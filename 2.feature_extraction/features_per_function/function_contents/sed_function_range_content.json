{
  "sed/sed-4.5/basicdefs.h": {},
  "sed/sed-4.5/gnulib-tests/accept.c": {
    "rpl_accept": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "int\nrpl_accept (int fd, struct sockaddr *addr, socklen_t *addrlen)\n{\n  SOCKET sock = FD_TO_SOCKET (fd);\n\n  if (sock == INVALID_SOCKET)\n    {\n      errno = EBADF;\n      return -1;\n    }\n  else\n    {\n      SOCKET fh = accept (sock, addr, addrlen);\n      if (fh == INVALID_SOCKET)\n        {\n          set_winsock_errno ();\n          return -1;\n        }\n      else\n        return SOCKET_TO_FD (fh);\n    }\n}",
      "lines": 22,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/arg-nonnull.h": {},
  "sed/sed-4.5/gnulib-tests/arpa_inet.in.h": {},
  "sed/sed-4.5/gnulib-tests/binary-io.c": {
    "__gl_setmode_check": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        35,
        1
      ],
      "content": "int\n__gl_setmode_check (int fd)\n{\n  if (isatty (fd))\n    {\n      errno = EINVAL;\n      return -1;\n    }\n  else\n    return 0;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/binary-io.h": {
    "__gl_setmode": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "BINARY_IO_INLINE int\n__gl_setmode (int fd _GL_UNUSED, int mode _GL_UNUSED)\n{\n  return O_BINARY;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "BINARY_IO_INLINE",
        "int",
        "int"
      ]
    },
    "__gl_setmode_check": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        59,
        52
      ],
      "content": "BINARY_IO_INLINE int\n__gl_setmode_check (int fd _GL_UNUSED) { return 0; }",
      "lines": 2,
      "depth": 6,
      "decorators": [
        "BINARY_IO_INLINE",
        "int",
        "int"
      ]
    },
    "set_binary_mode": {
      "start_point": [
        68,
        0
      ],
      "end_point": [
        73,
        1
      ],
      "content": "BINARY_IO_INLINE int\nset_binary_mode (int fd, int mode)\n{\n  int r = __gl_setmode_check (fd);\n  return r != 0 ? r : __gl_setmode (fd, mode);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "BINARY_IO_INLINE",
        "int",
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/bind.c": {
    "rpl_bind": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "int\nrpl_bind (int fd, const struct sockaddr *sockaddr, socklen_t len)\n{\n  SOCKET sock = FD_TO_SOCKET (fd);\n\n  if (sock == INVALID_SOCKET)\n    {\n      errno = EBADF;\n      return -1;\n    }\n  else\n    {\n      int r = bind (sock, sockaddr, len);\n      if (r < 0)\n        set_winsock_errno ();\n\n      return r;\n    }\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/c++defs.h": {},
  "sed/sed-4.5/gnulib-tests/cloexec.c": {
    "set_cloexec_flag": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "int\nset_cloexec_flag (int desc, bool value)\n{\n#ifdef F_SETFD\n\n  int flags = fcntl (desc, F_GETFD, 0);\n\n  if (0 <= flags)\n    {\n      int newflags = (value ? flags | FD_CLOEXEC : flags & ~FD_CLOEXEC);\n\n      if (flags == newflags\n          || fcntl (desc, F_SETFD, newflags) != -1)\n        return 0;\n    }\n\n  return -1;\n\n#else /* !F_SETFD */\n\n  /* Use dup2 to reject invalid file descriptors; the cloexec flag\n     will be unaffected.  */\n  if (desc < 0)\n    {\n      errno = EBADF;\n      return -1;\n    }\n  if (dup2 (desc, desc) < 0)\n    /* errno is EBADF here.  */\n    return -1;\n\n  /* There is nothing we can do on this kind of platform.  Punt.  */\n  return 0;\n#endif /* !F_SETFD */\n}",
      "lines": 35,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "dup_cloexec": {
      "start_point": [
        78,
        0
      ],
      "end_point": [
        82,
        1
      ],
      "content": "int\ndup_cloexec (int fd)\n{\n  return fcntl (fd, F_DUPFD_CLOEXEC, 0);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/cloexec.h": {},
  "sed/sed-4.5/gnulib-tests/close.c": {
    "close_nothrow": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        39,
        5
      ],
      "content": "static int\nclose_nothrow (int fd)\n{\n  int result;\n\n  TRY_MSVC_INVAL\n    {\n      result = close (fd);\n    }",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_close": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "int\nrpl_close (int fd)\n{\n#if WINDOWS_SOCKETS\n  int retval = execute_all_close_hooks (close_nothrow, fd);\n#else\n  int retval = close_nothrow (fd);\n#endif\n\n#if REPLACE_FCHDIR\n  if (retval >= 0)\n    _gl_unregister_fd (fd);\n#endif\n\n  return retval;\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/closedir.c": {
    "closedir": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "int\nclosedir (DIR *dirp)\n{\n# if REPLACE_FCHDIR || REPLACE_DIRFD\n  int fd = dirfd (dirp);\n# endif\n  int retval;\n\n#if HAVE_CLOSEDIR\n# undef closedir\n\n  retval = closedir (dirp);\n\n# ifdef __KLIBC__\n  if (!retval)\n    _gl_unregister_dirp_fd (fd);\n# endif\n#else\n\n  if (dirp->current != INVALID_HANDLE_VALUE)\n    FindClose (dirp->current);\n  free (dirp);\n\n  retval = 0;\n\n#endif\n\n#if REPLACE_FCHDIR\n  if (retval >= 0)\n    _gl_unregister_fd (fd);\n#endif\n  return retval;\n}",
      "lines": 33,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/connect.c": {
    "rpl_connect": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "int\nrpl_connect (int fd, const struct sockaddr *sockaddr, socklen_t len)\n{\n  SOCKET sock = FD_TO_SOCKET (fd);\n\n  if (sock == INVALID_SOCKET)\n    {\n      errno = EBADF;\n      return -1;\n    }\n  else\n    {\n      int r = connect (sock, sockaddr, len);\n      if (r < 0)\n        {\n          /* EINPROGRESS is not returned by WinSock 2.0; for backwards\n             compatibility, connect(2) uses EWOULDBLOCK.  */\n          if (WSAGetLastError () == WSAEWOULDBLOCK)\n            WSASetLastError (WSAEINPROGRESS);\n\n          set_winsock_errno ();\n        }\n\n      return r;\n    }\n}",
      "lines": 26,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/dfa-match-aux.c": {
    "dfaerror": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        35,
        1
      ],
      "content": "_Noreturn void\ndfaerror (char const *mesg)\n{\n  printf (\"dfaerror: %s\\n\", mesg);\n  exit (EXIT_FAILURE);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "_Noreturn",
        "void",
        "void"
      ]
    },
    "dfawarn": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        42,
        1
      ],
      "content": "_Noreturn void\ndfawarn (char const *mesg)\n{\n  printf (\"dfawarn: %s\\n\", mesg);\n  exit (EXIT_FAILURE);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "_Noreturn",
        "void",
        "void"
      ]
    },
    "main": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  struct dfa *dfa;\n  char *beg, *end, *p;\n  int allow_nl;\n  struct localeinfo localeinfo;\n\n  if (argc < 3)\n    exit (EXIT_FAILURE);\n\n  setlocale (LC_ALL, \"\");\n  init_localeinfo (&localeinfo);\n\n  dfa = dfaalloc ();\n  dfasyntax (dfa, &localeinfo, RE_SYNTAX_GREP | RE_NO_EMPTY_RANGES, 0);\n  dfacomp (argv[1], strlen (argv[1]), dfa, 0);\n\n  beg = argv[2];\n  end = argv[2] + strlen (argv[2]);\n  allow_nl = argc > 3 && atoi (argv[3]);\n\n  p = dfaexec (dfa, beg, end, allow_nl, NULL, NULL);\n\n  if (p != NULL)\n    printf (\"%zd\\n\", p - beg);\n\n  exit (EXIT_SUCCESS);\n}",
      "lines": 29,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/dirent-private.h": {},
  "sed/sed-4.5/gnulib-tests/dirent.in.h": {
    "dirfd": {
      "start_point": [
        171,
        0
      ],
      "end_point": [
        171,
        58
      ],
      "content": "static inline int (dirfd) (DIR *dp) { return dirfd (dp); }",
      "lines": 1,
      "depth": 6,
      "decorators": null
    }
  },
  "sed/sed-4.5/gnulib-tests/dirfd.c": {
    "_gl_register_dirp_fd": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "int\n_gl_register_dirp_fd (int fd, DIR *dirp)\n{\n  struct dirp_fd_list *new_dirp_fd = malloc (sizeof *new_dirp_fd);\n  if (!new_dirp_fd)\n    return -1;\n\n  new_dirp_fd->dirp = dirp;\n  new_dirp_fd->fd = fd;\n  new_dirp_fd->next = dirp_fd_start;\n\n  dirp_fd_start = new_dirp_fd;\n\n  return 0;\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "_gl_unregister_dirp_fd": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "void\n_gl_unregister_dirp_fd (int fd)\n{\n  struct dirp_fd_list *dirp_fd;\n  struct dirp_fd_list *dirp_fd_prev;\n\n  for (dirp_fd_prev = NULL, dirp_fd = dirp_fd_start; dirp_fd;\n       dirp_fd_prev = dirp_fd, dirp_fd = dirp_fd->next)\n    {\n      if (dirp_fd->fd == fd)\n        {\n          if (dirp_fd_prev)\n            dirp_fd_prev->next = dirp_fd->next;\n          else  /* dirp_fd == dirp_fd_start */\n            dirp_fd_start = dirp_fd_start->next;\n\n          close (fd);\n          free (dirp_fd);\n          break;\n        }\n    }\n}",
      "lines": 22,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "dirfd": {
      "start_point": [
        77,
        0
      ],
      "end_point": [
        97,
        1
      ],
      "content": "int\ndirfd (DIR *dir_p)\n{\n  int fd = DIR_TO_FD (dir_p);\n  if (fd == -1)\n#ifndef __KLIBC__\n    errno = ENOTSUP;\n#else\n    {\n      struct dirp_fd_list *dirp_fd;\n\n      for (dirp_fd = dirp_fd_start; dirp_fd; dirp_fd = dirp_fd->next)\n        if (dirp_fd->dirp == dir_p)\n          return dirp_fd->fd;\n\n      errno = EINVAL;\n    }\n#endif\n\n  return fd;\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/dup2.c": {
    "dup2_nothrow": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        57,
        5
      ],
      "content": "static int\ndup2_nothrow (int fd, int desired_fd)\n{\n  int result;\n\n  TRY_MSVC_INVAL\n    {\n      result = dup2 (fd, desired_fd);\n    }",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "ms_windows_dup2": {
      "start_point": [
        71,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "static int\nms_windows_dup2 (int fd, int desired_fd)\n{\n  int result;\n\n  /* If fd is closed, mingw hangs on dup2 (fd, fd).  If fd is open,\n     dup2 (fd, fd) returns 0, but all further attempts to use fd in\n     future dup2 calls will hang.  */\n  if (fd == desired_fd)\n    {\n      if ((HANDLE) _get_osfhandle (fd) == INVALID_HANDLE_VALUE)\n        {\n          errno = EBADF;\n          return -1;\n        }\n      return fd;\n    }\n\n  /* Wine 1.0.1 return 0 when desired_fd is negative but not -1:\n     https://bugs.winehq.org/show_bug.cgi?id=21289 */\n  if (desired_fd < 0)\n    {\n      errno = EBADF;\n      return -1;\n    }\n\n  result = dup2_nothrow (fd, desired_fd);\n\n  if (result == 0)\n    result = desired_fd;\n\n  return result;\n}",
      "lines": 33,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "klibc_dup2dirfd": {
      "start_point": [
        111,
        0
      ],
      "end_point": [
        137,
        1
      ],
      "content": "static int\nklibc_dup2dirfd (int fd, int desired_fd)\n{\n  int tempfd;\n  int dupfd;\n\n  tempfd = open (\"NUL\", O_RDONLY);\n  if (tempfd == -1)\n    return -1;\n\n  if (tempfd == desired_fd)\n    {\n      close (tempfd);\n\n      char path[_MAX_PATH];\n      if (__libc_Back_ioFHToPath (fd, path, sizeof (path)))\n        return -1;\n\n      return open(path, O_RDONLY);\n    }\n\n  dupfd = klibc_dup2dirfd (fd, desired_fd);\n\n  close (tempfd);\n\n  return dupfd;\n}",
      "lines": 27,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "klibc_dup2": {
      "start_point": [
        139,
        0
      ],
      "end_point": [
        155,
        1
      ],
      "content": "static int\nklibc_dup2 (int fd, int desired_fd)\n{\n  int dupfd;\n  struct stat sbuf;\n\n  dupfd = dup2 (fd, desired_fd);\n  if (dupfd == -1 && errno == ENOTSUP \\\n      && !fstat (fd, &sbuf) && S_ISDIR (sbuf.st_mode))\n    {\n      close (desired_fd);\n\n      return klibc_dup2dirfd (fd, desired_fd);\n    }\n\n  return dupfd;\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_dup2": {
      "start_point": [
        160,
        0
      ],
      "end_point": [
        190,
        1
      ],
      "content": "int\nrpl_dup2 (int fd, int desired_fd)\n{\n  int result;\n\n# ifdef F_GETFL\n  /* On Linux kernels 2.6.26-2.6.29, dup2 (fd, fd) returns -EBADF.\n     On Cygwin 1.5.x, dup2 (1, 1) returns 0.\n     On Cygwin 1.7.17, dup2 (1, -1) dumps core.\n     On Cygwin 1.7.25, dup2 (1, 256) can dump core.\n     On Haiku, dup2 (fd, fd) mistakenly clears FD_CLOEXEC.  */\n#  if HAVE_SETDTABLESIZE\n  setdtablesize (desired_fd + 1);\n#  endif\n  if (desired_fd < 0)\n    fd = desired_fd;\n  if (fd == desired_fd)\n    return fcntl (fd, F_GETFL) == -1 ? -1 : fd;\n# endif\n\n  result = dup2 (fd, desired_fd);\n\n  /* Correct an errno value on FreeBSD 6.1 and Cygwin 1.5.x.  */\n  if (result == -1 && errno == EMFILE)\n    errno = EBADF;\n# if REPLACE_FCHDIR\n  if (fd != desired_fd && result != -1)\n    result = _gl_register_dup (fd, result);\n# endif\n  return result;\n}",
      "lines": 31,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "dupfd": {
      "start_point": [
        197,
        0
      ],
      "end_point": [
        211,
        1
      ],
      "content": "static int\ndupfd (int fd, int desired_fd)\n{\n  int duplicated_fd = dup (fd);\n  if (duplicated_fd < 0 || duplicated_fd == desired_fd)\n    return duplicated_fd;\n  else\n    {\n      int r = dupfd (fd, desired_fd);\n      int e = errno;\n      close (duplicated_fd);\n      errno = e;\n      return r;\n    }\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "dup2": {
      "start_point": [
        214,
        0
      ],
      "end_point": [
        233,
        1
      ],
      "content": "int\ndup2 (int fd, int desired_fd)\n{\n  int result = fcntl (fd, F_GETFL) < 0 ? -1 : fd;\n  if (result == -1 || fd == desired_fd)\n    return result;\n  close (desired_fd);\n# ifdef F_DUPFD\n  result = fcntl (fd, F_DUPFD, desired_fd);\n#  if REPLACE_FCHDIR\n  if (0 <= result)\n    result = _gl_register_dup (fd, result);\n#  endif\n# else\n  result = dupfd (fd, desired_fd);\n# endif\n  if (result == -1 && (errno == EMFILE || errno == EINVAL))\n    errno = EBADF;\n  return result;\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/fcntl.c": {
    "dupfd": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        165,
        1
      ],
      "content": "static int\ndupfd (int oldfd, int newfd, int flags)\n{\n  /* Mingw has no way to create an arbitrary fd.  Iterate until all\n     file descriptors less than newfd are filled up.  */\n  HANDLE curr_process = GetCurrentProcess ();\n  HANDLE old_handle = (HANDLE) _get_osfhandle (oldfd);\n  unsigned char fds_to_close[OPEN_MAX_MAX / CHAR_BIT];\n  unsigned int fds_to_close_bound = 0;\n  int result;\n  BOOL inherit = flags & O_CLOEXEC ? FALSE : TRUE;\n  int mode;\n\n  if (newfd < 0 || getdtablesize () <= newfd)\n    {\n      errno = EINVAL;\n      return -1;\n    }\n  if (old_handle == INVALID_HANDLE_VALUE\n      || (mode = setmode (oldfd, O_BINARY)) == -1)\n    {\n      /* oldfd is not open, or is an unassigned standard file\n         descriptor.  */\n      errno = EBADF;\n      return -1;\n    }\n  setmode (oldfd, mode);\n  flags |= mode;\n\n  for (;;)\n    {\n      HANDLE new_handle;\n      int duplicated_fd;\n      unsigned int index;\n\n      if (!DuplicateHandle (curr_process,           /* SourceProcessHandle */\n                            old_handle,             /* SourceHandle */\n                            curr_process,           /* TargetProcessHandle */\n                            (PHANDLE) &new_handle,  /* TargetHandle */\n                            (DWORD) 0,              /* DesiredAccess */\n                            inherit,                /* InheritHandle */\n                            DUPLICATE_SAME_ACCESS)) /* Options */\n        {\n          switch (GetLastError ())\n            {\n              case ERROR_TOO_MANY_OPEN_FILES:\n                errno = EMFILE;\n                break;\n              case ERROR_INVALID_HANDLE:\n              case ERROR_INVALID_TARGET_HANDLE:\n              case ERROR_DIRECT_ACCESS_HANDLE:\n                errno = EBADF;\n                break;\n              case ERROR_INVALID_PARAMETER:\n              case ERROR_INVALID_FUNCTION:\n              case ERROR_INVALID_ACCESS:\n                errno = EINVAL;\n                break;\n              default:\n                errno = EACCES;\n                break;\n            }\n          result = -1;\n          break;\n        }\n      duplicated_fd = _open_osfhandle ((intptr_t) new_handle, flags);\n      if (duplicated_fd < 0)\n        {\n          CloseHandle (new_handle);\n          result = -1;\n          break;\n        }\n      if (newfd <= duplicated_fd)\n        {\n          result = duplicated_fd;\n          break;\n        }\n\n      /* Set the bit duplicated_fd in fds_to_close[].  */\n      index = (unsigned int) duplicated_fd / CHAR_BIT;\n      if (fds_to_close_bound <= index)\n        {\n          if (sizeof fds_to_close <= index)\n            /* Need to increase OPEN_MAX_MAX.  */\n            abort ();\n          memset (fds_to_close + fds_to_close_bound, '\\0',\n                  index + 1 - fds_to_close_bound);\n          fds_to_close_bound = index + 1;\n        }\n      fds_to_close[index] |= 1 << ((unsigned int) duplicated_fd % CHAR_BIT);\n    }\n\n  /* Close the previous fds that turned out to be too small.  */\n  {\n    int saved_errno = errno;\n    unsigned int duplicated_fd;\n\n    for (duplicated_fd = 0;\n         duplicated_fd < fds_to_close_bound * CHAR_BIT;\n         duplicated_fd++)\n      if ((fds_to_close[duplicated_fd / CHAR_BIT]\n           >> (duplicated_fd % CHAR_BIT))\n          & 1)\n        close (duplicated_fd);\n\n    errno = saved_errno;\n  }\n\n# if REPLACE_FCHDIR\n  if (0 <= result)\n    result = _gl_register_dup (oldfd, result);\n# endif\n  return result;\n}",
      "lines": 114,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "klibc_fcntl": {
      "start_point": [
        173,
        0
      ],
      "end_point": [
        250,
        1
      ],
      "content": "static int\nklibc_fcntl (int fd, int action, /* arg */...)\n{\n  va_list arg_ptr;\n  int arg;\n  struct stat sbuf;\n  int result = -1;\n\n  va_start (arg_ptr, action);\n  arg = va_arg (arg_ptr, int);\n  result = fcntl (fd, action, arg);\n  /* EPERM for F_DUPFD, ENOTSUP for others */\n  if (result == -1 && (errno == EPERM || errno == ENOTSUP)\n      && !fstat (fd, &sbuf) && S_ISDIR (sbuf.st_mode))\n  {\n    ULONG ulMode;\n\n    switch (action)\n      {\n      case F_DUPFD:\n        /* Find available fd */\n        while (fcntl (arg, F_GETFL) != -1 || errno != EBADF)\n          arg++;\n\n        result = dup2 (fd, arg);\n        break;\n\n      /* Using underlying APIs is right ? */\n      case F_GETFD:\n        if (DosQueryFHState (fd, &ulMode))\n          break;\n\n        result = (ulMode & OPEN_FLAGS_NOINHERIT) ? FD_CLOEXEC : 0;\n        break;\n\n      case F_SETFD:\n        if (arg & ~FD_CLOEXEC)\n          break;\n\n        if (DosQueryFHState (fd, &ulMode))\n          break;\n\n        if (arg & FD_CLOEXEC)\n          ulMode |= OPEN_FLAGS_NOINHERIT;\n        else\n          ulMode &= ~OPEN_FLAGS_NOINHERIT;\n\n        /* Filter supported flags.  */\n        ulMode &= (OPEN_FLAGS_WRITE_THROUGH | OPEN_FLAGS_FAIL_ON_ERROR\n                   | OPEN_FLAGS_NO_CACHE | OPEN_FLAGS_NOINHERIT);\n\n        if (DosSetFHState (fd, ulMode))\n          break;\n\n        result = 0;\n        break;\n\n      case F_GETFL:\n        result = 0;\n        break;\n\n      case F_SETFL:\n        if (arg != 0)\n          break;\n\n        result = 0;\n        break;\n\n      default :\n        errno = EINVAL;\n        break;\n      }\n  }\n\n  va_end (arg_ptr);\n\n  return result;\n}",
      "lines": 78,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_fcntl": {
      "start_point": [
        274,
        0
      ],
      "end_point": [
        417,
        1
      ],
      "content": "int\nrpl_fcntl (int fd, int action, /* arg */...)\n{\n  va_list arg;\n  int result = -1;\n  va_start (arg, action);\n  switch (action)\n    {\n\n#if !HAVE_FCNTL\n    case F_DUPFD:\n      {\n        int target = va_arg (arg, int);\n        result = dupfd (fd, target, 0);\n        break;\n      }\n#elif FCNTL_DUPFD_BUGGY || REPLACE_FCHDIR\n    case F_DUPFD:\n      {\n        int target = va_arg (arg, int);\n        /* Detect invalid target; needed for cygwin 1.5.x.  */\n        if (target < 0 || getdtablesize () <= target)\n          errno = EINVAL;\n        else\n          {\n            /* Haiku alpha 2 loses fd flags on original.  */\n            int flags = fcntl (fd, F_GETFD);\n            if (flags < 0)\n              {\n                result = -1;\n                break;\n              }\n            result = fcntl (fd, action, target);\n            if (0 <= result && fcntl (fd, F_SETFD, flags) == -1)\n              {\n                int saved_errno = errno;\n                close (result);\n                result = -1;\n                errno = saved_errno;\n              }\n# if REPLACE_FCHDIR\n            if (0 <= result)\n              result = _gl_register_dup (fd, result);\n# endif\n          }\n        break;\n      } /* F_DUPFD */\n#endif /* FCNTL_DUPFD_BUGGY || REPLACE_FCHDIR */\n\n    case F_DUPFD_CLOEXEC:\n      {\n        int target = va_arg (arg, int);\n\n#if !HAVE_FCNTL\n        result = dupfd (fd, target, O_CLOEXEC);\n        break;\n#else /* HAVE_FCNTL */\n        /* Try the system call first, if the headers claim it exists\n           (that is, if GNULIB_defined_F_DUPFD_CLOEXEC is 0), since we\n           may be running with a glibc that has the macro but with an\n           older kernel that does not support it.  Cache the\n           information on whether the system call really works, but\n           avoid caching failure if the corresponding F_DUPFD fails\n           for any reason.  0 = unknown, 1 = yes, -1 = no.  */\n        static int have_dupfd_cloexec = GNULIB_defined_F_DUPFD_CLOEXEC ? -1 : 0;\n        if (0 <= have_dupfd_cloexec)\n          {\n            result = fcntl (fd, action, target);\n            if (0 <= result || errno != EINVAL)\n              {\n                have_dupfd_cloexec = 1;\n# if REPLACE_FCHDIR\n                if (0 <= result)\n                  result = _gl_register_dup (fd, result);\n# endif\n              }\n            else\n              {\n                result = rpl_fcntl (fd, F_DUPFD, target);\n                if (result < 0)\n                  break;\n                have_dupfd_cloexec = -1;\n              }\n          }\n        else\n          result = rpl_fcntl (fd, F_DUPFD, target);\n        if (0 <= result && have_dupfd_cloexec == -1)\n          {\n            int flags = fcntl (result, F_GETFD);\n            if (flags < 0 || fcntl (result, F_SETFD, flags | FD_CLOEXEC) == -1)\n              {\n                int saved_errno = errno;\n                close (result);\n                errno = saved_errno;\n                result = -1;\n              }\n          }\n        break;\n#endif /* HAVE_FCNTL */\n      } /* F_DUPFD_CLOEXEC */\n\n#if !HAVE_FCNTL\n    case F_GETFD:\n      {\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n        HANDLE handle = (HANDLE) _get_osfhandle (fd);\n        DWORD flags;\n        if (handle == INVALID_HANDLE_VALUE\n            || GetHandleInformation (handle, &flags) == 0)\n          errno = EBADF;\n        else\n          result = (flags & HANDLE_FLAG_INHERIT) ? 0 : FD_CLOEXEC;\n# else /* !W32 */\n        /* Use dup2 to reject invalid file descriptors.  No way to\n           access this information, so punt.  */\n        if (0 <= dup2 (fd, fd))\n          result = 0;\n# endif /* !W32 */\n        break;\n      } /* F_GETFD */\n#endif /* !HAVE_FCNTL */\n\n      /* Implementing F_SETFD on mingw is not trivial - there is no\n         API for changing the O_NOINHERIT bit on an fd, and merely\n         changing the HANDLE_FLAG_INHERIT bit on the underlying handle\n         can lead to odd state.  It may be possible by duplicating the\n         handle, using _open_osfhandle with the right flags, then\n         using dup2 to move the duplicate onto the original, but that\n         is not supported for now.  */\n\n    default:\n      {\n#if HAVE_FCNTL\n        void *p = va_arg (arg, void *);\n        result = fcntl (fd, action, p);\n#else\n        errno = EINVAL;\n#endif\n        break;\n      }\n    }\n  va_end (arg);\n  return result;\n}",
      "lines": 144,
      "depth": 19,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/fd-hook.c": {
    "execute_close_hooks": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        42,
        1
      ],
      "content": "int\nexecute_close_hooks (const struct fd_hook *remaining_list, gl_close_fn primary,\n                     int fd)\n{\n  if (remaining_list == &anchor)\n    /* End of list reached.  */\n    return primary (fd);\n  else\n    return remaining_list->private_close_fn (remaining_list->private_next,\n                                             primary, fd);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "execute_all_close_hooks": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "int\nexecute_all_close_hooks (gl_close_fn primary, int fd)\n{\n  return execute_close_hooks (anchor.private_next, primary, fd);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "execute_ioctl_hooks": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "int\nexecute_ioctl_hooks (const struct fd_hook *remaining_list, gl_ioctl_fn primary,\n                     int fd, int request, void *arg)\n{\n  if (remaining_list == &anchor)\n    /* End of list reached.  */\n    return primary (fd, request, arg);\n  else\n    return remaining_list->private_ioctl_fn (remaining_list->private_next,\n                                             primary, fd, request, arg);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "execute_all_ioctl_hooks": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "int\nexecute_all_ioctl_hooks (gl_ioctl_fn primary,\n                         int fd, int request, void *arg)\n{\n  return execute_ioctl_hooks (anchor.private_next, primary, fd, request, arg);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "register_fd_hook": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "void\nregister_fd_hook (close_hook_fn close_hook, ioctl_hook_fn ioctl_hook, struct fd_hook *link)\n{\n  if (close_hook == NULL)\n    close_hook = execute_close_hooks;\n  if (ioctl_hook == NULL)\n    ioctl_hook = execute_ioctl_hooks;\n\n  if (link->private_next == NULL && link->private_prev == NULL)\n    {\n      /* Add the link to the doubly linked list.  */\n      link->private_next = anchor.private_next;\n      link->private_prev = &anchor;\n      link->private_close_fn = close_hook;\n      link->private_ioctl_fn = ioctl_hook;\n      anchor.private_next->private_prev = link;\n      anchor.private_next = link;\n    }\n  else\n    {\n      /* The link is already in use.  */\n      if (link->private_close_fn != close_hook\n          || link->private_ioctl_fn != ioctl_hook)\n        abort ();\n    }\n}",
      "lines": 26,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "unregister_fd_hook": {
      "start_point": [
        96,
        0
      ],
      "end_point": [
        113,
        1
      ],
      "content": "void\nunregister_fd_hook (struct fd_hook *link)\n{\n  struct fd_hook *next = link->private_next;\n  struct fd_hook *prev = link->private_prev;\n\n  if (next != NULL && prev != NULL)\n    {\n      /* The link is in use.  Remove it from the doubly linked list.  */\n      prev->private_next = next;\n      next->private_prev = prev;\n      /* Clear the link, to mark it unused.  */\n      link->private_next = NULL;\n      link->private_prev = NULL;\n      link->private_close_fn = NULL;\n      link->private_ioctl_fn = NULL;\n    }\n}",
      "lines": 18,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/fd-hook.h": {},
  "sed/sed-4.5/gnulib-tests/fdopen.c": {
    "fdopen_nothrow": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        38,
        5
      ],
      "content": "static FILE *\nfdopen_nothrow (int fd, const char *mode)\n{\n  FILE *result;\n\n  TRY_MSVC_INVAL\n    {\n      result = fdopen (fd, mode);\n    }",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "FILE",
        "*\nfdopen_nothrow (int fd, const char *mode)",
        "*"
      ]
    },
    "rpl_fdopen": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "FILE *\nrpl_fdopen (int fd, const char *mode)\n{\n  int saved_errno = errno;\n  FILE *fp;\n\n  errno = 0;\n  fp = fdopen_nothrow (fd, mode);\n  if (fp == NULL)\n    {\n      if (errno == 0)\n        errno = EBADF;\n    }\n  else\n    errno = saved_errno;\n\n  return fp;\n}",
      "lines": 18,
      "depth": 8,
      "decorators": [
        "FILE",
        "*\nrpl_fdopen (int fd, const char *mode)",
        "*"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/fflush.c": {
    "clear_ungetc_buffer_preserving_position": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "static void\nclear_ungetc_buffer_preserving_position (FILE *fp)\n{\n  if (fp->_flags & _IO_IN_BACKUP)\n    /* _IO_free_backup_area is a bit complicated.  Simply call fseek.  */\n    fseeko (fp, 0, SEEK_CUR);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "clear_ungetc_buffer": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "static void\nclear_ungetc_buffer (FILE *fp)\n{\n# if defined __sferror || defined __DragonFly__ || defined __ANDROID__\n  /* FreeBSD, NetBSD, OpenBSD, DragonFly, Mac OS X, Cygwin, Minix 3, Android */\n  if (HASUB (fp))\n    {\n      fp_->_p += fp_->_r;\n      fp_->_r = 0;\n    }\n# elif defined __EMX__              /* emx+gcc */\n  if (fp->_ungetc_count > 0)\n    {\n      fp->_ungetc_count = 0;\n      fp->_rcount = - fp->_rcount;\n    }\n# elif defined _IOERR               /* Minix, AIX, HP-UX, IRIX, OSF/1, Solaris, OpenServer, mingw, MSVC, NonStop Kernel, OpenVMS */\n  /* Nothing to do.  */\n# else                              /* other implementations */\n  fseeko (fp, 0, SEEK_CUR);\n# endif\n}",
      "lines": 22,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "disable_seek_optimization": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        87,
        1
      ],
      "content": "static int\ndisable_seek_optimization (FILE *fp)\n{\n  int saved_flags = fp_->_flags & (__SOPT | __SNPT);\n  fp_->_flags = (fp_->_flags & ~__SOPT) | __SNPT;\n  return saved_flags;\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "restore_seek_optimization": {
      "start_point": [
        89,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "static void\nrestore_seek_optimization (FILE *fp, int saved_flags)\n{\n  fp_->_flags = (fp_->_flags & ~(__SOPT | __SNPT)) | saved_flags;\n}",
      "lines": 5,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "update_fpos_cache": {
      "start_point": [
        97,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "static void\nupdate_fpos_cache (FILE *fp _GL_UNUSED_PARAMETER,\n                   off_t pos _GL_UNUSED_PARAMETER)\n{\n#  if defined __sferror || defined __DragonFly__ || defined __ANDROID__\n  /* FreeBSD, NetBSD, OpenBSD, DragonFly, Mac OS X, Cygwin, Minix 3, Android */\n#   if defined __CYGWIN__\n  /* fp_->_offset is typed as an integer.  */\n  fp_->_offset = pos;\n#   else\n  /* fp_->_offset is an fpos_t.  */\n  /* Use a union, since on NetBSD, the compilation flags determine\n     whether fpos_t is typedef'd to off_t or a struct containing a\n     single off_t member.  */\n  union\n    {\n      fpos_t f;\n      off_t o;\n    } u;\n  u.o = pos;\n  fp_->_offset = u.f;\n#   endif\n  fp_->_flags |= __SOFF;\n#  endif\n}",
      "lines": 25,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "rpl_fflush": {
      "start_point": [
        127,
        0
      ],
      "end_point": [
        231,
        1
      ],
      "content": "int\nrpl_fflush (FILE *stream)\n{\n  /* When stream is NULL, POSIX and C99 only require flushing of \"output\n     streams and update streams in which the most recent operation was not\n     input\", and all implementations do this.\n\n     When stream is \"an output stream or an update stream in which the most\n     recent operation was not input\", POSIX and C99 requires that fflush\n     writes out any buffered data, and all implementations do this.\n\n     When stream is, however, an input stream or an update stream in\n     which the most recent operation was input, C99 specifies nothing,\n     and POSIX only specifies behavior if the stream is seekable.\n     mingw, in particular, drops the input buffer, leaving the file\n     descriptor positioned at the end of the input buffer. I.e. ftell\n     (stream) is lost.  We don't want to call the implementation's\n     fflush in this case.\n\n     We test ! freading (stream) here, rather than fwriting (stream), because\n     what we need to know is whether the stream holds a \"read buffer\", and on\n     mingw this is indicated by _IOREAD, regardless of _IOWRT.  */\n  if (stream == NULL || ! freading (stream))\n    return fflush (stream);\n\n#if defined _IO_EOF_SEEN || defined _IO_ftrylockfile || __GNU_LIBRARY__ == 1\n  /* GNU libc, BeOS, Haiku, Linux libc5 */\n\n  clear_ungetc_buffer_preserving_position (stream);\n\n  return fflush (stream);\n\n#else\n  {\n    /* Notes about the file-position indicator:\n       1) The file position indicator is incremented by fgetc() and decremented\n          by ungetc():\n          <http://www.opengroup.org/susv3/functions/fgetc.html>\n            \"... the fgetc() function shall ... advance the associated file\n             position indicator for the stream ...\"\n          <http://www.opengroup.org/susv3/functions/ungetc.html>\n            \"The file-position indicator is decremented by each successful\n             call to ungetc()...\"\n       2) <http://www.opengroup.org/susv3/functions/ungetc.html> says:\n            \"The value of the file-position indicator for the stream after\n             reading or discarding all pushed-back bytes shall be the same\n             as it was before the bytes were pushed back.\"\n          Here we are discarding all pushed-back bytes.  But more specifically,\n       3) <http://www.opengroup.org/austin/aardvark/latest/xshbug3.txt> says:\n            \"[After fflush(),] the file offset of the underlying open file\n             description shall be set to the file position of the stream, and\n             any characters pushed back onto the stream by ungetc() ... shall\n             be discarded.\"  */\n\n    /* POSIX does not specify fflush behavior for non-seekable input\n       streams.  Some implementations purge unread data, some return\n       EBADF, some do nothing.  */\n    off_t pos = ftello (stream);\n    if (pos == -1)\n      {\n        errno = EBADF;\n        return EOF;\n      }\n\n    /* Clear the ungetc buffer.  */\n    clear_ungetc_buffer (stream);\n\n    /* To get here, we must be flushing a seekable input stream, so the\n       semantics of fpurge are now appropriate to clear the buffer.  To\n       avoid losing data, the lseek is also necessary.  */\n    {\n      int result = fpurge (stream);\n      if (result != 0)\n        return result;\n    }\n\n# if (defined __sferror || defined __DragonFly__ || defined __ANDROID__) && defined __SNPT\n    /* FreeBSD, NetBSD, OpenBSD, DragonFly, Mac OS X, Cygwin, Minix 3, Android */\n\n    {\n      /* Disable seek optimization for the next fseeko call.  This tells the\n         following fseeko call to seek to the desired position directly, rather\n         than to seek to a block-aligned boundary.  */\n      int saved_flags = disable_seek_optimization (stream);\n      int result = fseeko (stream, pos, SEEK_SET);\n\n      restore_seek_optimization (stream, saved_flags);\n      return result;\n    }\n\n# else\n\n    pos = lseek (fileno (stream), pos, SEEK_SET);\n    if (pos == -1)\n      return EOF;\n    /* After a successful lseek, update the file descriptor's position cache\n       in the stream.  */\n    update_fpos_cache (stream, pos);\n\n    return 0;\n\n# endif\n  }\n#endif\n}",
      "lines": 105,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/file-has-acl.c": {
    "file_has_acl": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        502,
        1
      ],
      "content": "int\nfile_has_acl (char const *name, struct stat const *sb)\n{\n#if USE_ACL\n  if (! S_ISLNK (sb->st_mode))\n    {\n\n# if GETXATTR_WITH_POSIX_ACLS\n\n      ssize_t ret;\n\n      ret = getxattr (name, XATTR_NAME_POSIX_ACL_ACCESS, NULL, 0);\n      if (ret < 0 && errno == ENODATA)\n        ret = 0;\n      else if (ret > 0)\n        return 1;\n\n      if (ret == 0 && S_ISDIR (sb->st_mode))\n        {\n          ret = getxattr (name, XATTR_NAME_POSIX_ACL_DEFAULT, NULL, 0);\n          if (ret < 0 && errno == ENODATA)\n            ret = 0;\n          else if (ret > 0)\n            return 1;\n        }\n\n      if (ret < 0)\n        return - acl_errno_valid (errno);\n      return ret;\n\n# elif HAVE_ACL_GET_FILE\n\n      /* POSIX 1003.1e (draft 17 -- abandoned) specific version.  */\n      /* Linux, FreeBSD, Mac OS X, IRIX, Tru64 */\n      int ret;\n\n      if (HAVE_ACL_EXTENDED_FILE) /* Linux */\n        {\n          /* On Linux, acl_extended_file is an optimized function: It only\n             makes two calls to getxattr(), one for ACL_TYPE_ACCESS, one for\n             ACL_TYPE_DEFAULT.  */\n          ret = acl_extended_file (name);\n        }\n      else /* FreeBSD, Mac OS X, IRIX, Tru64 */\n        {\n#  if HAVE_ACL_TYPE_EXTENDED /* Mac OS X */\n          /* On Mac OS X, acl_get_file (name, ACL_TYPE_ACCESS)\n             and acl_get_file (name, ACL_TYPE_DEFAULT)\n             always return NULL / EINVAL.  There is no point in making\n             these two useless calls.  The real ACL is retrieved through\n             acl_get_file (name, ACL_TYPE_EXTENDED).  */\n          acl_t acl = acl_get_file (name, ACL_TYPE_EXTENDED);\n          if (acl)\n            {\n              ret = acl_extended_nontrivial (acl);\n              acl_free (acl);\n            }\n          else\n            ret = -1;\n#  else /* FreeBSD, IRIX, Tru64 */\n          acl_t acl = acl_get_file (name, ACL_TYPE_ACCESS);\n          if (acl)\n            {\n              int saved_errno;\n\n              ret = acl_access_nontrivial (acl);\n              saved_errno = errno;\n              acl_free (acl);\n              errno = saved_errno;\n#   if HAVE_ACL_FREE_TEXT /* Tru64 */\n              /* On OSF/1, acl_get_file (name, ACL_TYPE_DEFAULT) always\n                 returns NULL with errno not set.  There is no point in\n                 making this call.  */\n#   else /* FreeBSD, IRIX */\n              /* On Linux, FreeBSD, IRIX, acl_get_file (name, ACL_TYPE_ACCESS)\n                 and acl_get_file (name, ACL_TYPE_DEFAULT) on a directory\n                 either both succeed or both fail; it depends on the\n                 file system.  Therefore there is no point in making the second\n                 call if the first one already failed.  */\n              if (ret == 0 && S_ISDIR (sb->st_mode))\n                {\n                  acl = acl_get_file (name, ACL_TYPE_DEFAULT);\n                  if (acl)\n                    {\n                      ret = (0 < acl_entries (acl));\n                      acl_free (acl);\n                    }\n                  else\n                    ret = -1;\n                }\n#   endif\n            }\n          else\n            ret = -1;\n#  endif\n        }\n      if (ret < 0)\n        return - acl_errno_valid (errno);\n      return ret;\n\n# elif HAVE_FACL && defined GETACL /* Solaris, Cygwin, not HP-UX */\n\n#  if defined ACL_NO_TRIVIAL\n\n      /* Solaris 10 (newer version), which has additional API declared in\n         <sys/acl.h> (acl_t) and implemented in libsec (acl_set, acl_trivial,\n         acl_fromtext, ...).  */\n      return acl_trivial (name);\n\n#  else /* Solaris, Cygwin, general case */\n\n      /* Solaris 2.5 through Solaris 10, Cygwin, and contemporaneous versions\n         of Unixware.  The acl() call returns the access and default ACL both\n         at once.  */\n      {\n        /* Initially, try to read the entries into a stack-allocated buffer.\n           Use malloc if it does not fit.  */\n        enum\n          {\n            alloc_init = 4000 / sizeof (aclent_t), /* >= 3 */\n            alloc_max = MIN (INT_MAX, SIZE_MAX / sizeof (aclent_t))\n          };\n        aclent_t buf[alloc_init];\n        size_t alloc = alloc_init;\n        aclent_t *entries = buf;\n        aclent_t *malloced = NULL;\n        int count;\n\n        for (;;)\n          {\n            count = acl (name, GETACL, alloc, entries);\n            if (count < 0 && errno == ENOSPC)\n              {\n                /* Increase the size of the buffer.  */\n                free (malloced);\n                if (alloc > alloc_max / 2)\n                  {\n                    errno = ENOMEM;\n                    return -1;\n                  }\n                alloc = 2 * alloc; /* <= alloc_max */\n                entries = malloced =\n                  (aclent_t *) malloc (alloc * sizeof (aclent_t));\n                if (entries == NULL)\n                  {\n                    errno = ENOMEM;\n                    return -1;\n                  }\n                continue;\n              }\n            break;\n          }\n        if (count < 0)\n          {\n            if (errno == ENOSYS || errno == ENOTSUP)\n              ;\n            else\n              {\n                int saved_errno = errno;\n                free (malloced);\n                errno = saved_errno;\n                return -1;\n              }\n          }\n        else if (count == 0)\n          ;\n        else\n          {\n            /* Don't use MIN_ACL_ENTRIES:  It's set to 4 on Cygwin, but Cygwin\n               returns only 3 entries for files with no ACL.  But this is safe:\n               If there are more than 4 entries, there cannot be only the\n               \"user::\", \"group::\", \"other:\", and \"mask:\" entries.  */\n            if (count > 4)\n              {\n                free (malloced);\n                return 1;\n              }\n\n            if (acl_nontrivial (count, entries))\n              {\n                free (malloced);\n                return 1;\n              }\n          }\n        free (malloced);\n      }\n\n#   ifdef ACE_GETACL\n      /* Solaris also has a different variant of ACLs, used in ZFS and NFSv4\n         file systems (whereas the other ones are used in UFS file systems).  */\n      {\n        /* Initially, try to read the entries into a stack-allocated buffer.\n           Use malloc if it does not fit.  */\n        enum\n          {\n            alloc_init = 4000 / sizeof (ace_t), /* >= 3 */\n            alloc_max = MIN (INT_MAX, SIZE_MAX / sizeof (ace_t))\n          };\n        ace_t buf[alloc_init];\n        size_t alloc = alloc_init;\n        ace_t *entries = buf;\n        ace_t *malloced = NULL;\n        int count;\n\n        for (;;)\n          {\n            count = acl (name, ACE_GETACL, alloc, entries);\n            if (count < 0 && errno == ENOSPC)\n              {\n                /* Increase the size of the buffer.  */\n                free (malloced);\n                if (alloc > alloc_max / 2)\n                  {\n                    errno = ENOMEM;\n                    return -1;\n                  }\n                alloc = 2 * alloc; /* <= alloc_max */\n                entries = malloced = (ace_t *) malloc (alloc * sizeof (ace_t));\n                if (entries == NULL)\n                  {\n                    errno = ENOMEM;\n                    return -1;\n                  }\n                continue;\n              }\n            break;\n          }\n        if (count < 0)\n          {\n            if (errno == ENOSYS || errno == EINVAL)\n              ;\n            else\n              {\n                int saved_errno = errno;\n                free (malloced);\n                errno = saved_errno;\n                return -1;\n              }\n          }\n        else if (count == 0)\n          ;\n        else\n          {\n            /* In the old (original Solaris 10) convention:\n               If there are more than 3 entries, there cannot be only the\n               ACE_OWNER, ACE_GROUP, ACE_OTHER entries.\n               In the newer Solaris 10 and Solaris 11 convention:\n               If there are more than 6 entries, there cannot be only the\n               ACE_OWNER, ACE_GROUP, ACE_EVERYONE entries, each once with\n               NEW_ACE_ACCESS_ALLOWED_ACE_TYPE and once with\n               NEW_ACE_ACCESS_DENIED_ACE_TYPE.  */\n            if (count > 6)\n              {\n                free (malloced);\n                return 1;\n              }\n\n            if (acl_ace_nontrivial (count, entries))\n              {\n                free (malloced);\n                return 1;\n              }\n          }\n        free (malloced);\n      }\n#   endif\n\n      return 0;\n#  endif\n\n# elif HAVE_GETACL /* HP-UX */\n\n      {\n        struct acl_entry entries[NACLENTRIES];\n        int count;\n\n        count = getacl (name, NACLENTRIES, entries);\n\n        if (count < 0)\n          {\n            /* ENOSYS is seen on newer HP-UX versions.\n               EOPNOTSUPP is typically seen on NFS mounts.\n               ENOTSUP was seen on Quantum StorNext file systems (cvfs).  */\n            if (errno == ENOSYS || errno == EOPNOTSUPP || errno == ENOTSUP)\n              ;\n            else\n              return -1;\n          }\n        else if (count == 0)\n          return 0;\n        else /* count > 0 */\n          {\n            if (count > NACLENTRIES)\n              /* If NACLENTRIES cannot be trusted, use dynamic memory\n                 allocation.  */\n              abort ();\n\n            /* If there are more than 3 entries, there cannot be only the\n               (uid,%), (%,gid), (%,%) entries.  */\n            if (count > 3)\n              return 1;\n\n            {\n              struct stat statbuf;\n\n              if (stat (name, &statbuf) < 0)\n                return -1;\n\n              return acl_nontrivial (count, entries);\n            }\n          }\n      }\n\n#  if HAVE_ACLV_H /* HP-UX >= 11.11 */\n\n      {\n        struct acl entries[NACLVENTRIES];\n        int count;\n\n        count = acl ((char *) name, ACL_GET, NACLVENTRIES, entries);\n\n        if (count < 0)\n          {\n            /* EOPNOTSUPP is seen on NFS in HP-UX 11.11, 11.23.\n               EINVAL is seen on NFS in HP-UX 11.31.  */\n            if (errno == ENOSYS || errno == EOPNOTSUPP || errno == EINVAL)\n              ;\n            else\n              return -1;\n          }\n        else if (count == 0)\n          return 0;\n        else /* count > 0 */\n          {\n            if (count > NACLVENTRIES)\n              /* If NACLVENTRIES cannot be trusted, use dynamic memory\n                 allocation.  */\n              abort ();\n\n            /* If there are more than 4 entries, there cannot be only the\n               four base ACL entries.  */\n            if (count > 4)\n              return 1;\n\n            return aclv_nontrivial (count, entries);\n          }\n      }\n\n#  endif\n\n# elif HAVE_ACLX_GET && defined ACL_AIX_WIP /* AIX */\n\n      acl_type_t type;\n      char aclbuf[1024];\n      void *acl = aclbuf;\n      size_t aclsize = sizeof (aclbuf);\n      mode_t mode;\n\n      for (;;)\n        {\n          /* The docs say that type being 0 is equivalent to ACL_ANY, but it\n             is not true, in AIX 5.3.  */\n          type.u64 = ACL_ANY;\n          if (aclx_get (name, 0, &type, aclbuf, &aclsize, &mode) >= 0)\n            break;\n          if (errno == ENOSYS)\n            return 0;\n          if (errno != ENOSPC)\n            {\n              if (acl != aclbuf)\n                {\n                  int saved_errno = errno;\n                  free (acl);\n                  errno = saved_errno;\n                }\n              return -1;\n            }\n          aclsize = 2 * aclsize;\n          if (acl != aclbuf)\n            free (acl);\n          acl = malloc (aclsize);\n          if (acl == NULL)\n            {\n              errno = ENOMEM;\n              return -1;\n            }\n        }\n\n      if (type.u64 == ACL_AIXC)\n        {\n          int result = acl_nontrivial ((struct acl *) acl);\n          if (acl != aclbuf)\n            free (acl);\n          return result;\n        }\n      else if (type.u64 == ACL_NFS4)\n        {\n          int result = acl_nfs4_nontrivial ((nfs4_acl_int_t *) acl);\n          if (acl != aclbuf)\n            free (acl);\n          return result;\n        }\n      else\n        {\n          /* A newer type of ACL has been introduced in the system.\n             We should better support it.  */\n          if (acl != aclbuf)\n            free (acl);\n          errno = EINVAL;\n          return -1;\n        }\n\n# elif HAVE_STATACL /* older AIX */\n\n      union { struct acl a; char room[4096]; } u;\n\n      if (statacl ((char *) name, STX_NORMAL, &u.a, sizeof (u)) < 0)\n        return -1;\n\n      return acl_nontrivial (&u.a);\n\n# elif HAVE_ACLSORT /* NonStop Kernel */\n\n      {\n        struct acl entries[NACLENTRIES];\n        int count;\n\n        count = acl ((char *) name, ACL_GET, NACLENTRIES, entries);\n\n        if (count < 0)\n          {\n            if (errno == ENOSYS || errno == ENOTSUP)\n              ;\n            else\n              return -1;\n          }\n        else if (count == 0)\n          return 0;\n        else /* count > 0 */\n          {\n            if (count > NACLENTRIES)\n              /* If NACLENTRIES cannot be trusted, use dynamic memory\n                 allocation.  */\n              abort ();\n\n            /* If there are more than 4 entries, there cannot be only the\n               four base ACL entries.  */\n            if (count > 4)\n              return 1;\n\n            return acl_nontrivial (count, entries);\n          }\n      }\n\n# endif\n    }\n#endif\n\n  return 0;\n}",
      "lines": 460,
      "depth": 26,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/flexmember.h": {},
  "sed/sed-4.5/gnulib-tests/fpurge.c": {
    "fpurge": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        147,
        1
      ],
      "content": "int\nfpurge (FILE *fp)\n{\n#if HAVE___FPURGE                   /* glibc >= 2.2, Haiku, Solaris >= 7, musl libc */\n\n  __fpurge (fp);\n  /* The __fpurge function does not have a return value.  */\n  return 0;\n\n#elif HAVE_FPURGE                   /* FreeBSD, NetBSD, OpenBSD, DragonFly, Mac OS X, Cygwin 1.7 */\n\n  /* Call the system's fpurge function.  */\n# undef fpurge\n# if !HAVE_DECL_FPURGE\n  extern int fpurge (FILE *);\n# endif\n  int result = fpurge (fp);\n# if defined __sferror || defined __DragonFly__ || defined __ANDROID__\n  /* FreeBSD, NetBSD, OpenBSD, DragonFly, Mac OS X, Cygwin, Minix 3, Android */\n  if (result == 0)\n    /* Correct the invariants that fpurge broke.\n       <stdio.h> on BSD systems says:\n         \"The following always hold: if _flags & __SRD, _w is 0.\"\n       If this invariant is not fulfilled and the stream is read-write but\n       currently reading, subsequent putc or fputc calls will write directly\n       into the buffer, although they shouldn't be allowed to.  */\n    if ((fp_->_flags & __SRD) != 0)\n      fp_->_w = 0;\n# endif\n  return result;\n\n#else\n\n  /* Most systems provide FILE as a struct and the necessary bitmask in\n     <stdio.h>, because they need it for implementing getc() and putc() as\n     fast macros.  */\n# if defined _IO_EOF_SEEN || defined _IO_ftrylockfile || __GNU_LIBRARY__ == 1\n  /* GNU libc, BeOS, Haiku, Linux libc5 */\n  fp->_IO_read_end = fp->_IO_read_ptr;\n  fp->_IO_write_ptr = fp->_IO_write_base;\n  /* Avoid memory leak when there is an active ungetc buffer.  */\n  if (fp->_IO_save_base != NULL)\n    {\n      free (fp->_IO_save_base);\n      fp->_IO_save_base = NULL;\n    }\n  return 0;\n# elif defined __sferror || defined __DragonFly__ || defined __ANDROID__\n  /* FreeBSD, NetBSD, OpenBSD, DragonFly, Mac OS X, Cygwin, Minix 3, Android */\n  fp_->_p = fp_->_bf._base;\n  fp_->_r = 0;\n  fp_->_w = ((fp_->_flags & (__SLBF | __SNBF | __SRD)) == 0 /* fully buffered and not currently reading? */\n             ? fp_->_bf._size\n             : 0);\n  /* Avoid memory leak when there is an active ungetc buffer.  */\n  if (fp_ub._base != NULL)\n    {\n      if (fp_ub._base != fp_->_ubuf)\n        free (fp_ub._base);\n      fp_ub._base = NULL;\n    }\n  return 0;\n# elif defined __EMX__              /* emx+gcc */\n  fp->_ptr = fp->_buffer;\n  fp->_rcount = 0;\n  fp->_wcount = 0;\n  fp->_ungetc_count = 0;\n  return 0;\n# elif defined __minix              /* Minix */\n  fp->_ptr = fp->_buf;\n  if (fp->_ptr != NULL)\n    fp->_count = 0;\n  return 0;\n# elif defined _IOERR               /* AIX, HP-UX, IRIX, OSF/1, Solaris, OpenServer, mingw, MSVC, NonStop Kernel, OpenVMS */\n  fp_->_ptr = fp_->_base;\n  if (fp_->_ptr != NULL)\n    fp_->_cnt = 0;\n  return 0;\n# elif defined __UCLIBC__           /* uClibc */\n#  ifdef __STDIO_BUFFERS\n  if (fp->__modeflags & __FLAG_WRITING)\n    fp->__bufpos = fp->__bufstart;\n  else if (fp->__modeflags & (__FLAG_READONLY | __FLAG_READING))\n    fp->__bufpos = fp->__bufread;\n#  endif\n  return 0;\n# elif defined __QNX__              /* QNX */\n  fp->_Rback = fp->_Back + sizeof (fp->_Back);\n  fp->_Rsave = NULL;\n  if (fp->_Mode & 0x2000 /* _MWRITE */)\n    /* fp->_Buf <= fp->_Next <= fp->_Wend */\n    fp->_Next = fp->_Buf;\n  else\n    /* fp->_Buf <= fp->_Next <= fp->_Rend */\n    fp->_Rend = fp->_Next;\n  return 0;\n# elif defined __MINT__             /* Atari FreeMiNT */\n  if (fp->__pushed_back)\n    {\n      fp->__bufp = fp->__pushback_bufp;\n      fp->__pushed_back = 0;\n    }\n  /* Preserve the current file position.  */\n  if (fp->__target != -1)\n    fp->__target += fp->__bufp - fp->__buffer;\n  fp->__bufp = fp->__buffer;\n  /* Nothing in the buffer, next getc is nontrivial.  */\n  fp->__get_limit = fp->__bufp;\n  /* Nothing in the buffer, next putc is nontrivial.  */\n  fp->__put_limit = fp->__buffer;\n  return 0;\n# elif defined EPLAN9               /* Plan9 */\n  fp->rp = fp->wp = fp->lp = fp->buf;\n  return 0;\n# else\n#  error \"Please port gnulib fpurge.c to your platform! Look at the definitions of fflush, setvbuf and ungetc on your system, then report this to bug-gnulib.\"\n# endif\n\n#endif\n}",
      "lines": 120,
      "depth": 20,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/freading.c": {
    "freading": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        73,
        1
      ],
      "content": "bool\nfreading (FILE *fp)\n{\n  /* Most systems provide FILE as a struct and the necessary bitmask in\n     <stdio.h>, because they need it for implementing getc() and putc() as\n     fast macros.  */\n# if defined _IO_EOF_SEEN || defined _IO_ftrylockfile || __GNU_LIBRARY__ == 1\n  /* GNU libc, BeOS, Haiku, Linux libc5 */\n  return ((fp->_flags & _IO_NO_WRITES) != 0\n          || ((fp->_flags & (_IO_NO_READS | _IO_CURRENTLY_PUTTING)) == 0\n              && fp->_IO_read_base != NULL));\n# elif defined __sferror || defined __DragonFly__ || defined __ANDROID__\n  /* FreeBSD, NetBSD, OpenBSD, DragonFly, Mac OS X, Cygwin, Minix 3, Android */\n  return (fp_->_flags & __SRD) != 0;\n# elif defined __EMX__               /* emx+gcc */\n  return (fp->_flags & _IOREAD) != 0;\n# elif defined __minix               /* Minix */\n  return (fp->_flags & _IOREADING) != 0;\n# elif defined _IOERR                /* AIX, HP-UX, IRIX, OSF/1, Solaris, OpenServer, mingw, MSVC, NonStop Kernel, OpenVMS */\n#  if defined __sun                  /* Solaris */\n  return (fp_->_flag & _IOREAD) != 0 && (fp_->_flag & _IOWRT) == 0;\n#  else\n  return (fp_->_flag & _IOREAD) != 0;\n#  endif\n# elif defined __UCLIBC__            /* uClibc */\n  return (fp->__modeflags & (__FLAG_READONLY | __FLAG_READING)) != 0;\n# elif defined __QNX__               /* QNX */\n  return ((fp->_Mode & 0x2 /* _MOPENW */) == 0\n          || (fp->_Mode & 0x1000 /* _MREAD */) != 0);\n# elif defined __MINT__              /* Atari FreeMiNT */\n  if (!fp->__mode.__write)\n    return 1;\n  if (!fp->__mode.__read)\n    return 0;\n#  ifdef _IO_CURRENTLY_GETTING /* Flag added on 2009-02-28 */\n  return (fp->__flags & _IO_CURRENTLY_GETTING) != 0;\n#  else\n  return (fp->__buffer < fp->__get_limit /*|| fp->__bufp == fp->__put_limit ??*/);\n#  endif\n# elif defined EPLAN9                /* Plan9 */\n  if (fp->state == 0 /* CLOSED */ || fp->state == 4 /* WR */)\n    return 0;\n  return (fp->state == 3 /* RD */ && (fp->bufl == 0 || fp->rp < fp->wp));\n# else\n#  error \"Please port gnulib freading.c to your platform!\"\n# endif\n}",
      "lines": 47,
      "depth": 19,
      "decorators": [
        "bool"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/freading.h": {},
  "sed/sed-4.5/gnulib-tests/fseek.c": {
    "fseek": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        29,
        1
      ],
      "content": "int\nfseek (FILE *fp, long offset, int whence)\n{\n  /* Use the replacement fseeko function with all its workarounds.  */\n  return fseeko (fp, (off_t)offset, whence);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/fseeko.c": {},
  "sed/sed-4.5/gnulib-tests/ftell.c": {
    "ftell": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "long\nftell (FILE *fp)\n{\n  /* Use the replacement ftello function with all its workarounds.  */\n  off_t offset = ftello (fp);\n  if (LONG_MIN <= offset && offset <= LONG_MAX)\n    return /* (long) */ offset;\n  else\n    {\n      errno = EOVERFLOW;\n      return -1;\n    }\n}",
      "lines": 13,
      "depth": 7,
      "decorators": [
        "long",
        "long"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/ftello.c": {},
  "sed/sed-4.5/gnulib-tests/ftruncate.c": {
    "SetFileSize": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        119,
        1
      ],
      "content": "static BOOL\nSetFileSize (HANDLE h, LONGLONG size)\n{\n  LARGE_INTEGER old_size;\n\n  if (!GetFileSizeEx (h, &old_size))\n    return FALSE;\n\n  if (size != old_size.QuadPart)\n    {\n      /* Duplicate the handle, so we are free to modify its file position.  */\n      HANDLE curr_process = GetCurrentProcess ();\n      HANDLE tmph;\n\n      if (!DuplicateHandle (curr_process,           /* SourceProcessHandle */\n                            h,                      /* SourceHandle */\n                            curr_process,           /* TargetProcessHandle */\n                            (PHANDLE) &tmph,        /* TargetHandle */\n                            (DWORD) 0,              /* DesiredAccess */\n                            FALSE,                  /* InheritHandle */\n                            DUPLICATE_SAME_ACCESS)) /* Options */\n        return FALSE;\n\n      if (size < old_size.QuadPart)\n        {\n          /* Reduce the size.  */\n          LONG size_hi = (LONG) (size >> 32);\n          if (SetFilePointer (tmph, (LONG) size, &size_hi, FILE_BEGIN)\n              == INVALID_SET_FILE_POINTER\n              && GetLastError() != NO_ERROR)\n            {\n              CloseHandle (tmph);\n              return FALSE;\n            }\n          if (!SetEndOfFile (tmph))\n            {\n              CloseHandle (tmph);\n              return FALSE;\n            }\n        }\n      else\n        {\n          /* Increase the size by adding zero bytes at the end.  */\n          static char zero_bytes[1024];\n          LONG pos_hi = 0;\n          LONG pos_lo = SetFilePointer (tmph, (LONG) 0, &pos_hi, FILE_END);\n          LONGLONG pos;\n          if (pos_lo == INVALID_SET_FILE_POINTER\n              && GetLastError() != NO_ERROR)\n            {\n              CloseHandle (tmph);\n              return FALSE;\n            }\n          pos = ((LONGLONG) pos_hi << 32) | (ULONGLONG) (ULONG) pos_lo;\n          while (pos < size)\n            {\n              DWORD written;\n              LONGLONG count = size - pos;\n              if (count > sizeof (zero_bytes))\n                count = sizeof (zero_bytes);\n              if (!WriteFile (tmph, zero_bytes, (DWORD) count, &written, NULL)\n                  || written == 0)\n                {\n                  CloseHandle (tmph);\n                  return FALSE;\n                }\n              pos += (ULONGLONG) (ULONG) written;\n            }\n        }\n      /* Close the handle.  */\n      CloseHandle (tmph);\n    }\n  return TRUE;\n}",
      "lines": 74,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "BOOL"
      ]
    },
    "ftruncate": [
      {
        "start_point": [
          121,
          0
        ],
        "end_point": [
          155,
          1
        ],
        "content": "int\nftruncate (int fd, off_t length)\n{\n  HANDLE handle = (HANDLE) _get_osfhandle (fd);\n\n  if (handle == INVALID_HANDLE_VALUE)\n    {\n      errno = EBADF;\n      return -1;\n    }\n  if (length < 0)\n    {\n      errno = EINVAL;\n      return -1;\n    }\n  if (!SetFileSize (handle, length))\n    {\n      switch (GetLastError ())\n        {\n        case ERROR_ACCESS_DENIED:\n          errno = EACCES;\n          break;\n        case ERROR_HANDLE_DISK_FULL:\n        case ERROR_DISK_FULL:\n        case ERROR_DISK_TOO_FRAGMENTED:\n          errno = ENOSPC;\n          break;\n        default:\n          errno = EIO;\n          break;\n        }\n      return -1;\n    }\n  return 0;\n}",
        "lines": 35,
        "depth": 10,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          185,
          0
        ],
        "end_point": [
          189,
          1
        ],
        "content": "int\nftruncate (int fd, off_t length)\n{\n  return chsize_nothrow (fd, length);\n}",
        "lines": 5,
        "depth": 6,
        "decorators": [
          "int"
        ]
      }
    ],
    "chsize_nothrow": {
      "start_point": [
        163,
        0
      ],
      "end_point": [
        171,
        5
      ],
      "content": "static int\nchsize_nothrow (int fd, long length)\n{\n  int result;\n\n  TRY_MSVC_INVAL\n    {\n      result = chsize (fd, length);\n    }",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/getcwd-lgpl.c": {
    "rpl_getcwd": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        123,
        1
      ],
      "content": "char *\nrpl_getcwd (char *buf, size_t size)\n{\n  char *ptr;\n  char *result;\n\n  /* Handle single size operations.  */\n  if (buf)\n    {\n      if (!size)\n        {\n          errno = EINVAL;\n          return NULL;\n        }\n      return getcwd (buf, size);\n    }\n\n  if (size)\n    {\n      buf = malloc (size);\n      if (!buf)\n        {\n          errno = ENOMEM;\n          return NULL;\n        }\n      result = getcwd (buf, size);\n      if (!result)\n        {\n          int saved_errno = errno;\n          free (buf);\n          errno = saved_errno;\n        }\n      return result;\n    }\n\n  /* Flexible sizing requested.  Avoid over-allocation for the common\n     case of a name that fits within a 4k page, minus some space for\n     local variables, to be sure we don't skip over a guard page.  */\n  {\n    char tmp[4032];\n    size = sizeof tmp;\n    ptr = getcwd (tmp, size);\n    if (ptr)\n      {\n        result = strdup (ptr);\n        if (!result)\n          errno = ENOMEM;\n        return result;\n      }\n    if (errno != ERANGE)\n      return NULL;\n  }\n\n  /* My what a large directory name we have.  */\n  do\n    {\n      size <<= 1;\n      ptr = realloc (buf, size);\n      if (ptr == NULL)\n        {\n          free (buf);\n          errno = ENOMEM;\n          return NULL;\n        }\n      buf = ptr;\n      result = getcwd (buf, size);\n    }\n  while (!result && errno == ERANGE);\n\n  if (!result)\n    {\n      int saved_errno = errno;\n      free (buf);\n      errno = saved_errno;\n    }\n  else\n    {\n      /* Trim to fit, if possible.  */\n      result = realloc (buf, strlen (buf) + 1);\n      if (!result)\n        result = buf;\n    }\n  return result;\n}",
      "lines": 84,
      "depth": 12,
      "decorators": [
        "char",
        "*\nrpl_getcwd (char *buf, size_t size)",
        "*"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/getdtablesize.c": {
    "_setmaxstdio_nothrow": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        39,
        5
      ],
      "content": "static int\n_setmaxstdio_nothrow (int newmax)\n{\n  int result;\n\n  TRY_MSVC_INVAL\n    {\n      result = _setmaxstdio (newmax);\n    }",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "getdtablesize": [
      {
        "start_point": [
          56,
          0
        ],
        "end_point": [
          87,
          1
        ],
        "content": "int\ngetdtablesize (void)\n{\n  if (dtablesize == 0)\n    {\n      /* We are looking for the number N such that the valid file descriptors\n         are 0..N-1.  It can be obtained through a loop as follows:\n           {\n             int fd;\n             for (fd = 3; fd < 65536; fd++)\n               if (dup2 (0, fd) == -1)\n                 break;\n             return fd;\n           }\n         On Windows XP, the result is 2048.\n         The drawback of this loop is that it allocates memory for a libc\n         internal array that is never freed.\n\n         The number N can also be obtained as the upper bound for\n         _getmaxstdio ().  _getmaxstdio () returns the maximum number of open\n         FILE objects.  The sanity check in _setmaxstdio reveals the maximum\n         number of file descriptors.  This too allocates memory, but it is\n         freed when we call _setmaxstdio with the original value.  */\n      int orig_max_stdio = _getmaxstdio ();\n      unsigned int bound;\n      for (bound = 0x10000; _setmaxstdio_nothrow (bound) < 0; bound = bound / 2)\n        ;\n      _setmaxstdio_nothrow (orig_max_stdio);\n      dtablesize = bound;\n    }\n  return dtablesize;\n}",
        "lines": 32,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          108,
          0
        ],
        "end_point": [
          121,
          1
        ],
        "content": "int\ngetdtablesize (void)\n{\n  struct rlimit lim;\n\n  if (getrlimit (RLIMIT_NOFILE, &lim) == 0\n      && 0 <= lim.rlim_cur && lim.rlim_cur <= INT_MAX\n      && lim.rlim_cur != RLIM_INFINITY\n      && lim.rlim_cur != RLIM_SAVED_CUR\n      && lim.rlim_cur != RLIM_SAVED_MAX)\n    return lim.rlim_cur;\n\n  return INT_MAX;\n}",
        "lines": 14,
        "depth": 14,
        "decorators": [
          "int"
        ]
      }
    ]
  },
  "sed/sed-4.5/gnulib-tests/getpagesize.c": {
    "getpagesize": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "int\ngetpagesize (void)\n{\n  SYSTEM_INFO system_info;\n  GetSystemInfo (&system_info);\n  return system_info.dwPageSize;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/inet_pton.c": {
    "rpl_inet_pton": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "int\nrpl_inet_pton (int af, const char *restrict src, void *restrict dst)\n{\n  return inet_pton (af, src, dst);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "inet_pton": {
      "start_point": [
        80,
        0
      ],
      "end_point": [
        98,
        1
      ],
      "content": "int\ninet_pton (int af, const char *restrict src, void *restrict dst)\n{\n  switch (af)\n    {\n    case AF_INET:\n      return (inet_pton4 (src, dst));\n\n# if HAVE_IPV6\n    case AF_INET6:\n      return (inet_pton6 (src, dst));\n# endif\n\n    default:\n      errno = EAFNOSUPPORT;\n      return (-1);\n    }\n  /* NOTREACHED */\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "inet_pton4": {
      "start_point": [
        111,
        0
      ],
      "end_point": [
        153,
        1
      ],
      "content": "static int\ninet_pton4 (const char *restrict src, unsigned char *restrict dst)\n{\n  int saw_digit, octets, ch;\n  unsigned char tmp[NS_INADDRSZ], *tp;\n\n  saw_digit = 0;\n  octets = 0;\n  *(tp = tmp) = 0;\n  while ((ch = *src++) != '\\0')\n    {\n\n      if (ch >= '0' && ch <= '9')\n        {\n          unsigned new = *tp * 10 + (ch - '0');\n\n          if (saw_digit && *tp == 0)\n            return (0);\n          if (new > 255)\n            return (0);\n          *tp = new;\n          if (!saw_digit)\n            {\n              if (++octets > 4)\n                return (0);\n              saw_digit = 1;\n            }\n        }\n      else if (ch == '.' && saw_digit)\n        {\n          if (octets == 4)\n            return (0);\n          *++tp = 0;\n          saw_digit = 0;\n        }\n      else\n        return (0);\n    }\n  if (octets < 4)\n    return (0);\n  memcpy (dst, tmp, NS_INADDRSZ);\n  return (1);\n}",
      "lines": 43,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "inet_pton6": {
      "start_point": [
        170,
        0
      ],
      "end_point": [
        263,
        1
      ],
      "content": "static int\ninet_pton6 (const char *restrict src, unsigned char *restrict dst)\n{\n  static const char xdigits[] = \"0123456789abcdef\";\n  unsigned char tmp[NS_IN6ADDRSZ], *tp, *endp, *colonp;\n  const char *curtok;\n  int ch, saw_xdigit;\n  unsigned val;\n\n  tp = memset (tmp, '\\0', NS_IN6ADDRSZ);\n  endp = tp + NS_IN6ADDRSZ;\n  colonp = NULL;\n  /* Leading :: requires some special handling. */\n  if (*src == ':')\n    if (*++src != ':')\n      return (0);\n  curtok = src;\n  saw_xdigit = 0;\n  val = 0;\n  while ((ch = c_tolower (*src++)) != '\\0')\n    {\n      const char *pch;\n\n      pch = strchr (xdigits, ch);\n      if (pch != NULL)\n        {\n          val <<= 4;\n          val |= (pch - xdigits);\n          if (val > 0xffff)\n            return (0);\n          saw_xdigit = 1;\n          continue;\n        }\n      if (ch == ':')\n        {\n          curtok = src;\n          if (!saw_xdigit)\n            {\n              if (colonp)\n                return (0);\n              colonp = tp;\n              continue;\n            }\n          else if (*src == '\\0')\n            {\n              return (0);\n            }\n          if (tp + NS_INT16SZ > endp)\n            return (0);\n          *tp++ = (u_char) (val >> 8) & 0xff;\n          *tp++ = (u_char) val & 0xff;\n          saw_xdigit = 0;\n          val = 0;\n          continue;\n        }\n      if (ch == '.' && ((tp + NS_INADDRSZ) <= endp) &&\n          inet_pton4 (curtok, tp) > 0)\n        {\n          tp += NS_INADDRSZ;\n          saw_xdigit = 0;\n          break;                /* '\\0' was seen by inet_pton4(). */\n        }\n      return (0);\n    }\n  if (saw_xdigit)\n    {\n      if (tp + NS_INT16SZ > endp)\n        return (0);\n      *tp++ = (u_char) (val >> 8) & 0xff;\n      *tp++ = (u_char) val & 0xff;\n    }\n  if (colonp != NULL)\n    {\n      /*\n       * Since some memmove()'s erroneously fail to handle\n       * overlapping regions, we'll do the shift by hand.\n       */\n      const int n = tp - colonp;\n      int i;\n\n      if (tp == endp)\n        return (0);\n      for (i = 1; i <= n; i++)\n        {\n          endp[-i] = colonp[n - i];\n          colonp[n - i] = 0;\n        }\n      tp = endp;\n    }\n  if (tp != endp)\n    return (0);\n  memcpy (dst, tmp, NS_IN6ADDRSZ);\n  return (1);\n}",
      "lines": 94,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/inttypes.in.h": {},
  "sed/sed-4.5/gnulib-tests/ioctl.c": {
    "rpl_ioctl": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        42,
        1
      ],
      "content": "int\nrpl_ioctl (int fd, int request, ... /* {void *,char *} arg */)\n{\n  void *buf;\n  va_list args;\n\n  va_start (args, request);\n  buf = va_arg (args, void *);\n  va_end (args);\n\n  /* Cast 'request' so that when the system's ioctl function takes a 64-bit\n     request argument, the value gets zero-extended, not sign-extended.  */\n  return ioctl (fd, (unsigned int) request, buf);\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "primary_ioctl": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "static int\nprimary_ioctl (int fd, int request, void *arg)\n{\n  /* We don't support FIONBIO on pipes here.  If you want to make pipe\n     fds non-blocking, use the gnulib 'nonblocking' module, until\n     gnulib implements fcntl F_GETFL / F_SETFL with O_NONBLOCK.  */\n\n  if ((HANDLE) _get_osfhandle (fd) != INVALID_HANDLE_VALUE)\n    errno = ENOSYS;\n  else\n    errno = EBADF;\n  return -1;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "ioctl": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "int\nioctl (int fd, int request, ... /* {void *,char *} arg */)\n{\n  void *arg;\n  va_list args;\n\n  va_start (args, request);\n  arg = va_arg (args, void *);\n  va_end (args);\n\n# if WINDOWS_SOCKETS\n  return execute_all_ioctl_hooks (primary_ioctl, fd, request, arg);\n# else\n  return primary_ioctl (fd, request, arg);\n# endif\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/link.c": {
    "initialize": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "static void\ninitialize (void)\n{\n  HMODULE kernel32 = GetModuleHandle (\"kernel32.dll\");\n  if (kernel32 != NULL)\n    {\n      CreateHardLinkFunc =\n        (CreateHardLinkFuncType) GetProcAddress (kernel32, \"CreateHardLinkA\");\n    }\n  initialized = TRUE;\n}",
      "lines": 11,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "link": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        141,
        1
      ],
      "content": "int\nlink (const char *file1, const char *file2)\n{\n  char *dir;\n  size_t len1 = strlen (file1);\n  size_t len2 = strlen (file2);\n  if (!initialized)\n    initialize ();\n  if (CreateHardLinkFunc == NULL)\n    {\n      /* System does not support hard links.  */\n      errno = EPERM;\n      return -1;\n    }\n  /* Reject trailing slashes on non-directories; mingw does not\n     support hard-linking directories.  */\n  if ((len1 && (file1[len1 - 1] == '/' || file1[len1 - 1] == '\\\\'))\n      || (len2 && (file2[len2 - 1] == '/' || file2[len2 - 1] == '\\\\')))\n    {\n      struct stat st;\n      if (stat (file1, &st) == 0 && S_ISDIR (st.st_mode))\n        errno = EPERM;\n      else\n        errno = ENOTDIR;\n      return -1;\n    }\n  /* CreateHardLink(\"b/.\",\"a\",NULL) creates file \"b\", so we must check\n     that dirname(file2) exists.  */\n  dir = strdup (file2);\n  if (!dir)\n    return -1;\n  {\n    struct stat st;\n    char *p = strchr (dir, '\\0');\n    while (dir < p && (*--p != '/' && *p != '\\\\'));\n    *p = '\\0';\n    if (p != dir && stat (dir, &st) == -1)\n      {\n        int saved_errno = errno;\n        free (dir);\n        errno = saved_errno;\n        return -1;\n      }\n    free (dir);\n  }\n  /* Now create the link.  */\n  if (CreateHardLinkFunc (file2, file1, NULL) == 0)\n    {\n      /* It is not documented which errors CreateHardLink() can produce.\n       * The following conversions are based on tests on a Windows XP SP2\n       * system. */\n      DWORD err = GetLastError ();\n      switch (err)\n        {\n        case ERROR_ACCESS_DENIED:\n          errno = EACCES;\n          break;\n\n        case ERROR_INVALID_FUNCTION:    /* fs does not support hard links */\n          errno = EPERM;\n          break;\n\n        case ERROR_NOT_SAME_DEVICE:\n          errno = EXDEV;\n          break;\n\n        case ERROR_PATH_NOT_FOUND:\n        case ERROR_FILE_NOT_FOUND:\n          errno = ENOENT;\n          break;\n\n        case ERROR_INVALID_PARAMETER:\n          errno = ENAMETOOLONG;\n          break;\n\n        case ERROR_TOO_MANY_LINKS:\n          errno = EMLINK;\n          break;\n\n        case ERROR_ALREADY_EXISTS:\n          errno = EEXIST;\n          break;\n\n        default:\n          errno = EIO;\n        }\n      return -1;\n    }\n\n  return 0;\n}",
      "lines": 91,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "rpl_link": {
      "start_point": [
        153,
        0
      ],
      "end_point": [
        209,
        1
      ],
      "content": "int\nrpl_link (char const *file1, char const *file2)\n{\n  size_t len1;\n  size_t len2;\n  struct stat st;\n\n  /* Don't allow IRIX to dereference dangling file2 symlink.  */\n  if (!lstat (file2, &st))\n    {\n      errno = EEXIST;\n      return -1;\n    }\n\n  /* Reject trailing slashes on non-directories.  */\n  len1 = strlen (file1);\n  len2 = strlen (file2);\n  if ((len1 && file1[len1 - 1] == '/')\n      || (len2 && file2[len2 - 1] == '/'))\n    {\n      /* Let link() decide whether hard-linking directories is legal.\n         If stat() fails, then link() should fail for the same reason\n         (although on Solaris 9, link(\"file/\",\"oops\") mistakenly\n         succeeds); if stat() succeeds, require a directory.  */\n      if (stat (file1, &st))\n        return -1;\n      if (!S_ISDIR (st.st_mode))\n        {\n          errno = ENOTDIR;\n          return -1;\n        }\n    }\n  else\n    {\n      /* Fix Cygwin 1.5.x bug where link(\"a\",\"b/.\") creates file \"b\".  */\n      char *dir = strdup (file2);\n      char *p;\n      if (!dir)\n        return -1;\n      /* We already know file2 does not end in slash.  Strip off the\n         basename, then check that the dirname exists.  */\n      p = strrchr (dir, '/');\n      if (p)\n        {\n          *p = '\\0';\n          if (stat (dir, &st) == -1)\n            {\n              int saved_errno = errno;\n              free (dir);\n              errno = saved_errno;\n              return -1;\n            }\n        }\n      free (dir);\n    }\n  return link (file1, file2);\n}",
      "lines": 57,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/listen.c": {
    "rpl_listen": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "int\nrpl_listen (int fd, int backlog)\n{\n  SOCKET sock = FD_TO_SOCKET (fd);\n\n  if (sock == INVALID_SOCKET)\n    {\n      errno = EBADF;\n      return -1;\n    }\n  else\n    {\n      int r = listen (sock, backlog);\n      if (r < 0)\n        set_winsock_errno ();\n\n      return r;\n    }\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/localename.c": {
    "gl_locale_name_canonicalize": [
      {
        "start_point": [
          1154,
          0
        ],
        "end_point": [
          1417,
          1
        ],
        "content": "void\ngl_locale_name_canonicalize (char *name)\n{\n  /* This conversion is based on a posting by\n     Deborah GoldSmith <goldsmit@apple.com> on 2005-03-08,\n     https://lists.apple.com/archives/carbon-dev/2005/Mar/msg00293.html */\n\n  /* Convert legacy (NeXTstep inherited) English names to Unix (ISO 639 and\n     ISO 3166) names.  Prior to Mac OS X 10.3, there is no API for doing this.\n     Therefore we do it ourselves, using a table based on the results of the\n     Mac OS X 10.3.8 function\n     CFLocaleCreateCanonicalLocaleIdentifierFromString().  */\n  typedef struct { const char legacy[21+1]; const char unixy[5+1]; }\n          legacy_entry;\n  static const legacy_entry legacy_table[] = {\n    { \"Afrikaans\",             \"af\" },\n    { \"Albanian\",              \"sq\" },\n    { \"Amharic\",               \"am\" },\n    { \"Arabic\",                \"ar\" },\n    { \"Armenian\",              \"hy\" },\n    { \"Assamese\",              \"as\" },\n    { \"Aymara\",                \"ay\" },\n    { \"Azerbaijani\",           \"az\" },\n    { \"Basque\",                \"eu\" },\n    { \"Belarusian\",            \"be\" },\n    { \"Belorussian\",           \"be\" },\n    { \"Bengali\",               \"bn\" },\n    { \"Brazilian Portugese\",   \"pt_BR\" },\n    { \"Brazilian Portuguese\",  \"pt_BR\" },\n    { \"Breton\",                \"br\" },\n    { \"Bulgarian\",             \"bg\" },\n    { \"Burmese\",               \"my\" },\n    { \"Byelorussian\",          \"be\" },\n    { \"Catalan\",               \"ca\" },\n    { \"Chewa\",                 \"ny\" },\n    { \"Chichewa\",              \"ny\" },\n    { \"Chinese\",               \"zh\" },\n    { \"Chinese, Simplified\",   \"zh_CN\" },\n    { \"Chinese, Traditional\",  \"zh_TW\" },\n    { \"Chinese, Tradtional\",   \"zh_TW\" },\n    { \"Croatian\",              \"hr\" },\n    { \"Czech\",                 \"cs\" },\n    { \"Danish\",                \"da\" },\n    { \"Dutch\",                 \"nl\" },\n    { \"Dzongkha\",              \"dz\" },\n    { \"English\",               \"en\" },\n    { \"Esperanto\",             \"eo\" },\n    { \"Estonian\",              \"et\" },\n    { \"Faroese\",               \"fo\" },\n    { \"Farsi\",                 \"fa\" },\n    { \"Finnish\",               \"fi\" },\n    { \"Flemish\",               \"nl_BE\" },\n    { \"French\",                \"fr\" },\n    { \"Galician\",              \"gl\" },\n    { \"Gallegan\",              \"gl\" },\n    { \"Georgian\",              \"ka\" },\n    { \"German\",                \"de\" },\n    { \"Greek\",                 \"el\" },\n    { \"Greenlandic\",           \"kl\" },\n    { \"Guarani\",               \"gn\" },\n    { \"Gujarati\",              \"gu\" },\n    { \"Hawaiian\",              \"haw\" }, /* Yes, \"haw\", not \"cpe\".  */\n    { \"Hebrew\",                \"he\" },\n    { \"Hindi\",                 \"hi\" },\n    { \"Hungarian\",             \"hu\" },\n    { \"Icelandic\",             \"is\" },\n    { \"Indonesian\",            \"id\" },\n    { \"Inuktitut\",             \"iu\" },\n    { \"Irish\",                 \"ga\" },\n    { \"Italian\",               \"it\" },\n    { \"Japanese\",              \"ja\" },\n    { \"Javanese\",              \"jv\" },\n    { \"Kalaallisut\",           \"kl\" },\n    { \"Kannada\",               \"kn\" },\n    { \"Kashmiri\",              \"ks\" },\n    { \"Kazakh\",                \"kk\" },\n    { \"Khmer\",                 \"km\" },\n    { \"Kinyarwanda\",           \"rw\" },\n    { \"Kirghiz\",               \"ky\" },\n    { \"Korean\",                \"ko\" },\n    { \"Kurdish\",               \"ku\" },\n    { \"Latin\",                 \"la\" },\n    { \"Latvian\",               \"lv\" },\n    { \"Lithuanian\",            \"lt\" },\n    { \"Macedonian\",            \"mk\" },\n    { \"Malagasy\",              \"mg\" },\n    { \"Malay\",                 \"ms\" },\n    { \"Malayalam\",             \"ml\" },\n    { \"Maltese\",               \"mt\" },\n    { \"Manx\",                  \"gv\" },\n    { \"Marathi\",               \"mr\" },\n    { \"Moldavian\",             \"mo\" },\n    { \"Mongolian\",             \"mn\" },\n    { \"Nepali\",                \"ne\" },\n    { \"Norwegian\",             \"nb\" }, /* Yes, \"nb\", not the obsolete \"no\".  */\n    { \"Nyanja\",                \"ny\" },\n    { \"Nynorsk\",               \"nn\" },\n    { \"Oriya\",                 \"or\" },\n    { \"Oromo\",                 \"om\" },\n    { \"Panjabi\",               \"pa\" },\n    { \"Pashto\",                \"ps\" },\n    { \"Persian\",               \"fa\" },\n    { \"Polish\",                \"pl\" },\n    { \"Portuguese\",            \"pt\" },\n    { \"Portuguese, Brazilian\", \"pt_BR\" },\n    { \"Punjabi\",               \"pa\" },\n    { \"Pushto\",                \"ps\" },\n    { \"Quechua\",               \"qu\" },\n    { \"Romanian\",              \"ro\" },\n    { \"Ruanda\",                \"rw\" },\n    { \"Rundi\",                 \"rn\" },\n    { \"Russian\",               \"ru\" },\n    { \"Sami\",                  \"se_NO\" }, /* Not just \"se\".  */\n    { \"Sanskrit\",              \"sa\" },\n    { \"Scottish\",              \"gd\" },\n    { \"Serbian\",               \"sr\" },\n    { \"Simplified Chinese\",    \"zh_CN\" },\n    { \"Sindhi\",                \"sd\" },\n    { \"Sinhalese\",             \"si\" },\n    { \"Slovak\",                \"sk\" },\n    { \"Slovenian\",             \"sl\" },\n    { \"Somali\",                \"so\" },\n    { \"Spanish\",               \"es\" },\n    { \"Sundanese\",             \"su\" },\n    { \"Swahili\",               \"sw\" },\n    { \"Swedish\",               \"sv\" },\n    { \"Tagalog\",               \"tl\" },\n    { \"Tajik\",                 \"tg\" },\n    { \"Tajiki\",                \"tg\" },\n    { \"Tamil\",                 \"ta\" },\n    { \"Tatar\",                 \"tt\" },\n    { \"Telugu\",                \"te\" },\n    { \"Thai\",                  \"th\" },\n    { \"Tibetan\",               \"bo\" },\n    { \"Tigrinya\",              \"ti\" },\n    { \"Tongan\",                \"to\" },\n    { \"Traditional Chinese\",   \"zh_TW\" },\n    { \"Turkish\",               \"tr\" },\n    { \"Turkmen\",               \"tk\" },\n    { \"Uighur\",                \"ug\" },\n    { \"Ukrainian\",             \"uk\" },\n    { \"Urdu\",                  \"ur\" },\n    { \"Uzbek\",                 \"uz\" },\n    { \"Vietnamese\",            \"vi\" },\n    { \"Welsh\",                 \"cy\" },\n    { \"Yiddish\",               \"yi\" }\n  };\n\n  /* Convert new-style locale names with language tags (ISO 639 and ISO 15924)\n     to Unix (ISO 639 and ISO 3166) names.  */\n  typedef struct { const char langtag[7+1]; const char unixy[12+1]; }\n          langtag_entry;\n  static const langtag_entry langtag_table[] = {\n    /* Mac OS X has \"az-Arab\", \"az-Cyrl\", \"az-Latn\".\n       The default script for az on Unix is Latin.  */\n    { \"az-Latn\", \"az\" },\n    /* Mac OS X has \"ga-dots\".  Does not yet exist on Unix.  */\n    { \"ga-dots\", \"ga\" },\n    /* Mac OS X has \"kk-Cyrl\".  Does not yet exist on Unix.  */\n    /* Mac OS X has \"mn-Cyrl\", \"mn-Mong\".\n       The default script for mn on Unix is Cyrillic.  */\n    { \"mn-Cyrl\", \"mn\" },\n    /* Mac OS X has \"ms-Arab\", \"ms-Latn\".\n       The default script for ms on Unix is Latin.  */\n    { \"ms-Latn\", \"ms\" },\n    /* Mac OS X has \"tg-Cyrl\".\n       The default script for tg on Unix is Cyrillic.  */\n    { \"tg-Cyrl\", \"tg\" },\n    /* Mac OS X has \"tk-Cyrl\".  Does not yet exist on Unix.  */\n    /* Mac OS X has \"tt-Cyrl\".\n       The default script for tt on Unix is Cyrillic.  */\n    { \"tt-Cyrl\", \"tt\" },\n    /* Mac OS X has \"zh-Hans\", \"zh-Hant\".\n       Country codes are used to distinguish these on Unix.  */\n    { \"zh-Hans\", \"zh_CN\" },\n    { \"zh-Hant\", \"zh_TW\" }\n  };\n\n  /* Convert script names (ISO 15924) to Unix conventions.\n     See http://www.unicode.org/iso15924/iso15924-codes.html  */\n  typedef struct { const char script[4+1]; const char unixy[9+1]; }\n          script_entry;\n  static const script_entry script_table[] = {\n    { \"Arab\", \"arabic\" },\n    { \"Cyrl\", \"cyrillic\" },\n    { \"Mong\", \"mongolian\" }\n  };\n\n  /* Step 1: Convert using legacy_table.  */\n  if (name[0] >= 'A' && name[0] <= 'Z')\n    {\n      unsigned int i1, i2;\n      i1 = 0;\n      i2 = sizeof (legacy_table) / sizeof (legacy_entry);\n      while (i2 - i1 > 1)\n        {\n          /* At this point we know that if name occurs in legacy_table,\n             its index must be >= i1 and < i2.  */\n          unsigned int i = (i1 + i2) >> 1;\n          const legacy_entry *p = &legacy_table[i];\n          if (strcmp (name, p->legacy) < 0)\n            i2 = i;\n          else\n            i1 = i;\n        }\n      if (strcmp (name, legacy_table[i1].legacy) == 0)\n        {\n          strcpy (name, legacy_table[i1].unixy);\n          return;\n        }\n    }\n\n  /* Step 2: Convert using langtag_table and script_table.  */\n  if (strlen (name) == 7 && name[2] == '-')\n    {\n      unsigned int i1, i2;\n      i1 = 0;\n      i2 = sizeof (langtag_table) / sizeof (langtag_entry);\n      while (i2 - i1 > 1)\n        {\n          /* At this point we know that if name occurs in langtag_table,\n             its index must be >= i1 and < i2.  */\n          unsigned int i = (i1 + i2) >> 1;\n          const langtag_entry *p = &langtag_table[i];\n          if (strcmp (name, p->langtag) < 0)\n            i2 = i;\n          else\n            i1 = i;\n        }\n      if (strcmp (name, langtag_table[i1].langtag) == 0)\n        {\n          strcpy (name, langtag_table[i1].unixy);\n          return;\n        }\n\n      i1 = 0;\n      i2 = sizeof (script_table) / sizeof (script_entry);\n      while (i2 - i1 > 1)\n        {\n          /* At this point we know that if (name + 3) occurs in script_table,\n             its index must be >= i1 and < i2.  */\n          unsigned int i = (i1 + i2) >> 1;\n          const script_entry *p = &script_table[i];\n          if (strcmp (name + 3, p->script) < 0)\n            i2 = i;\n          else\n            i1 = i;\n        }\n      if (strcmp (name + 3, script_table[i1].script) == 0)\n        {\n          name[2] = '@';\n          strcpy (name + 3, script_table[i1].unixy);\n          return;\n        }\n    }\n\n  /* Step 3: Convert new-style dash to Unix underscore. */\n  {\n    char *p;\n    for (p = name; *p != '\\0'; p++)\n      if (*p == '-')\n        *p = '_';\n  }\n}",
        "lines": 264,
        "depth": 13,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          1431,
          0
        ],
        "end_point": [
          1455,
          1
        ],
        "content": "void\ngl_locale_name_canonicalize (char *name)\n{\n  /* FIXME: This is probably incomplete: it does not handle \"zh-Hans\" and\n     \"zh-Hant\".  */\n  char *p;\n\n  for (p = name; *p != '\\0'; p++)\n    if (*p == '-')\n      {\n        *p = '_';\n        p++;\n        for (; *p != '\\0'; p++)\n          {\n            if (*p >= 'a' && *p <= 'z')\n              *p += 'A' - 'a';\n            if (*p == '-')\n              {\n                *p = '\\0';\n                return;\n              }\n          }\n        return;\n      }\n}",
        "lines": 25,
        "depth": 13,
        "decorators": [
          "void"
        ]
      }
    ],
    "gl_locale_name_from_win32_LANGID": {
      "start_point": [
        1460,
        0
      ],
      "end_point": [
        2503,
        1
      ],
      "content": "const char *\ngl_locale_name_from_win32_LANGID (LANGID langid)\n{\n  /* Activate the new code only when the GETTEXT_MUI environment variable is\n     set, for the time being, since the new code is not well tested.  */\n  if (getenv (\"GETTEXT_MUI\") != NULL)\n    {\n      static char namebuf[256];\n\n      /* Query the system's notion of locale name.\n         On Windows95/98/ME, GetLocaleInfoA returns some incorrect results.\n         But we don't need to support systems that are so old.  */\n      if (GetLocaleInfoA (MAKELCID (langid, SORT_DEFAULT), LOCALE_SNAME,\n                          namebuf, sizeof (namebuf) - 1))\n        {\n          /* Convert it to a Unix locale name.  */\n          gl_locale_name_canonicalize (namebuf);\n          return namebuf;\n        }\n    }\n  /* Internet Explorer has an LCID to RFC3066 name mapping stored in\n     HKEY_CLASSES_ROOT\\Mime\\Database\\Rfc1766.  But we better don't use that\n     since IE's i18n subsystem is known to be inconsistent with the native\n     Windows base (e.g. they have different character conversion facilities\n     that produce different results).  */\n  /* Use our own table.  */\n  {\n    int primary, sub;\n\n    /* Split into language and territory part.  */\n    primary = PRIMARYLANGID (langid);\n    sub = SUBLANGID (langid);\n\n    /* Dispatch on language.\n       See also http://www.unicode.org/unicode/onlinedat/languages.html .\n       For details about languages, see https://www.ethnologue.com/ .  */\n    switch (primary)\n      {\n      case LANG_AFRIKAANS:\n        switch (sub)\n          {\n          case SUBLANG_AFRIKAANS_SOUTH_AFRICA: return \"af_ZA\";\n          }\n        return \"af\";\n      case LANG_ALBANIAN:\n        switch (sub)\n          {\n          case SUBLANG_ALBANIAN_ALBANIA: return \"sq_AL\";\n          }\n        return \"sq\";\n      case LANG_ALSATIAN:\n        switch (sub)\n          {\n          case SUBLANG_ALSATIAN_FRANCE: return \"gsw_FR\";\n          }\n        return \"gsw\";\n      case LANG_AMHARIC:\n        switch (sub)\n          {\n          case SUBLANG_AMHARIC_ETHIOPIA: return \"am_ET\";\n          }\n        return \"am\";\n      case LANG_ARABIC:\n        switch (sub)\n          {\n          case SUBLANG_ARABIC_SAUDI_ARABIA: return \"ar_SA\";\n          case SUBLANG_ARABIC_IRAQ: return \"ar_IQ\";\n          case SUBLANG_ARABIC_EGYPT: return \"ar_EG\";\n          case SUBLANG_ARABIC_LIBYA: return \"ar_LY\";\n          case SUBLANG_ARABIC_ALGERIA: return \"ar_DZ\";\n          case SUBLANG_ARABIC_MOROCCO: return \"ar_MA\";\n          case SUBLANG_ARABIC_TUNISIA: return \"ar_TN\";\n          case SUBLANG_ARABIC_OMAN: return \"ar_OM\";\n          case SUBLANG_ARABIC_YEMEN: return \"ar_YE\";\n          case SUBLANG_ARABIC_SYRIA: return \"ar_SY\";\n          case SUBLANG_ARABIC_JORDAN: return \"ar_JO\";\n          case SUBLANG_ARABIC_LEBANON: return \"ar_LB\";\n          case SUBLANG_ARABIC_KUWAIT: return \"ar_KW\";\n          case SUBLANG_ARABIC_UAE: return \"ar_AE\";\n          case SUBLANG_ARABIC_BAHRAIN: return \"ar_BH\";\n          case SUBLANG_ARABIC_QATAR: return \"ar_QA\";\n          }\n        return \"ar\";\n      case LANG_ARMENIAN:\n        switch (sub)\n          {\n          case SUBLANG_ARMENIAN_ARMENIA: return \"hy_AM\";\n          }\n        return \"hy\";\n      case LANG_ASSAMESE:\n        switch (sub)\n          {\n          case SUBLANG_ASSAMESE_INDIA: return \"as_IN\";\n          }\n        return \"as\";\n      case LANG_AZERI:\n        switch (sub)\n          {\n          /* FIXME: Adjust this when Azerbaijani locales appear on Unix.  */\n          case 0x1e: return \"az@latin\";\n          case SUBLANG_AZERI_LATIN: return \"az_AZ@latin\";\n          case 0x1d: return \"az@cyrillic\";\n          case SUBLANG_AZERI_CYRILLIC: return \"az_AZ@cyrillic\";\n          }\n        return \"az\";\n      case LANG_BASHKIR:\n        switch (sub)\n          {\n          case SUBLANG_BASHKIR_RUSSIA: return \"ba_RU\";\n          }\n        return \"ba\";\n      case LANG_BASQUE:\n        switch (sub)\n          {\n          case SUBLANG_BASQUE_BASQUE: return \"eu_ES\";\n          }\n        return \"eu\"; /* Ambiguous: could be \"eu_ES\" or \"eu_FR\".  */\n      case LANG_BELARUSIAN:\n        switch (sub)\n          {\n          case SUBLANG_BELARUSIAN_BELARUS: return \"be_BY\";\n          }\n        return \"be\";\n      case LANG_BENGALI:\n        switch (sub)\n          {\n          case SUBLANG_BENGALI_INDIA: return \"bn_IN\";\n          case SUBLANG_BENGALI_BANGLADESH: return \"bn_BD\";\n          }\n        return \"bn\";\n      case LANG_BRETON:\n        switch (sub)\n          {\n          case SUBLANG_BRETON_FRANCE: return \"br_FR\";\n          }\n        return \"br\";\n      case LANG_BULGARIAN:\n        switch (sub)\n          {\n          case SUBLANG_BULGARIAN_BULGARIA: return \"bg_BG\";\n          }\n        return \"bg\";\n      case LANG_BURMESE:\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"my_MM\";\n          }\n        return \"my\";\n      case LANG_CAMBODIAN:\n        switch (sub)\n          {\n          case SUBLANG_CAMBODIAN_CAMBODIA: return \"km_KH\";\n          }\n        return \"km\";\n      case LANG_CATALAN:\n        switch (sub)\n          {\n          case SUBLANG_CATALAN_SPAIN: return \"ca_ES\";\n          }\n        return \"ca\";\n      case LANG_CHEROKEE:\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"chr_US\";\n          }\n        return \"chr\";\n      case LANG_CHINESE:\n        switch (sub)\n          {\n          case SUBLANG_CHINESE_TRADITIONAL: case 0x1f: return \"zh_TW\";\n          case SUBLANG_CHINESE_SIMPLIFIED: case 0x00: return \"zh_CN\";\n          case SUBLANG_CHINESE_HONGKONG: return \"zh_HK\"; /* traditional */\n          case SUBLANG_CHINESE_SINGAPORE: return \"zh_SG\"; /* simplified */\n          case SUBLANG_CHINESE_MACAU: return \"zh_MO\"; /* traditional */\n          }\n        return \"zh\";\n      case LANG_CORSICAN:\n        switch (sub)\n          {\n          case SUBLANG_CORSICAN_FRANCE: return \"co_FR\";\n          }\n        return \"co\";\n      case LANG_CROATIAN:      /* LANG_CROATIAN == LANG_SERBIAN == LANG_BOSNIAN\n                                * What used to be called Serbo-Croatian\n                                * should really now be two separate\n                                * languages because of political reasons.\n                                * (Says tml, who knows nothing about Serbian\n                                * or Croatian.)\n                                * (I can feel those flames coming already.)\n                                */\n        switch (sub)\n          {\n          /* Croatian */\n          case 0x00: return \"hr\";\n          case SUBLANG_CROATIAN_CROATIA: return \"hr_HR\";\n          case SUBLANG_CROATIAN_BOSNIA_HERZEGOVINA_LATIN: return \"hr_BA\";\n          /* Serbian */\n          case 0x1f: return \"sr\";\n          case 0x1c: return \"sr\"; /* latin */\n          case SUBLANG_SERBIAN_LATIN: return \"sr_CS\"; /* latin */\n          case 0x09: return \"sr_RS\"; /* latin */\n          case 0x0b: return \"sr_ME\"; /* latin */\n          case 0x06: return \"sr_BA\"; /* latin */\n          case 0x1b: return \"sr@cyrillic\";\n          case SUBLANG_SERBIAN_CYRILLIC: return \"sr_CS@cyrillic\";\n          case 0x0a: return \"sr_RS@cyrillic\";\n          case 0x0c: return \"sr_ME@cyrillic\";\n          case 0x07: return \"sr_BA@cyrillic\";\n          /* Bosnian */\n          case 0x1e: return \"bs\";\n          case 0x1a: return \"bs\"; /* latin */\n          case SUBLANG_BOSNIAN_BOSNIA_HERZEGOVINA_LATIN: return \"bs_BA\"; /* latin */\n          case 0x19: return \"bs@cyrillic\";\n          case SUBLANG_BOSNIAN_BOSNIA_HERZEGOVINA_CYRILLIC: return \"bs_BA@cyrillic\";\n          }\n        return \"hr\";\n      case LANG_CZECH:\n        switch (sub)\n          {\n          case SUBLANG_CZECH_CZECH_REPUBLIC: return \"cs_CZ\";\n          }\n        return \"cs\";\n      case LANG_DANISH:\n        switch (sub)\n          {\n          case SUBLANG_DANISH_DENMARK: return \"da_DK\";\n          }\n        return \"da\";\n      case LANG_DARI:\n        /* FIXME: Adjust this when such locales appear on Unix.  */\n        switch (sub)\n          {\n          case SUBLANG_DARI_AFGHANISTAN: return \"prs_AF\";\n          }\n        return \"prs\";\n      case LANG_DIVEHI:\n        switch (sub)\n          {\n          case SUBLANG_DIVEHI_MALDIVES: return \"dv_MV\";\n          }\n        return \"dv\";\n      case LANG_DUTCH:\n        switch (sub)\n          {\n          case SUBLANG_DUTCH: return \"nl_NL\";\n          case SUBLANG_DUTCH_BELGIAN: /* FLEMISH, VLAAMS */ return \"nl_BE\";\n          case SUBLANG_DUTCH_SURINAM: return \"nl_SR\";\n          }\n        return \"nl\";\n      case LANG_EDO:\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"bin_NG\";\n          }\n        return \"bin\";\n      case LANG_ENGLISH:\n        switch (sub)\n          {\n          /* SUBLANG_ENGLISH_US == SUBLANG_DEFAULT. Heh. I thought\n           * English was the language spoken in England.\n           * Oh well.\n           */\n          case SUBLANG_ENGLISH_US: return \"en_US\";\n          case SUBLANG_ENGLISH_UK: return \"en_GB\";\n          case SUBLANG_ENGLISH_AUS: return \"en_AU\";\n          case SUBLANG_ENGLISH_CAN: return \"en_CA\";\n          case SUBLANG_ENGLISH_NZ: return \"en_NZ\";\n          case SUBLANG_ENGLISH_EIRE: return \"en_IE\";\n          case SUBLANG_ENGLISH_SOUTH_AFRICA: return \"en_ZA\";\n          case SUBLANG_ENGLISH_JAMAICA: return \"en_JM\";\n          case SUBLANG_ENGLISH_CARIBBEAN: return \"en_GD\"; /* Grenada? */\n          case SUBLANG_ENGLISH_BELIZE: return \"en_BZ\";\n          case SUBLANG_ENGLISH_TRINIDAD: return \"en_TT\";\n          case SUBLANG_ENGLISH_ZIMBABWE: return \"en_ZW\";\n          case SUBLANG_ENGLISH_PHILIPPINES: return \"en_PH\";\n          case SUBLANG_ENGLISH_INDONESIA: return \"en_ID\";\n          case SUBLANG_ENGLISH_HONGKONG: return \"en_HK\";\n          case SUBLANG_ENGLISH_INDIA: return \"en_IN\";\n          case SUBLANG_ENGLISH_MALAYSIA: return \"en_MY\";\n          case SUBLANG_ENGLISH_SINGAPORE: return \"en_SG\";\n          }\n        return \"en\";\n      case LANG_ESTONIAN:\n        switch (sub)\n          {\n          case SUBLANG_ESTONIAN_ESTONIA: return \"et_EE\";\n          }\n        return \"et\";\n      case LANG_FAEROESE:\n        switch (sub)\n          {\n          case SUBLANG_FAEROESE_FAROE_ISLANDS: return \"fo_FO\";\n          }\n        return \"fo\";\n      case LANG_FARSI:\n        switch (sub)\n          {\n          case SUBLANG_FARSI_IRAN: return \"fa_IR\";\n          }\n        return \"fa\";\n      case LANG_FINNISH:\n        switch (sub)\n          {\n          case SUBLANG_FINNISH_FINLAND: return \"fi_FI\";\n          }\n        return \"fi\";\n      case LANG_FRENCH:\n        switch (sub)\n          {\n          case SUBLANG_FRENCH: return \"fr_FR\";\n          case SUBLANG_FRENCH_BELGIAN: /* WALLOON */ return \"fr_BE\";\n          case SUBLANG_FRENCH_CANADIAN: return \"fr_CA\";\n          case SUBLANG_FRENCH_SWISS: return \"fr_CH\";\n          case SUBLANG_FRENCH_LUXEMBOURG: return \"fr_LU\";\n          case SUBLANG_FRENCH_MONACO: return \"fr_MC\";\n          case SUBLANG_FRENCH_WESTINDIES: return \"fr\"; /* Caribbean? */\n          case SUBLANG_FRENCH_REUNION: return \"fr_RE\";\n          case SUBLANG_FRENCH_CONGO: return \"fr_CG\";\n          case SUBLANG_FRENCH_SENEGAL: return \"fr_SN\";\n          case SUBLANG_FRENCH_CAMEROON: return \"fr_CM\";\n          case SUBLANG_FRENCH_COTEDIVOIRE: return \"fr_CI\";\n          case SUBLANG_FRENCH_MALI: return \"fr_ML\";\n          case SUBLANG_FRENCH_MOROCCO: return \"fr_MA\";\n          case SUBLANG_FRENCH_HAITI: return \"fr_HT\";\n          }\n        return \"fr\";\n      case LANG_FRISIAN:\n        switch (sub)\n          {\n          case SUBLANG_FRISIAN_NETHERLANDS: return \"fy_NL\";\n          }\n        return \"fy\";\n      case LANG_FULFULDE:\n        /* Spoken in Nigeria, Guinea, Senegal, Mali, Niger, Cameroon, Benin.  */\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"ff_NG\";\n          }\n        return \"ff\";\n      case LANG_GAELIC:\n        switch (sub)\n          {\n          case 0x01: /* SCOTTISH */\n            /* old, superseded by LANG_SCOTTISH_GAELIC */\n            return \"gd_GB\";\n          case SUBLANG_IRISH_IRELAND: return \"ga_IE\";\n          }\n        return \"ga\";\n      case LANG_GALICIAN:\n        switch (sub)\n          {\n          case SUBLANG_GALICIAN_SPAIN: return \"gl_ES\";\n          }\n        return \"gl\";\n      case LANG_GEORGIAN:\n        switch (sub)\n          {\n          case SUBLANG_GEORGIAN_GEORGIA: return \"ka_GE\";\n          }\n        return \"ka\";\n      case LANG_GERMAN:\n        switch (sub)\n          {\n          case SUBLANG_GERMAN: return \"de_DE\";\n          case SUBLANG_GERMAN_SWISS: return \"de_CH\";\n          case SUBLANG_GERMAN_AUSTRIAN: return \"de_AT\";\n          case SUBLANG_GERMAN_LUXEMBOURG: return \"de_LU\";\n          case SUBLANG_GERMAN_LIECHTENSTEIN: return \"de_LI\";\n          }\n        return \"de\";\n      case LANG_GREEK:\n        switch (sub)\n          {\n          case SUBLANG_GREEK_GREECE: return \"el_GR\";\n          }\n        return \"el\";\n      case LANG_GREENLANDIC:\n        switch (sub)\n          {\n          case SUBLANG_GREENLANDIC_GREENLAND: return \"kl_GL\";\n          }\n        return \"kl\";\n      case LANG_GUARANI:\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"gn_PY\";\n          }\n        return \"gn\";\n      case LANG_GUJARATI:\n        switch (sub)\n          {\n          case SUBLANG_GUJARATI_INDIA: return \"gu_IN\";\n          }\n        return \"gu\";\n      case LANG_HAUSA:\n        switch (sub)\n          {\n          case 0x1f: return \"ha\";\n          case SUBLANG_HAUSA_NIGERIA_LATIN: return \"ha_NG\";\n          }\n        return \"ha\";\n      case LANG_HAWAIIAN:\n        /* FIXME: Do they mean Hawaiian (\"haw_US\", 1000 speakers)\n           or Hawaii Creole English (\"cpe_US\", 600000 speakers)?  */\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"cpe_US\";\n          }\n        return \"cpe\";\n      case LANG_HEBREW:\n        switch (sub)\n          {\n          case SUBLANG_HEBREW_ISRAEL: return \"he_IL\";\n          }\n        return \"he\";\n      case LANG_HINDI:\n        switch (sub)\n          {\n          case SUBLANG_HINDI_INDIA: return \"hi_IN\";\n          }\n        return \"hi\";\n      case LANG_HUNGARIAN:\n        switch (sub)\n          {\n          case SUBLANG_HUNGARIAN_HUNGARY: return \"hu_HU\";\n          }\n        return \"hu\";\n      case LANG_IBIBIO:\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"nic_NG\";\n          }\n        return \"nic\";\n      case LANG_ICELANDIC:\n        switch (sub)\n          {\n          case SUBLANG_ICELANDIC_ICELAND: return \"is_IS\";\n          }\n        return \"is\";\n      case LANG_IGBO:\n        switch (sub)\n          {\n          case SUBLANG_IGBO_NIGERIA: return \"ig_NG\";\n          }\n        return \"ig\";\n      case LANG_INDONESIAN:\n        switch (sub)\n          {\n          case SUBLANG_INDONESIAN_INDONESIA: return \"id_ID\";\n          }\n        return \"id\";\n      case LANG_INUKTITUT:\n        switch (sub)\n          {\n          case 0x1e: return \"iu\"; /* syllabic */\n          case SUBLANG_INUKTITUT_CANADA: return \"iu_CA\"; /* syllabic */\n          case 0x1f: return \"iu@latin\";\n          case SUBLANG_INUKTITUT_CANADA_LATIN: return \"iu_CA@latin\";\n          }\n        return \"iu\";\n      case LANG_ITALIAN:\n        switch (sub)\n          {\n          case SUBLANG_ITALIAN: return \"it_IT\";\n          case SUBLANG_ITALIAN_SWISS: return \"it_CH\";\n          }\n        return \"it\";\n      case LANG_JAPANESE:\n        switch (sub)\n          {\n          case SUBLANG_JAPANESE_JAPAN: return \"ja_JP\";\n          }\n        return \"ja\";\n      case LANG_KANNADA:\n        switch (sub)\n          {\n          case SUBLANG_KANNADA_INDIA: return \"kn_IN\";\n          }\n        return \"kn\";\n      case LANG_KANURI:\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"kr_NG\";\n          }\n        return \"kr\";\n      case LANG_KASHMIRI:\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"ks_PK\";\n          case SUBLANG_KASHMIRI_INDIA: return \"ks_IN\";\n          }\n        return \"ks\";\n      case LANG_KAZAK:\n        switch (sub)\n          {\n          case SUBLANG_KAZAK_KAZAKHSTAN: return \"kk_KZ\";\n          }\n        return \"kk\";\n      case LANG_KICHE:\n        /* FIXME: Adjust this when such locales appear on Unix.  */\n        switch (sub)\n          {\n          case SUBLANG_KICHE_GUATEMALA: return \"qut_GT\";\n          }\n        return \"qut\";\n      case LANG_KINYARWANDA:\n        switch (sub)\n          {\n          case SUBLANG_KINYARWANDA_RWANDA: return \"rw_RW\";\n          }\n        return \"rw\";\n      case LANG_KONKANI:\n        /* FIXME: Adjust this when such locales appear on Unix.  */\n        switch (sub)\n          {\n          case SUBLANG_KONKANI_INDIA: return \"kok_IN\";\n          }\n        return \"kok\";\n      case LANG_KOREAN:\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"ko_KR\";\n          }\n        return \"ko\";\n      case LANG_KYRGYZ:\n        switch (sub)\n          {\n          case SUBLANG_KYRGYZ_KYRGYZSTAN: return \"ky_KG\";\n          }\n        return \"ky\";\n      case LANG_LAO:\n        switch (sub)\n          {\n          case SUBLANG_LAO_LAOS: return \"lo_LA\";\n          }\n        return \"lo\";\n      case LANG_LATIN:\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"la_VA\";\n          }\n        return \"la\";\n      case LANG_LATVIAN:\n        switch (sub)\n          {\n          case SUBLANG_LATVIAN_LATVIA: return \"lv_LV\";\n          }\n        return \"lv\";\n      case LANG_LITHUANIAN:\n        switch (sub)\n          {\n          case SUBLANG_LITHUANIAN_LITHUANIA: return \"lt_LT\";\n          }\n        return \"lt\";\n      case LANG_LUXEMBOURGISH:\n        switch (sub)\n          {\n          case SUBLANG_LUXEMBOURGISH_LUXEMBOURG: return \"lb_LU\";\n          }\n        return \"lb\";\n      case LANG_MACEDONIAN:\n        switch (sub)\n          {\n          case SUBLANG_MACEDONIAN_MACEDONIA: return \"mk_MK\";\n          }\n        return \"mk\";\n      case LANG_MALAY:\n        switch (sub)\n          {\n          case SUBLANG_MALAY_MALAYSIA: return \"ms_MY\";\n          case SUBLANG_MALAY_BRUNEI_DARUSSALAM: return \"ms_BN\";\n          }\n        return \"ms\";\n      case LANG_MALAYALAM:\n        switch (sub)\n          {\n          case SUBLANG_MALAYALAM_INDIA: return \"ml_IN\";\n          }\n        return \"ml\";\n      case LANG_MALTESE:\n        switch (sub)\n          {\n          case SUBLANG_MALTESE_MALTA: return \"mt_MT\";\n          }\n        return \"mt\";\n      case LANG_MANIPURI:\n        /* FIXME: Adjust this when such locales appear on Unix.  */\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"mni_IN\";\n          }\n        return \"mni\";\n      case LANG_MAORI:\n        switch (sub)\n          {\n          case SUBLANG_MAORI_NEW_ZEALAND: return \"mi_NZ\";\n          }\n        return \"mi\";\n      case LANG_MAPUDUNGUN:\n        switch (sub)\n          {\n          case SUBLANG_MAPUDUNGUN_CHILE: return \"arn_CL\";\n          }\n        return \"arn\";\n      case LANG_MARATHI:\n        switch (sub)\n          {\n          case SUBLANG_MARATHI_INDIA: return \"mr_IN\";\n          }\n        return \"mr\";\n      case LANG_MOHAWK:\n        switch (sub)\n          {\n          case SUBLANG_MOHAWK_CANADA: return \"moh_CA\";\n          }\n        return \"moh\";\n      case LANG_MONGOLIAN:\n        switch (sub)\n          {\n          case SUBLANG_MONGOLIAN_CYRILLIC_MONGOLIA: case 0x1e: return \"mn_MN\";\n          case SUBLANG_MONGOLIAN_PRC: case 0x1f: return \"mn_CN\";\n          }\n        return \"mn\"; /* Ambiguous: could be \"mn_CN\" or \"mn_MN\".  */\n      case LANG_NEPALI:\n        switch (sub)\n          {\n          case SUBLANG_NEPALI_NEPAL: return \"ne_NP\";\n          case SUBLANG_NEPALI_INDIA: return \"ne_IN\";\n          }\n        return \"ne\";\n      case LANG_NORWEGIAN:\n        switch (sub)\n          {\n          case 0x1f: return \"nb\";\n          case SUBLANG_NORWEGIAN_BOKMAL: return \"nb_NO\";\n          case 0x1e: return \"nn\";\n          case SUBLANG_NORWEGIAN_NYNORSK: return \"nn_NO\";\n          }\n        return \"no\";\n      case LANG_OCCITAN:\n        switch (sub)\n          {\n          case SUBLANG_OCCITAN_FRANCE: return \"oc_FR\";\n          }\n        return \"oc\";\n      case LANG_ORIYA:\n        switch (sub)\n          {\n          case SUBLANG_ORIYA_INDIA: return \"or_IN\";\n          }\n        return \"or\";\n      case LANG_OROMO:\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"om_ET\";\n          }\n        return \"om\";\n      case LANG_PAPIAMENTU:\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"pap_AN\";\n          }\n        return \"pap\";\n      case LANG_PASHTO:\n        switch (sub)\n          {\n          case SUBLANG_PASHTO_AFGHANISTAN: return \"ps_AF\";\n          }\n        return \"ps\"; /* Ambiguous: could be \"ps_PK\" or \"ps_AF\".  */\n      case LANG_POLISH:\n        switch (sub)\n          {\n          case SUBLANG_POLISH_POLAND: return \"pl_PL\";\n          }\n        return \"pl\";\n      case LANG_PORTUGUESE:\n        switch (sub)\n          {\n          /* Hmm. SUBLANG_PORTUGUESE_BRAZILIAN == SUBLANG_DEFAULT.\n             Same phenomenon as SUBLANG_ENGLISH_US == SUBLANG_DEFAULT. */\n          case SUBLANG_PORTUGUESE_BRAZILIAN: return \"pt_BR\";\n          case SUBLANG_PORTUGUESE: return \"pt_PT\";\n          }\n        return \"pt\";\n      case LANG_PUNJABI:\n        switch (sub)\n          {\n          case SUBLANG_PUNJABI_INDIA: return \"pa_IN\"; /* Gurmukhi script */\n          case SUBLANG_PUNJABI_PAKISTAN: return \"pa_PK\"; /* Arabic script */\n          }\n        return \"pa\";\n      case LANG_QUECHUA:\n        /* Note: Microsoft uses the non-ISO language code \"quz\".  */\n        switch (sub)\n          {\n          case SUBLANG_QUECHUA_BOLIVIA: return \"qu_BO\";\n          case SUBLANG_QUECHUA_ECUADOR: return \"qu_EC\";\n          case SUBLANG_QUECHUA_PERU: return \"qu_PE\";\n          }\n        return \"qu\";\n      case LANG_ROMANIAN:\n        switch (sub)\n          {\n          case SUBLANG_ROMANIAN_ROMANIA: return \"ro_RO\";\n          case SUBLANG_ROMANIAN_MOLDOVA: return \"ro_MD\";\n          }\n        return \"ro\";\n      case LANG_ROMANSH:\n        switch (sub)\n          {\n          case SUBLANG_ROMANSH_SWITZERLAND: return \"rm_CH\";\n          }\n        return \"rm\";\n      case LANG_RUSSIAN:\n        switch (sub)\n          {\n          case SUBLANG_RUSSIAN_RUSSIA: return \"ru_RU\";\n          case SUBLANG_RUSSIAN_MOLDAVIA: return \"ru_MD\";\n          }\n        return \"ru\"; /* Ambiguous: could be \"ru_RU\" or \"ru_UA\" or \"ru_MD\".  */\n      case LANG_SAMI:\n        switch (sub)\n          {\n          /* Northern Sami */\n          case 0x00: return \"se\";\n          case SUBLANG_SAMI_NORTHERN_NORWAY: return \"se_NO\";\n          case SUBLANG_SAMI_NORTHERN_SWEDEN: return \"se_SE\";\n          case SUBLANG_SAMI_NORTHERN_FINLAND: return \"se_FI\";\n          /* Lule Sami */\n          case 0x1f: return \"smj\";\n          case SUBLANG_SAMI_LULE_NORWAY: return \"smj_NO\";\n          case SUBLANG_SAMI_LULE_SWEDEN: return \"smj_SE\";\n          /* Southern Sami */\n          case 0x1e: return \"sma\";\n          case SUBLANG_SAMI_SOUTHERN_NORWAY: return \"sma_NO\";\n          case SUBLANG_SAMI_SOUTHERN_SWEDEN: return \"sma_SE\";\n          /* Skolt Sami */\n          case 0x1d: return \"sms\";\n          case SUBLANG_SAMI_SKOLT_FINLAND: return \"sms_FI\";\n          /* Inari Sami */\n          case 0x1c: return \"smn\";\n          case SUBLANG_SAMI_INARI_FINLAND: return \"smn_FI\";\n          }\n        return \"se\"; /* or \"smi\"? */\n      case LANG_SANSKRIT:\n        switch (sub)\n          {\n          case SUBLANG_SANSKRIT_INDIA: return \"sa_IN\";\n          }\n        return \"sa\";\n      case LANG_SCOTTISH_GAELIC:\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"gd_GB\";\n          }\n        return \"gd\";\n      case LANG_SINDHI:\n        switch (sub)\n          {\n          case SUBLANG_SINDHI_INDIA: return \"sd_IN\";\n          case SUBLANG_SINDHI_PAKISTAN: return \"sd_PK\";\n          /*case SUBLANG_SINDHI_AFGHANISTAN: return \"sd_AF\";*/\n          }\n        return \"sd\";\n      case LANG_SINHALESE:\n        switch (sub)\n          {\n          case SUBLANG_SINHALESE_SRI_LANKA: return \"si_LK\";\n          }\n        return \"si\";\n      case LANG_SLOVAK:\n        switch (sub)\n          {\n          case SUBLANG_SLOVAK_SLOVAKIA: return \"sk_SK\";\n          }\n        return \"sk\";\n      case LANG_SLOVENIAN:\n        switch (sub)\n          {\n          case SUBLANG_SLOVENIAN_SLOVENIA: return \"sl_SI\";\n          }\n        return \"sl\";\n      case LANG_SOMALI:\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"so_SO\";\n          }\n        return \"so\";\n      case LANG_SORBIAN:\n        /* FIXME: Adjust this when such locales appear on Unix.  */\n        switch (sub)\n          {\n          /* Upper Sorbian */\n          case 0x00: return \"hsb\";\n          case SUBLANG_UPPER_SORBIAN_GERMANY: return \"hsb_DE\";\n          /* Lower Sorbian */\n          case 0x1f: return \"dsb\";\n          case SUBLANG_LOWER_SORBIAN_GERMANY: return \"dsb_DE\";\n          }\n        return \"wen\";\n      case LANG_SOTHO:\n        /* <https://msdn.microsoft.com/en-us/library/dd318693.aspx> calls\n           it \"Sesotho sa Leboa\"; according to\n           <https://www.ethnologue.com/show_language.asp?code=nso>\n           <https://www.ethnologue.com/show_language.asp?code=sot>\n           it's the same as Northern Sotho.  */\n        switch (sub)\n          {\n          case SUBLANG_SOTHO_SOUTH_AFRICA: return \"nso_ZA\";\n          }\n        return \"nso\";\n      case LANG_SPANISH:\n        switch (sub)\n          {\n          case SUBLANG_SPANISH: return \"es_ES\";\n          case SUBLANG_SPANISH_MEXICAN: return \"es_MX\";\n          case SUBLANG_SPANISH_MODERN:\n            return \"es_ES@modern\";      /* not seen on Unix */\n          case SUBLANG_SPANISH_GUATEMALA: return \"es_GT\";\n          case SUBLANG_SPANISH_COSTA_RICA: return \"es_CR\";\n          case SUBLANG_SPANISH_PANAMA: return \"es_PA\";\n          case SUBLANG_SPANISH_DOMINICAN_REPUBLIC: return \"es_DO\";\n          case SUBLANG_SPANISH_VENEZUELA: return \"es_VE\";\n          case SUBLANG_SPANISH_COLOMBIA: return \"es_CO\";\n          case SUBLANG_SPANISH_PERU: return \"es_PE\";\n          case SUBLANG_SPANISH_ARGENTINA: return \"es_AR\";\n          case SUBLANG_SPANISH_ECUADOR: return \"es_EC\";\n          case SUBLANG_SPANISH_CHILE: return \"es_CL\";\n          case SUBLANG_SPANISH_URUGUAY: return \"es_UY\";\n          case SUBLANG_SPANISH_PARAGUAY: return \"es_PY\";\n          case SUBLANG_SPANISH_BOLIVIA: return \"es_BO\";\n          case SUBLANG_SPANISH_EL_SALVADOR: return \"es_SV\";\n          case SUBLANG_SPANISH_HONDURAS: return \"es_HN\";\n          case SUBLANG_SPANISH_NICARAGUA: return \"es_NI\";\n          case SUBLANG_SPANISH_PUERTO_RICO: return \"es_PR\";\n          case SUBLANG_SPANISH_US: return \"es_US\";\n          }\n        return \"es\";\n      case LANG_SUTU:\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"bnt_TZ\"; /* or \"st_LS\" or \"nso_ZA\"? */\n          }\n        return \"bnt\";\n      case LANG_SWAHILI:\n        switch (sub)\n          {\n          case SUBLANG_SWAHILI_KENYA: return \"sw_KE\";\n          }\n        return \"sw\";\n      case LANG_SWEDISH:\n        switch (sub)\n          {\n          case SUBLANG_SWEDISH_SWEDEN: return \"sv_SE\";\n          case SUBLANG_SWEDISH_FINLAND: return \"sv_FI\";\n          }\n        return \"sv\";\n      case LANG_SYRIAC:\n        switch (sub)\n          {\n          case SUBLANG_SYRIAC_SYRIA: return \"syr_SY\"; /* An extinct language.  */\n          }\n        return \"syr\";\n      case LANG_TAGALOG:\n        switch (sub)\n          {\n          case SUBLANG_TAGALOG_PHILIPPINES: return \"tl_PH\"; /* or \"fil_PH\"? */\n          }\n        return \"tl\"; /* or \"fil\"? */\n      case LANG_TAJIK:\n        switch (sub)\n          {\n          case 0x1f: return \"tg\";\n          case SUBLANG_TAJIK_TAJIKISTAN: return \"tg_TJ\";\n          }\n        return \"tg\";\n      case LANG_TAMAZIGHT:\n        /* Note: Microsoft uses the non-ISO language code \"tmz\".  */\n        switch (sub)\n          {\n          /* FIXME: Adjust this when Tamazight locales appear on Unix.  */\n          case SUBLANG_TAMAZIGHT_ARABIC: return \"ber_MA@arabic\";\n          case 0x1f: return \"ber@latin\";\n          case SUBLANG_TAMAZIGHT_ALGERIA_LATIN: return \"ber_DZ@latin\";\n          }\n        return \"ber\";\n      case LANG_TAMIL:\n        switch (sub)\n          {\n          case SUBLANG_TAMIL_INDIA: return \"ta_IN\";\n          }\n        return \"ta\"; /* Ambiguous: could be \"ta_IN\" or \"ta_LK\" or \"ta_SG\".  */\n      case LANG_TATAR:\n        switch (sub)\n          {\n          case SUBLANG_TATAR_RUSSIA: return \"tt_RU\";\n          }\n        return \"tt\";\n      case LANG_TELUGU:\n        switch (sub)\n          {\n          case SUBLANG_TELUGU_INDIA: return \"te_IN\";\n          }\n        return \"te\";\n      case LANG_THAI:\n        switch (sub)\n          {\n          case SUBLANG_THAI_THAILAND: return \"th_TH\";\n          }\n        return \"th\";\n      case LANG_TIBETAN:\n        switch (sub)\n          {\n          case SUBLANG_TIBETAN_PRC:\n            /* Most Tibetans would not like \"bo_CN\".  But Tibet does not yet\n               have a country code of its own.  */\n            return \"bo\";\n          case SUBLANG_TIBETAN_BHUTAN: return \"bo_BT\";\n          }\n        return \"bo\";\n      case LANG_TIGRINYA:\n        switch (sub)\n          {\n          case SUBLANG_TIGRINYA_ETHIOPIA: return \"ti_ET\";\n          case SUBLANG_TIGRINYA_ERITREA: return \"ti_ER\";\n          }\n        return \"ti\";\n      case LANG_TSONGA:\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"ts_ZA\";\n          }\n        return \"ts\";\n      case LANG_TSWANA:\n        /* Spoken in South Africa, Botswana.  */\n        switch (sub)\n          {\n          case SUBLANG_TSWANA_SOUTH_AFRICA: return \"tn_ZA\";\n          }\n        return \"tn\";\n      case LANG_TURKISH:\n        switch (sub)\n          {\n          case SUBLANG_TURKISH_TURKEY: return \"tr_TR\";\n          }\n        return \"tr\";\n      case LANG_TURKMEN:\n        switch (sub)\n          {\n          case SUBLANG_TURKMEN_TURKMENISTAN: return \"tk_TM\";\n          }\n        return \"tk\";\n      case LANG_UIGHUR:\n        switch (sub)\n          {\n          case SUBLANG_UIGHUR_PRC: return \"ug_CN\";\n          }\n        return \"ug\";\n      case LANG_UKRAINIAN:\n        switch (sub)\n          {\n          case SUBLANG_UKRAINIAN_UKRAINE: return \"uk_UA\";\n          }\n        return \"uk\";\n      case LANG_URDU:\n        switch (sub)\n          {\n          case SUBLANG_URDU_PAKISTAN: return \"ur_PK\";\n          case SUBLANG_URDU_INDIA: return \"ur_IN\";\n          }\n        return \"ur\";\n      case LANG_UZBEK:\n        switch (sub)\n          {\n          case 0x1f: return \"uz\";\n          case SUBLANG_UZBEK_LATIN: return \"uz_UZ\";\n          case 0x1e: return \"uz@cyrillic\";\n          case SUBLANG_UZBEK_CYRILLIC: return \"uz_UZ@cyrillic\";\n          }\n        return \"uz\";\n      case LANG_VENDA:\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"ve_ZA\";\n          }\n        return \"ve\";\n      case LANG_VIETNAMESE:\n        switch (sub)\n          {\n          case SUBLANG_VIETNAMESE_VIETNAM: return \"vi_VN\";\n          }\n        return \"vi\";\n      case LANG_WELSH:\n        switch (sub)\n          {\n          case SUBLANG_WELSH_UNITED_KINGDOM: return \"cy_GB\";\n          }\n        return \"cy\";\n      case LANG_WOLOF:\n        switch (sub)\n          {\n          case SUBLANG_WOLOF_SENEGAL: return \"wo_SN\";\n          }\n        return \"wo\";\n      case LANG_XHOSA:\n        switch (sub)\n          {\n          case SUBLANG_XHOSA_SOUTH_AFRICA: return \"xh_ZA\";\n          }\n        return \"xh\";\n      case LANG_YAKUT:\n        switch (sub)\n          {\n          case SUBLANG_YAKUT_RUSSIA: return \"sah_RU\";\n          }\n        return \"sah\";\n      case LANG_YI:\n        switch (sub)\n          {\n          case SUBLANG_YI_PRC: return \"ii_CN\";\n          }\n        return \"ii\";\n      case LANG_YIDDISH:\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"yi_IL\";\n          }\n        return \"yi\";\n      case LANG_YORUBA:\n        switch (sub)\n          {\n          case SUBLANG_YORUBA_NIGERIA: return \"yo_NG\";\n          }\n        return \"yo\";\n      case LANG_ZULU:\n        switch (sub)\n          {\n          case SUBLANG_ZULU_SOUTH_AFRICA: return \"zu_ZA\";\n          }\n        return \"zu\";\n      default: return \"C\";\n      }\n  }\n}",
      "lines": 1044,
      "depth": 12,
      "decorators": [
        "const",
        "const",
        "char",
        "*\ngl_locale_name_from_win32_LANGID (LANGID langid)",
        "*"
      ]
    },
    "gl_locale_name_from_win32_LCID": {
      "start_point": [
        2508,
        0
      ],
      "end_point": [
        2517,
        1
      ],
      "content": "const char *\ngl_locale_name_from_win32_LCID (LCID lcid)\n{\n  LANGID langid;\n\n  /* Strip off the sorting rules, keep only the language part.  */\n  langid = LANGIDFROMLCID (lcid);\n\n  return gl_locale_name_from_win32_LANGID (langid);\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "const",
        "const",
        "char",
        "*\ngl_locale_name_from_win32_LCID (LCID lcid)",
        "*"
      ]
    },
    "enum_locales_fn": {
      "start_point": [
        2527,
        0
      ],
      "end_point": [
        2553,
        1
      ],
      "content": "static BOOL CALLBACK\nenum_locales_fn (LPTSTR locale_num_str)\n{\n  char *endp;\n  char locval[2 * LOCALE_NAME_MAX_LENGTH + 1 + 1];\n  LCID try_lcid = strtoul (locale_num_str, &endp, 16);\n\n  if (GetLocaleInfo (try_lcid, LOCALE_SENGLANGUAGE,\n                    locval, LOCALE_NAME_MAX_LENGTH))\n    {\n      strcat (locval, \"_\");\n      if (GetLocaleInfo (try_lcid, LOCALE_SENGCOUNTRY,\n                        locval + strlen (locval), LOCALE_NAME_MAX_LENGTH))\n       {\n         size_t locval_len = strlen (locval);\n\n         if (strncmp (locval, lname, locval_len) == 0\n             && (lname[locval_len] == '.'\n                 || lname[locval_len] == '\\0'))\n           {\n             found_lcid = try_lcid;\n             return FALSE;\n           }\n       }\n    }\n  return TRUE;\n}",
      "lines": 27,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "BOOL",
        "CALLBACK",
        "CALLBACK"
      ]
    },
    "get_lcid": {
      "start_point": [
        2562,
        0
      ],
      "end_point": [
        2588,
        1
      ],
      "content": "static LCID\nget_lcid (const char *locale_name)\n{\n  /* A simple cache.  */\n  static LCID last_lcid;\n  static char last_locale[1000];\n\n  /* Lock while looking for an LCID, to protect access to static\n     variables: last_lcid, last_locale, found_lcid, and lname.  */\n  gl_lock_lock (get_lcid_lock);\n  if (last_lcid > 0 && strcmp (locale_name, last_locale) == 0)\n    {\n      gl_lock_unlock (get_lcid_lock);\n      return last_lcid;\n    }\n  strncpy (lname, locale_name, sizeof (lname) - 1);\n  lname[sizeof (lname) - 1] = '\\0';\n  found_lcid = 0;\n  EnumSystemLocales (enum_locales_fn, LCID_SUPPORTED);\n  if (found_lcid > 0)\n    {\n      last_lcid = found_lcid;\n      strcpy (last_locale, locale_name);\n    }\n  gl_lock_unlock (get_lcid_lock);\n  return found_lcid;\n}",
      "lines": 27,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "LCID"
      ]
    },
    "string_hash": {
      "start_point": [
        2604,
        0
      ],
      "end_point": [
        2614,
        1
      ],
      "content": "static size_t _GL_ATTRIBUTE_PURE\nstring_hash (const void *x)\n{\n  const char *s = (const char *) x;\n  size_t h = 0;\n\n  for (; *s; s++)\n    h = *s + ((h << 9) | (h >> (SIZE_BITS - 9)));\n\n  return h;\n}",
      "lines": 11,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "size_t",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "struniq": {
      "start_point": [
        2636,
        0
      ],
      "end_point": [
        2674,
        1
      ],
      "content": "static const char *\nstruniq (const char *string)\n{\n  size_t hashcode = string_hash (string);\n  size_t slot = hashcode % HASH_TABLE_SIZE;\n  size_t size;\n  struct hash_node *new_node;\n  struct hash_node *p;\n  for (p = struniq_hash_table[slot]; p != NULL; p = p->next)\n    if (strcmp (p->contents, string) == 0)\n      return p->contents;\n  size = strlen (string) + 1;\n  new_node =\n    (struct hash_node *)\n    malloc (FLEXSIZEOF (struct hash_node, contents, size));\n  if (new_node == NULL)\n    /* Out of memory.  Return a statically allocated string.  */\n    return \"C\";\n  memcpy (new_node->contents, string, size);\n  /* Lock while inserting new_node.  */\n  gl_lock_lock (struniq_lock);\n  /* Check whether another thread already added the string while we were\n     waiting on the lock.  */\n  for (p = struniq_hash_table[slot]; p != NULL; p = p->next)\n    if (strcmp (p->contents, string) == 0)\n      {\n        free (new_node);\n        new_node = p;\n        goto done;\n      }\n  /* Really insert new_node into the hash table.  Fill new_node entirely first,\n     because other threads may be iterating over the linked list.  */\n  new_node->next = struniq_hash_table[slot];\n  struniq_hash_table[slot] = new_node;\n done:\n  /* Unlock after new_node is inserted.  */\n  gl_lock_unlock (struniq_lock);\n  return new_node->contents;\n}",
      "lines": 39,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nstruniq (const char *string)",
        "*"
      ]
    },
    "gl_locale_name_thread_unsafe": {
      "start_point": [
        2686,
        0
      ],
      "end_point": [
        2777,
        1
      ],
      "content": "const char *\ngl_locale_name_thread_unsafe (int category, const char *categoryname)\n{\n# if HAVE_USELOCALE\n  {\n    locale_t thread_locale = uselocale (NULL);\n    if (thread_locale != LC_GLOBAL_LOCALE)\n      {\n#  if __GLIBC__ >= 2 && !defined __UCLIBC__\n        /* Work around an incorrect definition of the _NL_LOCALE_NAME macro in\n           glibc < 2.12.\n           See <https://sourceware.org/bugzilla/show_bug.cgi?id=10968>.  */\n        const char *name =\n          nl_langinfo (_NL_ITEM ((category), _NL_ITEM_INDEX (-1)));\n        if (name[0] == '\\0')\n          /* Fallback code for glibc < 2.4, which did not implement\n             nl_langinfo (_NL_LOCALE_NAME (category)).  */\n          name = thread_locale->__names[category];\n        return name;\n#  elif defined __linux__ && HAVE_LANGINFO_H && defined NL_LOCALE_NAME\n        /* musl libc */\n        return nl_langinfo_l (NL_LOCALE_NAME (category), thread_locale);\n#  elif (defined __FreeBSD__ || defined __DragonFly__) || (defined __APPLE__ && defined __MACH__)\n        /* FreeBSD, Mac OS X */\n        int mask;\n\n        switch (category)\n          {\n          case LC_CTYPE:\n            mask = LC_CTYPE_MASK;\n            break;\n          case LC_NUMERIC:\n            mask = LC_NUMERIC_MASK;\n            break;\n          case LC_TIME:\n            mask = LC_TIME_MASK;\n            break;\n          case LC_COLLATE:\n            mask = LC_COLLATE_MASK;\n            break;\n          case LC_MONETARY:\n            mask = LC_MONETARY_MASK;\n            break;\n          case LC_MESSAGES:\n            mask = LC_MESSAGES_MASK;\n            break;\n          default: /* We shouldn't get here.  */\n            return \"\";\n          }\n        return querylocale (mask, thread_locale);\n#  elif defined __sun\n#   if HAVE_GETLOCALENAME_L\n        /* Solaris >= 12.  */\n        return getlocalename_l (category, thread_locale);\n#   else\n        /* Solaris 11 OpenIndiana.\n           For the internal structure of locale objects, see\n           https://github.com/OpenIndiana/illumos-gate/blob/master/usr/src/lib/libc/port/locale/localeimpl.h  */\n        switch (category)\n          {\n          case LC_CTYPE:\n          case LC_NUMERIC:\n          case LC_TIME:\n          case LC_COLLATE:\n          case LC_MONETARY:\n          case LC_MESSAGES:\n            return ((const char * const *) thread_locale)[category];\n          default: /* We shouldn't get here.  */\n            return \"\";\n          }\n#   endif\n#  elif defined __CYGWIN__\n        /* Cygwin < 2.6 lacks uselocale and thread-local locales altogether.\n           Cygwin <= 2.6.1 lacks NL_LOCALE_NAME, requiring peeking inside\n           an opaque struct.  */\n#   ifdef NL_LOCALE_NAME\n        return nl_langinfo_l (NL_LOCALE_NAME (category), thread_locale);\n#   else\n        /* FIXME: Remove when we can assume new-enough Cygwin.  */\n        struct __locale_t {\n          char categories[7][32];\n        };\n        return ((struct __locale_t *) thread_locale)->categories[category];\n#   endif\n#  elif defined __ANDROID__\n        return MB_CUR_MAX == 4 ? \"C.UTF-8\" : \"C\";\n#  endif\n      }\n  }\n# endif\n  return NULL;\n}",
      "lines": 92,
      "depth": 23,
      "decorators": [
        "const",
        "const",
        "char",
        "*\ngl_locale_name_thread_unsafe (int category, const char *categoryname)",
        "*"
      ]
    },
    "gl_locale_name_thread": {
      "start_point": [
        2781,
        0
      ],
      "end_point": [
        2811,
        1
      ],
      "content": "const char *\ngl_locale_name_thread (int category, const char *categoryname)\n{\n#if HAVE_USELOCALE\n  const char *name = gl_locale_name_thread_unsafe (category, categoryname);\n  if (name != NULL)\n    return struniq (name);\n#elif defined WINDOWS_NATIVE\n  if (LC_MIN <= category && category <= LC_MAX)\n    {\n      char *locname = setlocale (category, NULL);\n      LCID lcid = 0;\n\n      /* If CATEGORY is LC_ALL, the result might be a semi-colon\n        separated list of locales.  We need only one, so we take the\n        one corresponding to LC_CTYPE, as the most important for\n        character translations.  */\n      if (strchr (locname, ';'))\n       locname = setlocale (LC_CTYPE, NULL);\n\n      /* Convert locale name to LCID.  We don't want to use\n         LocaleNameToLCID because (a) it is only available since Vista,\n         and (b) it doesn't accept locale names returned by 'setlocale'.  */\n      lcid = get_lcid (locname);\n\n      if (lcid > 0)\n        return gl_locale_name_from_win32_LCID (lcid);\n    }\n#endif\n  return NULL;\n}",
      "lines": 31,
      "depth": 12,
      "decorators": [
        "const",
        "const",
        "char",
        "*\ngl_locale_name_thread (int category, const char *categoryname)",
        "*"
      ]
    },
    "gl_locale_name_posix": {
      "start_point": [
        2823,
        0
      ],
      "end_point": [
        2850,
        1
      ],
      "content": "const char *\ngl_locale_name_posix (int category, const char *categoryname)\n{\n  /* Use the POSIX methods of looking to 'LC_ALL', 'LC_xxx', and 'LANG'.\n     On some systems this can be done by the 'setlocale' function itself.  */\n#if defined HAVE_SETLOCALE && defined HAVE_LC_MESSAGES && defined HAVE_LOCALE_NULL\n  return setlocale (category, NULL);\n#else\n  /* On other systems we ignore what setlocale reports and instead look at the\n     environment variables directly.  This is necessary\n       1. on systems which have a facility for customizing the default locale\n          (Mac OS X, native Windows, Cygwin) and where the system's setlocale()\n          function ignores this default locale (Mac OS X, Cygwin), in two cases:\n          a. when the user missed to use the setlocale() override from libintl\n             (for example by not including <libintl.h>),\n          b. when setlocale supports only the \"C\" locale, such as on Cygwin\n             1.5.x.  In this case even the override from libintl cannot help.\n       2. on all systems where setlocale supports only the \"C\" locale.  */\n  /* Strictly speaking, it is a POSIX violation to look at the environment\n     variables regardless whether setlocale has been called or not.  POSIX\n     says:\n         \"For C-language programs, the POSIX locale shall be the\n          default locale when the setlocale() function is not called.\"\n     But we assume that all programs that use internationalized APIs call\n     setlocale (LC_ALL, \"\").  */\n  return gl_locale_name_environ (category, categoryname);\n#endif\n}",
      "lines": 28,
      "depth": 8,
      "decorators": [
        "const",
        "const",
        "char",
        "*\ngl_locale_name_posix (int category, const char *categoryname)",
        "*"
      ]
    },
    "gl_locale_name_environ": {
      "start_point": [
        2852,
        0
      ],
      "end_point": [
        2883,
        1
      ],
      "content": "const char *\ngl_locale_name_environ (int category, const char *categoryname)\n{\n  const char *retval;\n\n  /* Setting of LC_ALL overrides all other.  */\n  retval = getenv (\"LC_ALL\");\n  if (retval != NULL && retval[0] != '\\0')\n    return retval;\n  /* Next comes the name of the desired category.  */\n  retval = getenv (categoryname);\n  if (retval != NULL && retval[0] != '\\0')\n    return retval;\n  /* Last possibility is the LANG environment variable.  */\n  retval = getenv (\"LANG\");\n  if (retval != NULL && retval[0] != '\\0')\n    {\n#if HAVE_CFLOCALECOPYCURRENT || HAVE_CFPREFERENCESCOPYAPPVALUE\n      /* Mac OS X 10.2 or newer.\n         Ignore invalid LANG value set by the Terminal application.  */\n      if (strcmp (retval, \"UTF-8\") != 0)\n#endif\n#if defined __CYGWIN__\n      /* Cygwin.\n         Ignore dummy LANG value set by ~/.profile.  */\n      if (strcmp (retval, \"C.UTF-8\") != 0)\n#endif\n        return retval;\n    }\n\n  return NULL;\n}",
      "lines": 32,
      "depth": 12,
      "decorators": [
        "const",
        "const",
        "char",
        "*\ngl_locale_name_environ (int category, const char *categoryname)",
        "*"
      ]
    },
    "gl_locale_name_default": {
      "start_point": [
        2885,
        0
      ],
      "end_point": [
        2982,
        1
      ],
      "content": "const char *\ngl_locale_name_default (void)\n{\n  /* POSIX:2001 says:\n     \"All implementations shall define a locale as the default locale, to be\n      invoked when no environment variables are set, or set to the empty\n      string.  This default locale can be the POSIX locale or any other\n      implementation-defined locale.  Some implementations may provide\n      facilities for local installation administrators to set the default\n      locale, customizing it for each location.  POSIX:2001 does not require\n      such a facility.\n\n     The systems with such a facility are Mac OS X and Windows: They provide a\n     GUI that allows the user to choose a locale.\n       - On Mac OS X, by default, none of LC_* or LANG are set.  Starting with\n         Mac OS X 10.4 or 10.5, LANG is set for processes launched by the\n         'Terminal' application (but sometimes to an incorrect value \"UTF-8\").\n         When no environment variable is set, setlocale (LC_ALL, \"\") uses the\n         \"C\" locale.\n       - On native Windows, by default, none of LC_* or LANG are set.\n         When no environment variable is set, setlocale (LC_ALL, \"\") uses the\n         locale chosen by the user.\n       - On Cygwin 1.5.x, by default, none of LC_* or LANG are set.\n         When no environment variable is set, setlocale (LC_ALL, \"\") uses the\n         \"C\" locale.\n       - On Cygwin 1.7, by default, LANG is set to \"C.UTF-8\" when the default\n         ~/.profile is executed.\n         When no environment variable is set, setlocale (LC_ALL, \"\") uses the\n         \"C.UTF-8\" locale, which operates in the same way as the \"C\" locale.\n  */\n\n#if !(HAVE_CFLOCALECOPYCURRENT || HAVE_CFPREFERENCESCOPYAPPVALUE || defined WINDOWS_NATIVE || defined __CYGWIN__)\n\n  /* The system does not have a way of setting the locale, other than the\n     POSIX specified environment variables.  We use C as default locale.  */\n  return \"C\";\n\n#else\n\n  /* Return an XPG style locale name language[_territory][@modifier].\n     Don't even bother determining the codeset; it's not useful in this\n     context, because message catalogs are not specific to a single\n     codeset.  */\n\n# if HAVE_CFLOCALECOPYCURRENT || HAVE_CFPREFERENCESCOPYAPPVALUE\n  /* Mac OS X 10.2 or newer */\n  {\n    /* Cache the locale name, since CoreFoundation calls are expensive.  */\n    static const char *cached_localename;\n\n    if (cached_localename == NULL)\n      {\n        char namebuf[256];\n#  if HAVE_CFLOCALECOPYCURRENT /* Mac OS X 10.3 or newer */\n        CFLocaleRef locale = CFLocaleCopyCurrent ();\n        CFStringRef name = CFLocaleGetIdentifier (locale);\n\n        if (CFStringGetCString (name, namebuf, sizeof (namebuf),\n                                kCFStringEncodingASCII))\n          {\n            gl_locale_name_canonicalize (namebuf);\n            cached_localename = strdup (namebuf);\n          }\n        CFRelease (locale);\n#  elif HAVE_CFPREFERENCESCOPYAPPVALUE /* Mac OS X 10.2 or newer */\n        CFTypeRef value =\n          CFPreferencesCopyAppValue (CFSTR (\"AppleLocale\"),\n                                     kCFPreferencesCurrentApplication);\n        if (value != NULL\n            && CFGetTypeID (value) == CFStringGetTypeID ()\n            && CFStringGetCString ((CFStringRef)value,\n                                   namebuf, sizeof (namebuf),\n                                   kCFStringEncodingASCII))\n          {\n            gl_locale_name_canonicalize (namebuf);\n            cached_localename = strdup (namebuf);\n          }\n#  endif\n        if (cached_localename == NULL)\n          cached_localename = \"C\";\n      }\n    return cached_localename;\n  }\n\n# endif\n\n# if defined WINDOWS_NATIVE || defined __CYGWIN__ /* Native Windows or Cygwin */\n  {\n    LCID lcid;\n\n    /* Use native Windows API locale ID.  */\n    lcid = GetThreadLocale ();\n\n    return gl_locale_name_from_win32_LCID (lcid);\n  }\n# endif\n#endif\n}",
      "lines": 98,
      "depth": 18,
      "decorators": [
        "const",
        "const",
        "char",
        "*\ngl_locale_name_default (void)",
        "*"
      ]
    },
    "gl_locale_name": {
      "start_point": [
        2990,
        0
      ],
      "end_point": [
        3004,
        1
      ],
      "content": "const char *\ngl_locale_name (int category, const char *categoryname)\n{\n  const char *retval;\n\n  retval = gl_locale_name_thread (category, categoryname);\n  if (retval != NULL)\n    return retval;\n\n  retval = gl_locale_name_posix (category, categoryname);\n  if (retval != NULL)\n    return retval;\n\n  return gl_locale_name_default ();\n}",
      "lines": 15,
      "depth": 7,
      "decorators": [
        "const",
        "const",
        "char",
        "*\ngl_locale_name (int category, const char *categoryname)",
        "*"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/localename.h": {},
  "sed/sed-4.5/gnulib-tests/lseek.c": {
    "rpl_lseek": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "off_t\nrpl_lseek (int fd, off_t offset, int whence)\n{\n#if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n  /* mingw lseek mistakenly succeeds on pipes, sockets, and terminals.  */\n  HANDLE h = (HANDLE) _get_osfhandle (fd);\n  if (h == INVALID_HANDLE_VALUE)\n    {\n      errno = EBADF;\n      return -1;\n    }\n  if (GetFileType (h) != FILE_TYPE_DISK)\n    {\n      errno = ESPIPE;\n      return -1;\n    }\n#else\n  /* BeOS lseek mistakenly succeeds on pipes...  */\n  struct stat statbuf;\n  if (fstat (fd, &statbuf) < 0)\n    return -1;\n  if (!S_ISREG (statbuf.st_mode))\n    {\n      errno = ESPIPE;\n      return -1;\n    }\n#endif\n#if _GL_WINDOWS_64_BIT_OFF_T\n  return _lseeki64 (fd, offset, whence);\n#else\n  return lseek (fd, offset, whence);\n#endif\n}",
      "lines": 33,
      "depth": 11,
      "decorators": [
        "off_t"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/macros.h": {},
  "sed/sed-4.5/gnulib-tests/nanosleep.c": {
    "nanosleep": [
      {
        "start_point": [
          100,
          0
        ],
        "end_point": [
          180,
          1
        ],
        "content": "int\nnanosleep (const struct timespec *requested_delay,\n           struct timespec *remaining_delay)\n{\n  static bool initialized;\n  /* Number of performance counter increments per nanosecond,\n     or zero if it could not be determined.  */\n  static double ticks_per_nanosecond;\n\n  if (requested_delay->tv_nsec < 0 || BILLION <= requested_delay->tv_nsec)\n    {\n      errno = EINVAL;\n      return -1;\n    }\n\n  /* For requested delays of one second or more, 15ms resolution is\n     sufficient.  */\n  if (requested_delay->tv_sec == 0)\n    {\n      if (!initialized)\n        {\n          /* Initialize ticks_per_nanosecond.  */\n          LARGE_INTEGER ticks_per_second;\n\n          if (QueryPerformanceFrequency (&ticks_per_second))\n            ticks_per_nanosecond =\n              (double) ticks_per_second.QuadPart / 1000000000.0;\n\n          initialized = true;\n        }\n      if (ticks_per_nanosecond)\n        {\n          /* QueryPerformanceFrequency worked.  We can use\n             QueryPerformanceCounter.  Use a combination of Sleep and\n             busy-looping.  */\n          /* Number of milliseconds to pass to the Sleep function.\n             Since Sleep can take up to 8 ms less or 8 ms more than requested\n             (or maybe more if the system is loaded), we subtract 10 ms.  */\n          int sleep_millis = (int) requested_delay->tv_nsec / 1000000 - 10;\n          /* Determine how many ticks to delay.  */\n          LONGLONG wait_ticks = requested_delay->tv_nsec * ticks_per_nanosecond;\n          /* Start.  */\n          LARGE_INTEGER counter_before;\n          if (QueryPerformanceCounter (&counter_before))\n            {\n              /* Wait until the performance counter has reached this value.\n                 We don't need to worry about overflow, because the performance\n                 counter is reset at reboot, and with a frequency of 3.6E6\n                 ticks per second 63 bits suffice for over 80000 years.  */\n              LONGLONG wait_until = counter_before.QuadPart + wait_ticks;\n              /* Use Sleep for the longest part.  */\n              if (sleep_millis > 0)\n                Sleep (sleep_millis);\n              /* Busy-loop for the rest.  */\n              for (;;)\n                {\n                  LARGE_INTEGER counter_after;\n                  if (!QueryPerformanceCounter (&counter_after))\n                    /* QueryPerformanceCounter failed, but succeeded earlier.\n                       Should not happen.  */\n                    break;\n                  if (counter_after.QuadPart >= wait_until)\n                    /* The requested time has elapsed.  */\n                    break;\n                }\n              goto done;\n            }\n        }\n    }\n  /* Implementation for long delays and as fallback.  */\n  Sleep (requested_delay->tv_sec * 1000 + requested_delay->tv_nsec / 1000000);\n\n done:\n  /* Sleep is not interruptible.  So there is no remaining delay.  */\n  if (remaining_delay != NULL)\n    {\n      remaining_delay->tv_sec = 0;\n      remaining_delay->tv_nsec = 0;\n    }\n  return 0;\n}",
        "lines": 81,
        "depth": 17,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          226,
          0
        ],
        "end_point": [
          274,
          1
        ],
        "content": "int\nnanosleep (const struct timespec *requested_delay,\n           struct timespec *remaining_delay)\n{\n  static bool initialized;\n\n  if (requested_delay->tv_nsec < 0 || BILLION <= requested_delay->tv_nsec)\n    {\n      errno = EINVAL;\n      return -1;\n    }\n\n  /* set up sig handler */\n  if (! initialized)\n    {\n      struct sigaction oldact;\n\n      sigaction (SIGCONT, NULL, &oldact);\n      if (get_handler (&oldact) != SIG_IGN)\n        {\n          struct sigaction newact;\n\n          newact.sa_handler = sighandler;\n          sigemptyset (&newact.sa_mask);\n          newact.sa_flags = 0;\n          sigaction (SIGCONT, &newact, NULL);\n        }\n      initialized = true;\n    }\n\n  suspended = 0;\n\n  if (my_usleep (requested_delay) == -1)\n    {\n      if (suspended)\n        {\n          /* Calculate time remaining.  */\n          /* FIXME: the code in sleep doesn't use this, so there's no\n             rush to implement it.  */\n\n          errno = EINTR;\n        }\n      return -1;\n    }\n\n  /* FIXME: Restore sig handler?  */\n\n  return 0;\n}",
        "lines": 49,
        "depth": 12,
        "decorators": [
          "int"
        ]
      }
    ],
    "sighandler": {
      "start_point": [
        196,
        0
      ],
      "end_point": [
        200,
        1
      ],
      "content": "static void\nsighandler (int sig)\n{\n  suspended = 1;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "my_usleep": {
      "start_point": [
        204,
        0
      ],
      "end_point": [
        221,
        1
      ],
      "content": "static int\nmy_usleep (const struct timespec *ts_delay)\n{\n  struct timeval tv_delay;\n  tv_delay.tv_sec = ts_delay->tv_sec;\n  tv_delay.tv_usec = (ts_delay->tv_nsec + 999) / 1000;\n  if (tv_delay.tv_usec == 1000000)\n    {\n      if (tv_delay.tv_sec == TYPE_MAXIMUM (time_t))\n        tv_delay.tv_usec = 1000000 - 1; /* close enough */\n      else\n        {\n          tv_delay.tv_sec++;\n          tv_delay.tv_usec = 0;\n        }\n    }\n  return select (0, NULL, NULL, NULL, &tv_delay);\n}",
      "lines": 18,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/nap.h": {
    "diff_timespec": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "static int\ndiff_timespec (struct timespec a, struct timespec b)\n{\n  time_t as = a.tv_sec;\n  time_t bs = b.tv_sec;\n  int ans = a.tv_nsec;\n  int bns = b.tv_nsec;\n  int sdiff;\n\n  ASSERT (0 <= ans && ans < 2000000000);\n  ASSERT (0 <= bns && bns < 2000000000);\n\n  if (! (bs < as || (bs == as && bns < ans)))\n    return 0;\n\n  if (INT_SUBTRACT_WRAPV (as, bs, &sdiff)\n      || INT_MULTIPLY_WRAPV (sdiff, 1000000000, &sdiff)\n      || INT_ADD_WRAPV (sdiff, ans - bns, &sdiff))\n    return INT_MAX;\n\n  return sdiff;\n}",
      "lines": 22,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "nap_get_stat": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "static void\nnap_get_stat (struct stat *st, int do_write)\n{\n  if (do_write)\n    {\n      ASSERT (write (nap_fd, \"\\n\", 1) == 1);\n#if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n      /* On native Windows, the modification times are not changed until NAP_FD\n         is closed. See\n         https://msdn.microsoft.com/en-us/library/windows/desktop/aa365747(v=vs.85).aspx */\n      close (nap_fd);\n      nap_fd = open (TEMPFILE, O_RDWR, 0600);\n      ASSERT (nap_fd != -1);\n      lseek (nap_fd, 0, SEEK_END);\n#endif\n    }\n  ASSERT (fstat (nap_fd, st) == 0);\n}",
      "lines": 18,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "nap_works": {
      "start_point": [
        82,
        0
      ],
      "end_point": [
        96,
        1
      ],
      "content": "static bool\nnap_works (int delay, struct stat old_st)\n{\n  struct stat st;\n  struct timespec delay_spec;\n  delay_spec.tv_sec = delay / 1000000000;\n  delay_spec.tv_nsec = delay % 1000000000;\n  ASSERT (nanosleep (&delay_spec, 0) == 0);\n  nap_get_stat (&st, 1);\n\n  if (diff_timespec (get_stat_mtime (&st), get_stat_mtime (&old_st)))\n    return true;\n\n  return false;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "clear_temp_file": {
      "start_point": [
        98,
        0
      ],
      "end_point": [
        106,
        1
      ],
      "content": "static void\nclear_temp_file (void)\n{\n  if (0 <= nap_fd)\n    {\n      ASSERT (close (nap_fd) != -1);\n      ASSERT (unlink (TEMPFILE) != -1);\n    }\n}",
      "lines": 9,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "nap": {
      "start_point": [
        115,
        0
      ],
      "end_point": [
        152,
        1
      ],
      "content": "static void\nnap (void)\n{\n  struct stat old_st;\n  static int delay = 1;\n\n  if (-1 == nap_fd)\n    {\n      atexit (clear_temp_file);\n      ASSERT ((nap_fd = creat (TEMPFILE, 0600)) != -1);\n      nap_get_stat (&old_st, 0);\n    }\n  else\n    {\n      ASSERT (0 <= nap_fd);\n      nap_get_stat (&old_st, 1);\n    }\n\n  if (1 < delay)\n    delay = delay / 2;  /* Try half of the previous delay.  */\n  ASSERT (0 < delay);\n\n  for (;;)\n    {\n      if (nap_works (delay, old_st))\n        return;\n      if (delay <= (2147483647 - 1) / 2)\n        {\n          delay = delay * 2 + 1;\n          continue;\n        }\n      else\n        break;\n    }\n\n  /* Bummer: even the highest nap delay didn't work. */\n  ASSERT (0);\n}",
      "lines": 38,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/netinet_in.in.h": {},
  "sed/sed-4.5/gnulib-tests/null-ptr.h": {
    "null_ptr": {
      "start_point": [
        20,
        0
      ],
      "end_point": [
        29,
        1
      ],
      "content": "static void *\nnull_ptr (void)\n{\n  unsigned int x = rand ();\n  unsigned int y = x * x;\n  if (y & 2)\n    return (void *) -1;\n  else\n    return (void *) 0;\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nnull_ptr (void)",
        "*"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/open.c": {
    "orig_open": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        33,
        1
      ],
      "content": "static int\norig_open (const char *filename, int flags, mode_t mode)\n{\n  return open (filename, flags, mode);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "open": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        207,
        1
      ],
      "content": "int\nopen (const char *filename, int flags, ...)\n{\n  /* 0 = unknown, 1 = yes, -1 = no.  */\n#if GNULIB_defined_O_CLOEXEC\n  int have_cloexec = -1;\n#else\n  static int have_cloexec;\n#endif\n\n  mode_t mode;\n  int fd;\n\n  mode = 0;\n  if (flags & O_CREAT)\n    {\n      va_list arg;\n      va_start (arg, flags);\n\n      /* We have to use PROMOTED_MODE_T instead of mode_t, otherwise GCC 4\n         creates crashing code when 'mode_t' is smaller than 'int'.  */\n      mode = va_arg (arg, PROMOTED_MODE_T);\n\n      va_end (arg);\n    }\n\n#if GNULIB_defined_O_NONBLOCK\n  /* The only known platform that lacks O_NONBLOCK is mingw, but it\n     also lacks named pipes and Unix sockets, which are the only two\n     file types that require non-blocking handling in open().\n     Therefore, it is safe to ignore O_NONBLOCK here.  It is handy\n     that mingw also lacks openat(), so that is also covered here.  */\n  flags &= ~O_NONBLOCK;\n#endif\n\n#if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n  if (strcmp (filename, \"/dev/null\") == 0)\n    filename = \"NUL\";\n#endif\n\n#if OPEN_TRAILING_SLASH_BUG\n  /* If the filename ends in a slash and one of O_CREAT, O_WRONLY, O_RDWR\n     is specified, then fail.\n     Rationale: POSIX <http://www.opengroup.org/susv3/basedefs/xbd_chap04.html>\n     says that\n       \"A pathname that contains at least one non-slash character and that\n        ends with one or more trailing slashes shall be resolved as if a\n        single dot character ( '.' ) were appended to the pathname.\"\n     and\n       \"The special filename dot shall refer to the directory specified by\n        its predecessor.\"\n     If the named file already exists as a directory, then\n       - if O_CREAT is specified, open() must fail because of the semantics\n         of O_CREAT,\n       - if O_WRONLY or O_RDWR is specified, open() must fail because POSIX\n         <http://www.opengroup.org/susv3/functions/open.html> says that it\n         fails with errno = EISDIR in this case.\n     If the named file does not exist or does not name a directory, then\n       - if O_CREAT is specified, open() must fail since open() cannot create\n         directories,\n       - if O_WRONLY or O_RDWR is specified, open() must fail because the\n         file does not contain a '.' directory.  */\n  if (flags & (O_CREAT | O_WRONLY | O_RDWR))\n    {\n      size_t len = strlen (filename);\n      if (len > 0 && filename[len - 1] == '/')\n        {\n          errno = EISDIR;\n          return -1;\n        }\n    }\n#endif\n\n  fd = orig_open (filename,\n                  flags & ~(have_cloexec <= 0 ? O_CLOEXEC : 0), mode);\n\n  if (flags & O_CLOEXEC)\n    {\n      if (! have_cloexec)\n        {\n          if (0 <= fd)\n            have_cloexec = 1;\n          else if (errno == EINVAL)\n            {\n              fd = orig_open (filename, flags & ~O_CLOEXEC, mode);\n              have_cloexec = -1;\n            }\n        }\n      if (have_cloexec < 0 && 0 <= fd)\n        set_cloexec_flag (fd, true);\n    }\n\n\n#if REPLACE_FCHDIR\n  /* Implementing fchdir and fdopendir requires the ability to open a\n     directory file descriptor.  If open doesn't support that (as on\n     mingw), we use a dummy file that behaves the same as directories\n     on Linux (ie. always reports EOF on attempts to read()), and\n     override fstat() in fchdir.c to hide the fact that we have a\n     dummy.  */\n  if (REPLACE_OPEN_DIRECTORY && fd < 0 && errno == EACCES\n      && ((flags & O_ACCMODE) == O_RDONLY\n          || (O_SEARCH != O_RDONLY && (flags & O_ACCMODE) == O_SEARCH)))\n    {\n      struct stat statbuf;\n      if (stat (filename, &statbuf) == 0 && S_ISDIR (statbuf.st_mode))\n        {\n          /* Maximum recursion depth of 1.  */\n          fd = open (\"/dev/null\", flags, mode);\n          if (0 <= fd)\n            fd = _gl_register_fd (fd, filename);\n        }\n      else\n        errno = EACCES;\n    }\n#endif\n\n#if OPEN_TRAILING_SLASH_BUG\n  /* If the filename ends in a slash and fd does not refer to a directory,\n     then fail.\n     Rationale: POSIX <http://www.opengroup.org/susv3/basedefs/xbd_chap04.html>\n     says that\n       \"A pathname that contains at least one non-slash character and that\n        ends with one or more trailing slashes shall be resolved as if a\n        single dot character ( '.' ) were appended to the pathname.\"\n     and\n       \"The special filename dot shall refer to the directory specified by\n        its predecessor.\"\n     If the named file without the slash is not a directory, open() must fail\n     with ENOTDIR.  */\n  if (fd >= 0)\n    {\n      /* We know len is positive, since open did not fail with ENOENT.  */\n      size_t len = strlen (filename);\n      if (filename[len - 1] == '/')\n        {\n          struct stat statbuf;\n\n          if (fstat (fd, &statbuf) >= 0 && !S_ISDIR (statbuf.st_mode))\n            {\n              close (fd);\n              errno = ENOTDIR;\n              return -1;\n            }\n        }\n    }\n#endif\n\n#if REPLACE_FCHDIR\n  if (!REPLACE_OPEN_DIRECTORY && 0 <= fd)\n    fd = _gl_register_fd (fd, filename);\n#endif\n\n  return fd;\n}",
      "lines": 155,
      "depth": 16,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/opendir.c": {
    "opendir": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        168,
        1
      ],
      "content": "DIR *\nopendir (const char *dir_name)\n{\n#if HAVE_OPENDIR\n# undef opendir\n  DIR *dirp;\n\n  dirp = opendir (dir_name);\n  if (dirp == NULL)\n    return NULL;\n\n# ifdef __KLIBC__\n  {\n    int fd = open (dir_name, O_RDONLY);\n    if (fd == -1 || _gl_register_dirp_fd (fd, dirp))\n      {\n        int saved_errno = errno;\n\n        close (fd);\n        closedir (dirp);\n\n        errno = saved_errno;\n\n        return NULL;\n      }\n  }\n# endif\n#else\n\n  char dir_name_mask[MAX_PATH + 1 + 1 + 1];\n  int status;\n  HANDLE current;\n  WIN32_FIND_DATA entry;\n  struct gl_directory *dirp;\n\n  if (dir_name[0] == '\\0')\n    {\n      errno = ENOENT;\n      return NULL;\n    }\n\n  /* Make the dir_name absolute, so that we continue reading the same\n     directory if the current directory changed between this opendir()\n     call and a subsequent rewinddir() call.  */\n  if (!GetFullPathName (dir_name, MAX_PATH, dir_name_mask, NULL))\n    {\n      errno = EINVAL;\n      return NULL;\n    }\n\n  /* Append the mask.\n     \"*\" and \"*.*\" appear to be equivalent.  */\n  {\n    char *p;\n\n    p = dir_name_mask + strlen (dir_name_mask);\n    if (p > dir_name_mask && !ISSLASH (p[-1]))\n      *p++ = '\\\\';\n    *p++ = '*';\n    *p = '\\0';\n  }\n\n  /* Start searching the directory.  */\n  status = -1;\n  current = FindFirstFile (dir_name_mask, &entry);\n  if (current == INVALID_HANDLE_VALUE)\n    {\n      switch (GetLastError ())\n        {\n        case ERROR_FILE_NOT_FOUND:\n          status = -2;\n          break;\n        case ERROR_PATH_NOT_FOUND:\n          errno = ENOENT;\n          return NULL;\n        case ERROR_DIRECTORY:\n          errno = ENOTDIR;\n          return NULL;\n        case ERROR_ACCESS_DENIED:\n          errno = EACCES;\n          return NULL;\n        default:\n          errno = EIO;\n          return NULL;\n        }\n    }\n\n  /* Allocate the result.  */\n  dirp =\n    (struct gl_directory *)\n    malloc (offsetof (struct gl_directory, dir_name_mask[0])\n            + strlen (dir_name_mask) + 1);\n  if (dirp == NULL)\n    {\n      if (current != INVALID_HANDLE_VALUE)\n        FindClose (current);\n      errno = ENOMEM;\n      return NULL;\n    }\n  dirp->status = status;\n  dirp->current = current;\n  if (status == -1)\n    memcpy (&dirp->entry, &entry, sizeof (WIN32_FIND_DATA));\n  strcpy (dirp->dir_name_mask, dir_name_mask);\n\n#endif\n\n#if REPLACE_FCHDIR\n  {\n    int fd = dirfd (dirp);\n    if (0 <= fd && _gl_register_fd (fd, dir_name) != fd)\n      {\n        int saved_errno = errno;\n        closedir (dirp);\n        errno = saved_errno;\n        return NULL;\n      }\n  }\n#endif\n\n  return dirp;\n}",
      "lines": 122,
      "depth": 15,
      "decorators": [
        "DIR",
        "*\nopendir (const char *dir_name)",
        "*"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/perror.c": {
    "perror": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "void\nperror (const char *string)\n{\n  char stackbuf[STACKBUF_LEN];\n  int ret;\n\n  /* Our implementation guarantees that this will be a non-empty\n     string, even if it returns EINVAL; and stackbuf should be sized\n     large enough to avoid ERANGE.  */\n  ret = strerror_r (errno, stackbuf, sizeof stackbuf);\n  if (ret == ERANGE)\n    abort ();\n\n  if (string != NULL && *string != '\\0')\n    fprintf (stderr, \"%s: %s\\n\", string, stackbuf);\n  else\n    fprintf (stderr, \"%s\\n\", stackbuf);\n}",
      "lines": 18,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/pipe.c": {
    "pipe": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "int\npipe (int fd[2])\n{\n  /* Mingw changes fd to {-1,-1} on failure, but this violates\n     http://austingroupbugs.net/view.php?id=467 */\n  int tmp[2];\n  int result = _pipe (tmp, 4096, _O_BINARY);\n  if (!result)\n    {\n      fd[0] = tmp[0];\n      fd[1] = tmp[1];\n    }\n  return result;\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/putenv.c": {
    "_unsetenv": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        112,
        1
      ],
      "content": "static int\n_unsetenv (const char *name)\n{\n  size_t len;\n#if !HAVE_DECL__PUTENV\n  char **ep;\n#endif\n\n  if (name == NULL || *name == '\\0' || strchr (name, '=') != NULL)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  len = strlen (name);\n\n#if HAVE_DECL__PUTENV\n  {\n    int putenv_result, putenv_errno;\n    char *name_ = malloc (len + 2);\n    memcpy (name_, name, len);\n    name_[len] = '=';\n    name_[len + 1] = 0;\n    putenv_result = _putenv (name_);\n    putenv_errno = errno;\n    free (name_);\n    __set_errno (putenv_errno);\n    return putenv_result;\n  }\n#else\n\n  LOCK;\n\n  ep = environ;\n  while (*ep != NULL)\n    if (!strncmp (*ep, name, len) && (*ep)[len] == '=')\n      {\n        /* Found it.  Remove this pointer by moving later ones back.  */\n        char **dp = ep;\n\n        do\n          dp[0] = dp[1];\n        while (*dp++);\n        /* Continue the loop in case NAME appears again.  */\n      }\n    else\n      ++ep;\n\n  UNLOCK;\n\n  return 0;\n#endif\n}",
      "lines": 53,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "putenv": {
      "start_point": [
        117,
        0
      ],
      "end_point": [
        193,
        1
      ],
      "content": "int\nputenv (char *string)\n{\n  const char *name_end = strchr (string, '=');\n  char **ep;\n\n  if (name_end == NULL)\n    {\n      /* Remove the variable from the environment.  */\n      return _unsetenv (string);\n    }\n\n#if HAVE_DECL__PUTENV\n  /* Rely on _putenv to allocate the new environment.  If other\n     parts of the application use _putenv, the !HAVE_DECL__PUTENV code\n     would fight over who owns the environ vector, causing a crash.  */\n  if (name_end[1])\n    return _putenv (string);\n  else\n    {\n      /* _putenv (\"NAME=\") unsets NAME, so invoke _putenv (\"NAME= \")\n         to allocate the environ vector and then replace the new\n         entry with \"NAME=\".  */\n      int putenv_result, putenv_errno;\n      char *name_x = malloc (name_end - string + sizeof \"= \");\n      if (!name_x)\n        return -1;\n      memcpy (name_x, string, name_end - string + 1);\n      name_x[name_end - string + 1] = ' ';\n      name_x[name_end - string + 2] = 0;\n      putenv_result = _putenv (name_x);\n      putenv_errno = errno;\n      for (ep = environ; *ep; ep++)\n        if (strcmp (*ep, name_x) == 0)\n          {\n            *ep = string;\n            break;\n          }\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n      if (putenv_result == 0)\n        {\n          /* _putenv propagated \"NAME= \" into the subprocess environment;\n             fix that by calling SetEnvironmentVariable directly.  */\n          name_x[name_end - string] = 0;\n          putenv_result = SetEnvironmentVariable (name_x, \"\") ? 0 : -1;\n          putenv_errno = ENOMEM; /* ENOMEM is the only way to fail.  */\n        }\n# endif\n      free (name_x);\n      __set_errno (putenv_errno);\n      return putenv_result;\n    }\n#else\n  for (ep = environ; *ep; ep++)\n    if (strncmp (*ep, string, name_end - string) == 0\n        && (*ep)[name_end - string] == '=')\n      break;\n\n  if (*ep)\n    *ep = string;\n  else\n    {\n      static char **last_environ = NULL;\n      size_t size = ep - environ;\n      char **new_environ = malloc ((size + 2) * sizeof *new_environ);\n      if (! new_environ)\n        return -1;\n      new_environ[0] = string;\n      memcpy (new_environ + 1, environ, (size + 1) * sizeof *new_environ);\n      free (last_environ);\n      last_environ = new_environ;\n      environ = new_environ;\n    }\n\n  return 0;\n#endif\n}",
      "lines": 77,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/raise.c": {
    "raise_nothrow": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        44,
        5
      ],
      "content": "static int\nraise_nothrow (int sig)\n{\n  int result;\n\n  TRY_MSVC_INVAL\n    {\n      result = raise (sig);\n    }",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_raise": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        80,
        1
      ],
      "content": "int\nrpl_raise (int sig)\n{\n#if GNULIB_defined_signal_blocking && GNULIB_defined_SIGPIPE\n  if (sig == SIGPIPE)\n    return _gl_raise_SIGPIPE ();\n#endif\n\n#if HAVE_RAISE\n  return raise_nothrow (sig);\n#else\n  return kill (getpid (), sig);\n#endif\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/read-file.c": {
    "fread_file": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        134,
        1
      ],
      "content": "char *\nfread_file (FILE *stream, size_t *length)\n{\n  char *buf = NULL;\n  size_t alloc = BUFSIZ;\n\n  /* For a regular file, allocate a buffer that has exactly the right\n     size.  This avoids the need to do dynamic reallocations later.  */\n  {\n    struct stat st;\n\n    if (fstat (fileno (stream), &st) >= 0 && S_ISREG (st.st_mode))\n      {\n        off_t pos = ftello (stream);\n\n        if (pos >= 0 && pos < st.st_size)\n          {\n            off_t alloc_off = st.st_size - pos;\n\n            /* '1' below, accounts for the trailing NUL.  */\n            if (SIZE_MAX - 1 < alloc_off)\n              {\n                errno = ENOMEM;\n                return NULL;\n              }\n\n            alloc = alloc_off + 1;\n          }\n      }\n  }\n\n  if (!(buf = malloc (alloc)))\n    return NULL; /* errno is ENOMEM.  */\n\n  {\n    size_t size = 0; /* number of bytes read so far */\n    int save_errno;\n\n    for (;;)\n      {\n        /* This reads 1 more than the size of a regular file\n           so that we get eof immediately.  */\n        size_t requested = alloc - size;\n        size_t count = fread (buf + size, 1, requested, stream);\n        size += count;\n\n        if (count != requested)\n          {\n            save_errno = errno;\n            if (ferror (stream))\n              break;\n\n            /* Shrink the allocated memory if possible.  */\n            if (size < alloc - 1)\n              {\n                char *smaller_buf = realloc (buf, size + 1);\n                if (smaller_buf != NULL)\n                  buf = smaller_buf;\n              }\n\n            buf[size] = '\\0';\n            *length = size;\n            return buf;\n          }\n\n        {\n          char *new_buf;\n\n          if (alloc == SIZE_MAX)\n            {\n              save_errno = ENOMEM;\n              break;\n            }\n\n          if (alloc < SIZE_MAX - alloc / 2)\n            alloc = alloc + alloc / 2;\n          else\n            alloc = SIZE_MAX;\n\n          if (!(new_buf = realloc (buf, alloc)))\n            {\n              save_errno = errno;\n              break;\n            }\n\n          buf = new_buf;\n        }\n      }\n\n    free (buf);\n    errno = save_errno;\n    return NULL;\n  }\n}",
      "lines": 94,
      "depth": 15,
      "decorators": [
        "char",
        "*\nfread_file (FILE *stream, size_t *length)",
        "*"
      ]
    },
    "internal_read_file": {
      "start_point": [
        136,
        0
      ],
      "end_point": [
        162,
        1
      ],
      "content": "static char *\ninternal_read_file (const char *filename, size_t *length, const char *mode)\n{\n  FILE *stream = fopen (filename, mode);\n  char *out;\n  int save_errno;\n\n  if (!stream)\n    return NULL;\n\n  out = fread_file (stream, length);\n\n  save_errno = errno;\n\n  if (fclose (stream) != 0)\n    {\n      if (out)\n        {\n          save_errno = errno;\n          free (out);\n        }\n      errno = save_errno;\n      return NULL;\n    }\n\n  return out;\n}",
      "lines": 27,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "char",
        "*\ninternal_read_file (const char *filename, size_t *length, const char *mode)",
        "*"
      ]
    },
    "read_file": {
      "start_point": [
        170,
        0
      ],
      "end_point": [
        174,
        1
      ],
      "content": "char *\nread_file (const char *filename, size_t *length)\n{\n  return internal_read_file (filename, length, \"r\");\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nread_file (const char *filename, size_t *length)",
        "*"
      ]
    },
    "read_binary_file": {
      "start_point": [
        183,
        0
      ],
      "end_point": [
        187,
        1
      ],
      "content": "char *\nread_binary_file (const char *filename, size_t *length)\n{\n  return internal_read_file (filename, length, \"rb\");\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nread_binary_file (const char *filename, size_t *length)",
        "*"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/read-file.h": {},
  "sed/sed-4.5/gnulib-tests/readdir.c": {
    "readdir": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        97,
        1
      ],
      "content": "struct dirent *\nreaddir (DIR *dirp)\n{\n  char type;\n  struct dirent *result;\n\n  /* There is no need to add code to produce entries for \".\" and \"..\".\n     According to the POSIX:2008 section \"4.12 Pathname Resolution\"\n     <http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html>\n     \".\" and \"..\" are syntactic entities.\n     POSIX also says:\n       \"If entries for dot or dot-dot exist, one entry shall be returned\n        for dot and one entry shall be returned for dot-dot; otherwise,\n        they shall not be returned.\"  */\n\n  switch (dirp->status)\n    {\n    case -2:\n      /* End of directory already reached.  */\n      return NULL;\n    case -1:\n      break;\n    case 0:\n      if (!FindNextFile (dirp->current, &dirp->entry))\n        {\n          switch (GetLastError ())\n            {\n            case ERROR_NO_MORE_FILES:\n              dirp->status = -2;\n              return NULL;\n            default:\n              errno = EIO;\n              return NULL;\n            }\n        }\n      break;\n    default:\n      errno = dirp->status;\n      return NULL;\n    }\n\n  dirp->status = 0;\n\n  if (dirp->entry.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)\n    type = DT_DIR;\n  else if (dirp->entry.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT)\n    type = DT_LNK;\n  else if ((dirp->entry.dwFileAttributes\n            & ~(FILE_ATTRIBUTE_READONLY\n                | FILE_ATTRIBUTE_HIDDEN\n                | FILE_ATTRIBUTE_SYSTEM\n                | FILE_ATTRIBUTE_ARCHIVE\n                | FILE_ATTRIBUTE_NORMAL\n                | FILE_ATTRIBUTE_TEMPORARY\n                | FILE_ATTRIBUTE_SPARSE_FILE\n                | FILE_ATTRIBUTE_COMPRESSED\n                | FILE_ATTRIBUTE_NOT_CONTENT_INDEXED\n                | FILE_ATTRIBUTE_ENCRYPTED)) == 0)\n    /* Devices like COM1, LPT1, NUL would also have the attributes 0x20 but\n       they cannot occur here.  */\n    type = DT_REG;\n  else\n    type = DT_UNKNOWN;\n\n  /* Reuse the memory of dirp->entry for the result.  */\n  result =\n    (struct dirent *)\n    ((char *) dirp->entry.cFileName - offsetof (struct dirent, d_name[0]));\n  result->d_type = type;\n\n  return result;\n}",
      "lines": 72,
      "depth": 21,
      "decorators": [
        "struct dirent",
        "struct",
        "dirent",
        "*\nreaddir (DIR *dirp)",
        "*"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/realloc.c": {
    "rpl_realloc": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "void *\nrpl_realloc (void *p, size_t n)\n{\n  void *result;\n\n#if NEED_REALLOC_GNU\n  if (n == 0)\n    {\n      n = 1;\n\n      /* In theory realloc might fail, so don't rely on it to free.  */\n      free (p);\n      p = NULL;\n    }\n#endif\n\n  if (p == NULL)\n    {\n#if GNULIB_REALLOC_GNU && !NEED_REALLOC_GNU && !SYSTEM_MALLOC_GLIBC_COMPATIBLE\n      if (n == 0)\n        n = 1;\n#endif\n      result = malloc (n);\n    }\n  else\n    result = realloc (p, n);\n\n#if !HAVE_REALLOC_POSIX\n  if (result == NULL)\n    errno = ENOMEM;\n#endif\n\n  return result;\n}",
      "lines": 34,
      "depth": 9,
      "decorators": [
        "void",
        "*\nrpl_realloc (void *p, size_t n)",
        "*"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/select.c": {
    "IsConsoleHandle": {
      "start_point": [
        88,
        0
      ],
      "end_point": [
        92,
        1
      ],
      "content": "static BOOL IsConsoleHandle (HANDLE h)\n{\n  DWORD mode;\n  return GetConsoleMode (h, &mode) != 0;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "BOOL"
      ]
    },
    "IsSocketHandle": {
      "start_point": [
        94,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "static BOOL\nIsSocketHandle (HANDLE h)\n{\n  WSANETWORKEVENTS ev;\n\n  if (IsConsoleHandle (h))\n    return FALSE;\n\n  /* Under Wine, it seems that getsockopt returns 0 for pipes too.\n     WSAEnumNetworkEvents instead distinguishes the two correctly.  */\n  ev.lNetworkEvents = 0xDEADBEEF;\n  WSAEnumNetworkEvents ((SOCKET) h, NULL, &ev);\n  return ev.lNetworkEvents != 0xDEADBEEF;\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "BOOL"
      ]
    },
    "windows_poll_handle": {
      "start_point": [
        112,
        0
      ],
      "end_point": [
        244,
        1
      ],
      "content": "static int\nwindows_poll_handle (HANDLE h, int fd,\n                     struct bitset *rbits,\n                     struct bitset *wbits,\n                     struct bitset *xbits)\n{\n  BOOL read, write, except;\n  int i, ret;\n  INPUT_RECORD *irbuffer;\n  DWORD avail, nbuffer;\n  BOOL bRet;\n  IO_STATUS_BLOCK iosb;\n  FILE_PIPE_LOCAL_INFORMATION fpli;\n  static PNtQueryInformationFile NtQueryInformationFile;\n  static BOOL once_only;\n\n  read = write = except = FALSE;\n  switch (GetFileType (h))\n    {\n    case FILE_TYPE_DISK:\n      read = TRUE;\n      write = TRUE;\n      break;\n\n    case FILE_TYPE_PIPE:\n      if (!once_only)\n        {\n          NtQueryInformationFile = (PNtQueryInformationFile)\n            GetProcAddress (GetModuleHandle (\"ntdll.dll\"),\n                            \"NtQueryInformationFile\");\n          once_only = TRUE;\n        }\n\n      if (PeekNamedPipe (h, NULL, 0, NULL, &avail, NULL) != 0)\n        {\n          if (avail)\n            read = TRUE;\n        }\n      else if (GetLastError () == ERROR_BROKEN_PIPE)\n        ;\n\n      else\n        {\n          /* It was the write-end of the pipe.  Check if it is writable.\n             If NtQueryInformationFile fails, optimistically assume the pipe is\n             writable.  This could happen on Windows 9x, where\n             NtQueryInformationFile is not available, or if we inherit a pipe\n             that doesn't permit FILE_READ_ATTRIBUTES access on the write end\n             (I think this should not happen since Windows XP SP2; WINE seems\n             fine too).  Otherwise, ensure that enough space is available for\n             atomic writes.  */\n          memset (&iosb, 0, sizeof (iosb));\n          memset (&fpli, 0, sizeof (fpli));\n\n          if (!NtQueryInformationFile\n              || NtQueryInformationFile (h, &iosb, &fpli, sizeof (fpli),\n                                         FilePipeLocalInformation)\n              || fpli.WriteQuotaAvailable >= PIPE_BUF\n              || (fpli.OutboundQuota < PIPE_BUF &&\n                  fpli.WriteQuotaAvailable == fpli.OutboundQuota))\n            write = TRUE;\n        }\n      break;\n\n    case FILE_TYPE_CHAR:\n      write = TRUE;\n      if (!(rbits->in[fd / CHAR_BIT] & (1 << (fd & (CHAR_BIT - 1)))))\n        break;\n\n      ret = WaitForSingleObject (h, 0);\n      if (ret == WAIT_OBJECT_0)\n        {\n          if (!IsConsoleHandle (h))\n            {\n              read = TRUE;\n              break;\n            }\n\n          nbuffer = avail = 0;\n          bRet = GetNumberOfConsoleInputEvents (h, &nbuffer);\n\n          /* Screen buffers handles are filtered earlier.  */\n          assert (bRet);\n          if (nbuffer == 0)\n            {\n              except = TRUE;\n              break;\n            }\n\n          irbuffer = (INPUT_RECORD *) alloca (nbuffer * sizeof (INPUT_RECORD));\n          bRet = PeekConsoleInput (h, irbuffer, nbuffer, &avail);\n          if (!bRet || avail == 0)\n            {\n              except = TRUE;\n              break;\n            }\n\n          for (i = 0; i < avail; i++)\n            if (irbuffer[i].EventType == KEY_EVENT)\n              read = TRUE;\n        }\n      break;\n\n    default:\n      ret = WaitForSingleObject (h, 0);\n      write = TRUE;\n      if (ret == WAIT_OBJECT_0)\n        read = TRUE;\n\n      break;\n    }\n\n  ret = 0;\n  if (read && (rbits->in[fd / CHAR_BIT] & (1 << (fd & (CHAR_BIT - 1)))))\n    {\n      rbits->out[fd / CHAR_BIT] |= (1 << (fd & (CHAR_BIT - 1)));\n      ret++;\n    }\n\n  if (write && (wbits->in[fd / CHAR_BIT] & (1 << (fd & (CHAR_BIT - 1)))))\n    {\n      wbits->out[fd / CHAR_BIT] |= (1 << (fd & (CHAR_BIT - 1)));\n      ret++;\n    }\n\n  if (except && (xbits->in[fd / CHAR_BIT] & (1 << (fd & (CHAR_BIT - 1)))))\n    {\n      xbits->out[fd / CHAR_BIT] |= (1 << (fd & (CHAR_BIT - 1)));\n      ret++;\n    }\n\n  return ret;\n}",
      "lines": 133,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_select": {
      "start_point": [
        546,
        0
      ],
      "end_point": [
        576,
        1
      ],
      "content": "int\nrpl_select (int nfds, fd_set *rfds, fd_set *wfds, fd_set *xfds,\n            struct timeval *timeout)\n{\n  int i;\n\n  /* FreeBSD 8.2 has a bug: it does not always detect invalid fds.  */\n  if (nfds < 0 || nfds > FD_SETSIZE)\n    {\n      errno = EINVAL;\n      return -1;\n    }\n  for (i = 0; i < nfds; i++)\n    {\n      if (((rfds && FD_ISSET (i, rfds))\n           || (wfds && FD_ISSET (i, wfds))\n           || (xfds && FD_ISSET (i, xfds)))\n          && dup2 (i, i) != i)\n        return -1;\n    }\n\n  /* Interix 3.5 has a bug: it does not support nfds == 0.  */\n  if (nfds == 0)\n    {\n      nfds = 1;\n      rfds = NULL;\n      wfds = NULL;\n      xfds = NULL;\n    }\n  return select (nfds, rfds, wfds, xfds, timeout);\n}",
      "lines": 31,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/setenv.c": {
    "__add_to_environ": {
      "start_point": [
        111,
        0
      ],
      "end_point": [
        287,
        1
      ],
      "content": "int\n__add_to_environ (const char *name, const char *value, const char *combined,\n                  int replace)\n{\n  char **ep;\n  size_t size;\n  const size_t namelen = strlen (name);\n  const size_t vallen = value != NULL ? strlen (value) + 1 : 0;\n\n  LOCK;\n\n  /* We have to get the pointer now that we have the lock and not earlier\n     since another thread might have created a new environment.  */\n  ep = __environ;\n\n  size = 0;\n  if (ep != NULL)\n    {\n      for (; *ep != NULL; ++ep)\n        if (!strncmp (*ep, name, namelen) && (*ep)[namelen] == '=')\n          break;\n        else\n          ++size;\n    }\n\n  if (ep == NULL || *ep == NULL)\n    {\n      char **new_environ;\n#ifdef USE_TSEARCH\n      char *new_value;\n#endif\n\n      /* We allocated this space; we can extend it.  */\n      new_environ =\n        (char **) (last_environ == NULL\n                   ? malloc ((size + 2) * sizeof (char *))\n                   : realloc (last_environ, (size + 2) * sizeof (char *)));\n      if (new_environ == NULL)\n        {\n          /* It's easier to set errno to ENOMEM than to rely on the\n             'malloc-posix' and 'realloc-posix' gnulib modules.  */\n          __set_errno (ENOMEM);\n          UNLOCK;\n          return -1;\n        }\n\n      /* If the whole entry is given add it.  */\n      if (combined != NULL)\n        /* We must not add the string to the search tree since it belongs\n           to the user.  */\n        new_environ[size] = (char *) combined;\n      else\n        {\n          /* See whether the value is already known.  */\n#ifdef USE_TSEARCH\n# ifdef _LIBC\n          new_value = (char *) alloca (namelen + 1 + vallen);\n          __mempcpy (__mempcpy (__mempcpy (new_value, name, namelen), \"=\", 1),\n                     value, vallen);\n# else\n          new_value = (char *) malloca (namelen + 1 + vallen);\n          if (new_value == NULL)\n            {\n              __set_errno (ENOMEM);\n              UNLOCK;\n              return -1;\n            }\n          memcpy (new_value, name, namelen);\n          new_value[namelen] = '=';\n          memcpy (&new_value[namelen + 1], value, vallen);\n# endif\n\n          new_environ[size] = KNOWN_VALUE (new_value);\n          if (new_environ[size] == NULL)\n#endif\n            {\n              new_environ[size] = (char *) malloc (namelen + 1 + vallen);\n              if (new_environ[size] == NULL)\n                {\n#if defined USE_TSEARCH && !defined _LIBC\n                  freea (new_value);\n#endif\n                  __set_errno (ENOMEM);\n                  UNLOCK;\n                  return -1;\n                }\n\n#ifdef USE_TSEARCH\n              memcpy (new_environ[size], new_value, namelen + 1 + vallen);\n#else\n              memcpy (new_environ[size], name, namelen);\n              new_environ[size][namelen] = '=';\n              memcpy (&new_environ[size][namelen + 1], value, vallen);\n#endif\n              /* And save the value now.  We cannot do this when we remove\n                 the string since then we cannot decide whether it is a\n                 user string or not.  */\n              STORE_VALUE (new_environ[size]);\n            }\n#if defined USE_TSEARCH && !defined _LIBC\n          freea (new_value);\n#endif\n        }\n\n      if (__environ != last_environ)\n        memcpy ((char *) new_environ, (char *) __environ,\n                size * sizeof (char *));\n\n      new_environ[size + 1] = NULL;\n\n      last_environ = __environ = new_environ;\n    }\n  else if (replace)\n    {\n      char *np;\n\n      /* Use the user string if given.  */\n      if (combined != NULL)\n        np = (char *) combined;\n      else\n        {\n#ifdef USE_TSEARCH\n          char *new_value;\n# ifdef _LIBC\n          new_value = alloca (namelen + 1 + vallen);\n          __mempcpy (__mempcpy (__mempcpy (new_value, name, namelen), \"=\", 1),\n                     value, vallen);\n# else\n          new_value = malloca (namelen + 1 + vallen);\n          if (new_value == NULL)\n            {\n              __set_errno (ENOMEM);\n              UNLOCK;\n              return -1;\n            }\n          memcpy (new_value, name, namelen);\n          new_value[namelen] = '=';\n          memcpy (&new_value[namelen + 1], value, vallen);\n# endif\n\n          np = KNOWN_VALUE (new_value);\n          if (np == NULL)\n#endif\n            {\n              np = (char *) malloc (namelen + 1 + vallen);\n              if (np == NULL)\n                {\n#if defined USE_TSEARCH && !defined _LIBC\n                  freea (new_value);\n#endif\n                  __set_errno (ENOMEM);\n                  UNLOCK;\n                  return -1;\n                }\n\n#ifdef USE_TSEARCH\n              memcpy (np, new_value, namelen + 1 + vallen);\n#else\n              memcpy (np, name, namelen);\n              np[namelen] = '=';\n              memcpy (&np[namelen + 1], value, vallen);\n#endif\n              /* And remember the value.  */\n              STORE_VALUE (np);\n            }\n#if defined USE_TSEARCH && !defined _LIBC\n          freea (new_value);\n#endif\n        }\n\n      *ep = np;\n    }\n\n  UNLOCK;\n\n  return 0;\n}",
      "lines": 177,
      "depth": 17,
      "decorators": [
        "int"
      ]
    },
    "setenv": {
      "start_point": [
        289,
        0
      ],
      "end_point": [
        299,
        1
      ],
      "content": "int\nsetenv (const char *name, const char *value, int replace)\n{\n  if (name == NULL || *name == '\\0' || strchr (name, '=') != NULL)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  return __add_to_environ (name, value, NULL, replace);\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "clearenv": {
      "start_point": [
        304,
        0
      ],
      "end_point": [
        322,
        1
      ],
      "content": "int\nclearenv (void)\n{\n  LOCK;\n\n  if (__environ == last_environ && __environ != NULL)\n    {\n      /* We allocated this environment so we can free it.  */\n      free (__environ);\n      last_environ = NULL;\n    }\n\n  /* Clear the environment pointer removes the whole environment.  */\n  __environ = NULL;\n\n  UNLOCK;\n\n  return 0;\n}",
      "lines": 19,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "free_mem": {
      "start_point": [
        325,
        0
      ],
      "end_point": [
        334,
        1
      ],
      "content": "static void\nfree_mem (void)\n{\n  /* Remove all traces.  */\n  clearenv ();\n\n  /* Now remove the search tree.  */\n  __tdestroy (known_values, free);\n  known_values = NULL;\n}",
      "lines": 10,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "rpl_setenv": {
      "start_point": [
        357,
        0
      ],
      "end_point": [
        387,
        1
      ],
      "content": "int\nrpl_setenv (const char *name, const char *value, int replace)\n{\n  int result;\n  if (!name || !*name || strchr (name, '='))\n    {\n      errno = EINVAL;\n      return -1;\n    }\n  /* Call the real setenv even if replace is 0, in case implementation\n     has underlying data to update, such as when environ changes.  */\n  result = setenv (name, value, replace);\n  if (result == 0 && replace && *value == '=')\n    {\n      char *tmp = getenv (name);\n      if (!STREQ (tmp, value))\n        {\n          int saved_errno;\n          size_t len = strlen (value);\n          tmp = malloca (len + 2);\n          /* Since leading '=' is eaten, double it up.  */\n          *tmp = '=';\n          memcpy (tmp + 1, value, len + 1);\n          result = setenv (name, tmp, replace);\n          saved_errno = errno;\n          freea (tmp);\n          errno = saved_errno;\n        }\n    }\n  return result;\n}",
      "lines": 31,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/setlocale.c": {
    "category_to_name": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "static const char *\ncategory_to_name (int category)\n{\n  const char *retval;\n\n  switch (category)\n  {\n  case LC_COLLATE:\n    retval = \"LC_COLLATE\";\n    break;\n  case LC_CTYPE:\n    retval = \"LC_CTYPE\";\n    break;\n  case LC_MONETARY:\n    retval = \"LC_MONETARY\";\n    break;\n  case LC_NUMERIC:\n    retval = \"LC_NUMERIC\";\n    break;\n  case LC_TIME:\n    retval = \"LC_TIME\";\n    break;\n  case LC_MESSAGES:\n    retval = \"LC_MESSAGES\";\n    break;\n  default:\n    /* If you have a better idea for a default value let me know.  */\n    retval = \"LC_XXX\";\n  }\n\n  return retval;\n}",
      "lines": 32,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\ncategory_to_name (int category)",
        "*"
      ]
    },
    "search": {
      "start_point": [
        567,
        0
      ],
      "end_point": [
        623,
        1
      ],
      "content": "static void\nsearch (const struct table_entry *table, size_t table_size, const char *string,\n        range_t *result)\n{\n  /* The table is sorted.  Perform a binary search.  */\n  size_t hi = table_size;\n  size_t lo = 0;\n  while (lo < hi)\n    {\n      /* Invariant:\n         for i < lo, strcmp (table[i].code, string) < 0,\n         for i >= hi, strcmp (table[i].code, string) > 0.  */\n      size_t mid = (hi + lo) >> 1; /* >= lo, < hi */\n      int cmp = strcmp (table[mid].code, string);\n      if (cmp < 0)\n        lo = mid + 1;\n      else if (cmp > 0)\n        hi = mid;\n      else\n        {\n          /* Found an i with\n               strcmp (language_table[i].code, string) == 0.\n             Find the entire interval of such i.  */\n          {\n            size_t i;\n\n            for (i = mid; i > lo; )\n              {\n                i--;\n                if (strcmp (table[i].code, string) < 0)\n                  {\n                    lo = i + 1;\n                    break;\n                  }\n              }\n          }\n          {\n            size_t i;\n\n            for (i = mid; i < hi; i++)\n              {\n                if (strcmp (table[i].code, string) > 0)\n                  {\n                    hi = i;\n                    break;\n                  }\n              }\n          }\n          /* The set of i with\n               strcmp (language_table[i].code, string) == 0\n             is the interval [lo, hi-1].  */\n          break;\n        }\n    }\n  result->lo = lo;\n  result->hi = hi;\n}",
      "lines": 57,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "setlocale_unixlike": {
      "start_point": [
        627,
        0
      ],
      "end_point": [
        783,
        1
      ],
      "content": "static char *\nsetlocale_unixlike (int category, const char *locale)\n{\n  char *result;\n  char llCC_buf[64];\n  char ll_buf[64];\n  char CC_buf[64];\n\n  /* The native Windows implementation of setlocale understands the special\n     locale name \"C\", but not \"POSIX\".  Therefore map \"POSIX\" to \"C\".  */\n#if (defined _WIN32 || defined __WIN32__) && !defined __CYGWIN__\n  if (locale != NULL && strcmp (locale, \"POSIX\") == 0)\n    locale = \"C\";\n#endif\n\n  /* First, try setlocale with the original argument unchanged.  */\n  result = setlocale (category, locale);\n  if (result != NULL)\n    return result;\n\n  /* Otherwise, assume the argument is in the form\n       language[_territory][.codeset][@modifier]\n     and try to map it using the tables.  */\n  if (strlen (locale) < sizeof (llCC_buf))\n    {\n      /* Second try: Remove the codeset part.  */\n      {\n        const char *p = locale;\n        char *q = llCC_buf;\n\n        /* Copy the part before the dot.  */\n        for (; *p != '\\0' && *p != '.'; p++, q++)\n          *q = *p;\n        if (*p == '.')\n          /* Skip the part up to the '@', if any.  */\n          for (; *p != '\\0' && *p != '@'; p++)\n            ;\n        /* Copy the part starting with '@', if any.  */\n        for (; *p != '\\0'; p++, q++)\n          *q = *p;\n        *q = '\\0';\n      }\n      /* llCC_buf now contains\n           language[_territory][@modifier]\n       */\n      if (strcmp (llCC_buf, locale) != 0)\n        {\n          result = setlocale (category, llCC_buf);\n          if (result != NULL)\n            return result;\n        }\n      /* Look it up in language_table.  */\n      {\n        range_t range;\n        size_t i;\n\n        search (language_table,\n                sizeof (language_table) / sizeof (language_table[0]),\n                llCC_buf,\n                &range);\n\n        for (i = range.lo; i < range.hi; i++)\n          {\n            /* Try the replacement in language_table[i].  */\n            result = setlocale (category, language_table[i].english);\n            if (result != NULL)\n              return result;\n          }\n      }\n      /* Split language[_territory][@modifier]\n         into  ll_buf = language[@modifier]\n         and   CC_buf = territory\n       */\n      {\n        const char *underscore = strchr (llCC_buf, '_');\n        if (underscore != NULL)\n          {\n            const char *territory_start = underscore + 1;\n            const char *territory_end = strchr (territory_start, '@');\n            if (territory_end == NULL)\n              territory_end = territory_start + strlen (territory_start);\n\n            memcpy (ll_buf, llCC_buf, underscore - llCC_buf);\n            strcpy (ll_buf + (underscore - llCC_buf), territory_end);\n\n            memcpy (CC_buf, territory_start, territory_end - territory_start);\n            CC_buf[territory_end - territory_start] = '\\0';\n\n            {\n              /* Look up ll_buf in language_table\n                 and CC_buf in country_table.  */\n              range_t language_range;\n\n              search (language_table,\n                      sizeof (language_table) / sizeof (language_table[0]),\n                      ll_buf,\n                      &language_range);\n              if (language_range.lo < language_range.hi)\n                {\n                  range_t country_range;\n\n                  search (country_table,\n                          sizeof (country_table) / sizeof (country_table[0]),\n                          CC_buf,\n                          &country_range);\n                  if (country_range.lo < country_range.hi)\n                    {\n                      size_t i;\n                      size_t j;\n\n                      for (i = language_range.lo; i < language_range.hi; i++)\n                        for (j = country_range.lo; j < country_range.hi; j++)\n                          {\n                            /* Concatenate the replacements.  */\n                            const char *part1 = language_table[i].english;\n                            size_t part1_len = strlen (part1);\n                            const char *part2 = country_table[j].english;\n                            size_t part2_len = strlen (part2) + 1;\n                            char buf[64+64];\n\n                            if (!(part1_len + 1 + part2_len <= sizeof (buf)))\n                              abort ();\n                            memcpy (buf, part1, part1_len);\n                            buf[part1_len] = '_';\n                            memcpy (buf + part1_len + 1, part2, part2_len);\n\n                            /* Try the concatenated replacements.  */\n                            result = setlocale (category, buf);\n                            if (result != NULL)\n                              return result;\n                          }\n                    }\n\n                  /* Try omitting the country entirely.  This may set a locale\n                     corresponding to the wrong country, but is better than\n                     failing entirely.  */\n                  {\n                    size_t i;\n\n                    for (i = language_range.lo; i < language_range.hi; i++)\n                      {\n                        /* Try only the language replacement.  */\n                        result =\n                          setlocale (category, language_table[i].english);\n                        if (result != NULL)\n                          return result;\n                      }\n                  }\n                }\n            }\n          }\n      }\n    }\n\n  /* Failed.  */\n  return NULL;\n}",
      "lines": 157,
      "depth": 23,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nsetlocale_unixlike (int category, const char *locale)",
        "*"
      ]
    },
    "setlocale_single": {
      "start_point": [
        795,
        0
      ],
      "end_point": [
        809,
        1
      ],
      "content": "static char *\nsetlocale_single (int category, const char *locale)\n{\n  if (category == LC_MESSAGES)\n    {\n      if (locale != NULL)\n        {\n          lc_messages_name[sizeof (lc_messages_name) - 1] = '\\0';\n          strncpy (lc_messages_name, locale, sizeof (lc_messages_name) - 1);\n        }\n      return lc_messages_name;\n    }\n  else\n    return setlocale_unixlike (category, locale);\n}",
      "lines": 15,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nsetlocale_single (int category, const char *locale)",
        "*"
      ]
    },
    "rpl_setlocale": {
      "start_point": [
        815,
        0
      ],
      "end_point": [
        943,
        1
      ],
      "content": "char *\nrpl_setlocale (int category, const char *locale)\n{\n  if (locale != NULL && locale[0] == '\\0')\n    {\n      /* A request to the set the current locale to the default locale.  */\n      if (category == LC_ALL)\n        {\n          /* Set LC_CTYPE first.  Then the other categories.  */\n          static int const categories[] =\n            {\n              LC_NUMERIC,\n              LC_TIME,\n              LC_COLLATE,\n              LC_MONETARY,\n              LC_MESSAGES\n            };\n          char *saved_locale;\n          const char *base_name;\n          unsigned int i;\n\n          /* Back up the old locale, in case one of the steps fails.  */\n          saved_locale = setlocale (LC_ALL, NULL);\n          if (saved_locale == NULL)\n            return NULL;\n          saved_locale = strdup (saved_locale);\n          if (saved_locale == NULL)\n            return NULL;\n\n          /* Set LC_CTYPE category.  Set all other categories (except possibly\n             LC_MESSAGES) to the same value in the same call; this is likely to\n             save calls.  */\n          base_name =\n            gl_locale_name_environ (LC_CTYPE, category_to_name (LC_CTYPE));\n          if (base_name == NULL)\n            base_name = gl_locale_name_default ();\n\n          if (setlocale_unixlike (LC_ALL, base_name) == NULL)\n            goto fail;\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n          /* On native Windows, setlocale(LC_ALL,...) may succeed but set the\n             LC_CTYPE category to an invalid value (\"C\") when it does not\n             support the specified encoding.  Report a failure instead.  */\n          if (strchr (base_name, '.') != NULL\n              && strcmp (setlocale (LC_CTYPE, NULL), \"C\") == 0)\n            goto fail;\n# endif\n\n          for (i = 0; i < sizeof (categories) / sizeof (categories[0]); i++)\n            {\n              int cat = categories[i];\n              const char *name;\n\n              name = gl_locale_name_environ (cat, category_to_name (cat));\n              if (name == NULL)\n                name = gl_locale_name_default ();\n\n              /* If name is the same as base_name, it has already been set\n                 through the setlocale call before the loop.  */\n              if (strcmp (name, base_name) != 0\n# if LC_MESSAGES == 1729\n                  || cat == LC_MESSAGES\n# endif\n                 )\n                if (setlocale_single (cat, name) == NULL)\n                  goto fail;\n            }\n\n          /* All steps were successful.  */\n          free (saved_locale);\n          return setlocale (LC_ALL, NULL);\n\n        fail:\n          if (saved_locale[0] != '\\0') /* don't risk an endless recursion */\n            setlocale (LC_ALL, saved_locale);\n          free (saved_locale);\n          return NULL;\n        }\n      else\n        {\n          const char *name =\n            gl_locale_name_environ (category, category_to_name (category));\n          if (name == NULL)\n            name = gl_locale_name_default ();\n\n          return setlocale_single (category, name);\n        }\n    }\n  else\n    {\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n      if (category == LC_ALL && locale != NULL && strchr (locale, '.') != NULL)\n        {\n          char *saved_locale;\n\n          /* Back up the old locale.  */\n          saved_locale = setlocale (LC_ALL, NULL);\n          if (saved_locale == NULL)\n            return NULL;\n          saved_locale = strdup (saved_locale);\n          if (saved_locale == NULL)\n            return NULL;\n\n          if (setlocale_unixlike (LC_ALL, locale) == NULL)\n            {\n              free (saved_locale);\n              return NULL;\n            }\n\n          /* On native Windows, setlocale(LC_ALL,...) may succeed but set the\n             LC_CTYPE category to an invalid value (\"C\") when it does not\n             support the specified encoding.  Report a failure instead.  */\n          if (strcmp (setlocale (LC_CTYPE, NULL), \"C\") == 0)\n            {\n              if (saved_locale[0] != '\\0') /* don't risk an endless recursion */\n                setlocale (LC_ALL, saved_locale);\n              free (saved_locale);\n              return NULL;\n            }\n\n          /* It was really successful.  */\n          free (saved_locale);\n          return setlocale (LC_ALL, NULL);\n        }\n      else\n# endif\n        return setlocale_single (category, locale);\n    }\n}",
      "lines": 129,
      "depth": 16,
      "decorators": [
        "char",
        "*\nrpl_setlocale (int category, const char *locale)",
        "*"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/setsockopt.c": {
    "rpl_setsockopt": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "int\nrpl_setsockopt (int fd, int level, int optname, const void *optval, socklen_t optlen)\n{\n  SOCKET sock = FD_TO_SOCKET (fd);\n  int r;\n\n  if (sock == INVALID_SOCKET)\n    {\n      errno = EBADF;\n      return -1;\n    }\n  else\n    {\n      if (level == SOL_SOCKET\n          && (optname == SO_RCVTIMEO || optname == SO_SNDTIMEO))\n        {\n          const struct timeval *tv = optval;\n          int milliseconds = tv->tv_sec * 1000 + tv->tv_usec / 1000;\n          optval = &milliseconds;\n          r = setsockopt (sock, level, optname, optval, sizeof (int));\n        }\n      else\n        {\n          r = setsockopt (sock, level, optname, optval, optlen);\n        }\n\n      if (r < 0)\n        set_winsock_errno ();\n\n      return r;\n    }\n}",
      "lines": 32,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/sig-handler.c": {},
  "sed/sed-4.5/gnulib-tests/sig-handler.h": {
    "get_handler": {
      "start_point": [
        36,
        32
      ],
      "end_point": [
        49,
        1
      ],
      "content": "_GL_ATTRIBUTE_PURE\nget_handler (struct sigaction const *a)\n{\n#ifdef SA_SIGINFO\n  /* POSIX says that special values like SIG_IGN can only occur when\n     action.sa_flags does not contain SA_SIGINFO.  But in Linux 2.4,\n     for example, sa_sigaction and sa_handler are aliases and a signal\n     is ignored if sa_sigaction (after casting) equals SIG_IGN.  So\n     use (and cast) sa_sigaction in that case.  */\n  if (a->sa_flags & SA_SIGINFO)\n    return (sa_handler_t) a->sa_sigaction;\n#endif\n  return a->sa_handler;\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "_GL_ATTRIBUTE_PURE"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/sigaction.c": {
    "sigaction_handler": {
      "start_point": [
        82,
        0
      ],
      "end_point": [
        123,
        1
      ],
      "content": "static void\nsigaction_handler (int sig)\n{\n  handler_t handler;\n  sigset_t mask;\n  sigset_t oldmask;\n  int saved_errno = errno;\n  if (sig < 0 || NSIG <= sig || !action_array[sig].sa_handler)\n    {\n      /* Unexpected situation; be careful to avoid recursive abort.  */\n      if (sig == SIGABRT)\n        signal (SIGABRT, SIG_DFL);\n      abort ();\n    }\n\n  /* Reinstall the signal handler when required; otherwise update the\n     bookkeeping so that the user's handler may call sigaction and get\n     accurate results.  We know the signal isn't currently blocked, or\n     we wouldn't be in its handler, therefore we know that we are not\n     interrupting a sigaction() call.  There is a race where any\n     asynchronous instance of the same signal occurring before we\n     reinstall the handler will trigger the default handler; oh\n     well.  */\n  handler = action_array[sig].sa_handler;\n  if ((action_array[sig].sa_flags & SA_RESETHAND) == 0)\n    signal (sig, sigaction_handler);\n  else\n    action_array[sig].sa_handler = NULL;\n\n  /* Block appropriate signals.  */\n  mask = action_array[sig].sa_mask;\n  if ((action_array[sig].sa_flags & SA_NODEFER) == 0)\n    sigaddset (&mask, sig);\n  sigprocmask (SIG_BLOCK, &mask, &oldmask);\n\n  /* Invoke the user's handler, then restore prior mask.  */\n  errno = saved_errno;\n  handler (sig);\n  saved_errno = errno;\n  sigprocmask (SIG_SETMASK, &oldmask, NULL);\n  errno = saved_errno;\n}",
      "lines": 42,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "sigaction": {
      "start_point": [
        129,
        0
      ],
      "end_point": [
        203,
        1
      ],
      "content": "int\nsigaction (int sig, const struct sigaction *restrict act,\n           struct sigaction *restrict oact)\n{\n  sigset_t mask;\n  sigset_t oldmask;\n  int saved_errno;\n\n  if (sig < 0 || NSIG <= sig || sig == SIGKILL || sig == SIGSTOP\n      || (act && act->sa_handler == SIG_ERR))\n    {\n      errno = EINVAL;\n      return -1;\n    }\n\n#ifdef SIGABRT_COMPAT\n  if (sig == SIGABRT_COMPAT)\n    sig = SIGABRT;\n#endif\n\n  /* POSIX requires sigaction() to be async-signal-safe.  In other\n     words, if an asynchronous signal can occur while we are anywhere\n     inside this function, the user's handler could then call\n     sigaction() recursively and expect consistent results.  We meet\n     this rule by using sigprocmask to block all signals before\n     modifying any data structure that could be read from a signal\n     handler; this works since we know that the gnulib sigprocmask\n     replacement does not try to use sigaction() from its handler.  */\n  if (!act && !oact)\n    return 0;\n  sigfillset (&mask);\n  sigprocmask (SIG_BLOCK, &mask, &oldmask);\n  if (oact)\n    {\n      if (action_array[sig].sa_handler)\n        *oact = action_array[sig];\n      else\n        {\n          /* Safe to change the handler at will here, since all\n             signals are currently blocked.  */\n          oact->sa_handler = signal (sig, SIG_DFL);\n          if (oact->sa_handler == SIG_ERR)\n            goto failure;\n          signal (sig, oact->sa_handler);\n          oact->sa_flags = SA_RESETHAND | SA_NODEFER;\n          sigemptyset (&oact->sa_mask);\n        }\n    }\n\n  if (act)\n    {\n      /* Safe to install the handler before updating action_array,\n         since all signals are currently blocked.  */\n      if (act->sa_handler == SIG_DFL || act->sa_handler == SIG_IGN)\n        {\n          if (signal (sig, act->sa_handler) == SIG_ERR)\n            goto failure;\n          action_array[sig].sa_handler = NULL;\n        }\n      else\n        {\n          if (signal (sig, sigaction_handler) == SIG_ERR)\n            goto failure;\n          action_array[sig] = *act;\n        }\n    }\n  sigprocmask (SIG_SETMASK, &oldmask, NULL);\n  return 0;\n\n failure:\n  saved_errno = errno;\n  sigprocmask (SIG_SETMASK, &oldmask, NULL);\n  errno = saved_errno;\n  return -1;\n}",
      "lines": 75,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/signal.in.h": {},
  "sed/sed-4.5/gnulib-tests/signature.h": {},
  "sed/sed-4.5/gnulib-tests/sigprocmask.c": {
    "signal_nothrow": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        73,
        5
      ],
      "content": "static handler_t\nsignal_nothrow (int sig, handler_t handler)\n{\n  handler_t result;\n\n  TRY_MSVC_INVAL\n    {\n      result = signal (sig, handler);\n    }",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "handler_t"
      ]
    },
    "ext_signal": {
      "start_point": [
        93,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "static handler_t\next_signal (int sig, handler_t handler)\n{\n  switch (sig)\n    {\n    case SIGPIPE:\n      {\n        handler_t old_handler = SIGPIPE_handler;\n        SIGPIPE_handler = handler;\n        return old_handler;\n      }\n    default: /* System defined signal */\n      return signal (sig, handler);\n    }\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "handler_t"
      ]
    },
    "sigismember": {
      "start_point": [
        112,
        0
      ],
      "end_point": [
        126,
        1
      ],
      "content": "int\nsigismember (const sigset_t *set, int sig)\n{\n  if (sig >= 0 && sig < NSIG)\n    {\n      #ifdef SIGABRT_COMPAT\n      if (sig == SIGABRT_COMPAT)\n        sig = SIGABRT;\n      #endif\n\n      return (*set >> sig) & 1;\n    }\n  else\n    return 0;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "sigemptyset": {
      "start_point": [
        128,
        0
      ],
      "end_point": [
        133,
        1
      ],
      "content": "int\nsigemptyset (sigset_t *set)\n{\n  *set = 0;\n  return 0;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "sigaddset": {
      "start_point": [
        135,
        0
      ],
      "end_point": [
        153,
        1
      ],
      "content": "int\nsigaddset (sigset_t *set, int sig)\n{\n  if (sig >= 0 && sig < NSIG)\n    {\n      #ifdef SIGABRT_COMPAT\n      if (sig == SIGABRT_COMPAT)\n        sig = SIGABRT;\n      #endif\n\n      *set |= 1U << sig;\n      return 0;\n    }\n  else\n    {\n      errno = EINVAL;\n      return -1;\n    }\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "sigdelset": {
      "start_point": [
        155,
        0
      ],
      "end_point": [
        173,
        1
      ],
      "content": "int\nsigdelset (sigset_t *set, int sig)\n{\n  if (sig >= 0 && sig < NSIG)\n    {\n      #ifdef SIGABRT_COMPAT\n      if (sig == SIGABRT_COMPAT)\n        sig = SIGABRT;\n      #endif\n\n      *set &= ~(1U << sig);\n      return 0;\n    }\n  else\n    {\n      errno = EINVAL;\n      return -1;\n    }\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "sigfillset": {
      "start_point": [
        176,
        0
      ],
      "end_point": [
        181,
        1
      ],
      "content": "int\nsigfillset (sigset_t *set)\n{\n  *set = ((2U << (NSIG - 1)) - 1) & ~ SIGABRT_COMPAT_MASK;\n  return 0;\n}",
      "lines": 6,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "blocked_handler": {
      "start_point": [
        190,
        0
      ],
      "end_point": [
        201,
        1
      ],
      "content": "static void\nblocked_handler (int sig)\n{\n  /* Reinstall the handler, in case the signal occurs multiple times\n     while blocked.  There is an inherent race where an asynchronous\n     signal in between when the kernel uninstalled the handler and\n     when we reinstall it will trigger the default handler; oh\n     well.  */\n  signal (sig, blocked_handler);\n  if (sig >= 0 && sig < NSIG)\n    pending_array[sig] = 1;\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "sigpending": {
      "start_point": [
        203,
        0
      ],
      "end_point": [
        214,
        1
      ],
      "content": "int\nsigpending (sigset_t *set)\n{\n  sigset_t pending = 0;\n  int sig;\n\n  for (sig = 0; sig < NSIG; sig++)\n    if (pending_array[sig])\n      pending |= 1U << sig;\n  *set = pending;\n  return 0;\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "sigprocmask": {
      "start_point": [
        220,
        0
      ],
      "end_point": [
        289,
        1
      ],
      "content": "int\nsigprocmask (int operation, const sigset_t *set, sigset_t *old_set)\n{\n  if (old_set != NULL)\n    *old_set = blocked_set;\n\n  if (set != NULL)\n    {\n      sigset_t new_blocked_set;\n      sigset_t to_unblock;\n      sigset_t to_block;\n\n      switch (operation)\n        {\n        case SIG_BLOCK:\n          new_blocked_set = blocked_set | *set;\n          break;\n        case SIG_SETMASK:\n          new_blocked_set = *set;\n          break;\n        case SIG_UNBLOCK:\n          new_blocked_set = blocked_set & ~*set;\n          break;\n        default:\n          errno = EINVAL;\n          return -1;\n        }\n      to_unblock = blocked_set & ~new_blocked_set;\n      to_block = new_blocked_set & ~blocked_set;\n\n      if (to_block != 0)\n        {\n          int sig;\n\n          for (sig = 0; sig < NSIG; sig++)\n            if ((to_block >> sig) & 1)\n              {\n                pending_array[sig] = 0;\n                if ((old_handlers[sig] = signal (sig, blocked_handler)) != SIG_ERR)\n                  blocked_set |= 1U << sig;\n              }\n        }\n\n      if (to_unblock != 0)\n        {\n          sig_atomic_t received[NSIG];\n          int sig;\n\n          for (sig = 0; sig < NSIG; sig++)\n            if ((to_unblock >> sig) & 1)\n              {\n                if (signal (sig, old_handlers[sig]) != blocked_handler)\n                  /* The application changed a signal handler while the signal\n                     was blocked, bypassing our rpl_signal replacement.\n                     We don't support this.  */\n                  abort ();\n                received[sig] = pending_array[sig];\n                blocked_set &= ~(1U << sig);\n                pending_array[sig] = 0;\n              }\n            else\n              received[sig] = 0;\n\n          for (sig = 0; sig < NSIG; sig++)\n            if (received[sig])\n              raise (sig);\n        }\n    }\n  return 0;\n}",
      "lines": 70,
      "depth": 17,
      "decorators": [
        "int"
      ]
    },
    "rpl_signal": {
      "start_point": [
        293,
        0
      ],
      "end_point": [
        329,
        1
      ],
      "content": "handler_t\nrpl_signal (int sig, handler_t handler)\n{\n  /* We must provide a wrapper, so that a user can query what handler\n     they installed even if that signal is currently blocked.  */\n  if (sig >= 0 && sig < NSIG && sig != SIGKILL && sig != SIGSTOP\n      && handler != SIG_ERR)\n    {\n      #ifdef SIGABRT_COMPAT\n      if (sig == SIGABRT_COMPAT)\n        sig = SIGABRT;\n      #endif\n\n      if (blocked_set & (1U << sig))\n        {\n          /* POSIX states that sigprocmask and signal are both\n             async-signal-safe.  This is not true of our\n             implementation - there is a slight data race where an\n             asynchronous interrupt on signal A can occur after we\n             install blocked_handler but before we have updated\n             old_handlers for signal B, such that handler A can see\n             stale information if it calls signal(B).  Oh well -\n             signal handlers really shouldn't try to manipulate the\n             installed handlers of unrelated signals.  */\n          handler_t result = old_handlers[sig];\n          old_handlers[sig] = handler;\n          return result;\n        }\n      else\n        return signal (sig, handler);\n    }\n  else\n    {\n      errno = EINVAL;\n      return SIG_ERR;\n    }\n}",
      "lines": 37,
      "depth": 10,
      "decorators": [
        "handler_t"
      ]
    },
    "_gl_raise_SIGPIPE": {
      "start_point": [
        333,
        0
      ],
      "end_point": [
        347,
        1
      ],
      "content": "int\n_gl_raise_SIGPIPE (void)\n{\n  if (blocked_set & (1U << SIGPIPE))\n    pending_array[SIGPIPE] = 1;\n  else\n    {\n      handler_t handler = SIGPIPE_handler;\n      if (handler == SIG_DFL)\n        exit (128 + SIGPIPE);\n      else if (handler != SIG_IGN)\n        (*handler) (SIGPIPE);\n    }\n  return 0;\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/sleep.c": {
    "sleep": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "unsigned int\nsleep (unsigned int seconds)\n{\n  unsigned int remaining;\n\n  /* Sleep for 1 second many times, because\n       1. Sleep is not interruptible by Ctrl-C,\n       2. we want to avoid arithmetic overflow while multiplying with 1000.  */\n  for (remaining = seconds; remaining > 0; remaining--)\n    Sleep (1000);\n\n  return remaining;\n}",
      "lines": 13,
      "depth": 7,
      "decorators": [
        "unsigned int",
        "unsigned",
        "int"
      ]
    },
    "rpl_sleep": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        69,
        1
      ],
      "content": "unsigned int\nrpl_sleep (unsigned int seconds)\n{\n  /* This requires int larger than 16 bits.  */\n  verify (UINT_MAX / 24 / 24 / 60 / 60);\n  const unsigned int limit = 24 * 24 * 60 * 60;\n  while (limit < seconds)\n    {\n      unsigned int result;\n      seconds -= limit;\n      result = sleep (limit);\n      if (result)\n        return seconds + result;\n    }\n  return sleep (seconds);\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "unsigned int",
        "unsigned",
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/socket.c": {
    "rpl_socket": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "int\nrpl_socket (int domain, int type, int protocol)\n{\n  SOCKET fh;\n\n  gl_sockets_startup (SOCKETS_1_1);\n\n  /* We have to use WSASocket() to create non-overlapped IO sockets.\n     Overlapped IO sockets cannot be used with read/write.  */\n  fh = WSASocket (domain, type, protocol, NULL, 0, 0);\n\n  if (fh == INVALID_SOCKET)\n    {\n      set_winsock_errno ();\n      return -1;\n    }\n  else\n    return SOCKET_TO_FD (fh);\n}",
      "lines": 19,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/sockets.c": {
    "close_fd_maybe_socket": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "static int\nclose_fd_maybe_socket (const struct fd_hook *remaining_list,\n                       gl_close_fn primary,\n                       int fd)\n{\n  /* Note about multithread-safety: There is a race condition where, between\n     our calls to closesocket() and the primary close(), some other thread\n     could make system calls that allocate precisely the same HANDLE value\n     as sock; then the primary close() would call CloseHandle() on it.  */\n  SOCKET sock;\n  WSANETWORKEVENTS ev;\n\n  /* Test whether fd refers to a socket.  */\n  sock = FD_TO_SOCKET (fd);\n  ev.lNetworkEvents = 0xDEADBEEF;\n  WSAEnumNetworkEvents (sock, NULL, &ev);\n  if (ev.lNetworkEvents != 0xDEADBEEF)\n    {\n      /* fd refers to a socket.  */\n      /* FIXME: other applications, like squid, use an undocumented\n         _free_osfhnd free function.  But this is not enough: The 'osfile'\n         flags for fd also needs to be cleared, but it is hard to access it.\n         Instead, here we just close twice the file descriptor.  */\n      if (closesocket (sock))\n        {\n          set_winsock_errno ();\n          return -1;\n        }\n      else\n        {\n          /* This call frees the file descriptor and does a\n             CloseHandle ((HANDLE) _get_osfhandle (fd)), which fails.  */\n          _close (fd);\n          return 0;\n        }\n    }\n  else\n    /* Some other type of file descriptor.  */\n    return execute_close_hooks (remaining_list, primary, fd);\n}",
      "lines": 40,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "ioctl_fd_maybe_socket": {
      "start_point": [
        80,
        0
      ],
      "end_point": [
        106,
        1
      ],
      "content": "static int\nioctl_fd_maybe_socket (const struct fd_hook *remaining_list,\n                       gl_ioctl_fn primary,\n                       int fd, int request, void *arg)\n{\n  SOCKET sock;\n  WSANETWORKEVENTS ev;\n\n  /* Test whether fd refers to a socket.  */\n  sock = FD_TO_SOCKET (fd);\n  ev.lNetworkEvents = 0xDEADBEEF;\n  WSAEnumNetworkEvents (sock, NULL, &ev);\n  if (ev.lNetworkEvents != 0xDEADBEEF)\n    {\n      /* fd refers to a socket.  */\n      if (ioctlsocket (sock, request, arg) < 0)\n        {\n          set_winsock_errno ();\n          return -1;\n        }\n      else\n        return 0;\n    }\n  else\n    /* Some other type of file descriptor.  */\n    return execute_ioctl_hooks (remaining_list, primary, fd, request, arg);\n}",
      "lines": 27,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "gl_sockets_startup": {
      "start_point": [
        114,
        0
      ],
      "end_point": [
        142,
        1
      ],
      "content": "int\ngl_sockets_startup (int version _GL_UNUSED)\n{\n#if WINDOWS_SOCKETS\n  if (version > initialized_sockets_version)\n    {\n      WSADATA data;\n      int err;\n\n      err = WSAStartup (version, &data);\n      if (err != 0)\n        return 1;\n\n      if (data.wVersion != version)\n        {\n          WSACleanup ();\n          return 2;\n        }\n\n      if (initialized_sockets_version == 0)\n        register_fd_hook (close_fd_maybe_socket, ioctl_fd_maybe_socket,\n                          &fd_sockets_hook);\n\n      initialized_sockets_version = version;\n    }\n#endif\n\n  return 0;\n}",
      "lines": 29,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "gl_sockets_cleanup": {
      "start_point": [
        144,
        0
      ],
      "end_point": [
        160,
        1
      ],
      "content": "int\ngl_sockets_cleanup (void)\n{\n#if WINDOWS_SOCKETS\n  int err;\n\n  initialized_sockets_version = 0;\n\n  unregister_fd_hook (&fd_sockets_hook);\n\n  err = WSACleanup ();\n  if (err != 0)\n    return 1;\n#endif\n\n  return 0;\n}",
      "lines": 17,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/sockets.h": {
    "gl_fd_to_handle": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "static inline SOCKET\ngl_fd_to_handle (int fd)\n{\n  return _get_osfhandle (fd);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "SOCKET"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/stdio-impl.h": {},
  "sed/sed-4.5/gnulib-tests/strdup.c": {
    "__strdup": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "char *\n__strdup (const char *s)\n{\n  size_t len = strlen (s) + 1;\n  void *new = malloc (len);\n\n  if (new == NULL)\n    return NULL;\n\n  return (char *) memcpy (new, s, len);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "char",
        "*\n__strdup (const char *s)",
        "*"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/strerror_r.c": {
    "local_snprintf": {
      "start_point": [
        109,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "static int\nlocal_snprintf (char *buf, size_t buflen, const char *format, ...)\n{\n  va_list args;\n  int result;\n\n  va_start (args, format);\n  result = _vsnprintf (buf, buflen, format, args);\n  va_end (args);\n  if (buflen > 0 && (result < 0 || result >= buflen))\n    buf[buflen - 1] = '\\0';\n  return result;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "safe_copy": {
      "start_point": [
        127,
        0
      ],
      "end_point": [
        147,
        1
      ],
      "content": "static int\nsafe_copy (char *buf, size_t buflen, const char *msg)\n{\n  size_t len = strlen (msg);\n  int ret;\n\n  if (len < buflen)\n    {\n      /* Although POSIX allows memcpy() to corrupt errno, we don't\n         know of any implementation where this is a real problem.  */\n      memcpy (buf, msg, len + 1);\n      ret = 0;\n    }\n  else\n    {\n      memcpy (buf, msg, buflen - 1);\n      buf[buflen - 1] = '\\0';\n      ret = ERANGE;\n    }\n  return ret;\n}",
      "lines": 21,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/symlink.c": {
    "rpl_symlink": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "int\nrpl_symlink (char const *contents, char const *name)\n{\n  size_t len = strlen (name);\n  if (len && name[len - 1] == '/')\n    {\n      struct stat st;\n      if (lstat (name, &st) == 0)\n        errno = EEXIST;\n      return -1;\n    }\n  return symlink (contents, name);\n}",
      "lines": 13,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "symlink": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "int\nsymlink (char const *contents _GL_UNUSED,\n         char const *name _GL_UNUSED)\n{\n  errno = ENOSYS;\n  return -1;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/sys_ioctl.in.h": {},
  "sed/sed-4.5/gnulib-tests/sys_select.in.h": {
    "rpl_fd_isset": {
      "start_point": [
        150,
        0
      ],
      "end_point": [
        162,
        1
      ],
      "content": "static int\nrpl_fd_isset (SOCKET fd, fd_set * set)\n{\n  u_int i;\n  if (set == NULL)\n    return 0;\n\n  for (i = 0; i < set->fd_count; i++)\n    if (set->fd_array[i] == fd)\n      return 1;\n\n  return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/sys_socket.c": {},
  "sed/sed-4.5/gnulib-tests/sys_socket.in.h": {
    "rpl_fd_isset": {
      "start_point": [
        225,
        0
      ],
      "end_point": [
        237,
        1
      ],
      "content": "_GL_SYS_SOCKET_INLINE int\nrpl_fd_isset (SOCKET fd, fd_set * set)\n{\n  u_int i;\n  if (set == NULL)\n    return 0;\n\n  for (i = 0; i < set->fd_count; i++)\n    if (set->fd_array[i] == fd)\n      return 1;\n\n  return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "_GL_SYS_SOCKET_INLINE",
        "int",
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/sys_uio.in.h": {},
  "sed/sed-4.5/gnulib-tests/test-accept.c": {
    "main": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "int\nmain (void)\n{\n  (void) gl_sockets_startup (SOCKETS_1_1);\n\n  /* Test behaviour for invalid file descriptors.  */\n  {\n    struct sockaddr_in addr;\n    socklen_t addrlen = sizeof (addr);\n\n    errno = 0;\n    ASSERT (accept (-1, (struct sockaddr *) &addr, &addrlen) == -1);\n    ASSERT (errno == EBADF);\n  }\n  {\n    struct sockaddr_in addr;\n    socklen_t addrlen = sizeof (addr);\n\n    close (99);\n    errno = 0;\n    ASSERT (accept (99, (struct sockaddr *) &addr, &addrlen) == -1);\n    ASSERT (errno == EBADF);\n  }\n\n  return 0;\n}",
      "lines": 26,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-alignof.c": {
    "main": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "int\nmain ()\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 4,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-alloca-opt.c": {
    "do_allocation": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        29,
        1
      ],
      "content": "static void\ndo_allocation (int n)\n{\n  void *ptr = alloca (n);\n  (void) ptr;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "int\nmain ()\n{\n#if HAVE_ALLOCA\n  int i;\n\n  /* Repeat a lot of times, to make sure there's no memory leak.  */\n  for (i = 0; i < 100000; i++)\n    {\n      /* Try various values.\n         n = 0 gave a crash on Alpha with gcc-2.5.8.\n         Some versions of Mac OS X have a stack size limit of 512 KB.  */\n      func (34);\n      func (134);\n      func (399);\n      func (510823);\n      func (129321);\n      func (0);\n      func (4070);\n      func (4095);\n      func (1);\n      func (16582);\n    }\n#endif\n\n  return 0;\n}",
      "lines": 27,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-arpa_inet.c": {
    "main": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        26,
        1
      ],
      "content": "int\nmain (void)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-binary-io.c": {
    "main": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  /* Test the O_BINARY macro.  */\n  {\n    int fd =\n      open (\"t-bin-out0.tmp\", O_CREAT | O_TRUNC | O_RDWR | O_BINARY, 0600);\n    if (write (fd, \"Hello\\n\", 6) < 0)\n      exit (1);\n    close (fd);\n  }\n  {\n    struct stat statbuf;\n    if (stat (\"t-bin-out0.tmp\", &statbuf) < 0)\n      exit (1);\n    ASSERT (statbuf.st_size == 6);\n  }\n\n  switch (argv[1][0])\n    {\n    case '1':\n      /* Test the set_binary_mode() function.  */\n      set_binary_mode (1, O_BINARY);\n      fputs (\"Hello\\n\", stdout);\n      break;\n\n    default:\n      break;\n    }\n\n  return 0;\n}",
      "lines": 32,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-bind.c": {
    "main": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "int\nmain (void)\n{\n  (void) gl_sockets_startup (SOCKETS_1_1);\n\n  /* Test behaviour for invalid file descriptors.  */\n  {\n    struct sockaddr_in addr;\n\n    addr.sin_family = AF_INET;\n    inet_pton (AF_INET, \"127.0.0.1\", &addr.sin_addr);\n    addr.sin_port = htons (80);\n    {\n      errno = 0;\n      ASSERT (bind (-1, (const struct sockaddr *) &addr, sizeof (addr)) == -1);\n      ASSERT (errno == EBADF);\n    }\n    {\n      close (99);\n      errno = 0;\n      ASSERT (bind (99, (const struct sockaddr *) &addr, sizeof (addr)) == -1);\n      ASSERT (errno == EBADF);\n    }\n  }\n\n  return 0;\n}",
      "lines": 27,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-btowc.c": {
    "main": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  int c;\n\n  /* configure should already have checked that the locale is supported.  */\n  if (setlocale (LC_ALL, \"\") == NULL)\n    return 1;\n\n  ASSERT (btowc (EOF) == WEOF);\n\n  if (argc > 1)\n    switch (argv[1][0])\n      {\n      case '1':\n        /* Locale encoding is ISO-8859-1 or ISO-8859-15.  */\n        for (c = 0; c < 0x80; c++)\n          ASSERT (btowc (c) == c);\n        for (c = 0xA0; c < 0x100; c++)\n          ASSERT (btowc (c) != WEOF);\n        return 0;\n\n      case '2':\n        /* Locale encoding is UTF-8.  */\n        for (c = 0; c < 0x80; c++)\n          ASSERT (btowc (c) == c);\n        for (c = 0x80; c < 0x100; c++)\n          ASSERT (btowc (c) == WEOF);\n        return 0;\n      }\n\n  return 1;\n}",
      "lines": 33,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-c-ctype.c": {
    "test_agree_with_C_locale": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "static void\ntest_agree_with_C_locale (void)\n{\n  int c;\n\n  for (c = 0; c <= UCHAR_MAX; c++)\n    {\n      ASSERT (c_isascii (c) == (isascii (c) != 0));\n      if (c_isascii (c))\n        {\n          ASSERT (c_isalnum (c) == (isalnum (c) != 0));\n          ASSERT (c_isalpha (c) == (isalpha (c) != 0));\n          ASSERT (c_isblank (c) == (isblank (c) != 0));\n          ASSERT (c_iscntrl (c) == (iscntrl (c) != 0));\n          ASSERT (c_isdigit (c) == (isdigit (c) != 0));\n          ASSERT (c_islower (c) == (islower (c) != 0));\n          ASSERT (c_isgraph (c) == (isgraph (c) != 0));\n          ASSERT (c_isprint (c) == (isprint (c) != 0));\n          ASSERT (c_ispunct (c) == (ispunct (c) != 0));\n          ASSERT (c_isspace (c) == (isspace (c) != 0));\n          ASSERT (c_isupper (c) == (isupper (c) != 0));\n          ASSERT (c_isxdigit (c) == (isxdigit (c) != 0));\n          ASSERT (c_tolower (c) == tolower (c));\n          ASSERT (c_toupper (c) == toupper (c));\n        }\n    }\n}",
      "lines": 27,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_all": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        211,
        1
      ],
      "content": "static void\ntest_all (void)\n{\n  int c;\n  int n_isascii = 0;\n\n  for (c = CHAR_MIN; c <= UCHAR_MAX; c++)\n    {\n      if (! (0 <= c && c <= CHAR_MAX))\n        {\n          ASSERT (! c_isascii (c));\n          ASSERT (! c_isalnum (c));\n          ASSERT (! c_isalpha (c));\n          ASSERT (! c_isblank (c));\n          ASSERT (! c_iscntrl (c));\n          ASSERT (! c_isdigit (c));\n          ASSERT (! c_islower (c));\n          ASSERT (! c_isgraph (c));\n          ASSERT (! c_isprint (c));\n          ASSERT (! c_ispunct (c));\n          ASSERT (! c_isspace (c));\n          ASSERT (! c_isupper (c));\n          ASSERT (! c_isxdigit (c));\n          ASSERT (c_tolower (c) == c);\n          ASSERT (c_toupper (c) == c);\n        }\n\n      n_isascii += c_isascii (c);\n\n#ifdef C_CTYPE_ASCII\n      ASSERT (c_isascii (c) == (0 <= c && c <= 0x7f));\n#endif\n\n      ASSERT (c_isascii (c) == (c_isprint (c) || c_iscntrl (c)));\n\n      ASSERT (c_isalnum (c) == (c_isalpha (c) || c_isdigit (c)));\n\n      ASSERT (c_isalpha (c) == (c_islower (c) || c_isupper (c)));\n\n      switch (c)\n        {\n        case '\\t': case ' ':\n          ASSERT (c_isblank (c) == 1);\n          break;\n        default:\n          ASSERT (c_isblank (c) == 0);\n          break;\n        }\n\n#ifdef C_CTYPE_ASCII\n      ASSERT (c_iscntrl (c) == ((c >= 0 && c < 0x20) || c == 0x7f));\n#endif\n\n      switch (c)\n        {\n        case '\\a': case '\\b': case '\\f': case '\\n':\n        case '\\r': case '\\t': case '\\v':\n          ASSERT (c_iscntrl (c));\n          break;\n        }\n\n      ASSERT (! (c_iscntrl (c) && c_isprint (c)));\n\n      switch (c)\n        {\n        case '0': case '1': case '2': case '3': case '4': case '5':\n        case '6': case '7': case '8': case '9':\n          ASSERT (c_isdigit (c) == 1);\n          break;\n        default:\n          ASSERT (c_isdigit (c) == 0);\n          break;\n        }\n\n      switch (c)\n        {\n        case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n        case 'g': case 'h': case 'i': case 'j': case 'k': case 'l':\n        case 'm': case 'n': case 'o': case 'p': case 'q': case 'r':\n        case 's': case 't': case 'u': case 'v': case 'w': case 'x':\n        case 'y': case 'z':\n          ASSERT (c_islower (c) == 1);\n          ASSERT (c_toupper (c) == c - 'a' + 'A');\n          break;\n        default:\n          ASSERT (c_islower (c) == 0);\n          ASSERT (c_toupper (c) == c);\n          break;\n        }\n\n#ifdef C_CTYPE_ASCII\n      ASSERT (c_isgraph (c) == ((c >= 0x20 && c < 0x7f) && c != ' '));\n\n      ASSERT (c_isprint (c) == (c >= 0x20 && c < 0x7f));\n#endif\n\n      ASSERT (c_isgraph (c) == (c_isalnum (c) || c_ispunct (c)));\n\n      ASSERT (c_isprint (c) == (c_isgraph (c) || c == ' '));\n\n      switch (c)\n        {\n        case '!': case '\"': case '#': case '$': case '%': case '&': case '\\'':\n        case '(': case ')': case '*': case '+': case ',': case '-': case '.':\n        case '/': case ':': case ';': case '<': case '=': case '>': case '?':\n        case '@': case '[': case'\\\\': case ']': case '^': case '_': case '`':\n        case '{': case '|': case '}': case '~':\n          ASSERT (c_ispunct (c) == 1);\n          break;\n        default:\n          ASSERT (c_ispunct (c) == 0);\n          break;\n        }\n\n      switch (c)\n        {\n        case ' ': case '\\t': case '\\n': case '\\v': case '\\f': case '\\r':\n          ASSERT (c_isspace (c) == 1);\n          break;\n        default:\n          ASSERT (c_isspace (c) == 0);\n          break;\n        }\n\n      switch (c)\n        {\n        case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n        case 'G': case 'H': case 'I': case 'J': case 'K': case 'L':\n        case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':\n        case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n        case 'Y': case 'Z':\n          ASSERT (c_isupper (c) == 1);\n          ASSERT (c_tolower (c) == c - 'A' + 'a');\n          break;\n        default:\n          ASSERT (c_isupper (c) == 0);\n          ASSERT (c_tolower (c) == c);\n          break;\n        }\n\n      switch (c)\n        {\n        case '0': case '1': case '2': case '3': case '4': case '5':\n        case '6': case '7': case '8': case '9':\n        case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n        case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n          ASSERT (c_isxdigit (c) == 1);\n          break;\n        default:\n          ASSERT (c_isxdigit (c) == 0);\n          break;\n        }\n    }\n\n  ASSERT (n_isascii == 128);\n}",
      "lines": 156,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        213,
        0
      ],
      "end_point": [
        227,
        1
      ],
      "content": "int\nmain ()\n{\n  test_agree_with_C_locale ();\n\n  test_all ();\n\n  setlocale (LC_ALL, \"de_DE\");\n  test_all ();\n\n  setlocale (LC_ALL, \"ja_JP.EUC-JP\");\n  test_all ();\n\n  return 0;\n}",
      "lines": 15,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-c-strcasecmp.c": {
    "main": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  if (argc > 1)\n    {\n      /* configure should already have checked that the locale is supported.  */\n      if (setlocale (LC_ALL, \"\") == NULL)\n        return 1;\n    }\n\n  ASSERT (c_strcasecmp (\"paragraph\", \"Paragraph\") == 0);\n\n  ASSERT (c_strcasecmp (\"paragrapH\", \"parAgRaph\") == 0);\n\n  ASSERT (c_strcasecmp (\"paragraph\", \"paraLyzed\") < 0);\n  ASSERT (c_strcasecmp (\"paraLyzed\", \"paragraph\") > 0);\n\n  ASSERT (c_strcasecmp (\"para\", \"paragraph\") < 0);\n  ASSERT (c_strcasecmp (\"paragraph\", \"para\") > 0);\n\n  /* The following tests shows how c_strcasecmp() is different from\n     strcasecmp().  */\n\n  ASSERT (c_strcasecmp (\"\\311mile\", \"\\351mile\") < 0);\n  ASSERT (c_strcasecmp (\"\\351mile\", \"\\311mile\") > 0);\n\n  /* The following tests shows how c_strcasecmp() is different from\n     mbscasecmp().  */\n\n  ASSERT (c_strcasecmp (\"\\303\\266zg\\303\\274r\", \"\\303\\226ZG\\303\\234R\") > 0); /* \u00c3\u00b6zg\u00c3\u00bcr */\n  ASSERT (c_strcasecmp (\"\\303\\226ZG\\303\\234R\", \"\\303\\266zg\\303\\274r\") < 0); /* \u00c3\u00b6zg\u00c3\u00bcr */\n\n#if C_CTYPE_ASCII\n  /* This test shows how strings of different size cannot compare equal.  */\n  ASSERT (c_strcasecmp (\"turkish\", \"TURK\\304\\260SH\") < 0);\n  ASSERT (c_strcasecmp (\"TURK\\304\\260SH\", \"turkish\") > 0);\n#endif\n\n  return 0;\n}",
      "lines": 40,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-c-strncasecmp.c": {
    "main": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        81,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  if (argc > 1)\n    {\n      /* configure should already have checked that the locale is supported.  */\n      if (setlocale (LC_ALL, \"\") == NULL)\n        return 1;\n    }\n\n  ASSERT (c_strncasecmp (\"paragraph\", \"Paragraph\", 1000000) == 0);\n  ASSERT (c_strncasecmp (\"paragraph\", \"Paragraph\", 9) == 0);\n\n  ASSERT (c_strncasecmp (\"paragrapH\", \"parAgRaph\", 1000000) == 0);\n  ASSERT (c_strncasecmp (\"paragrapH\", \"parAgRaph\", 9) == 0);\n\n  ASSERT (c_strncasecmp (\"paragraph\", \"paraLyzed\", 10) < 0);\n  ASSERT (c_strncasecmp (\"paragraph\", \"paraLyzed\", 9) < 0);\n  ASSERT (c_strncasecmp (\"paragraph\", \"paraLyzed\", 5) < 0);\n  ASSERT (c_strncasecmp (\"paragraph\", \"paraLyzed\", 4) == 0);\n  ASSERT (c_strncasecmp (\"paraLyzed\", \"paragraph\", 10) > 0);\n  ASSERT (c_strncasecmp (\"paraLyzed\", \"paragraph\", 9) > 0);\n  ASSERT (c_strncasecmp (\"paraLyzed\", \"paragraph\", 5) > 0);\n  ASSERT (c_strncasecmp (\"paraLyzed\", \"paragraph\", 4) == 0);\n\n  ASSERT (c_strncasecmp (\"para\", \"paragraph\", 10) < 0);\n  ASSERT (c_strncasecmp (\"para\", \"paragraph\", 9) < 0);\n  ASSERT (c_strncasecmp (\"para\", \"paragraph\", 5) < 0);\n  ASSERT (c_strncasecmp (\"para\", \"paragraph\", 4) == 0);\n  ASSERT (c_strncasecmp (\"paragraph\", \"para\", 10) > 0);\n  ASSERT (c_strncasecmp (\"paragraph\", \"para\", 9) > 0);\n  ASSERT (c_strncasecmp (\"paragraph\", \"para\", 5) > 0);\n  ASSERT (c_strncasecmp (\"paragraph\", \"para\", 4) == 0);\n\n  /* The following tests shows how c_strncasecmp() is different from\n     strncasecmp().  */\n\n  ASSERT (c_strncasecmp (\"\\311mily\", \"\\351mile\", 4) < 0);\n  ASSERT (c_strncasecmp (\"\\351mile\", \"\\311mily\", 4) > 0);\n\n  /* The following tests shows how c_strncasecmp() is different from\n     mbsncasecmp().  */\n\n  ASSERT (c_strncasecmp (\"\\303\\266zg\\303\\274r\", \"\\303\\226ZG\\303\\234R\", 99) > 0); /* \u00c3\u00b6zg\u00c3\u00bcr */\n  ASSERT (c_strncasecmp (\"\\303\\226ZG\\303\\234R\", \"\\303\\266zg\\303\\274r\", 99) < 0); /* \u00c3\u00b6zg\u00c3\u00bcr */\n\n#if C_CTYPE_ASCII\n  /* This test shows how strings of different size cannot compare equal.  */\n  ASSERT (c_strncasecmp (\"turkish\", \"TURK\\304\\260SH\", 7) < 0);\n  ASSERT (c_strncasecmp (\"TURK\\304\\260SH\", \"turkish\", 7) > 0);\n#endif\n\n  return 0;\n}",
      "lines": 54,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-canonicalize-lgpl.c": {
    "main": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        221,
        1
      ],
      "content": "int\nmain (void)\n{\n#if GNULIB_TEST_CANONICALIZE\n  /* No need to test canonicalize-lgpl module if canonicalize is also\n     in use.  */\n  return 0;\n#endif\n\n  /* Setup some hierarchy to be used by this test.  Start by removing\n     any leftovers from a previous partial run.  */\n  {\n    int fd;\n    ignore_value (system (\"rm -rf \" BASE \" ise\"));\n    ASSERT (mkdir (BASE, 0700) == 0);\n    fd = creat (BASE \"/tra\", 0600);\n    ASSERT (0 <= fd);\n    ASSERT (close (fd) == 0);\n  }\n\n  /* Check for ., .., intermediate // handling, and for error cases.  */\n  {\n    char *result = canonicalize_file_name (BASE \"//./..//\" BASE \"/tra\");\n    ASSERT (result != NULL);\n    ASSERT (strstr (result, \"/\" BASE \"/tra\")\n            == result + strlen (result) - strlen (\"/\" BASE \"/tra\"));\n    free (result);\n    errno = 0;\n    result = canonicalize_file_name (\"\");\n    ASSERT (result == NULL);\n    ASSERT (errno == ENOENT);\n    errno = 0;\n    result = canonicalize_file_name (null_ptr ());\n    ASSERT (result == NULL);\n    ASSERT (errno == EINVAL);\n  }\n\n  /* Check that a non-directory with trailing slash yields NULL.  */\n  {\n    char *result;\n    errno = 0;\n    result = canonicalize_file_name (BASE \"/tra/\");\n    ASSERT (result == NULL);\n    ASSERT (errno == ENOTDIR);\n  }\n\n  /* Check that a missing directory yields NULL.  */\n  {\n    char *result;\n    errno = 0;\n    result = canonicalize_file_name (BASE \"/zzz/..\");\n    ASSERT (result == NULL);\n    ASSERT (errno == ENOENT);\n  }\n\n  /* From here on out, tests involve symlinks.  */\n  if (symlink (BASE \"/ket\", \"ise\") != 0)\n    {\n      ASSERT (remove (BASE \"/tra\") == 0);\n      ASSERT (rmdir (BASE) == 0);\n      fputs (\"skipping test: symlinks not supported on this file system\\n\",\n             stderr);\n      return 77;\n    }\n  ASSERT (symlink (\"bef\", BASE \"/plo\") == 0);\n  ASSERT (symlink (\"tra\", BASE \"/huk\") == 0);\n  ASSERT (symlink (\"lum\", BASE \"/bef\") == 0);\n  ASSERT (symlink (\"wum\", BASE \"/ouk\") == 0);\n  ASSERT (symlink (\"../ise\", BASE \"/ket\") == 0);\n  ASSERT (mkdir (BASE \"/lum\", 0700) == 0);\n  ASSERT (symlink (\"//.//../..\", BASE \"/droot\") == 0);\n\n  /* Check that the symbolic link to a file can be resolved.  */\n  {\n    char *result1 = canonicalize_file_name (BASE \"/huk\");\n    char *result2 = canonicalize_file_name (BASE \"/tra\");\n    ASSERT (result1 != NULL);\n    ASSERT (result2 != NULL);\n    ASSERT (strcmp (result1, result2) == 0);\n    ASSERT (strcmp (result1 + strlen (result1) - strlen (\"/\" BASE \"/tra\"),\n                    \"/\" BASE \"/tra\") == 0);\n    free (result1);\n    free (result2);\n  }\n\n  /* Check that the symbolic link to a directory can be resolved.  */\n  {\n    char *result1 = canonicalize_file_name (BASE \"/plo\");\n    char *result2 = canonicalize_file_name (BASE \"/bef\");\n    char *result3 = canonicalize_file_name (BASE \"/lum\");\n    ASSERT (result1 != NULL);\n    ASSERT (result2 != NULL);\n    ASSERT (result3 != NULL);\n    ASSERT (strcmp (result1, result2) == 0);\n    ASSERT (strcmp (result2, result3) == 0);\n    ASSERT (strcmp (result1 + strlen (result1) - strlen (\"/\" BASE \"/lum\"),\n                    \"/\" BASE \"/lum\") == 0);\n    free (result1);\n    free (result2);\n    free (result3);\n  }\n\n  /* Check that a symbolic link to a nonexistent file yields NULL.  */\n  {\n    char *result;\n    errno = 0;\n    result = canonicalize_file_name (BASE \"/ouk\");\n    ASSERT (result == NULL);\n    ASSERT (errno == ENOENT);\n  }\n\n  /* Check that a non-directory symlink with trailing slash yields NULL.  */\n  {\n    char *result;\n    errno = 0;\n    result = canonicalize_file_name (BASE \"/huk/\");\n    ASSERT (result == NULL);\n    ASSERT (errno == ENOTDIR);\n  }\n\n  /* Check that a missing directory via symlink yields NULL.  */\n  {\n    char *result;\n    errno = 0;\n    result = canonicalize_file_name (BASE \"/ouk/..\");\n    ASSERT (result == NULL);\n    ASSERT (errno == ENOENT);\n  }\n\n  /* Check that a loop of symbolic links is detected.  */\n  {\n    char *result;\n    errno = 0;\n    result = canonicalize_file_name (\"ise\");\n    ASSERT (result == NULL);\n    ASSERT (errno == ELOOP);\n  }\n\n  /* Check that leading // is honored correctly.  */\n  {\n    struct stat st1;\n    struct stat st2;\n    char *result1 = canonicalize_file_name (\"//.\");\n    char *result2 = canonicalize_file_name (BASE \"/droot\");\n    ASSERT (result1);\n    ASSERT (result2);\n    ASSERT (stat (\"/\", &st1) == 0);\n    ASSERT (stat (\"//\", &st2) == 0);\n    /* On IBM z/OS, \"/\" and \"//\" are distinct, yet they both have\n       st_dev == st_ino == 1.  */\n#ifndef __MVS__\n    if (SAME_INODE (st1, st2))\n      {\n        ASSERT (strcmp (result1, \"/\") == 0);\n        ASSERT (strcmp (result2, \"/\") == 0);\n      }\n    else\n#endif\n      {\n        ASSERT (strcmp (result1, \"//\") == 0);\n        ASSERT (strcmp (result2, \"//\") == 0);\n      }\n    free (result1);\n    free (result2);\n  }\n\n\n  /* Cleanup.  */\n  ASSERT (remove (BASE \"/droot\") == 0);\n  ASSERT (remove (BASE \"/plo\") == 0);\n  ASSERT (remove (BASE \"/huk\") == 0);\n  ASSERT (remove (BASE \"/bef\") == 0);\n  ASSERT (remove (BASE \"/ouk\") == 0);\n  ASSERT (remove (BASE \"/ket\") == 0);\n  ASSERT (remove (BASE \"/lum\") == 0);\n  ASSERT (remove (BASE \"/tra\") == 0);\n  ASSERT (remove (BASE) == 0);\n  ASSERT (remove (\"ise\") == 0);\n\n  return 0;\n}",
      "lines": 181,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-chdir.c": {
    "main": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        32,
        1
      ],
      "content": "int\nmain (void)\n{\n  ASSERT (chdir (\"/\") == 0);\n\n  return 0;\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-cloexec.c": {
    "is_inheritable": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "static int\nis_inheritable (int fd)\n{\n#if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n  /* On native Windows, the initial state of unassigned standard file\n     descriptors is that they are open but point to an\n     INVALID_HANDLE_VALUE, and there is no fcntl.  */\n  HANDLE h = (HANDLE) _get_osfhandle (fd);\n  DWORD flags;\n  if (h == INVALID_HANDLE_VALUE || GetHandleInformation (h, &flags) == 0)\n    return 0;\n  return (flags & HANDLE_FLAG_INHERIT) != 0;\n#else\n# ifndef F_GETFD\n#  error Please port fcntl to your platform\n# endif\n  int i = fcntl (fd, F_GETFD);\n  return 0 <= i && (i & FD_CLOEXEC) == 0;\n#endif\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "zero": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        65,
        36
      ],
      "content": "static int zero (void) { return 0; }",
      "lines": 1,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "is_mode": {
      "start_point": [
        70,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "static int\nis_mode (int fd, int mode)\n{\n  int value = setmode (fd, O_BINARY);\n  setmode (fd, value);\n  return mode == value;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        78,
        0
      ],
      "end_point": [
        147,
        1
      ],
      "content": "int\nmain (void)\n{\n  const char *file = \"test-cloexec.tmp\";\n  int fd = creat (file, 0600);\n  int fd2;\n  int bad_fd = getdtablesize ();\n\n  /* Assume std descriptors were provided by invoker.  */\n  ASSERT (STDERR_FILENO < fd);\n  ASSERT (is_inheritable (fd));\n\n  /* Normal use of set_cloexec_flag.  */\n  ASSERT (set_cloexec_flag (fd, true) == 0);\n#if !((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__)\n  ASSERT (!is_inheritable (fd));\n#endif\n  ASSERT (set_cloexec_flag (fd, false) == 0);\n  ASSERT (is_inheritable (fd));\n\n  /* Normal use of dup_cloexec.  */\n  fd2 = dup_cloexec (fd);\n  ASSERT (fd < fd2);\n  ASSERT (!is_inheritable (fd2));\n  ASSERT (close (fd) == 0);\n  ASSERT (dup_cloexec (fd2) == fd);\n  ASSERT (!is_inheritable (fd));\n  ASSERT (close (fd2) == 0);\n\n  /* On systems that distinguish between text and binary mode,\n     dup_cloexec reuses the mode of the source.  */\n  setmode (fd, O_BINARY);\n  ASSERT (is_mode (fd, O_BINARY));\n  fd2 = dup_cloexec (fd);\n  ASSERT (fd < fd2);\n  ASSERT (is_mode (fd2, O_BINARY));\n  ASSERT (close (fd2) == 0);\n  setmode (fd, O_TEXT);\n  ASSERT (is_mode (fd, O_TEXT));\n  fd2 = dup_cloexec (fd);\n  ASSERT (fd < fd2);\n  ASSERT (is_mode (fd2, O_TEXT));\n  ASSERT (close (fd2) == 0);\n\n  /* Test error handling.  */\n  errno = 0;\n  ASSERT (set_cloexec_flag (-1, false) == -1);\n  ASSERT (errno == EBADF);\n  errno = 0;\n  ASSERT (set_cloexec_flag (bad_fd, false) == -1);\n  ASSERT (errno == EBADF);\n  errno = 0;\n  ASSERT (set_cloexec_flag (fd2, false) == -1);\n  ASSERT (errno == EBADF);\n  errno = 0;\n  ASSERT (dup_cloexec (-1) == -1);\n  ASSERT (errno == EBADF);\n  errno = 0;\n  ASSERT (dup_cloexec (bad_fd) == -1);\n  ASSERT (errno == EBADF);\n  errno = 0;\n  ASSERT (dup_cloexec (fd2) == -1);\n  ASSERT (errno == EBADF);\n\n  /* Clean up.  */\n  ASSERT (close (fd) == 0);\n  ASSERT (unlink (file) == 0);\n\n  return 0;\n}",
      "lines": 70,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-close.c": {
    "main": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "int\nmain (void)\n{\n  /* Test behaviour for invalid file descriptors.  */\n  {\n    errno = 0;\n    ASSERT (close (-1) == -1);\n    ASSERT (errno == EBADF);\n  }\n  {\n    close (99);\n    errno = 0;\n    ASSERT (close (99) == -1);\n    ASSERT (errno == EBADF);\n  }\n\n  return 0;\n}",
      "lines": 18,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-connect.c": {
    "main": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "int\nmain (void)\n{\n  (void) gl_sockets_startup (SOCKETS_1_1);\n\n  /* Test behaviour for invalid file descriptors.  */\n  {\n    struct sockaddr_in addr;\n\n    addr.sin_family = AF_INET;\n    inet_pton (AF_INET, \"127.0.0.1\", &addr.sin_addr);\n    addr.sin_port = htons (80);\n    {\n      errno = 0;\n      ASSERT (connect (-1, (const struct sockaddr *) &addr, sizeof (addr))\n              == -1);\n      ASSERT (errno == EBADF);\n    }\n    {\n      close (99);\n      errno = 0;\n      ASSERT (connect (99, (const struct sockaddr *) &addr, sizeof (addr))\n              == -1);\n      ASSERT (errno == EBADF);\n    }\n  }\n\n  return 0;\n}",
      "lines": 29,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-copy-acl.c": {
    "main": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  const char *file1;\n  const char *file2;\n  int fd1;\n  struct stat statbuf;\n  int mode;\n  int fd2;\n\n  ASSERT (argc == 3);\n\n  file1 = argv[1];\n  file2 = argv[2];\n\n  fd1 = open (file1, O_RDONLY);\n  if (fd1 < 0 || fstat (fd1, &statbuf) < 0)\n    {\n      fprintf (stderr, \"could not open file \\\"%s\\\"\\n\", file1);\n      exit (EXIT_FAILURE);\n    }\n  mode = statbuf.st_mode & 07777;\n\n  fd2 = open (file2, O_WRONLY, 0600);\n  if (fd2 < 0)\n    {\n      fprintf (stderr, \"could not open file \\\"%s\\\"\\n\", file2);\n      exit (EXIT_FAILURE);\n    }\n\n#if USE_ACL\n  if (copy_acl (file1, fd1, file2, fd2, mode))\n    exit (EXIT_FAILURE);\n#else\n  chmod (file2, mode);\n#endif\n\n  close (fd2);\n  close (fd1);\n\n  return 0;\n}",
      "lines": 42,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-ctype.c": {
    "main": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        26,
        1
      ],
      "content": "int\nmain (void)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-dirent.c": {
    "main": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        31,
        1
      ],
      "content": "int\nmain (void)\n{\n  return d.d_name[0] + i;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-dup2.c": {
    "is_open": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "static int\nis_open (int fd)\n{\n#if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n  /* On native Windows, the initial state of unassigned standard file\n     descriptors is that they are open but point to an\n     INVALID_HANDLE_VALUE, and there is no fcntl.  */\n  return (HANDLE) _get_osfhandle (fd) != INVALID_HANDLE_VALUE;\n#else\n# ifndef F_GETFL\n#  error Please port fcntl to your platform\n# endif\n  return 0 <= fcntl (fd, F_GETFL);\n#endif\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "is_inheritable": {
      "start_point": [
        71,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "static int\nis_inheritable (int fd)\n{\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n  /* On native Windows, the initial state of unassigned standard file\n     descriptors is that they are open but point to an\n     INVALID_HANDLE_VALUE, and there is no fcntl.  */\n  HANDLE h = (HANDLE) _get_osfhandle (fd);\n  DWORD flags;\n  if (h == INVALID_HANDLE_VALUE || GetHandleInformation (h, &flags) == 0)\n    return 0;\n  return (flags & HANDLE_FLAG_INHERIT) != 0;\n# else\n#  ifndef F_GETFD\n#   error Please port fcntl to your platform\n#  endif\n  int i = fcntl (fd, F_GETFD);\n  return 0 <= i && (i & FD_CLOEXEC) == 0;\n# endif\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "zero": {
      "start_point": [
        95,
        0
      ],
      "end_point": [
        95,
        36
      ],
      "content": "static int zero (void) { return 0; }",
      "lines": 1,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "is_mode": {
      "start_point": [
        100,
        0
      ],
      "end_point": [
        106,
        1
      ],
      "content": "static int\nis_mode (int fd, int mode)\n{\n  int value = setmode (fd, O_BINARY);\n  setmode (fd, value);\n  return mode == value;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        108,
        0
      ],
      "end_point": [
        221,
        1
      ],
      "content": "int\nmain (void)\n{\n  const char *file = \"test-dup2.tmp\";\n  char buffer[1];\n  int bad_fd = getdtablesize ();\n  int fd = open (file, O_CREAT | O_TRUNC | O_RDWR, 0600);\n\n  /* Assume std descriptors were provided by invoker.  */\n  ASSERT (STDERR_FILENO < fd);\n  ASSERT (is_open (fd));\n  /* Ignore any other fd's leaked into this process.  */\n  close (fd + 1);\n  close (fd + 2);\n  ASSERT (!is_open (fd + 1));\n  ASSERT (!is_open (fd + 2));\n\n  /* Assigning to self must be a no-op.  */\n  ASSERT (dup2 (fd, fd) == fd);\n  ASSERT (is_open (fd));\n\n  /* The source must be valid.  */\n  errno = 0;\n  ASSERT (dup2 (-1, fd) == -1);\n  ASSERT (errno == EBADF);\n  close (99);\n  errno = 0;\n  ASSERT (dup2 (99, fd) == -1);\n  ASSERT (errno == EBADF);\n  errno = 0;\n  ASSERT (dup2 (AT_FDCWD, fd) == -1);\n  ASSERT (errno == EBADF);\n  ASSERT (is_open (fd));\n\n  /* If the source is not open, then the destination is unaffected.  */\n  errno = 0;\n  ASSERT (dup2 (fd + 1, fd + 1) == -1);\n  ASSERT (errno == EBADF);\n  ASSERT (!is_open (fd + 1));\n  errno = 0;\n  ASSERT (dup2 (fd + 1, fd) == -1);\n  ASSERT (errno == EBADF);\n  ASSERT (is_open (fd));\n\n  /* The destination must be valid.  */\n  errno = 0;\n  ASSERT (dup2 (fd, -2) == -1);\n  ASSERT (errno == EBADF);\n  if (bad_fd > 256)\n    {\n      ASSERT (dup2 (fd, 255) == 255);\n      ASSERT (dup2 (fd, 256) == 256);\n      ASSERT (close (255) == 0);\n      ASSERT (close (256) == 0);\n    }\n  ASSERT (dup2 (fd, bad_fd - 1) == bad_fd - 1);\n  ASSERT (close (bad_fd - 1) == 0);\n  errno = 0;\n  ASSERT (dup2 (fd, bad_fd) == -1);\n  ASSERT (errno == EBADF);\n\n  /* Using dup2 can skip fds.  */\n  ASSERT (dup2 (fd, fd + 2) == fd + 2);\n  ASSERT (is_open (fd));\n  ASSERT (!is_open (fd + 1));\n  ASSERT (is_open (fd + 2));\n\n  /* Verify that dup2 closes the previous occupant of a fd.  */\n  ASSERT (open (\"/dev/null\", O_WRONLY, 0600) == fd + 1);\n  ASSERT (dup2 (fd + 1, fd) == fd);\n  ASSERT (close (fd + 1) == 0);\n  ASSERT (write (fd, \"1\", 1) == 1);\n  ASSERT (dup2 (fd + 2, fd) == fd);\n  ASSERT (lseek (fd, 0, SEEK_END) == 0);\n  ASSERT (write (fd + 2, \"2\", 1) == 1);\n  ASSERT (lseek (fd, 0, SEEK_SET) == 0);\n  ASSERT (read (fd, buffer, 1) == 1);\n  ASSERT (*buffer == '2');\n\n#if GNULIB_TEST_CLOEXEC\n  /* Any new fd created by dup2 must not be cloexec.  */\n  ASSERT (close (fd + 2) == 0);\n  ASSERT (dup_cloexec (fd) == fd + 1);\n  ASSERT (!is_inheritable (fd + 1));\n  ASSERT (dup2 (fd + 1, fd + 1) == fd + 1);\n  ASSERT (!is_inheritable (fd + 1));\n  ASSERT (dup2 (fd + 1, fd + 2) == fd + 2);\n  ASSERT (!is_inheritable (fd + 1));\n  ASSERT (is_inheritable (fd + 2));\n  errno = 0;\n  ASSERT (dup2 (fd + 1, -1) == -1);\n  ASSERT (errno == EBADF);\n  ASSERT (!is_inheritable (fd + 1));\n#endif\n\n  /* On systems that distinguish between text and binary mode, dup2\n     reuses the mode of the source.  */\n  setmode (fd, O_BINARY);\n  ASSERT (is_mode (fd, O_BINARY));\n  ASSERT (dup2 (fd, fd + 1) == fd + 1);\n  ASSERT (is_mode (fd + 1, O_BINARY));\n  setmode (fd, O_TEXT);\n  ASSERT (is_mode (fd, O_TEXT));\n  ASSERT (dup2 (fd, fd + 1) == fd + 1);\n  ASSERT (is_mode (fd + 1, O_TEXT));\n\n  /* Clean up.  */\n  ASSERT (close (fd + 2) == 0);\n  ASSERT (close (fd + 1) == 0);\n  ASSERT (close (fd) == 0);\n  ASSERT (unlink (file) == 0);\n\n  return 0;\n}",
      "lines": 114,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-environ.c": {
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "int\nmain ()\n{\n  /* The environment variables that are set even in the weirdest situations\n     are HOME and PATH.\n     POSIX says that HOME is initialized by the system, and that PATH may be\n     unset.  But in practice it's more frequent to see HOME unset and PATH\n     set.  So we test the presence of PATH.  */\n  char **remaining_variables = environ;\n  char *string;\n\n  for (; (string = *remaining_variables) != NULL; remaining_variables++)\n    {\n      if (strncmp (string, \"PATH=\", 5) == 0)\n        /* Found the PATH environment variable.  */\n        return 0;\n    }\n  /* Failed to find the PATH environment variable.  */\n  return 1;\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-errno.c": {
    "main": {
      "start_point": [
        107,
        0
      ],
      "end_point": [
        118,
        1
      ],
      "content": "int\nmain ()\n{\n  /* Verify that errno can be assigned.  */\n  errno = EOVERFLOW;\n\n  /* snprintf() callers want to distinguish EINVAL and EOVERFLOW.  */\n  if (errno == EINVAL)\n    return 1;\n\n  return 0;\n}",
      "lines": 12,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-fcntl-h.c": {
    "main": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        129,
        1
      ],
      "content": "int\nmain (void)\n{\n  /* Ensure no overlap in SEEK_*. */\n  switch (0)\n    {\n    case SEEK_CUR:\n    case SEEK_END:\n    case SEEK_SET:\n      ;\n    }\n\n  /* Ensure no dangerous overlap in non-zero gnulib-defined replacements.  */\n  switch (O_RDONLY)\n    {\n      /* Access modes */\n    case O_RDONLY:\n    case O_WRONLY:\n    case O_RDWR:\n#if O_EXEC && O_EXEC != O_RDONLY\n    case O_EXEC:\n#endif\n#if O_SEARCH && O_EXEC != O_SEARCH && O_SEARCH != O_RDONLY\n    case O_SEARCH:\n#endif\n      i = ! (~O_ACCMODE & (O_RDONLY | O_WRONLY | O_RDWR | O_EXEC | O_SEARCH));\n      break;\n\n      /* Everyone should have these */\n    case O_CREAT:\n    case O_EXCL:\n    case O_TRUNC:\n    case O_APPEND:\n      break;\n\n      /* These might be 0 or O_RDONLY, only test non-zero versions.  */\n#if O_CLOEXEC\n    case O_CLOEXEC:\n#endif\n#if O_DIRECT\n    case O_DIRECT:\n#endif\n#if O_DIRECTORY\n    case O_DIRECTORY:\n#endif\n#if O_DSYNC\n    case O_DSYNC:\n#endif\n#if O_IGNORE_CTTY\n    case O_IGNORE_CTTY:\n#endif\n#if O_NOATIME\n    case O_NOATIME:\n#endif\n#if O_NONBLOCK\n    case O_NONBLOCK:\n#endif\n#if O_NOCTTY\n    case O_NOCTTY:\n#endif\n#if O_NOFOLLOW\n    case O_NOFOLLOW:\n#endif\n#if O_NOLINK\n    case O_NOLINK:\n#endif\n#if O_NOLINKS\n    case O_NOLINKS:\n#endif\n#if O_NOTRANS\n    case O_NOTRANS:\n#endif\n#if O_RSYNC && O_RSYNC != O_DSYNC\n    case O_RSYNC:\n#endif\n#if O_SYNC && O_SYNC != O_DSYNC && O_SYNC != O_RSYNC\n    case O_SYNC:\n#endif\n#if O_TTY_INIT\n    case O_TTY_INIT:\n#endif\n#if O_BINARY\n    case O_BINARY:\n#endif\n#if O_TEXT\n    case O_TEXT:\n#endif\n      ;\n    }\n\n  return !i;\n}",
      "lines": 92,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-fcntl.c": {
    "zero": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        49,
        36
      ],
      "content": "static int zero (void) { return 0; }",
      "lines": 1,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "is_open": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "static bool\nis_open (int fd)\n{\n#if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n  /* On native Windows, the initial state of unassigned standard file\n     descriptors is that they are open but point to an\n     INVALID_HANDLE_VALUE, and there is no fcntl.  */\n  return (HANDLE) _get_osfhandle (fd) != INVALID_HANDLE_VALUE;\n#else\n# ifndef F_GETFL\n#  error Please port fcntl to your platform\n# endif\n  return 0 <= fcntl (fd, F_GETFL);\n#endif\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "is_inheritable": {
      "start_point": [
        70,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "static bool\nis_inheritable (int fd)\n{\n#if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n  /* On native Windows, the initial state of unassigned standard file\n     descriptors is that they are open but point to an\n     INVALID_HANDLE_VALUE, and there is no fcntl.  */\n  HANDLE h = (HANDLE) _get_osfhandle (fd);\n  DWORD flags;\n  if (h == INVALID_HANDLE_VALUE || GetHandleInformation (h, &flags) == 0)\n    return false;\n  return (flags & HANDLE_FLAG_INHERIT) != 0;\n#else\n# ifndef F_GETFD\n#  error Please port fcntl to your platform\n# endif\n  int i = fcntl (fd, F_GETFD);\n  return 0 <= i && (i & FD_CLOEXEC) == 0;\n#endif\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "is_mode": {
      "start_point": [
        93,
        0
      ],
      "end_point": [
        99,
        1
      ],
      "content": "static bool\nis_mode (int fd, int mode)\n{\n  int value = setmode (fd, O_BINARY);\n  setmode (fd, value);\n  return mode == value;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "func1": {
      "start_point": [
        114,
        0
      ],
      "end_point": [
        129,
        1
      ],
      "content": "static int\nfunc1 (int a, ...)\n{\n  va_list arg;\n  int i;\n  va_start (arg, a);\n  if (a < 4)\n    i = va_arg (arg, int);\n  else\n    {\n      struct dummy_struct *s = va_arg (arg, struct dummy_struct *);\n      i = s->value;\n    }\n  va_end (arg);\n  return i;\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "func2": {
      "start_point": [
        130,
        0
      ],
      "end_point": [
        139,
        1
      ],
      "content": "static int\nfunc2 (int a, ...)\n{\n  va_list arg;\n  void *p;\n  va_start (arg, a);\n  p = va_arg (arg, void *);\n  va_end (arg);\n  return func1 (a, p);\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "check_flags": {
      "start_point": [
        143,
        0
      ],
      "end_point": [
        210,
        1
      ],
      "content": "static void\ncheck_flags (void)\n{\n  switch (0)\n    {\n    case F_DUPFD:\n#if F_DUPFD\n#endif\n\n    case F_DUPFD_CLOEXEC:\n#if F_DUPFD_CLOEXEC\n#endif\n\n    case F_GETFD:\n#if F_GETFD\n#endif\n\n#ifdef F_SETFD\n    case F_SETFD:\n# if F_SETFD\n# endif\n#endif\n\n#ifdef F_GETFL\n    case F_GETFL:\n# if F_GETFL\n# endif\n#endif\n\n#ifdef F_SETFL\n    case F_SETFL:\n# if F_SETFL\n# endif\n#endif\n\n#ifdef F_GETOWN\n    case F_GETOWN:\n# if F_GETOWN\n# endif\n#endif\n\n#ifdef F_SETOWN\n    case F_SETOWN:\n# if F_SETOWN\n# endif\n#endif\n\n#ifdef F_GETLK\n    case F_GETLK:\n# if F_GETLK\n# endif\n#endif\n\n#ifdef F_SETLK\n    case F_SETLK:\n# if F_SETLK\n# endif\n#endif\n\n#ifdef F_SETLKW\n    case F_SETLKW:\n# if F_SETLKW\n# endif\n#endif\n\n      ;\n    }\n}",
      "lines": 68,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        212,
        0
      ],
      "end_point": [
        413,
        1
      ],
      "content": "int\nmain (void)\n{\n  const char *file = \"test-fcntl.tmp\";\n  int fd;\n  int bad_fd = getdtablesize ();\n\n  /* Sanity check that rpl_fcntl is likely to work.  */\n  ASSERT (func2 (1, 2) == 2);\n  ASSERT (func2 (2, -2) == -2);\n  ASSERT (func2 (3, 0x80000000) == 0x80000000);\n  {\n    struct dummy_struct s = { 0L, 4 };\n    ASSERT (func2 (4, &s) == 4);\n  }\n  check_flags ();\n\n  /* Assume std descriptors were provided by invoker, and ignore fds\n     that might have been inherited.  */\n  fd = creat (file, 0600);\n  ASSERT (STDERR_FILENO < fd);\n  close (fd + 1);\n  close (fd + 2);\n\n  /* For F_DUPFD*, the source must be valid.  */\n  errno = 0;\n  ASSERT (fcntl (-1, F_DUPFD, 0) == -1);\n  ASSERT (errno == EBADF);\n  errno = 0;\n  ASSERT (fcntl (fd + 1, F_DUPFD, 0) == -1);\n  ASSERT (errno == EBADF);\n  errno = 0;\n  ASSERT (fcntl (bad_fd, F_DUPFD, 0) == -1);\n  ASSERT (errno == EBADF);\n  errno = 0;\n  ASSERT (fcntl (-1, F_DUPFD_CLOEXEC, 0) == -1);\n  ASSERT (errno == EBADF);\n  errno = 0;\n  ASSERT (fcntl (fd + 1, F_DUPFD_CLOEXEC, 0) == -1);\n  ASSERT (errno == EBADF);\n  errno = 0;\n  ASSERT (fcntl (bad_fd, F_DUPFD_CLOEXEC, 0) == -1);\n  ASSERT (errno == EBADF);\n\n  /* For F_DUPFD*, the destination must be valid.  */\n  errno = 0;\n  ASSERT (fcntl (fd, F_DUPFD, -1) == -1);\n  ASSERT (errno == EINVAL);\n  errno = 0;\n  ASSERT (fcntl (fd, F_DUPFD, bad_fd) == -1);\n  ASSERT (errno == EINVAL);\n  errno = 0;\n  ASSERT (fcntl (fd, F_DUPFD_CLOEXEC, -1) == -1);\n  ASSERT (errno == EINVAL);\n  errno = 0;\n  ASSERT (fcntl (fd, F_DUPFD_CLOEXEC, bad_fd) == -1);\n  ASSERT (errno == EINVAL\n          || errno == EMFILE /* WSL */);\n\n  /* For F_DUPFD*, check for correct inheritance, as well as\n     preservation of text vs. binary.  */\n  setmode (fd, O_BINARY);\n  ASSERT (is_open (fd));\n  ASSERT (!is_open (fd + 1));\n  ASSERT (!is_open (fd + 2));\n  ASSERT (is_inheritable (fd));\n  ASSERT (is_mode (fd, O_BINARY));\n\n  ASSERT (fcntl (fd, F_DUPFD, fd) == fd + 1);\n  ASSERT (is_open (fd));\n  ASSERT (is_open (fd + 1));\n  ASSERT (!is_open (fd + 2));\n  ASSERT (is_inheritable (fd + 1));\n  ASSERT (is_mode (fd, O_BINARY));\n  ASSERT (is_mode (fd + 1, O_BINARY));\n  ASSERT (close (fd + 1) == 0);\n\n  ASSERT (fcntl (fd, F_DUPFD_CLOEXEC, fd + 2) == fd + 2);\n  ASSERT (is_open (fd));\n  ASSERT (!is_open (fd + 1));\n  ASSERT (is_open (fd + 2));\n  ASSERT (is_inheritable (fd));\n  ASSERT (!is_inheritable (fd + 2));\n  ASSERT (is_mode (fd, O_BINARY));\n  ASSERT (is_mode (fd + 2, O_BINARY));\n  ASSERT (close (fd) == 0);\n\n  setmode (fd + 2, O_TEXT);\n  ASSERT (fcntl (fd + 2, F_DUPFD, fd + 1) == fd + 1);\n  ASSERT (!is_open (fd));\n  ASSERT (is_open (fd + 1));\n  ASSERT (is_open (fd + 2));\n  ASSERT (is_inheritable (fd + 1));\n  ASSERT (!is_inheritable (fd + 2));\n  ASSERT (is_mode (fd + 1, O_TEXT));\n  ASSERT (is_mode (fd + 2, O_TEXT));\n  ASSERT (close (fd + 1) == 0);\n\n  ASSERT (fcntl (fd + 2, F_DUPFD_CLOEXEC, 0) == fd);\n  ASSERT (is_open (fd));\n  ASSERT (!is_open (fd + 1));\n  ASSERT (is_open (fd + 2));\n  ASSERT (!is_inheritable (fd));\n  ASSERT (!is_inheritable (fd + 2));\n  ASSERT (is_mode (fd, O_TEXT));\n  ASSERT (is_mode (fd + 2, O_TEXT));\n  ASSERT (close (fd + 2) == 0);\n\n  /* Test F_GETFD on invalid file descriptors.  */\n  errno = 0;\n  ASSERT (fcntl (-1, F_GETFD) == -1);\n  ASSERT (errno == EBADF);\n  errno = 0;\n  ASSERT (fcntl (fd + 1, F_GETFD) == -1);\n  ASSERT (errno == EBADF);\n  errno = 0;\n  ASSERT (fcntl (bad_fd, F_GETFD) == -1);\n  ASSERT (errno == EBADF);\n\n  /* Test F_GETFD, the FD_CLOEXEC bit.  */\n  {\n    int result = fcntl (fd, F_GETFD);\n    ASSERT (0 <= result);\n    ASSERT ((result & FD_CLOEXEC) == FD_CLOEXEC);\n    ASSERT (dup (fd) == fd + 1);\n    result = fcntl (fd + 1, F_GETFD);\n    ASSERT (0 <= result);\n    ASSERT ((result & FD_CLOEXEC) == 0);\n    ASSERT (close (fd + 1) == 0);\n  }\n\n#ifdef F_SETFD\n  /* Test F_SETFD on invalid file descriptors.  */\n  errno = 0;\n  ASSERT (fcntl (-1, F_SETFD, 0) == -1);\n  ASSERT (errno == EBADF);\n  errno = 0;\n  ASSERT (fcntl (fd + 1, F_SETFD, 0) == -1);\n  ASSERT (errno == EBADF);\n  errno = 0;\n  ASSERT (fcntl (bad_fd, F_SETFD, 0) == -1);\n  ASSERT (errno == EBADF);\n#endif\n\n#ifdef F_GETFL\n  /* Test F_GETFL on invalid file descriptors.  */\n  errno = 0;\n  ASSERT (fcntl (-1, F_GETFL) == -1);\n  ASSERT (errno == EBADF);\n  errno = 0;\n  ASSERT (fcntl (fd + 1, F_GETFL) == -1);\n  ASSERT (errno == EBADF);\n  errno = 0;\n  ASSERT (fcntl (bad_fd, F_GETFL) == -1);\n  ASSERT (errno == EBADF);\n#endif\n\n#ifdef F_SETFL\n  /* Test F_SETFL on invalid file descriptors.  */\n  errno = 0;\n  ASSERT (fcntl (-1, F_SETFL, 0) == -1);\n  ASSERT (errno == EBADF);\n  errno = 0;\n  ASSERT (fcntl (fd + 1, F_SETFL, 0) == -1);\n  ASSERT (errno == EBADF);\n  errno = 0;\n  ASSERT (fcntl (bad_fd, F_SETFL, 0) == -1);\n  ASSERT (errno == EBADF);\n#endif\n\n#ifdef F_GETOWN\n  /* Test F_GETOWN on invalid file descriptors.  */\n  errno = 0;\n  ASSERT (fcntl (-1, F_GETOWN) == -1);\n  ASSERT (errno == EBADF);\n  errno = 0;\n  ASSERT (fcntl (fd + 1, F_GETOWN) == -1);\n  ASSERT (errno == EBADF);\n  errno = 0;\n  ASSERT (fcntl (bad_fd, F_GETOWN) == -1);\n  ASSERT (errno == EBADF);\n#endif\n\n#ifdef F_SETOWN\n  /* Test F_SETFL on invalid file descriptors.  */\n  errno = 0;\n  ASSERT (fcntl (-1, F_SETOWN, 0) == -1);\n  ASSERT (errno == EBADF);\n  errno = 0;\n  ASSERT (fcntl (fd + 1, F_SETOWN, 0) == -1);\n  ASSERT (errno == EBADF);\n  errno = 0;\n  ASSERT (fcntl (bad_fd, F_SETOWN, 0) == -1);\n  ASSERT (errno == EBADF);\n#endif\n\n  /* Cleanup.  */\n  ASSERT (close (fd) == 0);\n  ASSERT (unlink (file) == 0);\n\n  return 0;\n}",
      "lines": 202,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-fdopen.c": {
    "main": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "int\nmain (void)\n{\n  /* Test behavior on failure.  POSIX makes it hard to check for\n     failure, since the behavior is not well-defined on invalid file\n     descriptors, so try fdopen 1000 times and if that's not enough to\n     fail due to EMFILE, so be it.  */\n\n  int i;\n  for (i = 0; i < 1000; i++)\n    {\n      errno = 0;\n      if (! fdopen (STDOUT_FILENO, \"w\"))\n        {\n          ASSERT (errno != 0);\n          break;\n        }\n    }\n\n  return 0;\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-fflush.c": {
    "main": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        190,
        1
      ],
      "content": "int\nmain (void)\n{\n  FILE *f;\n  char buffer[10];\n  int fd;\n\n  /* Create test file.  */\n  f = fopen (\"test-fflush.txt\", \"w\");\n  if (!f || fwrite (\"1234567890ABCDEFG\", 1, 17, f) != 17 || fclose (f) != 0)\n    {\n      fputs (\"Failed to create sample file.\\n\", stderr);\n      unlink (\"test-fflush.txt\");\n      return 1;\n    }\n\n  /* Test fflush.  */\n  f = fopen (\"test-fflush.txt\", \"r\");\n  ASSERT (f != NULL);\n  fd = fileno (f);\n  if (!f || 0 > fd || fread (buffer, 1, 5, f) != 5)\n    {\n      fputs (\"Failed initial read of sample file.\\n\", stderr);\n      if (f)\n        fclose (f);\n      unlink (\"test-fflush.txt\");\n      return 1;\n    }\n  /* For deterministic results, ensure f read a bigger buffer.\n     This is not the case on BeOS, nor on uClibc.  */\n#if !(defined __BEOS__ || defined __UCLIBC__)\n  if (lseek (fd, 0, SEEK_CUR) == 5)\n    {\n      fputs (\"Sample file was not buffered after fread.\\n\", stderr);\n      fclose (f);\n      unlink (\"test-fflush.txt\");\n      return 1;\n    }\n#endif\n  /* POSIX requires fflush-fseek to set file offset of fd.  */\n  if (fflush (f) != 0 || fseeko (f, 0, SEEK_CUR) != 0)\n    {\n      fputs (\"Failed to flush-fseek sample file.\\n\", stderr);\n      fclose (f);\n      unlink (\"test-fflush.txt\");\n      return 1;\n    }\n  /* Check that offset is correct.  */\n  if (lseek (fd, 0, SEEK_CUR) != 5)\n    {\n      fprintf (stderr, \"File offset is wrong after fseek: %ld.\\n\",\n               (long) lseek (fd, 0, SEEK_CUR));\n      fclose (f);\n      unlink (\"test-fflush.txt\");\n      return 1;\n    }\n  if (ftell (f) != 5)\n    {\n      fprintf (stderr, \"ftell result is wrong after fseek: %ld.\\n\",\n               (long) ftell (f));\n      fclose (f);\n      unlink (\"test-fflush.txt\");\n      return 1;\n    }\n  /* Check that file reading resumes at correct location.  */\n  if (fgetc (f) != '6')\n    {\n      fputs (\"Failed to read next byte after fseek.\\n\", stderr);\n      fclose (f);\n      unlink (\"test-fflush.txt\");\n      return 1;\n    }\n  /* For deterministic results, ensure f read a bigger buffer.  */\n  if (lseek (fd, 0, SEEK_CUR) == 6)\n    {\n      fputs (\"Sample file was not buffered after fgetc.\\n\", stderr);\n      fclose (f);\n      unlink (\"test-fflush.txt\");\n      return 1;\n    }\n  /* POSIX requires fflush-fseeko to set file offset of fd.  */\n  if (fflush (f) != 0 || fseeko (f, 0, SEEK_CUR) != 0)\n    {\n      fputs (\"Failed to flush-fseeko sample file.\\n\", stderr);\n      fclose (f);\n      unlink (\"test-fflush.txt\");\n      return 1;\n    }\n  /* Check that offset is correct.  */\n  if (lseek (fd, 0, SEEK_CUR) != 6)\n    {\n      fprintf (stderr, \"File offset is wrong after fseeko: %ld.\\n\",\n               (long) lseek (fd, 0, SEEK_CUR));\n      fclose (f);\n      unlink (\"test-fflush.txt\");\n      return 1;\n    }\n  if (ftell (f) != 6)\n    {\n      fprintf (stderr, \"ftell result is wrong after fseeko: %ld.\\n\",\n               (long) ftell (f));\n      fclose (f);\n      unlink (\"test-fflush.txt\");\n      return 1;\n    }\n  /* Check that file reading resumes at correct location.  */\n  if (fgetc (f) != '7')\n    {\n      fputs (\"Failed to read next byte after fseeko.\\n\", stderr);\n      fclose (f);\n      unlink (\"test-fflush.txt\");\n      return 1;\n    }\n  fclose (f);\n\n  /* Test that fflush() sets errno if someone else closes the stream\n     fd behind the back of stdio.  */\n  {\n    FILE *fp = fopen (\"test-fflush.txt\", \"w\");\n    ASSERT (fp != NULL);\n    fputc ('x', fp);\n    ASSERT (close (fileno (fp)) == 0);\n    errno = 0;\n    ASSERT (fflush (fp) == EOF);\n    ASSERT (errno == EBADF);\n    fclose (fp);\n  }\n\n  /* Test that fflush() sets errno if the stream was constructed with\n     an invalid file descriptor.  */\n  {\n    FILE *fp = fdopen (-1, \"w\");\n    if (fp != NULL)\n      {\n        fputc ('x', fp);\n        errno = 0;\n        ASSERT (fflush (fp) == EOF);\n        ASSERT (errno == EBADF);\n      }\n  }\n  {\n    FILE *fp;\n    close (99);\n    fp = fdopen (99, \"w\");\n    if (fp != NULL)\n      {\n        fputc ('x', fp);\n        errno = 0;\n        ASSERT (fflush (fp) == EOF);\n        ASSERT (errno == EBADF);\n      }\n  }\n\n  /* Clean up.  */\n  unlink (\"test-fflush.txt\");\n\n  return 0;\n}",
      "lines": 158,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-fflush2.c": {
    "main": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  int c;\n\n  /* Avoid the well-known bugs of fflush() on streams in O_TEXT mode\n     on native Windows platforms.  */\n  set_binary_mode (0, O_BINARY);\n\n  if (argc > 1)\n    switch (argv[1][0])\n      {\n      case '1':\n        /* Check fflush after a backup ungetc() call.  This is case 1a in\n           terms of\n           <https://lists.gnu.org/r/bug-gnulib/2008-03/msg00131.html>,\n           according to the Austin Group's resolution on 2009-01-08.  */\n\n        c = fgetc (stdin);\n        ASSERT (c == '#');\n\n        c = fgetc (stdin);\n        ASSERT (c == '!');\n\n        /* Here the file-position indicator must be 2.  */\n\n        c = ungetc ('!', stdin);\n        ASSERT (c == '!');\n\n        fflush (stdin);\n\n        /* Here the file-position indicator must be 1.  */\n\n        c = fgetc (stdin);\n        ASSERT (c == '!');\n\n        c = fgetc (stdin);\n        ASSERT (c == '/');\n\n        return 0;\n\n      case '2':\n        /* Check fflush after a non-backup ungetc() call.  This is case 2a in\n           terms of\n           <https://lists.gnu.org/r/bug-gnulib/2008-03/msg00131.html>,\n           according to the Austin Group's resolution on 2009-01-08.  */\n        /* Check that fflush after a non-backup ungetc() call discards the\n           ungetc buffer.  This is mandated by POSIX\n           <http://www.opengroup.org/susv3/functions/ungetc.html>:\n             \"The value of the file-position indicator for the stream after\n              reading or discarding all pushed-back bytes shall be the same\n              as it was before the bytes were pushed back.\"\n           <http://www.opengroup.org/austin/aardvark/latest/xshbug3.txt>\n             \"[After fflush(),] the file offset of the underlying open file\n              description shall be set to the file position of the stream, and\n              any characters pushed back onto the stream by ungetc() or\n              ungetwc() that have not subsequently been read from the stream\n              shall be discarded.\"  */\n\n        c = fgetc (stdin);\n        ASSERT (c == '#');\n\n        c = fgetc (stdin);\n        ASSERT (c == '!');\n\n        /* Here the file-position indicator must be 2.  */\n\n        c = ungetc ('@', stdin);\n        ASSERT (c == '@');\n\n        fflush (stdin);\n\n        /* Here the file-position indicator must be 1.  */\n\n        c = fgetc (stdin);\n        ASSERT (c == '!');\n\n        c = fgetc (stdin);\n        ASSERT (c == '/');\n\n        return 0;\n      }\n\n  return 1;\n}",
      "lines": 85,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-fgetc.c": {
    "main": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        98,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  const char *filename = \"test-fgetc.txt\";\n\n  /* We don't have an fgetc() function that installs an invalid parameter\n     handler so far.  So install that handler here, explicitly.  */\n#if HAVE_MSVC_INVALID_PARAMETER_HANDLER \\\n    && MSVC_INVALID_PARAMETER_HANDLING == DEFAULT_HANDLING\n  gl_msvc_inval_ensure_handler ();\n#endif\n\n  /* Prepare a file.  */\n  {\n    const char text[] = \"hello world\";\n    int fd = open (filename, O_RDWR | O_CREAT | O_TRUNC, 0600);\n    ASSERT (fd >= 0);\n    ASSERT (write (fd, text, sizeof (text)) == sizeof (text));\n    ASSERT (close (fd) == 0);\n  }\n\n  /* Test that fgetc() sets errno if someone else closes the stream\n     fd behind the back of stdio.  */\n  {\n    FILE *fp = fopen (filename, \"r\");\n    ASSERT (fp != NULL);\n    ASSERT (close (fileno (fp)) == 0);\n    errno = 0;\n    ASSERT (fgetc (fp) == EOF);\n    ASSERT (errno == EBADF);\n    ASSERT (ferror (fp));\n    fclose (fp);\n  }\n\n  /* Test that fgetc() sets errno if the stream was constructed with\n     an invalid file descriptor.  */\n  {\n    FILE *fp = fdopen (-1, \"r\");\n    if (fp != NULL)\n      {\n        errno = 0;\n        ASSERT (fgetc (fp) == EOF);\n        ASSERT (errno == EBADF);\n        ASSERT (ferror (fp));\n        fclose (fp);\n      }\n  }\n  {\n    FILE *fp;\n    close (99);\n    fp = fdopen (99, \"r\");\n    if (fp != NULL)\n      {\n        errno = 0;\n        ASSERT (fgetc (fp) == EOF);\n        ASSERT (errno == EBADF);\n        ASSERT (ferror (fp));\n        fclose (fp);\n      }\n  }\n\n  /* Clean up.  */\n  unlink (filename);\n\n  return 0;\n}",
      "lines": 66,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-file-has-acl.c": {
    "main": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        73,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  const char *file;\n  struct stat statbuf;\n\n  ASSERT (argc == 2);\n\n  file = argv[1];\n\n  if (stat (file, &statbuf) < 0)\n    {\n      fprintf (stderr, \"could not access file \\\"%s\\\"\\n\", file);\n      exit (EXIT_FAILURE);\n    }\n\n  /* Check against possible infinite loop in file_has_acl.  */\n#if HAVE_DECL_ALARM\n  /* Declare failure if test takes too long, by using default abort\n     caused by SIGALRM.  */\n  {\n    int alarm_value = 5;\n    signal (SIGALRM, SIG_DFL);\n    alarm (alarm_value);\n  }\n#endif\n\n#if USE_ACL\n  {\n    int ret = file_has_acl (file, &statbuf);\n    if (ret < 0)\n      {\n        fprintf (stderr, \"could not access the ACL of file \\\"%s\\\"\\n\", file);\n        exit (EXIT_FAILURE);\n      }\n    printf (\"%s\\n\", ret ? \"yes\" : \"no\");\n  }\n#else\n  printf (\"no\\n\");\n#endif\n\n  return 0;\n}",
      "lines": 43,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-fpending.c": {
    "main": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "int\nmain (void)\n{\n  ASSERT (__fpending (stdout) == 0);\n\n  fputs (\"foo\", stdout);\n  ASSERT (__fpending (stdout) == 3);\n\n  fflush (stdout);\n  ASSERT (__fpending (stdout) == 0);\n\n  exit (0);\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-fpurge.c": {
    "main": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        133,
        1
      ],
      "content": "int\nmain (void)\n{\n  int check_filepos;\n\n  for (check_filepos = 0; check_filepos <= 1; check_filepos++)\n    {\n      FILE *fp;\n\n      /* Create a file with some contents.  */\n      fp = fopen (TESTFILE, \"w\");\n      if (fp == NULL)\n        goto skip;\n      if (fwrite (\"foobarsh\", 1, 8, fp) < 8)\n        goto skip;\n      if (fclose (fp))\n        goto skip;\n\n      /* The file's contents is now \"foobarsh\".  */\n\n      /* Open it in read-write mode.  */\n      fp = fopen (TESTFILE, \"r+\");\n      if (fp == NULL)\n        goto skip;\n      if (fseek (fp, 3, SEEK_CUR))\n        goto skip;\n      if (fwrite (\"g\", 1, 1, fp) < 1)\n        goto skip;\n      if (fflush (fp))\n        goto skip;\n      if (fwrite (\"bz\", 1, 2, fp) < 2)\n        goto skip;\n      /* Discard pending write.  */\n      ASSERT (fpurge (fp) == 0);\n      /* Verify that when discarding pending output, the file position is set\n         back to where it was before the write calls.  */\n      if (check_filepos)\n        ASSERT (ftell (fp) == 4);\n      ASSERT (fclose (fp) == 0);\n\n      /* Open it in read-only mode.  */\n      fp = fopen (TESTFILE, \"r\");\n      if (fp == NULL)\n        goto skip;\n      /* Verify that the pending writes before the fpurge were really\n         discarded.  */\n      {\n        char buf[8];\n        if (fread (buf, 1, 7, fp) < 7)\n          goto skip;\n        ASSERT (memcmp (buf, \"foogars\", 7) == 0);\n      }\n      /* Discard the buffered 'h'.  */\n      if (check_filepos)\n        ASSERT (ftell (fp) == 7);\n      ASSERT (fpurge (fp) == 0);\n      /* Verify that when discarding pending input, the file position is\n         advanced to match the end of the previously read input.  */\n      if (check_filepos)\n        ASSERT (ftell (fp) == 8);\n      ASSERT (getc (fp) == EOF);\n      ASSERT (fclose (fp) == 0);\n\n      /* The file's contents is now \"foogarsh\".  */\n\n      /* Ensure that purging a read does not corrupt subsequent writes.  */\n      fp = fopen (TESTFILE, \"r+\");\n      if (fp == NULL)\n        goto skip;\n      if (fseek (fp, -1, SEEK_END))\n        goto skip;\n      ASSERT (getc (fp) == 'h');\n      ASSERT (getc (fp) == EOF);\n      if (check_filepos)\n        ASSERT (ftell (fp) == 8);\n      ASSERT (fpurge (fp) == 0);\n      if (check_filepos)\n        ASSERT (ftell (fp) == 8);\n      ASSERT (putc ('!', fp) == '!');\n      if (check_filepos)\n        ASSERT (ftell (fp) == 9);\n      ASSERT (fclose (fp) == 0);\n      fp = fopen (TESTFILE, \"r\");\n      if (fp == NULL)\n        goto skip;\n      {\n        char buf[10];\n        ASSERT (fread (buf, 1, 10, fp) == 9);\n        ASSERT (memcmp (buf, \"foogarsh!\", 9) == 0);\n      }\n      ASSERT (fclose (fp) == 0);\n\n      /* The file's contents is now \"foogarsh!\".  */\n    }\n\n  remove (TESTFILE);\n  return 0;\n\n skip:\n  fprintf (stderr, \"Skipping test: prerequisite file operations failed.\\n\");\n  remove (TESTFILE);\n  return 77;\n}",
      "lines": 103,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-fputc.c": {
    "main": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        92,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  const char *filename = \"test-fputc.txt\";\n\n  /* We don't have an fputc() function that installs an invalid parameter\n     handler so far.  So install that handler here, explicitly.  */\n#if HAVE_MSVC_INVALID_PARAMETER_HANDLER \\\n    && MSVC_INVALID_PARAMETER_HANDLING == DEFAULT_HANDLING\n  gl_msvc_inval_ensure_handler ();\n#endif\n\n  /* Test that fputc() on an unbuffered stream sets errno if someone else\n     closes the stream fd behind the back of stdio.  */\n  {\n    FILE *fp = fopen (filename, \"w\");\n    ASSERT (fp != NULL);\n    setvbuf (fp, NULL, _IONBF, 0);\n    ASSERT (close (fileno (fp)) == 0);\n    errno = 0;\n    ASSERT (fputc ('x', fp) == EOF);\n    ASSERT (errno == EBADF);\n    ASSERT (ferror (fp));\n    fclose (fp);\n  }\n\n  /* Test that fputc() on an unbuffered stream sets errno if the stream\n     was constructed with an invalid file descriptor.  */\n  {\n    FILE *fp = fdopen (-1, \"w\");\n    if (fp != NULL)\n      {\n        setvbuf (fp, NULL, _IONBF, 0);\n        errno = 0;\n        ASSERT (fputc ('x', fp) == EOF);\n        ASSERT (errno == EBADF);\n        ASSERT (ferror (fp));\n        fclose (fp);\n      }\n  }\n  {\n    FILE *fp;\n    close (99);\n    fp = fdopen (99, \"w\");\n    if (fp != NULL)\n      {\n        setvbuf (fp, NULL, _IONBF, 0);\n        errno = 0;\n        ASSERT (fputc ('x', fp) == EOF);\n        ASSERT (errno == EBADF);\n        ASSERT (ferror (fp));\n        fclose (fp);\n      }\n  }\n\n  /* Clean up.  */\n  unlink (filename);\n\n  return 0;\n}",
      "lines": 60,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-fread.c": {
    "main": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        101,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  const char *filename = \"test-fread.txt\";\n\n  /* We don't have an fread() function that installs an invalid parameter\n     handler so far.  So install that handler here, explicitly.  */\n#if HAVE_MSVC_INVALID_PARAMETER_HANDLER \\\n    && MSVC_INVALID_PARAMETER_HANDLING == DEFAULT_HANDLING\n  gl_msvc_inval_ensure_handler ();\n#endif\n\n  /* Prepare a file.  */\n  {\n    const char text[] = \"hello world\";\n    int fd = open (filename, O_RDWR | O_CREAT | O_TRUNC, 0600);\n    ASSERT (fd >= 0);\n    ASSERT (write (fd, text, sizeof (text)) == sizeof (text));\n    ASSERT (close (fd) == 0);\n  }\n\n  /* Test that fread() sets errno if someone else closes the stream\n     fd behind the back of stdio.  */\n  {\n    FILE *fp = fopen (filename, \"r\");\n    char buf[5];\n    ASSERT (fp != NULL);\n    ASSERT (close (fileno (fp)) == 0);\n    errno = 0;\n    ASSERT (fread (buf, 1, sizeof (buf), fp) == 0);\n    ASSERT (errno == EBADF);\n    ASSERT (ferror (fp));\n    fclose (fp);\n  }\n\n  /* Test that fread() sets errno if the stream was constructed with\n     an invalid file descriptor.  */\n  {\n    FILE *fp = fdopen (-1, \"r\");\n    if (fp != NULL)\n      {\n        char buf[1];\n        errno = 0;\n        ASSERT (fread (buf, 1, 1, fp) == 0);\n        ASSERT (errno == EBADF);\n        ASSERT (ferror (fp));\n        fclose (fp);\n      }\n  }\n  {\n    FILE *fp;\n    close (99);\n    fp = fdopen (99, \"r\");\n    if (fp != NULL)\n      {\n        char buf[1];\n        errno = 0;\n        ASSERT (fread (buf, 1, 1, fp) == 0);\n        ASSERT (errno == EBADF);\n        ASSERT (ferror (fp));\n        fclose (fp);\n      }\n  }\n\n  /* Clean up.  */\n  unlink (filename);\n\n  return 0;\n}",
      "lines": 69,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-freading.c": {
    "main": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        129,
        1
      ],
      "content": "int\nmain (void)\n{\n  FILE *fp;\n\n  /* Create a file with some contents.  Write-only file is never reading.  */\n  fp = fopen (TESTFILE, \"w\");\n  ASSERT (fp);\n  ASSERT (!freading (fp));\n  ASSERT (fwrite (\"foobarsh\", 1, 8, fp) == 8);\n  ASSERT (!freading (fp));\n  ASSERT (fclose (fp) == 0);\n\n  /* Open it in read-only mode.  Read-only file is always reading.  */\n  fp = fopen (TESTFILE, \"r\");\n  ASSERT (fp);\n  ASSERT (freading (fp));\n  ASSERT (fgetc (fp) == 'f');\n  ASSERT (freading (fp));\n  ASSERT (fseek (fp, 2, SEEK_CUR) == 0);\n  ASSERT (freading (fp));\n  ASSERT (fgetc (fp) == 'b');\n  ASSERT (freading (fp));\n  fflush (fp);\n  ASSERT (freading (fp));\n  ASSERT (fgetc (fp) == 'a');\n  ASSERT (freading (fp));\n  ASSERT (fseek (fp, 0, SEEK_END) == 0);\n  ASSERT (freading (fp));\n  ASSERT (fclose (fp) == 0);\n\n  /* Open it in read-write mode.  POSIX requires a reposition (fseek,\n     fsetpos, rewind) or EOF when transitioning from read to write;\n     freading is only deterministic after input or output, but this\n     test case should be portable even on open, after reposition, and\n     at EOF.  */\n  /* First a scenario with only fgetc, fseek, fputc.  */\n  fp = fopen (TESTFILE, \"r+\");\n  ASSERT (fp);\n  ASSERT (!freading (fp));\n  ASSERT (fgetc (fp) == 'f');\n  ASSERT (freading (fp));\n  ASSERT (fseek (fp, 2, SEEK_CUR) ==  0);\n  /* freading (fp) is undefined here, but fwriting (fp) is false.  */\n  ASSERT (fgetc (fp) == 'b');\n  ASSERT (freading (fp));\n  /* This fseek call is necessary when switching from reading to writing.\n     See the description of fopen(), ISO C 99 7.19.5.3.(6).  */\n  ASSERT (fseek (fp, 0, SEEK_CUR) == 0);\n  /* freading (fp) is undefined here, but fwriting (fp) is false.  */\n  ASSERT (fputc ('x', fp) == 'x');\n  ASSERT (!freading (fp));\n  ASSERT (fseek (fp, 0, SEEK_END) == 0);\n  /* freading (fp) is undefined here, because on some implementations (e.g.\n     glibc) fseek causes a buffer to be read.\n     fwriting (fp) is undefined as well.  */\n  ASSERT (fclose (fp) == 0);\n\n  /* Open it in read-write mode.  POSIX requires a reposition (fseek,\n     fsetpos, rewind) or EOF when transitioning from read to write;\n     freading is only deterministic after input or output, but this\n     test case should be portable even on open, after reposition, and\n     at EOF.  */\n  /* Here a scenario that includes fflush.  */\n  fp = fopen (TESTFILE, \"r+\");\n  ASSERT (fp);\n  ASSERT (!freading (fp));\n  ASSERT (fgetc (fp) == 'f');\n  ASSERT (freading (fp));\n  ASSERT (fseek (fp, 2, SEEK_CUR) == 0);\n  /* freading (fp) is undefined here, but fwriting (fp) is false.  */\n  ASSERT (fgetc (fp) == 'b');\n  ASSERT (freading (fp));\n  fflush (fp);\n  /* freading (fp) is undefined here, but fwriting (fp) is false.  */\n  ASSERT (fgetc (fp) == 'x');\n  ASSERT (freading (fp));\n  /* This fseek call is necessary when switching from reading to writing.\n     See the description of fopen(), ISO C 99 7.19.5.3.(6).  */\n  ASSERT (fseek (fp, 0, SEEK_CUR) == 0);\n  /* freading (fp) is undefined here, but fwriting (fp) is false.  */\n  ASSERT (fputc ('z', fp) == 'z');\n  ASSERT (!freading (fp));\n  ASSERT (fseek (fp, 0, SEEK_END) == 0);\n  /* freading (fp) is undefined here, because on some implementations (e.g.\n     glibc) fseek causes a buffer to be read.\n     fwriting (fp) is undefined as well.  */\n  ASSERT (fclose (fp) == 0);\n\n  /* Open it in append mode.  Write-only file is never reading.  */\n  fp = fopen (TESTFILE, \"a\");\n  ASSERT (fp);\n  ASSERT (!freading (fp));\n  ASSERT (fwrite (\"bla\", 1, 3, fp) == 3);\n  ASSERT (!freading (fp));\n  ASSERT (fclose (fp) == 0);\n  ASSERT (remove (TESTFILE) == 0);\n  return 0;\n}",
      "lines": 99,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-fseek.c": {
    "main": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        69,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  /* Assume stdin is non-empty, seekable, and starts with '#!/bin/sh'\n     iff argc > 1.  */\n  int expected = argc > 1 ? 0 : -1;\n  ASSERT (fseek (stdin, 0, SEEK_CUR) == expected);\n  if (argc > 1)\n    {\n      /* Test that fseek discards previously read ungetc data.  */\n      int ch = fgetc (stdin);\n      ASSERT (ch == '#');\n      ASSERT (ungetc (ch, stdin) == ch);\n      ASSERT (fseek (stdin, 2, SEEK_SET) == 0);\n      ch = fgetc (stdin);\n      ASSERT (ch == '/');\n      if (2 < argc)\n        {\n          if (FUNC_UNGETC_BROKEN)\n            {\n              fputs (\"Skipping test: ungetc cannot handle arbitrary bytes\\n\",\n                     stderr);\n              return 77;\n            }\n          /* Test that fseek discards random ungetc data.  */\n          ASSERT (ungetc (ch ^ 0xff, stdin) == (ch ^ 0xff));\n        }\n      ASSERT (fseek (stdin, 0, SEEK_END) == 0);\n      ASSERT (fgetc (stdin) == EOF);\n      /* Test that fseek resets end-of-file marker.  */\n      ASSERT (feof (stdin));\n      ASSERT (fseek (stdin, 0, SEEK_END) == 0);\n      ASSERT (!feof (stdin));\n    }\n  return 0;\n}",
      "lines": 36,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-fseeko.c": {
    "main": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        73,
        1
      ],
      "content": "int\nmain (int argc, char **argv _GL_UNUSED)\n{\n  /* Assume stdin is non-empty, seekable, and starts with '#!/bin/sh'\n     iff argc > 1.  */\n  int expected = argc > 1 ? 0 : -1;\n  /* Exit with success only if fseek/fseeko agree.  */\n  int r1 = fseeko (stdin, 0, SEEK_CUR);\n  int r2 = fseek (stdin, 0, SEEK_CUR);\n  ASSERT (r1 == r2 && r1 == expected);\n  if (argc > 1)\n    {\n      /* Test that fseek discards previously read ungetc data.  */\n      int ch = fgetc (stdin);\n      ASSERT (ch == '#');\n      ASSERT (ungetc (ch, stdin) == ch);\n      ASSERT (fseeko (stdin, 2, SEEK_SET) == 0);\n      ch = fgetc (stdin);\n      ASSERT (ch == '/');\n      if (2 < argc)\n        {\n          if (FUNC_UNGETC_BROKEN)\n            {\n              fputs (\"Skipping test: ungetc cannot handle arbitrary bytes\\n\",\n                     stderr);\n              return 77;\n            }\n          /* Test that fseek discards random ungetc data.  */\n          ASSERT (ungetc (ch ^ 0xff, stdin) == (ch ^ 0xff));\n        }\n      ASSERT (fseeko (stdin, 0, SEEK_END) == 0);\n      ASSERT (fgetc (stdin) == EOF);\n      /* Test that fseek resets end-of-file marker.  */\n      ASSERT (feof (stdin));\n      ASSERT (fseeko (stdin, 0, SEEK_END) == 0);\n      ASSERT (!feof (stdin));\n    }\n  return 0;\n}",
      "lines": 39,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-fseeko3.c": {
    "main": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  int do_initial_ftell = atoi (argv[1]);\n  const char *filename = argv[2];\n  FILE *fp = fopen (filename, \"r\");\n  ASSERT (fp != NULL);\n\n  if (do_initial_ftell)\n    {\n      off_t pos = ftell (fp);\n      ASSERT (pos == 0);\n    }\n\n  ASSERT (fseeko (fp, 0, SEEK_END) == 0);\n\n  {\n    off_t pos = ftell (fp);\n    ASSERT (pos > 0);\n  }\n\n  ASSERT (fclose (fp) == 0);\n\n  return 0;\n}",
      "lines": 25,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-fseeko4.c": {
    "main": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  const char *filename = argv[1];\n\n  /* Test that fseeko() sets errno if someone else closes the stream\n     fd behind the back of stdio.  */\n  {\n    FILE *fp = fopen (filename, \"r\");\n    ASSERT (fp != NULL);\n    setvbuf (fp, NULL, _IONBF, 0);\n    ASSERT (ftell (fp) == 0);\n    ASSERT (fseeko (fp, 0, SEEK_END) == 0);\n    ASSERT (ftell (fp) > 0);\n    ASSERT (close (fileno (fp)) == 0);\n    errno = 0;\n    ASSERT (fseeko (fp, 0, SEEK_SET) == -1);\n    ASSERT (errno == EBADF);\n    fclose (fp);\n  }\n\n  /* Test that fseeko() sets errno if the stream was constructed with\n     an invalid file descriptor.  */\n  {\n    FILE *fp = fdopen (-1, \"w\");\n    if (fp != NULL)\n      {\n        errno = 0;\n        ASSERT (fseeko (fp, 0, SEEK_END) == -1);\n        ASSERT (errno == EBADF);\n        fclose (fp);\n      }\n  }\n  {\n    FILE *fp;\n    close (99);\n    fp = fdopen (99, \"w\");\n    if (fp != NULL)\n      {\n        errno = 0;\n        ASSERT (fseeko (fp, 0, SEEK_END) == -1);\n        ASSERT (errno == EBADF);\n        fclose (fp);\n      }\n  }\n\n  return 0;\n}",
      "lines": 48,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-fstat.c": {
    "main": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  /* Test behaviour for invalid file descriptors.  */\n  {\n    struct stat statbuf;\n\n    errno = 0;\n    ASSERT (fstat (-1, &statbuf) == -1);\n    ASSERT (errno == EBADF);\n  }\n  {\n    struct stat statbuf;\n\n    close (99);\n    errno = 0;\n    ASSERT (fstat (99, &statbuf) == -1);\n    ASSERT (errno == EBADF);\n  }\n\n  return 0;\n}",
      "lines": 22,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-ftell.c": {
    "main": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        106,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  int ch;\n  /* Assume stdin is seekable iff argc > 1.  */\n  if (argc == 1)\n    {\n      ASSERT (ftell (stdin) == -1);\n      return 0;\n    }\n\n  /* mingw ftell is unreliable on text mode input.  */\n  set_binary_mode (0, O_BINARY);\n\n  /* Simple tests.  */\n  ASSERT (ftell (stdin) == 0);\n\n  ch = fgetc (stdin);\n  ASSERT (ch == '#');\n  ASSERT (ftell (stdin) == 1);\n\n  /* Test ftell after ungetc of read input.  */\n  ch = ungetc ('#', stdin);\n  ASSERT (ch == '#');\n  ASSERT (ftell (stdin) == 0);\n\n  ch = fgetc (stdin);\n  ASSERT (ch == '#');\n  ASSERT (ftell (stdin) == 1);\n\n  /* Test ftell after fseek.  */\n  ASSERT (fseek (stdin, 2, SEEK_SET) == 0);\n  ASSERT (ftell (stdin) == 2);\n\n  /* Test ftell after random ungetc.  */\n  ch = fgetc (stdin);\n  ASSERT (ch == '/');\n  ch = ungetc ('@', stdin);\n  ASSERT (ch == '@');\n  ASSERT (ftell (stdin) == 2);\n\n  ch = fgetc (stdin);\n  ASSERT (ch == '@');\n  ASSERT (ftell (stdin) == 3);\n\n  if (2 < argc)\n    {\n      if (FUNC_UNGETC_BROKEN)\n        {\n          fputs (\"Skipping test: ungetc cannot handle arbitrary bytes\\n\",\n                 stderr);\n          return 77;\n        }\n      /* Test ftell after ungetc without read.  */\n      ASSERT (fseek (stdin, 0, SEEK_CUR) == 0);\n      ASSERT (ftell (stdin) == 3);\n\n      ch = ungetc ('~', stdin);\n      ASSERT (ch == '~');\n      ASSERT (ftell (stdin) == 2);\n    }\n\n#if !defined __MINT__ /* FreeMiNT has problems seeking past end of file */\n  /* Test ftell beyond end of file.  */\n  ASSERT (fseek (stdin, 0, SEEK_END) == 0);\n  ch = ftell (stdin);\n  ASSERT (fseek (stdin, 10, SEEK_END) == 0);\n  ASSERT (ftell (stdin) == ch + 10);\n#endif\n\n  return 0;\n}",
      "lines": 72,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-ftell3.c": {
    "main": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "int\nmain (void)\n{\n  FILE *fp;\n\n  /* Create a file with some contents.  */\n  fp = fopen (TESTFILE, \"w\");\n  if (fp == NULL)\n    goto skip;\n  if (fwrite (\"foogarsh\", 1, 8, fp) < 8)\n    goto skip;\n  if (fclose (fp))\n    goto skip;\n\n  /* The file's contents is now \"foogarsh\".  */\n\n  /* Try writing after reading to EOF.  */\n  fp = fopen (TESTFILE, \"r+\");\n  if (fp == NULL)\n    goto skip;\n  if (fseek (fp, -1, SEEK_END))\n    goto skip;\n  ASSERT (getc (fp) == 'h');\n  ASSERT (getc (fp) == EOF);\n  ASSERT (ftell (fp) == 8);\n  ASSERT (ftell (fp) == 8);\n  ASSERT (putc ('!', fp) == '!');\n  ASSERT (ftell (fp) == 9);\n  ASSERT (fclose (fp) == 0);\n  fp = fopen (TESTFILE, \"r\");\n  if (fp == NULL)\n    goto skip;\n  {\n    char buf[10];\n    ASSERT (fread (buf, 1, 10, fp) == 9);\n    ASSERT (memcmp (buf, \"foogarsh!\", 9) == 0);\n  }\n  ASSERT (fclose (fp) == 0);\n\n  /* The file's contents is now \"foogarsh!\".  */\n\n  remove (TESTFILE);\n  return 0;\n\n skip:\n  fprintf (stderr, \"Skipping test: prerequisite file operations failed.\\n\");\n  remove (TESTFILE);\n  return 77;\n}",
      "lines": 49,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-ftello.c": {
    "main": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        117,
        1
      ],
      "content": "int\nmain (int argc, char **argv _GL_UNUSED)\n{\n  int ch;\n  /* Assume stdin is seekable iff argc > 1.  */\n  if (argc == 1)\n    {\n      ASSERT (ftell (stdin) == -1);\n      ASSERT (ftello (stdin) == -1);\n      return 0;\n    }\n\n  /* mingw ftell is unreliable on text mode input.  */\n  set_binary_mode (0, O_BINARY);\n\n  /* Simple tests.  For each test, make sure ftell and ftello agree.  */\n  ASSERT (ftell (stdin) == 0);\n  ASSERT (ftello (stdin) == 0);\n\n  ch = fgetc (stdin);\n  ASSERT (ch == '#');\n  ASSERT (ftell (stdin) == 1);\n  ASSERT (ftello (stdin) == 1);\n\n  /* Test ftell after ungetc of read input.  */\n  ch = ungetc ('#', stdin);\n  ASSERT (ch == '#');\n  ASSERT (ftell (stdin) == 0);\n  ASSERT (ftello (stdin) == 0);\n\n  ch = fgetc (stdin);\n  ASSERT (ch == '#');\n  ASSERT (ftell (stdin) == 1);\n  ASSERT (ftello (stdin) == 1);\n\n  /* Test ftell after fseek.  */\n  ASSERT (fseek (stdin, 2, SEEK_SET) == 0);\n  ASSERT (ftell (stdin) == 2);\n  ASSERT (ftello (stdin) == 2);\n\n  /* Test ftell after random ungetc.  */\n  ch = fgetc (stdin);\n  ASSERT (ch == '/');\n  ch = ungetc ('@', stdin);\n  ASSERT (ch == '@');\n  ASSERT (ftell (stdin) == 2);\n  ASSERT (ftello (stdin) == 2);\n\n  ch = fgetc (stdin);\n  ASSERT (ch == '@');\n  ASSERT (ftell (stdin) == 3);\n  ASSERT (ftello (stdin) == 3);\n\n  if (2 < argc)\n    {\n      if (FUNC_UNGETC_BROKEN)\n        {\n          fputs (\"Skipping test: ungetc cannot handle arbitrary bytes\\n\",\n                 stderr);\n          return 77;\n        }\n      /* Test ftell after ungetc without read.  */\n      ASSERT (fseek (stdin, 0, SEEK_CUR) == 0);\n      ASSERT (ftell (stdin) == 3);\n      ASSERT (ftello (stdin) == 3);\n\n      ch = ungetc ('~', stdin);\n      ASSERT (ch == '~');\n      ASSERT (ftell (stdin) == 2);\n      ASSERT (ftello (stdin) == 2);\n    }\n\n#if !defined __MINT__ /* FreeMiNT has problems seeking past end of file */\n  /* Test ftell beyond end of file.  */\n  ASSERT (fseek (stdin, 0, SEEK_END) == 0);\n  ch = ftello (stdin);\n  ASSERT (fseek (stdin, 10, SEEK_END) == 0);\n  ASSERT (ftell (stdin) == ch + 10);\n  ASSERT (ftello (stdin) == ch + 10);\n#endif\n\n  return 0;\n}",
      "lines": 83,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-ftello3.c": {
    "main": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "int\nmain (void)\n{\n  FILE *fp;\n\n  /* Create a file with some contents.  */\n  fp = fopen (TESTFILE, \"w\");\n  if (fp == NULL)\n    goto skip;\n  if (fwrite (\"foogarsh\", 1, 8, fp) < 8)\n    goto skip;\n  if (fclose (fp))\n    goto skip;\n\n  /* The file's contents is now \"foogarsh\".  */\n\n  /* Try writing after reading to EOF.  */\n  fp = fopen (TESTFILE, \"r+\");\n  if (fp == NULL)\n    goto skip;\n  if (fseek (fp, -1, SEEK_END))\n    goto skip;\n  ASSERT (getc (fp) == 'h');\n  ASSERT (getc (fp) == EOF);\n  ASSERT (ftello (fp) == 8);\n  ASSERT (ftello (fp) == 8);\n  ASSERT (putc ('!', fp) == '!');\n  ASSERT (ftello (fp) == 9);\n  ASSERT (fclose (fp) == 0);\n  fp = fopen (TESTFILE, \"r\");\n  if (fp == NULL)\n    goto skip;\n  {\n    char buf[10];\n    ASSERT (fread (buf, 1, 10, fp) == 9);\n    ASSERT (memcmp (buf, \"foogarsh!\", 9) == 0);\n  }\n  ASSERT (fclose (fp) == 0);\n\n  /* The file's contents is now \"foogarsh!\".  */\n\n  remove (TESTFILE);\n  return 0;\n\n skip:\n  fprintf (stderr, \"Skipping test: prerequisite file operations failed.\\n\");\n  remove (TESTFILE);\n  return 77;\n}",
      "lines": 49,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-ftello4.c": {
    "main": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        69,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  const char *filename = argv[1];\n\n  /* Test that ftello() sets errno if someone else closes the stream\n     fd behind the back of stdio.  */\n  {\n    FILE *fp = fopen (filename, \"r\");\n    ASSERT (fp != NULL);\n    setvbuf (fp, NULL, _IONBF, 0);\n    ASSERT (close (fileno (fp)) == 0);\n    errno = 0;\n    ASSERT (ftello (fp) == (off_t)-1);\n    ASSERT (errno == EBADF);\n    fclose (fp);\n  }\n\n  /* Test that ftello() sets errno if the stream was constructed with\n     an invalid file descriptor.  */\n  {\n    FILE *fp = fdopen (-1, \"w\");\n    if (fp != NULL)\n      {\n        errno = 0;\n        ASSERT (ftello (fp) == (off_t)-1);\n        ASSERT (errno == EBADF);\n        fclose (fp);\n      }\n  }\n  {\n    FILE *fp;\n    close (99);\n    fp = fdopen (99, \"w\");\n    if (fp != NULL)\n      {\n        errno = 0;\n        ASSERT (ftello (fp) == (off_t)-1);\n        ASSERT (errno == EBADF);\n        fclose (fp);\n      }\n  }\n\n  return 0;\n}",
      "lines": 45,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-ftruncate.c": {
    "main": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  const char *filename = argv[1];\n\n  /* Test behaviour for invalid file descriptors.  */\n  {\n    errno = 0;\n    ASSERT (ftruncate (-1, 0) == -1);\n    ASSERT (errno == EBADF);\n  }\n  {\n    close (99);\n    errno = 0;\n    ASSERT (ftruncate (99, 0) == -1);\n    ASSERT (errno == EBADF);\n  }\n\n  /* Test behaviour for read-only file descriptors.  */\n  {\n    int fd = open (filename, O_RDONLY);\n    ASSERT (fd >= 0);\n    errno = 0;\n    ASSERT (ftruncate (fd, 0) == -1);\n    ASSERT (errno == EBADF || errno == EINVAL\n            || errno == EACCES /* seen on mingw */\n           );\n    close (fd);\n  }\n\n  return 0;\n}",
      "lines": 32,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-fwrite.c": {
    "main": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        95,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  const char *filename = \"test-fwrite.txt\";\n\n  /* We don't have an fwrite() function that installs an invalid parameter\n     handler so far.  So install that handler here, explicitly.  */\n#if HAVE_MSVC_INVALID_PARAMETER_HANDLER \\\n    && MSVC_INVALID_PARAMETER_HANDLING == DEFAULT_HANDLING\n  gl_msvc_inval_ensure_handler ();\n#endif\n\n  /* Test that fwrite() on an unbuffered stream sets errno if someone else\n     closes the stream fd behind the back of stdio.  */\n  {\n    FILE *fp = fopen (filename, \"w\");\n    char buf[5] = \"world\";\n    ASSERT (fp != NULL);\n    setvbuf (fp, NULL, _IONBF, 0);\n    ASSERT (close (fileno (fp)) == 0);\n    errno = 0;\n    ASSERT (fwrite (buf, 1, sizeof (buf), fp) == 0);\n    ASSERT (errno == EBADF);\n    ASSERT (ferror (fp));\n    fclose (fp);\n  }\n\n  /* Test that fwrite() on an unbuffered stream sets errno if the stream\n     was constructed with an invalid file descriptor.  */\n  {\n    FILE *fp = fdopen (-1, \"w\");\n    if (fp != NULL)\n      {\n        char buf[5] = \"world\";\n        setvbuf (fp, NULL, _IONBF, 0);\n        errno = 0;\n        ASSERT (fwrite (buf, 1, sizeof (buf), fp) == 0);\n        ASSERT (errno == EBADF);\n        ASSERT (ferror (fp));\n        fclose (fp);\n      }\n  }\n  {\n    FILE *fp;\n    close (99);\n    fp = fdopen (99, \"w\");\n    if (fp != NULL)\n      {\n        char buf[5] = \"world\";\n        setvbuf (fp, NULL, _IONBF, 0);\n        errno = 0;\n        ASSERT (fwrite (buf, 1, sizeof (buf), fp) == 0);\n        ASSERT (errno == EBADF);\n        ASSERT (ferror (fp));\n        fclose (fp);\n      }\n  }\n\n  /* Clean up.  */\n  unlink (filename);\n\n  return 0;\n}",
      "lines": 63,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-fwriting.c": {
    "main": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        163,
        1
      ],
      "content": "int\nmain ()\n{\n  FILE *fp;\n\n  /* Create a file with some contents.  Write-only file is always writing.  */\n  fp = fopen (TESTFILE, \"w\");\n  if (fp == NULL)\n    goto skip;\n  ASSERT (fwriting (fp));\n  if (fwrite (\"foobarsh\", 1, 8, fp) < 8)\n    goto skip;\n  ASSERT (fwriting (fp));\n  if (fclose (fp))\n    goto skip;\n\n  /* Open it in read-only mode.  Read-only file is never writing.  */\n  fp = fopen (TESTFILE, \"r\");\n  if (fp == NULL)\n    goto skip;\n  ASSERT (!fwriting (fp));\n  if (fgetc (fp) != 'f')\n    goto skip;\n  ASSERT (!fwriting (fp));\n  if (fseek (fp, 2, SEEK_CUR))\n    goto skip;\n  ASSERT (!fwriting (fp));\n  if (fgetc (fp) != 'b')\n    goto skip;\n  ASSERT (!fwriting (fp));\n  fflush (fp);\n  ASSERT (!fwriting (fp));\n  if (fgetc (fp) != 'a')\n    goto skip;\n  ASSERT (!fwriting (fp));\n  if (fseek (fp, 0, SEEK_END))\n    goto skip;\n  ASSERT (!fwriting (fp));\n  if (fclose (fp))\n    goto skip;\n\n  /* Open it in read-write mode.  POSIX requires a reposition (fseek,\n     fsetpos, rewind) or fflush when transitioning from write to read,\n     fwriting is only deterministic after input or output, but this\n     test case should be portable even on open, after reposition, and\n     after fflush.  */\n  /* First a scenario with only fgetc, fseek, fputc.  */\n  fp = fopen (TESTFILE, \"r+\");\n  if (fp == NULL)\n    goto skip;\n  ASSERT (!fwriting (fp));\n  if (fgetc (fp) != 'f')\n    goto skip;\n  ASSERT (!fwriting (fp));\n  if (fseek (fp, 2, SEEK_CUR))\n    goto skip;\n  ASSERT (!fwriting (fp));\n  if (fgetc (fp) != 'b')\n    goto skip;\n  ASSERT (!fwriting (fp));\n  /* This fseek call is necessary when switching from reading to writing.\n     See the description of fopen(), ISO C 99 7.19.5.3.(6).  */\n  if (fseek (fp, 0, SEEK_CUR) != 0)\n    goto skip;\n  ASSERT (!fwriting (fp));\n  if (fputc ('x', fp) != 'x')\n    goto skip;\n  ASSERT (fwriting (fp));\n  if (fseek (fp, 0, SEEK_END))\n    goto skip;\n  /* freading (fp) is undefined here, because on some implementations (e.g.\n     glibc) fseek causes a buffer to be read.\n     fwriting (fp) is undefined as well.  */\n  if (fclose (fp))\n    goto skip;\n\n  /* Open it in read-write mode.  POSIX requires a reposition (fseek,\n     fsetpos, rewind) or fflush when transitioning from write to read,\n     fwriting is only deterministic after input or output, but this\n     test case should be portable even on open, after reposition, and\n     after fflush.  */\n  /* Here a scenario that includes fflush.  */\n  fp = fopen (TESTFILE, \"r+\");\n  if (fp == NULL)\n    goto skip;\n  ASSERT (!fwriting (fp));\n  if (fgetc (fp) != 'f')\n    goto skip;\n  ASSERT (!fwriting (fp));\n  if (fseek (fp, 2, SEEK_CUR))\n    goto skip;\n  ASSERT (!fwriting (fp));\n  if (fgetc (fp) != 'b')\n    goto skip;\n  ASSERT (!fwriting (fp));\n  fflush (fp);\n  ASSERT (!fwriting (fp));\n  if (fgetc (fp) != 'x')\n    goto skip;\n  ASSERT (!fwriting (fp));\n  /* This fseek call is necessary when switching from reading to writing.\n     See the description of fopen(), ISO C 99 7.19.5.3.(6).  */\n  if (fseek (fp, 0, SEEK_CUR) != 0)\n    goto skip;\n  ASSERT (!fwriting (fp));\n  if (fputc ('z', fp) != 'z')\n    goto skip;\n  ASSERT (fwriting (fp));\n  if (fseek (fp, 0, SEEK_END))\n    goto skip;\n  /* freading (fp) is undefined here, because on some implementations (e.g.\n     glibc) fseek causes a buffer to be read.\n     fwriting (fp) is undefined as well.  */\n  if (fclose (fp))\n    goto skip;\n\n  /* Open it in append mode.  */\n  fp = fopen (TESTFILE, \"a\");\n  if (fp == NULL)\n    goto skip;\n  ASSERT (fwriting (fp));\n  if (fwrite (\"bla\", 1, 3, fp) < 3)\n    goto skip;\n  ASSERT (fwriting (fp));\n  if (fclose (fp))\n    goto skip;\n\n  return 0;\n\n skip:\n  fprintf (stderr, \"Skipping test: file operations failed.\\n\");\n  return 77;\n}",
      "lines": 133,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-getcwd-lgpl.c": {
    "main": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        101,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  char *pwd1;\n  char *pwd2;\n  /* If the user provides an argument, attempt to chdir there first.  */\n  if (1 < argc)\n    {\n      if (chdir (argv[1]) == 0)\n        printf (\"changed to directory %s\\n\", argv[1]);\n    }\n\n  pwd1 = getcwd (NULL, 0);\n  ASSERT (pwd1 && *pwd1);\n  if (1 < argc)\n    printf (\"cwd=%s\\n\", pwd1);\n\n  /* Make sure the result is usable.  */\n  ASSERT (chdir (pwd1) == 0);\n  ASSERT (chdir (\".//./.\") == 0);\n\n  /* Make sure that result is normalized.  */\n  pwd2 = getcwd (NULL, 0);\n  ASSERT (pwd2);\n  ASSERT (strcmp (pwd1, pwd2) == 0);\n  free (pwd2);\n  {\n    size_t len = strlen (pwd1);\n    ssize_t i = len - 10;\n    if (i < 1)\n      i = 1;\n    pwd2 = getcwd (NULL, len + 1);\n    ASSERT (pwd2);\n    free (pwd2);\n    pwd2 = malloc (len + 2);\n    for ( ; i <= len; i++)\n      {\n        char *tmp;\n        errno = 0;\n        ASSERT (getcwd (pwd2, i) == NULL);\n        ASSERT (errno == ERANGE);\n        /* Allow either glibc or BSD behavior, since POSIX allows both.  */\n        errno = 0;\n        tmp = getcwd (NULL, i);\n        if (tmp)\n          {\n            ASSERT (strcmp (pwd1, tmp) == 0);\n            free (tmp);\n          }\n        else\n          {\n            ASSERT (errno == ERANGE);\n          }\n      }\n    ASSERT (getcwd (pwd2, len + 1) == pwd2);\n    pwd2[len] = '/';\n    pwd2[len + 1] = '\\0';\n  }\n  ASSERT (strstr (pwd2, \"/./\") == NULL);\n  ASSERT (strstr (pwd2, \"/../\") == NULL);\n  ASSERT (strstr (pwd2 + 1 + (pwd2[1] == '/'), \"//\") == NULL);\n\n  /* Validate a POSIX requirement on size.  */\n  errno = 0;\n  ASSERT (getcwd(pwd2, 0) == NULL);\n  ASSERT (errno == EINVAL);\n\n  free (pwd1);\n  free (pwd2);\n\n  return 0;\n}",
      "lines": 72,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-getdelim.c": {
    "main": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "int\nmain (void)\n{\n  FILE *f;\n  char *line;\n  size_t len;\n  ssize_t result;\n\n  /* Create test file.  */\n  f = fopen (\"test-getdelim.txt\", \"wb\");\n  if (!f || fwrite (\"anAnbcnd\\0f\", 1, 10, f) != 10 || fclose (f) != 0)\n    {\n      fputs (\"Failed to create sample file.\\n\", stderr);\n      remove (\"test-getdelim.txt\");\n      return 1;\n    }\n  f = fopen (\"test-getdelim.txt\", \"rb\");\n  if (!f)\n    {\n      fputs (\"Failed to reopen sample file.\\n\", stderr);\n      remove (\"test-getdelim.txt\");\n      return 1;\n    }\n\n  /* Test initial allocation, which must include trailing NUL.  */\n  line = NULL;\n  len = 0;\n  result = getdelim (&line, &len, 'n', f);\n  ASSERT (result == 2);\n  ASSERT (strcmp (line, \"an\") == 0);\n  ASSERT (2 < len);\n  free (line);\n\n  /* Test initial allocation again, with line = NULL and len != 0.  */\n  line = NULL;\n  len = (size_t)(~0) / 4;\n  result = getdelim (&line, &len, 'n', f);\n  ASSERT (result == 2);\n  ASSERT (strcmp (line, \"An\") == 0);\n  ASSERT (2 < len);\n  free (line);\n\n  /* Test growth of buffer.  */\n  line = malloc (1);\n  len = 1;\n  result = getdelim (&line, &len, 'n', f);\n  ASSERT (result == 3);\n  ASSERT (strcmp (line, \"bcn\") == 0);\n  ASSERT (3 < len);\n\n  /* Test embedded NULs and EOF behavior.  */\n  result = getdelim (&line, &len, 'n', f);\n  ASSERT (result == 3);\n  ASSERT (memcmp (line, \"d\\0f\", 4) == 0);\n  ASSERT (3 < len);\n\n  result = getdelim (&line, &len, 'n', f);\n  ASSERT (result == -1);\n\n  free (line);\n  fclose (f);\n  remove (\"test-getdelim.txt\");\n  return 0;\n}",
      "lines": 64,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-getdtablesize.c": {
    "main": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        35,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  ASSERT (getdtablesize () >= 3);\n  ASSERT (dup2 (0, getdtablesize() - 1) == getdtablesize () - 1);\n  ASSERT (dup2 (0, getdtablesize()) == -1);\n\n  return 0;\n}",
      "lines": 9,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-getopt-gnu.c": {},
  "sed/sed-4.5/gnulib-tests/test-getopt-main.h": {
    "main": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        75,
        1
      ],
      "content": "int\nmain (void)\n{\n   /* This test validates that stderr is used correctly, so move the\n      original into fd 10.  */\n  if (dup2 (STDERR_FILENO, BACKUP_STDERR_FILENO) != BACKUP_STDERR_FILENO\n      || (myerr = fdopen (BACKUP_STDERR_FILENO, \"w\")) == NULL)\n    return 2;\n\n  ASSERT (freopen (TEST_GETOPT_TMP_NAME, \"w\", stderr) == stderr);\n\n  /* These default values are required by POSIX.  */\n  ASSERT (optind == 1);\n  ASSERT (opterr != 0);\n\n  setenv (\"POSIXLY_CORRECT\", \"1\", 1);\n  test_getopt ();\n\n#if TEST_GETOPT_GNU\n  test_getopt_long_posix ();\n#endif\n\n  unsetenv (\"POSIXLY_CORRECT\");\n  test_getopt ();\n\n#if TEST_GETOPT_GNU\n  test_getopt_long ();\n  test_getopt_long_only ();\n#endif\n\n  ASSERT (fclose (stderr) == 0);\n  ASSERT (remove (TEST_GETOPT_TMP_NAME) == 0);\n\n  return 0;\n}",
      "lines": 35,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-getopt-posix.c": {},
  "sed/sed-4.5/gnulib-tests/test-getopt.h": {
    "getopt_loop": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "static void\ngetopt_loop (int argc, const char **argv,\n             const char *options,\n             int *a_seen, int *b_seen,\n             const char **p_value, const char **q_value,\n             int *non_options_count, const char **non_options,\n             int *unrecognized, bool *message_issued)\n{\n  int c;\n  int pos = ftell (stderr);\n\n  while ((c = getopt (argc, (char **) argv, options)) != -1)\n    {\n      switch (c)\n        {\n        case 'a':\n          (*a_seen)++;\n          break;\n        case 'b':\n          (*b_seen)++;\n          break;\n        case 'p':\n          *p_value = optarg;\n          break;\n        case 'q':\n          *q_value = optarg;\n          break;\n        case '\\1':\n          /* Must only happen with option '-' at the beginning.  */\n          ASSERT (options[0] == '-');\n          non_options[(*non_options_count)++] = optarg;\n          break;\n        case ':':\n          /* Must only happen with option ':' at the beginning.  */\n          ASSERT (options[0] == ':'\n                  || ((options[0] == '-' || options[0] == '+')\n                      && options[1] == ':'));\n          FALLTHROUGH;\n        case '?':\n          *unrecognized = optopt;\n          break;\n        default:\n          *unrecognized = c;\n          break;\n        }\n    }\n\n  *message_issued = pos < ftell (stderr);\n}",
      "lines": 49,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_getopt": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        1390,
        1
      ],
      "content": "static void\ntest_getopt (void)\n{\n  int start;\n  bool posixly = !!getenv (\"POSIXLY_CORRECT\");\n  /* See comment in getopt.c:\n     glibc gets a LSB-compliant getopt.\n     Standalone applications get a POSIX-compliant getopt.  */\n#if defined __GETOPT_PREFIX || !(__GLIBC__ >= 2 || defined __MINGW32__)\n  /* Using getopt from gnulib or from a non-glibc system.  */\n  posixly = true;\n#endif\n\n  /* Test processing of boolean options.  */\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[10];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 1;\n      getopt_loop (argc, argv, \"ab\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 2);\n      ASSERT (!output);\n    }\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[10];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-b\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 1;\n      getopt_loop (argc, argv, \"ab\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 1);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 3);\n      ASSERT (!output);\n    }\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[10];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-ba\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 1;\n      getopt_loop (argc, argv, \"ab\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 1);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 2);\n      ASSERT (!output);\n    }\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[10];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-ab\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 1;\n      getopt_loop (argc, argv, \"ab\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      ASSERT (a_seen == 2);\n      ASSERT (b_seen == 1);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 3);\n      ASSERT (!output);\n    }\n\n  /* Test processing of options with arguments.  */\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[10];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-pfoo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 1;\n      getopt_loop (argc, argv, \"p:q:\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"foo\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 2);\n      ASSERT (!output);\n    }\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[10];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 1;\n      getopt_loop (argc, argv, \"p:q:\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"foo\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 3);\n      ASSERT (!output);\n    }\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[10];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-ab\";\n      argv[argc++] = \"-q\";\n      argv[argc++] = \"baz\";\n      argv[argc++] = \"-pfoo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 1;\n      getopt_loop (argc, argv, \"abp:q:\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 1);\n      ASSERT (p_value != NULL && strcmp (p_value, \"foo\") == 0);\n      ASSERT (q_value != NULL && strcmp (q_value, \"baz\") == 0);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 5);\n      ASSERT (!output);\n    }\n\n#if GNULIB_TEST_GETOPT_GNU\n  /* Test processing of options with optional arguments.  */\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[10];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-pfoo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 1;\n      getopt_loop (argc, argv, \"p::q::\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"foo\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 2);\n      ASSERT (!output);\n    }\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[10];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 1;\n      getopt_loop (argc, argv, \"p::q::\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 2);\n      ASSERT (!output);\n    }\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[10];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 1;\n      getopt_loop (argc, argv, \"abp::q::\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 3);\n      ASSERT (!output);\n    }\n#endif /* GNULIB_TEST_GETOPT_GNU */\n\n  /* Check that invalid options are recognized; and that both opterr\n     and leading ':' can silence output.  */\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[10];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"-x\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 42;\n      getopt_loop (argc, argv, \"abp:q:\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"foo\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 'x');\n      ASSERT (optind == 5);\n      ASSERT (output);\n    }\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[10];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"-x\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 0;\n      getopt_loop (argc, argv, \"abp:q:\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"foo\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 'x');\n      ASSERT (optind == 5);\n      ASSERT (!output);\n    }\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[10];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"-x\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 1;\n      getopt_loop (argc, argv, \":abp:q:\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"foo\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 'x');\n      ASSERT (optind == 5);\n      ASSERT (!output);\n    }\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[10];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"-:\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 42;\n      getopt_loop (argc, argv, \"abp:q:\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"foo\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == ':');\n      ASSERT (optind == 5);\n      ASSERT (output);\n    }\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[10];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"-:\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 0;\n      getopt_loop (argc, argv, \"abp:q:\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"foo\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == ':');\n      ASSERT (optind == 5);\n      ASSERT (!output);\n    }\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[10];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"-:\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 1;\n      getopt_loop (argc, argv, \":abp:q:\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"foo\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == ':');\n      ASSERT (optind == 5);\n      ASSERT (!output);\n    }\n\n  /* Check for missing argument behavior.  */\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[10];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-ap\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 1;\n      getopt_loop (argc, argv, \"abp:q:\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 'p');\n      ASSERT (optind == 2);\n      ASSERT (output);\n    }\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[10];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-ap\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 0;\n      getopt_loop (argc, argv, \"abp:q:\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 'p');\n      ASSERT (optind == 2);\n      ASSERT (!output);\n    }\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[10];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-ap\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 1;\n      getopt_loop (argc, argv, \":abp:q:\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 'p');\n      ASSERT (optind == 2);\n      ASSERT (!output);\n    }\n\n  /* Check that by default, non-options arguments are moved to the end.  */\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[10];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"donald\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"billy\";\n      argv[argc++] = \"duck\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 1;\n      getopt_loop (argc, argv, \"abp:q:\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      if (posixly)\n        {\n          ASSERT (strcmp (argv[0], \"program\") == 0);\n          ASSERT (strcmp (argv[1], \"donald\") == 0);\n          ASSERT (strcmp (argv[2], \"-p\") == 0);\n          ASSERT (strcmp (argv[3], \"billy\") == 0);\n          ASSERT (strcmp (argv[4], \"duck\") == 0);\n          ASSERT (strcmp (argv[5], \"-a\") == 0);\n          ASSERT (strcmp (argv[6], \"bar\") == 0);\n          ASSERT (argv[7] == NULL);\n          ASSERT (a_seen == 0);\n          ASSERT (b_seen == 0);\n          ASSERT (p_value == NULL);\n          ASSERT (q_value == NULL);\n          ASSERT (non_options_count == 0);\n          ASSERT (unrecognized == 0);\n          ASSERT (optind == 1);\n          ASSERT (!output);\n        }\n      else\n        {\n          ASSERT (strcmp (argv[0], \"program\") == 0);\n          ASSERT (strcmp (argv[1], \"-p\") == 0);\n          ASSERT (strcmp (argv[2], \"billy\") == 0);\n          ASSERT (strcmp (argv[3], \"-a\") == 0);\n          ASSERT (strcmp (argv[4], \"donald\") == 0);\n          ASSERT (strcmp (argv[5], \"duck\") == 0);\n          ASSERT (strcmp (argv[6], \"bar\") == 0);\n          ASSERT (argv[7] == NULL);\n          ASSERT (a_seen == 1);\n          ASSERT (b_seen == 0);\n          ASSERT (p_value != NULL && strcmp (p_value, \"billy\") == 0);\n          ASSERT (q_value == NULL);\n          ASSERT (non_options_count == 0);\n          ASSERT (unrecognized == 0);\n          ASSERT (optind == 4);\n          ASSERT (!output);\n        }\n    }\n\n  /* Check that '--' ends the argument processing.  */\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[20];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"donald\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"billy\";\n      argv[argc++] = \"duck\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"--\";\n      argv[argc++] = \"-b\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"-q\";\n      argv[argc++] = \"johnny\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 1;\n      getopt_loop (argc, argv, \"abp:q:\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      if (posixly)\n        {\n          ASSERT (strcmp (argv[0], \"program\") == 0);\n          ASSERT (strcmp (argv[1], \"donald\") == 0);\n          ASSERT (strcmp (argv[2], \"-p\") == 0);\n          ASSERT (strcmp (argv[3], \"billy\") == 0);\n          ASSERT (strcmp (argv[4], \"duck\") == 0);\n          ASSERT (strcmp (argv[5], \"-a\") == 0);\n          ASSERT (strcmp (argv[6], \"--\") == 0);\n          ASSERT (strcmp (argv[7], \"-b\") == 0);\n          ASSERT (strcmp (argv[8], \"foo\") == 0);\n          ASSERT (strcmp (argv[9], \"-q\") == 0);\n          ASSERT (strcmp (argv[10], \"johnny\") == 0);\n          ASSERT (strcmp (argv[11], \"bar\") == 0);\n          ASSERT (argv[12] == NULL);\n          ASSERT (a_seen == 0);\n          ASSERT (b_seen == 0);\n          ASSERT (p_value == NULL);\n          ASSERT (q_value == NULL);\n          ASSERT (non_options_count == 0);\n          ASSERT (unrecognized == 0);\n          ASSERT (optind == 1);\n          ASSERT (!output);\n        }\n      else\n        {\n          ASSERT (strcmp (argv[0], \"program\") == 0);\n          ASSERT (strcmp (argv[1], \"-p\") == 0);\n          ASSERT (strcmp (argv[2], \"billy\") == 0);\n          ASSERT (strcmp (argv[3], \"-a\") == 0);\n          ASSERT (strcmp (argv[4], \"--\") == 0);\n          ASSERT (strcmp (argv[5], \"donald\") == 0);\n          ASSERT (strcmp (argv[6], \"duck\") == 0);\n          ASSERT (strcmp (argv[7], \"-b\") == 0);\n          ASSERT (strcmp (argv[8], \"foo\") == 0);\n          ASSERT (strcmp (argv[9], \"-q\") == 0);\n          ASSERT (strcmp (argv[10], \"johnny\") == 0);\n          ASSERT (strcmp (argv[11], \"bar\") == 0);\n          ASSERT (argv[12] == NULL);\n          ASSERT (a_seen == 1);\n          ASSERT (b_seen == 0);\n          ASSERT (p_value != NULL && strcmp (p_value, \"billy\") == 0);\n          ASSERT (q_value == NULL);\n          ASSERT (non_options_count == 0);\n          ASSERT (unrecognized == 0);\n          ASSERT (optind == 5);\n          ASSERT (!output);\n        }\n    }\n\n#if GNULIB_TEST_GETOPT_GNU\n  /* Check that the '-' flag causes non-options to be returned in order.  */\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[10];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"donald\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"billy\";\n      argv[argc++] = \"duck\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 1;\n      getopt_loop (argc, argv, \"-abp:q:\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      ASSERT (strcmp (argv[0], \"program\") == 0);\n      ASSERT (strcmp (argv[1], \"donald\") == 0);\n      ASSERT (strcmp (argv[2], \"-p\") == 0);\n      ASSERT (strcmp (argv[3], \"billy\") == 0);\n      ASSERT (strcmp (argv[4], \"duck\") == 0);\n      ASSERT (strcmp (argv[5], \"-a\") == 0);\n      ASSERT (strcmp (argv[6], \"bar\") == 0);\n      ASSERT (argv[7] == NULL);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"billy\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 3);\n      ASSERT (strcmp (non_options[0], \"donald\") == 0);\n      ASSERT (strcmp (non_options[1], \"duck\") == 0);\n      ASSERT (strcmp (non_options[2], \"bar\") == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 7);\n      ASSERT (!output);\n    }\n\n  /* Check that '--' ends the argument processing.  */\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[20];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"donald\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"billy\";\n      argv[argc++] = \"duck\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"--\";\n      argv[argc++] = \"-b\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"-q\";\n      argv[argc++] = \"johnny\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 1;\n      getopt_loop (argc, argv, \"-abp:q:\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      ASSERT (strcmp (argv[0], \"program\") == 0);\n      ASSERT (strcmp (argv[1], \"donald\") == 0);\n      ASSERT (strcmp (argv[2], \"-p\") == 0);\n      ASSERT (strcmp (argv[3], \"billy\") == 0);\n      ASSERT (strcmp (argv[4], \"duck\") == 0);\n      ASSERT (strcmp (argv[5], \"-a\") == 0);\n      ASSERT (strcmp (argv[6], \"--\") == 0);\n      ASSERT (strcmp (argv[7], \"-b\") == 0);\n      ASSERT (strcmp (argv[8], \"foo\") == 0);\n      ASSERT (strcmp (argv[9], \"-q\") == 0);\n      ASSERT (strcmp (argv[10], \"johnny\") == 0);\n      ASSERT (strcmp (argv[11], \"bar\") == 0);\n      ASSERT (argv[12] == NULL);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"billy\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (!output);\n      if (non_options_count == 2)\n        {\n          /* glibc behaviour.  */\n          ASSERT (non_options_count == 2);\n          ASSERT (strcmp (non_options[0], \"donald\") == 0);\n          ASSERT (strcmp (non_options[1], \"duck\") == 0);\n          ASSERT (unrecognized == 0);\n          ASSERT (optind == 7);\n        }\n      else\n        {\n          /* Another valid behaviour.  */\n          ASSERT (non_options_count == 7);\n          ASSERT (strcmp (non_options[0], \"donald\") == 0);\n          ASSERT (strcmp (non_options[1], \"duck\") == 0);\n          ASSERT (strcmp (non_options[2], \"-b\") == 0);\n          ASSERT (strcmp (non_options[3], \"foo\") == 0);\n          ASSERT (strcmp (non_options[4], \"-q\") == 0);\n          ASSERT (strcmp (non_options[5], \"johnny\") == 0);\n          ASSERT (strcmp (non_options[6], \"bar\") == 0);\n          ASSERT (unrecognized == 0);\n          ASSERT (optind == 12);\n        }\n    }\n\n  /* Check that the '-' flag has to come first.  */\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[10];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"donald\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"billy\";\n      argv[argc++] = \"duck\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 1;\n      getopt_loop (argc, argv, \"abp:q:-\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      if (posixly)\n        {\n          ASSERT (strcmp (argv[0], \"program\") == 0);\n          ASSERT (strcmp (argv[1], \"donald\") == 0);\n          ASSERT (strcmp (argv[2], \"-p\") == 0);\n          ASSERT (strcmp (argv[3], \"billy\") == 0);\n          ASSERT (strcmp (argv[4], \"duck\") == 0);\n          ASSERT (strcmp (argv[5], \"-a\") == 0);\n          ASSERT (strcmp (argv[6], \"bar\") == 0);\n          ASSERT (argv[7] == NULL);\n          ASSERT (a_seen == 0);\n          ASSERT (b_seen == 0);\n          ASSERT (p_value == NULL);\n          ASSERT (q_value == NULL);\n          ASSERT (non_options_count == 0);\n          ASSERT (unrecognized == 0);\n          ASSERT (optind == 1);\n          ASSERT (!output);\n        }\n      else\n        {\n          ASSERT (strcmp (argv[0], \"program\") == 0);\n          ASSERT (strcmp (argv[1], \"-p\") == 0);\n          ASSERT (strcmp (argv[2], \"billy\") == 0);\n          ASSERT (strcmp (argv[3], \"-a\") == 0);\n          ASSERT (strcmp (argv[4], \"donald\") == 0);\n          ASSERT (strcmp (argv[5], \"duck\") == 0);\n          ASSERT (strcmp (argv[6], \"bar\") == 0);\n          ASSERT (argv[7] == NULL);\n          ASSERT (a_seen == 1);\n          ASSERT (b_seen == 0);\n          ASSERT (p_value != NULL && strcmp (p_value, \"billy\") == 0);\n          ASSERT (q_value == NULL);\n          ASSERT (non_options_count == 0);\n          ASSERT (unrecognized == 0);\n          ASSERT (optind == 4);\n          ASSERT (!output);\n        }\n    }\n\n  /* Check that the '+' flag causes the first non-option to terminate the\n     loop.  */\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[10];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"donald\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"billy\";\n      argv[argc++] = \"duck\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 1;\n      getopt_loop (argc, argv, \"+abp:q:\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      ASSERT (strcmp (argv[0], \"program\") == 0);\n      ASSERT (strcmp (argv[1], \"donald\") == 0);\n      ASSERT (strcmp (argv[2], \"-p\") == 0);\n      ASSERT (strcmp (argv[3], \"billy\") == 0);\n      ASSERT (strcmp (argv[4], \"duck\") == 0);\n      ASSERT (strcmp (argv[5], \"-a\") == 0);\n      ASSERT (strcmp (argv[6], \"bar\") == 0);\n      ASSERT (argv[7] == NULL);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 1);\n      ASSERT (!output);\n    }\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[10];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-+\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_loop (argc, argv, \"+abp:q:\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == '+');\n      ASSERT (optind == 2);\n      ASSERT (output);\n    }\n\n  /* Check that '--' ends the argument processing.  */\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[20];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"donald\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"billy\";\n      argv[argc++] = \"duck\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"--\";\n      argv[argc++] = \"-b\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"-q\";\n      argv[argc++] = \"johnny\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 1;\n      getopt_loop (argc, argv, \"+abp:q:\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      ASSERT (strcmp (argv[0], \"program\") == 0);\n      ASSERT (strcmp (argv[1], \"donald\") == 0);\n      ASSERT (strcmp (argv[2], \"-p\") == 0);\n      ASSERT (strcmp (argv[3], \"billy\") == 0);\n      ASSERT (strcmp (argv[4], \"duck\") == 0);\n      ASSERT (strcmp (argv[5], \"-a\") == 0);\n      ASSERT (strcmp (argv[6], \"--\") == 0);\n      ASSERT (strcmp (argv[7], \"-b\") == 0);\n      ASSERT (strcmp (argv[8], \"foo\") == 0);\n      ASSERT (strcmp (argv[9], \"-q\") == 0);\n      ASSERT (strcmp (argv[10], \"johnny\") == 0);\n      ASSERT (strcmp (argv[11], \"bar\") == 0);\n      ASSERT (argv[12] == NULL);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 1);\n      ASSERT (!output);\n    }\n#endif /* GNULIB_TEST_GETOPT_GNU */\n\n  /* Check that the '+' flag has to come first.  */\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[10];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"donald\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"billy\";\n      argv[argc++] = \"duck\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 1;\n      getopt_loop (argc, argv, \"abp:q:+\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      if (posixly)\n        {\n          ASSERT (strcmp (argv[0], \"program\") == 0);\n          ASSERT (strcmp (argv[1], \"donald\") == 0);\n          ASSERT (strcmp (argv[2], \"-p\") == 0);\n          ASSERT (strcmp (argv[3], \"billy\") == 0);\n          ASSERT (strcmp (argv[4], \"duck\") == 0);\n          ASSERT (strcmp (argv[5], \"-a\") == 0);\n          ASSERT (strcmp (argv[6], \"bar\") == 0);\n          ASSERT (argv[7] == NULL);\n          ASSERT (a_seen == 0);\n          ASSERT (b_seen == 0);\n          ASSERT (p_value == NULL);\n          ASSERT (q_value == NULL);\n          ASSERT (non_options_count == 0);\n          ASSERT (unrecognized == 0);\n          ASSERT (optind == 1);\n          ASSERT (!output);\n        }\n      else\n        {\n          ASSERT (strcmp (argv[0], \"program\") == 0);\n          ASSERT (strcmp (argv[1], \"-p\") == 0);\n          ASSERT (strcmp (argv[2], \"billy\") == 0);\n          ASSERT (strcmp (argv[3], \"-a\") == 0);\n          ASSERT (strcmp (argv[4], \"donald\") == 0);\n          ASSERT (strcmp (argv[5], \"duck\") == 0);\n          ASSERT (strcmp (argv[6], \"bar\") == 0);\n          ASSERT (argv[7] == NULL);\n          ASSERT (a_seen == 1);\n          ASSERT (b_seen == 0);\n          ASSERT (p_value != NULL && strcmp (p_value, \"billy\") == 0);\n          ASSERT (q_value == NULL);\n          ASSERT (non_options_count == 0);\n          ASSERT (unrecognized == 0);\n          ASSERT (optind == 4);\n          ASSERT (!output);\n        }\n    }\n\n#if GNULIB_TEST_GETOPT_GNU\n  /* If GNU extensions are supported, require compliance with POSIX\n     interpretation on leading '+' behavior.\n     http://austingroupbugs.net/view.php?id=191  */\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[10];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"donald\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"billy\";\n      argv[argc++] = \"duck\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 1;\n      getopt_loop (argc, argv, \"+:abp:q:\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      ASSERT (strcmp (argv[0], \"program\") == 0);\n      ASSERT (strcmp (argv[1], \"donald\") == 0);\n      ASSERT (strcmp (argv[2], \"-p\") == 0);\n      ASSERT (strcmp (argv[3], \"billy\") == 0);\n      ASSERT (strcmp (argv[4], \"duck\") == 0);\n      ASSERT (strcmp (argv[5], \"-a\") == 0);\n      ASSERT (strcmp (argv[6], \"bar\") == 0);\n      ASSERT (argv[7] == NULL);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 1);\n      ASSERT (!output);\n    }\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[10];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-p\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_loop (argc, argv, \"+:abp:q:\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 'p');\n      ASSERT (optind == 2);\n      ASSERT (!output);\n    }\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[10];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-b\";\n      argv[argc++] = \"-p\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_loop (argc, argv, \"+:abp:q:\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 1);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 'p');\n      ASSERT (optind == 3);\n      ASSERT (!output);\n    }\n\n  /* Check that 'W' does not dump core:\n     https://sourceware.org/bugzilla/show_bug.cgi?id=12922\n     Technically, POSIX says the presence of ';' in the opt-string\n     gives unspecified behavior, so we only test this when GNU compliance\n     is desired.  */\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int argc = 0;\n      const char *argv[10];\n      int pos = ftell (stderr);\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-W\";\n      argv[argc++] = \"dummy\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 1;\n      ASSERT (getopt (argc, (char **) argv, \"W;\") == 'W');\n      ASSERT (ftell (stderr) == pos);\n      ASSERT (optind == 2);\n    }\n#endif /* GNULIB_TEST_GETOPT_GNU */\n}",
      "lines": 1310,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-getopt_long.h": {
    "getopt_long_loop": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        98,
        1
      ],
      "content": "static void\ngetopt_long_loop (int argc, const char **argv,\n                  const char *options, const struct option *long_options,\n                  const char **p_value, const char **q_value,\n                  int *non_options_count, const char **non_options,\n                  int *unrecognized)\n{\n  int option_index = -1;\n  int c;\n\n  opterr = 0;\n  q_seen = 0;\n  while ((c = getopt_long (argc, (char **) argv, options, long_options,\n                           &option_index))\n         != -1)\n    {\n      switch (c)\n        {\n        case 0:\n          /* An option with a non-NULL flag pointer was processed.  */\n          if (q_seen)\n            *q_value = optarg;\n          break;\n        case 'a':\n          a_seen++;\n          break;\n        case 'b':\n          b_seen = 1;\n          break;\n        case 'p':\n          *p_value = optarg;\n          break;\n        case 'q':\n          *q_value = optarg;\n          break;\n        case '\\1':\n          /* Must only happen with option '-' at the beginning.  */\n          ASSERT (options[0] == '-');\n          non_options[(*non_options_count)++] = optarg;\n          break;\n        case ':':\n          /* Must only happen with option ':' at the beginning.  */\n          ASSERT (options[0] == ':'\n                  || ((options[0] == '-' || options[0] == '+')\n                      && options[1] == ':'));\n          FALLTHROUGH;\n        case '?':\n          *unrecognized = optopt;\n          break;\n        default:\n          *unrecognized = c;\n          break;\n        }\n    }\n}",
      "lines": 55,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "do_getopt_long": {
      "start_point": [
        103,
        0
      ],
      "end_point": [
        108,
        1
      ],
      "content": "static int\ndo_getopt_long (int argc, const char **argv, const char *shortopts,\n                const struct option *longopts, int *longind)\n{\n  return getopt_long (argc, (char **) argv, shortopts, longopts, longind);\n}",
      "lines": 6,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "test_getopt_long": {
      "start_point": [
        110,
        0
      ],
      "end_point": [
        1812,
        1
      ],
      "content": "static void\ntest_getopt_long (void)\n{\n  int start;\n\n  /* Test disambiguation of options.  */\n  {\n    int argc = 0;\n    const char *argv[10];\n    int option_index;\n    int c;\n\n    argv[argc++] = \"program\";\n    argv[argc++] = \"--x\";\n    argv[argc] = NULL;\n    optind = 1;\n    opterr = 0;\n    c = do_getopt_long (argc, argv, \"ab\", long_options_required, &option_index);\n    ASSERT (c == '?');\n    ASSERT (optopt == 0);\n  }\n  {\n    int argc = 0;\n    const char *argv[10];\n    int option_index;\n    int c;\n\n    argv[argc++] = \"program\";\n    argv[argc++] = \"--xt\";\n    argv[argc] = NULL;\n    optind = 1;\n    opterr = 0;\n    c = do_getopt_long (argc, argv, \"ab\", long_options_required, &option_index);\n    ASSERT (c == '?');\n    ASSERT (optopt == 0);\n  }\n  {\n    int argc = 0;\n    const char *argv[10];\n    int option_index;\n    int c;\n\n    argv[argc++] = \"program\";\n    argv[argc++] = \"--xtr\";\n    argv[argc] = NULL;\n    optind = 1;\n    opterr = 0;\n    c = do_getopt_long (argc, argv, \"ab\", long_options_required, &option_index);\n    ASSERT (c == '?');\n    ASSERT (optopt == 0);\n  }\n  {\n    int argc = 0;\n    const char *argv[10];\n    int option_index;\n    int c;\n\n    argv[argc++] = \"program\";\n    argv[argc++] = \"--xtra\";\n    argv[argc] = NULL;\n    optind = 1;\n    opterr = 0;\n    c = do_getopt_long (argc, argv, \"ab\", long_options_required, &option_index);\n    ASSERT (c == 1001);\n  }\n  {\n    int argc = 0;\n    const char *argv[10];\n    int option_index;\n    int c;\n\n    argv[argc++] = \"program\";\n    argv[argc++] = \"--xtre\";\n    argv[argc] = NULL;\n    optind = 1;\n    opterr = 0;\n    c = do_getopt_long (argc, argv, \"ab\", long_options_required, &option_index);\n    ASSERT (c == '?');\n    ASSERT (optopt == 0);\n  }\n  {\n    int argc = 0;\n    const char *argv[10];\n    int option_index;\n    int c;\n\n    argv[argc++] = \"program\";\n    argv[argc++] = \"--xtrem\";\n    argv[argc] = NULL;\n    optind = 1;\n    opterr = 0;\n    c = do_getopt_long (argc, argv, \"ab\", long_options_required, &option_index);\n    ASSERT (c == '?');\n    ASSERT (optopt == 0);\n  }\n  {\n    int argc = 0;\n    const char *argv[10];\n    int option_index;\n    int c;\n\n    argv[argc++] = \"program\";\n    argv[argc++] = \"--xtreme\";\n    argv[argc] = NULL;\n    optind = 1;\n    opterr = 0;\n    c = do_getopt_long (argc, argv, \"ab\", long_options_required, &option_index);\n    ASSERT (c == 1002);\n  }\n  {\n    int argc = 0;\n    const char *argv[10];\n    int option_index;\n    int c;\n\n    argv[argc++] = \"program\";\n    argv[argc++] = \"--xtremel\";\n    argv[argc] = NULL;\n    optind = 1;\n    opterr = 0;\n    c = do_getopt_long (argc, argv, \"ab\", long_options_required, &option_index);\n    ASSERT (c == 1003);\n  }\n  {\n    int argc = 0;\n    const char *argv[10];\n    int option_index;\n    int c;\n\n    argv[argc++] = \"program\";\n    argv[argc++] = \"--xtremely\";\n    argv[argc] = NULL;\n    optind = 1;\n    opterr = 0;\n    c = do_getopt_long (argc, argv, \"ab\", long_options_required, &option_index);\n    ASSERT (c == 1003);\n  }\n\n  /* Check that -W handles unknown options.  */\n  {\n    int argc = 0;\n    const char *argv[10];\n    int option_index;\n    int c;\n\n    argv[argc++] = \"program\";\n    argv[argc++] = \"-W\";\n    argv[argc] = NULL;\n    optind = 1;\n    opterr = 0;\n    c = do_getopt_long (argc, argv, \"W;\", long_options_required, &option_index);\n    ASSERT (c == '?');\n    ASSERT (optopt == 'W');\n  }\n  {\n    int argc = 0;\n    const char *argv[10];\n    int option_index;\n    int c;\n\n    argv[argc++] = \"program\";\n    argv[argc++] = \"-Wunknown\";\n    argv[argc] = NULL;\n    optind = 1;\n    opterr = 0;\n    c = do_getopt_long (argc, argv, \"W;\", long_options_required, &option_index);\n    /* glibc and BSD behave differently here, but for now, we allow\n       both behaviors since W support is not frequently used.  */\n    if (c == '?')\n      {\n        ASSERT (optopt == 0);\n        ASSERT (optarg == NULL);\n      }\n    else\n      {\n        ASSERT (c == 'W');\n        ASSERT (strcmp (optarg, \"unknown\") == 0);\n      }\n  }\n  {\n    int argc = 0;\n    const char *argv[10];\n    int option_index;\n    int c;\n\n    argv[argc++] = \"program\";\n    argv[argc++] = \"-W\";\n    argv[argc++] = \"unknown\";\n    argv[argc] = NULL;\n    optind = 1;\n    opterr = 0;\n    c = do_getopt_long (argc, argv, \"W;\", long_options_required, &option_index);\n    /* glibc and BSD behave differently here, but for now, we allow\n       both behaviors since W support is not frequently used.  */\n    if (c == '?')\n      {\n        ASSERT (optopt == 0);\n        ASSERT (optarg == NULL);\n      }\n    else\n      {\n        ASSERT (c == 'W');\n        ASSERT (strcmp (optarg, \"unknown\") == 0);\n      }\n  }\n\n  /* Test that 'W' does not dump core:\n     https://sourceware.org/bugzilla/show_bug.cgi?id=12922  */\n  {\n    int argc = 0;\n    const char *argv[10];\n    int option_index;\n    int c;\n\n    argv[argc++] = \"program\";\n    argv[argc++] = \"-W\";\n    argv[argc++] = \"dummy\";\n    argv[argc] = NULL;\n    optind = 1;\n    opterr = 0;\n    c = do_getopt_long (argc, argv, \"W;\", NULL, &option_index);\n    ASSERT (c == 'W');\n    ASSERT (optind == 2);\n  }\n\n  /* Test processing of boolean short options.  */\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"ab\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 2);\n    }\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-b\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"ab\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 1);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 3);\n    }\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-ba\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"ab\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 1);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 2);\n    }\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-ab\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"ab\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 2);\n      ASSERT (b_seen == 1);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 3);\n    }\n\n  /* Test processing of boolean long options.  */\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"--alpha\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"ab\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 2);\n    }\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"--beta\";\n      argv[argc++] = \"--alpha\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"ab\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 1);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 3);\n    }\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"--alpha\";\n      argv[argc++] = \"--beta\";\n      argv[argc++] = \"--alpha\";\n      argv[argc++] = \"--beta\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"ab\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 2);\n      ASSERT (b_seen == 1);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 5);\n    }\n\n  /* Test processing of boolean long options via -W.  */\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-Walpha\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"abW;\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 2);\n    }\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-W\";\n      argv[argc++] = \"beta\";\n      argv[argc++] = \"-W\";\n      argv[argc++] = \"alpha\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"aW;b\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 1);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 5);\n    }\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-Walpha\";\n      argv[argc++] = \"-Wbeta\";\n      argv[argc++] = \"-Walpha\";\n      argv[argc++] = \"-Wbeta\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"W;ab\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 2);\n      ASSERT (b_seen == 1);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 5);\n    }\n\n  /* Test processing of short options with arguments.  */\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-pfoo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"p:q:\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"foo\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 2);\n    }\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"p:q:\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"foo\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 3);\n    }\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-ab\";\n      argv[argc++] = \"-q\";\n      argv[argc++] = \"baz\";\n      argv[argc++] = \"-pfoo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"abp:q:\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 1);\n      ASSERT (p_value != NULL && strcmp (p_value, \"foo\") == 0);\n      ASSERT (q_value != NULL && strcmp (q_value, \"baz\") == 0);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 5);\n    }\n\n  /* Test processing of long options with arguments.  */\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"--p=foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"p:q:\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"foo\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 2);\n    }\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"--p\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"p:q:\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"foo\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 3);\n    }\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-ab\";\n      argv[argc++] = \"--q\";\n      argv[argc++] = \"baz\";\n      argv[argc++] = \"--p=foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"abp:q:\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 1);\n      ASSERT (p_value != NULL && strcmp (p_value, \"foo\") == 0);\n      ASSERT (q_value != NULL && strcmp (q_value, \"baz\") == 0);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 5);\n    }\n\n  /* Test processing of long options with arguments via -W.  */\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-Wp=foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"p:q:W;\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"foo\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 2);\n    }\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-W\";\n      argv[argc++] = \"p\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"p:W;q:\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"foo\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 4);\n    }\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-ab\";\n      argv[argc++] = \"-Wq\";\n      argv[argc++] = \"baz\";\n      argv[argc++] = \"-W\";\n      argv[argc++] = \"p=foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"W;abp:q:\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 1);\n      ASSERT (p_value != NULL && strcmp (p_value, \"foo\") == 0);\n      ASSERT (q_value != NULL && strcmp (q_value, \"baz\") == 0);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 6);\n    }\n\n  /* Test processing of short options with optional arguments.  */\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-pfoo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"p::q::\", long_options_optional,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"foo\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 2);\n    }\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"p::q::\", long_options_optional,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 2);\n    }\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"abp::q::\", long_options_optional,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 3);\n    }\n\n  /* Test processing of long options with optional arguments.  */\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"--p=foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"p::q::\", long_options_optional,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"foo\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 2);\n    }\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"--p\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"p::q::\", long_options_optional,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 2);\n    }\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"--p=\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"p::q::\", long_options_optional,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && *p_value == '\\0');\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 2);\n    }\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"--p\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"abp::q::\", long_options_optional,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 3);\n    }\n\n  /* Test processing of long options with optional arguments via -W.  */\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-Wp=foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"p::q::W;\", long_options_optional,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"foo\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 2);\n    }\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-Wp\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"p::q::W;\", long_options_optional,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 2);\n    }\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-Wp=\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"W;p::q::\", long_options_optional,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && *p_value == '\\0');\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 2);\n    }\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-W\";\n      argv[argc++] = \"p=\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"W;p::q::\", long_options_optional,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && *p_value == '\\0');\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 3);\n    }\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-W\";\n      argv[argc++] = \"p\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"W;abp::q::\", long_options_optional,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 0);\n      /* ASSERT (p_value == NULL); */\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 4);\n    }\n\n  /* Check that invalid options are recognized.  */\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"-x\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"abp:q:\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"foo\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 'x');\n      ASSERT (optind == 5);\n    }\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"-:\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"abp:q:\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"foo\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == ':');\n      ASSERT (optind == 5);\n    }\n\n  /* Check that unexpected arguments are recognized.  */\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"--a=\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"abp:q:\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"foo\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 'a');\n      ASSERT (optind == 4);\n    }\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"--b=\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"abp:q:\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"foo\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      /* When flag is non-zero, glibc sets optopt anyway, but BSD\n         leaves optopt unchanged.  */\n      ASSERT (unrecognized == 1 || unrecognized == 0);\n      ASSERT (optind == 4);\n    }\n\n  /* Check that by default, non-options arguments are moved to the end.  */\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"donald\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"billy\";\n      argv[argc++] = \"duck\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"abp:q:\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (strcmp (argv[0], \"program\") == 0);\n      ASSERT (strcmp (argv[1], \"-p\") == 0);\n      ASSERT (strcmp (argv[2], \"billy\") == 0);\n      ASSERT (strcmp (argv[3], \"-a\") == 0);\n      ASSERT (strcmp (argv[4], \"donald\") == 0);\n      ASSERT (strcmp (argv[5], \"duck\") == 0);\n      ASSERT (strcmp (argv[6], \"bar\") == 0);\n      ASSERT (argv[7] == NULL);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"billy\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 4);\n    }\n\n  /* Check that '--' ends the argument processing.  */\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[20];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"donald\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"billy\";\n      argv[argc++] = \"duck\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"--\";\n      argv[argc++] = \"-b\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"-q\";\n      argv[argc++] = \"johnny\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"abp:q:\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (strcmp (argv[0], \"program\") == 0);\n      ASSERT (strcmp (argv[1], \"-p\") == 0);\n      ASSERT (strcmp (argv[2], \"billy\") == 0);\n      ASSERT (strcmp (argv[3], \"-a\") == 0);\n      ASSERT (strcmp (argv[4], \"--\") == 0);\n      ASSERT (strcmp (argv[5], \"donald\") == 0);\n      ASSERT (strcmp (argv[6], \"duck\") == 0);\n      ASSERT (strcmp (argv[7], \"-b\") == 0);\n      ASSERT (strcmp (argv[8], \"foo\") == 0);\n      ASSERT (strcmp (argv[9], \"-q\") == 0);\n      ASSERT (strcmp (argv[10], \"johnny\") == 0);\n      ASSERT (strcmp (argv[11], \"bar\") == 0);\n      ASSERT (argv[12] == NULL);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"billy\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 5);\n    }\n\n  /* Check that the '-' flag causes non-options to be returned in order.  */\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"donald\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"billy\";\n      argv[argc++] = \"duck\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"-abp:q:\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (strcmp (argv[0], \"program\") == 0);\n      ASSERT (strcmp (argv[1], \"donald\") == 0);\n      ASSERT (strcmp (argv[2], \"-p\") == 0);\n      ASSERT (strcmp (argv[3], \"billy\") == 0);\n      ASSERT (strcmp (argv[4], \"duck\") == 0);\n      ASSERT (strcmp (argv[5], \"-a\") == 0);\n      ASSERT (strcmp (argv[6], \"bar\") == 0);\n      ASSERT (argv[7] == NULL);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"billy\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 3);\n      ASSERT (strcmp (non_options[0], \"donald\") == 0);\n      ASSERT (strcmp (non_options[1], \"duck\") == 0);\n      ASSERT (strcmp (non_options[2], \"bar\") == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 7);\n    }\n\n  /* Check that '--' ends the argument processing.  */\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[20];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"donald\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"billy\";\n      argv[argc++] = \"duck\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"--\";\n      argv[argc++] = \"-b\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"-q\";\n      argv[argc++] = \"johnny\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"-abp:q:\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (strcmp (argv[0], \"program\") == 0);\n      ASSERT (strcmp (argv[1], \"donald\") == 0);\n      ASSERT (strcmp (argv[2], \"-p\") == 0);\n      ASSERT (strcmp (argv[3], \"billy\") == 0);\n      ASSERT (strcmp (argv[4], \"duck\") == 0);\n      ASSERT (strcmp (argv[5], \"-a\") == 0);\n      ASSERT (strcmp (argv[6], \"--\") == 0);\n      ASSERT (strcmp (argv[7], \"-b\") == 0);\n      ASSERT (strcmp (argv[8], \"foo\") == 0);\n      ASSERT (strcmp (argv[9], \"-q\") == 0);\n      ASSERT (strcmp (argv[10], \"johnny\") == 0);\n      ASSERT (strcmp (argv[11], \"bar\") == 0);\n      ASSERT (argv[12] == NULL);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"billy\") == 0);\n      ASSERT (q_value == NULL);\n      if (non_options_count == 2)\n      {\n        /* glibc behaviour.  */\n        ASSERT (non_options_count == 2);\n        ASSERT (strcmp (non_options[0], \"donald\") == 0);\n        ASSERT (strcmp (non_options[1], \"duck\") == 0);\n        ASSERT (unrecognized == 0);\n        ASSERT (optind == 7);\n      }\n      else\n      {\n        /* Another valid behaviour.  */\n        ASSERT (non_options_count == 7);\n        ASSERT (strcmp (non_options[0], \"donald\") == 0);\n        ASSERT (strcmp (non_options[1], \"duck\") == 0);\n        ASSERT (strcmp (non_options[2], \"-b\") == 0);\n        ASSERT (strcmp (non_options[3], \"foo\") == 0);\n        ASSERT (strcmp (non_options[4], \"-q\") == 0);\n        ASSERT (strcmp (non_options[5], \"johnny\") == 0);\n        ASSERT (strcmp (non_options[6], \"bar\") == 0);\n        ASSERT (unrecognized == 0);\n        ASSERT (optind == 12);\n      }\n    }\n\n  /* Check that the '-' flag has to come first.  */\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"donald\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"billy\";\n      argv[argc++] = \"duck\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"abp:q:-\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (strcmp (argv[0], \"program\") == 0);\n      ASSERT (strcmp (argv[1], \"-p\") == 0);\n      ASSERT (strcmp (argv[2], \"billy\") == 0);\n      ASSERT (strcmp (argv[3], \"-a\") == 0);\n      ASSERT (strcmp (argv[4], \"donald\") == 0);\n      ASSERT (strcmp (argv[5], \"duck\") == 0);\n      ASSERT (strcmp (argv[6], \"bar\") == 0);\n      ASSERT (argv[7] == NULL);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"billy\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 4);\n    }\n\n  /* Check that the '+' flag causes the first non-option to terminate the\n     loop.  */\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"donald\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"billy\";\n      argv[argc++] = \"duck\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"+abp:q:\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (strcmp (argv[0], \"program\") == 0);\n      ASSERT (strcmp (argv[1], \"donald\") == 0);\n      ASSERT (strcmp (argv[2], \"-p\") == 0);\n      ASSERT (strcmp (argv[3], \"billy\") == 0);\n      ASSERT (strcmp (argv[4], \"duck\") == 0);\n      ASSERT (strcmp (argv[5], \"-a\") == 0);\n      ASSERT (strcmp (argv[6], \"bar\") == 0);\n      ASSERT (argv[7] == NULL);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 1);\n    }\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-+\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"+abp:q:\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == '+');\n      ASSERT (optind == 2);\n    }\n\n  /* Check that '--' ends the argument processing.  */\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[20];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"donald\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"billy\";\n      argv[argc++] = \"duck\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"--\";\n      argv[argc++] = \"-b\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"-q\";\n      argv[argc++] = \"johnny\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"+abp:q:\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (strcmp (argv[0], \"program\") == 0);\n      ASSERT (strcmp (argv[1], \"donald\") == 0);\n      ASSERT (strcmp (argv[2], \"-p\") == 0);\n      ASSERT (strcmp (argv[3], \"billy\") == 0);\n      ASSERT (strcmp (argv[4], \"duck\") == 0);\n      ASSERT (strcmp (argv[5], \"-a\") == 0);\n      ASSERT (strcmp (argv[6], \"--\") == 0);\n      ASSERT (strcmp (argv[7], \"-b\") == 0);\n      ASSERT (strcmp (argv[8], \"foo\") == 0);\n      ASSERT (strcmp (argv[9], \"-q\") == 0);\n      ASSERT (strcmp (argv[10], \"johnny\") == 0);\n      ASSERT (strcmp (argv[11], \"bar\") == 0);\n      ASSERT (argv[12] == NULL);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 1);\n    }\n\n  /* Check that the '+' flag has to come first.  */\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"donald\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"billy\";\n      argv[argc++] = \"duck\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"abp:q:+\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (strcmp (argv[0], \"program\") == 0);\n      ASSERT (strcmp (argv[1], \"-p\") == 0);\n      ASSERT (strcmp (argv[2], \"billy\") == 0);\n      ASSERT (strcmp (argv[3], \"-a\") == 0);\n      ASSERT (strcmp (argv[4], \"donald\") == 0);\n      ASSERT (strcmp (argv[5], \"duck\") == 0);\n      ASSERT (strcmp (argv[6], \"bar\") == 0);\n      ASSERT (argv[7] == NULL);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"billy\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 4);\n    }\n}",
      "lines": 1703,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_getopt_long_posix": {
      "start_point": [
        1818,
        0
      ],
      "end_point": [
        1926,
        1
      ],
      "content": "static void\ntest_getopt_long_posix (void)\n{\n  int start;\n\n  /* Check that POSIXLY_CORRECT stops parsing the same as leading '+'.  */\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"donald\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"billy\";\n      argv[argc++] = \"duck\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"abp:q:\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (strcmp (argv[0], \"program\") == 0);\n      ASSERT (strcmp (argv[1], \"donald\") == 0);\n      ASSERT (strcmp (argv[2], \"-p\") == 0);\n      ASSERT (strcmp (argv[3], \"billy\") == 0);\n      ASSERT (strcmp (argv[4], \"duck\") == 0);\n      ASSERT (strcmp (argv[5], \"-a\") == 0);\n      ASSERT (strcmp (argv[6], \"bar\") == 0);\n      ASSERT (argv[7] == NULL);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 1);\n    }\n\n  /* Check that POSIXLY_CORRECT doesn't change optional arguments.  */\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"billy\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"p::\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 2);\n    }\n\n  /* Check that leading - still sees options after non-options.  */\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"billy\";\n      argv[argc++] = \"-b\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"-ab\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 1);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 1);\n      ASSERT (strcmp (non_options[0], \"billy\") == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 4);\n    }\n}",
      "lines": 109,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "do_getopt_long_only": {
      "start_point": [
        1931,
        0
      ],
      "end_point": [
        1936,
        1
      ],
      "content": "static int\ndo_getopt_long_only (int argc, const char **argv, const char *shortopts,\n                     const struct option *longopts, int *longind)\n{\n  return getopt_long_only (argc, (char **) argv, shortopts, longopts, longind);\n}",
      "lines": 6,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "test_getopt_long_only": {
      "start_point": [
        1938,
        0
      ],
      "end_point": [
        2143,
        1
      ],
      "content": "static void\ntest_getopt_long_only (void)\n{\n  /* Test disambiguation of options.  */\n  {\n    int argc = 0;\n    const char *argv[10];\n    int option_index;\n    int c;\n\n    argv[argc++] = \"program\";\n    argv[argc++] = \"-x\";\n    argv[argc] = NULL;\n    optind = 1;\n    opterr = 0;\n    c = do_getopt_long_only (argc, argv, \"ab\", long_options_required,\n                             &option_index);\n    ASSERT (c == '?');\n    ASSERT (optopt == 0);\n  }\n  {\n    int argc = 0;\n    const char *argv[10];\n    int option_index;\n    int c;\n\n    argv[argc++] = \"program\";\n    argv[argc++] = \"-x\";\n    argv[argc] = NULL;\n    optind = 1;\n    opterr = 0;\n    c = do_getopt_long_only (argc, argv, \"abx\", long_options_required,\n                             &option_index);\n    ASSERT (c == 'x');\n    ASSERT (optopt == 0);\n  }\n  {\n    int argc = 0;\n    const char *argv[10];\n    int option_index;\n    int c;\n\n    argv[argc++] = \"program\";\n    argv[argc++] = \"--x\";\n    argv[argc] = NULL;\n    optind = 1;\n    opterr = 0;\n    c = do_getopt_long_only (argc, argv, \"abx\", long_options_required,\n                             &option_index);\n    ASSERT (c == '?');\n    ASSERT (optopt == 0);\n  }\n  {\n    int argc = 0;\n    const char *argv[10];\n    int option_index;\n    int c;\n\n    argv[argc++] = \"program\";\n    argv[argc++] = \"-b\";\n    argv[argc] = NULL;\n    optind = 1;\n    opterr = 0;\n    b_seen = 0;\n    c = do_getopt_long_only (argc, argv, \"abx\", long_options_required,\n                             &option_index);\n    ASSERT (c == 'b');\n    ASSERT (b_seen == 0);\n  }\n  {\n    int argc = 0;\n    const char *argv[10];\n    int option_index;\n    int c;\n\n    argv[argc++] = \"program\";\n    argv[argc++] = \"--b\";\n    argv[argc] = NULL;\n    optind = 1;\n    opterr = 0;\n    b_seen = 0;\n    c = do_getopt_long_only (argc, argv, \"abx\", long_options_required,\n                             &option_index);\n    ASSERT (c == 0);\n    ASSERT (b_seen == 1);\n  }\n  {\n    int argc = 0;\n    const char *argv[10];\n    int option_index;\n    int c;\n\n    argv[argc++] = \"program\";\n    argv[argc++] = \"-xt\";\n    argv[argc] = NULL;\n    optind = 1;\n    opterr = 0;\n    c = do_getopt_long_only (argc, argv, \"ab\", long_options_required,\n                             &option_index);\n    ASSERT (c == '?');\n    ASSERT (optopt == 0);\n  }\n  {\n    int argc = 0;\n    const char *argv[10];\n    int option_index;\n    int c;\n\n    argv[argc++] = \"program\";\n    argv[argc++] = \"-xt\";\n    argv[argc] = NULL;\n    optind = 1;\n    opterr = 0;\n    c = do_getopt_long_only (argc, argv, \"abx\", long_options_required,\n                             &option_index);\n    ASSERT (c == '?');\n    ASSERT (optopt == 0);\n  }\n  {\n    int argc = 0;\n    const char *argv[10];\n    int option_index;\n    int c;\n\n    argv[argc++] = \"program\";\n    argv[argc++] = \"-xtra\";\n    argv[argc] = NULL;\n    optind = 1;\n    opterr = 0;\n    c = do_getopt_long_only (argc, argv, \"ab\", long_options_required,\n                             &option_index);\n    ASSERT (c == 1001);\n  }\n  {\n    int argc = 0;\n    const char *argv[10];\n    int option_index;\n    int c;\n\n    argv[argc++] = \"program\";\n    argv[argc++] = \"-xtreme\";\n    argv[argc] = NULL;\n    optind = 1;\n    opterr = 0;\n    c = do_getopt_long_only (argc, argv, \"abx:\", long_options_required,\n                             &option_index);\n    ASSERT (c == 1002);\n  }\n  {\n    int argc = 0;\n    const char *argv[10];\n    int option_index;\n    int c;\n\n    argv[argc++] = \"program\";\n    argv[argc++] = \"-xtremel\";\n    argv[argc] = NULL;\n    optind = 1;\n    opterr = 0;\n    c = do_getopt_long_only (argc, argv, \"ab\", long_options_required,\n                             &option_index);\n    /* glibc getopt_long_only is intentionally different from\n       getopt_long when handling a prefix that is common to two\n       spellings, when both spellings have the same option directives.\n       BSD getopt_long_only treats both cases the same.  */\n    ASSERT (c == 1003 || c == '?');\n    ASSERT (optind == 2);\n  }\n  {\n    int argc = 0;\n    const char *argv[10];\n    int option_index;\n    int c;\n\n    argv[argc++] = \"program\";\n    argv[argc++] = \"-xtremel\";\n    argv[argc] = NULL;\n    optind = 1;\n    opterr = 0;\n    c = do_getopt_long_only (argc, argv, \"abx::\", long_options_required,\n                             &option_index);\n    /* glibc getopt_long_only is intentionally different from\n       getopt_long when handling a prefix that is common to two\n       spellings, when both spellings have the same option directives.\n       BSD getopt_long_only treats both cases the same.  */\n    ASSERT (c == 1003 || c == '?');\n    ASSERT (optind == 2);\n    ASSERT (optarg == NULL);\n  }\n  {\n    int argc = 0;\n    const char *argv[10];\n    int option_index;\n    int c;\n\n    argv[argc++] = \"program\";\n    argv[argc++] = \"-xtras\";\n    argv[argc] = NULL;\n    optind = 1;\n    opterr = 0;\n    c = do_getopt_long_only (argc, argv, \"abx::\", long_options_required,\n                             &option_index);\n    ASSERT (c == 'x');\n    ASSERT (strcmp (optarg, \"tras\") == 0);\n  }\n}",
      "lines": 206,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-getprogname.c": {
    "main": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "int\nmain (void)\n{\n  char const *p = getprogname ();\n\n  /* libtool creates a temporary executable whose name is sometimes prefixed\n     with \"lt-\" (depends on the platform).  But the name of the temporary\n     executable is a detail that should not be visible to the end user and to\n     the test suite.  Remove this \"lt-\" prefix here.  */\n  if (strncmp (p, \"lt-\", 3) == 0)\n    p += 3;\n\n  /* Note: You can make this test fail\n     a) by running it on a case-insensitive file system (such as on Windows,\n        Cygwin, or on Mac OS X with a case-insensitive HFS+ file system),\n        with an invocation that contains upper case characters, e.g.\n        test-GETPROGNAME,\n     b) by hardlinking or symlinking it to a different name (e.g. test-foo)\n        and invoking it through that name.\n     That's not the intended use. The Makefile always invokes it as\n     'test-getprogname${EXEEXT}'. */\n#if defined __CYGWIN__\n  /* The Cygwin getprogname() function strips the \".exe\" suffix. */\n  assert (STREQ (p, \"test-getprogname\"));\n#else\n  assert (STREQ (p, \"test-getprogname\" EXEEXT));\n#endif\n\n  return 0;\n}",
      "lines": 30,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-gettimeofday.c": {
    "main": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        46,
        1
      ],
      "content": "int\nmain (void)\n{\n  time_t t = 0;\n  struct tm *lt;\n  struct tm saved_lt;\n  struct timeval tv;\n  lt = localtime (&t);\n  saved_lt = *lt;\n  gettimeofday (&tv, NULL);\n  if (memcmp (lt, &saved_lt, sizeof (struct tm)) != 0)\n    {\n      fprintf (stderr, \"gettimeofday still clobbers the localtime buffer!\\n\");\n      return 1;\n    }\n  return 0;\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-ignore-value.c": {
    "doChar": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "static char\ndoChar (void)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "char"
      ]
    },
    "doInt": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "static int\ndoInt (void)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "doOff": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "static off_t\ndoOff (void)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "off_t"
      ]
    },
    "doPtr": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "static void *\ndoPtr (void)\n{\n  return NULL;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void",
        "*\ndoPtr (void)",
        "*"
      ]
    },
    "doStruct": {
      "start_point": [
        64,
        0
      ],
      "end_point": [
        69,
        1
      ],
      "content": "static struct s\ndoStruct (void)\n{\n  static struct s s1;\n  return s1;\n}",
      "lines": 6,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "struct s",
        "struct",
        "s"
      ]
    },
    "main": {
      "start_point": [
        71,
        0
      ],
      "end_point": [
        83,
        1
      ],
      "content": "int\nmain (void)\n{\n  /* If this test can compile with -Werror and the same warnings as\n     the rest of the project, then we are properly silencing warnings\n     about ignored return values.  */\n  ignore_value (doChar ());\n  ignore_value (doInt ());\n  ignore_value (doOff ());\n  ignore_value (doPtr ());\n  ignore_value (doStruct ());\n  return 0;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-inet_pton.c": {
    "main": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "int\nmain (void)\n{\n#if defined AF_INET /* HAVE_IPV4 */\n  {\n    /* This machine was for a long time known as\n       ma2s2.mathematik.uni-karlsruhe.de.  */\n    const char printable[] = \"129.13.115.2\";\n    struct in_addr internal;\n    int ret;\n\n    ret = inet_pton (AF_INET, printable, &internal);\n    ASSERT (ret == 1);\n    /* Verify that internal is filled in network byte order.  */\n    ASSERT (((unsigned char *) &internal)[0] == 0x81);\n    ASSERT (((unsigned char *) &internal)[1] == 0x0D);\n    ASSERT (((unsigned char *) &internal)[2] == 0x73);\n    ASSERT (((unsigned char *) &internal)[3] == 0x02);\n# ifdef WORDS_BIGENDIAN\n    ASSERT (internal.s_addr == 0x810D7302);\n# else\n    ASSERT (internal.s_addr == 0x02730D81);\n# endif\n  }\n#endif\n\n  return 0;\n}",
      "lines": 28,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-intprops.c": {
    "main": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        390,
        1
      ],
      "content": "int\nmain (void)\n{\n  /* Use VERIFY for tests that must be integer constant expressions,\n     ASSERT otherwise.  */\n\n  /* TYPE_IS_INTEGER.  */\n  ASSERT (TYPE_IS_INTEGER (bool));\n  ASSERT (TYPE_IS_INTEGER (char));\n  ASSERT (TYPE_IS_INTEGER (signed char));\n  ASSERT (TYPE_IS_INTEGER (unsigned char));\n  ASSERT (TYPE_IS_INTEGER (short int));\n  ASSERT (TYPE_IS_INTEGER (unsigned short int));\n  ASSERT (TYPE_IS_INTEGER (int));\n  ASSERT (TYPE_IS_INTEGER (unsigned int));\n  ASSERT (TYPE_IS_INTEGER (long int));\n  ASSERT (TYPE_IS_INTEGER (unsigned long int));\n  ASSERT (TYPE_IS_INTEGER (intmax_t));\n  ASSERT (TYPE_IS_INTEGER (uintmax_t));\n  ASSERT (! TYPE_IS_INTEGER (float));\n  ASSERT (! TYPE_IS_INTEGER (double));\n  ASSERT (! TYPE_IS_INTEGER (long double));\n\n  /* TYPE_SIGNED.  */\n  /* VERIFY (! TYPE_SIGNED (bool)); // not guaranteed by gnulib substitute */\n  VERIFY (TYPE_SIGNED (signed char));\n  VERIFY (! TYPE_SIGNED (unsigned char));\n  VERIFY (TYPE_SIGNED (short int));\n  VERIFY (! TYPE_SIGNED (unsigned short int));\n  VERIFY (TYPE_SIGNED (int));\n  VERIFY (! TYPE_SIGNED (unsigned int));\n  VERIFY (TYPE_SIGNED (long int));\n  VERIFY (! TYPE_SIGNED (unsigned long int));\n  VERIFY (TYPE_SIGNED (intmax_t));\n  VERIFY (! TYPE_SIGNED (uintmax_t));\n  ASSERT (TYPE_SIGNED (float));\n  ASSERT (TYPE_SIGNED (double));\n  ASSERT (TYPE_SIGNED (long double));\n\n  /* Integer representation.  Check that it is two's complement.  */\n  VERIFY (INT_MIN + INT_MAX < 0);\n\n  /* TYPE_MINIMUM, TYPE_MAXIMUM.  */\n  VERIFY (TYPE_MINIMUM (char) == CHAR_MIN);\n  VERIFY (TYPE_MAXIMUM (char) == CHAR_MAX);\n  VERIFY (TYPE_MINIMUM (unsigned char) == 0);\n  VERIFY (TYPE_MAXIMUM (unsigned char) == UCHAR_MAX);\n  VERIFY (TYPE_MINIMUM (signed char) == SCHAR_MIN);\n  VERIFY (TYPE_MAXIMUM (signed char) == SCHAR_MAX);\n  VERIFY (TYPE_MINIMUM (short int) == SHRT_MIN);\n  VERIFY (TYPE_MAXIMUM (short int) == SHRT_MAX);\n  VERIFY (TYPE_MINIMUM (unsigned short int) == 0);\n  VERIFY (TYPE_MAXIMUM (unsigned short int) == USHRT_MAX);\n  VERIFY (TYPE_MINIMUM (int) == INT_MIN);\n  VERIFY (TYPE_MAXIMUM (int) == INT_MAX);\n  VERIFY (TYPE_MINIMUM (unsigned int) == 0);\n  VERIFY (TYPE_MAXIMUM (unsigned int) == UINT_MAX);\n  VERIFY (TYPE_MINIMUM (long int) == LONG_MIN);\n  VERIFY (TYPE_MAXIMUM (long int) == LONG_MAX);\n  VERIFY (TYPE_MINIMUM (unsigned long int) == 0);\n  VERIFY (TYPE_MAXIMUM (unsigned long int) == ULONG_MAX);\n  #ifdef LLONG_MAX\n   verify (TYPE_MINIMUM (long long int) == LLONG_MIN);\n   verify (TYPE_MAXIMUM (long long int) == LLONG_MAX);\n  #endif\n  VERIFY (TYPE_MINIMUM (intmax_t) == INTMAX_MIN);\n  VERIFY (TYPE_MAXIMUM (intmax_t) == INTMAX_MAX);\n  VERIFY (TYPE_MINIMUM (uintmax_t) == 0);\n  VERIFY (TYPE_MAXIMUM (uintmax_t) == UINTMAX_MAX);\n\n  /* TYPE_WIDTH.  */\n  #ifdef CHAR_WIDTH\n   verify (TYPE_WIDTH (char) == CHAR_WIDTH);\n   verify (TYPE_WIDTH (signed char) == SCHAR_WIDTH);\n   verify (TYPE_WIDTH (unsigned char) == UCHAR_WIDTH);\n   verify (TYPE_WIDTH (short int) == SHRT_WIDTH);\n   verify (TYPE_WIDTH (unsigned short int) == USHRT_WIDTH);\n   verify (TYPE_WIDTH (int) == INT_WIDTH);\n   verify (TYPE_WIDTH (unsigned int) == UINT_WIDTH);\n   verify (TYPE_WIDTH (long int) == LONG_WIDTH);\n   verify (TYPE_WIDTH (unsigned long int) == ULONG_WIDTH);\n   #ifdef LLONG_WIDTH\n    verify (TYPE_WIDTH (long long int) == LLONG_WIDTH);\n    verify (TYPE_WIDTH (unsigned long long int) == ULLONG_WIDTH);\n   #endif\n  #endif\n\n  /* INT_BITS_STRLEN_BOUND.  */\n  VERIFY (INT_BITS_STRLEN_BOUND (1) == 1);\n  VERIFY (INT_BITS_STRLEN_BOUND (2620) == 789);\n\n  /* INT_STRLEN_BOUND, INT_BUFSIZE_BOUND.  */\n  #ifdef INT32_MAX /* POSIX guarantees int32_t; this ports to non-POSIX.  */\n  VERIFY (INT_STRLEN_BOUND (int32_t) == sizeof (\"-2147483648\") - 1);\n  VERIFY (INT_BUFSIZE_BOUND (int32_t) == sizeof (\"-2147483648\"));\n  #endif\n  #ifdef INT64_MAX\n  VERIFY (INT_STRLEN_BOUND (int64_t) == sizeof (\"-9223372036854775808\") - 1);\n  VERIFY (INT_BUFSIZE_BOUND (int64_t) == sizeof (\"-9223372036854775808\"));\n  #endif\n\n  /* All the INT_<op>_RANGE_OVERFLOW tests are equally valid as\n     INT_<op>_OVERFLOW tests, so define macros to do both.  OP is the\n     operation, OPNAME its symbolic name, A and B its operands, T the\n     result type, V the overflow flag, and VRES the result if V and if\n     two's complement.  CHECK_BINOP is for most binary operatinos,\n     CHECK_SBINOP for binary +, -, * when the result type is signed,\n     and CHECK_UNOP for unary operations.  */\n  #define CHECK_BINOP(op, opname, a, b, t, v, vres)                       \\\n    VERIFY (INT_##opname##_RANGE_OVERFLOW (a, b, TYPE_MINIMUM (t),        \\\n                                           TYPE_MAXIMUM (t))              \\\n            == (v));                                                      \\\n    VERIFY (INT_##opname##_OVERFLOW (a, b) == (v))\n  #define CHECK_SBINOP(op, opname, a, b, t, v, vres)                      \\\n    CHECK_BINOP(op, opname, a, b, t, v, vres);                            \\\n    {                                                                     \\\n      t result;                                                           \\\n      ASSERT (INT_##opname##_WRAPV (a, b, &result) == (v));               \\\n      ASSERT (result == ((v) ? (vres) : ((a) op (b))));                   \\\n    }\n  #define CHECK_UNOP(op, opname, a, t, v)                                 \\\n    VERIFY (INT_##opname##_RANGE_OVERFLOW (a, TYPE_MINIMUM (t),           \\\n                                           TYPE_MAXIMUM (t))              \\\n            == (v));                                                      \\\n    VERIFY (INT_##opname##_OVERFLOW (a) == (v))\n\n  /* INT_<op>_RANGE_OVERFLOW, INT_<op>_OVERFLOW.  */\n  VERIFY (INT_ADD_RANGE_OVERFLOW (INT_MAX, 1, INT_MIN, INT_MAX));\n  VERIFY (INT_ADD_OVERFLOW (INT_MAX, 1));\n\n  CHECK_SBINOP (+, ADD, INT_MAX, 1, int, true, INT_MIN);\n  CHECK_SBINOP (+, ADD, INT_MAX, -1, int, false, INT_MAX - 1);\n  CHECK_SBINOP (+, ADD, INT_MIN, 1, int, false, INT_MIN + 1);\n  CHECK_SBINOP (+, ADD, INT_MIN, -1, int, true, INT_MAX);\n  CHECK_BINOP (+, ADD, UINT_MAX, 1u, unsigned int, true, 0u);\n  CHECK_BINOP (+, ADD, 0u, 1u, unsigned int, false, 1u);\n\n  CHECK_SBINOP (-, SUBTRACT, INT_MAX, 1, int, false, INT_MAX - 1);\n  CHECK_SBINOP (-, SUBTRACT, INT_MAX, -1, int, true, INT_MIN);\n  CHECK_SBINOP (-, SUBTRACT, INT_MIN, 1, int, true, INT_MAX);\n  CHECK_SBINOP (-, SUBTRACT, INT_MIN, -1, int, false, INT_MIN - -1);\n  CHECK_BINOP (-, SUBTRACT, UINT_MAX, 1u, unsigned int, false, UINT_MAX - 1u);\n  CHECK_BINOP (-, SUBTRACT, 0u, 1u, unsigned int, true, 0u - 1u);\n\n  CHECK_UNOP (-, NEGATE, INT_MIN, int, true);\n  CHECK_UNOP (-, NEGATE, 0, int, false);\n  CHECK_UNOP (-, NEGATE, INT_MAX, int, false);\n  CHECK_UNOP (-, NEGATE, 0u, unsigned int, false);\n  CHECK_UNOP (-, NEGATE, 1u, unsigned int, true);\n  CHECK_UNOP (-, NEGATE, UINT_MAX, unsigned int, true);\n\n  CHECK_SBINOP (*, MULTIPLY, INT_MAX, INT_MAX, int, true, 1);\n  CHECK_SBINOP (*, MULTIPLY, INT_MAX, INT_MIN, int, true, INT_MIN);\n  CHECK_SBINOP (*, MULTIPLY, INT_MIN, INT_MAX, int, true, INT_MIN);\n  CHECK_SBINOP (*, MULTIPLY, INT_MIN, INT_MIN, int, true, 0);\n  CHECK_SBINOP (*, MULTIPLY, -1, INT_MIN, int,\n                INT_NEGATE_OVERFLOW (INT_MIN), INT_MIN);\n  CHECK_SBINOP (*, MULTIPLY, LONG_MIN / INT_MAX, (long int) INT_MAX,\n                long int, false, LONG_MIN - LONG_MIN % INT_MAX);\n\n  CHECK_BINOP (/, DIVIDE, INT_MIN, -1, int,\n               INT_NEGATE_OVERFLOW (INT_MIN), INT_MIN);\n  CHECK_BINOP (/, DIVIDE, INT_MAX, 1, int, false, INT_MAX);\n  CHECK_BINOP (/, DIVIDE, (unsigned int) INT_MIN, -1u, unsigned int,\n               false, INT_MIN / -1u);\n\n  CHECK_BINOP (%, REMAINDER, INT_MIN, -1, int, INT_NEGATE_OVERFLOW (INT_MIN), 0);\n  CHECK_BINOP (%, REMAINDER, INT_MAX, 1, int, false, 0);\n  CHECK_BINOP (%, REMAINDER, (unsigned int) INT_MIN, -1u, unsigned int,\n               false, INT_MIN % -1u);\n\n  CHECK_BINOP (<<, LEFT_SHIFT, UINT_MAX, 1, unsigned int, true, UINT_MAX << 1);\n  CHECK_BINOP (<<, LEFT_SHIFT, UINT_MAX / 2 + 1, 1, unsigned int, true,\n               (UINT_MAX / 2 + 1) << 1);\n  CHECK_BINOP (<<, LEFT_SHIFT, UINT_MAX / 2, 1, unsigned int, false,\n               (UINT_MAX / 2) << 1);\n\n  /* INT_<op>_OVERFLOW and INT_<op>_WRAPV with mixed types.  */\n  #define CHECK_SUM(a, b, t, v, vres)                                     \\\n    CHECK_SUM1(a, b, t, v, vres);                                         \\\n    CHECK_SUM1(b, a, t, v, vres)\n  #define CHECK_SSUM(a, b, t, v, vres)                                    \\\n    CHECK_SSUM1(a, b, t, v, vres);                                        \\\n    CHECK_SSUM1(b, a, t, v, vres)\n  #define CHECK_SUM1(a, b, t, v, vres)                                    \\\n    VERIFY (INT_ADD_OVERFLOW (a, b) == (v))\n  #define CHECK_SSUM1(a, b, t, v, vres)                                   \\\n    CHECK_SUM1(a, b, t, v, vres);                                         \\\n    {                                                                     \\\n      t result;                                                           \\\n      ASSERT (INT_ADD_WRAPV (a, b, &result) == (v));                      \\\n      ASSERT (result == ((v) ? (vres) : ((a) + (b))));                    \\\n    }\n  CHECK_SSUM (-1, LONG_MIN, long int, true, LONG_MAX);\n  CHECK_SUM (-1, UINT_MAX, unsigned int, false, DONTCARE);\n  CHECK_SSUM (-1L, INT_MIN, long int, INT_MIN == LONG_MIN,\n              INT_MIN == LONG_MIN ? INT_MAX : DONTCARE);\n  CHECK_SUM (0u, -1, unsigned int, true, 0u + -1);\n  CHECK_SUM (0u, 0, unsigned int, false, DONTCARE);\n  CHECK_SUM (0u, 1, unsigned int, false, DONTCARE);\n  CHECK_SSUM (1, LONG_MAX, long int, true, LONG_MIN);\n  CHECK_SUM (1, UINT_MAX, unsigned int, true, 0u);\n  CHECK_SSUM (1L, INT_MAX, long int, INT_MAX == LONG_MAX,\n              INT_MAX == LONG_MAX ? INT_MIN : DONTCARE);\n  CHECK_SUM (1u, INT_MAX, unsigned int, INT_MAX == UINT_MAX, 1u + INT_MAX);\n  CHECK_SUM (1u, INT_MIN, unsigned int, true, 1u + INT_MIN);\n  {\n    long int result;\n    ASSERT (INT_ADD_WRAPV (1, INT_MAX, &result) == (INT_MAX == LONG_MAX));\n    ASSERT (INT_ADD_WRAPV (-1, INT_MIN, &result) == (INT_MIN == LONG_MIN));\n  }\n\n  #define CHECK_DIFFERENCE(a, b, t, v, vres)                              \\\n    VERIFY (INT_SUBTRACT_OVERFLOW (a, b) == (v))\n  #define CHECK_SDIFFERENCE(a, b, t, v, vres)                             \\\n    CHECK_DIFFERENCE(a, b, t, v, vres);                                   \\\n    {                                                                     \\\n      t result;                                                           \\\n      ASSERT (INT_SUBTRACT_WRAPV (a, b, &result) == (v));                 \\\n      ASSERT (result == ((v) ? (vres) : ((a) - (b))));                    \\\n    }\n  CHECK_DIFFERENCE (INT_MAX, 1u, unsigned int, UINT_MAX < INT_MAX - 1,\n                    INT_MAX - 1u);\n  CHECK_DIFFERENCE (UINT_MAX, 1, unsigned int, false, UINT_MAX - 1);\n  CHECK_DIFFERENCE (0u, -1, unsigned int, false, 0u - -1);\n  CHECK_DIFFERENCE (UINT_MAX, -1, unsigned int, true, UINT_MAX - -1);\n  CHECK_DIFFERENCE (INT_MIN, 1u, unsigned int, true, INT_MIN - 1u);\n  CHECK_DIFFERENCE (-1, 0u, unsigned int, true, -1 - 0u);\n  CHECK_SDIFFERENCE (-1, INT_MIN, int, false, -1 - INT_MIN);\n  CHECK_SDIFFERENCE (-1, INT_MAX, int, false, -1 - INT_MAX);\n  CHECK_SDIFFERENCE (0, INT_MIN, int, INT_MIN < -INT_MAX, INT_MIN);\n  CHECK_SDIFFERENCE (0, INT_MAX, int, false, 0 - INT_MAX);\n  {\n    long int result;\n    ASSERT (INT_SUBTRACT_WRAPV (INT_MAX, -1, &result) == (INT_MAX == LONG_MAX));\n    ASSERT (INT_SUBTRACT_WRAPV (INT_MIN, 1, &result) == (INT_MAX == LONG_MAX));\n  }\n\n  #define CHECK_PRODUCT(a, b, t, v, vres)                                 \\\n    CHECK_PRODUCT1(a, b, t, v, vres);                                     \\\n    CHECK_PRODUCT1(b, a, t, v, vres)\n  #define CHECK_SPRODUCT(a, b, t, v, vres)                                \\\n    CHECK_SPRODUCT1(a, b, t, v, vres);                                    \\\n    CHECK_SPRODUCT1(b, a, t, v, vres)\n  #define CHECK_PRODUCT1(a, b, t, v, vres)                                \\\n    VERIFY (INT_MULTIPLY_OVERFLOW (a, b) == (v))\n  #define CHECK_SPRODUCT1(a, b, t, v, vres)                               \\\n    CHECK_PRODUCT1(a, b, t, v, vres);                                     \\\n    {                                                                     \\\n      t result;                                                           \\\n      ASSERT (INT_MULTIPLY_WRAPV (a, b, &result) == (v));                 \\\n      ASSERT (result == ((v) ? (vres) : ((a) * (b))));                    \\\n    }\n  CHECK_PRODUCT (-1, 1u, unsigned int, true, -1 * 1u);\n  CHECK_SPRODUCT (-1, INT_MIN, int, INT_NEGATE_OVERFLOW (INT_MIN), INT_MIN);\n  CHECK_PRODUCT (-1, UINT_MAX, unsigned int, true, -1 * UINT_MAX);\n  CHECK_SPRODUCT (-32768, LONG_MAX / -32768 - 1, long int, true, LONG_MIN);\n  CHECK_SPRODUCT (-12345, LONG_MAX / -12345, long int, false, DONTCARE);\n  CHECK_SPRODUCT (0, -1, int, false, DONTCARE);\n  CHECK_SPRODUCT (0, 0, int, false, DONTCARE);\n  CHECK_PRODUCT (0, 0u, unsigned int, false, DONTCARE);\n  CHECK_SPRODUCT (0, 1, int, false, DONTCARE);\n  CHECK_SPRODUCT (0, INT_MAX, int, false, DONTCARE);\n  CHECK_SPRODUCT (0, INT_MIN, int, false, DONTCARE);\n  CHECK_PRODUCT (0, UINT_MAX, unsigned int, false, DONTCARE);\n  CHECK_PRODUCT (0u, -1, unsigned int, false, DONTCARE);\n  CHECK_PRODUCT (0u, 0, unsigned int, false, DONTCARE);\n  CHECK_PRODUCT (0u, 0u, unsigned int, false, DONTCARE);\n  CHECK_PRODUCT (0u, 1, unsigned int, false, DONTCARE);\n  CHECK_PRODUCT (0u, INT_MAX, unsigned int, false, DONTCARE);\n  CHECK_PRODUCT (0u, INT_MIN, unsigned int, false, DONTCARE);\n  CHECK_PRODUCT (0u, UINT_MAX, unsigned int, false, DONTCARE);\n  CHECK_SPRODUCT (1, INT_MAX, int, false, DONTCARE);\n  CHECK_SPRODUCT (1, INT_MIN, int, false, DONTCARE);\n  CHECK_PRODUCT (1, UINT_MAX, unsigned int, false, DONTCARE);\n  CHECK_PRODUCT (1u, INT_MIN, unsigned int, true, 1u * INT_MIN);\n  CHECK_PRODUCT (1u, INT_MAX, unsigned int, UINT_MAX < INT_MAX, 1u * INT_MAX);\n  CHECK_PRODUCT (INT_MAX, UINT_MAX, unsigned int, true, INT_MAX * UINT_MAX);\n  CHECK_PRODUCT (INT_MAX, ULONG_MAX, unsigned long int, true,\n                 INT_MAX * ULONG_MAX);\n  CHECK_SPRODUCT (INT_MIN, LONG_MAX / INT_MIN - 1, long int, true, LONG_MIN);\n  CHECK_SPRODUCT (INT_MIN, LONG_MAX / INT_MIN, long int, false, DONTCARE);\n  CHECK_PRODUCT (INT_MIN, UINT_MAX, unsigned int, true, INT_MIN * UINT_MAX);\n  CHECK_PRODUCT (INT_MIN, ULONG_MAX, unsigned long int, true,\n                 INT_MIN * ULONG_MAX);\n  {\n    long int result;\n    ASSERT (INT_MULTIPLY_WRAPV (INT_MAX, INT_MAX, &result)\n            == (LONG_MAX / INT_MAX < INT_MAX));\n    ASSERT (INT_MULTIPLY_WRAPV (INT_MAX, INT_MAX, &result)\n            || result == INT_MAX * (long int) INT_MAX);\n    ASSERT (INT_MULTIPLY_WRAPV (INT_MIN, INT_MIN, &result)\n            || result == INT_MIN * (long int) INT_MIN);\n  }\n\n# ifdef LLONG_MAX\n  {\n    long long int result;\n    ASSERT (INT_MULTIPLY_WRAPV (LONG_MAX, LONG_MAX, &result)\n            == (LLONG_MAX / LONG_MAX < LONG_MAX));\n    ASSERT (INT_MULTIPLY_WRAPV (LONG_MAX, LONG_MAX, &result)\n            || result == LONG_MAX * (long long int) LONG_MAX);\n    ASSERT (INT_MULTIPLY_WRAPV (LONG_MIN, LONG_MIN, &result)\n            || result == LONG_MIN * (long long int) LONG_MIN);\n  }\n# endif\n\n  #define CHECK_QUOTIENT(a, b, v) VERIFY (INT_DIVIDE_OVERFLOW (a, b) == (v))\n\n  CHECK_QUOTIENT (INT_MIN, -1L, INT_MIN == LONG_MIN);\n  CHECK_QUOTIENT (INT_MIN, UINT_MAX, false);\n  CHECK_QUOTIENT (INTMAX_MIN, UINTMAX_MAX, false);\n  CHECK_QUOTIENT (INTMAX_MIN, UINT_MAX, false);\n  CHECK_QUOTIENT (-11, 10u, true);\n  CHECK_QUOTIENT (-10, 10u, true);\n  CHECK_QUOTIENT (-9, 10u, false);\n  CHECK_QUOTIENT (11u, -10, true);\n  CHECK_QUOTIENT (10u, -10, true);\n  CHECK_QUOTIENT (9u, -10, false);\n\n  #define CHECK_REMAINDER(a, b, v) VERIFY (INT_REMAINDER_OVERFLOW (a, b) == (v))\n\n  CHECK_REMAINDER (INT_MIN, -1L, INT_MIN == LONG_MIN);\n  CHECK_REMAINDER (-1, UINT_MAX, true);\n  CHECK_REMAINDER ((intmax_t) -1, UINTMAX_MAX, true);\n  CHECK_REMAINDER (INTMAX_MIN, UINT_MAX,\n                   (INTMAX_MAX < UINT_MAX\n                    && - (unsigned int) INTMAX_MIN % UINT_MAX != 0));\n  CHECK_REMAINDER (INT_MIN, ULONG_MAX, INT_MIN % ULONG_MAX != 1);\n  CHECK_REMAINDER (1u, -1, false);\n  CHECK_REMAINDER (37*39u, -39, false);\n  CHECK_REMAINDER (37*39u + 1, -39, true);\n  CHECK_REMAINDER (37*39u - 1, -39, true);\n  CHECK_REMAINDER (LONG_MAX, -INT_MAX, false);\n\n  return 0;\n}",
      "lines": 337,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-inttypes.c": {
    "main": {
      "start_point": [
        113,
        0
      ],
      "end_point": [
        117,
        1
      ],
      "content": "int\nmain (void)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-ioctl.c": {
    "main": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "int\nmain (void)\n{\n#ifdef FIONREAD\n  /* Test behaviour for invalid file descriptors.  */\n  {\n    int value;\n    errno = 0;\n    ASSERT (ioctl (-1, FIONREAD, &value) == -1);\n    ASSERT (errno == EBADF);\n  }\n  {\n    int value;\n    close (99);\n    errno = 0;\n    ASSERT (ioctl (99, FIONREAD, &value) == -1);\n    ASSERT (errno == EBADF);\n  }\n#endif\n\n  return 0;\n}",
      "lines": 22,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-isblank.c": {
    "main": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  unsigned int c;\n\n  /* Verify the property in the \"C\" locale.\n     POSIX specifies in\n       <http://www.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap07.html>\n     that\n       - in all locales, the blank characters include the <space> and <tab>\n         characters,\n       - in the \"POSIX\" locale (which is usually the same as the \"C\" locale),\n         the blank characters include only the ASCII <space> and <tab>\n         characters.  */\n  for (c = 0; c <= UCHAR_MAX; c++)\n    ASSERT (!isblank (c) == !(c == ' ' || c == '\\t'));\n  ASSERT (!isblank (EOF));\n\n  return 0;\n}",
      "lines": 20,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-langinfo.c": {
    "main": {
      "start_point": [
        87,
        0
      ],
      "end_point": [
        91,
        1
      ],
      "content": "int\nmain (void)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-limits-h.c": {
    "main": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "int\nmain (void)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-link.c": {
    "main": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        46,
        1
      ],
      "content": "int\nmain (void)\n{\n  /* Remove any garbage left from previous partial runs.  */\n  ignore_value (system (\"rm -rf \" BASE \"*\"));\n\n  return test_link (link, true);\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-link.h": {
    "test_link": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        181,
        1
      ],
      "content": "static int\ntest_link (int (*func) (char const *, char const *), bool print)\n{\n  int fd;\n  int ret;\n\n  /* Create first file.  */\n  fd = open (BASE \"a\", O_CREAT | O_EXCL | O_WRONLY, 0600);\n  ASSERT (0 <= fd);\n  ASSERT (write (fd, \"hello\", 5) == 5);\n  ASSERT (close (fd) == 0);\n\n  /* Not all file systems support link.  Mingw doesn't have reliable\n     st_nlink on hard links, but our implementation does fail with\n     EPERM on poor file systems, and we can detect the inferior stat()\n     via st_ino.  Cygwin 1.5.x copies rather than links files on those\n     file systems, but there, st_nlink and st_ino are reliable.  */\n  ret = func (BASE \"a\", BASE \"b\");\n  if (!ret)\n  {\n    struct stat st;\n    ASSERT (stat (BASE \"b\", &st) == 0);\n    if (st.st_ino && st.st_nlink != 2)\n      {\n        ASSERT (unlink (BASE \"b\") == 0);\n        errno = EPERM;\n        ret = -1;\n      }\n  }\n  if (ret == -1)\n    {\n      /* If the device does not support hard links, errno is\n         EPERM on Linux, EOPNOTSUPP on FreeBSD.  */\n      switch (errno)\n        {\n        case EPERM:\n        case EOPNOTSUPP:\n          if (print)\n            fputs (\"skipping test: \"\n                   \"hard links not supported on this file system\\n\",\n                   stderr);\n          ASSERT (unlink (BASE \"a\") == 0);\n          return 77;\n        default:\n          perror (\"link\");\n          return 1;\n        }\n    }\n  ASSERT (ret == 0);\n\n  /* Now, for some behavior tests.  Modify the contents of 'b', and\n     ensure that 'a' can see it, both while 'b' exists and after.  */\n  fd = open (BASE \"b\", O_APPEND | O_WRONLY);\n  ASSERT (0 <= fd);\n  ASSERT (write (fd, \"world\", 5) == 5);\n  ASSERT (close (fd) == 0);\n  {\n    char buf[11] = { 0 };\n    fd = open (BASE \"a\", O_RDONLY);\n    ASSERT (0 <= fd);\n    ASSERT (read (fd, buf, 10) == 10);\n    ASSERT (strcmp (buf, \"helloworld\") == 0);\n    ASSERT (close (fd) == 0);\n    ASSERT (unlink (BASE \"b\") == 0);\n    fd = open (BASE \"a\", O_RDONLY);\n    ASSERT (0 <= fd);\n    ASSERT (read (fd, buf, 10) == 10);\n    ASSERT (strcmp (buf, \"helloworld\") == 0);\n    ASSERT (close (fd) == 0);\n  }\n\n  /* Test for various error conditions.  */\n  ASSERT (mkdir (BASE \"d\", 0700) == 0);\n  errno = 0;\n  ASSERT (func (BASE \"a\", \".\") == -1);\n  ASSERT (errno == EEXIST || errno == EINVAL);\n  errno = 0;\n  ASSERT (func (BASE \"a\", BASE \"a\") == -1);\n  ASSERT (errno == EEXIST);\n  ASSERT (func (BASE \"a\", BASE \"b\") == 0);\n  errno = 0;\n  ASSERT (func (BASE \"a\", BASE \"b\") == -1);\n  ASSERT (errno == EEXIST);\n  errno = 0;\n  ASSERT (func (BASE \"a\", BASE \"d\") == -1);\n  ASSERT (errno == EEXIST);\n  errno = 0;\n  ASSERT (func (BASE \"c\", BASE \"e\") == -1);\n  ASSERT (errno == ENOENT);\n  errno = 0;\n  ASSERT (func (BASE \"a\", BASE \"c/.\") == -1);\n  ASSERT (errno == ENOENT);\n  errno = 0;\n  ASSERT (func (BASE \"a/\", BASE \"c\") == -1);\n  ASSERT (errno == ENOTDIR || errno == EINVAL);\n  errno = 0;\n  ASSERT (func (BASE \"a\", BASE \"c/\") == -1);\n  ASSERT (errno == ENOTDIR || errno == ENOENT || errno == EINVAL);\n\n  /* Most platforms reject hard links to directories, and even on\n     those that do permit it, most users can't create them.  We assume\n     that if this test is run as root and we managed to create a hard\n     link, then unlink better be able to clean it up.  */\n  {\n    int result;\n    errno = 0;\n    result = func (BASE \"d\", BASE \"c\");\n    if (result == 0)\n      {\n        /* Probably root on Solaris.  */\n        ASSERT (unlink (BASE \"c\") == 0);\n      }\n    else\n      {\n        /* Most everyone else.  */\n        ASSERT (errno == EPERM || errno == EACCES || errno == EISDIR);\n        errno = 0;\n        ASSERT (func (BASE \"d/.\", BASE \"c\") == -1);\n        ASSERT (errno == EPERM || errno == EACCES || errno == EISDIR\n                || errno == EINVAL);\n        errno = 0;\n        ASSERT (func (BASE \"d/.//\", BASE \"c\") == -1);\n        ASSERT (errno == EPERM || errno == EACCES || errno == EISDIR\n                || errno == EINVAL);\n      }\n  }\n  ASSERT (unlink (BASE \"a\") == 0);\n  errno = 0;\n  ASSERT (unlink (BASE \"c\") == -1);\n  ASSERT (errno == ENOENT);\n  ASSERT (rmdir (BASE \"d\") == 0);\n\n  /* Test invalid use of symlink.  */\n  if (symlink (BASE \"a\", BASE \"link\") != 0)\n    {\n      ASSERT (unlink (BASE \"b\") == 0);\n      if (print)\n        fputs (\"skipping test: symlinks not supported on this file system\\n\",\n               stderr);\n      return 77;\n    }\n  errno = 0;\n  ASSERT (func (BASE \"b\", BASE \"link/\") == -1);\n  ASSERT (errno == ENOTDIR || errno == ENOENT || errno == EEXIST\n          || errno == EINVAL);\n  errno = 0;\n  ASSERT (func (BASE \"b\", BASE \"link\") == -1);\n  ASSERT (errno == EEXIST);\n  ASSERT (rename (BASE \"b\", BASE \"a\") == 0);\n  errno = 0;\n  ASSERT (func (BASE \"link/\", BASE \"b\") == -1);\n  ASSERT (errno == ENOTDIR || errno == EEXIST || errno == EINVAL);\n\n  /* Clean up.  */\n  ASSERT (unlink (BASE \"a\") == 0);\n  ASSERT (unlink (BASE \"link\") == 0);\n\n  return 0;\n}",
      "lines": 159,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-listen.c": {
    "main": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "int\nmain (void)\n{\n  (void) gl_sockets_startup (SOCKETS_1_1);\n\n  /* Test behaviour for invalid file descriptors.  */\n  {\n    errno = 0;\n    ASSERT (listen (-1, 1) == -1);\n    ASSERT (errno == EBADF);\n  }\n  {\n    close (99);\n    errno = 0;\n    ASSERT (listen (99 ,1) == -1);\n    ASSERT (errno == EBADF);\n  }\n\n  return 0;\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-locale.c": {
    "main": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "int\nmain ()\n{\n#if HAVE_NEWLOCALE\n  /* Check that the locale_t type and the LC_GLOBAL_LOCALE macro are defined.  */\n  locale_t b = LC_GLOBAL_LOCALE;\n  (void) b;\n#endif\n\n  /* Check that 'struct lconv' has the ISO C and POSIX specified members.  */\n  ls += sizeof (*l.decimal_point);\n  ls += sizeof (*l.thousands_sep);\n  ls += sizeof (*l.grouping);\n  ls += sizeof (*l.mon_decimal_point);\n  ls += sizeof (*l.mon_thousands_sep);\n  ls += sizeof (*l.mon_grouping);\n  ls += sizeof (*l.positive_sign);\n  ls += sizeof (*l.negative_sign);\n  ls += sizeof (*l.currency_symbol);\n  ls += sizeof (l.frac_digits);\n  ls += sizeof (l.p_cs_precedes);\n  ls += sizeof (l.p_sign_posn);\n  ls += sizeof (l.p_sep_by_space);\n  ls += sizeof (l.n_cs_precedes);\n  ls += sizeof (l.n_sign_posn);\n  ls += sizeof (l.n_sep_by_space);\n  ls += sizeof (*l.int_curr_symbol);\n  ls += sizeof (l.int_frac_digits);\n  ls += sizeof (l.int_p_cs_precedes);\n  ls += sizeof (l.int_p_sign_posn);\n  ls += sizeof (l.int_p_sep_by_space);\n  ls += sizeof (l.int_n_cs_precedes);\n  ls += sizeof (l.int_n_sign_posn);\n  ls += sizeof (l.int_n_sep_by_space);\n\n  return 0;\n}",
      "lines": 37,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-localeconv.c": {
    "main": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "int\nmain ()\n{\n  /* Test localeconv() result in the \"C\" locale.  */\n  {\n    struct lconv *l = localeconv ();\n\n    ASSERT (STREQ (l->decimal_point, \".\"));\n    ASSERT (STREQ (l->thousands_sep, \"\"));\n#if !((defined __FreeBSD__ || defined __DragonFly__) || defined __sun)\n    ASSERT (STREQ (l->grouping, \"\"));\n#endif\n\n    ASSERT (STREQ (l->mon_decimal_point, \"\"));\n    ASSERT (STREQ (l->mon_thousands_sep, \"\"));\n#if !((defined __FreeBSD__ || defined __DragonFly__) || defined __sun)\n    ASSERT (STREQ (l->mon_grouping, \"\"));\n#endif\n    ASSERT (STREQ (l->positive_sign, \"\"));\n    ASSERT (STREQ (l->negative_sign, \"\"));\n\n    ASSERT (STREQ (l->currency_symbol, \"\"));\n    ASSERT (l->frac_digits == CHAR_MAX);\n    ASSERT (l->p_cs_precedes == CHAR_MAX);\n    ASSERT (l->p_sign_posn == CHAR_MAX);\n    ASSERT (l->p_sep_by_space == CHAR_MAX);\n    ASSERT (l->n_cs_precedes == CHAR_MAX);\n    ASSERT (l->n_sign_posn == CHAR_MAX);\n    ASSERT (l->n_sep_by_space == CHAR_MAX);\n\n    ASSERT (STREQ (l->int_curr_symbol, \"\"));\n    ASSERT (l->int_frac_digits == CHAR_MAX);\n    ASSERT (l->int_p_cs_precedes == CHAR_MAX);\n    ASSERT (l->int_p_sign_posn == CHAR_MAX);\n    ASSERT (l->int_p_sep_by_space == CHAR_MAX);\n    ASSERT (l->int_n_cs_precedes == CHAR_MAX);\n    ASSERT (l->int_n_sign_posn == CHAR_MAX);\n    ASSERT (l->int_n_sep_by_space == CHAR_MAX);\n  }\n\n  return 0;\n}",
      "lines": 42,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-localename.c": {
    "test_locale_name": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        225,
        1
      ],
      "content": "static void\ntest_locale_name (void)\n{\n  const char *name;\n\n  /* Check that gl_locale_name returns non-NULL.  */\n  ASSERT (gl_locale_name (LC_MESSAGES, \"LC_MESSAGES\") != NULL);\n\n  /* Get into a defined state,  */\n  setlocale (LC_ALL, \"en_US.UTF-8\");\n#if HAVE_NEWLOCALE && HAVE_USELOCALE\n  uselocale (LC_GLOBAL_LOCALE);\n#endif\n\n  /* Check that when all environment variables are unset,\n     gl_locale_name returns the default locale.  */\n  unsetenv (\"LC_ALL\");\n  unsetenv (\"LC_CTYPE\");\n  unsetenv (\"LC_MESSAGES\");\n  unsetenv (\"LC_NUMERIC\");\n  unsetenv (\"LANG\");\n  setlocale (LC_ALL, \"\");\n  ASSERT (strcmp (gl_locale_name (LC_MESSAGES, \"LC_MESSAGES\"),\n                  gl_locale_name_default ()) == 0);\n  ASSERT (strcmp (gl_locale_name (LC_NUMERIC, \"LC_NUMERIC\"),\n                  gl_locale_name_default ()) == 0);\n\n  /* Check that an empty environment variable is treated like an unset\n     environment variable.  */\n\n  setenv (\"LC_ALL\", \"\", 1);\n  unsetenv (\"LC_CTYPE\");\n  unsetenv (\"LC_MESSAGES\");\n  unsetenv (\"LANG\");\n  setlocale (LC_ALL, \"\");\n  ASSERT (strcmp (gl_locale_name (LC_MESSAGES, \"LC_MESSAGES\"),\n                  gl_locale_name_default ()) == 0);\n\n  unsetenv (\"LC_ALL\");\n  setenv (\"LC_CTYPE\", \"\", 1);\n  unsetenv (\"LC_MESSAGES\");\n  unsetenv (\"LANG\");\n  setlocale (LC_ALL, \"\");\n  ASSERT (strcmp (gl_locale_name (LC_MESSAGES, \"LC_MESSAGES\"),\n                  gl_locale_name_default ()) == 0);\n\n  unsetenv (\"LC_ALL\");\n  unsetenv (\"LC_CTYPE\");\n  setenv (\"LC_MESSAGES\", \"\", 1);\n  unsetenv (\"LANG\");\n  setlocale (LC_ALL, \"\");\n  ASSERT (strcmp (gl_locale_name (LC_MESSAGES, \"LC_MESSAGES\"),\n                  gl_locale_name_default ()) == 0);\n\n  unsetenv (\"LC_ALL\");\n  unsetenv (\"LC_CTYPE\");\n  unsetenv (\"LC_MESSAGES\");\n  setenv (\"LANG\", \"\", 1);\n  setlocale (LC_ALL, \"\");\n  ASSERT (strcmp (gl_locale_name (LC_MESSAGES, \"LC_MESSAGES\"),\n                  gl_locale_name_default ()) == 0);\n\n  /* Check that LC_ALL overrides the others, and LANG is overridden by the\n     others.  */\n\n  setenv (\"LC_ALL\", \"C\", 1);\n  unsetenv (\"LC_CTYPE\");\n  unsetenv (\"LC_MESSAGES\");\n  unsetenv (\"LANG\");\n  setlocale (LC_ALL, \"\");\n  ASSERT (strcmp (gl_locale_name (LC_MESSAGES, \"LC_MESSAGES\"), \"C\") == 0);\n\n  unsetenv (\"LC_ALL\");\n  setenv (\"LC_CTYPE\", \"C\", 1);\n  setenv (\"LC_MESSAGES\", \"C\", 1);\n  unsetenv (\"LANG\");\n  setlocale (LC_ALL, \"\");\n  ASSERT (strcmp (gl_locale_name (LC_MESSAGES, \"LC_MESSAGES\"), \"C\") == 0);\n\n  unsetenv (\"LC_ALL\");\n  unsetenv (\"LC_CTYPE\");\n  unsetenv (\"LC_MESSAGES\");\n  setenv (\"LANG\", \"C\", 1);\n  setlocale (LC_ALL, \"\");\n  ASSERT (strcmp (gl_locale_name (LC_MESSAGES, \"LC_MESSAGES\"), \"C\") == 0);\n\n  /* Check mixed situations.  */\n\n  unsetenv (\"LC_ALL\");\n  unsetenv (\"LC_CTYPE\");\n  setenv (\"LC_MESSAGES\", \"fr_FR.UTF-8\", 1);\n  setenv (\"LANG\", \"de_DE.UTF-8\", 1);\n  if (setlocale (LC_ALL, \"\") != NULL)\n    {\n      name = gl_locale_name (LC_CTYPE, \"LC_CTYPE\");\n      ASSERT (strcmp (name, \"de_DE.UTF-8\") == 0);\n      name = gl_locale_name (LC_MESSAGES, \"LC_MESSAGES\");\n      ASSERT (strcmp (name, \"fr_FR.UTF-8\") == 0);\n    }\n\n  unsetenv (\"LC_ALL\");\n  unsetenv (\"LC_CTYPE\");\n  setenv (\"LC_MESSAGES\", \"fr_FR.UTF-8\", 1);\n  unsetenv (\"LANG\");\n  if (setlocale (LC_ALL, \"\") != NULL)\n    {\n      name = gl_locale_name (LC_CTYPE, \"LC_CTYPE\");\n      ASSERT (strcmp (name, gl_locale_name_default ()) == 0);\n      name = gl_locale_name (LC_MESSAGES, \"LC_MESSAGES\");\n      ASSERT (strcmp (name, \"fr_FR.UTF-8\") == 0);\n    }\n\n#if HAVE_NEWLOCALE && HAVE_USELOCALE\n  /* Check that gl_locale_name considers the thread locale.  */\n  {\n    locale_t locale = newlocale (LC_ALL_MASK, \"fr_FR.UTF-8\", NULL);\n    if (locale != NULL)\n      {\n        uselocale (locale);\n        name = gl_locale_name (LC_CTYPE, \"LC_CTYPE\");\n        ASSERT (strcmp (name, \"fr_FR.UTF-8\") == 0);\n        name = gl_locale_name (LC_MESSAGES, \"LC_MESSAGES\");\n        ASSERT (strcmp (name, \"fr_FR.UTF-8\") == 0);\n        uselocale (LC_GLOBAL_LOCALE);\n        freelocale (locale);\n      }\n  }\n\n  /* Check that gl_locale_name distinguishes different categories of the\n     thread locale, and that the name is the right one for each.  */\n  {\n    unsigned int i;\n\n    for (i = 0; i < SIZEOF (categories); i++)\n      {\n        int category_mask = categories[i].mask;\n        locale_t loc = newlocale (LC_ALL_MASK, \"fr_FR.UTF-8\", NULL);\n        if (loc != NULL)\n          {\n            locale_t locale = newlocale (category_mask, \"de_DE.UTF-8\", loc);\n            if (locale == NULL)\n              freelocale (loc);\n            else\n              {\n                unsigned int j;\n\n                uselocale (locale);\n                for (j = 0; j < SIZEOF (categories); j++)\n                  {\n                    const char *name_j =\n                      gl_locale_name (categories[j].cat, categories[j].string);\n                    if (j == i)\n                      ASSERT (strcmp (name_j, \"de_DE.UTF-8\") == 0);\n                    else\n                      ASSERT (strcmp (name_j, \"fr_FR.UTF-8\") == 0);\n                  }\n                uselocale (LC_GLOBAL_LOCALE);\n                freelocale (locale);\n              }\n          }\n      }\n  }\n#endif\n}",
      "lines": 164,
      "depth": 21,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_locale_name_thread": {
      "start_point": [
        228,
        0
      ],
      "end_point": [
        479,
        1
      ],
      "content": "static void\ntest_locale_name_thread (void)\n{\n  /* Get into a defined state,  */\n  setlocale (LC_ALL, \"en_US.UTF-8\");\n\n#if HAVE_NEWLOCALE && HAVE_USELOCALE\n  /* Check that gl_locale_name_thread returns NULL when no thread locale is\n     set.  */\n  uselocale (LC_GLOBAL_LOCALE);\n  ASSERT (gl_locale_name_thread (LC_CTYPE, \"LC_CTYPE\") == NULL);\n  ASSERT (gl_locale_name_thread (LC_MESSAGES, \"LC_MESSAGES\") == NULL);\n\n  /* Check that gl_locale_name_thread considers the thread locale.  */\n  {\n    locale_t locale = newlocale (LC_ALL_MASK, \"fr_FR.UTF-8\", NULL);\n    if (locale != NULL)\n      {\n        const char *name;\n\n        uselocale (locale);\n        name = gl_locale_name_thread (LC_CTYPE, \"LC_CTYPE\");\n        ASSERT (strcmp (name, \"fr_FR.UTF-8\") == 0);\n        name = gl_locale_name_thread (LC_MESSAGES, \"LC_MESSAGES\");\n        ASSERT (strcmp (name, \"fr_FR.UTF-8\") == 0);\n        uselocale (LC_GLOBAL_LOCALE);\n        freelocale (locale);\n      }\n  }\n\n  /* Check that gl_locale_name_thread distinguishes different categories of the\n     thread locale, and that the name is the right one for each.  */\n  {\n    unsigned int i;\n\n    for (i = 0; i < SIZEOF (categories); i++)\n      {\n        int category_mask = categories[i].mask;\n        locale_t loc = newlocale (LC_ALL_MASK, \"fr_FR.UTF-8\", NULL);\n        if (loc != NULL)\n          {\n            locale_t locale = newlocale (category_mask, \"de_DE.UTF-8\", loc);\n            if (locale == NULL)\n              freelocale (loc);\n            else\n              {\n                unsigned int j;\n\n                uselocale (locale);\n                for (j = 0; j < SIZEOF (categories); j++)\n                  {\n                    const char *name_j =\n                      gl_locale_name_thread (categories[j].cat,\n                                             categories[j].string);\n                    if (j == i)\n                      ASSERT (strcmp (name_j, \"de_DE.UTF-8\") == 0);\n                    else\n                      ASSERT (strcmp (name_j, \"fr_FR.UTF-8\") == 0);\n                  }\n                uselocale (LC_GLOBAL_LOCALE);\n                freelocale (locale);\n              }\n          }\n      }\n  }\n\n  /* Check that gl_locale_name_thread returns a string that is allocated with\n     indefinite extent.  */\n  {\n    /* Try many locale names in turn, in order to defeat possible caches.  */\n    static const char * const choices[] =\n      {\n        \"C\",\n        \"POSIX\",\n        \"af_ZA\",\n        \"af_ZA.UTF-8\",\n        \"am_ET\",\n        \"am_ET.UTF-8\",\n        \"be_BY\",\n        \"be_BY.UTF-8\",\n        \"bg_BG\",\n        \"bg_BG.UTF-8\",\n        \"ca_ES\",\n        \"ca_ES.UTF-8\",\n        \"cs_CZ\",\n        \"cs_CZ.UTF-8\",\n        \"da_DK\",\n        \"da_DK.UTF-8\",\n        \"de_AT\",\n        \"de_AT.UTF-8\",\n        \"de_CH\",\n        \"de_CH.UTF-8\",\n        \"de_DE\",\n        \"de_DE.UTF-8\",\n        \"el_GR\",\n        \"el_GR.UTF-8\",\n        \"en_AU\",\n        \"en_AU.UTF-8\",\n        \"en_CA\",\n        \"en_CA.UTF-8\",\n        \"en_GB\",\n        \"en_GB.UTF-8\",\n        \"en_IE\",\n        \"en_IE.UTF-8\",\n        \"en_NZ\",\n        \"en_NZ.UTF-8\",\n        \"en_US\",\n        \"en_US.UTF-8\",\n        \"es_ES\",\n        \"es_ES.UTF-8\",\n        \"et_EE\",\n        \"et_EE.UTF-8\",\n        \"eu_ES\",\n        \"eu_ES.UTF-8\",\n        \"fi_FI\",\n        \"fi_FI.UTF-8\",\n        \"fr_BE\",\n        \"fr_BE.UTF-8\",\n        \"fr_CA\",\n        \"fr_CA.UTF-8\",\n        \"fr_CH\",\n        \"fr_CH.UTF-8\",\n        \"fr_FR\",\n        \"fr_FR.UTF-8\",\n        \"he_IL\",\n        \"he_IL.UTF-8\",\n        \"hr_HR\",\n        \"hr_HR.UTF-8\",\n        \"hu_HU\",\n        \"hu_HU.UTF-8\",\n        \"hy_AM\",\n        \"is_IS\",\n        \"is_IS.UTF-8\",\n        \"it_CH\",\n        \"it_CH.UTF-8\",\n        \"it_IT\",\n        \"it_IT.UTF-8\",\n        \"ja_JP.UTF-8\",\n        \"kk_KZ\",\n        \"kk_KZ.UTF-8\",\n        \"ko_KR.UTF-8\",\n        \"lt_LT\",\n        \"lt_LT.UTF-8\",\n        \"nl_BE\",\n        \"nl_BE.UTF-8\",\n        \"nl_NL\",\n        \"nl_NL.UTF-8\",\n        \"no_NO\",\n        \"no_NO.UTF-8\",\n        \"pl_PL\",\n        \"pl_PL.UTF-8\",\n        \"pt_BR\",\n        \"pt_BR.UTF-8\",\n        \"pt_PT\",\n        \"pt_PT.UTF-8\",\n        \"ro_RO\",\n        \"ro_RO.UTF-8\",\n        \"ru_RU\",\n        \"ru_RU.UTF-8\",\n        \"sk_SK\",\n        \"sk_SK.UTF-8\",\n        \"sl_SI\",\n        \"sl_SI.UTF-8\",\n        \"sv_SE\",\n        \"sv_SE.UTF-8\",\n        \"tr_TR\",\n        \"tr_TR.UTF-8\",\n        \"uk_UA\",\n        \"uk_UA.UTF-8\",\n        \"zh_CN\",\n        \"zh_CN.UTF-8\",\n        \"zh_HK\",\n        \"zh_HK.UTF-8\",\n        \"zh_TW\",\n        \"zh_TW.UTF-8\"\n      };\n    /* Remember which locales are available.  */\n    unsigned char /* bool */ available[SIZEOF (choices)];\n    /* Array of remembered results of gl_locale_name_thread.  */\n    const char *unsaved_names[SIZEOF (choices)][SIZEOF (categories)];\n    /* Array of remembered results of gl_locale_name_thread, stored in safe\n       memory.  */\n    char *saved_names[SIZEOF (choices)][SIZEOF (categories)];\n    unsigned int j;\n\n    for (j = 0; j < SIZEOF (choices); j++)\n      {\n        locale_t locale = newlocale (LC_ALL_MASK, choices[j], NULL);\n        available[j] = (locale != NULL);\n        if (locale != NULL)\n          {\n            unsigned int i;\n\n            uselocale (locale);\n            for (i = 0; i < SIZEOF (categories); i++)\n              {\n                unsaved_names[j][i] = gl_locale_name_thread (categories[i].cat, categories[i].string);\n                saved_names[j][i] = strdup (unsaved_names[j][i]);\n              }\n            uselocale (LC_GLOBAL_LOCALE);\n            freelocale (locale);\n          }\n      }\n    /* Verify the unsaved_names are still valid.  */\n    for (j = 0; j < SIZEOF (choices); j++)\n      if (available[j])\n        {\n          unsigned int i;\n\n          for (i = 0; i < SIZEOF (categories); i++)\n            ASSERT (strcmp (unsaved_names[j][i], saved_names[j][i]) == 0);\n        }\n    /* Allocate many locales, without freeing them.  This is an attempt at\n       overwriting as much of the previously allocated memory as possible.  */\n    for (j = SIZEOF (choices); j > 0; )\n      {\n        j--;\n        if (available[j])\n          {\n            locale_t locale = newlocale (LC_ALL_MASK, choices[j], NULL);\n            unsigned int i;\n\n            ASSERT (locale != NULL);\n            uselocale (locale);\n            for (i = 0; i < SIZEOF (categories); i++)\n              {\n                const char *name = gl_locale_name_thread (categories[i].cat, categories[i].string);\n                ASSERT (strcmp (unsaved_names[j][i], name) == 0);\n              }\n            uselocale (LC_GLOBAL_LOCALE);\n            freelocale (locale);\n          }\n      }\n    /* Verify the unsaved_names are still valid.  */\n    for (j = 0; j < SIZEOF (choices); j++)\n      if (available[j])\n        {\n          unsigned int i;\n\n          for (i = 0; i < SIZEOF (categories); i++)\n            {\n              ASSERT (strcmp (unsaved_names[j][i], saved_names[j][i]) == 0);\n              free (saved_names[j][i]);\n            }\n        }\n  }\n#else\n  /* Check that gl_locale_name_thread always returns NULL.  */\n  ASSERT (gl_locale_name_thread (LC_CTYPE, \"LC_CTYPE\") == NULL);\n  ASSERT (gl_locale_name_thread (LC_MESSAGES, \"LC_MESSAGES\") == NULL);\n#endif\n}",
      "lines": 252,
      "depth": 21,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_locale_name_posix": {
      "start_point": [
        482,
        0
      ],
      "end_point": [
        613,
        1
      ],
      "content": "static void\ntest_locale_name_posix (void)\n{\n  const char *name;\n\n  /* Get into a defined state,  */\n  setlocale (LC_ALL, \"en_US.UTF-8\");\n#if HAVE_NEWLOCALE && HAVE_USELOCALE\n  uselocale (LC_GLOBAL_LOCALE);\n#endif\n\n  /* Check that when all environment variables are unset,\n     gl_locale_name_posix returns either NULL or the default locale.  */\n  unsetenv (\"LC_ALL\");\n  unsetenv (\"LC_CTYPE\");\n  unsetenv (\"LC_MESSAGES\");\n  unsetenv (\"LC_NUMERIC\");\n  unsetenv (\"LANG\");\n  setlocale (LC_ALL, \"\");\n  name = gl_locale_name_posix (LC_MESSAGES, \"LC_MESSAGES\");\n  ASSERT (name == NULL || strcmp (name, gl_locale_name_default ()) == 0);\n  name = gl_locale_name_posix (LC_NUMERIC, \"LC_NUMERIC\");\n  ASSERT (name == NULL || strcmp (name, gl_locale_name_default ()) == 0);\n\n  /* Check that an empty environment variable is treated like an unset\n     environment variable.  */\n\n  setenv (\"LC_ALL\", \"\", 1);\n  unsetenv (\"LC_CTYPE\");\n  unsetenv (\"LC_MESSAGES\");\n  unsetenv (\"LANG\");\n  setlocale (LC_ALL, \"\");\n  name = gl_locale_name_posix (LC_MESSAGES, \"LC_MESSAGES\");\n  ASSERT (name == NULL || strcmp (name, gl_locale_name_default ()) == 0);\n\n  unsetenv (\"LC_ALL\");\n  setenv (\"LC_CTYPE\", \"\", 1);\n  unsetenv (\"LC_MESSAGES\");\n  unsetenv (\"LANG\");\n  setlocale (LC_ALL, \"\");\n  name = gl_locale_name_posix (LC_MESSAGES, \"LC_MESSAGES\");\n  ASSERT (name == NULL || strcmp (name, gl_locale_name_default ()) == 0);\n\n  unsetenv (\"LC_ALL\");\n  unsetenv (\"LC_CTYPE\");\n  setenv (\"LC_MESSAGES\", \"\", 1);\n  unsetenv (\"LANG\");\n  setlocale (LC_ALL, \"\");\n  name = gl_locale_name_posix (LC_MESSAGES, \"LC_MESSAGES\");\n  ASSERT (name == NULL || strcmp (name, gl_locale_name_default ()) == 0);\n\n  unsetenv (\"LC_ALL\");\n  unsetenv (\"LC_CTYPE\");\n  unsetenv (\"LC_MESSAGES\");\n  setenv (\"LANG\", \"\", 1);\n  setlocale (LC_ALL, \"\");\n  name = gl_locale_name_posix (LC_MESSAGES, \"LC_MESSAGES\");\n  ASSERT (name == NULL || strcmp (name, gl_locale_name_default ()) == 0);\n\n  /* Check that LC_ALL overrides the others, and LANG is overridden by the\n     others.  */\n\n  setenv (\"LC_ALL\", \"C\", 1);\n  unsetenv (\"LC_CTYPE\");\n  unsetenv (\"LC_MESSAGES\");\n  unsetenv (\"LANG\");\n  setlocale (LC_ALL, \"\");\n  name = gl_locale_name_posix (LC_MESSAGES, \"LC_MESSAGES\");\n  ASSERT (strcmp (name, \"C\") == 0);\n\n  unsetenv (\"LC_ALL\");\n  setenv (\"LC_CTYPE\", \"C\", 1);\n  setenv (\"LC_MESSAGES\", \"C\", 1);\n  unsetenv (\"LANG\");\n  setlocale (LC_ALL, \"\");\n  name = gl_locale_name_posix (LC_MESSAGES, \"LC_MESSAGES\");\n  ASSERT (strcmp (name, \"C\") == 0);\n\n  unsetenv (\"LC_ALL\");\n  unsetenv (\"LC_CTYPE\");\n  unsetenv (\"LC_MESSAGES\");\n  setenv (\"LANG\", \"C\", 1);\n  setlocale (LC_ALL, \"\");\n  name = gl_locale_name_posix (LC_MESSAGES, \"LC_MESSAGES\");\n  ASSERT (strcmp (name, \"C\") == 0);\n\n  /* Check mixed situations.  */\n\n  unsetenv (\"LC_ALL\");\n  unsetenv (\"LC_CTYPE\");\n  setenv (\"LC_MESSAGES\", \"fr_FR.UTF-8\", 1);\n  setenv (\"LANG\", \"de_DE.UTF-8\", 1);\n  if (setlocale (LC_ALL, \"\") != NULL)\n    {\n      name = gl_locale_name_posix (LC_CTYPE, \"LC_CTYPE\");\n      ASSERT (strcmp (name, \"de_DE.UTF-8\") == 0);\n      name = gl_locale_name_posix (LC_MESSAGES, \"LC_MESSAGES\");\n      ASSERT (strcmp (name, \"fr_FR.UTF-8\") == 0);\n    }\n\n  unsetenv (\"LC_ALL\");\n  unsetenv (\"LC_CTYPE\");\n  setenv (\"LC_MESSAGES\", \"fr_FR.UTF-8\", 1);\n  unsetenv (\"LANG\");\n  if (setlocale (LC_ALL, \"\") != NULL)\n    {\n      name = gl_locale_name_posix (LC_CTYPE, \"LC_CTYPE\");\n      ASSERT (name == NULL || strcmp (name, gl_locale_name_default ()) == 0);\n      name = gl_locale_name_posix (LC_MESSAGES, \"LC_MESSAGES\");\n      ASSERT (strcmp (name, \"fr_FR.UTF-8\") == 0);\n    }\n\n#if HAVE_NEWLOCALE && HAVE_USELOCALE\n  /* Check that gl_locale_name_posix ignores the thread locale.  */\n  {\n    locale_t locale = newlocale (LC_ALL_MASK, \"fr_FR.UTF-8\", NULL);\n    if (locale != NULL)\n      {\n        unsetenv (\"LC_ALL\");\n        unsetenv (\"LC_CTYPE\");\n        unsetenv (\"LC_MESSAGES\");\n        setenv (\"LANG\", \"C\", 1);\n        setlocale (LC_ALL, \"\");\n        uselocale (locale);\n        name = gl_locale_name_posix (LC_MESSAGES, \"LC_MESSAGES\");\n        ASSERT (strcmp (name, \"C\") == 0);\n        uselocale (LC_GLOBAL_LOCALE);\n        freelocale (locale);\n      }\n  }\n#endif\n}",
      "lines": 132,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_locale_name_environ": {
      "start_point": [
        616,
        0
      ],
      "end_point": [
        727,
        1
      ],
      "content": "static void\ntest_locale_name_environ (void)\n{\n  const char *name;\n\n  /* Get into a defined state,  */\n  setlocale (LC_ALL, \"en_US.UTF-8\");\n#if HAVE_NEWLOCALE && HAVE_USELOCALE\n  uselocale (LC_GLOBAL_LOCALE);\n#endif\n\n  /* Check that when all environment variables are unset,\n     gl_locale_name_environ returns NULL.  */\n  unsetenv (\"LC_ALL\");\n  unsetenv (\"LC_CTYPE\");\n  unsetenv (\"LC_MESSAGES\");\n  unsetenv (\"LC_NUMERIC\");\n  unsetenv (\"LANG\");\n  ASSERT (gl_locale_name_environ (LC_MESSAGES, \"LC_MESSAGES\") == NULL);\n  ASSERT (gl_locale_name_environ (LC_NUMERIC, \"LC_NUMERIC\") == NULL);\n\n  /* Check that an empty environment variable is treated like an unset\n     environment variable.  */\n\n  setenv (\"LC_ALL\", \"\", 1);\n  unsetenv (\"LC_CTYPE\");\n  unsetenv (\"LC_MESSAGES\");\n  unsetenv (\"LANG\");\n  ASSERT (gl_locale_name_environ (LC_MESSAGES, \"LC_MESSAGES\") == NULL);\n\n  unsetenv (\"LC_ALL\");\n  setenv (\"LC_CTYPE\", \"\", 1);\n  unsetenv (\"LC_MESSAGES\");\n  unsetenv (\"LANG\");\n  ASSERT (gl_locale_name_environ (LC_MESSAGES, \"LC_MESSAGES\") == NULL);\n\n  unsetenv (\"LC_ALL\");\n  unsetenv (\"LC_CTYPE\");\n  setenv (\"LC_MESSAGES\", \"\", 1);\n  unsetenv (\"LANG\");\n  ASSERT (gl_locale_name_environ (LC_MESSAGES, \"LC_MESSAGES\") == NULL);\n\n  unsetenv (\"LC_ALL\");\n  unsetenv (\"LC_CTYPE\");\n  unsetenv (\"LC_MESSAGES\");\n  setenv (\"LANG\", \"\", 1);\n  ASSERT (gl_locale_name_environ (LC_MESSAGES, \"LC_MESSAGES\") == NULL);\n\n  /* Check that LC_ALL overrides the others, and LANG is overridden by the\n     others.  */\n\n  setenv (\"LC_ALL\", \"C\", 1);\n  unsetenv (\"LC_CTYPE\");\n  unsetenv (\"LC_MESSAGES\");\n  unsetenv (\"LANG\");\n  name = gl_locale_name_environ (LC_MESSAGES, \"LC_MESSAGES\");\n  ASSERT (strcmp (name, \"C\") == 0);\n\n  unsetenv (\"LC_ALL\");\n  setenv (\"LC_CTYPE\", \"C\", 1);\n  setenv (\"LC_MESSAGES\", \"C\", 1);\n  unsetenv (\"LANG\");\n  name = gl_locale_name_environ (LC_MESSAGES, \"LC_MESSAGES\");\n  ASSERT (strcmp (name, \"C\") == 0);\n\n  unsetenv (\"LC_ALL\");\n  unsetenv (\"LC_CTYPE\");\n  unsetenv (\"LC_MESSAGES\");\n  setenv (\"LANG\", \"C\", 1);\n  name = gl_locale_name_environ (LC_MESSAGES, \"LC_MESSAGES\");\n  ASSERT (strcmp (name, \"C\") == 0);\n\n  /* Check mixed situations.  */\n\n  unsetenv (\"LC_ALL\");\n  unsetenv (\"LC_CTYPE\");\n  setenv (\"LC_MESSAGES\", \"fr_FR.UTF-8\", 1);\n  setenv (\"LANG\", \"de_DE.UTF-8\", 1);\n  name = gl_locale_name_environ (LC_CTYPE, \"LC_CTYPE\");\n  ASSERT (strcmp (name, \"de_DE.UTF-8\") == 0);\n  name = gl_locale_name_environ (LC_MESSAGES, \"LC_MESSAGES\");\n  ASSERT (strcmp (name, \"fr_FR.UTF-8\") == 0);\n\n  unsetenv (\"LC_ALL\");\n  unsetenv (\"LC_CTYPE\");\n  setenv (\"LC_MESSAGES\", \"fr_FR.UTF-8\", 1);\n  unsetenv (\"LANG\");\n  name = gl_locale_name_environ (LC_CTYPE, \"LC_CTYPE\");\n  ASSERT (name == NULL);\n  name = gl_locale_name_environ (LC_MESSAGES, \"LC_MESSAGES\");\n  ASSERT (strcmp (name, \"fr_FR.UTF-8\") == 0);\n\n#if HAVE_NEWLOCALE && HAVE_USELOCALE\n  /* Check that gl_locale_name_environ ignores the thread locale.  */\n  {\n    locale_t locale = newlocale (LC_ALL_MASK, \"fr_FR.UTF-8\", NULL);\n    if (locale != NULL)\n      {\n        unsetenv (\"LC_ALL\");\n        unsetenv (\"LC_CTYPE\");\n        unsetenv (\"LC_MESSAGES\");\n        setenv (\"LANG\", \"C\", 1);\n        setlocale (LC_ALL, \"\");\n        uselocale (locale);\n        name = gl_locale_name_environ (LC_MESSAGES, \"LC_MESSAGES\");\n        ASSERT (strcmp (name, \"C\") == 0);\n        uselocale (LC_GLOBAL_LOCALE);\n        freelocale (locale);\n      }\n  }\n#endif\n}",
      "lines": 112,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_locale_name_default": {
      "start_point": [
        730,
        0
      ],
      "end_point": [
        756,
        1
      ],
      "content": "static void\ntest_locale_name_default (void)\n{\n  const char *name = gl_locale_name_default ();\n\n  ASSERT (name != NULL);\n\n  /* Only Mac OS X and Windows have a facility for the user to set the default\n     locale.  */\n#if !((defined __APPLE__ && defined __MACH__) || (defined _WIN32 || defined __WIN32__ || defined __CYGWIN__))\n  ASSERT (strcmp (name, \"C\") == 0);\n#endif\n\n#if HAVE_NEWLOCALE && HAVE_USELOCALE\n  /* Check that gl_locale_name_default ignores the thread locale.  */\n  {\n    locale_t locale = newlocale (LC_ALL_MASK, \"fr_FR.UTF-8\", NULL);\n    if (locale != NULL)\n      {\n        uselocale (locale);\n        ASSERT (strcmp (gl_locale_name_default (), name) == 0);\n        uselocale (LC_GLOBAL_LOCALE);\n        freelocale (locale);\n      }\n  }\n#endif\n}",
      "lines": 27,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        758,
        0
      ],
      "end_point": [
        768,
        1
      ],
      "content": "int\nmain ()\n{\n  test_locale_name ();\n  test_locale_name_thread ();\n  test_locale_name_posix ();\n  test_locale_name_environ ();\n  test_locale_name_default ();\n\n  return 0;\n}",
      "lines": 11,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-lseek.c": {
    "main": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        108,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  if (argc != 2)\n    return 2;\n  switch (*argv[1])\n    {\n    case '0': /* regular files */\n      ASSERT (lseek (0, (off_t)2, SEEK_SET) == 2);\n      ASSERT (lseek (0, (off_t)-4, SEEK_CUR) == -1);\n      ASSERT (errno == EINVAL);\n      errno = 0;\n#if ! defined __BEOS__\n      /* POSIX says that the last lseek call, when failing, does not change\n         the current offset.  But BeOS sets it to 0.  */\n      ASSERT (lseek (0, (off_t)0, SEEK_CUR) == 2);\n#endif\n#if 0 /* leads to SIGSYS on IRIX 6.5 */\n      ASSERT (lseek (0, (off_t)0, (SEEK_SET | SEEK_CUR | SEEK_END) + 1) == -1);\n      ASSERT (errno == EINVAL);\n#endif\n      ASSERT (lseek (1, (off_t)2, SEEK_SET) == 2);\n      errno = 0;\n      ASSERT (lseek (1, (off_t)-4, SEEK_CUR) == -1);\n      ASSERT (errno == EINVAL);\n      errno = 0;\n#if ! defined __BEOS__\n      /* POSIX says that the last lseek call, when failing, does not change\n         the current offset.  But BeOS sets it to 0.  */\n      ASSERT (lseek (1, (off_t)0, SEEK_CUR) == 2);\n#endif\n#if 0 /* leads to SIGSYS on IRIX 6.5 */\n      ASSERT (lseek (1, (off_t)0, (SEEK_SET | SEEK_CUR | SEEK_END) + 1) == -1);\n      ASSERT (errno == EINVAL);\n#endif\n      break;\n\n    case '1': /* pipes */\n      errno = 0;\n      ASSERT (lseek (0, (off_t)0, SEEK_CUR) == -1);\n      ASSERT (errno == ESPIPE);\n      errno = 0;\n      ASSERT (lseek (1, (off_t)0, SEEK_CUR) == -1);\n      ASSERT (errno == ESPIPE);\n      break;\n\n    case '2': /* closed */\n      /* Explicitly close file descriptors 0 and 1.  The <&- and >&- in the\n         invoking shell are not enough on HP-UX.  */\n      close (0);\n      close (1);\n\n      errno = 0;\n      ASSERT (lseek (0, (off_t)0, SEEK_CUR) == -1);\n      ASSERT (errno == EBADF);\n\n      errno = 0;\n      ASSERT (lseek (1, (off_t)0, SEEK_CUR) == -1);\n      ASSERT (errno == EBADF);\n\n      /* Test behaviour for invalid file descriptors.  */\n      errno = 0;\n      ASSERT (lseek (-1, (off_t)0, SEEK_CUR) == -1);\n      ASSERT (errno == EBADF);\n\n      close (99);\n      errno = 0;\n      ASSERT (lseek (99, (off_t)0, SEEK_CUR) == -1);\n      ASSERT (errno == EBADF);\n\n      break;\n\n    default:\n      return 1;\n    }\n  return 0;\n}",
      "lines": 77,
      "depth": 16,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-lstat.c": {
    "do_lstat": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "static int\ndo_lstat (char const *name, struct stat *st)\n{\n  return lstat (name, st);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "int\nmain (void)\n{\n  /* Remove any leftovers from a previous partial run.  */\n  ignore_value (system (\"rm -rf \" BASE \"*\"));\n\n  return test_lstat_func (do_lstat, true);\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-lstat.h": {
    "test_lstat_func": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        115,
        1
      ],
      "content": "static int\ntest_lstat_func (int (*func) (char const *, struct stat *), bool print)\n{\n  struct stat st1;\n  struct stat st2;\n\n  /* Test for common directories.  */\n  ASSERT (func (\".\", &st1) == 0);\n  ASSERT (func (\"./\", &st2) == 0);\n  ASSERT (SAME_INODE (st1, st2));\n  ASSERT (S_ISDIR (st1.st_mode));\n  ASSERT (S_ISDIR (st2.st_mode));\n  ASSERT (func (\"/\", &st1) == 0);\n  ASSERT (func (\"///\", &st2) == 0);\n  ASSERT (SAME_INODE (st1, st2));\n  ASSERT (S_ISDIR (st1.st_mode));\n  ASSERT (S_ISDIR (st2.st_mode));\n  ASSERT (func (\"..\", &st1) == 0);\n  ASSERT (S_ISDIR (st1.st_mode));\n\n  /* Test for error conditions.  */\n  errno = 0;\n  ASSERT (func (\"\", &st1) == -1);\n  ASSERT (errno == ENOENT);\n  errno = 0;\n  ASSERT (func (\"nosuch\", &st1) == -1);\n  ASSERT (errno == ENOENT);\n  errno = 0;\n  ASSERT (func (\"nosuch/\", &st1) == -1);\n  ASSERT (errno == ENOENT);\n\n  ASSERT (close (creat (BASE \"file\", 0600)) == 0);\n  ASSERT (func (BASE \"file\", &st1) == 0);\n  ASSERT (S_ISREG (st1.st_mode));\n  errno = 0;\n  ASSERT (func (BASE \"file/\", &st1) == -1);\n  ASSERT (errno == ENOTDIR);\n\n  /* Now for some symlink tests, where supported.  We set up:\n     link1 -> directory\n     link2 -> file\n     link3 -> dangling\n     link4 -> loop\n     then test behavior both with and without trailing slash.\n  */\n  if (symlink (\".\", BASE \"link1\") != 0)\n    {\n      ASSERT (unlink (BASE \"file\") == 0);\n      if (print)\n        fputs (\"skipping test: symlinks not supported on this file system\\n\",\n               stderr);\n      return 77;\n    }\n  ASSERT (symlink (BASE \"file\", BASE \"link2\") == 0);\n  ASSERT (symlink (BASE \"nosuch\", BASE \"link3\") == 0);\n  ASSERT (symlink (BASE \"link4\", BASE \"link4\") == 0);\n\n  ASSERT (func (BASE \"link1\", &st1) == 0);\n  ASSERT (S_ISLNK (st1.st_mode));\n  ASSERT (func (BASE \"link1/\", &st1) == 0);\n  ASSERT (stat (BASE \"link1\", &st2) == 0);\n  ASSERT (S_ISDIR (st1.st_mode));\n  ASSERT (S_ISDIR (st2.st_mode));\n  ASSERT (SAME_INODE (st1, st2));\n\n  ASSERT (func (BASE \"link2\", &st1) == 0);\n  ASSERT (S_ISLNK (st1.st_mode));\n  errno = 0;\n  ASSERT (func (BASE \"link2/\", &st1) == -1);\n  ASSERT (errno == ENOTDIR);\n\n  ASSERT (func (BASE \"link3\", &st1) == 0);\n  ASSERT (S_ISLNK (st1.st_mode));\n  errno = 0;\n  ASSERT (func (BASE \"link3/\", &st1) == -1);\n  ASSERT (errno == ENOENT);\n\n  ASSERT (func (BASE \"link4\", &st1) == 0);\n  ASSERT (S_ISLNK (st1.st_mode));\n  errno = 0;\n  ASSERT (func (BASE \"link4/\", &st1) == -1);\n  ASSERT (errno == ELOOP);\n\n  /* Cleanup.  */\n  ASSERT (unlink (BASE \"file\") == 0);\n  ASSERT (unlink (BASE \"link1\") == 0);\n  ASSERT (unlink (BASE \"link2\") == 0);\n  ASSERT (unlink (BASE \"link3\") == 0);\n  ASSERT (unlink (BASE \"link4\") == 0);\n\n  return 0;\n}",
      "lines": 92,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-malloca.c": {
    "do_allocation": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        30,
        1
      ],
      "content": "static void\ndo_allocation (int n)\n{\n  void *ptr = malloca (n);\n  freea (ptr);\n  safe_alloca (n);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "int\nmain ()\n{\n  int i;\n\n  /* This slows down malloc a lot.  */\n  unsetenv (\"MALLOC_PERTURB_\");\n\n  /* Repeat a lot of times, to make sure there's no memory leak.  */\n  for (i = 0; i < 50000; i++)\n    {\n      /* Try various values.\n         n = 0 gave a crash on Alpha with gcc-2.5.8.\n         Some versions of Mac OS X have a stack size limit of 512 KB.  */\n      func (34);\n      func (134);\n      func (399);\n      func (510823);\n      func (129321);\n      func (0);\n      func (4070);\n      func (4095);\n      func (1);\n      func (16582);\n    }\n\n  return 0;\n}",
      "lines": 28,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-mbrtowc-w32.c": {
    "test_one_locale": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        693,
        1
      ],
      "content": "static int\ntest_one_locale (const char *name, int codepage)\n{\n  mbstate_t state;\n  wchar_t wc;\n  size_t ret;\n\n# if 1\n  /* Portable code to set the locale.  */\n  {\n    char name_with_codepage[1024];\n\n    sprintf (name_with_codepage, \"%s.%d\", name, codepage);\n\n    /* Set the locale.  */\n    if (setlocale (LC_ALL, name_with_codepage) == NULL)\n      return 77;\n  }\n# else\n  /* Hacky way to set a locale.codepage combination that setlocale() refuses\n     to set.  */\n  {\n    /* Codepage of the current locale, set with setlocale().\n       Not necessarily the same as GetACP().  */\n    extern __declspec(dllimport) unsigned int __lc_codepage;\n\n    /* Set the locale.  */\n    if (setlocale (LC_ALL, name) == NULL)\n      return 77;\n\n    /* Clobber the codepage and MB_CUR_MAX, both set by setlocale().  */\n    __lc_codepage = codepage;\n    switch (codepage)\n      {\n      case 1252:\n      case 1256:\n        MB_CUR_MAX = 1;\n        break;\n      case 932:\n      case 950:\n      case 936:\n        MB_CUR_MAX = 2;\n        break;\n      case 54936:\n      case 65001:\n        MB_CUR_MAX = 4;\n        break;\n      }\n\n    /* Test whether the codepage is really available.  */\n    memset (&state, '\\0', sizeof (mbstate_t));\n    if (mbrtowc (&wc, \" \", 1, &state) == (size_t)(-1))\n      return 77;\n  }\n# endif\n\n  /* Test zero-length input.  */\n  {\n    memset (&state, '\\0', sizeof (mbstate_t));\n    wc = (wchar_t) 0xBADFACE;\n    ret = mbrtowc (&wc, \"x\", 0, &state);\n    /* gnulib's implementation returns (size_t)(-2).\n       The AIX 5.1 implementation returns (size_t)(-1).\n       glibc's implementation returns 0.  */\n    ASSERT (ret == (size_t)(-2) || ret == (size_t)(-1) || ret == 0);\n    ASSERT (mbsinit (&state));\n  }\n\n  /* Test NUL byte input.  */\n  {\n    memset (&state, '\\0', sizeof (mbstate_t));\n    wc = (wchar_t) 0xBADFACE;\n    ret = mbrtowc (&wc, \"\", 1, &state);\n    ASSERT (ret == 0);\n    ASSERT (wc == 0);\n    ASSERT (mbsinit (&state));\n    ret = mbrtowc (NULL, \"\", 1, &state);\n    ASSERT (ret == 0);\n    ASSERT (mbsinit (&state));\n  }\n\n  /* Test single-byte input.  */\n  {\n    int c;\n    char buf[1];\n\n    memset (&state, '\\0', sizeof (mbstate_t));\n    for (c = 0; c < 0x100; c++)\n      switch (c)\n        {\n        case '\\t': case '\\v': case '\\f':\n        case ' ': case '!': case '\"': case '#': case '%':\n        case '&': case '\\'': case '(': case ')': case '*':\n        case '+': case ',': case '-': case '.': case '/':\n        case '0': case '1': case '2': case '3': case '4':\n        case '5': case '6': case '7': case '8': case '9':\n        case ':': case ';': case '<': case '=': case '>':\n        case '?':\n        case 'A': case 'B': case 'C': case 'D': case 'E':\n        case 'F': case 'G': case 'H': case 'I': case 'J':\n        case 'K': case 'L': case 'M': case 'N': case 'O':\n        case 'P': case 'Q': case 'R': case 'S': case 'T':\n        case 'U': case 'V': case 'W': case 'X': case 'Y':\n        case 'Z':\n        case '[': case '\\\\': case ']': case '^': case '_':\n        case 'a': case 'b': case 'c': case 'd': case 'e':\n        case 'f': case 'g': case 'h': case 'i': case 'j':\n        case 'k': case 'l': case 'm': case 'n': case 'o':\n        case 'p': case 'q': case 'r': case 's': case 't':\n        case 'u': case 'v': case 'w': case 'x': case 'y':\n        case 'z': case '{': case '|': case '}': case '~':\n          /* c is in the ISO C \"basic character set\".  */\n          buf[0] = c;\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, buf, 1, &state);\n          ASSERT (ret == 1);\n          ASSERT (wc == c);\n          ASSERT (mbsinit (&state));\n          ret = mbrtowc (NULL, buf, 1, &state);\n          ASSERT (ret == 1);\n          ASSERT (mbsinit (&state));\n          break;\n        }\n  }\n\n  /* Test special calling convention, passing a NULL pointer.  */\n  {\n    memset (&state, '\\0', sizeof (mbstate_t));\n    wc = (wchar_t) 0xBADFACE;\n    ret = mbrtowc (&wc, NULL, 5, &state);\n    ASSERT (ret == 0);\n    ASSERT (wc == (wchar_t) 0xBADFACE);\n    ASSERT (mbsinit (&state));\n  }\n\n  switch (codepage)\n    {\n    case 1252:\n      /* Locale encoding is CP1252, an extension of ISO-8859-1.  */\n      {\n        char input[] = \"B\\374\\337er\"; /* \"B\u00c3\u00bc\u00c3\u009fer\" */\n        memset (&state, '\\0', sizeof (mbstate_t));\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input, 1, &state);\n        ASSERT (ret == 1);\n        ASSERT (wc == 'B');\n        ASSERT (mbsinit (&state));\n        input[0] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 1, 1, &state);\n        ASSERT (ret == 1);\n        ASSERT (wctob (wc) == (unsigned char) '\\374');\n        ASSERT (wc == 0x00FC);\n        ASSERT (mbsinit (&state));\n        input[1] = '\\0';\n\n        /* Test support of NULL first argument.  */\n        ret = mbrtowc (NULL, input + 2, 3, &state);\n        ASSERT (ret == 1);\n        ASSERT (mbsinit (&state));\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 2, 3, &state);\n        ASSERT (ret == 1);\n        ASSERT (wctob (wc) == (unsigned char) '\\337');\n        ASSERT (wc == 0x00DF);\n        ASSERT (mbsinit (&state));\n        input[2] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 3, 2, &state);\n        ASSERT (ret == 1);\n        ASSERT (wc == 'e');\n        ASSERT (mbsinit (&state));\n        input[3] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 4, 1, &state);\n        ASSERT (ret == 1);\n        ASSERT (wc == 'r');\n        ASSERT (mbsinit (&state));\n      }\n      return 0;\n\n    case 1256:\n      /* Locale encoding is CP1256, not the same as ISO-8859-6.  */\n      {\n        char input[] = \"x\\302\\341\\346y\"; /* \"x\u00d8\u00a2\u00d9\u0084\u00d9\u0088y\" */\n        memset (&state, '\\0', sizeof (mbstate_t));\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input, 1, &state);\n        ASSERT (ret == 1);\n        ASSERT (wc == 'x');\n        ASSERT (mbsinit (&state));\n        input[0] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 1, 1, &state);\n        ASSERT (ret == 1);\n        ASSERT (wctob (wc) == (unsigned char) '\\302');\n        ASSERT (wc == 0x0622);\n        ASSERT (mbsinit (&state));\n        input[1] = '\\0';\n\n        /* Test support of NULL first argument.  */\n        ret = mbrtowc (NULL, input + 2, 3, &state);\n        ASSERT (ret == 1);\n        ASSERT (mbsinit (&state));\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 2, 3, &state);\n        ASSERT (ret == 1);\n        ASSERT (wctob (wc) == (unsigned char) '\\341');\n        ASSERT (wc == 0x0644);\n        ASSERT (mbsinit (&state));\n        input[2] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 3, 2, &state);\n        ASSERT (ret == 1);\n        ASSERT (wctob (wc) == (unsigned char) '\\346');\n        ASSERT (wc == 0x0648);\n        ASSERT (mbsinit (&state));\n        input[3] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 4, 1, &state);\n        ASSERT (ret == 1);\n        ASSERT (wc == 'y');\n        ASSERT (mbsinit (&state));\n      }\n      return 0;\n\n    case 932:\n      /* Locale encoding is CP932, similar to Shift_JIS.  */\n      {\n        char input[] = \"<\\223\\372\\226\\173\\214\\352>\"; /* \"<\u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e>\" */\n        memset (&state, '\\0', sizeof (mbstate_t));\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input, 1, &state);\n        ASSERT (ret == 1);\n        ASSERT (wc == '<');\n        ASSERT (mbsinit (&state));\n        input[0] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 1, 2, &state);\n        ASSERT (ret == 2);\n        ASSERT (wctob (wc) == EOF);\n        ASSERT (wc == 0x65E5);\n        ASSERT (mbsinit (&state));\n        input[1] = '\\0';\n        input[2] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 3, 1, &state);\n        ASSERT (ret == (size_t)(-2));\n        ASSERT (wc == (wchar_t) 0xBADFACE);\n        ASSERT (!mbsinit (&state));\n        input[3] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 4, 4, &state);\n        ASSERT (ret == 1);\n        ASSERT (wctob (wc) == EOF);\n        ASSERT (wc == 0x672C);\n        ASSERT (mbsinit (&state));\n        input[4] = '\\0';\n\n        /* Test support of NULL first argument.  */\n        ret = mbrtowc (NULL, input + 5, 3, &state);\n        ASSERT (ret == 2);\n        ASSERT (mbsinit (&state));\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 5, 3, &state);\n        ASSERT (ret == 2);\n        ASSERT (wctob (wc) == EOF);\n        ASSERT (wc == 0x8A9E);\n        ASSERT (mbsinit (&state));\n        input[5] = '\\0';\n        input[6] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 7, 1, &state);\n        ASSERT (ret == 1);\n        ASSERT (wc == '>');\n        ASSERT (mbsinit (&state));\n\n        /* Test some invalid input.  */\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\377\", 1, &state); /* 0xFF */\n        ASSERT ((ret == (size_t)-1 && errno == EILSEQ) || ret == (size_t)-2);\n\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\225\\377\", 2, &state); /* 0x95 0xFF */\n        ASSERT ((ret == (size_t)-1 && errno == EILSEQ) || (ret == 2 && wc == 0x30FB));\n      }\n      return 0;\n\n    case 950:\n      /* Locale encoding is CP950, similar to Big5.  */\n      {\n        char input[] = \"<\\244\\351\\245\\273\\273\\171>\"; /* \"<\u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e>\" */\n        memset (&state, '\\0', sizeof (mbstate_t));\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input, 1, &state);\n        ASSERT (ret == 1);\n        ASSERT (wc == '<');\n        ASSERT (mbsinit (&state));\n        input[0] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 1, 2, &state);\n        ASSERT (ret == 2);\n        ASSERT (wctob (wc) == EOF);\n        ASSERT (wc == 0x65E5);\n        ASSERT (mbsinit (&state));\n        input[1] = '\\0';\n        input[2] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 3, 1, &state);\n        ASSERT (ret == (size_t)(-2));\n        ASSERT (wc == (wchar_t) 0xBADFACE);\n        ASSERT (!mbsinit (&state));\n        input[3] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 4, 4, &state);\n        ASSERT (ret == 1);\n        ASSERT (wctob (wc) == EOF);\n        ASSERT (wc == 0x672C);\n        ASSERT (mbsinit (&state));\n        input[4] = '\\0';\n\n        /* Test support of NULL first argument.  */\n        ret = mbrtowc (NULL, input + 5, 3, &state);\n        ASSERT (ret == 2);\n        ASSERT (mbsinit (&state));\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 5, 3, &state);\n        ASSERT (ret == 2);\n        ASSERT (wctob (wc) == EOF);\n        ASSERT (wc == 0x8A9E);\n        ASSERT (mbsinit (&state));\n        input[5] = '\\0';\n        input[6] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 7, 1, &state);\n        ASSERT (ret == 1);\n        ASSERT (wc == '>');\n        ASSERT (mbsinit (&state));\n\n        /* Test some invalid input.  */\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\377\", 1, &state); /* 0xFF */\n        ASSERT ((ret == (size_t)-1 && errno == EILSEQ) || ret == (size_t)-2);\n\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\225\\377\", 2, &state); /* 0x95 0xFF */\n        ASSERT ((ret == (size_t)-1 && errno == EILSEQ) || (ret == 2 && wc == '?'));\n      }\n      return 0;\n\n    case 936:\n      /* Locale encoding is CP936 = GBK, an extension of GB2312.  */\n      {\n        char input[] = \"<\\310\\325\\261\\276\\325\\132>\"; /* \"<\u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e>\" */\n        memset (&state, '\\0', sizeof (mbstate_t));\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input, 1, &state);\n        ASSERT (ret == 1);\n        ASSERT (wc == '<');\n        ASSERT (mbsinit (&state));\n        input[0] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 1, 2, &state);\n        ASSERT (ret == 2);\n        ASSERT (wctob (wc) == EOF);\n        ASSERT (wc == 0x65E5);\n        ASSERT (mbsinit (&state));\n        input[1] = '\\0';\n        input[2] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 3, 1, &state);\n        ASSERT (ret == (size_t)(-2));\n        ASSERT (wc == (wchar_t) 0xBADFACE);\n        ASSERT (!mbsinit (&state));\n        input[3] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 4, 4, &state);\n        ASSERT (ret == 1);\n        ASSERT (wctob (wc) == EOF);\n        ASSERT (wc == 0x672C);\n        ASSERT (mbsinit (&state));\n        input[4] = '\\0';\n\n        /* Test support of NULL first argument.  */\n        ret = mbrtowc (NULL, input + 5, 3, &state);\n        ASSERT (ret == 2);\n        ASSERT (mbsinit (&state));\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 5, 3, &state);\n        ASSERT (ret == 2);\n        ASSERT (wctob (wc) == EOF);\n        ASSERT (wc == 0x8A9E);\n        ASSERT (mbsinit (&state));\n        input[5] = '\\0';\n        input[6] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 7, 1, &state);\n        ASSERT (ret == 1);\n        ASSERT (wc == '>');\n        ASSERT (mbsinit (&state));\n\n        /* Test some invalid input.  */\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\377\", 1, &state); /* 0xFF */\n        ASSERT ((ret == (size_t)-1 && errno == EILSEQ) || ret == (size_t)-2);\n\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\225\\377\", 2, &state); /* 0x95 0xFF */\n        ASSERT ((ret == (size_t)-1 && errno == EILSEQ) || (ret == 2 && wc == '?'));\n      }\n      return 0;\n\n    case 54936:\n      /* Locale encoding is CP54936 = GB18030.  */\n      {\n        char input[] = \"B\\250\\271\\201\\060\\211\\070er\"; /* \"B\u00c3\u00bc\u00c3\u009fer\" */\n        memset (&state, '\\0', sizeof (mbstate_t));\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input, 1, &state);\n        ASSERT (ret == 1);\n        ASSERT (wc == 'B');\n        ASSERT (mbsinit (&state));\n        input[0] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 1, 1, &state);\n        ASSERT (ret == (size_t)(-2));\n        ASSERT (wc == (wchar_t) 0xBADFACE);\n        ASSERT (!mbsinit (&state));\n        input[1] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 2, 7, &state);\n        ASSERT (ret == 1);\n        ASSERT (wctob (wc) == EOF);\n        ASSERT (wc == 0x00FC);\n        ASSERT (mbsinit (&state));\n        input[2] = '\\0';\n\n        /* Test support of NULL first argument.  */\n        ret = mbrtowc (NULL, input + 3, 6, &state);\n        ASSERT (ret == 4);\n        ASSERT (mbsinit (&state));\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 3, 6, &state);\n        ASSERT (ret == 4);\n        ASSERT (wctob (wc) == EOF);\n        ASSERT (wc == 0x00DF);\n        ASSERT (mbsinit (&state));\n        input[3] = '\\0';\n        input[4] = '\\0';\n        input[5] = '\\0';\n        input[6] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 7, 2, &state);\n        ASSERT (ret == 1);\n        ASSERT (wc == 'e');\n        ASSERT (mbsinit (&state));\n        input[5] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 8, 1, &state);\n        ASSERT (ret == 1);\n        ASSERT (wc == 'r');\n        ASSERT (mbsinit (&state));\n\n        /* Test some invalid input.  */\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\377\", 1, &state); /* 0xFF */\n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\225\\377\", 2, &state); /* 0x95 0xFF */\n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\201\\045\", 2, &state); /* 0x81 0x25 */\n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\201\\060\\377\", 3, &state); /* 0x81 0x30 0xFF */\n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\201\\060\\377\\064\", 4, &state); /* 0x81 0x30 0xFF 0x34 */\n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\201\\060\\211\\072\", 4, &state); /* 0x81 0x30 0x89 0x3A */\n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n      }\n      return 0;\n\n    case 65001:\n      /* Locale encoding is CP65001 = UTF-8.  */\n      {\n        char input[] = \"B\\303\\274\\303\\237er\"; /* \"B\u00c3\u00bc\u00c3\u009fer\" */\n        memset (&state, '\\0', sizeof (mbstate_t));\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input, 1, &state);\n        ASSERT (ret == 1);\n        ASSERT (wc == 'B');\n        ASSERT (mbsinit (&state));\n        input[0] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 1, 1, &state);\n        ASSERT (ret == (size_t)(-2));\n        ASSERT (wc == (wchar_t) 0xBADFACE);\n        ASSERT (!mbsinit (&state));\n        input[1] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 2, 5, &state);\n        ASSERT (ret == 1);\n        ASSERT (wctob (wc) == EOF);\n        ASSERT (wc == 0x00FC);\n        ASSERT (mbsinit (&state));\n        input[2] = '\\0';\n\n        /* Test support of NULL first argument.  */\n        ret = mbrtowc (NULL, input + 3, 4, &state);\n        ASSERT (ret == 2);\n        ASSERT (mbsinit (&state));\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 3, 4, &state);\n        ASSERT (ret == 2);\n        ASSERT (wctob (wc) == EOF);\n        ASSERT (wc == 0x00DF);\n        ASSERT (mbsinit (&state));\n        input[3] = '\\0';\n        input[4] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 5, 2, &state);\n        ASSERT (ret == 1);\n        ASSERT (wc == 'e');\n        ASSERT (mbsinit (&state));\n        input[5] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 6, 1, &state);\n        ASSERT (ret == 1);\n        ASSERT (wc == 'r');\n        ASSERT (mbsinit (&state));\n\n        /* Test some invalid input.  */\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\377\", 1, &state); /* 0xFF */\n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\303\\300\", 2, &state); /* 0xC3 0xC0 */\n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\343\\300\", 2, &state); /* 0xE3 0xC0 */\n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\343\\300\\200\", 3, &state); /* 0xE3 0xC0 0x80 */\n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\343\\200\\300\", 3, &state); /* 0xE3 0x80 0xC0 */\n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\363\\300\", 2, &state); /* 0xF3 0xC0 */\n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\363\\300\\200\\200\", 4, &state); /* 0xF3 0xC0 0x80 0x80 */\n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\363\\200\\300\", 3, &state); /* 0xF3 0x80 0xC0 */\n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\363\\200\\300\\200\", 4, &state); /* 0xF3 0x80 0xC0 0x80 */\n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\363\\200\\200\\300\", 4, &state); /* 0xF3 0x80 0x80 0xC0 */\n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n      }\n      return 0;\n\n    default:\n      return 1;\n    }\n}",
      "lines": 664,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": [
      {
        "start_point": [
          695,
          0
        ],
        "end_point": [
          717,
          1
        ],
        "content": "int\nmain (int argc, char *argv[])\n{\n  int codepage = atoi (argv[argc - 1]);\n  int result;\n  int i;\n\n  result = 77;\n  for (i = 1; i < argc - 1; i++)\n    {\n      int ret = test_one_locale (argv[i], codepage);\n\n      if (ret != 77)\n        result = ret;\n    }\n\n  if (result == 77)\n    {\n      fprintf (stderr, \"Skipping test: found no locale with codepage %d\\n\",\n               codepage);\n    }\n  return result;\n}",
        "lines": 23,
        "depth": 10,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          721,
          0
        ],
        "end_point": [
          726,
          1
        ],
        "content": "int\nmain (int argc, char *argv[])\n{\n  fputs (\"Skipping test: not a native Windows system\\n\", stderr);\n  return 77;\n}",
        "lines": 6,
        "depth": 7,
        "decorators": [
          "int"
        ]
      }
    ]
  },
  "sed/sed-4.5/gnulib-tests/test-mbrtowc.c": {
    "main": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        356,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  mbstate_t state;\n  wchar_t wc;\n  size_t ret;\n\n  /* configure should already have checked that the locale is supported.  */\n  if (setlocale (LC_ALL, \"\") == NULL)\n    return 1;\n\n  /* Test zero-length input.  */\n  {\n    memset (&state, '\\0', sizeof (mbstate_t));\n    wc = (wchar_t) 0xBADFACE;\n    ret = mbrtowc (&wc, \"x\", 0, &state);\n    ASSERT (ret == (size_t)(-2));\n    ASSERT (mbsinit (&state));\n  }\n\n  /* Test NUL byte input.  */\n  {\n    memset (&state, '\\0', sizeof (mbstate_t));\n    wc = (wchar_t) 0xBADFACE;\n    ret = mbrtowc (&wc, \"\", 1, &state);\n    ASSERT (ret == 0);\n    ASSERT (wc == 0);\n    ASSERT (mbsinit (&state));\n    ret = mbrtowc (NULL, \"\", 1, &state);\n    ASSERT (ret == 0);\n    ASSERT (mbsinit (&state));\n  }\n\n  /* Test single-byte input.  */\n  {\n    int c;\n    char buf[1];\n\n    memset (&state, '\\0', sizeof (mbstate_t));\n    for (c = 0; c < 0x100; c++)\n      switch (c)\n        {\n        default:\n          if (! (c && 1 < argc && argv[1][0] == '5'))\n            break;\n          FALLTHROUGH;\n        case '\\t': case '\\v': case '\\f':\n        case ' ': case '!': case '\"': case '#': case '%':\n        case '&': case '\\'': case '(': case ')': case '*':\n        case '+': case ',': case '-': case '.': case '/':\n        case '0': case '1': case '2': case '3': case '4':\n        case '5': case '6': case '7': case '8': case '9':\n        case ':': case ';': case '<': case '=': case '>':\n        case '?':\n        case 'A': case 'B': case 'C': case 'D': case 'E':\n        case 'F': case 'G': case 'H': case 'I': case 'J':\n        case 'K': case 'L': case 'M': case 'N': case 'O':\n        case 'P': case 'Q': case 'R': case 'S': case 'T':\n        case 'U': case 'V': case 'W': case 'X': case 'Y':\n        case 'Z':\n        case '[': case '\\\\': case ']': case '^': case '_':\n        case 'a': case 'b': case 'c': case 'd': case 'e':\n        case 'f': case 'g': case 'h': case 'i': case 'j':\n        case 'k': case 'l': case 'm': case 'n': case 'o':\n        case 'p': case 'q': case 'r': case 's': case 't':\n        case 'u': case 'v': case 'w': case 'x': case 'y':\n        case 'z': case '{': case '|': case '}': case '~':\n          /* c is in the ISO C \"basic character set\", or argv[1] starts\n             with '5' so we are testing all nonnull bytes.  */\n          buf[0] = c;\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, buf, 1, &state);\n          ASSERT (ret == 1);\n          if (c < 0x80)\n            /* c is an ASCII character.  */\n            ASSERT (wc == c);\n          else\n            /* argv[1] starts with '5', that is, we are testing the C or POSIX\n               locale.\n               On most platforms, the bytes 0x80..0xFF map to U+0080..U+00FF.\n               But on musl libc, the bytes 0x80..0xFF map to U+DF80..U+DFFF.  */\n            ASSERT (wc == (btowc (c) == WEOF ? c : btowc (c)));\n          ASSERT (mbsinit (&state));\n          ret = mbrtowc (NULL, buf, 1, &state);\n          ASSERT (ret == 1);\n          ASSERT (mbsinit (&state));\n          break;\n        }\n  }\n\n  /* Test special calling convention, passing a NULL pointer.  */\n  {\n    memset (&state, '\\0', sizeof (mbstate_t));\n    wc = (wchar_t) 0xBADFACE;\n    ret = mbrtowc (&wc, NULL, 5, &state);\n    ASSERT (ret == 0);\n    ASSERT (wc == (wchar_t) 0xBADFACE);\n    ASSERT (mbsinit (&state));\n  }\n\n  if (argc > 1)\n    switch (argv[1][0])\n      {\n      case '1':\n        /* Locale encoding is ISO-8859-1 or ISO-8859-15.  */\n        {\n          char input[] = \"B\\374\\337er\"; /* \"B\u00c3\u00bc\u00c3\u009fer\" */\n          memset (&state, '\\0', sizeof (mbstate_t));\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input, 1, &state);\n          ASSERT (ret == 1);\n          ASSERT (wc == 'B');\n          ASSERT (mbsinit (&state));\n          input[0] = '\\0';\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input + 1, 1, &state);\n          ASSERT (ret == 1);\n          ASSERT (wctob (wc) == (unsigned char) '\\374');\n          ASSERT (mbsinit (&state));\n          input[1] = '\\0';\n\n          /* Test support of NULL first argument.  */\n          ret = mbrtowc (NULL, input + 2, 3, &state);\n          ASSERT (ret == 1);\n          ASSERT (mbsinit (&state));\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input + 2, 3, &state);\n          ASSERT (ret == 1);\n          ASSERT (wctob (wc) == (unsigned char) '\\337');\n          ASSERT (mbsinit (&state));\n          input[2] = '\\0';\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input + 3, 2, &state);\n          ASSERT (ret == 1);\n          ASSERT (wc == 'e');\n          ASSERT (mbsinit (&state));\n          input[3] = '\\0';\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input + 4, 1, &state);\n          ASSERT (ret == 1);\n          ASSERT (wc == 'r');\n          ASSERT (mbsinit (&state));\n        }\n        return 0;\n\n      case '2':\n        /* Locale encoding is UTF-8.  */\n        {\n          char input[] = \"B\\303\\274\\303\\237er\"; /* \"B\u00c3\u00bc\u00c3\u009fer\" */\n          memset (&state, '\\0', sizeof (mbstate_t));\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input, 1, &state);\n          ASSERT (ret == 1);\n          ASSERT (wc == 'B');\n          ASSERT (mbsinit (&state));\n          input[0] = '\\0';\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input + 1, 1, &state);\n          ASSERT (ret == (size_t)(-2));\n          ASSERT (wc == (wchar_t) 0xBADFACE);\n          ASSERT (!mbsinit (&state));\n          input[1] = '\\0';\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input + 2, 5, &state);\n          ASSERT (ret == 1);\n          ASSERT (wctob (wc) == EOF);\n          ASSERT (mbsinit (&state));\n          input[2] = '\\0';\n\n          /* Test support of NULL first argument.  */\n          ret = mbrtowc (NULL, input + 3, 4, &state);\n          ASSERT (ret == 2);\n          ASSERT (mbsinit (&state));\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input + 3, 4, &state);\n          ASSERT (ret == 2);\n          ASSERT (wctob (wc) == EOF);\n          ASSERT (mbsinit (&state));\n          input[3] = '\\0';\n          input[4] = '\\0';\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input + 5, 2, &state);\n          ASSERT (ret == 1);\n          ASSERT (wc == 'e');\n          ASSERT (mbsinit (&state));\n          input[5] = '\\0';\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input + 6, 1, &state);\n          ASSERT (ret == 1);\n          ASSERT (wc == 'r');\n          ASSERT (mbsinit (&state));\n        }\n        return 0;\n\n      case '3':\n        /* Locale encoding is EUC-JP.  */\n        {\n          char input[] = \"<\\306\\374\\313\\334\\270\\354>\"; /* \"<\u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e>\" */\n          memset (&state, '\\0', sizeof (mbstate_t));\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input, 1, &state);\n          ASSERT (ret == 1);\n          ASSERT (wc == '<');\n          ASSERT (mbsinit (&state));\n          input[0] = '\\0';\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input + 1, 2, &state);\n          ASSERT (ret == 2);\n          ASSERT (wctob (wc) == EOF);\n          ASSERT (mbsinit (&state));\n          input[1] = '\\0';\n          input[2] = '\\0';\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input + 3, 1, &state);\n          ASSERT (ret == (size_t)(-2));\n          ASSERT (wc == (wchar_t) 0xBADFACE);\n          ASSERT (!mbsinit (&state));\n          input[3] = '\\0';\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input + 4, 4, &state);\n          ASSERT (ret == 1);\n          ASSERT (wctob (wc) == EOF);\n          ASSERT (mbsinit (&state));\n          input[4] = '\\0';\n\n          /* Test support of NULL first argument.  */\n          ret = mbrtowc (NULL, input + 5, 3, &state);\n          ASSERT (ret == 2);\n          ASSERT (mbsinit (&state));\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input + 5, 3, &state);\n          ASSERT (ret == 2);\n          ASSERT (wctob (wc) == EOF);\n          ASSERT (mbsinit (&state));\n          input[5] = '\\0';\n          input[6] = '\\0';\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input + 7, 1, &state);\n          ASSERT (ret == 1);\n          ASSERT (wc == '>');\n          ASSERT (mbsinit (&state));\n        }\n        return 0;\n\n      case '4':\n        /* Locale encoding is GB18030.  */\n        {\n          char input[] = \"B\\250\\271\\201\\060\\211\\070er\"; /* \"B\u00c3\u00bc\u00c3\u009fer\" */\n          memset (&state, '\\0', sizeof (mbstate_t));\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input, 1, &state);\n          ASSERT (ret == 1);\n          ASSERT (wc == 'B');\n          ASSERT (mbsinit (&state));\n          input[0] = '\\0';\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input + 1, 1, &state);\n          ASSERT (ret == (size_t)(-2));\n          ASSERT (wc == (wchar_t) 0xBADFACE);\n          ASSERT (!mbsinit (&state));\n          input[1] = '\\0';\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input + 2, 7, &state);\n          ASSERT (ret == 1);\n          ASSERT (wctob (wc) == EOF);\n          ASSERT (mbsinit (&state));\n          input[2] = '\\0';\n\n          /* Test support of NULL first argument.  */\n          ret = mbrtowc (NULL, input + 3, 6, &state);\n          ASSERT (ret == 4);\n          ASSERT (mbsinit (&state));\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input + 3, 6, &state);\n          ASSERT (ret == 4);\n          ASSERT (wctob (wc) == EOF);\n          ASSERT (mbsinit (&state));\n          input[3] = '\\0';\n          input[4] = '\\0';\n          input[5] = '\\0';\n          input[6] = '\\0';\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input + 7, 2, &state);\n          ASSERT (ret == 1);\n          ASSERT (wc == 'e');\n          ASSERT (mbsinit (&state));\n          input[5] = '\\0';\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input + 8, 1, &state);\n          ASSERT (ret == 1);\n          ASSERT (wc == 'r');\n          ASSERT (mbsinit (&state));\n        }\n        return 0;\n\n      case '5':\n        /* C locale; tested above.  */\n        return 0;\n      }\n\n  return 1;\n}",
      "lines": 325,
      "depth": 18,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-mbsinit.c": {
    "main": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  static mbstate_t state;\n\n  ASSERT (mbsinit (NULL));\n\n  ASSERT (mbsinit (&state));\n\n  if (argc > 1)\n    {\n      static const char input[1] = \"\\303\";\n      wchar_t wc;\n      size_t ret;\n\n      /* configure should already have checked that the locale is supported.  */\n      if (setlocale (LC_ALL, \"\") == NULL)\n        return 1;\n\n      ret = mbrtowc (&wc, input, 1, &state);\n      ASSERT (ret == (size_t)(-2));\n      ASSERT (!mbsinit (&state));\n    }\n\n  return 0;\n}",
      "lines": 26,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-memchr.c": {
    "main": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        131,
        1
      ],
      "content": "int\nmain (void)\n{\n  size_t n = 0x100000;\n  char *input = malloc (n);\n  ASSERT (input);\n\n  input[0] = 'a';\n  input[1] = 'b';\n  memset (input + 2, 'c', 1024);\n  memset (input + 1026, 'd', n - 1028);\n  input[n - 2] = 'e';\n  input[n - 1] = 'a';\n\n  /* Basic behavior tests.  */\n  ASSERT (MEMCHR (input, 'a', n) == input);\n\n  ASSERT (MEMCHR (input, 'a', 0) == NULL);\n  ASSERT (MEMCHR (zerosize_ptr (), 'a', 0) == NULL);\n\n  ASSERT (MEMCHR (input, 'b', n) == input + 1);\n  ASSERT (MEMCHR (input, 'c', n) == input + 2);\n  ASSERT (MEMCHR (input, 'd', n) == input + 1026);\n\n  ASSERT (MEMCHR (input + 1, 'a', n - 1) == input + n - 1);\n  ASSERT (MEMCHR (input + 1, 'e', n - 1) == input + n - 2);\n  ASSERT (MEMCHR (input + 1, 0x789abc00 | 'e', n - 1) == input + n - 2);\n\n  ASSERT (MEMCHR (input, 'f', n) == NULL);\n  ASSERT (MEMCHR (input, '\\0', n) == NULL);\n\n  /* Check that a very long haystack is handled quickly if the byte is\n     found near the beginning.  */\n  {\n    size_t repeat = 10000;\n    for (; repeat > 0; repeat--)\n      {\n        ASSERT (MEMCHR (input, 'c', n) == input + 2);\n      }\n  }\n\n  /* Alignment tests.  */\n  {\n    int i, j;\n    for (i = 0; i < 32; i++)\n      {\n        for (j = 0; j < 256; j++)\n          input[i + j] = j;\n        for (j = 0; j < 256; j++)\n          {\n            ASSERT (MEMCHR (input + i, j, 256) == input + i + j);\n          }\n      }\n  }\n\n  /* Check that memchr() does not read past the first occurrence of the\n     byte being searched.  See the Austin Group's clarification\n     <http://www.opengroup.org/austin/docs/austin_454.txt>.\n     Test both '\\0' and something else, since some implementations\n     special-case searching for NUL.\n  */\n  {\n    char *page_boundary = (char *) zerosize_ptr ();\n    /* Too small, and we miss cache line boundary tests; too large,\n       and the test takes cubically longer to complete.  */\n    int limit = 257;\n\n    if (page_boundary != NULL)\n      {\n        for (n = 1; n <= limit; n++)\n          {\n            char *mem = page_boundary - n;\n            memset (mem, 'X', n);\n            ASSERT (MEMCHR (mem, 'U', n) == NULL);\n            ASSERT (MEMCHR (mem, 0, n) == NULL);\n\n            {\n              size_t i;\n              size_t k;\n\n              for (i = 0; i < n; i++)\n                {\n                  mem[i] = 'U';\n                  for (k = i + 1; k < n + limit; k++)\n                    ASSERT (MEMCHR (mem, 'U', k) == mem + i);\n                  mem[i] = 0;\n                  for (k = i + 1; k < n + limit; k++)\n                    ASSERT (MEMCHR (mem, 0, k) == mem + i);\n                  mem[i] = 'X';\n                }\n            }\n          }\n      }\n  }\n\n  free (input);\n\n  return 0;\n}",
      "lines": 99,
      "depth": 19,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-memrchr.c": {
    "main": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "int\nmain (void)\n{\n  size_t n = 0x100000;\n  char *input = malloc (n);\n  ASSERT (input);\n\n  input[n - 1] = 'a';\n  input[n - 2] = 'b';\n  memset (input + n - 1026, 'c', 1024);\n  memset (input + 2, 'd', n - 1028);\n  input[1] = 'e';\n  input[0] = 'a';\n\n  /* Basic behavior tests.  */\n  ASSERT (MEMRCHR (input, 'a', n) == input + n - 1);\n\n  ASSERT (MEMRCHR (input, 'a', 0) == NULL);\n  ASSERT (MEMRCHR (zerosize_ptr (), 'a', 0) == NULL);\n\n  ASSERT (MEMRCHR (input, 'b', n) == input + n - 2);\n  ASSERT (MEMRCHR (input, 'c', n) == input + n - 3);\n  ASSERT (MEMRCHR (input, 'd', n) == input + n - 1027);\n\n  ASSERT (MEMRCHR (input, 'a', n - 1) == input);\n  ASSERT (MEMRCHR (input, 'e', n - 1) == input + 1);\n\n  ASSERT (MEMRCHR (input, 'f', n) == NULL);\n  ASSERT (MEMRCHR (input, '\\0', n) == NULL);\n\n  /* Check that a very long haystack is handled quickly if the byte is\n     found near the end.  */\n  {\n    size_t repeat = 10000;\n    for (; repeat > 0; repeat--)\n      {\n        ASSERT (MEMRCHR (input, 'c', n) == input + n - 3);\n      }\n  }\n\n  /* Alignment tests.  */\n  {\n    int i, j;\n    for (i = 0; i < 32; i++)\n      {\n        for (j = 0; j < 256; j++)\n          input[i + j] = j;\n        for (j = 0; j < 256; j++)\n          {\n            ASSERT (MEMRCHR (input + i, j, 256) == input + i + j);\n          }\n      }\n  }\n\n  free (input);\n\n  return 0;\n}",
      "lines": 58,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-nanosleep.c": {
    "handle_alarm": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "static void\nhandle_alarm (int sig)\n{\n  if (sig != SIGALRM)\n    _exit (1);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        82,
        1
      ],
      "content": "int\nmain (void)\n{\n  struct timespec ts;\n\n  ts.tv_sec = 1000;\n  ts.tv_nsec = -1;\n  errno = 0;\n  ASSERT (nanosleep (&ts, NULL) == -1);\n  ASSERT (errno == EINVAL);\n  ts.tv_nsec = 1000000000;\n  errno = 0;\n  ASSERT (nanosleep (&ts, NULL) == -1);\n  ASSERT (errno == EINVAL);\n\n  ts.tv_sec = 0;\n  ts.tv_nsec = 1;\n  ASSERT (nanosleep (&ts, &ts) == 0);\n  /* Remaining time is only defined on EINTR failure; but on success,\n     it is typically either 0 or unchanged from input.  At any rate,\n     it shouldn't be randomly changed to unrelated values.  */\n  ASSERT (ts.tv_sec == 0);\n  ASSERT (ts.tv_nsec == 0 || ts.tv_nsec == 1);\n  ts.tv_nsec = 0;\n  ASSERT (nanosleep (&ts, NULL) == 0);\n\n#if HAVE_DECL_ALARM\n  {\n    const time_t pentecost = 50 * 24 * 60 * 60; /* 50 days.  */\n    signal (SIGALRM, handle_alarm);\n    alarm (1);\n    ts.tv_sec = pentecost;\n    ts.tv_nsec = 999999999;\n    errno = 0;\n    ASSERT (nanosleep (&ts, &ts) == -1);\n    ASSERT (errno == EINTR);\n    ASSERT (pentecost - 10 < ts.tv_sec && ts.tv_sec <= pentecost);\n    ASSERT (0 <= ts.tv_nsec && ts.tv_nsec <= 999999999);\n  }\n#endif\n\n  return 0;\n}",
      "lines": 43,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-netinet_in.c": {
    "main": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        26,
        1
      ],
      "content": "int\nmain (void)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-nl_langinfo.c": {
    "main": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        151,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  int pass = atoi (argv[1]);\n  /* pass    locale\n      0        C\n      1        traditional French locale\n      2        French UTF-8 locale\n   */\n\n  setlocale (LC_ALL, \"\");\n\n  /* nl_langinfo items of the LC_CTYPE category */\n  ASSERT (strlen (nl_langinfo (CODESET)) > 0);\n  if (pass == 2)\n    {\n      const char *codeset = nl_langinfo (CODESET);\n      ASSERT (c_strcasecmp (codeset, \"UTF-8\") == 0 || c_strcasecmp (codeset, \"UTF8\") == 0);\n    }\n  /* nl_langinfo items of the LC_NUMERIC category */\n  ASSERT (strlen (nl_langinfo (RADIXCHAR)) > 0);\n  ASSERT (strlen (nl_langinfo (THOUSEP)) >= 0);\n  /* nl_langinfo items of the LC_TIME category */\n  ASSERT (strlen (nl_langinfo (D_T_FMT)) > 0);\n  ASSERT (strlen (nl_langinfo (D_FMT)) > 0);\n  ASSERT (strlen (nl_langinfo (T_FMT)) > 0);\n  ASSERT (strlen (nl_langinfo (T_FMT_AMPM)) >= (pass == 0 ? 1 : 0));\n  ASSERT (strlen (nl_langinfo (AM_STR)) >= (pass == 0 ? 1 : 0));\n  ASSERT (strlen (nl_langinfo (PM_STR)) >= (pass == 0 ? 1 : 0));\n  ASSERT (strlen (nl_langinfo (DAY_1)) > 0);\n  ASSERT (strlen (nl_langinfo (DAY_2)) > 0);\n  ASSERT (strlen (nl_langinfo (DAY_3)) > 0);\n  ASSERT (strlen (nl_langinfo (DAY_4)) > 0);\n  ASSERT (strlen (nl_langinfo (DAY_5)) > 0);\n  ASSERT (strlen (nl_langinfo (DAY_6)) > 0);\n  ASSERT (strlen (nl_langinfo (DAY_7)) > 0);\n  ASSERT (strlen (nl_langinfo (ABDAY_1)) > 0);\n  ASSERT (strlen (nl_langinfo (ABDAY_2)) > 0);\n  ASSERT (strlen (nl_langinfo (ABDAY_3)) > 0);\n  ASSERT (strlen (nl_langinfo (ABDAY_4)) > 0);\n  ASSERT (strlen (nl_langinfo (ABDAY_5)) > 0);\n  ASSERT (strlen (nl_langinfo (ABDAY_6)) > 0);\n  ASSERT (strlen (nl_langinfo (ABDAY_7)) > 0);\n  ASSERT (strlen (nl_langinfo (MON_1)) > 0);\n  ASSERT (strlen (nl_langinfo (MON_2)) > 0);\n  ASSERT (strlen (nl_langinfo (MON_3)) > 0);\n  ASSERT (strlen (nl_langinfo (MON_4)) > 0);\n  ASSERT (strlen (nl_langinfo (MON_5)) > 0);\n  ASSERT (strlen (nl_langinfo (MON_6)) > 0);\n  ASSERT (strlen (nl_langinfo (MON_7)) > 0);\n  ASSERT (strlen (nl_langinfo (MON_8)) > 0);\n  ASSERT (strlen (nl_langinfo (MON_9)) > 0);\n  ASSERT (strlen (nl_langinfo (MON_10)) > 0);\n  ASSERT (strlen (nl_langinfo (MON_11)) > 0);\n  ASSERT (strlen (nl_langinfo (MON_12)) > 0);\n  ASSERT (strlen (nl_langinfo (ALTMON_1)) > 0);\n  ASSERT (strlen (nl_langinfo (ALTMON_2)) > 0);\n  ASSERT (strlen (nl_langinfo (ALTMON_3)) > 0);\n  ASSERT (strlen (nl_langinfo (ALTMON_4)) > 0);\n  ASSERT (strlen (nl_langinfo (ALTMON_5)) > 0);\n  ASSERT (strlen (nl_langinfo (ALTMON_6)) > 0);\n  ASSERT (strlen (nl_langinfo (ALTMON_7)) > 0);\n  ASSERT (strlen (nl_langinfo (ALTMON_8)) > 0);\n  ASSERT (strlen (nl_langinfo (ALTMON_9)) > 0);\n  ASSERT (strlen (nl_langinfo (ALTMON_10)) > 0);\n  ASSERT (strlen (nl_langinfo (ALTMON_11)) > 0);\n  ASSERT (strlen (nl_langinfo (ALTMON_12)) > 0);\n  /* In the tested locales, alternate month names and month names ought to be\n     the same.  */\n  ASSERT (strcmp (nl_langinfo (ALTMON_1), nl_langinfo (MON_1)) == 0);\n  ASSERT (strcmp (nl_langinfo (ALTMON_2), nl_langinfo (MON_2)) == 0);\n  ASSERT (strcmp (nl_langinfo (ALTMON_3), nl_langinfo (MON_3)) == 0);\n  ASSERT (strcmp (nl_langinfo (ALTMON_4), nl_langinfo (MON_4)) == 0);\n  ASSERT (strcmp (nl_langinfo (ALTMON_5), nl_langinfo (MON_5)) == 0);\n  ASSERT (strcmp (nl_langinfo (ALTMON_6), nl_langinfo (MON_6)) == 0);\n  ASSERT (strcmp (nl_langinfo (ALTMON_7), nl_langinfo (MON_7)) == 0);\n  ASSERT (strcmp (nl_langinfo (ALTMON_8), nl_langinfo (MON_8)) == 0);\n  ASSERT (strcmp (nl_langinfo (ALTMON_9), nl_langinfo (MON_9)) == 0);\n  ASSERT (strcmp (nl_langinfo (ALTMON_10), nl_langinfo (MON_10)) == 0);\n  ASSERT (strcmp (nl_langinfo (ALTMON_11), nl_langinfo (MON_11)) == 0);\n  ASSERT (strcmp (nl_langinfo (ALTMON_12), nl_langinfo (MON_12)) == 0);\n  ASSERT (strlen (nl_langinfo (ABMON_1)) > 0);\n  ASSERT (strlen (nl_langinfo (ABMON_2)) > 0);\n  ASSERT (strlen (nl_langinfo (ABMON_3)) > 0);\n  ASSERT (strlen (nl_langinfo (ABMON_4)) > 0);\n  ASSERT (strlen (nl_langinfo (ABMON_5)) > 0);\n  ASSERT (strlen (nl_langinfo (ABMON_6)) > 0);\n  ASSERT (strlen (nl_langinfo (ABMON_7)) > 0);\n  ASSERT (strlen (nl_langinfo (ABMON_8)) > 0);\n  ASSERT (strlen (nl_langinfo (ABMON_9)) > 0);\n  ASSERT (strlen (nl_langinfo (ABMON_10)) > 0);\n  ASSERT (strlen (nl_langinfo (ABMON_11)) > 0);\n  ASSERT (strlen (nl_langinfo (ABMON_12)) > 0);\n  ASSERT (strlen (nl_langinfo (ERA)) >= 0);\n  ASSERT (strlen (nl_langinfo (ERA_D_FMT)) >= 0);\n  ASSERT (strlen (nl_langinfo (ERA_D_T_FMT)) >= 0);\n  ASSERT (strlen (nl_langinfo (ERA_T_FMT)) >= 0);\n  ASSERT (nl_langinfo (ALT_DIGITS) != NULL);\n  /* nl_langinfo items of the LC_MONETARY category */\n  {\n    const char *currency = nl_langinfo (CRNCYSTR);\n    ASSERT (strlen (currency) >= 0);\n#if !defined __NetBSD__\n    if (pass > 0)\n      ASSERT (strlen (currency) >= 1);\n#endif\n  }\n  /* nl_langinfo items of the LC_MESSAGES category */\n  ASSERT (strlen (nl_langinfo (YESEXPR)) > 0);\n  ASSERT (strlen (nl_langinfo (NOEXPR)) > 0);\n\n  return 0;\n}",
      "lines": 113,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-open.c": {
    "main": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "int\nmain (void)\n{\n  return test_open (open, true);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-open.h": {
    "test_open": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "static ALWAYS_INLINE int\ntest_open (int (*func) (char const *, int, ...), bool print)\n{\n  int fd;\n  /* Remove anything from prior partial run.  */\n  unlink (BASE \"file\");\n\n  /* Cannot create directory.  */\n  errno = 0;\n  ASSERT (func (\"nonexist.ent/\", O_CREAT | O_RDONLY, 0600) == -1);\n  ASSERT (errno == ENOTDIR || errno == EISDIR || errno == ENOENT\n          || errno == EINVAL);\n\n  /* Create a regular file.  */\n  fd = func (BASE \"file\", O_CREAT | O_RDONLY, 0600);\n  ASSERT (0 <= fd);\n  ASSERT (close (fd) == 0);\n\n  /* Trailing slash handling.  */\n  errno = 0;\n  ASSERT (func (BASE \"file/\", O_RDONLY) == -1);\n  ASSERT (errno == ENOTDIR || errno == EISDIR || errno == EINVAL);\n\n  /* Directories cannot be opened for writing.  */\n  errno = 0;\n  ASSERT (func (\".\", O_WRONLY) == -1);\n  ASSERT (errno == EISDIR || errno == EACCES);\n\n  /* /dev/null must exist, and be writable.  */\n  fd = func (\"/dev/null\", O_RDONLY);\n  ASSERT (0 <= fd);\n  {\n    char c;\n    ASSERT (read (fd, &c, 1) == 0);\n  }\n  ASSERT (close (fd) == 0);\n  fd = func (\"/dev/null\", O_WRONLY);\n  ASSERT (0 <= fd);\n  ASSERT (write (fd, \"c\", 1) == 1);\n  ASSERT (close (fd) == 0);\n\n  /* Although O_NONBLOCK on regular files can be ignored, it must not\n     cause a failure.  */\n  fd = func (BASE \"file\", O_NONBLOCK | O_RDONLY);\n  ASSERT (0 <= fd);\n  ASSERT (close (fd) == 0);\n\n  /* Symlink handling, where supported.  */\n  if (symlink (BASE \"file\", BASE \"link\") != 0)\n    {\n      ASSERT (unlink (BASE \"file\") == 0);\n      if (print)\n        fputs (\"skipping test: symlinks not supported on this file system\\n\",\n               stderr);\n      return 77;\n    }\n  errno = 0;\n  ASSERT (func (BASE \"link/\", O_RDONLY) == -1);\n  ASSERT (errno == ENOTDIR);\n  fd = func (BASE \"link\", O_RDONLY);\n  ASSERT (0 <= fd);\n  ASSERT (close (fd) == 0);\n\n  /* Cleanup.  */\n  ASSERT (unlink (BASE \"file\") == 0);\n  ASSERT (unlink (BASE \"link\") == 0);\n\n  return 0;\n}",
      "lines": 69,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "ALWAYS_INLINE",
        "int",
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-pathmax.c": {
    "main": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        31,
        1
      ],
      "content": "int\nmain (void)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-perror.c": {
    "main": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        35,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  const char *prefix = (argc > 1 ? argv[1] : NULL);\n\n  errno = EACCES;    perror (prefix);\n  errno = ETIMEDOUT; perror (prefix);\n  errno = EOVERFLOW; perror (prefix);\n\n  return 0;\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-perror2.c": {
    "main": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "int\nmain (void)\n{\n  /* We change fd 2 later, so save it in fd 10.  */\n  if (dup2 (STDERR_FILENO, BACKUP_STDERR_FILENO) != BACKUP_STDERR_FILENO\n      || (myerr = fdopen (BACKUP_STDERR_FILENO, \"w\")) == NULL)\n    return 2;\n\n  ASSERT (freopen (BASE \".tmp\", \"w+\", stderr) == stderr);\n\n  /* Test that perror does not clobber strerror buffer.  */\n  {\n    const char *msg1;\n    const char *msg2;\n    const char *msg3;\n    const char *msg4;\n    char *str1;\n    char *str2;\n    char *str3;\n    char *str4;\n\n    msg1 = strerror (ENOENT);\n    ASSERT (msg1);\n    str1 = strdup (msg1);\n    ASSERT (str1);\n\n    msg2 = strerror (ERANGE);\n    ASSERT (msg2);\n    str2 = strdup (msg2);\n    ASSERT (str2);\n\n    msg3 = strerror (-4);\n    ASSERT (msg3);\n    str3 = strdup (msg3);\n    ASSERT (str3);\n\n    msg4 = strerror (1729576);\n    ASSERT (msg4);\n    str4 = strdup (msg4);\n    ASSERT (str4);\n\n    errno = EACCES;\n    perror (\"\");\n    errno = -5;\n    perror (\"\");\n    ASSERT (!ferror (stderr));\n    ASSERT (msg1 == msg2 || msg1 == msg4 || STREQ (msg1, str1));\n    ASSERT (msg2 == msg4 || STREQ (msg2, str2));\n    ASSERT (msg3 == msg4 || STREQ (msg3, str3));\n    ASSERT (STREQ (msg4, str4));\n\n    free (str1);\n    free (str2);\n    free (str3);\n    free (str4);\n  }\n\n  /* Test that perror uses the same message as strerror.  */\n  {\n    int errs[] = { EACCES, 0, -3, };\n    int i;\n    for (i = 0; i < SIZEOF (errs); i++)\n      {\n        char buf[256];\n        char *err = strerror (errs[i]);\n\n        ASSERT (err);\n        ASSERT (strlen (err) < sizeof buf);\n        rewind (stderr);\n        ASSERT (ftruncate (fileno (stderr), 0) == 0);\n        errno = errs[i];\n        perror (NULL);\n        ASSERT (!ferror (stderr));\n        rewind (stderr);\n        ASSERT (fgets (buf, sizeof buf, stderr) == buf);\n        ASSERT (strstr (buf, err));\n      }\n  }\n\n  /* Test that perror reports write failure.  */\n  {\n    ASSERT (freopen (BASE \".tmp\", \"r\", stderr) == stderr);\n    ASSERT (setvbuf (stderr, NULL, _IONBF, BUFSIZ) == 0);\n    errno = -1;\n    ASSERT (!ferror (stderr));\n    perror (NULL);\n#if 0\n    /* Commented out until cygwin behaves:\n       https://sourceware.org/ml/newlib/2011/msg00228.html */\n    ASSERT (errno > 0);\n    /* Commented out until glibc behaves:\n       https://sourceware.org/bugzilla/show_bug.cgi?id=12792 */\n    ASSERT (ferror (stderr));\n#endif\n  }\n\n  ASSERT (fclose (stderr) == 0);\n  ASSERT (remove (BASE \".tmp\") == 0);\n\n  return 0;\n}",
      "lines": 101,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-pipe.c": {
    "is_open": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "static bool\nis_open (int fd)\n{\n#if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n  /* On native Windows, the initial state of unassigned standard file\n     descriptors is that they are open but point to an\n     INVALID_HANDLE_VALUE, and there is no fcntl.  */\n  return (HANDLE) _get_osfhandle (fd) != INVALID_HANDLE_VALUE;\n#else\n# ifndef F_GETFL\n#  error Please port fcntl to your platform\n# endif\n  return 0 <= fcntl (fd, F_GETFL);\n#endif\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "is_cloexec": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "static bool\nis_cloexec (int fd)\n{\n#if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n  HANDLE h = (HANDLE) _get_osfhandle (fd);\n  DWORD flags;\n  ASSERT (GetHandleInformation (h, &flags));\n  return (flags & HANDLE_FLAG_INHERIT) == 0;\n#else\n  int flags;\n  ASSERT ((flags = fcntl (fd, F_GETFD)) >= 0);\n  return (flags & FD_CLOEXEC) != 0;\n#endif\n}",
      "lines": 14,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "is_nonblocking": {
      "start_point": [
        75,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "static bool\nis_nonblocking (int fd)\n{\n#if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n  /* We don't use the non-blocking mode for sockets here.  */\n  return 0;\n#else\n  int flags;\n  ASSERT ((flags = fcntl (fd, F_GETFL)) >= 0);\n  return (flags & O_NONBLOCK) != 0;\n#endif\n}",
      "lines": 12,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "main": {
      "start_point": [
        88,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "int\nmain ()\n{\n  int fd[2];\n\n  fd[0] = -1;\n  fd[1] = -1;\n  ASSERT (pipe (fd) >= 0);\n  ASSERT (fd[0] >= 0);\n  ASSERT (fd[1] >= 0);\n  ASSERT (fd[0] != fd[1]);\n  ASSERT (is_open (fd[0]));\n  ASSERT (is_open (fd[1]));\n  ASSERT (!is_cloexec (fd[0]));\n  ASSERT (!is_cloexec (fd[1]));\n  ASSERT (!is_nonblocking (fd[0]));\n  ASSERT (!is_nonblocking (fd[1]));\n\n  return 0;\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-quotearg-simple.c": {
    "use_quote_double_quotes": {
      "start_point": [
        247,
        0
      ],
      "end_point": [
        254,
        1
      ],
      "content": "static char *\nuse_quote_double_quotes (const char *str, size_t *len)\n{\n  char *p = *len == SIZE_MAX ? quotearg_char (str, '\"')\n                               : quotearg_char_mem (str, *len, '\"');\n  *len = strlen (p);\n  return p;\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nuse_quote_double_quotes (const char *str, size_t *len)",
        "*"
      ]
    },
    "main": {
      "start_point": [
        256,
        0
      ],
      "end_point": [
        365,
        1
      ],
      "content": "int\nmain (int argc _GL_UNUSED, char *argv[])\n{\n  int i;\n  bool ascii_only = MB_CUR_MAX == 1 && !isprint ((unsigned char) LQ[0]);\n\n  /* This part of the program is hard-wired to the C locale since it\n     does not call setlocale.  However, according to POSIX, the use of\n     8-bit bytes in a character context in the C locale gives\n     unspecified results (that is, the C locale charset is allowed to\n     be unibyte with 8-bit bytes rejected [ASCII], unibyte with 8-bit\n     bytes being characters [often ISO-8859-1], or multibyte [often\n     UTF-8]).  We assume that the latter two cases will be\n     indistinguishable in this test - that is, the LQ and RQ sequences\n     will pass through unchanged in either type of charset.  So when\n     testing for quoting of str7, use the ascii_only flag to decide\n     what to expect for the 8-bit data being quoted.  */\n  ASSERT (!isprint ('\\033'));\n  for (i = literal_quoting_style; i <= clocale_quoting_style; i++)\n    {\n      set_quoting_style (NULL, (enum quoting_style) i);\n      if (!(i == locale_quoting_style || i == clocale_quoting_style)\n          || (strcmp (locale_charset (), \"ASCII\") == 0\n              || strcmp (locale_charset (), \"ANSI_X3.4-1968\") == 0))\n        {\n          compare_strings (use_quotearg_buffer, &results_g[i].group1,\n                           ascii_only);\n          compare_strings (use_quotearg, &results_g[i].group2,\n                           ascii_only);\n          if (i == c_quoting_style)\n            compare_strings (use_quote_double_quotes, &results_g[i].group2,\n                             ascii_only);\n          compare_strings (use_quotearg_colon, &results_g[i].group3,\n                           ascii_only);\n        }\n    }\n\n  set_quoting_style (NULL, literal_quoting_style);\n  ASSERT (set_quoting_flags (NULL, QA_ELIDE_NULL_BYTES) == 0);\n  compare_strings (use_quotearg_buffer, &flag_results[0].group1, ascii_only);\n  compare_strings (use_quotearg, &flag_results[0].group2, ascii_only);\n  compare_strings (use_quotearg_colon, &flag_results[0].group3, ascii_only);\n\n  set_quoting_style (NULL, c_quoting_style);\n  ASSERT (set_quoting_flags (NULL, QA_ELIDE_OUTER_QUOTES)\n          == QA_ELIDE_NULL_BYTES);\n  compare_strings (use_quotearg_buffer, &flag_results[1].group1, ascii_only);\n  compare_strings (use_quotearg, &flag_results[1].group2, ascii_only);\n  compare_strings (use_quote_double_quotes, &flag_results[1].group2,\n                   ascii_only);\n  compare_strings (use_quotearg_colon, &flag_results[1].group3, ascii_only);\n\n  ASSERT (set_quoting_flags (NULL, QA_SPLIT_TRIGRAPHS)\n          == QA_ELIDE_OUTER_QUOTES);\n  compare_strings (use_quotearg_buffer, &flag_results[2].group1, ascii_only);\n  compare_strings (use_quotearg, &flag_results[2].group2, ascii_only);\n  compare_strings (use_quote_double_quotes, &flag_results[2].group2,\n                   ascii_only);\n  compare_strings (use_quotearg_colon, &flag_results[2].group3, ascii_only);\n\n  ASSERT (set_quoting_flags (NULL, 0) == QA_SPLIT_TRIGRAPHS);\n\n  for (i = 0; i < sizeof custom_quotes / sizeof *custom_quotes; ++i)\n    {\n      set_custom_quoting (NULL,\n                          custom_quotes[i][0], custom_quotes[i][1]);\n      compare_strings (use_quotearg_buffer, &custom_results[i].group1,\n                       ascii_only);\n      compare_strings (use_quotearg, &custom_results[i].group2, ascii_only);\n      compare_strings (use_quotearg_colon, &custom_results[i].group3,\n                       ascii_only);\n    }\n\n  {\n    /* Trigger the bug whereby quotearg_buffer would read beyond the NUL\n       that defines the end of the string being quoted.  Use an input\n       string whose NUL is the last byte before an unreadable page.  */\n    char *z = zerosize_ptr ();\n\n    if (z)\n      {\n        size_t q_len = 1024;\n        char *q = malloc (q_len + 1);\n        char buf[10];\n        memset (q, 'Q', q_len);\n        q[q_len] = 0;\n\n        /* Z points to the boundary between a readable/writable page\n           and one that is neither readable nor writable.  Position\n           our string so its NUL is at the end of the writable one.  */\n        char const *str = \"____\";\n        size_t s_len = strlen (str);\n        z -= s_len + 1;\n        memcpy (z, str, s_len + 1);\n\n        set_custom_quoting (NULL, q, q);\n        /* Whether this actually triggers a SEGV depends on the\n           implementation of memcmp: whether it compares only byte-at-\n           a-time, and from left to right (no SEGV) or some other way.  */\n        size_t n = quotearg_buffer (buf, sizeof buf, z, SIZE_MAX, NULL);\n        ASSERT (n == s_len + 2 * q_len);\n        ASSERT (memcmp (buf, q, sizeof buf) == 0);\n        free (q);\n      }\n  }\n\n  quotearg_free ();\n\n  return 0;\n}",
      "lines": 110,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-quotearg.h": {
    "compare": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "static void\ncompare (char const *a, size_t la, char const *b, size_t lb)\n{\n  ASSERT (la == lb);\n  ASSERT (memcmp (a, b, la) == 0);\n  ASSERT (b[lb] == '\\0');\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "compare_strings": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        98,
        1
      ],
      "content": "static void\ncompare_strings (char *(func) (char const *, size_t *),\n                 struct result_strings *results, bool ascii_only)\n{\n  size_t len;\n  char *p;\n\n  len = 0;\n  p = func (inputs.str1, &len);\n  compare (results->str1, strlen (results->str1), p, len);\n\n  len = inputs.len2;\n  p = func (inputs.str2, &len);\n  compare (results->str2, results->len2, p, len);\n\n  len = SIZE_MAX;\n  p = func (inputs.str3, &len);\n  compare (results->str3, strlen (results->str3), p, len);\n\n  len = strlen (inputs.str4);\n  p = func (inputs.str4, &len);\n  compare (results->str4, strlen (results->str4), p, len);\n\n  len = SIZE_MAX;\n  p = func (inputs.str5, &len);\n  compare (results->str5, strlen (results->str5), p, len);\n\n  len = strlen (inputs.str6);\n  p = func (inputs.str6, &len);\n  compare (results->str6, strlen (results->str6), p, len);\n\n  len = strlen (inputs.str7);\n  p = func (inputs.str7, &len);\n  compare (results->str7, strlen (results->str7), p, len);\n\n  len = strlen (inputs.str8a);\n  p = func (inputs.str8a, &len);\n  if (ascii_only)\n    compare (results->str8a, strlen (results->str8a), p, len);\n  else\n    compare (results->str8b, strlen (results->str8b), p, len);\n}",
      "lines": 42,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "use_quotearg_buffer": {
      "start_point": [
        100,
        0
      ],
      "end_point": [
        110,
        1
      ],
      "content": "static char *\nuse_quotearg_buffer (const char *str, size_t *len)\n{\n  static char buf[100];\n  size_t size;\n  memset (buf, 0xa5, 100);\n  size = quotearg_buffer (buf, 100, str, *len, NULL);\n  *len = size;\n  ASSERT ((unsigned char) buf[size + 1] == 0xa5);\n  return buf;\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nuse_quotearg_buffer (const char *str, size_t *len)",
        "*"
      ]
    },
    "use_quotearg": {
      "start_point": [
        112,
        0
      ],
      "end_point": [
        118,
        1
      ],
      "content": "static char *\nuse_quotearg (const char *str, size_t *len)\n{\n  char *p = *len == SIZE_MAX ? quotearg (str) : quotearg_mem (str, *len);\n  *len = strlen (p);\n  return p;\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nuse_quotearg (const char *str, size_t *len)",
        "*"
      ]
    },
    "use_quotearg_colon": {
      "start_point": [
        120,
        0
      ],
      "end_point": [
        127,
        1
      ],
      "content": "static char *\nuse_quotearg_colon (const char *str, size_t *len)\n{\n  char *p = (*len == SIZE_MAX ? quotearg_colon (str)\n             : quotearg_colon_mem (str, *len));\n  *len = strlen (p);\n  return p;\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nuse_quotearg_colon (const char *str, size_t *len)",
        "*"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-raise.c": {
    "handler": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        34,
        1
      ],
      "content": "static _Noreturn void\nhandler (int sig)\n{\n  exit (0);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "_Noreturn",
        "void",
        "void"
      ]
    },
    "main": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "int\nmain (void)\n{\n  /* Test behaviour for invalid argument.  */\n  ASSERT (raise (-1) != 0);\n\n  /* Test behaviour for SIGINT.  */\n  ASSERT (signal (SIGINT, handler) != SIG_ERR);\n\n  raise (SIGINT);\n\n  /* We should not get here, because the handler takes away the control.  */\n  exit (1);\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-read-file.c": {
    "main": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        110,
        1
      ],
      "content": "int\nmain (void)\n{\n  struct stat statbuf;\n  int err = 0;\n\n  /* We can perform the test only if the file exists and is readable.\n     Test whether it exists, then assume it is world-readable.  */\n  if (stat (FILE1, &statbuf) >= 0)\n    {\n      size_t len;\n      char *out = read_file (FILE1, &len);\n\n      if (!out)\n        {\n          perror (\"Could not read file\");\n          err = 1;\n        }\n      else\n        {\n          if (out[len] != '\\0')\n            {\n              perror (\"BAD: out[len] not zero\");\n              err = 1;\n            }\n\n          if (S_ISREG (statbuf.st_mode))\n            {\n              /* FILE1 is a regular file or a symlink to a regular file.  */\n              if (len != statbuf.st_size)\n                {\n                  fprintf (stderr, \"Read %lu from %s...\\n\",\n                           (unsigned long) len, FILE1);\n                  err = 1;\n                }\n            }\n          else\n            {\n              /* Assume FILE1 is not empty.  */\n              if (len == 0)\n                {\n                  fprintf (stderr, \"Read nothing from %s\\n\", FILE1);\n                  err = 1;\n                }\n            }\n          free (out);\n        }\n    }\n\n  /* We can perform the test only if the file exists and is readable.\n     Test whether it exists, then assume it is world-readable.  */\n  if (stat (FILE2, &statbuf) >= 0)\n    {\n      size_t len;\n      char *out = read_file (FILE2, &len);\n\n      if (!out)\n        {\n          perror (\"Could not read file\");\n          err = 1;\n        }\n      else\n        {\n          if (out[len] != '\\0')\n            {\n              perror (\"BAD: out[len] not zero\");\n              err = 1;\n            }\n\n          /* /dev/null should always be empty.  Ignore statbuf.st_size, since it\n             is not a regular file.  */\n          if (len != 0)\n            {\n              fprintf (stderr, \"Read %lu from %s...\\n\",\n                       (unsigned long) len, FILE2);\n              err = 1;\n            }\n          free (out);\n        }\n    }\n\n  return err;\n}",
      "lines": 83,
      "depth": 17,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-readlink.c": {
    "main": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "int\nmain (void)\n{\n  /* Remove any leftovers from a previous partial run.  */\n  ignore_value (system (\"rm -rf \" BASE \"*\"));\n\n  return test_readlink (readlink, true);\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-readlink.h": {
    "test_readlink": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        118,
        1
      ],
      "content": "static int\ntest_readlink (ssize_t (*func) (char const *, char *, size_t), bool print)\n{\n  char buf[80];\n\n  /* Sanity checks of failures.  Mingw lacks symlink, but readlink can\n     still distinguish between various errors.  */\n  memset (buf, 0xff, sizeof buf);\n  errno = 0;\n  ASSERT (func (\"no_such\", buf, sizeof buf) == -1);\n  ASSERT (errno == ENOENT);\n  errno = 0;\n  ASSERT (func (\"no_such/\", buf, sizeof buf) == -1);\n  ASSERT (errno == ENOENT);\n  errno = 0;\n  ASSERT (func (\"\", buf, sizeof buf) == -1);\n  ASSERT (errno == ENOENT || errno == EINVAL);\n  errno = 0;\n  ASSERT (func (\".\", buf, sizeof buf) == -1);\n  ASSERT (errno == EINVAL);\n  errno = 0;\n  ASSERT (func (\"./\", buf, sizeof buf) == -1);\n  ASSERT (errno == EINVAL);\n  ASSERT (close (creat (BASE \"file\", 0600)) == 0);\n  errno = 0;\n  ASSERT (func (BASE \"file\", buf, sizeof buf) == -1);\n  ASSERT (errno == EINVAL);\n  errno = 0;\n  ASSERT (func (BASE \"file/\", buf, sizeof buf) == -1);\n  ASSERT (errno == ENOTDIR || errno == EINVAL); /* AIX yields EINVAL */\n\n  /* Now test actual symlinks.  */\n  if (symlink (BASE \"dir\", BASE \"link\"))\n    {\n      ASSERT (unlink (BASE \"file\") == 0);\n      if (print)\n        fputs (\"skipping test: symlinks not supported on this file system\\n\",\n               stderr);\n      return 77;\n    }\n  ASSERT (mkdir (BASE \"dir\", 0700) == 0);\n  errno = 0;\n  ASSERT (func (BASE \"link/\", buf, sizeof buf) == -1);\n  ASSERT (errno == EINVAL);\n  ASSERT (symlink (BASE \"link\", BASE \"link2\") == 0);\n  errno = 0;\n  ASSERT (func (BASE \"link2/\", buf, sizeof buf) == -1);\n  ASSERT (errno == EINVAL);\n  ASSERT (unlink (BASE \"link2\") == 0);\n  ASSERT (symlink (BASE \"file\", BASE \"link2\") == 0);\n  errno = 0;\n  ASSERT (func (BASE \"link2/\", buf, sizeof buf) == -1);\n  ASSERT (errno == ENOTDIR || errno == EINVAL); /* AIX yields EINVAL */\n  ASSERT (unlink (BASE \"file\") == 0);\n  ASSERT (unlink (BASE \"link2\") == 0);\n  {\n    /* Up till now, no readlink has been successful, so buf should be\n       unchanged.  */\n    int i;\n    for (i = 0; i < sizeof buf; i++)\n      ASSERT (buf[i] == (char) 0xff);\n  }\n  {\n    size_t len = strlen (BASE \"dir\");\n    /* When passing too small of a buffer, expect the truncated\n       length, or an ERANGE failure.  However, a size of 0 is not\n       portable enough to test.  */\n    ssize_t result;\n    errno = 0;\n    result = readlink (BASE \"link\", buf, 1);\n    if (result == -1)\n      {\n        ASSERT (errno == ERANGE);\n        ASSERT (buf[0] == (char) 0xff);\n      }\n    else\n      {\n        ASSERT (result == 1);\n        ASSERT (buf[0] == BASE[0]);\n      }\n    ASSERT (buf[1] == (char) 0xff);\n    ASSERT (func (BASE \"link\", buf, len) == len);\n    ASSERT (strncmp (buf, BASE \"dir\", len) == 0);\n    ASSERT (buf[len] == (char) 0xff);\n    ASSERT (func (BASE \"link\", buf, sizeof buf) == len);\n    ASSERT (strncmp (buf, BASE \"dir\", len) == 0);\n    /* POSIX says rest of buf is unspecified; but in practice, it is\n       either left alone, or NUL-terminated.  */\n    ASSERT (buf[len] == '\\0' || buf[len] == (char) 0xff);\n  }\n  ASSERT (rmdir (BASE \"dir\") == 0);\n  ASSERT (unlink (BASE \"link\") == 0);\n\n  return 0;\n}",
      "lines": 95,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-regex.c": {
    "main": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        252,
        1
      ],
      "content": "int\nmain (void)\n{\n  int result = 0;\n  static struct re_pattern_buffer regex;\n  unsigned char folded_chars[UCHAR_MAX + 1];\n  int i;\n  const char *s;\n  struct re_registers regs;\n\n#if HAVE_DECL_ALARM\n  /* Some builds of glibc go into an infinite loop on this test.  */\n  int alarm_value = 2;\n  signal (SIGALRM, SIG_DFL);\n  alarm (alarm_value);\n#endif\n  if (setlocale (LC_ALL, \"en_US.UTF-8\"))\n    {\n      {\n        /* https://sourceware.org/ml/libc-hacker/2006-09/msg00008.html\n           This test needs valgrind to catch the bug on Debian\n           GNU/Linux 3.1 x86, but it might catch the bug better\n           on other platforms and it shouldn't hurt to try the\n           test here.  */\n        static char const pat[] = \"insert into\";\n        static char const data[] =\n          \"\\xFF\\0\\x12\\xA2\\xAA\\xC4\\xB1,K\\x12\\xC4\\xB1*\\xACK\";\n        re_set_syntax (RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE\n                       | RE_ICASE);\n        memset (&regex, 0, sizeof regex);\n        s = re_compile_pattern (pat, sizeof pat - 1, &regex);\n        if (s)\n          result |= 1;\n        else\n          {\n            memset (&regs, 0, sizeof regs);\n            if (re_search (&regex, data, sizeof data - 1,\n                           0, sizeof data - 1, &regs)\n                != -1)\n              result |= 1;\n            regfree (&regex);\n            free (regs.start);\n            free (regs.end);\n          }\n      }\n\n      /* Check whether it's really a UTF-8 locale.\n         On mingw, the setlocale call succeeds but returns\n         \"English_United States.1252\", with locale_charset() returning\n         \"CP1252\".  */\n      if (strcmp (locale_charset (), \"UTF-8\") == 0)\n        {\n          /* This test is from glibc bug 15078.\n             The test case is from Andreas Schwab in\n             <https://sourceware.org/ml/libc-alpha/2013-01/msg00967.html>.\n          */\n          static char const pat[] = \"[^x]x\";\n          static char const data[] =\n            /* <U1000><U103B><U103D><U1014><U103A><U102F><U1015><U103A> */\n            \"\\xe1\\x80\\x80\"\n            \"\\xe1\\x80\\xbb\"\n            \"\\xe1\\x80\\xbd\"\n            \"\\xe1\\x80\\x94\"\n            \"\\xe1\\x80\\xba\"\n            \"\\xe1\\x80\\xaf\"\n            \"\\xe1\\x80\\x95\"\n            \"\\xe1\\x80\\xba\"\n            \"x\";\n          re_set_syntax (0);\n          memset (&regex, 0, sizeof regex);\n          s = re_compile_pattern (pat, sizeof pat - 1, &regex);\n          if (s)\n            result |= 1;\n          else\n            {\n              memset (&regs, 0, sizeof regs);\n              i = re_search (&regex, data, sizeof data - 1,\n                             0, sizeof data - 1, 0);\n              if (i != 0 && i != 21)\n                result |= 1;\n              regfree (&regex);\n              free (regs.start);\n              free (regs.end);\n            }\n        }\n\n      if (! setlocale (LC_ALL, \"C\"))\n        return 1;\n    }\n\n  /* This test is from glibc bug 3957, reported by Andrew Mackey.  */\n  re_set_syntax (RE_SYNTAX_EGREP | RE_HAT_LISTS_NOT_NEWLINE);\n  memset (&regex, 0, sizeof regex);\n  s = re_compile_pattern (\"a[^x]b\", 6, &regex);\n  if (s)\n    result |= 2;\n  /* This should fail, but succeeds for glibc-2.5.  */\n  else\n    {\n      memset (&regs, 0, sizeof regs);\n      if (re_search (&regex, \"a\\nb\", 3, 0, 3, &regs) != -1)\n        result |= 2;\n      regfree (&regex);\n      free (regs.start);\n      free (regs.end);\n    }\n\n  /* This regular expression is from Spencer ere test number 75\n     in grep-2.3.  */\n  re_set_syntax (RE_SYNTAX_POSIX_EGREP);\n  memset (&regex, 0, sizeof regex);\n  for (i = 0; i <= UCHAR_MAX; i++)\n    folded_chars[i] = i;\n  regex.translate = folded_chars;\n  s = re_compile_pattern (\"a[[:@:>@:]]b\\n\", 11, &regex);\n  /* This should fail with _Invalid character class name_ error.  */\n  if (!s)\n    {\n      result |= 4;\n      regfree (&regex);\n    }\n\n  /* Ensure that [b-a] is diagnosed as invalid, when\n     using RE_NO_EMPTY_RANGES. */\n  re_set_syntax (RE_SYNTAX_POSIX_EGREP | RE_NO_EMPTY_RANGES);\n  memset (&regex, 0, sizeof regex);\n  s = re_compile_pattern (\"a[b-a]\", 6, &regex);\n  if (s == 0)\n    {\n      result |= 8;\n      regfree (&regex);\n    }\n\n  /* This should succeed, but does not for glibc-2.1.3.  */\n  memset (&regex, 0, sizeof regex);\n  s = re_compile_pattern (\"{1\", 2, &regex);\n  if (s)\n    result |= 8;\n  else\n    regfree (&regex);\n\n  /* The following example is derived from a problem report\n     against gawk from Jorge Stolfi <stolfi@ic.unicamp.br>.  */\n  memset (&regex, 0, sizeof regex);\n  s = re_compile_pattern (\"[an\\371]*n\", 7, &regex);\n  if (s)\n    result |= 8;\n  /* This should match, but does not for glibc-2.2.1.  */\n  else\n    {\n      memset (&regs, 0, sizeof regs);\n      if (re_match (&regex, \"an\", 2, 0, &regs) != 2)\n        result |= 8;\n      regfree (&regex);\n      free (regs.start);\n      free (regs.end);\n    }\n\n  memset (&regex, 0, sizeof regex);\n  s = re_compile_pattern (\"x\", 1, &regex);\n  if (s)\n    result |= 8;\n  /* glibc-2.2.93 does not work with a negative RANGE argument.  */\n  else\n    {\n      memset (&regs, 0, sizeof regs);\n      if (re_search (&regex, \"wxy\", 3, 2, -2, &regs) != 1)\n        result |= 8;\n      regfree (&regex);\n      free (regs.start);\n      free (regs.end);\n    }\n\n  /* The version of regex.c in older versions of gnulib\n     ignored RE_ICASE.  Detect that problem too.  */\n  re_set_syntax (RE_SYNTAX_EMACS | RE_ICASE);\n  memset (&regex, 0, sizeof regex);\n  s = re_compile_pattern (\"x\", 1, &regex);\n  if (s)\n    result |= 16;\n  else\n    {\n      memset (&regs, 0, sizeof regs);\n      if (re_search (&regex, \"WXY\", 3, 0, 3, &regs) < 0)\n        result |= 16;\n      regfree (&regex);\n      free (regs.start);\n      free (regs.end);\n    }\n\n  /* Catch a bug reported by Vin Shelton in\n     https://lists.gnu.org/r/bug-coreutils/2007-06/msg00089.html\n     */\n  re_set_syntax (RE_SYNTAX_POSIX_BASIC\n                 & ~RE_CONTEXT_INVALID_DUP\n                 & ~RE_NO_EMPTY_RANGES);\n  memset (&regex, 0, sizeof regex);\n  s = re_compile_pattern (\"[[:alnum:]_-]\\\\\\\\+$\", 16, &regex);\n  if (s)\n    result |= 32;\n  else\n    regfree (&regex);\n\n  /* REG_STARTEND was added to glibc on 2004-01-15.\n     Reject older versions.  */\n  if (! REG_STARTEND)\n    result |= 64;\n\n#if 0\n  /* It would be nice to reject hosts whose regoff_t values are too\n     narrow (including glibc on hosts with 64-bit ptrdiff_t and\n     32-bit int), but we should wait until glibc implements this\n     feature.  Otherwise, support for equivalence classes and\n     multibyte collation symbols would always be broken except\n     when compiling --without-included-regex.   */\n  if (sizeof (regoff_t) < sizeof (ptrdiff_t)\n      || sizeof (regoff_t) < sizeof (ssize_t))\n    result |= 64;\n#endif\n\n  return result;\n}",
      "lines": 222,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-rename.c": {
    "main": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        46,
        1
      ],
      "content": "int\nmain (void)\n{\n  /* Remove any garbage left from previous partial runs.  */\n  ignore_value (system (\"rm -rf \" BASE \"*\"));\n\n  return test_rename (rename, true);\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-rename.h": {
    "dentry_exists": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "static bool\ndentry_exists (const char *filename)\n{\n  bool exists = false;\n  DIR *dir = opendir (\".\");\n\n  ASSERT (dir != NULL);\n  for (;;)\n    {\n      struct dirent *d = readdir (dir);\n      if (d == NULL)\n        break;\n      if (strcmp (d->d_name, filename) == 0)\n        {\n          exists = true;\n          break;\n        }\n    }\n  ASSERT (closedir (dir) == 0);\n  return exists;\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "assert_nonexistent": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "static void\nassert_nonexistent (const char *filename)\n{\n  struct stat st;\n\n  /* The usual way to test the presence of a file is via stat() or lstat().  */\n  errno = 0;\n  if (stat (filename, &st) == -1)\n    ASSERT (errno == ENOENT);\n  else\n    {\n      /* But after renaming a directory over an empty directory on an NFS-\n         mounted file system, on Linux 2.6.18, for a period of 30 seconds the\n         old directory name is \"present\" according to stat() but \"nonexistent\"\n         according to dentry_exists().  */\n      ASSERT (!dentry_exists (filename));\n      /* Remove the old directory name, so that subsequent mkdir calls\n         succeed.  */\n      (void) rmdir (filename);\n    }\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_rename": {
      "start_point": [
        70,
        0
      ],
      "end_point": [
        958,
        1
      ],
      "content": "static int\ntest_rename (int (*func) (char const *, char const *), bool print)\n{\n  /* Setup.  */\n  struct stat st;\n  int fd = creat (BASE \"file\", 0600);\n  ASSERT (0 <= fd);\n  ASSERT (write (fd, \"hi\", 2) == 2);\n  ASSERT (close (fd) == 0);\n  ASSERT (mkdir (BASE \"dir\", 0700) == 0);\n\n  /* Files present here:\n       {BASE}file\n       {BASE}dir/\n   */\n\n  /* Obvious errors.  */\n\n  { /* Missing source.  */\n    {\n      errno = 0;\n      ASSERT (func (BASE \"missing\", BASE \"missing\") == -1);\n      ASSERT (errno == ENOENT);\n    }\n    {\n      errno = 0;\n      ASSERT (func (BASE \"missing/\", BASE \"missing\") == -1);\n      ASSERT (errno == ENOENT);\n    }\n    {\n      errno = 0;\n      ASSERT (func (BASE \"missing\", BASE \"missing/\") == -1);\n      ASSERT (errno == ENOENT);\n    }\n  }\n  { /* Empty operand.  */\n    {\n      errno = 0;\n      ASSERT (func (\"\", BASE \"missing\") == -1);\n      ASSERT (errno == ENOENT);\n    }\n    {\n      errno = 0;\n      ASSERT (func (BASE \"file\", \"\") == -1);\n      ASSERT (errno == ENOENT);\n    }\n    {\n      errno = 0;\n      ASSERT (func (BASE \"\", \"\") == -1);\n      ASSERT (errno == ENOENT);\n    }\n  }\n\n  /* Files.  */\n\n  { /* Trailing slash.  */\n    {\n      errno = 0;\n      ASSERT (func (BASE \"file\", BASE \"file2/\") == -1);\n      ASSERT (errno == ENOENT || errno == ENOTDIR);\n    }\n    {\n      errno = 0;\n      ASSERT (func (BASE \"file/\", BASE \"file2\") == -1);\n      ASSERT (errno == ENOTDIR);\n    }\n    {\n      errno = 0;\n      ASSERT (stat (BASE \"file2\", &st) == -1);\n      ASSERT (errno == ENOENT);\n    }\n  }\n  { /* Simple rename.  */\n    ASSERT (func (BASE \"file\", BASE \"file2\") == 0);\n    errno = 0;\n    ASSERT (stat (BASE \"file\", &st) == -1);\n    ASSERT (errno == ENOENT);\n    memset (&st, 0, sizeof st);\n    ASSERT (stat (BASE \"file2\", &st) == 0);\n    ASSERT (st.st_size == 2);\n  }\n  /* Files present here:\n       {BASE}file2\n       {BASE}dir/\n   */\n  { /* Overwrite.  */\n    ASSERT (close (creat (BASE \"file\", 0600)) == 0);\n    errno = 0;\n    ASSERT (func (BASE \"file2\", BASE \"file/\") == -1);\n    ASSERT (errno == ENOTDIR);\n    ASSERT (func (BASE \"file2\", BASE \"file\") == 0);\n    memset (&st, 0, sizeof st);\n    ASSERT (stat (BASE \"file\", &st) == 0);\n    ASSERT (st.st_size == 2);\n    errno = 0;\n    ASSERT (stat (BASE \"file2\", &st) == -1);\n    ASSERT (errno == ENOENT);\n  }\n  /* Files present here:\n       {BASE}file\n       {BASE}dir/\n   */\n\n  /* Directories.  */\n\n  { /* Simple rename.  */\n    {\n      ASSERT (func (BASE \"dir\", BASE \"dir2/\") == 0);\n      errno = 0;\n      ASSERT (stat (BASE \"dir\", &st) == -1);\n      ASSERT (errno == ENOENT);\n      ASSERT (stat (BASE \"dir2\", &st) == 0);\n    }\n    /* Files present here:\n         {BASE}file\n         {BASE}dir2/\n     */\n    {\n      ASSERT (func (BASE \"dir2/\", BASE \"dir\") == 0);\n      ASSERT (stat (BASE \"dir\", &st) == 0);\n      errno = 0;\n      ASSERT (stat (BASE \"dir2\", &st) == -1);\n      ASSERT (errno == ENOENT);\n    }\n    /* Files present here:\n         {BASE}file\n         {BASE}dir/\n     */\n    {\n      ASSERT (func (BASE \"dir\", BASE \"dir2\") == 0);\n      errno = 0;\n      ASSERT (stat (BASE \"dir\", &st) == -1);\n      ASSERT (errno == ENOENT);\n      ASSERT (stat (BASE \"dir2\", &st) == 0);\n    }\n    /* Files present here:\n         {BASE}file\n         {BASE}dir2/\n     */\n    { /* Empty onto empty.  */\n      ASSERT (mkdir (BASE \"dir\", 0700) == 0);\n      /* Files present here:\n           {BASE}file\n           {BASE}dir/\n           {BASE}dir2/\n       */\n      ASSERT (func (BASE \"dir2\", BASE \"dir\") == 0);\n      /* Files present here:\n           {BASE}file\n           {BASE}dir/\n       */\n      ASSERT (mkdir (BASE \"dir2\", 0700) == 0);\n      /* Files present here:\n           {BASE}file\n           {BASE}dir/\n           {BASE}dir2/\n       */\n      ASSERT (func (BASE \"dir2\", BASE \"dir/\") == 0);\n      /* Files present here:\n           {BASE}file\n           {BASE}dir/\n       */\n      ASSERT (mkdir (BASE \"dir2\", 0700) == 0);\n      /* Files present here:\n           {BASE}file\n           {BASE}dir/\n           {BASE}dir2/\n       */\n      ASSERT (func (BASE \"dir2/\", BASE \"dir\") == 0);\n      /* Files present here:\n           {BASE}file\n           {BASE}dir/\n       */\n      ASSERT (mkdir (BASE \"dir2\", 0700) == 0);\n    }\n    /* Files present here:\n         {BASE}file\n         {BASE}dir/\n         {BASE}dir2/\n     */\n    { /* Empty onto full.  */\n      ASSERT (close (creat (BASE \"dir/file\", 0600)) == 0);\n      /* Files present here:\n           {BASE}file\n           {BASE}dir/\n           {BASE}dir/file\n           {BASE}dir2/\n       */\n      {\n        errno = 0;\n        ASSERT (func (BASE \"dir2\", BASE \"dir\") == -1);\n        ASSERT (errno == EEXIST || errno == ENOTEMPTY);\n      }\n      {\n        errno = 0;\n        ASSERT (func (BASE \"dir2/\", BASE \"dir\") == -1);\n        ASSERT (errno == EEXIST || errno == ENOTEMPTY);\n      }\n      {\n        errno = 0;\n        ASSERT (func (BASE \"dir2\", BASE \"dir/\") == -1);\n        ASSERT (errno == EEXIST || errno == ENOTEMPTY);\n      }\n    }\n    { /* Full onto empty.  */\n      ASSERT (func (BASE \"dir\", BASE \"dir2\") == 0);\n      assert_nonexistent (BASE \"dir\");\n      ASSERT (stat (BASE \"dir2/file\", &st) == 0);\n      /* Files present here:\n           {BASE}file\n           {BASE}dir2/\n           {BASE}dir2/file\n       */\n      ASSERT (mkdir (BASE \"dir\", 0700) == 0);\n      /* Files present here:\n           {BASE}file\n           {BASE}dir/\n           {BASE}dir2/\n           {BASE}dir2/file\n       */\n      {\n        ASSERT (func (BASE \"dir2/\", BASE \"dir\") == 0);\n        ASSERT (stat (BASE \"dir/file\", &st) == 0);\n        errno = 0;\n        ASSERT (stat (BASE \"dir2\", &st) == -1);\n        ASSERT (errno == ENOENT);\n      }\n      /* Files present here:\n           {BASE}file\n           {BASE}dir/\n           {BASE}dir/file\n       */\n      ASSERT (mkdir (BASE \"dir2\", 0700) == 0);\n      /* Files present here:\n           {BASE}file\n           {BASE}dir/\n           {BASE}dir/file\n           {BASE}dir2/\n       */\n      {\n        ASSERT (func (BASE \"dir\", BASE \"dir2/\") == 0);\n        assert_nonexistent (BASE \"dir\");\n        ASSERT (stat (BASE \"dir2/file\", &st) == 0);\n      }\n      /* Files present here:\n           {BASE}file\n           {BASE}dir2/\n           {BASE}dir2/file\n       */\n      ASSERT (unlink (BASE \"dir2/file\") == 0);\n    }\n    /* Files present here:\n         {BASE}file\n         {BASE}dir2/\n     */\n    { /* Reject trailing dot.  */\n      {\n        errno = 0;\n        ASSERT (func (BASE \"dir2\", BASE \"dir/.\") == -1);\n        ASSERT (errno == EINVAL || errno == ENOENT);\n      }\n      ASSERT (mkdir (BASE \"dir\", 0700) == 0);\n      /* Files present here:\n           {BASE}file\n           {BASE}dir/\n           {BASE}dir2/\n       */\n      {\n        errno = 0;\n        ASSERT (func (BASE \"dir2\", BASE \"dir/.\") == -1);\n        ASSERT (errno == EINVAL || errno == EBUSY || errno == EISDIR\n                || errno == ENOTEMPTY || errno == EEXIST\n                || errno == ENOENT /* WSL */);\n      }\n      {\n        errno = 0;\n        ASSERT (func (BASE \"dir2/.\", BASE \"dir\") == -1);\n        ASSERT (errno == EINVAL || errno == EBUSY || errno == EEXIST\n                || errno == ENOENT /* WSL */);\n      }\n      ASSERT (rmdir (BASE \"dir\") == 0);\n      /* Files present here:\n           {BASE}file\n           {BASE}dir2/\n       */\n      {\n        errno = 0;\n        ASSERT (func (BASE \"dir2\", BASE \"dir/.//\") == -1);\n        ASSERT (errno == EINVAL || errno == ENOENT);\n      }\n      ASSERT (mkdir (BASE \"dir\", 0700) == 0);\n      /* Files present here:\n           {BASE}file\n           {BASE}dir/\n           {BASE}dir2/\n       */\n      {\n        errno = 0;\n        ASSERT (func (BASE \"dir2\", BASE \"dir/.//\") == -1);\n        ASSERT (errno == EINVAL || errno == EBUSY || errno == EISDIR\n                || errno == ENOTEMPTY || errno == EEXIST\n                || errno == ENOENT /* WSL */);\n      }\n      {\n        errno = 0;\n        ASSERT (func (BASE \"dir2/.//\", BASE \"dir\") == -1);\n        ASSERT (errno == EINVAL || errno == EBUSY || errno == EEXIST\n                || errno == ENOENT /* WSL */);\n      }\n      ASSERT (rmdir (BASE \"dir2\") == 0);\n      /* Files present here:\n           {BASE}file\n           {BASE}dir/\n       */\n    }\n    { /* Move into subdir.  */\n      {\n        errno = 0;\n        ASSERT (func (BASE \"dir\", BASE \"dir/sub\") == -1);\n        ASSERT (errno == EINVAL || errno == EACCES);\n      }\n      {\n        errno = 0;\n        ASSERT (stat (BASE \"dir/sub\", &st) == -1);\n        ASSERT (errno == ENOENT);\n      }\n      ASSERT (mkdir (BASE \"dir/sub\", 0700) == 0);\n      /* Files present here:\n           {BASE}file\n           {BASE}dir/\n           {BASE}dir/sub/\n       */\n      {\n        errno = 0;\n        ASSERT (func (BASE \"dir\", BASE \"dir/sub\") == -1);\n        ASSERT (errno == EINVAL);\n        ASSERT (stat (BASE \"dir/sub\", &st) == 0);\n      }\n      ASSERT (rmdir (BASE \"dir/sub\") == 0);\n    }\n  }\n  /* Files present here:\n       {BASE}file\n       {BASE}dir/\n   */\n\n  /* Mixing file and directory.  */\n\n  {\n    { /* File onto dir.  */\n      {\n        errno = 0;\n        ASSERT (func (BASE \"file\", BASE \"dir\") == -1);\n        ASSERT (errno == EISDIR || errno == ENOTDIR);\n      }\n      {\n        errno = 0;\n        ASSERT (func (BASE \"file\", BASE \"dir/\") == -1);\n        ASSERT (errno == EISDIR || errno == ENOTDIR);\n      }\n    }\n    { /* Dir onto file.  */\n      {\n        errno = 0;\n        ASSERT (func (BASE \"dir\", BASE \"file\") == -1);\n        ASSERT (errno == ENOTDIR);\n      }\n      {\n        errno = 0;\n        ASSERT (func (BASE \"dir/\", BASE \"file\") == -1);\n        ASSERT (errno == ENOTDIR);\n      }\n    }\n  }\n\n  /* Hard links.  */\n\n  { /* File onto self.  */\n    ASSERT (func (BASE \"file\", BASE \"file\") == 0);\n    memset (&st, 0, sizeof st);\n    ASSERT (stat (BASE \"file\", &st) == 0);\n    ASSERT (st.st_size == 2);\n  }\n  /* Files present here:\n       {BASE}file\n       {BASE}dir/\n   */\n  { /* Empty dir onto self.  */\n    ASSERT (func (BASE \"dir\", BASE \"dir\") == 0);\n    ASSERT (stat (BASE \"dir\", &st) == 0);\n  }\n  /* Files present here:\n       {BASE}file\n       {BASE}dir/\n   */\n  ASSERT (close (creat (BASE \"dir/file\", 0600)) == 0);\n  /* Files present here:\n       {BASE}file\n       {BASE}dir/\n       {BASE}dir/file\n   */\n  { /* Full dir onto self.  */\n    ASSERT (func (BASE \"dir\", BASE \"dir\") == 0);\n  }\n  ASSERT (unlink (BASE \"dir/file\") == 0);\n  /* Files present here:\n       {BASE}file\n       {BASE}dir/\n   */\n  {\n    /*  Not all file systems support link.  Mingw doesn't have\n        reliable st_nlink on hard links, but our implementation does\n        fail with EPERM on poor file systems, and we can detect the\n        inferior stat() via st_ino.  Cygwin 1.5.x copies rather than\n        links files on those file systems, but there, st_nlink and\n        st_ino are reliable.  */\n    int ret = link (BASE \"file\", BASE \"file2\");\n    if (!ret)\n      {\n        memset (&st, 0, sizeof st);\n        ASSERT (stat (BASE \"file2\", &st) == 0);\n        if (st.st_ino && st.st_nlink != 2)\n          {\n            ASSERT (unlink (BASE \"file2\") == 0);\n            errno = EPERM;\n            ret = -1;\n          }\n      }\n    if (ret == -1)\n      {\n        /* If the device does not support hard links, errno is\n           EPERM on Linux, EOPNOTSUPP on FreeBSD.  */\n        switch (errno)\n          {\n          case EPERM:\n          case EOPNOTSUPP:\n            if (print)\n              fputs (\"skipping test: \"\n                     \"hard links not supported on this file system\\n\",\n                     stderr);\n            ASSERT (unlink (BASE \"file\") == 0);\n            ASSERT (rmdir (BASE \"dir\") == 0);\n            return 77;\n          default:\n            perror (\"link\");\n            return 1;\n          }\n      }\n    ASSERT (ret == 0);\n  }\n  /* Files present here:\n       {BASE}file\n       {BASE}file2       (hard link to file)\n       {BASE}dir/\n   */\n  { /* File onto hard link.  */\n    ASSERT (func (BASE \"file\", BASE \"file2\") == 0);\n    memset (&st, 0, sizeof st);\n    if (stat (BASE \"file\", &st) != 0)\n      {\n        /* This can happen on NetBSD.  */\n        ASSERT (errno == ENOENT);\n        ASSERT (link (BASE \"file2\", BASE \"file\") == 0);\n        ASSERT (stat (BASE \"file\", &st) == 0);\n      }\n    ASSERT (st.st_size == 2);\n    memset (&st, 0, sizeof st);\n    ASSERT (stat (BASE \"file2\", &st) == 0);\n    ASSERT (st.st_size == 2);\n  }\n  /* Files present here:\n       {BASE}file\n       {BASE}file2\n       {BASE}dir/\n   */\n  ASSERT (unlink (BASE \"file2\") == 0);\n  /* Files present here:\n       {BASE}file\n       {BASE}dir/\n   */\n\n  /* Symlinks.  */\n\n  if (symlink (BASE \"file\", BASE \"link1\"))\n    {\n      if (print)\n        fputs (\"skipping test: symlinks not supported on this file system\\n\",\n               stderr);\n      ASSERT (unlink (BASE \"file\") == 0);\n      ASSERT (rmdir (BASE \"dir\") == 0);\n      return 77;\n    }\n  /* Files present here:\n       {BASE}file\n       {BASE}link1 -> {BASE}file\n       {BASE}dir/\n   */\n  { /* Simple rename.  */\n    ASSERT (func (BASE \"link1\", BASE \"link2\") == 0);\n    ASSERT (stat (BASE \"file\", &st) == 0);\n    errno = 0;\n    ASSERT (lstat (BASE \"link1\", &st) == -1);\n    ASSERT (errno == ENOENT);\n    memset (&st, 0, sizeof st);\n    ASSERT (lstat (BASE \"link2\", &st) == 0);\n    ASSERT (S_ISLNK (st.st_mode));\n  }\n  /* Files present here:\n       {BASE}file\n       {BASE}link2 -> {BASE}file\n       {BASE}dir/\n   */\n  { /* Overwrite.  */\n    ASSERT (symlink (BASE \"nowhere\", BASE \"link1\") == 0);\n    /* Files present here:\n         {BASE}file\n         {BASE}link1 -> {BASE}nowhere\n         {BASE}link2 -> {BASE}file\n         {BASE}dir/\n     */\n    {\n      ASSERT (func (BASE \"link2\", BASE \"link1\") == 0);\n      memset (&st, 0, sizeof st);\n      ASSERT (stat (BASE \"link1\", &st) == 0);\n      ASSERT (st.st_size == 2);\n      errno = 0;\n      ASSERT (lstat (BASE \"link2\", &st) == -1);\n      ASSERT (errno == ENOENT);\n    }\n  }\n  /* Files present here:\n       {BASE}file\n       {BASE}link1 -> {BASE}file\n       {BASE}dir/\n   */\n  { /* Symlink loop.  */\n    ASSERT (symlink (BASE \"link2\", BASE \"link2\") == 0);\n    /* Files present here:\n         {BASE}file\n         {BASE}link1 -> {BASE}file\n         {BASE}link2 -> {BASE}link2\n         {BASE}dir/\n     */\n    {\n      ASSERT (func (BASE \"link2\", BASE \"link2\") == 0);\n    }\n    {\n      errno = 0;\n      ASSERT (func (BASE \"link2/\", BASE \"link2\") == -1);\n      ASSERT (errno == ELOOP || errno == ENOTDIR);\n    }\n    ASSERT (func (BASE \"link2\", BASE \"link3\") == 0);\n    /* Files present here:\n         {BASE}file\n         {BASE}link1 -> {BASE}file\n         {BASE}link3 -> {BASE}link2\n         {BASE}dir/\n     */\n    ASSERT (unlink (BASE \"link3\") == 0);\n  }\n  /* Files present here:\n       {BASE}file\n       {BASE}link1 -> {BASE}file\n       {BASE}dir/\n   */\n  { /* Dangling link.  */\n    ASSERT (symlink (BASE \"nowhere\", BASE \"link2\") == 0);\n    /* Files present here:\n         {BASE}file\n         {BASE}link1 -> {BASE}file\n         {BASE}link2 -> {BASE}nowhere\n         {BASE}dir/\n     */\n    {\n      ASSERT (func (BASE \"link2\", BASE \"link3\") == 0);\n      errno = 0;\n      ASSERT (lstat (BASE \"link2\", &st) == -1);\n      ASSERT (errno == ENOENT);\n      memset (&st, 0, sizeof st);\n      ASSERT (lstat (BASE \"link3\", &st) == 0);\n    }\n  }\n  /* Files present here:\n       {BASE}file\n       {BASE}link1 -> {BASE}file\n       {BASE}link3 -> {BASE}nowhere\n       {BASE}dir/\n   */\n  { /* Trailing slash on dangling.  */\n    {\n      errno = 0;\n      ASSERT (func (BASE \"link3/\", BASE \"link2\") == -1);\n      ASSERT (errno == ENOENT || errno == ENOTDIR);\n    }\n    {\n      errno = 0;\n      ASSERT (func (BASE \"link3\", BASE \"link2/\") == -1);\n      ASSERT (errno == ENOENT || errno == ENOTDIR);\n    }\n    {\n      errno = 0;\n      ASSERT (lstat (BASE \"link2\", &st) == -1);\n      ASSERT (errno == ENOENT);\n    }\n    memset (&st, 0, sizeof st);\n    ASSERT (lstat (BASE \"link3\", &st) == 0);\n  }\n  /* Files present here:\n       {BASE}file\n       {BASE}link1 -> {BASE}file\n       {BASE}link3 -> {BASE}nowhere\n       {BASE}dir/\n   */\n  { /* Trailing slash on link to file.  */\n    {\n      errno = 0;\n      ASSERT (func (BASE \"link1/\", BASE \"link2\") == -1);\n      ASSERT (errno == ENOTDIR);\n    }\n    {\n      errno = 0;\n      ASSERT (func (BASE \"link1\", BASE \"link3/\") == -1);\n      ASSERT (errno == ENOENT || errno == ENOTDIR);\n    }\n  }\n  /* Files present here:\n       {BASE}file\n       {BASE}link1 -> {BASE}file\n       {BASE}link3 -> {BASE}nowhere\n       {BASE}dir/\n   */\n\n  /* Mixing symlink and file.  */\n\n  { /* File onto link.  */\n    ASSERT (close (creat (BASE \"file2\", 0600)) == 0);\n    /* Files present here:\n         {BASE}file\n         {BASE}file2\n         {BASE}link1 -> {BASE}file\n         {BASE}link3 -> {BASE}nowhere\n         {BASE}dir/\n     */\n    {\n      ASSERT (func (BASE \"file2\", BASE \"link3\") == 0);\n      errno = 0;\n      ASSERT (stat (BASE \"file2\", &st) == -1);\n      ASSERT (errno == ENOENT);\n      memset (&st, 0, sizeof st);\n      ASSERT (lstat (BASE \"link3\", &st) == 0);\n      ASSERT (S_ISREG (st.st_mode));\n    }\n    /* Files present here:\n         {BASE}file\n         {BASE}link1 -> {BASE}file\n         {BASE}link3\n         {BASE}dir/\n     */\n    ASSERT (unlink (BASE \"link3\") == 0);\n  }\n  /* Files present here:\n       {BASE}file\n       {BASE}link1 -> {BASE}file\n       {BASE}dir/\n   */\n  { /* Link onto file.  */\n    ASSERT (symlink (BASE \"nowhere\", BASE \"link2\") == 0);\n    /* Files present here:\n         {BASE}file\n         {BASE}link1 -> {BASE}file\n         {BASE}link2 -> {BASE}nowhere\n         {BASE}dir/\n     */\n    ASSERT (close (creat (BASE \"file2\", 0600)) == 0);\n    /* Files present here:\n         {BASE}file\n         {BASE}file2\n         {BASE}link1 -> {BASE}file\n         {BASE}link2 -> {BASE}nowhere\n         {BASE}dir/\n     */\n    {\n      ASSERT (func (BASE \"link2\", BASE \"file2\") == 0);\n      errno = 0;\n      ASSERT (lstat (BASE \"link2\", &st) == -1);\n      ASSERT (errno == ENOENT);\n      memset (&st, 0, sizeof st);\n      ASSERT (lstat (BASE \"file2\", &st) == 0);\n      ASSERT (S_ISLNK (st.st_mode));\n    }\n    /* Files present here:\n         {BASE}file\n         {BASE}file2 -> {BASE}nowhere\n         {BASE}link1 -> {BASE}file\n         {BASE}dir/\n     */\n    ASSERT (unlink (BASE \"file2\") == 0);\n  }\n  /* Files present here:\n       {BASE}file\n       {BASE}link1 -> {BASE}file\n       {BASE}dir/\n   */\n  { /* Trailing slash.  */\n    {\n      errno = 0;\n      ASSERT (func (BASE \"file/\", BASE \"link1\") == -1);\n      ASSERT (errno == ENOTDIR);\n    }\n    {\n      errno = 0;\n      ASSERT (func (BASE \"file\", BASE \"link1/\") == -1);\n      ASSERT (errno == ENOTDIR || errno == ENOENT);\n    }\n    {\n      errno = 0;\n      ASSERT (func (BASE \"link1/\", BASE \"file\") == -1);\n      ASSERT (errno == ENOTDIR);\n    }\n    {\n      errno = 0;\n      ASSERT (func (BASE \"link1\", BASE \"file/\") == -1);\n      ASSERT (errno == ENOTDIR || errno == ENOENT);\n      memset (&st, 0, sizeof st);\n      ASSERT (lstat (BASE \"file\", &st) == 0);\n      ASSERT (S_ISREG (st.st_mode));\n      memset (&st, 0, sizeof st);\n      ASSERT (lstat (BASE \"link1\", &st) == 0);\n      ASSERT (S_ISLNK (st.st_mode));\n    }\n  }\n  /* Files present here:\n       {BASE}file\n       {BASE}link1 -> {BASE}file\n       {BASE}dir/\n   */\n\n  /* Mixing symlink and directory.  */\n\n  { /* Directory onto link.  */\n    {\n      errno = 0;\n      ASSERT (func (BASE \"dir\", BASE \"link1\") == -1);\n      ASSERT (errno == ENOTDIR);\n    }\n    {\n      errno = 0;\n      ASSERT (func (BASE \"dir/\", BASE \"link1\") == -1);\n      ASSERT (errno == ENOTDIR);\n    }\n    {\n      errno = 0;\n      ASSERT (func (BASE \"dir\", BASE \"link1/\") == -1);\n      ASSERT (errno == ENOTDIR);\n    }\n  }\n  { /* Link onto directory.  */\n    {\n      errno = 0;\n      ASSERT (func (BASE \"link1\", BASE \"dir\") == -1);\n      ASSERT (errno == EISDIR || errno == ENOTDIR);\n    }\n    {\n      errno = 0;\n      ASSERT (func (BASE \"link1\", BASE \"dir/\") == -1);\n      ASSERT (errno == EISDIR || errno == ENOTDIR);\n    }\n    {\n      errno = 0;\n      ASSERT (func (BASE \"link1/\", BASE \"dir\") == -1);\n      ASSERT (errno == ENOTDIR);\n      memset (&st, 0, sizeof st);\n      ASSERT (lstat (BASE \"link1\", &st) == 0);\n      ASSERT (S_ISLNK (st.st_mode));\n      memset (&st, 0, sizeof st);\n      ASSERT (lstat (BASE \"dir\", &st) == 0);\n      ASSERT (S_ISDIR (st.st_mode));\n    }\n  }\n  /* Files present here:\n       {BASE}file\n       {BASE}link1 -> {BASE}file\n       {BASE}dir/\n   */\n\n  /* POSIX requires rename(\"link-to-dir/\",\"other\") to rename \"dir\" and\n     leave \"link-to-dir\" dangling, but GNU rejects this.  POSIX\n     requires rename(\"dir\",\"dangling/\") to create the directory so\n     that \"dangling/\" now resolves, but GNU rejects this.  While we\n     prefer GNU behavior, we don't enforce it.  However, we do test\n     that the system either follows POSIX in both cases, or follows\n     GNU.  */\n  {\n    int result;\n    ASSERT (symlink (BASE \"dir2\", BASE \"link2\") == 0);\n    /* Files present here:\n         {BASE}file\n         {BASE}link1 -> {BASE}file\n         {BASE}link2 -> {BASE}dir2\n         {BASE}dir/\n     */\n    errno = 0;\n    result = func (BASE \"dir\", BASE \"link2/\");\n    if (result == 0)\n      {\n        /* POSIX.  */\n        errno = 0;\n        ASSERT (lstat (BASE \"dir\", &st) == -1);\n        ASSERT (errno == ENOENT);\n        memset (&st, 0, sizeof st);\n        ASSERT (lstat (BASE \"dir2\", &st) == 0);\n        ASSERT (S_ISDIR (st.st_mode));\n        memset (&st, 0, sizeof st);\n        ASSERT (lstat (BASE \"link2\", &st) == 0);\n        ASSERT (S_ISLNK (st.st_mode));\n        /* Files present here:\n             {BASE}file\n             {BASE}link1 -> {BASE}file\n             {BASE}link2 -> {BASE}dir2\n             {BASE}dir2/\n         */\n        {\n          ASSERT (func (BASE \"link2/\", BASE \"dir\") == 0);\n          memset (&st, 0, sizeof st);\n          ASSERT (lstat (BASE \"dir\", &st) == 0);\n          ASSERT (S_ISDIR (st.st_mode));\n          errno = 0;\n          ASSERT (lstat (BASE \"dir2\", &st) == -1);\n          ASSERT (errno == ENOENT);\n          memset (&st, 0, sizeof st);\n          ASSERT (lstat (BASE \"link2\", &st) == 0);\n          ASSERT (S_ISLNK (st.st_mode));\n        }\n      }\n    else\n      {\n        /* GNU.  */\n        ASSERT (result == -1);\n        ASSERT (errno == ENOTDIR);\n        memset (&st, 0, sizeof st);\n        ASSERT (lstat (BASE \"dir\", &st) == 0);\n        ASSERT (S_ISDIR (st.st_mode));\n        errno = 0;\n        ASSERT (lstat (BASE \"dir2\", &st) == -1);\n        ASSERT (errno == ENOENT);\n        memset (&st, 0, sizeof st);\n        ASSERT (lstat (BASE \"link2\", &st) == 0);\n        ASSERT (S_ISLNK (st.st_mode));\n        ASSERT (unlink (BASE \"link2\") == 0);\n        ASSERT (symlink (BASE \"dir\", BASE \"link2\") == 0);\n        /* Files present here:\n             {BASE}file\n             {BASE}link1 -> {BASE}file\n             {BASE}link2 -> {BASE}dir\n             {BASE}dir/\n         */\n        errno = 0; /* OpenBSD notices that link2/ and dir are the same.  */\n        result = func (BASE \"link2/\", BASE \"dir\");\n        if (result) /* GNU/Linux rejects attempts to use link2/.  */\n          {\n            ASSERT (result == -1);\n            ASSERT (errno == ENOTDIR || errno == EISDIR);\n          }\n        memset (&st, 0, sizeof st);\n        ASSERT (lstat (BASE \"dir\", &st) == 0);\n        ASSERT (S_ISDIR (st.st_mode));\n        errno = 0;\n        ASSERT (lstat (BASE \"dir2\", &st) == -1);\n        ASSERT (errno == ENOENT);\n        memset (&st, 0, sizeof st);\n        ASSERT (lstat (BASE \"link2\", &st) == 0);\n        ASSERT (S_ISLNK (st.st_mode));\n      }\n  }\n  /* Files present here:\n       {BASE}file\n       {BASE}link1 -> {BASE}file\n       {BASE}link2 -> {BASE}dir or {BASE}dir2\n       {BASE}dir/\n   */\n\n  /* Clean up.  */\n  ASSERT (unlink (BASE \"file\") == 0);\n  ASSERT (rmdir (BASE \"dir\") == 0);\n  ASSERT (unlink (BASE \"link1\") == 0);\n  ASSERT (unlink (BASE \"link2\") == 0);\n\n  return 0;\n}",
      "lines": 889,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-rmdir.c": {
    "main": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        46,
        1
      ],
      "content": "int\nmain (void)\n{\n  /* Remove any leftovers from a previous partial run.  */\n  ignore_value (system (\"rm -rf \" BASE \"*\"));\n\n  return test_rmdir_func (rmdir, true);\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-rmdir.h": {
    "test_rmdir_func": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        101,
        1
      ],
      "content": "static int\ntest_rmdir_func (int (*func) (char const *name), bool print)\n{\n  /* Setup.  */\n  ASSERT (mkdir (BASE \"dir\", 0700) == 0);\n  ASSERT (close (creat (BASE \"dir/file\", 0600)) == 0);\n\n  /* Basic error conditions.  */\n  errno = 0;\n  ASSERT (func (\"\") == -1);\n  ASSERT (errno == ENOENT);\n  errno = 0;\n  ASSERT (func (BASE \"nosuch\") == -1);\n  ASSERT (errno == ENOENT);\n  errno = 0;\n  ASSERT (func (BASE \"nosuch/\") == -1);\n  ASSERT (errno == ENOENT);\n  errno = 0;\n  ASSERT (func (\".\") == -1);\n  ASSERT (errno == EINVAL || errno == EBUSY);\n  /* Resulting errno after \"..\" or \"/\" is too varied to test; it is\n     reasonable to see any of EINVAL, EBUSY, EEXIST, ENOTEMPTY,\n     EACCES, EPERM.  */\n  ASSERT (func (\"..\") == -1);\n  ASSERT (func (\"/\") == -1);\n  ASSERT (func (\"///\") == -1);\n  errno = 0;\n  ASSERT (func (BASE \"dir/file/\") == -1);\n  ASSERT (errno == ENOTDIR);\n\n  /* Non-empty directory.  */\n  errno = 0;\n  ASSERT (func (BASE \"dir\") == -1);\n  ASSERT (errno == EEXIST || errno == ENOTEMPTY);\n\n  /* Non-directory.  */\n  errno = 0;\n  ASSERT (func (BASE \"dir/file\") == -1);\n  ASSERT (errno == ENOTDIR);\n\n  /* Empty directory.  */\n  ASSERT (unlink (BASE \"dir/file\") == 0);\n  errno = 0;\n  ASSERT (func (BASE \"dir/.//\") == -1);\n  ASSERT (errno == EINVAL || errno == EBUSY || errno == EEXIST\n          || errno == ENOTEMPTY);\n  ASSERT (func (BASE \"dir\") == 0);\n\n  /* Test symlink behavior.  Specifying trailing slash should remove\n     referent directory (POSIX), or cause ENOTDIR failure (Linux), but\n     not touch symlink.  We prefer the Linux behavior for its\n     intuitiveness (especially compared to rmdir(\"symlink-to-file/\")),\n     but not enough to penalize POSIX systems with an rpl_rmdir.  */\n  if (symlink (BASE \"dir\", BASE \"link\") != 0)\n    {\n      if (print)\n        fputs (\"skipping test: symlinks not supported on this file system\\n\",\n               stderr);\n      return 77;\n    }\n  ASSERT (mkdir (BASE \"dir\", 0700) == 0);\n  errno = 0;\n  if (func (BASE \"link/\") == 0)\n    {\n      struct stat st;\n      errno = 0;\n      ASSERT (stat (BASE \"link\", &st) == -1);\n      ASSERT (errno == ENOENT);\n    }\n  else\n    {\n      ASSERT (errno == ENOTDIR);\n      ASSERT (func (BASE \"dir\") == 0);\n    }\n  ASSERT (unlink (BASE \"link\") == 0);\n\n  return 0;\n}",
      "lines": 78,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-sameacls.c": {
    "main": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        694,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  const char *file1;\n  const char *file2;\n\n  ASSERT (argc == 3);\n\n  file1 = argv[1];\n  file2 = argv[2];\n\n  /* Compare the contents of the two files.  */\n  {\n    size_t size1;\n    char *contents1;\n    size_t size2;\n    char *contents2;\n\n    contents1 = read_file (file1, &size1);\n    if (contents1 == NULL)\n      {\n        fprintf (stderr, \"error reading file %s: errno = %d\\n\", file1, errno);\n        fflush (stderr);\n        abort ();\n      }\n    contents2 = read_file (file2, &size2);\n    if (contents2 == NULL)\n      {\n        fprintf (stderr, \"error reading file %s: errno = %d\\n\", file2, errno);\n        fflush (stderr);\n        abort ();\n      }\n\n    if (size2 != size1)\n      {\n        fprintf (stderr, \"files %s and %s have different sizes\\n\",\n                 file1, file2);\n        fflush (stderr);\n        abort ();\n      }\n    if (memcmp (contents1, contents2, size1) != 0)\n      {\n        fprintf (stderr, \"files %s and %s have different contents\\n\",\n                 file1, file2);\n        fflush (stderr);\n        abort ();\n      }\n  }\n\n  /* Compare the access permissions of the two files, including ACLs.  */\n  {\n    struct stat statbuf1;\n    struct stat statbuf2;\n\n    if (stat (file1, &statbuf1) < 0)\n      {\n        fprintf (stderr, \"error accessing file %s: errno = %d\\n\", file1, errno);\n        fflush (stderr);\n        abort ();\n      }\n    if (stat (file2, &statbuf2) < 0)\n      {\n        fprintf (stderr, \"error accessing file %s: errno = %d\\n\", file2, errno);\n        fflush (stderr);\n        abort ();\n      }\n    if (statbuf1.st_mode != statbuf2.st_mode)\n      {\n        fprintf (stderr, \"files %s and %s have different access modes: %03o and %03o\\n\",\n                 file1, file2,\n                (unsigned int) statbuf1.st_mode, (unsigned int) statbuf2.st_mode);\n        return 1;\n      }\n  }\n  {\n#if HAVE_ACL_GET_FILE /* Linux, FreeBSD, Mac OS X, IRIX, Tru64 */\n    static const int types[] =\n      {\n        ACL_TYPE_ACCESS\n# if HAVE_ACL_TYPE_EXTENDED /* Mac OS X */\n        , ACL_TYPE_EXTENDED\n# endif\n      };\n    int t;\n\n    for (t = 0; t < sizeof (types) / sizeof (types[0]); t++)\n      {\n        int type = types[t];\n        acl_t acl1;\n        char *text1;\n        int errno1;\n        acl_t acl2;\n        char *text2;\n        int errno2;\n\n        acl1 = acl_get_file (file1, type);\n        if (acl1 == (acl_t)NULL)\n          {\n            text1 = NULL;\n            errno1 = errno;\n          }\n        else\n          {\n            text1 = acl_to_text (acl1, NULL);\n            if (text1 == NULL)\n              errno1 = errno;\n            else\n              errno1 = 0;\n          }\n        acl2 = acl_get_file (file2, type);\n        if (acl2 == (acl_t)NULL)\n          {\n            text2 = NULL;\n            errno2 = errno;\n          }\n        else\n          {\n            text2 = acl_to_text (acl2, NULL);\n            if (text2 == NULL)\n              errno2 = errno;\n            else\n              errno2 = 0;\n          }\n\n        if (acl1 != (acl_t)NULL)\n          {\n            if (acl2 != (acl_t)NULL)\n              {\n                if (text1 != NULL)\n                  {\n                    if (text2 != NULL)\n                      {\n                        if (strcmp (text1, text2) != 0)\n                          {\n                            fprintf (stderr, \"files %s and %s have different ACLs:\\n%s\\n%s\\n\",\n                                     file1, file2, text1, text2);\n                            return 1;\n                          }\n                      }\n                    else\n                      {\n                        fprintf (stderr, \"file %s has a valid ACL, but file %s has an invalid ACL\\n\",\n                                 file1, file2);\n                        return 1;\n                      }\n                  }\n                else\n                  {\n                    if (text2 != NULL)\n                      {\n                        fprintf (stderr, \"file %s has an invalid ACL, but file %s has a valid ACL\\n\",\n                                 file1, file2);\n                        return 1;\n                      }\n                    else\n                      {\n                        if (errno1 != errno2)\n                          {\n                            fprintf (stderr, \"files %s and %s have differently invalid ACLs, errno = %d vs. %d\\n\",\n                                     file1, file2, errno1, errno2);\n                            return 1;\n                          }\n                      }\n                  }\n              }\n            else\n              {\n                fprintf (stderr, \"file %s has an ACL, but file %s has no ACL\\n\",\n                         file1, file2);\n                return 1;\n              }\n          }\n        else\n          {\n            if (acl2 != (acl_t)NULL)\n              {\n                fprintf (stderr, \"file %s has no ACL, but file %s has an ACL\\n\",\n                         file1, file2);\n                return 1;\n              }\n          }\n      }\n#elif HAVE_FACL && defined GETACL /* Solaris, Cygwin, not HP-UX */\n  int count1;\n  int count2;\n\n  count1 = acl (file1, GETACLCNT, 0, NULL);\n  if (count1 < 0 && errno == ENOSYS) /* Can happen on Solaris 10 with ZFS */\n    count1 = 0;\n  count2 = acl (file2, GETACLCNT, 0, NULL);\n  if (count2 < 0 && errno == ENOSYS) /* Can happen on Solaris 10 with ZFS */\n    count2 = 0;\n\n  if (count1 < 0)\n    {\n      fprintf (stderr, \"error accessing the ACLs of file %s\\n\", file1);\n      fflush (stderr);\n      abort ();\n    }\n  if (count2 < 0)\n    {\n      fprintf (stderr, \"error accessing the ACLs of file %s\\n\", file2);\n      fflush (stderr);\n      abort ();\n    }\n  if (count1 != count2)\n    {\n      fprintf (stderr, \"files %s and %s have different number of ACLs: %d and %d\\n\",\n               file1, file2, count1, count2);\n      return 1;\n    }\n  else\n    {\n      aclent_t *entries1 = XNMALLOC (count1, aclent_t);\n      aclent_t *entries2 = XNMALLOC (count2, aclent_t);\n      int i;\n\n      if (count1 > 0 && acl (file1, GETACL, count1, entries1) < count1)\n        {\n          fprintf (stderr, \"error retrieving the ACLs of file %s\\n\", file1);\n          fflush (stderr);\n          abort ();\n        }\n      if (count2 > 0 && acl (file2, GETACL, count2, entries2) < count1)\n        {\n          fprintf (stderr, \"error retrieving the ACLs of file %s\\n\", file2);\n          fflush (stderr);\n          abort ();\n        }\n      for (i = 0; i < count1; i++)\n        {\n          if (entries1[i].a_type != entries2[i].a_type)\n            {\n              fprintf (stderr, \"files %s and %s: different ACL entry #%d: different types %d and %d\\n\",\n                       file1, file2, i, entries1[i].a_type, entries2[i].a_type);\n              return 1;\n            }\n          if (entries1[i].a_id != entries2[i].a_id)\n            {\n              fprintf (stderr, \"files %s and %s: different ACL entry #%d: different ids %d and %d\\n\",\n                       file1, file2, i, (int)entries1[i].a_id, (int)entries2[i].a_id);\n              return 1;\n            }\n          if (entries1[i].a_perm != entries2[i].a_perm)\n            {\n              fprintf (stderr, \"files %s and %s: different ACL entry #%d: different permissions %03o and %03o\\n\",\n                       file1, file2, i, (unsigned int) entries1[i].a_perm, (unsigned int) entries2[i].a_perm);\n              return 1;\n            }\n        }\n    }\n# ifdef ACE_GETACL\n  count1 = acl (file1, ACE_GETACLCNT, 0, NULL);\n  if (count1 < 0 && errno == EINVAL)\n    count1 = 0;\n  count2 = acl (file2, ACE_GETACLCNT, 0, NULL);\n  if (count2 < 0 && errno == EINVAL)\n    count2 = 0;\n  if (count1 < 0)\n    {\n      fprintf (stderr, \"error accessing the ACE-ACLs of file %s\\n\", file1);\n      fflush (stderr);\n      abort ();\n    }\n  if (count2 < 0)\n    {\n      fprintf (stderr, \"error accessing the ACE-ACLs of file %s\\n\", file2);\n      fflush (stderr);\n      abort ();\n    }\n  {\n    ace_t *entries1 = XNMALLOC (count1, ace_t);\n    ace_t *entries2 = XNMALLOC (count2, ace_t);\n    int ret;\n    int i;\n\n    ret = acl (file1, ACE_GETACL, count1, entries1);\n    if (ret < 0 && errno == EINVAL)\n      count1 = 0;\n    else if (ret < count1)\n      {\n        fprintf (stderr, \"error retrieving the ACE-ACLs of file %s\\n\", file1);\n        fflush (stderr);\n        abort ();\n      }\n    ret = acl (file2, ACE_GETACL, count2, entries2);\n    if (ret < 0 && errno == EINVAL)\n      count2 = 0;\n    else if (ret < count2)\n      {\n        fprintf (stderr, \"error retrieving the ACE-ACLs of file %s\\n\", file2);\n        fflush (stderr);\n        abort ();\n      }\n\n    if (count1 != count2)\n      {\n        fprintf (stderr, \"files %s and %s have different number of ACE-ACLs: %d and %d\\n\",\n                 file1, file2, count1, count2);\n        return 1;\n      }\n\n    for (i = 0; i < count1; i++)\n      {\n        if (entries1[i].a_type != entries2[i].a_type)\n          {\n            fprintf (stderr, \"files %s and %s: different ACE-ACL entry #%d: different types %d and %d\\n\",\n                     file1, file2, i, entries1[i].a_type, entries2[i].a_type);\n            return 1;\n          }\n        if (entries1[i].a_who != entries2[i].a_who)\n          {\n            fprintf (stderr, \"files %s and %s: different ACE-ACL entry #%d: different ids %d and %d\\n\",\n                     file1, file2, i, (int)entries1[i].a_who, (int)entries2[i].a_who);\n            return 1;\n          }\n        if (entries1[i].a_access_mask != entries2[i].a_access_mask)\n          {\n            fprintf (stderr, \"files %s and %s: different ACE-ACL entry #%d: different access masks %03o and %03o\\n\",\n                     file1, file2, i, (unsigned int) entries1[i].a_access_mask, (unsigned int) entries2[i].a_access_mask);\n            return 1;\n          }\n        if (entries1[i].a_flags != entries2[i].a_flags)\n          {\n            fprintf (stderr, \"files %s and %s: different ACE-ACL entry #%d: different flags 0x%x and 0x%x\\n\",\n                     file1, file2, i, (unsigned int) entries1[i].a_flags, (unsigned int) entries2[i].a_flags);\n            return 1;\n          }\n      }\n  }\n# endif\n#elif HAVE_GETACL /* HP-UX */\n  int count1;\n  int count2;\n\n  count1 = getacl (file1, 0, NULL);\n  if (count1 < 0\n      && (errno == ENOSYS || errno == EOPNOTSUPP || errno == ENOTSUP))\n    count1 = 0;\n  count2 = getacl (file2, 0, NULL);\n  if (count2 < 0\n      && (errno == ENOSYS || errno == EOPNOTSUPP || errno == ENOTSUP))\n    count2 = 0;\n\n  if (count1 < 0)\n    {\n      fprintf (stderr, \"error accessing the ACLs of file %s\\n\", file1);\n      fflush (stderr);\n      abort ();\n    }\n  if (count2 < 0)\n    {\n      fprintf (stderr, \"error accessing the ACLs of file %s\\n\", file2);\n      fflush (stderr);\n      abort ();\n    }\n  if (count1 != count2)\n    {\n      fprintf (stderr, \"files %s and %s have different number of ACLs: %d and %d\\n\",\n               file1, file2, count1, count2);\n      return 1;\n    }\n  else if (count1 > 0)\n    {\n      struct acl_entry *entries1 = XNMALLOC (count1, struct acl_entry);\n      struct acl_entry *entries2 = XNMALLOC (count2, struct acl_entry);\n      int i;\n\n      if (getacl (file1, count1, entries1) < count1)\n        {\n          fprintf (stderr, \"error retrieving the ACLs of file %s\\n\", file1);\n          fflush (stderr);\n          abort ();\n        }\n      if (getacl (file2, count2, entries2) < count1)\n        {\n          fprintf (stderr, \"error retrieving the ACLs of file %s\\n\", file2);\n          fflush (stderr);\n          abort ();\n        }\n      for (i = 0; i < count1; i++)\n        {\n          if (entries1[i].uid != entries2[i].uid)\n            {\n              fprintf (stderr, \"files %s and %s: different ACL entry #%d: different uids %d and %d\\n\",\n                       file1, file2, i, (int)entries1[i].uid, (int)entries2[i].uid);\n              return 1;\n            }\n          if (entries1[i].gid != entries2[i].gid)\n            {\n              fprintf (stderr, \"files %s and %s: different ACL entry #%d: different gids %d and %d\\n\",\n                       file1, file2, i, (int)entries1[i].gid, (int)entries2[i].gid);\n              return 1;\n            }\n          if (entries1[i].mode != entries2[i].mode)\n            {\n              fprintf (stderr, \"files %s and %s: different ACL entry #%d: different permissions %03o and %03o\\n\",\n                       file1, file2, i, (unsigned int) entries1[i].mode, (unsigned int) entries2[i].mode);\n              return 1;\n            }\n        }\n    }\n\n# if HAVE_ACLV_H /* HP-UX >= 11.11 */\n  {\n    struct acl dummy_entries[NACLVENTRIES];\n\n    count1 = acl ((char *) file1, ACL_CNT, NACLVENTRIES, dummy_entries);\n    if (count1 < 0\n        && (errno == ENOSYS || errno == EOPNOTSUPP || errno == EINVAL))\n      count1 = 0;\n    count2 = acl ((char *) file2, ACL_CNT, NACLVENTRIES, dummy_entries);\n    if (count2 < 0\n        && (errno == ENOSYS || errno == EOPNOTSUPP || errno == EINVAL))\n      count2 = 0;\n  }\n\n  if (count1 < 0)\n    {\n      fprintf (stderr, \"error accessing the ACLs of file %s\\n\", file1);\n      fflush (stderr);\n      abort ();\n    }\n  if (count2 < 0)\n    {\n      fprintf (stderr, \"error accessing the ACLs of file %s\\n\", file2);\n      fflush (stderr);\n      abort ();\n    }\n  if (count1 != count2)\n    {\n      fprintf (stderr, \"files %s and %s have different number of ACLs: %d and %d\\n\",\n               file1, file2, count1, count2);\n      return 1;\n    }\n  else if (count1 > 0)\n    {\n      struct acl *entries1 = XNMALLOC (count1, struct acl);\n      struct acl *entries2 = XNMALLOC (count2, struct acl);\n      int i;\n\n      if (acl ((char *) file1, ACL_GET, count1, entries1) < count1)\n        {\n          fprintf (stderr, \"error retrieving the ACLs of file %s\\n\", file1);\n          fflush (stderr);\n          abort ();\n        }\n      if (acl ((char *) file2, ACL_GET, count2, entries2) < count1)\n        {\n          fprintf (stderr, \"error retrieving the ACLs of file %s\\n\", file2);\n          fflush (stderr);\n          abort ();\n        }\n      for (i = 0; i < count1; i++)\n        {\n          if (entries1[i].a_type != entries2[i].a_type)\n            {\n              fprintf (stderr, \"files %s and %s: different ACL entry #%d: different types %d and %d\\n\",\n                       file1, file2, i, entries1[i].a_type, entries2[i].a_type);\n              return 1;\n            }\n          if (entries1[i].a_id != entries2[i].a_id)\n            {\n              fprintf (stderr, \"files %s and %s: different ACL entry #%d: different ids %d and %d\\n\",\n                       file1, file2, i, (int)entries1[i].a_id, (int)entries2[i].a_id);\n              return 1;\n            }\n          if (entries1[i].a_perm != entries2[i].a_perm)\n            {\n              fprintf (stderr, \"files %s and %s: different ACL entry #%d: different permissions %03o and %03o\\n\",\n                       file1, file2, i, (unsigned int) entries1[i].a_perm, (unsigned int) entries2[i].a_perm);\n              return 1;\n            }\n        }\n    }\n# endif\n#elif HAVE_ACLX_GET /* AIX */\n  acl_type_t type1;\n  char acl1[1000];\n  size_t aclsize1 = sizeof (acl1);\n  mode_t mode1;\n  char text1[1000];\n  size_t textsize1 = sizeof (text1);\n  acl_type_t type2;\n  char acl2[1000];\n  size_t aclsize2 = sizeof (acl2);\n  mode_t mode2;\n  char text2[1000];\n  size_t textsize2 = sizeof (text2);\n\n  /* The docs say that type1 being 0 is equivalent to ACL_ANY, but it is not\n     true, in AIX 5.3.  */\n  type1.u64 = ACL_ANY;\n  if (aclx_get (file1, 0, &type1, acl1, &aclsize1, &mode1) < 0)\n    {\n      if (errno == ENOSYS)\n        text1[0] = '\\0';\n      else\n        {\n          fprintf (stderr, \"error accessing the ACLs of file %s\\n\", file1);\n          fflush (stderr);\n          abort ();\n        }\n    }\n  else\n    if (aclx_printStr (text1, &textsize1, acl1, aclsize1, type1, file1, 0) < 0)\n      {\n        fprintf (stderr, \"cannot convert the ACLs of file %s to text\\n\", file1);\n        fflush (stderr);\n        abort ();\n      }\n\n  /* The docs say that type2 being 0 is equivalent to ACL_ANY, but it is not\n     true, in AIX 5.3.  */\n  type2.u64 = ACL_ANY;\n  if (aclx_get (file2, 0, &type2, acl2, &aclsize2, &mode2) < 0)\n    {\n      if (errno == ENOSYS)\n        text2[0] = '\\0';\n      else\n        {\n          fprintf (stderr, \"error accessing the ACLs of file %s\\n\", file2);\n          fflush (stderr);\n          abort ();\n        }\n    }\n  else\n    if (aclx_printStr (text2, &textsize2, acl2, aclsize2, type2, file2, 0) < 0)\n      {\n        fprintf (stderr, \"cannot convert the ACLs of file %s to text\\n\", file2);\n        fflush (stderr);\n        abort ();\n      }\n\n  if (strcmp (text1, text2) != 0)\n    {\n      fprintf (stderr, \"files %s and %s have different ACLs:\\n%s\\n%s\\n\",\n               file1, file2, text1, text2);\n      return 1;\n    }\n#elif HAVE_STATACL /* older AIX */\n  union { struct acl a; char room[4096]; } acl1;\n  union { struct acl a; char room[4096]; } acl2;\n  unsigned int i;\n\n  if (statacl (file1, STX_NORMAL, &acl1.a, sizeof (acl1)) < 0)\n    {\n      fprintf (stderr, \"error accessing the ACLs of file %s\\n\", file1);\n      fflush (stderr);\n      abort ();\n    }\n  if (statacl (file2, STX_NORMAL, &acl2.a, sizeof (acl2)) < 0)\n    {\n      fprintf (stderr, \"error accessing the ACLs of file %s\\n\", file2);\n      fflush (stderr);\n      abort ();\n    }\n\n  if (acl1.a.acl_len != acl2.a.acl_len)\n    {\n      fprintf (stderr, \"files %s and %s have different ACL lengths: %u and %u\\n\",\n               file1, file2, acl1.a.acl_len, acl2.a.acl_len);\n      return 1;\n    }\n  if (acl1.a.acl_mode != acl2.a.acl_mode)\n    {\n      fprintf (stderr, \"files %s and %s have different ACL modes: %03o and %03o\\n\",\n               file1, file2, acl1.a.acl_mode, acl2.a.acl_mode);\n      return 1;\n    }\n  if (acl1.a.u_access != acl2.a.u_access\n      || acl1.a.g_access != acl2.a.g_access\n      || acl1.a.o_access != acl2.a.o_access)\n    {\n      fprintf (stderr, \"files %s and %s have different ACL access masks: %03o %03o %03o and %03o %03o %03o\\n\",\n               file1, file2,\n               acl1.a.u_access, acl1.a.g_access, acl1.a.o_access,\n               acl2.a.u_access, acl2.a.g_access, acl2.a.o_access);\n      return 1;\n    }\n  if (memcmp (acl1.a.acl_ext, acl2.a.acl_ext, acl1.a.acl_len) != 0)\n    {\n      fprintf (stderr, \"files %s and %s have different ACL entries\\n\",\n               file1, file2);\n      return 1;\n    }\n#elif HAVE_ACLSORT /* NonStop Kernel */\n  int count1;\n  int count2;\n\n  count1 = acl ((char *) file1, ACL_CNT, NACLENTRIES, NULL);\n  count2 = acl ((char *) file2, ACL_CNT, NACLENTRIES, NULL);\n\n  if (count1 < 0)\n    {\n      fprintf (stderr, \"error accessing the ACLs of file %s\\n\", file1);\n      fflush (stderr);\n      abort ();\n    }\n  if (count2 < 0)\n    {\n      fprintf (stderr, \"error accessing the ACLs of file %s\\n\", file2);\n      fflush (stderr);\n      abort ();\n    }\n  if (count1 != count2)\n    {\n      fprintf (stderr, \"files %s and %s have different number of ACLs: %d and %d\\n\",\n               file1, file2, count1, count2);\n      return 1;\n    }\n  else if (count1 > 0)\n    {\n      struct acl *entries1 = XNMALLOC (count1, struct acl);\n      struct acl *entries2 = XNMALLOC (count2, struct acl);\n      int i;\n\n      if (acl ((char *) file1, ACL_GET, count1, entries1) < count1)\n        {\n          fprintf (stderr, \"error retrieving the ACLs of file %s\\n\", file1);\n          fflush (stderr);\n          abort ();\n        }\n      if (acl ((char *) file2, ACL_GET, count2, entries2) < count1)\n        {\n          fprintf (stderr, \"error retrieving the ACLs of file %s\\n\", file2);\n          fflush (stderr);\n          abort ();\n        }\n      for (i = 0; i < count1; i++)\n        {\n          if (entries1[i].a_type != entries2[i].a_type)\n            {\n              fprintf (stderr, \"files %s and %s: different ACL entry #%d: different types %d and %d\\n\",\n                       file1, file2, i, entries1[i].a_type, entries2[i].a_type);\n              return 1;\n            }\n          if (entries1[i].a_id != entries2[i].a_id)\n            {\n              fprintf (stderr, \"files %s and %s: different ACL entry #%d: different ids %d and %d\\n\",\n                       file1, file2, i, (int)entries1[i].a_id, (int)entries2[i].a_id);\n              return 1;\n            }\n          if (entries1[i].a_perm != entries2[i].a_perm)\n            {\n              fprintf (stderr, \"files %s and %s: different ACL entry #%d: different permissions %03o and %03o\\n\",\n                       file1, file2, i, (unsigned int) entries1[i].a_perm, (unsigned int) entries2[i].a_perm);\n              return 1;\n            }\n        }\n    }\n#endif\n  }\n\n  return 0;\n}",
      "lines": 656,
      "depth": 23,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-select-fd.c": {
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  if (argc == 4)\n    {\n      char mode = argv[1][0];\n\n      if (mode == 'r' || mode == 'w')\n        {\n          int fd = atoi (argv[2]);\n\n          if (fd >= 0)\n            {\n              const char *result_file_name = argv[3];\n              FILE *result_file = fopen (result_file_name, \"wb\");\n\n              if (result_file != NULL)\n                {\n                  fd_set fds;\n                  struct timeval timeout;\n                  int ret;\n\n                  FD_ZERO (&fds);\n                  FD_SET (fd, &fds);\n                  timeout.tv_sec = 0;\n                  timeout.tv_usec = 10000;\n                  ret = (mode == 'r'\n                         ? select (fd + 1, &fds, NULL, NULL, &timeout)\n                         : select (fd + 1, NULL, &fds, NULL, &timeout));\n                  if (ret < 0)\n                    {\n                      perror (\"select failed\");\n                      exit (1);\n                    }\n                  if ((ret == 0) != ! FD_ISSET (fd, &fds))\n                    {\n                      fprintf (stderr, \"incorrect return value\\n\");\n                      exit (1);\n                    }\n                  fprintf (result_file, \"%d\\n\", ret);\n                  exit (0);\n                }\n            }\n        }\n    }\n  fprintf (stderr, \"Usage: test-select-fd mode fd result-file-name\\n\");\n  exit (1);\n}",
      "lines": 48,
      "depth": 18,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-select-stdin.c": {
    "main": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        82,
        1
      ],
      "content": "int\nmain (void)\n{\n  printf (\"Applying select() from standard input. Press Ctrl-C to abort.\\n\");\n  for (;;)\n    {\n      struct timeval before;\n      struct timeval after;\n      unsigned long spent_usec;\n      fd_set readfds;\n      struct timeval timeout;\n      int ret;\n\n      gettimeofday (&before, NULL);\n\n      FD_ZERO (&readfds);\n      FD_SET (0, &readfds);\n      timeout.tv_sec = 0;\n      timeout.tv_usec = 500000;\n      ret = select (1, &readfds, NULL, NULL, &timeout);\n\n      gettimeofday (&after, NULL);\n      spent_usec = (after.tv_sec - before.tv_sec) * 1000000\n                   + after.tv_usec - before.tv_usec;\n\n      if (ret < 0)\n        {\n          perror (\"select failed\");\n          exit (1);\n        }\n      if ((ret == 0) != ! FD_ISSET (0, &readfds))\n        {\n          fprintf (stderr, \"incorrect return value\\n\");\n          exit (1);\n        }\n      if (ret == 0)\n        {\n          if (spent_usec < 250000)\n            {\n              fprintf (stderr, \"returned too early\\n\");\n              exit (1);\n            }\n          /* Timeout */\n          printf (\".\");\n          ASSERT (fflush (stdout) == 0);\n        }\n      else\n        {\n          char c;\n\n          printf (\"Input available! Trying to read 1 byte...\\n\");\n          ASSERT (read (0, &c, 1) == 1);\n        }\n    }\n}",
      "lines": 55,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-select.c": {
    "main": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        33,
        1
      ],
      "content": "int\nmain (void)\n{\n  return test_function (select);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-select.h": {
    "failed": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "static void\nfailed (const char *reason)\n{\n  if (++failures > 1)\n    printf (\"  \");\n  printf (\"failed (%s)\\n\", reason);\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        73,
        1
      ],
      "content": "static int\ntest (void (*fn) (select_fn), select_fn my_select, const char *msg)\n{\n  failures = 0;\n  printf (\"%s... \", msg);\n  fflush (stdout);\n  fn (my_select);\n\n  if (!failures)\n    printf (\"passed\\n\");\n\n  return failures;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "open_server_socket": {
      "start_point": [
        78,
        0
      ],
      "end_point": [
        106,
        1
      ],
      "content": "static int\nopen_server_socket (void)\n{\n  int s, x;\n  struct sockaddr_in ia;\n\n  s = socket (AF_INET, SOCK_STREAM, 0);\n\n  x = 1;\n  setsockopt (s, SOL_SOCKET, SO_REUSEPORT, &x, sizeof (x));\n\n  memset (&ia, 0, sizeof (ia));\n  ia.sin_family = AF_INET;\n  inet_pton (AF_INET, \"127.0.0.1\", &ia.sin_addr);\n  ia.sin_port = htons (TEST_PORT);\n  if (bind (s, (struct sockaddr *) &ia, sizeof (ia)) < 0)\n    {\n      perror (\"bind\");\n      exit (77);\n    }\n\n  if (listen (s, 1) < 0)\n    {\n      perror (\"listen\");\n      exit (77);\n    }\n\n  return s;\n}",
      "lines": 29,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "connect_to_socket": {
      "start_point": [
        108,
        0
      ],
      "end_point": [
        143,
        1
      ],
      "content": "static int\nconnect_to_socket (bool blocking)\n{\n  int s;\n  struct sockaddr_in ia;\n\n  s = socket (AF_INET, SOCK_STREAM, 0);\n\n  memset (&ia, 0, sizeof (ia));\n  ia.sin_family = AF_INET;\n  inet_pton (AF_INET, \"127.0.0.1\", &ia.sin_addr);\n  ia.sin_port = htons (TEST_PORT);\n\n  if (!blocking)\n    {\n#ifdef WINDOWS_NATIVE\n      unsigned long iMode = 1;\n      ioctl (s, FIONBIO, (char *) &iMode);\n\n#elif defined F_GETFL\n      int oldflags = fcntl (s, F_GETFL, NULL);\n\n      if (!(oldflags & O_NONBLOCK))\n        fcntl (s, F_SETFL, oldflags | O_NONBLOCK);\n#endif\n    }\n\n  if (connect (s, (struct sockaddr *) &ia, sizeof (ia)) < 0\n      && (blocking || errno != EINPROGRESS))\n    {\n      perror (\"connect\");\n      exit (77);\n    }\n\n  return s;\n}",
      "lines": 36,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "do_select": {
      "start_point": [
        158,
        0
      ],
      "end_point": [
        190,
        1
      ],
      "content": "static int\ndo_select (int fd, int ev, struct timeval *timeout, select_fn my_select)\n{\n  fd_set rfds, wfds, xfds;\n  int r, rev;\n\n  FD_ZERO (&rfds);\n  FD_ZERO (&wfds);\n  FD_ZERO (&xfds);\n  if (ev & SEL_IN)\n    FD_SET (fd, &rfds);\n  if (ev & SEL_OUT)\n    FD_SET (fd, &wfds);\n  if (ev & SEL_EXC)\n    FD_SET (fd, &xfds);\n  r = my_select (fd + 1, &rfds, &wfds, &xfds, timeout);\n  if (r < 0)\n    return r;\n\n  rev = 0;\n  if (FD_ISSET (fd, &rfds))\n    rev |= SEL_IN;\n  if (FD_ISSET (fd, &wfds))\n    rev |= SEL_OUT;\n  if (FD_ISSET (fd, &xfds))\n    rev |= SEL_EXC;\n  if (rev && r == 0)\n    failed (\"select returned 0\");\n  if (rev & ~ev)\n    failed (\"select returned unrequested events\");\n\n  return rev;\n}",
      "lines": 33,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "do_select_nowait": {
      "start_point": [
        192,
        0
      ],
      "end_point": [
        199,
        1
      ],
      "content": "static int\ndo_select_nowait (int fd, int ev, select_fn my_select)\n{\n  struct timeval tv0;\n  tv0.tv_sec = 0;\n  tv0.tv_usec = 0;\n  return do_select (fd, ev, &tv0, my_select);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "do_select_wait": {
      "start_point": [
        201,
        0
      ],
      "end_point": [
        205,
        1
      ],
      "content": "static int\ndo_select_wait (int fd, int ev, select_fn my_select)\n{\n  return do_select (fd, ev, NULL, my_select);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "test_tty": {
      "start_point": [
        211,
        0
      ],
      "end_point": [
        225,
        1
      ],
      "content": "static void\ntest_tty (select_fn my_select)\n{\n  if (do_select_nowait (0, SEL_IN, my_select) != 0)\n    failed (\"can read\");\n  if (do_select_nowait (0, SEL_OUT, my_select) == 0)\n    failed (\"cannot write\");\n\n  if (do_select_wait (0, SEL_IN, my_select) == 0)\n    failed (\"return with infinite timeout\");\n\n  getchar ();\n  if (do_select_nowait (0, SEL_IN, my_select) != 0)\n    failed (\"can read after getc\");\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "do_select_bad_nfd_nowait": {
      "start_point": [
        229,
        0
      ],
      "end_point": [
        237,
        1
      ],
      "content": "static int\ndo_select_bad_nfd_nowait (int nfd, select_fn my_select)\n{\n  struct timeval tv0;\n  tv0.tv_sec = 0;\n  tv0.tv_usec = 0;\n  errno = 0;\n  return my_select (nfd, NULL, NULL, NULL, &tv0);\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "test_bad_nfd": {
      "start_point": [
        239,
        0
      ],
      "end_point": [
        250,
        1
      ],
      "content": "static void\ntest_bad_nfd (select_fn my_select)\n{\n  if (do_select_bad_nfd_nowait (-1, my_select) != -1 || errno != EINVAL)\n    failed (\"invalid errno after negative nfds\");\n  /* Can't test FD_SETSIZE + 1 for EINVAL, since some systems allow\n     dynamically larger set size by redefining FD_SETSIZE anywhere up\n     to the actual maximum fd.  */\n  /* if (do_select_bad_nfd_nowait (FD_SETSIZE + 1, my_select) != -1 */\n  /*     || errno != EINVAL) */\n  /*   failed (\"invalid errno after bogus nfds\"); */\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "do_select_bad_fd": {
      "start_point": [
        254,
        0
      ],
      "end_point": [
        273,
        1
      ],
      "content": "static int\ndo_select_bad_fd (int fd, int ev, struct timeval *timeout, select_fn my_select)\n{\n  fd_set rfds, wfds, xfds;\n\n  FD_ZERO (&rfds);\n  FD_ZERO (&wfds);\n  FD_ZERO (&xfds);\n  if (ev & SEL_IN)\n    FD_SET (fd, &rfds);\n  if (ev & SEL_OUT)\n    FD_SET (fd, &wfds);\n  if (ev & SEL_EXC)\n    FD_SET (fd, &xfds);\n  errno = 0;\n  return my_select (fd + 1, &rfds, &wfds, &xfds, timeout);\n  /* In this case, when fd is invalid, on some platforms, the bit for fd\n     is left alone in the fd_set, whereas on other platforms it is cleared.\n     So, don't check the bit for fd here.  */\n}",
      "lines": 20,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "do_select_bad_fd_nowait": {
      "start_point": [
        275,
        0
      ],
      "end_point": [
        282,
        1
      ],
      "content": "static int\ndo_select_bad_fd_nowait (int fd, int ev, select_fn my_select)\n{\n  struct timeval tv0;\n  tv0.tv_sec = 0;\n  tv0.tv_usec = 0;\n  return do_select_bad_fd (fd, ev, &tv0, my_select);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "test_bad_fd": {
      "start_point": [
        284,
        0
      ],
      "end_point": [
        308,
        1
      ],
      "content": "static void\ntest_bad_fd (select_fn my_select)\n{\n  /* This tests fails on OSF/1 and native Windows, even with fd = 16.  */\n#if !(defined __osf__ || defined WINDOWS_NATIVE)\n  int fd;\n\n  /* On Linux, Mac OS X, *BSD, values of fd like 99 or 399 are discarded\n     by the kernel early and therefore do *not* lead to EBADF, as required\n     by POSIX.  */\n# if defined __linux__ || (defined __APPLE__ && defined __MACH__) || (defined __FreeBSD__ || defined __DragonFly__) || defined __OpenBSD__ || defined __NetBSD__\n  fd = 14;\n# else\n  fd = 99;\n# endif\n  close (fd);\n\n  if (do_select_bad_fd_nowait (fd, SEL_IN, my_select) == 0 || errno != EBADF)\n    failed (\"invalid fd among rfds\");\n  if (do_select_bad_fd_nowait (fd, SEL_OUT, my_select) == 0 || errno != EBADF)\n    failed (\"invalid fd among wfds\");\n  if (do_select_bad_fd_nowait (fd, SEL_EXC, my_select) == 0 || errno != EBADF)\n    failed (\"invalid fd among xfds\");\n#endif\n}",
      "lines": 25,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_connect_first": {
      "start_point": [
        313,
        0
      ],
      "end_point": [
        337,
        1
      ],
      "content": "static void\ntest_connect_first (select_fn my_select)\n{\n  int s = open_server_socket ();\n  struct sockaddr_in ia;\n  socklen_t addrlen;\n\n  int c1, c2;\n\n  if (do_select_nowait (s, SEL_IN | SEL_EXC, my_select) != 0)\n    failed (\"can read, socket not connected\");\n\n  c1 = connect_to_socket (false);\n\n  if (do_select_wait (s, SEL_IN | SEL_EXC, my_select) != SEL_IN)\n    failed (\"expecting readability on passive socket\");\n  if (do_select_nowait (s, SEL_IN | SEL_EXC, my_select) != SEL_IN)\n    failed (\"expecting readability on passive socket\");\n\n  addrlen = sizeof (ia);\n  c2 = accept (s, (struct sockaddr *) &ia, &addrlen);\n  ASSERT (close (s) == 0);\n  ASSERT (close (c1) == 0);\n  ASSERT (close (c2) == 0);\n}",
      "lines": 25,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_accept_first": {
      "start_point": [
        342,
        0
      ],
      "end_point": [
        382,
        1
      ],
      "content": "static void\ntest_accept_first (select_fn my_select)\n{\n#ifndef WINDOWS_NATIVE\n  int s = open_server_socket ();\n  struct sockaddr_in ia;\n  socklen_t addrlen;\n  char buf[3];\n  int c, pid;\n\n  pid = fork ();\n  if (pid < 0)\n    return;\n\n  if (pid == 0)\n    {\n      addrlen = sizeof (ia);\n      c = accept (s, (struct sockaddr *) &ia, &addrlen);\n      ASSERT (close (s) == 0);\n      ASSERT (write (c, \"foo\", 3) == 3);\n      ASSERT (read (c, buf, 3) == 3);\n      shutdown (c, SHUT_RD);\n      ASSERT (close (c) == 0);\n      exit (0);\n    }\n  else\n    {\n      ASSERT (close (s) == 0);\n      c = connect_to_socket (true);\n      if (do_select_nowait (c, SEL_OUT, my_select) != SEL_OUT)\n        failed (\"cannot write after blocking connect\");\n      ASSERT (write (c, \"foo\", 3) == 3);\n      wait (&pid);\n      if (do_select_wait (c, SEL_IN, my_select) != SEL_IN)\n        failed (\"cannot read data left in the socket by closed process\");\n      ASSERT (read (c, buf, 3) == 3);\n      ASSERT (write (c, \"foo\", 3) == 3);\n      (void) close (c); /* may fail with errno = ECONNRESET */\n    }\n#endif\n}",
      "lines": 41,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_pair": {
      "start_point": [
        387,
        0
      ],
      "end_point": [
        403,
        1
      ],
      "content": "static void\ntest_pair (int rd, int wd, select_fn my_select)\n{\n  char buf[3];\n  if (do_select_wait (wd, SEL_IN | SEL_OUT | SEL_EXC, my_select) != SEL_OUT)\n    failed (\"expecting writability before writing\");\n  if (do_select_nowait (wd, SEL_IN | SEL_OUT | SEL_EXC, my_select) != SEL_OUT)\n    failed (\"expecting writability before writing\");\n\n  ASSERT (write (wd, \"foo\", 3) == 3);\n  if (do_select_wait (rd, SEL_IN, my_select) != SEL_IN)\n    failed (\"expecting readability after writing\");\n  if (do_select_nowait (rd, SEL_IN, my_select) != SEL_IN)\n    failed (\"expecting readability after writing\");\n\n  ASSERT (read (rd, buf, 3) == 3);\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_socket_pair": {
      "start_point": [
        408,
        0
      ],
      "end_point": [
        424,
        1
      ],
      "content": "static void\ntest_socket_pair (select_fn my_select)\n{\n  struct sockaddr_in ia;\n\n  socklen_t addrlen = sizeof (ia);\n  int s = open_server_socket ();\n  int c1 = connect_to_socket (false);\n  int c2 = accept (s, (struct sockaddr *) &ia, &addrlen);\n\n  ASSERT (close (s) == 0);\n\n  test_pair (c1, c2, my_select);\n  ASSERT (close (c1) == 0);\n  ASSERT (write (c2, \"foo\", 3) == 3);\n  (void) close (c2); /* may fail with errno = ECONNRESET */\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_pipe": {
      "start_point": [
        429,
        0
      ],
      "end_point": [
        438,
        1
      ],
      "content": "static void\ntest_pipe (select_fn my_select)\n{\n  int fd[2];\n\n  ASSERT (pipe (fd) == 0);\n  test_pair (fd[0], fd[1], my_select);\n  ASSERT (close (fd[0]) == 0);\n  ASSERT (close (fd[1]) == 0);\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_function": {
      "start_point": [
        443,
        0
      ],
      "end_point": [
        461,
        1
      ],
      "content": "static int\ntest_function (select_fn my_select)\n{\n  int result = 0;\n\n#ifdef INTERACTIVE\n  printf (\"Please press Enter\\n\");\n  test (test_tty, \"TTY\", my_select);\n#endif\n\n  result += test (test_bad_nfd, my_select, \"Invalid nfd test\");\n  result += test (test_bad_fd, my_select, \"Invalid fd test\");\n  result += test (test_connect_first, my_select, \"Unconnected socket test\");\n  result += test (test_socket_pair, my_select, \"Connected sockets test\");\n  result += test (test_accept_first, my_select, \"General socket test with fork\");\n  result += test (test_pipe, my_select, \"Pipe test\");\n\n  return result;\n}",
      "lines": 19,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-set-mode-acl.c": {
    "main": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  const char *file;\n  int mode;\n\n  ASSERT (argc == 3);\n\n  file = argv[1];\n  mode = strtol (argv[2], NULL, 8);\n\n  set_acl (file, -1, mode);\n\n  return 0;\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-setenv.c": {
    "main": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "int\nmain (void)\n{\n  /* Test overwriting.  */\n  ASSERT (setenv (\"a\", \"==\", -1) == 0);\n  ASSERT (setenv (\"a\", \"2\", 0) == 0);\n  ASSERT (strcmp (getenv (\"a\"), \"==\") == 0);\n\n  /* Required to fail with EINVAL.  */\n  errno = 0;\n  ASSERT (setenv (\"\", \"\", 1) == -1);\n  ASSERT (errno == EINVAL);\n  errno = 0;\n  ASSERT (setenv (\"a=b\", \"\", 0) == -1);\n  ASSERT (errno == EINVAL);\n#if 0\n  /* glibc and gnulib's implementation guarantee this, but POSIX no\n     longer requires it: http://austingroupbugs.net/view.php?id=185  */\n  errno = 0;\n  ASSERT (setenv (NULL, \"\", 0) == -1);\n  ASSERT (errno == EINVAL);\n#endif\n\n  return 0;\n}",
      "lines": 25,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-setlocale1.c": {
    "main": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  char *name1;\n  char *name2;\n\n  /* Try to set the locale by implicitly looking at the LC_ALL environment\n     variable.\n     configure should already have checked that the locale is supported.  */\n  if (setlocale (LC_ALL, \"\") == NULL)\n    return 1;\n\n  name1 = strdup (setlocale (LC_ALL, NULL));\n\n  /* Reset the locale.  */\n  if (setlocale (LC_ALL, \"C\") == NULL)\n    return 1;\n\n  /* Try to set the locale by explicitly looking at the LC_ALL environment\n     variable.\n     configure should already have checked that the locale is supported.  */\n  if (setlocale (LC_ALL, getenv (\"LC_ALL\")) == NULL)\n    return 1;\n\n  name2 = strdup (setlocale (LC_ALL, NULL));\n\n  /* Test that the two results are the same.  */\n  ASSERT (strcmp (name1, name2) == 0);\n  free (name1);\n  free (name2);\n\n  return 0;\n}",
      "lines": 33,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-setlocale2.c": {
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "int\nmain ()\n{\n  /* Try to set the locale by implicitly looking at the LC_ALL environment\n     variable.  */\n  if (setlocale (LC_ALL, \"\") != NULL)\n    /* It was successful.  Check whether LC_CTYPE is non-trivial.  */\n    if (strcmp (setlocale (LC_CTYPE, NULL), \"C\") == 0)\n      {\n        fprintf (stderr, \"setlocale did not fail for implicit %s\\n\",\n                 getenv (\"LC_ALL\"));\n        return 1;\n      }\n\n  /* Reset the locale.  */\n  if (setlocale (LC_ALL, \"C\") == NULL)\n    return 1;\n\n  /* Try to set the locale by explicitly looking at the LC_ALL environment\n     variable.  */\n  if (setlocale (LC_ALL, getenv (\"LC_ALL\")) != NULL)\n    /* It was successful.  Check whether LC_CTYPE is non-trivial.  */\n    if (strcmp (setlocale (LC_CTYPE, NULL), \"C\") == 0)\n      {\n        fprintf (stderr, \"setlocale did not fail for explicit %s\\n\",\n                 getenv (\"LC_ALL\"));\n        return 1;\n      }\n\n  return 0;\n}",
      "lines": 31,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-setsockopt.c": {
    "main": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "int\nmain (void)\n{\n  (void) gl_sockets_startup (SOCKETS_1_1);\n\n  /* Test behaviour for invalid file descriptors.  */\n  {\n    int value = 1;\n\n    errno = 0;\n    ASSERT (setsockopt (-1, SOL_SOCKET, SO_REUSEADDR, &value, sizeof (value))\n            == -1);\n    ASSERT (errno == EBADF);\n  }\n  {\n    int value = 1;\n\n    close (99);\n    errno = 0;\n    ASSERT (setsockopt (99, SOL_SOCKET, SO_REUSEADDR, &value, sizeof (value))\n            == -1);\n    ASSERT (errno == EBADF);\n  }\n\n  return 0;\n}",
      "lines": 26,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-sigaction.c": {
    "handler": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "static void\nhandler (int sig)\n{\n  static int entry_count;\n  struct sigaction sa;\n  ASSERT (sig == SIGABRT);\n  ASSERT (sigaction (SIGABRT, NULL, &sa) == 0);\n  ASSERT ((sa.sa_flags & SA_SIGINFO) == 0);\n  switch (entry_count++)\n    {\n    case 0:\n      ASSERT ((sa.sa_flags & SA_RESETHAND) == 0);\n      ASSERT (sa.sa_handler == handler);\n      break;\n    case 1:\n      /* This assertion fails on glibc-2.3.6 systems with LinuxThreads,\n         when this program is linked with -lpthread, due to the sigaction()\n         override in libpthread.so.  */\n#if !(defined __GLIBC__ || defined __UCLIBC__)\n      ASSERT (sa.sa_handler == SIG_DFL);\n#endif\n      break;\n    default:\n      ASSERT (0);\n    }\n}",
      "lines": 26,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        88,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "int\nmain (void)\n{\n  struct sigaction sa;\n  struct sigaction old_sa;\n  sa.sa_handler = handler;\n\n  sa.sa_flags = 0;\n  ASSERT (sigemptyset (&sa.sa_mask) == 0);\n  ASSERT (sigaction (SIGABRT, &sa, NULL) == 0);\n  ASSERT (raise (SIGABRT) == 0);\n\n  sa.sa_flags = SA_RESETHAND | SA_NODEFER;\n  ASSERT (sigaction (SIGABRT, &sa, &old_sa) == 0);\n  ASSERT ((old_sa.sa_flags & MASK_SA_FLAGS) == 0);\n  ASSERT (old_sa.sa_handler == handler);\n  ASSERT (raise (SIGABRT) == 0);\n\n  sa.sa_handler = SIG_DFL;\n  ASSERT (sigaction (SIGABRT, &sa, &old_sa) == 0);\n  ASSERT ((old_sa.sa_flags & SA_SIGINFO) == 0);\n#if !(defined __GLIBC__ || defined __UCLIBC__) /* see above */\n  ASSERT (old_sa.sa_handler == SIG_DFL);\n#endif\n\n  sa.sa_handler = SIG_IGN;\n  ASSERT (sigaction (SIGABRT, &sa, NULL) == 0);\n  ASSERT (raise (SIGABRT) == 0);\n  ASSERT (sigaction (SIGABRT, NULL, &old_sa) == 0);\n  ASSERT (old_sa.sa_handler == SIG_IGN);\n  ASSERT (raise (SIGABRT) == 0);\n\n  return 0;\n}",
      "lines": 34,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-signal-h.c": {
    "main": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        128,
        1
      ],
      "content": "int\nmain (void)\n{\n  switch (0)\n    {\n      /* The following are guaranteed by C.  */\n    case 0:\n    case SIGABRT:\n    case SIGFPE:\n    case SIGILL:\n    case SIGINT:\n    case SIGSEGV:\n    case SIGTERM:\n      /* The following is guaranteed by gnulib.  */\n#if GNULIB_SIGPIPE || defined SIGPIPE\n    case SIGPIPE:\n#endif\n      /* Ensure no conflict with other standardized names.  */\n#ifdef SIGALRM\n    case SIGALRM:\n#endif\n      /* On Haiku, SIGBUS is mistakenly equal to SIGSEGV.  */\n#if defined SIGBUS && SIGBUS != SIGSEGV\n    case SIGBUS:\n#endif\n#ifdef SIGCHLD\n    case SIGCHLD:\n#endif\n#ifdef SIGCONT\n    case SIGCONT:\n#endif\n#ifdef SIGHUP\n    case SIGHUP:\n#endif\n#ifdef SIGKILL\n    case SIGKILL:\n#endif\n#ifdef SIGQUIT\n    case SIGQUIT:\n#endif\n#ifdef SIGSTOP\n    case SIGSTOP:\n#endif\n#ifdef SIGTSTP\n    case SIGTSTP:\n#endif\n#ifdef SIGTTIN\n    case SIGTTIN:\n#endif\n#ifdef SIGTTOU\n    case SIGTTOU:\n#endif\n#ifdef SIGUSR1\n    case SIGUSR1:\n#endif\n#ifdef SIGUSR2\n    case SIGUSR2:\n#endif\n#ifdef SIGSYS\n    case SIGSYS:\n#endif\n#ifdef SIGTRAP\n    case SIGTRAP:\n#endif\n#ifdef SIGURG\n    case SIGURG:\n#endif\n#ifdef SIGVTALRM\n    case SIGVTALRM:\n#endif\n#ifdef SIGXCPU\n    case SIGXCPU:\n#endif\n#ifdef SIGXFSZ\n    case SIGXFSZ:\n#endif\n      /* SIGRTMIN and SIGRTMAX need not be compile-time constants.  */\n#if 0\n# ifdef SIGRTMIN\n    case SIGRTMIN:\n# endif\n# ifdef SIGRTMAX\n    case SIGRTMAX:\n# endif\n#endif\n      ;\n    }\n  return s.a + s.b + s.c + s.e;\n}",
      "lines": 89,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-sigprocmask.c": {
    "sigint_handler": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "static void\nsigint_handler (int sig)\n{\n  sigint_occurred++;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": [
      {
        "start_point": [
          42,
          0
        ],
        "end_point": [
          87,
          1
        ],
        "content": "int\nmain (int argc, char *argv[])\n{\n  sigset_t set;\n  pid_t pid = getpid ();\n  char command[80];\n\n  if (sizeof (int) < sizeof pid && 0x7fffffff < pid)\n    {\n      fputs (\"Skipping test: pid too large\\n\", stderr);\n      return 77;\n    }\n\n  signal (SIGINT, sigint_handler);\n\n  sigemptyset (&set);\n  sigaddset (&set, SIGINT);\n\n  /* Check error handling.  */\n  ASSERT (sigprocmask (1729, &set, NULL) == -1);\n  ASSERT (errno == EINVAL);\n\n  /* Block SIGINT.  */\n  ASSERT (sigprocmask (SIG_BLOCK, &set, NULL) == 0);\n\n  /* Request a SIGINT signal from outside.  */\n  sprintf (command, \"sh -c 'sleep 1; kill -%d %d' &\", SIGINT, (int) pid);\n  ASSERT (system (command) == 0);\n\n  /* Wait.  */\n  sleep (2);\n\n  /* The signal should not have arrived yet, because it is blocked.  */\n  ASSERT (sigint_occurred == 0);\n\n  /* Unblock SIGINT.  */\n  ASSERT (sigprocmask (SIG_UNBLOCK, &set, NULL) == 0);\n\n  /* The signal should have arrived now, because POSIX says\n       \"If there are any pending unblocked signals after the call to\n        sigprocmask(), at least one of those signals shall be delivered\n        before the call to sigprocmask() returns.\"  */\n  ASSERT (sigint_occurred == 1);\n\n  return 0;\n}",
        "lines": 46,
        "depth": 10,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          94,
          0
        ],
        "end_point": [
          99,
          1
        ],
        "content": "int\nmain ()\n{\n  fputs (\"Skipping test: native Windows platform\\n\", stderr);\n  return 77;\n}",
        "lines": 6,
        "depth": 7,
        "decorators": [
          "int"
        ]
      }
    ]
  },
  "sed/sed-4.5/gnulib-tests/test-sleep.c": {
    "handle_alarm": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        35,
        1
      ],
      "content": "static void\nhandle_alarm (int sig)\n{\n  if (sig != SIGALRM)\n    _exit (1);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "int\nmain (void)\n{\n  ASSERT (sleep (1) <= 1);\n\n  ASSERT (sleep (0) == 0);\n\n#if HAVE_DECL_ALARM\n  {\n    const unsigned int pentecost = 50 * 24 * 60 * 60; /* 50 days.  */\n    unsigned int remaining;\n    signal (SIGALRM, handle_alarm);\n    alarm (1);\n    remaining = sleep (pentecost);\n    ASSERT (pentecost - 10 < remaining && remaining <= pentecost);\n  }\n#endif\n\n  return 0;\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-sockets.c": {
    "main": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "int\nmain (void)\n{\n  int err;\n\n  err = gl_sockets_startup (SOCKETS_1_1);\n  if (err != 0)\n    {\n      printf (\"wsastartup failed %d\\n\", err);\n      return 1;\n    }\n\n  err = gl_sockets_cleanup ();\n  if (err != 0)\n    {\n      printf (\"wsacleanup failed %d\\n\", err);\n      return 1;\n    }\n\n  (void) gl_fd_to_handle (0);\n\n  return 0;\n}",
      "lines": 23,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-stat-time.c": {
    "initialize_filenames": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "static void\ninitialize_filenames (void)\n{\n  long t = (long) time (NULL);\n  sprintf (filename_stamp1,   \"t-stt-%ld-stamp1\", t);\n  sprintf (filename_testfile, \"t-stt-%ld-testfile\", t);\n  sprintf (filename_stamp2,   \"t-stt-%ld-stamp2\", t);\n  sprintf (filename_stamp3,   \"t-stt-%ld-stamp3\", t);\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "force_unlink": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "static int\nforce_unlink (const char *filename)\n{\n  /* This chmod is necessary on mingw, where unlink() of a read-only file\n     fails with EPERM.  */\n  chmod (filename, 0600);\n  return unlink (filename);\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cleanup": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "static void\ncleanup (int sig)\n{\n  /* Remove temporary files.  */\n  force_unlink (filename_stamp1);\n  force_unlink (filename_testfile);\n  force_unlink (filename_stamp2);\n  force_unlink (filename_stamp3);\n\n  if (sig != 0)\n    _exit (1);\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "open_file": {
      "start_point": [
        79,
        0
      ],
      "end_point": [
        92,
        1
      ],
      "content": "static int\nopen_file (const char *filename, int flags)\n{\n  int fd = open (filename, flags | O_WRONLY, 0500);\n  if (fd >= 0)\n    {\n      close (fd);\n      return 1;\n    }\n  else\n    {\n      return 0;\n    }\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "create_file": {
      "start_point": [
        94,
        0
      ],
      "end_point": [
        98,
        1
      ],
      "content": "static void\ncreate_file (const char *filename)\n{\n  ASSERT (open_file (filename, O_CREAT | O_EXCL));\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "do_stat": {
      "start_point": [
        100,
        0
      ],
      "end_point": [
        104,
        1
      ],
      "content": "static void\ndo_stat (const char *filename, struct stat *p)\n{\n  ASSERT (stat (filename, p) == 0);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "prepare_test": {
      "start_point": [
        106,
        0
      ],
      "end_point": [
        131,
        1
      ],
      "content": "static void\nprepare_test (struct stat *statinfo, struct timespec *modtimes)\n{\n  int i;\n\n  create_file (filename_stamp1);\n  nap ();\n  create_file (filename_testfile);\n  nap ();\n  create_file (filename_stamp2);\n  nap ();\n  ASSERT (chmod (filename_testfile, 0400) == 0);\n  nap ();\n  create_file (filename_stamp3);\n\n  do_stat (filename_stamp1,   &statinfo[0]);\n  do_stat (filename_testfile, &statinfo[1]);\n  do_stat (filename_stamp2,   &statinfo[2]);\n  do_stat (filename_stamp3,   &statinfo[3]);\n\n  /* Now use our access functions. */\n  for (i = 0; i < NFILES; ++i)\n    {\n      modtimes[i] = get_stat_mtime (&statinfo[i]);\n    }\n}",
      "lines": 26,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_mtime": {
      "start_point": [
        133,
        0
      ],
      "end_point": [
        167,
        1
      ],
      "content": "static void\ntest_mtime (const struct stat *statinfo, struct timespec *modtimes)\n{\n  int i;\n\n  /* Use the struct stat fields directly. */\n  /* mtime(stamp1) < mtime(stamp2) */\n  ASSERT (statinfo[0].st_mtime < statinfo[2].st_mtime\n          || (statinfo[0].st_mtime == statinfo[2].st_mtime\n              && (get_stat_mtime_ns (&statinfo[0])\n                  < get_stat_mtime_ns (&statinfo[2]))));\n  /* mtime(stamp2) < mtime(stamp3) */\n  ASSERT (statinfo[2].st_mtime < statinfo[3].st_mtime\n          || (statinfo[2].st_mtime == statinfo[3].st_mtime\n              && (get_stat_mtime_ns (&statinfo[2])\n                  < get_stat_mtime_ns (&statinfo[3]))));\n\n  /* Now check the result of the access functions. */\n  /* mtime(stamp1) < mtime(stamp2) */\n  ASSERT (modtimes[0].tv_sec < modtimes[2].tv_sec\n          || (modtimes[0].tv_sec == modtimes[2].tv_sec\n              && modtimes[0].tv_nsec < modtimes[2].tv_nsec));\n  /* mtime(stamp2) < mtime(stamp3) */\n  ASSERT (modtimes[2].tv_sec < modtimes[3].tv_sec\n          || (modtimes[2].tv_sec == modtimes[3].tv_sec\n              && modtimes[2].tv_nsec < modtimes[3].tv_nsec));\n\n  /* verify equivalence */\n  for (i = 0; i < NFILES; ++i)\n    {\n      struct timespec ts;\n      ts = get_stat_mtime (&statinfo[i]);\n      ASSERT (ts.tv_sec == statinfo[i].st_mtime);\n    }\n}",
      "lines": 35,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_ctime": {
      "start_point": [
        176,
        0
      ],
      "end_point": [
        189,
        1
      ],
      "content": "static void\ntest_ctime (const struct stat *statinfo)\n{\n  /* On some buggy NFS clients, mtime and ctime are disproportionately\n     skewed from one another.  Skip this test in that case.  */\n  if (statinfo[0].st_mtime != statinfo[0].st_ctime)\n    return;\n\n  /* mtime(stamp2) < ctime(testfile) */\n  ASSERT (statinfo[2].st_mtime < statinfo[1].st_ctime\n          || (statinfo[2].st_mtime == statinfo[1].st_ctime\n              && (get_stat_mtime_ns (&statinfo[2])\n                  < get_stat_ctime_ns (&statinfo[1]))));\n}",
      "lines": 14,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_birthtime": {
      "start_point": [
        192,
        0
      ],
      "end_point": [
        215,
        1
      ],
      "content": "static void\ntest_birthtime (const struct stat *statinfo,\n                const struct timespec *modtimes,\n                struct timespec *birthtimes)\n{\n  int i;\n\n  /* Collect the birth times.  */\n  for (i = 0; i < NFILES; ++i)\n    {\n      birthtimes[i] = get_stat_birthtime (&statinfo[i]);\n      if (birthtimes[i].tv_nsec < 0)\n        return;\n    }\n\n  /* mtime(stamp1) < birthtime(testfile) */\n  ASSERT (modtimes[0].tv_sec < birthtimes[1].tv_sec\n          || (modtimes[0].tv_sec == birthtimes[1].tv_sec\n              && modtimes[0].tv_nsec < birthtimes[1].tv_nsec));\n  /* birthtime(testfile) < mtime(stamp2) */\n  ASSERT (birthtimes[1].tv_sec < modtimes[2].tv_sec\n          || (birthtimes[1].tv_sec == modtimes[2].tv_sec\n              && birthtimes[1].tv_nsec < modtimes[2].tv_nsec));\n}",
      "lines": 24,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        217,
        0
      ],
      "end_point": [
        247,
        1
      ],
      "content": "int\nmain (void)\n{\n  struct stat statinfo[NFILES];\n  struct timespec modtimes[NFILES];\n  struct timespec birthtimes[NFILES];\n\n  initialize_filenames ();\n\n#ifdef SIGHUP\n  signal (SIGHUP, cleanup);\n#endif\n#ifdef SIGINT\n  signal (SIGINT, cleanup);\n#endif\n#ifdef SIGQUIT\n  signal (SIGQUIT, cleanup);\n#endif\n#ifdef SIGTERM\n  signal (SIGTERM, cleanup);\n#endif\n\n  cleanup (0);\n  prepare_test (statinfo, modtimes);\n  test_mtime (statinfo, modtimes);\n  test_ctime (statinfo);\n  test_birthtime (statinfo, modtimes, birthtimes);\n\n  cleanup (0);\n  return 0;\n}",
      "lines": 31,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-stat.c": {
    "do_stat": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "static int\ndo_stat (char const *name, struct stat *st)\n{\n  return stat (name, st);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "int\nmain (void)\n{\n  return test_stat_func (do_stat, true);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-stat.h": {
    "test_stat_func": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        100,
        1
      ],
      "content": "static int\ntest_stat_func (int (*func) (char const *, struct stat *), bool print)\n{\n  struct stat st1;\n  struct stat st2;\n  char *cwd = getcwd (NULL, 0);\n\n  ASSERT (cwd);\n  ASSERT (func (\".\", &st1) == 0);\n  ASSERT (func (\"./\", &st2) == 0);\n  ASSERT (SAME_INODE (st1, st2));\n  ASSERT (func (cwd, &st2) == 0);\n  ASSERT (SAME_INODE (st1, st2));\n  ASSERT (func (\"/\", &st1) == 0);\n  ASSERT (func (\"///\", &st2) == 0);\n  ASSERT (SAME_INODE (st1, st2));\n\n  errno = 0;\n  ASSERT (func (\"\", &st1) == -1);\n  ASSERT (errno == ENOENT);\n  errno = 0;\n  ASSERT (func (\"nosuch\", &st1) == -1);\n  ASSERT (errno == ENOENT);\n  errno = 0;\n  ASSERT (func (\"nosuch/\", &st1) == -1);\n  ASSERT (errno == ENOENT);\n\n  ASSERT (close (creat (BASE \"file\", 0600)) == 0);\n  ASSERT (func (BASE \"file\", &st1) == 0);\n  errno = 0;\n  ASSERT (func (BASE \"file/\", &st1) == -1);\n  ASSERT (errno == ENOTDIR);\n\n  /* Now for some symlink tests, where supported.  We set up:\n     link1 -> directory\n     link2 -> file\n     link3 -> dangling\n     link4 -> loop\n     then test behavior with trailing slash.\n  */\n  if (symlink (\".\", BASE \"link1\") != 0)\n    {\n      ASSERT (unlink (BASE \"file\") == 0);\n      if (print)\n        fputs (\"skipping test: symlinks not supported on this file system\\n\",\n               stderr);\n      return 77;\n    }\n  ASSERT (symlink (BASE \"file\", BASE \"link2\") == 0);\n  ASSERT (symlink (BASE \"nosuch\", BASE \"link3\") == 0);\n  ASSERT (symlink (BASE \"link4\", BASE \"link4\") == 0);\n\n  ASSERT (func (BASE \"link1/\", &st1) == 0);\n  ASSERT (S_ISDIR (st1.st_mode));\n\n  errno = 0;\n  ASSERT (func (BASE \"link2/\", &st1) == -1);\n  ASSERT (errno == ENOTDIR);\n\n  errno = 0;\n  ASSERT (func (BASE \"link3/\", &st1) == -1);\n  ASSERT (errno == ENOENT);\n\n  errno = 0;\n  ASSERT (func (BASE \"link4/\", &st1) == -1);\n  ASSERT (errno == ELOOP);\n\n  /* Cleanup.  */\n  ASSERT (unlink (BASE \"file\") == 0);\n  ASSERT (unlink (BASE \"link1\") == 0);\n  ASSERT (unlink (BASE \"link2\") == 0);\n  ASSERT (unlink (BASE \"link3\") == 0);\n  ASSERT (unlink (BASE \"link4\") == 0);\n  free (cwd);\n\n  return 0;\n}",
      "lines": 77,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-stdalign.c": {
    "main": {
      "start_point": [
        79,
        0
      ],
      "end_point": [
        120,
        1
      ],
      "content": "int\nmain ()\n{\n#if defined __SUNPRO_C\n  /* Avoid a test failure due to Sun Studio Developer Bug Report #2125432.  */\n  fputs (\"Skipping test: known Sun C compiler bug\\n\", stderr);\n  return 77;\n#elif defined __HP_cc && __ia64\n  /* Avoid a test failure due to HP-UX Itanium cc bug; see:\n     https://lists.gnu.org/r/bug-gnulib/2017-03/msg00078.html  */\n  fputs (\"Skipping test: known HP-UX Itanium cc compiler bug\\n\", stderr);\n  return 77;\n#else\n  CHECK_ALIGNED (static_char_alignas);\n  CHECK_ALIGNED (static_char_Alignas);\n  CHECK_ALIGNED (static_short_alignas);\n  CHECK_ALIGNED (static_short_Alignas);\n  CHECK_ALIGNED (static_int_alignas);\n  CHECK_ALIGNED (static_int_Alignas);\n  CHECK_ALIGNED (static_long_alignas);\n  CHECK_ALIGNED (static_long_Alignas);\n# ifdef INT64_MAX\n  CHECK_ALIGNED (static_int64_t_alignas);\n  CHECK_ALIGNED (static_int64_t_Alignas);\n# endif\n  CHECK_ALIGNED (static_float_alignas);\n  CHECK_ALIGNED (static_float_Alignas);\n  CHECK_ALIGNED (static_double_alignas);\n  CHECK_ALIGNED (static_double_Alignas);\n  /* CHECK_ALIGNED (static_longdouble_alignas); */\n  /* CHECK_ALIGNED (static_longdouble_Alignas); */\n  CHECK_ALIGNED (static_struct1_alignas);\n  CHECK_ALIGNED (static_struct1_Alignas);\n  CHECK_ALIGNED (static_struct2_alignas);\n  CHECK_ALIGNED (static_struct2_Alignas);\n  CHECK_ALIGNED (static_struct3_alignas);\n  CHECK_ALIGNED (static_struct3_Alignas);\n  CHECK_ALIGNED (static_struct4_alignas);\n  CHECK_ALIGNED (static_struct4_Alignas);\n  return 0;\n#endif\n}",
      "lines": 42,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-stdbool.c": {
    "main": {
      "start_point": [
        89,
        0
      ],
      "end_point": [
        117,
        1
      ],
      "content": "int\nmain ()\n{\n  int error = 0;\n\n#if HAVE_STDBOOL_H || 3 <= __GNUC__ /* See above.  */\n# ifdef ADDRESS_CHECK_OKAY /* Avoid gcc warning.  */\n  /* A cast from a variable's address to bool is valid in expressions.  */\n  {\n    bool e1 = &s;\n    if (!e1)\n      error = 1;\n  }\n# endif\n#endif\n\n  /* Catch a bug in IBM AIX xlc compiler version 6.0.0.0\n     reported by James Lemley on 2005-10-05; see\n     https://lists.gnu.org/r/bug-coreutils/2005-10/msg00086.html\n     This is a runtime test, since a corresponding compile-time\n     test would rely on initializer extensions.  */\n  {\n    char digs[] = \"0123456789\";\n    if (&(digs + 5)[-2 + (bool) 1] != &digs[4])\n      error = 1;\n  }\n\n  return error;\n}",
      "lines": 29,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-stddef.c": {
    "main": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "int\nmain (void)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-stdint.c": {
    "main": {
      "start_point": [
        421,
        0
      ],
      "end_point": [
        425,
        1
      ],
      "content": "int\nmain (void)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-stdio.c": {
    "main": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        42,
        1
      ],
      "content": "int\nmain (void)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-stdlib.c": {
    "main": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "int\nmain (void)\n{\n  if (test_sys_wait_macros ())\n    return 1;\n\n  return exitcode;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-strerror.c": {
    "main": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "int\nmain (void)\n{\n  char *str;\n\n  errno = 0;\n  str = strerror (EACCES);\n  ASSERT (str);\n  ASSERT (*str);\n  ASSERT (errno == 0);\n\n  errno = 0;\n  str = strerror (ETIMEDOUT);\n  ASSERT (str);\n  ASSERT (*str);\n  ASSERT (errno == 0);\n\n  errno = 0;\n  str = strerror (EOVERFLOW);\n  ASSERT (str);\n  ASSERT (*str);\n  ASSERT (errno == 0);\n\n  /* POSIX requires strerror (0) to succeed.  Reject use of \"Unknown\n     error\", but allow \"Success\", \"No error\", or even Solaris' \"Error\n     0\" which are distinct patterns from true out-of-range strings.\n     http://austingroupbugs.net/view.php?id=382  */\n  errno = 0;\n  str = strerror (0);\n  ASSERT (str);\n  ASSERT (*str);\n  ASSERT (errno == 0);\n  ASSERT (strstr (str, \"nknown\") == NULL);\n  ASSERT (strstr (str, \"ndefined\") == NULL);\n\n  /* POSIX requires strerror to produce a non-NULL result for all\n     inputs; as an extension, we also guarantee a non-empty result.\n     Reporting EINVAL is optional.  */\n  errno = 0;\n  str = strerror (-3);\n  ASSERT (str);\n  ASSERT (*str);\n  ASSERT (errno == 0 || errno == EINVAL);\n\n  return 0;\n}",
      "lines": 46,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-strerror_r.c": {
    "main": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        180,
        1
      ],
      "content": "int\nmain (void)\n{\n  char buf[100];\n  int ret;\n\n  /* Test results with valid errnum and enough room.  */\n\n  errno = 0;\n  buf[0] = '\\0';\n  ASSERT (strerror_r (EACCES, buf, sizeof buf) == 0);\n  ASSERT (buf[0] != '\\0');\n  ASSERT (errno == 0);\n  ASSERT (strlen (buf) < sizeof buf);\n\n  errno = 0;\n  buf[0] = '\\0';\n  ASSERT (strerror_r (ETIMEDOUT, buf, sizeof buf) == 0);\n  ASSERT (buf[0] != '\\0');\n  ASSERT (errno == 0);\n  ASSERT (strlen (buf) < sizeof buf);\n\n  errno = 0;\n  buf[0] = '\\0';\n  ASSERT (strerror_r (EOVERFLOW, buf, sizeof buf) == 0);\n  ASSERT (buf[0] != '\\0');\n  ASSERT (errno == 0);\n  ASSERT (strlen (buf) < sizeof buf);\n\n  /* POSIX requires strerror (0) to succeed.  Reject use of \"Unknown\n     error\", but allow \"Success\", \"No error\", or even Solaris' \"Error\n     0\" which are distinct patterns from true out-of-range strings.\n     http://austingroupbugs.net/view.php?id=382  */\n  errno = 0;\n  buf[0] = '\\0';\n  ret = strerror_r (0, buf, sizeof buf);\n  ASSERT (ret == 0);\n  ASSERT (buf[0]);\n  ASSERT (errno == 0);\n  ASSERT (strstr (buf, \"nknown\") == NULL);\n  ASSERT (strstr (buf, \"ndefined\") == NULL);\n\n  /* Test results with out-of-range errnum and enough room.  POSIX\n     allows an empty string on success, and allows an unchanged buf on\n     error, but these are not useful, so we guarantee contents.  */\n  errno = 0;\n  buf[0] = '^';\n  ret = strerror_r (-3, buf, sizeof buf);\n  ASSERT (ret == 0 || ret == EINVAL);\n  ASSERT (buf[0] != '^');\n  ASSERT (*buf);\n  ASSERT (errno == 0);\n  ASSERT (strlen (buf) < sizeof buf);\n\n  /* Test results with a too small buffer.  POSIX requires an error;\n     only ERANGE for 0 and valid errors, and a choice of ERANGE or\n     EINVAL for out-of-range values.  On error, POSIX permits buf to\n     be empty, unchanged, or unterminated, but these are not useful,\n     so we guarantee NUL-terminated truncated contents for all but\n     size 0.  http://austingroupbugs.net/view.php?id=398.  Also ensure\n     that no out-of-bounds writes occur.  */\n  {\n    int errs[] = { EACCES, 0, -3, };\n    int j;\n\n    buf[sizeof buf - 1] = '\\0';\n    for (j = 0; j < SIZEOF (errs); j++)\n      {\n        int err = errs[j];\n        char buf2[sizeof buf] = \"\";\n        size_t len;\n        size_t i;\n\n        strerror_r (err, buf2, sizeof buf2);\n        len = strlen (buf2);\n        ASSERT (len < sizeof buf);\n\n        for (i = 0; i <= len; i++)\n          {\n            memset (buf, '^', sizeof buf - 1);\n            errno = 0;\n            ret = strerror_r (err, buf, i);\n            ASSERT (errno == 0);\n            if (j == 2)\n              ASSERT (ret == ERANGE || ret == EINVAL);\n            else\n              ASSERT (ret == ERANGE);\n            if (i)\n              {\n                ASSERT (strncmp (buf, buf2, i - 1) == 0);\n                ASSERT (buf[i - 1] == '\\0');\n              }\n            ASSERT (strspn (buf + i, \"^\") == sizeof buf - 1 - i);\n          }\n\n        strcpy (buf, \"BADFACE\");\n        errno = 0;\n        ret = strerror_r (err, buf, len + 1);\n        ASSERT (ret != ERANGE);\n        ASSERT (errno == 0);\n        ASSERT (strcmp (buf, buf2) == 0);\n      }\n  }\n\n#if GNULIB_STRERROR\n  /* Test that strerror_r does not clobber strerror buffer.  On some\n     platforms, this test can only succeed if gnulib also replaces\n     strerror.  */\n  {\n    const char *msg1;\n    const char *msg2;\n    const char *msg3;\n    const char *msg4;\n    char *str1;\n    char *str2;\n    char *str3;\n    char *str4;\n\n    msg1 = strerror (ENOENT);\n    ASSERT (msg1);\n    str1 = strdup (msg1);\n    ASSERT (str1);\n\n    msg2 = strerror (ERANGE);\n    ASSERT (msg2);\n    str2 = strdup (msg2);\n    ASSERT (str2);\n\n    msg3 = strerror (-4);\n    ASSERT (msg3);\n    str3 = strdup (msg3);\n    ASSERT (str3);\n\n    msg4 = strerror (1729576);\n    ASSERT (msg4);\n    str4 = strdup (msg4);\n    ASSERT (str4);\n\n    strerror_r (EACCES, buf, sizeof buf);\n    strerror_r (-5, buf, sizeof buf);\n    ASSERT (msg1 == msg2 || msg1 == msg4 || STREQ (msg1, str1));\n    ASSERT (msg2 == msg4 || STREQ (msg2, str2));\n    ASSERT (msg3 == msg4 || STREQ (msg3, str3));\n    ASSERT (STREQ (msg4, str4));\n\n    free (str1);\n    free (str2);\n    free (str3);\n    free (str4);\n  }\n#endif\n\n  return 0;\n}",
      "lines": 154,
      "depth": 17,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-string.c": {
    "main": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        32,
        1
      ],
      "content": "int\nmain (void)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-strverscmp.c": {
    "main": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "int\nmain (void)\n{\n  ASSERT (strverscmp (\"\", \"\") == 0);\n  ASSERT (strverscmp (\"a\", \"a\") == 0);\n  ASSERT (strverscmp (\"a\", \"b\") < 0);\n  ASSERT (strverscmp (\"b\", \"a\") > 0);\n  ASSERT (strverscmp (\"000\", \"00\") < 0);\n  ASSERT (strverscmp (\"00\", \"000\") > 0);\n  ASSERT (strverscmp (\"a0\", \"a\") > 0);\n  ASSERT (strverscmp (\"00\", \"01\") < 0);\n  ASSERT (strverscmp (\"01\", \"010\") < 0);\n  ASSERT (strverscmp (\"010\", \"09\") < 0);\n  ASSERT (strverscmp (\"09\", \"0\") < 0);\n  ASSERT (strverscmp (\"9\", \"10\") < 0);\n  ASSERT (strverscmp (\"0a\", \"0\") > 0);\n\n  /* From glibc bug 9913.  */\n  {\n    static char const a[] = \"B0075022800016.gbp.corp.com\";\n    static char const b[] = \"B007502280067.gbp.corp.com\";\n    static char const c[] = \"B007502357019.GBP.CORP.COM\";\n    ASSERT (strverscmp (a, b) < 0);\n    ASSERT (strverscmp (b, c) < 0);\n    ASSERT (strverscmp (a, c) < 0);\n    ASSERT (strverscmp (b, a) > 0);\n    ASSERT (strverscmp (c, b) > 0);\n    ASSERT (strverscmp (c, a) > 0);\n  }\n\n  return 0;\n}",
      "lines": 32,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-symlink.c": {
    "main": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        46,
        1
      ],
      "content": "int\nmain (void)\n{\n  /* Remove any leftovers from a previous partial run.  */\n  ignore_value (system (\"rm -rf \" BASE \"*\"));\n\n  return test_symlink (symlink, true);\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-symlink.h": {
    "test_symlink": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "static int\ntest_symlink (int (*func) (char const *, char const *), bool print)\n{\n  if (func (\"nowhere\", BASE \"link1\"))\n    {\n      if (print)\n        fputs (\"skipping test: symlinks not supported on this file system\\n\",\n               stderr);\n      return 77;\n    }\n\n  /* Some systems allow the creation of 0-length symlinks as a synonym\n     for \".\"; but most reject it.  */\n  {\n    int status;\n    errno = 0;\n    status = func (\"\", BASE \"link2\");\n    if (status == -1)\n      ASSERT (errno == ENOENT || errno == EINVAL);\n    else\n      {\n        ASSERT (status == 0);\n        ASSERT (unlink (BASE \"link2\") == 0);\n      }\n  }\n\n  /* Sanity checks of failures.  */\n  errno = 0;\n  ASSERT (func (\"nowhere\", \"\") == -1);\n  ASSERT (errno == ENOENT);\n  errno = 0;\n  ASSERT (func (\"nowhere\", \".\") == -1);\n  ASSERT (errno == EEXIST || errno == EINVAL);\n  errno = 0;\n  ASSERT (func (\"somewhere\", BASE \"link1\") == -1);\n  ASSERT (errno == EEXIST);\n  errno = 0;\n  ASSERT (func (\"nowhere\", BASE \"link2/\") == -1);\n  ASSERT (errno == ENOTDIR || errno == ENOENT);\n  ASSERT (mkdir (BASE \"dir\", 0700) == 0);\n  errno = 0;\n  ASSERT (func (\"nowhere\", BASE \"dir\") == -1);\n  ASSERT (errno == EEXIST);\n  errno = 0;\n  ASSERT (func (\"nowhere\", BASE \"dir/\") == -1);\n  ASSERT (errno == EEXIST || errno == EINVAL);\n  ASSERT (close (creat (BASE \"file\", 0600)) == 0);\n  errno = 0;\n  ASSERT (func (\"nowhere\", BASE \"file\") == -1);\n  ASSERT (errno == EEXIST);\n  errno = 0;\n  ASSERT (func (\"nowhere\", BASE \"file/\") == -1);\n  ASSERT (errno == EEXIST || errno == ENOTDIR || errno == ENOENT);\n\n  /* Trailing slash must always be rejected.  */\n  ASSERT (unlink (BASE \"link1\") == 0);\n  ASSERT (func (BASE \"link2\", BASE \"link1\") == 0);\n  errno = 0;\n  ASSERT (func (BASE \"nowhere\", BASE \"link1/\") == -1);\n  ASSERT (errno == EEXIST || errno == ENOTDIR || errno == ENOENT);\n  errno = 0;\n  ASSERT (unlink (BASE \"link2\") == -1);\n  ASSERT (errno == ENOENT);\n\n  /* Cleanup.  */\n  ASSERT (rmdir (BASE \"dir\") == 0);\n  ASSERT (unlink (BASE \"file\") == 0);\n  ASSERT (unlink (BASE \"link1\") == 0);\n\n  return 0;\n}",
      "lines": 71,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-sys_ioctl.c": {
    "main": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        26,
        1
      ],
      "content": "int\nmain (void)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-sys_select.c": {
    "main": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "int\nmain (void)\n{\n  /* Check that FD_ZERO can be used.  This should not yield a warning\n     such as \"warning: implicit declaration of function 'memset'\".  */\n  fd_set fds;\n  FD_ZERO (&fds);\n\n  return 0;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-sys_socket.c": {
    "main": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "int\nmain (void)\n{\n  struct sockaddr_storage x;\n  sa_family_t i;\n\n  /* Check some errno values.  */\n  switch (ENOTSOCK)\n    {\n    case ENOTSOCK:\n    case EADDRINUSE:\n    case ENETRESET:\n    case ECONNABORTED:\n    case ECONNRESET:\n    case ENOTCONN:\n    case ESHUTDOWN:\n      break;\n    }\n\n  x.ss_family = 42;\n  i = 42;\n  msg.msg_iov = &io;\n\n  return (x.ss_family - i + msg.msg_namelen + msg.msg_iov->iov_len\n          + msg.msg_iovlen);\n}",
      "lines": 26,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-sys_stat.c": {
    "main": {
      "start_point": [
        335,
        0
      ],
      "end_point": [
        339,
        1
      ],
      "content": "int\nmain (void)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-sys_time.c": {
    "main": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        33,
        1
      ],
      "content": "int\nmain (void)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-sys_types.c": {
    "main": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        33,
        1
      ],
      "content": "int\nmain (void)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-sys_uio.c": {
    "main": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        31,
        1
      ],
      "content": "int\nmain (void)\n{\n  return a + b + !!c.iov_base + c.iov_len;\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-sys_wait.h": {
    "test_sys_wait_macros": {
      "start_point": [
        18,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "static int\ntest_sys_wait_macros (void)\n{\n  /* Check subset of <sys/wait.h> macros that must be visible here.\n     Note that some of these macros are only portable when operating\n     on an lvalue.  */\n  int i;\n  for (i = 0; i < 0x8000; i = (i ? i << 1 : 1))\n    {\n      /* POSIX requires that for all valid process statuses, that\n         exactly one of these three macros is true.  But not all\n         possible 16-bit values map to valid process status.\n         Traditionally, 8 of the bits are for WIFEXITED, 7 of the bits\n         to tell between WIFSIGNALED and WIFSTOPPED, and either 0x80\n         or 0x8000 to flag that core was also dumped.  Since we don't\n         know which byte is WIFEXITED, we skip the both possible bits\n         that can signal core dump.  */\n      if (i == 0x80)\n        continue;\n      if (!!WIFSIGNALED (i) + !!WIFEXITED (i) + !!WIFSTOPPED (i) != 1)\n        return 1;\n    }\n  i = WEXITSTATUS (i) + WSTOPSIG (i) + WTERMSIG (i);\n\n  switch (i)\n    {\n#if 0\n  /* Gnulib doesn't guarantee these, yet.  */\n    case WNOHANG:\n    case WUNTRACED:\n#endif\n      break;\n    }\n  return 0;\n}",
      "lines": 35,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-time.c": {
    "main": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "int\nmain (void)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-unistd.c": {
    "main": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "int\nmain (void)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-unsetenv.c": {
    "main": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "int\nmain (void)\n{\n  char entry[] = \"b=2\";\n\n  /* Test removal when multiple entries present.  */\n  ASSERT (putenv ((char *) \"a=1\") == 0);\n  ASSERT (putenv (entry) == 0);\n  entry[0] = 'a'; /* Unspecified what getenv(\"a\") would be at this point.  */\n  ASSERT (unsetenv (\"a\") == 0); /* Both entries will be removed.  */\n  ASSERT (getenv (\"a\") == NULL);\n  ASSERT (unsetenv (\"a\") == 0);\n\n  /* Required to fail with EINVAL.  */\n  errno = 0;\n  ASSERT (unsetenv (\"\") == -1);\n  ASSERT (errno == EINVAL);\n  errno = 0;\n  ASSERT (unsetenv (\"a=b\") == -1);\n  ASSERT (errno == EINVAL);\n#if 0\n  /* glibc and gnulib's implementation guarantee this, but POSIX no\n     longer requires it: http://austingroupbugs.net/view.php?id=185  */\n  errno = 0;\n  ASSERT (unsetenv (NULL) == -1);\n  ASSERT (errno == EINVAL);\n#endif\n\n  return 0;\n}",
      "lines": 30,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-verify-try.c": {},
  "sed/sed-4.5/gnulib-tests/test-verify.c": {
    "function": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "static int\nfunction (int n)\n{\n#if EXP_FAIL == 3\n  verify (n >= 0);                  /* should give ERROR: non-constant expression */\n#endif\n  verify (c == 2);                  /* should be ok */\n#if EXP_FAIL == 4\n  verify (1 + 1 == 3);              /* should give ERROR */\n#endif\n  verify (1 == 1); verify (1 == 1); /* should be ok */\n\n  if (n)\n    return ((void) verify_expr (1 == 1, 1), verify_expr (1 == 1, 8)); /* should be ok */\n#if EXP_FAIL == 5\n  return verify_expr (1 == 2, 5); /* should give ERROR */\n#endif\n  return 0;\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        64,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "int\nmain (void)\n{\n  return !(function (0) == 0 && function (1) == 8);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-version-etc.c": {
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        30,
        1
      ],
      "content": "int\nmain (int argc _GL_UNUSED, char **argv)\n{\n  version_etc (stdout, \"test-version-etc\", \"dummy\", \"0\", AUTHORS,\n               (const char *) NULL);\n  return 0;\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-wchar.c": {
    "main": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "int\nmain (void)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-wcrtomb-w32.c": {
    "test_one_locale": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        296,
        1
      ],
      "content": "static int\ntest_one_locale (const char *name, int codepage)\n{\n  char buf[64];\n  size_t ret;\n\n# if 1\n  /* Portable code to set the locale.  */\n  {\n    char name_with_codepage[1024];\n\n    sprintf (name_with_codepage, \"%s.%d\", name, codepage);\n\n    /* Set the locale.  */\n    if (setlocale (LC_ALL, name_with_codepage) == NULL)\n      return 77;\n  }\n# else\n  /* Hacky way to set a locale.codepage combination that setlocale() refuses\n     to set.  */\n  {\n    /* Codepage of the current locale, set with setlocale().\n       Not necessarily the same as GetACP().  */\n    extern __declspec(dllimport) unsigned int __lc_codepage;\n\n    /* Set the locale.  */\n    if (setlocale (LC_ALL, name) == NULL)\n      return 77;\n\n    /* Clobber the codepage and MB_CUR_MAX, both set by setlocale().  */\n    __lc_codepage = codepage;\n    switch (codepage)\n      {\n      case 1252:\n      case 1256:\n        MB_CUR_MAX = 1;\n        break;\n      case 932:\n      case 950:\n      case 936:\n        MB_CUR_MAX = 2;\n        break;\n      case 54936:\n      case 65001:\n        MB_CUR_MAX = 4;\n        break;\n      }\n\n    /* Test whether the codepage is really available.  */\n    {\n      mbstate_t state;\n      wchar_t wc;\n\n      memset (&state, '\\0', sizeof (mbstate_t));\n      if (mbrtowc (&wc, \" \", 1, &state) == (size_t)(-1))\n        return 77;\n    }\n  }\n# endif\n\n  /* Test NUL character.  */\n  {\n    buf[0] = 'x';\n    ret = wcrtomb (buf, 0, NULL);\n    ASSERT (ret == 1);\n    ASSERT (buf[0] == '\\0');\n  }\n\n  /* Test single bytes.  */\n  {\n    int c;\n\n    for (c = 0; c < 0x100; c++)\n      switch (c)\n        {\n        case '\\t': case '\\v': case '\\f':\n        case ' ': case '!': case '\"': case '#': case '%':\n        case '&': case '\\'': case '(': case ')': case '*':\n        case '+': case ',': case '-': case '.': case '/':\n        case '0': case '1': case '2': case '3': case '4':\n        case '5': case '6': case '7': case '8': case '9':\n        case ':': case ';': case '<': case '=': case '>':\n        case '?':\n        case 'A': case 'B': case 'C': case 'D': case 'E':\n        case 'F': case 'G': case 'H': case 'I': case 'J':\n        case 'K': case 'L': case 'M': case 'N': case 'O':\n        case 'P': case 'Q': case 'R': case 'S': case 'T':\n        case 'U': case 'V': case 'W': case 'X': case 'Y':\n        case 'Z':\n        case '[': case '\\\\': case ']': case '^': case '_':\n        case 'a': case 'b': case 'c': case 'd': case 'e':\n        case 'f': case 'g': case 'h': case 'i': case 'j':\n        case 'k': case 'l': case 'm': case 'n': case 'o':\n        case 'p': case 'q': case 'r': case 's': case 't':\n        case 'u': case 'v': case 'w': case 'x': case 'y':\n        case 'z': case '{': case '|': case '}': case '~':\n          /* c is in the ISO C \"basic character set\".  */\n          ret = wcrtomb (buf, btowc (c), NULL);\n          ASSERT (ret == 1);\n          ASSERT (buf[0] == (char) c);\n          break;\n        }\n  }\n\n  /* Test special calling convention, passing a NULL pointer.  */\n  {\n    ret = wcrtomb (NULL, '\\0', NULL);\n    ASSERT (ret == 1);\n    ret = wcrtomb (NULL, btowc ('x'), NULL);\n    ASSERT (ret == 1);\n  }\n\n  switch (codepage)\n    {\n    case 1252:\n      /* Locale encoding is CP1252, an extension of ISO-8859-1.  */\n      {\n        /* Convert \"B\\374\\337er\": \"B\u00c3\u00bc\u00c3\u009fer\" */\n        memset (buf, 'x', 8);\n        ret = wcrtomb (buf, 0x00FC, NULL);\n        ASSERT (ret == 1);\n        ASSERT (memcmp (buf, \"\\374\", 1) == 0);\n        ASSERT (buf[1] == 'x');\n\n        memset (buf, 'x', 8);\n        ret = wcrtomb (buf, 0x00DF, NULL);\n        ASSERT (ret == 1);\n        ASSERT (memcmp (buf, \"\\337\", 1) == 0);\n        ASSERT (buf[1] == 'x');\n      }\n      return 0;\n\n    case 1256:\n      /* Locale encoding is CP1256, not the same as ISO-8859-6.  */\n      {\n        /* Convert \"x\\302\\341\\346y\": \"x\u00d8\u00a2\u00d9\u0084\u00d9\u0088y\" */\n        memset (buf, 'x', 8);\n        ret = wcrtomb (buf, 0x0622, NULL);\n        ASSERT (ret == 1);\n        ASSERT (memcmp (buf, \"\\302\", 1) == 0);\n        ASSERT (buf[1] == 'x');\n\n        memset (buf, 'x', 8);\n        ret = wcrtomb (buf, 0x0644, NULL);\n        ASSERT (ret == 1);\n        ASSERT (memcmp (buf, \"\\341\", 1) == 0);\n        ASSERT (buf[1] == 'x');\n\n        memset (buf, 'x', 8);\n        ret = wcrtomb (buf, 0x0648, NULL);\n        ASSERT (ret == 1);\n        ASSERT (memcmp (buf, \"\\346\", 1) == 0);\n        ASSERT (buf[1] == 'x');\n      }\n      return 0;\n\n    case 932:\n      /* Locale encoding is CP932, similar to Shift_JIS.  */\n      {\n        /* Convert \"<\\223\\372\\226\\173\\214\\352>\": \"<\u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e>\" */\n        memset (buf, 'x', 8);\n        ret = wcrtomb (buf, 0x65E5, NULL);\n        ASSERT (ret == 2);\n        ASSERT (memcmp (buf, \"\\223\\372\", 2) == 0);\n        ASSERT (buf[2] == 'x');\n\n        memset (buf, 'x', 8);\n        ret = wcrtomb (buf, 0x672C, NULL);\n        ASSERT (ret == 2);\n        ASSERT (memcmp (buf, \"\\226\\173\", 2) == 0);\n        ASSERT (buf[2] == 'x');\n\n        memset (buf, 'x', 8);\n        ret = wcrtomb (buf, 0x8A9E, NULL);\n        ASSERT (ret == 2);\n        ASSERT (memcmp (buf, \"\\214\\352\", 2) == 0);\n        ASSERT (buf[2] == 'x');\n      }\n      return 0;\n\n    case 950:\n      /* Locale encoding is CP950, similar to Big5.  */\n      {\n        /* Convert \"<\\244\\351\\245\\273\\273\\171>\": \"<\u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e>\" */\n        memset (buf, 'x', 8);\n        ret = wcrtomb (buf, 0x65E5, NULL);\n        ASSERT (ret == 2);\n        ASSERT (memcmp (buf, \"\\244\\351\", 2) == 0);\n        ASSERT (buf[2] == 'x');\n\n        memset (buf, 'x', 8);\n        ret = wcrtomb (buf, 0x672C, NULL);\n        ASSERT (ret == 2);\n        ASSERT (memcmp (buf, \"\\245\\273\", 2) == 0);\n        ASSERT (buf[2] == 'x');\n\n        memset (buf, 'x', 8);\n        ret = wcrtomb (buf, 0x8A9E, NULL);\n        ASSERT (ret == 2);\n        ASSERT (memcmp (buf, \"\\273\\171\", 2) == 0);\n        ASSERT (buf[2] == 'x');\n      }\n      return 0;\n\n    case 936:\n      /* Locale encoding is CP936 = GBK, an extension of GB2312.  */\n      {\n        /* Convert \"<\\310\\325\\261\\276\\325\\132>\": \"<\u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e>\" */\n        memset (buf, 'x', 8);\n        ret = wcrtomb (buf, 0x65E5, NULL);\n        ASSERT (ret == 2);\n        ASSERT (memcmp (buf, \"\\310\\325\", 2) == 0);\n        ASSERT (buf[2] == 'x');\n\n        memset (buf, 'x', 8);\n        ret = wcrtomb (buf, 0x672C, NULL);\n        ASSERT (ret == 2);\n        ASSERT (memcmp (buf, \"\\261\\276\", 2) == 0);\n        ASSERT (buf[2] == 'x');\n\n        memset (buf, 'x', 8);\n        ret = wcrtomb (buf, 0x8A9E, NULL);\n        ASSERT (ret == 2);\n        ASSERT (memcmp (buf, \"\\325\\132\", 2) == 0);\n        ASSERT (buf[2] == 'x');\n      }\n      return 0;\n\n    case 54936:\n      /* Locale encoding is CP54936 = GB18030.  */\n      {\n        /* Convert \"B\\250\\271\\201\\060\\211\\070er\": \"B\u00c3\u00bc\u00c3\u009fer\" */\n        memset (buf, 'x', 8);\n        ret = wcrtomb (buf, 0x00FC, NULL);\n        ASSERT (ret == 2);\n        ASSERT (memcmp (buf, \"\\250\\271\", 2) == 0);\n        ASSERT (buf[2] == 'x');\n\n        memset (buf, 'x', 8);\n        ret = wcrtomb (buf, 0x00DF, NULL);\n        ASSERT (ret == 4);\n        ASSERT (memcmp (buf, \"\\201\\060\\211\\070\", 4) == 0);\n        ASSERT (buf[4] == 'x');\n      }\n      return 0;\n\n    case 65001:\n      /* Locale encoding is CP65001 = UTF-8.  */\n      {\n        /* Convert \"B\\303\\274\\303\\237er\": \"B\u00c3\u00bc\u00c3\u009fer\" */\n        memset (buf, 'x', 8);\n        ret = wcrtomb (buf, 0x00FC, NULL);\n        ASSERT (ret == 2);\n        ASSERT (memcmp (buf, \"\\303\\274\", 2) == 0);\n        ASSERT (buf[2] == 'x');\n\n        memset (buf, 'x', 8);\n        ret = wcrtomb (buf, 0x00DF, NULL);\n        ASSERT (ret == 2);\n        ASSERT (memcmp (buf, \"\\303\\237\", 2) == 0);\n        ASSERT (buf[2] == 'x');\n      }\n      return 0;\n\n    default:\n      return 1;\n    }\n}",
      "lines": 268,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": [
      {
        "start_point": [
          298,
          0
        ],
        "end_point": [
          320,
          1
        ],
        "content": "int\nmain (int argc, char *argv[])\n{\n  int codepage = atoi (argv[argc - 1]);\n  int result;\n  int i;\n\n  result = 77;\n  for (i = 1; i < argc - 1; i++)\n    {\n      int ret = test_one_locale (argv[i], codepage);\n\n      if (ret != 77)\n        result = ret;\n    }\n\n  if (result == 77)\n    {\n      fprintf (stderr, \"Skipping test: found no locale with codepage %d\\n\",\n               codepage);\n    }\n  return result;\n}",
        "lines": 23,
        "depth": 10,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          324,
          0
        ],
        "end_point": [
          329,
          1
        ],
        "content": "int\nmain (int argc, char *argv[])\n{\n  fputs (\"Skipping test: not a native Windows system\\n\", stderr);\n  return 77;\n}",
        "lines": 6,
        "depth": 7,
        "decorators": [
          "int"
        ]
      }
    ]
  },
  "sed/sed-4.5/gnulib-tests/test-wcrtomb.c": {
    "check_character": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "static void\ncheck_character (const char *s, size_t n)\n{\n  wchar_t wc;\n  char buf[64];\n  int iret;\n  size_t ret;\n\n  wc = (wchar_t) 0xBADFACE;\n  iret = mbtowc (&wc, s, n);\n  ASSERT (iret == n);\n\n  ret = wcrtomb (buf, wc, NULL);\n  ASSERT (ret == n);\n  ASSERT (memcmp (buf, s, n) == 0);\n\n  /* Test special calling convention, passing a NULL pointer.  */\n  ret = wcrtomb (NULL, wc, NULL);\n  ASSERT (ret == 1);\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        161,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  char buf[64];\n  size_t ret;\n\n  /* configure should already have checked that the locale is supported.  */\n  if (setlocale (LC_ALL, \"\") == NULL)\n    return 1;\n\n  /* Test NUL character.  */\n  {\n    buf[0] = 'x';\n    ret = wcrtomb (buf, 0, NULL);\n    ASSERT (ret == 1);\n    ASSERT (buf[0] == '\\0');\n  }\n\n  /* Test single bytes.  */\n  {\n    int c;\n\n    for (c = 0; c < 0x100; c++)\n      switch (c)\n        {\n        case '\\t': case '\\v': case '\\f':\n        case ' ': case '!': case '\"': case '#': case '%':\n        case '&': case '\\'': case '(': case ')': case '*':\n        case '+': case ',': case '-': case '.': case '/':\n        case '0': case '1': case '2': case '3': case '4':\n        case '5': case '6': case '7': case '8': case '9':\n        case ':': case ';': case '<': case '=': case '>':\n        case '?':\n        case 'A': case 'B': case 'C': case 'D': case 'E':\n        case 'F': case 'G': case 'H': case 'I': case 'J':\n        case 'K': case 'L': case 'M': case 'N': case 'O':\n        case 'P': case 'Q': case 'R': case 'S': case 'T':\n        case 'U': case 'V': case 'W': case 'X': case 'Y':\n        case 'Z':\n        case '[': case '\\\\': case ']': case '^': case '_':\n        case 'a': case 'b': case 'c': case 'd': case 'e':\n        case 'f': case 'g': case 'h': case 'i': case 'j':\n        case 'k': case 'l': case 'm': case 'n': case 'o':\n        case 'p': case 'q': case 'r': case 's': case 't':\n        case 'u': case 'v': case 'w': case 'x': case 'y':\n        case 'z': case '{': case '|': case '}': case '~':\n          /* c is in the ISO C \"basic character set\".  */\n          ret = wcrtomb (buf, btowc (c), NULL);\n          ASSERT (ret == 1);\n          ASSERT (buf[0] == (char) c);\n          break;\n        }\n  }\n\n  /* Test special calling convention, passing a NULL pointer.  */\n  {\n    ret = wcrtomb (NULL, '\\0', NULL);\n    ASSERT (ret == 1);\n    ret = wcrtomb (NULL, btowc ('x'), NULL);\n    ASSERT (ret == 1);\n  }\n\n  if (argc > 1)\n    switch (argv[1][0])\n      {\n      case '1':\n        /* Locale encoding is ISO-8859-1 or ISO-8859-15.  */\n        {\n          const char input[] = \"B\\374\\337er\"; /* \"B\u00c3\u00bc\u00c3\u009fer\" */\n\n          check_character (input + 1, 1);\n          check_character (input + 2, 1);\n        }\n        return 0;\n\n      case '2':\n        /* Locale encoding is UTF-8.  */\n        {\n          const char input[] = \"B\\303\\274\\303\\237er\"; /* \"B\u00c3\u00bc\u00c3\u009fer\" */\n\n          check_character (input + 1, 2);\n          check_character (input + 3, 2);\n        }\n        return 0;\n\n      case '3':\n        /* Locale encoding is EUC-JP.  */\n        {\n          const char input[] = \"<\\306\\374\\313\\334\\270\\354>\"; /* \"<\u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e>\" */\n\n          check_character (input + 1, 2);\n          check_character (input + 3, 2);\n          check_character (input + 5, 2);\n        }\n        return 0;\n\n      case '4':\n        /* Locale encoding is GB18030.  */\n        {\n          const char input[] = \"B\\250\\271\\201\\060\\211\\070er\"; /* \"B\u00c3\u00bc\u00c3\u009fer\" */\n\n          check_character (input + 1, 2);\n          check_character (input + 3, 4);\n        }\n        return 0;\n      }\n\n  return 1;\n}",
      "lines": 109,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-wctype-h.c": {
    "main": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        73,
        1
      ],
      "content": "int\nmain (void)\n{\n  /* Check that the isw* functions exist as functions or as macros.  */\n  (void) iswalnum (0);\n  (void) iswalpha (0);\n  (void) iswcntrl (0);\n  (void) iswdigit (0);\n  (void) iswgraph (0);\n  (void) iswlower (0);\n  (void) iswprint (0);\n  (void) iswpunct (0);\n  (void) iswspace (0);\n  (void) iswupper (0);\n  (void) iswxdigit (0);\n\n  /* Check that the isw* functions map WEOF to 0.  */\n  ASSERT (!iswalnum (e));\n  ASSERT (!iswalpha (e));\n  ASSERT (!iswcntrl (e));\n  ASSERT (!iswdigit (e));\n  ASSERT (!iswgraph (e));\n  ASSERT (!iswlower (e));\n  ASSERT (!iswprint (e));\n  ASSERT (!iswpunct (e));\n  ASSERT (!iswspace (e));\n  ASSERT (!iswupper (e));\n  ASSERT (!iswxdigit (e));\n\n  /* Check that the tow* functions exist as functions or as macros.  */\n  (void) towlower (0);\n  (void) towupper (0);\n\n  /* Check that the tow* functions map WEOF to WEOF.  */\n  ASSERT (towlower (e) == e);\n  ASSERT (towupper (e) == e);\n\n  return 0;\n}",
      "lines": 39,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/test-xalloc-die.c": {
    "main": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        27,
        1
      ],
      "content": "int\nmain (int argc _GL_UNUSED, char **argv)\n{\n  xalloc_die ();\n  return 0;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/unsetenv.c": {
    "unsetenv": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "int\nunsetenv (const char *name)\n{\n  size_t len;\n  char **ep;\n\n  if (name == NULL || *name == '\\0' || strchr (name, '=') != NULL)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  len = strlen (name);\n\n  LOCK;\n\n  ep = __environ;\n  while (*ep != NULL)\n    if (!strncmp (*ep, name, len) && (*ep)[len] == '=')\n      {\n        /* Found it.  Remove this pointer by moving later ones back.  */\n        char **dp = ep;\n\n        do\n          dp[0] = dp[1];\n        while (*dp++);\n        /* Continue the loop in case NAME appears again.  */\n      }\n    else\n      ++ep;\n\n  UNLOCK;\n\n  return 0;\n}",
      "lines": 35,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "rpl_unsetenv": {
      "start_point": [
        109,
        0
      ],
      "end_point": [
        124,
        1
      ],
      "content": "int\nrpl_unsetenv (const char *name)\n{\n  int result = 0;\n  if (!name || !*name || strchr (name, '='))\n    {\n      errno = EINVAL;\n      return -1;\n    }\n  while (getenv (name))\n# if !VOID_UNSETENV\n    result =\n# endif\n      unsetenv (name);\n  return result;\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/unused-parameter.h": {},
  "sed/sed-4.5/gnulib-tests/w32sock.h": {
    "set_winsock_errno": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        139,
        1
      ],
      "content": "static inline void\nset_winsock_errno (void)\n{\n  int err = WSAGetLastError ();\n\n  /* Map some WSAE* errors to the runtime library's error codes.  */\n  switch (err)\n    {\n    case WSA_INVALID_HANDLE:\n      errno = EBADF;\n      break;\n    case WSA_NOT_ENOUGH_MEMORY:\n      errno = ENOMEM;\n      break;\n    case WSA_INVALID_PARAMETER:\n      errno = EINVAL;\n      break;\n    case WSAENAMETOOLONG:\n      errno = ENAMETOOLONG;\n      break;\n    case WSAENOTEMPTY:\n      errno = ENOTEMPTY;\n      break;\n    case WSAEWOULDBLOCK:\n      errno = EWOULDBLOCK;\n      break;\n    case WSAEINPROGRESS:\n      errno = EINPROGRESS;\n      break;\n    case WSAEALREADY:\n      errno = EALREADY;\n      break;\n    case WSAENOTSOCK:\n      errno = ENOTSOCK;\n      break;\n    case WSAEDESTADDRREQ:\n      errno = EDESTADDRREQ;\n      break;\n    case WSAEMSGSIZE:\n      errno = EMSGSIZE;\n      break;\n    case WSAEPROTOTYPE:\n      errno = EPROTOTYPE;\n      break;\n    case WSAENOPROTOOPT:\n      errno = ENOPROTOOPT;\n      break;\n    case WSAEPROTONOSUPPORT:\n      errno = EPROTONOSUPPORT;\n      break;\n    case WSAEOPNOTSUPP:\n      errno = EOPNOTSUPP;\n      break;\n    case WSAEAFNOSUPPORT:\n      errno = EAFNOSUPPORT;\n      break;\n    case WSAEADDRINUSE:\n      errno = EADDRINUSE;\n      break;\n    case WSAEADDRNOTAVAIL:\n      errno = EADDRNOTAVAIL;\n      break;\n    case WSAENETDOWN:\n      errno = ENETDOWN;\n      break;\n    case WSAENETUNREACH:\n      errno = ENETUNREACH;\n      break;\n    case WSAENETRESET:\n      errno = ENETRESET;\n      break;\n    case WSAECONNABORTED:\n      errno = ECONNABORTED;\n      break;\n    case WSAECONNRESET:\n      errno = ECONNRESET;\n      break;\n    case WSAENOBUFS:\n      errno = ENOBUFS;\n      break;\n    case WSAEISCONN:\n      errno = EISCONN;\n      break;\n    case WSAENOTCONN:\n      errno = ENOTCONN;\n      break;\n    case WSAETIMEDOUT:\n      errno = ETIMEDOUT;\n      break;\n    case WSAECONNREFUSED:\n      errno = ECONNREFUSED;\n      break;\n    case WSAELOOP:\n      errno = ELOOP;\n      break;\n    case WSAEHOSTUNREACH:\n      errno = EHOSTUNREACH;\n      break;\n    default:\n      errno = (err > 10000 && err < 10025) ? err - 10000 : err;\n      break;\n    }\n}",
      "lines": 103,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/warn-on-use.h": {},
  "sed/sed-4.5/gnulib-tests/zerosize-ptr.h": {
    "zerosize_ptr": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "static void *\nzerosize_ptr (void)\n{\n/* Use mmap and mprotect when they exist.  Don't test HAVE_MMAP, because it is\n   not defined on HP-UX 11 (since it does not support MAP_FIXED).  */\n#if HAVE_SYS_MMAN_H && HAVE_MPROTECT\n# if HAVE_MAP_ANONYMOUS\n  const int flags = MAP_ANONYMOUS | MAP_PRIVATE;\n  const int fd = -1;\n# else /* !HAVE_MAP_ANONYMOUS */\n  const int flags = MAP_FILE | MAP_PRIVATE;\n  int fd = open (\"/dev/zero\", O_RDONLY, 0666);\n  if (fd >= 0)\n# endif\n    {\n      int pagesize = getpagesize ();\n      char *two_pages =\n        (char *) mmap (NULL, 2 * pagesize, PROT_READ | PROT_WRITE,\n                       flags, fd, 0);\n      if (two_pages != (char *)(-1)\n          && mprotect (two_pages + pagesize, pagesize, PROT_NONE) == 0)\n        return two_pages + pagesize;\n    }\n#endif\n  return NULL;\n}",
      "lines": 26,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nzerosize_ptr (void)",
        "*"
      ]
    }
  },
  "sed/sed-4.5/gnulib-tests/_Noreturn.h": {},
  "sed/sed-4.5/lib/acl-errno-valid.c": {
    "acl_errno_valid": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "bool\nacl_errno_valid (int errnum)\n{\n  /* Recognize some common errors such as from an NFS mount that does\n     not support ACLs, even when local drives do.  */\n  switch (errnum)\n    {\n    case EBUSY: return false;\n    case EINVAL: return false;\n#if defined __APPLE__ && defined __MACH__\n    case ENOENT: return false;\n#endif\n    case ENOSYS: return false;\n\n#if defined ENOTSUP && ENOTSUP != EOPNOTSUPP\n# if ENOTSUP != ENOSYS /* Needed for the MS-Windows port of GNU Emacs.  */\n    case ENOTSUP: return false;\n# endif\n#endif\n\n    case EOPNOTSUPP: return false;\n    default: return true;\n    }\n}",
      "lines": 24,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    }
  },
  "sed/sed-4.5/lib/acl-internal.c": {
    "acl_extended_nontrivial": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "int\nacl_extended_nontrivial (acl_t acl)\n{\n  /* acl is non-trivial if it is non-empty.  */\n  return (acl_entries (acl) > 0);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "acl_access_nontrivial": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        115,
        1
      ],
      "content": "int\nacl_access_nontrivial (acl_t acl)\n{\n  /* acl is non-trivial if it has some entries other than for \"user::\",\n     \"group::\", and \"other::\".  Normally these three should be present\n     at least, allowing us to write\n        return (3 < acl_entries (acl));\n     but the following code is more robust.  */\n#  if HAVE_ACL_FIRST_ENTRY /* Linux, FreeBSD */\n\n  acl_entry_t ace;\n  int got_one;\n\n  for (got_one = acl_get_entry (acl, ACL_FIRST_ENTRY, &ace);\n       got_one > 0;\n       got_one = acl_get_entry (acl, ACL_NEXT_ENTRY, &ace))\n    {\n      acl_tag_t tag;\n      if (acl_get_tag_type (ace, &tag) < 0)\n        return -1;\n      if (!(tag == ACL_USER_OBJ || tag == ACL_GROUP_OBJ || tag == ACL_OTHER))\n        return 1;\n    }\n  return got_one;\n\n#  elif HAVE_ACL_TO_SHORT_TEXT /* IRIX */\n  /* Don't use acl_get_entry: it is undocumented.  */\n\n  int count = acl->acl_cnt;\n  int i;\n\n  for (i = 0; i < count; i++)\n    {\n      acl_entry_t ace = &acl->acl_entry[i];\n      acl_tag_t tag = ace->ae_tag;\n\n      if (!(tag == ACL_USER_OBJ || tag == ACL_GROUP_OBJ\n            || tag == ACL_OTHER_OBJ))\n        return 1;\n    }\n  return 0;\n\n#  elif HAVE_ACL_FREE_TEXT /* Tru64 */\n  /* Don't use acl_get_entry: it takes only one argument and does not work.  */\n\n  int count = acl->acl_num;\n  acl_entry_t ace;\n\n  for (ace = acl->acl_first; count > 0; ace = ace->next, count--)\n    {\n      acl_tag_t tag;\n      acl_perm_t perm;\n\n      tag = ace->entry->acl_type;\n      if (!(tag == ACL_USER_OBJ || tag == ACL_GROUP_OBJ || tag == ACL_OTHER))\n        return 1;\n\n      perm = ace->entry->acl_perm;\n      /* On Tru64, perm can also contain non-standard bits such as\n         PERM_INSERT, PERM_DELETE, PERM_MODIFY, PERM_LOOKUP, ... */\n      if ((perm & ~(ACL_READ | ACL_WRITE | ACL_EXECUTE)) != 0)\n        return 1;\n    }\n  return 0;\n\n#  else\n\n  errno = ENOSYS;\n  return -1;\n#  endif\n}",
      "lines": 71,
      "depth": 17,
      "decorators": [
        "int"
      ]
    },
    "acl_default_nontrivial": {
      "start_point": [
        117,
        0
      ],
      "end_point": [
        122,
        1
      ],
      "content": "int\nacl_default_nontrivial (acl_t acl)\n{\n  /* acl is non-trivial if it is non-empty.  */\n  return (acl_entries (acl) > 0);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "acl_nontrivial": [
      {
        "start_point": [
          131,
          0
        ],
        "end_point": [
          152,
          1
        ],
        "content": "int\nacl_nontrivial (int count, aclent_t *entries)\n{\n  int i;\n\n  for (i = 0; i < count; i++)\n    {\n      aclent_t *ace = &entries[i];\n\n      /* Note: If ace->a_type = USER_OBJ, ace->a_id is the st_uid from stat().\n         If ace->a_type = GROUP_OBJ, ace->a_id is the st_gid from stat().\n         We don't need to check ace->a_id in these cases.  */\n      if (!(ace->a_type == USER_OBJ\n            || ace->a_type == GROUP_OBJ\n            || ace->a_type == OTHER_OBJ\n            /* Note: Cygwin does not return a CLASS_OBJ (\"mask:\") entry\n               sometimes.  */\n            || ace->a_type == CLASS_OBJ))\n        return 1;\n    }\n  return 0;\n}",
        "lines": 22,
        "depth": 14,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          344,
          0
        ],
        "end_point": [
          360,
          1
        ],
        "content": "int\nacl_nontrivial (int count, struct acl_entry *entries)\n{\n  int i;\n\n  if (count > 3)\n    return 1;\n\n  for (i = 0; i < count; i++)\n    {\n      struct acl_entry *ace = &entries[i];\n\n      if (ace->uid != ACL_NSUSER && ace->gid != ACL_NSGROUP)\n\treturn 1;\n    }\n  return 0;\n}",
        "lines": 17,
        "depth": 10,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          393,
          0
        ],
        "end_point": [
          413,
          1
        ],
        "content": "int\nacl_nontrivial (struct acl *a)\n{\n  /* The normal way to iterate through an ACL is like this:\n       struct acl_entry *ace;\n       for (ace = a->acl_ext; ace != acl_last (a); ace = acl_nxt (ace))\n         {\n           struct ace_id *aei;\n           switch (ace->ace_type)\n             {\n             case ACC_PERMIT:\n             case ACC_DENY:\n             case ACC_SPECIFY:\n               ...;\n             }\n           for (aei = ace->ace_id; aei != id_last (ace); aei = id_nxt (aei))\n             ...\n         }\n   */\n  return (acl_last (a) != a->acl_ext ? 1 : 0);\n}",
        "lines": 21,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          454,
          0
        ],
        "end_point": [
          473,
          1
        ],
        "content": "int\nacl_nontrivial (int count, struct acl *entries)\n{\n  int i;\n\n  for (i = 0; i < count; i++)\n    {\n      struct acl *ace = &entries[i];\n\n      /* Note: If ace->a_type = USER_OBJ, ace->a_id is the st_uid from stat().\n         If ace->a_type = GROUP_OBJ, ace->a_id is the st_gid from stat().\n         We don't need to check ace->a_id in these cases.  */\n      if (!(ace->a_type == USER_OBJ /* no need to check ace->a_id here */\n            || ace->a_type == GROUP_OBJ /* no need to check ace->a_id here */\n            || ace->a_type == CLASS_OBJ\n            || ace->a_type == OTHER_OBJ))\n        return 1;\n    }\n  return 0;\n}",
        "lines": 20,
        "depth": 14,
        "decorators": [
          "int"
        ]
      }
    ],
    "acl_ace_nontrivial": {
      "start_point": [
        162,
        0
      ],
      "end_point": [
        336,
        1
      ],
      "content": "int\nacl_ace_nontrivial (int count, ace_t *entries)\n{\n  int i;\n\n  /* The flags in the ace_t structure changed in a binary incompatible way\n     when ACL_NO_TRIVIAL etc. were introduced in <sys/acl.h> version 1.15.\n     How to distinguish the two conventions at runtime?\n     In the old convention, usually three ACEs have a_flags = ACE_OWNER /\n     ACE_GROUP / ACE_OTHER, in the range 0x0100..0x0400.  In the new\n     convention, these values are not used.  */\n  int old_convention = 0;\n\n  for (i = 0; i < count; i++)\n    if (entries[i].a_flags & (OLD_ACE_OWNER | OLD_ACE_GROUP | OLD_ACE_OTHER))\n      {\n        old_convention = 1;\n        break;\n      }\n\n  if (old_convention)\n    /* Running on Solaris 10.  */\n    for (i = 0; i < count; i++)\n      {\n        ace_t *ace = &entries[i];\n\n        /* Note:\n           If ace->a_flags = ACE_OWNER, ace->a_who is the st_uid from stat().\n           If ace->a_flags = ACE_GROUP, ace->a_who is the st_gid from stat().\n           We don't need to check ace->a_who in these cases.  */\n        if (!(ace->a_type == OLD_ALLOW\n              && (ace->a_flags == OLD_ACE_OWNER\n                  || ace->a_flags == OLD_ACE_GROUP\n                  || ace->a_flags == OLD_ACE_OTHER)))\n          return 1;\n      }\n  else\n    {\n      /* Running on Solaris 10 (newer version) or Solaris 11.  */\n      unsigned int access_masks[6] =\n        {\n          0, /* owner@ deny */\n          0, /* owner@ allow */\n          0, /* group@ deny */\n          0, /* group@ allow */\n          0, /* everyone@ deny */\n          0  /* everyone@ allow */\n        };\n\n      for (i = 0; i < count; i++)\n        {\n          ace_t *ace = &entries[i];\n          unsigned int index1;\n          unsigned int index2;\n\n          if (ace->a_type == NEW_ACE_ACCESS_ALLOWED_ACE_TYPE)\n            index1 = 1;\n          else if (ace->a_type == NEW_ACE_ACCESS_DENIED_ACE_TYPE)\n            index1 = 0;\n          else\n            return 1;\n\n          if (ace->a_flags == NEW_ACE_OWNER)\n            index2 = 0;\n          else if (ace->a_flags == (NEW_ACE_GROUP | NEW_ACE_IDENTIFIER_GROUP))\n            index2 = 2;\n          else if (ace->a_flags == NEW_ACE_EVERYONE)\n            index2 = 4;\n          else\n            return 1;\n\n          access_masks[index1 + index2] |= ace->a_access_mask;\n        }\n\n      /* The same bit shouldn't be both allowed and denied.  */\n      if (access_masks[0] & access_masks[1])\n        return 1;\n      if (access_masks[2] & access_masks[3])\n        return 1;\n      if (access_masks[4] & access_masks[5])\n        return 1;\n\n      /* Check minimum masks.  */\n      if ((NEW_ACE_WRITE_NAMED_ATTRS\n           | NEW_ACE_WRITE_ATTRIBUTES\n           | NEW_ACE_WRITE_ACL\n           | NEW_ACE_WRITE_OWNER)\n          & ~ access_masks[1])\n        return 1;\n      access_masks[1] &= ~(NEW_ACE_WRITE_NAMED_ATTRS\n                           | NEW_ACE_WRITE_ATTRIBUTES\n                           | NEW_ACE_WRITE_ACL\n                           | NEW_ACE_WRITE_OWNER);\n      if ((NEW_ACE_READ_NAMED_ATTRS\n           | NEW_ACE_READ_ATTRIBUTES\n           | NEW_ACE_READ_ACL\n           | NEW_ACE_SYNCHRONIZE)\n          & ~ access_masks[5])\n        return 1;\n      access_masks[5] &= ~(NEW_ACE_READ_NAMED_ATTRS\n                           | NEW_ACE_READ_ATTRIBUTES\n                           | NEW_ACE_READ_ACL\n                           | NEW_ACE_SYNCHRONIZE);\n\n      /* Check the allowed or denied bits.  */\n      switch ((access_masks[0] | access_masks[1])\n              & ~(NEW_ACE_READ_NAMED_ATTRS\n                  | NEW_ACE_READ_ATTRIBUTES\n                  | NEW_ACE_READ_ACL\n                  | NEW_ACE_SYNCHRONIZE))\n        {\n        case 0:\n        case NEW_ACE_READ_DATA:\n        case                     NEW_ACE_WRITEA_DATA:\n        case NEW_ACE_READ_DATA | NEW_ACE_WRITEA_DATA:\n        case                                           NEW_ACE_EXECUTE:\n        case NEW_ACE_READ_DATA |                       NEW_ACE_EXECUTE:\n        case                     NEW_ACE_WRITEA_DATA | NEW_ACE_EXECUTE:\n        case NEW_ACE_READ_DATA | NEW_ACE_WRITEA_DATA | NEW_ACE_EXECUTE:\n          break;\n        default:\n          return 1;\n        }\n      switch ((access_masks[2] | access_masks[3])\n              & ~(NEW_ACE_READ_NAMED_ATTRS\n                  | NEW_ACE_READ_ATTRIBUTES\n                  | NEW_ACE_READ_ACL\n                  | NEW_ACE_SYNCHRONIZE))\n        {\n        case 0:\n        case NEW_ACE_READ_DATA:\n        case                     NEW_ACE_WRITEA_DATA:\n        case NEW_ACE_READ_DATA | NEW_ACE_WRITEA_DATA:\n        case                                           NEW_ACE_EXECUTE:\n        case NEW_ACE_READ_DATA |                       NEW_ACE_EXECUTE:\n        case                     NEW_ACE_WRITEA_DATA | NEW_ACE_EXECUTE:\n        case NEW_ACE_READ_DATA | NEW_ACE_WRITEA_DATA | NEW_ACE_EXECUTE:\n          break;\n        default:\n          return 1;\n        }\n      switch ((access_masks[4] | access_masks[5])\n              & ~(NEW_ACE_WRITE_NAMED_ATTRS\n                  | NEW_ACE_WRITE_ATTRIBUTES\n                  | NEW_ACE_WRITE_ACL\n                  | NEW_ACE_WRITE_OWNER))\n        {\n        case 0:\n        case NEW_ACE_READ_DATA:\n        case                     NEW_ACE_WRITEA_DATA:\n        case NEW_ACE_READ_DATA | NEW_ACE_WRITEA_DATA:\n        case                                           NEW_ACE_EXECUTE:\n        case NEW_ACE_READ_DATA |                       NEW_ACE_EXECUTE:\n        case                     NEW_ACE_WRITEA_DATA | NEW_ACE_EXECUTE:\n        case NEW_ACE_READ_DATA | NEW_ACE_WRITEA_DATA | NEW_ACE_EXECUTE:\n          break;\n        default:\n          return 1;\n        }\n\n      /* Check that the NEW_ACE_WRITE_DATA and NEW_ACE_APPEND_DATA bits are\n         either both allowed or both denied.  */\n      if (((access_masks[0] & NEW_ACE_WRITE_DATA) != 0)\n          != ((access_masks[0] & NEW_ACE_APPEND_DATA) != 0))\n        return 1;\n      if (((access_masks[2] & NEW_ACE_WRITE_DATA) != 0)\n          != ((access_masks[2] & NEW_ACE_APPEND_DATA) != 0))\n        return 1;\n      if (((access_masks[4] & NEW_ACE_WRITE_DATA) != 0)\n          != ((access_masks[4] & NEW_ACE_APPEND_DATA) != 0))\n        return 1;\n    }\n\n  return 0;\n}",
      "lines": 175,
      "depth": 16,
      "decorators": [
        "int"
      ]
    },
    "aclv_nontrivial": {
      "start_point": [
        366,
        0
      ],
      "end_point": [
        385,
        1
      ],
      "content": "int\naclv_nontrivial (int count, struct acl *entries)\n{\n  int i;\n\n  for (i = 0; i < count; i++)\n    {\n      struct acl *ace = &entries[i];\n\n      /* Note: If ace->a_type = USER_OBJ, ace->a_id is the st_uid from stat().\n         If ace->a_type = GROUP_OBJ, ace->a_id is the st_gid from stat().\n         We don't need to check ace->a_id in these cases.  */\n      if (!(ace->a_type == USER_OBJ /* no need to check ace->a_id here */\n            || ace->a_type == GROUP_OBJ /* no need to check ace->a_id here */\n            || ace->a_type == CLASS_OBJ\n            || ace->a_type == OTHER_OBJ))\n        return 1;\n    }\n  return 0;\n}",
      "lines": 20,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "acl_nfs4_nontrivial": {
      "start_point": [
        419,
        0
      ],
      "end_point": [
        445,
        1
      ],
      "content": "int\nacl_nfs4_nontrivial (nfs4_acl_int_t *a)\n{\n#  if 1 /* let's try this first */\n  return (a->aclEntryN > 0 ? 1 : 0);\n#  else\n  int count = a->aclEntryN;\n  int i;\n\n  for (i = 0; i < count; i++)\n    {\n      nfs4_ace_int_t *ace = &a->aclEntry[i];\n\n      if (!((ace->flags & ACE4_ID_SPECIAL) != 0\n            && (ace->aceWho.special_whoid == ACE4_WHO_OWNER\n                || ace->aceWho.special_whoid == ACE4_WHO_GROUP\n                || ace->aceWho.special_whoid == ACE4_WHO_EVERYONE)\n            && ace->aceType == ACE4_ACCESS_ALLOWED_ACE_TYPE\n            && ace->aceFlags == 0\n            && (ace->aceMask & ~(ACE4_READ_DATA | ACE4_LIST_DIRECTORY\n                                 | ACE4_WRITE_DATA | ACE4_ADD_FILE\n                                 | ACE4_EXECUTE)) == 0))\n        return 1;\n    }\n  return 0;\n#  endif\n}",
      "lines": 27,
      "depth": 21,
      "decorators": [
        "int"
      ]
    },
    "free_permission_context": {
      "start_point": [
        477,
        0
      ],
      "end_point": [
        506,
        1
      ],
      "content": "void\nfree_permission_context (struct permission_context *ctx)\n{\n#if USE_ACL\n# if HAVE_ACL_GET_FILE /* Linux, FreeBSD, Mac OS X, IRIX, Tru64 */\n  if (ctx->acl)\n    acl_free (ctx->acl);\n#  if !HAVE_ACL_TYPE_EXTENDED\n  if (ctx->default_acl)\n    acl_free (ctx->default_acl);\n#  endif\n\n# elif defined GETACL /* Solaris, Cygwin */\n  free (ctx->entries);\n#  ifdef ACE_GETACL\n  free (ctx->ace_entries);\n#  endif\n\n# elif HAVE_GETACL /* HP-UX */\n\n#  if HAVE_ACLV_H\n#  endif\n\n# elif HAVE_STATACL /* older AIX */\n\n# elif HAVE_ACLSORT /* NonStop Kernel */\n\n# endif\n#endif\n}",
      "lines": 30,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "sed/sed-4.5/lib/acl-internal.h": {
    "rpl_acl_get_fd": {
      "start_point": [
        85,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "ACL_INTERNAL_INLINE acl_t\nrpl_acl_get_fd (int fd)\n{\n  return acl_get_fd (fd, ACL_TYPE_ACCESS);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "ACL_INTERNAL_INLINE",
        "acl_t",
        "acl_t"
      ]
    },
    "rpl_acl_set_fd": {
      "start_point": [
        104,
        0
      ],
      "end_point": [
        108,
        1
      ],
      "content": "ACL_INTERNAL_INLINE int\nrpl_acl_set_fd (int fd, acl_t acl)\n{\n  return acl_set_fd (fd, ACL_TYPE_ACCESS, acl);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "ACL_INTERNAL_INLINE",
        "int",
        "int"
      ]
    }
  },
  "sed/sed-4.5/lib/acl.h": {},
  "sed/sed-4.5/lib/acl_entries.c": {
    "acl_entries": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "int\nacl_entries (acl_t acl)\n{\n  int count = 0;\n\n  if (acl != NULL)\n    {\n#if HAVE_ACL_FIRST_ENTRY /* Linux, FreeBSD, Mac OS X */\n# if HAVE_ACL_TYPE_EXTENDED /* Mac OS X */\n      /* acl_get_entry returns 0 when it successfully fetches an entry,\n         and -1/EINVAL at the end.  */\n      acl_entry_t ace;\n      int got_one;\n\n      for (got_one = acl_get_entry (acl, ACL_FIRST_ENTRY, &ace);\n           got_one >= 0;\n           got_one = acl_get_entry (acl, ACL_NEXT_ENTRY, &ace))\n        count++;\n# else /* Linux, FreeBSD */\n      /* acl_get_entry returns 1 when it successfully fetches an entry,\n         and 0 at the end.  */\n      acl_entry_t ace;\n      int got_one;\n\n      for (got_one = acl_get_entry (acl, ACL_FIRST_ENTRY, &ace);\n           got_one > 0;\n           got_one = acl_get_entry (acl, ACL_NEXT_ENTRY, &ace))\n        count++;\n      if (got_one < 0)\n        return -1;\n# endif\n#else /* IRIX, Tru64 */\n# if HAVE_ACL_TO_SHORT_TEXT /* IRIX */\n      /* Don't use acl_get_entry: it is undocumented.  */\n      count = acl->acl_cnt;\n# endif\n# if HAVE_ACL_FREE_TEXT /* Tru64 */\n      /* Don't use acl_get_entry: it takes only one argument and does not\n         work.  */\n      count = acl->acl_num;\n# endif\n#endif\n    }\n\n  return count;\n}",
      "lines": 46,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/lib/alignof.h": {},
  "sed/sed-4.5/lib/alloca.c": {
    "find_stack_direction": {
      "start_point": [
        95,
        0
      ],
      "end_point": [
        104,
        1
      ],
      "content": "static int\nfind_stack_direction (int *addr, int depth)\n{\n  int dir, dummy = 0;\n  if (! addr)\n    addr = &dummy;\n  *addr = addr < &dummy ? 1 : addr == &dummy ? 0 : -1;\n  dir = depth ? find_stack_direction (addr, depth - 1) : 0;\n  return dir + dummy;\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "alloca": {
      "start_point": [
        138,
        0
      ],
      "end_point": [
        206,
        1
      ],
      "content": "void *\nalloca (size_t size)\n{\n  auto char probe;              /* Probes stack depth: */\n  register char *depth = ADDRESS_FUNCTION (probe);\n\n#  if STACK_DIRECTION == 0\n  if (STACK_DIR == 0)           /* Unknown growth direction.  */\n    STACK_DIR = find_stack_direction (NULL, (size & 1) + 20);\n#  endif\n\n  /* Reclaim garbage, defined as all alloca'd storage that\n     was allocated from deeper in the stack than currently.  */\n\n  {\n    register header *hp;        /* Traverses linked list.  */\n\n#  ifdef emacs\n    BLOCK_INPUT;\n#  endif\n\n    for (hp = last_alloca_header; hp != NULL;)\n      if ((STACK_DIR > 0 && hp->h.deep > depth)\n          || (STACK_DIR < 0 && hp->h.deep < depth))\n        {\n          register header *np = hp->h.next;\n\n          free (hp);            /* Collect garbage.  */\n\n          hp = np;              /* -> next header.  */\n        }\n      else\n        break;                  /* Rest are not deeper.  */\n\n    last_alloca_header = hp;    /* -> last valid storage.  */\n\n#  ifdef emacs\n    UNBLOCK_INPUT;\n#  endif\n  }\n\n  if (size == 0)\n    return NULL;                /* No allocation required.  */\n\n  /* Allocate combined header + user data storage.  */\n\n  {\n    /* Address of header.  */\n    register header *new;\n\n    size_t combined_size = sizeof (header) + size;\n    if (combined_size < sizeof (header))\n      memory_full ();\n\n    new = malloc (combined_size);\n\n    if (! new)\n      memory_full ();\n\n    new->h.next = last_alloca_header;\n    new->h.deep = depth;\n\n    last_alloca_header = new;\n\n    /* User storage begins just after header.  */\n\n    return (void *) (new + 1);\n  }\n}",
      "lines": 69,
      "depth": 13,
      "decorators": [
        "void",
        "*\nalloca (size_t size)",
        "*"
      ]
    },
    "i00afunc": [
      {
        "start_point": [
          328,
          0
        ],
        "end_point": [
          393,
          1
        ],
        "content": "static long\ni00afunc (long *address)\n{\n  struct stk_stat status;\n  struct stk_trailer *trailer;\n  long *block, size;\n  long result = 0;\n\n  /* We want to iterate through all of the segments.  The first\n     step is to get the stack status structure.  We could do this\n     more quickly and more directly, perhaps, by referencing the\n     $LM00 common block, but I know that this works.  */\n\n  STKSTAT (&status);\n\n  /* Set up the iteration.  */\n\n  trailer = (struct stk_trailer *) (status.current_address\n                                    + status.current_size\n                                    - 15);\n\n  /* There must be at least one stack segment.  Therefore it is\n     a fatal error if \"trailer\" is null.  */\n\n  if (trailer == 0)\n    abort ();\n\n  /* Discard segments that do not contain our argument address.  */\n\n  while (trailer != 0)\n    {\n      block = (long *) trailer->this_address;\n      size = trailer->this_size;\n      if (block == 0 || size == 0)\n        abort ();\n      trailer = (struct stk_trailer *) trailer->link;\n      if ((block <= address) && (address < (block + size)))\n        break;\n    }\n\n  /* Set the result to the offset in this segment and add the sizes\n     of all predecessor segments.  */\n\n  result = address - block;\n\n  if (trailer == 0)\n    {\n      return result;\n    }\n\n  do\n    {\n      if (trailer->this_size <= 0)\n        abort ();\n      result += trailer->this_size;\n      trailer = (struct stk_trailer *) trailer->link;\n    }\n  while (trailer != 0);\n\n  /* We are done.  Note that if you present a bogus address (one\n     not in any segment), you will get a different number back, formed\n     from subtracting the address of the first block.  This is probably\n     not what you want.  */\n\n  return (result);\n}",
        "lines": 66,
        "depth": 12,
        "decorators": [
          "static",
          "static",
          "long",
          "long"
        ]
      },
      {
        "start_point": [
          402,
          0
        ],
        "end_point": [
          471,
          1
        ],
        "content": "static long\ni00afunc (long address)\n{\n  long stkl = 0;\n\n  long size, pseg, this_segment, stack;\n  long result = 0;\n\n  struct stack_segment_linkage *ssptr;\n\n  /* Register B67 contains the address of the end of the\n     current stack segment.  If you (as a subprogram) store\n     your registers on the stack and find that you are past\n     the contents of B67, you have overflowed the segment.\n\n     B67 also points to the stack segment linkage control\n     area, which is what we are really interested in.  */\n\n  stkl = CRAY_STACKSEG_END ();\n  ssptr = (struct stack_segment_linkage *) stkl;\n\n  /* If one subtracts 'size' from the end of the segment,\n     one has the address of the first word of the segment.\n\n     If this is not the first segment, 'pseg' will be\n     nonzero.  */\n\n  pseg = ssptr->sspseg;\n  size = ssptr->sssize;\n\n  this_segment = stkl - size;\n\n  /* It is possible that calling this routine itself caused\n     a stack overflow.  Discard stack segments which do not\n     contain the target address.  */\n\n  while (!(this_segment <= address && address <= stkl))\n    {\n#    ifdef DEBUG_I00AFUNC\n      fprintf (stderr, \"%011o %011o %011o\\n\", this_segment, address, stkl);\n#    endif\n      if (pseg == 0)\n        break;\n      stkl = stkl - pseg;\n      ssptr = (struct stack_segment_linkage *) stkl;\n      size = ssptr->sssize;\n      pseg = ssptr->sspseg;\n      this_segment = stkl - size;\n    }\n\n  result = address - this_segment;\n\n  /* If you subtract pseg from the current end of the stack,\n     you get the address of the previous stack segment's end.\n     This seems a little convoluted to me, but I'll bet you save\n     a cycle somewhere.  */\n\n  while (pseg != 0)\n    {\n#    ifdef DEBUG_I00AFUNC\n      fprintf (stderr, \"%011o %011o\\n\", pseg, size);\n#    endif\n      stkl = stkl - pseg;\n      ssptr = (struct stack_segment_linkage *) stkl;\n      size = ssptr->sssize;\n      pseg = ssptr->sspseg;\n      result += size;\n    }\n  return (result);\n}",
        "lines": 70,
        "depth": 10,
        "decorators": [
          "static",
          "static",
          "long",
          "long"
        ]
      }
    ]
  },
  "sed/sed-4.5/lib/alloca.in.h": {},
  "sed/sed-4.5/lib/arg-nonnull.h": {},
  "sed/sed-4.5/lib/basename-lgpl.c": {
    "last_component": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "char *\nlast_component (char const *name)\n{\n  char const *base = name + FILE_SYSTEM_PREFIX_LEN (name);\n  char const *p;\n  bool saw_slash = false;\n\n  while (ISSLASH (*base))\n    base++;\n\n  for (p = base; *p; p++)\n    {\n      if (ISSLASH (*p))\n        saw_slash = true;\n      else if (saw_slash)\n        {\n          base = p;\n          saw_slash = false;\n        }\n    }\n\n  return (char *) base;\n}",
      "lines": 23,
      "depth": 10,
      "decorators": [
        "char",
        "*\nlast_component (char const *name)",
        "*"
      ]
    },
    "base_len": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "size_t\nbase_len (char const *name)\n{\n  size_t len;\n  size_t prefix_len = FILE_SYSTEM_PREFIX_LEN (name);\n\n  for (len = strlen (name);  1 < len && ISSLASH (name[len - 1]);  len--)\n    continue;\n\n  if (DOUBLE_SLASH_IS_DISTINCT_ROOT && len == 1\n      && ISSLASH (name[0]) && ISSLASH (name[1]) && ! name[2])\n    return 2;\n\n  if (FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE && prefix_len\n      && len == prefix_len && ISSLASH (name[prefix_len]))\n    return prefix_len + 1;\n\n  return len;\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "size_t"
      ]
    }
  },
  "sed/sed-4.5/lib/btowc.c": {
    "btowc": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "wint_t\nbtowc (int c)\n{\n  if (c != EOF)\n    {\n      char buf[1];\n      wchar_t wc;\n\n      buf[0] = c;\n      if (mbtowc (&wc, buf, 1) >= 0)\n        return wc;\n    }\n  return WEOF;\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "wint_t"
      ]
    }
  },
  "sed/sed-4.5/lib/c++defs.h": {},
  "sed/sed-4.5/lib/c-ctype.c": {},
  "sed/sed-4.5/lib/c-ctype.h": {
    "c_isalnum": {
      "start_point": [
        167,
        0
      ],
      "end_point": [
        179,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_isalnum (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_DIGIT:\n    _C_CTYPE_LOWER:\n    _C_CTYPE_UPPER:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_isalpha": {
      "start_point": [
        181,
        0
      ],
      "end_point": [
        192,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_isalpha (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_LOWER:\n    _C_CTYPE_UPPER:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_isascii": {
      "start_point": [
        196,
        0
      ],
      "end_point": [
        211,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_isascii (int c)\n{\n  switch (c)\n    {\n    case ' ':\n    _C_CTYPE_CNTRL:\n    _C_CTYPE_DIGIT:\n    _C_CTYPE_LOWER:\n    _C_CTYPE_PUNCT:\n    _C_CTYPE_UPPER:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 16,
      "depth": 12,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_isblank": {
      "start_point": [
        213,
        0
      ],
      "end_point": [
        217,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_isblank (int c)\n{\n  return c == ' ' || c == '\\t';\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_iscntrl": {
      "start_point": [
        219,
        0
      ],
      "end_point": [
        229,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_iscntrl (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_CNTRL:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_isdigit": {
      "start_point": [
        231,
        0
      ],
      "end_point": [
        241,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_isdigit (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_DIGIT:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_isgraph": {
      "start_point": [
        243,
        0
      ],
      "end_point": [
        256,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_isgraph (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_DIGIT:\n    _C_CTYPE_LOWER:\n    _C_CTYPE_PUNCT:\n    _C_CTYPE_UPPER:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_islower": {
      "start_point": [
        258,
        0
      ],
      "end_point": [
        268,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_islower (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_LOWER:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_isprint": {
      "start_point": [
        270,
        0
      ],
      "end_point": [
        284,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_isprint (int c)\n{\n  switch (c)\n    {\n    case ' ':\n    _C_CTYPE_DIGIT:\n    _C_CTYPE_LOWER:\n    _C_CTYPE_PUNCT:\n    _C_CTYPE_UPPER:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_ispunct": {
      "start_point": [
        286,
        0
      ],
      "end_point": [
        296,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_ispunct (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_PUNCT:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_isspace": {
      "start_point": [
        298,
        0
      ],
      "end_point": [
        308,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_isspace (int c)\n{\n  switch (c)\n    {\n    case ' ': case '\\t': case '\\n': case '\\v': case '\\f': case '\\r':\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_isupper": {
      "start_point": [
        310,
        0
      ],
      "end_point": [
        320,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_isupper (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_UPPER:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_isxdigit": {
      "start_point": [
        322,
        0
      ],
      "end_point": [
        333,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_isxdigit (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_DIGIT:\n    _C_CTYPE_A_THRU_F:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_tolower": {
      "start_point": [
        335,
        0
      ],
      "end_point": [
        345,
        1
      ],
      "content": "C_CTYPE_INLINE int\nc_tolower (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_UPPER:\n      return c - 'A' + 'a';\n    default:\n      return c;\n    }\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "C_CTYPE_INLINE",
        "int",
        "int"
      ]
    },
    "c_toupper": {
      "start_point": [
        347,
        0
      ],
      "end_point": [
        357,
        1
      ],
      "content": "C_CTYPE_INLINE int\nc_toupper (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_LOWER:\n      return c - 'a' + 'A';\n    default:\n      return c;\n    }\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "C_CTYPE_INLINE",
        "int",
        "int"
      ]
    }
  },
  "sed/sed-4.5/lib/c-strcase.h": {},
  "sed/sed-4.5/lib/c-strcasecmp.c": {
    "c_strcasecmp": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "int\nc_strcasecmp (const char *s1, const char *s2)\n{\n  register const unsigned char *p1 = (const unsigned char *) s1;\n  register const unsigned char *p2 = (const unsigned char *) s2;\n  unsigned char c1, c2;\n\n  if (p1 == p2)\n    return 0;\n\n  do\n    {\n      c1 = c_tolower (*p1);\n      c2 = c_tolower (*p2);\n\n      if (c1 == '\\0')\n        break;\n\n      ++p1;\n      ++p2;\n    }\n  while (c1 == c2);\n\n  if (UCHAR_MAX <= INT_MAX)\n    return c1 - c2;\n  else\n    /* On machines where 'char' and 'int' are types of the same size, the\n       difference of two 'unsigned char' values - including the sign bit -\n       doesn't fit in an 'int'.  */\n    return (c1 > c2 ? 1 : c1 < c2 ? -1 : 0);\n}",
      "lines": 31,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/lib/c-strcaseeq.h": {
    "strcaseeq9": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "static inline int\nstrcaseeq9 (const char *s1, const char *s2)\n{\n  return c_strcasecmp (s1 + 9, s2 + 9) == 0;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq8": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "static inline int\nstrcaseeq8 (const char *s1, const char *s2, char s28)\n{\n  if (CASEEQ (s1[8], s28))\n    {\n      if (s28 == 0)\n        return 1;\n      else\n        return strcaseeq9 (s1, s2);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq7": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "static inline int\nstrcaseeq7 (const char *s1, const char *s2, char s27, char s28)\n{\n  if (CASEEQ (s1[7], s27))\n    {\n      if (s27 == 0)\n        return 1;\n      else\n        return strcaseeq8 (s1, s2, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq6": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "static inline int\nstrcaseeq6 (const char *s1, const char *s2, char s26, char s27, char s28)\n{\n  if (CASEEQ (s1[6], s26))\n    {\n      if (s26 == 0)\n        return 1;\n      else\n        return strcaseeq7 (s1, s2, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq5": {
      "start_point": [
        88,
        0
      ],
      "end_point": [
        100,
        1
      ],
      "content": "static inline int\nstrcaseeq5 (const char *s1, const char *s2, char s25, char s26, char s27, char s28)\n{\n  if (CASEEQ (s1[5], s25))\n    {\n      if (s25 == 0)\n        return 1;\n      else\n        return strcaseeq6 (s1, s2, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq4": {
      "start_point": [
        102,
        0
      ],
      "end_point": [
        114,
        1
      ],
      "content": "static inline int\nstrcaseeq4 (const char *s1, const char *s2, char s24, char s25, char s26, char s27, char s28)\n{\n  if (CASEEQ (s1[4], s24))\n    {\n      if (s24 == 0)\n        return 1;\n      else\n        return strcaseeq5 (s1, s2, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq3": {
      "start_point": [
        116,
        0
      ],
      "end_point": [
        128,
        1
      ],
      "content": "static inline int\nstrcaseeq3 (const char *s1, const char *s2, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (CASEEQ (s1[3], s23))\n    {\n      if (s23 == 0)\n        return 1;\n      else\n        return strcaseeq4 (s1, s2, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq2": {
      "start_point": [
        130,
        0
      ],
      "end_point": [
        142,
        1
      ],
      "content": "static inline int\nstrcaseeq2 (const char *s1, const char *s2, char s22, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (CASEEQ (s1[2], s22))\n    {\n      if (s22 == 0)\n        return 1;\n      else\n        return strcaseeq3 (s1, s2, s23, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq1": {
      "start_point": [
        144,
        0
      ],
      "end_point": [
        156,
        1
      ],
      "content": "static inline int\nstrcaseeq1 (const char *s1, const char *s2, char s21, char s22, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (CASEEQ (s1[1], s21))\n    {\n      if (s21 == 0)\n        return 1;\n      else\n        return strcaseeq2 (s1, s2, s22, s23, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq0": {
      "start_point": [
        158,
        0
      ],
      "end_point": [
        170,
        1
      ],
      "content": "static inline int\nstrcaseeq0 (const char *s1, const char *s2, char s20, char s21, char s22, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (CASEEQ (s1[0], s20))\n    {\n      if (s20 == 0)\n        return 1;\n      else\n        return strcaseeq1 (s1, s2, s21, s22, s23, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    }
  },
  "sed/sed-4.5/lib/c-strncasecmp.c": {
    "c_strncasecmp": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "int\nc_strncasecmp (const char *s1, const char *s2, size_t n)\n{\n  register const unsigned char *p1 = (const unsigned char *) s1;\n  register const unsigned char *p2 = (const unsigned char *) s2;\n  unsigned char c1, c2;\n\n  if (p1 == p2 || n == 0)\n    return 0;\n\n  do\n    {\n      c1 = c_tolower (*p1);\n      c2 = c_tolower (*p2);\n\n      if (--n == 0 || c1 == '\\0')\n        break;\n\n      ++p1;\n      ++p2;\n    }\n  while (c1 == c2);\n\n  if (UCHAR_MAX <= INT_MAX)\n    return c1 - c2;\n  else\n    /* On machines where 'char' and 'int' are types of the same size, the\n       difference of two 'unsigned char' values - including the sign bit -\n       doesn't fit in an 'int'.  */\n    return (c1 > c2 ? 1 : c1 < c2 ? -1 : 0);\n}",
      "lines": 31,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/lib/canonicalize-lgpl.c": {
    "alloc_failed": {
      "start_point": [
        94,
        0
      ],
      "end_point": [
        102,
        1
      ],
      "content": "static void\nalloc_failed (void)\n{\n#if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n  /* Avoid errno problem without using the malloc or realloc modules; see:\n     https://lists.gnu.org/r/bug-gnulib/2016-08/msg00025.html  */\n  errno = ENOMEM;\n#endif\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "__realpath": {
      "start_point": [
        115,
        0
      ],
      "end_point": [
        392,
        1
      ],
      "content": "char *\n__realpath (const char *name, char *resolved)\n{\n  char *rpath, *dest, *extra_buf = NULL;\n  const char *start, *end, *rpath_limit;\n  long int path_max;\n  int num_links = 0;\n  size_t prefix_len;\n\n  if (name == NULL)\n    {\n      /* As per Single Unix Specification V2 we must return an error if\n         either parameter is a null pointer.  We extend this to allow\n         the RESOLVED parameter to be NULL in case the we are expected to\n         allocate the room for the return value.  */\n      __set_errno (EINVAL);\n      return NULL;\n    }\n\n  if (name[0] == '\\0')\n    {\n      /* As per Single Unix Specification V2 we must return an error if\n         the name argument points to an empty string.  */\n      __set_errno (ENOENT);\n      return NULL;\n    }\n\n#ifdef PATH_MAX\n  path_max = PATH_MAX;\n#else\n  path_max = pathconf (name, _PC_PATH_MAX);\n  if (path_max <= 0)\n    path_max = 8192;\n#endif\n\n  if (resolved == NULL)\n    {\n      rpath = malloc (path_max);\n      if (rpath == NULL)\n        {\n          alloc_failed ();\n          return NULL;\n        }\n    }\n  else\n    rpath = resolved;\n  rpath_limit = rpath + path_max;\n\n  /* This is always zero for Posix hosts, but can be 2 for MS-Windows\n     and MS-DOS X:/foo/bar file names.  */\n  prefix_len = FILE_SYSTEM_PREFIX_LEN (name);\n\n  if (!IS_ABSOLUTE_FILE_NAME (name))\n    {\n      if (!__getcwd (rpath, path_max))\n        {\n          rpath[0] = '\\0';\n          goto error;\n        }\n      dest = strchr (rpath, '\\0');\n      start = name;\n      prefix_len = FILE_SYSTEM_PREFIX_LEN (rpath);\n    }\n  else\n    {\n      dest = rpath;\n      if (prefix_len)\n        {\n          memcpy (rpath, name, prefix_len);\n          dest += prefix_len;\n        }\n      *dest++ = '/';\n      if (DOUBLE_SLASH_IS_DISTINCT_ROOT)\n        {\n          if (ISSLASH (name[1]) && !ISSLASH (name[2]) && !prefix_len)\n            *dest++ = '/';\n          *dest = '\\0';\n        }\n      start = name + prefix_len;\n    }\n\n  for (end = start; *start; start = end)\n    {\n#ifdef _LIBC\n      struct stat64 st;\n#else\n      struct stat st;\n#endif\n\n      /* Skip sequence of multiple path-separators.  */\n      while (ISSLASH (*start))\n        ++start;\n\n      /* Find end of path component.  */\n      for (end = start; *end && !ISSLASH (*end); ++end)\n        /* Nothing.  */;\n\n      if (end - start == 0)\n        break;\n      else if (end - start == 1 && start[0] == '.')\n        /* nothing */;\n      else if (end - start == 2 && start[0] == '.' && start[1] == '.')\n        {\n          /* Back up to previous component, ignore if at root already.  */\n          if (dest > rpath + prefix_len + 1)\n            for (--dest; dest > rpath && !ISSLASH (dest[-1]); --dest)\n              continue;\n          if (DOUBLE_SLASH_IS_DISTINCT_ROOT\n              && dest == rpath + 1 && !prefix_len\n              && ISSLASH (*dest) && !ISSLASH (dest[1]))\n            dest++;\n        }\n      else\n        {\n          size_t new_size;\n\n          if (!ISSLASH (dest[-1]))\n            *dest++ = '/';\n\n          if (dest + (end - start) >= rpath_limit)\n            {\n              ptrdiff_t dest_offset = dest - rpath;\n              char *new_rpath;\n\n              if (resolved)\n                {\n                  __set_errno (ENAMETOOLONG);\n                  if (dest > rpath + prefix_len + 1)\n                    dest--;\n                  *dest = '\\0';\n                  goto error;\n                }\n              new_size = rpath_limit - rpath;\n              if (end - start + 1 > path_max)\n                new_size += end - start + 1;\n              else\n                new_size += path_max;\n              new_rpath = (char *) realloc (rpath, new_size);\n              if (new_rpath == NULL)\n                {\n                  alloc_failed ();\n                  goto error;\n                }\n              rpath = new_rpath;\n              rpath_limit = rpath + new_size;\n\n              dest = rpath + dest_offset;\n            }\n\n#ifdef _LIBC\n          dest = __mempcpy (dest, start, end - start);\n#else\n          memcpy (dest, start, end - start);\n          dest += end - start;\n#endif\n          *dest = '\\0';\n\n          /* FIXME: if lstat fails with errno == EOVERFLOW,\n             the entry exists.  */\n#ifdef _LIBC\n          if (__lxstat64 (_STAT_VER, rpath, &st) < 0)\n#else\n          if (lstat (rpath, &st) < 0)\n#endif\n            goto error;\n\n          if (S_ISLNK (st.st_mode))\n            {\n              char *buf;\n              size_t len;\n              ssize_t n;\n\n              if (++num_links > MAXSYMLINKS)\n                {\n                  __set_errno (ELOOP);\n                  goto error;\n                }\n\n              buf = malloca (path_max);\n              if (!buf)\n                {\n                  __set_errno (ENOMEM);\n                  goto error;\n                }\n\n              n = __readlink (rpath, buf, path_max - 1);\n              if (n < 0)\n                {\n                  int saved_errno = errno;\n                  freea (buf);\n                  __set_errno (saved_errno);\n                  goto error;\n                }\n              buf[n] = '\\0';\n\n              if (!extra_buf)\n                {\n                  extra_buf = malloca (path_max);\n                  if (!extra_buf)\n                    {\n                      freea (buf);\n                      __set_errno (ENOMEM);\n                      goto error;\n                    }\n                }\n\n              len = strlen (end);\n              /* Check that n + len + 1 doesn't overflow and is <= path_max. */\n              if (n >= SIZE_MAX - len || n + len >= path_max)\n                {\n                  freea (buf);\n                  __set_errno (ENAMETOOLONG);\n                  goto error;\n                }\n\n              /* Careful here, end may be a pointer into extra_buf... */\n              memmove (&extra_buf[n], end, len + 1);\n              name = end = memcpy (extra_buf, buf, n);\n\n              if (IS_ABSOLUTE_FILE_NAME (buf))\n                {\n                  size_t pfxlen = FILE_SYSTEM_PREFIX_LEN (buf);\n\n                  if (pfxlen)\n                    memcpy (rpath, buf, pfxlen);\n                  dest = rpath + pfxlen;\n                  *dest++ = '/'; /* It's an absolute symlink */\n                  if (DOUBLE_SLASH_IS_DISTINCT_ROOT)\n                    {\n                      if (ISSLASH (buf[1]) && !ISSLASH (buf[2]) && !pfxlen)\n                        *dest++ = '/';\n                      *dest = '\\0';\n                    }\n                  /* Install the new prefix to be in effect hereafter.  */\n                  prefix_len = pfxlen;\n                }\n              else\n                {\n                  /* Back up to previous component, ignore if at root\n                     already: */\n                  if (dest > rpath + prefix_len + 1)\n                    for (--dest; dest > rpath && !ISSLASH (dest[-1]); --dest)\n                      continue;\n                  if (DOUBLE_SLASH_IS_DISTINCT_ROOT && dest == rpath + 1\n                      && ISSLASH (*dest) && !ISSLASH (dest[1]) && !prefix_len)\n                    dest++;\n                }\n            }\n          else if (!S_ISDIR (st.st_mode) && *end != '\\0')\n            {\n              __set_errno (ENOTDIR);\n              goto error;\n            }\n        }\n    }\n  if (dest > rpath + prefix_len + 1 && ISSLASH (dest[-1]))\n    --dest;\n  if (DOUBLE_SLASH_IS_DISTINCT_ROOT && dest == rpath + 1 && !prefix_len\n      && ISSLASH (*dest) && !ISSLASH (dest[1]))\n    dest++;\n  *dest = '\\0';\n\n  if (extra_buf)\n    freea (extra_buf);\n\n  return rpath;\n\nerror:\n  {\n    int saved_errno = errno;\n    if (extra_buf)\n      freea (extra_buf);\n    if (resolved == NULL)\n      free (rpath);\n    __set_errno (saved_errno);\n  }\n  return NULL;\n}",
      "lines": 278,
      "depth": 24,
      "decorators": [
        "char",
        "*\n__realpath (const char *name, char *resolved)",
        "*"
      ]
    },
    "__old_realpath": {
      "start_point": [
        398,
        0
      ],
      "end_point": [
        409,
        1
      ],
      "content": "char *\nattribute_compat_text_section\n__old_realpath (const char *name, char *resolved)\n{\n  if (resolved == NULL)\n    {\n      __set_errno (EINVAL);\n      return NULL;\n    }\n\n  return __realpath (name, resolved);\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "char",
        "*\nattribute_compat_text_section\n__old_realpath (const char *name, char *resolved)",
        "*",
        "attribute_compat_text_section",
        "attribute_compat_text_section"
      ]
    },
    "__canonicalize_file_name": {
      "start_point": [
        414,
        0
      ],
      "end_point": [
        418,
        1
      ],
      "content": "char *\n__canonicalize_file_name (const char *name)\n{\n  return __realpath (name, NULL);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\n__canonicalize_file_name (const char *name)",
        "*"
      ]
    }
  },
  "sed/sed-4.5/lib/close-stream.c": {
    "close_stream": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "int\nclose_stream (FILE *stream)\n{\n  const bool some_pending = (__fpending (stream) != 0);\n  const bool prev_fail = (ferror (stream) != 0);\n  const bool fclose_fail = (fclose (stream) != 0);\n\n  /* Return an error indication if there was a previous failure or if\n     fclose failed, with one exception: ignore an fclose failure if\n     there was no previous error, no data remains to be flushed, and\n     fclose failed with EBADF.  That can happen when a program like cp\n     is invoked like this 'cp a b >&-' (i.e., with standard output\n     closed) and doesn't generate any output (hence no previous error\n     and nothing to be flushed).  */\n\n  if (prev_fail || (fclose_fail && (some_pending || errno != EBADF)))\n    {\n      if (! fclose_fail)\n        errno = 0;\n      return EOF;\n    }\n\n  return 0;\n}",
      "lines": 24,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/lib/close-stream.h": {},
  "sed/sed-4.5/lib/closeout.c": {
    "close_stdout_set_file_name": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "void\nclose_stdout_set_file_name (const char *file)\n{\n  file_name = file;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "close_stdout_set_ignore_EPIPE": {
      "start_point": [
        86,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "void\nclose_stdout_set_ignore_EPIPE (bool ignore)\n{\n  ignore_EPIPE = ignore;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "void"
      ]
    },
    "close_stdout": {
      "start_point": [
        115,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "void\nclose_stdout (void)\n{\n  if (close_stream (stdout) != 0\n      && !(ignore_EPIPE && errno == EPIPE))\n    {\n      char const *write_error = _(\"write error\");\n      if (file_name)\n        error (0, errno, \"%s: %s\", quotearg_colon (file_name),\n               write_error);\n      else\n        error (0, errno, \"%s\", write_error);\n\n      _exit (exit_failure);\n    }\n\n  /* Close stderr only if not sanitizing, as sanitizers may report to\n     stderr after this function returns.  */\n  if (!SANITIZE_ADDRESS && close_stream (stderr) != 0)\n    _exit (exit_failure);\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "sed/sed-4.5/lib/closeout.h": {},
  "sed/sed-4.5/lib/copy-acl.c": {
    "copy_acl": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "int\ncopy_acl (const char *src_name, int source_desc, const char *dst_name,\n          int dest_desc, mode_t mode)\n{\n  int ret = qcopy_acl (src_name, source_desc, dst_name, dest_desc, mode);\n  switch (ret)\n    {\n    case -2:\n      error (0, errno, \"%s\", quote (src_name));\n      break;\n\n    case -1:\n      error (0, errno, _(\"preserving permissions for %s\"), quote (dst_name));\n      break;\n\n    default:\n      break;\n    }\n  return ret;\n}",
      "lines": 20,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/lib/ctype.in.h": {},
  "sed/sed-4.5/lib/dfa.c": {
    "streq": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        39,
        1
      ],
      "content": "static bool\nstreq (char const *a, char const *b)\n{\n  return strcmp (a, b) == 0;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "isasciidigit": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "static bool\nisasciidigit (char c)\n{\n  return '0' <= c && c <= '9';\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "to_uchar": {
      "start_point": [
        118,
        0
      ],
      "end_point": [
        122,
        1
      ],
      "content": "static unsigned char\nto_uchar (char ch)\n{\n  return ch;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "unsigned char",
        "unsigned",
        "char"
      ]
    },
    "newline_constraint": {
      "start_point": [
        159,
        0
      ],
      "end_point": [
        163,
        1
      ],
      "content": "static int\nnewline_constraint (int constraint)\n{\n  return (constraint >> 6) & 7;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "letter_constraint": {
      "start_point": [
        164,
        0
      ],
      "end_point": [
        168,
        1
      ],
      "content": "static int\nletter_constraint (int constraint)\n{\n  return (constraint >> 3) & 7;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "other_constraint": {
      "start_point": [
        169,
        0
      ],
      "end_point": [
        173,
        1
      ],
      "content": "static int\nother_constraint (int constraint)\n{\n  return constraint & 7;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "succeeds_in_context": {
      "start_point": [
        175,
        0
      ],
      "end_point": [
        182,
        1
      ],
      "content": "static bool\nsucceeds_in_context (int constraint, int prev, int curr)\n{\n  return !! (((curr & CTX_NONE      ? other_constraint (constraint) : 0) \\\n              | (curr & CTX_LETTER  ? letter_constraint (constraint) : 0) \\\n              | (curr & CTX_NEWLINE ? newline_constraint (constraint) : 0)) \\\n             & prev);\n}",
      "lines": 8,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "prev_newline_dependent": {
      "start_point": [
        185,
        0
      ],
      "end_point": [
        189,
        1
      ],
      "content": "static bool\nprev_newline_dependent (int constraint)\n{\n  return ((constraint ^ constraint >> 2) & 0111) != 0;\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "prev_letter_dependent": {
      "start_point": [
        190,
        0
      ],
      "end_point": [
        194,
        1
      ],
      "content": "static bool\nprev_letter_dependent (int constraint)\n{\n  return ((constraint ^ constraint >> 1) & 0111) != 0;\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "accepting": {
      "start_point": [
        573,
        0
      ],
      "end_point": [
        577,
        1
      ],
      "content": "static bool\naccepting (state_num s, struct dfa const *r)\n{\n  return r->states[s].constraint != 0;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "accepts_in_context": {
      "start_point": [
        580,
        0
      ],
      "end_point": [
        584,
        1
      ],
      "content": "static bool\naccepts_in_context (int prev, int curr, state_num state, struct dfa const *dfa)\n{\n  return succeeds_in_context (dfa->states[state].constraint, prev, curr);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "mbs_to_wchar": {
      "start_point": [
        605,
        0
      ],
      "end_point": [
        625,
        1
      ],
      "content": "static size_t\nmbs_to_wchar (wint_t *pwc, char const *s, size_t n, struct dfa *d)\n{\n  unsigned char uc = s[0];\n  wint_t wc = d->localeinfo.sbctowc[uc];\n\n  if (wc == WEOF)\n    {\n      wchar_t wch;\n      size_t nbytes = mbrtowc (&wch, s, n, &d->mbs);\n      if (0 < nbytes && nbytes < (size_t) -2)\n        {\n          *pwc = wch;\n          return nbytes;\n        }\n      memset (&d->mbs, 0, sizeof d->mbs);\n    }\n\n  *pwc = wc;\n  return 1;\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "prtok": {
      "start_point": [
        629,
        0
      ],
      "end_point": [
        701,
        1
      ],
      "content": "static void\nprtok (token t)\n{\n  if (t < 0)\n    fprintf (stderr, \"END\");\n  else if (t < NOTCHAR)\n    {\n      unsigned int ch = t;\n      fprintf (stderr, \"0x%02x\", ch);\n    }\n  else\n    {\n      char const *s;\n      switch (t)\n        {\n        case EMPTY:\n          s = \"EMPTY\";\n          break;\n        case BACKREF:\n          s = \"BACKREF\";\n          break;\n        case BEGLINE:\n          s = \"BEGLINE\";\n          break;\n        case ENDLINE:\n          s = \"ENDLINE\";\n          break;\n        case BEGWORD:\n          s = \"BEGWORD\";\n          break;\n        case ENDWORD:\n          s = \"ENDWORD\";\n          break;\n        case LIMWORD:\n          s = \"LIMWORD\";\n          break;\n        case NOTLIMWORD:\n          s = \"NOTLIMWORD\";\n          break;\n        case QMARK:\n          s = \"QMARK\";\n          break;\n        case STAR:\n          s = \"STAR\";\n          break;\n        case PLUS:\n          s = \"PLUS\";\n          break;\n        case CAT:\n          s = \"CAT\";\n          break;\n        case OR:\n          s = \"OR\";\n          break;\n        case LPAREN:\n          s = \"LPAREN\";\n          break;\n        case RPAREN:\n          s = \"RPAREN\";\n          break;\n        case ANYCHAR:\n          s = \"ANYCHAR\";\n          break;\n        case MBCSET:\n          s = \"MBCSET\";\n          break;\n        default:\n          s = \"CSET\";\n          break;\n        }\n      fprintf (stderr, \"%s\", s);\n    }\n}",
      "lines": 73,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "tstbit": {
      "start_point": [
        706,
        0
      ],
      "end_point": [
        710,
        1
      ],
      "content": "static bool\ntstbit (unsigned int b, charclass const *c)\n{\n  return c->w[b / CHARCLASS_WORD_BITS] >> b % CHARCLASS_WORD_BITS & 1;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "setbit": {
      "start_point": [
        712,
        0
      ],
      "end_point": [
        717,
        1
      ],
      "content": "static void\nsetbit (unsigned int b, charclass *c)\n{\n  charclass_word one = 1;\n  c->w[b / CHARCLASS_WORD_BITS] |= one << b % CHARCLASS_WORD_BITS;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "clrbit": {
      "start_point": [
        719,
        0
      ],
      "end_point": [
        724,
        1
      ],
      "content": "static void\nclrbit (unsigned int b, charclass *c)\n{\n  charclass_word one = 1;\n  c->w[b / CHARCLASS_WORD_BITS] &= ~(one << b % CHARCLASS_WORD_BITS);\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "zeroset": {
      "start_point": [
        726,
        0
      ],
      "end_point": [
        730,
        1
      ],
      "content": "static void\nzeroset (charclass *s)\n{\n  memset (s, 0, sizeof *s);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "fillset": {
      "start_point": [
        732,
        0
      ],
      "end_point": [
        737,
        1
      ],
      "content": "static void\nfillset (charclass *s)\n{\n  for (int i = 0; i < CHARCLASS_WORDS; i++)\n    s->w[i] = CHARCLASS_WORD_MASK;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "notset": {
      "start_point": [
        739,
        0
      ],
      "end_point": [
        744,
        1
      ],
      "content": "static void\nnotset (charclass *s)\n{\n  for (int i = 0; i < CHARCLASS_WORDS; ++i)\n    s->w[i] = CHARCLASS_WORD_MASK & ~s->w[i];\n}",
      "lines": 6,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "equal": {
      "start_point": [
        746,
        0
      ],
      "end_point": [
        753,
        1
      ],
      "content": "static bool\nequal (charclass const *s1, charclass const *s2)\n{\n  charclass_word w = 0;\n  for (int i = 0; i < CHARCLASS_WORDS; i++)\n    w |= s1->w[i] ^ s2->w[i];\n  return w == 0;\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "emptyset": {
      "start_point": [
        755,
        0
      ],
      "end_point": [
        762,
        1
      ],
      "content": "static bool\nemptyset (charclass const *s)\n{\n  charclass_word w = 0;\n  for (int i = 0; i < CHARCLASS_WORDS; i++)\n    w |= s->w[i];\n  return w == 0;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "xpalloc": {
      "start_point": [
        780,
        0
      ],
      "end_point": [
        822,
        1
      ],
      "content": "static void *\nxpalloc (void *pa, ptrdiff_t *nitems, ptrdiff_t nitems_incr_min,\n\t ptrdiff_t nitems_max, ptrdiff_t item_size)\n{\n  ptrdiff_t n0 = *nitems;\n\n  /* The approximate size to use for initial small allocation\n     requests.  This is the largest \"small\" request for the GNU C\n     library malloc.  */\n  enum { DEFAULT_MXFAST = 64 * sizeof (size_t) / 4 };\n\n  /* If the array is tiny, grow it to about (but no greater than)\n     DEFAULT_MXFAST bytes.  Otherwise, grow it by about 50%.\n     Adjust the growth according to three constraints: NITEMS_INCR_MIN,\n     NITEMS_MAX, and what the C language can represent safely.  */\n\n  ptrdiff_t n, nbytes;\n  if (INT_ADD_WRAPV (n0, n0 >> 1, &n))\n    n = PTRDIFF_MAX;\n  if (0 <= nitems_max && nitems_max < n)\n    n = nitems_max;\n\n  ptrdiff_t adjusted_nbytes\n    = ((INT_MULTIPLY_WRAPV (n, item_size, &nbytes) || SIZE_MAX < nbytes)\n       ? MIN (PTRDIFF_MAX, SIZE_MAX)\n       : nbytes < DEFAULT_MXFAST ? DEFAULT_MXFAST : 0);\n  if (adjusted_nbytes)\n    {\n      n = adjusted_nbytes / item_size;\n      nbytes = adjusted_nbytes - adjusted_nbytes % item_size;\n    }\n\n  if (! pa)\n    *nitems = 0;\n  if (n - n0 < nitems_incr_min\n      && (INT_ADD_WRAPV (n0, nitems_incr_min, &n)\n\t  || (0 <= nitems_max && nitems_max < n)\n\t  || INT_MULTIPLY_WRAPV (n, item_size, &nbytes)))\n    xalloc_die ();\n  pa = xrealloc (pa, nbytes);\n  *nitems = n;\n  return pa;\n}",
      "lines": 43,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nxpalloc (void *pa, ptrdiff_t *nitems, ptrdiff_t nitems_incr_min,\n\t ptrdiff_t nitems_max, ptrdiff_t item_size)",
        "*"
      ]
    },
    "maybe_realloc": {
      "start_point": [
        833,
        0
      ],
      "end_point": [
        840,
        1
      ],
      "content": "static void *\nmaybe_realloc (void *pa, ptrdiff_t i, ptrdiff_t *nitems,\n               ptrdiff_t nitems_max, ptrdiff_t item_size)\n{\n  if (i < *nitems)\n    return pa;\n  return xpalloc (pa, nitems, 1, nitems_max, item_size);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nmaybe_realloc (void *pa, ptrdiff_t i, ptrdiff_t *nitems,\n               ptrdiff_t nitems_max, ptrdiff_t item_size)",
        "*"
      ]
    },
    "charclass_index": {
      "start_point": [
        843,
        0
      ],
      "end_point": [
        856,
        1
      ],
      "content": "static ptrdiff_t\ncharclass_index (struct dfa *d, charclass *s)\n{\n  ptrdiff_t i;\n\n  for (i = 0; i < d->cindex; ++i)\n    if (equal (s, &d->charclasses[i]))\n      return i;\n  d->charclasses = maybe_realloc (d->charclasses, d->cindex, &d->calloc,\n                                  TOKEN_MAX - CSET, sizeof *d->charclasses);\n  ++d->cindex;\n  d->charclasses[i] = *s;\n  return i;\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "ptrdiff_t"
      ]
    },
    "unibyte_word_constituent": {
      "start_point": [
        858,
        0
      ],
      "end_point": [
        862,
        1
      ],
      "content": "static bool\nunibyte_word_constituent (struct dfa const *dfa, unsigned char c)\n{\n  return dfa->localeinfo.sbctowc[c] != WEOF && (isalnum (c) || (c) == '_');\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "char_context": {
      "start_point": [
        864,
        0
      ],
      "end_point": [
        872,
        1
      ],
      "content": "static int\nchar_context (struct dfa const *dfa, unsigned char c)\n{\n  if (c == dfa->syntax.eolbyte && !dfa->syntax.anchor)\n    return CTX_NEWLINE;\n  if (unibyte_word_constituent (dfa, c))\n    return CTX_LETTER;\n  return CTX_NONE;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "setbit_wc": {
      "start_point": [
        879,
        0
      ],
      "end_point": [
        888,
        1
      ],
      "content": "static bool\nsetbit_wc (wint_t wc, charclass *c)\n{\n  int b = wctob (wc);\n  if (b < 0)\n    return false;\n\n  setbit (b, c);\n  return true;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "setbit_case_fold_c": {
      "start_point": [
        892,
        0
      ],
      "end_point": [
        899,
        1
      ],
      "content": "static void\nsetbit_case_fold_c (int b, charclass *c)\n{\n  int ub = toupper (b);\n  for (int i = 0; i < NOTCHAR; i++)\n    if (toupper (i) == ub)\n      setbit (i, c);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "using_simple_locale": {
      "start_point": [
        903,
        0
      ],
      "end_point": [
        931,
        1
      ],
      "content": "static bool\nusing_simple_locale (bool multibyte)\n{\n  /* The native character set is known to be compatible with\n     the C locale.  The following test isn't perfect, but it's good\n     enough in practice, as only ASCII and EBCDIC are in common use\n     and this test correctly accepts ASCII and rejects EBCDIC.  */\n  enum { native_c_charset =\n    ('\\b' == 8 && '\\t' == 9 && '\\n' == 10 && '\\v' == 11 && '\\f' == 12\n     && '\\r' == 13 && ' ' == 32 && '!' == 33 && '\"' == 34 && '#' == 35\n     && '%' == 37 && '&' == 38 && '\\'' == 39 && '(' == 40 && ')' == 41\n     && '*' == 42 && '+' == 43 && ',' == 44 && '-' == 45 && '.' == 46\n     && '/' == 47 && '0' == 48 && '9' == 57 && ':' == 58 && ';' == 59\n     && '<' == 60 && '=' == 61 && '>' == 62 && '?' == 63 && 'A' == 65\n     && 'Z' == 90 && '[' == 91 && '\\\\' == 92 && ']' == 93 && '^' == 94\n     && '_' == 95 && 'a' == 97 && 'z' == 122 && '{' == 123 && '|' == 124\n     && '}' == 125 && '~' == 126)\n  };\n\n  if (!native_c_charset || multibyte)\n    return false;\n  else\n    {\n      /* Treat C and POSIX locales as being compatible.  Also, treat\n         errors as compatible, as these are invariably from stubs.  */\n      char const *loc = setlocale (LC_ALL, NULL);\n      return !loc || streq (loc, \"C\") || streq (loc, \"POSIX\");\n    }\n}",
      "lines": 29,
      "depth": 50,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "fetch_wc": {
      "start_point": [
        939,
        0
      ],
      "end_point": [
        949,
        1
      ],
      "content": "static int\nfetch_wc (struct dfa *dfa)\n{\n  size_t nbytes = mbs_to_wchar (&dfa->lex.wctok, dfa->lex.ptr, dfa->lex.left,\n                                dfa);\n  dfa->lex.cur_mb_len = nbytes;\n  int c = nbytes == 1 ? to_uchar (dfa->lex.ptr[0]) : EOF;\n  dfa->lex.ptr += nbytes;\n  dfa->lex.left -= nbytes;\n  return c;\n}",
      "lines": 11,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "bracket_fetch_wc": {
      "start_point": [
        953,
        0
      ],
      "end_point": [
        959,
        1
      ],
      "content": "static int\nbracket_fetch_wc (struct dfa *dfa)\n{\n  if (! dfa->lex.left)\n    dfaerror (_(\"unbalanced [\"));\n  return fetch_wc (dfa);\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "_GL_ATTRIBUTE_PURE": [
      {
        "start_point": [
          990,
          0
        ],
        "end_point": [
          997,
          1
        ],
        "content": "static const struct dfa_ctype *_GL_ATTRIBUTE_PURE\nfind_pred (const char *str)\n{\n  for (unsigned int i = 0; prednames[i].name; ++i)\n    if (streq (str, prednames[i].name))\n      return &prednames[i];\n  return NULL;\n}",
        "lines": 8,
        "depth": 10,
        "decorators": [
          "static",
          "static",
          "const",
          "const",
          "struct dfa_ctype",
          "struct",
          "dfa_ctype",
          "*_GL_ATTRIBUTE_PURE\nfind_pred (const char *str)",
          "*"
        ]
      },
      {
        "start_point": [
          1857,
          0
        ],
        "end_point": [
          1875,
          1
        ],
        "content": "static size_t _GL_ATTRIBUTE_PURE\nnsubtoks (struct dfa const *dfa, size_t tindex)\n{\n  switch (dfa->tokens[tindex - 1])\n    {\n    default:\n      return 1;\n    case QMARK:\n    case STAR:\n    case PLUS:\n      return 1 + nsubtoks (dfa, tindex - 1);\n    case CAT:\n    case OR:\n      {\n        size_t ntoks1 = nsubtoks (dfa, tindex - 1);\n        return 1 + ntoks1 + nsubtoks (dfa, tindex - 1 - ntoks1);\n      }\n    }\n}",
        "lines": 19,
        "depth": 13,
        "decorators": [
          "static",
          "static",
          "size_t"
        ]
      }
    ],
    "parse_bracket_exp": {
      "start_point": [
        1001,
        0
      ],
      "end_point": [
        1224,
        1
      ],
      "content": "static token\nparse_bracket_exp (struct dfa *dfa)\n{\n  /* This is a bracket expression that dfaexec is known to\n     process correctly.  */\n  bool known_bracket_exp = true;\n\n  /* Used to warn about [:space:].\n     Bit 0 = first character is a colon.\n     Bit 1 = last character is a colon.\n     Bit 2 = includes any other character but a colon.\n     Bit 3 = includes ranges, char/equiv classes or collation elements.  */\n  int colon_warning_state;\n\n  dfa->lex.brack.nchars = 0;\n  charclass ccl;\n  zeroset (&ccl);\n  int c = bracket_fetch_wc (dfa);\n  bool invert = c == '^';\n  if (invert)\n    {\n      c = bracket_fetch_wc (dfa);\n      known_bracket_exp = dfa->simple_locale;\n    }\n  wint_t wc = dfa->lex.wctok;\n  int c1;\n  wint_t wc1;\n  colon_warning_state = (c == ':');\n  do\n    {\n      c1 = NOTCHAR;\t/* Mark c1 as not initialized.  */\n      colon_warning_state &= ~2;\n\n      /* Note that if we're looking at some other [:...:] construct,\n         we just treat it as a bunch of ordinary characters.  We can do\n         this because we assume regex has checked for syntax errors before\n         dfa is ever called.  */\n      if (c == '[')\n        {\n          c1 = bracket_fetch_wc (dfa);\n          wc1 = dfa->lex.wctok;\n\n          if ((c1 == ':' && (dfa->syntax.syntax_bits & RE_CHAR_CLASSES))\n              || c1 == '.' || c1 == '=')\n            {\n              enum { MAX_BRACKET_STRING_LEN = 32 };\n              char str[MAX_BRACKET_STRING_LEN + 1];\n              size_t len = 0;\n              for (;;)\n                {\n                  c = bracket_fetch_wc (dfa);\n                  if (dfa->lex.left == 0\n                      || (c == c1 && dfa->lex.ptr[0] == ']'))\n                    break;\n                  if (len < MAX_BRACKET_STRING_LEN)\n                    str[len++] = c;\n                  else\n                    /* This is in any case an invalid class name.  */\n                    str[0] = '\\0';\n                }\n              str[len] = '\\0';\n\n              /* Fetch bracket.  */\n              c = bracket_fetch_wc (dfa);\n              wc = dfa->lex.wctok;\n              if (c1 == ':')\n                /* Build character class.  POSIX allows character\n                   classes to match multicharacter collating elements,\n                   but the regex code does not support that, so do not\n                   worry about that possibility.  */\n                {\n                  char const *class\n                    = (dfa->syntax.case_fold && (streq (str, \"upper\")\n                                                 || streq (str, \"lower\"))\n                       ? \"alpha\" : str);\n                  const struct dfa_ctype *pred = find_pred (class);\n                  if (!pred)\n                    dfaerror (_(\"invalid character class\"));\n\n                  if (dfa->localeinfo.multibyte && !pred->single_byte_only)\n                    known_bracket_exp = false;\n                  else\n                    for (int c2 = 0; c2 < NOTCHAR; ++c2)\n                      if (pred->func (c2))\n                        setbit (c2, &ccl);\n                }\n              else\n                known_bracket_exp = false;\n\n              colon_warning_state |= 8;\n\n              /* Fetch new lookahead character.  */\n              c1 = bracket_fetch_wc (dfa);\n              wc1 = dfa->lex.wctok;\n              continue;\n            }\n\n          /* We treat '[' as a normal character here.  c/c1/wc/wc1\n             are already set up.  */\n        }\n\n      if (c == '\\\\'\n          && (dfa->syntax.syntax_bits & RE_BACKSLASH_ESCAPE_IN_LISTS))\n        {\n          c = bracket_fetch_wc (dfa);\n          wc = dfa->lex.wctok;\n        }\n\n      if (c1 == NOTCHAR)\n        {\n          c1 = bracket_fetch_wc (dfa);\n          wc1 = dfa->lex.wctok;\n        }\n\n      if (c1 == '-')\n        /* build range characters.  */\n        {\n          int c2 = bracket_fetch_wc (dfa);\n          wint_t wc2 = dfa->lex.wctok;\n\n          /* A bracket expression like [a-[.aa.]] matches an unknown set.\n             Treat it like [-a[.aa.]] while parsing it, and\n             remember that the set is unknown.  */\n          if (c2 == '[' && dfa->lex.ptr[0] == '.')\n            {\n              known_bracket_exp = false;\n              c2 = ']';\n            }\n\n          if (c2 == ']')\n            {\n              /* In the case [x-], the - is an ordinary hyphen,\n                 which is left in c1, the lookahead character.  */\n              dfa->lex.ptr -= dfa->lex.cur_mb_len;\n              dfa->lex.left += dfa->lex.cur_mb_len;\n            }\n          else\n            {\n              if (c2 == '\\\\' && (dfa->syntax.syntax_bits\n                                 & RE_BACKSLASH_ESCAPE_IN_LISTS))\n                {\n                  c2 = bracket_fetch_wc (dfa);\n                  wc2 = dfa->lex.wctok;\n                }\n\n              colon_warning_state |= 8;\n              c1 = bracket_fetch_wc (dfa);\n              wc1 = dfa->lex.wctok;\n\n              /* Treat [x-y] as a range if x != y.  */\n              if (wc != wc2 || wc == WEOF)\n                {\n                  if (dfa->simple_locale\n                      || (isasciidigit (c) & isasciidigit (c2)))\n                    {\n                      for (int ci = c; ci <= c2; ci++)\n                        if (dfa->syntax.case_fold && isalpha (ci))\n                          setbit_case_fold_c (ci, &ccl);\n                        else\n                          setbit (ci, &ccl);\n                    }\n                  else\n                    known_bracket_exp = false;\n\n                  continue;\n                }\n            }\n        }\n\n      colon_warning_state |= (c == ':') ? 2 : 4;\n\n      if (!dfa->localeinfo.multibyte)\n        {\n          if (dfa->syntax.case_fold && isalpha (c))\n            setbit_case_fold_c (c, &ccl);\n          else\n            setbit (c, &ccl);\n          continue;\n        }\n\n      if (wc == WEOF)\n        known_bracket_exp = false;\n      else\n        {\n          wchar_t folded[CASE_FOLDED_BUFSIZE + 1];\n          unsigned int n = (dfa->syntax.case_fold\n                            ? case_folded_counterparts (wc, folded + 1) + 1\n                            : 1);\n          folded[0] = wc;\n          for (unsigned int i = 0; i < n; i++)\n            if (!setbit_wc (folded[i], &ccl))\n              {\n                dfa->lex.brack.chars\n                  = maybe_realloc (dfa->lex.brack.chars, dfa->lex.brack.nchars,\n                                   &dfa->lex.brack.nchars_alloc, -1,\n                                   sizeof *dfa->lex.brack.chars);\n                dfa->lex.brack.chars[dfa->lex.brack.nchars++] = folded[i];\n              }\n        }\n    }\n  while ((wc = wc1, (c = c1) != ']'));\n\n  if (colon_warning_state == 7)\n    dfawarn (_(\"character class syntax is [[:space:]], not [:space:]\"));\n\n  if (! known_bracket_exp)\n    return BACKREF;\n\n  if (dfa->localeinfo.multibyte && (invert || dfa->lex.brack.nchars != 0))\n    {\n      dfa->lex.brack.invert = invert;\n      dfa->lex.brack.cset = emptyset (&ccl) ? -1 : charclass_index (dfa, &ccl);\n      return MBCSET;\n    }\n\n  if (invert)\n    {\n      notset (&ccl);\n      if (dfa->syntax.syntax_bits & RE_HAT_LISTS_NOT_NEWLINE)\n        clrbit ('\\n', &ccl);\n    }\n\n  return CSET + charclass_index (dfa, &ccl);\n}",
      "lines": 224,
      "depth": 21,
      "decorators": [
        "static",
        "static",
        "token"
      ]
    },
    "push_lex_state": {
      "start_point": [
        1232,
        0
      ],
      "end_point": [
        1239,
        1
      ],
      "content": "static void\npush_lex_state (struct dfa *dfa, struct lexptr *ls, char const *s)\n{\n  ls->ptr = dfa->lex.ptr;\n  ls->left = dfa->lex.left;\n  dfa->lex.ptr = s;\n  dfa->lex.left = strlen (s);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "pop_lex_state": {
      "start_point": [
        1241,
        0
      ],
      "end_point": [
        1246,
        1
      ],
      "content": "static void\npop_lex_state (struct dfa *dfa, struct lexptr const *ls)\n{\n  dfa->lex.ptr = ls->ptr;\n  dfa->lex.left = ls->left;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "lex": {
      "start_point": [
        1248,
        0
      ],
      "end_point": [
        1593,
        1
      ],
      "content": "static token\nlex (struct dfa *dfa)\n{\n  bool backslash = false;\n\n  /* Basic plan: We fetch a character.  If it's a backslash,\n     we set the backslash flag and go through the loop again.\n     On the plus side, this avoids having a duplicate of the\n     main switch inside the backslash case.  On the minus side,\n     it means that just about every case begins with\n     \"if (backslash) ...\".  */\n  for (int i = 0; i < 2; ++i)\n    {\n      if (! dfa->lex.left)\n        return dfa->lex.lasttok = END;\n      int c = fetch_wc (dfa);\n\n      switch (c)\n        {\n        case '\\\\':\n          if (backslash)\n            goto normal_char;\n          if (dfa->lex.left == 0)\n            dfaerror (_(\"unfinished \\\\ escape\"));\n          backslash = true;\n          break;\n\n        case '^':\n          if (backslash)\n            goto normal_char;\n          if (dfa->syntax.syntax_bits & RE_CONTEXT_INDEP_ANCHORS\n              || dfa->lex.lasttok == END || dfa->lex.lasttok == LPAREN\n              || dfa->lex.lasttok == OR)\n            return dfa->lex.lasttok = BEGLINE;\n          goto normal_char;\n\n        case '$':\n          if (backslash)\n            goto normal_char;\n          if (dfa->syntax.syntax_bits & RE_CONTEXT_INDEP_ANCHORS\n              || dfa->lex.left == 0\n              || ((dfa->lex.left\n                   > !(dfa->syntax.syntax_bits & RE_NO_BK_PARENS))\n                  && (dfa->lex.ptr[!(dfa->syntax.syntax_bits & RE_NO_BK_PARENS)\n                                   & (dfa->lex.ptr[0] == '\\\\')]\n                      == ')'))\n              || ((dfa->lex.left\n                   > !(dfa->syntax.syntax_bits & RE_NO_BK_VBAR))\n                  && (dfa->lex.ptr[!(dfa->syntax.syntax_bits & RE_NO_BK_VBAR)\n                                   & (dfa->lex.ptr[0] == '\\\\')]\n                      == '|'))\n              || ((dfa->syntax.syntax_bits & RE_NEWLINE_ALT)\n                  && dfa->lex.left > 0 && dfa->lex.ptr[0] == '\\n'))\n            return dfa->lex.lasttok = ENDLINE;\n          goto normal_char;\n\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n          if (backslash && !(dfa->syntax.syntax_bits & RE_NO_BK_REFS))\n            {\n              dfa->lex.laststart = false;\n              return dfa->lex.lasttok = BACKREF;\n            }\n          goto normal_char;\n\n        case '`':\n          if (backslash && !(dfa->syntax.syntax_bits & RE_NO_GNU_OPS))\n            {\n              /* FIXME: should be beginning of string */\n              return dfa->lex.lasttok = BEGLINE;\n            }\n          goto normal_char;\n\n        case '\\'':\n          if (backslash && !(dfa->syntax.syntax_bits & RE_NO_GNU_OPS))\n            {\n              /* FIXME: should be end of string */\n              return dfa->lex.lasttok = ENDLINE;\n            }\n          goto normal_char;\n\n        case '<':\n          if (backslash && !(dfa->syntax.syntax_bits & RE_NO_GNU_OPS))\n            return dfa->lex.lasttok = BEGWORD;\n          goto normal_char;\n\n        case '>':\n          if (backslash && !(dfa->syntax.syntax_bits & RE_NO_GNU_OPS))\n            return dfa->lex.lasttok = ENDWORD;\n          goto normal_char;\n\n        case 'b':\n          if (backslash && !(dfa->syntax.syntax_bits & RE_NO_GNU_OPS))\n            return dfa->lex.lasttok = LIMWORD;\n          goto normal_char;\n\n        case 'B':\n          if (backslash && !(dfa->syntax.syntax_bits & RE_NO_GNU_OPS))\n            return dfa->lex.lasttok = NOTLIMWORD;\n          goto normal_char;\n\n        case '?':\n          if (dfa->syntax.syntax_bits & RE_LIMITED_OPS)\n            goto normal_char;\n          if (backslash != ((dfa->syntax.syntax_bits & RE_BK_PLUS_QM) != 0))\n            goto normal_char;\n          if (!(dfa->syntax.syntax_bits & RE_CONTEXT_INDEP_OPS)\n              && dfa->lex.laststart)\n            goto normal_char;\n          return dfa->lex.lasttok = QMARK;\n\n        case '*':\n          if (backslash)\n            goto normal_char;\n          if (!(dfa->syntax.syntax_bits & RE_CONTEXT_INDEP_OPS)\n              && dfa->lex.laststart)\n            goto normal_char;\n          return dfa->lex.lasttok = STAR;\n\n        case '+':\n          if (dfa->syntax.syntax_bits & RE_LIMITED_OPS)\n            goto normal_char;\n          if (backslash != ((dfa->syntax.syntax_bits & RE_BK_PLUS_QM) != 0))\n            goto normal_char;\n          if (!(dfa->syntax.syntax_bits & RE_CONTEXT_INDEP_OPS)\n              && dfa->lex.laststart)\n            goto normal_char;\n          return dfa->lex.lasttok = PLUS;\n\n        case '{':\n          if (!(dfa->syntax.syntax_bits & RE_INTERVALS))\n            goto normal_char;\n          if (backslash != ((dfa->syntax.syntax_bits & RE_NO_BK_BRACES) == 0))\n            goto normal_char;\n          if (!(dfa->syntax.syntax_bits & RE_CONTEXT_INDEP_OPS)\n              && dfa->lex.laststart)\n            goto normal_char;\n\n          /* Cases:\n             {M} - exact count\n             {M,} - minimum count, maximum is infinity\n             {,N} - 0 through N\n             {,} - 0 to infinity (same as '*')\n             {M,N} - M through N */\n          {\n            char const *p = dfa->lex.ptr;\n            char const *lim = p + dfa->lex.left;\n            dfa->lex.minrep = dfa->lex.maxrep = -1;\n            for (; p != lim && isasciidigit (*p); p++)\n              dfa->lex.minrep = (dfa->lex.minrep < 0\n                                 ? *p - '0'\n                                 : MIN (RE_DUP_MAX + 1,\n                                        dfa->lex.minrep * 10 + *p - '0'));\n            if (p != lim)\n              {\n                if (*p != ',')\n                  dfa->lex.maxrep = dfa->lex.minrep;\n                else\n                  {\n                    if (dfa->lex.minrep < 0)\n                      dfa->lex.minrep = 0;\n                    while (++p != lim && isasciidigit (*p))\n                      dfa->lex.maxrep\n                        = (dfa->lex.maxrep < 0\n                           ? *p - '0'\n                           : MIN (RE_DUP_MAX + 1,\n                                  dfa->lex.maxrep * 10 + *p - '0'));\n                  }\n              }\n            if (! ((! backslash || (p != lim && *p++ == '\\\\'))\n                   && p != lim && *p++ == '}'\n                   && 0 <= dfa->lex.minrep\n                   && (dfa->lex.maxrep < 0\n                       || dfa->lex.minrep <= dfa->lex.maxrep)))\n              {\n                if (dfa->syntax.syntax_bits & RE_INVALID_INTERVAL_ORD)\n                  goto normal_char;\n                dfaerror (_(\"invalid content of \\\\{\\\\}\"));\n              }\n            if (RE_DUP_MAX < dfa->lex.maxrep)\n              dfaerror (_(\"regular expression too big\"));\n            dfa->lex.ptr = p;\n            dfa->lex.left = lim - p;\n          }\n          dfa->lex.laststart = false;\n          return dfa->lex.lasttok = REPMN;\n\n        case '|':\n          if (dfa->syntax.syntax_bits & RE_LIMITED_OPS)\n            goto normal_char;\n          if (backslash != ((dfa->syntax.syntax_bits & RE_NO_BK_VBAR) == 0))\n            goto normal_char;\n          dfa->lex.laststart = true;\n          return dfa->lex.lasttok = OR;\n\n        case '\\n':\n          if (dfa->syntax.syntax_bits & RE_LIMITED_OPS\n              || backslash || !(dfa->syntax.syntax_bits & RE_NEWLINE_ALT))\n            goto normal_char;\n          dfa->lex.laststart = true;\n          return dfa->lex.lasttok = OR;\n\n        case '(':\n          if (backslash != ((dfa->syntax.syntax_bits & RE_NO_BK_PARENS) == 0))\n            goto normal_char;\n          dfa->lex.parens++;\n          dfa->lex.laststart = true;\n          return dfa->lex.lasttok = LPAREN;\n\n        case ')':\n          if (backslash != ((dfa->syntax.syntax_bits & RE_NO_BK_PARENS) == 0))\n            goto normal_char;\n          if (dfa->lex.parens == 0\n              && dfa->syntax.syntax_bits & RE_UNMATCHED_RIGHT_PAREN_ORD)\n            goto normal_char;\n          dfa->lex.parens--;\n          dfa->lex.laststart = false;\n          return dfa->lex.lasttok = RPAREN;\n\n        case '.':\n          if (backslash)\n            goto normal_char;\n          if (dfa->canychar == (size_t) -1)\n            {\n              charclass ccl;\n              fillset (&ccl);\n              if (!(dfa->syntax.syntax_bits & RE_DOT_NEWLINE))\n                clrbit ('\\n', &ccl);\n              if (dfa->syntax.syntax_bits & RE_DOT_NOT_NULL)\n                clrbit ('\\0', &ccl);\n              if (dfa->localeinfo.multibyte)\n                for (int c2 = 0; c2 < NOTCHAR; c2++)\n                  if (dfa->localeinfo.sbctowc[c2] == WEOF)\n                    clrbit (c2, &ccl);\n              dfa->canychar = charclass_index (dfa, &ccl);\n            }\n          dfa->lex.laststart = false;\n          return dfa->lex.lasttok = (dfa->localeinfo.multibyte\n                                     ? ANYCHAR\n                                     : CSET + dfa->canychar);\n\n        case 's':\n        case 'S':\n          if (!backslash || (dfa->syntax.syntax_bits & RE_NO_GNU_OPS))\n            goto normal_char;\n          if (!dfa->localeinfo.multibyte)\n            {\n              charclass ccl;\n              zeroset (&ccl);\n              for (int c2 = 0; c2 < NOTCHAR; ++c2)\n                if (isspace (c2))\n                  setbit (c2, &ccl);\n              if (c == 'S')\n                notset (&ccl);\n              dfa->lex.laststart = false;\n              return dfa->lex.lasttok = CSET + charclass_index (dfa, &ccl);\n            }\n\n          /* FIXME: see if optimizing this, as is done with ANYCHAR and\n             add_utf8_anychar, makes sense.  */\n\n          /* \\s and \\S are documented to be equivalent to [[:space:]] and\n             [^[:space:]] respectively, so tell the lexer to process those\n             strings, each minus its \"already processed\" '['.  */\n          {\n            struct lexptr ls;\n            push_lex_state (dfa, &ls, &\"^[:space:]]\"[c == 's']);\n            dfa->lex.lasttok = parse_bracket_exp (dfa);\n            pop_lex_state (dfa, &ls);\n          }\n\n          dfa->lex.laststart = false;\n          return dfa->lex.lasttok;\n\n        case 'w':\n        case 'W':\n          if (!backslash || (dfa->syntax.syntax_bits & RE_NO_GNU_OPS))\n            goto normal_char;\n\n          if (!dfa->localeinfo.multibyte)\n            {\n              charclass ccl;\n              zeroset (&ccl);\n              for (int c2 = 0; c2 < NOTCHAR; ++c2)\n                if (dfa->syntax.sbit[c2] == CTX_LETTER)\n                  setbit (c2, &ccl);\n              if (c == 'W')\n                notset (&ccl);\n              dfa->lex.laststart = false;\n              return dfa->lex.lasttok = CSET + charclass_index (dfa, &ccl);\n            }\n\n          /* FIXME: see if optimizing this, as is done with ANYCHAR and\n             add_utf8_anychar, makes sense.  */\n\n          /* \\w and \\W are documented to be equivalent to [_[:alnum:]] and\n             [^_[:alnum:]] respectively, so tell the lexer to process those\n             strings, each minus its \"already processed\" '['.  */\n          {\n            struct lexptr ls;\n            push_lex_state (dfa, &ls, &\"^_[:alnum:]]\"[c == 'w']);\n            dfa->lex.lasttok = parse_bracket_exp (dfa);\n            pop_lex_state (dfa, &ls);\n          }\n\n          dfa->lex.laststart = false;\n          return dfa->lex.lasttok;\n\n        case '[':\n          if (backslash)\n            goto normal_char;\n          dfa->lex.laststart = false;\n          return dfa->lex.lasttok = parse_bracket_exp (dfa);\n\n        default:\n        normal_char:\n          dfa->lex.laststart = false;\n          /* For multibyte character sets, folding is done in atom.  Always\n             return WCHAR.  */\n          if (dfa->localeinfo.multibyte)\n            return dfa->lex.lasttok = WCHAR;\n\n          if (dfa->syntax.case_fold && isalpha (c))\n            {\n              charclass ccl;\n              zeroset (&ccl);\n              setbit_case_fold_c (c, &ccl);\n              return dfa->lex.lasttok = CSET + charclass_index (dfa, &ccl);\n            }\n\n          return dfa->lex.lasttok = c;\n        }\n    }\n\n  /* The above loop should consume at most a backslash\n     and some other character.  */\n  abort ();\n  return END;                   /* keeps pedantic compilers happy.  */\n}",
      "lines": 346,
      "depth": 25,
      "decorators": [
        "static",
        "static",
        "token"
      ]
    },
    "addtok_mb": {
      "start_point": [
        1595,
        0
      ],
      "end_point": [
        1634,
        1
      ],
      "content": "static void\naddtok_mb (struct dfa *dfa, token t, char mbprop)\n{\n  if (dfa->talloc == dfa->tindex)\n    {\n      dfa->tokens = x2nrealloc (dfa->tokens, &dfa->talloc,\n                                sizeof *dfa->tokens);\n      if (dfa->localeinfo.multibyte)\n        dfa->multibyte_prop = xnrealloc (dfa->multibyte_prop, dfa->talloc,\n                                         sizeof *dfa->multibyte_prop);\n    }\n  if (dfa->localeinfo.multibyte)\n    dfa->multibyte_prop[dfa->tindex] = mbprop;\n  dfa->tokens[dfa->tindex++] = t;\n\n  switch (t)\n    {\n    case QMARK:\n    case STAR:\n    case PLUS:\n      break;\n\n    case CAT:\n    case OR:\n      dfa->parse.depth--;\n      break;\n\n    case BACKREF:\n      dfa->fast = false;\n      FALLTHROUGH;\n    default:\n      dfa->nleaves++;\n      FALLTHROUGH;\n    case EMPTY:\n      dfa->parse.depth++;\n      break;\n    }\n  if (dfa->parse.depth > dfa->depth)\n    dfa->depth = dfa->parse.depth;\n}",
      "lines": 40,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "addtok": {
      "start_point": [
        1640,
        0
      ],
      "end_point": [
        1671,
        1
      ],
      "content": "static void\naddtok (struct dfa *dfa, token t)\n{\n  if (dfa->localeinfo.multibyte && t == MBCSET)\n    {\n      bool need_or = false;\n\n      /* Extract wide characters into alternations for better performance.\n         This does not require UTF-8.  */\n      for (ptrdiff_t i = 0; i < dfa->lex.brack.nchars; i++)\n        {\n          addtok_wc (dfa, dfa->lex.brack.chars[i]);\n          if (need_or)\n            addtok (dfa, OR);\n          need_or = true;\n        }\n      dfa->lex.brack.nchars = 0;\n\n      /* Wide characters have been handled above, so it is possible\n         that the set is empty now.  Do nothing in that case.  */\n      if (dfa->lex.brack.cset != -1)\n        {\n          addtok (dfa, CSET + dfa->lex.brack.cset);\n          if (need_or)\n            addtok (dfa, OR);\n        }\n    }\n  else\n    {\n      addtok_mb (dfa, t, 3);\n    }\n}",
      "lines": 32,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "addtok_wc": {
      "start_point": [
        1679,
        0
      ],
      "end_point": [
        1702,
        1
      ],
      "content": "static void\naddtok_wc (struct dfa *dfa, wint_t wc)\n{\n  unsigned char buf[MB_LEN_MAX];\n  mbstate_t s = { 0 };\n  size_t stored_bytes = wcrtomb ((char *) buf, wc, &s);\n\n  if (stored_bytes != (size_t) -1)\n    dfa->lex.cur_mb_len = stored_bytes;\n  else\n    {\n      /* This is merely stop-gap.  buf[0] is undefined, yet skipping\n         the addtok_mb call altogether can corrupt the heap.  */\n      dfa->lex.cur_mb_len = 1;\n      buf[0] = 0;\n    }\n\n  addtok_mb (dfa, buf[0], dfa->lex.cur_mb_len == 1 ? 3 : 1);\n  for (int i = 1; i < dfa->lex.cur_mb_len; i++)\n    {\n      addtok_mb (dfa, buf[i], i == dfa->lex.cur_mb_len - 1 ? 2 : 0);\n      addtok (dfa, CAT);\n    }\n}",
      "lines": 24,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "add_utf8_anychar": {
      "start_point": [
        1704,
        0
      ],
      "end_point": [
        1759,
        1
      ],
      "content": "static void\nadd_utf8_anychar (struct dfa *dfa)\n{\n  static charclass const utf8_classes[5] = {\n    /* 80-bf: non-leading bytes.  */\n    CHARCLASS_INIT (0, 0, 0, 0, 0xffffffff, 0xffffffff, 0, 0),\n\n    /* 00-7f: 1-byte sequence.  */\n    CHARCLASS_INIT (0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0, 0, 0, 0),\n\n    /* c2-df: 2-byte sequence.  */\n    CHARCLASS_INIT (0, 0, 0, 0, 0, 0, 0xfffffffc, 0),\n\n    /* e0-ef: 3-byte sequence.  */\n    CHARCLASS_INIT (0, 0, 0, 0, 0, 0, 0, 0xffff),\n\n    /* f0-f7: 4-byte sequence.  */\n    CHARCLASS_INIT (0, 0, 0, 0, 0, 0, 0, 0xff0000)\n  };\n  const unsigned int n = sizeof (utf8_classes) / sizeof (utf8_classes[0]);\n\n  /* Define the five character classes that are needed below.  */\n  if (dfa->utf8_anychar_classes[0] == 0)\n    for (unsigned int i = 0; i < n; i++)\n      {\n        charclass c = utf8_classes[i];\n        if (i == 1)\n          {\n            if (!(dfa->syntax.syntax_bits & RE_DOT_NEWLINE))\n              clrbit ('\\n', &c);\n            if (dfa->syntax.syntax_bits & RE_DOT_NOT_NULL)\n              clrbit ('\\0', &c);\n          }\n        dfa->utf8_anychar_classes[i] = CSET + charclass_index (dfa, &c);\n      }\n\n  /* A valid UTF-8 character is\n\n     ([0x00-0x7f]\n     |[0xc2-0xdf][0x80-0xbf]\n     |[0xe0-0xef[0x80-0xbf][0x80-0xbf]\n     |[0xf0-f7][0x80-0xbf][0x80-0xbf][0x80-0xbf])\n\n     which I'll write more concisely \"B|CA|DAA|EAAA\".  Factor the [0x00-0x7f]\n     and you get \"B|(C|(D|EA)A)A\".  And since the token buffer is in reverse\n     Polish notation, you get \"B C D E A CAT OR A CAT OR A CAT OR\".  */\n  unsigned int i;\n  for (i = 1; i < n; i++)\n    addtok (dfa, dfa->utf8_anychar_classes[i]);\n  while (--i > 1)\n    {\n      addtok (dfa, dfa->utf8_anychar_classes[0]);\n      addtok (dfa, CAT);\n      addtok (dfa, OR);\n    }\n}",
      "lines": 56,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "atom": {
      "start_point": [
        1796,
        0
      ],
      "end_point": [
        1854,
        1
      ],
      "content": "static void\natom (struct dfa *dfa)\n{\n  if (dfa->parse.tok == WCHAR)\n    {\n      if (dfa->lex.wctok == WEOF)\n        addtok (dfa, BACKREF);\n      else\n        {\n          addtok_wc (dfa, dfa->lex.wctok);\n\n          if (dfa->syntax.case_fold)\n            {\n              wchar_t folded[CASE_FOLDED_BUFSIZE];\n              unsigned int n = case_folded_counterparts (dfa->lex.wctok,\n                                                         folded);\n              for (unsigned int i = 0; i < n; i++)\n                {\n                  addtok_wc (dfa, folded[i]);\n                  addtok (dfa, OR);\n                }\n            }\n        }\n\n      dfa->parse.tok = lex (dfa);\n    }\n  else if (dfa->parse.tok == ANYCHAR && dfa->localeinfo.using_utf8)\n    {\n      /* For UTF-8 expand the period to a series of CSETs that define a valid\n         UTF-8 character.  This avoids using the slow multibyte path.  I'm\n         pretty sure it would be both profitable and correct to do it for\n         any encoding; however, the optimization must be done manually as\n         it is done above in add_utf8_anychar.  So, let's start with\n         UTF-8: it is the most used, and the structure of the encoding\n         makes the correctness more obvious.  */\n      add_utf8_anychar (dfa);\n      dfa->parse.tok = lex (dfa);\n    }\n  else if ((0 <= dfa->parse.tok && dfa->parse.tok < NOTCHAR)\n           || dfa->parse.tok >= CSET || dfa->parse.tok == BACKREF\n           || dfa->parse.tok == BEGLINE || dfa->parse.tok == ENDLINE\n           || dfa->parse.tok == BEGWORD || dfa->parse.tok == ANYCHAR\n           || dfa->parse.tok == MBCSET || dfa->parse.tok == ENDWORD\n           || dfa->parse.tok == LIMWORD || dfa->parse.tok == NOTLIMWORD)\n    {\n      addtok (dfa, dfa->parse.tok);\n      dfa->parse.tok = lex (dfa);\n    }\n  else if (dfa->parse.tok == LPAREN)\n    {\n      dfa->parse.tok = lex (dfa);\n      regexp (dfa);\n      if (dfa->parse.tok != RPAREN)\n        dfaerror (_(\"unbalanced (\"));\n      dfa->parse.tok = lex (dfa);\n    }\n  else\n    addtok (dfa, EMPTY);\n}",
      "lines": 59,
      "depth": 22,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "copytoks": {
      "start_point": [
        1878,
        0
      ],
      "end_point": [
        1888,
        1
      ],
      "content": "static void\ncopytoks (struct dfa *dfa, size_t tindex, size_t ntokens)\n{\n  if (dfa->localeinfo.multibyte)\n    for (size_t i = 0; i < ntokens; ++i)\n      addtok_mb (dfa, dfa->tokens[tindex + i],\n                 dfa->multibyte_prop[tindex + i]);\n  else\n    for (size_t i = 0; i < ntokens; ++i)\n      addtok_mb (dfa, dfa->tokens[tindex + i], 3);\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "closure": {
      "start_point": [
        1890,
        0
      ],
      "end_point": [
        1929,
        1
      ],
      "content": "static void\nclosure (struct dfa *dfa)\n{\n  atom (dfa);\n  while (dfa->parse.tok == QMARK || dfa->parse.tok == STAR\n         || dfa->parse.tok == PLUS || dfa->parse.tok == REPMN)\n    if (dfa->parse.tok == REPMN && (dfa->lex.minrep || dfa->lex.maxrep))\n      {\n        size_t ntokens = nsubtoks (dfa, dfa->tindex);\n        size_t tindex = dfa->tindex - ntokens;\n        if (dfa->lex.maxrep < 0)\n          addtok (dfa, PLUS);\n        if (dfa->lex.minrep == 0)\n          addtok (dfa, QMARK);\n        int i;\n        for (i = 1; i < dfa->lex.minrep; i++)\n          {\n            copytoks (dfa, tindex, ntokens);\n            addtok (dfa, CAT);\n          }\n        for (; i < dfa->lex.maxrep; i++)\n          {\n            copytoks (dfa, tindex, ntokens);\n            addtok (dfa, QMARK);\n            addtok (dfa, CAT);\n          }\n        dfa->parse.tok = lex (dfa);\n      }\n    else if (dfa->parse.tok == REPMN)\n      {\n        dfa->tindex -= nsubtoks (dfa, dfa->tindex);\n        dfa->parse.tok = lex (dfa);\n        closure (dfa);\n      }\n    else\n      {\n        addtok (dfa, dfa->parse.tok);\n        dfa->parse.tok = lex (dfa);\n      }\n}",
      "lines": 40,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "branch": {
      "start_point": [
        1931,
        0
      ],
      "end_point": [
        1941,
        1
      ],
      "content": "static void\nbranch (struct dfa* dfa)\n{\n  closure (dfa);\n  while (dfa->parse.tok != RPAREN && dfa->parse.tok != OR\n         && dfa->parse.tok >= 0)\n    {\n      closure (dfa);\n      addtok (dfa, CAT);\n    }\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "regexp": {
      "start_point": [
        1943,
        0
      ],
      "end_point": [
        1953,
        1
      ],
      "content": "static void\nregexp (struct dfa *dfa)\n{\n  branch (dfa);\n  while (dfa->parse.tok == OR)\n    {\n      dfa->parse.tok = lex (dfa);\n      branch (dfa);\n      addtok (dfa, OR);\n    }\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "dfaparse": {
      "start_point": [
        1958,
        0
      ],
      "end_point": [
        1984,
        1
      ],
      "content": "static void\ndfaparse (char const *s, size_t len, struct dfa *d)\n{\n  d->lex.ptr = s;\n  d->lex.left = len;\n  d->lex.lasttok = END;\n  d->lex.laststart = true;\n\n  if (!d->syntax.syntax_bits_set)\n    dfaerror (_(\"no syntax specified\"));\n\n  d->parse.tok = lex (d);\n  d->parse.depth = d->depth;\n\n  regexp (d);\n\n  if (d->parse.tok != END)\n    dfaerror (_(\"unbalanced )\"));\n\n  addtok (d, END - d->nregexps);\n  addtok (d, CAT);\n\n  if (d->nregexps)\n    addtok (d, OR);\n\n  ++d->nregexps;\n}",
      "lines": 27,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "copy": {
      "start_point": [
        1989,
        0
      ],
      "end_point": [
        2001,
        1
      ],
      "content": "static void\ncopy (position_set const *src, position_set *dst)\n{\n  if (dst->alloc < src->nelem)\n    {\n      free (dst->elems);\n      dst->elems = xpalloc (NULL, &dst->alloc, src->nelem - dst->alloc, -1,\n                            sizeof *dst->elems);\n    }\n  dst->nelem = src->nelem;\n  if (src->nelem != 0)\n    memcpy (dst->elems, src->elems, src->nelem * sizeof *dst->elems);\n}",
      "lines": 13,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "alloc_position_set": {
      "start_point": [
        2003,
        0
      ],
      "end_point": [
        2009,
        1
      ],
      "content": "static void\nalloc_position_set (position_set *s, size_t size)\n{\n  s->elems = xnmalloc (size, sizeof *s->elems);\n  s->alloc = size;\n  s->nelem = 0;\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "insert": {
      "start_point": [
        2015,
        0
      ],
      "end_point": [
        2039,
        1
      ],
      "content": "static void\ninsert (position p, position_set *s)\n{\n  ptrdiff_t count = s->nelem;\n  ptrdiff_t lo = 0, hi = count;\n  while (lo < hi)\n    {\n      ptrdiff_t mid = (lo + hi) >> 1;\n      if (s->elems[mid].index > p.index)\n        lo = mid + 1;\n      else if (s->elems[mid].index == p.index)\n        {\n          s->elems[mid].constraint |= p.constraint;\n          return;\n        }\n      else\n        hi = mid;\n    }\n\n  s->elems = maybe_realloc (s->elems, count, &s->alloc, -1, sizeof *s->elems);\n  for (ptrdiff_t i = count; i > lo; i--)\n    s->elems[i] = s->elems[i - 1];\n  s->elems[lo] = p;\n  ++s->nelem;\n}",
      "lines": 25,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "merge_constrained": {
      "start_point": [
        2044,
        0
      ],
      "end_point": [
        2077,
        1
      ],
      "content": "static void\nmerge_constrained (position_set const *s1, position_set const *s2,\n                   unsigned int c2, position_set *m)\n{\n  ptrdiff_t i = 0, j = 0;\n\n  if (m->alloc - s1->nelem < s2->nelem)\n    {\n      free (m->elems);\n      m->alloc = s1->nelem;\n      m->elems = xpalloc (NULL, &m->alloc, s2->nelem, -1, sizeof *m->elems);\n    }\n  m->nelem = 0;\n  while (i < s1->nelem || j < s2->nelem)\n    if (! (j < s2->nelem)\n        || (i < s1->nelem && s1->elems[i].index >= s2->elems[j].index))\n      {\n        unsigned int c = ((i < s1->nelem && j < s2->nelem\n                           && s1->elems[i].index == s2->elems[j].index)\n                          ? s2->elems[j++].constraint & c2\n                          : 0);\n        m->elems[m->nelem].index = s1->elems[i].index;\n        m->elems[m->nelem++].constraint = s1->elems[i++].constraint | c;\n      }\n    else\n      {\n        if (s2->elems[j].constraint & c2)\n          {\n            m->elems[m->nelem].index = s2->elems[j].index;\n            m->elems[m->nelem++].constraint = s2->elems[j].constraint & c2;\n          }\n        j++;\n      }\n}",
      "lines": 34,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "merge": {
      "start_point": [
        2081,
        0
      ],
      "end_point": [
        2085,
        1
      ],
      "content": "static void\nmerge (position_set const *s1, position_set const *s2, position_set *m)\n{\n  merge_constrained (s1, s2, -1, m);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "delete": {
      "start_point": [
        2089,
        0
      ],
      "end_point": [
        2112,
        1
      ],
      "content": "static unsigned int\ndelete (size_t del, position_set *s)\n{\n  size_t count = s->nelem;\n  size_t lo = 0, hi = count;\n  while (lo < hi)\n    {\n      size_t mid = (lo + hi) >> 1;\n      if (s->elems[mid].index > del)\n        lo = mid + 1;\n      else if (s->elems[mid].index == del)\n        {\n          unsigned int c = s->elems[mid].constraint;\n          size_t i;\n          for (i = mid; i + 1 < count; i++)\n            s->elems[i] = s->elems[i + 1];\n          s->nelem = i;\n          return c;\n        }\n      else\n        hi = mid;\n    }\n  return 0;\n}",
      "lines": 24,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "unsigned int",
        "unsigned",
        "int"
      ]
    },
    "replace": {
      "start_point": [
        2115,
        0
      ],
      "end_point": [
        2126,
        1
      ],
      "content": "static void\nreplace (position_set *dst, size_t del, position_set *add,\n         unsigned int constraint, position_set *tmp)\n{\n  unsigned int c = delete (del, dst) & constraint;\n\n  if (c)\n    {\n      copy (dst, tmp);\n      merge_constrained (tmp, add, c, dst);\n    }\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "state_index": {
      "start_point": [
        2131,
        0
      ],
      "end_point": [
        2210,
        1
      ],
      "content": "static state_num\nstate_index (struct dfa *d, position_set const *s, int context)\n{\n  size_t hash = 0;\n  int constraint = 0;\n  state_num i;\n  token first_end = 0;\n\n  for (i = 0; i < s->nelem; ++i)\n    hash ^= s->elems[i].index + s->elems[i].constraint;\n\n  /* Try to find a state that exactly matches the proposed one.  */\n  for (i = 0; i < d->sindex; ++i)\n    {\n      if (hash != d->states[i].hash || s->nelem != d->states[i].elems.nelem\n          || context != d->states[i].context)\n        continue;\n      state_num j;\n      for (j = 0; j < s->nelem; ++j)\n        if (s->elems[j].constraint != d->states[i].elems.elems[j].constraint\n            || s->elems[j].index != d->states[i].elems.elems[j].index)\n          break;\n      if (j == s->nelem)\n        return i;\n    }\n\n#ifdef DEBUG\n  fprintf (stderr, \"new state %zd\\n nextpos:\", i);\n  for (state_num j = 0; j < s->nelem; j++)\n    {\n      fprintf (stderr, \" %zu:\", s->elems[j].index);\n      prtok (d->tokens[s->elems[j].index]);\n    }\n  fprintf (stderr, \"\\n context:\");\n  if (context ^ CTX_ANY)\n    {\n      if (context & CTX_NONE)\n        fprintf (stderr, \" CTX_NONE\");\n      if (context & CTX_LETTER)\n        fprintf (stderr, \" CTX_LETTER\");\n      if (context & CTX_NEWLINE)\n        fprintf (stderr, \" CTX_NEWLINE\");\n    }\n  else\n    fprintf (stderr, \" CTX_ANY\");\n  fprintf (stderr, \"\\n\");\n#endif\n\n  for (state_num j = 0; j < s->nelem; j++)\n    {\n      int c = s->elems[j].constraint;\n      if (d->tokens[s->elems[j].index] < 0)\n        {\n          if (succeeds_in_context (c, context, CTX_ANY))\n            constraint |= c;\n          if (!first_end)\n            first_end = d->tokens[s->elems[j].index];\n        }\n      else if (d->tokens[s->elems[j].index] == BACKREF)\n        constraint = NO_CONSTRAINT;\n    }\n\n\n  /* Create a new state.  */\n  d->states = maybe_realloc (d->states, d->sindex, &d->salloc, -1,\n                             sizeof *d->states);\n  d->states[i].hash = hash;\n  alloc_position_set (&d->states[i].elems, s->nelem);\n  copy (s, &d->states[i].elems);\n  d->states[i].context = context;\n  d->states[i].constraint = constraint;\n  d->states[i].first_end = first_end;\n  d->states[i].mbps.nelem = 0;\n  d->states[i].mbps.elems = NULL;\n  d->states[i].mb_trindex = -1;\n\n  ++d->sindex;\n\n  return i;\n}",
      "lines": 80,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "state_num"
      ]
    },
    "epsclosure": {
      "start_point": [
        2217,
        0
      ],
      "end_point": [
        2262,
        1
      ],
      "content": "static void\nepsclosure (position_set *initial, struct dfa const *d)\n{\n  position_set tmp;\n  alloc_position_set (&tmp, d->nleaves);\n  for (size_t i = 0; i < d->tindex; ++i)\n    if (d->follows[i].nelem > 0 && d->tokens[i] >= NOTCHAR\n        && d->tokens[i] != BACKREF && d->tokens[i] != ANYCHAR\n        && d->tokens[i] != MBCSET && d->tokens[i] < CSET)\n      {\n        unsigned int constraint;\n        switch (d->tokens[i])\n          {\n          case BEGLINE:\n            constraint = BEGLINE_CONSTRAINT;\n            break;\n          case ENDLINE:\n            constraint = ENDLINE_CONSTRAINT;\n            break;\n          case BEGWORD:\n            constraint = BEGWORD_CONSTRAINT;\n            break;\n          case ENDWORD:\n            constraint = ENDWORD_CONSTRAINT;\n            break;\n          case LIMWORD:\n            constraint = LIMWORD_CONSTRAINT;\n            break;\n          case NOTLIMWORD:\n            constraint = NOTLIMWORD_CONSTRAINT;\n            break;\n          default:\n            constraint = NO_CONSTRAINT;\n            break;\n          }\n\n        delete (i, &d->follows[i]);\n\n        for (size_t j = 0; j < d->tindex; j++)\n          if (i != j && d->follows[j].nelem > 0)\n            replace (&d->follows[j], i, &d->follows[i], constraint, &tmp);\n\n        replace (initial, i, &d->follows[i], constraint, &tmp);\n      }\n  free (tmp.elems);\n}",
      "lines": 46,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "charclass_context": {
      "start_point": [
        2267,
        0
      ],
      "end_point": [
        2283,
        1
      ],
      "content": "static int\ncharclass_context (struct dfa const *dfa, charclass const *c)\n{\n  int context = 0;\n\n  for (unsigned int j = 0; j < CHARCLASS_WORDS; ++j)\n    {\n      if (c->w[j] & dfa->syntax.newline.w[j])\n        context |= CTX_NEWLINE;\n      if (c->w[j] & dfa->syntax.letters.w[j])\n        context |= CTX_LETTER;\n      if (c->w[j] & ~(dfa->syntax.letters.w[j] | dfa->syntax.newline.w[j]))\n        context |= CTX_NONE;\n    }\n\n  return context;\n}",
      "lines": 17,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "state_separate_contexts": {
      "start_point": [
        2291,
        0
      ],
      "end_point": [
        2305,
        1
      ],
      "content": "static int _GL_ATTRIBUTE_PURE\nstate_separate_contexts (position_set const *s)\n{\n  int separate_contexts = 0;\n\n  for (size_t j = 0; j < s->nelem; j++)\n    {\n      if (prev_newline_dependent (s->elems[j].constraint))\n        separate_contexts |= CTX_NEWLINE;\n      if (prev_letter_dependent (s->elems[j].constraint))\n        separate_contexts |= CTX_LETTER;\n    }\n\n  return separate_contexts;\n}",
      "lines": 15,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "dfaanalyze": {
      "start_point": [
        2360,
        0
      ],
      "end_point": [
        2568,
        1
      ],
      "content": "static void\ndfaanalyze (struct dfa *d, bool searchflag)\n{\n  /* Array allocated to hold position sets.  */\n  position *posalloc = xnmalloc (d->nleaves, 2 * sizeof *posalloc);\n  /* Firstpos and lastpos elements.  */\n  position *firstpos = posalloc + d->nleaves;\n  position *lastpos = firstpos + d->nleaves;\n\n  /* Stack for element counts and nullable flags.  */\n  struct\n  {\n    /* Whether the entry is nullable.  */\n    bool nullable;\n\n    /* Counts of firstpos and lastpos sets.  */\n    size_t nfirstpos;\n    size_t nlastpos;\n  } *stkalloc = xnmalloc (d->depth, sizeof *stkalloc), *stk = stkalloc;\n\n  position_set merged;          /* Result of merging sets.  */\n\n#ifdef DEBUG\n  fprintf (stderr, \"dfaanalyze:\\n\");\n  for (size_t i = 0; i < d->tindex; ++i)\n    {\n      fprintf (stderr, \" %zu:\", i);\n      prtok (d->tokens[i]);\n    }\n  putc ('\\n', stderr);\n#endif\n\n  d->searchflag = searchflag;\n  alloc_position_set (&merged, d->nleaves);\n  d->follows = xcalloc (d->tindex, sizeof *d->follows);\n\n  for (size_t i = 0; i < d->tindex; ++i)\n    {\n      switch (d->tokens[i])\n        {\n        case EMPTY:\n          /* The empty set is nullable.  */\n          stk->nullable = true;\n\n          /* The firstpos and lastpos of the empty leaf are both empty.  */\n          stk->nfirstpos = stk->nlastpos = 0;\n          stk++;\n          break;\n\n        case STAR:\n        case PLUS:\n          /* Every element in the firstpos of the argument is in the follow\n             of every element in the lastpos.  */\n          {\n            position_set tmp;\n            tmp.nelem = stk[-1].nfirstpos;\n            tmp.elems = firstpos;\n            position *pos = lastpos;\n            for (size_t j = 0; j < stk[-1].nlastpos; j++)\n              {\n                merge (&tmp, &d->follows[pos[j].index], &merged);\n                copy (&merged, &d->follows[pos[j].index]);\n              }\n          }\n          FALLTHROUGH;\n        case QMARK:\n          /* A QMARK or STAR node is automatically nullable.  */\n          if (d->tokens[i] != PLUS)\n            stk[-1].nullable = true;\n          break;\n\n        case CAT:\n          /* Every element in the firstpos of the second argument is in the\n             follow of every element in the lastpos of the first argument.  */\n          {\n            position_set tmp;\n            tmp.nelem = stk[-1].nfirstpos;\n            tmp.elems = firstpos;\n            position *pos = lastpos + stk[-1].nlastpos;\n            for (size_t j = 0; j < stk[-2].nlastpos; j++)\n              {\n                merge (&tmp, &d->follows[pos[j].index], &merged);\n                copy (&merged, &d->follows[pos[j].index]);\n              }\n          }\n\n          /* The firstpos of a CAT node is the firstpos of the first argument,\n             union that of the second argument if the first is nullable.  */\n          if (stk[-2].nullable)\n            stk[-2].nfirstpos += stk[-1].nfirstpos;\n          else\n            firstpos += stk[-1].nfirstpos;\n\n          /* The lastpos of a CAT node is the lastpos of the second argument,\n             union that of the first argument if the second is nullable.  */\n          if (stk[-1].nullable)\n            stk[-2].nlastpos += stk[-1].nlastpos;\n          else\n            {\n              position *pos = lastpos + stk[-2].nlastpos;\n              for (size_t j = stk[-1].nlastpos; j-- > 0;)\n                pos[j] = lastpos[j];\n              lastpos += stk[-2].nlastpos;\n              stk[-2].nlastpos = stk[-1].nlastpos;\n            }\n\n          /* A CAT node is nullable if both arguments are nullable.  */\n          stk[-2].nullable &= stk[-1].nullable;\n          stk--;\n          break;\n\n        case OR:\n          /* The firstpos is the union of the firstpos of each argument.  */\n          stk[-2].nfirstpos += stk[-1].nfirstpos;\n\n          /* The lastpos is the union of the lastpos of each argument.  */\n          stk[-2].nlastpos += stk[-1].nlastpos;\n\n          /* An OR node is nullable if either argument is nullable.  */\n          stk[-2].nullable |= stk[-1].nullable;\n          stk--;\n          break;\n\n        default:\n          /* Anything else is a nonempty position.  (Note that special\n             constructs like \\< are treated as nonempty strings here;\n             an \"epsilon closure\" effectively makes them nullable later.\n             Backreferences have to get a real position so we can detect\n             transitions on them later.  But they are nullable.  */\n          stk->nullable = d->tokens[i] == BACKREF;\n\n          /* This position is in its own firstpos and lastpos.  */\n          stk->nfirstpos = stk->nlastpos = 1;\n          stk++;\n\n          --firstpos, --lastpos;\n          firstpos->index = lastpos->index = i;\n          firstpos->constraint = lastpos->constraint = NO_CONSTRAINT;\n\n          break;\n        }\n#ifdef DEBUG\n      /* ... balance the above nonsyntactic #ifdef goo...  */\n      fprintf (stderr, \"node %zu:\", i);\n      prtok (d->tokens[i]);\n      putc ('\\n', stderr);\n      fprintf (stderr,\n               stk[-1].nullable ? \" nullable: yes\\n\" : \" nullable: no\\n\");\n      fprintf (stderr, \" firstpos:\");\n      for (size_t j = stk[-1].nfirstpos; j-- > 0;)\n        {\n          fprintf (stderr, \" %zu:\", firstpos[j].index);\n          prtok (d->tokens[firstpos[j].index]);\n        }\n      fprintf (stderr, \"\\n lastpos:\");\n      for (size_t j = stk[-1].nlastpos; j-- > 0;)\n        {\n          fprintf (stderr, \" %zu:\", lastpos[j].index);\n          prtok (d->tokens[lastpos[j].index]);\n        }\n      putc ('\\n', stderr);\n#endif\n    }\n\n#ifdef DEBUG\n  for (size_t i = 0; i < d->tindex; ++i)\n    if (d->tokens[i] < NOTCHAR || d->tokens[i] == BACKREF\n        || d->tokens[i] == ANYCHAR || d->tokens[i] == MBCSET\n        || d->tokens[i] >= CSET)\n      {\n        fprintf (stderr, \"follows(%zu:\", i);\n        prtok (d->tokens[i]);\n        fprintf (stderr, \"):\");\n        for (size_t j = d->follows[i].nelem; j-- > 0;)\n          {\n            fprintf (stderr, \" %zu:\", d->follows[i].elems[j].index);\n            prtok (d->tokens[d->follows[i].elems[j].index]);\n          }\n        putc ('\\n', stderr);\n      }\n#endif\n\n  /* Get the epsilon closure of the firstpos of the regexp.  The result will\n     be the set of positions of state 0.  */\n  merged.nelem = 0;\n  for (size_t i = 0; i < stk[-1].nfirstpos; ++i)\n    insert (firstpos[i], &merged);\n\n  /* For each follow set that is the follow set of a real position, replace\n     it with its epsilon closure.  */\n  epsclosure (&merged, d);\n\n  /* Context wanted by some position.  */\n  int separate_contexts = state_separate_contexts (&merged);\n\n  /* Build the initial state.  */\n  if (separate_contexts & CTX_NEWLINE)\n    state_index (d, &merged, CTX_NEWLINE);\n  d->initstate_notbol = d->min_trcount\n    = state_index (d, &merged, separate_contexts ^ CTX_ANY);\n  if (separate_contexts & CTX_LETTER)\n    d->min_trcount = state_index (d, &merged, CTX_LETTER);\n  d->min_trcount++;\n  d->trcount = 0;\n\n  free (posalloc);\n  free (stkalloc);\n  free (merged.elems);\n}",
      "lines": 209,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "realloc_trans_if_necessary": {
      "start_point": [
        2571,
        0
      ],
      "end_point": [
        2603,
        1
      ],
      "content": "static void\nrealloc_trans_if_necessary (struct dfa *d)\n{\n  state_num oldalloc = d->tralloc;\n  if (oldalloc < d->sindex)\n    {\n      state_num **realtrans = d->trans ? d->trans - 2 : NULL;\n      ptrdiff_t newalloc1 = realtrans ? d->tralloc + 2 : 0;\n      realtrans = xpalloc (realtrans, &newalloc1, d->sindex - oldalloc,\n                           -1, sizeof *realtrans);\n      realtrans[0] = realtrans[1] = NULL;\n      d->trans = realtrans + 2;\n      ptrdiff_t newalloc = d->tralloc = newalloc1 - 2;\n      d->fails = xnrealloc (d->fails, newalloc, sizeof *d->fails);\n      d->success = xnrealloc (d->success, newalloc, sizeof *d->success);\n      d->newlines = xnrealloc (d->newlines, newalloc, sizeof *d->newlines);\n      if (d->localeinfo.multibyte)\n        {\n          realtrans = d->mb_trans ? d->mb_trans - 2 : NULL;\n          realtrans = xnrealloc (realtrans, newalloc1, sizeof *realtrans);\n          if (oldalloc == 0)\n            realtrans[0] = realtrans[1] = NULL;\n          d->mb_trans = realtrans + 2;\n        }\n      for (; oldalloc < newalloc; oldalloc++)\n        {\n          d->trans[oldalloc] = NULL;\n          d->fails[oldalloc] = NULL;\n          if (d->localeinfo.multibyte)\n            d->mb_trans[oldalloc] = NULL;\n        }\n    }\n}",
      "lines": 33,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "build_state": {
      "start_point": [
        2638,
        0
      ],
      "end_point": [
        2921,
        1
      ],
      "content": "static state_num\nbuild_state (state_num s, struct dfa *d, unsigned char uc)\n{\n  position_set follows;         /* Union of the follows of the group.  */\n  position_set tmp;             /* Temporary space for merging sets.  */\n  state_num state;              /* New state.  */\n  state_num state_newline;      /* New state on a newline transition.  */\n  state_num state_letter;       /* New state on a letter transition.  */\n\n#ifdef DEBUG\n  fprintf (stderr, \"build state %td\\n\", s);\n#endif\n\n  /* A pointer to the new transition table, and the table itself.  */\n  state_num **ptrans = (accepting (s, d) ? d->fails : d->trans) + s;\n  state_num *trans = *ptrans;\n\n  if (!trans)\n    {\n      /* MAX_TRCOUNT is an arbitrary upper limit on the number of\n         transition tables that can exist at once, other than for\n         initial states.  Often-used transition tables are quickly\n         rebuilt, whereas rarely-used ones are cleared away.  */\n      if (MAX_TRCOUNT <= d->trcount)\n        {\n          for (state_num i = d->min_trcount; i < d->tralloc; i++)\n            {\n              free (d->trans[i]);\n              free (d->fails[i]);\n              d->trans[i] = d->fails[i] = NULL;\n            }\n          d->trcount = 0;\n        }\n\n      d->trcount++;\n      *ptrans = trans = xmalloc (NOTCHAR * sizeof *trans);\n\n      /* Fill transition table with a default value which means that the\n         transited state has not been calculated yet.  */\n      for (int i = 0; i < NOTCHAR; i++)\n        trans[i] = -2;\n    }\n\n  /* Set up the success bits for this state.  */\n  d->success[s] = 0;\n  if (accepts_in_context (d->states[s].context, CTX_NEWLINE, s, d))\n    d->success[s] |= CTX_NEWLINE;\n  if (accepts_in_context (d->states[s].context, CTX_LETTER, s, d))\n    d->success[s] |= CTX_LETTER;\n  if (accepts_in_context (d->states[s].context, CTX_NONE, s, d))\n    d->success[s] |= CTX_NONE;\n\n  /* Positions that match the input char.  */\n  leaf_set group;\n  group.elems = xnmalloc (d->nleaves, sizeof *group.elems);\n  group.nelem = 0;\n\n  /* The group's label.  */\n  charclass label;\n  fillset (&label);\n\n  for (size_t i = 0; i < d->states[s].elems.nelem; ++i)\n    {\n      charclass matches;            /* Set of matching characters.  */\n      position pos = d->states[s].elems.elems[i];\n      bool matched = false;\n      if (d->tokens[pos.index] >= 0 && d->tokens[pos.index] < NOTCHAR)\n        {\n          zeroset (&matches);\n          setbit (d->tokens[pos.index], &matches);\n          if (d->tokens[pos.index] == uc)\n            matched = true;\n        }\n      else if (d->tokens[pos.index] >= CSET)\n        {\n          matches = d->charclasses[d->tokens[pos.index] - CSET];\n          if (tstbit (uc, &matches))\n            matched = true;\n        }\n      else if (d->tokens[pos.index] == ANYCHAR)\n        {\n          matches = d->charclasses[d->canychar];\n          if (tstbit (uc, &matches))\n            matched = true;\n\n          /* ANYCHAR must match with a single character, so we must put\n             it to D->states[s].mbps which contains the positions which\n             can match with a single character not a byte.  If all\n             positions which has ANYCHAR does not depend on context of\n             next character, we put the follows instead of it to\n             D->states[s].mbps to optimize.  */\n          if (succeeds_in_context (pos.constraint, d->states[s].context,\n                                   CTX_NONE))\n            {\n              if (d->states[s].mbps.nelem == 0)\n                alloc_position_set (&d->states[s].mbps,\n                                    d->follows[pos.index].nelem);\n              for (size_t j = 0; j < d->follows[pos.index].nelem; j++)\n                insert (d->follows[pos.index].elems[j], &d->states[s].mbps);\n            }\n        }\n      else\n        continue;\n\n      /* Some characters may need to be eliminated from matches because\n         they fail in the current context.  */\n      if (pos.constraint != NO_CONSTRAINT)\n        {\n          if (!succeeds_in_context (pos.constraint,\n                                    d->states[s].context, CTX_NEWLINE))\n            for (size_t j = 0; j < CHARCLASS_WORDS; ++j)\n              matches.w[j] &= ~d->syntax.newline.w[j];\n          if (!succeeds_in_context (pos.constraint,\n                                    d->states[s].context, CTX_LETTER))\n            for (size_t j = 0; j < CHARCLASS_WORDS; ++j)\n              matches.w[j] &= ~d->syntax.letters.w[j];\n          if (!succeeds_in_context (pos.constraint,\n                                    d->states[s].context, CTX_NONE))\n            for (size_t j = 0; j < CHARCLASS_WORDS; ++j)\n              matches.w[j] &= d->syntax.letters.w[j] | d->syntax.newline.w[j];\n\n          /* If there are no characters left, there's no point in going on.  */\n          if (emptyset (&matches))\n            continue;\n\n          /* If we have reset the bit that made us declare \"matched\", reset\n             that indicator, too.  This is required to avoid an infinite loop\n             with this command: echo cx | LC_ALL=C grep -E 'c\\b[x ]'  */\n          if (!tstbit (uc, &matches))\n            matched = false;\n        }\n\n#ifdef DEBUG\n      fprintf (stderr, \" nextpos %zu:\", pos.index);\n      prtok (d->tokens[pos.index]);\n      fprintf (stderr, \" of\");\n      for (size_t j = 0; j < NOTCHAR; j++)\n        if (tstbit (j, &matches))\n          fprintf (stderr, \" 0x%02zx\", j);\n      fprintf (stderr, \"\\n\");\n#endif\n\n      if (matched)\n        {\n          for (size_t k = 0; k < CHARCLASS_WORDS; ++k)\n            label.w[k] &= matches.w[k];\n          group.elems[group.nelem++] = pos.index;\n        }\n      else\n        {\n          for (size_t k = 0; k < CHARCLASS_WORDS; ++k)\n            label.w[k] &= ~matches.w[k];\n        }\n    }\n\n  alloc_position_set (&follows, d->nleaves);\n  alloc_position_set (&tmp, d->nleaves);\n\n  if (group.nelem > 0)\n    {\n      follows.nelem = 0;\n\n      /* Find the union of the follows of the positions of the group.\n         This is a hideously inefficient loop.  Fix it someday.  */\n      for (size_t j = 0; j < group.nelem; ++j)\n        for (size_t k = 0; k < d->follows[group.elems[j]].nelem; ++k)\n          insert (d->follows[group.elems[j]].elems[k], &follows);\n\n      /* If we are building a searching matcher, throw in the positions\n         of state 0 as well, if possible.  */\n      if (d->searchflag)\n        {\n          /* If a token in follows.elems is not 1st byte of a multibyte\n             character, or the states of follows must accept the bytes\n             which are not 1st byte of the multibyte character.\n             Then, if a state of follows encounters a byte, it must not be\n             a 1st byte of a multibyte character nor a single byte character.\n             In this case, do not add state[0].follows to next state, because\n             state[0] must accept 1st-byte.\n\n             For example, suppose <sb a> is a certain single byte character,\n             <mb A> is a certain multibyte character, and the codepoint of\n             <sb a> equals the 2nd byte of the codepoint of <mb A>.  When\n             state[0] accepts <sb a>, state[i] transits to state[i+1] by\n             accepting the 1st byte of <mb A>, and state[i+1] accepts the\n             2nd byte of <mb A>, if state[i+1] encounters the codepoint of\n             <sb a>, it must not be <sb a> but the 2nd byte of <mb A>, so do\n             not add state[0].  */\n\n          bool mergeit = !d->localeinfo.multibyte;\n          if (!mergeit)\n            {\n              mergeit = true;\n              for (size_t j = 0; mergeit && j < follows.nelem; j++)\n                mergeit &= d->multibyte_prop[follows.elems[j].index];\n            }\n          if (mergeit)\n            {\n              merge (&d->states[0].elems, &follows, &tmp);\n              copy (&tmp, &follows);\n            }\n        }\n\n      /* Find out if the new state will want any context information,\n         by calculating possible contexts that the group can match,\n         and separate contexts that the new state wants to know.  */\n      int possible_contexts = charclass_context (d, &label);\n      int separate_contexts = state_separate_contexts (&follows);\n\n      /* Find the state(s) corresponding to the union of the follows.  */\n      if (possible_contexts & ~separate_contexts)\n        state = state_index (d, &follows, separate_contexts ^ CTX_ANY);\n      else\n        state = -1;\n      if (separate_contexts & possible_contexts & CTX_NEWLINE)\n        state_newline = state_index (d, &follows, CTX_NEWLINE);\n      else\n        state_newline = state;\n      if (separate_contexts & possible_contexts & CTX_LETTER)\n        state_letter = state_index (d, &follows, CTX_LETTER);\n      else\n        state_letter = state;\n\n      /* Reallocate now, to reallocate any newline transition properly.  */\n      realloc_trans_if_necessary (d);\n    }\n\n  /* If we are a searching matcher, the default transition is to a state\n     containing the positions of state 0, otherwise the default transition\n     is to fail miserably.  */\n  else if (d->searchflag)\n    {\n      state_newline = 0;\n      state_letter = d->min_trcount - 1;\n      state = d->initstate_notbol;\n    }\n  else\n    {\n      state_newline = -1;\n      state_letter = -1;\n      state = -1;\n    }\n\n  /* Set the transitions for each character in the label.  */\n  for (size_t i = 0; i < NOTCHAR; i++)\n    if (tstbit (i, &label))\n      switch (d->syntax.sbit[i])\n        {\n        case CTX_NEWLINE:\n          trans[i] = state_newline;\n          break;\n        case CTX_LETTER:\n          trans[i] = state_letter;\n          break;\n        default:\n          trans[i] = state;\n          break;\n        }\n\n#ifdef DEBUG\n  fprintf (stderr, \"trans table %td\", s);\n  for (size_t i = 0; i < NOTCHAR; ++i)\n    {\n      if (!(i & 0xf))\n        fprintf (stderr, \"\\n\");\n      fprintf (stderr, \" %2td\", trans[i]);\n    }\n  fprintf (stderr, \"\\n\");\n#endif\n\n  free (group.elems);\n  free (follows.elems);\n  free (tmp.elems);\n\n  /* Keep the newline transition in a special place so we can use it as\n     a sentinel.  */\n  if (tstbit (d->syntax.eolbyte, &label))\n    {\n      d->newlines[s] = trans[d->syntax.eolbyte];\n      trans[d->syntax.eolbyte] = -1;\n    }\n\n  return trans[uc];\n}",
      "lines": 284,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "state_num"
      ]
    },
    "transit_state_singlebyte": {
      "start_point": [
        2929,
        0
      ],
      "end_point": [
        2954,
        1
      ],
      "content": "static state_num\ntransit_state_singlebyte (struct dfa *d, state_num s, unsigned char const **pp)\n{\n  state_num *t;\n\n  if (d->trans[s])\n    t = d->trans[s];\n  else if (d->fails[s])\n    t = d->fails[s];\n  else\n    {\n      build_state (s, d, **pp);\n      if (d->trans[s])\n        t = d->trans[s];\n      else\n        {\n          t = d->fails[s];\n          assert (t);\n        }\n    }\n\n  if (t[**pp] == -2)\n    build_state (s, d, **pp);\n\n  return t[*(*pp)++];\n}",
      "lines": 26,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "state_num"
      ]
    },
    "transit_state": {
      "start_point": [
        2959,
        0
      ],
      "end_point": [
        3028,
        1
      ],
      "content": "static state_num\ntransit_state (struct dfa *d, state_num s, unsigned char const **pp,\n               unsigned char const *end)\n{\n  wint_t wc;\n\n  int mbclen = mbs_to_wchar (&wc, (char const *) *pp, end - *pp, d);\n\n  /* This state has some operators which can match a multibyte character.  */\n  d->mb_follows.nelem = 0;\n\n  /* Calculate the state which can be reached from the state 's' by\n     consuming 'mbclen' single bytes from the buffer.  */\n  state_num s1 = s;\n  int mbci;\n  for (mbci = 0; mbci < mbclen && (mbci == 0 || d->min_trcount <= s); mbci++)\n    s = transit_state_singlebyte (d, s, pp);\n  *pp += mbclen - mbci;\n\n  if (wc == WEOF)\n    {\n      /* It is an invalid character, so ANYCHAR is not accepted.  */\n      return s;\n    }\n\n  /* If all positions which have ANYCHAR do not depend on the context\n     of the next character, calculate the next state with\n     pre-calculated follows and cache the result.  */\n  if (d->states[s1].mb_trindex < 0)\n    {\n      if (MAX_TRCOUNT <= d->mb_trcount)\n        {\n          state_num s3;\n          for (s3 = -1; s3 < d->tralloc; s3++)\n            {\n              free (d->mb_trans[s3]);\n              d->mb_trans[s3] = NULL;\n            }\n\n          for (state_num i = 0; i < d->sindex; i++)\n            d->states[i].mb_trindex = -1;\n          d->mb_trcount = 0;\n        }\n      d->states[s1].mb_trindex = d->mb_trcount++;\n    }\n\n  if (! d->mb_trans[s])\n    {\n      enum { TRANSPTR_SIZE = sizeof *d->mb_trans[s] };\n      enum { TRANSALLOC_SIZE = MAX_TRCOUNT * TRANSPTR_SIZE };\n      d->mb_trans[s] = xmalloc (TRANSALLOC_SIZE);\n      for (int i = 0; i < MAX_TRCOUNT; i++)\n        d->mb_trans[s][i] = -1;\n    }\n  else if (d->mb_trans[s][d->states[s1].mb_trindex] >= 0)\n    return d->mb_trans[s][d->states[s1].mb_trindex];\n\n  if (s == -1)\n    copy (&d->states[s1].mbps, &d->mb_follows);\n  else\n    merge (&d->states[s1].mbps, &d->states[s].elems, &d->mb_follows);\n\n  int separate_contexts = state_separate_contexts (&d->mb_follows);\n  state_num s2 = state_index (d, &d->mb_follows, separate_contexts ^ CTX_ANY);\n  realloc_trans_if_necessary (d);\n\n  d->mb_trans[s][d->states[s1].mb_trindex] = s2;\n\n  return s2;\n}",
      "lines": 70,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "state_num"
      ]
    },
    "skip_remains_mb": {
      "start_point": [
        3045,
        0
      ],
      "end_point": [
        3058,
        1
      ],
      "content": "static unsigned char const *\nskip_remains_mb (struct dfa *d, unsigned char const *p,\n                 unsigned char const *mbp, char const *end)\n{\n  if (d->syntax.never_trail[*p])\n    return p;\n  while (mbp < p)\n    {\n      wint_t wc;\n      mbp += mbs_to_wchar (&wc, (char const *) mbp,\n                           end - (char const *) mbp, d);\n    }\n  return mbp;\n}",
      "lines": 14,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "unsigned char",
        "unsigned",
        "char",
        "const",
        "const",
        "*\nskip_remains_mb (struct dfa *d, unsigned char const *p,\n                 unsigned char const *mbp, char const *end)",
        "*"
      ]
    },
    "dfaexec_main": {
      "start_point": [
        3080,
        0
      ],
      "end_point": [
        3258,
        1
      ],
      "content": "static inline char *\ndfaexec_main (struct dfa *d, char const *begin, char *end, bool allow_nl,\n              size_t *count, bool multibyte)\n{\n  if (MAX_TRCOUNT <= d->sindex)\n    {\n      for (state_num s = d->min_trcount; s < d->sindex; s++)\n        {\n          free (d->states[s].elems.elems);\n          free (d->states[s].mbps.elems);\n        }\n      d->sindex = d->min_trcount;\n\n      if (d->trans)\n        {\n          for (state_num s = 0; s < d->tralloc; s++)\n            {\n              free (d->trans[s]);\n              free (d->fails[s]);\n              d->trans[s] = d->fails[s] = NULL;\n            }\n          d->trcount = 0;\n        }\n\n      if (d->localeinfo.multibyte && d->mb_trans)\n        {\n          for (state_num s = -1; s < d->tralloc; s++)\n            {\n              free (d->mb_trans[s]);\n              d->mb_trans[s] = NULL;\n            }\n          for (state_num s = 0; s < d->min_trcount; s++)\n            d->states[s].mb_trindex = -1;\n          d->mb_trcount = 0;\n        }\n    }\n\n  if (!d->tralloc)\n    realloc_trans_if_necessary (d);\n\n  /* Current state.  */\n  state_num s = 0, s1 = 0;\n\n  /* Current input character.  */\n  unsigned char const *p = (unsigned char const *) begin;\n  unsigned char const *mbp = p;\n\n  /* Copy of d->trans so it can be optimized into a register.  */\n  state_num **trans = d->trans;\n  unsigned char eol = d->syntax.eolbyte;  /* Likewise for eolbyte.  */\n  unsigned char saved_end = *(unsigned char *) end;\n  *end = eol;\n\n  if (multibyte)\n    {\n      memset (&d->mbs, 0, sizeof d->mbs);\n      if (d->mb_follows.alloc == 0)\n        alloc_position_set (&d->mb_follows, d->nleaves);\n    }\n\n  size_t nlcount = 0;\n  for (;;)\n    {\n      state_num *t;\n      while ((t = trans[s]) != NULL)\n        {\n          if (s < d->min_trcount)\n            {\n              if (!multibyte || d->states[s].mbps.nelem == 0)\n                {\n                  while (t[*p] == s)\n                    p++;\n                }\n              if (multibyte)\n                p = mbp = skip_remains_mb (d, p, mbp, end);\n            }\n\n          if (multibyte)\n            {\n              s1 = s;\n\n              if (d->states[s].mbps.nelem == 0\n                  || d->localeinfo.sbctowc[*p] != WEOF || (char *) p >= end)\n                {\n                  /* If an input character does not match ANYCHAR, do it\n                     like a single-byte character.  */\n                  s = t[*p++];\n                }\n              else\n                {\n                  s = transit_state (d, s, &p, (unsigned char *) end);\n                  mbp = p;\n                  trans = d->trans;\n                }\n            }\n          else\n            {\n              s1 = t[*p++];\n              t = trans[s1];\n              if (! t)\n                {\n                  state_num tmp = s;\n                  s = s1;\n                  s1 = tmp;     /* swap */\n                  break;\n                }\n              if (s < d->min_trcount)\n                {\n                  while (t[*p] == s1)\n                    p++;\n                }\n              s = t[*p++];\n            }\n        }\n\n      if (s < 0)\n        {\n          if (s == -2)\n            {\n              s = build_state (s1, d, p[-1]);\n              trans = d->trans;\n            }\n          else if ((char *) p <= end && p[-1] == eol && 0 <= d->newlines[s1])\n            {\n              /* The previous character was a newline.  Count it, and skip\n                 checking of multibyte character boundary until here.  */\n              nlcount++;\n              mbp = p;\n\n              s = (allow_nl ? d->newlines[s1]\n                   : d->syntax.sbit[eol] == CTX_NEWLINE ? 0\n                   : d->syntax.sbit[eol] == CTX_LETTER ? d->min_trcount - 1\n                   : d->initstate_notbol);\n            }\n          else\n            {\n              p = NULL;\n              goto done;\n            }\n        }\n      else if (d->fails[s])\n        {\n          if ((d->success[s] & d->syntax.sbit[*p])\n              || ((char *) p == end\n                  && accepts_in_context (d->states[s].context, CTX_NEWLINE, s,\n                                         d)))\n            goto done;\n\n          if (multibyte && s < d->min_trcount)\n            p = mbp = skip_remains_mb (d, p, mbp, end);\n\n          s1 = s;\n          if (!multibyte || d->states[s].mbps.nelem == 0\n              || d->localeinfo.sbctowc[*p] != WEOF || (char *) p >= end)\n            {\n              /* If a input character does not match ANYCHAR, do it\n                 like a single-byte character.  */\n              s = d->fails[s][*p++];\n            }\n          else\n            {\n              s = transit_state (d, s, &p, (unsigned char *) end);\n              mbp = p;\n              trans = d->trans;\n            }\n        }\n      else\n        {\n          build_state (s, d, p[0]);\n          trans = d->trans;\n        }\n    }\n\n done:\n  if (count)\n    *count += nlcount;\n  *end = saved_end;\n  return (char *) p;\n}",
      "lines": 179,
      "depth": 20,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "char",
        "*\ndfaexec_main (struct dfa *d, char const *begin, char *end, bool allow_nl,\n              size_t *count, bool multibyte)",
        "*"
      ]
    },
    "dfaexec_mb": {
      "start_point": [
        3263,
        0
      ],
      "end_point": [
        3268,
        1
      ],
      "content": "static char *\ndfaexec_mb (struct dfa *d, char const *begin, char *end,\n            bool allow_nl, size_t *count, bool *backref)\n{\n  return dfaexec_main (d, begin, end, allow_nl, count, true);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "char",
        "*\ndfaexec_mb (struct dfa *d, char const *begin, char *end,\n            bool allow_nl, size_t *count, bool *backref)",
        "*"
      ]
    },
    "dfaexec_sb": {
      "start_point": [
        3270,
        0
      ],
      "end_point": [
        3275,
        1
      ],
      "content": "static char *\ndfaexec_sb (struct dfa *d, char const *begin, char *end,\n            bool allow_nl, size_t *count, bool *backref)\n{\n  return dfaexec_main (d, begin, end, allow_nl, count, false);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "char",
        "*\ndfaexec_sb (struct dfa *d, char const *begin, char *end,\n            bool allow_nl, size_t *count, bool *backref)",
        "*"
      ]
    },
    "dfaexec_noop": {
      "start_point": [
        3279,
        0
      ],
      "end_point": [
        3285,
        1
      ],
      "content": "static char *\ndfaexec_noop (struct dfa *d, char const *begin, char *end,\n              bool allow_nl, size_t *count, bool *backref)\n{\n  *backref = true;\n  return (char *) begin;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "char",
        "*\ndfaexec_noop (struct dfa *d, char const *begin, char *end,\n              bool allow_nl, size_t *count, bool *backref)",
        "*"
      ]
    },
    "dfaexec": {
      "start_point": [
        3291,
        0
      ],
      "end_point": [
        3296,
        1
      ],
      "content": "char *\ndfaexec (struct dfa *d, char const *begin, char *end,\n         bool allow_nl, size_t *count, bool *backref)\n{\n  return d->dfaexec (d, begin, end, allow_nl, count, backref);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "char",
        "*\ndfaexec (struct dfa *d, char const *begin, char *end,\n         bool allow_nl, size_t *count, bool *backref)",
        "*"
      ]
    },
    "dfasuperset": {
      "start_point": [
        3298,
        0
      ],
      "end_point": [
        3302,
        1
      ],
      "content": "struct dfa *\ndfasuperset (struct dfa const *d)\n{\n  return d->superset;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "struct dfa",
        "struct",
        "dfa",
        "*\ndfasuperset (struct dfa const *d)",
        "*"
      ]
    },
    "dfaisfast": {
      "start_point": [
        3304,
        0
      ],
      "end_point": [
        3308,
        1
      ],
      "content": "bool\ndfaisfast (struct dfa const *d)\n{\n  return d->fast;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "bool"
      ]
    },
    "free_mbdata": {
      "start_point": [
        3310,
        0
      ],
      "end_point": [
        3324,
        1
      ],
      "content": "static void\nfree_mbdata (struct dfa *d)\n{\n  free (d->multibyte_prop);\n  free (d->lex.brack.chars);\n  free (d->mb_follows.elems);\n\n  if (d->mb_trans)\n    {\n      state_num s;\n      for (s = -1; s < d->tralloc; s++)\n        free (d->mb_trans[s]);\n      free (d->mb_trans - 2);\n    }\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "dfa_supported": {
      "start_point": [
        3327,
        0
      ],
      "end_point": [
        3347,
        1
      ],
      "content": "static bool _GL_ATTRIBUTE_PURE\ndfa_supported (struct dfa const *d)\n{\n  for (size_t i = 0; i < d->tindex; i++)\n    {\n      switch (d->tokens[i])\n        {\n        case BEGWORD:\n        case ENDWORD:\n        case LIMWORD:\n        case NOTLIMWORD:\n          if (!d->localeinfo.multibyte)\n            continue;\n          FALLTHROUGH;\n        case BACKREF:\n        case MBCSET:\n          return false;\n        }\n    }\n  return true;\n}",
      "lines": 21,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "bool",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "dfaoptimize": {
      "start_point": [
        3349,
        0
      ],
      "end_point": [
        3386,
        1
      ],
      "content": "static void\ndfaoptimize (struct dfa *d)\n{\n  if (!d->localeinfo.using_utf8)\n    return;\n\n  bool have_backref = false;\n  for (size_t i = 0; i < d->tindex; ++i)\n    {\n      switch (d->tokens[i])\n        {\n        case ANYCHAR:\n          /* Lowered.  */\n          abort ();\n        case BACKREF:\n          have_backref = true;\n          break;\n        case MBCSET:\n          /* Requires multi-byte algorithm.  */\n          return;\n        default:\n          break;\n        }\n    }\n\n  if (!have_backref && d->superset)\n    {\n      /* The superset DFA is not likely to be much faster, so remove it.  */\n      dfafree (d->superset);\n      free (d->superset);\n      d->superset = NULL;\n    }\n\n  free_mbdata (d);\n  d->localeinfo.multibyte = false;\n  d->dfaexec = dfaexec_sb;\n  d->fast = true;\n}",
      "lines": 38,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "dfassbuild": {
      "start_point": [
        3388,
        0
      ],
      "end_point": [
        3467,
        1
      ],
      "content": "static void\ndfassbuild (struct dfa *d)\n{\n  struct dfa *sup = dfaalloc ();\n\n  *sup = *d;\n  sup->localeinfo.multibyte = false;\n  sup->dfaexec = dfaexec_sb;\n  sup->multibyte_prop = NULL;\n  sup->superset = NULL;\n  sup->states = NULL;\n  sup->sindex = 0;\n  sup->follows = NULL;\n  sup->tralloc = 0;\n  sup->trans = NULL;\n  sup->fails = NULL;\n  sup->success = NULL;\n  sup->newlines = NULL;\n\n  sup->charclasses = xnmalloc (sup->calloc, sizeof *sup->charclasses);\n  if (d->cindex)\n    {\n      memcpy (sup->charclasses, d->charclasses,\n              d->cindex * sizeof *sup->charclasses);\n    }\n\n  sup->tokens = xnmalloc (d->tindex, 2 * sizeof *sup->tokens);\n  sup->talloc = d->tindex * 2;\n\n  bool have_achar = false;\n  bool have_nchar = false;\n  size_t j;\n  for (size_t i = j = 0; i < d->tindex; i++)\n    {\n      switch (d->tokens[i])\n        {\n        case ANYCHAR:\n        case MBCSET:\n        case BACKREF:\n          {\n            charclass ccl;\n            fillset (&ccl);\n            sup->tokens[j++] = CSET + charclass_index (sup, &ccl);\n            sup->tokens[j++] = STAR;\n            if (d->tokens[i + 1] == QMARK || d->tokens[i + 1] == STAR\n                || d->tokens[i + 1] == PLUS)\n              i++;\n            have_achar = true;\n          }\n          break;\n        case BEGWORD:\n        case ENDWORD:\n        case LIMWORD:\n        case NOTLIMWORD:\n          if (d->localeinfo.multibyte)\n            {\n              /* These constraints aren't supported in a multibyte locale.\n                 Ignore them in the superset DFA.  */\n              sup->tokens[j++] = EMPTY;\n              break;\n            }\n          FALLTHROUGH;\n        default:\n          sup->tokens[j++] = d->tokens[i];\n          if ((0 <= d->tokens[i] && d->tokens[i] < NOTCHAR)\n              || d->tokens[i] >= CSET)\n            have_nchar = true;\n          break;\n        }\n    }\n  sup->tindex = j;\n\n  if (have_nchar && (have_achar || d->localeinfo.multibyte))\n    d->superset = sup;\n  else\n    {\n      dfafree (sup);\n      free (sup);\n    }\n}",
      "lines": 80,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "dfacomp": {
      "start_point": [
        3470,
        0
      ],
      "end_point": [
        3491,
        1
      ],
      "content": "void\ndfacomp (char const *s, size_t len, struct dfa *d, bool searchflag)\n{\n  dfaparse (s, len, d);\n  dfassbuild (d);\n\n  if (dfa_supported (d))\n    {\n      dfaoptimize (d);\n      dfaanalyze (d, searchflag);\n    }\n  else\n    {\n      d->dfaexec = dfaexec_noop;\n    }\n\n  if (d->superset)\n    {\n      d->fast = true;\n      dfaanalyze (d->superset, searchflag);\n    }\n}",
      "lines": 22,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "dfafree": {
      "start_point": [
        3494,
        0
      ],
      "end_point": [
        3533,
        1
      ],
      "content": "void\ndfafree (struct dfa *d)\n{\n  free (d->charclasses);\n  free (d->tokens);\n\n  if (d->localeinfo.multibyte)\n    free_mbdata (d);\n\n  for (size_t i = 0; i < d->sindex; ++i)\n    {\n      free (d->states[i].elems.elems);\n      free (d->states[i].mbps.elems);\n    }\n  free (d->states);\n\n  if (d->follows)\n    {\n      for (size_t i = 0; i < d->tindex; ++i)\n        free (d->follows[i].elems);\n      free (d->follows);\n    }\n\n  if (d->trans)\n    {\n      for (size_t i = 0; i < d->tralloc; ++i)\n        {\n          free (d->trans[i]);\n          free (d->fails[i]);\n        }\n\n      free (d->trans - 2);\n      free (d->fails);\n      free (d->newlines);\n      free (d->success);\n    }\n\n  if (d->superset)\n    dfafree (d->superset);\n}",
      "lines": 40,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "icatalloc": {
      "start_point": [
        3617,
        0
      ],
      "end_point": [
        3627,
        1
      ],
      "content": "static char *\nicatalloc (char *old, char const *new)\n{\n  size_t newsize = strlen (new);\n  if (newsize == 0)\n    return old;\n  size_t oldsize = strlen (old);\n  char *result = xrealloc (old, oldsize + newsize + 1);\n  memcpy (result + oldsize, new, newsize + 1);\n  return result;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nicatalloc (char *old, char const *new)",
        "*"
      ]
    },
    "freelist": {
      "start_point": [
        3629,
        0
      ],
      "end_point": [
        3634,
        1
      ],
      "content": "static void\nfreelist (char **cpp)\n{\n  while (*cpp)\n    free (*cpp++);\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "enlist": {
      "start_point": [
        3636,
        0
      ],
      "end_point": [
        3666,
        1
      ],
      "content": "static char **\nenlist (char **cpp, char *new, size_t len)\n{\n  new = memcpy (xmalloc (len + 1), new, len);\n  new[len] = '\\0';\n  /* Is there already something in the list that's new (or longer)?  */\n  size_t i;\n  for (i = 0; cpp[i] != NULL; ++i)\n    if (strstr (cpp[i], new) != NULL)\n      {\n        free (new);\n        return cpp;\n      }\n  /* Eliminate any obsoleted strings.  */\n  for (size_t j = 0; cpp[j] != NULL; )\n    if (strstr (new, cpp[j]) == NULL)\n      ++j;\n    else\n      {\n        free (cpp[j]);\n        if (--i == j)\n          break;\n        cpp[j] = cpp[i];\n        cpp[i] = NULL;\n      }\n  /* Add the new string.  */\n  cpp = xnrealloc (cpp, i + 2, sizeof *cpp);\n  cpp[i] = new;\n  cpp[i + 1] = NULL;\n  return cpp;\n}",
      "lines": 31,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "char",
        "**\nenlist (char **cpp, char *new, size_t len)",
        "*",
        "*\nenlist (char **cpp, char *new, size_t len)",
        "*"
      ]
    },
    "comsubs": {
      "start_point": [
        3670,
        0
      ],
      "end_point": [
        3692,
        1
      ],
      "content": "static char **\ncomsubs (char *left, char const *right)\n{\n  char **cpp = xzalloc (sizeof *cpp);\n\n  for (char *lcp = left; *lcp != '\\0'; lcp++)\n    {\n      size_t len = 0;\n      char *rcp = strchr (right, *lcp);\n      while (rcp != NULL)\n        {\n          size_t i;\n          for (i = 1; lcp[i] != '\\0' && lcp[i] == rcp[i]; ++i)\n            continue;\n          if (i > len)\n            len = i;\n          rcp = strchr (rcp + 1, *lcp);\n        }\n      if (len != 0)\n        cpp = enlist (cpp, lcp, len);\n    }\n  return cpp;\n}",
      "lines": 23,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "char",
        "**\ncomsubs (char *left, char const *right)",
        "*",
        "*\ncomsubs (char *left, char const *right)",
        "*"
      ]
    },
    "addlists": {
      "start_point": [
        3694,
        0
      ],
      "end_point": [
        3700,
        1
      ],
      "content": "static char **\naddlists (char **old, char **new)\n{\n  for (; *new; new++)\n    old = enlist (old, *new, strlen (*new));\n  return old;\n}",
      "lines": 7,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "char",
        "**\naddlists (char **old, char **new)",
        "*",
        "*\naddlists (char **old, char **new)",
        "*"
      ]
    },
    "inboth": {
      "start_point": [
        3704,
        0
      ],
      "end_point": [
        3720,
        1
      ],
      "content": "static char **\ninboth (char **left, char **right)\n{\n  char **both = xzalloc (sizeof *both);\n\n  for (size_t lnum = 0; left[lnum] != NULL; ++lnum)\n    {\n      for (size_t rnum = 0; right[rnum] != NULL; ++rnum)\n        {\n          char **temp = comsubs (left[lnum], right[rnum]);\n          both = addlists (both, temp);\n          freelist (temp);\n          free (temp);\n        }\n    }\n  return both;\n}",
      "lines": 17,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "char",
        "**\ninboth (char **left, char **right)",
        "*",
        "*\ninboth (char **left, char **right)",
        "*"
      ]
    },
    "allocmust": {
      "start_point": [
        3735,
        0
      ],
      "end_point": [
        3747,
        1
      ],
      "content": "static must *\nallocmust (must *mp, size_t size)\n{\n  must *new_mp = xmalloc (sizeof *new_mp);\n  new_mp->in = xzalloc (sizeof *new_mp->in);\n  new_mp->left = xzalloc (size);\n  new_mp->right = xzalloc (size);\n  new_mp->is = xzalloc (size);\n  new_mp->begline = false;\n  new_mp->endline = false;\n  new_mp->prev = mp;\n  return new_mp;\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "must",
        "*\nallocmust (must *mp, size_t size)",
        "*"
      ]
    },
    "resetmust": {
      "start_point": [
        3749,
        0
      ],
      "end_point": [
        3757,
        1
      ],
      "content": "static void\nresetmust (must *mp)\n{\n  freelist (mp->in);\n  mp->in[0] = NULL;\n  mp->left[0] = mp->right[0] = mp->is[0] = '\\0';\n  mp->begline = false;\n  mp->endline = false;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "freemust": {
      "start_point": [
        3759,
        0
      ],
      "end_point": [
        3768,
        1
      ],
      "content": "static void\nfreemust (must *mp)\n{\n  freelist (mp->in);\n  free (mp->in);\n  free (mp->left);\n  free (mp->right);\n  free (mp->is);\n  free (mp);\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "dfamust": {
      "start_point": [
        3770,
        0
      ],
      "end_point": [
        4005,
        1
      ],
      "content": "struct dfamust *\ndfamust (struct dfa const *d)\n{\n  must *mp = NULL;\n  char const *result = \"\";\n  bool exact = false;\n  bool begline = false;\n  bool endline = false;\n  bool need_begline = false;\n  bool need_endline = false;\n  bool case_fold_unibyte = d->syntax.case_fold && MB_CUR_MAX == 1;\n\n  for (size_t ri = 0; ri < d->tindex; ++ri)\n    {\n      token t = d->tokens[ri];\n      switch (t)\n        {\n        case BEGLINE:\n          mp = allocmust (mp, 2);\n          mp->begline = true;\n          need_begline = true;\n          break;\n        case ENDLINE:\n          mp = allocmust (mp, 2);\n          mp->endline = true;\n          need_endline = true;\n          break;\n        case LPAREN:\n        case RPAREN:\n          assert (!\"neither LPAREN nor RPAREN may appear here\");\n\n        case EMPTY:\n        case BEGWORD:\n        case ENDWORD:\n        case LIMWORD:\n        case NOTLIMWORD:\n        case BACKREF:\n        case ANYCHAR:\n        case MBCSET:\n          mp = allocmust (mp, 2);\n          break;\n\n        case STAR:\n        case QMARK:\n          resetmust (mp);\n          break;\n\n        case OR:\n          {\n            char **new;\n            must *rmp = mp;\n            must *lmp = mp = mp->prev;\n            size_t j, ln, rn, n;\n\n            /* Guaranteed to be.  Unlikely, but ...  */\n            if (streq (lmp->is, rmp->is))\n              {\n                lmp->begline &= rmp->begline;\n                lmp->endline &= rmp->endline;\n              }\n            else\n              {\n                lmp->is[0] = '\\0';\n                lmp->begline = false;\n                lmp->endline = false;\n              }\n            /* Left side--easy */\n            size_t i = 0;\n            while (lmp->left[i] != '\\0' && lmp->left[i] == rmp->left[i])\n              ++i;\n            lmp->left[i] = '\\0';\n            /* Right side */\n            ln = strlen (lmp->right);\n            rn = strlen (rmp->right);\n            n = ln;\n            if (n > rn)\n              n = rn;\n            for (i = 0; i < n; ++i)\n              if (lmp->right[ln - i - 1] != rmp->right[rn - i - 1])\n                break;\n            for (j = 0; j < i; ++j)\n              lmp->right[j] = lmp->right[(ln - i) + j];\n            lmp->right[j] = '\\0';\n            new = inboth (lmp->in, rmp->in);\n            freelist (lmp->in);\n            free (lmp->in);\n            lmp->in = new;\n            freemust (rmp);\n          }\n          break;\n\n        case PLUS:\n          mp->is[0] = '\\0';\n          break;\n\n        case END:\n          assert (!mp->prev);\n          for (size_t i = 0; mp->in[i] != NULL; ++i)\n            if (strlen (mp->in[i]) > strlen (result))\n              result = mp->in[i];\n          if (streq (result, mp->is))\n            {\n              if ((!need_begline || mp->begline) && (!need_endline\n                                                     || mp->endline))\n                exact = true;\n              begline = mp->begline;\n              endline = mp->endline;\n            }\n          goto done;\n\n        case CAT:\n          {\n            must *rmp = mp;\n            must *lmp = mp = mp->prev;\n\n            /* In.  Everything in left, plus everything in\n               right, plus concatenation of\n               left's right and right's left.  */\n            lmp->in = addlists (lmp->in, rmp->in);\n            if (lmp->right[0] != '\\0' && rmp->left[0] != '\\0')\n              {\n                size_t lrlen = strlen (lmp->right);\n                size_t rllen = strlen (rmp->left);\n                char *tp = xmalloc (lrlen + rllen);\n                memcpy (tp, lmp->right, lrlen);\n                memcpy (tp + lrlen, rmp->left, rllen);\n                lmp->in = enlist (lmp->in, tp, lrlen + rllen);\n                free (tp);\n              }\n            /* Left-hand */\n            if (lmp->is[0] != '\\0')\n              lmp->left = icatalloc (lmp->left, rmp->left);\n            /* Right-hand */\n            if (rmp->is[0] == '\\0')\n              lmp->right[0] = '\\0';\n            lmp->right = icatalloc (lmp->right, rmp->right);\n            /* Guaranteed to be */\n            if ((lmp->is[0] != '\\0' || lmp->begline)\n                && (rmp->is[0] != '\\0' || rmp->endline))\n              {\n                lmp->is = icatalloc (lmp->is, rmp->is);\n                lmp->endline = rmp->endline;\n              }\n            else\n              {\n                lmp->is[0] = '\\0';\n                lmp->begline = false;\n                lmp->endline = false;\n              }\n            freemust (rmp);\n          }\n          break;\n\n        case '\\0':\n          /* Not on *my* shift.  */\n          goto done;\n\n        default:\n          if (CSET <= t)\n            {\n              /* If T is a singleton, or if case-folding in a unibyte\n                 locale and T's members all case-fold to the same char,\n                 convert T to one of its members.  Otherwise, do\n                 nothing further with T.  */\n              charclass *ccl = &d->charclasses[t - CSET];\n              int j;\n              for (j = 0; j < NOTCHAR; j++)\n                if (tstbit (j, ccl))\n                  break;\n              if (! (j < NOTCHAR))\n                {\n                  mp = allocmust (mp, 2);\n                  break;\n                }\n              t = j;\n              while (++j < NOTCHAR)\n                if (tstbit (j, ccl)\n                    && ! (case_fold_unibyte\n                          && toupper (j) == toupper (t)))\n                  break;\n              if (j < NOTCHAR)\n                {\n                  mp = allocmust (mp, 2);\n                  break;\n                }\n            }\n\n          size_t rj = ri + 2;\n          if (d->tokens[ri + 1] == CAT)\n            {\n              for (; rj < d->tindex - 1; rj += 2)\n                {\n                  if ((rj != ri && (d->tokens[rj] <= 0\n                                    || NOTCHAR <= d->tokens[rj]))\n                      || d->tokens[rj + 1] != CAT)\n                    break;\n                }\n            }\n          mp = allocmust (mp, ((rj - ri) >> 1) + 1);\n          mp->is[0] = mp->left[0] = mp->right[0]\n            = case_fold_unibyte ? toupper (t) : t;\n\n          size_t i;\n          for (i = 1; ri + 2 < rj; i++)\n            {\n              ri += 2;\n              t = d->tokens[ri];\n              mp->is[i] = mp->left[i] = mp->right[i]\n                = case_fold_unibyte ? toupper (t) : t;\n            }\n          mp->is[i] = mp->left[i] = mp->right[i] = '\\0';\n          mp->in = enlist (mp->in, mp->is, i);\n          break;\n        }\n    }\n done:;\n\n  struct dfamust *dm = NULL;\n  if (*result)\n    {\n      dm = xmalloc (sizeof *dm);\n      dm->exact = exact;\n      dm->begline = begline;\n      dm->endline = endline;\n      dm->must = xstrdup (result);\n    }\n\n  while (mp)\n    {\n      must *prev = mp->prev;\n      freemust (mp);\n      mp = prev;\n    }\n\n  return dm;\n}",
      "lines": 236,
      "depth": 22,
      "decorators": [
        "struct dfamust",
        "struct",
        "dfamust",
        "*\ndfamust (struct dfa const *d)",
        "*"
      ]
    },
    "dfamustfree": {
      "start_point": [
        4007,
        0
      ],
      "end_point": [
        4012,
        1
      ],
      "content": "void\ndfamustfree (struct dfamust *dm)\n{\n  free (dm->must);\n  free (dm);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "dfaalloc": {
      "start_point": [
        4014,
        0
      ],
      "end_point": [
        4018,
        1
      ],
      "content": "struct dfa *\ndfaalloc (void)\n{\n  return xmalloc (sizeof (struct dfa));\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "struct dfa",
        "struct",
        "dfa",
        "*\ndfaalloc (void)",
        "*"
      ]
    },
    "dfasyntax": {
      "start_point": [
        4021,
        0
      ],
      "end_point": [
        4061,
        1
      ],
      "content": "void\ndfasyntax (struct dfa *dfa, struct localeinfo const *linfo,\n           reg_syntax_t bits, int dfaopts)\n{\n  memset (dfa, 0, offsetof (struct dfa, dfaexec));\n  dfa->dfaexec = linfo->multibyte ? dfaexec_mb : dfaexec_sb;\n  dfa->simple_locale = using_simple_locale (linfo->multibyte);\n  dfa->localeinfo = *linfo;\n\n  dfa->fast = !dfa->localeinfo.multibyte;\n\n  dfa->canychar = -1;\n  dfa->lex.cur_mb_len = 1;\n  dfa->syntax.syntax_bits_set = true;\n  dfa->syntax.case_fold = (bits & RE_ICASE) != 0;\n  dfa->syntax.anchor = (dfaopts & DFA_ANCHOR) != 0;\n  dfa->syntax.eolbyte = dfaopts & DFA_EOL_NUL ? '\\0' : '\\n';\n  dfa->syntax.syntax_bits = bits;\n\n  for (int i = CHAR_MIN; i <= CHAR_MAX; ++i)\n    {\n      unsigned char uc = i;\n\n      dfa->syntax.sbit[uc] = char_context (dfa, uc);\n      switch (dfa->syntax.sbit[uc])\n        {\n        case CTX_LETTER:\n          setbit (uc, &dfa->syntax.letters);\n          break;\n        case CTX_NEWLINE:\n          setbit (uc, &dfa->syntax.newline);\n          break;\n        }\n\n      /* POSIX requires that the five bytes in \"\\n\\r./\" (including the\n         terminating NUL) cannot occur inside a multibyte character.  */\n      dfa->syntax.never_trail[uc] = (dfa->localeinfo.using_utf8\n                                     ? (uc & 0xc0) != 0x80\n                                     : strchr (\"\\n\\r./\", uc) != NULL);\n    }\n}",
      "lines": 41,
      "depth": 14,
      "decorators": [
        "void"
      ]
    }
  },
  "sed/sed-4.5/lib/dfa.h": {},
  "sed/sed-4.5/lib/dirname-lgpl.c": {
    "dir_len": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "size_t\ndir_len (char const *file)\n{\n  size_t prefix_length = FILE_SYSTEM_PREFIX_LEN (file);\n  size_t length;\n\n  /* Advance prefix_length beyond important leading slashes.  */\n  prefix_length += (prefix_length != 0\n                    ? (FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE\n                       && ISSLASH (file[prefix_length]))\n                    : (ISSLASH (file[0])\n                       ? ((DOUBLE_SLASH_IS_DISTINCT_ROOT\n                           && ISSLASH (file[1]) && ! ISSLASH (file[2])\n                           ? 2 : 1))\n                       : 0));\n\n  /* Strip the basename and any redundant slashes before it.  */\n  for (length = last_component (file) - file;\n       prefix_length < length; length--)\n    if (! ISSLASH (file[length - 1]))\n      break;\n  return length;\n}",
      "lines": 23,
      "depth": 17,
      "decorators": [
        "size_t"
      ]
    },
    "mdir_name": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "char *\nmdir_name (char const *file)\n{\n  size_t length = dir_len (file);\n  bool append_dot = (length == 0\n                     || (FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE\n                         && length == FILE_SYSTEM_PREFIX_LEN (file)\n                         && file[2] != '\\0' && ! ISSLASH (file[2])));\n  char *dir = malloc (length + append_dot + 1);\n  if (!dir)\n    return NULL;\n  memcpy (dir, file, length);\n  if (append_dot)\n    dir[length++] = '.';\n  dir[length] = '\\0';\n  return dir;\n}",
      "lines": 17,
      "depth": 14,
      "decorators": [
        "char",
        "*\nmdir_name (char const *file)",
        "*"
      ]
    }
  },
  "sed/sed-4.5/lib/dirname.h": {},
  "sed/sed-4.5/lib/dosname.h": {},
  "sed/sed-4.5/lib/errno.in.h": {},
  "sed/sed-4.5/lib/error.c": {
    "is_open": {
      "start_point": [
        130,
        0
      ],
      "end_point": [
        145,
        1
      ],
      "content": "static int\nis_open (int fd)\n{\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n  /* On native Windows: The initial state of unassigned standard file\n     descriptors is that they are open but point to an INVALID_HANDLE_VALUE.\n     There is no fcntl, and the gnulib replacement fcntl does not support\n     F_GETFL.  */\n  return (HANDLE) _get_osfhandle (fd) != INVALID_HANDLE_VALUE;\n# else\n#  ifndef F_GETFL\n#   error Please port fcntl to your platform\n#  endif\n  return 0 <= fcntl (fd, F_GETFL);\n# endif\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "flush_stdout": {
      "start_point": [
        148,
        0
      ],
      "end_point": [
        171,
        1
      ],
      "content": "static void\nflush_stdout (void)\n{\n#if !_LIBC\n  int stdout_fd;\n\n# if GNULIB_FREOPEN_SAFER\n  /* Use of gnulib's freopen-safer module normally ensures that\n       fileno (stdout) == 1\n     whenever stdout is open.  */\n  stdout_fd = STDOUT_FILENO;\n# else\n  /* POSIX states that fileno (stdout) after fclose is unspecified.  But in\n     practice it is not a problem, because stdout is statically allocated and\n     the fd of a FILE stream is stored as a field in its allocated memory.  */\n  stdout_fd = fileno (stdout);\n# endif\n  /* POSIX states that fflush (stdout) after fclose is unspecified; it\n     is safe in glibc, but not on all other platforms.  fflush (NULL)\n     is always defined, but too draconian.  */\n  if (0 <= stdout_fd && is_open (stdout_fd))\n#endif\n    fflush (stdout);\n}",
      "lines": 24,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "print_errno_message": {
      "start_point": [
        173,
        0
      ],
      "end_point": [
        202,
        1
      ],
      "content": "static void\nprint_errno_message (int errnum)\n{\n  char const *s;\n\n#if _LIBC || GNULIB_STRERROR_R_POSIX || defined HAVE_STRERROR_R\n  char errbuf[1024];\n# if _LIBC || (!GNULIB_STRERROR_R_POSIX && STRERROR_R_CHAR_P)\n  s = __strerror_r (errnum, errbuf, sizeof errbuf);\n# else\n  if (__strerror_r (errnum, errbuf, sizeof errbuf) == 0)\n    s = errbuf;\n  else\n    s = 0;\n# endif\n#else\n  s = strerror (errnum);\n#endif\n\n#if !_LIBC\n  if (! s)\n    s = _(\"Unknown system error\");\n#endif\n\n#if _LIBC\n  __fxprintf (NULL, \": %s\", s);\n#else\n  fprintf (stderr, \": %s\", s);\n#endif\n}",
      "lines": 30,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "error_tail": {
      "start_point": [
        205,
        42
      ],
      "end_point": [
        286,
        1
      ],
      "content": "char *message, va_list args)\n{\n#if _LIBC\n  if (_IO_fwide (stderr, 0) > 0)\n    {\n      size_t len = strlen (message) + 1;\n      wchar_t *wmessage = NULL;\n      mbstate_t st;\n      size_t res;\n      const char *tmp;\n      bool use_malloc = false;\n\n      while (1)\n        {\n          if (__libc_use_alloca (len * sizeof (wchar_t)))\n            wmessage = (wchar_t *) alloca (len * sizeof (wchar_t));\n          else\n            {\n              if (!use_malloc)\n                wmessage = NULL;\n\n              wchar_t *p = (wchar_t *) realloc (wmessage,\n                                                len * sizeof (wchar_t));\n              if (p == NULL)\n                {\n                  free (wmessage);\n                  fputws_unlocked (L\"out of memory\\n\", stderr);\n                  return;\n                }\n              wmessage = p;\n              use_malloc = true;\n            }\n\n          memset (&st, '\\0', sizeof (st));\n          tmp = message;\n\n          res = mbsrtowcs (wmessage, &tmp, len, &st);\n          if (res != len)\n            break;\n\n          if (__builtin_expect (len >= SIZE_MAX / sizeof (wchar_t) / 2, 0))\n            {\n              /* This really should not happen if everything is fine.  */\n              res = (size_t) -1;\n              break;\n            }\n\n          len *= 2;\n        }\n\n      if (res == (size_t) -1)\n        {\n          /* The string cannot be converted.  */\n          if (use_malloc)\n            {\n              free (wmessage);\n              use_malloc = false;\n            }\n          wmessage = (wchar_t *) L\"???\";\n        }\n\n      __vfwprintf (stderr, wmessage, args);\n\n      if (use_malloc)\n        free (wmessage);\n    }\n  else\n#endif\n    vfprintf (stderr, message, args);\n\n  ++error_message_count;\n  if (errnum)\n    print_errno_message (errnum);\n#if _LIBC\n  __fxprintf (NULL, \"\\n\");\n#else\n  putc ('\\n', stderr);\n#endif\n  fflush (stderr);\n  if (status)\n    exit (status);\n}",
      "lines": 82,
      "depth": 18,
      "decorators": null
    },
    "error": {
      "start_point": [
        293,
        0
      ],
      "end_point": [
        331,
        1
      ],
      "content": "void\nerror (int status, int errnum, const char *message, ...)\n{\n  va_list args;\n\n#if defined _LIBC && defined __libc_ptf_call\n  /* We do not want this call to be cut short by a thread\n     cancellation.  Therefore disable cancellation for now.  */\n  int state = PTHREAD_CANCEL_ENABLE;\n  __libc_ptf_call (pthread_setcancelstate, (PTHREAD_CANCEL_DISABLE, &state),\n                   0);\n#endif\n\n  flush_stdout ();\n#ifdef _LIBC\n  _IO_flockfile (stderr);\n#endif\n  if (error_print_progname)\n    (*error_print_progname) ();\n  else\n    {\n#if _LIBC\n      __fxprintf (NULL, \"%s: \", program_name);\n#else\n      fprintf (stderr, \"%s: \", program_name);\n#endif\n    }\n\n  va_start (args, message);\n  error_tail (status, errnum, message, args);\n  va_end (args);\n\n#ifdef _LIBC\n  _IO_funlockfile (stderr);\n# ifdef __libc_ptf_call\n  __libc_ptf_call (pthread_setcancelstate, (state, NULL), 0);\n# endif\n#endif\n}",
      "lines": 39,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "error_at_line": {
      "start_point": [
        337,
        0
      ],
      "end_point": [
        402,
        1
      ],
      "content": "void\nerror_at_line (int status, int errnum, const char *file_name,\n               unsigned int line_number, const char *message, ...)\n{\n  va_list args;\n\n  if (error_one_per_line)\n    {\n      static const char *old_file_name;\n      static unsigned int old_line_number;\n\n      if (old_line_number == line_number\n          && (file_name == old_file_name\n              || (old_file_name != NULL\n                  && file_name != NULL\n                  && strcmp (old_file_name, file_name) == 0)))\n\n        /* Simply return and print nothing.  */\n        return;\n\n      old_file_name = file_name;\n      old_line_number = line_number;\n    }\n\n#if defined _LIBC && defined __libc_ptf_call\n  /* We do not want this call to be cut short by a thread\n     cancellation.  Therefore disable cancellation for now.  */\n  int state = PTHREAD_CANCEL_ENABLE;\n  __libc_ptf_call (pthread_setcancelstate, (PTHREAD_CANCEL_DISABLE, &state),\n                   0);\n#endif\n\n  flush_stdout ();\n#ifdef _LIBC\n  _IO_flockfile (stderr);\n#endif\n  if (error_print_progname)\n    (*error_print_progname) ();\n  else\n    {\n#if _LIBC\n      __fxprintf (NULL, \"%s:\", program_name);\n#else\n      fprintf (stderr, \"%s:\", program_name);\n#endif\n    }\n\n#if _LIBC\n  __fxprintf (NULL, file_name != NULL ? \"%s:%u: \" : \" \",\n              file_name, line_number);\n#else\n  fprintf (stderr, file_name != NULL ? \"%s:%u: \" : \" \",\n           file_name, line_number);\n#endif\n\n  va_start (args, message);\n  error_tail (status, errnum, message, args);\n  va_end (args);\n\n#ifdef _LIBC\n  _IO_funlockfile (stderr);\n# ifdef __libc_ptf_call\n  __libc_ptf_call (pthread_setcancelstate, (state, NULL), 0);\n# endif\n#endif\n}",
      "lines": 66,
      "depth": 15,
      "decorators": [
        "void"
      ]
    }
  },
  "sed/sed-4.5/lib/error.h": {},
  "sed/sed-4.5/lib/exitfail.c": {},
  "sed/sed-4.5/lib/exitfail.h": {},
  "sed/sed-4.5/lib/fcntl.in.h": {},
  "sed/sed-4.5/lib/filename.h": {},
  "sed/sed-4.5/lib/fpending.c": {
    "__fpending": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "size_t\n__fpending (FILE *fp)\n{\n  /* Most systems provide FILE as a struct and the necessary bitmask in\n     <stdio.h>, because they need it for implementing getc() and putc() as\n     fast macros.  */\n#if defined _IO_EOF_SEEN || defined _IO_ftrylockfile || __GNU_LIBRARY__ == 1\n  /* GNU libc, BeOS, Haiku, Linux libc5 */\n  return fp->_IO_write_ptr - fp->_IO_write_base;\n#elif defined __sferror || defined __DragonFly__ || defined __ANDROID__\n  /* FreeBSD, NetBSD, OpenBSD, DragonFly, Mac OS X, Cygwin, Minix 3, Android */\n  return fp->_p - fp->_bf._base;\n#elif defined __EMX__                /* emx+gcc */\n  return fp->_ptr - fp->_buffer;\n#elif defined __minix                /* Minix */\n  return fp_->_ptr - fp_->_buf;\n#elif defined _IOERR                 /* AIX, HP-UX, IRIX, OSF/1, Solaris, OpenServer, mingw, MSVC, NonStop Kernel, OpenVMS */\n  return (fp_->_ptr ? fp_->_ptr - fp_->_base : 0);\n#elif defined __UCLIBC__             /* uClibc */\n  return (fp->__modeflags & __FLAG_WRITING ? fp->__bufpos - fp->__bufstart : 0);\n#elif defined __QNX__                /* QNX */\n  return (fp->_Mode & 0x2000 /*_MWRITE*/ ? fp->_Next - fp->_Buf : 0);\n#elif defined __MINT__               /* Atari FreeMiNT */\n  return fp->__bufp - fp->__buffer;\n#elif defined EPLAN9                 /* Plan9 */\n  return fp->wp - fp->buf;\n#else\n# error \"Please port gnulib fpending.c to your platform!\"\n  return 1;\n#endif\n}",
      "lines": 31,
      "depth": 15,
      "decorators": [
        "size_t"
      ]
    }
  },
  "sed/sed-4.5/lib/fpending.h": {},
  "sed/sed-4.5/lib/fstat.c": {
    "orig_fstat": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "static int\norig_fstat (int fd, struct stat *buf)\n{\n  return fstat (fd, buf);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_fstat": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "int\nrpl_fstat (int fd, struct stat *buf)\n{\n#if REPLACE_FCHDIR && REPLACE_OPEN_DIRECTORY\n  /* Handle the case when rpl_open() used a dummy file descriptor to work\n     around an open() that can't normally visit directories.  */\n  const char *name = _gl_directory_name (fd);\n  if (name != NULL)\n    return stat (name, buf);\n#endif\n\n#ifdef WINDOWS_NATIVE\n  /* Fill the fields ourselves, because the original fstat function returns\n     values for st_atime, st_mtime, st_ctime that depend on the current time\n     zone.  See\n     <https://lists.gnu.org/r/bug-gnulib/2017-04/msg00134.html>  */\n  HANDLE h = (HANDLE) _get_osfhandle (fd);\n\n  if (h == INVALID_HANDLE_VALUE)\n    {\n      errno = EBADF;\n      return -1;\n    }\n  return _gl_fstat_by_handle (h, NULL, buf);\n#else\n  return stat_time_normalize (orig_fstat (fd, buf), buf);\n#endif\n}",
      "lines": 28,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/lib/fwriting.c": {
    "fwriting": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        63,
        1
      ],
      "content": "bool\nfwriting (FILE *fp)\n{\n  /* Most systems provide FILE as a struct and the necessary bitmask in\n     <stdio.h>, because they need it for implementing getc() and putc() as\n     fast macros.  */\n#if defined _IO_EOF_SEEN || defined _IO_ftrylockfile || __GNU_LIBRARY__ == 1\n  /* GNU libc, BeOS, Haiku, Linux libc5 */\n  return (fp->_flags & (_IO_NO_READS | _IO_CURRENTLY_PUTTING)) != 0;\n#elif defined __sferror || defined __DragonFly__ || defined __ANDROID__\n  /* FreeBSD, NetBSD, OpenBSD, DragonFly, Mac OS X, Cygwin, Minix 3, Android */\n  return (fp_->_flags & __SWR) != 0;\n#elif defined __EMX__               /* emx+gcc */\n  return (fp->_flags & _IOWRT) != 0;\n#elif defined __minix               /* Minix */\n  return (fp->_flags & _IOWRITING) != 0;\n#elif defined _IOERR                /* AIX, HP-UX, IRIX, OSF/1, Solaris, OpenServer, mingw, MSVC, NonStop Kernel, OpenVMS */\n  return (fp_->_flag & _IOWRT) != 0;\n#elif defined __UCLIBC__            /* uClibc */\n  return (fp->__modeflags & __FLAG_WRITING) != 0;\n#elif defined __QNX__               /* QNX */\n  return ((fp->_Mode & 0x1 /* _MOPENR */) == 0\n          || (fp->_Mode & 0x2000 /* _MWRITE */) != 0);\n#elif defined __MINT__              /* Atari FreeMiNT */\n  if (!fp->__mode.__read)\n    return 1;\n  if (!fp->__mode.__write)\n    return 0;\n# ifdef _IO_CURRENTLY_PUTTING /* Flag added on 2009-02-28 */\n  return (fp->__flags & _IO_CURRENTLY_PUTTING) != 0;\n# else\n  return (fp->__buffer < fp->__put_limit /*|| fp->__bufp == fp->__get_limit ??*/);\n# endif\n#elif defined EPLAN9                /* Plan9 */\n  if (fp->state == 0 /* CLOSED */ || fp->state == 3 /* RD */)\n    return 0;\n  return (fp->state == 4 /* WR */ && (fp->bufl == 0 || fp->wp < fp->rp));\n#else\n# error \"Please port gnulib fwriting.c to your platform!\"\n#endif\n}",
      "lines": 41,
      "depth": 19,
      "decorators": [
        "bool"
      ]
    }
  },
  "sed/sed-4.5/lib/fwriting.h": {},
  "sed/sed-4.5/lib/get-permissions.c": {
    "get_permissions": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        290,
        1
      ],
      "content": "int\nget_permissions (const char *name, int desc, mode_t mode,\n\t\t struct permission_context *ctx)\n{\n  memset (ctx, 0, sizeof *ctx);\n  ctx->mode = mode;\n\n#if USE_ACL && HAVE_ACL_GET_FILE\n  /* POSIX 1003.1e (draft 17 -- abandoned) specific version.  */\n  /* Linux, FreeBSD, Mac OS X, IRIX, Tru64 */\n# if !HAVE_ACL_TYPE_EXTENDED\n  /* Linux, FreeBSD, IRIX, Tru64 */\n\n  if (HAVE_ACL_GET_FD && desc != -1)\n    ctx->acl = acl_get_fd (desc);\n  else\n    ctx->acl = acl_get_file (name, ACL_TYPE_ACCESS);\n  if (ctx->acl == NULL)\n    return acl_errno_valid (errno) ? -1 : 0;\n\n  /* With POSIX ACLs, a file cannot have \"no\" acl; a file without\n     extended permissions has a \"minimal\" acl which is equivalent to the\n     file mode.  */\n\n  if (S_ISDIR (mode))\n    {\n      ctx->default_acl = acl_get_file (name, ACL_TYPE_DEFAULT);\n      if (ctx->default_acl == NULL)\n\treturn -1;\n    }\n\n# if HAVE_ACL_TYPE_NFS4  /* FreeBSD */\n\n  /* TODO (see set_permissions). */\n\n# endif\n\n#  else /* HAVE_ACL_TYPE_EXTENDED */\n  /* Mac OS X */\n\n  /* On Mac OS X,  acl_get_file (name, ACL_TYPE_ACCESS)\n     and           acl_get_file (name, ACL_TYPE_DEFAULT)\n     always return NULL / EINVAL.  You have to use\n                   acl_get_file (name, ACL_TYPE_EXTENDED)\n     or            acl_get_fd (open (name, ...))\n     to retrieve an ACL.\n     On the other hand,\n                   acl_set_file (name, ACL_TYPE_ACCESS, acl)\n     and           acl_set_file (name, ACL_TYPE_DEFAULT, acl)\n     have the same effect as\n                   acl_set_file (name, ACL_TYPE_EXTENDED, acl):\n     Each of these calls sets the file's ACL.  */\n\n  if (HAVE_ACL_GET_FD && desc != -1)\n    ctx->acl = acl_get_fd (desc);\n  else\n    ctx->acl = acl_get_file (name, ACL_TYPE_EXTENDED);\n  if (ctx->acl == NULL)\n    return acl_errno_valid (errno) ? -1 : 0;\n\n# endif\n\n#elif USE_ACL && defined GETACL /* Solaris, Cygwin, not HP-UX */\n\n  /* Solaris 2.5 through Solaris 10, Cygwin, and contemporaneous versions\n     of Unixware.  The acl() call returns the access and default ACL both\n     at once.  */\n# ifdef ACE_GETACL\n  /* Solaris also has a different variant of ACLs, used in ZFS and NFSv4\n     file systems (whereas the other ones are used in UFS file systems).\n     There is an API\n       pathconf (name, _PC_ACL_ENABLED)\n       fpathconf (desc, _PC_ACL_ENABLED)\n     that allows us to determine which of the two kinds of ACLs is supported\n     for the given file.  But some file systems may implement this call\n     incorrectly, so better not use it.\n     When fetching the source ACL, we simply fetch both ACL types.\n     When setting the destination ACL, we try either ACL types, assuming\n     that the kernel will translate the ACL from one form to the other.\n     (See in <http://docs.sun.com/app/docs/doc/819-2241/6n4huc7ia?l=en&a=view>\n     the description of ENOTSUP.)  */\n  for (;;)\n    {\n      int ret;\n\n      if (desc != -1)\n\tret = facl (desc, ACE_GETACLCNT, 0, NULL);\n      else\n\tret = acl (name, ACE_GETACLCNT, 0, NULL);\n      if (ret < 0)\n\t{\n\t  if (errno == ENOSYS || errno == EINVAL)\n\t    ret = 0;\n\t  else\n\t    return -1;\n\t}\n      ctx->ace_count = ret;\n\n      if (ctx->ace_count == 0)\n        break;\n\n      ctx->ace_entries = (ace_t *) malloc (ctx->ace_count * sizeof (ace_t));\n      if (ctx->ace_entries == NULL)\n        {\n          errno = ENOMEM;\n          return -1;\n        }\n\n      if (desc != -1)\n\tret = facl (desc, ACE_GETACL, ctx->ace_count, ctx->ace_entries);\n      else\n\tret = acl (name, ACE_GETACL, ctx->ace_count, ctx->ace_entries);\n      if (ret < 0)\n        {\n          if (errno == ENOSYS || errno == EINVAL)\n            {\n\t      free (ctx->ace_entries);\n\t      ctx->ace_entries = NULL;\n              ctx->ace_count = 0;\n              break;\n            }\n          else\n            return -1;\n        }\n      if (ret <= ctx->ace_count)\n\t{\n\t  ctx->ace_count = ret;\n\t  break;\n\t}\n      /* Huh? The number of ACL entries has increased since the last call.\n         Repeat.  */\n      free (ctx->ace_entries);\n      ctx->ace_entries = NULL;\n    }\n# endif\n\n  for (;;)\n    {\n      int ret;\n\n      if (desc != -1)\n\tret = facl (desc, GETACLCNT, 0, NULL);\n      else\n\tret = acl (name, GETACLCNT, 0, NULL);\n      if (ret < 0)\n\t{\n\t  if (errno == ENOSYS || errno == ENOTSUP || errno == EOPNOTSUPP)\n\t    ret = 0;\n\t  else\n\t    return -1;\n\t}\n      ctx->count = ret;\n\n      if (ctx->count == 0)\n\tbreak;\n\n      ctx->entries = (aclent_t *) malloc (ctx->count * sizeof (aclent_t));\n      if (ctx->entries == NULL)\n        {\n          errno = ENOMEM;\n          return -1;\n        }\n\n      if (desc != -1)\n\tret = facl (desc, GETACL, ctx->count, ctx->entries);\n      else\n\tret = acl (name, GETACL, ctx->count, ctx->entries);\n      if (ret < 0)\n\t{\n\t  if (errno == ENOSYS || errno == ENOTSUP || errno == EOPNOTSUPP)\n\t    {\n\t      free (ctx->entries);\n\t      ctx->entries = NULL;\n\t      ctx->count = 0;\n\t      break;\n\t    }\n\t  else\n\t    return -1;\n\t}\n      if (ret <= ctx->count)\n\t{\n\t  ctx->count = ret;\n\t  break;\n\t}\n      /* Huh? The number of ACL entries has increased since the last call.\n         Repeat.  */\n      free (ctx->entries);\n      ctx->entries = NULL;\n    }\n\n#elif USE_ACL && HAVE_GETACL /* HP-UX */\n\n  {\n    int ret;\n\n    if (desc != -1)\n      ret = fgetacl (desc, NACLENTRIES, ctx->entries);\n    else\n      ret = getacl (name, NACLENTRIES, ctx->entries);\n    if (ret < 0)\n      {\n        if (errno == ENOSYS || errno == EOPNOTSUPP || errno == ENOTSUP)\n          ret = 0;\n        else\n          return -1;\n      }\n    else if (ret > NACLENTRIES)\n      /* If NACLENTRIES cannot be trusted, use dynamic memory allocation.  */\n      abort ();\n    ctx->count = ret;\n\n# if HAVE_ACLV_H\n    ret = acl ((char *) name, ACL_GET, NACLVENTRIES, ctx->aclv_entries);\n    if (ret < 0)\n      {\n        if (errno == ENOSYS || errno == EOPNOTSUPP || errno == EINVAL)\n          ret = 0;\n        else\n          return -2;\n      }\n    else if (ret > NACLVENTRIES)\n      /* If NACLVENTRIES cannot be trusted, use dynamic memory allocation.  */\n      abort ();\n    ctx->aclv_count = ret;\n# endif\n  }\n\n#elif USE_ACL && HAVE_ACLX_GET && ACL_AIX_WIP /* AIX */\n\n  /* TODO (see set_permissions). */\n\n#elif USE_ACL && HAVE_STATACL /* older AIX */\n\n  {\n    int ret;\n    if (desc != -1)\n      ret = fstatacl (desc, STX_NORMAL, &ctx->u.a, sizeof ctx->u);\n    else\n      ret = statacl ((char *) name, STX_NORMAL, &ctx->u.a, sizeof ctx->u);\n    if (ret == 0)\n      ctx->have_u = true;\n  }\n\n#elif USE_ACL && HAVE_ACLSORT /* NonStop Kernel */\n\n  {\n    int ret = acl ((char *) name, ACL_GET, NACLENTRIES, ctx->entries);\n    if (ret < 0)\n      return -1;\n    else if (ret > NACLENTRIES)\n      /* If NACLENTRIES cannot be trusted, use dynamic memory allocation.  */\n      abort ();\n    ctx->count = ret;\n  }\n\n#endif\n\n  return 0;\n\n}",
      "lines": 260,
      "depth": 17,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/lib/getdelim.c": {
    "alloc_failed": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "static void\nalloc_failed (void)\n{\n#if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n  /* Avoid errno problem without using the realloc module; see:\n     https://lists.gnu.org/r/bug-gnulib/2016-08/msg00025.html  */\n  errno = ENOMEM;\n#endif\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "getdelim": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        146,
        1
      ],
      "content": "ssize_t\ngetdelim (char **lineptr, size_t *n, int delimiter, FILE *fp)\n{\n  ssize_t result;\n  size_t cur_len = 0;\n\n  if (lineptr == NULL || n == NULL || fp == NULL)\n    {\n      errno = EINVAL;\n      return -1;\n    }\n\n  flockfile (fp);\n\n  if (*lineptr == NULL || *n == 0)\n    {\n      char *new_lineptr;\n      *n = 120;\n      new_lineptr = (char *) realloc (*lineptr, *n);\n      if (new_lineptr == NULL)\n        {\n          alloc_failed ();\n          result = -1;\n          goto unlock_return;\n        }\n      *lineptr = new_lineptr;\n    }\n\n  for (;;)\n    {\n      int i;\n\n      i = getc_maybe_unlocked (fp);\n      if (i == EOF)\n        {\n          result = -1;\n          break;\n        }\n\n      /* Make enough space for len+1 (for final NUL) bytes.  */\n      if (cur_len + 1 >= *n)\n        {\n          size_t needed_max =\n            SSIZE_MAX < SIZE_MAX ? (size_t) SSIZE_MAX + 1 : SIZE_MAX;\n          size_t needed = 2 * *n + 1;   /* Be generous. */\n          char *new_lineptr;\n\n          if (needed_max < needed)\n            needed = needed_max;\n          if (cur_len + 1 >= needed)\n            {\n              result = -1;\n              errno = EOVERFLOW;\n              goto unlock_return;\n            }\n\n          new_lineptr = (char *) realloc (*lineptr, needed);\n          if (new_lineptr == NULL)\n            {\n              alloc_failed ();\n              result = -1;\n              goto unlock_return;\n            }\n\n          *lineptr = new_lineptr;\n          *n = needed;\n        }\n\n      (*lineptr)[cur_len] = i;\n      cur_len++;\n\n      if (i == delimiter)\n        break;\n    }\n  (*lineptr)[cur_len] = '\\0';\n  result = cur_len ? cur_len : result;\n\n unlock_return:\n  funlockfile (fp); /* doesn't set errno */\n\n  return result;\n}",
      "lines": 82,
      "depth": 13,
      "decorators": [
        "ssize_t"
      ]
    }
  },
  "sed/sed-4.5/lib/getfilecon.c": {
    "map_to_failure": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        65,
        1
      ],
      "content": "static int\nmap_to_failure (int ret, security_context_t *con)\n{\n  if (ret == 0)\n    {\n      errno = ENOTSUP;\n      return -1;\n    }\n\n  if (ret == 10 && strcmp (*con, \"unlabeled\") == 0)\n    {\n      freecon (*con);\n      *con = NULL;\n      errno = ENODATA;\n      return -1;\n    }\n\n  return ret;\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_getfilecon": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "int\nrpl_getfilecon (char const *file, security_context_t *con)\n{\n  int ret = getfilecon (file, con);\n  return map_to_failure (ret, con);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "rpl_lgetfilecon": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "int\nrpl_lgetfilecon (char const *file, security_context_t *con)\n{\n  int ret = lgetfilecon (file, con);\n  return map_to_failure (ret, con);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "rpl_fgetfilecon": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "int\nrpl_fgetfilecon (int fd, security_context_t *con)\n{\n  int ret = fgetfilecon (fd, con);\n  return map_to_failure (ret, con);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/lib/getopt-cdefs.in.h": {},
  "sed/sed-4.5/lib/getopt-core.h": {},
  "sed/sed-4.5/lib/getopt-ext.h": {
    "struct": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "__BEGIN_DECLS\n\n/* Describe the long-named options requested by the application.\n   The LONG_OPTIONS argument to getopt_long or getopt_long_only is a vector\n   of 'struct option' terminated by an element containing a name which is\n   zero.\n\n   The field 'has_arg' is:\n   no_argument\t\t(or 0) if the option does not take an argument,\n   required_argument\t(or 1) if the option requires an argument,\n   optional_argument \t(or 2) if the option takes an optional argument.\n\n   If the field 'flag' is not NULL, it points to a variable that is set\n   to the value given in the field 'val' when the option is found, but\n   left unchanged if the option is not found.\n\n   To have a long-named option do something other than set an 'int' to\n   a compiled-in constant, such as set a value from 'optarg', set the\n   option's 'flag' field to zero and its 'val' field to a nonzero\n   value (the equivalent single-letter option character, if there is\n   one).  For long options that have a zero 'flag' field, 'getopt'\n   returns the contents of the 'val' field.  */\n\nstruct option\n{\n  const char *name;\n  /* has_arg can't be an enum because some compilers complain about\n     type mismatches in all the code that assumes it is an int.  */\n  int has_arg;\n  int *flag;\n  int val;\n}",
      "lines": 32,
      "depth": 5,
      "decorators": null
    }
  },
  "sed/sed-4.5/lib/getopt-pfx-core.h": {},
  "sed/sed-4.5/lib/getopt-pfx-ext.h": {},
  "sed/sed-4.5/lib/getopt.c": {
    "exchange": {
      "start_point": [
        129,
        0
      ],
      "end_point": [
        182,
        1
      ],
      "content": "static void\nexchange (char **argv, struct _getopt_data *d)\n{\n  int bottom = d->__first_nonopt;\n  int middle = d->__last_nonopt;\n  int top = d->optind;\n  char *tem;\n\n  /* Exchange the shorter segment with the far end of the longer segment.\n     That puts the shorter segment into the right place.\n     It leaves the longer segment in the right place overall,\n     but it consists of two parts that need to be swapped next.  */\n\n  while (top > middle && middle > bottom)\n    {\n      if (top - middle > middle - bottom)\n\t{\n\t  /* Bottom segment is the short one.  */\n\t  int len = middle - bottom;\n\t  int i;\n\n\t  /* Swap it with the top part of the top segment.  */\n\t  for (i = 0; i < len; i++)\n\t    {\n\t      tem = argv[bottom + i];\n\t      argv[bottom + i] = argv[top - (middle - bottom) + i];\n\t      argv[top - (middle - bottom) + i] = tem;\n\t    }\n\t  /* Exclude the moved bottom segment from further swapping.  */\n\t  top -= len;\n\t}\n      else\n\t{\n\t  /* Top segment is the short one.  */\n\t  int len = top - middle;\n\t  int i;\n\n\t  /* Swap it with the bottom part of the bottom segment.  */\n\t  for (i = 0; i < len; i++)\n\t    {\n\t      tem = argv[bottom + i];\n\t      argv[bottom + i] = argv[middle + i];\n\t      argv[middle + i] = tem;\n\t    }\n\t  /* Exclude the moved top segment from further swapping.  */\n\t  bottom += len;\n\t}\n    }\n\n  /* Update records for the slots the non-options now occupy.  */\n\n  d->__first_nonopt += (d->optind - d->__last_nonopt);\n  d->__last_nonopt = d->optind;\n}",
      "lines": 54,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "process_long_option": {
      "start_point": [
        192,
        0
      ],
      "end_point": [
        375,
        1
      ],
      "content": "static int\nprocess_long_option (int argc, char **argv, const char *optstring,\n\t\t     const struct option *longopts, int *longind,\n\t\t     int long_only, struct _getopt_data *d,\n\t\t     int print_errors, const char *prefix)\n{\n  char *nameend;\n  size_t namelen;\n  const struct option *p;\n  const struct option *pfound = NULL;\n  int n_options;\n  int option_index;\n\n  for (nameend = d->__nextchar; *nameend && *nameend != '='; nameend++)\n    /* Do nothing.  */ ;\n  namelen = nameend - d->__nextchar;\n\n  /* First look for an exact match, counting the options as a side\n     effect.  */\n  for (p = longopts, n_options = 0; p->name; p++, n_options++)\n    if (!strncmp (p->name, d->__nextchar, namelen)\n\t&& namelen == strlen (p->name))\n      {\n\t/* Exact match found.  */\n\tpfound = p;\n\toption_index = n_options;\n\tbreak;\n      }\n\n  if (pfound == NULL)\n    {\n      /* Didn't find an exact match, so look for abbreviations.  */\n      unsigned char *ambig_set = NULL;\n      int ambig_malloced = 0;\n      int ambig_fallback = 0;\n      int indfound = -1;\n\n      for (p = longopts, option_index = 0; p->name; p++, option_index++)\n\tif (!strncmp (p->name, d->__nextchar, namelen))\n\t  {\n\t    if (pfound == NULL)\n\t      {\n\t\t/* First nonexact match found.  */\n\t\tpfound = p;\n\t\tindfound = option_index;\n\t      }\n\t    else if (long_only\n\t\t     || pfound->has_arg != p->has_arg\n\t\t     || pfound->flag != p->flag\n\t\t     || pfound->val != p->val)\n\t      {\n\t\t/* Second or later nonexact match found.  */\n\t\tif (!ambig_fallback)\n\t\t  {\n\t\t    if (!print_errors)\n\t\t      /* Don't waste effort tracking the ambig set if\n\t\t\t we're not going to print it anyway.  */\n\t\t      ambig_fallback = 1;\n\t\t    else if (!ambig_set)\n\t\t      {\n\t\t\tif (__libc_use_alloca (n_options))\n\t\t\t  ambig_set = alloca (n_options);\n\t\t\telse if ((ambig_set = malloc (n_options)) == NULL)\n\t\t\t  /* Fall back to simpler error message.  */\n\t\t\t  ambig_fallback = 1;\n\t\t\telse\n\t\t\t  ambig_malloced = 1;\n\n\t\t\tif (ambig_set)\n\t\t\t  {\n\t\t\t    memset (ambig_set, 0, n_options);\n\t\t\t    ambig_set[indfound] = 1;\n\t\t\t  }\n\t\t      }\n\t\t    if (ambig_set)\n\t\t      ambig_set[option_index] = 1;\n\t\t  }\n\t      }\n\t  }\n\n      if (ambig_set || ambig_fallback)\n\t{\n\t  if (print_errors)\n\t    {\n\t      if (ambig_fallback)\n\t\tfprintf (stderr, _(\"%s: option '%s%s' is ambiguous\\n\"),\n\t\t\t argv[0], prefix, d->__nextchar);\n\t      else\n\t\t{\n\t\t  flockfile (stderr);\n\t\t  fprintf (stderr,\n\t\t\t   _(\"%s: option '%s%s' is ambiguous; possibilities:\"),\n\t\t\t   argv[0], prefix, d->__nextchar);\n\n\t\t  for (option_index = 0; option_index < n_options; option_index++)\n\t\t    if (ambig_set[option_index])\n\t\t      fprintf (stderr, \" '%s%s'\",\n\t\t\t       prefix, longopts[option_index].name);\n\n\t\t  /* This must use 'fprintf' even though it's only\n\t\t     printing a single character, so that it goes through\n\t\t     __fxprintf_nocancel when compiled as part of glibc.  */\n\t\t  fprintf (stderr, \"\\n\");\n\t\t  funlockfile (stderr);\n\t\t}\n\t    }\n\t  if (ambig_malloced)\n\t    free (ambig_set);\n\t  d->__nextchar += strlen (d->__nextchar);\n\t  d->optind++;\n\t  d->optopt = 0;\n\t  return '?';\n\t}\n\n      option_index = indfound;\n    }\n\n  if (pfound == NULL)\n    {\n      /* Can't find it as a long option.  If this is not getopt_long_only,\n\t or the option starts with '--' or is not a valid short option,\n\t then it's an error.  */\n      if (!long_only || argv[d->optind][1] == '-'\n\t  || strchr (optstring, *d->__nextchar) == NULL)\n\t{\n\t  if (print_errors)\n\t    fprintf (stderr, _(\"%s: unrecognized option '%s%s'\\n\"),\n\t\t     argv[0], prefix, d->__nextchar);\n\n\t  d->__nextchar = NULL;\n\t  d->optind++;\n\t  d->optopt = 0;\n\t  return '?';\n\t}\n\n      /* Otherwise interpret it as a short option.  */\n      return -1;\n    }\n\n  /* We have found a matching long option.  Consume it.  */\n  d->optind++;\n  d->__nextchar = NULL;\n  if (*nameend)\n    {\n      /* Don't test has_arg with >, because some C compilers don't\n\t allow it to be used on enums.  */\n      if (pfound->has_arg)\n\td->optarg = nameend + 1;\n      else\n\t{\n\t  if (print_errors)\n\t    fprintf (stderr,\n\t\t     _(\"%s: option '%s%s' doesn't allow an argument\\n\"),\n\t\t     argv[0], prefix, pfound->name);\n\n\t  d->optopt = pfound->val;\n\t  return '?';\n\t}\n    }\n  else if (pfound->has_arg == 1)\n    {\n      if (d->optind < argc)\n\td->optarg = argv[d->optind++];\n      else\n\t{\n\t  if (print_errors)\n\t    fprintf (stderr,\n\t\t     _(\"%s: option '%s%s' requires an argument\\n\"),\n\t\t     argv[0], prefix, pfound->name);\n\n\t  d->optopt = pfound->val;\n\t  return optstring[0] == ':' ? ':' : '?';\n\t}\n    }\n\n  if (longind != NULL)\n    *longind = option_index;\n  if (pfound->flag)\n    {\n      *(pfound->flag) = pfound->val;\n      return 0;\n    }\n  return pfound->val;\n}",
      "lines": 184,
      "depth": 24,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "_getopt_initialize": {
      "start_point": [
        379,
        0
      ],
      "end_point": [
        411,
        1
      ],
      "content": "static const char *\n_getopt_initialize (int argc _GL_UNUSED,\n\t\t    char **argv _GL_UNUSED, const char *optstring,\n\t\t    struct _getopt_data *d, int posixly_correct)\n{\n  /* Start processing options with ARGV-element 1 (since ARGV-element 0\n     is the program name); the sequence of previously skipped\n     non-option ARGV-elements is empty.  */\n  if (d->optind == 0)\n    d->optind = 1;\n\n  d->__first_nonopt = d->__last_nonopt = d->optind;\n  d->__nextchar = NULL;\n\n  /* Determine how to handle the ordering of options and nonoptions.  */\n  if (optstring[0] == '-')\n    {\n      d->__ordering = RETURN_IN_ORDER;\n      ++optstring;\n    }\n  else if (optstring[0] == '+')\n    {\n      d->__ordering = REQUIRE_ORDER;\n      ++optstring;\n    }\n  else if (posixly_correct || !!getenv (\"POSIXLY_CORRECT\"))\n    d->__ordering = REQUIRE_ORDER;\n  else\n    d->__ordering = PERMUTE;\n\n  d->__initialized = 1;\n  return optstring;\n}",
      "lines": 33,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\n_getopt_initialize (int argc _GL_UNUSED,\n\t\t    char **argv _GL_UNUSED, const char *optstring,\n\t\t    struct _getopt_data *d, int posixly_correct)",
        "*"
      ]
    },
    "_getopt_internal_r": {
      "start_point": [
        469,
        0
      ],
      "end_point": [
        699,
        1
      ],
      "content": "int\n_getopt_internal_r (int argc, char **argv, const char *optstring,\n\t\t    const struct option *longopts, int *longind,\n\t\t    int long_only, struct _getopt_data *d, int posixly_correct)\n{\n  int print_errors = d->opterr;\n\n  if (argc < 1)\n    return -1;\n\n  d->optarg = NULL;\n\n  if (d->optind == 0 || !d->__initialized)\n    optstring = _getopt_initialize (argc, argv, optstring, d, posixly_correct);\n  else if (optstring[0] == '-' || optstring[0] == '+')\n    optstring++;\n\n  if (optstring[0] == ':')\n    print_errors = 0;\n\n  /* Test whether ARGV[optind] points to a non-option argument.  */\n#define NONOPTION_P (argv[d->optind][0] != '-' || argv[d->optind][1] == '\\0')\n\n  if (d->__nextchar == NULL || *d->__nextchar == '\\0')\n    {\n      /* Advance to the next ARGV-element.  */\n\n      /* Give FIRST_NONOPT & LAST_NONOPT rational values if OPTIND has been\n\t moved back by the user (who may also have changed the arguments).  */\n      if (d->__last_nonopt > d->optind)\n\td->__last_nonopt = d->optind;\n      if (d->__first_nonopt > d->optind)\n\td->__first_nonopt = d->optind;\n\n      if (d->__ordering == PERMUTE)\n\t{\n\t  /* If we have just processed some options following some non-options,\n\t     exchange them so that the options come first.  */\n\n\t  if (d->__first_nonopt != d->__last_nonopt\n\t      && d->__last_nonopt != d->optind)\n\t    exchange (argv, d);\n\t  else if (d->__last_nonopt != d->optind)\n\t    d->__first_nonopt = d->optind;\n\n\t  /* Skip any additional non-options\n\t     and extend the range of non-options previously skipped.  */\n\n\t  while (d->optind < argc && NONOPTION_P)\n\t    d->optind++;\n\t  d->__last_nonopt = d->optind;\n\t}\n\n      /* The special ARGV-element '--' means premature end of options.\n\t Skip it like a null option,\n\t then exchange with previous non-options as if it were an option,\n\t then skip everything else like a non-option.  */\n\n      if (d->optind != argc && !strcmp (argv[d->optind], \"--\"))\n\t{\n\t  d->optind++;\n\n\t  if (d->__first_nonopt != d->__last_nonopt\n\t      && d->__last_nonopt != d->optind)\n\t    exchange (argv, d);\n\t  else if (d->__first_nonopt == d->__last_nonopt)\n\t    d->__first_nonopt = d->optind;\n\t  d->__last_nonopt = argc;\n\n\t  d->optind = argc;\n\t}\n\n      /* If we have done all the ARGV-elements, stop the scan\n\t and back over any non-options that we skipped and permuted.  */\n\n      if (d->optind == argc)\n\t{\n\t  /* Set the next-arg-index to point at the non-options\n\t     that we previously skipped, so the caller will digest them.  */\n\t  if (d->__first_nonopt != d->__last_nonopt)\n\t    d->optind = d->__first_nonopt;\n\t  return -1;\n\t}\n\n      /* If we have come to a non-option and did not permute it,\n\t either stop the scan or describe it to the caller and pass it by.  */\n\n      if (NONOPTION_P)\n\t{\n\t  if (d->__ordering == REQUIRE_ORDER)\n\t    return -1;\n\t  d->optarg = argv[d->optind++];\n\t  return 1;\n\t}\n\n      /* We have found another option-ARGV-element.\n\t Check whether it might be a long option.  */\n      if (longopts)\n\t{\n\t  if (argv[d->optind][1] == '-')\n\t    {\n\t      /* \"--foo\" is always a long option.  The special option\n\t\t \"--\" was handled above.  */\n\t      d->__nextchar = argv[d->optind] + 2;\n\t      return process_long_option (argc, argv, optstring, longopts,\n\t\t\t\t\t  longind, long_only, d,\n\t\t\t\t\t  print_errors, \"--\");\n\t    }\n\n\t  /* If long_only and the ARGV-element has the form \"-f\",\n\t     where f is a valid short option, don't consider it an\n\t     abbreviated form of a long option that starts with f.\n\t     Otherwise there would be no way to give the -f short\n\t     option.\n\n\t     On the other hand, if there's a long option \"fubar\" and\n\t     the ARGV-element is \"-fu\", do consider that an\n\t     abbreviation of the long option, just like \"--fu\", and\n\t     not \"-f\" with arg \"u\".\n\n\t     This distinction seems to be the most useful approach.  */\n\t  if (long_only && (argv[d->optind][2]\n\t\t\t    || !strchr (optstring, argv[d->optind][1])))\n\t    {\n\t      int code;\n\t      d->__nextchar = argv[d->optind] + 1;\n\t      code = process_long_option (argc, argv, optstring, longopts,\n\t\t\t\t\t  longind, long_only, d,\n\t\t\t\t\t  print_errors, \"-\");\n\t      if (code != -1)\n\t\treturn code;\n\t    }\n\t}\n\n      /* It is not a long option.  Skip the initial punctuation.  */\n      d->__nextchar = argv[d->optind] + 1;\n    }\n\n  /* Look at and handle the next short option-character.  */\n\n  {\n    char c = *d->__nextchar++;\n    const char *temp = strchr (optstring, c);\n\n    /* Increment 'optind' when we start to process its last character.  */\n    if (*d->__nextchar == '\\0')\n      ++d->optind;\n\n    if (temp == NULL || c == ':' || c == ';')\n      {\n\tif (print_errors)\n\t  fprintf (stderr, _(\"%s: invalid option -- '%c'\\n\"), argv[0], c);\n\td->optopt = c;\n\treturn '?';\n      }\n\n    /* Convenience. Treat POSIX -W foo same as long option --foo */\n    if (temp[0] == 'W' && temp[1] == ';' && longopts != NULL)\n      {\n\t/* This is an option that requires an argument.  */\n\tif (*d->__nextchar != '\\0')\n\t  d->optarg = d->__nextchar;\n\telse if (d->optind == argc)\n\t  {\n\t    if (print_errors)\n\t      fprintf (stderr,\n\t\t       _(\"%s: option requires an argument -- '%c'\\n\"),\n\t\t       argv[0], c);\n\n\t    d->optopt = c;\n\t    if (optstring[0] == ':')\n\t      c = ':';\n\t    else\n\t      c = '?';\n\t    return c;\n\t  }\n\telse\n\t  d->optarg = argv[d->optind];\n\n\td->__nextchar = d->optarg;\n\td->optarg = NULL;\n\treturn process_long_option (argc, argv, optstring, longopts, longind,\n\t\t\t\t    0 /* long_only */, d, print_errors, \"-W \");\n      }\n    if (temp[1] == ':')\n      {\n\tif (temp[2] == ':')\n\t  {\n\t    /* This is an option that accepts an argument optionally.  */\n\t    if (*d->__nextchar != '\\0')\n\t      {\n\t\td->optarg = d->__nextchar;\n\t\td->optind++;\n\t      }\n\t    else\n\t      d->optarg = NULL;\n\t    d->__nextchar = NULL;\n\t  }\n\telse\n\t  {\n\t    /* This is an option that requires an argument.  */\n\t    if (*d->__nextchar != '\\0')\n\t      {\n\t\td->optarg = d->__nextchar;\n\t\t/* If we end this ARGV-element by taking the rest as an arg,\n\t\t   we must advance to the next element now.  */\n\t\td->optind++;\n\t      }\n\t    else if (d->optind == argc)\n\t      {\n\t\tif (print_errors)\n\t\t  fprintf (stderr,\n\t\t\t   _(\"%s: option requires an argument -- '%c'\\n\"),\n\t\t\t   argv[0], c);\n\n\t\td->optopt = c;\n\t\tif (optstring[0] == ':')\n\t\t  c = ':';\n\t\telse\n\t\t  c = '?';\n\t      }\n\t    else\n\t      /* We already incremented 'optind' once;\n\t\t increment it again when taking next ARGV-elt as argument.  */\n\t      d->optarg = argv[d->optind++];\n\t    d->__nextchar = NULL;\n\t  }\n      }\n    return c;\n  }\n}",
      "lines": 231,
      "depth": 18,
      "decorators": [
        "int"
      ]
    },
    "_getopt_internal": {
      "start_point": [
        701,
        0
      ],
      "end_point": [
        720,
        1
      ],
      "content": "int\n_getopt_internal (int argc, char **argv, const char *optstring,\n\t\t  const struct option *longopts, int *longind, int long_only,\n\t\t  int posixly_correct)\n{\n  int result;\n\n  getopt_data.optind = optind;\n  getopt_data.opterr = opterr;\n\n  result = _getopt_internal_r (argc, argv, optstring, longopts,\n\t\t\t       longind, long_only, &getopt_data,\n\t\t\t       posixly_correct);\n\n  optind = getopt_data.optind;\n  optarg = getopt_data.optarg;\n  optopt = getopt_data.optopt;\n\n  return result;\n}",
      "lines": 20,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "main": {
      "start_point": [
        747,
        0
      ],
      "end_point": [
        808,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  int c;\n  int digit_optind = 0;\n\n  while (1)\n    {\n      int this_option_optind = optind ? optind : 1;\n\n      c = getopt (argc, argv, \"abc:d:0123456789\");\n      if (c == -1)\n\tbreak;\n\n      switch (c)\n\t{\n\tcase '0':\n\tcase '1':\n\tcase '2':\n\tcase '3':\n\tcase '4':\n\tcase '5':\n\tcase '6':\n\tcase '7':\n\tcase '8':\n\tcase '9':\n\t  if (digit_optind != 0 && digit_optind != this_option_optind)\n\t    printf (\"digits occur in two different argv-elements.\\n\");\n\t  digit_optind = this_option_optind;\n\t  printf (\"option %c\\n\", c);\n\t  break;\n\n\tcase 'a':\n\t  printf (\"option a\\n\");\n\t  break;\n\n\tcase 'b':\n\t  printf (\"option b\\n\");\n\t  break;\n\n\tcase 'c':\n\t  printf (\"option c with value '%s'\\n\", optarg);\n\t  break;\n\n\tcase '?':\n\t  break;\n\n\tdefault:\n\t  printf (\"?? getopt returned character code 0%o ??\\n\", c);\n\t}\n    }\n\n  if (optind < argc)\n    {\n      printf (\"non-option ARGV-elements: \");\n      while (optind < argc)\n\tprintf (\"%s \", argv[optind++]);\n      printf (\"\\n\");\n    }\n\n  exit (0);\n}",
      "lines": 62,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/lib/getopt.in.h": {},
  "sed/sed-4.5/lib/getopt1.c": {
    "getopt_long": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        32,
        1
      ],
      "content": "int\ngetopt_long (int argc, char *__getopt_argv_const *argv, const char *options,\n\t     const struct option *long_options, int *opt_index)\n{\n  return _getopt_internal (argc, (char **) argv, options, long_options,\n\t\t\t   opt_index, 0, 0);\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "_getopt_long_r": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        41,
        1
      ],
      "content": "int\n_getopt_long_r (int argc, char **argv, const char *options,\n\t\tconst struct option *long_options, int *opt_index,\n\t\tstruct _getopt_data *d)\n{\n  return _getopt_internal_r (argc, argv, options, long_options, opt_index,\n\t\t\t     0, d, 0);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "getopt_long_only": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "int\ngetopt_long_only (int argc, char *__getopt_argv_const *argv,\n\t\t  const char *options,\n\t\t  const struct option *long_options, int *opt_index)\n{\n  return _getopt_internal (argc, (char **) argv, options, long_options,\n\t\t\t   opt_index, 1, 0);\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "_getopt_long_only_r": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "int\n_getopt_long_only_r (int argc, char **argv, const char *options,\n\t\t     const struct option *long_options, int *opt_index,\n\t\t     struct _getopt_data *d)\n{\n  return _getopt_internal_r (argc, argv, options, long_options, opt_index,\n\t\t\t     1, d, 0);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "main": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        156,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  int c;\n  int digit_optind = 0;\n\n  while (1)\n    {\n      int this_option_optind = optind ? optind : 1;\n      int option_index = 0;\n      static const struct option long_options[] =\n      {\n\t{\"add\", 1, 0, 0},\n\t{\"append\", 0, 0, 0},\n\t{\"delete\", 1, 0, 0},\n\t{\"verbose\", 0, 0, 0},\n\t{\"create\", 0, 0, 0},\n\t{\"file\", 1, 0, 0},\n\t{0, 0, 0, 0}\n      };\n\n      c = getopt_long (argc, argv, \"abc:d:0123456789\",\n\t\t       long_options, &option_index);\n      if (c == -1)\n\tbreak;\n\n      switch (c)\n\t{\n\tcase 0:\n\t  printf (\"option %s\", long_options[option_index].name);\n\t  if (optarg)\n\t    printf (\" with arg %s\", optarg);\n\t  printf (\"\\n\");\n\t  break;\n\n\tcase '0':\n\tcase '1':\n\tcase '2':\n\tcase '3':\n\tcase '4':\n\tcase '5':\n\tcase '6':\n\tcase '7':\n\tcase '8':\n\tcase '9':\n\t  if (digit_optind != 0 && digit_optind != this_option_optind)\n\t    printf (\"digits occur in two different argv-elements.\\n\");\n\t  digit_optind = this_option_optind;\n\t  printf (\"option %c\\n\", c);\n\t  break;\n\n\tcase 'a':\n\t  printf (\"option a\\n\");\n\t  break;\n\n\tcase 'b':\n\t  printf (\"option b\\n\");\n\t  break;\n\n\tcase 'c':\n\t  printf (\"option c with value '%s'\\n\", optarg);\n\t  break;\n\n\tcase 'd':\n\t  printf (\"option d with value '%s'\\n\", optarg);\n\t  break;\n\n\tcase '?':\n\t  break;\n\n\tdefault:\n\t  printf (\"?? getopt returned character code 0%o ??\\n\", c);\n\t}\n    }\n\n  if (optind < argc)\n    {\n      printf (\"non-option ARGV-elements: \");\n      while (optind < argc)\n\tprintf (\"%s \", argv[optind++]);\n      printf (\"\\n\");\n    }\n\n  exit (0);\n}",
      "lines": 85,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/lib/getopt_int.h": {},
  "sed/sed-4.5/lib/getprogname.c": {
    "getprogname": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        181,
        1
      ],
      "content": "char const *\ngetprogname (void)\n{\n# if HAVE_DECL_PROGRAM_INVOCATION_SHORT_NAME                /* glibc, BeOS */\n  /* https://www.gnu.org/software/libc/manual/html_node/Error-Messages.html */\n  return program_invocation_short_name;\n# elif HAVE_DECL_PROGRAM_INVOCATION_NAME                    /* glibc, BeOS */\n  /* https://www.gnu.org/software/libc/manual/html_node/Error-Messages.html */\n  return last_component (program_invocation_name);\n# elif HAVE_GETEXECNAME                                     /* Solaris */\n  /* https://docs.oracle.com/cd/E19253-01/816-5168/6mbb3hrb1/index.html */\n  const char *p = getexecname ();\n  if (!p)\n    p = \"?\";\n  return last_component (p);\n# elif HAVE_DECL___ARGV                                     /* mingw, MSVC */\n  /* https://msdn.microsoft.com/en-us/library/dn727674.aspx */\n  const char *p = __argv && __argv[0] ? __argv[0] : \"?\";\n  return last_component (p);\n# elif HAVE_VAR___PROGNAME                                  /* OpenBSD, QNX */\n  /* https://man.openbsd.org/style.9 */\n  /* http://www.qnx.de/developers/docs/6.5.0/index.jsp?topic=%2Fcom.qnx.doc.neutrino_lib_ref%2Fp%2F__progname.html */\n  /* Be careful to declare this only when we absolutely need it\n     (OpenBSD 5.1), rather than when it's available.  Otherwise,\n     its mere declaration makes program_invocation_short_name\n     malfunction (have zero length) with Fedora 25's glibc.  */\n  extern char *__progname;\n  const char *p = __progname;\n  return p && p[0] ? p : \"?\";\n# elif _AIX                                                 /* AIX */\n  /* Idea by Bastien ROUCARI\u00c3\u0088S,\n     https://lists.gnu.org/r/bug-gnulib/2010-12/msg00095.html\n     Reference: https://www.ibm.com/support/knowledgecenter/en/ssw_aix_61/com.ibm.aix.basetrf1/getprocs.htm\n  */\n  static char *p;\n  static int first = 1;\n  if (first)\n    {\n      first = 0;\n      pid_t pid = getpid ();\n      struct procentry64 procs;\n      p = (0 < getprocs64 (&procs, sizeof procs, NULL, 0, &pid, 1)\n           ? strdup (procs.pi_comm)\n           : NULL);\n      if (!p)\n        p = \"?\";\n    }\n  return p;\n# elif defined __hpux\n  static char *p;\n  static int first = 1;\n  if (first)\n    {\n      first = 0;\n      pid_t pid = getpid ();\n      struct pst_status status;\n      p = (0 < pstat_getproc (&status, sizeof status, 0, pid)\n           ? strdup (status.pst_ucomm)\n           : NULL);\n      if (!p)\n        p = \"?\";\n    }\n  return p;\n# elif __MVS__                                              /* z/OS */\n  /* https://www.ibm.com/support/knowledgecenter/SSLTBW_2.1.0/com.ibm.zos.v2r1.bpxbd00/rtwgetp.htm */\n  static char *p = \"?\";\n  static int first = 1;\n  if (first)\n    {\n      pid_t pid = getpid ();\n      int token;\n      W_PSPROC buf;\n      first = 0;\n      memset (&buf, 0, sizeof(buf));\n      buf.ps_cmdptr    = (char *) malloc (buf.ps_cmdlen    = PS_CMDBLEN_LONG);\n      buf.ps_conttyptr = (char *) malloc (buf.ps_conttylen = PS_CONTTYBLEN);\n      buf.ps_pathptr   = (char *) malloc (buf.ps_pathlen   = PS_PATHBLEN);\n      if (buf.ps_cmdptr && buf.ps_conttyptr && buf.ps_pathptr)\n        {\n          for (token = 0; token >= 0;\n               token = w_getpsent (token, &buf, sizeof(buf)))\n            {\n              if (token > 0 && buf.ps_pid == pid)\n                {\n                  char *s = strdup (last_component (buf.ps_pathptr));\n                  if (s)\n                    p = s;\n                  break;\n                }\n            }\n        }\n      free (buf.ps_cmdptr);\n      free (buf.ps_conttyptr);\n      free (buf.ps_pathptr);\n    }\n  return p;\n# elif defined __sgi                                        /* IRIX */\n  char filename[50];\n  int fd;\n\n  sprintf (filename, \"/proc/pinfo/%d\", (int) getpid ());\n  fd = open (filename, O_RDONLY);\n  if (0 <= fd)\n    {\n      prpsinfo_t buf;\n      int ioctl_ok = 0 <= ioctl (fd, PIOCPSINFO, &buf);\n      close (fd);\n      if (ioctl_ok)\n        {\n          char *name = buf.pr_fname;\n          size_t namesize = sizeof buf.pr_fname;\n          char *namenul = memchr (name, '\\0', namesize);\n          size_t namelen = namenul ? namenul - name : namesize;\n          char *namecopy = malloc (namelen + 1);\n          if (namecopy)\n            {\n              namecopy[namelen] = 0;\n              return memcpy (namecopy, name, namelen);\n            }\n        }\n    }\n  return NULL;\n# else\n#  error \"getprogname module not ported to this OS\"\n# endif\n}",
      "lines": 126,
      "depth": 26,
      "decorators": [
        "char",
        "const",
        "const",
        "*\ngetprogname (void)",
        "*"
      ]
    }
  },
  "sed/sed-4.5/lib/getprogname.h": {},
  "sed/sed-4.5/lib/gettext.h": {
    "pgettext_aux": {
      "start_point": [
        147,
        0
      ],
      "end_point": [
        157,
        1
      ],
      "content": "static const char *\npgettext_aux (const char *domain,\n              const char *msg_ctxt_id, const char *msgid,\n              int category)\n{\n  const char *translation = dcgettext (domain, msg_ctxt_id, category);\n  if (translation == msg_ctxt_id)\n    return msgid;\n  else\n    return translation;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\npgettext_aux (const char *domain,\n              const char *msg_ctxt_id, const char *msgid,\n              int category)",
        "*"
      ]
    },
    "npgettext_aux": {
      "start_point": [
        166,
        0
      ],
      "end_point": [
        178,
        1
      ],
      "content": "static const char *\nnpgettext_aux (const char *domain,\n               const char *msg_ctxt_id, const char *msgid,\n               const char *msgid_plural, unsigned long int n,\n               int category)\n{\n  const char *translation =\n    dcngettext (domain, msg_ctxt_id, msgid_plural, n, category);\n  if (translation == msg_ctxt_id || translation == msgid_plural)\n    return (n == 1 ? msgid : msgid_plural);\n  else\n    return translation;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nnpgettext_aux (const char *domain,\n               const char *msg_ctxt_id, const char *msgid,\n               const char *msgid_plural, unsigned long int n,\n               int category)",
        "*"
      ]
    },
    "dcpgettext_expr": {
      "start_point": [
        210,
        0
      ],
      "end_point": [
        243,
        1
      ],
      "content": "static const char *\ndcpgettext_expr (const char *domain,\n                 const char *msgctxt, const char *msgid,\n                 int category)\n{\n  size_t msgctxt_len = strlen (msgctxt) + 1;\n  size_t msgid_len = strlen (msgid) + 1;\n  const char *translation;\n#if _LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n  char msg_ctxt_id[msgctxt_len + msgid_len];\n#else\n  char buf[1024];\n  char *msg_ctxt_id =\n    (msgctxt_len + msgid_len <= sizeof (buf)\n     ? buf\n     : (char *) malloc (msgctxt_len + msgid_len));\n  if (msg_ctxt_id != NULL)\n#endif\n    {\n      int found_translation;\n      memcpy (msg_ctxt_id, msgctxt, msgctxt_len - 1);\n      msg_ctxt_id[msgctxt_len - 1] = '\\004';\n      memcpy (msg_ctxt_id + msgctxt_len, msgid, msgid_len);\n      translation = dcgettext (domain, msg_ctxt_id, category);\n      found_translation = (translation != msg_ctxt_id);\n#if !_LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n      if (msg_ctxt_id != buf)\n        free (msg_ctxt_id);\n#endif\n      if (found_translation)\n        return translation;\n    }\n  return msgid;\n}",
      "lines": 34,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\ndcpgettext_expr (const char *domain,\n                 const char *msgctxt, const char *msgid,\n                 int category)",
        "*"
      ]
    },
    "dcnpgettext_expr": {
      "start_point": [
        257,
        0
      ],
      "end_point": [
        291,
        1
      ],
      "content": "static const char *\ndcnpgettext_expr (const char *domain,\n                  const char *msgctxt, const char *msgid,\n                  const char *msgid_plural, unsigned long int n,\n                  int category)\n{\n  size_t msgctxt_len = strlen (msgctxt) + 1;\n  size_t msgid_len = strlen (msgid) + 1;\n  const char *translation;\n#if _LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n  char msg_ctxt_id[msgctxt_len + msgid_len];\n#else\n  char buf[1024];\n  char *msg_ctxt_id =\n    (msgctxt_len + msgid_len <= sizeof (buf)\n     ? buf\n     : (char *) malloc (msgctxt_len + msgid_len));\n  if (msg_ctxt_id != NULL)\n#endif\n    {\n      int found_translation;\n      memcpy (msg_ctxt_id, msgctxt, msgctxt_len - 1);\n      msg_ctxt_id[msgctxt_len - 1] = '\\004';\n      memcpy (msg_ctxt_id + msgctxt_len, msgid, msgid_len);\n      translation = dcngettext (domain, msg_ctxt_id, msgid_plural, n, category);\n      found_translation = !(translation == msg_ctxt_id || translation == msgid_plural);\n#if !_LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n      if (msg_ctxt_id != buf)\n        free (msg_ctxt_id);\n#endif\n      if (found_translation)\n        return translation;\n    }\n  return (n == 1 ? msgid : msgid_plural);\n}",
      "lines": 35,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\ndcnpgettext_expr (const char *domain,\n                  const char *msgctxt, const char *msgid,\n                  const char *msgid_plural, unsigned long int n,\n                  int category)",
        "*"
      ]
    }
  },
  "sed/sed-4.5/lib/gettimeofday.c": {
    "initialize": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "static void\ninitialize (void)\n{\n  HMODULE kernel32 = LoadLibrary (\"kernel32.dll\");\n  if (kernel32 != NULL)\n    {\n      GetSystemTimePreciseAsFileTimeFunc =\n\t(GetSystemTimePreciseAsFileTimeFuncType) GetProcAddress (kernel32, \"GetSystemTimePreciseAsFileTime\");\n    }\n  initialized = TRUE;\n}",
      "lines": 11,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "gettimeofday": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        145,
        1
      ],
      "content": "int\ngettimeofday (struct timeval *restrict tv, void *restrict tz)\n{\n#undef gettimeofday\n#ifdef WINDOWS_NATIVE\n\n  /* On native Windows, there are two ways to get the current time:\n     GetSystemTimeAsFileTime\n     <https://msdn.microsoft.com/en-us/library/ms724397.aspx>\n     or\n     GetSystemTimePreciseAsFileTime\n     <https://msdn.microsoft.com/en-us/library/hh706895.aspx>.\n     GetSystemTimeAsFileTime produces values that jump by increments of\n     15.627 milliseconds (!) on average.\n     Whereas GetSystemTimePreciseAsFileTime values usually jump by 1 or 2\n     microseconds.\n     More discussion on this topic:\n     <http://www.windowstimestamp.com/description>.  */\n  FILETIME current_time;\n\n  if (!initialized)\n    initialize ();\n  if (GetSystemTimePreciseAsFileTimeFunc != NULL)\n    GetSystemTimePreciseAsFileTimeFunc (&current_time);\n  else\n    GetSystemTimeAsFileTime (&current_time);\n\n  /* Convert from FILETIME to 'struct timeval'.  */\n  /* FILETIME: <https://msdn.microsoft.com/en-us/library/ms724284.aspx> */\n  ULONGLONG since_1601 =\n    ((ULONGLONG) current_time.dwHighDateTime << 32)\n    | (ULONGLONG) current_time.dwLowDateTime;\n  /* Between 1601-01-01 and 1970-01-01 there were 280 normal years and 89 leap\n     years, in total 134774 days.  */\n  ULONGLONG since_1970 =\n    since_1601 - (ULONGLONG) 134774 * (ULONGLONG) 86400 * (ULONGLONG) 10000000;\n  ULONGLONG microseconds_since_1970 = since_1970 / (ULONGLONG) 10;\n  tv->tv_sec = microseconds_since_1970 / (ULONGLONG) 1000000;\n  tv->tv_usec = microseconds_since_1970 % (ULONGLONG) 1000000;\n\n  return 0;\n\n#else\n\n# if HAVE_GETTIMEOFDAY\n#  if GETTIMEOFDAY_CLOBBERS_LOCALTIME\n  /* Save and restore the contents of the buffer used for localtime's\n     result around the call to gettimeofday.  */\n  struct tm save = *localtime_buffer_addr;\n#  endif\n\n#  if defined timeval /* 'struct timeval' overridden by gnulib?  */\n#   undef timeval\n  struct timeval otv;\n  int result = gettimeofday (&otv, (struct timezone *) tz);\n  if (result == 0)\n    {\n      tv->tv_sec = otv.tv_sec;\n      tv->tv_usec = otv.tv_usec;\n    }\n#  else\n  int result = gettimeofday (tv, (struct timezone *) tz);\n#  endif\n\n#  if GETTIMEOFDAY_CLOBBERS_LOCALTIME\n  *localtime_buffer_addr = save;\n#  endif\n\n  return result;\n\n# else\n\n#  if !defined OK_TO_USE_1S_CLOCK\n#   error \"Only 1-second nominal clock resolution found.  Is that intended?\" \\\n          \"If so, compile with the -DOK_TO_USE_1S_CLOCK option.\"\n#  endif\n  tv->tv_sec = time (NULL);\n  tv->tv_usec = 0;\n\n  return 0;\n\n# endif\n#endif\n}",
      "lines": 84,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/lib/hard-locale.c": {
    "hard_locale": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "bool\nhard_locale (int category)\n{\n  bool hard = true;\n  char const *p = setlocale (category, NULL);\n\n  if (p)\n    {\n      if (2 <= GLIBC_VERSION)\n        {\n          if (strcmp (p, \"C\") == 0 || strcmp (p, \"POSIX\") == 0)\n            hard = false;\n        }\n      else\n        {\n          char *locale = strdup (p);\n          if (locale)\n            {\n              /* Temporarily set the locale to the \"C\" and \"POSIX\" locales\n                 to find their names, so that we can determine whether one\n                 or the other is the caller's locale.  */\n              if (((p = setlocale (category, \"C\"))\n                   && strcmp (p, locale) == 0)\n                  || ((p = setlocale (category, \"POSIX\"))\n                      && strcmp (p, locale) == 0))\n                hard = false;\n\n              /* Restore the caller's locale.  */\n              setlocale (category, locale);\n              free (locale);\n            }\n        }\n    }\n\n  return hard;\n}",
      "lines": 36,
      "depth": 19,
      "decorators": [
        "bool"
      ]
    }
  },
  "sed/sed-4.5/lib/hard-locale.h": {},
  "sed/sed-4.5/lib/ignore-value.h": {},
  "sed/sed-4.5/lib/intprops.h": {},
  "sed/sed-4.5/lib/isblank.c": {
    "isblank": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        32,
        1
      ],
      "content": "int\nisblank (int c)\n{\n  /* On all known platforms, in all predefined locales, isblank(c) is likely\n     equivalent with  (c == ' ' || c == '\\t').  Look at the glibc definition\n     (in glibc/localedata/locales/i18n): The \"blank\" characters are '\\t', ' ',\n     U+1680, U+180E, U+2000..U+2006, U+2008..U+200A, U+205F, U+3000, and none\n     except the first two is present in a common 8-bit encoding.  Therefore\n     the substitute for other platforms is not more complicated than this.  */\n  return (c == ' ' || c == '\\t');\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/lib/langinfo.in.h": {},
  "sed/sed-4.5/lib/limits.in.h": {},
  "sed/sed-4.5/lib/localcharset.c": {
    "get_charset_aliases": {
      "start_point": [
        123,
        0
      ],
      "end_point": [
        384,
        1
      ],
      "content": "static const char *\nget_charset_aliases (void)\n{\n  const char *cp;\n\n  cp = charset_aliases;\n  if (cp == NULL)\n    {\n#if !(defined DARWIN7 || defined VMS || defined WINDOWS_NATIVE || defined __CYGWIN__ || defined OS2)\n      char *malloc_dir = NULL;\n      const char *dir;\n      const char *base = \"charset.alias\";\n      char *file_name;\n\n      /* Make it possible to override the charset.alias location.  This is\n         necessary for running the testsuite before \"make install\".  */\n      dir = getenv (\"CHARSETALIASDIR\");\n      if (dir == NULL || dir[0] == '\\0')\n        dir = relocate2 (LIBDIR, &malloc_dir);\n\n      /* Concatenate dir and base into freshly allocated file_name.  */\n      {\n        size_t dir_len = strlen (dir);\n        size_t base_len = strlen (base);\n        int add_slash = (dir_len > 0 && !ISSLASH (dir[dir_len - 1]));\n        file_name = (char *) malloc (dir_len + add_slash + base_len + 1);\n        if (file_name != NULL)\n          {\n            memcpy (file_name, dir, dir_len);\n            if (add_slash)\n              file_name[dir_len] = DIRECTORY_SEPARATOR;\n            memcpy (file_name + dir_len + add_slash, base, base_len + 1);\n          }\n      }\n\n      free (malloc_dir);\n\n      if (file_name == NULL)\n        /* Out of memory.  Treat the file as empty.  */\n        cp = \"\";\n      else\n        {\n          int fd;\n\n          /* Open the file.  Reject symbolic links on platforms that support\n             O_NOFOLLOW.  This is a security feature.  Without it, an attacker\n             could retrieve parts of the contents (namely, the tail of the\n             first line that starts with \"* \") of an arbitrary file by placing\n             a symbolic link to that file under the name \"charset.alias\" in\n             some writable directory and defining the environment variable\n             CHARSETALIASDIR to point to that directory.  */\n          fd = open (file_name,\n                     O_RDONLY | (HAVE_WORKING_O_NOFOLLOW ? O_NOFOLLOW : 0));\n          if (fd < 0)\n            /* File not found.  Treat it as empty.  */\n            cp = \"\";\n          else\n            {\n              FILE *fp;\n\n              fp = fdopen (fd, \"r\");\n              if (fp == NULL)\n                {\n                  /* Out of memory.  Treat the file as empty.  */\n                  close (fd);\n                  cp = \"\";\n                }\n              else\n                {\n                  /* Parse the file's contents.  */\n                  char *res_ptr = NULL;\n                  size_t res_size = 0;\n\n                  for (;;)\n                    {\n                      int c;\n                      char buf1[50+1];\n                      char buf2[50+1];\n                      size_t l1, l2;\n                      char *old_res_ptr;\n\n                      c = getc (fp);\n                      if (c == EOF)\n                        break;\n                      if (c == '\\n' || c == ' ' || c == '\\t')\n                        continue;\n                      if (c == '#')\n                        {\n                          /* Skip comment, to end of line.  */\n                          do\n                            c = getc (fp);\n                          while (!(c == EOF || c == '\\n'));\n                          if (c == EOF)\n                            break;\n                          continue;\n                        }\n                      ungetc (c, fp);\n                      if (fscanf (fp, \"%50s %50s\", buf1, buf2) < 2)\n                        break;\n                      l1 = strlen (buf1);\n                      l2 = strlen (buf2);\n                      old_res_ptr = res_ptr;\n                      if (res_size == 0)\n                        {\n                          res_size = l1 + 1 + l2 + 1;\n                          res_ptr = (char *) malloc (res_size + 1);\n                        }\n                      else\n                        {\n                          res_size += l1 + 1 + l2 + 1;\n                          res_ptr = (char *) realloc (res_ptr, res_size + 1);\n                        }\n                      if (res_ptr == NULL)\n                        {\n                          /* Out of memory. */\n                          res_size = 0;\n                          free (old_res_ptr);\n                          break;\n                        }\n                      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);\n                      strcpy (res_ptr + res_size - (l2 + 1), buf2);\n                    }\n                  fclose (fp);\n                  if (res_size == 0)\n                    cp = \"\";\n                  else\n                    {\n                      *(res_ptr + res_size) = '\\0';\n                      cp = res_ptr;\n                    }\n                }\n            }\n\n          free (file_name);\n        }\n\n#else\n\n# if defined DARWIN7\n      /* To avoid the trouble of installing a file that is shared by many\n         GNU packages -- many packaging systems have problems with this --,\n         simply inline the aliases here.  */\n      cp = \"ISO8859-1\" \"\\0\" \"ISO-8859-1\" \"\\0\"\n           \"ISO8859-2\" \"\\0\" \"ISO-8859-2\" \"\\0\"\n           \"ISO8859-4\" \"\\0\" \"ISO-8859-4\" \"\\0\"\n           \"ISO8859-5\" \"\\0\" \"ISO-8859-5\" \"\\0\"\n           \"ISO8859-7\" \"\\0\" \"ISO-8859-7\" \"\\0\"\n           \"ISO8859-9\" \"\\0\" \"ISO-8859-9\" \"\\0\"\n           \"ISO8859-13\" \"\\0\" \"ISO-8859-13\" \"\\0\"\n           \"ISO8859-15\" \"\\0\" \"ISO-8859-15\" \"\\0\"\n           \"KOI8-R\" \"\\0\" \"KOI8-R\" \"\\0\"\n           \"KOI8-U\" \"\\0\" \"KOI8-U\" \"\\0\"\n           \"CP866\" \"\\0\" \"CP866\" \"\\0\"\n           \"CP949\" \"\\0\" \"CP949\" \"\\0\"\n           \"CP1131\" \"\\0\" \"CP1131\" \"\\0\"\n           \"CP1251\" \"\\0\" \"CP1251\" \"\\0\"\n           \"eucCN\" \"\\0\" \"GB2312\" \"\\0\"\n           \"GB2312\" \"\\0\" \"GB2312\" \"\\0\"\n           \"eucJP\" \"\\0\" \"EUC-JP\" \"\\0\"\n           \"eucKR\" \"\\0\" \"EUC-KR\" \"\\0\"\n           \"Big5\" \"\\0\" \"BIG5\" \"\\0\"\n           \"Big5HKSCS\" \"\\0\" \"BIG5-HKSCS\" \"\\0\"\n           \"GBK\" \"\\0\" \"GBK\" \"\\0\"\n           \"GB18030\" \"\\0\" \"GB18030\" \"\\0\"\n           \"SJIS\" \"\\0\" \"SHIFT_JIS\" \"\\0\"\n           \"ARMSCII-8\" \"\\0\" \"ARMSCII-8\" \"\\0\"\n           \"PT154\" \"\\0\" \"PT154\" \"\\0\"\n         /*\"ISCII-DEV\" \"\\0\" \"?\" \"\\0\"*/\n           \"*\" \"\\0\" \"UTF-8\" \"\\0\";\n# endif\n\n# if defined VMS\n      /* To avoid the troubles of an extra file charset.alias_vms in the\n         sources of many GNU packages, simply inline the aliases here.  */\n      /* The list of encodings is taken from the OpenVMS 7.3-1 documentation\n         \"Compaq C Run-Time Library Reference Manual for OpenVMS systems\"\n         section 10.7 \"Handling Different Character Sets\".  */\n      cp = \"ISO8859-1\" \"\\0\" \"ISO-8859-1\" \"\\0\"\n           \"ISO8859-2\" \"\\0\" \"ISO-8859-2\" \"\\0\"\n           \"ISO8859-5\" \"\\0\" \"ISO-8859-5\" \"\\0\"\n           \"ISO8859-7\" \"\\0\" \"ISO-8859-7\" \"\\0\"\n           \"ISO8859-8\" \"\\0\" \"ISO-8859-8\" \"\\0\"\n           \"ISO8859-9\" \"\\0\" \"ISO-8859-9\" \"\\0\"\n           /* Japanese */\n           \"eucJP\" \"\\0\" \"EUC-JP\" \"\\0\"\n           \"SJIS\" \"\\0\" \"SHIFT_JIS\" \"\\0\"\n           \"DECKANJI\" \"\\0\" \"DEC-KANJI\" \"\\0\"\n           \"SDECKANJI\" \"\\0\" \"EUC-JP\" \"\\0\"\n           /* Chinese */\n           \"eucTW\" \"\\0\" \"EUC-TW\" \"\\0\"\n           \"DECHANYU\" \"\\0\" \"DEC-HANYU\" \"\\0\"\n           \"DECHANZI\" \"\\0\" \"GB2312\" \"\\0\"\n           /* Korean */\n           \"DECKOREAN\" \"\\0\" \"EUC-KR\" \"\\0\";\n# endif\n\n# if defined WINDOWS_NATIVE || defined __CYGWIN__\n      /* To avoid the troubles of installing a separate file in the same\n         directory as the DLL and of retrieving the DLL's directory at\n         runtime, simply inline the aliases here.  */\n\n      cp = \"CP936\" \"\\0\" \"GBK\" \"\\0\"\n           \"CP1361\" \"\\0\" \"JOHAB\" \"\\0\"\n           \"CP20127\" \"\\0\" \"ASCII\" \"\\0\"\n           \"CP20866\" \"\\0\" \"KOI8-R\" \"\\0\"\n           \"CP20936\" \"\\0\" \"GB2312\" \"\\0\"\n           \"CP21866\" \"\\0\" \"KOI8-RU\" \"\\0\"\n           \"CP28591\" \"\\0\" \"ISO-8859-1\" \"\\0\"\n           \"CP28592\" \"\\0\" \"ISO-8859-2\" \"\\0\"\n           \"CP28593\" \"\\0\" \"ISO-8859-3\" \"\\0\"\n           \"CP28594\" \"\\0\" \"ISO-8859-4\" \"\\0\"\n           \"CP28595\" \"\\0\" \"ISO-8859-5\" \"\\0\"\n           \"CP28596\" \"\\0\" \"ISO-8859-6\" \"\\0\"\n           \"CP28597\" \"\\0\" \"ISO-8859-7\" \"\\0\"\n           \"CP28598\" \"\\0\" \"ISO-8859-8\" \"\\0\"\n           \"CP28599\" \"\\0\" \"ISO-8859-9\" \"\\0\"\n           \"CP28605\" \"\\0\" \"ISO-8859-15\" \"\\0\"\n           \"CP38598\" \"\\0\" \"ISO-8859-8\" \"\\0\"\n           \"CP51932\" \"\\0\" \"EUC-JP\" \"\\0\"\n           \"CP51936\" \"\\0\" \"GB2312\" \"\\0\"\n           \"CP51949\" \"\\0\" \"EUC-KR\" \"\\0\"\n           \"CP51950\" \"\\0\" \"EUC-TW\" \"\\0\"\n           \"CP54936\" \"\\0\" \"GB18030\" \"\\0\"\n           \"CP65001\" \"\\0\" \"UTF-8\" \"\\0\";\n# endif\n# if defined OS2\n      /* To avoid the troubles of installing a separate file in the same\n         directory as the DLL and of retrieving the DLL's directory at\n         runtime, simply inline the aliases here.  */\n\n      /* The list of encodings is taken from \"List of OS/2 Codepages\"\n         by Alex Taylor:\n         <http://altsan.org/os2/toolkits/uls/index.html#codepages>.\n         See also \"IBM Globalization - Code page identifiers\":\n         <https://www-01.ibm.com/software/globalization/cp/cp_cpgid.html>.  */\n      cp = \"CP813\" \"\\0\" \"ISO-8859-7\" \"\\0\"\n           \"CP878\" \"\\0\" \"KOI8-R\" \"\\0\"\n           \"CP819\" \"\\0\" \"ISO-8859-1\" \"\\0\"\n           \"CP912\" \"\\0\" \"ISO-8859-2\" \"\\0\"\n           \"CP913\" \"\\0\" \"ISO-8859-3\" \"\\0\"\n           \"CP914\" \"\\0\" \"ISO-8859-4\" \"\\0\"\n           \"CP915\" \"\\0\" \"ISO-8859-5\" \"\\0\"\n           \"CP916\" \"\\0\" \"ISO-8859-8\" \"\\0\"\n           \"CP920\" \"\\0\" \"ISO-8859-9\" \"\\0\"\n           \"CP921\" \"\\0\" \"ISO-8859-13\" \"\\0\"\n           \"CP923\" \"\\0\" \"ISO-8859-15\" \"\\0\"\n           \"CP954\" \"\\0\" \"EUC-JP\" \"\\0\"\n           \"CP964\" \"\\0\" \"EUC-TW\" \"\\0\"\n           \"CP970\" \"\\0\" \"EUC-KR\" \"\\0\"\n           \"CP1089\" \"\\0\" \"ISO-8859-6\" \"\\0\"\n           \"CP1208\" \"\\0\" \"UTF-8\" \"\\0\"\n           \"CP1381\" \"\\0\" \"GB2312\" \"\\0\"\n           \"CP1386\" \"\\0\" \"GBK\" \"\\0\"\n           \"CP3372\" \"\\0\" \"EUC-JP\" \"\\0\";\n# endif\n#endif\n\n      charset_aliases = cp;\n    }\n\n  return cp;\n}",
      "lines": 262,
      "depth": 23,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nget_charset_aliases (void)",
        "*"
      ]
    },
    "locale_charset": {
      "start_point": [
        395,
        0
      ],
      "end_point": [
        616,
        1
      ],
      "content": "const char *\nlocale_charset (void)\n{\n  const char *codeset;\n  const char *aliases;\n\n#if !(defined WINDOWS_NATIVE || defined OS2)\n\n# if HAVE_LANGINFO_CODESET\n\n  /* Most systems support nl_langinfo (CODESET) nowadays.  */\n  codeset = nl_langinfo (CODESET);\n\n#  ifdef __CYGWIN__\n  /* Cygwin < 1.7 does not have locales.  nl_langinfo (CODESET) always\n     returns \"US-ASCII\".  Return the suffix of the locale name from the\n     environment variables (if present) or the codepage as a number.  */\n  if (codeset != NULL && strcmp (codeset, \"US-ASCII\") == 0)\n    {\n      const char *locale;\n      static char buf[2 + 10 + 1];\n\n      locale = getenv (\"LC_ALL\");\n      if (locale == NULL || locale[0] == '\\0')\n        {\n          locale = getenv (\"LC_CTYPE\");\n          if (locale == NULL || locale[0] == '\\0')\n            locale = getenv (\"LANG\");\n        }\n      if (locale != NULL && locale[0] != '\\0')\n        {\n          /* If the locale name contains an encoding after the dot, return\n             it.  */\n          const char *dot = strchr (locale, '.');\n\n          if (dot != NULL)\n            {\n              const char *modifier;\n\n              dot++;\n              /* Look for the possible @... trailer and remove it, if any.  */\n              modifier = strchr (dot, '@');\n              if (modifier == NULL)\n                return dot;\n              if (modifier - dot < sizeof (buf))\n                {\n                  memcpy (buf, dot, modifier - dot);\n                  buf [modifier - dot] = '\\0';\n                  return buf;\n                }\n            }\n        }\n\n      /* The Windows API has a function returning the locale's codepage as a\n         number: GetACP().  This encoding is used by Cygwin, unless the user\n         has set the environment variable CYGWIN=codepage:oem (which very few\n         people do).\n         Output directed to console windows needs to be converted (to\n         GetOEMCP() if the console is using a raster font, or to\n         GetConsoleOutputCP() if it is using a TrueType font).  Cygwin does\n         this conversion transparently (see winsup/cygwin/fhandler_console.cc),\n         converting to GetConsoleOutputCP().  This leads to correct results,\n         except when SetConsoleOutputCP has been called and a raster font is\n         in use.  */\n      sprintf (buf, \"CP%u\", GetACP ());\n      codeset = buf;\n    }\n#  endif\n\n# else\n\n  /* On old systems which lack it, use setlocale or getenv.  */\n  const char *locale = NULL;\n\n  /* But most old systems don't have a complete set of locales.  Some\n     (like SunOS 4 or DJGPP) have only the C locale.  Therefore we don't\n     use setlocale here; it would return \"C\" when it doesn't support the\n     locale name the user has set.  */\n#  if 0\n  locale = setlocale (LC_CTYPE, NULL);\n#  endif\n  if (locale == NULL || locale[0] == '\\0')\n    {\n      locale = getenv (\"LC_ALL\");\n      if (locale == NULL || locale[0] == '\\0')\n        {\n          locale = getenv (\"LC_CTYPE\");\n          if (locale == NULL || locale[0] == '\\0')\n            locale = getenv (\"LANG\");\n        }\n    }\n\n  /* On some old systems, one used to set locale = \"iso8859_1\". On others,\n     you set it to \"language_COUNTRY.charset\". In any case, we resolve it\n     through the charset.alias file.  */\n  codeset = locale;\n\n# endif\n\n#elif defined WINDOWS_NATIVE\n\n  static char buf[2 + 10 + 1];\n\n  /* The Windows API has a function returning the locale's codepage as\n     a number, but the value doesn't change according to what the\n     'setlocale' call specified.  So we use it as a last resort, in\n     case the string returned by 'setlocale' doesn't specify the\n     codepage.  */\n  char *current_locale = setlocale (LC_ALL, NULL);\n  char *pdot;\n\n  /* If they set different locales for different categories,\n     'setlocale' will return a semi-colon separated list of locale\n     values.  To make sure we use the correct one, we choose LC_CTYPE.  */\n  if (strchr (current_locale, ';'))\n    current_locale = setlocale (LC_CTYPE, NULL);\n\n  pdot = strrchr (current_locale, '.');\n  if (pdot && 2 + strlen (pdot + 1) + 1 <= sizeof (buf))\n    sprintf (buf, \"CP%s\", pdot + 1);\n  else\n    {\n      /* The Windows API has a function returning the locale's codepage as a\n        number: GetACP().\n        When the output goes to a console window, it needs to be provided in\n        GetOEMCP() encoding if the console is using a raster font, or in\n        GetConsoleOutputCP() encoding if it is using a TrueType font.\n        But in GUI programs and for output sent to files and pipes, GetACP()\n        encoding is the best bet.  */\n      sprintf (buf, \"CP%u\", GetACP ());\n    }\n  codeset = buf;\n\n#elif defined OS2\n\n  const char *locale;\n  static char buf[2 + 10 + 1];\n  ULONG cp[3];\n  ULONG cplen;\n\n  codeset = NULL;\n\n  /* Allow user to override the codeset, as set in the operating system,\n     with standard language environment variables.  */\n  locale = getenv (\"LC_ALL\");\n  if (locale == NULL || locale[0] == '\\0')\n    {\n      locale = getenv (\"LC_CTYPE\");\n      if (locale == NULL || locale[0] == '\\0')\n        locale = getenv (\"LANG\");\n    }\n  if (locale != NULL && locale[0] != '\\0')\n    {\n      /* If the locale name contains an encoding after the dot, return it.  */\n      const char *dot = strchr (locale, '.');\n\n      if (dot != NULL)\n        {\n          const char *modifier;\n\n          dot++;\n          /* Look for the possible @... trailer and remove it, if any.  */\n          modifier = strchr (dot, '@');\n          if (modifier == NULL)\n            return dot;\n          if (modifier - dot < sizeof (buf))\n            {\n              memcpy (buf, dot, modifier - dot);\n              buf [modifier - dot] = '\\0';\n              return buf;\n            }\n        }\n\n      /* For the POSIX locale, don't use the system's codepage.  */\n      if (strcmp (locale, \"C\") == 0 || strcmp (locale, \"POSIX\") == 0)\n        codeset = \"\";\n    }\n\n  if (codeset == NULL)\n    {\n      /* OS/2 has a function returning the locale's codepage as a number.  */\n      if (DosQueryCp (sizeof (cp), cp, &cplen))\n        codeset = \"\";\n      else\n        {\n          sprintf (buf, \"CP%u\", cp[0]);\n          codeset = buf;\n        }\n    }\n\n#endif\n\n  if (codeset == NULL)\n    /* The canonical name cannot be determined.  */\n    codeset = \"\";\n\n  /* Resolve alias. */\n  for (aliases = get_charset_aliases ();\n       *aliases != '\\0';\n       aliases += strlen (aliases) + 1, aliases += strlen (aliases) + 1)\n    if (strcmp (codeset, aliases) == 0\n        || (aliases[0] == '*' && aliases[1] == '\\0'))\n      {\n        codeset = aliases + strlen (aliases) + 1;\n        break;\n      }\n\n  /* Don't return an empty string.  GNU libc and GNU libiconv interpret\n     the empty string as denoting \"the locale's character encoding\",\n     thus GNU libiconv would call this function a second time.  */\n  if (codeset[0] == '\\0')\n    codeset = \"ASCII\";\n\n#ifdef DARWIN7\n  /* Mac OS X sets MB_CUR_MAX to 1 when LC_ALL=C, and \"UTF-8\"\n     (the default codeset) does not work when MB_CUR_MAX is 1.  */\n  if (strcmp (codeset, \"UTF-8\") == 0 && MB_CUR_MAX_L (uselocale (NULL)) <= 1)\n    codeset = \"ASCII\";\n#endif\n\n  return codeset;\n}",
      "lines": 222,
      "depth": 18,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nlocale_charset (void)",
        "*"
      ]
    }
  },
  "sed/sed-4.5/lib/localcharset.h": {},
  "sed/sed-4.5/lib/locale.in.h": {},
  "sed/sed-4.5/lib/localeconv.c": {
    "localeconv": [
      {
        "start_point": [
          26,
          0
        ],
        "end_point": [
          60,
          1
        ],
        "content": "struct lconv *\nlocaleconv (void)\n{\n  static struct lconv result;\n# undef lconv\n# undef localeconv\n  struct lconv *sys_result = localeconv ();\n\n  result.decimal_point = sys_result->decimal_point;\n  result.thousands_sep = sys_result->thousands_sep;\n  result.grouping = sys_result->grouping;\n  result.mon_decimal_point = sys_result->mon_decimal_point;\n  result.mon_thousands_sep = sys_result->mon_thousands_sep;\n  result.mon_grouping = sys_result->mon_grouping;\n  result.positive_sign = sys_result->positive_sign;\n  result.negative_sign = sys_result->negative_sign;\n  result.currency_symbol = sys_result->currency_symbol;\n  result.frac_digits = sys_result->frac_digits;\n  result.p_cs_precedes = sys_result->p_cs_precedes;\n  result.p_sign_posn = sys_result->p_sign_posn;\n  result.p_sep_by_space = sys_result->p_sep_by_space;\n  result.n_cs_precedes = sys_result->n_cs_precedes;\n  result.n_sign_posn = sys_result->n_sign_posn;\n  result.n_sep_by_space = sys_result->n_sep_by_space;\n  result.int_curr_symbol = sys_result->int_curr_symbol;\n  result.int_frac_digits = sys_result->int_frac_digits;\n  result.int_p_cs_precedes = sys_result->p_cs_precedes;\n  result.int_p_sign_posn = sys_result->p_sign_posn;\n  result.int_p_sep_by_space = sys_result->p_sep_by_space;\n  result.int_n_cs_precedes = sys_result->n_cs_precedes;\n  result.int_n_sign_posn = sys_result->n_sign_posn;\n  result.int_n_sep_by_space = sys_result->n_sep_by_space;\n\n  return &result;\n}",
        "lines": 35,
        "depth": 7,
        "decorators": [
          "struct lconv",
          "struct",
          "lconv",
          "*\nlocaleconv (void)",
          "*"
        ]
      },
      {
        "start_point": [
          68,
          0
        ],
        "end_point": [
          100,
          1
        ],
        "content": "struct lconv *\nlocaleconv (void)\n{\n  static /*const*/ struct lconv result =\n    {\n      /* decimal_point */ \".\",\n      /* thousands_sep */ \"\",\n      /* grouping */ \"\",\n      /* mon_decimal_point */ \"\",\n      /* mon_thousands_sep */ \"\",\n      /* mon_grouping */ \"\",\n      /* positive_sign */ \"\",\n      /* negative_sign */ \"\",\n      /* currency_symbol */ \"\",\n      /* frac_digits */ CHAR_MAX,\n      /* p_cs_precedes */ CHAR_MAX,\n      /* p_sign_posn */ CHAR_MAX,\n      /* p_sep_by_space */ CHAR_MAX,\n      /* n_cs_precedes */ CHAR_MAX,\n      /* n_sign_posn */ CHAR_MAX,\n      /* n_sep_by_space */ CHAR_MAX,\n      /* int_curr_symbol */ \"\",\n      /* int_frac_digits */ CHAR_MAX,\n      /* int_p_cs_precedes */ CHAR_MAX,\n      /* int_p_sign_posn */ CHAR_MAX,\n      /* int_p_sep_by_space */ CHAR_MAX,\n      /* int_n_cs_precedes */ CHAR_MAX,\n      /* int_n_sign_posn */ CHAR_MAX,\n      /* int_n_sep_by_space */ CHAR_MAX\n    };\n\n  return &result;\n}",
        "lines": 33,
        "depth": 7,
        "decorators": [
          "struct lconv",
          "struct",
          "lconv",
          "*\nlocaleconv (void)",
          "*"
        ]
      }
    ]
  },
  "sed/sed-4.5/lib/localeinfo.c": {
    "is_using_utf8": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "static bool\nis_using_utf8 (void)\n{\n  wchar_t wc;\n  mbstate_t mbs = {0};\n  return mbrtowc (&wc, \"\\xc4\\x80\", 2, &mbs) == 2 && wc == 0x100;\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "init_localeinfo": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "void\ninit_localeinfo (struct localeinfo *localeinfo)\n{\n  int i;\n\n  localeinfo->multibyte = MB_CUR_MAX > 1;\n  localeinfo->using_utf8 = is_using_utf8 ();\n\n  for (i = CHAR_MIN; i <= CHAR_MAX; i++)\n    {\n      char c = i;\n      unsigned char uc = i;\n      mbstate_t s = {0};\n      wchar_t wc;\n      size_t len = mbrtowc (&wc, &c, 1, &s);\n      localeinfo->sbclen[uc] = len <= 1 ? 1 : - (int) - len;\n      localeinfo->sbctowc[uc] = len <= 1 ? wc : WEOF;\n    }\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "case_folded_counterparts": {
      "start_point": [
        94,
        0
      ],
      "end_point": [
        112,
        1
      ],
      "content": "int\ncase_folded_counterparts (wint_t c, wchar_t folded[CASE_FOLDED_BUFSIZE])\n{\n  int i;\n  int n = 0;\n  wint_t uc = towupper (c);\n  wint_t lc = towlower (uc);\n  if (uc != c)\n    folded[n++] = uc;\n  if (lc != uc && lc != c && towupper (lc) == uc)\n    folded[n++] = lc;\n  for (i = 0; i < sizeof lonesome_lower / sizeof *lonesome_lower; i++)\n    {\n      wint_t li = lonesome_lower[i];\n      if (li != lc && li != uc && li != c && towupper (li) == uc)\n        folded[n++] = li;\n    }\n  return n;\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/lib/localeinfo.h": {},
  "sed/sed-4.5/lib/localtime-buffer.c": {
    "rpl_localtime": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "struct tm *\nrpl_localtime (time_t const *timep)\n{\n  struct tm *tm = localtime (timep);\n\n  if (localtime_buffer_addr == &tm_zero_buffer)\n    localtime_buffer_addr = tm;\n\n  return tm;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "struct tm",
        "struct",
        "tm",
        "*\nrpl_localtime (time_t const *timep)",
        "*"
      ]
    },
    "rpl_gmtime": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "struct tm *\nrpl_gmtime (time_t const *timep)\n{\n  struct tm *tm = gmtime (timep);\n\n  if (localtime_buffer_addr == &tm_zero_buffer)\n    localtime_buffer_addr = tm;\n\n  return tm;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "struct tm",
        "struct",
        "tm",
        "*\nrpl_gmtime (time_t const *timep)",
        "*"
      ]
    }
  },
  "sed/sed-4.5/lib/localtime-buffer.h": {},
  "sed/sed-4.5/lib/lstat.c": {
    "orig_lstat": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        41,
        1
      ],
      "content": "static int\norig_lstat (const char *filename, struct stat *buf)\n{\n  return lstat (filename, buf);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_lstat": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        97,
        1
      ],
      "content": "int\nrpl_lstat (const char *file, struct stat *sbuf)\n{\n  int result = orig_lstat (file, sbuf);\n\n  /* This replacement file can blindly check against '/' rather than\n     using the ISSLASH macro, because all platforms with '\\\\' either\n     lack symlinks (mingw) or have working lstat (cygwin) and thus do\n     not compile this file.  0 len should have already been filtered\n     out above, with a failure return of ENOENT.  */\n  if (result == 0)\n    {\n      if (S_ISDIR (sbuf->st_mode) || file[strlen (file) - 1] != '/')\n        result = stat_time_normalize (result, sbuf);\n      else\n        {\n          /* At this point, a trailing slash is permitted only on\n             symlink-to-dir; but it should have found information on the\n             directory, not the symlink.  Call 'stat' to get info about the\n             link's referent.  Our replacement stat guarantees valid results,\n             even if the symlink is not pointing to a directory.  */\n          if (!S_ISLNK (sbuf->st_mode))\n            {\n              errno = ENOTDIR;\n              return -1;\n            }\n          result = stat (file, sbuf);\n        }\n    }\n  return result;\n}",
      "lines": 31,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/lib/malloc.c": {
    "rpl_malloc": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "void *\nrpl_malloc (size_t n)\n{\n  void *result;\n\n#if NEED_MALLOC_GNU\n  if (n == 0)\n    n = 1;\n#endif\n\n  result = malloc (n);\n\n#if !HAVE_MALLOC_POSIX\n  if (result == NULL)\n    errno = ENOMEM;\n#endif\n\n  return result;\n}",
      "lines": 19,
      "depth": 7,
      "decorators": [
        "void",
        "*\nrpl_malloc (size_t n)",
        "*"
      ]
    }
  },
  "sed/sed-4.5/lib/malloca.c": {
    "mmalloca": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "void *\nmmalloca (size_t n)\n{\n#if HAVE_ALLOCA\n  /* Allocate one more word, used to determine the address to pass to freea(),\n     and room for the alignment \u00e2\u0089\u00a1 sa_alignment_max mod 2*sa_alignment_max.  */\n  size_t nplus = n + sizeof (small_t) + 2 * sa_alignment_max - 1;\n\n  if (nplus >= n)\n    {\n      char *mem = (char *) malloc (nplus);\n\n      if (mem != NULL)\n        {\n          char *p =\n            (char *)((((uintptr_t)mem + sizeof (small_t) + sa_alignment_max - 1)\n                      & ~(uintptr_t)(2 * sa_alignment_max - 1))\n                     + sa_alignment_max);\n          /* Here p >= mem + sizeof (small_t),\n             and p <= mem + sizeof (small_t) + 2 * sa_alignment_max - 1\n             hence p + n <= mem + nplus.\n             So, the memory range [p, p+n) lies in the allocated memory range\n             [mem, mem + nplus).  */\n          ((small_t *) p)[-1] = p - mem;\n          /* p \u00e2\u0089\u00a1 sa_alignment_max mod 2*sa_alignment_max.  */\n          return p;\n        }\n    }\n  /* Out of memory.  */\n  return NULL;\n#else\n# if !MALLOC_0_IS_NONNULL\n  if (n == 0)\n    n = 1;\n# endif\n  return malloc (n);\n#endif\n}",
      "lines": 38,
      "depth": 21,
      "decorators": [
        "void",
        "*\nmmalloca (size_t n)",
        "*"
      ]
    },
    "freea": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        96,
        1
      ],
      "content": "void\nfreea (void *p)\n{\n  /* Check argument.  */\n  if ((uintptr_t) p & (sa_alignment_max - 1))\n    {\n      /* p was not the result of a malloca() call.  Invalid argument.  */\n      abort ();\n    }\n  /* Determine whether p was a non-NULL pointer returned by mmalloca().  */\n  if ((uintptr_t) p & sa_alignment_max)\n    {\n      void *mem = (char *) p - ((small_t *) p)[-1];\n      free (mem);\n    }\n}",
      "lines": 16,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "sed/sed-4.5/lib/malloca.h": {},
  "sed/sed-4.5/lib/mbrlen.c": {
    "mbrlen": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        31,
        1
      ],
      "content": "size_t\nmbrlen (const char *s, size_t n, mbstate_t *ps)\n{\n  if (ps == NULL)\n    ps = &internal_state;\n  return mbrtowc (NULL, s, n, ps);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "size_t"
      ]
    }
  },
  "sed/sed-4.5/lib/mbrtowc.c": {
    "mbrtowc": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        332,
        1
      ],
      "content": "size_t\nmbrtowc (wchar_t *pwc, const char *s, size_t n, mbstate_t *ps)\n{\n  char *pstate = (char *)ps;\n\n  if (s == NULL)\n    {\n      pwc = NULL;\n      s = \"\";\n      n = 1;\n    }\n\n  if (n == 0)\n    return (size_t)(-2);\n\n  /* Here n > 0.  */\n\n  if (pstate == NULL)\n    pstate = internal_state;\n\n  {\n    size_t nstate = pstate[0];\n    char buf[4];\n    const char *p;\n    size_t m;\n\n    switch (nstate)\n      {\n      case 0:\n        p = s;\n        m = n;\n        break;\n      case 3:\n        buf[2] = pstate[3];\n        FALLTHROUGH;\n      case 2:\n        buf[1] = pstate[2];\n        FALLTHROUGH;\n      case 1:\n        buf[0] = pstate[1];\n        p = buf;\n        m = nstate;\n        buf[m++] = s[0];\n        if (n >= 2 && m < 4)\n          {\n            buf[m++] = s[1];\n            if (n >= 3 && m < 4)\n              buf[m++] = s[2];\n          }\n        break;\n      default:\n        errno = EINVAL;\n        return (size_t)(-1);\n      }\n\n    /* Here m > 0.  */\n\n# if __GLIBC__ || defined __UCLIBC__\n    /* Work around bug <https://sourceware.org/bugzilla/show_bug.cgi?id=9674> */\n    mbtowc (NULL, NULL, 0);\n# endif\n    {\n      int res = mbtowc (pwc, p, m);\n\n      if (res >= 0)\n        {\n          if (pwc != NULL && ((*pwc == 0) != (res == 0)))\n            abort ();\n          if (nstate >= (res > 0 ? res : 1))\n            abort ();\n          res -= nstate;\n          pstate[0] = 0;\n          return res;\n        }\n\n      /* mbtowc does not distinguish between invalid and incomplete multibyte\n         sequences.  But mbrtowc needs to make this distinction.\n         There are two possible approaches:\n           - Use iconv() and its return value.\n           - Use built-in knowledge about the possible encodings.\n         Given the low quality of implementation of iconv() on the systems that\n         lack mbrtowc(), we use the second approach.\n         The possible encodings are:\n           - 8-bit encodings,\n           - EUC-JP, EUC-KR, GB2312, EUC-TW, BIG5, GB18030, SJIS,\n           - UTF-8.\n         Use specialized code for each.  */\n      if (m >= 4 || m >= MB_CUR_MAX)\n        goto invalid;\n      /* Here MB_CUR_MAX > 1 and 0 < m < 4.  */\n      {\n        const char *encoding = locale_charset ();\n\n        if (STREQ_OPT (encoding, \"UTF-8\", 'U', 'T', 'F', '-', '8', 0, 0, 0, 0))\n          {\n            /* Cf. unistr/u8-mblen.c.  */\n            unsigned char c = (unsigned char) p[0];\n\n            if (c >= 0xc2)\n              {\n                if (c < 0xe0)\n                  {\n                    if (m == 1)\n                      goto incomplete;\n                  }\n                else if (c < 0xf0)\n                  {\n                    if (m == 1)\n                      goto incomplete;\n                    if (m == 2)\n                      {\n                        unsigned char c2 = (unsigned char) p[1];\n\n                        if ((c2 ^ 0x80) < 0x40\n                            && (c >= 0xe1 || c2 >= 0xa0)\n                            && (c != 0xed || c2 < 0xa0))\n                          goto incomplete;\n                      }\n                  }\n                else if (c <= 0xf4)\n                  {\n                    if (m == 1)\n                      goto incomplete;\n                    else /* m == 2 || m == 3 */\n                      {\n                        unsigned char c2 = (unsigned char) p[1];\n\n                        if ((c2 ^ 0x80) < 0x40\n                            && (c >= 0xf1 || c2 >= 0x90)\n                            && (c < 0xf4 || (c == 0xf4 && c2 < 0x90)))\n                          {\n                            if (m == 2)\n                              goto incomplete;\n                            else /* m == 3 */\n                              {\n                                unsigned char c3 = (unsigned char) p[2];\n\n                                if ((c3 ^ 0x80) < 0x40)\n                                  goto incomplete;\n                              }\n                          }\n                      }\n                  }\n              }\n            goto invalid;\n          }\n\n        /* As a reference for this code, you can use the GNU libiconv\n           implementation.  Look for uses of the RET_TOOFEW macro.  */\n\n        if (STREQ_OPT (encoding,\n                       \"EUC-JP\", 'E', 'U', 'C', '-', 'J', 'P', 0, 0, 0))\n          {\n            if (m == 1)\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if ((c >= 0xa1 && c < 0xff) || c == 0x8e || c == 0x8f)\n                  goto incomplete;\n              }\n            if (m == 2)\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if (c == 0x8f)\n                  {\n                    unsigned char c2 = (unsigned char) p[1];\n\n                    if (c2 >= 0xa1 && c2 < 0xff)\n                      goto incomplete;\n                  }\n              }\n            goto invalid;\n          }\n        if (STREQ_OPT (encoding,\n                       \"EUC-KR\", 'E', 'U', 'C', '-', 'K', 'R', 0, 0, 0)\n            || STREQ_OPT (encoding,\n                          \"GB2312\", 'G', 'B', '2', '3', '1', '2', 0, 0, 0)\n            || STREQ_OPT (encoding,\n                          \"BIG5\", 'B', 'I', 'G', '5', 0, 0, 0, 0, 0))\n          {\n            if (m == 1)\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if (c >= 0xa1 && c < 0xff)\n                  goto incomplete;\n              }\n            goto invalid;\n          }\n        if (STREQ_OPT (encoding,\n                       \"EUC-TW\", 'E', 'U', 'C', '-', 'T', 'W', 0, 0, 0))\n          {\n            if (m == 1)\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if ((c >= 0xa1 && c < 0xff) || c == 0x8e)\n                  goto incomplete;\n              }\n            else /* m == 2 || m == 3 */\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if (c == 0x8e)\n                  goto incomplete;\n              }\n            goto invalid;\n          }\n        if (STREQ_OPT (encoding,\n                       \"GB18030\", 'G', 'B', '1', '8', '0', '3', '0', 0, 0))\n          {\n            if (m == 1)\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if ((c >= 0x90 && c <= 0xe3) || (c >= 0xf8 && c <= 0xfe))\n                  goto incomplete;\n              }\n            else /* m == 2 || m == 3 */\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if (c >= 0x90 && c <= 0xe3)\n                  {\n                    unsigned char c2 = (unsigned char) p[1];\n\n                    if (c2 >= 0x30 && c2 <= 0x39)\n                      {\n                        if (m == 2)\n                          goto incomplete;\n                        else /* m == 3 */\n                          {\n                            unsigned char c3 = (unsigned char) p[2];\n\n                            if (c3 >= 0x81 && c3 <= 0xfe)\n                              goto incomplete;\n                          }\n                      }\n                  }\n              }\n            goto invalid;\n          }\n        if (STREQ_OPT (encoding, \"SJIS\", 'S', 'J', 'I', 'S', 0, 0, 0, 0, 0))\n          {\n            if (m == 1)\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if ((c >= 0x81 && c <= 0x9f) || (c >= 0xe0 && c <= 0xea)\n                    || (c >= 0xf0 && c <= 0xf9))\n                  goto incomplete;\n              }\n            goto invalid;\n          }\n\n        /* An unknown multibyte encoding.  */\n        goto incomplete;\n      }\n\n     incomplete:\n      {\n        size_t k = nstate;\n        /* Here 0 <= k < m < 4.  */\n        pstate[++k] = s[0];\n        if (k < m)\n          {\n            pstate[++k] = s[1];\n            if (k < m)\n              pstate[++k] = s[2];\n          }\n        if (k != m)\n          abort ();\n      }\n      pstate[0] = m;\n      return (size_t)(-2);\n\n     invalid:\n      errno = EILSEQ;\n      /* The conversion state is undefined, says POSIX.  */\n      return (size_t)(-1);\n    }\n  }\n}",
      "lines": 284,
      "depth": 25,
      "decorators": [
        "size_t"
      ]
    },
    "rpl_mbrtowc": {
      "start_point": [
        339,
        0
      ],
      "end_point": [
        411,
        1
      ],
      "content": "size_t\nrpl_mbrtowc (wchar_t *pwc, const char *s, size_t n, mbstate_t *ps)\n{\n  size_t ret;\n  wchar_t wc;\n\n# if MBRTOWC_NULL_ARG2_BUG || MBRTOWC_RETVAL_BUG || MBRTOWC_EMPTY_INPUT_BUG\n  if (s == NULL)\n    {\n      pwc = NULL;\n      s = \"\";\n      n = 1;\n    }\n# endif\n\n# if MBRTOWC_EMPTY_INPUT_BUG\n  if (n == 0)\n    return (size_t) -2;\n# endif\n\n  if (! pwc)\n    pwc = &wc;\n\n# if MBRTOWC_RETVAL_BUG\n  {\n    static mbstate_t internal_state;\n\n    /* Override mbrtowc's internal state.  We cannot call mbsinit() on the\n       hidden internal state, but we can call it on our variable.  */\n    if (ps == NULL)\n      ps = &internal_state;\n\n    if (!mbsinit (ps))\n      {\n        /* Parse the rest of the multibyte character byte for byte.  */\n        size_t count = 0;\n        for (; n > 0; s++, n--)\n          {\n            ret = mbrtowc (&wc, s, 1, ps);\n\n            if (ret == (size_t)(-1))\n              return (size_t)(-1);\n            count++;\n            if (ret != (size_t)(-2))\n              {\n                /* The multibyte character has been completed.  */\n                *pwc = wc;\n                return (wc == 0 ? 0 : count);\n              }\n          }\n        return (size_t)(-2);\n      }\n  }\n# endif\n\n  ret = mbrtowc (pwc, s, n, ps);\n\n# if MBRTOWC_NUL_RETVAL_BUG\n  if (ret < (size_t) -2 && !*pwc)\n    return 0;\n# endif\n\n# if C_LOCALE_MAYBE_EILSEQ\n  if ((size_t) -2 <= ret && n != 0 && ! hard_locale (LC_CTYPE))\n    {\n      unsigned char uc = *s;\n      *pwc = uc;\n      return 1;\n    }\n# endif\n\n  return ret;\n}",
      "lines": 73,
      "depth": 15,
      "decorators": [
        "size_t"
      ]
    }
  },
  "sed/sed-4.5/lib/mbsinit.c": {
    "mbsinit": [
      {
        "start_point": [
          43,
          0
        ],
        "end_point": [
          49,
          1
        ],
        "content": "int\nmbsinit (const mbstate_t *ps)\n{\n  const char *pstate = (const char *)ps;\n\n  return pstate == NULL || pstate[0] == 0;\n}",
        "lines": 7,
        "depth": 8,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          53,
          0
        ],
        "end_point": [
          70,
          1
        ],
        "content": "int\nmbsinit (const mbstate_t *ps)\n{\n# if (defined _WIN32 || defined __WIN32__) && !defined __CYGWIN__\n  /* Native Windows.  */\n#  ifdef __MINGW32__\n  /* On mingw, 'mbstate_t' is defined as 'int'.  */\n  return ps == NULL || *ps == 0;\n#  else\n  /* MSVC defines 'mbstate_t' as an 8-byte struct; the first 4-bytes matter.  */\n  return ps == NULL || *(const unsigned int *)ps == 0;\n#  endif\n# else\n  /* Minix, HP-UX 11.00, Solaris 2.6, Interix, ...  */\n  /* Maybe this definition works, maybe not...  */\n  return ps == NULL || *(const char *)ps == 0;\n# endif\n}",
        "lines": 18,
        "depth": 13,
        "decorators": [
          "int"
        ]
      }
    ]
  },
  "sed/sed-4.5/lib/mbtowc-impl.h": {
    "mbtowc": {
      "start_point": [
        21,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "int\nmbtowc (wchar_t *pwc, const char *s, size_t n)\n{\n  if (s == NULL)\n    return 0;\n  else\n    {\n      mbstate_t state;\n      wchar_t wc;\n      size_t result;\n\n      memset (&state, 0, sizeof (mbstate_t));\n      result = mbrtowc (&wc, s, n, &state);\n      if (result == (size_t)-1 || result == (size_t)-2)\n        {\n          errno = EILSEQ;\n          return -1;\n        }\n      if (pwc != NULL)\n        *pwc = wc;\n      return (wc == 0 ? 0 : result);\n    }\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/lib/mbtowc.c": {},
  "sed/sed-4.5/lib/memchr.c": {
    "__memchr": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        168,
        1
      ],
      "content": "void *\n__memchr (void const *s, int c_in, size_t n)\n{\n  /* On 32-bit hardware, choosing longword to be a 32-bit unsigned\n     long instead of a 64-bit uintmax_t tends to give better\n     performance.  On 64-bit hardware, unsigned long is generally 64\n     bits already.  Change this typedef to experiment with\n     performance.  */\n  typedef unsigned long int longword;\n\n  const unsigned char *char_ptr;\n  const longword *longword_ptr;\n  longword repeated_one;\n  longword repeated_c;\n  unsigned reg_char c;\n\n  c = (unsigned char) c_in;\n\n  /* Handle the first few bytes by reading one byte at a time.\n     Do this until CHAR_PTR is aligned on a longword boundary.  */\n  for (char_ptr = (const unsigned char *) s;\n       n > 0 && (size_t) char_ptr % sizeof (longword) != 0;\n       --n, ++char_ptr)\n    if (*char_ptr == c)\n      return (void *) char_ptr;\n\n  longword_ptr = (const longword *) char_ptr;\n\n  /* All these elucidatory comments refer to 4-byte longwords,\n     but the theory applies equally well to any size longwords.  */\n\n  /* Compute auxiliary longword values:\n     repeated_one is a value which has a 1 in every byte.\n     repeated_c has c in every byte.  */\n  repeated_one = 0x01010101;\n  repeated_c = c | (c << 8);\n  repeated_c |= repeated_c << 16;\n  if (0xffffffffU < (longword) -1)\n    {\n      repeated_one |= repeated_one << 31 << 1;\n      repeated_c |= repeated_c << 31 << 1;\n      if (8 < sizeof (longword))\n        {\n          size_t i;\n\n          for (i = 64; i < sizeof (longword) * 8; i *= 2)\n            {\n              repeated_one |= repeated_one << i;\n              repeated_c |= repeated_c << i;\n            }\n        }\n    }\n\n  /* Instead of the traditional loop which tests each byte, we will test a\n     longword at a time.  The tricky part is testing if *any of the four*\n     bytes in the longword in question are equal to c.  We first use an xor\n     with repeated_c.  This reduces the task to testing whether *any of the\n     four* bytes in longword1 is zero.\n\n     We compute tmp =\n       ((longword1 - repeated_one) & ~longword1) & (repeated_one << 7).\n     That is, we perform the following operations:\n       1. Subtract repeated_one.\n       2. & ~longword1.\n       3. & a mask consisting of 0x80 in every byte.\n     Consider what happens in each byte:\n       - If a byte of longword1 is zero, step 1 and 2 transform it into 0xff,\n         and step 3 transforms it into 0x80.  A carry can also be propagated\n         to more significant bytes.\n       - If a byte of longword1 is nonzero, let its lowest 1 bit be at\n         position k (0 <= k <= 7); so the lowest k bits are 0.  After step 1,\n         the byte ends in a single bit of value 0 and k bits of value 1.\n         After step 2, the result is just k bits of value 1: 2^k - 1.  After\n         step 3, the result is 0.  And no carry is produced.\n     So, if longword1 has only non-zero bytes, tmp is zero.\n     Whereas if longword1 has a zero byte, call j the position of the least\n     significant zero byte.  Then the result has a zero at positions 0, ...,\n     j-1 and a 0x80 at position j.  We cannot predict the result at the more\n     significant bytes (positions j+1..3), but it does not matter since we\n     already have a non-zero bit at position 8*j+7.\n\n     So, the test whether any byte in longword1 is zero is equivalent to\n     testing whether tmp is nonzero.  */\n\n  while (n >= sizeof (longword))\n    {\n      longword longword1 = *longword_ptr ^ repeated_c;\n\n      if ((((longword1 - repeated_one) & ~longword1)\n           & (repeated_one << 7)) != 0)\n        break;\n      longword_ptr++;\n      n -= sizeof (longword);\n    }\n\n  char_ptr = (const unsigned char *) longword_ptr;\n\n  /* At this point, we know that either n < sizeof (longword), or one of the\n     sizeof (longword) bytes starting at char_ptr is == c.  On little-endian\n     machines, we could determine the first such byte without any further\n     memory accesses, just by looking at the tmp result from the last loop\n     iteration.  But this does not work on big-endian machines.  Choose code\n     that works in both cases.  */\n\n  for (; n > 0; --n, ++char_ptr)\n    {\n      if (*char_ptr == c)\n        return (void *) char_ptr;\n    }\n\n  return NULL;\n}",
      "lines": 112,
      "depth": 14,
      "decorators": [
        "void",
        "*\n__memchr (void const *s, int c_in, size_t n)",
        "*"
      ]
    }
  },
  "sed/sed-4.5/lib/memrchr.c": {
    "__memrchr": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        157,
        1
      ],
      "content": "void *\n__memrchr (void const *s, int c_in, size_t n)\n{\n  /* On 32-bit hardware, choosing longword to be a 32-bit unsigned\n     long instead of a 64-bit uintmax_t tends to give better\n     performance.  On 64-bit hardware, unsigned long is generally 64\n     bits already.  Change this typedef to experiment with\n     performance.  */\n  typedef unsigned long int longword;\n\n  const unsigned char *char_ptr;\n  const longword *longword_ptr;\n  longword repeated_one;\n  longword repeated_c;\n  unsigned reg_char c;\n\n  c = (unsigned char) c_in;\n\n  /* Handle the last few bytes by reading one byte at a time.\n     Do this until CHAR_PTR is aligned on a longword boundary.  */\n  for (char_ptr = (const unsigned char *) s + n;\n       n > 0 && (size_t) char_ptr % sizeof (longword) != 0;\n       --n)\n    if (*--char_ptr == c)\n      return (void *) char_ptr;\n\n  longword_ptr = (const longword *) char_ptr;\n\n  /* All these elucidatory comments refer to 4-byte longwords,\n     but the theory applies equally well to any size longwords.  */\n\n  /* Compute auxiliary longword values:\n     repeated_one is a value which has a 1 in every byte.\n     repeated_c has c in every byte.  */\n  repeated_one = 0x01010101;\n  repeated_c = c | (c << 8);\n  repeated_c |= repeated_c << 16;\n  if (0xffffffffU < (longword) -1)\n    {\n      repeated_one |= repeated_one << 31 << 1;\n      repeated_c |= repeated_c << 31 << 1;\n      if (8 < sizeof (longword))\n        {\n          size_t i;\n\n          for (i = 64; i < sizeof (longword) * 8; i *= 2)\n            {\n              repeated_one |= repeated_one << i;\n              repeated_c |= repeated_c << i;\n            }\n        }\n    }\n\n  /* Instead of the traditional loop which tests each byte, we will test a\n     longword at a time.  The tricky part is testing if *any of the four*\n     bytes in the longword in question are equal to c.  We first use an xor\n     with repeated_c.  This reduces the task to testing whether *any of the\n     four* bytes in longword1 is zero.\n\n     We compute tmp =\n       ((longword1 - repeated_one) & ~longword1) & (repeated_one << 7).\n     That is, we perform the following operations:\n       1. Subtract repeated_one.\n       2. & ~longword1.\n       3. & a mask consisting of 0x80 in every byte.\n     Consider what happens in each byte:\n       - If a byte of longword1 is zero, step 1 and 2 transform it into 0xff,\n         and step 3 transforms it into 0x80.  A carry can also be propagated\n         to more significant bytes.\n       - If a byte of longword1 is nonzero, let its lowest 1 bit be at\n         position k (0 <= k <= 7); so the lowest k bits are 0.  After step 1,\n         the byte ends in a single bit of value 0 and k bits of value 1.\n         After step 2, the result is just k bits of value 1: 2^k - 1.  After\n         step 3, the result is 0.  And no carry is produced.\n     So, if longword1 has only non-zero bytes, tmp is zero.\n     Whereas if longword1 has a zero byte, call j the position of the least\n     significant zero byte.  Then the result has a zero at positions 0, ...,\n     j-1 and a 0x80 at position j.  We cannot predict the result at the more\n     significant bytes (positions j+1..3), but it does not matter since we\n     already have a non-zero bit at position 8*j+7.\n\n     So, the test whether any byte in longword1 is zero is equivalent to\n     testing whether tmp is nonzero.  */\n\n  while (n >= sizeof (longword))\n    {\n      longword longword1 = *--longword_ptr ^ repeated_c;\n\n      if ((((longword1 - repeated_one) & ~longword1)\n           & (repeated_one << 7)) != 0)\n        {\n          longword_ptr++;\n          break;\n        }\n      n -= sizeof (longword);\n    }\n\n  char_ptr = (const unsigned char *) longword_ptr;\n\n  /* At this point, we know that either n < sizeof (longword), or one of the\n     sizeof (longword) bytes starting at char_ptr is == c.  On little-endian\n     machines, we could determine the first such byte without any further\n     memory accesses, just by looking at the tmp result from the last loop\n     iteration.  But this does not work on big-endian machines.  Choose code\n     that works in both cases.  */\n\n  while (n-- > 0)\n    {\n      if (*--char_ptr == c)\n        return (void *) char_ptr;\n    }\n\n  return NULL;\n}",
      "lines": 114,
      "depth": 14,
      "decorators": [
        "void",
        "*\n__memrchr (void const *s, int c_in, size_t n)",
        "*"
      ]
    }
  },
  "sed/sed-4.5/lib/minmax.h": {},
  "sed/sed-4.5/lib/mkostemp.c": {
    "mkostemp": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "int\nmkostemp (char *xtemplate, int flags)\n{\n  return __gen_tempname (xtemplate, 0, flags, __GT_FILE);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/lib/msvc-inval.c": {
    "gl_msvc_invalid_parameter_handler": [
      {
        "start_point": [
          30,
          0
        ],
        "end_point": [
          37,
          1
        ],
        "content": "static void __cdecl\ngl_msvc_invalid_parameter_handler (const wchar_t *expression,\n                                   const wchar_t *function,\n                                   const wchar_t *file,\n                                   unsigned int line,\n                                   uintptr_t dummy)\n{\n}",
        "lines": 8,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void",
          "__cdecl",
          "__cdecl"
        ]
      },
      {
        "start_point": [
          47,
          0
        ],
        "end_point": [
          55,
          1
        ],
        "content": "static void __cdecl\ngl_msvc_invalid_parameter_handler (const wchar_t *expression,\n                                   const wchar_t *function,\n                                   const wchar_t *file,\n                                   unsigned int line,\n                                   uintptr_t dummy)\n{\n  RaiseException (STATUS_GNULIB_INVALID_PARAMETER, 0, 0, NULL);\n}",
        "lines": 9,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void",
          "__cdecl",
          "__cdecl"
        ]
      },
      {
        "start_point": [
          96,
          0
        ],
        "end_point": [
          110,
          1
        ],
        "content": "static void __cdecl\ngl_msvc_invalid_parameter_handler (const wchar_t *expression,\n                                   const wchar_t *function,\n                                   const wchar_t *file,\n                                   unsigned int line,\n                                   uintptr_t dummy)\n{\n  struct gl_msvc_inval_per_thread *current = gl_msvc_inval_current ();\n  if (current->restart_valid)\n    longjmp (current->restart, 1);\n  else\n    /* An invalid parameter notification from outside the gnulib code.\n       Give the caller a chance to intervene.  */\n    RaiseException (STATUS_GNULIB_INVALID_PARAMETER, 0, 0, NULL);\n}",
        "lines": 15,
        "depth": 8,
        "decorators": [
          "static",
          "static",
          "void",
          "__cdecl",
          "__cdecl"
        ]
      }
    ],
    "gl_msvc_inval_current": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "struct gl_msvc_inval_per_thread *\ngl_msvc_inval_current (void)\n{\n  if (!tls_initialized)\n    {\n      tls_index = TlsAlloc ();\n      tls_initialized = 1;\n    }\n  if (tls_index == TLS_OUT_OF_INDEXES)\n    /* TlsAlloc had failed.  */\n    return &not_per_thread;\n  else\n    {\n      struct gl_msvc_inval_per_thread *pointer =\n        (struct gl_msvc_inval_per_thread *) TlsGetValue (tls_index);\n      if (pointer == NULL)\n        {\n          /* First call.  Allocate a new 'struct gl_msvc_inval_per_thread'.  */\n          pointer =\n            (struct gl_msvc_inval_per_thread *)\n            malloc (sizeof (struct gl_msvc_inval_per_thread));\n          if (pointer == NULL)\n            /* Could not allocate memory.  Use the global storage.  */\n            pointer = &not_per_thread;\n          TlsSetValue (tls_index, pointer);\n        }\n      return pointer;\n    }\n}",
      "lines": 29,
      "depth": 15,
      "decorators": [
        "struct gl_msvc_inval_per_thread",
        "struct",
        "gl_msvc_inval_per_thread",
        "*\ngl_msvc_inval_current (void)",
        "*"
      ]
    },
    "gl_msvc_inval_ensure_handler": {
      "start_point": [
        118,
        0
      ],
      "end_point": [
        126,
        1
      ],
      "content": "void\ngl_msvc_inval_ensure_handler (void)\n{\n  if (gl_msvc_inval_initialized == 0)\n    {\n      _set_invalid_parameter_handler (gl_msvc_invalid_parameter_handler);\n      gl_msvc_inval_initialized = 1;\n    }\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "sed/sed-4.5/lib/msvc-inval.h": {},
  "sed/sed-4.5/lib/msvc-nothrow.c": {
    "_gl_nothrow_get_osfhandle": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        41,
        5
      ],
      "content": "intptr_t\n_gl_nothrow_get_osfhandle (int fd)\n{\n  intptr_t result;\n\n  TRY_MSVC_INVAL\n    {\n      result = _get_osfhandle (fd);\n    }",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "intptr_t"
      ]
    }
  },
  "sed/sed-4.5/lib/msvc-nothrow.h": {},
  "sed/sed-4.5/lib/nl_langinfo.c": {
    "ctype_codeset": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        81,
        1
      ],
      "content": "static char *\nctype_codeset (void)\n{\n  static char buf[2 + 10 + 1];\n  char const *locale = setlocale (LC_CTYPE, NULL);\n  char *codeset = buf;\n  size_t codesetlen;\n  codeset[0] = '\\0';\n\n  if (locale && locale[0])\n    {\n      /* If the locale name contains an encoding after the dot, return it.  */\n      char *dot = strchr (locale, '.');\n\n      if (dot)\n        {\n          /* Look for the possible @... trailer and remove it, if any.  */\n          char *codeset_start = dot + 1;\n          char const *modifier = strchr (codeset_start, '@');\n\n          if (! modifier)\n            codeset = codeset_start;\n          else\n            {\n              codesetlen = modifier - codeset_start;\n              if (codesetlen < sizeof buf)\n                {\n                  codeset = memcpy (buf, codeset_start, codesetlen);\n                  codeset[codesetlen] = '\\0';\n                }\n            }\n        }\n    }\n\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n  /* If setlocale is successful, it returns the number of the\n     codepage, as a string.  Otherwise, fall back on Windows API\n     GetACP, which returns the locale's codepage as a number (although\n     this doesn't change according to what the 'setlocale' call specified).\n     Either way, prepend \"CP\" to make it a valid codeset name.  */\n  codesetlen = strlen (codeset);\n  if (0 < codesetlen && codesetlen < sizeof buf - 2)\n    memmove (buf + 2, codeset, codesetlen + 1);\n  else\n    sprintf (buf + 2, \"%u\", GetACP ());\n  codeset = memcpy (buf, \"CP\", 2);\n# endif\n  return codeset;\n}",
      "lines": 49,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nctype_codeset (void)",
        "*"
      ]
    },
    "rpl_nl_langinfo": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        158,
        1
      ],
      "content": "char *\nrpl_nl_langinfo (nl_item item)\n{\n  switch (item)\n    {\n# if GNULIB_defined_CODESET\n    case CODESET:\n      return ctype_codeset ();\n# endif\n# if GNULIB_defined_T_FMT_AMPM\n    case T_FMT_AMPM:\n      return (char *) \"%I:%M:%S %p\";\n# endif\n# if GNULIB_defined_ALTMON\n    case ALTMON_1:\n    case ALTMON_2:\n    case ALTMON_3:\n    case ALTMON_4:\n    case ALTMON_5:\n    case ALTMON_6:\n    case ALTMON_7:\n    case ALTMON_8:\n    case ALTMON_9:\n    case ALTMON_10:\n    case ALTMON_11:\n    case ALTMON_12:\n      /* We don't ship the appropriate localizations with gnulib.  Therefore,\n         treat ALTMON_i like MON_i.  */\n      item = item - ALTMON_1 + MON_1;\n      break;\n# endif\n# if GNULIB_defined_ERA\n    case ERA:\n      /* The format is not standardized.  In glibc it is a sequence of strings\n         of the form \"direction:offset:start_date:end_date:era_name:era_format\"\n         with an empty string at the end.  */\n      return (char *) \"\";\n    case ERA_D_FMT:\n      /* The %Ex conversion in strftime behaves like %x if the locale does not\n         have an alternative time format.  */\n      item = D_FMT;\n      break;\n    case ERA_D_T_FMT:\n      /* The %Ec conversion in strftime behaves like %c if the locale does not\n         have an alternative time format.  */\n      item = D_T_FMT;\n      break;\n    case ERA_T_FMT:\n      /* The %EX conversion in strftime behaves like %X if the locale does not\n         have an alternative time format.  */\n      item = T_FMT;\n      break;\n    case ALT_DIGITS:\n      /* The format is not standardized.  In glibc it is a sequence of 10\n         strings, appended in memory.  */\n      return (char *) \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\";\n# endif\n# if GNULIB_defined_YESEXPR || !FUNC_NL_LANGINFO_YESEXPR_WORKS\n    case YESEXPR:\n      return (char *) \"^[yY]\";\n    case NOEXPR:\n      return (char *) \"^[nN]\";\n# endif\n    default:\n      break;\n    }\n  return nl_langinfo (item);\n}",
      "lines": 68,
      "depth": 11,
      "decorators": [
        "char",
        "*\nrpl_nl_langinfo (nl_item item)",
        "*"
      ]
    },
    "nl_langinfo": {
      "start_point": [
        168,
        0
      ],
      "end_point": [
        359,
        1
      ],
      "content": "char *\nnl_langinfo (nl_item item)\n{\n  static char nlbuf[100];\n  struct tm tmm = { 0 };\n\n  switch (item)\n    {\n    /* nl_langinfo items of the LC_CTYPE category */\n    case CODESET:\n      {\n        char *codeset = ctype_codeset ();\n        if (*codeset)\n          return codeset;\n      }\n# ifdef __BEOS__\n      return (char *) \"UTF-8\";\n# else\n      return (char *) \"ISO-8859-1\";\n# endif\n    /* nl_langinfo items of the LC_NUMERIC category */\n    case RADIXCHAR:\n      return localeconv () ->decimal_point;\n    case THOUSEP:\n      return localeconv () ->thousands_sep;\n    case GROUPING:\n      return localeconv () ->grouping;\n    /* nl_langinfo items of the LC_TIME category.\n       TODO: Really use the locale.  */\n    case D_T_FMT:\n    case ERA_D_T_FMT:\n      return (char *) \"%a %b %e %H:%M:%S %Y\";\n    case D_FMT:\n    case ERA_D_FMT:\n      return (char *) \"%m/%d/%y\";\n    case T_FMT:\n    case ERA_T_FMT:\n      return (char *) \"%H:%M:%S\";\n    case T_FMT_AMPM:\n      return (char *) \"%I:%M:%S %p\";\n    case AM_STR:\n      if (!strftime (nlbuf, sizeof nlbuf, \"%p\", &tmm))\n        return (char *) \"AM\";\n      return nlbuf;\n    case PM_STR:\n      tmm.tm_hour = 12;\n      if (!strftime (nlbuf, sizeof nlbuf, \"%p\", &tmm))\n        return (char *) \"PM\";\n      return nlbuf;\n    case DAY_1:\n    case DAY_2:\n    case DAY_3:\n    case DAY_4:\n    case DAY_5:\n    case DAY_6:\n    case DAY_7:\n      {\n        static char const days[][sizeof \"Wednesday\"] = {\n          \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\",\n          \"Friday\", \"Saturday\"\n        };\n        tmm.tm_wday = item - DAY_1;\n        if (!strftime (nlbuf, sizeof nlbuf, \"%A\", &tmm))\n          return (char *) days[item - DAY_1];\n        return nlbuf;\n      }\n    case ABDAY_1:\n    case ABDAY_2:\n    case ABDAY_3:\n    case ABDAY_4:\n    case ABDAY_5:\n    case ABDAY_6:\n    case ABDAY_7:\n      {\n        static char const abdays[][sizeof \"Sun\"] = {\n          \"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"\n        };\n        tmm.tm_wday = item - ABDAY_1;\n        if (!strftime (nlbuf, sizeof nlbuf, \"%a\", &tmm))\n          return (char *) abdays[item - ABDAY_1];\n        return nlbuf;\n      }\n    {\n      static char const months[][sizeof \"September\"] = {\n        \"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\",\n        \"September\", \"October\", \"November\", \"December\"\n      };\n      case MON_1:\n      case MON_2:\n      case MON_3:\n      case MON_4:\n      case MON_5:\n      case MON_6:\n      case MON_7:\n      case MON_8:\n      case MON_9:\n      case MON_10:\n      case MON_11:\n      case MON_12:\n        tmm.tm_mon = item - MON_1;\n        if (!strftime (nlbuf, sizeof nlbuf, \"%B\", &tmm))\n          return (char *) months[item - MON_1];\n        return nlbuf;\n      case ALTMON_1:\n      case ALTMON_2:\n      case ALTMON_3:\n      case ALTMON_4:\n      case ALTMON_5:\n      case ALTMON_6:\n      case ALTMON_7:\n      case ALTMON_8:\n      case ALTMON_9:\n      case ALTMON_10:\n      case ALTMON_11:\n      case ALTMON_12:\n        tmm.tm_mon = item - ALTMON_1;\n        /* The platforms without nl_langinfo() don't support strftime with %OB.\n           We don't even need to try.  */\n        #if 0\n        if (!strftime (nlbuf, sizeof nlbuf, \"%OB\", &tmm))\n        #endif\n          if (!strftime (nlbuf, sizeof nlbuf, \"%B\", &tmm))\n            return (char *) months[item - ALTMON_1];\n        return nlbuf;\n    }\n    case ABMON_1:\n    case ABMON_2:\n    case ABMON_3:\n    case ABMON_4:\n    case ABMON_5:\n    case ABMON_6:\n    case ABMON_7:\n    case ABMON_8:\n    case ABMON_9:\n    case ABMON_10:\n    case ABMON_11:\n    case ABMON_12:\n      {\n        static char const abmonths[][sizeof \"Jan\"] = {\n          \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\",\n          \"Sep\", \"Oct\", \"Nov\", \"Dec\"\n        };\n        tmm.tm_mon = item - ABMON_1;\n        if (!strftime (nlbuf, sizeof nlbuf, \"%b\", &tmm))\n          return (char *) abmonths[item - ABMON_1];\n        return nlbuf;\n      }\n    case ERA:\n      return (char *) \"\";\n    case ALT_DIGITS:\n      return (char *) \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\";\n    /* nl_langinfo items of the LC_MONETARY category.  */\n    case CRNCYSTR:\n      return localeconv () ->currency_symbol;\n    case INT_CURR_SYMBOL:\n      return localeconv () ->int_curr_symbol;\n    case MON_DECIMAL_POINT:\n      return localeconv () ->mon_decimal_point;\n    case MON_THOUSANDS_SEP:\n      return localeconv () ->mon_thousands_sep;\n    case MON_GROUPING:\n      return localeconv () ->mon_grouping;\n    case POSITIVE_SIGN:\n      return localeconv () ->positive_sign;\n    case NEGATIVE_SIGN:\n      return localeconv () ->negative_sign;\n    case FRAC_DIGITS:\n      return & localeconv () ->frac_digits;\n    case INT_FRAC_DIGITS:\n      return & localeconv () ->int_frac_digits;\n    case P_CS_PRECEDES:\n      return & localeconv () ->p_cs_precedes;\n    case N_CS_PRECEDES:\n      return & localeconv () ->n_cs_precedes;\n    case P_SEP_BY_SPACE:\n      return & localeconv () ->p_sep_by_space;\n    case N_SEP_BY_SPACE:\n      return & localeconv () ->n_sep_by_space;\n    case P_SIGN_POSN:\n      return & localeconv () ->p_sign_posn;\n    case N_SIGN_POSN:\n      return & localeconv () ->n_sign_posn;\n    /* nl_langinfo items of the LC_MESSAGES category\n       TODO: Really use the locale. */\n    case YESEXPR:\n      return (char *) \"^[yY]\";\n    case NOEXPR:\n      return (char *) \"^[nN]\";\n    default:\n      return (char *) \"\";\n    }\n}",
      "lines": 192,
      "depth": 14,
      "decorators": [
        "char",
        "*\nnl_langinfo (nl_item item)",
        "*"
      ]
    }
  },
  "sed/sed-4.5/lib/obstack.c": {
    "call_chunkfun": {
      "start_point": [
        82,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "static void *\ncall_chunkfun (struct obstack *h, size_t size)\n{\n  if (h->use_extra_arg)\n    return h->chunkfun.extra (h->extra_arg, size);\n  else\n    return h->chunkfun.plain (size);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void",
        "*\ncall_chunkfun (struct obstack *h, size_t size)",
        "*"
      ]
    },
    "call_freefun": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        98,
        1
      ],
      "content": "static void\ncall_freefun (struct obstack *h, void *old_chunk)\n{\n  if (h->use_extra_arg)\n    h->freefun.extra (h->extra_arg, old_chunk);\n  else\n    h->freefun.plain (old_chunk);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "_obstack_begin_worker": {
      "start_point": [
        107,
        0
      ],
      "end_point": [
        146,
        1
      ],
      "content": "static int\n_obstack_begin_worker (struct obstack *h,\n                       _OBSTACK_SIZE_T size, _OBSTACK_SIZE_T alignment)\n{\n  struct _obstack_chunk *chunk; /* points to new chunk */\n\n  if (alignment == 0)\n    alignment = DEFAULT_ALIGNMENT;\n  if (size == 0)\n    /* Default size is what GNU malloc can fit in a 4096-byte block.  */\n    {\n      /* 12 is sizeof (mhead) and 4 is EXTRA from GNU malloc.\n         Use the values for range checking, because if range checking is off,\n         the extra bytes won't be missed terribly, but if range checking is on\n         and we used a larger request, a whole extra 4096 bytes would be\n         allocated.\n\n         These number are irrelevant to the new GNU malloc.  I suspect it is\n         less sensitive to the size of the request.  */\n      int extra = ((((12 + DEFAULT_ROUNDING - 1) & ~(DEFAULT_ROUNDING - 1))\n                    + 4 + DEFAULT_ROUNDING - 1)\n                   & ~(DEFAULT_ROUNDING - 1));\n      size = 4096 - extra;\n    }\n\n  h->chunk_size = size;\n  h->alignment_mask = alignment - 1;\n\n  chunk = h->chunk = call_chunkfun (h, h->chunk_size);\n  if (!chunk)\n    (*obstack_alloc_failed_handler) ();\n  h->next_free = h->object_base = __PTR_ALIGN ((char *) chunk, chunk->contents,\n                                               alignment - 1);\n  h->chunk_limit = chunk->limit = (char *) chunk + h->chunk_size;\n  chunk->prev = 0;\n  /* The initial chunk now contains no empty object.  */\n  h->maybe_empty_object = 0;\n  h->alloc_failed = 0;\n  return 1;\n}",
      "lines": 40,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "_obstack_begin": {
      "start_point": [
        148,
        0
      ],
      "end_point": [
        158,
        1
      ],
      "content": "int\n_obstack_begin (struct obstack *h,\n                _OBSTACK_SIZE_T size, _OBSTACK_SIZE_T alignment,\n                void *(*chunkfun) (size_t),\n                void (*freefun) (void *))\n{\n  h->chunkfun.plain = chunkfun;\n  h->freefun.plain = freefun;\n  h->use_extra_arg = 0;\n  return _obstack_begin_worker (h, size, alignment);\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "_obstack_begin_1": {
      "start_point": [
        160,
        0
      ],
      "end_point": [
        172,
        1
      ],
      "content": "int\n_obstack_begin_1 (struct obstack *h,\n                  _OBSTACK_SIZE_T size, _OBSTACK_SIZE_T alignment,\n                  void *(*chunkfun) (void *, size_t),\n                  void (*freefun) (void *, void *),\n                  void *arg)\n{\n  h->chunkfun.extra = chunkfun;\n  h->freefun.extra = freefun;\n  h->extra_arg = arg;\n  h->use_extra_arg = 1;\n  return _obstack_begin_worker (h, size, alignment);\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "_obstack_newchunk": {
      "start_point": [
        180,
        0
      ],
      "end_point": [
        229,
        1
      ],
      "content": "void\n_obstack_newchunk (struct obstack *h, _OBSTACK_SIZE_T length)\n{\n  struct _obstack_chunk *old_chunk = h->chunk;\n  struct _obstack_chunk *new_chunk = 0;\n  size_t obj_size = h->next_free - h->object_base;\n  char *object_base;\n\n  /* Compute size for new chunk.  */\n  size_t sum1 = obj_size + length;\n  size_t sum2 = sum1 + h->alignment_mask;\n  size_t new_size = sum2 + (obj_size >> 3) + 100;\n  if (new_size < sum2)\n    new_size = sum2;\n  if (new_size < h->chunk_size)\n    new_size = h->chunk_size;\n\n  /* Allocate and initialize the new chunk.  */\n  if (obj_size <= sum1 && sum1 <= sum2)\n    new_chunk = call_chunkfun (h, new_size);\n  if (!new_chunk)\n    (*obstack_alloc_failed_handler)();\n  h->chunk = new_chunk;\n  new_chunk->prev = old_chunk;\n  new_chunk->limit = h->chunk_limit = (char *) new_chunk + new_size;\n\n  /* Compute an aligned object_base in the new chunk */\n  object_base =\n    __PTR_ALIGN ((char *) new_chunk, new_chunk->contents, h->alignment_mask);\n\n  /* Move the existing object to the new chunk.  */\n  memcpy (object_base, h->object_base, obj_size);\n\n  /* If the object just copied was the only data in OLD_CHUNK,\n     free that chunk and remove it from the chain.\n     But not if that chunk might contain an empty object.  */\n  if (!h->maybe_empty_object\n      && (h->object_base\n          == __PTR_ALIGN ((char *) old_chunk, old_chunk->contents,\n                          h->alignment_mask)))\n    {\n      new_chunk->prev = old_chunk->prev;\n      call_freefun (h, old_chunk);\n    }\n\n  h->object_base = object_base;\n  h->next_free = h->object_base + obj_size;\n  /* The new chunk certainly contains no empty object yet.  */\n  h->maybe_empty_object = 0;\n}",
      "lines": 50,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "_obstack_allocated_p": {
      "start_point": [
        239,
        0
      ],
      "end_point": [
        255,
        1
      ],
      "content": "int\n_obstack_allocated_p (struct obstack *h, void *obj)\n{\n  struct _obstack_chunk *lp;    /* below addr of any objects in this chunk */\n  struct _obstack_chunk *plp;   /* point to previous chunk if any */\n\n  lp = (h)->chunk;\n  /* We use >= rather than > since the object cannot be exactly at\n     the beginning of the chunk but might be an empty object exactly\n     at the end of an adjacent chunk.  */\n  while (lp != 0 && ((void *) lp >= obj || (void *) (lp)->limit < obj))\n    {\n      plp = lp->prev;\n      lp = plp;\n    }\n  return lp != 0;\n}",
      "lines": 17,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "_obstack_free": {
      "start_point": [
        260,
        0
      ],
      "end_point": [
        288,
        1
      ],
      "content": "void\n_obstack_free (struct obstack *h, void *obj)\n{\n  struct _obstack_chunk *lp;    /* below addr of any objects in this chunk */\n  struct _obstack_chunk *plp;   /* point to previous chunk if any */\n\n  lp = h->chunk;\n  /* We use >= because there cannot be an object at the beginning of a chunk.\n     But there can be an empty object at that address\n     at the end of another chunk.  */\n  while (lp != 0 && ((void *) lp >= obj || (void *) (lp)->limit < obj))\n    {\n      plp = lp->prev;\n      call_freefun (h, lp);\n      lp = plp;\n      /* If we switch chunks, we can't tell whether the new current\n         chunk contains an empty object, so assume that it may.  */\n      h->maybe_empty_object = 1;\n    }\n  if (lp)\n    {\n      h->object_base = h->next_free = (char *) (obj);\n      h->chunk_limit = lp->limit;\n      h->chunk = lp;\n    }\n  else if (obj != 0)\n    /* obj is not in any of the chunks! */\n    abort ();\n}",
      "lines": 29,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "_obstack_memory_used": {
      "start_point": [
        290,
        0
      ],
      "end_point": [
        301,
        1
      ],
      "content": "_OBSTACK_SIZE_T\n_obstack_memory_used (struct obstack *h)\n{\n  struct _obstack_chunk *lp;\n  _OBSTACK_SIZE_T nbytes = 0;\n\n  for (lp = h->chunk; lp != 0; lp = lp->prev)\n    {\n      nbytes += lp->limit - (char *) lp;\n    }\n  return nbytes;\n}",
      "lines": 12,
      "depth": 11,
      "decorators": [
        "_OBSTACK_SIZE_T"
      ]
    },
    "print_and_abort": {
      "start_point": [
        328,
        0
      ],
      "end_point": [
        342,
        1
      ],
      "content": "static _Noreturn void\nprint_and_abort (void)\n{\n  /* Don't change any of these strings.  Yes, it would be possible to add\n     the newline to the string and use fputs or so.  But this must not\n     happen because the \"memory exhausted\" message appears in other places\n     like this and the translation should be reused instead of creating\n     a very similar string which requires a separate translation.  */\n#  ifdef _LIBC\n  (void) __fxprintf (NULL, \"%s\\n\", _(\"memory exhausted\"));\n#  else\n  fprintf (stderr, \"%s\\n\", _(\"memory exhausted\"));\n#  endif\n  exit (obstack_exit_failure);\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "_Noreturn",
        "void",
        "void"
      ]
    }
  },
  "sed/sed-4.5/lib/obstack.h": {},
  "sed/sed-4.5/lib/pathmax.h": {},
  "sed/sed-4.5/lib/progname.c": {
    "set_program_name": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        91,
        1
      ],
      "content": "void\nset_program_name (const char *argv0)\n{\n  /* libtool creates a temporary executable whose name is sometimes prefixed\n     with \"lt-\" (depends on the platform).  It also makes argv[0] absolute.\n     But the name of the temporary executable is a detail that should not be\n     visible to the end user and to the test suite.\n     Remove this \"<dirname>/.libs/\" or \"<dirname>/.libs/lt-\" prefix here.  */\n  const char *slash;\n  const char *base;\n\n  /* Sanity check.  POSIX requires the invoking process to pass a non-NULL\n     argv[0].  */\n  if (argv0 == NULL)\n    {\n      /* It's a bug in the invoking program.  Help diagnosing it.  */\n      fputs (\"A NULL argv[0] was passed through an exec system call.\\n\",\n             stderr);\n      abort ();\n    }\n\n  slash = strrchr (argv0, '/');\n  base = (slash != NULL ? slash + 1 : argv0);\n  if (base - argv0 >= 7 && strncmp (base - 7, \"/.libs/\", 7) == 0)\n    {\n      argv0 = base;\n      if (strncmp (base, \"lt-\", 3) == 0)\n        {\n          argv0 = base + 3;\n          /* On glibc systems, remove the \"lt-\" prefix from the variable\n             program_invocation_short_name.  */\n#if HAVE_DECL_PROGRAM_INVOCATION_SHORT_NAME\n          program_invocation_short_name = (char *) argv0;\n#endif\n        }\n    }\n\n  /* But don't strip off a leading <dirname>/ in general, because when the user\n     runs\n         /some/hidden/place/bin/cp foo foo\n     he should get the error message\n         /some/hidden/place/bin/cp: `foo' and `foo' are the same file\n     not\n         cp: `foo' and `foo' are the same file\n   */\n\n  program_name = argv0;\n\n  /* On glibc systems, the error() function comes from libc and uses the\n     variable program_invocation_name, not program_name.  So set this variable\n     as well.  */\n#if HAVE_DECL_PROGRAM_INVOCATION_NAME\n  program_invocation_name = (char *) argv0;\n#endif\n}",
      "lines": 55,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "sed/sed-4.5/lib/progname.h": {},
  "sed/sed-4.5/lib/qcopy-acl.c": {
    "qcopy_acl": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "int\nqcopy_acl (const char *src_name, int source_desc, const char *dst_name,\n           int dest_desc, mode_t mode)\n{\n  struct permission_context ctx;\n  int ret;\n\n  ret = get_permissions (src_name, source_desc, mode, &ctx);\n  if (ret != 0)\n    return -2;\n  ret = set_permissions (&ctx, dst_name, dest_desc);\n  free_permission_context (&ctx);\n  return ret;\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/lib/qset-acl.c": {
    "qset_acl": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "int\nqset_acl (char const *name, int desc, mode_t mode)\n{\n  struct permission_context ctx;\n  int ret;\n\n  memset (&ctx, 0, sizeof ctx);\n  ctx.mode = mode;\n  ret = set_permissions (&ctx, name, desc);\n  free_permission_context (&ctx);\n  return ret;\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/lib/quote.h": {},
  "sed/sed-4.5/lib/quotearg.c": {
    "clone_quoting_options": {
      "start_point": [
        120,
        0
      ],
      "end_point": [
        128,
        1
      ],
      "content": "struct quoting_options *\nclone_quoting_options (struct quoting_options *o)\n{\n  int e = errno;\n  struct quoting_options *p = xmemdup (o ? o : &default_quoting_options,\n                                       sizeof *o);\n  errno = e;\n  return p;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "struct quoting_options",
        "struct",
        "quoting_options",
        "*\nclone_quoting_options (struct quoting_options *o)",
        "*"
      ]
    },
    "get_quoting_style": {
      "start_point": [
        131,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "enum quoting_style\nget_quoting_style (struct quoting_options const *o)\n{\n  return (o ? o : &default_quoting_options)->style;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "enum quoting_style",
        "enum",
        "quoting_style"
      ]
    },
    "set_quoting_style": {
      "start_point": [
        139,
        0
      ],
      "end_point": [
        143,
        1
      ],
      "content": "void\nset_quoting_style (struct quoting_options *o, enum quoting_style s)\n{\n  (o ? o : &default_quoting_options)->style = s;\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "set_char_quoting": {
      "start_point": [
        150,
        0
      ],
      "end_point": [
        160,
        1
      ],
      "content": "int\nset_char_quoting (struct quoting_options *o, char c, int i)\n{\n  unsigned char uc = c;\n  unsigned int *p =\n    (o ? o : &default_quoting_options)->quote_these_too + uc / INT_BITS;\n  int shift = uc % INT_BITS;\n  int r = (*p >> shift) & 1;\n  *p ^= ((i & 1) ^ r) << shift;\n  return r;\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "set_quoting_flags": {
      "start_point": [
        166,
        0
      ],
      "end_point": [
        175,
        1
      ],
      "content": "int\nset_quoting_flags (struct quoting_options *o, int i)\n{\n  int r;\n  if (!o)\n    o = &default_quoting_options;\n  r = o->flags;\n  o->flags = i;\n  return r;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "set_custom_quoting": {
      "start_point": [
        177,
        0
      ],
      "end_point": [
        188,
        1
      ],
      "content": "void\nset_custom_quoting (struct quoting_options *o,\n                    char const *left_quote, char const *right_quote)\n{\n  if (!o)\n    o = &default_quoting_options;\n  o->style = custom_quoting_style;\n  if (!left_quote || !right_quote)\n    abort ();\n  o->left_quote = left_quote;\n  o->right_quote = right_quote;\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "quoting_options_from_style": {
      "start_point": [
        191,
        0
      ],
      "end_point": [
        199,
        1
      ],
      "content": "static struct quoting_options /* NOT PURE!! */\nquoting_options_from_style (enum quoting_style style)\n{\n  struct quoting_options o = { literal_quoting_style, 0, { 0 }, NULL, NULL };\n  if (style == custom_quoting_style)\n    abort ();\n  o.style = style;\n  return o;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "struct quoting_options",
        "struct",
        "quoting_options",
        "/* NOT PURE!! */"
      ]
    },
    "gettext_quote": {
      "start_point": [
        205,
        0
      ],
      "end_point": [
        239,
        1
      ],
      "content": "static char const *\ngettext_quote (char const *msgid, enum quoting_style s)\n{\n  char const *translation = _(msgid);\n  char const *locale_code;\n\n  if (translation != msgid)\n    return translation;\n\n  /* For UTF-8 and GB-18030, use single quotes U+2018 and U+2019.\n     Here is a list of other locales that include U+2018 and U+2019:\n\n        ISO-8859-7   0xA1                 KOI8-T       0x91\n        CP869        0x8B                 CP874        0x91\n        CP932        0x81 0x65            CP936        0xA1 0xAE\n        CP949        0xA1 0xAE            CP950        0xA1 0xA5\n        CP1250       0x91                 CP1251       0x91\n        CP1252       0x91                 CP1253       0x91\n        CP1254       0x91                 CP1255       0x91\n        CP1256       0x91                 CP1257       0x91\n        EUC-JP       0xA1 0xC6            EUC-KR       0xA1 0xAE\n        EUC-TW       0xA1 0xE4            BIG5         0xA1 0xA5\n        BIG5-HKSCS   0xA1 0xA5            EUC-CN       0xA1 0xAE\n        GBK          0xA1 0xAE            Georgian-PS  0x91\n        PT154        0x91\n\n     None of these is still in wide use; using iconv is overkill.  */\n  locale_code = locale_charset ();\n  if (STRCASEEQ (locale_code, \"UTF-8\", 'U','T','F','-','8',0,0,0,0))\n    return msgid[0] == '`' ? \"\\xe2\\x80\\x98\": \"\\xe2\\x80\\x99\";\n  if (STRCASEEQ (locale_code, \"GB18030\", 'G','B','1','8','0','3','0',0,0))\n    return msgid[0] == '`' ? \"\\xa1\\ae\": \"\\xa1\\xaf\";\n\n  return (s == clocale_quoting_style ? \"\\\"\" : \"'\");\n}",
      "lines": 35,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "char",
        "const",
        "const",
        "*\ngettext_quote (char const *msgid, enum quoting_style s)",
        "*"
      ]
    },
    "quotearg_buffer_restyled": {
      "start_point": [
        254,
        0
      ],
      "end_point": [
        771,
        1
      ],
      "content": "static size_t\nquotearg_buffer_restyled (char *buffer, size_t buffersize,\n                          char const *arg, size_t argsize,\n                          enum quoting_style quoting_style, int flags,\n                          unsigned int const *quote_these_too,\n                          char const *left_quote,\n                          char const *right_quote)\n{\n  size_t i;\n  size_t len = 0;\n  size_t orig_buffersize = 0;\n  char const *quote_string = 0;\n  size_t quote_string_len = 0;\n  bool backslash_escapes = false;\n  bool unibyte_locale = MB_CUR_MAX == 1;\n  bool elide_outer_quotes = (flags & QA_ELIDE_OUTER_QUOTES) != 0;\n  bool pending_shell_escape_end = false;\n  bool encountered_single_quote = false;\n  bool all_c_and_shell_quote_compat = true;\n\n#define STORE(c) \\\n    do \\\n      { \\\n        if (len < buffersize) \\\n          buffer[len] = (c); \\\n        len++; \\\n      } \\\n    while (0)\n\n#define START_ESC() \\\n    do \\\n      { \\\n        if (elide_outer_quotes) \\\n          goto force_outer_quoting_style; \\\n        escaping = true; \\\n        if (quoting_style == shell_always_quoting_style \\\n            && ! pending_shell_escape_end) \\\n          { \\\n            STORE ('\\''); \\\n            STORE ('$'); \\\n            STORE ('\\''); \\\n            pending_shell_escape_end = true; \\\n          } \\\n        STORE ('\\\\'); \\\n      } \\\n    while (0)\n\n#define END_ESC() \\\n    do \\\n      { \\\n        if (pending_shell_escape_end && ! escaping) \\\n          { \\\n            STORE ('\\''); \\\n            STORE ('\\''); \\\n            pending_shell_escape_end = false; \\\n          } \\\n      } \\\n    while (0)\n\n process_input:\n\n  switch (quoting_style)\n    {\n    case c_maybe_quoting_style:\n      quoting_style = c_quoting_style;\n      elide_outer_quotes = true;\n      FALLTHROUGH;\n    case c_quoting_style:\n      if (!elide_outer_quotes)\n        STORE ('\"');\n      backslash_escapes = true;\n      quote_string = \"\\\"\";\n      quote_string_len = 1;\n      break;\n\n    case escape_quoting_style:\n      backslash_escapes = true;\n      elide_outer_quotes = false;\n      break;\n\n    case locale_quoting_style:\n    case clocale_quoting_style:\n    case custom_quoting_style:\n      {\n        if (quoting_style != custom_quoting_style)\n          {\n            /* TRANSLATORS:\n               Get translations for open and closing quotation marks.\n               The message catalog should translate \"`\" to a left\n               quotation mark suitable for the locale, and similarly for\n               \"'\".  For example, a French Unicode local should translate\n               these to U+00AB (LEFT-POINTING DOUBLE ANGLE\n               QUOTATION MARK), and U+00BB (RIGHT-POINTING DOUBLE ANGLE\n               QUOTATION MARK), respectively.\n\n               If the catalog has no translation, we will try to\n               use Unicode U+2018 (LEFT SINGLE QUOTATION MARK) and\n               Unicode U+2019 (RIGHT SINGLE QUOTATION MARK).  If the\n               current locale is not Unicode, locale_quoting_style\n               will quote 'like this', and clocale_quoting_style will\n               quote \"like this\".  You should always include translations\n               for \"`\" and \"'\" even if U+2018 and U+2019 are appropriate\n               for your locale.\n\n               If you don't know what to put here, please see\n               <https://en.wikipedia.org/wiki/Quotation_marks_in_other_languages>\n               and use glyphs suitable for your language.  */\n            left_quote = gettext_quote (N_(\"`\"), quoting_style);\n            right_quote = gettext_quote (N_(\"'\"), quoting_style);\n          }\n        if (!elide_outer_quotes)\n          for (quote_string = left_quote; *quote_string; quote_string++)\n            STORE (*quote_string);\n        backslash_escapes = true;\n        quote_string = right_quote;\n        quote_string_len = strlen (quote_string);\n      }\n      break;\n\n    case shell_escape_quoting_style:\n      backslash_escapes = true;\n      FALLTHROUGH;\n    case shell_quoting_style:\n      elide_outer_quotes = true;\n      FALLTHROUGH;\n    case shell_escape_always_quoting_style:\n      if (!elide_outer_quotes)\n        backslash_escapes = true;\n      FALLTHROUGH;\n    case shell_always_quoting_style:\n      quoting_style = shell_always_quoting_style;\n      if (!elide_outer_quotes)\n        STORE ('\\'');\n      quote_string = \"'\";\n      quote_string_len = 1;\n      break;\n\n    case literal_quoting_style:\n      elide_outer_quotes = false;\n      break;\n\n    default:\n      abort ();\n    }\n\n  for (i = 0;  ! (argsize == SIZE_MAX ? arg[i] == '\\0' : i == argsize);  i++)\n    {\n      unsigned char c;\n      unsigned char esc;\n      bool is_right_quote = false;\n      bool escaping = false;\n      bool c_and_shell_quote_compat = false;\n\n      if (backslash_escapes\n          && quoting_style != shell_always_quoting_style\n          && quote_string_len\n          && (i + quote_string_len\n              <= (argsize == SIZE_MAX && 1 < quote_string_len\n                  /* Use strlen only if we must: when argsize is SIZE_MAX,\n                     and when the quote string is more than 1 byte long.\n                     If we do call strlen, save the result.  */\n                  ? (argsize = strlen (arg)) : argsize))\n          && memcmp (arg + i, quote_string, quote_string_len) == 0)\n        {\n          if (elide_outer_quotes)\n            goto force_outer_quoting_style;\n          is_right_quote = true;\n        }\n\n      c = arg[i];\n      switch (c)\n        {\n        case '\\0':\n          if (backslash_escapes)\n            {\n              START_ESC ();\n              /* If quote_string were to begin with digits, we'd need to\n                 test for the end of the arg as well.  However, it's\n                 hard to imagine any locale that would use digits in\n                 quotes, and set_custom_quoting is documented not to\n                 accept them.  Use only a single \\0 with shell-escape\n                 as currently digits are not printed within $'...'  */\n              if (quoting_style != shell_always_quoting_style\n                  && i + 1 < argsize && '0' <= arg[i + 1] && arg[i + 1] <= '9')\n                {\n                  STORE ('0');\n                  STORE ('0');\n                }\n              c = '0';\n              /* We don't have to worry that this last '0' will be\n                 backslash-escaped because, again, quote_string should\n                 not start with it and because quote_these_too is\n                 documented as not accepting it.  */\n            }\n          else if (flags & QA_ELIDE_NULL_BYTES)\n            continue;\n          break;\n\n        case '?':\n          switch (quoting_style)\n            {\n            case shell_always_quoting_style:\n              if (elide_outer_quotes)\n                goto force_outer_quoting_style;\n              break;\n\n            case c_quoting_style:\n              if ((flags & QA_SPLIT_TRIGRAPHS)\n                  && i + 2 < argsize && arg[i + 1] == '?')\n                switch (arg[i + 2])\n                  {\n                  case '!': case '\\'':\n                  case '(': case ')': case '-': case '/':\n                  case '<': case '=': case '>':\n                    /* Escape the second '?' in what would otherwise be\n                       a trigraph.  */\n                    if (elide_outer_quotes)\n                      goto force_outer_quoting_style;\n                    c = arg[i + 2];\n                    i += 2;\n                    STORE ('?');\n                    STORE ('\"');\n                    STORE ('\"');\n                    STORE ('?');\n                    break;\n\n                  default:\n                    break;\n                  }\n              break;\n\n            default:\n              break;\n            }\n          break;\n\n        case '\\a': esc = 'a'; goto c_escape;\n        case '\\b': esc = 'b'; goto c_escape;\n        case '\\f': esc = 'f'; goto c_escape;\n        case '\\n': esc = 'n'; goto c_and_shell_escape;\n        case '\\r': esc = 'r'; goto c_and_shell_escape;\n        case '\\t': esc = 't'; goto c_and_shell_escape;\n        case '\\v': esc = 'v'; goto c_escape;\n        case '\\\\': esc = c;\n          /* Never need to escape '\\' in shell case.  */\n          if (quoting_style == shell_always_quoting_style)\n            {\n              if (elide_outer_quotes)\n                goto force_outer_quoting_style;\n              goto store_c;\n            }\n\n          /* No need to escape the escape if we are trying to elide\n             outer quotes and nothing else is problematic.  */\n          if (backslash_escapes && elide_outer_quotes && quote_string_len)\n            goto store_c;\n\n        c_and_shell_escape:\n          if (quoting_style == shell_always_quoting_style\n              && elide_outer_quotes)\n            goto force_outer_quoting_style;\n          /* fall through */\n        c_escape:\n          if (backslash_escapes)\n            {\n              c = esc;\n              goto store_escape;\n            }\n          break;\n\n        case '{': case '}': /* sometimes special if isolated */\n          if (! (argsize == SIZE_MAX ? arg[1] == '\\0' : argsize == 1))\n            break;\n          FALLTHROUGH;\n        case '#': case '~':\n          if (i != 0)\n            break;\n          FALLTHROUGH;\n        case ' ':\n          c_and_shell_quote_compat = true;\n          FALLTHROUGH;\n        case '!': /* special in bash */\n        case '\"': case '$': case '&':\n        case '(': case ')': case '*': case ';':\n        case '<':\n        case '=': /* sometimes special in 0th or (with \"set -k\") later args */\n        case '>': case '[':\n        case '^': /* special in old /bin/sh, e.g. SunOS 4.1.4 */\n        case '`': case '|':\n          /* A shell special character.  In theory, '$' and '`' could\n             be the first bytes of multibyte characters, which means\n             we should check them with mbrtowc, but in practice this\n             doesn't happen so it's not worth worrying about.  */\n          if (quoting_style == shell_always_quoting_style\n              && elide_outer_quotes)\n            goto force_outer_quoting_style;\n          break;\n\n        case '\\'':\n          encountered_single_quote = true;\n          c_and_shell_quote_compat = true;\n          if (quoting_style == shell_always_quoting_style)\n            {\n              if (elide_outer_quotes)\n                goto force_outer_quoting_style;\n\n              if (buffersize && ! orig_buffersize)\n                {\n                  /* Just scan string to see if supports a more concise\n                     representation, rather than writing a longer string\n                     but returning the length of the more concise form.  */\n                  orig_buffersize = buffersize;\n                  buffersize = 0;\n                }\n\n              STORE ('\\'');\n              STORE ('\\\\');\n              STORE ('\\'');\n              pending_shell_escape_end = false;\n            }\n          break;\n\n        case '%': case '+': case ',': case '-': case '.': case '/':\n        case '0': case '1': case '2': case '3': case '4': case '5':\n        case '6': case '7': case '8': case '9': case ':':\n        case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n        case 'G': case 'H': case 'I': case 'J': case 'K': case 'L':\n        case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':\n        case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n        case 'Y': case 'Z': case ']': case '_': case 'a': case 'b':\n        case 'c': case 'd': case 'e': case 'f': case 'g': case 'h':\n        case 'i': case 'j': case 'k': case 'l': case 'm': case 'n':\n        case 'o': case 'p': case 'q': case 'r': case 's': case 't':\n        case 'u': case 'v': case 'w': case 'x': case 'y': case 'z':\n          /* These characters don't cause problems, no matter what the\n             quoting style is.  They cannot start multibyte sequences.\n             A digit or a special letter would cause trouble if it\n             appeared at the beginning of quote_string because we'd then\n             escape by prepending a backslash.  However, it's hard to\n             imagine any locale that would use digits or letters as\n             quotes, and set_custom_quoting is documented not to accept\n             them.  Also, a digit or a special letter would cause\n             trouble if it appeared in quote_these_too, but that's also\n             documented as not accepting them.  */\n          c_and_shell_quote_compat = true;\n          break;\n\n        default:\n          /* If we have a multibyte sequence, copy it until we reach\n             its end, find an error, or come back to the initial shift\n             state.  For C-like styles, if the sequence has\n             unprintable characters, escape the whole sequence, since\n             we can't easily escape single characters within it.  */\n          {\n            /* Length of multibyte sequence found so far.  */\n            size_t m;\n\n            bool printable;\n\n            if (unibyte_locale)\n              {\n                m = 1;\n                printable = isprint (c) != 0;\n              }\n            else\n              {\n                mbstate_t mbstate;\n                memset (&mbstate, 0, sizeof mbstate);\n\n                m = 0;\n                printable = true;\n                if (argsize == SIZE_MAX)\n                  argsize = strlen (arg);\n\n                do\n                  {\n                    wchar_t w;\n                    size_t bytes = mbrtowc (&w, &arg[i + m],\n                                            argsize - (i + m), &mbstate);\n                    if (bytes == 0)\n                      break;\n                    else if (bytes == (size_t) -1)\n                      {\n                        printable = false;\n                        break;\n                      }\n                    else if (bytes == (size_t) -2)\n                      {\n                        printable = false;\n                        while (i + m < argsize && arg[i + m])\n                          m++;\n                        break;\n                      }\n                    else\n                      {\n                        /* Work around a bug with older shells that \"see\" a '\\'\n                           that is really the 2nd byte of a multibyte character.\n                           In practice the problem is limited to ASCII\n                           chars >= '@' that are shell special chars.  */\n                        if ('[' == 0x5b && elide_outer_quotes\n                            && quoting_style == shell_always_quoting_style)\n                          {\n                            size_t j;\n                            for (j = 1; j < bytes; j++)\n                              switch (arg[i + m + j])\n                                {\n                                case '[': case '\\\\': case '^':\n                                case '`': case '|':\n                                  goto force_outer_quoting_style;\n\n                                default:\n                                  break;\n                                }\n                          }\n\n                        if (! iswprint (w))\n                          printable = false;\n                        m += bytes;\n                      }\n                  }\n                while (! mbsinit (&mbstate));\n              }\n\n            c_and_shell_quote_compat = printable;\n\n            if (1 < m || (backslash_escapes && ! printable))\n              {\n                /* Output a multibyte sequence, or an escaped\n                   unprintable unibyte character.  */\n                size_t ilim = i + m;\n\n                for (;;)\n                  {\n                    if (backslash_escapes && ! printable)\n                      {\n                        START_ESC ();\n                        STORE ('0' + (c >> 6));\n                        STORE ('0' + ((c >> 3) & 7));\n                        c = '0' + (c & 7);\n                      }\n                    else if (is_right_quote)\n                      {\n                        STORE ('\\\\');\n                        is_right_quote = false;\n                      }\n                    if (ilim <= i + 1)\n                      break;\n                    END_ESC ();\n                    STORE (c);\n                    c = arg[++i];\n                  }\n\n                goto store_c;\n              }\n          }\n        }\n\n      if (! (((backslash_escapes && quoting_style != shell_always_quoting_style)\n              || elide_outer_quotes)\n             && quote_these_too\n             && quote_these_too[c / INT_BITS] >> (c % INT_BITS) & 1)\n          && !is_right_quote)\n        goto store_c;\n\n    store_escape:\n      START_ESC ();\n\n    store_c:\n      END_ESC ();\n      STORE (c);\n\n      if (! c_and_shell_quote_compat)\n        all_c_and_shell_quote_compat = false;\n    }\n\n  if (len == 0 && quoting_style == shell_always_quoting_style\n      && elide_outer_quotes)\n    goto force_outer_quoting_style;\n\n  /* Single shell quotes (') are commonly enough used as an apostrophe,\n     that we attempt to minimize the quoting in this case.  Note it\u00ca\u00bcs\n     better to use the apostrophe modifier \"\\u02BC\" if possible, as that\n     renders better and works with the word match regex \\W+ etc.  */\n  if (quoting_style == shell_always_quoting_style && ! elide_outer_quotes\n      && encountered_single_quote)\n    {\n      if (all_c_and_shell_quote_compat)\n        return quotearg_buffer_restyled (buffer, orig_buffersize, arg, argsize,\n                                         c_quoting_style,\n                                         flags, quote_these_too,\n                                         left_quote, right_quote);\n      else if (! buffersize && orig_buffersize)\n        {\n          /* Disable read-only scan, and reprocess to write quoted string.  */\n          buffersize = orig_buffersize;\n          len = 0;\n          goto process_input;\n        }\n    }\n\n  if (quote_string && !elide_outer_quotes)\n    for (; *quote_string; quote_string++)\n      STORE (*quote_string);\n\n  if (len < buffersize)\n    buffer[len] = '\\0';\n  return len;\n\n force_outer_quoting_style:\n  /* Don't reuse quote_these_too, since the addition of outer quotes\n     sufficiently quotes the specified characters.  */\n  if (quoting_style == shell_always_quoting_style && backslash_escapes)\n    quoting_style = shell_escape_always_quoting_style;\n  return quotearg_buffer_restyled (buffer, buffersize, arg, argsize,\n                                   quoting_style,\n                                   flags & ~QA_ELIDE_OUTER_QUOTES, NULL,\n                                   left_quote, right_quote);\n}",
      "lines": 518,
      "depth": 25,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "quotearg_buffer": {
      "start_point": [
        782,
        0
      ],
      "end_point": [
        794,
        1
      ],
      "content": "size_t\nquotearg_buffer (char *buffer, size_t buffersize,\n                 char const *arg, size_t argsize,\n                 struct quoting_options const *o)\n{\n  struct quoting_options const *p = o ? o : &default_quoting_options;\n  int e = errno;\n  size_t r = quotearg_buffer_restyled (buffer, buffersize, arg, argsize,\n                                       p->style, p->flags, p->quote_these_too,\n                                       p->left_quote, p->right_quote);\n  errno = e;\n  return r;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "size_t"
      ]
    },
    "quotearg_alloc": {
      "start_point": [
        797,
        0
      ],
      "end_point": [
        802,
        1
      ],
      "content": "char *\nquotearg_alloc (char const *arg, size_t argsize,\n                struct quoting_options const *o)\n{\n  return quotearg_alloc_mem (arg, argsize, NULL, o);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_alloc (char const *arg, size_t argsize,\n                struct quoting_options const *o)",
        "*"
      ]
    },
    "quotearg_alloc_mem": {
      "start_point": [
        810,
        0
      ],
      "end_point": [
        830,
        1
      ],
      "content": "char *\nquotearg_alloc_mem (char const *arg, size_t argsize, size_t *size,\n                    struct quoting_options const *o)\n{\n  struct quoting_options const *p = o ? o : &default_quoting_options;\n  int e = errno;\n  /* Elide embedded null bytes if we can't return a size.  */\n  int flags = p->flags | (size ? 0 : QA_ELIDE_NULL_BYTES);\n  size_t bufsize = quotearg_buffer_restyled (0, 0, arg, argsize, p->style,\n                                             flags, p->quote_these_too,\n                                             p->left_quote,\n                                             p->right_quote) + 1;\n  char *buf = xcharalloc (bufsize);\n  quotearg_buffer_restyled (buf, bufsize, arg, argsize, p->style, flags,\n                            p->quote_these_too,\n                            p->left_quote, p->right_quote);\n  errno = e;\n  if (size)\n    *size = bufsize - 1;\n  return buf;\n}",
      "lines": 21,
      "depth": 9,
      "decorators": [
        "char",
        "*\nquotearg_alloc_mem (char const *arg, size_t argsize, size_t *size,\n                    struct quoting_options const *o)",
        "*"
      ]
    },
    "quotearg_free": {
      "start_point": [
        846,
        0
      ],
      "end_point": [
        865,
        1
      ],
      "content": "void\nquotearg_free (void)\n{\n  struct slotvec *sv = slotvec;\n  int i;\n  for (i = 1; i < nslots; i++)\n    free (sv[i].val);\n  if (sv[0].val != slot0)\n    {\n      free (sv[0].val);\n      slotvec0.size = sizeof slot0;\n      slotvec0.val = slot0;\n    }\n  if (sv != &slotvec0)\n    {\n      free (sv);\n      slotvec = &slotvec0;\n    }\n  nslots = 1;\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "quotearg_n_options": {
      "start_point": [
        875,
        0
      ],
      "end_point": [
        927,
        1
      ],
      "content": "static char *\nquotearg_n_options (int n, char const *arg, size_t argsize,\n                    struct quoting_options const *options)\n{\n  int e = errno;\n\n  struct slotvec *sv = slotvec;\n\n  if (n < 0)\n    abort ();\n\n  if (nslots <= n)\n    {\n      bool preallocated = (sv == &slotvec0);\n      int nmax = MIN (INT_MAX, MIN (PTRDIFF_MAX, SIZE_MAX) / sizeof *sv) - 1;\n\n      if (nmax < n)\n        xalloc_die ();\n\n      slotvec = sv = xrealloc (preallocated ? NULL : sv, (n + 1) * sizeof *sv);\n      if (preallocated)\n        *sv = slotvec0;\n      memset (sv + nslots, 0, (n + 1 - nslots) * sizeof *sv);\n      nslots = n + 1;\n    }\n\n  {\n    size_t size = sv[n].size;\n    char *val = sv[n].val;\n    /* Elide embedded null bytes since we don't return a size.  */\n    int flags = options->flags | QA_ELIDE_NULL_BYTES;\n    size_t qsize = quotearg_buffer_restyled (val, size, arg, argsize,\n                                             options->style, flags,\n                                             options->quote_these_too,\n                                             options->left_quote,\n                                             options->right_quote);\n\n    if (size <= qsize)\n      {\n        sv[n].size = size = qsize + 1;\n        if (val != slot0)\n          free (val);\n        sv[n].val = val = xcharalloc (size);\n        quotearg_buffer_restyled (val, size, arg, argsize, options->style,\n                                  flags, options->quote_these_too,\n                                  options->left_quote,\n                                  options->right_quote);\n      }\n\n    errno = e;\n    return val;\n  }\n}",
      "lines": 53,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nquotearg_n_options (int n, char const *arg, size_t argsize,\n                    struct quoting_options const *options)",
        "*"
      ]
    },
    "quotearg_n": {
      "start_point": [
        929,
        0
      ],
      "end_point": [
        933,
        1
      ],
      "content": "char *\nquotearg_n (int n, char const *arg)\n{\n  return quotearg_n_options (n, arg, SIZE_MAX, &default_quoting_options);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_n (int n, char const *arg)",
        "*"
      ]
    },
    "quotearg_n_mem": {
      "start_point": [
        935,
        0
      ],
      "end_point": [
        939,
        1
      ],
      "content": "char *\nquotearg_n_mem (int n, char const *arg, size_t argsize)\n{\n  return quotearg_n_options (n, arg, argsize, &default_quoting_options);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_n_mem (int n, char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quotearg": {
      "start_point": [
        941,
        0
      ],
      "end_point": [
        945,
        1
      ],
      "content": "char *\nquotearg (char const *arg)\n{\n  return quotearg_n (0, arg);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg (char const *arg)",
        "*"
      ]
    },
    "quotearg_mem": {
      "start_point": [
        947,
        0
      ],
      "end_point": [
        951,
        1
      ],
      "content": "char *\nquotearg_mem (char const *arg, size_t argsize)\n{\n  return quotearg_n_mem (0, arg, argsize);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_mem (char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quotearg_n_style": {
      "start_point": [
        953,
        0
      ],
      "end_point": [
        958,
        1
      ],
      "content": "char *\nquotearg_n_style (int n, enum quoting_style s, char const *arg)\n{\n  struct quoting_options const o = quoting_options_from_style (s);\n  return quotearg_n_options (n, arg, SIZE_MAX, &o);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_n_style (int n, enum quoting_style s, char const *arg)",
        "*"
      ]
    },
    "quotearg_n_style_mem": {
      "start_point": [
        960,
        0
      ],
      "end_point": [
        966,
        1
      ],
      "content": "char *\nquotearg_n_style_mem (int n, enum quoting_style s,\n                      char const *arg, size_t argsize)\n{\n  struct quoting_options const o = quoting_options_from_style (s);\n  return quotearg_n_options (n, arg, argsize, &o);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_n_style_mem (int n, enum quoting_style s,\n                      char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quotearg_style": {
      "start_point": [
        968,
        0
      ],
      "end_point": [
        972,
        1
      ],
      "content": "char *\nquotearg_style (enum quoting_style s, char const *arg)\n{\n  return quotearg_n_style (0, s, arg);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_style (enum quoting_style s, char const *arg)",
        "*"
      ]
    },
    "quotearg_style_mem": {
      "start_point": [
        974,
        0
      ],
      "end_point": [
        978,
        1
      ],
      "content": "char *\nquotearg_style_mem (enum quoting_style s, char const *arg, size_t argsize)\n{\n  return quotearg_n_style_mem (0, s, arg, argsize);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_style_mem (enum quoting_style s, char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quotearg_char_mem": {
      "start_point": [
        980,
        0
      ],
      "end_point": [
        987,
        1
      ],
      "content": "char *\nquotearg_char_mem (char const *arg, size_t argsize, char ch)\n{\n  struct quoting_options options;\n  options = default_quoting_options;\n  set_char_quoting (&options, ch, 1);\n  return quotearg_n_options (0, arg, argsize, &options);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_char_mem (char const *arg, size_t argsize, char ch)",
        "*"
      ]
    },
    "quotearg_char": {
      "start_point": [
        989,
        0
      ],
      "end_point": [
        993,
        1
      ],
      "content": "char *\nquotearg_char (char const *arg, char ch)\n{\n  return quotearg_char_mem (arg, SIZE_MAX, ch);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_char (char const *arg, char ch)",
        "*"
      ]
    },
    "quotearg_colon": {
      "start_point": [
        995,
        0
      ],
      "end_point": [
        999,
        1
      ],
      "content": "char *\nquotearg_colon (char const *arg)\n{\n  return quotearg_char (arg, ':');\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_colon (char const *arg)",
        "*"
      ]
    },
    "quotearg_colon_mem": {
      "start_point": [
        1001,
        0
      ],
      "end_point": [
        1005,
        1
      ],
      "content": "char *\nquotearg_colon_mem (char const *arg, size_t argsize)\n{\n  return quotearg_char_mem (arg, argsize, ':');\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_colon_mem (char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quotearg_n_style_colon": {
      "start_point": [
        1007,
        0
      ],
      "end_point": [
        1014,
        1
      ],
      "content": "char *\nquotearg_n_style_colon (int n, enum quoting_style s, char const *arg)\n{\n  struct quoting_options options;\n  options = quoting_options_from_style (s);\n  set_char_quoting (&options, ':', 1);\n  return quotearg_n_options (n, arg, SIZE_MAX, &options);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_n_style_colon (int n, enum quoting_style s, char const *arg)",
        "*"
      ]
    },
    "quotearg_n_custom": {
      "start_point": [
        1016,
        0
      ],
      "end_point": [
        1022,
        1
      ],
      "content": "char *\nquotearg_n_custom (int n, char const *left_quote,\n                   char const *right_quote, char const *arg)\n{\n  return quotearg_n_custom_mem (n, left_quote, right_quote, arg,\n                                SIZE_MAX);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_n_custom (int n, char const *left_quote,\n                   char const *right_quote, char const *arg)",
        "*"
      ]
    },
    "quotearg_n_custom_mem": {
      "start_point": [
        1024,
        0
      ],
      "end_point": [
        1032,
        1
      ],
      "content": "char *\nquotearg_n_custom_mem (int n, char const *left_quote,\n                       char const *right_quote,\n                       char const *arg, size_t argsize)\n{\n  struct quoting_options o = default_quoting_options;\n  set_custom_quoting (&o, left_quote, right_quote);\n  return quotearg_n_options (n, arg, argsize, &o);\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_n_custom_mem (int n, char const *left_quote,\n                       char const *right_quote,\n                       char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quotearg_custom": {
      "start_point": [
        1034,
        0
      ],
      "end_point": [
        1039,
        1
      ],
      "content": "char *\nquotearg_custom (char const *left_quote, char const *right_quote,\n                 char const *arg)\n{\n  return quotearg_n_custom (0, left_quote, right_quote, arg);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_custom (char const *left_quote, char const *right_quote,\n                 char const *arg)",
        "*"
      ]
    },
    "quotearg_custom_mem": {
      "start_point": [
        1041,
        0
      ],
      "end_point": [
        1047,
        1
      ],
      "content": "char *\nquotearg_custom_mem (char const *left_quote, char const *right_quote,\n                     char const *arg, size_t argsize)\n{\n  return quotearg_n_custom_mem (0, left_quote, right_quote, arg,\n                                argsize);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_custom_mem (char const *left_quote, char const *right_quote,\n                     char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quote_n_mem": {
      "start_point": [
        1059,
        0
      ],
      "end_point": [
        1063,
        1
      ],
      "content": "char const *\nquote_n_mem (int n, char const *arg, size_t argsize)\n{\n  return quotearg_n_options (n, arg, argsize, &quote_quoting_options);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "const",
        "const",
        "*\nquote_n_mem (int n, char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quote_mem": {
      "start_point": [
        1065,
        0
      ],
      "end_point": [
        1069,
        1
      ],
      "content": "char const *\nquote_mem (char const *arg, size_t argsize)\n{\n  return quote_n_mem (0, arg, argsize);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "const",
        "const",
        "*\nquote_mem (char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quote_n": {
      "start_point": [
        1071,
        0
      ],
      "end_point": [
        1075,
        1
      ],
      "content": "char const *\nquote_n (int n, char const *arg)\n{\n  return quote_n_mem (n, arg, SIZE_MAX);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "const",
        "const",
        "*\nquote_n (int n, char const *arg)",
        "*"
      ]
    },
    "quote": {
      "start_point": [
        1077,
        0
      ],
      "end_point": [
        1081,
        1
      ],
      "content": "char const *\nquote (char const *arg)\n{\n  return quote_n (0, arg);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "const",
        "const",
        "*\nquote (char const *arg)",
        "*"
      ]
    }
  },
  "sed/sed-4.5/lib/quotearg.h": {},
  "sed/sed-4.5/lib/readlink.c": {
    "readlink": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        42,
        1
      ],
      "content": "ssize_t\nreadlink (const char *name, char *buf _GL_UNUSED,\n          size_t bufsize _GL_UNUSED)\n{\n  struct stat statbuf;\n\n  /* In general we should use lstat() here, not stat().  But on platforms\n     without symbolic links, lstat() - if it exists - would be equivalent to\n     stat(), therefore we can use stat().  This saves us a configure check.  */\n  if (stat (name, &statbuf) >= 0)\n    errno = EINVAL;\n  return -1;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "ssize_t"
      ]
    },
    "rpl_readlink": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "ssize_t\nrpl_readlink (const char *name, char *buf, size_t bufsize)\n{\n# if READLINK_TRAILING_SLASH_BUG\n  size_t len = strlen (name);\n  if (len && name[len - 1] == '/')\n    {\n      /* Even if name without the slash is a symlink to a directory,\n         both lstat() and stat() must resolve the trailing slash to\n         the directory rather than the symlink.  We can therefore\n         safely use stat() to distinguish between EINVAL and\n         ENOTDIR/ENOENT, avoiding extra overhead of rpl_lstat().  */\n      struct stat st;\n      if (stat (name, &st) == 0)\n        errno = EINVAL;\n      return -1;\n    }\n# endif /* READLINK_TRAILING_SLASH_BUG */\n  return readlink (name, buf, bufsize);\n}",
      "lines": 20,
      "depth": 12,
      "decorators": [
        "ssize_t"
      ]
    }
  },
  "sed/sed-4.5/lib/regcomp.c": {
    "re_compile_pattern": {
      "start_point": [
        215,
        0
      ],
      "end_point": [
        234,
        1
      ],
      "content": "const char *\nre_compile_pattern (const char *pattern, size_t length,\n\t\t    struct re_pattern_buffer *bufp)\n{\n  reg_errcode_t ret;\n\n  /* And GNU code determines whether or not to get register information\n     by passing null for the REGS argument to re_match, etc., not by\n     setting no_sub, unless RE_NO_SUB is set.  */\n  bufp->no_sub = !!(re_syntax_options & RE_NO_SUB);\n\n  /* Match anchors at newline.  */\n  bufp->newline_anchor = 1;\n\n  ret = re_compile_internal (bufp, pattern, length, re_syntax_options);\n\n  if (!ret)\n    return NULL;\n  return gettext (__re_error_msgid + __re_error_msgid_idx[(int) ret]);\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nre_compile_pattern (const char *pattern, size_t length,\n\t\t    struct re_pattern_buffer *bufp)",
        "*"
      ]
    },
    "re_set_syntax": {
      "start_point": [
        254,
        0
      ],
      "end_point": [
        261,
        1
      ],
      "content": "reg_syntax_t\nre_set_syntax (reg_syntax_t syntax)\n{\n  reg_syntax_t ret = re_syntax_options;\n\n  re_syntax_options = syntax;\n  return ret;\n}",
      "lines": 8,
      "depth": 5,
      "decorators": [
        "reg_syntax_t"
      ]
    },
    "re_compile_fastmap": {
      "start_point": [
        266,
        0
      ],
      "end_point": [
        282,
        1
      ],
      "content": "int\nre_compile_fastmap (struct re_pattern_buffer *bufp)\n{\n  re_dfa_t *dfa = bufp->buffer;\n  char *fastmap = bufp->fastmap;\n\n  memset (fastmap, '\\0', sizeof (char) * SBC_MAX);\n  re_compile_fastmap_iter (bufp, dfa->init_state, fastmap);\n  if (dfa->init_state != dfa->init_state_word)\n    re_compile_fastmap_iter (bufp, dfa->init_state_word, fastmap);\n  if (dfa->init_state != dfa->init_state_nl)\n    re_compile_fastmap_iter (bufp, dfa->init_state_nl, fastmap);\n  if (dfa->init_state != dfa->init_state_begbuf)\n    re_compile_fastmap_iter (bufp, dfa->init_state_begbuf, fastmap);\n  bufp->fastmap_accurate = 1;\n  return 0;\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "re_set_fastmap": {
      "start_point": [
        287,
        0
      ],
      "end_point": [
        294,
        1
      ],
      "content": "static inline void\n__attribute__ ((always_inline))\nre_set_fastmap (char *fastmap, bool icase, int ch)\n{\n  fastmap[ch] = 1;\n  if (icase)\n    fastmap[tolower (ch)] = 1;\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void",
        "__attribute__ ((always_inline))",
        "__attribute__",
        "(",
        "(always_inline)",
        "(",
        "always_inline",
        ")",
        ")"
      ]
    },
    "re_compile_fastmap_iter": {
      "start_point": [
        299,
        0
      ],
      "end_point": [
        427,
        1
      ],
      "content": "static void\nre_compile_fastmap_iter (regex_t *bufp, const re_dfastate_t *init_state,\n\t\t\t char *fastmap)\n{\n  re_dfa_t *dfa = bufp->buffer;\n  Idx node_cnt;\n  bool icase = (dfa->mb_cur_max == 1 && (bufp->syntax & RE_ICASE));\n  for (node_cnt = 0; node_cnt < init_state->nodes.nelem; ++node_cnt)\n    {\n      Idx node = init_state->nodes.elems[node_cnt];\n      re_token_type_t type = dfa->nodes[node].type;\n\n      if (type == CHARACTER)\n\t{\n\t  re_set_fastmap (fastmap, icase, dfa->nodes[node].opr.c);\n#ifdef RE_ENABLE_I18N\n\t  if ((bufp->syntax & RE_ICASE) && dfa->mb_cur_max > 1)\n\t    {\n\t      unsigned char buf[MB_LEN_MAX];\n\t      unsigned char *p;\n\t      wchar_t wc;\n\t      mbstate_t state;\n\n\t      p = buf;\n\t      *p++ = dfa->nodes[node].opr.c;\n\t      while (++node < dfa->nodes_len\n\t\t     &&\tdfa->nodes[node].type == CHARACTER\n\t\t     && dfa->nodes[node].mb_partial)\n\t\t*p++ = dfa->nodes[node].opr.c;\n\t      memset (&state, '\\0', sizeof (state));\n\t      if (__mbrtowc (&wc, (const char *) buf, p - buf,\n\t\t\t     &state) == p - buf\n\t\t  && (__wcrtomb ((char *) buf, __towlower (wc), &state)\n\t\t      != (size_t) -1))\n\t\tre_set_fastmap (fastmap, false, buf[0]);\n\t    }\n#endif\n\t}\n      else if (type == SIMPLE_BRACKET)\n\t{\n\t  int i, ch;\n\t  for (i = 0, ch = 0; i < BITSET_WORDS; ++i)\n\t    {\n\t      int j;\n\t      bitset_word_t w = dfa->nodes[node].opr.sbcset[i];\n\t      for (j = 0; j < BITSET_WORD_BITS; ++j, ++ch)\n\t\tif (w & ((bitset_word_t) 1 << j))\n\t\t  re_set_fastmap (fastmap, icase, ch);\n\t    }\n\t}\n#ifdef RE_ENABLE_I18N\n      else if (type == COMPLEX_BRACKET)\n\t{\n\t  re_charset_t *cset = dfa->nodes[node].opr.mbcset;\n\t  Idx i;\n\n# ifdef _LIBC\n\t  /* See if we have to try all bytes which start multiple collation\n\t     elements.\n\t     e.g. In da_DK, we want to catch 'a' since \"aa\" is a valid\n\t\t  collation element, and don't catch 'b' since 'b' is\n\t\t  the only collation element which starts from 'b' (and\n\t\t  it is caught by SIMPLE_BRACKET).  */\n\t      if (_NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_NRULES) != 0\n\t\t  && (cset->ncoll_syms || cset->nranges))\n\t\t{\n\t\t  const int32_t *table = (const int32_t *)\n\t\t    _NL_CURRENT (LC_COLLATE, _NL_COLLATE_TABLEMB);\n\t\t  for (i = 0; i < SBC_MAX; ++i)\n\t\t    if (table[i] < 0)\n\t\t      re_set_fastmap (fastmap, icase, i);\n\t\t}\n# endif /* _LIBC */\n\n\t  /* See if we have to start the match at all multibyte characters,\n\t     i.e. where we would not find an invalid sequence.  This only\n\t     applies to multibyte character sets; for single byte character\n\t     sets, the SIMPLE_BRACKET again suffices.  */\n\t  if (dfa->mb_cur_max > 1\n\t      && (cset->nchar_classes || cset->non_match || cset->nranges\n# ifdef _LIBC\n\t\t  || cset->nequiv_classes\n# endif /* _LIBC */\n\t\t ))\n\t    {\n\t      unsigned char c = 0;\n\t      do\n\t\t{\n\t\t  mbstate_t mbs;\n\t\t  memset (&mbs, 0, sizeof (mbs));\n\t\t  if (__mbrtowc (NULL, (char *) &c, 1, &mbs) == (size_t) -2)\n\t\t    re_set_fastmap (fastmap, false, (int) c);\n\t\t}\n\t      while (++c != 0);\n\t    }\n\n\t  else\n\t    {\n\t      /* ... Else catch all bytes which can start the mbchars.  */\n\t      for (i = 0; i < cset->nmbchars; ++i)\n\t\t{\n\t\t  char buf[256];\n\t\t  mbstate_t state;\n\t\t  memset (&state, '\\0', sizeof (state));\n\t\t  if (__wcrtomb (buf, cset->mbchars[i], &state) != (size_t) -1)\n\t\t    re_set_fastmap (fastmap, icase, *(unsigned char *) buf);\n\t\t  if ((bufp->syntax & RE_ICASE) && dfa->mb_cur_max > 1)\n\t\t    {\n\t\t      if (__wcrtomb (buf, __towlower (cset->mbchars[i]), &state)\n\t\t\t  != (size_t) -1)\n\t\t\tre_set_fastmap (fastmap, false, *(unsigned char *) buf);\n\t\t    }\n\t\t}\n\t    }\n\t}\n#endif /* RE_ENABLE_I18N */\n      else if (type == OP_PERIOD\n#ifdef RE_ENABLE_I18N\n\t       || type == OP_UTF8_PERIOD\n#endif /* RE_ENABLE_I18N */\n\t       || type == END_OF_RE)\n\t{\n\t  memset (fastmap, '\\1', sizeof (char) * SBC_MAX);\n\t  if (type == END_OF_RE)\n\t    bufp->can_be_null = 1;\n\t  return;\n\t}\n    }\n}",
      "lines": 129,
      "depth": 23,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "regcomp": {
      "start_point": [
        465,
        0
      ],
      "end_point": [
        516,
        1
      ],
      "content": "int\nregcomp (regex_t *_Restrict_ preg, const char *_Restrict_ pattern, int cflags)\n{\n  reg_errcode_t ret;\n  reg_syntax_t syntax = ((cflags & REG_EXTENDED) ? RE_SYNTAX_POSIX_EXTENDED\n\t\t\t : RE_SYNTAX_POSIX_BASIC);\n\n  preg->buffer = NULL;\n  preg->allocated = 0;\n  preg->used = 0;\n\n  /* Try to allocate space for the fastmap.  */\n  preg->fastmap = re_malloc (char, SBC_MAX);\n  if (BE (preg->fastmap == NULL, 0))\n    return REG_ESPACE;\n\n  syntax |= (cflags & REG_ICASE) ? RE_ICASE : 0;\n\n  /* If REG_NEWLINE is set, newlines are treated differently.  */\n  if (cflags & REG_NEWLINE)\n    { /* REG_NEWLINE implies neither . nor [^...] match newline.  */\n      syntax &= ~RE_DOT_NEWLINE;\n      syntax |= RE_HAT_LISTS_NOT_NEWLINE;\n      /* It also changes the matching behavior.  */\n      preg->newline_anchor = 1;\n    }\n  else\n    preg->newline_anchor = 0;\n  preg->no_sub = !!(cflags & REG_NOSUB);\n  preg->translate = NULL;\n\n  ret = re_compile_internal (preg, pattern, strlen (pattern), syntax);\n\n  /* POSIX doesn't distinguish between an unmatched open-group and an\n     unmatched close-group: both are REG_EPAREN.  */\n  if (ret == REG_ERPAREN)\n    ret = REG_EPAREN;\n\n  /* We have already checked preg->fastmap != NULL.  */\n  if (BE (ret == REG_NOERROR, 1))\n    /* Compute the fastmap now, since regexec cannot modify the pattern\n       buffer.  This function never fails in this implementation.  */\n    (void) re_compile_fastmap (preg);\n  else\n    {\n      /* Some error occurred while compiling the expression.  */\n      re_free (preg->fastmap);\n      preg->fastmap = NULL;\n    }\n\n  return (int) ret;\n}",
      "lines": 52,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "regerror": {
      "start_point": [
        525,
        0
      ],
      "end_point": [
        557,
        1
      ],
      "content": "size_t\nregerror (int errcode, const regex_t *_Restrict_ preg, char *_Restrict_ errbuf,\n\t  size_t errbuf_size)\n{\n  const char *msg;\n  size_t msg_size;\n\n  if (BE (errcode < 0\n\t  || errcode >= (int) (sizeof (__re_error_msgid_idx)\n\t\t\t       / sizeof (__re_error_msgid_idx[0])), 0))\n    /* Only error codes returned by the rest of the code should be passed\n       to this routine.  If we are given anything else, or if other regex\n       code generates an invalid error code, then the program has a bug.\n       Dump core so we can fix it.  */\n    abort ();\n\n  msg = gettext (__re_error_msgid + __re_error_msgid_idx[errcode]);\n\n  msg_size = strlen (msg) + 1; /* Includes the null.  */\n\n  if (BE (errbuf_size != 0, 1))\n    {\n      size_t cpy_size = msg_size;\n      if (BE (msg_size > errbuf_size, 0))\n\t{\n\t  cpy_size = errbuf_size - 1;\n\t  errbuf[cpy_size] = '\\0';\n\t}\n      memcpy (errbuf, msg, cpy_size);\n    }\n\n  return msg_size;\n}",
      "lines": 33,
      "depth": 15,
      "decorators": [
        "size_t"
      ]
    },
    "free_dfa_content": {
      "start_point": [
        592,
        0
      ],
      "end_point": [
        637,
        1
      ],
      "content": "static void\nfree_dfa_content (re_dfa_t *dfa)\n{\n  Idx i, j;\n\n  if (dfa->nodes)\n    for (i = 0; i < dfa->nodes_len; ++i)\n      free_token (dfa->nodes + i);\n  re_free (dfa->nexts);\n  for (i = 0; i < dfa->nodes_len; ++i)\n    {\n      if (dfa->eclosures != NULL)\n\tre_node_set_free (dfa->eclosures + i);\n      if (dfa->inveclosures != NULL)\n\tre_node_set_free (dfa->inveclosures + i);\n      if (dfa->edests != NULL)\n\tre_node_set_free (dfa->edests + i);\n    }\n  re_free (dfa->edests);\n  re_free (dfa->eclosures);\n  re_free (dfa->inveclosures);\n  re_free (dfa->nodes);\n\n  if (dfa->state_table)\n    for (i = 0; i <= dfa->state_hash_mask; ++i)\n      {\n\tstruct re_state_table_entry *entry = dfa->state_table + i;\n\tfor (j = 0; j < entry->num; ++j)\n\t  {\n\t    re_dfastate_t *state = entry->array[j];\n\t    free_state (state);\n\t  }\n\tre_free (entry->array);\n      }\n  re_free (dfa->state_table);\n#ifdef RE_ENABLE_I18N\n  if (dfa->sb_char != utf8_sb_map)\n    re_free (dfa->sb_char);\n#endif\n  re_free (dfa->subexp_map);\n#ifdef DEBUG\n  re_free (dfa->re_str);\n#endif\n\n  re_free (dfa);\n}",
      "lines": 46,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "regfree": {
      "start_point": [
        642,
        0
      ],
      "end_point": [
        659,
        1
      ],
      "content": "void\nregfree (regex_t *preg)\n{\n  re_dfa_t *dfa = preg->buffer;\n  if (BE (dfa != NULL, 1))\n    {\n      lock_fini (dfa->lock);\n      free_dfa_content (dfa);\n    }\n  preg->buffer = NULL;\n  preg->allocated = 0;\n\n  re_free (preg->fastmap);\n  preg->fastmap = NULL;\n\n  re_free (preg->translate);\n  preg->translate = NULL;\n}",
      "lines": 18,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "re_comp": {
      "start_point": [
        678,
        0
      ],
      "end_point": [
        722,
        1
      ],
      "content": "weak_function\n# endif\nre_comp (const char *s)\n{\n  reg_errcode_t ret;\n  char *fastmap;\n\n  if (!s)\n    {\n      if (!re_comp_buf.buffer)\n\treturn gettext (\"No previous regular expression\");\n      return 0;\n    }\n\n  if (re_comp_buf.buffer)\n    {\n      fastmap = re_comp_buf.fastmap;\n      re_comp_buf.fastmap = NULL;\n      __regfree (&re_comp_buf);\n      memset (&re_comp_buf, '\\0', sizeof (re_comp_buf));\n      re_comp_buf.fastmap = fastmap;\n    }\n\n  if (re_comp_buf.fastmap == NULL)\n    {\n      re_comp_buf.fastmap = re_malloc (char, SBC_MAX);\n      if (re_comp_buf.fastmap == NULL)\n\treturn (char *) gettext (__re_error_msgid\n\t\t\t\t + __re_error_msgid_idx[(int) REG_ESPACE]);\n    }\n\n  /* Since 're_exec' always passes NULL for the 'regs' argument, we\n     don't need to initialize the pattern buffer fields which affect it.  */\n\n  /* Match anchors at newlines.  */\n  re_comp_buf.newline_anchor = 1;\n\n  ret = re_compile_internal (&re_comp_buf, s, strlen (s), re_syntax_options);\n\n  if (!ret)\n    return NULL;\n\n  /* Yes, we're discarding 'const' here if !HAVE_LIBINTL.  */\n  return (char *) gettext (__re_error_msgid + __re_error_msgid_idx[(int) ret]);\n}",
      "lines": 45,
      "depth": 14,
      "decorators": [
        "weak_function",
        "# endif",
        "# endif"
      ]
    },
    "free_mem": {
      "start_point": [
        725,
        0
      ],
      "end_point": [
        728,
        1
      ],
      "content": "libc_freeres_fn (free_mem)\n{\n  __regfree (&re_comp_buf);\n}",
      "lines": 4,
      "depth": 7,
      "decorators": null
    },
    "re_compile_internal": {
      "start_point": [
        737,
        0
      ],
      "end_point": [
        833,
        1
      ],
      "content": "static reg_errcode_t\nre_compile_internal (regex_t *preg, const char * pattern, size_t length,\n\t\t     reg_syntax_t syntax)\n{\n  reg_errcode_t err = REG_NOERROR;\n  re_dfa_t *dfa;\n  re_string_t regexp;\n\n  /* Initialize the pattern buffer.  */\n  preg->fastmap_accurate = 0;\n  preg->syntax = syntax;\n  preg->not_bol = preg->not_eol = 0;\n  preg->used = 0;\n  preg->re_nsub = 0;\n  preg->can_be_null = 0;\n  preg->regs_allocated = REGS_UNALLOCATED;\n\n  /* Initialize the dfa.  */\n  dfa = preg->buffer;\n  if (BE (preg->allocated < sizeof (re_dfa_t), 0))\n    {\n      /* If zero allocated, but buffer is non-null, try to realloc\n\t enough space.  This loses if buffer's address is bogus, but\n\t that is the user's responsibility.  If ->buffer is NULL this\n\t is a simple allocation.  */\n      dfa = re_realloc (preg->buffer, re_dfa_t, 1);\n      if (dfa == NULL)\n\treturn REG_ESPACE;\n      preg->allocated = sizeof (re_dfa_t);\n      preg->buffer = dfa;\n    }\n  preg->used = sizeof (re_dfa_t);\n\n  err = init_dfa (dfa, length);\n  if (BE (err == REG_NOERROR && lock_init (dfa->lock) != 0, 0))\n    err = REG_ESPACE;\n  if (BE (err != REG_NOERROR, 0))\n    {\n      free_dfa_content (dfa);\n      preg->buffer = NULL;\n      preg->allocated = 0;\n      return err;\n    }\n#ifdef DEBUG\n  /* Note: length+1 will not overflow since it is checked in init_dfa.  */\n  dfa->re_str = re_malloc (char, length + 1);\n  strncpy (dfa->re_str, pattern, length + 1);\n#endif\n\n  err = re_string_construct (&regexp, pattern, length, preg->translate,\n\t\t\t     (syntax & RE_ICASE) != 0, dfa);\n  if (BE (err != REG_NOERROR, 0))\n    {\n    re_compile_internal_free_return:\n      free_workarea_compile (preg);\n      re_string_destruct (&regexp);\n      lock_fini (dfa->lock);\n      free_dfa_content (dfa);\n      preg->buffer = NULL;\n      preg->allocated = 0;\n      return err;\n    }\n\n  /* Parse the regular expression, and build a structure tree.  */\n  preg->re_nsub = 0;\n  dfa->str_tree = parse (&regexp, preg, syntax, &err);\n  if (BE (dfa->str_tree == NULL, 0))\n    goto re_compile_internal_free_return;\n\n  /* Analyze the tree and create the nfa.  */\n  err = analyze (preg);\n  if (BE (err != REG_NOERROR, 0))\n    goto re_compile_internal_free_return;\n\n#ifdef RE_ENABLE_I18N\n  /* If possible, do searching in single byte encoding to speed things up.  */\n  if (dfa->is_utf8 && !(syntax & RE_ICASE) && preg->translate == NULL)\n    optimize_utf8 (dfa);\n#endif\n\n  /* Then create the initial state of the dfa.  */\n  err = create_initial_state (dfa);\n\n  /* Release work areas.  */\n  free_workarea_compile (preg);\n  re_string_destruct (&regexp);\n\n  if (BE (err != REG_NOERROR, 0))\n    {\n      lock_fini (dfa->lock);\n      free_dfa_content (dfa);\n      preg->buffer = NULL;\n      preg->allocated = 0;\n    }\n\n  return err;\n}",
      "lines": 97,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "init_dfa": {
      "start_point": [
        838,
        0
      ],
      "end_point": [
        932,
        1
      ],
      "content": "static reg_errcode_t\ninit_dfa (re_dfa_t *dfa, size_t pat_len)\n{\n  __re_size_t table_size;\n#ifndef _LIBC\n  const char *codeset_name;\n#endif\n#ifdef RE_ENABLE_I18N\n  size_t max_i18n_object_size = MAX (sizeof (wchar_t), sizeof (wctype_t));\n#else\n  size_t max_i18n_object_size = 0;\n#endif\n  size_t max_object_size =\n    MAX (sizeof (struct re_state_table_entry),\n\t MAX (sizeof (re_token_t),\n\t      MAX (sizeof (re_node_set),\n\t\t   MAX (sizeof (regmatch_t),\n\t\t\tmax_i18n_object_size))));\n\n  memset (dfa, '\\0', sizeof (re_dfa_t));\n\n  /* Force allocation of str_tree_storage the first time.  */\n  dfa->str_tree_storage_idx = BIN_TREE_STORAGE_SIZE;\n\n  /* Avoid overflows.  The extra \"/ 2\" is for the table_size doubling\n     calculation below, and for similar doubling calculations\n     elsewhere.  And it's <= rather than <, because some of the\n     doubling calculations add 1 afterwards.  */\n  if (BE (MIN (IDX_MAX, SIZE_MAX / max_object_size) / 2 <= pat_len, 0))\n    return REG_ESPACE;\n\n  dfa->nodes_alloc = pat_len + 1;\n  dfa->nodes = re_malloc (re_token_t, dfa->nodes_alloc);\n\n  /*  table_size = 2 ^ ceil(log pat_len) */\n  for (table_size = 1; ; table_size <<= 1)\n    if (table_size > pat_len)\n      break;\n\n  dfa->state_table = calloc (sizeof (struct re_state_table_entry), table_size);\n  dfa->state_hash_mask = table_size - 1;\n\n  dfa->mb_cur_max = MB_CUR_MAX;\n#ifdef _LIBC\n  if (dfa->mb_cur_max == 6\n      && strcmp (_NL_CURRENT (LC_CTYPE, _NL_CTYPE_CODESET_NAME), \"UTF-8\") == 0)\n    dfa->is_utf8 = 1;\n  dfa->map_notascii = (_NL_CURRENT_WORD (LC_CTYPE, _NL_CTYPE_MAP_TO_NONASCII)\n\t\t       != 0);\n#else\n  codeset_name = nl_langinfo (CODESET);\n  if ((codeset_name[0] == 'U' || codeset_name[0] == 'u')\n      && (codeset_name[1] == 'T' || codeset_name[1] == 't')\n      && (codeset_name[2] == 'F' || codeset_name[2] == 'f')\n      && strcmp (codeset_name + 3 + (codeset_name[3] == '-'), \"8\") == 0)\n    dfa->is_utf8 = 1;\n\n  /* We check exhaustively in the loop below if this charset is a\n     superset of ASCII.  */\n  dfa->map_notascii = 0;\n#endif\n\n#ifdef RE_ENABLE_I18N\n  if (dfa->mb_cur_max > 1)\n    {\n      if (dfa->is_utf8)\n\tdfa->sb_char = (re_bitset_ptr_t) utf8_sb_map;\n      else\n\t{\n\t  int i, j, ch;\n\n\t  dfa->sb_char = (re_bitset_ptr_t) calloc (sizeof (bitset_t), 1);\n\t  if (BE (dfa->sb_char == NULL, 0))\n\t    return REG_ESPACE;\n\n\t  /* Set the bits corresponding to single byte chars.  */\n\t  for (i = 0, ch = 0; i < BITSET_WORDS; ++i)\n\t    for (j = 0; j < BITSET_WORD_BITS; ++j, ++ch)\n\t      {\n\t\twint_t wch = __btowc (ch);\n\t\tif (wch != WEOF)\n\t\t  dfa->sb_char[i] |= (bitset_word_t) 1 << j;\n# ifndef _LIBC\n\t\tif (isascii (ch) && wch != ch)\n\t\t  dfa->map_notascii = 1;\n# endif\n\t      }\n\t}\n    }\n#endif\n\n  if (BE (dfa->nodes == NULL || dfa->state_table == NULL, 0))\n    return REG_ESPACE;\n  return REG_NOERROR;\n}",
      "lines": 95,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "init_word_char": {
      "start_point": [
        938,
        0
      ],
      "end_point": [
        984,
        1
      ],
      "content": "static void\ninit_word_char (re_dfa_t *dfa)\n{\n  int i = 0;\n  int j;\n  int ch = 0;\n  dfa->word_ops_used = 1;\n  if (BE (dfa->map_notascii == 0, 1))\n    {\n      /* Avoid uint32_t and uint64_t as some non-GCC platforms lack\n\t them, an issue when this code is used in Gnulib.  */\n      bitset_word_t bits0 = 0x00000000;\n      bitset_word_t bits1 = 0x03ff0000;\n      bitset_word_t bits2 = 0x87fffffe;\n      bitset_word_t bits3 = 0x07fffffe;\n      if (BITSET_WORD_BITS == 64)\n\t{\n\t  /* Pacify gcc -Woverflow on 32-bit platformns.  */\n\t  dfa->word_char[0] = bits1 << 31 << 1 | bits0;\n\t  dfa->word_char[1] = bits3 << 31 << 1 | bits2;\n\t  i = 2;\n\t}\n      else if (BITSET_WORD_BITS == 32)\n\t{\n\t  dfa->word_char[0] = bits0;\n\t  dfa->word_char[1] = bits1;\n\t  dfa->word_char[2] = bits2;\n\t  dfa->word_char[3] = bits3;\n\t  i = 4;\n\t}\n      else\n        goto general_case;\n      ch = 128;\n\n      if (BE (dfa->is_utf8, 1))\n\t{\n\t  memset (&dfa->word_char[i], '\\0', (SBC_MAX - ch) / 8);\n\t  return;\n\t}\n    }\n\n general_case:\n  for (; i < BITSET_WORDS; ++i)\n    for (j = 0; j < BITSET_WORD_BITS; ++j, ++ch)\n      if (isalnum (ch) || ch == '_')\n\tdfa->word_char[i] |= (bitset_word_t) 1 << j;\n}",
      "lines": 47,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "free_workarea_compile": {
      "start_point": [
        988,
        0
      ],
      "end_point": [
        1003,
        1
      ],
      "content": "static void\nfree_workarea_compile (regex_t *preg)\n{\n  re_dfa_t *dfa = preg->buffer;\n  bin_tree_storage_t *storage, *next;\n  for (storage = dfa->str_tree_storage; storage; storage = next)\n    {\n      next = storage->next;\n      re_free (storage);\n    }\n  dfa->str_tree_storage = NULL;\n  dfa->str_tree_storage_idx = BIN_TREE_STORAGE_SIZE;\n  dfa->str_tree = NULL;\n  re_free (dfa->org_indices);\n  dfa->org_indices = NULL;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "create_initial_state": {
      "start_point": [
        1007,
        0
      ],
      "end_point": [
        1085,
        1
      ],
      "content": "static reg_errcode_t\ncreate_initial_state (re_dfa_t *dfa)\n{\n  Idx first, i;\n  reg_errcode_t err;\n  re_node_set init_nodes;\n\n  /* Initial states have the epsilon closure of the node which is\n     the first node of the regular expression.  */\n  first = dfa->str_tree->first->node_idx;\n  dfa->init_node = first;\n  err = re_node_set_init_copy (&init_nodes, dfa->eclosures + first);\n  if (BE (err != REG_NOERROR, 0))\n    return err;\n\n  /* The back-references which are in initial states can epsilon transit,\n     since in this case all of the subexpressions can be null.\n     Then we add epsilon closures of the nodes which are the next nodes of\n     the back-references.  */\n  if (dfa->nbackref > 0)\n    for (i = 0; i < init_nodes.nelem; ++i)\n      {\n\tIdx node_idx = init_nodes.elems[i];\n\tre_token_type_t type = dfa->nodes[node_idx].type;\n\n\tIdx clexp_idx;\n\tif (type != OP_BACK_REF)\n\t  continue;\n\tfor (clexp_idx = 0; clexp_idx < init_nodes.nelem; ++clexp_idx)\n\t  {\n\t    re_token_t *clexp_node;\n\t    clexp_node = dfa->nodes + init_nodes.elems[clexp_idx];\n\t    if (clexp_node->type == OP_CLOSE_SUBEXP\n\t\t&& clexp_node->opr.idx == dfa->nodes[node_idx].opr.idx)\n\t      break;\n\t  }\n\tif (clexp_idx == init_nodes.nelem)\n\t  continue;\n\n\tif (type == OP_BACK_REF)\n\t  {\n\t    Idx dest_idx = dfa->edests[node_idx].elems[0];\n\t    if (!re_node_set_contains (&init_nodes, dest_idx))\n\t      {\n\t\treg_errcode_t merge_err\n                  = re_node_set_merge (&init_nodes, dfa->eclosures + dest_idx);\n\t\tif (merge_err != REG_NOERROR)\n\t\t  return merge_err;\n\t\ti = 0;\n\t      }\n\t  }\n      }\n\n  /* It must be the first time to invoke acquire_state.  */\n  dfa->init_state = re_acquire_state_context (&err, dfa, &init_nodes, 0);\n  /* We don't check ERR here, since the initial state must not be NULL.  */\n  if (BE (dfa->init_state == NULL, 0))\n    return err;\n  if (dfa->init_state->has_constraint)\n    {\n      dfa->init_state_word = re_acquire_state_context (&err, dfa, &init_nodes,\n\t\t\t\t\t\t       CONTEXT_WORD);\n      dfa->init_state_nl = re_acquire_state_context (&err, dfa, &init_nodes,\n\t\t\t\t\t\t     CONTEXT_NEWLINE);\n      dfa->init_state_begbuf = re_acquire_state_context (&err, dfa,\n\t\t\t\t\t\t\t &init_nodes,\n\t\t\t\t\t\t\t CONTEXT_NEWLINE\n\t\t\t\t\t\t\t | CONTEXT_BEGBUF);\n      if (BE (dfa->init_state_word == NULL || dfa->init_state_nl == NULL\n\t      || dfa->init_state_begbuf == NULL, 0))\n\treturn err;\n    }\n  else\n    dfa->init_state_word = dfa->init_state_nl\n      = dfa->init_state_begbuf = dfa->init_state;\n\n  re_node_set_free (&init_nodes);\n  return REG_NOERROR;\n}",
      "lines": 79,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "optimize_utf8": {
      "start_point": [
        1092,
        0
      ],
      "end_point": [
        1166,
        1
      ],
      "content": "static void\noptimize_utf8 (re_dfa_t *dfa)\n{\n  Idx node;\n  int i;\n  bool mb_chars = false;\n  bool has_period = false;\n\n  for (node = 0; node < dfa->nodes_len; ++node)\n    switch (dfa->nodes[node].type)\n      {\n      case CHARACTER:\n\tif (dfa->nodes[node].opr.c >= ASCII_CHARS)\n\t  mb_chars = true;\n\tbreak;\n      case ANCHOR:\n\tswitch (dfa->nodes[node].opr.ctx_type)\n\t  {\n\t  case LINE_FIRST:\n\t  case LINE_LAST:\n\t  case BUF_FIRST:\n\t  case BUF_LAST:\n\t    break;\n\t  default:\n\t    /* Word anchors etc. cannot be handled.  It's okay to test\n\t       opr.ctx_type since constraints (for all DFA nodes) are\n\t       created by ORing one or more opr.ctx_type values.  */\n\t    return;\n\t  }\n\tbreak;\n      case OP_PERIOD:\n\thas_period = true;\n\tbreak;\n      case OP_BACK_REF:\n      case OP_ALT:\n      case END_OF_RE:\n      case OP_DUP_ASTERISK:\n      case OP_OPEN_SUBEXP:\n      case OP_CLOSE_SUBEXP:\n\tbreak;\n      case COMPLEX_BRACKET:\n\treturn;\n      case SIMPLE_BRACKET:\n\t/* Just double check.  */\n\t{\n\t  int rshift = (ASCII_CHARS % BITSET_WORD_BITS == 0\n\t\t\t? 0\n\t\t\t: BITSET_WORD_BITS - ASCII_CHARS % BITSET_WORD_BITS);\n\t  for (i = ASCII_CHARS / BITSET_WORD_BITS; i < BITSET_WORDS; ++i)\n\t    {\n\t      if (dfa->nodes[node].opr.sbcset[i] >> rshift != 0)\n\t\treturn;\n\t      rshift = 0;\n\t    }\n\t}\n\tbreak;\n      default:\n\tabort ();\n      }\n\n  if (mb_chars || has_period)\n    for (node = 0; node < dfa->nodes_len; ++node)\n      {\n\tif (dfa->nodes[node].type == CHARACTER\n\t    && dfa->nodes[node].opr.c >= ASCII_CHARS)\n\t  dfa->nodes[node].mb_partial = 0;\n\telse if (dfa->nodes[node].type == OP_PERIOD)\n\t  dfa->nodes[node].type = OP_UTF8_PERIOD;\n      }\n\n  /* The search can be in single byte locale.  */\n  dfa->mb_cur_max = 1;\n  dfa->is_utf8 = 0;\n  dfa->has_mb_node = dfa->nbackref > 0 || has_period;\n}",
      "lines": 75,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "analyze": {
      "start_point": [
        1172,
        0
      ],
      "end_point": [
        1230,
        1
      ],
      "content": "static reg_errcode_t\nanalyze (regex_t *preg)\n{\n  re_dfa_t *dfa = preg->buffer;\n  reg_errcode_t ret;\n\n  /* Allocate arrays.  */\n  dfa->nexts = re_malloc (Idx, dfa->nodes_alloc);\n  dfa->org_indices = re_malloc (Idx, dfa->nodes_alloc);\n  dfa->edests = re_malloc (re_node_set, dfa->nodes_alloc);\n  dfa->eclosures = re_malloc (re_node_set, dfa->nodes_alloc);\n  if (BE (dfa->nexts == NULL || dfa->org_indices == NULL || dfa->edests == NULL\n\t  || dfa->eclosures == NULL, 0))\n    return REG_ESPACE;\n\n  dfa->subexp_map = re_malloc (Idx, preg->re_nsub);\n  if (dfa->subexp_map != NULL)\n    {\n      Idx i;\n      for (i = 0; i < preg->re_nsub; i++)\n\tdfa->subexp_map[i] = i;\n      preorder (dfa->str_tree, optimize_subexps, dfa);\n      for (i = 0; i < preg->re_nsub; i++)\n\tif (dfa->subexp_map[i] != i)\n\t  break;\n      if (i == preg->re_nsub)\n\t{\n\t  re_free (dfa->subexp_map);\n\t  dfa->subexp_map = NULL;\n\t}\n    }\n\n  ret = postorder (dfa->str_tree, lower_subexps, preg);\n  if (BE (ret != REG_NOERROR, 0))\n    return ret;\n  ret = postorder (dfa->str_tree, calc_first, dfa);\n  if (BE (ret != REG_NOERROR, 0))\n    return ret;\n  preorder (dfa->str_tree, calc_next, dfa);\n  ret = preorder (dfa->str_tree, link_nfa_nodes, dfa);\n  if (BE (ret != REG_NOERROR, 0))\n    return ret;\n  ret = calc_eclosure (dfa);\n  if (BE (ret != REG_NOERROR, 0))\n    return ret;\n\n  /* We only need this during the prune_impossible_nodes pass in regexec.c;\n     skip it if p_i_n will not run, as calc_inveclosure can be quadratic.  */\n  if ((!preg->no_sub && preg->re_nsub > 0 && dfa->has_plural_match)\n      || dfa->nbackref)\n    {\n      dfa->inveclosures = re_malloc (re_node_set, dfa->nodes_len);\n      if (BE (dfa->inveclosures == NULL, 0))\n\treturn REG_ESPACE;\n      ret = calc_inveclosure (dfa);\n    }\n\n  return ret;\n}",
      "lines": 59,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "postorder": {
      "start_point": [
        1235,
        0
      ],
      "end_point": [
        1265,
        1
      ],
      "content": "static reg_errcode_t\npostorder (bin_tree_t *root, reg_errcode_t (fn (void *, bin_tree_t *)),\n\t   void *extra)\n{\n  bin_tree_t *node, *prev;\n\n  for (node = root; ; )\n    {\n      /* Descend down the tree, preferably to the left (or to the right\n\t if that's the only child).  */\n      while (node->left || node->right)\n\tif (node->left)\n\t  node = node->left;\n\telse\n\t  node = node->right;\n\n      do\n\t{\n\t  reg_errcode_t err = fn (extra, node);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return err;\n\t  if (node->parent == NULL)\n\t    return REG_NOERROR;\n\t  prev = node;\n\t  node = node->parent;\n\t}\n      /* Go up while we have a node that is reached from the right.  */\n      while (node->right == prev || node->right == NULL);\n      node = node->right;\n    }\n}",
      "lines": 31,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "preorder": {
      "start_point": [
        1267,
        0
      ],
      "end_point": [
        1295,
        1
      ],
      "content": "static reg_errcode_t\npreorder (bin_tree_t *root, reg_errcode_t (fn (void *, bin_tree_t *)),\n\t  void *extra)\n{\n  bin_tree_t *node;\n\n  for (node = root; ; )\n    {\n      reg_errcode_t err = fn (extra, node);\n      if (BE (err != REG_NOERROR, 0))\n\treturn err;\n\n      /* Go to the left node, or up and to the right.  */\n      if (node->left)\n\tnode = node->left;\n      else\n\t{\n\t  bin_tree_t *prev = NULL;\n\t  while (node->right == prev || node->right == NULL)\n\t    {\n\t      prev = node;\n\t      node = node->parent;\n\t      if (!node)\n\t\treturn REG_NOERROR;\n\t    }\n\t  node = node->right;\n\t}\n    }\n}",
      "lines": 29,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "optimize_subexps": {
      "start_point": [
        1300,
        0
      ],
      "end_point": [
        1327,
        1
      ],
      "content": "static reg_errcode_t\noptimize_subexps (void *extra, bin_tree_t *node)\n{\n  re_dfa_t *dfa = (re_dfa_t *) extra;\n\n  if (node->token.type == OP_BACK_REF && dfa->subexp_map)\n    {\n      int idx = node->token.opr.idx;\n      node->token.opr.idx = dfa->subexp_map[idx];\n      dfa->used_bkref_map |= 1 << node->token.opr.idx;\n    }\n\n  else if (node->token.type == SUBEXP\n\t   && node->left && node->left->token.type == SUBEXP)\n    {\n      Idx other_idx = node->left->token.opr.idx;\n\n      node->left = node->left->left;\n      if (node->left)\n\tnode->left->parent = node;\n\n      dfa->subexp_map[other_idx] = dfa->subexp_map[node->token.opr.idx];\n      if (other_idx < BITSET_WORD_BITS)\n\tdfa->used_bkref_map &= ~((bitset_word_t) 1 << other_idx);\n    }\n\n  return REG_NOERROR;\n}",
      "lines": 28,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "lower_subexps": {
      "start_point": [
        1331,
        0
      ],
      "end_point": [
        1351,
        1
      ],
      "content": "static reg_errcode_t\nlower_subexps (void *extra, bin_tree_t *node)\n{\n  regex_t *preg = (regex_t *) extra;\n  reg_errcode_t err = REG_NOERROR;\n\n  if (node->left && node->left->token.type == SUBEXP)\n    {\n      node->left = lower_subexp (&err, preg, node->left);\n      if (node->left)\n\tnode->left->parent = node;\n    }\n  if (node->right && node->right->token.type == SUBEXP)\n    {\n      node->right = lower_subexp (&err, preg, node->right);\n      if (node->right)\n\tnode->right->parent = node;\n    }\n\n  return err;\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "lower_subexp": {
      "start_point": [
        1353,
        0
      ],
      "end_point": [
        1386,
        1
      ],
      "content": "static bin_tree_t *\nlower_subexp (reg_errcode_t *err, regex_t *preg, bin_tree_t *node)\n{\n  re_dfa_t *dfa = preg->buffer;\n  bin_tree_t *body = node->left;\n  bin_tree_t *op, *cls, *tree1, *tree;\n\n  if (preg->no_sub\n      /* We do not optimize empty subexpressions, because otherwise we may\n\t have bad CONCAT nodes with NULL children.  This is obviously not\n\t very common, so we do not lose much.  An example that triggers\n\t this case is the sed \"script\" /\\(\\)/x.  */\n      && node->left != NULL\n      && (node->token.opr.idx >= BITSET_WORD_BITS\n\t  || !(dfa->used_bkref_map\n\t       & ((bitset_word_t) 1 << node->token.opr.idx))))\n    return node->left;\n\n  /* Convert the SUBEXP node to the concatenation of an\n     OP_OPEN_SUBEXP, the contents, and an OP_CLOSE_SUBEXP.  */\n  op = create_tree (dfa, NULL, NULL, OP_OPEN_SUBEXP);\n  cls = create_tree (dfa, NULL, NULL, OP_CLOSE_SUBEXP);\n  tree1 = body ? create_tree (dfa, body, cls, CONCAT) : cls;\n  tree = create_tree (dfa, op, tree1, CONCAT);\n  if (BE (tree == NULL || tree1 == NULL || op == NULL || cls == NULL, 0))\n    {\n      *err = REG_ESPACE;\n      return NULL;\n    }\n\n  op->token.opr.idx = cls->token.opr.idx = node->token.opr.idx;\n  op->token.opt_subexp = cls->token.opt_subexp = node->token.opt_subexp;\n  return tree;\n}",
      "lines": 34,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\nlower_subexp (reg_errcode_t *err, regex_t *preg, bin_tree_t *node)",
        "*"
      ]
    },
    "calc_first": {
      "start_point": [
        1390,
        0
      ],
      "end_point": [
        1409,
        1
      ],
      "content": "static reg_errcode_t\ncalc_first (void *extra, bin_tree_t *node)\n{\n  re_dfa_t *dfa = (re_dfa_t *) extra;\n  if (node->token.type == CONCAT)\n    {\n      node->first = node->left->first;\n      node->node_idx = node->left->node_idx;\n    }\n  else\n    {\n      node->first = node;\n      node->node_idx = re_dfa_add_node (dfa, node->token);\n      if (BE (node->node_idx == -1, 0))\n\treturn REG_ESPACE;\n      if (node->token.type == ANCHOR)\n\tdfa->nodes[node->node_idx].constraint = node->token.opr.ctx_type;\n    }\n  return REG_NOERROR;\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "calc_next": {
      "start_point": [
        1412,
        0
      ],
      "end_point": [
        1432,
        1
      ],
      "content": "static reg_errcode_t\ncalc_next (void *extra, bin_tree_t *node)\n{\n  switch (node->token.type)\n    {\n    case OP_DUP_ASTERISK:\n      node->left->next = node;\n      break;\n    case CONCAT:\n      node->left->next = node->right->first;\n      node->right->next = node->next;\n      break;\n    default:\n      if (node->left)\n\tnode->left->next = node->next;\n      if (node->right)\n\tnode->right->next = node->next;\n      break;\n    }\n  return REG_NOERROR;\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "link_nfa_nodes": {
      "start_point": [
        1435,
        0
      ],
      "end_point": [
        1489,
        1
      ],
      "content": "static reg_errcode_t\nlink_nfa_nodes (void *extra, bin_tree_t *node)\n{\n  re_dfa_t *dfa = (re_dfa_t *) extra;\n  Idx idx = node->node_idx;\n  reg_errcode_t err = REG_NOERROR;\n\n  switch (node->token.type)\n    {\n    case CONCAT:\n      break;\n\n    case END_OF_RE:\n      assert (node->next == NULL);\n      break;\n\n    case OP_DUP_ASTERISK:\n    case OP_ALT:\n      {\n\tIdx left, right;\n\tdfa->has_plural_match = 1;\n\tif (node->left != NULL)\n\t  left = node->left->first->node_idx;\n\telse\n\t  left = node->next->node_idx;\n\tif (node->right != NULL)\n\t  right = node->right->first->node_idx;\n\telse\n\t  right = node->next->node_idx;\n\tassert (left > -1);\n\tassert (right > -1);\n\terr = re_node_set_init_2 (dfa->edests + idx, left, right);\n      }\n      break;\n\n    case ANCHOR:\n    case OP_OPEN_SUBEXP:\n    case OP_CLOSE_SUBEXP:\n      err = re_node_set_init_1 (dfa->edests + idx, node->next->node_idx);\n      break;\n\n    case OP_BACK_REF:\n      dfa->nexts[idx] = node->next->node_idx;\n      if (node->token.type == OP_BACK_REF)\n\terr = re_node_set_init_1 (dfa->edests + idx, dfa->nexts[idx]);\n      break;\n\n    default:\n      assert (!IS_EPSILON_NODE (node->token.type));\n      dfa->nexts[idx] = node->next->node_idx;\n      break;\n    }\n\n  return err;\n}",
      "lines": 55,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "duplicate_node_closure": {
      "start_point": [
        1495,
        0
      ],
      "end_point": [
        1597,
        1
      ],
      "content": "static reg_errcode_t\nduplicate_node_closure (re_dfa_t *dfa, Idx top_org_node, Idx top_clone_node,\n\t\t\tIdx root_node, unsigned int init_constraint)\n{\n  Idx org_node, clone_node;\n  bool ok;\n  unsigned int constraint = init_constraint;\n  for (org_node = top_org_node, clone_node = top_clone_node;;)\n    {\n      Idx org_dest, clone_dest;\n      if (dfa->nodes[org_node].type == OP_BACK_REF)\n\t{\n\t  /* If the back reference epsilon-transit, its destination must\n\t     also have the constraint.  Then duplicate the epsilon closure\n\t     of the destination of the back reference, and store it in\n\t     edests of the back reference.  */\n\t  org_dest = dfa->nexts[org_node];\n\t  re_node_set_empty (dfa->edests + clone_node);\n\t  clone_dest = duplicate_node (dfa, org_dest, constraint);\n\t  if (BE (clone_dest == -1, 0))\n\t    return REG_ESPACE;\n\t  dfa->nexts[clone_node] = dfa->nexts[org_node];\n\t  ok = re_node_set_insert (dfa->edests + clone_node, clone_dest);\n\t  if (BE (! ok, 0))\n\t    return REG_ESPACE;\n\t}\n      else if (dfa->edests[org_node].nelem == 0)\n\t{\n\t  /* In case of the node can't epsilon-transit, don't duplicate the\n\t     destination and store the original destination as the\n\t     destination of the node.  */\n\t  dfa->nexts[clone_node] = dfa->nexts[org_node];\n\t  break;\n\t}\n      else if (dfa->edests[org_node].nelem == 1)\n\t{\n\t  /* In case of the node can epsilon-transit, and it has only one\n\t     destination.  */\n\t  org_dest = dfa->edests[org_node].elems[0];\n\t  re_node_set_empty (dfa->edests + clone_node);\n\t  /* If the node is root_node itself, it means the epsilon closure\n\t     has a loop.  Then tie it to the destination of the root_node.  */\n\t  if (org_node == root_node && clone_node != org_node)\n\t    {\n\t      ok = re_node_set_insert (dfa->edests + clone_node, org_dest);\n\t      if (BE (! ok, 0))\n\t        return REG_ESPACE;\n\t      break;\n\t    }\n\t  /* In case the node has another constraint, append it.  */\n\t  constraint |= dfa->nodes[org_node].constraint;\n\t  clone_dest = duplicate_node (dfa, org_dest, constraint);\n\t  if (BE (clone_dest == -1, 0))\n\t    return REG_ESPACE;\n\t  ok = re_node_set_insert (dfa->edests + clone_node, clone_dest);\n\t  if (BE (! ok, 0))\n\t    return REG_ESPACE;\n\t}\n      else /* dfa->edests[org_node].nelem == 2 */\n\t{\n\t  /* In case of the node can epsilon-transit, and it has two\n\t     destinations. In the bin_tree_t and DFA, that's '|' and '*'.   */\n\t  org_dest = dfa->edests[org_node].elems[0];\n\t  re_node_set_empty (dfa->edests + clone_node);\n\t  /* Search for a duplicated node which satisfies the constraint.  */\n\t  clone_dest = search_duplicated_node (dfa, org_dest, constraint);\n\t  if (clone_dest == -1)\n\t    {\n\t      /* There is no such duplicated node, create a new one.  */\n\t      reg_errcode_t err;\n\t      clone_dest = duplicate_node (dfa, org_dest, constraint);\n\t      if (BE (clone_dest == -1, 0))\n\t\treturn REG_ESPACE;\n\t      ok = re_node_set_insert (dfa->edests + clone_node, clone_dest);\n\t      if (BE (! ok, 0))\n\t\treturn REG_ESPACE;\n\t      err = duplicate_node_closure (dfa, org_dest, clone_dest,\n\t\t\t\t\t    root_node, constraint);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\treturn err;\n\t    }\n\t  else\n\t    {\n\t      /* There is a duplicated node which satisfies the constraint,\n\t\t use it to avoid infinite loop.  */\n\t      ok = re_node_set_insert (dfa->edests + clone_node, clone_dest);\n\t      if (BE (! ok, 0))\n\t\treturn REG_ESPACE;\n\t    }\n\n\t  org_dest = dfa->edests[org_node].elems[1];\n\t  clone_dest = duplicate_node (dfa, org_dest, constraint);\n\t  if (BE (clone_dest == -1, 0))\n\t    return REG_ESPACE;\n\t  ok = re_node_set_insert (dfa->edests + clone_node, clone_dest);\n\t  if (BE (! ok, 0))\n\t    return REG_ESPACE;\n\t}\n      org_node = org_dest;\n      clone_node = clone_dest;\n    }\n  return REG_NOERROR;\n}",
      "lines": 103,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "search_duplicated_node": {
      "start_point": [
        1602,
        0
      ],
      "end_point": [
        1614,
        1
      ],
      "content": "static Idx\nsearch_duplicated_node (const re_dfa_t *dfa, Idx org_node,\n\t\t\tunsigned int constraint)\n{\n  Idx idx;\n  for (idx = dfa->nodes_len - 1; dfa->nodes[idx].duplicated && idx > 0; --idx)\n    {\n      if (org_node == dfa->org_indices[idx]\n\t  && constraint == dfa->nodes[idx].constraint)\n\treturn idx; /* Found.  */\n    }\n  return -1; /* Not found.  */\n}",
      "lines": 13,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "Idx"
      ]
    },
    "duplicate_node": {
      "start_point": [
        1620,
        0
      ],
      "end_point": [
        1634,
        1
      ],
      "content": "static Idx\nduplicate_node (re_dfa_t *dfa, Idx org_idx, unsigned int constraint)\n{\n  Idx dup_idx = re_dfa_add_node (dfa, dfa->nodes[org_idx]);\n  if (BE (dup_idx != -1, 1))\n    {\n      dfa->nodes[dup_idx].constraint = constraint;\n      dfa->nodes[dup_idx].constraint |= dfa->nodes[org_idx].constraint;\n      dfa->nodes[dup_idx].duplicated = 1;\n\n      /* Store the index of the original node.  */\n      dfa->org_indices[dup_idx] = org_idx;\n    }\n  return dup_idx;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "Idx"
      ]
    },
    "calc_inveclosure": {
      "start_point": [
        1636,
        0
      ],
      "end_point": [
        1656,
        1
      ],
      "content": "static reg_errcode_t\ncalc_inveclosure (re_dfa_t *dfa)\n{\n  Idx src, idx;\n  bool ok;\n  for (idx = 0; idx < dfa->nodes_len; ++idx)\n    re_node_set_init_empty (dfa->inveclosures + idx);\n\n  for (src = 0; src < dfa->nodes_len; ++src)\n    {\n      Idx *elems = dfa->eclosures[src].elems;\n      for (idx = 0; idx < dfa->eclosures[src].nelem; ++idx)\n\t{\n\t  ok = re_node_set_insert_last (dfa->inveclosures + elems[idx], src);\n\t  if (BE (! ok, 0))\n\t    return REG_ESPACE;\n\t}\n    }\n\n  return REG_NOERROR;\n}",
      "lines": 21,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "calc_eclosure": {
      "start_point": [
        1660,
        0
      ],
      "end_point": [
        1701,
        1
      ],
      "content": "static reg_errcode_t\ncalc_eclosure (re_dfa_t *dfa)\n{\n  Idx node_idx;\n  bool incomplete;\n#ifdef DEBUG\n  assert (dfa->nodes_len > 0);\n#endif\n  incomplete = false;\n  /* For each nodes, calculate epsilon closure.  */\n  for (node_idx = 0; ; ++node_idx)\n    {\n      reg_errcode_t err;\n      re_node_set eclosure_elem;\n      if (node_idx == dfa->nodes_len)\n\t{\n\t  if (!incomplete)\n\t    break;\n\t  incomplete = false;\n\t  node_idx = 0;\n\t}\n\n#ifdef DEBUG\n      assert (dfa->eclosures[node_idx].nelem != -1);\n#endif\n\n      /* If we have already calculated, skip it.  */\n      if (dfa->eclosures[node_idx].nelem != 0)\n\tcontinue;\n      /* Calculate epsilon closure of 'node_idx'.  */\n      err = calc_eclosure_iter (&eclosure_elem, dfa, node_idx, true);\n      if (BE (err != REG_NOERROR, 0))\n\treturn err;\n\n      if (dfa->eclosures[node_idx].nelem == 0)\n\t{\n\t  incomplete = true;\n\t  re_node_set_free (&eclosure_elem);\n\t}\n    }\n  return REG_NOERROR;\n}",
      "lines": 42,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "calc_eclosure_iter": {
      "start_point": [
        1705,
        0
      ],
      "end_point": [
        1779,
        1
      ],
      "content": "static reg_errcode_t\ncalc_eclosure_iter (re_node_set *new_set, re_dfa_t *dfa, Idx node, bool root)\n{\n  reg_errcode_t err;\n  Idx i;\n  re_node_set eclosure;\n  bool ok;\n  bool incomplete = false;\n  err = re_node_set_alloc (&eclosure, dfa->edests[node].nelem + 1);\n  if (BE (err != REG_NOERROR, 0))\n    return err;\n\n  /* This indicates that we are calculating this node now.\n     We reference this value to avoid infinite loop.  */\n  dfa->eclosures[node].nelem = -1;\n\n  /* If the current node has constraints, duplicate all nodes\n     since they must inherit the constraints.  */\n  if (dfa->nodes[node].constraint\n      && dfa->edests[node].nelem\n      && !dfa->nodes[dfa->edests[node].elems[0]].duplicated)\n    {\n      err = duplicate_node_closure (dfa, node, node, node,\n\t\t\t\t    dfa->nodes[node].constraint);\n      if (BE (err != REG_NOERROR, 0))\n\treturn err;\n    }\n\n  /* Expand each epsilon destination nodes.  */\n  if (IS_EPSILON_NODE(dfa->nodes[node].type))\n    for (i = 0; i < dfa->edests[node].nelem; ++i)\n      {\n\tre_node_set eclosure_elem;\n\tIdx edest = dfa->edests[node].elems[i];\n\t/* If calculating the epsilon closure of 'edest' is in progress,\n\t   return intermediate result.  */\n\tif (dfa->eclosures[edest].nelem == -1)\n\t  {\n\t    incomplete = true;\n\t    continue;\n\t  }\n\t/* If we haven't calculated the epsilon closure of 'edest' yet,\n\t   calculate now. Otherwise use calculated epsilon closure.  */\n\tif (dfa->eclosures[edest].nelem == 0)\n\t  {\n\t    err = calc_eclosure_iter (&eclosure_elem, dfa, edest, false);\n\t    if (BE (err != REG_NOERROR, 0))\n\t      return err;\n\t  }\n\telse\n\t  eclosure_elem = dfa->eclosures[edest];\n\t/* Merge the epsilon closure of 'edest'.  */\n\terr = re_node_set_merge (&eclosure, &eclosure_elem);\n\tif (BE (err != REG_NOERROR, 0))\n\t  return err;\n\t/* If the epsilon closure of 'edest' is incomplete,\n\t   the epsilon closure of this node is also incomplete.  */\n\tif (dfa->eclosures[edest].nelem == 0)\n\t  {\n\t    incomplete = true;\n\t    re_node_set_free (&eclosure_elem);\n\t  }\n      }\n\n  /* An epsilon closure includes itself.  */\n  ok = re_node_set_insert (&eclosure, node);\n  if (BE (! ok, 0))\n    return REG_ESPACE;\n  if (incomplete && !root)\n    dfa->eclosures[node].nelem = 0;\n  else\n    dfa->eclosures[node] = eclosure;\n  *new_set = eclosure;\n  return REG_NOERROR;\n}",
      "lines": 75,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "fetch_token": {
      "start_point": [
        1786,
        0
      ],
      "end_point": [
        1790,
        1
      ],
      "content": "static void\nfetch_token (re_token_t *result, re_string_t *input, reg_syntax_t syntax)\n{\n  re_string_skip_bytes (input, peek_token (result, input, syntax));\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "peek_token": {
      "start_point": [
        1795,
        0
      ],
      "end_point": [
        2028,
        1
      ],
      "content": "static int\npeek_token (re_token_t *token, re_string_t *input, reg_syntax_t syntax)\n{\n  unsigned char c;\n\n  if (re_string_eoi (input))\n    {\n      token->type = END_OF_RE;\n      return 0;\n    }\n\n  c = re_string_peek_byte (input, 0);\n  token->opr.c = c;\n\n  token->word_char = 0;\n#ifdef RE_ENABLE_I18N\n  token->mb_partial = 0;\n  if (input->mb_cur_max > 1 &&\n      !re_string_first_byte (input, re_string_cur_idx (input)))\n    {\n      token->type = CHARACTER;\n      token->mb_partial = 1;\n      return 1;\n    }\n#endif\n  if (c == '\\\\')\n    {\n      unsigned char c2;\n      if (re_string_cur_idx (input) + 1 >= re_string_length (input))\n\t{\n\t  token->type = BACK_SLASH;\n\t  return 1;\n\t}\n\n      c2 = re_string_peek_byte_case (input, 1);\n      token->opr.c = c2;\n      token->type = CHARACTER;\n#ifdef RE_ENABLE_I18N\n      if (input->mb_cur_max > 1)\n\t{\n\t  wint_t wc = re_string_wchar_at (input,\n\t\t\t\t\t  re_string_cur_idx (input) + 1);\n\t  token->word_char = IS_WIDE_WORD_CHAR (wc) != 0;\n\t}\n      else\n#endif\n\ttoken->word_char = IS_WORD_CHAR (c2) != 0;\n\n      switch (c2)\n\t{\n\tcase '|':\n\t  if (!(syntax & RE_LIMITED_OPS) && !(syntax & RE_NO_BK_VBAR))\n\t    token->type = OP_ALT;\n\t  break;\n\tcase '1': case '2': case '3': case '4': case '5':\n\tcase '6': case '7': case '8': case '9':\n\t  if (!(syntax & RE_NO_BK_REFS))\n\t    {\n\t      token->type = OP_BACK_REF;\n\t      token->opr.idx = c2 - '1';\n\t    }\n\t  break;\n\tcase '<':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    {\n\t      token->type = ANCHOR;\n\t      token->opr.ctx_type = WORD_FIRST;\n\t    }\n\t  break;\n\tcase '>':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    {\n\t      token->type = ANCHOR;\n\t      token->opr.ctx_type = WORD_LAST;\n\t    }\n\t  break;\n\tcase 'b':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    {\n\t      token->type = ANCHOR;\n\t      token->opr.ctx_type = WORD_DELIM;\n\t    }\n\t  break;\n\tcase 'B':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    {\n\t      token->type = ANCHOR;\n\t      token->opr.ctx_type = NOT_WORD_DELIM;\n\t    }\n\t  break;\n\tcase 'w':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    token->type = OP_WORD;\n\t  break;\n\tcase 'W':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    token->type = OP_NOTWORD;\n\t  break;\n\tcase 's':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    token->type = OP_SPACE;\n\t  break;\n\tcase 'S':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    token->type = OP_NOTSPACE;\n\t  break;\n\tcase '`':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    {\n\t      token->type = ANCHOR;\n\t      token->opr.ctx_type = BUF_FIRST;\n\t    }\n\t  break;\n\tcase '\\'':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    {\n\t      token->type = ANCHOR;\n\t      token->opr.ctx_type = BUF_LAST;\n\t    }\n\t  break;\n\tcase '(':\n\t  if (!(syntax & RE_NO_BK_PARENS))\n\t    token->type = OP_OPEN_SUBEXP;\n\t  break;\n\tcase ')':\n\t  if (!(syntax & RE_NO_BK_PARENS))\n\t    token->type = OP_CLOSE_SUBEXP;\n\t  break;\n\tcase '+':\n\t  if (!(syntax & RE_LIMITED_OPS) && (syntax & RE_BK_PLUS_QM))\n\t    token->type = OP_DUP_PLUS;\n\t  break;\n\tcase '?':\n\t  if (!(syntax & RE_LIMITED_OPS) && (syntax & RE_BK_PLUS_QM))\n\t    token->type = OP_DUP_QUESTION;\n\t  break;\n\tcase '{':\n\t  if ((syntax & RE_INTERVALS) && (!(syntax & RE_NO_BK_BRACES)))\n\t    token->type = OP_OPEN_DUP_NUM;\n\t  break;\n\tcase '}':\n\t  if ((syntax & RE_INTERVALS) && (!(syntax & RE_NO_BK_BRACES)))\n\t    token->type = OP_CLOSE_DUP_NUM;\n\t  break;\n\tdefault:\n\t  break;\n\t}\n      return 2;\n    }\n\n  token->type = CHARACTER;\n#ifdef RE_ENABLE_I18N\n  if (input->mb_cur_max > 1)\n    {\n      wint_t wc = re_string_wchar_at (input, re_string_cur_idx (input));\n      token->word_char = IS_WIDE_WORD_CHAR (wc) != 0;\n    }\n  else\n#endif\n    token->word_char = IS_WORD_CHAR (token->opr.c);\n\n  switch (c)\n    {\n    case '\\n':\n      if (syntax & RE_NEWLINE_ALT)\n\ttoken->type = OP_ALT;\n      break;\n    case '|':\n      if (!(syntax & RE_LIMITED_OPS) && (syntax & RE_NO_BK_VBAR))\n\ttoken->type = OP_ALT;\n      break;\n    case '*':\n      token->type = OP_DUP_ASTERISK;\n      break;\n    case '+':\n      if (!(syntax & RE_LIMITED_OPS) && !(syntax & RE_BK_PLUS_QM))\n\ttoken->type = OP_DUP_PLUS;\n      break;\n    case '?':\n      if (!(syntax & RE_LIMITED_OPS) && !(syntax & RE_BK_PLUS_QM))\n\ttoken->type = OP_DUP_QUESTION;\n      break;\n    case '{':\n      if ((syntax & RE_INTERVALS) && (syntax & RE_NO_BK_BRACES))\n\ttoken->type = OP_OPEN_DUP_NUM;\n      break;\n    case '}':\n      if ((syntax & RE_INTERVALS) && (syntax & RE_NO_BK_BRACES))\n\ttoken->type = OP_CLOSE_DUP_NUM;\n      break;\n    case '(':\n      if (syntax & RE_NO_BK_PARENS)\n\ttoken->type = OP_OPEN_SUBEXP;\n      break;\n    case ')':\n      if (syntax & RE_NO_BK_PARENS)\n\ttoken->type = OP_CLOSE_SUBEXP;\n      break;\n    case '[':\n      token->type = OP_OPEN_BRACKET;\n      break;\n    case '.':\n      token->type = OP_PERIOD;\n      break;\n    case '^':\n      if (!(syntax & (RE_CONTEXT_INDEP_ANCHORS | RE_CARET_ANCHORS_HERE)) &&\n\t  re_string_cur_idx (input) != 0)\n\t{\n\t  char prev = re_string_peek_byte (input, -1);\n\t  if (!(syntax & RE_NEWLINE_ALT) || prev != '\\n')\n\t    break;\n\t}\n      token->type = ANCHOR;\n      token->opr.ctx_type = LINE_FIRST;\n      break;\n    case '$':\n      if (!(syntax & RE_CONTEXT_INDEP_ANCHORS) &&\n\t  re_string_cur_idx (input) + 1 != re_string_length (input))\n\t{\n\t  re_token_t next;\n\t  re_string_skip_bytes (input, 1);\n\t  peek_token (&next, input, syntax);\n\t  re_string_skip_bytes (input, -1);\n\t  if (next.type != OP_ALT && next.type != OP_CLOSE_SUBEXP)\n\t    break;\n\t}\n      token->type = ANCHOR;\n      token->opr.ctx_type = LINE_LAST;\n      break;\n    default:\n      break;\n    }\n  return 1;\n}",
      "lines": 234,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "peek_token_bracket": {
      "start_point": [
        2033,
        0
      ],
      "end_point": [
        2115,
        1
      ],
      "content": "static int\npeek_token_bracket (re_token_t *token, re_string_t *input, reg_syntax_t syntax)\n{\n  unsigned char c;\n  if (re_string_eoi (input))\n    {\n      token->type = END_OF_RE;\n      return 0;\n    }\n  c = re_string_peek_byte (input, 0);\n  token->opr.c = c;\n\n#ifdef RE_ENABLE_I18N\n  if (input->mb_cur_max > 1 &&\n      !re_string_first_byte (input, re_string_cur_idx (input)))\n    {\n      token->type = CHARACTER;\n      return 1;\n    }\n#endif /* RE_ENABLE_I18N */\n\n  if (c == '\\\\' && (syntax & RE_BACKSLASH_ESCAPE_IN_LISTS)\n      && re_string_cur_idx (input) + 1 < re_string_length (input))\n    {\n      /* In this case, '\\' escape a character.  */\n      unsigned char c2;\n      re_string_skip_bytes (input, 1);\n      c2 = re_string_peek_byte (input, 0);\n      token->opr.c = c2;\n      token->type = CHARACTER;\n      return 1;\n    }\n  if (c == '[') /* '[' is a special char in a bracket exps.  */\n    {\n      unsigned char c2;\n      int token_len;\n      if (re_string_cur_idx (input) + 1 < re_string_length (input))\n\tc2 = re_string_peek_byte (input, 1);\n      else\n\tc2 = 0;\n      token->opr.c = c2;\n      token_len = 2;\n      switch (c2)\n\t{\n\tcase '.':\n\t  token->type = OP_OPEN_COLL_ELEM;\n\t  break;\n\n\tcase '=':\n\t  token->type = OP_OPEN_EQUIV_CLASS;\n\t  break;\n\n\tcase ':':\n\t  if (syntax & RE_CHAR_CLASSES)\n\t    {\n\t      token->type = OP_OPEN_CHAR_CLASS;\n\t      break;\n\t    }\n\t  FALLTHROUGH;\n\tdefault:\n\t  token->type = CHARACTER;\n\t  token->opr.c = c;\n\t  token_len = 1;\n\t  break;\n\t}\n      return token_len;\n    }\n  switch (c)\n    {\n    case '-':\n      token->type = OP_CHARSET_RANGE;\n      break;\n    case ']':\n      token->type = OP_CLOSE_BRACKET;\n      break;\n    case '^':\n      token->type = OP_NON_MATCH_LIST;\n      break;\n    default:\n      token->type = CHARACTER;\n    }\n  return 1;\n}",
      "lines": 83,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "parse": {
      "start_point": [
        2131,
        0
      ],
      "end_point": [
        2154,
        1
      ],
      "content": "static bin_tree_t *\nparse (re_string_t *regexp, regex_t *preg, reg_syntax_t syntax,\n       reg_errcode_t *err)\n{\n  re_dfa_t *dfa = preg->buffer;\n  bin_tree_t *tree, *eor, *root;\n  re_token_t current_token;\n  dfa->syntax = syntax;\n  fetch_token (&current_token, regexp, syntax | RE_CARET_ANCHORS_HERE);\n  tree = parse_reg_exp (regexp, preg, &current_token, syntax, 0, err);\n  if (BE (*err != REG_NOERROR && tree == NULL, 0))\n    return NULL;\n  eor = create_tree (dfa, NULL, NULL, END_OF_RE);\n  if (tree != NULL)\n    root = create_tree (dfa, tree, eor, CONCAT);\n  else\n    root = eor;\n  if (BE (eor == NULL || root == NULL, 0))\n    {\n      *err = REG_ESPACE;\n      return NULL;\n    }\n  return root;\n}",
      "lines": 24,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\nparse (re_string_t *regexp, regex_t *preg, reg_syntax_t syntax,\n       reg_errcode_t *err)",
        "*"
      ]
    },
    "parse_reg_exp": {
      "start_point": [
        2165,
        0
      ],
      "end_point": [
        2203,
        1
      ],
      "content": "static bin_tree_t *\nparse_reg_exp (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t       reg_syntax_t syntax, Idx nest, reg_errcode_t *err)\n{\n  re_dfa_t *dfa = preg->buffer;\n  bin_tree_t *tree, *branch = NULL;\n  bitset_word_t initial_bkref_map = dfa->completed_bkref_map;\n  tree = parse_branch (regexp, preg, token, syntax, nest, err);\n  if (BE (*err != REG_NOERROR && tree == NULL, 0))\n    return NULL;\n\n  while (token->type == OP_ALT)\n    {\n      fetch_token (token, regexp, syntax | RE_CARET_ANCHORS_HERE);\n      if (token->type != OP_ALT && token->type != END_OF_RE\n\t  && (nest == 0 || token->type != OP_CLOSE_SUBEXP))\n\t{\n\t  bitset_word_t accumulated_bkref_map = dfa->completed_bkref_map;\n\t  dfa->completed_bkref_map = initial_bkref_map;\n\t  branch = parse_branch (regexp, preg, token, syntax, nest, err);\n\t  if (BE (*err != REG_NOERROR && branch == NULL, 0))\n\t    {\n\t      if (tree != NULL)\n\t\tpostorder (tree, free_tree, NULL);\n\t      return NULL;\n\t    }\n\t  dfa->completed_bkref_map |= accumulated_bkref_map;\n\t}\n      else\n\tbranch = NULL;\n      tree = create_tree (dfa, tree, branch, OP_ALT);\n      if (BE (tree == NULL, 0))\n\t{\n\t  *err = REG_ESPACE;\n\t  return NULL;\n\t}\n    }\n  return tree;\n}",
      "lines": 39,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\nparse_reg_exp (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t       reg_syntax_t syntax, Idx nest, reg_errcode_t *err)",
        "*"
      ]
    },
    "parse_branch": {
      "start_point": [
        2214,
        0
      ],
      "end_point": [
        2251,
        1
      ],
      "content": "static bin_tree_t *\nparse_branch (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t      reg_syntax_t syntax, Idx nest, reg_errcode_t *err)\n{\n  bin_tree_t *tree, *expr;\n  re_dfa_t *dfa = preg->buffer;\n  tree = parse_expression (regexp, preg, token, syntax, nest, err);\n  if (BE (*err != REG_NOERROR && tree == NULL, 0))\n    return NULL;\n\n  while (token->type != OP_ALT && token->type != END_OF_RE\n\t && (nest == 0 || token->type != OP_CLOSE_SUBEXP))\n    {\n      expr = parse_expression (regexp, preg, token, syntax, nest, err);\n      if (BE (*err != REG_NOERROR && expr == NULL, 0))\n\t{\n\t  if (tree != NULL)\n\t    postorder (tree, free_tree, NULL);\n\t  return NULL;\n\t}\n      if (tree != NULL && expr != NULL)\n\t{\n\t  bin_tree_t *newtree = create_tree (dfa, tree, expr, CONCAT);\n\t  if (newtree == NULL)\n\t    {\n\t      postorder (expr, free_tree, NULL);\n\t      postorder (tree, free_tree, NULL);\n\t      *err = REG_ESPACE;\n\t      return NULL;\n\t    }\n\t  tree = newtree;\n\t}\n      else if (tree == NULL)\n\ttree = expr;\n      /* Otherwise expr == NULL, we don't need to create new tree.  */\n    }\n  return tree;\n}",
      "lines": 38,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\nparse_branch (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t      reg_syntax_t syntax, Idx nest, reg_errcode_t *err)",
        "*"
      ]
    },
    "parse_expression": {
      "start_point": [
        2259,
        0
      ],
      "end_point": [
        2485,
        1
      ],
      "content": "static bin_tree_t *\nparse_expression (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t\t  reg_syntax_t syntax, Idx nest, reg_errcode_t *err)\n{\n  re_dfa_t *dfa = preg->buffer;\n  bin_tree_t *tree;\n  switch (token->type)\n    {\n    case CHARACTER:\n      tree = create_token_tree (dfa, NULL, NULL, token);\n      if (BE (tree == NULL, 0))\n\t{\n\t  *err = REG_ESPACE;\n\t  return NULL;\n\t}\n#ifdef RE_ENABLE_I18N\n      if (dfa->mb_cur_max > 1)\n\t{\n\t  while (!re_string_eoi (regexp)\n\t\t && !re_string_first_byte (regexp, re_string_cur_idx (regexp)))\n\t    {\n\t      bin_tree_t *mbc_remain;\n\t      fetch_token (token, regexp, syntax);\n\t      mbc_remain = create_token_tree (dfa, NULL, NULL, token);\n\t      tree = create_tree (dfa, tree, mbc_remain, CONCAT);\n\t      if (BE (mbc_remain == NULL || tree == NULL, 0))\n\t\t{\n\t\t  *err = REG_ESPACE;\n\t\t  return NULL;\n\t\t}\n\t    }\n\t}\n#endif\n      break;\n\n    case OP_OPEN_SUBEXP:\n      tree = parse_sub_exp (regexp, preg, token, syntax, nest + 1, err);\n      if (BE (*err != REG_NOERROR && tree == NULL, 0))\n\treturn NULL;\n      break;\n\n    case OP_OPEN_BRACKET:\n      tree = parse_bracket_exp (regexp, dfa, token, syntax, err);\n      if (BE (*err != REG_NOERROR && tree == NULL, 0))\n\treturn NULL;\n      break;\n\n    case OP_BACK_REF:\n      if (!BE (dfa->completed_bkref_map & (1 << token->opr.idx), 1))\n\t{\n\t  *err = REG_ESUBREG;\n\t  return NULL;\n\t}\n      dfa->used_bkref_map |= 1 << token->opr.idx;\n      tree = create_token_tree (dfa, NULL, NULL, token);\n      if (BE (tree == NULL, 0))\n\t{\n\t  *err = REG_ESPACE;\n\t  return NULL;\n\t}\n      ++dfa->nbackref;\n      dfa->has_mb_node = 1;\n      break;\n\n    case OP_OPEN_DUP_NUM:\n      if (syntax & RE_CONTEXT_INVALID_DUP)\n\t{\n\t  *err = REG_BADRPT;\n\t  return NULL;\n\t}\n      FALLTHROUGH;\n    case OP_DUP_ASTERISK:\n    case OP_DUP_PLUS:\n    case OP_DUP_QUESTION:\n      if (syntax & RE_CONTEXT_INVALID_OPS)\n\t{\n\t  *err = REG_BADRPT;\n\t  return NULL;\n\t}\n      else if (syntax & RE_CONTEXT_INDEP_OPS)\n\t{\n\t  fetch_token (token, regexp, syntax);\n\t  return parse_expression (regexp, preg, token, syntax, nest, err);\n\t}\n      FALLTHROUGH;\n    case OP_CLOSE_SUBEXP:\n      if ((token->type == OP_CLOSE_SUBEXP) &&\n\t  !(syntax & RE_UNMATCHED_RIGHT_PAREN_ORD))\n\t{\n\t  *err = REG_ERPAREN;\n\t  return NULL;\n\t}\n      FALLTHROUGH;\n    case OP_CLOSE_DUP_NUM:\n      /* We treat it as a normal character.  */\n\n      /* Then we can these characters as normal characters.  */\n      token->type = CHARACTER;\n      /* mb_partial and word_char bits should be initialized already\n\t by peek_token.  */\n      tree = create_token_tree (dfa, NULL, NULL, token);\n      if (BE (tree == NULL, 0))\n\t{\n\t  *err = REG_ESPACE;\n\t  return NULL;\n\t}\n      break;\n\n    case ANCHOR:\n      if ((token->opr.ctx_type\n\t   & (WORD_DELIM | NOT_WORD_DELIM | WORD_FIRST | WORD_LAST))\n\t  && dfa->word_ops_used == 0)\n\tinit_word_char (dfa);\n      if (token->opr.ctx_type == WORD_DELIM\n\t  || token->opr.ctx_type == NOT_WORD_DELIM)\n\t{\n\t  bin_tree_t *tree_first, *tree_last;\n\t  if (token->opr.ctx_type == WORD_DELIM)\n\t    {\n\t      token->opr.ctx_type = WORD_FIRST;\n\t      tree_first = create_token_tree (dfa, NULL, NULL, token);\n\t      token->opr.ctx_type = WORD_LAST;\n\t    }\n\t  else\n\t    {\n\t      token->opr.ctx_type = INSIDE_WORD;\n\t      tree_first = create_token_tree (dfa, NULL, NULL, token);\n\t      token->opr.ctx_type = INSIDE_NOTWORD;\n\t    }\n\t  tree_last = create_token_tree (dfa, NULL, NULL, token);\n\t  tree = create_tree (dfa, tree_first, tree_last, OP_ALT);\n\t  if (BE (tree_first == NULL || tree_last == NULL || tree == NULL, 0))\n\t    {\n\t      *err = REG_ESPACE;\n\t      return NULL;\n\t    }\n\t}\n      else\n\t{\n\t  tree = create_token_tree (dfa, NULL, NULL, token);\n\t  if (BE (tree == NULL, 0))\n\t    {\n\t      *err = REG_ESPACE;\n\t      return NULL;\n\t    }\n\t}\n      /* We must return here, since ANCHORs can't be followed\n\t by repetition operators.\n\t eg. RE\"^*\" is invalid or \"<ANCHOR(^)><CHAR(*)>\",\n\t     it must not be \"<ANCHOR(^)><REPEAT(*)>\".  */\n      fetch_token (token, regexp, syntax);\n      return tree;\n\n    case OP_PERIOD:\n      tree = create_token_tree (dfa, NULL, NULL, token);\n      if (BE (tree == NULL, 0))\n\t{\n\t  *err = REG_ESPACE;\n\t  return NULL;\n\t}\n      if (dfa->mb_cur_max > 1)\n\tdfa->has_mb_node = 1;\n      break;\n\n    case OP_WORD:\n    case OP_NOTWORD:\n      tree = build_charclass_op (dfa, regexp->trans,\n\t\t\t\t \"alnum\",\n\t\t\t\t \"_\",\n\t\t\t\t token->type == OP_NOTWORD, err);\n      if (BE (*err != REG_NOERROR && tree == NULL, 0))\n\treturn NULL;\n      break;\n\n    case OP_SPACE:\n    case OP_NOTSPACE:\n      tree = build_charclass_op (dfa, regexp->trans,\n\t\t\t\t \"space\",\n\t\t\t\t \"\",\n\t\t\t\t token->type == OP_NOTSPACE, err);\n      if (BE (*err != REG_NOERROR && tree == NULL, 0))\n\treturn NULL;\n      break;\n\n    case OP_ALT:\n    case END_OF_RE:\n      return NULL;\n\n    case BACK_SLASH:\n      *err = REG_EESCAPE;\n      return NULL;\n\n    default:\n      /* Must not happen?  */\n#ifdef DEBUG\n      assert (0);\n#endif\n      return NULL;\n    }\n  fetch_token (token, regexp, syntax);\n\n  while (token->type == OP_DUP_ASTERISK || token->type == OP_DUP_PLUS\n\t || token->type == OP_DUP_QUESTION || token->type == OP_OPEN_DUP_NUM)\n    {\n      bin_tree_t *dup_tree = parse_dup_op (tree, regexp, dfa, token,\n\t\t\t\t\t   syntax, err);\n      if (BE (*err != REG_NOERROR && dup_tree == NULL, 0))\n\t{\n\t  if (tree != NULL)\n\t    postorder (tree, free_tree, NULL);\n\t  return NULL;\n\t}\n      tree = dup_tree;\n      /* In BRE consecutive duplications are not allowed.  */\n      if ((syntax & RE_CONTEXT_INVALID_DUP)\n\t  && (token->type == OP_DUP_ASTERISK\n\t      || token->type == OP_OPEN_DUP_NUM))\n\t{\n\t  if (tree != NULL)\n\t    postorder (tree, free_tree, NULL);\n\t  *err = REG_BADRPT;\n\t  return NULL;\n\t}\n    }\n\n  return tree;\n}",
      "lines": 227,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\nparse_expression (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t\t  reg_syntax_t syntax, Idx nest, reg_errcode_t *err)",
        "*"
      ]
    },
    "parse_sub_exp": {
      "start_point": [
        2494,
        0
      ],
      "end_point": [
        2532,
        1
      ],
      "content": "static bin_tree_t *\nparse_sub_exp (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t       reg_syntax_t syntax, Idx nest, reg_errcode_t *err)\n{\n  re_dfa_t *dfa = preg->buffer;\n  bin_tree_t *tree;\n  size_t cur_nsub;\n  cur_nsub = preg->re_nsub++;\n\n  fetch_token (token, regexp, syntax | RE_CARET_ANCHORS_HERE);\n\n  /* The subexpression may be a null string.  */\n  if (token->type == OP_CLOSE_SUBEXP)\n    tree = NULL;\n  else\n    {\n      tree = parse_reg_exp (regexp, preg, token, syntax, nest, err);\n      if (BE (*err == REG_NOERROR && token->type != OP_CLOSE_SUBEXP, 0))\n\t{\n\t  if (tree != NULL)\n\t    postorder (tree, free_tree, NULL);\n\t  *err = REG_EPAREN;\n\t}\n      if (BE (*err != REG_NOERROR, 0))\n\treturn NULL;\n    }\n\n  if (cur_nsub <= '9' - '1')\n    dfa->completed_bkref_map |= 1 << cur_nsub;\n\n  tree = create_tree (dfa, tree, NULL, SUBEXP);\n  if (BE (tree == NULL, 0))\n    {\n      *err = REG_ESPACE;\n      return NULL;\n    }\n  tree->token.opr.idx = cur_nsub;\n  return tree;\n}",
      "lines": 39,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\nparse_sub_exp (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t       reg_syntax_t syntax, Idx nest, reg_errcode_t *err)",
        "*"
      ]
    },
    "parse_dup_op": {
      "start_point": [
        2536,
        0
      ],
      "end_point": [
        2680,
        1
      ],
      "content": "static bin_tree_t *\nparse_dup_op (bin_tree_t *elem, re_string_t *regexp, re_dfa_t *dfa,\n\t      re_token_t *token, reg_syntax_t syntax, reg_errcode_t *err)\n{\n  bin_tree_t *tree = NULL, *old_tree = NULL;\n  Idx i, start, end, start_idx = re_string_cur_idx (regexp);\n  re_token_t start_token = *token;\n\n  if (token->type == OP_OPEN_DUP_NUM)\n    {\n      end = 0;\n      start = fetch_number (regexp, token, syntax);\n      if (start == -1)\n\t{\n\t  if (token->type == CHARACTER && token->opr.c == ',')\n\t    start = 0; /* We treat \"{,m}\" as \"{0,m}\".  */\n\t  else\n\t    {\n\t      *err = REG_BADBR; /* <re>{} is invalid.  */\n\t      return NULL;\n\t    }\n\t}\n      if (BE (start != -2, 1))\n\t{\n\t  /* We treat \"{n}\" as \"{n,n}\".  */\n\t  end = ((token->type == OP_CLOSE_DUP_NUM) ? start\n\t\t : ((token->type == CHARACTER && token->opr.c == ',')\n\t\t    ? fetch_number (regexp, token, syntax) : -2));\n\t}\n      if (BE (start == -2 || end == -2, 0))\n\t{\n\t  /* Invalid sequence.  */\n\t  if (BE (!(syntax & RE_INVALID_INTERVAL_ORD), 0))\n\t    {\n\t      if (token->type == END_OF_RE)\n\t\t*err = REG_EBRACE;\n\t      else\n\t\t*err = REG_BADBR;\n\n\t      return NULL;\n\t    }\n\n\t  /* If the syntax bit is set, rollback.  */\n\t  re_string_set_index (regexp, start_idx);\n\t  *token = start_token;\n\t  token->type = CHARACTER;\n\t  /* mb_partial and word_char bits should be already initialized by\n\t     peek_token.  */\n\t  return elem;\n\t}\n\n      if (BE ((end != -1 && start > end)\n\t      || token->type != OP_CLOSE_DUP_NUM, 0))\n\t{\n\t  /* First number greater than second.  */\n\t  *err = REG_BADBR;\n\t  return NULL;\n\t}\n\n      if (BE (RE_DUP_MAX < (end == -1 ? start : end), 0))\n\t{\n\t  *err = REG_ESIZE;\n\t  return NULL;\n\t}\n    }\n  else\n    {\n      start = (token->type == OP_DUP_PLUS) ? 1 : 0;\n      end = (token->type == OP_DUP_QUESTION) ? 1 : -1;\n    }\n\n  fetch_token (token, regexp, syntax);\n\n  if (BE (elem == NULL, 0))\n    return NULL;\n  if (BE (start == 0 && end == 0, 0))\n    {\n      postorder (elem, free_tree, NULL);\n      return NULL;\n    }\n\n  /* Extract \"<re>{n,m}\" to \"<re><re>...<re><re>{0,<m-n>}\".  */\n  if (BE (start > 0, 0))\n    {\n      tree = elem;\n      for (i = 2; i <= start; ++i)\n\t{\n\t  elem = duplicate_tree (elem, dfa);\n\t  tree = create_tree (dfa, tree, elem, CONCAT);\n\t  if (BE (elem == NULL || tree == NULL, 0))\n\t    goto parse_dup_op_espace;\n\t}\n\n      if (start == end)\n\treturn tree;\n\n      /* Duplicate ELEM before it is marked optional.  */\n      elem = duplicate_tree (elem, dfa);\n      if (BE (elem == NULL, 0))\n        goto parse_dup_op_espace;\n      old_tree = tree;\n    }\n  else\n    old_tree = NULL;\n\n  if (elem->token.type == SUBEXP)\n    {\n      uintptr_t subidx = elem->token.opr.idx;\n      postorder (elem, mark_opt_subexp, (void *) subidx);\n    }\n\n  tree = create_tree (dfa, elem, NULL,\n\t\t      (end == -1 ? OP_DUP_ASTERISK : OP_ALT));\n  if (BE (tree == NULL, 0))\n    goto parse_dup_op_espace;\n\n/* From gnulib's \"intprops.h\":\n   True if the arithmetic type T is signed.  */\n#define TYPE_SIGNED(t) (! ((t) 0 < (t) -1))\n\n  /* This loop is actually executed only when end != -1,\n     to rewrite <re>{0,n} as (<re>(<re>...<re>?)?)?...  We have\n     already created the start+1-th copy.  */\n  if (TYPE_SIGNED (Idx) || end != -1)\n    for (i = start + 2; i <= end; ++i)\n      {\n\telem = duplicate_tree (elem, dfa);\n\ttree = create_tree (dfa, tree, elem, CONCAT);\n\tif (BE (elem == NULL || tree == NULL, 0))\n\t  goto parse_dup_op_espace;\n\n\ttree = create_tree (dfa, tree, NULL, OP_ALT);\n\tif (BE (tree == NULL, 0))\n\t  goto parse_dup_op_espace;\n      }\n\n  if (old_tree)\n    tree = create_tree (dfa, old_tree, tree, CONCAT);\n\n  return tree;\n\n parse_dup_op_espace:\n  *err = REG_ESPACE;\n  return NULL;\n}",
      "lines": 145,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\nparse_dup_op (bin_tree_t *elem, re_string_t *regexp, re_dfa_t *dfa,\n\t      re_token_t *token, reg_syntax_t syntax, reg_errcode_t *err)",
        "*"
      ]
    },
    "parse_byte": {
      "start_point": [
        2692,
        0
      ],
      "end_point": [
        2697,
        1
      ],
      "content": "static wint_t\nparse_byte (unsigned char b, re_charset_t *mbcset)\n{\n  wint_t wc = __btowc (b);\n  return wc == WEOF && !mbcset ? b : wc;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "wint_t"
      ]
    },
    "start_elem": {
      "start_point": [
        2719,
        23
      ],
      "end_point": [
        2822,
        1
      ],
      "content": "bracket_elem_t *end_elem)\n# endif /* not RE_ENABLE_I18N */\n{\n  unsigned int start_ch, end_ch;\n  /* Equivalence Classes and Character Classes can't be a range start/end.  */\n  if (BE (start_elem->type == EQUIV_CLASS || start_elem->type == CHAR_CLASS\n\t  || end_elem->type == EQUIV_CLASS || end_elem->type == CHAR_CLASS,\n\t  0))\n    return REG_ERANGE;\n\n  /* We can handle no multi character collating elements without libc\n     support.  */\n  if (BE ((start_elem->type == COLL_SYM\n\t   && strlen ((char *) start_elem->opr.name) > 1)\n\t  || (end_elem->type == COLL_SYM\n\t      && strlen ((char *) end_elem->opr.name) > 1), 0))\n    return REG_ECOLLATE;\n\n# ifdef RE_ENABLE_I18N\n  {\n    wchar_t wc;\n    wint_t start_wc;\n    wint_t end_wc;\n\n    start_ch = ((start_elem->type == SB_CHAR) ? start_elem->opr.ch\n\t\t: ((start_elem->type == COLL_SYM) ? start_elem->opr.name[0]\n\t\t   : 0));\n    end_ch = ((end_elem->type == SB_CHAR) ? end_elem->opr.ch\n\t      : ((end_elem->type == COLL_SYM) ? end_elem->opr.name[0]\n\t\t : 0));\n    start_wc = ((start_elem->type == SB_CHAR || start_elem->type == COLL_SYM)\n\t\t? parse_byte (start_ch, mbcset) : start_elem->opr.wch);\n    end_wc = ((end_elem->type == SB_CHAR || end_elem->type == COLL_SYM)\n\t      ? parse_byte (end_ch, mbcset) : end_elem->opr.wch);\n    if (start_wc == WEOF || end_wc == WEOF)\n      return REG_ECOLLATE;\n    else if (BE ((syntax & RE_NO_EMPTY_RANGES) && start_wc > end_wc, 0))\n      return REG_ERANGE;\n\n    /* Got valid collation sequence values, add them as a new entry.\n       However, for !_LIBC we have no collation elements: if the\n       character set is single byte, the single byte character set\n       that we build below suffices.  parse_bracket_exp passes\n       no MBCSET if dfa->mb_cur_max == 1.  */\n    if (mbcset)\n      {\n\t/* Check the space of the arrays.  */\n\tif (BE (*range_alloc == mbcset->nranges, 0))\n\t  {\n\t    /* There is not enough space, need realloc.  */\n\t    wchar_t *new_array_start, *new_array_end;\n\t    Idx new_nranges;\n\n\t    /* +1 in case of mbcset->nranges is 0.  */\n\t    new_nranges = 2 * mbcset->nranges + 1;\n\t    /* Use realloc since mbcset->range_starts and mbcset->range_ends\n\t       are NULL if *range_alloc == 0.  */\n\t    new_array_start = re_realloc (mbcset->range_starts, wchar_t,\n\t\t\t\t\t  new_nranges);\n\t    new_array_end = re_realloc (mbcset->range_ends, wchar_t,\n\t\t\t\t\tnew_nranges);\n\n\t    if (BE (new_array_start == NULL || new_array_end == NULL, 0))\n\t      {\n\t\tre_free (new_array_start);\n\t\tre_free (new_array_end);\n\t\treturn REG_ESPACE;\n\t      }\n\n\t    mbcset->range_starts = new_array_start;\n\t    mbcset->range_ends = new_array_end;\n\t    *range_alloc = new_nranges;\n\t  }\n\n\tmbcset->range_starts[mbcset->nranges] = start_wc;\n\tmbcset->range_ends[mbcset->nranges++] = end_wc;\n      }\n\n    /* Build the table for single byte characters.  */\n    for (wc = 0; wc < SBC_MAX; ++wc)\n      {\n\tif (start_wc <= wc && wc <= end_wc)\n\t  bitset_set (sbcset, wc);\n      }\n  }\n# else /* not RE_ENABLE_I18N */\n  {\n    unsigned int ch;\n    start_ch = ((start_elem->type == SB_CHAR ) ? start_elem->opr.ch\n\t\t: ((start_elem->type == COLL_SYM) ? start_elem->opr.name[0]\n\t\t   : 0));\n    end_ch = ((end_elem->type == SB_CHAR ) ? end_elem->opr.ch\n\t      : ((end_elem->type == COLL_SYM) ? end_elem->opr.name[0]\n\t\t : 0));\n    if (start_ch > end_ch)\n      return REG_ERANGE;\n    /* Build the table for single byte characters.  */\n    for (ch = 0; ch < SBC_MAX; ++ch)\n      if (start_ch <= ch  && ch <= end_ch)\n\tbitset_set (sbcset, ch);\n  }\n# endif /* not RE_ENABLE_I18N */\n  return REG_NOERROR;\n}",
      "lines": 104,
      "depth": 16,
      "decorators": null
    },
    "parse_bracket_exp": {
      "start_point": [
        2854,
        0
      ],
      "end_point": [
        3399,
        1
      ],
      "content": "static bin_tree_t *\nparse_bracket_exp (re_string_t *regexp, re_dfa_t *dfa, re_token_t *token,\n\t\t   reg_syntax_t syntax, reg_errcode_t *err)\n{\n#ifdef _LIBC\n  const unsigned char *collseqmb;\n  const char *collseqwc;\n  uint32_t nrules;\n  int32_t table_size;\n  const int32_t *symb_table;\n  const unsigned char *extra;\n\n  /* Local function for parse_bracket_exp used in _LIBC environment.\n     Seek the collating symbol entry corresponding to NAME.\n     Return the index of the symbol in the SYMB_TABLE,\n     or -1 if not found.  */\n\n  auto inline int32_t\n  __attribute__ ((always_inline))\n  seek_collating_symbol_entry (const unsigned char *name, size_t name_len)\n    {\n      int32_t elem;\n\n      for (elem = 0; elem < table_size; elem++)\n\tif (symb_table[2 * elem] != 0)\n\t  {\n\t    int32_t idx = symb_table[2 * elem + 1];\n\t    /* Skip the name of collating element name.  */\n\t    idx += 1 + extra[idx];\n\t    if (/* Compare the length of the name.  */\n\t\tname_len == extra[idx]\n\t\t/* Compare the name.  */\n\t\t&& memcmp (name, &extra[idx + 1], name_len) == 0)\n\t      /* Yep, this is the entry.  */\n\t      return elem;\n\t  }\n      return -1;\n    }\n\n  /* Local function for parse_bracket_exp used in _LIBC environment.\n     Look up the collation sequence value of BR_ELEM.\n     Return the value if succeeded, UINT_MAX otherwise.  */\n\n  auto inline unsigned int\n  __attribute__ ((always_inline))\n  lookup_collation_sequence_value (bracket_elem_t *br_elem)\n    {\n      if (br_elem->type == SB_CHAR)\n\t{\n\t  /*\n\t  if (MB_CUR_MAX == 1)\n\t  */\n\t  if (nrules == 0)\n\t    return collseqmb[br_elem->opr.ch];\n\t  else\n\t    {\n\t      wint_t wc = __btowc (br_elem->opr.ch);\n\t      return __collseq_table_lookup (collseqwc, wc);\n\t    }\n\t}\n      else if (br_elem->type == MB_CHAR)\n\t{\n\t  if (nrules != 0)\n\t    return __collseq_table_lookup (collseqwc, br_elem->opr.wch);\n\t}\n      else if (br_elem->type == COLL_SYM)\n\t{\n\t  size_t sym_name_len = strlen ((char *) br_elem->opr.name);\n\t  if (nrules != 0)\n\t    {\n\t      int32_t elem, idx;\n\t      elem = seek_collating_symbol_entry (br_elem->opr.name,\n\t\t\t\t\t\t  sym_name_len);\n\t      if (elem != -1)\n\t\t{\n\t\t  /* We found the entry.  */\n\t\t  idx = symb_table[2 * elem + 1];\n\t\t  /* Skip the name of collating element name.  */\n\t\t  idx += 1 + extra[idx];\n\t\t  /* Skip the byte sequence of the collating element.  */\n\t\t  idx += 1 + extra[idx];\n\t\t  /* Adjust for the alignment.  */\n\t\t  idx = (idx + 3) & ~3;\n\t\t  /* Skip the multibyte collation sequence value.  */\n\t\t  idx += sizeof (unsigned int);\n\t\t  /* Skip the wide char sequence of the collating element.  */\n\t\t  idx += sizeof (unsigned int) *\n\t\t    (1 + *(unsigned int *) (extra + idx));\n\t\t  /* Return the collation sequence value.  */\n\t\t  return *(unsigned int *) (extra + idx);\n\t\t}\n\t      else if (sym_name_len == 1)\n\t\t{\n\t\t  /* No valid character.  Match it as a single byte\n\t\t     character.  */\n\t\t  return collseqmb[br_elem->opr.name[0]];\n\t\t}\n\t    }\n\t  else if (sym_name_len == 1)\n\t    return collseqmb[br_elem->opr.name[0]];\n\t}\n      return UINT_MAX;\n    }\n\n  /* Local function for parse_bracket_exp used in _LIBC environment.\n     Build the range expression which starts from START_ELEM, and ends\n     at END_ELEM.  The result are written to MBCSET and SBCSET.\n     RANGE_ALLOC is the allocated size of mbcset->range_starts, and\n     mbcset->range_ends, is a pointer argument since we may\n     update it.  */\n\n  auto inline reg_errcode_t\n  __attribute__ ((always_inline))\n  build_range_exp (bitset_t sbcset, re_charset_t *mbcset, int *range_alloc,\n\t\t   bracket_elem_t *start_elem, bracket_elem_t *end_elem)\n    {\n      unsigned int ch;\n      uint32_t start_collseq;\n      uint32_t end_collseq;\n\n      /* Equivalence Classes and Character Classes can't be a range\n\t start/end.  */\n      if (BE (start_elem->type == EQUIV_CLASS || start_elem->type == CHAR_CLASS\n\t      || end_elem->type == EQUIV_CLASS || end_elem->type == CHAR_CLASS,\n\t      0))\n\treturn REG_ERANGE;\n\n      /* FIXME: Implement rational ranges here, too.  */\n      start_collseq = lookup_collation_sequence_value (start_elem);\n      end_collseq = lookup_collation_sequence_value (end_elem);\n      /* Check start/end collation sequence values.  */\n      if (BE (start_collseq == UINT_MAX || end_collseq == UINT_MAX, 0))\n\treturn REG_ECOLLATE;\n      if (BE ((syntax & RE_NO_EMPTY_RANGES) && start_collseq > end_collseq, 0))\n\treturn REG_ERANGE;\n\n      /* Got valid collation sequence values, add them as a new entry.\n\t However, if we have no collation elements, and the character set\n\t is single byte, the single byte character set that we\n\t build below suffices. */\n      if (nrules > 0 || dfa->mb_cur_max > 1)\n\t{\n\t  /* Check the space of the arrays.  */\n\t  if (BE (*range_alloc == mbcset->nranges, 0))\n\t    {\n\t      /* There is not enough space, need realloc.  */\n\t      uint32_t *new_array_start;\n\t      uint32_t *new_array_end;\n\t      Idx new_nranges;\n\n\t      /* +1 in case of mbcset->nranges is 0.  */\n\t      new_nranges = 2 * mbcset->nranges + 1;\n\t      new_array_start = re_realloc (mbcset->range_starts, uint32_t,\n\t\t\t\t\t    new_nranges);\n\t      new_array_end = re_realloc (mbcset->range_ends, uint32_t,\n\t\t\t\t\t  new_nranges);\n\n\t      if (BE (new_array_start == NULL || new_array_end == NULL, 0))\n\t\treturn REG_ESPACE;\n\n\t      mbcset->range_starts = new_array_start;\n\t      mbcset->range_ends = new_array_end;\n\t      *range_alloc = new_nranges;\n\t    }\n\n\t  mbcset->range_starts[mbcset->nranges] = start_collseq;\n\t  mbcset->range_ends[mbcset->nranges++] = end_collseq;\n\t}\n\n      /* Build the table for single byte characters.  */\n      for (ch = 0; ch < SBC_MAX; ch++)\n\t{\n\t  uint32_t ch_collseq;\n\t  /*\n\t  if (MB_CUR_MAX == 1)\n\t  */\n\t  if (nrules == 0)\n\t    ch_collseq = collseqmb[ch];\n\t  else\n\t    ch_collseq = __collseq_table_lookup (collseqwc, __btowc (ch));\n\t  if (start_collseq <= ch_collseq && ch_collseq <= end_collseq)\n\t    bitset_set (sbcset, ch);\n\t}\n      return REG_NOERROR;\n    }\n\n  /* Local function for parse_bracket_exp used in _LIBC environment.\n     Build the collating element which is represented by NAME.\n     The result are written to MBCSET and SBCSET.\n     COLL_SYM_ALLOC is the allocated size of mbcset->coll_sym, is a\n     pointer argument since we may update it.  */\n\n  auto inline reg_errcode_t\n  __attribute__ ((always_inline))\n  build_collating_symbol (bitset_t sbcset, re_charset_t *mbcset,\n\t\t\t  Idx *coll_sym_alloc, const unsigned char *name)\n    {\n      int32_t elem, idx;\n      size_t name_len = strlen ((const char *) name);\n      if (nrules != 0)\n\t{\n\t  elem = seek_collating_symbol_entry (name, name_len);\n\t  if (elem != -1)\n\t    {\n\t      /* We found the entry.  */\n\t      idx = symb_table[2 * elem + 1];\n\t      /* Skip the name of collating element name.  */\n\t      idx += 1 + extra[idx];\n\t    }\n\t  else if (name_len == 1)\n\t    {\n\t      /* No valid character, treat it as a normal\n\t\t character.  */\n\t      bitset_set (sbcset, name[0]);\n\t      return REG_NOERROR;\n\t    }\n\t  else\n\t    return REG_ECOLLATE;\n\n\t  /* Got valid collation sequence, add it as a new entry.  */\n\t  /* Check the space of the arrays.  */\n\t  if (BE (*coll_sym_alloc == mbcset->ncoll_syms, 0))\n\t    {\n\t      /* Not enough, realloc it.  */\n\t      /* +1 in case of mbcset->ncoll_syms is 0.  */\n\t      Idx new_coll_sym_alloc = 2 * mbcset->ncoll_syms + 1;\n\t      /* Use realloc since mbcset->coll_syms is NULL\n\t\t if *alloc == 0.  */\n\t      int32_t *new_coll_syms = re_realloc (mbcset->coll_syms, int32_t,\n\t\t\t\t\t\t   new_coll_sym_alloc);\n\t      if (BE (new_coll_syms == NULL, 0))\n\t\treturn REG_ESPACE;\n\t      mbcset->coll_syms = new_coll_syms;\n\t      *coll_sym_alloc = new_coll_sym_alloc;\n\t    }\n\t  mbcset->coll_syms[mbcset->ncoll_syms++] = idx;\n\t  return REG_NOERROR;\n\t}\n      else\n\t{\n\t  if (BE (name_len != 1, 0))\n\t    return REG_ECOLLATE;\n\t  else\n\t    {\n\t      bitset_set (sbcset, name[0]);\n\t      return REG_NOERROR;\n\t    }\n\t}\n    }\n#endif\n\n  re_token_t br_token;\n  re_bitset_ptr_t sbcset;\n#ifdef RE_ENABLE_I18N\n  re_charset_t *mbcset;\n  Idx coll_sym_alloc = 0, range_alloc = 0, mbchar_alloc = 0;\n  Idx equiv_class_alloc = 0, char_class_alloc = 0;\n#endif /* not RE_ENABLE_I18N */\n  bool non_match = false;\n  bin_tree_t *work_tree;\n  int token_len;\n  bool first_round = true;\n#ifdef _LIBC\n  collseqmb = (const unsigned char *)\n    _NL_CURRENT (LC_COLLATE, _NL_COLLATE_COLLSEQMB);\n  nrules = _NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_NRULES);\n  if (nrules)\n    {\n      /*\n      if (MB_CUR_MAX > 1)\n      */\n      collseqwc = _NL_CURRENT (LC_COLLATE, _NL_COLLATE_COLLSEQWC);\n      table_size = _NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_SYMB_HASH_SIZEMB);\n      symb_table = (const int32_t *) _NL_CURRENT (LC_COLLATE,\n\t\t\t\t\t\t  _NL_COLLATE_SYMB_TABLEMB);\n      extra = (const unsigned char *) _NL_CURRENT (LC_COLLATE,\n\t\t\t\t\t\t   _NL_COLLATE_SYMB_EXTRAMB);\n    }\n#endif\n  sbcset = (re_bitset_ptr_t) calloc (sizeof (bitset_t), 1);\n#ifdef RE_ENABLE_I18N\n  mbcset = (re_charset_t *) calloc (sizeof (re_charset_t), 1);\n#endif /* RE_ENABLE_I18N */\n#ifdef RE_ENABLE_I18N\n  if (BE (sbcset == NULL || mbcset == NULL, 0))\n#else\n  if (BE (sbcset == NULL, 0))\n#endif /* RE_ENABLE_I18N */\n    {\n      re_free (sbcset);\n#ifdef RE_ENABLE_I18N\n      re_free (mbcset);\n#endif\n      *err = REG_ESPACE;\n      return NULL;\n    }\n\n  token_len = peek_token_bracket (token, regexp, syntax);\n  if (BE (token->type == END_OF_RE, 0))\n    {\n      *err = REG_BADPAT;\n      goto parse_bracket_exp_free_return;\n    }\n  if (token->type == OP_NON_MATCH_LIST)\n    {\n#ifdef RE_ENABLE_I18N\n      mbcset->non_match = 1;\n#endif /* not RE_ENABLE_I18N */\n      non_match = true;\n      if (syntax & RE_HAT_LISTS_NOT_NEWLINE)\n\tbitset_set (sbcset, '\\n');\n      re_string_skip_bytes (regexp, token_len); /* Skip a token.  */\n      token_len = peek_token_bracket (token, regexp, syntax);\n      if (BE (token->type == END_OF_RE, 0))\n\t{\n\t  *err = REG_BADPAT;\n\t  goto parse_bracket_exp_free_return;\n\t}\n    }\n\n  /* We treat the first ']' as a normal character.  */\n  if (token->type == OP_CLOSE_BRACKET)\n    token->type = CHARACTER;\n\n  while (1)\n    {\n      bracket_elem_t start_elem, end_elem;\n      unsigned char start_name_buf[BRACKET_NAME_BUF_SIZE];\n      unsigned char end_name_buf[BRACKET_NAME_BUF_SIZE];\n      reg_errcode_t ret;\n      int token_len2 = 0;\n      bool is_range_exp = false;\n      re_token_t token2;\n\n      start_elem.opr.name = start_name_buf;\n      start_elem.type = COLL_SYM;\n      ret = parse_bracket_element (&start_elem, regexp, token, token_len, dfa,\n\t\t\t\t   syntax, first_round);\n      if (BE (ret != REG_NOERROR, 0))\n\t{\n\t  *err = ret;\n\t  goto parse_bracket_exp_free_return;\n\t}\n      first_round = false;\n\n      /* Get information about the next token.  We need it in any case.  */\n      token_len = peek_token_bracket (token, regexp, syntax);\n\n      /* Do not check for ranges if we know they are not allowed.  */\n      if (start_elem.type != CHAR_CLASS && start_elem.type != EQUIV_CLASS)\n\t{\n\t  if (BE (token->type == END_OF_RE, 0))\n\t    {\n\t      *err = REG_EBRACK;\n\t      goto parse_bracket_exp_free_return;\n\t    }\n\t  if (token->type == OP_CHARSET_RANGE)\n\t    {\n\t      re_string_skip_bytes (regexp, token_len); /* Skip '-'.  */\n\t      token_len2 = peek_token_bracket (&token2, regexp, syntax);\n\t      if (BE (token2.type == END_OF_RE, 0))\n\t\t{\n\t\t  *err = REG_EBRACK;\n\t\t  goto parse_bracket_exp_free_return;\n\t\t}\n\t      if (token2.type == OP_CLOSE_BRACKET)\n\t\t{\n\t\t  /* We treat the last '-' as a normal character.  */\n\t\t  re_string_skip_bytes (regexp, -token_len);\n\t\t  token->type = CHARACTER;\n\t\t}\n\t      else\n\t\tis_range_exp = true;\n\t    }\n\t}\n\n      if (is_range_exp == true)\n\t{\n\t  end_elem.opr.name = end_name_buf;\n\t  end_elem.type = COLL_SYM;\n\t  ret = parse_bracket_element (&end_elem, regexp, &token2, token_len2,\n\t\t\t\t       dfa, syntax, true);\n\t  if (BE (ret != REG_NOERROR, 0))\n\t    {\n\t      *err = ret;\n\t      goto parse_bracket_exp_free_return;\n\t    }\n\n\t  token_len = peek_token_bracket (token, regexp, syntax);\n\n#ifdef _LIBC\n\t  *err = build_range_exp (sbcset, mbcset, &range_alloc,\n\t\t\t\t  &start_elem, &end_elem);\n#else\n# ifdef RE_ENABLE_I18N\n\t  *err = build_range_exp (syntax, sbcset,\n\t\t\t\t  dfa->mb_cur_max > 1 ? mbcset : NULL,\n\t\t\t\t  &range_alloc, &start_elem, &end_elem);\n# else\n\t  *err = build_range_exp (syntax, sbcset, &start_elem, &end_elem);\n# endif\n#endif /* RE_ENABLE_I18N */\n\t  if (BE (*err != REG_NOERROR, 0))\n\t    goto parse_bracket_exp_free_return;\n\t}\n      else\n\t{\n\t  switch (start_elem.type)\n\t    {\n\t    case SB_CHAR:\n\t      bitset_set (sbcset, start_elem.opr.ch);\n\t      break;\n#ifdef RE_ENABLE_I18N\n\t    case MB_CHAR:\n\t      /* Check whether the array has enough space.  */\n\t      if (BE (mbchar_alloc == mbcset->nmbchars, 0))\n\t\t{\n\t\t  wchar_t *new_mbchars;\n\t\t  /* Not enough, realloc it.  */\n\t\t  /* +1 in case of mbcset->nmbchars is 0.  */\n\t\t  mbchar_alloc = 2 * mbcset->nmbchars + 1;\n\t\t  /* Use realloc since array is NULL if *alloc == 0.  */\n\t\t  new_mbchars = re_realloc (mbcset->mbchars, wchar_t,\n\t\t\t\t\t    mbchar_alloc);\n\t\t  if (BE (new_mbchars == NULL, 0))\n\t\t    goto parse_bracket_exp_espace;\n\t\t  mbcset->mbchars = new_mbchars;\n\t\t}\n\t      mbcset->mbchars[mbcset->nmbchars++] = start_elem.opr.wch;\n\t      break;\n#endif /* RE_ENABLE_I18N */\n\t    case EQUIV_CLASS:\n\t      *err = build_equiv_class (sbcset,\n#ifdef RE_ENABLE_I18N\n\t\t\t\t\tmbcset, &equiv_class_alloc,\n#endif /* RE_ENABLE_I18N */\n\t\t\t\t\tstart_elem.opr.name);\n\t      if (BE (*err != REG_NOERROR, 0))\n\t\tgoto parse_bracket_exp_free_return;\n\t      break;\n\t    case COLL_SYM:\n\t      *err = build_collating_symbol (sbcset,\n#ifdef RE_ENABLE_I18N\n\t\t\t\t\t     mbcset, &coll_sym_alloc,\n#endif /* RE_ENABLE_I18N */\n\t\t\t\t\t     start_elem.opr.name);\n\t      if (BE (*err != REG_NOERROR, 0))\n\t\tgoto parse_bracket_exp_free_return;\n\t      break;\n\t    case CHAR_CLASS:\n\t      *err = build_charclass (regexp->trans, sbcset,\n#ifdef RE_ENABLE_I18N\n\t\t\t\t      mbcset, &char_class_alloc,\n#endif /* RE_ENABLE_I18N */\n\t\t\t\t      (const char *) start_elem.opr.name,\n\t\t\t\t      syntax);\n\t      if (BE (*err != REG_NOERROR, 0))\n\t       goto parse_bracket_exp_free_return;\n\t      break;\n\t    default:\n\t      assert (0);\n\t      break;\n\t    }\n\t}\n      if (BE (token->type == END_OF_RE, 0))\n\t{\n\t  *err = REG_EBRACK;\n\t  goto parse_bracket_exp_free_return;\n\t}\n      if (token->type == OP_CLOSE_BRACKET)\n\tbreak;\n    }\n\n  re_string_skip_bytes (regexp, token_len); /* Skip a token.  */\n\n  /* If it is non-matching list.  */\n  if (non_match)\n    bitset_not (sbcset);\n\n#ifdef RE_ENABLE_I18N\n  /* Ensure only single byte characters are set.  */\n  if (dfa->mb_cur_max > 1)\n    bitset_mask (sbcset, dfa->sb_char);\n\n  if (mbcset->nmbchars || mbcset->ncoll_syms || mbcset->nequiv_classes\n      || mbcset->nranges || (dfa->mb_cur_max > 1 && (mbcset->nchar_classes\n\t\t\t\t\t\t     || mbcset->non_match)))\n    {\n      bin_tree_t *mbc_tree;\n      int sbc_idx;\n      /* Build a tree for complex bracket.  */\n      dfa->has_mb_node = 1;\n      br_token.type = COMPLEX_BRACKET;\n      br_token.opr.mbcset = mbcset;\n      mbc_tree = create_token_tree (dfa, NULL, NULL, &br_token);\n      if (BE (mbc_tree == NULL, 0))\n\tgoto parse_bracket_exp_espace;\n      for (sbc_idx = 0; sbc_idx < BITSET_WORDS; ++sbc_idx)\n\tif (sbcset[sbc_idx])\n\t  break;\n      /* If there are no bits set in sbcset, there is no point\n\t of having both SIMPLE_BRACKET and COMPLEX_BRACKET.  */\n      if (sbc_idx < BITSET_WORDS)\n\t{\n\t  /* Build a tree for simple bracket.  */\n\t  br_token.type = SIMPLE_BRACKET;\n\t  br_token.opr.sbcset = sbcset;\n\t  work_tree = create_token_tree (dfa, NULL, NULL, &br_token);\n\t  if (BE (work_tree == NULL, 0))\n\t    goto parse_bracket_exp_espace;\n\n\t  /* Then join them by ALT node.  */\n\t  work_tree = create_tree (dfa, work_tree, mbc_tree, OP_ALT);\n\t  if (BE (work_tree == NULL, 0))\n\t    goto parse_bracket_exp_espace;\n\t}\n      else\n\t{\n\t  re_free (sbcset);\n\t  work_tree = mbc_tree;\n\t}\n    }\n  else\n#endif /* not RE_ENABLE_I18N */\n    {\n#ifdef RE_ENABLE_I18N\n      free_charset (mbcset);\n#endif\n      /* Build a tree for simple bracket.  */\n      br_token.type = SIMPLE_BRACKET;\n      br_token.opr.sbcset = sbcset;\n      work_tree = create_token_tree (dfa, NULL, NULL, &br_token);\n      if (BE (work_tree == NULL, 0))\n\tgoto parse_bracket_exp_espace;\n    }\n  return work_tree;\n\n parse_bracket_exp_espace:\n  *err = REG_ESPACE;\n parse_bracket_exp_free_return:\n  re_free (sbcset);\n#ifdef RE_ENABLE_I18N\n  free_charset (mbcset);\n#endif /* RE_ENABLE_I18N */\n  return NULL;\n}",
      "lines": 546,
      "depth": 25,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\nparse_bracket_exp (re_string_t *regexp, re_dfa_t *dfa, re_token_t *token,\n\t\t   reg_syntax_t syntax, reg_errcode_t *err)",
        "*"
      ]
    },
    "seek_collating_symbol_entry": {
      "start_point": [
        2871,
        2
      ],
      "end_point": [
        2891,
        5
      ],
      "content": "auto inline int32_t\n  __attribute__ ((always_inline))\n  seek_collating_symbol_entry (const unsigned char *name, size_t name_len)\n    {\n      int32_t elem;\n\n      for (elem = 0; elem < table_size; elem++)\n\tif (symb_table[2 * elem] != 0)\n\t  {\n\t    int32_t idx = symb_table[2 * elem + 1];\n\t    /* Skip the name of collating element name.  */\n\t    idx += 1 + extra[idx];\n\t    if (/* Compare the length of the name.  */\n\t\tname_len == extra[idx]\n\t\t/* Compare the name.  */\n\t\t&& memcmp (name, &extra[idx + 1], name_len) == 0)\n\t      /* Yep, this is the entry.  */\n\t      return elem;\n\t  }\n      return -1;\n    }",
      "lines": 21,
      "depth": 15,
      "decorators": [
        "auto",
        "auto",
        "inline",
        "inline",
        "int32_t",
        "__attribute__ ((always_inline))",
        "__attribute__",
        "(",
        "(always_inline)",
        "(",
        "always_inline",
        ")",
        ")"
      ]
    },
    "lookup_collation_sequence_value": {
      "start_point": [
        2897,
        2
      ],
      "end_point": [
        2956,
        5
      ],
      "content": "auto inline unsigned int\n  __attribute__ ((always_inline))\n  lookup_collation_sequence_value (bracket_elem_t *br_elem)\n    {\n      if (br_elem->type == SB_CHAR)\n\t{\n\t  /*\n\t  if (MB_CUR_MAX == 1)\n\t  */\n\t  if (nrules == 0)\n\t    return collseqmb[br_elem->opr.ch];\n\t  else\n\t    {\n\t      wint_t wc = __btowc (br_elem->opr.ch);\n\t      return __collseq_table_lookup (collseqwc, wc);\n\t    }\n\t}\n      else if (br_elem->type == MB_CHAR)\n\t{\n\t  if (nrules != 0)\n\t    return __collseq_table_lookup (collseqwc, br_elem->opr.wch);\n\t}\n      else if (br_elem->type == COLL_SYM)\n\t{\n\t  size_t sym_name_len = strlen ((char *) br_elem->opr.name);\n\t  if (nrules != 0)\n\t    {\n\t      int32_t elem, idx;\n\t      elem = seek_collating_symbol_entry (br_elem->opr.name,\n\t\t\t\t\t\t  sym_name_len);\n\t      if (elem != -1)\n\t\t{\n\t\t  /* We found the entry.  */\n\t\t  idx = symb_table[2 * elem + 1];\n\t\t  /* Skip the name of collating element name.  */\n\t\t  idx += 1 + extra[idx];\n\t\t  /* Skip the byte sequence of the collating element.  */\n\t\t  idx += 1 + extra[idx];\n\t\t  /* Adjust for the alignment.  */\n\t\t  idx = (idx + 3) & ~3;\n\t\t  /* Skip the multibyte collation sequence value.  */\n\t\t  idx += sizeof (unsigned int);\n\t\t  /* Skip the wide char sequence of the collating element.  */\n\t\t  idx += sizeof (unsigned int) *\n\t\t    (1 + *(unsigned int *) (extra + idx));\n\t\t  /* Return the collation sequence value.  */\n\t\t  return *(unsigned int *) (extra + idx);\n\t\t}\n\t      else if (sym_name_len == 1)\n\t\t{\n\t\t  /* No valid character.  Match it as a single byte\n\t\t     character.  */\n\t\t  return collseqmb[br_elem->opr.name[0]];\n\t\t}\n\t    }\n\t  else if (sym_name_len == 1)\n\t    return collseqmb[br_elem->opr.name[0]];\n\t}\n      return UINT_MAX;\n    }",
      "lines": 60,
      "depth": 22,
      "decorators": [
        "auto",
        "auto",
        "inline",
        "inline",
        "unsigned int",
        "unsigned",
        "int",
        "__attribute__ ((always_inline))",
        "__attribute__",
        "(",
        "(always_inline)",
        "(",
        "always_inline",
        ")",
        ")"
      ]
    },
    "build_range_exp": {
      "start_point": [
        2965,
        2
      ],
      "end_point": [
        3038,
        5
      ],
      "content": "auto inline reg_errcode_t\n  __attribute__ ((always_inline))\n  build_range_exp (bitset_t sbcset, re_charset_t *mbcset, int *range_alloc,\n\t\t   bracket_elem_t *start_elem, bracket_elem_t *end_elem)\n    {\n      unsigned int ch;\n      uint32_t start_collseq;\n      uint32_t end_collseq;\n\n      /* Equivalence Classes and Character Classes can't be a range\n\t start/end.  */\n      if (BE (start_elem->type == EQUIV_CLASS || start_elem->type == CHAR_CLASS\n\t      || end_elem->type == EQUIV_CLASS || end_elem->type == CHAR_CLASS,\n\t      0))\n\treturn REG_ERANGE;\n\n      /* FIXME: Implement rational ranges here, too.  */\n      start_collseq = lookup_collation_sequence_value (start_elem);\n      end_collseq = lookup_collation_sequence_value (end_elem);\n      /* Check start/end collation sequence values.  */\n      if (BE (start_collseq == UINT_MAX || end_collseq == UINT_MAX, 0))\n\treturn REG_ECOLLATE;\n      if (BE ((syntax & RE_NO_EMPTY_RANGES) && start_collseq > end_collseq, 0))\n\treturn REG_ERANGE;\n\n      /* Got valid collation sequence values, add them as a new entry.\n\t However, if we have no collation elements, and the character set\n\t is single byte, the single byte character set that we\n\t build below suffices. */\n      if (nrules > 0 || dfa->mb_cur_max > 1)\n\t{\n\t  /* Check the space of the arrays.  */\n\t  if (BE (*range_alloc == mbcset->nranges, 0))\n\t    {\n\t      /* There is not enough space, need realloc.  */\n\t      uint32_t *new_array_start;\n\t      uint32_t *new_array_end;\n\t      Idx new_nranges;\n\n\t      /* +1 in case of mbcset->nranges is 0.  */\n\t      new_nranges = 2 * mbcset->nranges + 1;\n\t      new_array_start = re_realloc (mbcset->range_starts, uint32_t,\n\t\t\t\t\t    new_nranges);\n\t      new_array_end = re_realloc (mbcset->range_ends, uint32_t,\n\t\t\t\t\t  new_nranges);\n\n\t      if (BE (new_array_start == NULL || new_array_end == NULL, 0))\n\t\treturn REG_ESPACE;\n\n\t      mbcset->range_starts = new_array_start;\n\t      mbcset->range_ends = new_array_end;\n\t      *range_alloc = new_nranges;\n\t    }\n\n\t  mbcset->range_starts[mbcset->nranges] = start_collseq;\n\t  mbcset->range_ends[mbcset->nranges++] = end_collseq;\n\t}\n\n      /* Build the table for single byte characters.  */\n      for (ch = 0; ch < SBC_MAX; ch++)\n\t{\n\t  uint32_t ch_collseq;\n\t  /*\n\t  if (MB_CUR_MAX == 1)\n\t  */\n\t  if (nrules == 0)\n\t    ch_collseq = collseqmb[ch];\n\t  else\n\t    ch_collseq = __collseq_table_lookup (collseqwc, __btowc (ch));\n\t  if (start_collseq <= ch_collseq && ch_collseq <= end_collseq)\n\t    bitset_set (sbcset, ch);\n\t}\n      return REG_NOERROR;\n    }",
      "lines": 74,
      "depth": 13,
      "decorators": [
        "auto",
        "auto",
        "inline",
        "inline",
        "reg_errcode_t",
        "__attribute__ ((always_inline))",
        "__attribute__",
        "(",
        "(always_inline)",
        "(",
        "always_inline",
        ")",
        ")"
      ]
    },
    "build_collating_symbol": {
      "start_point": [
        3046,
        2
      ],
      "end_point": [
        3102,
        5
      ],
      "content": "auto inline reg_errcode_t\n  __attribute__ ((always_inline))\n  build_collating_symbol (bitset_t sbcset, re_charset_t *mbcset,\n\t\t\t  Idx *coll_sym_alloc, const unsigned char *name)\n    {\n      int32_t elem, idx;\n      size_t name_len = strlen ((const char *) name);\n      if (nrules != 0)\n\t{\n\t  elem = seek_collating_symbol_entry (name, name_len);\n\t  if (elem != -1)\n\t    {\n\t      /* We found the entry.  */\n\t      idx = symb_table[2 * elem + 1];\n\t      /* Skip the name of collating element name.  */\n\t      idx += 1 + extra[idx];\n\t    }\n\t  else if (name_len == 1)\n\t    {\n\t      /* No valid character, treat it as a normal\n\t\t character.  */\n\t      bitset_set (sbcset, name[0]);\n\t      return REG_NOERROR;\n\t    }\n\t  else\n\t    return REG_ECOLLATE;\n\n\t  /* Got valid collation sequence, add it as a new entry.  */\n\t  /* Check the space of the arrays.  */\n\t  if (BE (*coll_sym_alloc == mbcset->ncoll_syms, 0))\n\t    {\n\t      /* Not enough, realloc it.  */\n\t      /* +1 in case of mbcset->ncoll_syms is 0.  */\n\t      Idx new_coll_sym_alloc = 2 * mbcset->ncoll_syms + 1;\n\t      /* Use realloc since mbcset->coll_syms is NULL\n\t\t if *alloc == 0.  */\n\t      int32_t *new_coll_syms = re_realloc (mbcset->coll_syms, int32_t,\n\t\t\t\t\t\t   new_coll_sym_alloc);\n\t      if (BE (new_coll_syms == NULL, 0))\n\t\treturn REG_ESPACE;\n\t      mbcset->coll_syms = new_coll_syms;\n\t      *coll_sym_alloc = new_coll_sym_alloc;\n\t    }\n\t  mbcset->coll_syms[mbcset->ncoll_syms++] = idx;\n\t  return REG_NOERROR;\n\t}\n      else\n\t{\n\t  if (BE (name_len != 1, 0))\n\t    return REG_ECOLLATE;\n\t  else\n\t    {\n\t      bitset_set (sbcset, name[0]);\n\t      return REG_NOERROR;\n\t    }\n\t}\n    }",
      "lines": 57,
      "depth": 12,
      "decorators": [
        "auto",
        "auto",
        "inline",
        "inline",
        "reg_errcode_t",
        "__attribute__ ((always_inline))",
        "__attribute__",
        "(",
        "(always_inline)",
        "(",
        "always_inline",
        ")",
        ")"
      ]
    },
    "parse_bracket_element": {
      "start_point": [
        3403,
        0
      ],
      "end_point": [
        3437,
        1
      ],
      "content": "static reg_errcode_t\nparse_bracket_element (bracket_elem_t *elem, re_string_t *regexp,\n\t\t       re_token_t *token, int token_len, re_dfa_t *dfa,\n\t\t       reg_syntax_t syntax, bool accept_hyphen)\n{\n#ifdef RE_ENABLE_I18N\n  int cur_char_size;\n  cur_char_size = re_string_char_size_at (regexp, re_string_cur_idx (regexp));\n  if (cur_char_size > 1)\n    {\n      elem->type = MB_CHAR;\n      elem->opr.wch = re_string_wchar_at (regexp, re_string_cur_idx (regexp));\n      re_string_skip_bytes (regexp, cur_char_size);\n      return REG_NOERROR;\n    }\n#endif /* RE_ENABLE_I18N */\n  re_string_skip_bytes (regexp, token_len); /* Skip a token.  */\n  if (token->type == OP_OPEN_COLL_ELEM || token->type == OP_OPEN_CHAR_CLASS\n      || token->type == OP_OPEN_EQUIV_CLASS)\n    return parse_bracket_symbol (elem, regexp, token);\n  if (BE (token->type == OP_CHARSET_RANGE, 0) && !accept_hyphen)\n    {\n      /* A '-' must only appear as anything but a range indicator before\n\t the closing bracket.  Everything else is an error.  */\n      re_token_t token2;\n      (void) peek_token_bracket (&token2, regexp, syntax);\n      if (token2.type != OP_CLOSE_BRACKET)\n\t/* The actual error value is not standardized since this whole\n\t   case is undefined.  But ERANGE makes good sense.  */\n\treturn REG_ERANGE;\n    }\n  elem->type = SB_CHAR;\n  elem->opr.ch = token->opr.c;\n  return REG_NOERROR;\n}",
      "lines": 35,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "parse_bracket_symbol": {
      "start_point": [
        3443,
        0
      ],
      "end_point": [
        3482,
        1
      ],
      "content": "static reg_errcode_t\nparse_bracket_symbol (bracket_elem_t *elem, re_string_t *regexp,\n\t\t      re_token_t *token)\n{\n  unsigned char ch, delim = token->opr.c;\n  int i = 0;\n  if (re_string_eoi(regexp))\n    return REG_EBRACK;\n  for (;; ++i)\n    {\n      if (i >= BRACKET_NAME_BUF_SIZE)\n\treturn REG_EBRACK;\n      if (token->type == OP_OPEN_CHAR_CLASS)\n\tch = re_string_fetch_byte_case (regexp);\n      else\n\tch = re_string_fetch_byte (regexp);\n      if (re_string_eoi(regexp))\n\treturn REG_EBRACK;\n      if (ch == delim && re_string_peek_byte (regexp, 0) == ']')\n\tbreak;\n      elem->opr.name[i] = ch;\n    }\n  re_string_skip_bytes (regexp, 1);\n  elem->opr.name[i] = '\\0';\n  switch (token->type)\n    {\n    case OP_OPEN_COLL_ELEM:\n      elem->type = COLL_SYM;\n      break;\n    case OP_OPEN_EQUIV_CLASS:\n      elem->type = EQUIV_CLASS;\n      break;\n    case OP_OPEN_CHAR_CLASS:\n      elem->type = CHAR_CLASS;\n      break;\n    default:\n      break;\n    }\n  return REG_NOERROR;\n}",
      "lines": 40,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "build_charclass": {
      "start_point": [
        3590,
        9
      ],
      "end_point": [
        3664,
        1
      ],
      "content": "char *class_name, reg_syntax_t syntax)\n#endif /* not RE_ENABLE_I18N */\n{\n  int i;\n  const char *name = class_name;\n\n  /* In case of REG_ICASE \"upper\" and \"lower\" match the both of\n     upper and lower cases.  */\n  if ((syntax & RE_ICASE)\n      && (strcmp (name, \"upper\") == 0 || strcmp (name, \"lower\") == 0))\n    name = \"alpha\";\n\n#ifdef RE_ENABLE_I18N\n  /* Check the space of the arrays.  */\n  if (BE (*char_class_alloc == mbcset->nchar_classes, 0))\n    {\n      /* Not enough, realloc it.  */\n      /* +1 in case of mbcset->nchar_classes is 0.  */\n      Idx new_char_class_alloc = 2 * mbcset->nchar_classes + 1;\n      /* Use realloc since array is NULL if *alloc == 0.  */\n      wctype_t *new_char_classes = re_realloc (mbcset->char_classes, wctype_t,\n\t\t\t\t\t       new_char_class_alloc);\n      if (BE (new_char_classes == NULL, 0))\n\treturn REG_ESPACE;\n      mbcset->char_classes = new_char_classes;\n      *char_class_alloc = new_char_class_alloc;\n    }\n  mbcset->char_classes[mbcset->nchar_classes++] = __wctype (name);\n#endif /* RE_ENABLE_I18N */\n\n#define BUILD_CHARCLASS_LOOP(ctype_func)\t\\\n  do {\t\t\t\t\t\t\\\n    if (BE (trans != NULL, 0))\t\t\t\\\n      {\t\t\t\t\t\t\\\n\tfor (i = 0; i < SBC_MAX; ++i)\t\t\\\n\t  if (ctype_func (i))\t\t\t\\\n\t    bitset_set (sbcset, trans[i]);\t\\\n      }\t\t\t\t\t\t\\\n    else\t\t\t\t\t\\\n      {\t\t\t\t\t\t\\\n\tfor (i = 0; i < SBC_MAX; ++i)\t\t\\\n\t  if (ctype_func (i))\t\t\t\\\n\t    bitset_set (sbcset, i);\t\t\\\n      }\t\t\t\t\t\t\\\n  } while (0)\n\n  if (strcmp (name, \"alnum\") == 0)\n    BUILD_CHARCLASS_LOOP (isalnum);\n  else if (strcmp (name, \"cntrl\") == 0)\n    BUILD_CHARCLASS_LOOP (iscntrl);\n  else if (strcmp (name, \"lower\") == 0)\n    BUILD_CHARCLASS_LOOP (islower);\n  else if (strcmp (name, \"space\") == 0)\n    BUILD_CHARCLASS_LOOP (isspace);\n  else if (strcmp (name, \"alpha\") == 0)\n    BUILD_CHARCLASS_LOOP (isalpha);\n  else if (strcmp (name, \"digit\") == 0)\n    BUILD_CHARCLASS_LOOP (isdigit);\n  else if (strcmp (name, \"print\") == 0)\n    BUILD_CHARCLASS_LOOP (isprint);\n  else if (strcmp (name, \"upper\") == 0)\n    BUILD_CHARCLASS_LOOP (isupper);\n  else if (strcmp (name, \"blank\") == 0)\n    BUILD_CHARCLASS_LOOP (isblank);\n  else if (strcmp (name, \"graph\") == 0)\n    BUILD_CHARCLASS_LOOP (isgraph);\n  else if (strcmp (name, \"punct\") == 0)\n    BUILD_CHARCLASS_LOOP (ispunct);\n  else if (strcmp (name, \"xdigit\") == 0)\n    BUILD_CHARCLASS_LOOP (isxdigit);\n  else\n    return REG_ECTYPE;\n\n  return REG_NOERROR;\n}",
      "lines": 75,
      "depth": 20,
      "decorators": null
    },
    "build_charclass_op": {
      "start_point": [
        3666,
        0
      ],
      "end_point": [
        3770,
        1
      ],
      "content": "static bin_tree_t *\nbuild_charclass_op (re_dfa_t *dfa, RE_TRANSLATE_TYPE trans,\n\t\t    const char *class_name,\n\t\t    const char *extra, bool non_match,\n\t\t    reg_errcode_t *err)\n{\n  re_bitset_ptr_t sbcset;\n#ifdef RE_ENABLE_I18N\n  re_charset_t *mbcset;\n  Idx alloc = 0;\n#endif /* not RE_ENABLE_I18N */\n  reg_errcode_t ret;\n  re_token_t br_token;\n  bin_tree_t *tree;\n\n  sbcset = (re_bitset_ptr_t) calloc (sizeof (bitset_t), 1);\n  if (BE (sbcset == NULL, 0))\n    {\n      *err = REG_ESPACE;\n      return NULL;\n    }\n#ifdef RE_ENABLE_I18N\n  mbcset = (re_charset_t *) calloc (sizeof (re_charset_t), 1);\n  if (BE (mbcset == NULL, 0))\n    {\n      re_free (sbcset);\n      *err = REG_ESPACE;\n      return NULL;\n    }\n  mbcset->non_match = non_match;\n#endif /* RE_ENABLE_I18N */\n\n  /* We don't care the syntax in this case.  */\n  ret = build_charclass (trans, sbcset,\n#ifdef RE_ENABLE_I18N\n\t\t\t mbcset, &alloc,\n#endif /* RE_ENABLE_I18N */\n\t\t\t class_name, 0);\n\n  if (BE (ret != REG_NOERROR, 0))\n    {\n      re_free (sbcset);\n#ifdef RE_ENABLE_I18N\n      free_charset (mbcset);\n#endif /* RE_ENABLE_I18N */\n      *err = ret;\n      return NULL;\n    }\n  /* \\w match '_' also.  */\n  for (; *extra; extra++)\n    bitset_set (sbcset, *extra);\n\n  /* If it is non-matching list.  */\n  if (non_match)\n    bitset_not (sbcset);\n\n#ifdef RE_ENABLE_I18N\n  /* Ensure only single byte characters are set.  */\n  if (dfa->mb_cur_max > 1)\n    bitset_mask (sbcset, dfa->sb_char);\n#endif\n\n  /* Build a tree for simple bracket.  */\n#if defined GCC_LINT || defined lint\n  memset (&br_token, 0, sizeof br_token);\n#endif\n  br_token.type = SIMPLE_BRACKET;\n  br_token.opr.sbcset = sbcset;\n  tree = create_token_tree (dfa, NULL, NULL, &br_token);\n  if (BE (tree == NULL, 0))\n    goto build_word_op_espace;\n\n#ifdef RE_ENABLE_I18N\n  if (dfa->mb_cur_max > 1)\n    {\n      bin_tree_t *mbc_tree;\n      /* Build a tree for complex bracket.  */\n      br_token.type = COMPLEX_BRACKET;\n      br_token.opr.mbcset = mbcset;\n      dfa->has_mb_node = 1;\n      mbc_tree = create_token_tree (dfa, NULL, NULL, &br_token);\n      if (BE (mbc_tree == NULL, 0))\n\tgoto build_word_op_espace;\n      /* Then join them by ALT node.  */\n      tree = create_tree (dfa, tree, mbc_tree, OP_ALT);\n      if (BE (mbc_tree != NULL, 1))\n\treturn tree;\n    }\n  else\n    {\n      free_charset (mbcset);\n      return tree;\n    }\n#else /* not RE_ENABLE_I18N */\n  return tree;\n#endif /* not RE_ENABLE_I18N */\n\n build_word_op_espace:\n  re_free (sbcset);\n#ifdef RE_ENABLE_I18N\n  free_charset (mbcset);\n#endif /* RE_ENABLE_I18N */\n  *err = REG_ESPACE;\n  return NULL;\n}",
      "lines": 105,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\nbuild_charclass_op (re_dfa_t *dfa, RE_TRANSLATE_TYPE trans,\n\t\t    const char *class_name,\n\t\t    const char *extra, bool non_match,\n\t\t    reg_errcode_t *err)",
        "*"
      ]
    },
    "fetch_number": {
      "start_point": [
        3778,
        0
      ],
      "end_point": [
        3798,
        1
      ],
      "content": "static Idx\nfetch_number (re_string_t *input, re_token_t *token, reg_syntax_t syntax)\n{\n  Idx num = -1;\n  unsigned char c;\n  while (1)\n    {\n      fetch_token (token, input, syntax);\n      c = token->opr.c;\n      if (BE (token->type == END_OF_RE, 0))\n\treturn -2;\n      if (token->type == OP_CLOSE_DUP_NUM || c == ',')\n\tbreak;\n      num = ((token->type != CHARACTER || c < '0' || '9' < c || num == -2)\n\t     ? -2\n\t     : num == -1\n\t     ? c - '0'\n\t     : MIN (RE_DUP_MAX + 1, num * 10 + c - '0'));\n    }\n  return num;\n}",
      "lines": 21,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "Idx"
      ]
    },
    "free_charset": {
      "start_point": [
        3801,
        0
      ],
      "end_point": [
        3813,
        1
      ],
      "content": "static void\nfree_charset (re_charset_t *cset)\n{\n  re_free (cset->mbchars);\n# ifdef _LIBC\n  re_free (cset->coll_syms);\n  re_free (cset->equiv_classes);\n  re_free (cset->range_starts);\n  re_free (cset->range_ends);\n# endif\n  re_free (cset->char_classes);\n  re_free (cset);\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "create_tree": {
      "start_point": [
        3820,
        0
      ],
      "end_point": [
        3830,
        1
      ],
      "content": "static bin_tree_t *\ncreate_tree (re_dfa_t *dfa, bin_tree_t *left, bin_tree_t *right,\n\t     re_token_type_t type)\n{\n  re_token_t t;\n#if defined GCC_LINT || defined lint\n  memset (&t, 0, sizeof t);\n#endif\n  t.type = type;\n  return create_token_tree (dfa, left, right, &t);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\ncreate_tree (re_dfa_t *dfa, bin_tree_t *left, bin_tree_t *right,\n\t     re_token_type_t type)",
        "*"
      ]
    },
    "create_token_tree": {
      "start_point": [
        3832,
        0
      ],
      "end_point": [
        3864,
        1
      ],
      "content": "static bin_tree_t *\ncreate_token_tree (re_dfa_t *dfa, bin_tree_t *left, bin_tree_t *right,\n\t\t   const re_token_t *token)\n{\n  bin_tree_t *tree;\n  if (BE (dfa->str_tree_storage_idx == BIN_TREE_STORAGE_SIZE, 0))\n    {\n      bin_tree_storage_t *storage = re_malloc (bin_tree_storage_t, 1);\n\n      if (storage == NULL)\n\treturn NULL;\n      storage->next = dfa->str_tree_storage;\n      dfa->str_tree_storage = storage;\n      dfa->str_tree_storage_idx = 0;\n    }\n  tree = &dfa->str_tree_storage->data[dfa->str_tree_storage_idx++];\n\n  tree->parent = NULL;\n  tree->left = left;\n  tree->right = right;\n  tree->token = *token;\n  tree->token.duplicated = 0;\n  tree->token.opt_subexp = 0;\n  tree->first = NULL;\n  tree->next = NULL;\n  tree->node_idx = -1;\n\n  if (left != NULL)\n    left->parent = tree;\n  if (right != NULL)\n    right->parent = tree;\n  return tree;\n}",
      "lines": 33,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\ncreate_token_tree (re_dfa_t *dfa, bin_tree_t *left, bin_tree_t *right,\n\t\t   const re_token_t *token)",
        "*"
      ]
    },
    "mark_opt_subexp": {
      "start_point": [
        3869,
        0
      ],
      "end_point": [
        3877,
        1
      ],
      "content": "static reg_errcode_t\nmark_opt_subexp (void *extra, bin_tree_t *node)\n{\n  Idx idx = (uintptr_t) extra;\n  if (node->token.type == SUBEXP && node->token.opr.idx == idx)\n    node->token.opt_subexp = 1;\n\n  return REG_NOERROR;\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "free_token": {
      "start_point": [
        3881,
        0
      ],
      "end_point": [
        3891,
        1
      ],
      "content": "static void\nfree_token (re_token_t *node)\n{\n#ifdef RE_ENABLE_I18N\n  if (node->type == COMPLEX_BRACKET && node->duplicated == 0)\n    free_charset (node->opr.mbcset);\n  else\n#endif /* RE_ENABLE_I18N */\n    if (node->type == SIMPLE_BRACKET && node->duplicated == 0)\n      re_free (node->opr.sbcset);\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "free_tree": {
      "start_point": [
        3896,
        0
      ],
      "end_point": [
        3901,
        1
      ],
      "content": "static reg_errcode_t\nfree_tree (void *extra, bin_tree_t *node)\n{\n  free_token (&node->token);\n  return REG_NOERROR;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "duplicate_tree": {
      "start_point": [
        3909,
        0
      ],
      "end_point": [
        3947,
        1
      ],
      "content": "static bin_tree_t *\nduplicate_tree (const bin_tree_t *root, re_dfa_t *dfa)\n{\n  const bin_tree_t *node;\n  bin_tree_t *dup_root;\n  bin_tree_t **p_new = &dup_root, *dup_node = root->parent;\n\n  for (node = root; ; )\n    {\n      /* Create a new tree and link it back to the current parent.  */\n      *p_new = create_token_tree (dfa, NULL, NULL, &node->token);\n      if (*p_new == NULL)\n\treturn NULL;\n      (*p_new)->parent = dup_node;\n      (*p_new)->token.duplicated = 1;\n      dup_node = *p_new;\n\n      /* Go to the left node, or up and to the right.  */\n      if (node->left)\n\t{\n\t  node = node->left;\n\t  p_new = &dup_node->left;\n\t}\n      else\n\t{\n\t  const bin_tree_t *prev = NULL;\n\t  while (node->right == prev || node->right == NULL)\n\t    {\n\t      prev = node;\n\t      node = node->parent;\n\t      dup_node = dup_node->parent;\n\t      if (!node)\n\t\treturn dup_root;\n\t    }\n\t  node = node->right;\n\t  p_new = &dup_node->right;\n\t}\n    }\n}",
      "lines": 39,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\nduplicate_tree (const bin_tree_t *root, re_dfa_t *dfa)",
        "*"
      ]
    }
  },
  "sed/sed-4.5/lib/regex.c": {},
  "sed/sed-4.5/lib/regex.h": {},
  "sed/sed-4.5/lib/regexec.c": {
    "regexec": {
      "start_point": [
        190,
        0
      ],
      "end_point": [
        221,
        1
      ],
      "content": "int\nregexec (const regex_t *_Restrict_ preg, const char *_Restrict_ string,\n\t size_t nmatch, regmatch_t pmatch[], int eflags)\n{\n  reg_errcode_t err;\n  Idx start, length;\n  re_dfa_t *dfa = preg->buffer;\n\n  if (eflags & ~(REG_NOTBOL | REG_NOTEOL | REG_STARTEND))\n    return REG_BADPAT;\n\n  if (eflags & REG_STARTEND)\n    {\n      start = pmatch[0].rm_so;\n      length = pmatch[0].rm_eo;\n    }\n  else\n    {\n      start = 0;\n      length = strlen (string);\n    }\n\n  lock_lock (dfa->lock);\n  if (preg->no_sub)\n    err = re_search_internal (preg, string, length, start, length,\n\t\t\t      length, 0, NULL, eflags);\n  else\n    err = re_search_internal (preg, string, length, start, length,\n\t\t\t      length, nmatch, pmatch, eflags);\n  lock_unlock (dfa->lock);\n  return err != REG_NOERROR;\n}",
      "lines": 32,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "__compat_regexec": {
      "start_point": [
        232,
        0
      ],
      "end_point": [
        240,
        1
      ],
      "content": "int\nattribute_compat_text_section\n__compat_regexec (const regex_t *_Restrict_ preg,\n\t\t  const char *_Restrict_ string, size_t nmatch,\n\t\t  regmatch_t pmatch[], int eflags)\n{\n  return regexec (preg, string, nmatch, pmatch,\n\t\t  eflags & (REG_NOTBOL | REG_NOTEOL));\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "int",
        "attribute_compat_text_section",
        "attribute_compat_text_section"
      ]
    },
    "re_match": {
      "start_point": [
        274,
        0
      ],
      "end_point": [
        279,
        1
      ],
      "content": "regoff_t\nre_match (struct re_pattern_buffer *bufp, const char *string, Idx length,\n\t  Idx start, struct re_registers *regs)\n{\n  return re_search_stub (bufp, string, length, start, 0, length, regs, true);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "regoff_t"
      ]
    },
    "re_search": {
      "start_point": [
        284,
        0
      ],
      "end_point": [
        290,
        1
      ],
      "content": "regoff_t\nre_search (struct re_pattern_buffer *bufp, const char *string, Idx length,\n\t   Idx start, regoff_t range, struct re_registers *regs)\n{\n  return re_search_stub (bufp, string, length, start, range, length, regs,\n\t\t\t false);\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "regoff_t"
      ]
    },
    "re_match_2": {
      "start_point": [
        295,
        0
      ],
      "end_point": [
        302,
        1
      ],
      "content": "regoff_t\nre_match_2 (struct re_pattern_buffer *bufp, const char *string1, Idx length1,\n\t    const char *string2, Idx length2, Idx start,\n\t    struct re_registers *regs, Idx stop)\n{\n  return re_search_2_stub (bufp, string1, length1, string2, length2,\n\t\t\t   start, 0, regs, stop, true);\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "regoff_t"
      ]
    },
    "re_search_2": {
      "start_point": [
        307,
        0
      ],
      "end_point": [
        314,
        1
      ],
      "content": "regoff_t\nre_search_2 (struct re_pattern_buffer *bufp, const char *string1, Idx length1,\n\t     const char *string2, Idx length2, Idx start, regoff_t range,\n\t     struct re_registers *regs, Idx stop)\n{\n  return re_search_2_stub (bufp, string1, length1, string2, length2,\n\t\t\t   start, range, regs, stop, false);\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "regoff_t"
      ]
    },
    "re_search_2_stub": {
      "start_point": [
        319,
        0
      ],
      "end_point": [
        360,
        1
      ],
      "content": "static regoff_t\nre_search_2_stub (struct re_pattern_buffer *bufp, const char *string1,\n\t\t  Idx length1, const char *string2, Idx length2, Idx start,\n\t\t  regoff_t range, struct re_registers *regs,\n\t\t  Idx stop, bool ret_len)\n{\n  const char *str;\n  regoff_t rval;\n  Idx len;\n  char *s = NULL;\n\n  if (BE ((length1 < 0 || length2 < 0 || stop < 0\n           || INT_ADD_WRAPV (length1, length2, &len)),\n          0))\n    return -2;\n\n  /* Concatenate the strings.  */\n  if (length2 > 0)\n    if (length1 > 0)\n      {\n\ts = re_malloc (char, len);\n\n\tif (BE (s == NULL, 0))\n\t  return -2;\n#ifdef _LIBC\n\tmemcpy (__mempcpy (s, string1, length1), string2, length2);\n#else\n\tmemcpy (s, string1, length1);\n\tmemcpy (s + length1, string2, length2);\n#endif\n\tstr = s;\n      }\n    else\n      str = string2;\n  else\n    str = string1;\n\n  rval = re_search_stub (bufp, str, len, start, range, stop, regs,\n\t\t\t ret_len);\n  re_free (s);\n  return rval;\n}",
      "lines": 42,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "regoff_t"
      ]
    },
    "re_search_stub": {
      "start_point": [
        367,
        0
      ],
      "end_point": [
        454,
        1
      ],
      "content": "static regoff_t\nre_search_stub (struct re_pattern_buffer *bufp, const char *string, Idx length,\n\t\tIdx start, regoff_t range, Idx stop, struct re_registers *regs,\n\t\tbool ret_len)\n{\n  reg_errcode_t result;\n  regmatch_t *pmatch;\n  Idx nregs;\n  regoff_t rval;\n  int eflags = 0;\n  re_dfa_t *dfa = bufp->buffer;\n  Idx last_start = start + range;\n\n  /* Check for out-of-range.  */\n  if (BE (start < 0 || start > length, 0))\n    return -1;\n  if (BE (length < last_start || (0 <= range && last_start < start), 0))\n    last_start = length;\n  else if (BE (last_start < 0 || (range < 0 && start <= last_start), 0))\n    last_start = 0;\n\n  lock_lock (dfa->lock);\n\n  eflags |= (bufp->not_bol) ? REG_NOTBOL : 0;\n  eflags |= (bufp->not_eol) ? REG_NOTEOL : 0;\n\n  /* Compile fastmap if we haven't yet.  */\n  if (start < last_start && bufp->fastmap != NULL && !bufp->fastmap_accurate)\n    re_compile_fastmap (bufp);\n\n  if (BE (bufp->no_sub, 0))\n    regs = NULL;\n\n  /* We need at least 1 register.  */\n  if (regs == NULL)\n    nregs = 1;\n  else if (BE (bufp->regs_allocated == REGS_FIXED\n\t       && regs->num_regs <= bufp->re_nsub, 0))\n    {\n      nregs = regs->num_regs;\n      if (BE (nregs < 1, 0))\n\t{\n\t  /* Nothing can be copied to regs.  */\n\t  regs = NULL;\n\t  nregs = 1;\n\t}\n    }\n  else\n    nregs = bufp->re_nsub + 1;\n  pmatch = re_malloc (regmatch_t, nregs);\n  if (BE (pmatch == NULL, 0))\n    {\n      rval = -2;\n      goto out;\n    }\n\n  result = re_search_internal (bufp, string, length, start, last_start, stop,\n\t\t\t       nregs, pmatch, eflags);\n\n  rval = 0;\n\n  /* I hope we needn't fill their regs with -1's when no match was found.  */\n  if (result != REG_NOERROR)\n    rval = result == REG_NOMATCH ? -1 : -2;\n  else if (regs != NULL)\n    {\n      /* If caller wants register contents data back, copy them.  */\n      bufp->regs_allocated = re_copy_regs (regs, pmatch, nregs,\n\t\t\t\t\t   bufp->regs_allocated);\n      if (BE (bufp->regs_allocated == REGS_UNALLOCATED, 0))\n\trval = -2;\n    }\n\n  if (BE (rval == 0, 1))\n    {\n      if (ret_len)\n\t{\n\t  assert (pmatch[0].rm_so == start);\n\t  rval = pmatch[0].rm_eo - start;\n\t}\n      else\n\trval = pmatch[0].rm_so;\n    }\n  re_free (pmatch);\n out:\n  lock_unlock (dfa->lock);\n  return rval;\n}",
      "lines": 88,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "regoff_t"
      ]
    },
    "re_copy_regs": {
      "start_point": [
        456,
        0
      ],
      "end_point": [
        519,
        1
      ],
      "content": "static unsigned\nre_copy_regs (struct re_registers *regs, regmatch_t *pmatch, Idx nregs,\n\t      int regs_allocated)\n{\n  int rval = REGS_REALLOCATE;\n  Idx i;\n  Idx need_regs = nregs + 1;\n  /* We need one extra element beyond 'num_regs' for the '-1' marker GNU code\n     uses.  */\n\n  /* Have the register data arrays been allocated?  */\n  if (regs_allocated == REGS_UNALLOCATED)\n    { /* No.  So allocate them with malloc.  */\n      regs->start = re_malloc (regoff_t, need_regs);\n      if (BE (regs->start == NULL, 0))\n\treturn REGS_UNALLOCATED;\n      regs->end = re_malloc (regoff_t, need_regs);\n      if (BE (regs->end == NULL, 0))\n\t{\n\t  re_free (regs->start);\n\t  return REGS_UNALLOCATED;\n\t}\n      regs->num_regs = need_regs;\n    }\n  else if (regs_allocated == REGS_REALLOCATE)\n    { /* Yes.  If we need more elements than were already\n\t allocated, reallocate them.  If we need fewer, just\n\t leave it alone.  */\n      if (BE (need_regs > regs->num_regs, 0))\n\t{\n\t  regoff_t *new_start = re_realloc (regs->start, regoff_t, need_regs);\n\t  regoff_t *new_end;\n\t  if (BE (new_start == NULL, 0))\n\t    return REGS_UNALLOCATED;\n\t  new_end = re_realloc (regs->end, regoff_t, need_regs);\n\t  if (BE (new_end == NULL, 0))\n\t    {\n\t      re_free (new_start);\n\t      return REGS_UNALLOCATED;\n\t    }\n\t  regs->start = new_start;\n\t  regs->end = new_end;\n\t  regs->num_regs = need_regs;\n\t}\n    }\n  else\n    {\n      assert (regs_allocated == REGS_FIXED);\n      /* This function may not be called with REGS_FIXED and nregs too big.  */\n      assert (regs->num_regs >= nregs);\n      rval = REGS_FIXED;\n    }\n\n  /* Copy the regs.  */\n  for (i = 0; i < nregs; ++i)\n    {\n      regs->start[i] = pmatch[i].rm_so;\n      regs->end[i] = pmatch[i].rm_eo;\n    }\n  for ( ; i < regs->num_regs; ++i)\n    regs->start[i] = regs->end[i] = -1;\n\n  return rval;\n}",
      "lines": 64,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "unsigned",
        "unsigned"
      ]
    },
    "re_set_registers": {
      "start_point": [
        534,
        0
      ],
      "end_point": [
        551,
        1
      ],
      "content": "void\nre_set_registers (struct re_pattern_buffer *bufp, struct re_registers *regs,\n\t\t  __re_size_t num_regs, regoff_t *starts, regoff_t *ends)\n{\n  if (num_regs)\n    {\n      bufp->regs_allocated = REGS_REALLOCATE;\n      regs->num_regs = num_regs;\n      regs->start = starts;\n      regs->end = ends;\n    }\n  else\n    {\n      bufp->regs_allocated = REGS_UNALLOCATED;\n      regs->num_regs = 0;\n      regs->start = regs->end = NULL;\n    }\n}",
      "lines": 18,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "re_exec": {
      "start_point": [
        562,
        0
      ],
      "end_point": [
        567,
        1
      ],
      "content": "weak_function\n# endif\nre_exec (const char *s)\n{\n  return 0 == regexec (&re_comp_buf, s, 0, NULL, 0);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "weak_function",
        "# endif",
        "# endif"
      ]
    },
    "re_search_internal": {
      "start_point": [
        581,
        0
      ],
      "end_point": [
        913,
        1
      ],
      "content": "static reg_errcode_t\n__attribute_warn_unused_result__\nre_search_internal (const regex_t *preg, const char *string, Idx length,\n\t\t    Idx start, Idx last_start, Idx stop, size_t nmatch,\n\t\t    regmatch_t pmatch[], int eflags)\n{\n  reg_errcode_t err;\n  const re_dfa_t *dfa = preg->buffer;\n  Idx left_lim, right_lim;\n  int incr;\n  bool fl_longest_match;\n  int match_kind;\n  Idx match_first;\n  Idx match_last = -1;\n  Idx extra_nmatch;\n  bool sb;\n  int ch;\n#if defined _LIBC || (defined __STDC_VERSION__ && __STDC_VERSION__ >= 199901L)\n  re_match_context_t mctx = { .dfa = dfa };\n#else\n  re_match_context_t mctx;\n#endif\n  char *fastmap = ((preg->fastmap != NULL && preg->fastmap_accurate\n\t\t    && start != last_start && !preg->can_be_null)\n\t\t   ? preg->fastmap : NULL);\n  RE_TRANSLATE_TYPE t = preg->translate;\n\n#if !(defined _LIBC || (defined __STDC_VERSION__ && __STDC_VERSION__ >= 199901L))\n  memset (&mctx, '\\0', sizeof (re_match_context_t));\n  mctx.dfa = dfa;\n#endif\n\n  extra_nmatch = (nmatch > preg->re_nsub) ? nmatch - (preg->re_nsub + 1) : 0;\n  nmatch -= extra_nmatch;\n\n  /* Check if the DFA haven't been compiled.  */\n  if (BE (preg->used == 0 || dfa->init_state == NULL\n\t  || dfa->init_state_word == NULL || dfa->init_state_nl == NULL\n\t  || dfa->init_state_begbuf == NULL, 0))\n    return REG_NOMATCH;\n\n#ifdef DEBUG\n  /* We assume front-end functions already check them.  */\n  assert (0 <= last_start && last_start <= length);\n#endif\n\n  /* If initial states with non-begbuf contexts have no elements,\n     the regex must be anchored.  If preg->newline_anchor is set,\n     we'll never use init_state_nl, so do not check it.  */\n  if (dfa->init_state->nodes.nelem == 0\n      && dfa->init_state_word->nodes.nelem == 0\n      && (dfa->init_state_nl->nodes.nelem == 0\n\t  || !preg->newline_anchor))\n    {\n      if (start != 0 && last_start != 0)\n        return REG_NOMATCH;\n      start = last_start = 0;\n    }\n\n  /* We must check the longest matching, if nmatch > 0.  */\n  fl_longest_match = (nmatch != 0 || dfa->nbackref);\n\n  err = re_string_allocate (&mctx.input, string, length, dfa->nodes_len + 1,\n\t\t\t    preg->translate, (preg->syntax & RE_ICASE) != 0,\n\t\t\t    dfa);\n  if (BE (err != REG_NOERROR, 0))\n    goto free_return;\n  mctx.input.stop = stop;\n  mctx.input.raw_stop = stop;\n  mctx.input.newline_anchor = preg->newline_anchor;\n\n  err = match_ctx_init (&mctx, eflags, dfa->nbackref * 2);\n  if (BE (err != REG_NOERROR, 0))\n    goto free_return;\n\n  /* We will log all the DFA states through which the dfa pass,\n     if nmatch > 1, or this dfa has \"multibyte node\", which is a\n     back-reference or a node which can accept multibyte character or\n     multi character collating element.  */\n  if (nmatch > 1 || dfa->has_mb_node)\n    {\n      /* Avoid overflow.  */\n      if (BE ((MIN (IDX_MAX, SIZE_MAX / sizeof (re_dfastate_t *))\n               <= mctx.input.bufs_len), 0))\n\t{\n\t  err = REG_ESPACE;\n\t  goto free_return;\n\t}\n\n      mctx.state_log = re_malloc (re_dfastate_t *, mctx.input.bufs_len + 1);\n      if (BE (mctx.state_log == NULL, 0))\n\t{\n\t  err = REG_ESPACE;\n\t  goto free_return;\n\t}\n    }\n  else\n    mctx.state_log = NULL;\n\n  match_first = start;\n  mctx.input.tip_context = (eflags & REG_NOTBOL) ? CONTEXT_BEGBUF\n\t\t\t   : CONTEXT_NEWLINE | CONTEXT_BEGBUF;\n\n  /* Check incrementally whether the input string matches.  */\n  incr = (last_start < start) ? -1 : 1;\n  left_lim = (last_start < start) ? last_start : start;\n  right_lim = (last_start < start) ? start : last_start;\n  sb = dfa->mb_cur_max == 1;\n  match_kind =\n    (fastmap\n     ? ((sb || !(preg->syntax & RE_ICASE || t) ? 4 : 0)\n\t| (start <= last_start ? 2 : 0)\n\t| (t != NULL ? 1 : 0))\n     : 8);\n\n  for (;; match_first += incr)\n    {\n      err = REG_NOMATCH;\n      if (match_first < left_lim || right_lim < match_first)\n\tgoto free_return;\n\n      /* Advance as rapidly as possible through the string, until we\n\t find a plausible place to start matching.  This may be done\n\t with varying efficiency, so there are various possibilities:\n\t only the most common of them are specialized, in order to\n\t save on code size.  We use a switch statement for speed.  */\n      switch (match_kind)\n\t{\n\tcase 8:\n\t  /* No fastmap.  */\n\t  break;\n\n\tcase 7:\n\t  /* Fastmap with single-byte translation, match forward.  */\n\t  while (BE (match_first < right_lim, 1)\n\t\t && !fastmap[t[(unsigned char) string[match_first]]])\n\t    ++match_first;\n\t  goto forward_match_found_start_or_reached_end;\n\n\tcase 6:\n\t  /* Fastmap without translation, match forward.  */\n\t  while (BE (match_first < right_lim, 1)\n\t\t && !fastmap[(unsigned char) string[match_first]])\n\t    ++match_first;\n\n\tforward_match_found_start_or_reached_end:\n\t  if (BE (match_first == right_lim, 0))\n\t    {\n\t      ch = match_first >= length\n\t\t       ? 0 : (unsigned char) string[match_first];\n\t      if (!fastmap[t ? t[ch] : ch])\n\t\tgoto free_return;\n\t    }\n\t  break;\n\n\tcase 4:\n\tcase 5:\n\t  /* Fastmap without multi-byte translation, match backwards.  */\n\t  while (match_first >= left_lim)\n\t    {\n\t      ch = match_first >= length\n\t\t       ? 0 : (unsigned char) string[match_first];\n\t      if (fastmap[t ? t[ch] : ch])\n\t\tbreak;\n\t      --match_first;\n\t    }\n\t  if (match_first < left_lim)\n\t    goto free_return;\n\t  break;\n\n\tdefault:\n\t  /* In this case, we can't determine easily the current byte,\n\t     since it might be a component byte of a multibyte\n\t     character.  Then we use the constructed buffer instead.  */\n\t  for (;;)\n\t    {\n\t      /* If MATCH_FIRST is out of the valid range, reconstruct the\n\t\t buffers.  */\n\t      __re_size_t offset = match_first - mctx.input.raw_mbs_idx;\n\t      if (BE (offset >= (__re_size_t) mctx.input.valid_raw_len, 0))\n\t\t{\n\t\t  err = re_string_reconstruct (&mctx.input, match_first,\n\t\t\t\t\t       eflags);\n\t\t  if (BE (err != REG_NOERROR, 0))\n\t\t    goto free_return;\n\n\t\t  offset = match_first - mctx.input.raw_mbs_idx;\n\t\t}\n\t      /* If MATCH_FIRST is out of the buffer, leave it as '\\0'.\n\t\t Note that MATCH_FIRST must not be smaller than 0.  */\n\t      ch = (match_first >= length\n\t\t    ? 0 : re_string_byte_at (&mctx.input, offset));\n\t      if (fastmap[ch])\n\t\tbreak;\n\t      match_first += incr;\n\t      if (match_first < left_lim || match_first > right_lim)\n\t\t{\n\t\t  err = REG_NOMATCH;\n\t\t  goto free_return;\n\t\t}\n\t    }\n\t  break;\n\t}\n\n      /* Reconstruct the buffers so that the matcher can assume that\n\t the matching starts from the beginning of the buffer.  */\n      err = re_string_reconstruct (&mctx.input, match_first, eflags);\n      if (BE (err != REG_NOERROR, 0))\n\tgoto free_return;\n\n#ifdef RE_ENABLE_I18N\n     /* Don't consider this char as a possible match start if it part,\n\tyet isn't the head, of a multibyte character.  */\n      if (!sb && !re_string_first_byte (&mctx.input, 0))\n\tcontinue;\n#endif\n\n      /* It seems to be appropriate one, then use the matcher.  */\n      /* We assume that the matching starts from 0.  */\n      mctx.state_log_top = mctx.nbkref_ents = mctx.max_mb_elem_len = 0;\n      match_last = check_matching (&mctx, fl_longest_match,\n\t\t\t\t   start <= last_start ? &match_first : NULL);\n      if (match_last != -1)\n\t{\n\t  if (BE (match_last == -2, 0))\n\t    {\n\t      err = REG_ESPACE;\n\t      goto free_return;\n\t    }\n\t  else\n\t    {\n\t      mctx.match_last = match_last;\n\t      if ((!preg->no_sub && nmatch > 1) || dfa->nbackref)\n\t\t{\n\t\t  re_dfastate_t *pstate = mctx.state_log[match_last];\n\t\t  mctx.last_node = check_halt_state_context (&mctx, pstate,\n\t\t\t\t\t\t\t     match_last);\n\t\t}\n\t      if ((!preg->no_sub && nmatch > 1 && dfa->has_plural_match)\n\t\t  || dfa->nbackref)\n\t\t{\n\t\t  err = prune_impossible_nodes (&mctx);\n\t\t  if (err == REG_NOERROR)\n\t\t    break;\n\t\t  if (BE (err != REG_NOMATCH, 0))\n\t\t    goto free_return;\n\t\t  match_last = -1;\n\t\t}\n\t      else\n\t\tbreak; /* We found a match.  */\n\t    }\n\t}\n\n      match_ctx_clean (&mctx);\n    }\n\n#ifdef DEBUG\n  assert (match_last != -1);\n  assert (err == REG_NOERROR);\n#endif\n\n  /* Set pmatch[] if we need.  */\n  if (nmatch > 0)\n    {\n      Idx reg_idx;\n\n      /* Initialize registers.  */\n      for (reg_idx = 1; reg_idx < nmatch; ++reg_idx)\n\tpmatch[reg_idx].rm_so = pmatch[reg_idx].rm_eo = -1;\n\n      /* Set the points where matching start/end.  */\n      pmatch[0].rm_so = 0;\n      pmatch[0].rm_eo = mctx.match_last;\n      /* FIXME: This function should fail if mctx.match_last exceeds\n\t the maximum possible regoff_t value.  We need a new error\n\t code REG_OVERFLOW.  */\n\n      if (!preg->no_sub && nmatch > 1)\n\t{\n\t  err = set_regs (preg, &mctx, nmatch, pmatch,\n\t\t\t  dfa->has_plural_match && dfa->nbackref > 0);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    goto free_return;\n\t}\n\n      /* At last, add the offset to each register, since we slid\n\t the buffers so that we could assume that the matching starts\n\t from 0.  */\n      for (reg_idx = 0; reg_idx < nmatch; ++reg_idx)\n\tif (pmatch[reg_idx].rm_so != -1)\n\t  {\n#ifdef RE_ENABLE_I18N\n\t    if (BE (mctx.input.offsets_needed != 0, 0))\n\t      {\n\t\tpmatch[reg_idx].rm_so =\n\t\t  (pmatch[reg_idx].rm_so == mctx.input.valid_len\n\t\t   ? mctx.input.valid_raw_len\n\t\t   : mctx.input.offsets[pmatch[reg_idx].rm_so]);\n\t\tpmatch[reg_idx].rm_eo =\n\t\t  (pmatch[reg_idx].rm_eo == mctx.input.valid_len\n\t\t   ? mctx.input.valid_raw_len\n\t\t   : mctx.input.offsets[pmatch[reg_idx].rm_eo]);\n\t      }\n#else\n\t    assert (mctx.input.offsets_needed == 0);\n#endif\n\t    pmatch[reg_idx].rm_so += match_first;\n\t    pmatch[reg_idx].rm_eo += match_first;\n\t  }\n      for (reg_idx = 0; reg_idx < extra_nmatch; ++reg_idx)\n\t{\n\t  pmatch[nmatch + reg_idx].rm_so = -1;\n\t  pmatch[nmatch + reg_idx].rm_eo = -1;\n\t}\n\n      if (dfa->subexp_map)\n\tfor (reg_idx = 0; reg_idx + 1 < nmatch; reg_idx++)\n\t  if (dfa->subexp_map[reg_idx] != reg_idx)\n\t    {\n\t      pmatch[reg_idx + 1].rm_so\n\t\t= pmatch[dfa->subexp_map[reg_idx] + 1].rm_so;\n\t      pmatch[reg_idx + 1].rm_eo\n\t\t= pmatch[dfa->subexp_map[reg_idx] + 1].rm_eo;\n\t    }\n    }\n\n free_return:\n  re_free (mctx.state_log);\n  if (dfa->nbackref)\n    match_ctx_free (&mctx);\n  re_string_destruct (&mctx.input);\n  return err;\n}",
      "lines": 333,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "__attribute_warn_unused_result__",
        "__attribute_warn_unused_result__"
      ]
    },
    "prune_impossible_nodes": {
      "start_point": [
        915,
        0
      ],
      "end_point": [
        1005,
        1
      ],
      "content": "static reg_errcode_t\n__attribute_warn_unused_result__\nprune_impossible_nodes (re_match_context_t *mctx)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  Idx halt_node, match_last;\n  reg_errcode_t ret;\n  re_dfastate_t **sifted_states;\n  re_dfastate_t **lim_states = NULL;\n  re_sift_context_t sctx;\n#ifdef DEBUG\n  assert (mctx->state_log != NULL);\n#endif\n  match_last = mctx->match_last;\n  halt_node = mctx->last_node;\n\n  /* Avoid overflow.  */\n  if (BE (MIN (IDX_MAX, SIZE_MAX / sizeof (re_dfastate_t *)) <= match_last, 0))\n    return REG_ESPACE;\n\n  sifted_states = re_malloc (re_dfastate_t *, match_last + 1);\n  if (BE (sifted_states == NULL, 0))\n    {\n      ret = REG_ESPACE;\n      goto free_return;\n    }\n  if (dfa->nbackref)\n    {\n      lim_states = re_malloc (re_dfastate_t *, match_last + 1);\n      if (BE (lim_states == NULL, 0))\n\t{\n\t  ret = REG_ESPACE;\n\t  goto free_return;\n\t}\n      while (1)\n\t{\n\t  memset (lim_states, '\\0',\n\t\t  sizeof (re_dfastate_t *) * (match_last + 1));\n\t  sift_ctx_init (&sctx, sifted_states, lim_states, halt_node,\n\t\t\t match_last);\n\t  ret = sift_states_backward (mctx, &sctx);\n\t  re_node_set_free (&sctx.limits);\n\t  if (BE (ret != REG_NOERROR, 0))\n\t      goto free_return;\n\t  if (sifted_states[0] != NULL || lim_states[0] != NULL)\n\t    break;\n\t  do\n\t    {\n\t      --match_last;\n\t      if (match_last < 0)\n\t\t{\n\t\t  ret = REG_NOMATCH;\n\t\t  goto free_return;\n\t\t}\n\t    } while (mctx->state_log[match_last] == NULL\n\t\t     || !mctx->state_log[match_last]->halt);\n\t  halt_node = check_halt_state_context (mctx,\n\t\t\t\t\t\tmctx->state_log[match_last],\n\t\t\t\t\t\tmatch_last);\n\t}\n      ret = merge_state_array (dfa, sifted_states, lim_states,\n\t\t\t       match_last + 1);\n      re_free (lim_states);\n      lim_states = NULL;\n      if (BE (ret != REG_NOERROR, 0))\n\tgoto free_return;\n    }\n  else\n    {\n      sift_ctx_init (&sctx, sifted_states, lim_states, halt_node, match_last);\n      ret = sift_states_backward (mctx, &sctx);\n      re_node_set_free (&sctx.limits);\n      if (BE (ret != REG_NOERROR, 0))\n\tgoto free_return;\n      if (sifted_states[0] == NULL)\n\t{\n\t  ret = REG_NOMATCH;\n\t  goto free_return;\n\t}\n    }\n  re_free (mctx->state_log);\n  mctx->state_log = sifted_states;\n  sifted_states = NULL;\n  mctx->last_node = halt_node;\n  mctx->match_last = match_last;\n  ret = REG_NOERROR;\n free_return:\n  re_free (sifted_states);\n  re_free (lim_states);\n  return ret;\n}",
      "lines": 91,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "__attribute_warn_unused_result__",
        "__attribute_warn_unused_result__"
      ]
    },
    "check_matching": {
      "start_point": [
        1053,
        0
      ],
      "end_point": [
        1182,
        1
      ],
      "content": "static Idx\n__attribute_warn_unused_result__\ncheck_matching (re_match_context_t *mctx, bool fl_longest_match,\n\t\tIdx *p_match_first)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  reg_errcode_t err;\n  Idx match = 0;\n  Idx match_last = -1;\n  Idx cur_str_idx = re_string_cur_idx (&mctx->input);\n  re_dfastate_t *cur_state;\n  bool at_init_state = p_match_first != NULL;\n  Idx next_start_idx = cur_str_idx;\n\n  err = REG_NOERROR;\n  cur_state = acquire_init_state_context (&err, mctx, cur_str_idx);\n  /* An initial state must not be NULL (invalid).  */\n  if (BE (cur_state == NULL, 0))\n    {\n      assert (err == REG_ESPACE);\n      return -2;\n    }\n\n  if (mctx->state_log != NULL)\n    {\n      mctx->state_log[cur_str_idx] = cur_state;\n\n      /* Check OP_OPEN_SUBEXP in the initial state in case that we use them\n\t later.  E.g. Processing back references.  */\n      if (BE (dfa->nbackref, 0))\n\t{\n\t  at_init_state = false;\n\t  err = check_subexp_matching_top (mctx, &cur_state->nodes, 0);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return err;\n\n\t  if (cur_state->has_backref)\n\t    {\n\t      err = transit_state_bkref (mctx, &cur_state->nodes);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\treturn err;\n\t    }\n\t}\n    }\n\n  /* If the RE accepts NULL string.  */\n  if (BE (cur_state->halt, 0))\n    {\n      if (!cur_state->has_constraint\n\t  || check_halt_state_context (mctx, cur_state, cur_str_idx))\n\t{\n\t  if (!fl_longest_match)\n\t    return cur_str_idx;\n\t  else\n\t    {\n\t      match_last = cur_str_idx;\n\t      match = 1;\n\t    }\n\t}\n    }\n\n  while (!re_string_eoi (&mctx->input))\n    {\n      re_dfastate_t *old_state = cur_state;\n      Idx next_char_idx = re_string_cur_idx (&mctx->input) + 1;\n\n      if ((BE (next_char_idx >= mctx->input.bufs_len, 0)\n\t   && mctx->input.bufs_len < mctx->input.len)\n\t  || (BE (next_char_idx >= mctx->input.valid_len, 0)\n\t      && mctx->input.valid_len < mctx->input.len))\n\t{\n\t  err = extend_buffers (mctx, next_char_idx + 1);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    {\n\t      assert (err == REG_ESPACE);\n\t      return -2;\n\t    }\n\t}\n\n      cur_state = transit_state (&err, mctx, cur_state);\n      if (mctx->state_log != NULL)\n\tcur_state = merge_state_with_log (&err, mctx, cur_state);\n\n      if (cur_state == NULL)\n\t{\n\t  /* Reached the invalid state or an error.  Try to recover a valid\n\t     state using the state log, if available and if we have not\n\t     already found a valid (even if not the longest) match.  */\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return -2;\n\n\t  if (mctx->state_log == NULL\n\t      || (match && !fl_longest_match)\n\t      || (cur_state = find_recover_state (&err, mctx)) == NULL)\n\t    break;\n\t}\n\n      if (BE (at_init_state, 0))\n\t{\n\t  if (old_state == cur_state)\n\t    next_start_idx = next_char_idx;\n\t  else\n\t    at_init_state = false;\n\t}\n\n      if (cur_state->halt)\n\t{\n\t  /* Reached a halt state.\n\t     Check the halt state can satisfy the current context.  */\n\t  if (!cur_state->has_constraint\n\t      || check_halt_state_context (mctx, cur_state,\n\t\t\t\t\t   re_string_cur_idx (&mctx->input)))\n\t    {\n\t      /* We found an appropriate halt state.  */\n\t      match_last = re_string_cur_idx (&mctx->input);\n\t      match = 1;\n\n\t      /* We found a match, do not modify match_first below.  */\n\t      p_match_first = NULL;\n\t      if (!fl_longest_match)\n\t\tbreak;\n\t    }\n\t}\n    }\n\n  if (p_match_first)\n    *p_match_first += next_start_idx;\n\n  return match_last;\n}",
      "lines": 130,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "Idx",
        "__attribute_warn_unused_result__",
        "__attribute_warn_unused_result__"
      ]
    },
    "check_halt_node_context": {
      "start_point": [
        1186,
        0
      ],
      "end_point": [
        1198,
        1
      ],
      "content": "static bool\ncheck_halt_node_context (const re_dfa_t *dfa, Idx node, unsigned int context)\n{\n  re_token_type_t type = dfa->nodes[node].type;\n  unsigned int constraint = dfa->nodes[node].constraint;\n  if (type != END_OF_RE)\n    return false;\n  if (!constraint)\n    return true;\n  if (NOT_SATISFY_NEXT_CONSTRAINT (constraint, context))\n    return false;\n  return true;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "check_halt_state_context": {
      "start_point": [
        1204,
        0
      ],
      "end_point": [
        1218,
        1
      ],
      "content": "static Idx\ncheck_halt_state_context (const re_match_context_t *mctx,\n\t\t\t  const re_dfastate_t *state, Idx idx)\n{\n  Idx i;\n  unsigned int context;\n#ifdef DEBUG\n  assert (state->halt);\n#endif\n  context = re_string_context_at (&mctx->input, idx, mctx->eflags);\n  for (i = 0; i < state->nodes.nelem; ++i)\n    if (check_halt_node_context (mctx->dfa, state->nodes.elems[i], context))\n      return state->nodes.elems[i];\n  return 0;\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "Idx"
      ]
    },
    "proceed_next_node": {
      "start_point": [
        1225,
        0
      ],
      "end_point": [
        1324,
        1
      ],
      "content": "static Idx\nproceed_next_node (const re_match_context_t *mctx, Idx nregs, regmatch_t *regs,\n\t\t   Idx *pidx, Idx node, re_node_set *eps_via_nodes,\n\t\t   struct re_fail_stack_t *fs)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  Idx i;\n  bool ok;\n  if (IS_EPSILON_NODE (dfa->nodes[node].type))\n    {\n      re_node_set *cur_nodes = &mctx->state_log[*pidx]->nodes;\n      re_node_set *edests = &dfa->edests[node];\n      Idx dest_node;\n      ok = re_node_set_insert (eps_via_nodes, node);\n      if (BE (! ok, 0))\n\treturn -2;\n      /* Pick up a valid destination, or return -1 if none\n\t is found.  */\n      for (dest_node = -1, i = 0; i < edests->nelem; ++i)\n\t{\n\t  Idx candidate = edests->elems[i];\n\t  if (!re_node_set_contains (cur_nodes, candidate))\n\t    continue;\n          if (dest_node == -1)\n\t    dest_node = candidate;\n\n\t  else\n\t    {\n\t      /* In order to avoid infinite loop like \"(a*)*\", return the second\n\t\t epsilon-transition if the first was already considered.  */\n\t      if (re_node_set_contains (eps_via_nodes, dest_node))\n\t\treturn candidate;\n\n\t      /* Otherwise, push the second epsilon-transition on the fail stack.  */\n\t      else if (fs != NULL\n\t\t       && push_fail_stack (fs, *pidx, candidate, nregs, regs,\n\t\t\t\t\t   eps_via_nodes))\n\t\treturn -2;\n\n\t      /* We know we are going to exit.  */\n\t      break;\n\t    }\n\t}\n      return dest_node;\n    }\n  else\n    {\n      Idx naccepted = 0;\n      re_token_type_t type = dfa->nodes[node].type;\n\n#ifdef RE_ENABLE_I18N\n      if (dfa->nodes[node].accept_mb)\n\tnaccepted = check_node_accept_bytes (dfa, node, &mctx->input, *pidx);\n      else\n#endif /* RE_ENABLE_I18N */\n      if (type == OP_BACK_REF)\n\t{\n\t  Idx subexp_idx = dfa->nodes[node].opr.idx + 1;\n\t  naccepted = regs[subexp_idx].rm_eo - regs[subexp_idx].rm_so;\n\t  if (fs != NULL)\n\t    {\n\t      if (regs[subexp_idx].rm_so == -1 || regs[subexp_idx].rm_eo == -1)\n\t\treturn -1;\n\t      else if (naccepted)\n\t\t{\n\t\t  char *buf = (char *) re_string_get_buffer (&mctx->input);\n\t\t  if (memcmp (buf + regs[subexp_idx].rm_so, buf + *pidx,\n\t\t\t      naccepted) != 0)\n\t\t    return -1;\n\t\t}\n\t    }\n\n\t  if (naccepted == 0)\n\t    {\n\t      Idx dest_node;\n\t      ok = re_node_set_insert (eps_via_nodes, node);\n\t      if (BE (! ok, 0))\n\t\treturn -2;\n\t      dest_node = dfa->edests[node].elems[0];\n\t      if (re_node_set_contains (&mctx->state_log[*pidx]->nodes,\n\t\t\t\t\tdest_node))\n\t\treturn dest_node;\n\t    }\n\t}\n\n      if (naccepted != 0\n\t  || check_node_accept (mctx, dfa->nodes + node, *pidx))\n\t{\n\t  Idx dest_node = dfa->nexts[node];\n\t  *pidx = (naccepted == 0) ? *pidx + 1 : *pidx + naccepted;\n\t  if (fs && (*pidx > mctx->match_last || mctx->state_log[*pidx] == NULL\n\t\t     || !re_node_set_contains (&mctx->state_log[*pidx]->nodes,\n\t\t\t\t\t       dest_node)))\n\t    return -1;\n\t  re_node_set_empty (eps_via_nodes);\n\t  return dest_node;\n\t}\n    }\n  return -1;\n}",
      "lines": 100,
      "depth": 20,
      "decorators": [
        "static",
        "static",
        "Idx"
      ]
    },
    "push_fail_stack": {
      "start_point": [
        1326,
        0
      ],
      "end_point": [
        1351,
        1
      ],
      "content": "static reg_errcode_t\n__attribute_warn_unused_result__\npush_fail_stack (struct re_fail_stack_t *fs, Idx str_idx, Idx dest_node,\n\t\t Idx nregs, regmatch_t *regs, re_node_set *eps_via_nodes)\n{\n  reg_errcode_t err;\n  Idx num = fs->num++;\n  if (fs->num == fs->alloc)\n    {\n      struct re_fail_stack_ent_t *new_array;\n      new_array = re_realloc (fs->stack, struct re_fail_stack_ent_t,\n                              fs->alloc * 2);\n      if (new_array == NULL)\n\treturn REG_ESPACE;\n      fs->alloc *= 2;\n      fs->stack = new_array;\n    }\n  fs->stack[num].idx = str_idx;\n  fs->stack[num].node = dest_node;\n  fs->stack[num].regs = re_malloc (regmatch_t, nregs);\n  if (fs->stack[num].regs == NULL)\n    return REG_ESPACE;\n  memcpy (fs->stack[num].regs, regs, sizeof (regmatch_t) * nregs);\n  err = re_node_set_init_copy (&fs->stack[num].eps_via_nodes, eps_via_nodes);\n  return err;\n}",
      "lines": 26,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "__attribute_warn_unused_result__",
        "__attribute_warn_unused_result__"
      ]
    },
    "pop_fail_stack": {
      "start_point": [
        1353,
        0
      ],
      "end_point": [
        1365,
        1
      ],
      "content": "static Idx\npop_fail_stack (struct re_fail_stack_t *fs, Idx *pidx, Idx nregs,\n\t\tregmatch_t *regs, re_node_set *eps_via_nodes)\n{\n  Idx num = --fs->num;\n  assert (num >= 0);\n  *pidx = fs->stack[num].idx;\n  memcpy (regs, fs->stack[num].regs, sizeof (regmatch_t) * nregs);\n  re_node_set_free (eps_via_nodes);\n  re_free (fs->stack[num].regs);\n  *eps_via_nodes = fs->stack[num].eps_via_nodes;\n  return fs->stack[num].node;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "Idx"
      ]
    },
    "__attribute_warn_unused_result__": [
      {
        "start_point": [
          1372,
          0
        ],
        "end_point": [
          1477,
          1
        ],
        "content": "static reg_errcode_t\n__attribute_warn_unused_result__\nset_regs (const regex_t *preg, const re_match_context_t *mctx, size_t nmatch,\n\t  regmatch_t *pmatch, bool fl_backtrack)\n{\n  const re_dfa_t *dfa = preg->buffer;\n  Idx idx, cur_node;\n  re_node_set eps_via_nodes;\n  struct re_fail_stack_t *fs;\n  struct re_fail_stack_t fs_body = { 0, 2, NULL };\n  regmatch_t *prev_idx_match;\n  bool prev_idx_match_malloced = false;\n\n#ifdef DEBUG\n  assert (nmatch > 1);\n  assert (mctx->state_log != NULL);\n#endif\n  if (fl_backtrack)\n    {\n      fs = &fs_body;\n      fs->stack = re_malloc (struct re_fail_stack_ent_t, fs->alloc);\n      if (fs->stack == NULL)\n\treturn REG_ESPACE;\n    }\n  else\n    fs = NULL;\n\n  cur_node = dfa->init_node;\n  re_node_set_init_empty (&eps_via_nodes);\n\n  if (__libc_use_alloca (nmatch * sizeof (regmatch_t)))\n    prev_idx_match = (regmatch_t *) alloca (nmatch * sizeof (regmatch_t));\n  else\n    {\n      prev_idx_match = re_malloc (regmatch_t, nmatch);\n      if (prev_idx_match == NULL)\n\t{\n\t  free_fail_stack_return (fs);\n\t  return REG_ESPACE;\n\t}\n      prev_idx_match_malloced = true;\n    }\n  memcpy (prev_idx_match, pmatch, sizeof (regmatch_t) * nmatch);\n\n  for (idx = pmatch[0].rm_so; idx <= pmatch[0].rm_eo ;)\n    {\n      update_regs (dfa, pmatch, prev_idx_match, cur_node, idx, nmatch);\n\n      if (idx == pmatch[0].rm_eo && cur_node == mctx->last_node)\n\t{\n\t  Idx reg_idx;\n\t  if (fs)\n\t    {\n\t      for (reg_idx = 0; reg_idx < nmatch; ++reg_idx)\n\t\tif (pmatch[reg_idx].rm_so > -1 && pmatch[reg_idx].rm_eo == -1)\n\t\t  break;\n\t      if (reg_idx == nmatch)\n\t\t{\n\t\t  re_node_set_free (&eps_via_nodes);\n\t\t  if (prev_idx_match_malloced)\n\t\t    re_free (prev_idx_match);\n\t\t  return free_fail_stack_return (fs);\n\t\t}\n\t      cur_node = pop_fail_stack (fs, &idx, nmatch, pmatch,\n\t\t\t\t\t &eps_via_nodes);\n\t    }\n\t  else\n\t    {\n\t      re_node_set_free (&eps_via_nodes);\n\t      if (prev_idx_match_malloced)\n\t\tre_free (prev_idx_match);\n\t      return REG_NOERROR;\n\t    }\n\t}\n\n      /* Proceed to next node.  */\n      cur_node = proceed_next_node (mctx, nmatch, pmatch, &idx, cur_node,\n\t\t\t\t    &eps_via_nodes, fs);\n\n      if (BE (cur_node < 0, 0))\n\t{\n\t  if (BE (cur_node == -2, 0))\n\t    {\n\t      re_node_set_free (&eps_via_nodes);\n\t      if (prev_idx_match_malloced)\n\t\tre_free (prev_idx_match);\n\t      free_fail_stack_return (fs);\n\t      return REG_ESPACE;\n\t    }\n\t  if (fs)\n\t    cur_node = pop_fail_stack (fs, &idx, nmatch, pmatch,\n\t\t\t\t       &eps_via_nodes);\n\t  else\n\t    {\n\t      re_node_set_free (&eps_via_nodes);\n\t      if (prev_idx_match_malloced)\n\t\tre_free (prev_idx_match);\n\t      return REG_NOMATCH;\n\t    }\n\t}\n    }\n  re_node_set_free (&eps_via_nodes);\n  if (prev_idx_match_malloced)\n    re_free (prev_idx_match);\n  return free_fail_stack_return (fs);\n}",
        "lines": 106,
        "depth": 16,
        "decorators": [
          "static",
          "static",
          "reg_errcode_t"
        ]
      },
      {
        "start_point": [
          2642,
          0
        ],
        "end_point": [
          2784,
          1
        ],
        "content": "static reg_errcode_t\n__attribute_warn_unused_result__\nget_subexp (re_match_context_t *mctx, Idx bkref_node, Idx bkref_str_idx)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  Idx subexp_num, sub_top_idx;\n  const char *buf = (const char *) re_string_get_buffer (&mctx->input);\n  /* Return if we have already checked BKREF_NODE at BKREF_STR_IDX.  */\n  Idx cache_idx = search_cur_bkref_entry (mctx, bkref_str_idx);\n  if (cache_idx != -1)\n    {\n      const struct re_backref_cache_entry *entry\n\t= mctx->bkref_ents + cache_idx;\n      do\n\tif (entry->node == bkref_node)\n\t  return REG_NOERROR; /* We already checked it.  */\n      while (entry++->more);\n    }\n\n  subexp_num = dfa->nodes[bkref_node].opr.idx;\n\n  /* For each sub expression  */\n  for (sub_top_idx = 0; sub_top_idx < mctx->nsub_tops; ++sub_top_idx)\n    {\n      reg_errcode_t err;\n      re_sub_match_top_t *sub_top = mctx->sub_tops[sub_top_idx];\n      re_sub_match_last_t *sub_last;\n      Idx sub_last_idx, sl_str, bkref_str_off;\n\n      if (dfa->nodes[sub_top->node].opr.idx != subexp_num)\n\tcontinue; /* It isn't related.  */\n\n      sl_str = sub_top->str_idx;\n      bkref_str_off = bkref_str_idx;\n      /* At first, check the last node of sub expressions we already\n\t evaluated.  */\n      for (sub_last_idx = 0; sub_last_idx < sub_top->nlasts; ++sub_last_idx)\n\t{\n\t  regoff_t sl_str_diff;\n\t  sub_last = sub_top->lasts[sub_last_idx];\n\t  sl_str_diff = sub_last->str_idx - sl_str;\n\t  /* The matched string by the sub expression match with the substring\n\t     at the back reference?  */\n\t  if (sl_str_diff > 0)\n\t    {\n\t      if (BE (bkref_str_off + sl_str_diff > mctx->input.valid_len, 0))\n\t\t{\n\t\t  /* Not enough chars for a successful match.  */\n\t\t  if (bkref_str_off + sl_str_diff > mctx->input.len)\n\t\t    break;\n\n\t\t  err = clean_state_log_if_needed (mctx,\n\t\t\t\t\t\t   bkref_str_off\n\t\t\t\t\t\t   + sl_str_diff);\n\t\t  if (BE (err != REG_NOERROR, 0))\n\t\t    return err;\n\t\t  buf = (const char *) re_string_get_buffer (&mctx->input);\n\t\t}\n\t      if (memcmp (buf + bkref_str_off, buf + sl_str, sl_str_diff) != 0)\n\t\t/* We don't need to search this sub expression any more.  */\n\t\tbreak;\n\t    }\n\t  bkref_str_off += sl_str_diff;\n\t  sl_str += sl_str_diff;\n\t  err = get_subexp_sub (mctx, sub_top, sub_last, bkref_node,\n\t\t\t\tbkref_str_idx);\n\n\t  /* Reload buf, since the preceding call might have reallocated\n\t     the buffer.  */\n\t  buf = (const char *) re_string_get_buffer (&mctx->input);\n\n\t  if (err == REG_NOMATCH)\n\t    continue;\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return err;\n\t}\n\n      if (sub_last_idx < sub_top->nlasts)\n\tcontinue;\n      if (sub_last_idx > 0)\n\t++sl_str;\n      /* Then, search for the other last nodes of the sub expression.  */\n      for (; sl_str <= bkref_str_idx; ++sl_str)\n\t{\n\t  Idx cls_node;\n\t  regoff_t sl_str_off;\n\t  const re_node_set *nodes;\n\t  sl_str_off = sl_str - sub_top->str_idx;\n\t  /* The matched string by the sub expression match with the substring\n\t     at the back reference?  */\n\t  if (sl_str_off > 0)\n\t    {\n\t      if (BE (bkref_str_off >= mctx->input.valid_len, 0))\n\t\t{\n\t\t  /* If we are at the end of the input, we cannot match.  */\n\t\t  if (bkref_str_off >= mctx->input.len)\n\t\t    break;\n\n\t\t  err = extend_buffers (mctx, bkref_str_off + 1);\n\t\t  if (BE (err != REG_NOERROR, 0))\n\t\t    return err;\n\n\t\t  buf = (const char *) re_string_get_buffer (&mctx->input);\n\t\t}\n\t      if (buf [bkref_str_off++] != buf[sl_str - 1])\n\t\tbreak; /* We don't need to search this sub expression\n\t\t\t  any more.  */\n\t    }\n\t  if (mctx->state_log[sl_str] == NULL)\n\t    continue;\n\t  /* Does this state have a ')' of the sub expression?  */\n\t  nodes = &mctx->state_log[sl_str]->nodes;\n\t  cls_node = find_subexp_node (dfa, nodes, subexp_num,\n\t\t\t\t       OP_CLOSE_SUBEXP);\n\t  if (cls_node == -1)\n\t    continue; /* No.  */\n\t  if (sub_top->path == NULL)\n\t    {\n\t      sub_top->path = calloc (sizeof (state_array_t),\n\t\t\t\t      sl_str - sub_top->str_idx + 1);\n\t      if (sub_top->path == NULL)\n\t\treturn REG_ESPACE;\n\t    }\n\t  /* Can the OP_OPEN_SUBEXP node arrive the OP_CLOSE_SUBEXP node\n\t     in the current context?  */\n\t  err = check_arrival (mctx, sub_top->path, sub_top->node,\n\t\t\t       sub_top->str_idx, cls_node, sl_str,\n\t\t\t       OP_CLOSE_SUBEXP);\n\t  if (err == REG_NOMATCH)\n\t      continue;\n\t  if (BE (err != REG_NOERROR, 0))\n\t      return err;\n\t  sub_last = match_ctx_add_sublast (sub_top, cls_node, sl_str);\n\t  if (BE (sub_last == NULL, 0))\n\t    return REG_ESPACE;\n\t  err = get_subexp_sub (mctx, sub_top, sub_last, bkref_node,\n\t\t\t\tbkref_str_idx);\n\t  if (err == REG_NOMATCH)\n\t    continue;\n\t}\n    }\n  return REG_NOERROR;\n}",
        "lines": 143,
        "depth": 18,
        "decorators": [
          "static",
          "static",
          "reg_errcode_t"
        ]
      }
    ],
    "free_fail_stack_return": {
      "start_point": [
        1479,
        0
      ],
      "end_point": [
        1493,
        1
      ],
      "content": "static reg_errcode_t\nfree_fail_stack_return (struct re_fail_stack_t *fs)\n{\n  if (fs)\n    {\n      Idx fs_idx;\n      for (fs_idx = 0; fs_idx < fs->num; ++fs_idx)\n\t{\n\t  re_node_set_free (&fs->stack[fs_idx].eps_via_nodes);\n\t  re_free (fs->stack[fs_idx].regs);\n\t}\n      re_free (fs->stack);\n    }\n  return REG_NOERROR;\n}",
      "lines": 15,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "update_regs": {
      "start_point": [
        1495,
        0
      ],
      "end_point": [
        1541,
        1
      ],
      "content": "static void\nupdate_regs (const re_dfa_t *dfa, regmatch_t *pmatch,\n\t     regmatch_t *prev_idx_match, Idx cur_node, Idx cur_idx, Idx nmatch)\n{\n  int type = dfa->nodes[cur_node].type;\n  if (type == OP_OPEN_SUBEXP)\n    {\n      Idx reg_num = dfa->nodes[cur_node].opr.idx + 1;\n\n      /* We are at the first node of this sub expression.  */\n      if (reg_num < nmatch)\n\t{\n\t  pmatch[reg_num].rm_so = cur_idx;\n\t  pmatch[reg_num].rm_eo = -1;\n\t}\n    }\n  else if (type == OP_CLOSE_SUBEXP)\n    {\n      Idx reg_num = dfa->nodes[cur_node].opr.idx + 1;\n      if (reg_num < nmatch)\n\t{\n\t  /* We are at the last node of this sub expression.  */\n\t  if (pmatch[reg_num].rm_so < cur_idx)\n\t    {\n\t      pmatch[reg_num].rm_eo = cur_idx;\n\t      /* This is a non-empty match or we are not inside an optional\n\t\t subexpression.  Accept this right away.  */\n\t      memcpy (prev_idx_match, pmatch, sizeof (regmatch_t) * nmatch);\n\t    }\n\t  else\n\t    {\n\t      if (dfa->nodes[cur_node].opt_subexp\n\t\t  && prev_idx_match[reg_num].rm_so != -1)\n\t\t/* We transited through an empty match for an optional\n\t\t   subexpression, like (a?)*, and this is not the subexp's\n\t\t   first match.  Copy back the old content of the registers\n\t\t   so that matches of an inner subexpression are undone as\n\t\t   well, like in ((a?))*.  */\n\t\tmemcpy (pmatch, prev_idx_match, sizeof (regmatch_t) * nmatch);\n\t      else\n\t\t/* We completed a subexpression, but it may be part of\n\t\t   an optional one, so do not update PREV_IDX_MATCH.  */\n\t\tpmatch[reg_num].rm_eo = cur_idx;\n\t    }\n\t}\n    }\n}",
      "lines": 47,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "sift_states_backward": {
      "start_point": [
        1566,
        0
      ],
      "end_point": [
        1621,
        1
      ],
      "content": "static reg_errcode_t\nsift_states_backward (const re_match_context_t *mctx, re_sift_context_t *sctx)\n{\n  reg_errcode_t err;\n  int null_cnt = 0;\n  Idx str_idx = sctx->last_str_idx;\n  re_node_set cur_dest;\n\n#ifdef DEBUG\n  assert (mctx->state_log != NULL && mctx->state_log[str_idx] != NULL);\n#endif\n\n  /* Build sifted state_log[str_idx].  It has the nodes which can epsilon\n     transit to the last_node and the last_node itself.  */\n  err = re_node_set_init_1 (&cur_dest, sctx->last_node);\n  if (BE (err != REG_NOERROR, 0))\n    return err;\n  err = update_cur_sifted_state (mctx, sctx, str_idx, &cur_dest);\n  if (BE (err != REG_NOERROR, 0))\n    goto free_return;\n\n  /* Then check each states in the state_log.  */\n  while (str_idx > 0)\n    {\n      /* Update counters.  */\n      null_cnt = (sctx->sifted_states[str_idx] == NULL) ? null_cnt + 1 : 0;\n      if (null_cnt > mctx->max_mb_elem_len)\n\t{\n\t  memset (sctx->sifted_states, '\\0',\n\t\t  sizeof (re_dfastate_t *) * str_idx);\n\t  re_node_set_free (&cur_dest);\n\t  return REG_NOERROR;\n\t}\n      re_node_set_empty (&cur_dest);\n      --str_idx;\n\n      if (mctx->state_log[str_idx])\n\t{\n\t  err = build_sifted_states (mctx, sctx, str_idx, &cur_dest);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    goto free_return;\n\t}\n\n      /* Add all the nodes which satisfy the following conditions:\n\t - It can epsilon transit to a node in CUR_DEST.\n\t - It is in CUR_SRC.\n\t And update state_log.  */\n      err = update_cur_sifted_state (mctx, sctx, str_idx, &cur_dest);\n      if (BE (err != REG_NOERROR, 0))\n\tgoto free_return;\n    }\n  err = REG_NOERROR;\n free_return:\n  re_node_set_free (&cur_dest);\n  return err;\n}",
      "lines": 56,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "build_sifted_states": {
      "start_point": [
        1623,
        0
      ],
      "end_point": [
        1681,
        1
      ],
      "content": "static reg_errcode_t\n__attribute_warn_unused_result__\nbuild_sifted_states (const re_match_context_t *mctx, re_sift_context_t *sctx,\n\t\t     Idx str_idx, re_node_set *cur_dest)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  const re_node_set *cur_src = &mctx->state_log[str_idx]->non_eps_nodes;\n  Idx i;\n\n  /* Then build the next sifted state.\n     We build the next sifted state on 'cur_dest', and update\n     'sifted_states[str_idx]' with 'cur_dest'.\n     Note:\n     'cur_dest' is the sifted state from 'state_log[str_idx + 1]'.\n     'cur_src' points the node_set of the old 'state_log[str_idx]'\n     (with the epsilon nodes pre-filtered out).  */\n  for (i = 0; i < cur_src->nelem; i++)\n    {\n      Idx prev_node = cur_src->elems[i];\n      int naccepted = 0;\n      bool ok;\n\n#ifdef DEBUG\n      re_token_type_t type = dfa->nodes[prev_node].type;\n      assert (!IS_EPSILON_NODE (type));\n#endif\n#ifdef RE_ENABLE_I18N\n      /* If the node may accept \"multi byte\".  */\n      if (dfa->nodes[prev_node].accept_mb)\n\tnaccepted = sift_states_iter_mb (mctx, sctx, prev_node,\n\t\t\t\t\t str_idx, sctx->last_str_idx);\n#endif /* RE_ENABLE_I18N */\n\n      /* We don't check backreferences here.\n\t See update_cur_sifted_state().  */\n      if (!naccepted\n\t  && check_node_accept (mctx, dfa->nodes + prev_node, str_idx)\n\t  && STATE_NODE_CONTAINS (sctx->sifted_states[str_idx + 1],\n\t\t\t\t  dfa->nexts[prev_node]))\n\tnaccepted = 1;\n\n      if (naccepted == 0)\n\tcontinue;\n\n      if (sctx->limits.nelem)\n\t{\n\t  Idx to_idx = str_idx + naccepted;\n\t  if (check_dst_limits (mctx, &sctx->limits,\n\t\t\t\tdfa->nexts[prev_node], to_idx,\n\t\t\t\tprev_node, str_idx))\n\t    continue;\n\t}\n      ok = re_node_set_insert (cur_dest, prev_node);\n      if (BE (! ok, 0))\n\treturn REG_ESPACE;\n    }\n\n  return REG_NOERROR;\n}",
      "lines": 59,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "__attribute_warn_unused_result__",
        "__attribute_warn_unused_result__"
      ]
    },
    "clean_state_log_if_needed": {
      "start_point": [
        1685,
        0
      ],
      "end_point": [
        1708,
        1
      ],
      "content": "static reg_errcode_t\nclean_state_log_if_needed (re_match_context_t *mctx, Idx next_state_log_idx)\n{\n  Idx top = mctx->state_log_top;\n\n  if ((next_state_log_idx >= mctx->input.bufs_len\n       && mctx->input.bufs_len < mctx->input.len)\n      || (next_state_log_idx >= mctx->input.valid_len\n\t  && mctx->input.valid_len < mctx->input.len))\n    {\n      reg_errcode_t err;\n      err = extend_buffers (mctx, next_state_log_idx + 1);\n      if (BE (err != REG_NOERROR, 0))\n\treturn err;\n    }\n\n  if (top < next_state_log_idx)\n    {\n      memset (mctx->state_log + top + 1, '\\0',\n\t      sizeof (re_dfastate_t *) * (next_state_log_idx - top));\n      mctx->state_log_top = next_state_log_idx;\n    }\n  return REG_NOERROR;\n}",
      "lines": 24,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "merge_state_array": {
      "start_point": [
        1710,
        0
      ],
      "end_point": [
        1734,
        1
      ],
      "content": "static reg_errcode_t\nmerge_state_array (const re_dfa_t *dfa, re_dfastate_t **dst,\n\t\t   re_dfastate_t **src, Idx num)\n{\n  Idx st_idx;\n  reg_errcode_t err;\n  for (st_idx = 0; st_idx < num; ++st_idx)\n    {\n      if (dst[st_idx] == NULL)\n\tdst[st_idx] = src[st_idx];\n      else if (src[st_idx] != NULL)\n\t{\n\t  re_node_set merged_set;\n\t  err = re_node_set_init_union (&merged_set, &dst[st_idx]->nodes,\n\t\t\t\t\t&src[st_idx]->nodes);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return err;\n\t  dst[st_idx] = re_acquire_state (&err, dfa, &merged_set);\n\t  re_node_set_free (&merged_set);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return err;\n\t}\n    }\n  return REG_NOERROR;\n}",
      "lines": 25,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "update_cur_sifted_state": {
      "start_point": [
        1736,
        0
      ],
      "end_point": [
        1781,
        1
      ],
      "content": "static reg_errcode_t\nupdate_cur_sifted_state (const re_match_context_t *mctx,\n\t\t\t re_sift_context_t *sctx, Idx str_idx,\n\t\t\t re_node_set *dest_nodes)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  reg_errcode_t err = REG_NOERROR;\n  const re_node_set *candidates;\n  candidates = ((mctx->state_log[str_idx] == NULL) ? NULL\n\t\t: &mctx->state_log[str_idx]->nodes);\n\n  if (dest_nodes->nelem == 0)\n    sctx->sifted_states[str_idx] = NULL;\n  else\n    {\n      if (candidates)\n\t{\n\t  /* At first, add the nodes which can epsilon transit to a node in\n\t     DEST_NODE.  */\n\t  err = add_epsilon_src_nodes (dfa, dest_nodes, candidates);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return err;\n\n\t  /* Then, check the limitations in the current sift_context.  */\n\t  if (sctx->limits.nelem)\n\t    {\n\t      err = check_subexp_limits (dfa, dest_nodes, candidates, &sctx->limits,\n\t\t\t\t\t mctx->bkref_ents, str_idx);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\treturn err;\n\t    }\n\t}\n\n      sctx->sifted_states[str_idx] = re_acquire_state (&err, dfa, dest_nodes);\n      if (BE (err != REG_NOERROR, 0))\n\treturn err;\n    }\n\n  if (candidates && mctx->state_log[str_idx]->has_backref)\n    {\n      err = sift_states_bkref (mctx, sctx, str_idx, candidates);\n      if (BE (err != REG_NOERROR, 0))\n\treturn err;\n    }\n  return REG_NOERROR;\n}",
      "lines": 46,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "add_epsilon_src_nodes": {
      "start_point": [
        1783,
        0
      ],
      "end_point": [
        1810,
        1
      ],
      "content": "static reg_errcode_t\n__attribute_warn_unused_result__\nadd_epsilon_src_nodes (const re_dfa_t *dfa, re_node_set *dest_nodes,\n\t\t       const re_node_set *candidates)\n{\n  reg_errcode_t err = REG_NOERROR;\n  Idx i;\n\n  re_dfastate_t *state = re_acquire_state (&err, dfa, dest_nodes);\n  if (BE (err != REG_NOERROR, 0))\n    return err;\n\n  if (!state->inveclosure.alloc)\n    {\n      err = re_node_set_alloc (&state->inveclosure, dest_nodes->nelem);\n      if (BE (err != REG_NOERROR, 0))\n\treturn REG_ESPACE;\n      for (i = 0; i < dest_nodes->nelem; i++)\n\t{\n\t  err = re_node_set_merge (&state->inveclosure,\n\t\t\t\t   dfa->inveclosures + dest_nodes->elems[i]);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return REG_ESPACE;\n\t}\n    }\n  return re_node_set_add_intersect (dest_nodes, candidates,\n\t\t\t\t    &state->inveclosure);\n}",
      "lines": 28,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "__attribute_warn_unused_result__",
        "__attribute_warn_unused_result__"
      ]
    },
    "sub_epsilon_src_nodes": {
      "start_point": [
        1812,
        0
      ],
      "end_point": [
        1858,
        1
      ],
      "content": "static reg_errcode_t\nsub_epsilon_src_nodes (const re_dfa_t *dfa, Idx node, re_node_set *dest_nodes,\n\t\t       const re_node_set *candidates)\n{\n    Idx ecl_idx;\n    reg_errcode_t err;\n    re_node_set *inv_eclosure = dfa->inveclosures + node;\n    re_node_set except_nodes;\n    re_node_set_init_empty (&except_nodes);\n    for (ecl_idx = 0; ecl_idx < inv_eclosure->nelem; ++ecl_idx)\n      {\n\tIdx cur_node = inv_eclosure->elems[ecl_idx];\n\tif (cur_node == node)\n\t  continue;\n\tif (IS_EPSILON_NODE (dfa->nodes[cur_node].type))\n\t  {\n\t    Idx edst1 = dfa->edests[cur_node].elems[0];\n\t    Idx edst2 = ((dfa->edests[cur_node].nelem > 1)\n\t\t\t ? dfa->edests[cur_node].elems[1] : -1);\n\t    if ((!re_node_set_contains (inv_eclosure, edst1)\n\t\t && re_node_set_contains (dest_nodes, edst1))\n\t\t|| (edst2 > 0\n\t\t    && !re_node_set_contains (inv_eclosure, edst2)\n\t\t    && re_node_set_contains (dest_nodes, edst2)))\n\t      {\n\t\terr = re_node_set_add_intersect (&except_nodes, candidates,\n\t\t\t\t\t\t dfa->inveclosures + cur_node);\n\t\tif (BE (err != REG_NOERROR, 0))\n\t\t  {\n\t\t    re_node_set_free (&except_nodes);\n\t\t    return err;\n\t\t  }\n\t      }\n\t  }\n      }\n    for (ecl_idx = 0; ecl_idx < inv_eclosure->nelem; ++ecl_idx)\n      {\n\tIdx cur_node = inv_eclosure->elems[ecl_idx];\n\tif (!re_node_set_contains (&except_nodes, cur_node))\n\t  {\n\t    Idx idx = re_node_set_contains (dest_nodes, cur_node) - 1;\n\t    re_node_set_remove_at (dest_nodes, idx);\n\t  }\n      }\n    re_node_set_free (&except_nodes);\n    return REG_NOERROR;\n}",
      "lines": 47,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "check_dst_limits": {
      "start_point": [
        1860,
        0
      ],
      "end_point": [
        1893,
        1
      ],
      "content": "static bool\ncheck_dst_limits (const re_match_context_t *mctx, const re_node_set *limits,\n\t\t  Idx dst_node, Idx dst_idx, Idx src_node, Idx src_idx)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  Idx lim_idx, src_pos, dst_pos;\n\n  Idx dst_bkref_idx = search_cur_bkref_entry (mctx, dst_idx);\n  Idx src_bkref_idx = search_cur_bkref_entry (mctx, src_idx);\n  for (lim_idx = 0; lim_idx < limits->nelem; ++lim_idx)\n    {\n      Idx subexp_idx;\n      struct re_backref_cache_entry *ent;\n      ent = mctx->bkref_ents + limits->elems[lim_idx];\n      subexp_idx = dfa->nodes[ent->node].opr.idx;\n\n      dst_pos = check_dst_limits_calc_pos (mctx, limits->elems[lim_idx],\n\t\t\t\t\t   subexp_idx, dst_node, dst_idx,\n\t\t\t\t\t   dst_bkref_idx);\n      src_pos = check_dst_limits_calc_pos (mctx, limits->elems[lim_idx],\n\t\t\t\t\t   subexp_idx, src_node, src_idx,\n\t\t\t\t\t   src_bkref_idx);\n\n      /* In case of:\n\t <src> <dst> ( <subexp> )\n\t ( <subexp> ) <src> <dst>\n\t ( <subexp1> <src> <subexp2> <dst> <subexp3> )  */\n      if (src_pos == dst_pos)\n\tcontinue; /* This is unrelated limitation.  */\n      else\n\treturn true;\n    }\n  return false;\n}",
      "lines": 34,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "check_dst_limits_calc_pos_1": {
      "start_point": [
        1895,
        0
      ],
      "end_point": [
        1974,
        1
      ],
      "content": "static int\ncheck_dst_limits_calc_pos_1 (const re_match_context_t *mctx, int boundaries,\n\t\t\t     Idx subexp_idx, Idx from_node, Idx bkref_idx)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  const re_node_set *eclosures = dfa->eclosures + from_node;\n  Idx node_idx;\n\n  /* Else, we are on the boundary: examine the nodes on the epsilon\n     closure.  */\n  for (node_idx = 0; node_idx < eclosures->nelem; ++node_idx)\n    {\n      Idx node = eclosures->elems[node_idx];\n      switch (dfa->nodes[node].type)\n\t{\n\tcase OP_BACK_REF:\n\t  if (bkref_idx != -1)\n\t    {\n\t      struct re_backref_cache_entry *ent = mctx->bkref_ents + bkref_idx;\n\t      do\n\t\t{\n\t\t  Idx dst;\n\t\t  int cpos;\n\n\t\t  if (ent->node != node)\n\t\t    continue;\n\n\t\t  if (subexp_idx < BITSET_WORD_BITS\n\t\t      && !(ent->eps_reachable_subexps_map\n\t\t\t   & ((bitset_word_t) 1 << subexp_idx)))\n\t\t    continue;\n\n\t\t  /* Recurse trying to reach the OP_OPEN_SUBEXP and\n\t\t     OP_CLOSE_SUBEXP cases below.  But, if the\n\t\t     destination node is the same node as the source\n\t\t     node, don't recurse because it would cause an\n\t\t     infinite loop: a regex that exhibits this behavior\n\t\t     is ()\\1*\\1*  */\n\t\t  dst = dfa->edests[node].elems[0];\n\t\t  if (dst == from_node)\n\t\t    {\n\t\t      if (boundaries & 1)\n\t\t\treturn -1;\n\t\t      else /* if (boundaries & 2) */\n\t\t\treturn 0;\n\t\t    }\n\n\t\t  cpos =\n\t\t    check_dst_limits_calc_pos_1 (mctx, boundaries, subexp_idx,\n\t\t\t\t\t\t dst, bkref_idx);\n\t\t  if (cpos == -1 /* && (boundaries & 1) */)\n\t\t    return -1;\n\t\t  if (cpos == 0 && (boundaries & 2))\n\t\t    return 0;\n\n\t\t  if (subexp_idx < BITSET_WORD_BITS)\n\t\t    ent->eps_reachable_subexps_map\n\t\t      &= ~((bitset_word_t) 1 << subexp_idx);\n\t\t}\n\t      while (ent++->more);\n\t    }\n\t  break;\n\n\tcase OP_OPEN_SUBEXP:\n\t  if ((boundaries & 1) && subexp_idx == dfa->nodes[node].opr.idx)\n\t    return -1;\n\t  break;\n\n\tcase OP_CLOSE_SUBEXP:\n\t  if ((boundaries & 2) && subexp_idx == dfa->nodes[node].opr.idx)\n\t    return 0;\n\t  break;\n\n\tdefault:\n\t    break;\n\t}\n    }\n\n  return (boundaries & 2) ? 1 : 0;\n}",
      "lines": 80,
      "depth": 22,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "check_dst_limits_calc_pos": {
      "start_point": [
        1976,
        0
      ],
      "end_point": [
        2000,
        1
      ],
      "content": "static int\ncheck_dst_limits_calc_pos (const re_match_context_t *mctx, Idx limit,\n\t\t\t   Idx subexp_idx, Idx from_node, Idx str_idx,\n\t\t\t   Idx bkref_idx)\n{\n  struct re_backref_cache_entry *lim = mctx->bkref_ents + limit;\n  int boundaries;\n\n  /* If we are outside the range of the subexpression, return -1 or 1.  */\n  if (str_idx < lim->subexp_from)\n    return -1;\n\n  if (lim->subexp_to < str_idx)\n    return 1;\n\n  /* If we are within the subexpression, return 0.  */\n  boundaries = (str_idx == lim->subexp_from);\n  boundaries |= (str_idx == lim->subexp_to) << 1;\n  if (boundaries == 0)\n    return 0;\n\n  /* Else, examine epsilon closure.  */\n  return check_dst_limits_calc_pos_1 (mctx, boundaries, subexp_idx,\n\t\t\t\t      from_node, bkref_idx);\n}",
      "lines": 25,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "check_subexp_limits": {
      "start_point": [
        2005,
        0
      ],
      "end_point": [
        2090,
        1
      ],
      "content": "static reg_errcode_t\ncheck_subexp_limits (const re_dfa_t *dfa, re_node_set *dest_nodes,\n\t\t     const re_node_set *candidates, re_node_set *limits,\n\t\t     struct re_backref_cache_entry *bkref_ents, Idx str_idx)\n{\n  reg_errcode_t err;\n  Idx node_idx, lim_idx;\n\n  for (lim_idx = 0; lim_idx < limits->nelem; ++lim_idx)\n    {\n      Idx subexp_idx;\n      struct re_backref_cache_entry *ent;\n      ent = bkref_ents + limits->elems[lim_idx];\n\n      if (str_idx <= ent->subexp_from || ent->str_idx < str_idx)\n\tcontinue; /* This is unrelated limitation.  */\n\n      subexp_idx = dfa->nodes[ent->node].opr.idx;\n      if (ent->subexp_to == str_idx)\n\t{\n\t  Idx ops_node = -1;\n\t  Idx cls_node = -1;\n\t  for (node_idx = 0; node_idx < dest_nodes->nelem; ++node_idx)\n\t    {\n\t      Idx node = dest_nodes->elems[node_idx];\n\t      re_token_type_t type = dfa->nodes[node].type;\n\t      if (type == OP_OPEN_SUBEXP\n\t\t  && subexp_idx == dfa->nodes[node].opr.idx)\n\t\tops_node = node;\n\t      else if (type == OP_CLOSE_SUBEXP\n\t\t       && subexp_idx == dfa->nodes[node].opr.idx)\n\t\tcls_node = node;\n\t    }\n\n\t  /* Check the limitation of the open subexpression.  */\n\t  /* Note that (ent->subexp_to = str_idx != ent->subexp_from).  */\n\t  if (ops_node >= 0)\n\t    {\n\t      err = sub_epsilon_src_nodes (dfa, ops_node, dest_nodes,\n\t\t\t\t\t   candidates);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\treturn err;\n\t    }\n\n\t  /* Check the limitation of the close subexpression.  */\n\t  if (cls_node >= 0)\n\t    for (node_idx = 0; node_idx < dest_nodes->nelem; ++node_idx)\n\t      {\n\t\tIdx node = dest_nodes->elems[node_idx];\n\t\tif (!re_node_set_contains (dfa->inveclosures + node,\n\t\t\t\t\t   cls_node)\n\t\t    && !re_node_set_contains (dfa->eclosures + node,\n\t\t\t\t\t      cls_node))\n\t\t  {\n\t\t    /* It is against this limitation.\n\t\t       Remove it form the current sifted state.  */\n\t\t    err = sub_epsilon_src_nodes (dfa, node, dest_nodes,\n\t\t\t\t\t\t candidates);\n\t\t    if (BE (err != REG_NOERROR, 0))\n\t\t      return err;\n\t\t    --node_idx;\n\t\t  }\n\t      }\n\t}\n      else /* (ent->subexp_to != str_idx)  */\n\t{\n\t  for (node_idx = 0; node_idx < dest_nodes->nelem; ++node_idx)\n\t    {\n\t      Idx node = dest_nodes->elems[node_idx];\n\t      re_token_type_t type = dfa->nodes[node].type;\n\t      if (type == OP_CLOSE_SUBEXP || type == OP_OPEN_SUBEXP)\n\t\t{\n\t\t  if (subexp_idx != dfa->nodes[node].opr.idx)\n\t\t    continue;\n\t\t  /* It is against this limitation.\n\t\t     Remove it form the current sifted state.  */\n\t\t  err = sub_epsilon_src_nodes (dfa, node, dest_nodes,\n\t\t\t\t\t       candidates);\n\t\t  if (BE (err != REG_NOERROR, 0))\n\t\t    return err;\n\t\t}\n\t    }\n\t}\n    }\n  return REG_NOERROR;\n}",
      "lines": 86,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "sift_states_bkref": {
      "start_point": [
        2092,
        0
      ],
      "end_point": [
        2188,
        1
      ],
      "content": "static reg_errcode_t\n__attribute_warn_unused_result__\nsift_states_bkref (const re_match_context_t *mctx, re_sift_context_t *sctx,\n\t\t   Idx str_idx, const re_node_set *candidates)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  reg_errcode_t err;\n  Idx node_idx, node;\n  re_sift_context_t local_sctx;\n  Idx first_idx = search_cur_bkref_entry (mctx, str_idx);\n\n  if (first_idx == -1)\n    return REG_NOERROR;\n\n  local_sctx.sifted_states = NULL; /* Mark that it hasn't been initialized.  */\n\n  for (node_idx = 0; node_idx < candidates->nelem; ++node_idx)\n    {\n      Idx enabled_idx;\n      re_token_type_t type;\n      struct re_backref_cache_entry *entry;\n      node = candidates->elems[node_idx];\n      type = dfa->nodes[node].type;\n      /* Avoid infinite loop for the REs like \"()\\1+\".  */\n      if (node == sctx->last_node && str_idx == sctx->last_str_idx)\n\tcontinue;\n      if (type != OP_BACK_REF)\n\tcontinue;\n\n      entry = mctx->bkref_ents + first_idx;\n      enabled_idx = first_idx;\n      do\n\t{\n\t  Idx subexp_len;\n\t  Idx to_idx;\n\t  Idx dst_node;\n\t  bool ok;\n\t  re_dfastate_t *cur_state;\n\n\t  if (entry->node != node)\n\t    continue;\n\t  subexp_len = entry->subexp_to - entry->subexp_from;\n\t  to_idx = str_idx + subexp_len;\n\t  dst_node = (subexp_len ? dfa->nexts[node]\n\t\t      : dfa->edests[node].elems[0]);\n\n\t  if (to_idx > sctx->last_str_idx\n\t      || sctx->sifted_states[to_idx] == NULL\n\t      || !STATE_NODE_CONTAINS (sctx->sifted_states[to_idx], dst_node)\n\t      || check_dst_limits (mctx, &sctx->limits, node,\n\t\t\t\t   str_idx, dst_node, to_idx))\n\t    continue;\n\n\t  if (local_sctx.sifted_states == NULL)\n\t    {\n\t      local_sctx = *sctx;\n\t      err = re_node_set_init_copy (&local_sctx.limits, &sctx->limits);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\tgoto free_return;\n\t    }\n\t  local_sctx.last_node = node;\n\t  local_sctx.last_str_idx = str_idx;\n\t  ok = re_node_set_insert (&local_sctx.limits, enabled_idx);\n\t  if (BE (! ok, 0))\n\t    {\n\t      err = REG_ESPACE;\n\t      goto free_return;\n\t    }\n\t  cur_state = local_sctx.sifted_states[str_idx];\n\t  err = sift_states_backward (mctx, &local_sctx);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    goto free_return;\n\t  if (sctx->limited_states != NULL)\n\t    {\n\t      err = merge_state_array (dfa, sctx->limited_states,\n\t\t\t\t       local_sctx.sifted_states,\n\t\t\t\t       str_idx + 1);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\tgoto free_return;\n\t    }\n\t  local_sctx.sifted_states[str_idx] = cur_state;\n\t  re_node_set_remove (&local_sctx.limits, enabled_idx);\n\n\t  /* mctx->bkref_ents may have changed, reload the pointer.  */\n\t  entry = mctx->bkref_ents + enabled_idx;\n\t}\n      while (enabled_idx++, entry++->more);\n    }\n  err = REG_NOERROR;\n free_return:\n  if (local_sctx.sifted_states != NULL)\n    {\n      re_node_set_free (&local_sctx.limits);\n    }\n\n  return err;\n}",
      "lines": 97,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "__attribute_warn_unused_result__",
        "__attribute_warn_unused_result__"
      ]
    },
    "sift_states_iter_mb": {
      "start_point": [
        2192,
        0
      ],
      "end_point": [
        2210,
        1
      ],
      "content": "static int\nsift_states_iter_mb (const re_match_context_t *mctx, re_sift_context_t *sctx,\n\t\t     Idx node_idx, Idx str_idx, Idx max_str_idx)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  int naccepted;\n  /* Check the node can accept \"multi byte\".  */\n  naccepted = check_node_accept_bytes (dfa, node_idx, &mctx->input, str_idx);\n  if (naccepted > 0 && str_idx + naccepted <= max_str_idx &&\n      !STATE_NODE_CONTAINS (sctx->sifted_states[str_idx + naccepted],\n\t\t\t    dfa->nexts[node_idx]))\n    /* The node can't accept the \"multi byte\", or the\n       destination was already thrown away, then the node\n       could't accept the current input \"multi byte\".   */\n    naccepted = 0;\n  /* Otherwise, it is sure that the node could accept\n     'naccepted' bytes input.  */\n  return naccepted;\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "transit_state": {
      "start_point": [
        2221,
        0
      ],
      "end_point": [
        2276,
        1
      ],
      "content": "static re_dfastate_t *\n__attribute_warn_unused_result__\ntransit_state (reg_errcode_t *err, re_match_context_t *mctx,\n\t       re_dfastate_t *state)\n{\n  re_dfastate_t **trtable;\n  unsigned char ch;\n\n#ifdef RE_ENABLE_I18N\n  /* If the current state can accept multibyte.  */\n  if (BE (state->accept_mb, 0))\n    {\n      *err = transit_state_mb (mctx, state);\n      if (BE (*err != REG_NOERROR, 0))\n\treturn NULL;\n    }\n#endif /* RE_ENABLE_I18N */\n\n  /* Then decide the next state with the single byte.  */\n#if 0\n  if (0)\n    /* don't use transition table  */\n    return transit_state_sb (err, mctx, state);\n#endif\n\n  /* Use transition table  */\n  ch = re_string_fetch_byte (&mctx->input);\n  for (;;)\n    {\n      trtable = state->trtable;\n      if (BE (trtable != NULL, 1))\n\treturn trtable[ch];\n\n      trtable = state->word_trtable;\n      if (BE (trtable != NULL, 1))\n\t{\n\t  unsigned int context;\n\t  context\n\t    = re_string_context_at (&mctx->input,\n\t\t\t\t    re_string_cur_idx (&mctx->input) - 1,\n\t\t\t\t    mctx->eflags);\n\t  if (IS_WORD_CONTEXT (context))\n\t    return trtable[ch + SBC_MAX];\n\t  else\n\t    return trtable[ch];\n\t}\n\n      if (!build_trtable (mctx->dfa, state))\n\t{\n\t  *err = REG_ESPACE;\n\t  return NULL;\n\t}\n\n      /* Retry, we now have a transition table.  */\n    }\n}",
      "lines": 56,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "re_dfastate_t",
        "*\n__attribute_warn_unused_result__\ntransit_state (reg_errcode_t *err, re_match_context_t *mctx,\n\t       re_dfastate_t *state)",
        "*",
        "__attribute_warn_unused_result__",
        "__attribute_warn_unused_result__"
      ]
    },
    "merge_state_with_log": {
      "start_point": [
        2279,
        0
      ],
      "end_point": [
        2352,
        1
      ],
      "content": "static re_dfastate_t *\nmerge_state_with_log (reg_errcode_t *err, re_match_context_t *mctx,\n\t\t      re_dfastate_t *next_state)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  Idx cur_idx = re_string_cur_idx (&mctx->input);\n\n  if (cur_idx > mctx->state_log_top)\n    {\n      mctx->state_log[cur_idx] = next_state;\n      mctx->state_log_top = cur_idx;\n    }\n  else if (mctx->state_log[cur_idx] == 0)\n    {\n      mctx->state_log[cur_idx] = next_state;\n    }\n  else\n    {\n      re_dfastate_t *pstate;\n      unsigned int context;\n      re_node_set next_nodes, *log_nodes, *table_nodes = NULL;\n      /* If (state_log[cur_idx] != 0), it implies that cur_idx is\n\t the destination of a multibyte char/collating element/\n\t back reference.  Then the next state is the union set of\n\t these destinations and the results of the transition table.  */\n      pstate = mctx->state_log[cur_idx];\n      log_nodes = pstate->entrance_nodes;\n      if (next_state != NULL)\n\t{\n\t  table_nodes = next_state->entrance_nodes;\n\t  *err = re_node_set_init_union (&next_nodes, table_nodes,\n\t\t\t\t\t     log_nodes);\n\t  if (BE (*err != REG_NOERROR, 0))\n\t    return NULL;\n\t}\n      else\n\tnext_nodes = *log_nodes;\n      /* Note: We already add the nodes of the initial state,\n\t then we don't need to add them here.  */\n\n      context = re_string_context_at (&mctx->input,\n\t\t\t\t      re_string_cur_idx (&mctx->input) - 1,\n\t\t\t\t      mctx->eflags);\n      next_state = mctx->state_log[cur_idx]\n\t= re_acquire_state_context (err, dfa, &next_nodes, context);\n      /* We don't need to check errors here, since the return value of\n\t this function is next_state and ERR is already set.  */\n\n      if (table_nodes != NULL)\n\tre_node_set_free (&next_nodes);\n    }\n\n  if (BE (dfa->nbackref, 0) && next_state != NULL)\n    {\n      /* Check OP_OPEN_SUBEXP in the current state in case that we use them\n\t later.  We must check them here, since the back references in the\n\t next state might use them.  */\n      *err = check_subexp_matching_top (mctx, &next_state->nodes,\n\t\t\t\t\tcur_idx);\n      if (BE (*err != REG_NOERROR, 0))\n\treturn NULL;\n\n      /* If the next state has back references.  */\n      if (next_state->has_backref)\n\t{\n\t  *err = transit_state_bkref (mctx, &next_state->nodes);\n\t  if (BE (*err != REG_NOERROR, 0))\n\t    return NULL;\n\t  next_state = mctx->state_log[cur_idx];\n\t}\n    }\n\n  return next_state;\n}",
      "lines": 74,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "re_dfastate_t",
        "*\nmerge_state_with_log (reg_errcode_t *err, re_match_context_t *mctx,\n\t\t      re_dfastate_t *next_state)",
        "*"
      ]
    },
    "find_recover_state": {
      "start_point": [
        2357,
        0
      ],
      "end_point": [
        2378,
        1
      ],
      "content": "static re_dfastate_t *\nfind_recover_state (reg_errcode_t *err, re_match_context_t *mctx)\n{\n  re_dfastate_t *cur_state;\n  do\n    {\n      Idx max = mctx->state_log_top;\n      Idx cur_str_idx = re_string_cur_idx (&mctx->input);\n\n      do\n\t{\n\t  if (++cur_str_idx > max)\n\t    return NULL;\n\t  re_string_skip_bytes (&mctx->input, 1);\n\t}\n      while (mctx->state_log[cur_str_idx] == NULL);\n\n      cur_state = merge_state_with_log (err, mctx, NULL);\n    }\n  while (*err == REG_NOERROR && cur_state == NULL);\n  return cur_state;\n}",
      "lines": 22,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "re_dfastate_t",
        "*\nfind_recover_state (reg_errcode_t *err, re_match_context_t *mctx)",
        "*"
      ]
    },
    "check_subexp_matching_top": {
      "start_point": [
        2387,
        0
      ],
      "end_point": [
        2414,
        1
      ],
      "content": "static reg_errcode_t\ncheck_subexp_matching_top (re_match_context_t *mctx, re_node_set *cur_nodes,\n\t\t\t   Idx str_idx)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  Idx node_idx;\n  reg_errcode_t err;\n\n  /* TODO: This isn't efficient.\n\t   Because there might be more than one nodes whose types are\n\t   OP_OPEN_SUBEXP and whose index is SUBEXP_IDX, we must check all\n\t   nodes.\n\t   E.g. RE: (a){2}  */\n  for (node_idx = 0; node_idx < cur_nodes->nelem; ++node_idx)\n    {\n      Idx node = cur_nodes->elems[node_idx];\n      if (dfa->nodes[node].type == OP_OPEN_SUBEXP\n\t  && dfa->nodes[node].opr.idx < BITSET_WORD_BITS\n\t  && (dfa->used_bkref_map\n\t      & ((bitset_word_t) 1 << dfa->nodes[node].opr.idx)))\n\t{\n\t  err = match_ctx_add_subtop (mctx, node, str_idx);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return err;\n\t}\n    }\n  return REG_NOERROR;\n}",
      "lines": 28,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "transit_state_sb": {
      "start_point": [
        2420,
        0
      ],
      "end_point": [
        2455,
        1
      ],
      "content": "static re_dfastate_t *\ntransit_state_sb (reg_errcode_t *err, re_match_context_t *mctx,\n\t\t  re_dfastate_t *state)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  re_node_set next_nodes;\n  re_dfastate_t *next_state;\n  Idx node_cnt, cur_str_idx = re_string_cur_idx (&mctx->input);\n  unsigned int context;\n\n  *err = re_node_set_alloc (&next_nodes, state->nodes.nelem + 1);\n  if (BE (*err != REG_NOERROR, 0))\n    return NULL;\n  for (node_cnt = 0; node_cnt < state->nodes.nelem; ++node_cnt)\n    {\n      Idx cur_node = state->nodes.elems[node_cnt];\n      if (check_node_accept (mctx, dfa->nodes + cur_node, cur_str_idx))\n\t{\n\t  *err = re_node_set_merge (&next_nodes,\n\t\t\t\t    dfa->eclosures + dfa->nexts[cur_node]);\n\t  if (BE (*err != REG_NOERROR, 0))\n\t    {\n\t      re_node_set_free (&next_nodes);\n\t      return NULL;\n\t    }\n\t}\n    }\n  context = re_string_context_at (&mctx->input, cur_str_idx, mctx->eflags);\n  next_state = re_acquire_state_context (err, dfa, &next_nodes, context);\n  /* We don't need to check errors here, since the return value of\n     this function is next_state and ERR is already set.  */\n\n  re_node_set_free (&next_nodes);\n  re_string_skip_bytes (&mctx->input, 1);\n  return next_state;\n}",
      "lines": 36,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "re_dfastate_t",
        "*\ntransit_state_sb (reg_errcode_t *err, re_match_context_t *mctx,\n\t\t  re_dfastate_t *state)",
        "*"
      ]
    },
    "transit_state_mb": {
      "start_point": [
        2459,
        0
      ],
      "end_point": [
        2526,
        1
      ],
      "content": "static reg_errcode_t\ntransit_state_mb (re_match_context_t *mctx, re_dfastate_t *pstate)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  reg_errcode_t err;\n  Idx i;\n\n  for (i = 0; i < pstate->nodes.nelem; ++i)\n    {\n      re_node_set dest_nodes, *new_nodes;\n      Idx cur_node_idx = pstate->nodes.elems[i];\n      int naccepted;\n      Idx dest_idx;\n      unsigned int context;\n      re_dfastate_t *dest_state;\n\n      if (!dfa->nodes[cur_node_idx].accept_mb)\n\tcontinue;\n\n      if (dfa->nodes[cur_node_idx].constraint)\n\t{\n\t  context = re_string_context_at (&mctx->input,\n\t\t\t\t\t  re_string_cur_idx (&mctx->input),\n\t\t\t\t\t  mctx->eflags);\n\t  if (NOT_SATISFY_NEXT_CONSTRAINT (dfa->nodes[cur_node_idx].constraint,\n\t\t\t\t\t   context))\n\t    continue;\n\t}\n\n      /* How many bytes the node can accept?  */\n      naccepted = check_node_accept_bytes (dfa, cur_node_idx, &mctx->input,\n\t\t\t\t\t   re_string_cur_idx (&mctx->input));\n      if (naccepted == 0)\n\tcontinue;\n\n      /* The node can accepts 'naccepted' bytes.  */\n      dest_idx = re_string_cur_idx (&mctx->input) + naccepted;\n      mctx->max_mb_elem_len = ((mctx->max_mb_elem_len < naccepted) ? naccepted\n\t\t\t       : mctx->max_mb_elem_len);\n      err = clean_state_log_if_needed (mctx, dest_idx);\n      if (BE (err != REG_NOERROR, 0))\n\treturn err;\n#ifdef DEBUG\n      assert (dfa->nexts[cur_node_idx] != -1);\n#endif\n      new_nodes = dfa->eclosures + dfa->nexts[cur_node_idx];\n\n      dest_state = mctx->state_log[dest_idx];\n      if (dest_state == NULL)\n\tdest_nodes = *new_nodes;\n      else\n\t{\n\t  err = re_node_set_init_union (&dest_nodes,\n\t\t\t\t\tdest_state->entrance_nodes, new_nodes);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return err;\n\t}\n      context = re_string_context_at (&mctx->input, dest_idx - 1,\n\t\t\t\t      mctx->eflags);\n      mctx->state_log[dest_idx]\n\t= re_acquire_state_context (&err, dfa, &dest_nodes, context);\n      if (dest_state != NULL)\n\tre_node_set_free (&dest_nodes);\n      if (BE (mctx->state_log[dest_idx] == NULL && err != REG_NOERROR, 0))\n\treturn err;\n    }\n  return REG_NOERROR;\n}",
      "lines": 68,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "transit_state_bkref": {
      "start_point": [
        2529,
        0
      ],
      "end_point": [
        2634,
        1
      ],
      "content": "static reg_errcode_t\ntransit_state_bkref (re_match_context_t *mctx, const re_node_set *nodes)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  reg_errcode_t err;\n  Idx i;\n  Idx cur_str_idx = re_string_cur_idx (&mctx->input);\n\n  for (i = 0; i < nodes->nelem; ++i)\n    {\n      Idx dest_str_idx, prev_nelem, bkc_idx;\n      Idx node_idx = nodes->elems[i];\n      unsigned int context;\n      const re_token_t *node = dfa->nodes + node_idx;\n      re_node_set *new_dest_nodes;\n\n      /* Check whether 'node' is a backreference or not.  */\n      if (node->type != OP_BACK_REF)\n\tcontinue;\n\n      if (node->constraint)\n\t{\n\t  context = re_string_context_at (&mctx->input, cur_str_idx,\n\t\t\t\t\t  mctx->eflags);\n\t  if (NOT_SATISFY_NEXT_CONSTRAINT (node->constraint, context))\n\t    continue;\n\t}\n\n      /* 'node' is a backreference.\n\t Check the substring which the substring matched.  */\n      bkc_idx = mctx->nbkref_ents;\n      err = get_subexp (mctx, node_idx, cur_str_idx);\n      if (BE (err != REG_NOERROR, 0))\n\tgoto free_return;\n\n      /* And add the epsilon closures (which is 'new_dest_nodes') of\n\t the backreference to appropriate state_log.  */\n#ifdef DEBUG\n      assert (dfa->nexts[node_idx] != -1);\n#endif\n      for (; bkc_idx < mctx->nbkref_ents; ++bkc_idx)\n\t{\n\t  Idx subexp_len;\n\t  re_dfastate_t *dest_state;\n\t  struct re_backref_cache_entry *bkref_ent;\n\t  bkref_ent = mctx->bkref_ents + bkc_idx;\n\t  if (bkref_ent->node != node_idx || bkref_ent->str_idx != cur_str_idx)\n\t    continue;\n\t  subexp_len = bkref_ent->subexp_to - bkref_ent->subexp_from;\n\t  new_dest_nodes = (subexp_len == 0\n\t\t\t    ? dfa->eclosures + dfa->edests[node_idx].elems[0]\n\t\t\t    : dfa->eclosures + dfa->nexts[node_idx]);\n\t  dest_str_idx = (cur_str_idx + bkref_ent->subexp_to\n\t\t\t  - bkref_ent->subexp_from);\n\t  context = re_string_context_at (&mctx->input, dest_str_idx - 1,\n\t\t\t\t\t  mctx->eflags);\n\t  dest_state = mctx->state_log[dest_str_idx];\n\t  prev_nelem = ((mctx->state_log[cur_str_idx] == NULL) ? 0\n\t\t\t: mctx->state_log[cur_str_idx]->nodes.nelem);\n\t  /* Add 'new_dest_node' to state_log.  */\n\t  if (dest_state == NULL)\n\t    {\n\t      mctx->state_log[dest_str_idx]\n\t\t= re_acquire_state_context (&err, dfa, new_dest_nodes,\n\t\t\t\t\t    context);\n\t      if (BE (mctx->state_log[dest_str_idx] == NULL\n\t\t      && err != REG_NOERROR, 0))\n\t\tgoto free_return;\n\t    }\n\t  else\n\t    {\n\t      re_node_set dest_nodes;\n\t      err = re_node_set_init_union (&dest_nodes,\n\t\t\t\t\t    dest_state->entrance_nodes,\n\t\t\t\t\t    new_dest_nodes);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\t{\n\t\t  re_node_set_free (&dest_nodes);\n\t\t  goto free_return;\n\t\t}\n\t      mctx->state_log[dest_str_idx]\n\t\t= re_acquire_state_context (&err, dfa, &dest_nodes, context);\n\t      re_node_set_free (&dest_nodes);\n\t      if (BE (mctx->state_log[dest_str_idx] == NULL\n\t\t      && err != REG_NOERROR, 0))\n\t\tgoto free_return;\n\t    }\n\t  /* We need to check recursively if the backreference can epsilon\n\t     transit.  */\n\t  if (subexp_len == 0\n\t      && mctx->state_log[cur_str_idx]->nodes.nelem > prev_nelem)\n\t    {\n\t      err = check_subexp_matching_top (mctx, new_dest_nodes,\n\t\t\t\t\t       cur_str_idx);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\tgoto free_return;\n\t      err = transit_state_bkref (mctx, new_dest_nodes);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\tgoto free_return;\n\t    }\n\t}\n    }\n  err = REG_NOERROR;\n free_return:\n  return err;\n}",
      "lines": 106,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "get_subexp_sub": {
      "start_point": [
        2792,
        0
      ],
      "end_point": [
        2810,
        1
      ],
      "content": "static reg_errcode_t\nget_subexp_sub (re_match_context_t *mctx, const re_sub_match_top_t *sub_top,\n\t\tre_sub_match_last_t *sub_last, Idx bkref_node, Idx bkref_str)\n{\n  reg_errcode_t err;\n  Idx to_idx;\n  /* Can the subexpression arrive the back reference?  */\n  err = check_arrival (mctx, &sub_last->path, sub_last->node,\n\t\t       sub_last->str_idx, bkref_node, bkref_str,\n\t\t       OP_OPEN_SUBEXP);\n  if (err != REG_NOERROR)\n    return err;\n  err = match_ctx_add_entry (mctx, bkref_node, bkref_str, sub_top->str_idx,\n\t\t\t     sub_last->str_idx);\n  if (BE (err != REG_NOERROR, 0))\n    return err;\n  to_idx = bkref_str + sub_last->str_idx - sub_top->str_idx;\n  return clean_state_log_if_needed (mctx, to_idx);\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "find_subexp_node": {
      "start_point": [
        2820,
        0
      ],
      "end_point": [
        2834,
        1
      ],
      "content": "static Idx\nfind_subexp_node (const re_dfa_t *dfa, const re_node_set *nodes,\n\t\t  Idx subexp_idx, int type)\n{\n  Idx cls_idx;\n  for (cls_idx = 0; cls_idx < nodes->nelem; ++cls_idx)\n    {\n      Idx cls_node = nodes->elems[cls_idx];\n      const re_token_t *node = dfa->nodes + cls_node;\n      if (node->type == type\n\t  && node->opr.idx == subexp_idx)\n\treturn cls_node;\n    }\n  return -1;\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "Idx"
      ]
    },
    "check_arrival": {
      "start_point": [
        2841,
        0
      ],
      "end_point": [
        2996,
        1
      ],
      "content": "static reg_errcode_t\n__attribute_warn_unused_result__\ncheck_arrival (re_match_context_t *mctx, state_array_t *path, Idx top_node,\n\t       Idx top_str, Idx last_node, Idx last_str, int type)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  reg_errcode_t err = REG_NOERROR;\n  Idx subexp_num, backup_cur_idx, str_idx, null_cnt;\n  re_dfastate_t *cur_state = NULL;\n  re_node_set *cur_nodes, next_nodes;\n  re_dfastate_t **backup_state_log;\n  unsigned int context;\n\n  subexp_num = dfa->nodes[top_node].opr.idx;\n  /* Extend the buffer if we need.  */\n  if (BE (path->alloc < last_str + mctx->max_mb_elem_len + 1, 0))\n    {\n      re_dfastate_t **new_array;\n      Idx old_alloc = path->alloc;\n      Idx incr_alloc = last_str + mctx->max_mb_elem_len + 1;\n      Idx new_alloc;\n      if (BE (IDX_MAX - old_alloc < incr_alloc, 0))\n\treturn REG_ESPACE;\n      new_alloc = old_alloc + incr_alloc;\n      if (BE (SIZE_MAX / sizeof (re_dfastate_t *) < new_alloc, 0))\n\treturn REG_ESPACE;\n      new_array = re_realloc (path->array, re_dfastate_t *, new_alloc);\n      if (BE (new_array == NULL, 0))\n\treturn REG_ESPACE;\n      path->array = new_array;\n      path->alloc = new_alloc;\n      memset (new_array + old_alloc, '\\0',\n\t      sizeof (re_dfastate_t *) * (path->alloc - old_alloc));\n    }\n\n  str_idx = path->next_idx ? path->next_idx : top_str;\n\n  /* Temporary modify MCTX.  */\n  backup_state_log = mctx->state_log;\n  backup_cur_idx = mctx->input.cur_idx;\n  mctx->state_log = path->array;\n  mctx->input.cur_idx = str_idx;\n\n  /* Setup initial node set.  */\n  context = re_string_context_at (&mctx->input, str_idx - 1, mctx->eflags);\n  if (str_idx == top_str)\n    {\n      err = re_node_set_init_1 (&next_nodes, top_node);\n      if (BE (err != REG_NOERROR, 0))\n\treturn err;\n      err = check_arrival_expand_ecl (dfa, &next_nodes, subexp_num, type);\n      if (BE (err != REG_NOERROR, 0))\n\t{\n\t  re_node_set_free (&next_nodes);\n\t  return err;\n\t}\n    }\n  else\n    {\n      cur_state = mctx->state_log[str_idx];\n      if (cur_state && cur_state->has_backref)\n\t{\n\t  err = re_node_set_init_copy (&next_nodes, &cur_state->nodes);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return err;\n\t}\n      else\n\tre_node_set_init_empty (&next_nodes);\n    }\n  if (str_idx == top_str || (cur_state && cur_state->has_backref))\n    {\n      if (next_nodes.nelem)\n\t{\n\t  err = expand_bkref_cache (mctx, &next_nodes, str_idx,\n\t\t\t\t    subexp_num, type);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    {\n\t      re_node_set_free (&next_nodes);\n\t      return err;\n\t    }\n\t}\n      cur_state = re_acquire_state_context (&err, dfa, &next_nodes, context);\n      if (BE (cur_state == NULL && err != REG_NOERROR, 0))\n\t{\n\t  re_node_set_free (&next_nodes);\n\t  return err;\n\t}\n      mctx->state_log[str_idx] = cur_state;\n    }\n\n  for (null_cnt = 0; str_idx < last_str && null_cnt <= mctx->max_mb_elem_len;)\n    {\n      re_node_set_empty (&next_nodes);\n      if (mctx->state_log[str_idx + 1])\n\t{\n\t  err = re_node_set_merge (&next_nodes,\n\t\t\t\t   &mctx->state_log[str_idx + 1]->nodes);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    {\n\t      re_node_set_free (&next_nodes);\n\t      return err;\n\t    }\n\t}\n      if (cur_state)\n\t{\n\t  err = check_arrival_add_next_nodes (mctx, str_idx,\n\t\t\t\t\t      &cur_state->non_eps_nodes,\n\t\t\t\t\t      &next_nodes);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    {\n\t      re_node_set_free (&next_nodes);\n\t      return err;\n\t    }\n\t}\n      ++str_idx;\n      if (next_nodes.nelem)\n\t{\n\t  err = check_arrival_expand_ecl (dfa, &next_nodes, subexp_num, type);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    {\n\t      re_node_set_free (&next_nodes);\n\t      return err;\n\t    }\n\t  err = expand_bkref_cache (mctx, &next_nodes, str_idx,\n\t\t\t\t    subexp_num, type);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    {\n\t      re_node_set_free (&next_nodes);\n\t      return err;\n\t    }\n\t}\n      context = re_string_context_at (&mctx->input, str_idx - 1, mctx->eflags);\n      cur_state = re_acquire_state_context (&err, dfa, &next_nodes, context);\n      if (BE (cur_state == NULL && err != REG_NOERROR, 0))\n\t{\n\t  re_node_set_free (&next_nodes);\n\t  return err;\n\t}\n      mctx->state_log[str_idx] = cur_state;\n      null_cnt = cur_state == NULL ? null_cnt + 1 : 0;\n    }\n  re_node_set_free (&next_nodes);\n  cur_nodes = (mctx->state_log[last_str] == NULL ? NULL\n\t       : &mctx->state_log[last_str]->nodes);\n  path->next_idx = str_idx;\n\n  /* Fix MCTX.  */\n  mctx->state_log = backup_state_log;\n  mctx->input.cur_idx = backup_cur_idx;\n\n  /* Then check the current node set has the node LAST_NODE.  */\n  if (cur_nodes != NULL && re_node_set_contains (cur_nodes, last_node))\n    return REG_NOERROR;\n\n  return REG_NOMATCH;\n}",
      "lines": 156,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "__attribute_warn_unused_result__",
        "__attribute_warn_unused_result__"
      ]
    },
    "check_arrival_add_next_nodes": {
      "start_point": [
        3006,
        0
      ],
      "end_point": [
        3079,
        1
      ],
      "content": "static reg_errcode_t\n__attribute_warn_unused_result__\ncheck_arrival_add_next_nodes (re_match_context_t *mctx, Idx str_idx,\n\t\t\t      re_node_set *cur_nodes, re_node_set *next_nodes)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  bool ok;\n  Idx cur_idx;\n#ifdef RE_ENABLE_I18N\n  reg_errcode_t err = REG_NOERROR;\n#endif\n  re_node_set union_set;\n  re_node_set_init_empty (&union_set);\n  for (cur_idx = 0; cur_idx < cur_nodes->nelem; ++cur_idx)\n    {\n      int naccepted = 0;\n      Idx cur_node = cur_nodes->elems[cur_idx];\n#ifdef DEBUG\n      re_token_type_t type = dfa->nodes[cur_node].type;\n      assert (!IS_EPSILON_NODE (type));\n#endif\n#ifdef RE_ENABLE_I18N\n      /* If the node may accept \"multi byte\".  */\n      if (dfa->nodes[cur_node].accept_mb)\n\t{\n\t  naccepted = check_node_accept_bytes (dfa, cur_node, &mctx->input,\n\t\t\t\t\t       str_idx);\n\t  if (naccepted > 1)\n\t    {\n\t      re_dfastate_t *dest_state;\n\t      Idx next_node = dfa->nexts[cur_node];\n\t      Idx next_idx = str_idx + naccepted;\n\t      dest_state = mctx->state_log[next_idx];\n\t      re_node_set_empty (&union_set);\n\t      if (dest_state)\n\t\t{\n\t\t  err = re_node_set_merge (&union_set, &dest_state->nodes);\n\t\t  if (BE (err != REG_NOERROR, 0))\n\t\t    {\n\t\t      re_node_set_free (&union_set);\n\t\t      return err;\n\t\t    }\n\t\t}\n\t      ok = re_node_set_insert (&union_set, next_node);\n\t      if (BE (! ok, 0))\n\t\t{\n\t\t  re_node_set_free (&union_set);\n\t\t  return REG_ESPACE;\n\t\t}\n\t      mctx->state_log[next_idx] = re_acquire_state (&err, dfa,\n\t\t\t\t\t\t\t    &union_set);\n\t      if (BE (mctx->state_log[next_idx] == NULL\n\t\t      && err != REG_NOERROR, 0))\n\t\t{\n\t\t  re_node_set_free (&union_set);\n\t\t  return err;\n\t\t}\n\t    }\n\t}\n#endif /* RE_ENABLE_I18N */\n      if (naccepted\n\t  || check_node_accept (mctx, dfa->nodes + cur_node, str_idx))\n\t{\n\t  ok = re_node_set_insert (next_nodes, dfa->nexts[cur_node]);\n\t  if (BE (! ok, 0))\n\t    {\n\t      re_node_set_free (&union_set);\n\t      return REG_ESPACE;\n\t    }\n\t}\n    }\n  re_node_set_free (&union_set);\n  return REG_NOERROR;\n}",
      "lines": 74,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "__attribute_warn_unused_result__",
        "__attribute_warn_unused_result__"
      ]
    },
    "check_arrival_expand_ecl": {
      "start_point": [
        3087,
        0
      ],
      "end_point": [
        3133,
        1
      ],
      "content": "static reg_errcode_t\ncheck_arrival_expand_ecl (const re_dfa_t *dfa, re_node_set *cur_nodes,\n\t\t\t  Idx ex_subexp, int type)\n{\n  reg_errcode_t err;\n  Idx idx, outside_node;\n  re_node_set new_nodes;\n#ifdef DEBUG\n  assert (cur_nodes->nelem);\n#endif\n  err = re_node_set_alloc (&new_nodes, cur_nodes->nelem);\n  if (BE (err != REG_NOERROR, 0))\n    return err;\n  /* Create a new node set NEW_NODES with the nodes which are epsilon\n     closures of the node in CUR_NODES.  */\n\n  for (idx = 0; idx < cur_nodes->nelem; ++idx)\n    {\n      Idx cur_node = cur_nodes->elems[idx];\n      const re_node_set *eclosure = dfa->eclosures + cur_node;\n      outside_node = find_subexp_node (dfa, eclosure, ex_subexp, type);\n      if (outside_node == -1)\n\t{\n\t  /* There are no problematic nodes, just merge them.  */\n\t  err = re_node_set_merge (&new_nodes, eclosure);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    {\n\t      re_node_set_free (&new_nodes);\n\t      return err;\n\t    }\n\t}\n      else\n\t{\n\t  /* There are problematic nodes, re-calculate incrementally.  */\n\t  err = check_arrival_expand_ecl_sub (dfa, &new_nodes, cur_node,\n\t\t\t\t\t      ex_subexp, type);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    {\n\t      re_node_set_free (&new_nodes);\n\t      return err;\n\t    }\n\t}\n    }\n  re_node_set_free (cur_nodes);\n  *cur_nodes = new_nodes;\n  return REG_NOERROR;\n}",
      "lines": 47,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "check_arrival_expand_ecl_sub": {
      "start_point": [
        3139,
        0
      ],
      "end_point": [
        3177,
        1
      ],
      "content": "static reg_errcode_t\n__attribute_warn_unused_result__\ncheck_arrival_expand_ecl_sub (const re_dfa_t *dfa, re_node_set *dst_nodes,\n\t\t\t      Idx target, Idx ex_subexp, int type)\n{\n  Idx cur_node;\n  for (cur_node = target; !re_node_set_contains (dst_nodes, cur_node);)\n    {\n      bool ok;\n\n      if (dfa->nodes[cur_node].type == type\n\t  && dfa->nodes[cur_node].opr.idx == ex_subexp)\n\t{\n\t  if (type == OP_CLOSE_SUBEXP)\n\t    {\n\t      ok = re_node_set_insert (dst_nodes, cur_node);\n\t      if (BE (! ok, 0))\n\t\treturn REG_ESPACE;\n\t    }\n\t  break;\n\t}\n      ok = re_node_set_insert (dst_nodes, cur_node);\n      if (BE (! ok, 0))\n\treturn REG_ESPACE;\n      if (dfa->edests[cur_node].nelem == 0)\n\tbreak;\n      if (dfa->edests[cur_node].nelem == 2)\n\t{\n\t  reg_errcode_t err;\n\t  err = check_arrival_expand_ecl_sub (dfa, dst_nodes,\n\t\t\t\t\t      dfa->edests[cur_node].elems[1],\n\t\t\t\t\t      ex_subexp, type);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return err;\n\t}\n      cur_node = dfa->edests[cur_node].elems[0];\n    }\n  return REG_NOERROR;\n}",
      "lines": 39,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "__attribute_warn_unused_result__",
        "__attribute_warn_unused_result__"
      ]
    },
    "expand_bkref_cache": {
      "start_point": [
        3184,
        0
      ],
      "end_point": [
        3268,
        1
      ],
      "content": "static reg_errcode_t\n__attribute_warn_unused_result__\nexpand_bkref_cache (re_match_context_t *mctx, re_node_set *cur_nodes,\n\t\t    Idx cur_str, Idx subexp_num, int type)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  reg_errcode_t err;\n  Idx cache_idx_start = search_cur_bkref_entry (mctx, cur_str);\n  struct re_backref_cache_entry *ent;\n\n  if (cache_idx_start == -1)\n    return REG_NOERROR;\n\n restart:\n  ent = mctx->bkref_ents + cache_idx_start;\n  do\n    {\n      Idx to_idx, next_node;\n\n      /* Is this entry ENT is appropriate?  */\n      if (!re_node_set_contains (cur_nodes, ent->node))\n\tcontinue; /* No.  */\n\n      to_idx = cur_str + ent->subexp_to - ent->subexp_from;\n      /* Calculate the destination of the back reference, and append it\n\t to MCTX->STATE_LOG.  */\n      if (to_idx == cur_str)\n\t{\n\t  /* The backreference did epsilon transit, we must re-check all the\n\t     node in the current state.  */\n\t  re_node_set new_dests;\n\t  reg_errcode_t err2, err3;\n\t  next_node = dfa->edests[ent->node].elems[0];\n\t  if (re_node_set_contains (cur_nodes, next_node))\n\t    continue;\n\t  err = re_node_set_init_1 (&new_dests, next_node);\n\t  err2 = check_arrival_expand_ecl (dfa, &new_dests, subexp_num, type);\n\t  err3 = re_node_set_merge (cur_nodes, &new_dests);\n\t  re_node_set_free (&new_dests);\n\t  if (BE (err != REG_NOERROR || err2 != REG_NOERROR\n\t\t  || err3 != REG_NOERROR, 0))\n\t    {\n\t      err = (err != REG_NOERROR ? err\n\t\t     : (err2 != REG_NOERROR ? err2 : err3));\n\t      return err;\n\t    }\n\t  /* TODO: It is still inefficient...  */\n\t  goto restart;\n\t}\n      else\n\t{\n\t  re_node_set union_set;\n\t  next_node = dfa->nexts[ent->node];\n\t  if (mctx->state_log[to_idx])\n\t    {\n\t      bool ok;\n\t      if (re_node_set_contains (&mctx->state_log[to_idx]->nodes,\n\t\t\t\t\tnext_node))\n\t\tcontinue;\n\t      err = re_node_set_init_copy (&union_set,\n\t\t\t\t\t   &mctx->state_log[to_idx]->nodes);\n\t      ok = re_node_set_insert (&union_set, next_node);\n\t      if (BE (err != REG_NOERROR || ! ok, 0))\n\t\t{\n\t\t  re_node_set_free (&union_set);\n\t\t  err = err != REG_NOERROR ? err : REG_ESPACE;\n\t\t  return err;\n\t\t}\n\t    }\n\t  else\n\t    {\n\t      err = re_node_set_init_1 (&union_set, next_node);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\treturn err;\n\t    }\n\t  mctx->state_log[to_idx] = re_acquire_state (&err, dfa, &union_set);\n\t  re_node_set_free (&union_set);\n\t  if (BE (mctx->state_log[to_idx] == NULL\n\t\t  && err != REG_NOERROR, 0))\n\t    return err;\n\t}\n    }\n  while (ent++->more);\n  return REG_NOERROR;\n}",
      "lines": 85,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "__attribute_warn_unused_result__",
        "__attribute_warn_unused_result__"
      ]
    },
    "build_trtable": {
      "start_point": [
        3273,
        0
      ],
      "end_point": [
        3502,
        1
      ],
      "content": "static bool\nbuild_trtable (const re_dfa_t *dfa, re_dfastate_t *state)\n{\n  reg_errcode_t err;\n  Idx i, j;\n  int ch;\n  bool need_word_trtable = false;\n  bitset_word_t elem, mask;\n  bool dests_node_malloced = false;\n  bool dest_states_malloced = false;\n  Idx ndests; /* Number of the destination states from 'state'.  */\n  re_dfastate_t **trtable;\n  re_dfastate_t **dest_states = NULL, **dest_states_word, **dest_states_nl;\n  re_node_set follows, *dests_node;\n  bitset_t *dests_ch;\n  bitset_t acceptable;\n\n  struct dests_alloc\n  {\n    re_node_set dests_node[SBC_MAX];\n    bitset_t dests_ch[SBC_MAX];\n  } *dests_alloc;\n\n  /* We build DFA states which corresponds to the destination nodes\n     from 'state'.  'dests_node[i]' represents the nodes which i-th\n     destination state contains, and 'dests_ch[i]' represents the\n     characters which i-th destination state accepts.  */\n  if (__libc_use_alloca (sizeof (struct dests_alloc)))\n    dests_alloc = (struct dests_alloc *) alloca (sizeof (struct dests_alloc));\n  else\n    {\n      dests_alloc = re_malloc (struct dests_alloc, 1);\n      if (BE (dests_alloc == NULL, 0))\n\treturn false;\n      dests_node_malloced = true;\n    }\n  dests_node = dests_alloc->dests_node;\n  dests_ch = dests_alloc->dests_ch;\n\n  /* Initialize transition table.  */\n  state->word_trtable = state->trtable = NULL;\n\n  /* At first, group all nodes belonging to 'state' into several\n     destinations.  */\n  ndests = group_nodes_into_DFAstates (dfa, state, dests_node, dests_ch);\n  if (BE (ndests <= 0, 0))\n    {\n      if (dests_node_malloced)\n\tre_free (dests_alloc);\n      /* Return false in case of an error, true otherwise.  */\n      if (ndests == 0)\n\t{\n\t  state->trtable = (re_dfastate_t **)\n\t    calloc (sizeof (re_dfastate_t *), SBC_MAX);\n          if (BE (state->trtable == NULL, 0))\n            return false;\n\t  return true;\n\t}\n      return false;\n    }\n\n  err = re_node_set_alloc (&follows, ndests + 1);\n  if (BE (err != REG_NOERROR, 0))\n    goto out_free;\n\n  /* Avoid arithmetic overflow in size calculation.  */\n  if (BE ((((SIZE_MAX - (sizeof (re_node_set) + sizeof (bitset_t)) * SBC_MAX)\n\t    / (3 * sizeof (re_dfastate_t *)))\n\t   < ndests),\n\t  0))\n    goto out_free;\n\n  if (__libc_use_alloca ((sizeof (re_node_set) + sizeof (bitset_t)) * SBC_MAX\n\t\t\t + ndests * 3 * sizeof (re_dfastate_t *)))\n    dest_states = (re_dfastate_t **)\n      alloca (ndests * 3 * sizeof (re_dfastate_t *));\n  else\n    {\n      dest_states = re_malloc (re_dfastate_t *, ndests * 3);\n      if (BE (dest_states == NULL, 0))\n\t{\nout_free:\n\t  if (dest_states_malloced)\n\t    re_free (dest_states);\n\t  re_node_set_free (&follows);\n\t  for (i = 0; i < ndests; ++i)\n\t    re_node_set_free (dests_node + i);\n\t  if (dests_node_malloced)\n\t    re_free (dests_alloc);\n\t  return false;\n\t}\n      dest_states_malloced = true;\n    }\n  dest_states_word = dest_states + ndests;\n  dest_states_nl = dest_states_word + ndests;\n  bitset_empty (acceptable);\n\n  /* Then build the states for all destinations.  */\n  for (i = 0; i < ndests; ++i)\n    {\n      Idx next_node;\n      re_node_set_empty (&follows);\n      /* Merge the follows of this destination states.  */\n      for (j = 0; j < dests_node[i].nelem; ++j)\n\t{\n\t  next_node = dfa->nexts[dests_node[i].elems[j]];\n\t  if (next_node != -1)\n\t    {\n\t      err = re_node_set_merge (&follows, dfa->eclosures + next_node);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\tgoto out_free;\n\t    }\n\t}\n      dest_states[i] = re_acquire_state_context (&err, dfa, &follows, 0);\n      if (BE (dest_states[i] == NULL && err != REG_NOERROR, 0))\n\tgoto out_free;\n      /* If the new state has context constraint,\n\t build appropriate states for these contexts.  */\n      if (dest_states[i]->has_constraint)\n\t{\n\t  dest_states_word[i] = re_acquire_state_context (&err, dfa, &follows,\n\t\t\t\t\t\t\t  CONTEXT_WORD);\n\t  if (BE (dest_states_word[i] == NULL && err != REG_NOERROR, 0))\n\t    goto out_free;\n\n\t  if (dest_states[i] != dest_states_word[i] && dfa->mb_cur_max > 1)\n\t    need_word_trtable = true;\n\n\t  dest_states_nl[i] = re_acquire_state_context (&err, dfa, &follows,\n\t\t\t\t\t\t\tCONTEXT_NEWLINE);\n\t  if (BE (dest_states_nl[i] == NULL && err != REG_NOERROR, 0))\n\t    goto out_free;\n\t}\n      else\n\t{\n\t  dest_states_word[i] = dest_states[i];\n\t  dest_states_nl[i] = dest_states[i];\n\t}\n      bitset_merge (acceptable, dests_ch[i]);\n    }\n\n  if (!BE (need_word_trtable, 0))\n    {\n      /* We don't care about whether the following character is a word\n\t character, or we are in a single-byte character set so we can\n\t discern by looking at the character code: allocate a\n\t 256-entry transition table.  */\n      trtable = state->trtable =\n\t(re_dfastate_t **) calloc (sizeof (re_dfastate_t *), SBC_MAX);\n      if (BE (trtable == NULL, 0))\n\tgoto out_free;\n\n      /* For all characters ch...:  */\n      for (i = 0; i < BITSET_WORDS; ++i)\n\tfor (ch = i * BITSET_WORD_BITS, elem = acceptable[i], mask = 1;\n\t     elem;\n\t     mask <<= 1, elem >>= 1, ++ch)\n\t  if (BE (elem & 1, 0))\n\t    {\n\t      /* There must be exactly one destination which accepts\n\t\t character ch.  See group_nodes_into_DFAstates.  */\n\t      for (j = 0; (dests_ch[j][i] & mask) == 0; ++j)\n\t\t;\n\n\t      /* j-th destination accepts the word character ch.  */\n\t      if (dfa->word_char[i] & mask)\n\t\ttrtable[ch] = dest_states_word[j];\n\t      else\n\t\ttrtable[ch] = dest_states[j];\n\t    }\n    }\n  else\n    {\n      /* We care about whether the following character is a word\n\t character, and we are in a multi-byte character set: discern\n\t by looking at the character code: build two 256-entry\n\t transition tables, one starting at trtable[0] and one\n\t starting at trtable[SBC_MAX].  */\n      trtable = state->word_trtable =\n\t(re_dfastate_t **) calloc (sizeof (re_dfastate_t *), 2 * SBC_MAX);\n      if (BE (trtable == NULL, 0))\n\tgoto out_free;\n\n      /* For all characters ch...:  */\n      for (i = 0; i < BITSET_WORDS; ++i)\n\tfor (ch = i * BITSET_WORD_BITS, elem = acceptable[i], mask = 1;\n\t     elem;\n\t     mask <<= 1, elem >>= 1, ++ch)\n\t  if (BE (elem & 1, 0))\n\t    {\n\t      /* There must be exactly one destination which accepts\n\t\t character ch.  See group_nodes_into_DFAstates.  */\n\t      for (j = 0; (dests_ch[j][i] & mask) == 0; ++j)\n\t\t;\n\n\t      /* j-th destination accepts the word character ch.  */\n\t      trtable[ch] = dest_states[j];\n\t      trtable[ch + SBC_MAX] = dest_states_word[j];\n\t    }\n    }\n\n  /* new line */\n  if (bitset_contain (acceptable, NEWLINE_CHAR))\n    {\n      /* The current state accepts newline character.  */\n      for (j = 0; j < ndests; ++j)\n\tif (bitset_contain (dests_ch[j], NEWLINE_CHAR))\n\t  {\n\t    /* k-th destination accepts newline character.  */\n\t    trtable[NEWLINE_CHAR] = dest_states_nl[j];\n\t    if (need_word_trtable)\n\t      trtable[NEWLINE_CHAR + SBC_MAX] = dest_states_nl[j];\n\t    /* There must be only one destination which accepts\n\t       newline.  See group_nodes_into_DFAstates.  */\n\t    break;\n\t  }\n    }\n\n  if (dest_states_malloced)\n    re_free (dest_states);\n\n  re_node_set_free (&follows);\n  for (i = 0; i < ndests; ++i)\n    re_node_set_free (dests_node + i);\n\n  if (dests_node_malloced)\n    re_free (dests_alloc);\n\n  return true;\n}",
      "lines": 230,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "group_nodes_into_DFAstates": {
      "start_point": [
        3509,
        0
      ],
      "end_point": [
        3690,
        1
      ],
      "content": "static Idx\ngroup_nodes_into_DFAstates (const re_dfa_t *dfa, const re_dfastate_t *state,\n\t\t\t    re_node_set *dests_node, bitset_t *dests_ch)\n{\n  reg_errcode_t err;\n  bool ok;\n  Idx i, j, k;\n  Idx ndests; /* Number of the destinations from 'state'.  */\n  bitset_t accepts; /* Characters a node can accept.  */\n  const re_node_set *cur_nodes = &state->nodes;\n  bitset_empty (accepts);\n  ndests = 0;\n\n  /* For all the nodes belonging to 'state',  */\n  for (i = 0; i < cur_nodes->nelem; ++i)\n    {\n      re_token_t *node = &dfa->nodes[cur_nodes->elems[i]];\n      re_token_type_t type = node->type;\n      unsigned int constraint = node->constraint;\n\n      /* Enumerate all single byte character this node can accept.  */\n      if (type == CHARACTER)\n\tbitset_set (accepts, node->opr.c);\n      else if (type == SIMPLE_BRACKET)\n\t{\n\t  bitset_merge (accepts, node->opr.sbcset);\n\t}\n      else if (type == OP_PERIOD)\n\t{\n#ifdef RE_ENABLE_I18N\n\t  if (dfa->mb_cur_max > 1)\n\t    bitset_merge (accepts, dfa->sb_char);\n\t  else\n#endif\n\t    bitset_set_all (accepts);\n\t  if (!(dfa->syntax & RE_DOT_NEWLINE))\n\t    bitset_clear (accepts, '\\n');\n\t  if (dfa->syntax & RE_DOT_NOT_NULL)\n\t    bitset_clear (accepts, '\\0');\n\t}\n#ifdef RE_ENABLE_I18N\n      else if (type == OP_UTF8_PERIOD)\n\t{\n\t  if (ASCII_CHARS % BITSET_WORD_BITS == 0)\n\t    memset (accepts, -1, ASCII_CHARS / CHAR_BIT);\n\t  else\n\t    bitset_merge (accepts, utf8_sb_map);\n\t  if (!(dfa->syntax & RE_DOT_NEWLINE))\n\t    bitset_clear (accepts, '\\n');\n\t  if (dfa->syntax & RE_DOT_NOT_NULL)\n\t    bitset_clear (accepts, '\\0');\n\t}\n#endif\n      else\n\tcontinue;\n\n      /* Check the 'accepts' and sift the characters which are not\n\t match it the context.  */\n      if (constraint)\n\t{\n\t  if (constraint & NEXT_NEWLINE_CONSTRAINT)\n\t    {\n\t      bool accepts_newline = bitset_contain (accepts, NEWLINE_CHAR);\n\t      bitset_empty (accepts);\n\t      if (accepts_newline)\n\t\tbitset_set (accepts, NEWLINE_CHAR);\n\t      else\n\t\tcontinue;\n\t    }\n\t  if (constraint & NEXT_ENDBUF_CONSTRAINT)\n\t    {\n\t      bitset_empty (accepts);\n\t      continue;\n\t    }\n\n\t  if (constraint & NEXT_WORD_CONSTRAINT)\n\t    {\n\t      bitset_word_t any_set = 0;\n\t      if (type == CHARACTER && !node->word_char)\n\t\t{\n\t\t  bitset_empty (accepts);\n\t\t  continue;\n\t\t}\n#ifdef RE_ENABLE_I18N\n\t      if (dfa->mb_cur_max > 1)\n\t\tfor (j = 0; j < BITSET_WORDS; ++j)\n\t\t  any_set |= (accepts[j] &= (dfa->word_char[j] | ~dfa->sb_char[j]));\n\t      else\n#endif\n\t\tfor (j = 0; j < BITSET_WORDS; ++j)\n\t\t  any_set |= (accepts[j] &= dfa->word_char[j]);\n\t      if (!any_set)\n\t\tcontinue;\n\t    }\n\t  if (constraint & NEXT_NOTWORD_CONSTRAINT)\n\t    {\n\t      bitset_word_t any_set = 0;\n\t      if (type == CHARACTER && node->word_char)\n\t\t{\n\t\t  bitset_empty (accepts);\n\t\t  continue;\n\t\t}\n#ifdef RE_ENABLE_I18N\n\t      if (dfa->mb_cur_max > 1)\n\t\tfor (j = 0; j < BITSET_WORDS; ++j)\n\t\t  any_set |= (accepts[j] &= ~(dfa->word_char[j] & dfa->sb_char[j]));\n\t      else\n#endif\n\t\tfor (j = 0; j < BITSET_WORDS; ++j)\n\t\t  any_set |= (accepts[j] &= ~dfa->word_char[j]);\n\t      if (!any_set)\n\t\tcontinue;\n\t    }\n\t}\n\n      /* Then divide 'accepts' into DFA states, or create a new\n\t state.  Above, we make sure that accepts is not empty.  */\n      for (j = 0; j < ndests; ++j)\n\t{\n\t  bitset_t intersec; /* Intersection sets, see below.  */\n\t  bitset_t remains;\n\t  /* Flags, see below.  */\n\t  bitset_word_t has_intersec, not_subset, not_consumed;\n\n\t  /* Optimization, skip if this state doesn't accept the character.  */\n\t  if (type == CHARACTER && !bitset_contain (dests_ch[j], node->opr.c))\n\t    continue;\n\n\t  /* Enumerate the intersection set of this state and 'accepts'.  */\n\t  has_intersec = 0;\n\t  for (k = 0; k < BITSET_WORDS; ++k)\n\t    has_intersec |= intersec[k] = accepts[k] & dests_ch[j][k];\n\t  /* And skip if the intersection set is empty.  */\n\t  if (!has_intersec)\n\t    continue;\n\n\t  /* Then check if this state is a subset of 'accepts'.  */\n\t  not_subset = not_consumed = 0;\n\t  for (k = 0; k < BITSET_WORDS; ++k)\n\t    {\n\t      not_subset |= remains[k] = ~accepts[k] & dests_ch[j][k];\n\t      not_consumed |= accepts[k] = accepts[k] & ~dests_ch[j][k];\n\t    }\n\n\t  /* If this state isn't a subset of 'accepts', create a\n\t     new group state, which has the 'remains'. */\n\t  if (not_subset)\n\t    {\n\t      bitset_copy (dests_ch[ndests], remains);\n\t      bitset_copy (dests_ch[j], intersec);\n\t      err = re_node_set_init_copy (dests_node + ndests, &dests_node[j]);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\tgoto error_return;\n\t      ++ndests;\n\t    }\n\n\t  /* Put the position in the current group. */\n\t  ok = re_node_set_insert (&dests_node[j], cur_nodes->elems[i]);\n\t  if (BE (! ok, 0))\n\t    goto error_return;\n\n\t  /* If all characters are consumed, go to next node. */\n\t  if (!not_consumed)\n\t    break;\n\t}\n      /* Some characters remain, create a new group. */\n      if (j == ndests)\n\t{\n\t  bitset_copy (dests_ch[ndests], accepts);\n\t  err = re_node_set_init_1 (dests_node + ndests, cur_nodes->elems[i]);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    goto error_return;\n\t  ++ndests;\n\t  bitset_empty (accepts);\n\t}\n    }\n  return ndests;\n error_return:\n  for (j = 0; j < ndests; ++j)\n    re_node_set_free (dests_node + j);\n  return -1;\n}",
      "lines": 182,
      "depth": 21,
      "decorators": [
        "static",
        "static",
        "Idx"
      ]
    },
    "check_node_accept_bytes": {
      "start_point": [
        3705,
        0
      ],
      "end_point": [
        3931,
        1
      ],
      "content": "static int\ncheck_node_accept_bytes (const re_dfa_t *dfa, Idx node_idx,\n\t\t\t const re_string_t *input, Idx str_idx)\n{\n  const re_token_t *node = dfa->nodes + node_idx;\n  int char_len, elem_len;\n  Idx i;\n\n  if (BE (node->type == OP_UTF8_PERIOD, 0))\n    {\n      unsigned char c = re_string_byte_at (input, str_idx), d;\n      if (BE (c < 0xc2, 1))\n\treturn 0;\n\n      if (str_idx + 2 > input->len)\n\treturn 0;\n\n      d = re_string_byte_at (input, str_idx + 1);\n      if (c < 0xe0)\n\treturn (d < 0x80 || d > 0xbf) ? 0 : 2;\n      else if (c < 0xf0)\n\t{\n\t  char_len = 3;\n\t  if (c == 0xe0 && d < 0xa0)\n\t    return 0;\n\t}\n      else if (c < 0xf8)\n\t{\n\t  char_len = 4;\n\t  if (c == 0xf0 && d < 0x90)\n\t    return 0;\n\t}\n      else if (c < 0xfc)\n\t{\n\t  char_len = 5;\n\t  if (c == 0xf8 && d < 0x88)\n\t    return 0;\n\t}\n      else if (c < 0xfe)\n\t{\n\t  char_len = 6;\n\t  if (c == 0xfc && d < 0x84)\n\t    return 0;\n\t}\n      else\n\treturn 0;\n\n      if (str_idx + char_len > input->len)\n\treturn 0;\n\n      for (i = 1; i < char_len; ++i)\n\t{\n\t  d = re_string_byte_at (input, str_idx + i);\n\t  if (d < 0x80 || d > 0xbf)\n\t    return 0;\n\t}\n      return char_len;\n    }\n\n  char_len = re_string_char_size_at (input, str_idx);\n  if (node->type == OP_PERIOD)\n    {\n      if (char_len <= 1)\n\treturn 0;\n      /* FIXME: I don't think this if is needed, as both '\\n'\n\t and '\\0' are char_len == 1.  */\n      /* '.' accepts any one character except the following two cases.  */\n      if ((!(dfa->syntax & RE_DOT_NEWLINE) &&\n\t   re_string_byte_at (input, str_idx) == '\\n') ||\n\t  ((dfa->syntax & RE_DOT_NOT_NULL) &&\n\t   re_string_byte_at (input, str_idx) == '\\0'))\n\treturn 0;\n      return char_len;\n    }\n\n  elem_len = re_string_elem_size_at (input, str_idx);\n  if ((elem_len <= 1 && char_len <= 1) || char_len == 0)\n    return 0;\n\n  if (node->type == COMPLEX_BRACKET)\n    {\n      const re_charset_t *cset = node->opr.mbcset;\n# ifdef _LIBC\n      const unsigned char *pin\n\t= ((const unsigned char *) re_string_get_buffer (input) + str_idx);\n      Idx j;\n      uint32_t nrules;\n# endif /* _LIBC */\n      int match_len = 0;\n      wchar_t wc = ((cset->nranges || cset->nchar_classes || cset->nmbchars)\n\t\t    ? re_string_wchar_at (input, str_idx) : 0);\n\n      /* match with multibyte character?  */\n      for (i = 0; i < cset->nmbchars; ++i)\n\tif (wc == cset->mbchars[i])\n\t  {\n\t    match_len = char_len;\n\t    goto check_node_accept_bytes_match;\n\t  }\n      /* match with character_class?  */\n      for (i = 0; i < cset->nchar_classes; ++i)\n\t{\n\t  wctype_t wt = cset->char_classes[i];\n\t  if (__iswctype (wc, wt))\n\t    {\n\t      match_len = char_len;\n\t      goto check_node_accept_bytes_match;\n\t    }\n\t}\n\n# ifdef _LIBC\n      nrules = _NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_NRULES);\n      if (nrules != 0)\n\t{\n\t  unsigned int in_collseq = 0;\n\t  const int32_t *table, *indirect;\n\t  const unsigned char *weights, *extra;\n\t  const char *collseqwc;\n\n\t  /* match with collating_symbol?  */\n\t  if (cset->ncoll_syms)\n\t    extra = (const unsigned char *)\n\t      _NL_CURRENT (LC_COLLATE, _NL_COLLATE_SYMB_EXTRAMB);\n\t  for (i = 0; i < cset->ncoll_syms; ++i)\n\t    {\n\t      const unsigned char *coll_sym = extra + cset->coll_syms[i];\n\t      /* Compare the length of input collating element and\n\t\t the length of current collating element.  */\n\t      if (*coll_sym != elem_len)\n\t\tcontinue;\n\t      /* Compare each bytes.  */\n\t      for (j = 0; j < *coll_sym; j++)\n\t\tif (pin[j] != coll_sym[1 + j])\n\t\t  break;\n\t      if (j == *coll_sym)\n\t\t{\n\t\t  /* Match if every bytes is equal.  */\n\t\t  match_len = j;\n\t\t  goto check_node_accept_bytes_match;\n\t\t}\n\t    }\n\n\t  if (cset->nranges)\n\t    {\n\t      if (elem_len <= char_len)\n\t\t{\n\t\t  collseqwc = _NL_CURRENT (LC_COLLATE, _NL_COLLATE_COLLSEQWC);\n\t\t  in_collseq = __collseq_table_lookup (collseqwc, wc);\n\t\t}\n\t      else\n\t\tin_collseq = find_collation_sequence_value (pin, elem_len);\n\t    }\n\t  /* match with range expression?  */\n\t  /* FIXME: Implement rational ranges here, too.  */\n\t  for (i = 0; i < cset->nranges; ++i)\n\t    if (cset->range_starts[i] <= in_collseq\n\t\t&& in_collseq <= cset->range_ends[i])\n\t      {\n\t\tmatch_len = elem_len;\n\t\tgoto check_node_accept_bytes_match;\n\t      }\n\n\t  /* match with equivalence_class?  */\n\t  if (cset->nequiv_classes)\n\t    {\n\t      const unsigned char *cp = pin;\n\t      table = (const int32_t *)\n\t\t_NL_CURRENT (LC_COLLATE, _NL_COLLATE_TABLEMB);\n\t      weights = (const unsigned char *)\n\t\t_NL_CURRENT (LC_COLLATE, _NL_COLLATE_WEIGHTMB);\n\t      extra = (const unsigned char *)\n\t\t_NL_CURRENT (LC_COLLATE, _NL_COLLATE_EXTRAMB);\n\t      indirect = (const int32_t *)\n\t\t_NL_CURRENT (LC_COLLATE, _NL_COLLATE_INDIRECTMB);\n\t      int32_t idx = findidx (table, indirect, extra, &cp, elem_len);\n\t      if (idx > 0)\n\t\tfor (i = 0; i < cset->nequiv_classes; ++i)\n\t\t  {\n\t\t    int32_t equiv_class_idx = cset->equiv_classes[i];\n\t\t    size_t weight_len = weights[idx & 0xffffff];\n\t\t    if (weight_len == weights[equiv_class_idx & 0xffffff]\n\t\t\t&& (idx >> 24) == (equiv_class_idx >> 24))\n\t\t      {\n\t\t\tIdx cnt = 0;\n\n\t\t\tidx &= 0xffffff;\n\t\t\tequiv_class_idx &= 0xffffff;\n\n\t\t\twhile (cnt <= weight_len\n\t\t\t       && (weights[equiv_class_idx + 1 + cnt]\n\t\t\t\t   == weights[idx + 1 + cnt]))\n\t\t\t  ++cnt;\n\t\t\tif (cnt > weight_len)\n\t\t\t  {\n\t\t\t    match_len = elem_len;\n\t\t\t    goto check_node_accept_bytes_match;\n\t\t\t  }\n\t\t      }\n\t\t  }\n\t    }\n\t}\n      else\n# endif /* _LIBC */\n\t{\n\t  /* match with range expression?  */\n\t  for (i = 0; i < cset->nranges; ++i)\n\t    {\n\t      if (cset->range_starts[i] <= wc && wc <= cset->range_ends[i])\n\t\t{\n\t\t  match_len = char_len;\n\t\t  goto check_node_accept_bytes_match;\n\t\t}\n\t    }\n\t}\n    check_node_accept_bytes_match:\n      if (!cset->non_match)\n\treturn match_len;\n      else\n\t{\n\t  if (match_len > 0)\n\t    return 0;\n\t  else\n\t    return (elem_len > char_len) ? elem_len : char_len;\n\t}\n    }\n  return 0;\n}",
      "lines": 227,
      "depth": 23,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "find_collation_sequence_value": {
      "start_point": [
        3934,
        0
      ],
      "end_point": [
        3990,
        1
      ],
      "content": "static unsigned int\nfind_collation_sequence_value (const unsigned char *mbs, size_t mbs_len)\n{\n  uint32_t nrules = _NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_NRULES);\n  if (nrules == 0)\n    {\n      if (mbs_len == 1)\n\t{\n\t  /* No valid character.  Match it as a single byte character.  */\n\t  const unsigned char *collseq = (const unsigned char *)\n\t    _NL_CURRENT (LC_COLLATE, _NL_COLLATE_COLLSEQMB);\n\t  return collseq[mbs[0]];\n\t}\n      return UINT_MAX;\n    }\n  else\n    {\n      int32_t idx;\n      const unsigned char *extra = (const unsigned char *)\n\t_NL_CURRENT (LC_COLLATE, _NL_COLLATE_SYMB_EXTRAMB);\n      int32_t extrasize = (const unsigned char *)\n\t_NL_CURRENT (LC_COLLATE, _NL_COLLATE_SYMB_EXTRAMB + 1) - extra;\n\n      for (idx = 0; idx < extrasize;)\n\t{\n\t  int mbs_cnt;\n\t  bool found = false;\n\t  int32_t elem_mbs_len;\n\t  /* Skip the name of collating element name.  */\n\t  idx = idx + extra[idx] + 1;\n\t  elem_mbs_len = extra[idx++];\n\t  if (mbs_len == elem_mbs_len)\n\t    {\n\t      for (mbs_cnt = 0; mbs_cnt < elem_mbs_len; ++mbs_cnt)\n\t\tif (extra[idx + mbs_cnt] != mbs[mbs_cnt])\n\t\t  break;\n\t      if (mbs_cnt == elem_mbs_len)\n\t\t/* Found the entry.  */\n\t\tfound = true;\n\t    }\n\t  /* Skip the byte sequence of the collating element.  */\n\t  idx += elem_mbs_len;\n\t  /* Adjust for the alignment.  */\n\t  idx = (idx + 3) & ~3;\n\t  /* Skip the collation sequence value.  */\n\t  idx += sizeof (uint32_t);\n\t  /* Skip the wide char sequence of the collating element.  */\n\t  idx = idx + sizeof (uint32_t) * (*(int32_t *) (extra + idx) + 1);\n\t  /* If we found the entry, return the sequence value.  */\n\t  if (found)\n\t    return *(uint32_t *) (extra + idx);\n\t  /* Skip the collation sequence value.  */\n\t  idx += sizeof (uint32_t);\n\t}\n      return UINT_MAX;\n    }\n}",
      "lines": 57,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "unsigned int",
        "unsigned",
        "int"
      ]
    },
    "check_node_accept": {
      "start_point": [
        3997,
        0
      ],
      "end_point": [
        4042,
        1
      ],
      "content": "static bool\ncheck_node_accept (const re_match_context_t *mctx, const re_token_t *node,\n\t\t   Idx idx)\n{\n  unsigned char ch;\n  ch = re_string_byte_at (&mctx->input, idx);\n  switch (node->type)\n    {\n    case CHARACTER:\n      if (node->opr.c != ch)\n        return false;\n      break;\n\n    case SIMPLE_BRACKET:\n      if (!bitset_contain (node->opr.sbcset, ch))\n        return false;\n      break;\n\n#ifdef RE_ENABLE_I18N\n    case OP_UTF8_PERIOD:\n      if (ch >= ASCII_CHARS)\n        return false;\n      FALLTHROUGH;\n#endif\n    case OP_PERIOD:\n      if ((ch == '\\n' && !(mctx->dfa->syntax & RE_DOT_NEWLINE))\n\t  || (ch == '\\0' && (mctx->dfa->syntax & RE_DOT_NOT_NULL)))\n\treturn false;\n      break;\n\n    default:\n      return false;\n    }\n\n  if (node->constraint)\n    {\n      /* The node has constraints.  Check whether the current context\n\t satisfies the constraints.  */\n      unsigned int context = re_string_context_at (&mctx->input, idx,\n\t\t\t\t\t\t   mctx->eflags);\n      if (NOT_SATISFY_NEXT_CONSTRAINT (node->constraint, context))\n\treturn false;\n    }\n\n  return true;\n}",
      "lines": 46,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "extend_buffers": {
      "start_point": [
        4046,
        0
      ],
      "end_point": [
        4105,
        1
      ],
      "content": "static reg_errcode_t\n__attribute_warn_unused_result__\nextend_buffers (re_match_context_t *mctx, int min_len)\n{\n  reg_errcode_t ret;\n  re_string_t *pstr = &mctx->input;\n\n  /* Avoid overflow.  */\n  if (BE (MIN (IDX_MAX, SIZE_MAX / sizeof (re_dfastate_t *)) / 2\n          <= pstr->bufs_len, 0))\n    return REG_ESPACE;\n\n  /* Double the lengths of the buffers, but allocate at least MIN_LEN.  */\n  ret = re_string_realloc_buffers (pstr,\n\t\t\t\t   MAX (min_len,\n\t\t\t\t\tMIN (pstr->len, pstr->bufs_len * 2)));\n  if (BE (ret != REG_NOERROR, 0))\n    return ret;\n\n  if (mctx->state_log != NULL)\n    {\n      /* And double the length of state_log.  */\n      /* XXX We have no indication of the size of this buffer.  If this\n\t allocation fail we have no indication that the state_log array\n\t does not have the right size.  */\n      re_dfastate_t **new_array = re_realloc (mctx->state_log, re_dfastate_t *,\n\t\t\t\t\t      pstr->bufs_len + 1);\n      if (BE (new_array == NULL, 0))\n\treturn REG_ESPACE;\n      mctx->state_log = new_array;\n    }\n\n  /* Then reconstruct the buffers.  */\n  if (pstr->icase)\n    {\n#ifdef RE_ENABLE_I18N\n      if (pstr->mb_cur_max > 1)\n\t{\n\t  ret = build_wcs_upper_buffer (pstr);\n\t  if (BE (ret != REG_NOERROR, 0))\n\t    return ret;\n\t}\n      else\n#endif /* RE_ENABLE_I18N  */\n\tbuild_upper_buffer (pstr);\n    }\n  else\n    {\n#ifdef RE_ENABLE_I18N\n      if (pstr->mb_cur_max > 1)\n\tbuild_wcs_buffer (pstr);\n      else\n#endif /* RE_ENABLE_I18N  */\n\t{\n\t  if (pstr->trans != NULL)\n\t    re_string_translate_buffer (pstr);\n\t}\n    }\n  return REG_NOERROR;\n}",
      "lines": 60,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "__attribute_warn_unused_result__",
        "__attribute_warn_unused_result__"
      ]
    },
    "match_ctx_init": {
      "start_point": [
        4112,
        0
      ],
      "end_point": [
        4141,
        1
      ],
      "content": "static reg_errcode_t\n__attribute_warn_unused_result__\nmatch_ctx_init (re_match_context_t *mctx, int eflags, Idx n)\n{\n  mctx->eflags = eflags;\n  mctx->match_last = -1;\n  if (n > 0)\n    {\n      /* Avoid overflow.  */\n      size_t max_object_size =\n\tMAX (sizeof (struct re_backref_cache_entry),\n\t     sizeof (re_sub_match_top_t *));\n      if (BE (MIN (IDX_MAX, SIZE_MAX / max_object_size) < n, 0))\n\treturn REG_ESPACE;\n\n      mctx->bkref_ents = re_malloc (struct re_backref_cache_entry, n);\n      mctx->sub_tops = re_malloc (re_sub_match_top_t *, n);\n      if (BE (mctx->bkref_ents == NULL || mctx->sub_tops == NULL, 0))\n\treturn REG_ESPACE;\n    }\n  /* Already zero-ed by the caller.\n     else\n       mctx->bkref_ents = NULL;\n     mctx->nbkref_ents = 0;\n     mctx->nsub_tops = 0;  */\n  mctx->abkref_ents = n;\n  mctx->max_mb_elem_len = 1;\n  mctx->asub_tops = n;\n  return REG_NOERROR;\n}",
      "lines": 30,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "__attribute_warn_unused_result__",
        "__attribute_warn_unused_result__"
      ]
    },
    "match_ctx_clean": {
      "start_point": [
        4147,
        0
      ],
      "end_point": [
        4172,
        1
      ],
      "content": "static void\nmatch_ctx_clean (re_match_context_t *mctx)\n{\n  Idx st_idx;\n  for (st_idx = 0; st_idx < mctx->nsub_tops; ++st_idx)\n    {\n      Idx sl_idx;\n      re_sub_match_top_t *top = mctx->sub_tops[st_idx];\n      for (sl_idx = 0; sl_idx < top->nlasts; ++sl_idx)\n\t{\n\t  re_sub_match_last_t *last = top->lasts[sl_idx];\n\t  re_free (last->path.array);\n\t  re_free (last);\n\t}\n      re_free (top->lasts);\n      if (top->path)\n\t{\n\t  re_free (top->path->array);\n\t  re_free (top->path);\n\t}\n      re_free (top);\n    }\n\n  mctx->nsub_tops = 0;\n  mctx->nbkref_ents = 0;\n}",
      "lines": 26,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "match_ctx_free": {
      "start_point": [
        4176,
        0
      ],
      "end_point": [
        4183,
        1
      ],
      "content": "static void\nmatch_ctx_free (re_match_context_t *mctx)\n{\n  /* First, free all the memory associated with MCTX->SUB_TOPS.  */\n  match_ctx_clean (mctx);\n  re_free (mctx->sub_tops);\n  re_free (mctx->bkref_ents);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "match_ctx_add_entry": {
      "start_point": [
        4190,
        0
      ],
      "end_point": [
        4234,
        1
      ],
      "content": "static reg_errcode_t\n__attribute_warn_unused_result__\nmatch_ctx_add_entry (re_match_context_t *mctx, Idx node, Idx str_idx, Idx from,\n\t\t     Idx to)\n{\n  if (mctx->nbkref_ents >= mctx->abkref_ents)\n    {\n      struct re_backref_cache_entry* new_entry;\n      new_entry = re_realloc (mctx->bkref_ents, struct re_backref_cache_entry,\n\t\t\t      mctx->abkref_ents * 2);\n      if (BE (new_entry == NULL, 0))\n\t{\n\t  re_free (mctx->bkref_ents);\n\t  return REG_ESPACE;\n\t}\n      mctx->bkref_ents = new_entry;\n      memset (mctx->bkref_ents + mctx->nbkref_ents, '\\0',\n\t      sizeof (struct re_backref_cache_entry) * mctx->abkref_ents);\n      mctx->abkref_ents *= 2;\n    }\n  if (mctx->nbkref_ents > 0\n      && mctx->bkref_ents[mctx->nbkref_ents - 1].str_idx == str_idx)\n    mctx->bkref_ents[mctx->nbkref_ents - 1].more = 1;\n\n  mctx->bkref_ents[mctx->nbkref_ents].node = node;\n  mctx->bkref_ents[mctx->nbkref_ents].str_idx = str_idx;\n  mctx->bkref_ents[mctx->nbkref_ents].subexp_from = from;\n  mctx->bkref_ents[mctx->nbkref_ents].subexp_to = to;\n\n  /* This is a cache that saves negative results of check_dst_limits_calc_pos.\n     If bit N is clear, means that this entry won't epsilon-transition to\n     an OP_OPEN_SUBEXP or OP_CLOSE_SUBEXP for the N+1-th subexpression.  If\n     it is set, check_dst_limits_calc_pos_1 will recurse and try to find one\n     such node.\n\n     A backreference does not epsilon-transition unless it is empty, so set\n     to all zeros if FROM != TO.  */\n  mctx->bkref_ents[mctx->nbkref_ents].eps_reachable_subexps_map\n    = (from == to ? -1 : 0);\n\n  mctx->bkref_ents[mctx->nbkref_ents++].more = 0;\n  if (mctx->max_mb_elem_len < to - from)\n    mctx->max_mb_elem_len = to - from;\n  return REG_NOERROR;\n}",
      "lines": 45,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "__attribute_warn_unused_result__",
        "__attribute_warn_unused_result__"
      ]
    },
    "search_cur_bkref_entry": {
      "start_point": [
        4239,
        0
      ],
      "end_point": [
        4256,
        1
      ],
      "content": "static Idx\nsearch_cur_bkref_entry (const re_match_context_t *mctx, Idx str_idx)\n{\n  Idx left, right, mid, last;\n  last = right = mctx->nbkref_ents;\n  for (left = 0; left < right;)\n    {\n      mid = (left + right) / 2;\n      if (mctx->bkref_ents[mid].str_idx < str_idx)\n\tleft = mid + 1;\n      else\n\tright = mid;\n    }\n  if (left < last && mctx->bkref_ents[left].str_idx == str_idx)\n    return left;\n  else\n    return -1;\n}",
      "lines": 18,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "Idx"
      ]
    },
    "match_ctx_add_subtop": {
      "start_point": [
        4261,
        0
      ],
      "end_point": [
        4286,
        1
      ],
      "content": "static reg_errcode_t\n__attribute_warn_unused_result__\nmatch_ctx_add_subtop (re_match_context_t *mctx, Idx node, Idx str_idx)\n{\n#ifdef DEBUG\n  assert (mctx->sub_tops != NULL);\n  assert (mctx->asub_tops > 0);\n#endif\n  if (BE (mctx->nsub_tops == mctx->asub_tops, 0))\n    {\n      Idx new_asub_tops = mctx->asub_tops * 2;\n      re_sub_match_top_t **new_array = re_realloc (mctx->sub_tops,\n\t\t\t\t\t\t   re_sub_match_top_t *,\n\t\t\t\t\t\t   new_asub_tops);\n      if (BE (new_array == NULL, 0))\n\treturn REG_ESPACE;\n      mctx->sub_tops = new_array;\n      mctx->asub_tops = new_asub_tops;\n    }\n  mctx->sub_tops[mctx->nsub_tops] = calloc (1, sizeof (re_sub_match_top_t));\n  if (BE (mctx->sub_tops[mctx->nsub_tops] == NULL, 0))\n    return REG_ESPACE;\n  mctx->sub_tops[mctx->nsub_tops]->node = node;\n  mctx->sub_tops[mctx->nsub_tops++]->str_idx = str_idx;\n  return REG_NOERROR;\n}",
      "lines": 26,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "__attribute_warn_unused_result__",
        "__attribute_warn_unused_result__"
      ]
    },
    "match_ctx_add_sublast": {
      "start_point": [
        4291,
        0
      ],
      "end_point": [
        4315,
        1
      ],
      "content": "static re_sub_match_last_t *\nmatch_ctx_add_sublast (re_sub_match_top_t *subtop, Idx node, Idx str_idx)\n{\n  re_sub_match_last_t *new_entry;\n  if (BE (subtop->nlasts == subtop->alasts, 0))\n    {\n      Idx new_alasts = 2 * subtop->alasts + 1;\n      re_sub_match_last_t **new_array = re_realloc (subtop->lasts,\n\t\t\t\t\t\t    re_sub_match_last_t *,\n\t\t\t\t\t\t    new_alasts);\n      if (BE (new_array == NULL, 0))\n\treturn NULL;\n      subtop->lasts = new_array;\n      subtop->alasts = new_alasts;\n    }\n  new_entry = calloc (1, sizeof (re_sub_match_last_t));\n  if (BE (new_entry != NULL, 1))\n    {\n      subtop->lasts[subtop->nlasts] = new_entry;\n      new_entry->node = node;\n      new_entry->str_idx = str_idx;\n      ++subtop->nlasts;\n    }\n  return new_entry;\n}",
      "lines": 25,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "re_sub_match_last_t",
        "*\nmatch_ctx_add_sublast (re_sub_match_top_t *subtop, Idx node, Idx str_idx)",
        "*"
      ]
    },
    "sift_ctx_init": {
      "start_point": [
        4317,
        0
      ],
      "end_point": [
        4326,
        1
      ],
      "content": "static void\nsift_ctx_init (re_sift_context_t *sctx, re_dfastate_t **sifted_sts,\n\t       re_dfastate_t **limited_sts, Idx last_node, Idx last_str_idx)\n{\n  sctx->sifted_states = sifted_sts;\n  sctx->limited_states = limited_sts;\n  sctx->last_node = last_node;\n  sctx->last_str_idx = last_str_idx;\n  re_node_set_init_empty (&sctx->limits);\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "sed/sed-4.5/lib/regex_internal.c": {
    "re_string_allocate": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "static reg_errcode_t\n__attribute_warn_unused_result__\nre_string_allocate (re_string_t *pstr, const char *str, Idx len, Idx init_len,\n\t\t    RE_TRANSLATE_TYPE trans, bool icase, const re_dfa_t *dfa)\n{\n  reg_errcode_t ret;\n  Idx init_buf_len;\n\n  /* Ensure at least one character fits into the buffers.  */\n  if (init_len < dfa->mb_cur_max)\n    init_len = dfa->mb_cur_max;\n  init_buf_len = (len + 1 < init_len) ? len + 1: init_len;\n  re_string_construct_common (str, len, pstr, trans, icase, dfa);\n\n  ret = re_string_realloc_buffers (pstr, init_buf_len);\n  if (BE (ret != REG_NOERROR, 0))\n    return ret;\n\n  pstr->word_char = dfa->word_char;\n  pstr->word_ops_used = dfa->word_ops_used;\n  pstr->mbs = pstr->mbs_allocated ? pstr->mbs : (unsigned char *) str;\n  pstr->valid_len = (pstr->mbs_allocated || dfa->mb_cur_max > 1) ? 0 : len;\n  pstr->valid_raw_len = pstr->valid_len;\n  return REG_NOERROR;\n}",
      "lines": 25,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "__attribute_warn_unused_result__",
        "__attribute_warn_unused_result__"
      ]
    },
    "re_string_construct": {
      "start_point": [
        64,
        0
      ],
      "end_point": [
        123,
        1
      ],
      "content": "static reg_errcode_t\n__attribute_warn_unused_result__\nre_string_construct (re_string_t *pstr, const char *str, Idx len,\n\t\t     RE_TRANSLATE_TYPE trans, bool icase, const re_dfa_t *dfa)\n{\n  reg_errcode_t ret;\n  memset (pstr, '\\0', sizeof (re_string_t));\n  re_string_construct_common (str, len, pstr, trans, icase, dfa);\n\n  if (len > 0)\n    {\n      ret = re_string_realloc_buffers (pstr, len + 1);\n      if (BE (ret != REG_NOERROR, 0))\n\treturn ret;\n    }\n  pstr->mbs = pstr->mbs_allocated ? pstr->mbs : (unsigned char *) str;\n\n  if (icase)\n    {\n#ifdef RE_ENABLE_I18N\n      if (dfa->mb_cur_max > 1)\n\t{\n\t  while (1)\n\t    {\n\t      ret = build_wcs_upper_buffer (pstr);\n\t      if (BE (ret != REG_NOERROR, 0))\n\t\treturn ret;\n\t      if (pstr->valid_raw_len >= len)\n\t\tbreak;\n\t      if (pstr->bufs_len > pstr->valid_len + dfa->mb_cur_max)\n\t\tbreak;\n\t      ret = re_string_realloc_buffers (pstr, pstr->bufs_len * 2);\n\t      if (BE (ret != REG_NOERROR, 0))\n\t\treturn ret;\n\t    }\n\t}\n      else\n#endif /* RE_ENABLE_I18N  */\n\tbuild_upper_buffer (pstr);\n    }\n  else\n    {\n#ifdef RE_ENABLE_I18N\n      if (dfa->mb_cur_max > 1)\n\tbuild_wcs_buffer (pstr);\n      else\n#endif /* RE_ENABLE_I18N  */\n\t{\n\t  if (trans != NULL)\n\t    re_string_translate_buffer (pstr);\n\t  else\n\t    {\n\t      pstr->valid_len = pstr->bufs_len;\n\t      pstr->valid_raw_len = pstr->bufs_len;\n\t    }\n\t}\n    }\n\n  return REG_NOERROR;\n}",
      "lines": 60,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "__attribute_warn_unused_result__",
        "__attribute_warn_unused_result__"
      ]
    },
    "re_string_realloc_buffers": {
      "start_point": [
        127,
        0
      ],
      "end_point": [
        164,
        1
      ],
      "content": "static reg_errcode_t\n__attribute_warn_unused_result__\nre_string_realloc_buffers (re_string_t *pstr, Idx new_buf_len)\n{\n#ifdef RE_ENABLE_I18N\n  if (pstr->mb_cur_max > 1)\n    {\n      wint_t *new_wcs;\n\n      /* Avoid overflow in realloc.  */\n      const size_t max_object_size = MAX (sizeof (wint_t), sizeof (Idx));\n      if (BE (MIN (IDX_MAX, SIZE_MAX / max_object_size) < new_buf_len, 0))\n\treturn REG_ESPACE;\n\n      new_wcs = re_realloc (pstr->wcs, wint_t, new_buf_len);\n      if (BE (new_wcs == NULL, 0))\n\treturn REG_ESPACE;\n      pstr->wcs = new_wcs;\n      if (pstr->offsets != NULL)\n\t{\n\t  Idx *new_offsets = re_realloc (pstr->offsets, Idx, new_buf_len);\n\t  if (BE (new_offsets == NULL, 0))\n\t    return REG_ESPACE;\n\t  pstr->offsets = new_offsets;\n\t}\n    }\n#endif /* RE_ENABLE_I18N  */\n  if (pstr->mbs_allocated)\n    {\n      unsigned char *new_mbs = re_realloc (pstr->mbs, unsigned char,\n\t\t\t\t\t   new_buf_len);\n      if (BE (new_mbs == NULL, 0))\n\treturn REG_ESPACE;\n      pstr->mbs = new_mbs;\n    }\n  pstr->bufs_len = new_buf_len;\n  return REG_NOERROR;\n}",
      "lines": 38,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "__attribute_warn_unused_result__",
        "__attribute_warn_unused_result__"
      ]
    },
    "re_string_construct_common": {
      "start_point": [
        167,
        0
      ],
      "end_point": [
        183,
        1
      ],
      "content": "static void\nre_string_construct_common (const char *str, Idx len, re_string_t *pstr,\n\t\t\t    RE_TRANSLATE_TYPE trans, bool icase,\n\t\t\t    const re_dfa_t *dfa)\n{\n  pstr->raw_mbs = (const unsigned char *) str;\n  pstr->len = len;\n  pstr->raw_len = len;\n  pstr->trans = trans;\n  pstr->icase = icase;\n  pstr->mbs_allocated = (trans != NULL || icase);\n  pstr->mb_cur_max = dfa->mb_cur_max;\n  pstr->is_utf8 = dfa->is_utf8;\n  pstr->map_notascii = dfa->map_notascii;\n  pstr->stop = pstr->len;\n  pstr->raw_stop = pstr->stop;\n}",
      "lines": 17,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "build_wcs_buffer": {
      "start_point": [
        198,
        0
      ],
      "end_point": [
        261,
        1
      ],
      "content": "static void\nbuild_wcs_buffer (re_string_t *pstr)\n{\n#ifdef _LIBC\n  unsigned char buf[MB_LEN_MAX];\n  assert (MB_LEN_MAX >= pstr->mb_cur_max);\n#else\n  unsigned char buf[64];\n#endif\n  mbstate_t prev_st;\n  Idx byte_idx, end_idx, remain_len;\n  size_t mbclen;\n\n  /* Build the buffers from pstr->valid_len to either pstr->len or\n     pstr->bufs_len.  */\n  end_idx = (pstr->bufs_len > pstr->len) ? pstr->len : pstr->bufs_len;\n  for (byte_idx = pstr->valid_len; byte_idx < end_idx;)\n    {\n      wchar_t wc;\n      const char *p;\n\n      remain_len = end_idx - byte_idx;\n      prev_st = pstr->cur_state;\n      /* Apply the translation if we need.  */\n      if (BE (pstr->trans != NULL, 0))\n\t{\n\t  int i, ch;\n\n\t  for (i = 0; i < pstr->mb_cur_max && i < remain_len; ++i)\n\t    {\n\t      ch = pstr->raw_mbs [pstr->raw_mbs_idx + byte_idx + i];\n\t      buf[i] = pstr->mbs[byte_idx + i] = pstr->trans[ch];\n\t    }\n\t  p = (const char *) buf;\n\t}\n      else\n\tp = (const char *) pstr->raw_mbs + pstr->raw_mbs_idx + byte_idx;\n      mbclen = __mbrtowc (&wc, p, remain_len, &pstr->cur_state);\n      if (BE (mbclen == (size_t) -1 || mbclen == 0\n\t      || (mbclen == (size_t) -2 && pstr->bufs_len >= pstr->len), 0))\n\t{\n\t  /* We treat these cases as a singlebyte character.  */\n\t  mbclen = 1;\n\t  wc = (wchar_t) pstr->raw_mbs[pstr->raw_mbs_idx + byte_idx];\n\t  if (BE (pstr->trans != NULL, 0))\n\t    wc = pstr->trans[wc];\n\t  pstr->cur_state = prev_st;\n\t}\n      else if (BE (mbclen == (size_t) -2, 0))\n\t{\n\t  /* The buffer doesn't have enough space, finish to build.  */\n\t  pstr->cur_state = prev_st;\n\t  break;\n\t}\n\n      /* Write wide character and padding.  */\n      pstr->wcs[byte_idx++] = wc;\n      /* Write paddings.  */\n      for (remain_len = byte_idx + mbclen - 1; byte_idx < remain_len ;)\n\tpstr->wcs[byte_idx++] = WEOF;\n    }\n  pstr->valid_len = byte_idx;\n  pstr->valid_raw_len = byte_idx;\n}",
      "lines": 64,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "build_wcs_upper_buffer": {
      "start_point": [
        266,
        0
      ],
      "end_point": [
        478,
        1
      ],
      "content": "static reg_errcode_t\n__attribute_warn_unused_result__\nbuild_wcs_upper_buffer (re_string_t *pstr)\n{\n  mbstate_t prev_st;\n  Idx src_idx, byte_idx, end_idx, remain_len;\n  size_t mbclen;\n#ifdef _LIBC\n  char buf[MB_LEN_MAX];\n  assert (MB_LEN_MAX >= pstr->mb_cur_max);\n#else\n  char buf[64];\n#endif\n\n  byte_idx = pstr->valid_len;\n  end_idx = (pstr->bufs_len > pstr->len) ? pstr->len : pstr->bufs_len;\n\n  /* The following optimization assumes that ASCII characters can be\n     mapped to wide characters with a simple cast.  */\n  if (! pstr->map_notascii && pstr->trans == NULL && !pstr->offsets_needed)\n    {\n      while (byte_idx < end_idx)\n\t{\n\t  wchar_t wc;\n\n\t  if (isascii (pstr->raw_mbs[pstr->raw_mbs_idx + byte_idx])\n\t      && mbsinit (&pstr->cur_state))\n\t    {\n\t      /* In case of a singlebyte character.  */\n\t      pstr->mbs[byte_idx]\n\t\t= toupper (pstr->raw_mbs[pstr->raw_mbs_idx + byte_idx]);\n\t      /* The next step uses the assumption that wchar_t is encoded\n\t\t ASCII-safe: all ASCII values can be converted like this.  */\n\t      pstr->wcs[byte_idx] = (wchar_t) pstr->mbs[byte_idx];\n\t      ++byte_idx;\n\t      continue;\n\t    }\n\n\t  remain_len = end_idx - byte_idx;\n\t  prev_st = pstr->cur_state;\n\t  mbclen = __mbrtowc (&wc,\n\t\t\t      ((const char *) pstr->raw_mbs + pstr->raw_mbs_idx\n\t\t\t       + byte_idx), remain_len, &pstr->cur_state);\n\t  if (BE (mbclen < (size_t) -2, 1))\n\t    {\n\t      wchar_t wcu = __towupper (wc);\n\t      if (wcu != wc)\n\t\t{\n\t\t  size_t mbcdlen;\n\n\t\t  mbcdlen = __wcrtomb (buf, wcu, &prev_st);\n\t\t  if (BE (mbclen == mbcdlen, 1))\n\t\t    memcpy (pstr->mbs + byte_idx, buf, mbclen);\n\t\t  else\n\t\t    {\n\t\t      src_idx = byte_idx;\n\t\t      goto offsets_needed;\n\t\t    }\n\t\t}\n\t      else\n\t\tmemcpy (pstr->mbs + byte_idx,\n\t\t\tpstr->raw_mbs + pstr->raw_mbs_idx + byte_idx, mbclen);\n\t      pstr->wcs[byte_idx++] = wcu;\n\t      /* Write paddings.  */\n\t      for (remain_len = byte_idx + mbclen - 1; byte_idx < remain_len ;)\n\t\tpstr->wcs[byte_idx++] = WEOF;\n\t    }\n\t  else if (mbclen == (size_t) -1 || mbclen == 0\n\t\t   || (mbclen == (size_t) -2 && pstr->bufs_len >= pstr->len))\n\t    {\n\t      /* It is an invalid character, an incomplete character\n\t\t at the end of the string, or '\\0'.  Just use the byte.  */\n\t      int ch = pstr->raw_mbs[pstr->raw_mbs_idx + byte_idx];\n\t      pstr->mbs[byte_idx] = ch;\n\t      /* And also cast it to wide char.  */\n\t      pstr->wcs[byte_idx++] = (wchar_t) ch;\n\t      if (BE (mbclen == (size_t) -1, 0))\n\t\tpstr->cur_state = prev_st;\n\t    }\n\t  else\n\t    {\n\t      /* The buffer doesn't have enough space, finish to build.  */\n\t      pstr->cur_state = prev_st;\n\t      break;\n\t    }\n\t}\n      pstr->valid_len = byte_idx;\n      pstr->valid_raw_len = byte_idx;\n      return REG_NOERROR;\n    }\n  else\n    for (src_idx = pstr->valid_raw_len; byte_idx < end_idx;)\n      {\n\twchar_t wc;\n\tconst char *p;\n      offsets_needed:\n\tremain_len = end_idx - byte_idx;\n\tprev_st = pstr->cur_state;\n\tif (BE (pstr->trans != NULL, 0))\n\t  {\n\t    int i, ch;\n\n\t    for (i = 0; i < pstr->mb_cur_max && i < remain_len; ++i)\n\t      {\n\t\tch = pstr->raw_mbs [pstr->raw_mbs_idx + src_idx + i];\n\t\tbuf[i] = pstr->trans[ch];\n\t      }\n\t    p = (const char *) buf;\n\t  }\n\telse\n\t  p = (const char *) pstr->raw_mbs + pstr->raw_mbs_idx + src_idx;\n\tmbclen = __mbrtowc (&wc, p, remain_len, &pstr->cur_state);\n\tif (BE (mbclen < (size_t) -2, 1))\n\t  {\n\t    wchar_t wcu = __towupper (wc);\n\t    if (wcu != wc)\n\t      {\n\t\tsize_t mbcdlen;\n\n\t\tmbcdlen = wcrtomb ((char *) buf, wcu, &prev_st);\n\t\tif (BE (mbclen == mbcdlen, 1))\n\t\t  memcpy (pstr->mbs + byte_idx, buf, mbclen);\n\t\telse if (mbcdlen != (size_t) -1)\n\t\t  {\n\t\t    size_t i;\n\n\t\t    if (byte_idx + mbcdlen > pstr->bufs_len)\n\t\t      {\n\t\t\tpstr->cur_state = prev_st;\n\t\t\tbreak;\n\t\t      }\n\n\t\t    if (pstr->offsets == NULL)\n\t\t      {\n\t\t\tpstr->offsets = re_malloc (Idx, pstr->bufs_len);\n\n\t\t\tif (pstr->offsets == NULL)\n\t\t\t  return REG_ESPACE;\n\t\t      }\n\t\t    if (!pstr->offsets_needed)\n\t\t      {\n\t\t\tfor (i = 0; i < (size_t) byte_idx; ++i)\n\t\t\t  pstr->offsets[i] = i;\n\t\t\tpstr->offsets_needed = 1;\n\t\t      }\n\n\t\t    memcpy (pstr->mbs + byte_idx, buf, mbcdlen);\n\t\t    pstr->wcs[byte_idx] = wcu;\n\t\t    pstr->offsets[byte_idx] = src_idx;\n\t\t    for (i = 1; i < mbcdlen; ++i)\n\t\t      {\n\t\t\tpstr->offsets[byte_idx + i]\n\t\t\t  = src_idx + (i < mbclen ? i : mbclen - 1);\n\t\t\tpstr->wcs[byte_idx + i] = WEOF;\n\t\t      }\n\t\t    pstr->len += mbcdlen - mbclen;\n\t\t    if (pstr->raw_stop > src_idx)\n\t\t      pstr->stop += mbcdlen - mbclen;\n\t\t    end_idx = (pstr->bufs_len > pstr->len)\n\t\t\t      ? pstr->len : pstr->bufs_len;\n\t\t    byte_idx += mbcdlen;\n\t\t    src_idx += mbclen;\n\t\t    continue;\n\t\t  }\n\t\telse\n\t\t  memcpy (pstr->mbs + byte_idx, p, mbclen);\n\t      }\n\t    else\n\t      memcpy (pstr->mbs + byte_idx, p, mbclen);\n\n\t    if (BE (pstr->offsets_needed != 0, 0))\n\t      {\n\t\tsize_t i;\n\t\tfor (i = 0; i < mbclen; ++i)\n\t\t  pstr->offsets[byte_idx + i] = src_idx + i;\n\t      }\n\t    src_idx += mbclen;\n\n\t    pstr->wcs[byte_idx++] = wcu;\n\t    /* Write paddings.  */\n\t    for (remain_len = byte_idx + mbclen - 1; byte_idx < remain_len ;)\n\t      pstr->wcs[byte_idx++] = WEOF;\n\t  }\n\telse if (mbclen == (size_t) -1 || mbclen == 0\n\t\t || (mbclen == (size_t) -2 && pstr->bufs_len >= pstr->len))\n\t  {\n\t    /* It is an invalid character or '\\0'.  Just use the byte.  */\n\t    int ch = pstr->raw_mbs[pstr->raw_mbs_idx + src_idx];\n\n\t    if (BE (pstr->trans != NULL, 0))\n\t      ch = pstr->trans [ch];\n\t    pstr->mbs[byte_idx] = ch;\n\n\t    if (BE (pstr->offsets_needed != 0, 0))\n\t      pstr->offsets[byte_idx] = src_idx;\n\t    ++src_idx;\n\n\t    /* And also cast it to wide char.  */\n\t    pstr->wcs[byte_idx++] = (wchar_t) ch;\n\t    if (BE (mbclen == (size_t) -1, 0))\n\t      pstr->cur_state = prev_st;\n\t  }\n\telse\n\t  {\n\t    /* The buffer doesn't have enough space, finish to build.  */\n\t    pstr->cur_state = prev_st;\n\t    break;\n\t  }\n      }\n  pstr->valid_len = byte_idx;\n  pstr->valid_raw_len = src_idx;\n  return REG_NOERROR;\n}",
      "lines": 213,
      "depth": 21,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "__attribute_warn_unused_result__",
        "__attribute_warn_unused_result__"
      ]
    },
    "re_string_skip_chars": {
      "start_point": [
        483,
        0
      ],
      "end_point": [
        517,
        1
      ],
      "content": "static Idx\nre_string_skip_chars (re_string_t *pstr, Idx new_raw_idx, wint_t *last_wc)\n{\n  mbstate_t prev_st;\n  Idx rawbuf_idx;\n  size_t mbclen;\n  wint_t wc = WEOF;\n\n  /* Skip the characters which are not necessary to check.  */\n  for (rawbuf_idx = pstr->raw_mbs_idx + pstr->valid_raw_len;\n       rawbuf_idx < new_raw_idx;)\n    {\n      wchar_t wc2;\n      Idx remain_len = pstr->raw_len - rawbuf_idx;\n      prev_st = pstr->cur_state;\n      mbclen = __mbrtowc (&wc2, (const char *) pstr->raw_mbs + rawbuf_idx,\n\t\t\t  remain_len, &pstr->cur_state);\n      if (BE (mbclen == (size_t) -2 || mbclen == (size_t) -1 || mbclen == 0, 0))\n\t{\n\t  /* We treat these cases as a single byte character.  */\n\t  if (mbclen == 0 || remain_len == 0)\n\t    wc = L'\\0';\n\t  else\n\t    wc = *(unsigned char *) (pstr->raw_mbs + rawbuf_idx);\n\t  mbclen = 1;\n\t  pstr->cur_state = prev_st;\n\t}\n      else\n\twc = wc2;\n      /* Then proceed the next character.  */\n      rawbuf_idx += mbclen;\n    }\n  *last_wc = wc;\n  return rawbuf_idx;\n}",
      "lines": 35,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "Idx"
      ]
    },
    "build_upper_buffer": {
      "start_point": [
        523,
        0
      ],
      "end_point": [
        538,
        1
      ],
      "content": "static void\nbuild_upper_buffer (re_string_t *pstr)\n{\n  Idx char_idx, end_idx;\n  end_idx = (pstr->bufs_len > pstr->len) ? pstr->len : pstr->bufs_len;\n\n  for (char_idx = pstr->valid_len; char_idx < end_idx; ++char_idx)\n    {\n      int ch = pstr->raw_mbs[pstr->raw_mbs_idx + char_idx];\n      if (BE (pstr->trans != NULL, 0))\n\tch = pstr->trans[ch];\n      pstr->mbs[char_idx] = toupper (ch);\n    }\n  pstr->valid_len = char_idx;\n  pstr->valid_raw_len = char_idx;\n}",
      "lines": 16,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "re_string_translate_buffer": {
      "start_point": [
        542,
        0
      ],
      "end_point": [
        556,
        1
      ],
      "content": "static void\nre_string_translate_buffer (re_string_t *pstr)\n{\n  Idx buf_idx, end_idx;\n  end_idx = (pstr->bufs_len > pstr->len) ? pstr->len : pstr->bufs_len;\n\n  for (buf_idx = pstr->valid_len; buf_idx < end_idx; ++buf_idx)\n    {\n      int ch = pstr->raw_mbs[pstr->raw_mbs_idx + buf_idx];\n      pstr->mbs[buf_idx] = pstr->trans[ch];\n    }\n\n  pstr->valid_len = buf_idx;\n  pstr->valid_raw_len = buf_idx;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "re_string_reconstruct": {
      "start_point": [
        562,
        0
      ],
      "end_point": [
        823,
        1
      ],
      "content": "static reg_errcode_t\n__attribute_warn_unused_result__\nre_string_reconstruct (re_string_t *pstr, Idx idx, int eflags)\n{\n  Idx offset;\n\n  if (BE (pstr->raw_mbs_idx <= idx, 0))\n    offset = idx - pstr->raw_mbs_idx;\n  else\n    {\n      /* Reset buffer.  */\n#ifdef RE_ENABLE_I18N\n      if (pstr->mb_cur_max > 1)\n\tmemset (&pstr->cur_state, '\\0', sizeof (mbstate_t));\n#endif /* RE_ENABLE_I18N */\n      pstr->len = pstr->raw_len;\n      pstr->stop = pstr->raw_stop;\n      pstr->valid_len = 0;\n      pstr->raw_mbs_idx = 0;\n      pstr->valid_raw_len = 0;\n      pstr->offsets_needed = 0;\n      pstr->tip_context = ((eflags & REG_NOTBOL) ? CONTEXT_BEGBUF\n\t\t\t   : CONTEXT_NEWLINE | CONTEXT_BEGBUF);\n      if (!pstr->mbs_allocated)\n\tpstr->mbs = (unsigned char *) pstr->raw_mbs;\n      offset = idx;\n    }\n\n  if (BE (offset != 0, 1))\n    {\n      /* Should the already checked characters be kept?  */\n      if (BE (offset < pstr->valid_raw_len, 1))\n\t{\n\t  /* Yes, move them to the front of the buffer.  */\n#ifdef RE_ENABLE_I18N\n\t  if (BE (pstr->offsets_needed, 0))\n\t    {\n\t      Idx low = 0, high = pstr->valid_len, mid;\n\t      do\n\t\t{\n\t\t  mid = (high + low) / 2;\n\t\t  if (pstr->offsets[mid] > offset)\n\t\t    high = mid;\n\t\t  else if (pstr->offsets[mid] < offset)\n\t\t    low = mid + 1;\n\t\t  else\n\t\t    break;\n\t\t}\n\t      while (low < high);\n\t      if (pstr->offsets[mid] < offset)\n\t\t++mid;\n\t      pstr->tip_context = re_string_context_at (pstr, mid - 1,\n\t\t\t\t\t\t\teflags);\n\t      /* This can be quite complicated, so handle specially\n\t\t only the common and easy case where the character with\n\t\t different length representation of lower and upper\n\t\t case is present at or after offset.  */\n\t      if (pstr->valid_len > offset\n\t\t  && mid == offset && pstr->offsets[mid] == offset)\n\t\t{\n\t\t  memmove (pstr->wcs, pstr->wcs + offset,\n\t\t\t   (pstr->valid_len - offset) * sizeof (wint_t));\n\t\t  memmove (pstr->mbs, pstr->mbs + offset, pstr->valid_len - offset);\n\t\t  pstr->valid_len -= offset;\n\t\t  pstr->valid_raw_len -= offset;\n\t\t  for (low = 0; low < pstr->valid_len; low++)\n\t\t    pstr->offsets[low] = pstr->offsets[low + offset] - offset;\n\t\t}\n\t      else\n\t\t{\n\t\t  /* Otherwise, just find out how long the partial multibyte\n\t\t     character at offset is and fill it with WEOF/255.  */\n\t\t  pstr->len = pstr->raw_len - idx + offset;\n\t\t  pstr->stop = pstr->raw_stop - idx + offset;\n\t\t  pstr->offsets_needed = 0;\n\t\t  while (mid > 0 && pstr->offsets[mid - 1] == offset)\n\t\t    --mid;\n\t\t  while (mid < pstr->valid_len)\n\t\t    if (pstr->wcs[mid] != WEOF)\n\t\t      break;\n\t\t    else\n\t\t      ++mid;\n\t\t  if (mid == pstr->valid_len)\n\t\t    pstr->valid_len = 0;\n\t\t  else\n\t\t    {\n\t\t      pstr->valid_len = pstr->offsets[mid] - offset;\n\t\t      if (pstr->valid_len)\n\t\t\t{\n\t\t\t  for (low = 0; low < pstr->valid_len; ++low)\n\t\t\t    pstr->wcs[low] = WEOF;\n\t\t\t  memset (pstr->mbs, 255, pstr->valid_len);\n\t\t\t}\n\t\t    }\n\t\t  pstr->valid_raw_len = pstr->valid_len;\n\t\t}\n\t    }\n\t  else\n#endif\n\t    {\n\t      pstr->tip_context = re_string_context_at (pstr, offset - 1,\n\t\t\t\t\t\t\teflags);\n#ifdef RE_ENABLE_I18N\n\t      if (pstr->mb_cur_max > 1)\n\t\tmemmove (pstr->wcs, pstr->wcs + offset,\n\t\t\t (pstr->valid_len - offset) * sizeof (wint_t));\n#endif /* RE_ENABLE_I18N */\n\t      if (BE (pstr->mbs_allocated, 0))\n\t\tmemmove (pstr->mbs, pstr->mbs + offset,\n\t\t\t pstr->valid_len - offset);\n\t      pstr->valid_len -= offset;\n\t      pstr->valid_raw_len -= offset;\n#if defined DEBUG && DEBUG\n\t      assert (pstr->valid_len > 0);\n#endif\n\t    }\n\t}\n      else\n\t{\n#ifdef RE_ENABLE_I18N\n\t  /* No, skip all characters until IDX.  */\n\t  Idx prev_valid_len = pstr->valid_len;\n\n\t  if (BE (pstr->offsets_needed, 0))\n\t    {\n\t      pstr->len = pstr->raw_len - idx + offset;\n\t      pstr->stop = pstr->raw_stop - idx + offset;\n\t      pstr->offsets_needed = 0;\n\t    }\n#endif\n\t  pstr->valid_len = 0;\n#ifdef RE_ENABLE_I18N\n\t  if (pstr->mb_cur_max > 1)\n\t    {\n\t      Idx wcs_idx;\n\t      wint_t wc = WEOF;\n\n\t      if (pstr->is_utf8)\n\t\t{\n\t\t  const unsigned char *raw, *p, *end;\n\n\t\t  /* Special case UTF-8.  Multi-byte chars start with any\n\t\t     byte other than 0x80 - 0xbf.  */\n\t\t  raw = pstr->raw_mbs + pstr->raw_mbs_idx;\n\t\t  end = raw + (offset - pstr->mb_cur_max);\n\t\t  if (end < pstr->raw_mbs)\n\t\t    end = pstr->raw_mbs;\n\t\t  p = raw + offset - 1;\n#ifdef _LIBC\n\t\t  /* We know the wchar_t encoding is UCS4, so for the simple\n\t\t     case, ASCII characters, skip the conversion step.  */\n\t\t  if (isascii (*p) && BE (pstr->trans == NULL, 1))\n\t\t    {\n\t\t      memset (&pstr->cur_state, '\\0', sizeof (mbstate_t));\n\t\t      /* pstr->valid_len = 0; */\n\t\t      wc = (wchar_t) *p;\n\t\t    }\n\t\t  else\n#endif\n\t\t    for (; p >= end; --p)\n\t\t      if ((*p & 0xc0) != 0x80)\n\t\t\t{\n\t\t\t  mbstate_t cur_state;\n\t\t\t  wchar_t wc2;\n\t\t\t  Idx mlen = raw + pstr->len - p;\n\t\t\t  unsigned char buf[6];\n\t\t\t  size_t mbclen;\n\n\t\t\t  const unsigned char *pp = p;\n\t\t\t  if (BE (pstr->trans != NULL, 0))\n\t\t\t    {\n\t\t\t      int i = mlen < 6 ? mlen : 6;\n\t\t\t      while (--i >= 0)\n\t\t\t\tbuf[i] = pstr->trans[p[i]];\n\t\t\t      pp = buf;\n\t\t\t    }\n\t\t\t  /* XXX Don't use mbrtowc, we know which conversion\n\t\t\t     to use (UTF-8 -> UCS4).  */\n\t\t\t  memset (&cur_state, 0, sizeof (cur_state));\n\t\t\t  mbclen = __mbrtowc (&wc2, (const char *) pp, mlen,\n\t\t\t\t\t      &cur_state);\n\t\t\t  if (raw + offset - p <= mbclen\n\t\t\t      && mbclen < (size_t) -2)\n\t\t\t    {\n\t\t\t      memset (&pstr->cur_state, '\\0',\n\t\t\t\t      sizeof (mbstate_t));\n\t\t\t      pstr->valid_len = mbclen - (raw + offset - p);\n\t\t\t      wc = wc2;\n\t\t\t    }\n\t\t\t  break;\n\t\t\t}\n\t\t}\n\n\t      if (wc == WEOF)\n\t\tpstr->valid_len = re_string_skip_chars (pstr, idx, &wc) - idx;\n\t      if (wc == WEOF)\n\t\tpstr->tip_context\n\t\t  = re_string_context_at (pstr, prev_valid_len - 1, eflags);\n\t      else\n\t\tpstr->tip_context = ((BE (pstr->word_ops_used != 0, 0)\n\t\t\t\t      && IS_WIDE_WORD_CHAR (wc))\n\t\t\t\t     ? CONTEXT_WORD\n\t\t\t\t     : ((IS_WIDE_NEWLINE (wc)\n\t\t\t\t\t && pstr->newline_anchor)\n\t\t\t\t\t? CONTEXT_NEWLINE : 0));\n\t      if (BE (pstr->valid_len, 0))\n\t\t{\n\t\t  for (wcs_idx = 0; wcs_idx < pstr->valid_len; ++wcs_idx)\n\t\t    pstr->wcs[wcs_idx] = WEOF;\n\t\t  if (pstr->mbs_allocated)\n\t\t    memset (pstr->mbs, 255, pstr->valid_len);\n\t\t}\n\t      pstr->valid_raw_len = pstr->valid_len;\n\t    }\n\t  else\n#endif /* RE_ENABLE_I18N */\n\t    {\n\t      int c = pstr->raw_mbs[pstr->raw_mbs_idx + offset - 1];\n\t      pstr->valid_raw_len = 0;\n\t      if (pstr->trans)\n\t\tc = pstr->trans[c];\n\t      pstr->tip_context = (bitset_contain (pstr->word_char, c)\n\t\t\t\t   ? CONTEXT_WORD\n\t\t\t\t   : ((IS_NEWLINE (c) && pstr->newline_anchor)\n\t\t\t\t      ? CONTEXT_NEWLINE : 0));\n\t    }\n\t}\n      if (!BE (pstr->mbs_allocated, 0))\n\tpstr->mbs += offset;\n    }\n  pstr->raw_mbs_idx = idx;\n  pstr->len -= offset;\n  pstr->stop -= offset;\n\n  /* Then build the buffers.  */\n#ifdef RE_ENABLE_I18N\n  if (pstr->mb_cur_max > 1)\n    {\n      if (pstr->icase)\n\t{\n\t  reg_errcode_t ret = build_wcs_upper_buffer (pstr);\n\t  if (BE (ret != REG_NOERROR, 0))\n\t    return ret;\n\t}\n      else\n\tbuild_wcs_buffer (pstr);\n    }\n  else\n#endif /* RE_ENABLE_I18N */\n    if (BE (pstr->mbs_allocated, 0))\n      {\n\tif (pstr->icase)\n\t  build_upper_buffer (pstr);\n\telse if (pstr->trans != NULL)\n\t  re_string_translate_buffer (pstr);\n      }\n    else\n      pstr->valid_len = pstr->len;\n\n  pstr->cur_idx = 0;\n  return REG_NOERROR;\n}",
      "lines": 262,
      "depth": 23,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "__attribute_warn_unused_result__",
        "__attribute_warn_unused_result__"
      ]
    },
    "re_string_peek_byte_case": {
      "start_point": [
        825,
        0
      ],
      "end_point": [
        860,
        1
      ],
      "content": "static unsigned char\n__attribute__ ((pure))\nre_string_peek_byte_case (const re_string_t *pstr, Idx idx)\n{\n  int ch;\n  Idx off;\n\n  /* Handle the common (easiest) cases first.  */\n  if (BE (!pstr->mbs_allocated, 1))\n    return re_string_peek_byte (pstr, idx);\n\n#ifdef RE_ENABLE_I18N\n  if (pstr->mb_cur_max > 1\n      && ! re_string_is_single_byte_char (pstr, pstr->cur_idx + idx))\n    return re_string_peek_byte (pstr, idx);\n#endif\n\n  off = pstr->cur_idx + idx;\n#ifdef RE_ENABLE_I18N\n  if (pstr->offsets_needed)\n    off = pstr->offsets[off];\n#endif\n\n  ch = pstr->raw_mbs[pstr->raw_mbs_idx + off];\n\n#ifdef RE_ENABLE_I18N\n  /* Ensure that e.g. for tr_TR.UTF-8 BACKSLASH DOTLESS SMALL LETTER I\n     this function returns CAPITAL LETTER I instead of first byte of\n     DOTLESS SMALL LETTER I.  The latter would confuse the parser,\n     since peek_byte_case doesn't advance cur_idx in any way.  */\n  if (pstr->offsets_needed && !isascii (ch))\n    return re_string_peek_byte (pstr, idx);\n#endif\n\n  return ch;\n}",
      "lines": 36,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "unsigned char",
        "unsigned",
        "char",
        "__attribute__ ((pure))",
        "__attribute__",
        "(",
        "(pure)",
        "(",
        "pure",
        ")",
        ")"
      ]
    },
    "re_string_fetch_byte_case": {
      "start_point": [
        862,
        0
      ],
      "end_point": [
        897,
        1
      ],
      "content": "static unsigned char\nre_string_fetch_byte_case (re_string_t *pstr)\n{\n  if (BE (!pstr->mbs_allocated, 1))\n    return re_string_fetch_byte (pstr);\n\n#ifdef RE_ENABLE_I18N\n  if (pstr->offsets_needed)\n    {\n      Idx off;\n      int ch;\n\n      /* For tr_TR.UTF-8 [[:islower:]] there is\n\t [[: CAPITAL LETTER I WITH DOT lower:]] in mbs.  Skip\n\t in that case the whole multi-byte character and return\n\t the original letter.  On the other side, with\n\t [[: DOTLESS SMALL LETTER I return [[:I, as doing\n\t anything else would complicate things too much.  */\n\n      if (!re_string_first_byte (pstr, pstr->cur_idx))\n\treturn re_string_fetch_byte (pstr);\n\n      off = pstr->offsets[pstr->cur_idx];\n      ch = pstr->raw_mbs[pstr->raw_mbs_idx + off];\n\n      if (! isascii (ch))\n\treturn re_string_fetch_byte (pstr);\n\n      re_string_skip_bytes (pstr,\n\t\t\t    re_string_char_size_at (pstr, pstr->cur_idx));\n      return ch;\n    }\n#endif\n\n  return pstr->raw_mbs[pstr->raw_mbs_idx + pstr->cur_idx++];\n}",
      "lines": 36,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "unsigned char",
        "unsigned",
        "char"
      ]
    },
    "re_string_destruct": {
      "start_point": [
        899,
        0
      ],
      "end_point": [
        908,
        1
      ],
      "content": "static void\nre_string_destruct (re_string_t *pstr)\n{\n#ifdef RE_ENABLE_I18N\n  re_free (pstr->wcs);\n  re_free (pstr->offsets);\n#endif /* RE_ENABLE_I18N  */\n  if (pstr->mbs_allocated)\n    re_free (pstr->mbs);\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "re_string_context_at": {
      "start_point": [
        912,
        0
      ],
      "end_point": [
        952,
        1
      ],
      "content": "static unsigned int\nre_string_context_at (const re_string_t *input, Idx idx, int eflags)\n{\n  int c;\n  if (BE (idx < 0, 0))\n    /* In this case, we use the value stored in input->tip_context,\n       since we can't know the character in input->mbs[-1] here.  */\n    return input->tip_context;\n  if (BE (idx == input->len, 0))\n    return ((eflags & REG_NOTEOL) ? CONTEXT_ENDBUF\n\t    : CONTEXT_NEWLINE | CONTEXT_ENDBUF);\n#ifdef RE_ENABLE_I18N\n  if (input->mb_cur_max > 1)\n    {\n      wint_t wc;\n      Idx wc_idx = idx;\n      while(input->wcs[wc_idx] == WEOF)\n\t{\n#if defined DEBUG && DEBUG\n\t  /* It must not happen.  */\n\t  assert (wc_idx >= 0);\n#endif\n\t  --wc_idx;\n\t  if (wc_idx < 0)\n\t    return input->tip_context;\n\t}\n      wc = input->wcs[wc_idx];\n      if (BE (input->word_ops_used != 0, 0) && IS_WIDE_WORD_CHAR (wc))\n\treturn CONTEXT_WORD;\n      return (IS_WIDE_NEWLINE (wc) && input->newline_anchor\n\t      ? CONTEXT_NEWLINE : 0);\n    }\n  else\n#endif\n    {\n      c = re_string_byte_at (input, idx);\n      if (bitset_contain (input->word_char, c))\n\treturn CONTEXT_WORD;\n      return IS_NEWLINE (c) && input->newline_anchor ? CONTEXT_NEWLINE : 0;\n    }\n}",
      "lines": 41,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "unsigned int",
        "unsigned",
        "int"
      ]
    },
    "re_node_set_alloc": {
      "start_point": [
        956,
        0
      ],
      "end_point": [
        966,
        1
      ],
      "content": "static reg_errcode_t\n__attribute_warn_unused_result__\nre_node_set_alloc (re_node_set *set, Idx size)\n{\n  set->alloc = size;\n  set->nelem = 0;\n  set->elems = re_malloc (Idx, size);\n  if (BE (set->elems == NULL, 0) && (MALLOC_0_IS_NONNULL || size != 0))\n    return REG_ESPACE;\n  return REG_NOERROR;\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "__attribute_warn_unused_result__",
        "__attribute_warn_unused_result__"
      ]
    },
    "re_node_set_init_1": {
      "start_point": [
        968,
        0
      ],
      "end_point": [
        982,
        1
      ],
      "content": "static reg_errcode_t\n__attribute_warn_unused_result__\nre_node_set_init_1 (re_node_set *set, Idx elem)\n{\n  set->alloc = 1;\n  set->nelem = 1;\n  set->elems = re_malloc (Idx, 1);\n  if (BE (set->elems == NULL, 0))\n    {\n      set->alloc = set->nelem = 0;\n      return REG_ESPACE;\n    }\n  set->elems[0] = elem;\n  return REG_NOERROR;\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "__attribute_warn_unused_result__",
        "__attribute_warn_unused_result__"
      ]
    },
    "re_node_set_init_2": {
      "start_point": [
        984,
        0
      ],
      "end_point": [
        1012,
        1
      ],
      "content": "static reg_errcode_t\n__attribute_warn_unused_result__\nre_node_set_init_2 (re_node_set *set, Idx elem1, Idx elem2)\n{\n  set->alloc = 2;\n  set->elems = re_malloc (Idx, 2);\n  if (BE (set->elems == NULL, 0))\n    return REG_ESPACE;\n  if (elem1 == elem2)\n    {\n      set->nelem = 1;\n      set->elems[0] = elem1;\n    }\n  else\n    {\n      set->nelem = 2;\n      if (elem1 < elem2)\n\t{\n\t  set->elems[0] = elem1;\n\t  set->elems[1] = elem2;\n\t}\n      else\n\t{\n\t  set->elems[0] = elem2;\n\t  set->elems[1] = elem1;\n\t}\n    }\n  return REG_NOERROR;\n}",
      "lines": 29,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "__attribute_warn_unused_result__",
        "__attribute_warn_unused_result__"
      ]
    },
    "re_node_set_init_copy": {
      "start_point": [
        1014,
        0
      ],
      "end_point": [
        1033,
        1
      ],
      "content": "static reg_errcode_t\n__attribute_warn_unused_result__\nre_node_set_init_copy (re_node_set *dest, const re_node_set *src)\n{\n  dest->nelem = src->nelem;\n  if (src->nelem > 0)\n    {\n      dest->alloc = dest->nelem;\n      dest->elems = re_malloc (Idx, dest->alloc);\n      if (BE (dest->elems == NULL, 0))\n\t{\n\t  dest->alloc = dest->nelem = 0;\n\t  return REG_ESPACE;\n\t}\n      memcpy (dest->elems, src->elems, src->nelem * sizeof (Idx));\n    }\n  else\n    re_node_set_init_empty (dest);\n  return REG_NOERROR;\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "__attribute_warn_unused_result__",
        "__attribute_warn_unused_result__"
      ]
    },
    "re_node_set_add_intersect": {
      "start_point": [
        1039,
        0
      ],
      "end_point": [
        1125,
        1
      ],
      "content": "static reg_errcode_t\n__attribute_warn_unused_result__\nre_node_set_add_intersect (re_node_set *dest, const re_node_set *src1,\n\t\t\t   const re_node_set *src2)\n{\n  Idx i1, i2, is, id, delta, sbase;\n  if (src1->nelem == 0 || src2->nelem == 0)\n    return REG_NOERROR;\n\n  /* We need dest->nelem + 2 * elems_in_intersection; this is a\n     conservative estimate.  */\n  if (src1->nelem + src2->nelem + dest->nelem > dest->alloc)\n    {\n      Idx new_alloc = src1->nelem + src2->nelem + dest->alloc;\n      Idx *new_elems = re_realloc (dest->elems, Idx, new_alloc);\n      if (BE (new_elems == NULL, 0))\n\treturn REG_ESPACE;\n      dest->elems = new_elems;\n      dest->alloc = new_alloc;\n    }\n\n  /* Find the items in the intersection of SRC1 and SRC2, and copy\n     into the top of DEST those that are not already in DEST itself.  */\n  sbase = dest->nelem + src1->nelem + src2->nelem;\n  i1 = src1->nelem - 1;\n  i2 = src2->nelem - 1;\n  id = dest->nelem - 1;\n  for (;;)\n    {\n      if (src1->elems[i1] == src2->elems[i2])\n\t{\n\t  /* Try to find the item in DEST.  Maybe we could binary search?  */\n\t  while (id >= 0 && dest->elems[id] > src1->elems[i1])\n\t    --id;\n\n\t  if (id < 0 || dest->elems[id] != src1->elems[i1])\n            dest->elems[--sbase] = src1->elems[i1];\n\n\t  if (--i1 < 0 || --i2 < 0)\n\t    break;\n\t}\n\n      /* Lower the highest of the two items.  */\n      else if (src1->elems[i1] < src2->elems[i2])\n\t{\n\t  if (--i2 < 0)\n\t    break;\n\t}\n      else\n\t{\n\t  if (--i1 < 0)\n\t    break;\n\t}\n    }\n\n  id = dest->nelem - 1;\n  is = dest->nelem + src1->nelem + src2->nelem - 1;\n  delta = is - sbase + 1;\n\n  /* Now copy.  When DELTA becomes zero, the remaining\n     DEST elements are already in place; this is more or\n     less the same loop that is in re_node_set_merge.  */\n  dest->nelem += delta;\n  if (delta > 0 && id >= 0)\n    for (;;)\n      {\n\tif (dest->elems[is] > dest->elems[id])\n\t  {\n\t    /* Copy from the top.  */\n\t    dest->elems[id + delta--] = dest->elems[is--];\n\t    if (delta == 0)\n\t      break;\n\t  }\n\telse\n\t  {\n\t    /* Slide from the bottom.  */\n\t    dest->elems[id + delta] = dest->elems[id];\n\t    if (--id < 0)\n\t      break;\n\t  }\n      }\n\n  /* Copy remaining SRC elements.  */\n  memcpy (dest->elems, dest->elems + sbase, delta * sizeof (Idx));\n\n  return REG_NOERROR;\n}",
      "lines": 87,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "__attribute_warn_unused_result__",
        "__attribute_warn_unused_result__"
      ]
    },
    "re_node_set_init_union": {
      "start_point": [
        1130,
        0
      ],
      "end_point": [
        1178,
        1
      ],
      "content": "static reg_errcode_t\n__attribute_warn_unused_result__\nre_node_set_init_union (re_node_set *dest, const re_node_set *src1,\n\t\t\tconst re_node_set *src2)\n{\n  Idx i1, i2, id;\n  if (src1 != NULL && src1->nelem > 0 && src2 != NULL && src2->nelem > 0)\n    {\n      dest->alloc = src1->nelem + src2->nelem;\n      dest->elems = re_malloc (Idx, dest->alloc);\n      if (BE (dest->elems == NULL, 0))\n\treturn REG_ESPACE;\n    }\n  else\n    {\n      if (src1 != NULL && src1->nelem > 0)\n\treturn re_node_set_init_copy (dest, src1);\n      else if (src2 != NULL && src2->nelem > 0)\n\treturn re_node_set_init_copy (dest, src2);\n      else\n\tre_node_set_init_empty (dest);\n      return REG_NOERROR;\n    }\n  for (i1 = i2 = id = 0 ; i1 < src1->nelem && i2 < src2->nelem ;)\n    {\n      if (src1->elems[i1] > src2->elems[i2])\n\t{\n\t  dest->elems[id++] = src2->elems[i2++];\n\t  continue;\n\t}\n      if (src1->elems[i1] == src2->elems[i2])\n\t++i2;\n      dest->elems[id++] = src1->elems[i1++];\n    }\n  if (i1 < src1->nelem)\n    {\n      memcpy (dest->elems + id, src1->elems + i1,\n\t     (src1->nelem - i1) * sizeof (Idx));\n      id += src1->nelem - i1;\n    }\n  else if (i2 < src2->nelem)\n    {\n      memcpy (dest->elems + id, src2->elems + i2,\n\t     (src2->nelem - i2) * sizeof (Idx));\n      id += src2->nelem - i2;\n    }\n  dest->nelem = id;\n  return REG_NOERROR;\n}",
      "lines": 49,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "__attribute_warn_unused_result__",
        "__attribute_warn_unused_result__"
      ]
    },
    "re_node_set_merge": {
      "start_point": [
        1183,
        0
      ],
      "end_point": [
        1260,
        1
      ],
      "content": "static reg_errcode_t\n__attribute_warn_unused_result__\nre_node_set_merge (re_node_set *dest, const re_node_set *src)\n{\n  Idx is, id, sbase, delta;\n  if (src == NULL || src->nelem == 0)\n    return REG_NOERROR;\n  if (dest->alloc < 2 * src->nelem + dest->nelem)\n    {\n      Idx new_alloc = 2 * (src->nelem + dest->alloc);\n      Idx *new_buffer = re_realloc (dest->elems, Idx, new_alloc);\n      if (BE (new_buffer == NULL, 0))\n\treturn REG_ESPACE;\n      dest->elems = new_buffer;\n      dest->alloc = new_alloc;\n    }\n\n  if (BE (dest->nelem == 0, 0))\n    {\n      dest->nelem = src->nelem;\n      memcpy (dest->elems, src->elems, src->nelem * sizeof (Idx));\n      return REG_NOERROR;\n    }\n\n  /* Copy into the top of DEST the items of SRC that are not\n     found in DEST.  Maybe we could binary search in DEST?  */\n  for (sbase = dest->nelem + 2 * src->nelem,\n       is = src->nelem - 1, id = dest->nelem - 1; is >= 0 && id >= 0; )\n    {\n      if (dest->elems[id] == src->elems[is])\n\tis--, id--;\n      else if (dest->elems[id] < src->elems[is])\n\tdest->elems[--sbase] = src->elems[is--];\n      else /* if (dest->elems[id] > src->elems[is]) */\n\t--id;\n    }\n\n  if (is >= 0)\n    {\n      /* If DEST is exhausted, the remaining items of SRC must be unique.  */\n      sbase -= is + 1;\n      memcpy (dest->elems + sbase, src->elems, (is + 1) * sizeof (Idx));\n    }\n\n  id = dest->nelem - 1;\n  is = dest->nelem + 2 * src->nelem - 1;\n  delta = is - sbase + 1;\n  if (delta == 0)\n    return REG_NOERROR;\n\n  /* Now copy.  When DELTA becomes zero, the remaining\n     DEST elements are already in place.  */\n  dest->nelem += delta;\n  for (;;)\n    {\n      if (dest->elems[is] > dest->elems[id])\n\t{\n\t  /* Copy from the top.  */\n\t  dest->elems[id + delta--] = dest->elems[is--];\n\t  if (delta == 0)\n\t    break;\n\t}\n      else\n\t{\n\t  /* Slide from the bottom.  */\n\t  dest->elems[id + delta] = dest->elems[id];\n\t  if (--id < 0)\n\t    {\n\t      /* Copy remaining SRC elements.  */\n\t      memcpy (dest->elems, dest->elems + sbase,\n\t\t      delta * sizeof (Idx));\n\t      break;\n\t    }\n\t}\n    }\n\n  return REG_NOERROR;\n}",
      "lines": 78,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "__attribute_warn_unused_result__",
        "__attribute_warn_unused_result__"
      ]
    },
    "re_node_set_insert": {
      "start_point": [
        1266,
        0
      ],
      "end_point": [
        1312,
        1
      ],
      "content": "static bool\n__attribute_warn_unused_result__\nre_node_set_insert (re_node_set *set, Idx elem)\n{\n  Idx idx;\n  /* In case the set is empty.  */\n  if (set->alloc == 0)\n    return BE (re_node_set_init_1 (set, elem) == REG_NOERROR, 1);\n\n  if (BE (set->nelem, 0) == 0)\n    {\n      /* We already guaranteed above that set->alloc != 0.  */\n      set->elems[0] = elem;\n      ++set->nelem;\n      return true;\n    }\n\n  /* Realloc if we need.  */\n  if (set->alloc == set->nelem)\n    {\n      Idx *new_elems;\n      set->alloc = set->alloc * 2;\n      new_elems = re_realloc (set->elems, Idx, set->alloc);\n      if (BE (new_elems == NULL, 0))\n\treturn false;\n      set->elems = new_elems;\n    }\n\n  /* Move the elements which follows the new element.  Test the\n     first element separately to skip a check in the inner loop.  */\n  if (elem < set->elems[0])\n    {\n      idx = 0;\n      for (idx = set->nelem; idx > 0; idx--)\n\tset->elems[idx] = set->elems[idx - 1];\n    }\n  else\n    {\n      for (idx = set->nelem; set->elems[idx - 1] > elem; idx--)\n\tset->elems[idx] = set->elems[idx - 1];\n    }\n\n  /* Insert the new element.  */\n  set->elems[idx] = elem;\n  ++set->nelem;\n  return true;\n}",
      "lines": 47,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "bool",
        "__attribute_warn_unused_result__",
        "__attribute_warn_unused_result__"
      ]
    },
    "re_node_set_insert_last": {
      "start_point": [
        1318,
        0
      ],
      "end_point": [
        1336,
        1
      ],
      "content": "static bool\n__attribute_warn_unused_result__\nre_node_set_insert_last (re_node_set *set, Idx elem)\n{\n  /* Realloc if we need.  */\n  if (set->alloc == set->nelem)\n    {\n      Idx *new_elems;\n      set->alloc = (set->alloc + 1) * 2;\n      new_elems = re_realloc (set->elems, Idx, set->alloc);\n      if (BE (new_elems == NULL, 0))\n\treturn false;\n      set->elems = new_elems;\n    }\n\n  /* Insert the new element.  */\n  set->elems[set->nelem++] = elem;\n  return true;\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "bool",
        "__attribute_warn_unused_result__",
        "__attribute_warn_unused_result__"
      ]
    },
    "re_node_set_compare": {
      "start_point": [
        1341,
        0
      ],
      "end_point": [
        1352,
        1
      ],
      "content": "static bool\n__attribute__ ((pure))\nre_node_set_compare (const re_node_set *set1, const re_node_set *set2)\n{\n  Idx i;\n  if (set1 == NULL || set2 == NULL || set1->nelem != set2->nelem)\n    return false;\n  for (i = set1->nelem ; --i >= 0 ; )\n    if (set1->elems[i] != set2->elems[i])\n      return false;\n  return true;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "bool",
        "__attribute__ ((pure))",
        "__attribute__",
        "(",
        "(pure)",
        "(",
        "pure",
        ")",
        ")"
      ]
    },
    "re_node_set_contains": {
      "start_point": [
        1356,
        0
      ],
      "end_point": [
        1376,
        1
      ],
      "content": "static Idx\n__attribute__ ((pure))\nre_node_set_contains (const re_node_set *set, Idx elem)\n{\n  __re_size_t idx, right, mid;\n  if (set->nelem <= 0)\n    return 0;\n\n  /* Binary search the element.  */\n  idx = 0;\n  right = set->nelem - 1;\n  while (idx < right)\n    {\n      mid = (idx + right) / 2;\n      if (set->elems[mid] < elem)\n\tidx = mid + 1;\n      else\n\tright = mid;\n    }\n  return set->elems[idx] == elem ? idx + 1 : 0;\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "Idx",
        "__attribute__ ((pure))",
        "__attribute__",
        "(",
        "(pure)",
        "(",
        "pure",
        ")",
        ")"
      ]
    },
    "re_node_set_remove_at": {
      "start_point": [
        1378,
        0
      ],
      "end_point": [
        1386,
        1
      ],
      "content": "static void\nre_node_set_remove_at (re_node_set *set, Idx idx)\n{\n  if (idx < 0 || idx >= set->nelem)\n    return;\n  --set->nelem;\n  for (; idx < set->nelem; idx++)\n    set->elems[idx] = set->elems[idx + 1];\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "re_dfa_add_node": {
      "start_point": [
        1392,
        0
      ],
      "end_point": [
        1443,
        1
      ],
      "content": "static Idx\nre_dfa_add_node (re_dfa_t *dfa, re_token_t token)\n{\n  if (BE (dfa->nodes_len >= dfa->nodes_alloc, 0))\n    {\n      size_t new_nodes_alloc = dfa->nodes_alloc * 2;\n      Idx *new_nexts, *new_indices;\n      re_node_set *new_edests, *new_eclosures;\n      re_token_t *new_nodes;\n\n      /* Avoid overflows in realloc.  */\n      const size_t max_object_size = MAX (sizeof (re_token_t),\n\t\t\t\t\t  MAX (sizeof (re_node_set),\n\t\t\t\t\t       sizeof (Idx)));\n      if (BE (MIN (IDX_MAX, SIZE_MAX / max_object_size) < new_nodes_alloc, 0))\n\treturn -1;\n\n      new_nodes = re_realloc (dfa->nodes, re_token_t, new_nodes_alloc);\n      if (BE (new_nodes == NULL, 0))\n\treturn -1;\n      dfa->nodes = new_nodes;\n      new_nexts = re_realloc (dfa->nexts, Idx, new_nodes_alloc);\n      new_indices = re_realloc (dfa->org_indices, Idx, new_nodes_alloc);\n      new_edests = re_realloc (dfa->edests, re_node_set, new_nodes_alloc);\n      new_eclosures = re_realloc (dfa->eclosures, re_node_set, new_nodes_alloc);\n      if (BE (new_nexts == NULL || new_indices == NULL\n\t      || new_edests == NULL || new_eclosures == NULL, 0))\n\t{\n\t   re_free (new_nexts);\n\t   re_free (new_indices);\n\t   re_free (new_edests);\n\t   re_free (new_eclosures);\n\t   return -1;\n\t}\n      dfa->nexts = new_nexts;\n      dfa->org_indices = new_indices;\n      dfa->edests = new_edests;\n      dfa->eclosures = new_eclosures;\n      dfa->nodes_alloc = new_nodes_alloc;\n    }\n  dfa->nodes[dfa->nodes_len] = token;\n  dfa->nodes[dfa->nodes_len].constraint = 0;\n#ifdef RE_ENABLE_I18N\n  dfa->nodes[dfa->nodes_len].accept_mb =\n    ((token.type == OP_PERIOD && dfa->mb_cur_max > 1)\n     || token.type == COMPLEX_BRACKET);\n#endif\n  dfa->nexts[dfa->nodes_len] = -1;\n  re_node_set_init_empty (dfa->edests + dfa->nodes_len);\n  re_node_set_init_empty (dfa->eclosures + dfa->nodes_len);\n  return dfa->nodes_len++;\n}",
      "lines": 52,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "Idx"
      ]
    },
    "calc_state_hash": {
      "start_point": [
        1445,
        0
      ],
      "end_point": [
        1453,
        1
      ],
      "content": "static re_hashval_t\ncalc_state_hash (const re_node_set *nodes, unsigned int context)\n{\n  re_hashval_t hash = nodes->nelem + context;\n  Idx i;\n  for (i = 0 ; i < nodes->nelem ; i++)\n    hash += nodes->elems[i];\n  return hash;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "re_hashval_t"
      ]
    },
    "re_acquire_state": {
      "start_point": [
        1464,
        0
      ],
      "end_point": [
        1500,
        1
      ],
      "content": "static re_dfastate_t *\n__attribute_warn_unused_result__\nre_acquire_state (reg_errcode_t *err, const re_dfa_t *dfa,\n\t\t  const re_node_set *nodes)\n{\n  re_hashval_t hash;\n  re_dfastate_t *new_state;\n  struct re_state_table_entry *spot;\n  Idx i;\n#if defined GCC_LINT || defined lint\n  /* Suppress bogus uninitialized-variable warnings.  */\n  *err = REG_NOERROR;\n#endif\n  if (BE (nodes->nelem == 0, 0))\n    {\n      *err = REG_NOERROR;\n      return NULL;\n    }\n  hash = calc_state_hash (nodes, 0);\n  spot = dfa->state_table + (hash & dfa->state_hash_mask);\n\n  for (i = 0 ; i < spot->num ; i++)\n    {\n      re_dfastate_t *state = spot->array[i];\n      if (hash != state->hash)\n\tcontinue;\n      if (re_node_set_compare (&state->nodes, nodes))\n\treturn state;\n    }\n\n  /* There are no appropriate state in the dfa, create the new one.  */\n  new_state = create_ci_newstate (dfa, nodes, hash);\n  if (BE (new_state == NULL, 0))\n    *err = REG_ESPACE;\n\n  return new_state;\n}",
      "lines": 37,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "re_dfastate_t",
        "*\n__attribute_warn_unused_result__\nre_acquire_state (reg_errcode_t *err, const re_dfa_t *dfa,\n\t\t  const re_node_set *nodes)",
        "*",
        "__attribute_warn_unused_result__",
        "__attribute_warn_unused_result__"
      ]
    },
    "re_acquire_state_context": {
      "start_point": [
        1512,
        0
      ],
      "end_point": [
        1547,
        1
      ],
      "content": "static re_dfastate_t *\n__attribute_warn_unused_result__\nre_acquire_state_context (reg_errcode_t *err, const re_dfa_t *dfa,\n\t\t\t  const re_node_set *nodes, unsigned int context)\n{\n  re_hashval_t hash;\n  re_dfastate_t *new_state;\n  struct re_state_table_entry *spot;\n  Idx i;\n#if defined GCC_LINT || defined lint\n  /* Suppress bogus uninitialized-variable warnings.  */\n  *err = REG_NOERROR;\n#endif\n  if (nodes->nelem == 0)\n    {\n      *err = REG_NOERROR;\n      return NULL;\n    }\n  hash = calc_state_hash (nodes, context);\n  spot = dfa->state_table + (hash & dfa->state_hash_mask);\n\n  for (i = 0 ; i < spot->num ; i++)\n    {\n      re_dfastate_t *state = spot->array[i];\n      if (state->hash == hash\n\t  && state->context == context\n\t  && re_node_set_compare (state->entrance_nodes, nodes))\n\treturn state;\n    }\n  /* There are no appropriate state in 'dfa', create the new one.  */\n  new_state = create_cd_newstate (dfa, nodes, context, hash);\n  if (BE (new_state == NULL, 0))\n    *err = REG_ESPACE;\n\n  return new_state;\n}",
      "lines": 36,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "re_dfastate_t",
        "*\n__attribute_warn_unused_result__\nre_acquire_state_context (reg_errcode_t *err, const re_dfa_t *dfa,\n\t\t\t  const re_node_set *nodes, unsigned int context)",
        "*",
        "__attribute_warn_unused_result__",
        "__attribute_warn_unused_result__"
      ]
    },
    "register_state": {
      "start_point": [
        1553,
        0
      ],
      "end_point": [
        1587,
        1
      ],
      "content": "static reg_errcode_t\n__attribute_warn_unused_result__\nregister_state (const re_dfa_t *dfa, re_dfastate_t *newstate,\n\t\tre_hashval_t hash)\n{\n  struct re_state_table_entry *spot;\n  reg_errcode_t err;\n  Idx i;\n\n  newstate->hash = hash;\n  err = re_node_set_alloc (&newstate->non_eps_nodes, newstate->nodes.nelem);\n  if (BE (err != REG_NOERROR, 0))\n    return REG_ESPACE;\n  for (i = 0; i < newstate->nodes.nelem; i++)\n    {\n      Idx elem = newstate->nodes.elems[i];\n      if (!IS_EPSILON_NODE (dfa->nodes[elem].type))\n\tif (! re_node_set_insert_last (&newstate->non_eps_nodes, elem))\n\t  return REG_ESPACE;\n    }\n\n  spot = dfa->state_table + (hash & dfa->state_hash_mask);\n  if (BE (spot->alloc <= spot->num, 0))\n    {\n      Idx new_alloc = 2 * spot->num + 2;\n      re_dfastate_t **new_array = re_realloc (spot->array, re_dfastate_t *,\n\t\t\t\t\t      new_alloc);\n      if (BE (new_array == NULL, 0))\n\treturn REG_ESPACE;\n      spot->array = new_array;\n      spot->alloc = new_alloc;\n    }\n  spot->array[spot->num++] = newstate;\n  return REG_NOERROR;\n}",
      "lines": 35,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "__attribute_warn_unused_result__",
        "__attribute_warn_unused_result__"
      ]
    },
    "free_state": {
      "start_point": [
        1589,
        0
      ],
      "end_point": [
        1603,
        1
      ],
      "content": "static void\nfree_state (re_dfastate_t *state)\n{\n  re_node_set_free (&state->non_eps_nodes);\n  re_node_set_free (&state->inveclosure);\n  if (state->entrance_nodes != &state->nodes)\n    {\n      re_node_set_free (state->entrance_nodes);\n      re_free (state->entrance_nodes);\n    }\n  re_node_set_free (&state->nodes);\n  re_free (state->word_trtable);\n  re_free (state->trtable);\n  re_free (state);\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "create_ci_newstate": {
      "start_point": [
        1608,
        0
      ],
      "end_point": [
        1653,
        1
      ],
      "content": "static re_dfastate_t *\n__attribute_warn_unused_result__\ncreate_ci_newstate (const re_dfa_t *dfa, const re_node_set *nodes,\n\t\t    re_hashval_t hash)\n{\n  Idx i;\n  reg_errcode_t err;\n  re_dfastate_t *newstate;\n\n  newstate = (re_dfastate_t *) calloc (sizeof (re_dfastate_t), 1);\n  if (BE (newstate == NULL, 0))\n    return NULL;\n  err = re_node_set_init_copy (&newstate->nodes, nodes);\n  if (BE (err != REG_NOERROR, 0))\n    {\n      re_free (newstate);\n      return NULL;\n    }\n\n  newstate->entrance_nodes = &newstate->nodes;\n  for (i = 0 ; i < nodes->nelem ; i++)\n    {\n      re_token_t *node = dfa->nodes + nodes->elems[i];\n      re_token_type_t type = node->type;\n      if (type == CHARACTER && !node->constraint)\n\tcontinue;\n#ifdef RE_ENABLE_I18N\n      newstate->accept_mb |= node->accept_mb;\n#endif /* RE_ENABLE_I18N */\n\n      /* If the state has the halt node, the state is a halt state.  */\n      if (type == END_OF_RE)\n\tnewstate->halt = 1;\n      else if (type == OP_BACK_REF)\n\tnewstate->has_backref = 1;\n      else if (type == ANCHOR || node->constraint)\n\tnewstate->has_constraint = 1;\n    }\n  err = register_state (dfa, newstate, hash);\n  if (BE (err != REG_NOERROR, 0))\n    {\n      free_state (newstate);\n      newstate = NULL;\n    }\n  return newstate;\n}",
      "lines": 46,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "re_dfastate_t",
        "*\n__attribute_warn_unused_result__\ncreate_ci_newstate (const re_dfa_t *dfa, const re_node_set *nodes,\n\t\t    re_hashval_t hash)",
        "*",
        "__attribute_warn_unused_result__",
        "__attribute_warn_unused_result__"
      ]
    },
    "create_cd_newstate": {
      "start_point": [
        1658,
        0
      ],
      "end_point": [
        1729,
        1
      ],
      "content": "static re_dfastate_t *\n__attribute_warn_unused_result__\ncreate_cd_newstate (const re_dfa_t *dfa, const re_node_set *nodes,\n\t\t    unsigned int context, re_hashval_t hash)\n{\n  Idx i, nctx_nodes = 0;\n  reg_errcode_t err;\n  re_dfastate_t *newstate;\n\n  newstate = (re_dfastate_t *) calloc (sizeof (re_dfastate_t), 1);\n  if (BE (newstate == NULL, 0))\n    return NULL;\n  err = re_node_set_init_copy (&newstate->nodes, nodes);\n  if (BE (err != REG_NOERROR, 0))\n    {\n      re_free (newstate);\n      return NULL;\n    }\n\n  newstate->context = context;\n  newstate->entrance_nodes = &newstate->nodes;\n\n  for (i = 0 ; i < nodes->nelem ; i++)\n    {\n      re_token_t *node = dfa->nodes + nodes->elems[i];\n      re_token_type_t type = node->type;\n      unsigned int constraint = node->constraint;\n\n      if (type == CHARACTER && !constraint)\n\tcontinue;\n#ifdef RE_ENABLE_I18N\n      newstate->accept_mb |= node->accept_mb;\n#endif /* RE_ENABLE_I18N */\n\n      /* If the state has the halt node, the state is a halt state.  */\n      if (type == END_OF_RE)\n\tnewstate->halt = 1;\n      else if (type == OP_BACK_REF)\n\tnewstate->has_backref = 1;\n\n      if (constraint)\n\t{\n\t  if (newstate->entrance_nodes == &newstate->nodes)\n\t    {\n\t      newstate->entrance_nodes = re_malloc (re_node_set, 1);\n\t      if (BE (newstate->entrance_nodes == NULL, 0))\n\t\t{\n\t\t  free_state (newstate);\n\t\t  return NULL;\n\t\t}\n\t      if (re_node_set_init_copy (newstate->entrance_nodes, nodes)\n\t\t  != REG_NOERROR)\n\t\treturn NULL;\n\t      nctx_nodes = 0;\n\t      newstate->has_constraint = 1;\n\t    }\n\n\t  if (NOT_SATISFY_PREV_CONSTRAINT (constraint,context))\n\t    {\n\t      re_node_set_remove_at (&newstate->nodes, i - nctx_nodes);\n\t      ++nctx_nodes;\n\t    }\n\t}\n    }\n  err = register_state (dfa, newstate, hash);\n  if (BE (err != REG_NOERROR, 0))\n    {\n      free_state (newstate);\n      newstate = NULL;\n    }\n  return  newstate;\n}",
      "lines": 72,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "re_dfastate_t",
        "*\n__attribute_warn_unused_result__\ncreate_cd_newstate (const re_dfa_t *dfa, const re_node_set *nodes,\n\t\t    unsigned int context, re_hashval_t hash)",
        "*",
        "__attribute_warn_unused_result__",
        "__attribute_warn_unused_result__"
      ]
    }
  },
  "sed/sed-4.5/lib/regex_internal.h": {
    "bitset_set": {
      "start_point": [
        759,
        0
      ],
      "end_point": [
        763,
        1
      ],
      "content": "static void\nbitset_set (bitset_t set, Idx i)\n{\n  set[i / BITSET_WORD_BITS] |= (bitset_word_t) 1 << i % BITSET_WORD_BITS;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bitset_clear": {
      "start_point": [
        765,
        0
      ],
      "end_point": [
        769,
        1
      ],
      "content": "static void\nbitset_clear (bitset_t set, Idx i)\n{\n  set[i / BITSET_WORD_BITS] &= ~ ((bitset_word_t) 1 << i % BITSET_WORD_BITS);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bitset_contain": {
      "start_point": [
        771,
        0
      ],
      "end_point": [
        775,
        1
      ],
      "content": "static bool\nbitset_contain (const bitset_t set, Idx i)\n{\n  return (set[i / BITSET_WORD_BITS] >> i % BITSET_WORD_BITS) & 1;\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "bitset_empty": {
      "start_point": [
        777,
        0
      ],
      "end_point": [
        781,
        1
      ],
      "content": "static void\nbitset_empty (bitset_t set)\n{\n  memset (set, '\\0', sizeof (bitset_t));\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bitset_set_all": {
      "start_point": [
        783,
        0
      ],
      "end_point": [
        790,
        1
      ],
      "content": "static void\nbitset_set_all (bitset_t set)\n{\n  memset (set, -1, sizeof (bitset_word_t) * (SBC_MAX / BITSET_WORD_BITS));\n  if (SBC_MAX % BITSET_WORD_BITS != 0)\n    set[BITSET_WORDS - 1] =\n      ((bitset_word_t) 1 << SBC_MAX % BITSET_WORD_BITS) - 1;\n}",
      "lines": 8,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bitset_copy": {
      "start_point": [
        792,
        0
      ],
      "end_point": [
        796,
        1
      ],
      "content": "static void\nbitset_copy (bitset_t dest, const bitset_t src)\n{\n  memcpy (dest, src, sizeof (bitset_t));\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bitset_not": {
      "start_point": [
        798,
        0
      ],
      "end_point": [
        808,
        1
      ],
      "content": "static void __attribute__ ((unused))\nbitset_not (bitset_t set)\n{\n  int bitset_i;\n  for (bitset_i = 0; bitset_i < SBC_MAX / BITSET_WORD_BITS; ++bitset_i)\n    set[bitset_i] = ~set[bitset_i];\n  if (SBC_MAX % BITSET_WORD_BITS != 0)\n    set[BITSET_WORDS - 1] =\n      ((((bitset_word_t) 1 << SBC_MAX % BITSET_WORD_BITS) - 1)\n       & ~set[BITSET_WORDS - 1]);\n}",
      "lines": 11,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void",
        "__attribute__ ((unused))",
        "__attribute__",
        "(",
        "(unused)",
        "(",
        "unused",
        ")",
        ")"
      ]
    },
    "bitset_merge": {
      "start_point": [
        810,
        0
      ],
      "end_point": [
        816,
        1
      ],
      "content": "static void __attribute__ ((unused))\nbitset_merge (bitset_t dest, const bitset_t src)\n{\n  int bitset_i;\n  for (bitset_i = 0; bitset_i < BITSET_WORDS; ++bitset_i)\n    dest[bitset_i] |= src[bitset_i];\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void",
        "__attribute__ ((unused))",
        "__attribute__",
        "(",
        "(unused)",
        "(",
        "unused",
        ")",
        ")"
      ]
    },
    "bitset_mask": {
      "start_point": [
        818,
        0
      ],
      "end_point": [
        824,
        1
      ],
      "content": "static void __attribute__ ((unused))\nbitset_mask (bitset_t dest, const bitset_t src)\n{\n  int bitset_i;\n  for (bitset_i = 0; bitset_i < BITSET_WORDS; ++bitset_i)\n    dest[bitset_i] &= src[bitset_i];\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void",
        "__attribute__ ((unused))",
        "__attribute__",
        "(",
        "(unused)",
        "(",
        "unused",
        ")",
        ")"
      ]
    },
    "re_string_char_size_at": {
      "start_point": [
        828,
        0
      ],
      "end_point": [
        839,
        1
      ],
      "content": "static int\n__attribute__ ((pure, unused))\nre_string_char_size_at (const re_string_t *pstr, Idx idx)\n{\n  int byte_idx;\n  if (pstr->mb_cur_max == 1)\n    return 1;\n  for (byte_idx = 1; idx + byte_idx < pstr->valid_len; ++byte_idx)\n    if (pstr->wcs[idx + byte_idx] != WEOF)\n      break;\n  return byte_idx;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int",
        "__attribute__ ((pure, unused))",
        "__attribute__",
        "(",
        "(pure, unused)",
        "(",
        "pure",
        ",",
        "unused",
        ")",
        ")"
      ]
    },
    "re_string_wchar_at": {
      "start_point": [
        841,
        0
      ],
      "end_point": [
        848,
        1
      ],
      "content": "static wint_t\n__attribute__ ((pure, unused))\nre_string_wchar_at (const re_string_t *pstr, Idx idx)\n{\n  if (pstr->mb_cur_max == 1)\n    return (wint_t) pstr->mbs[idx];\n  return (wint_t) pstr->wcs[idx];\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "wint_t",
        "__attribute__ ((pure, unused))",
        "__attribute__",
        "(",
        "(pure, unused)",
        "(",
        "pure",
        ",",
        "unused",
        ")",
        ")"
      ]
    },
    "re_string_elem_size_at": {
      "start_point": [
        854,
        0
      ],
      "end_point": [
        877,
        1
      ],
      "content": "static int\n__attribute__ ((pure, unused))\nre_string_elem_size_at (const re_string_t *pstr, Idx idx)\n{\n# ifdef _LIBC\n  const unsigned char *p, *extra;\n  const int32_t *table, *indirect;\n  uint_fast32_t nrules = _NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_NRULES);\n\n  if (nrules != 0)\n    {\n      table = (const int32_t *) _NL_CURRENT (LC_COLLATE, _NL_COLLATE_TABLEMB);\n      extra = (const unsigned char *)\n\t_NL_CURRENT (LC_COLLATE, _NL_COLLATE_EXTRAMB);\n      indirect = (const int32_t *) _NL_CURRENT (LC_COLLATE,\n\t\t\t\t\t\t_NL_COLLATE_INDIRECTMB);\n      p = pstr->mbs + idx;\n      findidx (table, indirect, extra, &p, pstr->len - idx);\n      return p - pstr->mbs - idx;\n    }\n  else\n# endif /* _LIBC */\n    return 1;\n}",
      "lines": 24,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int",
        "__attribute__ ((pure, unused))",
        "__attribute__",
        "(",
        "(pure, unused)",
        "(",
        "pure",
        ",",
        "unused",
        ")",
        ")"
      ]
    }
  },
  "sed/sed-4.5/lib/rename.c": {
    "rpl_rename": [
      {
        "start_point": [
          44,
          0
        ],
        "end_point": [
          262,
          1
        ],
        "content": "int\nrpl_rename (char const *src, char const *dst)\n{\n  int error;\n  size_t src_len = strlen (src);\n  size_t dst_len = strlen (dst);\n  char *src_base = last_component (src);\n  char *dst_base = last_component (dst);\n  bool src_slash;\n  bool dst_slash;\n  bool dst_exists;\n  struct stat src_st;\n  struct stat dst_st;\n\n  /* Filter out dot as last component.  */\n  if (!src_len || !dst_len)\n    {\n      errno = ENOENT;\n      return -1;\n    }\n  if (*src_base == '.')\n    {\n      size_t len = base_len (src_base);\n      if (len == 1 || (len == 2 && src_base[1] == '.'))\n        {\n          errno = EINVAL;\n          return -1;\n        }\n    }\n  if (*dst_base == '.')\n    {\n      size_t len = base_len (dst_base);\n      if (len == 1 || (len == 2 && dst_base[1] == '.'))\n        {\n          errno = EINVAL;\n          return -1;\n        }\n    }\n\n  /* Presence of a trailing slash requires directory semantics.  If\n     the source does not exist, or if the destination cannot be turned\n     into a directory, give up now.  Otherwise, strip trailing slashes\n     before calling rename.  There are no symlinks on mingw, so stat\n     works instead of lstat.  */\n  src_slash = ISSLASH (src[src_len - 1]);\n  dst_slash = ISSLASH (dst[dst_len - 1]);\n  if (stat (src, &src_st))\n    return -1;\n  if (stat (dst, &dst_st))\n    {\n      if (errno != ENOENT || (!S_ISDIR (src_st.st_mode) && dst_slash))\n        return -1;\n      dst_exists = false;\n    }\n  else\n    {\n      if (S_ISDIR (dst_st.st_mode) != S_ISDIR (src_st.st_mode))\n        {\n          errno = S_ISDIR (dst_st.st_mode) ? EISDIR : ENOTDIR;\n          return -1;\n        }\n      dst_exists = true;\n    }\n\n  /* There are no symlinks, so if a file existed with a trailing\n     slash, it must be a directory, and we don't have to worry about\n     stripping strip trailing slash.  However, mingw refuses to\n     replace an existing empty directory, so we have to help it out.\n     And canonicalize_file_name is not yet ported to mingw; however,\n     for directories, getcwd works as a viable alternative.  Ensure\n     that we can get back to where we started before using it; later\n     attempts to return are fatal.  Note that we can end up losing a\n     directory if rename then fails, but it was empty, so not much\n     damage was done.  */\n  if (dst_exists && S_ISDIR (dst_st.st_mode))\n    {\n      char *cwd = getcwd (NULL, 0);\n      char *src_temp;\n      char *dst_temp;\n      if (!cwd || chdir (cwd))\n        return -1;\n      if (IS_ABSOLUTE_FILE_NAME (src))\n        {\n          dst_temp = chdir (dst) ? NULL : getcwd (NULL, 0);\n          src_temp = chdir (src) ? NULL : getcwd (NULL, 0);\n        }\n      else\n        {\n          src_temp = chdir (src) ? NULL : getcwd (NULL, 0);\n          if (!IS_ABSOLUTE_FILE_NAME (dst) && chdir (cwd))\n            abort ();\n          dst_temp = chdir (dst) ? NULL : getcwd (NULL, 0);\n        }\n      if (chdir (cwd))\n        abort ();\n      free (cwd);\n      if (!src_temp || !dst_temp)\n        {\n          free (src_temp);\n          free (dst_temp);\n          errno = ENOMEM;\n          return -1;\n        }\n      src_len = strlen (src_temp);\n      if (strncmp (src_temp, dst_temp, src_len) == 0\n          && (ISSLASH (dst_temp[src_len]) || dst_temp[src_len] == '\\0'))\n        {\n          error = dst_temp[src_len];\n          free (src_temp);\n          free (dst_temp);\n          if (error)\n            {\n              errno = EINVAL;\n              return -1;\n            }\n          return 0;\n        }\n      if (rmdir (dst))\n        {\n          error = errno;\n          free (src_temp);\n          free (dst_temp);\n          errno = error;\n          return -1;\n        }\n      free (src_temp);\n      free (dst_temp);\n    }\n\n  /* MoveFileEx works if SRC is a directory without any flags, but\n     fails with MOVEFILE_REPLACE_EXISTING, so try without flags first.\n     Thankfully, MoveFileEx handles hard links correctly, even though\n     rename() does not.  */\n  if (MoveFileEx (src, dst, 0))\n    return 0;\n\n  /* Retry with MOVEFILE_REPLACE_EXISTING if the move failed\n     due to the destination already existing.  */\n  error = GetLastError ();\n  if (error == ERROR_FILE_EXISTS || error == ERROR_ALREADY_EXISTS)\n    {\n      if (MoveFileEx (src, dst, MOVEFILE_REPLACE_EXISTING))\n        return 0;\n\n      error = GetLastError ();\n    }\n\n  switch (error)\n    {\n    case ERROR_FILE_NOT_FOUND:\n    case ERROR_PATH_NOT_FOUND:\n    case ERROR_BAD_PATHNAME:\n    case ERROR_DIRECTORY:\n      errno = ENOENT;\n      break;\n\n    case ERROR_ACCESS_DENIED:\n    case ERROR_SHARING_VIOLATION:\n      errno = EACCES;\n      break;\n\n    case ERROR_OUTOFMEMORY:\n      errno = ENOMEM;\n      break;\n\n    case ERROR_CURRENT_DIRECTORY:\n      errno = EBUSY;\n      break;\n\n    case ERROR_NOT_SAME_DEVICE:\n      errno = EXDEV;\n      break;\n\n    case ERROR_WRITE_PROTECT:\n      errno = EROFS;\n      break;\n\n    case ERROR_WRITE_FAULT:\n    case ERROR_READ_FAULT:\n    case ERROR_GEN_FAILURE:\n      errno = EIO;\n      break;\n\n    case ERROR_HANDLE_DISK_FULL:\n    case ERROR_DISK_FULL:\n    case ERROR_DISK_TOO_FRAGMENTED:\n      errno = ENOSPC;\n      break;\n\n    case ERROR_FILE_EXISTS:\n    case ERROR_ALREADY_EXISTS:\n      errno = EEXIST;\n      break;\n\n    case ERROR_BUFFER_OVERFLOW:\n    case ERROR_FILENAME_EXCED_RANGE:\n      errno = ENAMETOOLONG;\n      break;\n\n    case ERROR_INVALID_NAME:\n    case ERROR_DELETE_PENDING:\n      errno = EPERM;        /* ? */\n      break;\n\n# ifndef ERROR_FILE_TOO_LARGE\n/* This value is documented but not defined in all versions of windows.h.  */\n#  define ERROR_FILE_TOO_LARGE 223\n# endif\n    case ERROR_FILE_TOO_LARGE:\n      errno = EFBIG;\n      break;\n\n    default:\n      errno = EINVAL;\n      break;\n    }\n\n  return -1;\n}",
        "lines": 219,
        "depth": 14,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          278,
          0
        ],
        "end_point": [
          473,
          1
        ],
        "content": "int\nrpl_rename (char const *src, char const *dst)\n{\n  size_t src_len = strlen (src);\n  size_t dst_len = strlen (dst);\n  char *src_temp = (char *) src;\n  char *dst_temp = (char *) dst;\n  bool src_slash;\n  bool dst_slash;\n  bool dst_exists _GL_UNUSED;\n  int ret_val = -1;\n  int rename_errno = ENOTDIR;\n  struct stat src_st;\n  struct stat dst_st;\n\n  if (!src_len || !dst_len)\n    return rename (src, dst); /* Let strace see the ENOENT failure.  */\n\n# if RENAME_DEST_EXISTS_BUG\n  {\n    char *src_base = last_component (src);\n    char *dst_base = last_component (dst);\n    if (*src_base == '.')\n      {\n        size_t len = base_len (src_base);\n        if (len == 1 || (len == 2 && src_base[1] == '.'))\n          {\n            errno = EINVAL;\n            return -1;\n          }\n      }\n    if (*dst_base == '.')\n      {\n        size_t len = base_len (dst_base);\n        if (len == 1 || (len == 2 && dst_base[1] == '.'))\n          {\n            errno = EINVAL;\n            return -1;\n          }\n      }\n  }\n# endif /* RENAME_DEST_EXISTS_BUG */\n\n  src_slash = src[src_len - 1] == '/';\n  dst_slash = dst[dst_len - 1] == '/';\n\n# if !RENAME_HARD_LINK_BUG && !RENAME_DEST_EXISTS_BUG\n  /* If there are no trailing slashes, then trust the native\n     implementation unless we also suspect issues with hard link\n     detection or file/directory conflicts.  */\n  if (!src_slash && !dst_slash)\n    return rename (src, dst);\n# endif /* !RENAME_HARD_LINK_BUG && !RENAME_DEST_EXISTS_BUG */\n\n  /* Presence of a trailing slash requires directory semantics.  If\n     the source does not exist, or if the destination cannot be turned\n     into a directory, give up now.  Otherwise, strip trailing slashes\n     before calling rename.  */\n  if (lstat (src, &src_st))\n    return -1;\n  if (lstat (dst, &dst_st))\n    {\n      if (errno != ENOENT || (!S_ISDIR (src_st.st_mode) && dst_slash))\n        return -1;\n      dst_exists = false;\n    }\n  else\n    {\n      if (S_ISDIR (dst_st.st_mode) != S_ISDIR (src_st.st_mode))\n        {\n          errno = S_ISDIR (dst_st.st_mode) ? EISDIR : ENOTDIR;\n          return -1;\n        }\n# if RENAME_HARD_LINK_BUG\n      if (SAME_INODE (src_st, dst_st))\n        return 0;\n# endif /* RENAME_HARD_LINK_BUG */\n      dst_exists = true;\n    }\n\n# if (RENAME_TRAILING_SLASH_SOURCE_BUG || RENAME_DEST_EXISTS_BUG        \\\n      || RENAME_HARD_LINK_BUG)\n  /* If the only bug was that a trailing slash was allowed on a\n     non-existing file destination, as in Solaris 10, then we've\n     already covered that situation.  But if there is any problem with\n     a trailing slash on an existing source or destination, as in\n     Solaris 9, or if a directory can overwrite a symlink, as on\n     Cygwin 1.5, or if directories cannot be created with trailing\n     slash, as on NetBSD 1.6, then we must strip the offending slash\n     and check that we have not encountered a symlink instead of a\n     directory.\n\n     Stripping a trailing slash interferes with POSIX semantics, where\n     rename behavior on a symlink with a trailing slash operates on\n     the corresponding target directory.  We prefer the GNU semantics\n     of rejecting any use of a symlink with trailing slash, but do not\n     enforce them, since Solaris 10 is able to obey POSIX semantics\n     and there might be clients expecting it, as counter-intuitive as\n     those semantics are.\n\n     Technically, we could also follow the POSIX behavior by chasing a\n     readlink trail, but that is harder to implement.  */\n  if (src_slash)\n    {\n      src_temp = strdup (src);\n      if (!src_temp)\n        {\n          /* Rather than rely on strdup-posix, we set errno ourselves.  */\n          rename_errno = ENOMEM;\n          goto out;\n        }\n      strip_trailing_slashes (src_temp);\n      if (lstat (src_temp, &src_st))\n        {\n          rename_errno = errno;\n          goto out;\n        }\n      if (S_ISLNK (src_st.st_mode))\n        goto out;\n    }\n  if (dst_slash)\n    {\n      dst_temp = strdup (dst);\n      if (!dst_temp)\n        {\n          rename_errno = ENOMEM;\n          goto out;\n        }\n      strip_trailing_slashes (dst_temp);\n      if (lstat (dst_temp, &dst_st))\n        {\n          if (errno != ENOENT)\n            {\n              rename_errno = errno;\n              goto out;\n            }\n        }\n      else if (S_ISLNK (dst_st.st_mode))\n        goto out;\n    }\n# endif /* RENAME_TRAILING_SLASH_SOURCE_BUG || RENAME_DEST_EXISTS_BUG\n           || RENAME_HARD_LINK_BUG */\n\n# if RENAME_DEST_EXISTS_BUG\n  /* Cygwin 1.5 sometimes behaves oddly when moving a non-empty\n     directory on top of an empty one (the old directory name can\n     reappear if the new directory tree is removed).  Work around this\n     by removing the target first, but don't remove the target if it\n     is a subdirectory of the source.  Note that we can end up losing\n     a directory if rename then fails, but it was empty, so not much\n     damage was done.  */\n  if (dst_exists && S_ISDIR (dst_st.st_mode))\n    {\n      if (src_st.st_dev != dst_st.st_dev)\n        {\n          rename_errno = EXDEV;\n          goto out;\n        }\n      if (src_temp != src)\n        free (src_temp);\n      src_temp = canonicalize_file_name (src);\n      if (dst_temp != dst)\n        free (dst_temp);\n      dst_temp = canonicalize_file_name (dst);\n      if (!src_temp || !dst_temp)\n        {\n          rename_errno = ENOMEM;\n          goto out;\n        }\n      src_len = strlen (src_temp);\n      if (strncmp (src_temp, dst_temp, src_len) == 0\n          && dst_temp[src_len] == '/')\n        {\n          rename_errno = EINVAL;\n          goto out;\n        }\n      if (rmdir (dst))\n        {\n          rename_errno = errno;\n          goto out;\n        }\n    }\n# endif /* RENAME_DEST_EXISTS_BUG */\n\n  ret_val = rename (src_temp, dst_temp);\n  rename_errno = errno;\n\n out: _GL_UNUSED_LABEL;\n\n  if (src_temp != src)\n    free (src_temp);\n  if (dst_temp != dst)\n    free (dst_temp);\n  errno = rename_errno;\n  return ret_val;\n}",
        "lines": 196,
        "depth": 14,
        "decorators": [
          "int"
        ]
      }
    ]
  },
  "sed/sed-4.5/lib/rmdir.c": {
    "rpl_rmdir": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "int\nrpl_rmdir (char const *dir)\n{\n  /* Work around cygwin 1.5.x bug where rmdir(\"dir/./\") succeeds.  */\n  size_t len = strlen (dir);\n  int result;\n  while (len && ISSLASH (dir[len - 1]))\n    len--;\n  if (len && dir[len - 1] == '.' && (1 == len || ISSLASH (dir[len - 2])))\n    {\n      errno = EINVAL;\n      return -1;\n    }\n  result = rmdir (dir);\n  /* Work around mingw bug, where rmdir(\"file/\") fails with EINVAL\n     instead of ENOTDIR.  We've already filtered out trailing ., the\n     only reason allowed by POSIX for EINVAL.  */\n  if (result == -1 && errno == EINVAL)\n    errno = ENOTDIR;\n  return result;\n}",
      "lines": 21,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/lib/same-inode.h": {},
  "sed/sed-4.5/lib/se-context.c": {},
  "sed/sed-4.5/lib/se-context.in.h": {
    "context_new": {
      "start_point": [
        16,
        0
      ],
      "end_point": [
        17,
        32
      ],
      "content": "SE_CONTEXT_INLINE context_t context_new (char const *s _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return 0; }",
      "lines": 2,
      "depth": 7,
      "decorators": [
        "SE_CONTEXT_INLINE",
        "context_t",
        "context_t"
      ]
    },
    "context_str": {
      "start_point": [
        18,
        0
      ],
      "end_point": [
        19,
        41
      ],
      "content": "SE_CONTEXT_INLINE char *context_str (context_t con _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return (void *) 0; }",
      "lines": 2,
      "depth": 7,
      "decorators": [
        "SE_CONTEXT_INLINE",
        "char",
        "char",
        "*context_str (context_t con _GL_UNUSED_PARAMETER)",
        "*"
      ]
    },
    "context_free": {
      "start_point": [
        20,
        0
      ],
      "end_point": [
        20,
        73
      ],
      "content": "SE_CONTEXT_INLINE void context_free (context_t c _GL_UNUSED_PARAMETER) {}",
      "lines": 1,
      "depth": 6,
      "decorators": [
        "SE_CONTEXT_INLINE",
        "void",
        "void"
      ]
    },
    "context_user_set": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        24,
        33
      ],
      "content": "SE_CONTEXT_INLINE int context_user_set (context_t sc _GL_UNUSED_PARAMETER,\n                                        char const *s _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return -1; }",
      "lines": 3,
      "depth": 7,
      "decorators": [
        "SE_CONTEXT_INLINE",
        "int",
        "int"
      ]
    },
    "context_role_set": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        27,
        33
      ],
      "content": "SE_CONTEXT_INLINE int context_role_set (context_t sc _GL_UNUSED_PARAMETER,\n                                        char const *s _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return -1; }",
      "lines": 3,
      "depth": 7,
      "decorators": [
        "SE_CONTEXT_INLINE",
        "int",
        "int"
      ]
    },
    "context_range_set": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        30,
        33
      ],
      "content": "SE_CONTEXT_INLINE int context_range_set (context_t sc _GL_UNUSED_PARAMETER,\n                                         char const *s _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return -1; }",
      "lines": 3,
      "depth": 7,
      "decorators": [
        "SE_CONTEXT_INLINE",
        "int",
        "int"
      ]
    },
    "context_type_set": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        33,
        33
      ],
      "content": "SE_CONTEXT_INLINE int context_type_set (context_t sc _GL_UNUSED_PARAMETER,\n                                        char const *s _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return -1; }",
      "lines": 3,
      "depth": 7,
      "decorators": [
        "SE_CONTEXT_INLINE",
        "int",
        "int"
      ]
    },
    "context_type_get": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        35,
        41
      ],
      "content": "SE_CONTEXT_INLINE char *context_type_get (context_t sc _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return (void *) 0; }",
      "lines": 2,
      "depth": 7,
      "decorators": [
        "SE_CONTEXT_INLINE",
        "char",
        "char",
        "*context_type_get (context_t sc _GL_UNUSED_PARAMETER)",
        "*"
      ]
    },
    "context_range_get": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        37,
        41
      ],
      "content": "SE_CONTEXT_INLINE char *context_range_get (context_t sc _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return (void *) 0; }",
      "lines": 2,
      "depth": 7,
      "decorators": [
        "SE_CONTEXT_INLINE",
        "char",
        "char",
        "*context_range_get (context_t sc _GL_UNUSED_PARAMETER)",
        "*"
      ]
    },
    "context_role_get": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        39,
        41
      ],
      "content": "SE_CONTEXT_INLINE char *context_role_get (context_t sc _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return (void *) 0; }",
      "lines": 2,
      "depth": 7,
      "decorators": [
        "SE_CONTEXT_INLINE",
        "char",
        "char",
        "*context_role_get (context_t sc _GL_UNUSED_PARAMETER)",
        "*"
      ]
    },
    "context_user_get": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        41,
        41
      ],
      "content": "SE_CONTEXT_INLINE char *context_user_get (context_t sc _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return (void *) 0; }",
      "lines": 2,
      "depth": 7,
      "decorators": [
        "SE_CONTEXT_INLINE",
        "char",
        "char",
        "*context_user_get (context_t sc _GL_UNUSED_PARAMETER)",
        "*"
      ]
    }
  },
  "sed/sed-4.5/lib/se-selinux.c": {},
  "sed/sed-4.5/lib/se-selinux.in.h": {
    "getcon": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        50,
        33
      ],
      "content": "SE_SELINUX_INLINE int\ngetcon (security_context_t *con _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return -1; }",
      "lines": 3,
      "depth": 7,
      "decorators": [
        "SE_SELINUX_INLINE",
        "int",
        "int"
      ]
    },
    "freecon": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        52,
        56
      ],
      "content": "SE_SELINUX_INLINE void\nfreecon (security_context_t con _GL_UNUSED_PARAMETER) {}",
      "lines": 2,
      "depth": 6,
      "decorators": [
        "SE_SELINUX_INLINE",
        "void",
        "void"
      ]
    },
    "getfscreatecon": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        56,
        33
      ],
      "content": "SE_SELINUX_INLINE int\ngetfscreatecon (security_context_t *con _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return -1; }",
      "lines": 3,
      "depth": 7,
      "decorators": [
        "SE_SELINUX_INLINE",
        "int",
        "int"
      ]
    },
    "setfscreatecon": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        59,
        33
      ],
      "content": "SE_SELINUX_INLINE int\nsetfscreatecon (security_context_t con _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return -1; }",
      "lines": 3,
      "depth": 6,
      "decorators": [
        "SE_SELINUX_INLINE",
        "int",
        "int"
      ]
    },
    "matchpathcon": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        64,
        33
      ],
      "content": "SE_SELINUX_INLINE int\nmatchpathcon (char const *file _GL_UNUSED_PARAMETER,\n              mode_t m _GL_UNUSED_PARAMETER,\n  security_context_t *con _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return -1; }",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "SE_SELINUX_INLINE",
        "int",
        "int"
      ]
    },
    "getfilecon": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        68,
        33
      ],
      "content": "SE_SELINUX_INLINE int\ngetfilecon (char const *file _GL_UNUSED_PARAMETER,\n            security_context_t *con _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return -1; }",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "SE_SELINUX_INLINE",
        "int",
        "int"
      ]
    },
    "lgetfilecon": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        72,
        33
      ],
      "content": "SE_SELINUX_INLINE int\nlgetfilecon (char const *file _GL_UNUSED_PARAMETER,\n             security_context_t *con _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return -1; }",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "SE_SELINUX_INLINE",
        "int",
        "int"
      ]
    },
    "fgetfilecon": {
      "start_point": [
        73,
        0
      ],
      "end_point": [
        75,
        33
      ],
      "content": "SE_SELINUX_INLINE int\nfgetfilecon (int fd, security_context_t *con _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return -1; }",
      "lines": 3,
      "depth": 7,
      "decorators": [
        "SE_SELINUX_INLINE",
        "int",
        "int"
      ]
    },
    "setfilecon": {
      "start_point": [
        76,
        0
      ],
      "end_point": [
        79,
        33
      ],
      "content": "SE_SELINUX_INLINE int\nsetfilecon (char const *file _GL_UNUSED_PARAMETER,\n            security_context_t con _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return -1; }",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "SE_SELINUX_INLINE",
        "int",
        "int"
      ]
    },
    "lsetfilecon": {
      "start_point": [
        80,
        0
      ],
      "end_point": [
        83,
        33
      ],
      "content": "SE_SELINUX_INLINE int\nlsetfilecon (char const *file _GL_UNUSED_PARAMETER,\n             security_context_t con _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return -1; }",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "SE_SELINUX_INLINE",
        "int",
        "int"
      ]
    },
    "fsetfilecon": {
      "start_point": [
        84,
        0
      ],
      "end_point": [
        87,
        33
      ],
      "content": "SE_SELINUX_INLINE int\nfsetfilecon (int fd _GL_UNUSED_PARAMETER,\n             security_context_t con _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return -1; }",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "SE_SELINUX_INLINE",
        "int",
        "int"
      ]
    },
    "security_check_context": {
      "start_point": [
        89,
        0
      ],
      "end_point": [
        91,
        33
      ],
      "content": "SE_SELINUX_INLINE int\nsecurity_check_context (security_context_t con _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return -1; }",
      "lines": 3,
      "depth": 6,
      "decorators": [
        "SE_SELINUX_INLINE",
        "int",
        "int"
      ]
    },
    "security_check_context_raw": {
      "start_point": [
        92,
        0
      ],
      "end_point": [
        94,
        33
      ],
      "content": "SE_SELINUX_INLINE int\nsecurity_check_context_raw (security_context_t con _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return -1; }",
      "lines": 3,
      "depth": 6,
      "decorators": [
        "SE_SELINUX_INLINE",
        "int",
        "int"
      ]
    },
    "setexeccon": {
      "start_point": [
        95,
        0
      ],
      "end_point": [
        97,
        33
      ],
      "content": "SE_SELINUX_INLINE int\nsetexeccon (security_context_t con _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return -1; }",
      "lines": 3,
      "depth": 6,
      "decorators": [
        "SE_SELINUX_INLINE",
        "int",
        "int"
      ]
    },
    "security_compute_create": {
      "start_point": [
        98,
        0
      ],
      "end_point": [
        103,
        33
      ],
      "content": "SE_SELINUX_INLINE int\nsecurity_compute_create (security_context_t scon _GL_UNUSED_PARAMETER,\n                         security_context_t tcon _GL_UNUSED_PARAMETER,\n                         security_class_t tclass _GL_UNUSED_PARAMETER,\n                         security_context_t *newcon _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return -1; }",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "SE_SELINUX_INLINE",
        "int",
        "int"
      ]
    },
    "string_to_security_class": {
      "start_point": [
        104,
        0
      ],
      "end_point": [
        106,
        32
      ],
      "content": "SE_SELINUX_INLINE security_class_t\nstring_to_security_class (char const *name)\n  { errno = ENOTSUP; return 0; }",
      "lines": 3,
      "depth": 6,
      "decorators": [
        "SE_SELINUX_INLINE",
        "security_class_t",
        "security_class_t"
      ]
    },
    "matchpathcon_init_prefix": {
      "start_point": [
        107,
        0
      ],
      "end_point": [
        110,
        33
      ],
      "content": "SE_SELINUX_INLINE int\nmatchpathcon_init_prefix (char const *path _GL_UNUSED_PARAMETER,\n                          char const *prefix _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return -1; }",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "SE_SELINUX_INLINE",
        "int",
        "int"
      ]
    }
  },
  "sed/sed-4.5/lib/set-acl.c": {
    "set_acl": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "int\nset_acl (char const *name, int desc, mode_t mode)\n{\n  int ret = qset_acl (name, desc, mode);\n  if (ret != 0)\n    error (0, errno, _(\"setting permissions for %s\"), quote (name));\n  return ret;\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/lib/set-permissions.c": {
    "acl_from_mode": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "static acl_t\nacl_from_mode (mode_t mode)\n{\n#  if HAVE_ACL_FREE_TEXT /* Tru64 */\n  char acl_text[] = \"u::---,g::---,o::---,\";\n#  else /* FreeBSD, IRIX */\n  char acl_text[] = \"u::---,g::---,o::---\";\n#  endif\n\n  if (mode & S_IRUSR) acl_text[ 3] = 'r';\n  if (mode & S_IWUSR) acl_text[ 4] = 'w';\n  if (mode & S_IXUSR) acl_text[ 5] = 'x';\n  if (mode & S_IRGRP) acl_text[10] = 'r';\n  if (mode & S_IWGRP) acl_text[11] = 'w';\n  if (mode & S_IXGRP) acl_text[12] = 'x';\n  if (mode & S_IROTH) acl_text[17] = 'r';\n  if (mode & S_IWOTH) acl_text[18] = 'w';\n  if (mode & S_IXOTH) acl_text[19] = 'x';\n\n  return acl_from_text (acl_text);\n}",
      "lines": 21,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "acl_t"
      ]
    },
    "set_acls_from_mode": [
      {
        "start_point": [
          54,
          0
        ],
        "end_point": [
          273,
          1
        ],
        "content": "static int\nset_acls_from_mode (const char *name, int desc, mode_t mode, bool *must_chmod)\n{\n#  ifdef ACE_GETACL\n  /* Solaris also has a different variant of ACLs, used in ZFS and NFSv4\n     file systems (whereas the other ones are used in UFS file systems).  */\n\n  /* The flags in the ace_t structure changed in a binary incompatible way\n     when ACL_NO_TRIVIAL etc. were introduced in <sys/acl.h> version 1.15.\n     How to distinguish the two conventions at runtime?\n     We fetch the existing ACL.  In the old convention, usually three ACEs have\n     a_flags = ACE_OWNER / ACE_GROUP / ACE_OTHER, in the range 0x0100..0x0400.\n     In the new convention, these values are not used.  */\n  int convention;\n\n  {\n    /* Initially, try to read the entries into a stack-allocated buffer.\n       Use malloc if it does not fit.  */\n    enum\n      {\n        alloc_init = 4000 / sizeof (ace_t), /* >= 3 */\n        alloc_max = MIN (INT_MAX, SIZE_MAX / sizeof (ace_t))\n      };\n    ace_t buf[alloc_init];\n    size_t alloc = alloc_init;\n    ace_t *entries = buf;\n    ace_t *malloced = NULL;\n    int count;\n\n    for (;;)\n      {\n        count = (desc != -1\n                 ? facl (desc, ACE_GETACL, alloc, entries)\n                 : acl (name, ACE_GETACL, alloc, entries));\n        if (count < 0 && errno == ENOSPC)\n          {\n            /* Increase the size of the buffer.  */\n            free (malloced);\n            if (alloc > alloc_max / 2)\n              {\n                errno = ENOMEM;\n                return -1;\n              }\n            alloc = 2 * alloc; /* <= alloc_max */\n            entries = malloced = (ace_t *) malloc (alloc * sizeof (ace_t));\n            if (entries == NULL)\n              {\n                errno = ENOMEM;\n                return -1;\n              }\n            continue;\n          }\n        break;\n      }\n\n    if (count <= 0)\n      convention = -1;\n    else\n      {\n        int i;\n\n        convention = 0;\n        for (i = 0; i < count; i++)\n          if (entries[i].a_flags & (OLD_ACE_OWNER | OLD_ACE_GROUP | OLD_ACE_OTHER))\n            {\n              convention = 1;\n              break;\n            }\n      }\n    free (malloced);\n  }\n\n  if (convention >= 0)\n    {\n      ace_t entries[6];\n      int count;\n      int ret;\n\n      if (convention)\n        {\n          /* Running on Solaris 10.  */\n          entries[0].a_type = OLD_ALLOW;\n          entries[0].a_flags = OLD_ACE_OWNER;\n          entries[0].a_who = 0; /* irrelevant */\n          entries[0].a_access_mask = (mode >> 6) & 7;\n          entries[1].a_type = OLD_ALLOW;\n          entries[1].a_flags = OLD_ACE_GROUP;\n          entries[1].a_who = 0; /* irrelevant */\n          entries[1].a_access_mask = (mode >> 3) & 7;\n          entries[2].a_type = OLD_ALLOW;\n          entries[2].a_flags = OLD_ACE_OTHER;\n          entries[2].a_who = 0;\n          entries[2].a_access_mask = mode & 7;\n          count = 3;\n        }\n      else\n        {\n          /* Running on Solaris 10 (newer version) or Solaris 11.\n             The details here were found through \"/bin/ls -lvd somefiles\".  */\n          entries[0].a_type = NEW_ACE_ACCESS_DENIED_ACE_TYPE;\n          entries[0].a_flags = NEW_ACE_OWNER;\n          entries[0].a_who = 0; /* irrelevant */\n          entries[0].a_access_mask = 0;\n          entries[1].a_type = NEW_ACE_ACCESS_ALLOWED_ACE_TYPE;\n          entries[1].a_flags = NEW_ACE_OWNER;\n          entries[1].a_who = 0; /* irrelevant */\n          entries[1].a_access_mask = NEW_ACE_WRITE_NAMED_ATTRS\n                                     | NEW_ACE_WRITE_ATTRIBUTES\n                                     | NEW_ACE_WRITE_ACL\n                                     | NEW_ACE_WRITE_OWNER;\n          if (mode & 0400)\n            entries[1].a_access_mask |= NEW_ACE_READ_DATA;\n          else\n            entries[0].a_access_mask |= NEW_ACE_READ_DATA;\n          if (mode & 0200)\n            entries[1].a_access_mask |= NEW_ACE_WRITE_DATA | NEW_ACE_APPEND_DATA;\n          else\n            entries[0].a_access_mask |= NEW_ACE_WRITE_DATA | NEW_ACE_APPEND_DATA;\n          if (mode & 0100)\n            entries[1].a_access_mask |= NEW_ACE_EXECUTE;\n          else\n            entries[0].a_access_mask |= NEW_ACE_EXECUTE;\n          entries[2].a_type = NEW_ACE_ACCESS_DENIED_ACE_TYPE;\n          entries[2].a_flags = NEW_ACE_GROUP | NEW_ACE_IDENTIFIER_GROUP;\n          entries[2].a_who = 0; /* irrelevant */\n          entries[2].a_access_mask = 0;\n          entries[3].a_type = NEW_ACE_ACCESS_ALLOWED_ACE_TYPE;\n          entries[3].a_flags = NEW_ACE_GROUP | NEW_ACE_IDENTIFIER_GROUP;\n          entries[3].a_who = 0; /* irrelevant */\n          entries[3].a_access_mask = 0;\n          if (mode & 0040)\n            entries[3].a_access_mask |= NEW_ACE_READ_DATA;\n          else\n            entries[2].a_access_mask |= NEW_ACE_READ_DATA;\n          if (mode & 0020)\n            entries[3].a_access_mask |= NEW_ACE_WRITE_DATA | NEW_ACE_APPEND_DATA;\n          else\n            entries[2].a_access_mask |= NEW_ACE_WRITE_DATA | NEW_ACE_APPEND_DATA;\n          if (mode & 0010)\n            entries[3].a_access_mask |= NEW_ACE_EXECUTE;\n          else\n            entries[2].a_access_mask |= NEW_ACE_EXECUTE;\n          entries[4].a_type = NEW_ACE_ACCESS_DENIED_ACE_TYPE;\n          entries[4].a_flags = NEW_ACE_EVERYONE;\n          entries[4].a_who = 0;\n          entries[4].a_access_mask = NEW_ACE_WRITE_NAMED_ATTRS\n                                     | NEW_ACE_WRITE_ATTRIBUTES\n                                     | NEW_ACE_WRITE_ACL\n                                     | NEW_ACE_WRITE_OWNER;\n          entries[5].a_type = NEW_ACE_ACCESS_ALLOWED_ACE_TYPE;\n          entries[5].a_flags = NEW_ACE_EVERYONE;\n          entries[5].a_who = 0;\n          entries[5].a_access_mask = NEW_ACE_READ_NAMED_ATTRS\n                                     | NEW_ACE_READ_ATTRIBUTES\n                                     | NEW_ACE_READ_ACL\n                                     | NEW_ACE_SYNCHRONIZE;\n          if (mode & 0004)\n            entries[5].a_access_mask |= NEW_ACE_READ_DATA;\n          else\n            entries[4].a_access_mask |= NEW_ACE_READ_DATA;\n          if (mode & 0002)\n            entries[5].a_access_mask |= NEW_ACE_WRITE_DATA | NEW_ACE_APPEND_DATA;\n          else\n            entries[4].a_access_mask |= NEW_ACE_WRITE_DATA | NEW_ACE_APPEND_DATA;\n          if (mode & 0001)\n            entries[5].a_access_mask |= NEW_ACE_EXECUTE;\n          else\n            entries[4].a_access_mask |= NEW_ACE_EXECUTE;\n          count = 6;\n        }\n      if (desc != -1)\n        ret = facl (desc, ACE_SETACL, count, entries);\n      else\n        ret = acl (name, ACE_SETACL, count, entries);\n      if (ret < 0 && errno != EINVAL && errno != ENOTSUP)\n        {\n          if (errno == ENOSYS)\n\t    {\n\t      *must_chmod = true;\n\t      return 0;\n\t    }\n          return -1;\n        }\n      if (ret == 0)\n\treturn 0;\n    }\n#  endif\n\n  {\n    aclent_t entries[3];\n    int ret;\n\n    entries[0].a_type = USER_OBJ;\n    entries[0].a_id = 0; /* irrelevant */\n    entries[0].a_perm = (mode >> 6) & 7;\n    entries[1].a_type = GROUP_OBJ;\n    entries[1].a_id = 0; /* irrelevant */\n    entries[1].a_perm = (mode >> 3) & 7;\n    entries[2].a_type = OTHER_OBJ;\n    entries[2].a_id = 0;\n    entries[2].a_perm = mode & 7;\n\n    if (desc != -1)\n      ret = facl (desc, SETACL,\n\t\t  sizeof (entries) / sizeof (aclent_t), entries);\n    else\n      ret = acl (name, SETACL,\n\t\t sizeof (entries) / sizeof (aclent_t), entries);\n    if (ret < 0)\n      {\n\tif (errno == ENOSYS || errno == EOPNOTSUPP)\n\t  {\n\t    *must_chmod = true;\n\t    return 0;\n\t  }\n\treturn -1;\n      }\n    return 0;\n  }\n}",
        "lines": 220,
        "depth": 18,
        "decorators": [
          "static",
          "static",
          "int"
        ]
      },
      {
        "start_point": [
          330,
          0
        ],
        "end_point": [
          441,
          1
        ],
        "content": "static int\nset_acls_from_mode (const char *name, int desc, mode_t mode, bool *must_chmod)\n{\n  acl_type_list_t types;\n  size_t types_size = sizeof (types);\n  acl_type_t type;\n\n  if (aclx_gettypes (name, &types, &types_size) < 0\n      || types.num_entries == 0)\n    {\n      *must_chmod = true;\n      return 0;\n    }\n\n  /* XXX Do we need to clear all types of ACLs for the given file, or is it\n     sufficient to clear the first one?  */\n  type = types.entries[0];\n  if (type.u64 == ACL_AIXC)\n    {\n      union { struct acl a; char room[128]; } u;\n      int ret;\n\n      u.a.acl_len = (char *) &u.a.acl_ext[0] - (char *) &u.a; /* no entries */\n      u.a.acl_mode = mode & ~(S_IXACL | 0777);\n      u.a.u_access = (mode >> 6) & 7;\n      u.a.g_access = (mode >> 3) & 7;\n      u.a.o_access = mode & 7;\n\n      if (desc != -1)\n        ret = aclx_fput (desc, SET_ACL | SET_MODE_S_BITS,\n                         type, &u.a, u.a.acl_len, mode);\n      else\n        ret = aclx_put (name, SET_ACL | SET_MODE_S_BITS,\n                        type, &u.a, u.a.acl_len, mode);\n      if (!(ret < 0 && errno == ENOSYS))\n        return ret;\n    }\n  else if (type.u64 == ACL_NFS4)\n    {\n      union { nfs4_acl_int_t a; char room[128]; } u;\n      nfs4_ace_int_t *ace;\n      int ret;\n\n      u.a.aclVersion = NFS4_ACL_INT_STRUCT_VERSION;\n      u.a.aclEntryN = 0;\n      ace = &u.a.aclEntry[0];\n      {\n        ace->flags = ACE4_ID_SPECIAL;\n        ace->aceWho.special_whoid = ACE4_WHO_OWNER;\n        ace->aceType = ACE4_ACCESS_ALLOWED_ACE_TYPE;\n        ace->aceFlags = 0;\n        ace->aceMask =\n          (mode & 0400 ? ACE4_READ_DATA | ACE4_LIST_DIRECTORY : 0)\n          | (mode & 0200\n             ? ACE4_WRITE_DATA | ACE4_ADD_FILE | ACE4_APPEND_DATA\n               | ACE4_ADD_SUBDIRECTORY\n             : 0)\n          | (mode & 0100 ? ACE4_EXECUTE : 0);\n        ace->aceWhoString[0] = '\\0';\n        ace->entryLen = (char *) &ace->aceWhoString[4] - (char *) ace;\n        ace = (nfs4_ace_int_t *) (char *) &ace->aceWhoString[4];\n        u.a.aclEntryN++;\n      }\n      {\n        ace->flags = ACE4_ID_SPECIAL;\n        ace->aceWho.special_whoid = ACE4_WHO_GROUP;\n        ace->aceType = ACE4_ACCESS_ALLOWED_ACE_TYPE;\n        ace->aceFlags = 0;\n        ace->aceMask =\n          (mode & 0040 ? ACE4_READ_DATA | ACE4_LIST_DIRECTORY : 0)\n          | (mode & 0020\n             ? ACE4_WRITE_DATA | ACE4_ADD_FILE | ACE4_APPEND_DATA\n               | ACE4_ADD_SUBDIRECTORY\n             : 0)\n          | (mode & 0010 ? ACE4_EXECUTE : 0);\n        ace->aceWhoString[0] = '\\0';\n        ace->entryLen = (char *) &ace->aceWhoString[4] - (char *) ace;\n        ace = (nfs4_ace_int_t *) (char *) &ace->aceWhoString[4];\n        u.a.aclEntryN++;\n      }\n      {\n        ace->flags = ACE4_ID_SPECIAL;\n        ace->aceWho.special_whoid = ACE4_WHO_EVERYONE;\n        ace->aceType = ACE4_ACCESS_ALLOWED_ACE_TYPE;\n        ace->aceFlags = 0;\n        ace->aceMask =\n          (mode & 0004 ? ACE4_READ_DATA | ACE4_LIST_DIRECTORY : 0)\n          | (mode & 0002\n             ? ACE4_WRITE_DATA | ACE4_ADD_FILE | ACE4_APPEND_DATA\n               | ACE4_ADD_SUBDIRECTORY\n             : 0)\n          | (mode & 0001 ? ACE4_EXECUTE : 0);\n        ace->aceWhoString[0] = '\\0';\n        ace->entryLen = (char *) &ace->aceWhoString[4] - (char *) ace;\n        ace = (nfs4_ace_int_t *) (char *) &ace->aceWhoString[4];\n        u.a.aclEntryN++;\n      }\n      u.a.aclLength = (char *) ace - (char *) &u.a;\n\n      if (desc != -1)\n        ret = aclx_fput (desc, SET_ACL | SET_MODE_S_BITS,\n                         type, &u.a, u.a.aclLength, mode);\n      else\n        ret = aclx_put (name, SET_ACL | SET_MODE_S_BITS,\n                        type, &u.a, u.a.aclLength, mode);\n      if (!(ret < 0 && errno == ENOSYS))\n        return ret;\n    }\n\n  *must_chmod = true;\n  return 0;\n}",
        "lines": 112,
        "depth": 16,
        "decorators": [
          "static",
          "static",
          "int"
        ]
      }
    ],
    "context_acl_from_mode": [
      {
        "start_point": [
          276,
          0
        ],
        "end_point": [
          300,
          1
        ],
        "content": "static int\ncontext_acl_from_mode (struct permission_context *ctx, const char *name, int desc)\n{\n  struct stat statbuf;\n  int ret;\n\n  if (desc != -1)\n    ret = fstat (desc, &statbuf);\n  else\n    ret = stat (name, &statbuf);\n  if (ret < 0)\n    return -1;\n\n  ctx->entries[0].uid = statbuf.st_uid;\n  ctx->entries[0].gid = ACL_NSGROUP;\n  ctx->entries[0].mode = (ctx->mode >> 6) & 7;\n  ctx->entries[1].uid = ACL_NSUSER;\n  ctx->entries[1].gid = statbuf.st_gid;\n  ctx->entries[1].mode = (ctx->mode >> 3) & 7;\n  ctx->entries[2].uid = ACL_NSUSER;\n  ctx->entries[2].gid = ACL_NSGROUP;\n  ctx->entries[2].mode = ctx->mode & 7;\n  ctx->count = 3;\n  return 0;\n}",
        "lines": 25,
        "depth": 9,
        "decorators": [
          "static",
          "static",
          "int"
        ]
      },
      {
        "start_point": [
          444,
          0
        ],
        "end_point": [
          454,
          1
        ],
        "content": "static int\ncontext_acl_from_mode (struct permission_context *ctx)\n{\n  ctx->u.a.acl_len = (char *) &ctx->u.a.acl_ext[0] - (char *) &ctx->u.a; /* no entries */\n  ctx->u.a.acl_mode = ctx->mode & ~(S_IXACL | 0777);\n  ctx->u.a.u_access = (ctx->mode >> 6) & 7;\n  ctx->u.a.g_access = (ctx->mode >> 3) & 7;\n  ctx->u.a.o_access = ctx->mode & 7;\n  ctx->have_u = true;\n  return 0;\n}",
        "lines": 11,
        "depth": 12,
        "decorators": [
          "static",
          "static",
          "int"
        ]
      },
      {
        "start_point": [
          457,
          0
        ],
        "end_point": [
          480,
          1
        ],
        "content": "static int\ncontext_acl_from_mode (struct permission_context *ctx)\n{\n  int ret;\n\n  ctx->entries[0].a_type = USER_OBJ;\n  ctx->entries[0].a_id = 0; /* irrelevant */\n  ctx->entries[0].a_perm = (ctx->mode >> 6) & 7;\n  ctx->entries[1].a_type = GROUP_OBJ;\n  ctx->entries[1].a_id = 0; /* irrelevant */\n  ctx->entries[1].a_perm = (ctx->mode >> 3) & 7;\n  ctx->entries[2].a_type = CLASS_OBJ;\n  ctx->entries[2].a_id = 0;\n  ctx->entries[2].a_perm = (ctx->mode >> 3) & 7;\n  ctx->entries[3].a_type = OTHER_OBJ;\n  ctx->entries[3].a_id = 0;\n  ctx->entries[3].a_perm = ctx->mode & 7;\n  ctx->count = 4;\n\n  ret = aclsort (ctx->count, 1, entries);\n  if (ret > 0)\n    abort ();\n  return ret;\n}",
        "lines": 24,
        "depth": 9,
        "decorators": [
          "static",
          "static",
          "int"
        ]
      }
    ],
    "context_aclv_from_mode": {
      "start_point": [
        303,
        0
      ],
      "end_point": [
        326,
        1
      ],
      "content": "static int\ncontext_aclv_from_mode (struct permission_context *ctx)\n{\n  int ret;\n\n  ctx->aclv_entries[0].a_type = USER_OBJ;\n  ctx->aclv_entries[0].a_id = 0; /* irrelevant */\n  ctx->aclv_entries[0].a_perm = (ctx->mode >> 6) & 7;\n  ctx->aclv_entries[1].a_type = GROUP_OBJ;\n  ctx->aclv_entries[1].a_id = 0; /* irrelevant */\n  ctx->aclv_entries[1].a_perm = (ctx->mode >> 3) & 7;\n  ctx->aclv_entries[2].a_type = CLASS_OBJ;\n  ctx->aclv_entries[2].a_id = 0;\n  ctx->aclv_entries[2].a_perm = (ctx->mode >> 3) & 7;\n  ctx->aclv_entries[3].a_type = OTHER_OBJ;\n  ctx->aclv_entries[3].a_id = 0;\n  ctx->aclv_entries[3].a_perm = ctx->mode & 7;\n  ctx->aclv_count = 4;\n\n  ret = aclsort (ctx->aclv_count, 1, ctx->aclv_entries);\n  if (ret > 0)\n    abort ();\n  return ret;\n}",
      "lines": 24,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "set_acls": {
      "start_point": [
        483,
        0
      ],
      "end_point": [
        749,
        1
      ],
      "content": "static int\nset_acls (struct permission_context *ctx, const char *name, int desc,\n\t  int from_mode, bool *must_chmod, bool *acls_set)\n{\n  int ret = 0;\n\n# if HAVE_ACL_GET_FILE\n  /* POSIX 1003.1e (draft 17 -- abandoned) specific version.  */\n  /* Linux, FreeBSD, Mac OS X, IRIX, Tru64 */\n#  if !HAVE_ACL_TYPE_EXTENDED\n  /* Linux, FreeBSD, IRIX, Tru64 */\n\n#   ifndef HAVE_ACL_FROM_TEXT\n#    error Must have acl_from_text (see POSIX 1003.1e draft 17).\n#   endif\n#   ifndef HAVE_ACL_DELETE_DEF_FILE\n#    error Must have acl_delete_def_file (see POSIX 1003.1e draft 17).\n#   endif\n\n  if (! ctx->acls_not_supported)\n    {\n      if (ret == 0 && from_mode)\n\t{\n\t  if (ctx->acl)\n\t    acl_free (ctx->acl);\n\t  ctx->acl = acl_from_mode (ctx->mode);\n\t  if (ctx->acl == NULL)\n\t    ret = -1;\n\t}\n\n      if (ret == 0 && ctx->acl)\n\t{\n\t  if (HAVE_ACL_SET_FD && desc != -1)\n\t    ret = acl_set_fd (desc, ctx->acl);\n\t  else\n\t    ret = acl_set_file (name, ACL_TYPE_ACCESS, ctx->acl);\n\t  if (ret != 0)\n\t    {\n\t      if (! acl_errno_valid (errno))\n\t\t{\n\t\t  ctx->acls_not_supported = true;\n\t\t  if (from_mode || acl_access_nontrivial (ctx->acl) == 0)\n\t\t    ret = 0;\n\t\t}\n\t    }\n\t  else\n\t    {\n\t      *acls_set = true;\n\t      if (S_ISDIR(ctx->mode))\n\t\t{\n\t\t  if (! from_mode && ctx->default_acl &&\n\t\t      acl_default_nontrivial (ctx->default_acl))\n\t\t    ret = acl_set_file (name, ACL_TYPE_DEFAULT,\n\t\t\t\t\tctx->default_acl);\n\t\t  else\n\t\t    ret = acl_delete_def_file (name);\n\t\t}\n\t    }\n\t}\n    }\n\n# if HAVE_ACL_TYPE_NFS4  /* FreeBSD */\n\n  /* File systems either support POSIX ACLs (for example, ufs) or NFS4 ACLs\n     (for example, zfs). */\n\n  /* TODO: Implement setting ACLs once get_permissions() reads them. */\n\n# endif\n\n#  else /* HAVE_ACL_TYPE_EXTENDED */\n  /* Mac OS X */\n\n  /* On Mac OS X,  acl_get_file (name, ACL_TYPE_ACCESS)\n     and           acl_get_file (name, ACL_TYPE_DEFAULT)\n     always return NULL / EINVAL.  You have to use\n                   acl_get_file (name, ACL_TYPE_EXTENDED)\n     or            acl_get_fd (open (name, ...))\n     to retrieve an ACL.\n     On the other hand,\n                   acl_set_file (name, ACL_TYPE_ACCESS, acl)\n     and           acl_set_file (name, ACL_TYPE_DEFAULT, acl)\n     have the same effect as\n                   acl_set_file (name, ACL_TYPE_EXTENDED, acl):\n     Each of these calls sets the file's ACL.  */\n\n  if (ctx->acl == NULL)\n    {\n      acl_t acl;\n\n      /* Remove ACLs if the file has ACLs.  */\n      if (HAVE_ACL_GET_FD && desc != -1)\n\tacl = acl_get_fd (desc);\n      else\n\tacl = acl_get_file (name, ACL_TYPE_EXTENDED);\n      if (acl)\n\t{\n\t  acl_free (acl);\n\n\t  acl = acl_init (0);\n\t  if (acl)\n\t    {\n\t      if (HAVE_ACL_SET_FD && desc != -1)\n\t\tret = acl_set_fd (desc, acl);\n\t      else\n\t\tret = acl_set_file (name, ACL_TYPE_EXTENDED, acl);\n\t      acl_free (acl);\n\t    }\n\t  else\n\t    ret = -1;\n\t}\n    }\n  else\n    {\n      if (HAVE_ACL_SET_FD && desc != -1)\n\tret = acl_set_fd (desc, ctx->acl);\n      else\n\tret = acl_set_file (name, ACL_TYPE_EXTENDED, ctx->acl);\n      if (ret != 0)\n\t{\n\t  if (! acl_errno_valid (errno)\n\t      && ! acl_extended_nontrivial (ctx->acl))\n\t    ret = 0;\n\t}\n    }\n  *acls_set = true;\n\n#  endif\n\n# elif defined GETACL /* Solaris, Cygwin, not HP-UX */\n\n  /* Solaris 2.5 through Solaris 10, Cygwin, and contemporaneous versions\n     of Unixware.  The acl() call returns the access and default ACL both\n     at once.  */\n\n  /* If both ace_entries and entries are available, try SETACL before\n     ACE_SETACL, because SETACL cannot fail with ENOTSUP whereas ACE_SETACL\n     can.  */\n\n  if (from_mode)\n    return set_acls_from_mode (name, desc, ctx->mode, must_chmod);\n\n  if (ret == 0 && ctx->count)\n    {\n      if (desc != -1)\n\tret = facl (desc, SETACL, ctx->count, ctx->entries);\n      else\n\tret = acl (name, SETACL, ctx->count, ctx->entries);\n      if (ret < 0)\n\t{\n\t  if ((errno == ENOSYS || errno == EOPNOTSUPP || errno == EINVAL)\n\t      && acl_nontrivial (ctx->count, ctx->entries) == 0)\n\t    ret = 0;\n\t}\n      else\n\t*acls_set = true;\n    }\n\n#  ifdef ACE_GETACL\n  if (ret == 0 && ctx->ace_count)\n    {\n      if (desc != -1)\n\tret = facl (desc, ACE_SETACL, ctx->ace_count, ctx->ace_entries);\n      else\n\tret = acl (name, ACE_SETACL, ctx->ace_count, ctx->ace_entries);\n      if (ret < 0)\n\t{\n\t  if ((errno == ENOSYS || errno == EINVAL || errno == ENOTSUP)\n\t      && acl_ace_nontrivial (ctx->ace_count, ctx->ace_entries) == 0)\n\t    ret = 0;\n\t}\n      else\n\t*acls_set = true;\n    }\n#  endif\n\n# elif HAVE_GETACL /* HP-UX */\n\n  if (from_mode)\n    ret = context_acl_from_mode (ctx, name, desc);\n\n  if (ret == 0 && ctx->count > 0)\n    {\n      if (desc != -1)\n\tret = fsetacl (desc, ctx->count, ctx->entries);\n      else\n\tret = setacl (name, ctx->count, ctx->entries);\n      if (ret < 0)\n\t{\n\t  if ((errno == ENOSYS || errno == EOPNOTSUPP || errno == ENOTSUP)\n\t      && (from_mode || !acl_nontrivial (ctx->count, ctx->entries)))\n\t    ret = 0;\n\t}\n      else\n\t*acls_set = true;\n    }\n\n#  if HAVE_ACLV_H\n  if (from_mode)\n    ret = context_aclv_from_mode (ctx);\n\n  if (ret == 0 && ctx->aclv_count > 0)\n    {\n      ret = acl ((char *) name, ACL_SET, ctx->aclv_count, ctx->aclv_entries);\n      if (ret < 0)\n\t{\n\t  if ((errno == ENOSYS || errno == EOPNOTSUPP || errno == EINVAL)\n\t      && (from_mode || !aclv_nontrivial (ctx->aclv_count, ctx->aclv_entries)))\n\t    ret = 0;\n\t}\n      else\n\t*acls_set = true;\n    }\n#  endif\n\n# elif HAVE_ACLX_GET && ACL_AIX_WIP /* AIX */\n\n  /* TODO: Implement setting ACLs once get_permissions() reads them. */\n\n  if (from_mode)\n    ret = set_acls_from_mode (name, desc, mode, must_chmod);\n\n# elif HAVE_STATACL /* older AIX */\n\n  if (from_mode)\n    ret = context_acl_from_mode (ctx);\n\n  if (ret == 0 && ctx->have_u)\n    {\n      if (desc != -1)\n\tret = fchacl (desc, &ctx->u.a, ctx->u.a.acl_len);\n      else\n\tret = chacl ((char *) name, &ctx->u.a, ctx->u.a.acl_len);\n      if (ret < 0)\n\t{\n\t  if (errno == ENOSYS && from_mode)\n\t    ret = 0;\n\t}\n      else\n\t*acls_set = true;\n    }\n\n# elif HAVE_ACLSORT /* NonStop Kernel */\n\n  if (from_mode)\n    ret = context_acl_from_mode (ctx);\n\n  if (ret == 0 && ctx->count)\n    {\n      ret = acl ((char *) name, ACL_SET, ctx->count, ctx->entries);\n      if (ret != 0)\n\t{\n\t  if (!acl_nontrivial (ctx->count, ctx->entries))\n\t    ret = 0;\n\t}\n      else\n\t*acls_set = true;\n    }\n\n# else  /* No ACLs */\n\n  /* Nothing to do. */\n\n# endif\n\n  return ret;\n}",
      "lines": 267,
      "depth": 20,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "chmod_or_fchmod": {
      "start_point": [
        758,
        0
      ],
      "end_point": [
        765,
        1
      ],
      "content": "int\nchmod_or_fchmod (const char *name, int desc, mode_t mode)\n{\n  if (HAVE_FCHMOD && desc != -1)\n    return fchmod (desc, mode);\n  else\n    return chmod (name, mode);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "set_permissions": {
      "start_point": [
        774,
        0
      ],
      "end_point": [
        846,
        1
      ],
      "content": "int\nset_permissions (struct permission_context *ctx, const char *name, int desc)\n{\n  bool acls_set _GL_UNUSED = false;\n  bool early_chmod;\n  bool must_chmod = false;\n  int ret = 0;\n\n#if USE_ACL\n# if HAVE_STATACL\n  /* older AIX */\n  /* There is no need to call chmod_or_fchmod, since the mode\n     bits S_ISUID, S_ISGID, S_ISVTX are also stored in the ACL.  */\n\n  early_chmod = false;\n# else\n  /* All other platforms */\n  /* On Cygwin, it is necessary to call chmod before acl, because\n     chmod can change the contents of the ACL (in ways that don't\n     change the allowed accesses, but still visible).  */\n\n  early_chmod = (! MODE_INSIDE_ACL || (ctx->mode & (S_ISUID | S_ISGID | S_ISVTX)));\n# endif\n#else\n  /* No ACLs */\n\n  early_chmod = true;\n#endif\n\n  if (early_chmod)\n    {\n      ret = chmod_or_fchmod (name, desc, ctx->mode);\n      if (ret != 0)\n\treturn -1;\n    }\n\n#if USE_ACL\n  ret = set_acls (ctx, name, desc, false, &must_chmod, &acls_set);\n  if (! acls_set)\n    {\n      int saved_errno = ret ? errno : 0;\n\n      /* If we can't set an acl which we expect to be able to set, try setting\n\t the permissions to ctx->mode. Due to possible inherited permissions,\n\t we cannot simply chmod.  */\n\n      ret = set_acls (ctx, name, desc, true, &must_chmod, &acls_set);\n      if (! acls_set)\n\tmust_chmod = true;\n\n      if (saved_errno)\n\t{\n\t  errno = saved_errno;\n\t  ret = -1;\n\t}\n    }\n#endif\n\n  if (must_chmod && ! early_chmod)\n    {\n      int saved_errno = ret ? errno : 0;\n\n      ret = chmod_or_fchmod (name, desc, ctx->mode);\n\n      if (saved_errno)\n\t{\n\t  errno = saved_errno;\n\t  ret = -1;\n\t}\n    }\n\n  return ret;\n}",
      "lines": 73,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/lib/stat-macros.h": {},
  "sed/sed-4.5/lib/stat-time.c": {},
  "sed/sed-4.5/lib/stat-time.h": {
    "get_stat_atime_ns": {
      "start_point": [
        64,
        26
      ],
      "end_point": [
        74,
        1
      ],
      "content": "int _GL_ATTRIBUTE_PURE\nget_stat_atime_ns (struct stat const *st)\n{\n# if defined STAT_TIMESPEC\n  return STAT_TIMESPEC (st, st_atim).tv_nsec;\n# elif defined STAT_TIMESPEC_NS\n  return STAT_TIMESPEC_NS (st, st_atim);\n# else\n  return 0;\n# endif\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "int",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "get_stat_ctime_ns": {
      "start_point": [
        77,
        26
      ],
      "end_point": [
        87,
        1
      ],
      "content": "int _GL_ATTRIBUTE_PURE\nget_stat_ctime_ns (struct stat const *st)\n{\n# if defined STAT_TIMESPEC\n  return STAT_TIMESPEC (st, st_ctim).tv_nsec;\n# elif defined STAT_TIMESPEC_NS\n  return STAT_TIMESPEC_NS (st, st_ctim);\n# else\n  return 0;\n# endif\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "int",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "get_stat_mtime_ns": {
      "start_point": [
        90,
        26
      ],
      "end_point": [
        100,
        1
      ],
      "content": "int _GL_ATTRIBUTE_PURE\nget_stat_mtime_ns (struct stat const *st)\n{\n# if defined STAT_TIMESPEC\n  return STAT_TIMESPEC (st, st_mtim).tv_nsec;\n# elif defined STAT_TIMESPEC_NS\n  return STAT_TIMESPEC_NS (st, st_mtim);\n# else\n  return 0;\n# endif\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "int",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "get_stat_birthtime_ns": {
      "start_point": [
        103,
        26
      ],
      "end_point": [
        113,
        1
      ],
      "content": "int _GL_ATTRIBUTE_PURE\nget_stat_birthtime_ns (struct stat const *st _GL_UNUSED)\n{\n# if defined HAVE_STRUCT_STAT_ST_BIRTHTIMESPEC_TV_NSEC\n  return STAT_TIMESPEC (st, st_birthtim).tv_nsec;\n# elif defined HAVE_STRUCT_STAT_ST_BIRTHTIMENSEC\n  return STAT_TIMESPEC_NS (st, st_birthtim);\n# else\n  return 0;\n# endif\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "int",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "get_stat_atime": {
      "start_point": [
        116,
        28
      ],
      "end_point": [
        127,
        1
      ],
      "content": "timespec _GL_ATTRIBUTE_PURE\nget_stat_atime (struct stat const *st)\n{\n#ifdef STAT_TIMESPEC\n  return STAT_TIMESPEC (st, st_atim);\n#else\n  struct timespec t;\n  t.tv_sec = st->st_atime;\n  t.tv_nsec = get_stat_atime_ns (st);\n  return t;\n#endif\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "timespec",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "get_stat_ctime": {
      "start_point": [
        130,
        28
      ],
      "end_point": [
        141,
        1
      ],
      "content": "timespec _GL_ATTRIBUTE_PURE\nget_stat_ctime (struct stat const *st)\n{\n#ifdef STAT_TIMESPEC\n  return STAT_TIMESPEC (st, st_ctim);\n#else\n  struct timespec t;\n  t.tv_sec = st->st_ctime;\n  t.tv_nsec = get_stat_ctime_ns (st);\n  return t;\n#endif\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "timespec",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "get_stat_mtime": {
      "start_point": [
        144,
        28
      ],
      "end_point": [
        155,
        1
      ],
      "content": "timespec _GL_ATTRIBUTE_PURE\nget_stat_mtime (struct stat const *st)\n{\n#ifdef STAT_TIMESPEC\n  return STAT_TIMESPEC (st, st_mtim);\n#else\n  struct timespec t;\n  t.tv_sec = st->st_mtime;\n  t.tv_nsec = get_stat_mtime_ns (st);\n  return t;\n#endif\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "timespec",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "get_stat_birthtime": {
      "start_point": [
        159,
        28
      ],
      "end_point": [
        202,
        1
      ],
      "content": "timespec _GL_ATTRIBUTE_PURE\nget_stat_birthtime (struct stat const *st _GL_UNUSED)\n{\n  struct timespec t;\n\n#if (defined HAVE_STRUCT_STAT_ST_BIRTHTIMESPEC_TV_NSEC \\\n     || defined HAVE_STRUCT_STAT_ST_BIRTHTIM_TV_NSEC)\n  t = STAT_TIMESPEC (st, st_birthtim);\n#elif defined HAVE_STRUCT_STAT_ST_BIRTHTIMENSEC\n  t.tv_sec = st->st_birthtime;\n  t.tv_nsec = st->st_birthtimensec;\n#elif (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n  /* Native Windows platforms (but not Cygwin) put the \"file creation\n     time\" in st_ctime (!).  See\n     <https://msdn.microsoft.com/en-us/library/14h5k7ff(VS.80).aspx>.  */\n# if _GL_WINDOWS_STAT_TIMESPEC\n  t = st->st_ctim;\n# else\n  t.tv_sec = st->st_ctime;\n  t.tv_nsec = 0;\n# endif\n#else\n  /* Birth time is not supported.  */\n  t.tv_sec = -1;\n  t.tv_nsec = -1;\n#endif\n\n#if (defined HAVE_STRUCT_STAT_ST_BIRTHTIMESPEC_TV_NSEC \\\n     || defined HAVE_STRUCT_STAT_ST_BIRTHTIM_TV_NSEC \\\n     || defined HAVE_STRUCT_STAT_ST_BIRTHTIMENSEC)\n  /* FreeBSD and NetBSD sometimes signal the absence of knowledge by\n     using zero.  Attempt to work around this problem.  Alas, this can\n     report failure even for valid timestamps.  Also, NetBSD\n     sometimes returns junk in the birth time fields; work around this\n     bug if it is detected.  */\n  if (! (t.tv_sec && 0 <= t.tv_nsec && t.tv_nsec < 1000000000))\n    {\n      t.tv_sec = -1;\n      t.tv_nsec = -1;\n    }\n#endif\n\n  return t;\n}",
      "lines": 44,
      "depth": 12,
      "decorators": [
        "timespec",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "stat_time_normalize": {
      "start_point": [
        209,
        0
      ],
      "end_point": [
        243,
        1
      ],
      "content": "_GL_STAT_TIME_INLINE int\nstat_time_normalize (int result, struct stat *st _GL_UNUSED)\n{\n#if defined __sun && defined STAT_TIMESPEC\n  if (result == 0)\n    {\n      long int timespec_resolution = 1000000000;\n      short int const ts_off[] = { offsetof (struct stat, st_atim),\n                                   offsetof (struct stat, st_mtim),\n                                   offsetof (struct stat, st_ctim) };\n      int i;\n      for (i = 0; i < sizeof ts_off / sizeof *ts_off; i++)\n        {\n          struct timespec *ts = (struct timespec *) ((char *) st + ts_off[i]);\n          long int q = ts->tv_nsec / timespec_resolution;\n          long int r = ts->tv_nsec % timespec_resolution;\n          if (r < 0)\n            {\n              r += timespec_resolution;\n              q--;\n            }\n          ts->tv_nsec = r;\n          /* Overflow is possible, as Solaris 11 stat can yield\n             tv_sec == TYPE_MINIMUM (time_t) && tv_nsec == -1000000000.\n             INT_ADD_WRAPV is OK, since time_t is signed on Solaris.  */\n          if (INT_ADD_WRAPV (q, ts->tv_sec, &ts->tv_sec))\n            {\n              errno = EOVERFLOW;\n              return -1;\n            }\n        }\n    }\n#endif\n  return result;\n}",
      "lines": 35,
      "depth": 16,
      "decorators": [
        "_GL_STAT_TIME_INLINE",
        "int",
        "int"
      ]
    }
  },
  "sed/sed-4.5/lib/stat-w32.c": {
    "initialize": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "static void\ninitialize (void)\n{\n  HMODULE kernel32 = LoadLibrary (\"kernel32.dll\");\n  if (kernel32 != NULL)\n    {\n#if _GL_WINDOWS_STAT_INODES == 2\n      GetFileInformationByHandleExFunc =\n        (GetFileInformationByHandleExFuncType) GetProcAddress (kernel32, \"GetFileInformationByHandleEx\");\n#endif\n      GetFinalPathNameByHandleFunc =\n        (GetFinalPathNameByHandleFuncType) GetProcAddress (kernel32, \"GetFinalPathNameByHandleA\");\n    }\n  initialized = TRUE;\n}",
      "lines": 15,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "_gl_convert_FILETIME_to_timespec": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        97,
        1
      ],
      "content": "struct timespec\n_gl_convert_FILETIME_to_timespec (const FILETIME *ft)\n{\n  struct timespec result;\n  /* FILETIME: <https://msdn.microsoft.com/en-us/library/ms724284.aspx> */\n  unsigned long long since_1601 =\n    ((unsigned long long) ft->dwHighDateTime << 32)\n    | (unsigned long long) ft->dwLowDateTime;\n  if (since_1601 == 0)\n    {\n      result.tv_sec = 0;\n      result.tv_nsec = 0;\n    }\n  else\n    {\n      /* Between 1601-01-01 and 1970-01-01 there were 280 normal years and 89\n         leap years, in total 134774 days.  */\n      unsigned long long since_1970 =\n        since_1601 - (unsigned long long) 134774 * (unsigned long long) 86400 * (unsigned long long) 10000000;\n      result.tv_sec = since_1970 / (unsigned long long) 10000000;\n      result.tv_nsec = (unsigned long) (since_1970 % (unsigned long long) 10000000) * 100;\n    }\n  return result;\n}",
      "lines": 24,
      "depth": 14,
      "decorators": [
        "struct timespec",
        "struct",
        "timespec"
      ]
    },
    "_gl_convert_FILETIME_to_POSIX": {
      "start_point": [
        99,
        0
      ],
      "end_point": [
        116,
        1
      ],
      "content": "time_t\n_gl_convert_FILETIME_to_POSIX (const FILETIME *ft)\n{\n  /* FILETIME: <https://msdn.microsoft.com/en-us/library/ms724284.aspx> */\n  unsigned long long since_1601 =\n    ((unsigned long long) ft->dwHighDateTime << 32)\n    | (unsigned long long) ft->dwLowDateTime;\n  if (since_1601 == 0)\n    return 0;\n  else\n    {\n      /* Between 1601-01-01 and 1970-01-01 there were 280 normal years and 89\n         leap years, in total 134774 days.  */\n      unsigned long long since_1970 =\n        since_1601 - (unsigned long long) 134774 * (unsigned long long) 86400 * (unsigned long long) 10000000;\n      return since_1970 / (unsigned long long) 10000000;\n    }\n}",
      "lines": 18,
      "depth": 13,
      "decorators": [
        "time_t"
      ]
    },
    "_gl_fstat_by_handle": {
      "start_point": [
        122,
        0
      ],
      "end_point": [
        412,
        1
      ],
      "content": "int\n_gl_fstat_by_handle (HANDLE h, const char *path, struct stat *buf)\n{\n  /* GetFileType\n     <https://msdn.microsoft.com/en-us/library/aa364960.aspx> */\n  DWORD type = GetFileType (h);\n  if (type == FILE_TYPE_DISK)\n    {\n      if (!initialized)\n        initialize ();\n\n      /* st_mode can be determined through\n         GetFileAttributesEx\n         <https://msdn.microsoft.com/en-us/library/aa364946.aspx>\n         <https://msdn.microsoft.com/en-us/library/aa365739.aspx>\n         or through\n         GetFileInformationByHandle\n         <https://msdn.microsoft.com/en-us/library/aa364952.aspx>\n         <https://msdn.microsoft.com/en-us/library/aa363788.aspx>\n         or through\n         GetFileInformationByHandleEx with argument FileBasicInfo\n         <https://msdn.microsoft.com/en-us/library/aa364953.aspx>\n         <https://msdn.microsoft.com/en-us/library/aa364217.aspx>\n         The latter requires -D_WIN32_WINNT=_WIN32_WINNT_VISTA or higher.  */\n      BY_HANDLE_FILE_INFORMATION info;\n      if (! GetFileInformationByHandle (h, &info))\n        goto failed;\n\n      /* Test for error conditions before starting to fill *buf.  */\n      if (sizeof (buf->st_size) <= 4 && info.nFileSizeHigh > 0)\n        {\n          errno = EOVERFLOW;\n          return -1;\n        }\n\n#if _GL_WINDOWS_STAT_INODES\n      /* st_ino can be determined through\n         GetFileInformationByHandle\n         <https://msdn.microsoft.com/en-us/library/aa364952.aspx>\n         <https://msdn.microsoft.com/en-us/library/aa363788.aspx>\n         as 64 bits, or through\n         GetFileInformationByHandleEx with argument FileIdInfo\n         <https://msdn.microsoft.com/en-us/library/aa364953.aspx>\n         <https://msdn.microsoft.com/en-us/library/hh802691.aspx>\n         as 128 bits.\n         The latter requires -D_WIN32_WINNT=_WIN32_WINNT_WIN8 or higher.  */\n      /* Experiments show that GetFileInformationByHandleEx does not provide\n         much more information than GetFileInformationByHandle:\n           * The dwVolumeSerialNumber from GetFileInformationByHandle is equal\n             to the low 32 bits of the 64-bit VolumeSerialNumber from\n             GetFileInformationByHandleEx, and is apparently sufficient for\n             identifying the device.\n           * The nFileIndex from GetFileInformationByHandle is equal to the low\n             64 bits of the 128-bit FileId from GetFileInformationByHandleEx,\n             and the high 64 bits of this 128-bit FileId are zero.\n           * On a FAT file system, GetFileInformationByHandleEx fails with error\n             ERROR_INVALID_PARAMETER, whereas GetFileInformationByHandle\n             succeeds.\n           * On a CIFS/SMB file system, GetFileInformationByHandleEx fails with\n             error ERROR_INVALID_LEVEL, whereas GetFileInformationByHandle\n             succeeds.  */\n# if _GL_WINDOWS_STAT_INODES == 2\n      if (GetFileInformationByHandleExFunc != NULL)\n        {\n          FILE_ID_INFO id;\n          if (GetFileInformationByHandleExFunc (h, FileIdInfo, &id, sizeof (id)))\n            {\n              buf->st_dev = id.VolumeSerialNumber;\n              verify (sizeof (ino_t) == sizeof (id.FileId));\n              memcpy (&buf->st_ino, &id.FileId, sizeof (ino_t));\n              goto ino_done;\n            }\n          else\n            {\n              switch (GetLastError ())\n                {\n                case ERROR_INVALID_PARAMETER: /* older Windows version, or FAT */\n                case ERROR_INVALID_LEVEL: /* CIFS/SMB file system */\n                  goto fallback;\n                default:\n                  goto failed;\n                }\n            }\n        }\n     fallback: ;\n      /* Fallback for older Windows versions.  */\n      buf->st_dev = info.dwVolumeSerialNumber;\n      buf->st_ino._gl_ino[0] = ((ULONGLONG) info.nFileIndexHigh << 32) | (ULONGLONG) info.nFileIndexLow;\n      buf->st_ino._gl_ino[1] = 0;\n     ino_done: ;\n# else /* _GL_WINDOWS_STAT_INODES == 1 */\n      buf->st_dev = info.dwVolumeSerialNumber;\n      buf->st_ino = ((ULONGLONG) info.nFileIndexHigh << 32) | (ULONGLONG) info.nFileIndexLow;\n# endif\n#else\n      /* st_ino is not wide enough for identifying a file on a device.\n         Without st_ino, st_dev is pointless.  */\n      buf->st_dev = 0;\n      buf->st_ino = 0;\n#endif\n\n      /* st_mode.  */\n      unsigned int mode =\n        /* XXX How to handle FILE_ATTRIBUTE_REPARSE_POINT ?  */\n        ((info.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ? _S_IFDIR | S_IEXEC_UGO : _S_IFREG)\n        | S_IREAD_UGO\n        | ((info.dwFileAttributes & FILE_ATTRIBUTE_READONLY) ? 0 : S_IWRITE_UGO);\n      if (!(info.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))\n        {\n          /* Determine whether the file is executable by looking at the file\n             name suffix.\n             If the file name is already known, use it. Otherwise, for\n             non-empty files, it can be determined through\n             GetFinalPathNameByHandle\n             <https://msdn.microsoft.com/en-us/library/aa364962.aspx>\n             or through\n             GetFileInformationByHandleEx with argument FileNameInfo\n             <https://msdn.microsoft.com/en-us/library/aa364953.aspx>\n             <https://msdn.microsoft.com/en-us/library/aa364388.aspx>\n             Both require -D_WIN32_WINNT=_WIN32_WINNT_VISTA or higher.  */\n          if (info.nFileSizeHigh > 0 || info.nFileSizeLow > 0)\n            {\n              char fpath[PATH_MAX];\n              if (path != NULL\n                  || (GetFinalPathNameByHandleFunc != NULL\n                      && GetFinalPathNameByHandleFunc (h, fpath, sizeof (fpath), VOLUME_NAME_NONE)\n                         < sizeof (fpath)\n                      && (path = fpath, 1)))\n                {\n                  const char *last_dot = NULL;\n                  const char *p;\n                  for (p = path; *p != '\\0'; p++)\n                    if (*p == '.')\n                      last_dot = p;\n                  if (last_dot != NULL)\n                    {\n                      const char *suffix = last_dot + 1;\n                      if (_stricmp (suffix, \"exe\") == 0\n                          || _stricmp (suffix, \"bat\") == 0\n                          || _stricmp (suffix, \"cmd\") == 0\n                          || _stricmp (suffix, \"com\") == 0)\n                        mode |= S_IEXEC_UGO;\n                    }\n                }\n              else\n                /* Cannot determine file name.  Pretend that it is executable.  */\n                mode |= S_IEXEC_UGO;\n            }\n        }\n      buf->st_mode = mode;\n\n      /* st_nlink can be determined through\n         GetFileInformationByHandle\n         <https://msdn.microsoft.com/en-us/library/aa364952.aspx>\n         <https://msdn.microsoft.com/en-us/library/aa363788.aspx>\n         or through\n         GetFileInformationByHandleEx with argument FileStandardInfo\n         <https://msdn.microsoft.com/en-us/library/aa364953.aspx>\n         <https://msdn.microsoft.com/en-us/library/aa364401.aspx>\n         The latter requires -D_WIN32_WINNT=_WIN32_WINNT_VISTA or higher.  */\n      buf->st_nlink = (info.nNumberOfLinks > SHRT_MAX ? SHRT_MAX : info.nNumberOfLinks);\n\n      /* There's no easy way to map the Windows SID concept to an integer.  */\n      buf->st_uid = 0;\n      buf->st_gid = 0;\n\n      /* st_rdev is irrelevant for normal files and directories.  */\n      buf->st_rdev = 0;\n\n      /* st_size can be determined through\n         GetFileSizeEx\n         <https://msdn.microsoft.com/en-us/library/aa364957.aspx>\n         or through\n         GetFileAttributesEx\n         <https://msdn.microsoft.com/en-us/library/aa364946.aspx>\n         <https://msdn.microsoft.com/en-us/library/aa365739.aspx>\n         or through\n         GetFileInformationByHandle\n         <https://msdn.microsoft.com/en-us/library/aa364952.aspx>\n         <https://msdn.microsoft.com/en-us/library/aa363788.aspx>\n         or through\n         GetFileInformationByHandleEx with argument FileStandardInfo\n         <https://msdn.microsoft.com/en-us/library/aa364953.aspx>\n         <https://msdn.microsoft.com/en-us/library/aa364401.aspx>\n         The latter requires -D_WIN32_WINNT=_WIN32_WINNT_VISTA or higher.  */\n      if (sizeof (buf->st_size) <= 4)\n        /* Range check already done above.  */\n        buf->st_size = info.nFileSizeLow;\n      else\n        buf->st_size = ((long long) info.nFileSizeHigh << 32) | (long long) info.nFileSizeLow;\n\n      /* st_atime, st_mtime, st_ctime can be determined through\n         GetFileTime\n         <https://msdn.microsoft.com/en-us/library/ms724320.aspx>\n         or through\n         GetFileAttributesEx\n         <https://msdn.microsoft.com/en-us/library/aa364946.aspx>\n         <https://msdn.microsoft.com/en-us/library/aa365739.aspx>\n         or through\n         GetFileInformationByHandle\n         <https://msdn.microsoft.com/en-us/library/aa364952.aspx>\n         <https://msdn.microsoft.com/en-us/library/aa363788.aspx>\n         or through\n         GetFileInformationByHandleEx with argument FileBasicInfo\n         <https://msdn.microsoft.com/en-us/library/aa364953.aspx>\n         <https://msdn.microsoft.com/en-us/library/aa364217.aspx>\n         The latter requires -D_WIN32_WINNT=_WIN32_WINNT_VISTA or higher.  */\n#if _GL_WINDOWS_STAT_TIMESPEC\n      buf->st_atim = _gl_convert_FILETIME_to_timespec (&info.ftLastAccessTime);\n      buf->st_mtim = _gl_convert_FILETIME_to_timespec (&info.ftLastWriteTime);\n      buf->st_ctim = _gl_convert_FILETIME_to_timespec (&info.ftCreationTime);\n#else\n      buf->st_atime = _gl_convert_FILETIME_to_POSIX (&info.ftLastAccessTime);\n      buf->st_mtime = _gl_convert_FILETIME_to_POSIX (&info.ftLastWriteTime);\n      buf->st_ctime = _gl_convert_FILETIME_to_POSIX (&info.ftCreationTime);\n#endif\n\n      return 0;\n    }\n  else if (type == FILE_TYPE_CHAR || type == FILE_TYPE_PIPE)\n    {\n      buf->st_dev = 0;\n#if _GL_WINDOWS_STAT_INODES == 2\n      buf->st_ino._gl_ino[0] = buf->st_ino._gl_ino[1] = 0;\n#else\n      buf->st_ino = 0;\n#endif\n      buf->st_mode = (type == FILE_TYPE_PIPE ? _S_IFIFO : _S_IFCHR);\n      buf->st_nlink = 1;\n      buf->st_uid = 0;\n      buf->st_gid = 0;\n      buf->st_rdev = 0;\n      if (type == FILE_TYPE_PIPE)\n        {\n          /* PeekNamedPipe\n             <https://msdn.microsoft.com/en-us/library/aa365779.aspx> */\n          DWORD bytes_available;\n          if (PeekNamedPipe (h, NULL, 0, NULL, &bytes_available, NULL))\n            buf->st_size = bytes_available;\n          else\n            buf->st_size = 0;\n        }\n      else\n        buf->st_size = 0;\n#if _GL_WINDOWS_STAT_TIMESPEC\n      buf->st_atim.tv_sec = 0; buf->st_atim.tv_nsec = 0;\n      buf->st_mtim.tv_sec = 0; buf->st_mtim.tv_nsec = 0;\n      buf->st_ctim.tv_sec = 0; buf->st_ctim.tv_nsec = 0;\n#else\n      buf->st_atime = 0;\n      buf->st_mtime = 0;\n      buf->st_ctime = 0;\n#endif\n      return 0;\n    }\n  else\n    {\n      errno = ENOENT;\n      return -1;\n    }\n\n failed:\n  {\n    DWORD error = GetLastError ();\n    #if 0\n    fprintf (stderr, \"_gl_fstat_by_handle error 0x%x\\n\", (unsigned int) error);\n    #endif\n    switch (error)\n      {\n      case ERROR_ACCESS_DENIED:\n      case ERROR_SHARING_VIOLATION:\n        errno = EACCES;\n        break;\n\n      case ERROR_OUTOFMEMORY:\n        errno = ENOMEM;\n        break;\n\n      case ERROR_WRITE_FAULT:\n      case ERROR_READ_FAULT:\n      case ERROR_GEN_FAILURE:\n        errno = EIO;\n        break;\n\n      default:\n        errno = EINVAL;\n        break;\n      }\n    return -1;\n  }\n}",
      "lines": 291,
      "depth": 22,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/lib/stat-w32.h": {},
  "sed/sed-4.5/lib/stat.c": {
    "orig_stat": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        39,
        1
      ],
      "content": "static int\norig_stat (const char *filename, struct stat *buf)\n{\n  return stat (filename, buf);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "is_unc_root": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "static BOOL\nis_unc_root (const char *rname)\n{\n  /* Test whether it has the syntax '\\\\server\\share'.  */\n  if (ISSLASH (rname[0]) && ISSLASH (rname[1]))\n    {\n      /* It starts with two slashes.  Find the next slash.  */\n      const char *p = rname + 2;\n      const char *q = p;\n      while (*q != '\\0' && !ISSLASH (*q))\n        q++;\n      if (q > p && *q != '\\0')\n        {\n          /* Found the next slash at q.  */\n          q++;\n          const char *r = q;\n          while (*r != '\\0' && !ISSLASH (*r))\n            r++;\n          if (r > q && *r == '\\0')\n            return TRUE;\n        }\n    }\n  return FALSE;\n}",
      "lines": 24,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "BOOL"
      ]
    },
    "rpl_stat": {
      "start_point": [
        99,
        0
      ],
      "end_point": [
        428,
        1
      ],
      "content": "int\nrpl_stat (char const *name, struct stat *buf)\n{\n#ifdef WINDOWS_NATIVE\n  /* Fill the fields ourselves, because the original stat function returns\n     values for st_atime, st_mtime, st_ctime that depend on the current time\n     zone.  See\n     <https://lists.gnu.org/r/bug-gnulib/2017-04/msg00134.html>  */\n  /* XXX Should we convert to wchar_t* and prepend '\\\\?\\', in order to work\n     around length limitations\n     <https://msdn.microsoft.com/en-us/library/aa365247.aspx> ?  */\n\n  /* POSIX <http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html#tag_04_13>\n     specifies: \"More than two leading <slash> characters shall be treated as\n     a single <slash> character.\"  */\n  if (ISSLASH (name[0]) && ISSLASH (name[1]) && ISSLASH (name[2]))\n    {\n      name += 2;\n      while (ISSLASH (name[1]))\n        name++;\n    }\n\n  size_t len = strlen (name);\n  size_t drive_prefix_len = (HAS_DEVICE (name) ? 2 : 0);\n\n  /* Remove trailing slashes (except the very first one, at position\n     drive_prefix_len), but remember their presence.  */\n  size_t rlen;\n  bool check_dir = false;\n\n  rlen = len;\n  while (rlen > drive_prefix_len && ISSLASH (name[rlen-1]))\n    {\n      check_dir = true;\n      if (rlen == drive_prefix_len + 1)\n        break;\n      rlen--;\n    }\n\n  /* Handle '' and 'C:'.  */\n  if (!check_dir && rlen == drive_prefix_len)\n    {\n      errno = ENOENT;\n      return -1;\n    }\n\n  /* Handle '\\\\'.  */\n  if (rlen == 1 && ISSLASH (name[0]) && len >= 2)\n    {\n      errno = ENOENT;\n      return -1;\n    }\n\n  const char *rname;\n  char *malloca_rname;\n  if (rlen == len)\n    {\n      rname = name;\n      malloca_rname = NULL;\n    }\n  else\n    {\n      malloca_rname = malloca (rlen + 1);\n      if (malloca_rname == NULL)\n        {\n          errno = ENOMEM;\n          return -1;\n        }\n      memcpy (malloca_rname, name, rlen);\n      malloca_rname[rlen] = '\\0';\n      rname = malloca_rname;\n    }\n\n  /* There are two ways to get at the requested information:\n       - by scanning the parent directory and examining the relevant\n         directory entry,\n       - by opening the file directly.\n     The first approach fails for root directories (e.g. 'C:\\') and\n     UNC root directories (e.g. '\\\\server\\share').\n     The second approach fails for some system files (e.g. 'C:\\pagefile.sys'\n     and 'C:\\hiberfil.sys'): ERROR_SHARING_VIOLATION.\n     The second approach gives more information (in particular, correct\n     st_dev, st_ino, st_nlink fields).\n     So we use the second approach and, as a fallback except for root and\n     UNC root directories, also the first approach.  */\n  {\n    int ret;\n\n    {\n      /* Approach based on the file.  */\n\n      /* Open a handle to the file.\n         CreateFile\n         <https://msdn.microsoft.com/en-us/library/aa363858.aspx>\n         <https://msdn.microsoft.com/en-us/library/aa363874.aspx>  */\n      HANDLE h =\n        CreateFile (rname,\n                    FILE_READ_ATTRIBUTES,\n                    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,\n                    NULL,\n                    OPEN_EXISTING,\n                    /* FILE_FLAG_POSIX_SEMANTICS (treat file names that differ only\n                       in case as different) makes sense only when applied to *all*\n                       filesystem operations.  */\n                    FILE_FLAG_BACKUP_SEMANTICS /* | FILE_FLAG_POSIX_SEMANTICS */,\n                    NULL);\n      if (h != INVALID_HANDLE_VALUE)\n        {\n          ret = _gl_fstat_by_handle (h, rname, buf);\n          CloseHandle (h);\n          goto done;\n        }\n    }\n\n    /* Test for root and UNC root directories.  */\n    if ((rlen == drive_prefix_len + 1 && ISSLASH (rname[drive_prefix_len]))\n        || is_unc_root (rname))\n      goto failed;\n\n    /* Fallback.  */\n    {\n      /* Approach based on the directory entry.  */\n\n      if (strchr (rname, '?') != NULL || strchr (rname, '*') != NULL)\n        {\n          /* Other Windows API functions would fail with error\n             ERROR_INVALID_NAME.  */\n          if (malloca_rname != NULL)\n            freea (malloca_rname);\n          errno = ENOENT;\n          return -1;\n        }\n\n      /* Get the details about the directory entry.  This can be done through\n         FindFirstFile\n         <https://msdn.microsoft.com/en-us/library/aa364418.aspx>\n         <https://msdn.microsoft.com/en-us/library/aa365740.aspx>\n         or through\n         FindFirstFileEx with argument FindExInfoBasic\n         <https://msdn.microsoft.com/en-us/library/aa364419.aspx>\n         <https://msdn.microsoft.com/en-us/library/aa364415.aspx>\n         <https://msdn.microsoft.com/en-us/library/aa365740.aspx>  */\n      WIN32_FIND_DATA info;\n      HANDLE h = FindFirstFile (rname, &info);\n      if (h == INVALID_HANDLE_VALUE)\n        goto failed;\n\n      /* Test for error conditions before starting to fill *buf.  */\n      if (sizeof (buf->st_size) <= 4 && info.nFileSizeHigh > 0)\n        {\n          FindClose (h);\n          if (malloca_rname != NULL)\n            freea (malloca_rname);\n          errno = EOVERFLOW;\n          return -1;\n        }\n\n# if _GL_WINDOWS_STAT_INODES\n      buf->st_dev = 0;\n#  if _GL_WINDOWS_STAT_INODES == 2\n      buf->st_ino._gl_ino[0] = buf->st_ino._gl_ino[1] = 0;\n#  else /* _GL_WINDOWS_STAT_INODES == 1 */\n      buf->st_ino = 0;\n#  endif\n# else\n      /* st_ino is not wide enough for identifying a file on a device.\n         Without st_ino, st_dev is pointless.  */\n      buf->st_dev = 0;\n      buf->st_ino = 0;\n# endif\n\n      /* st_mode.  */\n      unsigned int mode =\n        /* XXX How to handle FILE_ATTRIBUTE_REPARSE_POINT ?  */\n        ((info.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ? _S_IFDIR | S_IEXEC_UGO : _S_IFREG)\n        | S_IREAD_UGO\n        | ((info.dwFileAttributes & FILE_ATTRIBUTE_READONLY) ? 0 : S_IWRITE_UGO);\n      if (!(info.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))\n        {\n          /* Determine whether the file is executable by looking at the file\n             name suffix.  */\n          if (info.nFileSizeHigh > 0 || info.nFileSizeLow > 0)\n            {\n              const char *last_dot = NULL;\n              const char *p;\n              for (p = info.cFileName; *p != '\\0'; p++)\n                if (*p == '.')\n                  last_dot = p;\n              if (last_dot != NULL)\n                {\n                  const char *suffix = last_dot + 1;\n                  if (_stricmp (suffix, \"exe\") == 0\n                      || _stricmp (suffix, \"bat\") == 0\n                      || _stricmp (suffix, \"cmd\") == 0\n                      || _stricmp (suffix, \"com\") == 0)\n                    mode |= S_IEXEC_UGO;\n                }\n            }\n        }\n      buf->st_mode = mode;\n\n      /* st_nlink.  Ignore hard links here.  */\n      buf->st_nlink = 1;\n\n      /* There's no easy way to map the Windows SID concept to an integer.  */\n      buf->st_uid = 0;\n      buf->st_gid = 0;\n\n      /* st_rdev is irrelevant for normal files and directories.  */\n      buf->st_rdev = 0;\n\n      /* st_size.  */\n      if (sizeof (buf->st_size) <= 4)\n        /* Range check already done above.  */\n        buf->st_size = info.nFileSizeLow;\n      else\n        buf->st_size = ((long long) info.nFileSizeHigh << 32) | (long long) info.nFileSizeLow;\n\n      /* st_atime, st_mtime, st_ctime.  */\n# if _GL_WINDOWS_STAT_TIMESPEC\n      buf->st_atim = _gl_convert_FILETIME_to_timespec (&info.ftLastAccessTime);\n      buf->st_mtim = _gl_convert_FILETIME_to_timespec (&info.ftLastWriteTime);\n      buf->st_ctim = _gl_convert_FILETIME_to_timespec (&info.ftCreationTime);\n# else\n      buf->st_atime = _gl_convert_FILETIME_to_POSIX (&info.ftLastAccessTime);\n      buf->st_mtime = _gl_convert_FILETIME_to_POSIX (&info.ftLastWriteTime);\n      buf->st_ctime = _gl_convert_FILETIME_to_POSIX (&info.ftCreationTime);\n# endif\n\n      FindClose (h);\n\n      ret = 0;\n    }\n\n   done:\n    if (ret >= 0 && check_dir && !S_ISDIR (buf->st_mode))\n      {\n        errno = ENOTDIR;\n        ret = -1;\n      }\n    if (malloca_rname != NULL)\n      {\n        int saved_errno = errno;\n        freea (malloca_rname);\n        errno = saved_errno;\n      }\n    return ret;\n  }\n\n failed:\n  {\n    DWORD error = GetLastError ();\n    #if 0\n    fprintf (stderr, \"rpl_stat error 0x%x\\n\", (unsigned int) error);\n    #endif\n\n    if (malloca_rname != NULL)\n      freea (malloca_rname);\n\n    switch (error)\n      {\n      /* Some of these errors probably cannot happen with the specific flags\n         that we pass to CreateFile.  But who knows...  */\n      case ERROR_FILE_NOT_FOUND: /* The last component of rname does not exist.  */\n      case ERROR_PATH_NOT_FOUND: /* Some directory component in rname does not exist.  */\n      case ERROR_BAD_PATHNAME:   /* rname is such as '\\\\server'.  */\n      case ERROR_BAD_NET_NAME:   /* rname is such as '\\\\server\\nonexistentshare'.  */\n      case ERROR_INVALID_NAME:   /* rname contains wildcards, misplaced colon, etc.  */\n      case ERROR_DIRECTORY:\n        errno = ENOENT;\n        break;\n\n      case ERROR_ACCESS_DENIED:  /* rname is such as 'C:\\System Volume Information\\foo'.  */\n      case ERROR_SHARING_VIOLATION: /* rname is such as 'C:\\pagefile.sys' (second approach only).  */\n                                    /* XXX map to EACCESS or EPERM? */\n        errno = EACCES;\n        break;\n\n      case ERROR_OUTOFMEMORY:\n        errno = ENOMEM;\n        break;\n\n      case ERROR_WRITE_PROTECT:\n        errno = EROFS;\n        break;\n\n      case ERROR_WRITE_FAULT:\n      case ERROR_READ_FAULT:\n      case ERROR_GEN_FAILURE:\n        errno = EIO;\n        break;\n\n      case ERROR_BUFFER_OVERFLOW:\n      case ERROR_FILENAME_EXCED_RANGE:\n        errno = ENAMETOOLONG;\n        break;\n\n      case ERROR_DELETE_PENDING: /* XXX map to EACCESS or EPERM? */\n        errno = EPERM;\n        break;\n\n      default:\n        errno = EINVAL;\n        break;\n      }\n\n    return -1;\n  }\n#else\n  int result = orig_stat (name, buf);\n  if (result == 0)\n    {\n# if REPLACE_FUNC_STAT_FILE\n      /* Solaris 9 mistakenly succeeds when given a non-directory with a\n         trailing slash.  */\n      if (!S_ISDIR (buf->st_mode))\n        {\n          size_t len = strlen (name);\n          if (ISSLASH (name[len - 1]))\n            {\n              errno = ENOTDIR;\n              return -1;\n            }\n        }\n# endif /* REPLACE_FUNC_STAT_FILE */\n      result = stat_time_normalize (result, buf);\n    }\n  return result;\n#endif\n}",
      "lines": 330,
      "depth": 21,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/lib/stdalign.in.h": {},
  "sed/sed-4.5/lib/stdarg.in.h": {},
  "sed/sed-4.5/lib/stdbool.in.h": {},
  "sed/sed-4.5/lib/stddef.in.h": {},
  "sed/sed-4.5/lib/stdint.in.h": {},
  "sed/sed-4.5/lib/stdio-impl.h": {},
  "sed/sed-4.5/lib/stdio.in.h": {},
  "sed/sed-4.5/lib/stdlib.in.h": {},
  "sed/sed-4.5/lib/streq.h": {
    "streq9": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "static inline int\nstreq9 (const char *s1, const char *s2)\n{\n  return strcmp (s1 + 9, s2 + 9) == 0;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq8": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "static inline int\nstreq8 (const char *s1, const char *s2, char s28)\n{\n  if (s1[8] == s28)\n    {\n      if (s28 == 0)\n        return 1;\n      else\n        return streq9 (s1, s2);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq7": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        65,
        1
      ],
      "content": "static inline int\nstreq7 (const char *s1, const char *s2, char s27, char s28)\n{\n  if (s1[7] == s27)\n    {\n      if (s27 == 0)\n        return 1;\n      else\n        return streq8 (s1, s2, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq6": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "static inline int\nstreq6 (const char *s1, const char *s2, char s26, char s27, char s28)\n{\n  if (s1[6] == s26)\n    {\n      if (s26 == 0)\n        return 1;\n      else\n        return streq7 (s1, s2, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq5": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "static inline int\nstreq5 (const char *s1, const char *s2, char s25, char s26, char s27, char s28)\n{\n  if (s1[5] == s25)\n    {\n      if (s25 == 0)\n        return 1;\n      else\n        return streq6 (s1, s2, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq4": {
      "start_point": [
        95,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "static inline int\nstreq4 (const char *s1, const char *s2, char s24, char s25, char s26, char s27, char s28)\n{\n  if (s1[4] == s24)\n    {\n      if (s24 == 0)\n        return 1;\n      else\n        return streq5 (s1, s2, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq3": {
      "start_point": [
        109,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "static inline int\nstreq3 (const char *s1, const char *s2, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (s1[3] == s23)\n    {\n      if (s23 == 0)\n        return 1;\n      else\n        return streq4 (s1, s2, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq2": {
      "start_point": [
        123,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "static inline int\nstreq2 (const char *s1, const char *s2, char s22, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (s1[2] == s22)\n    {\n      if (s22 == 0)\n        return 1;\n      else\n        return streq3 (s1, s2, s23, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq1": {
      "start_point": [
        137,
        0
      ],
      "end_point": [
        149,
        1
      ],
      "content": "static inline int\nstreq1 (const char *s1, const char *s2, char s21, char s22, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (s1[1] == s21)\n    {\n      if (s21 == 0)\n        return 1;\n      else\n        return streq2 (s1, s2, s22, s23, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq0": {
      "start_point": [
        151,
        0
      ],
      "end_point": [
        163,
        1
      ],
      "content": "static inline int\nstreq0 (const char *s1, const char *s2, char s20, char s21, char s22, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (s1[0] == s20)\n    {\n      if (s20 == 0)\n        return 1;\n      else\n        return streq1 (s1, s2, s21, s22, s23, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    }
  },
  "sed/sed-4.5/lib/strerror-override.c": {
    "strerror_override": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        301,
        1
      ],
      "content": "const char *\nstrerror_override (int errnum)\n{\n  /* These error messages are taken from glibc/sysdeps/gnu/errlist.c.  */\n  switch (errnum)\n    {\n#if REPLACE_STRERROR_0\n    case 0:\n      return \"Success\";\n#endif\n\n#if GNULIB_defined_ESOCK /* native Windows platforms with older <errno.h> */\n    case EINPROGRESS:\n      return \"Operation now in progress\";\n    case EALREADY:\n      return \"Operation already in progress\";\n    case ENOTSOCK:\n      return \"Socket operation on non-socket\";\n    case EDESTADDRREQ:\n      return \"Destination address required\";\n    case EMSGSIZE:\n      return \"Message too long\";\n    case EPROTOTYPE:\n      return \"Protocol wrong type for socket\";\n    case ENOPROTOOPT:\n      return \"Protocol not available\";\n    case EPROTONOSUPPORT:\n      return \"Protocol not supported\";\n    case EOPNOTSUPP:\n      return \"Operation not supported\";\n    case EAFNOSUPPORT:\n      return \"Address family not supported by protocol\";\n    case EADDRINUSE:\n      return \"Address already in use\";\n    case EADDRNOTAVAIL:\n      return \"Cannot assign requested address\";\n    case ENETDOWN:\n      return \"Network is down\";\n    case ENETUNREACH:\n      return \"Network is unreachable\";\n    case ECONNRESET:\n      return \"Connection reset by peer\";\n    case ENOBUFS:\n      return \"No buffer space available\";\n    case EISCONN:\n      return \"Transport endpoint is already connected\";\n    case ENOTCONN:\n      return \"Transport endpoint is not connected\";\n    case ETIMEDOUT:\n      return \"Connection timed out\";\n    case ECONNREFUSED:\n      return \"Connection refused\";\n    case ELOOP:\n      return \"Too many levels of symbolic links\";\n    case EHOSTUNREACH:\n      return \"No route to host\";\n    case EWOULDBLOCK:\n      return \"Operation would block\";\n#endif\n#if GNULIB_defined_ESTREAMS /* native Windows platforms with older <errno.h> */\n    case ETXTBSY:\n      return \"Text file busy\";\n    case ENODATA:\n      return \"No data available\";\n    case ENOSR:\n      return \"Out of streams resources\";\n    case ENOSTR:\n      return \"Device not a stream\";\n    case ETIME:\n      return \"Timer expired\";\n    case EOTHER:\n      return \"Other error\";\n#endif\n#if GNULIB_defined_EWINSOCK /* native Windows platforms */\n    case ESOCKTNOSUPPORT:\n      return \"Socket type not supported\";\n    case EPFNOSUPPORT:\n      return \"Protocol family not supported\";\n    case ESHUTDOWN:\n      return \"Cannot send after transport endpoint shutdown\";\n    case ETOOMANYREFS:\n      return \"Too many references: cannot splice\";\n    case EHOSTDOWN:\n      return \"Host is down\";\n    case EPROCLIM:\n      return \"Too many processes\";\n    case EUSERS:\n      return \"Too many users\";\n    case EDQUOT:\n      return \"Disk quota exceeded\";\n    case ESTALE:\n      return \"Stale NFS file handle\";\n    case EREMOTE:\n      return \"Object is remote\";\n# if HAVE_WINSOCK2_H\n      /* WSA_INVALID_HANDLE maps to EBADF */\n      /* WSA_NOT_ENOUGH_MEMORY maps to ENOMEM */\n      /* WSA_INVALID_PARAMETER maps to EINVAL */\n    case WSA_OPERATION_ABORTED:\n      return \"Overlapped operation aborted\";\n    case WSA_IO_INCOMPLETE:\n      return \"Overlapped I/O event object not in signaled state\";\n    case WSA_IO_PENDING:\n      return \"Overlapped operations will complete later\";\n      /* WSAEINTR maps to EINTR */\n      /* WSAEBADF maps to EBADF */\n      /* WSAEACCES maps to EACCES */\n      /* WSAEFAULT maps to EFAULT */\n      /* WSAEINVAL maps to EINVAL */\n      /* WSAEMFILE maps to EMFILE */\n      /* WSAEWOULDBLOCK maps to EWOULDBLOCK */\n      /* WSAEINPROGRESS maps to EINPROGRESS */\n      /* WSAEALREADY maps to EALREADY */\n      /* WSAENOTSOCK maps to ENOTSOCK */\n      /* WSAEDESTADDRREQ maps to EDESTADDRREQ */\n      /* WSAEMSGSIZE maps to EMSGSIZE */\n      /* WSAEPROTOTYPE maps to EPROTOTYPE */\n      /* WSAENOPROTOOPT maps to ENOPROTOOPT */\n      /* WSAEPROTONOSUPPORT maps to EPROTONOSUPPORT */\n      /* WSAESOCKTNOSUPPORT is ESOCKTNOSUPPORT */\n      /* WSAEOPNOTSUPP maps to EOPNOTSUPP */\n      /* WSAEPFNOSUPPORT is EPFNOSUPPORT */\n      /* WSAEAFNOSUPPORT maps to EAFNOSUPPORT */\n      /* WSAEADDRINUSE maps to EADDRINUSE */\n      /* WSAEADDRNOTAVAIL maps to EADDRNOTAVAIL */\n      /* WSAENETDOWN maps to ENETDOWN */\n      /* WSAENETUNREACH maps to ENETUNREACH */\n      /* WSAENETRESET maps to ENETRESET */\n      /* WSAECONNABORTED maps to ECONNABORTED */\n      /* WSAECONNRESET maps to ECONNRESET */\n      /* WSAENOBUFS maps to ENOBUFS */\n      /* WSAEISCONN maps to EISCONN */\n      /* WSAENOTCONN maps to ENOTCONN */\n      /* WSAESHUTDOWN is ESHUTDOWN */\n      /* WSAETOOMANYREFS is ETOOMANYREFS */\n      /* WSAETIMEDOUT maps to ETIMEDOUT */\n      /* WSAECONNREFUSED maps to ECONNREFUSED */\n      /* WSAELOOP maps to ELOOP */\n      /* WSAENAMETOOLONG maps to ENAMETOOLONG */\n      /* WSAEHOSTDOWN is EHOSTDOWN */\n      /* WSAEHOSTUNREACH maps to EHOSTUNREACH */\n      /* WSAENOTEMPTY maps to ENOTEMPTY */\n      /* WSAEPROCLIM is EPROCLIM */\n      /* WSAEUSERS is EUSERS */\n      /* WSAEDQUOT is EDQUOT */\n      /* WSAESTALE is ESTALE */\n      /* WSAEREMOTE is EREMOTE */\n    case WSASYSNOTREADY:\n      return \"Network subsystem is unavailable\";\n    case WSAVERNOTSUPPORTED:\n      return \"Winsock.dll version out of range\";\n    case WSANOTINITIALISED:\n      return \"Successful WSAStartup not yet performed\";\n    case WSAEDISCON:\n      return \"Graceful shutdown in progress\";\n    case WSAENOMORE: case WSA_E_NO_MORE:\n      return \"No more results\";\n    case WSAECANCELLED: case WSA_E_CANCELLED:\n      return \"Call was canceled\";\n    case WSAEINVALIDPROCTABLE:\n      return \"Procedure call table is invalid\";\n    case WSAEINVALIDPROVIDER:\n      return \"Service provider is invalid\";\n    case WSAEPROVIDERFAILEDINIT:\n      return \"Service provider failed to initialize\";\n    case WSASYSCALLFAILURE:\n      return \"System call failure\";\n    case WSASERVICE_NOT_FOUND:\n      return \"Service not found\";\n    case WSATYPE_NOT_FOUND:\n      return \"Class type not found\";\n    case WSAEREFUSED:\n      return \"Database query was refused\";\n    case WSAHOST_NOT_FOUND:\n      return \"Host not found\";\n    case WSATRY_AGAIN:\n      return \"Nonauthoritative host not found\";\n    case WSANO_RECOVERY:\n      return \"Nonrecoverable error\";\n    case WSANO_DATA:\n      return \"Valid name, no data record of requested type\";\n      /* WSA_QOS_* omitted */\n# endif\n#endif\n\n#if GNULIB_defined_ENOMSG\n    case ENOMSG:\n      return \"No message of desired type\";\n#endif\n\n#if GNULIB_defined_EIDRM\n    case EIDRM:\n      return \"Identifier removed\";\n#endif\n\n#if GNULIB_defined_ENOLINK\n    case ENOLINK:\n      return \"Link has been severed\";\n#endif\n\n#if GNULIB_defined_EPROTO\n    case EPROTO:\n      return \"Protocol error\";\n#endif\n\n#if GNULIB_defined_EMULTIHOP\n    case EMULTIHOP:\n      return \"Multihop attempted\";\n#endif\n\n#if GNULIB_defined_EBADMSG\n    case EBADMSG:\n      return \"Bad message\";\n#endif\n\n#if GNULIB_defined_EOVERFLOW\n    case EOVERFLOW:\n      return \"Value too large for defined data type\";\n#endif\n\n#if GNULIB_defined_ENOTSUP\n    case ENOTSUP:\n      return \"Not supported\";\n#endif\n\n#if GNULIB_defined_ENETRESET\n    case ENETRESET:\n      return \"Network dropped connection on reset\";\n#endif\n\n#if GNULIB_defined_ECONNABORTED\n    case ECONNABORTED:\n      return \"Software caused connection abort\";\n#endif\n\n#if GNULIB_defined_ESTALE\n    case ESTALE:\n      return \"Stale NFS file handle\";\n#endif\n\n#if GNULIB_defined_EDQUOT\n    case EDQUOT:\n      return \"Disk quota exceeded\";\n#endif\n\n#if GNULIB_defined_ECANCELED\n    case ECANCELED:\n      return \"Operation canceled\";\n#endif\n\n#if GNULIB_defined_EOWNERDEAD\n    case EOWNERDEAD:\n      return \"Owner died\";\n#endif\n\n#if GNULIB_defined_ENOTRECOVERABLE\n    case ENOTRECOVERABLE:\n      return \"State not recoverable\";\n#endif\n\n#if GNULIB_defined_EILSEQ\n    case EILSEQ:\n      return \"Invalid or incomplete multibyte or wide character\";\n#endif\n\n    default:\n      return NULL;\n    }\n}",
      "lines": 269,
      "depth": 10,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nstrerror_override (int errnum)",
        "*"
      ]
    }
  },
  "sed/sed-4.5/lib/strerror-override.h": {},
  "sed/sed-4.5/lib/strerror.c": {},
  "sed/sed-4.5/lib/string.in.h": {},
  "sed/sed-4.5/lib/stripslash.c": {
    "strip_trailing_slashes": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "bool\nstrip_trailing_slashes (char *file)\n{\n  char *base = last_component (file);\n  char *base_lim;\n  bool had_slash;\n\n  /* last_component returns \"\" for file system roots, but we need to turn\n     \"///\" into \"/\".  */\n  if (! *base)\n    base = file;\n  base_lim = base + base_len (base);\n  had_slash = (*base_lim != '\\0');\n  *base_lim = '\\0';\n  return had_slash;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "bool"
      ]
    }
  },
  "sed/sed-4.5/lib/strverscmp.c": {
    "__strverscmp": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        112,
        1
      ],
      "content": "int\n__strverscmp (const char *s1, const char *s2)\n{\n  const unsigned char *p1 = (const unsigned char *) s1;\n  const unsigned char *p2 = (const unsigned char *) s2;\n  unsigned char c1, c2;\n  int state;\n  int diff;\n\n  /* Symbol(s)    0       [1-9]   others\n     Transition   (10) 0  (01) d  (00) x   */\n  static const unsigned char next_state[] =\n  {\n      /* state    x    d    0  */\n      /* S_N */  S_N, S_I, S_Z,\n      /* S_I */  S_N, S_I, S_I,\n      /* S_F */  S_N, S_F, S_F,\n      /* S_Z */  S_N, S_F, S_Z\n  };\n\n  static const signed char result_type[] =\n  {\n      /* state   x/x  x/d  x/0  d/x  d/d  d/0  0/x  0/d  0/0  */\n\n      /* S_N */  CMP, CMP, CMP, CMP, LEN, CMP, CMP, CMP, CMP,\n      /* S_I */  CMP, -1,  -1,  +1,  LEN, LEN, +1,  LEN, LEN,\n      /* S_F */  CMP, CMP, CMP, CMP, CMP, CMP, CMP, CMP, CMP,\n      /* S_Z */  CMP, +1,  +1,  -1,  CMP, CMP, -1,  CMP, CMP\n  };\n\n  if (p1 == p2)\n    return 0;\n\n  c1 = *p1++;\n  c2 = *p2++;\n  /* Hint: '0' is a digit too.  */\n  state = S_N + ((c1 == '0') + (isdigit (c1) != 0));\n\n  while ((diff = c1 - c2) == 0)\n    {\n      if (c1 == '\\0')\n        return diff;\n\n      state = next_state[state];\n      c1 = *p1++;\n      c2 = *p2++;\n      state += (c1 == '0') + (isdigit (c1) != 0);\n    }\n\n  state = result_type[state * 3 + (((c2 == '0') + (isdigit (c2) != 0)))];\n\n  switch (state)\n    {\n    case CMP:\n      return diff;\n\n    case LEN:\n      while (isdigit (*p1++))\n        if (!isdigit (*p2++))\n          return 1;\n\n      return isdigit (*p2) ? -1 : diff;\n\n    default:\n      return state;\n    }\n}",
      "lines": 67,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/lib/sys_stat.in.h": {
    "rpl_mkdir": {
      "start_point": [
        581,
        0
      ],
      "end_point": [
        585,
        1
      ],
      "content": "static int\nrpl_mkdir (char const *name, mode_t mode)\n{\n  return _mkdir (name);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "sed/sed-4.5/lib/sys_time.in.h": {
    "GNULIB_NAMESPACE": {
      "start_point": [
        112,
        0
      ],
      "end_point": [
        116,
        1
      ],
      "content": "namespace GNULIB_NAMESPACE {\n  typedef ::timeval\n#undef timeval\n    timeval;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": null
    }
  },
  "sed/sed-4.5/lib/sys_types.in.h": {},
  "sed/sed-4.5/lib/tempname.c": {
    "direxists": {
      "start_point": [
        103,
        0
      ],
      "end_point": [
        108,
        1
      ],
      "content": "static int\ndirexists (const char *dir)\n{\n  struct_stat64 buf;\n  return __xstat64 (_STAT_VER, dir, &buf) == 0 && S_ISDIR (buf.st_mode);\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "__path_search": {
      "start_point": [
        116,
        0
      ],
      "end_point": [
        171,
        1
      ],
      "content": "int\n__path_search (char *tmpl, size_t tmpl_len, const char *dir, const char *pfx,\n               int try_tmpdir)\n{\n  const char *d;\n  size_t dlen, plen;\n\n  if (!pfx || !pfx[0])\n    {\n      pfx = \"file\";\n      plen = 4;\n    }\n  else\n    {\n      plen = strlen (pfx);\n      if (plen > 5)\n        plen = 5;\n    }\n\n  if (try_tmpdir)\n    {\n      d = __secure_getenv (\"TMPDIR\");\n      if (d != NULL && direxists (d))\n        dir = d;\n      else if (dir != NULL && direxists (dir))\n        /* nothing */ ;\n      else\n        dir = NULL;\n    }\n  if (dir == NULL)\n    {\n      if (direxists (P_tmpdir))\n        dir = P_tmpdir;\n      else if (strcmp (P_tmpdir, \"/tmp\") != 0 && direxists (\"/tmp\"))\n        dir = \"/tmp\";\n      else\n        {\n          __set_errno (ENOENT);\n          return -1;\n        }\n    }\n\n  dlen = strlen (dir);\n  while (dlen > 1 && dir[dlen - 1] == '/')\n    dlen--;                     /* remove trailing slashes */\n\n  /* check we have room for \"${dir}/${pfx}XXXXXX\\0\" */\n  if (tmpl_len < dlen + 1 + plen + 6 + 1)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  sprintf (tmpl, \"%.*s/%.*sXXXXXX\", (int) dlen, dir, (int) plen, pfx);\n  return 0;\n}",
      "lines": 56,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "__try_tempname": {
      "start_point": [
        178,
        0
      ],
      "end_point": [
        258,
        1
      ],
      "content": "int\n__try_tempname (char *tmpl, int suffixlen, void *args,\n                int (*tryfunc) (char *, void *))\n{\n  int len;\n  char *XXXXXX;\n  static uint64_t value;\n  uint64_t random_time_bits;\n  unsigned int count;\n  int fd = -1;\n  int save_errno = errno;\n\n  /* A lower bound on the number of temporary files to attempt to\n     generate.  The maximum total number of temporary file names that\n     can exist for a given template is 62**6.  It should never be\n     necessary to try all of these combinations.  Instead if a reasonable\n     number of names is tried (we define reasonable as 62**3) fail to\n     give the system administrator the chance to remove the problems.  */\n#define ATTEMPTS_MIN (62 * 62 * 62)\n\n  /* The number of times to attempt to generate a temporary file.  To\n     conform to POSIX, this must be no smaller than TMP_MAX.  */\n#if ATTEMPTS_MIN < TMP_MAX\n  unsigned int attempts = TMP_MAX;\n#else\n  unsigned int attempts = ATTEMPTS_MIN;\n#endif\n\n  len = strlen (tmpl);\n  if (len < 6 + suffixlen || memcmp (&tmpl[len - 6 - suffixlen], \"XXXXXX\", 6))\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  /* This is where the Xs start.  */\n  XXXXXX = &tmpl[len - 6 - suffixlen];\n\n  /* Get some more or less random data.  */\n#ifdef RANDOM_BITS\n  RANDOM_BITS (random_time_bits);\n#else\n  {\n    struct timeval tv;\n    __gettimeofday (&tv, NULL);\n    random_time_bits = ((uint64_t) tv.tv_usec << 16) ^ tv.tv_sec;\n  }\n#endif\n  value += random_time_bits ^ __getpid ();\n\n  for (count = 0; count < attempts; value += 7777, ++count)\n    {\n      uint64_t v = value;\n\n      /* Fill in the random bits.  */\n      XXXXXX[0] = letters[v % 62];\n      v /= 62;\n      XXXXXX[1] = letters[v % 62];\n      v /= 62;\n      XXXXXX[2] = letters[v % 62];\n      v /= 62;\n      XXXXXX[3] = letters[v % 62];\n      v /= 62;\n      XXXXXX[4] = letters[v % 62];\n      v /= 62;\n      XXXXXX[5] = letters[v % 62];\n\n      fd = tryfunc (tmpl, args);\n      if (fd >= 0)\n        {\n          __set_errno (save_errno);\n          return fd;\n        }\n      else if (errno != EEXIST)\n        return -1;\n    }\n\n  /* We got out of the loop because we ran out of combinations to try.  */\n  __set_errno (EEXIST);\n  return -1;\n}",
      "lines": 81,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "try_file": {
      "start_point": [
        260,
        0
      ],
      "end_point": [
        267,
        1
      ],
      "content": "static int\ntry_file (char *tmpl, void *flags)\n{\n  int *openflags = flags;\n  return __open (tmpl,\n                 (*openflags & ~O_ACCMODE)\n                 | O_RDWR | O_CREAT | O_EXCL, S_IRUSR | S_IWUSR);\n}",
      "lines": 8,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "try_dir": {
      "start_point": [
        269,
        0
      ],
      "end_point": [
        273,
        1
      ],
      "content": "static int\ntry_dir (char *tmpl, void *flags _GL_UNUSED)\n{\n  return __mkdir (tmpl, S_IRUSR | S_IWUSR | S_IXUSR);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "try_nocreate": {
      "start_point": [
        275,
        0
      ],
      "end_point": [
        283,
        1
      ],
      "content": "static int\ntry_nocreate (char *tmpl, void *flags _GL_UNUSED)\n{\n  struct_stat64 st;\n\n  if (__lxstat64 (_STAT_VER, tmpl, &st) == 0 || errno == EOVERFLOW)\n    __set_errno (EEXIST);\n  return errno == ENOENT ? 0 : -1;\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "__gen_tempname": {
      "start_point": [
        298,
        0
      ],
      "end_point": [
        322,
        1
      ],
      "content": "int\n__gen_tempname (char *tmpl, int suffixlen, int flags, int kind)\n{\n  int (*tryfunc) (char *, void *);\n\n  switch (kind)\n    {\n    case __GT_FILE:\n      tryfunc = try_file;\n      break;\n\n    case __GT_DIR:\n      tryfunc = try_dir;\n      break;\n\n    case __GT_NOCREATE:\n      tryfunc = try_nocreate;\n      break;\n\n    default:\n      assert (! \"invalid KIND in __gen_tempname\");\n      abort ();\n    }\n  return __try_tempname (tmpl, suffixlen, &flags, tryfunc);\n}",
      "lines": 25,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/lib/tempname.h": {},
  "sed/sed-4.5/lib/time.in.h": {},
  "sed/sed-4.5/lib/unistd.c": {},
  "sed/sed-4.5/lib/unistd.in.h": {
    "rpl_environ": {
      "start_point": [
        433,
        0
      ],
      "end_point": [
        437,
        1
      ],
      "content": "_GL_UNISTD_INLINE char ***\nrpl_environ (void)\n{\n  return &environ;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "_GL_UNISTD_INLINE",
        "char",
        "char",
        "***\nrpl_environ (void)",
        "*",
        "**\nrpl_environ (void)",
        "*",
        "*\nrpl_environ (void)",
        "*"
      ]
    },
    "getpagesize": {
      "start_point": [
        912,
        0
      ],
      "end_point": [
        916,
        1
      ],
      "content": "_GL_UNISTD_INLINE int\ngetpagesize ()\n{\n  return _gl_getpagesize ();\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "_GL_UNISTD_INLINE",
        "int",
        "int"
      ]
    }
  },
  "sed/sed-4.5/lib/unlocked-io.h": {},
  "sed/sed-4.5/lib/unused-parameter.h": {},
  "sed/sed-4.5/lib/verify.h": {},
  "sed/sed-4.5/lib/version-etc-fsf.c": {},
  "sed/sed-4.5/lib/version-etc.c": {
    "version_etc_arn": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        172,
        1
      ],
      "content": "void\nversion_etc_arn (FILE *stream,\n                 const char *command_name, const char *package,\n                 const char *version,\n                 const char * const * authors, size_t n_authors)\n{\n  if (command_name)\n    fprintf (stream, \"%s (%s) %s\\n\", command_name, package, version);\n  else\n    fprintf (stream, \"%s %s\\n\", package, version);\n\n#ifdef PACKAGE_PACKAGER\n# ifdef PACKAGE_PACKAGER_VERSION\n  fprintf (stream, _(\"Packaged by %s (%s)\\n\"), PACKAGE_PACKAGER,\n           PACKAGE_PACKAGER_VERSION);\n# else\n  fprintf (stream, _(\"Packaged by %s\\n\"), PACKAGE_PACKAGER);\n# endif\n#endif\n\n  /* TRANSLATORS: Translate \"(C)\" to the copyright symbol\n     (C-in-a-circle), if this symbol is available in the user's\n     locale.  Otherwise, do not translate \"(C)\"; leave it as-is.  */\n  fprintf (stream, version_etc_copyright, _(\"(C)\"), COPYRIGHT_YEAR);\n\n  fputs (_(\"\\\n\\n\\\nLicense GPLv3+: GNU GPL version 3 or later <https://gnu.org/licenses/gpl.html>.\\n\\\nThis is free software: you are free to change and redistribute it.\\n\\\nThere is NO WARRANTY, to the extent permitted by law.\\n\\\n\\n\\\n\"),\n         stream);\n\n  switch (n_authors)\n    {\n    case 0:\n      /* The caller must provide at least one author name.  */\n      abort ();\n    case 1:\n      /* TRANSLATORS: %s denotes an author name.  */\n      fprintf (stream, _(\"Written by %s.\\n\"), authors[0]);\n      break;\n    case 2:\n      /* TRANSLATORS: Each %s denotes an author name.  */\n      fprintf (stream, _(\"Written by %s and %s.\\n\"), authors[0], authors[1]);\n      break;\n    case 3:\n      /* TRANSLATORS: Each %s denotes an author name.  */\n      fprintf (stream, _(\"Written by %s, %s, and %s.\\n\"),\n               authors[0], authors[1], authors[2]);\n      break;\n    case 4:\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"Written by %s, %s, %s,\\nand %s.\\n\"),\n               authors[0], authors[1], authors[2], authors[3]);\n      break;\n    case 5:\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"Written by %s, %s, %s,\\n%s, and %s.\\n\"),\n               authors[0], authors[1], authors[2], authors[3], authors[4]);\n      break;\n    case 6:\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"Written by %s, %s, %s,\\n%s, %s, and %s.\\n\"),\n               authors[0], authors[1], authors[2], authors[3], authors[4],\n               authors[5]);\n      break;\n    case 7:\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"Written by %s, %s, %s,\\n%s, %s, %s, and %s.\\n\"),\n               authors[0], authors[1], authors[2], authors[3], authors[4],\n               authors[5], authors[6]);\n      break;\n    case 8:\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"\\\nWritten by %s, %s, %s,\\n%s, %s, %s, %s,\\nand %s.\\n\"),\n                authors[0], authors[1], authors[2], authors[3], authors[4],\n                authors[5], authors[6], authors[7]);\n      break;\n    case 9:\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"\\\nWritten by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, and %s.\\n\"),\n               authors[0], authors[1], authors[2], authors[3], authors[4],\n               authors[5], authors[6], authors[7], authors[8]);\n      break;\n    default:\n      /* 10 or more authors.  Use an abbreviation, since the human reader\n         will probably not want to read the entire list anyway.  */\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"\\\nWritten by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, %s, and others.\\n\"),\n                authors[0], authors[1], authors[2], authors[3], authors[4],\n                authors[5], authors[6], authors[7], authors[8]);\n      break;\n    }\n}",
      "lines": 113,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "version_etc_ar": {
      "start_point": [
        178,
        0
      ],
      "end_point": [
        188,
        1
      ],
      "content": "void\nversion_etc_ar (FILE *stream,\n                const char *command_name, const char *package,\n                const char *version, const char * const * authors)\n{\n  size_t n_authors;\n\n  for (n_authors = 0; authors[n_authors]; n_authors++)\n    ;\n  version_etc_arn (stream, command_name, package, version, authors, n_authors);\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "version_etc_va": {
      "start_point": [
        194,
        0
      ],
      "end_point": [
        209,
        1
      ],
      "content": "void\nversion_etc_va (FILE *stream,\n                const char *command_name, const char *package,\n                const char *version, va_list authors)\n{\n  size_t n_authors;\n  const char *authtab[10];\n\n  for (n_authors = 0;\n       n_authors < 10\n         && (authtab[n_authors] = va_arg (authors, const char *)) != NULL;\n       n_authors++)\n    ;\n  version_etc_arn (stream, command_name, package, version,\n                   authtab, n_authors);\n}",
      "lines": 16,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "version_etc": {
      "start_point": [
        225,
        0
      ],
      "end_point": [
        235,
        1
      ],
      "content": "void\nversion_etc (FILE *stream,\n             const char *command_name, const char *package,\n             const char *version, /* const char *author1, ...*/ ...)\n{\n  va_list authors;\n\n  va_start (authors, version);\n  version_etc_va (stream, command_name, package, version, authors);\n  va_end (authors);\n}",
      "lines": 11,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "emit_bug_reporting_address": {
      "start_point": [
        237,
        0
      ],
      "end_point": [
        257,
        1
      ],
      "content": "void\nemit_bug_reporting_address (void)\n{\n  /* TRANSLATORS: The placeholder indicates the bug-reporting address\n     for this package.  Please add _another line_ saying\n     \"Report translation bugs to <...>\\n\" with the address for translation\n     bugs (typically your translation team's web or email address).  */\n  printf (_(\"\\nReport bugs to: %s\\n\"), PACKAGE_BUGREPORT);\n#ifdef PACKAGE_PACKAGER_BUG_REPORTS\n  printf (_(\"Report %s bugs to: %s\\n\"), PACKAGE_PACKAGER,\n          PACKAGE_PACKAGER_BUG_REPORTS);\n#endif\n#ifdef PACKAGE_URL\n  printf (_(\"%s home page: <%s>\\n\"), PACKAGE_NAME, PACKAGE_URL);\n#else\n  printf (_(\"%s home page: <https://www.gnu.org/software/%s/>\\n\"),\n          PACKAGE_NAME, PACKAGE);\n#endif\n  fputs (_(\"General help using GNU software: <https://www.gnu.org/gethelp/>\\n\"),\n         stdout);\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "sed/sed-4.5/lib/version-etc.h": {},
  "sed/sed-4.5/lib/warn-on-use.h": {},
  "sed/sed-4.5/lib/wchar.in.h": {},
  "sed/sed-4.5/lib/wcrtomb.c": {
    "wcrtomb": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "size_t\nwcrtomb (char *s, wchar_t wc, mbstate_t *ps)\n{\n  /* This implementation of wcrtomb on top of wctomb() supports only\n     stateless encodings.  ps must be in the initial state.  */\n  if (ps != NULL && !mbsinit (ps))\n    {\n      errno = EINVAL;\n      return (size_t)(-1);\n    }\n\n  if (s == NULL)\n    /* We know the NUL wide character corresponds to the NUL character.  */\n    return 1;\n  else\n    {\n      int ret = wctomb (s, wc);\n\n      if (ret >= 0)\n        return ret;\n      else\n        {\n          errno = EILSEQ;\n          return (size_t)(-1);\n        }\n    }\n}",
      "lines": 27,
      "depth": 10,
      "decorators": [
        "size_t"
      ]
    }
  },
  "sed/sed-4.5/lib/wctob.c": {
    "wctob": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "int\nwctob (wint_t wc)\n{\n  char buf[64];\n\n  if (!(MB_CUR_MAX <= sizeof (buf)))\n    abort ();\n  /* Handle the case where WEOF is a value that does not fit in a wchar_t.  */\n  if (wc == (wchar_t)wc)\n    if (wctomb (buf, (wchar_t)wc) == 1)\n      return (unsigned char) buf[0];\n  return EOF;\n}",
      "lines": 13,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/lib/wctomb-impl.h": {
    "wctomb": {
      "start_point": [
        17,
        0
      ],
      "end_point": [
        33,
        1
      ],
      "content": "int\nwctomb (char *s, wchar_t wc)\n{\n  if (s == NULL)\n    return 0;\n  else\n    {\n      mbstate_t state;\n      size_t result;\n\n      memset (&state, 0, sizeof (mbstate_t));\n      result = wcrtomb (s, wc, &state);\n      if (result == (size_t)-1)\n        return -1;\n      return result;\n    }\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/lib/wctomb.c": {},
  "sed/sed-4.5/lib/wctype-h.c": {},
  "sed/sed-4.5/lib/wctype.in.h": {
    "rpl_towlower": {
      "start_point": [
        371,
        0
      ],
      "end_point": [
        375,
        1
      ],
      "content": "_GL_WCTYPE_INLINE wint_t\nrpl_towlower (wint_t wc)\n{\n  return (wint_t) (wchar_t) towlower (wc);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "_GL_WCTYPE_INLINE",
        "wint_t",
        "wint_t"
      ]
    },
    "rpl_towupper": {
      "start_point": [
        380,
        0
      ],
      "end_point": [
        384,
        1
      ],
      "content": "_GL_WCTYPE_INLINE wint_t\nrpl_towupper (wint_t wc)\n{\n  return (wint_t) (wchar_t) towupper (wc);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "_GL_WCTYPE_INLINE",
        "wint_t",
        "wint_t"
      ]
    }
  },
  "sed/sed-4.5/lib/xalloc-die.c": {
    "xalloc_die": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "void\nxalloc_die (void)\n{\n  error (exit_failure, 0, \"%s\", _(\"memory exhausted\"));\n\n  /* _Noreturn cannot be given to error, since it may return if\n     its first argument is 0.  To help compilers understand the\n     xalloc_die does not return, call abort.  Also, the abort is a\n     safety feature if exit_failure is 0 (which shouldn't happen).  */\n  abort ();\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "sed/sed-4.5/lib/xalloc-oversized.h": {},
  "sed/sed-4.5/lib/xalloc.h": {
    "xnmalloc": {
      "start_point": [
        103,
        0
      ],
      "end_point": [
        109,
        1
      ],
      "content": "XALLOC_INLINE void *\nxnmalloc (size_t n, size_t s)\n{\n  if (xalloc_oversized (n, s))\n    xalloc_die ();\n  return xmalloc (n * s);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "XALLOC_INLINE",
        "void",
        "void",
        "*\nxnmalloc (size_t n, size_t s)",
        "*"
      ]
    },
    "xnrealloc": [
      {
        "start_point": [
          116,
          0
        ],
        "end_point": [
          122,
          1
        ],
        "content": "XALLOC_INLINE void *\nxnrealloc (void *p, size_t n, size_t s)\n{\n  if (xalloc_oversized (n, s))\n    xalloc_die ();\n  return xrealloc (p, n * s);\n}",
        "lines": 7,
        "depth": 7,
        "decorators": [
          "XALLOC_INLINE",
          "void",
          "void",
          "*\nxnrealloc (void *p, size_t n, size_t s)",
          "*"
        ]
      },
      {
        "start_point": [
          239,
          29
        ],
        "end_point": [
          243,
          1
        ],
        "content": "T *\nxnrealloc (T *p, size_t n, size_t s)\n{\n  return (T *) xnrealloc ((void *) p, n, s);\n}",
        "lines": 5,
        "depth": 10,
        "decorators": [
          "T",
          "*\nxnrealloc (T *p, size_t n, size_t s)",
          "*"
        ]
      }
    ],
    "x2nrealloc": [
      {
        "start_point": [
          178,
          0
        ],
        "end_point": [
          213,
          1
        ],
        "content": "XALLOC_INLINE void *\nx2nrealloc (void *p, size_t *pn, size_t s)\n{\n  size_t n = *pn;\n\n  if (! p)\n    {\n      if (! n)\n        {\n          /* The approximate size to use for initial small allocation\n             requests, when the invoking code specifies an old size of\n             zero.  This is the largest \"small\" request for the GNU C\n             library malloc.  */\n          enum { DEFAULT_MXFAST = 64 * sizeof (size_t) / 4 };\n\n          n = DEFAULT_MXFAST / s;\n          n += !n;\n        }\n      if (xalloc_oversized (n, s))\n        xalloc_die ();\n    }\n  else\n    {\n      /* Set N = floor (1.5 * N) + 1 so that progress is made even if N == 0.\n         Check for overflow, so that N * S stays in both ptrdiff_t and\n         size_t range.  The check may be slightly conservative, but an\n         exact check isn't worth the trouble.  */\n      if ((PTRDIFF_MAX < SIZE_MAX ? PTRDIFF_MAX : SIZE_MAX) / 3 * 2 / s\n          <= n)\n        xalloc_die ();\n      n += n / 2 + 1;\n    }\n\n  *pn = n;\n  return xrealloc (p, n * s);\n}",
        "lines": 36,
        "depth": 14,
        "decorators": [
          "XALLOC_INLINE",
          "void",
          "void",
          "*\nx2nrealloc (void *p, size_t *pn, size_t s)",
          "*"
        ]
      },
      {
        "start_point": [
          251,
          29
        ],
        "end_point": [
          255,
          1
        ],
        "content": "T *\nx2nrealloc (T *p, size_t *pn, size_t s)\n{\n  return (T *) x2nrealloc ((void *) p, pn, s);\n}",
        "lines": 5,
        "depth": 10,
        "decorators": [
          "T",
          "*\nx2nrealloc (T *p, size_t *pn, size_t s)",
          "*"
        ]
      }
    ],
    "xcharalloc": {
      "start_point": [
        220,
        0
      ],
      "end_point": [
        224,
        1
      ],
      "content": "XALLOC_INLINE char *\nxcharalloc (size_t n)\n{\n  return XNMALLOC (n, char);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "XALLOC_INLINE",
        "char",
        "char",
        "*\nxcharalloc (size_t n)",
        "*"
      ]
    },
    "xrealloc": {
      "start_point": [
        233,
        29
      ],
      "end_point": [
        237,
        1
      ],
      "content": "T *\nxrealloc (T *p, size_t s)\n{\n  return (T *) xrealloc ((void *) p, s);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "T",
        "*\nxrealloc (T *p, size_t s)",
        "*"
      ]
    },
    "x2realloc": {
      "start_point": [
        245,
        29
      ],
      "end_point": [
        249,
        1
      ],
      "content": "T *\nx2realloc (T *p, size_t *pn)\n{\n  return (T *) x2realloc ((void *) p, pn);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "T",
        "*\nx2realloc (T *p, size_t *pn)",
        "*"
      ]
    },
    "xmemdup": {
      "start_point": [
        257,
        29
      ],
      "end_point": [
        261,
        1
      ],
      "content": "T *\nxmemdup (T const *p, size_t s)\n{\n  return (T *) xmemdup ((void const *) p, s);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "T",
        "*\nxmemdup (T const *p, size_t s)",
        "*"
      ]
    }
  },
  "sed/sed-4.5/lib/xmalloc.c": {
    "xmalloc": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "void *\nxmalloc (size_t n)\n{\n  void *p = malloc (n);\n  if (!p && n != 0)\n    xalloc_die ();\n  return p;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void",
        "*\nxmalloc (size_t n)",
        "*"
      ]
    },
    "xrealloc": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "void *\nxrealloc (void *p, size_t n)\n{\n  if (!n && p)\n    {\n      /* The GNU and C99 realloc behaviors disagree here.  Act like\n         GNU, even if the underlying realloc is C99.  */\n      free (p);\n      return NULL;\n    }\n\n  p = realloc (p, n);\n  if (!p && n)\n    xalloc_die ();\n  return p;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "void",
        "*\nxrealloc (void *p, size_t n)",
        "*"
      ]
    },
    "x2realloc": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "void *\nx2realloc (void *p, size_t *pn)\n{\n  return x2nrealloc (p, pn, 1);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void",
        "*\nx2realloc (void *p, size_t *pn)",
        "*"
      ]
    },
    "xzalloc": {
      "start_point": [
        82,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "void *\nxzalloc (size_t s)\n{\n  return memset (xmalloc (s), 0, s);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void",
        "*\nxzalloc (size_t s)",
        "*"
      ]
    },
    "xcalloc": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "void *\nxcalloc (size_t n, size_t s)\n{\n  void *p;\n  /* Test for overflow, since objects with size greater than\n     PTRDIFF_MAX cause pointer subtraction to go awry.  Omit size-zero\n     tests if HAVE_GNU_CALLOC, since GNU calloc never returns NULL if\n     successful.  */\n  if (xalloc_oversized (n, s)\n      || (! (p = calloc (n, s)) && (HAVE_GNU_CALLOC || n != 0)))\n    xalloc_die ();\n  return p;\n}",
      "lines": 13,
      "depth": 13,
      "decorators": [
        "void",
        "*\nxcalloc (size_t n, size_t s)",
        "*"
      ]
    },
    "xmemdup": {
      "start_point": [
        109,
        0
      ],
      "end_point": [
        113,
        1
      ],
      "content": "void *\nxmemdup (void const *p, size_t s)\n{\n  return memcpy (xmalloc (s), p, s);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void",
        "*\nxmemdup (void const *p, size_t s)",
        "*"
      ]
    },
    "xstrdup": {
      "start_point": [
        117,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "char *\nxstrdup (char const *string)\n{\n  return xmemdup (string, strlen (string) + 1);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "char",
        "*\nxstrdup (char const *string)",
        "*"
      ]
    }
  },
  "sed/sed-4.5/lib/_Noreturn.h": {},
  "sed/sed-4.5/lib/glthread/lock.c": {
    "glthread_rwlock_init_for_glibc": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "int\nglthread_rwlock_init_for_glibc (pthread_rwlock_t *lock)\n{\n  pthread_rwlockattr_t attributes;\n  int err;\n\n  err = pthread_rwlockattr_init (&attributes);\n  if (err != 0)\n    return err;\n  /* Note: PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP is the only value that\n     causes the writer to be preferred. PTHREAD_RWLOCK_PREFER_WRITER_NP does not\n     do this; see\n     http://man7.org/linux/man-pages/man3/pthread_rwlockattr_setkind_np.3.html */\n  err = pthread_rwlockattr_setkind_np (&attributes,\n                                       PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP);\n  if (err == 0)\n    err = pthread_rwlock_init(lock, &attributes);\n  /* pthread_rwlockattr_destroy always returns 0.  It cannot influence the\n     return value.  */\n  pthread_rwlockattr_destroy (&attributes);\n  return err;\n}",
      "lines": 22,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "glthread_rwlock_init_multithreaded": [
      {
        "start_point": [
          65,
          0
        ],
        "end_point": [
          75,
          1
        ],
        "content": "int\nglthread_rwlock_init_multithreaded (gl_rwlock_t *lock)\n{\n  int err;\n\n  err = pthread_rwlock_init (&lock->rwlock, NULL);\n  if (err != 0)\n    return err;\n  lock->initialized = 1;\n  return 0;\n}",
        "lines": 11,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          155,
          0
        ],
        "end_point": [
          172,
          1
        ],
        "content": "int\nglthread_rwlock_init_multithreaded (gl_rwlock_t *lock)\n{\n  int err;\n\n  err = pthread_mutex_init (&lock->lock, NULL);\n  if (err != 0)\n    return err;\n  err = pthread_cond_init (&lock->waiting_readers, NULL);\n  if (err != 0)\n    return err;\n  err = pthread_cond_init (&lock->waiting_writers, NULL);\n  if (err != 0)\n    return err;\n  lock->waiting_writers_count = 0;\n  lock->runcount = 0;\n  return 0;\n}",
        "lines": 18,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          512,
          0
        ],
        "end_point": [
          525,
          1
        ],
        "content": "int\nglthread_rwlock_init_multithreaded (gl_rwlock_t *lock)\n{\n  if (!pth_mutex_init (&lock->lock))\n    return errno;\n  if (!pth_cond_init (&lock->waiting_readers))\n    return errno;\n  if (!pth_cond_init (&lock->waiting_writers))\n    return errno;\n  lock->waiting_writers_count = 0;\n  lock->runcount = 0;\n  lock->initialized = 1;\n  return 0;\n}",
        "lines": 14,
        "depth": 10,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_rwlock_rdlock_multithreaded": [
      {
        "start_point": [
          77,
          0
        ],
        "end_point": [
          101,
          1
        ],
        "content": "int\nglthread_rwlock_rdlock_multithreaded (gl_rwlock_t *lock)\n{\n  if (!lock->initialized)\n    {\n      int err;\n\n      err = pthread_mutex_lock (&lock->guard);\n      if (err != 0)\n        return err;\n      if (!lock->initialized)\n        {\n          err = glthread_rwlock_init_multithreaded (lock);\n          if (err != 0)\n            {\n              pthread_mutex_unlock (&lock->guard);\n              return err;\n            }\n        }\n      err = pthread_mutex_unlock (&lock->guard);\n      if (err != 0)\n        return err;\n    }\n  return pthread_rwlock_rdlock (&lock->rwlock);\n}",
        "lines": 25,
        "depth": 14,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          174,
          0
        ],
        "end_point": [
          199,
          1
        ],
        "content": "int\nglthread_rwlock_rdlock_multithreaded (gl_rwlock_t *lock)\n{\n  int err;\n\n  err = pthread_mutex_lock (&lock->lock);\n  if (err != 0)\n    return err;\n  /* Test whether only readers are currently running, and whether the runcount\n     field will not overflow, and whether no writer is waiting.  The latter\n     condition is because POSIX recommends that \"write locks shall take\n     precedence over read locks\", to avoid \"writer starvation\".  */\n  while (!(lock->runcount + 1 > 0 && lock->waiting_writers_count == 0))\n    {\n      /* This thread has to wait for a while.  Enqueue it among the\n         waiting_readers.  */\n      err = pthread_cond_wait (&lock->waiting_readers, &lock->lock);\n      if (err != 0)\n        {\n          pthread_mutex_unlock (&lock->lock);\n          return err;\n        }\n    }\n  lock->runcount++;\n  return pthread_mutex_unlock (&lock->lock);\n}",
        "lines": 26,
        "depth": 12,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          527,
          0
        ],
        "end_point": [
          551,
          1
        ],
        "content": "int\nglthread_rwlock_rdlock_multithreaded (gl_rwlock_t *lock)\n{\n  if (!lock->initialized)\n    glthread_rwlock_init_multithreaded (lock);\n  if (!pth_mutex_acquire (&lock->lock, 0, NULL))\n    return errno;\n  /* Test whether only readers are currently running, and whether the runcount\n     field will not overflow, and whether no writer is waiting.  The latter\n     condition is because POSIX recommends that \"write locks shall take\n     precedence over read locks\", to avoid \"writer starvation\".  */\n  while (!(lock->runcount + 1 > 0 && lock->waiting_writers_count == 0))\n    {\n      /* This thread has to wait for a while.  Enqueue it among the\n         waiting_readers.  */\n      if (!pth_cond_await (&lock->waiting_readers, &lock->lock, NULL))\n        {\n          int err = errno;\n          pth_mutex_release (&lock->lock);\n          return err;\n        }\n    }\n  lock->runcount++;\n  return (!pth_mutex_release (&lock->lock) ? errno : 0);\n}",
        "lines": 25,
        "depth": 12,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_rwlock_wrlock_multithreaded": [
      {
        "start_point": [
          103,
          0
        ],
        "end_point": [
          127,
          1
        ],
        "content": "int\nglthread_rwlock_wrlock_multithreaded (gl_rwlock_t *lock)\n{\n  if (!lock->initialized)\n    {\n      int err;\n\n      err = pthread_mutex_lock (&lock->guard);\n      if (err != 0)\n        return err;\n      if (!lock->initialized)\n        {\n          err = glthread_rwlock_init_multithreaded (lock);\n          if (err != 0)\n            {\n              pthread_mutex_unlock (&lock->guard);\n              return err;\n            }\n        }\n      err = pthread_mutex_unlock (&lock->guard);\n      if (err != 0)\n        return err;\n    }\n  return pthread_rwlock_wrlock (&lock->rwlock);\n}",
        "lines": 25,
        "depth": 14,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          201,
          0
        ],
        "end_point": [
          226,
          1
        ],
        "content": "int\nglthread_rwlock_wrlock_multithreaded (gl_rwlock_t *lock)\n{\n  int err;\n\n  err = pthread_mutex_lock (&lock->lock);\n  if (err != 0)\n    return err;\n  /* Test whether no readers or writers are currently running.  */\n  while (!(lock->runcount == 0))\n    {\n      /* This thread has to wait for a while.  Enqueue it among the\n         waiting_writers.  */\n      lock->waiting_writers_count++;\n      err = pthread_cond_wait (&lock->waiting_writers, &lock->lock);\n      if (err != 0)\n        {\n          lock->waiting_writers_count--;\n          pthread_mutex_unlock (&lock->lock);\n          return err;\n        }\n      lock->waiting_writers_count--;\n    }\n  lock->runcount--; /* runcount becomes -1 */\n  return pthread_mutex_unlock (&lock->lock);\n}",
        "lines": 26,
        "depth": 12,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          553,
          0
        ],
        "end_point": [
          577,
          1
        ],
        "content": "int\nglthread_rwlock_wrlock_multithreaded (gl_rwlock_t *lock)\n{\n  if (!lock->initialized)\n    glthread_rwlock_init_multithreaded (lock);\n  if (!pth_mutex_acquire (&lock->lock, 0, NULL))\n    return errno;\n  /* Test whether no readers or writers are currently running.  */\n  while (!(lock->runcount == 0))\n    {\n      /* This thread has to wait for a while.  Enqueue it among the\n         waiting_writers.  */\n      lock->waiting_writers_count++;\n      if (!pth_cond_await (&lock->waiting_writers, &lock->lock, NULL))\n        {\n          int err = errno;\n          lock->waiting_writers_count--;\n          pth_mutex_release (&lock->lock);\n          return err;\n        }\n      lock->waiting_writers_count--;\n    }\n  lock->runcount--; /* runcount becomes -1 */\n  return (!pth_mutex_release (&lock->lock) ? errno : 0);\n}",
        "lines": 25,
        "depth": 12,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_rwlock_unlock_multithreaded": [
      {
        "start_point": [
          129,
          0
        ],
        "end_point": [
          135,
          1
        ],
        "content": "int\nglthread_rwlock_unlock_multithreaded (gl_rwlock_t *lock)\n{\n  if (!lock->initialized)\n    return EINVAL;\n  return pthread_rwlock_unlock (&lock->rwlock);\n}",
        "lines": 7,
        "depth": 8,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          228,
          0
        ],
        "end_point": [
          282,
          1
        ],
        "content": "int\nglthread_rwlock_unlock_multithreaded (gl_rwlock_t *lock)\n{\n  int err;\n\n  err = pthread_mutex_lock (&lock->lock);\n  if (err != 0)\n    return err;\n  if (lock->runcount < 0)\n    {\n      /* Drop a writer lock.  */\n      if (!(lock->runcount == -1))\n        {\n          pthread_mutex_unlock (&lock->lock);\n          return EINVAL;\n        }\n      lock->runcount = 0;\n    }\n  else\n    {\n      /* Drop a reader lock.  */\n      if (!(lock->runcount > 0))\n        {\n          pthread_mutex_unlock (&lock->lock);\n          return EINVAL;\n        }\n      lock->runcount--;\n    }\n  if (lock->runcount == 0)\n    {\n      /* POSIX recommends that \"write locks shall take precedence over read\n         locks\", to avoid \"writer starvation\".  */\n      if (lock->waiting_writers_count > 0)\n        {\n          /* Wake up one of the waiting writers.  */\n          err = pthread_cond_signal (&lock->waiting_writers);\n          if (err != 0)\n            {\n              pthread_mutex_unlock (&lock->lock);\n              return err;\n            }\n        }\n      else\n        {\n          /* Wake up all waiting readers.  */\n          err = pthread_cond_broadcast (&lock->waiting_readers);\n          if (err != 0)\n            {\n              pthread_mutex_unlock (&lock->lock);\n              return err;\n            }\n        }\n    }\n  return pthread_mutex_unlock (&lock->lock);\n}",
        "lines": 55,
        "depth": 14,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          579,
          0
        ],
        "end_point": [
          634,
          1
        ],
        "content": "int\nglthread_rwlock_unlock_multithreaded (gl_rwlock_t *lock)\n{\n  int err;\n\n  if (!lock->initialized)\n    return EINVAL;\n  if (!pth_mutex_acquire (&lock->lock, 0, NULL))\n    return errno;\n  if (lock->runcount < 0)\n    {\n      /* Drop a writer lock.  */\n      if (!(lock->runcount == -1))\n        {\n          pth_mutex_release (&lock->lock);\n          return EINVAL;\n        }\n      lock->runcount = 0;\n    }\n  else\n    {\n      /* Drop a reader lock.  */\n      if (!(lock->runcount > 0))\n        {\n          pth_mutex_release (&lock->lock);\n          return EINVAL;\n        }\n      lock->runcount--;\n    }\n  if (lock->runcount == 0)\n    {\n      /* POSIX recommends that \"write locks shall take precedence over read\n         locks\", to avoid \"writer starvation\".  */\n      if (lock->waiting_writers_count > 0)\n        {\n          /* Wake up one of the waiting writers.  */\n          if (!pth_cond_notify (&lock->waiting_writers, FALSE))\n            {\n              int err = errno;\n              pth_mutex_release (&lock->lock);\n              return err;\n            }\n        }\n      else\n        {\n          /* Wake up all waiting readers.  */\n          if (!pth_cond_notify (&lock->waiting_readers, TRUE))\n            {\n              int err = errno;\n              pth_mutex_release (&lock->lock);\n              return err;\n            }\n        }\n    }\n  return (!pth_mutex_release (&lock->lock) ? errno : 0);\n}",
        "lines": 56,
        "depth": 14,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_rwlock_destroy_multithreaded": [
      {
        "start_point": [
          137,
          0
        ],
        "end_point": [
          149,
          1
        ],
        "content": "int\nglthread_rwlock_destroy_multithreaded (gl_rwlock_t *lock)\n{\n  int err;\n\n  if (!lock->initialized)\n    return EINVAL;\n  err = pthread_rwlock_destroy (&lock->rwlock);\n  if (err != 0)\n    return err;\n  lock->initialized = 0;\n  return 0;\n}",
        "lines": 13,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          284,
          0
        ],
        "end_point": [
          299,
          1
        ],
        "content": "int\nglthread_rwlock_destroy_multithreaded (gl_rwlock_t *lock)\n{\n  int err;\n\n  err = pthread_mutex_destroy (&lock->lock);\n  if (err != 0)\n    return err;\n  err = pthread_cond_destroy (&lock->waiting_readers);\n  if (err != 0)\n    return err;\n  err = pthread_cond_destroy (&lock->waiting_writers);\n  if (err != 0)\n    return err;\n  return 0;\n}",
        "lines": 16,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          636,
          0
        ],
        "end_point": [
          641,
          1
        ],
        "content": "int\nglthread_rwlock_destroy_multithreaded (gl_rwlock_t *lock)\n{\n  lock->initialized = 0;\n  return 0;\n}",
        "lines": 6,
        "depth": 6,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_recursive_lock_init_multithreaded": [
      {
        "start_point": [
          309,
          0
        ],
        "end_point": [
          334,
          1
        ],
        "content": "int\nglthread_recursive_lock_init_multithreaded (gl_recursive_lock_t *lock)\n{\n  pthread_mutexattr_t attributes;\n  int err;\n\n  err = pthread_mutexattr_init (&attributes);\n  if (err != 0)\n    return err;\n  err = pthread_mutexattr_settype (&attributes, PTHREAD_MUTEX_RECURSIVE);\n  if (err != 0)\n    {\n      pthread_mutexattr_destroy (&attributes);\n      return err;\n    }\n  err = pthread_mutex_init (lock, &attributes);\n  if (err != 0)\n    {\n      pthread_mutexattr_destroy (&attributes);\n      return err;\n    }\n  err = pthread_mutexattr_destroy (&attributes);\n  if (err != 0)\n    return err;\n  return 0;\n}",
        "lines": 26,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          338,
          0
        ],
        "end_point": [
          364,
          1
        ],
        "content": "int\nglthread_recursive_lock_init_multithreaded (gl_recursive_lock_t *lock)\n{\n  pthread_mutexattr_t attributes;\n  int err;\n\n  err = pthread_mutexattr_init (&attributes);\n  if (err != 0)\n    return err;\n  err = pthread_mutexattr_settype (&attributes, PTHREAD_MUTEX_RECURSIVE);\n  if (err != 0)\n    {\n      pthread_mutexattr_destroy (&attributes);\n      return err;\n    }\n  err = pthread_mutex_init (&lock->recmutex, &attributes);\n  if (err != 0)\n    {\n      pthread_mutexattr_destroy (&attributes);\n      return err;\n    }\n  err = pthread_mutexattr_destroy (&attributes);\n  if (err != 0)\n    return err;\n  lock->initialized = 1;\n  return 0;\n}",
        "lines": 27,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          418,
          0
        ],
        "end_point": [
          429,
          1
        ],
        "content": "int\nglthread_recursive_lock_init_multithreaded (gl_recursive_lock_t *lock)\n{\n  int err;\n\n  err = pthread_mutex_init (&lock->mutex, NULL);\n  if (err != 0)\n    return err;\n  lock->owner = (pthread_t) 0;\n  lock->depth = 0;\n  return 0;\n}",
        "lines": 12,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          692,
          0
        ],
        "end_point": [
          703,
          1
        ],
        "content": "int\nglthread_recursive_lock_init_multithreaded (gl_recursive_lock_t *lock)\n{\n  int err;\n\n  err = mutex_init (&lock->mutex, USYNC_THREAD, NULL);\n  if (err != 0)\n    return err;\n  lock->owner = (thread_t) 0;\n  lock->depth = 0;\n  return 0;\n}",
        "lines": 12,
        "depth": 9,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_recursive_lock_lock_multithreaded": [
      {
        "start_point": [
          366,
          0
        ],
        "end_point": [
          390,
          1
        ],
        "content": "int\nglthread_recursive_lock_lock_multithreaded (gl_recursive_lock_t *lock)\n{\n  if (!lock->initialized)\n    {\n      int err;\n\n      err = pthread_mutex_lock (&lock->guard);\n      if (err != 0)\n        return err;\n      if (!lock->initialized)\n        {\n          err = glthread_recursive_lock_init_multithreaded (lock);\n          if (err != 0)\n            {\n              pthread_mutex_unlock (&lock->guard);\n              return err;\n            }\n        }\n      err = pthread_mutex_unlock (&lock->guard);\n      if (err != 0)\n        return err;\n    }\n  return pthread_mutex_lock (&lock->recmutex);\n}",
        "lines": 25,
        "depth": 14,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          431,
          0
        ],
        "end_point": [
          450,
          1
        ],
        "content": "int\nglthread_recursive_lock_lock_multithreaded (gl_recursive_lock_t *lock)\n{\n  pthread_t self = pthread_self ();\n  if (lock->owner != self)\n    {\n      int err;\n\n      err = pthread_mutex_lock (&lock->mutex);\n      if (err != 0)\n        return err;\n      lock->owner = self;\n    }\n  if (++(lock->depth) == 0) /* wraparound? */\n    {\n      lock->depth--;\n      return EAGAIN;\n    }\n  return 0;\n}",
        "lines": 20,
        "depth": 11,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          705,
          0
        ],
        "end_point": [
          724,
          1
        ],
        "content": "int\nglthread_recursive_lock_lock_multithreaded (gl_recursive_lock_t *lock)\n{\n  thread_t self = thr_self ();\n  if (lock->owner != self)\n    {\n      int err;\n\n      err = mutex_lock (&lock->mutex);\n      if (err != 0)\n        return err;\n      lock->owner = self;\n    }\n  if (++(lock->depth) == 0) /* wraparound? */\n    {\n      lock->depth--;\n      return EAGAIN;\n    }\n  return 0;\n}",
        "lines": 20,
        "depth": 11,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_recursive_lock_unlock_multithreaded": [
      {
        "start_point": [
          392,
          0
        ],
        "end_point": [
          398,
          1
        ],
        "content": "int\nglthread_recursive_lock_unlock_multithreaded (gl_recursive_lock_t *lock)\n{\n  if (!lock->initialized)\n    return EINVAL;\n  return pthread_mutex_unlock (&lock->recmutex);\n}",
        "lines": 7,
        "depth": 8,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          452,
          0
        ],
        "end_point": [
          466,
          1
        ],
        "content": "int\nglthread_recursive_lock_unlock_multithreaded (gl_recursive_lock_t *lock)\n{\n  if (lock->owner != pthread_self ())\n    return EPERM;\n  if (lock->depth == 0)\n    return EINVAL;\n  if (--(lock->depth) == 0)\n    {\n      lock->owner = (pthread_t) 0;\n      return pthread_mutex_unlock (&lock->mutex);\n    }\n  else\n    return 0;\n}",
        "lines": 15,
        "depth": 10,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          726,
          0
        ],
        "end_point": [
          740,
          1
        ],
        "content": "int\nglthread_recursive_lock_unlock_multithreaded (gl_recursive_lock_t *lock)\n{\n  if (lock->owner != thr_self ())\n    return EPERM;\n  if (lock->depth == 0)\n    return EINVAL;\n  if (--(lock->depth) == 0)\n    {\n      lock->owner = (thread_t) 0;\n      return mutex_unlock (&lock->mutex);\n    }\n  else\n    return 0;\n}",
        "lines": 15,
        "depth": 10,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_recursive_lock_destroy_multithreaded": [
      {
        "start_point": [
          400,
          0
        ],
        "end_point": [
          412,
          1
        ],
        "content": "int\nglthread_recursive_lock_destroy_multithreaded (gl_recursive_lock_t *lock)\n{\n  int err;\n\n  if (!lock->initialized)\n    return EINVAL;\n  err = pthread_mutex_destroy (&lock->recmutex);\n  if (err != 0)\n    return err;\n  lock->initialized = 0;\n  return 0;\n}",
        "lines": 13,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          468,
          0
        ],
        "end_point": [
          474,
          1
        ],
        "content": "int\nglthread_recursive_lock_destroy_multithreaded (gl_recursive_lock_t *lock)\n{\n  if (lock->owner != (pthread_t) 0)\n    return EBUSY;\n  return pthread_mutex_destroy (&lock->mutex);\n}",
        "lines": 7,
        "depth": 8,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          742,
          0
        ],
        "end_point": [
          748,
          1
        ],
        "content": "int\nglthread_recursive_lock_destroy_multithreaded (gl_recursive_lock_t *lock)\n{\n  if (lock->owner != (thread_t) 0)\n    return EBUSY;\n  return mutex_destroy (&lock->mutex);\n}",
        "lines": 7,
        "depth": 8,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_once_singlethreaded": [
      {
        "start_point": [
          482,
          0
        ],
        "end_point": [
          496,
          1
        ],
        "content": "int\nglthread_once_singlethreaded (pthread_once_t *once_control)\n{\n  /* We don't know whether pthread_once_t is an integer type, a floating-point\n     type, a pointer type, or a structure type.  */\n  char *firstbyte = (char *)once_control;\n  if (*firstbyte == *(const char *)&fresh_once)\n    {\n      /* First time use of once_control.  Invert the first byte.  */\n      *firstbyte = ~ *(const char *)&fresh_once;\n      return 1;\n    }\n  else\n    return 0;\n}",
        "lines": 15,
        "depth": 12,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          664,
          0
        ],
        "end_point": [
          676,
          1
        ],
        "content": "int\nglthread_once_singlethreaded (pth_once_t *once_control)\n{\n  /* We know that pth_once_t is an integer type.  */\n  if (*once_control == PTH_ONCE_INIT)\n    {\n      /* First time use of once_control.  Invert the marker.  */\n      *once_control = ~ PTH_ONCE_INIT;\n      return 1;\n    }\n  else\n    return 0;\n}",
        "lines": 13,
        "depth": 8,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          775,
          0
        ],
        "end_point": [
          787,
          1
        ],
        "content": "int\nglthread_once_singlethreaded (gl_once_t *once_control)\n{\n  /* We know that gl_once_t contains an integer type.  */\n  if (!once_control->inited)\n    {\n      /* First time use of once_control.  Invert the marker.  */\n      once_control->inited = ~ 0;\n      return 1;\n    }\n  else\n    return 0;\n}",
        "lines": 13,
        "depth": 8,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_once_call": {
      "start_point": [
        649,
        0
      ],
      "end_point": [
        655,
        1
      ],
      "content": "static void\nglthread_once_call (void *arg)\n{\n  void (**gl_once_temp_addr) (void) = (void (**) (void)) arg;\n  void (*initfunction) (void) = *gl_once_temp_addr;\n  initfunction ();\n}",
      "lines": 7,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "glthread_once_multithreaded": [
      {
        "start_point": [
          657,
          0
        ],
        "end_point": [
          662,
          1
        ],
        "content": "int\nglthread_once_multithreaded (pth_once_t *once_control, void (*initfunction) (void))\n{\n  void (*temp) (void) = initfunction;\n  return (!pth_once (once_control, glthread_once_call, &temp) ? errno : 0);\n}",
        "lines": 6,
        "depth": 10,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          752,
          0
        ],
        "end_point": [
          773,
          1
        ],
        "content": "int\nglthread_once_multithreaded (gl_once_t *once_control, void (*initfunction) (void))\n{\n  if (!once_control->inited)\n    {\n      int err;\n\n      /* Use the mutex to guarantee that if another thread is already calling\n         the initfunction, this thread waits until it's finished.  */\n      err = mutex_lock (&once_control->mutex);\n      if (err != 0)\n        return err;\n      if (!once_control->inited)\n        {\n          once_control->inited = 1;\n          initfunction ();\n        }\n      return mutex_unlock (&once_control->mutex);\n    }\n  else\n    return 0;\n}",
        "lines": 22,
        "depth": 11,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_lock_init_func": {
      "start_point": [
        797,
        0
      ],
      "end_point": [
        802,
        1
      ],
      "content": "void\nglthread_lock_init_func (gl_lock_t *lock)\n{\n  InitializeCriticalSection (&lock->lock);\n  lock->guard.done = 1;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "glthread_lock_lock_func": {
      "start_point": [
        804,
        0
      ],
      "end_point": [
        820,
        1
      ],
      "content": "int\nglthread_lock_lock_func (gl_lock_t *lock)\n{\n  if (!lock->guard.done)\n    {\n      if (InterlockedIncrement (&lock->guard.started) == 0)\n        /* This thread is the first one to need this lock.  Initialize it.  */\n        glthread_lock_init (lock);\n      else\n        /* Yield the CPU while waiting for another thread to finish\n           initializing this lock.  */\n        while (!lock->guard.done)\n          Sleep (0);\n    }\n  EnterCriticalSection (&lock->lock);\n  return 0;\n}",
      "lines": 17,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "glthread_lock_unlock_func": {
      "start_point": [
        822,
        0
      ],
      "end_point": [
        829,
        1
      ],
      "content": "int\nglthread_lock_unlock_func (gl_lock_t *lock)\n{\n  if (!lock->guard.done)\n    return EINVAL;\n  LeaveCriticalSection (&lock->lock);\n  return 0;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "glthread_lock_destroy_func": {
      "start_point": [
        831,
        0
      ],
      "end_point": [
        839,
        1
      ],
      "content": "int\nglthread_lock_destroy_func (gl_lock_t *lock)\n{\n  if (!lock->guard.done)\n    return EINVAL;\n  DeleteCriticalSection (&lock->lock);\n  lock->guard.done = 0;\n  return 0;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "gl_waitqueue_init": {
      "start_point": [
        846,
        0
      ],
      "end_point": [
        853,
        1
      ],
      "content": "static void\ngl_waitqueue_init (gl_waitqueue_t *wq)\n{\n  wq->array = NULL;\n  wq->count = 0;\n  wq->alloc = 0;\n  wq->offset = 0;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "gl_waitqueue_add": {
      "start_point": [
        857,
        0
      ],
      "end_point": [
        904,
        1
      ],
      "content": "static HANDLE\ngl_waitqueue_add (gl_waitqueue_t *wq)\n{\n  HANDLE event;\n  unsigned int index;\n\n  if (wq->count == wq->alloc)\n    {\n      unsigned int new_alloc = 2 * wq->alloc + 1;\n      HANDLE *new_array =\n        (HANDLE *) realloc (wq->array, new_alloc * sizeof (HANDLE));\n      if (new_array == NULL)\n        /* No more memory.  */\n        return INVALID_HANDLE_VALUE;\n      /* Now is a good opportunity to rotate the array so that its contents\n         starts at offset 0.  */\n      if (wq->offset > 0)\n        {\n          unsigned int old_count = wq->count;\n          unsigned int old_alloc = wq->alloc;\n          unsigned int old_offset = wq->offset;\n          unsigned int i;\n          if (old_offset + old_count > old_alloc)\n            {\n              unsigned int limit = old_offset + old_count - old_alloc;\n              for (i = 0; i < limit; i++)\n                new_array[old_alloc + i] = new_array[i];\n            }\n          for (i = 0; i < old_count; i++)\n            new_array[i] = new_array[old_offset + i];\n          wq->offset = 0;\n        }\n      wq->array = new_array;\n      wq->alloc = new_alloc;\n    }\n  /* Whether the created event is a manual-reset one or an auto-reset one,\n     does not matter, since we will wait on it only once.  */\n  event = CreateEvent (NULL, TRUE, FALSE, NULL);\n  if (event == INVALID_HANDLE_VALUE)\n    /* No way to allocate an event.  */\n    return INVALID_HANDLE_VALUE;\n  index = wq->offset + wq->count;\n  if (index >= wq->alloc)\n    index -= wq->alloc;\n  wq->array[index] = event;\n  wq->count++;\n  return event;\n}",
      "lines": 48,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "HANDLE"
      ]
    },
    "gl_waitqueue_notify_first": {
      "start_point": [
        907,
        0
      ],
      "end_point": [
        915,
        1
      ],
      "content": "static void\ngl_waitqueue_notify_first (gl_waitqueue_t *wq)\n{\n  SetEvent (wq->array[wq->offset + 0]);\n  wq->offset++;\n  wq->count--;\n  if (wq->count == 0 || wq->offset == wq->alloc)\n    wq->offset = 0;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "gl_waitqueue_notify_all": {
      "start_point": [
        918,
        0
      ],
      "end_point": [
        932,
        1
      ],
      "content": "static void\ngl_waitqueue_notify_all (gl_waitqueue_t *wq)\n{\n  unsigned int i;\n\n  for (i = 0; i < wq->count; i++)\n    {\n      unsigned int index = wq->offset + i;\n      if (index >= wq->alloc)\n        index -= wq->alloc;\n      SetEvent (wq->array[index]);\n    }\n  wq->count = 0;\n  wq->offset = 0;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "glthread_rwlock_init_func": {
      "start_point": [
        934,
        0
      ],
      "end_point": [
        942,
        1
      ],
      "content": "void\nglthread_rwlock_init_func (gl_rwlock_t *lock)\n{\n  InitializeCriticalSection (&lock->lock);\n  gl_waitqueue_init (&lock->waiting_readers);\n  gl_waitqueue_init (&lock->waiting_writers);\n  lock->runcount = 0;\n  lock->guard.done = 1;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "glthread_rwlock_rdlock_func": {
      "start_point": [
        944,
        0
      ],
      "end_point": [
        998,
        1
      ],
      "content": "int\nglthread_rwlock_rdlock_func (gl_rwlock_t *lock)\n{\n  if (!lock->guard.done)\n    {\n      if (InterlockedIncrement (&lock->guard.started) == 0)\n        /* This thread is the first one to need this lock.  Initialize it.  */\n        glthread_rwlock_init (lock);\n      else\n        /* Yield the CPU while waiting for another thread to finish\n           initializing this lock.  */\n        while (!lock->guard.done)\n          Sleep (0);\n    }\n  EnterCriticalSection (&lock->lock);\n  /* Test whether only readers are currently running, and whether the runcount\n     field will not overflow, and whether no writer is waiting.  The latter\n     condition is because POSIX recommends that \"write locks shall take\n     precedence over read locks\", to avoid \"writer starvation\".  */\n  if (!(lock->runcount + 1 > 0 && lock->waiting_writers.count == 0))\n    {\n      /* This thread has to wait for a while.  Enqueue it among the\n         waiting_readers.  */\n      HANDLE event = gl_waitqueue_add (&lock->waiting_readers);\n      if (event != INVALID_HANDLE_VALUE)\n        {\n          DWORD result;\n          LeaveCriticalSection (&lock->lock);\n          /* Wait until another thread signals this event.  */\n          result = WaitForSingleObject (event, INFINITE);\n          if (result == WAIT_FAILED || result == WAIT_TIMEOUT)\n            abort ();\n          CloseHandle (event);\n          /* The thread which signalled the event already did the bookkeeping:\n             removed us from the waiting_readers, incremented lock->runcount.  */\n          if (!(lock->runcount > 0))\n            abort ();\n          return 0;\n        }\n      else\n        {\n          /* Allocation failure.  Weird.  */\n          do\n            {\n              LeaveCriticalSection (&lock->lock);\n              Sleep (1);\n              EnterCriticalSection (&lock->lock);\n            }\n          while (!(lock->runcount + 1 > 0));\n        }\n    }\n  lock->runcount++;\n  LeaveCriticalSection (&lock->lock);\n  return 0;\n}",
      "lines": 55,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "glthread_rwlock_wrlock_func": {
      "start_point": [
        1000,
        0
      ],
      "end_point": [
        1051,
        1
      ],
      "content": "int\nglthread_rwlock_wrlock_func (gl_rwlock_t *lock)\n{\n  if (!lock->guard.done)\n    {\n      if (InterlockedIncrement (&lock->guard.started) == 0)\n        /* This thread is the first one to need this lock.  Initialize it.  */\n        glthread_rwlock_init (lock);\n      else\n        /* Yield the CPU while waiting for another thread to finish\n           initializing this lock.  */\n        while (!lock->guard.done)\n          Sleep (0);\n    }\n  EnterCriticalSection (&lock->lock);\n  /* Test whether no readers or writers are currently running.  */\n  if (!(lock->runcount == 0))\n    {\n      /* This thread has to wait for a while.  Enqueue it among the\n         waiting_writers.  */\n      HANDLE event = gl_waitqueue_add (&lock->waiting_writers);\n      if (event != INVALID_HANDLE_VALUE)\n        {\n          DWORD result;\n          LeaveCriticalSection (&lock->lock);\n          /* Wait until another thread signals this event.  */\n          result = WaitForSingleObject (event, INFINITE);\n          if (result == WAIT_FAILED || result == WAIT_TIMEOUT)\n            abort ();\n          CloseHandle (event);\n          /* The thread which signalled the event already did the bookkeeping:\n             removed us from the waiting_writers, set lock->runcount = -1.  */\n          if (!(lock->runcount == -1))\n            abort ();\n          return 0;\n        }\n      else\n        {\n          /* Allocation failure.  Weird.  */\n          do\n            {\n              LeaveCriticalSection (&lock->lock);\n              Sleep (1);\n              EnterCriticalSection (&lock->lock);\n            }\n          while (!(lock->runcount == 0));\n        }\n    }\n  lock->runcount--; /* runcount becomes -1 */\n  LeaveCriticalSection (&lock->lock);\n  return 0;\n}",
      "lines": 52,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "glthread_rwlock_unlock_func": {
      "start_point": [
        1053,
        0
      ],
      "end_point": [
        1095,
        1
      ],
      "content": "int\nglthread_rwlock_unlock_func (gl_rwlock_t *lock)\n{\n  if (!lock->guard.done)\n    return EINVAL;\n  EnterCriticalSection (&lock->lock);\n  if (lock->runcount < 0)\n    {\n      /* Drop a writer lock.  */\n      if (!(lock->runcount == -1))\n        abort ();\n      lock->runcount = 0;\n    }\n  else\n    {\n      /* Drop a reader lock.  */\n      if (!(lock->runcount > 0))\n        {\n          LeaveCriticalSection (&lock->lock);\n          return EPERM;\n        }\n      lock->runcount--;\n    }\n  if (lock->runcount == 0)\n    {\n      /* POSIX recommends that \"write locks shall take precedence over read\n         locks\", to avoid \"writer starvation\".  */\n      if (lock->waiting_writers.count > 0)\n        {\n          /* Wake up one of the waiting writers.  */\n          lock->runcount--;\n          gl_waitqueue_notify_first (&lock->waiting_writers);\n        }\n      else\n        {\n          /* Wake up all waiting readers.  */\n          lock->runcount += lock->waiting_readers.count;\n          gl_waitqueue_notify_all (&lock->waiting_readers);\n        }\n    }\n  LeaveCriticalSection (&lock->lock);\n  return 0;\n}",
      "lines": 43,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "glthread_rwlock_destroy_func": {
      "start_point": [
        1097,
        0
      ],
      "end_point": [
        1111,
        1
      ],
      "content": "int\nglthread_rwlock_destroy_func (gl_rwlock_t *lock)\n{\n  if (!lock->guard.done)\n    return EINVAL;\n  if (lock->runcount != 0)\n    return EBUSY;\n  DeleteCriticalSection (&lock->lock);\n  if (lock->waiting_readers.array != NULL)\n    free (lock->waiting_readers.array);\n  if (lock->waiting_writers.array != NULL)\n    free (lock->waiting_writers.array);\n  lock->guard.done = 0;\n  return 0;\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "glthread_recursive_lock_init_func": {
      "start_point": [
        1115,
        0
      ],
      "end_point": [
        1122,
        1
      ],
      "content": "void\nglthread_recursive_lock_init_func (gl_recursive_lock_t *lock)\n{\n  lock->owner = 0;\n  lock->depth = 0;\n  InitializeCriticalSection (&lock->lock);\n  lock->guard.done = 1;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "glthread_recursive_lock_lock_func": {
      "start_point": [
        1124,
        0
      ],
      "end_point": [
        1152,
        1
      ],
      "content": "int\nglthread_recursive_lock_lock_func (gl_recursive_lock_t *lock)\n{\n  if (!lock->guard.done)\n    {\n      if (InterlockedIncrement (&lock->guard.started) == 0)\n        /* This thread is the first one to need this lock.  Initialize it.  */\n        glthread_recursive_lock_init (lock);\n      else\n        /* Yield the CPU while waiting for another thread to finish\n           initializing this lock.  */\n        while (!lock->guard.done)\n          Sleep (0);\n    }\n  {\n    DWORD self = GetCurrentThreadId ();\n    if (lock->owner != self)\n      {\n        EnterCriticalSection (&lock->lock);\n        lock->owner = self;\n      }\n    if (++(lock->depth) == 0) /* wraparound? */\n      {\n        lock->depth--;\n        return EAGAIN;\n      }\n  }\n  return 0;\n}",
      "lines": 29,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "glthread_recursive_lock_unlock_func": {
      "start_point": [
        1154,
        0
      ],
      "end_point": [
        1167,
        1
      ],
      "content": "int\nglthread_recursive_lock_unlock_func (gl_recursive_lock_t *lock)\n{\n  if (lock->owner != GetCurrentThreadId ())\n    return EPERM;\n  if (lock->depth == 0)\n    return EINVAL;\n  if (--(lock->depth) == 0)\n    {\n      lock->owner = 0;\n      LeaveCriticalSection (&lock->lock);\n    }\n  return 0;\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "glthread_recursive_lock_destroy_func": {
      "start_point": [
        1169,
        0
      ],
      "end_point": [
        1177,
        1
      ],
      "content": "int\nglthread_recursive_lock_destroy_func (gl_recursive_lock_t *lock)\n{\n  if (lock->owner != 0)\n    return EBUSY;\n  DeleteCriticalSection (&lock->lock);\n  lock->guard.done = 0;\n  return 0;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "glthread_once_func": {
      "start_point": [
        1181,
        0
      ],
      "end_point": [
        1216,
        1
      ],
      "content": "void\nglthread_once_func (gl_once_t *once_control, void (*initfunction) (void))\n{\n  if (once_control->inited <= 0)\n    {\n      if (InterlockedIncrement (&once_control->started) == 0)\n        {\n          /* This thread is the first one to come to this once_control.  */\n          InitializeCriticalSection (&once_control->lock);\n          EnterCriticalSection (&once_control->lock);\n          once_control->inited = 0;\n          initfunction ();\n          once_control->inited = 1;\n          LeaveCriticalSection (&once_control->lock);\n        }\n      else\n        {\n          /* Undo last operation.  */\n          InterlockedDecrement (&once_control->started);\n          /* Some other thread has already started the initialization.\n             Yield the CPU while waiting for the other thread to finish\n             initializing and taking the lock.  */\n          while (once_control->inited < 0)\n            Sleep (0);\n          if (once_control->inited <= 0)\n            {\n              /* Take the lock.  This blocks until the other thread has\n                 finished calling the initfunction.  */\n              EnterCriticalSection (&once_control->lock);\n              LeaveCriticalSection (&once_control->lock);\n              if (!(once_control->inited > 0))\n                abort ();\n            }\n        }\n    }\n}",
      "lines": 36,
      "depth": 15,
      "decorators": [
        "void"
      ]
    }
  },
  "sed/sed-4.5/lib/glthread/lock.h": {},
  "sed/sed-4.5/lib/glthread/threadlib.c": {
    "dummy_thread_func": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "static void *\ndummy_thread_func (void *arg)\n{\n  return arg;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void",
        "*\ndummy_thread_func (void *arg)",
        "*"
      ]
    },
    "glthread_in_use": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "int\nglthread_in_use (void)\n{\n  static int tested;\n  static int result; /* 1: linked with -lpthread, 0: only with libc */\n\n  if (!tested)\n    {\n      pthread_t thread;\n\n      if (pthread_create (&thread, NULL, dummy_thread_func, NULL) != 0)\n        /* Thread creation failed.  */\n        result = 0;\n      else\n        {\n          /* Thread creation works.  */\n          void *retval;\n          if (pthread_join (thread, &retval) != 0)\n            abort ();\n          result = 1;\n        }\n      tested = 1;\n    }\n  return result;\n}",
      "lines": 25,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/sed/compile.c": {
    "bad_command": {
      "start_point": [
        198,
        0
      ],
      "end_point": [
        205,
        1
      ],
      "content": "static void\nbad_command(char ch)\n{\n  const char *msg = _(UNKNOWN_CMD);\n  char *unknown_cmd = xmalloc(strlen(msg));\n  sprintf(unknown_cmd, msg, ch);\n  bad_prog(unknown_cmd);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bad_prog": {
      "start_point": [
        208,
        0
      ],
      "end_point": [
        221,
        1
      ],
      "content": "void\nbad_prog(const char *why)\n{\n  if (cur_input.name)\n    fprintf(stderr, _(\"%s: file %s line %lu: %s\\n\"),\n            myname, cur_input.name, (unsigned long)cur_input.line, why);\n  else\n    fprintf(stderr, _(\"%s: -e expression #%lu, char %lu: %s\\n\"),\n            myname,\n            (unsigned long)cur_input.string_expr_count,\n            (unsigned long)(prog.cur-prog.base),\n            why);\n  exit(EXIT_BAD_USAGE);\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "inchar": {
      "start_point": [
        227,
        0
      ],
      "end_point": [
        245,
        1
      ],
      "content": "static int\ninchar(void)\n{\n  int ch = EOF;\n\n  if (prog.cur)\n    {\n      if (prog.cur < prog.end)\n        ch = *prog.cur++;\n    }\n  else if (prog.file)\n    {\n      if (!feof(prog.file))\n        ch = getc(prog.file);\n    }\n  if (ch == '\\n')\n    ++cur_input.line;\n  return ch;\n}",
      "lines": 19,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "savchar": {
      "start_point": [
        248,
        0
      ],
      "end_point": [
        263,
        1
      ],
      "content": "static void\nsavchar(int ch)\n{\n  if (ch == EOF)\n    return;\n  if (ch == '\\n' && cur_input.line > 0)\n    --cur_input.line;\n  if (prog.cur)\n    {\n      if (prog.cur <= prog.base || *--prog.cur != ch)\n        panic(\"Called savchar() with unexpected pushback (%x)\",\n              (unsigned int) ch);\n    }\n  else\n    ungetc(ch, prog.file);\n}",
      "lines": 16,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "in_nonblank": {
      "start_point": [
        266,
        0
      ],
      "end_point": [
        274,
        1
      ],
      "content": "static int\nin_nonblank(void)\n{\n  int ch;\n  do\n    ch = inchar();\n    while (ISBLANK(ch));\n  return ch;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "read_end_of_cmd": {
      "start_point": [
        281,
        0
      ],
      "end_point": [
        289,
        1
      ],
      "content": "static void\nread_end_of_cmd (void)\n{\n  const int ch = in_nonblank();\n  if (ch == CLOSE_BRACE || ch == '#')\n    savchar(ch);\n  else if (ch != EOF && ch != '\\n' && ch != ';')\n    bad_prog(_(EXCESS_JUNK));\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "in_integer": {
      "start_point": [
        292,
        0
      ],
      "end_point": [
        304,
        1
      ],
      "content": "static countT\nin_integer (int ch)\n{\n  countT num = 0;\n\n  while (ISDIGIT(ch))\n    {\n      num = num * 10 + ch - '0';\n      ch = inchar();\n    }\n  savchar(ch);\n  return num;\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "countT"
      ]
    },
    "add_then_next": {
      "start_point": [
        306,
        0
      ],
      "end_point": [
        311,
        1
      ],
      "content": "static int\nadd_then_next(struct buffer *b, int ch)\n{\n  add1_buffer(b, ch);\n  return inchar();\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "convert_number": {
      "start_point": [
        313,
        0
      ],
      "end_point": [
        351,
        1
      ],
      "content": "static char *\nconvert_number(char *result, char *buf, const char *bufend, int base)\n{\n  int n = 0;\n  int max = 1;\n  char *p;\n\n  for (p=buf+1; p < bufend && max <= 255; ++p, max *= base)\n    {\n      int d = -1;\n      switch (*p)\n        {\n        case '0': d = 0x0; break;\n        case '1': d = 0x1; break;\n        case '2': d = 0x2; break;\n        case '3': d = 0x3; break;\n        case '4': d = 0x4; break;\n        case '5': d = 0x5; break;\n        case '6': d = 0x6; break;\n        case '7': d = 0x7; break;\n        case '8': d = 0x8; break;\n        case '9': d = 0x9; break;\n        case 'A': case 'a': d = 0xa; break;\n        case 'B': case 'b': d = 0xb; break;\n        case 'C': case 'c': d = 0xc; break;\n        case 'D': case 'd': d = 0xd; break;\n        case 'E': case 'e': d = 0xe; break;\n        case 'F': case 'f': d = 0xf; break;\n        }\n      if (d < 0 || base <= d)\n        break;\n      n = n * base + d;\n    }\n  if (p == buf+1)\n    *result = *buf;\n  else\n    *result = n;\n  return p;\n}",
      "lines": 39,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nconvert_number(char *result, char *buf, const char *bufend, int base)",
        "*"
      ]
    },
    "read_filename": {
      "start_point": [
        355,
        0
      ],
      "end_point": [
        380,
        1
      ],
      "content": "static struct buffer *\nread_filename(void)\n{\n  struct buffer *b;\n  int ch;\n\n  if (sandbox)\n    bad_prog(_(DISALLOWED_CMD));\n\n  b = init_buffer();\n  ch = in_nonblank();\n  while (ch != EOF && ch != '\\n')\n    {\n#if 0 /*XXX ZZZ 1998-09-12 kpp: added, then had second thoughts*/\n      if (posixicity == POSIXLY_EXTENDED)\n        if (ch == ';' || ch == '#')\n          {\n            savchar(ch);\n            break;\n          }\n#endif\n      ch = add_then_next(b, ch);\n    }\n  add1_buffer(b, '\\0');\n  return b;\n}",
      "lines": 26,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "struct buffer",
        "struct",
        "buffer",
        "*\nread_filename(void)",
        "*"
      ]
    },
    "get_openfile": {
      "start_point": [
        382,
        0
      ],
      "end_point": [
        423,
        1
      ],
      "content": "static struct output *\nget_openfile (struct output **file_ptrs, const char *mode, int fail)\n{\n  struct buffer *b;\n  char *file_name;\n  struct output *p;\n\n  b = read_filename();\n  file_name = get_buffer(b);\n  for (p=*file_ptrs; p; p=p->link)\n    if (strcmp(p->name, file_name) == 0)\n      break;\n\n  if (posixicity == POSIXLY_EXTENDED)\n    {\n      /* Check whether it is a special file (stdin, stdout or stderr) */\n      struct special_files *special = special_files;\n\n      /* std* sometimes are not constants, so they\n         cannot be used in the initializer for special_files */\n      my_stdin = stdin; my_stdout = stdout; my_stderr = stderr;\n      for (special = special_files; special->outf.name; special++)\n        if (strcmp(special->outf.name, file_name) == 0)\n          {\n            special->outf.fp = *special->pfp;\n            free_buffer (b);\n            return &special->outf;\n          }\n    }\n\n  if (!p)\n    {\n      p = OB_MALLOC(&obs, 1, struct output);\n      p->name = ck_strdup(file_name);\n      p->fp = ck_fopen(p->name, mode, fail);\n      p->missing_newline = false;\n      p->link = *file_ptrs;\n      *file_ptrs = p;\n    }\n  free_buffer(b);\n  return p;\n}",
      "lines": 42,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "struct output",
        "struct",
        "output",
        "*\nget_openfile (struct output **file_ptrs, const char *mode, int fail)",
        "*"
      ]
    },
    "next_cmd_entry": {
      "start_point": [
        426,
        0
      ],
      "end_point": [
        448,
        1
      ],
      "content": "static struct sed_cmd *\nnext_cmd_entry (struct vector **vectorp)\n{\n  struct sed_cmd *cmd;\n  struct vector *v;\n\n  v = *vectorp;\n  if (v->v_length == v->v_allocated)\n    {\n      v->v_allocated += VECTOR_ALLOC_INCREMENT;\n      v->v = REALLOC(v->v, v->v_allocated, struct sed_cmd);\n    }\n\n  cmd = v->v + v->v_length;\n  cmd->a1 = NULL;\n  cmd->a2 = NULL;\n  cmd->range_state = RANGE_INACTIVE;\n  cmd->addr_bang = false;\n  cmd->cmd = '\\0';\t/* something invalid, to catch bugs early */\n\n  *vectorp  = v;\n  return cmd;\n}",
      "lines": 23,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "struct sed_cmd",
        "struct",
        "sed_cmd",
        "*\nnext_cmd_entry (struct vector **vectorp)",
        "*"
      ]
    },
    "snarf_char_class": {
      "start_point": [
        450,
        0
      ],
      "end_point": [
        525,
        1
      ],
      "content": "static int\nsnarf_char_class (struct buffer *b, mbstate_t *cur_stat)\n{\n  int ch;\n  int state = 0;\n  int delim IF_LINT ( = 0) ;\n\n  ch = inchar();\n  if (ch == '^')\n    ch = add_then_next(b, ch);\n  if (ch == CLOSE_BRACKET)\n    ch = add_then_next(b, ch);\n\n  /* States are:\n        0 outside a collation element, character class or collation class\n        1 after the bracket\n        2 after the opening ./:/=\n        3 after the closing ./:/= */\n\n  for (;; ch = add_then_next (b, ch))\n    {\n      const int mb_char = IS_MB_CHAR (ch, cur_stat);\n\n      switch (ch)\n        {\n        case EOF:\n        case '\\n':\n          return ch;\n\n        case '.':\n        case ':':\n        case '=':\n          if (mb_char)\n            continue;\n\n          if (state == 1)\n            {\n              delim = ch;\n              state = 2;\n            }\n          else if (state == 2 && ch == delim)\n            state = 3;\n          else\n            break;\n\n          continue;\n\n        case OPEN_BRACKET:\n          if (mb_char)\n            continue;\n\n          if (state == 0)\n            state = 1;\n          continue;\n\n        case CLOSE_BRACKET:\n          if (mb_char)\n            continue;\n\n          if (state == 0 || state == 1)\n            return ch;\n          else if (state == 3)\n            state = 0;\n\n          break;\n\n        default:\n          break;\n        }\n\n      /* Getting a character different from .=: whilst in state 1\n         goes back to state 0, getting a character different from ]\n         whilst in state 3 goes back to state 2.  */\n      state &= ~1;\n    }\n}",
      "lines": 76,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "match_slash": {
      "start_point": [
        527,
        0
      ],
      "end_point": [
        577,
        1
      ],
      "content": "static struct buffer *\nmatch_slash (int slash, int regex)\n{\n  struct buffer *b;\n  int ch;\n  mbstate_t cur_stat = { 0, };\n\n  /* We allow only 1 byte characters for a slash.  */\n  if (IS_MB_CHAR (slash, &cur_stat))\n    bad_prog (BAD_DELIM);\n\n  memset (&cur_stat, 0, sizeof cur_stat);\n\n  b = init_buffer();\n  while ((ch = inchar()) != EOF && ch != '\\n')\n    {\n      const int mb_char = IS_MB_CHAR (ch, &cur_stat);\n\n      if (!mb_char)\n        {\n          if (ch == slash)\n            return b;\n          else if (ch == '\\\\')\n            {\n              ch = inchar();\n              if (ch == EOF)\n                break;\n#ifndef REG_PERL\n              else if (ch == 'n' && regex)\n                ch = '\\n';\n#endif\n              else if (ch != '\\n' && (ch != slash || (!regex && ch == '&')))\n                add1_buffer(b, '\\\\');\n            }\n          else if (ch == OPEN_BRACKET && regex)\n            {\n              add1_buffer(b, ch);\n              ch = snarf_char_class(b, &cur_stat);\n              if (ch != CLOSE_BRACKET)\n                break;\n            }\n        }\n\n      add1_buffer(b, ch);\n    }\n\n  if (ch == '\\n')\n    savchar(ch);\t/* for proper line number in error report */\n  free_buffer(b);\n  return NULL;\n}",
      "lines": 51,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "struct buffer",
        "struct",
        "buffer",
        "*\nmatch_slash (int slash, int regex)",
        "*"
      ]
    },
    "mark_subst_opts": {
      "start_point": [
        579,
        0
      ],
      "end_point": [
        675,
        1
      ],
      "content": "static int\nmark_subst_opts (struct subst *cmd)\n{\n  int flags = 0;\n  int ch;\n\n  cmd->global = false;\n  cmd->print = false;\n  cmd->eval = false;\n  cmd->numb = 0;\n  cmd->outf = NULL;\n\n  for (;;)\n    switch ( (ch = in_nonblank()) )\n      {\n      case 'i':\t/* GNU extension */\n      case 'I':\t/* GNU extension */\n        if (posixicity == POSIXLY_BASIC)\n          bad_prog(_(UNKNOWN_S_OPT));\n        flags |= REG_ICASE;\n        break;\n\n#ifdef REG_PERL\n      case 's':\t/* GNU extension */\n      case 'S':\t/* GNU extension */\n        if (posixicity == POSIXLY_BASIC)\n          bad_prog(_(UNKNOWN_S_OPT));\n        if (extended_regexp_flags & REG_PERL)\n          flags |= REG_DOTALL;\n        break;\n\n      case 'x':\t/* GNU extension */\n      case 'X':\t/* GNU extension */\n        if (posixicity == POSIXLY_BASIC)\n          bad_prog(_(UNKNOWN_S_OPT));\n        if (extended_regexp_flags & REG_PERL)\n          flags |= REG_EXTENDED;\n        break;\n#endif\n\n      case 'm':\t/* GNU extension */\n      case 'M':\t/* GNU extension */\n        if (posixicity == POSIXLY_BASIC)\n          bad_prog(_(UNKNOWN_S_OPT));\n        flags |= REG_NEWLINE;\n        break;\n\n      case 'e':\n        if (posixicity == POSIXLY_BASIC)\n          bad_prog(_(UNKNOWN_S_OPT));\n        cmd->eval = true;\n        break;\n\n      case 'p':\n        if (cmd->print)\n          bad_prog(_(EXCESS_P_OPT));\n        cmd->print |= (1 << cmd->eval); /* 1=before eval, 2=after */\n        break;\n\n      case 'g':\n        if (cmd->global)\n          bad_prog(_(EXCESS_G_OPT));\n        cmd->global = true;\n        break;\n\n      case 'w':\n        cmd->outf = get_openfile(&file_write, write_mode, true);\n        return flags;\n\n      case '0': case '1': case '2': case '3': case '4':\n      case '5': case '6': case '7': case '8': case '9':\n        if (cmd->numb)\n          bad_prog(_(EXCESS_N_OPT));\n        cmd->numb = in_integer(ch);\n        if (!cmd->numb)\n          bad_prog(_(ZERO_N_OPT));\n        break;\n\n      case CLOSE_BRACE:\n      case '#':\n        savchar(ch);\n        FALLTHROUGH;\n      case EOF:\n      case '\\n':\n      case ';':\n        return flags;\n\n      case '\\r':\n        if (inchar() == '\\n')\n          return flags;\n        FALLTHROUGH;\n\n      default:\n        bad_prog(_(UNKNOWN_S_OPT));\n        /*NOTREACHED*/\n      }\n}",
      "lines": 97,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "read_label": {
      "start_point": [
        679,
        0
      ],
      "end_point": [
        698,
        1
      ],
      "content": "static char *\nread_label (void)\n{\n  struct buffer *b;\n  int ch;\n  char *ret;\n\n  b = init_buffer();\n  ch = in_nonblank();\n\n  while (ch != EOF && ch != '\\n'\n         && !ISBLANK(ch) && ch != ';' && ch != CLOSE_BRACE && ch != '#')\n    ch = add_then_next (b, ch);\n\n  savchar(ch);\n  add1_buffer(b, '\\0');\n  ret = ck_strdup(get_buffer(b));\n  free_buffer(b);\n  return ret;\n}",
      "lines": 20,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nread_label (void)",
        "*"
      ]
    },
    "setup_label": {
      "start_point": [
        704,
        0
      ],
      "end_point": [
        715,
        1
      ],
      "content": "static struct sed_label *\nsetup_label(struct sed_label *list, countT idx, char *name,\n            const struct error_info *err_info)\n{\n  struct sed_label *ret = OB_MALLOC(&obs, 1, struct sed_label);\n  ret->v_index = idx;\n  ret->name = name;\n  if (err_info)\n    memcpy(&ret->err_info, err_info, sizeof (ret->err_info));\n  ret->next = list;\n  return ret;\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "struct sed_label",
        "struct",
        "sed_label",
        "*\nsetup_label(struct sed_label *list, countT idx, char *name,\n            const struct error_info *err_info)",
        "*"
      ]
    },
    "release_label": {
      "start_point": [
        717,
        0
      ],
      "end_point": [
        733,
        1
      ],
      "content": "static struct sed_label *\nrelease_label (struct sed_label *list_head)\n{\n  struct sed_label *ret;\n\n  if (!list_head)\n    return NULL;\n  ret = list_head->next;\n\n  free(list_head->name);\n\n#if 0\n  /* We use obstacks */\n  free(list_head);\n#endif\n  return ret;\n}",
      "lines": 17,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "struct sed_label",
        "struct",
        "sed_label",
        "*\nrelease_label (struct sed_label *list_head)",
        "*"
      ]
    },
    "new_replacement": {
      "start_point": [
        735,
        0
      ],
      "end_point": [
        747,
        1
      ],
      "content": "static struct replacement *\nnew_replacement(char *text, size_t length, enum replacement_types type)\n{\n  struct replacement *r = OB_MALLOC(&obs, 1, struct replacement);\n\n  r->prefix = text;\n  r->prefix_length = length;\n  r->subst_id = -1;\n  r->repl_type = type;\n\n  /* r-> next = NULL; */\n  return r;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "struct replacement",
        "struct",
        "replacement",
        "*\nnew_replacement(char *text, size_t length, enum replacement_types type)",
        "*"
      ]
    },
    "setup_replacement": {
      "start_point": [
        749,
        0
      ],
      "end_point": [
        848,
        1
      ],
      "content": "static void\nsetup_replacement (struct subst *sub, const char *text, size_t length)\n{\n  char *base;\n  char *p;\n  char *text_end;\n  enum replacement_types repl_type = REPL_ASIS, save_type = REPL_ASIS;\n  struct replacement root;\n  struct replacement *tail;\n\n  sub->max_id = 0;\n  base = MEMDUP(text, length, char);\n  length = normalize_text(base, length, TEXT_REPLACEMENT);\n\n  text_end = base + length;\n  tail = &root;\n\n  for (p=base; p<text_end; ++p)\n    {\n      if (*p == '\\\\')\n        {\n          /* Preceding the backslash may be some literal text: */\n          tail = tail->next =\n            new_replacement(base, (size_t)(p - base), repl_type);\n\n          repl_type = save_type;\n\n          /* Skip the backslash and look for a numeric back-reference,\n             or a case-munging escape if not in POSIX mode: */\n          ++p;\n          if (p == text_end)\n            ++tail->prefix_length;\n\n          else if (posixicity == POSIXLY_BASIC && !ISDIGIT (*p))\n            {\n              p[-1] = *p;\n              ++tail->prefix_length;\n            }\n\n          else\n            switch (*p)\n              {\n              case '0': case '1': case '2': case '3': case '4':\n              case '5': case '6': case '7': case '8': case '9':\n                tail->subst_id = *p - '0';\n                if (sub->max_id < tail->subst_id)\n                  sub->max_id = tail->subst_id;\n                break;\n\n              case 'L':\n                repl_type = REPL_LOWERCASE;\n                save_type = REPL_LOWERCASE;\n                break;\n\n              case 'U':\n                repl_type = REPL_UPPERCASE;\n                save_type = REPL_UPPERCASE;\n                break;\n\n              case 'E':\n                repl_type = REPL_ASIS;\n                save_type = REPL_ASIS;\n                break;\n\n              case 'l':\n                save_type = repl_type;\n                repl_type |= REPL_LOWERCASE_FIRST;\n                break;\n\n              case 'u':\n                save_type = repl_type;\n                repl_type |= REPL_UPPERCASE_FIRST;\n                break;\n\n              default:\n                p[-1] = *p;\n                ++tail->prefix_length;\n              }\n\n          base = p + 1;\n        }\n      else if (*p == '&')\n        {\n          /* Preceding the ampersand may be some literal text: */\n          tail = tail->next =\n            new_replacement(base, (size_t)(p - base), repl_type);\n\n          repl_type = save_type;\n          tail->subst_id = 0;\n          base = p + 1;\n        }\n  }\n  /* There may be some trailing literal text: */\n  if (base < text_end)\n    tail = tail->next =\n      new_replacement(base, (size_t)(text_end - base), repl_type);\n\n  tail->next = NULL;\n  sub->replacement = root.next;\n}",
      "lines": 100,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "read_text": {
      "start_point": [
        850,
        0
      ],
      "end_point": [
        900,
        1
      ],
      "content": "static void\nread_text (struct text_buf *buf, int leadin_ch)\n{\n  int ch;\n\n  /* Should we start afresh (as opposed to continue a partial text)? */\n  if (buf)\n    {\n      if (pending_text)\n        free_buffer(pending_text);\n      pending_text = init_buffer();\n      buf->text = NULL;\n      buf->text_length = 0;\n      old_text_buf = buf;\n    }\n  /* assert(old_text_buf != NULL); */\n\n  if (leadin_ch == EOF)\n    return;\n\n  if (leadin_ch != '\\n')\n    add1_buffer(pending_text, leadin_ch);\n\n  ch = inchar();\n  while (ch != EOF && ch != '\\n')\n    {\n      if (ch == '\\\\')\n        {\n          ch = inchar();\n          if (ch != EOF)\n            add1_buffer (pending_text, '\\\\');\n        }\n\n      if (ch == EOF)\n        {\n          add1_buffer (pending_text, '\\n');\n          return;\n        }\n\n      ch = add_then_next (pending_text, ch);\n    }\n\n  add1_buffer(pending_text, '\\n');\n  if (!buf)\n    buf = old_text_buf;\n  buf->text_length = normalize_text (get_buffer (pending_text),\n                                     size_buffer (pending_text), TEXT_BUFFER);\n  buf->text = MEMDUP(get_buffer(pending_text), buf->text_length, char);\n  free_buffer(pending_text);\n  pending_text = NULL;\n}",
      "lines": 51,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "compile_address": {
      "start_point": [
        907,
        0
      ],
      "end_point": [
        998,
        1
      ],
      "content": "static bool\ncompile_address (struct addr *addr, int ch)\n{\n  addr->addr_type = ADDR_IS_NULL;\n  addr->addr_step = 0;\n  addr->addr_number = ~(countT)0;  /* extremely unlikely to ever match */\n  addr->addr_regex = NULL;\n\n  if (ch == '/' || ch == '\\\\')\n    {\n      int flags = 0;\n      struct buffer *b;\n      addr->addr_type = ADDR_IS_REGEX;\n      if (ch == '\\\\')\n        ch = inchar();\n      if ( !(b = match_slash(ch, true)) )\n        bad_prog(_(UNTERM_ADDR_RE));\n\n      for(;;)\n        {\n          ch = in_nonblank();\n          if (posixicity == POSIXLY_BASIC)\n            goto posix_address_modifier;\n          switch(ch)\n            {\n            case 'I':\t/* GNU extension */\n              flags |= REG_ICASE;\n              break;\n\n#ifdef REG_PERL\n            case 'S':\t/* GNU extension */\n              if (extended_regexp_flags & REG_PERL)\n                flags |= REG_DOTALL;\n              break;\n\n            case 'X':\t/* GNU extension */\n              if (extended_regexp_flags & REG_PERL)\n                flags |= REG_EXTENDED;\n              break;\n#endif\n\n            case 'M':\t/* GNU extension */\n              flags |= REG_NEWLINE;\n              break;\n\n            default:\n            posix_address_modifier:\n              savchar (ch);\n              addr->addr_regex = compile_regex (b, flags, 0);\n              free_buffer(b);\n              return true;\n            }\n        }\n    }\n  else if (ISDIGIT(ch))\n    {\n      addr->addr_number = in_integer(ch);\n      addr->addr_type = ADDR_IS_NUM;\n      ch = in_nonblank();\n      if (ch != '~' || posixicity == POSIXLY_BASIC)\n        {\n          savchar(ch);\n        }\n      else\n        {\n          countT step = in_integer(in_nonblank());\n          if (step > 0)\n            {\n              addr->addr_step = step;\n              addr->addr_type = ADDR_IS_NUM_MOD;\n            }\n        }\n    }\n  else if ((ch == '+' || ch == '~') && posixicity != POSIXLY_BASIC)\n    {\n      addr->addr_step = in_integer(in_nonblank());\n      if (addr->addr_step==0)\n        ; /* default to ADDR_IS_NULL; forces matching to stop on next line */\n      else if (ch == '+')\n        addr->addr_type = ADDR_IS_STEP;\n      else\n        addr->addr_type = ADDR_IS_STEP_MOD;\n    }\n  else if (ch == '$')\n    {\n      addr->addr_type = ADDR_IS_LAST;\n    }\n  else\n    return false;\n\n  return true;\n}",
      "lines": 92,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "compile_program": {
      "start_point": [
        1002,
        0
      ],
      "end_point": [
        1378,
        1
      ],
      "content": "static struct vector *\ncompile_program(struct vector *vector)\n{\n  struct sed_cmd *cur_cmd;\n  struct buffer *b;\n  int ch;\n\n  if (!vector)\n    {\n      vector = MALLOC(1, struct vector);\n      vector->v = NULL;\n      vector->v_allocated = 0;\n      vector->v_length = 0;\n\n      obstack_init (&obs);\n    }\n  if (pending_text)\n    read_text(NULL, '\\n');\n\n  for (;;)\n    {\n      struct addr a;\n\n      while ((ch=inchar()) == ';' || ISSPACE(ch))\n        ;\n      if (ch == EOF)\n        break;\n\n      cur_cmd = next_cmd_entry(&vector);\n      if (compile_address(&a, ch))\n        {\n          if (a.addr_type == ADDR_IS_STEP\n              || a.addr_type == ADDR_IS_STEP_MOD)\n            bad_prog(_(BAD_STEP));\n\n          cur_cmd->a1 = MEMDUP(&a, 1, struct addr);\n          ch = in_nonblank();\n          if (ch == ',')\n            {\n              if (!compile_address(&a, in_nonblank()))\n                bad_prog(_(BAD_COMMA));\n\n              cur_cmd->a2 = MEMDUP(&a, 1, struct addr);\n              ch = in_nonblank();\n            }\n\n          if ((cur_cmd->a1->addr_type == ADDR_IS_NUM\n               && cur_cmd->a1->addr_number == 0)\n              && ((!cur_cmd->a2 || cur_cmd->a2->addr_type != ADDR_IS_REGEX)\n                  || posixicity == POSIXLY_BASIC))\n            bad_prog(_(INVALID_LINE_0));\n        }\n      if (ch == '!')\n        {\n          cur_cmd->addr_bang = true;\n          ch = in_nonblank();\n          if (ch == '!')\n            bad_prog(_(BAD_BANG));\n        }\n\n      /* Do not accept extended commands in --posix mode.  Also,\n         a few commands only accept one address in that mode.  */\n      if (posixicity == POSIXLY_BASIC)\n       switch (ch)\n         {\n           case 'e': case 'F': case 'v': case 'z': case 'L':\n           case 'Q': case 'T': case 'R': case 'W':\n             bad_command(ch);\n             FALLTHROUGH;\n\n            case 'a': case 'i': case 'l':\n            case '=': case 'r':\n              if (cur_cmd->a2)\n                bad_prog(_(ONE_ADDR));\n          }\n\n      cur_cmd->cmd = ch;\n      switch (ch)\n        {\n        case '#':\n          if (cur_cmd->a1)\n            bad_prog(_(NO_SHARP_ADDR));\n          ch = inchar();\n          if (ch=='n' && first_script && cur_input.line < 2)\n            if (   (prog.base && prog.cur==2+prog.base)\n                || (prog.file && !prog.base && 2==ftell(prog.file)))\n              no_default_output = true;\n          while (ch != EOF && ch != '\\n')\n            ch = inchar();\n          continue;\t/* restart the for (;;) loop */\n\n        case 'v':\n          /* This is an extension.  Programs needing GNU sed might start\n           * with a `v' command so that other seds will stop.\n           * We compare the version and ignore POSIXLY_CORRECT.\n           */\n          {\n            char *version = read_label ();\n            char const *compared_version;\n            compared_version = (*version == '\\0') ? \"4.0\" : version;\n            if (strverscmp (compared_version, PACKAGE_VERSION) > 0)\n              bad_prog(_(ANCIENT_VERSION));\n\n            free (version);\n            posixicity = POSIXLY_EXTENDED;\n          }\n          continue;\n\n        case '{':\n          blocks = setup_label(blocks, vector->v_length, NULL, &cur_input);\n          cur_cmd->addr_bang = !cur_cmd->addr_bang;\n          break;\n\n        case '}':\n          if (!blocks)\n            bad_prog(_(EXCESS_CLOSE_BRACE));\n          if (cur_cmd->a1)\n            bad_prog(_(NO_CLOSE_BRACE_ADDR));\n\n          read_end_of_cmd ();\n\n          vector->v[blocks->v_index].x.jump_index = vector->v_length;\n          blocks = release_label(blocks);\t/* done with this entry */\n          break;\n\n        case 'e':\n          if (sandbox)\n            bad_prog(_(DISALLOWED_CMD));\n\n          ch = in_nonblank();\n          if (ch == EOF || ch == '\\n')\n            {\n              cur_cmd->x.cmd_txt.text_length = 0;\n              break;\n            }\n          else\n            goto read_text_to_slash;\n\n        case 'a':\n        case 'i':\n        case 'c':\n          ch = in_nonblank();\n\n        read_text_to_slash:\n          if (ch == EOF)\n            bad_prog(_(EXPECTED_SLASH));\n\n          if (ch == '\\\\')\n            ch = inchar();\n          else\n            {\n              if (posixicity == POSIXLY_BASIC)\n                bad_prog(_(EXPECTED_SLASH));\n              savchar(ch);\n              ch = '\\n';\n            }\n\n          read_text(&cur_cmd->x.cmd_txt, ch);\n          break;\n\n        case ':':\n          if (cur_cmd->a1)\n            bad_prog(_(NO_COLON_ADDR));\n          {\n            char *label = read_label ();\n            if (!*label)\n              bad_prog(_(COLON_LACKS_LABEL));\n            labels = setup_label(labels, vector->v_length, label, NULL);\n          }\n          break;\n\n        case 'T':\n        case 'b':\n        case 't':\n          jumps = setup_label(jumps, vector->v_length, read_label(), NULL);\n          break;\n\n        case 'Q':\n        case 'q':\n          if (cur_cmd->a2)\n            bad_prog(_(ONE_ADDR));\n          FALLTHROUGH;\n\n        case 'L':\n        case 'l':\n          ch = in_nonblank();\n          if (ISDIGIT(ch) && posixicity != POSIXLY_BASIC)\n            {\n              cur_cmd->x.int_arg = in_integer(ch);\n            }\n          else\n            {\n              cur_cmd->x.int_arg = -1;\n              savchar (ch);\n            }\n\n          read_end_of_cmd ();\n          break;\n\n       case '=':\n       case 'd':\n       case 'D':\n       case 'F':\n       case 'g':\n       case 'G':\n       case 'h':\n        case 'H':\n        case 'n':\n        case 'N':\n        case 'p':\n        case 'P':\n        case 'z':\n        case 'x':\n          read_end_of_cmd ();\n          break;\n\n        case 'r':\n          b = read_filename();\n          cur_cmd->x.fname = ck_strdup(get_buffer(b));\n          free_buffer(b);\n          break;\n\n        case 'R':\n          cur_cmd->x.fp = get_openfile(&file_read, read_mode, false)->fp;\n          break;\n\n        case 'W':\n        case 'w':\n          cur_cmd->x.outf = get_openfile(&file_write, write_mode, true);\n          break;\n\n        case 's':\n          {\n            struct buffer *b2;\n            int flags;\n            int slash;\n\n            slash = inchar();\n            if ( !(b  = match_slash(slash, true)) )\n              bad_prog(_(UNTERM_S_CMD));\n            if ( !(b2 = match_slash(slash, false)) )\n              bad_prog(_(UNTERM_S_CMD));\n\n            cur_cmd->x.cmd_subst = OB_MALLOC(&obs, 1, struct subst);\n            setup_replacement(cur_cmd->x.cmd_subst,\n                              get_buffer(b2), size_buffer(b2));\n            free_buffer(b2);\n\n            flags = mark_subst_opts(cur_cmd->x.cmd_subst);\n            cur_cmd->x.cmd_subst->regx =\n              compile_regex(b, flags, cur_cmd->x.cmd_subst->max_id + 1);\n            free_buffer(b);\n\n            if (cur_cmd->x.cmd_subst->eval && sandbox)\n              bad_prog(_(DISALLOWED_CMD));\n          }\n          break;\n\n        case 'y':\n          {\n            size_t len, dest_len;\n            int slash;\n            struct buffer *b2;\n            char *src_buf, *dest_buf;\n\n            slash = inchar();\n            if ( !(b = match_slash(slash, false)) )\n              bad_prog(_(UNTERM_Y_CMD));\n            src_buf = get_buffer(b);\n            len = normalize_text(src_buf, size_buffer (b), TEXT_BUFFER);\n\n            if ( !(b2 = match_slash(slash, false)) )\n              bad_prog(_(UNTERM_Y_CMD));\n            dest_buf = get_buffer(b2);\n            dest_len = normalize_text(dest_buf, size_buffer (b2), TEXT_BUFFER);\n\n            if (mb_cur_max > 1)\n              {\n                size_t i, j, idx, src_char_num;\n                size_t *src_lens = MALLOC(len, size_t);\n                char **trans_pairs;\n                size_t mbclen;\n                mbstate_t cur_stat = { 0, };\n\n                /* Enumerate how many character the source buffer has.  */\n                for (i = 0, j = 0; i < len;)\n                  {\n                    mbclen = MBRLEN (src_buf + i, len - i, &cur_stat);\n                    /* An invalid sequence, or a truncated multibyte character.\n                       We treat it as a single-byte character.  */\n                    if (mbclen == (size_t) -1 || mbclen == (size_t) -2\n                        || mbclen == 0)\n                      mbclen = 1;\n                    src_lens[j++] = mbclen;\n                    i += mbclen;\n                  }\n                src_char_num = j;\n\n                memset(&cur_stat, 0, sizeof cur_stat);\n                idx = 0;\n\n                /* trans_pairs = {src(0), dest(0), src(1), dest(1), ..., NULL}\n                     src(i) : pointer to i-th source character.\n                     dest(i) : pointer to i-th destination character.\n                     NULL : terminator */\n                trans_pairs = MALLOC(2 * src_char_num + 1, char*);\n                cur_cmd->x.translatemb = trans_pairs;\n                for (i = 0; i < src_char_num; i++)\n                  {\n                    if (idx >= dest_len)\n                      bad_prog(_(Y_CMD_LEN));\n\n                    /* Set the i-th source character.  */\n                    trans_pairs[2 * i] = MALLOC(src_lens[i] + 1, char);\n                    memcpy(trans_pairs[2 * i], src_buf, src_lens[i]);\n                    trans_pairs[2 * i][src_lens[i]] = '\\0';\n                    src_buf += src_lens[i]; /* Forward to next character.  */\n\n                    /* Fetch the i-th destination character.  */\n                    mbclen = MBRLEN (dest_buf + idx, dest_len - idx, &cur_stat);\n                    /* An invalid sequence, or a truncated multibyte character.\n                       We treat it as a single-byte character.  */\n                    if (mbclen == (size_t) -1 || mbclen == (size_t) -2\n                        || mbclen == 0)\n                      mbclen = 1;\n\n                    /* Set the i-th destination character.  */\n                    trans_pairs[2 * i + 1] = MALLOC(mbclen + 1, char);\n                    memcpy(trans_pairs[2 * i + 1], dest_buf + idx, mbclen);\n                    trans_pairs[2 * i + 1][mbclen] = '\\0';\n                    idx += mbclen; /* Forward to next character.  */\n                  }\n                trans_pairs[2 * i] = NULL;\n                if (idx != dest_len)\n                  bad_prog(_(Y_CMD_LEN));\n              }\n            else\n              {\n                unsigned char *translate =\n                  OB_MALLOC(&obs, YMAP_LENGTH, unsigned char);\n                unsigned char *ustring = (unsigned char *)src_buf;\n\n                if (len != dest_len)\n                  bad_prog(_(Y_CMD_LEN));\n\n                for (len = 0; len < YMAP_LENGTH; len++)\n                  translate[len] = len;\n\n                while (dest_len--)\n                  translate[*ustring++] = (unsigned char)*dest_buf++;\n\n                cur_cmd->x.translate = translate;\n              }\n\n            read_end_of_cmd ();\n\n            free_buffer(b);\n            free_buffer(b2);\n          }\n        break;\n\n        case EOF:\n          bad_prog(_(NO_COMMAND));\n          /*NOTREACHED*/\n\n        default:\n          bad_command (ch);\n          /*NOTREACHED*/\n        }\n\n      /* this is buried down here so that \"continue\" statements will miss it */\n      ++vector->v_length;\n    }\n  if (posixicity == POSIXLY_BASIC && pending_text)\n    bad_prog (_(INCOMPLETE_CMD));\n  return vector;\n}",
      "lines": 377,
      "depth": 20,
      "decorators": [
        "static",
        "static",
        "struct vector",
        "struct",
        "vector",
        "*\ncompile_program(struct vector *vector)",
        "*"
      ]
    },
    "normalize_text": {
      "start_point": [
        1382,
        0
      ],
      "end_point": [
        1543,
        1
      ],
      "content": "size_t\nnormalize_text(char *buf, size_t len, enum text_types buftype)\n{\n  const char *bufend = buf + len;\n  char *p = buf;\n  char *q = buf;\n  char ch;\n  int base;\n\n  /* This variable prevents normalizing text within bracket\n     subexpressions when conforming to POSIX.  If 0, we\n     are not within a bracket expression.  If -1, we are within a\n     bracket expression but are not within [.FOO.], [=FOO=],\n     or [:FOO:].  Otherwise, this is the '.', '=', or ':'\n     respectively within these three types of subexpressions.  */\n  int bracket_state = 0;\n\n  int mbclen;\n  mbstate_t cur_stat = { 0, };\n\n  while (p < bufend)\n    {\n      mbclen = MBRLEN (p, bufend - p, &cur_stat);\n      if (mbclen != 1)\n        {\n          /* An invalid sequence, or a truncated multibyte character.\n             We treat it as a single-byte character.  */\n          if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)\n            mbclen = 1;\n\n          memmove (q, p, mbclen);\n          q += mbclen;\n          p += mbclen;\n          continue;\n        }\n\n      if (*p == '\\\\' && p+1 < bufend && bracket_state == 0)\n        switch (*++p)\n          {\n#if defined __STDC__ && __STDC__-0\n          case 'a': *q++ = '\\a'; p++; continue;\n#else /* Not STDC; we'll just assume ASCII */\n          case 'a': *q++ = '\\007'; p++; continue;\n#endif\n          /* case 'b': *q++ = '\\b'; p++; continue; --- conflicts with \\b RE */\n          case 'f': *q++ = '\\f'; p++; continue;\n          case '\\n': /*fall through */\n          case 'n': *q++ = '\\n'; p++; continue;\n          case 'r': *q++ = '\\r'; p++; continue;\n          case 't': *q++ = '\\t'; p++; continue;\n          case 'v': *q++ = '\\v'; p++; continue;\n\n          case 'd': /* decimal byte */\n            base = 10;\n            goto convert;\n\n          case 'x': /* hexadecimal byte */\n            base = 16;\n            goto convert;\n\n#ifdef REG_PERL\n          case '0': case '1': case '2': case '3':\n          case '4': case '5': case '6': case '7':\n            if ((extended_regexp_flags & REG_PERL)\n                && p+1 < bufend\n                && p[1] >= '0' && p[1] <= '9')\n              {\n                base = 8;\n                goto convert;\n              }\n            else\n              {\n                /* we just pass the \\ up one level for interpretation */\n                if (buftype != TEXT_BUFFER)\n                  *q++ = '\\\\';\n              }\n\n            continue;\n\n          case 'o': /* octal byte */\n            if (!(extended_regexp_flags & REG_PERL))\n              {\n                base = 8;\n                goto convert;\n              }\n            else\n              {\n                /* we just pass the \\ up one level for interpretation */\n                if (buftype != TEXT_BUFFER)\n                  *q++ = '\\\\';\n              }\n\n            continue;\n#else\n          case 'o': /* octal byte */\n            base = 8;\n#endif\nconvert:\n            p = convert_number(&ch, p, bufend, base);\n\n            /* for an ampersand in a replacement, pass the \\ up one level */\n            if (buftype == TEXT_REPLACEMENT && (ch == '&' || ch == '\\\\'))\n              *q++ = '\\\\';\n            *q++ = ch;\n            continue;\n\n          case 'c':\n            if (++p < bufend)\n              {\n                *q++ = toupper((unsigned char) *p) ^ 0x40;\n                if (*p == '\\\\')\n                  {\n                    p++;\n                    if (*p != '\\\\')\n                      bad_prog(RECURSIVE_ESCAPE_C);\n                  }\n                p++;\n                continue;\n              }\n            else\n              {\n                /* we just pass the \\ up one level for interpretation */\n                if (buftype != TEXT_BUFFER)\n                  *q++ = '\\\\';\n                continue;\n              }\n\n          default:\n            /* we just pass the \\ up one level for interpretation */\n            if (buftype != TEXT_BUFFER)\n              *q++ = '\\\\';\n            break;\n          }\n      else if (buftype == TEXT_REGEX && posixicity != POSIXLY_EXTENDED)\n        switch (*p)\n          {\n          case '[':\n            if (!bracket_state)\n              bracket_state = -1;\n            break;\n\n          case ':':\n          case '.':\n          case '=':\n            if (bracket_state == -1 && p[-1] == '[')\n              bracket_state = *p;\n            break;\n\n          case ']':\n            if (bracket_state == 0)\n              ;\n            else if (bracket_state == -1)\n              bracket_state = 0;\n            else if (p[-2] != bracket_state && p[-1] == bracket_state)\n              bracket_state = -1;\n            break;\n          }\n\n      *q++ = *p++;\n    }\n    return (size_t)(q - buf);\n}",
      "lines": 162,
      "depth": 19,
      "decorators": [
        "size_t"
      ]
    },
    "compile_string": {
      "start_point": [
        1548,
        0
      ],
      "end_point": [
        1570,
        1
      ],
      "content": "struct vector *\ncompile_string(struct vector *cur_program, char *str, size_t len)\n{\n  static countT string_expr_count = 0;\n  struct vector *ret;\n\n  prog.file = NULL;\n  prog.base = (unsigned char *)str;\n  prog.cur = prog.base;\n  prog.end = prog.cur + len;\n\n  cur_input.line = 0;\n  cur_input.name = NULL;\n  cur_input.string_expr_count = ++string_expr_count;\n\n  ret = compile_program(cur_program);\n  prog.base = NULL;\n  prog.cur = NULL;\n  prog.end = NULL;\n\n  first_script = false;\n  return ret;\n}",
      "lines": 23,
      "depth": 8,
      "decorators": [
        "struct vector",
        "struct",
        "vector",
        "*\ncompile_string(struct vector *cur_program, char *str, size_t len)",
        "*"
      ]
    },
    "compile_file": {
      "start_point": [
        1575,
        0
      ],
      "end_point": [
        1601,
        1
      ],
      "content": "struct vector *\ncompile_file(struct vector *cur_program, const char *cmdfile)\n{\n  struct vector *ret;\n\n  prog.file = stdin;\n  if (cmdfile[0] != '-' || cmdfile[1] != '\\0')\n    {\n#ifdef HAVE_FOPEN_RT\n      prog.file = ck_fopen(cmdfile, \"rt\", true);\n#else\n      prog.file = ck_fopen(cmdfile, \"r\", true);\n#endif\n    }\n\n  cur_input.line = 1;\n  cur_input.name = cmdfile;\n  cur_input.string_expr_count = 0;\n\n  ret = compile_program(cur_program);\n  if (prog.file != stdin)\n    ck_fclose(prog.file);\n  prog.file = NULL;\n\n  first_script = false;\n  return ret;\n}",
      "lines": 27,
      "depth": 12,
      "decorators": [
        "struct vector",
        "struct",
        "vector",
        "*\ncompile_file(struct vector *cur_program, const char *cmdfile)",
        "*"
      ]
    },
    "check_final_program": {
      "start_point": [
        1606,
        0
      ],
      "end_point": [
        1671,
        1
      ],
      "content": "void\ncheck_final_program(struct vector *program)\n{\n  struct sed_label *go;\n  struct sed_label *lbl;\n\n  /* do all \"{\"s have a corresponding \"}\"? */\n  if (blocks)\n    {\n      /* update info for error reporting: */\n      memcpy(&cur_input, &blocks->err_info, sizeof (cur_input));\n      bad_prog(_(EXCESS_OPEN_BRACE));\n    }\n\n  /* was the final command an unterminated a/c/i command? */\n  if (pending_text)\n    {\n      old_text_buf->text_length = size_buffer(pending_text);\n      if (old_text_buf->text_length)\n        old_text_buf->text = MEMDUP(get_buffer(pending_text),\n                                    old_text_buf->text_length, char);\n      free_buffer(pending_text);\n      pending_text = NULL;\n    }\n\n  for (go = jumps; go; go = release_label(go))\n    {\n      for (lbl = labels; lbl; lbl = lbl->next)\n        if (strcmp(lbl->name, go->name) == 0)\n          break;\n      if (lbl)\n        {\n          program->v[go->v_index].x.jump_index = lbl->v_index;\n        }\n      else\n        {\n          if (*go->name)\n            panic(_(\"can't find label for jump to `%s'\"), go->name);\n          program->v[go->v_index].x.jump_index = program->v_length;\n        }\n    }\n  jumps = NULL;\n\n  for (lbl = labels; lbl; lbl = release_label(lbl))\n    ;\n  labels = NULL;\n\n  /* There is no longer a need to track file names: */\n  {\n    struct output *p;\n\n    for (p=file_read; p; p=p->link)\n      if (p->name)\n        {\n          free(p->name);\n          p->name = NULL;\n        }\n\n    for (p=file_write; p; p=p->link)\n      if (p->name)\n        {\n          free(p->name);\n          p->name = NULL;\n        }\n  }\n}",
      "lines": 66,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "rewind_read_files": {
      "start_point": [
        1674,
        0
      ],
      "end_point": [
        1682,
        1
      ],
      "content": "void\nrewind_read_files(void)\n{\n  struct output *p;\n\n  for (p=file_read; p; p=p->link)\n    if (p->fp)\n      rewind(p->fp);\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "finish_program": {
      "start_point": [
        1685,
        0
      ],
      "end_point": [
        1719,
        1
      ],
      "content": "void\nfinish_program(void)\n{\n  /* close all files... */\n  {\n    struct output *p, *q;\n\n    for (p=file_read; p; p=q)\n      {\n        if (p->fp)\n          ck_fclose(p->fp);\n        q = p->link;\n#if 0\n        /* We use obstacks. */\n        free(p);\n#endif\n      }\n\n    for (p=file_write; p; p=q)\n      {\n        if (p->fp)\n          ck_fclose(p->fp);\n        q = p->link;\n#if 0\n        /* We use obstacks. */\n        free(p);\n#endif\n      }\n    file_read = file_write = NULL;\n  }\n\n#ifdef DEBUG_LEAKS\n  obstack_free (&obs, NULL);\n#endif /*DEBUG_LEAKS*/\n}",
      "lines": 35,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "sed/sed-4.5/sed/execute.c": {
    "resize_line": {
      "start_point": [
        128,
        0
      ],
      "end_point": [
        155,
        1
      ],
      "content": "static void\nresize_line (struct line *lb, size_t len)\n{\n  int inactive;\n  inactive = lb->active - lb->text;\n\n  /* If the inactive part has got to more than two thirds of the buffer,\n   * remove it. */\n  if (inactive > lb->alloc * 2)\n    {\n      memmove(lb->text, lb->active, lb->length);\n      lb->alloc += lb->active - lb->text;\n      lb->active = lb->text;\n      inactive = 0;\n\n      if (lb->alloc > len)\n        return;\n    }\n\n  lb->alloc *= 2;\n  if (lb->alloc < len)\n    lb->alloc = len;\n  if (lb->alloc < INITIAL_BUFFER_SIZE)\n    lb->alloc = INITIAL_BUFFER_SIZE;\n\n  lb->text = REALLOC(lb->text, inactive + lb->alloc + DFA_SLOP, char);\n  lb->active = lb->text + inactive;\n}",
      "lines": 28,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "str_append": {
      "start_point": [
        158,
        0
      ],
      "end_point": [
        187,
        1
      ],
      "content": "static void\nstr_append(struct line *to, const char *string, size_t length)\n{\n  size_t new_length = to->length + length;\n\n  if (to->alloc < new_length)\n    resize_line(to, new_length);\n  memcpy(to->active + to->length, string, length);\n  to->length = new_length;\n\n  if (mb_cur_max > 1 && !is_utf8)\n    while (length)\n      {\n        size_t n = MBRLEN (string, length, &to->mbstate);\n\n        /* Treat an invalid or incomplete sequence like a\n           single-byte character.  */\n        if (n == (size_t) -1 || n == (size_t) -2)\n          {\n            memset (&to->mbstate, 0, sizeof (to->mbstate));\n            n = 1;\n          }\n\n        if (n == 0)\n          break;\n\n        string += n;\n        length -= n;\n      }\n}",
      "lines": 30,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "str_append_modified": {
      "start_point": [
        189,
        0
      ],
      "end_point": [
        274,
        1
      ],
      "content": "static void\nstr_append_modified(struct line *to, const char *string, size_t length,\n                    enum replacement_types type)\n{\n  mbstate_t from_stat;\n\n  if (type == REPL_ASIS)\n    {\n      str_append(to, string, length);\n      return;\n    }\n\n  if (to->alloc - to->length < length * mb_cur_max)\n    resize_line(to, to->length + length * mb_cur_max);\n\n  memcpy (&from_stat, &to->mbstate, sizeof(mbstate_t));\n  while (length)\n    {\n      wchar_t wc;\n      size_t n = MBRTOWC (&wc, string, length, &from_stat);\n\n      /* Treat an invalid sequence like a single-byte character.  */\n      if (n == (size_t) -1)\n        {\n          type &= ~(REPL_LOWERCASE_FIRST | REPL_UPPERCASE_FIRST);\n          if (type == REPL_ASIS)\n            {\n              str_append(to, string, length);\n              return;\n            }\n\n          str_append (to, string, 1);\n          memset (&to->mbstate, 0, sizeof (from_stat));\n          n = 1;\n          string += n, length -= n;\n          continue;\n        }\n\n      if (n == 0 || n == (size_t) -2)\n        {\n          /* L'\\0' or an incomplete sequence: copy it manually.  */\n          str_append(to, string, length);\n          return;\n        }\n\n      string += n, length -= n;\n\n      /* Convert the first character specially... */\n      if (type & (REPL_UPPERCASE_FIRST | REPL_LOWERCASE_FIRST))\n        {\n          if (type & REPL_UPPERCASE_FIRST)\n            wc = towupper(wc);\n          else\n            wc = towlower(wc);\n\n          type &= ~(REPL_LOWERCASE_FIRST | REPL_UPPERCASE_FIRST);\n          if (type == REPL_ASIS)\n            {\n              /* Copy the new wide character to the end of the string. */\n              n = WCRTOMB (to->active + to->length, wc, &to->mbstate);\n              to->length += n;\n              if (n == (size_t) -1 || n == (size_t) -2)\n                {\n                  fprintf (stderr,\n                           _(\"case conversion produced an invalid character\"));\n                  abort ();\n                }\n              str_append(to, string, length);\n              return;\n            }\n        }\n      else if (type & REPL_UPPERCASE)\n        wc = towupper(wc);\n      else\n        wc = towlower(wc);\n\n      /* Copy the new wide character to the end of the string. */\n      n = WCRTOMB (to->active + to->length, wc, &to->mbstate);\n      to->length += n;\n      if (n == -1 || n == -2)\n        {\n          fprintf (stderr, _(\"case conversion produced an invalid character\"));\n          abort ();\n        }\n    }\n}",
      "lines": 86,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "line_init": {
      "start_point": [
        278,
        0
      ],
      "end_point": [
        291,
        1
      ],
      "content": "static void\nline_init(struct line *buf, struct line *state, size_t initial_size)\n{\n  buf->text = MALLOC(initial_size + DFA_SLOP, char);\n  buf->active = buf->text;\n  buf->alloc = initial_size;\n  buf->length = 0;\n  buf->chomped = true;\n\n  if (state)\n    memcpy (&buf->mbstate, &state->mbstate, sizeof (buf->mbstate));\n  else\n    memset (&buf->mbstate, 0, sizeof (buf->mbstate));\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "line_reset": {
      "start_point": [
        295,
        0
      ],
      "end_point": [
        308,
        1
      ],
      "content": "static void\nline_reset(struct line *buf, struct line *state)\n{\n  if (buf->alloc == 0)\n    line_init(buf, state, INITIAL_BUFFER_SIZE);\n  else\n    {\n      buf->length = 0;\n      if (state)\n        memcpy (&buf->mbstate, &state->mbstate, sizeof (buf->mbstate));\n      else\n        memset (&buf->mbstate, 0, sizeof (buf->mbstate));\n    }\n}",
      "lines": 14,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "line_copy": {
      "start_point": [
        313,
        0
      ],
      "end_point": [
        339,
        1
      ],
      "content": "static void\nline_copy(struct line *from, struct line *to, int state)\n{\n  /* Remove the inactive portion in the destination buffer. */\n  to->alloc += to->active - to->text;\n\n  if (to->alloc < from->length)\n    {\n      to->alloc *= 2;\n      if (to->alloc < from->length)\n        to->alloc = from->length;\n      if (to->alloc < INITIAL_BUFFER_SIZE)\n        to->alloc = INITIAL_BUFFER_SIZE;\n      /* Use free()+MALLOC() instead of REALLOC() to\n         avoid unnecessary copying of old text. */\n      free(to->text);\n      to->text = MALLOC(to->alloc + DFA_SLOP, char);\n    }\n\n  to->active = to->text;\n  to->length = from->length;\n  to->chomped = from->chomped;\n  memcpy(to->active, from->active, from->length);\n\n  if (state)\n    memcpy(&to->mbstate, &from->mbstate, sizeof (from->mbstate));\n}",
      "lines": 27,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "line_append": {
      "start_point": [
        343,
        0
      ],
      "end_point": [
        352,
        1
      ],
      "content": "static void\nline_append (struct line *from, struct line *to, int state)\n{\n  str_append(to, &buffer_delimiter, 1);\n  str_append(to, from->active, from->length);\n  to->chomped = from->chomped;\n\n  if (state)\n    memcpy (&to->mbstate, &from->mbstate, sizeof (from->mbstate));\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "line_exchange": {
      "start_point": [
        356,
        0
      ],
      "end_point": [
        373,
        1
      ],
      "content": "static void\nline_exchange (struct line *a, struct line *b, int state)\n{\n  struct line t;\n\n  if (state)\n    {\n      memcpy(&t,  a, sizeof (struct line));\n      memcpy( a,  b, sizeof (struct line));\n      memcpy( b, &t, sizeof (struct line));\n    }\n  else\n    {\n      memcpy(&t,  a, SIZEOF_LINE);\n      memcpy( a,  b, SIZEOF_LINE);\n      memcpy( b, &t, SIZEOF_LINE);\n    }\n}",
      "lines": 18,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "read_always_fail": {
      "start_point": [
        377,
        0
      ],
      "end_point": [
        381,
        1
      ],
      "content": "static bool\nread_always_fail(struct input *input _GL_UNUSED)\n{\n  return false;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "read_file_line": {
      "start_point": [
        383,
        0
      ],
      "end_point": [
        401,
        1
      ],
      "content": "static bool\nread_file_line(struct input *input)\n{\n  static char *b;\n  static size_t blen;\n\n  long result = ck_getdelim (&b, &blen, buffer_delimiter, input->fp);\n  if (result <= 0)\n    return false;\n\n  /* Remove the trailing new-line that is left by getline. */\n  if (b[result - 1] == buffer_delimiter)\n    --result;\n  else\n    line.chomped = false;\n\n  str_append(&line, b, result);\n  return true;\n}",
      "lines": 19,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "output_missing_newline": {
      "start_point": [
        404,
        0
      ],
      "end_point": [
        412,
        1
      ],
      "content": "static inline void\noutput_missing_newline(struct output *outf)\n{\n  if (outf->missing_newline)\n    {\n      ck_fwrite(&buffer_delimiter, 1, 1, outf->fp);\n      outf->missing_newline = false;\n    }\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    },
    "flush_output": {
      "start_point": [
        414,
        0
      ],
      "end_point": [
        419,
        1
      ],
      "content": "static inline void\nflush_output(FILE *fp)\n{\n  if (fp != stdout || unbuffered)\n    ck_fflush(fp);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    },
    "output_line": {
      "start_point": [
        421,
        0
      ],
      "end_point": [
        436,
        1
      ],
      "content": "static void\noutput_line(const char *text, size_t length, int nl, struct output *outf)\n{\n  if (!text)\n    return;\n\n  output_missing_newline(outf);\n  if (length)\n    ck_fwrite(text, 1, length, outf->fp);\n  if (nl)\n    ck_fwrite(&buffer_delimiter, 1, 1, outf->fp);\n  else\n    outf->missing_newline = true;\n\n  flush_output(outf->fp);\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "next_append_slot": {
      "start_point": [
        438,
        0
      ],
      "end_point": [
        454,
        1
      ],
      "content": "static struct append_queue *\nnext_append_slot(void)\n{\n  struct append_queue *n = MALLOC(1, struct append_queue);\n\n  n->fname = NULL;\n  n->text = NULL;\n  n->textlen = 0;\n  n->next = NULL;\n  n->free = false;\n\n  if (append_tail)\n      append_tail->next = n;\n  else\n      append_head = n;\n  return append_tail = n;\n}",
      "lines": 17,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "struct append_queue",
        "struct",
        "append_queue",
        "*\nnext_append_slot(void)",
        "*"
      ]
    },
    "release_append_queue": {
      "start_point": [
        456,
        0
      ],
      "end_point": [
        470,
        1
      ],
      "content": "static void\nrelease_append_queue(void)\n{\n  struct append_queue *p, *q;\n\n  for (p=append_head; p; p=q)\n    {\n      if (p->free)\n        free(p->text);\n\n      q = p->next;\n      free(p);\n    }\n  append_head = append_tail = NULL;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "dump_append_queue": {
      "start_point": [
        472,
        0
      ],
      "end_point": [
        505,
        1
      ],
      "content": "static void\ndump_append_queue(void)\n{\n  struct append_queue *p;\n\n  output_missing_newline(&output_file);\n  for (p=append_head; p; p=p->next)\n    {\n      if (p->text)\n        ck_fwrite(p->text, 1, p->textlen, output_file.fp);\n\n      if (p->fname)\n        {\n          char buf[FREAD_BUFFER_SIZE];\n          size_t cnt;\n          FILE *fp;\n\n          /* \"If _fname_ does not exist or cannot be read, it shall\n             be treated as if it were an empty file, causing no error\n             condition.\"  IEEE Std 1003.2-1992\n             So, don't fail. */\n          fp = ck_fopen(p->fname, read_mode, false);\n          if (fp)\n            {\n              while ((cnt = ck_fread(buf, 1, sizeof buf, fp)) > 0)\n                ck_fwrite(buf, 1, cnt, output_file.fp);\n              ck_fclose(fp);\n            }\n        }\n    }\n\n  flush_output(output_file.fp);\n  release_append_queue();\n}",
      "lines": 34,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "get_backup_file_name": {
      "start_point": [
        509,
        0
      ],
      "end_point": [
        537,
        1
      ],
      "content": "static char *\nget_backup_file_name(const char *name)\n{\n  char *old_asterisk, *asterisk, *backup, *p;\n  int name_length = strlen(name), backup_length = strlen(in_place_extension);\n\n  /* Compute the length of the backup file */\n  for (asterisk = in_place_extension - 1, old_asterisk = asterisk + 1;\n       (asterisk = strchr(old_asterisk, '*'));\n       old_asterisk = asterisk + 1)\n    backup_length += name_length - 1;\n\n  p = backup = xmalloc(backup_length + 1);\n\n  /* Each iteration gobbles up to an asterisk */\n  for (asterisk = in_place_extension - 1, old_asterisk = asterisk + 1;\n       (asterisk = strchr(old_asterisk, '*'));\n       old_asterisk = asterisk + 1)\n    {\n      memcpy (p, old_asterisk, asterisk - old_asterisk);\n      p += asterisk - old_asterisk;\n      strcpy (p, name);\n      p += name_length;\n    }\n\n  /* Tack on what's after the last asterisk */\n  strcpy (p, old_asterisk);\n  return backup;\n}",
      "lines": 29,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nget_backup_file_name(const char *name)",
        "*"
      ]
    },
    "open_next_file": {
      "start_point": [
        540,
        0
      ],
      "end_point": [
        641,
        1
      ],
      "content": "static void\nopen_next_file(const char *name, struct input *input)\n{\n  buffer.length = 0;\n\n  input->in_file_name = name;\n  if (name[0] == '-' && name[1] == '\\0' && !in_place_extension)\n    {\n      clearerr(stdin);\t/* clear any stale EOF indication */\n#if defined WIN32 || defined _WIN32 || defined __CYGWIN__ \\\n  || defined MSDOS || defined __EMX__\n      input->fp = ck_fdopen (fileno (stdin), \"stdin\", read_mode, false);\n#else\n      input->fp = stdin;\n#endif\n    }\n  else\n    {\n      if (follow_symlinks)\n        input->in_file_name = follow_symlink (name);\n\n      if ( ! (input->fp = ck_fopen (name, read_mode, false)) )\n        {\n          const char *ptr = strerror (errno);\n          fprintf (stderr, _(\"%s: can't read %s: %s\\n\"), myname, name, ptr);\n          input->read_fn = read_always_fail; /* a redundancy */\n          ++input->bad_count;\n          return;\n        }\n    }\n\n  input->read_fn = read_file_line;\n\n  if (in_place_extension)\n    {\n      int input_fd;\n      char *tmpdir, *p;\n      security_context_t old_fscreatecon;\n      int reset_fscreatecon = 0;\n      memset (&old_fscreatecon, 0, sizeof (old_fscreatecon));\n\n      /* get the base name */\n      tmpdir = ck_strdup(input->in_file_name);\n      if ((p = strrchr(tmpdir, '/')))\n        *p = 0;\n      else\n        strcpy(tmpdir, \".\");\n\n      if (isatty (fileno (input->fp)))\n        panic(_(\"couldn't edit %s: is a terminal\"), input->in_file_name);\n\n      input_fd = fileno (input->fp);\n      fstat (input_fd, &input->st);\n      if (!S_ISREG (input->st.st_mode))\n        panic(_(\"couldn't edit %s: not a regular file\"), input->in_file_name);\n\n      if (is_selinux_enabled () > 0)\n        {\n          security_context_t con;\n          if (lgetfilecon (input->in_file_name, &con) != -1)\n            {\n              /* Save and restore the old context for the sake of w and W\n                 commands.  */\n              reset_fscreatecon = getfscreatecon (&old_fscreatecon) >= 0;\n              if (setfscreatecon (con) < 0)\n                fprintf (stderr, _(\"%s: warning: failed to set default\" \\\n                                   \" file creation context to %s: %s\"),\n                         myname, con, strerror (errno));\n              freecon (con);\n            }\n          else\n            {\n              if (errno != ENOSYS)\n                fprintf (stderr, _(\"%s: warning: failed to get\" \\\n                                   \" security context of %s: %s\"),\n                         myname, input->in_file_name, strerror (errno));\n            }\n        }\n\n      output_file.fp = ck_mkstemp (&input->out_file_name, tmpdir, \"sed\",\n                                   write_mode);\n      register_cleanup_file (input->out_file_name);\n      output_file.missing_newline = false;\n      free (tmpdir);\n\n      if (reset_fscreatecon)\n        {\n          setfscreatecon (old_fscreatecon);\n          freecon (old_fscreatecon);\n        }\n\n      if (!output_file.fp)\n        panic(_(\"couldn't open temporary file %s: %s\"), input->out_file_name,\n              strerror(errno));\n    }\n  else\n    {\n      if (input->fp && unbuffered)\n        setvbuf (input->fp, NULL, _IONBF, 0);\n      output_file.fp = stdout;\n    }\n}",
      "lines": 102,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "closedown": {
      "start_point": [
        645,
        0
      ],
      "end_point": [
        687,
        1
      ],
      "content": "static void\nclosedown(struct input *input)\n{\n  input->read_fn = read_always_fail;\n  if (!input->fp)\n    return;\n\n  if (in_place_extension && output_file.fp != NULL)\n    {\n      const char *target_name;\n      int input_fd, output_fd;\n\n      target_name = input->in_file_name;\n      input_fd = fileno (input->fp);\n      output_fd = fileno (output_file.fp);\n#ifdef HAVE_FCHOWN\n      /* Try to set both UID and GID, but if that fails,\n         try to set only the GID.  Ignore failure.  */\n      if (fchown (output_fd, input->st.st_uid, input->st.st_gid) == -1)\n        ignore_value (fchown (output_fd, -1, input->st.st_gid));\n#endif\n      copy_acl (input->in_file_name, input_fd,\n                input->out_file_name, output_fd,\n                input->st.st_mode);\n\n      ck_fclose (input->fp);\n      ck_fclose (output_file.fp);\n      if (strcmp(in_place_extension, \"*\") != 0)\n        {\n          char *backup_file_name = get_backup_file_name(target_name);\n          ck_rename (target_name, backup_file_name, input->out_file_name);\n          free (backup_file_name);\n        }\n\n      ck_rename (input->out_file_name, target_name, input->out_file_name);\n      cancel_cleanup ();\n      free (input->out_file_name);\n    }\n  else\n    ck_fclose (input->fp);\n\n  input->fp = NULL;\n}",
      "lines": 43,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "reset_addresses": {
      "start_point": [
        690,
        0
      ],
      "end_point": [
        703,
        1
      ],
      "content": "static void\nreset_addresses(struct vector *vec)\n{\n  struct sed_cmd *cur_cmd;\n  int n;\n\n  for (cur_cmd = vec->v, n = vec->v_length; n--; cur_cmd++)\n    if (cur_cmd->a1\n        && cur_cmd->a1->addr_type == ADDR_IS_NUM\n        && cur_cmd->a1->addr_number == 0)\n      cur_cmd->range_state = RANGE_ACTIVE;\n    else\n      cur_cmd->range_state = RANGE_INACTIVE;\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "read_pattern_space": {
      "start_point": [
        707,
        0
      ],
      "end_point": [
        745,
        1
      ],
      "content": "static bool\nread_pattern_space(struct input *input, struct vector *the_program, int append)\n{\n  if (append_head) /* redundant test to optimize for common case */\n    dump_append_queue();\n  replaced = false;\n  if (!append)\n    line.length = 0;\n  line.chomped = true;  /* default, until proved otherwise */\n\n  while ( ! (*input->read_fn)(input) )\n    {\n      closedown(input);\n\n      if (!*input->file_list)\n        return false;\n\n      if (input->reset_at_next_file)\n        {\n          input->line_number = 0;\n          hold.length = 0;\n          reset_addresses (the_program);\n          rewind_read_files ();\n\n          /* If doing in-place editing, we will never append the\n             new-line to this file; but if the output goes to stdout,\n             we might still have to output the missing new-line.  */\n          if (in_place_extension)\n            output_file.missing_newline = false;\n\n          input->reset_at_next_file = separate_files;\n        }\n\n      open_next_file (*input->file_list++, input);\n    }\n\n  ++input->line_number;\n  return true;\n}",
      "lines": 39,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "last_file_with_data_p": {
      "start_point": [
        748,
        0
      ],
      "end_point": [
        768,
        1
      ],
      "content": "static bool\nlast_file_with_data_p(struct input *input)\n{\n  for (;;)\n    {\n      int ch;\n\n      closedown(input);\n      if (!*input->file_list)\n        return true;\n      open_next_file(*input->file_list++, input);\n      if (input->fp)\n        {\n          if ((ch = getc(input->fp)) != EOF)\n            {\n              ungetc(ch, input->fp);\n              return false;\n            }\n        }\n    }\n}",
      "lines": 21,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "test_eof": {
      "start_point": [
        771,
        0
      ],
      "end_point": [
        786,
        1
      ],
      "content": "static bool\ntest_eof(struct input *input)\n{\n  int ch;\n\n  if (buffer.length)\n    return false;\n  if (!input->fp)\n    return separate_files || last_file_with_data_p(input);\n  if (feof(input->fp))\n    return separate_files || last_file_with_data_p(input);\n  if ((ch = getc(input->fp)) == EOF)\n    return separate_files || last_file_with_data_p(input);\n  ungetc(ch, input->fp);\n  return false;\n}",
      "lines": 16,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "match_an_address_p": {
      "start_point": [
        790,
        0
      ],
      "end_point": [
        826,
        1
      ],
      "content": "static bool\nmatch_an_address_p(struct addr *addr, struct input *input)\n{\n  switch (addr->addr_type)\n    {\n    case ADDR_IS_NULL:\n      return true;\n\n    case ADDR_IS_REGEX:\n      return match_regex(addr->addr_regex, line.active, line.length, 0,\n                         NULL, 0);\n\n    case ADDR_IS_NUM_MOD:\n      return (input->line_number >= addr->addr_number\n              && ((input->line_number - addr->addr_number)\n                  % addr->addr_step) == 0);\n\n    case ADDR_IS_STEP:\n    case ADDR_IS_STEP_MOD:\n      /* reminder: these are only meaningful for a2 addresses */\n      /* a2->addr_number needs to be recomputed each time a1 address\n         matches for the step and step_mod types */\n      return (addr->addr_number <= input->line_number);\n\n    case ADDR_IS_LAST:\n      return test_eof(input);\n\n    case ADDR_IS_NUM:\n      /* reminder: these are only meaningful for a1 addresses */\n      return (addr->addr_number == input->line_number);\n\n    default:\n      panic(\"INTERNAL ERROR: bad address type\");\n    }\n  /*NOTREACHED*/\n  return false;\n}",
      "lines": 37,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "match_address_p": {
      "start_point": [
        829,
        0
      ],
      "end_point": [
        900,
        1
      ],
      "content": "static bool\nmatch_address_p(struct sed_cmd *cmd, struct input *input)\n{\n  if (!cmd->a1)\n    return true;\n\n  if (cmd->range_state != RANGE_ACTIVE)\n    {\n      if (!cmd->a2)\n        return match_an_address_p(cmd->a1, input);\n\n      /* Find if we are going to activate a range.  Handle ADDR_IS_NUM\n         specially: it represent an \"absolute\" state, it should not\n         be computed like regexes.  */\n      if (cmd->a1->addr_type == ADDR_IS_NUM)\n        {\n          if (cmd->range_state == RANGE_CLOSED\n              || input->line_number < cmd->a1->addr_number)\n            return false;\n        }\n      else\n        {\n          if (!match_an_address_p(cmd->a1, input))\n            return false;\n        }\n\n      /* Ok, start a new range.  */\n      cmd->range_state = RANGE_ACTIVE;\n      switch (cmd->a2->addr_type)\n        {\n        case ADDR_IS_REGEX:\n          /* Always include at least two lines.  */\n          return true;\n        case ADDR_IS_NUM:\n          /* Same handling as below, but always include at least one line.  */\n          if (input->line_number >= cmd->a2->addr_number)\n            cmd->range_state = RANGE_CLOSED;\n          return (input->line_number <= cmd->a2->addr_number\n                  || match_an_address_p(cmd->a1, input));\n        case ADDR_IS_STEP:\n          cmd->a2->addr_number = input->line_number + cmd->a2->addr_step;\n          return true;\n        case ADDR_IS_STEP_MOD:\n          cmd->a2->addr_number = input->line_number + cmd->a2->addr_step\n                                 - (input->line_number%cmd->a2->addr_step);\n          return true;\n        default:\n          break;\n        }\n    }\n\n  /* cmd->range_state == RANGE_ACTIVE.  Check if the range is\n     ending; also handle ADDR_IS_NUM specially in this case.  */\n\n  if (cmd->a2->addr_type == ADDR_IS_NUM)\n    {\n      /* If the second address is a line number, and if we got past\n         that line, fail to match (it can happen when you jump\n         over such addresses with `b' and `t'.  Use RANGE_CLOSED\n         so that the range is not re-enabled anymore.  */\n      if (input->line_number >= cmd->a2->addr_number)\n        cmd->range_state = RANGE_CLOSED;\n\n      return (input->line_number <= cmd->a2->addr_number);\n   }\n\n  /* Other addresses are treated as usual.  */\n  if (match_an_address_p(cmd->a2, input))\n    cmd->range_state = RANGE_CLOSED;\n\n  return true;\n}",
      "lines": 72,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "do_list": {
      "start_point": [
        903,
        0
      ],
      "end_point": [
        961,
        1
      ],
      "content": "static void\ndo_list(int line_len)\n{\n  unsigned char *p = (unsigned char *)line.active;\n  countT len = line.length;\n  countT width = 0;\n  char obuf[180];\t/* just in case we encounter a 512-bit char (;-) */\n  char *o;\n  size_t olen;\n  FILE *fp = output_file.fp;\n\n  output_missing_newline(&output_file);\n  for (; len--; ++p) {\n      o = obuf;\n\n      /* Some locales define 8-bit characters as printable.  This makes the\n         testsuite fail at 8to7.sed because the `l' command in fact will not\n         convert the 8-bit characters. */\n#if defined isascii || defined HAVE_ISASCII\n      if (isascii(*p) && ISPRINT(*p)) {\n#else\n      if (ISPRINT(*p)) {\n#endif\n          *o++ = *p;\n          if (*p == '\\\\')\n            *o++ = '\\\\';\n      } else {\n          *o++ = '\\\\';\n          switch (*p) {\n#if defined __STDC__ && __STDC__-0\n            case '\\a': *o++ = 'a'; break;\n#else /* Not STDC; we'll just assume ASCII */\n            case 007:  *o++ = 'a'; break;\n#endif\n            case '\\b': *o++ = 'b'; break;\n            case '\\f': *o++ = 'f'; break;\n            case '\\n': *o++ = 'n'; break;\n            case '\\r': *o++ = 'r'; break;\n            case '\\t': *o++ = 't'; break;\n            case '\\v': *o++ = 'v'; break;\n            default:\n              sprintf(o, \"%03o\", *p);\n              o += strlen(o);\n              break;\n            }\n      }\n      olen = o - obuf;\n      if (width+olen >= line_len && line_len > 0) {\n          ck_fwrite(\"\\\\\", 1, 1, fp);\n          ck_fwrite(&buffer_delimiter, 1, 1, fp);\n          width = 0;\n      }\n      ck_fwrite(obuf, 1, olen, fp);\n      width += olen;\n  }\n  ck_fwrite(\"$\", 1, 1, fp);\n  ck_fwrite(&buffer_delimiter, 1, 1, fp);\n  flush_output (fp);\n}",
      "lines": 59,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "append_replacement": {
      "start_point": [
        964,
        0
      ],
      "end_point": [
        1003,
        1
      ],
      "content": "static void append_replacement (struct line *buf, struct replacement *p,\n                                struct re_registers *regs)\n{\n  enum replacement_types repl_mod = 0;\n\n  for (; p; p=p->next)\n    {\n      int i = p->subst_id;\n      enum replacement_types curr_type;\n\n      /* Apply a \\[lu] modifier that was given earlier, but which we\n         have not had yet the occasion to apply.  But don't do it\n         if this replacement has a modifier of its own. */\n      curr_type = (p->repl_type & REPL_MODIFIERS)\n        ? p->repl_type\n        : p->repl_type | repl_mod;\n\n      repl_mod = 0;\n      if (p->prefix_length)\n        {\n          str_append_modified(buf, p->prefix, p->prefix_length,\n                              curr_type);\n          curr_type &= ~REPL_MODIFIERS;\n        }\n\n      if (0 <= i)\n        {\n          if (regs->end[i] == regs->start[i] && p->repl_type & REPL_MODIFIERS)\n            /* Save this modifier, we shall apply it later.\n               e.g. in s/()([a-z])/\\u\\1\\2/\n               the \\u modifier is applied to \\2, not \\1 */\n            repl_mod = curr_type & REPL_MODIFIERS;\n\n          else if (regs->end[i] != regs->start[i])\n            str_append_modified(buf, line.active + regs->start[i],\n                                (size_t)(regs->end[i] - regs->start[i]),\n                                curr_type);\n        }\n    }\n}",
      "lines": 40,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "do_subst": {
      "start_point": [
        1005,
        0
      ],
      "end_point": [
        1157,
        1
      ],
      "content": "static void\ndo_subst(struct subst *sub)\n{\n  size_t start = 0;\t/* where to start scan for (next) match in LINE */\n  size_t last_end = 0;  /* where did the last successful match end in LINE */\n  countT count = 0;\t/* number of matches found */\n  bool again = true;\n\n  static struct re_registers regs;\n\n  line_reset(&s_accum, &line);\n\n  /* The first part of the loop optimizes s/xxx// when xxx is at the\n     start, and s/xxx$// */\n  if (!match_regex(sub->regx, line.active, line.length, start,\n                   &regs, sub->max_id + 1))\n    return;\n\n  if (!sub->replacement && sub->numb <= 1)\n    {\n      if (regs.start[0] == 0 && !sub->global)\n        {\n          /* We found a match, set the `replaced' flag. */\n          replaced = true;\n\n          line.active += regs.end[0];\n          line.length -= regs.end[0];\n          line.alloc -= regs.end[0];\n          goto post_subst;\n        }\n      else if (regs.end[0] == line.length)\n        {\n          /* We found a match, set the `replaced' flag. */\n          replaced = true;\n\n          line.length = regs.start[0];\n          goto post_subst;\n        }\n    }\n\n  do\n    {\n      size_t offset = regs.start[0];\n      size_t matched = regs.end[0] - regs.start[0];\n\n      /* Copy stuff to the left of this match into the output string. */\n      if (start < offset)\n        str_append(&s_accum, line.active + start, offset - start);\n\n      /* If we're counting up to the Nth match, are we there yet?\n         And even if we are there, there is another case we have to\n         skip: are we matching an empty string immediately following\n         another match?\n\n         This latter case avoids that baaaac, when passed through\n         s,a*,x,g, gives `xbxxcx' instead of xbxcx.  This behavior is\n         unacceptable because it is not consistently applied (for\n         example, `baaaa' gives `xbx', not `xbxx'). */\n      if ((matched > 0 || count == 0 || offset > last_end)\n          && ++count >= sub->numb)\n        {\n          /* We found a match, set the `replaced' flag. */\n          replaced = true;\n\n          /* Now expand the replacement string into the output string. */\n          append_replacement (&s_accum, sub->replacement, &regs);\n          again = sub->global;\n        }\n      else\n        {\n          /* The match was not replaced.  Copy the text until its\n             end; if it was vacuous, skip over one character and\n             add that character to the output.  */\n          if (matched == 0)\n            {\n              if (start < line.length)\n                matched = 1;\n              else\n                break;\n            }\n\n          str_append(&s_accum, line.active + offset, matched);\n        }\n\n      /* Start after the match.  last_end is the real end of the matched\n         substring, excluding characters that were skipped in case the RE\n         matched the empty string.  */\n      start = offset + matched;\n      last_end = regs.end[0];\n    }\n  while (again\n         && start <= line.length\n         && match_regex(sub->regx, line.active, line.length, start,\n                        &regs, sub->max_id + 1));\n\n  /* Copy stuff to the right of the last match into the output string. */\n  if (start < line.length)\n    str_append(&s_accum, line.active + start, line.length-start);\n  s_accum.chomped = line.chomped;\n\n  /* Exchange line and s_accum.  This can be much cheaper\n     than copying s_accum.active into line.text (for huge lines). */\n  line_exchange(&line, &s_accum, false);\n\n  /* Finish up. */\n  if (count < sub->numb)\n    return;\n\n post_subst:\n  if (sub->print & 1)\n    output_line(line.active, line.length, line.chomped, &output_file);\n\n  if (sub->eval)\n    {\n#ifdef HAVE_POPEN\n      FILE *pipe_fp;\n      line_reset(&s_accum, NULL);\n\n      str_append (&line, \"\", 1);\n      pipe_fp = popen(line.active, \"r\");\n\n      if (pipe_fp != NULL)\n        {\n          while (!feof (pipe_fp))\n            {\n              char buf[4096];\n              int n = fread (buf, sizeof(char), 4096, pipe_fp);\n              if (n > 0)\n                str_append(&s_accum, buf, n);\n            }\n\n          pclose (pipe_fp);\n\n          /* Exchange line and s_accum.  This can be much cheaper than copying\n             s_accum.active into line.text (for huge lines).  See comment above\n             for 'g' as to while the third argument is incorrect anyway.  */\n          line_exchange(&line, &s_accum, true);\n          if (line.length &&\n              line.active[line.length - 1] == buffer_delimiter)\n            line.length--;\n        }\n      else\n        panic(_(\"error in subprocess\"));\n#else\n      panic(_(\"option `e' not supported\"));\n#endif\n    }\n\n  if (sub->print & 2)\n    output_line(line.active, line.length, line.chomped, &output_file);\n  if (sub->outf)\n    output_line(line.active, line.length, line.chomped, sub->outf);\n}",
      "lines": 153,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "translate_mb": {
      "start_point": [
        1212,
        0
      ],
      "end_point": [
        1272,
        1
      ],
      "content": "static void\ntranslate_mb (char *const *trans)\n{\n  size_t idx; /* index in the input line.  */\n  mbstate_t mbstate = { 0, };\n  for (idx = 0; idx < line.length;)\n    {\n      unsigned int i;\n      size_t mbclen = MBRLEN (line.active + idx,\n                              line.length - idx, &mbstate);\n      /* An invalid sequence, or a truncated multibyte\n         character.  Treat it as a single-byte character.  */\n      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)\n        mbclen = 1;\n\n      /* `i' indicate i-th translate pair.  */\n      for (i = 0; trans[2*i] != NULL; i++)\n        {\n          if (strncmp(line.active + idx, trans[2*i], mbclen) == 0)\n            {\n              bool move_remain_buffer = false;\n              const char *tr = trans[2*i+1];\n              size_t trans_len = *tr == '\\0' ? 1 : strlen (tr);\n\n              if (mbclen < trans_len)\n                {\n                  size_t new_len = (line.length + 1\n                                    + trans_len - mbclen);\n                  /* We must extend the line buffer.  */\n                  if (line.alloc < new_len)\n                    {\n                      /* And we must resize the buffer.  */\n                      resize_line(&line, new_len);\n                    }\n                  move_remain_buffer = true;\n                }\n              else if (mbclen > trans_len)\n                {\n                  /* We must truncate the line buffer.  */\n                  move_remain_buffer = true;\n                }\n              size_t prev_idx = idx;\n              if (move_remain_buffer)\n                {\n                  /* Move the remaining with \\0.  */\n                  char const *move_from = (line.active + idx + mbclen);\n                  char *move_to = line.active + idx + trans_len;\n                  size_t move_len = line.length + 1 - idx - mbclen;\n                  size_t move_offset = trans_len - mbclen;\n                  memmove(move_to, move_from, move_len);\n                  line.length += move_offset;\n                  idx += move_offset;\n                }\n              memcpy(line.active + prev_idx, trans[2*i+1],\n                     trans_len);\n              break;\n            }\n        }\n      idx += mbclen;\n    }\n}",
      "lines": 61,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "execute_program": {
      "start_point": [
        1276,
        0
      ],
      "end_point": [
        1640,
        1
      ],
      "content": "static int\nexecute_program(struct vector *vec, struct input *input)\n{\n  struct sed_cmd *cur_cmd;\n  struct sed_cmd *end_cmd;\n\n  cur_cmd = vec->v;\n  end_cmd = vec->v + vec->v_length;\n  while (cur_cmd < end_cmd)\n    {\n      if (match_address_p(cur_cmd, input) != cur_cmd->addr_bang)\n        {\n          switch (cur_cmd->cmd)\n            {\n            case 'a':\n              {\n                struct append_queue *aq = next_append_slot();\n                aq->text = cur_cmd->x.cmd_txt.text;\n                aq->textlen = cur_cmd->x.cmd_txt.text_length;\n              }\n              break;\n\n            case '{':\n            case 'b':\n              cur_cmd = vec->v + cur_cmd->x.jump_index;\n              continue;\n\n            case '}':\n            case '#':\n            case ':':\n              /* Executing labels and block-ends are easy. */\n              break;\n\n            case 'c':\n              if (cur_cmd->range_state != RANGE_ACTIVE)\n                output_line(cur_cmd->x.cmd_txt.text,\n                            cur_cmd->x.cmd_txt.text_length - 1, true,\n                            &output_file);\n              /* POSIX.2 is silent about c starting a new cycle,\n                 but it seems to be expected (and make sense). */\n              FALLTHROUGH;\n            case 'd':\n              return -1;\n\n            case 'D':\n              {\n                char *p = memchr(line.active, buffer_delimiter, line.length);\n                if (!p)\n                  return -1;\n\n                ++p;\n                line.alloc -= p - line.active;\n                line.length -= p - line.active;\n                line.active += p - line.active;\n\n                /* reset to start next cycle without reading a new line: */\n                cur_cmd = vec->v;\n                continue;\n              }\n\n            case 'e': {\n#ifndef HAVE_POPEN\n              panic(_(\"`e' command not supported\"));\n#else\n              FILE *pipe_fp;\n              int cmd_length = cur_cmd->x.cmd_txt.text_length;\n              line_reset(&s_accum, NULL);\n\n              if (!cmd_length)\n                {\n                  str_append (&line, \"\", 1);\n                  pipe_fp = popen(line.active, \"r\");\n                }\n              else\n                {\n                  cur_cmd->x.cmd_txt.text[cmd_length - 1] = 0;\n                  pipe_fp = popen(cur_cmd->x.cmd_txt.text, \"r\");\n                  output_missing_newline(&output_file);\n                }\n\n              if (pipe_fp == NULL)\n                panic(_(\"error in subprocess\"));\n\n              {\n                char buf[4096];\n                int n;\n                while (!feof (pipe_fp))\n                  if ((n = fread (buf, sizeof(char), 4096, pipe_fp)) > 0)\n                    {\n                      if (!cmd_length)\n                        str_append(&s_accum, buf, n);\n                      else\n                        ck_fwrite(buf, 1, n, output_file.fp);\n                    }\n\n                pclose (pipe_fp);\n                if (!cmd_length)\n                  {\n                    /* Store into pattern space for plain `e' commands */\n                    if (s_accum.length &&\n                        s_accum.active[s_accum.length - 1] == buffer_delimiter)\n                      s_accum.length--;\n\n                    /* Exchange line and s_accum.  This can be much\n                       cheaper than copying s_accum.active into line.text\n                       (for huge lines).  See comment above for 'g' as\n                       to while the third argument is incorrect anyway.  */\n                    line_exchange(&line, &s_accum, true);\n                  }\n                else\n                  flush_output(output_file.fp);\n              }\n#endif\n              break;\n            }\n\n            case 'g':\n              /* We do not have a really good choice for the third parameter.\n                 The problem is that hold space and the input file might as\n                 well have different states; copying it from hold space means\n                 that subsequent input might be read incorrectly, while\n                 keeping it as in pattern space means that commands operating\n                 on the moved buffer might consider a wrong character set.\n                 We keep it true because it's what sed <= 4.1.5 did.  */\n              line_copy(&hold, &line, true);\n              break;\n\n            case 'G':\n              /* We do not have a really good choice for the third parameter.\n                 The problem is that hold space and pattern space might as\n                 well have different states.  So, true is as wrong as false.\n                 We keep it true because it's what sed <= 4.1.5 did, but\n                 we could consider having line_ap.  */\n              line_append(&hold, &line, true);\n              break;\n\n            case 'h':\n              /* Here, it is ok to have true.  */\n              line_copy(&line, &hold, true);\n              break;\n\n            case 'H':\n              /* See comment above for 'G' regarding the third parameter.  */\n              line_append(&line, &hold, true);\n              break;\n\n            case 'i':\n              output_line(cur_cmd->x.cmd_txt.text,\n                          cur_cmd->x.cmd_txt.text_length - 1,\n                          true, &output_file);\n              break;\n\n            case 'l':\n              do_list(cur_cmd->x.int_arg == -1\n                      ? lcmd_out_line_len\n                      : cur_cmd->x.int_arg);\n              break;\n\n            case 'n':\n              if (!no_default_output)\n                output_line(line.active, line.length, line.chomped,\n                            &output_file);\n              if (test_eof(input) || !read_pattern_space(input, vec, false))\n                return -1;\n              break;\n\n            case 'N':\n              str_append(&line, &buffer_delimiter, 1);\n\n              if (test_eof(input) || !read_pattern_space(input, vec, true))\n                {\n                  line.length--;\n                  if (posixicity == POSIXLY_EXTENDED && !no_default_output)\n                     output_line(line.active, line.length, line.chomped,\n                                 &output_file);\n                  return -1;\n                }\n              break;\n\n            case 'p':\n              output_line(line.active, line.length, line.chomped, &output_file);\n              break;\n\n            case 'P':\n              {\n                char *p = memchr(line.active, buffer_delimiter, line.length);\n                output_line(line.active, p ? p - line.active : line.length,\n                            p ? true : line.chomped, &output_file);\n              }\n              break;\n\n            case 'q':\n              if (!no_default_output)\n                output_line(line.active, line.length, line.chomped,\n                            &output_file);\n              dump_append_queue();\n              FALLTHROUGH;\n\n            case 'Q':\n              return cur_cmd->x.int_arg == -1 ? 0 : cur_cmd->x.int_arg;\n\n            case 'r':\n              if (cur_cmd->x.fname)\n                {\n                  struct append_queue *aq = next_append_slot();\n                  aq->fname = cur_cmd->x.fname;\n                }\n              break;\n\n            case 'R':\n              if (cur_cmd->x.fp && !feof (cur_cmd->x.fp))\n                {\n                  struct append_queue *aq;\n                  size_t buflen;\n                  char *text = NULL;\n                  int result;\n\n                  result = ck_getdelim (&text, &buflen, buffer_delimiter,\n                                        cur_cmd->x.fp);\n                  if (result != EOF)\n                    {\n                      aq = next_append_slot();\n                      aq->free = true;\n                      aq->text = text;\n                      aq->textlen = result;\n                    }\n                }\n              break;\n\n            case 's':\n              do_subst(cur_cmd->x.cmd_subst);\n              break;\n\n            case 't':\n              if (replaced)\n                {\n                  replaced = false;\n                  cur_cmd = vec->v + cur_cmd->x.jump_index;\n                  continue;\n                }\n              break;\n\n            case 'T':\n              if (!replaced)\n                {\n                  cur_cmd = vec->v + cur_cmd->x.jump_index;\n                  continue;\n                }\n              else\n                replaced = false;\n              break;\n\n            case 'w':\n              if (cur_cmd->x.fp)\n                output_line(line.active, line.length,\n                            line.chomped, cur_cmd->x.outf);\n              break;\n\n            case 'W':\n              if (cur_cmd->x.fp)\n                {\n                  char *p = memchr(line.active, buffer_delimiter, line.length);\n                  output_line(line.active, p ? p - line.active : line.length,\n                              p ? true : line.chomped, cur_cmd->x.outf);\n                }\n              break;\n\n            case 'x':\n              /* See comment above for 'g' regarding the third parameter.  */\n              line_exchange(&line, &hold, false);\n              break;\n\n            case 'y':\n              if (mb_cur_max > 1)\n                translate_mb (cur_cmd->x.translatemb);\n              else\n                {\n                  unsigned char *p, *e;\n                  p = (unsigned char *)line.active;\n                  for (e=p+line.length; p<e; ++p)\n                    *p = cur_cmd->x.translate[*p];\n                }\n              break;\n\n            case 'z':\n              line.length = 0;\n              break;\n\n            case '=':\n              output_missing_newline(&output_file);\n              fprintf(output_file.fp, \"%lu%c\",\n                      (unsigned long)input->line_number,\n                      buffer_delimiter);\n              flush_output(output_file.fp);\n             break;\n\n           case 'F':\n              output_missing_newline(&output_file);\n              fprintf(output_file.fp, \"%s%c\",\n                      input->in_file_name,\n                      buffer_delimiter);\n              flush_output(output_file.fp);\n             break;\n\n           default:\n             panic(\"INTERNAL ERROR: Bad cmd %c\", cur_cmd->cmd);\n           }\n        }\n\n#ifdef EXPERIMENTAL_DASH_N_OPTIMIZATION\n      /* If our top-level program consists solely of commands with\n         ADDR_IS_NUM addresses then once we past the last mentioned\n         line we should be able to quit if no_default_output is true,\n         or otherwise quickly copy input to output.  Now whether this\n         optimization is a win or not depends on how cheaply we can\n         implement this for the cases where it doesn't help, as\n         compared against how much time is saved.  One semantic\n         difference (which I think is an improvement) is that *this*\n         version will terminate after printing line two in the script\n         \"yes | sed -n 2p\".\n\n         Don't use this when in-place editing is active, because line\n         numbers restart each time then. */\n      else if (!separate_files)\n        {\n          if (cur_cmd->a1->addr_type == ADDR_IS_NUM\n              && (cur_cmd->a2\n                  ? cur_cmd->range_state == RANGE_CLOSED\n                  : cur_cmd->a1->addr_number < input->line_number))\n            {\n              /* Skip this address next time */\n              cur_cmd->addr_bang = !cur_cmd->addr_bang;\n              cur_cmd->a1->addr_type = ADDR_IS_NULL;\n              if (cur_cmd->a2)\n                cur_cmd->a2->addr_type = ADDR_IS_NULL;\n\n              /* can we make an optimization? */\n              if (cur_cmd->addr_bang)\n                {\n                  if (cur_cmd->cmd == 'b' || cur_cmd->cmd == 't'\n                      || cur_cmd->cmd == 'T' || cur_cmd->cmd == '}')\n                    branches--;\n\n                  cur_cmd->cmd = '#';\t/* replace with no-op */\n                  if (branches == 0)\n                    cur_cmd = shrink_program(vec, cur_cmd);\n                  if (!cur_cmd && no_default_output)\n                    return 0;\n                  end_cmd = vec->v + vec->v_length;\n                  if (!cur_cmd)\n                    cur_cmd = end_cmd;\n                  continue;\n                }\n            }\n        }\n#endif /*EXPERIMENTAL_DASH_N_OPTIMIZATION*/\n\n      /* this is buried down here so that a \"continue\" statement can skip it */\n      ++cur_cmd;\n    }\n\n    if (!no_default_output)\n      output_line(line.active, line.length, line.chomped, &output_file);\n    return -1;\n}",
      "lines": 365,
      "depth": 24,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "process_files": {
      "start_point": [
        1645,
        0
      ],
      "end_point": [
        1701,
        1
      ],
      "content": "int\nprocess_files(struct vector *the_program, char **argv)\n{\n  static char dash[] = \"-\";\n  static char *stdin_argv[2] = { dash, NULL };\n  struct input input;\n  int status;\n\n  line_init(&line, NULL, INITIAL_BUFFER_SIZE);\n  line_init(&hold, NULL, 0);\n  line_init(&buffer, NULL, 0);\n\n#ifdef EXPERIMENTAL_DASH_N_OPTIMIZATION\n  branches = count_branches(the_program);\n#endif /*EXPERIMENTAL_DASH_N_OPTIMIZATION*/\n  input.reset_at_next_file = true;\n  if (argv && *argv)\n    input.file_list = argv;\n  else if (in_place_extension)\n    panic(_(\"no input files\"));\n  else\n    input.file_list = stdin_argv;\n\n  input.bad_count = 0;\n  input.line_number = 0;\n  input.read_fn = read_always_fail;\n  input.fp = NULL;\n\n  status = EXIT_SUCCESS;\n  while (read_pattern_space(&input, the_program, false))\n    {\n      status = execute_program(the_program, &input);\n      if (status == -1)\n        status = EXIT_SUCCESS;\n      else\n        break;\n    }\n  closedown(&input);\n\n#ifdef DEBUG_LEAKS\n  /* We're about to exit, so these free()s are redundant.\n     But if we're running under a memory-leak detecting\n     implementation of malloc(), we want to explicitly\n     deallocate in order to avoid extraneous noise from\n     the allocator. */\n  release_append_queue();\n  free(buffer.text);\n  free(hold.text);\n  free(line.text);\n  free(s_accum.text);\n#endif /*DEBUG_LEAKS*/\n\n  if (input.bad_count)\n    status = EXIT_BAD_INPUT;\n\n  return status;\n}",
      "lines": 57,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/sed/mbcs.c": {
    "is_mb_char": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "int\nis_mb_char (int ch, mbstate_t *cur_stat)\n{\n  const char c = ch ;\n  const int mb_pending = !mbsinit (cur_stat);\n  const int result = mbrtowc (NULL, &c, 1, cur_stat);\n\n  switch (result)\n    {\n    case -2: /* Beginning or middle of valid multibyte sequence */\n      return 1;\n\n    case -1: /* Invalid sequence, byte treated like a single-byte character */\n      memset (cur_stat, 0, sizeof (mbstate_t));\n      return 0;\n\n    case 1: /* A valid byte, check if part of on-going multibyte sequence */\n      return mb_pending;\n\n    case 0: /* Special case of mbrtowc(3): the NUL character */\n      /* TODO: test this */\n      return 1;\n\n    default: /* Should never happen, as per mbrtowc(3) documentation */\n      panic (\"is_mb_char: mbrtowc (0x%x) returned %d\",\n             (unsigned int) ch, result);\n    }\n}",
      "lines": 28,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "initialize_mbcs": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "void\ninitialize_mbcs (void)\n{\n  /* For UTF-8, we know that the encoding is stateless.  */\n  const char *codeset_name;\n\n  codeset_name = locale_charset ();\n  is_utf8 = (strcmp (codeset_name, \"UTF-8\") == 0);\n\n  mb_cur_max = MB_CUR_MAX;\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "sed/sed-4.5/sed/regexp.c": {
    "dfaerror": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        46,
        1
      ],
      "content": "void\ndfaerror (char const *mesg)\n{\n  panic (\"%s\", mesg);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "dfawarn": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "void\ndfawarn (char const *mesg)\n{\n  if (!getenv (\"POSIXLY_CORRECT\"))\n    dfaerror (mesg);\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "compile_regex_1": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        161,
        1
      ],
      "content": "static void\ncompile_regex_1 (struct regex *new_regex, int needed_sub)\n{\n#ifdef REG_PERL\n  int errcode;\n  errcode = regncomp(&new_regex->pattern, new_regex->re, new_regex->sz,\n                     (needed_sub ? 0 : REG_NOSUB)\n                     | new_regex->flags\n                     | extended_regexp_flags);\n\n  if (errcode)\n    {\n      char errorbuf[200];\n      regerror(errcode, NULL, errorbuf, 200);\n      bad_prog(gettext(errorbuf));\n    }\n#else\n  const char *error;\n  int syntax = ((extended_regexp_flags & REG_EXTENDED)\n                 ? RE_SYNTAX_POSIX_EXTENDED\n                 : RE_SYNTAX_POSIX_BASIC);\n\n  syntax &= ~RE_DOT_NOT_NULL;\n  syntax |= RE_NO_POSIX_BACKTRACKING;\n\n  switch (posixicity)\n    {\n    case POSIXLY_EXTENDED:\n      syntax &= ~RE_UNMATCHED_RIGHT_PAREN_ORD;\n      break;\n    case POSIXLY_CORRECT:\n      syntax |= RE_UNMATCHED_RIGHT_PAREN_ORD;\n      break;\n    case POSIXLY_BASIC:\n      syntax |= RE_UNMATCHED_RIGHT_PAREN_ORD | RE_NO_GNU_OPS;\n      if (!(extended_regexp_flags & REG_EXTENDED))\n        syntax |= RE_LIMITED_OPS;\n      break;\n    }\n\n  if (new_regex->flags & REG_ICASE)\n    syntax |= RE_ICASE;\n  else\n    new_regex->pattern.fastmap = malloc (1 << (sizeof (char) * 8));\n  syntax |= needed_sub ? 0 : RE_NO_SUB;\n\n  /* If REG_NEWLINE is set, newlines are treated differently.  */\n  if (new_regex->flags & REG_NEWLINE)\n    {\n      /* REG_NEWLINE implies neither . nor [^...] match newline.  */\n      syntax &= ~RE_DOT_NEWLINE;\n      syntax |= RE_HAT_LISTS_NOT_NEWLINE;\n    }\n\n  re_set_syntax (syntax);\n  error = re_compile_pattern (new_regex->re, new_regex->sz,\n                              &new_regex->pattern);\n  new_regex->pattern.newline_anchor =\n    buffer_delimiter == '\\n' && (new_regex->flags & REG_NEWLINE) != 0;\n\n  new_regex->pattern.translate = NULL;\n#ifndef RE_ICASE\n  if (new_regex->flags & REG_ICASE)\n    {\n      static char translate[1 << (sizeof(char) * 8)];\n      int i;\n      for (i = 0; i < sizeof(translate) / sizeof(char); i++)\n        translate[i] = tolower (i);\n\n      new_regex->pattern.translate = translate;\n    }\n#endif\n\n  if (error)\n    bad_prog(error);\n#endif\n\n  /* Just to be sure, I mark this as not POSIXLY_CORRECT behavior */\n  if (needed_sub\n      && new_regex->pattern.re_nsub < needed_sub - 1\n      && posixicity == POSIXLY_EXTENDED)\n    {\n      char buf[200];\n      sprintf(buf, _(\"invalid reference \\\\%d on `s' command's RHS\"),\n              needed_sub - 1);\n      bad_prog(buf);\n    }\n\n  int dfaopts = buffer_delimiter == '\\n' ? 0 : DFA_EOL_NUL;\n  new_regex->dfa = dfaalloc ();\n  dfasyntax (new_regex->dfa, &localeinfo, syntax, dfaopts);\n  dfacomp (new_regex->re, new_regex->sz, new_regex->dfa, 1);\n\n  /* The patterns which consist of only ^ or $ often appear in\n     substitution, but regex and dfa are not good at them, as regex does\n     not build fastmap, and as all in buffer must be scanned for $.  So\n     we mark them to handle manually.  */\n  if (new_regex->sz == 1)\n    {\n      if (new_regex->re[0] == '^')\n        new_regex->begline = true;\n      if (new_regex->re[0] == '$')\n        new_regex->endline = true;\n    }\n}",
      "lines": 105,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "compile_regex": {
      "start_point": [
        163,
        0
      ],
      "end_point": [
        191,
        1
      ],
      "content": "struct regex *\ncompile_regex(struct buffer *b, int flags, int needed_sub)\n{\n  struct regex *new_regex;\n  size_t re_len;\n\n  /* // matches the last RE */\n  if (size_buffer(b) == 0)\n    {\n      if (flags > 0)\n        bad_prog(_(BAD_MODIF));\n      return NULL;\n    }\n\n  re_len = size_buffer(b);\n  new_regex = ck_malloc(sizeof (struct regex) + re_len - 1);\n  new_regex->flags = flags;\n  memcpy (new_regex->re, get_buffer(b), re_len);\n\n#ifdef REG_PERL\n  new_regex->sz = re_len;\n#else\n  /* GNU regex does not process \\t & co. */\n  new_regex->sz = normalize_text(new_regex->re, re_len, TEXT_REGEX);\n#endif\n\n  compile_regex_1 (new_regex, needed_sub);\n  return new_regex;\n}",
      "lines": 29,
      "depth": 12,
      "decorators": [
        "struct regex",
        "struct",
        "regex",
        "*\ncompile_regex(struct buffer *b, int flags, int needed_sub)",
        "*"
      ]
    },
    "match_regex": {
      "start_point": [
        231,
        0
      ],
      "end_point": [
        423,
        1
      ],
      "content": "int\nmatch_regex(struct regex *regex, char *buf, size_t buflen,\n            size_t buf_start_offset, struct re_registers *regarray,\n            int regsize)\n{\n  int ret;\n  static struct regex *regex_last;\n#ifdef REG_PERL\n  regmatch_t rm[10], *regmatch = rm;\n  if (regsize > 10)\n    regmatch = alloca (sizeof (regmatch_t) * regsize);\n#endif\n\n  /* printf (\"Matching from %d/%d\\n\", buf_start_offset, buflen); */\n\n  /* Keep track of the last regexp matched. */\n  if (!regex)\n    {\n      regex = regex_last;\n      if (!regex_last)\n        bad_prog(_(NO_REGEX));\n    }\n  else\n    regex_last = regex;\n\n  /* gnulib's re_search uses signed-int as length */\n  if (buflen >= INT_MAX)\n    panic (_(\"regex input buffer length larger than INT_MAX\"));\n\n#ifdef REG_PERL\n  regmatch[0].rm_so = (int)buf_start_offset;\n  regmatch[0].rm_eo = (int)buflen;\n  ret = regexec (&regex->pattern, buf, regsize, regmatch, REG_STARTEND);\n\n  if (regsize)\n    copy_regs (regarray, regmatch, regsize);\n\n  return (ret == 0);\n#else\n  if (regex->pattern.no_sub && regsize)\n    compile_regex_1 (regex, regsize);\n\n  regex->pattern.regs_allocated = REGS_REALLOCATE;\n\n  /* Optimized handling for '^' and '$' patterns */\n  if (regex->begline || regex->endline)\n    {\n      size_t offset;\n\n      if (regex->endline)\n        {\n          const char *p = NULL;\n\n          if (regex->flags & REG_NEWLINE)\n            p = memchr (buf + buf_start_offset, buffer_delimiter, buflen);\n\n          offset = p ? p - buf : buflen;\n        }\n      else if (buf_start_offset == 0)\n        /* begline anchor, starting at beginning of the buffer. */\n        offset = 0;\n      else if (!(regex->flags & REG_NEWLINE))\n        /* begline anchor, starting in the middle of the text buffer,\n           and multiline regex is not specified - will never match.\n           Example: seq 2 | sed 'N;s/^/X/g' */\n        return 0;\n      else if (buf[buf_start_offset - 1] == buffer_delimiter)\n        /* begline anchor, starting in the middle of the text buffer,\n           with multiline match, and the current character\n           is the line delimiter - start here.\n           Example: seq 2 | sed 'N;s/^/X/mg' */\n        offset = buf_start_offset;\n      else\n        {\n          /* begline anchor, starting in the middle of the search buffer,\n             all previous optimizions didn't work: search\n             for the next line delimiter character in the buffer,\n             and start from there if found. */\n          const char *p = memchr (buf + buf_start_offset, buffer_delimiter,\n                                  buflen - buf_start_offset);\n\n          if (p == NULL)\n            return 0;\n\n          offset = p - buf + 1;\n        }\n\n      if (regsize)\n        {\n          size_t i;\n\n          if (!regarray->start)\n            {\n              regarray->start = MALLOC (1, regoff_t);\n              regarray->end = MALLOC (1, regoff_t);\n              regarray->num_regs = 1;\n            }\n\n          regarray->start[0] = offset;\n          regarray->end[0] = offset;\n\n          for (i = 1 ; i < regarray->num_regs; ++i)\n            regarray->start[i] = regarray->end[i] = -1;\n        }\n\n      return 1;\n    }\n\n  if (buf_start_offset == 0)\n    {\n      struct dfa *superset = dfasuperset (regex->dfa);\n\n      if (superset && !dfaexec (superset, buf, buf + buflen, true, NULL, NULL))\n        return 0;\n\n      if ((!regsize && (regex->flags & REG_NEWLINE))\n          || (!superset && dfaisfast (regex->dfa)))\n        {\n          bool backref = false;\n\n          if (!dfaexec (regex->dfa, buf, buf + buflen, true, NULL, &backref))\n            return 0;\n\n          if (!regsize && (regex->flags & REG_NEWLINE) && !backref)\n            return 1;\n        }\n    }\n\n  /* If the buffer delimiter is not newline character, we cannot use\n     newline_anchor flag of regex.  So do it line-by-line, and add offset\n     value to results.  */\n  if ((regex->flags & REG_NEWLINE) && buffer_delimiter != '\\n')\n    {\n      const char *beg, *end;\n      const char *start;\n\n      beg = buf;\n\n      if (buf_start_offset > 0)\n        {\n          const char *eol = memrchr (buf, buffer_delimiter, buf_start_offset);\n\n          if (eol != NULL)\n            beg = eol + 1;\n        }\n\n      start = buf + buf_start_offset;\n\n      for (;;)\n        {\n          end = memchr (beg, buffer_delimiter, buf + buflen - beg);\n\n          if (end == NULL)\n            end = buf + buflen;\n\n          ret = re_search (&regex->pattern, beg, end - beg,\n                           start - beg, end - start,\n                           regsize ? regarray : NULL);\n\n          if (ret > -1)\n            {\n              size_t i;\n\n              ret += beg - buf;\n\n              if (regsize)\n                {\n                  for (i = 0; i < regarray->num_regs; ++i)\n                    {\n                      if (regarray->start[i] > -1)\n                        regarray->start[i] += beg - buf;\n                      if (regarray->end[i] > -1)\n                        regarray->end[i] += beg - buf;\n                    }\n                }\n\n              break;\n            }\n\n          if (end == buf + buflen)\n            break;\n\n          beg = start = end + 1;\n        }\n    }\n  else\n    ret = re_search (&regex->pattern, buf, buflen, buf_start_offset,\n                     buflen - buf_start_offset,\n                     regsize ? regarray : NULL);\n\n  return (ret > -1);\n#endif\n}",
      "lines": 193,
      "depth": 20,
      "decorators": [
        "int"
      ]
    },
    "release_regex": {
      "start_point": [
        427,
        0
      ],
      "end_point": [
        432,
        1
      ],
      "content": "void\nrelease_regex(struct regex *regex)\n{\n  regfree(&regex->pattern);\n  free(regex);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "sed/sed-4.5/sed/sed.c": {
    "cleanup": {
      "start_point": [
        85,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "static void\ncleanup (void)\n{\n  if (G_file_to_unlink)\n    unlink (G_file_to_unlink);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "register_cleanup_file": {
      "start_point": [
        93,
        0
      ],
      "end_point": [
        97,
        1
      ],
      "content": "void\nregister_cleanup_file (char const *file)\n{\n  G_file_to_unlink = file;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "cancel_cleanup": {
      "start_point": [
        100,
        0
      ],
      "end_point": [
        104,
        1
      ],
      "content": "void\ncancel_cleanup (void)\n{\n  G_file_to_unlink = NULL;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "void"
      ]
    },
    "contact": {
      "start_point": [
        107,
        0
      ],
      "end_point": [
        120,
        1
      ],
      "content": "static void\ncontact(int errmsg)\n{\n  FILE *out = errmsg ? stderr : stdout;\n#ifndef REG_PERL\n  fprintf(out, _(\"GNU sed home page: <https://www.gnu.org/software/sed/>.\\n\\\nGeneral help using GNU software: <https://www.gnu.org/gethelp/>.\\n\"));\n#endif\n\n  /* Only print the bug report address for `sed --help', otherwise we'll\n     get reports for other people's bugs.  */\n  if (!errmsg)\n    fprintf(out, _(\"E-mail bug reports to: <%s>.\\n\"), PACKAGE_BUGREPORT);\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "usage": {
      "start_point": [
        122,
        0
      ],
      "end_point": [
        188,
        1
      ],
      "content": "_Noreturn static void\nusage(int status)\n{\n  FILE *out = status ? stderr : stdout;\n\n#ifdef REG_PERL\n#define PERL_HELP _(\"  -R, --regexp-perl\" \\\n                    \"\\n                 use Perl 5's regular expressions\" \\\n                    \" syntax in the script.\\n\")\n#endif\n\n  fprintf(out, _(\"\\\nUsage: %s [OPTION]... {script-only-if-no-other-script} [input-file]...\\n\\\n\\n\"), myname);\n\n  fprintf(out, _(\"  -n, --quiet, --silent\\n\\\n                 suppress automatic printing of pattern space\\n\"));\n  fprintf(out, _(\"  -e script, --expression=script\\n\\\n                 add the script to the commands to be executed\\n\"));\n  fprintf(out, _(\"  -f script-file, --file=script-file\\n\\\n                 add the contents of script-file to the commands\" \\\n                 \" to be executed\\n\"));\n#ifdef ENABLE_FOLLOW_SYMLINKS\n  fprintf(out, _(\"  --follow-symlinks\\n\\\n                 follow symlinks when processing in place\\n\"));\n#endif\n  fprintf(out, _(\"  -i[SUFFIX], --in-place[=SUFFIX]\\n\\\n                 edit files in place (makes backup if SUFFIX supplied)\\n\"));\n#if defined WIN32 || defined _WIN32 || defined __CYGWIN__ \\\n  || defined MSDOS || defined __EMX__\n  fprintf(out, _(\"  -b, --binary\\n\\\n                 open files in binary mode (CR+LFs are not\" \\\n                 \" processed specially)\\n\"));\n#endif\n  fprintf(out, _(\"  -l N, --line-length=N\\n\\\n                 specify the desired line-wrap length for the `l' command\\n\"));\n  fprintf(out, _(\"  --posix\\n\\\n                 disable all GNU extensions.\\n\"));\n  fprintf(out, _(\"  -E, -r, --regexp-extended\\n\\\n                 use extended regular expressions in the script\\n\\\n                 (for portability use POSIX -E).\\n\"));\n#ifdef REG_PERL\n  fprintf(out, PERL_HELP);\n#endif\n  fprintf(out, _(\"  -s, --separate\\n\\\n                 consider files as separate rather than as a single,\\n\\\n                 continuous long stream.\\n\"));\n  fprintf(out, _(\"      --sandbox\\n\\\n                 operate in sandbox mode (disable e/r/w commands).\\n\"));\n  fprintf(out, _(\"  -u, --unbuffered\\n\\\n                 load minimal amounts of data from the input files and flush\\n\\\n                 the output buffers more often\\n\"));\n  fprintf(out, _(\"  -z, --null-data\\n\\\n                 separate lines by NUL characters\\n\"));\n  fprintf(out, _(\"      --help     display this help and exit\\n\"));\n  fprintf(out, _(\"      --version  output version information and exit\\n\"));\n  fprintf(out, _(\"\\n\\\nIf no -e, --expression, -f, or --file option is given, then the first\\n\\\nnon-option argument is taken as the sed script to interpret.  All\\n\\\nremaining arguments are names of input files; if no input files are\\n\\\nspecified, then the standard input is read.\\n\\\n\\n\"));\n  contact (status);\n\n  ck_fclose (NULL);\n  exit (status);\n}",
      "lines": 67,
      "depth": 11,
      "decorators": [
        "_Noreturn",
        "static",
        "static",
        "void",
        "void"
      ]
    },
    "main": {
      "start_point": [
        190,
        0
      ],
      "end_point": [
        382,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n#ifdef REG_PERL\n#define SHORTOPTS \"bsnrzRuEe:f:l:i::V:\"\n#else\n#define SHORTOPTS \"bsnrzuEe:f:l:i::V:\"\n#endif\n\n  enum { SANDBOX_OPTION = CHAR_MAX+1 };\n\n  static const struct option longopts[] = {\n    {\"binary\", 0, NULL, 'b'},\n    {\"regexp-extended\", 0, NULL, 'r'},\n#ifdef REG_PERL\n    {\"regexp-perl\", 0, NULL, 'R'},\n#endif\n    {\"expression\", 1, NULL, 'e'},\n    {\"file\", 1, NULL, 'f'},\n    {\"in-place\", 2, NULL, 'i'},\n    {\"line-length\", 1, NULL, 'l'},\n    {\"null-data\", 0, NULL, 'z'},\n    {\"zero-terminated\", 0, NULL, 'z'},\n    {\"quiet\", 0, NULL, 'n'},\n    {\"posix\", 0, NULL, 'p'},\n    {\"silent\", 0, NULL, 'n'},\n    {\"sandbox\", 0, NULL, SANDBOX_OPTION},\n    {\"separate\", 0, NULL, 's'},\n    {\"unbuffered\", 0, NULL, 'u'},\n    {\"version\", 0, NULL, 'v'},\n    {\"help\", 0, NULL, 'h'},\n#ifdef ENABLE_FOLLOW_SYMLINKS\n    {\"follow-symlinks\", 0, NULL, 'F'},\n#endif\n    {NULL, 0, NULL, 0}\n  };\n\n  int opt;\n  int return_code;\n  const char *cols = getenv(\"COLS\");\n\n  program_name = argv[0];\n  initialize_main (&argc, &argv);\n#if HAVE_SETLOCALE\n  /* Set locale according to user's wishes.  */\n  setlocale (LC_ALL, \"\");\n#endif\n  set_program_name (argv[0]);\n  initialize_mbcs ();\n  init_localeinfo (&localeinfo);\n\n  /* Arrange to remove any un-renamed temporary file,\n     upon premature exit.  */\n  atexit (cleanup);\n\n#if ENABLE_NLS\n\n  /* Tell program which translations to use and where to find.  */\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n#endif\n\n  if (getenv(\"POSIXLY_CORRECT\") != NULL)\n    posixicity = POSIXLY_CORRECT;\n  else\n    posixicity = POSIXLY_EXTENDED;\n\n  /* If environment variable `COLS' is set, use its value for\n     the baseline setting of `lcmd_out_line_len'.  The \"-1\"\n     is to avoid gratuitous auto-line-wrap on ttys.\n   */\n  if (cols)\n    {\n      countT t = atoi(cols);\n      if (t > 1)\n        lcmd_out_line_len = t-1;\n    }\n\n  myname = *argv;\n  while ((opt = getopt_long(argc, argv, SHORTOPTS, longopts, NULL)) != EOF)\n    {\n      switch (opt)\n        {\n        case 'n':\n          no_default_output = true;\n          break;\n        case 'e':\n          the_program = compile_string(the_program, optarg, strlen(optarg));\n          break;\n        case 'f':\n          the_program = compile_file(the_program, optarg);\n          break;\n\n        case 'z':\n          buffer_delimiter = 0;\n          break;\n\n        case 'F':\n          follow_symlinks = true;\n          break;\n\n        case 'i':\n          separate_files = true;\n          if (optarg == NULL)\n            /* use no backups */\n            in_place_extension = ck_strdup (\"*\");\n\n          else if (strchr(optarg, '*') != NULL)\n            in_place_extension = ck_strdup(optarg);\n\n          else\n            {\n              in_place_extension = MALLOC (strlen(optarg) + 2, char);\n              in_place_extension[0] = '*';\n              strcpy (in_place_extension + 1, optarg);\n            }\n\n          break;\n\n        case 'l':\n          lcmd_out_line_len = atoi(optarg);\n          break;\n\n        case 'p':\n          posixicity = POSIXLY_BASIC;\n          break;\n\n        case 'b':\n          read_mode = \"rb\";\n          write_mode = \"wb\";\n          break;\n\n        case 'E':\n        case 'r':\n#ifdef REG_PERL\n          if (extended_regexp_flags && (extended_regexp_flags!=REG_EXTENDED))\n            usage(EXIT_BAD_USAGE);\n#endif\n          extended_regexp_flags = REG_EXTENDED;\n          break;\n\n#ifdef REG_PERL\n        case 'R':\n          if (extended_regexp_flags && (extended_regexp_flags!=REG_PERL)))\n            usage(EXIT_BAD_USAGE);\n          extended_regexp_flags = REG_PERL;\n          break;\n#endif\n\n        case 's':\n          separate_files = true;\n          break;\n\n        case SANDBOX_OPTION:\n          sandbox = true;\n          break;\n\n        case 'u':\n          unbuffered = true;\n          break;\n\n        case 'v':\n          version_etc(stdout, program_name, PACKAGE_NAME, Version,\n                      AUTHORS, (char *) NULL);\n          contact(false);\n          ck_fclose (NULL);\n          exit (EXIT_SUCCESS);\n        case 'h':\n          usage(EXIT_SUCCESS);\n        default:\n          usage(EXIT_BAD_USAGE);\n        }\n    }\n\n  if (!the_program)\n    {\n      if (optind < argc)\n        {\n          char *arg = argv[optind++];\n          the_program = compile_string(the_program, arg, strlen(arg));\n        }\n      else\n        usage(EXIT_BAD_USAGE);\n    }\n  check_final_program(the_program);\n\n  return_code = process_files(the_program, argv+optind);\n\n  finish_program();\n  ck_fclose(NULL);\n\n  return return_code;\n}",
      "lines": 193,
      "depth": 18,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/sed/sed.h": {},
  "sed/sed-4.5/sed/utils.c": {
    "panic": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        80,
        1
      ],
      "content": "void\npanic(const char *str, ...)\n{\n  va_list ap;\n\n  fprintf(stderr, \"%s: \", myname);\n  va_start(ap, str);\n  vfprintf(stderr, str, ap);\n  va_end(ap);\n  putc('\\n', stderr);\n\n  /* Unlink the temporary files.  */\n  while (open_files)\n    {\n      if (open_files->temp)\n        {\n          fclose (open_files->fp);\n          errno = 0;\n          unlink (open_files->name);\n          if (errno != 0)\n            fprintf (stderr, _(\"cannot remove %s: %s\"), open_files->name,\n                     strerror (errno));\n        }\n\n      open_files = open_files->link;\n    }\n\n  exit(EXIT_PANIC);\n}",
      "lines": 29,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "utils_fp_name": {
      "start_point": [
        84,
        0
      ],
      "end_point": [
        100,
        1
      ],
      "content": "static const char * _GL_ATTRIBUTE_PURE\nutils_fp_name(FILE *fp)\n{\n  struct open_file *p;\n\n  for (p=open_files; p; p=p->link)\n    if (p->fp == fp)\n      return p->name;\n  if (fp == stdin)\n    return \"stdin\";\n  else if (fp == stdout)\n    return \"stdout\";\n  else if (fp == stderr)\n    return \"stderr\";\n\n  return \"<unknown>\";\n}",
      "lines": 17,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "* _GL_ATTRIBUTE_PURE\nutils_fp_name(FILE *fp)",
        "*",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "register_open_file": {
      "start_point": [
        102,
        0
      ],
      "end_point": [
        123,
        1
      ],
      "content": "static void\nregister_open_file (FILE *fp, const char *name)\n{\n  struct open_file *p;\n  for (p=open_files; p; p=p->link)\n    {\n      if (fp == p->fp)\n        {\n          free(p->name);\n          break;\n        }\n    }\n  if (!p)\n    {\n      p = MALLOC(1, struct open_file);\n      p->link = open_files;\n      open_files = p;\n    }\n  p->name = ck_strdup(name);\n  p->fp = fp;\n  p->temp = false;\n}",
      "lines": 22,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "ck_fopen": {
      "start_point": [
        126,
        0
      ],
      "end_point": [
        142,
        1
      ],
      "content": "FILE *\nck_fopen(const char *name, const char *mode, int fail)\n{\n  FILE *fp;\n\n  fp = fopen (name, mode);\n  if (!fp)\n    {\n      if (fail)\n        panic(_(\"couldn't open file %s: %s\"), name, strerror(errno));\n\n      return NULL;\n    }\n\n  register_open_file (fp, name);\n  return fp;\n}",
      "lines": 17,
      "depth": 12,
      "decorators": [
        "FILE",
        "*\nck_fopen(const char *name, const char *mode, int fail)",
        "*"
      ]
    },
    "ck_fdopen": {
      "start_point": [
        145,
        0
      ],
      "end_point": [
        161,
        1
      ],
      "content": "FILE *\nck_fdopen( int fd, const char *name, const char *mode, int fail)\n{\n  FILE *fp;\n\n  fp = fdopen (fd, mode);\n  if (!fp)\n    {\n      if (fail)\n        panic(_(\"couldn't attach to %s: %s\"), name, strerror(errno));\n\n      return NULL;\n    }\n\n  register_open_file (fp, name);\n  return fp;\n}",
      "lines": 17,
      "depth": 12,
      "decorators": [
        "FILE",
        "*\nck_fdopen( int fd, const char *name, const char *mode, int fail)",
        "*"
      ]
    },
    "ck_mkstemp": {
      "start_point": [
        163,
        0
      ],
      "end_point": [
        183,
        1
      ],
      "content": "FILE *\nck_mkstemp (char **p_filename, const char *tmpdir,\n            const char *base, const char *mode)\n{\n  char *template = xmalloc (strlen (tmpdir) + strlen (base) + 8);\n  sprintf (template, \"%s/%sXXXXXX\", tmpdir, base);\n\n   /* The ownership might change, so omit some permissions at first\n      so unauthorized users cannot nip in before the file is ready.\n      mkstemp forces O_BINARY on cygwin, so use mkostemp instead.  */\n  mode_t save_umask = umask (0700);\n  int fd = mkostemp (template, 0);\n  umask (save_umask);\n  if (fd == -1)\n    panic(_(\"couldn't open temporary file %s: %s\"), template, strerror(errno));\n\n  *p_filename = template;\n  FILE *fp = fdopen (fd, mode);\n  register_open_file (fp, template);\n  return fp;\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "FILE",
        "*\nck_mkstemp (char **p_filename, const char *tmpdir,\n            const char *base, const char *mode)",
        "*"
      ]
    },
    "ck_fwrite": {
      "start_point": [
        186,
        0
      ],
      "end_point": [
        195,
        1
      ],
      "content": "void\nck_fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream)\n{\n  clearerr(stream);\n  if (size && fwrite(ptr, size, nmemb, stream) != nmemb)\n    panic(ngettext(\"couldn't write %llu item to %s: %s\",\n                   \"couldn't write %llu items to %s: %s\", nmemb),\n          (unsigned long long) nmemb, utils_fp_name(stream),\n          strerror(errno));\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "ck_fread": {
      "start_point": [
        198,
        0
      ],
      "end_point": [
        206,
        1
      ],
      "content": "size_t\nck_fread(void *ptr, size_t size, size_t nmemb, FILE *stream)\n{\n  clearerr(stream);\n  if (size && (nmemb=fread(ptr, size, nmemb, stream)) <= 0 && ferror(stream))\n    panic(_(\"read error on %s: %s\"), utils_fp_name(stream), strerror(errno));\n\n  return nmemb;\n}",
      "lines": 9,
      "depth": 12,
      "decorators": [
        "size_t"
      ]
    },
    "ck_getdelim": {
      "start_point": [
        208,
        0
      ],
      "end_point": [
        225,
        1
      ],
      "content": "size_t\nck_getdelim(char **text, size_t *buflen, char buffer_delimiter, FILE *stream)\n{\n  ssize_t result;\n  bool error;\n\n  error = ferror (stream);\n  if (!error)\n    {\n      result = getdelim (text, buflen, buffer_delimiter, stream);\n      error = ferror (stream);\n    }\n\n  if (error)\n    panic (_(\"read error on %s: %s\"), utils_fp_name(stream), strerror(errno));\n\n  return result;\n}",
      "lines": 18,
      "depth": 10,
      "decorators": [
        "size_t"
      ]
    },
    "ck_fflush": {
      "start_point": [
        228,
        0
      ],
      "end_point": [
        237,
        1
      ],
      "content": "void\nck_fflush(FILE *stream)\n{\n  if (!fwriting(stream))\n    return;\n\n  clearerr(stream);\n  if (fflush(stream) == EOF && errno != EBADF)\n    panic(\"couldn't flush %s: %s\", utils_fp_name(stream), strerror(errno));\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "ck_fclose": {
      "start_point": [
        240,
        0
      ],
      "end_point": [
        273,
        1
      ],
      "content": "void\nck_fclose(FILE *stream)\n{\n  struct open_file r;\n  struct open_file *prev;\n  struct open_file *cur;\n\n  /* a NULL stream means to close all files */\n  r.link = open_files;\n  prev = &r;\n  while ( (cur = prev->link) )\n    {\n      if (!stream || stream == cur->fp)\n        {\n          do_ck_fclose (cur->fp);\n          prev->link = cur->link;\n          free(cur->name);\n          free(cur);\n        }\n      else\n        prev = cur;\n    }\n\n  open_files = r.link;\n\n  /* Also care about stdout, because if it is redirected the\n     last output operations might fail and it is important\n     to signal this as an error (perhaps to make). */\n  if (!stream)\n    {\n      do_ck_fclose (stdout);\n      do_ck_fclose (stderr);\n    }\n}",
      "lines": 34,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "do_ck_fclose": {
      "start_point": [
        276,
        0
      ],
      "end_point": [
        284,
        1
      ],
      "content": "void\ndo_ck_fclose(FILE *fp)\n{\n  ck_fflush(fp);\n  clearerr(fp);\n\n  if (fclose(fp) == EOF)\n    panic(\"couldn't close %s: %s\", utils_fp_name(fp), strerror(errno));\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "follow_symlink": {
      "start_point": [
        290,
        0
      ],
      "end_point": [
        364,
        1
      ],
      "content": "const char *\nfollow_symlink(const char *fname)\n{\n#ifdef ENABLE_FOLLOW_SYMLINKS\n  static char *buf1, *buf2;\n  static int buf_size;\n\n  struct stat statbuf;\n  const char *buf = fname, *c;\n  int rc;\n\n  if (buf_size == 0)\n    {\n      buf1 = ck_malloc (PATH_MAX + 1);\n      buf2 = ck_malloc (PATH_MAX + 1);\n      buf_size = PATH_MAX + 1;\n    }\n\n  while ((rc = lstat (buf, &statbuf)) == 0\n         && (statbuf.st_mode & S_IFLNK) == S_IFLNK)\n    {\n      if (buf == buf2)\n        {\n          strcpy (buf1, buf2);\n          buf = buf1;\n        }\n\n      while ((rc = readlink (buf, buf2, buf_size)) == buf_size)\n        {\n          buf_size *= 2;\n          buf1 = ck_realloc (buf1, buf_size);\n          buf2 = ck_realloc (buf2, buf_size);\n        }\n      if (rc < 0)\n        panic (_(\"couldn't follow symlink %s: %s\"), buf, strerror(errno));\n      else\n        buf2 [rc] = '\\0';\n\n      if (buf2[0] != '/' && (c = strrchr (buf, '/')) != NULL)\n        {\n          /* Need to handle relative paths with care.  Reallocate buf1 and\n             buf2 to be big enough.  */\n          int len = c - buf + 1;\n          if (len + rc + 1 > buf_size)\n            {\n              buf_size = len + rc + 1;\n              buf1 = ck_realloc (buf1, buf_size);\n              buf2 = ck_realloc (buf2, buf_size);\n            }\n\n          /* Always store the new path in buf1.  */\n          if (buf != buf1)\n            memcpy (buf1, buf, len);\n\n          /* Tack the relative symlink at the end of buf1.  */\n          memcpy (buf1 + len, buf2, rc + 1);\n          buf = buf1;\n        }\n      else\n        {\n          /* Use buf2 as the buffer, it saves a strcpy if it is not pointing to\n             another link.  It works for absolute symlinks, and as long as\n             symlinks do not leave the current directory.  */\n           buf = buf2;\n        }\n    }\n\n  if (rc < 0)\n    panic (_(\"cannot stat %s: %s\"), buf, strerror(errno));\n\n  return buf;\n#else\n  return fname;\n#endif /* ENABLE_FOLLOW_SYMLINKS */\n}",
      "lines": 75,
      "depth": 15,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nfollow_symlink(const char *fname)",
        "*"
      ]
    },
    "ck_rename": {
      "start_point": [
        367,
        0
      ],
      "end_point": [
        389,
        1
      ],
      "content": "void\nck_rename (const char *from, const char *to, const char *unlink_if_fail)\n{\n  int rd = rename (from, to);\n  if (rd != -1)\n    return;\n\n  if (unlink_if_fail)\n    {\n      int save_errno = errno;\n      errno = 0;\n      unlink (unlink_if_fail);\n\n      /* Failure to remove the temporary file is more severe,\n         so trigger it first.  */\n      if (errno != 0)\n        panic (_(\"cannot remove %s: %s\"), unlink_if_fail, strerror (errno));\n\n      errno = save_errno;\n    }\n\n  panic (_(\"cannot rename %s: %s\"), from, strerror (errno));\n}",
      "lines": 23,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "ck_malloc": {
      "start_point": [
        395,
        0
      ],
      "end_point": [
        402,
        1
      ],
      "content": "void *\nck_malloc(size_t size)\n{\n  void *ret = calloc(1, size ? size : 1);\n  if (!ret)\n    panic(\"couldn't allocate memory\");\n  return ret;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void",
        "*\nck_malloc(size_t size)",
        "*"
      ]
    },
    "ck_realloc": {
      "start_point": [
        405,
        0
      ],
      "end_point": [
        421,
        1
      ],
      "content": "void *\nck_realloc(void *ptr, size_t size)\n{\n  void *ret;\n\n  if (size == 0)\n    {\n      free(ptr);\n      return NULL;\n    }\n  if (!ptr)\n    return ck_malloc(size);\n  ret = realloc(ptr, size);\n  if (!ret)\n    panic(\"couldn't re-allocate memory\");\n  return ret;\n}",
      "lines": 17,
      "depth": 8,
      "decorators": [
        "void",
        "*\nck_realloc(void *ptr, size_t size)",
        "*"
      ]
    },
    "ck_strdup": {
      "start_point": [
        424,
        0
      ],
      "end_point": [
        429,
        1
      ],
      "content": "char *\nck_strdup(const char *str)\n{\n  char *ret = MALLOC(strlen(str)+1, char);\n  return strcpy(ret, str);\n}",
      "lines": 6,
      "depth": 10,
      "decorators": [
        "char",
        "*\nck_strdup(const char *str)",
        "*"
      ]
    },
    "ck_memdup": {
      "start_point": [
        432,
        0
      ],
      "end_point": [
        437,
        1
      ],
      "content": "void *\nck_memdup(const void *buf, size_t len)\n{\n  void *ret = ck_malloc(len);\n  return memcpy(ret, buf, len);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void",
        "*\nck_memdup(const void *buf, size_t len)",
        "*"
      ]
    },
    "init_buffer": {
      "start_point": [
        452,
        0
      ],
      "end_point": [
        460,
        1
      ],
      "content": "struct buffer *\ninit_buffer(void)\n{\n  struct buffer *b = MALLOC(1, struct buffer);\n  b->b = MALLOC(MIN_ALLOCATE, char);\n  b->allocated = MIN_ALLOCATE;\n  b->length = 0;\n  return b;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "struct buffer",
        "struct",
        "buffer",
        "*\ninit_buffer(void)",
        "*"
      ]
    },
    "get_buffer": {
      "start_point": [
        462,
        0
      ],
      "end_point": [
        466,
        1
      ],
      "content": "char *\nget_buffer(struct buffer const *b)\n{\n  return b->b;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nget_buffer(struct buffer const *b)",
        "*"
      ]
    },
    "size_buffer": {
      "start_point": [
        468,
        0
      ],
      "end_point": [
        472,
        1
      ],
      "content": "size_t\nsize_buffer(struct buffer const *b)\n{\n  return b->length;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "size_t"
      ]
    },
    "resize_buffer": {
      "start_point": [
        474,
        0
      ],
      "end_point": [
        492,
        1
      ],
      "content": "static void\nresize_buffer(struct buffer *b, size_t newlen)\n{\n  char *try = NULL;\n  size_t alen = b->allocated;\n\n  if (newlen <= alen)\n    return;\n  alen *= 2;\n  if (newlen < alen)\n    try = realloc(b->b, alen);\t/* Note: *not* the REALLOC() macro! */\n  if (!try)\n    {\n      alen = newlen;\n      try = REALLOC(b->b, alen, char);\n    }\n  b->allocated = alen;\n  b->b = try;\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "add_buffer": {
      "start_point": [
        494,
        0
      ],
      "end_point": [
        503,
        1
      ],
      "content": "char *\nadd_buffer(struct buffer *b, const char *p, size_t n)\n{\n  char *result;\n  if (b->allocated - b->length < n)\n    resize_buffer(b, b->length+n);\n  result = memcpy(b->b + b->length, p, n);\n  b->length += n;\n  return result;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "char",
        "*\nadd_buffer(struct buffer *b, const char *p, size_t n)",
        "*"
      ]
    },
    "add1_buffer": {
      "start_point": [
        505,
        0
      ],
      "end_point": [
        525,
        1
      ],
      "content": "char *\nadd1_buffer(struct buffer *b, int c)\n{\n  /* This special case should be kept cheap;\n   *  don't make it just a mere convenience\n   *  wrapper for add_buffer() -- even \"builtin\"\n   *  versions of memcpy(a, b, 1) can become\n   *  expensive when called too often.\n   */\n  if (c != EOF)\n    {\n      char *result;\n      if (b->allocated - b->length < 1)\n        resize_buffer(b, b->length+1);\n      result = b->b + b->length++;\n      *result = c;\n      return result;\n    }\n\n  return NULL;\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "char",
        "*\nadd1_buffer(struct buffer *b, int c)",
        "*"
      ]
    },
    "free_buffer": {
      "start_point": [
        527,
        0
      ],
      "end_point": [
        533,
        1
      ],
      "content": "void\nfree_buffer(struct buffer *b)\n{\n  if (b)\n    free(b->b);\n  free(b);\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "sed/sed-4.5/sed/utils.h": {},
  "sed/sed-4.5/testsuite/get-mb-cur-max.c": {
    "main": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  set_program_name (argv[0]);\n  if (1 < argc && setlocale (LC_ALL, argv[1]))\n    {\n      printf (\"%d\\n\", (int) MB_CUR_MAX);\n      exit (EXIT_SUCCESS);\n    }\n\n  exit (EXIT_FAILURE);\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/testsuite/ptestcases.h": {},
  "sed/sed-4.5/testsuite/test-mbrtowc.c": {
    "die": {
      "start_point": [
        131,
        0
      ],
      "end_point": [
        136,
        1
      ],
      "content": "static int\ndie (const char *msg)\n{\n  error (0, 0, \"%s: error: %s\\n\", program_name, msg);\n  exit (EXIT_FAILURE);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        138,
        0
      ],
      "end_point": [
        171,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  int c;\n  int first = 1;\n\n  set_program_name (argv[0]);\n  if (!setlocale (LC_ALL, \"\"))\n    die (\"failed to set locale\");\n\n  while ((c = getchar ()) != EOF)\n    {\n      wchar_t wc;\n      char ch = (unsigned char) c;\n      int i = (int) mbrtowc (&wc, &ch, 1, NULL);\n\n      if (!first)\n        putchar (',');\n      first = 0;\n\n      printf (\"%d\", i);\n    }\n\n  if (first)\n    die (\"empty input\");\n\n  putchar ('\\n');\n\n  if (ferror (stdin))\n    die (\"read error\");\n  close_stdout ();\n\n  exit (EXIT_SUCCESS);\n}",
      "lines": 34,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "sed/sed-4.5/testsuite/testcases.h": {}
}