{
  "libmicrohttpd/libmicrohttpd-0.9.59/doc/examples/basicauthentication.c": {
    "answer_to_connection": {
      "start_point": [
        19,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "static int\nanswer_to_connection (void *cls, struct MHD_Connection *connection,\n                      const char *url, const char *method,\n                      const char *version, const char *upload_data,\n                      size_t *upload_data_size, void **con_cls)\n{\n  char *user;\n  char *pass;\n  int fail;\n  int ret;\n  struct MHD_Response *response;\n  (void)cls;               /* Unused. Silent compiler warning. */\n  (void)url;               /* Unused. Silent compiler warning. */\n  (void)version;           /* Unused. Silent compiler warning. */\n  (void)upload_data;       /* Unused. Silent compiler warning. */\n  (void)upload_data_size;  /* Unused. Silent compiler warning. */\n\n  if (0 != strcmp (method, \"GET\"))\n    return MHD_NO;\n  if (NULL == *con_cls)\n    {\n      *con_cls = connection;\n      return MHD_YES;\n    }\n  pass = NULL;\n  user = MHD_basic_auth_get_username_password (connection,\n                                               &pass);\n  fail = ( (NULL == user) ||\n\t   (0 != strcmp (user, \"root\")) ||\n\t   (0 != strcmp (pass, \"pa$$w0rd\") ) );\n  if (NULL != user) MHD_free (user);\n  if (NULL != pass) MHD_free (pass);\n  if (fail)\n    {\n      const char *page = \"<html><body>Go away.</body></html>\";\n      response =\n\tMHD_create_response_from_buffer (strlen (page), (void *) page,\n\t\t\t\t\t MHD_RESPMEM_PERSISTENT);\n      ret = MHD_queue_basic_auth_fail_response (connection,\n\t\t\t\t\t\t\"my realm\",\n\t\t\t\t\t\tresponse);\n    }\n  else\n    {\n      const char *page = \"<html><body>A secret.</body></html>\";\n      response =\n\tMHD_create_response_from_buffer (strlen (page), (void *) page,\n\t\t\t\t\t MHD_RESPMEM_PERSISTENT);\n      ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n    }\n  MHD_destroy_response (response);\n  return ret;\n}",
      "lines": 53,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        88,
        1
      ],
      "content": "int\nmain (void)\n{\n  struct MHD_Daemon *daemon;\n\n  daemon = MHD_start_daemon (MHD_USE_INTERNAL_POLLING_THREAD, PORT, NULL, NULL,\n                             &answer_to_connection, NULL, MHD_OPTION_END);\n  if (NULL == daemon)\n    return 1;\n\n  (void) getchar ();\n\n  MHD_stop_daemon (daemon);\n  return 0;\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/doc/examples/hellobrowser.c": {
    "answer_to_connection": {
      "start_point": [
        16,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "static int\nanswer_to_connection (void *cls, struct MHD_Connection *connection,\n                      const char *url, const char *method,\n                      const char *version, const char *upload_data,\n                      size_t *upload_data_size, void **con_cls)\n{\n  const char *page = \"<html><body>Hello, browser!</body></html>\";\n  struct MHD_Response *response;\n  int ret;\n  (void)cls;               /* Unused. Silent compiler warning. */\n  (void)url;               /* Unused. Silent compiler warning. */\n  (void)method;            /* Unused. Silent compiler warning. */\n  (void)version;           /* Unused. Silent compiler warning. */\n  (void)upload_data;       /* Unused. Silent compiler warning. */\n  (void)upload_data_size;  /* Unused. Silent compiler warning. */\n  (void)con_cls;           /* Unused. Silent compiler warning. */\n\n  response =\n    MHD_create_response_from_buffer (strlen (page), (void *) page, \n\t\t\t\t     MHD_RESPMEM_PERSISTENT);\n  ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n  MHD_destroy_response (response);\n\n  return ret;\n}",
      "lines": 25,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "int\nmain (void)\n{\n  struct MHD_Daemon *daemon;\n\n  daemon = MHD_start_daemon (MHD_USE_AUTO | MHD_USE_INTERNAL_POLLING_THREAD, PORT, NULL, NULL,\n                             &answer_to_connection, NULL, MHD_OPTION_END);\n  if (NULL == daemon)\n    return 1;\n\n  (void) getchar ();\n\n  MHD_stop_daemon (daemon);\n  return 0;\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/doc/examples/largepost.c": {
    "send_page": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        114,
        1
      ],
      "content": "static int\nsend_page (struct MHD_Connection *connection,\n           const char *page,\n           int status_code)\n{\n  int ret;\n  struct MHD_Response *response;\n\n  response =\n    MHD_create_response_from_buffer (strlen (page),\n                                     (void *) page,\n\t\t\t\t     MHD_RESPMEM_MUST_COPY);\n  if (!response)\n    return MHD_NO;\n  MHD_add_response_header (response,\n                           MHD_HTTP_HEADER_CONTENT_TYPE,\n                           \"text/html\");\n  ret = MHD_queue_response (connection,\n                            status_code,\n                            response);\n  MHD_destroy_response (response);\n\n  return ret;\n}",
      "lines": 24,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "iterate_post": {
      "start_point": [
        117,
        0
      ],
      "end_point": [
        176,
        1
      ],
      "content": "static int\niterate_post (void *coninfo_cls,\n              enum MHD_ValueKind kind,\n              const char *key,\n              const char *filename,\n              const char *content_type,\n              const char *transfer_encoding,\n              const char *data,\n              uint64_t off,\n              size_t size)\n{\n  struct connection_info_struct *con_info = coninfo_cls;\n  FILE *fp;\n  (void)kind;               /* Unused. Silent compiler warning. */\n  (void)content_type;       /* Unused. Silent compiler warning. */\n  (void)transfer_encoding;  /* Unused. Silent compiler warning. */\n  (void)off;                /* Unused. Silent compiler warning. */\n\n  if (0 != strcmp (key, \"file\"))\n    {\n      con_info->answerstring = servererrorpage;\n      con_info->answercode = MHD_HTTP_BAD_REQUEST;\n      return MHD_YES;\n    }\n\n  if (! con_info->fp)\n    {\n      if (0 != con_info->answercode) /* something went wrong */\n        return MHD_YES;\n      if (NULL != (fp = fopen (filename, \"rb\")))\n        {\n          fclose (fp);\n          con_info->answerstring = fileexistspage;\n          con_info->answercode = MHD_HTTP_FORBIDDEN;\n          return MHD_YES;\n        }\n      /* NOTE: This is technically a race with the 'fopen()' above,\n         but there is no easy fix, short of moving to open(O_EXCL)\n         instead of using fopen(). For the example, we do not care. */\n      con_info->fp = fopen (filename, \"ab\");\n      if (!con_info->fp)\n        {\n          con_info->answerstring = fileioerror;\n          con_info->answercode = MHD_HTTP_INTERNAL_SERVER_ERROR;\n          return MHD_YES;\n        }\n    }\n\n  if (size > 0)\n    {\n      if (! fwrite (data, sizeof (char), size, con_info->fp))\n        {\n          con_info->answerstring = fileioerror;\n          con_info->answercode = MHD_HTTP_INTERNAL_SERVER_ERROR;\n          return MHD_YES;\n        }\n    }\n\n  return MHD_YES;\n}",
      "lines": 60,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "request_completed": {
      "start_point": [
        179,
        0
      ],
      "end_point": [
        207,
        1
      ],
      "content": "static void\nrequest_completed (void *cls,\n                   struct MHD_Connection *connection,\n                   void **con_cls,\n                   enum MHD_RequestTerminationCode toe)\n{\n  struct connection_info_struct *con_info = *con_cls;\n  (void)cls;         /* Unused. Silent compiler warning. */\n  (void)connection;  /* Unused. Silent compiler warning. */\n  (void)toe;         /* Unused. Silent compiler warning. */\n\n  if (NULL == con_info)\n    return;\n\n  if (con_info->connectiontype == POST)\n    {\n      if (NULL != con_info->postprocessor)\n        {\n          MHD_destroy_post_processor (con_info->postprocessor);\n          nr_of_uploading_clients--;\n        }\n\n      if (con_info->fp)\n        fclose (con_info->fp);\n    }\n\n  free (con_info);\n  *con_cls = NULL;\n}",
      "lines": 29,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "answer_to_connection": {
      "start_point": [
        210,
        0
      ],
      "end_point": [
        328,
        1
      ],
      "content": "static int\nanswer_to_connection (void *cls,\n                      struct MHD_Connection *connection,\n                      const char *url,\n                      const char *method,\n                      const char *version,\n                      const char *upload_data,\n                      size_t *upload_data_size,\n                      void **con_cls)\n{\n  (void)cls;               /* Unused. Silent compiler warning. */\n  (void)url;               /* Unused. Silent compiler warning. */\n  (void)version;           /* Unused. Silent compiler warning. */\n\n  if (NULL == *con_cls)\n    {\n      /* First call, setup data structures */\n      struct connection_info_struct *con_info;\n\n      if (nr_of_uploading_clients >= MAXCLIENTS)\n        return send_page (connection,\n                          busypage,\n                          MHD_HTTP_SERVICE_UNAVAILABLE);\n\n      con_info = malloc (sizeof (struct connection_info_struct));\n      if (NULL == con_info)\n        return MHD_NO;\n      con_info->answercode = 0; /* none yet */\n      con_info->fp = NULL;\n\n      if (0 == strcasecmp (method, MHD_HTTP_METHOD_POST))\n        {\n          con_info->postprocessor =\n            MHD_create_post_processor (connection,\n                                       POSTBUFFERSIZE,\n                                       &iterate_post,\n                                       (void *) con_info);\n\n          if (NULL == con_info->postprocessor)\n            {\n              free (con_info);\n              return MHD_NO;\n            }\n\n          nr_of_uploading_clients++;\n\n          con_info->connectiontype = POST;\n        }\n      else\n        {\n          con_info->connectiontype = GET;\n        }\n\n      *con_cls = (void *) con_info;\n\n      return MHD_YES;\n    }\n\n  if (0 == strcasecmp (method, MHD_HTTP_METHOD_GET))\n    {\n      /* We just return the standard form for uploads on all GET requests */\n      char buffer[1024];\n\n      snprintf (buffer,\n                sizeof (buffer),\n                askpage,\n                nr_of_uploading_clients);\n      return send_page (connection,\n                        buffer,\n                        MHD_HTTP_OK);\n    }\n\n  if (0 == strcasecmp (method, MHD_HTTP_METHOD_POST))\n    {\n      struct connection_info_struct *con_info = *con_cls;\n\n      if (0 != *upload_data_size)\n        {\n          /* Upload not yet done */\n          if (0 != con_info->answercode)\n            {\n              /* we already know the answer, skip rest of upload */\n              *upload_data_size = 0;\n              return MHD_YES;\n            }\n          if (MHD_YES !=\n              MHD_post_process (con_info->postprocessor,\n                                upload_data,\n                                *upload_data_size))\n            {\n              con_info->answerstring = postprocerror;\n              con_info->answercode = MHD_HTTP_INTERNAL_SERVER_ERROR;\n            }\n          *upload_data_size = 0;\n\n          return MHD_YES;\n        }\n      /* Upload finished */\n      if (NULL != con_info->fp)\n        {\n          fclose (con_info->fp);\n          con_info->fp = NULL;\n        }\n      if (0 == con_info->answercode)\n        {\n          /* No errors encountered, declare success */\n          con_info->answerstring = completepage;\n          con_info->answercode = MHD_HTTP_OK;\n        }\n      return send_page (connection,\n                        con_info->answerstring,\n                        con_info->answercode);\n    }\n\n  /* Note a GET or a POST, generate error */\n  return send_page (connection,\n                    errorpage,\n                    MHD_HTTP_BAD_REQUEST);\n}",
      "lines": 119,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        331,
        0
      ],
      "end_point": [
        350,
        1
      ],
      "content": "int\nmain ()\n{\n  struct MHD_Daemon *daemon;\n\n  daemon = MHD_start_daemon (MHD_USE_INTERNAL_POLLING_THREAD,\n                             PORT, NULL, NULL,\n                             &answer_to_connection, NULL,\n                             MHD_OPTION_NOTIFY_COMPLETED, &request_completed, NULL,\n                             MHD_OPTION_END);\n  if (NULL == daemon)\n    {\n      fprintf (stderr,\n               \"Failed to start daemon\\n\");\n      return 1;\n    }\n  (void) getchar ();\n  MHD_stop_daemon (daemon);\n  return 0;\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/doc/examples/logging.c": {
    "print_out_key": {
      "start_point": [
        16,
        0
      ],
      "end_point": [
        24,
        1
      ],
      "content": "static int\nprint_out_key (void *cls, enum MHD_ValueKind kind, const char *key,\n               const char *value)\n{\n  (void)cls;    /* Unused. Silent compiler warning. */\n  (void)kind;   /* Unused. Silent compiler warning. */\n  printf (\"%s: %s\\n\", key, value);\n  return MHD_YES;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "answer_to_connection": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "static int\nanswer_to_connection (void *cls, struct MHD_Connection *connection,\n                      const char *url, const char *method,\n                      const char *version, const char *upload_data,\n                      size_t *upload_data_size, void **con_cls)\n{\n  (void)cls;               /* Unused. Silent compiler warning. */\n  (void)version;           /* Unused. Silent compiler warning. */\n  (void)upload_data;       /* Unused. Silent compiler warning. */\n  (void)upload_data_size;  /* Unused. Silent compiler warning. */\n  (void)con_cls;           /* Unused. Silent compiler warning. */\n  printf (\"New %s request for %s using version %s\\n\", method, url, version);\n\n  MHD_get_connection_values (connection, MHD_HEADER_KIND, print_out_key,\n                             NULL);\n\n  return MHD_NO;\n}",
      "lines": 18,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "int\nmain ()\n{\n  struct MHD_Daemon *daemon;\n\n  daemon = MHD_start_daemon (MHD_USE_INTERNAL_POLLING_THREAD, PORT, NULL, NULL,\n                             &answer_to_connection, NULL, MHD_OPTION_END);\n  if (NULL == daemon)\n    return 1;\n\n  (void) getchar ();\n\n  MHD_stop_daemon (daemon);\n  return 0;\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/doc/examples/responseheaders.c": {
    "answer_to_connection": {
      "start_point": [
        21,
        0
      ],
      "end_point": [
        73,
        1
      ],
      "content": "static int\nanswer_to_connection (void *cls, struct MHD_Connection *connection,\n                      const char *url, const char *method,\n                      const char *version, const char *upload_data,\n                      size_t *upload_data_size, void **con_cls)\n{\n  struct MHD_Response *response;\n  int fd;\n  int ret;\n  struct stat sbuf;\n  (void)cls;               /* Unused. Silent compiler warning. */\n  (void)url;               /* Unused. Silent compiler warning. */\n  (void)version;           /* Unused. Silent compiler warning. */\n  (void)upload_data;       /* Unused. Silent compiler warning. */\n  (void)upload_data_size;  /* Unused. Silent compiler warning. */\n  (void)con_cls;           /* Unused. Silent compiler warning. */\n\n  if (0 != strcmp (method, \"GET\"))\n    return MHD_NO;\n\n  if ( (-1 == (fd = open (FILENAME, O_RDONLY))) ||\n       (0 != fstat (fd, &sbuf)) )\n    {\n      const char *errorstr =\n        \"<html><body>An internal server error has occured!\\\n                              </body></html>\";\n      /* error accessing file */\n      if (fd != -1)\n\t(void) close (fd);\n      response =\n\tMHD_create_response_from_buffer (strlen (errorstr),\n\t\t\t\t\t (void *) errorstr,\n\t\t\t\t\t MHD_RESPMEM_PERSISTENT);\n      if (NULL != response)\n        {\n          ret =\n            MHD_queue_response (connection, MHD_HTTP_INTERNAL_SERVER_ERROR,\n                                response);\n          MHD_destroy_response (response);\n\n          return ret;\n        }\n      else\n        return MHD_NO;\n    }\n  response =\n    MHD_create_response_from_fd_at_offset64 (sbuf.st_size, fd, 0);\n  MHD_add_response_header (response, \"Content-Type\", MIMETYPE);\n  ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n  MHD_destroy_response (response);\n\n  return ret;\n}",
      "lines": 53,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        76,
        0
      ],
      "end_point": [
        91,
        1
      ],
      "content": "int\nmain ()\n{\n  struct MHD_Daemon *daemon;\n\n  daemon = MHD_start_daemon (MHD_USE_INTERNAL_POLLING_THREAD, PORT, NULL, NULL,\n                             &answer_to_connection, NULL, MHD_OPTION_END);\n  if (NULL == daemon)\n    return 1;\n\n  (void) getchar ();\n\n  MHD_stop_daemon (daemon);\n\n  return 0;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/doc/examples/sessions.c": {
    "asprintf": {
      "start_point": [
        14,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "static int\nasprintf (char **resultp, const char *format, ...)\n{\n  va_list argptr;\n  char *result = NULL;\n  int len = 0;\n\n  if (format == NULL)\n    return -1;\n\n  va_start (argptr, format);\n\n  len = _vscprintf ((char *) format, argptr);\n  if (len >= 0)\n  {\n    len += 1;\n    result = (char *) malloc (sizeof (char *) * len);\n    if (result != NULL)\n    {\n      int len2 = _vscprintf ((char *) format, argptr);\n      if (len2 != len - 1 || len2 <= 0)\n      {\n        free (result);\n        result = NULL;\n        len = -1;\n      }\n      else\n      {\n        len = len2;\n        if (resultp)\n          *resultp = result;\n      }\n    }\n  }\n  va_end (argptr);\n  return len;\n}",
      "lines": 37,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "get_session": {
      "start_point": [
        167,
        0
      ],
      "end_point": [
        213,
        1
      ],
      "content": "static struct Session *\nget_session (struct MHD_Connection *connection)\n{\n  struct Session *ret;\n  const char *cookie;\n\n  cookie = MHD_lookup_connection_value (connection,\n\t\t\t\t\tMHD_COOKIE_KIND,\n\t\t\t\t\tCOOKIE_NAME);\n  if (cookie != NULL)\n    {\n      /* find existing session */\n      ret = sessions;\n      while (NULL != ret)\n\t{\n\t  if (0 == strcmp (cookie, ret->sid))\n\t    break;\n\t  ret = ret->next;\n\t}\n      if (NULL != ret)\n\t{\n\t  ret->rc++;\n\t  return ret;\n\t}\n    }\n  /* create fresh session */\n  ret = calloc (1, sizeof (struct Session));\n  if (NULL == ret)\n    {\n      fprintf (stderr, \"calloc error: %s\\n\", strerror (errno));\n      return NULL;\n    }\n  /* not a super-secure way to generate a random session ID,\n     but should do for a simple example... */\n  snprintf (ret->sid,\n\t    sizeof (ret->sid),\n\t    \"%X%X%X%X\",\n\t    (unsigned int) rand (),\n\t    (unsigned int) rand (),\n\t    (unsigned int) rand (),\n\t    (unsigned int) rand ());\n  ret->rc++;\n  ret->start = time (NULL);\n  ret->next = sessions;\n  sessions = ret;\n  return ret;\n}",
      "lines": 47,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "struct Session",
        "struct",
        "Session",
        "*\nget_session (struct MHD_Connection *connection)",
        "*"
      ]
    },
    "add_session_cookie": {
      "start_point": [
        264,
        0
      ],
      "end_point": [
        282,
        1
      ],
      "content": "static void\nadd_session_cookie (struct Session *session,\n\t\t    struct MHD_Response *response)\n{\n  char cstr[256];\n  snprintf (cstr,\n\t    sizeof (cstr),\n\t    \"%s=%s\",\n\t    COOKIE_NAME,\n\t    session->sid);\n  if (MHD_NO ==\n      MHD_add_response_header (response,\n\t\t\t       MHD_HTTP_HEADER_SET_COOKIE,\n\t\t\t       cstr))\n    {\n      fprintf (stderr,\n\t       \"Failed to set session cookie header!\\n\");\n    }\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "serve_simple_form": {
      "start_point": [
        294,
        0
      ],
      "end_point": [
        317,
        1
      ],
      "content": "static int\nserve_simple_form (const void *cls,\n\t\t   const char *mime,\n\t\t   struct Session *session,\n\t\t   struct MHD_Connection *connection)\n{\n  int ret;\n  const char *form = cls;\n  struct MHD_Response *response;\n\n  /* return static form */\n  response = MHD_create_response_from_buffer (strlen (form),\n\t\t\t\t\t      (void *) form,\n\t\t\t\t\t      MHD_RESPMEM_PERSISTENT);\n  add_session_cookie (session, response);\n  MHD_add_response_header (response,\n\t\t\t   MHD_HTTP_HEADER_CONTENT_ENCODING,\n\t\t\t   mime);\n  ret = MHD_queue_response (connection,\n\t\t\t    MHD_HTTP_OK,\n\t\t\t    response);\n  MHD_destroy_response (response);\n  return ret;\n}",
      "lines": 24,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "fill_v1_form": {
      "start_point": [
        328,
        0
      ],
      "end_point": [
        359,
        1
      ],
      "content": "static int\nfill_v1_form (const void *cls,\n\t      const char *mime,\n\t      struct Session *session,\n\t      struct MHD_Connection *connection)\n{\n  int ret;\n  const char *form = cls;\n  char *reply;\n  struct MHD_Response *response;\n\n  if (-1 == asprintf (&reply,\n\t\t      form,\n\t\t      session->value_1))\n    {\n      /* oops */\n      return MHD_NO;\n    }\n  /* return static form */\n  response = MHD_create_response_from_buffer (strlen (reply),\n\t\t\t\t\t      (void *) reply,\n\t\t\t\t\t      MHD_RESPMEM_MUST_FREE);\n  add_session_cookie (session, response);\n  MHD_add_response_header (response,\n\t\t\t   MHD_HTTP_HEADER_CONTENT_ENCODING,\n\t\t\t   mime);\n  ret = MHD_queue_response (connection,\n\t\t\t    MHD_HTTP_OK,\n\t\t\t    response);\n  MHD_destroy_response (response);\n  return ret;\n}",
      "lines": 32,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "fill_v1_v2_form": {
      "start_point": [
        370,
        0
      ],
      "end_point": [
        402,
        1
      ],
      "content": "static int\nfill_v1_v2_form (const void *cls,\n\t\t const char *mime,\n\t\t struct Session *session,\n\t\t struct MHD_Connection *connection)\n{\n  int ret;\n  const char *form = cls;\n  char *reply;\n  struct MHD_Response *response;\n\n  if (-1 == asprintf (&reply,\n\t\t      form,\n\t\t      session->value_1,\n\t\t      session->value_2))\n    {\n      /* oops */\n      return MHD_NO;\n    }\n  /* return static form */\n  response = MHD_create_response_from_buffer (strlen (reply),\n\t\t\t\t\t      (void *) reply,\n\t\t\t\t\t      MHD_RESPMEM_MUST_FREE);\n  add_session_cookie (session, response);\n  MHD_add_response_header (response,\n\t\t\t   MHD_HTTP_HEADER_CONTENT_ENCODING,\n\t\t\t   mime);\n  ret = MHD_queue_response (connection,\n\t\t\t    MHD_HTTP_OK,\n\t\t\t    response);\n  MHD_destroy_response (response);\n  return ret;\n}",
      "lines": 33,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "not_found_page": {
      "start_point": [
        413,
        0
      ],
      "end_point": [
        436,
        1
      ],
      "content": "static int\nnot_found_page (const void *cls,\n\t\tconst char *mime,\n\t\tstruct Session *session,\n\t\tstruct MHD_Connection *connection)\n{\n  int ret;\n  struct MHD_Response *response;\n  (void)cls;     /* Unused. Silent compiler warning. */\n  (void)session; /* Unused. Silent compiler warning. */\n\n  /* unsupported HTTP method */\n  response = MHD_create_response_from_buffer (strlen (NOT_FOUND_ERROR),\n\t\t\t\t\t      (void *) NOT_FOUND_ERROR,\n\t\t\t\t\t      MHD_RESPMEM_PERSISTENT);\n  ret = MHD_queue_response (connection,\n\t\t\t    MHD_HTTP_NOT_FOUND,\n\t\t\t    response);\n  MHD_add_response_header (response,\n\t\t\t   MHD_HTTP_HEADER_CONTENT_ENCODING,\n\t\t\t   mime);\n  MHD_destroy_response (response);\n  return ret;\n}",
      "lines": 24,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "post_iterator": {
      "start_point": [
        472,
        0
      ],
      "end_point": [
        521,
        1
      ],
      "content": "static int\npost_iterator (void *cls,\n\t       enum MHD_ValueKind kind,\n\t       const char *key,\n\t       const char *filename,\n\t       const char *content_type,\n\t       const char *transfer_encoding,\n\t       const char *data, uint64_t off, size_t size)\n{\n  struct Request *request = cls;\n  struct Session *session = request->session;\n  (void)kind;               /* Unused. Silent compiler warning. */\n  (void)filename;           /* Unused. Silent compiler warning. */\n  (void)content_type;       /* Unused. Silent compiler warning. */\n  (void)transfer_encoding;  /* Unused. Silent compiler warning. */\n\n  if (0 == strcmp (\"DONE\", key))\n    {\n      fprintf (stdout,\n\t       \"Session `%s' submitted `%s', `%s'\\n\",\n\t       session->sid,\n\t       session->value_1,\n\t       session->value_2);\n      return MHD_YES;\n    }\n  if (0 == strcmp (\"v1\", key))\n    {\n      if (size + off > sizeof(session->value_1))\n\tsize = sizeof (session->value_1) - off;\n      memcpy (&session->value_1[off],\n\t      data,\n\t      size);\n      if (size + off < sizeof (session->value_1))\n\tsession->value_1[size+off] = '\\0';\n      return MHD_YES;\n    }\n  if (0 == strcmp (\"v2\", key))\n    {\n      if (size + off > sizeof(session->value_2))\n\tsize = sizeof (session->value_2) - off;\n      memcpy (&session->value_2[off],\n\t      data,\n\t      size);\n      if (size + off < sizeof (session->value_2))\n\tsession->value_2[size+off] = '\\0';\n      return MHD_YES;\n    }\n  fprintf (stderr, \"Unsupported form value `%s'\\n\", key);\n  return MHD_YES;\n}",
      "lines": 50,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "create_response": {
      "start_point": [
        558,
        0
      ],
      "end_point": [
        655,
        1
      ],
      "content": "static int\ncreate_response (void *cls,\n\t\t struct MHD_Connection *connection,\n\t\t const char *url,\n\t\t const char *method,\n\t\t const char *version,\n\t\t const char *upload_data,\n\t\t size_t *upload_data_size,\n\t\t void **ptr)\n{\n  struct MHD_Response *response;\n  struct Request *request;\n  struct Session *session;\n  int ret;\n  unsigned int i;\n  (void)cls;               /* Unused. Silent compiler warning. */\n  (void)version;           /* Unused. Silent compiler warning. */\n\n  request = *ptr;\n  if (NULL == request)\n    {\n      request = calloc (1, sizeof (struct Request));\n      if (NULL == request)\n\t{\n\t  fprintf (stderr, \"calloc error: %s\\n\", strerror (errno));\n\t  return MHD_NO;\n\t}\n      *ptr = request;\n      if (0 == strcmp (method, MHD_HTTP_METHOD_POST))\n\t{\n\t  request->pp = MHD_create_post_processor (connection, 1024,\n\t\t\t\t\t\t   &post_iterator, request);\n\t  if (NULL == request->pp)\n\t    {\n\t      fprintf (stderr, \"Failed to setup post processor for `%s'\\n\",\n\t\t       url);\n\t      return MHD_NO; /* internal error */\n\t    }\n\t}\n      return MHD_YES;\n    }\n  if (NULL == request->session)\n    {\n      request->session = get_session (connection);\n      if (NULL == request->session)\n\t{\n\t  fprintf (stderr, \"Failed to setup session for `%s'\\n\",\n\t\t   url);\n\t  return MHD_NO; /* internal error */\n\t}\n    }\n  session = request->session;\n  session->start = time (NULL);\n  if (0 == strcmp (method, MHD_HTTP_METHOD_POST))\n    {\n      /* evaluate POST data */\n      MHD_post_process (request->pp,\n\t\t\tupload_data,\n\t\t\t*upload_data_size);\n      if (0 != *upload_data_size)\n\t{\n\t  *upload_data_size = 0;\n\t  return MHD_YES;\n\t}\n      /* done with POST data, serve response */\n      MHD_destroy_post_processor (request->pp);\n      request->pp = NULL;\n      method = MHD_HTTP_METHOD_GET; /* fake 'GET' */\n      if (NULL != request->post_url)\n\turl = request->post_url;\n    }\n\n  if ( (0 == strcmp (method, MHD_HTTP_METHOD_GET)) ||\n       (0 == strcmp (method, MHD_HTTP_METHOD_HEAD)) )\n    {\n      /* find out which page to serve */\n      i=0;\n      while ( (pages[i].url != NULL) &&\n\t      (0 != strcmp (pages[i].url, url)) )\n\ti++;\n      ret = pages[i].handler (pages[i].handler_cls,\n\t\t\t      pages[i].mime,\n\t\t\t      session, connection);\n      if (ret != MHD_YES)\n\tfprintf (stderr, \"Failed to create page for `%s'\\n\",\n\t\t url);\n      return ret;\n    }\n  /* unsupported HTTP method */\n  response = MHD_create_response_from_buffer (strlen (METHOD_ERROR),\n\t\t\t\t\t      (void *) METHOD_ERROR,\n\t\t\t\t\t      MHD_RESPMEM_PERSISTENT);\n  ret = MHD_queue_response (connection,\n\t\t\t    MHD_HTTP_NOT_ACCEPTABLE,\n\t\t\t    response);\n  MHD_destroy_response (response);\n  return ret;\n}",
      "lines": 98,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "request_completed_callback": {
      "start_point": [
        667,
        0
      ],
      "end_point": [
        685,
        1
      ],
      "content": "static void\nrequest_completed_callback (void *cls,\n\t\t\t    struct MHD_Connection *connection,\n\t\t\t    void **con_cls,\n\t\t\t    enum MHD_RequestTerminationCode toe)\n{\n  struct Request *request = *con_cls;\n  (void)cls;         /* Unused. Silent compiler warning. */\n  (void)connection;  /* Unused. Silent compiler warning. */\n  (void)toe;         /* Unused. Silent compiler warning. */\n\n  if (NULL == request)\n    return;\n  if (NULL != request->session)\n    request->session->rc--;\n  if (NULL != request->pp)\n    MHD_destroy_post_processor (request->pp);\n  free (request);\n}",
      "lines": 19,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "expire_sessions": {
      "start_point": [
        692,
        0
      ],
      "end_point": [
        719,
        1
      ],
      "content": "static void\nexpire_sessions ()\n{\n  struct Session *pos;\n  struct Session *prev;\n  struct Session *next;\n  time_t now;\n\n  now = time (NULL);\n  prev = NULL;\n  pos = sessions;\n  while (NULL != pos)\n    {\n      next = pos->next;\n      if (now - pos->start > 60 * 60)\n\t{\n\t  /* expire sessions after 1h */\n\t  if (NULL == prev)\n\t    sessions = pos->next;\n\t  else\n\t    prev->next = next;\n\t  free (pos);\n\t}\n      else\n        prev = pos;\n      pos = next;\n    }\n}",
      "lines": 28,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        726,
        0
      ],
      "end_point": [
        783,
        1
      ],
      "content": "int\nmain (int argc, char *const *argv)\n{\n  struct MHD_Daemon *d;\n  struct timeval tv;\n  struct timeval *tvp;\n  fd_set rs;\n  fd_set ws;\n  fd_set es;\n  MHD_socket max;\n  MHD_UNSIGNED_LONG_LONG mhd_timeout;\n\n  if (argc != 2)\n    {\n      printf (\"%s PORT\\n\", argv[0]);\n      return 1;\n    }\n  /* initialize PRNG */\n  srand ((unsigned int) time (NULL));\n  d = MHD_start_daemon (MHD_USE_ERROR_LOG,\n                        atoi (argv[1]),\n                        NULL, NULL,\n\t\t\t&create_response, NULL,\n\t\t\tMHD_OPTION_CONNECTION_TIMEOUT, (unsigned int) 15,\n\t\t\tMHD_OPTION_NOTIFY_COMPLETED, &request_completed_callback, NULL,\n\t\t\tMHD_OPTION_END);\n  if (NULL == d)\n    return 1;\n  while (1)\n    {\n      expire_sessions ();\n      max = 0;\n      FD_ZERO (&rs);\n      FD_ZERO (&ws);\n      FD_ZERO (&es);\n      if (MHD_YES != MHD_get_fdset (d, &rs, &ws, &es, &max))\n\tbreak; /* fatal internal error */\n      if (MHD_get_timeout (d, &mhd_timeout) == MHD_YES)\n\t{\n\t  tv.tv_sec = mhd_timeout / 1000;\n\t  tv.tv_usec = (mhd_timeout - (tv.tv_sec * 1000)) * 1000;\n\t  tvp = &tv;\n\t}\n      else\n\ttvp = NULL;\n      if (-1 == select (max + 1, &rs, &ws, &es, tvp))\n\t{\n\t  if (EINTR != errno)\n\t    fprintf (stderr,\n\t\t     \"Aborting due to error during select: %s\\n\",\n\t\t     strerror (errno));\n\t  break;\n\t}\n      MHD_run (d);\n    }\n  MHD_stop_daemon (d);\n  return 0;\n}",
      "lines": 58,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/doc/examples/simplepost.c": {
    "send_page": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "static int\nsend_page (struct MHD_Connection *connection, const char *page)\n{\n  int ret;\n  struct MHD_Response *response;\n\n\n  response =\n    MHD_create_response_from_buffer (strlen (page), (void *) page,\n\t\t\t\t     MHD_RESPMEM_PERSISTENT);\n  if (!response)\n    return MHD_NO;\n\n  ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n  MHD_destroy_response (response);\n\n  return ret;\n}",
      "lines": 18,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "iterate_post": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        101,
        1
      ],
      "content": "static int\niterate_post (void *coninfo_cls, enum MHD_ValueKind kind, const char *key,\n              const char *filename, const char *content_type,\n              const char *transfer_encoding, const char *data, uint64_t off,\n              size_t size)\n{\n  struct connection_info_struct *con_info = coninfo_cls;\n  (void)kind;               /* Unused. Silent compiler warning. */\n  (void)filename;           /* Unused. Silent compiler warning. */\n  (void)content_type;       /* Unused. Silent compiler warning. */\n  (void)transfer_encoding;  /* Unused. Silent compiler warning. */\n  (void)off;                /* Unused. Silent compiler warning. */\n\n  if (0 == strcmp (key, \"name\"))\n    {\n      if ((size > 0) && (size <= MAXNAMESIZE))\n        {\n          char *answerstring;\n          answerstring = malloc (MAXANSWERSIZE);\n          if (!answerstring)\n            return MHD_NO;\n\n          snprintf (answerstring, MAXANSWERSIZE, greetingpage, data);\n          con_info->answerstring = answerstring;\n        }\n      else\n        con_info->answerstring = NULL;\n\n      return MHD_NO;\n    }\n\n  return MHD_YES;\n}",
      "lines": 33,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "request_completed": {
      "start_point": [
        103,
        0
      ],
      "end_point": [
        124,
        1
      ],
      "content": "static void\nrequest_completed (void *cls, struct MHD_Connection *connection,\n                   void **con_cls, enum MHD_RequestTerminationCode toe)\n{\n  struct connection_info_struct *con_info = *con_cls;\n  (void)cls;         /* Unused. Silent compiler warning. */\n  (void)connection;  /* Unused. Silent compiler warning. */\n  (void)toe;         /* Unused. Silent compiler warning. */\n\n  if (NULL == con_info)\n    return;\n\n  if (con_info->connectiontype == POST)\n    {\n      MHD_destroy_post_processor (con_info->postprocessor);\n      if (con_info->answerstring)\n        free (con_info->answerstring);\n    }\n\n  free (con_info);\n  *con_cls = NULL;\n}",
      "lines": 22,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "answer_to_connection": {
      "start_point": [
        127,
        0
      ],
      "end_point": [
        190,
        1
      ],
      "content": "static int\nanswer_to_connection (void *cls, struct MHD_Connection *connection,\n                      const char *url, const char *method,\n                      const char *version, const char *upload_data,\n                      size_t *upload_data_size, void **con_cls)\n{\n  (void)cls;               /* Unused. Silent compiler warning. */\n  (void)url;               /* Unused. Silent compiler warning. */\n  (void)version;           /* Unused. Silent compiler warning. */\n\n  if (NULL == *con_cls)\n    {\n      struct connection_info_struct *con_info;\n\n      con_info = malloc (sizeof (struct connection_info_struct));\n      if (NULL == con_info)\n        return MHD_NO;\n      con_info->answerstring = NULL;\n\n      if (0 == strcmp (method, \"POST\"))\n        {\n          con_info->postprocessor =\n            MHD_create_post_processor (connection, POSTBUFFERSIZE,\n                                       iterate_post, (void *) con_info);\n\n          if (NULL == con_info->postprocessor)\n            {\n              free (con_info);\n              return MHD_NO;\n            }\n\n          con_info->connectiontype = POST;\n        }\n      else\n        con_info->connectiontype = GET;\n\n      *con_cls = (void *) con_info;\n\n      return MHD_YES;\n    }\n\n  if (0 == strcmp (method, \"GET\"))\n    {\n      return send_page (connection, askpage);\n    }\n\n  if (0 == strcmp (method, \"POST\"))\n    {\n      struct connection_info_struct *con_info = *con_cls;\n\n      if (*upload_data_size != 0)\n        {\n          MHD_post_process (con_info->postprocessor, upload_data,\n                            *upload_data_size);\n          *upload_data_size = 0;\n\n          return MHD_YES;\n        }\n      else if (NULL != con_info->answerstring)\n        return send_page (connection, con_info->answerstring);\n    }\n\n  return send_page (connection, errorpage);\n}",
      "lines": 64,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        192,
        0
      ],
      "end_point": [
        209,
        1
      ],
      "content": "int\nmain ()\n{\n  struct MHD_Daemon *daemon;\n\n  daemon = MHD_start_daemon (MHD_USE_AUTO | MHD_USE_INTERNAL_POLLING_THREAD, PORT, NULL, NULL,\n                             &answer_to_connection, NULL,\n                             MHD_OPTION_NOTIFY_COMPLETED, request_completed,\n                             NULL, MHD_OPTION_END);\n  if (NULL == daemon)\n    return 1;\n\n  (void) getchar ();\n\n  MHD_stop_daemon (daemon);\n\n  return 0;\n}",
      "lines": 18,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/doc/examples/tlsauthentication.c": {
    "string_to_base64": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "static char *\nstring_to_base64 (const char *message)\n{\n  const char *lookup =\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n  unsigned long l;\n  size_t i;\n  char *tmp;\n  size_t length = strlen (message);\n\n  tmp = malloc (length * 2);\n  if (NULL == tmp)\n    return tmp;\n\n  tmp[0] = 0;\n\n  for (i = 0; i < length; i += 3)\n    {\n      l = (((unsigned long) message[i]) << 16)\n        | (((i + 1) < length) ? (((unsigned long) message[i + 1]) << 8) : 0)\n        | (((i + 2) < length) ? ((unsigned long) message[i + 2]) : 0);\n\n\n      strncat (tmp, &lookup[(l >> 18) & 0x3F], 1);\n      strncat (tmp, &lookup[(l >> 12) & 0x3F], 1);\n\n      if (i + 1 < length)\n        strncat (tmp, &lookup[(l >> 6) & 0x3F], 1);\n      if (i + 2 < length)\n        strncat (tmp, &lookup[l & 0x3F], 1);\n    }\n\n  if (length % 3)\n    strncat (tmp, \"===\", 3 - length % 3);\n\n  return tmp;\n}",
      "lines": 37,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nstring_to_base64 (const char *message)",
        "*"
      ]
    },
    "get_file_size": {
      "start_point": [
        64,
        0
      ],
      "end_point": [
        83,
        1
      ],
      "content": "static long\nget_file_size (const char *filename)\n{\n  FILE *fp;\n\n  fp = fopen (filename, \"rb\");\n  if (fp)\n    {\n      long size;\n\n      if ((0 != fseek (fp, 0, SEEK_END)) || (-1 == (size = ftell (fp))))\n        size = 0;\n\n      fclose (fp);\n\n      return size;\n    }\n  else\n    return 0;\n}",
      "lines": 20,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "long",
        "long"
      ]
    },
    "load_file": {
      "start_point": [
        86,
        0
      ],
      "end_point": [
        117,
        1
      ],
      "content": "static char *\nload_file (const char *filename)\n{\n  FILE *fp;\n  char *buffer;\n  long size;\n\n  size = get_file_size (filename);\n  if (0 == size)\n    return NULL;\n\n  fp = fopen (filename, \"rb\");\n  if (! fp)\n    return NULL;\n\n  buffer = malloc (size + 1);\n  if (! buffer)\n    {\n      fclose (fp);\n      return NULL;\n    }\n  buffer[size] = '\\0';\n\n  if (size != (long)fread (buffer, 1, size, fp))\n    {\n      free (buffer);\n      buffer = NULL;\n    }\n\n  fclose (fp);\n  return buffer;\n}",
      "lines": 32,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nload_file (const char *filename)",
        "*"
      ]
    },
    "ask_for_authentication": {
      "start_point": [
        120,
        0
      ],
      "end_point": [
        153,
        1
      ],
      "content": "static int\nask_for_authentication (struct MHD_Connection *connection, const char *realm)\n{\n  int ret;\n  struct MHD_Response *response;\n  char *headervalue;\n  const char *strbase = \"Basic realm=\";\n\n  response = MHD_create_response_from_buffer (0, NULL,\n\t\t\t\t\t      MHD_RESPMEM_PERSISTENT);\n  if (!response)\n    return MHD_NO;\n\n  headervalue = malloc (strlen (strbase) + strlen (realm) + 1);\n  if (!headervalue)\n    return MHD_NO;\n\n  strcpy (headervalue, strbase);\n  strcat (headervalue, realm);\n\n  ret = MHD_add_response_header (response, \"WWW-Authenticate\", headervalue);\n  free (headervalue);\n  if (!ret)\n    {\n      MHD_destroy_response (response);\n      return MHD_NO;\n    }\n\n  ret = MHD_queue_response (connection, MHD_HTTP_UNAUTHORIZED, response);\n\n  MHD_destroy_response (response);\n\n  return ret;\n}",
      "lines": 34,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "is_authenticated": {
      "start_point": [
        155,
        0
      ],
      "end_point": [
        191,
        1
      ],
      "content": "static int\nis_authenticated (struct MHD_Connection *connection,\n                  const char *username, const char *password)\n{\n  const char *headervalue;\n  char *expected_b64, *expected;\n  const char *strbase = \"Basic \";\n  int authenticated;\n\n  headervalue =\n    MHD_lookup_connection_value (connection, MHD_HEADER_KIND,\n                                 \"Authorization\");\n  if (NULL == headervalue)\n    return 0;\n  if (0 != strncmp (headervalue, strbase, strlen (strbase)))\n    return 0;\n\n  expected = malloc (strlen (username) + 1 + strlen (password) + 1);\n  if (NULL == expected)\n    return 0;\n\n  strcpy (expected, username);\n  strcat (expected, \":\");\n  strcat (expected, password);\n\n  expected_b64 = string_to_base64 (expected);\n  free (expected);\n  if (NULL == expected_b64)\n    return 0;\n\n  authenticated =\n    (strcmp (headervalue + strlen (strbase), expected_b64) == 0);\n\n  free (expected_b64);\n\n  return authenticated;\n}",
      "lines": 37,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "secret_page": {
      "start_point": [
        194,
        0
      ],
      "end_point": [
        211,
        1
      ],
      "content": "static int\nsecret_page (struct MHD_Connection *connection)\n{\n  int ret;\n  struct MHD_Response *response;\n  const char *page = \"<html><body>A secret.</body></html>\";\n\n  response =\n    MHD_create_response_from_buffer (strlen (page), (void *) page,\n\t\t\t\t     MHD_RESPMEM_PERSISTENT);\n  if (!response)\n    return MHD_NO;\n\n  ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n  MHD_destroy_response (response);\n\n  return ret;\n}",
      "lines": 18,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "answer_to_connection": {
      "start_point": [
        214,
        0
      ],
      "end_point": [
        238,
        1
      ],
      "content": "static int\nanswer_to_connection (void *cls, struct MHD_Connection *connection,\n                      const char *url, const char *method,\n                      const char *version, const char *upload_data,\n                      size_t *upload_data_size, void **con_cls)\n{\n  (void)cls;               /* Unused. Silent compiler warning. */\n  (void)url;               /* Unused. Silent compiler warning. */\n  (void)version;           /* Unused. Silent compiler warning. */\n  (void)upload_data;       /* Unused. Silent compiler warning. */\n  (void)upload_data_size;  /* Unused. Silent compiler warning. */\n\n  if (0 != strcmp (method, \"GET\"))\n    return MHD_NO;\n  if (NULL == *con_cls)\n    {\n      *con_cls = connection;\n      return MHD_YES;\n    }\n\n  if (!is_authenticated (connection, USER, PASSWORD))\n    return ask_for_authentication (connection, REALM);\n\n  return secret_page (connection);\n}",
      "lines": 25,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        241,
        0
      ],
      "end_point": [
        283,
        1
      ],
      "content": "int\nmain ()\n{\n  struct MHD_Daemon *daemon;\n  char *key_pem;\n  char *cert_pem;\n\n  key_pem = load_file (SERVERKEYFILE);\n  cert_pem = load_file (SERVERCERTFILE);\n\n  if ((key_pem == NULL) || (cert_pem == NULL))\n    {\n      printf (\"The key/certificate files could not be read.\\n\");\n      if (NULL != key_pem)\n        free (key_pem);\n      if (NULL != cert_pem)\n        free (cert_pem);\n      return 1;\n    }\n\n  daemon =\n    MHD_start_daemon (MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_TLS, PORT, NULL,\n                      NULL, &answer_to_connection, NULL,\n                      MHD_OPTION_HTTPS_MEM_KEY, key_pem,\n                      MHD_OPTION_HTTPS_MEM_CERT, cert_pem, MHD_OPTION_END);\n  if (NULL == daemon)\n    {\n      printf (\"%s\\n\", cert_pem);\n\n      free (key_pem);\n      free (cert_pem);\n\n      return 1;\n    }\n\n  (void) getchar ();\n\n  MHD_stop_daemon (daemon);\n  free (key_pem);\n  free (cert_pem);\n\n  return 0;\n}",
      "lines": 43,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/examples/authorization_example.c": {
    "ahc_echo": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        97,
        1
      ],
      "content": "static int\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data, size_t *upload_data_size, void **ptr)\n{\n  static int aptr;\n  const char *me = cls;\n  struct MHD_Response *response;\n  int ret;\n  char *user;\n  char *pass;\n  int fail;\n  (void)url;               /* Unused. Silent compiler warning. */\n  (void)version;           /* Unused. Silent compiler warning. */\n  (void)upload_data;       /* Unused. Silent compiler warning. */\n  (void)upload_data_size;  /* Unused. Silent compiler warning. */\n\n  if (0 != strcmp (method, \"GET\"))\n    return MHD_NO;              /* unexpected method */\n  if (&aptr != *ptr)\n    {\n      /* do never respond on first call */\n      *ptr = &aptr;\n      return MHD_YES;\n    }\n  *ptr = NULL;                  /* reset when done */\n\n  /* require: \"Aladdin\" with password \"open sesame\" */\n  pass = NULL;\n  user = MHD_basic_auth_get_username_password (connection,\n                                               &pass);\n  fail = ( (NULL == user) ||\n           (0 != strcmp (user, \"Aladdin\")) ||\n           (0 != strcmp (pass, \"open sesame\") ) );\n  if (fail)\n  {\n      response = MHD_create_response_from_buffer (strlen (DENIED),\n\t\t\t\t\t\t  (void *) DENIED,\n\t\t\t\t\t\t  MHD_RESPMEM_PERSISTENT);\n      ret = MHD_queue_basic_auth_fail_response (connection,\"TestRealm\",response);\n    }\n  else\n    {\n      response = MHD_create_response_from_buffer (strlen (me),\n\t\t\t\t\t\t  (void *) me,\n\t\t\t\t\t\t  MHD_RESPMEM_PERSISTENT);\n      ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n    }\n  if (NULL != user)\n    MHD_free (user);\n  if (NULL != pass)\n    MHD_free (pass);\n  MHD_destroy_response (response);\n  return ret;\n}",
      "lines": 58,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        100,
        0
      ],
      "end_point": [
        124,
        1
      ],
      "content": "int\nmain (int argc, char *const *argv)\n{\n  struct MHD_Daemon *d;\n  unsigned int port;\n\n  if ( (argc != 2) ||\n       (1 != sscanf (argv[1], \"%u\", &port)) ||\n       (UINT16_MAX < port) )\n    {\n      fprintf (stderr,\n\t       \"%s PORT\\n\", argv[0]);\n      return 1;\n    }\n\n  d = MHD_start_daemon (MHD_USE_THREAD_PER_CONNECTION | MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_ERROR_LOG,\n                        atoi (argv[1]),\n                        NULL, NULL, &ahc_echo, PAGE, MHD_OPTION_END);\n  if (d == NULL)\n    return 1;\n  fprintf (stderr, \"HTTP server running. Press ENTER to stop the server\\n\");\n  (void) getc (stdin);\n  MHD_stop_daemon (d);\n  return 0;\n}",
      "lines": 25,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/examples/benchmark.c": {
    "completed_callback": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        91,
        1
      ],
      "content": "static void\ncompleted_callback (void *cls,\n\t\t    struct MHD_Connection *connection,\n\t\t    void **con_cls,\n\t\t    enum MHD_RequestTerminationCode toe)\n{\n  struct timeval *tv = *con_cls;\n  struct timeval tve;\n  uint64_t delta;\n  (void)cls;         /* Unused. Silent compiler warning. */\n  (void)connection;  /* Unused. Silent compiler warning. */\n  (void)toe;         /* Unused. Silent compiler warning. */\n\n  if (NULL == tv)\n    return;\n  gettimeofday (&tve, NULL);\n\n  delta = 0;\n  if (tve.tv_usec >= tv->tv_usec)\n    delta += (tve.tv_sec - tv->tv_sec) * 1000000LL\n      + (tve.tv_usec - tv->tv_usec);\n  else\n    delta += (tve.tv_sec - tv->tv_sec) * 1000000LL\n      - tv->tv_usec + tve.tv_usec;\n  if (delta < SMALL)\n    small_deltas[delta]++;\n  else\n    fprintf (stdout, \"D: %llu 1\\n\", (unsigned long long) delta);\n  free (tv);\n}",
      "lines": 30,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "uri_logger_cb": {
      "start_point": [
        94,
        0
      ],
      "end_point": [
        105,
        1
      ],
      "content": "static void *\nuri_logger_cb (void *cls,\n\t       const char *uri)\n{\n  struct timeval *tv = malloc (sizeof (struct timeval));\n  (void)cls; /* Unused. Silent compiler warning. */\n  (void)uri; /* Unused. Silent compiler warning. */\n\n  if (NULL != tv)\n    gettimeofday (tv, NULL);\n  return tv;\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nuri_logger_cb (void *cls,\n\t       const char *uri)",
        "*"
      ]
    },
    "ahc_echo": {
      "start_point": [
        108,
        0
      ],
      "end_point": [
        126,
        1
      ],
      "content": "static int\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data, size_t *upload_data_size, void **ptr)\n{\n  (void)cls;               /* Unused. Silent compiler warning. */\n  (void)url;               /* Unused. Silent compiler warning. */\n  (void)version;           /* Unused. Silent compiler warning. */\n  (void)upload_data;       /* Unused. Silent compiler warning. */\n  (void)upload_data_size;  /* Unused. Silent compiler warning. */\n  (void)ptr;               /* Unused. Silent compiler warning. */\n\n  if (0 != strcmp (method, \"GET\"))\n    return MHD_NO;              /* unexpected method */\n  return MHD_queue_response (connection, MHD_HTTP_OK, response);\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        129,
        0
      ],
      "end_point": [
        170,
        1
      ],
      "content": "int\nmain (int argc, char *const *argv)\n{\n  struct MHD_Daemon *d;\n  unsigned int i;\n\n  if (argc != 2)\n    {\n      printf (\"%s PORT\\n\", argv[0]);\n      return 1;\n    }\n  response = MHD_create_response_from_buffer (strlen (PAGE),\n\t\t\t\t\t      (void *) PAGE,\n\t\t\t\t\t      MHD_RESPMEM_PERSISTENT);\n#if 0\n  (void) MHD_add_response_header (response,\n\t\t\t\t  MHD_HTTP_HEADER_CONNECTION,\n\t\t\t\t  \"close\");\n#endif\n  d = MHD_start_daemon (MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_SUPPRESS_DATE_NO_CLOCK\n#ifdef EPOLL_SUPPORT\n\t\t\t| MHD_USE_EPOLL | MHD_USE_TURBO\n#endif\n\t\t\t,\n                        atoi (argv[1]),\n                        NULL, NULL, &ahc_echo, NULL,\n\t\t\tMHD_OPTION_CONNECTION_TIMEOUT, (unsigned int) 120,\n\t\t\tMHD_OPTION_THREAD_POOL_SIZE, (unsigned int) NUMBER_OF_THREADS,\n\t\t\tMHD_OPTION_URI_LOG_CALLBACK, &uri_logger_cb, NULL,\n\t\t\tMHD_OPTION_NOTIFY_COMPLETED, &completed_callback, NULL,\n\t\t\tMHD_OPTION_CONNECTION_LIMIT, (unsigned int) 1000,\n\t\t\tMHD_OPTION_END);\n  if (d == NULL)\n    return 1;\n  (void) getc (stdin);\n  MHD_stop_daemon (d);\n  MHD_destroy_response (response);\n  for (i=0;i<SMALL;i++)\n    if (0 != small_deltas[i])\n      fprintf (stdout, \"D: %d %u\\n\", i, small_deltas[i]);\n  return 0;\n}",
      "lines": 42,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/examples/benchmark_https.c": {
    "completed_callback": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        91,
        1
      ],
      "content": "static void\ncompleted_callback (void *cls,\n\t\t    struct MHD_Connection *connection,\n\t\t    void **con_cls,\n\t\t    enum MHD_RequestTerminationCode toe)\n{\n  struct timeval *tv = *con_cls;\n  struct timeval tve;\n  uint64_t delta;\n  (void)cls;         /* Unused. Silent compiler warning. */\n  (void)connection;  /* Unused. Silent compiler warning. */\n  (void)toe;         /* Unused. Silent compiler warning. */\n\n  if (NULL == tv)\n    return;\n  gettimeofday (&tve, NULL);\n\n  delta = 0;\n  if (tve.tv_usec >= tv->tv_usec)\n    delta += (tve.tv_sec - tv->tv_sec) * 1000000LL\n      + (tve.tv_usec - tv->tv_usec);\n  else\n    delta += (tve.tv_sec - tv->tv_sec) * 1000000LL\n      - tv->tv_usec + tve.tv_usec;\n  if (delta < SMALL)\n    small_deltas[delta]++;\n  else\n    fprintf (stdout, \"D: %llu 1\\n\", (unsigned long long) delta);\n  free (tv);\n}",
      "lines": 30,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "uri_logger_cb": {
      "start_point": [
        94,
        0
      ],
      "end_point": [
        105,
        1
      ],
      "content": "static void *\nuri_logger_cb (void *cls,\n\t       const char *uri)\n{\n  struct timeval *tv = malloc (sizeof (struct timeval));\n  (void)cls; /* Unused. Silent compiler warning. */\n  (void)uri; /* Unused. Silent compiler warning. */\n\n  if (NULL != tv)\n    gettimeofday (tv, NULL);\n  return tv;\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nuri_logger_cb (void *cls,\n\t       const char *uri)",
        "*"
      ]
    },
    "ahc_echo": {
      "start_point": [
        108,
        0
      ],
      "end_point": [
        126,
        1
      ],
      "content": "static int\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data, size_t *upload_data_size, void **ptr)\n{\n  (void)cls;               /* Unused. Silent compiler warning. */\n  (void)url;               /* Unused. Silent compiler warning. */\n  (void)version;           /* Unused. Silent compiler warning. */\n  (void)upload_data;       /* Unused. Silent compiler warning. */\n  (void)upload_data_size;  /* Unused. Silent compiler warning. */\n  (void)ptr;               /* Unused. Silent compiler warning. */\n\n  if (0 != strcmp (method, \"GET\"))\n    return MHD_NO;              /* unexpected method */\n  return MHD_queue_response (connection, MHD_HTTP_OK, response);\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        180,
        0
      ],
      "end_point": [
        218,
        1
      ],
      "content": "int\nmain (int argc, char *const *argv)\n{\n  struct MHD_Daemon *d;\n  unsigned int i;\n\n  if (argc != 2)\n    {\n      printf (\"%s PORT\\n\", argv[0]);\n      return 1;\n    }\n  response = MHD_create_response_from_buffer (strlen (PAGE),\n\t\t\t\t\t      (void *) PAGE,\n\t\t\t\t\t      MHD_RESPMEM_PERSISTENT);\n  d = MHD_start_daemon (MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_TLS\n#ifdef EPOLL_SUPPORT\n\t\t\t| MHD_USE_EPOLL | MHD_USE_TURBO\n#endif\n\t\t\t,\n                        atoi (argv[1]),\n                        NULL, NULL, &ahc_echo, NULL,\n\t\t\tMHD_OPTION_CONNECTION_TIMEOUT, (unsigned int) 120,\n\t\t\tMHD_OPTION_THREAD_POOL_SIZE, (unsigned int) NUMBER_OF_THREADS,\n\t\t\tMHD_OPTION_URI_LOG_CALLBACK, &uri_logger_cb, NULL,\n\t\t\tMHD_OPTION_NOTIFY_COMPLETED, &completed_callback, NULL,\n\t\t\tMHD_OPTION_CONNECTION_LIMIT, (unsigned int) 1000,\n                        MHD_OPTION_HTTPS_MEM_KEY, srv_signed_key_pem,\n                        MHD_OPTION_HTTPS_MEM_CERT, srv_signed_cert_pem,\n\t\t\tMHD_OPTION_END);\n  if (d == NULL)\n    return 1;\n  (void) getc (stdin);\n  MHD_stop_daemon (d);\n  MHD_destroy_response (response);\n  for (i=0;i<SMALL;i++)\n    if (0 != small_deltas[i])\n      fprintf (stdout, \"D: %d %u\\n\", i, small_deltas[i]);\n  return 0;\n}",
      "lines": 39,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/examples/chunked_example.c": {
    "callback": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "static ssize_t\ncallback (void *cls,\n          uint64_t pos,\n          char *buf,\n          size_t buf_size)\n{\n  size_t size_to_copy;\n  struct ResponseContentCallbackParam * const param =\n      (struct ResponseContentCallbackParam *)cls;\n\n  /* Note: 'pos' will never exceed size of transmitted data. */\n  /* You can use 'pos == param->response_size' in next check. */\n  if (pos >= param->response_size)\n    { /* Whole response was sent. Signal end of response. */\n      return MHD_CONTENT_READER_END_OF_STREAM;\n    }\n\n  /* Pseudo code.        *\n  if (data_not_ready)\n    {\n      // Callback will be called again on next loop.\n      // Consider suspending connection until data will be ready.\n      return 0;\n    }\n   * End of pseudo code. */\n\n  if (buf_size < (param->response_size - pos))\n    size_to_copy = buf_size;\n  else\n    size_to_copy = param->response_size - pos;\n\n  memcpy (buf, param->response_data + pos, size_to_copy);\n\n  /* Pseudo code.        *\n  if (error_preparing_response)\n    {\n      // Close connection with error.\n      return MHD_CONTENT_READER_END_WITH_ERROR;\n    }\n   * End of pseudo code. */\n\n  /* Return amount of data copied to buffer. */\n  return size_to_copy;\n}",
      "lines": 44,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "ssize_t"
      ]
    },
    "free_callback_param": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "static void\nfree_callback_param (void *cls)\n{\n  free(cls);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "ahc_echo": {
      "start_point": [
        92,
        0
      ],
      "end_point": [
        142,
        1
      ],
      "content": "static int\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data,\n          size_t *upload_data_size,\n          void **ptr)\n{\n  static int aptr;\n  struct ResponseContentCallbackParam *callback_param;\n  struct MHD_Response *response;\n  int ret;\n  (void)cls;               /* Unused. Silent compiler warning. */\n  (void)url;               /* Unused. Silent compiler warning. */\n  (void)version;           /* Unused. Silent compiler warning. */\n  (void)upload_data;       /* Unused. Silent compiler warning. */\n  (void)upload_data_size;  /* Unused. Silent compiler warning. */\n\n  if (0 != strcmp (method, \"GET\"))\n    return MHD_NO;              /* unexpected method */\n  if (&aptr != *ptr)\n    {\n      /* do never respond on first call */\n      *ptr = &aptr;\n      return MHD_YES;\n    }\n\n  callback_param = malloc (sizeof(struct ResponseContentCallbackParam));\n  if (NULL == callback_param)\n    return MHD_NO; /* Not enough memory. */\n\n  callback_param->response_data = simple_response_text;\n  callback_param->response_size = (sizeof(simple_response_text)/sizeof(char)) - 1;\n\n  *ptr = NULL;                  /* reset when done */\n  response = MHD_create_response_from_callback (MHD_SIZE_UNKNOWN,\n                                                1024,\n                                                &callback,\n                                                callback_param,\n                                                &free_callback_param);\n  if (NULL == response)\n  {\n    free (callback_param);\n    return MHD_NO;\n  }\n  ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n  MHD_destroy_response (response);\n  return ret;\n}",
      "lines": 51,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        145,
        0
      ],
      "end_point": [
        179,
        1
      ],
      "content": "int\nmain (int argc, char *const *argv)\n{\n  struct MHD_Daemon *d;\n  int port;\n\n  if (argc != 2)\n    {\n      printf (\"%s PORT\\n\", argv[0]);\n      return 1;\n    }\n  port = atoi (argv[1]);\n  if ( (1 > port) ||\n       (port > UINT16_MAX) )\n    {\n      fprintf (stderr,\n               \"Port must be a number between 1 and 65535\\n\");\n      return 1;\n    }\n  d = MHD_start_daemon (/* MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_ERROR_LOG, */\n                        MHD_USE_AUTO | MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_ERROR_LOG,\n                        /* MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_ERROR_LOG | MHD_USE_POLL, */\n\t\t\t/* MHD_USE_THREAD_PER_CONNECTION | MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_ERROR_LOG | MHD_USE_POLL, */\n\t\t\t/* MHD_USE_THREAD_PER_CONNECTION | MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_ERROR_LOG, */\n                        (uint16_t) port,\n                        NULL, NULL,\n                        &ahc_echo, NULL,\n\t\t\tMHD_OPTION_CONNECTION_TIMEOUT, (unsigned int) 120,\n\t\t\tMHD_OPTION_END);\n  if (NULL == d)\n    return 1;\n  (void) getc (stdin);\n  MHD_stop_daemon (d);\n  return 0;\n}",
      "lines": 35,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/examples/demo.c": {
    "mark_as_html": {
      "start_point": [
        202,
        0
      ],
      "end_point": [
        208,
        1
      ],
      "content": "static void\nmark_as_html (struct MHD_Response *response)\n{\n  (void) MHD_add_response_header (response,\n\t\t\t\t  MHD_HTTP_HEADER_CONTENT_TYPE,\n\t\t\t\t  \"text/html\");\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "update_cached_response": {
      "start_point": [
        217,
        0
      ],
      "end_point": [
        225,
        1
      ],
      "content": "static void\nupdate_cached_response (struct MHD_Response *response)\n{\n  (void) pthread_mutex_lock (&mutex);\n  if (NULL != cached_directory_response)\n    MHD_destroy_response (cached_directory_response);\n  cached_directory_response = response;\n  (void) pthread_mutex_unlock (&mutex);\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "list_directory": {
      "start_point": [
        258,
        0
      ],
      "end_point": [
        301,
        1
      ],
      "content": "static int\nlist_directory (struct ResponseDataContext *rdc,\n\t\tconst char *dirname)\n{\n  char fullname[PATH_MAX];\n  struct stat sbuf;\n  DIR *dir;\n  struct dirent *de;\n\n  if (NULL == (dir = opendir (dirname)))\n    return MHD_NO;\n  while (NULL != (de = readdir (dir)))\n    {\n      if ('.' == de->d_name[0])\n\tcontinue;\n      if (sizeof (fullname) <= (unsigned int)\n\t  snprintf (fullname, sizeof (fullname),\n\t\t    \"%s/%s\",\n\t\t    dirname, de->d_name))\n\tcontinue; /* ugh, file too long? how can this be!? */\n      if (0 != stat (fullname, &sbuf))\n\tcontinue; /* ugh, failed to 'stat' */\n      if (! S_ISREG (sbuf.st_mode))\n\tcontinue; /* not a regular file, skip */\n      if (rdc->off + 1024 > rdc->buf_len)\n\t{\n\t  void *r;\n\n\t  if ( (2 * rdc->buf_len + 1024) < rdc->buf_len)\n\t    break; /* more than SIZE_T _index_ size? Too big for us */\n\t  rdc->buf_len = 2 * rdc->buf_len + 1024;\n\t  if (NULL == (r = realloc (rdc->buf, rdc->buf_len)))\n\t    break; /* out of memory */\n\t  rdc->buf = r;\n\t}\n      rdc->off += snprintf (&rdc->buf[rdc->off],\n\t\t\t    rdc->buf_len - rdc->off,\n\t\t\t    \"<li><a href=\\\"/%s\\\">%s</a></li>\\n\",\n\t\t\t    fullname,\n\t\t\t    de->d_name);\n    }\n  (void) closedir (dir);\n  return MHD_YES;\n}",
      "lines": 44,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "update_directory": {
      "start_point": [
        307,
        0
      ],
      "end_point": [
        383,
        1
      ],
      "content": "static void\nupdate_directory ()\n{\n  static size_t initial_allocation = 32 * 1024; /* initial size for response buffer */\n  struct MHD_Response *response;\n  struct ResponseDataContext rdc;\n  unsigned int language_idx;\n  unsigned int category_idx;\n  const struct Language *language;\n  const char *category;\n  char dir_name[128];\n  struct stat sbuf;\n\n  rdc.buf_len = initial_allocation;\n  if (NULL == (rdc.buf = malloc (rdc.buf_len)))\n    {\n      update_cached_response (NULL);\n      return;\n    }\n  rdc.off = snprintf (rdc.buf, rdc.buf_len,\n\t\t      \"%s\",\n\t\t      INDEX_PAGE_HEADER);\n  for (language_idx = 0; NULL != languages[language_idx].dirname; language_idx++)\n    {\n      language = &languages[language_idx];\n\n      if (0 != stat (language->dirname, &sbuf))\n\tcontinue; /* empty */\n      /* we ensured always +1k room, filenames are ~256 bytes,\n\t so there is always still enough space for the header\n\t without need for an additional reallocation check. */\n      rdc.off += snprintf (&rdc.buf[rdc.off], rdc.buf_len - rdc.off,\n\t\t\t   \"<h2>%s</h2>\\n\",\n\t\t\t   language->longname);\n      for (category_idx = 0; NULL != categories[category_idx]; category_idx++)\n\t{\n\t  category = categories[category_idx];\n\t  snprintf (dir_name, sizeof (dir_name),\n\t\t    \"%s/%s\",\n\t\t    language->dirname,\n\t\t    category);\n\t  if (0 != stat (dir_name, &sbuf))\n\t    continue; /* empty */\n\n\t  /* we ensured always +1k room, filenames are ~256 bytes,\n\t     so there is always still enough space for the header\n\t     without need for an additional reallocation check. */\n\t  rdc.off += snprintf (&rdc.buf[rdc.off], rdc.buf_len - rdc.off,\n\t\t\t       \"<h3>%s</h3>\\n\",\n\t\t\t       category);\n\n\t  if (MHD_NO == list_directory (&rdc, dir_name))\n\t    {\n\t      free (rdc.buf);\n\t      update_cached_response (NULL);\n\t      return;\n\t    }\n\t}\n    }\n  /* we ensured always +1k room, filenames are ~256 bytes,\n     so there is always still enough space for the footer\n     without need for a final reallocation check. */\n  rdc.off += snprintf (&rdc.buf[rdc.off], rdc.buf_len - rdc.off,\n\t\t       \"%s\",\n\t\t       INDEX_PAGE_FOOTER);\n  initial_allocation = rdc.buf_len; /* remember for next time */\n  response = MHD_create_response_from_buffer (rdc.off,\n\t\t\t\t\t      rdc.buf,\n\t\t\t\t\t      MHD_RESPMEM_MUST_FREE);\n  mark_as_html (response);\n#if FORCE_CLOSE\n  (void) MHD_add_response_header (response,\n\t\t\t\t  MHD_HTTP_HEADER_CONNECTION,\n\t\t\t\t  \"close\");\n#endif\n  update_cached_response (response);\n}",
      "lines": 77,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "do_append": {
      "start_point": [
        437,
        0
      ],
      "end_point": [
        459,
        1
      ],
      "content": "static int\ndo_append (char **ret,\n\t   const char *data,\n\t   size_t size)\n{\n  char *buf;\n  size_t old_len;\n\n  if (NULL == *ret)\n    old_len = 0;\n  else\n    old_len = strlen (*ret);\n  buf = malloc (old_len + size + 1);\n  if (NULL == buf)\n    return MHD_NO;\n  memcpy (buf, *ret, old_len);\n  if (NULL != *ret)\n    free (*ret);\n  memcpy (&buf[old_len], data, size);\n  buf[old_len + size] = '\\0';\n  *ret = buf;\n  return MHD_YES;\n}",
      "lines": 23,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "process_upload_data": {
      "start_point": [
        481,
        0
      ],
      "end_point": [
        597,
        1
      ],
      "content": "static int\nprocess_upload_data (void *cls,\n\t\t     enum MHD_ValueKind kind,\n\t\t     const char *key,\n\t\t     const char *filename,\n\t\t     const char *content_type,\n\t\t     const char *transfer_encoding,\n\t\t     const char *data,\n\t\t     uint64_t off,\n\t\t     size_t size)\n{\n  struct UploadContext *uc = cls;\n  int i;\n  (void)kind;              /* Unused. Silent compiler warning. */\n  (void)content_type;      /* Unused. Silent compiler warning. */\n  (void)transfer_encoding; /* Unused. Silent compiler warning. */\n  (void)off;               /* Unused. Silent compiler warning. */\n\n  if (0 == strcmp (key, \"category\"))\n    return do_append (&uc->category, data, size);\n  if (0 == strcmp (key, \"language\"))\n    return do_append (&uc->language, data, size);\n  if (0 != strcmp (key, \"upload\"))\n    {\n      fprintf (stderr,\n\t       \"Ignoring unexpected form value `%s'\\n\",\n\t       key);\n      return MHD_YES; /* ignore */\n    }\n  if (NULL == filename)\n    {\n      fprintf (stderr, \"No filename, aborting upload\\n\");\n      return MHD_NO; /* no filename, error */\n    }\n  if ( (NULL == uc->category) ||\n       (NULL == uc->language) )\n    {\n      fprintf (stderr,\n\t       \"Missing form data for upload `%s'\\n\",\n\t       filename);\n      uc->response = request_refused_response;\n      return MHD_NO;\n    }\n  if (-1 == uc->fd)\n    {\n      char fn[PATH_MAX];\n\n      if ( (NULL != strstr (filename, \"..\")) ||\n\t   (NULL != strchr (filename, '/')) ||\n\t   (NULL != strchr (filename, '\\\\')) )\n\t{\n\t  uc->response = request_refused_response;\n\t  return MHD_NO;\n\t}\n      /* create directories -- if they don't exist already */\n#ifdef WINDOWS\n      (void) mkdir (uc->language);\n#else\n      (void) mkdir (uc->language, S_IRWXU);\n#endif\n      snprintf (fn, sizeof (fn),\n\t\t\"%s/%s\",\n\t\tuc->language,\n\t\tuc->category);\n#ifdef WINDOWS\n      (void) mkdir (fn);\n#else\n      (void) mkdir (fn, S_IRWXU);\n#endif\n      /* open file */\n      snprintf (fn, sizeof (fn),\n\t\t\"%s/%s/%s\",\n\t\tuc->language,\n\t\tuc->category,\n\t\tfilename);\n      for (i=strlen (fn)-1;i>=0;i--)\n\tif (! isprint ((unsigned char) fn[i]))\n\t  fn[i] = '_';\n      uc->fd = open (fn,\n\t\t     O_CREAT | O_EXCL\n#if O_LARGEFILE\n\t\t     | O_LARGEFILE\n#endif\n\t\t     | O_WRONLY,\n\t\t     S_IRUSR | S_IWUSR);\n      if (-1 == uc->fd)\n\t{\n\t  fprintf (stderr,\n\t\t   \"Error opening file `%s' for upload: %s\\n\",\n\t\t   fn,\n\t\t   strerror (errno));\n\t  uc->response = request_refused_response;\n\t  return MHD_NO;\n\t}\n      uc->filename = strdup (fn);\n    }\n  if ( (0 != size) &&\n       (size != (size_t) write (uc->fd, data, size)) )\n    {\n      /* write failed; likely: disk full */\n      fprintf (stderr,\n\t       \"Error writing to file `%s': %s\\n\",\n\t       uc->filename,\n\t       strerror (errno));\n      uc->response = internal_error_response;\n      (void) close (uc->fd);\n      uc->fd = -1;\n      if (NULL != uc->filename)\n\t{\n\t  unlink (uc->filename);\n\t  free (uc->filename);\n\t  uc->filename = NULL;\n\t}\n      return MHD_NO;\n    }\n  return MHD_YES;\n}",
      "lines": 117,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "response_completed_callback": {
      "start_point": [
        611,
        0
      ],
      "end_point": [
        643,
        1
      ],
      "content": "static void\nresponse_completed_callback (void *cls,\n\t\t\t     struct MHD_Connection *connection,\n\t\t\t     void **con_cls,\n\t\t\t     enum MHD_RequestTerminationCode toe)\n{\n  struct UploadContext *uc = *con_cls;\n  (void)cls;         /* Unused. Silent compiler warning. */\n  (void)connection;  /* Unused. Silent compiler warning. */\n  (void)toe;         /* Unused. Silent compiler warning. */\n\n  if (NULL == uc)\n    return; /* this request wasn't an upload request */\n  if (NULL != uc->pp)\n    {\n      MHD_destroy_post_processor (uc->pp);\n      uc->pp = NULL;\n    }\n  if (-1 != uc->fd)\n  {\n    (void) close (uc->fd);\n    if (NULL != uc->filename)\n      {\n\tfprintf (stderr,\n\t\t \"Upload of file `%s' failed (incomplete or aborted), removing file.\\n\",\n\t\t uc->filename);\n\t(void) unlink (uc->filename);\n      }\n  }\n  if (NULL != uc->filename)\n    free (uc->filename);\n  free (uc);\n}",
      "lines": 33,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "return_directory_response": {
      "start_point": [
        652,
        0
      ],
      "end_point": [
        668,
        1
      ],
      "content": "static int\nreturn_directory_response (struct MHD_Connection *connection)\n{\n  int ret;\n\n  (void) pthread_mutex_lock (&mutex);\n  if (NULL == cached_directory_response)\n    ret = MHD_queue_response (connection,\n\t\t\t      MHD_HTTP_INTERNAL_SERVER_ERROR,\n\t\t\t      internal_error_response);\n  else\n    ret = MHD_queue_response (connection,\n\t\t\t      MHD_HTTP_OK,\n\t\t\t      cached_directory_response);\n  (void) pthread_mutex_unlock (&mutex);\n  return ret;\n}",
      "lines": 17,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "generate_page": {
      "start_point": [
        684,
        0
      ],
      "end_point": [
        822,
        1
      ],
      "content": "static int\ngenerate_page (void *cls,\n\t       struct MHD_Connection *connection,\n\t       const char *url,\n\t       const char *method,\n\t       const char *version,\n\t       const char *upload_data,\n\t       size_t *upload_data_size, void **ptr)\n{\n  struct MHD_Response *response;\n  int ret;\n  int fd;\n  struct stat buf;\n  (void)cls;               /* Unused. Silent compiler warning. */\n  (void)version;           /* Unused. Silent compiler warning. */\n\n  if (0 != strcmp (url, \"/\"))\n    {\n      /* should be file download */\n#ifdef MHD_HAVE_LIBMAGIC\n      char file_data[MAGIC_HEADER_SIZE];\n      ssize_t got;\n#endif /* MHD_HAVE_LIBMAGIC */\n      const char *mime;\n\n      if ( (0 != strcmp (method, MHD_HTTP_METHOD_GET)) &&\n           (0 != strcmp (method, MHD_HTTP_METHOD_HEAD)) )\n        return MHD_NO;  /* unexpected method (we're not polite...) */\n      fd = -1;\n      if ( (NULL == strstr (&url[1], \"..\")) &&\n\t   ('/' != url[1]) )\n        {\n          fd = open (&url[1], O_RDONLY);\n          if ( (-1 != fd) &&\n               ( (0 != fstat (fd, &buf)) ||\n                 (! S_ISREG (buf.st_mode)) ) )\n            {\n              (void) close (fd);\n              fd = -1;\n            }\n        }\n      if (-1 == fd)\n\treturn MHD_queue_response (connection,\n\t\t\t\t   MHD_HTTP_NOT_FOUND,\n\t\t\t\t   file_not_found_response);\n#ifdef MHD_HAVE_LIBMAGIC\n      /* read beginning of the file to determine mime type  */\n      got = read (fd, file_data, sizeof (file_data));\n      (void) lseek (fd, 0, SEEK_SET);\n      if (-1 != got)\n\tmime = magic_buffer (magic, file_data, got);\n      else\n#endif /* MHD_HAVE_LIBMAGIC */\n\tmime = NULL;\n\n      if (NULL == (response = MHD_create_response_from_fd (buf.st_size,\n\t\t\t\t\t\t\t   fd)))\n\t{\n\t  /* internal error (i.e. out of memory) */\n\t  (void) close (fd);\n\t  return MHD_NO;\n\t}\n\n      /* add mime type if we had one */\n      if (NULL != mime)\n\t(void) MHD_add_response_header (response,\n\t\t\t\t\tMHD_HTTP_HEADER_CONTENT_TYPE,\n\t\t\t\t\tmime);\n      ret = MHD_queue_response (connection,\n\t\t\t\tMHD_HTTP_OK,\n\t\t\t\tresponse);\n      MHD_destroy_response (response);\n      return ret;\n    }\n\n  if (0 == strcmp (method, MHD_HTTP_METHOD_POST))\n    {\n      /* upload! */\n      struct UploadContext *uc = *ptr;\n\n      if (NULL == uc)\n\t{\n\t  if (NULL == (uc = malloc (sizeof (struct UploadContext))))\n\t    return MHD_NO; /* out of memory, close connection */\n\t  memset (uc, 0, sizeof (struct UploadContext));\n          uc->fd = -1;\n\t  uc->connection = connection;\n\t  uc->pp = MHD_create_post_processor (connection,\n\t\t\t\t\t      64 * 1024 /* buffer size */,\n\t\t\t\t\t      &process_upload_data, uc);\n\t  if (NULL == uc->pp)\n\t    {\n\t      /* out of memory, close connection */\n\t      free (uc);\n\t      return MHD_NO;\n\t    }\n\t  *ptr = uc;\n\t  return MHD_YES;\n\t}\n      if (0 != *upload_data_size)\n\t{\n\t  if (NULL == uc->response)\n\t    (void) MHD_post_process (uc->pp,\n\t\t\t\t     upload_data,\n\t\t\t\t     *upload_data_size);\n\t  *upload_data_size = 0;\n\t  return MHD_YES;\n\t}\n      /* end of upload, finish it! */\n      MHD_destroy_post_processor (uc->pp);\n      uc->pp = NULL;\n      if (-1 != uc->fd)\n\t{\n\t  close (uc->fd);\n\t  uc->fd = -1;\n\t}\n      if (NULL != uc->response)\n\t{\n\t  return MHD_queue_response (connection,\n\t\t\t\t     MHD_HTTP_FORBIDDEN,\n\t\t\t\t     uc->response);\n\t}\n      else\n\t{\n\t  update_directory ();\n\t  return return_directory_response (connection);\n\t}\n    }\n  if ( (0 == strcmp (method, MHD_HTTP_METHOD_GET)) ||\n       (0 == strcmp (method, MHD_HTTP_METHOD_HEAD)) )\n  {\n    return return_directory_response (connection);\n  }\n\n  /* unexpected request, refuse */\n  return MHD_queue_response (connection,\n\t\t\t     MHD_HTTP_FORBIDDEN,\n\t\t\t     request_refused_response);\n}",
      "lines": 139,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "catcher": {
      "start_point": [
        831,
        0
      ],
      "end_point": [
        836,
        1
      ],
      "content": "static void\ncatcher (int sig)\n{\n  (void)sig;\t/* Unused. Silent compiler warning. */\n  /* do nothing */\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "ignore_sigpipe": {
      "start_point": [
        842,
        0
      ],
      "end_point": [
        858,
        1
      ],
      "content": "static void\nignore_sigpipe ()\n{\n  struct sigaction oldsig;\n  struct sigaction sig;\n\n  sig.sa_handler = &catcher;\n  sigemptyset (&sig.sa_mask);\n#ifdef SA_INTERRUPT\n  sig.sa_flags = SA_INTERRUPT;  /* SunOS */\n#else\n  sig.sa_flags = SA_RESTART;\n#endif\n  if (0 != sigaction (SIGPIPE, &sig, &oldsig))\n    fprintf (stderr,\n             \"Failed to install SIGPIPE handler: %s\\n\", strerror (errno));\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        871,
        0
      ],
      "end_point": [
        933,
        1
      ],
      "content": "int\nmain (int argc, char *const *argv)\n{\n  struct MHD_Daemon *d;\n  unsigned int port;\n\n  if ( (argc != 2) ||\n       (1 != sscanf (argv[1], \"%u\", &port)) ||\n       (UINT16_MAX < port) )\n    {\n      fprintf (stderr,\n\t       \"%s PORT\\n\", argv[0]);\n      return 1;\n    }\n#ifndef MINGW\n  ignore_sigpipe ();\n#endif\n#ifdef MHD_HAVE_LIBMAGIC\n  magic = magic_open (MAGIC_MIME_TYPE);\n  (void) magic_load (magic, NULL);\n#endif /* MHD_HAVE_LIBMAGIC */\n\n  (void) pthread_mutex_init (&mutex, NULL);\n  file_not_found_response = MHD_create_response_from_buffer (strlen (FILE_NOT_FOUND_PAGE),\n\t\t\t\t\t\t\t     (void *) FILE_NOT_FOUND_PAGE,\n\t\t\t\t\t\t\t     MHD_RESPMEM_PERSISTENT);\n  mark_as_html (file_not_found_response);\n  request_refused_response = MHD_create_response_from_buffer (strlen (REQUEST_REFUSED_PAGE),\n\t\t\t\t\t\t\t     (void *) REQUEST_REFUSED_PAGE,\n\t\t\t\t\t\t\t     MHD_RESPMEM_PERSISTENT);\n  mark_as_html (request_refused_response);\n  internal_error_response = MHD_create_response_from_buffer (strlen (INTERNAL_ERROR_PAGE),\n\t\t\t\t\t\t\t     (void *) INTERNAL_ERROR_PAGE,\n\t\t\t\t\t\t\t     MHD_RESPMEM_PERSISTENT);\n  mark_as_html (internal_error_response);\n  update_directory ();\n  d = MHD_start_daemon (MHD_USE_AUTO | MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_ERROR_LOG,\n                        port,\n                        NULL, NULL,\n\t\t\t&generate_page, NULL,\n\t\t\tMHD_OPTION_CONNECTION_MEMORY_LIMIT, (size_t) (256 * 1024),\n#if PRODUCTION\n\t\t\tMHD_OPTION_PER_IP_CONNECTION_LIMIT, (unsigned int) (64),\n#endif\n\t\t\tMHD_OPTION_CONNECTION_TIMEOUT, (unsigned int) (120 /* seconds */),\n\t\t\tMHD_OPTION_THREAD_POOL_SIZE, (unsigned int) NUMBER_OF_THREADS,\n\t\t\tMHD_OPTION_NOTIFY_COMPLETED, &response_completed_callback, NULL,\n\t\t\tMHD_OPTION_END);\n  if (NULL == d)\n    return 1;\n  fprintf (stderr, \"HTTP server running. Press ENTER to stop the server\\n\");\n  (void) getc (stdin);\n  MHD_stop_daemon (d);\n  MHD_destroy_response (file_not_found_response);\n  MHD_destroy_response (request_refused_response);\n  MHD_destroy_response (internal_error_response);\n  update_cached_response (NULL);\n  (void) pthread_mutex_destroy (&mutex);\n#ifdef MHD_HAVE_LIBMAGIC\n  magic_close (magic);\n#endif /* MHD_HAVE_LIBMAGIC */\n  return 0;\n}",
      "lines": 63,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/examples/demo_https.c": {
    "mark_as_html": {
      "start_point": [
        203,
        0
      ],
      "end_point": [
        209,
        1
      ],
      "content": "static void\nmark_as_html (struct MHD_Response *response)\n{\n  (void) MHD_add_response_header (response,\n\t\t\t\t  MHD_HTTP_HEADER_CONTENT_TYPE,\n\t\t\t\t  \"text/html\");\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "update_cached_response": {
      "start_point": [
        218,
        0
      ],
      "end_point": [
        226,
        1
      ],
      "content": "static void\nupdate_cached_response (struct MHD_Response *response)\n{\n  (void) pthread_mutex_lock (&mutex);\n  if (NULL != cached_directory_response)\n    MHD_destroy_response (cached_directory_response);\n  cached_directory_response = response;\n  (void) pthread_mutex_unlock (&mutex);\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "list_directory": {
      "start_point": [
        259,
        0
      ],
      "end_point": [
        302,
        1
      ],
      "content": "static int\nlist_directory (struct ResponseDataContext *rdc,\n\t\tconst char *dirname)\n{\n  char fullname[PATH_MAX];\n  struct stat sbuf;\n  DIR *dir;\n  struct dirent *de;\n\n  if (NULL == (dir = opendir (dirname)))\n    return MHD_NO;\n  while (NULL != (de = readdir (dir)))\n    {\n      if ('.' == de->d_name[0])\n\tcontinue;\n      if (sizeof (fullname) <= (size_t)\n\t  snprintf (fullname, sizeof (fullname),\n\t\t    \"%s/%s\",\n\t\t    dirname, de->d_name))\n\tcontinue; /* ugh, file too long? how can this be!? */\n      if (0 != stat (fullname, &sbuf))\n\tcontinue; /* ugh, failed to 'stat' */\n      if (! S_ISREG (sbuf.st_mode))\n\tcontinue; /* not a regular file, skip */\n      if (rdc->off + 1024 > rdc->buf_len)\n\t{\n\t  void *r;\n\n\t  if ( (2 * rdc->buf_len + 1024) < rdc->buf_len)\n\t    break; /* more than SIZE_T _index_ size? Too big for us */\n\t  rdc->buf_len = 2 * rdc->buf_len + 1024;\n\t  if (NULL == (r = realloc (rdc->buf, rdc->buf_len)))\n\t    break; /* out of memory */\n\t  rdc->buf = r;\n\t}\n      rdc->off += snprintf (&rdc->buf[rdc->off],\n\t\t\t    rdc->buf_len - rdc->off,\n\t\t\t    \"<li><a href=\\\"/%s\\\">%s</a></li>\\n\",\n\t\t\t    fullname,\n\t\t\t    de->d_name);\n    }\n  (void) closedir (dir);\n  return MHD_YES;\n}",
      "lines": 44,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "update_directory": {
      "start_point": [
        308,
        0
      ],
      "end_point": [
        384,
        1
      ],
      "content": "static void\nupdate_directory ()\n{\n  static size_t initial_allocation = 32 * 1024; /* initial size for response buffer */\n  struct MHD_Response *response;\n  struct ResponseDataContext rdc;\n  unsigned int language_idx;\n  unsigned int category_idx;\n  const struct Language *language;\n  const char *category;\n  char dir_name[128];\n  struct stat sbuf;\n\n  rdc.buf_len = initial_allocation;\n  if (NULL == (rdc.buf = malloc (rdc.buf_len)))\n    {\n      update_cached_response (NULL);\n      return;\n    }\n  rdc.off = snprintf (rdc.buf, rdc.buf_len,\n\t\t      \"%s\",\n\t\t      INDEX_PAGE_HEADER);\n  for (language_idx = 0; NULL != languages[language_idx].dirname; language_idx++)\n    {\n      language = &languages[language_idx];\n\n      if (0 != stat (language->dirname, &sbuf))\n\tcontinue; /* empty */\n      /* we ensured always +1k room, filenames are ~256 bytes,\n\t so there is always still enough space for the header\n\t without need for an additional reallocation check. */\n      rdc.off += snprintf (&rdc.buf[rdc.off], rdc.buf_len - rdc.off,\n\t\t\t   \"<h2>%s</h2>\\n\",\n\t\t\t   language->longname);\n      for (category_idx = 0; NULL != categories[category_idx]; category_idx++)\n\t{\n\t  category = categories[category_idx];\n\t  snprintf (dir_name, sizeof (dir_name),\n\t\t    \"%s/%s\",\n\t\t    language->dirname,\n\t\t    category);\n\t  if (0 != stat (dir_name, &sbuf))\n\t    continue; /* empty */\n\n\t  /* we ensured always +1k room, filenames are ~256 bytes,\n\t     so there is always still enough space for the header\n\t     without need for an additional reallocation check. */\n\t  rdc.off += snprintf (&rdc.buf[rdc.off], rdc.buf_len - rdc.off,\n\t\t\t       \"<h3>%s</h3>\\n\",\n\t\t\t       category);\n\n\t  if (MHD_NO == list_directory (&rdc, dir_name))\n\t    {\n\t      free (rdc.buf);\n\t      update_cached_response (NULL);\n\t      return;\n\t    }\n\t}\n    }\n  /* we ensured always +1k room, filenames are ~256 bytes,\n     so there is always still enough space for the footer\n     without need for a final reallocation check. */\n  rdc.off += snprintf (&rdc.buf[rdc.off], rdc.buf_len - rdc.off,\n\t\t       \"%s\",\n\t\t       INDEX_PAGE_FOOTER);\n  initial_allocation = rdc.buf_len; /* remember for next time */\n  response = MHD_create_response_from_buffer (rdc.off,\n\t\t\t\t\t      rdc.buf,\n\t\t\t\t\t      MHD_RESPMEM_MUST_FREE);\n  mark_as_html (response);\n#if FORCE_CLOSE\n  (void) MHD_add_response_header (response,\n\t\t\t\t  MHD_HTTP_HEADER_CONNECTION,\n\t\t\t\t  \"close\");\n#endif\n  update_cached_response (response);\n}",
      "lines": 77,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "do_append": {
      "start_point": [
        438,
        0
      ],
      "end_point": [
        460,
        1
      ],
      "content": "static int\ndo_append (char **ret,\n\t   const char *data,\n\t   size_t size)\n{\n  char *buf;\n  size_t old_len;\n\n  if (NULL == *ret)\n    old_len = 0;\n  else\n    old_len = strlen (*ret);\n  buf = malloc (old_len + size + 1);\n  if (NULL == buf)\n    return MHD_NO;\n  memcpy (buf, *ret, old_len);\n  if (NULL != *ret)\n    free (*ret);\n  memcpy (&buf[old_len], data, size);\n  buf[old_len + size] = '\\0';\n  *ret = buf;\n  return MHD_YES;\n}",
      "lines": 23,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "process_upload_data": {
      "start_point": [
        482,
        0
      ],
      "end_point": [
        598,
        1
      ],
      "content": "static int\nprocess_upload_data (void *cls,\n\t\t     enum MHD_ValueKind kind,\n\t\t     const char *key,\n\t\t     const char *filename,\n\t\t     const char *content_type,\n\t\t     const char *transfer_encoding,\n\t\t     const char *data,\n\t\t     uint64_t off,\n\t\t     size_t size)\n{\n  struct UploadContext *uc = cls;\n  int i;\n  (void)kind;              /* Unused. Silent compiler warning. */\n  (void)content_type;      /* Unused. Silent compiler warning. */\n  (void)transfer_encoding; /* Unused. Silent compiler warning. */\n  (void)off;               /* Unused. Silent compiler warning. */\n\n  if (0 == strcmp (key, \"category\"))\n    return do_append (&uc->category, data, size);\n  if (0 == strcmp (key, \"language\"))\n    return do_append (&uc->language, data, size);\n  if (0 != strcmp (key, \"upload\"))\n    {\n      fprintf (stderr,\n\t       \"Ignoring unexpected form value `%s'\\n\",\n\t       key);\n      return MHD_YES; /* ignore */\n    }\n  if (NULL == filename)\n    {\n      fprintf (stderr, \"No filename, aborting upload\\n\");\n      return MHD_NO; /* no filename, error */\n    }\n  if ( (NULL == uc->category) ||\n       (NULL == uc->language) )\n    {\n      fprintf (stderr,\n\t       \"Missing form data for upload `%s'\\n\",\n\t       filename);\n      uc->response = request_refused_response;\n      return MHD_NO;\n    }\n  if (-1 == uc->fd)\n    {\n      char fn[PATH_MAX];\n\n      if ( (NULL != strstr (filename, \"..\")) ||\n\t   (NULL != strchr (filename, '/')) ||\n\t   (NULL != strchr (filename, '\\\\')) )\n\t{\n\t  uc->response = request_refused_response;\n\t  return MHD_NO;\n\t}\n      /* create directories -- if they don't exist already */\n#ifdef WINDOWS\n      (void) mkdir (uc->language);\n#else\n      (void) mkdir (uc->language, S_IRWXU);\n#endif\n      snprintf (fn, sizeof (fn),\n\t\t\"%s/%s\",\n\t\tuc->language,\n\t\tuc->category);\n#ifdef WINDOWS\n      (void) mkdir (fn);\n#else\n      (void) mkdir (fn, S_IRWXU);\n#endif\n      /* open file */\n      snprintf (fn, sizeof (fn),\n\t\t\"%s/%s/%s\",\n\t\tuc->language,\n\t\tuc->category,\n\t\tfilename);\n      for (i=strlen (fn)-1;i>=0;i--)\n\tif (! isprint ((int) fn[i]))\n\t  fn[i] = '_';\n      uc->fd = open (fn,\n\t\t     O_CREAT | O_EXCL\n#if O_LARGEFILE\n\t\t     | O_LARGEFILE\n#endif\n\t\t     | O_WRONLY,\n\t\t     S_IRUSR | S_IWUSR);\n      if (-1 == uc->fd)\n\t{\n\t  fprintf (stderr,\n\t\t   \"Error opening file `%s' for upload: %s\\n\",\n\t\t   fn,\n\t\t   strerror (errno));\n\t  uc->response = request_refused_response;\n\t  return MHD_NO;\n\t}\n      uc->filename = strdup (fn);\n    }\n  if ( (0 != size) &&\n       (size != (size_t) write (uc->fd, data, size)) )\n    {\n      /* write failed; likely: disk full */\n      fprintf (stderr,\n\t       \"Error writing to file `%s': %s\\n\",\n\t       uc->filename,\n\t       strerror (errno));\n      uc->response = internal_error_response;\n      close (uc->fd);\n      uc->fd = -1;\n      if (NULL != uc->filename)\n\t{\n\t  unlink (uc->filename);\n\t  free (uc->filename);\n\t  uc->filename = NULL;\n\t}\n      return MHD_NO;\n    }\n  return MHD_YES;\n}",
      "lines": 117,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "response_completed_callback": {
      "start_point": [
        612,
        0
      ],
      "end_point": [
        644,
        1
      ],
      "content": "static void\nresponse_completed_callback (void *cls,\n\t\t\t     struct MHD_Connection *connection,\n\t\t\t     void **con_cls,\n\t\t\t     enum MHD_RequestTerminationCode toe)\n{\n  struct UploadContext *uc = *con_cls;\n  (void)cls;         /* Unused. Silent compiler warning. */\n  (void)connection;  /* Unused. Silent compiler warning. */\n  (void)toe;         /* Unused. Silent compiler warning. */\n\n  if (NULL == uc)\n    return; /* this request wasn't an upload request */\n  if (NULL != uc->pp)\n    {\n      MHD_destroy_post_processor (uc->pp);\n      uc->pp = NULL;\n    }\n  if (-1 != uc->fd)\n  {\n    (void) close (uc->fd);\n    if (NULL != uc->filename)\n      {\n\tfprintf (stderr,\n\t\t \"Upload of file `%s' failed (incomplete or aborted), removing file.\\n\",\n\t\t uc->filename);\n\t(void) unlink (uc->filename);\n      }\n  }\n  if (NULL != uc->filename)\n    free (uc->filename);\n  free (uc);\n}",
      "lines": 33,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "return_directory_response": {
      "start_point": [
        653,
        0
      ],
      "end_point": [
        669,
        1
      ],
      "content": "static int\nreturn_directory_response (struct MHD_Connection *connection)\n{\n  int ret;\n\n  (void) pthread_mutex_lock (&mutex);\n  if (NULL == cached_directory_response)\n    ret = MHD_queue_response (connection,\n\t\t\t      MHD_HTTP_INTERNAL_SERVER_ERROR,\n\t\t\t      internal_error_response);\n  else\n    ret = MHD_queue_response (connection,\n\t\t\t      MHD_HTTP_OK,\n\t\t\t      cached_directory_response);\n  (void) pthread_mutex_unlock (&mutex);\n  return ret;\n}",
      "lines": 17,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "generate_page": {
      "start_point": [
        685,
        0
      ],
      "end_point": [
        821,
        1
      ],
      "content": "static int\ngenerate_page (void *cls,\n\t       struct MHD_Connection *connection,\n\t       const char *url,\n\t       const char *method,\n\t       const char *version,\n\t       const char *upload_data,\n\t       size_t *upload_data_size, void **ptr)\n{\n  struct MHD_Response *response;\n  int ret;\n  int fd;\n  struct stat buf;\n  (void)cls;               /* Unused. Silent compiler warning. */\n  (void)version;           /* Unused. Silent compiler warning. */\n\n  if (0 != strcmp (url, \"/\"))\n    {\n      /* should be file download */\n#ifdef MHD_HAVE_LIBMAGIC\n      char file_data[MAGIC_HEADER_SIZE];\n      ssize_t got;\n#endif /* MHD_HAVE_LIBMAGIC */\n      const char *mime;\n\n      if (0 != strcmp (method, MHD_HTTP_METHOD_GET))\n\treturn MHD_NO;  /* unexpected method (we're not polite...) */\n      fd = -1;\n      if ( (NULL == strstr (&url[1], \"..\")) &&\n\t   ('/' != url[1]) )\n        {\n          fd = open (&url[1], O_RDONLY);\n          if ( (-1 != fd) &&\n               ( (0 != fstat (fd, &buf)) ||\n                 (! S_ISREG (buf.st_mode)) ) )\n            {\n              (void) close (fd);\n              fd = -1;\n            }\n        }\n      if (-1 == fd)\n\treturn MHD_queue_response (connection,\n\t\t\t\t   MHD_HTTP_NOT_FOUND,\n\t\t\t\t   file_not_found_response);\n#ifdef MHD_HAVE_LIBMAGIC\n      /* read beginning of the file to determine mime type  */\n      got = read (fd, file_data, sizeof (file_data));\n      (void) lseek (fd, 0, SEEK_SET);\n      if (-1 != got)\n\tmime = magic_buffer (magic, file_data, got);\n      else\n#endif /* MHD_HAVE_LIBMAGIC */\n\tmime = NULL;\n\n      if (NULL == (response = MHD_create_response_from_fd (buf.st_size,\n\t\t\t\t\t\t\t   fd)))\n\t{\n\t  /* internal error (i.e. out of memory) */\n\t  (void) close (fd);\n\t  return MHD_NO;\n\t}\n\n      /* add mime type if we had one */\n      if (NULL != mime)\n\t(void) MHD_add_response_header (response,\n\t\t\t\t\tMHD_HTTP_HEADER_CONTENT_TYPE,\n\t\t\t\t\tmime);\n      ret = MHD_queue_response (connection,\n\t\t\t\tMHD_HTTP_OK,\n\t\t\t\tresponse);\n      MHD_destroy_response (response);\n      return ret;\n    }\n\n  if (0 == strcmp (method, MHD_HTTP_METHOD_POST))\n    {\n      /* upload! */\n      struct UploadContext *uc = *ptr;\n\n      if (NULL == uc)\n\t{\n\t  if (NULL == (uc = malloc (sizeof (struct UploadContext))))\n\t    return MHD_NO; /* out of memory, close connection */\n\t  memset (uc, 0, sizeof (struct UploadContext));\n          uc->fd = -1;\n\t  uc->connection = connection;\n\t  uc->pp = MHD_create_post_processor (connection,\n\t\t\t\t\t      64 * 1024 /* buffer size */,\n\t\t\t\t\t      &process_upload_data, uc);\n\t  if (NULL == uc->pp)\n\t    {\n\t      /* out of memory, close connection */\n\t      free (uc);\n\t      return MHD_NO;\n\t    }\n\t  *ptr = uc;\n\t  return MHD_YES;\n\t}\n      if (0 != *upload_data_size)\n\t{\n\t  if (NULL == uc->response)\n\t    (void) MHD_post_process (uc->pp,\n\t\t\t\t     upload_data,\n\t\t\t\t     *upload_data_size);\n\t  *upload_data_size = 0;\n\t  return MHD_YES;\n\t}\n      /* end of upload, finish it! */\n      MHD_destroy_post_processor (uc->pp);\n      uc->pp = NULL;\n      if (-1 != uc->fd)\n\t{\n\t  close (uc->fd);\n\t  uc->fd = -1;\n\t}\n      if (NULL != uc->response)\n\t{\n\t  return MHD_queue_response (connection,\n\t\t\t\t     MHD_HTTP_FORBIDDEN,\n\t\t\t\t     uc->response);\n\t}\n      else\n\t{\n\t  update_directory ();\n\t  return return_directory_response (connection);\n\t}\n    }\n  if (0 == strcmp (method, MHD_HTTP_METHOD_GET))\n  {\n    return return_directory_response (connection);\n  }\n\n  /* unexpected request, refuse */\n  return MHD_queue_response (connection,\n\t\t\t     MHD_HTTP_FORBIDDEN,\n\t\t\t     request_refused_response);\n}",
      "lines": 137,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "catcher": {
      "start_point": [
        830,
        0
      ],
      "end_point": [
        835,
        1
      ],
      "content": "static void\ncatcher (int sig)\n{\n  (void)sig;\t/* Unused. Silent compiler warning. */\n  /* do nothing */\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "ignore_sigpipe": {
      "start_point": [
        841,
        0
      ],
      "end_point": [
        857,
        1
      ],
      "content": "static void\nignore_sigpipe (void)\n{\n  struct sigaction oldsig;\n  struct sigaction sig;\n\n  sig.sa_handler = &catcher;\n  sigemptyset (&sig.sa_mask);\n#ifdef SA_INTERRUPT\n  sig.sa_flags = SA_INTERRUPT;  /* SunOS */\n#else\n  sig.sa_flags = SA_RESTART;\n#endif\n  if (0 != sigaction (SIGPIPE, &sig, &oldsig))\n    fprintf (stderr,\n             \"Failed to install SIGPIPE handler: %s\\n\", strerror (errno));\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        920,
        0
      ],
      "end_point": [
        984,
        1
      ],
      "content": "int\nmain (int argc, char *const *argv)\n{\n  struct MHD_Daemon *d;\n  unsigned int port;\n\n  if ( (argc != 2) ||\n       (1 != sscanf (argv[1], \"%u\", &port)) ||\n       (UINT16_MAX < port) )\n    {\n      fprintf (stderr,\n\t       \"%s PORT\\n\", argv[0]);\n      return 1;\n    }\n  #ifndef MINGW\n  ignore_sigpipe ();\n  #endif\n#ifdef MHD_HAVE_LIBMAGIC\n  magic = magic_open (MAGIC_MIME_TYPE);\n  (void) magic_load (magic, NULL);\n#endif /* MHD_HAVE_LIBMAGIC */\n\n  (void) pthread_mutex_init (&mutex, NULL);\n  file_not_found_response = MHD_create_response_from_buffer (strlen (FILE_NOT_FOUND_PAGE),\n\t\t\t\t\t\t\t     (void *) FILE_NOT_FOUND_PAGE,\n\t\t\t\t\t\t\t     MHD_RESPMEM_PERSISTENT);\n  mark_as_html (file_not_found_response);\n  request_refused_response = MHD_create_response_from_buffer (strlen (REQUEST_REFUSED_PAGE),\n\t\t\t\t\t\t\t     (void *) REQUEST_REFUSED_PAGE,\n\t\t\t\t\t\t\t     MHD_RESPMEM_PERSISTENT);\n  mark_as_html (request_refused_response);\n  internal_error_response = MHD_create_response_from_buffer (strlen (INTERNAL_ERROR_PAGE),\n\t\t\t\t\t\t\t     (void *) INTERNAL_ERROR_PAGE,\n\t\t\t\t\t\t\t     MHD_RESPMEM_PERSISTENT);\n  mark_as_html (internal_error_response);\n  update_directory ();\n  d = MHD_start_daemon (MHD_USE_AUTO | MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_ERROR_LOG | MHD_USE_TLS,\n                        port,\n                        NULL, NULL,\n\t\t\t&generate_page, NULL,\n\t\t\tMHD_OPTION_CONNECTION_MEMORY_LIMIT, (size_t) (256 * 1024),\n#if PRODUCTION\n\t\t\tMHD_OPTION_PER_IP_CONNECTION_LIMIT, (unsigned int) (64),\n#endif\n\t\t\tMHD_OPTION_CONNECTION_TIMEOUT, (unsigned int) (120 /* seconds */),\n\t\t\tMHD_OPTION_THREAD_POOL_SIZE, (unsigned int) NUMBER_OF_THREADS,\n\t\t\tMHD_OPTION_NOTIFY_COMPLETED, &response_completed_callback, NULL,\n                        MHD_OPTION_HTTPS_MEM_KEY, srv_signed_key_pem,\n                        MHD_OPTION_HTTPS_MEM_CERT, srv_signed_cert_pem,\n\t\t\tMHD_OPTION_END);\n  if (NULL == d)\n    return 1;\n  fprintf (stderr, \"HTTP server running. Press ENTER to stop the server\\n\");\n  (void) getc (stdin);\n  MHD_stop_daemon (d);\n  MHD_destroy_response (file_not_found_response);\n  MHD_destroy_response (request_refused_response);\n  MHD_destroy_response (internal_error_response);\n  update_cached_response (NULL);\n  (void) pthread_mutex_destroy (&mutex);\n#ifdef MHD_HAVE_LIBMAGIC\n  magic_close (magic);\n#endif /* MHD_HAVE_LIBMAGIC */\n  return 0;\n}",
      "lines": 65,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/examples/digest_auth_example.c": {
    "ahc_echo": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "static int\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data, size_t *upload_data_size, void **ptr)\n{\n  struct MHD_Response *response;\n  char *username;\n  const char *password = \"testpass\";\n  const char *realm = \"test@example.com\";\n  int ret;\n  (void)cls;               /* Unused. Silent compiler warning. */\n  (void)url;               /* Unused. Silent compiler warning. */\n  (void)method;            /* Unused. Silent compiler warning. */\n  (void)version;           /* Unused. Silent compiler warning. */\n  (void)upload_data;       /* Unused. Silent compiler warning. */\n  (void)upload_data_size;  /* Unused. Silent compiler warning. */\n  (void)ptr;               /* Unused. Silent compiler warning. */\n\n  username = MHD_digest_auth_get_username(connection);\n  if (NULL == username)\n    {\n      response = MHD_create_response_from_buffer(strlen (DENIED),\n\t\t\t\t\t\t DENIED,\n\t\t\t\t\t\t MHD_RESPMEM_PERSISTENT);\n      ret = MHD_queue_auth_fail_response(connection, realm,\n\t\t\t\t\t MY_OPAQUE_STR,\n\t\t\t\t\t response,\n\t\t\t\t\t MHD_NO);\n      MHD_destroy_response(response);\n      return ret;\n    }\n  ret = MHD_digest_auth_check(connection, realm,\n\t\t\t      username,\n\t\t\t      password,\n\t\t\t      300);\n  MHD_free (username);\n  if ( (ret == MHD_INVALID_NONCE) ||\n       (ret == MHD_NO) )\n    {\n      response = MHD_create_response_from_buffer(strlen (DENIED),\n\t\t\t\t\t\t DENIED,\n\t\t\t\t\t\t MHD_RESPMEM_PERSISTENT);\n      if (NULL == response)\n\treturn MHD_NO;\n      ret = MHD_queue_auth_fail_response(connection, realm,\n\t\t\t\t\t MY_OPAQUE_STR,\n\t\t\t\t\t response,\n\t\t\t\t\t (ret == MHD_INVALID_NONCE) ? MHD_YES : MHD_NO);\n      MHD_destroy_response(response);\n      return ret;\n    }\n  response = MHD_create_response_from_buffer(strlen(PAGE), PAGE,\n\t\t\t\t\t     MHD_RESPMEM_PERSISTENT);\n  ret = MHD_queue_response(connection, MHD_HTTP_OK, response);\n  MHD_destroy_response(response);\n  return ret;\n}",
      "lines": 60,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        96,
        0
      ],
      "end_point": [
        145,
        1
      ],
      "content": "int\nmain (int argc, char *const *argv)\n{\n  int fd;\n  char rnd[8];\n  ssize_t len;\n  size_t off;\n  struct MHD_Daemon *d;\n\n  if (argc != 2)\n    {\n      printf (\"%s PORT\\n\", argv[0]);\n      return 1;\n    }\n  fd = open(\"/dev/urandom\", O_RDONLY);\n  if (-1 == fd)\n    {\n      fprintf (stderr, \"Failed to open `%s': %s\\n\",\n\t       \"/dev/urandom\",\n\t       strerror (errno));\n      return 1;\n    }\n  off = 0;\n  while (off < 8)\n    {\n      len = read(fd, rnd, 8);\n      if (len == -1)\n\t{\n\t  fprintf (stderr, \"Failed to read `%s': %s\\n\",\n\t\t   \"/dev/urandom\",\n\t\t   strerror (errno));\n\t  (void) close (fd);\n\t  return 1;\n\t}\n      off += len;\n    }\n  (void) close(fd);\n  d = MHD_start_daemon (MHD_USE_THREAD_PER_CONNECTION | MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_ERROR_LOG,\n                        atoi (argv[1]),\n                        NULL, NULL, &ahc_echo, PAGE,\n\t\t\tMHD_OPTION_DIGEST_AUTH_RANDOM, sizeof(rnd), rnd,\n\t\t\tMHD_OPTION_NONCE_NC_SIZE, 300,\n\t\t\tMHD_OPTION_CONNECTION_TIMEOUT, (unsigned int) 120,\n\t\t\tMHD_OPTION_END);\n  if (d == NULL)\n    return 1;\n  (void) getc (stdin);\n  MHD_stop_daemon (d);\n  return 0;\n}",
      "lines": 50,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/examples/dual_stack_example.c": {
    "ahc_echo": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "static int\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data, size_t *upload_data_size, void **ptr)\n{\n  static int aptr;\n  const char *me = cls;\n  struct MHD_Response *response;\n  int ret;\n  (void)url;               /* Unused. Silent compiler warning. */\n  (void)version;           /* Unused. Silent compiler warning. */\n  (void)upload_data;       /* Unused. Silent compiler warning. */\n  (void)upload_data_size;  /* Unused. Silent compiler warning. */\n\n  if (0 != strcmp (method, \"GET\"))\n    return MHD_NO;              /* unexpected method */\n  if (&aptr != *ptr)\n    {\n      /* do never respond on first call */\n      *ptr = &aptr;\n      return MHD_YES;\n    }\n  *ptr = NULL;                  /* reset when done */\n  response = MHD_create_response_from_buffer (strlen (me),\n\t\t\t\t\t      (void *) me,\n\t\t\t\t\t      MHD_RESPMEM_PERSISTENT);\n  ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n  MHD_destroy_response (response);\n  return ret;\n}",
      "lines": 33,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        64,
        0
      ],
      "end_point": [
        82,
        1
      ],
      "content": "int\nmain (int argc, char *const *argv)\n{\n  struct MHD_Daemon *d;\n\n  if (argc != 2)\n    {\n      printf (\"%s PORT\\n\", argv[0]);\n      return 1;\n    }\n  d = MHD_start_daemon (MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_ERROR_LOG | MHD_USE_DUAL_STACK,\n\t\t\tatoi (argv[1]),\n\t\t\tNULL, NULL, &ahc_echo, PAGE,\n\t\t\tMHD_OPTION_CONNECTION_TIMEOUT, (unsigned int) 120,\n\t\t\tMHD_OPTION_END);\n  (void) getc (stdin);\n  MHD_stop_daemon (d);\n  return 0;\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/examples/fileserver_example.c": {
    "ahc_echo": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        111,
        1
      ],
      "content": "static int\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data,\n\t  size_t *upload_data_size, void **ptr)\n{\n  static int aptr;\n  struct MHD_Response *response;\n  int ret;\n  int fd;\n  struct stat buf;\n  (void)cls;               /* Unused. Silent compiler warning. */\n  (void)version;           /* Unused. Silent compiler warning. */\n  (void)upload_data;       /* Unused. Silent compiler warning. */\n  (void)upload_data_size;  /* Unused. Silent compiler warning. */\n\n  if ( (0 != strcmp (method, MHD_HTTP_METHOD_GET)) &&\n       (0 != strcmp (method, MHD_HTTP_METHOD_HEAD)) )\n    return MHD_NO;              /* unexpected method */\n  if (&aptr != *ptr)\n    {\n      /* do never respond on first call */\n      *ptr = &aptr;\n      return MHD_YES;\n    }\n  *ptr = NULL;                  /* reset when done */\n  /* WARNING: direct usage of url as filename is for example only!\n   * NEVER pass received data directly as parameter to file manipulation\n   * functions. Always check validity of data before using.\n   */\n  if (NULL != strstr(url, \"../\")) /* Very simplified check! */\n    fd = -1; /* Do not allow usage of parent directories. */\n  else\n    fd = open (url + 1, O_RDONLY);\n  if (-1 != fd)\n    {\n      if ( (0 != fstat (fd, &buf)) ||\n           (! S_ISREG (buf.st_mode)) )\n        {\n          /* not a regular file, refuse to serve */\n          if (0 != close (fd))\n            abort ();\n          fd = -1;\n        }\n    }\n  if (-1 == fd)\n    {\n      response = MHD_create_response_from_buffer (strlen (PAGE),\n\t\t\t\t\t\t  (void *) PAGE,\n\t\t\t\t\t\t  MHD_RESPMEM_PERSISTENT);\n      ret = MHD_queue_response (connection, MHD_HTTP_NOT_FOUND, response);\n      MHD_destroy_response (response);\n    }\n  else\n    {\n      response = MHD_create_response_from_fd64 (buf.st_size, fd);\n      if (NULL == response)\n\t{\n\t  if (0 != close (fd))\n            abort ();\n\t  return MHD_NO;\n\t}\n      ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n      MHD_destroy_response (response);\n    }\n  return ret;\n}",
      "lines": 70,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        114,
        0
      ],
      "end_point": [
        132,
        1
      ],
      "content": "int\nmain (int argc, char *const *argv)\n{\n  struct MHD_Daemon *d;\n\n  if (argc != 2)\n    {\n      printf (\"%s PORT\\n\", argv[0]);\n      return 1;\n    }\n  d = MHD_start_daemon (MHD_USE_THREAD_PER_CONNECTION | MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_ERROR_LOG,\n                        atoi (argv[1]),\n                        NULL, NULL, &ahc_echo, PAGE, MHD_OPTION_END);\n  if (d == NULL)\n    return 1;\n  (void) getc (stdin);\n  MHD_stop_daemon (d);\n  return 0;\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/examples/fileserver_example_dirs.c": {
    "file_reader": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "static ssize_t\nfile_reader (void *cls, uint64_t pos, char *buf, size_t max)\n{\n  FILE *file = cls;\n\n  (void) fseek (file, pos, SEEK_SET);\n  return fread (buf, 1, max, file);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "ssize_t"
      ]
    },
    "file_free_callback": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "static void\nfile_free_callback (void *cls)\n{\n  FILE *file = cls;\n  fclose (file);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "dir_free_callback": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "static void\ndir_free_callback (void *cls)\n{\n  DIR *dir = cls;\n  if (dir != NULL)\n    closedir (dir);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "dir_reader": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "static ssize_t\ndir_reader (void *cls, uint64_t pos, char *buf, size_t max)\n{\n  DIR *dir = cls;\n  struct dirent *e;\n\n  if (max < 512)\n    return 0;\n  (void)pos; /* 'pos' is ignored as function return next one single entry per call. */\n  do\n    {\n      e = readdir (dir);\n      if (e == NULL)\n        return MHD_CONTENT_READER_END_OF_STREAM;\n  } while (e->d_name[0] == '.');\n  return snprintf (buf, max,\n\t\t   \"<a href=\\\"/%s\\\">%s</a><br>\",\n\t\t   e->d_name,\n\t\t   e->d_name);\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "ssize_t"
      ]
    },
    "ahc_echo": {
      "start_point": [
        82,
        0
      ],
      "end_point": [
        184,
        1
      ],
      "content": "static int\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data,\n\t  size_t *upload_data_size, void **ptr)\n{\n  static int aptr;\n  struct MHD_Response *response;\n  int ret;\n  FILE *file;\n  int fd;\n  DIR *dir;\n  struct stat buf;\n  char emsg[1024];\n  (void)cls;               /* Unused. Silent compiler warning. */\n  (void)version;           /* Unused. Silent compiler warning. */\n  (void)upload_data;       /* Unused. Silent compiler warning. */\n  (void)upload_data_size;  /* Unused. Silent compiler warning. */\n\n  if (0 != strcmp (method, MHD_HTTP_METHOD_GET))\n    return MHD_NO;              /* unexpected method */\n  if (&aptr != *ptr)\n    {\n      /* do never respond on first call */\n      *ptr = &aptr;\n      return MHD_YES;\n    }\n  *ptr = NULL;                  /* reset when done */\n\n  file = fopen (&url[1], \"rb\");\n  if (NULL != file)\n    {\n      fd = fileno (file);\n      if (-1 == fd)\n        {\n          (void) fclose (file);\n          return MHD_NO; /* internal error */\n        }\n      if ( (0 != fstat (fd, &buf)) ||\n           (! S_ISREG (buf.st_mode)) )\n        {\n          /* not a regular file, refuse to serve */\n          fclose (file);\n          file = NULL;\n        }\n    }\n\n  if (NULL == file)\n    {\n      dir = opendir (\".\");\n      if (NULL == dir)\n\t{\n\t  /* most likely cause: more concurrent requests than\n\t     available file descriptors / 2 */\n\t  snprintf (emsg,\n\t\t    sizeof (emsg),\n\t\t    \"Failed to open directory `.': %s\\n\",\n\t\t    strerror (errno));\n\t  response = MHD_create_response_from_buffer (strlen (emsg),\n\t\t\t\t\t\t      emsg,\n\t\t\t\t\t\t      MHD_RESPMEM_MUST_COPY);\n\t  if (NULL == response)\n\t    return MHD_NO;\n\t  ret = MHD_queue_response (connection,\n                                    MHD_HTTP_SERVICE_UNAVAILABLE,\n                                    response);\n\t  MHD_destroy_response (response);\n\t}\n      else\n\t{\n\t  response = MHD_create_response_from_callback (MHD_SIZE_UNKNOWN,\n\t\t\t\t\t\t\t32 * 1024,\n\t\t\t\t\t\t\t&dir_reader,\n\t\t\t\t\t\t\tdir,\n\t\t\t\t\t\t\t&dir_free_callback);\n\t  if (NULL == response)\n\t    {\n\t      closedir (dir);\n\t      return MHD_NO;\n\t    }\n\t  ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n\t  MHD_destroy_response (response);\n\t}\n    }\n  else\n    {\n      response = MHD_create_response_from_callback (buf.st_size, 32 * 1024,     /* 32k page size */\n                                                    &file_reader,\n                                                    file,\n                                                    &file_free_callback);\n      if (NULL == response)\n\t{\n\t  fclose (file);\n\t  return MHD_NO;\n\t}\n      ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n      MHD_destroy_response (response);\n    }\n  return ret;\n}",
      "lines": 103,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        187,
        0
      ],
      "end_point": [
        205,
        1
      ],
      "content": "int\nmain (int argc, char *const *argv)\n{\n  struct MHD_Daemon *d;\n\n  if (argc != 2)\n    {\n      printf (\"%s PORT\\n\", argv[0]);\n      return 1;\n    }\n  d = MHD_start_daemon (MHD_USE_THREAD_PER_CONNECTION | MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_ERROR_LOG,\n                        atoi (argv[1]),\n                        NULL, NULL, &ahc_echo, PAGE, MHD_OPTION_END);\n  if (NULL == d)\n    return 1;\n  (void) getc (stdin);\n  MHD_stop_daemon (d);\n  return 0;\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/examples/fileserver_example_external_select.c": {
    "file_reader": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "static ssize_t\nfile_reader (void *cls, uint64_t pos, char *buf, size_t max)\n{\n  FILE *file = cls;\n\n  (void) fseek (file, pos, SEEK_SET);\n  return fread (buf, 1, max, file);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "ssize_t"
      ]
    },
    "free_callback": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        46,
        1
      ],
      "content": "static void\nfree_callback (void *cls)\n{\n  FILE *file = cls;\n  fclose (file);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "ahc_echo": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        120,
        1
      ],
      "content": "static int\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data,\n\t  size_t *upload_data_size, void **ptr)\n{\n  static int aptr;\n  struct MHD_Response *response;\n  int ret;\n  FILE *file;\n  int fd;\n  struct stat buf;\n  (void)cls;               /* Unused. Silent compiler warning. */\n  (void)version;           /* Unused. Silent compiler warning. */\n  (void)upload_data;       /* Unused. Silent compiler warning. */\n  (void)upload_data_size;  /* Unused. Silent compiler warning. */\n\n  if (0 != strcmp (method, MHD_HTTP_METHOD_GET))\n    return MHD_NO;              /* unexpected method */\n  if (&aptr != *ptr)\n    {\n      /* do never respond on first call */\n      *ptr = &aptr;\n      return MHD_YES;\n    }\n  *ptr = NULL;                  /* reset when done */\n\n  file = fopen (&url[1], \"rb\");\n  if (NULL != file)\n    {\n      fd = fileno (file);\n      if (-1 == fd)\n        {\n          (void) fclose (file);\n          return MHD_NO; /* internal error */\n        }\n      if ( (0 != fstat (fd, &buf)) ||\n           (! S_ISREG (buf.st_mode)) )\n        {\n          /* not a regular file, refuse to serve */\n          fclose (file);\n          file = NULL;\n        }\n    }\n\n  if (NULL == file)\n    {\n      response = MHD_create_response_from_buffer (strlen (PAGE),\n\t\t\t\t\t\t  (void *) PAGE,\n\t\t\t\t\t\t  MHD_RESPMEM_PERSISTENT);\n      ret = MHD_queue_response (connection, MHD_HTTP_NOT_FOUND, response);\n      MHD_destroy_response (response);\n    }\n  else\n    {\n      response = MHD_create_response_from_callback (buf.st_size, 32 * 1024,     /* 32k page size */\n                                                    &file_reader,\n                                                    file,\n                                                    &free_callback);\n      if (NULL == response)\n\t{\n\t  fclose (file);\n\t  return MHD_NO;\n\t}\n      ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n      MHD_destroy_response (response);\n    }\n  return ret;\n}",
      "lines": 72,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        123,
        0
      ],
      "end_point": [
        174,
        1
      ],
      "content": "int\nmain (int argc, char *const *argv)\n{\n  struct MHD_Daemon *d;\n  time_t end;\n  time_t t;\n  struct timeval tv;\n  fd_set rs;\n  fd_set ws;\n  fd_set es;\n  MHD_socket max;\n  MHD_UNSIGNED_LONG_LONG mhd_timeout;\n\n  if (argc != 3)\n    {\n      printf (\"%s PORT SECONDS-TO-RUN\\n\", argv[0]);\n      return 1;\n    }\n  d = MHD_start_daemon (MHD_USE_ERROR_LOG,\n                        atoi (argv[1]),\n                        NULL, NULL, &ahc_echo, PAGE, MHD_OPTION_END);\n  if (d == NULL)\n    return 1;\n  end = time (NULL) + atoi (argv[2]);\n  while ((t = time (NULL)) < end)\n    {\n      tv.tv_sec = end - t;\n      tv.tv_usec = 0;\n      max = 0;\n      FD_ZERO (&rs);\n      FD_ZERO (&ws);\n      FD_ZERO (&es);\n      if (MHD_YES != MHD_get_fdset (d, &rs, &ws, &es, &max))\n\tbreak; /* fatal internal error */\n      if (MHD_get_timeout (d, &mhd_timeout) == MHD_YES)\n        {\n          if (((MHD_UNSIGNED_LONG_LONG)tv.tv_sec) < mhd_timeout / 1000LL)\n            {\n              tv.tv_sec = mhd_timeout / 1000LL;\n              tv.tv_usec = (mhd_timeout - (tv.tv_sec * 1000LL)) * 1000LL;\n            }\n        }\n      if (-1 == select (max + 1, &rs, &ws, &es, &tv))\n        {\n          if (EINTR != errno)\n            abort ();\n        }\n      MHD_run (d);\n    }\n  MHD_stop_daemon (d);\n  return 0;\n}",
      "lines": 52,
      "depth": 17,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/examples/https_fileserver_example.c": {
    "file_reader": {
      "start_point": [
        95,
        0
      ],
      "end_point": [
        102,
        1
      ],
      "content": "static ssize_t\nfile_reader (void *cls, uint64_t pos, char *buf, size_t max)\n{\n  FILE *file = cls;\n\n  (void) fseek (file, pos, SEEK_SET);\n  return fread (buf, 1, max, file);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "ssize_t"
      ]
    },
    "file_free_callback": {
      "start_point": [
        104,
        0
      ],
      "end_point": [
        109,
        1
      ],
      "content": "static void\nfile_free_callback (void *cls)\n{\n  FILE *file = cls;\n  fclose (file);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "http_ahc": {
      "start_point": [
        112,
        0
      ],
      "end_point": [
        182,
        1
      ],
      "content": "static int\nhttp_ahc (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data,\n\t  size_t *upload_data_size, void **ptr)\n{\n  static int aptr;\n  struct MHD_Response *response;\n  int ret;\n  FILE *file;\n  int fd;\n  struct stat buf;\n  (void)cls;               /* Unused. Silent compiler warning. */\n  (void)version;           /* Unused. Silent compiler warning. */\n  (void)upload_data;       /* Unused. Silent compiler warning. */\n  (void)upload_data_size;  /* Unused. Silent compiler warning. */\n\n  if (0 != strcmp (method, MHD_HTTP_METHOD_GET))\n    return MHD_NO;              /* unexpected method */\n  if (&aptr != *ptr)\n    {\n      /* do never respond on first call */\n      *ptr = &aptr;\n      return MHD_YES;\n    }\n  *ptr = NULL;                  /* reset when done */\n\n  file = fopen (&url[1], \"rb\");\n  if (NULL != file)\n    {\n      fd = fileno (file);\n      if (-1 == fd)\n        {\n          (void) fclose (file);\n          return MHD_NO; /* internal error */\n        }\n      if ( (0 != fstat (fd, &buf)) ||\n           (! S_ISREG (buf.st_mode)) )\n        {\n          /* not a regular file, refuse to serve */\n          fclose (file);\n          file = NULL;\n        }\n    }\n\n  if (NULL == file)\n    {\n      response = MHD_create_response_from_buffer (strlen (EMPTY_PAGE),\n\t\t\t\t\t\t  (void *) EMPTY_PAGE,\n\t\t\t\t\t\t  MHD_RESPMEM_PERSISTENT);\n      ret = MHD_queue_response (connection, MHD_HTTP_NOT_FOUND, response);\n      MHD_destroy_response (response);\n    }\n  else\n    {\n      response = MHD_create_response_from_callback (buf.st_size, 32 * 1024,     /* 32k PAGE_NOT_FOUND size */\n                                                    &file_reader, file,\n                                                    &file_free_callback);\n      if (NULL == response)\n\t{\n\t  fclose (file);\n\t  return MHD_NO;\n\t}\n      ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n      MHD_destroy_response (response);\n    }\n  return ret;\n}",
      "lines": 71,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        185,
        0
      ],
      "end_point": [
        227,
        1
      ],
      "content": "int\nmain (int argc, char *const *argv)\n{\n  struct MHD_Daemon *TLS_daemon;\n  int port;\n\n  if (argc != 2)\n    {\n      printf (\"%s PORT\\n\", argv[0]);\n      return 1;\n    }\n  port = atoi (argv[1]);\n  if ( (1 > port) ||\n       (port > UINT16_MAX) )\n    {\n      fprintf (stderr,\n               \"Port must be a number between 1 and 65535\\n\");\n      return 1;\n    }\n\n  TLS_daemon =\n    MHD_start_daemon (MHD_USE_THREAD_PER_CONNECTION | MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_ERROR_LOG |\n                      MHD_USE_TLS,\n                      (uint16_t) port,\n                      NULL, NULL,\n                      &http_ahc, NULL,\n                      MHD_OPTION_CONNECTION_TIMEOUT, 256,\n                      MHD_OPTION_HTTPS_MEM_KEY, key_pem,\n                      MHD_OPTION_HTTPS_MEM_CERT, cert_pem,\n                      MHD_OPTION_END);\n  if (NULL == TLS_daemon)\n    {\n      fprintf (stderr, \"Error: failed to start TLS_daemon\\n\");\n      return 1;\n    }\n  printf (\"MHD daemon listening on port %u\\n\",\n          (unsigned int) port);\n\n  (void) getc (stdin);\n\n  MHD_stop_daemon (TLS_daemon);\n  return 0;\n}",
      "lines": 43,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/examples/minimal_example.c": {
    "ahc_echo": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "static int\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data, size_t *upload_data_size, void **ptr)\n{\n  static int aptr;\n  const char *me = cls;\n  struct MHD_Response *response;\n  int ret;\n  (void)url;               /* Unused. Silent compiler warning. */\n  (void)version;           /* Unused. Silent compiler warning. */\n  (void)upload_data;       /* Unused. Silent compiler warning. */\n  (void)upload_data_size;  /* Unused. Silent compiler warning. */\n\n  if (0 != strcmp (method, \"GET\"))\n    return MHD_NO;              /* unexpected method */\n  if (&aptr != *ptr)\n    {\n      /* do never respond on first call */\n      *ptr = &aptr;\n      return MHD_YES;\n    }\n  *ptr = NULL;                  /* reset when done */\n  response = MHD_create_response_from_buffer (strlen (me),\n\t\t\t\t\t      (void *) me,\n\t\t\t\t\t      MHD_RESPMEM_PERSISTENT);\n  ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n  MHD_destroy_response (response);\n  return ret;\n}",
      "lines": 33,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        63,
        0
      ],
      "end_point": [
        88,
        1
      ],
      "content": "int\nmain (int argc, char *const *argv)\n{\n  struct MHD_Daemon *d;\n\n  if (argc != 2)\n    {\n      printf (\"%s PORT\\n\", argv[0]);\n      return 1;\n    }\n  d = MHD_start_daemon (/* MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_ERROR_LOG, */\n                        MHD_USE_AUTO | MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_ERROR_LOG,\n                        /* MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_ERROR_LOG | MHD_USE_POLL, */\n\t\t\t/* MHD_USE_THREAD_PER_CONNECTION | MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_ERROR_LOG | MHD_USE_POLL, */\n\t\t\t/* MHD_USE_THREAD_PER_CONNECTION | MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_ERROR_LOG, */\n                        atoi (argv[1]),\n                        NULL, NULL, &ahc_echo, PAGE,\n\t\t\tMHD_OPTION_CONNECTION_TIMEOUT, (unsigned int) 120,\n\t\t\tMHD_OPTION_STRICT_FOR_CLIENT, (int) 1,\n\t\t\tMHD_OPTION_END);\n  if (d == NULL)\n    return 1;\n  (void) getc (stdin);\n  MHD_stop_daemon (d);\n  return 0;\n}",
      "lines": 26,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/examples/minimal_example_comet.c": {
    "data_generator": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "static ssize_t\ndata_generator (void *cls, uint64_t pos, char *buf, size_t max)\n{\n  (void)cls; /* Unused. Silent compiler warning. */\n  (void)pos; /* Unused. Silent compiler warning. */\n  if (max < 80)\n    return 0;\n  memset (buf, 'A', max - 1);\n  buf[79] = '\\n';\n  return 80;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "ssize_t"
      ]
    },
    "ahc_echo": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "static int\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data, size_t *upload_data_size, void **ptr)\n{\n  static int aptr;\n  struct MHD_Response *response;\n  int ret;\n  (void)cls;               /* Unused. Silent compiler warning. */\n  (void)url;               /* Unused. Silent compiler warning. */\n  (void)version;           /* Unused. Silent compiler warning. */\n  (void)upload_data;       /* Unused. Silent compiler warning. */\n  (void)upload_data_size;  /* Unused. Silent compiler warning. */\n\n  if (0 != strcmp (method, \"GET\"))\n    return MHD_NO;              /* unexpected method */\n  if (&aptr != *ptr)\n    {\n      /* do never respond on first call */\n      *ptr = &aptr;\n      return MHD_YES;\n    }\n  *ptr = NULL;                  /* reset when done */\n  response = MHD_create_response_from_callback (MHD_SIZE_UNKNOWN,\n                                                80,\n                                                &data_generator, NULL, NULL);\n  ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n  MHD_destroy_response (response);\n  return ret;\n}",
      "lines": 33,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        73,
        0
      ],
      "end_point": [
        91,
        1
      ],
      "content": "int\nmain (int argc, char *const *argv)\n{\n  struct MHD_Daemon *d;\n\n  if (argc != 2)\n    {\n      printf (\"%s PORT\\n\", argv[0]);\n      return 1;\n    }\n  d = MHD_start_daemon (MHD_USE_AUTO | MHD_USE_THREAD_PER_CONNECTION | MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_ERROR_LOG,\n                        atoi (argv[1]),\n                        NULL, NULL, &ahc_echo, NULL, MHD_OPTION_END);\n  if (d == NULL)\n    return 1;\n  (void) getc (stdin);\n  MHD_stop_daemon (d);\n  return 0;\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/examples/msgs_i18n.c": {
    "ahc_echo": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "static int\nahc_echo (void *cls,\n\t  struct MHD_Connection *cnc,\n\t  const char *url,\n\t  const char *mt,\n\t  const char *ver,\n\t  const char *upd,\n\t  size_t *upsz,\n\t  void **ptr)\n{  \n  return MHD_NO;\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "error_handler": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "static void\nerror_handler (void *cls,\n\t       const char *fm,\n\t       va_list ap)\n{\n  /* Here we do the translation using GNU gettext.\n     As the error message is from libmicrohttpd, we specify\n     \"libmicrohttpd\" as the translation domain here. */\n  vprintf (dgettext (\"libmicrohttpd\",\n\t\t     fm),\n\t  ap);\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        73,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "int\nmain (int argc,\n      char **argv)\n{\n  setlocale(LC_ALL, \"\");\n\n  /* The example uses PO files in the directory \n     \"libmicrohttpd/src/examples/locale\".  This\n     needs to be adapted to match\n     where the MHD PO files are installed. */\n  bindtextdomain (\"libmicrohttpd\",\n\t\t  \"locale\");\n  MHD_start_daemon (MHD_USE_SELECT_INTERNALLY | MHD_FEATURE_MESSAGES | MHD_USE_ERROR_LOG,\n\t\t    8080,\n\t\t    NULL, NULL,\n\t\t    &ahc_echo, NULL,\n\t\t    MHD_OPTION_EXTERNAL_LOGGER, &error_handler, NULL,\n\t\t    99999 /* invalid option, to raise the error \n\t\t\t     \"Invalid option ...\" which we are going \n\t\t\t     to translate */);\n  return 1; /* This program won't \"succeed\"... */\n}",
      "lines": 22,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/examples/post_example.c": {
    "get_session": {
      "start_point": [
        145,
        0
      ],
      "end_point": [
        191,
        1
      ],
      "content": "static struct Session *\nget_session (struct MHD_Connection *connection)\n{\n  struct Session *ret;\n  const char *cookie;\n\n  cookie = MHD_lookup_connection_value (connection,\n\t\t\t\t\tMHD_COOKIE_KIND,\n\t\t\t\t\tCOOKIE_NAME);\n  if (cookie != NULL)\n    {\n      /* find existing session */\n      ret = sessions;\n      while (NULL != ret)\n\t{\n\t  if (0 == strcmp (cookie, ret->sid))\n\t    break;\n\t  ret = ret->next;\n\t}\n      if (NULL != ret)\n\t{\n\t  ret->rc++;\n\t  return ret;\n\t}\n    }\n  /* create fresh session */\n  ret = calloc (1, sizeof (struct Session));\n  if (NULL == ret)\n    {\n      fprintf (stderr, \"calloc error: %s\\n\", strerror (errno));\n      return NULL;\n    }\n  /* not a super-secure way to generate a random session ID,\n     but should do for a simple example... */\n  snprintf (ret->sid,\n\t    sizeof (ret->sid),\n\t    \"%X%X%X%X\",\n\t    (unsigned int) rand (),\n\t    (unsigned int) rand (),\n\t    (unsigned int) rand (),\n\t    (unsigned int) rand ());\n  ret->rc++;\n  ret->start = time (NULL);\n  ret->next = sessions;\n  sessions = ret;\n  return ret;\n}",
      "lines": 47,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "struct Session",
        "struct",
        "Session",
        "*\nget_session (struct MHD_Connection *connection)",
        "*"
      ]
    },
    "add_session_cookie": {
      "start_point": [
        242,
        0
      ],
      "end_point": [
        260,
        1
      ],
      "content": "static void\nadd_session_cookie (struct Session *session,\n\t\t    struct MHD_Response *response)\n{\n  char cstr[256];\n  snprintf (cstr,\n\t    sizeof (cstr),\n\t    \"%s=%s\",\n\t    COOKIE_NAME,\n\t    session->sid);\n  if (MHD_NO ==\n      MHD_add_response_header (response,\n\t\t\t       MHD_HTTP_HEADER_SET_COOKIE,\n\t\t\t       cstr))\n    {\n      fprintf (stderr,\n\t       \"Failed to set session cookie header!\\n\");\n    }\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "serve_simple_form": {
      "start_point": [
        272,
        0
      ],
      "end_point": [
        297,
        1
      ],
      "content": "static int\nserve_simple_form (const void *cls,\n\t\t   const char *mime,\n\t\t   struct Session *session,\n\t\t   struct MHD_Connection *connection)\n{\n  int ret;\n  const char *form = cls;\n  struct MHD_Response *response;\n\n  /* return static form */\n  response = MHD_create_response_from_buffer (strlen (form),\n\t\t\t\t\t      (void *) form,\n\t\t\t\t\t      MHD_RESPMEM_PERSISTENT);\n  if (NULL == response)\n    return MHD_NO;\n  add_session_cookie (session, response);\n  MHD_add_response_header (response,\n\t\t\t   MHD_HTTP_HEADER_CONTENT_ENCODING,\n\t\t\t   mime);\n  ret = MHD_queue_response (connection,\n\t\t\t    MHD_HTTP_OK,\n\t\t\t    response);\n  MHD_destroy_response (response);\n  return ret;\n}",
      "lines": 26,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "fill_v1_form": {
      "start_point": [
        308,
        0
      ],
      "end_point": [
        346,
        1
      ],
      "content": "static int\nfill_v1_form (const void *cls,\n\t      const char *mime,\n\t      struct Session *session,\n\t      struct MHD_Connection *connection)\n{\n  int ret;\n  size_t slen;\n  char *reply;\n  struct MHD_Response *response;\n  (void)cls; /* Unused. Silent compiler warning. */\n\n  slen = strlen (MAIN_PAGE) + strlen (session->value_1);\n  reply = malloc (slen + 1);\n  if (NULL == reply)\n    return MHD_NO;\n  snprintf (reply,\n\t    slen + 1,\n\t    MAIN_PAGE,\n\t    session->value_1);\n  /* return static form */\n  response = MHD_create_response_from_buffer (slen,\n\t\t\t\t\t      (void *) reply,\n\t\t\t\t\t      MHD_RESPMEM_MUST_FREE);\n  if (NULL == response)\n  {\n    free (reply);\n    return MHD_NO;\n  }\n  add_session_cookie (session, response);\n  MHD_add_response_header (response,\n\t\t\t   MHD_HTTP_HEADER_CONTENT_ENCODING,\n\t\t\t   mime);\n  ret = MHD_queue_response (connection,\n\t\t\t    MHD_HTTP_OK,\n\t\t\t    response);\n  MHD_destroy_response (response);\n  return ret;\n}",
      "lines": 39,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "fill_v1_v2_form": {
      "start_point": [
        357,
        0
      ],
      "end_point": [
        396,
        1
      ],
      "content": "static int\nfill_v1_v2_form (const void *cls,\n\t\t const char *mime,\n\t\t struct Session *session,\n\t\t struct MHD_Connection *connection)\n{\n  int ret;\n  char *reply;\n  struct MHD_Response *response;\n  size_t slen;\n  (void)cls; /* Unused. Silent compiler warning. */\n\n  slen = strlen (SECOND_PAGE) + strlen (session->value_1) + strlen (session->value_2);\n  reply = malloc (slen + 1);\n  if (NULL == reply)\n    return MHD_NO;\n  snprintf (reply,\n\t    slen + 1,\n\t    SECOND_PAGE,\n\t    session->value_1,\n            session->value_2);\n  /* return static form */\n  response = MHD_create_response_from_buffer (slen,\n\t\t\t\t\t      (void *) reply,\n\t\t\t\t\t      MHD_RESPMEM_MUST_FREE);\n  if (NULL == response)\n  {\n    free (reply);\n    return MHD_NO;\n  }\n  add_session_cookie (session, response);\n  MHD_add_response_header (response,\n\t\t\t   MHD_HTTP_HEADER_CONTENT_ENCODING,\n\t\t\t   mime);\n  ret = MHD_queue_response (connection,\n\t\t\t    MHD_HTTP_OK,\n\t\t\t    response);\n  MHD_destroy_response (response);\n  return ret;\n}",
      "lines": 40,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "not_found_page": {
      "start_point": [
        407,
        0
      ],
      "end_point": [
        432,
        1
      ],
      "content": "static int\nnot_found_page (const void *cls,\n\t\tconst char *mime,\n\t\tstruct Session *session,\n\t\tstruct MHD_Connection *connection)\n{\n  int ret;\n  struct MHD_Response *response;\n  (void)cls;     /* Unused. Silent compiler warning. */\n  (void)session; /* Unused. Silent compiler warning. */\n\n  /* unsupported HTTP method */\n  response = MHD_create_response_from_buffer (strlen (NOT_FOUND_ERROR),\n\t\t\t\t\t      (void *) NOT_FOUND_ERROR,\n\t\t\t\t\t      MHD_RESPMEM_PERSISTENT);\n  if (NULL == response)\n    return MHD_NO;\n  ret = MHD_queue_response (connection,\n\t\t\t    MHD_HTTP_NOT_FOUND,\n\t\t\t    response);\n  MHD_add_response_header (response,\n\t\t\t   MHD_HTTP_HEADER_CONTENT_ENCODING,\n\t\t\t   mime);\n  MHD_destroy_response (response);\n  return ret;\n}",
      "lines": 26,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "post_iterator": {
      "start_point": [
        468,
        0
      ],
      "end_point": [
        517,
        1
      ],
      "content": "static int\npost_iterator (void *cls,\n\t       enum MHD_ValueKind kind,\n\t       const char *key,\n\t       const char *filename,\n\t       const char *content_type,\n\t       const char *transfer_encoding,\n\t       const char *data, uint64_t off, size_t size)\n{\n  struct Request *request = cls;\n  struct Session *session = request->session;\n  (void)kind;              /* Unused. Silent compiler warning. */\n  (void)filename;          /* Unused. Silent compiler warning. */\n  (void)content_type;      /* Unused. Silent compiler warning. */\n  (void)transfer_encoding; /* Unused. Silent compiler warning. */\n\n  if (0 == strcmp (\"DONE\", key))\n    {\n      fprintf (stdout,\n\t       \"Session `%s' submitted `%s', `%s'\\n\",\n\t       session->sid,\n\t       session->value_1,\n\t       session->value_2);\n      return MHD_YES;\n    }\n  if (0 == strcmp (\"v1\", key))\n    {\n      if (size + off >= sizeof(session->value_1))\n\tsize = sizeof (session->value_1) - off - 1;\n      memcpy (&session->value_1[off],\n\t      data,\n\t      size);\n      session->value_1[size+off] = '\\0';\n      return MHD_YES;\n    }\n  if (0 == strcmp (\"v2\", key))\n    {\n      if (size + off >= sizeof(session->value_2))\n\tsize = sizeof (session->value_2) - off - 1;\n      memcpy (&session->value_2[off],\n\t      data,\n\t      size);\n      session->value_2[size+off] = '\\0';\n      return MHD_YES;\n    }\n  fprintf (stderr,\n           \"Unsupported form value `%s'\\n\",\n           key);\n  return MHD_YES;\n}",
      "lines": 50,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "create_response": {
      "start_point": [
        553,
        0
      ],
      "end_point": [
        650,
        1
      ],
      "content": "static int\ncreate_response (void *cls,\n\t\t struct MHD_Connection *connection,\n\t\t const char *url,\n\t\t const char *method,\n\t\t const char *version,\n\t\t const char *upload_data,\n\t\t size_t *upload_data_size,\n\t\t void **ptr)\n{\n  struct MHD_Response *response;\n  struct Request *request;\n  struct Session *session;\n  int ret;\n  unsigned int i;\n  (void)cls;               /* Unused. Silent compiler warning. */\n  (void)version;           /* Unused. Silent compiler warning. */\n\n  request = *ptr;\n  if (NULL == request)\n    {\n      request = calloc (1, sizeof (struct Request));\n      if (NULL == request)\n\t{\n\t  fprintf (stderr, \"calloc error: %s\\n\", strerror (errno));\n\t  return MHD_NO;\n\t}\n      *ptr = request;\n      if (0 == strcmp (method, MHD_HTTP_METHOD_POST))\n\t{\n\t  request->pp = MHD_create_post_processor (connection, 1024,\n\t\t\t\t\t\t   &post_iterator, request);\n\t  if (NULL == request->pp)\n\t    {\n\t      fprintf (stderr, \"Failed to setup post processor for `%s'\\n\",\n\t\t       url);\n\t      return MHD_NO; /* internal error */\n\t    }\n\t}\n      return MHD_YES;\n    }\n  if (NULL == request->session)\n    {\n      request->session = get_session (connection);\n      if (NULL == request->session)\n\t{\n\t  fprintf (stderr, \"Failed to setup session for `%s'\\n\",\n\t\t   url);\n\t  return MHD_NO; /* internal error */\n\t}\n    }\n  session = request->session;\n  session->start = time (NULL);\n  if (0 == strcmp (method, MHD_HTTP_METHOD_POST))\n    {\n      /* evaluate POST data */\n      MHD_post_process (request->pp,\n\t\t\tupload_data,\n\t\t\t*upload_data_size);\n      if (0 != *upload_data_size)\n\t{\n\t  *upload_data_size = 0;\n\t  return MHD_YES;\n\t}\n      /* done with POST data, serve response */\n      MHD_destroy_post_processor (request->pp);\n      request->pp = NULL;\n      method = MHD_HTTP_METHOD_GET; /* fake 'GET' */\n      if (NULL != request->post_url)\n\turl = request->post_url;\n    }\n\n  if ( (0 == strcmp (method, MHD_HTTP_METHOD_GET)) ||\n       (0 == strcmp (method, MHD_HTTP_METHOD_HEAD)) )\n    {\n      /* find out which page to serve */\n      i=0;\n      while ( (pages[i].url != NULL) &&\n\t      (0 != strcmp (pages[i].url, url)) )\n\ti++;\n      ret = pages[i].handler (pages[i].handler_cls,\n\t\t\t      pages[i].mime,\n\t\t\t      session, connection);\n      if (ret != MHD_YES)\n\tfprintf (stderr, \"Failed to create page for `%s'\\n\",\n\t\t url);\n      return ret;\n    }\n  /* unsupported HTTP method */\n  response = MHD_create_response_from_buffer (strlen (METHOD_ERROR),\n\t\t\t\t\t      (void *) METHOD_ERROR,\n\t\t\t\t\t      MHD_RESPMEM_PERSISTENT);\n  ret = MHD_queue_response (connection,\n\t\t\t    MHD_HTTP_NOT_ACCEPTABLE,\n\t\t\t    response);\n  MHD_destroy_response (response);\n  return ret;\n}",
      "lines": 98,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "request_completed_callback": {
      "start_point": [
        662,
        0
      ],
      "end_point": [
        680,
        1
      ],
      "content": "static void\nrequest_completed_callback (void *cls,\n\t\t\t    struct MHD_Connection *connection,\n\t\t\t    void **con_cls,\n\t\t\t    enum MHD_RequestTerminationCode toe)\n{\n  struct Request *request = *con_cls;\n  (void)cls;         /* Unused. Silent compiler warning. */\n  (void)connection;  /* Unused. Silent compiler warning. */\n  (void)toe;         /* Unused. Silent compiler warning. */\n\n  if (NULL == request)\n    return;\n  if (NULL != request->session)\n    request->session->rc--;\n  if (NULL != request->pp)\n    MHD_destroy_post_processor (request->pp);\n  free (request);\n}",
      "lines": 19,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "expire_sessions": {
      "start_point": [
        687,
        0
      ],
      "end_point": [
        714,
        1
      ],
      "content": "static void\nexpire_sessions ()\n{\n  struct Session *pos;\n  struct Session *prev;\n  struct Session *next;\n  time_t now;\n\n  now = time (NULL);\n  prev = NULL;\n  pos = sessions;\n  while (NULL != pos)\n    {\n      next = pos->next;\n      if (now - pos->start > 60 * 60)\n\t{\n\t  /* expire sessions after 1h */\n\t  if (NULL == prev)\n\t    sessions = pos->next;\n\t  else\n\t    prev->next = next;\n\t  free (pos);\n\t}\n      else\n        prev = pos;\n      pos = next;\n    }\n}",
      "lines": 28,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        721,
        0
      ],
      "end_point": [
        775,
        1
      ],
      "content": "int\nmain (int argc, char *const *argv)\n{\n  struct MHD_Daemon *d;\n  struct timeval tv;\n  struct timeval *tvp;\n  fd_set rs;\n  fd_set ws;\n  fd_set es;\n  MHD_socket max;\n  MHD_UNSIGNED_LONG_LONG mhd_timeout;\n\n  if (argc != 2)\n    {\n      printf (\"%s PORT\\n\", argv[0]);\n      return 1;\n    }\n  /* initialize PRNG */\n  srand ((unsigned int) time (NULL));\n  d = MHD_start_daemon (MHD_USE_ERROR_LOG,\n                        atoi (argv[1]),\n                        NULL, NULL,\n\t\t\t&create_response, NULL,\n\t\t\tMHD_OPTION_CONNECTION_TIMEOUT, (unsigned int) 15,\n\t\t\tMHD_OPTION_NOTIFY_COMPLETED, &request_completed_callback, NULL,\n\t\t\tMHD_OPTION_END);\n  if (NULL == d)\n    return 1;\n  while (1)\n    {\n      expire_sessions ();\n      max = 0;\n      FD_ZERO (&rs);\n      FD_ZERO (&ws);\n      FD_ZERO (&es);\n      if (MHD_YES != MHD_get_fdset (d, &rs, &ws, &es, &max))\n\tbreak; /* fatal internal error */\n      if (MHD_get_timeout (d, &mhd_timeout) == MHD_YES)\n\t{\n\t  tv.tv_sec = mhd_timeout / 1000;\n\t  tv.tv_usec = (mhd_timeout - (tv.tv_sec * 1000)) * 1000;\n\t  tvp = &tv;\n\t}\n      else\n\ttvp = NULL;\n      if (-1 == select (max + 1, &rs, &ws, &es, tvp))\n        {\n          if (EINTR != errno)\n            abort ();\n        }\n      MHD_run (d);\n    }\n  MHD_stop_daemon (d);\n  return 0;\n}",
      "lines": 55,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/examples/querystring_example.c": {
    "ahc_echo": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        73,
        1
      ],
      "content": "static int\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data, size_t *upload_data_size, void **ptr)\n{\n  static int aptr;\n  const char *fmt = cls;\n  const char *val;\n  char *me;\n  struct MHD_Response *response;\n  int ret;\n  (void)url;               /* Unused. Silent compiler warning. */\n  (void)version;           /* Unused. Silent compiler warning. */\n  (void)upload_data;       /* Unused. Silent compiler warning. */\n  (void)upload_data_size;  /* Unused. Silent compiler warning. */\n\n  if (0 != strcmp (method, \"GET\"))\n    return MHD_NO;              /* unexpected method */\n  if (&aptr != *ptr)\n    {\n      /* do never respond on first call */\n      *ptr = &aptr;\n      return MHD_YES;\n    }\n  *ptr = NULL;                  /* reset when done */\n  val = MHD_lookup_connection_value (connection, MHD_GET_ARGUMENT_KIND, \"q\");\n  me = malloc (snprintf (NULL, 0, fmt, \"q\", val) + 1);\n  if (me == NULL)\n    return MHD_NO;\n  sprintf (me, fmt, \"q\", val);\n  response = MHD_create_response_from_buffer (strlen (me), me,\n\t\t\t\t\t      MHD_RESPMEM_MUST_FREE);\n  if (response == NULL)\n    {\n      free (me);\n      return MHD_NO;\n    }\n  ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n  MHD_destroy_response (response);\n  return ret;\n}",
      "lines": 44,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        75,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "int\nmain (int argc, char *const *argv)\n{\n  struct MHD_Daemon *d;\n\n  if (argc != 2)\n    {\n      printf (\"%s PORT\\n\", argv[0]);\n      return 1;\n    }\n  d = MHD_start_daemon (MHD_USE_THREAD_PER_CONNECTION | MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_ERROR_LOG,\n                        atoi (argv[1]),\n                        NULL, NULL, &ahc_echo, PAGE, MHD_OPTION_END);\n  if (d == NULL)\n    return 1;\n  (void) getc (stdin);\n  MHD_stop_daemon (d);\n  return 0;\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/examples/refuse_post_example.c": {
    "ahc_echo": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        81,
        1
      ],
      "content": "static int\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data, size_t *upload_data_size, void **ptr)\n{\n  static int aptr;\n  const char *me = cls;\n  struct MHD_Response *response;\n  int ret;\n  (void)cls;               /* Unused. Silent compiler warning. */\n  (void)url;               /* Unused. Silent compiler warning. */\n  (void)version;           /* Unused. Silent compiler warning. */\n  (void)upload_data;       /* Unused. Silent compiler warning. */\n  (void)upload_data_size;  /* Unused. Silent compiler warning. */\n\n  if ((0 != strcmp (method, \"GET\")) && (0 != strcmp (method, \"POST\")))\n    return MHD_NO;              /* unexpected method */\n\n  if (&aptr != *ptr)\n    {\n      *ptr = &aptr;\n\n      /* always to busy for POST requests */\n      if (0 == strcmp (method, \"POST\"))\n        {\n          response = MHD_create_response_from_buffer (strlen (BUSYPAGE),\n\t\t\t\t\t\t      (void *) BUSYPAGE, \n\t\t\t\t\t\t      MHD_RESPMEM_PERSISTENT);\n          ret =\n            MHD_queue_response (connection, MHD_HTTP_SERVICE_UNAVAILABLE,\n                                response);\n          MHD_destroy_response (response);\n          return ret;\n        }\n    }\n\n  *ptr = NULL;                  /* reset when done */\n  response = MHD_create_response_from_buffer (strlen (me),\n\t\t\t\t\t      (void *) me,\n\t\t\t\t\t      MHD_RESPMEM_PERSISTENT);\n  ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n  MHD_destroy_response (response);\n  return ret;\n}",
      "lines": 47,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        83,
        0
      ],
      "end_point": [
        102,
        1
      ],
      "content": "int\nmain (int argc, char *const *argv)\n{\n  struct MHD_Daemon *d;\n\n  if (argc != 2)\n    {\n      printf (\"%s PORT\\n\", argv[0]);\n      return 1;\n    }\n  d = MHD_start_daemon (MHD_USE_THREAD_PER_CONNECTION | MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_ERROR_LOG,\n                        atoi (argv[1]),\n                        NULL, NULL, &ahc_echo, (void *) askpage,\n                        MHD_OPTION_END);\n  if (d == NULL)\n    return 1;\n  (void) getc (stdin);\n  MHD_stop_daemon (d);\n  return 0;\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/examples/timeout.c": {
    "answer_to_connection": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        63,
        1
      ],
      "content": "static int\nanswer_to_connection(void *cls,\n                     struct MHD_Connection *connection,\n                     const char *url,\n                     const char *method,\n                     const char *version,\n                     const char *upload_data,\n                     size_t *upload_data_size,\n                     void **con_cls)\n{\n  const char *page = \"<html><body>Hello timeout!</body></html>\";\n  struct MHD_Response *response;\n  int ret;\n  (void)cls;               /* Unused. Silent compiler warning. */\n  (void)url;               /* Unused. Silent compiler warning. */\n  (void)version;           /* Unused. Silent compiler warning. */\n  (void)method;            /* Unused. Silent compiler warning. */\n  (void)upload_data;       /* Unused. Silent compiler warning. */\n  (void)upload_data_size;  /* Unused. Silent compiler warning. */\n  (void)con_cls;           /* Unused. Silent compiler warning. */\n\n  response = MHD_create_response_from_buffer (strlen(page),\n                                              (void *) page,\n                                              MHD_RESPMEM_PERSISTENT);\n  MHD_add_response_header (response,\n                           MHD_HTTP_HEADER_CONTENT_TYPE,\n                           \"text/html\");\n  ret = MHD_queue_response (connection,\n                            MHD_HTTP_OK,\n                            response);\n  MHD_destroy_response(response);\n  return ret;\n}",
      "lines": 33,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        83,
        1
      ],
      "content": "int\nmain (void)\n{\n  struct MHD_Daemon *daemon;\n\n  daemon = MHD_start_daemon (MHD_USE_THREAD_PER_CONNECTION | MHD_USE_INTERNAL_POLLING_THREAD,\n                             PORT,\n                             NULL, NULL,\n                             &answer_to_connection, NULL,\n                             /* 3 seconds */\n                             MHD_OPTION_CONNECTION_TIMEOUT, (unsigned int) 3,\n                             MHD_OPTION_END);\n  if (NULL == daemon)\n    return 1;\n  getchar();\n  MHD_stop_daemon(daemon);\n  return 0;\n}",
      "lines": 18,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/examples/upgrade_example.c": {
    "make_blocking": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "static void\nmake_blocking (MHD_socket fd)\n{\n#if defined(MHD_POSIX_SOCKETS)\n  int flags;\n\n  flags = fcntl (fd, F_GETFL);\n  if (-1 == flags)\n    return;\n  if ((flags & ~O_NONBLOCK) != flags)\n    if (-1 == fcntl (fd, F_SETFL, flags & ~O_NONBLOCK))\n      abort ();\n#elif defined(MHD_WINSOCK_SOCKETS)\n  unsigned long flags = 1;\n\n  ioctlsocket (fd, FIONBIO, &flags);\n#endif /* MHD_WINSOCK_SOCKETS */\n\n}",
      "lines": 19,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "send_all": {
      "start_point": [
        64,
        0
      ],
      "end_point": [
        91,
        1
      ],
      "content": "static void\nsend_all (MHD_socket sock,\n          const char *buf,\n          size_t len)\n{\n  ssize_t ret;\n  size_t off;\n\n  make_blocking (sock);\n  for (off = 0; off < len; off += ret)\n    {\n      ret = send (sock,\n                  &buf[off],\n                  len - off,\n                  0);\n      if (0 > ret)\n        {\n          if (EAGAIN == errno)\n            {\n              ret = 0;\n              continue;\n            }\n          break;\n        }\n      if (0 == ret)\n        break;\n    }\n}",
      "lines": 28,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "run_usock": {
      "start_point": [
        109,
        0
      ],
      "end_point": [
        143,
        1
      ],
      "content": "static void *\nrun_usock (void *cls)\n{\n  struct MyData *md = cls;\n  struct MHD_UpgradeResponseHandle *urh = md->urh;\n  char buf[128];\n  ssize_t got;\n\n  make_blocking (md->sock);\n  /* start by sending extra data MHD may have already read, if any */\n  if (0 != md->extra_in_size)\n    {\n      send_all (md->sock,\n                md->extra_in,\n                md->extra_in_size);\n      free (md->extra_in);\n    }\n  /* now echo in a loop */\n  while (1)\n    {\n      got = recv (md->sock,\n                  buf,\n                  sizeof (buf),\n                  0);\n      if (0 >= got)\n        break;\n      send_all (md->sock,\n                buf,\n                got);\n    }\n  free (md);\n  MHD_upgrade_action (urh,\n                      MHD_UPGRADE_ACTION_CLOSE);\n  return NULL;\n}",
      "lines": 35,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nrun_usock (void *cls)",
        "*"
      ]
    },
    "uh_cb": {
      "start_point": [
        193,
        0
      ],
      "end_point": [
        238,
        1
      ],
      "content": "static void\nuh_cb (void *cls,\n       struct MHD_Connection *connection,\n       void *con_cls,\n       const char *extra_in,\n       size_t extra_in_size,\n       MHD_socket sock,\n       struct MHD_UpgradeResponseHandle *urh)\n{\n  struct MyData *md;\n  pthread_t pt;\n  (void)cls;         /* Unused. Silent compiler warning. */\n  (void)connection;  /* Unused. Silent compiler warning. */\n  (void)con_cls;     /* Unused. Silent compiler warning. */\n\n  md = malloc (sizeof (struct MyData));\n  if (NULL == md)\n    abort ();\n  memset (md, 0, sizeof (struct MyData));\n  if (0 != extra_in_size)\n    {\n      md->extra_in = malloc (extra_in_size);\n      if (NULL == md->extra_in)\n        abort ();\n      memcpy (md->extra_in,\n              extra_in,\n              extra_in_size);\n    }\n  md->extra_in_size = extra_in_size;\n  md->sock = sock;\n  md->urh = urh;\n  if (0 != pthread_create (&pt,\n                           NULL,\n                           &run_usock,\n                           md))\n    abort ();\n  /* Note that by detaching like this we make it impossible to ensure\n     a clean shutdown, as the we stop the daemon even if a worker thread\n     is still running. Alas, this is a simple example... */\n  pthread_detach (pt);\n\n  /* This callback must return as soon as possible. */\n\n  /* Data forwarding to \"upgraded\" socket will be started\n   * after return from this callback. */\n}",
      "lines": 46,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "ahc_echo": {
      "start_point": [
        241,
        0
      ],
      "end_point": [
        280,
        1
      ],
      "content": "static int\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data,\n          size_t *upload_data_size,\n          void **ptr)\n{\n  static int aptr;\n  struct MHD_Response *response;\n  int ret;\n  (void)cls;               /* Unused. Silent compiler warning. */\n  (void)url;               /* Unused. Silent compiler warning. */\n  (void)version;           /* Unused. Silent compiler warning. */\n  (void)upload_data;       /* Unused. Silent compiler warning. */\n  (void)upload_data_size;  /* Unused. Silent compiler warning. */\n\n  if (0 != strcmp (method, \"GET\"))\n    return MHD_NO;              /* unexpected method */\n  if (&aptr != *ptr)\n    {\n      /* do never respond on first call */\n      *ptr = &aptr;\n      return MHD_YES;\n    }\n  *ptr = NULL;                  /* reset when done */\n  response = MHD_create_response_for_upgrade (&uh_cb,\n                                              NULL);\n\n  MHD_add_response_header (response,\n                           MHD_HTTP_HEADER_UPGRADE,\n                           \"Echo Server\");\n  ret = MHD_queue_response (connection,\n                            MHD_HTTP_SWITCHING_PROTOCOLS,\n                            response);\n  MHD_destroy_response (response);\n  return ret;\n}",
      "lines": 40,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        283,
        0
      ],
      "end_point": [
        305,
        1
      ],
      "content": "int\nmain (int argc,\n      char *const *argv)\n{\n  struct MHD_Daemon *d;\n\n  if (argc != 2)\n    {\n      printf (\"%s PORT\\n\", argv[0]);\n      return 1;\n    }\n  d = MHD_start_daemon (MHD_ALLOW_UPGRADE | MHD_USE_AUTO | MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_ERROR_LOG,\n                        atoi (argv[1]),\n                        NULL, NULL,\n                        &ahc_echo, NULL,\n\t\t\tMHD_OPTION_CONNECTION_TIMEOUT, (unsigned int) 120,\n\t\t\tMHD_OPTION_END);\n  if (d == NULL)\n    return 1;\n  (void) getc (stdin);\n  MHD_stop_daemon (d);\n  return 0;\n}",
      "lines": 23,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/include/autoinit_funcs.h": {},
  "libmicrohttpd/libmicrohttpd-0.9.59/src/include/mhd_options.h": {},
  "libmicrohttpd/libmicrohttpd-0.9.59/src/include/microhttpd.h": {},
  "libmicrohttpd/libmicrohttpd-0.9.59/src/include/platform.h": {},
  "libmicrohttpd/libmicrohttpd-0.9.59/src/microhttpd/base64.c": {
    "BASE64Decode": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "char *\nBASE64Decode(const char* src)\n{\n  size_t in_len = strlen (src);\n  char* dest;\n  char* result;\n\n  if (in_len % 4)\n    {\n      /* Wrong base64 string length */\n      return NULL;\n    }\n  result = dest = malloc(in_len / 4 * 3 + 1);\n  if (NULL == result)\n    return NULL; /* out of memory */\n  while (*src) {\n    char a = base64_digits[(unsigned char)*(src++)];\n    char b = base64_digits[(unsigned char)*(src++)];\n    char c = base64_digits[(unsigned char)*(src++)];\n    char d = base64_digits[(unsigned char)*(src++)];\n    *(dest++) = (a << 2) | ((b & 0x30) >> 4);\n    if (c == (char)-1)\n      break;\n    *(dest++) = ((b & 0x0f) << 4) | ((c & 0x3c) >> 2);\n    if (d == (char)-1)\n      break;\n    *(dest++) = ((c & 0x03) << 6) | d;\n  }\n  *dest = 0;\n  return result;\n}",
      "lines": 31,
      "depth": 12,
      "decorators": [
        "char",
        "*\nBASE64Decode(const char* src)",
        "*"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/microhttpd/base64.h": {},
  "libmicrohttpd/libmicrohttpd-0.9.59/src/microhttpd/basicauth.c": {
    "MHD_basic_auth_get_username_password": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "char *\nMHD_basic_auth_get_username_password (struct MHD_Connection *connection,\n\t\t\t\t      char** password)\n{\n  const char *header;\n  char *decode;\n  const char *separator;\n  char *user;\n\n  if ( (NULL == (header = MHD_lookup_connection_value (connection,\n\t\t\t\t\t\t       MHD_HEADER_KIND,\n\t\t\t\t\t\t       MHD_HTTP_HEADER_AUTHORIZATION))) ||\n       (0 != strncmp (header,\n                      _BASIC_BASE,\n                      MHD_STATICSTR_LEN_ (_BASIC_BASE))) )\n    return NULL;\n  header += MHD_STATICSTR_LEN_ (_BASIC_BASE);\n  if (NULL == (decode = BASE64Decode (header)))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (connection->daemon,\n\t\t_(\"Error decoding basic authentication\\n\"));\n#endif\n      return NULL;\n    }\n  /* Find user:password pattern */\n  if (NULL == (separator = strchr (decode,\n                                   ':')))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG(connection->daemon,\n\t       _(\"Basic authentication doesn't contain ':' separator\\n\"));\n#endif\n      free (decode);\n      return NULL;\n    }\n  if (NULL == (user = strdup (decode)))\n    {\n      free (decode);\n      return NULL;\n    }\n  user[separator - decode] = '\\0'; /* cut off at ':' */\n  if (NULL != password)\n    {\n      *password = strdup (separator + 1);\n      if (NULL == *password)\n\t{\n#ifdef HAVE_MESSAGES\n\t  MHD_DLOG(connection->daemon,\n\t\t   _(\"Failed to allocate memory for password\\n\"));\n#endif\n\t  free (decode);\n\t  free (user);\n\t  return NULL;\n\t}\n    }\n  free (decode);\n  return user;\n}",
      "lines": 59,
      "depth": 14,
      "decorators": [
        "char",
        "*\nMHD_basic_auth_get_username_password (struct MHD_Connection *connection,\n\t\t\t\t      char** password)",
        "*"
      ]
    },
    "MHD_queue_basic_auth_fail_response": {
      "start_point": [
        118,
        0
      ],
      "end_point": [
        161,
        1
      ],
      "content": "int\nMHD_queue_basic_auth_fail_response (struct MHD_Connection *connection,\n\t\t\t\t    const char *realm,\n\t\t\t\t    struct MHD_Response *response)\n{\n  int ret;\n  int res;\n  size_t hlen = strlen(realm) + strlen(\"Basic realm=\\\"\\\"\") + 1;\n  char *header;\n\n  header = (char *) malloc(hlen);\n  if (NULL == header)\n  {\n#ifdef HAVE_MESSAGES\n    MHD_DLOG(connection->daemon,\n\t\t   \"Failed to allocate memory for auth header\\n\");\n#endif /* HAVE_MESSAGES */\n    return MHD_NO;\n  }\n  res = MHD_snprintf_ (header,\n                       hlen,\n                       \"Basic realm=\\\"%s\\\"\",\n                       realm);\n  if (res > 0 && (size_t)res < hlen)\n    ret = MHD_add_response_header (response,\n                                   MHD_HTTP_HEADER_WWW_AUTHENTICATE,\n                                   header);\n  else\n    ret = MHD_NO;\n\n  free(header);\n  if (MHD_YES == ret)\n    ret = MHD_queue_response (connection,\n\t\t\t      MHD_HTTP_UNAUTHORIZED,\n\t\t\t      response);\n  else\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (connection->daemon,\n                _(\"Failed to add Basic auth header\\n\"));\n#endif /* HAVE_MESSAGES */\n    }\n  return ret;\n}",
      "lines": 44,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/microhttpd/connection.c": {
    "MHD_conn_init_static_": {
      "start_point": [
        144,
        0
      ],
      "end_point": [
        165,
        1
      ],
      "content": "void\nMHD_conn_init_static_ (void)\n{\n/* FreeBSD 11 and later allow to specify read-ahead size\n * and handles SF_NODISKIO differently.\n * SF_FLAGS defined only on FreeBSD 11 and later. */\n#ifdef SF_FLAGS\n  long sys_page_size = sysconf (_SC_PAGESIZE);\n  if (0 > sys_page_size)\n    { /* Failed to get page size. */\n      freebsd_sendfile_flags_ = SF_NODISKIO;\n      freebsd_sendfile_flags_thd_p_c_ = SF_NODISKIO;\n    }\n  else\n    {\n      freebsd_sendfile_flags_ =\n          SF_FLAGS((uint16_t)(MHD_SENFILE_CHUNK_ / sys_page_size), SF_NODISKIO);\n      freebsd_sendfile_flags_thd_p_c_ =\n          SF_FLAGS((uint16_t)(MHD_SENFILE_CHUNK_THR_P_C_ / sys_page_size), SF_NODISKIO);\n    }\n#endif /* SF_FLAGS */\n}",
      "lines": 22,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "recv_param_adapter": {
      "start_point": [
        176,
        0
      ],
      "end_point": [
        217,
        1
      ],
      "content": "static ssize_t\nrecv_param_adapter (struct MHD_Connection *connection,\n                    void *other,\n                    size_t i)\n{\n  ssize_t ret;\n\n  if ( (MHD_INVALID_SOCKET == connection->socket_fd) ||\n       (MHD_CONNECTION_CLOSED == connection->state) )\n    {\n      return MHD_ERR_NOTCONN_;\n    }\n  if (i > MHD_SCKT_SEND_MAX_SIZE_)\n    i = MHD_SCKT_SEND_MAX_SIZE_; /* return value limit */\n\n  ret = MHD_recv_ (connection->socket_fd,\n                   other,\n                   i);\n  if (0 > ret)\n    {\n      const int err = MHD_socket_get_error_ ();\n      if (MHD_SCKT_ERR_IS_EAGAIN_ (err))\n        {\n#ifdef EPOLL_SUPPORT\n          /* Got EAGAIN --- no longer read-ready */\n          connection->epoll_state &= ~MHD_EPOLL_STATE_READ_READY;\n#endif /* EPOLL_SUPPORT */\n          return MHD_ERR_AGAIN_;\n        }\n      if (MHD_SCKT_ERR_IS_EINTR_ (err))\n        return MHD_ERR_AGAIN_;\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_ECONNRESET_))\n        return MHD_ERR_CONNRESET_;\n      /* Treat any other error as hard error. */\n      return MHD_ERR_NOTCONN_;\n    }\n#ifdef EPOLL_SUPPORT\n  else if (i > (size_t)ret)\n    connection->epoll_state &= ~MHD_EPOLL_STATE_READ_READY;\n#endif /* EPOLL_SUPPORT */\n  return ret;\n}",
      "lines": 42,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "ssize_t"
      ]
    },
    "send_param_adapter": {
      "start_point": [
        229,
        0
      ],
      "end_point": [
        271,
        1
      ],
      "content": "static ssize_t\nsend_param_adapter (struct MHD_Connection *connection,\n                    const void *other,\n                    size_t i)\n{\n  ssize_t ret;\n\n  if ( (MHD_INVALID_SOCKET == connection->socket_fd) ||\n       (MHD_CONNECTION_CLOSED == connection->state) )\n    {\n      return MHD_ERR_NOTCONN_;\n    }\n  if (i > MHD_SCKT_SEND_MAX_SIZE_)\n    i = MHD_SCKT_SEND_MAX_SIZE_; /* return value limit */\n\n  ret = MHD_send_ (connection->socket_fd,\n                   other,\n                   i);\n  if (0 > ret)\n    {\n      const int err = MHD_socket_get_error_();\n\n      if (MHD_SCKT_ERR_IS_EAGAIN_(err))\n        {\n#ifdef EPOLL_SUPPORT\n          /* EAGAIN --- no longer write-ready */\n          connection->epoll_state &= ~MHD_EPOLL_STATE_WRITE_READY;\n#endif /* EPOLL_SUPPORT */\n          return MHD_ERR_AGAIN_;\n        }\n      if (MHD_SCKT_ERR_IS_EINTR_ (err))\n        return MHD_ERR_AGAIN_;\n      if (MHD_SCKT_ERR_IS_ (err, MHD_SCKT_ECONNRESET_))\n        return MHD_ERR_CONNRESET_;\n      /* Treat any other error as hard error. */\n      return MHD_ERR_NOTCONN_;\n    }\n#ifdef EPOLL_SUPPORT\n  else if (i > (size_t)ret)\n    connection->epoll_state &= ~MHD_EPOLL_STATE_WRITE_READY;\n#endif /* EPOLL_SUPPORT */\n  return ret;\n}",
      "lines": 43,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "ssize_t"
      ]
    },
    "sendfile_adapter": {
      "start_point": [
        281,
        0
      ],
      "end_point": [
        451,
        1
      ],
      "content": "static ssize_t\nsendfile_adapter (struct MHD_Connection *connection)\n{\n  ssize_t ret;\n  const int file_fd = connection->response->fd;\n  uint64_t left;\n  uint64_t offsetu64;\n#ifndef HAVE_SENDFILE64\n  const uint64_t max_off_t = (uint64_t)OFF_T_MAX;\n#else  /* HAVE_SENDFILE64 */\n  const uint64_t max_off_t = (uint64_t)OFF64_T_MAX;\n#endif /* HAVE_SENDFILE64 */\n#ifdef MHD_LINUX_SOLARIS_SENDFILE\n#ifndef HAVE_SENDFILE64\n  off_t offset;\n#else  /* HAVE_SENDFILE64 */\n  off64_t offset;\n#endif /* HAVE_SENDFILE64 */\n#endif /* MHD_LINUX_SOLARIS_SENDFILE */\n#ifdef HAVE_FREEBSD_SENDFILE\n  off_t sent_bytes;\n  int flags = 0;\n#endif\n#ifdef HAVE_DARWIN_SENDFILE\n  off_t len;\n#endif /* HAVE_DARWIN_SENDFILE */\n  const bool used_thr_p_c = (0 != (connection->daemon->options & MHD_USE_THREAD_PER_CONNECTION));\n  const size_t chunk_size = used_thr_p_c ? MHD_SENFILE_CHUNK_THR_P_C_ : MHD_SENFILE_CHUNK_;\n  size_t send_size = 0;\n  mhd_assert (MHD_resp_sender_sendfile == connection->resp_sender);\n\n  offsetu64 = connection->response_write_position + connection->response->fd_off;\n  left = connection->response->total_size - connection->response_write_position;\n  /* Do not allow system to stick sending on single fast connection:\n   * use 128KiB chunks (2MiB for thread-per-connection). */\n  send_size = (left > chunk_size) ? chunk_size : (size_t) left;\n  if (max_off_t < offsetu64)\n    { /* Retry to send with standard 'send()'. */\n      connection->resp_sender = MHD_resp_sender_std;\n      return MHD_ERR_AGAIN_;\n    }\n#ifdef MHD_LINUX_SOLARIS_SENDFILE\n#ifndef HAVE_SENDFILE64\n  offset = (off_t) offsetu64;\n  ret = sendfile (connection->socket_fd,\n                  file_fd,\n                  &offset,\n                  send_size);\n#else  /* HAVE_SENDFILE64 */\n  offset = (off64_t) offsetu64;\n  ret = sendfile64 (connection->socket_fd,\n                    file_fd,\n                    &offset,\n                    send_size);\n#endif /* HAVE_SENDFILE64 */\n  if (0 > ret)\n    {\n      const int err = MHD_socket_get_error_();\n      if (MHD_SCKT_ERR_IS_EAGAIN_(err))\n        {\n#ifdef EPOLL_SUPPORT\n          /* EAGAIN --- no longer write-ready */\n          connection->epoll_state &= ~MHD_EPOLL_STATE_WRITE_READY;\n#endif /* EPOLL_SUPPORT */\n          return MHD_ERR_AGAIN_;\n        }\n      if (MHD_SCKT_ERR_IS_EINTR_ (err))\n        return MHD_ERR_AGAIN_;\n#ifdef HAVE_LINUX_SENDFILE\n      if (MHD_SCKT_ERR_IS_(err,\n                           MHD_SCKT_EBADF_))\n        return MHD_ERR_BADF_;\n      /* sendfile() failed with EINVAL if mmap()-like operations are not\n         supported for FD or other 'unusual' errors occurred, so we should try\n         to fall back to 'SEND'; see also this thread for info on\n         odd libc/Linux behavior with sendfile:\n         http://lists.gnu.org/archive/html/libmicrohttpd/2011-02/msg00015.html */\n      connection->resp_sender = MHD_resp_sender_std;\n      return MHD_ERR_AGAIN_;\n#else  /* HAVE_SOLARIS_SENDFILE */\n      if ( (EAFNOSUPPORT == err) ||\n           (EINVAL == err) ||\n           (EOPNOTSUPP == err) )\n        { /* Retry with standard file reader. */\n          connection->resp_sender = MHD_resp_sender_std;\n          return MHD_ERR_AGAIN_;\n        }\n      if ( (ENOTCONN == err) ||\n           (EPIPE == err) )\n        {\n          return MHD_ERR_CONNRESET_;\n        }\n      return MHD_ERR_BADF_; /* Fail hard */\n#endif /* HAVE_SOLARIS_SENDFILE */\n    }\n#ifdef EPOLL_SUPPORT\n  else if (send_size > (size_t)ret)\n        connection->epoll_state &= ~MHD_EPOLL_STATE_WRITE_READY;\n#endif /* EPOLL_SUPPORT */\n#elif defined(HAVE_FREEBSD_SENDFILE)\n#ifdef SF_FLAGS\n  flags = used_thr_p_c ?\n      freebsd_sendfile_flags_thd_p_c_ : freebsd_sendfile_flags_;\n#endif /* SF_FLAGS */\n  if (0 != sendfile (file_fd,\n                     connection->socket_fd,\n                     (off_t) offsetu64,\n                     send_size,\n                     NULL,\n                     &sent_bytes,\n                     flags))\n    {\n      const int err = MHD_socket_get_error_();\n      if (MHD_SCKT_ERR_IS_EAGAIN_(err) ||\n          MHD_SCKT_ERR_IS_EINTR_(err) ||\n          EBUSY == err)\n        {\n          mhd_assert (SSIZE_MAX >= sent_bytes);\n          if (0 != sent_bytes)\n            return (ssize_t)sent_bytes;\n\n          return MHD_ERR_AGAIN_;\n        }\n      /* Some unrecoverable error. Possibly file FD is not suitable\n       * for sendfile(). Retry with standard send(). */\n      connection->resp_sender = MHD_resp_sender_std;\n      return MHD_ERR_AGAIN_;\n    }\n  mhd_assert (0 < sent_bytes);\n  mhd_assert (SSIZE_MAX >= sent_bytes);\n  ret = (ssize_t)sent_bytes;\n#elif defined(HAVE_DARWIN_SENDFILE)\n  len = (off_t)send_size; /* chunk always fit */\n  if (0 != sendfile (file_fd,\n                     connection->socket_fd,\n                     (off_t) offsetu64,\n                     &len,\n                     NULL,\n                     0))\n    {\n      const int err = MHD_socket_get_error_();\n      if (MHD_SCKT_ERR_IS_EAGAIN_(err) ||\n          MHD_SCKT_ERR_IS_EINTR_(err))\n        {\n          mhd_assert (0 <= len);\n          mhd_assert (SSIZE_MAX >= len);\n          mhd_assert (send_size >= (size_t)len);\n          if (0 != len)\n            return (ssize_t)len;\n\n          return MHD_ERR_AGAIN_;\n        }\n      if (ENOTCONN == err ||\n          EPIPE == err)\n        return MHD_ERR_CONNRESET_;\n      if (ENOTSUP == err ||\n          EOPNOTSUPP == err)\n        { /* This file FD is not suitable for sendfile().\n           * Retry with standard send(). */\n          connection->resp_sender = MHD_resp_sender_std;\n          return MHD_ERR_AGAIN_;\n        }\n      return MHD_ERR_BADF_; /* Return hard error. */\n    }\n  mhd_assert (0 <= len);\n  mhd_assert (SSIZE_MAX >= len);\n  mhd_assert (send_size >= (size_t)len);\n  ret = (ssize_t)len;\n#endif /* HAVE_FREEBSD_SENDFILE */\n  return ret;\n}",
      "lines": 171,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "ssize_t"
      ]
    },
    "socket_flush_possible": {
      "start_point": [
        474,
        0
      ],
      "end_point": [
        483,
        1
      ],
      "content": "static int\nsocket_flush_possible(struct MHD_Connection *connection)\n{\n  (void)connection; /* Mute compiler warning. */\n#if defined(TCP_CORK) || defined(TCP_PUSH)\n  return MHD_YES;\n#else  /* !TCP_CORK && !TCP_PUSH */\n  return MHD_NO;\n#endif /* !TCP_CORK && !TCP_PUSH */\n}",
      "lines": 10,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "socket_start_extra_buffering": {
      "start_point": [
        493,
        0
      ],
      "end_point": [
        543,
        1
      ],
      "content": "static int\nsocket_start_extra_buffering (struct MHD_Connection *connection)\n{\n  int res = MHD_NO;\n  (void)connection; /* Mute compiler warning. */\n#if defined(TCP_CORK) || defined(TCP_NOPUSH)\n  const MHD_SCKT_OPT_BOOL_ on_val = 1;\n#if defined(TCP_NODELAY)\n  const MHD_SCKT_OPT_BOOL_ off_val = 0;\n#endif /* TCP_NODELAY */\n  mhd_assert(NULL != connection);\n#if defined(TCP_NOPUSH) && !defined(TCP_CORK)\n  /* Buffer data before sending */\n  res = (0 == setsockopt (connection->socket_fd,\n                          IPPROTO_TCP,\n                          TCP_NOPUSH,\n                          (const void *) &on_val,\n                          sizeof (on_val)))\n    ? MHD_YES : MHD_NO;\n#if defined(TCP_NODELAY)\n  /* Enable Nagle's algorithm */\n  /* TCP_NODELAY may interfere with TCP_NOPUSH */\n  res &= (0 == setsockopt (connection->socket_fd,\n                           IPPROTO_TCP,\n                           TCP_NODELAY,\n                           (const void *) &off_val,\n                           sizeof (off_val)))\n    ? MHD_YES : MHD_NO;\n#endif /* TCP_NODELAY */\n#else /* TCP_CORK */\n#if defined(TCP_NODELAY)\n  /* Enable Nagle's algorithm */\n  /* TCP_NODELAY may prevent enabling TCP_CORK. Resulting buffering mode depends\n     solely on TCP_CORK result, so ignoring return code here. */\n  (void) setsockopt (connection->socket_fd,\n                     IPPROTO_TCP,\n                     TCP_NODELAY,\n                     (const void *) &off_val,\n                     sizeof (off_val));\n#endif /* TCP_NODELAY */\n  /* Send only full packets */\n  res = (0 == setsockopt (connection->socket_fd,\n                          IPPROTO_TCP,\n                          TCP_CORK,\n                          (const void *) &on_val,\n                          sizeof (on_val)))\n    ? MHD_YES : MHD_NO;\n#endif /* TCP_CORK */\n#endif /* TCP_CORK || TCP_NOPUSH */\n  return res;\n}",
      "lines": 51,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "socket_start_no_buffering": {
      "start_point": [
        552,
        0
      ],
      "end_point": [
        595,
        1
      ],
      "content": "static int\nsocket_start_no_buffering (struct MHD_Connection *connection)\n{\n#if defined(TCP_NODELAY)\n  int res = MHD_YES;\n  const MHD_SCKT_OPT_BOOL_ on_val = 1;\n#if defined(TCP_CORK) || defined(TCP_NOPUSH)\n  const MHD_SCKT_OPT_BOOL_ off_val = 0;\n#endif /* TCP_CORK || TCP_NOPUSH */\n\n  (void)connection; /* Mute compiler warning. */\n  mhd_assert(NULL != connection);\n#if defined(TCP_CORK)\n  /* Allow partial packets */\n  res &= (0 == setsockopt (connection->socket_fd,\n                           IPPROTO_TCP,\n                           TCP_CORK,\n                           (const void *) &off_val,\n                           sizeof (off_val)))\n    ? MHD_YES : MHD_NO;\n#endif /* TCP_CORK */\n#if defined(TCP_NODELAY)\n  /* Disable Nagle's algorithm for sending packets without delay */\n  res &= (0 == setsockopt (connection->socket_fd,\n                           IPPROTO_TCP,\n                           TCP_NODELAY,\n                           (const void *) &on_val,\n                           sizeof (on_val)))\n    ? MHD_YES : MHD_NO;\n#endif /* TCP_NODELAY */\n#if defined(TCP_NOPUSH) && !defined(TCP_CORK)\n  /* Disable extra buffering */\n  res &= (0 == setsockopt (connection->socket_fd,\n                           IPPROTO_TCP,\n                           TCP_NOPUSH,\n                           (const void *) &off_val,\n                           sizeof (off_val)))\n    ? MHD_YES : MHD_NO;\n#endif /* TCP_NOPUSH  && !TCP_CORK */\n  return res;\n#else  /* !TCP_NODELAY */\n  return MHD_NO;\n#endif /* !TCP_NODELAY */\n}",
      "lines": 44,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "socket_start_no_buffering_flush": {
      "start_point": [
        605,
        0
      ],
      "end_point": [
        626,
        1
      ],
      "content": "static int\nsocket_start_no_buffering_flush (struct MHD_Connection *connection)\n{\n  int res = MHD_YES;\n#if defined(TCP_NOPUSH) && !defined(TCP_CORK)\n  const int dummy = 0;\n#endif /* !TCP_CORK */\n\n  if (NULL == connection)\n    return MHD_NO;\n  res = socket_start_no_buffering (connection);\n#if defined(TCP_NOPUSH) && !defined(TCP_CORK)\n  /* Force flush data with zero send otherwise Darwin and some BSD systems\n     will add 5 seconds delay. Not required with TCP_CORK as switching off\n     TCP_CORK always flushes socket buffer. */\n  res &= (0 <= MHD_send_ (connection->socket_fd,\n                          &dummy,\n                          0))\n    ? MHD_YES : MHD_NO;\n#endif /* TCP_NOPUSH && !TCP_CORK*/\n  return res;\n}",
      "lines": 22,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "socket_start_normal_buffering": {
      "start_point": [
        635,
        0
      ],
      "end_point": [
        684,
        1
      ],
      "content": "static int\nsocket_start_normal_buffering (struct MHD_Connection *connection)\n{\n#if defined(TCP_NODELAY)\n  int res = MHD_YES;\n  const MHD_SCKT_OPT_BOOL_ off_val = 0;\n#if defined(TCP_CORK)\n  MHD_SCKT_OPT_BOOL_ cork_val = 0;\n  socklen_t param_size = sizeof (cork_val);\n#endif /* TCP_CORK */\n  mhd_assert(NULL != connection);\n#if defined(TCP_CORK)\n  /* Allow partial packets */\n  /* Disabling TCP_CORK will flush partial packet even if TCP_CORK wasn't enabled before\n     so try to check current value of TCP_CORK to prevent unrequested flushing */\n  if ( (0 != getsockopt (connection->socket_fd,\n                         IPPROTO_TCP,\n                         TCP_CORK,\n                         (void*)&cork_val,\n                         &param_size)) ||\n       (0 != cork_val))\n    res &= (0 == setsockopt (connection->socket_fd,\n                             IPPROTO_TCP,\n                             TCP_CORK,\n                             (const void *) &off_val,\n                             sizeof (off_val)))\n      ? MHD_YES : MHD_NO;\n#elif defined(TCP_NOPUSH)\n  /* Disable extra buffering */\n  /* No need to check current value as disabling TCP_NOPUSH will not flush partial\n     packet if TCP_NOPUSH wasn't enabled before */\n  res &= (0 == setsockopt (connection->socket_fd,\n                           IPPROTO_TCP,\n                           TCP_NOPUSH,\n                           (const void *) &off_val,\n                           sizeof (off_val)))\n    ? MHD_YES : MHD_NO;\n#endif /* TCP_NOPUSH && !TCP_CORK */\n  /* Enable Nagle's algorithm for normal buffering */\n  res &= (0 == setsockopt (connection->socket_fd,\n                           IPPROTO_TCP,\n                           TCP_NODELAY,\n                           (const void *) &off_val,\n                           sizeof (off_val)))\n    ? MHD_YES : MHD_NO;\n  return res;\n#else  /* !TCP_NODELAY */\n  return MHD_NO;\n#endif /* !TCP_NODELAY */\n}",
      "lines": 50,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "MHD_get_connection_values": {
      "start_point": [
        698,
        0
      ],
      "end_point": [
        722,
        1
      ],
      "content": "int\nMHD_get_connection_values (struct MHD_Connection *connection,\n                           enum MHD_ValueKind kind,\n                           MHD_KeyValueIterator iterator,\n                           void *iterator_cls)\n{\n  int ret;\n  struct MHD_HTTP_Header *pos;\n\n  if (NULL == connection)\n    return -1;\n  ret = 0;\n  for (pos = connection->headers_received; NULL != pos; pos = pos->next)\n    if (0 != (pos->kind & kind))\n      {\n\tret++;\n\tif ( (NULL != iterator) &&\n             (MHD_YES != iterator (iterator_cls,\n                                   pos->kind,\n                                   pos->header,\n                                   pos->value)) )\n\t  return ret;\n      }\n  return ret;\n}",
      "lines": 25,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "MHD_set_connection_value": {
      "start_point": [
        750,
        0
      ],
      "end_point": [
        779,
        1
      ],
      "content": "int\nMHD_set_connection_value (struct MHD_Connection *connection,\n                          enum MHD_ValueKind kind,\n                          const char *key,\n                          const char *value)\n{\n  struct MHD_HTTP_Header *pos;\n\n  pos = MHD_pool_allocate (connection->pool,\n                           sizeof (struct MHD_HTTP_Header),\n                           MHD_YES);\n  if (NULL == pos)\n    return MHD_NO;\n  pos->header = (char *) key;\n  pos->value = (char *) value;\n  pos->kind = kind;\n  pos->next = NULL;\n  /* append 'pos' to the linked list of headers */\n  if (NULL == connection->headers_received_tail)\n    {\n      connection->headers_received = pos;\n      connection->headers_received_tail = pos;\n    }\n  else\n    {\n      connection->headers_received_tail->next = pos;\n      connection->headers_received_tail = pos;\n    }\n  return MHD_YES;\n}",
      "lines": 30,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "MHD_lookup_connection_value": {
      "start_point": [
        792,
        0
      ],
      "end_point": [
        810,
        1
      ],
      "content": "const char *\nMHD_lookup_connection_value (struct MHD_Connection *connection,\n                             enum MHD_ValueKind kind,\n                             const char *key)\n{\n  struct MHD_HTTP_Header *pos;\n\n  if (NULL == connection)\n    return NULL;\n  for (pos = connection->headers_received; NULL != pos; pos = pos->next)\n    if ((0 != (pos->kind & kind)) &&\n\t( (key == pos->header) ||\n\t  ( (NULL != pos->header) &&\n\t    (NULL != key) &&\n        (MHD_str_equal_caseless_(key,\n                                 pos->header)))))\n      return pos->value;\n  return NULL;\n}",
      "lines": 19,
      "depth": 15,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nMHD_lookup_connection_value (struct MHD_Connection *connection,\n                             enum MHD_ValueKind kind,\n                             const char *key)",
        "*"
      ]
    },
    "MHD_lookup_header_token_ci": {
      "start_point": [
        826,
        0
      ],
      "end_point": [
        846,
        1
      ],
      "content": "static bool\nMHD_lookup_header_token_ci (const struct MHD_Connection *connection,\n                         const char *header,\n                         const char *token,\n                         size_t token_len)\n{\n  struct MHD_HTTP_Header *pos;\n\n  if (NULL == connection || NULL == header || 0 == header[0] || NULL == token || 0 == token[0])\n    return false;\n  for (pos = connection->headers_received; NULL != pos; pos = pos->next)\n    {\n      if ((0 != (pos->kind & MHD_HEADER_KIND)) &&\n          ( (header == pos->header) ||\n            (MHD_str_equal_caseless_(header,\n                                      pos->header)) ) &&\n          (MHD_str_has_token_caseless_ (pos->value, token, token_len)))\n        return true;\n    }\n  return false;\n}",
      "lines": 21,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "need_100_continue": {
      "start_point": [
        871,
        0
      ],
      "end_point": [
        887,
        1
      ],
      "content": "static int\nneed_100_continue (struct MHD_Connection *connection)\n{\n  const char *expect;\n\n  return ( (NULL == connection->response) &&\n\t   (NULL != connection->version) &&\n       (MHD_str_equal_caseless_(connection->version,\n\t\t\t     MHD_HTTP_VERSION_1_1)) &&\n\t   (NULL != (expect = MHD_lookup_connection_value (connection,\n\t\t\t\t\t\t\t   MHD_HEADER_KIND,\n\t\t\t\t\t\t\t   MHD_HTTP_HEADER_EXPECT))) &&\n\t   (MHD_str_equal_caseless_(expect,\n                                    \"100-continue\")) &&\n\t   (connection->continue_message_write_offset <\n\t    MHD_STATICSTR_LEN_ (HTTP_100_CONTINUE)) );\n}",
      "lines": 17,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "MHD_connection_mark_closed_": {
      "start_point": [
        896,
        0
      ],
      "end_point": [
        922,
        1
      ],
      "content": "void\nMHD_connection_mark_closed_ (struct MHD_Connection *connection)\n{\n  const struct MHD_Daemon *daemon = connection->daemon;\n\n  connection->state = MHD_CONNECTION_CLOSED;\n  connection->event_loop_info = MHD_EVENT_LOOP_INFO_CLEANUP;\n  if (0 == (daemon->options & MHD_USE_TURBO))\n    {\n#ifdef HTTPS_SUPPORT\n      /* For TLS connection use shutdown of TLS layer\n       * and do not shutdown TCP socket. This give more\n       * chances to send TLS closure data to remote side.\n       * Closure of TLS layer will be interpreted by\n       * remote side as end of transmission. */\n      if (0 != (daemon->options & MHD_USE_TLS))\n        {\n          if (! MHD_tls_connection_shutdown(connection))\n            shutdown (connection->socket_fd,\n                      SHUT_WR);\n        }\n      else /* Combined with next 'shutdown()'. */\n#endif /* HTTPS_SUPPORT */\n      shutdown (connection->socket_fd,\n                SHUT_WR);\n    }\n}",
      "lines": 27,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "MHD_connection_close_": {
      "start_point": [
        934,
        0
      ],
      "end_point": [
        954,
        1
      ],
      "content": "void\nMHD_connection_close_ (struct MHD_Connection *connection,\n                       enum MHD_RequestTerminationCode termination_code)\n{\n  struct MHD_Daemon *daemon = connection->daemon;\n  struct MHD_Response *resp = connection->response;\n\n  MHD_connection_mark_closed_ (connection);\n  if (NULL != resp)\n    {\n      connection->response = NULL;\n      MHD_destroy_response (resp);\n    }\n  if ( (NULL != daemon->notify_completed) &&\n       (connection->client_aware) )\n    daemon->notify_completed (daemon->notify_completed_cls,\n\t\t\t      connection,\n\t\t\t      &connection->client_context,\n\t\t\t      termination_code);\n  connection->client_aware = false;\n}",
      "lines": 21,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "MHD_connection_finish_forward_": {
      "start_point": [
        968,
        0
      ],
      "end_point": [
        1019,
        1
      ],
      "content": "void\nMHD_connection_finish_forward_ (struct MHD_Connection *connection)\n{\n  struct MHD_Daemon *daemon = connection->daemon;\n  struct MHD_UpgradeResponseHandle *urh = connection->urh;\n\n  if (0 == (daemon->options & MHD_USE_TLS))\n    return; /* Nothing to do with non-TLS connection. */\n\n  if (0 == (daemon->options & MHD_USE_THREAD_PER_CONNECTION))\n    DLL_remove (daemon->urh_head,\n                daemon->urh_tail,\n                urh);\n#if EPOLL_SUPPORT\n  if ( (0 != (daemon->options & MHD_USE_EPOLL)) &&\n       (0 != epoll_ctl (daemon->epoll_upgrade_fd,\n                        EPOLL_CTL_DEL,\n                        connection->socket_fd,\n                        NULL)) )\n    {\n      MHD_PANIC (_(\"Failed to remove FD from epoll set\\n\"));\n    }\n  if (urh->in_eready_list)\n    {\n      EDLL_remove (daemon->eready_urh_head,\n\t\t   daemon->eready_urh_tail,\n\t\t   urh);\n      urh->in_eready_list = false;\n    }\n#endif /* EPOLL_SUPPORT */\n  if (MHD_INVALID_SOCKET != urh->mhd.socket)\n    {\n#if EPOLL_SUPPORT\n      if ( (0 != (daemon->options & MHD_USE_EPOLL)) &&\n           (0 != epoll_ctl (daemon->epoll_upgrade_fd,\n                            EPOLL_CTL_DEL,\n                            urh->mhd.socket,\n                            NULL)) )\n        {\n          MHD_PANIC (_(\"Failed to remove FD from epoll set\\n\"));\n        }\n#endif /* EPOLL_SUPPORT */\n      /* Reflect remote disconnect to application by breaking\n       * socketpair connection. */\n      shutdown (urh->mhd.socket, SHUT_RDWR);\n    }\n  /* Socketpair sockets will remain open as they will be\n   * used with MHD_UPGRADE_ACTION_CLOSE. They will be\n   * closed by MHD_cleanup_upgraded_connection_() during\n   * connection's final cleanup.\n   */\n}",
      "lines": 52,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "connection_close_error": {
      "start_point": [
        1030,
        0
      ],
      "end_point": [
        1043,
        1
      ],
      "content": "static void\nconnection_close_error (struct MHD_Connection *connection,\n\t\t\tconst char *emsg)\n{\n#ifdef HAVE_MESSAGES\n  if (NULL != emsg)\n    MHD_DLOG (connection->daemon,\n              emsg);\n#else  /* ! HAVE_MESSAGES */\n  (void)emsg; /* Mute compiler warning. */\n#endif /* ! HAVE_MESSAGES */\n  MHD_connection_close_ (connection,\n                         MHD_REQUEST_TERMINATED_WITH_ERROR);\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "try_ready_normal_body": {
      "start_point": [
        1069,
        0
      ],
      "end_point": [
        1123,
        1
      ],
      "content": "static int\ntry_ready_normal_body (struct MHD_Connection *connection)\n{\n  ssize_t ret;\n  struct MHD_Response *response;\n\n  response = connection->response;\n  if (NULL == response->crc)\n    return MHD_YES;\n  if ( (0 == response->total_size) ||\n       (connection->response_write_position == response->total_size) )\n    return MHD_YES; /* 0-byte response is always ready */\n  if ( (response->data_start <=\n\tconnection->response_write_position) &&\n       (response->data_size + response->data_start >\n\tconnection->response_write_position) )\n    return MHD_YES; /* response already ready */\n#if defined(_MHD_HAVE_SENDFILE)\n  if (MHD_resp_sender_sendfile == connection->resp_sender)\n    {\n      /* will use sendfile, no need to bother response crc */\n      return MHD_YES;\n    }\n#endif /* _MHD_HAVE_SENDFILE */\n\n  ret = response->crc (response->crc_cls,\n                       connection->response_write_position,\n                       response->data,\n                       (size_t) MHD_MIN ((uint64_t)response->data_buffer_size,\n                                         response->total_size -\n                                         connection->response_write_position));\n  if ( (((ssize_t) MHD_CONTENT_READER_END_OF_STREAM) == ret) ||\n       (((ssize_t) MHD_CONTENT_READER_END_WITH_ERROR) == ret) )\n    {\n      /* either error or http 1.0 transfer, close socket! */\n      response->total_size = connection->response_write_position;\n      MHD_mutex_unlock_chk_ (&response->mutex);\n      if ( ((ssize_t)MHD_CONTENT_READER_END_OF_STREAM) == ret)\n\tMHD_connection_close_ (connection,\n                               MHD_REQUEST_TERMINATED_COMPLETED_OK);\n      else\n\tCONNECTION_CLOSE_ERROR (connection,\n\t\t\t\t_(\"Closing connection (application reported error generating data)\\n\"));\n      return MHD_NO;\n    }\n  response->data_start = connection->response_write_position;\n  response->data_size = ret;\n  if (0 == ret)\n    {\n      connection->state = MHD_CONNECTION_NORMAL_BODY_UNREADY;\n      MHD_mutex_unlock_chk_ (&response->mutex);\n      return MHD_NO;\n    }\n  return MHD_YES;\n}",
      "lines": 55,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "try_ready_chunked_body": {
      "start_point": [
        1135,
        0
      ],
      "end_point": [
        1243,
        1
      ],
      "content": "static int\ntry_ready_chunked_body (struct MHD_Connection *connection)\n{\n  ssize_t ret;\n  char *buf;\n  struct MHD_Response *response;\n  size_t size;\n  char cbuf[10];                /* 10: max strlen of \"%x\\r\\n\" */\n  int cblen;\n\n  response = connection->response;\n  if (NULL == response->crc)\n    return MHD_YES;\n  if (0 == connection->write_buffer_size)\n    {\n      size = MHD_MIN (connection->daemon->pool_size,\n                      2 * (0xFFFFFF + sizeof(cbuf) + 2));\n      do\n        {\n          size /= 2;\n          if (size < 128)\n            {\n              MHD_mutex_unlock_chk_ (&response->mutex);\n              /* not enough memory */\n              CONNECTION_CLOSE_ERROR (connection,\n\t\t\t\t      _(\"Closing connection (out of memory)\\n\"));\n              return MHD_NO;\n            }\n          buf = MHD_pool_allocate (connection->pool,\n                                   size,\n                                   MHD_NO);\n        }\n      while (NULL == buf);\n      connection->write_buffer_size = size;\n      connection->write_buffer = buf;\n    }\n\n  if (0 == response->total_size)\n    ret = 0; /* response must be empty, don't bother calling crc */\n  else if ( (response->data_start <=\n\tconnection->response_write_position) &&\n       (response->data_start + response->data_size >\n\tconnection->response_write_position) )\n    {\n      /* difference between response_write_position and data_start is less\n         than data_size which is size_t type, no need to check for overflow */\n      const size_t data_write_offset\n        = (size_t)(connection->response_write_position - response->data_start);\n      /* buffer already ready, use what is there for the chunk */\n      ret = response->data_size - data_write_offset;\n      if ( ((size_t) ret) > connection->write_buffer_size - sizeof (cbuf) - 2 )\n\tret = connection->write_buffer_size - sizeof (cbuf) - 2;\n      memcpy (&connection->write_buffer[sizeof (cbuf)],\n              &response->data[data_write_offset],\n              ret);\n    }\n  else\n    {\n      /* buffer not in range, try to fill it */\n      ret = response->crc (response->crc_cls,\n                           connection->response_write_position,\n                           &connection->write_buffer[sizeof (cbuf)],\n                           connection->write_buffer_size - sizeof (cbuf) - 2);\n    }\n  if ( ((ssize_t) MHD_CONTENT_READER_END_WITH_ERROR) == ret)\n    {\n      /* error, close socket! */\n      response->total_size = connection->response_write_position;\n      MHD_mutex_unlock_chk_ (&response->mutex);\n      CONNECTION_CLOSE_ERROR (connection,\n\t\t\t      _(\"Closing connection (application error generating response)\\n\"));\n      return MHD_NO;\n    }\n  if ( (((ssize_t) MHD_CONTENT_READER_END_OF_STREAM) == ret) ||\n       (0 == response->total_size) )\n    {\n      /* end of message, signal other side! */\n      strcpy (connection->write_buffer,\n              \"0\\r\\n\");\n      connection->write_buffer_append_offset = 3;\n      connection->write_buffer_send_offset = 0;\n      response->total_size = connection->response_write_position;\n      return MHD_YES;\n    }\n  if (0 == ret)\n    {\n      connection->state = MHD_CONNECTION_CHUNKED_BODY_UNREADY;\n      MHD_mutex_unlock_chk_ (&response->mutex);\n      return MHD_NO;\n    }\n  if (ret > 0xFFFFFF)\n    ret = 0xFFFFFF;\n  cblen = MHD_snprintf_(cbuf,\n                        sizeof (cbuf),\n                        \"%X\\r\\n\",\n                        (unsigned int) ret);\n  mhd_assert(cblen > 0);\n  mhd_assert((size_t)cblen < sizeof(cbuf));\n  memcpy (&connection->write_buffer[sizeof (cbuf) - cblen],\n          cbuf,\n          cblen);\n  memcpy (&connection->write_buffer[sizeof (cbuf) + ret],\n          \"\\r\\n\",\n          2);\n  connection->response_write_position += ret;\n  connection->write_buffer_send_offset = sizeof (cbuf) - cblen;\n  connection->write_buffer_append_offset = sizeof (cbuf) + ret + 2;\n  return MHD_YES;\n}",
      "lines": 109,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "keepalive_possible": {
      "start_point": [
        1262,
        0
      ],
      "end_point": [
        1299,
        1
      ],
      "content": "static int\nkeepalive_possible (struct MHD_Connection *connection)\n{\n  if (MHD_CONN_MUST_CLOSE == connection->keepalive)\n    return MHD_NO;\n  if (NULL == connection->version)\n    return MHD_NO;\n  if ( (NULL != connection->response) &&\n       (0 != (connection->response->flags & MHD_RF_HTTP_VERSION_1_0_ONLY) ) )\n    return MHD_NO;\n\n  if (MHD_str_equal_caseless_(connection->version,\n                              MHD_HTTP_VERSION_1_1))\n    {\n      if (MHD_lookup_header_s_token_ci (connection,\n                                        MHD_HTTP_HEADER_CONNECTION,\n                                        \"upgrade\"))\n        return MHD_NO;\n\n      if (MHD_lookup_header_s_token_ci (connection,\n                                        MHD_HTTP_HEADER_CONNECTION,\n                                        \"close\"))\n        return MHD_NO;\n\n      return MHD_YES;\n    }\n  if (MHD_str_equal_caseless_(connection->version,\n                              MHD_HTTP_VERSION_1_0))\n    {\n      if (MHD_lookup_header_s_token_ci (connection,\n                                        MHD_HTTP_HEADER_CONNECTION,\n                                        \"Keep-Alive\"))\n        return MHD_YES;\n\n      return MHD_NO;\n    }\n  return MHD_NO;\n}",
      "lines": 38,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "get_date_string": {
      "start_point": [
        1309,
        0
      ],
      "end_point": [
        1356,
        1
      ],
      "content": "static void\nget_date_string (char *date,\n\t\t size_t date_len)\n{\n  static const char *const days[] = {\n    \"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"\n  };\n  static const char *const mons[] = {\n    \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n    \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"\n  };\n  struct tm now;\n  time_t t;\n#if !defined(HAVE_C11_GMTIME_S) && !defined(HAVE_W32_GMTIME_S) && !defined(HAVE_GMTIME_R)\n  struct tm* pNow;\n#endif\n\n  date[0] = 0;\n  time (&t);\n#if defined(HAVE_C11_GMTIME_S)\n  if (NULL == gmtime_s (&t,\n                        &now))\n    return;\n#elif defined(HAVE_W32_GMTIME_S)\n  if (0 != gmtime_s (&now,\n                     &t))\n    return;\n#elif defined(HAVE_GMTIME_R)\n  if (NULL == gmtime_r(&t,\n                       &now))\n    return;\n#else\n  pNow = gmtime(&t);\n  if (NULL == pNow)\n    return;\n  now = *pNow;\n#endif\n  MHD_snprintf_ (date,\n\t\t date_len,\n\t\t \"Date: %3s, %02u %3s %04u %02u:%02u:%02u GMT\\r\\n\",\n\t\t days[now.tm_wday % 7],\n\t\t (unsigned int) now.tm_mday,\n\t\t mons[now.tm_mon % 12],\n\t\t (unsigned int) (1900 + now.tm_year),\n\t\t (unsigned int) now.tm_hour,\n\t\t (unsigned int) now.tm_min,\n\t\t (unsigned int) now.tm_sec);\n}",
      "lines": 48,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "try_grow_read_buffer": {
      "start_point": [
        1369,
        0
      ],
      "end_point": [
        1389,
        1
      ],
      "content": "static int\ntry_grow_read_buffer (struct MHD_Connection *connection)\n{\n  void *buf;\n  size_t new_size;\n\n  if (0 == connection->read_buffer_size)\n    new_size = connection->daemon->pool_size / 2;\n  else\n    new_size = connection->read_buffer_size + MHD_BUF_INC_SIZE;\n  buf = MHD_pool_reallocate (connection->pool,\n                             connection->read_buffer,\n                             connection->read_buffer_size,\n                             new_size);\n  if (NULL == buf)\n    return MHD_NO;\n  /* we can actually grow the buffer, do it! */\n  connection->read_buffer = buf;\n  connection->read_buffer_size = new_size;\n  return MHD_YES;\n}",
      "lines": 21,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "build_header_response": {
      "start_point": [
        1401,
        0
      ],
      "end_point": [
        1734,
        1
      ],
      "content": "static int\nbuild_header_response (struct MHD_Connection *connection)\n{\n  size_t size;\n  size_t off;\n  struct MHD_HTTP_Header *pos;\n  char code[256];\n  char date[128];\n  char content_length_buf[128];\n  size_t content_length_len;\n  char *data;\n  enum MHD_ValueKind kind;\n  const char *reason_phrase;\n  uint32_t rc;\n  bool client_requested_close;\n  bool response_has_close;\n  bool response_has_keepalive;\n  const char *have_encoding;\n  const char *have_content_length;\n  int must_add_close;\n  int must_add_chunked_encoding;\n  int must_add_keep_alive;\n  int must_add_content_length;\n\n  mhd_assert (NULL != connection->version);\n  if (0 == connection->version[0])\n    {\n      data = MHD_pool_allocate (connection->pool,\n                                0,\n                                MHD_YES);\n      connection->write_buffer = data;\n      connection->write_buffer_append_offset = 0;\n      connection->write_buffer_send_offset = 0;\n      connection->write_buffer_size = 0;\n      return MHD_YES;\n    }\n  rc = connection->responseCode & (~MHD_ICY_FLAG);\n  if (MHD_CONNECTION_FOOTERS_RECEIVED == connection->state)\n    {\n      reason_phrase = MHD_get_reason_phrase_for (rc);\n      MHD_snprintf_ (code,\n\t\t     sizeof (code),\n\t\t     \"%s %u %s\\r\\n\",\n\t\t     (0 != (connection->responseCode & MHD_ICY_FLAG))\n\t\t     ? \"ICY\"\n\t\t     : ( (MHD_str_equal_caseless_ (MHD_HTTP_VERSION_1_0,\n\t\t\t\t\t\t   connection->version))\n\t\t\t ? MHD_HTTP_VERSION_1_0\n\t\t\t : MHD_HTTP_VERSION_1_1),\n\t\t     rc,\n\t\t     reason_phrase);\n      off = strlen (code);\n      /* estimate size */\n      size = off + 2;           /* +2 for extra \"\\r\\n\" at the end */\n      kind = MHD_HEADER_KIND;\n      if ( (0 == (connection->daemon->options & MHD_USE_SUPPRESS_DATE_NO_CLOCK)) &&\n\t   (NULL == MHD_get_response_header (connection->response,\n\t\t\t\t\t     MHD_HTTP_HEADER_DATE)) )\n        get_date_string (date,\n\t\t\t sizeof (date));\n      else\n        date[0] = '\\0';\n      size += strlen (date);\n    }\n  else\n    {\n      /* 2 bytes for final CRLF of a Chunked-Body */\n      size = 2;\n      kind = MHD_FOOTER_KIND;\n      off = 0;\n    }\n\n  /* calculate extra headers we need to add, such as 'Connection: close',\n     first see what was explicitly requested by the application */\n  must_add_close = MHD_NO;\n  must_add_chunked_encoding = MHD_NO;\n  must_add_keep_alive = MHD_NO;\n  must_add_content_length = MHD_NO;\n  response_has_close = false;\n  response_has_keepalive = false;\n  switch (connection->state)\n    {\n    case MHD_CONNECTION_FOOTERS_RECEIVED:\n      response_has_close = MHD_check_response_header_s_token_ci (connection->response,\n                                                                 MHD_HTTP_HEADER_CONNECTION,\n                                                                 \"close\");\n      response_has_keepalive = MHD_check_response_header_s_token_ci (connection->response,\n                                                                     MHD_HTTP_HEADER_CONNECTION,\n                                                                     \"Keep-Alive\");\n      client_requested_close = MHD_lookup_header_s_token_ci (connection,\n                                                            MHD_HTTP_HEADER_CONNECTION,\n                                                            \"close\");\n\n      if (0 != (connection->response->flags & MHD_RF_HTTP_VERSION_1_0_ONLY))\n        connection->keepalive = MHD_CONN_MUST_CLOSE;\n#ifdef UPGRADE_SUPPORT\n      else if (NULL != connection->response->upgrade_handler)\n        /* If this connection will not be \"upgraded\", it must be closed. */\n        connection->keepalive = MHD_CONN_MUST_CLOSE;\n#endif /* UPGRADE_SUPPORT */\n\n      /* now analyze chunked encoding situation */\n      connection->have_chunked_upload = false;\n\n      if ( (MHD_SIZE_UNKNOWN == connection->response->total_size) &&\n#ifdef UPGRADE_SUPPORT\n           (NULL == connection->response->upgrade_handler) &&\n#endif /* UPGRADE_SUPPORT */\n           (! response_has_close) &&\n           (! client_requested_close) )\n        {\n          /* size is unknown, and close was not explicitly requested;\n             need to either to HTTP 1.1 chunked encoding or\n             close the connection */\n          /* 'close' header doesn't exist yet, see if we need to add one;\n             if the client asked for a close, no need to start chunk'ing */\n          if ( (MHD_YES == keepalive_possible (connection)) &&\n               (MHD_str_equal_caseless_ (MHD_HTTP_VERSION_1_1,\n                                         connection->version) ) )\n            {\n              have_encoding = MHD_get_response_header (connection->response,\n                                                       MHD_HTTP_HEADER_TRANSFER_ENCODING);\n              if (NULL == have_encoding)\n                {\n                  must_add_chunked_encoding = MHD_YES;\n                  connection->have_chunked_upload = true;\n                }\n              else if (MHD_str_equal_caseless_ (have_encoding,\n                                                \"identity\"))\n                {\n                  /* application forced identity encoding, can't do 'chunked' */\n                  must_add_close = MHD_YES;\n                }\n              else\n                {\n                  connection->have_chunked_upload = true;\n                }\n            }\n          else\n            {\n              /* Keep alive or chunking not possible\n                 => set close header if not present */\n              if (! response_has_close)\n                must_add_close = MHD_YES;\n            }\n        }\n\n      /* check for other reasons to add 'close' header */\n      if ( ( (client_requested_close) ||\n             (connection->read_closed) ||\n             (MHD_CONN_MUST_CLOSE == connection->keepalive)) &&\n           (! response_has_close) &&\n#ifdef UPGRADE_SUPPORT\n           (NULL == connection->response->upgrade_handler) &&\n#endif /* UPGRADE_SUPPORT */\n           (0 == (connection->response->flags & MHD_RF_HTTP_VERSION_1_0_ONLY) ) )\n        must_add_close = MHD_YES;\n\n      /* check if we should add a 'content length' header */\n      have_content_length = MHD_get_response_header (connection->response,\n                                                     MHD_HTTP_HEADER_CONTENT_LENGTH);\n\n      /* MHD_HTTP_NO_CONTENT, MHD_HTTP_NOT_MODIFIED and 1xx-status\n         codes SHOULD NOT have a Content-Length according to spec;\n         also chunked encoding / unknown length or CONNECT... */\n      if ( (MHD_SIZE_UNKNOWN != connection->response->total_size) &&\n           (MHD_HTTP_NO_CONTENT != rc) &&\n           (MHD_HTTP_NOT_MODIFIED != rc) &&\n           (MHD_HTTP_OK <= rc) &&\n           (NULL == have_content_length) &&\n           ( (NULL == connection->method) ||\n             (! MHD_str_equal_caseless_ (connection->method,\n                                         MHD_HTTP_METHOD_CONNECT)) ) )\n        {\n          /*\n            Here we add a content-length if one is missing; however,\n            for 'connect' methods, the responses MUST NOT include a\n            content-length header *if* the response code is 2xx (in\n            which case we expect there to be no body).  Still,\n            as we don't know the response code here in some cases, we\n            simply only force adding a content-length header if this\n            is not a 'connect' or if the response is not empty\n            (which is kind of more sane, because if some crazy\n            application did return content with a 2xx status code,\n            then having a content-length might again be a good idea).\n\n            Note that the change from 'SHOULD NOT' to 'MUST NOT' is\n            a recent development of the HTTP 1.1 specification.\n          */\n          content_length_len\n            = MHD_snprintf_ (content_length_buf,\n\t\t\t     sizeof (content_length_buf),\n\t\t\t     MHD_HTTP_HEADER_CONTENT_LENGTH \": \" MHD_UNSIGNED_LONG_LONG_PRINTF \"\\r\\n\",\n\t\t\t     (MHD_UNSIGNED_LONG_LONG) connection->response->total_size);\n          must_add_content_length = MHD_YES;\n        }\n\n      /* check for adding keep alive */\n      if ( (! response_has_keepalive) &&\n           (! response_has_close) &&\n           (MHD_NO == must_add_close) &&\n           (MHD_CONN_MUST_CLOSE != connection->keepalive) &&\n#ifdef UPGRADE_SUPPORT\n           (NULL == connection->response->upgrade_handler) &&\n#endif /* UPGRADE_SUPPORT */\n           (MHD_YES == keepalive_possible (connection)) )\n        must_add_keep_alive = MHD_YES;\n      break;\n    case MHD_CONNECTION_BODY_SENT:\n      response_has_keepalive = false;\n      break;\n    default:\n      mhd_assert (0);\n    }\n\n  if (MHD_CONN_MUST_CLOSE != connection->keepalive)\n    {\n      if ( (must_add_close) || (response_has_close) )\n        connection->keepalive = MHD_CONN_MUST_CLOSE;\n      else if ( (must_add_keep_alive) || (response_has_keepalive) )\n        connection->keepalive = MHD_CONN_USE_KEEPALIVE;\n    }\n\n  if (must_add_close)\n    size += MHD_STATICSTR_LEN_ (\"Connection: close\\r\\n\");\n  if (must_add_keep_alive)\n    size += MHD_STATICSTR_LEN_ (\"Connection: Keep-Alive\\r\\n\");\n  if (must_add_chunked_encoding)\n    size += MHD_STATICSTR_LEN_ (\"Transfer-Encoding: chunked\\r\\n\");\n  if (must_add_content_length)\n    size += content_length_len;\n  mhd_assert (! (must_add_close && must_add_keep_alive) );\n  mhd_assert (! (must_add_chunked_encoding && must_add_content_length) );\n\n  for (pos = connection->response->first_header; NULL != pos; pos = pos->next)\n    {\n      /* TODO: add proper support for excluding \"Keep-Alive\" token. */\n      if ( (pos->kind == kind) &&\n           (! ( (MHD_YES == must_add_close) &&\n                (response_has_keepalive) &&\n                (MHD_str_equal_caseless_(pos->header,\n                                         MHD_HTTP_HEADER_CONNECTION)) &&\n                (MHD_str_equal_caseless_(pos->value,\n                                         \"Keep-Alive\")) ) ) )\n        size += strlen (pos->header) + strlen (pos->value) + 4; /* colon, space, linefeeds */\n    }\n  /* produce data */\n  data = MHD_pool_allocate (connection->pool,\n                            size + 1,\n                            MHD_NO);\n  if (NULL == data)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (connection->daemon,\n                \"Not enough memory for write!\\n\");\n#endif\n      return MHD_NO;\n    }\n  if (MHD_CONNECTION_FOOTERS_RECEIVED == connection->state)\n    {\n      memcpy (data,\n              code,\n              off);\n    }\n  if (must_add_close)\n    {\n      /* we must add the 'Connection: close' header */\n      memcpy (&data[off],\n              \"Connection: close\\r\\n\",\n              MHD_STATICSTR_LEN_ (\"Connection: close\\r\\n\"));\n      off += MHD_STATICSTR_LEN_ (\"Connection: close\\r\\n\");\n    }\n  if (must_add_keep_alive)\n    {\n      /* we must add the 'Connection: Keep-Alive' header */\n      memcpy (&data[off],\n              \"Connection: Keep-Alive\\r\\n\",\n              MHD_STATICSTR_LEN_ (\"Connection: Keep-Alive\\r\\n\"));\n      off += MHD_STATICSTR_LEN_ (\"Connection: Keep-Alive\\r\\n\");\n    }\n  if (must_add_chunked_encoding)\n    {\n      /* we must add the 'Transfer-Encoding: chunked' header */\n      memcpy (&data[off],\n              \"Transfer-Encoding: chunked\\r\\n\",\n              MHD_STATICSTR_LEN_ (\"Transfer-Encoding: chunked\\r\\n\"));\n      off += MHD_STATICSTR_LEN_ (\"Transfer-Encoding: chunked\\r\\n\");\n    }\n  if (must_add_content_length)\n    {\n      /* we must add the 'Content-Length' header */\n      memcpy (&data[off],\n              content_length_buf,\n\t      content_length_len);\n      off += content_length_len;\n    }\n  for (pos = connection->response->first_header; NULL != pos; pos = pos->next)\n    {\n      /* TODO: add proper support for excluding \"Keep-Alive\" token. */\n      if ( (pos->kind == kind) &&\n           (! ( (MHD_YES == must_add_close) &&\n                (response_has_keepalive) &&\n                (MHD_str_equal_caseless_(pos->header,\n                                         MHD_HTTP_HEADER_CONNECTION)) &&\n                (MHD_str_equal_caseless_(pos->value,\n                                         \"Keep-Alive\")) ) ) )\n        off += MHD_snprintf_ (&data[off],\n                              size - off,\n                              \"%s: %s\\r\\n\",\n                              pos->header,\n                              pos->value);\n    }\n  if (MHD_CONNECTION_FOOTERS_RECEIVED == connection->state)\n    {\n      strcpy (&data[off],\n              date);\n      off += strlen (date);\n    }\n  memcpy (&data[off],\n          \"\\r\\n\",\n          2);\n  off += 2;\n\n  if (off != size)\n    mhd_panic (mhd_panic_cls,\n               __FILE__,\n               __LINE__,\n               NULL);\n  connection->write_buffer = data;\n  connection->write_buffer_append_offset = size;\n  connection->write_buffer_send_offset = 0;\n  connection->write_buffer_size = size + 1;\n  return MHD_YES;\n}",
      "lines": 334,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "transmit_error_response": {
      "start_point": [
        1746,
        0
      ],
      "end_point": [
        1792,
        1
      ],
      "content": "static void\ntransmit_error_response (struct MHD_Connection *connection,\n                         unsigned int status_code,\n\t\t\t const char *message)\n{\n  struct MHD_Response *response;\n\n  if (NULL == connection->version)\n    {\n      /* we were unable to process the full header line, so we don't\n\t really know what version the client speaks; assume 1.0 */\n      connection->version = MHD_HTTP_VERSION_1_0;\n    }\n  connection->state = MHD_CONNECTION_FOOTERS_RECEIVED;\n  connection->read_closed = true;\n#ifdef HAVE_MESSAGES\n  MHD_DLOG (connection->daemon,\n            _(\"Error processing request (HTTP response code is %u (`%s')). Closing connection.\\n\"),\n            status_code,\n            message);\n#endif\n  if (NULL != connection->response)\n    {\n      MHD_destroy_response (connection->response);\n      connection->response = NULL;\n    }\n  response = MHD_create_response_from_buffer (strlen (message),\n\t\t\t\t\t      (void *) message,\n\t\t\t\t\t      MHD_RESPMEM_PERSISTENT);\n  MHD_queue_response (connection,\n                      status_code,\n                      response);\n  mhd_assert (NULL != connection->response);\n  MHD_destroy_response (response);\n  /* Do not reuse this connection. */\n  connection->keepalive = MHD_CONN_MUST_CLOSE;\n  if (MHD_NO == build_header_response (connection))\n    {\n      /* oops - close! */\n      CONNECTION_CLOSE_ERROR (connection,\n\t\t\t      _(\"Closing connection (failed to create response header)\\n\"));\n    }\n  else\n    {\n      connection->state = MHD_CONNECTION_HEADERS_SENDING;\n    }\n}",
      "lines": 47,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "MHD_connection_update_event_loop_info": {
      "start_point": [
        1803,
        0
      ],
      "end_point": [
        1958,
        1
      ],
      "content": "static void\nMHD_connection_update_event_loop_info (struct MHD_Connection *connection)\n{\n  /* Do not update states of suspended connection */\n  if (connection->suspended)\n    return; /* States will be updated after resume. */\n#ifdef HTTPS_SUPPORT\n  if (MHD_TLS_CONN_NO_TLS != connection->tls_state)\n    { /* HTTPS connection. */\n      switch (connection->tls_state)\n        {\n          case MHD_TLS_CONN_INIT:\n            connection->event_loop_info = MHD_EVENT_LOOP_INFO_READ;\n            return;\n          case MHD_TLS_CONN_HANDSHAKING:\n            if (0 == gnutls_record_get_direction (connection->tls_session))\n              connection->event_loop_info = MHD_EVENT_LOOP_INFO_READ;\n            else\n              connection->event_loop_info = MHD_EVENT_LOOP_INFO_WRITE;\n            return;\n          default:\n            break;\n        }\n    }\n#endif /* HTTPS_SUPPORT */\n  while (1)\n    {\n#if DEBUG_STATES\n      MHD_DLOG (connection->daemon,\n                _(\"In function %s handling connection at state: %s\\n\"),\n                __FUNCTION__,\n                MHD_state_to_string (connection->state));\n#endif\n      switch (connection->state)\n        {\n        case MHD_CONNECTION_INIT:\n        case MHD_CONNECTION_URL_RECEIVED:\n        case MHD_CONNECTION_HEADER_PART_RECEIVED:\n          /* while reading headers, we always grow the\n             read buffer if needed, no size-check required */\n          if ( (connection->read_buffer_offset == connection->read_buffer_size) &&\n\t       (MHD_NO == try_grow_read_buffer (connection)) )\n            {\n              transmit_error_response (connection,\n                                       (connection->url != NULL)\n                                       ? MHD_HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE\n                                       : MHD_HTTP_URI_TOO_LONG,\n                                       REQUEST_TOO_BIG);\n              continue;\n            }\n\t  if (! connection->read_closed)\n\t    connection->event_loop_info = MHD_EVENT_LOOP_INFO_READ;\n\t  else\n\t    connection->event_loop_info = MHD_EVENT_LOOP_INFO_BLOCK;\n          break;\n        case MHD_CONNECTION_HEADERS_RECEIVED:\n          mhd_assert (0);\n          break;\n        case MHD_CONNECTION_HEADERS_PROCESSED:\n          mhd_assert (0);\n          break;\n        case MHD_CONNECTION_CONTINUE_SENDING:\n          connection->event_loop_info = MHD_EVENT_LOOP_INFO_WRITE;\n          break;\n        case MHD_CONNECTION_CONTINUE_SENT:\n          if (connection->read_buffer_offset == connection->read_buffer_size)\n            {\n              if ((MHD_YES != try_grow_read_buffer (connection)) &&\n                  (0 != (connection->daemon->options &\n                         MHD_USE_INTERNAL_POLLING_THREAD)))\n                {\n                  /* failed to grow the read buffer, and the\n                     client which is supposed to handle the\n                     received data in a *blocking* fashion\n                     (in this mode) did not handle the data as\n                     it was supposed to!\n                     => we would either have to do busy-waiting\n                     (on the client, which would likely fail),\n                     or if we do nothing, we would just timeout\n                     on the connection (if a timeout is even\n                     set!).\n                     Solution: we kill the connection with an error */\n                  transmit_error_response (connection,\n                                           MHD_HTTP_INTERNAL_SERVER_ERROR,\n                                           INTERNAL_ERROR);\n                  continue;\n                }\n            }\n          if ( (connection->read_buffer_offset < connection->read_buffer_size) &&\n\t       (! connection->read_closed) )\n\t    connection->event_loop_info = MHD_EVENT_LOOP_INFO_READ;\n\t  else\n\t    connection->event_loop_info = MHD_EVENT_LOOP_INFO_BLOCK;\n          break;\n        case MHD_CONNECTION_BODY_RECEIVED:\n        case MHD_CONNECTION_FOOTER_PART_RECEIVED:\n          /* while reading footers, we always grow the\n             read buffer if needed, no size-check required */\n          if (connection->read_closed)\n            {\n\t      CONNECTION_CLOSE_ERROR (connection,\n\t\t\t\t      NULL);\n              continue;\n            }\n\t  connection->event_loop_info = MHD_EVENT_LOOP_INFO_READ;\n          /* transition to FOOTERS_RECEIVED\n             happens in read handler */\n          break;\n        case MHD_CONNECTION_FOOTERS_RECEIVED:\n\t  connection->event_loop_info = MHD_EVENT_LOOP_INFO_BLOCK;\n          break;\n        case MHD_CONNECTION_HEADERS_SENDING:\n          /* headers in buffer, keep writing */\n\t  connection->event_loop_info = MHD_EVENT_LOOP_INFO_WRITE;\n          break;\n        case MHD_CONNECTION_HEADERS_SENT:\n          mhd_assert (0);\n          break;\n        case MHD_CONNECTION_NORMAL_BODY_READY:\n\t  connection->event_loop_info = MHD_EVENT_LOOP_INFO_WRITE;\n          break;\n        case MHD_CONNECTION_NORMAL_BODY_UNREADY:\n\t  connection->event_loop_info = MHD_EVENT_LOOP_INFO_BLOCK;\n          break;\n        case MHD_CONNECTION_CHUNKED_BODY_READY:\n\t  connection->event_loop_info = MHD_EVENT_LOOP_INFO_WRITE;\n          break;\n        case MHD_CONNECTION_CHUNKED_BODY_UNREADY:\n\t  connection->event_loop_info = MHD_EVENT_LOOP_INFO_BLOCK;\n          break;\n        case MHD_CONNECTION_BODY_SENT:\n          mhd_assert (0);\n          break;\n        case MHD_CONNECTION_FOOTERS_SENDING:\n\t  connection->event_loop_info = MHD_EVENT_LOOP_INFO_WRITE;\n          break;\n        case MHD_CONNECTION_FOOTERS_SENT:\n          mhd_assert (0);\n          break;\n        case MHD_CONNECTION_CLOSED:\n\t  connection->event_loop_info = MHD_EVENT_LOOP_INFO_CLEANUP;\n          return;       /* do nothing, not even reading */\n        case MHD_CONNECTION_IN_CLEANUP:\n          mhd_assert (0);\n          break;\n#ifdef UPGRADE_SUPPORT\n        case MHD_CONNECTION_UPGRADE:\n          mhd_assert (0);\n          break;\n#endif /* UPGRADE_SUPPORT */\n        default:\n          mhd_assert (0);\n        }\n      break;\n    }\n}",
      "lines": 156,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "get_next_header_line": {
      "start_point": [
        1974,
        0
      ],
      "end_point": [
        2019,
        1
      ],
      "content": "static char *\nget_next_header_line (struct MHD_Connection *connection,\n                      size_t *line_len)\n{\n  char *rbuf;\n  size_t pos;\n\n  if (0 == connection->read_buffer_offset)\n    return NULL;\n  pos = 0;\n  rbuf = connection->read_buffer;\n  while ( (pos < connection->read_buffer_offset - 1) &&\n          ('\\r' != rbuf[pos]) &&\n          ('\\n' != rbuf[pos]) )\n    pos++;\n  if ( (pos == connection->read_buffer_offset - 1) &&\n       ('\\n' != rbuf[pos]) )\n    {\n      /* not found, consider growing... */\n      if ( (connection->read_buffer_offset == connection->read_buffer_size) &&\n\t   (MHD_NO ==\n\t    try_grow_read_buffer (connection)) )\n\t{\n\t  transmit_error_response (connection,\n\t\t\t\t   (NULL != connection->url)\n\t\t\t\t   ? MHD_HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE\n\t\t\t\t   : MHD_HTTP_URI_TOO_LONG,\n\t\t\t\t   REQUEST_TOO_BIG);\n\t}\n      if (line_len)\n        *line_len = 0;\n      return NULL;\n    }\n\n  if (line_len)\n    *line_len = pos;\n  /* found, check if we have proper LFCR */\n  if ( ('\\r' == rbuf[pos]) &&\n       ('\\n' == rbuf[pos + 1]) )\n    rbuf[pos++] = '\\0';         /* skip both r and n */\n  rbuf[pos++] = '\\0';\n  connection->read_buffer += pos;\n  connection->read_buffer_size -= pos;\n  connection->read_buffer_offset -= pos;\n  return rbuf;\n}",
      "lines": 46,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nget_next_header_line (struct MHD_Connection *connection,\n                      size_t *line_len)",
        "*"
      ]
    },
    "connection_add_header": {
      "start_point": [
        2033,
        0
      ],
      "end_point": [
        2055,
        1
      ],
      "content": "static int\nconnection_add_header (struct MHD_Connection *connection,\n                       const char *key,\n\t\t       const char *value,\n\t\t       enum MHD_ValueKind kind)\n{\n  if (MHD_NO ==\n      MHD_set_connection_value (connection,\n\t\t\t\tkind,\n\t\t\t\tkey,\n\t\t\t\tvalue))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (connection->daemon,\n                _(\"Not enough memory in pool to allocate header record!\\n\"));\n#endif\n      transmit_error_response (connection,\n                               MHD_HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE,\n                               REQUEST_TOO_BIG);\n      return MHD_NO;\n    }\n  return MHD_YES;\n}",
      "lines": 23,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "parse_cookie_header": {
      "start_point": [
        2064,
        0
      ],
      "end_point": [
        2167,
        1
      ],
      "content": "static int\nparse_cookie_header (struct MHD_Connection *connection)\n{\n  const char *hdr;\n  char *cpy;\n  char *pos;\n  char *sce;\n  char *semicolon;\n  char *equals;\n  char *ekill;\n  char old;\n  int quotes;\n\n  hdr = MHD_lookup_connection_value (connection,\n\t\t\t\t     MHD_HEADER_KIND,\n\t\t\t\t     MHD_HTTP_HEADER_COOKIE);\n  if (NULL == hdr)\n    return MHD_YES;\n  cpy = MHD_pool_allocate (connection->pool,\n                           strlen (hdr) + 1,\n                           MHD_YES);\n  if (NULL == cpy)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (connection->daemon,\n                _(\"Not enough memory in pool to parse cookies!\\n\"));\n#endif\n      transmit_error_response (connection,\n                               MHD_HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE,\n                               REQUEST_TOO_BIG);\n      return MHD_NO;\n    }\n  memcpy (cpy,\n          hdr,\n          strlen (hdr) + 1);\n  pos = cpy;\n  while (NULL != pos)\n    {\n      while (' ' == *pos)\n        pos++;                  /* skip spaces */\n\n      sce = pos;\n      while ( ((*sce) != '\\0') &&\n              ((*sce) != ',') &&\n              ((*sce) != ';') &&\n              ((*sce) != '=') )\n        sce++;\n      /* remove tailing whitespace (if any) from key */\n      ekill = sce - 1;\n      while ( (*ekill == ' ') &&\n              (ekill >= pos) )\n        *(ekill--) = '\\0';\n      old = *sce;\n      *sce = '\\0';\n      if (old != '=')\n        {\n          /* value part omitted, use empty string... */\n          if (MHD_NO ==\n              connection_add_header (connection,\n                                     pos,\n                                     \"\",\n                                     MHD_COOKIE_KIND))\n            return MHD_NO;\n          if (old == '\\0')\n            break;\n          pos = sce + 1;\n          continue;\n        }\n      equals = sce + 1;\n      quotes = 0;\n      semicolon = equals;\n      while ( ('\\0' != semicolon[0]) &&\n              ( (0 != quotes) ||\n                ( (';' != semicolon[0]) &&\n                  (',' != semicolon[0]) ) ) )\n        {\n          if ('\"' == semicolon[0])\n            quotes = (quotes + 1) & 1;\n          semicolon++;\n        }\n      if ('\\0' == semicolon[0])\n        semicolon = NULL;\n      if (NULL != semicolon)\n        {\n          semicolon[0] = '\\0';\n          semicolon++;\n        }\n      /* remove quotes */\n      if ( ('\"' == equals[0]) &&\n           ('\"' == equals[strlen (equals) - 1]) )\n        {\n          equals[strlen (equals) - 1] = '\\0';\n          equals++;\n        }\n      if (MHD_NO ==\n\t  connection_add_header (connection,\n\t\t\t\t pos,\n\t\t\t\t equals,\n\t\t\t\t MHD_COOKIE_KIND))\n        return MHD_NO;\n      pos = semicolon;\n    }\n  return MHD_YES;\n}",
      "lines": 104,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "parse_initial_message_line": {
      "start_point": [
        2178,
        0
      ],
      "end_point": [
        2263,
        1
      ],
      "content": "static int\nparse_initial_message_line (struct MHD_Connection *connection,\n                            char *line,\n                            size_t line_len)\n{\n  struct MHD_Daemon *daemon = connection->daemon;\n  const char *curi;\n  char *uri;\n  char *http_version;\n  char *args;\n  unsigned int unused_num_headers;\n\n  if (NULL == (uri = memchr (line,\n                             ' ',\n                             line_len)))\n    return MHD_NO;              /* serious error */\n  uri[0] = '\\0';\n  connection->method = line;\n  uri++;\n  /* Skip any spaces. Not required by standard but allow\n     to be more tolerant. */\n  while ( (' ' == uri[0]) &&\n          ( (size_t)(uri - line) < line_len) )\n    uri++;\n  if ((size_t)(uri - line) == line_len)\n    {\n      curi = \"\";\n      uri = NULL;\n      connection->version = \"\";\n      args = NULL;\n    }\n  else\n    {\n      curi = uri;\n      /* Search from back to accept misformed URI with space */\n      http_version = line + line_len - 1;\n      /* Skip any trailing spaces */\n      while ( (' ' == http_version[0]) &&\n              (http_version > uri) )\n        http_version--;\n      /* Find first space in reverse direction */\n      while ( (' ' != http_version[0]) &&\n              (http_version > uri) )\n        http_version--;\n      if (http_version > uri)\n        {\n          http_version[0] = '\\0';\n          connection->version = http_version + 1;\n          args = memchr (uri,\n                         '?',\n                         http_version - uri);\n        }\n      else\n        {\n          connection->version = \"\";\n          args = memchr (uri,\n                         '?',\n                         line_len - (uri - line));\n        }\n    }\n  if (NULL != daemon->uri_log_callback)\n    {\n      connection->client_aware = true;\n      connection->client_context\n        = daemon->uri_log_callback (daemon->uri_log_callback_cls,\n  \t\t\t\t    curi,\n                                    connection);\n    }\n  if (NULL != args)\n    {\n      args[0] = '\\0';\n      args++;\n      /* note that this call clobbers 'args' */\n      MHD_parse_arguments_ (connection,\n\t\t\t    MHD_GET_ARGUMENT_KIND,\n\t\t\t    args,\n\t\t\t    &connection_add_header,\n\t\t\t    &unused_num_headers);\n    }\n  if (NULL != uri)\n    daemon->unescape_callback (daemon->unescape_callback_cls,\n                               connection,\n                               uri);\n  connection->url = curi;\n  return MHD_YES;\n}",
      "lines": 86,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "call_connection_handler": {
      "start_point": [
        2273,
        0
      ],
      "end_point": [
        2297,
        1
      ],
      "content": "static void\ncall_connection_handler (struct MHD_Connection *connection)\n{\n  size_t processed;\n\n  if (NULL != connection->response)\n    return;                     /* already queued a response */\n  processed = 0;\n  connection->client_aware = true;\n  if (MHD_NO ==\n      connection->daemon->default_handler (connection->daemon->default_handler_cls,\n\t\t\t\t\t   connection,\n                                           connection->url,\n\t\t\t\t\t   connection->method,\n\t\t\t\t\t   connection->version,\n\t\t\t\t\t   NULL,\n                                           &processed,\n\t\t\t\t\t   &connection->client_context))\n    {\n      /* serious internal error, close connection */\n      CONNECTION_CLOSE_ERROR (connection,\n\t\t\t      _(\"Application reported internal error, closing connection.\\n\"));\n      return;\n    }\n}",
      "lines": 25,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "process_request_body": {
      "start_point": [
        2308,
        0
      ],
      "end_point": [
        2520,
        1
      ],
      "content": "static void\nprocess_request_body (struct MHD_Connection *connection)\n{\n  size_t available;\n  int instant_retry;\n  char *buffer_head;\n\n  if (NULL != connection->response)\n    return;                     /* already queued a response */\n\n  buffer_head = connection->read_buffer;\n  available = connection->read_buffer_offset;\n  do\n    {\n      size_t to_be_processed;\n      size_t left_unprocessed;\n      size_t processed_size;\n\n      instant_retry = MHD_NO;\n      if ( (connection->have_chunked_upload) &&\n           (MHD_SIZE_UNKNOWN == connection->remaining_upload_size) )\n        {\n          if ( (connection->current_chunk_offset == connection->current_chunk_size) &&\n               (0LLU != connection->current_chunk_offset) &&\n               (available >= 2) )\n            {\n              size_t i;\n              /* skip new line at the *end* of a chunk */\n              i = 0;\n              if ( ('\\r' == buffer_head[i]) ||\n                   ('\\n' == buffer_head[i]) )\n                i++;            /* skip 1st part of line feed */\n              if ( ('\\r' == buffer_head[i]) ||\n                   ('\\n' == buffer_head[i]) )\n                i++;            /* skip 2nd part of line feed */\n              if (0 == i)\n                {\n                  /* malformed encoding */\n                  CONNECTION_CLOSE_ERROR (connection,\n\t\t\t\t\t  _(\"Received malformed HTTP request (bad chunked encoding). Closing connection.\\n\"));\n                  return;\n                }\n              available -= i;\n              buffer_head += i;\n              connection->current_chunk_offset = 0;\n              connection->current_chunk_size = 0;\n            }\n          if (connection->current_chunk_offset <\n              connection->current_chunk_size)\n            {\n              uint64_t cur_chunk_left;\n              /* we are in the middle of a chunk, give\n                 as much as possible to the client (without\n                 crossing chunk boundaries) */\n              cur_chunk_left\n                = connection->current_chunk_size - connection->current_chunk_offset;\n              if (cur_chunk_left > available)\n                to_be_processed = available;\n              else\n                { /* cur_chunk_left <= (size_t)available */\n                  to_be_processed = (size_t)cur_chunk_left;\n                  if (available > to_be_processed)\n                    instant_retry = MHD_YES;\n                }\n            }\n          else\n            {\n              size_t i;\n              size_t end_size;\n              bool malformed;\n\n              /* we need to read chunk boundaries */\n              i = 0;\n              while (i < available)\n                {\n                  if ( ('\\r' == buffer_head[i]) ||\n                       ('\\n' == buffer_head[i]) ||\n\t\t       (';' == buffer_head[i]) )\n                    break;\n                  i++;\n                  if (i >= 16)\n                    break;\n                }\n\t      end_size = i;\n\t      /* find beginning of CRLF (skip over chunk extensions) */\n\t      if (';' == buffer_head[i])\n\t\t{\n\t\t  while (i < available)\n\t\t  {\n\t\t    if ( ('\\r' == buffer_head[i]) ||\n\t\t\t ('\\n' == buffer_head[i]) )\n\t\t      break;\n\t\t    i++;\n\t\t  }\n\t\t}\n              /* take '\\n' into account; if '\\n' is the unavailable\n                 character, we will need to wait until we have it\n                 before going further */\n              if ( (i + 1 >= available) &&\n                   ! ( (1 == i) &&\n                       (2 == available) &&\n                       ('0' == buffer_head[0]) ) )\n                break;          /* need more data... */\n\t      i++;\n              malformed = (end_size >= 16);\n              if (! malformed)\n                {\n                  size_t num_dig = MHD_strx_to_uint64_n_ (buffer_head,\n\t\t\t\t\t\t\t  end_size,\n\t\t\t\t\t\t\t  &connection->current_chunk_size);\n                  malformed = (end_size != num_dig);\n                }\n              if (malformed)\n                {\n                  /* malformed encoding */\n                  CONNECTION_CLOSE_ERROR (connection,\n\t\t\t\t\t  _(\"Received malformed HTTP request (bad chunked encoding). Closing connection.\\n\"));\n                  return;\n                }\n\t      /* skip 2nd part of line feed */\n              if ( (i < available) &&\n                   ( ('\\r' == buffer_head[i]) ||\n                     ('\\n' == buffer_head[i]) ) )\n                i++;\n\n              buffer_head += i;\n              available -= i;\n              connection->current_chunk_offset = 0;\n\n              if (available > 0)\n                instant_retry = MHD_YES;\n              if (0LLU == connection->current_chunk_size)\n                {\n                  connection->remaining_upload_size = 0;\n                  break;\n                }\n              continue;\n            }\n        }\n      else\n        {\n          /* no chunked encoding, give all to the client */\n          if ( (0 != connection->remaining_upload_size) &&\n\t       (MHD_SIZE_UNKNOWN != connection->remaining_upload_size) &&\n\t       (connection->remaining_upload_size < available) )\n\t    {\n              to_be_processed = (size_t)connection->remaining_upload_size;\n\t    }\n          else\n\t    {\n              /**\n               * 1. no chunked encoding, give all to the client\n               * 2. client may send large chunked data, but only a smaller part is available at one time.\n               */\n              to_be_processed = available;\n\t    }\n        }\n      left_unprocessed = to_be_processed;\n      connection->client_aware = true;\n      if (MHD_NO ==\n          connection->daemon->default_handler (connection->daemon->default_handler_cls,\n                                               connection,\n                                               connection->url,\n                                               connection->method,\n                                               connection->version,\n                                               buffer_head,\n                                               &left_unprocessed,\n                                               &connection->client_context))\n        {\n          /* serious internal error, close connection */\n          CONNECTION_CLOSE_ERROR (connection,\n                                  _(\"Application reported internal error, closing connection.\\n\"));\n          return;\n        }\n      if (left_unprocessed > to_be_processed)\n        mhd_panic (mhd_panic_cls,\n                   __FILE__,\n                   __LINE__\n#ifdef HAVE_MESSAGES\n\t\t   , _(\"libmicrohttpd API violation\")\n#else\n\t\t   , NULL\n#endif\n\t\t   );\n      if (0 != left_unprocessed)\n\t{\n\t  instant_retry = MHD_NO; /* client did not process everything */\n#ifdef HAVE_MESSAGES\n\t  /* client did not process all upload data, complain if\n\t     the setup was incorrect, which may prevent us from\n\t     handling the rest of the request */\n\t  if ( (0 != (connection->daemon->options & MHD_USE_INTERNAL_POLLING_THREAD)) &&\n\t       (! connection->suspended) )\n\t    MHD_DLOG (connection->daemon,\n\t\t      _(\"WARNING: incomplete upload processing and connection not suspended may result in hung connection.\\n\"));\n#endif\n\t}\n      processed_size = to_be_processed - left_unprocessed;\n      if (connection->have_chunked_upload)\n        connection->current_chunk_offset += processed_size;\n      /* dh left \"processed\" bytes in buffer for next time... */\n      buffer_head += processed_size;\n      available -= processed_size;\n      if (MHD_SIZE_UNKNOWN != connection->remaining_upload_size)\n        connection->remaining_upload_size -= processed_size;\n    }\n  while (MHD_YES == instant_retry);\n  if (available > 0)\n    memmove (connection->read_buffer,\n             buffer_head,\n             available);\n  connection->read_buffer_offset = available;\n}",
      "lines": 213,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "check_write_done": {
      "start_point": [
        2531,
        0
      ],
      "end_point": [
        2548,
        1
      ],
      "content": "static int\ncheck_write_done (struct MHD_Connection *connection,\n                  enum MHD_CONNECTION_STATE next_state)\n{\n  if (connection->write_buffer_append_offset !=\n      connection->write_buffer_send_offset)\n    return MHD_NO;\n  connection->write_buffer_append_offset = 0;\n  connection->write_buffer_send_offset = 0;\n  connection->state = next_state;\n  MHD_pool_reallocate (connection->pool,\n\t\t       connection->write_buffer,\n                       connection->write_buffer_size,\n                       0);\n  connection->write_buffer = NULL;\n  connection->write_buffer_size = 0;\n  return MHD_YES;\n}",
      "lines": 18,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "process_header_line": {
      "start_point": [
        2560,
        0
      ],
      "end_point": [
        2606,
        1
      ],
      "content": "static int\nprocess_header_line (struct MHD_Connection *connection,\n                     char *line)\n{\n  char *colon;\n\n  /* line should be normal header line, find colon */\n  colon = strchr (line, ':');\n  if (NULL == colon)\n    {\n      /* error in header line, die hard */\n      CONNECTION_CLOSE_ERROR (connection,\n\t\t\t      _(\"Received malformed line (no colon). Closing connection.\\n\"));\n      return MHD_NO;\n    }\n  if (-1 >= connection->daemon->strict_for_client)\n    {\n      /* check for whitespace before colon, which is not allowed\n\t by RFC 7230 section 3.2.4; we count space ' ' and\n\t tab '\\t', but not '\\r\\n' as those would have ended the line. */\n      const char *white;\n\n      white = strchr (line, ' ');\n      if ( (NULL != white) &&\n\t   (white < colon) )\n\treturn MHD_NO;\n      white = strchr (line, '\\t');\n      if ( (NULL != white) &&\n\t   (white < colon) )\n\treturn MHD_NO;\n    }\n  /* zero-terminate header */\n  colon[0] = '\\0';\n  colon++;                      /* advance to value */\n  while ( ('\\0' != colon[0]) &&\n          ( (' ' == colon[0]) ||\n            ('\\t' == colon[0]) ) )\n    colon++;\n  /* we do the actual adding of the connection\n     header at the beginning of the while\n     loop since we need to be able to inspect\n     the *next* header line (in case it starts\n     with a space...) */\n  connection->last = line;\n  connection->colon = colon;\n  return MHD_YES;\n}",
      "lines": 47,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "process_broken_line": {
      "start_point": [
        2619,
        0
      ],
      "end_point": [
        2691,
        1
      ],
      "content": "static int\nprocess_broken_line (struct MHD_Connection *connection,\n                     char *line,\n                     enum MHD_ValueKind kind)\n{\n  char *last;\n  char *tmp;\n  size_t last_len;\n  size_t tmp_len;\n\n  last = connection->last;\n  if ( (' ' == line[0]) ||\n       ('\\t' == line[0]) )\n    {\n      /* value was continued on the next line, see\n         http://www.jmarshall.com/easy/http/ */\n      last_len = strlen (last);\n      /* skip whitespace at start of 2nd line */\n      tmp = line;\n      while ( (' ' == tmp[0]) ||\n              ('\\t' == tmp[0]) )\n        tmp++;\n      tmp_len = strlen (tmp);\n      /* FIXME: we might be able to do this better (faster!), as most\n\t likely 'last' and 'line' should already be adjacent in\n\t memory; however, doing this right gets tricky if we have a\n\t value continued over multiple lines (in which case we need to\n\t record how often we have done this so we can check for\n\t adjacency); also, in the case where these are not adjacent\n\t (not sure how it can happen!), we would want to allocate from\n\t the end of the pool, so as to not destroy the read-buffer's\n\t ability to grow nicely. */\n      last = MHD_pool_reallocate (connection->pool,\n                                  last,\n                                  last_len + 1,\n                                  last_len + tmp_len + 1);\n      if (NULL == last)\n        {\n          transmit_error_response (connection,\n                                   MHD_HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE,\n                                   REQUEST_TOO_BIG);\n          return MHD_NO;\n        }\n      memcpy (&last[last_len], tmp, tmp_len + 1);\n      connection->last = last;\n      return MHD_YES;           /* possibly more than 2 lines... */\n    }\n  mhd_assert ( (NULL != last) &&\n                (NULL != connection->colon) );\n  if ((MHD_NO == connection_add_header (connection,\n                                        last,\n\t\t\t\t\tconnection->colon,\n\t\t\t\t\tkind)))\n    {\n      transmit_error_response (connection,\n                               MHD_HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE,\n                               REQUEST_TOO_BIG);\n      return MHD_NO;\n    }\n  /* we still have the current line to deal with... */\n  if (0 != line[0])\n    {\n      if (MHD_NO == process_header_line (connection,\n                                         line))\n        {\n          transmit_error_response (connection,\n                                   MHD_HTTP_BAD_REQUEST,\n                                   REQUEST_MALFORMED);\n          return MHD_NO;\n        }\n    }\n  return MHD_YES;\n}",
      "lines": 73,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "parse_connection_headers": {
      "start_point": [
        2701,
        0
      ],
      "end_point": [
        2772,
        1
      ],
      "content": "static void\nparse_connection_headers (struct MHD_Connection *connection)\n{\n  const char *clen;\n  struct MHD_Response *response;\n  const char *enc;\n  const char *end;\n\n  parse_cookie_header (connection);\n  if ( (1 <= connection->daemon->strict_for_client) &&\n       (NULL != connection->version) &&\n       (MHD_str_equal_caseless_(MHD_HTTP_VERSION_1_1,\n                                connection->version)) &&\n       (NULL ==\n        MHD_lookup_connection_value (connection,\n                                     MHD_HEADER_KIND,\n                                     MHD_HTTP_HEADER_HOST)) )\n    {\n      /* die, http 1.1 request without host and we are pedantic */\n      connection->state = MHD_CONNECTION_FOOTERS_RECEIVED;\n      connection->read_closed = true;\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (connection->daemon,\n                _(\"Received HTTP 1.1 request without `Host' header.\\n\"));\n#endif\n      mhd_assert (NULL == connection->response);\n      response =\n        MHD_create_response_from_buffer (MHD_STATICSTR_LEN_ (REQUEST_LACKS_HOST),\n\t\t\t\t\t REQUEST_LACKS_HOST,\n\t\t\t\t\t MHD_RESPMEM_PERSISTENT);\n      MHD_queue_response (connection,\n                          MHD_HTTP_BAD_REQUEST,\n                          response);\n      MHD_destroy_response (response);\n      return;\n    }\n\n  connection->remaining_upload_size = 0;\n  enc = MHD_lookup_connection_value (connection,\n\t\t\t\t     MHD_HEADER_KIND,\n\t\t\t\t     MHD_HTTP_HEADER_TRANSFER_ENCODING);\n  if (NULL != enc)\n    {\n      connection->remaining_upload_size = MHD_SIZE_UNKNOWN;\n      if (MHD_str_equal_caseless_(enc,\n                                  \"chunked\"))\n        connection->have_chunked_upload = true;\n    }\n  else\n    {\n      clen = MHD_lookup_connection_value (connection,\n\t\t\t\t\t  MHD_HEADER_KIND,\n\t\t\t\t\t  MHD_HTTP_HEADER_CONTENT_LENGTH);\n      if (NULL != clen)\n        {\n          end = clen + MHD_str_to_uint64_ (clen,\n                                           &connection->remaining_upload_size);\n          if ( (clen == end) ||\n               ('\\0' != *end) )\n            {\n              connection->remaining_upload_size = 0;\n#ifdef HAVE_MESSAGES\n              MHD_DLOG (connection->daemon,\n                        \"Failed to parse `Content-Length' header. Closing connection.\\n\");\n#endif\n\t      CONNECTION_CLOSE_ERROR (connection,\n                                      NULL);\n              return;\n            }\n        }\n    }\n}",
      "lines": 72,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "MHD_update_last_activity_": {
      "start_point": [
        2782,
        0
      ],
      "end_point": [
        2809,
        1
      ],
      "content": "void\nMHD_update_last_activity_ (struct MHD_Connection *connection)\n{\n  struct MHD_Daemon *daemon = connection->daemon;\n\n  if (0 == connection->connection_timeout)\n    return; /* Skip update of activity for connections\n               without timeout timer. */\n  if (connection->suspended)\n    return; /* no activity on suspended connections */\n\n  connection->last_activity = MHD_monotonic_sec_counter();\n  if (0 != (daemon->options & MHD_USE_THREAD_PER_CONNECTION))\n    return; /* each connection has personal timeout */\n\n  if (connection->connection_timeout != daemon->connection_timeout)\n    return; /* custom timeout, no need to move it in \"normal\" DLL */\n\n  MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n  /* move connection to head of timeout list (by remove + add operation) */\n  XDLL_remove (daemon->normal_timeout_head,\n\t       daemon->normal_timeout_tail,\n\t       connection);\n  XDLL_insert (daemon->normal_timeout_head,\n\t       daemon->normal_timeout_tail,\n\t       connection);\n  MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n}",
      "lines": 28,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "MHD_connection_handle_read": {
      "start_point": [
        2818,
        0
      ],
      "end_point": [
        2918,
        1
      ],
      "content": "void\nMHD_connection_handle_read (struct MHD_Connection *connection)\n{\n  ssize_t bytes_read;\n\n  if ( (MHD_CONNECTION_CLOSED == connection->state) ||\n       (connection->suspended) )\n    return;\n#ifdef HTTPS_SUPPORT\n  if (MHD_TLS_CONN_NO_TLS != connection->tls_state)\n    { /* HTTPS connection. */\n      if (MHD_TLS_CONN_CONNECTED > connection->tls_state)\n        {\n          if (!MHD_run_tls_handshake_ (connection))\n            return;\n        }\n    }\n#endif /* HTTPS_SUPPORT */\n\n  /* make sure \"read\" has a reasonable number of bytes\n     in buffer to use per system call (if possible) */\n  if (connection->read_buffer_offset + connection->daemon->pool_increment >\n      connection->read_buffer_size)\n    try_grow_read_buffer (connection);\n\n  if (connection->read_buffer_size == connection->read_buffer_offset)\n    return; /* No space for receiving data. */\n  bytes_read = connection->recv_cls (connection,\n                                     &connection->read_buffer\n                                     [connection->read_buffer_offset],\n                                     connection->read_buffer_size -\n                                     connection->read_buffer_offset);\n  if (bytes_read < 0)\n    {\n      if (MHD_ERR_AGAIN_ == bytes_read)\n          return; /* No new data to process. */\n      if (MHD_ERR_CONNRESET_ == bytes_read)\n        {\n           CONNECTION_CLOSE_ERROR (connection,\n                                   (MHD_CONNECTION_INIT == connection->state) ?\n                                     NULL :\n                                     _(\"Socket disconnected while reading request.\\n\"));\n           return;\n        }\n      CONNECTION_CLOSE_ERROR (connection,\n                              (MHD_CONNECTION_INIT == connection->state) ?\n                                NULL :\n                                _(\"Connection socket is closed due to error when reading request.\\n\"));\n      return;\n    }\n\n  if (0 == bytes_read)\n    { /* Remote side closed connection. */\n      connection->read_closed = true;\n      MHD_connection_close_ (connection,\n                             MHD_REQUEST_TERMINATED_CLIENT_ABORT);\n      return;\n    }\n  connection->read_buffer_offset += bytes_read;\n  MHD_update_last_activity_ (connection);\n#if DEBUG_STATES\n  MHD_DLOG (connection->daemon,\n            _(\"In function %s handling connection at state: %s\\n\"),\n            __FUNCTION__,\n            MHD_state_to_string (connection->state));\n#endif\n  switch (connection->state)\n    {\n    case MHD_CONNECTION_INIT:\n    case MHD_CONNECTION_URL_RECEIVED:\n    case MHD_CONNECTION_HEADER_PART_RECEIVED:\n    case MHD_CONNECTION_HEADERS_RECEIVED:\n    case MHD_CONNECTION_HEADERS_PROCESSED:\n    case MHD_CONNECTION_CONTINUE_SENDING:\n    case MHD_CONNECTION_CONTINUE_SENT:\n    case MHD_CONNECTION_BODY_RECEIVED:\n    case MHD_CONNECTION_FOOTER_PART_RECEIVED:\n      /* nothing to do but default action */\n      if (connection->read_closed)\n        {\n          MHD_connection_close_ (connection,\n                                 MHD_REQUEST_TERMINATED_READ_ERROR);\n        }\n      return;\n    case MHD_CONNECTION_CLOSED:\n      return;\n#ifdef UPGRADE_SUPPORT\n    case MHD_CONNECTION_UPGRADE:\n      mhd_assert (0);\n      return;\n#endif /* UPGRADE_SUPPORT */\n    default:\n      /* shrink read buffer to how much is actually used */\n      MHD_pool_reallocate (connection->pool,\n                           connection->read_buffer,\n                           connection->read_buffer_size + 1,\n                           connection->read_buffer_offset);\n      break;\n    }\n  return;\n}",
      "lines": 101,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "MHD_connection_handle_write": {
      "start_point": [
        2927,
        0
      ],
      "end_point": [
        3156,
        1
      ],
      "content": "void\nMHD_connection_handle_write (struct MHD_Connection *connection)\n{\n  struct MHD_Response *response;\n  ssize_t ret;\n  if (connection->suspended)\n    return;\n\n#ifdef HTTPS_SUPPORT\n  if (MHD_TLS_CONN_NO_TLS != connection->tls_state)\n    { /* HTTPS connection. */\n      if (MHD_TLS_CONN_CONNECTED > connection->tls_state)\n        {\n          if (!MHD_run_tls_handshake_ (connection))\n            return;\n        }\n    }\n#endif /* HTTPS_SUPPORT */\n\n#if DEBUG_STATES\n  MHD_DLOG (connection->daemon,\n            _(\"In function %s handling connection at state: %s\\n\"),\n            __FUNCTION__,\n            MHD_state_to_string (connection->state));\n#endif\n  switch (connection->state)\n    {\n    case MHD_CONNECTION_INIT:\n    case MHD_CONNECTION_URL_RECEIVED:\n    case MHD_CONNECTION_HEADER_PART_RECEIVED:\n    case MHD_CONNECTION_HEADERS_RECEIVED:\n      mhd_assert (0);\n      return;\n    case MHD_CONNECTION_HEADERS_PROCESSED:\n      return;\n    case MHD_CONNECTION_CONTINUE_SENDING:\n      ret = connection->send_cls (connection,\n                                  &HTTP_100_CONTINUE\n                                  [connection->continue_message_write_offset],\n                                  MHD_STATICSTR_LEN_ (HTTP_100_CONTINUE) -\n                                  connection->continue_message_write_offset);\n      if (ret < 0)\n        {\n          if (MHD_ERR_AGAIN_ == ret)\n            return;\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (connection->daemon,\n                    _(\"Failed to send data in request for %s.\\n\"),\n                    connection->url);\n#endif\n          CONNECTION_CLOSE_ERROR (connection,\n                                  NULL);\n          return;\n        }\n#if DEBUG_SEND_DATA\n      fprintf (stderr,\n               _(\"Sent 100 continue response: `%.*s'\\n\"),\n               (int) ret,\n               &HTTP_100_CONTINUE[connection->continue_message_write_offset]);\n#endif\n      connection->continue_message_write_offset += ret;\n      MHD_update_last_activity_ (connection);\n      return;\n    case MHD_CONNECTION_CONTINUE_SENT:\n    case MHD_CONNECTION_BODY_RECEIVED:\n    case MHD_CONNECTION_FOOTER_PART_RECEIVED:\n    case MHD_CONNECTION_FOOTERS_RECEIVED:\n      mhd_assert (0);\n      return;\n    case MHD_CONNECTION_HEADERS_SENDING:\n      ret = connection->send_cls (connection,\n                                  &connection->write_buffer\n                                  [connection->write_buffer_send_offset],\n                                  connection->write_buffer_append_offset -\n                                    connection->write_buffer_send_offset);\n      if (ret < 0)\n        {\n          if (MHD_ERR_AGAIN_ == ret)\n            return;\n          CONNECTION_CLOSE_ERROR (connection,\n                                  _(\"Connection was closed while sending response headers.\\n\"));\n          return;\n        }\n      connection->write_buffer_send_offset += ret;\n      MHD_update_last_activity_ (connection);\n      if (MHD_CONNECTION_HEADERS_SENDING != connection->state)\n        return;\n      check_write_done (connection,\n                        MHD_CONNECTION_HEADERS_SENT);\n      return;\n    case MHD_CONNECTION_HEADERS_SENT:\n      return;\n    case MHD_CONNECTION_NORMAL_BODY_READY:\n      response = connection->response;\n      if (connection->response_write_position <\n          connection->response->total_size)\n        {\n          uint64_t data_write_offset;\n\n          if (NULL != response->crc)\n            MHD_mutex_lock_chk_ (&response->mutex);\n          if (MHD_YES != try_ready_normal_body (connection))\n            {\n              /* mutex was already unlocked by try_ready_normal_body */\n              return;\n            }\n#if defined(_MHD_HAVE_SENDFILE)\n          if (MHD_resp_sender_sendfile == connection->resp_sender)\n            {\n              ret = sendfile_adapter (connection);\n            }\n          else\n#else  /* ! _MHD_HAVE_SENDFILE */\n          if (1)\n#endif /* ! _MHD_HAVE_SENDFILE */\n            {\n              data_write_offset = connection->response_write_position\n                                  - response->data_start;\n              if (data_write_offset > (uint64_t)SIZE_MAX)\n                MHD_PANIC (_(\"Data offset exceeds limit\"));\n              ret = connection->send_cls (connection,\n                                          &response->data\n                                          [(size_t)data_write_offset],\n                                          response->data_size -\n                                          (size_t)data_write_offset);\n#if DEBUG_SEND_DATA\n              if (ret > 0)\n                fprintf (stderr,\n                         _(\"Sent %d-byte DATA response: `%.*s'\\n\"),\n                         (int) ret,\n                         (int) ret,\n                         &response->data[connection->response_write_position -\n                                         response->data_start]);\n#endif\n            }\n          if (NULL != response->crc)\n            MHD_mutex_unlock_chk_ (&response->mutex);\n          if (ret < 0)\n            {\n              if (MHD_ERR_AGAIN_ == ret)\n                return;\n#ifdef HAVE_MESSAGES\n              MHD_DLOG (connection->daemon,\n                        _(\"Failed to send data in request for `%s'.\\n\"),\n                        connection->url);\n#endif\n              CONNECTION_CLOSE_ERROR (connection,\n                                      NULL);\n              return;\n            }\n          connection->response_write_position += ret;\n          MHD_update_last_activity_ (connection);\n        }\n      if (connection->response_write_position ==\n          connection->response->total_size)\n        connection->state = MHD_CONNECTION_FOOTERS_SENT; /* have no footers */\n      return;\n    case MHD_CONNECTION_NORMAL_BODY_UNREADY:\n      mhd_assert (0);\n      return;\n    case MHD_CONNECTION_CHUNKED_BODY_READY:\n      ret = connection->send_cls (connection,\n                                  &connection->write_buffer\n                                  [connection->write_buffer_send_offset],\n                                  connection->write_buffer_append_offset -\n                                    connection->write_buffer_send_offset);\n      if (ret < 0)\n        {\n          if (MHD_ERR_AGAIN_ == ret)\n            return;\n          CONNECTION_CLOSE_ERROR (connection,\n                                  _(\"Connection was closed while sending response body.\\n\"));\n          return;\n        }\n      connection->write_buffer_send_offset += ret;\n      MHD_update_last_activity_ (connection);\n      if (MHD_CONNECTION_CHUNKED_BODY_READY != connection->state)\n        return;\n      check_write_done (connection,\n                        (connection->response->total_size ==\n                         connection->response_write_position) ?\n                        MHD_CONNECTION_BODY_SENT :\n                        MHD_CONNECTION_CHUNKED_BODY_UNREADY);\n      return;\n    case MHD_CONNECTION_CHUNKED_BODY_UNREADY:\n    case MHD_CONNECTION_BODY_SENT:\n      mhd_assert (0);\n      return;\n    case MHD_CONNECTION_FOOTERS_SENDING:\n      ret = connection->send_cls (connection,\n                                  &connection->write_buffer\n                                  [connection->write_buffer_send_offset],\n                                  connection->write_buffer_append_offset -\n                                    connection->write_buffer_send_offset);\n      if (ret < 0)\n        {\n          if (MHD_ERR_AGAIN_ == ret)\n            return;\n          CONNECTION_CLOSE_ERROR (connection,\n                                  _(\"Connection was closed while sending response body.\\n\"));\n          return;\n        }\n      connection->write_buffer_send_offset += ret;\n      MHD_update_last_activity_ (connection);\n      if (MHD_CONNECTION_FOOTERS_SENDING != connection->state)\n        return;\n      check_write_done (connection,\n                        MHD_CONNECTION_FOOTERS_SENT);\n      return;\n    case MHD_CONNECTION_FOOTERS_SENT:\n      mhd_assert (0);\n      return;\n    case MHD_CONNECTION_CLOSED:\n      return;\n    case MHD_CONNECTION_IN_CLEANUP:\n      mhd_assert (0);\n      return;\n#ifdef UPGRADE_SUPPORT\n    case MHD_CONNECTION_UPGRADE:\n      mhd_assert (0);\n      return;\n#endif /* UPGRADE_SUPPORT */\n    default:\n      mhd_assert (0);\n      CONNECTION_CLOSE_ERROR (connection,\n                              _(\"Internal error\\n\"));\n      break;\n    }\n  return;\n}",
      "lines": 230,
      "depth": 18,
      "decorators": [
        "void"
      ]
    },
    "cleanup_connection": {
      "start_point": [
        3167,
        0
      ],
      "end_point": [
        3225,
        1
      ],
      "content": "static void\ncleanup_connection (struct MHD_Connection *connection)\n{\n  struct MHD_Daemon *daemon = connection->daemon;\n\n  if (connection->in_cleanup)\n    return; /* Prevent double cleanup. */\n  connection->in_cleanup = true;\n  if (NULL != connection->response)\n    {\n      MHD_destroy_response (connection->response);\n      connection->response = NULL;\n    }\n  MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n  if (connection->suspended)\n    {\n      DLL_remove (daemon->suspended_connections_head,\n                  daemon->suspended_connections_tail,\n                  connection);\n      connection->suspended = false;\n    }\n  else\n    {\n      if (0 == (daemon->options & MHD_USE_THREAD_PER_CONNECTION))\n        {\n          if (connection->connection_timeout == daemon->connection_timeout)\n            XDLL_remove (daemon->normal_timeout_head,\n                         daemon->normal_timeout_tail,\n                         connection);\n          else\n            XDLL_remove (daemon->manual_timeout_head,\n                         daemon->manual_timeout_tail,\n                         connection);\n        }\n      DLL_remove (daemon->connections_head,\n                  daemon->connections_tail,\n                  connection);\n    }\n  DLL_insert (daemon->cleanup_head,\n\t      daemon->cleanup_tail,\n\t      connection);\n  connection->resuming = false;\n  connection->in_idle = false;\n  MHD_mutex_unlock_chk_(&daemon->cleanup_connection_mutex);\n  if (0 != (daemon->options & MHD_USE_THREAD_PER_CONNECTION))\n    {\n      /* if we were at the connection limit before and are in\n         thread-per-connection mode, signal the main thread\n         to resume accepting connections */\n      if ( (MHD_ITC_IS_VALID_ (daemon->itc)) &&\n           (! MHD_itc_activate_ (daemon->itc, \"c\")) )\n        {\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (daemon,\n                    _(\"Failed to signal end of connection via inter-thread communication channel\"));\n#endif\n        }\n    }\n}",
      "lines": 59,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "MHD_connection_handle_idle": {
      "start_point": [
        3238,
        0
      ],
      "end_point": [
        3733,
        1
      ],
      "content": "int\nMHD_connection_handle_idle (struct MHD_Connection *connection)\n{\n  struct MHD_Daemon *daemon = connection->daemon;\n  char *line;\n  size_t line_len;\n  int ret;\n\n  connection->in_idle = true;\n  while (! connection->suspended)\n    {\n#ifdef HTTPS_SUPPORT\n      if (MHD_TLS_CONN_NO_TLS != connection->tls_state)\n        { /* HTTPS connection. */\n          if ((MHD_TLS_CONN_INIT <= connection->tls_state) &&\n              (MHD_TLS_CONN_CONNECTED > connection->tls_state))\n            break;\n        }\n#endif /* HTTPS_SUPPORT */\n#if DEBUG_STATES\n      MHD_DLOG (daemon,\n                _(\"In function %s handling connection at state: %s\\n\"),\n                __FUNCTION__,\n                MHD_state_to_string (connection->state));\n#endif\n      switch (connection->state)\n        {\n        case MHD_CONNECTION_INIT:\n          line = get_next_header_line (connection,\n                                       &line_len);\n          /* Check for empty string, as we might want\n             to tolerate 'spurious' empty lines; also\n             NULL means we didn't get a full line yet;\n             line is not 0-terminated here. */\n          if ( (NULL == line) ||\n               (0 == line[0]) )\n            {\n              if (MHD_CONNECTION_INIT != connection->state)\n                continue;\n              if (connection->read_closed)\n                {\n\t\t  CONNECTION_CLOSE_ERROR (connection,\n\t\t\t\t\t  NULL);\n                  continue;\n                }\n              break;\n            }\n          if (MHD_NO == parse_initial_message_line (connection,\n                                                    line,\n                                                    line_len))\n            CONNECTION_CLOSE_ERROR (connection,\n                                    NULL);\n          else\n            connection->state = MHD_CONNECTION_URL_RECEIVED;\n          continue;\n        case MHD_CONNECTION_URL_RECEIVED:\n          line = get_next_header_line (connection,\n                                       NULL);\n          if (NULL == line)\n            {\n              if (MHD_CONNECTION_URL_RECEIVED != connection->state)\n                continue;\n              if (connection->read_closed)\n                {\n\t\t  CONNECTION_CLOSE_ERROR (connection,\n\t\t\t\t\t  NULL);\n                  continue;\n                }\n              break;\n            }\n          if (0 == line[0])\n            {\n              connection->state = MHD_CONNECTION_HEADERS_RECEIVED;\n              connection->header_size = (size_t) (line - connection->read_buffer);\n              continue;\n            }\n          if (MHD_NO == process_header_line (connection,\n                                             line))\n            {\n              transmit_error_response (connection,\n                                       MHD_HTTP_BAD_REQUEST,\n                                       REQUEST_MALFORMED);\n              break;\n            }\n          connection->state = MHD_CONNECTION_HEADER_PART_RECEIVED;\n          continue;\n        case MHD_CONNECTION_HEADER_PART_RECEIVED:\n          line = get_next_header_line (connection,\n                                       NULL);\n          if (NULL == line)\n            {\n              if (connection->state != MHD_CONNECTION_HEADER_PART_RECEIVED)\n                continue;\n              if (connection->read_closed)\n                {\n\t\t  CONNECTION_CLOSE_ERROR (connection,\n\t\t\t\t\t  NULL);\n                  continue;\n                }\n              break;\n            }\n          if (MHD_NO ==\n              process_broken_line (connection,\n                                   line,\n                                   MHD_HEADER_KIND))\n            continue;\n          if (0 == line[0])\n            {\n              connection->state = MHD_CONNECTION_HEADERS_RECEIVED;\n              connection->header_size = (size_t) (line - connection->read_buffer);\n              continue;\n            }\n          continue;\n        case MHD_CONNECTION_HEADERS_RECEIVED:\n          parse_connection_headers (connection);\n          if (MHD_CONNECTION_CLOSED == connection->state)\n            continue;\n          connection->state = MHD_CONNECTION_HEADERS_PROCESSED;\n          if (connection->suspended)\n            break;\n          continue;\n        case MHD_CONNECTION_HEADERS_PROCESSED:\n          call_connection_handler (connection); /* first call */\n          if (MHD_CONNECTION_CLOSED == connection->state)\n            continue;\n          if (need_100_continue (connection))\n            {\n              connection->state = MHD_CONNECTION_CONTINUE_SENDING;\n              if (MHD_NO != socket_flush_possible (connection))\n                socket_start_extra_buffering (connection);\n              else\n                socket_start_no_buffering (connection);\n\n              break;\n            }\n          if ( (NULL != connection->response) &&\n\t       ( (MHD_str_equal_caseless_ (connection->method,\n                                           MHD_HTTP_METHOD_POST)) ||\n\t\t (MHD_str_equal_caseless_ (connection->method,\n                                           MHD_HTTP_METHOD_PUT))) )\n            {\n              /* we refused (no upload allowed!) */\n              connection->remaining_upload_size = 0;\n              /* force close, in case client still tries to upload... */\n              connection->read_closed = true;\n            }\n          connection->state = (0 == connection->remaining_upload_size)\n            ? MHD_CONNECTION_FOOTERS_RECEIVED : MHD_CONNECTION_CONTINUE_SENT;\n          if (connection->suspended)\n            break;\n          continue;\n        case MHD_CONNECTION_CONTINUE_SENDING:\n          if (connection->continue_message_write_offset ==\n              MHD_STATICSTR_LEN_ (HTTP_100_CONTINUE))\n            {\n              connection->state = MHD_CONNECTION_CONTINUE_SENT;\n              if (MHD_NO != socket_flush_possible (connection))\n                socket_start_no_buffering_flush (connection);\n              else\n                socket_start_normal_buffering (connection);\n\n              continue;\n            }\n          break;\n        case MHD_CONNECTION_CONTINUE_SENT:\n          if (0 != connection->read_buffer_offset)\n            {\n              process_request_body (connection);     /* loop call */\n              if (MHD_CONNECTION_CLOSED == connection->state)\n                continue;\n            }\n          if ( (0 == connection->remaining_upload_size) ||\n               ( (MHD_SIZE_UNKNOWN == connection->remaining_upload_size) &&\n                 (0 == connection->read_buffer_offset) &&\n                 (connection->read_closed) ) )\n            {\n              if ( (connection->have_chunked_upload) &&\n                   (! connection->read_closed) )\n                connection->state = MHD_CONNECTION_BODY_RECEIVED;\n              else\n                connection->state = MHD_CONNECTION_FOOTERS_RECEIVED;\n              if (connection->suspended)\n                break;\n              continue;\n            }\n          break;\n        case MHD_CONNECTION_BODY_RECEIVED:\n          line = get_next_header_line (connection,\n                                       NULL);\n          if (NULL == line)\n            {\n              if (connection->state != MHD_CONNECTION_BODY_RECEIVED)\n                continue;\n              if (connection->read_closed)\n                {\n\t\t  CONNECTION_CLOSE_ERROR (connection,\n\t\t\t\t\t  NULL);\n                  continue;\n                }\n              break;\n            }\n          if (0 == line[0])\n            {\n              connection->state = MHD_CONNECTION_FOOTERS_RECEIVED;\n              if (connection->suspended)\n                break;\n              continue;\n            }\n          if (MHD_NO == process_header_line (connection,\n                                             line))\n            {\n              transmit_error_response (connection,\n                                       MHD_HTTP_BAD_REQUEST,\n                                       REQUEST_MALFORMED);\n              break;\n            }\n          connection->state = MHD_CONNECTION_FOOTER_PART_RECEIVED;\n          continue;\n        case MHD_CONNECTION_FOOTER_PART_RECEIVED:\n          line = get_next_header_line (connection,\n                                       NULL);\n          if (NULL == line)\n            {\n              if (connection->state != MHD_CONNECTION_FOOTER_PART_RECEIVED)\n                continue;\n              if (connection->read_closed)\n                {\n\t\t  CONNECTION_CLOSE_ERROR (connection,\n\t\t\t\t\t  NULL);\n                  continue;\n                }\n              break;\n            }\n          if (MHD_NO ==\n              process_broken_line (connection,\n                                   line,\n                                   MHD_FOOTER_KIND))\n            continue;\n          if (0 == line[0])\n            {\n              connection->state = MHD_CONNECTION_FOOTERS_RECEIVED;\n              if (connection->suspended)\n                break;\n              continue;\n            }\n          continue;\n        case MHD_CONNECTION_FOOTERS_RECEIVED:\n          call_connection_handler (connection); /* \"final\" call */\n          if (connection->state == MHD_CONNECTION_CLOSED)\n            continue;\n          if (NULL == connection->response)\n            break;              /* try again next time */\n          if (MHD_NO == build_header_response (connection))\n            {\n              /* oops - close! */\n\t      CONNECTION_CLOSE_ERROR (connection,\n\t\t\t\t      _(\"Closing connection (failed to create response header)\\n\"));\n              continue;\n            }\n          connection->state = MHD_CONNECTION_HEADERS_SENDING;\n          if (MHD_NO != socket_flush_possible (connection))\n            socket_start_extra_buffering (connection);\n          else\n            socket_start_no_buffering (connection);\n\n          break;\n        case MHD_CONNECTION_HEADERS_SENDING:\n          /* no default action */\n          break;\n        case MHD_CONNECTION_HEADERS_SENT:\n          /* Some clients may take some actions right after header receive */\n          if (MHD_NO != socket_flush_possible (connection))\n            socket_start_no_buffering_flush (connection);\n\n#ifdef UPGRADE_SUPPORT\n          if (NULL != connection->response->upgrade_handler)\n            {\n              socket_start_normal_buffering (connection);\n              connection->state = MHD_CONNECTION_UPGRADE;\n              /* This connection is \"upgraded\".  Pass socket to application. */\n              if (MHD_YES !=\n                  MHD_response_execute_upgrade_ (connection->response,\n                                                 connection))\n                {\n                  /* upgrade failed, fail hard */\n                  CONNECTION_CLOSE_ERROR (connection,\n                                          NULL);\n                  continue;\n                }\n              /* Response is not required anymore for this connection. */\n              if (NULL != connection->response)\n                {\n                  struct MHD_Response * const resp = connection->response;\n                  connection->response = NULL;\n                  MHD_destroy_response (resp);\n                }\n              continue;\n            }\n#endif /* UPGRADE_SUPPORT */\n          if (MHD_NO != socket_flush_possible (connection))\n            socket_start_extra_buffering (connection);\n          else\n            socket_start_normal_buffering (connection);\n\n          if (connection->have_chunked_upload)\n            connection->state = MHD_CONNECTION_CHUNKED_BODY_UNREADY;\n          else\n            connection->state = MHD_CONNECTION_NORMAL_BODY_UNREADY;\n          continue;\n        case MHD_CONNECTION_NORMAL_BODY_READY:\n          /* nothing to do here */\n          break;\n        case MHD_CONNECTION_NORMAL_BODY_UNREADY:\n          if (NULL != connection->response->crc)\n            MHD_mutex_lock_chk_ (&connection->response->mutex);\n          if (0 == connection->response->total_size)\n            {\n              if (NULL != connection->response->crc)\n                MHD_mutex_unlock_chk_ (&connection->response->mutex);\n              connection->state = MHD_CONNECTION_BODY_SENT;\n              continue;\n            }\n          if (MHD_YES == try_ready_normal_body (connection))\n            {\n\t      if (NULL != connection->response->crc)\n\t        MHD_mutex_unlock_chk_ (&connection->response->mutex);\n              connection->state = MHD_CONNECTION_NORMAL_BODY_READY;\n              /* Buffering for flushable socket was already enabled*/\n              if (MHD_NO == socket_flush_possible (connection))\n                socket_start_no_buffering (connection);\n              break;\n            }\n          /* mutex was already unlocked by \"try_ready_normal_body */\n          /* not ready, no socket action */\n          break;\n        case MHD_CONNECTION_CHUNKED_BODY_READY:\n          /* nothing to do here */\n          break;\n        case MHD_CONNECTION_CHUNKED_BODY_UNREADY:\n          if (NULL != connection->response->crc)\n            MHD_mutex_lock_chk_ (&connection->response->mutex);\n          if ( (0 == connection->response->total_size) ||\n               (connection->response_write_position ==\n                connection->response->total_size) )\n            {\n              if (NULL != connection->response->crc)\n                MHD_mutex_unlock_chk_ (&connection->response->mutex);\n              connection->state = MHD_CONNECTION_BODY_SENT;\n              continue;\n            }\n          if (MHD_YES == try_ready_chunked_body (connection))\n            {\n              if (NULL != connection->response->crc)\n                MHD_mutex_unlock_chk_ (&connection->response->mutex);\n              connection->state = MHD_CONNECTION_CHUNKED_BODY_READY;\n              /* Buffering for flushable socket was already enabled */\n              if (MHD_NO == socket_flush_possible (connection))\n                socket_start_no_buffering (connection);\n              continue;\n            }\n          /* mutex was already unlocked by try_ready_chunked_body */\n          break;\n        case MHD_CONNECTION_BODY_SENT:\n          if (MHD_NO == build_header_response (connection))\n            {\n              /* oops - close! */\n\t      CONNECTION_CLOSE_ERROR (connection,\n\t\t\t\t      _(\"Closing connection (failed to create response header)\\n\"));\n              continue;\n            }\n          if ( (! connection->have_chunked_upload) ||\n               (connection->write_buffer_send_offset ==\n                connection->write_buffer_append_offset) )\n            connection->state = MHD_CONNECTION_FOOTERS_SENT;\n          else\n            connection->state = MHD_CONNECTION_FOOTERS_SENDING;\n          continue;\n        case MHD_CONNECTION_FOOTERS_SENDING:\n          /* no default action */\n          break;\n        case MHD_CONNECTION_FOOTERS_SENT:\n\t  if (MHD_HTTP_PROCESSING == connection->responseCode)\n\t  {\n\t    /* After this type of response, we allow sending another! */\n\t    connection->state = MHD_CONNECTION_HEADERS_PROCESSED;\n\t    MHD_destroy_response (connection->response);\n\t    connection->response = NULL;\n\t    /* FIXME: maybe partially reset memory pool? */\n\t    continue;\n\t  }\n          if (MHD_NO != socket_flush_possible (connection))\n            socket_start_no_buffering_flush (connection);\n          else\n            socket_start_normal_buffering (connection);\n\n          MHD_destroy_response (connection->response);\n          connection->response = NULL;\n          if ( (NULL != daemon->notify_completed) &&\n               (connection->client_aware) )\n          {\n            connection->client_aware = false;\n\t    daemon->notify_completed (daemon->notify_completed_cls,\n\t\t\t\t      connection,\n\t\t\t\t      &connection->client_context,\n\t\t\t\t      MHD_REQUEST_TERMINATED_COMPLETED_OK);\n          }\n          if ( (MHD_CONN_USE_KEEPALIVE != connection->keepalive) ||\n               (connection->read_closed) )\n            {\n              /* have to close for some reason */\n              MHD_connection_close_ (connection,\n                                     MHD_REQUEST_TERMINATED_COMPLETED_OK);\n              MHD_pool_destroy (connection->pool);\n              connection->pool = NULL;\n              connection->read_buffer = NULL;\n              connection->read_buffer_size = 0;\n              connection->read_buffer_offset = 0;\n            }\n          else\n            {\n              /* can try to keep-alive */\n              if (MHD_NO != socket_flush_possible (connection))\n                socket_start_normal_buffering (connection);\n              connection->version = NULL;\n              connection->state = MHD_CONNECTION_INIT;\n              connection->last = NULL;\n              connection->colon = NULL;\n              connection->header_size = 0;\n              connection->keepalive = MHD_CONN_KEEPALIVE_UNKOWN;\n              /* Reset the read buffer to the starting size,\n                 preserving the bytes we have already read. */\n              connection->read_buffer\n                = MHD_pool_reset (connection->pool,\n                                  connection->read_buffer,\n                                  connection->read_buffer_offset,\n                                  connection->daemon->pool_size / 2);\n              connection->read_buffer_size\n                = connection->daemon->pool_size / 2;\n            }\n\t  connection->client_aware = false;\n          connection->client_context = NULL;\n          connection->continue_message_write_offset = 0;\n          connection->responseCode = 0;\n          connection->headers_received = NULL;\n\t  connection->headers_received_tail = NULL;\n          connection->response_write_position = 0;\n          connection->have_chunked_upload = false;\n          connection->current_chunk_size = 0;\n          connection->current_chunk_offset = 0;\n          connection->method = NULL;\n          connection->url = NULL;\n          connection->write_buffer = NULL;\n          connection->write_buffer_size = 0;\n          connection->write_buffer_send_offset = 0;\n          connection->write_buffer_append_offset = 0;\n          continue;\n        case MHD_CONNECTION_CLOSED:\n\t  cleanup_connection (connection);\n          connection->in_idle = false;\n\t  return MHD_NO;\n#ifdef UPGRADE_SUPPORT\n\tcase MHD_CONNECTION_UPGRADE:\n          connection->in_idle = false;\n          return MHD_YES; /* keep open */\n#endif /* UPGRADE_SUPPORT */\n       default:\n          mhd_assert (0);\n          break;\n        }\n      break;\n    }\n  if (! connection->suspended)\n    {\n      time_t timeout;\n      timeout = connection->connection_timeout;\n      if ( (0 != timeout) &&\n           (timeout < (MHD_monotonic_sec_counter() - connection->last_activity)) )\n        {\n          MHD_connection_close_ (connection,\n                                 MHD_REQUEST_TERMINATED_TIMEOUT_REACHED);\n          connection->in_idle = false;\n          return MHD_YES;\n        }\n    }\n  MHD_connection_update_event_loop_info (connection);\n  ret = MHD_YES;\n#ifdef EPOLL_SUPPORT\n  if ( (! connection->suspended) &&\n       (0 != (daemon->options & MHD_USE_EPOLL)) )\n    {\n      ret = MHD_connection_epoll_update_ (connection);\n    }\n#endif /* EPOLL_SUPPORT */\n  connection->in_idle = false;\n  return ret;\n}",
      "lines": 496,
      "depth": 17,
      "decorators": [
        "int"
      ]
    },
    "MHD_connection_epoll_update_": {
      "start_point": [
        3745,
        0
      ],
      "end_point": [
        3781,
        1
      ],
      "content": "int\nMHD_connection_epoll_update_ (struct MHD_Connection *connection)\n{\n  struct MHD_Daemon *daemon = connection->daemon;\n\n  if ( (0 != (daemon->options & MHD_USE_EPOLL)) &&\n       (0 == (connection->epoll_state & MHD_EPOLL_STATE_IN_EPOLL_SET)) &&\n       (0 == (connection->epoll_state & MHD_EPOLL_STATE_SUSPENDED)) &&\n       ( ( (MHD_EVENT_LOOP_INFO_WRITE == connection->event_loop_info) &&\n           (0 == (connection->epoll_state & MHD_EPOLL_STATE_WRITE_READY))) ||\n\t ( (MHD_EVENT_LOOP_INFO_READ == connection->event_loop_info) &&\n\t   (0 == (connection->epoll_state & MHD_EPOLL_STATE_READ_READY)) ) ) )\n    {\n      /* add to epoll set */\n      struct epoll_event event;\n\n      event.events = EPOLLIN | EPOLLOUT | EPOLLPRI | EPOLLET;\n      event.data.ptr = connection;\n      if (0 != epoll_ctl (daemon->epoll_fd,\n\t\t\t  EPOLL_CTL_ADD,\n\t\t\t  connection->socket_fd,\n\t\t\t  &event))\n\t{\n#ifdef HAVE_MESSAGES\n\t  if (0 != (daemon->options & MHD_USE_ERROR_LOG))\n\t    MHD_DLOG (daemon,\n\t\t      _(\"Call to epoll_ctl failed: %s\\n\"),\n\t\t      MHD_socket_last_strerr_ ());\n#endif\n\t  connection->state = MHD_CONNECTION_CLOSED;\n\t  cleanup_connection (connection);\n\t  return MHD_NO;\n\t}\n      connection->epoll_state |= MHD_EPOLL_STATE_IN_EPOLL_SET;\n    }\n  return MHD_YES;\n}",
      "lines": 37,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "MHD_set_http_callbacks_": {
      "start_point": [
        3790,
        0
      ],
      "end_point": [
        3795,
        1
      ],
      "content": "void\nMHD_set_http_callbacks_ (struct MHD_Connection *connection)\n{\n  connection->recv_cls = &recv_param_adapter;\n  connection->send_cls = &send_param_adapter;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "MHD_get_connection_info": {
      "start_point": [
        3808,
        0
      ],
      "end_point": [
        3854,
        1
      ],
      "content": "const union MHD_ConnectionInfo *\nMHD_get_connection_info (struct MHD_Connection *connection,\n                         enum MHD_ConnectionInfoType info_type,\n                         ...)\n{\n  switch (info_type)\n    {\n#ifdef HTTPS_SUPPORT\n    case MHD_CONNECTION_INFO_CIPHER_ALGO:\n      if (NULL == connection->tls_session)\n\treturn NULL;\n      connection->cipher = gnutls_cipher_get (connection->tls_session);\n      return (const union MHD_ConnectionInfo *) &connection->cipher;\n    case MHD_CONNECTION_INFO_PROTOCOL:\n      if (NULL == connection->tls_session)\n\treturn NULL;\n      connection->protocol = gnutls_protocol_get_version (connection->tls_session);\n      return (const union MHD_ConnectionInfo *) &connection->protocol;\n    case MHD_CONNECTION_INFO_GNUTLS_SESSION:\n      if (NULL == connection->tls_session)\n\treturn NULL;\n      return (const union MHD_ConnectionInfo *) &connection->tls_session;\n#endif /* HTTPS_SUPPORT */\n    case MHD_CONNECTION_INFO_CLIENT_ADDRESS:\n      return (const union MHD_ConnectionInfo *) &connection->addr;\n    case MHD_CONNECTION_INFO_DAEMON:\n      return (const union MHD_ConnectionInfo *) &connection->daemon;\n    case MHD_CONNECTION_INFO_CONNECTION_FD:\n      return (const union MHD_ConnectionInfo *) &connection->socket_fd;\n    case MHD_CONNECTION_INFO_SOCKET_CONTEXT:\n      return (const union MHD_ConnectionInfo *) &connection->socket_context;\n    case MHD_CONNECTION_INFO_CONNECTION_SUSPENDED:\n      connection->suspended_dummy = connection->suspended ? MHD_YES : MHD_NO;\n      return (const union MHD_ConnectionInfo *) &connection->suspended_dummy;\n    case MHD_CONNECTION_INFO_CONNECTION_TIMEOUT:\n      connection->connection_timeout_dummy = (unsigned int)connection->connection_timeout;\n      return (const union MHD_ConnectionInfo *) &connection->connection_timeout_dummy;\n    case MHD_CONNECTION_INFO_REQUEST_HEADER_SIZE:\n      if ( (MHD_CONNECTION_HEADERS_RECEIVED > connection->state) ||\n           (MHD_CONNECTION_CLOSED == connection->state) ||\n           (MHD_CONNECTION_IN_CLEANUP == connection->state) )\n        return NULL; /* invalid, too early! */\n      return (const union MHD_ConnectionInfo *) &connection->header_size;\n    default:\n      return NULL;\n    }\n}",
      "lines": 47,
      "depth": 13,
      "decorators": [
        "const",
        "const",
        "union MHD_ConnectionInfo",
        "union",
        "MHD_ConnectionInfo",
        "*\nMHD_get_connection_info (struct MHD_Connection *connection,\n                         enum MHD_ConnectionInfoType info_type,\n                         ...)",
        "*"
      ]
    },
    "MHD_set_connection_option": {
      "start_point": [
        3866,
        0
      ],
      "end_point": [
        3915,
        1
      ],
      "content": "int\nMHD_set_connection_option (struct MHD_Connection *connection,\n\t\t\t   enum MHD_CONNECTION_OPTION option,\n\t\t\t   ...)\n{\n  va_list ap;\n  struct MHD_Daemon *daemon;\n\n  daemon = connection->daemon;\n  switch (option)\n    {\n    case MHD_CONNECTION_OPTION_TIMEOUT:\n      if (0 == connection->connection_timeout)\n        connection->last_activity = MHD_monotonic_sec_counter();\n\n      MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n      if ( (0 == (daemon->options & MHD_USE_THREAD_PER_CONNECTION)) &&\n          (! connection->suspended) )\n        {\n          if (connection->connection_timeout == daemon->connection_timeout)\n            XDLL_remove (daemon->normal_timeout_head,\n                          daemon->normal_timeout_tail,\n                          connection);\n          else\n            XDLL_remove (daemon->manual_timeout_head,\n                          daemon->manual_timeout_tail,\n                          connection);\n        }\n      va_start (ap, option);\n      connection->connection_timeout = va_arg (ap,\n                                               unsigned int);\n      va_end (ap);\n      if ( (0 == (daemon->options & MHD_USE_THREAD_PER_CONNECTION)) &&\n          (! connection->suspended) )\n        {\n          if (connection->connection_timeout == daemon->connection_timeout)\n            XDLL_insert (daemon->normal_timeout_head,\n                          daemon->normal_timeout_tail,\n                          connection);\n          else\n            XDLL_insert (daemon->manual_timeout_head,\n                          daemon->manual_timeout_tail,\n                          connection);\n        }\n      MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n      return MHD_YES;\n    default:\n      return MHD_NO;\n    }\n}",
      "lines": 50,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "MHD_queue_response": {
      "start_point": [
        3929,
        0
      ],
      "end_point": [
        4016,
        1
      ],
      "content": "int\nMHD_queue_response (struct MHD_Connection *connection,\n                    unsigned int status_code,\n                    struct MHD_Response *response)\n{\n  struct MHD_Daemon *daemon;\n\n  if ( (NULL == connection) ||\n       (NULL == response) ||\n       (NULL != connection->response) ||\n       ( (MHD_CONNECTION_HEADERS_PROCESSED != connection->state) &&\n\t (MHD_CONNECTION_FOOTERS_RECEIVED != connection->state) ) )\n    return MHD_NO;\n  daemon = connection->daemon;\n\n  if (daemon->shutdown)\n    return MHD_YES; /* If daemon was shut down in parallel,\n                     * response will be aborted now or on later stage. */\n\n  if ( (!connection->suspended) &&\n       (0 != (daemon->options & MHD_USE_INTERNAL_POLLING_THREAD)) &&\n       (!MHD_thread_ID_match_current_(connection->pid.ID)) )\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _(\"Attempted to queue response on wrong thread!\\n\"));\n#endif\n      return MHD_NO;\n    }\n#ifdef UPGRADE_SUPPORT\n  if ( (NULL != response->upgrade_handler) &&\n       (0 == (daemon->options & MHD_ALLOW_UPGRADE)) )\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _(\"Attempted 'upgrade' connection on daemon without MHD_ALLOW_UPGRADE option!\\n\"));\n#endif\n      return MHD_NO;\n    }\n  if ( (MHD_HTTP_SWITCHING_PROTOCOLS != status_code) &&\n       (NULL != response->upgrade_handler) )\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _(\"Application used invalid status code for 'upgrade' response!\\n\"));\n#endif\n      return MHD_NO;\n    }\n#endif /* UPGRADE_SUPPORT */\n  MHD_increment_response_rc (response);\n  connection->response = response;\n  connection->responseCode = status_code;\n#if defined(_MHD_HAVE_SENDFILE)\n  if ( (response->fd == -1) ||\n       (0 != (connection->daemon->options & MHD_USE_TLS)) )\n    connection->resp_sender = MHD_resp_sender_std;\n  else\n    connection->resp_sender = MHD_resp_sender_sendfile;\n#endif /* _MHD_HAVE_SENDFILE */\n\n  if ( ( (NULL != connection->method) &&\n         (MHD_str_equal_caseless_ (connection->method,\n                                   MHD_HTTP_METHOD_HEAD)) ) ||\n       (MHD_HTTP_OK > status_code) ||\n       (MHD_HTTP_NO_CONTENT == status_code) ||\n       (MHD_HTTP_NOT_MODIFIED == status_code) )\n    {\n      /* if this is a \"HEAD\" request, or a status code for\n         which a body is not allowed, pretend that we\n         have already sent the full message body. */\n      connection->response_write_position = response->total_size;\n    }\n  if ( (MHD_CONNECTION_HEADERS_PROCESSED == connection->state) &&\n       (NULL != connection->method) &&\n       ( (MHD_str_equal_caseless_ (connection->method,\n                                   MHD_HTTP_METHOD_POST)) ||\n\t (MHD_str_equal_caseless_ (connection->method,\n                                   MHD_HTTP_METHOD_PUT))) )\n    {\n      /* response was queued \"early\", refuse to read body / footers or\n         further requests! */\n      connection->read_closed = true;\n      connection->state = MHD_CONNECTION_FOOTERS_RECEIVED;\n    }\n  if (! connection->in_idle)\n    (void) MHD_connection_handle_idle (connection);\n  return MHD_YES;\n}",
      "lines": 88,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/microhttpd/connection.h": {},
  "libmicrohttpd/libmicrohttpd-0.9.59/src/microhttpd/connection_https.c": {
    "recv_tls_adapter": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        88,
        1
      ],
      "content": "static ssize_t\nrecv_tls_adapter (struct MHD_Connection *connection,\n                  void *other,\n                  size_t i)\n{\n  ssize_t res;\n\n  if (i > SSIZE_MAX)\n    i = SSIZE_MAX;\n\n  res = gnutls_record_recv (connection->tls_session,\n                            other,\n                            i);\n  if ( (GNUTLS_E_AGAIN == res) ||\n       (GNUTLS_E_INTERRUPTED == res) )\n    {\n#ifdef EPOLL_SUPPORT\n      if (GNUTLS_E_AGAIN == res)\n        connection->epoll_state &= ~MHD_EPOLL_STATE_READ_READY;\n#endif\n      /* Any network errors means that buffer is empty. */\n      connection->tls_read_ready = false;\n      return MHD_ERR_AGAIN_;\n    }\n  if (res < 0)\n    {\n      /* Likely 'GNUTLS_E_INVALID_SESSION' (client communication\n         disrupted); interpret as a hard error */\n      connection->tls_read_ready = false;\n      return MHD_ERR_NOTCONN_;\n    }\n\n#ifdef EPOLL_SUPPORT\n  /* Unlike non-TLS connections, do not reset \"read-ready\" if\n   * received amount smaller than provided amount, as TLS\n   * connections may receive data by fixed-size chunks. */\n#endif /* EPOLL_SUPPORT */\n\n  /* Check whether TLS buffers still have some unread data. */\n  connection->tls_read_ready = ( ((size_t)res == i) &&\n                                 (0 != gnutls_record_check_pending (connection->tls_session)) );\n  return res;\n}",
      "lines": 43,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "ssize_t"
      ]
    },
    "send_tls_adapter": {
      "start_point": [
        100,
        0
      ],
      "end_point": [
        134,
        1
      ],
      "content": "static ssize_t\nsend_tls_adapter (struct MHD_Connection *connection,\n                  const void *other,\n                  size_t i)\n{\n  ssize_t res;\n\n  if (i > SSIZE_MAX)\n    i = SSIZE_MAX;\n\n  res = gnutls_record_send (connection->tls_session,\n                            other,\n                            i);\n  if ( (GNUTLS_E_AGAIN == res) ||\n       (GNUTLS_E_INTERRUPTED == res) )\n    {\n#ifdef EPOLL_SUPPORT\n      if (GNUTLS_E_AGAIN == res)\n        connection->epoll_state &= ~MHD_EPOLL_STATE_WRITE_READY;\n#endif\n      return MHD_ERR_AGAIN_;\n    }\n  if (res < 0)\n    {\n      /* Likely 'GNUTLS_E_INVALID_SESSION' (client communication\n         disrupted); interpret as a hard error */\n      return MHD_ERR_NOTCONN_;\n    }\n#ifdef EPOLL_SUPPORT\n  /* Unlike non-TLS connections, do not reset \"write-ready\" if\n   * sent amount smaller than provided amount, as TLS\n   * connections may break data into smaller parts for sending. */\n#endif /* EPOLL_SUPPORT */\n  return res;\n}",
      "lines": 35,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "ssize_t"
      ]
    },
    "MHD_run_tls_handshake_": {
      "start_point": [
        146,
        0
      ],
      "end_point": [
        180,
        1
      ],
      "content": "bool\nMHD_run_tls_handshake_ (struct MHD_Connection *connection)\n{\n  int ret;\n\n  if ((MHD_TLS_CONN_INIT == connection->tls_state) ||\n      (MHD_TLS_CONN_HANDSHAKING == connection->tls_state))\n    {\n      ret = gnutls_handshake (connection->tls_session);\n      if (ret == GNUTLS_E_SUCCESS)\n\t{\n\t  /* set connection TLS state to enable HTTP processing */\n\t  connection->tls_state = MHD_TLS_CONN_CONNECTED;\n\t  MHD_update_last_activity_ (connection);\n\t  return true;\n\t}\n      if ( (GNUTLS_E_AGAIN == ret) ||\n\t   (GNUTLS_E_INTERRUPTED == ret) )\n\t{\n          connection->tls_state = MHD_TLS_CONN_HANDSHAKING;\n\t  /* handshake not done */\n\t  return false;\n\t}\n      /* handshake failed */\n      connection->tls_state = MHD_TLS_CONN_TLS_FAILED;\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (connection->daemon,\n\t\t_(\"Error: received handshake message out of context\\n\"));\n#endif\n      MHD_connection_close_ (connection,\n                             MHD_REQUEST_TERMINATED_WITH_ERROR);\n      return false;\n    }\n  return true;\n}",
      "lines": 35,
      "depth": 12,
      "decorators": [
        "bool"
      ]
    },
    "MHD_set_https_callbacks": {
      "start_point": [
        189,
        0
      ],
      "end_point": [
        194,
        1
      ],
      "content": "void\nMHD_set_https_callbacks (struct MHD_Connection *connection)\n{\n  connection->recv_cls = &recv_tls_adapter;\n  connection->send_cls = &send_tls_adapter;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "MHD_tls_connection_shutdown": {
      "start_point": [
        203,
        0
      ],
      "end_point": [
        225,
        1
      ],
      "content": "bool\nMHD_tls_connection_shutdown (struct MHD_Connection *connection)\n{\n  if (MHD_TLS_CONN_WR_CLOSED > connection->tls_state)\n    {\n      const int res =\n          gnutls_bye(connection->tls_session, GNUTLS_SHUT_WR);\n      if (GNUTLS_E_SUCCESS == res)\n        {\n          connection->tls_state = MHD_TLS_CONN_WR_CLOSED;\n          return true;\n        }\n      if ((GNUTLS_E_AGAIN == res) ||\n          (GNUTLS_E_INTERRUPTED == res))\n        {\n          connection->tls_state = MHD_TLS_CONN_WR_CLOSING;\n          return true;\n        }\n      else\n        connection->tls_state = MHD_TLS_CONN_TLS_FAILED;\n    }\n  return false;\n}",
      "lines": 23,
      "depth": 10,
      "decorators": [
        "bool"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/microhttpd/connection_https.h": {},
  "libmicrohttpd/libmicrohttpd-0.9.59/src/microhttpd/daemon.c": {
    "mhd_panic_std": {
      "start_point": [
        126,
        0
      ],
      "end_point": [
        145,
        1
      ],
      "content": "static void\nmhd_panic_std (void *cls,\n\t       const char *file,\n\t       unsigned int line,\n\t       const char *reason)\n{\n  (void)cls; /* Mute compiler warning. */\n#ifdef HAVE_MESSAGES\n  fprintf (stderr,\n           _(\"Fatal error in GNU libmicrohttpd %s:%u: %s\\n\"),\n\t   file,\n           line,\n           reason);\n#else  /* ! HAVE_MESSAGES */\n  (void)file;   /* Mute compiler warning. */\n  (void)line;   /* Mute compiler warning. */\n  (void)reason; /* Mute compiler warning. */\n#endif\n  abort ();\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "MHD_check_global_init_": {
      "start_point": [
        193,
        0
      ],
      "end_point": [
        204,
        1
      ],
      "content": "void\nMHD_check_global_init_ (void)\n{\n#ifdef MHD_MUTEX_STATIC_DEFN_INIT_\n  MHD_mutex_lock_chk_(&global_init_mutex_);\n#endif /* MHD_MUTEX_STATIC_DEFN_INIT_ */\n  if (0 == global_init_count++)\n    MHD_init ();\n#ifdef MHD_MUTEX_STATIC_DEFN_INIT_\n  MHD_mutex_unlock_chk_(&global_init_mutex_);\n#endif /* MHD_MUTEX_STATIC_DEFN_INIT_ */\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "MHD_get_master": {
      "start_point": [
        214,
        0
      ],
      "end_point": [
        220,
        1
      ],
      "content": "static struct MHD_Daemon*\nMHD_get_master (struct MHD_Daemon *daemon)\n{\n  while (NULL != daemon->master)\n    daemon = daemon->master;\n  return daemon;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "struct MHD_Daemon",
        "struct",
        "MHD_Daemon",
        "*\nMHD_get_master (struct MHD_Daemon *daemon)",
        "*"
      ]
    },
    "MHD_ip_count_lock": {
      "start_point": [
        262,
        0
      ],
      "end_point": [
        266,
        1
      ],
      "content": "static void\nMHD_ip_count_lock (struct MHD_Daemon *daemon)\n{\n  MHD_mutex_lock_chk_(&daemon->per_ip_connection_mutex);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "MHD_ip_count_unlock": {
      "start_point": [
        274,
        0
      ],
      "end_point": [
        278,
        1
      ],
      "content": "static void\nMHD_ip_count_unlock (struct MHD_Daemon *daemon)\n{\n  MHD_mutex_unlock_chk_(&daemon->per_ip_connection_mutex);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "MHD_ip_addr_compare": {
      "start_point": [
        290,
        0
      ],
      "end_point": [
        298,
        1
      ],
      "content": "static int\nMHD_ip_addr_compare (const void *a1,\n                     const void *a2)\n{\n  return memcmp (a1,\n                 a2,\n                 offsetof (struct MHD_IPCount,\n                           count));\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "MHD_ip_addr_to_key": {
      "start_point": [
        309,
        0
      ],
      "end_point": [
        346,
        1
      ],
      "content": "static int\nMHD_ip_addr_to_key (const struct sockaddr *addr,\n\t\t    socklen_t addrlen,\n\t\t    struct MHD_IPCount *key)\n{\n  memset(key,\n         0,\n         sizeof(*key));\n\n  /* IPv4 addresses */\n  if (sizeof (struct sockaddr_in) == addrlen)\n    {\n      const struct sockaddr_in *addr4 = (const struct sockaddr_in*) addr;\n\n      key->family = AF_INET;\n      memcpy (&key->addr.ipv4,\n              &addr4->sin_addr,\n              sizeof(addr4->sin_addr));\n      return MHD_YES;\n    }\n\n#if HAVE_INET6\n  /* IPv6 addresses */\n  if (sizeof (struct sockaddr_in6) == addrlen)\n    {\n      const struct sockaddr_in6 *addr6 = (const struct sockaddr_in6*) addr;\n\n      key->family = AF_INET6;\n      memcpy (&key->addr.ipv6,\n              &addr6->sin6_addr,\n              sizeof(addr6->sin6_addr));\n      return MHD_YES;\n    }\n#endif\n\n  /* Some other address */\n  return MHD_NO;\n}",
      "lines": 38,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "MHD_ip_limit_add": {
      "start_point": [
        360,
        0
      ],
      "end_point": [
        415,
        1
      ],
      "content": "static int\nMHD_ip_limit_add (struct MHD_Daemon *daemon,\n\t\t  const struct sockaddr *addr,\n\t\t  socklen_t addrlen)\n{\n  struct MHD_IPCount *key;\n  void **nodep;\n  void *node;\n  int result;\n\n  daemon = MHD_get_master (daemon);\n  /* Ignore if no connection limit assigned */\n  if (0 == daemon->per_ip_connection_limit)\n    return MHD_YES;\n\n  if (NULL == (key = malloc (sizeof(*key))))\n    return MHD_NO;\n\n  /* Initialize key */\n  if (MHD_NO == MHD_ip_addr_to_key (addr,\n                                    addrlen,\n                                    key))\n    {\n      /* Allow unhandled address types through */\n      free (key);\n      return MHD_YES;\n    }\n  MHD_ip_count_lock (daemon);\n\n  /* Search for the IP address */\n  if (NULL == (nodep = tsearch (key,\n\t\t\t\t&daemon->per_ip_connection_count,\n\t\t\t\t&MHD_ip_addr_compare)))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n\t\t_(\"Failed to add IP connection count node\\n\"));\n#endif\n      MHD_ip_count_unlock (daemon);\n      free (key);\n      return MHD_NO;\n    }\n  node = *nodep;\n  /* If we got an existing node back, free the one we created */\n  if (node != key)\n    free(key);\n  key = (struct MHD_IPCount *) node;\n  /* Test if there is room for another connection; if so,\n   * increment count */\n  result = (key->count < daemon->per_ip_connection_limit) ? MHD_YES : MHD_NO;\n  if (MHD_YES == result)\n    ++key->count;\n\n  MHD_ip_count_unlock (daemon);\n  return result;\n}",
      "lines": 56,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "MHD_ip_limit_del": {
      "start_point": [
        426,
        0
      ],
      "end_point": [
        472,
        1
      ],
      "content": "static void\nMHD_ip_limit_del (struct MHD_Daemon *daemon,\n\t\t  const struct sockaddr *addr,\n\t\t  socklen_t addrlen)\n{\n  struct MHD_IPCount search_key;\n  struct MHD_IPCount *found_key;\n  void **nodep;\n\n  daemon = MHD_get_master (daemon);\n  /* Ignore if no connection limit assigned */\n  if (0 == daemon->per_ip_connection_limit)\n    return;\n  /* Initialize search key */\n  if (MHD_NO == MHD_ip_addr_to_key (addr,\n                                    addrlen,\n                                    &search_key))\n    return;\n\n  MHD_ip_count_lock (daemon);\n\n  /* Search for the IP address */\n  if (NULL == (nodep = tfind (&search_key,\n\t\t\t      &daemon->per_ip_connection_count,\n\t\t\t      &MHD_ip_addr_compare)))\n    {\n      /* Something's wrong if we couldn't find an IP address\n       * that was previously added */\n      MHD_PANIC (_(\"Failed to find previously-added IP address\\n\"));\n    }\n  found_key = (struct MHD_IPCount *) *nodep;\n  /* Validate existing count for IP address */\n  if (0 == found_key->count)\n    {\n      MHD_PANIC (_(\"Previously-added IP address had counter of zero\\n\"));\n    }\n  /* Remove the node entirely if count reduces to 0 */\n  if (0 == --found_key->count)\n    {\n      tdelete (found_key,\n\t       &daemon->per_ip_connection_count,\n\t       &MHD_ip_addr_compare);\n      free (found_key);\n    }\n\n  MHD_ip_count_unlock (daemon);\n}",
      "lines": 47,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "MHD_init_daemon_certificate": {
      "start_point": [
        482,
        0
      ],
      "end_point": [
        565,
        1
      ],
      "content": "static int\nMHD_init_daemon_certificate (struct MHD_Daemon *daemon)\n{\n  gnutls_datum_t key;\n  gnutls_datum_t cert;\n  int ret;\n\n#if GNUTLS_VERSION_MAJOR >= 3\n  if (NULL != daemon->cert_callback)\n    {\n      gnutls_certificate_set_retrieve_function2 (daemon->x509_cred,\n                                                 daemon->cert_callback);\n    }\n#endif\n  if (NULL != daemon->https_mem_trust)\n    {\n      cert.data = (unsigned char *) daemon->https_mem_trust;\n      cert.size = strlen (daemon->https_mem_trust);\n      if (gnutls_certificate_set_x509_trust_mem (daemon->x509_cred,\n                                                 &cert,\n\t\t\t\t\t\t GNUTLS_X509_FMT_PEM) < 0)\n\t{\n#ifdef HAVE_MESSAGES\n\t  MHD_DLOG(daemon,\n\t\t   \"Bad trust certificate format\\n\");\n#endif\n\t  return -1;\n\t}\n    }\n\n  if (daemon->have_dhparams)\n    {\n      gnutls_certificate_set_dh_params (daemon->x509_cred,\n                                        daemon->https_mem_dhparams);\n    }\n  /* certificate & key loaded from memory */\n  if ( (NULL != daemon->https_mem_cert) &&\n       (NULL != daemon->https_mem_key) )\n    {\n      key.data = (unsigned char *) daemon->https_mem_key;\n      key.size = strlen (daemon->https_mem_key);\n      cert.data = (unsigned char *) daemon->https_mem_cert;\n      cert.size = strlen (daemon->https_mem_cert);\n\n      if (NULL != daemon->https_key_password) {\n#if GNUTLS_VERSION_NUMBER >= 0x030111\n        ret = gnutls_certificate_set_x509_key_mem2 (daemon->x509_cred,\n                                                    &cert,\n                                                    &key,\n                                                    GNUTLS_X509_FMT_PEM,\n                                                    daemon->https_key_password,\n                                                    0);\n#else\n#ifdef HAVE_MESSAGES\n\tMHD_DLOG (daemon,\n                  _(\"Failed to setup x509 certificate/key: pre 3.X.X version \" \\\n                    \"of GnuTLS does not support setting key password\"));\n#endif\n\treturn -1;\n#endif\n      }\n      else\n        ret = gnutls_certificate_set_x509_key_mem (daemon->x509_cred,\n                                                   &cert,\n                                                   &key,\n                                                   GNUTLS_X509_FMT_PEM);\n#ifdef HAVE_MESSAGES\n      if (0 != ret)\n        MHD_DLOG (daemon,\n                  \"GnuTLS failed to setup x509 certificate/key: %s\\n\",\n                  gnutls_strerror (ret));\n#endif\n      return ret;\n    }\n#if GNUTLS_VERSION_MAJOR >= 3\n  if (NULL != daemon->cert_callback)\n    return 0;\n#endif\n#ifdef HAVE_MESSAGES\n  MHD_DLOG (daemon,\n            \"You need to specify a certificate and key location\\n\");\n#endif\n  return -1;\n}",
      "lines": 84,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "MHD_TLS_init": {
      "start_point": [
        574,
        0
      ],
      "end_point": [
        592,
        1
      ],
      "content": "static int\nMHD_TLS_init (struct MHD_Daemon *daemon)\n{\n  switch (daemon->cred_type)\n    {\n    case GNUTLS_CRD_CERTIFICATE:\n      if (0 !=\n          gnutls_certificate_allocate_credentials (&daemon->x509_cred))\n        return GNUTLS_E_MEMORY_ERROR;\n      return MHD_init_daemon_certificate (daemon);\n    default:\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _(\"Error: invalid credentials type %d specified.\\n\"),\n                daemon->cred_type);\n#endif\n      return -1;\n    }\n}",
      "lines": 19,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "MHD_get_fdset": {
      "start_point": [
        627,
        0
      ],
      "end_point": [
        640,
        1
      ],
      "content": "int\nMHD_get_fdset (struct MHD_Daemon *daemon,\n               fd_set *read_fd_set,\n               fd_set *write_fd_set,\n\t       fd_set *except_fd_set,\n\t       MHD_socket *max_fd)\n{\n  return MHD_get_fdset2 (daemon,\n                         read_fd_set,\n                         write_fd_set,\n                         except_fd_set,\n                         max_fd,\n                         _MHD_SYS_DEFAULT_FD_SETSIZE);\n}",
      "lines": 14,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "urh_to_fdset": {
      "start_point": [
        656,
        0
      ],
      "end_point": [
        722,
        1
      ],
      "content": "static bool\nurh_to_fdset (struct MHD_UpgradeResponseHandle *urh,\n              fd_set *rs,\n              fd_set *ws,\n              fd_set *es,\n              MHD_socket *max_fd,\n              unsigned int fd_setsize)\n{\n  const MHD_socket conn_sckt = urh->connection->socket_fd;\n  const MHD_socket mhd_sckt = urh->mhd.socket;\n  bool res = true;\n\n  /* Do not add to 'es' only if socket is closed\n   * or not used anymore. */\n  if (MHD_INVALID_SOCKET != conn_sckt)\n    {\n      if ( (urh->in_buffer_used < urh->in_buffer_size) &&\n           (! MHD_add_to_fd_set_ (conn_sckt,\n                                  rs,\n                                  max_fd,\n                                  fd_setsize)) )\n        res = false;\n      if ( (0 != urh->out_buffer_used) &&\n           (! MHD_add_to_fd_set_ (conn_sckt,\n                                  ws,\n                                  max_fd,\n                                  fd_setsize)) )\n        res = false;\n      /* Do not monitor again for errors if error was detected before as\n       * error state is remembered. */\n      if ((0 == (urh->app.celi & MHD_EPOLL_STATE_ERROR)) &&\n          ((0 != urh->in_buffer_size) ||\n           (0 != urh->out_buffer_size) ||\n           (0 != urh->out_buffer_used)))\n        MHD_add_to_fd_set_ (conn_sckt,\n                            es,\n                            max_fd,\n                            fd_setsize);\n    }\n  if (MHD_INVALID_SOCKET != mhd_sckt)\n    {\n      if ( (urh->out_buffer_used < urh->out_buffer_size) &&\n           (! MHD_add_to_fd_set_ (mhd_sckt,\n                                  rs,\n                                  max_fd,\n                                  fd_setsize)) )\n        res = false;\n      if ( (0 != urh->in_buffer_used) &&\n           (! MHD_add_to_fd_set_ (mhd_sckt,\n                                  ws,\n                                  max_fd,\n                                  fd_setsize)) )\n        res = false;\n      /* Do not monitor again for errors if error was detected before as\n       * error state is remembered. */\n      if ((0 == (urh->mhd.celi & MHD_EPOLL_STATE_ERROR)) &&\n          ((0 != urh->out_buffer_size) ||\n           (0 != urh->in_buffer_size) ||\n           (0 != urh->in_buffer_used)))\n        MHD_add_to_fd_set_ (mhd_sckt,\n                            es,\n                            max_fd,\n                            fd_setsize);\n    }\n\n  return res;\n}",
      "lines": 67,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "urh_from_fdset": {
      "start_point": [
        734,
        0
      ],
      "end_point": [
        765,
        1
      ],
      "content": "static void\nurh_from_fdset (struct MHD_UpgradeResponseHandle *urh,\n                const fd_set *rs,\n                const fd_set *ws,\n                const fd_set *es)\n{\n  const MHD_socket conn_sckt = urh->connection->socket_fd;\n  const MHD_socket mhd_sckt = urh->mhd.socket;\n\n  /* Reset read/write ready, preserve error state. */\n  urh->app.celi &= (~MHD_EPOLL_STATE_READ_READY & ~MHD_EPOLL_STATE_WRITE_READY);\n  urh->mhd.celi &= (~MHD_EPOLL_STATE_READ_READY & ~MHD_EPOLL_STATE_WRITE_READY);\n\n  if (MHD_INVALID_SOCKET != conn_sckt)\n    {\n      if (FD_ISSET (conn_sckt, rs))\n        urh->app.celi |= MHD_EPOLL_STATE_READ_READY;\n      if (FD_ISSET (conn_sckt, ws))\n        urh->app.celi |= MHD_EPOLL_STATE_WRITE_READY;\n      if (FD_ISSET (conn_sckt, es))\n        urh->app.celi |= MHD_EPOLL_STATE_ERROR;\n    }\n  if ((MHD_INVALID_SOCKET != mhd_sckt))\n    {\n      if (FD_ISSET (mhd_sckt, rs))\n        urh->mhd.celi |= MHD_EPOLL_STATE_READ_READY;\n      if (FD_ISSET (mhd_sckt, ws))\n        urh->mhd.celi |= MHD_EPOLL_STATE_WRITE_READY;\n      if (FD_ISSET (mhd_sckt, es))\n        urh->mhd.celi |= MHD_EPOLL_STATE_ERROR;\n    }\n}",
      "lines": 32,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "urh_update_pollfd": {
      "start_point": [
        777,
        0
      ],
      "end_point": [
        809,
        1
      ],
      "content": "static void\nurh_update_pollfd(struct MHD_UpgradeResponseHandle *urh,\n                  struct pollfd p[2])\n{\n  p[0].events = 0;\n  p[1].events = 0;\n\n  if (urh->in_buffer_used < urh->in_buffer_size)\n    p[0].events |= POLLIN;\n  if (0 != urh->out_buffer_used)\n    p[0].events |= POLLOUT;\n\n  /* Do not monitor again for errors if error was detected before as\n   * error state is remembered. */\n  if ((0 == (urh->app.celi & MHD_EPOLL_STATE_ERROR)) &&\n      ((0 != urh->in_buffer_size) ||\n       (0 != urh->out_buffer_size) ||\n       (0 != urh->out_buffer_used)))\n    p[0].events |= MHD_POLL_EVENTS_ERR_DISC;\n\n  if (urh->out_buffer_used < urh->out_buffer_size)\n    p[1].events |= POLLIN;\n  if (0 != urh->in_buffer_used)\n    p[1].events |= POLLOUT;\n\n  /* Do not monitor again for errors if error was detected before as\n   * error state is remembered. */\n  if ((0 == (urh->mhd.celi & MHD_EPOLL_STATE_ERROR)) &&\n      ((0 != urh->out_buffer_size) ||\n       (0 != urh->in_buffer_size) ||\n       (0 != urh->in_buffer_used)))\n    p[1].events |= MHD_POLL_EVENTS_ERR_DISC;\n}",
      "lines": 33,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "urh_to_pollfd": {
      "start_point": [
        818,
        0
      ],
      "end_point": [
        825,
        1
      ],
      "content": "static void\nurh_to_pollfd(struct MHD_UpgradeResponseHandle *urh,\n              struct pollfd p[2])\n{\n  p[0].fd = urh->connection->socket_fd;\n  p[1].fd = urh->mhd.socket;\n  urh_update_pollfd(urh, p);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "urh_from_pollfd": {
      "start_point": [
        833,
        0
      ],
      "end_point": [
        857,
        1
      ],
      "content": "static void\nurh_from_pollfd(struct MHD_UpgradeResponseHandle *urh,\n                struct pollfd p[2])\n{\n  /* Reset read/write ready, preserve error state. */\n  urh->app.celi &= (~MHD_EPOLL_STATE_READ_READY & ~MHD_EPOLL_STATE_WRITE_READY);\n  urh->mhd.celi &= (~MHD_EPOLL_STATE_READ_READY & ~MHD_EPOLL_STATE_WRITE_READY);\n\n  if (0 != (p[0].revents & POLLIN))\n    urh->app.celi |= MHD_EPOLL_STATE_READ_READY;\n  if (0 != (p[0].revents & POLLOUT))\n    urh->app.celi |= MHD_EPOLL_STATE_WRITE_READY;\n  if (0 != (p[0].revents & POLLHUP))\n    urh->app.celi |= MHD_EPOLL_STATE_READ_READY | MHD_EPOLL_STATE_WRITE_READY;\n  if (0 != (p[0].revents & MHD_POLL_REVENTS_ERRROR))\n    urh->app.celi |= MHD_EPOLL_STATE_ERROR;\n  if (0 != (p[1].revents & POLLIN))\n    urh->mhd.celi |= MHD_EPOLL_STATE_READ_READY;\n  if (0 != (p[1].revents & POLLOUT))\n    urh->mhd.celi |= MHD_EPOLL_STATE_WRITE_READY;\n  if (0 != (p[1].revents & POLLHUP))\n    urh->mhd.celi |= MHD_EPOLL_STATE_ERROR;\n  if (0 != (p[1].revents & MHD_POLL_REVENTS_ERRROR))\n    urh->mhd.celi |= MHD_EPOLL_STATE_READ_READY | MHD_EPOLL_STATE_WRITE_READY;\n}",
      "lines": 25,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "internal_get_fdset2": {
      "start_point": [
        876,
        0
      ],
      "end_point": [
        990,
        1
      ],
      "content": "static int\ninternal_get_fdset2 (struct MHD_Daemon *daemon,\n                     fd_set *read_fd_set,\n                     fd_set *write_fd_set,\n                     fd_set *except_fd_set,\n                     MHD_socket *max_fd,\n                     unsigned int fd_setsize)\n\n{\n  struct MHD_Connection *pos;\n  struct MHD_Connection *posn;\n  int result = MHD_YES;\n  MHD_socket ls;\n\n  if (daemon->shutdown)\n    return MHD_NO;\n\n  ls = daemon->listen_fd;\n  if ( (MHD_INVALID_SOCKET != ls) &&\n       (! daemon->was_quiesced) &&\n       (! MHD_add_to_fd_set_ (ls,\n                              read_fd_set,\n                              max_fd,\n                              fd_setsize)) )\n    result = MHD_NO;\n\n  /* Add all sockets to 'except_fd_set' as well to watch for\n   * out-of-band data. However, ignore errors if INFO_READ\n   * or INFO_WRITE sockets will not fit 'except_fd_set'. */\n  /* Start from oldest connections. Make sense for W32 FDSETs. */\n  for (pos = daemon->connections_tail; NULL != pos; pos = posn)\n    {\n      posn = pos->prev;\n\n      switch (pos->event_loop_info)\n\t{\n\tcase MHD_EVENT_LOOP_INFO_READ:\n\t  if (! MHD_add_to_fd_set_ (pos->socket_fd,\n                                    read_fd_set,\n                                    max_fd,\n                                    fd_setsize))\n\t    result = MHD_NO;\n#ifdef MHD_POSIX_SOCKETS\n          MHD_add_to_fd_set_ (pos->socket_fd,\n                              except_fd_set,\n                              max_fd,\n                              fd_setsize);\n#endif /* MHD_POSIX_SOCKETS */\n\t  break;\n\tcase MHD_EVENT_LOOP_INFO_WRITE:\n\t  if (! MHD_add_to_fd_set_ (pos->socket_fd,\n                                    write_fd_set,\n                                    max_fd,\n                                    fd_setsize))\n\t    result = MHD_NO;\n#ifdef MHD_POSIX_SOCKETS\n          MHD_add_to_fd_set_ (pos->socket_fd,\n                              except_fd_set,\n                              max_fd,\n                              fd_setsize);\n#endif /* MHD_POSIX_SOCKETS */\n\t  break;\n\tcase MHD_EVENT_LOOP_INFO_BLOCK:\n\t  if ( (NULL == except_fd_set) ||\n\t      ! MHD_add_to_fd_set_ (pos->socket_fd,\n\t                            except_fd_set,\n                                    max_fd,\n                                    fd_setsize))\n            result = MHD_NO;\n\t  break;\n\tcase MHD_EVENT_LOOP_INFO_CLEANUP:\n\t  /* this should never happen */\n\t  break;\n\t}\n    }\n#ifdef MHD_WINSOCK_SOCKETS\n  /* W32 use limited array for fd_set so add INFO_READ/INFO_WRITE sockets\n   * only after INFO_BLOCK sockets to ensure that INFO_BLOCK sockets will\n   * not be pushed out. */\n  for (pos = daemon->connections_tail; NULL != pos; pos = posn)\n    {\n      posn = pos->prev;\n      MHD_add_to_fd_set_ (pos->socket_fd,\n                          except_fd_set,\n                          max_fd,\n                          fd_setsize);\n    }\n#endif /* MHD_WINSOCK_SOCKETS */\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  {\n    struct MHD_UpgradeResponseHandle *urh;\n\n    for (urh = daemon->urh_tail; NULL != urh; urh = urh->prev)\n      {\n        if (MHD_NO ==\n            urh_to_fdset (urh,\n                          read_fd_set,\n                          write_fd_set,\n                          except_fd_set,\n                          max_fd,\n                          fd_setsize))\n          result = MHD_NO;\n      }\n  }\n#endif\n#if DEBUG_CONNECT\n#ifdef HAVE_MESSAGES\n  if (NULL != max_fd)\n    MHD_DLOG (daemon,\n              _(\"Maximum socket in select set: %d\\n\"),\n              *max_fd);\n#endif\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n  return result;\n}",
      "lines": 115,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "MHD_get_fdset2": {
      "start_point": [
        1025,
        0
      ],
      "end_point": [
        1075,
        1
      ],
      "content": "int\nMHD_get_fdset2 (struct MHD_Daemon *daemon,\n               fd_set *read_fd_set,\n               fd_set *write_fd_set,\n               fd_set *except_fd_set,\n               MHD_socket *max_fd,\n               unsigned int fd_setsize)\n{\n  fd_set es;\n\n  if ( (NULL == daemon) ||\n       (NULL == read_fd_set) ||\n       (NULL == write_fd_set) ||\n       (0 != (daemon->options & MHD_USE_INTERNAL_POLLING_THREAD)) ||\n       (0 != (daemon->options & MHD_USE_POLL)))\n    return MHD_NO;\n\n  if (NULL == except_fd_set)\n    { /* Workaround to maintain backward compatibility. */\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _(\"MHD_get_fdset2() called with except_fd_set \"\n                  \"set to NULL. Such behavior is unsupported.\\n\"));\n#endif\n      FD_ZERO (&es);\n      except_fd_set = &es;\n    }\n\n#ifdef EPOLL_SUPPORT\n  if (0 != (daemon->options & MHD_USE_EPOLL))\n    {\n      if (daemon->shutdown)\n        return MHD_NO;\n\n      /* we're in epoll mode, use the epoll FD as a stand-in for\n         the entire event set */\n\n      return MHD_add_to_fd_set_ (daemon->epoll_fd,\n                                 read_fd_set,\n                                 max_fd,\n                                 fd_setsize) ? MHD_YES : MHD_NO;\n    }\n#endif\n\n  return internal_get_fdset2 (daemon,\n\t\t\t      read_fd_set,\n                              write_fd_set,\n\t\t\t      except_fd_set,\n                              max_fd,\n\t\t\t      fd_setsize);\n}",
      "lines": 51,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "call_handlers": {
      "start_point": [
        1091,
        0
      ],
      "end_point": [
        1186,
        1
      ],
      "content": "static int\ncall_handlers (struct MHD_Connection *con,\n               bool read_ready,\n               bool write_ready,\n               bool force_close)\n{\n  int ret;\n  bool states_info_processed = false;\n  /* Fast track flag */\n  bool on_fasttrack = (con->state == MHD_CONNECTION_INIT);\n\n#ifdef HTTPS_SUPPORT\n  if (con->tls_read_ready)\n    read_ready = true;\n#endif /* HTTPS_SUPPORT */\n  if (!force_close)\n    {\n      if ( (MHD_EVENT_LOOP_INFO_READ == con->event_loop_info) &&\n\t   read_ready)\n        {\n          MHD_connection_handle_read (con);\n          ret = MHD_connection_handle_idle (con);\n          states_info_processed = true;\n        }\n      /* No need to check value of 'ret' here as closed connection\n       * cannot be in MHD_EVENT_LOOP_INFO_WRITE state. */\n      if ( (MHD_EVENT_LOOP_INFO_WRITE == con->event_loop_info) &&\n\t   write_ready)\n        {\n          MHD_connection_handle_write (con);\n          ret = MHD_connection_handle_idle (con);\n          states_info_processed = true;\n        }\n    }\n  else\n    {\n      MHD_connection_close_ (con,\n                             MHD_REQUEST_TERMINATED_WITH_ERROR);\n      return MHD_connection_handle_idle (con);\n    }\n\n  if (!states_info_processed)\n    { /* Connection is not read or write ready, but external conditions\n       * may be changed and need to be processed. */\n      ret = MHD_connection_handle_idle (con);\n    }\n  /* Fast track for fast connections. */\n  /* If full request was read by single read_handler() invocation\n     and headers were completely prepared by single MHD_connection_handle_idle()\n     then try not to wait for next sockets polling and send response\n     immediately.\n     As writeability of socket was not checked and it may have\n     some data pending in system buffers, use this optimization\n     only for non-blocking sockets. */\n  /* No need to check 'ret' as connection is always in\n   * MHD_CONNECTION_CLOSED state if 'ret' is equal 'MHD_NO'. */\n  else if (on_fasttrack && con->sk_nonblck)\n    {\n      if (MHD_CONNECTION_HEADERS_SENDING == con->state)\n        {\n          MHD_connection_handle_write (con);\n          /* Always call 'MHD_connection_handle_idle()' after each read/write. */\n          ret = MHD_connection_handle_idle (con);\n        }\n      /* If all headers were sent by single write_handler() and\n       * response body is prepared by single MHD_connection_handle_idle()\n       * call - continue. */\n      if ((MHD_CONNECTION_NORMAL_BODY_READY == con->state) ||\n          (MHD_CONNECTION_CHUNKED_BODY_READY == con->state))\n        {\n          MHD_connection_handle_write (con);\n          ret = MHD_connection_handle_idle (con);\n        }\n    }\n\n  /* All connection's data and states are processed for this turn.\n   * If connection already has more data to be processed - use\n   * zero timeout for next select()/poll(). */\n  /* Thread-per-connection do not need global zero timeout as\n   * connections are processed individually. */\n  /* Note: no need to check for read buffer availability for\n   * TLS read-ready connection in 'read info' state as connection\n   * without space in read buffer will be market as 'info block'. */\n  if ( (!con->daemon->data_already_pending) &&\n       (0 == (con->daemon->options & MHD_USE_THREAD_PER_CONNECTION)) )\n    {\n      if (MHD_EVENT_LOOP_INFO_BLOCK == con->event_loop_info)\n        con->daemon->data_already_pending = true;\n#ifdef HTTPS_SUPPORT\n      else if ( (con->tls_read_ready) &&\n                (MHD_EVENT_LOOP_INFO_READ == con->event_loop_info) )\n        con->daemon->data_already_pending = true;\n#endif /* HTTPS_SUPPORT */\n    }\n  return ret;\n}",
      "lines": 96,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cleanup_upgraded_connection": {
      "start_point": [
        1197,
        0
      ],
      "end_point": [
        1219,
        1
      ],
      "content": "static void\ncleanup_upgraded_connection (struct MHD_Connection *connection)\n{\n  struct MHD_UpgradeResponseHandle *urh = connection->urh;\n\n  if (NULL == urh)\n    return;\n#ifdef HTTPS_SUPPORT\n  /* Signal remote client the end of TLS connection by\n   * gracefully closing TLS session. */\n  if (0 != (connection->daemon->options & MHD_USE_TLS))\n    gnutls_bye (connection->tls_session,\n                GNUTLS_SHUT_WR);\n\n  if (MHD_INVALID_SOCKET != urh->mhd.socket)\n    MHD_socket_close_chk_ (urh->mhd.socket);\n\n  if (MHD_INVALID_SOCKET != urh->app.socket)\n    MHD_socket_close_chk_ (urh->app.socket);\n#endif /* HTTPS_SUPPORT */\n  connection->urh = NULL;\n  free (urh);\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "process_urh": {
      "start_point": [
        1232,
        0
      ],
      "end_point": [
        1567,
        1
      ],
      "content": "static void\nprocess_urh (struct MHD_UpgradeResponseHandle *urh)\n{\n  /* Help compiler to optimize:\n   * pointers to 'connection' and 'daemon' are not changed\n   * during this processing, so no need to chain dereference\n   * each time. */\n  struct MHD_Connection * const connection = urh->connection;\n  struct MHD_Daemon * const daemon = connection->daemon;\n  /* Prevent data races: use same value of 'was_closed' throughout\n   * this function. If 'was_closed' changed externally in the middle\n   * of processing - it will be processed on next iteration. */\n  bool was_closed;\n  if (daemon->shutdown)\n    {\n      /* Daemon shutting down, application will not receive any more data. */\n#ifdef HAVE_MESSAGES\n      if (! urh->was_closed)\n        {\n          MHD_DLOG (daemon,\n                    _(\"Initiated daemon shutdown while \\\"upgraded\\\" connection was not closed.\\n\"));\n        }\n#endif\n      urh->was_closed = true;\n    }\n  was_closed = urh->was_closed;\n  if (was_closed)\n    {\n      /* Application was closed connections: no more data\n       * can be forwarded to application socket. */\n      if (0 < urh->in_buffer_used)\n        {\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (daemon,\n                    _(\"Failed to forward to application \" MHD_UNSIGNED_LONG_LONG_PRINTF \\\n                        \" bytes of data received from remote side: application shut down socket\\n\"),\n                    (MHD_UNSIGNED_LONG_LONG) urh->in_buffer_used);\n#endif\n\n        }\n      /* If application signaled MHD about socket closure then\n       * check for any pending data even if socket is not marked\n       * as 'ready' (signal may arrive after poll()/select()).\n       * Socketpair for forwarding is always in non-blocking mode\n       * so no risk that recv() will block the thread. */\n      if (0 != urh->out_buffer_size)\n        urh->mhd.celi |= MHD_EPOLL_STATE_READ_READY;\n      /* Discard any data received form remote. */\n      urh->in_buffer_used = 0;\n      /* Do not try to push data to application. */\n      urh->mhd.celi &= ~MHD_EPOLL_STATE_WRITE_READY;\n      /* Reading from remote client is not required anymore. */\n      urh->in_buffer_size = 0;\n      urh->app.celi &= ~MHD_EPOLL_STATE_READ_READY;\n      connection->tls_read_ready = false;\n    }\n\n  /* On some platforms (W32, possibly Darwin) failed send() (send() will always\n   * fail after remote disconnect was detected) may discard data in system\n   * buffers received by system but not yet read by recv().\n   * So, before trying send() on any socket, recv() must be performed at first\n   * otherwise last part of incoming data may be lost. */\n\n  /* If disconnect or error was detected - try to read from socket\n   * to dry data possibly pending is system buffers. */\n  if (0 != (MHD_EPOLL_STATE_ERROR & urh->app.celi))\n    urh->app.celi |= MHD_EPOLL_STATE_READ_READY;\n  if (0 != (MHD_EPOLL_STATE_ERROR & urh->mhd.celi))\n    urh->mhd.celi |= MHD_EPOLL_STATE_READ_READY;\n\n  /*\n   * handle reading from remote TLS client\n   */\n  if ( ( (0 != (MHD_EPOLL_STATE_READ_READY & urh->app.celi)) ||\n         (connection->tls_read_ready) ) &&\n       (urh->in_buffer_used < urh->in_buffer_size) )\n    {\n      ssize_t res;\n      size_t buf_size;\n\n      buf_size = urh->in_buffer_size - urh->in_buffer_used;\n      if (buf_size > SSIZE_MAX)\n        buf_size = SSIZE_MAX;\n\n      connection->tls_read_ready = false;\n      res = gnutls_record_recv (connection->tls_session,\n                                &urh->in_buffer[urh->in_buffer_used],\n                                buf_size);\n      if (0 >= res)\n        {\n          if (GNUTLS_E_INTERRUPTED != res)\n            {\n              urh->app.celi &= ~MHD_EPOLL_STATE_READ_READY;\n              if (GNUTLS_E_AGAIN != res)\n                {\n                  /* Unrecoverable error on socket was detected or\n                   * socket was disconnected/shut down. */\n                  /* Stop trying to read from this TLS socket. */\n                  urh->in_buffer_size = 0;\n                }\n            }\n        }\n      else /* 0 < res */\n        {\n          urh->in_buffer_used += res;\n          if (buf_size > (size_t)res)\n            urh->app.celi &= ~MHD_EPOLL_STATE_READ_READY;\n          else if (0 < gnutls_record_check_pending (connection->tls_session))\n            connection->tls_read_ready = true;\n        }\n      if (MHD_EPOLL_STATE_ERROR ==\n          ((MHD_EPOLL_STATE_ERROR | MHD_EPOLL_STATE_READ_READY) & urh->app.celi))\n        {\n          /* Unrecoverable error on socket was detected and all\n           * pending data was read from system buffers. */\n          /* Stop trying to read from this TLS socket. */\n          urh->in_buffer_size = 0;\n        }\n    }\n\n  /*\n   * handle reading from application\n   */\n  if ( (0 != (MHD_EPOLL_STATE_READ_READY & urh->mhd.celi)) &&\n       (urh->out_buffer_used < urh->out_buffer_size) )\n    {\n      ssize_t res;\n      size_t buf_size;\n\n      buf_size = urh->out_buffer_size - urh->out_buffer_used;\n      if (buf_size > MHD_SCKT_SEND_MAX_SIZE_)\n        buf_size = MHD_SCKT_SEND_MAX_SIZE_;\n\n      res = MHD_recv_ (urh->mhd.socket,\n                       &urh->out_buffer[urh->out_buffer_used],\n                       buf_size);\n      if (0 >= res)\n        {\n          const int err = MHD_socket_get_error_ ();\n          if ((0 == res) ||\n              ((! MHD_SCKT_ERR_IS_EINTR_ (err)) &&\n               (! MHD_SCKT_ERR_IS_LOW_RESOURCES_(err))))\n            {\n              urh->mhd.celi &= ~MHD_EPOLL_STATE_READ_READY;\n              if ((0 == res) ||\n                  (was_closed) ||\n                  (0 != (MHD_EPOLL_STATE_ERROR & urh->mhd.celi)) ||\n                  (! MHD_SCKT_ERR_IS_EAGAIN_ (err)))\n                {\n                  /* Socket disconnect/shutdown was detected;\n                   * Application signaled about closure of 'upgraded' socket;\n                   * or persistent / unrecoverable error. */\n                  /* Do not try to pull more data from application. */\n                  urh->out_buffer_size = 0;\n                }\n            }\n        }\n      else /* 0 < res */\n        {\n          urh->out_buffer_used += res;\n          if (buf_size > (size_t)res)\n            urh->mhd.celi &= ~MHD_EPOLL_STATE_READ_READY;\n        }\n      if ( (0 == (MHD_EPOLL_STATE_READ_READY & urh->mhd.celi)) &&\n           ( (0 != (MHD_EPOLL_STATE_ERROR & urh->mhd.celi)) ||\n             (was_closed) ) )\n        {\n          /* Unrecoverable error on socket was detected and all\n           * pending data was read from system buffers. */\n          /* Do not try to pull more data from application. */\n          urh->out_buffer_size = 0;\n        }\n    }\n\n  /*\n   * handle writing to remote HTTPS client\n   */\n  if ( (0 != (MHD_EPOLL_STATE_WRITE_READY & urh->app.celi)) &&\n       (urh->out_buffer_used > 0) )\n    {\n      ssize_t res;\n      size_t data_size;\n\n      data_size = urh->out_buffer_used;\n      if (data_size > SSIZE_MAX)\n        data_size = SSIZE_MAX;\n\n      res = gnutls_record_send (connection->tls_session,\n                                urh->out_buffer,\n                                data_size);\n      if (0 >= res)\n        {\n          if (GNUTLS_E_INTERRUPTED != res)\n            {\n              urh->app.celi &= ~MHD_EPOLL_STATE_WRITE_READY;\n              if (GNUTLS_E_INTERRUPTED != res)\n                {\n                  /* TLS connection shut down or\n                   * persistent / unrecoverable error. */\n#ifdef HAVE_MESSAGES\n                  MHD_DLOG (daemon,\n                            _(\"Failed to forward to remote client \" MHD_UNSIGNED_LONG_LONG_PRINTF \\\n                                \" bytes of data received from application: %s\\n\"),\n                            (MHD_UNSIGNED_LONG_LONG) urh->out_buffer_used,\n                            gnutls_strerror(res));\n#endif\n                  /* Discard any data unsent to remote. */\n                  urh->out_buffer_used = 0;\n                  /* Do not try to pull more data from application. */\n                  urh->out_buffer_size = 0;\n                  urh->mhd.celi &= ~MHD_EPOLL_STATE_READ_READY;\n                }\n            }\n        }\n      else /* 0 < res */\n        {\n          const size_t next_out_buffer_used = urh->out_buffer_used - res;\n          if (0 != next_out_buffer_used)\n            {\n              memmove (urh->out_buffer,\n                       &urh->out_buffer[res],\n                       next_out_buffer_used);\n              if (data_size > (size_t)res)\n                urh->app.celi &= ~MHD_EPOLL_STATE_WRITE_READY;\n            }\n          urh->out_buffer_used = next_out_buffer_used;\n        }\n      if ( (0 == urh->out_buffer_used) &&\n           (0 != (MHD_EPOLL_STATE_ERROR & urh->app.celi)) )\n        {\n          /* Unrecoverable error on socket was detected and all\n           * pending data was sent to remote. */\n          /* Do not try to send to remote anymore. */\n          urh->app.celi &= ~MHD_EPOLL_STATE_WRITE_READY;\n          /* Do not try to pull more data from application. */\n          urh->out_buffer_size = 0;\n          urh->mhd.celi &= ~MHD_EPOLL_STATE_READ_READY;\n        }\n    }\n\n  /*\n   * handle writing to application\n   */\n  if ( (0 != (MHD_EPOLL_STATE_WRITE_READY & urh->mhd.celi)) &&\n         (urh->in_buffer_used > 0) )\n    {\n      ssize_t res;\n      size_t data_size;\n\n      data_size = urh->in_buffer_used;\n      if (data_size > MHD_SCKT_SEND_MAX_SIZE_)\n        data_size = MHD_SCKT_SEND_MAX_SIZE_;\n\n      res = MHD_send_ (urh->mhd.socket,\n                       urh->in_buffer,\n                       data_size);\n      if (0 >= res)\n        {\n          const int err = MHD_socket_get_error_ ();\n          if ( (! MHD_SCKT_ERR_IS_EINTR_ (err)) &&\n               (! MHD_SCKT_ERR_IS_LOW_RESOURCES_(err)) )\n            {\n              urh->mhd.celi &= ~MHD_EPOLL_STATE_WRITE_READY;\n              if (! MHD_SCKT_ERR_IS_EAGAIN_ (err))\n                {\n                  /* Socketpair connection shut down or\n                   * persistent / unrecoverable error. */\n#ifdef HAVE_MESSAGES\n                  MHD_DLOG (daemon,\n                            _(\"Failed to forward to application \" MHD_UNSIGNED_LONG_LONG_PRINTF \\\n                                \" bytes of data received from remote side: %s\\n\"),\n                            (MHD_UNSIGNED_LONG_LONG) urh->in_buffer_used,\n                            MHD_socket_strerr_ (err));\n#endif\n                  /* Discard any data received form remote. */\n                  urh->in_buffer_used = 0;\n                  /* Reading from remote client is not required anymore. */\n                  urh->in_buffer_size = 0;\n                  urh->app.celi &= ~MHD_EPOLL_STATE_READ_READY;\n                  connection->tls_read_ready = false;\n                }\n            }\n        }\n      else /* 0 < res */\n        {\n          const size_t next_in_buffer_used = urh->in_buffer_used - res;\n          if (0 != next_in_buffer_used)\n            {\n              memmove (urh->in_buffer,\n                       &urh->in_buffer[res],\n                       next_in_buffer_used);\n              if (data_size > (size_t)res)\n                urh->mhd.celi &= ~MHD_EPOLL_STATE_WRITE_READY;\n            }\n          urh->in_buffer_used = next_in_buffer_used;\n        }\n      if ( (0 == urh->in_buffer_used) &&\n           (0 != (MHD_EPOLL_STATE_ERROR & urh->mhd.celi)) )\n        {\n          /* Do not try to push data to application. */\n          urh->mhd.celi &= ~MHD_EPOLL_STATE_WRITE_READY;\n          /* Reading from remote client is not required anymore. */\n          urh->in_buffer_size = 0;\n          urh->app.celi &= ~MHD_EPOLL_STATE_READ_READY;\n          connection->tls_read_ready = false;\n        }\n    }\n\n  /* Check whether data is present in TLS buffers\n   * and incoming forward buffer have some space. */\n  if ( (connection->tls_read_ready) &&\n       (urh->in_buffer_used < urh->in_buffer_size) &&\n       (0 == (daemon->options & MHD_USE_THREAD_PER_CONNECTION)) )\n    daemon->data_already_pending = true;\n\n  if ( (daemon->shutdown) &&\n       ( (0 != urh->out_buffer_size) ||\n         (0 != urh->out_buffer_used) ) )\n    {\n      /* Daemon shutting down, discard any remaining forward data. */\n#ifdef HAVE_MESSAGES\n      if (0 < urh->out_buffer_used)\n        MHD_DLOG (daemon,\n                  _(\"Failed to forward to remote client \" MHD_UNSIGNED_LONG_LONG_PRINTF \\\n                      \" bytes of data received from application: daemon shut down\\n\"),\n                  (MHD_UNSIGNED_LONG_LONG) urh->out_buffer_used);\n#endif\n      /* Discard any data unsent to remote. */\n      urh->out_buffer_used = 0;\n      /* Do not try to sent to remote anymore. */\n      urh->app.celi &= ~MHD_EPOLL_STATE_WRITE_READY;\n      /* Do not try to pull more data from application. */\n      urh->out_buffer_size = 0;\n      urh->mhd.celi &= ~MHD_EPOLL_STATE_READ_READY;\n    }\n}",
      "lines": 336,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "thread_main_connection_upgrade": {
      "start_point": [
        1580,
        0
      ],
      "end_point": [
        1720,
        1
      ],
      "content": "static void\nthread_main_connection_upgrade (struct MHD_Connection *con)\n{\n#ifdef HTTPS_SUPPORT\n  struct MHD_UpgradeResponseHandle *urh = con->urh;\n  struct MHD_Daemon *daemon = con->daemon;\n\n  /* Here, we need to bi-directionally forward\n     until the application tells us that it is done\n     with the socket; */\n  if ( (0 != (daemon->options & MHD_USE_TLS)) &&\n      (0 == (daemon->options & MHD_USE_POLL)))\n    {\n      while ( (0 != urh->in_buffer_size) ||\n              (0 != urh->out_buffer_size) ||\n              (0 != urh->in_buffer_used) ||\n              (0 != urh->out_buffer_used) )\n        {\n          /* use select */\n          fd_set rs;\n          fd_set ws;\n          fd_set es;\n          MHD_socket max_fd;\n          int num_ready;\n          bool result;\n\n          FD_ZERO (&rs);\n          FD_ZERO (&ws);\n          FD_ZERO (&es);\n          max_fd = MHD_INVALID_SOCKET;\n          result = urh_to_fdset (urh,\n                                 &rs,\n                                 &ws,\n                                 &es,\n                                 &max_fd,\n                                 FD_SETSIZE);\n          if (! result)\n            {\n#ifdef HAVE_MESSAGES\n              MHD_DLOG (con->daemon,\n                        _(\"Error preparing select\\n\"));\n#endif\n              break;\n            }\n          /* FIXME: does this check really needed? */\n          if (MHD_INVALID_SOCKET != max_fd)\n            {\n              struct timeval* tvp;\n              struct timeval tv;\n              if ( (con->tls_read_ready) &&\n                   (urh->in_buffer_used < urh->in_buffer_size))\n                { /* No need to wait if incoming data is already pending in TLS buffers. */\n                  tv.tv_sec = 0;\n                  tv.tv_usec = 0;\n                  tvp = &tv;\n                }\n              else\n                tvp = NULL;\n              num_ready = MHD_SYS_select_ (max_fd + 1,\n                                           &rs,\n                                           &ws,\n                                           &es,\n                                           tvp);\n            }\n          else\n            num_ready = 0;\n          if (num_ready < 0)\n            {\n              const int err = MHD_socket_get_error_();\n\n              if (MHD_SCKT_ERR_IS_EINTR_(err))\n                continue;\n#ifdef HAVE_MESSAGES\n              MHD_DLOG (con->daemon,\n                        _(\"Error during select (%d): `%s'\\n\"),\n                        err,\n                        MHD_socket_strerr_ (err));\n#endif\n              break;\n            }\n          urh_from_fdset (urh,\n                          &rs,\n                          &ws,\n                          &es);\n          process_urh (urh);\n        }\n    }\n#ifdef HAVE_POLL\n  else if (0 != (daemon->options & MHD_USE_TLS))\n    {\n      /* use poll() */\n      struct pollfd p[2];\n      memset (p,\n              0,\n              sizeof (p));\n      p[0].fd = urh->connection->socket_fd;\n      p[1].fd = urh->mhd.socket;\n\n      while ( (0 != urh->in_buffer_size) ||\n              (0 != urh->out_buffer_size) ||\n              (0 != urh->in_buffer_used) ||\n              (0 != urh->out_buffer_used) )\n        {\n          int timeout;\n\n          urh_update_pollfd(urh, p);\n\n          if ( (con->tls_read_ready) &&\n               (urh->in_buffer_used < urh->in_buffer_size))\n            timeout = 0; /* No need to wait if incoming data is already pending in TLS buffers. */\n          else\n            timeout = -1;\n\n          if (MHD_sys_poll_ (p,\n                             2,\n                             timeout) < 0)\n            {\n              const int err = MHD_socket_get_error_ ();\n\n              if (MHD_SCKT_ERR_IS_EINTR_ (err))\n                continue;\n#ifdef HAVE_MESSAGES\n              MHD_DLOG (con->daemon,\n                        _(\"Error during poll: `%s'\\n\"),\n                        MHD_socket_strerr_ (err));\n#endif\n              break;\n            }\n          urh_from_pollfd(urh, p);\n          process_urh (urh);\n        }\n    }\n  /* end POLL */\n#endif\n  /* end HTTPS */\n#endif /* HTTPS_SUPPORT */\n  /* TLS forwarding was finished. Cleanup socketpair. */\n  MHD_connection_finish_forward_ (con);\n  /* Do not set 'urh->clean_ready' yet as 'urh' will be used\n   * in connection thread for a little while. */\n}",
      "lines": 141,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "thread_main_handle_connection": {
      "start_point": [
        1731,
        0
      ],
      "end_point": [
        2098,
        1
      ],
      "content": "static MHD_THRD_RTRN_TYPE_ MHD_THRD_CALL_SPEC_\nthread_main_handle_connection (void *data)\n{\n  struct MHD_Connection *con = data;\n  struct MHD_Daemon *daemon = con->daemon;\n  int num_ready;\n  fd_set rs;\n  fd_set ws;\n  fd_set es;\n  MHD_socket maxsock;\n  struct timeval tv;\n  struct timeval *tvp;\n  time_t now;\n#if WINDOWS\n#ifdef HAVE_POLL\n  int extra_slot;\n#endif /* HAVE_POLL */\n#define EXTRA_SLOTS 1\n#else  /* !WINDOWS */\n#define EXTRA_SLOTS 0\n#endif /* !WINDOWS */\n#ifdef HAVE_POLL\n  struct pollfd p[1 + EXTRA_SLOTS];\n#endif\n#undef EXTRA_SLOTS\n#ifdef HAVE_POLL\n  const bool use_poll = (0 != (daemon->options & MHD_USE_POLL));\n#else  /* ! HAVE_POLL */\n  const bool use_poll = 0;\n#endif /* ! HAVE_POLL */\n  bool was_suspended = false;\n  MHD_thread_init_(&(con->pid));\n\n  while ( (! daemon->shutdown) &&\n\t  (MHD_CONNECTION_CLOSED != con->state) )\n    {\n      const time_t timeout = daemon->connection_timeout;\n#ifdef UPGRADE_SUPPORT\n      struct MHD_UpgradeResponseHandle * const urh = con->urh;\n#else  /* ! UPGRADE_SUPPORT */\n      static const void * const urh = NULL;\n#endif /* ! UPGRADE_SUPPORT */\n\n      if ( (con->suspended) &&\n           (NULL == urh) )\n        {\n          /* Connection was suspended, wait for resume. */\n          was_suspended = true;\n          if (! use_poll)\n            {\n              FD_ZERO (&rs);\n              if (! MHD_add_to_fd_set_ (MHD_itc_r_fd_ (daemon->itc),\n                                        &rs,\n                                        NULL,\n                                        FD_SETSIZE))\n                {\n  #ifdef HAVE_MESSAGES\n                  MHD_DLOG (con->daemon,\n                            _(\"Failed to add FD to fd_set\\n\"));\n  #endif\n                  goto exit;\n                }\n              if (0 > MHD_SYS_select_ (MHD_itc_r_fd_ (daemon->itc) + 1,\n                                       &rs,\n                                       NULL,\n                                       NULL,\n                                       NULL))\n                {\n                  const int err = MHD_socket_get_error_();\n\n                  if (MHD_SCKT_ERR_IS_EINTR_(err))\n                    continue;\n#ifdef HAVE_MESSAGES\n                  MHD_DLOG (con->daemon,\n                            _(\"Error during select (%d): `%s'\\n\"),\n                            err,\n                            MHD_socket_strerr_ (err));\n#endif\n                  break;\n                }\n            }\n#ifdef HAVE_POLL\n          else /* use_poll */\n            {\n              p[0].events = POLLIN;\n              p[0].fd = MHD_itc_r_fd_ (daemon->itc);\n              p[0].revents = 0;\n              if (0 > MHD_sys_poll_ (p,\n                                     1,\n                                     -1))\n                {\n                  if (MHD_SCKT_LAST_ERR_IS_(MHD_SCKT_EINTR_))\n                    continue;\n#ifdef HAVE_MESSAGES\n                  MHD_DLOG (con->daemon,\n                            _(\"Error during poll: `%s'\\n\"),\n                            MHD_socket_last_strerr_ ());\n#endif\n                  break;\n                }\n            }\n#endif /* HAVE_POLL */\n          MHD_itc_clear_ (daemon->itc);\n          continue; /* Check again for resume. */\n        } /* End of \"suspended\" branch. */\n\n      if (was_suspended)\n        {\n          MHD_update_last_activity_ (con); /* Reset timeout timer. */\n          /* Process response queued during suspend and update states. */\n          MHD_connection_handle_idle (con);\n          was_suspended = false;\n        }\n\n      tvp = NULL;\n\n      if ( (MHD_EVENT_LOOP_INFO_BLOCK == con->event_loop_info)\n#ifdef HTTPS_SUPPORT\n           || ( (con->tls_read_ready) &&\n                (MHD_EVENT_LOOP_INFO_READ == con->event_loop_info) )\n#endif /* HTTPS_SUPPORT */\n         )\n\t{\n\t  /* do not block: more data may be inside of TLS buffers waiting or\n\t   * application must provide response data */\n\t  tv.tv_sec = 0;\n\t  tv.tv_usec = 0;\n\t  tvp = &tv;\n\t}\n      if ( (NULL == tvp) &&\n           (timeout > 0) )\n\t{\n\t  now = MHD_monotonic_sec_counter();\n\t  if (now - con->last_activity > timeout)\n\t    tv.tv_sec = 0;\n          else\n            {\n              const time_t seconds_left = timeout - (now - con->last_activity);\n#if !defined(_WIN32) || defined(__CYGWIN__)\n              tv.tv_sec = seconds_left;\n#else  /* _WIN32 && !__CYGWIN__ */\n              if (seconds_left > TIMEVAL_TV_SEC_MAX)\n                tv.tv_sec = TIMEVAL_TV_SEC_MAX;\n              else\n                tv.tv_sec = (_MHD_TIMEVAL_TV_SEC_TYPE) seconds_left;\n#endif /* _WIN32 && ! __CYGWIN__  */\n            }\n\t  tv.tv_usec = 0;\n\t  tvp = &tv;\n\t}\n      if (! use_poll)\n\t{\n\t  /* use select */\n\t  bool err_state = false;\n\n\t  FD_ZERO (&rs);\n\t  FD_ZERO (&ws);\n          FD_ZERO (&es);\n\t  maxsock = MHD_INVALID_SOCKET;\n\t  switch (con->event_loop_info)\n\t    {\n\t    case MHD_EVENT_LOOP_INFO_READ:\n\t      if (! MHD_add_to_fd_set_ (con->socket_fd,\n                                        &rs,\n                                        &maxsock,\n                                        FD_SETSIZE))\n\t        err_state = true;\n\t      break;\n\t    case MHD_EVENT_LOOP_INFO_WRITE:\n\t      if (! MHD_add_to_fd_set_ (con->socket_fd,\n                                        &ws,\n                                        &maxsock,\n                                        FD_SETSIZE))\n                err_state = true;\n\t      break;\n\t    case MHD_EVENT_LOOP_INFO_BLOCK:\n\t      if (! MHD_add_to_fd_set_ (con->socket_fd,\n                                        &es,\n                                        &maxsock,\n                                        FD_SETSIZE))\n\t        err_state = true;\n\t      break;\n\t    case MHD_EVENT_LOOP_INFO_CLEANUP:\n\t      /* how did we get here!? */\n\t      goto exit;\n\t    }\n#if WINDOWS\n          if (MHD_ITC_IS_VALID_(daemon->itc) )\n            {\n              if (! MHD_add_to_fd_set_ (MHD_itc_r_fd_ (daemon->itc),\n                                        &rs,\n                                        &maxsock,\n                                        FD_SETSIZE))\n                err_state = 1;\n            }\n#endif\n            if (err_state)\n              {\n#ifdef HAVE_MESSAGES\n                MHD_DLOG (con->daemon,\n                          _(\"Failed to add FD to fd_set\\n\"));\n#endif\n                goto exit;\n              }\n\n\t  num_ready = MHD_SYS_select_ (maxsock + 1,\n                                       &rs,\n                                       &ws,\n                                       NULL,\n                                       tvp);\n\t  if (num_ready < 0)\n\t    {\n\t      const int err = MHD_socket_get_error_();\n\n\t      if (MHD_SCKT_ERR_IS_EINTR_(err))\n\t\tcontinue;\n#ifdef HAVE_MESSAGES\n\t      MHD_DLOG (con->daemon,\n\t\t\t_(\"Error during select (%d): `%s'\\n\"),\n\t\t\terr,\n\t\t\tMHD_socket_strerr_ (err));\n#endif\n\t      break;\n\t    }\n#if WINDOWS\n          /* Clear ITC before other processing so additional\n           * signals will trigger select() again */\n          if ( (MHD_ITC_IS_VALID_(daemon->itc)) &&\n               (FD_ISSET (MHD_itc_r_fd_ (daemon->itc),\n                          &rs)) )\n            MHD_itc_clear_ (daemon->itc);\n#endif\n          if (MHD_NO ==\n              call_handlers (con,\n                             FD_ISSET (con->socket_fd,\n                                       &rs),\n                             FD_ISSET (con->socket_fd,\n                                       &ws),\n                             FD_ISSET (con->socket_fd,\n                                       &es)) )\n            goto exit;\n\t}\n#ifdef HAVE_POLL\n      else\n\t{\n\t  /* use poll */\n\t  memset (&p,\n                  0,\n                  sizeof (p));\n\t  p[0].fd = con->socket_fd;\n\t  switch (con->event_loop_info)\n\t    {\n\t    case MHD_EVENT_LOOP_INFO_READ:\n\t      p[0].events |= POLLIN | MHD_POLL_EVENTS_ERR_DISC;\n\t      break;\n\t    case MHD_EVENT_LOOP_INFO_WRITE:\n\t      p[0].events |= POLLOUT | MHD_POLL_EVENTS_ERR_DISC;\n\t      break;\n\t    case MHD_EVENT_LOOP_INFO_BLOCK:\n\t      p[0].events |= MHD_POLL_EVENTS_ERR_DISC;\n\t      break;\n\t    case MHD_EVENT_LOOP_INFO_CLEANUP:\n\t      /* how did we get here!? */\n\t      goto exit;\n\t    }\n#if WINDOWS\n          extra_slot = 0;\n          if (MHD_ITC_IS_VALID_(daemon->itc))\n            {\n              p[1].events |= POLLIN;\n              p[1].fd = MHD_itc_r_fd_ (daemon->itc);\n              p[1].revents = 0;\n              extra_slot = 1;\n            }\n#endif\n\t  if (MHD_sys_poll_ (p,\n#if WINDOWS\n                             1 + extra_slot,\n#else\n                             1,\n#endif\n                             (NULL == tvp) ? -1 : tv.tv_sec * 1000) < 0)\n\t    {\n\t      if (MHD_SCKT_LAST_ERR_IS_(MHD_SCKT_EINTR_))\n\t\tcontinue;\n#ifdef HAVE_MESSAGES\n\t      MHD_DLOG (con->daemon,\n                        _(\"Error during poll: `%s'\\n\"),\n\t\t\tMHD_socket_last_strerr_ ());\n#endif\n\t      break;\n\t    }\n#if WINDOWS\n          /* Clear ITC before other processing so additional\n           * signals will trigger poll() again */\n          if ( (MHD_ITC_IS_VALID_(daemon->itc)) &&\n               (0 != (p[1].revents & (POLLERR | POLLHUP | POLLIN))) )\n            MHD_itc_clear_ (daemon->itc);\n#endif\n          if (MHD_NO ==\n              call_handlers (con,\n                             0 != (p[0].revents & POLLIN),\n                             0 != (p[0].revents & POLLOUT),\n                             0 != (p[0].revents & (POLLERR | MHD_POLL_REVENTS_ERR_DISC))))\n            goto exit;\n\t}\n#endif\n#ifdef UPGRADE_SUPPORT\n      if (MHD_CONNECTION_UPGRADE == con->state)\n        {\n          /* Normal HTTP processing is finished,\n           * notify application. */\n          if ( (NULL != daemon->notify_completed) &&\n               (con->client_aware) )\n            daemon->notify_completed (daemon->notify_completed_cls,\n                                      con,\n                                      &con->client_context,\n                                      MHD_REQUEST_TERMINATED_COMPLETED_OK);\n          con->client_aware = false;\n\n          thread_main_connection_upgrade (con);\n          /* MHD_connection_finish_forward_() was called by thread_main_connection_upgrade(). */\n\n          /* \"Upgraded\" data will not be used in this thread from this point. */\n          con->urh->clean_ready = true;\n          /* If 'urh->was_closed' set to true, connection will be\n           * moved immediately to cleanup list. Otherwise connection\n           * will stay in suspended list until 'urh' will be marked\n           * with 'was_closed' by application. */\n          MHD_resume_connection(con);\n\n          /* skip usual clean up  */\n          return (MHD_THRD_RTRN_TYPE_) 0;\n        }\n#endif /* UPGRADE_SUPPORT */\n    }\n  if (MHD_CONNECTION_IN_CLEANUP != con->state)\n    {\n#if DEBUG_CLOSE\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (con->daemon,\n                _(\"Processing thread terminating. Closing connection\\n\"));\n#endif\n#endif\n      if (MHD_CONNECTION_CLOSED != con->state)\n\tMHD_connection_close_ (con,\n                               (daemon->shutdown) ?\n                               MHD_REQUEST_TERMINATED_DAEMON_SHUTDOWN:\n                               MHD_REQUEST_TERMINATED_WITH_ERROR);\n      MHD_connection_handle_idle (con);\n    }\nexit:\n  if (NULL != con->response)\n    {\n      MHD_destroy_response (con->response);\n      con->response = NULL;\n    }\n\n  if (MHD_INVALID_SOCKET != con->socket_fd)\n    {\n      shutdown (con->socket_fd,\n                SHUT_WR);\n      /* 'socket_fd' can be used in other thread to signal shutdown.\n       * To avoid data races, do not close socket here. Daemon will\n       * use more connections only after cleanup anyway. */\n    }\n  return (MHD_THRD_RTRN_TYPE_) 0;\n}",
      "lines": 368,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "MHD_THRD_RTRN_TYPE_",
        "MHD_THRD_CALL_SPEC_",
        "MHD_THRD_CALL_SPEC_"
      ]
    },
    "MHD_tls_push_func_": {
      "start_point": [
        2127,
        0
      ],
      "end_point": [
        2137,
        1
      ],
      "content": "static ssize_t\nMHD_tls_push_func_(gnutls_transport_ptr_t trnsp,\n                   const void *data,\n                   size_t data_size)\n{\n#if (MHD_SCKT_SEND_MAX_SIZE_ < SSIZE_MAX) || (0 == SSIZE_MAX)\n  if (data_size > MHD_SCKT_SEND_MAX_SIZE_)\n    data_size = MHD_SCKT_SEND_MAX_SIZE_;\n#endif /* (MHD_SCKT_SEND_MAX_SIZE_ < SSIZE_MAX) || (0 == SSIZE_MAX) */\n  return MHD_send_ ((MHD_socket)(intptr_t)(trnsp), data, data_size);\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "ssize_t"
      ]
    },
    "internal_add_connection": {
      "start_point": [
        2166,
        0
      ],
      "end_point": [
        2545,
        1
      ],
      "content": "static int\ninternal_add_connection (struct MHD_Daemon *daemon,\n\t\t\t MHD_socket client_socket,\n\t\t\t const struct sockaddr *addr,\n\t\t\t socklen_t addrlen,\n\t\t\t bool external_add,\n\t\t\t bool non_blck)\n{\n  struct MHD_Connection *connection;\n  unsigned int i;\n  int eno = 0;\n\n  /* Direct add to master daemon could happen only with \"external\" add mode. */\n  mhd_assert ((NULL == daemon->worker_pool) || (external_add));\n  if ((external_add) && (NULL != daemon->worker_pool))\n    {\n      /* have a pool, try to find a pool with capacity; we use the\n\t socket as the initial offset into the pool for load\n\t balancing */\n      for (i = 0; i < daemon->worker_pool_size; ++i)\n        {\n          struct MHD_Daemon * const worker =\n                &daemon->worker_pool[(i + client_socket) % daemon->worker_pool_size];\n          if (worker->connections < worker->connection_limit)\n            return internal_add_connection (worker,\n                                            client_socket,\n                                            addr,\n                                            addrlen,\n                                            true,\n                                            non_blck);\n        }\n      /* all pools are at their connection limit, must refuse */\n      MHD_socket_close_chk_ (client_socket);\n#if ENFILE\n      errno = ENFILE;\n#endif\n      return MHD_NO;\n    }\n\n  if ( (! MHD_SCKT_FD_FITS_FDSET_(client_socket,\n                                  NULL)) &&\n       (0 == (daemon->options & (MHD_USE_POLL | MHD_USE_EPOLL))) )\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n\t\t_(\"Socket descriptor larger than FD_SETSIZE: %d > %d\\n\"),\n\t\t(int) client_socket,\n\t\t(int) FD_SETSIZE);\n#endif\n      MHD_socket_close_chk_ (client_socket);\n#if EINVAL\n      errno = EINVAL;\n#endif\n      return MHD_NO;\n    }\n\n#ifdef MHD_socket_nosignal_\n  if (! MHD_socket_nosignal_ (client_socket))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _(\"Failed to set SO_NOSIGPIPE on accepted socket: %s\\n\"),\n                MHD_socket_last_strerr_());\n#endif\n#ifndef MSG_NOSIGNAL\n      /* Cannot use socket as it can produce SIGPIPE. */\n#ifdef ENOTSOCK\n      errno = ENOTSOCK;\n#endif /* ENOTSOCK */\n      return MHD_NO;\n#endif /* ! MSG_NOSIGNAL */\n    }\n#endif /* MHD_socket_nosignal_ */\n\n\n#ifdef HAVE_MESSAGES\n#if DEBUG_CONNECT\n  MHD_DLOG (daemon,\n            _(\"Accepted connection on socket %d\\n\"),\n            client_socket);\n#endif\n#endif\n  if ( (daemon->connections == daemon->connection_limit) ||\n       (MHD_NO == MHD_ip_limit_add (daemon,\n                                    addr,\n                                    addrlen)) )\n    {\n      /* above connection limit - reject */\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _(\"Server reached connection limit. Closing inbound connection.\\n\"));\n#endif\n      MHD_socket_close_chk_ (client_socket);\n#if ENFILE\n      errno = ENFILE;\n#endif\n      return MHD_NO;\n    }\n\n  /* apply connection acceptance policy if present */\n  if ( (NULL != daemon->apc) &&\n       (MHD_NO == daemon->apc (daemon->apc_cls,\n\t\t\t       addr,\n                               addrlen)) )\n    {\n#if DEBUG_CLOSE\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _(\"Connection rejected by application. Closing connection.\\n\"));\n#endif\n#endif\n      MHD_socket_close_chk_ (client_socket);\n      MHD_ip_limit_del (daemon,\n                        addr,\n                        addrlen);\n#if EACCESS\n      errno = EACCESS;\n#endif\n      return MHD_NO;\n    }\n\n  if (NULL == (connection = MHD_calloc_ (1, sizeof (struct MHD_Connection))))\n    {\n      eno = errno;\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n\t\t\"Error allocating memory: %s\\n\",\n\t\tMHD_strerror_ (errno));\n#endif\n      MHD_socket_close_chk_ (client_socket);\n      MHD_ip_limit_del (daemon,\n                        addr,\n                        addrlen);\n      errno = eno;\n      return MHD_NO;\n    }\n  connection->pool = MHD_pool_create (daemon->pool_size);\n  if (NULL == connection->pool)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n\t\t_(\"Error allocating memory: %s\\n\"),\n\t\tMHD_strerror_ (errno));\n#endif\n      MHD_socket_close_chk_ (client_socket);\n      MHD_ip_limit_del (daemon,\n                        addr,\n                        addrlen);\n      free (connection);\n#if ENOMEM\n      errno = ENOMEM;\n#endif\n      return MHD_NO;\n    }\n\n  connection->connection_timeout = daemon->connection_timeout;\n  if (NULL == (connection->addr = malloc (addrlen)))\n    {\n      eno = errno;\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n\t\t_(\"Error allocating memory: %s\\n\"),\n\t\tMHD_strerror_ (errno));\n#endif\n      MHD_socket_close_chk_ (client_socket);\n      MHD_ip_limit_del (daemon,\n                        addr,\n                        addrlen);\n      MHD_pool_destroy (connection->pool);\n      free (connection);\n      errno = eno;\n      return MHD_NO;\n    }\n  memcpy (connection->addr,\n          addr,\n          addrlen);\n  connection->addr_len = addrlen;\n  connection->socket_fd = client_socket;\n  connection->sk_nonblck = non_blck;\n  connection->daemon = daemon;\n  connection->last_activity = MHD_monotonic_sec_counter();\n\n  if (0 == (daemon->options & MHD_USE_TLS))\n    {\n      /* set default connection handlers  */\n      MHD_set_http_callbacks_ (connection);\n    }\n  else\n    {\n#ifdef HTTPS_SUPPORT\n      connection->tls_state = MHD_TLS_CONN_INIT;\n      MHD_set_https_callbacks (connection);\n      gnutls_init (&connection->tls_session,\n                   GNUTLS_SERVER\n#if (GNUTLS_VERSION_NUMBER+0 >= 0x030402)\n                   | GNUTLS_NO_SIGNAL\n#endif /* GNUTLS_VERSION_NUMBER >= 0x030402 */\n#if GNUTLS_VERSION_MAJOR >= 3\n                   | GNUTLS_NONBLOCK\n#endif /* GNUTLS_VERSION_MAJOR >= 3*/\n                  );\n      gnutls_priority_set (connection->tls_session,\n\t\t\t   daemon->priority_cache);\n      switch (daemon->cred_type)\n        {\n          /* set needed credentials for certificate authentication. */\n        case GNUTLS_CRD_CERTIFICATE:\n          gnutls_credentials_set (connection->tls_session,\n\t\t\t\t  GNUTLS_CRD_CERTIFICATE,\n\t\t\t\t  daemon->x509_cred);\n          break;\n        default:\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (connection->daemon,\n                    _(\"Failed to setup TLS credentials: unknown credential type %d\\n\"),\n                    daemon->cred_type);\n#endif\n          MHD_socket_close_chk_ (client_socket);\n          MHD_ip_limit_del (daemon,\n                            addr,\n                            addrlen);\n          free (connection->addr);\n          free (connection);\n          MHD_PANIC (_(\"Unknown credential type\"));\n#if EINVAL\n\t  errno = EINVAL;\n#endif\n \t  return MHD_NO;\n        }\n#if (GNUTLS_VERSION_NUMBER+0 >= 0x030109) && !defined(_WIN64)\n      gnutls_transport_set_int (connection->tls_session, (int)(client_socket));\n#else  /* GnuTLS before 3.1.9 or Win x64 */\n      gnutls_transport_set_ptr (connection->tls_session, (gnutls_transport_ptr_t)(intptr_t)(client_socket));\n#endif /* GnuTLS before 3.1.9 */\n#ifdef MHD_TLSLIB_NEED_PUSH_FUNC\n      gnutls_transport_set_push_function (connection->tls_session, MHD_tls_push_func_);\n#endif /* MHD_TLSLIB_NEED_PUSH_FUNC */\n      if (daemon->https_mem_trust)\n\t  gnutls_certificate_server_set_request (connection->tls_session,\n\t\t\t\t\t\t GNUTLS_CERT_REQUEST);\n#else  /* ! HTTPS_SUPPORT */\n      eno = EINVAL;\n      goto cleanup;\n#endif /* ! HTTPS_SUPPORT */\n    }\n\n\n  MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n  /* Firm check under lock. */\n  if (daemon->connections >= daemon->connection_limit)\n    {\n      MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n      /* above connection limit - reject */\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _(\"Server reached connection limit. Closing inbound connection.\\n\"));\n#endif\n#if ENFILE\n      eno = ENFILE;\n#endif\n      goto cleanup;\n    }\n  daemon->connections++;\n  if (0 == (daemon->options & MHD_USE_THREAD_PER_CONNECTION))\n    {\n      XDLL_insert (daemon->normal_timeout_head,\n                   daemon->normal_timeout_tail,\n                   connection);\n    }\n  DLL_insert (daemon->connections_head,\n\t      daemon->connections_tail,\n\t      connection);\n  MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n\n  if (NULL != daemon->notify_connection)\n    daemon->notify_connection (daemon->notify_connection_cls,\n                               connection,\n                               &connection->socket_context,\n                               MHD_CONNECTION_NOTIFY_STARTED);\n\n  /* attempt to create handler thread */\n  if (0 != (daemon->options & MHD_USE_THREAD_PER_CONNECTION))\n    {\n      if (! MHD_create_named_thread_ (&connection->pid,\n                                      \"MHD-connection\",\n                                      daemon->thread_stack_size,\n                                      &thread_main_handle_connection,\n                                      connection))\n        {\n\t  eno = errno;\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (daemon,\n                    \"Failed to create a thread: %s\\n\",\n                    MHD_strerror_ (eno));\n#endif\n\t  goto cleanup;\n        }\n    }\n  else\n    connection->pid = daemon->pid;\n#ifdef EPOLL_SUPPORT\n  if (0 != (daemon->options & MHD_USE_EPOLL))\n    {\n      if ((0 == (daemon->options & MHD_USE_TURBO)) || (external_add))\n\t{ /* Do not manipulate EReady DL-list in 'external_add' mode. */\n\t  struct epoll_event event;\n\n\t  event.events = EPOLLIN | EPOLLOUT | EPOLLPRI | EPOLLET;\n\t  event.data.ptr = connection;\n\t  if (0 != epoll_ctl (daemon->epoll_fd,\n\t\t\t      EPOLL_CTL_ADD,\n\t\t\t      client_socket,\n\t\t\t      &event))\n\t    {\n\t      eno = errno;\n#ifdef HAVE_MESSAGES\n              MHD_DLOG (daemon,\n                        _(\"Call to epoll_ctl failed: %s\\n\"),\n                        MHD_socket_last_strerr_ ());\n#endif\n\t      goto cleanup;\n\t    }\n\t  connection->epoll_state |= MHD_EPOLL_STATE_IN_EPOLL_SET;\n\t}\n      else\n\t{\n\t  connection->epoll_state |= MHD_EPOLL_STATE_READ_READY | MHD_EPOLL_STATE_WRITE_READY\n\t    | MHD_EPOLL_STATE_IN_EREADY_EDLL;\n\t  EDLL_insert (daemon->eready_head,\n\t\t       daemon->eready_tail,\n\t\t       connection);\n\t}\n    }\n  else /* This 'else' is combined with next 'if'. */\n#endif\n  if ( (0 == (daemon->options & MHD_USE_THREAD_PER_CONNECTION)) &&\n       (external_add) &&\n       (MHD_ITC_IS_VALID_(daemon->itc)) &&\n       (! MHD_itc_activate_ (daemon->itc, \"n\")) )\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _(\"Failed to signal new connection via inter-thread communication channel.\"));\n#endif\n    }\n  return MHD_YES;\n cleanup:\n  if (NULL != daemon->notify_connection)\n    daemon->notify_connection (daemon->notify_connection_cls,\n                               connection,\n                               &connection->socket_context,\n                               MHD_CONNECTION_NOTIFY_CLOSED);\n#ifdef HTTPS_SUPPORT\n if (NULL != connection->tls_session)\n   gnutls_deinit (connection->tls_session);\n#endif /* HTTPS_SUPPORT */\n  MHD_socket_close_chk_ (client_socket);\n  MHD_ip_limit_del (daemon,\n                    addr,\n                    addrlen);\n  MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n  if (0 == (daemon->options & MHD_USE_THREAD_PER_CONNECTION))\n    {\n      XDLL_remove (daemon->normal_timeout_head,\n                   daemon->normal_timeout_tail,\n                   connection);\n    }\n  DLL_remove (daemon->connections_head,\n\t      daemon->connections_tail,\n\t      connection);\n  MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n  MHD_pool_destroy (connection->pool);\n  free (connection->addr);\n  free (connection);\n  if (0 != eno)\n    errno = eno;\n  else\n    errno  = EINVAL;\n  return MHD_NO;\n}",
      "lines": 380,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "internal_suspend_connection_": {
      "start_point": [
        2557,
        0
      ],
      "end_point": [
        2612,
        1
      ],
      "content": "void\ninternal_suspend_connection_ (struct MHD_Connection *connection)\n{\n  struct MHD_Daemon *daemon = connection->daemon;\n\n  MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n  if (connection->resuming)\n    {\n      /* suspending again while we didn't even complete resuming yet */\n      connection->resuming = false;\n      MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n      return;\n    }\n  if (0 == (daemon->options & MHD_USE_THREAD_PER_CONNECTION))\n    {\n      if (connection->connection_timeout == daemon->connection_timeout)\n        XDLL_remove (daemon->normal_timeout_head,\n                     daemon->normal_timeout_tail,\n                     connection);\n      else\n        XDLL_remove (daemon->manual_timeout_head,\n                     daemon->manual_timeout_tail,\n                     connection);\n    }\n  DLL_remove (daemon->connections_head,\n              daemon->connections_tail,\n              connection);\n  mhd_assert (! connection->suspended);\n  DLL_insert (daemon->suspended_connections_head,\n              daemon->suspended_connections_tail,\n              connection);\n  connection->suspended = true;\n#ifdef EPOLL_SUPPORT\n  if (0 != (daemon->options & MHD_USE_EPOLL))\n    {\n      if (0 != (connection->epoll_state & MHD_EPOLL_STATE_IN_EREADY_EDLL))\n        {\n          EDLL_remove (daemon->eready_head,\n                       daemon->eready_tail,\n                       connection);\n          connection->epoll_state &= ~MHD_EPOLL_STATE_IN_EREADY_EDLL;\n        }\n      if (0 != (connection->epoll_state & MHD_EPOLL_STATE_IN_EPOLL_SET))\n        {\n          if (0 != epoll_ctl (daemon->epoll_fd,\n                              EPOLL_CTL_DEL,\n                              connection->socket_fd,\n                              NULL))\n            MHD_PANIC (_(\"Failed to remove FD from epoll set\\n\"));\n          connection->epoll_state &= ~MHD_EPOLL_STATE_IN_EPOLL_SET;\n        }\n      connection->epoll_state |= MHD_EPOLL_STATE_SUSPENDED;\n    }\n#endif\n  MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n}",
      "lines": 56,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "MHD_suspend_connection": {
      "start_point": [
        2646,
        0
      ],
      "end_point": [
        2664,
        1
      ],
      "content": "void\nMHD_suspend_connection (struct MHD_Connection *connection)\n{\n  struct MHD_Daemon * const daemon = connection->daemon;\n\n  if (0 == (daemon->options & MHD_TEST_ALLOW_SUSPEND_RESUME))\n    MHD_PANIC (_(\"Cannot suspend connections without enabling MHD_ALLOW_SUSPEND_RESUME!\\n\"));\n#ifdef UPGRADE_SUPPORT\n  if (NULL != connection->urh)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _(\"Error: connection scheduled for \\\"upgrade\\\" cannot be suspended\"));\n#endif /* HAVE_MESSAGES */\n      return;\n    }\n#endif /* UPGRADE_SUPPORT */\n  internal_suspend_connection_ (connection);\n}",
      "lines": 19,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "MHD_resume_connection": {
      "start_point": [
        2675,
        0
      ],
      "end_point": [
        2695,
        1
      ],
      "content": "void\nMHD_resume_connection (struct MHD_Connection *connection)\n{\n  struct MHD_Daemon *daemon;\n\n  daemon = connection->daemon;\n  if (0 == (daemon->options & MHD_TEST_ALLOW_SUSPEND_RESUME))\n    MHD_PANIC (_(\"Cannot resume connections without enabling MHD_ALLOW_SUSPEND_RESUME!\\n\"));\n  MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n  connection->resuming = true;\n  daemon->resuming = true;\n  MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n  if ( (MHD_ITC_IS_VALID_(daemon->itc)) &&\n       (! MHD_itc_activate_ (daemon->itc, \"r\")) )\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _(\"Failed to signal resume via inter-thread communication channel.\"));\n#endif\n    }\n}",
      "lines": 21,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "resume_suspended_connections": {
      "start_point": [
        2707,
        0
      ],
      "end_point": [
        2814,
        1
      ],
      "content": "static int\nresume_suspended_connections (struct MHD_Daemon *daemon)\n{\n  struct MHD_Connection *pos;\n  struct MHD_Connection *prev = NULL;\n  int ret;\n  const bool used_thr_p_c = (0 != (daemon->options & MHD_USE_THREAD_PER_CONNECTION));\n  mhd_assert (NULL == daemon->worker_pool);\n\n  ret = MHD_NO;\n  MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n\n  if (daemon->resuming)\n    {\n      prev = daemon->suspended_connections_tail;\n      /* During shutdown check for resuming is forced. */\n      mhd_assert((NULL != prev) || (daemon->shutdown));\n    }\n\n  daemon->resuming = false;\n\n  while (NULL != (pos = prev))\n    {\n#ifdef UPGRADE_SUPPORT\n      struct MHD_UpgradeResponseHandle * const urh = pos->urh;\n#else  /* ! UPGRADE_SUPPORT */\n      static const void * const urh = NULL;\n#endif /* ! UPGRADE_SUPPORT */\n      prev = pos->prev;\n      if ( (! pos->resuming)\n#ifdef UPGRADE_SUPPORT\n          || ( (NULL != urh) &&\n               ( (! urh->was_closed) ||\n                 (! urh->clean_ready) ) )\n#endif /* UPGRADE_SUPPORT */\n         )\n        continue;\n      ret = MHD_YES;\n      mhd_assert (pos->suspended);\n      DLL_remove (daemon->suspended_connections_head,\n                  daemon->suspended_connections_tail,\n                  pos);\n      pos->suspended = false;\n      if (NULL == urh)\n        {\n          DLL_insert (daemon->connections_head,\n                      daemon->connections_tail,\n                      pos);\n          if (!used_thr_p_c)\n            {\n              /* Reset timeout timer on resume. */\n              if (0 != pos->connection_timeout)\n                pos->last_activity = MHD_monotonic_sec_counter();\n\n              if (pos->connection_timeout == daemon->connection_timeout)\n                XDLL_insert (daemon->normal_timeout_head,\n                             daemon->normal_timeout_tail,\n                             pos);\n              else\n                XDLL_insert (daemon->manual_timeout_head,\n                             daemon->manual_timeout_tail,\n                             pos);\n            }\n#ifdef EPOLL_SUPPORT\n          if (0 != (daemon->options & MHD_USE_EPOLL))\n            {\n              if (0 != (pos->epoll_state & MHD_EPOLL_STATE_IN_EREADY_EDLL))\n                MHD_PANIC (\"Resumed connection was already in EREADY set\\n\");\n              /* we always mark resumed connections as ready, as we\n                 might have missed the edge poll event during suspension */\n              EDLL_insert (daemon->eready_head,\n                           daemon->eready_tail,\n                           pos);\n              pos->epoll_state |= MHD_EPOLL_STATE_IN_EREADY_EDLL | \\\n                  MHD_EPOLL_STATE_READ_READY | MHD_EPOLL_STATE_WRITE_READY;\n              pos->epoll_state &= ~MHD_EPOLL_STATE_SUSPENDED;\n            }\n#endif\n        }\n#ifdef UPGRADE_SUPPORT\n      else\n        {\n          /* Data forwarding was finished (for TLS connections) AND\n           * application was closed upgraded connection.\n           * Insert connection into cleanup list. */\n          DLL_insert (daemon->cleanup_head,\n                      daemon->cleanup_tail,\n                      pos);\n\n        }\n#endif /* UPGRADE_SUPPORT */\n      pos->resuming = false;\n    }\n  MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n  if ( (used_thr_p_c) &&\n       (MHD_NO != ret) )\n    { /* Wake up suspended connections. */\n      if (! MHD_itc_activate_(daemon->itc,\n                              \"w\"))\n\t{\n#ifdef HAVE_MESSAGES\n\t  MHD_DLOG (daemon,\n\t\t    _(\"Failed to signal resume of connection via inter-thread communication channel.\"));\n#endif\n\t}\n    }\n  return ret;\n}",
      "lines": 108,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "MHD_add_connection": {
      "start_point": [
        2844,
        0
      ],
      "end_point": [
        2877,
        1
      ],
      "content": "int\nMHD_add_connection (struct MHD_Daemon *daemon,\n\t\t    MHD_socket client_socket,\n\t\t    const struct sockaddr *addr,\n\t\t    socklen_t addrlen)\n{\n  bool sk_nonbl;\n  if (! MHD_socket_nonblocking_ (client_socket))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _(\"Failed to set nonblocking mode on new client socket: %s\\n\"),\n                MHD_socket_last_strerr_());\n#endif\n      sk_nonbl = 0;\n    }\n  else\n    sk_nonbl = !0;\n\n  if ( (0 != (daemon->options & MHD_USE_TURBO)) &&\n       (! MHD_socket_noninheritable_ (client_socket)) )\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _(\"Failed to set noninheritable mode on new client socket.\\n\"));\n#endif\n    }\n  return internal_add_connection (daemon,\n\t\t\t\t  client_socket,\n\t\t\t\t  addr,\n                                  addrlen,\n\t\t\t\t  true,\n\t\t\t\t  sk_nonbl);\n}",
      "lines": 34,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "MHD_accept_connection": {
      "start_point": [
        2894,
        0
      ],
      "end_point": [
        3010,
        1
      ],
      "content": "static int\nMHD_accept_connection (struct MHD_Daemon *daemon)\n{\n#if HAVE_INET6\n  struct sockaddr_in6 addrstorage;\n#else\n  struct sockaddr_in addrstorage;\n#endif\n  struct sockaddr *addr = (struct sockaddr *) &addrstorage;\n  socklen_t addrlen;\n  MHD_socket s;\n  MHD_socket fd;\n  bool sk_nonbl;\n\n  addrlen = sizeof (addrstorage);\n  memset (addr,\n          0,\n          sizeof (addrstorage));\n  if ( (MHD_INVALID_SOCKET == (fd = daemon->listen_fd)) ||\n       (daemon->was_quiesced) )\n    return MHD_NO;\n#ifdef USE_ACCEPT4\n  s = accept4 (fd,\n               addr,\n               &addrlen,\n               MAYBE_SOCK_CLOEXEC | MAYBE_SOCK_NONBLOCK);\n  sk_nonbl = (MAYBE_SOCK_NONBLOCK != 0);\n#else  /* ! USE_ACCEPT4 */\n  s = accept (fd,\n              addr,\n              &addrlen);\n  sk_nonbl = 0;\n#endif /* ! USE_ACCEPT4 */\n  if ( (MHD_INVALID_SOCKET == s) ||\n       (addrlen <= 0) )\n    {\n      const int err = MHD_socket_get_error_ ();\n\n      /* This could be a common occurance with multiple worker threads */\n      if (MHD_SCKT_ERR_IS_ (err,\n                            MHD_SCKT_EINVAL_))\n        return MHD_NO; /* can happen during shutdown */\n      if (MHD_SCKT_ERR_IS_DISCNN_BEFORE_ACCEPT_(err))\n        return MHD_NO; /* do not print error if client just disconnected early */\n#ifdef HAVE_MESSAGES\n      if (! MHD_SCKT_ERR_IS_EAGAIN_ (err) )\n        MHD_DLOG (daemon,\n\t\t  _(\"Error accepting connection: %s\\n\"),\n\t\t  MHD_socket_strerr_(err));\n#endif\n      if (MHD_INVALID_SOCKET != s)\n        {\n          MHD_socket_close_chk_ (s);\n        }\n      if ( MHD_SCKT_ERR_IS_LOW_RESOURCES_ (err) )\n        {\n          /* system/process out of resources */\n          if (0 == daemon->connections)\n            {\n#ifdef HAVE_MESSAGES\n              /* Not setting 'at_limit' flag, as there is no way it\n                 would ever be cleared.  Instead trying to produce\n                 bit fat ugly warning. */\n              MHD_DLOG (daemon,\n                        _(\"Hit process or system resource limit at FIRST connection. This is really bad as there is no sane way to proceed. Will try busy waiting for system resources to become magically available.\\n\"));\n#endif\n            }\n          else\n            {\n              MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n              daemon->at_limit = true;\n              MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n#ifdef HAVE_MESSAGES\n              MHD_DLOG (daemon,\n                        _(\"Hit process or system resource limit at %u connections, temporarily suspending accept(). Consider setting a lower MHD_OPTION_CONNECTION_LIMIT.\\n\"),\n                        (unsigned int) daemon->connections);\n#endif\n            }\n        }\n      return MHD_NO;\n    }\n#if !defined(USE_ACCEPT4) || !defined(HAVE_SOCK_NONBLOCK)\n  if (! MHD_socket_nonblocking_ (s))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _(\"Failed to set nonblocking mode on incoming connection socket: %s\\n\"),\n                MHD_socket_last_strerr_());\n#endif\n    }\n  else\n    sk_nonbl = !0;\n#endif /* !USE_ACCEPT4 || !HAVE_SOCK_NONBLOCK */\n#if !defined(USE_ACCEPT4) || !defined(SOCK_CLOEXEC)\n  if (! MHD_socket_noninheritable_ (s))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _(\"Failed to set noninheritable mode on incoming connection socket.\\n\"));\n#endif\n    }\n#endif /* !USE_ACCEPT4 || !SOCK_CLOEXEC */\n#ifdef HAVE_MESSAGES\n#if DEBUG_CONNECT\n  MHD_DLOG (daemon,\n            _(\"Accepted connection on socket %d\\n\"),\n            s);\n#endif\n#endif\n  (void) internal_add_connection (daemon,\n                                  s,\n\t\t\t\t  addr,\n                                  addrlen,\n\t\t\t\t  false,\n                                  sk_nonbl);\n  return MHD_YES;\n}",
      "lines": 117,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "MHD_cleanup_connections": {
      "start_point": [
        3022,
        0
      ],
      "end_point": [
        3101,
        1
      ],
      "content": "static void\nMHD_cleanup_connections (struct MHD_Daemon *daemon)\n{\n  struct MHD_Connection *pos;\n\n  MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n  while (NULL != (pos = daemon->cleanup_tail))\n    {\n      DLL_remove (daemon->cleanup_head,\n\t\t  daemon->cleanup_tail,\n\t\t  pos);\n      MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n\n      if ( (0 != (daemon->options & MHD_USE_THREAD_PER_CONNECTION)) &&\n\t   (! pos->thread_joined) &&\n           (! MHD_join_thread_ (pos->pid.handle)) )\n        MHD_PANIC (_(\"Failed to join a thread\\n\"));\n#ifdef UPGRADE_SUPPORT\n      cleanup_upgraded_connection (pos);\n#endif /* UPGRADE_SUPPORT */\n      MHD_pool_destroy (pos->pool);\n#ifdef HTTPS_SUPPORT\n      if (NULL != pos->tls_session)\n\tgnutls_deinit (pos->tls_session);\n#endif /* HTTPS_SUPPORT */\n\n      /* clean up the connection */\n      if (NULL != daemon->notify_connection)\n        daemon->notify_connection (daemon->notify_connection_cls,\n                                   pos,\n                                   &pos->socket_context,\n                                   MHD_CONNECTION_NOTIFY_CLOSED);\n      MHD_ip_limit_del (daemon,\n                        pos->addr,\n                        pos->addr_len);\n#ifdef EPOLL_SUPPORT\n      if (0 != (daemon->options & MHD_USE_EPOLL))\n        {\n          if (0 != (pos->epoll_state & MHD_EPOLL_STATE_IN_EREADY_EDLL))\n            {\n              EDLL_remove (daemon->eready_head,\n                           daemon->eready_tail,\n                           pos);\n              pos->epoll_state &= ~MHD_EPOLL_STATE_IN_EREADY_EDLL;\n            }\n          if ( (-1 != daemon->epoll_fd) &&\n               (0 != (pos->epoll_state & MHD_EPOLL_STATE_IN_EPOLL_SET)) )\n            {\n              /* epoll documentation suggests that closing a FD\n                 automatically removes it from the epoll set; however,\n                 this is not true as if we fail to do manually remove it,\n                 we are still seeing an event for this fd in epoll,\n                 causing grief (use-after-free...) --- at least on my\n                 system. */\n              if (0 != epoll_ctl (daemon->epoll_fd,\n                                  EPOLL_CTL_DEL,\n                                  pos->socket_fd,\n                                  NULL))\n                MHD_PANIC (_(\"Failed to remove FD from epoll set\\n\"));\n              pos->epoll_state &= ~MHD_EPOLL_STATE_IN_EPOLL_SET;\n            }\n        }\n#endif\n      if (NULL != pos->response)\n\t{\n\t  MHD_destroy_response (pos->response);\n\t  pos->response = NULL;\n\t}\n      if (MHD_INVALID_SOCKET != pos->socket_fd)\n        MHD_socket_close_chk_ (pos->socket_fd);\n      if (NULL != pos->addr)\n\tfree (pos->addr);\n      free (pos);\n\n      MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n      daemon->connections--;\n      daemon->at_limit = false;\n    }\n  MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n}",
      "lines": 80,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "MHD_get_timeout": {
      "start_point": [
        3124,
        0
      ],
      "end_point": [
        3200,
        1
      ],
      "content": "int\nMHD_get_timeout (struct MHD_Daemon *daemon,\n\t\t MHD_UNSIGNED_LONG_LONG *timeout)\n{\n  time_t earliest_deadline;\n  time_t now;\n  struct MHD_Connection *pos;\n  bool have_timeout;\n\n  if (0 != (daemon->options & MHD_USE_THREAD_PER_CONNECTION))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _(\"Illegal call to MHD_get_timeout\\n\"));\n#endif\n      return MHD_NO;\n    }\n\n  if (daemon->data_already_pending)\n    {\n      /* Some data already waiting to be processed. */\n      *timeout = 0;\n      return MHD_YES;\n    }\n\n#ifdef EPOLL_SUPPORT\n  if ( (0 != (daemon->options & MHD_USE_EPOLL)) &&\n       ((NULL != daemon->eready_head)\n#if defined(UPGRADE_SUPPORT) && defined(HTTPS_SUPPORT)\n\t || (NULL != daemon->eready_urh_head)\n#endif /* UPGRADE_SUPPORT && HTTPS_SUPPORT */\n\t ) )\n    {\n\t  /* Some connection(s) already have some data pending. */\n      *timeout = 0;\n      return MHD_YES;\n    }\n#endif /* EPOLL_SUPPORT */\n\n  have_timeout = false;\n  earliest_deadline = 0; /* avoid compiler warnings */\n  for (pos = daemon->manual_timeout_tail; NULL != pos; pos = pos->prevX)\n    {\n      if (0 != pos->connection_timeout)\n\t{\n\t  if ( (! have_timeout) ||\n\t       (earliest_deadline - pos->last_activity > pos->connection_timeout) )\n\t    earliest_deadline = pos->last_activity + pos->connection_timeout;\n\t  have_timeout = true;\n\t}\n    }\n  /* normal timeouts are sorted, so we only need to look at the 'tail' (oldest) */\n  pos = daemon->normal_timeout_tail;\n  if ( (NULL != pos) &&\n       (0 != pos->connection_timeout) )\n    {\n      if ( (! have_timeout) ||\n\t   (earliest_deadline - pos->connection_timeout > pos->last_activity) )\n\tearliest_deadline = pos->last_activity + pos->connection_timeout;\n      have_timeout = true;\n    }\n\n  if (! have_timeout)\n    return MHD_NO;\n  now = MHD_monotonic_sec_counter();\n  if (earliest_deadline < now)\n    *timeout = 0;\n  else\n    {\n      const time_t second_left = earliest_deadline - now;\n      if (second_left > ULLONG_MAX / 1000) /* Ignore compiler warning: 'second_left' is always positive. */\n        *timeout = ULLONG_MAX;\n      else\n        *timeout = 1000LL * second_left;\n  }\n  return MHD_YES;\n}",
      "lines": 77,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "internal_run_from_select": {
      "start_point": [
        3213,
        0
      ],
      "end_point": [
        3292,
        1
      ],
      "content": "static int\ninternal_run_from_select (struct MHD_Daemon *daemon,\n                          const fd_set *read_fd_set,\n                          const fd_set *write_fd_set,\n                          const fd_set *except_fd_set)\n{\n  MHD_socket ds;\n  struct MHD_Connection *pos;\n  struct MHD_Connection *prev;\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  struct MHD_UpgradeResponseHandle *urh;\n  struct MHD_UpgradeResponseHandle *urhn;\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n  /* Reset. New value will be set when connections are processed. */\n  /* Note: no-op for thread-per-connection as it is always false in that mode. */\n  daemon->data_already_pending = false;\n\n  /* Clear ITC to avoid spinning select */\n  /* Do it before any other processing so new signals\n     will trigger select again and will be processed */\n  if ( (MHD_ITC_IS_VALID_(daemon->itc)) &&\n       (FD_ISSET (MHD_itc_r_fd_ (daemon->itc),\n                  read_fd_set)) )\n    MHD_itc_clear_ (daemon->itc);\n\n  /* select connection thread handling type */\n  if ( (MHD_INVALID_SOCKET != (ds = daemon->listen_fd)) &&\n       (! daemon->was_quiesced) &&\n       (FD_ISSET (ds,\n                  read_fd_set)) )\n    (void) MHD_accept_connection (daemon);\n\n  if (0 == (daemon->options & MHD_USE_THREAD_PER_CONNECTION))\n    {\n      /* do not have a thread per connection, process all connections now */\n      prev = daemon->connections_tail;\n      while (NULL != (pos = prev))\n        {\n\t  prev = pos->prev;\n          ds = pos->socket_fd;\n          if (MHD_INVALID_SOCKET == ds)\n\t    continue;\n          call_handlers (pos,\n                         FD_ISSET (ds,\n                                   read_fd_set),\n                         FD_ISSET (ds,\n                                   write_fd_set),\n                         FD_ISSET (ds,\n                                   except_fd_set));\n        }\n    }\n\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  /* handle upgraded HTTPS connections */\n  for (urh = daemon->urh_tail; NULL != urh; urh = urhn)\n    {\n      urhn = urh->prev;\n      /* update urh state based on select() output */\n      urh_from_fdset (urh,\n                      read_fd_set,\n                      write_fd_set,\n                      except_fd_set);\n      /* call generic forwarding function for passing data */\n      process_urh (urh);\n      /* Finished forwarding? */\n      if ( (0 == urh->in_buffer_size) &&\n           (0 == urh->out_buffer_size) &&\n           (0 == urh->in_buffer_used) &&\n           (0 == urh->out_buffer_used) )\n        {\n          MHD_connection_finish_forward_ (urh->connection);\n          urh->clean_ready = true;\n          /* Resuming will move connection to cleanup list. */\n          MHD_resume_connection(urh->connection);\n        }\n    }\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n  MHD_cleanup_connections (daemon);\n  return MHD_YES;\n}",
      "lines": 80,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "MHD_run_from_select": {
      "start_point": [
        3317,
        0
      ],
      "end_point": [
        3357,
        1
      ],
      "content": "int\nMHD_run_from_select (struct MHD_Daemon *daemon,\n                     const fd_set *read_fd_set,\n                     const fd_set *write_fd_set,\n                     const fd_set *except_fd_set)\n{\n  fd_set es;\n  if (0 != (daemon->options &\n        (MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_POLL)) )\n    return MHD_NO;\n  if (NULL == read_fd_set || NULL == write_fd_set)\n    return MHD_NO;\n  if (NULL == except_fd_set)\n    { /* Workaround to maintain backward compatibility. */\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _(\"MHD_run_from_select() called with except_fd_set \"\n                  \"set to NULL. Such behavior is deprecated.\\n\"));\n#endif\n      FD_ZERO (&es);\n      except_fd_set = &es;\n    }\n  if (0 != (daemon->options & MHD_USE_EPOLL))\n    {\n#ifdef EPOLL_SUPPORT\n      int ret;\n      ret = MHD_epoll (daemon, MHD_NO);\n      MHD_cleanup_connections (daemon);\n      return ret;\n#else  /* ! EPOLL_SUPPORT */\n      return MHD_NO;\n#endif /* ! EPOLL_SUPPORT */\n    }\n\n  /* Resuming external connections when using an extern mainloop  */\n  if (0 != (daemon->options & MHD_TEST_ALLOW_SUSPEND_RESUME))\n    resume_suspended_connections (daemon);\n\n  return internal_run_from_select (daemon, read_fd_set,\n                                   write_fd_set, except_fd_set);\n}",
      "lines": 41,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "MHD_select": {
      "start_point": [
        3368,
        0
      ],
      "end_point": [
        3522,
        1
      ],
      "content": "static int\nMHD_select (struct MHD_Daemon *daemon,\n\t    int may_block)\n{\n  int num_ready;\n  fd_set rs;\n  fd_set ws;\n  fd_set es;\n  MHD_socket maxsock;\n  struct timeval timeout;\n  struct timeval *tv;\n  MHD_UNSIGNED_LONG_LONG ltimeout;\n  int err_state;\n  MHD_socket ls;\n\n  timeout.tv_sec = 0;\n  timeout.tv_usec = 0;\n  if (daemon->shutdown)\n    return MHD_NO;\n  FD_ZERO (&rs);\n  FD_ZERO (&ws);\n  FD_ZERO (&es);\n  maxsock = MHD_INVALID_SOCKET;\n  err_state = MHD_NO;\n  if ( (0 != (daemon->options & MHD_TEST_ALLOW_SUSPEND_RESUME)) &&\n       (MHD_YES == resume_suspended_connections (daemon)) &&\n       (0 == (daemon->options & MHD_USE_THREAD_PER_CONNECTION)) )\n    may_block = MHD_NO;\n\n  if (0 == (daemon->options & MHD_USE_THREAD_PER_CONNECTION))\n    {\n      /* single-threaded, go over everything */\n      if (MHD_NO ==\n          internal_get_fdset2 (daemon,\n                               &rs,\n                               &ws,\n                               &es,\n                               &maxsock,\n                               FD_SETSIZE))\n        {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _(\"Could not obtain daemon fdsets\"));\n#endif\n          err_state = MHD_YES;\n        }\n    }\n  else\n    {\n      /* accept only, have one thread per connection */\n      if ( (MHD_INVALID_SOCKET != (ls = daemon->listen_fd)) &&\n           (! daemon->was_quiesced) &&\n           (! MHD_add_to_fd_set_ (ls,\n                                  &rs,\n                                  &maxsock,\n                                  FD_SETSIZE)) )\n        {\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (daemon,\n                    _(\"Could not add listen socket to fdset\"));\n#endif\n          return MHD_NO;\n        }\n    }\n  if ( (MHD_ITC_IS_VALID_(daemon->itc)) &&\n       (! MHD_add_to_fd_set_ (MHD_itc_r_fd_ (daemon->itc),\n                              &rs,\n                              &maxsock,\n                              FD_SETSIZE)) )\n    {\n#if defined(MHD_WINSOCK_SOCKETS)\n      /* fdset limit reached, new connections\n         cannot be handled. Remove listen socket FD\n         from fdset and retry to add ITC FD. */\n      if ( (MHD_INVALID_SOCKET != (ls = daemon->listen_fd)) &&\n           (! daemon->was_quiesced) )\n        {\n          FD_CLR (ls,\n                  &rs);\n          if (! MHD_add_to_fd_set_ (MHD_itc_r_fd_(daemon->itc),\n                                    &rs,\n                                    &maxsock,\n                                    FD_SETSIZE))\n            {\n#endif /* MHD_WINSOCK_SOCKETS */\n#ifdef HAVE_MESSAGES\n              MHD_DLOG (daemon,\n                        _(\"Could not add control inter-thread communication channel FD to fdset\"));\n#endif\n              err_state = MHD_YES;\n#if defined(MHD_WINSOCK_SOCKETS)\n            }\n        }\n#endif /* MHD_WINSOCK_SOCKETS */\n    }\n  /* Stop listening if we are at the configured connection limit */\n  /* If we're at the connection limit, no point in really\n     accepting new connections; however, make sure we do not miss\n     the shutdown OR the termination of an existing connection; so\n     only do this optimization if we have a signaling ITC in\n     place. */\n  if ( (MHD_INVALID_SOCKET != (ls = daemon->listen_fd)) &&\n       (MHD_ITC_IS_VALID_(daemon->itc)) &&\n       ( (daemon->connections == daemon->connection_limit) ||\n         (daemon->at_limit) ) )\n    {\n      FD_CLR (ls,\n              &rs);\n    }\n  tv = NULL;\n  if (MHD_YES == err_state)\n    may_block = MHD_NO;\n  if (MHD_NO == may_block)\n    {\n      timeout.tv_usec = 0;\n      timeout.tv_sec = 0;\n      tv = &timeout;\n    }\n  else if ( (0 == (daemon->options & MHD_USE_THREAD_PER_CONNECTION)) &&\n\t    (MHD_YES == MHD_get_timeout (daemon, &ltimeout)) )\n    {\n      /* ltimeout is in ms */\n      timeout.tv_usec = (ltimeout % 1000) * 1000;\n      if (ltimeout / 1000 > TIMEVAL_TV_SEC_MAX)\n        timeout.tv_sec = TIMEVAL_TV_SEC_MAX;\n      else\n        timeout.tv_sec = (_MHD_TIMEVAL_TV_SEC_TYPE)(ltimeout / 1000);\n      tv = &timeout;\n    }\n  num_ready = MHD_SYS_select_ (maxsock + 1,\n                               &rs,\n                               &ws,\n                               &es,\n                               tv);\n  if (daemon->shutdown)\n    return MHD_NO;\n  if (num_ready < 0)\n    {\n      const int err = MHD_socket_get_error_ ();\n      if (MHD_SCKT_ERR_IS_EINTR_(err))\n        return (MHD_NO == err_state) ? MHD_YES : MHD_NO;\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _(\"select failed: %s\\n\"),\n                MHD_socket_strerr_ (err));\n#endif\n      return MHD_NO;\n    }\n  if (MHD_YES == internal_run_from_select (daemon,\n                                           &rs,\n                                           &ws,\n                                           &es))\n    return (MHD_NO == err_state) ? MHD_YES : MHD_NO;\n  return MHD_NO;\n}",
      "lines": 155,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "MHD_poll_all": {
      "start_point": [
        3534,
        0
      ],
      "end_point": [
        3736,
        1
      ],
      "content": "static int\nMHD_poll_all (struct MHD_Daemon *daemon,\n\t      int may_block)\n{\n  unsigned int num_connections;\n  struct MHD_Connection *pos;\n  struct MHD_Connection *prev;\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  struct MHD_UpgradeResponseHandle *urh;\n  struct MHD_UpgradeResponseHandle *urhn;\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n\n  if ( (0 != (daemon->options & MHD_TEST_ALLOW_SUSPEND_RESUME)) &&\n       (MHD_YES == resume_suspended_connections (daemon)) )\n    may_block = MHD_NO;\n\n  /* count number of connections and thus determine poll set size */\n  num_connections = 0;\n  for (pos = daemon->connections_head; NULL != pos; pos = pos->next)\n    num_connections++;\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  for (urh = daemon->urh_head; NULL != urh; urh = urh->next)\n    num_connections += 2;\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n  {\n    MHD_UNSIGNED_LONG_LONG ltimeout;\n    unsigned int i;\n    int timeout;\n    unsigned int poll_server;\n    int poll_listen;\n    int poll_itc_idx;\n    struct pollfd *p;\n    MHD_socket ls;\n\n    p = MHD_calloc_ ((2 + num_connections), sizeof (struct pollfd));\n    if (NULL == p)\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _(\"Error allocating memory: %s\\n\"),\n                  MHD_strerror_(errno));\n#endif\n        return MHD_NO;\n      }\n    poll_server = 0;\n    poll_listen = -1;\n    if ( (MHD_INVALID_SOCKET != (ls = daemon->listen_fd)) &&\n         (! daemon->was_quiesced) &&\n\t (daemon->connections < daemon->connection_limit) &&\n         (! daemon->at_limit) )\n      {\n\t/* only listen if we are not at the connection limit */\n\tp[poll_server].fd = ls;\n\tp[poll_server].events = POLLIN;\n\tp[poll_server].revents = 0;\n\tpoll_listen = (int) poll_server;\n\tpoll_server++;\n      }\n    poll_itc_idx = -1;\n    if (MHD_ITC_IS_VALID_(daemon->itc))\n      {\n\tp[poll_server].fd = MHD_itc_r_fd_ (daemon->itc);\n\tp[poll_server].events = POLLIN;\n\tp[poll_server].revents = 0;\n        poll_itc_idx = (int) poll_server;\n\tpoll_server++;\n      }\n    if (may_block == MHD_NO)\n      timeout = 0;\n    else if ( (0 != (daemon->options & MHD_USE_THREAD_PER_CONNECTION)) ||\n\t      (MHD_YES != MHD_get_timeout (daemon,\n                                           &ltimeout)) )\n      timeout = -1;\n    else\n      timeout = (ltimeout > INT_MAX) ? INT_MAX : (int) ltimeout;\n\n    i = 0;\n    for (pos = daemon->connections_tail; NULL != pos; pos = pos->prev)\n      {\n\tp[poll_server+i].fd = pos->socket_fd;\n\tswitch (pos->event_loop_info)\n\t  {\n\t  case MHD_EVENT_LOOP_INFO_READ:\n\t    p[poll_server+i].events |= POLLIN | MHD_POLL_EVENTS_ERR_DISC;\n\t    break;\n\t  case MHD_EVENT_LOOP_INFO_WRITE:\n\t    p[poll_server+i].events |= POLLOUT | MHD_POLL_EVENTS_ERR_DISC;\n\t    break;\n\t  case MHD_EVENT_LOOP_INFO_BLOCK:\n\t    p[poll_server+i].events |=  MHD_POLL_EVENTS_ERR_DISC;\n\t    break;\n\t  case MHD_EVENT_LOOP_INFO_CLEANUP:\n\t    timeout = 0; /* clean up \"pos\" immediately */\n\t    break;\n\t  }\n\ti++;\n      }\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n    for (urh = daemon->urh_tail; NULL != urh; urh = urh->prev)\n      {\n        urh_to_pollfd(urh, &(p[poll_server+i]));\n        i += 2;\n      }\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n    if (0 == poll_server + num_connections)\n      {\n        free(p);\n        return MHD_YES;\n      }\n    if (MHD_sys_poll_(p,\n                      poll_server + num_connections,\n                      timeout) < 0)\n      {\n        const int err = MHD_socket_get_error_ ();\n\tif (MHD_SCKT_ERR_IS_EINTR_ (err))\n      {\n        free(p);\n        return MHD_YES;\n      }\n#ifdef HAVE_MESSAGES\n\tMHD_DLOG (daemon,\n\t\t  _(\"poll failed: %s\\n\"),\n\t\t  MHD_socket_strerr_ (err));\n#endif\n        free(p);\n\treturn MHD_NO;\n      }\n\n    /* Reset. New value will be set when connections are processed. */\n    daemon->data_already_pending = false;\n\n    /* handle ITC FD */\n    /* do it before any other processing so\n       new signals will be processed in next loop */\n    if ( (-1 != poll_itc_idx) &&\n         (0 != (p[poll_itc_idx].revents & POLLIN)) )\n      MHD_itc_clear_ (daemon->itc);\n\n    /* handle shutdown */\n    if (daemon->shutdown)\n      {\n        free(p);\n        return MHD_NO;\n      }\n    i = 0;\n    prev = daemon->connections_tail;\n    while (NULL != (pos = prev))\n      {\n\tprev = pos->prev;\n        /* first, sanity checks */\n        if (i >= num_connections)\n          break; /* connection list changed somehow, retry later ... */\n        if (p[poll_server+i].fd != pos->socket_fd)\n          continue; /* fd mismatch, something else happened, retry later ... */\n        call_handlers (pos,\n                       0 != (p[poll_server+i].revents & POLLIN),\n                       0 != (p[poll_server+i].revents & POLLOUT),\n                       0 != (p[poll_server+i].revents & MHD_POLL_REVENTS_ERR_DISC));\n        i++;\n      }\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n    for (urh = daemon->urh_tail; NULL != urh; urh = urhn)\n      {\n        if (i >= num_connections)\n          break; /* connection list changed somehow, retry later ... */\n\n        /* Get next connection here as connection can be removed\n         * from 'daemon->urh_head' list. */\n        urhn = urh->prev;\n        /* Check for fd mismatch. FIXME: required for safety? */\n        if ((p[poll_server+i].fd != urh->connection->socket_fd) ||\n            (p[poll_server+i+1].fd != urh->mhd.socket))\n          break;\n        urh_from_pollfd(urh, &(p[poll_server+i]));\n        i += 2;\n        process_urh (urh);\n        /* Finished forwarding? */\n        if ( (0 == urh->in_buffer_size) &&\n             (0 == urh->out_buffer_size) &&\n             (0 == urh->in_buffer_used) &&\n             (0 == urh->out_buffer_used) )\n          {\n            /* MHD_connection_finish_forward_() will remove connection from\n             * 'daemon->urh_head' list. */\n            MHD_connection_finish_forward_ (urh->connection);\n            urh->clean_ready = true;\n            /* If 'urh->was_closed' already was set to true, connection will be\n             * moved immediately to cleanup list. Otherwise connection\n             * will stay in suspended list until 'urh' will be marked\n             * with 'was_closed' by application. */\n            MHD_resume_connection(urh->connection);\n          }\n      }\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n    /* handle 'listen' FD */\n    if ( (-1 != poll_listen) &&\n\t (0 != (p[poll_listen].revents & POLLIN)) )\n      (void) MHD_accept_connection (daemon);\n\n    free(p);\n  }\n  return MHD_YES;\n}",
      "lines": 203,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "MHD_poll_listen_socket": {
      "start_point": [
        3746,
        0
      ],
      "end_point": [
        3817,
        1
      ],
      "content": "static int\nMHD_poll_listen_socket (struct MHD_Daemon *daemon,\n\t\t\tint may_block)\n{\n  struct pollfd p[2];\n  int timeout;\n  unsigned int poll_count;\n  int poll_listen;\n  int poll_itc_idx;\n  MHD_socket ls;\n\n  memset (&p,\n          0,\n          sizeof (p));\n  poll_count = 0;\n  poll_listen = -1;\n  poll_itc_idx = -1;\n  if ( (MHD_INVALID_SOCKET != (ls = daemon->listen_fd)) &&\n       (! daemon->was_quiesced) )\n\n    {\n      p[poll_count].fd = ls;\n      p[poll_count].events = POLLIN;\n      p[poll_count].revents = 0;\n      poll_listen = poll_count;\n      poll_count++;\n    }\n  if (MHD_ITC_IS_VALID_(daemon->itc))\n    {\n      p[poll_count].fd = MHD_itc_r_fd_ (daemon->itc);\n      p[poll_count].events = POLLIN;\n      p[poll_count].revents = 0;\n      poll_itc_idx = poll_count;\n      poll_count++;\n    }\n\n  if (0 != (daemon->options & MHD_TEST_ALLOW_SUSPEND_RESUME))\n    (void)resume_suspended_connections (daemon);\n\n  if (MHD_NO == may_block)\n    timeout = 0;\n  else\n    timeout = -1;\n  if (0 == poll_count)\n    return MHD_YES;\n  if (MHD_sys_poll_(p,\n                    poll_count,\n                    timeout) < 0)\n    {\n      const int err = MHD_socket_get_error_ ();\n\n      if (MHD_SCKT_ERR_IS_EINTR_ (err))\n\treturn MHD_YES;\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _(\"poll failed: %s\\n\"),\n                MHD_socket_strerr_ (err));\n#endif\n      return MHD_NO;\n    }\n  if ( (-1 != poll_itc_idx) &&\n       (0 != (p[poll_itc_idx].revents & POLLIN)) )\n    MHD_itc_clear_ (daemon->itc);\n\n  /* handle shutdown */\n  if (daemon->shutdown)\n    return MHD_NO;\n  if ( (-1 != poll_listen) &&\n       (0 != (p[poll_listen].revents & POLLIN)) )\n    (void) MHD_accept_connection (daemon);\n  return MHD_YES;\n}",
      "lines": 72,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "MHD_poll": {
      "start_point": [
        3828,
        0
      ],
      "end_point": [
        3843,
        1
      ],
      "content": "static int\nMHD_poll (struct MHD_Daemon *daemon,\n\t  int may_block)\n{\n#ifdef HAVE_POLL\n  if (daemon->shutdown)\n    return MHD_NO;\n  if (0 == (daemon->options & MHD_USE_THREAD_PER_CONNECTION))\n    return MHD_poll_all (daemon,\n                         may_block);\n  return MHD_poll_listen_socket (daemon,\n                                 may_block);\n#else\n  return MHD_NO;\n#endif\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "is_urh_ready": {
      "start_point": [
        3868,
        0
      ],
      "end_point": [
        3900,
        1
      ],
      "content": "static bool\nis_urh_ready(struct MHD_UpgradeResponseHandle * const urh)\n{\n  const struct MHD_Connection * const connection = urh->connection;\n\n  if ( (0 == urh->in_buffer_size) &&\n       (0 == urh->out_buffer_size) &&\n       (0 == urh->in_buffer_used) &&\n       (0 == urh->out_buffer_used) )\n    return false;\n\n  if (connection->daemon->shutdown)\n    return true;\n\n  if ( ( (0 != (MHD_EPOLL_STATE_READ_READY & urh->app.celi)) ||\n         (connection->tls_read_ready) ) &&\n       (urh->in_buffer_used < urh->in_buffer_size) )\n    return true;\n\n  if ( (0 != (MHD_EPOLL_STATE_READ_READY & urh->mhd.celi)) &&\n       (urh->out_buffer_used < urh->out_buffer_size) )\n    return true;\n\n  if ( (0 != (MHD_EPOLL_STATE_WRITE_READY & urh->app.celi)) &&\n       (urh->out_buffer_used > 0) )\n    return true;\n\n  if ( (0 != (MHD_EPOLL_STATE_WRITE_READY & urh->mhd.celi)) &&\n         (urh->in_buffer_used > 0) )\n    return true;\n\n  return false;\n}",
      "lines": 33,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "run_epoll_for_upgrade": {
      "start_point": [
        3910,
        0
      ],
      "end_point": [
        4008,
        1
      ],
      "content": "static int\nrun_epoll_for_upgrade (struct MHD_Daemon *daemon)\n{\n  struct epoll_event events[MAX_EVENTS];\n  int num_events;\n  struct MHD_UpgradeResponseHandle * pos;\n  struct MHD_UpgradeResponseHandle * prev;\n\n  num_events = MAX_EVENTS;\n  while (MAX_EVENTS == num_events)\n    {\n      unsigned int i;\n      /* update event masks */\n      num_events = epoll_wait (daemon->epoll_upgrade_fd,\n\t\t\t       events,\n                               MAX_EVENTS,\n                               0);\n      if (-1 == num_events)\n\t{\n          const int err = MHD_socket_get_error_ ();\n          if (MHD_SCKT_ERR_IS_EINTR_ (err))\n\t    return MHD_YES;\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (daemon,\n                    _(\"Call to epoll_wait failed: %s\\n\"),\n                    MHD_socket_strerr_ (err));\n#endif\n\t  return MHD_NO;\n\t}\n      for (i = 0; i < (unsigned int) num_events; i++)\n\t{\n          struct UpgradeEpollHandle * const ueh = events[i].data.ptr;\n          struct MHD_UpgradeResponseHandle * const urh = ueh->urh;\n          bool new_err_state = false;\n\n          if (urh->clean_ready)\n            continue;\n\n          /* Update ueh state based on what is ready according to epoll() */\n          if (0 != (events[i].events & EPOLLIN))\n            ueh->celi |= MHD_EPOLL_STATE_READ_READY;\n          if (0 != (events[i].events & EPOLLOUT))\n            ueh->celi |= MHD_EPOLL_STATE_WRITE_READY;\n          if (0 != (events[i].events & EPOLLHUP))\n            ueh->celi |= MHD_EPOLL_STATE_READ_READY | MHD_EPOLL_STATE_WRITE_READY;\n\n          if ( (0 == (ueh->celi & MHD_EPOLL_STATE_ERROR)) &&\n               (0 != (events[i].events & (EPOLLERR | EPOLLPRI))) )\n\t    {\n              /* Process new error state only one time\n               * and avoid continuously marking this connection\n               * as 'ready'. */\n              ueh->celi |= MHD_EPOLL_STATE_ERROR;\n              new_err_state = true;\n\t    }\n\n          if (! urh->in_eready_list)\n            {\n              if (new_err_state ||\n        \t  is_urh_ready(urh))\n        \t{\n        \t  EDLL_insert (daemon->eready_urh_head,\n\t\t\t       daemon->eready_urh_tail,\n\t\t\t       urh);\n        \t  urh->in_eready_list = true;\n        \t}\n            }\n        }\n    }\n  prev = daemon->eready_urh_tail;\n  while (NULL != (pos = prev))\n    {\n      prev = pos->prevE;\n      process_urh (pos);\n      if (! is_urh_ready(pos))\n      \t{\n      \t  EDLL_remove (daemon->eready_urh_head,\n      \t\t       daemon->eready_urh_tail,\n      \t\t       pos);\n      \t  pos->in_eready_list = false;\n      \t}\n      /* Finished forwarding? */\n      if ( (0 == pos->in_buffer_size) &&\n           (0 == pos->out_buffer_size) &&\n           (0 == pos->in_buffer_used) &&\n           (0 == pos->out_buffer_used) )\n        {\n          MHD_connection_finish_forward_ (pos->connection);\n          pos->clean_ready = true;\n          /* If 'pos->was_closed' already was set to true, connection\n           * will be moved immediately to cleanup list. Otherwise\n           * connection will stay in suspended list until 'pos' will\n           * be marked with 'was_closed' by application. */\n          MHD_resume_connection(pos->connection);\n        }\n    }\n\n  return MHD_YES;\n}",
      "lines": 99,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "MHD_epoll": {
      "start_point": [
        4024,
        0
      ],
      "end_point": [
        4312,
        1
      ],
      "content": "static int\nMHD_epoll (struct MHD_Daemon *daemon,\n\t   int may_block)\n{\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  static const char * const upgrade_marker = \"upgrade_ptr\";\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n  struct MHD_Connection *pos;\n  struct MHD_Connection *prev;\n  struct epoll_event events[MAX_EVENTS];\n  struct epoll_event event;\n  int timeout_ms;\n  MHD_UNSIGNED_LONG_LONG timeout_ll;\n  int num_events;\n  unsigned int i;\n  MHD_socket ls;\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  int run_upgraded = MHD_NO;\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n\n  if (-1 == daemon->epoll_fd)\n    return MHD_NO; /* we're down! */\n  if (daemon->shutdown)\n    return MHD_NO;\n  if ( (MHD_INVALID_SOCKET != (ls = daemon->listen_fd)) &&\n       (! daemon->was_quiesced) &&\n       (daemon->connections < daemon->connection_limit) &&\n       (! daemon->listen_socket_in_epoll) &&\n       (! daemon->at_limit) )\n    {\n      event.events = EPOLLIN;\n      event.data.ptr = daemon;\n      if (0 != epoll_ctl (daemon->epoll_fd,\n\t\t\t  EPOLL_CTL_ADD,\n\t\t\t  ls,\n\t\t\t  &event))\n\t{\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (daemon,\n                    _(\"Call to epoll_ctl failed: %s\\n\"),\n                    MHD_socket_last_strerr_ ());\n#endif\n\t  return MHD_NO;\n\t}\n      daemon->listen_socket_in_epoll = true;\n    }\n  if ( (daemon->was_quiesced) &&\n       (daemon->listen_socket_in_epoll) )\n  {\n    if (0 != epoll_ctl (daemon->epoll_fd,\n                        EPOLL_CTL_DEL,\n                        ls,\n                        NULL))\n      MHD_PANIC (\"Failed to remove listen FD from epoll set\\n\");\n    daemon->listen_socket_in_epoll = false;\n  }\n\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  if ( (! daemon->upgrade_fd_in_epoll) &&\n       (-1 != daemon->epoll_upgrade_fd) )\n    {\n      event.events = EPOLLIN | EPOLLOUT;\n      event.data.ptr = (void *) upgrade_marker;\n      if (0 != epoll_ctl (daemon->epoll_fd,\n\t\t\t  EPOLL_CTL_ADD,\n\t\t\t  daemon->epoll_upgrade_fd,\n\t\t\t  &event))\n\t{\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (daemon,\n                    _(\"Call to epoll_ctl failed: %s\\n\"),\n                    MHD_socket_last_strerr_ ());\n#endif\n\t  return MHD_NO;\n\t}\n      daemon->upgrade_fd_in_epoll = true;\n    }\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n  if ( (daemon->listen_socket_in_epoll) &&\n       ( (daemon->connections == daemon->connection_limit) ||\n         (daemon->at_limit) ||\n         (daemon->was_quiesced) ) )\n    {\n      /* we're at the connection limit, disable listen socket\n\t for event loop for now */\n      if (0 != epoll_ctl (daemon->epoll_fd,\n\t\t\t  EPOLL_CTL_DEL,\n\t\t\t  ls,\n\t\t\t  NULL))\n\tMHD_PANIC (_(\"Failed to remove listen FD from epoll set\\n\"));\n      daemon->listen_socket_in_epoll = false;\n    }\n\n  if ( (0 != (daemon->options & MHD_TEST_ALLOW_SUSPEND_RESUME)) &&\n       (MHD_YES == resume_suspended_connections (daemon)) )\n    may_block = MHD_NO;\n\n  if (MHD_YES == may_block)\n    {\n      if (MHD_YES == MHD_get_timeout (daemon,\n\t\t\t\t      &timeout_ll))\n\t{\n\t  if (timeout_ll >= (MHD_UNSIGNED_LONG_LONG) INT_MAX)\n\t    timeout_ms = INT_MAX;\n\t  else\n\t    timeout_ms = (int) timeout_ll;\n\t}\n      else\n\ttimeout_ms = -1;\n    }\n  else\n    timeout_ms = 0;\n\n  /* Reset. New value will be set when connections are processed. */\n  /* Note: Used mostly for uniformity here as same situation is\n   * signaled in epoll mode by non-empty eready DLL. */\n  daemon->data_already_pending = false;\n\n  /* drain 'epoll' event queue; need to iterate as we get at most\n     MAX_EVENTS in one system call here; in practice this should\n     pretty much mean only one round, but better an extra loop here\n     than unfair behavior... */\n  num_events = MAX_EVENTS;\n  while (MAX_EVENTS == num_events)\n    {\n      /* update event masks */\n      num_events = epoll_wait (daemon->epoll_fd,\n\t\t\t       events,\n                               MAX_EVENTS,\n                               timeout_ms);\n      if (-1 == num_events)\n\t{\n          const int err = MHD_socket_get_error_ ();\n          if (MHD_SCKT_ERR_IS_EINTR_ (err))\n\t    return MHD_YES;\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (daemon,\n                    _(\"Call to epoll_wait failed: %s\\n\"),\n                    MHD_socket_strerr_ (err));\n#endif\n\t  return MHD_NO;\n\t}\n      for (i=0;i<(unsigned int) num_events;i++)\n\t{\n          /* First, check for the values of `ptr` that would indicate\n             that this event is not about a normal connection. */\n\t  if (NULL == events[i].data.ptr)\n\t    continue; /* shutdown signal! */\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n          if (upgrade_marker == events[i].data.ptr)\n            {\n              /* activity on an upgraded connection, we process\n                 those in a separate epoll() */\n              run_upgraded = MHD_YES;\n              continue;\n            }\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n          if (epoll_itc_marker == events[i].data.ptr)\n            {\n              /* It's OK to clear ITC here as all external\n                 conditions will be processed later. */\n              MHD_itc_clear_ (daemon->itc);\n              continue;\n            }\n\t  if (daemon == events[i].data.ptr)\n\t    {\n              /* Check for error conditions on listen socket. */\n              /* FIXME: Initiate MHD_quiesce_daemon() to prevent busy waiting? */\n              if (0 == (events[i].events & (EPOLLERR | EPOLLHUP)))\n                {\n                  unsigned int series_length = 0;\n                  /* Run 'accept' until it fails or daemon at limit of connections.\n                   * Do not accept more then 10 connections at once. The rest will\n                   * be accepted on next turn (level trigger is used for listen\n                   * socket). */\n                  while ( (MHD_YES == MHD_accept_connection (daemon)) &&\n                          (series_length < 10) &&\n                          (daemon->connections < daemon->connection_limit) &&\n                          (! daemon->at_limit) )\n                    series_length++;\n\t        }\n              continue;\n\t    }\n          /* this is an event relating to a 'normal' connection,\n             remember the event and if appropriate mark the\n             connection as 'eready'. */\n          pos = events[i].data.ptr;\n          /* normal processing: update read/write data */\n          if (0 != (events[i].events & (EPOLLPRI | EPOLLERR | EPOLLHUP)))\n            {\n              pos->epoll_state |= MHD_EPOLL_STATE_ERROR;\n              if (0 == (pos->epoll_state & MHD_EPOLL_STATE_IN_EREADY_EDLL))\n                {\n                  EDLL_insert (daemon->eready_head,\n                               daemon->eready_tail,\n                               pos);\n                  pos->epoll_state |= MHD_EPOLL_STATE_IN_EREADY_EDLL;\n                }\n            }\n          else\n            {\n              if (0 != (events[i].events & EPOLLIN))\n                {\n                  pos->epoll_state |= MHD_EPOLL_STATE_READ_READY;\n                  if ( ( (MHD_EVENT_LOOP_INFO_READ == pos->event_loop_info) ||\n                         (pos->read_buffer_size > pos->read_buffer_offset) ) &&\n                       (0 == (pos->epoll_state & MHD_EPOLL_STATE_IN_EREADY_EDLL) ) )\n                    {\n                      EDLL_insert (daemon->eready_head,\n                                   daemon->eready_tail,\n                                   pos);\n                      pos->epoll_state |= MHD_EPOLL_STATE_IN_EREADY_EDLL;\n                    }\n                }\n              if (0 != (events[i].events & EPOLLOUT))\n                {\n                  pos->epoll_state |= MHD_EPOLL_STATE_WRITE_READY;\n                  if ( (MHD_EVENT_LOOP_INFO_WRITE == pos->event_loop_info) &&\n                       (0 == (pos->epoll_state & MHD_EPOLL_STATE_IN_EREADY_EDLL) ) )\n                    {\n                      EDLL_insert (daemon->eready_head,\n                                   daemon->eready_tail,\n                                   pos);\n                      pos->epoll_state |= MHD_EPOLL_STATE_IN_EREADY_EDLL;\n                    }\n                }\n            }\n        }\n    }\n\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  if (MHD_YES == run_upgraded)\n    run_epoll_for_upgrade (daemon);\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n\n  /* process events for connections */\n  prev = daemon->eready_tail;\n  while (NULL != (pos = prev))\n    {\n\t  prev = pos->prevE;\n      call_handlers (pos,\n                     0 != (pos->epoll_state & MHD_EPOLL_STATE_READ_READY),\n                     0 != (pos->epoll_state & MHD_EPOLL_STATE_WRITE_READY),\n                     0 != (pos->epoll_state & MHD_EPOLL_STATE_ERROR));\n      if (MHD_EPOLL_STATE_IN_EREADY_EDLL ==\n            (pos->epoll_state & (MHD_EPOLL_STATE_SUSPENDED | MHD_EPOLL_STATE_IN_EREADY_EDLL)))\n        {\n          if ( (MHD_EVENT_LOOP_INFO_READ == pos->event_loop_info &&\n                  0 == (pos->epoll_state & MHD_EPOLL_STATE_READ_READY) ) ||\n               (MHD_EVENT_LOOP_INFO_WRITE == pos->event_loop_info &&\n                 0 == (pos->epoll_state & MHD_EPOLL_STATE_WRITE_READY) ) ||\n               MHD_EVENT_LOOP_INFO_CLEANUP == pos->event_loop_info)\n            {\n              EDLL_remove (daemon->eready_head,\n                           daemon->eready_tail,\n                           pos);\n              pos->epoll_state &= ~MHD_EPOLL_STATE_IN_EREADY_EDLL;\n            }\n        }\n    }\n\n  /* Finally, handle timed-out connections; we need to do this here\n     as the epoll mechanism won't call the 'MHD_connection_handle_idle()' on everything,\n     as the other event loops do.  As timeouts do not get an explicit\n     event, we need to find those connections that might have timed out\n     here.\n\n     Connections with custom timeouts must all be looked at, as we\n     do not bother to sort that (presumably very short) list. */\n  prev = daemon->manual_timeout_tail;\n  while (NULL != (pos = prev))\n    {\n      prev = pos->prevX;\n      MHD_connection_handle_idle (pos);\n    }\n  /* Connections with the default timeout are sorted by prepending\n     them to the head of the list whenever we touch the connection;\n     thus it suffices to iterate from the tail until the first\n     connection is NOT timed out */\n  prev = daemon->normal_timeout_tail;\n  while (NULL != (pos = prev))\n    {\n      prev = pos->prevX;\n      MHD_connection_handle_idle (pos);\n      if (MHD_CONNECTION_CLOSED != pos->state)\n\tbreak; /* sorted by timeout, no need to visit the rest! */\n    }\n  return MHD_YES;\n}",
      "lines": 289,
      "depth": 20,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "MHD_run": {
      "start_point": [
        4336,
        0
      ],
      "end_point": [
        4360,
        1
      ],
      "content": "int\nMHD_run (struct MHD_Daemon *daemon)\n{\n  if ( (daemon->shutdown) ||\n       (0 != (daemon->options & MHD_USE_INTERNAL_POLLING_THREAD)) )\n    return MHD_NO;\n  if (0 != (daemon->options & MHD_USE_POLL))\n  {\n    MHD_poll (daemon, MHD_NO);\n    MHD_cleanup_connections (daemon);\n  }\n#ifdef EPOLL_SUPPORT\n  else if (0 != (daemon->options & MHD_USE_EPOLL))\n  {\n    MHD_epoll (daemon, MHD_NO);\n    MHD_cleanup_connections (daemon);\n  }\n#endif\n  else\n  {\n    MHD_select (daemon, MHD_NO);\n    /* MHD_select does MHD_cleanup_connections already */\n  }\n  return MHD_YES;\n}",
      "lines": 25,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "close_connection": {
      "start_point": [
        4371,
        0
      ],
      "end_point": [
        4404,
        1
      ],
      "content": "static void\nclose_connection (struct MHD_Connection *pos)\n{\n  struct MHD_Daemon *daemon = pos->daemon;\n\n  if (0 != (daemon->options & MHD_USE_THREAD_PER_CONNECTION))\n    {\n      MHD_connection_mark_closed_ (pos);\n      return; /* must let thread to do the rest */\n    }\n  MHD_connection_close_ (pos,\n                         MHD_REQUEST_TERMINATED_DAEMON_SHUTDOWN);\n\n  MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n\n  mhd_assert (! pos->suspended);\n  mhd_assert (! pos->resuming);\n  if (pos->connection_timeout == pos->daemon->connection_timeout)\n    XDLL_remove (daemon->normal_timeout_head,\n\t\t daemon->normal_timeout_tail,\n\t\t pos);\n  else\n    XDLL_remove (daemon->manual_timeout_head,\n\t\t daemon->manual_timeout_tail,\n\t\t pos);\n  DLL_remove (daemon->connections_head,\n\t      daemon->connections_tail,\n\t      pos);\n  DLL_insert (daemon->cleanup_head,\n\t      daemon->cleanup_tail,\n\t      pos);\n\n  MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n}",
      "lines": 34,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "MHD_polling_thread": {
      "start_point": [
        4414,
        0
      ],
      "end_point": [
        4439,
        1
      ],
      "content": "static MHD_THRD_RTRN_TYPE_ MHD_THRD_CALL_SPEC_\nMHD_polling_thread (void *cls)\n{\n  struct MHD_Daemon *daemon = cls;\n  MHD_thread_init_(&(daemon->pid));\n\n  while (! daemon->shutdown)\n    {\n      if (0 != (daemon->options & MHD_USE_POLL))\n\tMHD_poll (daemon, MHD_YES);\n#ifdef EPOLL_SUPPORT\n      else if (0 != (daemon->options & MHD_USE_EPOLL))\n\tMHD_epoll (daemon, MHD_YES);\n#endif\n      else\n\tMHD_select (daemon, MHD_YES);\n      MHD_cleanup_connections (daemon);\n    }\n\n  /* Resume any pending for resume connections, join\n   * all connection's threads (if any) and finally cleanup\n   * everything. */\n  close_all_connections (daemon);\n\n  return (MHD_THRD_RTRN_TYPE_)0;\n}",
      "lines": 26,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "MHD_THRD_RTRN_TYPE_",
        "MHD_THRD_CALL_SPEC_",
        "MHD_THRD_CALL_SPEC_"
      ]
    },
    "unescape_wrapper": {
      "start_point": [
        4453,
        0
      ],
      "end_point": [
        4461,
        1
      ],
      "content": "static size_t\nunescape_wrapper (void *cls,\n                  struct MHD_Connection *connection,\n                  char *val)\n{\n  (void)cls; /* Mute compiler warning. */\n  (void)connection; /* Mute compiler warning. */\n  return MHD_http_unescape (val);\n}",
      "lines": 9,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "MHD_start_daemon": {
      "start_point": [
        4484,
        0
      ],
      "end_point": [
        4507,
        1
      ],
      "content": "struct MHD_Daemon *\nMHD_start_daemon (unsigned int flags,\n                  uint16_t port,\n                  MHD_AcceptPolicyCallback apc,\n                  void *apc_cls,\n                  MHD_AccessHandlerCallback dh,\n                  void *dh_cls,\n                  ...)\n{\n  struct MHD_Daemon *daemon;\n  va_list ap;\n\n  va_start (ap,\n            dh_cls);\n  daemon = MHD_start_daemon_va (flags,\n                                port,\n                                apc,\n                                apc_cls,\n                                dh,\n                                dh_cls,\n                                ap);\n  va_end (ap);\n  return daemon;\n}",
      "lines": 24,
      "depth": 7,
      "decorators": [
        "struct MHD_Daemon",
        "struct",
        "MHD_Daemon",
        "*\nMHD_start_daemon (unsigned int flags,\n                  uint16_t port,\n                  MHD_AcceptPolicyCallback apc,\n                  void *apc_cls,\n                  MHD_AccessHandlerCallback dh,\n                  void *dh_cls,\n                  ...)",
        "*"
      ]
    },
    "MHD_quiesce_daemon": {
      "start_point": [
        4529,
        0
      ],
      "end_point": [
        4590,
        1
      ],
      "content": "MHD_socket\nMHD_quiesce_daemon (struct MHD_Daemon *daemon)\n{\n  unsigned int i;\n  MHD_socket ret;\n\n  ret = daemon->listen_fd;\n  if (MHD_INVALID_SOCKET == ret)\n    return MHD_INVALID_SOCKET;\n  if ( (0 == (daemon->options & (MHD_USE_ITC))) &&\n       (0 != (daemon->options & (MHD_USE_INTERNAL_POLLING_THREAD))) )\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n\t\t\"Using MHD_quiesce_daemon in this mode requires MHD_USE_ITC\\n\");\n#endif\n      return MHD_INVALID_SOCKET;\n    }\n\n  if (NULL != daemon->worker_pool)\n    for (i = 0; i < daemon->worker_pool_size; i++)\n      {\n\tdaemon->worker_pool[i].was_quiesced = true;\n#ifdef EPOLL_SUPPORT\n\tif ( (0 != (daemon->options & MHD_USE_EPOLL)) &&\n\t     (-1 != daemon->worker_pool[i].epoll_fd) &&\n\t     (daemon->worker_pool[i].listen_socket_in_epoll) )\n\t  {\n\t    if (0 != epoll_ctl (daemon->worker_pool[i].epoll_fd,\n\t\t\t\tEPOLL_CTL_DEL,\n\t\t\t\tret,\n\t\t\t\tNULL))\n\t      MHD_PANIC (_(\"Failed to remove listen FD from epoll set\\n\"));\n\t    daemon->worker_pool[i].listen_socket_in_epoll = false;\n\t  }\n        else\n#endif\n        if (MHD_ITC_IS_VALID_(daemon->worker_pool[i].itc))\n          {\n            if (! MHD_itc_activate_ (daemon->worker_pool[i].itc, \"q\"))\n              MHD_PANIC (_(\"Failed to signal quiesce via inter-thread communication channel\"));\n          }\n      }\n  daemon->was_quiesced = true;\n#ifdef EPOLL_SUPPORT\n  if ( (0 != (daemon->options & MHD_USE_EPOLL)) &&\n       (-1 != daemon->epoll_fd) &&\n       (daemon->listen_socket_in_epoll) )\n    {\n      if (0 != epoll_ctl (daemon->epoll_fd,\n\t\t\t  EPOLL_CTL_DEL,\n\t\t\t  ret,\n\t\t\t  NULL))\n\tMHD_PANIC (\"Failed to remove listen FD from epoll set\\n\");\n      daemon->listen_socket_in_epoll = false;\n    }\n#endif\n  if ( (MHD_ITC_IS_VALID_(daemon->itc)) &&\n       (! MHD_itc_activate_ (daemon->itc, \"q\")) )\n    MHD_PANIC (_(\"failed to signal quiesce via inter-thread communication channel\"));\n  return ret;\n}",
      "lines": 62,
      "depth": 17,
      "decorators": [
        "MHD_socket"
      ]
    },
    "parse_options": {
      "start_point": [
        4628,
        0
      ],
      "end_point": [
        4642,
        1
      ],
      "content": "static int\nparse_options (struct MHD_Daemon *daemon,\n\t       const struct sockaddr **servaddr,\n\t       ...)\n{\n  va_list ap;\n  int ret;\n\n  va_start (ap, servaddr);\n  ret = parse_options_va (daemon,\n                          servaddr,\n                          ap);\n  va_end (ap);\n  return ret;\n}",
      "lines": 15,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "parse_options_va": {
      "start_point": [
        4653,
        0
      ],
      "end_point": [
        5109,
        1
      ],
      "content": "static int\nparse_options_va (struct MHD_Daemon *daemon,\n\t\t  const struct sockaddr **servaddr,\n\t\t  va_list ap)\n{\n  enum MHD_OPTION opt;\n  struct MHD_OptionItem *oa;\n  unsigned int i;\n  unsigned int uv;\n#ifdef HTTPS_SUPPORT\n  int ret;\n  const char *pstr;\n#endif /* HTTPS_SUPPORT */\n\n  while (MHD_OPTION_END != (opt = (enum MHD_OPTION) va_arg (ap, int)))\n    {\n      switch (opt)\n        {\n        case MHD_OPTION_CONNECTION_MEMORY_LIMIT:\n          daemon->pool_size = va_arg (ap,\n                                      size_t);\n          break;\n        case MHD_OPTION_CONNECTION_MEMORY_INCREMENT:\n          daemon->pool_increment= va_arg (ap,\n                                          size_t);\n          break;\n        case MHD_OPTION_CONNECTION_LIMIT:\n          daemon->connection_limit = va_arg (ap,\n                                             unsigned int);\n          break;\n        case MHD_OPTION_CONNECTION_TIMEOUT:\n          uv = va_arg (ap,\n                       unsigned int);\n          /* Next comparison could be always false on some platforms and whole branch will\n           * be optimized out on those platforms. On others it will be compiled into real\n           * check. */\n          if (TIME_T_MAX < uv) /* Compiler may warn on some platforms, ignore warning. */\n            {\n#ifdef HAVE_MESSAGES\n              MHD_DLOG (daemon,\n                        _(\"Warning: Too large timeout value, ignored.\\n\"));\n#endif\n              daemon->connection_timeout = 0;\n            }\n          else\n            daemon->connection_timeout = (time_t)uv;\n          break;\n        case MHD_OPTION_NOTIFY_COMPLETED:\n          daemon->notify_completed = va_arg (ap,\n                                             MHD_RequestCompletedCallback);\n          daemon->notify_completed_cls = va_arg (ap,\n                                                 void *);\n          break;\n        case MHD_OPTION_NOTIFY_CONNECTION:\n          daemon->notify_connection = va_arg (ap,\n                                              MHD_NotifyConnectionCallback);\n          daemon->notify_connection_cls = va_arg (ap,\n                                                  void *);\n          break;\n        case MHD_OPTION_PER_IP_CONNECTION_LIMIT:\n          daemon->per_ip_connection_limit = va_arg (ap,\n                                                    unsigned int);\n          break;\n        case MHD_OPTION_SOCK_ADDR:\n          *servaddr = va_arg (ap,\n                              const struct sockaddr *);\n          break;\n        case MHD_OPTION_URI_LOG_CALLBACK:\n          daemon->uri_log_callback = va_arg (ap,\n                                             LogCallback);\n          daemon->uri_log_callback_cls = va_arg (ap,\n                                                 void *);\n          break;\n        case MHD_OPTION_THREAD_POOL_SIZE:\n          daemon->worker_pool_size = va_arg (ap,\n                                             unsigned int);\n          if (0 == daemon->worker_pool_size)\n            {\n#ifdef HAVE_MESSAGES\n              MHD_DLOG (daemon,\n                        _(\"Warning: Zero size, specified for thread pool size, is ignored. \"\n                          \"Thread pool is not used.\\n\"));\n#endif\n            }\n          else if (1 == daemon->worker_pool_size)\n            {\n#ifdef HAVE_MESSAGES\n              MHD_DLOG (daemon,\n                        _(\"Warning: \\\"1\\\", specified for thread pool size, is ignored. \"\n                          \"Thread pool is not used.\\n\"));\n#endif\n              daemon->worker_pool_size = 0;\n            }\n          /* Next comparison could be always false on some platforms and whole branch will\n           * be optimized out on those platforms. On others it will be compiled into real\n           * check. */\n          else if (daemon->worker_pool_size >= (SIZE_MAX / sizeof (struct MHD_Daemon))) /* Compiler may warn on some platforms, ignore warning. */\n\t    {\n#ifdef HAVE_MESSAGES\n\t      MHD_DLOG (daemon,\n\t\t\t_(\"Specified thread pool size (%u) too big\\n\"),\n\t\t\tdaemon->worker_pool_size);\n#endif\n\t      return MHD_NO;\n\t    }\n\t  else\n\t    {\n\t      if (0 == (daemon->options & MHD_USE_INTERNAL_POLLING_THREAD))\n\t\t{\n#ifdef HAVE_MESSAGES\n\t\t  MHD_DLOG (daemon,\n\t\t\t    _(\"MHD_OPTION_THREAD_POOL_SIZE option is specified but \"\n\t\t\t      \"MHD_USE_INTERNAL_POLLING_THREAD flag is not specified.\\n\"));\n#endif\n\t\t  return MHD_NO;\n\t\t}\n\t      if (0 != (daemon->options & MHD_USE_THREAD_PER_CONNECTION))\n\t\t{\n#ifdef HAVE_MESSAGES\n\t\t  MHD_DLOG (daemon,\n\t\t\t    _(\"Both MHD_OPTION_THREAD_POOL_SIZE option and \"\n\t\t\t      \"MHD_USE_THREAD_PER_CONNECTION flag are specified.\\n\"));\n#endif\n\t\t  return MHD_NO;\n\t\t}\n\t    }\n          break;\n#ifdef HTTPS_SUPPORT\n        case MHD_OPTION_HTTPS_MEM_KEY:\n\t  if (0 != (daemon->options & MHD_USE_TLS))\n\t    daemon->https_mem_key = va_arg (ap,\n                                            const char *);\n#ifdef HAVE_MESSAGES\n\t  else\n\t    MHD_DLOG (daemon,\n\t\t      _(\"MHD HTTPS option %d passed to MHD but MHD_USE_TLS not set\\n\"),\n\t\t      opt);\n#endif\n          break;\n        case MHD_OPTION_HTTPS_KEY_PASSWORD:\n\t  if (0 != (daemon->options & MHD_USE_TLS))\n\t    daemon->https_key_password = va_arg (ap,\n                                                 const char *);\n#ifdef HAVE_MESSAGES\n\t  else\n\t    MHD_DLOG (daemon,\n\t\t      _(\"MHD HTTPS option %d passed to MHD but MHD_USE_TLS not set\\n\"),\n\t\t      opt);\n#endif\n          break;\n        case MHD_OPTION_HTTPS_MEM_CERT:\n\t  if (0 != (daemon->options & MHD_USE_TLS))\n\t    daemon->https_mem_cert = va_arg (ap,\n                                             const char *);\n#ifdef HAVE_MESSAGES\n\t  else\n\t    MHD_DLOG (daemon,\n\t\t      _(\"MHD HTTPS option %d passed to MHD but MHD_USE_TLS not set\\n\"),\n\t\t      opt);\n#endif\n          break;\n        case MHD_OPTION_HTTPS_MEM_TRUST:\n\t  if (0 != (daemon->options & MHD_USE_TLS))\n\t    daemon->https_mem_trust = va_arg (ap,\n                                              const char *);\n#ifdef HAVE_MESSAGES\n\t  else\n\t    MHD_DLOG (daemon,\n\t\t      _(\"MHD HTTPS option %d passed to MHD but MHD_USE_TLS not set\\n\"),\n\t\t      opt);\n#endif\n          break;\n\tcase MHD_OPTION_HTTPS_CRED_TYPE:\n\t  daemon->cred_type = (gnutls_credentials_type_t) va_arg (ap,\n                                                                  int);\n\t  break;\n        case MHD_OPTION_HTTPS_MEM_DHPARAMS:\n          if (0 != (daemon->options & MHD_USE_TLS))\n            {\n              const char *arg = va_arg (ap,\n                                        const char *);\n              gnutls_datum_t dhpar;\n\n              if (gnutls_dh_params_init (&daemon->https_mem_dhparams) < 0)\n                {\n#ifdef HAVE_MESSAGES\n                  MHD_DLOG (daemon,\n                            _(\"Error initializing DH parameters\\n\"));\n#endif\n                  return MHD_NO;\n                }\n              dhpar.data = (unsigned char *) arg;\n              dhpar.size = strlen (arg);\n              if (gnutls_dh_params_import_pkcs3 (daemon->https_mem_dhparams,\n                                                 &dhpar,\n                                                 GNUTLS_X509_FMT_PEM) < 0)\n                {\n#ifdef HAVE_MESSAGES\n                  MHD_DLOG (daemon,\n                            _(\"Bad Diffie-Hellman parameters format\\n\"));\n#endif\n                  gnutls_dh_params_deinit (daemon->https_mem_dhparams);\n                  return MHD_NO;\n                }\n              daemon->have_dhparams = true;\n            }\n          else\n            {\n#ifdef HAVE_MESSAGES\n              MHD_DLOG (daemon,\n                        _(\"MHD HTTPS option %d passed to MHD but MHD_USE_TLS not set\\n\"),\n                        opt);\n#endif\n              return MHD_NO;\n            }\n          break;\n        case MHD_OPTION_HTTPS_PRIORITIES:\n\t  if (0 != (daemon->options & MHD_USE_TLS))\n\t    {\n\t      gnutls_priority_deinit (daemon->priority_cache);\n\t      ret = gnutls_priority_init (&daemon->priority_cache,\n\t\t\t\t\t  pstr = va_arg (ap, const char*),\n\t\t\t\t\t  NULL);\n\t      if (GNUTLS_E_SUCCESS != ret)\n\t      {\n#ifdef HAVE_MESSAGES\n\t\tMHD_DLOG (daemon,\n\t\t\t  _(\"Setting priorities to `%s' failed: %s\\n\"),\n\t\t\t  pstr,\n\t\t\t  gnutls_strerror (ret));\n#endif\n\t\tdaemon->priority_cache = NULL;\n\t\treturn MHD_NO;\n\t      }\n\t    }\n          break;\n        case MHD_OPTION_HTTPS_CERT_CALLBACK:\n#if GNUTLS_VERSION_MAJOR < 3\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (daemon,\n                    _(\"MHD_OPTION_HTTPS_CERT_CALLBACK requires building MHD with GnuTLS >= 3.0\\n\"));\n#endif\n          return MHD_NO;\n#else\n          if (0 != (daemon->options & MHD_USE_TLS))\n            daemon->cert_callback = va_arg (ap,\n                                            gnutls_certificate_retrieve_function2 *);\n          break;\n#endif\n#endif /* HTTPS_SUPPORT */\n#ifdef DAUTH_SUPPORT\n\tcase MHD_OPTION_DIGEST_AUTH_RANDOM:\n\t  daemon->digest_auth_rand_size = va_arg (ap,\n                                                  size_t);\n\t  daemon->digest_auth_random = va_arg (ap,\n                                               const char *);\n\t  break;\n\tcase MHD_OPTION_NONCE_NC_SIZE:\n\t  daemon->nonce_nc_size = va_arg (ap,\n                                          unsigned int);\n\t  break;\n#endif\n\tcase MHD_OPTION_LISTEN_SOCKET:\n          if (0 != (daemon->options & MHD_USE_NO_LISTEN_SOCKET))\n            {\n#ifdef HAVE_MESSAGES\n                MHD_DLOG (daemon,\n                          _(\"MHD_OPTION_LISTEN_SOCKET specified for daemon \"\n                            \"with MHD_USE_NO_LISTEN_SOCKET flag set.\\n\"));\n#endif\n                return MHD_NO;\n            }\n          else\n            daemon->listen_fd = va_arg (ap,\n                                        MHD_socket);\n\t  break;\n        case MHD_OPTION_EXTERNAL_LOGGER:\n#ifdef HAVE_MESSAGES\n          daemon->custom_error_log = va_arg (ap,\n                                             VfprintfFunctionPointerType);\n          daemon->custom_error_log_cls = va_arg (ap,\n                                                 void *);\n#else\n          va_arg (ap,\n                  VfprintfFunctionPointerType);\n          va_arg (ap,\n                  void *);\n#endif\n          break;\n        case MHD_OPTION_THREAD_STACK_SIZE:\n          daemon->thread_stack_size = va_arg (ap,\n                                              size_t);\n          break;\n#ifdef TCP_FASTOPEN\n        case MHD_OPTION_TCP_FASTOPEN_QUEUE_SIZE:\n          daemon->fastopen_queue_size = va_arg (ap,\n                                                unsigned int);\n          break;\n#endif\n\tcase MHD_OPTION_LISTENING_ADDRESS_REUSE:\n\t  daemon->listening_address_reuse = va_arg (ap,\n                                                    unsigned int) ? 1 : -1;\n\t  break;\n\tcase MHD_OPTION_LISTEN_BACKLOG_SIZE:\n\t  daemon->listen_backlog_size = va_arg (ap,\n                                                unsigned int);\n\t  break;\n\tcase MHD_OPTION_STRICT_FOR_CLIENT:\n          daemon->strict_for_client = va_arg (ap, int);;\n#ifdef HAVE_MESSAGES\n\t  if ( (0 != (daemon->options & MHD_USE_PEDANTIC_CHECKS)) &&\n\t       (1 != daemon->strict_for_client) )\n            {\n              MHD_DLOG (daemon,\n                        _(\"Flag MHD_USE_PEDANTIC_CHECKS is ignored because \"\n                          \"another behavior is specified by MHD_OPTION_STRICT_CLIENT.\\n\"));\n            }\n#endif /* HAVE_MESSAGES */\n\t  break;\n\tcase MHD_OPTION_ARRAY:\n\t  oa = va_arg (ap, struct MHD_OptionItem*);\n\t  i = 0;\n\t  while (MHD_OPTION_END != (opt = oa[i].option))\n\t    {\n\t      switch (opt)\n\t\t{\n\t\t  /* all options taking 'size_t' */\n\t\tcase MHD_OPTION_CONNECTION_MEMORY_LIMIT:\n\t\tcase MHD_OPTION_CONNECTION_MEMORY_INCREMENT:\n\t\tcase MHD_OPTION_THREAD_STACK_SIZE:\n\t\t  if (MHD_YES != parse_options (daemon,\n\t\t\t\t\t\tservaddr,\n\t\t\t\t\t\topt,\n\t\t\t\t\t\t(size_t) oa[i].value,\n\t\t\t\t\t\tMHD_OPTION_END))\n\t\t    return MHD_NO;\n\t\t  break;\n\t\t  /* all options taking 'unsigned int' */\n\t\tcase MHD_OPTION_NONCE_NC_SIZE:\n\t\tcase MHD_OPTION_CONNECTION_LIMIT:\n\t\tcase MHD_OPTION_CONNECTION_TIMEOUT:\n\t\tcase MHD_OPTION_PER_IP_CONNECTION_LIMIT:\n\t\tcase MHD_OPTION_THREAD_POOL_SIZE:\n                case MHD_OPTION_TCP_FASTOPEN_QUEUE_SIZE:\n\t\tcase MHD_OPTION_LISTENING_ADDRESS_REUSE:\n\t\tcase MHD_OPTION_LISTEN_BACKLOG_SIZE:\n\t\t  if (MHD_YES != parse_options (daemon,\n\t\t\t\t\t\tservaddr,\n\t\t\t\t\t\topt,\n\t\t\t\t\t\t(unsigned int) oa[i].value,\n\t\t\t\t\t\tMHD_OPTION_END))\n\t\t    return MHD_NO;\n\t\t  break;\n\t\t  /* all options taking 'enum' */\n#ifdef HTTPS_SUPPORT\n\t\tcase MHD_OPTION_HTTPS_CRED_TYPE:\n\t\t  if (MHD_YES != parse_options (daemon,\n\t\t\t\t\t\tservaddr,\n\t\t\t\t\t\topt,\n\t\t\t\t\t\t(gnutls_credentials_type_t) oa[i].value,\n\t\t\t\t\t\tMHD_OPTION_END))\n\t\t    return MHD_NO;\n\t\t  break;\n#endif /* HTTPS_SUPPORT */\n                  /* all options taking 'MHD_socket' */\n                case MHD_OPTION_LISTEN_SOCKET:\n                  if (MHD_YES != parse_options (daemon,\n                                                servaddr,\n                                                opt,\n                                                (MHD_socket) oa[i].value,\n                                                MHD_OPTION_END))\n                    return MHD_NO;\n                  break;\n                  /* all options taking 'int' */\n                case MHD_OPTION_STRICT_FOR_CLIENT:\n                  if (MHD_YES != parse_options (daemon,\n                                                servaddr,\n                                                opt,\n                                                (int) oa[i].value,\n                                                MHD_OPTION_END))\n                    return MHD_NO;\n                  break;\n\t\t  /* all options taking one pointer */\n\t\tcase MHD_OPTION_SOCK_ADDR:\n\t\tcase MHD_OPTION_HTTPS_MEM_KEY:\n\t\tcase MHD_OPTION_HTTPS_KEY_PASSWORD:\n\t\tcase MHD_OPTION_HTTPS_MEM_CERT:\n\t\tcase MHD_OPTION_HTTPS_MEM_TRUST:\n\t        case MHD_OPTION_HTTPS_MEM_DHPARAMS:\n\t\tcase MHD_OPTION_HTTPS_PRIORITIES:\n\t\tcase MHD_OPTION_ARRAY:\n                case MHD_OPTION_HTTPS_CERT_CALLBACK:\n\t\t  if (MHD_YES != parse_options (daemon,\n\t\t\t\t\t\tservaddr,\n\t\t\t\t\t\topt,\n\t\t\t\t\t\toa[i].ptr_value,\n\t\t\t\t\t\tMHD_OPTION_END))\n\t\t    return MHD_NO;\n\t\t  break;\n\t\t  /* all options taking two pointers */\n\t\tcase MHD_OPTION_NOTIFY_COMPLETED:\n\t\tcase MHD_OPTION_NOTIFY_CONNECTION:\n\t\tcase MHD_OPTION_URI_LOG_CALLBACK:\n\t\tcase MHD_OPTION_EXTERNAL_LOGGER:\n\t\tcase MHD_OPTION_UNESCAPE_CALLBACK:\n\t\t  if (MHD_YES != parse_options (daemon,\n\t\t\t\t\t\tservaddr,\n\t\t\t\t\t\topt,\n\t\t\t\t\t\t(void *) oa[i].value,\n\t\t\t\t\t\toa[i].ptr_value,\n\t\t\t\t\t\tMHD_OPTION_END))\n\t\t    return MHD_NO;\n\t\t  break;\n\t\t  /* options taking size_t-number followed by pointer */\n\t\tcase MHD_OPTION_DIGEST_AUTH_RANDOM:\n\t\t  if (MHD_YES != parse_options (daemon,\n\t\t\t\t\t\tservaddr,\n\t\t\t\t\t\topt,\n\t\t\t\t\t\t(size_t) oa[i].value,\n\t\t\t\t\t\toa[i].ptr_value,\n\t\t\t\t\t\tMHD_OPTION_END))\n\t\t    return MHD_NO;\n\t\t  break;\n\t\tdefault:\n\t\t  return MHD_NO;\n\t\t}\n\t      i++;\n\t    }\n\t  break;\n        case MHD_OPTION_UNESCAPE_CALLBACK:\n          daemon->unescape_callback = va_arg (ap,\n                                              UnescapeCallback);\n          daemon->unescape_callback_cls = va_arg (ap,\n                                                  void *);\n          break;\n        default:\n#ifdef HAVE_MESSAGES\n          if ( ( (opt >= MHD_OPTION_HTTPS_MEM_KEY) &&\n                 (opt <= MHD_OPTION_HTTPS_PRIORITIES) ) ||\n               (opt == MHD_OPTION_HTTPS_MEM_TRUST))\n            {\n              MHD_DLOG (daemon,\n\t\t\t_(\"MHD HTTPS option %d passed to MHD compiled without HTTPS support\\n\"),\n\t\t\topt);\n            }\n          else\n            {\n              MHD_DLOG (daemon,\n\t\t\t_(\"Invalid option %d! (Did you terminate the list with MHD_OPTION_END?)\\n\"),\n\t\t\topt);\n            }\n#endif\n\t  return MHD_NO;\n        }\n    }\n  return MHD_YES;\n}",
      "lines": 457,
      "depth": 22,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "setup_epoll_fd": {
      "start_point": [
        5113,
        0
      ],
      "end_point": [
        5146,
        1
      ],
      "content": "static int\nsetup_epoll_fd (struct MHD_Daemon *daemon)\n{\n  int fd;\n\n#ifndef HAVE_MESSAGES\n  (void)daemon; /* Mute compiler warning. */\n#endif /* ! HAVE_MESSAGES */\n\n#ifdef USE_EPOLL_CREATE1\n  fd = epoll_create1 (EPOLL_CLOEXEC);\n#else  /* ! USE_EPOLL_CREATE1 */\n  fd = epoll_create (MAX_EVENTS);\n#endif /* ! USE_EPOLL_CREATE1 */\n  if (MHD_INVALID_SOCKET == fd)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _(\"Call to epoll_create1 failed: %s\\n\"),\n                MHD_socket_last_strerr_ ());\n#endif\n      return MHD_INVALID_SOCKET;\n    }\n#if !defined(USE_EPOLL_CREATE1)\n  if (! MHD_socket_noninheritable_ (fd))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _(\"Failed to set noninheritable mode on epoll FD.\\n\"));\n#endif\n    }\n#endif /* ! USE_EPOLL_CREATE1 */\n  return fd;\n}",
      "lines": 34,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "setup_epoll_to_listen": {
      "start_point": [
        5158,
        0
      ],
      "end_point": [
        5211,
        1
      ],
      "content": "static int\nsetup_epoll_to_listen (struct MHD_Daemon *daemon)\n{\n  struct epoll_event event;\n  MHD_socket ls;\n\n  daemon->epoll_fd = setup_epoll_fd (daemon);\n  if (-1 == daemon->epoll_fd)\n    return MHD_NO;\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  if (0 != (MHD_ALLOW_UPGRADE & daemon->options))\n    {\n       daemon->epoll_upgrade_fd = setup_epoll_fd (daemon);\n       if (MHD_INVALID_SOCKET == daemon->epoll_upgrade_fd)\n         return MHD_NO;\n    }\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n  if ( (MHD_INVALID_SOCKET == (ls = daemon->listen_fd)) ||\n       (daemon->was_quiesced) )\n    return MHD_YES; /* non-listening daemon */\n  event.events = EPOLLIN;\n  event.data.ptr = daemon;\n  if (0 != epoll_ctl (daemon->epoll_fd,\n\t\t      EPOLL_CTL_ADD,\n\t\t      ls,\n\t\t      &event))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _(\"Call to epoll_ctl failed: %s\\n\"),\n                MHD_socket_last_strerr_ ());\n#endif\n      return MHD_NO;\n    }\n  daemon->listen_socket_in_epoll = true;\n  if (MHD_ITC_IS_VALID_(daemon->itc))\n    {\n      event.events = EPOLLIN;\n      event.data.ptr = (void *) epoll_itc_marker;\n      if (0 != epoll_ctl (daemon->epoll_fd,\n                          EPOLL_CTL_ADD,\n                          MHD_itc_r_fd_ (daemon->itc),\n                          &event))\n        {\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (daemon,\n                    _(\"Call to epoll_ctl failed: %s\\n\"),\n                    MHD_socket_last_strerr_ ());\n#endif\n          return MHD_NO;\n        }\n    }\n  return MHD_YES;\n}",
      "lines": 54,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "MHD_start_daemon_va": {
      "start_point": [
        5236,
        0
      ],
      "end_point": [
        6111,
        1
      ],
      "content": "struct MHD_Daemon *\nMHD_start_daemon_va (unsigned int flags,\n                     uint16_t port,\n                     MHD_AcceptPolicyCallback apc,\n                     void *apc_cls,\n                     MHD_AccessHandlerCallback dh,\n                     void *dh_cls,\n\t\t     va_list ap)\n{\n  const MHD_SCKT_OPT_BOOL_ on = 1;\n  struct MHD_Daemon *daemon;\n  MHD_socket listen_fd;\n  struct sockaddr_in servaddr4;\n#if HAVE_INET6\n  struct sockaddr_in6 servaddr6;\n#endif\n  const struct sockaddr *servaddr = NULL;\n  socklen_t addrlen;\n  unsigned int i;\n  enum MHD_FLAG eflags; /* same type as in MHD_Daemon */\n  enum MHD_FLAG *pflags;\n\n  MHD_check_global_init_();\n  eflags = (enum MHD_FLAG) flags;\n  pflags = &eflags;\n#ifndef HAVE_INET6\n  if (0 != (*pflags & MHD_USE_IPv6))\n    return NULL;\n#endif\n#ifndef HAVE_POLL\n  if (0 != (*pflags & MHD_USE_POLL))\n    return NULL;\n#endif\n#ifndef EPOLL_SUPPORT\n  if (0 != (*pflags & MHD_USE_EPOLL))\n    return NULL;\n#endif /* ! EPOLL_SUPPORT */\n#ifndef HTTPS_SUPPORT\n  if (0 != (*pflags & MHD_USE_TLS))\n    return NULL;\n#endif /* ! HTTPS_SUPPORT */\n#ifndef TCP_FASTOPEN\n  if (0 != (*pflags & MHD_USE_TCP_FASTOPEN))\n    return NULL;\n#endif\n  if (0 != (*pflags & MHD_ALLOW_UPGRADE))\n    {\n#ifdef UPGRADE_SUPPORT\n      *pflags |= MHD_ALLOW_SUSPEND_RESUME;\n#else  /* ! UPGRADE_SUPPORT */\n      return NULL;\n#endif /* ! UPGRADE_SUPPORT */\n    }\n  if (NULL == dh)\n    return NULL;\n\n  /* Check for invalid combinations of flags. */\n  if ( ((0 != (*pflags & MHD_USE_POLL)) && (0 != (*pflags & MHD_USE_EPOLL))) ||\n       ((0 != (*pflags & MHD_USE_EPOLL)) && (0 != (*pflags & MHD_USE_THREAD_PER_CONNECTION))) ||\n       ((0 != (*pflags & MHD_USE_POLL)) &&\n           (0 == (*pflags & (MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_THREAD_PER_CONNECTION)))) ||\n       ((0 != (*pflags & MHD_USE_AUTO)) && (0 != (*pflags & (MHD_USE_POLL | MHD_USE_EPOLL)))) )\n    return NULL;\n\n  if (0 != (*pflags & MHD_USE_AUTO))\n    {\n      if (0 != (*pflags & MHD_USE_THREAD_PER_CONNECTION))\n        {\n          /* Thread per connection with internal polling thread. */\n#ifdef HAVE_POLL\n          *pflags |= MHD_USE_POLL;\n#else  /* ! HAVE_POLL */\n          /* use select() - do not modify flags */\n#endif /* ! HAVE_POLL */\n        }\n      else if (0 != (*pflags & MHD_USE_INTERNAL_POLLING_THREAD))\n        {\n          /* Internal polling thread. */\n#if defined(EPOLL_SUPPORT)\n          *pflags |= MHD_USE_EPOLL;\n#elif defined(HAVE_POLL)\n          *pflags |= MHD_USE_POLL;\n#else  /* !HAVE_POLL && !EPOLL_SUPPORT */\n          /* use select() - do not modify flags */\n#endif /* !HAVE_POLL && !EPOLL_SUPPORT */\n        }\n      else\n        {\n          /* Internal threads are not used - \"external\" polling mode. */\n#if defined(EPOLL_SUPPORT)\n          *pflags |= MHD_USE_EPOLL;\n#else  /* ! EPOLL_SUPPORT */\n          /* use select() - do not modify flags */\n#endif /* ! EPOLL_SUPPORT */\n        }\n    }\n\n  if (NULL == (daemon = MHD_calloc_ (1, sizeof (struct MHD_Daemon))))\n    return NULL;\n#ifdef EPOLL_SUPPORT\n  daemon->epoll_fd = -1;\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  daemon->epoll_upgrade_fd = -1;\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n#endif\n  /* try to open listen socket */\n#ifdef HTTPS_SUPPORT\n  daemon->priority_cache = NULL;\n  if (0 != (*pflags & MHD_USE_TLS))\n    {\n      gnutls_priority_init (&daemon->priority_cache,\n\t\t\t    \"NORMAL\",\n\t\t\t    NULL);\n    }\n#endif /* HTTPS_SUPPORT */\n  daemon->listen_fd = MHD_INVALID_SOCKET;\n  daemon->listening_address_reuse = 0;\n  daemon->options = *pflags;\n  pflags = &daemon->options;\n  daemon->strict_for_client = (0 != (*pflags & MHD_USE_PEDANTIC_CHECKS)) ? 1 : 0;\n  daemon->port = port;\n  daemon->apc = apc;\n  daemon->apc_cls = apc_cls;\n  daemon->default_handler = dh;\n  daemon->default_handler_cls = dh_cls;\n  daemon->connections = 0;\n  daemon->connection_limit = MHD_MAX_CONNECTIONS_DEFAULT;\n  daemon->pool_size = MHD_POOL_SIZE_DEFAULT;\n  daemon->pool_increment = MHD_BUF_INC_SIZE;\n  daemon->unescape_callback = &unescape_wrapper;\n  daemon->connection_timeout = 0;       /* no timeout */\n  MHD_itc_set_invalid_ (daemon->itc);\n#ifdef SOMAXCONN\n  daemon->listen_backlog_size = SOMAXCONN;\n#else  /* !SOMAXCONN */\n  daemon->listen_backlog_size = 511; /* should be safe value */\n#endif /* !SOMAXCONN */\n#ifdef HAVE_MESSAGES\n  daemon->custom_error_log = (MHD_LogCallback) &vfprintf;\n  daemon->custom_error_log_cls = stderr;\n#endif\n  if ( (0 != (*pflags & MHD_USE_THREAD_PER_CONNECTION)) &&\n       (0 == (*pflags & MHD_USE_INTERNAL_POLLING_THREAD)) )\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _(\"Warning: MHD_USE_THREAD_PER_CONNECTION must be used only with \"\n                  \"MHD_USE_INTERNAL_POLLING_THREAD. Flag MHD_USE_INTERNAL_POLLING_THREAD \"\n                   \"was added. Consider setting MHD_USE_INTERNAL_POLLING_THREAD explicitly.\\n\"));\n#endif\n      *pflags |= MHD_USE_INTERNAL_POLLING_THREAD;\n    }\n  if (0 == (*pflags & MHD_USE_INTERNAL_POLLING_THREAD))\n    *pflags &= ~MHD_USE_ITC; /* useless if we are using 'external' select */\n  else\n    {\n#ifdef HAVE_LISTEN_SHUTDOWN\n      if (0 != (*pflags & MHD_USE_NO_LISTEN_SOCKET))\n#endif\n        *pflags |= MHD_USE_ITC; /* yes, must use ITC to signal thread */\n    }\n#ifdef DAUTH_SUPPORT\n  daemon->digest_auth_rand_size = 0;\n  daemon->digest_auth_random = NULL;\n  daemon->nonce_nc_size = 4; /* tiny */\n#endif\n#ifdef HTTPS_SUPPORT\n  if (0 != (*pflags & MHD_USE_TLS))\n    {\n      daemon->cred_type = GNUTLS_CRD_CERTIFICATE;\n    }\n#endif /* HTTPS_SUPPORT */\n\n\n  if (MHD_YES != parse_options_va (daemon,\n                                   &servaddr,\n                                   ap))\n    {\n#ifdef HTTPS_SUPPORT\n      if ( (0 != (*pflags & MHD_USE_TLS)) &&\n\t   (NULL != daemon->priority_cache) )\n\tgnutls_priority_deinit (daemon->priority_cache);\n#endif /* HTTPS_SUPPORT */\n      free (daemon);\n      return NULL;\n    }\n#ifndef NDEBUG\n#ifdef HAVE_MESSAGES\n  MHD_DLOG (daemon,  _(\"Using debug build of libmicrohttpd.\\n\") );\n#endif /* HAVE_MESSAGES */\n#endif /* ! NDEBUG */\n  if ( (0 != (*pflags & MHD_USE_ITC)) &&\n       (0 == daemon->worker_pool_size) )\n    {\n      if (! MHD_itc_init_ (daemon->itc))\n        {\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (daemon,\n                    _(\"Failed to create inter-thread communication channel: %s\\n\"),\n                    MHD_itc_last_strerror_ ());\n#endif\n#ifdef HTTPS_SUPPORT\n          if (NULL != daemon->priority_cache)\n            gnutls_priority_deinit (daemon->priority_cache);\n#endif /* HTTPS_SUPPORT */\n          free (daemon);\n          return NULL;\n        }\n      if ( (0 == (*pflags & (MHD_USE_POLL | MHD_USE_EPOLL))) &&\n           (! MHD_SCKT_FD_FITS_FDSET_(MHD_itc_r_fd_ (daemon->itc),\n                                      NULL)) )\n        {\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (daemon,\n                    _(\"file descriptor for inter-thread communication channel exceeds maximum value\\n\"));\n#endif\n          MHD_itc_destroy_chk_ (daemon->itc);\n#ifdef HTTPS_SUPPORT\n          if (NULL != daemon->priority_cache)\n            gnutls_priority_deinit (daemon->priority_cache);\n#endif /* HTTPS_SUPPORT */\n          free (daemon);\n          return NULL;\n        }\n    }\n\n#ifdef DAUTH_SUPPORT\n  if (daemon->nonce_nc_size > 0)\n    {\n      if ( ( (size_t) (daemon->nonce_nc_size * sizeof (struct MHD_NonceNc))) /\n\t   sizeof(struct MHD_NonceNc) != daemon->nonce_nc_size)\n\t{\n#ifdef HAVE_MESSAGES\n\t  MHD_DLOG (daemon,\n\t\t    _(\"Specified value for NC_SIZE too large\\n\"));\n#endif\n#ifdef HTTPS_SUPPORT\n\t  if (0 != (*pflags & MHD_USE_TLS))\n\t    gnutls_priority_deinit (daemon->priority_cache);\n#endif /* HTTPS_SUPPORT */\n\t  free (daemon);\n\t  return NULL;\n\t}\n      daemon->nnc = malloc (daemon->nonce_nc_size * sizeof (struct MHD_NonceNc));\n      if (NULL == daemon->nnc)\n\t{\n#ifdef HAVE_MESSAGES\n\t  MHD_DLOG (daemon,\n\t\t    _(\"Failed to allocate memory for nonce-nc map: %s\\n\"),\n\t\t    MHD_strerror_ (errno));\n#endif\n#ifdef HTTPS_SUPPORT\n\t  if (0 != (*pflags & MHD_USE_TLS))\n\t    gnutls_priority_deinit (daemon->priority_cache);\n#endif /* HTTPS_SUPPORT */\n\t  free (daemon);\n\t  return NULL;\n\t}\n    }\n\n  if (! MHD_mutex_init_ (&daemon->nnc_lock))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n\t\t_(\"MHD failed to initialize nonce-nc mutex\\n\"));\n#endif\n#ifdef HTTPS_SUPPORT\n      if (0 != (*pflags & MHD_USE_TLS))\n\tgnutls_priority_deinit (daemon->priority_cache);\n#endif /* HTTPS_SUPPORT */\n      free (daemon->nnc);\n      free (daemon);\n      return NULL;\n    }\n#endif\n\n  /* Thread pooling currently works only with internal select thread model */\n  if ( (0 == (*pflags & MHD_USE_INTERNAL_POLLING_THREAD)) &&\n       (daemon->worker_pool_size > 0) )\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n\t\t_(\"MHD thread pooling only works with MHD_USE_INTERNAL_POLLING_THREAD\\n\"));\n#endif\n      goto free_and_fail;\n    }\n\n  if ( (MHD_INVALID_SOCKET == daemon->listen_fd) &&\n       (0 == (*pflags & MHD_USE_NO_LISTEN_SOCKET)) )\n    {\n      /* try to open listen socket */\n      listen_fd = MHD_socket_create_listen_(*pflags & MHD_USE_IPv6);\n      if (MHD_INVALID_SOCKET == listen_fd)\n\t{\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (daemon,\n                    _(\"Failed to create socket for listening: %s\\n\"),\n                    MHD_socket_last_strerr_ ());\n#endif\n\t  goto free_and_fail;\n\t}\n\n      /* Apply the socket options according to listening_address_reuse. */\n      if (0 == daemon->listening_address_reuse)\n        {\n#ifndef MHD_WINSOCK_SOCKETS\n          /* No user requirement, use \"traditional\" default SO_REUSEADDR\n           * on non-W32 platforms, and do not fail if it doesn't work.\n           * Don't use it on W32, because on W32 it will allow multiple\n           * bind to the same address:port, like SO_REUSEPORT on others. */\n          if (0 > setsockopt (listen_fd,\n                              SOL_SOCKET,\n                              SO_REUSEADDR,\n                              (void*)&on, sizeof (on)))\n          {\n#ifdef HAVE_MESSAGES\n            MHD_DLOG (daemon,\n                      _(\"setsockopt failed: %s\\n\"),\n                      MHD_socket_last_strerr_ ());\n#endif\n          }\n#endif /* ! MHD_WINSOCK_SOCKETS */\n        }\n      else if (daemon->listening_address_reuse > 0)\n        {\n          /* User requested to allow reusing listening address:port. */\n#ifndef MHD_WINSOCK_SOCKETS\n          /* Use SO_REUSEADDR on non-W32 platforms, and do not fail if\n           * it doesn't work. */\n          if (0 > setsockopt (listen_fd,\n                              SOL_SOCKET,\n                              SO_REUSEADDR,\n                              (void*)&on, sizeof (on)))\n            {\n#ifdef HAVE_MESSAGES\n              MHD_DLOG (daemon,\n                        _(\"setsockopt failed: %s\\n\"),\n                        MHD_socket_last_strerr_ ());\n#endif\n            }\n#endif /* ! MHD_WINSOCK_SOCKETS */\n          /* Use SO_REUSEADDR on Windows and SO_REUSEPORT on most platforms.\n           * Fail if SO_REUSEPORT is not defined or setsockopt fails.\n           */\n          /* SO_REUSEADDR on W32 has the same semantics\n             as SO_REUSEPORT on BSD/Linux */\n#if defined(MHD_WINSOCK_SOCKETS) || defined(SO_REUSEPORT)\n          if (0 > setsockopt (listen_fd,\n                              SOL_SOCKET,\n#ifndef MHD_WINSOCK_SOCKETS\n                              SO_REUSEPORT,\n#else  /* MHD_WINSOCK_SOCKETS */\n                              SO_REUSEADDR,\n#endif /* MHD_WINSOCK_SOCKETS */\n                              (void *) &on,\n                              sizeof (on)))\n            {\n#ifdef HAVE_MESSAGES\n              MHD_DLOG (daemon,\n                        _(\"setsockopt failed: %s\\n\"),\n                        MHD_socket_last_strerr_ ());\n#endif\n              goto free_and_fail;\n            }\n#else  /* !MHD_WINSOCK_SOCKETS && !SO_REUSEPORT */\n          /* we're supposed to allow address:port re-use, but\n             on this platform we cannot; fail hard */\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (daemon,\n                    _(\"Cannot allow listening address reuse: SO_REUSEPORT not defined\\n\"));\n#endif\n          goto free_and_fail;\n#endif /* !MHD_WINSOCK_SOCKETS && !SO_REUSEPORT */\n        }\n      else /* if (daemon->listening_address_reuse < 0) */\n        {\n          /* User requested to disallow reusing listening address:port.\n           * Do nothing except for Windows where SO_EXCLUSIVEADDRUSE\n           * is used and Solaris with SO_EXCLBIND.\n           * Fail if MHD was compiled for W32 without SO_EXCLUSIVEADDRUSE\n           * or setsockopt fails.\n           */\n#if (defined(MHD_WINSOCK_SOCKETS) && defined(SO_EXCLUSIVEADDRUSE)) || \\\n    (defined(__sun) && defined(SO_EXCLBIND))\n          if (0 > setsockopt (listen_fd,\n                              SOL_SOCKET,\n#ifdef SO_EXCLUSIVEADDRUSE\n                              SO_EXCLUSIVEADDRUSE,\n#else  /* SO_EXCLBIND */\n                              SO_EXCLBIND,\n#endif /* SO_EXCLBIND */\n                              (void *) &on,\n                              sizeof (on)))\n            {\n#ifdef HAVE_MESSAGES\n              MHD_DLOG (daemon,\n                        _(\"setsockopt failed: %s\\n\"),\n                        MHD_socket_last_strerr_ ());\n#endif\n              goto free_and_fail;\n            }\n#elif defined(MHD_WINSOCK_SOCKETS) /* SO_EXCLUSIVEADDRUSE not defined on W32? */\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (daemon,\n                    _(\"Cannot disallow listening address reuse: SO_EXCLUSIVEADDRUSE not defined\\n\"));\n#endif\n          goto free_and_fail;\n#endif /* MHD_WINSOCK_SOCKETS */\n        }\n\n      /* check for user supplied sockaddr */\n#if HAVE_INET6\n      if (0 != (*pflags & MHD_USE_IPv6))\n\taddrlen = sizeof (struct sockaddr_in6);\n      else\n#endif\n\taddrlen = sizeof (struct sockaddr_in);\n      if (NULL == servaddr)\n\t{\n#if HAVE_INET6\n\t  if (0 != (*pflags & MHD_USE_IPv6))\n\t    {\n#ifdef IN6ADDR_ANY_INIT\n\t      static const struct in6_addr static_in6any = IN6ADDR_ANY_INIT;\n#endif\n              memset (&servaddr6,\n                      0,\n                      sizeof (struct sockaddr_in6));\n\t      servaddr6.sin6_family = AF_INET6;\n\t      servaddr6.sin6_port = htons (port);\n#ifdef IN6ADDR_ANY_INIT\n\t      servaddr6.sin6_addr = static_in6any;\n#endif\n#if HAVE_SOCKADDR_IN_SIN_LEN\n\t      servaddr6.sin6_len = sizeof (struct sockaddr_in6);\n#endif\n\t      servaddr = (struct sockaddr *) &servaddr6;\n\t    }\n\t  else\n#endif\n\t    {\n\t      memset (&servaddr4,\n                      0,\n                      sizeof (struct sockaddr_in));\n\t      servaddr4.sin_family = AF_INET;\n\t      servaddr4.sin_port = htons (port);\n\t      if (0 != INADDR_ANY)\n\t        servaddr4.sin_addr.s_addr = htonl (INADDR_ANY);\n#if HAVE_SOCKADDR_IN_SIN_LEN\n\t      servaddr4.sin_len = sizeof (struct sockaddr_in);\n#endif\n\t      servaddr = (struct sockaddr *) &servaddr4;\n\t    }\n\t}\n      daemon->listen_fd = listen_fd;\n\n      if (0 != (*pflags & MHD_USE_IPv6))\n\t{\n#ifdef IPPROTO_IPV6\n#ifdef IPV6_V6ONLY\n\t  /* Note: \"IPV6_V6ONLY\" is declared by Windows Vista ff., see \"IPPROTO_IPV6 Socket Options\"\n\t     (http://msdn.microsoft.com/en-us/library/ms738574%28v=VS.85%29.aspx);\n\t     and may also be missing on older POSIX systems; good luck if you have any of those,\n\t     your IPv6 socket may then also bind against IPv4 anyway... */\n\t  const MHD_SCKT_OPT_BOOL_ v6_only =\n            (MHD_USE_DUAL_STACK != (*pflags & MHD_USE_DUAL_STACK));\n\t  if (0 > setsockopt (listen_fd,\n                              IPPROTO_IPV6, IPV6_V6ONLY,\n                              (const void *) &v6_only,\n                              sizeof (v6_only)))\n      {\n#ifdef HAVE_MESSAGES\n            MHD_DLOG (daemon,\n                      _(\"setsockopt failed: %s\\n\"),\n                      MHD_socket_last_strerr_ ());\n#endif\n      }\n#endif\n#endif\n\t}\n      if (-1 == bind (listen_fd, servaddr, addrlen))\n\t{\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (daemon,\n                    _(\"Failed to bind to port %u: %s\\n\"),\n                    (unsigned int) port,\n                    MHD_socket_last_strerr_ ());\n#endif\n\t  MHD_socket_close_chk_ (listen_fd);\n\t  goto free_and_fail;\n\t}\n#ifdef TCP_FASTOPEN\n      if (0 != (*pflags & MHD_USE_TCP_FASTOPEN))\n      {\n        if (0 == daemon->fastopen_queue_size)\n          daemon->fastopen_queue_size = MHD_TCP_FASTOPEN_QUEUE_SIZE_DEFAULT;\n        if (0 != setsockopt (listen_fd,\n                             IPPROTO_TCP,\n                             TCP_FASTOPEN,\n                             &daemon->fastopen_queue_size,\n                             sizeof (daemon->fastopen_queue_size)))\n        {\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (daemon,\n                    _(\"setsockopt failed: %s\\n\"),\n                    MHD_socket_last_strerr_ ());\n#endif\n        }\n      }\n#endif\n      if (listen (listen_fd,\n                  daemon->listen_backlog_size) < 0)\n\t{\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (daemon,\n                    _(\"Failed to listen for connections: %s\\n\"),\n                    MHD_socket_last_strerr_ ());\n#endif\n\t  MHD_socket_close_chk_ (listen_fd);\n\t  goto free_and_fail;\n\t}\n    }\n  else\n    {\n      listen_fd = daemon->listen_fd;\n    }\n\n  if ( (0 == daemon->port) &&\n       (0 == (*pflags & MHD_USE_NO_LISTEN_SOCKET)) )\n    { /* Get port number. */\n      struct sockaddr_storage servaddr;\n\n      memset (&servaddr,\n              0,\n              sizeof (struct sockaddr_storage));\n      addrlen = sizeof (servaddr);\n      if (0 != getsockname (listen_fd,\n                            (struct sockaddr *) &servaddr,\n                            &addrlen))\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _(\"Failed to get listen port number: %s\\n\"),\n                  MHD_socket_last_strerr_ ());\n#endif /* HAVE_MESSAGES */\n        }\n#ifdef MHD_POSIX_SOCKETS\n      else if (sizeof (servaddr) < addrlen)\n        {\n          /* should be impossible with `struct sockaddr_storage` */\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (daemon,\n                    _(\"Failed to get listen port number (`struct sockaddr_storage` too small!?)\\n\"));\n#endif /* HAVE_MESSAGES */\n        }\n#endif /* MHD_POSIX_SOCKETS */\n      else\n        {\n          switch (servaddr.ss_family)\n          {\n          case AF_INET:\n            {\n              struct sockaddr_in *s4 = (struct sockaddr_in *) &servaddr;\n\n              daemon->port = ntohs (s4->sin_port);\n              break;\n            }\n#ifdef HAVE_INET6\n          case AF_INET6:\n            {\n              struct sockaddr_in6 *s6 = (struct sockaddr_in6 *) &servaddr;\n\n              daemon->port = ntohs(s6->sin6_port);\n              mhd_assert (0 != (*pflags & MHD_USE_IPv6));\n              break;\n            }\n#endif /* HAVE_INET6 */\n#ifdef AF_UNIX\n          case AF_UNIX:\n            daemon->port = 0; /* special value for UNIX domain sockets */\n            break;\n#endif\n          default:\n#ifdef HAVE_MESSAGES\n            MHD_DLOG (daemon,\n                      _(\"Unknown address family!\\n\"));\n#endif\n            daemon->port = 0; /* ugh */\n            break;\n          }\n        }\n    }\n\n  if ( (MHD_INVALID_SOCKET != listen_fd) &&\n       (! MHD_socket_nonblocking_ (listen_fd)) )\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _(\"Failed to set nonblocking mode on listening socket: %s\\n\"),\n                MHD_socket_last_strerr_());\n#endif\n      if (0 != (*pflags & MHD_USE_EPOLL) ||\n          daemon->worker_pool_size > 0)\n        {\n           /* Accept must be non-blocking. Multiple children may wake up\n            * to handle a new connection, but only one will win the race.\n            * The others must immediately return. */\n          MHD_socket_close_chk_ (listen_fd);\n          goto free_and_fail;\n        }\n    }\n  if ( (MHD_INVALID_SOCKET != listen_fd) &&\n       (! MHD_SCKT_FD_FITS_FDSET_(listen_fd,\n                                  NULL)) &&\n       (0 == (*pflags & (MHD_USE_POLL | MHD_USE_EPOLL)) ) )\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _(\"Socket descriptor larger than FD_SETSIZE: %d > %d\\n\"),\n                listen_fd,\n                FD_SETSIZE);\n#endif\n      MHD_socket_close_chk_ (listen_fd);\n      goto free_and_fail;\n    }\n\n#ifdef EPOLL_SUPPORT\n  if ( (0 != (*pflags & MHD_USE_EPOLL)) &&\n       (0 == daemon->worker_pool_size) &&\n       (0 == (*pflags & MHD_USE_NO_LISTEN_SOCKET)) )\n    {\n      if (0 != (*pflags & MHD_USE_THREAD_PER_CONNECTION))\n\t{\n#ifdef HAVE_MESSAGES\n\t  MHD_DLOG (daemon,\n\t\t    _(\"Combining MHD_USE_THREAD_PER_CONNECTION and MHD_USE_EPOLL is not supported.\\n\"));\n#endif\n\t  goto free_and_fail;\n\t}\n      if (MHD_YES != setup_epoll_to_listen (daemon))\n\tgoto free_and_fail;\n    }\n#endif /* EPOLL_SUPPORT */\n\n  if (! MHD_mutex_init_ (&daemon->per_ip_connection_mutex))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _(\"MHD failed to initialize IP connection limit mutex\\n\"));\n#endif\n      if (MHD_INVALID_SOCKET != listen_fd)\n        MHD_socket_close_chk_ (listen_fd);\n      goto free_and_fail;\n    }\n  if (0 == daemon->worker_pool_size)\n    { /* Initialise connection mutex only if this daemon will handle\n       * any connections by itself. */\n      if (! MHD_mutex_init_ (&daemon->cleanup_connection_mutex))\n        {\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (daemon,\n                    _(\"MHD failed to initialize IP connection limit mutex\\n\"));\n#endif\n          MHD_mutex_destroy_chk_ (&daemon->cleanup_connection_mutex);\n          if (MHD_INVALID_SOCKET != listen_fd)\n            MHD_socket_close_chk_ (listen_fd);\n          goto free_and_fail;\n        }\n    }\n\n#ifdef HTTPS_SUPPORT\n  /* initialize HTTPS daemon certificate aspects & send / recv functions */\n  if ( (0 != (*pflags & MHD_USE_TLS)) &&\n       (0 != MHD_TLS_init (daemon)) )\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n\t\t_(\"Failed to initialize TLS support\\n\"));\n#endif\n      if (MHD_INVALID_SOCKET != listen_fd)\n        MHD_socket_close_chk_ (listen_fd);\n      if (0 == daemon->worker_pool_size)\n        MHD_mutex_destroy_chk_ (&daemon->cleanup_connection_mutex);\n      MHD_mutex_destroy_chk_ (&daemon->per_ip_connection_mutex);\n      goto free_and_fail;\n    }\n#endif /* HTTPS_SUPPORT */\n  if ( (0 != (*pflags & MHD_USE_INTERNAL_POLLING_THREAD)) &&\n       (0 == (*pflags & MHD_USE_NO_LISTEN_SOCKET)) )\n    {\n      if (0 == daemon->worker_pool_size)\n        {\n          if (! MHD_create_named_thread_ (&daemon->pid,\n                (*pflags & MHD_USE_THREAD_PER_CONNECTION) ?\n                  \"MHD-listen\" : \"MHD-single\",\n                daemon->thread_stack_size,\n                &MHD_polling_thread,\n                daemon) )\n            {\n#ifdef HAVE_MESSAGES\n              MHD_DLOG (daemon,\n                        _(\"Failed to create listen thread: %s\\n\"),\n                        MHD_strerror_ (errno));\n#endif\n              MHD_mutex_destroy_chk_ (&daemon->cleanup_connection_mutex);\n              MHD_mutex_destroy_chk_ (&daemon->per_ip_connection_mutex);\n              if (MHD_INVALID_SOCKET != listen_fd)\n                MHD_socket_close_chk_ (listen_fd);\n              goto free_and_fail;\n            }\n        }\n      else /* 0 < daemon->worker_pool_size */\n        {\n          /* Coarse-grained count of connections per thread (note error\n           * due to integer division). Also keep track of how many\n           * connections are leftover after an equal split. */\n          unsigned int conns_per_thread = daemon->connection_limit\n                                          / daemon->worker_pool_size;\n          unsigned int leftover_conns = daemon->connection_limit\n                                        % daemon->worker_pool_size;\n\n          i = 0; /* we need this in case fcntl or malloc fails */\n\n          /* Allocate memory for pooled objects */\n          daemon->worker_pool = malloc (sizeof (struct MHD_Daemon)\n                                        * daemon->worker_pool_size);\n          if (NULL == daemon->worker_pool)\n            goto thread_failed;\n\n          /* Start the workers in the pool */\n          for (i = 0; i < daemon->worker_pool_size; ++i)\n            {\n              /* Create copy of the Daemon object for each worker */\n              struct MHD_Daemon *d = &daemon->worker_pool[i];\n\n              memcpy (d, daemon, sizeof (struct MHD_Daemon));\n              /* Adjust pooling params for worker daemons; note that memcpy()\n                 has already copied MHD_USE_INTERNAL_POLLING_THREAD thread model into\n                 the worker threads. */\n              d->master = daemon;\n              d->worker_pool_size = 0;\n              d->worker_pool = NULL;\n\n              if (0 != (*pflags & MHD_USE_ITC))\n                {\n                  if (! MHD_itc_init_ (d->itc))\n                    {\n#ifdef HAVE_MESSAGES\n                      MHD_DLOG (daemon,\n                                _(\"Failed to create worker inter-thread communication channel: %s\\n\"),\n                                MHD_itc_last_strerror_() );\n#endif\n                      goto thread_failed;\n                    }\n                  if ( (0 == (*pflags & (MHD_USE_POLL | MHD_USE_EPOLL))) &&\n                       (! MHD_SCKT_FD_FITS_FDSET_(MHD_itc_r_fd_ (d->itc),\n                                                  NULL)) )\n                    {\n#ifdef HAVE_MESSAGES\n                      MHD_DLOG (daemon,\n                                _(\"File descriptor for worker inter-thread communication channel exceeds maximum value\\n\"));\n#endif\n                      MHD_itc_destroy_chk_ (d->itc);\n                      goto thread_failed;\n                    }\n                }\n              else\n                MHD_itc_set_invalid_ (d->itc);\n\n              /* Divide available connections evenly amongst the threads.\n               * Thread indexes in [0, leftover_conns) each get one of the\n               * leftover connections. */\n              d->connection_limit = conns_per_thread;\n              if (i < leftover_conns)\n                ++d->connection_limit;\n#ifdef EPOLL_SUPPORT\n              if ( (0 != (*pflags & MHD_USE_EPOLL)) &&\n                   (MHD_YES != setup_epoll_to_listen (d)) )\n                goto thread_failed;\n#endif\n              /* Must init cleanup connection mutex for each worker */\n              if (! MHD_mutex_init_ (&d->cleanup_connection_mutex))\n                {\n#ifdef HAVE_MESSAGES\n                  MHD_DLOG (daemon,\n                            _(\"MHD failed to initialize cleanup connection mutex\\n\"));\n#endif\n                  goto thread_failed;\n                }\n\n              /* Spawn the worker thread */\n              if (! MHD_create_named_thread_ (&d->pid,\n                                              \"MHD-worker\",\n                                              daemon->thread_stack_size,\n                                              &MHD_polling_thread,\n                                              d))\n                {\n#ifdef HAVE_MESSAGES\n                  MHD_DLOG (daemon,\n                            _(\"Failed to create pool thread: %s\\n\"),\n                            MHD_strerror_ (errno));\n#endif\n                  /* Free memory for this worker; cleanup below handles\n                   * all previously-created workers. */\n                  MHD_mutex_destroy_chk_ (&d->cleanup_connection_mutex);\n                  goto thread_failed;\n                }\n            }\n        }\n    }\n#ifdef HTTPS_SUPPORT\n  /* API promises to never use the password after initialization,\n     so we additionally NULL it here to not deref a dangling pointer. */\n  daemon->https_key_password = NULL;\n#endif /* HTTPS_SUPPORT */\n\n  return daemon;\n\nthread_failed:\n  /* If no worker threads created, then shut down normally. Calling\n     MHD_stop_daemon (as we do below) doesn't work here since it\n     assumes a 0-sized thread pool means we had been in the default\n     MHD_USE_INTERNAL_POLLING_THREAD mode. */\n  if (0 == i)\n    {\n      if (MHD_INVALID_SOCKET != listen_fd)\n        MHD_socket_close_chk_ (listen_fd);\n      MHD_mutex_destroy_chk_ (&daemon->per_ip_connection_mutex);\n      if (NULL != daemon->worker_pool)\n        free (daemon->worker_pool);\n      goto free_and_fail;\n    }\n\n  /* Shutdown worker threads we've already created. Pretend\n     as though we had fully initialized our daemon, but\n     with a smaller number of threads than had been\n     requested. */\n  daemon->worker_pool_size = i;\n  MHD_stop_daemon (daemon);\n  return NULL;\n\n free_and_fail:\n  /* clean up basic memory state in 'daemon' and return NULL to\n     indicate failure */\n#ifdef EPOLL_SUPPORT\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  if (daemon->upgrade_fd_in_epoll)\n    {\n      if (0 != epoll_ctl (daemon->epoll_fd,\n\t\t\t  EPOLL_CTL_DEL,\n\t\t\t  daemon->epoll_upgrade_fd,\n\t\t\t  NULL))\n\tMHD_PANIC (_(\"Failed to remove FD from epoll set\\n\"));\n      daemon->upgrade_fd_in_epoll = false;\n    }\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n  if (-1 != daemon->epoll_fd)\n    close (daemon->epoll_fd);\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  if (-1 != daemon->epoll_upgrade_fd)\n    close (daemon->epoll_upgrade_fd);\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n#endif /* EPOLL_SUPPORT */\n#ifdef DAUTH_SUPPORT\n  free (daemon->nnc);\n  MHD_mutex_destroy_chk_ (&daemon->nnc_lock);\n#endif\n#ifdef HTTPS_SUPPORT\n  if (0 != (*pflags & MHD_USE_TLS))\n    gnutls_priority_deinit (daemon->priority_cache);\n#endif /* HTTPS_SUPPORT */\n  if (MHD_ITC_IS_VALID_(daemon->itc))\n    MHD_itc_destroy_chk_ (daemon->itc);\n  free (daemon);\n  return NULL;\n}",
      "lines": 876,
      "depth": 21,
      "decorators": [
        "struct MHD_Daemon",
        "struct",
        "MHD_Daemon",
        "*\nMHD_start_daemon_va (unsigned int flags,\n                     uint16_t port,\n                     MHD_AcceptPolicyCallback apc,\n                     void *apc_cls,\n                     MHD_AccessHandlerCallback dh,\n                     void *dh_cls,\n\t\t     va_list ap)",
        "*"
      ]
    },
    "close_all_connections": {
      "start_point": [
        6122,
        0
      ],
      "end_point": [
        6261,
        1
      ],
      "content": "static void\nclose_all_connections (struct MHD_Daemon *daemon)\n{\n  struct MHD_Connection *pos;\n  const bool used_thr_p_c = (0 != (daemon->options & MHD_USE_THREAD_PER_CONNECTION));\n#ifdef UPGRADE_SUPPORT\n  const bool upg_allowed = (0 != (daemon->options & MHD_ALLOW_UPGRADE));\n#endif /* UPGRADE_SUPPORT */\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n  struct MHD_UpgradeResponseHandle *urh;\n  struct MHD_UpgradeResponseHandle *urhn;\n  const bool used_tls = (0 != (daemon->options & MHD_USE_TLS));\n\n  mhd_assert (NULL == daemon->worker_pool);\n  mhd_assert (daemon->shutdown);\n  /* give upgraded HTTPS connections a chance to finish */\n  /* 'daemon->urh_head' is not used in thread-per-connection mode. */\n  for (urh = daemon->urh_tail; NULL != urh; urh = urhn)\n    {\n      urhn = urh->prev;\n      /* call generic forwarding function for passing data\n         with chance to detect that application is done. */\n      process_urh (urh);\n      MHD_connection_finish_forward_ (urh->connection);\n      urh->clean_ready = true;\n      /* Resuming will move connection to cleanup list. */\n      MHD_resume_connection(urh->connection);\n    }\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n\n  /* Give suspended connections a chance to resume to avoid\n     running into the check for there not being any suspended\n     connections left in case of a tight race with a recently\n     resumed connection. */\n  if (0 != (MHD_TEST_ALLOW_SUSPEND_RESUME & daemon->options))\n    {\n      daemon->resuming = true; /* Force check for pending resume. */\n      resume_suspended_connections (daemon);\n    }\n  /* first, make sure all threads are aware of shutdown; need to\n     traverse DLLs in peace... */\n  MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n#ifdef UPGRADE_SUPPORT\n  if (upg_allowed)\n    {\n      struct MHD_Connection * susp;\n\n      susp = daemon->suspended_connections_tail;\n      while (NULL != susp)\n        {\n          if (NULL == susp->urh) /* \"Upgraded\" connection? */\n            MHD_PANIC (_(\"MHD_stop_daemon() called while we have suspended connections.\\n\"));\n#ifdef HTTPS_SUPPORT\n          else if (used_tls &&\n                   used_thr_p_c &&\n                   (! susp->urh->clean_ready) )\n            shutdown (susp->urh->app.socket,\n                      SHUT_RDWR); /* Wake thread by shutdown of app socket. */\n#endif /* HTTPS_SUPPORT */\n          else\n            {\n#ifdef HAVE_MESSAGES\n              if (! susp->urh->was_closed)\n                MHD_DLOG (daemon,\n                          _(\"Initiated daemon shutdown while \\\"upgraded\\\" connection was not closed.\\n\"));\n#endif\n              susp->urh->was_closed = true;\n              /* If thread-per-connection is used, connection's thread\n               * may still processing \"upgrade\" (exiting). */\n              if (! used_thr_p_c)\n                MHD_connection_finish_forward_ (susp);\n              /* Do not use MHD_resume_connection() as mutex is\n               * already locked. */\n              susp->resuming = true;\n              daemon->resuming = true;\n            }\n          susp = susp->prev;\n        }\n    }\n  else /* This 'else' is combined with next 'if' */\n#endif /* UPGRADE_SUPPORT */\n  if (NULL != daemon->suspended_connections_head)\n    MHD_PANIC (_(\"MHD_stop_daemon() called while we have suspended connections.\\n\"));\n  for (pos = daemon->connections_tail; NULL != pos; pos = pos->prev)\n    {\n      shutdown (pos->socket_fd,\n                SHUT_RDWR);\n#if MHD_WINSOCK_SOCKETS\n      if ( (0 != (daemon->options & MHD_USE_THREAD_PER_CONNECTION)) &&\n           (MHD_ITC_IS_VALID_(daemon->itc)) &&\n           (! MHD_itc_activate_ (daemon->itc, \"e\")) )\n        MHD_PANIC (_(\"Failed to signal shutdown via inter-thread communication channel\"));\n#endif\n    }\n\n  /* now, collect per-connection threads */\n  if (used_thr_p_c)\n    {\n      pos = daemon->connections_tail;\n      while (NULL != pos)\n      {\n        if (! pos->thread_joined)\n          {\n            MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n            if (! MHD_join_thread_ (pos->pid.handle))\n              MHD_PANIC (_(\"Failed to join a thread\\n\"));\n            MHD_mutex_lock_chk_ (&daemon->cleanup_connection_mutex);\n            pos->thread_joined = true;\n            /* The thread may have concurrently modified the DLL,\n               need to restart from the beginning */\n            pos = daemon->connections_tail;\n            continue;\n          }\n        pos = pos->prev;\n      }\n    }\n  MHD_mutex_unlock_chk_ (&daemon->cleanup_connection_mutex);\n\n#ifdef UPGRADE_SUPPORT\n  /* Finished threads with \"upgraded\" connections need to be moved\n   * to cleanup list by resume_suspended_connections(). */\n  /* \"Upgraded\" connections that were not closed explicitly by\n   * application should be moved to cleanup list too. */\n  if (upg_allowed)\n    {\n      daemon->resuming = true; /* Force check for pending resume. */\n      resume_suspended_connections (daemon);\n    }\n#endif /* UPGRADE_SUPPORT */\n\n  /* now that we're alone, move everyone to cleanup */\n  while (NULL != (pos = daemon->connections_tail))\n  {\n    if ( (0 != (daemon->options & MHD_USE_THREAD_PER_CONNECTION)) &&\n         (! pos->thread_joined) )\n      MHD_PANIC (_(\"Failed to join a thread\\n\"));\n    close_connection (pos);\n  }\n  MHD_cleanup_connections (daemon);\n}",
      "lines": 140,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "MHD_stop_daemon": {
      "start_point": [
        6270,
        0
      ],
      "end_point": [
        6411,
        1
      ],
      "content": "void\nMHD_stop_daemon (struct MHD_Daemon *daemon)\n{\n  MHD_socket fd;\n  unsigned int i;\n\n  if (NULL == daemon)\n    return;\n\n  daemon->shutdown = true;\n  if (daemon->was_quiesced)\n    fd = MHD_INVALID_SOCKET; /* Do not use FD if daemon was quiesced */\n  else\n    fd = daemon->listen_fd;\n\n  if (NULL != daemon->worker_pool)\n    { /* Master daemon with worker pool. */\n      mhd_assert (1 < daemon->worker_pool_size);\n      mhd_assert (0 != (daemon->options & MHD_USE_INTERNAL_POLLING_THREAD));\n\n      /* Let workers shutdown in parallel. */\n      for (i = 0; i < daemon->worker_pool_size; ++i)\n        {\n          daemon->worker_pool[i].shutdown = true;\n          if (MHD_ITC_IS_VALID_(daemon->worker_pool[i].itc))\n            {\n              if (! MHD_itc_activate_ (daemon->worker_pool[i].itc, \"e\"))\n                MHD_PANIC (_(\"Failed to signal shutdown via inter-thread communication channel.\"));\n            }\n          else\n            mhd_assert (MHD_INVALID_SOCKET != fd);\n        }\n#ifdef HAVE_LISTEN_SHUTDOWN\n      if (MHD_INVALID_SOCKET != fd)\n        {\n          (void) shutdown (fd,\n                           SHUT_RDWR);\n        }\n#endif /* HAVE_LISTEN_SHUTDOWN */\n      for (i = 0; i < daemon->worker_pool_size; ++i)\n        {\n          MHD_stop_daemon (&daemon->worker_pool[i]);\n        }\n      free (daemon->worker_pool);\n      mhd_assert (MHD_ITC_IS_INVALID_(daemon->itc));\n#ifdef EPOLL_SUPPORT\n      mhd_assert (-1 == daemon->epoll_fd);\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n      mhd_assert (-1 == daemon->epoll_upgrade_fd);\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n#endif /* EPOLL_SUPPORT */\n    }\n  else\n    { /* Worker daemon or single daemon. */\n      if (0 != (daemon->options & MHD_USE_INTERNAL_POLLING_THREAD))\n        { /* Worker daemon or single daemon with internal thread(s). */\n          mhd_assert (0 == daemon->worker_pool_size);\n          if (0 != (MHD_TEST_ALLOW_SUSPEND_RESUME & daemon->options))\n            resume_suspended_connections (daemon);\n\n          if (0 != (daemon->options & MHD_USE_INTERNAL_POLLING_THREAD))\n            {\n              /* Separate thread(s) is used for polling sockets. */\n              if (MHD_ITC_IS_VALID_(daemon->itc))\n                {\n                  if (! MHD_itc_activate_ (daemon->itc, \"e\"))\n                    MHD_PANIC (_(\"Failed to signal shutdown via inter-thread communication channel\"));\n                }\n              else\n                {\n#ifdef HAVE_LISTEN_SHUTDOWN\n                  if (MHD_INVALID_SOCKET != fd)\n                    {\n                      if (NULL == daemon->master)\n                        (void) shutdown (fd,\n                                         SHUT_RDWR);\n                    }\n                  else\n#endif /* HAVE_LISTEN_SHUTDOWN */\n                    mhd_assert (false); /* Should never happen */\n                }\n\n              if (! MHD_join_thread_ (daemon->pid.handle))\n                {\n                  MHD_PANIC (_(\"Failed to join a thread\\n\"));\n                }\n              /* close_all_connections() was called in daemon thread. */\n            }\n        }\n      else\n        {\n          /* No internal threads are used for polling sockets. */\n          close_all_connections (daemon);\n        }\n      if (MHD_ITC_IS_VALID_ (daemon->itc))\n        MHD_itc_destroy_chk_ (daemon->itc);\n\n#ifdef EPOLL_SUPPORT\n      if ( (0 != (daemon->options & MHD_USE_EPOLL)) &&\n           (-1 != daemon->epoll_fd) )\n        MHD_socket_close_chk_ (daemon->epoll_fd);\n#if defined(HTTPS_SUPPORT) && defined(UPGRADE_SUPPORT)\n      if ( (0 != (daemon->options & MHD_USE_EPOLL)) &&\n           (-1 != daemon->epoll_upgrade_fd) )\n        MHD_socket_close_chk_ (daemon->epoll_upgrade_fd);\n#endif /* HTTPS_SUPPORT && UPGRADE_SUPPORT */\n#endif /* EPOLL_SUPPORT */\n\n      MHD_mutex_destroy_chk_ (&daemon->cleanup_connection_mutex);\n    }\n\n  if (NULL == daemon->master)\n    { /* Cleanup that should be done only one time in master/single daemon.\n       * Do not perform this cleanup in worker daemons. */\n\n      if (MHD_INVALID_SOCKET != fd)\n        MHD_socket_close_chk_ (fd);\n\n      /* TLS clean up */\n#ifdef HTTPS_SUPPORT\n      if (daemon->have_dhparams)\n        {\n          gnutls_dh_params_deinit (daemon->https_mem_dhparams);\n          daemon->have_dhparams = false;\n        }\n      if (0 != (daemon->options & MHD_USE_TLS))\n        {\n          gnutls_priority_deinit (daemon->priority_cache);\n          if (daemon->x509_cred)\n            gnutls_certificate_free_credentials (daemon->x509_cred);\n        }\n#endif /* HTTPS_SUPPORT */\n\n#ifdef DAUTH_SUPPORT\n      free (daemon->nnc);\n      MHD_mutex_destroy_chk_ (&daemon->nnc_lock);\n#endif\n      MHD_mutex_destroy_chk_ (&daemon->per_ip_connection_mutex);\n\n      free (daemon);\n    }\n}",
      "lines": 142,
      "depth": 19,
      "decorators": [
        "void"
      ]
    },
    "MHD_get_daemon_info": {
      "start_point": [
        6425,
        0
      ],
      "end_point": [
        6470,
        1
      ],
      "content": "const union MHD_DaemonInfo *\nMHD_get_daemon_info (struct MHD_Daemon *daemon,\n\t\t     enum MHD_DaemonInfoType info_type,\n\t\t     ...)\n{\n  if (NULL == daemon)\n    return NULL;\n  switch (info_type)\n    {\n    case MHD_DAEMON_INFO_KEY_SIZE:\n      return NULL; /* no longer supported */\n    case MHD_DAEMON_INFO_MAC_KEY_SIZE:\n      return NULL; /* no longer supported */\n    case MHD_DAEMON_INFO_LISTEN_FD:\n      return (const union MHD_DaemonInfo *) &daemon->listen_fd;\n#ifdef EPOLL_SUPPORT\n    case MHD_DAEMON_INFO_EPOLL_FD:\n      return (const union MHD_DaemonInfo *) &daemon->epoll_fd;\n#endif\n    case MHD_DAEMON_INFO_CURRENT_CONNECTIONS:\n      if (0 == (daemon->options & MHD_USE_INTERNAL_POLLING_THREAD))\n        {\n          /* Assume that MHD_run() in not called in other thread\n           * at the same time. */\n          MHD_cleanup_connections (daemon);\n        }\n      else if (daemon->worker_pool)\n        {\n          unsigned int i;\n          /* Collect the connection information stored in the workers. */\n          daemon->connections = 0;\n          for (i = 0; i < daemon->worker_pool_size; i++)\n            {\n              /* FIXME: next line is thread-safe only if read is atomic. */\n              daemon->connections += daemon->worker_pool[i].connections;\n            }\n        }\n      return (const union MHD_DaemonInfo *) &daemon->connections;\n    case MHD_DAEMON_INFO_FLAGS:\n      return (const union MHD_DaemonInfo *) &daemon->options;\n    case MHD_DAEMON_INFO_BIND_PORT:\n      return (const union MHD_DaemonInfo *) &daemon->port;\n    default:\n      return NULL;\n    }\n}",
      "lines": 46,
      "depth": 16,
      "decorators": [
        "const",
        "const",
        "union MHD_DaemonInfo",
        "union",
        "MHD_DaemonInfo",
        "*\nMHD_get_daemon_info (struct MHD_Daemon *daemon,\n\t\t     enum MHD_DaemonInfoType info_type,\n\t\t     ...)",
        "*"
      ]
    },
    "MHD_set_panic_func": {
      "start_point": [
        6489,
        0
      ],
      "end_point": [
        6495,
        1
      ],
      "content": "void\nMHD_set_panic_func (MHD_PanicCallback cb,\n                    void *cls)\n{\n  mhd_panic = cb;\n  mhd_panic_cls = cls;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "MHD_get_version": {
      "start_point": [
        6504,
        0
      ],
      "end_point": [
        6524,
        1
      ],
      "content": "const char *\nMHD_get_version (void)\n{\n#ifdef PACKAGE_VERSION\n  return PACKAGE_VERSION;\n#else  /* !PACKAGE_VERSION */\n  static char ver[12] = \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\";\n  if (0 == ver[0])\n  {\n    int res = MHD_snprintf_(ver,\n                            sizeof(ver),\n                            \"%x.%x.%x\",\n                            (((int)MHD_VERSION >> 24) & 0xFF),\n                            (((int)MHD_VERSION >> 16) & 0xFF),\n                            (((int)MHD_VERSION >> 8) & 0xFF));\n    if (0 >= res || sizeof(ver) <= res)\n      return \"0.0.0\"; /* Can't return real version*/\n  }\n  return ver;\n#endif /* !PACKAGE_VERSION */\n}",
      "lines": 21,
      "depth": 17,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nMHD_get_version (void)",
        "*"
      ]
    },
    "MHD_is_feature_supported": {
      "start_point": [
        6538,
        0
      ],
      "end_point": [
        6676,
        1
      ],
      "content": "_MHD_EXTERN int\nMHD_is_feature_supported(enum MHD_FEATURE feature)\n{\n  switch(feature)\n    {\n    case MHD_FEATURE_MESSAGES:\n#ifdef HAVE_MESSAGES\n      return MHD_YES;\n#else\n      return MHD_NO;\n#endif\n    case MHD_FEATURE_TLS:\n#ifdef HTTPS_SUPPORT\n      return MHD_YES;\n#else  /* ! HTTPS_SUPPORT */\n      return MHD_NO;\n#endif  /* ! HTTPS_SUPPORT */\n    case MHD_FEATURE_HTTPS_CERT_CALLBACK:\n#if defined(HTTPS_SUPPORT) && GNUTLS_VERSION_MAJOR >= 3\n      return MHD_YES;\n#else  /* !HTTPS_SUPPORT || GNUTLS_VERSION_MAJOR < 3 */\n      return MHD_NO;\n#endif /* !HTTPS_SUPPORT || GNUTLS_VERSION_MAJOR < 3 */\n    case MHD_FEATURE_IPv6:\n#ifdef HAVE_INET6\n      return MHD_YES;\n#else\n      return MHD_NO;\n#endif\n    case MHD_FEATURE_IPv6_ONLY:\n#if defined(IPPROTO_IPV6) && defined(IPV6_V6ONLY)\n      return MHD_YES;\n#else\n      return MHD_NO;\n#endif\n    case MHD_FEATURE_POLL:\n#ifdef HAVE_POLL\n      return MHD_YES;\n#else\n      return MHD_NO;\n#endif\n    case MHD_FEATURE_EPOLL:\n#ifdef EPOLL_SUPPORT\n      return MHD_YES;\n#else\n      return MHD_NO;\n#endif\n    case MHD_FEATURE_SHUTDOWN_LISTEN_SOCKET:\n#ifdef HAVE_LISTEN_SHUTDOWN\n      return MHD_YES;\n#else\n      return MHD_NO;\n#endif\n    case MHD_FEATURE_SOCKETPAIR:\n#ifdef _MHD_ITC_SOCKETPAIR\n      return MHD_YES;\n#else\n      return MHD_NO;\n#endif\n    case MHD_FEATURE_TCP_FASTOPEN:\n#ifdef TCP_FASTOPEN\n      return MHD_YES;\n#else\n      return MHD_NO;\n#endif\n    case MHD_FEATURE_BASIC_AUTH:\n#ifdef BAUTH_SUPPORT\n      return MHD_YES;\n#else\n      return MHD_NO;\n#endif\n    case MHD_FEATURE_DIGEST_AUTH:\n#ifdef DAUTH_SUPPORT\n      return MHD_YES;\n#else\n      return MHD_NO;\n#endif\n    case MHD_FEATURE_POSTPROCESSOR:\n#ifdef HAVE_POSTPROCESSOR\n      return MHD_YES;\n#else\n      return MHD_NO;\n#endif\n    case MHD_FEATURE_HTTPS_KEY_PASSWORD:\n#if defined(HTTPS_SUPPORT) && GNUTLS_VERSION_NUMBER >= 0x030111\n      return MHD_YES;\n#else  /* !HTTPS_SUPPORT || GNUTLS_VERSION_NUMBER < 0x030111 */\n      return MHD_NO;\n#endif /* !HTTPS_SUPPORT || GNUTLS_VERSION_NUMBER < 0x030111 */\n    case MHD_FEATURE_LARGE_FILE:\n#if defined(HAVE_PREAD64) || defined(_WIN32)\n      return MHD_YES;\n#elif defined(HAVE_PREAD)\n      return (sizeof(uint64_t) > sizeof(off_t)) ? MHD_NO : MHD_YES;\n#elif defined(HAVE_LSEEK64)\n      return MHD_YES;\n#else\n      return (sizeof(uint64_t) > sizeof(off_t)) ? MHD_NO : MHD_YES;\n#endif\n    case MHD_FEATURE_THREAD_NAMES:\n#if defined(MHD_USE_THREAD_NAME_)\n      return MHD_YES;\n#else\n      return MHD_NO;\n#endif\n    case MHD_FEATURE_UPGRADE:\n#if defined(UPGRADE_SUPPORT)\n      return MHD_YES;\n#else\n      return MHD_NO;\n#endif\n    case MHD_FEATURE_RESPONSES_SHARED_FD:\n#if defined(HAVE_PREAD64) || defined(HAVE_PREAD) || defined(_WIN32)\n      return MHD_YES;\n#else\n      return MHD_NO;\n#endif\n    case MHD_FEATURE_AUTODETECT_BIND_PORT:\n#ifdef MHD_USE_GETSOCKNAME\n      return MHD_YES;\n#else\n      return MHD_NO;\n#endif\n    case MHD_FEATURE_AUTOSUPPRESS_SIGPIPE:\n#if defined(MHD_WINSOCK_SOCKETS) || defined(MHD_socket_nosignal_) || defined (MSG_NOSIGNAL)\n      return MHD_YES;\n#else\n      return MHD_NO;\n#endif\n    case MHD_FEATURE_SENDFILE:\n#ifdef _MHD_HAVE_SENDFILE\n      return MHD_YES;\n#else\n      return MHD_NO;\n#endif\n\n    }\n  return MHD_NO;\n}",
      "lines": 139,
      "depth": 15,
      "decorators": [
        "_MHD_EXTERN",
        "int",
        "int"
      ]
    },
    "gcry_w32_mutex_init": {
      "start_point": [
        6685,
        0
      ],
      "end_point": [
        6700,
        1
      ],
      "content": "static int\ngcry_w32_mutex_init (void **ppmtx)\n{\n  *ppmtx = malloc (sizeof (MHD_mutex_));\n\n  if (NULL == *ppmtx)\n    return ENOMEM;\n  if (!MHD_mutex_init_ ((MHD_mutex_*)*ppmtx))\n    {\n      free (*ppmtx);\n      *ppmtx = NULL;\n      return EPERM;\n    }\n\n  return 0;\n}",
      "lines": 16,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "gcry_w32_mutex_destroy": {
      "start_point": [
        6703,
        0
      ],
      "end_point": [
        6709,
        1
      ],
      "content": "static int\ngcry_w32_mutex_destroy (void **ppmtx)\n{\n  int res = (MHD_mutex_destroy_ ((MHD_mutex_*)*ppmtx)) ? 0 : EINVAL;\n  free (*ppmtx);\n  return res;\n}",
      "lines": 7,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "gcry_w32_mutex_lock": {
      "start_point": [
        6712,
        0
      ],
      "end_point": [
        6716,
        1
      ],
      "content": "static int\ngcry_w32_mutex_lock (void **ppmtx)\n{\n  return MHD_mutex_lock_ ((MHD_mutex_*)*ppmtx) ? 0 : EINVAL;\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "gcry_w32_mutex_unlock": {
      "start_point": [
        6719,
        0
      ],
      "end_point": [
        6723,
        1
      ],
      "content": "static int\ngcry_w32_mutex_unlock (void **ppmtx)\n{\n  return MHD_mutex_unlock_ ((MHD_mutex_*)*ppmtx) ? 0 : EINVAL;\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "MHD_init": {
      "start_point": [
        6739,
        0
      ],
      "end_point": [
        6780,
        1
      ],
      "content": "void\nMHD_init(void)\n{\n#if defined(_WIN32) && ! defined(__CYGWIN__)\n  WSADATA wsd;\n#endif /* _WIN32 && ! __CYGWIN__ */\n\n  if (NULL == mhd_panic)\n    mhd_panic = &mhd_panic_std;\n\n#if defined(_WIN32) && ! defined(__CYGWIN__)\n  if (0 != WSAStartup(MAKEWORD(2, 2), &wsd))\n    MHD_PANIC (_(\"Failed to initialize winsock\\n\"));\n  mhd_winsock_inited_ = 1;\n  if (2 != LOBYTE(wsd.wVersion) && 2 != HIBYTE(wsd.wVersion))\n    MHD_PANIC (_(\"Winsock version 2.2 is not available\\n\"));\n#endif\n#ifdef HTTPS_SUPPORT\n#ifdef MHD_HTTPS_REQUIRE_GRYPT\n#if GCRYPT_VERSION_NUMBER < 0x010600\n#if defined(MHD_USE_POSIX_THREADS)\n  if (0 != gcry_control (GCRYCTL_SET_THREAD_CBS,\n                         &gcry_threads_pthread))\n    MHD_PANIC (_(\"Failed to initialise multithreading in libgcrypt\\n\"));\n#elif defined(MHD_W32_MUTEX_)\n  if (0 != gcry_control (GCRYCTL_SET_THREAD_CBS,\n                         &gcry_threads_w32))\n    MHD_PANIC (_(\"Failed to initialise multithreading in libgcrypt\\n\"));\n#endif /* defined(MHD_W32_MUTEX_) */\n  gcry_check_version (NULL);\n#else\n  if (NULL == gcry_check_version (\"1.6.0\"))\n    MHD_PANIC (_(\"libgcrypt is too old. MHD was compiled for libgcrypt 1.6.0 or newer\\n\"));\n#endif\n#endif /* MHD_HTTPS_REQUIRE_GRYPT */\n  gnutls_global_init ();\n#endif /* HTTPS_SUPPORT */\n  MHD_monotonic_sec_counter_init();\n#ifdef HAVE_FREEBSD_SENDFILE\n  MHD_conn_init_static_ ();\n#endif /* HAVE_FREEBSD_SENDFILE */\n}",
      "lines": 42,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "MHD_fini": {
      "start_point": [
        6783,
        0
      ],
      "end_point": [
        6794,
        1
      ],
      "content": "void\nMHD_fini(void)\n{\n#ifdef HTTPS_SUPPORT\n  gnutls_global_deinit ();\n#endif /* HTTPS_SUPPORT */\n#if defined(_WIN32) && ! defined(__CYGWIN__)\n  if (mhd_winsock_inited_)\n    WSACleanup();\n#endif\n  MHD_monotonic_sec_counter_finish();\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/microhttpd/digestauth.c": {
    "cvthex": {
      "start_point": [
        75,
        0
      ],
      "end_point": [
        91,
        1
      ],
      "content": "static void\ncvthex (const unsigned char *bin,\n\tsize_t len,\n\tchar *hex)\n{\n  size_t i;\n  unsigned int j;\n\n  for (i = 0; i < len; ++i)\n    {\n      j = (bin[i] >> 4) & 0x0f;\n      hex[i * 2] = (char)((j <= 9) ? (j + '0') : (j - 10 + 'a'));\n      j = bin[i] & 0x0f;\n      hex[i * 2 + 1] = (char)((j <= 9) ? (j + '0') : (j - 10 + 'a'));\n    }\n  hex[len * 2] = '\\0';\n}",
      "lines": 17,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "digest_calc_ha1": {
      "start_point": [
        106,
        0
      ],
      "end_point": [
        161,
        1
      ],
      "content": "static void\ndigest_calc_ha1 (const char *alg,\n\t\t const char *username,\n\t\t const char *realm,\n\t\t const char *password,\n\t\t const char *nonce,\n\t\t const char *cnonce,\n\t\t char sessionkey[HASH_MD5_HEX_LEN + 1])\n{\n  struct MD5Context md5;\n  unsigned char ha1[MD5_DIGEST_SIZE];\n\n  MD5Init (&md5);\n  MD5Update (&md5,\n             (const unsigned char *) username,\n             strlen (username));\n  MD5Update (&md5,\n             (const unsigned char *) \":\",\n             1);\n  MD5Update (&md5,\n             (const unsigned char *) realm,\n             strlen (realm));\n  MD5Update (&md5,\n             (const unsigned char *) \":\",\n             1);\n  MD5Update (&md5,\n             (const unsigned char *) password,\n             strlen (password));\n  MD5Final (ha1,\n            &md5);\n  if (MHD_str_equal_caseless_(alg,\n                              \"md5-sess\"))\n    {\n      MD5Init (&md5);\n      MD5Update (&md5,\n                 (const unsigned char *) ha1,\n                 sizeof (ha1));\n      MD5Update (&md5,\n                 (const unsigned char *) \":\",\n                 1);\n      MD5Update (&md5,\n                 (const unsigned char *) nonce,\n                 strlen (nonce));\n      MD5Update (&md5,\n                 (const unsigned char *) \":\",\n                 1);\n      MD5Update (&md5,\n                 (const unsigned char *) cnonce,\n                 strlen (cnonce));\n      MD5Final (ha1,\n                &md5);\n    }\n  cvthex (ha1,\n          sizeof (ha1),\n          sessionkey);\n}",
      "lines": 56,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "digest_calc_response": {
      "start_point": [
        177,
        0
      ],
      "end_point": [
        267,
        1
      ],
      "content": "static void\ndigest_calc_response (const char ha1[HASH_MD5_HEX_LEN + 1],\n\t\t      const char *nonce,\n\t\t      const char *noncecount,\n\t\t      const char *cnonce,\n\t\t      const char *qop,\n\t\t      const char *method,\n\t\t      const char *uri,\n\t\t      const char *hentity,\n\t\t      char response[HASH_MD5_HEX_LEN + 1])\n{\n  struct MD5Context md5;\n  unsigned char ha2[MD5_DIGEST_SIZE];\n  unsigned char resphash[MD5_DIGEST_SIZE];\n  char ha2hex[HASH_MD5_HEX_LEN + 1];\n  (void)hentity; /* Unused. Silent compiler warning. */\n\n  MD5Init (&md5);\n  MD5Update (&md5,\n             (const unsigned char *) method,\n             strlen (method));\n  MD5Update (&md5,\n             (const unsigned char *) \":\",\n             1);\n  MD5Update (&md5,\n             (const unsigned char *) uri,\n             strlen (uri));\n#if 0\n  if (0 == strcasecmp(qop,\n                      \"auth-int\"))\n    {\n      /* This is dead code since the rest of this module does\n\t not support auth-int. */\n      MD5Update (&md5,\n                 \":\",\n                 1);\n      if (NULL != hentity)\n\tMD5Update (&md5,\n                   hentity,\n                   strlen (hentity));\n    }\n#endif\n  MD5Final (ha2,\n            &md5);\n  cvthex (ha2,\n          MD5_DIGEST_SIZE,\n          ha2hex);\n  MD5Init (&md5);\n  /* calculate response */\n  MD5Update (&md5,\n             (const unsigned char *) ha1,\n             HASH_MD5_HEX_LEN);\n  MD5Update (&md5,\n             (const unsigned char *) \":\",\n             1);\n  MD5Update (&md5,\n             (const unsigned char *) nonce,\n             strlen (nonce));\n  MD5Update (&md5,\n             (const unsigned char*) \":\",\n             1);\n  if ('\\0' != *qop)\n    {\n      MD5Update (&md5,\n                 (const unsigned char *) noncecount,\n                 strlen (noncecount));\n      MD5Update (&md5,\n                 (const unsigned char *) \":\",\n                 1);\n      MD5Update (&md5,\n                 (const unsigned char *) cnonce,\n                 strlen (cnonce));\n      MD5Update (&md5,\n                 (const unsigned char *) \":\",\n                 1);\n      MD5Update (&md5,\n                 (const unsigned char *) qop,\n                 strlen (qop));\n      MD5Update (&md5,\n                 (const unsigned char *) \":\",\n                 1);\n    }\n  MD5Update (&md5,\n             (const unsigned char *) ha2hex,\n             HASH_MD5_HEX_LEN);\n  MD5Final (resphash,\n            &md5);\n  cvthex (resphash,\n          sizeof(resphash),\n          response);\n}",
      "lines": 91,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "lookup_sub_value": {
      "start_point": [
        284,
        0
      ],
      "end_point": [
        365,
        1
      ],
      "content": "static size_t\nlookup_sub_value (char *dest,\n\t\t  size_t size,\n\t\t  const char *data,\n\t\t  const char *key)\n{\n  size_t keylen;\n  size_t len;\n  const char *ptr;\n  const char *eq;\n  const char *q1;\n  const char *q2;\n  const char *qn;\n\n  if (0 == size)\n    return 0;\n  keylen = strlen (key);\n  ptr = data;\n  while ('\\0' != *ptr)\n    {\n      if (NULL == (eq = strchr (ptr,\n                                '=')))\n\treturn 0;\n      q1 = eq + 1;\n      while (' ' == *q1)\n\tq1++;\n      if ('\\\"' != *q1)\n\t{\n\t  q2 = strchr (q1,\n                       ',');\n\t  qn = q2;\n\t}\n      else\n\t{\n\t  q1++;\n\t  q2 = strchr (q1,\n                       '\\\"');\n\t  if (NULL == q2)\n\t    return 0; /* end quote not found */\n\t  qn = q2 + 1;\n\t}\n      if ( (MHD_str_equal_caseless_n_(ptr,\n                                      key,\n                                      keylen)) &&\n\t   (eq == &ptr[keylen]) )\n\t{\n\t  if (NULL == q2)\n\t    {\n\t      len = strlen (q1) + 1;\n\t      if (size > len)\n\t\tsize = len;\n\t      size--;\n\t      strncpy (dest,\n\t\t       q1,\n\t\t       size);\n\t      dest[size] = '\\0';\n\t      return size;\n\t    }\n\t  else\n\t    {\n\t      if (size > (size_t) ((q2 - q1) + 1))\n\t\tsize = (q2 - q1) + 1;\n\t      size--;\n\t      memcpy (dest,\n\t\t      q1,\n\t\t      size);\n\t      dest[size] = '\\0';\n\t      return size;\n\t    }\n\t}\n      if (NULL == qn)\n\treturn 0;\n      ptr = strchr (qn,\n                    ',');\n      if (NULL == ptr)\n\treturn 0;\n      ptr++;\n      while (' ' == *ptr)\n\tptr++;\n    }\n  return 0;\n}",
      "lines": 82,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "check_nonce_nc": {
      "start_point": [
        377,
        0
      ],
      "end_point": [
        455,
        1
      ],
      "content": "static int\ncheck_nonce_nc (struct MHD_Connection *connection,\n\t\tconst char *nonce,\n\t\tuint64_t nc)\n{\n  struct MHD_Daemon *daemon = connection->daemon;\n  struct MHD_NonceNc *nn;\n  uint32_t off;\n  uint32_t mod;\n  const char *np;\n\n  if (MAX_NONCE_LENGTH <= strlen (nonce))\n    return MHD_NO; /* This should be impossible, but static analysis\n                      tools have a hard time with it *and* this also\n                      protects against unsafe modifications that may\n                      happen in the future... */\n  mod = daemon->nonce_nc_size;\n  if (0 == mod)\n    return MHD_NO; /* no array! */\n  /* super-fast xor-based \"hash\" function for HT lookup in nonce array */\n  off = 0;\n  np = nonce;\n  while ('\\0' != *np)\n    {\n      off = (off << 8) | (*np ^ (off >> 24));\n      np++;\n    }\n  off = off % mod;\n  /*\n   * Look for the nonce, if it does exist and its corresponding\n   * nonce counter is less than the current nonce counter by 1,\n   * then only increase the nonce counter by one.\n   */\n  nn = &daemon->nnc[off];\n  MHD_mutex_lock_chk_ (&daemon->nnc_lock);\n  if (0 == nc)\n    {\n      /* Fresh nonce, reinitialize array */\n      strcpy (nn->nonce,\n\t      nonce);\n      nn->nc = 0;\n      nn->nmask = 0;\n      MHD_mutex_unlock_chk_ (&daemon->nnc_lock);\n      return MHD_YES;\n    }\n  /* Note that we use 64 here, as we do not store the\n     bit for 'nn->nc' itself in 'nn->nmask' */\n  if ( (nc < nn->nc) &&\n       (nc + 64 > nc /* checking for overflow */) &&\n       (nc + 64 >= nn->nc) &&\n       (0 == ((1LLU << (nn->nc - nc - 1)) & nn->nmask)) )\n    {\n      /* Out-of-order nonce, but within 64-bit bitmask, set bit */\n      nn->nmask |= (1LLU << (nn->nc - nc - 1));\n      MHD_mutex_unlock_chk_ (&daemon->nnc_lock);\n      return MHD_YES;\n    }\n\n  if ( (nc <= nn->nc) ||\n       (0 != strcmp (nn->nonce,\n                     nonce)) )\n    {\n      /* Nonce does not match, fail */\n      MHD_mutex_unlock_chk_ (&daemon->nnc_lock);\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n\t\t_(\"Stale nonce received.  If this happens a lot, you should probably increase the size of the nonce array.\\n\"));\n#endif\n      return MHD_NO;\n    }\n  /* Nonce is larger, shift bitmask and bump limit */\n  if (64 > nc - nn->nc)\n    nn->nmask <<= (nc - nn->nc); /* small jump, less than mask width */\n  else\n    nn->nmask = 0; /* big jump, unset all bits in the mask */\n  nn->nc = nc;\n  MHD_mutex_unlock_chk_ (&daemon->nnc_lock);\n  return MHD_YES;\n}",
      "lines": 79,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "MHD_digest_auth_get_username": {
      "start_point": [
        467,
        0
      ],
      "end_point": [
        490,
        1
      ],
      "content": "char *\nMHD_digest_auth_get_username(struct MHD_Connection *connection)\n{\n  size_t len;\n  char user[MAX_USERNAME_LENGTH];\n  const char *header;\n\n  if (NULL == (header =\n               MHD_lookup_connection_value (connection,\n                                            MHD_HEADER_KIND,\n                                            MHD_HTTP_HEADER_AUTHORIZATION)))\n    return NULL;\n  if (0 != strncmp (header,\n                    _BASE,\n                    MHD_STATICSTR_LEN_ (_BASE)))\n    return NULL;\n  header += MHD_STATICSTR_LEN_ (_BASE);\n  if (0 == (len = lookup_sub_value (user,\n\t\t\t\t    sizeof (user),\n\t\t\t\t    header,\n\t\t\t\t    \"username\")))\n    return NULL;\n  return strdup (user);\n}",
      "lines": 24,
      "depth": 12,
      "decorators": [
        "char",
        "*\nMHD_digest_auth_get_username(struct MHD_Connection *connection)",
        "*"
      ]
    },
    "calculate_nonce": {
      "start_point": [
        506,
        0
      ],
      "end_point": [
        564,
        1
      ],
      "content": "static void\ncalculate_nonce (uint32_t nonce_time,\n\t\t const char *method,\n\t\t const char *rnd,\n\t\t size_t rnd_size,\n\t\t const char *uri,\n\t\t const char *realm,\n\t\t char nonce[NONCE_STD_LEN + 1])\n{\n  struct MD5Context md5;\n  unsigned char timestamp[TIMESTAMP_BIN_SIZE];\n  unsigned char tmpnonce[MD5_DIGEST_SIZE];\n  char timestamphex[TIMESTAMP_HEX_LEN + 1];\n\n  MD5Init (&md5);\n  timestamp[0] = (unsigned char)((nonce_time & 0xff000000) >> 0x18);\n  timestamp[1] = (unsigned char)((nonce_time & 0x00ff0000) >> 0x10);\n  timestamp[2] = (unsigned char)((nonce_time & 0x0000ff00) >> 0x08);\n  timestamp[3] = (unsigned char)((nonce_time & 0x000000ff));\n  MD5Update (&md5,\n             timestamp,\n             sizeof (timestamp));\n  MD5Update (&md5,\n             (const unsigned char *) \":\",\n             1);\n  MD5Update (&md5,\n             (const unsigned char *) method,\n             strlen (method));\n  MD5Update (&md5,\n             (const unsigned char *) \":\",\n             1);\n  if (rnd_size > 0)\n    MD5Update (&md5,\n               (const unsigned char *) rnd,\n               rnd_size);\n  MD5Update (&md5,\n             (const unsigned char *) \":\",\n             1);\n  MD5Update (&md5,\n             (const unsigned char *) uri,\n             strlen (uri));\n  MD5Update (&md5,\n             (const unsigned char *) \":\",\n             1);\n  MD5Update (&md5,\n             (const unsigned char *) realm,\n             strlen (realm));\n  MD5Final (tmpnonce,\n            &md5);\n  cvthex (tmpnonce,\n          sizeof (tmpnonce),\n          nonce);\n  cvthex (timestamp,\n          sizeof (timestamp),\n          timestamphex);\n  strncat (nonce,\n           timestamphex,\n           8);\n}",
      "lines": 59,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_header": {
      "start_point": [
        578,
        0
      ],
      "end_point": [
        604,
        1
      ],
      "content": "static int\ntest_header (struct MHD_Connection *connection,\n\t     const char *key,\n\t     const char *value,\n\t     enum MHD_ValueKind kind)\n{\n  struct MHD_HTTP_Header *pos;\n\n  for (pos = connection->headers_received; NULL != pos; pos = pos->next)\n    {\n      if (kind != pos->kind)\n\tcontinue;\n      if (0 != strcmp (key,\n                       pos->header))\n\tcontinue;\n      if ( (NULL == value) &&\n\t   (NULL == pos->value) )\n\treturn MHD_YES;\n      if ( (NULL == value) ||\n\t   (NULL == pos->value) ||\n\t   (0 != strcmp (value,\n                         pos->value)) )\n\tcontinue;\n      return MHD_YES;\n    }\n  return MHD_NO;\n}",
      "lines": 27,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "check_argument_match": {
      "start_point": [
        617,
        0
      ],
      "end_point": [
        656,
        1
      ],
      "content": "static int\ncheck_argument_match (struct MHD_Connection *connection,\n\t\t      const char *args)\n{\n  struct MHD_HTTP_Header *pos;\n  char *argb;\n  unsigned int num_headers;\n  int ret;\n\n  argb = strdup (args);\n  if (NULL == argb)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (connection->daemon,\n\t\t_(\"Failed to allocate memory for copy of URI arguments\\n\"));\n#endif /* HAVE_MESSAGES */\n      return MHD_NO;\n    }\n  ret = MHD_parse_arguments_ (connection,\n\t\t\t      MHD_GET_ARGUMENT_KIND,\n\t\t\t      argb,\n\t\t\t      &test_header,\n\t\t\t      &num_headers);\n  free (argb);\n  if (MHD_YES != ret)\n    return MHD_NO;\n  /* also check that the number of headers matches */\n  for (pos = connection->headers_received; NULL != pos; pos = pos->next)\n    {\n      if (MHD_GET_ARGUMENT_KIND != pos->kind)\n\tcontinue;\n      num_headers--;\n    }\n  if (0 != num_headers)\n    {\n      /* argument count mismatch */\n      return MHD_NO;\n    }\n  return MHD_YES;\n}",
      "lines": 40,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "MHD_digest_auth_check": {
      "start_point": [
        672,
        0
      ],
      "end_point": [
        929,
        1
      ],
      "content": "int\nMHD_digest_auth_check (struct MHD_Connection *connection,\n\t\t       const char *realm,\n\t\t       const char *username,\n\t\t       const char *password,\n\t\t       unsigned int nonce_timeout)\n{\n  struct MHD_Daemon *daemon = connection->daemon;\n  size_t len;\n  const char *header;\n  char nonce[MAX_NONCE_LENGTH];\n  char cnonce[MAX_NONCE_LENGTH];\n  char qop[15]; /* auth,auth-int */\n  char nc[20];\n  char response[MAX_AUTH_RESPONSE_LENGTH];\n  const char *hentity = NULL; /* \"auth-int\" is not supported */\n  char ha1[HASH_MD5_HEX_LEN + 1];\n  char respexp[HASH_MD5_HEX_LEN + 1];\n  char noncehashexp[NONCE_STD_LEN + 1];\n  uint32_t nonce_time;\n  uint32_t t;\n  size_t left; /* number of characters left in 'header' for 'uri' */\n  uint64_t nci;\n\n  header = MHD_lookup_connection_value (connection,\n\t\t\t\t\tMHD_HEADER_KIND,\n\t\t\t\t\tMHD_HTTP_HEADER_AUTHORIZATION);\n  if (NULL == header)\n    return MHD_NO;\n  if (0 != strncmp (header,\n                    _BASE,\n                    MHD_STATICSTR_LEN_(_BASE)))\n    return MHD_NO;\n  header += MHD_STATICSTR_LEN_ (_BASE);\n  left = strlen (header);\n\n  {\n    char un[MAX_USERNAME_LENGTH];\n\n    len = lookup_sub_value (un,\n\t\t\t    sizeof (un),\n\t\t\t    header,\n                            \"username\");\n    if ( (0 == len) ||\n\t (0 != strcmp (username,\n                       un)) )\n      return MHD_NO;\n    left -= strlen (\"username\") + len;\n  }\n\n  {\n    char r[MAX_REALM_LENGTH];\n\n    len = lookup_sub_value (r,\n                            sizeof (r),\n                            header,\n                            \"realm\");\n    if ( (0 == len) ||\n\t (0 != strcmp (realm,\n                       r)) )\n      return MHD_NO;\n    left -= strlen (\"realm\") + len;\n  }\n\n  if (0 == (len = lookup_sub_value (nonce,\n\t\t\t\t    sizeof (nonce),\n\t\t\t\t    header,\n                                    \"nonce\")))\n    return MHD_NO;\n  left -= strlen (\"nonce\") + len;\n  if (left > 32 * 1024)\n  {\n    /* we do not permit URIs longer than 32k, as we want to\n       make sure to not blow our stack (or per-connection\n       heap memory limit).  Besides, 32k is already insanely\n       large, but of course in theory the\n       #MHD_OPTION_CONNECTION_MEMORY_LIMIT might be very large\n       and would thus permit sending a >32k authorization\n       header value. */\n    return MHD_NO;\n  }\n  if (TIMESTAMP_HEX_LEN !=\n      MHD_strx_to_uint32_n_ (nonce + len - TIMESTAMP_HEX_LEN,\n                             TIMESTAMP_HEX_LEN,\n                             &nonce_time))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _(\"Authentication failed, invalid timestamp format.\\n\"));\n#endif\n      return MHD_NO;\n    }\n  t = (uint32_t) MHD_monotonic_sec_counter();\n  /*\n   * First level vetting for the nonce validity: if the timestamp\n   * attached to the nonce exceeds `nonce_timeout', then the nonce is\n   * invalid.\n   */\n  if ( (t > nonce_time + nonce_timeout) ||\n       (nonce_time + nonce_timeout < nonce_time) )\n    {\n      /* too old */\n      return MHD_INVALID_NONCE;\n    }\n\n  calculate_nonce (nonce_time,\n                   connection->method,\n                   daemon->digest_auth_random,\n                   daemon->digest_auth_rand_size,\n                   connection->url,\n                   realm,\n                   noncehashexp);\n  /*\n   * Second level vetting for the nonce validity\n   * if the timestamp attached to the nonce is valid\n   * and possibly fabricated (in case of an attack)\n   * the attacker must also know the random seed to be\n   * able to generate a \"sane\" nonce, which if he does\n   * not, the nonce fabrication process going to be\n   * very hard to achieve.\n   */\n\n  if (0 != strcmp (nonce, noncehashexp))\n    {\n      return MHD_INVALID_NONCE;\n    }\n  if ( (0 == lookup_sub_value (cnonce,\n                               sizeof (cnonce),\n                               header,\n                               \"cnonce\")) ||\n       (0 == lookup_sub_value (qop,\n                               sizeof (qop),\n                               header,\n                               \"qop\")) ||\n       ( (0 != strcmp (qop,\n                       \"auth\")) &&\n         (0 != strcmp (qop,\n                       \"\")) ) ||\n       (0 == (len = lookup_sub_value (nc,\n                                      sizeof (nc),\n                                      header,\n                                      \"nc\")) )  ||\n       (0 == lookup_sub_value (response,\n                               sizeof (response),\n                               header,\n                               \"response\")) )\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n\t\t_(\"Authentication failed, invalid format.\\n\"));\n#endif\n      return MHD_NO;\n    }\n  if (len != MHD_strx_to_uint64_n_ (nc,\n                                    len,\n                                    &nci))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n\t\t_(\"Authentication failed, invalid nc format.\\n\"));\n#endif\n      return MHD_NO; /* invalid nonce format */\n    }\n\n  /*\n   * Checking if that combination of nonce and nc is sound\n   * and not a replay attack attempt. Also adds the nonce\n   * to the nonce-nc map if it does not exist there.\n   */\n  if (MHD_YES !=\n      check_nonce_nc (connection,\n                      nonce,\n                      nci))\n    {\n      return MHD_NO;\n    }\n\n  {\n    char *uri;\n\n    uri = malloc (left + 1);\n    if (NULL == uri)\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG(daemon,\n               _(\"Failed to allocate memory for auth header processing\\n\"));\n#endif /* HAVE_MESSAGES */\n      return MHD_NO;\n    }\n    if (0 == lookup_sub_value (uri,\n                               left + 1,\n                               header,\n                               \"uri\"))\n    {\n      free (uri);\n      return MHD_NO;\n    }\n\n    digest_calc_ha1 (\"md5\",\n                     username,\n                     realm,\n                     password,\n                     nonce,\n                     cnonce,\n                     ha1);\n    digest_calc_response (ha1,\n\t\t\t  nonce,\n\t\t\t  nc,\n\t\t\t  cnonce,\n\t\t\t  qop,\n\t\t\t  connection->method,\n\t\t\t  uri,\n\t\t\t  hentity,\n\t\t\t  respexp);\n\n    /* Need to unescape URI before comparing with connection->url */\n    daemon->unescape_callback (daemon->unescape_callback_cls,\n                               connection,\n                               uri);\n    if (0 != strncmp (uri,\n\t\t      connection->url,\n\t\t      strlen (connection->url)))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n\t\t_(\"Authentication failed, URI does not match.\\n\"));\n#endif\n      free (uri);\n      return MHD_NO;\n    }\n\n    {\n      const char *args = strchr (uri,\n                                 '?');\n\n      if (NULL == args)\n\targs = \"\";\n      else\n\targs++;\n      if (MHD_YES !=\n\t  check_argument_match (connection,\n\t\t\t\targs) )\n      {\n#ifdef HAVE_MESSAGES\n\tMHD_DLOG (daemon,\n\t\t  _(\"Authentication failed, arguments do not match.\\n\"));\n#endif\n       free (uri);\n       return MHD_NO;\n      }\n    }\n    free (uri);\n    return (0 == strcmp(response,\n                        respexp))\n      ? MHD_YES\n      : MHD_NO;\n  }\n}",
      "lines": 258,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "MHD_queue_auth_fail_response": {
      "start_point": [
        946,
        0
      ],
      "end_point": [
        1033,
        1
      ],
      "content": "int\nMHD_queue_auth_fail_response (struct MHD_Connection *connection,\n\t\t\t      const char *realm,\n\t\t\t      const char *opaque,\n\t\t\t      struct MHD_Response *response,\n\t\t\t      int signal_stale)\n{\n  int ret;\n  int hlen;\n  char nonce[NONCE_STD_LEN + 1];\n\n  /* Generating the server nonce */\n  calculate_nonce ((uint32_t) MHD_monotonic_sec_counter(),\n\t\t   connection->method,\n\t\t   connection->daemon->digest_auth_random,\n\t\t   connection->daemon->digest_auth_rand_size,\n\t\t   connection->url,\n\t\t   realm,\n\t\t   nonce);\n  if (MHD_YES !=\n      check_nonce_nc (connection,\n                      nonce,\n                      0))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (connection->daemon,\n\t\t_(\"Could not register nonce (is the nonce array size zero?).\\n\"));\n#endif\n      return MHD_NO;\n    }\n  /* Building the authentication header */\n  hlen = MHD_snprintf_ (NULL,\n                        0,\n                        \"Digest realm=\\\"%s\\\",qop=\\\"auth\\\",nonce=\\\"%s\\\",opaque=\\\"%s\\\"%s\",\n                        realm,\n                        nonce,\n                        opaque,\n                        signal_stale\n                        ? \",stale=\\\"true\\\"\"\n                        : \"\");\n  if (hlen > 0)\n    {\n      char *header;\n\n      header = MHD_calloc_ (1, hlen + 1);\n      if (NULL == header)\n        {\n#ifdef HAVE_MESSAGES\n          MHD_DLOG(connection->daemon,\n                   _(\"Failed to allocate memory for auth response header\\n\"));\n#endif /* HAVE_MESSAGES */\n          return MHD_NO;\n        }\n\n      if (MHD_snprintf_ (header,\n                         hlen + 1,\n                         \"Digest realm=\\\"%s\\\",qop=\\\"auth\\\",nonce=\\\"%s\\\",opaque=\\\"%s\\\"%s\",\n                         realm,\n                         nonce,\n                         opaque,\n                         signal_stale\n                         ? \",stale=\\\"true\\\"\"\n                         : \"\") == hlen)\n        ret = MHD_add_response_header(response,\n                                      MHD_HTTP_HEADER_WWW_AUTHENTICATE,\n                                      header);\n      else\n        ret = MHD_NO;\n      free (header);\n    }\n  else\n    ret = MHD_NO;\n\n  if (MHD_YES == ret)\n    {\n      ret = MHD_queue_response (connection,\n                                MHD_HTTP_UNAUTHORIZED,\n                                response);\n    }\n  else\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (connection->daemon,\n                _(\"Failed to add Digest auth header\\n\"));\n#endif /* HAVE_MESSAGES */\n    }\n  return ret;\n}",
      "lines": 88,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/microhttpd/internal.c": {
    "MHD_state_to_string": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        82,
        1
      ],
      "content": "const char *\nMHD_state_to_string (enum MHD_CONNECTION_STATE state)\n{\n  switch (state)\n    {\n    case MHD_CONNECTION_INIT:\n      return \"connection init\";\n    case MHD_CONNECTION_URL_RECEIVED:\n      return \"connection url received\";\n    case MHD_CONNECTION_HEADER_PART_RECEIVED:\n      return \"header partially received\";\n    case MHD_CONNECTION_HEADERS_RECEIVED:\n      return \"headers received\";\n    case MHD_CONNECTION_HEADERS_PROCESSED:\n      return \"headers processed\";\n    case MHD_CONNECTION_CONTINUE_SENDING:\n      return \"continue sending\";\n    case MHD_CONNECTION_CONTINUE_SENT:\n      return \"continue sent\";\n    case MHD_CONNECTION_BODY_RECEIVED:\n      return \"body received\";\n    case MHD_CONNECTION_FOOTER_PART_RECEIVED:\n      return \"footer partially received\";\n    case MHD_CONNECTION_FOOTERS_RECEIVED:\n      return \"footers received\";\n    case MHD_CONNECTION_HEADERS_SENDING:\n      return \"headers sending\";\n    case MHD_CONNECTION_HEADERS_SENT:\n      return \"headers sent\";\n    case MHD_CONNECTION_NORMAL_BODY_READY:\n      return \"normal body ready\";\n    case MHD_CONNECTION_NORMAL_BODY_UNREADY:\n      return \"normal body unready\";\n    case MHD_CONNECTION_CHUNKED_BODY_READY:\n      return \"chunked body ready\";\n    case MHD_CONNECTION_CHUNKED_BODY_UNREADY:\n      return \"chunked body unready\";\n    case MHD_CONNECTION_BODY_SENT:\n      return \"body sent\";\n    case MHD_CONNECTION_FOOTERS_SENDING:\n      return \"footers sending\";\n    case MHD_CONNECTION_FOOTERS_SENT:\n      return \"footers sent\";\n    case MHD_CONNECTION_CLOSED:\n      return \"closed\";\n    default:\n      return \"unrecognized connection state\";\n    }\n}",
      "lines": 49,
      "depth": 8,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nMHD_state_to_string (enum MHD_CONNECTION_STATE state)",
        "*"
      ]
    },
    "MHD_DLOG": {
      "start_point": [
        92,
        0
      ],
      "end_point": [
        106,
        1
      ],
      "content": "void\nMHD_DLOG (const struct MHD_Daemon *daemon,\n          const char *format,\n          ...)\n{\n  va_list va;\n\n  if (0 == (daemon->options & MHD_USE_ERROR_LOG))\n    return;\n  va_start (va, format);\n  daemon->custom_error_log (daemon->custom_error_log_cls,\n                            format,\n                            va);\n  va_end (va);\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "MHD_unescape_plus": {
      "start_point": [
        115,
        0
      ],
      "end_point": [
        122,
        1
      ],
      "content": "void\nMHD_unescape_plus (char *arg)\n{\n  char *p;\n\n  for (p=strchr (arg, '+'); NULL != p; p = strchr (p + 1, '+'))\n    *p = ' ';\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "MHD_http_unescape": {
      "start_point": [
        134,
        0
      ],
      "end_point": [
        165,
        1
      ],
      "content": "size_t\nMHD_http_unescape (char *val)\n{\n  char *rpos = val;\n  char *wpos = val;\n\n  while ('\\0' != *rpos)\n    {\n      uint32_t num;\n      switch (*rpos)\n\t{\n\tcase '%':\n          if (2 == MHD_strx_to_uint32_n_ (rpos + 1,\n                                          2,\n                                          &num))\n\t    {\n\t      *wpos = (char)((unsigned char) num);\n\t      wpos++;\n\t      rpos += 3;\n\t      break;\n\t    }\n          /* TODO: add bad sequence handling */\n\t  /* intentional fall through! */\n\tdefault:\n\t  *wpos = *rpos;\n\t  wpos++;\n\t  rpos++;\n\t}\n    }\n  *wpos = '\\0'; /* add 0-terminator */\n  return wpos - val; /* = strlen(val) */\n}",
      "lines": 32,
      "depth": 17,
      "decorators": [
        "size_t"
      ]
    },
    "MHD_parse_arguments_": {
      "start_point": [
        182,
        0
      ],
      "end_point": [
        278,
        1
      ],
      "content": "int\nMHD_parse_arguments_ (struct MHD_Connection *connection,\n\t\t      enum MHD_ValueKind kind,\n\t\t      char *args,\n\t\t      MHD_ArgumentIterator_ cb,\n\t\t      unsigned int *num_headers)\n{\n  struct MHD_Daemon *daemon = connection->daemon;\n  char *equals;\n  char *amper;\n\n  *num_headers = 0;\n  while ( (NULL != args) &&\n\t  ('\\0' != args[0]) )\n    {\n      equals = strchr (args, '=');\n      amper = strchr (args, '&');\n      if (NULL == amper)\n\t{\n\t  /* last argument */\n\t  if (NULL == equals)\n\t    {\n\t      /* last argument, without '=' */\n              MHD_unescape_plus (args);\n\t      daemon->unescape_callback (daemon->unescape_callback_cls,\n\t\t\t\t\t connection,\n\t\t\t\t\t args);\n\t      if (MHD_YES != cb (connection,\n\t\t\t\t args,\n\t\t\t\t NULL,\n\t\t\t\t kind))\n\t\treturn MHD_NO;\n\t      (*num_headers)++;\n\t      break;\n\t    }\n\t  /* got 'foo=bar' */\n\t  equals[0] = '\\0';\n\t  equals++;\n          MHD_unescape_plus (args);\n\t  daemon->unescape_callback (daemon->unescape_callback_cls,\n\t\t\t\t     connection,\n\t\t\t\t     args);\n          MHD_unescape_plus (equals);\n\t  daemon->unescape_callback (daemon->unescape_callback_cls,\n\t\t\t\t     connection,\n\t\t\t\t     equals);\n\t  if (MHD_YES != cb (connection,\n\t\t\t     args,\n\t\t\t     equals,\n\t\t\t     kind))\n\t    return MHD_NO;\n\t  (*num_headers)++;\n\t  break;\n\t}\n      /* amper is non-NULL here */\n      amper[0] = '\\0';\n      amper++;\n      if ( (NULL == equals) ||\n\t   (equals >= amper) )\n\t{\n\t  /* got 'foo&bar' or 'foo&bar=val', add key 'foo' with NULL for value */\n          MHD_unescape_plus (args);\n\t  daemon->unescape_callback (daemon->unescape_callback_cls,\n\t\t\t\t     connection,\n\t\t\t\t     args);\n\t  if (MHD_YES != cb (connection,\n\t\t\t     args,\n\t\t\t     NULL,\n\t\t\t     kind))\n\t    return MHD_NO;\n\t  /* continue with 'bar' */\n\t  (*num_headers)++;\n\t  args = amper;\n\t  continue;\n\t}\n      /* equals and amper are non-NULL here, and equals < amper,\n\t so we got regular 'foo=value&bar...'-kind of argument */\n      equals[0] = '\\0';\n      equals++;\n      MHD_unescape_plus (args);\n      daemon->unescape_callback (daemon->unescape_callback_cls,\n\t\t\t\t connection,\n\t\t\t\t args);\n      MHD_unescape_plus (equals);\n      daemon->unescape_callback (daemon->unescape_callback_cls,\n\t\t\t\t connection,\n\t\t\t\t equals);\n      if (MHD_YES != cb (connection,\n\t\t\t args,\n\t\t\t equals,\n\t\t\t kind))\n        return MHD_NO;\n      (*num_headers)++;\n      args = amper;\n    }\n  return MHD_YES;\n}",
      "lines": 97,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/microhttpd/internal.h": {},
  "libmicrohttpd/libmicrohttpd-0.9.59/src/microhttpd/md5.c": {
    "MD5Init": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "void\nMD5Init(struct MD5Context *ctx)\n{\n  if (!ctx)\n    return;\n\n  ctx->count = 0;\n  ctx->state[0] = 0x67452301;\n  ctx->state[1] = 0xefcdab89;\n  ctx->state[2] = 0x98badcfe;\n  ctx->state[3] = 0x10325476;\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "MD5Update": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "void\nMD5Update(struct MD5Context *ctx, const unsigned char *input, size_t len)\n{\n  size_t have, need;\n\n  if (!ctx || !input)\n    return;\n\n  /* Check how many bytes we already have and how many more we need. */\n  have = (size_t)((ctx->count >> 3) & (MD5_BLOCK_SIZE - 1));\n  need = MD5_BLOCK_SIZE - have;\n\n  /* Update bitcount */\n  ctx->count += (uint64_t)len << 3;\n\n  if (len >= need)\n  {\n    if (have != 0)\n    {\n      memcpy(ctx->buffer + have, input, need);\n      MD5Transform(ctx->state, ctx->buffer);\n      input += need;\n      len -= need;\n      have = 0;\n    }\n\n    /* Process data in MD5_BLOCK_SIZE-byte chunks. */\n    while (len >= MD5_BLOCK_SIZE)\n    {\n      MD5Transform(ctx->state, input);\n      input += MD5_BLOCK_SIZE;\n      len -= MD5_BLOCK_SIZE;\n    }\n  }\n\n  /* Handle any remaining bytes of data. */\n  if (len != 0)\n    memcpy(ctx->buffer + have, input, len);\n}",
      "lines": 39,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "MD5Pad": {
      "start_point": [
        109,
        0
      ],
      "end_point": [
        128,
        1
      ],
      "content": "void\nMD5Pad(struct MD5Context *ctx)\n{\n  uint8_t count[8];\n  size_t padlen;\n\n  if (!ctx)\n    return;\n\n  /* Convert count to 8 bytes in little endian order. */\n  PUT_64BIT_LE(count, ctx->count);\n\n  /* Pad out to 56 mod 64. */\n  padlen = MD5_BLOCK_SIZE -\n    ((ctx->count >> 3) & (MD5_BLOCK_SIZE - 1));\n  if (padlen < 1 + 8)\n    padlen += MD5_BLOCK_SIZE;\n  MD5Update(ctx, PADDING, padlen - 8);\t\t/* padlen - 8 <= 64 */\n  MD5Update(ctx, count, 8);\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "MD5Final": {
      "start_point": [
        133,
        0
      ],
      "end_point": [
        146,
        1
      ],
      "content": "void\nMD5Final(unsigned char digest[MD5_DIGEST_SIZE], struct MD5Context *ctx)\n{\n  int i;\n\n  if (!ctx || !digest)\n    return;\n\n  MD5Pad(ctx);\n  for (i = 0; i < 4; i++)\n    PUT_32BIT_LE(digest + i * 4, ctx->state[i]);\n\n  memset(ctx, 0, sizeof(*ctx));\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "MD5Transform": {
      "start_point": [
        166,
        0
      ],
      "end_point": [
        261,
        1
      ],
      "content": "void\nMD5Transform(uint32_t state[4], const uint8_t block[MD5_BLOCK_SIZE])\n{\n  uint32_t a, b, c, d, in[MD5_BLOCK_SIZE / 4];\n\n#if _MHD_BYTE_ORDER == _MHD_LITTLE_ENDIAN\n  memcpy(in, block, sizeof(in));\n#else\n  for (a = 0; a < MD5_BLOCK_SIZE / 4; a++)\n  {\n    in[a] = (uint32_t)(\n      (uint32_t)(block[a * 4 + 0]) |\n      (uint32_t)(block[a * 4 + 1]) << 8 |\n      (uint32_t)(block[a * 4 + 2]) << 16 |\n      (uint32_t)(block[a * 4 + 3]) << 24);\n  }\n#endif\n\n  a = state[0];\n  b = state[1];\n  c = state[2];\n  d = state[3];\n\n  MD5STEP(F1, a, b, c, d, in[0]  + 0xd76aa478, 7);\n  MD5STEP(F1, d, a, b, c, in[1]  + 0xe8c7b756, 12);\n  MD5STEP(F1, c, d, a, b, in[2]  + 0x242070db, 17);\n  MD5STEP(F1, b, c, d, a, in[3]  + 0xc1bdceee, 22);\n  MD5STEP(F1, a, b, c, d, in[4]  + 0xf57c0faf, 7);\n  MD5STEP(F1, d, a, b, c, in[5]  + 0x4787c62a, 12);\n  MD5STEP(F1, c, d, a, b, in[6]  + 0xa8304613, 17);\n  MD5STEP(F1, b, c, d, a, in[7]  + 0xfd469501, 22);\n  MD5STEP(F1, a, b, c, d, in[8]  + 0x698098d8, 7);\n  MD5STEP(F1, d, a, b, c, in[9]  + 0x8b44f7af, 12);\n  MD5STEP(F1, c, d, a, b, in[10] + 0xffff5bb1, 17);\n  MD5STEP(F1, b, c, d, a, in[11] + 0x895cd7be, 22);\n  MD5STEP(F1, a, b, c, d, in[12] + 0x6b901122, 7);\n  MD5STEP(F1, d, a, b, c, in[13] + 0xfd987193, 12);\n  MD5STEP(F1, c, d, a, b, in[14] + 0xa679438e, 17);\n  MD5STEP(F1, b, c, d, a, in[15] + 0x49b40821, 22);\n\n  MD5STEP(F2, a, b, c, d, in[1]  + 0xf61e2562, 5);\n  MD5STEP(F2, d, a, b, c, in[6]  + 0xc040b340, 9);\n  MD5STEP(F2, c, d, a, b, in[11] + 0x265e5a51, 14);\n  MD5STEP(F2, b, c, d, a, in[0]  + 0xe9b6c7aa, 20);\n  MD5STEP(F2, a, b, c, d, in[5]  + 0xd62f105d, 5);\n  MD5STEP(F2, d, a, b, c, in[10] + 0x02441453, 9);\n  MD5STEP(F2, c, d, a, b, in[15] + 0xd8a1e681, 14);\n  MD5STEP(F2, b, c, d, a, in[4]  + 0xe7d3fbc8, 20);\n  MD5STEP(F2, a, b, c, d, in[9]  + 0x21e1cde6, 5);\n  MD5STEP(F2, d, a, b, c, in[14] + 0xc33707d6, 9);\n  MD5STEP(F2, c, d, a, b, in[3]  + 0xf4d50d87, 14);\n  MD5STEP(F2, b, c, d, a, in[8]  + 0x455a14ed, 20);\n  MD5STEP(F2, a, b, c, d, in[13] + 0xa9e3e905, 5);\n  MD5STEP(F2, d, a, b, c, in[2]  + 0xfcefa3f8, 9);\n  MD5STEP(F2, c, d, a, b, in[7]  + 0x676f02d9, 14);\n  MD5STEP(F2, b, c, d, a, in[12] + 0x8d2a4c8a, 20);\n\n  MD5STEP(F3, a, b, c, d, in[5]  + 0xfffa3942, 4);\n  MD5STEP(F3, d, a, b, c, in[8]  + 0x8771f681, 11);\n  MD5STEP(F3, c, d, a, b, in[11] + 0x6d9d6122, 16);\n  MD5STEP(F3, b, c, d, a, in[14] + 0xfde5380c, 23);\n  MD5STEP(F3, a, b, c, d, in[1]  + 0xa4beea44, 4);\n  MD5STEP(F3, d, a, b, c, in[4]  + 0x4bdecfa9, 11);\n  MD5STEP(F3, c, d, a, b, in[7]  + 0xf6bb4b60, 16);\n  MD5STEP(F3, b, c, d, a, in[10] + 0xbebfbc70, 23);\n  MD5STEP(F3, a, b, c, d, in[13] + 0x289b7ec6, 4);\n  MD5STEP(F3, d, a, b, c, in[0]  + 0xeaa127fa, 11);\n  MD5STEP(F3, c, d, a, b, in[3]  + 0xd4ef3085, 16);\n  MD5STEP(F3, b, c, d, a, in[6]  + 0x04881d05, 23);\n  MD5STEP(F3, a, b, c, d, in[9]  + 0xd9d4d039, 4);\n  MD5STEP(F3, d, a, b, c, in[12] + 0xe6db99e5, 11);\n  MD5STEP(F3, c, d, a, b, in[15] + 0x1fa27cf8, 16);\n  MD5STEP(F3, b, c, d, a, in[2]  + 0xc4ac5665, 23);\n\n  MD5STEP(F4, a, b, c, d, in[0]  + 0xf4292244, 6);\n  MD5STEP(F4, d, a, b, c, in[7]  + 0x432aff97, 10);\n  MD5STEP(F4, c, d, a, b, in[14] + 0xab9423a7, 15);\n  MD5STEP(F4, b, c, d, a, in[5]  + 0xfc93a039, 21);\n  MD5STEP(F4, a, b, c, d, in[12] + 0x655b59c3, 6);\n  MD5STEP(F4, d, a, b, c, in[3]  + 0x8f0ccc92, 10);\n  MD5STEP(F4, c, d, a, b, in[10] + 0xffeff47d, 15);\n  MD5STEP(F4, b, c, d, a, in[1]  + 0x85845dd1, 21);\n  MD5STEP(F4, a, b, c, d, in[8]  + 0x6fa87e4f, 6);\n  MD5STEP(F4, d, a, b, c, in[15] + 0xfe2ce6e0, 10);\n  MD5STEP(F4, c, d, a, b, in[6]  + 0xa3014314, 15);\n  MD5STEP(F4, b, c, d, a, in[13] + 0x4e0811a1, 21);\n  MD5STEP(F4, a, b, c, d, in[4]  + 0xf7537e82, 6);\n  MD5STEP(F4, d, a, b, c, in[11] + 0xbd3af235, 10);\n  MD5STEP(F4, c, d, a, b, in[2]  + 0x2ad7d2bb, 15);\n  MD5STEP(F4, b, c, d, a, in[9]  + 0xeb86d391, 21);\n\n  state[0] += a;\n  state[1] += b;\n  state[2] += c;\n  state[3] += d;\n}",
      "lines": 96,
      "depth": 20,
      "decorators": [
        "void"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/microhttpd/md5.h": {},
  "libmicrohttpd/libmicrohttpd-0.9.59/src/microhttpd/memorypool.c": {
    "MHD_free": {
      "start_point": [
        87,
        0
      ],
      "end_point": [
        91,
        1
      ],
      "content": "_MHD_EXTERN void\nMHD_free (void *ptr)\n{\n  free (ptr);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "_MHD_EXTERN",
        "void",
        "void"
      ]
    },
    "MHD_pool_create": {
      "start_point": [
        100,
        0
      ],
      "end_point": [
        147,
        1
      ],
      "content": "struct MemoryPool *\nMHD_pool_create (size_t max)\n{\n  struct MemoryPool *pool;\n\n  pool = malloc (sizeof (struct MemoryPool));\n  if (NULL == pool)\n    return NULL;\n#if defined(MAP_ANONYMOUS) || defined(_WIN32)\n  if (max <= 32 * 1024)\n    pool->memory = MAP_FAILED;\n  else\n#if defined(MAP_ANONYMOUS) && !defined(_WIN32)\n    pool->memory = mmap (NULL,\n                         max,\n                         PROT_READ | PROT_WRITE,\n\t\t\t MAP_PRIVATE | MAP_ANONYMOUS,\n                         -1,\n                         0);\n#elif defined(_WIN32)\n    pool->memory = VirtualAlloc (NULL,\n                                 max,\n                                 MEM_COMMIT | MEM_RESERVE,\n                                 PAGE_READWRITE);\n#endif\n#else\n  pool->memory = MAP_FAILED;\n#endif\n  if ( (MAP_FAILED == pool->memory) ||\n       (NULL == pool->memory))\n    {\n      pool->memory = malloc (max);\n      if (NULL == pool->memory)\n        {\n          free (pool);\n          return NULL;\n        }\n      pool->is_mmap = MHD_NO;\n    }\n  else\n    {\n      pool->is_mmap = MHD_YES;\n    }\n  pool->pos = 0;\n  pool->end = max;\n  pool->size = max;\n  return pool;\n}",
      "lines": 48,
      "depth": 11,
      "decorators": [
        "struct MemoryPool",
        "struct",
        "MemoryPool",
        "*\nMHD_pool_create (size_t max)",
        "*"
      ]
    },
    "MHD_pool_destroy": {
      "start_point": [
        155,
        0
      ],
      "end_point": [
        174,
        1
      ],
      "content": "void\nMHD_pool_destroy (struct MemoryPool *pool)\n{\n  if (NULL == pool)\n    return;\n  if (MHD_NO == pool->is_mmap)\n    free (pool->memory);\n  else\n#if defined(MAP_ANONYMOUS) && !defined(_WIN32)\n    munmap (pool->memory,\n            pool->size);\n#elif defined(_WIN32)\n    VirtualFree (pool->memory,\n                 0,\n                 MEM_RELEASE);\n#else\n    abort ();\n#endif\n  free (pool);\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "MHD_pool_get_free": {
      "start_point": [
        183,
        0
      ],
      "end_point": [
        187,
        1
      ],
      "content": "size_t\nMHD_pool_get_free (struct MemoryPool *pool)\n{\n  return (pool->end - pool->pos);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "size_t"
      ]
    },
    "MHD_pool_allocate": {
      "start_point": [
        201,
        0
      ],
      "end_point": [
        226,
        1
      ],
      "content": "void *\nMHD_pool_allocate (struct MemoryPool *pool,\n\t\t   size_t size,\n                   int from_end)\n{\n  void *ret;\n  size_t asize;\n\n  asize = ROUND_TO_ALIGN (size);\n  if ( (0 == asize) && (0 != size) )\n    return NULL; /* size too close to SIZE_MAX */\n  if ( (pool->pos + asize > pool->end) ||\n       (pool->pos + asize < pool->pos))\n    return NULL;\n  if (from_end == MHD_YES)\n    {\n      ret = &pool->memory[pool->end - asize];\n      pool->end -= asize;\n    }\n  else\n    {\n      ret = &pool->memory[pool->pos];\n      pool->pos += asize;\n    }\n  return ret;\n}",
      "lines": 26,
      "depth": 11,
      "decorators": [
        "void",
        "*\nMHD_pool_allocate (struct MemoryPool *pool,\n\t\t   size_t size,\n                   int from_end)",
        "*"
      ]
    },
    "MHD_pool_reallocate": {
      "start_point": [
        246,
        0
      ],
      "end_point": [
        296,
        1
      ],
      "content": "void *\nMHD_pool_reallocate (struct MemoryPool *pool,\n                     void *old,\n\t\t     size_t old_size,\n\t\t     size_t new_size)\n{\n  void *ret;\n  size_t asize;\n\n  asize = ROUND_TO_ALIGN (new_size);\n  if ( (0 == asize) &&\n       (0 != new_size) )\n    return NULL; /* new_size too close to SIZE_MAX */\n  if ( (pool->end < old_size) ||\n       (pool->end < asize) )\n    return NULL;                /* unsatisfiable or bogus request */\n\n  if ( (pool->pos >= old_size) &&\n       (&pool->memory[pool->pos - old_size] == old) )\n    {\n      /* was the previous allocation - optimize! */\n      if (pool->pos + asize - old_size <= pool->end)\n        {\n          /* fits */\n          pool->pos += asize - old_size;\n          if (asize < old_size)      /* shrinking - zero again! */\n            memset (&pool->memory[pool->pos],\n                    0,\n                    old_size - asize);\n          return old;\n        }\n      /* does not fit */\n      return NULL;\n    }\n  if (asize <= old_size)\n    return old;                 /* cannot shrink, no need to move */\n  if ((pool->pos + asize >= pool->pos) &&\n      (pool->pos + asize <= pool->end))\n    {\n      /* fits */\n      ret = &pool->memory[pool->pos];\n      if (0 != old_size)\n        memmove (ret,\n                 old,\n                 old_size);\n      pool->pos += asize;\n      return ret;\n    }\n  /* does not fit */\n  return NULL;\n}",
      "lines": 51,
      "depth": 14,
      "decorators": [
        "void",
        "*\nMHD_pool_reallocate (struct MemoryPool *pool,\n                     void *old,\n\t\t     size_t old_size,\n\t\t     size_t new_size)",
        "*"
      ]
    },
    "MHD_pool_reset": {
      "start_point": [
        312,
        0
      ],
      "end_point": [
        336,
        1
      ],
      "content": "void *\nMHD_pool_reset (struct MemoryPool *pool,\n\t\tvoid *keep,\n\t\tsize_t copy_bytes,\n                size_t new_size)\n{\n  if ( (NULL != keep) &&\n       (keep != pool->memory) )\n    {\n      if (0 != copy_bytes)\n        memmove (pool->memory,\n                 keep,\n                 copy_bytes);\n      keep = pool->memory;\n    }\n  pool->end = pool->size;\n  /* technically not needed, but safer to zero out */\n  if (pool->size > copy_bytes)\n    memset (&pool->memory[copy_bytes],\n            0,\n            pool->size - copy_bytes);\n  if (NULL != keep)\n    pool->pos = ROUND_TO_ALIGN (new_size);\n  return keep;\n}",
      "lines": 25,
      "depth": 10,
      "decorators": [
        "void",
        "*\nMHD_pool_reset (struct MemoryPool *pool,\n\t\tvoid *keep,\n\t\tsize_t copy_bytes,\n                size_t new_size)",
        "*"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/microhttpd/memorypool.h": {},
  "libmicrohttpd/libmicrohttpd-0.9.59/src/microhttpd/mhd_assert.h": {},
  "libmicrohttpd/libmicrohttpd-0.9.59/src/microhttpd/mhd_byteorder.h": {},
  "libmicrohttpd/libmicrohttpd-0.9.59/src/microhttpd/mhd_compat.c": {
    "W32_snprintf": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "int\nW32_snprintf (char *__restrict s,\n              size_t n,\n              const char *__restrict format,\n              ...)\n{\n  int ret;\n  va_list args;\n\n  if ( (0 != n) &&\n       (NULL != s) )\n  {\n    va_start (args,\n              format);\n    ret = _vsnprintf (s,\n                      n,\n                      format,\n                      args);\n    va_end (args);\n    if ((int)n == ret)\n      s[n - 1] = 0;\n    if (ret >= 0)\n      return ret;\n  }\n  va_start(args,\n           format);\n  ret = _vscprintf (format,\n                    args);\n  va_end(args);\n  if ( (0 <= ret) &&\n       (0 != n) &&\n       (NULL == s) )\n    return -1;\n\n  return ret;\n}",
      "lines": 36,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "MHD_calloc_": {
      "start_point": [
        95,
        0
      ],
      "end_point": [
        112,
        1
      ],
      "content": "void *MHD_calloc_(size_t nelem, size_t elsize)\n{\n  size_t alloc_size;\n  void *ptr;\n#ifdef MHD_HAVE_NUL_OVERFLOW\n  if (__builtin_mul_overflow(nelem, elsize, &alloc_size) || 0 == alloc_size)\n    return NULL;\n#else  /* ! MHD_HAVE_NUL_OVERFLOW */\n  alloc_size = nelem * elsize;\n  if (0 == alloc_size || elsize != alloc_size / nelem)\n    return NULL;\n#endif /* ! MHD_HAVE_NUL_OVERFLOW */\n  ptr = malloc (alloc_size);\n  if (NULL == ptr)\n    return NULL;\n  memset(ptr, 0, alloc_size);\n  return ptr;\n}",
      "lines": 18,
      "depth": 10,
      "decorators": [
        "void",
        "*MHD_calloc_(size_t nelem, size_t elsize)",
        "*"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/microhttpd/mhd_compat.h": {},
  "libmicrohttpd/libmicrohttpd-0.9.59/src/microhttpd/mhd_itc.c": {
    "MHD_itc_nonblocking_": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "int\nMHD_itc_nonblocking_ (struct MHD_itc_ itc)\n{\n  unsigned int i;\n\n  for (i=0;i<2;i++)\n  {\n    int flags;\n\n    flags = fcntl (itc.fd[i],\n                   F_GETFL);\n    if (-1 == flags)\n      return 0;\n\n    if ( ((flags | O_NONBLOCK) != flags) &&\n         (0 != fcntl (itc.fd[i],\n                      F_SETFL,\n                      flags | O_NONBLOCK)) )\n      return 0;\n  }\n  return !0;\n}",
      "lines": 22,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/microhttpd/mhd_itc.h": {},
  "libmicrohttpd/libmicrohttpd-0.9.59/src/microhttpd/mhd_itc_types.h": {},
  "libmicrohttpd/libmicrohttpd-0.9.59/src/microhttpd/mhd_limits.h": {},
  "libmicrohttpd/libmicrohttpd-0.9.59/src/microhttpd/mhd_locks.h": {},
  "libmicrohttpd/libmicrohttpd-0.9.59/src/microhttpd/mhd_mono_clock.c": {
    "MHD_monotonic_sec_counter_init": {
      "start_point": [
        136,
        0
      ],
      "end_point": [
        308,
        1
      ],
      "content": "void\nMHD_monotonic_sec_counter_init (void)\n{\n#ifdef HAVE_CLOCK_GET_TIME\n  mach_timespec_t cur_time;\n#endif /* HAVE_CLOCK_GET_TIME */\n  enum _MHD_mono_clock_source mono_clock_source = _MHD_CLOCK_NO_SOURCE;\n#ifdef HAVE_CLOCK_GETTIME\n  struct timespec ts;\n\n  mono_clock_id = _MHD_UNWANTED_CLOCK;\n#endif /* HAVE_CLOCK_GETTIME */\n#ifdef HAVE_CLOCK_GET_TIME\n  mono_clock_service = _MHD_INVALID_CLOCK_SERV;\n#endif /* HAVE_CLOCK_GET_TIME */\n\n  /* just a little syntactic trick to get the\n     various following ifdef's to work out nicely */\n  if (0)\n    {\n    }\n  else\n#ifdef HAVE_CLOCK_GETTIME\n#ifdef CLOCK_MONOTONIC_COARSE\n  /* Linux-specific fast value-getting clock */\n  /* Can be affected by frequency adjustment and don't count time in suspend, */\n  /* but preferred since it's fast */\n  if (0 == clock_gettime (CLOCK_MONOTONIC_COARSE,\n                          &ts))\n    {\n      mono_clock_id = CLOCK_MONOTONIC_COARSE;\n      mono_clock_start = ts.tv_sec;\n      mono_clock_source = _MHD_CLOCK_GETTIME;\n    }\n  else\n#endif /* CLOCK_MONOTONIC_COARSE */\n#ifdef CLOCK_MONOTONIC_FAST\n  /* FreeBSD/DragonFly fast value-getting clock */\n  /* Can be affected by frequency adjustment, but preferred since it's fast */\n  if (0 == clock_gettime (CLOCK_MONOTONIC_FAST,\n                          &ts))\n    {\n      mono_clock_id = CLOCK_MONOTONIC_FAST;\n      mono_clock_start = ts.tv_sec;\n      mono_clock_source = _MHD_CLOCK_GETTIME;\n    }\n  else\n#endif /* CLOCK_MONOTONIC_COARSE */\n#ifdef CLOCK_MONOTONIC_RAW\n  /* Linux-specific clock */\n  /* Not affected by frequency adjustment, but don't count time in suspend */\n  if (0 == clock_gettime (CLOCK_MONOTONIC_RAW,\n                          &ts))\n    {\n      mono_clock_id = CLOCK_MONOTONIC_RAW;\n      mono_clock_start = ts.tv_sec;\n      mono_clock_source = _MHD_CLOCK_GETTIME;\n    }\n  else\n#endif /* CLOCK_MONOTONIC_RAW */\n#ifdef CLOCK_BOOTTIME\n  /* Linux-specific clock */\n  /* Count time in suspend so it's real monotonic on Linux, */\n  /* but can be slower value-getting than other clocks */\n  if (0 == clock_gettime (CLOCK_BOOTTIME,\n                          &ts))\n    {\n      mono_clock_id = CLOCK_BOOTTIME;\n      mono_clock_start = ts.tv_sec;\n      mono_clock_source = _MHD_CLOCK_GETTIME;\n    }\n  else\n#endif /* CLOCK_BOOTTIME */\n#ifdef CLOCK_MONOTONIC\n  /* Monotonic clock */\n  /* Widely supported, may be affected by frequency adjustment */\n  /* On Linux it's not truly monotonic as it doesn't count time in suspend */\n  if (0 == clock_gettime (CLOCK_MONOTONIC,\n                          &ts))\n    {\n      mono_clock_id = CLOCK_MONOTONIC;\n      mono_clock_start = ts.tv_sec;\n      mono_clock_source = _MHD_CLOCK_GETTIME;\n    }\n  else\n#endif /* CLOCK_BOOTTIME */\n#endif /* HAVE_CLOCK_GETTIME */\n#ifdef HAVE_CLOCK_GET_TIME\n  /* Darwin-specific monotonic clock */\n  /* Should be monotonic as clock_set_time function always unconditionally */\n  /* failed on latest kernels */\n  if ( (KERN_SUCCESS == host_get_clock_service (mach_host_self(),\n                                                SYSTEM_CLOCK,\n                                                &mono_clock_service)) &&\n       (KERN_SUCCESS == clock_get_time (mono_clock_service,\n                                        &cur_time)) )\n    {\n      mono_clock_start = cur_time.tv_sec;\n      mono_clock_source = _MHD_CLOCK_GET_TIME;\n    }\n  else\n#endif /* HAVE_CLOCK_GET_TIME */\n#ifdef _WIN32\n#if _WIN32_WINNT >= 0x0600\n  /* W32 Vista or later specific monotonic clock */\n  /* Available since Vista, ~15ms accuracy */\n  if (1)\n    {\n      tick_start = GetTickCount64 ();\n      mono_clock_source = _MHD_CLOCK_GETTICKCOUNT64;\n    }\n  else\n#else  /* _WIN32_WINNT < 0x0600 */\n  /* W32 specific monotonic clock */\n  /* Available on Windows 2000 and later */\n  if (1)\n    {\n      LARGE_INTEGER freq;\n      LARGE_INTEGER perf_counter;\n\n      QueryPerformanceFrequency (&freq); /* never fail on XP and later */\n      QueryPerformanceCounter (&perf_counter); /* never fail on XP and later */\n      perf_freq = freq.QuadPart;\n      perf_start = perf_counter.QuadPart;\n      mono_clock_source = _MHD_CLOCK_PERFCOUNTER;\n    }\n  else\n#endif /* _WIN32_WINNT < 0x0600 */\n#endif /* _WIN32 */\n#ifdef HAVE_CLOCK_GETTIME\n#ifdef CLOCK_HIGHRES\n  /* Solaris-specific monotonic high-resolution clock */\n  /* Not preferred due to be potentially resource-hungry */\n  if (0 == clock_gettime (CLOCK_HIGHRES,\n                          &ts))\n    {\n      mono_clock_id = CLOCK_HIGHRES;\n      mono_clock_start = ts.tv_sec;\n      mono_clock_source = _MHD_CLOCK_GETTIME;\n    }\n  else\n#endif /* CLOCK_HIGHRES */\n#endif /* HAVE_CLOCK_GETTIME */\n#ifdef HAVE_GETHRTIME\n  /* HP-UX and Solaris monotonic clock */\n  /* Not preferred due to be potentially resource-hungry */\n  if (1)\n    {\n      hrtime_start = gethrtime ();\n      mono_clock_source = _MHD_CLOCK_GETHRTIME;\n    }\n  else\n#endif /* HAVE_GETHRTIME */\n    {\n      /* no suitable clock source was found */\n      mono_clock_source = _MHD_CLOCK_NO_SOURCE;\n    }\n\n#ifdef HAVE_CLOCK_GET_TIME\n  if ( (_MHD_CLOCK_GET_TIME != mono_clock_source) &&\n       (_MHD_INVALID_CLOCK_SERV != mono_clock_service) )\n    {\n      /* clock service was initialised but clock_get_time failed */\n      mach_port_deallocate (mach_task_self(),\n                            mono_clock_service);\n      mono_clock_service = _MHD_INVALID_CLOCK_SERV;\n    }\n#else\n  (void) mono_clock_source; /* avoid compiler warning */\n#endif /* HAVE_CLOCK_GET_TIME */\n\n  sys_clock_start = time (NULL);\n}",
      "lines": 173,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "MHD_monotonic_sec_counter_finish": {
      "start_point": [
        314,
        0
      ],
      "end_point": [
        325,
        1
      ],
      "content": "void\nMHD_monotonic_sec_counter_finish (void)\n{\n#ifdef HAVE_CLOCK_GET_TIME\n  if (_MHD_INVALID_CLOCK_SERV != mono_clock_service)\n    {\n      mach_port_deallocate (mach_task_self(),\n                            mono_clock_service);\n      mono_clock_service = _MHD_INVALID_CLOCK_SERV;\n    }\n#endif /* HAVE_CLOCK_GET_TIME */\n}",
      "lines": 12,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "MHD_monotonic_sec_counter": {
      "start_point": [
        335,
        0
      ],
      "end_point": [
        376,
        1
      ],
      "content": "time_t\nMHD_monotonic_sec_counter (void)\n{\n#ifdef HAVE_CLOCK_GETTIME\n  struct timespec ts;\n\n  if ( (_MHD_UNWANTED_CLOCK != mono_clock_id) &&\n       (0 == clock_gettime (mono_clock_id ,\n                            &ts)) )\n    return ts.tv_sec - mono_clock_start;\n#endif /* HAVE_CLOCK_GETTIME */\n#ifdef HAVE_CLOCK_GET_TIME\n  if (_MHD_INVALID_CLOCK_SERV != mono_clock_service)\n    {\n      mach_timespec_t cur_time;\n\n      if (KERN_SUCCESS == clock_get_time(mono_clock_service,\n                                         &cur_time))\n        return cur_time.tv_sec - mono_clock_start;\n    }\n#endif /* HAVE_CLOCK_GET_TIME */\n#if defined(_WIN32)\n#if _WIN32_WINNT >= 0x0600\n  if (1)\n    return (time_t)(((uint64_t)(GetTickCount64() - tick_start)) / 1000);\n#else  /* _WIN32_WINNT < 0x0600 */\n  if (0 != perf_freq)\n    {\n      LARGE_INTEGER perf_counter;\n\n      QueryPerformanceCounter (&perf_counter); /* never fail on XP and later */\n      return (time_t)(((uint64_t)(perf_counter.QuadPart - perf_start)) / perf_freq);\n    }\n#endif /* _WIN32_WINNT < 0x0600 */\n#endif /* _WIN32 */\n#ifdef HAVE_GETHRTIME\n  if (1)\n    return (time_t)(((uint64_t) (gethrtime () - hrtime_start)) / 1000000000);\n#endif /* HAVE_GETHRTIME */\n\n  return time (NULL) - sys_clock_start;\n}",
      "lines": 42,
      "depth": 17,
      "decorators": [
        "time_t"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/microhttpd/mhd_mono_clock.h": {},
  "libmicrohttpd/libmicrohttpd-0.9.59/src/microhttpd/mhd_sockets.c": {
    "MHD_W32_strerror_winsock_": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        237,
        1
      ],
      "content": "const char* MHD_W32_strerror_winsock_(int err)\n{\n  switch (err)\n    {\n  case 0:\n    return \"No error\";\n  case WSA_INVALID_HANDLE:\n    return \"Specified event object handle is invalid\";\n  case WSA_NOT_ENOUGH_MEMORY:\n    return \"Insufficient memory available\";\n  case WSA_INVALID_PARAMETER:\n    return \"One or more parameters are invalid\";\n  case WSA_OPERATION_ABORTED:\n    return \"Overlapped operation aborted\";\n  case WSA_IO_INCOMPLETE:\n    return \"Overlapped I/O event object not in signaled state\";\n  case WSA_IO_PENDING:\n    return \"Overlapped operations will complete later\";\n  case WSAEINTR:\n    return \"Interrupted function call\";\n  case WSAEBADF:\n    return \"File handle is not valid\";\n  case WSAEACCES:\n    return \"Permission denied\";\n  case WSAEFAULT:\n    return \"Bad address\";\n  case WSAEINVAL:\n    return \"Invalid argument\";\n  case WSAEMFILE:\n    return \"Too many open files\";\n  case WSAEWOULDBLOCK:\n    return \"Resource temporarily unavailable\";\n  case WSAEINPROGRESS:\n    return \"Operation now in progress\";\n  case WSAEALREADY:\n    return \"Operation already in progress\";\n  case WSAENOTSOCK:\n    return \"Socket operation on nonsocket\";\n  case WSAEDESTADDRREQ:\n    return \"Destination address required\";\n  case WSAEMSGSIZE:\n    return \"Message too long\";\n  case WSAEPROTOTYPE:\n    return \"Protocol wrong type for socket\";\n  case WSAENOPROTOOPT:\n    return \"Bad protocol option\";\n  case WSAEPROTONOSUPPORT:\n    return \"Protocol not supported\";\n  case WSAESOCKTNOSUPPORT:\n    return \"Socket type not supported\";\n  case WSAEOPNOTSUPP:\n    return \"Operation not supported\";\n  case WSAEPFNOSUPPORT:\n    return \"Protocol family not supported\";\n  case WSAEAFNOSUPPORT:\n    return \"Address family not supported by protocol family\";\n  case WSAEADDRINUSE:\n    return \"Address already in use\";\n  case WSAEADDRNOTAVAIL:\n    return \"Cannot assign requested address\";\n  case WSAENETDOWN:\n    return \"Network is down\";\n  case WSAENETUNREACH:\n    return \"Network is unreachable\";\n  case WSAENETRESET:\n    return \"Network dropped connection on reset\";\n  case WSAECONNABORTED:\n    return \"Software caused connection abort\";\n  case WSAECONNRESET:\n    return \"Connection reset by peer\";\n  case WSAENOBUFS:\n    return \"No buffer space available\";\n  case WSAEISCONN:\n    return \"Socket is already connected\";\n  case WSAENOTCONN:\n    return \"Socket is not connected\";\n  case WSAESHUTDOWN:\n    return \"Cannot send after socket shutdown\";\n  case WSAETOOMANYREFS:\n    return \"Too many references\";\n  case WSAETIMEDOUT:\n    return \"Connection timed out\";\n  case WSAECONNREFUSED:\n    return \"Connection refused\";\n  case WSAELOOP:\n    return \"Cannot translate name\";\n  case WSAENAMETOOLONG:\n    return \"Name too long\";\n  case WSAEHOSTDOWN:\n    return \"Host is down\";\n  case WSAEHOSTUNREACH:\n    return \"No route to host\";\n  case WSAENOTEMPTY:\n    return \"Directory not empty\";\n  case WSAEPROCLIM:\n    return \"Too many processes\";\n  case WSAEUSERS:\n    return \"User quota exceeded\";\n  case WSAEDQUOT:\n    return \"Disk quota exceeded\";\n  case WSAESTALE:\n    return \"Stale file handle reference\";\n  case WSAEREMOTE:\n    return \"Item is remote\";\n  case WSASYSNOTREADY:\n    return \"Network subsystem is unavailable\";\n  case WSAVERNOTSUPPORTED:\n    return \"Winsock.dll version out of range\";\n  case WSANOTINITIALISED:\n    return \"Successful WSAStartup not yet performed\";\n  case WSAEDISCON:\n    return \"Graceful shutdown in progress\";\n  case WSAENOMORE:\n    return \"No more results\";\n  case WSAECANCELLED:\n    return \"Call has been canceled\";\n  case WSAEINVALIDPROCTABLE:\n    return \"Procedure call table is invalid\";\n  case WSAEINVALIDPROVIDER:\n    return \"Service provider is invalid\";\n  case WSAEPROVIDERFAILEDINIT:\n    return \"Service provider failed to initialize\";\n  case WSASYSCALLFAILURE:\n    return \"System call failure\";\n  case WSASERVICE_NOT_FOUND:\n    return \"Service not found\";\n  case WSATYPE_NOT_FOUND:\n    return \"Class type not found\";\n  case WSA_E_NO_MORE:\n    return \"No more results\";\n  case WSA_E_CANCELLED:\n    return \"Call was canceled\";\n  case WSAEREFUSED:\n    return \"Database query was refused\";\n  case WSAHOST_NOT_FOUND:\n    return \"Host not found\";\n  case WSATRY_AGAIN:\n    return \"Nonauthoritative host not found\";\n  case WSANO_RECOVERY:\n    return \"This is a nonrecoverable error\";\n  case WSANO_DATA:\n    return \"Valid name, no data record of requested type\";\n  case WSA_QOS_RECEIVERS:\n    return \"QoS receivers\";\n  case WSA_QOS_SENDERS:\n    return \"QoS senders\";\n  case WSA_QOS_NO_SENDERS:\n    return \"No QoS senders\";\n  case WSA_QOS_NO_RECEIVERS:\n    return \"QoS no receivers\";\n  case WSA_QOS_REQUEST_CONFIRMED:\n    return \"QoS request confirmed\";\n  case WSA_QOS_ADMISSION_FAILURE:\n    return \"QoS admission error\";\n  case WSA_QOS_POLICY_FAILURE:\n    return \"QoS policy failure\";\n  case WSA_QOS_BAD_STYLE:\n    return \"QoS bad style\";\n  case WSA_QOS_BAD_OBJECT:\n    return \"QoS bad object\";\n  case WSA_QOS_TRAFFIC_CTRL_ERROR:\n    return \"QoS traffic control error\";\n  case WSA_QOS_GENERIC_ERROR:\n    return \"QoS generic error\";\n  case WSA_QOS_ESERVICETYPE:\n    return \"QoS service type error\";\n  case WSA_QOS_EFLOWSPEC:\n    return \"QoS flowspec error\";\n  case WSA_QOS_EPROVSPECBUF:\n    return \"Invalid QoS provider buffer\";\n  case WSA_QOS_EFILTERSTYLE:\n    return \"Invalid QoS filter style\";\n  case WSA_QOS_EFILTERTYPE:\n    return \"Invalid QoS filter type\";\n  case WSA_QOS_EFILTERCOUNT:\n    return \"Incorrect QoS filter count\";\n  case WSA_QOS_EOBJLENGTH:\n    return \"Invalid QoS object length\";\n  case WSA_QOS_EFLOWCOUNT:\n    return \"Incorrect QoS flow count\";\n  case WSA_QOS_EUNKOWNPSOBJ:\n    return \"Unrecognized QoS object\";\n  case WSA_QOS_EPOLICYOBJ:\n    return \"Invalid QoS policy object\";\n  case WSA_QOS_EFLOWDESC:\n    return \"Invalid QoS flow descriptor\";\n  case WSA_QOS_EPSFLOWSPEC:\n    return \"Invalid QoS provider-specific flowspec\";\n  case WSA_QOS_EPSFILTERSPEC:\n    return \"Invalid QoS provider-specific filterspec\";\n  case WSA_QOS_ESDMODEOBJ:\n    return \"Invalid QoS shape discard mode object\";\n  case WSA_QOS_ESHAPERATEOBJ:\n    return \"Invalid QoS shaping rate object\";\n  case WSA_QOS_RESERVED_PETYPE:\n    return \"Reserved policy QoS element type\";\n    }\n  return \"Unknown winsock error\";\n}",
      "lines": 199,
      "depth": 8,
      "decorators": [
        "const",
        "const",
        "char",
        "* MHD_W32_strerror_winsock_(int err)",
        "*"
      ]
    },
    "MHD_W32_socket_pair_": {
      "start_point": [
        247,
        0
      ],
      "end_point": [
        357,
        1
      ],
      "content": "int\nMHD_W32_socket_pair_(SOCKET sockets_pair[2], int non_blk)\n{\n  int i;\n\n  if (! sockets_pair)\n    {\n      WSASetLastError (WSAEFAULT);\n      return 0;\n    }\n\n#define PAIRMAXTRYIES 800\n  for (i = 0; i < PAIRMAXTRYIES; i++)\n    {\n      struct sockaddr_in listen_addr;\n      SOCKET listen_s;\n      static const int c_addinlen = sizeof(struct sockaddr_in); /* help compiler to optimize */\n      int addr_len = c_addinlen;\n      unsigned long on_val = 1;\n      unsigned long off_val = 0;\n\n      listen_s = socket (AF_INET,\n                         SOCK_STREAM,\n                         IPPROTO_TCP);\n      if (INVALID_SOCKET == listen_s)\n        break; /* can't create even single socket */\n\n      listen_addr.sin_family = AF_INET;\n      listen_addr.sin_port = 0; /* same as htons(0) */\n      listen_addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n      if ( (0 == bind (listen_s,\n                       (struct sockaddr*) &listen_addr,\n                       c_addinlen) &&\n            (0 == listen (listen_s,\n                          1) ) &&\n            (0 == getsockname (listen_s,\n                               (struct sockaddr*) &listen_addr,\n                               &addr_len))) )\n        {\n          SOCKET client_s = socket(AF_INET,\n                                   SOCK_STREAM,\n                                   IPPROTO_TCP);\n          struct sockaddr_in accepted_from_addr;\n          struct sockaddr_in client_addr;\n          SOCKET server_s;\n\n          if (INVALID_SOCKET == client_s)\n            {\n              /* try again */\n              closesocket (listen_s);\n              continue;\n            }\n\n          if ( (0 != ioctlsocket (client_s,\n                                  FIONBIO,\n                                  &on_val)) ||\n               ( (0 != connect (client_s,\n                                (struct sockaddr*) &listen_addr,\n                                c_addinlen)) &&\n                 (WSAGetLastError() != WSAEWOULDBLOCK)) )\n            {\n              /* try again */\n              closesocket (listen_s);\n              closesocket (client_s);\n              continue;\n            }\n\n          addr_len = c_addinlen;\n          server_s = accept (listen_s,\n                             (struct sockaddr*) &accepted_from_addr,\n                             &addr_len);\n          if (INVALID_SOCKET == server_s)\n            {\n              /* try again */\n              closesocket (listen_s);\n              closesocket (client_s);\n              continue;\n            }\n\n          addr_len = c_addinlen;\n          if ( (0 == getsockname (client_s,\n                                  (struct sockaddr*) &client_addr,\n                                  &addr_len)) &&\n               (accepted_from_addr.sin_family == client_addr.sin_family) &&\n               (accepted_from_addr.sin_port == client_addr.sin_port) &&\n               (accepted_from_addr.sin_addr.s_addr == client_addr.sin_addr.s_addr) &&\n               ( (0 != non_blk) ?\n                    (0 == ioctlsocket(server_s,\n                                      FIONBIO,\n                                      &on_val)) :\n                    (0 == ioctlsocket(client_s,\n                                      FIONBIO,\n                                      &off_val)) ) )\n            {\n              closesocket (listen_s);\n              sockets_pair[0] = server_s;\n              sockets_pair[1] = client_s;\n              return !0;\n            }\n          closesocket (server_s);\n          closesocket (client_s);\n        }\n      closesocket(listen_s);\n    }\n\n  sockets_pair[0] = INVALID_SOCKET;\n  sockets_pair[1] = INVALID_SOCKET;\n  WSASetLastError(WSAECONNREFUSED);\n\n  return 0;\n}",
      "lines": 111,
      "depth": 20,
      "decorators": [
        "int"
      ]
    },
    "MHD_add_to_fd_set_": {
      "start_point": [
        372,
        0
      ],
      "end_point": [
        393,
        1
      ],
      "content": "int\nMHD_add_to_fd_set_ (MHD_socket fd,\n                    fd_set *set,\n                    MHD_socket *max_fd,\n                    unsigned int fd_setsize)\n{\n  if ( (NULL == set) ||\n       (MHD_INVALID_SOCKET == fd) )\n    return 0;\n  if (! MHD_SCKT_FD_FITS_FDSET_SETSIZE_ (fd,\n                                         set,\n                                         fd_setsize))\n    return 0;\n  MHD_SCKT_ADD_FD_TO_FDSET_SETSIZE_(fd,\n                                    set,\n                                    fd_setsize);\n  if ( (NULL != max_fd) &&\n       ( (fd > *max_fd) ||\n         (MHD_INVALID_SOCKET == *max_fd) ) )\n    *max_fd = fd;\n  return ! 0;\n}",
      "lines": 22,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "MHD_socket_nonblocking_": {
      "start_point": [
        402,
        0
      ],
      "end_point": [
        427,
        1
      ],
      "content": "int\nMHD_socket_nonblocking_ (MHD_socket sock)\n{\n#if defined(MHD_POSIX_SOCKETS)\n  int flags;\n\n  flags = fcntl (sock,\n                 F_GETFL);\n  if (-1 == flags)\n    return 0;\n\n  if ( ((flags | O_NONBLOCK) != flags) &&\n       (0 != fcntl (sock,\n                    F_SETFL,\n                    flags | O_NONBLOCK)) )\n    return 0;\n#elif defined(MHD_WINSOCK_SOCKETS)\n  unsigned long flags = 1;\n\n  if (0 != ioctlsocket (sock,\n                        FIONBIO,\n                        &flags))\n    return 0;\n#endif /* MHD_WINSOCK_SOCKETS */\n  return !0;\n}",
      "lines": 26,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "MHD_socket_noninheritable_": {
      "start_point": [
        437,
        0
      ],
      "end_point": [
        460,
        1
      ],
      "content": "int\nMHD_socket_noninheritable_ (MHD_socket sock)\n{\n#if defined(MHD_POSIX_SOCKETS)\n  int flags;\n\n  flags = fcntl (sock,\n                 F_GETFD);\n  if (-1 == flags)\n    return 0;\n\n  if ( ((flags | FD_CLOEXEC) != flags) &&\n       (0 != fcntl (sock,\n                    F_SETFD,\n                    flags | FD_CLOEXEC)) )\n    return 0;\n#elif defined(MHD_WINSOCK_SOCKETS)\n  if (! SetHandleInformation ((HANDLE)sock,\n                              HANDLE_FLAG_INHERIT,\n                              0))\n    return 0;\n#endif /* MHD_WINSOCK_SOCKETS */\n  return !0;\n}",
      "lines": 24,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "MHD_socket_create_listen_": {
      "start_point": [
        469,
        0
      ],
      "end_point": [
        522,
        1
      ],
      "content": "MHD_socket\nMHD_socket_create_listen_ (int use_ipv6)\n{\n  int domain;\n  MHD_socket fd;\n  int cloexec_set;\n\n#ifdef HAVE_INET6\n  domain = (use_ipv6) ? PF_INET6 : PF_INET;\n#else  /* ! HAVE_INET6 */\n  if (use_ipv6)\n    return MHD_INVALID_SOCKET;\n  domain = PF_INET;\n#endif /* ! HAVE_INET6 */\n\n#if defined(MHD_POSIX_SOCKETS) && defined(SOCK_CLOEXEC)\n  fd = socket (domain,\n               SOCK_STREAM | SOCK_CLOEXEC,\n               0);\n  cloexec_set = !0;\n#elif defined(MHD_WINSOCK_SOCKETS) && defined (WSA_FLAG_NO_HANDLE_INHERIT)\n  fd = WSASocketW (domain,\n                   SOCK_STREAM,\n                   0,\n                   NULL,\n                   0,\n                   WSA_FLAG_NO_HANDLE_INHERIT);\n  cloexec_set = !0;\n#else  /* !SOCK_CLOEXEC */\n  fd = MHD_INVALID_SOCKET;\n#endif /* !SOCK_CLOEXEC */\n  if (MHD_INVALID_SOCKET == fd)\n    {\n      fd = socket (domain,\n                   SOCK_STREAM,\n                   0);\n      cloexec_set = 0;\n    }\n  if (MHD_INVALID_SOCKET == fd)\n    return MHD_INVALID_SOCKET;\n#ifdef MHD_socket_nosignal_\n  if(! MHD_socket_nosignal_(fd))\n    {\n      const int err = MHD_socket_get_error_ ();\n      (void) MHD_socket_close_ (fd);\n      MHD_socket_fset_error_ (err);\n      return MHD_INVALID_SOCKET;\n    }\n#endif /* MHD_socket_nosignal_ */\n  if (! cloexec_set)\n    (void) MHD_socket_noninheritable_ (fd);\n\n  return fd;\n}",
      "lines": 54,
      "depth": 10,
      "decorators": [
        "MHD_socket"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/microhttpd/mhd_sockets.h": {},
  "libmicrohttpd/libmicrohttpd-0.9.59/src/microhttpd/mhd_str.c": {
    "isasciilower": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "_MHD_static_inline bool\nisasciilower (char c)\n{\n  return (c >= 'a') && (c <= 'z');\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "_MHD_static_inline",
        "bool",
        "bool"
      ]
    },
    "isasciiupper": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "_MHD_static_inline bool\nisasciiupper (char c)\n{\n  return (c >= 'A') && (c <= 'Z');\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "_MHD_static_inline",
        "bool",
        "bool"
      ]
    },
    "isasciialpha": {
      "start_point": [
        88,
        0
      ],
      "end_point": [
        92,
        1
      ],
      "content": "_MHD_static_inline bool\nisasciialpha (char c)\n{\n  return isasciilower (c) || isasciiupper (c);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "_MHD_static_inline",
        "bool",
        "bool"
      ]
    },
    "isasciidigit": {
      "start_point": [
        102,
        0
      ],
      "end_point": [
        106,
        1
      ],
      "content": "_MHD_static_inline bool\nisasciidigit (char c)\n{\n  return (c >= '0') && (c <= '9');\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "_MHD_static_inline",
        "bool",
        "bool"
      ]
    },
    "isasciixdigit": {
      "start_point": [
        115,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "_MHD_static_inline bool\nisasciixdigit (char c)\n{\n  return isasciidigit (c) ||\n    ( (c >= 'A') && (c <= 'F') ) ||\n    ( (c >= 'a') && (c <= 'f') );\n}",
      "lines": 7,
      "depth": 11,
      "decorators": [
        "_MHD_static_inline",
        "bool",
        "bool"
      ]
    },
    "isasciialnum": {
      "start_point": [
        130,
        0
      ],
      "end_point": [
        134,
        1
      ],
      "content": "_MHD_static_inline bool\nisasciialnum (char c)\n{\n  return isasciialpha (c) || isasciidigit (c);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "_MHD_static_inline",
        "bool",
        "bool"
      ]
    },
    "toasciilower": {
      "start_point": [
        147,
        0
      ],
      "end_point": [
        151,
        1
      ],
      "content": "_MHD_static_inline char\ntoasciilower (char c)\n{\n  return isasciiupper (c) ? (c - 'A' + 'a') : c;\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "_MHD_static_inline",
        "char",
        "char"
      ]
    },
    "toasciiupper": {
      "start_point": [
        164,
        0
      ],
      "end_point": [
        168,
        1
      ],
      "content": "_MHD_static_inline char\ntoasciiupper (char c)\n{\n  return isasciilower (c) ? (c - 'a' + 'A') : c;\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "_MHD_static_inline",
        "char",
        "char"
      ]
    },
    "todigitvalue": {
      "start_point": [
        179,
        0
      ],
      "end_point": [
        186,
        1
      ],
      "content": "_MHD_static_inline int\ntodigitvalue (char c)\n{\n  if (isasciidigit (c))\n    return (unsigned char)(c - '0');\n\n  return -1;\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "_MHD_static_inline",
        "int",
        "int"
      ]
    },
    "toxdigitvalue": {
      "start_point": [
        196,
        0
      ],
      "end_point": [
        207,
        1
      ],
      "content": "_MHD_static_inline int\ntoxdigitvalue (char c)\n{\n  if (isasciidigit (c))\n    return (unsigned char)(c - '0');\n  if ( (c >= 'A') && (c <= 'F') )\n    return (unsigned char)(c - 'A' + 10);\n  if ( (c >= 'a') && (c <= 'f') )\n    return (unsigned char)(c - 'a' + 10);\n\n  return -1;\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "_MHD_static_inline",
        "int",
        "int"
      ]
    },
    "MHD_str_equal_caseless_": {
      "start_point": [
        327,
        0
      ],
      "end_point": [
        342,
        1
      ],
      "content": "int\nMHD_str_equal_caseless_ (const char * str1,\n                         const char * str2)\n{\n  while (0 != (*str1))\n    {\n      const char c1 = *str1;\n      const char c2 = *str2;\n      if ( (c1 != c2) &&\n           (toasciilower (c1) != toasciilower (c2)) )\n        return 0;\n      str1++;\n      str2++;\n    }\n  return 0 == (*str2);\n}",
      "lines": 16,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "MHD_str_equal_caseless_n_": {
      "start_point": [
        357,
        0
      ],
      "end_point": [
        375,
        1
      ],
      "content": "int\nMHD_str_equal_caseless_n_ (const char * const str1,\n                           const char * const str2,\n                           size_t maxlen)\n{\n  size_t i;\n\n  for (i = 0; i < maxlen; ++i)\n    {\n      const char c1 = str1[i];\n      const char c2 = str2[i];\n      if (0 == c2)\n        return 0 == c1;\n      if ( (c1 != c2) &&\n           (toasciilower (c1) != toasciilower (c2)) )\n        return 0;\n    }\n  return !0;\n}",
      "lines": 19,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "MHD_str_has_token_caseless_": {
      "start_point": [
        391,
        0
      ],
      "end_point": [
        433,
        1
      ],
      "content": "bool\nMHD_str_has_token_caseless_ (const char * str,\n                             const char * const token,\n                             size_t token_len)\n{\n  if (0 == token_len)\n    return false;\n\n  while (0 != *str)\n    {\n      size_t i;\n      /* Skip all whitespaces and empty tokens. */\n      while (' ' == *str || '\\t' == *str || ',' == *str) str++;\n\n      /* Check for token match. */\n      i = 0;\n      while (1)\n        {\n          const char sc = *(str++);\n          const char tc = token[i++];\n\n          if (0 == sc)\n            return false;\n          if ( (sc != tc) &&\n               (toasciilower (sc) != toasciilower (tc)) )\n            break;\n          if (i >= token_len)\n            {\n              /* Check whether substring match token fully or\n               * has additional unmatched chars at tail. */\n              while (' ' == *str || '\\t' == *str) str++;\n              /* End of (sub)string? */\n              if (0 == *str || ',' == *str)\n                return true;\n              /* Unmatched chars at end of substring. */\n              break;\n            }\n        }\n       /* Find next substring. */\n      while (0 != *str && ',' != *str) str++;\n    }\n  return false;\n}",
      "lines": 43,
      "depth": 14,
      "decorators": [
        "bool"
      ]
    },
    "MHD_str_to_uint64_": {
      "start_point": [
        448,
        0
      ],
      "end_point": [
        474,
        1
      ],
      "content": "size_t\nMHD_str_to_uint64_ (const char *str,\n                    uint64_t *out_val)\n{\n  const char * const start = str;\n  uint64_t res;\n\n  if (!str || !out_val || !isasciidigit(str[0]))\n    return 0;\n\n  res = 0;\n  do\n    {\n      const int digit = (unsigned char)(*str) - '0';\n      if ( (res > (UINT64_MAX / 10)) ||\n           ( (res == (UINT64_MAX / 10)) &&\n             ((uint64_t)digit > (UINT64_MAX % 10)) ) )\n        return 0;\n\n      res *= 10;\n      res += digit;\n      str++;\n    } while (isasciidigit (*str));\n\n  *out_val = res;\n  return str - start;\n}",
      "lines": 27,
      "depth": 14,
      "decorators": [
        "size_t"
      ]
    },
    "MHD_str_to_uint64_n_": {
      "start_point": [
        490,
        0
      ],
      "end_point": [
        520,
        1
      ],
      "content": "size_t\nMHD_str_to_uint64_n_ (const char * str,\n                      size_t maxlen,\n                      uint64_t *out_val)\n{\n  uint64_t res;\n  size_t i;\n\n  if (!str || !maxlen || !out_val || !isasciidigit (str[0]))\n    return 0;\n\n  res = 0;\n  i = 0;\n  do\n    {\n      const int digit = (unsigned char)str[i] - '0';\n\n      if ( (res > (UINT64_MAX / 10)) ||\n           ( (res == (UINT64_MAX / 10)) &&\n             ((uint64_t)digit > (UINT64_MAX % 10)) ) )\n        return 0;\n\n      res *= 10;\n      res += digit;\n      i++;\n    } while ( (i < maxlen) &&\n              isasciidigit (str[i]) );\n\n  *out_val= res;\n  return i;\n}",
      "lines": 31,
      "depth": 14,
      "decorators": [
        "size_t"
      ]
    },
    "MHD_strx_to_uint32_": {
      "start_point": [
        533,
        0
      ],
      "end_point": [
        563,
        1
      ],
      "content": "size_t\nMHD_strx_to_uint32_ (const char * str,\n                     uint32_t *out_val)\n{\n  const char * const start = str;\n  uint32_t res;\n  int digit;\n\n  if (!str || !out_val)\n    return 0;\n\n  res = 0;\n  digit = toxdigitvalue (*str);\n  while (digit >= 0)\n    {\n      if ( (res < (UINT32_MAX / 16)) ||\n           (res == (UINT32_MAX / 16) && (uint32_t)digit <= (UINT32_MAX % 16)) )\n        {\n          res *= 16;\n          res += digit;\n        }\n      else\n        return 0;\n      str++;\n      digit = toxdigitvalue (*str);\n    }\n\n  if (str - start > 0)\n    *out_val = res;\n  return str - start;\n}",
      "lines": 31,
      "depth": 13,
      "decorators": [
        "size_t"
      ]
    },
    "MHD_strx_to_uint32_n_": {
      "start_point": [
        579,
        0
      ],
      "end_point": [
        606,
        1
      ],
      "content": "size_t\nMHD_strx_to_uint32_n_ (const char *str,\n                       size_t maxlen,\n                       uint32_t *out_val)\n{\n  size_t i;\n  uint32_t res;\n  int digit;\n  if (!str || !out_val)\n    return 0;\n\n  res = 0;\n  i = 0;\n  while (i < maxlen && (digit = toxdigitvalue (str[i])) >= 0)\n    {\n      if ( (res > (UINT32_MAX / 16)) ||\n           (res == (UINT32_MAX / 16) && (uint32_t)digit > (UINT32_MAX % 16)) )\n        return 0;\n\n      res *= 16;\n      res += digit;\n      i++;\n    }\n\n  if (i)\n    *out_val = res;\n  return i;\n}",
      "lines": 28,
      "depth": 13,
      "decorators": [
        "size_t"
      ]
    },
    "MHD_strx_to_uint64_": {
      "start_point": [
        619,
        0
      ],
      "end_point": [
        648,
        1
      ],
      "content": "size_t\nMHD_strx_to_uint64_ (const char *str,\n                     uint64_t *out_val)\n{\n  const char * const start = str;\n  uint64_t res;\n  int digit;\n  if (!str || !out_val)\n    return 0;\n\n  res = 0;\n  digit = toxdigitvalue (*str);\n  while (digit >= 0)\n    {\n      if ( (res < (UINT64_MAX / 16)) ||\n           (res == (UINT64_MAX / 16) && (uint64_t)digit <= (UINT64_MAX % 16)) )\n        {\n          res *= 16;\n          res += digit;\n        }\n      else\n        return 0;\n      str++;\n      digit = toxdigitvalue (*str);\n    }\n\n  if (str - start > 0)\n    *out_val = res;\n  return str - start;\n}",
      "lines": 30,
      "depth": 13,
      "decorators": [
        "size_t"
      ]
    },
    "MHD_strx_to_uint64_n_": {
      "start_point": [
        664,
        0
      ],
      "end_point": [
        691,
        1
      ],
      "content": "size_t\nMHD_strx_to_uint64_n_ (const char * str,\n                       size_t maxlen,\n                       uint64_t *out_val)\n{\n  size_t i;\n  uint64_t res;\n  int digit;\n  if (!str || !out_val)\n    return 0;\n\n  res = 0;\n  i = 0;\n  while (i < maxlen && (digit = toxdigitvalue (str[i])) >= 0)\n    {\n      if ( (res > (UINT64_MAX / 16)) ||\n           (res == (UINT64_MAX / 16) && (uint64_t)digit > (UINT64_MAX % 16)) )\n        return 0;\n\n      res *= 16;\n      res += digit;\n      i++;\n    }\n\n  if (i)\n    *out_val = res;\n  return i;\n}",
      "lines": 28,
      "depth": 13,
      "decorators": [
        "size_t"
      ]
    },
    "MHD_str_to_uvalue_n_": {
      "start_point": [
        712,
        0
      ],
      "end_point": [
        756,
        1
      ],
      "content": "size_t\nMHD_str_to_uvalue_n_ (const char *str,\n                      size_t maxlen,\n                      void * out_val,\n                      size_t val_size,\n                      uint64_t max_val,\n                      int base)\n{\n  size_t i;\n  uint64_t res;\n  int digit;\n  const uint64_t max_v_div_b = max_val / base;\n  const uint64_t max_v_mod_b = max_val % base;\n  /* 'digit->value' must be function, not macro */\n  int (*const dfunc)(char) = (base == 16) ?\n                              toxdigitvalue : todigitvalue;\n\n  if ( !str || !out_val ||\n       (base != 16 && base != 10) )\n    return 0;\n\n  res = 0;\n  i = 0;\n  while (maxlen > i && 0 <= (digit = dfunc (str[i])))\n    {\n      if ( ((max_v_div_b) < res) ||\n          ((max_v_div_b) == res && (max_v_mod_b) < (uint64_t)digit) )\n        return 0;\n\n      res *= base;\n      res += digit;\n      i++;\n    }\n\n  if (i)\n    {\n      if (8 == val_size)\n        *(uint64_t*)out_val = res;\n      else if (4 == val_size)\n        *(uint32_t*)out_val = (uint32_t)res;\n      else\n        return 0;\n    }\n  return i;\n}",
      "lines": 45,
      "depth": 13,
      "decorators": [
        "size_t"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/microhttpd/mhd_str.h": {},
  "libmicrohttpd/libmicrohttpd-0.9.59/src/microhttpd/mhd_threads.c": {
    "MHD_set_thread_name_": [
      {
        "start_point": [
          62,
          0
        ],
        "end_point": [
          83,
          1
        ],
        "content": "static int\nMHD_set_thread_name_(const MHD_thread_ID_ thread_id,\n                     const char *thread_name)\n{\n  if (NULL == thread_name)\n    return 0;\n\n#if defined(HAVE_PTHREAD_SETNAME_NP_GNU)\n  return !pthread_setname_np (thread_id, thread_name);\n#elif defined(HAVE_PTHREAD_SET_NAME_NP_FREEBSD)\n  /* FreeBSD and OpenBSD use different name and void return type */\n  pthread_set_name_np (thread_id, thread_name);\n  return !0;\n#elif defined(HAVE_PTHREAD_SETNAME_NP_NETBSD)\n  /* NetBSD use 3 arguments: second argument is string in printf-like format,\n   *                         third argument is single argument for printf;\n   * OSF1 use 3 arguments too, but last one always must be zero (NULL).\n   * MHD doesn't use '%' in thread names, so both form are used in same way.\n   */\n  return !pthread_setname_np (thread_id, thread_name, 0);\n#endif /* HAVE_PTHREAD_SETNAME_NP_NETBSD */\n}",
        "lines": 22,
        "depth": 10,
        "decorators": [
          "static",
          "static",
          "int"
        ]
      },
      {
        "start_point": [
          118,
          0
        ],
        "end_point": [
          152,
          1
        ],
        "content": "static int\nMHD_set_thread_name_(const MHD_thread_ID_ thread_id,\n                     const char *thread_name)\n{\n  static const DWORD VC_SETNAME_EXC = 0x406D1388;\n#pragma pack(push,8)\n  struct thread_info_struct\n  {\n    DWORD type;   /* Must be 0x1000. */\n    LPCSTR name;  /* Pointer to name (in user address space). */\n    DWORD ID;     /* Thread ID (-1 = caller thread). */\n    DWORD flags;  /* Reserved for future use, must be zero. */\n  } thread_info;\n#pragma pack(pop)\n\n  if (NULL == thread_name)\n    return 0;\n\n  thread_info.type  = 0x1000;\n  thread_info.name  = thread_name;\n  thread_info.ID    = thread_id;\n  thread_info.flags = 0;\n\n  __try\n  { /* This exception is intercepted by debugger */\n    RaiseException (VC_SETNAME_EXC,\n                    0,\n                    sizeof (thread_info) / sizeof(ULONG_PTR),\n                    (ULONG_PTR *) &thread_info);\n  }\n  __except (EXCEPTION_EXECUTE_HANDLER)\n  {}\n\n  return !0;\n}",
        "lines": 35,
        "depth": 10,
        "decorators": [
          "static",
          "static",
          "int"
        ]
      }
    ],
    "thread_info": {
      "start_point": [
        148,
        2
      ],
      "end_point": [
        149,
        4
      ],
      "content": "__except (EXCEPTION_EXECUTE_HANDLER)\n  {}",
      "lines": 2,
      "depth": 3,
      "decorators": null
    },
    "MHD_create_thread_": {
      "start_point": [
        176,
        0
      ],
      "end_point": [
        233,
        1
      ],
      "content": "int\nMHD_create_thread_ (MHD_thread_handle_ID_ *thread,\n                    size_t stack_size,\n                    MHD_THREAD_START_ROUTINE_ start_routine,\n                    void *arg)\n{\n#if defined(MHD_USE_POSIX_THREADS)\n  int res;\n\n  if (0 != stack_size)\n    {\n      pthread_attr_t attr;\n      res = pthread_attr_init (&attr);\n      if (0 == res)\n        {\n          res = pthread_attr_setstacksize (&attr,\n                                           stack_size);\n          if (0 == res)\n              res = pthread_create (&(thread->handle),\n                                    &attr,\n                                    start_routine,\n                                    arg);\n          pthread_attr_destroy (&attr);\n        }\n    }\n  else\n    res = pthread_create (&(thread->handle),\n                          NULL,\n                          start_routine,\n                          arg);\n\n  if (0 != res)\n    errno = res;\n\n  return !res;\n#elif defined(MHD_USE_W32_THREADS)\n#if SIZE_MAX != UINT_MAX\n  if (stack_size > UINT_MAX)\n    {\n      errno = EINVAL;\n      return 0;\n    }\n#endif /* SIZE_MAX != UINT_MAX */\n\n  thread->handle = (MHD_thread_handle_)\n                     _beginthreadex (NULL,\n                                     (unsigned int) stack_size,\n                                     start_routine,\n                                     arg,\n                                     0,\n                                     NULL);\n\n  if ((MHD_thread_handle_)-1 == thread->handle)\n    return 0;\n\n  return !0;\n#endif\n}",
      "lines": 58,
      "depth": 16,
      "decorators": [
        "int"
      ]
    },
    "named_thread_starter": {
      "start_point": [
        257,
        0
      ],
      "end_point": [
        275,
        1
      ],
      "content": "static MHD_THRD_RTRN_TYPE_ MHD_THRD_CALL_SPEC_\nnamed_thread_starter (void *data)\n{\n  struct MHD_named_helper_param_ * const param =\n      (struct MHD_named_helper_param_ *) data;\n  void * arg;\n  MHD_THREAD_START_ROUTINE_ thr_func;\n\n  if (NULL == data)\n    return (MHD_THRD_RTRN_TYPE_)0;\n\n  MHD_set_cur_thread_name_ (param->name);\n\n  arg = param->arg;\n  thr_func = param->start_routine;\n  free(data);\n\n  return thr_func(arg);\n}",
      "lines": 19,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "MHD_THRD_RTRN_TYPE_",
        "MHD_THRD_CALL_SPEC_",
        "MHD_THRD_CALL_SPEC_"
      ]
    },
    "MHD_create_named_thread_": {
      "start_point": [
        289,
        0
      ],
      "end_point": [
        360,
        1
      ],
      "content": "int\nMHD_create_named_thread_ (MHD_thread_handle_ID_ *thread,\n                          const char* thread_name,\n                          size_t stack_size,\n                          MHD_THREAD_START_ROUTINE_ start_routine,\n                          void *arg)\n{\n#if defined(MHD_USE_THREAD_ATTR_SETNAME)\n  int res;\n  pthread_attr_t attr;\n\n  res = pthread_attr_init (&attr);\n  if (0 == res)\n    {\n#if defined(HAVE_PTHREAD_ATTR_SETNAME_NP_NETBSD)\n  /* NetBSD use 3 arguments: second argument is string in printf-like format,\n   *                         third argument is single argument for printf;\n   * OSF1 use 3 arguments too, but last one always must be zero (NULL).\n   * MHD doesn't use '%' in thread names, so both form are used in same way.\n   */\n      res = pthread_attr_setname_np (&attr, thread_name, 0);\n#elif defined(HAVE_PTHREAD_ATTR_SETNAME_NP_IBMI)\n      res = pthread_attr_setname_np (&attr, thread_name);\n#else\n#error No pthread_attr_setname_np() function.\n#endif\n      if (res == 0 && 0 != stack_size)\n        res = pthread_attr_setstacksize (&attr,\n                                         stack_size);\n      if (0 == res)\n          res = pthread_create (&(thread->handle),\n                                &attr,\n                                start_routine,\n                                arg);\n      pthread_attr_destroy (&attr);\n    }\n  if (0 != res)\n    errno = res;\n\n  return !res;\n#else  /* ! MHD_USE_THREAD_ATTR_SETNAME */\n  struct MHD_named_helper_param_ *param;\n\n  if (NULL == thread_name)\n    {\n      errno = EINVAL;\n      return 0;\n    }\n\n  param = malloc (sizeof (struct MHD_named_helper_param_));\n  if (NULL == param)\n    return 0;\n\n  param->start_routine = start_routine;\n  param->arg = arg;\n  param->name = thread_name;\n\n  /* Set thread name in thread itself to avoid problems with\n   * threads which terminated before name is set in other thread.\n   */\n  if (! MHD_create_thread_(thread,\n                           stack_size,\n                           &named_thread_starter,\n                           (void*)param))\n    {\n      free (param);\n      return 0;\n    }\n\n  return !0;\n#endif /* ! MHD_USE_THREAD_ATTR_SETNAME */\n}",
      "lines": 72,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/microhttpd/mhd_threads.h": {},
  "libmicrohttpd/libmicrohttpd-0.9.59/src/microhttpd/postprocessor.c": {
    "MHD_create_post_processor": {
      "start_point": [
        272,
        0
      ],
      "end_point": [
        340,
        1
      ],
      "content": "struct MHD_PostProcessor *\nMHD_create_post_processor (struct MHD_Connection *connection,\n                           size_t buffer_size,\n                           MHD_PostDataIterator iter,\n                           void *iter_cls)\n{\n  struct MHD_PostProcessor *ret;\n  const char *encoding;\n  const char *boundary;\n  size_t blen;\n\n  if ( (buffer_size < 256) ||\n       (NULL == connection) ||\n       (NULL == iter))\n    mhd_panic (mhd_panic_cls,\n               __FILE__,\n               __LINE__,\n               NULL);\n  encoding = MHD_lookup_connection_value (connection,\n                                          MHD_HEADER_KIND,\n                                          MHD_HTTP_HEADER_CONTENT_TYPE);\n  if (NULL == encoding)\n    return NULL;\n  boundary = NULL;\n  if (! MHD_str_equal_caseless_n_ (MHD_HTTP_POST_ENCODING_FORM_URLENCODED,\n                                   encoding,\n                                   MHD_STATICSTR_LEN_ (MHD_HTTP_POST_ENCODING_FORM_URLENCODED)))\n    {\n      if (! MHD_str_equal_caseless_n_ (MHD_HTTP_POST_ENCODING_MULTIPART_FORMDATA,\n                                       encoding,\n                                       MHD_STATICSTR_LEN_ (MHD_HTTP_POST_ENCODING_MULTIPART_FORMDATA)))\n        return NULL;\n      boundary =\n        &encoding[MHD_STATICSTR_LEN_ (MHD_HTTP_POST_ENCODING_MULTIPART_FORMDATA)];\n      /* Q: should this be \"strcasestr\"? */\n      boundary = strstr (boundary, \"boundary=\");\n      if (NULL == boundary)\n\treturn NULL; /* failed to determine boundary */\n      boundary += MHD_STATICSTR_LEN_ (\"boundary=\");\n      blen = strlen (boundary);\n      if ( (blen == 0) ||\n           (blen * 2 + 2 > buffer_size) )\n        return NULL;            /* (will be) out of memory or invalid boundary */\n      if ( (boundary[0] == '\"') &&\n           (boundary[blen - 1] == '\"') )\n\t{\n\t  /* remove enclosing quotes */\n\t  ++boundary;\n\t  blen -= 2;\n\t}\n    }\n  else\n    blen = 0;\n  buffer_size += 4; /* round up to get nice block sizes despite boundary search */\n\n  /* add +1 to ensure we ALWAYS have a zero-termination at the end */\n  if (NULL == (ret = MHD_calloc_ (1, sizeof (struct MHD_PostProcessor) + buffer_size + 1)))\n    return NULL;\n  ret->connection = connection;\n  ret->ikvi = iter;\n  ret->cls = iter_cls;\n  ret->encoding = encoding;\n  ret->buffer_size = buffer_size;\n  ret->state = PP_Init;\n  ret->blen = blen;\n  ret->boundary = boundary;\n  ret->skip_rn = RN_Inactive;\n  return ret;\n}",
      "lines": 69,
      "depth": 15,
      "decorators": [
        "struct MHD_PostProcessor",
        "struct",
        "MHD_PostProcessor",
        "*\nMHD_create_post_processor (struct MHD_Connection *connection,\n                           size_t buffer_size,\n                           MHD_PostDataIterator iter,\n                           void *iter_cls)",
        "*"
      ]
    },
    "post_process_urlencoded": {
      "start_point": [
        351,
        0
      ],
      "end_point": [
        512,
        1
      ],
      "content": "static int\npost_process_urlencoded (struct MHD_PostProcessor *pp,\n                         const char *post_data,\n\t\t\t size_t post_data_len)\n{\n  size_t equals;\n  size_t amper;\n  size_t poff;\n  size_t xoff;\n  size_t delta;\n  int end_of_value_found;\n  char *buf;\n  char xbuf[XBUF_SIZE + 1];\n\n  buf = (char *) &pp[1];\n  poff = 0;\n  while (poff < post_data_len)\n    {\n      switch (pp->state)\n        {\n        case PP_Error:\n          return MHD_NO;\n        case PP_Done:\n          /* did not expect to receive more data */\n          pp->state = PP_Error;\n          return MHD_NO;\n        case PP_Init:\n          equals = 0;\n          while ((equals + poff < post_data_len) &&\n                 (post_data[equals + poff] != '='))\n            equals++;\n          if (equals + pp->buffer_pos > pp->buffer_size)\n            {\n              pp->state = PP_Error;     /* out of memory */\n              return MHD_NO;\n            }\n          memcpy (&buf[pp->buffer_pos], &post_data[poff], equals);\n          pp->buffer_pos += equals;\n          if (equals + poff == post_data_len)\n            return MHD_YES;     /* no '=' yet */\n          buf[pp->buffer_pos] = '\\0';   /* 0-terminate key */\n          pp->buffer_pos = 0;   /* reset for next key */\n\t  MHD_unescape_plus (buf);\n          MHD_http_unescape (buf);\n          poff += equals + 1;\n          pp->state = PP_ProcessValue;\n          pp->value_offset = 0;\n          break;\n        case PP_ProcessValue:\n          /* obtain rest of value from previous iteration */\n          memcpy (xbuf, pp->xbuf, pp->xbuf_pos);\n          xoff = pp->xbuf_pos;\n          pp->xbuf_pos = 0;\n\n          /* find last position in input buffer that is part of the value */\n          amper = 0;\n          while ((amper + poff < post_data_len) &&\n                 (amper < XBUF_SIZE) &&\n                 (post_data[amper + poff] != '&') &&\n                 (post_data[amper + poff] != '\\n') &&\n                 (post_data[amper + poff] != '\\r'))\n            amper++;\n          end_of_value_found = ((amper + poff < post_data_len) &&\n                                ((post_data[amper + poff] == '&') ||\n                                 (post_data[amper + poff] == '\\n') ||\n                                 (post_data[amper + poff] == '\\r')));\n          /* compute delta, the maximum number of bytes that we will be able to\n             process right now (either amper-limited of xbuf-size limited) */\n          delta = amper;\n          if (delta > XBUF_SIZE - xoff)\n            delta = XBUF_SIZE - xoff;\n\n          /* move input into processing buffer */\n          memcpy (&xbuf[xoff], &post_data[poff], delta);\n          xoff += delta;\n          poff += delta;\n\n          /* find if escape sequence is at the end of the processing buffer;\n             if so, exclude those from processing (reduce delta to point at\n             end of processed region) */\n          delta = xoff;\n          if ((delta > 0) &&\n              ('%' == xbuf[delta - 1]))\n            delta--;\n          else if ((delta > 1) &&\n                   ('%' == xbuf[delta - 2]))\n            delta -= 2;\n\n          /* if we have an incomplete escape sequence, save it to\n             pp->xbuf for later */\n          if (delta < xoff)\n            {\n              memcpy (pp->xbuf,\n                      &xbuf[delta],\n                      xoff - delta);\n              pp->xbuf_pos = xoff - delta;\n              xoff = delta;\n            }\n\n          /* If we have nothing to do (delta == 0) and\n             not just because the value is empty (are\n             waiting for more data), go for next iteration */\n          if ( (0 == xoff) &&\n               (poff == post_data_len))\n            continue;\n\n          /* unescape */\n          xbuf[xoff] = '\\0';    /* 0-terminate in preparation */\n\t  MHD_unescape_plus (xbuf);\n          xoff = MHD_http_unescape (xbuf);\n          /* finally: call application! */\n\t  pp->must_ikvi = MHD_NO;\n          if (MHD_NO == pp->ikvi (pp->cls,\n                                  MHD_POSTDATA_KIND,\n                                  (const char *) &pp[1],    /* key */\n                                  NULL,\n                                  NULL,\n                                  NULL,\n                                  xbuf,\n                                  pp->value_offset,\n                                  xoff))\n            {\n              pp->state = PP_Error;\n              return MHD_NO;\n            }\n          pp->value_offset += xoff;\n\n          /* are we done with the value? */\n          if (end_of_value_found)\n            {\n              /* we found the end of the value! */\n              if ( ('\\n' == post_data[poff]) ||\n                   ('\\r' == post_data[poff]) )\n                {\n                  pp->state = PP_ExpectNewLine;\n                }\n              else if ('&' == post_data[poff])\n                {\n                  poff++;       /* skip '&' */\n                  pp->state = PP_Init;\n                }\n            }\n          break;\n        case PP_ExpectNewLine:\n          if ( ('\\n' == post_data[poff]) ||\n               ('\\r' == post_data[poff]) )\n            {\n              poff++;\n              /* we are done, report error if we receive any more... */\n              pp->state = PP_Done;\n              return MHD_YES;\n            }\n          return MHD_NO;\n        default:\n          mhd_panic (mhd_panic_cls,\n                     __FILE__,\n                     __LINE__,\n                     NULL);          /* should never happen! */\n        }\n    }\n  return MHD_YES;\n}",
      "lines": 162,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "try_match_header": {
      "start_point": [
        524,
        0
      ],
      "end_point": [
        543,
        1
      ],
      "content": "static int\ntry_match_header (const char *prefix,\n                  char *line,\n                  char **suffix)\n{\n  if (NULL != *suffix)\n    return MHD_NO;\n  while (0 != *line)\n    {\n      if (MHD_str_equal_caseless_n_ (prefix,\n                                     line,\n                                     strlen (prefix)))\n        {\n          *suffix = strdup (&line[strlen (prefix)]);\n          return MHD_YES;\n        }\n      ++line;\n    }\n  return MHD_NO;\n}",
      "lines": 20,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "find_boundary": {
      "start_point": [
        559,
        0
      ],
      "end_point": [
        612,
        1
      ],
      "content": "static int\nfind_boundary (struct MHD_PostProcessor *pp,\n               const char *boundary,\n               size_t blen,\n               size_t *ioffptr,\n               enum PP_State next_state,\n               enum PP_State next_dash_state)\n{\n  char *buf = (char *) &pp[1];\n  const char *dash;\n\n  if (pp->buffer_pos < 2 + blen)\n    {\n      if (pp->buffer_pos == pp->buffer_size)\n        pp->state = PP_Error;   /* out of memory */\n      /* ++(*ioffptr); */\n      return MHD_NO;            /* not enough data */\n    }\n  if ( (0 != memcmp (\"--\",\n                     buf,\n                     2)) ||\n       (0 != memcmp (&buf[2],\n                     boundary,\n                     blen)))\n    {\n      if (pp->state != PP_Init)\n        {\n          /* garbage not allowed */\n          pp->state = PP_Error;\n        }\n      else\n        {\n          /* skip over garbage (RFC 2046, 5.1.1) */\n          dash = memchr (buf,\n                         '-',\n                         pp->buffer_pos);\n          if (NULL == dash)\n            (*ioffptr) += pp->buffer_pos; /* skip entire buffer */\n          else\n            if (dash == buf)\n              (*ioffptr)++; /* at least skip one byte */\n            else\n              (*ioffptr) += dash - buf; /* skip to first possible boundary */\n        }\n      return MHD_NO;            /* expected boundary */\n    }\n  /* remove boundary from buffer */\n  (*ioffptr) += 2 + blen;\n  /* next: start with headers */\n  pp->skip_rn = RN_Dash;\n  pp->state = next_state;\n  pp->dash_state = next_dash_state;\n  return MHD_YES;\n}",
      "lines": 54,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "try_get_value": {
      "start_point": [
        621,
        0
      ],
      "end_point": [
        661,
        1
      ],
      "content": "static void\ntry_get_value (const char *buf,\n\t       const char *key,\n\t       char **destination)\n{\n  const char *spos;\n  const char *bpos;\n  const char *endv;\n  size_t klen;\n  size_t vlen;\n\n  if (NULL != *destination)\n    return;\n  bpos = buf;\n  klen = strlen (key);\n  while (NULL != (spos = strstr (bpos, key)))\n    {\n      if ( (spos[klen] != '=') ||\n           ( (spos != buf) &&\n             (spos[-1] != ' ') ) )\n        {\n          /* no match */\n          bpos = spos + 1;\n          continue;\n        }\n      if (spos[klen + 1] != '\"')\n        return;                 /* not quoted */\n      if (NULL == (endv = strchr (&spos[klen + 2],\n                                  '\\\"')))\n        return;                 /* no end-quote */\n      vlen = endv - spos - klen - 1;\n      *destination = malloc (vlen);\n      if (NULL == *destination)\n        return;                 /* out of memory */\n      (*destination)[vlen - 1] = '\\0';\n      memcpy (*destination,\n              &spos[klen + 2],\n              vlen - 1);\n      return;                   /* success */\n    }\n}",
      "lines": 41,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "process_multipart_headers": {
      "start_point": [
        679,
        0
      ],
      "end_point": [
        732,
        1
      ],
      "content": "static int\nprocess_multipart_headers (struct MHD_PostProcessor *pp,\n                           size_t *ioffptr,\n                           enum PP_State next_state)\n{\n  char *buf = (char *) &pp[1];\n  size_t newline;\n\n  newline = 0;\n  while ( (newline < pp->buffer_pos) &&\n          (buf[newline] != '\\r') &&\n          (buf[newline] != '\\n') )\n    newline++;\n  if (newline == pp->buffer_size)\n    {\n      pp->state = PP_Error;\n      return MHD_NO;            /* out of memory */\n    }\n  if (newline == pp->buffer_pos)\n    return MHD_NO;              /* will need more data */\n  if (0 == newline)\n    {\n      /* empty line - end of headers */\n      pp->skip_rn = RN_Full;\n      pp->state = next_state;\n      return MHD_YES;\n    }\n  /* got an actual header */\n  if (buf[newline] == '\\r')\n    pp->skip_rn = RN_OptN;\n  buf[newline] = '\\0';\n  if (MHD_str_equal_caseless_n_ (\"Content-disposition: \",\n                                 buf,\n                                 MHD_STATICSTR_LEN_ (\"Content-disposition: \")))\n    {\n      try_get_value (&buf[MHD_STATICSTR_LEN_ (\"Content-disposition: \")],\n                     \"name\",\n                     &pp->content_name);\n      try_get_value (&buf[MHD_STATICSTR_LEN_ (\"Content-disposition: \")],\n                     \"filename\",\n                     &pp->content_filename);\n    }\n  else\n    {\n      try_match_header (\"Content-type: \",\n                        buf,\n                        &pp->content_type);\n      try_match_header (\"Content-Transfer-Encoding: \",\n                        buf,\n                        &pp->content_transfer_encoding);\n    }\n  (*ioffptr) += newline + 1;\n  return MHD_YES;\n}",
      "lines": 54,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "process_value_to_boundary": {
      "start_point": [
        751,
        0
      ],
      "end_point": [
        844,
        1
      ],
      "content": "static int\nprocess_value_to_boundary (struct MHD_PostProcessor *pp,\n                           size_t *ioffptr,\n                           const char *boundary,\n                           size_t blen,\n                           enum PP_State next_state,\n                           enum PP_State next_dash_state)\n{\n  char *buf = (char *) &pp[1];\n  size_t newline;\n  const char *r;\n\n  /* all data in buf until the boundary\n     (\\r\\n--+boundary) is part of the value */\n  newline = 0;\n  while (1)\n    {\n      while (newline + 4 < pp->buffer_pos)\n        {\n          r = memchr (&buf[newline],\n                      '\\r',\n                      pp->buffer_pos - newline - 4);\n          if (NULL == r)\n          {\n            newline = pp->buffer_pos - 4;\n            break;\n          }\n          newline = r - buf;\n          if (0 == memcmp (\"\\r\\n--\",\n                           &buf[newline],\n                           4))\n            break;\n          newline++;\n        }\n      if (newline + blen + 4 <= pp->buffer_pos)\n        {\n          /* can check boundary */\n          if (0 != memcmp (&buf[newline + 4],\n                           boundary,\n                           blen))\n            {\n              /* no boundary, \"\\r\\n--\" is part of content, skip */\n              newline += 4;\n              continue;\n            }\n          else\n            {\n              /* boundary found, process until newline then\n                 skip boundary and go back to init */\n              pp->skip_rn = RN_Dash;\n              pp->state = next_state;\n              pp->dash_state = next_dash_state;\n              (*ioffptr) += blen + 4;       /* skip boundary as well */\n              buf[newline] = '\\0';\n              break;\n            }\n        }\n      else\n        {\n          /* cannot check for boundary, process content that\n             we have and check again later; except, if we have\n             no content, abort (out of memory) */\n          if ( (0 == newline) &&\n               (pp->buffer_pos == pp->buffer_size) )\n            {\n              pp->state = PP_Error;\n              return MHD_NO;\n            }\n          break;\n        }\n    }\n  /* newline is either at beginning of boundary or\n     at least at the last character that we are sure\n     is not part of the boundary */\n  if ( ( (MHD_YES == pp->must_ikvi) ||\n\t (0 != newline) ) &&\n       (MHD_NO == pp->ikvi (pp->cls,\n\t\t\t    MHD_POSTDATA_KIND,\n\t\t\t    pp->content_name,\n\t\t\t    pp->content_filename,\n\t\t\t    pp->content_type,\n\t\t\t    pp->content_transfer_encoding,\n\t\t\t    buf,\n                            pp->value_offset,\n                            newline)) )\n    {\n      pp->state = PP_Error;\n      return MHD_NO;\n    }\n  pp->must_ikvi = MHD_NO;\n  pp->value_offset += newline;\n  (*ioffptr) += newline;\n  return MHD_YES;\n}",
      "lines": 94,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "free_unmarked": {
      "start_point": [
        851,
        0
      ],
      "end_point": [
        878,
        1
      ],
      "content": "static void\nfree_unmarked (struct MHD_PostProcessor *pp)\n{\n  if ( (NULL != pp->content_name) &&\n       (0 == (pp->have & NE_content_name)) )\n    {\n      free (pp->content_name);\n      pp->content_name = NULL;\n    }\n  if ( (NULL != pp->content_type) &&\n       (0 == (pp->have & NE_content_type)) )\n    {\n      free (pp->content_type);\n      pp->content_type = NULL;\n    }\n  if ( (NULL != pp->content_filename) &&\n       (0 == (pp->have & NE_content_filename)) )\n    {\n      free (pp->content_filename);\n      pp->content_filename = NULL;\n    }\n  if ( (NULL != pp->content_transfer_encoding) &&\n       (0 == (pp->have & NE_content_transfer_encoding)) )\n    {\n      free (pp->content_transfer_encoding);\n      pp->content_transfer_encoding = NULL;\n    }\n}",
      "lines": 28,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "post_process_multipart": {
      "start_point": [
        889,
        0
      ],
      "end_point": [
        1196,
        1
      ],
      "content": "static int\npost_process_multipart (struct MHD_PostProcessor *pp,\n                        const char *post_data,\n\t\t\tsize_t post_data_len)\n{\n  char *buf;\n  size_t max;\n  size_t ioff;\n  size_t poff;\n  int state_changed;\n\n  buf = (char *) &pp[1];\n  ioff = 0;\n  poff = 0;\n  state_changed = 1;\n  while ( (poff < post_data_len) ||\n          ( (pp->buffer_pos > 0) &&\n            (0 != state_changed) ) )\n    {\n      /* first, move as much input data\n         as possible to our internal buffer */\n      max = pp->buffer_size - pp->buffer_pos;\n      if (max > post_data_len - poff)\n        max = post_data_len - poff;\n      memcpy (&buf[pp->buffer_pos],\n              &post_data[poff],\n              max);\n      poff += max;\n      pp->buffer_pos += max;\n      if ( (0 == max) &&\n           (0 == state_changed) &&\n           (poff < post_data_len) )\n        {\n          pp->state = PP_Error;\n          return MHD_NO;        /* out of memory */\n        }\n      state_changed = 0;\n\n      /* first state machine for '\\r'-'\\n' and '--' handling */\n      switch (pp->skip_rn)\n        {\n        case RN_Inactive:\n          break;\n        case RN_OptN:\n          if (buf[0] == '\\n')\n            {\n              ioff++;\n              pp->skip_rn = RN_Inactive;\n              goto AGAIN;\n            }\n          /* fall-through! */\n        case RN_Dash:\n          if (buf[0] == '-')\n            {\n              ioff++;\n              pp->skip_rn = RN_Dash2;\n              goto AGAIN;\n            }\n          pp->skip_rn = RN_Full;\n          /* fall-through! */\n        case RN_Full:\n          if (buf[0] == '\\r')\n            {\n              if ( (pp->buffer_pos > 1) &&\n                   ('\\n' == buf[1]) )\n                {\n                  pp->skip_rn = RN_Inactive;\n                  ioff += 2;\n                }\n              else\n                {\n                  pp->skip_rn = RN_OptN;\n                  ioff++;\n                }\n              goto AGAIN;\n            }\n          if (buf[0] == '\\n')\n            {\n              ioff++;\n              pp->skip_rn = RN_Inactive;\n              goto AGAIN;\n            }\n          pp->skip_rn = RN_Inactive;\n          pp->state = PP_Error;\n          return MHD_NO;        /* no '\\r\\n' */\n        case RN_Dash2:\n          if (buf[0] == '-')\n            {\n              ioff++;\n              pp->skip_rn = RN_Full;\n              pp->state = pp->dash_state;\n              goto AGAIN;\n            }\n          pp->state = PP_Error;\n          break;\n        }\n\n      /* main state engine */\n      switch (pp->state)\n        {\n        case PP_Error:\n          return MHD_NO;\n        case PP_Done:\n          /* did not expect to receive more data */\n          pp->state = PP_Error;\n          return MHD_NO;\n        case PP_Init:\n          /**\n           * Per RFC2046 5.1.1 NOTE TO IMPLEMENTORS, consume anything\n           * prior to the first multipart boundary:\n           *\n           * > There appears to be room for additional information prior\n           * > to the first boundary delimiter line and following the\n           * > final boundary delimiter line.  These areas should\n           * > generally be left blank, and implementations must ignore\n           * > anything that appears before the first boundary delimiter\n           * > line or after the last one.\n           */\n          (void) find_boundary (pp,\n\t\t\t\tpp->boundary,\n\t\t\t\tpp->blen,\n\t\t\t\t&ioff,\n\t\t\t\tPP_ProcessEntryHeaders,\n                                PP_Done);\n          break;\n        case PP_NextBoundary:\n          if (MHD_NO == find_boundary (pp,\n                                       pp->boundary,\n                                       pp->blen,\n                                       &ioff,\n                                       PP_ProcessEntryHeaders,\n                                       PP_Done))\n            {\n              if (pp->state == PP_Error)\n                return MHD_NO;\n              goto END;\n            }\n          break;\n        case PP_ProcessEntryHeaders:\n\t  pp->must_ikvi = MHD_YES;\n          if (MHD_NO ==\n              process_multipart_headers (pp,\n                                         &ioff,\n                                         PP_PerformCheckMultipart))\n            {\n              if (pp->state == PP_Error)\n                return MHD_NO;\n              else\n                goto END;\n            }\n          state_changed = 1;\n          break;\n        case PP_PerformCheckMultipart:\n          if ( (NULL != pp->content_type) &&\n               (MHD_str_equal_caseless_n_ (pp->content_type,\n                                           \"multipart/mixed\",\n                                           MHD_STATICSTR_LEN_ (\"multipart/mixed\"))))\n            {\n              pp->nested_boundary = strstr (pp->content_type,\n                                            \"boundary=\");\n              if (NULL == pp->nested_boundary)\n                {\n                  pp->state = PP_Error;\n                  return MHD_NO;\n                }\n              pp->nested_boundary =\n                strdup (&pp->nested_boundary[MHD_STATICSTR_LEN_ (\"boundary=\")]);\n              if (NULL == pp->nested_boundary)\n                {\n                  /* out of memory */\n                  pp->state = PP_Error;\n                  return MHD_NO;\n                }\n              /* free old content type, we will need that field\n                 for the content type of the nested elements */\n              free (pp->content_type);\n              pp->content_type = NULL;\n              pp->nlen = strlen (pp->nested_boundary);\n              pp->state = PP_Nested_Init;\n              state_changed = 1;\n              break;\n            }\n          pp->state = PP_ProcessValueToBoundary;\n          pp->value_offset = 0;\n          state_changed = 1;\n          break;\n        case PP_ProcessValueToBoundary:\n          if (MHD_NO == process_value_to_boundary (pp,\n                                                   &ioff,\n                                                   pp->boundary,\n                                                   pp->blen,\n                                                   PP_PerformCleanup,\n                                                   PP_Done))\n            {\n              if (pp->state == PP_Error)\n                return MHD_NO;\n              break;\n            }\n          break;\n        case PP_PerformCleanup:\n          /* clean up state of one multipart form-data element! */\n          pp->have = NE_none;\n          free_unmarked (pp);\n          if (NULL != pp->nested_boundary)\n            {\n              free (pp->nested_boundary);\n              pp->nested_boundary = NULL;\n            }\n          pp->state = PP_ProcessEntryHeaders;\n          state_changed = 1;\n          break;\n        case PP_Nested_Init:\n          if (NULL == pp->nested_boundary)\n            {\n              pp->state = PP_Error;\n              return MHD_NO;\n            }\n          if (MHD_NO == find_boundary (pp,\n                                       pp->nested_boundary,\n                                       pp->nlen,\n                                       &ioff,\n                                       PP_Nested_PerformMarking,\n                                       PP_NextBoundary /* or PP_Error? */ ))\n            {\n              if (pp->state == PP_Error)\n                return MHD_NO;\n              goto END;\n            }\n          break;\n        case PP_Nested_PerformMarking:\n          /* remember what headers were given\n             globally */\n          pp->have = NE_none;\n          if (NULL != pp->content_name)\n            pp->have |= NE_content_name;\n          if (NULL != pp->content_type)\n            pp->have |= NE_content_type;\n          if (NULL != pp->content_filename)\n            pp->have |= NE_content_filename;\n          if (NULL != pp->content_transfer_encoding)\n            pp->have |= NE_content_transfer_encoding;\n          pp->state = PP_Nested_ProcessEntryHeaders;\n          state_changed = 1;\n          break;\n        case PP_Nested_ProcessEntryHeaders:\n          pp->value_offset = 0;\n          if (MHD_NO ==\n              process_multipart_headers (pp,\n                                         &ioff,\n                                         PP_Nested_ProcessValueToBoundary))\n            {\n              if (pp->state == PP_Error)\n                return MHD_NO;\n              else\n                goto END;\n            }\n          state_changed = 1;\n          break;\n        case PP_Nested_ProcessValueToBoundary:\n          if (MHD_NO == process_value_to_boundary (pp,\n                                                   &ioff,\n                                                   pp->nested_boundary,\n                                                   pp->nlen,\n                                                   PP_Nested_PerformCleanup,\n                                                   PP_NextBoundary))\n            {\n              if (pp->state == PP_Error)\n                return MHD_NO;\n              break;\n            }\n          break;\n        case PP_Nested_PerformCleanup:\n          free_unmarked (pp);\n          pp->state = PP_Nested_ProcessEntryHeaders;\n          state_changed = 1;\n          break;\n        default:\n          mhd_panic (mhd_panic_cls,\n                     __FILE__,\n                     __LINE__,\n                     NULL);          /* should never happen! */\n        }\n    AGAIN:\n      if (ioff > 0)\n        {\n          memmove (buf,\n                   &buf[ioff],\n                   pp->buffer_pos - ioff);\n          pp->buffer_pos -= ioff;\n          ioff = 0;\n          state_changed = 1;\n        }\n    }\nEND:\n  if (0 != ioff)\n    {\n      memmove (buf,\n               &buf[ioff],\n               pp->buffer_pos - ioff);\n      pp->buffer_pos -= ioff;\n    }\n  if (poff < post_data_len)\n    {\n      pp->state = PP_Error;\n      return MHD_NO;            /* serious error */\n    }\n  return MHD_YES;\n}",
      "lines": 308,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "MHD_post_process": {
      "start_point": [
        1212,
        0
      ],
      "end_point": [
        1235,
        1
      ],
      "content": "int\nMHD_post_process (struct MHD_PostProcessor *pp,\n                  const char *post_data,\n                  size_t post_data_len)\n{\n  if (0 == post_data_len)\n    return MHD_YES;\n  if (NULL == pp)\n    return MHD_NO;\n  if (MHD_str_equal_caseless_n_ (MHD_HTTP_POST_ENCODING_FORM_URLENCODED,\n                                 pp->encoding,\n                                 MHD_STATICSTR_LEN_(MHD_HTTP_POST_ENCODING_FORM_URLENCODED)))\n    return post_process_urlencoded (pp,\n                                    post_data,\n                                    post_data_len);\n  if (MHD_str_equal_caseless_n_ (MHD_HTTP_POST_ENCODING_MULTIPART_FORMDATA,\n                                 pp->encoding,\n                                 MHD_STATICSTR_LEN_ (MHD_HTTP_POST_ENCODING_MULTIPART_FORMDATA)))\n    return post_process_multipart (pp,\n                                   post_data,\n                                   post_data_len);\n  /* this should never be reached */\n  return MHD_NO;\n}",
      "lines": 24,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "MHD_destroy_post_processor": {
      "start_point": [
        1248,
        0
      ],
      "end_point": [
        1279,
        1
      ],
      "content": "int\nMHD_destroy_post_processor (struct MHD_PostProcessor *pp)\n{\n  int ret;\n\n  if (NULL == pp)\n    return MHD_YES;\n  if (PP_ProcessValue == pp->state)\n  {\n    /* key without terminated value left at the end of the\n       buffer; fake receiving a termination character to\n       ensure it is also processed */\n    post_process_urlencoded (pp,\n                             \"\\n\",\n                             1);\n  }\n  /* These internal strings need cleaning up since\n     the post-processing may have been interrupted\n     at any stage */\n  if ( (pp->xbuf_pos > 0) ||\n       ( (pp->state != PP_Done) &&\n         (pp->state != PP_ExpectNewLine) ) )\n    ret = MHD_NO;\n  else\n    ret = MHD_YES;\n  pp->have = NE_none;\n  free_unmarked (pp);\n  if (NULL != pp->nested_boundary)\n    free (pp->nested_boundary);\n  free (pp);\n  return ret;\n}",
      "lines": 32,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/microhttpd/reason_phrase.c": {
    "MHD_get_reason_phrase_for": {
      "start_point": [
        174,
        0
      ],
      "end_point": [
        182,
        1
      ],
      "content": "const char *\nMHD_get_reason_phrase_for (unsigned int code)\n{\n  if ( (code >= 100) &&\n       (code < 600) &&\n       (reasons[code / 100].max > (code % 100)) )\n    return reasons[code / 100].data[code % 100];\n  return \"Unknown\";\n}",
      "lines": 9,
      "depth": 11,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nMHD_get_reason_phrase_for (unsigned int code)",
        "*"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/microhttpd/response.c": {
    "add_response_entry": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        104,
        1
      ],
      "content": "static int\nadd_response_entry (struct MHD_Response *response,\n\t\t    enum MHD_ValueKind kind,\n\t\t    const char *header,\n\t\t    const char *content)\n{\n  struct MHD_HTTP_Header *hdr;\n\n  if ( (NULL == response) ||\n       (NULL == header) ||\n       (NULL == content) ||\n       (0 == header[0]) ||\n       (0 == content[0]) ||\n       (NULL != strchr (header, '\\t')) ||\n       (NULL != strchr (header, '\\r')) ||\n       (NULL != strchr (header, '\\n')) ||\n       (NULL != strchr (content, '\\t')) ||\n       (NULL != strchr (content, '\\r')) ||\n       (NULL != strchr (content, '\\n')) )\n    return MHD_NO;\n  if (NULL == (hdr = malloc (sizeof (struct MHD_HTTP_Header))))\n    return MHD_NO;\n  if (NULL == (hdr->header = strdup (header)))\n    {\n      free (hdr);\n      return MHD_NO;\n    }\n  if (NULL == (hdr->value = strdup (content)))\n    {\n      free (hdr->header);\n      free (hdr);\n      return MHD_NO;\n    }\n  hdr->kind = kind;\n  hdr->next = response->first_header;\n  response->first_header = hdr;\n  return MHD_YES;\n}",
      "lines": 38,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "MHD_add_response_header": {
      "start_point": [
        116,
        0
      ],
      "end_point": [
        125,
        1
      ],
      "content": "int\nMHD_add_response_header (struct MHD_Response *response,\n                         const char *header,\n                         const char *content)\n{\n  return add_response_entry (response,\n\t\t\t     MHD_HEADER_KIND,\n\t\t\t     header,\n\t\t\t     content);\n}",
      "lines": 10,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "MHD_add_response_footer": {
      "start_point": [
        137,
        0
      ],
      "end_point": [
        146,
        1
      ],
      "content": "int\nMHD_add_response_footer (struct MHD_Response *response,\n                         const char *footer,\n                         const char *content)\n{\n  return add_response_entry (response,\n\t\t\t     MHD_FOOTER_KIND,\n\t\t\t     footer,\n\t\t\t     content);\n}",
      "lines": 10,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "MHD_del_response_header": {
      "start_point": [
        158,
        0
      ],
      "end_point": [
        191,
        1
      ],
      "content": "int\nMHD_del_response_header (struct MHD_Response *response,\n                         const char *header,\n\t\t\t const char *content)\n{\n  struct MHD_HTTP_Header *pos;\n  struct MHD_HTTP_Header *prev;\n\n  if ( (NULL == header) ||\n  (NULL == content) )\n    return MHD_NO;\n  prev = NULL;\n  pos = response->first_header;\n  while (NULL != pos)\n    {\n      if ((0 == strcmp (header,\n                        pos->header)) &&\n          (0 == strcmp (content,\n                        pos->value)))\n        {\n          free (pos->header);\n          free (pos->value);\n          if (NULL == prev)\n            response->first_header = pos->next;\n          else\n            prev->next = pos->next;\n          free (pos);\n          return MHD_YES;\n        }\n      prev = pos;\n      pos = pos->next;\n    }\n  return MHD_NO;\n}",
      "lines": 34,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "MHD_get_response_headers": {
      "start_point": [
        204,
        0
      ],
      "end_point": [
        225,
        1
      ],
      "content": "int\nMHD_get_response_headers (struct MHD_Response *response,\n                          MHD_KeyValueIterator iterator,\n                          void *iterator_cls)\n{\n  int numHeaders = 0;\n  struct MHD_HTTP_Header *pos;\n\n  for (pos = response->first_header;\n       NULL != pos;\n       pos = pos->next)\n    {\n      numHeaders++;\n      if ((NULL != iterator) &&\n          (MHD_YES != iterator (iterator_cls,\n                                pos->kind,\n                                pos->header,\n                                pos->value)))\n        break;\n    }\n  return numHeaders;\n}",
      "lines": 22,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "MHD_get_response_header": {
      "start_point": [
        236,
        0
      ],
      "end_point": [
        252,
        1
      ],
      "content": "const char *\nMHD_get_response_header (struct MHD_Response *response,\n\t\t\t const char *key)\n{\n  struct MHD_HTTP_Header *pos;\n\n  if (NULL == key)\n    return NULL;\n  for (pos = response->first_header;\n       NULL != pos;\n       pos = pos->next)\n    {\n      if ( MHD_str_equal_caseless_ (pos->header, key) )\n        return pos->value;\n    }\n  return NULL;\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nMHD_get_response_header (struct MHD_Response *response,\n\t\t\t const char *key)",
        "*"
      ]
    },
    "MHD_check_response_header_token_ci": {
      "start_point": [
        268,
        0
      ],
      "end_point": [
        295,
        1
      ],
      "content": "bool\nMHD_check_response_header_token_ci (const struct MHD_Response *response,\n                                    const char *key,\n                                    const char *token,\n                                    size_t token_len)\n{\n  struct MHD_HTTP_Header *pos;\n\n  if ( (NULL == key) ||\n       ('\\0' == key[0]) ||\n       (NULL == token) ||\n       ('\\0' == token[0]) )\n    return false;\n\n  for (pos = response->first_header;\n       NULL != pos;\n       pos = pos->next)\n    {\n      if ( (pos->kind == MHD_HEADER_KIND) &&\n           MHD_str_equal_caseless_ (pos->header,\n                                    key) &&\n           MHD_str_has_token_caseless_ (pos->value,\n                                        token,\n                                        token_len) )\n        return true;\n    }\n  return false;\n}",
      "lines": 28,
      "depth": 12,
      "decorators": [
        "bool"
      ]
    },
    "MHD_create_response_from_callback": {
      "start_point": [
        314,
        0
      ],
      "end_point": [
        341,
        1
      ],
      "content": "struct MHD_Response *\nMHD_create_response_from_callback (uint64_t size,\n                                   size_t block_size,\n                                   MHD_ContentReaderCallback crc,\n                                   void *crc_cls,\n                                   MHD_ContentReaderFreeCallback crfc)\n{\n  struct MHD_Response *response;\n\n  if ((NULL == crc) || (0 == block_size))\n    return NULL;\n  if (NULL == (response = MHD_calloc_ (1, sizeof (struct MHD_Response) + block_size)))\n    return NULL;\n  response->fd = -1;\n  response->data = (void *) &response[1];\n  response->data_buffer_size = block_size;\n  if (! MHD_mutex_init_ (&response->mutex))\n  {\n    free (response);\n    return NULL;\n  }\n  response->crc = crc;\n  response->crfc = crfc;\n  response->crc_cls = crc_cls;\n  response->reference_count = 1;\n  response->total_size = size;\n  return response;\n}",
      "lines": 28,
      "depth": 14,
      "decorators": [
        "struct MHD_Response",
        "struct",
        "MHD_Response",
        "*\nMHD_create_response_from_callback (uint64_t size,\n                                   size_t block_size,\n                                   MHD_ContentReaderCallback crc,\n                                   void *crc_cls,\n                                   MHD_ContentReaderFreeCallback crfc)",
        "*"
      ]
    },
    "MHD_set_response_options": {
      "start_point": [
        352,
        0
      ],
      "end_point": [
        375,
        1
      ],
      "content": "int\nMHD_set_response_options (struct MHD_Response *response,\n                          enum MHD_ResponseFlags flags,\n                          ...)\n{\n  va_list ap;\n  int ret;\n  enum MHD_ResponseOptions ro;\n\n  ret = MHD_YES;\n  response->flags = flags;\n  va_start (ap, flags);\n  while (MHD_RO_END != (ro = va_arg (ap, enum MHD_ResponseOptions)))\n  {\n    switch (ro)\n    {\n    default:\n      ret = MHD_NO;\n      break;\n    }\n  }\n  va_end (ap);\n  return ret;\n}",
      "lines": 24,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "file_reader": {
      "start_point": [
        388,
        0
      ],
      "end_point": [
        463,
        1
      ],
      "content": "static ssize_t\nfile_reader (void *cls,\n             uint64_t pos,\n             char *buf,\n             size_t max)\n{\n  struct MHD_Response *response = cls;\n#if !defined(_WIN32) || defined(__CYGWIN__)\n  ssize_t n;\n#else  /* _WIN32 && !__CYGWIN__ */\n  const HANDLE fh = (HANDLE) _get_osfhandle (response->fd);\n#endif /* _WIN32 && !__CYGWIN__ */\n  const int64_t offset64 = (int64_t)(pos + response->fd_off);\n\n  if (offset64 < 0)\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* seek to required position is not possible */\n\n#if !defined(_WIN32) || defined(__CYGWIN__)\n  if (max > SSIZE_MAX)\n    max = SSIZE_MAX; /* Clamp to maximum return value. */\n\n#if defined(HAVE_PREAD64)\n  n = pread64(response->fd, buf, max, offset64);\n#elif defined(HAVE_PREAD)\n  if ( (sizeof(off_t) < sizeof (uint64_t)) &&\n       (offset64 > (uint64_t)INT32_MAX) )\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* Read at required position is not possible. */\n\n  n = pread(response->fd, buf, max, (off_t) offset64);\n#else  /* ! HAVE_PREAD */\n#if defined(HAVE_LSEEK64)\n  if (lseek64 (response->fd,\n               offset64,\n               SEEK_SET) != offset64)\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* can't seek to required position */\n#else  /* ! HAVE_LSEEK64 */\n  if ( (sizeof(off_t) < sizeof (uint64_t)) &&\n       (offset64 > (uint64_t)INT32_MAX) )\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* seek to required position is not possible */\n\n  if (lseek (response->fd,\n             (off_t) offset64,\n             SEEK_SET) != (off_t) offset64)\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* can't seek to required position */\n#endif /* ! HAVE_LSEEK64 */\n  n = read (response->fd,\n            buf,\n            max);\n\n#endif /* ! HAVE_PREAD */\n  if (0 == n)\n    return MHD_CONTENT_READER_END_OF_STREAM;\n  if (n < 0)\n    return MHD_CONTENT_READER_END_WITH_ERROR;\n  return n;\n#else /* _WIN32 && !__CYGWIN__ */\n  if (INVALID_HANDLE_VALUE == fh)\n    return MHD_CONTENT_READER_END_WITH_ERROR; /* Value of 'response->fd' is not valid. */\n  else\n    {\n      OVERLAPPED f_ol = {0, 0, {{0, 0}}, 0}; /* Initialize to zero. */\n      ULARGE_INTEGER pos_uli;\n      DWORD toRead = (max > INT32_MAX) ? INT32_MAX : (DWORD) max;\n      DWORD resRead;\n\n      pos_uli.QuadPart = (uint64_t) offset64; /* Simple transformation 64bit -> 2x32bit. */\n      f_ol.Offset = pos_uli.LowPart;\n      f_ol.OffsetHigh = pos_uli.HighPart;\n      if (! ReadFile(fh, (void*)buf, toRead, &resRead, &f_ol))\n        return MHD_CONTENT_READER_END_WITH_ERROR; /* Read error. */\n      if (0 == resRead)\n        return MHD_CONTENT_READER_END_OF_STREAM;\n      return (ssize_t) resRead;\n    }\n#endif /* _WIN32 && !__CYGWIN__ */\n}",
      "lines": 76,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "ssize_t"
      ]
    },
    "free_callback": {
      "start_point": [
        472,
        0
      ],
      "end_point": [
        479,
        1
      ],
      "content": "static void\nfree_callback (void *cls)\n{\n  struct MHD_Response *response = cls;\n\n  (void) close (response->fd);\n  response->fd = -1;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "MHD_create_response_from_fd_at_offset": {
      "start_point": [
        499,
        0
      ],
      "end_point": [
        507,
        1
      ],
      "content": "struct MHD_Response *\nMHD_create_response_from_fd_at_offset (size_t size,\n\t\t\t\t       int fd,\n\t\t\t\t       off_t offset)\n{\n  return MHD_create_response_from_fd_at_offset64 (size,\n                                                  fd,\n                                                  offset);\n}",
      "lines": 9,
      "depth": 6,
      "decorators": [
        "struct MHD_Response",
        "struct",
        "MHD_Response",
        "*\nMHD_create_response_from_fd_at_offset (size_t size,\n\t\t\t\t       int fd,\n\t\t\t\t       off_t offset)",
        "*"
      ]
    },
    "MHD_create_response_from_fd_at_offset64": {
      "start_point": [
        526,
        19
      ],
      "end_point": [
        556,
        1
      ],
      "content": "MHD_Response *\nMHD_create_response_from_fd_at_offset64 (uint64_t size,\n                                         int fd,\n                                         uint64_t offset)\n{\n  struct MHD_Response *response;\n\n#if !defined(HAVE___LSEEKI64) && !defined(HAVE_LSEEK64)\n  if ( (sizeof(uint64_t) > sizeof(off_t)) &&\n       ( (size > (uint64_t)INT32_MAX) ||\n         (offset > (uint64_t)INT32_MAX) ||\n         ((size + offset) >= (uint64_t)INT32_MAX) ) )\n    return NULL;\n#endif\n  if ( ((int64_t)size < 0) ||\n       ((int64_t)offset < 0) ||\n       ((int64_t)(size + offset) < 0) )\n    return NULL;\n\n  response = MHD_create_response_from_callback (size,\n\t\t\t\t\t\t4 * 1024,\n\t\t\t\t\t\t&file_reader,\n\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t&free_callback);\n  if (NULL == response)\n    return NULL;\n  response->fd = fd;\n  response->fd_off = offset;\n  response->crc_cls = response;\n  return response;\n}",
      "lines": 31,
      "depth": 14,
      "decorators": [
        "MHD_Response",
        "*\nMHD_create_response_from_fd_at_offset64 (uint64_t size,\n                                         int fd,\n                                         uint64_t offset)",
        "*"
      ]
    },
    "MHD_create_response_from_fd": {
      "start_point": [
        568,
        0
      ],
      "end_point": [
        575,
        1
      ],
      "content": "struct MHD_Response *\nMHD_create_response_from_fd (size_t size,\n\t\t\t     int fd)\n{\n  return MHD_create_response_from_fd_at_offset64 (size,\n                                                  fd,\n                                                  0);\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "struct MHD_Response",
        "struct",
        "MHD_Response",
        "*\nMHD_create_response_from_fd (size_t size,\n\t\t\t     int fd)",
        "*"
      ]
    },
    "MHD_create_response_from_fd64": {
      "start_point": [
        591,
        19
      ],
      "end_point": [
        598,
        1
      ],
      "content": "MHD_Response *\nMHD_create_response_from_fd64 (uint64_t size,\n                               int fd)\n{\n  return MHD_create_response_from_fd_at_offset64 (size,\n                                                  fd,\n                                                  0);\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "MHD_Response",
        "*\nMHD_create_response_from_fd64 (uint64_t size,\n                               int fd)",
        "*"
      ]
    },
    "MHD_create_response_from_data": {
      "start_point": [
        615,
        0
      ],
      "end_point": [
        656,
        1
      ],
      "content": "struct MHD_Response *\nMHD_create_response_from_data (size_t size,\n                               void *data,\n                               int must_free,\n                               int must_copy)\n{\n  struct MHD_Response *response;\n  void *tmp;\n\n  if ((NULL == data) && (size > 0))\n    return NULL;\n  if (NULL == (response = MHD_calloc_ (1, sizeof (struct MHD_Response))))\n    return NULL;\n  response->fd = -1;\n  if (! MHD_mutex_init_ (&response->mutex))\n    {\n      free (response);\n      return NULL;\n    }\n  if ((must_copy) && (size > 0))\n    {\n      if (NULL == (tmp = malloc (size)))\n        {\n          MHD_mutex_destroy_chk_ (&response->mutex);\n          free (response);\n          return NULL;\n        }\n      memcpy (tmp, data, size);\n      must_free = MHD_YES;\n      data = tmp;\n    }\n  if (must_free)\n    {\n      response->crfc = &free;\n      response->crc_cls = data;\n    }\n  response->reference_count = 1;\n  response->total_size = size;\n  response->data = data;\n  response->data_size = size;\n  return response;\n}",
      "lines": 42,
      "depth": 13,
      "decorators": [
        "struct MHD_Response",
        "struct",
        "MHD_Response",
        "*\nMHD_create_response_from_data (size_t size,\n                               void *data,\n                               int must_free,\n                               int must_copy)",
        "*"
      ]
    },
    "MHD_create_response_from_buffer": {
      "start_point": [
        669,
        0
      ],
      "end_point": [
        678,
        1
      ],
      "content": "struct MHD_Response *\nMHD_create_response_from_buffer (size_t size,\n\t\t\t\t void *buffer,\n\t\t\t\t enum MHD_ResponseMemoryMode mode)\n{\n  return MHD_create_response_from_data (size,\n\t\t\t\t\tbuffer,\n\t\t\t\t\tmode == MHD_RESPMEM_MUST_FREE,\n\t\t\t\t\tmode == MHD_RESPMEM_MUST_COPY);\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "struct MHD_Response",
        "struct",
        "MHD_Response",
        "*\nMHD_create_response_from_buffer (size_t size,\n\t\t\t\t void *buffer,\n\t\t\t\t enum MHD_ResponseMemoryMode mode)",
        "*"
      ]
    },
    "MHD_upgrade_action": {
      "start_point": [
        694,
        0
      ],
      "end_point": [
        740,
        1
      ],
      "content": "_MHD_EXTERN int\nMHD_upgrade_action (struct MHD_UpgradeResponseHandle *urh,\n                    enum MHD_UpgradeAction action,\n                    ...)\n{\n  struct MHD_Connection *connection;\n  struct MHD_Daemon *daemon;\n\n  if (NULL == urh)\n    return MHD_NO;\n  connection = urh->connection;\n\n  /* Precaution checks on external data. */\n  if (NULL == connection)\n    return MHD_NO;\n  daemon = connection->daemon;\n  if (NULL == daemon)\n    return MHD_NO;\n\n  switch (action)\n  {\n  case MHD_UPGRADE_ACTION_CLOSE:\n    if (urh->was_closed)\n      return MHD_NO; /* Already closed. */\n\n    /* transition to special 'closed' state for start of cleanup */\n#ifdef HTTPS_SUPPORT\n    if (0 != (daemon->options & MHD_USE_TLS) )\n      {\n        /* signal that app is done by shutdown() of 'app' socket */\n        /* Application will not use anyway this socket after this command. */\n        shutdown (urh->app.socket,\n                  SHUT_RDWR);\n      }\n#endif /* HTTPS_SUPPORT */\n    mhd_assert (MHD_CONNECTION_UPGRADE == connection->state);\n    urh->was_closed = true;\n    /* As soon as connection will be marked with BOTH\n     * 'urh->was_closed' AND 'urh->clean_ready', it will\n     * be moved to cleanup list by MHD_resume_connection(). */\n    MHD_resume_connection (connection);\n    return MHD_YES;\n  default:\n    /* we don't understand this one */\n    return MHD_NO;\n  }\n}",
      "lines": 47,
      "depth": 13,
      "decorators": [
        "_MHD_EXTERN",
        "int",
        "int"
      ]
    },
    "MHD_response_execute_upgrade_": {
      "start_point": [
        756,
        0
      ],
      "end_point": [
        993,
        1
      ],
      "content": "int\nMHD_response_execute_upgrade_ (struct MHD_Response *response,\n                               struct MHD_Connection *connection)\n{\n  struct MHD_Daemon *daemon = connection->daemon;\n  struct MHD_UpgradeResponseHandle *urh;\n  size_t rbo;\n\n  if (0 == (daemon->options & MHD_ALLOW_UPGRADE))\n    return MHD_NO;\n\n  if (NULL ==\n      MHD_get_response_header (response,\n                               MHD_HTTP_HEADER_UPGRADE))\n    {\n#ifdef HAVE_MESSAGES\n      MHD_DLOG (daemon,\n                _(\"Invalid response for upgrade: application failed to set the 'Upgrade' header!\\n\"));\n#endif\n      return MHD_NO;\n    }\n\n  urh = MHD_calloc_ (1, sizeof (struct MHD_UpgradeResponseHandle));\n  if (NULL == urh)\n    return MHD_NO;\n  urh->connection = connection;\n  rbo = connection->read_buffer_offset;\n  connection->read_buffer_offset = 0;\n#ifdef HTTPS_SUPPORT\n  if (0 != (daemon->options & MHD_USE_TLS) )\n  {\n    struct MemoryPool *pool;\n    size_t avail;\n    char *buf;\n    MHD_socket sv[2];\n#if defined(MHD_socket_nosignal_) || !defined(MHD_socket_pair_nblk_)\n    int res1;\n    int res2;\n#endif /* MHD_socket_nosignal_ || !MHD_socket_pair_nblk_ */\n\n#ifdef MHD_socket_pair_nblk_\n    if (! MHD_socket_pair_nblk_ (sv))\n      {\n        free (urh);\n        return MHD_NO;\n      }\n#else  /* !MHD_socket_pair_nblk_ */\n    if (! MHD_socket_pair_ (sv))\n      {\n        free (urh);\n        return MHD_NO;\n      }\n    res1 = MHD_socket_nonblocking_(sv[0]);\n    res2 = MHD_socket_nonblocking_(sv[1]);\n    if ( (! res1) || (! res2) )\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n\t\t  _(\"Failed to make loopback sockets non-blocking.\\n\"));\n#endif\n        if (! res2)\n          {\n            /* Socketpair cannot be used. */\n            MHD_socket_close_chk_ (sv[0]);\n            MHD_socket_close_chk_ (sv[1]);\n            free (urh);\n            return MHD_NO;\n          }\n      }\n#endif /* !MHD_socket_pair_nblk_ */\n#ifdef MHD_socket_nosignal_\n    res1 = MHD_socket_nosignal_(sv[0]);\n    res2 = MHD_socket_nosignal_(sv[1]);\n    if ( (! res1) || (! res2) )\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _(\"Failed to set SO_NOSIGPIPE on loopback sockets.\\n\"));\n#endif\n#ifndef MSG_NOSIGNAL\n        if (!res2)\n          {\n            /* Socketpair cannot be used. */\n            MHD_socket_close_chk_ (sv[0]);\n            MHD_socket_close_chk_ (sv[1]);\n            free (urh);\n            return MHD_NO;\n          }\n#endif /* ! MSG_NOSIGNAL */\n      }\n#endif /* MHD_socket_nosignal_ */\n    if ( (! MHD_SCKT_FD_FITS_FDSET_ (sv[1],\n                                     NULL)) &&\n         (0 == (daemon->options & (MHD_USE_POLL | MHD_USE_EPOLL))) )\n      {\n#ifdef HAVE_MESSAGES\n        MHD_DLOG (daemon,\n                  _(\"Socketpair descriptor larger than FD_SETSIZE: %d > %d\\n\"),\n                  (int) sv[1],\n                  (int) FD_SETSIZE);\n#endif\n        MHD_socket_close_chk_ (sv[0]);\n        MHD_socket_close_chk_ (sv[1]);\n        free (urh);\n        return MHD_NO;\n      }\n    urh->app.socket = sv[0];\n    urh->app.urh = urh;\n    urh->app.celi = MHD_EPOLL_STATE_UNREADY;\n    urh->mhd.socket = sv[1];\n    urh->mhd.urh = urh;\n    urh->mhd.celi = MHD_EPOLL_STATE_UNREADY;\n    pool = connection->pool;\n    avail = MHD_pool_get_free (pool);\n    if (avail < RESERVE_EBUF_SIZE)\n      {\n        /* connection's pool is totally at the limit,\n           use our 'emergency' buffer of #RESERVE_EBUF_SIZE bytes. */\n        avail = RESERVE_EBUF_SIZE;\n        buf = urh->e_buf;\n      }\n    else\n      {\n        /* Normal case: grab all remaining memory from the\n           connection's pool for the IO buffers; the connection\n           certainly won't need it anymore as we've upgraded\n           to another protocol. */\n        buf = MHD_pool_allocate (pool,\n                                 avail,\n                                 MHD_NO);\n      }\n    /* use half the buffer for inbound, half for outbound */\n    urh->in_buffer_size = avail / 2;\n    urh->out_buffer_size = avail - urh->in_buffer_size;\n    urh->in_buffer = buf;\n    urh->out_buffer = &buf[urh->in_buffer_size];\n#ifdef EPOLL_SUPPORT\n    /* Launch IO processing by the event loop */\n    if (0 != (daemon->options & MHD_USE_EPOLL))\n      {\n        /* We're running with epoll(), need to add the sockets\n           to the event set of the daemon's `epoll_upgrade_fd` */\n        struct epoll_event event;\n\n        mhd_assert (-1 != daemon->epoll_upgrade_fd);\n        /* First, add network socket */\n        event.events = EPOLLIN | EPOLLOUT | EPOLLPRI | EPOLLET;\n        event.data.ptr = &urh->app;\n        if (0 != epoll_ctl (daemon->epoll_upgrade_fd,\n                            EPOLL_CTL_ADD,\n                            connection->socket_fd,\n                            &event))\n\t{\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (daemon,\n                    _(\"Call to epoll_ctl failed: %s\\n\"),\n                    MHD_socket_last_strerr_ ());\n#endif\n          MHD_socket_close_chk_ (sv[0]);\n          MHD_socket_close_chk_ (sv[1]);\n          free (urh);\n          return MHD_NO;\n\t}\n\n        /* Second, add our end of the UNIX socketpair() */\n        event.events = EPOLLIN | EPOLLOUT | EPOLLPRI | EPOLLET;\n        event.data.ptr = &urh->mhd;\n        if (0 != epoll_ctl (daemon->epoll_upgrade_fd,\n                            EPOLL_CTL_ADD,\n                            urh->mhd.socket,\n                            &event))\n\t{\n          event.events = EPOLLIN | EPOLLOUT | EPOLLPRI;\n          event.data.ptr = &urh->app;\n          if (0 != epoll_ctl (daemon->epoll_upgrade_fd,\n                              EPOLL_CTL_DEL,\n                              connection->socket_fd,\n                              &event))\n            MHD_PANIC (_(\"Error cleaning up while handling epoll error\"));\n#ifdef HAVE_MESSAGES\n          MHD_DLOG (daemon,\n                    _(\"Call to epoll_ctl failed: %s\\n\"),\n                    MHD_socket_last_strerr_ ());\n#endif\n          MHD_socket_close_chk_ (sv[0]);\n          MHD_socket_close_chk_ (sv[1]);\n          free (urh);\n          return MHD_NO;\n\t}\n\tEDLL_insert (daemon->eready_urh_head,\n\t\t     daemon->eready_urh_tail,\n\t\t     urh);\n\turh->in_eready_list = true;\n      }\n#endif /* EPOLL_SUPPORT */\n    if (0 == (daemon->options & MHD_USE_THREAD_PER_CONNECTION) )\n      {\n        /* This takes care of further processing for most event loops:\n           simply add to DLL for bi-direcitonal processing */\n        DLL_insert (daemon->urh_head,\n                    daemon->urh_tail,\n                    urh);\n      }\n    /* In thread-per-connection mode, thread will switch to forwarding once\n     * connection.urh is not NULL and connection.state == MHD_CONNECTION_UPGRADE.\n     */\n  }\n  else\n    {\n      urh->app.socket = MHD_INVALID_SOCKET;\n      urh->mhd.socket = MHD_INVALID_SOCKET;\n      /* Non-TLS connection do not hold any additional resources. */\n      urh->clean_ready = true;\n    }\n#else  /* ! HTTPS_SUPPORT */\n  urh->clean_ready = true;\n#endif /* ! HTTPS_SUPPORT */\n  connection->urh = urh;\n  /* As far as MHD's event loops are concerned, this connection is\n     suspended; it will be resumed once application is done by the\n     #MHD_upgrade_action() function */\n  internal_suspend_connection_ (connection);\n\n  /* hand over socket to application */\n  response->upgrade_handler (response->upgrade_handler_cls,\n                             connection,\n                             connection->client_context,\n                             connection->read_buffer,\n                             rbo,\n#ifdef HTTPS_SUPPORT\n                             (0 == (daemon->options & MHD_USE_TLS) ) ?\n                             connection->socket_fd : urh->app.socket,\n#else  /* ! HTTPS_SUPPORT */\n                             connection->socket_fd,\n#endif /* ! HTTPS_SUPPORT */\n                             urh);\n  return MHD_YES;\n}",
      "lines": 238,
      "depth": 18,
      "decorators": [
        "int"
      ]
    },
    "MHD_create_response_for_upgrade": {
      "start_point": [
        1025,
        19
      ],
      "end_point": [
        1054,
        1
      ],
      "content": "MHD_Response *\nMHD_create_response_for_upgrade (MHD_UpgradeHandler upgrade_handler,\n\t\t\t\t void *upgrade_handler_cls)\n{\n  struct MHD_Response *response;\n\n  if (NULL == upgrade_handler)\n    return NULL; /* invalid request */\n  response = MHD_calloc_ (1, sizeof (struct MHD_Response));\n  if (NULL == response)\n    return NULL;\n  if (! MHD_mutex_init_ (&response->mutex))\n    {\n      free (response);\n      return NULL;\n    }\n  response->upgrade_handler = upgrade_handler;\n  response->upgrade_handler_cls = upgrade_handler_cls;\n  response->total_size = MHD_SIZE_UNKNOWN;\n  response->reference_count = 1;\n  if (MHD_NO ==\n      MHD_add_response_header (response,\n                               MHD_HTTP_HEADER_CONNECTION,\n                               \"Upgrade\"))\n    {\n      MHD_destroy_response (response);\n      return NULL;\n    }\n  return response;\n}",
      "lines": 30,
      "depth": 10,
      "decorators": [
        "MHD_Response",
        "*\nMHD_create_response_for_upgrade (MHD_UpgradeHandler upgrade_handler,\n\t\t\t\t void *upgrade_handler_cls)",
        "*"
      ]
    },
    "MHD_destroy_response": {
      "start_point": [
        1067,
        0
      ],
      "end_point": [
        1093,
        1
      ],
      "content": "void\nMHD_destroy_response (struct MHD_Response *response)\n{\n  struct MHD_HTTP_Header *pos;\n\n  if (NULL == response)\n    return;\n  MHD_mutex_lock_chk_ (&response->mutex);\n  if (0 != --(response->reference_count))\n    {\n      MHD_mutex_unlock_chk_ (&response->mutex);\n      return;\n    }\n  MHD_mutex_unlock_chk_ (&response->mutex);\n  MHD_mutex_destroy_chk_ (&response->mutex);\n  if (NULL != response->crfc)\n    response->crfc (response->crc_cls);\n  while (NULL != response->first_header)\n    {\n      pos = response->first_header;\n      response->first_header = pos->next;\n      free (pos->header);\n      free (pos->value);\n      free (pos);\n    }\n  free (response);\n}",
      "lines": 27,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "MHD_increment_response_rc": {
      "start_point": [
        1101,
        0
      ],
      "end_point": [
        1107,
        1
      ],
      "content": "void\nMHD_increment_response_rc (struct MHD_Response *response)\n{\n  MHD_mutex_lock_chk_ (&response->mutex);\n  (response->reference_count)++;\n  MHD_mutex_unlock_chk_ (&response->mutex);\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/microhttpd/response.h": {},
  "libmicrohttpd/libmicrohttpd-0.9.59/src/microhttpd/sysfdsetsize.c": {
    "get_system_fdsetsize_value": {
      "start_point": [
        75,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "int\nget_system_fdsetsize_value (void)\n{\n  return FD_SETSIZE;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/microhttpd/sysfdsetsize.h": {},
  "libmicrohttpd/libmicrohttpd-0.9.59/src/microhttpd/test_daemon.c": {
    "testStartError": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "static int\ntestStartError ()\n{\n  struct MHD_Daemon *d;\n\n  d = MHD_start_daemon (MHD_USE_ERROR_LOG, 0, NULL, NULL, NULL, NULL);\n  if (NULL != d)\n  {\n    MHD_stop_daemon (d);\n    fprintf (stderr,\n             \"Succeeded to start without MHD_AccessHandlerCallback?\\n\");\n    return 1;\n  }\n  return 0;\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "apc_nothing": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "static int\napc_nothing (void *cls,\n             const struct sockaddr *addr,\n             socklen_t addrlen)\n{\n  (void)cls; (void)addr; (void)addrlen; /* Unused. Silent compiler warning. */\n\n  return MHD_NO;\n}",
      "lines": 9,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "apc_all": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        73,
        1
      ],
      "content": "static int\napc_all (void *cls,\n         const struct sockaddr *addr,\n         socklen_t addrlen)\n{\n  (void)cls; (void)addr; (void)addrlen; /* Unused. Silent compiler warning. */\n\n  return MHD_YES;\n}",
      "lines": 9,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "ahc_nothing": {
      "start_point": [
        76,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "static int\nahc_nothing (void *cls,\n             struct MHD_Connection *connection,\n             const char *url,\n             const char *method,\n             const char *version,\n             const char *upload_data, size_t *upload_data_size,\n             void **unused)\n{\n  (void)cls;(void)connection;(void)url;          /* Unused. Silent compiler warning. */\n  (void)method;(void)version;(void)upload_data;  /* Unused. Silent compiler warning. */\n  (void)upload_data_size;(void)unused;           /* Unused. Silent compiler warning. */\n\n  return MHD_NO;\n}",
      "lines": 15,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testStartStop": {
      "start_point": [
        93,
        0
      ],
      "end_point": [
        112,
        1
      ],
      "content": "static int\ntestStartStop ()\n{\n  struct MHD_Daemon *d;\n\n  d = MHD_start_daemon (MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_ERROR_LOG,\n                        0,\n                        &apc_nothing, NULL,\n                        &ahc_nothing, NULL,\n                        MHD_OPTION_END);\n  if (NULL == d)\n  {\n    fprintf (stderr,\n             \"Failed to start daemon on port %u\\n\",\n             0);\n    exit (77);\n  }\n  MHD_stop_daemon (d);\n  return 0;\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testExternalRun": {
      "start_point": [
        115,
        0
      ],
      "end_point": [
        159,
        1
      ],
      "content": "static int\ntestExternalRun ()\n{\n  struct MHD_Daemon *d;\n  fd_set rs;\n  MHD_socket maxfd;\n  int i;\n\n  d = MHD_start_daemon (MHD_USE_ERROR_LOG,\n                        0,\n                        &apc_all, NULL,\n                        &ahc_nothing, NULL,\n                        MHD_OPTION_END);\n\n  if (NULL == d)\n  {\n    fprintf (stderr,\n             \"Failed to start daemon on port %u\\n\",\n             0);\n    exit (77);\n  }\n  i = 0;\n  while (i < 15)\n    {\n      maxfd = 0;\n      FD_ZERO (&rs);\n      if (MHD_YES != MHD_get_fdset (d, &rs, &rs, &rs, &maxfd))\n        {\n          MHD_stop_daemon (d);\n          fprintf (stderr,\n                   \"Failed in MHD_get_fdset()\\n\");\n          return 256;\n        }\n      if (MHD_run (d) == MHD_NO)\n        {\n          MHD_stop_daemon (d);\n          fprintf (stderr,\n                   \"Failed in MHD_run()\\n\");\n          return 8;\n        }\n      i++;\n    }\n  MHD_stop_daemon (d);\n  return 0;\n}",
      "lines": 45,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testThread": {
      "start_point": [
        162,
        0
      ],
      "end_point": [
        188,
        1
      ],
      "content": "static int\ntestThread ()\n{\n  struct MHD_Daemon *d;\n\n  d = MHD_start_daemon (MHD_USE_ERROR_LOG | MHD_USE_INTERNAL_POLLING_THREAD,\n                        0,\n                        &apc_all, NULL,\n                        &ahc_nothing, NULL,\n                        MHD_OPTION_END);\n\n  if (NULL == d)\n  {\n    fprintf (stderr,\n             \"Failed to start daemon on port %u\\n\",\n             1082);\n    exit (77);\n  }\n  if (MHD_run (d) != MHD_NO)\n    {\n      fprintf (stderr,\n               \"Failed in MHD_run()\\n\");\n      return 32;\n    }\n  MHD_stop_daemon (d);\n  return 0;\n}",
      "lines": 27,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testMultithread": {
      "start_point": [
        191,
        0
      ],
      "end_point": [
        217,
        1
      ],
      "content": "static int\ntestMultithread ()\n{\n  struct MHD_Daemon *d;\n\n  d = MHD_start_daemon (MHD_USE_ERROR_LOG | MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_THREAD_PER_CONNECTION,\n                        0,\n                        &apc_all, NULL,\n                        &ahc_nothing, NULL,\n                        MHD_OPTION_END);\n\n  if (NULL == d)\n  {\n    fprintf (stderr,\n             \"Failed to start daemon on port %u\\n\",\n             0);\n    exit (77);\n  }\n  if (MHD_run (d) != MHD_NO)\n    {\n      fprintf (stderr,\n               \"Failed in MHD_run()\\n\");\n      return 128;\n    }\n  MHD_stop_daemon (d);\n  return 0;\n}",
      "lines": 27,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        220,
        0
      ],
      "end_point": [
        237,
        1
      ],
      "content": "int\nmain (int argc,\n      char *const *argv)\n{\n  int errorCount = 0;\n  (void)argc; (void)argv; /* Unused. Silent compiler warning. */\n\n  errorCount += testStartError ();\n  errorCount += testStartStop ();\n  errorCount += testExternalRun ();\n  errorCount += testThread ();\n  errorCount += testMultithread ();\n  if (0 != errorCount)\n    fprintf (stderr,\n             \"Error (code: %u)\\n\",\n             errorCount);\n  return 0 != errorCount;       /* 0 == pass */\n}",
      "lines": 18,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/microhttpd/test_helpers.h": {
    "has_in_name": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "static int\nhas_in_name(const char *prog_name, const char *marker)\n{\n  size_t name_pos;\n  size_t pos;\n\n  if (!prog_name || !marker || !prog_name[0] || !marker[0])\n    return 0;\n\n  pos = 0;\n  name_pos = 0;\n  while (prog_name[pos])\n    {\n      if ('/' == prog_name[pos])\n        name_pos = pos + 1;\n#if defined(_WIN32) || defined(__CYGWIN__)\n      else if ('\\\\' == prog_name[pos])\n        name_pos = pos + 1;\n#endif /* _WIN32 || __CYGWIN__ */\n      pos++;\n    }\n  if (name_pos == pos)\n    return 0;\n  return strstr(prog_name + name_pos, marker) != (char*)0;\n}",
      "lines": 25,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "has_param": {
      "start_point": [
        76,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "static int\nhas_param(int argc, char * const argv[], const char * param)\n{\n  int i;\n  if (!argv || !param || !param[0])\n    return 0;\n\n  for(i = 1; i < argc; i++)\n    {\n      if(argv[i] && strcmp(argv[i], param) == 0)\n        return !0;\n    }\n\n  return 0;\n}",
      "lines": 15,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/microhttpd/test_http_reasons.c": {
    "expect_result": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "static int expect_result(int code, const char* expected)\n{\n  const char* const reason = MHD_get_reason_phrase_for(code);\n  if (MHD_str_equal_caseless_(reason, expected))\n    return 0;\n  fprintf(stderr, \"Incorrect reason returned for code %d:\\n  Returned: \\\"%s\\\"  \\tExpected: \\\"%s\\\"\\n\",\n          code, reason, expected);\n  return 1;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "expect_absent": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "static int expect_absent(int code)\n{\n  return expect_result(code, \"unknown\");\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "test_absent_codes": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "static int test_absent_codes(void)\n{\n  int errcount = 0;\n  errcount += expect_absent(0);\n  errcount += expect_absent(1);\n  errcount += expect_absent(50);\n  errcount += expect_absent(99);\n  errcount += expect_absent(600);\n  errcount += expect_absent(601);\n  errcount += expect_absent(900);\n  errcount += expect_absent(10000);\n  return errcount;\n}",
      "lines": 13,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "test_1xx": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "static int test_1xx(void)\n{\n  int errcount = 0;\n  errcount += expect_result(MHD_HTTP_CONTINUE, \"continue\");\n  errcount += expect_result(MHD_HTTP_PROCESSING, \"processing\");\n  errcount += expect_absent(110);\n  errcount += expect_absent(190);\n  return errcount;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "test_2xx": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "static int test_2xx(void)\n{\n  int errcount = 0;\n  errcount += expect_result(MHD_HTTP_OK, \"ok\");\n  errcount += expect_result(MHD_HTTP_ALREADY_REPORTED, \"already reported\");\n  errcount += expect_absent(217);\n  errcount += expect_result(MHD_HTTP_IM_USED, \"im used\");\n  errcount += expect_absent(230);\n  errcount += expect_absent(295);\n  return errcount;\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "test_3xx": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "static int test_3xx(void)\n{\n  int errcount = 0;\n  errcount += expect_result(MHD_HTTP_MULTIPLE_CHOICES, \"multiple choices\");\n  errcount += expect_result(MHD_HTTP_SEE_OTHER, \"see other\");\n  errcount += expect_result(MHD_HTTP_PERMANENT_REDIRECT, \"permanent redirect\");\n  errcount += expect_absent(311);\n  errcount += expect_absent(399);\n  return errcount;\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "test_4xx": {
      "start_point": [
        92,
        0
      ],
      "end_point": [
        106,
        1
      ],
      "content": "static int test_4xx(void)\n{\n  int errcount = 0;\n  errcount += expect_result(MHD_HTTP_BAD_REQUEST, \"bad request\");\n  errcount += expect_result(MHD_HTTP_NOT_FOUND, \"not found\");\n  errcount += expect_result(MHD_HTTP_URI_TOO_LONG, \"uri too long\");\n  errcount += expect_result(MHD_HTTP_EXPECTATION_FAILED, \"expectation failed\");\n  errcount += expect_result(MHD_HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE, \"request header fields too large\");\n  errcount += expect_absent(441);\n  errcount += expect_result(MHD_HTTP_NO_RESPONSE, \"no response\");\n  errcount += expect_result(MHD_HTTP_UNAVAILABLE_FOR_LEGAL_REASONS, \"unavailable for legal reasons\");\n  errcount += expect_absent(470);\n  errcount += expect_absent(493);\n  return errcount;\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "test_5xx": {
      "start_point": [
        108,
        0
      ],
      "end_point": [
        118,
        1
      ],
      "content": "static int test_5xx(void)\n{\n  int errcount = 0;\n  errcount += expect_result(MHD_HTTP_INTERNAL_SERVER_ERROR, \"internal server error\");\n  errcount += expect_result(MHD_HTTP_BAD_GATEWAY, \"bad gateway\");\n  errcount += expect_result(MHD_HTTP_HTTP_VERSION_NOT_SUPPORTED, \"http version not supported\");\n  errcount += expect_result(MHD_HTTP_NETWORK_AUTHENTICATION_REQUIRED, \"network authentication required\");\n  errcount += expect_absent(520);\n  errcount += expect_absent(597);\n  return errcount;\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        120,
        0
      ],
      "end_point": [
        132,
        1
      ],
      "content": "int main(int argc, char * argv[])\n{\n  int errcount = 0;\n  (void)argc; (void)argv; /* Unused. Silent compiler warning. */\n\n  errcount += test_absent_codes();\n  errcount += test_1xx();\n  errcount += test_2xx();\n  errcount += test_3xx();\n  errcount += test_4xx();\n  errcount += test_5xx();\n  return errcount == 0 ? 0 : 1;\n}",
      "lines": 13,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/microhttpd/test_options.c": {
    "ahc_echo": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "static int\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data, size_t *upload_data_size,\n          void **unused)\n{\n  (void)cls;\n  (void)connection;\n  (void)url;\n  (void)method;\n  (void)version;\n  (void)upload_data;\n  (void)upload_data_size;\n  (void)unused;\n\n  return 0;\n}",
      "lines": 20,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "test_wrap_loc": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "static int\ntest_wrap_loc (char *test_name, int (*test) (void))\n{\n  int ret;\n\n  fprintf (stdout, \"running test: %s \", test_name);\n  ret = test ();\n  if (ret == 0)\n    {\n      fprintf (stdout, \"[pass]\\n\");\n    }\n  else\n    {\n      fprintf (stdout, \"[fail]\\n\");\n    }\n  return ret;\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "test_ip_addr_option": {
      "start_point": [
        80,
        0
      ],
      "end_point": [
        122,
        1
      ],
      "content": "static int\ntest_ip_addr_option ()\n{\n  struct MHD_Daemon *d;\n  struct sockaddr_in daemon_ip_addr;\n#if HAVE_INET6\n  struct sockaddr_in6 daemon_ip_addr6;\n#endif\n\n  memset (&daemon_ip_addr, 0, sizeof (struct sockaddr_in));\n  daemon_ip_addr.sin_family = AF_INET;\n  daemon_ip_addr.sin_port = 0;\n  daemon_ip_addr.sin_addr.s_addr = htonl (INADDR_LOOPBACK);\n\n#if HAVE_INET6\n  memset (&daemon_ip_addr6, 0, sizeof (struct sockaddr_in6));\n  daemon_ip_addr6.sin6_family = AF_INET6;\n  daemon_ip_addr6.sin6_port = 0;\n  daemon_ip_addr6.sin6_addr = in6addr_loopback;\n#endif\n\n  d = MHD_start_daemon (MHD_USE_ERROR_LOG, 0,\n                        NULL, NULL, &ahc_echo, NULL, MHD_OPTION_SOCK_ADDR,\n                        &daemon_ip_addr, MHD_OPTION_END);\n\n  if (d == 0)\n    return -1;\n\n  MHD_stop_daemon (d);\n\n#if HAVE_INET6\n  d = MHD_start_daemon (MHD_USE_ERROR_LOG | MHD_USE_IPv6, 0,\n                        NULL, NULL, &ahc_echo, NULL, MHD_OPTION_SOCK_ADDR,\n                        &daemon_ip_addr6, MHD_OPTION_END);\n\n  if (d == 0)\n    return -1;\n\n  MHD_stop_daemon (d);\n#endif\n\n  return 0;\n}",
      "lines": 43,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        125,
        0
      ],
      "end_point": [
        134,
        1
      ],
      "content": "int\nmain (int argc, char *const *argv)\n{\n  unsigned int errorCount = 0;\n  (void)argc; (void)argv; /* Unused. Silent compiler warning. */\n\n  errorCount += test_wrap_loc (\"ip addr option\", &test_ip_addr_option);\n\n  return errorCount != 0;\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/microhttpd/test_postprocessor.c": {
    "mismatch": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        80,
        1
      ],
      "content": "static int\nmismatch (const char *a, const char *b)\n{\n  if (a == b)\n    return 0;\n  if ((a == NULL) || (b == NULL))\n    return 1;\n  return 0 != strcmp (a, b);\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "value_checker": {
      "start_point": [
        82,
        0
      ],
      "end_point": [
        120,
        1
      ],
      "content": "static int\nvalue_checker (void *cls,\n               enum MHD_ValueKind kind,\n               const char *key,\n               const char *filename,\n               const char *content_type,\n               const char *transfer_encoding,\n               const char *data, uint64_t off, size_t size)\n{\n  int *want_off = cls;\n  int idx = *want_off;\n  (void)kind;  /* Unused. Silent compiler warning. */\n\n\n#if 0\n  fprintf (stderr,\n           \"VC: `%s' `%s' `%s' `%s' `%.*s'\\n\",\n           key, filename, content_type, transfer_encoding,\n           (int) size,\n           data);\n#endif\n  if ( (0 != off) && (0 == size) )\n    return MHD_YES;\n  if ((idx < 0) ||\n      (want[idx] == NULL) ||\n      (0 != strcmp (key, want[idx])) ||\n      (mismatch (filename, want[idx + 1])) ||\n      (mismatch (content_type, want[idx + 2])) ||\n      (mismatch (transfer_encoding, want[idx + 3])) ||\n      (0 != memcmp (data, &want[idx + 4][off], size)))\n    {\n      *want_off = -1;\n      return MHD_NO;\n    }\n  if (off + size == strlen (want[idx + 4]))\n    *want_off = idx + 5;\n  return MHD_YES;\n\n}",
      "lines": 39,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "test_urlencoding": {
      "start_point": [
        123,
        0
      ],
      "end_point": [
        154,
        1
      ],
      "content": "static int\ntest_urlencoding (void)\n{\n  struct MHD_Connection connection;\n  struct MHD_HTTP_Header header;\n  struct MHD_PostProcessor *pp;\n  unsigned int want_off = URL_START;\n  size_t i;\n  size_t delta;\n  size_t size;\n\n  memset (&connection, 0, sizeof (struct MHD_Connection));\n  memset (&header, 0, sizeof (struct MHD_HTTP_Header));\n  connection.headers_received = &header;\n  header.header = MHD_HTTP_HEADER_CONTENT_TYPE;\n  header.value = MHD_HTTP_POST_ENCODING_FORM_URLENCODED;\n  header.kind = MHD_HEADER_KIND;\n  pp = MHD_create_post_processor (&connection,\n                                  1024, &value_checker, &want_off);\n  i = 0;\n  size = strlen (URL_DATA);\n  while (i < size)\n    {\n      delta = 1 + MHD_random_ () % (size - i);\n      MHD_post_process (pp, &URL_DATA[i], delta);\n      i += delta;\n    }\n  MHD_destroy_post_processor (pp);\n  if (want_off != URL_END)\n    return 1;\n  return 0;\n}",
      "lines": 32,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "test_multipart_garbage": {
      "start_point": [
        157,
        0
      ],
      "end_point": [
        195,
        1
      ],
      "content": "static int\ntest_multipart_garbage (void)\n{\n  struct MHD_Connection connection;\n  struct MHD_HTTP_Header header;\n  struct MHD_PostProcessor *pp;\n  unsigned int want_off;\n  size_t size = strlen (FORM_DATA);\n  size_t splitpoint;\n  char xdata[size + 3];\n\n  /* fill in evil garbage at the beginning */\n  xdata[0] = '-';\n  xdata[1] = 'x';\n  xdata[2] = '\\r';\n  memcpy (&xdata[3], FORM_DATA, size);\n\n  size = strlen (FORM_DATA);\n  size += 3;\n  for (splitpoint = 1; splitpoint < size; splitpoint++)\n  {\n    want_off = FORM_START;\n    memset (&connection, 0, sizeof (struct MHD_Connection));\n    memset (&header, 0, sizeof (struct MHD_HTTP_Header));\n    connection.headers_received = &header;\n    header.header = MHD_HTTP_HEADER_CONTENT_TYPE;\n    header.value =\n      MHD_HTTP_POST_ENCODING_MULTIPART_FORMDATA \", boundary=AaB03x\";\n    header.kind = MHD_HEADER_KIND;\n    pp = MHD_create_post_processor (&connection,\n                                    1024, &value_checker, &want_off);\n    MHD_post_process (pp, xdata, splitpoint);\n    MHD_post_process (pp, &xdata[splitpoint], size - splitpoint);\n    MHD_destroy_post_processor (pp);\n    if (want_off != FORM_END)\n      return (int) splitpoint;\n  }\n  return 0;\n}",
      "lines": 39,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "test_multipart_splits": {
      "start_point": [
        198,
        0
      ],
      "end_point": [
        228,
        1
      ],
      "content": "static int\ntest_multipart_splits (void)\n{\n  struct MHD_Connection connection;\n  struct MHD_HTTP_Header header;\n  struct MHD_PostProcessor *pp;\n  unsigned int want_off;\n  size_t size;\n  size_t splitpoint;\n\n  size = strlen (FORM_DATA);\n  for (splitpoint = 1; splitpoint < size; splitpoint++)\n  {\n    want_off = FORM_START;\n    memset (&connection, 0, sizeof (struct MHD_Connection));\n    memset (&header, 0, sizeof (struct MHD_HTTP_Header));\n    connection.headers_received = &header;\n    header.header = MHD_HTTP_HEADER_CONTENT_TYPE;\n    header.value =\n      MHD_HTTP_POST_ENCODING_MULTIPART_FORMDATA \", boundary=AaB03x\";\n    header.kind = MHD_HEADER_KIND;\n    pp = MHD_create_post_processor (&connection,\n                                    1024, &value_checker, &want_off);\n    MHD_post_process (pp, FORM_DATA, splitpoint);\n    MHD_post_process (pp, &FORM_DATA[splitpoint], size - splitpoint);\n    MHD_destroy_post_processor (pp);\n    if (want_off != FORM_END)\n      return (int) splitpoint;\n  }\n  return 0;\n}",
      "lines": 31,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "test_multipart": {
      "start_point": [
        231,
        0
      ],
      "end_point": [
        263,
        1
      ],
      "content": "static int\ntest_multipart (void)\n{\n  struct MHD_Connection connection;\n  struct MHD_HTTP_Header header;\n  struct MHD_PostProcessor *pp;\n  unsigned int want_off = FORM_START;\n  size_t i;\n  size_t delta;\n  size_t size;\n\n  memset (&connection, 0, sizeof (struct MHD_Connection));\n  memset (&header, 0, sizeof (struct MHD_HTTP_Header));\n  connection.headers_received = &header;\n  header.header = MHD_HTTP_HEADER_CONTENT_TYPE;\n  header.value =\n    MHD_HTTP_POST_ENCODING_MULTIPART_FORMDATA \", boundary=AaB03x\";\n  header.kind = MHD_HEADER_KIND;\n  pp = MHD_create_post_processor (&connection,\n                                  1024, &value_checker, &want_off);\n  i = 0;\n  size = strlen (FORM_DATA);\n  while (i < size)\n    {\n      delta = 1 + MHD_random_ () % (size - i);\n      MHD_post_process (pp, &FORM_DATA[i], delta);\n      i += delta;\n    }\n  MHD_destroy_post_processor (pp);\n  if (want_off != FORM_END)\n    return 2;\n  return 0;\n}",
      "lines": 33,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "test_nested_multipart": {
      "start_point": [
        266,
        0
      ],
      "end_point": [
        298,
        1
      ],
      "content": "static int\ntest_nested_multipart (void)\n{\n  struct MHD_Connection connection;\n  struct MHD_HTTP_Header header;\n  struct MHD_PostProcessor *pp;\n  unsigned int want_off = FORM_NESTED_START;\n  size_t i;\n  size_t delta;\n  size_t size;\n\n  memset (&connection, 0, sizeof (struct MHD_Connection));\n  memset (&header, 0, sizeof (struct MHD_HTTP_Header));\n  connection.headers_received = &header;\n  header.header = MHD_HTTP_HEADER_CONTENT_TYPE;\n  header.value =\n    MHD_HTTP_POST_ENCODING_MULTIPART_FORMDATA \", boundary=AaB03x\";\n  header.kind = MHD_HEADER_KIND;\n  pp = MHD_create_post_processor (&connection,\n                                  1024, &value_checker, &want_off);\n  i = 0;\n  size = strlen (FORM_NESTED_DATA);\n  while (i < size)\n    {\n      delta = 1 + MHD_random_ () % (size - i);\n      MHD_post_process (pp, &FORM_NESTED_DATA[i], delta);\n      i += delta;\n    }\n  MHD_destroy_post_processor (pp);\n  if (want_off != FORM_NESTED_END)\n    return 4;\n  return 0;\n}",
      "lines": 33,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "test_empty_value": {
      "start_point": [
        301,
        0
      ],
      "end_point": [
        332,
        1
      ],
      "content": "static int\ntest_empty_value (void)\n{\n  struct MHD_Connection connection;\n  struct MHD_HTTP_Header header;\n  struct MHD_PostProcessor *pp;\n  unsigned int want_off = URL_EMPTY_VALUE_START;\n  size_t i;\n  size_t delta;\n  size_t size;\n\n  memset (&connection, 0, sizeof (struct MHD_Connection));\n  memset (&header, 0, sizeof (struct MHD_HTTP_Header));\n  connection.headers_received = &header;\n  header.header = MHD_HTTP_HEADER_CONTENT_TYPE;\n  header.value = MHD_HTTP_POST_ENCODING_FORM_URLENCODED;\n  header.kind = MHD_HEADER_KIND;\n  pp = MHD_create_post_processor (&connection,\n                                  1024, &value_checker, &want_off);\n  i = 0;\n  size = strlen (URL_EMPTY_VALUE_DATA);\n  while (i < size)\n    {\n      delta = 1 + MHD_random_ () % (size - i);\n      MHD_post_process (pp, &URL_EMPTY_VALUE_DATA[i], delta);\n      i += delta;\n    }\n  MHD_destroy_post_processor (pp);\n  if (want_off != URL_EMPTY_VALUE_END)\n    return 8;\n  return 0;\n}",
      "lines": 32,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        337,
        0
      ],
      "end_point": [
        352,
        1
      ],
      "content": "int\nmain (int argc, char *const *argv)\n{\n  unsigned int errorCount = 0;\n  (void)argc; (void)argv;  /* Unused. Silent compiler warning. */\n\n  errorCount += test_multipart_splits ();\n  errorCount += test_multipart_garbage ();\n  errorCount += test_urlencoding ();\n  errorCount += test_multipart ();\n  errorCount += test_nested_multipart ();\n  errorCount += test_empty_value ();\n  if (errorCount != 0)\n    fprintf (stderr, \"Error (code: %u)\\n\", errorCount);\n  return errorCount != 0;       /* 0 == pass */\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/microhttpd/test_postprocessor_amp.c": {
    "check_post": {
      "start_point": [
        8,
        0
      ],
      "end_point": [
        21,
        1
      ],
      "content": "int check_post(void *cls, enum MHD_ValueKind kind, const char* key,\n                 const char* filename, const char* content_type,\n                 const char* content_encoding, const char* data,\n                 uint64_t off, size_t size)\n{\n  (void)cls; (void)kind; (void)filename; (void)content_type;  /* Unused. Silent compiler warning. */\n  (void)content_encoding; (void)data; (void)off; (void)size;  /* Unused. Silent compiler warning. */\n  if ((0 != strcmp(key, \"a\")) && (0 != strcmp(key, \"b\")))\n    {\n      printf(\"ERROR: got unexpected '%s'\\n\", key);\n    }\n\n  return MHD_YES;\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "int\nmain (int argc, char *const *argv)\n{\n  struct MHD_Connection connection;\n  struct MHD_HTTP_Header header;\n  struct MHD_PostProcessor *pp;\n  (void)argc; (void)argv;  /* Unused. Silent compiler warning. */\n\n  memset (&connection, 0, sizeof (struct MHD_Connection));\n  memset (&header, 0, sizeof (struct MHD_HTTP_Header));\n  connection.headers_received = &header;\n  header.header = MHD_HTTP_HEADER_CONTENT_TYPE;\n  header.value = MHD_HTTP_POST_ENCODING_FORM_URLENCODED;\n  header.kind = MHD_HEADER_KIND;\n\n  pp = MHD_create_post_processor (&connection,\n                                  4096, &check_post, NULL);\n\n  const char* post = \"a=xx+xx+xxx+xxxxx+xxxx+xxxxxxxx+xxx+xxxxxx+xxx+xxx+xxxxxxx+xxxxx%0A+++++++xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx%0A+++++++--%3E%0A++++++++++++++%3Cxxxxx+xxxxx%3D%22xxx%25%22%3E%0A+++++++++++%3Cxx%3E%0A+++++++++++++++%3Cxx+xxxxxxx%3D%22x%22+xxxxx%3D%22xxxxx%22%3E%0A+++++++++++++++++++%3Cxxxxx+xxxxx%3D%22xxx%25%22%3E%0A+++++++++++++++++++++++%3Cxx%3E%0A+++++++++++++++++++++++++++%3Cxx+xxxxx%3D%22xxxx%22%3E%0A+++++++++++++++++++++++++++++++%3Cx+xxxxx%3D%22xxxx-xxxxx%3Axxxxx%22%3Exxxxx%3A%3C%2Fx%3E%0A%0A+++++++++++++++++++++++++++++++%3Cx+xxxxx%3D%22xxxx-xxxxx%3Axxxxx%22%3Exxx%3A%3C%2Fx%3E%0A%0A+++++++++++++++++++++++++++++++%3Cx+xxxxx%3D%22xxxx-xxxxx%3Axxxxx%3B+xxxx-xxxxxx%3A+xxxx%3B%22%3Exxxxx+xxxxx%3A%3C%2Fx%3E%0A+++++++++++++++++++++++++++%3C%2Fxx%3E%0A+++++++++++++++++++++++%3C%2Fxx%3E%0A+++++++++++++++++++%3C%2Fxxxxx%3E%0A+++++++++++++++%3C%2Fxx%3E%0A+++++++++++++++%3Cxx+xxxxx%3D%22xxxx-xxxxx%3A+xxxxx%3B+xxxxx%3A+xxxx%22%3E%26xxxxx%3B+%3Cxxxx%0A+++++++++++++++++++++++xxxxx%3D%22xxxxxxxxxxxxxxx%22%3Exxxx.xx%3C%2Fxxxx%3E%0A+++++++++++++++%3C%2Fxx%3E%0A+++++++++++%3C%2Fxx%3E%0A++++++++++++++++++++++++++%3Cxx%3E%0A+++++++++++++++++++%3Cxx+xxxxx%3D%22xxxx-xxxxx%3A+xxxxx%3B+xxxxx%3A+xxxx%22%3E%26xxxxx%3B+%3Cxxxx%0A+++++++++++++++++++++++++++xxxxx%3D%22xxxxxxxxxxxxxxx%22%3Exxx.xx%3C%2Fxxxx%3E%0A+++++++++++++++++++%3C%2Fxx%3E%0A+++++++++++++++%3C%2Fxx%3E%0A++++++++++++++++++++++%3Cxx%3E%0A+++++++++++++++%3Cxx+xxxxx%3D%22xxxx-xxxxx%3A+xxxxx%3Bxxxx-xxxxxx%3A+xxxx%3B+xxxxx%3A+xxxx%22%3E%26xxxxx%3B+%3Cxxxx%0A+++++++++++++++++++++++xxxxx%3D%22xxxxxxxxxxxxxxx%22%3Exxxx.xx%3C%2Fxxxx%3E%3C%2Fxx%3E%0A+++++++++++%3C%2Fxx%3E%0A+++++++%3C%2Fxxxxx%3E%0A+++++++%3C%21--%0A+++++++xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx%0A+++++++xxx+xx+xxxxx+xxxxxxx+xxxxxxx%0A+++++++xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx%0A+++++++--%3E%0A+++%3C%2Fxxx%3E%0A%0A%0A%0A+++%3Cxxx+xxxxx%3D%22xxxxxxxxx%22+xx%3D%22xxxxxxxxx%22%3E%3C%2Fxxx%3E%0A%0A+++%3Cxxx+xx%3D%22xxxx%22+xxxxx%3D%22xxxx%22%3E%0A+++++++%3Cxxxxx+xxxxx%3D%22xxxxxxxxx%22%3E%0A+++++++++++%3Cxx%3E%0A+++++++++++++++%3Cxx+xxxxxxx%3D%22x%22+xx%3D%22xxxxxxxxxxxxx%22+xxxxx%3D%22xxxxxxxxxxxxx%22%3E%0A+++++++++++++++++++%3Cxxx+xx%3D%22xxxxxx%22%3E%3C%2Fxxx%3E%0A+++++++++++++++%3C%2Fxx%3E%0A+++++++++++%3C%2Fxx%3E%0A+++++++++++%3Cxx%3E%0A+++++++++++++++%3Cxx+xx%3D%22xxxxxxxxxxxxxxxxx%22+xxxxx%3D%22xxxxxxxxxxxxxxxxx%22%3E%3C%2Fxx%3E%0A+++++++++++++++%3Cxx+xx%3D%22xxxxxxxxxxxxxx%22+xxxxx%3D%22xxxxxxxxxxxxxx%22%3E%0A+++++++++++++++++++%3Cxxx+xx%3D%22xxxxxxx%22%3E%3C%2Fxxx%3E%0A+++++++++++++++%3C%2Fxx%3E%0A+++++++++++%3C%2Fxx%3E%0A+++++++++++%3Cxx%3E%0A+++++++++++++++%3Cxx+xxxxxxx%3D%22x%22+xx%3D%22xxxxxxxxxxxxx%22+xxxxx%3D%22xxxxxxxxxxxxx%22%3E%0A+++++++++++++++++++%3Cxxx+xx%3D%22xxxxxx%22%3E%3C%2Fxxx%3E%0A+++++++++++++++%3C%2Fxx%3E%0A+++++++++++%3C%2Fxx%3E%0A+++++++%3C%2Fxxxxx%3E%0A+++%3C%2Fxxx%3E%0A%3C%2Fxxx%3E%0A%0A%3Cxxx+xx%3D%22xxxxxx%22%3E%3C%2Fxxx%3E%0A%0A%3C%2Fxxxx%3E%0A%3C%2Fxxxx%3E+&b=value\";\n\n  MHD_post_process (pp, post, strlen(post));\n  MHD_destroy_post_processor (pp);\n\n  return 0;\n}",
      "lines": 25,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/microhttpd/test_postprocessor_large.c": {
    "value_checker": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "static int\nvalue_checker (void *cls,\n               enum MHD_ValueKind kind,\n               const char *key,\n               const char *filename,\n               const char *content_type,\n               const char *transfer_encoding,\n               const char *data, uint64_t off, size_t size)\n{\n  unsigned int *pos = cls;\n  (void)kind; (void)key; (void)filename; (void)content_type;  /* Unused. Silent compiler warning. */\n  (void)transfer_encoding; (void)data; (void)off;             /* Unused. Silent compiler warning. */\n#if 0\n  fprintf (stderr,\n           \"VC: %llu %u `%s' `%s' `%s' `%s' `%.*s'\\n\",\n           off, size,\n           key, filename, content_type, transfer_encoding, size, data);\n#endif\n  if (size == 0)\n    return MHD_YES;\n  *pos += size;\n  return MHD_YES;\n\n}",
      "lines": 24,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "test_simple_large": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        96,
        1
      ],
      "content": "static int\ntest_simple_large ()\n{\n  struct MHD_Connection connection;\n  struct MHD_HTTP_Header header;\n  struct MHD_PostProcessor *pp;\n  size_t i;\n  size_t delta;\n  size_t size;\n  char data[102400];\n  unsigned int pos;\n\n  pos = 0;\n  memset (data, 'A', sizeof (data));\n  memcpy (data, \"key=\", 4);\n  data[sizeof (data) - 1] = '\\0';\n  memset (&connection, 0, sizeof (struct MHD_Connection));\n  memset (&header, 0, sizeof (struct MHD_HTTP_Header));\n  connection.headers_received = &header;\n  header.header = MHD_HTTP_HEADER_CONTENT_TYPE;\n  header.value = MHD_HTTP_POST_ENCODING_FORM_URLENCODED;\n  header.kind = MHD_HEADER_KIND;\n  pp = MHD_create_post_processor (&connection, 1024, &value_checker, &pos);\n  i = 0;\n  size = strlen (data);\n  while (i < size)\n    {\n      delta = 1 + MHD_random_ () % (size - i);\n      MHD_post_process (pp, &data[i], delta);\n      i += delta;\n    }\n  MHD_destroy_post_processor (pp);\n  if (pos != sizeof (data) - 5) /* minus 0-termination and 'key=' */\n    return 1;\n  return 0;\n}",
      "lines": 36,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        98,
        0
      ],
      "end_point": [
        108,
        1
      ],
      "content": "int\nmain (int argc, char *const *argv)\n{\n  unsigned int errorCount = 0;\n  (void)argc; (void)argv;  /* Unused. Silent compiler warning. */\n\n  errorCount += test_simple_large ();\n  if (errorCount != 0)\n    fprintf (stderr, \"Error (code: %u)\\n\", errorCount);\n  return errorCount != 0;       /* 0 == pass */\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/microhttpd/test_shutdown_select.c": {
    "has_in_name": {
      "start_point": [
        92,
        0
      ],
      "end_point": [
        116,
        1
      ],
      "content": "static bool\nhas_in_name(const char *prog_name, const char *marker)\n{\n  size_t name_pos;\n  size_t pos;\n\n  if (!prog_name || !marker)\n    return 0;\n\n  pos = 0;\n  name_pos = 0;\n  while (prog_name[pos])\n    {\n      if ('/' == prog_name[pos])\n        name_pos = pos + 1;\n#if defined(_WIN32) || defined(__CYGWIN__)\n      else if ('\\\\' == prog_name[pos])\n        name_pos = pos + 1;\n#endif /* _WIN32 || __CYGWIN__ */\n      pos++;\n    }\n  if (name_pos == pos)\n    return true;\n  return strstr(prog_name + name_pos, marker) != NULL;\n}",
      "lines": 25,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "start_socket_listen": {
      "start_point": [
        119,
        0
      ],
      "end_point": [
        218,
        1
      ],
      "content": "static MHD_socket\nstart_socket_listen(int domain)\n{\n/* Create sockets similarly to daemon.c */\n  MHD_socket fd;\n  int cloexec_set;\n  struct sockaddr_in sock_addr;\n  socklen_t addrlen;\n\n#ifdef MHD_WINSOCK_SOCKETS\n  unsigned long flags = 1;\n#else  /* MHD_POSIX_SOCKETS */\n  int flags;\n#endif /* MHD_POSIX_SOCKETS */\n\n#if defined(MHD_POSIX_SOCKETS) && defined(SOCK_CLOEXEC)\n  fd = socket (domain, SOCK_STREAM | SOCK_CLOEXEC, 0);\n  cloexec_set = 1;\n#elif defined(MHD_WINSOCK_SOCKETS) && defined (WSA_FLAG_NO_HANDLE_INHERIT)\n  fd = WSASocketW (domain, SOCK_STREAM, 0, NULL, 0, WSA_FLAG_NO_HANDLE_INHERIT);\n  cloexec_set = 1;\n#else  /* !SOCK_CLOEXEC */\n  fd = socket (domain, SOCK_STREAM, 0);\n  cloexec_set = 0;\n#endif /* !SOCK_CLOEXEC */\n  if ( (MHD_INVALID_SOCKET == fd) && (cloexec_set) )\n    {\n      fd = socket (domain, SOCK_STREAM, 0);\n      cloexec_set = 0;\n    }\n  if (MHD_INVALID_SOCKET == fd)\n    {\n      fprintf (stderr, \"Can't create socket: %u\\n\",\n               (unsigned)sock_errno);\n      return MHD_INVALID_SOCKET;\n    }\n\n  if (!cloexec_set)\n    {\n#ifdef MHD_WINSOCK_SOCKETS\n    if (!SetHandleInformation ((HANDLE)fd, HANDLE_FLAG_INHERIT, 0))\n      fprintf (stderr, \"Failed to make socket non-inheritable: %u\\n\",\n               (unsigned int)GetLastError ());\n#else  /* MHD_POSIX_SOCKETS */\n    flags = fcntl (fd, F_GETFD);\n    if ( ( (-1 == flags) ||\n           ( (flags != (flags | FD_CLOEXEC)) &&\n             (0 != fcntl (fd, F_SETFD, flags | FD_CLOEXEC)) ) ) )\n      fprintf (stderr, \"Failed to make socket non-inheritable: %s\\n\",\n               MHD_socket_last_strerr_ ());\n#endif /* MHD_POSIX_SOCKETS */\n    }\n\n  memset (&sock_addr, 0, sizeof (struct sockaddr_in));\n  sock_addr.sin_family = AF_INET;\n  sock_addr.sin_port = htons (0);\n#if HAVE_SOCKADDR_IN_SIN_LEN\n  sock_addr.sin_len = sizeof (struct sockaddr_in);\n#endif\n  addrlen = sizeof (struct sockaddr_in);\n\n  if (bind (fd, (const struct sockaddr*) &sock_addr, addrlen) < 0)\n    {\n      fprintf (stderr, \"Failed to bind socket: %u\\n\",\n               (unsigned)sock_errno);\n      MHD_socket_close_chk_ (fd);\n      return MHD_INVALID_SOCKET;\n    }\n\n#ifdef MHD_WINSOCK_SOCKETS\n  if (0 != ioctlsocket (fd, FIONBIO, &flags))\n    {\n      fprintf (stderr, \"Failed to make socket non-blocking: %u\\n\",\n               (unsigned)sock_errno);\n      MHD_socket_close_chk_ (fd);\n      return MHD_INVALID_SOCKET;\n    }\n#else  /* MHD_POSIX_SOCKETS */\n  flags = fcntl (fd, F_GETFL);\n  if ( ( (-1 == flags) ||\n         ( (flags != (flags | O_NONBLOCK)) &&\n           (0 != fcntl (fd, F_SETFL, flags | O_NONBLOCK)) ) ) )\n    {\n      fprintf (stderr, \"Failed to make socket non-blocking: %s\\n\",\n              MHD_socket_last_strerr_ ());\n      MHD_socket_close_chk_ (fd);\n      return MHD_INVALID_SOCKET;\n    }\n#endif /* MHD_POSIX_SOCKETS */\n\n  if (listen(fd, SOMAXCONN) < 0)\n    {\n      fprintf (stderr, \"Failed to listen on socket: %u\\n\",\n               (unsigned)sock_errno);\n      MHD_socket_close_chk_ (fd);\n      return MHD_INVALID_SOCKET;\n    }\n\n  return fd;\n}",
      "lines": 100,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "MHD_socket"
      ]
    },
    "select_thread": {
      "start_point": [
        221,
        0
      ],
      "end_point": [
        238,
        1
      ],
      "content": "MHD_THRD_RTRN_TYPE_ MHD_THRD_CALL_SPEC_\nselect_thread(void* data)\n{\n  /* use select() like in daemon.c */\n  MHD_socket listen_sock = *((MHD_socket*)data);\n  fd_set rs, ws;\n  struct timeval timeout;\n\n  FD_ZERO(&rs);\n  FD_ZERO(&ws);\n  FD_SET(listen_sock, &rs);\n  timeout.tv_usec = 0;\n  timeout.tv_sec = 7;\n\n  check_err = (0 > MHD_SYS_select_(listen_sock + 1, &rs, &ws, NULL, &timeout));\n\n  return (MHD_THRD_RTRN_TYPE_)0;\n}",
      "lines": 18,
      "depth": 10,
      "decorators": [
        "MHD_THRD_RTRN_TYPE_",
        "MHD_THRD_CALL_SPEC_",
        "MHD_THRD_CALL_SPEC_"
      ]
    },
    "poll_thread": {
      "start_point": [
        242,
        0
      ],
      "end_point": [
        256,
        1
      ],
      "content": "MHD_THRD_RTRN_TYPE_ MHD_THRD_CALL_SPEC_\npoll_thread(void* data)\n{\n  /* use poll() like in daemon.c */\n  struct pollfd p[1];\n  MHD_socket listen_sock = *((MHD_socket*)data);\n\n  p[0].fd = listen_sock;\n  p[0].events = POLLIN;\n  p[0].revents = 0;\n\n  check_err = (0 > MHD_sys_poll_ (p, 1, 7000));\n\n  return (MHD_THRD_RTRN_TYPE_)0;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "MHD_THRD_RTRN_TYPE_",
        "MHD_THRD_CALL_SPEC_",
        "MHD_THRD_CALL_SPEC_"
      ]
    },
    "local_sleep": {
      "start_point": [
        260,
        0
      ],
      "end_point": [
        272,
        1
      ],
      "content": "static void\nlocal_sleep(unsigned seconds)\n{\n#if defined(_WIN32) && !defined(__CYGWIN__)\n  Sleep(seconds * 1000);\n#else\n  unsigned seconds_left = seconds;\n  do\n    {\n      seconds_left = sleep(seconds_left);\n    } while (seconds_left > 0);\n#endif\n}",
      "lines": 13,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        275,
        0
      ],
      "end_point": [
        386,
        1
      ],
      "content": "int\nmain (int argc, char *const *argv)\n{\n  int i;\n  time_t start_t, end_t;\n  int result = 0;\n  MHD_THRD_RTRN_TYPE_ (MHD_THRD_CALL_SPEC_ *test_func)(void* data);\n#ifdef MHD_WINSOCK_SOCKETS\n  WORD ver_req;\n  WSADATA wsa_data;\n  int err;\n#endif /* MHD_WINSOCK_SOCKETS */\n  bool test_poll;\n  bool must_ignore;\n  (void)argc; /* Unused. Silent compiler warning. */\n\n  test_poll = has_in_name(argv[0], \"_poll\");\n  must_ignore = has_in_name(argv[0], \"_ignore\");\n  if (! test_poll)\n    test_func = &select_thread;\n  else\n    {\n#ifndef HAVE_POLL\n      return 77;\n#else  /* ! HAVE_POLL */\n      test_func = &poll_thread;\n#endif /* ! HAVE_POLL */\n    }\n\n#ifdef MHD_WINSOCK_SOCKETS\n  ver_req = MAKEWORD(2, 2);\n\n  err = WSAStartup(ver_req, &wsa_data);\n  if (err != 0 || MAKEWORD(2, 2) != wsa_data.wVersion)\n    {\n      printf(\"WSAStartup() failed\\n\");\n      WSACleanup();\n      return 99;\n    }\n#endif /* MHD_WINSOCK_SOCKETS */\n\n  /* try several times to ensure that accidental incoming connection\n   * didn't interfere with test results\n   */\n  for (i = 0; i < 5 && result == 0; i++)\n    {\n      MHD_thread_handle_ sel_thrd;\n      /* fprintf(stdout, \"Creating, binding and listening socket...\\n\"); */\n      MHD_socket listen_socket = start_socket_listen (AF_INET);\n      if (MHD_INVALID_SOCKET == listen_socket)\n        return 99;\n\n      check_err = true;\n      /* fprintf (stdout, \"Starting select() thread...\\n\"); */\n#if defined(MHD_USE_POSIX_THREADS)\n      if (0 != pthread_create (&sel_thrd, NULL, test_func, &listen_socket))\n        {\n          MHD_socket_close_chk_ (listen_socket);\n          fprintf (stderr, \"Can't start thread\\n\");\n          return 99;\n        }\n#elif defined(MHD_USE_W32_THREADS)\n      sel_thrd = (HANDLE)_beginthreadex (NULL, 0, test_func, &listen_socket, 0, NULL);\n      if (0 == (sel_thrd))\n        {\n          MHD_socket_close_chk_ (listen_socket);\n          fprintf (stderr, \"Can't start select() thread\\n\");\n          return 99;\n        }\n#else\n#error No threading lib available\n#endif\n      /* fprintf (stdout, \"Waiting...\\n\"); */\n      local_sleep(1); /* make sure that select() is started */\n\n      /* fprintf (stdout, \"Shutting down socket...\\n\"); */\n      start_t = time (NULL);\n      shutdown (listen_socket, SHUT_RDWR);\n\n      /* fprintf (stdout, \"Waiting for thread to finish...\\n\"); */\n      if (!MHD_join_thread_(sel_thrd))\n        {\n          MHD_socket_close_chk_(listen_socket);\n          fprintf (stderr, \"Can't join select() thread\\n\");\n          return 99;\n        }\n      if (check_err)\n        {\n          MHD_socket_close_chk_(listen_socket);\n          fprintf (stderr, \"Error in waiting thread\\n\");\n          return 99;\n        }\n      end_t = time (NULL);\n      /* fprintf (stdout, \"Thread finished.\\n\"); */\n      MHD_socket_close_chk_(listen_socket);\n\n      if (start_t == (time_t)-1 || end_t == (time_t)-1)\n        {\n          MHD_socket_close_chk_(listen_socket);\n          fprintf (stderr, \"Can't get current time\\n\");\n          return 99;\n        }\n      if (end_t - start_t > 3)\n        result++;\n    }\n\n#ifdef MHD_WINSOCK_SOCKETS\n  WSACleanup();\n#endif /* MHD_WINSOCK_SOCKETS */\n\n  return must_ignore ? (!result) : (result);\n}",
      "lines": 112,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/microhttpd/test_start_stop.c": {
    "ahc_echo": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "static int\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data, size_t *upload_data_size,\n          void **unused)\n{\n  (void)cls;(void)connection;(void)url;          /* Unused. Silent compiler warning. */\n  (void)method;(void)version;(void)upload_data;  /* Unused. Silent compiler warning. */\n  (void)upload_data_size;(void)unused;           /* Unused. Silent compiler warning. */\n\n  return MHD_NO;\n}",
      "lines": 15,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testInternalGet": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        65,
        1
      ],
      "content": "static int\ntestInternalGet (int poll_flag)\n{\n  struct MHD_Daemon *d;\n\n  d = MHD_start_daemon (MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_ERROR_LOG | poll_flag,\n                        0, NULL, NULL, &ahc_echo, \"GET\", MHD_OPTION_END);\n  if (d == NULL)\n    return 1;\n  MHD_stop_daemon (d);\n  return 0;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testMultithreadedGet": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "static int\ntestMultithreadedGet (int poll_flag)\n{\n  struct MHD_Daemon *d;\n\n  d = MHD_start_daemon (MHD_USE_THREAD_PER_CONNECTION | MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_ERROR_LOG  | poll_flag,\n                        0, NULL, NULL, &ahc_echo, \"GET\", MHD_OPTION_END);\n  if (d == NULL)\n    return 2;\n  MHD_stop_daemon (d);\n  return 0;\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testMultithreadedPoolGet": {
      "start_point": [
        80,
        0
      ],
      "end_point": [
        92,
        1
      ],
      "content": "static int\ntestMultithreadedPoolGet (int poll_flag)\n{\n  struct MHD_Daemon *d;\n\n  d = MHD_start_daemon (MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_ERROR_LOG | poll_flag,\n                        0, NULL, NULL, &ahc_echo, \"GET\",\n                        MHD_OPTION_THREAD_POOL_SIZE, CPU_COUNT, MHD_OPTION_END);\n  if (d == NULL)\n    return 4;\n  MHD_stop_daemon (d);\n  return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testExternalGet": {
      "start_point": [
        94,
        0
      ],
      "end_point": [
        105,
        1
      ],
      "content": "static int\ntestExternalGet ()\n{\n  struct MHD_Daemon *d;\n\n  d = MHD_start_daemon (MHD_USE_ERROR_LOG,\n                        0, NULL, NULL, &ahc_echo, \"GET\", MHD_OPTION_END);\n  if (d == NULL)\n    return 8;\n  MHD_stop_daemon (d);\n  return 0;\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        108,
        0
      ],
      "end_point": [
        132,
        1
      ],
      "content": "int\nmain (int argc, char *const *argv)\n{\n  unsigned int errorCount = 0;\n  (void)argc; (void)argv; /* Unused. Silent compiler warning. */\n\n  errorCount += testInternalGet (0);\n  errorCount += testMultithreadedGet (0);\n  errorCount += testMultithreadedPoolGet (0);\n  errorCount += testExternalGet ();\n  if (MHD_YES == MHD_is_feature_supported(MHD_FEATURE_POLL))\n    {\n      errorCount += testInternalGet(MHD_USE_POLL);\n      errorCount += testMultithreadedGet(MHD_USE_POLL);\n      errorCount += testMultithreadedPoolGet(MHD_USE_POLL);\n    }\n  if (MHD_YES == MHD_is_feature_supported(MHD_FEATURE_EPOLL))\n    {\n      errorCount += testInternalGet(MHD_USE_EPOLL);\n      errorCount += testMultithreadedPoolGet(MHD_USE_EPOLL);\n    }\n  if (errorCount != 0)\n    fprintf (stderr, \"Error (code: %u)\\n\", errorCount);\n  return errorCount != 0;       /* 0 == pass */\n}",
      "lines": 25,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/microhttpd/test_str.c": {
    "set_test_locale": {
      "start_point": [
        209,
        0
      ],
      "end_point": [
        224,
        1
      ],
      "content": "int set_test_locale(unsigned int num)\n{\n  if (num >= locale_name_count)\n    return -1;\n  if (verbose > 2)\n    printf(\"Setting locale \\\"%s\\\":\", locale_names[num]);\n   if (setlocale(LC_ALL, locale_names[num]))\n     {\n       if (verbose > 2)\n         printf(\" succeed.\\n\");\n       return 1;\n     }\n   if (verbose > 2)\n     printf(\" failed.\\n\");\n   return 0;\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "get_current_locale_str": {
      "start_point": [
        226,
        0
      ],
      "end_point": [
        230,
        1
      ],
      "content": "const char * get_current_locale_str(void)\n{\n  char const * loc_str = setlocale(LC_ALL, NULL);\n  return loc_str ? loc_str : \"unknown\";\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "const",
        "const",
        "char",
        "* get_current_locale_str(void)",
        "*"
      ]
    },
    "n_prnt": {
      "start_point": [
        236,
        0
      ],
      "end_point": [
        279,
        1
      ],
      "content": "char * n_prnt(const char * str)\n{\n  static char * buf; /* should be enough for testing */\n  static const size_t buf_size = sizeof(tmp_bufs[0]);\n  const unsigned char * p = (const unsigned char*)str;\n  size_t w_pos = 0;\n  if (++buf_idx > 3)\n    buf_idx = 0;\n  buf = tmp_bufs[buf_idx];\n\n  while(*p && w_pos + 1 < buf_size)\n    {\n      const unsigned char c = *p;\n      if (c == '\\\\' || c == '\"')\n        {\n          if (w_pos + 2 >= buf_size)\n            break;\n          buf[w_pos++] = '\\\\';\n          buf[w_pos++] = c;\n        }\n      else if (c >= 0x20 && c <= 0x7E)\n          buf[w_pos++] = c;\n      else\n        {\n          if (w_pos + 4 >= buf_size)\n            break;\n          if (snprintf(buf + w_pos, buf_size - w_pos, \"\\\\x%02hX\", (short unsigned int)c) != 4)\n            break;\n          w_pos += 4;\n        }\n      p++;\n    }\n  if (*p)\n    { /* not full string is printed */\n      /* enough space for \"...\" ? */\n      if (w_pos + 3 > buf_size)\n        w_pos = buf_size - 4;\n      buf[w_pos++] = '.';\n      buf[w_pos++] = '.';\n      buf[w_pos++] = '.';\n    }\n  buf[w_pos] = 0;\n  return buf;\n}",
      "lines": 44,
      "depth": 16,
      "decorators": [
        "char",
        "* n_prnt(const char * str)",
        "*"
      ]
    },
    "check_eq_strings": {
      "start_point": [
        476,
        0
      ],
      "end_point": [
        514,
        1
      ],
      "content": "int check_eq_strings(void)\n{\n  size_t t_failed = 0;\n  size_t i, j;\n  static const size_t n_checks = sizeof(eq_strings) / sizeof(eq_strings[0]);\n  int c_failed[n_checks];\n\n  memset(c_failed, 0, sizeof(c_failed));\n\n  for(j = 0; j < locale_name_count; j++)\n    {\n      set_test_locale(j); /* setlocale() can be slow! */\n      for(i = 0; i < n_checks; i++)\n        {\n          const struct two_eq_strs * const t = eq_strings + i;\n          if (c_failed[i])\n            continue; /* skip already failed checks */\n          if (!MHD_str_equal_caseless_(t->s1.str, t->s2.str))\n            {\n              t_failed++;\n              c_failed[i] = !0;\n              fprintf(stderr, \"FAILED: MHD_str_equal_caseless_(\\\"%s\\\", \\\"%s\\\") returned zero, while expected non-zero.\"\n                      \" Locale: %s\\n\", n_prnt(t->s1.str), n_prnt(t->s2.str), get_current_locale_str());\n            }\n          else if (!MHD_str_equal_caseless_(t->s2.str, t->s1.str))\n            {\n              t_failed++;\n              c_failed[i] = !0;\n              fprintf(stderr, \"FAILED: MHD_str_equal_caseless_(\\\"%s\\\", \\\"%s\\\") returned zero, while expected non-zero.\"\n                      \" Locale: %s\\n\", n_prnt(t->s2.str), n_prnt(t->s1.str), get_current_locale_str());\n            }\n          if (verbose > 1 && j == locale_name_count - 1 && !c_failed[i])\n            printf(\"PASSED: MHD_str_equal_caseless_(\\\"%s\\\", \\\"%s\\\") != 0 && \\\\\\n\"\n                   \"        MHD_str_equal_caseless_(\\\"%s\\\", \\\"%s\\\") != 0\\n\", n_prnt(t->s1.str), n_prnt(t->s2.str),\n                   n_prnt(t->s2.str), n_prnt(t->s1.str));\n        }\n    }\n  return t_failed;\n}",
      "lines": 39,
      "depth": 17,
      "decorators": [
        "int"
      ]
    },
    "check_neq_strings": {
      "start_point": [
        516,
        0
      ],
      "end_point": [
        554,
        1
      ],
      "content": "int check_neq_strings(void)\n{\n  size_t t_failed = 0;\n  size_t i, j;\n  static const size_t n_checks = sizeof(neq_strings) / sizeof(neq_strings[0]);\n  int c_failed[n_checks];\n\n  memset(c_failed, 0, sizeof(c_failed));\n\n  for(j = 0; j < locale_name_count; j++)\n    {\n      set_test_locale(j); /* setlocale() can be slow! */\n      for(i = 0; i < n_checks; i++)\n        {\n          const struct two_neq_strs * const t = neq_strings + i;\n          if (c_failed[i])\n            continue; /* skip already failed checks */\n          if (MHD_str_equal_caseless_(t->s1.str, t->s2.str))\n            {\n              t_failed++;\n              c_failed[i] = !0;\n              fprintf(stderr, \"FAILED: MHD_str_equal_caseless_(\\\"%s\\\", \\\"%s\\\") returned non-zero, while expected zero.\"\n                      \" Locale: %s\\n\", n_prnt(t->s1.str), n_prnt(t->s2.str), get_current_locale_str());\n            }\n          else if (MHD_str_equal_caseless_(t->s2.str, t->s1.str))\n            {\n              t_failed++;\n              c_failed[i] = !0;\n              fprintf(stderr, \"FAILED: MHD_str_equal_caseless_(\\\"%s\\\", \\\"%s\\\") returned non-zero, while expected zero.\"\n                      \" Locale: %s\\n\", n_prnt(t->s2.str), n_prnt(t->s1.str), get_current_locale_str());\n            }\n          if (verbose > 1 && j == locale_name_count - 1 && !c_failed[i])\n            printf(\"PASSED: MHD_str_equal_caseless_(\\\"%s\\\", \\\"%s\\\") == 0 && \\\\\\n\"\n                   \"        MHD_str_equal_caseless_(\\\"%s\\\", \\\"%s\\\") == 0\\n\", n_prnt(t->s1.str), n_prnt(t->s2.str),\n                   n_prnt(t->s2.str), n_prnt(t->s1.str));\n        }\n    }\n  return t_failed;\n}",
      "lines": 39,
      "depth": 17,
      "decorators": [
        "int"
      ]
    },
    "check_eq_strings_n": {
      "start_point": [
        556,
        0
      ],
      "end_point": [
        599,
        1
      ],
      "content": "int check_eq_strings_n(void)\n{\n  size_t t_failed = 0;\n  size_t i, j, k;\n  static const size_t n_checks = sizeof(eq_strings) / sizeof(eq_strings[0]);\n  int c_failed[n_checks];\n\n  memset(c_failed, 0, sizeof(c_failed));\n\n  for(j = 0; j < locale_name_count; j++)\n    {\n      set_test_locale(j); /* setlocale() can be slow! */\n      for(i = 0; i < n_checks; i++)\n        {\n          size_t m_len;\n          const struct two_eq_strs * const t = eq_strings + i;\n          m_len = (t->s1.len > t->s2.len) ? t->s1.len : t->s2.len;\n          for(k = 0; k <= m_len + 1 && !c_failed[i]; k++)\n            {\n              if (!MHD_str_equal_caseless_n_(t->s1.str, t->s2.str, k))\n                {\n                  t_failed++;\n                  c_failed[i] = !0;\n                  fprintf(stderr, \"FAILED: MHD_str_equal_caseless_n_(\\\"%s\\\", \\\"%s\\\", %u) returned zero,\"\n                                  \" while expected non-zero. Locale: %s\\n\",\n                                  n_prnt(t->s1.str), n_prnt(t->s2.str), (unsigned int) k, get_current_locale_str());\n                }\n              else if (!MHD_str_equal_caseless_n_(t->s2.str, t->s1.str, k))\n                {\n                  t_failed++;\n                  c_failed[i] = !0;\n                  fprintf(stderr, \"FAILED: MHD_str_equal_caseless_n_(\\\"%s\\\", \\\"%s\\\", %u) returned zero,\"\n                                  \" while expected non-zero. Locale: %s\\n\",\n                                  n_prnt(t->s2.str), n_prnt(t->s1.str), (unsigned int) k, get_current_locale_str());\n                }\n            }\n          if (verbose > 1 && j == locale_name_count - 1 && !c_failed[i])\n            printf(\"PASSED: MHD_str_equal_caseless_n_(\\\"%s\\\", \\\"%s\\\", N) != 0 && \\\\\\n\"\n                   \"        MHD_str_equal_caseless_n_(\\\"%s\\\", \\\"%s\\\", N) != 0, where N is 0..%u\\n\",\n                   n_prnt(t->s1.str), n_prnt(t->s2.str), n_prnt(t->s2.str), n_prnt(t->s1.str), (unsigned int) m_len + 1);\n        }\n    }\n  return t_failed;\n}",
      "lines": 44,
      "depth": 19,
      "decorators": [
        "int"
      ]
    },
    "check_neq_strings_n": {
      "start_point": [
        601,
        0
      ],
      "end_point": [
        695,
        1
      ],
      "content": "int check_neq_strings_n(void)\n{\n  size_t t_failed = 0;\n  size_t i, j, k;\n  static const size_t n_checks = sizeof(neq_strings) / sizeof(neq_strings[0]);\n  int c_failed[n_checks];\n\n  memset(c_failed, 0, sizeof(c_failed));\n\n  for(j = 0; j < locale_name_count; j++)\n    {\n      set_test_locale(j); /* setlocale() can be slow! */\n      for(i = 0; i < n_checks; i++)\n        {\n          size_t m_len;\n          const struct two_neq_strs * const t = neq_strings + i;\n          m_len = t->s1.len > t->s2.len ? t->s1.len : t->s2.len;\n          if (t->dif_pos >= m_len)\n            {\n              fprintf(stderr, \"ERROR: neq_strings[%u] has wrong dif_pos (%u): dif_pos is expected to be less than \"\n                              \"s1.len (%u) or s2.len (%u).\\n\", (unsigned int) i, (unsigned int) t->dif_pos,\n                              (unsigned int) t->s1.len, (unsigned int) t->s2.len);\n              return -1;\n            }\n          if (t->dif_pos > t->s1.len)\n            {\n              fprintf(stderr, \"ERROR: neq_strings[%u] has wrong dif_pos (%u): dif_pos is expected to be less or \"\n                              \"equal to s1.len (%u).\\n\", (unsigned int) i, (unsigned int) t->dif_pos,\n                              (unsigned int) t->s1.len);\n              return -1;\n            }\n          if (t->dif_pos > t->s2.len)\n            {\n              fprintf(stderr, \"ERROR: neq_strings[%u] has wrong dif_pos (%u): dif_pos is expected to be less or \"\n                              \"equal to s2.len (%u).\\n\", (unsigned int) i, (unsigned int) t->dif_pos,\n                              (unsigned int) t->s2.len);\n              return -1;\n            }\n          for(k = 0; k <= m_len + 1 && !c_failed[i]; k++)\n            {\n              if (k <= t->dif_pos)\n                {\n                  if (!MHD_str_equal_caseless_n_(t->s1.str, t->s2.str, k))\n                    {\n                      t_failed++;\n                      c_failed[i] = !0;\n                      fprintf(stderr, \"FAILED: MHD_str_equal_caseless_n_(\\\"%s\\\", \\\"%s\\\", %u) returned zero,\"\n                                      \" while expected non-zero. Locale: %s\\n\",\n                                      n_prnt(t->s1.str), n_prnt(t->s2.str), (unsigned int) k, get_current_locale_str());\n                    }\n                  else if (!MHD_str_equal_caseless_n_(t->s2.str, t->s1.str, k))\n                    {\n                      t_failed++;\n                      c_failed[i] = !0;\n                      fprintf(stderr, \"FAILED: MHD_str_equal_caseless_n_(\\\"%s\\\", \\\"%s\\\", %u) returned zero,\"\n                                      \" while expected non-zero. Locale: %s\\n\",\n                                      n_prnt(t->s2.str), n_prnt(t->s1.str), (unsigned int) k, get_current_locale_str());\n                    }\n                }\n              else\n                {\n                  if (MHD_str_equal_caseless_n_(t->s1.str, t->s2.str, k))\n                    {\n                      t_failed++;\n                      c_failed[i] = !0;\n                      fprintf(stderr, \"FAILED: MHD_str_equal_caseless_n_(\\\"%s\\\", \\\"%s\\\", %u) returned non-zero,\"\n                                      \" while expected zero. Locale: %s\\n\",\n                                      n_prnt(t->s1.str), n_prnt(t->s2.str), (unsigned int) k, get_current_locale_str());\n                    }\n                  else if (MHD_str_equal_caseless_n_(t->s2.str, t->s1.str, k))\n                    {\n                      t_failed++;\n                      c_failed[i] = !0;\n                      fprintf(stderr, \"FAILED: MHD_str_equal_caseless_n_(\\\"%s\\\", \\\"%s\\\", %u) returned non-zero,\"\n                                      \" while expected zero. Locale: %s\\n\",\n                                      n_prnt(t->s2.str), n_prnt(t->s1.str), (unsigned int) k, get_current_locale_str());\n                    }\n                }\n            }\n          if (verbose > 1 && j == locale_name_count - 1 && !c_failed[i])\n            {\n              printf(\"PASSED: MHD_str_equal_caseless_n_(\\\"%s\\\", \\\"%s\\\", N) != 0 && \\\\\\n\"\n                     \"        MHD_str_equal_caseless_n_(\\\"%s\\\", \\\"%s\\\", N) != 0, where N is 0..%u\\n\",\n                     n_prnt(t->s1.str), n_prnt(t->s2.str), n_prnt(t->s2.str), n_prnt(t->s1.str),\n                     (unsigned int) t->dif_pos);\n\n              printf(\"PASSED: MHD_str_equal_caseless_n_(\\\"%s\\\", \\\"%s\\\", N) == 0 && \\\\\\n\"\n                     \"        MHD_str_equal_caseless_n_(\\\"%s\\\", \\\"%s\\\", N) == 0, where N is %u..%u\\n\",\n                     n_prnt(t->s1.str), n_prnt(t->s2.str), n_prnt(t->s2.str), n_prnt(t->s1.str),\n                     (unsigned int) t->dif_pos + 1, (unsigned int) m_len + 1);\n            }\n        }\n    }\n  return t_failed;\n}",
      "lines": 95,
      "depth": 21,
      "decorators": [
        "int"
      ]
    },
    "run_eq_neq_str_tests": {
      "start_point": [
        700,
        0
      ],
      "end_point": [
        786,
        1
      ],
      "content": "int run_eq_neq_str_tests(void)\n{\n  int str_equal_caseless_fails = 0;\n  int str_equal_caseless_n_fails = 0;\n  int res;\n\n  res = check_eq_strings();\n  if (res != 0)\n    {\n      if (res < 0)\n        {\n          fprintf(stderr, \"ERROR: test internal error in check_eq_strings().\\n\");\n          return 99;\n        }\n      str_equal_caseless_fails += res;\n      fprintf(stderr, \"FAILED: testcase check_eq_strings() failed.\\n\\n\");\n    }\n  else if (verbose > 1)\n    printf(\"PASSED: testcase check_eq_strings() successfully passed.\\n\\n\");\n\n  res = check_neq_strings();\n  if (res != 0)\n    {\n      if (res < 0)\n        {\n          fprintf(stderr, \"ERROR: test internal error in check_neq_strings().\\n\");\n          return 99;\n        }\n      str_equal_caseless_fails += res;\n      fprintf(stderr, \"FAILED: testcase check_neq_strings() failed.\\n\\n\");\n    }\n  else if (verbose > 1)\n    printf(\"PASSED: testcase check_neq_strings() successfully passed.\\n\\n\");\n\n  if (str_equal_caseless_fails)\n    fprintf(stderr, \"FAILED: function MHD_str_equal_caseless_() failed %d time%s.\\n\\n\",\n                     str_equal_caseless_fails, str_equal_caseless_fails == 1 ? \"\" : \"s\");\n  else if (verbose > 0)\n    printf(\"PASSED: function MHD_str_equal_caseless_() successfully passed all checks.\\n\\n\");\n\n  res = check_eq_strings_n();\n  if (res != 0)\n    {\n      if (res < 0)\n        {\n          fprintf(stderr, \"ERROR: test internal error in check_eq_strings_n().\\n\");\n          return 99;\n        }\n      str_equal_caseless_n_fails += res;\n      fprintf(stderr, \"FAILED: testcase check_eq_strings_n() failed.\\n\\n\");\n    }\n  else if (verbose > 1)\n    printf(\"PASSED: testcase check_eq_strings_n() successfully passed.\\n\\n\");\n\n  res = check_neq_strings_n();\n  if (res != 0)\n    {\n      if (res < 0)\n        {\n          fprintf(stderr, \"ERROR: test internal error in check_neq_strings_n().\\n\");\n          return 99;\n        }\n      str_equal_caseless_n_fails += res;\n      fprintf(stderr, \"FAILED: testcase check_neq_strings_n() failed.\\n\\n\");\n    }\n  else if (verbose > 1)\n    printf(\"PASSED: testcase check_neq_strings_n() successfully passed.\\n\\n\");\n\n  if (str_equal_caseless_n_fails)\n    fprintf(stderr, \"FAILED: function MHD_str_equal_caseless_n_() failed %d time%s.\\n\\n\",\n                     str_equal_caseless_n_fails, str_equal_caseless_n_fails == 1 ? \"\" : \"s\");\n  else if (verbose > 0)\n    printf(\"PASSED: function MHD_str_equal_caseless_n_() successfully passed all checks.\\n\\n\");\n\n  if (str_equal_caseless_fails || str_equal_caseless_n_fails)\n    {\n      if (verbose > 0)\n        printf(\"At least one test failed.\\n\");\n\n      return 1;\n    }\n\n  if (verbose > 0)\n    printf(\"All tests passed successfully.\\n\");\n\n  return 0;\n}",
      "lines": 87,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "check_str_to_uint64_valid": {
      "start_point": [
        1052,
        0
      ],
      "end_point": [
        1103,
        1
      ],
      "content": "int check_str_to_uint64_valid(void)\n{\n  size_t t_failed = 0;\n  size_t i, j;\n  static const size_t n_checks = sizeof(dstrs_w_values) / sizeof(dstrs_w_values[0]);\n  int c_failed[n_checks];\n\n  memset(c_failed, 0, sizeof(c_failed));\n\n  for(j = 0; j < locale_name_count; j++)\n    {\n      set_test_locale(j); /* setlocale() can be slow! */\n      for(i = 0; i < n_checks; i++)\n        {\n          uint64_t rv;\n          size_t rs;\n          const struct str_with_value * const t = dstrs_w_values + i;\n\n          if (c_failed[i])\n            continue; /* skip already failed checks */\n\n          if (t->str.len < t->num_of_digt)\n            {\n              fprintf(stderr, \"ERROR: dstrs_w_values[%u] has wrong num_of_digt (%u): num_of_digt is expected\"\n                              \" to be less or equal to str.len (%u).\\n\",\n                              (unsigned int) i, (unsigned int) t->num_of_digt, (unsigned int) t->str.len);\n              return -1;\n            }\n          rv = 9435223; /* some random value */\n          rs = MHD_str_to_uint64_(t->str.str, &rv);\n          if (rs != t->num_of_digt)\n            {\n              t_failed++;\n              c_failed[i] = !0;\n              fprintf(stderr, \"FAILED: MHD_str_to_uint64_(\\\"%s\\\", ->%\" PRIu64 \") returned %\" PRIuPTR \", while expecting %d.\"\n                      \" Locale: %s\\n\", n_prnt(t->str.str), rv, (intptr_t)rs, (int)t->num_of_digt, get_current_locale_str());\n            }\n          if (rv != t->val)\n            {\n              t_failed++;\n              c_failed[i] = !0;\n              fprintf(stderr, \"FAILED: MHD_str_to_uint64_(\\\"%s\\\", ->%\" PRIu64 \") converted string to value %\" PRIu64 \",\"\n                      \" while expecting result %\" PRIu64 \". Locale: %s\\n\", n_prnt(t->str.str), rv, rv,\n                      t->val, get_current_locale_str());\n            }\n          if (verbose > 1 && j == locale_name_count - 1 && !c_failed[i])\n            printf(\"PASSED: MHD_str_to_uint64_(\\\"%s\\\", ->%\" PRIu64 \") == %\" PRIuPTR \"\\n\",\n                   n_prnt(t->str.str), rv, rs);\n        }\n    }\n  return t_failed;\n}",
      "lines": 52,
      "depth": 16,
      "decorators": [
        "int"
      ]
    },
    "check_str_to_uint64_all_chars": {
      "start_point": [
        1106,
        0
      ],
      "end_point": [
        1161,
        1
      ],
      "content": "int check_str_to_uint64_all_chars(void)\n{\n  static const size_t n_checks = 256; /* from 0 to 255 */\n  int c_failed[n_checks];\n  size_t t_failed = 0;\n  size_t j;\n\n  memset(c_failed, 0, sizeof(c_failed));\n\n  for(j = 0; j < locale_name_count; j++)\n    {\n      unsigned int c;\n      uint64_t test_val;\n\n      set_test_locale(j); /* setlocale() can be slow! */\n      for(c = 0; c < n_checks; c++)\n        {\n          static const uint64_t rnd_val = 24941852;\n          size_t rs;\n          if (c >= '0' && c <= '9')\n            continue; /* skip digits */\n          for(test_val = 0; test_val <= rnd_val&& !c_failed[c]; test_val += rnd_val)\n            {\n              char test_str[] = \"0123\";\n              uint64_t rv = test_val;\n\n              test_str[0] = (char) (unsigned char)c; /* replace first char with non-digit char */\n              rs = MHD_str_to_uint64_(test_str, &rv);\n              if (rs != 0)\n                {\n                  t_failed++;\n                  c_failed[c] = !0;\n                  fprintf(stderr, \"FAILED: MHD_str_to_uint64_(\\\"%s\\\", ->%\" PRIu64 \") returned %\" PRIuPTR \", while expecting zero.\"\n                                  \" Locale: %s\\n\", n_prnt(test_str), rv, (uintptr_t)rs, get_current_locale_str());\n                }\n              else if (rv != test_val)\n                {\n                  t_failed++;\n                  c_failed[c] = !0;\n                  fprintf(stderr, \"FAILED: MHD_str_to_uint64_(\\\"%s\\\", &ret_val) modified value of ret_val\"\n                                  \" (before call: %\" PRIu64 \", after call %\" PRIu64 \"). Locale: %s\\n\",\n                                  n_prnt(test_str), test_val, rv, get_current_locale_str());\n                }\n            }\n          if (verbose > 1 && j == locale_name_count - 1 && !c_failed[c])\n            {\n              char test_str[] = \"0123\";\n              test_str[0] = (char) (unsigned char)c; /* replace first char with non-digit char */\n\n              printf(\"PASSED: MHD_str_to_uint64_(\\\"%s\\\", &ret_val) == 0, value of ret_val is unmodified\\n\",\n                     n_prnt(test_str));\n            }\n        }\n    }\n  return t_failed;\n}",
      "lines": 56,
      "depth": 17,
      "decorators": [
        "int"
      ]
    },
    "check_str_to_uint64_overflow": {
      "start_point": [
        1164,
        0
      ],
      "end_point": [
        1210,
        1
      ],
      "content": "int check_str_to_uint64_overflow(void)\n{\n  size_t t_failed = 0;\n  size_t i, j;\n  static const size_t n_checks = sizeof(str_ovflw) / sizeof(str_ovflw[0]);\n  int c_failed[n_checks];\n\n  memset(c_failed, 0, sizeof(c_failed));\n\n  for(j = 0; j < locale_name_count; j++)\n    {\n      set_test_locale(j); /* setlocale() can be slow! */\n      for(i = 0; i < n_checks; i++)\n        {\n          size_t rs;\n          const struct str_with_len * const t = str_ovflw + i;\n          static const uint64_t rnd_val = 2;\n          uint64_t test_val;\n\n          for(test_val = 0; test_val <= rnd_val && !c_failed[i]; test_val += rnd_val)\n            {\n              uint64_t rv = test_val;\n\n              rs = MHD_str_to_uint64_(t->str, &rv);\n              if (rs != 0)\n                {\n                  t_failed++;\n                  c_failed[i] = !0;\n                  fprintf(stderr, \"FAILED: MHD_str_to_uint64_(\\\"%s\\\", ->%\" PRIu64 \") returned %\" PRIuPTR \", while expecting zero.\"\n                                  \" Locale: %s\\n\", n_prnt(t->str), rv, (uintptr_t)rs, get_current_locale_str());\n                }\n              else if (rv != test_val)\n                {\n                  t_failed++;\n                  c_failed[i] = !0;\n                  fprintf(stderr, \"FAILED: MHD_str_to_uint64_(\\\"%s\\\", &ret_val) modified value of ret_val\"\n                                  \" (before call: %\" PRIu64 \", after call %\" PRIu64 \"). Locale: %s\\n\",\n                                  n_prnt(t->str), test_val, rv, get_current_locale_str());\n                }\n            }\n          if (verbose > 1 && j == locale_name_count - 1 && !c_failed[i])\n            printf(\"PASSED: MHD_str_to_uint64_(\\\"%s\\\", &ret_val) == 0, value of ret_val is unmodified\\n\",\n                   n_prnt(t->str));\n        }\n    }\n  return t_failed;\n}",
      "lines": 47,
      "depth": 18,
      "decorators": [
        "int"
      ]
    },
    "check_str_to_uint64_no_val": {
      "start_point": [
        1213,
        0
      ],
      "end_point": [
        1259,
        1
      ],
      "content": "int check_str_to_uint64_no_val(void)\n{\n  size_t t_failed = 0;\n  size_t i, j;\n  static const size_t n_checks = sizeof(str_no_num) / sizeof(str_no_num[0]);\n  int c_failed[n_checks];\n\n  memset(c_failed, 0, sizeof(c_failed));\n\n  for(j = 0; j < locale_name_count; j++)\n    {\n      set_test_locale(j); /* setlocale() can be slow! */\n      for(i = 0; i < n_checks; i++)\n        {\n          size_t rs;\n          const struct str_with_len * const t = str_no_num + i;\n          static const uint64_t rnd_val = 74218431;\n          uint64_t test_val;\n\n          for(test_val = 0; test_val <= rnd_val && !c_failed[i]; test_val += rnd_val)\n            {\n              uint64_t rv = test_val;\n\n              rs = MHD_str_to_uint64_(t->str, &rv);\n              if (rs != 0)\n                {\n                  t_failed++;\n                  c_failed[i] = !0;\n                  fprintf(stderr, \"FAILED: MHD_str_to_uint64_(\\\"%s\\\", ->%\" PRIu64 \") returned %\" PRIuPTR \", while expecting zero.\"\n                                  \" Locale: %s\\n\", n_prnt(t->str), rv, (uintptr_t)rs, get_current_locale_str());\n                }\n              else if (rv != test_val)\n                {\n                  t_failed++;\n                  c_failed[i] = !0;\n                  fprintf(stderr, \"FAILED: MHD_str_to_uint64_(\\\"%s\\\", &ret_val) modified value of ret_val\"\n                                  \" (before call: %\" PRIu64 \", after call %\" PRIu64 \"). Locale: %s\\n\",\n                                  n_prnt(t->str), test_val, rv, get_current_locale_str());\n                }\n            }\n          if (verbose > 1 && j == locale_name_count - 1 && !c_failed[i])\n            printf(\"PASSED: MHD_str_to_uint64_(\\\"%s\\\", &ret_val) == 0, value of ret_val is unmodified\\n\",\n                   n_prnt(t->str));\n        }\n    }\n  return t_failed;\n}",
      "lines": 47,
      "depth": 18,
      "decorators": [
        "int"
      ]
    },
    "check_str_to_uint64_n_valid": {
      "start_point": [
        1262,
        0
      ],
      "end_point": [
        1317,
        1
      ],
      "content": "int check_str_to_uint64_n_valid(void)\n{\n  size_t t_failed = 0;\n  size_t i, j;\n  static const size_t n_checks = sizeof(dstrs_w_values) / sizeof(dstrs_w_values[0]);\n  int c_failed[n_checks];\n\n  memset(c_failed, 0, sizeof(c_failed));\n\n  for(j = 0; j < locale_name_count; j++)\n    {\n      set_test_locale(j); /* setlocale() can be slow! */\n      for(i = 0; i < n_checks; i++)\n        {\n          uint64_t rv = 1235572; /* some random value */\n          size_t rs = 0;\n          size_t len;\n          const struct str_with_value * const t = dstrs_w_values + i;\n\n          if (t->str.len < t->num_of_digt)\n            {\n              fprintf(stderr, \"ERROR: dstrs_w_values[%u] has wrong num_of_digt (%u): num_of_digt is expected\"\n                              \" to be less or equal to str.len (%u).\\n\",\n                              (unsigned int) i, (unsigned int) t->num_of_digt, (unsigned int) t->str.len);\n              return -1;\n            }\n          for (len = t->num_of_digt; len <= t->str.len + 1 && !c_failed[i]; len++)\n            {\n              rs = MHD_str_to_uint64_n_(t->str.str, len, &rv);\n              if (rs != t->num_of_digt)\n                {\n                  t_failed++;\n                  c_failed[i] = !0;\n                  fprintf(stderr, \"FAILED: MHD_str_to_uint64_n_(\\\"%s\\\", %\" PRIuPTR \", ->%\" PRIu64 \")\"\n                          \" returned %\" PRIuPTR \", while expecting %d. Locale: %s\\n\",\n                          n_prnt(t->str.str), (intptr_t)len, rv, (intptr_t)rs,\n                          (int)t->num_of_digt, get_current_locale_str());\n                }\n              if (rv != t->val)\n                {\n                  t_failed++;\n                  c_failed[i] = !0;\n                  fprintf(stderr, \"FAILED: MHD_str_to_uint64_n_(\\\"%s\\\", %\" PRIuPTR \", ->%\" PRIu64 \")\"\n                          \" converted string to value %\" PRIu64 \", while expecting result %\" PRIu64\n                          \". Locale: %s\\n\", n_prnt(t->str.str), (intptr_t)len, rv, rv,\n                          t->val, get_current_locale_str());\n                }\n            }\n          if (verbose > 1 && j == locale_name_count - 1 && !c_failed[i])\n            printf(\"PASSED: MHD_str_to_uint64_n_(\\\"%s\\\", %\" PRIuPTR \"..%\" PRIuPTR \", ->%\" PRIu64 \")\"\n                   \" == %\" PRIuPTR \"\\n\", n_prnt(t->str.str), (intptr_t)t->num_of_digt,\n                   (intptr_t)t->str.len + 1, rv, rs);\n        }\n    }\n  return t_failed;\n}",
      "lines": 56,
      "depth": 18,
      "decorators": [
        "int"
      ]
    },
    "check_str_to_uint64_n_all_chars": {
      "start_point": [
        1320,
        0
      ],
      "end_point": [
        1383,
        1
      ],
      "content": "int check_str_to_uint64_n_all_chars(void)\n{\n  static const size_t n_checks = 256; /* from 0 to 255 */\n  int c_failed[n_checks];\n  size_t t_failed = 0;\n  size_t j;\n\n  memset(c_failed, 0, sizeof(c_failed));\n\n  for(j = 0; j < locale_name_count; j++)\n    {\n      unsigned int c;\n      uint64_t test_val;\n\n      set_test_locale(j); /* setlocale() can be slow! */\n      for(c = 0; c < n_checks; c++)\n        {\n          static const uint64_t rnd_val = 98372558;\n          size_t rs;\n          size_t len;\n\n          if (c >= '0' && c <= '9')\n            continue; /* skip digits */\n\n          for (len = 0; len <= 5; len++)\n            {\n              for(test_val = 0; test_val <= rnd_val&& !c_failed[c]; test_val += rnd_val)\n                {\n                  char test_str[] = \"0123\";\n                  uint64_t rv = test_val;\n\n                  test_str[0] = (char) (unsigned char)c; /* replace first char with non-digit char */\n                  rs = MHD_str_to_uint64_n_(test_str, len, &rv);\n                  if (rs != 0)\n                    {\n                      t_failed++;\n                      c_failed[c] = !0;\n                      fprintf(stderr, \"FAILED: MHD_str_to_uint64_n_(\\\"%s\\\", %\" PRIuPTR \", ->%\" PRIu64 \")\"\n                              \" returned %\" PRIuPTR \", while expecting zero. Locale: %s\\n\",\n                              n_prnt(test_str), (uintptr_t)len, rv, (uintptr_t)rs, get_current_locale_str());\n                    }\n                  else if (rv != test_val)\n                    {\n                      t_failed++;\n                      c_failed[c] = !0;\n                      fprintf(stderr, \"FAILED: MHD_str_to_uint64_n_(\\\"%s\\\", %\" PRIuPTR \", &ret_val)\"\n                              \" modified value of ret_val (before call: %\" PRIu64 \", after call %\" PRIu64 \").\"\n                              \" Locale: %s\\n\",\n                              n_prnt(test_str), (uintptr_t)len, test_val, rv, get_current_locale_str());\n                    }\n                }\n            }\n          if (verbose > 1 && j == locale_name_count - 1 && !c_failed[c])\n            {\n              char test_str[] = \"0123\";\n              test_str[0] = (char) (unsigned char)c; /* replace first char with non-digit char */\n\n              printf(\"PASSED: MHD_str_to_uint64_n_(\\\"%s\\\", 0..5, &ret_val) == 0, value of ret_val is unmodified\\n\",\n                     n_prnt(test_str));\n            }\n        }\n    }\n  return t_failed;\n}",
      "lines": 64,
      "depth": 19,
      "decorators": [
        "int"
      ]
    },
    "check_str_to_uint64_n_overflow": {
      "start_point": [
        1386,
        0
      ],
      "end_point": [
        1439,
        1
      ],
      "content": "int check_str_to_uint64_n_overflow(void)\n{\n  size_t t_failed = 0;\n  size_t i, j;\n  static const size_t n_checks = sizeof(str_ovflw) / sizeof(str_ovflw[0]);\n  int c_failed[n_checks];\n\n  memset(c_failed, 0, sizeof(c_failed));\n\n  for(j = 0; j < locale_name_count; j++)\n    {\n      set_test_locale(j); /* setlocale() can be slow! */\n      for(i = 0; i < n_checks; i++)\n        {\n          size_t rs;\n          const struct str_with_len * const t = str_ovflw + i;\n          static const uint64_t rnd_val = 3;\n          size_t len;\n\n          for (len = t->len; len <= t->len + 1; len++)\n            {\n              uint64_t test_val;\n              for(test_val = 0; test_val <= rnd_val && !c_failed[i]; test_val += rnd_val)\n                {\n                  uint64_t rv = test_val;\n\n                  rs = MHD_str_to_uint64_n_(t->str, len, &rv);\n                  if (rs != 0)\n                    {\n                      t_failed++;\n                      c_failed[i] = !0;\n                      fprintf(stderr, \"FAILED: MHD_str_to_uint64_n_(\\\"%s\\\", %\" PRIuPTR \", ->%\" PRIu64 \")\"\n                              \" returned %\" PRIuPTR \", while expecting zero. Locale: %s\\n\",\n                              n_prnt(t->str), (uintptr_t)len, rv, (uintptr_t)rs, get_current_locale_str());\n                    }\n                  else if (rv != test_val)\n                    {\n                      t_failed++;\n                      c_failed[i] = !0;\n                      fprintf(stderr, \"FAILED: MHD_str_to_uint64_n_(\\\"%s\\\", %\" PRIuPTR \", &ret_val)\"\n                              \" modified value of ret_val (before call: %\" PRIu64 \", after call %\" PRIu64 \").\"\n                              \" Locale: %s\\n\", n_prnt(t->str), (uintptr_t)len, test_val, rv,\n                              get_current_locale_str());\n                    }\n                }\n            }\n          if (verbose > 1 && j == locale_name_count - 1 && !c_failed[i])\n            printf(\"PASSED: MHD_str_to_uint64_n_(\\\"%s\\\", %\" PRIuPTR \"..%\" PRIuPTR \", &ret_val) == 0,\"\n                   \" value of ret_val is unmodified\\n\", n_prnt(t->str), (uintptr_t)t->len,\n                   (uintptr_t)t->len + 1);\n        }\n    }\n  return t_failed;\n}",
      "lines": 54,
      "depth": 20,
      "decorators": [
        "int"
      ]
    },
    "check_str_to_uint64_n_no_val": {
      "start_point": [
        1442,
        0
      ],
      "end_point": [
        1495,
        1
      ],
      "content": "int check_str_to_uint64_n_no_val(void)\n{\n  size_t t_failed = 0;\n  size_t i, j;\n  static const size_t n_checks = sizeof(str_no_num) / sizeof(str_no_num[0]);\n  int c_failed[n_checks];\n\n  memset(c_failed, 0, sizeof(c_failed));\n\n  for(j = 0; j < locale_name_count; j++)\n    {\n      set_test_locale(j); /* setlocale() can be slow! */\n      for(i = 0; i < n_checks; i++)\n        {\n          size_t rs;\n          const struct str_with_len * const t = str_no_num + i;\n          static const uint64_t rnd_val = 43255654342;\n          size_t len;\n\n          for (len = 0; len <= t->len + 1; len++)\n            {\n              uint64_t test_val;\n              for(test_val = 0; test_val <= rnd_val && !c_failed[i]; test_val += rnd_val)\n                {\n                  uint64_t rv = test_val;\n\n                  rs = MHD_str_to_uint64_n_(t->str, len, &rv);\n                  if (rs != 0)\n                    {\n                      t_failed++;\n                      c_failed[i] = !0;\n                      fprintf(stderr, \"FAILED: MHD_str_to_uint64_n_(\\\"%s\\\", %\" PRIuPTR \", ->%\" PRIu64 \")\"\n                              \" returned %\" PRIuPTR \", while expecting zero. Locale: %s\\n\",\n                              n_prnt(t->str), (uintptr_t)len, rv, (uintptr_t)rs, get_current_locale_str());\n                    }\n                  else if (rv != test_val)\n                    {\n                      t_failed++;\n                      c_failed[i] = !0;\n                      fprintf(stderr, \"FAILED: MHD_str_to_uint64_n_(\\\"%s\\\", %\" PRIuPTR \", &ret_val)\"\n                              \" modified value of ret_val (before call: %\" PRIu64 \", after call %\" PRIu64 \").\"\n                              \" Locale: %s\\n\", n_prnt(t->str), (uintptr_t)len, test_val, rv,\n                              get_current_locale_str());\n                    }\n                }\n            }\n          if (verbose > 1 && j == locale_name_count - 1 && !c_failed[i])\n            printf(\"PASSED: MHD_str_to_uint64_n_(\\\"%s\\\", 0..%\" PRIuPTR \", &ret_val) == 0,\"\n                   \" value of ret_val is unmodified\\n\", n_prnt(t->str),\n                   (uintptr_t)t->len + 1);\n        }\n    }\n  return t_failed;\n}",
      "lines": 54,
      "depth": 20,
      "decorators": [
        "int"
      ]
    },
    "check_strx_to_uint32_valid": {
      "start_point": [
        1498,
        0
      ],
      "end_point": [
        1552,
        1
      ],
      "content": "int check_strx_to_uint32_valid(void)\n{\n  size_t t_failed = 0;\n  size_t i, j;\n  static const size_t n_checks = sizeof(xdstrs_w_values) / sizeof(xdstrs_w_values[0]);\n  int c_failed[n_checks];\n\n  memset(c_failed, 0, sizeof(c_failed));\n\n  for(j = 0; j < locale_name_count; j++)\n    {\n      set_test_locale(j); /* setlocale() can be slow! */\n      for(i = 0; i < n_checks; i++)\n        {\n          uint32_t rv;\n          size_t rs;\n          const struct str_with_value * const t = xdstrs_w_values + i;\n\n          if (t->val > UINT32_MAX)\n            continue; /* number is too high for this function */\n\n          if (c_failed[i])\n            continue; /* skip already failed checks */\n\n          if (t->str.len < t->num_of_digt)\n            {\n              fprintf(stderr, \"ERROR: xdstrs_w_values[%u] has wrong num_of_digt (%u): num_of_digt is expected\"\n                              \" to be less or equal to str.len (%u).\\n\",\n                              (unsigned int) i, (unsigned int) t->num_of_digt, (unsigned int) t->str.len);\n              return -1;\n            }\n          rv = 1458532; /* some random value */\n          rs = MHD_strx_to_uint32_(t->str.str, &rv);\n          if (rs != t->num_of_digt)\n            {\n              t_failed++;\n              c_failed[i] = !0;\n              fprintf(stderr, \"FAILED: MHD_strx_to_uint32_(\\\"%s\\\", ->0x%\" PRIX64 \") returned %\" PRIuPTR \", while expecting %d.\"\n                      \" Locale: %s\\n\", n_prnt(t->str.str), (uint64_t)rv, (intptr_t)rs, (int)t->num_of_digt, get_current_locale_str());\n            }\n          if (rv != t->val)\n            {\n              t_failed++;\n              c_failed[i] = !0;\n              fprintf(stderr, \"FAILED: MHD_strx_to_uint32_(\\\"%s\\\", ->0x%\" PRIX64 \") converted string to value 0x%\" PRIX64 \",\"\n                      \" while expecting result 0x%\" PRIX64 \". Locale: %s\\n\", n_prnt(t->str.str), (uint64_t)rv, (uint64_t)rv,\n                      t->val, get_current_locale_str());\n            }\n          if (verbose > 1 && j == locale_name_count - 1 && !c_failed[i])\n            printf(\"PASSED: MHD_strx_to_uint32_(\\\"%s\\\", ->0x%\" PRIX64 \") == %\" PRIuPTR \"\\n\",\n                   n_prnt(t->str.str), (uint64_t)rv, rs);\n        }\n    }\n  return t_failed;\n}",
      "lines": 55,
      "depth": 16,
      "decorators": [
        "int"
      ]
    },
    "check_strx_to_uint32_all_chars": {
      "start_point": [
        1555,
        0
      ],
      "end_point": [
        1610,
        1
      ],
      "content": "int check_strx_to_uint32_all_chars(void)\n{\n  static const size_t n_checks = 256; /* from 0 to 255 */\n  int c_failed[n_checks];\n  size_t t_failed = 0;\n  size_t j;\n\n  memset(c_failed, 0, sizeof(c_failed));\n\n  for(j = 0; j < locale_name_count; j++)\n    {\n      unsigned int c;\n      uint32_t test_val;\n\n      set_test_locale(j); /* setlocale() can be slow! */\n      for(c = 0; c < n_checks; c++)\n        {\n          static const uint32_t rnd_val = 234234;\n          size_t rs;\n          if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') ||(c >= 'a' && c <= 'f'))\n            continue; /* skip xdigits */\n          for(test_val = 0; test_val <= rnd_val&& !c_failed[c]; test_val += rnd_val)\n            {\n              char test_str[] = \"0123\";\n              uint32_t rv = test_val;\n\n              test_str[0] = (char) (unsigned char)c; /* replace first char with non-digit char */\n              rs = MHD_strx_to_uint32_(test_str, &rv);\n              if (rs != 0)\n                {\n                  t_failed++;\n                  c_failed[c] = !0;\n                  fprintf(stderr, \"FAILED: MHD_strx_to_uint32_(\\\"%s\\\", ->0x%\" PRIX64 \") returned %\" PRIuPTR \", while expecting zero.\"\n                                  \" Locale: %s\\n\", n_prnt(test_str), (uint64_t)rv, (uintptr_t)rs, get_current_locale_str());\n                }\n              else if (rv != test_val)\n                {\n                  t_failed++;\n                  c_failed[c] = !0;\n                  fprintf(stderr, \"FAILED: MHD_strx_to_uint32_(\\\"%s\\\", &ret_val) modified value of ret_val\"\n                                  \" (before call: 0x%\" PRIX64 \", after call 0x%\" PRIX64 \"). Locale: %s\\n\",\n                                  n_prnt(test_str), (uint64_t)test_val, (uint64_t)rv, get_current_locale_str());\n                }\n            }\n          if (verbose > 1 && j == locale_name_count - 1 && !c_failed[c])\n            {\n              char test_str[] = \"0123\";\n              test_str[0] = (char) (unsigned char)c; /* replace first char with non-digit char */\n\n              printf(\"PASSED: MHD_strx_to_uint32_(\\\"%s\\\", &ret_val) == 0, value of ret_val is unmodified\\n\",\n                     n_prnt(test_str));\n            }\n        }\n    }\n  return t_failed;\n}",
      "lines": 56,
      "depth": 17,
      "decorators": [
        "int"
      ]
    },
    "check_strx_to_uint32_overflow": {
      "start_point": [
        1613,
        0
      ],
      "end_point": [
        1674,
        1
      ],
      "content": "int check_strx_to_uint32_overflow(void)\n{\n  size_t t_failed = 0;\n  size_t i, j;\n  static const size_t n_checks1 = sizeof(strx_ovflw) / sizeof(strx_ovflw[0]);\n  static const size_t n_checks = sizeof(strx_ovflw) / sizeof(strx_ovflw[0]) +\n                                 sizeof(xdstrs_w_values) / sizeof(xdstrs_w_values[0]);\n  int c_failed[n_checks];\n\n  memset(c_failed, 0, sizeof(c_failed));\n\n  for(j = 0; j < locale_name_count; j++)\n    {\n      set_test_locale(j); /* setlocale() can be slow! */\n      for(i = 0; i < n_checks; i++)\n        {\n          size_t rs;\n          static const uint32_t rnd_val = 74218431;\n          uint32_t test_val;\n          const char * str;\n          if (i < n_checks1)\n            {\n              const struct str_with_len * const t = strx_ovflw + i;\n              str = t->str;\n            }\n          else\n            {\n              const struct str_with_value * const t = xdstrs_w_values + (i - n_checks1);\n              if (t->val <= UINT32_MAX)\n                continue; /* check only strings that should overflow uint32_t */\n              str = t->str.str;\n            }\n\n\n          for(test_val = 0; test_val <= rnd_val && !c_failed[i]; test_val += rnd_val)\n            {\n              uint32_t rv = test_val;\n\n              rs = MHD_strx_to_uint32_(str, &rv);\n              if (rs != 0)\n                {\n                  t_failed++;\n                  c_failed[i] = !0;\n                  fprintf(stderr, \"FAILED: MHD_strx_to_uint32_(\\\"%s\\\", ->0x%\" PRIX64 \") returned %\" PRIuPTR \", while expecting zero.\"\n                                  \" Locale: %s\\n\", n_prnt(str), (uint64_t)rv, (uintptr_t)rs, get_current_locale_str());\n                }\n              else if (rv != test_val)\n                {\n                  t_failed++;\n                  c_failed[i] = !0;\n                  fprintf(stderr, \"FAILED: MHD_strx_to_uint32_(\\\"%s\\\", &ret_val) modified value of ret_val\"\n                                  \" (before call: 0x%\" PRIX64 \", after call 0x%\" PRIX64 \"). Locale: %s\\n\",\n                                  n_prnt(str), (uint64_t)test_val, (uint64_t)rv, get_current_locale_str());\n                }\n            }\n          if (verbose > 1 && j == locale_name_count - 1 && !c_failed[i])\n            printf(\"PASSED: MHD_strx_to_uint32_(\\\"%s\\\", &ret_val) == 0, value of ret_val is unmodified\\n\",\n                   n_prnt(str));\n        }\n    }\n  return t_failed;\n}",
      "lines": 62,
      "depth": 17,
      "decorators": [
        "int"
      ]
    },
    "check_strx_to_uint32_no_val": {
      "start_point": [
        1677,
        0
      ],
      "end_point": [
        1723,
        1
      ],
      "content": "int check_strx_to_uint32_no_val(void)\n{\n  size_t t_failed = 0;\n  size_t i, j;\n  static const size_t n_checks = sizeof(str_no_num) / sizeof(str_no_num[0]);\n  int c_failed[n_checks];\n\n  memset(c_failed, 0, sizeof(c_failed));\n\n  for(j = 0; j < locale_name_count; j++)\n    {\n      set_test_locale(j); /* setlocale() can be slow! */\n      for(i = 0; i < n_checks; i++)\n        {\n          size_t rs;\n          const struct str_with_len * const t = str_no_num + i;\n          static const uint32_t rnd_val = 74218431;\n          uint32_t test_val;\n\n          for(test_val = 0; test_val <= rnd_val && !c_failed[i]; test_val += rnd_val)\n            {\n              uint32_t rv = test_val;\n\n              rs = MHD_strx_to_uint32_(t->str, &rv);\n              if (rs != 0)\n                {\n                  t_failed++;\n                  c_failed[i] = !0;\n                  fprintf(stderr, \"FAILED: MHD_strx_to_uint32_(\\\"%s\\\", ->0x%\" PRIX64 \") returned %\" PRIuPTR \", while expecting zero.\"\n                                  \" Locale: %s\\n\", n_prnt(t->str), (uint64_t)rv, (uintptr_t)rs, get_current_locale_str());\n                }\n              else if (rv != test_val)\n                {\n                  t_failed++;\n                  c_failed[i] = !0;\n                  fprintf(stderr, \"FAILED: MHD_strx_to_uint32_(\\\"%s\\\", &ret_val) modified value of ret_val\"\n                                  \" (before call: 0x%\" PRIX64 \", after call 0x%\" PRIX64 \"). Locale: %s\\n\",\n                                  n_prnt(t->str), (uint64_t)test_val, (uint64_t)rv, get_current_locale_str());\n                }\n            }\n          if (verbose > 1 && j == locale_name_count - 1 && !c_failed[i])\n            printf(\"PASSED: MHD_strx_to_uint32_(\\\"%s\\\", &ret_val) == 0, value of ret_val is unmodified\\n\",\n                   n_prnt(t->str));\n        }\n    }\n  return t_failed;\n}",
      "lines": 47,
      "depth": 18,
      "decorators": [
        "int"
      ]
    },
    "check_strx_to_uint32_n_valid": {
      "start_point": [
        1726,
        0
      ],
      "end_point": [
        1784,
        1
      ],
      "content": "int check_strx_to_uint32_n_valid(void)\n{\n  size_t t_failed = 0;\n  size_t i, j;\n  static const size_t n_checks = sizeof(xdstrs_w_values) / sizeof(xdstrs_w_values[0]);\n  int c_failed[n_checks];\n\n  memset(c_failed, 0, sizeof(c_failed));\n\n  for(j = 0; j < locale_name_count; j++)\n    {\n      set_test_locale(j); /* setlocale() can be slow! */\n      for(i = 0; i < n_checks; i++)\n        {\n          uint32_t rv = 2352932;  /* some random value */\n          size_t rs = 0;\n          size_t len;\n          const struct str_with_value * const t = xdstrs_w_values + i;\n\n          if (t->val > UINT32_MAX)\n            continue; /* number is too high for this function */\n\n          if (t->str.len < t->num_of_digt)\n            {\n              fprintf(stderr, \"ERROR: xdstrs_w_values[%u] has wrong num_of_digt (%u): num_of_digt is expected\"\n                              \" to be less or equal to str.len (%u).\\n\",\n                              (unsigned int) i, (unsigned int) t->num_of_digt, (unsigned int) t->str.len);\n              return -1;\n            }\n          for (len = t->num_of_digt; len <= t->str.len + 1 && !c_failed[i]; len++)\n            {\n              rs = MHD_strx_to_uint32_n_(t->str.str, len, &rv);\n              if (rs != t->num_of_digt)\n                {\n                  t_failed++;\n                  c_failed[i] = !0;\n                  fprintf(stderr, \"FAILED: MHD_strx_to_uint32_n_(\\\"%s\\\", %\" PRIuPTR \", ->0x%\" PRIX64 \")\"\n                          \" returned %\" PRIuPTR \", while expecting %d. Locale: %s\\n\",\n                          n_prnt(t->str.str), (intptr_t)len, (uint64_t)rv, (intptr_t)rs,\n                          (int)t->num_of_digt, get_current_locale_str());\n                }\n              if (rv != t->val)\n                {\n                  t_failed++;\n                  c_failed[i] = !0;\n                  fprintf(stderr, \"FAILED: MHD_strx_to_uint32_n_(\\\"%s\\\", %\" PRIuPTR \", ->0x%\" PRIX64 \")\"\n                          \" converted string to value 0x%\" PRIX64 \", while expecting result 0x%\" PRIX64\n                          \". Locale: %s\\n\", n_prnt(t->str.str), (intptr_t)len, (uint64_t)rv, (uint64_t)rv,\n                          t->val, get_current_locale_str());\n                }\n            }\n          if (verbose > 1 && j == locale_name_count - 1 && !c_failed[i])\n            printf(\"PASSED: MHD_strx_to_uint32_n_(\\\"%s\\\", %\" PRIuPTR \"..%\" PRIuPTR \", ->0x%\" PRIX64 \")\"\n                   \" == %\" PRIuPTR \"\\n\", n_prnt(t->str.str), (intptr_t)t->num_of_digt,\n                   (intptr_t)t->str.len + 1, (uint64_t)rv, rs);\n        }\n    }\n  return t_failed;\n}",
      "lines": 59,
      "depth": 18,
      "decorators": [
        "int"
      ]
    },
    "check_strx_to_uint32_n_all_chars": {
      "start_point": [
        1787,
        0
      ],
      "end_point": [
        1850,
        1
      ],
      "content": "int check_strx_to_uint32_n_all_chars(void)\n{\n  static const size_t n_checks = 256; /* from 0 to 255 */\n  int c_failed[n_checks];\n  size_t t_failed = 0;\n  size_t j;\n\n  memset(c_failed, 0, sizeof(c_failed));\n\n  for(j = 0; j < locale_name_count; j++)\n    {\n      unsigned int c;\n      uint32_t test_val;\n\n      set_test_locale(j); /* setlocale() can be slow! */\n      for(c = 0; c < n_checks; c++)\n        {\n          static const uint32_t rnd_val = 98372558;\n          size_t rs;\n          size_t len;\n\n          if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'))\n            continue; /* skip xdigits */\n\n          for (len = 0; len <= 5; len++)\n            {\n              for(test_val = 0; test_val <= rnd_val&& !c_failed[c]; test_val += rnd_val)\n                {\n                  char test_str[] = \"0123\";\n                  uint32_t rv = test_val;\n\n                  test_str[0] = (char) (unsigned char)c; /* replace first char with non-digit char */\n                  rs = MHD_strx_to_uint32_n_(test_str, len, &rv);\n                  if (rs != 0)\n                    {\n                      t_failed++;\n                      c_failed[c] = !0;\n                      fprintf(stderr, \"FAILED: MHD_strx_to_uint32_n_(\\\"%s\\\", %\" PRIuPTR \", ->0x%\" PRIX64 \")\"\n                              \" returned %\" PRIuPTR \", while expecting zero. Locale: %s\\n\",\n                              n_prnt(test_str), (uintptr_t)len, (uint64_t)rv, (uintptr_t)rs, get_current_locale_str());\n                    }\n                  else if (rv != test_val)\n                    {\n                      t_failed++;\n                      c_failed[c] = !0;\n                      fprintf(stderr, \"FAILED: MHD_strx_to_uint32_n_(\\\"%s\\\", %\" PRIuPTR \", &ret_val)\"\n                              \" modified value of ret_val (before call: 0x%\" PRIX64 \", after call 0x%\" PRIX64 \").\"\n                              \" Locale: %s\\n\",\n                              n_prnt(test_str), (uintptr_t)len, (uint64_t)test_val, (uint64_t)rv, get_current_locale_str());\n                    }\n                }\n            }\n          if (verbose > 1 && j == locale_name_count - 1 && !c_failed[c])\n            {\n              char test_str[] = \"0123\";\n              test_str[0] = (char) (unsigned char)c; /* replace first char with non-digit char */\n\n              printf(\"PASSED: MHD_strx_to_uint32_n_(\\\"%s\\\", 0..5, &ret_val) == 0, value of ret_val is unmodified\\n\",\n                     n_prnt(test_str));\n            }\n        }\n    }\n  return t_failed;\n}",
      "lines": 64,
      "depth": 19,
      "decorators": [
        "int"
      ]
    },
    "check_strx_to_uint32_n_overflow": {
      "start_point": [
        1853,
        0
      ],
      "end_point": [
        1934,
        1
      ],
      "content": "int check_strx_to_uint32_n_overflow(void)\n{\n  size_t t_failed = 0;\n  size_t i, j;\n  static const size_t n_checks1 = sizeof(strx_ovflw) / sizeof(strx_ovflw[0]);\n  static const size_t n_checks = sizeof(strx_ovflw) / sizeof(strx_ovflw[0]) +\n                                 sizeof(xdstrs_w_values) / sizeof(xdstrs_w_values[0]);\n  int c_failed[n_checks];\n\n  memset(c_failed, 0, sizeof(c_failed));\n\n  for(j = 0; j < locale_name_count; j++)\n    {\n      set_test_locale(j); /* setlocale() can be slow! */\n      for(i = 0; i < n_checks; i++)\n        {\n          size_t rs;\n          static const uint32_t rnd_val = 4;\n          size_t len;\n          const char * str;\n          size_t min_len, max_len;\n          if (i < n_checks1)\n            {\n              const struct str_with_len * const t = strx_ovflw + i;\n              str = t->str;\n              min_len = t->len;\n              max_len = t->len + 1;\n            }\n          else\n            {\n              const struct str_with_value * const t = xdstrs_w_values + (i - n_checks1);\n              if (t->val <= UINT32_MAX)\n                continue; /* check only strings that should overflow uint32_t */\n\n              if (t->str.len < t->num_of_digt)\n                {\n                  fprintf(stderr, \"ERROR: xdstrs_w_values[%u] has wrong num_of_digt (%u): num_of_digt is expected\"\n                                  \" to be less or equal to str.len (%u).\\n\",\n                                  (unsigned int) (i - n_checks1), (unsigned int) t->num_of_digt,\n                                  (unsigned int) t->str.len);\n                  return -1;\n                }\n              str = t->str.str;\n              min_len = t->num_of_digt;\n              max_len = t->str.len + 1;\n            }\n\n          for (len = min_len; len <= max_len; len++)\n            {\n              uint32_t test_val;\n              for(test_val = 0; test_val <= rnd_val && !c_failed[i]; test_val += rnd_val)\n                {\n                  uint32_t rv = test_val;\n\n                  rs = MHD_strx_to_uint32_n_(str, len, &rv);\n                  if (rs != 0)\n                    {\n                      t_failed++;\n                      c_failed[i] = !0;\n                      fprintf(stderr, \"FAILED: MHD_strx_to_uint32_n_(\\\"%s\\\", %\" PRIuPTR \", ->0x%\" PRIX64 \")\"\n                              \" returned %\" PRIuPTR \", while expecting zero. Locale: %s\\n\",\n                              n_prnt(str), (uintptr_t)len, (uint64_t)rv, (uintptr_t)rs, get_current_locale_str());\n                    }\n                  else if (rv != test_val)\n                    {\n                      t_failed++;\n                      c_failed[i] = !0;\n                      fprintf(stderr, \"FAILED: MHD_strx_to_uint32_n_(\\\"%s\\\", %\" PRIuPTR \", &ret_val)\"\n                              \" modified value of ret_val (before call: 0x%\" PRIX64 \", after call 0x%\" PRIX64 \").\"\n                              \" Locale: %s\\n\", n_prnt(str), (uintptr_t)len, (uint64_t)test_val, (uint64_t)rv,\n                              get_current_locale_str());\n                    }\n                }\n            }\n          if (verbose > 1 && j == locale_name_count - 1 && !c_failed[i])\n            printf(\"PASSED: MHD_strx_to_uint32_n_(\\\"%s\\\", %\" PRIuPTR \"..%\" PRIuPTR \", &ret_val) == 0,\"\n                   \" value of ret_val is unmodified\\n\", n_prnt(str), (uintptr_t)min_len,\n                   (uintptr_t)max_len);\n        }\n    }\n  return t_failed;\n}",
      "lines": 82,
      "depth": 19,
      "decorators": [
        "int"
      ]
    },
    "check_strx_to_uint32_n_no_val": {
      "start_point": [
        1937,
        0
      ],
      "end_point": [
        1990,
        1
      ],
      "content": "int check_strx_to_uint32_n_no_val(void)\n{\n  size_t t_failed = 0;\n  size_t i, j;\n  static const size_t n_checks = sizeof(str_no_num) / sizeof(str_no_num[0]);\n  int c_failed[n_checks];\n\n  memset(c_failed, 0, sizeof(c_failed));\n\n  for(j = 0; j < locale_name_count; j++)\n    {\n      set_test_locale(j); /* setlocale() can be slow! */\n      for(i = 0; i < n_checks; i++)\n        {\n          size_t rs;\n          const struct str_with_len * const t = str_no_num + i;\n          static const uint32_t rnd_val = 3214314212UL;\n          size_t len;\n\n          for (len = 0; len <= t->len + 1; len++)\n            {\n              uint32_t test_val;\n              for(test_val = 0; test_val <= rnd_val && !c_failed[i]; test_val += rnd_val)\n                {\n                  uint32_t rv = test_val;\n\n                  rs = MHD_strx_to_uint32_n_(t->str, len, &rv);\n                  if (rs != 0)\n                    {\n                      t_failed++;\n                      c_failed[i] = !0;\n                      fprintf(stderr, \"FAILED: MHD_strx_to_uint32_n_(\\\"%s\\\", %\" PRIuPTR \", ->0x%\" PRIX64 \")\"\n                              \" returned %\" PRIuPTR \", while expecting zero. Locale: %s\\n\",\n                              n_prnt(t->str), (uintptr_t)len, (uint64_t)rv, (uintptr_t)rs, get_current_locale_str());\n                    }\n                  else if (rv != test_val)\n                    {\n                      t_failed++;\n                      c_failed[i] = !0;\n                      fprintf(stderr, \"FAILED: MHD_strx_to_uint32_n_(\\\"%s\\\", %\" PRIuPTR \", &ret_val)\"\n                              \" modified value of ret_val (before call: 0x%\" PRIX64 \", after call 0x%\" PRIX64 \").\"\n                              \" Locale: %s\\n\", n_prnt(t->str), (uintptr_t)len, (uint64_t)test_val, (uint64_t)rv,\n                              get_current_locale_str());\n                    }\n                }\n            }\n          if (verbose > 1 && j == locale_name_count - 1 && !c_failed[i])\n            printf(\"PASSED: MHD_strx_to_uint32_n_(\\\"%s\\\", 0..%\" PRIuPTR \", &ret_val) == 0,\"\n                   \" value of ret_val is unmodified\\n\", n_prnt(t->str),\n                   (uintptr_t)t->len + 1);\n        }\n    }\n  return t_failed;\n}",
      "lines": 54,
      "depth": 20,
      "decorators": [
        "int"
      ]
    },
    "check_strx_to_uint64_valid": {
      "start_point": [
        1993,
        0
      ],
      "end_point": [
        2044,
        1
      ],
      "content": "int check_strx_to_uint64_valid(void)\n{\n  size_t t_failed = 0;\n  size_t i, j;\n  static const size_t n_checks = sizeof(xdstrs_w_values) / sizeof(xdstrs_w_values[0]);\n  int c_failed[n_checks];\n\n  memset(c_failed, 0, sizeof(c_failed));\n\n  for(j = 0; j < locale_name_count; j++)\n    {\n      set_test_locale(j); /* setlocale() can be slow! */\n      for(i = 0; i < n_checks; i++)\n        {\n          uint64_t rv;\n          size_t rs;\n          const struct str_with_value * const t = xdstrs_w_values + i;\n\n          if (c_failed[i])\n            continue; /* skip already failed checks */\n\n          if (t->str.len < t->num_of_digt)\n            {\n              fprintf(stderr, \"ERROR: xdstrs_w_values[%u] has wrong num_of_digt (%u): num_of_digt is expected\"\n                              \" to be less or equal to str.len (%u).\\n\",\n                              (unsigned int) i, (unsigned int) t->num_of_digt, (unsigned int) t->str.len);\n              return -1;\n            }\n          rv = 1458532; /* some random value */\n          rs = MHD_strx_to_uint64_(t->str.str, &rv);\n          if (rs != t->num_of_digt)\n            {\n              t_failed++;\n              c_failed[i] = !0;\n              fprintf(stderr, \"FAILED: MHD_strx_to_uint64_(\\\"%s\\\", ->0x%\" PRIX64 \") returned %\" PRIuPTR \", while expecting %d.\"\n                      \" Locale: %s\\n\", n_prnt(t->str.str), rv, (intptr_t)rs, (int)t->num_of_digt, get_current_locale_str());\n            }\n          if (rv != t->val)\n            {\n              t_failed++;\n              c_failed[i] = !0;\n              fprintf(stderr, \"FAILED: MHD_strx_to_uint64_(\\\"%s\\\", ->0x%\" PRIX64 \") converted string to value 0x%\" PRIX64 \",\"\n                      \" while expecting result 0x%\" PRIX64 \". Locale: %s\\n\", n_prnt(t->str.str), rv, rv,\n                      t->val, get_current_locale_str());\n            }\n          if (verbose > 1 && j == locale_name_count - 1 && !c_failed[i])\n            printf(\"PASSED: MHD_strx_to_uint64_(\\\"%s\\\", ->0x%\" PRIX64 \") == %\" PRIuPTR \"\\n\",\n                   n_prnt(t->str.str), rv, rs);\n        }\n    }\n  return t_failed;\n}",
      "lines": 52,
      "depth": 16,
      "decorators": [
        "int"
      ]
    },
    "check_strx_to_uint64_all_chars": {
      "start_point": [
        2047,
        0
      ],
      "end_point": [
        2102,
        1
      ],
      "content": "int check_strx_to_uint64_all_chars(void)\n{\n  static const size_t n_checks = 256; /* from 0 to 255 */\n  int c_failed[n_checks];\n  size_t t_failed = 0;\n  size_t j;\n\n  memset(c_failed, 0, sizeof(c_failed));\n\n  for(j = 0; j < locale_name_count; j++)\n    {\n      unsigned int c;\n      uint64_t test_val;\n\n      set_test_locale(j); /* setlocale() can be slow! */\n      for(c = 0; c < n_checks; c++)\n        {\n          static const uint64_t rnd_val = 234234;\n          size_t rs;\n          if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'))\n            continue; /* skip xdigits */\n          for(test_val = 0; test_val <= rnd_val&& !c_failed[c]; test_val += rnd_val)\n            {\n              char test_str[] = \"0123\";\n              uint64_t rv = test_val;\n\n              test_str[0] = (char) (unsigned char)c; /* replace first char with non-digit char */\n              rs = MHD_strx_to_uint64_(test_str, &rv);\n              if (rs != 0)\n                {\n                  t_failed++;\n                  c_failed[c] = !0;\n                  fprintf(stderr, \"FAILED: MHD_strx_to_uint64_(\\\"%s\\\", ->0x%\" PRIX64 \") returned %\" PRIuPTR \", while expecting zero.\"\n                                  \" Locale: %s\\n\", n_prnt(test_str), rv, (uintptr_t)rs, get_current_locale_str());\n                }\n              else if (rv != test_val)\n                {\n                  t_failed++;\n                  c_failed[c] = !0;\n                  fprintf(stderr, \"FAILED: MHD_strx_to_uint64_(\\\"%s\\\", &ret_val) modified value of ret_val\"\n                                  \" (before call: 0x%\" PRIX64 \", after call 0x%\" PRIX64 \"). Locale: %s\\n\",\n                                  n_prnt(test_str), test_val, rv, get_current_locale_str());\n                }\n            }\n          if (verbose > 1 && j == locale_name_count - 1 && !c_failed[c])\n            {\n              char test_str[] = \"0123\";\n              test_str[0] = (char) (unsigned char)c; /* replace first char with non-digit char */\n\n              printf(\"PASSED: MHD_strx_to_uint64_(\\\"%s\\\", &ret_val) == 0, value of ret_val is unmodified\\n\",\n                     n_prnt(test_str));\n            }\n        }\n    }\n  return t_failed;\n}",
      "lines": 56,
      "depth": 17,
      "decorators": [
        "int"
      ]
    },
    "check_strx_to_uint64_overflow": {
      "start_point": [
        2105,
        0
      ],
      "end_point": [
        2151,
        1
      ],
      "content": "int check_strx_to_uint64_overflow(void)\n{\n  size_t t_failed = 0;\n  size_t i, j;\n  static const size_t n_checks = sizeof(strx_ovflw) / sizeof(strx_ovflw[0]);\n  int c_failed[n_checks];\n\n  memset(c_failed, 0, sizeof(c_failed));\n\n  for(j = 0; j < locale_name_count; j++)\n    {\n      set_test_locale(j); /* setlocale() can be slow! */\n      for(i = 0; i < n_checks; i++)\n        {\n          size_t rs;\n          const struct str_with_len * const t = strx_ovflw + i;\n          static const uint64_t rnd_val = 74218431;\n          uint64_t test_val;\n\n          for(test_val = 0; test_val <= rnd_val && !c_failed[i]; test_val += rnd_val)\n            {\n              uint64_t rv = test_val;\n\n              rs = MHD_strx_to_uint64_(t->str, &rv);\n              if (rs != 0)\n                {\n                  t_failed++;\n                  c_failed[i] = !0;\n                  fprintf(stderr, \"FAILED: MHD_strx_to_uint64_(\\\"%s\\\", ->0x%\" PRIX64 \") returned %\" PRIuPTR \", while expecting zero.\"\n                                  \" Locale: %s\\n\", n_prnt(t->str), rv, (uintptr_t)rs, get_current_locale_str());\n                }\n              else if (rv != test_val)\n                {\n                  t_failed++;\n                  c_failed[i] = !0;\n                  fprintf(stderr, \"FAILED: MHD_strx_to_uint64_(\\\"%s\\\", &ret_val) modified value of ret_val\"\n                                  \" (before call: 0x%\" PRIX64 \", after call 0x%\" PRIX64 \"). Locale: %s\\n\",\n                                  n_prnt(t->str), test_val, rv, get_current_locale_str());\n                }\n            }\n          if (verbose > 1 && j == locale_name_count - 1 && !c_failed[i])\n            printf(\"PASSED: MHD_strx_to_uint64_(\\\"%s\\\", &ret_val) == 0, value of ret_val is unmodified\\n\",\n                   n_prnt(t->str));\n        }\n    }\n  return t_failed;\n}",
      "lines": 47,
      "depth": 18,
      "decorators": [
        "int"
      ]
    },
    "check_strx_to_uint64_no_val": {
      "start_point": [
        2154,
        0
      ],
      "end_point": [
        2200,
        1
      ],
      "content": "int check_strx_to_uint64_no_val(void)\n{\n  size_t t_failed = 0;\n  size_t i, j;\n  static const size_t n_checks = sizeof(str_no_num) / sizeof(str_no_num[0]);\n  int c_failed[n_checks];\n\n  memset(c_failed, 0, sizeof(c_failed));\n\n  for(j = 0; j < locale_name_count; j++)\n    {\n      set_test_locale(j); /* setlocale() can be slow! */\n      for(i = 0; i < n_checks; i++)\n        {\n          size_t rs;\n          const struct str_with_len * const t = str_no_num + i;\n          static const uint64_t rnd_val = 74218431;\n          uint64_t test_val;\n\n          for(test_val = 0; test_val <= rnd_val && !c_failed[i]; test_val += rnd_val)\n            {\n              uint64_t rv = test_val;\n\n              rs = MHD_strx_to_uint64_(t->str, &rv);\n              if (rs != 0)\n                {\n                  t_failed++;\n                  c_failed[i] = !0;\n                  fprintf(stderr, \"FAILED: MHD_strx_to_uint64_(\\\"%s\\\", ->0x%\" PRIX64 \") returned %\" PRIuPTR \", while expecting zero.\"\n                                  \" Locale: %s\\n\", n_prnt(t->str), rv, (uintptr_t)rs, get_current_locale_str());\n                }\n              else if (rv != test_val)\n                {\n                  t_failed++;\n                  c_failed[i] = !0;\n                  fprintf(stderr, \"FAILED: MHD_strx_to_uint64_(\\\"%s\\\", &ret_val) modified value of ret_val\"\n                                  \" (before call: 0x%\" PRIX64 \", after call 0x%\" PRIX64 \"). Locale: %s\\n\",\n                                  n_prnt(t->str), test_val, rv, get_current_locale_str());\n                }\n            }\n          if (verbose > 1 && j == locale_name_count - 1 && !c_failed[i])\n            printf(\"PASSED: MHD_strx_to_uint64_(\\\"%s\\\", &ret_val) == 0, value of ret_val is unmodified\\n\",\n                   n_prnt(t->str));\n        }\n    }\n  return t_failed;\n}",
      "lines": 47,
      "depth": 18,
      "decorators": [
        "int"
      ]
    },
    "check_strx_to_uint64_n_valid": {
      "start_point": [
        2203,
        0
      ],
      "end_point": [
        2258,
        1
      ],
      "content": "int check_strx_to_uint64_n_valid(void)\n{\n  size_t t_failed = 0;\n  size_t i, j;\n  static const size_t n_checks = sizeof(xdstrs_w_values) / sizeof(xdstrs_w_values[0]);\n  int c_failed[n_checks];\n\n  memset(c_failed, 0, sizeof(c_failed));\n\n  for(j = 0; j < locale_name_count; j++)\n    {\n      set_test_locale(j); /* setlocale() can be slow! */\n      for(i = 0; i < n_checks; i++)\n        {\n          uint64_t rv = 2352932; /* some random value */\n          size_t rs = 0;\n          size_t len;\n          const struct str_with_value * const t = xdstrs_w_values + i;\n\n          if (t->str.len < t->num_of_digt)\n            {\n              fprintf(stderr, \"ERROR: xdstrs_w_values[%u] has wrong num_of_digt (%u): num_of_digt is expected\"\n                              \" to be less or equal to str.len (%u).\\n\",\n                              (unsigned int) i, (unsigned int) t->num_of_digt, (unsigned int) t->str.len);\n              return -1;\n            }\n          for (len = t->num_of_digt; len <= t->str.len + 1 && !c_failed[i]; len++)\n            {\n              rs = MHD_strx_to_uint64_n_(t->str.str, len, &rv);\n              if (rs != t->num_of_digt)\n                {\n                  t_failed++;\n                  c_failed[i] = !0;\n                  fprintf(stderr, \"FAILED: MHD_strx_to_uint64_n_(\\\"%s\\\", %\" PRIuPTR \", ->0x%\" PRIX64 \")\"\n                          \" returned %\" PRIuPTR \", while expecting %d. Locale: %s\\n\",\n                          n_prnt(t->str.str), (intptr_t)len, rv, (intptr_t)rs,\n                          (int)t->num_of_digt, get_current_locale_str());\n                }\n              if (rv != t->val)\n                {\n                  t_failed++;\n                  c_failed[i] = !0;\n                  fprintf(stderr, \"FAILED: MHD_strx_to_uint64_n_(\\\"%s\\\", %\" PRIuPTR \", ->0x%\" PRIX64 \")\"\n                          \" converted string to value 0x%\" PRIX64 \", while expecting result 0x%\" PRIX64\n                          \". Locale: %s\\n\", n_prnt(t->str.str), (intptr_t)len, rv, rv,\n                          t->val, get_current_locale_str());\n                }\n            }\n          if (verbose > 1 && j == locale_name_count - 1 && !c_failed[i])\n            printf(\"PASSED: MHD_strx_to_uint64_n_(\\\"%s\\\", %\" PRIuPTR \"..%\" PRIuPTR \", ->0x%\" PRIX64 \")\"\n                   \" == %\" PRIuPTR \"\\n\", n_prnt(t->str.str), (intptr_t)t->num_of_digt,\n                   (intptr_t)t->str.len + 1, rv, rs);\n        }\n    }\n  return t_failed;\n}",
      "lines": 56,
      "depth": 18,
      "decorators": [
        "int"
      ]
    },
    "check_strx_to_uint64_n_all_chars": {
      "start_point": [
        2261,
        0
      ],
      "end_point": [
        2324,
        1
      ],
      "content": "int check_strx_to_uint64_n_all_chars(void)\n{\n  static const size_t n_checks = 256; /* from 0 to 255 */\n  int c_failed[n_checks];\n  size_t t_failed = 0;\n  size_t j;\n\n  memset(c_failed, 0, sizeof(c_failed));\n\n  for(j = 0; j < locale_name_count; j++)\n    {\n      unsigned int c;\n      uint64_t test_val;\n\n      set_test_locale(j); /* setlocale() can be slow! */\n      for(c = 0; c < n_checks; c++)\n        {\n          static const uint64_t rnd_val = 98372558;\n          size_t rs;\n          size_t len;\n\n          if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'))\n            continue; /* skip xdigits */\n\n          for (len = 0; len <= 5; len++)\n            {\n              for(test_val = 0; test_val <= rnd_val&& !c_failed[c]; test_val += rnd_val)\n                {\n                  char test_str[] = \"0123\";\n                  uint64_t rv = test_val;\n\n                  test_str[0] = (char) (unsigned char)c; /* replace first char with non-digit char */\n                  rs = MHD_strx_to_uint64_n_(test_str, len, &rv);\n                  if (rs != 0)\n                    {\n                      t_failed++;\n                      c_failed[c] = !0;\n                      fprintf(stderr, \"FAILED: MHD_strx_to_uint64_n_(\\\"%s\\\", %\" PRIuPTR \", ->0x%\" PRIX64 \")\"\n                              \" returned %\" PRIuPTR \", while expecting zero. Locale: %s\\n\",\n                              n_prnt(test_str), (uintptr_t)len, rv, (uintptr_t)rs, get_current_locale_str());\n                    }\n                  else if (rv != test_val)\n                    {\n                      t_failed++;\n                      c_failed[c] = !0;\n                      fprintf(stderr, \"FAILED: MHD_strx_to_uint64_n_(\\\"%s\\\", %\" PRIuPTR \", &ret_val)\"\n                              \" modified value of ret_val (before call: 0x%\" PRIX64 \", after call 0x%\" PRIX64 \").\"\n                              \" Locale: %s\\n\",\n                              n_prnt(test_str), (uintptr_t)len, test_val, rv, get_current_locale_str());\n                    }\n                }\n            }\n          if (verbose > 1 && j == locale_name_count - 1 && !c_failed[c])\n            {\n              char test_str[] = \"0123\";\n              test_str[0] = (char) (unsigned char)c; /* replace first char with non-digit char */\n\n              printf(\"PASSED: MHD_strx_to_uint64_n_(\\\"%s\\\", 0..5, &ret_val) == 0, value of ret_val is unmodified\\n\",\n                     n_prnt(test_str));\n            }\n        }\n    }\n  return t_failed;\n}",
      "lines": 64,
      "depth": 19,
      "decorators": [
        "int"
      ]
    },
    "check_strx_to_uint64_n_overflow": {
      "start_point": [
        2327,
        0
      ],
      "end_point": [
        2380,
        1
      ],
      "content": "int check_strx_to_uint64_n_overflow(void)\n{\n  size_t t_failed = 0;\n  size_t i, j;\n  static const size_t n_checks = sizeof(strx_ovflw) / sizeof(strx_ovflw[0]);\n  int c_failed[n_checks];\n\n  memset(c_failed, 0, sizeof(c_failed));\n\n  for(j = 0; j < locale_name_count; j++)\n    {\n      set_test_locale(j); /* setlocale() can be slow! */\n      for(i = 0; i < n_checks; i++)\n        {\n          size_t rs;\n          const struct str_with_len * const t = strx_ovflw + i;\n          static const uint64_t rnd_val = 4;\n          size_t len;\n\n          for (len = t->len; len <= t->len + 1; len++)\n            {\n              uint64_t test_val;\n              for(test_val = 0; test_val <= rnd_val && !c_failed[i]; test_val += rnd_val)\n                {\n                  uint64_t rv = test_val;\n\n                  rs = MHD_strx_to_uint64_n_(t->str, len, &rv);\n                  if (rs != 0)\n                    {\n                      t_failed++;\n                      c_failed[i] = !0;\n                      fprintf(stderr, \"FAILED: MHD_strx_to_uint64_n_(\\\"%s\\\", %\" PRIuPTR \", ->0x%\" PRIX64 \")\"\n                              \" returned %\" PRIuPTR \", while expecting zero. Locale: %s\\n\",\n                              n_prnt(t->str), (uintptr_t)len, rv, (uintptr_t)rs, get_current_locale_str());\n                    }\n                  else if (rv != test_val)\n                    {\n                      t_failed++;\n                      c_failed[i] = !0;\n                      fprintf(stderr, \"FAILED: MHD_strx_to_uint64_n_(\\\"%s\\\", %\" PRIuPTR \", &ret_val)\"\n                              \" modified value of ret_val (before call: 0x%\" PRIX64 \", after call 0x%\" PRIX64 \").\"\n                              \" Locale: %s\\n\", n_prnt(t->str), (uintptr_t)len, test_val, rv,\n                              get_current_locale_str());\n                    }\n                }\n            }\n          if (verbose > 1 && j == locale_name_count - 1 && !c_failed[i])\n            printf(\"PASSED: MHD_strx_to_uint64_n_(\\\"%s\\\", %\" PRIuPTR \"..%\" PRIuPTR \", &ret_val) == 0,\"\n                   \" value of ret_val is unmodified\\n\", n_prnt(t->str), (uintptr_t)t->len,\n                   (uintptr_t)t->len + 1);\n        }\n    }\n  return t_failed;\n}",
      "lines": 54,
      "depth": 20,
      "decorators": [
        "int"
      ]
    },
    "check_strx_to_uint64_n_no_val": {
      "start_point": [
        2383,
        0
      ],
      "end_point": [
        2436,
        1
      ],
      "content": "int check_strx_to_uint64_n_no_val(void)\n{\n  size_t t_failed = 0;\n  size_t i, j;\n  static const size_t n_checks = sizeof(str_no_num) / sizeof(str_no_num[0]);\n  int c_failed[n_checks];\n\n  memset(c_failed, 0, sizeof(c_failed));\n\n  for(j = 0; j < locale_name_count; j++)\n    {\n      set_test_locale(j); /* setlocale() can be slow! */\n      for(i = 0; i < n_checks; i++)\n        {\n          size_t rs;\n          const struct str_with_len * const t = str_no_num + i;\n          static const uint64_t rnd_val = 3214314212UL;\n          size_t len;\n\n          for (len = 0; len <= t->len + 1; len++)\n            {\n              uint64_t test_val;\n              for(test_val = 0; test_val <= rnd_val && !c_failed[i]; test_val += rnd_val)\n                {\n                  uint64_t rv = test_val;\n\n                  rs = MHD_strx_to_uint64_n_(t->str, len, &rv);\n                  if (rs != 0)\n                    {\n                      t_failed++;\n                      c_failed[i] = !0;\n                      fprintf(stderr, \"FAILED: MHD_strx_to_uint64_n_(\\\"%s\\\", %\" PRIuPTR \", ->0x%\" PRIX64 \")\"\n                              \" returned %\" PRIuPTR \", while expecting zero. Locale: %s\\n\",\n                              n_prnt(t->str), (uintptr_t)len, rv, (uintptr_t)rs, get_current_locale_str());\n                    }\n                  else if (rv != test_val)\n                    {\n                      t_failed++;\n                      c_failed[i] = !0;\n                      fprintf(stderr, \"FAILED: MHD_strx_to_uint64_n_(\\\"%s\\\", %\" PRIuPTR \", &ret_val)\"\n                              \" modified value of ret_val (before call: 0x%\" PRIX64 \", after call 0x%\" PRIX64 \").\"\n                              \" Locale: %s\\n\", n_prnt(t->str), (uintptr_t)len, test_val, rv,\n                              get_current_locale_str());\n                    }\n                }\n            }\n          if (verbose > 1 && j == locale_name_count - 1 && !c_failed[i])\n            printf(\"PASSED: MHD_strx_to_uint64_n_(\\\"%s\\\", 0..%\" PRIuPTR \", &ret_val) == 0,\"\n                   \" value of ret_val is unmodified\\n\", n_prnt(t->str),\n                   (uintptr_t)t->len + 1);\n        }\n    }\n  return t_failed;\n}",
      "lines": 54,
      "depth": 20,
      "decorators": [
        "int"
      ]
    },
    "run_str_to_X_tests": {
      "start_point": [
        2439,
        0
      ],
      "end_point": [
        2835,
        1
      ],
      "content": "int run_str_to_X_tests(void)\n{\n  int str_to_uint64_fails = 0;\n  int str_to_uint64_n_fails = 0;\n  int strx_to_uint32_fails = 0;\n  int strx_to_uint32_n_fails = 0;\n  int strx_to_uint64_fails = 0;\n  int strx_to_uint64_n_fails = 0;\n  int res;\n\n  res = check_str_to_uint64_valid();\n  if (res != 0)\n    {\n      if (res < 0)\n        {\n          fprintf(stderr, \"ERROR: test internal error in check_str_to_uint64_valid().\\n\");\n          return 99;\n        }\n      str_to_uint64_fails += res;\n      fprintf(stderr, \"FAILED: testcase check_str_to_uint64_valid() failed.\\n\\n\");\n    }\n  else if (verbose > 1)\n    printf(\"PASSED: testcase check_str_to_uint64_valid() successfully passed.\\n\\n\");\n\n  res = check_str_to_uint64_all_chars();\n  if (res != 0)\n    {\n      if (res < 0)\n        {\n          fprintf(stderr, \"ERROR: test internal error in check_str_to_uint64_all_chars().\\n\");\n          return 99;\n        }\n      str_to_uint64_fails += res;\n      fprintf(stderr, \"FAILED: testcase check_str_to_uint64_all_chars() failed.\\n\\n\");\n    }\n  else if (verbose > 1)\n    printf(\"PASSED: testcase check_str_to_uint64_all_chars() successfully passed.\\n\\n\");\n\n  res = check_str_to_uint64_overflow();\n  if (res != 0)\n    {\n      if (res < 0)\n        {\n          fprintf(stderr, \"ERROR: test internal error in check_str_to_uint64_overflow().\\n\");\n          return 99;\n        }\n      str_to_uint64_fails += res;\n      fprintf(stderr, \"FAILED: testcase check_str_to_uint64_overflow() failed.\\n\\n\");\n    }\n  else if (verbose > 1)\n    printf(\"PASSED: testcase check_str_to_uint64_overflow() successfully passed.\\n\\n\");\n\n  res = check_str_to_uint64_no_val();\n  if (res != 0)\n    {\n      if (res < 0)\n        {\n          fprintf(stderr, \"ERROR: test internal error in check_str_to_uint64_no_val().\\n\");\n          return 99;\n        }\n      str_to_uint64_fails += res;\n      fprintf(stderr, \"FAILED: testcase check_str_to_uint64_no_val() failed.\\n\\n\");\n    }\n  else if (verbose > 1)\n    printf(\"PASSED: testcase check_str_to_uint64_no_val() successfully passed.\\n\\n\");\n\n  if (str_to_uint64_fails)\n    fprintf(stderr, \"FAILED: function MHD_str_to_uint64_() failed %d time%s.\\n\\n\",\n                    str_to_uint64_fails, str_to_uint64_fails == 1 ? \"\" : \"s\");\n  else if (verbose > 0)\n    printf(\"PASSED: function MHD_str_to_uint64_() successfully passed all checks.\\n\\n\");\n\n  res = check_str_to_uint64_n_valid();\n  if (res != 0)\n    {\n      if (res < 0)\n        {\n          fprintf(stderr, \"ERROR: test internal error in check_str_to_uint64_n_valid().\\n\");\n          return 99;\n        }\n      str_to_uint64_n_fails += res;\n      fprintf(stderr, \"FAILED: testcase check_str_to_uint64_n_valid() failed.\\n\\n\");\n    }\n  else if (verbose > 1)\n    printf(\"PASSED: testcase check_str_to_uint64_n_valid() successfully passed.\\n\\n\");\n\n  res = check_str_to_uint64_n_all_chars();\n  if (res != 0)\n    {\n      if (res < 0)\n        {\n          fprintf(stderr, \"ERROR: test internal error in check_str_to_uint64_n_all_chars().\\n\");\n          return 99;\n        }\n      str_to_uint64_n_fails += res;\n      fprintf(stderr, \"FAILED: testcase check_str_to_uint64_n_all_chars() failed.\\n\\n\");\n    }\n  else if (verbose > 1)\n    printf(\"PASSED: testcase check_str_to_uint64_n_all_chars() successfully passed.\\n\\n\");\n\n  res = check_str_to_uint64_n_overflow();\n  if (res != 0)\n    {\n      if (res < 0)\n        {\n          fprintf(stderr, \"ERROR: test internal error in check_str_to_uint64_n_overflow().\\n\");\n          return 99;\n        }\n      str_to_uint64_n_fails += res;\n      fprintf(stderr, \"FAILED: testcase check_str_to_uint64_n_overflow() failed.\\n\\n\");\n    }\n  else if (verbose > 1)\n    printf(\"PASSED: testcase check_str_to_uint64_n_overflow() successfully passed.\\n\\n\");\n\n  res = check_str_to_uint64_n_no_val();\n  if (res != 0)\n    {\n      if (res < 0)\n        {\n          fprintf(stderr, \"ERROR: test internal error in check_str_to_uint64_n_no_val().\\n\");\n          return 99;\n        }\n      str_to_uint64_n_fails += res;\n      fprintf(stderr, \"FAILED: testcase check_str_to_uint64_n_no_val() failed.\\n\\n\");\n    }\n  else if (verbose > 1)\n    printf(\"PASSED: testcase check_str_to_uint64_n_no_val() successfully passed.\\n\\n\");\n\n  if (str_to_uint64_n_fails)\n    fprintf(stderr, \"FAILED: function MHD_str_to_uint64_n_() failed %d time%s.\\n\\n\",\n                    str_to_uint64_n_fails, str_to_uint64_n_fails == 1 ? \"\" : \"s\");\n  else if (verbose > 0)\n    printf(\"PASSED: function MHD_str_to_uint64_n_() successfully passed all checks.\\n\\n\");\n\n  res = check_strx_to_uint32_valid();\n  if (res != 0)\n    {\n      if (res < 0)\n        {\n          fprintf(stderr, \"ERROR: test internal error in check_strx_to_uint32_valid().\\n\");\n          return 99;\n        }\n      strx_to_uint32_fails += res;\n      fprintf(stderr, \"FAILED: testcase check_strx_to_uint32_valid() failed.\\n\\n\");\n    }\n  else if (verbose > 1)\n    printf(\"PASSED: testcase check_strx_to_uint32_valid() successfully passed.\\n\\n\");\n\n  res = check_strx_to_uint32_all_chars();\n  if (res != 0)\n    {\n      if (res < 0)\n        {\n          fprintf(stderr, \"ERROR: test internal error in check_strx_to_uint32_all_chars().\\n\");\n          return 99;\n        }\n      strx_to_uint32_fails += res;\n      fprintf(stderr, \"FAILED: testcase check_strx_to_uint32_all_chars() failed.\\n\\n\");\n    }\n  else if (verbose > 1)\n    printf(\"PASSED: testcase check_strx_to_uint32_all_chars() successfully passed.\\n\\n\");\n\n  res = check_strx_to_uint32_overflow();\n  if (res != 0)\n    {\n      if (res < 0)\n        {\n          fprintf(stderr, \"ERROR: test internal error in check_strx_to_uint32_overflow().\\n\");\n          return 99;\n        }\n      strx_to_uint32_fails += res;\n      fprintf(stderr, \"FAILED: testcase check_strx_to_uint32_overflow() failed.\\n\\n\");\n    }\n  else if (verbose > 1)\n    printf(\"PASSED: testcase check_strx_to_uint32_overflow() successfully passed.\\n\\n\");\n\n  res = check_strx_to_uint32_no_val();\n  if (res != 0)\n    {\n      if (res < 0)\n        {\n          fprintf(stderr, \"ERROR: test internal error in check_strx_to_uint32_no_val().\\n\");\n          return 99;\n        }\n      strx_to_uint32_fails += res;\n      fprintf(stderr, \"FAILED: testcase check_strx_to_uint32_no_val() failed.\\n\\n\");\n    }\n  else if (verbose > 1)\n    printf(\"PASSED: testcase check_strx_to_uint32_no_val() successfully passed.\\n\\n\");\n\n  if (strx_to_uint32_fails)\n    fprintf(stderr, \"FAILED: function MHD_strx_to_uint32_() failed %d time%s.\\n\\n\",\n                    strx_to_uint32_fails, strx_to_uint32_fails == 1 ? \"\" : \"s\");\n  else if (verbose > 0)\n    printf(\"PASSED: function MHD_strx_to_uint32_() successfully passed all checks.\\n\\n\");\n\n  res = check_strx_to_uint32_n_valid();\n  if (res != 0)\n    {\n      if (res < 0)\n        {\n          fprintf(stderr, \"ERROR: test internal error in check_strx_to_uint32_n_valid().\\n\");\n          return 99;\n        }\n      strx_to_uint32_n_fails += res;\n      fprintf(stderr, \"FAILED: testcase check_strx_to_uint32_n_valid() failed.\\n\\n\");\n    }\n  else if (verbose > 1)\n    printf(\"PASSED: testcase check_strx_to_uint32_n_valid() successfully passed.\\n\\n\");\n\n  res = check_strx_to_uint32_n_all_chars();\n  if (res != 0)\n    {\n      if (res < 0)\n        {\n          fprintf(stderr, \"ERROR: test internal error in check_strx_to_uint32_n_all_chars().\\n\");\n          return 99;\n        }\n      strx_to_uint32_n_fails += res;\n      fprintf(stderr, \"FAILED: testcase check_strx_to_uint32_n_all_chars() failed.\\n\\n\");\n    }\n  else if (verbose > 1)\n    printf(\"PASSED: testcase check_strx_to_uint32_n_all_chars() successfully passed.\\n\\n\");\n\n  res = check_strx_to_uint32_n_overflow();\n  if (res != 0)\n    {\n      if (res < 0)\n        {\n          fprintf(stderr, \"ERROR: test internal error in check_strx_to_uint32_n_overflow().\\n\");\n          return 99;\n        }\n      strx_to_uint32_n_fails += res;\n      fprintf(stderr, \"FAILED: testcase check_strx_to_uint32_n_overflow() failed.\\n\\n\");\n    }\n  else if (verbose > 1)\n    printf(\"PASSED: testcase check_strx_to_uint32_n_overflow() successfully passed.\\n\\n\");\n\n  res = check_strx_to_uint32_n_no_val();\n  if (res != 0)\n    {\n      if (res < 0)\n        {\n          fprintf(stderr, \"ERROR: test internal error in check_strx_to_uint32_n_no_val().\\n\");\n          return 99;\n        }\n      strx_to_uint32_n_fails += res;\n      fprintf(stderr, \"FAILED: testcase check_strx_to_uint32_n_no_val() failed.\\n\\n\");\n    }\n  else if (verbose > 1)\n    printf(\"PASSED: testcase check_strx_to_uint32_n_no_val() successfully passed.\\n\\n\");\n\n  if (strx_to_uint32_n_fails)\n    fprintf(stderr, \"FAILED: function MHD_strx_to_uint32_n_() failed %d time%s.\\n\\n\",\n                    strx_to_uint32_n_fails, strx_to_uint32_n_fails == 1 ? \"\" : \"s\");\n  else if (verbose > 0)\n    printf(\"PASSED: function MHD_strx_to_uint32_n_() successfully passed all checks.\\n\\n\");\n\n  res = check_strx_to_uint64_valid();\n  if (res != 0)\n    {\n      if (res < 0)\n        {\n          fprintf(stderr, \"ERROR: test internal error in check_strx_to_uint64_valid().\\n\");\n          return 99;\n        }\n      strx_to_uint64_fails += res;\n      fprintf(stderr, \"FAILED: testcase check_strx_to_uint64_valid() failed.\\n\\n\");\n    }\n  else if (verbose > 1)\n    printf(\"PASSED: testcase check_strx_to_uint64_valid() successfully passed.\\n\\n\");\n\n  res = check_strx_to_uint64_all_chars();\n  if (res != 0)\n    {\n      if (res < 0)\n        {\n          fprintf(stderr, \"ERROR: test internal error in check_strx_to_uint64_all_chars().\\n\");\n          return 99;\n        }\n      strx_to_uint64_fails += res;\n      fprintf(stderr, \"FAILED: testcase check_strx_to_uint64_all_chars() failed.\\n\\n\");\n    }\n  else if (verbose > 1)\n    printf(\"PASSED: testcase check_strx_to_uint64_all_chars() successfully passed.\\n\\n\");\n\n  res = check_strx_to_uint64_overflow();\n  if (res != 0)\n    {\n      if (res < 0)\n        {\n          fprintf(stderr, \"ERROR: test internal error in check_strx_to_uint64_overflow().\\n\");\n          return 99;\n        }\n      strx_to_uint64_fails += res;\n      fprintf(stderr, \"FAILED: testcase check_strx_to_uint64_overflow() failed.\\n\\n\");\n    }\n  else if (verbose > 1)\n    printf(\"PASSED: testcase check_strx_to_uint64_overflow() successfully passed.\\n\\n\");\n\n  res = check_strx_to_uint64_no_val();\n  if (res != 0)\n    {\n      if (res < 0)\n        {\n          fprintf(stderr, \"ERROR: test internal error in check_strx_to_uint64_no_val().\\n\");\n          return 99;\n        }\n      strx_to_uint64_fails += res;\n      fprintf(stderr, \"FAILED: testcase check_strx_to_uint64_no_val() failed.\\n\\n\");\n    }\n  else if (verbose > 1)\n    printf(\"PASSED: testcase check_strx_to_uint64_no_val() successfully passed.\\n\\n\");\n\n  if (strx_to_uint64_fails)\n    fprintf(stderr, \"FAILED: function MHD_strx_to_uint64_() failed %d time%s.\\n\\n\",\n                    strx_to_uint64_fails, strx_to_uint64_fails == 1 ? \"\" : \"s\");\n  else if (verbose > 0)\n    printf(\"PASSED: function MHD_strx_to_uint64_() successfully passed all checks.\\n\\n\");\n\n  res = check_strx_to_uint64_n_valid();\n  if (res != 0)\n    {\n      if (res < 0)\n        {\n          fprintf(stderr, \"ERROR: test internal error in check_strx_to_uint64_n_valid().\\n\");\n          return 99;\n        }\n      strx_to_uint64_n_fails += res;\n      fprintf(stderr, \"FAILED: testcase check_strx_to_uint64_n_valid() failed.\\n\\n\");\n    }\n  else if (verbose > 1)\n    printf(\"PASSED: testcase check_strx_to_uint64_n_valid() successfully passed.\\n\\n\");\n\n  res = check_strx_to_uint64_n_all_chars();\n  if (res != 0)\n    {\n      if (res < 0)\n        {\n          fprintf(stderr, \"ERROR: test internal error in check_strx_to_uint64_n_all_chars().\\n\");\n          return 99;\n        }\n      strx_to_uint64_n_fails += res;\n      fprintf(stderr, \"FAILED: testcase check_strx_to_uint64_n_all_chars() failed.\\n\\n\");\n    }\n  else if (verbose > 1)\n    printf(\"PASSED: testcase check_strx_to_uint64_n_all_chars() successfully passed.\\n\\n\");\n\n  res = check_strx_to_uint64_n_overflow();\n  if (res != 0)\n    {\n      if (res < 0)\n        {\n          fprintf(stderr, \"ERROR: test internal error in check_strx_to_uint64_n_overflow().\\n\");\n          return 99;\n        }\n      strx_to_uint64_n_fails += res;\n      fprintf(stderr, \"FAILED: testcase check_strx_to_uint64_n_overflow() failed.\\n\\n\");\n    }\n  else if (verbose > 1)\n    printf(\"PASSED: testcase check_strx_to_uint64_n_overflow() successfully passed.\\n\\n\");\n\n  res = check_strx_to_uint64_n_no_val();\n  if (res != 0)\n    {\n      if (res < 0)\n        {\n          fprintf(stderr, \"ERROR: test internal error in check_strx_to_uint64_n_no_val().\\n\");\n          return 99;\n        }\n      strx_to_uint64_n_fails += res;\n      fprintf(stderr, \"FAILED: testcase check_strx_to_uint64_n_no_val() failed.\\n\\n\");\n    }\n  else if (verbose > 1)\n    printf(\"PASSED: testcase check_strx_to_uint64_n_no_val() successfully passed.\\n\\n\");\n\n  if (strx_to_uint64_n_fails)\n    fprintf(stderr, \"FAILED: function MHD_strx_to_uint64_n_() failed %d time%s.\\n\\n\",\n                    strx_to_uint64_n_fails, strx_to_uint64_n_fails == 1 ? \"\" : \"s\");\n  else if (verbose > 0)\n    printf(\"PASSED: function MHD_strx_to_uint64_n_() successfully passed all checks.\\n\\n\");\n\n  if (str_to_uint64_fails || str_to_uint64_n_fails ||\n      strx_to_uint32_fails || strx_to_uint32_n_fails ||\n      strx_to_uint64_fails || strx_to_uint64_n_fails)\n    {\n      if (verbose > 0)\n        printf(\"At least one test failed.\\n\");\n\n      return 1;\n    }\n\n  if (verbose > 0)\n    printf(\"All tests passed successfully.\\n\");\n\n  return 0;\n}",
      "lines": 397,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "main": {
      "start_point": [
        2838,
        0
      ],
      "end_point": [
        2851,
        1
      ],
      "content": "int main(int argc, char * argv[])\n{\n  if (has_param(argc, argv, \"-v\") || has_param(argc, argv, \"--verbose\") || has_param(argc, argv, \"--verbose1\"))\n    verbose = 1;\n  if (has_param(argc, argv, \"-vv\") || has_param(argc, argv, \"--verbose2\"))\n    verbose = 2;\n  if (has_param(argc, argv, \"-vvv\") || has_param(argc, argv, \"--verbose3\"))\n    verbose = 3;\n\n  if (has_in_name(argv[0], \"_to_value\"))\n    return run_str_to_X_tests();\n\n  return run_eq_neq_str_tests();\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/microhttpd/test_str_token.c": {
    "expect_found_n": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "static int\nexpect_found_n(const char *str, const char *token, size_t token_len)\n{\n  if (!MHD_str_has_token_caseless_(str, token, token_len))\n    {\n      fprintf(stderr, \"MHD_str_has_token_caseless_() FAILED:\\n\\tMHD_str_has_token_caseless_(%s, %s, %lu) return false\\n\",\n              str, token, (unsigned long) token_len);\n      return 1;\n    }\n  return 0;\n}",
      "lines": 11,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "expect_not_found_n": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "static int\nexpect_not_found_n(const char *str, const char *token, size_t token_len)\n{\n  if (MHD_str_has_token_caseless_(str, token, token_len))\n    {\n      fprintf(stderr, \"MHD_str_has_token_caseless_() FAILED:\\n\\tMHD_str_has_token_caseless_(%s, %s, %lu) return true\\n\",\n              str, token, (unsigned long) token_len);\n      return 1;\n    }\n  return 0;\n}",
      "lines": 11,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "check_match": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        82,
        1
      ],
      "content": "int check_match(void)\n{\n  int errcount = 0;\n  errcount += expect_found(\"string\", \"string\");\n  errcount += expect_found(\"String\", \"string\");\n  errcount += expect_found(\"string\", \"String\");\n  errcount += expect_found(\"strinG\", \"String\");\n  errcount += expect_found(\"\\t strinG\", \"String\");\n  errcount += expect_found(\"strinG\\t \", \"String\");\n  errcount += expect_found(\" \\t tOkEn  \", \"toKEN\");\n  errcount += expect_found(\"not token\\t,  tOkEn  \", \"toKEN\");\n  errcount += expect_found(\"not token,\\t  tOkEn, more token\", \"toKEN\");\n  errcount += expect_found(\"not token,\\t  tOkEn\\t, more token\", \"toKEN\");\n  errcount += expect_found(\",,,,,,test,,,,\", \"TESt\");\n  errcount += expect_found(\",,,,,\\t,test,,,,\", \"TESt\");\n  errcount += expect_found(\",,,,,,test, ,,,\", \"TESt\");\n  errcount += expect_found(\",,,,,, test,,,,\", \"TESt\");\n  errcount += expect_found(\",,,,,, test not,test,,\", \"TESt\");\n  errcount += expect_found(\",,,,,, test not,,test,,\", \"TESt\");\n  errcount += expect_found(\",,,,,, test not ,test,,\", \"TESt\");\n  errcount += expect_found(\",,,,,, test\", \"TESt\");\n  errcount += expect_found(\",,,,,, test      \", \"TESt\");\n  errcount += expect_found(\"no test,,,,,, test      \", \"TESt\");\n  return errcount;\n}",
      "lines": 25,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "check_not_match": {
      "start_point": [
        84,
        0
      ],
      "end_point": [
        108,
        1
      ],
      "content": "int check_not_match(void)\n{\n  int errcount = 0;\n  errcount += expect_not_found(\"strin\", \"string\");\n  errcount += expect_not_found(\"Stringer\", \"string\");\n  errcount += expect_not_found(\"sstring\", \"String\");\n  errcount += expect_not_found(\"string\", \"Strin\");\n  errcount += expect_not_found(\"\\t( strinG\", \"String\");\n  errcount += expect_not_found(\")strinG\\t \", \"String\");\n  errcount += expect_not_found(\" \\t tOkEn t \", \"toKEN\");\n  errcount += expect_not_found(\"not token\\t,  tOkEner  \", \"toKEN\");\n  errcount += expect_not_found(\"not token,\\t  tOkEns, more token\", \"toKEN\");\n  errcount += expect_not_found(\"not token,\\t  tOkEns\\t, more token\", \"toKEN\");\n  errcount += expect_not_found(\",,,,,,testing,,,,\", \"TESt\");\n  errcount += expect_not_found(\",,,,,\\t,test,,,,\", \"TESting\");\n  errcount += expect_not_found(\"tests,,,,,,quest, ,,,\", \"TESt\");\n  errcount += expect_not_found(\",,,,,, test\u00d1\u008b,,,,\", \"TESt\");\n  errcount += expect_not_found(\",,,,,, test not,\u00d1\u0085test,,\", \"TESt\");\n  errcount += expect_not_found(\"testing,,,,,, test not,,test2,,\", \"TESt\");\n  errcount += expect_not_found(\",testi,,,,, test not ,test,,\", \"TESting\");\n  errcount += expect_not_found(\",,,,,,2 test\", \"TESt\");\n  errcount += expect_not_found(\",,,,,,test test      \", \"test\");\n  errcount += expect_not_found(\"no test,,,,,, test      test\", \"test\");\n  return errcount;\n}",
      "lines": 25,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "main": {
      "start_point": [
        110,
        0
      ],
      "end_point": [
        117,
        1
      ],
      "content": "int main(int argc, char * argv[])\n{\n  int errcount = 0;\n  (void)argc; (void)argv; /* Unused. Silent compiler warning. */\n  errcount += check_match();\n  errcount += check_not_match();\n  return errcount == 0 ? 0 : 1;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/microhttpd/test_upgrade.c": {
    "gnutlscli_connect": {
      "start_point": [
        82,
        0
      ],
      "end_point": [
        138,
        1
      ],
      "content": "static pid_t\ngnutlscli_connect (int *sock,\n                 uint16_t port)\n{\n  pid_t chld;\n  int sp[2];\n  char destination[30];\n\n  if (0 != socketpair (AF_UNIX,\n                       SOCK_STREAM,\n                       0,\n                       sp))\n    return -1;\n  chld = fork ();\n  if (0 != chld)\n    {\n      *sock = sp[1];\n      MHD_socket_close_chk_ (sp[0]);\n      return chld;\n    }\n  MHD_socket_close_chk_ (sp[1]);\n  (void) close (0);\n  (void) close (1);\n  dup2 (sp[0], 0);\n  dup2 (sp[0], 1);\n  MHD_socket_close_chk_ (sp[0]);\n  if (TLS_CLI_GNUTLS == use_tls_tool)\n    {\n      snprintf (destination,\n                sizeof(destination),\n                \"%u\",\n                (unsigned int) port);\n      execlp (\"gnutls-cli\",\n              \"gnutls-cli\",\n              \"--insecure\",\n              \"-p\",\n              destination,\n              \"127.0.0.1\",\n              (char *) NULL);\n    }\n  else if (TLS_CLI_OPENSSL == use_tls_tool)\n    {\n      snprintf (destination,\n                sizeof(destination),\n                \"127.0.0.1:%u\",\n                (unsigned int) port);\n      execlp (\"openssl\",\n              \"openssl\",\n              \"s_client\",\n              \"-connect\",\n              destination,\n              \"-verify\",\n              \"1\",\n              (char *) NULL);\n    }\n  _exit (1);\n}",
      "lines": 57,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "pid_t"
      ]
    },
    "wr_create_plain_sckt": {
      "start_point": [
        203,
        0
      ],
      "end_point": [
        215,
        1
      ],
      "content": "static wr_socket\nwr_create_plain_sckt(void)\n{\n  wr_socket s = (wr_socket)malloc(sizeof(struct wr_socket_strc));\n  if (WR_BAD == s)\n    return WR_BAD;\n  s->t = wr_plain;\n  s->fd = socket (AF_INET, SOCK_STREAM, IPPROTO_TCP);\n  if (MHD_INVALID_SOCKET != s->fd)\n    return s;\n  free(s);\n  return WR_BAD;\n}",
      "lines": 13,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "wr_socket"
      ]
    },
    "wr_create_tls_sckt": {
      "start_point": [
        222,
        0
      ],
      "end_point": [
        259,
        1
      ],
      "content": "static wr_socket\nwr_create_tls_sckt(void)\n{\n#ifdef HTTPS_SUPPORT\n  wr_socket s = (wr_socket)malloc(sizeof(struct wr_socket_strc));\n  if (WR_BAD == s)\n    return WR_BAD;\n  s->t = wr_tls;\n  s->tls_connected = 0;\n  s->fd = socket (AF_INET, SOCK_STREAM, IPPROTO_TCP);\n  if (MHD_INVALID_SOCKET != s->fd)\n    {\n      if (GNUTLS_E_SUCCESS == gnutls_init (&(s->tls_s), GNUTLS_CLIENT))\n        {\n          if (GNUTLS_E_SUCCESS == gnutls_set_default_priority (s->tls_s))\n            {\n              if (GNUTLS_E_SUCCESS == gnutls_certificate_allocate_credentials (&(s->tls_crd)))\n                {\n                  if (GNUTLS_E_SUCCESS == gnutls_credentials_set (s->tls_s, GNUTLS_CRD_CERTIFICATE, s->tls_crd))\n                    {\n#if GNUTLS_VERSION_NUMBER+0 >= 0x030109\n                      gnutls_transport_set_int (s->tls_s, (int)(s->fd));\n#else  /* GnuTLS before 3.1.9 */\n                      gnutls_transport_set_ptr (s->tls_s, (gnutls_transport_ptr_t)(intptr_t)(s->fd));\n#endif /* GnuTLS before 3.1.9 */\n                      return s;\n                    }\n                  gnutls_certificate_free_credentials (s->tls_crd);\n                }\n            }\n          gnutls_deinit (s->tls_s);\n        }\n      (void)MHD_socket_close_ (s->fd);\n    }\n  free(s);\n#endif /* HTTPS_SUPPORT */\n  return WR_BAD;\n}",
      "lines": 38,
      "depth": 22,
      "decorators": [
        "static",
        "static",
        "wr_socket"
      ]
    },
    "wr_create_from_plain_sckt": {
      "start_point": [
        268,
        0
      ],
      "end_point": [
        278,
        1
      ],
      "content": "static wr_socket\nwr_create_from_plain_sckt(MHD_socket plain_sk)\n{\n  wr_socket s = (wr_socket)malloc(sizeof(struct wr_socket_strc));\n\n  if (WR_BAD == s)\n    return WR_BAD;\n  s->t = wr_plain;\n  s->fd = plain_sk;\n  return s;\n}",
      "lines": 11,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "wr_socket"
      ]
    },
    "wr_connect": {
      "start_point": [
        288,
        0
      ],
      "end_point": [
        310,
        1
      ],
      "content": "static int\nwr_connect(wr_socket s,\n           const struct sockaddr *addr,\n           int length)\n{\n  if (0 != connect (s->fd, addr, length))\n    return -1;\n  if (wr_plain == s->t)\n    return 0;\n#ifdef HTTPS_SUPPORT\n  if (wr_tls == s->t)\n    {\n      /* Do not try handshake here as\n       * it require processing on MHD side and\n       * when testing with \"external\" polling,\n       * test will call MHD processing only\n       * after return from wr_connect(). */\n      s->tls_connected = 0;\n      return 0;\n    }\n#endif /* HTTPS_SUPPORT */\n  return -1;\n}",
      "lines": 23,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "wr_handshake": {
      "start_point": [
        314,
        0
      ],
      "end_point": [
        324,
        1
      ],
      "content": "static bool wr_handshake(wr_socket s)\n{\n  int res = gnutls_handshake (s->tls_s);\n  if (GNUTLS_E_SUCCESS == res)\n    s->tls_connected = true;\n  else if (GNUTLS_E_AGAIN == res)\n    MHD_socket_set_error_ (MHD_SCKT_EAGAIN_);\n  else\n    MHD_socket_set_error_ (MHD_SCKT_ECONNABORTED_); /* hard error */\n  return s->tls_connected;\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "wr_send": {
      "start_point": [
        337,
        0
      ],
      "end_point": [
        361,
        1
      ],
      "content": "static ssize_t\nwr_send (wr_socket s,\n         const void *buf,\n         size_t len)\n{\n  if (wr_plain == s->t)\n    return MHD_send_(s->fd, buf, len);\n#ifdef HTTPS_SUPPORT\n  if (wr_tls == s->t)\n    {\n      ssize_t ret;\n      if (!s->tls_connected && !wr_handshake (s))\n        return -1;\n\n      ret = gnutls_record_send (s->tls_s, buf, len);\n      if (ret > 0)\n        return ret;\n      if (GNUTLS_E_AGAIN == ret)\n        MHD_socket_set_error_ (MHD_SCKT_EAGAIN_);\n      else\n        MHD_socket_set_error_ (MHD_SCKT_ECONNABORTED_); /* hard error */\n    }\n#endif /* HTTPS_SUPPORT */\n  return -1;\n}",
      "lines": 25,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "ssize_t"
      ]
    },
    "wr_recv": {
      "start_point": [
        373,
        0
      ],
      "end_point": [
        397,
        1
      ],
      "content": "static ssize_t\nwr_recv (wr_socket s,\n         void *buf,\n         size_t len)\n{\n  if (wr_plain == s->t)\n    return MHD_recv_ (s->fd, buf, len);\n#ifdef HTTPS_SUPPORT\n  if (wr_tls == s->t)\n    {\n      ssize_t ret;\n      if (!s->tls_connected && !wr_handshake (s))\n        return -1;\n\n      ret = gnutls_record_recv (s->tls_s, buf, len);\n      if (ret > 0)\n        return ret;\n      if (GNUTLS_E_AGAIN == ret)\n        MHD_socket_set_error_ (MHD_SCKT_EAGAIN_);\n      else\n        MHD_socket_set_error_ (MHD_SCKT_ECONNABORTED_); /* hard error */\n    }\n#endif /* HTTPS_SUPPORT */\n  return -1;\n}",
      "lines": 25,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "ssize_t"
      ]
    },
    "wr_close": {
      "start_point": [
        405,
        0
      ],
      "end_point": [
        418,
        1
      ],
      "content": "static int\nwr_close (wr_socket s)\n{\n  int ret = (MHD_socket_close_(s->fd)) ? 0 : -1;\n#ifdef HTTPS_SUPPORT\n  if (wr_tls == s->t)\n    {\n      gnutls_deinit (s->tls_s);\n      gnutls_certificate_free_credentials (s->tls_crd);\n    }\n#endif /* HTTPS_SUPPORT */\n  free(s);\n  return ret;\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "notify_completed_cb": {
      "start_point": [
        442,
        0
      ],
      "end_point": [
        457,
        1
      ],
      "content": "static void\nnotify_completed_cb (void *cls,\n                     struct MHD_Connection *connection,\n                     void **con_cls,\n                     enum MHD_RequestTerminationCode toe)\n{\n  (void)cls; (void)connection;  /* Unused. Silent compiler warning. */\n  if ( (toe != MHD_REQUEST_TERMINATED_COMPLETED_OK) &&\n       (toe != MHD_REQUEST_TERMINATED_CLIENT_ABORT) &&\n       (toe != MHD_REQUEST_TERMINATED_DAEMON_SHUTDOWN) )\n    abort ();\n  if (! pthread_equal (**((pthread_t**)con_cls), pthread_self ()))\n    abort ();\n  free (*con_cls);\n  *con_cls = NULL;\n}",
      "lines": 16,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "log_cb": {
      "start_point": [
        468,
        0
      ],
      "end_point": [
        484,
        1
      ],
      "content": "static void *\nlog_cb (void *cls,\n        const char *uri,\n        struct MHD_Connection *connection)\n{\n  pthread_t* ppth;\n  (void)cls; (void)connection;  /* Unused. Silent compiler warning. */\n\n  if (0 != strcmp (uri,\n                   \"/\"))\n    abort ();\n  ppth = (pthread_t*) malloc (sizeof(pthread_t));\n  if (NULL == ppth)\n    abort();\n  *ppth = pthread_self ();\n  return (void *) ppth;\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nlog_cb (void *cls,\n        const char *uri,\n        struct MHD_Connection *connection)",
        "*"
      ]
    },
    "notify_connection_cb": {
      "start_point": [
        506,
        0
      ],
      "end_point": [
        532,
        1
      ],
      "content": "static void\nnotify_connection_cb (void *cls,\n                      struct MHD_Connection *connection,\n                      void **socket_context,\n                      enum MHD_ConnectionNotificationCode toe)\n{\n  static int started;\n  (void)cls; (void)connection;  /* Unused. Silent compiler warning. */\n\n  switch (toe)\n  {\n  case MHD_CONNECTION_NOTIFY_STARTED:\n    if (MHD_NO != started)\n      abort ();\n    started = MHD_YES;\n    *socket_context = &started;\n    break;\n  case MHD_CONNECTION_NOTIFY_CLOSED:\n    if (MHD_YES != started)\n      abort ();\n    if (&started != *socket_context)\n      abort ();\n    *socket_context = NULL;\n    started = MHD_NO;\n    break;\n  }\n}",
      "lines": 27,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "make_blocking": {
      "start_point": [
        541,
        0
      ],
      "end_point": [
        559,
        1
      ],
      "content": "static void\nmake_blocking (MHD_socket fd)\n{\n#if defined(MHD_POSIX_SOCKETS)\n  int flags;\n\n  flags = fcntl (fd, F_GETFL);\n  if (-1 == flags)\n    return;\n  if ((flags & ~O_NONBLOCK) != flags)\n    if (-1 == fcntl (fd, F_SETFL, flags & ~O_NONBLOCK))\n      abort ();\n#elif defined(MHD_WINSOCK_SOCKETS)\n  unsigned long flags = 1;\n\n  ioctlsocket (fd, FIONBIO, &flags);\n#endif /* MHD_WINSOCK_SOCKETS */\n\n}",
      "lines": 19,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "send_all": {
      "start_point": [
        562,
        0
      ],
      "end_point": [
        586,
        1
      ],
      "content": "static void\nsend_all (wr_socket sock,\n          const char *text)\n{\n  size_t len = strlen (text);\n  ssize_t ret;\n  size_t off;\n\n  make_blocking (wr_fd (sock));\n  for (off = 0; off < len; off += ret)\n    {\n      ret = wr_send (sock,\n                       &text[off],\n                       len - off);\n      if (0 > ret)\n        {\n          if (MHD_SCKT_ERR_IS_EAGAIN_ (MHD_socket_get_error_ ()))\n            {\n              ret = 0;\n              continue;\n            }\n          abort ();\n        }\n    }\n}",
      "lines": 25,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "recv_hdr": {
      "start_point": [
        593,
        0
      ],
      "end_point": [
        635,
        1
      ],
      "content": "static void\nrecv_hdr (wr_socket sock)\n{\n  unsigned int i;\n  char next;\n  char c;\n  ssize_t ret;\n\n  make_blocking (wr_fd (sock));\n  next = '\\r';\n  i = 0;\n  while (i < 4)\n    {\n      ret = wr_recv (sock,\n                       &c,\n                       1);\n      if (0 > ret)\n        {\n          if (MHD_SCKT_ERR_IS_EAGAIN_ (MHD_socket_get_error_ ()))\n            continue;\n          abort ();\n        }\n      if (0 == ret)\n        continue;\n      if (c == next)\n        {\n          i++;\n          if (next == '\\r')\n            next = '\\n';\n          else\n            next = '\\r';\n          continue;\n        }\n      if (c == '\\r')\n        {\n          i = 1;\n          next = '\\n';\n          continue;\n        }\n      i = 0;\n      next = '\\r';\n    }\n}",
      "lines": 43,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "recv_all": {
      "start_point": [
        638,
        0
      ],
      "end_point": [
        665,
        1
      ],
      "content": "static void\nrecv_all (wr_socket sock,\n          const char *text)\n{\n  size_t len = strlen (text);\n  char buf[len];\n  ssize_t ret;\n  size_t off;\n\n  make_blocking (wr_fd (sock));\n  for (off = 0; off < len; off += ret)\n    {\n      ret = wr_recv (sock,\n                       &buf[off],\n                       len - off);\n      if (0 > ret)\n        {\n          if (MHD_SCKT_ERR_IS_EAGAIN_ (MHD_socket_get_error_ ()))\n            {\n              ret = 0;\n              continue;\n            }\n          abort ();\n        }\n    }\n  if (0 != strncmp (text, buf, len))\n    abort();\n}",
      "lines": 28,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "run_usock": {
      "start_point": [
        674,
        0
      ],
      "end_point": [
        688,
        1
      ],
      "content": "static void *\nrun_usock (void *cls)\n{\n  struct MHD_UpgradeResponseHandle *urh = cls;\n\n  send_all (usock,\n            \"Hello\");\n  recv_all (usock,\n            \"World\");\n  send_all (usock,\n            \"Finished\");\n  MHD_upgrade_action (urh,\n                      MHD_UPGRADE_ACTION_CLOSE);\n  return NULL;\n}",
      "lines": 15,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nrun_usock (void *cls)",
        "*"
      ]
    },
    "run_usock_client": {
      "start_point": [
        697,
        0
      ],
      "end_point": [
        714,
        1
      ],
      "content": "static void *\nrun_usock_client (void *cls)\n{\n  wr_socket *sock = cls;\n\n  send_all (*sock,\n            \"GET / HTTP/1.1\\r\\nConnection: Upgrade\\r\\n\\r\\n\");\n  recv_hdr (*sock);\n  recv_all (*sock,\n            \"Hello\");\n  send_all (*sock,\n            \"World\");\n  recv_all (*sock,\n            \"Finished\");\n  wr_close (*sock);\n  done = true;\n  return NULL;\n}",
      "lines": 18,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nrun_usock_client (void *cls)",
        "*"
      ]
    },
    "upgrade_cb": {
      "start_point": [
        761,
        0
      ],
      "end_point": [
        779,
        1
      ],
      "content": "static void\nupgrade_cb (void *cls,\n            struct MHD_Connection *connection,\n            void *con_cls,\n            const char *extra_in,\n            size_t extra_in_size,\n            MHD_socket sock,\n            struct MHD_UpgradeResponseHandle *urh)\n{\n  (void)cls; (void)connection; (void)con_cls; (void)extra_in; /* Unused. Silent compiler warning. */\n  usock = wr_create_from_plain_sckt (sock);\n  if (0 != extra_in_size)\n    abort ();\n  if (0 != pthread_create (&pt,\n                           NULL,\n                           &run_usock,\n                           urh))\n    abort ();\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "ahc_upgrade": {
      "start_point": [
        821,
        0
      ],
      "end_point": [
        850,
        1
      ],
      "content": "static int\nahc_upgrade (void *cls,\n             struct MHD_Connection *connection,\n             const char *url,\n             const char *method,\n             const char *version,\n             const char *upload_data,\n             size_t *upload_data_size,\n             void **con_cls)\n{\n  struct MHD_Response *resp;\n  int ret;\n  (void)cls;(void)url;(void)method;                        /* Unused. Silent compiler warning. */\n  (void)version;(void)upload_data;(void)upload_data_size;  /* Unused. Silent compiler warning. */\n\n  if (NULL == *con_cls)\n    abort ();\n  if (! pthread_equal (**((pthread_t**)con_cls), pthread_self ()))\n    abort ();\n  resp = MHD_create_response_for_upgrade (&upgrade_cb,\n                                          NULL);\n  MHD_add_response_header (resp,\n                           MHD_HTTP_HEADER_UPGRADE,\n                           \"Hello World Protocol\");\n  ret = MHD_queue_response (connection,\n                            MHD_HTTP_SWITCHING_PROTOCOLS,\n                            resp);\n  MHD_destroy_response (resp);\n  return ret;\n}",
      "lines": 30,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "run_mhd_select_loop": {
      "start_point": [
        858,
        0
      ],
      "end_point": [
        900,
        1
      ],
      "content": "static void\nrun_mhd_select_loop (struct MHD_Daemon *daemon)\n{\n  fd_set rs;\n  fd_set ws;\n  fd_set es;\n  MHD_socket max_fd;\n  MHD_UNSIGNED_LONG_LONG to;\n  struct timeval tv;\n\n  while (! done)\n    {\n      FD_ZERO (&rs);\n      FD_ZERO (&ws);\n      FD_ZERO (&es);\n      max_fd = -1;\n      to = 1000;\n\n      if (MHD_YES !=\n          MHD_get_fdset (daemon,\n                         &rs,\n                         &ws,\n                         &es,\n                         &max_fd))\n        abort ();\n      (void) MHD_get_timeout (daemon,\n                              &to);\n      if (1000 < to)\n        to = 1000;\n      tv.tv_sec = to / 1000;\n      tv.tv_usec = 1000 * (to % 1000);\n      if (0 > MHD_SYS_select_ (max_fd + 1,\n                               &rs,\n                               &ws,\n                               &es,\n                               &tv))\n        abort ();\n      MHD_run_from_select (daemon,\n                           &rs,\n                           &ws,\n                           &es);\n    }\n}",
      "lines": 43,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "run_mhd_poll_loop": {
      "start_point": [
        909,
        0
      ],
      "end_point": [
        914,
        1
      ],
      "content": "static void\nrun_mhd_poll_loop (struct MHD_Daemon *daemon)\n{\n  (void)daemon; /* Unused. Silent compiler warning. */\n  abort (); /* currently not implementable with existing MHD API */\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "run_mhd_epoll_loop": {
      "start_point": [
        924,
        0
      ],
      "end_point": [
        955,
        1
      ],
      "content": "static void\nrun_mhd_epoll_loop (struct MHD_Daemon *daemon)\n{\n  const union MHD_DaemonInfo *di;\n  MHD_socket ep;\n  fd_set rs;\n  MHD_UNSIGNED_LONG_LONG to;\n  struct timeval tv;\n\n  di = MHD_get_daemon_info (daemon,\n                            MHD_DAEMON_INFO_EPOLL_FD);\n  ep = di->listen_fd;\n  while (! done)\n    {\n      FD_ZERO (&rs);\n      to = 1000;\n\n      FD_SET (ep, &rs);\n      (void) MHD_get_timeout (daemon,\n                              &to);\n      if (1000 < to)\n        to = 1000;\n      tv.tv_sec = to / 1000;\n      tv.tv_usec = 1000 * (to % 1000);\n      select (ep + 1,\n              &rs,\n              NULL,\n              NULL,\n              &tv);\n      MHD_run (daemon);\n    }\n}",
      "lines": 32,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "run_mhd_loop": {
      "start_point": [
        963,
        0
      ],
      "end_point": [
        979,
        1
      ],
      "content": "static void\nrun_mhd_loop (struct MHD_Daemon *daemon,\n              int flags)\n{\n  if (0 == (flags & (MHD_USE_POLL | MHD_USE_EPOLL)))\n    run_mhd_select_loop (daemon);\n#ifdef HAVE_POLL\n  else if (0 != (flags & MHD_USE_POLL))\n    run_mhd_poll_loop (daemon);\n#endif /* HAVE_POLL */\n#if EPOLL_SUPPORT\n  else if (0 != (flags & MHD_USE_EPOLL))\n    run_mhd_epoll_loop (daemon);\n#endif\n  else\n    abort ();\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_upgrade": {
      "start_point": [
        989,
        0
      ],
      "end_point": [
        1085,
        1
      ],
      "content": "static int\ntest_upgrade (int flags,\n              unsigned int pool)\n{\n  struct MHD_Daemon *d = NULL;\n  wr_socket sock;\n  struct sockaddr_in sa;\n  const union MHD_DaemonInfo *real_flags;\n  const union MHD_DaemonInfo *dinfo;\n#if defined(HTTPS_SUPPORT) && defined(HAVE_FORK) && defined(HAVE_WAITPID)\n  pid_t pid = -1;\n#endif /* HTTPS_SUPPORT && HAVE_FORK && HAVE_WAITPID */\n\n  done = false;\n\n  if (!test_tls)\n    d = MHD_start_daemon (flags | MHD_USE_ERROR_LOG | MHD_ALLOW_UPGRADE,\n\t\t\t  MHD_is_feature_supported(MHD_FEATURE_AUTODETECT_BIND_PORT) ?\n\t\t\t      0 : 1090,\n\t\t\t  NULL, NULL,\n\t\t\t  &ahc_upgrade, NULL,\n\t\t\t  MHD_OPTION_URI_LOG_CALLBACK, &log_cb, NULL,\n\t\t\t  MHD_OPTION_NOTIFY_COMPLETED, &notify_completed_cb, NULL,\n\t\t\t  MHD_OPTION_NOTIFY_CONNECTION, &notify_connection_cb, NULL,\n\t\t\t  MHD_OPTION_THREAD_POOL_SIZE, pool,\n\t\t\t  MHD_OPTION_END);\n#ifdef HTTPS_SUPPORT\n  else\n    d = MHD_start_daemon (flags | MHD_USE_ERROR_LOG | MHD_ALLOW_UPGRADE | MHD_USE_TLS,\n                          MHD_is_feature_supported(MHD_FEATURE_AUTODETECT_BIND_PORT) ?\n                              0 : 1090,\n                          NULL, NULL,\n                          &ahc_upgrade, NULL,\n                          MHD_OPTION_URI_LOG_CALLBACK, &log_cb, NULL,\n                          MHD_OPTION_NOTIFY_COMPLETED, &notify_completed_cb, NULL,\n                          MHD_OPTION_NOTIFY_CONNECTION, &notify_connection_cb, NULL,\n                          MHD_OPTION_HTTPS_MEM_KEY, srv_signed_key_pem,\n                          MHD_OPTION_HTTPS_MEM_CERT, srv_signed_cert_pem,\n                          MHD_OPTION_THREAD_POOL_SIZE, pool,\n                          MHD_OPTION_END);\n#endif /* HTTPS_SUPPORT */\n  if (NULL == d)\n    return 2;\n  real_flags = MHD_get_daemon_info(d, MHD_DAEMON_INFO_FLAGS);\n  if (NULL == real_flags)\n    abort ();\n  dinfo = MHD_get_daemon_info (d, MHD_DAEMON_INFO_BIND_PORT);\n  if (NULL == dinfo || 0 == dinfo->port)\n    abort ();\n  if (!test_tls || TLS_LIB_GNUTLS == use_tls_tool)\n    {\n      sock = test_tls ? wr_create_tls_sckt () : wr_create_plain_sckt ();\n      if (WR_BAD == sock)\n        abort ();\n      sa.sin_family = AF_INET;\n      sa.sin_port = htons (dinfo->port);\n      sa.sin_addr.s_addr = htonl (INADDR_LOOPBACK);\n      if (0 != wr_connect (sock,\n                        (struct sockaddr *) &sa,\n                        sizeof (sa)))\n        abort ();\n    }\n  else\n    {\n#if defined(HTTPS_SUPPORT) && defined(HAVE_FORK) && defined(HAVE_WAITPID)\n      MHD_socket tls_fork_sock;\n      if (-1 == (pid = gnutlscli_connect (&tls_fork_sock, dinfo->port)))\n        {\n          MHD_stop_daemon (d);\n          return 4;\n        }\n      sock =  wr_create_from_plain_sckt (tls_fork_sock);\n      if (WR_BAD == sock)\n        abort ();\n#else  /* !HTTPS_SUPPORT || !HAVE_FORK || !HAVE_WAITPID */\n      abort ();\n#endif /* !HTTPS_SUPPORT || !HAVE_FORK || !HAVE_WAITPID */\n    }\n\n  if (0 != pthread_create (&pt_client,\n                           NULL,\n                           &run_usock_client,\n                           &sock))\n    abort ();\n  if (0 == (flags & MHD_USE_INTERNAL_POLLING_THREAD) )\n    run_mhd_loop (d, real_flags->flags);\n  pthread_join (pt_client,\n                NULL);\n  pthread_join (pt,\n                NULL);\n#if defined(HTTPS_SUPPORT) && defined(HAVE_FORK) && defined(HAVE_WAITPID)\n  if (test_tls && TLS_LIB_GNUTLS != use_tls_tool)\n    waitpid (pid, NULL, 0);\n#endif /* HTTPS_SUPPORT && HAVE_FORK && HAVE_WAITPID */\n  MHD_stop_daemon (d);\n  return 0;\n}",
      "lines": 97,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        1088,
        0
      ],
      "end_point": [
        1271,
        1
      ],
      "content": "int\nmain (int argc,\n      char *const *argv)\n{\n  int error_count = 0;\n  int res;\n\n  use_tls_tool = TLS_CLI_NO_TOOL;\n  test_tls = has_in_name(argv[0], \"_tls\");\n\n  verbose = 1;\n  if (has_param(argc, argv, \"-q\") || has_param(argc, argv, \"--quiet\"))\n    verbose = 0;\n\n  if (test_tls)\n    {\n#ifdef HTTPS_SUPPORT\n      if (has_param(argc, argv, \"--use-gnutls-cli\"))\n        use_tls_tool = TLS_CLI_GNUTLS;\n      else if (has_param(argc, argv, \"--use-openssl\"))\n        use_tls_tool = TLS_CLI_OPENSSL;\n      else if (has_param(argc, argv, \"--use-gnutls-lib\"))\n        use_tls_tool = TLS_LIB_GNUTLS;\n#if defined(HAVE_FORK) && defined(HAVE_WAITPID)\n      else if (0 == system (\"gnutls-cli --version 1> /dev/null 2> /dev/null\"))\n        use_tls_tool = TLS_CLI_GNUTLS;\n      else if (0 == system (\"openssl version 1> /dev/null 2> /dev/null\"))\n        use_tls_tool = TLS_CLI_OPENSSL;\n#endif /* HAVE_FORK && HAVE_WAITPID */\n      else\n        use_tls_tool = TLS_LIB_GNUTLS; /* Should be available as MHD use it. */\n      if (verbose)\n        {\n          switch (use_tls_tool)\n          {\n            case TLS_CLI_GNUTLS:\n              printf (\"GnuTLS-CLI will be used for testing.\\n\");\n              break;\n            case TLS_CLI_OPENSSL:\n              printf (\"Command line version of OpenSSL will be used for testing.\\n\");\n              break;\n            case TLS_LIB_GNUTLS:\n              printf (\"GnuTLS library will be used for testing.\\n\");\n              break;\n            default:\n              abort ();\n          }\n        }\n      if ( (TLS_LIB_GNUTLS == use_tls_tool) &&\n           (GNUTLS_E_SUCCESS != gnutls_global_init()) )\n        abort ();\n\n#else  /* ! HTTPS_SUPPORT */\n      fprintf (stderr, \"HTTPS support was disabled by configure.\\n\");\n      return 77;\n#endif /* ! HTTPS_SUPPORT */\n    }\n\n  /* run tests */\n  if (verbose)\n    printf (\"Starting HTTP \\\"Upgrade\\\" tests with %s connections.\\n\", test_tls ? \"TLS\" : \"plain\");\n  /* try external select */\n  res = test_upgrade (0,\n                      0);\n  error_count += res;\n  if (res)\n    fprintf (stderr, \"FAILED: Upgrade with external select, return code %d.\\n\", res);\n  else if (verbose)\n    printf (\"PASSED: Upgrade with external select.\\n\");\n\n  /* Try external auto */\n  res = test_upgrade (MHD_USE_AUTO,\n                      0);\n  error_count += res;\n  if (res)\n    fprintf (stderr, \"FAILED: Upgrade with external 'auto', return code %d.\\n\", res);\n  else if (verbose)\n    printf (\"PASSED: Upgrade with external 'auto'.\\n\");\n\n#ifdef EPOLL_SUPPORT\n  res = test_upgrade (MHD_USE_EPOLL,\n                      0);\n  error_count += res;\n  if (res)\n    fprintf (stderr, \"FAILED: Upgrade with external select with EPOLL, return code %d.\\n\", res);\n  else if (verbose)\n    printf (\"PASSED: Upgrade with external select with EPOLL.\\n\");\n#endif\n\n  /* Test thread-per-connection */\n  res = test_upgrade (MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_THREAD_PER_CONNECTION,\n                      0);\n  error_count += res;\n  if (res)\n    fprintf (stderr, \"FAILED: Upgrade with thread per connection, return code %d.\\n\", res);\n  else if (verbose)\n    printf (\"PASSED: Upgrade with thread per connection.\\n\");\n\n  res = test_upgrade (MHD_USE_AUTO | MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_THREAD_PER_CONNECTION,\n                      0);\n  error_count += res;\n  if (res)\n    fprintf (stderr, \"FAILED: Upgrade with thread per connection and 'auto', return code %d.\\n\", res);\n  else if (verbose)\n    printf (\"PASSED: Upgrade with thread per connection and 'auto'.\\n\");\n#ifdef HAVE_POLL\n  res = test_upgrade (MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_THREAD_PER_CONNECTION | MHD_USE_POLL,\n                      0);\n  error_count += res;\n  if (res)\n    fprintf (stderr, \"FAILED: Upgrade with thread per connection and poll, return code %d.\\n\", res);\n  else if (verbose)\n    printf (\"PASSED: Upgrade with thread per connection and poll.\\n\");\n#endif /* HAVE_POLL */\n\n  /* Test different event loops, with and without thread pool */\n  res = test_upgrade (MHD_USE_INTERNAL_POLLING_THREAD,\n                      0);\n  error_count += res;\n  if (res)\n    fprintf (stderr, \"FAILED: Upgrade with internal select, return code %d.\\n\", res);\n  else if (verbose)\n    printf (\"PASSED: Upgrade with internal select.\\n\");\n  res = test_upgrade (MHD_USE_INTERNAL_POLLING_THREAD,\n                      2);\n  error_count += res;\n  if (res)\n    fprintf (stderr, \"FAILED: Upgrade with internal select with thread pool, return code %d.\\n\", res);\n  else if (verbose)\n    printf (\"PASSED: Upgrade with internal select with thread pool.\\n\");\n  res = test_upgrade (MHD_USE_AUTO | MHD_USE_INTERNAL_POLLING_THREAD,\n                      0);\n  error_count += res;\n  if (res)\n    fprintf (stderr, \"FAILED: Upgrade with internal 'auto' return code %d.\\n\", res);\n  else if (verbose)\n    printf (\"PASSED: Upgrade with internal 'auto'.\\n\");\n  res = test_upgrade (MHD_USE_AUTO | MHD_USE_INTERNAL_POLLING_THREAD,\n                      2);\n  error_count += res;\n  if (res)\n    fprintf (stderr, \"FAILED: Upgrade with internal 'auto' with thread pool, return code %d.\\n\", res);\n  else if (verbose)\n    printf (\"PASSED: Upgrade with internal 'auto' with thread pool.\\n\");\n#ifdef HAVE_POLL\n  res = test_upgrade (MHD_USE_POLL_INTERNAL_THREAD,\n                      0);\n  error_count += res;\n  if (res)\n    fprintf (stderr, \"FAILED: Upgrade with internal poll, return code %d.\\n\", res);\n  else if (verbose)\n    printf (\"PASSED: Upgrade with internal poll.\\n\");\n  res = test_upgrade (MHD_USE_POLL_INTERNAL_THREAD,\n                      2);\n  if (res)\n    fprintf (stderr, \"FAILED: Upgrade with internal poll with thread pool, return code %d.\\n\", res);\n  else if (verbose)\n    printf (\"PASSED: Upgrade with internal poll with thread pool.\\n\");\n#endif\n#ifdef EPOLL_SUPPORT\n  res = test_upgrade (MHD_USE_EPOLL_INTERNAL_THREAD,\n                      0);\n  if (res)\n    fprintf (stderr, \"FAILED: Upgrade with internal epoll, return code %d.\\n\", res);\n  else if (verbose)\n    printf (\"PASSED: Upgrade with internal epoll.\\n\");\n  res = test_upgrade (MHD_USE_EPOLL_INTERNAL_THREAD,\n                      2);\n  if (res)\n    fprintf (stderr, \"FAILED: Upgrade with internal epoll, return code %d.\\n\", res);\n  else if (verbose)\n    printf (\"PASSED: Upgrade with internal epoll.\\n\");\n#endif\n  /* report result */\n  if (0 != error_count)\n    fprintf (stderr,\n             \"Error (code: %u)\\n\",\n             error_count);\n#ifdef HTTPS_SUPPORT\n  if (test_tls && (TLS_LIB_GNUTLS == use_tls_tool))\n    gnutls_global_deinit();\n#endif /* HTTPS_SUPPORT */\n  return error_count != 0;       /* 0 == pass */\n}",
      "lines": 184,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/microhttpd/tsearch.c": {
    "tsearch": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "void *\ntsearch (const void *vkey,\t\t/* key to be located */\n         void **vrootp,\t\t\t/* address of tree root */\n         int (*compar)(const void *, const void *))\n{\n  node_t *q;\n  node_t **rootp = (node_t **)vrootp;\n\n  if (NULL == rootp)\n    return NULL;\n\n  while (*rootp != NULL)\n    {\t/* Knuth's T1: */\n      int r;\n\n      if ((r = (*compar)(vkey, (*rootp)->key)) == 0)\t/* T2: */\n        return *rootp;\t\t/* we found it! */\n\n      rootp = (r < 0) ?\n        &(*rootp)->llink :\t\t/* T3: follow left branch */\n        &(*rootp)->rlink;\t\t/* T4: follow right branch */\n    }\n\n  q = malloc (sizeof(node_t));\t\t/* T5: key not found */\n  if (q)\n    {\t\t\t\t/* make new node */\n      *rootp = q;\t\t\t/* link new node to old */\n      q->key = vkey;\t\t/* initialize new node */\n      q->llink = q->rlink = NULL;\n    }\n  return q;\n}",
      "lines": 32,
      "depth": 15,
      "decorators": [
        "void",
        "*\ntsearch (const void *vkey,\t\t/* key to be located */\n         void **vrootp,\t\t\t/* address of tree root */\n         int (*compar)(const void *, const void *))",
        "*"
      ]
    },
    "tfind": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        82,
        1
      ],
      "content": "void *\ntfind (const void *vkey,         /* key to be found */\n       void * const *vrootp,     /* address of the tree root */\n       int (*compar)(const void *, const void *))\n{\n  node_t * const *rootp = (node_t * const*)vrootp;\n\n  if (NULL == rootp)\n    return NULL;\n\n  while (*rootp != NULL)\n    {\t\t/* T1: */\n      int r;\n\n      if ((r = (*compar)(vkey, (*rootp)->key)) == 0)\t/* T2: */\n        return *rootp;\t\t/* key found */\n      rootp = (r < 0) ?\n        &(*rootp)->llink :\t\t/* T3: follow left branch */\n        &(*rootp)->rlink;\t\t/* T4: follow right branch */\n    }\n  return NULL;\n}",
      "lines": 22,
      "depth": 15,
      "decorators": [
        "void",
        "*\ntfind (const void *vkey,         /* key to be found */\n       void * const *vrootp,     /* address of the tree root */\n       int (*compar)(const void *, const void *))",
        "*"
      ]
    },
    "tdelete": {
      "start_point": [
        93,
        0
      ],
      "end_point": [
        140,
        1
      ],
      "content": "void *\ntdelete (const void * __restrict vkey,\n         void ** __restrict vrootp,\n         int (*compar)(const void *, const void *))\n{\n  node_t **rootp = (node_t **)vrootp;\n  node_t *p;\n  node_t *q;\n  node_t *r;\n  int cmp;\n\n  if (rootp == NULL || (p = *rootp) == NULL)\n    return NULL;\n\n  while ((cmp = (*compar)(vkey, (*rootp)->key)) != 0)\n    {\n      p = *rootp;\n      rootp = (cmp < 0) ?\n        &(*rootp)->llink :\t\t/* follow llink branch */\n        &(*rootp)->rlink;\t\t/* follow rlink branch */\n      if (*rootp == NULL)\n        return NULL;\t\t/* key not found */\n    }\n  r = (*rootp)->rlink;\t\t\t/* D1: */\n  if ((q = (*rootp)->llink) == NULL)\t/* Left NULL? */\n    {\n      q = r;\n    }\n  else if (r != NULL)\n    {\t\t\t/* Right link is NULL? */\n      if (r->llink == NULL)\n        {\t\t/* D2: Find successor */\n          r->llink = q;\n          q = r;\n        }\n      else\n        {\t\t\t/* D3: Find NULL link */\n          for (q = r->llink; q->llink != NULL; q = r->llink)\n            r = q;\n          r->llink = q->rlink;\n          q->llink = (*rootp)->llink;\n          q->rlink = (*rootp)->rlink;\n        }\n    }\n  free(*rootp);\t\t\t\t/* D4: Free node */\n  *rootp = q;\t\t\t\t/* link parent to new node */\n  return p;\n}",
      "lines": 48,
      "depth": 13,
      "decorators": [
        "void",
        "*\ntdelete (const void * __restrict vkey,\n         void ** __restrict vrootp,\n         int (*compar)(const void *, const void *))",
        "*"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/microhttpd/tsearch.h": {},
  "libmicrohttpd/libmicrohttpd-0.9.59/src/testcurl/curl_version_check.c": {
    "parse_version_number": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "static int\nparse_version_number (const char **s)\n{\n  int i = 0;\n  char num[17];\n\n  while (i < 16 && ((**s >= '0') & (**s <= '9')))\n    {\n      num[i] = **s;\n      (*s)++;\n      i++;\n    }\n\n  num[i] = '\\0';\n\n  return atoi (num);\n}",
      "lines": 17,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "parse_version_string": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "const char *\nparse_version_string (const char *s, int *major, int *minor, int *micro)\n{\n  if (!s)\n    return NULL;\n  *major = parse_version_number (&s);\n  if (*s != '.')\n    return NULL;\n  s++;\n  *minor = parse_version_number (&s);\n  if (*s != '.')\n    return NULL;\n  s++;\n  *micro = parse_version_number (&s);\n  return s;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nparse_version_string (const char *s, int *major, int *minor, int *micro)",
        "*"
      ]
    },
    "curl_uses_nss_ssl": {
      "start_point": [
        70,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "int\ncurl_uses_nss_ssl()\n{\n  return (strstr(curl_version(), \" NSS/\") != NULL) ? 0 : -1;\n}",
      "lines": 5,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "curl_check_version": {
      "start_point": [
        80,
        0
      ],
      "end_point": [
        175,
        1
      ],
      "content": "int\ncurl_check_version (const char *req_version)\n{\n  const char *ver;\n  const char *curl_ver;\n#ifdef HTTPS_SUPPORT\n  const char *ssl_ver;\n  const char *req_ssl_ver;\n#endif /* HTTPS_SUPPORT */\n\n  int loc_major, loc_minor, loc_micro;\n  int rq_major, rq_minor, rq_micro;\n\n  ver = curl_version ();\n#ifdef HAVE_MESSAGES\n  fprintf (stderr, \"curl version: %s\\n\", ver);\n#endif\n  /*\n   * this call relies on the cURL string to be of the exact following format :\n   * 'libcurl/7.16.4 OpenSSL/0.9.8g zlib/1.2.3.3 libidn/0.6.5' OR\n   * 'libcurl/7.18.2 GnuTLS/2.4.0 zlib/1.2.3.3 libidn/0.6.5'\n   */\n  curl_ver = strchr (ver, '/');\n  if (curl_ver == NULL)\n    return -1;\n  curl_ver++;\n  /* Parse version numbers */\n  if ( (NULL == parse_version_string (req_version, &rq_major, &rq_minor, &rq_micro)) ||\n       (NULL == parse_version_string (curl_ver, &loc_major, &loc_minor, &loc_micro)) )\n    return -1;\n\n  /* Compare version numbers.  */\n  if ((loc_major > rq_major\n       || (loc_major == rq_major && loc_minor > rq_minor)\n       || (loc_major == rq_major && loc_minor == rq_minor\n           && loc_micro > rq_micro) || (loc_major == rq_major\n                                        && loc_minor == rq_minor\n                                        && loc_micro == rq_micro)) == 0)\n    {\n      fprintf (stderr,\n               \"Error: running curl test depends on local libcurl version > %s\\n\",\n               req_version);\n      return -1;\n    }\n\n  /*\n   * enforce required gnutls/openssl version.\n   * TODO use curl version string to assert use of gnutls\n   */\n#ifdef HTTPS_SUPPORT\n  ssl_ver = strchr (curl_ver, ' ');\n  if (ssl_ver == NULL)\n    return -1;\n  ssl_ver++;\n  if (strncmp (\"GnuTLS\", ssl_ver, strlen (\"GNUtls\")) == 0)\n    {\n      ssl_ver = strchr (ssl_ver, '/');\n      req_ssl_ver = MHD_REQ_CURL_GNUTLS_VERSION;\n    }\n  else if (strncmp (\"OpenSSL\", ssl_ver, strlen (\"OpenSSL\")) == 0)\n    {\n      ssl_ver = strchr (ssl_ver, '/');\n      req_ssl_ver = MHD_REQ_CURL_OPENSSL_VERSION;\n    }\n  else if (strncmp (\"NSS\", ssl_ver, strlen (\"NSS\")) == 0)\n    {\n      ssl_ver = strchr (ssl_ver, '/');\n      req_ssl_ver = MHD_REQ_CURL_NSS_VERSION;\n    }\n  else\n    {\n      fprintf (stderr, \"Error: unrecognized curl ssl library\\n\");\n      return -1;\n    }\n  if (ssl_ver == NULL)\n    return -1;\n  ssl_ver++;\n  if ( (NULL == parse_version_string (req_ssl_ver, &rq_major, &rq_minor, &rq_micro)) ||\n       (NULL == parse_version_string (ssl_ver, &loc_major, &loc_minor, &loc_micro)) )\n    return -1;\n\n  if ((loc_major > rq_major\n       || (loc_major == rq_major && loc_minor > rq_minor)\n       || (loc_major == rq_major && loc_minor == rq_minor\n           && loc_micro > rq_micro) || (loc_major == rq_major\n                                        && loc_minor == rq_minor\n                                        && loc_micro == rq_micro)) == 0)\n    {\n      fprintf (stderr,\n               \"Error: running curl test depends on local libcurl SSL version > %s\\n\",\n               req_ssl_ver);\n      return -1;\n    }\n#endif /* HTTPS_SUPPORT */\n  return 0;\n}",
      "lines": 96,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/testcurl/gauger.h": {},
  "libmicrohttpd/libmicrohttpd-0.9.59/src/testcurl/perf_get.c": {
    "now": {
      "start_point": [
        86,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "static unsigned long long\nnow ()\n{\n  struct timeval tv;\n\n  gettimeofday (&tv, NULL);\n  return (((unsigned long long) tv.tv_sec * 1000LL) +\n\t  ((unsigned long long) tv.tv_usec / 1000LL));\n}",
      "lines": 9,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "unsigned long long",
        "unsigned",
        "long",
        "long"
      ]
    },
    "start_timer": {
      "start_point": [
        100,
        0
      ],
      "end_point": [
        104,
        1
      ],
      "content": "static void\nstart_timer()\n{\n  start_time = now ();\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "stop": {
      "start_point": [
        112,
        0
      ],
      "end_point": [
        126,
        1
      ],
      "content": "static void\nstop (const char *desc)\n{\n  double rps = ((double) (ROUNDS * 1000)) / ((double) (now() - start_time));\n\n  fprintf (stderr,\n\t   \"Sequential GETs using %s: %f %s\\n\",\n\t   desc,\n\t   rps,\n\t   \"requests/s\");\n  GAUGER (desc,\n\t  \"Sequential GETs\",\n\t  rps,\n\t  \"requests/s\");\n}",
      "lines": 15,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "copyBuffer": {
      "start_point": [
        137,
        0
      ],
      "end_point": [
        149,
        1
      ],
      "content": "static size_t\ncopyBuffer (void *ptr,\n\t    size_t size, size_t nmemb,\n\t    void *ctx)\n{\n  struct CBC *cbc = ctx;\n\n  if (cbc->pos + size * nmemb > cbc->size)\n    return 0;                   /* overflow */\n  memcpy (&cbc->buf[cbc->pos], ptr, size * nmemb);\n  cbc->pos += size * nmemb;\n  return size * nmemb;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "ahc_echo": {
      "start_point": [
        151,
        0
      ],
      "end_point": [
        178,
        1
      ],
      "content": "static int\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data, size_t *upload_data_size,\n          void **unused)\n{\n  static int ptr;\n  const char *me = cls;\n  int ret;\n  (void)url;(void)version;                      /* Unused. Silent compiler warning. */\n  (void)upload_data;(void)upload_data_size;     /* Unused. Silent compiler warning. */\n\n  if (0 != strcmp (me, method))\n    return MHD_NO;              /* unexpected method */\n  if (&ptr != *unused)\n    {\n      *unused = &ptr;\n      return MHD_YES;\n    }\n  *unused = NULL;\n  ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n  if (ret == MHD_NO)\n    abort ();\n  return ret;\n}",
      "lines": 28,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testInternalGet": {
      "start_point": [
        181,
        0
      ],
      "end_point": [
        249,
        1
      ],
      "content": "static int\ntestInternalGet (int port, int poll_flag)\n{\n  struct MHD_Daemon *d;\n  CURL *c;\n  char buf[2048];\n  struct CBC cbc;\n  CURLcode errornum;\n  unsigned int i;\n  char url[64];\n\n  if (MHD_NO != MHD_is_feature_supported(MHD_FEATURE_AUTODETECT_BIND_PORT))\n    port = 0;\n\n  cbc.buf = buf;\n  cbc.size = 2048;\n  d = MHD_start_daemon (MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_ERROR_LOG  | poll_flag,\n                        port, NULL, NULL, &ahc_echo, \"GET\", MHD_OPTION_END);\n  if (d == NULL)\n    return 1;\n  if (0 == port)\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (d, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        { MHD_stop_daemon (d); return 32; }\n      port = (int)dinfo->port;\n    }\n  sprintf(url, \"http://127.0.0.1:%d/hello_world\", port);\n  start_timer ();\n  for (i=0;i<ROUNDS;i++)\n    {\n      cbc.pos = 0;\n      c = curl_easy_init ();\n      curl_easy_setopt (c, CURLOPT_URL, url);\n      curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n      curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc);\n      curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n      curl_easy_setopt (c, CURLOPT_TIMEOUT, 150L);\n      curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT, 150L);\n      if (oneone)\n\tcurl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n      else\n\tcurl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0);\n      /* NOTE: use of CONNECTTIMEOUT without also\n\t setting NOSIGNAL results in really weird\n\t crashes on my system!*/\n      curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n      if (CURLE_OK != (errornum = curl_easy_perform (c)))\n\t{\n\t  fprintf (stderr,\n\t\t   \"curl_easy_perform failed: `%s'\\n\",\n\t\t   curl_easy_strerror (errornum));\n\t  curl_easy_cleanup (c);\n\t  MHD_stop_daemon (d);\n\t  return 2;\n\t}\n      curl_easy_cleanup (c);\n    }\n  stop (poll_flag == MHD_USE_AUTO ? \"internal thread with 'auto'\" :\n        poll_flag == MHD_USE_POLL ? \"internal thread with poll()\" :\n\tpoll_flag == MHD_USE_EPOLL ? \"internal thread with epoll\" : \"internal thread with select()\");\n  MHD_stop_daemon (d);\n  if (cbc.pos != strlen (\"/hello_world\"))\n    return 4;\n  if (0 != strncmp (\"/hello_world\", cbc.buf, strlen (\"/hello_world\")))\n    return 8;\n  return 0;\n}",
      "lines": 69,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testMultithreadedGet": {
      "start_point": [
        252,
        0
      ],
      "end_point": [
        321,
        1
      ],
      "content": "static int\ntestMultithreadedGet (int port, int poll_flag)\n{\n  struct MHD_Daemon *d;\n  CURL *c;\n  char buf[2048];\n  struct CBC cbc;\n  CURLcode errornum;\n  unsigned int i;\n  char url[64];\n\n  if (MHD_NO != MHD_is_feature_supported(MHD_FEATURE_AUTODETECT_BIND_PORT))\n    port = 0;\n\n  cbc.buf = buf;\n  cbc.size = 2048;\n  d = MHD_start_daemon (MHD_USE_THREAD_PER_CONNECTION | MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_ERROR_LOG  | poll_flag,\n                        port, NULL, NULL, &ahc_echo, \"GET\", MHD_OPTION_END);\n  if (d == NULL)\n    return 16;\n  if (0 == port)\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (d, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        { MHD_stop_daemon (d); return 32; }\n      port = (int)dinfo->port;\n    }\n  sprintf(url, \"http://127.0.0.1:%d/hello_world\", port);\n  start_timer ();\n  for (i=0;i<ROUNDS;i++)\n    {\n      cbc.pos = 0;\n      c = curl_easy_init ();\n      curl_easy_setopt (c, CURLOPT_URL, url);\n      curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n      curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc);\n      curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n      curl_easy_setopt (c, CURLOPT_TIMEOUT, 150L);\n      if (oneone)\n\tcurl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n      else\n\tcurl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0);\n      curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT, 150L);\n      /* NOTE: use of CONNECTTIMEOUT without also\n\t setting NOSIGNAL results in really weird\n\t crashes on my system! */\n      curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n      if (CURLE_OK != (errornum = curl_easy_perform (c)))\n\t{\n\t  fprintf (stderr,\n\t\t   \"curl_easy_perform failed: `%s'\\n\",\n\t\t   curl_easy_strerror (errornum));\n\t  curl_easy_cleanup (c);\n\t  MHD_stop_daemon (d);\n\t  return 32;\n\t}\n      curl_easy_cleanup (c);\n    }\n  stop ((poll_flag & MHD_USE_AUTO) ? \"internal thread with 'auto' and thread per connection\" :\n        (poll_flag & MHD_USE_POLL) ? \"internal thread with poll() and thread per connection\" :\n\t(poll_flag & MHD_USE_EPOLL) ? \"internal thread with epoll and thread per connection\" :\n\t    \"internal thread with select() and thread per connection\");\n  MHD_stop_daemon (d);\n  if (cbc.pos != strlen (\"/hello_world\"))\n    return 64;\n  if (0 != strncmp (\"/hello_world\", cbc.buf, strlen (\"/hello_world\")))\n    return 128;\n  return 0;\n}",
      "lines": 70,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testMultithreadedPoolGet": {
      "start_point": [
        323,
        0
      ],
      "end_point": [
        392,
        1
      ],
      "content": "static int\ntestMultithreadedPoolGet (int port, int poll_flag)\n{\n  struct MHD_Daemon *d;\n  CURL *c;\n  char buf[2048];\n  struct CBC cbc;\n  CURLcode errornum;\n  unsigned int i;\n  char url[64];\n\n  if (MHD_NO != MHD_is_feature_supported(MHD_FEATURE_AUTODETECT_BIND_PORT))\n    port = 0;\n\n  cbc.buf = buf;\n  cbc.size = 2048;\n  d = MHD_start_daemon (MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_ERROR_LOG | poll_flag,\n                        port, NULL, NULL, &ahc_echo, \"GET\",\n                        MHD_OPTION_THREAD_POOL_SIZE, CPU_COUNT, MHD_OPTION_END);\n  if (d == NULL)\n    return 16;\n  if (0 == port)\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (d, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        { MHD_stop_daemon (d); return 32; }\n      port = (int)dinfo->port;\n    }\n  sprintf(url, \"http://127.0.0.1:%d/hello_world\", port);\n  start_timer ();\n  for (i=0;i<ROUNDS;i++)\n    {\n      cbc.pos = 0;\n      c = curl_easy_init ();\n      curl_easy_setopt (c, CURLOPT_URL, url);\n      curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n      curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc);\n      curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n      curl_easy_setopt (c, CURLOPT_TIMEOUT, 150L);\n      if (oneone)\n\tcurl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n      else\n\tcurl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0);\n      curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT, 150L);\n      /* NOTE: use of CONNECTTIMEOUT without also\n\t setting NOSIGNAL results in really weird\n\t crashes on my system!*/\n      curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n      if (CURLE_OK != (errornum = curl_easy_perform (c)))\n\t{\n\t  fprintf (stderr,\n\t\t   \"curl_easy_perform failed: `%s'\\n\",\n\t\t   curl_easy_strerror (errornum));\n\t  curl_easy_cleanup (c);\n\t  MHD_stop_daemon (d);\n\t  return 32;\n\t}\n      curl_easy_cleanup (c);\n    }\n  stop (0 != (poll_flag & MHD_USE_AUTO) ? \"internal thread pool with 'auto'\" :\n        0 != (poll_flag & MHD_USE_POLL) ? \"internal thread pool with poll()\" :\n\t0 != (poll_flag & MHD_USE_EPOLL) ? \"internal thread pool with epoll\" : \"internal thread pool with select()\");\n  MHD_stop_daemon (d);\n  if (cbc.pos != strlen (\"/hello_world\"))\n    return 64;\n  if (0 != strncmp (\"/hello_world\", cbc.buf, strlen (\"/hello_world\")))\n    return 128;\n  return 0;\n}",
      "lines": 70,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testExternalGet": {
      "start_point": [
        394,
        0
      ],
      "end_point": [
        557,
        1
      ],
      "content": "static int\ntestExternalGet (int port)\n{\n  struct MHD_Daemon *d;\n  CURL *c;\n  char buf[2048];\n  struct CBC cbc;\n  CURLM *multi;\n  CURLMcode mret;\n  fd_set rs;\n  fd_set ws;\n  fd_set es;\n  MHD_socket maxsock;\n#ifdef MHD_WINSOCK_SOCKETS\n  int maxposixs; /* Max socket number unused on W32 */\n#else  /* MHD_POSIX_SOCKETS */\n#define maxposixs maxsock\n#endif /* MHD_POSIX_SOCKETS */\n  int running;\n  struct CURLMsg *msg;\n  time_t start;\n  struct timeval tv;\n  unsigned int i;\n  char url[64];\n\n  if (MHD_NO != MHD_is_feature_supported(MHD_FEATURE_AUTODETECT_BIND_PORT))\n    port = 0;\n\n  multi = NULL;\n  cbc.buf = buf;\n  cbc.size = 2048;\n  d = MHD_start_daemon (MHD_USE_ERROR_LOG,\n                        port, NULL, NULL, &ahc_echo, \"GET\", MHD_OPTION_END);\n  if (d == NULL)\n    return 256;\n  if (0 == port)\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (d, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        { MHD_stop_daemon (d); return 32; }\n      port = (int)dinfo->port;\n    }\n  sprintf(url, \"http://127.0.0.1:%d/hello_world\", port);\n  start_timer ();\n  multi = curl_multi_init ();\n  if (multi == NULL)\n    {\n      MHD_stop_daemon (d);\n      return 512;\n    }\n  for (i=0;i<ROUNDS;i++)\n    {\n      cbc.pos = 0;\n      c = curl_easy_init ();\n      curl_easy_setopt (c, CURLOPT_URL, url);\n      curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n      curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc);\n      curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n      if (oneone)\n\tcurl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n      else\n\tcurl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0);\n      curl_easy_setopt (c, CURLOPT_TIMEOUT, 150L);\n      curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT, 150L);\n      /* NOTE: use of CONNECTTIMEOUT without also\n\t setting NOSIGNAL results in really weird\n\t crashes on my system! */\n      curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n      mret = curl_multi_add_handle (multi, c);\n      if (mret != CURLM_OK)\n\t{\n\t  curl_multi_cleanup (multi);\n\t  curl_easy_cleanup (c);\n\t  MHD_stop_daemon (d);\n\t  return 1024;\n\t}\n      start = time (NULL);\n      while ((time (NULL) - start < 5) && (c != NULL))\n\t{\n\t  maxsock = MHD_INVALID_SOCKET;\n\t  maxposixs = -1;\n\t  FD_ZERO (&rs);\n\t  FD_ZERO (&ws);\n\t  FD_ZERO (&es);\n\t  curl_multi_perform (multi, &running);\n\t  mret = curl_multi_fdset (multi, &rs, &ws, &es, &maxposixs);\n\t  if (mret != CURLM_OK)\n\t    {\n\t      curl_multi_remove_handle (multi, c);\n\t      curl_multi_cleanup (multi);\n\t      curl_easy_cleanup (c);\n\t      MHD_stop_daemon (d);\n\t      return 2048;\n\t    }\n\t  if (MHD_YES != MHD_get_fdset (d, &rs, &ws, &es, &maxsock))\n\t    {\n\t      curl_multi_remove_handle (multi, c);\n\t      curl_multi_cleanup (multi);\n\t      curl_easy_cleanup (c);\n\t      MHD_stop_daemon (d);\n\t      return 4096;\n\t    }\n\t  tv.tv_sec = 0;\n\t  tv.tv_usec = 1000;\n\t  if (-1 == select (maxposixs + 1, &rs, &ws, &es, &tv))\n            {\n#ifdef MHD_POSIX_SOCKETS\n              if (EINTR != errno)\n                abort ();\n#else\n              if (WSAEINVAL != WSAGetLastError() || 0 != rs.fd_count || 0 != ws.fd_count || 0 != es.fd_count)\n                abort ();\n              Sleep (1000);\n#endif\n            }\n\t  curl_multi_perform (multi, &running);\n\t  if (running == 0)\n\t    {\n\t      msg = curl_multi_info_read (multi, &running);\n\t      if (msg == NULL)\n\t\tbreak;\n\t      if (msg->msg == CURLMSG_DONE)\n\t\t{\n\t\t  if (msg->data.result != CURLE_OK)\n\t\t    printf (\"%s failed at %s:%d: `%s'\\n\",\n\t\t\t    \"curl_multi_perform\",\n\t\t\t    __FILE__,\n\t\t\t    __LINE__, curl_easy_strerror (msg->data.result));\n\t\t  curl_multi_remove_handle (multi, c);\n\t\t  curl_easy_cleanup (c);\n\t\t  c = NULL;\n\t\t}\n\t    }\n\t  /* two possibilities here; as select sets are\n\t     tiny, this makes virtually no difference\n\t     in actual runtime right now, even though the\n\t     number of select calls is virtually cut in half\n\t     (and 'select' is the most expensive of our system\n\t     calls according to 'strace') */\n\t  if (0)\n\t    MHD_run (d);\n\t  else\n\t    MHD_run_from_select (d, &rs, &ws, &es);\n\t}\n      if (NULL != c)\n\t{\n\t  curl_multi_remove_handle (multi, c);\n\t  curl_easy_cleanup (c);\n\t  fprintf (stderr, \"Timeout!?\\n\");\n\t}\n    }\n  stop (\"external select\");\n  if (multi != NULL)\n    {\n      curl_multi_cleanup (multi);\n    }\n  MHD_stop_daemon (d);\n  if (cbc.pos != strlen (\"/hello_world\"))\n    return 8192;\n  if (0 != strncmp (\"/hello_world\", cbc.buf, strlen (\"/hello_world\")))\n    return 16384;\n  return 0;\n}",
      "lines": 164,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        560,
        0
      ],
      "end_point": [
        599,
        1
      ],
      "content": "int\nmain (int argc, char *const *argv)\n{\n  unsigned int errorCount = 0;\n  int port = 1130;\n  (void)argc;   /* Unused. Silent compiler warning. */\n\n  oneone = (NULL != strrchr (argv[0], (int) '/')) ?\n    (NULL != strstr (strrchr (argv[0], (int) '/'), \"11\")) : 0;\n  if (oneone)\n    port += 15;\n  if (0 != curl_global_init (CURL_GLOBAL_WIN32))\n    return 2;\n  response = MHD_create_response_from_buffer (strlen (\"/hello_world\"),\n\t\t\t\t\t      \"/hello_world\",\n\t\t\t\t\t      MHD_RESPMEM_MUST_COPY);\n  errorCount += testExternalGet (port++);\n  errorCount += testInternalGet (port++, MHD_USE_AUTO);\n  errorCount += testMultithreadedGet (port++, MHD_USE_AUTO);\n  errorCount += testMultithreadedPoolGet (port++, MHD_USE_AUTO);\n  errorCount += testInternalGet (port++, 0);\n  errorCount += testMultithreadedGet (port++, 0);\n  errorCount += testMultithreadedPoolGet (port++, 0);\n  if (MHD_YES == MHD_is_feature_supported(MHD_FEATURE_POLL))\n    {\n      errorCount += testInternalGet(port++, MHD_USE_POLL);\n      errorCount += testMultithreadedGet(port++, MHD_USE_POLL);\n      errorCount += testMultithreadedPoolGet(port++, MHD_USE_POLL);\n    }\n  if (MHD_YES == MHD_is_feature_supported(MHD_FEATURE_EPOLL))\n    {\n      errorCount += testInternalGet(port++, MHD_USE_EPOLL);\n      errorCount += testMultithreadedPoolGet(port++, MHD_USE_EPOLL);\n    }\n  MHD_destroy_response (response);\n  if (errorCount != 0)\n    fprintf (stderr, \"Error (code: %u)\\n\", errorCount);\n  curl_global_cleanup ();\n  return errorCount != 0;       /* 0 == pass */\n}",
      "lines": 40,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/testcurl/perf_get_concurrent.c": {
    "now": {
      "start_point": [
        88,
        0
      ],
      "end_point": [
        96,
        1
      ],
      "content": "static unsigned long long\nnow ()\n{\n  struct timeval tv;\n\n  gettimeofday (&tv, NULL);\n  return (((unsigned long long) tv.tv_sec * 1000LL) +\n\t  ((unsigned long long) tv.tv_usec / 1000LL));\n}",
      "lines": 9,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "unsigned long long",
        "unsigned",
        "long",
        "long"
      ]
    },
    "start_timer": {
      "start_point": [
        102,
        0
      ],
      "end_point": [
        106,
        1
      ],
      "content": "static void\nstart_timer()\n{\n  start_time = now ();\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "stop": {
      "start_point": [
        114,
        0
      ],
      "end_point": [
        128,
        1
      ],
      "content": "static void\nstop (const char *desc)\n{\n  double rps = ((double) (PAR * ROUNDS * 1000)) / ((double) (now() - start_time));\n\n  fprintf (stderr,\n\t   \"Parallel GETs using %s: %f %s\\n\",\n\t   desc,\n\t   rps,\n\t   \"requests/s\");\n  GAUGER (desc,\n\t  \"Parallel GETs\",\n\t  rps,\n\t  \"requests/s\");\n}",
      "lines": 15,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "copyBuffer": {
      "start_point": [
        131,
        0
      ],
      "end_point": [
        138,
        1
      ],
      "content": "static size_t\ncopyBuffer (void *ptr,\n\t    size_t size, size_t nmemb,\n\t    void *ctx)\n{\n  (void)ptr;(void)ctx;          /* Unused. Silent compiler warning. */\n  return size * nmemb;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "ahc_echo": {
      "start_point": [
        141,
        0
      ],
      "end_point": [
        168,
        1
      ],
      "content": "static int\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data, size_t *upload_data_size,\n          void **unused)\n{\n  static int ptr;\n  const char *me = cls;\n  int ret;\n  (void)url;(void)version;                      /* Unused. Silent compiler warning. */\n  (void)upload_data;(void)upload_data_size;     /* Unused. Silent compiler warning. */\n\n  if (0 != strcmp (me, method))\n    return MHD_NO;              /* unexpected method */\n  if (&ptr != *unused)\n    {\n      *unused = &ptr;\n      return MHD_YES;\n    }\n  *unused = NULL;\n  ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n  if (ret == MHD_NO)\n    abort ();\n  return ret;\n}",
      "lines": 28,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "thread_gets": {
      "start_point": [
        171,
        0
      ],
      "end_point": [
        208,
        1
      ],
      "content": "static void *\nthread_gets (void *param)\n{\n  CURL *c;\n  CURLcode errornum;\n  unsigned int i;\n  char * const url = (char*) param;\n\n  for (i=0;i<ROUNDS;i++)\n    {\n      c = curl_easy_init ();\n      curl_easy_setopt (c, CURLOPT_URL, url);\n      curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n      curl_easy_setopt (c, CURLOPT_WRITEDATA, NULL);\n      curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n      curl_easy_setopt (c, CURLOPT_TIMEOUT, 150L);\n      if (oneone)\n        curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n      else\n        curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0);\n      curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT, 150L);\n      /* NOTE: use of CONNECTTIMEOUT without also\n         setting NOSIGNAL results in really weird\n         crashes on my system! */\n      curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n      if (CURLE_OK != (errornum = curl_easy_perform (c)))\n        {\n          fprintf (stderr,\n                   \"curl_easy_perform failed: `%s'\\n\",\n                   curl_easy_strerror (errornum));\n          curl_easy_cleanup (c);\n          return \"curl error\";\n        }\n      curl_easy_cleanup (c);\n    }\n\n  return NULL;\n}",
      "lines": 38,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nthread_gets (void *param)",
        "*"
      ]
    },
    "do_gets": {
      "start_point": [
        211,
        0
      ],
      "end_point": [
        240,
        1
      ],
      "content": "static void *\ndo_gets (void * param)\n{\n  int j;\n  pthread_t par[PAR];\n  char url[64];\n  int port = (int)(intptr_t)param;\n  char *err = NULL;\n\n  sprintf(url, \"http://127.0.0.1:%d/hello_world\", port);\n\n  for (j=0;j<PAR;j++)\n    {\n      if (0 != pthread_create(&par[j], NULL, &thread_gets, (void*)url))\n        {\n          for (j--; j >= 0; j--)\n            pthread_join(par[j], NULL);\n          return \"pthread_create error\";\n        }\n    }\n  for (j=0;j<PAR;j++)\n    {\n      char *ret_val;\n      if (0 != pthread_join(par[j], (void**)&ret_val) ||\n          NULL != ret_val)\n        err = ret_val;\n    }\n  signal_done = 1;\n  return err;\n}",
      "lines": 30,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void",
        "*\ndo_gets (void * param)",
        "*"
      ]
    },
    "testInternalGet": {
      "start_point": [
        243,
        0
      ],
      "end_point": [
        280,
        1
      ],
      "content": "static int\ntestInternalGet (int port, int poll_flag)\n{\n  struct MHD_Daemon *d;\n  const char * const test_desc = ((poll_flag & MHD_USE_AUTO) ? \"internal thread with 'auto'\" :\n                                  (poll_flag & MHD_USE_POLL) ? \"internal thread with poll()\" :\n                                  (poll_flag & MHD_USE_EPOLL) ? \"internal thread with epoll\" : \"internal thread with select()\");\n  const char * ret_val;\n\n  if (MHD_NO != MHD_is_feature_supported(MHD_FEATURE_AUTODETECT_BIND_PORT))\n    port = 0;\n\n  signal_done = 0;\n  d = MHD_start_daemon (MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_ERROR_LOG  | poll_flag,\n                        port, NULL, NULL, &ahc_echo, \"GET\", MHD_OPTION_END);\n  if (d == NULL)\n    return 1;\n  if (0 == port)\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (d, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        { MHD_stop_daemon (d); return 32; }\n      port = (int)dinfo->port;\n    }\n  start_timer ();\n  ret_val = do_gets ((void*)(intptr_t)port);\n  if (!ret_val)\n    stop (test_desc);\n  MHD_stop_daemon (d);\n  if (ret_val)\n    {\n      fprintf (stderr,\n               \"Error performing %s test: %s\\n\", test_desc, ret_val);\n      return 4;\n    }\n  return 0;\n}",
      "lines": 38,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testMultithreadedGet": {
      "start_point": [
        283,
        0
      ],
      "end_point": [
        321,
        1
      ],
      "content": "static int\ntestMultithreadedGet (int port, int poll_flag)\n{\n  struct MHD_Daemon *d;\n  const char * const test_desc = ((poll_flag & MHD_USE_AUTO) ? \"internal thread with 'auto' and thread per connection\" :\n                                  (poll_flag & MHD_USE_POLL) ? \"internal thread with poll() and thread per connection\" :\n                                  (poll_flag & MHD_USE_EPOLL) ? \"internal thread with epoll and thread per connection\"\n                                      : \"internal thread with select() and thread per connection\");\n  const char * ret_val;\n\n  if (MHD_NO != MHD_is_feature_supported(MHD_FEATURE_AUTODETECT_BIND_PORT))\n    port = 0;\n\n  signal_done = 0;\n  d = MHD_start_daemon (MHD_USE_THREAD_PER_CONNECTION | MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_ERROR_LOG  | poll_flag,\n                        port, NULL, NULL, &ahc_echo, \"GET\", MHD_OPTION_END);\n  if (d == NULL)\n    return 16;\n  if (0 == port)\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (d, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        { MHD_stop_daemon (d); return 32; }\n      port = (int)dinfo->port;\n    }\n  start_timer ();\n  ret_val = do_gets ((void*)(intptr_t)port);\n  if (!ret_val)\n    stop (test_desc);\n  MHD_stop_daemon (d);\n  if (ret_val)\n    {\n      fprintf (stderr,\n               \"Error performing %s test: %s\\n\", test_desc, ret_val);\n      return 4;\n    }\n  return 0;\n}",
      "lines": 39,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testMultithreadedPoolGet": {
      "start_point": [
        324,
        0
      ],
      "end_point": [
        362,
        1
      ],
      "content": "static int\ntestMultithreadedPoolGet (int port, int poll_flag)\n{\n  struct MHD_Daemon *d;\n  const char * const test_desc = ((poll_flag & MHD_USE_AUTO) ? \"internal thread pool with 'auto'\" :\n                                  (poll_flag & MHD_USE_POLL) ? \"internal thread pool with poll()\" :\n                                  (poll_flag & MHD_USE_EPOLL) ? \"internal thread poll with epoll\" : \"internal thread pool with select()\");\n  const char * ret_val;\n\n  if (MHD_NO != MHD_is_feature_supported(MHD_FEATURE_AUTODETECT_BIND_PORT))\n    port = 0;\n\n  signal_done = 0 ;\n  d = MHD_start_daemon (MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_ERROR_LOG | poll_flag,\n                        port, NULL, NULL, &ahc_echo, \"GET\",\n                        MHD_OPTION_THREAD_POOL_SIZE, CPU_COUNT, MHD_OPTION_END);\n  if (d == NULL)\n    return 16;\n  if (0 == port)\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (d, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        { MHD_stop_daemon (d); return 32; }\n      port = (int)dinfo->port;\n    }\n  start_timer ();\n  ret_val = do_gets ((void*)(intptr_t)port);\n  if (!ret_val)\n    stop (test_desc);\n  MHD_stop_daemon (d);\n  if (ret_val)\n    {\n      fprintf (stderr,\n               \"Error performing %s test: %s\\n\", test_desc, ret_val);\n      return 4;\n    }\n  return 0;\n}",
      "lines": 39,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testExternalGet": {
      "start_point": [
        365,
        0
      ],
      "end_point": [
        452,
        1
      ],
      "content": "static int\ntestExternalGet (int port)\n{\n  struct MHD_Daemon *d;\n  pthread_t pid;\n  fd_set rs;\n  fd_set ws;\n  fd_set es;\n  MHD_socket max;\n  struct timeval tv;\n  MHD_UNSIGNED_LONG_LONG tt;\n  int tret;\n  char *ret_val;\n  int ret = 0;\n\n  if (MHD_NO != MHD_is_feature_supported(MHD_FEATURE_AUTODETECT_BIND_PORT))\n    port = 0;\n\n  signal_done = 0;\n  d = MHD_start_daemon (MHD_USE_ERROR_LOG,\n                        port, NULL, NULL, &ahc_echo, \"GET\", MHD_OPTION_END);\n  if (d == NULL)\n    return 256;\n  if (0 == port)\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (d, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        { MHD_stop_daemon (d); return 32; }\n      port = (int)dinfo->port;\n    }\n  if (0 != pthread_create (&pid, NULL,\n\t\t\t   &do_gets, (void*)(intptr_t)port))\n    {\n      MHD_stop_daemon(d);\n      return 512;\n    }\n  start_timer ();\n\n  while (0 == signal_done)\n    {\n      max = 0;\n      FD_ZERO (&rs);\n      FD_ZERO (&ws);\n      FD_ZERO (&es);\n      if (MHD_YES != MHD_get_fdset (d, &rs, &ws, &es, &max))\n\t{\n\t  MHD_stop_daemon (d);\n\t  return 4096;\n\t}\n      tret = MHD_get_timeout (d, &tt);\n      if (MHD_YES != tret) tt = 1;\n      tv.tv_sec = tt / 1000;\n      tv.tv_usec = 1000 * (tt % 1000);\n      if (-1 == select (max + 1, &rs, &ws, &es, &tv))\n\t{\n#ifdef MHD_POSIX_SOCKETS\n          if (EINTR == errno)\n            continue;\n          fprintf (stderr,\n                   \"select failed: %s\\n\",\n                   strerror (errno));\n#else\n          if (WSAEINVAL == WSAGetLastError() && 0 == rs.fd_count && 0 == ws.fd_count && 0 == es.fd_count)\n            {\n              Sleep (1000);\n              continue;\n            }\n#endif\n\t  ret |= 1024;\n\t  break;\n\t}\n      MHD_run_from_select(d, &rs, &ws, &es);\n    }\n\n  stop (\"external select\");\n  MHD_stop_daemon (d);\n  if (0 != pthread_join(pid, (void**)&ret_val) ||\n      NULL != ret_val)\n    {\n      fprintf (stderr,\n               \"%s\\n\", ret_val);\n      ret |= 8;\n    }\n  if (ret)\n    fprintf (stderr, \"Error performing test.\\n\");\n  return 0;\n}",
      "lines": 88,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        455,
        0
      ],
      "end_point": [
        494,
        1
      ],
      "content": "int\nmain (int argc, char *const *argv)\n{\n  unsigned int errorCount = 0;\n  int port = 1100;\n  (void)argc;   /* Unused. Silent compiler warning. */\n\n  oneone = (NULL != strrchr (argv[0], (int) '/')) ?\n    (NULL != strstr (strrchr (argv[0], (int) '/'), \"11\")) : 0;\n  if (oneone)\n    port += 15;\n  if (0 != curl_global_init (CURL_GLOBAL_WIN32))\n    return 2;\n  response = MHD_create_response_from_buffer (strlen (\"/hello_world\"),\n\t\t\t\t\t      \"/hello_world\",\n\t\t\t\t\t      MHD_RESPMEM_MUST_COPY);\n  errorCount += testInternalGet (port++, 0);\n  errorCount += testMultithreadedGet (port++, 0);\n  errorCount += testMultithreadedPoolGet (port++, 0);\n  errorCount += testExternalGet (port++);\n  errorCount += testInternalGet (port++, MHD_USE_AUTO);\n  errorCount += testMultithreadedGet (port++, MHD_USE_AUTO);\n  errorCount += testMultithreadedPoolGet (port++, MHD_USE_AUTO);\n  if (MHD_YES == MHD_is_feature_supported(MHD_FEATURE_POLL))\n    {\n      errorCount += testInternalGet (port++, MHD_USE_POLL);\n      errorCount += testMultithreadedGet (port++, MHD_USE_POLL);\n      errorCount += testMultithreadedPoolGet (port++, MHD_USE_POLL);\n    }\n  if (MHD_YES == MHD_is_feature_supported(MHD_FEATURE_EPOLL))\n    {\n      errorCount += testInternalGet (port++, MHD_USE_EPOLL);\n      errorCount += testMultithreadedPoolGet (port++, MHD_USE_EPOLL);\n    }\n  MHD_destroy_response (response);\n  if (errorCount != 0)\n    fprintf (stderr, \"Error (code: %u)\\n\", errorCount);\n  curl_global_cleanup ();\n  return errorCount != 0;       /* 0 == pass */\n}",
      "lines": 40,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/testcurl/test_callback.c": {
    "called_twice": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "static ssize_t\ncalled_twice(void *cls, uint64_t pos, char *buf, size_t max)\n{\n  struct callback_closure *cls2 = cls;\n  (void)pos;    /* Unused. Silent compiler warning. */\n\n  if (cls2->called == 0)\n    {\n      memset(buf, 0, max);\n      strcat(buf, \"test\");\n      cls2->called = 1;\n      return strlen(buf);\n    }\n  if (cls2->called == 1)\n    {\n      cls2->called = 2;\n      return MHD_CONTENT_READER_END_OF_STREAM;\n    }\n  fprintf(stderr,\n\t  \"Handler called after returning END_OF_STREAM!\\n\");\n  return MHD_CONTENT_READER_END_WITH_ERROR;\n}",
      "lines": 22,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "ssize_t"
      ]
    },
    "callback": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "static int\ncallback(void *cls,\n         struct MHD_Connection *connection,\n         const char *url,\n\t const char *method,\n         const char *version,\n         const char *upload_data,\n\t size_t *upload_data_size,\n         void **con_cls)\n{\n  struct callback_closure *cbc = calloc(1, sizeof(struct callback_closure));\n  struct MHD_Response *r;\n  int ret;\n  (void)cls;(void)url;                          /* Unused. Silent compiler warning. */\n  (void)method;(void)version;(void)upload_data; /* Unused. Silent compiler warning. */\n  (void)upload_data_size;(void)con_cls;         /* Unused. Silent compiler warning. */\n\n  r = MHD_create_response_from_callback (MHD_SIZE_UNKNOWN, 1024,\n\t\t\t\t\t &called_twice, cbc,\n\t\t\t\t\t &free);\n  if (NULL == r)\n  {\n    free (cbc);\n    return MHD_NO;\n  }\n  ret = MHD_queue_response (connection,\n                            MHD_HTTP_OK,\n                            r);\n  MHD_destroy_response (r);\n  return ret;\n}",
      "lines": 31,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "discard_buffer": {
      "start_point": [
        93,
        0
      ],
      "end_point": [
        101,
        1
      ],
      "content": "static size_t\ndiscard_buffer (void *ptr,\n                size_t size,\n                size_t nmemb,\n                void *ctx)\n{\n  (void)ptr;(void)ctx;  /* Unused. Silent compiler warning. */\n  return size * nmemb;\n}",
      "lines": 9,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "main": {
      "start_point": [
        104,
        0
      ],
      "end_point": [
        243,
        1
      ],
      "content": "int\nmain(int argc, char **argv)\n{\n  struct MHD_Daemon *d;\n  fd_set rs;\n  fd_set ws;\n  fd_set es;\n  MHD_socket maxsock;\n#ifdef MHD_WINSOCK_SOCKETS\n  int maxposixs; /* Max socket number unused on W32 */\n#else  /* MHD_POSIX_SOCKETS */\n#define maxposixs maxsock\n#endif /* MHD_POSIX_SOCKETS */\n  CURL *c;\n  CURLM *multi;\n  CURLMcode mret;\n  struct CURLMsg *msg;\n  int running;\n  struct timeval tv;\n  int extra;\n  int port;\n  (void)argc; (void)argv; /* Unused. Silent compiler warning. */\n\n  if (MHD_NO != MHD_is_feature_supported (MHD_FEATURE_AUTODETECT_BIND_PORT))\n    port = 0;\n  else\n    port = 1140;\n\n  d = MHD_start_daemon(0,\n\t\t       port,\n\t\t       NULL,\n\t\t       NULL,\n\t\t       &callback,\n\t\t       NULL,\n\t\t       MHD_OPTION_END);\n  if (d == NULL)\n    return 32;\n  if (0 == port)\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (d, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        { MHD_stop_daemon (d); return 48; }\n      port = (int)dinfo->port;\n    }\n  c = curl_easy_init ();\n  curl_easy_setopt (c, CURLOPT_URL, \"http://127.0.0.1/\");\n  curl_easy_setopt (c, CURLOPT_PORT, (long)port);\n  curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &discard_buffer);\n  curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n  curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0);\n  curl_easy_setopt (c, CURLOPT_TIMEOUT, 150L);\n  curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT, 150L);\n  curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n  multi = curl_multi_init ();\n  if (multi == NULL)\n    {\n      curl_easy_cleanup (c);\n      MHD_stop_daemon (d);\n      return 1;\n    }\n  mret = curl_multi_add_handle (multi, c);\n  if (mret != CURLM_OK)\n    {\n      curl_multi_cleanup (multi);\n      curl_easy_cleanup (c);\n      MHD_stop_daemon (d);\n      return 2;\n    }\n  extra = 10;\n  while ( (c != NULL) || (--extra > 0) )\n    {\n      maxsock = MHD_INVALID_SOCKET;\n      maxposixs = -1;\n      FD_ZERO(&ws);\n      FD_ZERO(&rs);\n      FD_ZERO(&es);\n      curl_multi_perform (multi, &running);\n      if (NULL != multi)\n\t{\n\t  mret = curl_multi_fdset (multi, &rs, &ws, &es, &maxposixs);\n\t  if (mret != CURLM_OK)\n\t    {\n\t      curl_multi_remove_handle (multi, c);\n\t      curl_multi_cleanup (multi);\n\t      curl_easy_cleanup (c);\n\t      MHD_stop_daemon (d);\n\t      return 3;\n\t    }\n\t}\n      if (MHD_YES !=\n\t  MHD_get_fdset(d, &rs, &ws, &es, &maxsock))\n\t{\n          curl_multi_remove_handle (multi, c);\n          curl_multi_cleanup (multi);\n          curl_easy_cleanup (c);\n          MHD_stop_daemon (d);\n\t  return 4;\n\t}\n      tv.tv_sec = 0;\n      tv.tv_usec = 1000;\n      if (-1 == select (maxposixs + 1, &rs, &ws, &es, &tv))\n        {\n#ifdef MHD_POSIX_SOCKETS\n              if (EINTR != errno)\n                abort ();\n#else\n              if (WSAEINVAL != WSAGetLastError() || 0 != rs.fd_count || 0 != ws.fd_count || 0 != es.fd_count)\n                abort ();\n              Sleep (1000);\n#endif\n        }\n      if (NULL != multi)\n\t{\n\t  curl_multi_perform (multi, &running);\n\t  if (running == 0)\n\t    {\n\t      msg = curl_multi_info_read (multi, &running);\n\t      if (msg == NULL)\n\t\tbreak;\n\t      if (msg->msg == CURLMSG_DONE)\n\t\t{\n\t\t  if (msg->data.result != CURLE_OK)\n\t\t    printf (\"%s failed at %s:%d: `%s'\\n\",\n\t\t\t    \"curl_multi_perform\",\n\t\t\t    __FILE__,\n\t\t\t    __LINE__, curl_easy_strerror (msg->data.result));\n\t\t  curl_multi_remove_handle (multi, c);\n\t\t  curl_multi_cleanup (multi);\n\t\t  curl_easy_cleanup (c);\n\t\t  c = NULL;\n\t\t  multi = NULL;\n\t\t}\n\t    }\n\t}\n      MHD_run(d);\n    }\n  MHD_stop_daemon(d);\n  return 0;\n}",
      "lines": 140,
      "depth": 19,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/testcurl/test_concurrent_stop.c": {
    "copyBuffer": {
      "start_point": [
        63,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "static size_t\ncopyBuffer (void *ptr,\n\t    size_t size, size_t nmemb,\n\t    void *ctx)\n{\n  (void)ptr;(void)ctx;  /* Unused. Silent compiler warning. */\n  return size * nmemb;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "ahc_echo": {
      "start_point": [
        73,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "static int\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data,\n          size_t *upload_data_size,\n          void **unused)\n{\n  static int ptr;\n  const char *me = cls;\n  int ret;\n  (void)url;(void)version;                      /* Unused. Silent compiler warning. */\n  (void)upload_data;(void)upload_data_size;     /* Unused. Silent compiler warning. */\n\n  if (0 != strcmp (me, method))\n    return MHD_NO;              /* unexpected method */\n  if (&ptr != *unused)\n    {\n      *unused = &ptr;\n      return MHD_YES;\n    }\n  *unused = NULL;\n  ret = MHD_queue_response (connection,\n                            MHD_HTTP_OK,\n                            response);\n  if (ret == MHD_NO)\n    abort ();\n  return ret;\n}",
      "lines": 31,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "clean_curl": {
      "start_point": [
        105,
        0
      ],
      "end_point": [
        114,
        1
      ],
      "content": "static void\nclean_curl(void * param)\n{\n  if (param)\n    {\n      CURL * const c = *((CURL **)param);\n      if (c)\n        curl_easy_cleanup (c);\n    }\n}",
      "lines": 10,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "thread_gets": {
      "start_point": [
        116,
        0
      ],
      "end_point": [
        161,
        1
      ],
      "content": "static void *\nthread_gets (void *param)\n{\n  CURL *c;\n  CURLcode errornum;\n  unsigned int i;\n  char * const url = (char*) param;\n  int pth_olst;\n  if (pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, &pth_olst) ||\n      pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED, &pth_olst) )\n    {\n      fprintf(stderr,\n              \"pthread_setcancelstate()/pthread_setcanceltype() failed.\\n\");\n      _exit(99);\n    }\n\n  for (i=0;i<ROUNDS;i++)\n    {\n      pthread_testcancel();\n      c = NULL;\n      pthread_cleanup_push(clean_curl, (void*)&c);\n      c = curl_easy_init ();\n      pthread_testcancel();\n      curl_easy_setopt (c, CURLOPT_URL, url);\n      curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n      curl_easy_setopt (c, CURLOPT_WRITEDATA, NULL);\n      curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n      curl_easy_setopt (c, CURLOPT_TIMEOUT, 5L);\n      if (oneone)\n        curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n      else\n        curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0);\n      curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT, 5L);\n      /* NOTE: use of CONNECTTIMEOUT without also\n         setting NOSIGNAL results in really weird\n         crashes on my system! */\n      curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n      pthread_testcancel();\n      errornum = curl_easy_perform (c);\n      pthread_cleanup_pop (1);\n      if (CURLE_OK != errornum)\n        return NULL;\n    }\n\n  return NULL;\n}",
      "lines": 46,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nthread_gets (void *param)",
        "*"
      ]
    },
    "do_gets": {
      "start_point": [
        163,
        0
      ],
      "end_point": [
        193,
        1
      ],
      "content": "static void *\ndo_gets (void * param)\n{\n  int j;\n  pthread_t par[PAR];\n  char url[64];\n  int port = (int)(intptr_t)param;\n\n  sprintf(url, \"http://127.0.0.1:%d/hello_world\", port);\n\n  for (j=0;j<PAR;j++)\n    {\n      if (0 != pthread_create(&par[j], NULL, &thread_gets, (void*)url))\n        {\n          fprintf(stderr, \"pthread_create failed.\\n\");\n          for (j--; j >= 0; j--)\n            {\n              pthread_cancel(par[j]);\n              pthread_join(par[j], NULL);\n            }\n          _exit(99);\n        }\n    }\n  (void)sleep (1);\n  for (j=0;j<PAR;j++)\n    {\n      pthread_cancel(par[j]);\n      pthread_join(par[j], NULL);\n    }\n  return NULL;\n}",
      "lines": 31,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void",
        "*\ndo_gets (void * param)",
        "*"
      ]
    },
    "start_gets": {
      "start_point": [
        196,
        0
      ],
      "end_point": [
        205,
        1
      ],
      "content": "pthread_t start_gets(int port)\n{\n  pthread_t tid;\n  if (0 != pthread_create(&tid, NULL, &do_gets, (void*)(intptr_t)port))\n    {\n      fprintf(stderr, \"pthread_create failed.\\n\");\n      _exit(99);\n    }\n  return tid;\n}",
      "lines": 10,
      "depth": 11,
      "decorators": [
        "pthread_t"
      ]
    },
    "testMultithreadedGet": {
      "start_point": [
        208,
        0
      ],
      "end_point": [
        235,
        1
      ],
      "content": "static int\ntestMultithreadedGet (int port,\n                      int poll_flag)\n{\n  struct MHD_Daemon *d;\n  pthread_t p;\n\n  d = MHD_start_daemon (MHD_USE_THREAD_PER_CONNECTION | MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_ERROR_LOG  | poll_flag,\n                        port,\n                        NULL, NULL,\n                        &ahc_echo, \"GET\",\n                        MHD_OPTION_END);\n  if (d == NULL)\n    return 16;\n  if (0 == port)\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (d, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        { MHD_stop_daemon (d); return 32; }\n      port = (int)dinfo->port;\n    }\n  p = start_gets (port);\n  (void)sleep (1);\n  MHD_stop_daemon (d);\n  pthread_join (p, NULL);\n  return 0;\n}",
      "lines": 28,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testMultithreadedPoolGet": {
      "start_point": [
        238,
        0
      ],
      "end_point": [
        266,
        1
      ],
      "content": "static int\ntestMultithreadedPoolGet (int port,\n                          int poll_flag)\n{\n  struct MHD_Daemon *d;\n  pthread_t p;\n\n  d = MHD_start_daemon (MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_ERROR_LOG | poll_flag,\n                        port,\n                        NULL, NULL,\n                        &ahc_echo, \"GET\",\n                        MHD_OPTION_THREAD_POOL_SIZE, CPU_COUNT,\n                        MHD_OPTION_END);\n  if (d == NULL)\n    return 16;\n  if (0 == port)\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (d, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        { MHD_stop_daemon (d); return 32; }\n      port = (int)dinfo->port;\n    }\n  p = start_gets (port);\n  (void)sleep (1);\n  MHD_stop_daemon (d);\n  pthread_join (p, NULL);\n  return 0;\n}",
      "lines": 29,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        269,
        0
      ],
      "end_point": [
        298,
        1
      ],
      "content": "int\nmain (int argc, char *const *argv)\n{\n  unsigned int errorCount = 0;\n  int port;\n  (void)argc;   /* Unused. Silent compiler warning. */\n\n  if (MHD_NO != MHD_is_feature_supported (MHD_FEATURE_AUTODETECT_BIND_PORT))\n    port = 0;\n  else\n    port = 1142;\n\n  oneone = (NULL != strrchr (argv[0], (int) '/')) ?\n    (NULL != strstr (strrchr (argv[0], (int) '/'), \"11\")) : 0;\n  if (0 != port && oneone)\n    port += 5;\n  if (0 != curl_global_init (CURL_GLOBAL_WIN32))\n    return 2;\n  response = MHD_create_response_from_buffer (strlen (\"/hello_world\"),\n\t\t\t\t\t      \"/hello_world\",\n\t\t\t\t\t      MHD_RESPMEM_MUST_COPY);\n  errorCount += testMultithreadedGet (port, 0);\n  if (0 != port) port++;\n  errorCount += testMultithreadedPoolGet (port, 0);\n  MHD_destroy_response (response);\n  if (errorCount != 0)\n    fprintf (stderr, \"Error (code: %u)\\n\", errorCount);\n  curl_global_cleanup ();\n  return errorCount != 0;       /* 0 == pass */\n}",
      "lines": 30,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/testcurl/test_delete.c": {
    "putBuffer": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "static size_t\nputBuffer (void *stream, size_t size, size_t nmemb, void *ptr)\n{\n  unsigned int *pos = ptr;\n  unsigned int wrt;\n\n  wrt = size * nmemb;\n  if (wrt > 8 - (*pos))\n    wrt = 8 - (*pos);\n  memcpy (stream, &(\"Hello123\"[*pos]), wrt);\n  (*pos) += wrt;\n  return wrt;\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "copyBuffer": {
      "start_point": [
        68,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "static size_t\ncopyBuffer (void *ptr, size_t size, size_t nmemb, void *ctx)\n{\n  struct CBC *cbc = ctx;\n\n  if (cbc->pos + size * nmemb > cbc->size)\n    return 0;                   /* overflow */\n  memcpy (&cbc->buf[cbc->pos], ptr, size * nmemb);\n  cbc->pos += size * nmemb;\n  return size * nmemb;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "ahc_echo": {
      "start_point": [
        80,
        0
      ],
      "end_point": [
        117,
        1
      ],
      "content": "static int\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data, size_t *upload_data_size,\n          void **unused)\n{\n  int *done = cls;\n  struct MHD_Response *response;\n  int ret;\n  (void)version;(void)unused;   /* Unused. Silent compiler warning. */\n\n  if (0 != strcasecmp (\"DELETE\", method))\n    return MHD_NO;              /* unexpected method */\n  if ((*done) == 0)\n    {\n      if (*upload_data_size != 8)\n        return MHD_YES;         /* not yet ready */\n      if (0 == memcmp (upload_data, \"Hello123\", 8))\n        {\n          *upload_data_size = 0;\n        }\n      else\n        {\n          printf (\"Invalid upload data `%8s'!\\n\", upload_data);\n          return MHD_NO;\n        }\n      *done = 1;\n      return MHD_YES;\n    }\n  response = MHD_create_response_from_buffer (strlen (url), (void*) url,\n\t\t\t\t\t      MHD_RESPMEM_MUST_COPY);\n  ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n  MHD_destroy_response (response);\n  return ret;\n}",
      "lines": 38,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testInternalDelete": {
      "start_point": [
        120,
        0
      ],
      "end_point": [
        190,
        1
      ],
      "content": "static int\ntestInternalDelete ()\n{\n  struct MHD_Daemon *d;\n  CURL *c;\n  char buf[2048];\n  struct CBC cbc;\n  unsigned int pos = 0;\n  int done_flag = 0;\n  CURLcode errornum;\n  int port;\n\n  if (MHD_NO != MHD_is_feature_supported (MHD_FEATURE_AUTODETECT_BIND_PORT))\n    port = 0;\n  else\n    port = 1152;\n\n  cbc.buf = buf;\n  cbc.size = 2048;\n  cbc.pos = 0;\n  d = MHD_start_daemon (MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_ERROR_LOG,\n                        port,\n                        NULL, NULL, &ahc_echo, &done_flag, MHD_OPTION_END);\n  if (d == NULL)\n    return 1;\n  if (0 == port)\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (d, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        { MHD_stop_daemon (d); return 32; }\n      port = (int)dinfo->port;\n    }\n  c = curl_easy_init ();\n  curl_easy_setopt (c, CURLOPT_URL, \"http://127.0.0.1/hello_world\");\n  curl_easy_setopt (c, CURLOPT_PORT, (long)port);\n  curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n  curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc);\n  curl_easy_setopt (c, CURLOPT_READFUNCTION, &putBuffer);\n  curl_easy_setopt (c, CURLOPT_READDATA, &pos);\n  curl_easy_setopt (c, CURLOPT_CUSTOMREQUEST, \"DELETE\");\n  curl_easy_setopt (c, CURLOPT_UPLOAD, 1L);\n  curl_easy_setopt (c, CURLOPT_INFILESIZE_LARGE, (curl_off_t) 8L);\n  curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n  curl_easy_setopt (c, CURLOPT_TIMEOUT, 150L);\n  if (oneone)\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n  else\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0);\n  curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT, 150L);\n  /* NOTE: use of CONNECTTIMEOUT without also\n   *   setting NOSIGNAL results in really weird\n   *   crashes on my system! */\n  curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n  if (CURLE_OK != (errornum = curl_easy_perform (c)))\n    {\n      fprintf (stderr,\n               \"curl_easy_perform failed: `%s'\\n\",\n               curl_easy_strerror (errornum));\n      curl_easy_cleanup (c);\n      MHD_stop_daemon (d);\n      return 2;\n    }\n  curl_easy_cleanup (c);\n  MHD_stop_daemon (d);\n  if (cbc.pos != strlen (\"/hello_world\"))\n    return 4;\n  if (0 != strncmp (\"/hello_world\", cbc.buf, strlen (\"/hello_world\")))\n    return 8;\n  return 0;\n}",
      "lines": 71,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testMultithreadedDelete": {
      "start_point": [
        193,
        0
      ],
      "end_point": [
        264,
        1
      ],
      "content": "static int\ntestMultithreadedDelete ()\n{\n  struct MHD_Daemon *d;\n  CURL *c;\n  char buf[2048];\n  struct CBC cbc;\n  unsigned int pos = 0;\n  int done_flag = 0;\n  CURLcode errornum;\n  int port;\n\n  if (MHD_NO != MHD_is_feature_supported (MHD_FEATURE_AUTODETECT_BIND_PORT))\n    port = 0;\n  else\n    port = 1153;\n\n  cbc.buf = buf;\n  cbc.size = 2048;\n  cbc.pos = 0;\n  d = MHD_start_daemon (MHD_USE_THREAD_PER_CONNECTION | MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_ERROR_LOG,\n                        port,\n                        NULL, NULL, &ahc_echo, &done_flag, MHD_OPTION_END);\n  if (d == NULL)\n    return 16;\n  if (0 == port)\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (d, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        { MHD_stop_daemon (d); return 32; }\n      port = (int)dinfo->port;\n    }\n  c = curl_easy_init ();\n  curl_easy_setopt (c, CURLOPT_URL, \"http://127.0.0.1/hello_world\");\n  curl_easy_setopt (c, CURLOPT_PORT, (long)port);\n  curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n  curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc);\n  curl_easy_setopt (c, CURLOPT_READFUNCTION, &putBuffer);\n  curl_easy_setopt (c, CURLOPT_READDATA, &pos);\n  curl_easy_setopt (c, CURLOPT_CUSTOMREQUEST, \"DELETE\");\n  curl_easy_setopt (c, CURLOPT_UPLOAD, 1L);\n  curl_easy_setopt (c, CURLOPT_INFILESIZE_LARGE, (curl_off_t) 8L);\n  curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n  curl_easy_setopt (c, CURLOPT_TIMEOUT, 150L);\n  if (oneone)\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n  else\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0);\n  curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT, 150L);\n  /* NOTE: use of CONNECTTIMEOUT without also\n   *   setting NOSIGNAL results in really weird\n   *   crashes on my system! */\n  curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n  if (CURLE_OK != (errornum = curl_easy_perform (c)))\n    {\n      fprintf (stderr,\n               \"curl_easy_perform failed: `%s'\\n\",\n               curl_easy_strerror (errornum));\n      curl_easy_cleanup (c);\n      MHD_stop_daemon (d);\n      return 32;\n    }\n  curl_easy_cleanup (c);\n  MHD_stop_daemon (d);\n  if (cbc.pos != strlen (\"/hello_world\"))\n    return 64;\n  if (0 != strncmp (\"/hello_world\", cbc.buf, strlen (\"/hello_world\")))\n    return 128;\n\n  return 0;\n}",
      "lines": 72,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testMultithreadedPoolDelete": {
      "start_point": [
        266,
        0
      ],
      "end_point": [
        338,
        1
      ],
      "content": "static int\ntestMultithreadedPoolDelete ()\n{\n  struct MHD_Daemon *d;\n  CURL *c;\n  char buf[2048];\n  struct CBC cbc;\n  unsigned int pos = 0;\n  int done_flag = 0;\n  CURLcode errornum;\n  int port;\n\n  if (MHD_NO != MHD_is_feature_supported (MHD_FEATURE_AUTODETECT_BIND_PORT))\n    port = 0;\n  else\n    port = 1154;\n\n  cbc.buf = buf;\n  cbc.size = 2048;\n  cbc.pos = 0;\n  d = MHD_start_daemon (MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_ERROR_LOG,\n                        port,\n                        NULL, NULL, &ahc_echo, &done_flag,\n                        MHD_OPTION_THREAD_POOL_SIZE, CPU_COUNT, MHD_OPTION_END);\n  if (d == NULL)\n    return 16;\n  if (0 == port)\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (d, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        { MHD_stop_daemon (d); return 32; }\n      port = (int)dinfo->port;\n    }\n  c = curl_easy_init ();\n  curl_easy_setopt (c, CURLOPT_URL, \"http://127.0.0.1/hello_world\");\n  curl_easy_setopt (c, CURLOPT_PORT, (long)port);\n  curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n  curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc);\n  curl_easy_setopt (c, CURLOPT_READFUNCTION, &putBuffer);\n  curl_easy_setopt (c, CURLOPT_READDATA, &pos);\n  curl_easy_setopt (c, CURLOPT_CUSTOMREQUEST, \"DELETE\");\n  curl_easy_setopt (c, CURLOPT_UPLOAD, 1L);\n  curl_easy_setopt (c, CURLOPT_INFILESIZE_LARGE, (curl_off_t) 8L);\n  curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n  curl_easy_setopt (c, CURLOPT_TIMEOUT, 150L);\n  if (oneone)\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n  else\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0);\n  curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT, 150L);\n  /* NOTE: use of CONNECTTIMEOUT without also\n   *   setting NOSIGNAL results in really weird\n   *   crashes on my system! */\n  curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n  if (CURLE_OK != (errornum = curl_easy_perform (c)))\n    {\n      fprintf (stderr,\n               \"curl_easy_perform failed: `%s'\\n\",\n               curl_easy_strerror (errornum));\n      curl_easy_cleanup (c);\n      MHD_stop_daemon (d);\n      return 32;\n    }\n  curl_easy_cleanup (c);\n  MHD_stop_daemon (d);\n  if (cbc.pos != strlen (\"/hello_world\"))\n    return 64;\n  if (0 != strncmp (\"/hello_world\", cbc.buf, strlen (\"/hello_world\")))\n    return 128;\n\n  return 0;\n}",
      "lines": 73,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testExternalDelete": {
      "start_point": [
        341,
        0
      ],
      "end_point": [
        500,
        1
      ],
      "content": "static int\ntestExternalDelete ()\n{\n  struct MHD_Daemon *d;\n  CURL *c;\n  char buf[2048];\n  struct CBC cbc;\n  CURLM *multi;\n  CURLMcode mret;\n  fd_set rs;\n  fd_set ws;\n  fd_set es;\n  MHD_socket maxsock;\n#ifdef MHD_WINSOCK_SOCKETS\n  int maxposixs; /* Max socket number unused on W32 */\n#else  /* MHD_POSIX_SOCKETS */\n#define maxposixs maxsock\n#endif /* MHD_POSIX_SOCKETS */\n  int running;\n  struct CURLMsg *msg;\n  time_t start;\n  struct timeval tv;\n  unsigned int pos = 0;\n  int done_flag = 0;\n  int port;\n\n  if (MHD_NO != MHD_is_feature_supported (MHD_FEATURE_AUTODETECT_BIND_PORT))\n    port = 0;\n  else\n    port = 1154;\n\n  multi = NULL;\n  cbc.buf = buf;\n  cbc.size = 2048;\n  cbc.pos = 0;\n  d = MHD_start_daemon (MHD_USE_ERROR_LOG,\n                        port,\n                        NULL, NULL, &ahc_echo, &done_flag, MHD_OPTION_END);\n  if (d == NULL)\n    return 256;\n  if (0 == port)\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (d, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        { MHD_stop_daemon (d); return 32; }\n      port = (int)dinfo->port;\n    }\n  c = curl_easy_init ();\n  curl_easy_setopt (c, CURLOPT_URL, \"http://127.0.0.1/hello_world\");\n  curl_easy_setopt (c, CURLOPT_PORT, (long)port);\n  curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n  curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc);\n  curl_easy_setopt (c, CURLOPT_READFUNCTION, &putBuffer);\n  curl_easy_setopt (c, CURLOPT_READDATA, &pos);\n  curl_easy_setopt (c, CURLOPT_CUSTOMREQUEST, \"DELETE\");\n  curl_easy_setopt (c, CURLOPT_UPLOAD, 1L);\n  curl_easy_setopt (c, CURLOPT_INFILESIZE_LARGE, (curl_off_t) 8L);\n  curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n  curl_easy_setopt (c, CURLOPT_TIMEOUT, 150L);\n  if (oneone)\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n  else\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0);\n  curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT, 150L);\n  /* NOTE: use of CONNECTTIMEOUT without also\n   *   setting NOSIGNAL results in really weird\n   *   crashes on my system! */\n  curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n\n\n  multi = curl_multi_init ();\n  if (multi == NULL)\n    {\n      curl_easy_cleanup (c);\n      MHD_stop_daemon (d);\n      return 512;\n    }\n  mret = curl_multi_add_handle (multi, c);\n  if (mret != CURLM_OK)\n    {\n      curl_multi_cleanup (multi);\n      curl_easy_cleanup (c);\n      MHD_stop_daemon (d);\n      return 1024;\n    }\n  start = time (NULL);\n  while ((time (NULL) - start < 5) && (multi != NULL))\n    {\n      maxsock = MHD_INVALID_SOCKET;\n      maxposixs = -1;\n      FD_ZERO (&rs);\n      FD_ZERO (&ws);\n      FD_ZERO (&es);\n      curl_multi_perform (multi, &running);\n      mret = curl_multi_fdset (multi, &rs, &ws, &es, &maxposixs);\n      if (mret != CURLM_OK)\n        {\n          curl_multi_remove_handle (multi, c);\n          curl_multi_cleanup (multi);\n          curl_easy_cleanup (c);\n          MHD_stop_daemon (d);\n          return 2048;\n        }\n      if (MHD_YES != MHD_get_fdset (d, &rs, &ws, &es, &maxsock))\n        {\n          curl_multi_remove_handle (multi, c);\n          curl_multi_cleanup (multi);\n          curl_easy_cleanup (c);\n          MHD_stop_daemon (d);\n          return 4096;\n        }\n      tv.tv_sec = 0;\n      tv.tv_usec = 1000;\n      if (-1 == select (maxposixs + 1, &rs, &ws, &es, &tv))\n        {\n#ifdef MHD_POSIX_SOCKETS\n              if (EINTR != errno)\n                abort ();\n#else\n              if (WSAEINVAL != WSAGetLastError() || 0 != rs.fd_count || 0 != ws.fd_count || 0 != es.fd_count)\n                abort ();\n              Sleep (1000);\n#endif\n        }\n      curl_multi_perform (multi, &running);\n      if (running == 0)\n        {\n          msg = curl_multi_info_read (multi, &running);\n          if (msg == NULL)\n            break;\n          if (msg->msg == CURLMSG_DONE)\n            {\n              if (msg->data.result != CURLE_OK)\n                printf (\"%s failed at %s:%d: `%s'\\n\",\n                        \"curl_multi_perform\",\n                        __FILE__,\n                        __LINE__, curl_easy_strerror (msg->data.result));\n              curl_multi_remove_handle (multi, c);\n              curl_multi_cleanup (multi);\n              curl_easy_cleanup (c);\n              c = NULL;\n              multi = NULL;\n            }\n        }\n      MHD_run (d);\n    }\n  if (multi != NULL)\n    {\n      curl_multi_remove_handle (multi, c);\n      curl_easy_cleanup (c);\n      curl_multi_cleanup (multi);\n    }\n  MHD_stop_daemon (d);\n  if (cbc.pos != strlen (\"/hello_world\"))\n    return 8192;\n  if (0 != strncmp (\"/hello_world\", cbc.buf, strlen (\"/hello_world\")))\n    return 16384;\n  return 0;\n}",
      "lines": 160,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        504,
        0
      ],
      "end_point": [
        522,
        1
      ],
      "content": "int\nmain (int argc, char *const *argv)\n{\n  unsigned int errorCount = 0;\n  (void)argc;   /* Unused. Silent compiler warning. */\n\n  oneone = (NULL != strrchr (argv[0], (int) '/')) ?\n    (NULL != strstr (strrchr (argv[0], (int) '/'), \"11\")) : 0;\n  if (0 != curl_global_init (CURL_GLOBAL_WIN32))\n    return 2;\n  errorCount += testInternalDelete ();\n  errorCount += testMultithreadedDelete ();\n  errorCount += testMultithreadedPoolDelete ();\n  errorCount += testExternalDelete ();\n  if (errorCount != 0)\n    fprintf (stderr, \"Error (code: %u)\\n\", errorCount);\n  curl_global_cleanup ();\n  return errorCount != 0;       /* 0 == pass */\n}",
      "lines": 19,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/testcurl/test_digestauth.c": {
    "copyBuffer": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        69,
        1
      ],
      "content": "static size_t\ncopyBuffer (void *ptr, size_t size, size_t nmemb, void *ctx)\n{\n  struct CBC *cbc = ctx;\n\n  if (cbc->pos + size * nmemb > cbc->size)\n    return 0;                   /* overflow */\n  memcpy (&cbc->buf[cbc->pos], ptr, size * nmemb);\n  cbc->pos += size * nmemb;\n  return size * nmemb;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "ahc_echo": {
      "start_point": [
        71,
        0
      ],
      "end_point": [
        132,
        1
      ],
      "content": "static int\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data,\n          size_t *upload_data_size,\n          void **unused)\n{\n  struct MHD_Response *response;\n  char *username;\n  const char *password = \"testpass\";\n  const char *realm = \"test@example.com\";\n  int ret;\n  (void)cls;(void)url;                          /* Unused. Silent compiler warning. */\n  (void)method;(void)version;(void)upload_data; /* Unused. Silent compiler warning. */\n  (void)upload_data_size;(void)unused;         /* Unused. Silent compiler warning. */\n\n  username = MHD_digest_auth_get_username (connection);\n  if ( (username == NULL) ||\n       (0 != strcmp (username, \"testuser\")) )\n    {\n      response = MHD_create_response_from_buffer (strlen (DENIED),\n                                                  DENIED,\n                                                  MHD_RESPMEM_PERSISTENT);\n      ret = MHD_queue_auth_fail_response(connection, realm,\n\t\t\t\t\t MY_OPAQUE,\n\t\t\t\t\t response,\n\t\t\t\t\t MHD_NO);\n      MHD_destroy_response(response);\n      return ret;\n    }\n  ret = MHD_digest_auth_check(connection, realm,\n\t\t\t      username,\n\t\t\t      password,\n\t\t\t      300);\n  free(username);\n  if ( (ret == MHD_INVALID_NONCE) ||\n       (ret == MHD_NO) )\n    {\n      response = MHD_create_response_from_buffer(strlen (DENIED),\n\t\t\t\t\t\t DENIED,\n\t\t\t\t\t\t MHD_RESPMEM_PERSISTENT);\n      if (NULL == response)\n\treturn MHD_NO;\n      ret = MHD_queue_auth_fail_response(connection, realm,\n\t\t\t\t\t MY_OPAQUE,\n\t\t\t\t\t response,\n\t\t\t\t\t (ret == MHD_INVALID_NONCE) ? MHD_YES : MHD_NO);\n      MHD_destroy_response(response);\n      return ret;\n    }\n  response = MHD_create_response_from_buffer (strlen(PAGE),\n                                              PAGE,\n                                              MHD_RESPMEM_PERSISTENT);\n  ret = MHD_queue_response (connection,\n                            MHD_HTTP_OK,\n                            response);\n  MHD_destroy_response (response);\n  return ret;\n}",
      "lines": 62,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testDigestAuth": {
      "start_point": [
        135,
        0
      ],
      "end_point": [
        251,
        1
      ],
      "content": "static int\ntestDigestAuth ()\n{\n  CURL *c;\n  CURLcode errornum;\n  struct MHD_Daemon *d;\n  struct CBC cbc;\n  char buf[2048];\n  char rnd[8];\n  int port;\n  char url[128];\n#ifndef WINDOWS\n  int fd;\n  size_t len;\n  size_t off = 0;\n#endif /* ! WINDOWS */\n\n  if (MHD_NO != MHD_is_feature_supported (MHD_FEATURE_AUTODETECT_BIND_PORT))\n    port = 0;\n  else\n    port = 1165;\n\n  cbc.buf = buf;\n  cbc.size = 2048;\n  cbc.pos = 0;\n#ifndef WINDOWS\n  fd = open(\"/dev/urandom\", O_RDONLY);\n  if (-1 == fd)\n    {\n      fprintf(stderr, \"Failed to open `%s': %s\\n\",\n              \"/dev/urandom\",\n              strerror(errno));\n      return 1;\n    }\n  while (off < 8)\n    {\n      len = read(fd, rnd, 8);\n      if (len == (size_t)-1)\n        {\n          fprintf(stderr, \"Failed to read `%s': %s\\n\",\n                  \"/dev/urandom\",\n                  strerror(errno));\n          (void) close(fd);\n          return 1;\n        }\n      off += len;\n    }\n  (void) close(fd);\n#else\n  {\n    HCRYPTPROV cc;\n    BOOL b;\n    b = CryptAcquireContext (&cc, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT);\n    if (b == 0)\n    {\n      fprintf (stderr, \"Failed to acquire crypto provider context: %lu\\n\",\n          GetLastError ());\n      return 1;\n    }\n    b = CryptGenRandom (cc, 8, (BYTE*)rnd);\n    if (b == 0)\n    {\n      fprintf (stderr, \"Failed to generate 8 random bytes: %lu\\n\",\n          GetLastError ());\n    }\n    CryptReleaseContext (cc, 0);\n    if (b == 0)\n      return 1;\n  }\n#endif\n  d = MHD_start_daemon (MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_ERROR_LOG,\n                        port, NULL, NULL, &ahc_echo, PAGE,\n\t\t\tMHD_OPTION_DIGEST_AUTH_RANDOM, sizeof (rnd), rnd,\n\t\t\tMHD_OPTION_NONCE_NC_SIZE, 300,\n\t\t\tMHD_OPTION_END);\n  if (d == NULL)\n    return 1;\n  if (0 == port)\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (d, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        { MHD_stop_daemon (d); return 32; }\n      port = (int)dinfo->port;\n    }\n  sprintf(url, \"http://127.0.0.1:%d/bar%%20 foo?a=b\u00c3\u00bc%%20\", port);\n  c = curl_easy_init ();\n  curl_easy_setopt (c, CURLOPT_URL, url);\n  curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n  curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc);\n  curl_easy_setopt (c, CURLOPT_HTTPAUTH, CURLAUTH_DIGEST);\n  curl_easy_setopt (c, CURLOPT_USERPWD, \"testuser:testpass\");\n  curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n  curl_easy_setopt (c, CURLOPT_TIMEOUT, 150L);\n  curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT, 150L);\n  curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n  /* NOTE: use of CONNECTTIMEOUT without also\n     setting NOSIGNAL results in really weird\n     crashes on my system!*/\n  curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n  if (CURLE_OK != (errornum = curl_easy_perform (c)))\n    {\n      fprintf (stderr,\n               \"curl_easy_perform failed: `%s'\\n\",\n               curl_easy_strerror (errornum));\n      curl_easy_cleanup (c);\n      MHD_stop_daemon (d);\n      return 2;\n    }\n  curl_easy_cleanup (c);\n  MHD_stop_daemon (d);\n  if (cbc.pos != strlen (PAGE))\n    return 4;\n  if (0 != strncmp (PAGE, cbc.buf, strlen (PAGE)))\n    return 8;\n  return 0;\n}",
      "lines": 117,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        254,
        0
      ],
      "end_point": [
        275,
        1
      ],
      "content": "int\nmain (int argc, char *const *argv)\n{\n  unsigned int errorCount = 0;\n  (void)argc; (void)argv; /* Unused. Silent compiler warning. */\n\n#ifdef MHD_HTTPS_REQUIRE_GRYPT\n#ifdef HAVE_GCRYPT_H\n  gcry_control (GCRYCTL_ENABLE_QUICK_RANDOM, 0);\n#ifdef GCRYCTL_INITIALIZATION_FINISHED\n  gcry_control (GCRYCTL_INITIALIZATION_FINISHED, 0);\n#endif\n#endif\n#endif /* MHD_HTTPS_REQUIRE_GRYPT */\nif (0 != curl_global_init (CURL_GLOBAL_WIN32))\n    return 2;\n  errorCount += testDigestAuth ();\n  if (errorCount != 0)\n    fprintf (stderr, \"Error (code: %u)\\n\", errorCount);\n  curl_global_cleanup ();\n  return errorCount != 0;       /* 0 == pass */\n}",
      "lines": 22,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/testcurl/test_digestauth_with_arguments.c": {
    "copyBuffer": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "static size_t\ncopyBuffer (void *ptr, size_t size, size_t nmemb, void *ctx)\n{\n  struct CBC *cbc = ctx;\n\n  if (cbc->pos + size * nmemb > cbc->size)\n    return 0;                   /* overflow */\n  memcpy (&cbc->buf[cbc->pos], ptr, size * nmemb);\n  cbc->pos += size * nmemb;\n  return size * nmemb;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "ahc_echo": {
      "start_point": [
        70,
        0
      ],
      "end_point": [
        127,
        1
      ],
      "content": "static int\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data, size_t *upload_data_size,\n          void **unused)\n{\n  struct MHD_Response *response;\n  char *username;\n  const char *password = \"testpass\";\n  const char *realm = \"test@example.com\";\n  int ret;\n  (void)cls;(void)url;                          /* Unused. Silent compiler warning. */\n  (void)method;(void)version;(void)upload_data; /* Unused. Silent compiler warning. */\n  (void)upload_data_size;(void)unused;         /* Unused. Silent compiler warning. */\n\n  username = MHD_digest_auth_get_username(connection);\n  if ( (username == NULL) ||\n       (0 != strcmp (username, \"testuser\")) )\n    {\n      response = MHD_create_response_from_buffer(strlen (DENIED), \n\t\t\t\t\t\t DENIED,\n\t\t\t\t\t\t MHD_RESPMEM_PERSISTENT);  \n      ret = MHD_queue_auth_fail_response(connection, realm,\n\t\t\t\t\t MY_OPAQUE,\n\t\t\t\t\t response,\n\t\t\t\t\t MHD_NO);    \n      MHD_destroy_response(response);  \n      return ret;\n    }\n  ret = MHD_digest_auth_check(connection, realm,\n\t\t\t      username, \n\t\t\t      password, \n\t\t\t      300);\n  free(username);\n  if ( (ret == MHD_INVALID_NONCE) ||\n       (ret == MHD_NO) )\n    {\n      response = MHD_create_response_from_buffer(strlen (DENIED), \n\t\t\t\t\t\t DENIED,\n\t\t\t\t\t\t MHD_RESPMEM_PERSISTENT);  \n      if (NULL == response) \n\treturn MHD_NO;\n      ret = MHD_queue_auth_fail_response(connection, realm,\n\t\t\t\t\t MY_OPAQUE,\n\t\t\t\t\t response,\n\t\t\t\t\t (ret == MHD_INVALID_NONCE) ? MHD_YES : MHD_NO);  \n      MHD_destroy_response(response);  \n      return ret;\n    }\n  response = MHD_create_response_from_buffer(strlen(PAGE), PAGE,\n\t\t\t\t\t     MHD_RESPMEM_PERSISTENT);\n  ret = MHD_queue_response(connection, MHD_HTTP_OK, response);  \n  MHD_destroy_response(response);\n  return ret;\n}",
      "lines": 58,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testDigestAuth": {
      "start_point": [
        130,
        0
      ],
      "end_point": [
        246,
        1
      ],
      "content": "static int\ntestDigestAuth ()\n{\n  CURL *c;\n  CURLcode errornum;\n  struct MHD_Daemon *d;\n  struct CBC cbc;\n  char buf[2048];\n  char rnd[8];\n  int port;\n  char url[128];\n#ifndef WINDOWS\n  int fd;\n  size_t len;\n  size_t off = 0;\n#endif /* ! WINDOWS */\n\n  if (MHD_NO != MHD_is_feature_supported (MHD_FEATURE_AUTODETECT_BIND_PORT))\n    port = 0;\n  else\n    port = 1160;\n\n  cbc.buf = buf;\n  cbc.size = 2048;\n  cbc.pos = 0;\n#ifndef WINDOWS\n  fd = open(\"/dev/urandom\", O_RDONLY);\n  if (-1 == fd)\n    {\n\t  fprintf(stderr, \"Failed to open `%s': %s\\n\",\n\t       \"/dev/urandom\",\n\t\t   strerror(errno));\n\t  return 1;\n\t}\n  while (off < 8)\n\t{\n\t  len = read(fd, rnd, 8);\n\t  if (len == (size_t)-1)\n\t    {\n\t\t  fprintf(stderr, \"Failed to read `%s': %s\\n\",\n\t\t       \"/dev/urandom\",\n\t\t\t   strerror(errno));\n\t\t  (void) close(fd);\n\t\t  return 1;\n\t\t}\n\t  off += len;\n\t}\n  (void) close(fd);\n#else\n  {\n    HCRYPTPROV cc;\n    BOOL b;\n    b = CryptAcquireContext (&cc, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT);\n    if (b == 0)\n    {\n      fprintf (stderr, \"Failed to acquire crypto provider context: %lu\\n\",\n          GetLastError ());\n      return 1;\n    }\n    b = CryptGenRandom (cc, 8, (BYTE*)rnd);\n    if (b == 0)\n    {\n      fprintf (stderr, \"Failed to generate 8 random bytes: %lu\\n\",\n          GetLastError ());\n    }\n    CryptReleaseContext (cc, 0);\n    if (b == 0)\n      return 1;\n  }\n#endif\n  d = MHD_start_daemon (MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_ERROR_LOG,\n                        port, NULL, NULL, &ahc_echo, PAGE,\n\t\t\tMHD_OPTION_DIGEST_AUTH_RANDOM, sizeof (rnd), rnd,\n\t\t\tMHD_OPTION_NONCE_NC_SIZE, 300,\n\t\t\tMHD_OPTION_END);\n  if (d == NULL)\n    return 1;\n  if (0 == port)\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (d, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        { MHD_stop_daemon (d); return 32; }\n      port = (int)dinfo->port;\n    }\n  sprintf(url, \"http://127.0.0.1:%d/foo?key=value\", port);\n  c = curl_easy_init ();\n  curl_easy_setopt (c, CURLOPT_URL, url);\n  curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n  curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc);\n  curl_easy_setopt (c, CURLOPT_HTTPAUTH, CURLAUTH_DIGEST);\n  curl_easy_setopt (c, CURLOPT_USERPWD, \"testuser:testpass\");\n  curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n  curl_easy_setopt (c, CURLOPT_TIMEOUT, 150L);\n  curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT, 150L);\n  curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n  /* NOTE: use of CONNECTTIMEOUT without also\n     setting NOSIGNAL results in really weird\n     crashes on my system!*/\n  curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n  if (CURLE_OK != (errornum = curl_easy_perform (c)))\n    {\n      fprintf (stderr,\n               \"curl_easy_perform failed: `%s'\\n\",\n               curl_easy_strerror (errornum));\n      curl_easy_cleanup (c);\n      MHD_stop_daemon (d);\n      return 2;\n    }\n  curl_easy_cleanup (c);\n  MHD_stop_daemon (d);\n  if (cbc.pos != strlen (PAGE))\n    return 4;\n  if (0 != strncmp (PAGE, cbc.buf, strlen (PAGE)))\n    return 8;\n  return 0;\n}",
      "lines": 117,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        249,
        0
      ],
      "end_point": [
        270,
        1
      ],
      "content": "int\nmain (int argc, char *const *argv)\n{\n  unsigned int errorCount = 0;\n  (void)argc; (void)argv; /* Unused. Silent compiler warning. */\n\n#ifdef MHD_HTTPS_REQUIRE_GRYPT\n#ifdef HAVE_GCRYPT_H\n  gcry_control (GCRYCTL_ENABLE_QUICK_RANDOM, 0);\n#ifdef GCRYCTL_INITIALIZATION_FINISHED\n  gcry_control (GCRYCTL_INITIALIZATION_FINISHED, 0);\n#endif\n#endif\n#endif /* MHD_HTTPS_REQUIRE_GRYPT */\n  if (0 != curl_global_init (CURL_GLOBAL_WIN32))\n    return 2;\n  errorCount += testDigestAuth ();\n  if (errorCount != 0)\n    fprintf (stderr, \"Error (code: %u)\\n\", errorCount);\n  curl_global_cleanup ();\n  return errorCount != 0;       /* 0 == pass */\n}",
      "lines": 22,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/testcurl/test_get.c": {
    "copyBuffer": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "static size_t\ncopyBuffer (void *ptr, size_t size, size_t nmemb, void *ctx)\n{\n  struct CBC *cbc = ctx;\n\n  if (cbc->pos + size * nmemb > cbc->size)\n    return 0;                   /* overflow */\n  memcpy (&cbc->buf[cbc->pos], ptr, size * nmemb);\n  cbc->pos += size * nmemb;\n  return size * nmemb;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "ahc_echo": {
      "start_point": [
        78,
        0
      ],
      "end_point": [
        109,
        1
      ],
      "content": "static int\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data, size_t *upload_data_size,\n          void **unused)\n{\n  static int ptr;\n  const char *me = cls;\n  struct MHD_Response *response;\n  int ret;\n  (void)version;(void)upload_data;(void)upload_data_size;       /* Unused. Silent compiler warning. */\n\n  if (0 != strcasecmp (me, method))\n    return MHD_NO;              /* unexpected method */\n  if (&ptr != *unused)\n    {\n      *unused = &ptr;\n      return MHD_YES;\n    }\n  *unused = NULL;\n  response = MHD_create_response_from_buffer (strlen (url),\n\t\t\t\t\t      (void *) url,\n\t\t\t\t\t      MHD_RESPMEM_MUST_COPY);\n  ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n  MHD_destroy_response (response);\n  if (ret == MHD_NO)\n    abort ();\n  return ret;\n}",
      "lines": 32,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testInternalGet": {
      "start_point": [
        112,
        0
      ],
      "end_point": [
        176,
        1
      ],
      "content": "static int\ntestInternalGet (int poll_flag)\n{\n  struct MHD_Daemon *d;\n  CURL *c;\n  char buf[2048];\n  struct CBC cbc;\n  CURLcode errornum;\n\n  if ( (0 == global_port) &&\n       (MHD_NO == MHD_is_feature_supported (MHD_FEATURE_AUTODETECT_BIND_PORT)) )\n    {\n      global_port = 1220;\n      if (oneone)\n        global_port += 20;\n    }\n\n  cbc.buf = buf;\n  cbc.size = 2048;\n  cbc.pos = 0;\n  d = MHD_start_daemon (MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_ERROR_LOG  | poll_flag,\n                        global_port, NULL, NULL, &ahc_echo, \"GET\", MHD_OPTION_END);\n  if (d == NULL)\n    return 1;\n  if (0 == global_port)\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (d, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        { MHD_stop_daemon (d); return 32; }\n      global_port = (int)dinfo->port;\n    }\n  c = curl_easy_init ();\n  curl_easy_setopt (c, CURLOPT_URL, \"http://127.0.0.1/hello_world\");\n  curl_easy_setopt (c, CURLOPT_PORT, (long)global_port);\n  curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n  curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc);\n  curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n  curl_easy_setopt (c, CURLOPT_TIMEOUT, 150L);\n  curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT, 150L);\n  if (oneone)\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n  else\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0);\n  /* NOTE: use of CONNECTTIMEOUT without also\n     setting NOSIGNAL results in really weird\n     crashes on my system!*/\n  curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n  if (CURLE_OK != (errornum = curl_easy_perform (c)))\n    {\n      fprintf (stderr,\n               \"curl_easy_perform failed: `%s'\\n\",\n               curl_easy_strerror (errornum));\n      curl_easy_cleanup (c);\n      MHD_stop_daemon (d);\n      return 2;\n    }\n  curl_easy_cleanup (c);\n  MHD_stop_daemon (d);\n  if (cbc.pos != strlen (\"/hello_world\"))\n    return 4;\n  if (0 != strncmp (\"/hello_world\", cbc.buf, strlen (\"/hello_world\")))\n    return 8;\n  return 0;\n}",
      "lines": 65,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testMultithreadedGet": {
      "start_point": [
        179,
        0
      ],
      "end_point": [
        243,
        1
      ],
      "content": "static int\ntestMultithreadedGet (int poll_flag)\n{\n  struct MHD_Daemon *d;\n  CURL *c;\n  char buf[2048];\n  struct CBC cbc;\n  CURLcode errornum;\n\n  if ( (0 == global_port) &&\n       (MHD_NO == MHD_is_feature_supported (MHD_FEATURE_AUTODETECT_BIND_PORT)) )\n    {\n      global_port = 1221;\n      if (oneone)\n        global_port += 20;\n    }\n\n  cbc.buf = buf;\n  cbc.size = 2048;\n  cbc.pos = 0;\n  d = MHD_start_daemon (MHD_USE_THREAD_PER_CONNECTION | MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_ERROR_LOG  | poll_flag,\n                        global_port, NULL, NULL, &ahc_echo, \"GET\", MHD_OPTION_END);\n  if (d == NULL)\n    return 16;\n  if (0 == global_port)\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (d, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        { MHD_stop_daemon (d); return 32; }\n      global_port = (int)dinfo->port;\n    }\n  c = curl_easy_init ();\n  curl_easy_setopt (c, CURLOPT_URL, \"http://127.0.0.1/hello_world\");\n  curl_easy_setopt (c, CURLOPT_PORT, (long)global_port);\n  curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n  curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc);\n  curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n  curl_easy_setopt (c, CURLOPT_TIMEOUT, 150L);\n  if (oneone)\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n  else\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0);\n  curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT, 150L);\n  /* NOTE: use of CONNECTTIMEOUT without also\n     setting NOSIGNAL results in really weird\n     crashes on my system! */\n  curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n  if (CURLE_OK != (errornum = curl_easy_perform (c)))\n    {\n      fprintf (stderr,\n               \"curl_easy_perform failed: `%s'\\n\",\n               curl_easy_strerror (errornum));\n      curl_easy_cleanup (c);\n      MHD_stop_daemon (d);\n      return 32;\n    }\n  curl_easy_cleanup (c);\n  MHD_stop_daemon (d);\n  if (cbc.pos != strlen (\"/hello_world\"))\n    return 64;\n  if (0 != strncmp (\"/hello_world\", cbc.buf, strlen (\"/hello_world\")))\n    return 128;\n  return 0;\n}",
      "lines": 65,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testMultithreadedPoolGet": {
      "start_point": [
        246,
        0
      ],
      "end_point": [
        311,
        1
      ],
      "content": "static int\ntestMultithreadedPoolGet (int poll_flag)\n{\n  struct MHD_Daemon *d;\n  CURL *c;\n  char buf[2048];\n  struct CBC cbc;\n  CURLcode errornum;\n\n  if ( (0 == global_port) &&\n       (MHD_NO == MHD_is_feature_supported (MHD_FEATURE_AUTODETECT_BIND_PORT)) )\n    {\n      global_port = 1222;\n      if (oneone)\n        global_port += 20;\n    }\n\n  cbc.buf = buf;\n  cbc.size = 2048;\n  cbc.pos = 0;\n  d = MHD_start_daemon (MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_ERROR_LOG | poll_flag,\n                        global_port, NULL, NULL, &ahc_echo, \"GET\",\n                        MHD_OPTION_THREAD_POOL_SIZE, CPU_COUNT, MHD_OPTION_END);\n  if (d == NULL)\n    return 16;\n  if (0 == global_port)\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (d, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        { MHD_stop_daemon (d); return 32; }\n      global_port = (int)dinfo->port;\n    }\n  c = curl_easy_init ();\n  curl_easy_setopt (c, CURLOPT_URL, \"http://127.0.0.1/hello_world\");\n  curl_easy_setopt (c, CURLOPT_PORT, (long)global_port);\n  curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n  curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc);\n  curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n  curl_easy_setopt (c, CURLOPT_TIMEOUT, 150L);\n  if (oneone)\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n  else\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0);\n  curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT, 150L);\n  /* NOTE: use of CONNECTTIMEOUT without also\n     setting NOSIGNAL results in really weird\n     crashes on my system!*/\n  curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n  if (CURLE_OK != (errornum = curl_easy_perform (c)))\n    {\n      fprintf (stderr,\n               \"curl_easy_perform failed: `%s'\\n\",\n               curl_easy_strerror (errornum));\n      curl_easy_cleanup (c);\n      MHD_stop_daemon (d);\n      return 32;\n    }\n  curl_easy_cleanup (c);\n  MHD_stop_daemon (d);\n  if (cbc.pos != strlen (\"/hello_world\"))\n    return 64;\n  if (0 != strncmp (\"/hello_world\", cbc.buf, strlen (\"/hello_world\")))\n    return 128;\n  return 0;\n}",
      "lines": 66,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testExternalGet": {
      "start_point": [
        314,
        0
      ],
      "end_point": [
        467,
        1
      ],
      "content": "static int\ntestExternalGet ()\n{\n  struct MHD_Daemon *d;\n  CURL *c;\n  char buf[2048];\n  struct CBC cbc;\n  CURLM *multi;\n  CURLMcode mret;\n  fd_set rs;\n  fd_set ws;\n  fd_set es;\n  MHD_socket maxsock;\n#ifdef MHD_WINSOCK_SOCKETS\n  int maxposixs; /* Max socket number unused on W32 */\n#else  /* MHD_POSIX_SOCKETS */\n#define maxposixs maxsock\n#endif /* MHD_POSIX_SOCKETS */\n  int running;\n  struct CURLMsg *msg;\n  time_t start;\n  struct timeval tv;\n\n  if ( (0 == global_port) &&\n       (MHD_NO == MHD_is_feature_supported (MHD_FEATURE_AUTODETECT_BIND_PORT)) )\n    {\n      global_port = 1223;\n      if (oneone)\n        global_port += 20;\n    }\n\n  multi = NULL;\n  cbc.buf = buf;\n  cbc.size = 2048;\n  cbc.pos = 0;\n  d = MHD_start_daemon (MHD_USE_ERROR_LOG,\n                        global_port, NULL, NULL, &ahc_echo, \"GET\", MHD_OPTION_END);\n  if (d == NULL)\n    return 256;\n  if (0 == global_port)\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (d, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        { MHD_stop_daemon (d); return 32; }\n      global_port = (int)dinfo->port;\n    }\n  c = curl_easy_init ();\n  curl_easy_setopt (c, CURLOPT_URL, \"http://127.0.0.1/hello_world\");\n  curl_easy_setopt (c, CURLOPT_PORT, (long)global_port);\n  curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n  curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc);\n  curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n  if (oneone)\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n  else\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0);\n  curl_easy_setopt (c, CURLOPT_TIMEOUT, 150L);\n  curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT, 150L);\n  /* NOTE: use of CONNECTTIMEOUT without also\n     setting NOSIGNAL results in really weird\n     crashes on my system! */\n  curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n\n\n  multi = curl_multi_init ();\n  if (multi == NULL)\n    {\n      curl_easy_cleanup (c);\n      MHD_stop_daemon (d);\n      return 512;\n    }\n  mret = curl_multi_add_handle (multi, c);\n  if (mret != CURLM_OK)\n    {\n      curl_multi_cleanup (multi);\n      curl_easy_cleanup (c);\n      MHD_stop_daemon (d);\n      return 1024;\n    }\n  start = time (NULL);\n  while ((time (NULL) - start < 5) && (multi != NULL))\n    {\n      maxsock = MHD_INVALID_SOCKET;\n      maxposixs = -1;\n      FD_ZERO (&rs);\n      FD_ZERO (&ws);\n      FD_ZERO (&es);\n      curl_multi_perform (multi, &running);\n      mret = curl_multi_fdset (multi, &rs, &ws, &es, &maxposixs);\n      if (mret != CURLM_OK)\n        {\n          curl_multi_remove_handle (multi, c);\n          curl_multi_cleanup (multi);\n          curl_easy_cleanup (c);\n          MHD_stop_daemon (d);\n          return 2048;\n        }\n      if (MHD_YES != MHD_get_fdset (d, &rs, &ws, &es, &maxsock))\n        {\n          curl_multi_remove_handle (multi, c);\n          curl_multi_cleanup (multi);\n          curl_easy_cleanup (c);\n          MHD_stop_daemon (d);\n          return 4096;\n        }\n      tv.tv_sec = 0;\n      tv.tv_usec = 1000;\n      if (-1 == select (maxposixs + 1, &rs, &ws, &es, &tv))\n        {\n#ifdef MHD_POSIX_SOCKETS\n          if (EINTR != errno)\n            abort ();\n#else\n          if (WSAEINVAL != WSAGetLastError() || 0 != rs.fd_count || 0 != ws.fd_count || 0 != es.fd_count)\n            abort ();\n          Sleep (1000);\n#endif\n        }\n      curl_multi_perform (multi, &running);\n      if (running == 0)\n        {\n          msg = curl_multi_info_read (multi, &running);\n          if (msg == NULL)\n            break;\n          if (msg->msg == CURLMSG_DONE)\n            {\n              if (msg->data.result != CURLE_OK)\n                printf (\"%s failed at %s:%d: `%s'\\n\",\n                        \"curl_multi_perform\",\n                        __FILE__,\n                        __LINE__, curl_easy_strerror (msg->data.result));\n              curl_multi_remove_handle (multi, c);\n              curl_multi_cleanup (multi);\n              curl_easy_cleanup (c);\n              c = NULL;\n              multi = NULL;\n            }\n        }\n      MHD_run (d);\n    }\n  if (multi != NULL)\n    {\n      curl_multi_remove_handle (multi, c);\n      curl_easy_cleanup (c);\n      curl_multi_cleanup (multi);\n    }\n  MHD_stop_daemon (d);\n  if (cbc.pos != strlen (\"/hello_world\"))\n    return 8192;\n  if (0 != strncmp (\"/hello_world\", cbc.buf, strlen (\"/hello_world\")))\n    return 16384;\n  return 0;\n}",
      "lines": 154,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testUnknownPortGet": {
      "start_point": [
        470,
        0
      ],
      "end_point": [
        551,
        1
      ],
      "content": "static int\ntestUnknownPortGet (int poll_flag)\n{\n  struct MHD_Daemon *d;\n  const union MHD_DaemonInfo *di;\n  CURL *c;\n  char buf[2048];\n  struct CBC cbc;\n  CURLcode errornum;\n  int port;\n\n  struct sockaddr_in addr;\n  socklen_t addr_len = sizeof(addr);\n  memset(&addr, 0, sizeof(addr));\n  addr.sin_family = AF_INET;\n  addr.sin_port = 0;\n  addr.sin_addr.s_addr = INADDR_ANY;\n\n  cbc.buf = buf;\n  cbc.size = 2048;\n  cbc.pos = 0;\n  d = MHD_start_daemon (MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_ERROR_LOG  | poll_flag,\n                        0, NULL, NULL, &ahc_echo, \"GET\",\n                        MHD_OPTION_SOCK_ADDR, &addr,\n                        MHD_OPTION_END);\n  if (MHD_NO == MHD_is_feature_supported (MHD_FEATURE_AUTODETECT_BIND_PORT))\n    {\n      di = MHD_get_daemon_info (d, MHD_DAEMON_INFO_LISTEN_FD);\n      if (di == NULL)\n        return 65536;\n\n      if (0 != getsockname(di->listen_fd, (struct sockaddr *) &addr, &addr_len))\n        return 131072;\n\n      if (addr.sin_family != AF_INET)\n        return 26214;\n      port = (int)ntohs(addr.sin_port);\n    }\n  else\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (d, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        { MHD_stop_daemon (d); return 32; }\n      port = (int)dinfo->port;\n    }\n\n  snprintf(buf, sizeof(buf), \"http://127.0.0.1:%d/hello_world\",\n           port);\n\n  c = curl_easy_init ();\n  curl_easy_setopt (c, CURLOPT_URL, buf);\n  curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n  curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc);\n  curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n  curl_easy_setopt (c, CURLOPT_TIMEOUT, 150L);\n  curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT, 150L);\n  if (oneone)\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n  else\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0);\n  /* NOTE: use of CONNECTTIMEOUT without also\n     setting NOSIGNAL results in really weird\n     crashes on my system! */\n  curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n  if (CURLE_OK != (errornum = curl_easy_perform (c)))\n    {\n      fprintf (stderr,\n               \"curl_easy_perform failed: `%s'\\n\",\n               curl_easy_strerror (errornum));\n      curl_easy_cleanup (c);\n      MHD_stop_daemon (d);\n      return 524288;\n    }\n  curl_easy_cleanup (c);\n  MHD_stop_daemon (d);\n  if (cbc.pos != strlen (\"/hello_world\"))\n    return 1048576;\n  if (0 != strncmp (\"/hello_world\", cbc.buf, strlen (\"/hello_world\")))\n    return 2097152;\n  return 0;\n}",
      "lines": 82,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testStopRace": {
      "start_point": [
        554,
        0
      ],
      "end_point": [
        612,
        1
      ],
      "content": "static int\ntestStopRace (int poll_flag)\n{\n    struct sockaddr_in sin;\n    MHD_socket fd;\n    struct MHD_Daemon *d;\n\n    if ( (0 == global_port) &&\n         (MHD_NO == MHD_is_feature_supported (MHD_FEATURE_AUTODETECT_BIND_PORT)) )\n      {\n        global_port = 1224;\n        if (oneone)\n          global_port += 20;\n      }\n\n    d = MHD_start_daemon (MHD_USE_THREAD_PER_CONNECTION | MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_ERROR_LOG | poll_flag,\n                         global_port, NULL, NULL, &ahc_echo, \"GET\", MHD_OPTION_END);\n    if (d == NULL)\n       return 16;\n    if (0 == global_port)\n      {\n        const union MHD_DaemonInfo *dinfo;\n        dinfo = MHD_get_daemon_info (d, MHD_DAEMON_INFO_BIND_PORT);\n        if (NULL == dinfo || 0 == dinfo->port)\n          { MHD_stop_daemon (d); return 32; }\n        global_port = (int)dinfo->port;\n      }\n\n    fd = socket (PF_INET, SOCK_STREAM, 0);\n    if (fd == MHD_INVALID_SOCKET)\n    {\n       fprintf(stderr, \"socket error\\n\");\n       return 256;\n    }\n\n    memset(&sin, 0, sizeof(sin));\n    sin.sin_family = AF_INET;\n    sin.sin_port = htons(global_port);\n    sin.sin_addr.s_addr = htonl(0x7f000001);\n\n    if (connect (fd, (struct sockaddr *)(&sin), sizeof(sin)) < 0)\n    {\n       fprintf(stderr, \"connect error\\n\");\n       MHD_socket_close_chk_ (fd);\n       return 512;\n    }\n\n    /*  printf(\"Waiting\\n\"); */\n    /* Let the thread get going. */\n    usleep(500000);\n\n    /* printf(\"Stopping daemon\\n\"); */\n    MHD_stop_daemon (d);\n\n    MHD_socket_close_chk_ (fd);\n\n    /* printf(\"good\\n\"); */\n    return 0;\n}",
      "lines": 59,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "ahc_empty": {
      "start_point": [
        615,
        0
      ],
      "end_point": [
        646,
        1
      ],
      "content": "static int\nahc_empty (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data, size_t *upload_data_size,\n          void **unused)\n{\n  static int ptr;\n  struct MHD_Response *response;\n  int ret;\n  (void)cls;(void)url;(void)url;(void)version;  /* Unused. Silent compiler warning. */\n  (void)upload_data;(void)upload_data_size;     /* Unused. Silent compiler warning. */\n\n  if (0 != strcasecmp (\"GET\", method))\n    return MHD_NO;              /* unexpected method */\n  if (&ptr != *unused)\n    {\n      *unused = &ptr;\n      return MHD_YES;\n    }\n  *unused = NULL;\n  response = MHD_create_response_from_buffer (0,\n\t\t\t\t\t      NULL,\n\t\t\t\t\t      MHD_RESPMEM_PERSISTENT);\n  ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n  MHD_destroy_response (response);\n  if (ret == MHD_NO)\n    abort ();\n  return ret;\n}",
      "lines": 32,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "curlExcessFound": {
      "start_point": [
        649,
        0
      ],
      "end_point": [
        661,
        1
      ],
      "content": "static int\ncurlExcessFound(CURL *c, curl_infotype type, char *data, size_t size, void *cls)\n{\n  static const char *excess_found = \"Excess found\";\n  const size_t str_size = strlen (excess_found);\n  (void)c;      /* Unused. Silent compiler warning. */\n\n  if (CURLINFO_TEXT == type\n      && size >= str_size\n      && 0 == strncmp(excess_found, data, str_size))\n    *(int *)cls = 1;\n  return 0;\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testEmptyGet": {
      "start_point": [
        664,
        0
      ],
      "end_point": [
        732,
        1
      ],
      "content": "static int\ntestEmptyGet (int poll_flag)\n{\n  struct MHD_Daemon *d;\n  CURL *c;\n  char buf[2048];\n  struct CBC cbc;\n  CURLcode errornum;\n  int excess_found = 0;\n\n  if ( (0 == global_port) &&\n       (MHD_NO == MHD_is_feature_supported (MHD_FEATURE_AUTODETECT_BIND_PORT)) )\n    {\n      global_port = 1225;\n      if (oneone)\n        global_port += 20;\n    }\n\n  cbc.buf = buf;\n  cbc.size = 2048;\n  cbc.pos = 0;\n  d = MHD_start_daemon (MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_ERROR_LOG  | poll_flag,\n                        global_port, NULL, NULL, &ahc_empty, NULL, MHD_OPTION_END);\n  if (d == NULL)\n    return 4194304;\n  if (0 == global_port)\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (d, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        { MHD_stop_daemon (d); return 32; }\n      global_port = (int)dinfo->port;\n    }\n  c = curl_easy_init ();\n  curl_easy_setopt (c, CURLOPT_URL, \"http://127.0.0.1/hello_world\");\n  curl_easy_setopt (c, CURLOPT_PORT, (long)global_port);\n  curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n  curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc);\n  curl_easy_setopt (c, CURLOPT_DEBUGFUNCTION, &curlExcessFound);\n  curl_easy_setopt (c, CURLOPT_DEBUGDATA, &excess_found);\n  curl_easy_setopt (c, CURLOPT_VERBOSE, 1);\n  curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n  curl_easy_setopt (c, CURLOPT_TIMEOUT, 150L);\n  curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT, 150L);\n  if (oneone)\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n  else\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0);\n  /* NOTE: use of CONNECTTIMEOUT without also\n     setting NOSIGNAL results in really weird\n     crashes on my system!*/\n  curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n  if (CURLE_OK != (errornum = curl_easy_perform (c)))\n    {\n      fprintf (stderr,\n               \"curl_easy_perform failed: `%s'\\n\",\n               curl_easy_strerror (errornum));\n      curl_easy_cleanup (c);\n      MHD_stop_daemon (d);\n      return 8388608;\n    }\n  curl_easy_cleanup (c);\n  MHD_stop_daemon (d);\n  if (cbc.pos != 0)\n    return 16777216;\n  if (excess_found)\n    return 33554432;\n  return 0;\n}",
      "lines": 69,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        735,
        0
      ],
      "end_point": [
        773,
        1
      ],
      "content": "int\nmain (int argc, char *const *argv)\n{\n  unsigned int errorCount = 0;\n  (void)argc;   /* Unused. Silent compiler warning. */\n\n  oneone = (NULL != strrchr (argv[0], (int) '/')) ?\n    (NULL != strstr (strrchr (argv[0], (int) '/'), \"11\")) : 0;\n  if (0 != curl_global_init (CURL_GLOBAL_WIN32))\n    return 2;\n  global_port = 0;\n  errorCount += testInternalGet (0);\n  errorCount += testMultithreadedGet (0);\n  errorCount += testMultithreadedPoolGet (0);\n  errorCount += testUnknownPortGet (0);\n  errorCount += testStopRace (0);\n  errorCount += testExternalGet ();\n  errorCount += testEmptyGet (0);\n  if (MHD_YES == MHD_is_feature_supported(MHD_FEATURE_POLL))\n    {\n      errorCount += testInternalGet(MHD_USE_POLL);\n      errorCount += testMultithreadedGet(MHD_USE_POLL);\n      errorCount += testMultithreadedPoolGet(MHD_USE_POLL);\n      errorCount += testUnknownPortGet(MHD_USE_POLL);\n      errorCount += testStopRace(MHD_USE_POLL);\n      errorCount += testEmptyGet(MHD_USE_POLL);\n    }\n  if (MHD_YES == MHD_is_feature_supported(MHD_FEATURE_EPOLL))\n    {\n      errorCount += testInternalGet(MHD_USE_EPOLL);\n      errorCount += testMultithreadedPoolGet(MHD_USE_EPOLL);\n      errorCount += testUnknownPortGet(MHD_USE_EPOLL);\n      errorCount += testEmptyGet(MHD_USE_EPOLL);\n    }\n  if (errorCount != 0)\n    fprintf (stderr, \"Error (code: %u)\\n\", errorCount);\n  curl_global_cleanup ();\n  return errorCount != 0;       /* 0 == pass */\n}",
      "lines": 39,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/testcurl/test_get_chunked.c": {
    "copyBuffer": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "static size_t\ncopyBuffer (void *ptr,\n            size_t size,\n            size_t nmemb,\n            void *ctx)\n{\n  struct CBC *cbc = ctx;\n\n  if (cbc->pos + size * nmemb > cbc->size)\n    return 0;                   /* overflow */\n  memcpy (&cbc->buf[cbc->pos], ptr, size * nmemb);\n  cbc->pos += size * nmemb;\n  return size * nmemb;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "crc": {
      "start_point": [
        76,
        0
      ],
      "end_point": [
        95,
        1
      ],
      "content": "static ssize_t\ncrc (void *cls,\n     uint64_t pos,\n     char *buf,\n     size_t max)\n{\n  struct MHD_Response **responseptr = cls;\n\n  if (pos == 128 * 10)\n  {\n    MHD_add_response_footer (*responseptr,\n                             \"Footer\",\n                             \"working\");\n    return MHD_CONTENT_READER_END_OF_STREAM;\n  }\n  if (max < 128)\n    abort ();                   /* should not happen in this testcase... */\n  memset (buf, 'A' + (pos / 128), 128);\n  return 128;\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "ssize_t"
      ]
    },
    "crcf": {
      "start_point": [
        101,
        0
      ],
      "end_point": [
        105,
        1
      ],
      "content": "static void\ncrcf (void *ptr)\n{\n  free (ptr);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "ahc_echo": {
      "start_point": [
        108,
        0
      ],
      "end_point": [
        151,
        1
      ],
      "content": "static int\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data, size_t *upload_data_size, void **ptr)\n{\n  static int aptr;\n  const char *me = cls;\n  struct MHD_Response *response;\n  struct MHD_Response **responseptr;\n  int ret;\n  (void)url;(void)version;                      /* Unused. Silent compiler warning. */\n  (void)upload_data;(void)upload_data_size;     /* Unused. Silent compiler warning. */\n\n  if (0 != strcmp (me, method))\n    return MHD_NO;              /* unexpected method */\n  if (&aptr != *ptr)\n    {\n      /* do never respond on first call */\n      *ptr = &aptr;\n      return MHD_YES;\n    }\n  responseptr = malloc (sizeof (struct MHD_Response *));\n  if (NULL == responseptr)\n    return MHD_NO;\n  response = MHD_create_response_from_callback (MHD_SIZE_UNKNOWN,\n                                                1024,\n                                                &crc,\n                                                responseptr,\n                                                &crcf);\n  if (NULL == response)\n  {\n    free (responseptr);\n    return MHD_NO;\n  }\n  *responseptr = response;\n  ret = MHD_queue_response (connection,\n                            MHD_HTTP_OK,\n                            response);\n  MHD_destroy_response (response);\n  return ret;\n}",
      "lines": 44,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "validate": {
      "start_point": [
        154,
        0
      ],
      "end_point": [
        175,
        1
      ],
      "content": "static int\nvalidate (struct CBC cbc, int ebase)\n{\n  int i;\n  char buf[128];\n\n  if (cbc.pos != 128 * 10)\n    return ebase;\n\n  for (i = 0; i < 10; i++)\n    {\n      memset (buf, 'A' + i, 128);\n      if (0 != memcmp (buf, &cbc.buf[i * 128], 128))\n        {\n          fprintf (stderr,\n                   \"Got  `%.*s'\\nWant `%.*s'\\n\",\n                   128, buf, 128, &cbc.buf[i * 128]);\n          return ebase * 2;\n        }\n    }\n  return 0;\n}",
      "lines": 22,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testInternalGet": {
      "start_point": [
        177,
        0
      ],
      "end_point": [
        232,
        1
      ],
      "content": "static int\ntestInternalGet ()\n{\n  struct MHD_Daemon *d;\n  CURL *c;\n  char buf[2048];\n  struct CBC cbc;\n  CURLcode errornum;\n  int port;\n\n  if (MHD_NO != MHD_is_feature_supported (MHD_FEATURE_AUTODETECT_BIND_PORT))\n    port = 0;\n  else\n    port = 1170;\n\n  cbc.buf = buf;\n  cbc.size = 2048;\n  cbc.pos = 0;\n  d = MHD_start_daemon (MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_ERROR_LOG,\n                        port, NULL, NULL, &ahc_echo, \"GET\", MHD_OPTION_END);\n  if (d == NULL)\n    return 1;\n  if (0 == port)\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (d, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        { MHD_stop_daemon (d); return 32; }\n      port = (int)dinfo->port;\n    }\n  c = curl_easy_init ();\n  curl_easy_setopt (c, CURLOPT_URL, \"http://127.0.0.1/hello_world\");\n  curl_easy_setopt (c, CURLOPT_PORT, (long)port);\n  curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n  curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc);\n  curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n  curl_easy_setopt (c, CURLOPT_TIMEOUT, 150L);\n  curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT, 150L);\n  curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n  /* NOTE: use of CONNECTTIMEOUT without also\n   *   setting NOSIGNAL results in really weird\n   *   crashes on my system! */\n  curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n  if (CURLE_OK != (errornum = curl_easy_perform (c)))\n    {\n      fprintf (stderr,\n               \"curl_easy_perform failed: `%s'\\n\",\n               curl_easy_strerror (errornum));\n      curl_easy_cleanup (c);\n      MHD_stop_daemon (d);\n      return 2;\n    }\n  curl_easy_cleanup (c);\n  MHD_stop_daemon (d);\n  return validate (cbc, 4);\n}",
      "lines": 56,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testMultithreadedGet": {
      "start_point": [
        234,
        0
      ],
      "end_point": [
        289,
        1
      ],
      "content": "static int\ntestMultithreadedGet ()\n{\n  struct MHD_Daemon *d;\n  CURL *c;\n  char buf[2048];\n  struct CBC cbc;\n  CURLcode errornum;\n  int port;\n\n  if (MHD_NO != MHD_is_feature_supported (MHD_FEATURE_AUTODETECT_BIND_PORT))\n    port = 0;\n  else\n    port = 1171;\n\n  cbc.buf = buf;\n  cbc.size = 2048;\n  cbc.pos = 0;\n  d = MHD_start_daemon (MHD_USE_THREAD_PER_CONNECTION | MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_ERROR_LOG,\n                        port, NULL, NULL, &ahc_echo, \"GET\", MHD_OPTION_END);\n  if (d == NULL)\n    return 16;\n  if (0 == port)\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (d, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        { MHD_stop_daemon (d); return 32; }\n      port = (int)dinfo->port;\n    }\n  c = curl_easy_init ();\n  curl_easy_setopt (c, CURLOPT_URL, \"http://127.0.0.1/hello_world\");\n  curl_easy_setopt (c, CURLOPT_PORT, (long)port);\n  curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n  curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc);\n  curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n  curl_easy_setopt (c, CURLOPT_TIMEOUT, 150L);\n  curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n  curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT, 150L);\n  /* NOTE: use of CONNECTTIMEOUT without also\n   *   setting NOSIGNAL results in really weird\n   *   crashes on my system! */\n  curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n  if (CURLE_OK != (errornum = curl_easy_perform (c)))\n    {\n      fprintf (stderr,\n               \"curl_easy_perform failed: `%s'\\n\",\n               curl_easy_strerror (errornum));\n      curl_easy_cleanup (c);\n      MHD_stop_daemon (d);\n      return 32;\n    }\n  curl_easy_cleanup (c);\n  MHD_stop_daemon (d);\n  return validate (cbc, 64);\n}",
      "lines": 56,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testMultithreadedPoolGet": {
      "start_point": [
        291,
        0
      ],
      "end_point": [
        347,
        1
      ],
      "content": "static int\ntestMultithreadedPoolGet ()\n{\n  struct MHD_Daemon *d;\n  CURL *c;\n  char buf[2048];\n  struct CBC cbc;\n  CURLcode errornum;\n  int port;\n\n  if (MHD_NO != MHD_is_feature_supported (MHD_FEATURE_AUTODETECT_BIND_PORT))\n    port = 0;\n  else\n    port = 1172;\n\n  cbc.buf = buf;\n  cbc.size = 2048;\n  cbc.pos = 0;\n  d = MHD_start_daemon (MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_ERROR_LOG,\n                        port, NULL, NULL, &ahc_echo, \"GET\",\n                        MHD_OPTION_THREAD_POOL_SIZE, CPU_COUNT, MHD_OPTION_END);\n  if (d == NULL)\n    return 16;\n  if (0 == port)\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (d, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        { MHD_stop_daemon (d); return 32; }\n      port = (int)dinfo->port;\n    }\n  c = curl_easy_init ();\n  curl_easy_setopt (c, CURLOPT_URL, \"http://127.0.0.1/hello_world\");\n  curl_easy_setopt (c, CURLOPT_PORT, (long)port);\n  curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n  curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc);\n  curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n  curl_easy_setopt (c, CURLOPT_TIMEOUT, 150L);\n  curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n  curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT, 150L);\n  /* NOTE: use of CONNECTTIMEOUT without also\n   *   setting NOSIGNAL results in really weird\n   *   crashes on my system! */\n  curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n  if (CURLE_OK != (errornum = curl_easy_perform (c)))\n    {\n      fprintf (stderr,\n               \"curl_easy_perform failed: `%s'\\n\",\n               curl_easy_strerror (errornum));\n      curl_easy_cleanup (c);\n      MHD_stop_daemon (d);\n      return 32;\n    }\n  curl_easy_cleanup (c);\n  MHD_stop_daemon (d);\n  return validate (cbc, 64);\n}",
      "lines": 57,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testExternalGet": {
      "start_point": [
        349,
        0
      ],
      "end_point": [
        493,
        1
      ],
      "content": "static int\ntestExternalGet ()\n{\n  struct MHD_Daemon *d;\n  CURL *c;\n  char buf[2048];\n  struct CBC cbc;\n  CURLM *multi;\n  CURLMcode mret;\n  fd_set rs;\n  fd_set ws;\n  fd_set es;\n  MHD_socket maxsock;\n#ifdef MHD_WINSOCK_SOCKETS\n  int maxposixs; /* Max socket number unused on W32 */\n#else  /* MHD_POSIX_SOCKETS */\n#define maxposixs maxsock\n#endif /* MHD_POSIX_SOCKETS */\n  int running;\n  struct CURLMsg *msg;\n  time_t start;\n  struct timeval tv;\n  int port;\n\n  if (MHD_NO != MHD_is_feature_supported (MHD_FEATURE_AUTODETECT_BIND_PORT))\n    port = 0;\n  else\n    port = 1173;\n\n  multi = NULL;\n  cbc.buf = buf;\n  cbc.size = 2048;\n  cbc.pos = 0;\n  d = MHD_start_daemon (MHD_USE_ERROR_LOG,\n                        port, NULL, NULL, &ahc_echo, \"GET\", MHD_OPTION_END);\n  if (d == NULL)\n    return 256;\n  if (0 == port)\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (d, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        { MHD_stop_daemon (d); return 32; }\n      port = (int)dinfo->port;\n    }\n  c = curl_easy_init ();\n  curl_easy_setopt (c, CURLOPT_URL, \"http://127.0.0.1/hello_world\");\n  curl_easy_setopt (c, CURLOPT_PORT, (long)port);\n  curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n  curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc);\n  curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n  curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n  curl_easy_setopt (c, CURLOPT_TIMEOUT, 150L);\n  curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT, 5L);\n  /* NOTE: use of CONNECTTIMEOUT without also\n   *   setting NOSIGNAL results in really weird\n   *   crashes on my system! */\n  curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n\n\n  multi = curl_multi_init ();\n  if (multi == NULL)\n    {\n      curl_easy_cleanup (c);\n      MHD_stop_daemon (d);\n      return 512;\n    }\n  mret = curl_multi_add_handle (multi, c);\n  if (mret != CURLM_OK)\n    {\n      curl_multi_cleanup (multi);\n      curl_easy_cleanup (c);\n      MHD_stop_daemon (d);\n      return 1024;\n    }\n  start = time (NULL);\n  while ((time (NULL) - start < 5) && (multi != NULL))\n    {\n      maxsock = MHD_INVALID_SOCKET;\n      maxposixs = -1;\n      FD_ZERO (&rs);\n      FD_ZERO (&ws);\n      FD_ZERO (&es);\n      curl_multi_perform (multi, &running);\n      mret = curl_multi_fdset (multi, &rs, &ws, &es, &maxposixs);\n      if (mret != CURLM_OK)\n        {\n          curl_multi_remove_handle (multi, c);\n          curl_multi_cleanup (multi);\n          curl_easy_cleanup (c);\n          MHD_stop_daemon (d);\n          return 2048;\n        }\n      if (MHD_YES != MHD_get_fdset (d, &rs, &ws, &es, &maxsock))\n        {\n          curl_multi_remove_handle (multi, c);\n          curl_multi_cleanup (multi);\n          curl_easy_cleanup (c);\n          MHD_stop_daemon (d);\n          return 4096;\n        }\n      tv.tv_sec = 0;\n      tv.tv_usec = 1000;\n      if (-1 == select (maxposixs + 1, &rs, &ws, &es, &tv))\n        {\n#ifdef MHD_POSIX_SOCKETS\n          if (EINTR != errno)\n            abort ();\n#else\n          if (WSAEINVAL != WSAGetLastError() || 0 != rs.fd_count || 0 != ws.fd_count || 0 != es.fd_count)\n            abort ();\n          Sleep (1000);\n#endif\n        }\n      curl_multi_perform (multi, &running);\n      if (running == 0)\n        {\n          msg = curl_multi_info_read (multi, &running);\n          if (msg == NULL)\n            break;\n          if (msg->msg == CURLMSG_DONE)\n            {\n              if (msg->data.result != CURLE_OK)\n                printf (\"%s failed at %s:%d: `%s'\\n\",\n                        \"curl_multi_perform\",\n                        __FILE__,\n                        __LINE__, curl_easy_strerror (msg->data.result));\n              curl_multi_remove_handle (multi, c);\n              curl_multi_cleanup (multi);\n              curl_easy_cleanup (c);\n              c = NULL;\n              multi = NULL;\n            }\n        }\n      MHD_run (d);\n    }\n  if (multi != NULL)\n    {\n      curl_multi_remove_handle (multi, c);\n      curl_easy_cleanup (c);\n      curl_multi_cleanup (multi);\n    }\n  MHD_stop_daemon (d);\n  return validate (cbc, 8192);\n}",
      "lines": 145,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        497,
        0
      ],
      "end_point": [
        513,
        1
      ],
      "content": "int\nmain (int argc, char *const *argv)\n{\n  unsigned int errorCount = 0;\n  (void)argc; (void)argv; /* Unused. Silent compiler warning. */\n\n  if (0 != curl_global_init (CURL_GLOBAL_WIN32))\n    return 2;\n  errorCount += testInternalGet ();\n  errorCount += testMultithreadedGet ();\n  errorCount += testMultithreadedPoolGet ();\n  errorCount += testExternalGet ();\n  if (errorCount != 0)\n    fprintf (stderr, \"Error (code: %u)\\n\", errorCount);\n  curl_global_cleanup ();\n  return errorCount != 0;       /* 0 == pass */\n}",
      "lines": 17,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/testcurl/test_get_response_cleanup.c": {
    "fork_curl": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        80,
        1
      ],
      "content": "static pid_t\nfork_curl (const char *url)\n{\n  pid_t ret;\n\n  ret = fork();\n  if (ret != 0)\n    return ret;\n  execlp (\"curl\", \"curl\", \"-s\", \"-N\", \"-o\", \"/dev/null\", \"-GET\", url, NULL);\n  fprintf (stderr,\n\t   \"Failed to exec curl: %s\\n\",\n\t   strerror (errno));\n  _exit (-1);\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "pid_t"
      ]
    },
    "kill_curl": {
      "start_point": [
        83,
        0
      ],
      "end_point": [
        91,
        1
      ],
      "content": "static void\nkill_curl (pid_t pid)\n{\n  int status;\n\n  //fprintf (stderr, \"Killing curl\\n\");\n  kill (pid, SIGTERM);\n  waitpid (pid, &status, 0);\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "push_callback": {
      "start_point": [
        94,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "static ssize_t\npush_callback (void *cls, uint64_t pos, char *buf, size_t max)\n{\n  (void)cls;(void)pos;\t/* Unused. Silent compiler warning. */\n\n  if (max == 0)\n    return 0;\n  buf[0] = 'd';\n  return 1;\n}",
      "lines": 10,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "ssize_t"
      ]
    },
    "push_free_callback": {
      "start_point": [
        106,
        0
      ],
      "end_point": [
        113,
        1
      ],
      "content": "static void\npush_free_callback (void *cls)\n{\n  int *ok = cls;\n\n  //fprintf (stderr, \"Cleanup callback called!\\n\");\n  *ok = 0;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "ahc_echo": {
      "start_point": [
        116,
        0
      ],
      "end_point": [
        151,
        1
      ],
      "content": "static int\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data, size_t *upload_data_size,\n          void **unused)\n{\n  static int ptr;\n  const char *me = cls;\n  struct MHD_Response *response;\n  int ret;\n  (void)url;(void)version;                      /* Unused. Silent compiler warning. */\n  (void)upload_data;(void)upload_data_size;     /* Unused. Silent compiler warning. */\n\n  //fprintf (stderr, \"In CB: %s!\\n\", method);\n  if (0 != strcmp (me, method))\n    return MHD_NO;              /* unexpected method */\n  if (&ptr != *unused)\n    {\n      *unused = &ptr;\n      return MHD_YES;\n    }\n  *unused = NULL;\n  response = MHD_create_response_from_callback (MHD_SIZE_UNKNOWN,\n\t\t\t\t\t\t32 * 1024,\n\t\t\t\t\t\t&push_callback,\n\t\t\t\t\t\t&ok,\n\t\t\t\t\t\t&push_free_callback);\n  ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n  MHD_destroy_response (response);\n  if (ret == MHD_NO)\n    abort ();\n  return ret;\n}",
      "lines": 36,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testInternalGet": {
      "start_point": [
        154,
        0
      ],
      "end_point": [
        194,
        1
      ],
      "content": "static int\ntestInternalGet ()\n{\n  struct MHD_Daemon *d;\n  pid_t curl;\n  int port;\n  char url[127];\n\n  if (MHD_NO != MHD_is_feature_supported (MHD_FEATURE_AUTODETECT_BIND_PORT))\n    port = 0;\n  else\n    {\n      port = 1180;\n      if (oneone)\n        port += 10;\n    }\n\n  ok = 1;\n  d = MHD_start_daemon (MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_ERROR_LOG,\n                        port, NULL, NULL, &ahc_echo, \"GET\", MHD_OPTION_END);\n  if (d == NULL)\n    return 1;\n  if (0 == port)\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (d, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        { MHD_stop_daemon (d); return 32; }\n      port = (int)dinfo->port;\n    }\n  sprintf(url, \"http://127.0.0.1:%d/\", port);\n  curl = fork_curl (url);\n  (void)sleep (1);\n  kill_curl (curl);\n  (void)sleep (1);\n  /* fprintf (stderr, \"Stopping daemon!\\n\"); */\n  MHD_stop_daemon (d);\n  if (ok != 0)\n    return 2;\n  return 0;\n}",
      "lines": 41,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testMultithreadedGet": {
      "start_point": [
        197,
        0
      ],
      "end_point": [
        251,
        1
      ],
      "content": "static int\ntestMultithreadedGet ()\n{\n  struct MHD_Daemon *d;\n  pid_t curl;\n  int port;\n  char url[127];\n\n  if (MHD_NO != MHD_is_feature_supported (MHD_FEATURE_AUTODETECT_BIND_PORT))\n    port = 0;\n  else\n    {\n      port = 1181;\n      if (oneone)\n        port += 10;\n    }\n\n  ok = 1;\n  d = MHD_start_daemon (MHD_USE_THREAD_PER_CONNECTION | MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_ERROR_LOG,\n                        port, NULL, NULL, &ahc_echo, \"GET\",\n\t\t\tMHD_OPTION_CONNECTION_TIMEOUT, (unsigned int) 2,\n\t\t\tMHD_OPTION_END);\n  if (d == NULL)\n    return 16;\n  if (0 == port)\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (d, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        { MHD_stop_daemon (d); return 32; }\n      port = (int)dinfo->port;\n    }\n  sprintf(url, \"http://127.0.0.1:%d/\", port);\n  //fprintf (stderr, \"Forking cURL!\\n\");\n  curl = fork_curl (url);\n  (void)sleep (1);\n  kill_curl (curl);\n  (void)sleep (1);\n  curl = fork_curl (url);\n  (void)sleep (1);\n  if (ok != 0)\n    {\n      kill_curl (curl);\n      MHD_stop_daemon (d);\n      return 64;\n    }\n  kill_curl (curl);\n  (void)sleep (1);\n  //fprintf (stderr, \"Stopping daemon!\\n\");\n  MHD_stop_daemon (d);\n  if (ok != 0)\n    return 32;\n\n  return 0;\n}",
      "lines": 55,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testMultithreadedPoolGet": {
      "start_point": [
        254,
        0
      ],
      "end_point": [
        295,
        1
      ],
      "content": "static int\ntestMultithreadedPoolGet ()\n{\n  struct MHD_Daemon *d;\n  pid_t curl;\n  int port;\n  char url[127];\n\n  if (MHD_NO != MHD_is_feature_supported (MHD_FEATURE_AUTODETECT_BIND_PORT))\n    port = 0;\n  else\n    {\n      port = 1182;\n      if (oneone)\n        port += 10;\n    }\n\n  ok = 1;\n  d = MHD_start_daemon (MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_ERROR_LOG,\n                        port, NULL, NULL, &ahc_echo, \"GET\",\n                        MHD_OPTION_THREAD_POOL_SIZE, CPU_COUNT, MHD_OPTION_END);\n  if (d == NULL)\n    return 64;\n  if (0 == port)\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (d, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        { MHD_stop_daemon (d); return 32; }\n      port = (int)dinfo->port;\n    }\n  sprintf(url, \"http://127.0.0.1:%d/\", port);\n  curl = fork_curl (url);\n  (void)sleep (1);\n  kill_curl (curl);\n  (void)sleep (1);\n  //fprintf (stderr, \"Stopping daemon!\\n\");\n  MHD_stop_daemon (d);\n  if (ok != 0)\n    return 128;\n  return 0;\n}",
      "lines": 42,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testExternalGet": {
      "start_point": [
        298,
        0
      ],
      "end_point": [
        385,
        1
      ],
      "content": "static int\ntestExternalGet ()\n{\n  struct MHD_Daemon *d;\n  fd_set rs;\n  fd_set ws;\n  fd_set es;\n  MHD_socket max;\n  time_t start;\n  struct timeval tv;\n  pid_t curl;\n  int port;\n  char url[127];\n\n  if (MHD_NO != MHD_is_feature_supported (MHD_FEATURE_AUTODETECT_BIND_PORT))\n    port = 0;\n  else\n    {\n      port = 1183;\n      if (oneone)\n        port += 10;\n    }\n\n  ok = 1;\n  d = MHD_start_daemon (MHD_USE_ERROR_LOG,\n                        port, NULL, NULL, &ahc_echo, \"GET\", MHD_OPTION_END);\n  if (d == NULL)\n    return 256;\n  if (0 == port)\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (d, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        { MHD_stop_daemon (d); return 32; }\n      port = (int)dinfo->port;\n    }\n  sprintf(url, \"http://127.0.0.1:%d/\", port);\n  curl = fork_curl (url);\n\n  start = time (NULL);\n  while ((time (NULL) - start < 2))\n    {\n      max = 0;\n      FD_ZERO (&rs);\n      FD_ZERO (&ws);\n      FD_ZERO (&es);\n      if (MHD_YES != MHD_get_fdset (d, &rs, &ws, &es, &max))\n        {\n          MHD_stop_daemon (d);\n          return 4096;\n        }\n      tv.tv_sec = 0;\n      tv.tv_usec = 1000;\n      if (-1 == select (max + 1, &rs, &ws, &es, &tv))\n        {\n          if (EINTR != errno)\n            abort ();\n        }\n      MHD_run (d);\n    }\n  kill_curl (curl);\n  start = time (NULL);\n  while ((time (NULL) - start < 2))\n    {\n      max = 0;\n      FD_ZERO (&rs);\n      FD_ZERO (&ws);\n      FD_ZERO (&es);\n      if (MHD_YES != MHD_get_fdset (d, &rs, &ws, &es, &max))\n        {\n          MHD_stop_daemon (d);\n          return 4096;\n        }\n      tv.tv_sec = 0;\n      tv.tv_usec = 1000;\n      if (-1 == select (max + 1, &rs, &ws, &es, &tv))\n        {\n          if (EINTR != errno)\n            abort ();\n        }\n      MHD_run (d);\n    }\n  /* fprintf (stderr, \"Stopping daemon!\\n\"); */\n  MHD_stop_daemon (d);\n  if (ok != 0)\n    return 1024;\n  return 0;\n}",
      "lines": 88,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        388,
        0
      ],
      "end_point": [
        414,
        1
      ],
      "content": "int\nmain (int argc, char *const *argv)\n{\n  unsigned int errorCount = 0;\n  (void)argc;   /* Unused. Silent compiler warning. */\n\n#ifndef _WIN32\n  /* Solaris has no way to disable SIGPIPE on socket disconnect. */\n  if (MHD_NO == MHD_is_feature_supported (MHD_FEATURE_AUTOSUPPRESS_SIGPIPE))\n    {\n      struct sigaction act;\n\n      act.sa_handler = SIG_IGN;\n      sigaction(SIGPIPE, &act, NULL);\n    }\n#endif /* _WIN32 */\n\n  oneone = (NULL != strrchr (argv[0], (int) '/')) ?\n    (NULL != strstr (strrchr (argv[0], (int) '/'), \"11\")) : 0;\n  errorCount += testInternalGet ();\n  errorCount += testMultithreadedGet ();\n  errorCount += testMultithreadedPoolGet ();\n  errorCount += testExternalGet ();\n  if (errorCount != 0)\n    fprintf (stderr, \"Error (code: %u)\\n\", errorCount);\n  return errorCount != 0;       /* 0 == pass */\n}",
      "lines": 27,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/testcurl/test_get_sendfile.c": {
    "copyBuffer": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "static size_t\ncopyBuffer (void *ptr, size_t size, size_t nmemb, void *ctx)\n{\n  struct CBC *cbc = ctx;\n\n  if (cbc->pos + size * nmemb > cbc->size)\n    return 0;                   /* overflow */\n  memcpy (&cbc->buf[cbc->pos], ptr, size * nmemb);\n  cbc->pos += size * nmemb;\n  return size * nmemb;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "ahc_echo": {
      "start_point": [
        75,
        0
      ],
      "end_point": [
        114,
        1
      ],
      "content": "static int\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data, size_t *upload_data_size,\n          void **unused)\n{\n  static int ptr;\n  const char *me = cls;\n  struct MHD_Response *response;\n  int ret;\n  int fd;\n  (void)url;(void)version;                      /* Unused. Silent compiler warning. */\n  (void)upload_data;(void)upload_data_size;     /* Unused. Silent compiler warning. */\n\n  if (0 != strcmp (me, method))\n    return MHD_NO;              /* unexpected method */\n  if (&ptr != *unused)\n    {\n      *unused = &ptr;\n      return MHD_YES;\n    }\n  *unused = NULL;\n  fd = open (sourcefile, O_RDONLY);\n  if (fd == -1)\n    {\n      fprintf (stderr, \"Failed to open `%s': %s\\n\",\n\t       sourcefile,\n\t       strerror (errno));\n      exit (1);\n    }\n  response = MHD_create_response_from_fd (strlen (TESTSTR), fd);\n  ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n  MHD_destroy_response (response);\n  if (ret == MHD_NO)\n    abort ();\n  return ret;\n}",
      "lines": 40,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testInternalGet": {
      "start_point": [
        117,
        0
      ],
      "end_point": [
        183,
        1
      ],
      "content": "static int\ntestInternalGet ()\n{\n  struct MHD_Daemon *d;\n  CURL *c;\n  char buf[2048];\n  struct CBC cbc;\n  CURLcode errornum;\n  int port;\n\n  if (MHD_NO != MHD_is_feature_supported (MHD_FEATURE_AUTODETECT_BIND_PORT))\n    port = 0;\n  else\n    {\n      port = 1200;\n      if (oneone)\n        port += 10;\n    }\n\n  cbc.buf = buf;\n  cbc.size = 2048;\n  cbc.pos = 0;\n  d = MHD_start_daemon (MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_ERROR_LOG,\n                        port, NULL, NULL, &ahc_echo, \"GET\", MHD_OPTION_END);\n  if (d == NULL)\n    return 1;\n  if (0 == port)\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (d, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        { MHD_stop_daemon (d); return 32; }\n      port = (int)dinfo->port;\n    }\n  c = curl_easy_init ();\n  curl_easy_setopt (c, CURLOPT_URL, \"http://127.0.0.1/\");\n  curl_easy_setopt (c, CURLOPT_PORT, (long)port);\n  curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n  curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc);\n  curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n  curl_easy_setopt (c, CURLOPT_TIMEOUT, 150L);\n  curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT, 150L);\n  if (oneone)\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n  else\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0);\n  /* NOTE: use of CONNECTTIMEOUT without also\n     setting NOSIGNAL results in really weird\n     crashes on my system!*/\n  curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n  if (CURLE_OK != (errornum = curl_easy_perform (c)))\n    {\n      fprintf (stderr,\n               \"curl_easy_perform failed: `%s'\\n\",\n               curl_easy_strerror (errornum));\n      curl_easy_cleanup (c);\n      MHD_stop_daemon (d);\n      return 2;\n    }\n  curl_easy_cleanup (c);\n  MHD_stop_daemon (d);\n  if (cbc.pos != strlen (TESTSTR))\n    return 4;\n  if (0 != strncmp (TESTSTR, cbc.buf, strlen (TESTSTR)))\n    return 8;\n  return 0;\n}",
      "lines": 67,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testMultithreadedGet": {
      "start_point": [
        186,
        0
      ],
      "end_point": [
        252,
        1
      ],
      "content": "static int\ntestMultithreadedGet ()\n{\n  struct MHD_Daemon *d;\n  CURL *c;\n  char buf[2048];\n  struct CBC cbc;\n  CURLcode errornum;\n  int port;\n\n  if (MHD_NO != MHD_is_feature_supported (MHD_FEATURE_AUTODETECT_BIND_PORT))\n    port = 0;\n  else\n    {\n      port = 1201;\n      if (oneone)\n        port += 10;\n    }\n\n  cbc.buf = buf;\n  cbc.size = 2048;\n  cbc.pos = 0;\n  d = MHD_start_daemon (MHD_USE_THREAD_PER_CONNECTION | MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_ERROR_LOG,\n                        port, NULL, NULL, &ahc_echo, \"GET\", MHD_OPTION_END);\n  if (d == NULL)\n    return 16;\n  if (0 == port)\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (d, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        { MHD_stop_daemon (d); return 32; }\n      port = (int)dinfo->port;\n    }\n  c = curl_easy_init ();\n  curl_easy_setopt (c, CURLOPT_URL, \"http://127.0.0.1/\");\n  curl_easy_setopt (c, CURLOPT_PORT, (long)port);\n  curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n  curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc);\n  curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n  curl_easy_setopt (c, CURLOPT_TIMEOUT, 150L);\n  if (oneone)\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n  else\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0);\n  curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT, 150L);\n  /* NOTE: use of CONNECTTIMEOUT without also\n     setting NOSIGNAL results in really weird\n     crashes on my system! */\n  curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n  if (CURLE_OK != (errornum = curl_easy_perform (c)))\n    {\n      fprintf (stderr,\n               \"curl_easy_perform failed: `%s'\\n\",\n               curl_easy_strerror (errornum));\n      curl_easy_cleanup (c);\n      MHD_stop_daemon (d);\n      return 32;\n    }\n  curl_easy_cleanup (c);\n  MHD_stop_daemon (d);\n  if (cbc.pos != strlen (TESTSTR))\n    return 64;\n  if (0 != strncmp (TESTSTR, cbc.buf, strlen (TESTSTR)))\n    return 128;\n  return 0;\n}",
      "lines": 67,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testMultithreadedPoolGet": {
      "start_point": [
        255,
        0
      ],
      "end_point": [
        322,
        1
      ],
      "content": "static int\ntestMultithreadedPoolGet ()\n{\n  struct MHD_Daemon *d;\n  CURL *c;\n  char buf[2048];\n  struct CBC cbc;\n  CURLcode errornum;\n  int port;\n\n  if (MHD_NO != MHD_is_feature_supported (MHD_FEATURE_AUTODETECT_BIND_PORT))\n    port = 0;\n  else\n    {\n      port = 1202;\n      if (oneone)\n        port += 10;\n    }\n\n  cbc.buf = buf;\n  cbc.size = 2048;\n  cbc.pos = 0;\n  d = MHD_start_daemon (MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_ERROR_LOG,\n                        port, NULL, NULL, &ahc_echo, \"GET\",\n                        MHD_OPTION_THREAD_POOL_SIZE, CPU_COUNT, MHD_OPTION_END);\n  if (d == NULL)\n    return 16;\n  if (0 == port)\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (d, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        { MHD_stop_daemon (d); return 32; }\n      port = (int)dinfo->port;\n    }\n  c = curl_easy_init ();\n  curl_easy_setopt (c, CURLOPT_URL, \"http://127.0.0.1/\");\n  curl_easy_setopt (c, CURLOPT_PORT, (long)port);\n  curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n  curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc);\n  curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n  curl_easy_setopt (c, CURLOPT_TIMEOUT, 150L);\n  if (oneone)\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n  else\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0);\n  curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT, 150L);\n  /* NOTE: use of CONNECTTIMEOUT without also\n     setting NOSIGNAL results in really weird\n     crashes on my system!*/\n  curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n  if (CURLE_OK != (errornum = curl_easy_perform (c)))\n    {\n      fprintf (stderr,\n               \"curl_easy_perform failed: `%s'\\n\",\n               curl_easy_strerror (errornum));\n      curl_easy_cleanup (c);\n      MHD_stop_daemon (d);\n      return 32;\n    }\n  curl_easy_cleanup (c);\n  MHD_stop_daemon (d);\n  if (cbc.pos != strlen (TESTSTR))\n    return 64;\n  if (0 != strncmp (TESTSTR, cbc.buf, strlen (TESTSTR)))\n    return 128;\n  return 0;\n}",
      "lines": 68,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testExternalGet": {
      "start_point": [
        325,
        0
      ],
      "end_point": [
        480,
        1
      ],
      "content": "static int\ntestExternalGet ()\n{\n  struct MHD_Daemon *d;\n  CURL *c;\n  char buf[2048];\n  struct CBC cbc;\n  CURLM *multi;\n  CURLMcode mret;\n  fd_set rs;\n  fd_set ws;\n  fd_set es;\n  MHD_socket maxsock;\n#ifdef MHD_WINSOCK_SOCKETS\n  int maxposixs; /* Max socket number unused on W32 */\n#else  /* MHD_POSIX_SOCKETS */\n#define maxposixs maxsock\n#endif /* MHD_POSIX_SOCKETS */\n  int running;\n  struct CURLMsg *msg;\n  time_t start;\n  struct timeval tv;\n  int port;\n\n  if (MHD_NO != MHD_is_feature_supported (MHD_FEATURE_AUTODETECT_BIND_PORT))\n    port = 0;\n  else\n    {\n      port = 1203;\n      if (oneone)\n        port += 10;\n    }\n\n  multi = NULL;\n  cbc.buf = buf;\n  cbc.size = 2048;\n  cbc.pos = 0;\n  d = MHD_start_daemon (MHD_USE_ERROR_LOG,\n                        port, NULL, NULL, &ahc_echo, \"GET\", MHD_OPTION_END);\n  if (d == NULL)\n    return 256;\n  if (0 == port)\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (d, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        { MHD_stop_daemon (d); return 32; }\n      port = (int)dinfo->port;\n    }\n  c = curl_easy_init ();\n  curl_easy_setopt (c, CURLOPT_URL, \"http://127.0.0.1/\");\n  curl_easy_setopt (c, CURLOPT_PORT, (long)port);\n  curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n  curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc);\n  curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n  if (oneone)\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n  else\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0);\n  curl_easy_setopt (c, CURLOPT_TIMEOUT, 150L);\n  curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT, 150L);\n  /* NOTE: use of CONNECTTIMEOUT without also\n     setting NOSIGNAL results in really weird\n     crashes on my system! */\n  curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n\n\n  multi = curl_multi_init ();\n  if (multi == NULL)\n    {\n      curl_easy_cleanup (c);\n      MHD_stop_daemon (d);\n      return 512;\n    }\n  mret = curl_multi_add_handle (multi, c);\n  if (mret != CURLM_OK)\n    {\n      curl_multi_cleanup (multi);\n      curl_easy_cleanup (c);\n      MHD_stop_daemon (d);\n      return 1024;\n    }\n  start = time (NULL);\n  while ((time (NULL) - start < 5) && (multi != NULL))\n    {\n      maxsock = MHD_INVALID_SOCKET;\n      maxposixs = -1;\n      FD_ZERO (&rs);\n      FD_ZERO (&ws);\n      FD_ZERO (&es);\n      curl_multi_perform (multi, &running);\n      mret = curl_multi_fdset (multi, &rs, &ws, &es, &maxposixs);\n      if (mret != CURLM_OK)\n        {\n          curl_multi_remove_handle (multi, c);\n          curl_multi_cleanup (multi);\n          curl_easy_cleanup (c);\n          MHD_stop_daemon (d);\n          return 2048;\n        }\n      if (MHD_YES != MHD_get_fdset (d, &rs, &ws, &es, &maxsock))\n        {\n          curl_multi_remove_handle (multi, c);\n          curl_multi_cleanup (multi);\n          curl_easy_cleanup (c);\n          MHD_stop_daemon (d);\n          return 4096;\n        }\n      tv.tv_sec = 0;\n      tv.tv_usec = 1000;\n      if (-1 == select (maxposixs + 1, &rs, &ws, &es, &tv))\n        {\n#ifdef MHD_POSIX_SOCKETS\n          if (EINTR != errno)\n            abort ();\n#else\n          if (WSAEINVAL != WSAGetLastError() || 0 != rs.fd_count || 0 != ws.fd_count || 0 != es.fd_count)\n            abort ();\n          Sleep (1000);\n#endif\n        }\n      curl_multi_perform (multi, &running);\n      if (running == 0)\n        {\n          msg = curl_multi_info_read (multi, &running);\n          if (msg == NULL)\n            break;\n          if (msg->msg == CURLMSG_DONE)\n            {\n              if (msg->data.result != CURLE_OK)\n                printf (\"%s failed at %s:%d: `%s'\\n\",\n                        \"curl_multi_perform\",\n                        __FILE__,\n                        __LINE__, curl_easy_strerror (msg->data.result));\n              curl_multi_remove_handle (multi, c);\n              curl_multi_cleanup (multi);\n              curl_easy_cleanup (c);\n              c = NULL;\n              multi = NULL;\n            }\n        }\n      MHD_run (d);\n    }\n  if (multi != NULL)\n    {\n      curl_multi_remove_handle (multi, c);\n      curl_easy_cleanup (c);\n      curl_multi_cleanup (multi);\n    }\n  MHD_stop_daemon (d);\n  if (cbc.pos != strlen (TESTSTR))\n    return 8192;\n  if (0 != strncmp (TESTSTR, cbc.buf, strlen (TESTSTR)))\n    return 16384;\n  return 0;\n}",
      "lines": 156,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testUnknownPortGet": {
      "start_point": [
        483,
        0
      ],
      "end_point": [
        567,
        1
      ],
      "content": "static int\ntestUnknownPortGet ()\n{\n  struct MHD_Daemon *d;\n  const union MHD_DaemonInfo *di;\n  CURL *c;\n  char buf[2048];\n  struct CBC cbc;\n  CURLcode errornum;\n  int port;\n\n  struct sockaddr_in addr;\n  socklen_t addr_len = sizeof(addr);\n  memset(&addr, 0, sizeof(addr));\n  addr.sin_family = AF_INET;\n  addr.sin_port = 0;\n  addr.sin_addr.s_addr = INADDR_ANY;\n\n  cbc.buf = buf;\n  cbc.size = 2048;\n  cbc.pos = 0;\n  d = MHD_start_daemon (MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_ERROR_LOG,\n                        0, NULL, NULL, &ahc_echo, \"GET\",\n                        MHD_OPTION_SOCK_ADDR, &addr,\n                        MHD_OPTION_END);\n  if (d == NULL)\n    return 32768;\n\n  if (MHD_NO == MHD_is_feature_supported (MHD_FEATURE_AUTODETECT_BIND_PORT))\n    {\n      di = MHD_get_daemon_info (d, MHD_DAEMON_INFO_LISTEN_FD);\n      if (di == NULL)\n        return 65536;\n\n      if (0 != getsockname(di->listen_fd, (struct sockaddr *) &addr, &addr_len))\n        return 131072;\n\n      if (addr.sin_family != AF_INET)\n        return 26214;\n      port = (int)ntohs(addr.sin_port);\n    }\n  else\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (d, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        { MHD_stop_daemon (d); return 32; }\n      port = (int)dinfo->port;\n    }\n\n  snprintf(buf, sizeof(buf), \"http://127.0.0.1:%d/\",\n           port);\n\n  c = curl_easy_init ();\n  curl_easy_setopt (c, CURLOPT_URL, buf);\n  curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n  curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc);\n  curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n  curl_easy_setopt (c, CURLOPT_TIMEOUT, 150L);\n  curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT, 150L);\n  if (oneone)\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n  else\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0);\n  /* NOTE: use of CONNECTTIMEOUT without also\n     setting NOSIGNAL results in really weird\n     crashes on my system! */\n  curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n  if (CURLE_OK != (errornum = curl_easy_perform (c)))\n    {\n      fprintf (stderr,\n               \"curl_easy_perform failed: `%s'\\n\",\n               curl_easy_strerror (errornum));\n      curl_easy_cleanup (c);\n      MHD_stop_daemon (d);\n      return 524288;\n    }\n  curl_easy_cleanup (c);\n  MHD_stop_daemon (d);\n  if (cbc.pos != strlen (TESTSTR))\n    return 1048576;\n  if (0 != strncmp (TESTSTR, cbc.buf, strlen (TESTSTR)))\n    return 2097152;\n  return 0;\n}",
      "lines": 85,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        570,
        0
      ],
      "end_point": [
        611,
        1
      ],
      "content": "int\nmain (int argc, char *const *argv)\n{\n  unsigned int errorCount = 0;\n  const char *tmp;\n  FILE *f;\n  (void)argc;   /* Unused. Silent compiler warning. */\n\n  if ( (NULL == (tmp = getenv (\"TMPDIR\"))) &&\n       (NULL == (tmp = getenv (\"TMP\"))) &&\n       (NULL == (tmp = getenv (\"TEMP\"))) )\n    tmp = \"/tmp\";\n  sourcefile = malloc (strlen (tmp) + 32);\n  sprintf (sourcefile,\n\t   \"%s/%s\",\n\t   tmp,\n\t   \"test-mhd-sendfile\");\n  f = fopen (sourcefile, \"w\");\n  if (NULL == f)\n    {\n      fprintf (stderr, \"failed to write test file\\n\");\n      free (sourcefile);\n      return 1;\n    }\n  fwrite (TESTSTR, strlen (TESTSTR), 1, f);\n  fclose (f);\n  oneone = (NULL != strrchr (argv[0], (int) '/')) ?\n    (NULL != strstr (strrchr (argv[0], (int) '/'), \"11\")) : 0;\n  if (0 != curl_global_init (CURL_GLOBAL_WIN32))\n    return 2;\n  errorCount += testInternalGet ();\n  errorCount += testMultithreadedGet ();\n  errorCount += testMultithreadedPoolGet ();\n  errorCount += testExternalGet ();\n  errorCount += testUnknownPortGet ();\n  if (errorCount != 0)\n    fprintf (stderr, \"Error (code: %u)\\n\", errorCount);\n  curl_global_cleanup ();\n  unlink (sourcefile);\n  free (sourcefile);\n  return errorCount != 0;       /* 0 == pass */\n}",
      "lines": 42,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/testcurl/test_iplimit.c": {
    "copyBuffer": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "static size_t\ncopyBuffer (void *ptr, size_t size, size_t nmemb, void *ctx)\n{\n  struct CBC *cbc = ctx;\n\n  if (cbc->pos + size * nmemb > cbc->size)\n    return 0;                   /* overflow */\n  memcpy (&cbc->buf[cbc->pos], ptr, size * nmemb);\n  cbc->pos += size * nmemb;\n  return size * nmemb;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "ahc_echo": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        105,
        1
      ],
      "content": "static int\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data, size_t *upload_data_size,\n          void **unused)\n{\n  static int ptr;\n  const char *me = cls;\n  struct MHD_Response *response;\n  int ret;\n  (void)version;(void)upload_data;(void)upload_data_size;       /* Unused. Silent compiler warning. */\n\n  if (0 != strcmp (me, method))\n    return MHD_NO;              /* unexpected method */\n  if (&ptr != *unused)\n    {\n      *unused = &ptr;\n      return MHD_YES;\n    }\n  *unused = NULL;\n  response = MHD_create_response_from_buffer (strlen (url),\n\t\t\t\t\t      (void *) url,\n\t\t\t\t\t      MHD_RESPMEM_MUST_COPY);\n  ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n  MHD_destroy_response (response);\n  if (ret == MHD_NO)\n    abort ();\n  return ret;\n}",
      "lines": 32,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testMultithreadedGet": {
      "start_point": [
        107,
        0
      ],
      "end_point": [
        217,
        1
      ],
      "content": "static int\ntestMultithreadedGet ()\n{\n  struct MHD_Daemon *d;\n  char buf[2048];\n  int k;\n  unsigned int success;\n  unsigned int failure;\n  int port;\n\n  if (MHD_NO != MHD_is_feature_supported (MHD_FEATURE_AUTODETECT_BIND_PORT))\n    port = 0;\n  else\n    {\n      port = 1260;\n      if (oneone)\n        port += 5;\n    }\n\n  /* Test only valid for HTTP/1.1 (uses persistent connections) */\n  if (!oneone)\n    return 0;\n\n  d = MHD_start_daemon (MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_ERROR_LOG,\n                        port, NULL, NULL,\n                        &ahc_echo, \"GET\",\n                        MHD_OPTION_PER_IP_CONNECTION_LIMIT, 2,\n                        MHD_OPTION_END);\n  if (d == NULL)\n    return 16;\n  if (0 == port)\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (d, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        { MHD_stop_daemon (d); return 32; }\n      port = (int)dinfo->port;\n    }\n\n  for (k = 0; k < 3; ++k)\n    {\n      struct CBC cbc[3];\n      CURL *cenv[3];\n      int i;\n\n      success = 0;\n      failure = 0;\n      for (i = 0; i < 3; ++i)\n        {\n          CURL *c;\n          CURLcode errornum;\n\n          cenv[i] = c = curl_easy_init ();\n          cbc[i].buf = buf;\n          cbc[i].size = 2048;\n          cbc[i].pos = 0;\n\n          curl_easy_setopt (c, CURLOPT_URL, \"http://127.0.0.1/hello_world\");\n          curl_easy_setopt (c, CURLOPT_PORT, (long)port);\n          curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n          curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc[i]);\n          curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n          curl_easy_setopt (c, CURLOPT_TIMEOUT, 150L);\n          curl_easy_setopt (c, CURLOPT_FORBID_REUSE, 0L);\n          curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n          curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT, 150L);\n          /* NOTE: use of CONNECTTIMEOUT without also\n           *   setting NOSIGNAL results in really weird\n           *   crashes on my system! */\n          curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n\n          errornum = curl_easy_perform (c);\n          if (CURLE_OK == errornum)\n            success++;\n          else\n            failure++;\n        }\n\n      /* Cleanup the environments */\n      for (i = 0; i < 3; ++i)\n        curl_easy_cleanup (cenv[i]);\n      if ( (2 != success) ||\n           (1 != failure) )\n      {\n        fprintf (stderr,\n                 \"Unexpected number of success (%u) or failure (%u)\\n\",\n                 success,\n                 failure);\n        MHD_stop_daemon (d);\n        return 32;\n      }\n\n      (void)sleep(2);\n\n      for (i = 0; i < 2; ++i)\n        {\n          if (cbc[i].pos != strlen (\"/hello_world\"))\n            {\n              MHD_stop_daemon (d);\n              return 64;\n            }\n          if (0 != strncmp (\"/hello_world\", cbc[i].buf, strlen (\"/hello_world\")))\n            {\n              MHD_stop_daemon (d);\n              return 128;\n            }\n        }\n    }\n  MHD_stop_daemon (d);\n  return 0;\n}",
      "lines": 111,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testMultithreadedPoolGet": {
      "start_point": [
        219,
        0
      ],
      "end_point": [
        333,
        1
      ],
      "content": "static int\ntestMultithreadedPoolGet ()\n{\n  struct MHD_Daemon *d;\n  char buf[2048];\n  int k;\n  int port;\n  if (MHD_NO != MHD_is_feature_supported (MHD_FEATURE_AUTODETECT_BIND_PORT))\n    port = 0;\n  else\n    {\n      port = 1261;\n      if (oneone)\n        port += 5;\n    }\n\n  /* Test only valid for HTTP/1.1 (uses persistent connections) */\n  if (!oneone)\n    return 0;\n\n  d = MHD_start_daemon (MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_ERROR_LOG,\n                        port, NULL, NULL, &ahc_echo, \"GET\",\n                        MHD_OPTION_PER_IP_CONNECTION_LIMIT, 2,\n                        MHD_OPTION_THREAD_POOL_SIZE, CPU_COUNT,\n                        MHD_OPTION_END);\n  if (d == NULL)\n    return 16;\n  if (0 == port)\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (d, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        { MHD_stop_daemon (d); return 32; }\n      port = (int)dinfo->port;\n    }\n\n  for (k = 0; k < 3; ++k)\n    {\n      struct CBC cbc[3];\n      CURL *cenv[3];\n      int i;\n\n      for (i = 0; i < 3; ++i)\n        {\n          CURL *c;\n          CURLcode errornum;\n\n          cenv[i] = c = curl_easy_init ();\n          cbc[i].buf = buf;\n          cbc[i].size = 2048;\n          cbc[i].pos = 0;\n\n          curl_easy_setopt (c, CURLOPT_URL, \"http://127.0.0.1/hello_world\");\n          curl_easy_setopt (c, CURLOPT_PORT, (long)port);\n          curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n          curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc[i]);\n          curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n          curl_easy_setopt (c, CURLOPT_TIMEOUT, 150L);\n          curl_easy_setopt (c, CURLOPT_FORBID_REUSE, 0L);\n          curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n          curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT, 150L);\n          /* NOTE: use of CONNECTTIMEOUT without also\n           *   setting NOSIGNAL results in really weird\n           *   crashes on my system! */\n          curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n\n          errornum = curl_easy_perform (c);\n          if ( ( (CURLE_OK != errornum) && (i <  2) ) ||\n\t       ( (CURLE_OK == errornum) && (i == 2) ) )\n            {\n              int j;\n\n              /* First 2 should succeed */\n              if (i < 2)\n                fprintf (stderr,\n                         \"curl_easy_perform failed: `%s'\\n\",\n                         curl_easy_strerror (errornum));\n\n              /* Last request should have failed */\n              else\n                fprintf (stderr,\n                         \"No error on IP address over limit\\n\");\n\n              for (j = 0; j < i; ++j)\n                curl_easy_cleanup (cenv[j]);\n              MHD_stop_daemon (d);\n              return 32;\n            }\n        }\n\n      /* Cleanup the environments */\n      for (i = 0; i < 3; ++i)\n        curl_easy_cleanup (cenv[i]);\n\n      (void)sleep(2);\n\n      for (i = 0; i < 2; ++i)\n        {\n          if (cbc[i].pos != strlen (\"/hello_world\"))\n            {\n              MHD_stop_daemon (d);\n              return 64;\n            }\n          if (0 != strncmp (\"/hello_world\", cbc[i].buf, strlen (\"/hello_world\")))\n            {\n              MHD_stop_daemon (d);\n              return 128;\n            }\n        }\n\n\n    }\n  MHD_stop_daemon (d);\n  return 0;\n}",
      "lines": 115,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        335,
        0
      ],
      "end_point": [
        351,
        1
      ],
      "content": "int\nmain (int argc, char *const *argv)\n{\n  unsigned int errorCount = 0;\n  (void)argc;   /* Unused. Silent compiler warning. */\n\n  oneone = (NULL != strrchr (argv[0], (int) '/')) ?\n    (NULL != strstr (strrchr (argv[0], (int) '/'), \"11\")) : 0;\n  if (0 != curl_global_init (CURL_GLOBAL_WIN32))\n    return 2;\n  errorCount |= testMultithreadedGet ();\n  errorCount |= testMultithreadedPoolGet ();\n  if (errorCount != 0)\n    fprintf (stderr, \"Error (code: %u)\\n\", errorCount);\n  curl_global_cleanup ();\n  return errorCount != 0;       /* 0 == pass */\n}",
      "lines": 17,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/testcurl/test_large_put.c": {
    "alloc_init": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "char*\nalloc_init(size_t buf_size)\n{\n  static const char template[] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz\";\n  static const size_t templ_size = sizeof(template) / sizeof(char) - 1;\n  char *buf;\n  char *fill_ptr;\n  size_t to_fill;\n\n  buf = malloc(buf_size);\n  if (NULL == buf)\n    return NULL;\n\n  fill_ptr = buf;\n  to_fill = buf_size;\n  while (to_fill > 0)\n    {\n      const size_t to_copy = to_fill > templ_size ? templ_size : to_fill;\n      memcpy (fill_ptr, template, to_copy);\n      fill_ptr += to_copy;\n      to_fill -= to_copy;\n    }\n  return buf;\n}",
      "lines": 24,
      "depth": 9,
      "decorators": [
        "char",
        "*\nalloc_init(size_t buf_size)",
        "*"
      ]
    },
    "putBuffer": {
      "start_point": [
        87,
        0
      ],
      "end_point": [
        102,
        1
      ],
      "content": "static size_t\nputBuffer (void *stream, size_t size, size_t nmemb, void *ptr)\n{\n  size_t *pos = (size_t *)ptr;\n  size_t wrt;\n\n  wrt = size * nmemb;\n  /* Check for overflow. */\n  if (wrt / size != nmemb)\n    return 0;\n  if (wrt > PUT_SIZE - (*pos))\n    wrt = PUT_SIZE - (*pos);\n  memcpy (stream, &put_buffer[*pos], wrt);\n  (*pos) += wrt;\n  return wrt;\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "copyBuffer": {
      "start_point": [
        104,
        0
      ],
      "end_point": [
        114,
        1
      ],
      "content": "static size_t\ncopyBuffer (void *ptr, size_t size, size_t nmemb, void *ctx)\n{\n  struct CBC *cbc = ctx;\n\n  if (cbc->pos + size * nmemb > cbc->size)\n    return 0;                   /* overflow */\n  memcpy (&cbc->buf[cbc->pos], ptr, size * nmemb);\n  cbc->pos += size * nmemb;\n  return size * nmemb;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "ahc_echo": {
      "start_point": [
        116,
        0
      ],
      "end_point": [
        172,
        1
      ],
      "content": "static int\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data, size_t *upload_data_size,\n          void **pparam)\n{\n  int *done = cls;\n  struct MHD_Response *response;\n  int ret;\n  static size_t processed;\n  (void)version;        /* Unused. Silent compiler warning. */\n\n  if (0 != strcmp (\"PUT\", method))\n    return MHD_NO;              /* unexpected method */\n  if ((*done) == 0)\n    {\n      size_t *pproc;\n      if (NULL == *pparam)\n        {\n          processed = 0;\n          *pparam = &processed; /* Safe as long as only one parallel request served. */\n        }\n      pproc = (size_t*) *pparam;\n\n      if (0 == *upload_data_size)\n        return MHD_YES; /* No data to process. */\n\n      if (*pproc + *upload_data_size > PUT_SIZE)\n        {\n          fprintf (stderr, \"Incoming data larger than expected.\\n\");\n          return MHD_NO;\n        }\n      if ( (!incr_read) && (*upload_data_size != PUT_SIZE) )\n        return MHD_YES; /* Wait until whole request is received. */\n\n      if (0 != memcmp(upload_data, put_buffer + (*pproc), *upload_data_size))\n        {\n          fprintf (stderr, \"Incoming data does not match sent data.\\n\");\n          return MHD_NO;\n        }\n      *pproc += *upload_data_size;\n      *upload_data_size = 0; /* Current block of data is fully processed. */\n\n      if (PUT_SIZE == *pproc)\n        *done = 1; /* Whole request is processed. */\n      return MHD_YES;\n    }\n  response = MHD_create_response_from_buffer (strlen (url),\n\t\t\t\t\t      (void *) url,\n\t\t\t\t\t      MHD_RESPMEM_MUST_COPY);\n  ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n  MHD_destroy_response (response);\n  return ret;\n}",
      "lines": 57,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testPutInternalThread": {
      "start_point": [
        175,
        0
      ],
      "end_point": [
        252,
        1
      ],
      "content": "static int\ntestPutInternalThread (unsigned int add_flag)\n{\n  struct MHD_Daemon *d;\n  CURL *c;\n  struct CBC cbc;\n  size_t pos = 0;\n  int done_flag = 0;\n  CURLcode errornum;\n  char buf[2048];\n  int port;\n\n  if (MHD_NO != MHD_is_feature_supported (MHD_FEATURE_AUTODETECT_BIND_PORT))\n    port = 0;\n  else\n    {\n      port = 1270;\n      if (oneone)\n        port += 10;\n      if (incr_read)\n        port += 20;\n    }\n\n  cbc.buf = buf;\n  cbc.size = 2048;\n  cbc.pos = 0;\n  d = MHD_start_daemon (MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_ERROR_LOG | add_flag,\n                        port,\n                        NULL, NULL, &ahc_echo, &done_flag,\n\t\t\tMHD_OPTION_CONNECTION_MEMORY_LIMIT, (size_t)(incr_read ? 1024 : (PUT_SIZE * 4)),\n\t\t\tMHD_OPTION_END);\n  if (d == NULL)\n    return 1;\n  if (0 == port)\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (d, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        { MHD_stop_daemon (d); return 32; }\n      port = (int)dinfo->port;\n    }\n  c = curl_easy_init ();\n  curl_easy_setopt (c, CURLOPT_URL, \"http://127.0.0.1/hello_world\");\n  curl_easy_setopt (c, CURLOPT_PORT, (long)port);\n  curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n  curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc);\n  curl_easy_setopt (c, CURLOPT_READFUNCTION, &putBuffer);\n  curl_easy_setopt (c, CURLOPT_READDATA, &pos);\n  curl_easy_setopt (c, CURLOPT_UPLOAD, 1L);\n  curl_easy_setopt (c, CURLOPT_INFILESIZE, (long) PUT_SIZE);\n  curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n  curl_easy_setopt (c, CURLOPT_TIMEOUT, 150L);\n  if (oneone)\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n  else\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0);\n  curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT, 150L);\n  /* NOTE: use of CONNECTTIMEOUT without also\n   *   setting NOSIGNAL results in really weird\n   *   crashes on my system! */\n  curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n  if (CURLE_OK != (errornum = curl_easy_perform (c)))\n    {\n      fprintf (stderr,\n               \"curl_easy_perform failed: `%s'\\n\",\n               curl_easy_strerror (errornum));\n      curl_easy_cleanup (c);\n      MHD_stop_daemon (d);\n      return 2;\n    }\n  curl_easy_cleanup (c);\n  MHD_stop_daemon (d);\n  if (cbc.pos != strlen (\"/hello_world\"))\n    return 4;\n  if (0 != strncmp (\"/hello_world\", cbc.buf, strlen (\"/hello_world\")))\n    return 8;\n  return 0;\n}",
      "lines": 78,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testPutThreadPerConn": {
      "start_point": [
        254,
        0
      ],
      "end_point": [
        335,
        1
      ],
      "content": "static int\ntestPutThreadPerConn (unsigned int add_flag)\n{\n  struct MHD_Daemon *d;\n  CURL *c;\n  struct CBC cbc;\n  size_t pos = 0;\n  int done_flag = 0;\n  CURLcode errornum;\n  char buf[2048];\n  int port;\n\n  if (MHD_NO != MHD_is_feature_supported (MHD_FEATURE_AUTODETECT_BIND_PORT))\n    port = 0;\n  else\n    {\n      port = 1271;\n      if (oneone)\n        port += 10;\n      if (incr_read)\n        port += 20;\n    }\n\n  cbc.buf = buf;\n  cbc.size = 2048;\n  cbc.pos = 0;\n  d = MHD_start_daemon (MHD_USE_THREAD_PER_CONNECTION | MHD_USE_INTERNAL_POLLING_THREAD |\n                          MHD_USE_ERROR_LOG | add_flag,\n                        port,\n                        NULL, NULL, &ahc_echo, &done_flag,\n                        MHD_OPTION_CONNECTION_MEMORY_LIMIT, (size_t)(incr_read ? 1024 : (PUT_SIZE * 4)),\n\t\t\tMHD_OPTION_END);\n  if (d == NULL)\n    return 16;\n  if (0 == port)\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (d, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        { MHD_stop_daemon (d); return 32; }\n      port = (int)dinfo->port;\n    }\n  c = curl_easy_init ();\n  curl_easy_setopt (c, CURLOPT_URL, \"http://127.0.0.1/hello_world\");\n  curl_easy_setopt (c, CURLOPT_PORT, (long)port);\n  curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n  curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc);\n  curl_easy_setopt (c, CURLOPT_READFUNCTION, &putBuffer);\n  curl_easy_setopt (c, CURLOPT_READDATA, &pos);\n  curl_easy_setopt (c, CURLOPT_UPLOAD, 1L);\n  curl_easy_setopt (c, CURLOPT_INFILESIZE, (long) PUT_SIZE);\n  curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n  curl_easy_setopt (c, CURLOPT_TIMEOUT, 150L);\n  if (oneone)\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n  else\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0);\n  curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT, 150L);\n  /* NOTE: use of CONNECTTIMEOUT without also\n   *   setting NOSIGNAL results in really weird\n   *   crashes on my system! */\n  curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n  if (CURLE_OK != (errornum = curl_easy_perform (c)))\n    {\n      fprintf (stderr,\n               \"curl_easy_perform failed: `%s'\\n\",\n               curl_easy_strerror (errornum));\n      curl_easy_cleanup (c);\n      MHD_stop_daemon (d);\n      return 32;\n    }\n  curl_easy_cleanup (c);\n  MHD_stop_daemon (d);\n  if (cbc.pos != strlen (\"/hello_world\"))\n    {\n      fprintf (stderr, \"Got invalid response `%.*s'\\n\", (int)cbc.pos, cbc.buf);\n      return 64;\n    }\n  if (0 != strncmp (\"/hello_world\", cbc.buf, strlen (\"/hello_world\")))\n    return 128;\n  return 0;\n}",
      "lines": 82,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testPutThreadPool": {
      "start_point": [
        337,
        0
      ],
      "end_point": [
        418,
        1
      ],
      "content": "static int\ntestPutThreadPool (unsigned int add_flag)\n{\n  struct MHD_Daemon *d;\n  CURL *c;\n  struct CBC cbc;\n  size_t pos = 0;\n  int done_flag = 0;\n  CURLcode errornum;\n  char buf[2048];\n  int port;\n\n  if (MHD_NO != MHD_is_feature_supported (MHD_FEATURE_AUTODETECT_BIND_PORT))\n    port = 0;\n  else\n    {\n      port = 1272;\n      if (oneone)\n        port += 10;\n      if (incr_read)\n        port += 20;\n    }\n\n  cbc.buf = buf;\n  cbc.size = 2048;\n  cbc.pos = 0;\n  d = MHD_start_daemon (MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_ERROR_LOG | add_flag,\n                        port,\n                        NULL, NULL, &ahc_echo, &done_flag,\n                        MHD_OPTION_THREAD_POOL_SIZE, CPU_COUNT,\n                        MHD_OPTION_CONNECTION_MEMORY_LIMIT, (size_t)(incr_read ? 1024 : (PUT_SIZE * 4)),\n\t\t\tMHD_OPTION_END);\n  if (d == NULL)\n    return 16;\n  if (0 == port)\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (d, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        { MHD_stop_daemon (d); return 32; }\n      port = (int)dinfo->port;\n    }\n  c = curl_easy_init ();\n  curl_easy_setopt (c, CURLOPT_URL, \"http://127.0.0.1/hello_world\");\n  curl_easy_setopt (c, CURLOPT_PORT, (long)port);\n  curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n  curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc);\n  curl_easy_setopt (c, CURLOPT_READFUNCTION, &putBuffer);\n  curl_easy_setopt (c, CURLOPT_READDATA, &pos);\n  curl_easy_setopt (c, CURLOPT_UPLOAD, 1L);\n  curl_easy_setopt (c, CURLOPT_INFILESIZE, (long) PUT_SIZE);\n  curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n  curl_easy_setopt (c, CURLOPT_TIMEOUT, 150L);\n  if (oneone)\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n  else\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0);\n  curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT, 150L);\n  /* NOTE: use of CONNECTTIMEOUT without also\n   *   setting NOSIGNAL results in really weird\n   *   crashes on my system! */\n  curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n  if (CURLE_OK != (errornum = curl_easy_perform (c)))\n    {\n      fprintf (stderr,\n               \"curl_easy_perform failed: `%s'\\n\",\n               curl_easy_strerror (errornum));\n      curl_easy_cleanup (c);\n      MHD_stop_daemon (d);\n      return 32;\n    }\n  curl_easy_cleanup (c);\n  MHD_stop_daemon (d);\n  if (cbc.pos != strlen (\"/hello_world\"))\n    {\n      fprintf (stderr, \"Got invalid response `%.*s'\\n\", (int)cbc.pos, cbc.buf);\n      return 64;\n    }\n  if (0 != strncmp (\"/hello_world\", cbc.buf, strlen (\"/hello_world\")))\n    return 128;\n  return 0;\n}",
      "lines": 82,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testPutExternal": {
      "start_point": [
        420,
        0
      ],
      "end_point": [
        589,
        1
      ],
      "content": "static int\ntestPutExternal (void)\n{\n  struct MHD_Daemon *d;\n  CURL *c;\n  struct CBC cbc;\n  CURLM *multi;\n  CURLMcode mret;\n  fd_set rs;\n  fd_set ws;\n  fd_set es;\n  MHD_socket maxsock;\n#ifdef MHD_WINSOCK_SOCKETS\n  int maxposixs; /* Max socket number unused on W32 */\n#else  /* MHD_POSIX_SOCKETS */\n#define maxposixs maxsock\n#endif /* MHD_POSIX_SOCKETS */\n  int running;\n  struct CURLMsg *msg;\n  time_t start;\n  struct timeval tv;\n  size_t pos = 0;\n  int done_flag = 0;\n  char buf[2048];\n  int port;\n\n  if (MHD_NO != MHD_is_feature_supported (MHD_FEATURE_AUTODETECT_BIND_PORT))\n    port = 0;\n  else\n    {\n      port = 1273;\n      if (oneone)\n        port += 10;\n      if (incr_read)\n        port += 20;\n    }\n\n  cbc.buf = buf;\n  cbc.size = 2048;\n  cbc.pos = 0;\n  multi = NULL;\n  d = MHD_start_daemon (MHD_USE_ERROR_LOG,\n                        port,\n                        NULL, NULL, &ahc_echo, &done_flag,\n                        MHD_OPTION_CONNECTION_MEMORY_LIMIT, (size_t)(incr_read ? 1024 : (PUT_SIZE * 4)),\n                        MHD_OPTION_END);\n  if (d == NULL)\n    return 256;\n  if (0 == port)\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (d, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        { MHD_stop_daemon (d); return 32; }\n      port = (int)dinfo->port;\n    }\n  c = curl_easy_init ();\n  curl_easy_setopt (c, CURLOPT_URL, \"http://127.0.0.1/hello_world\");\n  curl_easy_setopt (c, CURLOPT_PORT, (long)port);\n  curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n  curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc);\n  curl_easy_setopt (c, CURLOPT_READFUNCTION, &putBuffer);\n  curl_easy_setopt (c, CURLOPT_READDATA, &pos);\n  curl_easy_setopt (c, CURLOPT_UPLOAD, 1L);\n  curl_easy_setopt (c, CURLOPT_INFILESIZE, (long) PUT_SIZE);\n  curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n  curl_easy_setopt (c, CURLOPT_TIMEOUT, 150L);\n  if (oneone)\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n  else\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0);\n  curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT, 150L);\n  /* NOTE: use of CONNECTTIMEOUT without also\n   *   setting NOSIGNAL results in really weird\n   *   crashes on my system! */\n  curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n\n\n  multi = curl_multi_init ();\n  if (multi == NULL)\n    {\n      curl_easy_cleanup (c);\n      MHD_stop_daemon (d);\n      return 512;\n    }\n  mret = curl_multi_add_handle (multi, c);\n  if (mret != CURLM_OK)\n    {\n      curl_multi_cleanup (multi);\n      curl_easy_cleanup (c);\n      MHD_stop_daemon (d);\n      return 1024;\n    }\n  start = time (NULL);\n  while ((time (NULL) - start < 5) && (multi != NULL))\n    {\n      maxsock = MHD_INVALID_SOCKET;\n      maxposixs = -1;\n      FD_ZERO (&rs);\n      FD_ZERO (&ws);\n      FD_ZERO (&es);\n      curl_multi_perform (multi, &running);\n      mret = curl_multi_fdset (multi, &rs, &ws, &es, &maxposixs);\n      if (mret != CURLM_OK)\n        {\n          curl_multi_remove_handle (multi, c);\n          curl_multi_cleanup (multi);\n          curl_easy_cleanup (c);\n          MHD_stop_daemon (d);\n          return 2048;\n        }\n      if (MHD_YES != MHD_get_fdset (d, &rs, &ws, &es, &maxsock))\n        {\n          curl_multi_remove_handle (multi, c);\n          curl_multi_cleanup (multi);\n          curl_easy_cleanup (c);\n          MHD_stop_daemon (d);\n          return 4096;\n        }\n      tv.tv_sec = 0;\n      tv.tv_usec = 1000;\n      if (-1 == select (maxposixs + 1, &rs, &ws, &es, &tv))\n        {\n#ifdef MHD_POSIX_SOCKETS\n          if (EINTR != errno)\n            abort ();\n#else\n          if (WSAEINVAL != WSAGetLastError() || 0 != rs.fd_count || 0 != ws.fd_count || 0 != es.fd_count)\n            abort ();\n          Sleep (1000);\n#endif\n        }\n      curl_multi_perform (multi, &running);\n      if (running == 0)\n        {\n          msg = curl_multi_info_read (multi, &running);\n          if (msg == NULL)\n            break;\n          if (msg->msg == CURLMSG_DONE)\n            {\n              if (msg->data.result != CURLE_OK)\n                printf (\"%s failed at %s:%d: `%s'\\n\",\n                        \"curl_multi_perform\",\n                        __FILE__,\n                        __LINE__, curl_easy_strerror (msg->data.result));\n              curl_multi_remove_handle (multi, c);\n              curl_multi_cleanup (multi);\n              curl_easy_cleanup (c);\n              c = NULL;\n              multi = NULL;\n            }\n        }\n      MHD_run (d);\n    }\n  if (multi != NULL)\n    {\n      curl_multi_remove_handle (multi, c);\n      curl_easy_cleanup (c);\n      curl_multi_cleanup (multi);\n    }\n  MHD_stop_daemon (d);\n  if (cbc.pos != strlen (\"/hello_world\"))\n    {\n      fprintf (stderr, \"Got invalid response `%.*s'\\n\", (int)cbc.pos, cbc.buf);\n      return 8192;\n    }\n  if (0 != strncmp (\"/hello_world\", cbc.buf, strlen (\"/hello_world\")))\n    return 16384;\n  return 0;\n}",
      "lines": 170,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        593,
        0
      ],
      "end_point": [
        656,
        1
      ],
      "content": "int\nmain (int argc, char *const *argv)\n{\n  unsigned int errorCount = 0;\n  unsigned int lastErr;\n\n  oneone = has_in_name(argv[0], \"11\");\n  incr_read = has_in_name(argv[0], \"_inc\");\n  verbose = has_param(argc, argv, \"-v\");\n  if (0 != curl_global_init (CURL_GLOBAL_WIN32))\n    return 99;\n  put_buffer = alloc_init (PUT_SIZE);\n  if (NULL == put_buffer)\n    return 99;\n  lastErr = testPutInternalThread (0);\n  if (verbose && 0 != lastErr)\n    fprintf (stderr, \"Error during testing with internal thread with select().\\n\");\n  errorCount += lastErr;\n  lastErr = testPutThreadPerConn (0);\n  if (verbose && 0 != lastErr)\n    fprintf (stderr, \"Error during testing with internal thread per connection with select().\\n\");\n  errorCount += lastErr;\n  lastErr = testPutThreadPool (0);\n  if (verbose && 0 != lastErr)\n    fprintf (stderr, \"Error during testing with thread pool per connection with select().\\n\");\n  errorCount += lastErr;\n  lastErr = testPutExternal ();\n  if (verbose && 0 != lastErr)\n    fprintf (stderr, \"Error during testing with external select().\\n\");\n  errorCount += lastErr;\n  if (MHD_is_feature_supported(MHD_FEATURE_POLL))\n    {\n      lastErr = testPutInternalThread (MHD_USE_POLL);\n      if (verbose && 0 != lastErr)\n        fprintf (stderr, \"Error during testing with internal thread with poll().\\n\");\n      errorCount += lastErr;\n      lastErr = testPutThreadPerConn (MHD_USE_POLL);\n      if (verbose && 0 != lastErr)\n        fprintf (stderr, \"Error during testing with internal thread per connection with poll().\\n\");\n      errorCount += lastErr;\n      lastErr = testPutThreadPool (MHD_USE_POLL);\n      if (verbose && 0 != lastErr)\n        fprintf (stderr, \"Error during testing with thread pool per connection with poll().\\n\");\n      errorCount += lastErr;\n    }\n  if (MHD_is_feature_supported(MHD_FEATURE_EPOLL))\n    {\n      lastErr = testPutInternalThread (MHD_USE_EPOLL);\n      if (verbose && 0 != lastErr)\n        fprintf (stderr, \"Error during testing with internal thread with epoll.\\n\");\n      errorCount += lastErr;\n      lastErr = testPutThreadPool (MHD_USE_EPOLL);\n      if (verbose && 0 != lastErr)\n        fprintf (stderr, \"Error during testing with thread pool per connection with epoll.\\n\");\n      errorCount += lastErr;\n    }\n  free (put_buffer);\n  if (errorCount != 0)\n    fprintf (stderr, \"Error (code: %u)\\n\", errorCount);\n  else if (verbose)\n    printf (\"All checks passed successfully.\\n\");\n  curl_global_cleanup ();\n  return (errorCount == 0) ? 0 : 1;\n}",
      "lines": 64,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/testcurl/test_long_header.c": {
    "apc_all": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "static int\napc_all (void *cls, const struct sockaddr *addr, socklen_t addrlen)\n{\n  (void)cls;(void)addr;(void)addrlen;   /* Unused. Silent compiler warning. */\n  return MHD_YES;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "copyBuffer": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "static size_t\ncopyBuffer (void *ptr, size_t size, size_t nmemb, void *ctx)\n{\n  (void)ptr;(void)ctx;  /* Unused. Silent compiler warning. */\n  return size * nmemb;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "ahc_echo": {
      "start_point": [
        68,
        0
      ],
      "end_point": [
        91,
        1
      ],
      "content": "static int\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data, size_t *upload_data_size,\n          void **unused)\n{\n  const char *me = cls;\n  struct MHD_Response *response;\n  int ret;\n  (void)version;(void)upload_data;      /* Unused. Silent compiler warning. */\n  (void)upload_data_size;(void)unused;  /* Unused. Silent compiler warning. */\n\n  if (0 != strcmp (me, method))\n    return MHD_NO;              /* unexpected method */\n  response = MHD_create_response_from_buffer (strlen (url),\n\t\t\t\t\t      (void *) url,\n\t\t\t\t\t      MHD_RESPMEM_MUST_COPY);\n  ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n  MHD_destroy_response (response);\n  return ret;\n}",
      "lines": 24,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testLongUrlGet": {
      "start_point": [
        94,
        0
      ],
      "end_point": [
        179,
        1
      ],
      "content": "static int\ntestLongUrlGet ()\n{\n  struct MHD_Daemon *d;\n  CURL *c;\n  char buf[2048];\n  struct CBC cbc;\n  char *url;\n  long code;\n  int port;\n\n  if (MHD_NO != MHD_is_feature_supported (MHD_FEATURE_AUTODETECT_BIND_PORT))\n    port = 0;\n  else\n    {\n      port = 1330;\n      if (oneone)\n        port += 5;\n    }\n  cbc.buf = buf;\n  cbc.size = 2048;\n  cbc.pos = 0;\n  d = MHD_start_daemon (MHD_USE_INTERNAL_POLLING_THREAD /* | MHD_USE_ERROR_LOG */ ,\n                        port,\n                        &apc_all,\n                        NULL,\n                        &ahc_echo,\n                        \"GET\",\n                        MHD_OPTION_CONNECTION_MEMORY_LIMIT,\n                        (size_t) (VERY_LONG / 2), MHD_OPTION_END);\n  if (d == NULL)\n    return 1;\n  if (0 == port)\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (d, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        { MHD_stop_daemon (d); return 32; }\n      port = (int)dinfo->port;\n    }\n  c = curl_easy_init ();\n  url = malloc (VERY_LONG);\n  if (url == NULL)\n    {\n\tMHD_stop_daemon (d);\n \treturn 1;\n    }\n  memset (url, 'a', VERY_LONG);\n  url[VERY_LONG - 1] = '\\0';\n  memcpy (url, \"http://127.0.0.1/\", strlen (\"http://127.0.0.1/\"));\n  curl_easy_setopt (c, CURLOPT_URL, url);\n  curl_easy_setopt (c, CURLOPT_PORT, (long)port);\n  curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n  curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc);\n  curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n  curl_easy_setopt (c, CURLOPT_TIMEOUT, 150L);\n  curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT, 150L);\n  if (oneone)\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n  else\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0);\n  /* NOTE: use of CONNECTTIMEOUT without also\n     setting NOSIGNAL results in really weird\n     crashes on my system! */\n  curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n  if (CURLE_OK == curl_easy_perform (c))\n    {\n      curl_easy_cleanup (c);\n      MHD_stop_daemon (d);\n      free (url);\n      return 2;\n    }\n  if (CURLE_OK != curl_easy_getinfo (c, CURLINFO_RESPONSE_CODE, &code))\n    {\n      curl_easy_cleanup (c);\n      MHD_stop_daemon (d);\n      free (url);\n      return 4;\n    }\n  curl_easy_cleanup (c);\n  MHD_stop_daemon (d);\n  free (url);\n  if (code != MHD_HTTP_URI_TOO_LONG)\n    return 8;\n  return 0;\n}",
      "lines": 86,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testLongHeaderGet": {
      "start_point": [
        182,
        0
      ],
      "end_point": [
        276,
        1
      ],
      "content": "static int\ntestLongHeaderGet ()\n{\n  struct MHD_Daemon *d;\n  CURL *c;\n  char buf[2048];\n  struct CBC cbc;\n  char *url;\n  long code;\n  struct curl_slist *header = NULL;\n  int port;\n\n  if (MHD_NO != MHD_is_feature_supported (MHD_FEATURE_AUTODETECT_BIND_PORT))\n    port = 0;\n  else\n    {\n      port = 1331;\n      if (oneone)\n        port += 5;\n    }\n\n  cbc.buf = buf;\n  cbc.size = 2048;\n  cbc.pos = 0;\n  d = MHD_start_daemon (MHD_USE_INTERNAL_POLLING_THREAD /* | MHD_USE_ERROR_LOG */ ,\n                        port,\n                        &apc_all,\n                        NULL,\n                        &ahc_echo,\n                        \"GET\",\n                        MHD_OPTION_CONNECTION_MEMORY_LIMIT,\n                        (size_t) (VERY_LONG / 2), MHD_OPTION_END);\n  if (d == NULL)\n    return 16;\n  if (0 == port)\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (d, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        { MHD_stop_daemon (d); return 32; }\n      port = (int)dinfo->port;\n    }\n  c = curl_easy_init ();\n  url = malloc (VERY_LONG);\n  if (url == NULL)\n     {\n\tMHD_stop_daemon (d);\n\treturn 16;\n     }\n  memset (url, 'a', VERY_LONG);\n  url[VERY_LONG - 1] = '\\0';\n  url[VERY_LONG / 2] = ':';\n  url[VERY_LONG / 2 + 1] = ' ';\n  header = curl_slist_append (header, url);\n\n  curl_easy_setopt (c, CURLOPT_HTTPHEADER, header);\n  curl_easy_setopt (c, CURLOPT_URL, \"http://127.0.0.1/hello_world\");\n  curl_easy_setopt (c, CURLOPT_PORT, (long)port);\n  curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n  curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc);\n  curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n  curl_easy_setopt (c, CURLOPT_TIMEOUT, 150L);\n  curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT, 150L);\n  if (oneone)\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n  else\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0);\n  /* NOTE: use of CONNECTTIMEOUT without also\n     setting NOSIGNAL results in really weird\n     crashes on my system! */\n  curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n  if (CURLE_OK == curl_easy_perform (c))\n    {\n      curl_easy_cleanup (c);\n      MHD_stop_daemon (d);\n      curl_slist_free_all (header);\n      free (url);\n      return 32;\n    }\n  if (CURLE_OK != curl_easy_getinfo (c, CURLINFO_RESPONSE_CODE, &code))\n    {\n      curl_slist_free_all (header);\n      curl_easy_cleanup (c);\n      MHD_stop_daemon (d);\n      free (url);\n      return 64;\n    }\n  curl_slist_free_all (header);\n  curl_easy_cleanup (c);\n  MHD_stop_daemon (d);\n  free (url);\n  if (code != MHD_HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE)\n    return 128;\n  return 0;\n}",
      "lines": 95,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        278,
        0
      ],
      "end_point": [
        294,
        1
      ],
      "content": "int\nmain (int argc, char *const *argv)\n{\n  unsigned int errorCount = 0;\n  (void)argc;   /* Unused. Silent compiler warning. */\n\n  oneone = (NULL != strrchr (argv[0], (int) '/')) ?\n    (NULL != strstr (strrchr (argv[0], (int) '/'), \"11\")) : 0;\n  if (0 != curl_global_init (CURL_GLOBAL_WIN32))\n    return 2;\n  errorCount += testLongUrlGet ();\n  errorCount += testLongHeaderGet ();\n  if (errorCount != 0)\n    fprintf (stderr, \"Error (code: %u)\\n\", errorCount);\n  curl_global_cleanup ();\n  return errorCount != 0;       /* 0 == pass */\n}",
      "lines": 17,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/testcurl/test_parse_cookies.c": {
    "copyBuffer": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "static size_t\ncopyBuffer (void *ptr, size_t size, size_t nmemb, void *ctx)\n{\n  struct CBC *cbc = ctx;\n\n  if (cbc->pos + size * nmemb > cbc->size)\n    return 0;                   /* overflow */\n  memcpy (&cbc->buf[cbc->pos], ptr, size * nmemb);\n  cbc->pos += size * nmemb;\n  return size * nmemb;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "ahc_echo": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        105,
        1
      ],
      "content": "static int\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data, size_t *upload_data_size,\n          void **unused)\n{\n  static int ptr;\n  const char *me = cls;\n  struct MHD_Response *response;\n  int ret;\n  const char *hdr;\n  (void)version;(void)upload_data;(void)upload_data_size;       /* Unused. Silent compiler warning. */\n\n  if (0 != strcmp (me, method))\n    return MHD_NO;              /* unexpected method */\n  if (&ptr != *unused)\n    {\n      *unused = &ptr;\n      return MHD_YES;\n    }\n  *unused = NULL;\n\n  hdr = MHD_lookup_connection_value (connection, MHD_COOKIE_KIND, \"name1\");\n  if ((hdr == NULL) || (0 != strcmp (hdr, \"var1\")))\n    abort ();\n  hdr = MHD_lookup_connection_value (connection, MHD_COOKIE_KIND, \"name2\");\n  if ((hdr == NULL) || (0 != strcmp (hdr, \"var2\")))\n    abort ();\n  hdr = MHD_lookup_connection_value (connection, MHD_COOKIE_KIND, \"name3\");\n  if ((hdr == NULL) || (0 != strcmp (hdr, \"\")))\n    abort ();\n  hdr = MHD_lookup_connection_value (connection, MHD_COOKIE_KIND, \"name4\");\n  if ((hdr == NULL) || (0 != strcmp (hdr, \"var4 with spaces\")))\n    abort ();\n  response = MHD_create_response_from_buffer (strlen (url),\n\t\t\t\t\t      (void *) url,\n\t\t\t\t\t      MHD_RESPMEM_PERSISTENT);\n  ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n  MHD_destroy_response (response);\n  if (ret == MHD_NO)\n    abort ();\n  return ret;\n}",
      "lines": 46,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testExternalGet": {
      "start_point": [
        107,
        0
      ],
      "end_point": [
        267,
        1
      ],
      "content": "static int\ntestExternalGet ()\n{\n  struct MHD_Daemon *d;\n  CURL *c;\n  char buf[2048];\n  struct CBC cbc;\n  CURLM *multi;\n  CURLMcode mret;\n  fd_set rs;\n  fd_set ws;\n  fd_set es;\n  MHD_socket maxsock;\n#ifdef MHD_WINSOCK_SOCKETS\n  int maxposixs; /* Max socket number unused on W32 */\n#else  /* MHD_POSIX_SOCKETS */\n#define maxposixs maxsock\n#endif /* MHD_POSIX_SOCKETS */\n  int running;\n  struct CURLMsg *msg;\n  time_t start;\n  struct timeval tv;\n  int port;\n\n  if (MHD_NO != MHD_is_feature_supported (MHD_FEATURE_AUTODETECT_BIND_PORT))\n    port = 0;\n  else\n    {\n      port = 1340;\n      if (oneone)\n        port += 5;\n    }\n\n  multi = NULL;\n  cbc.buf = buf;\n  cbc.size = 2048;\n  cbc.pos = 0;\n  d = MHD_start_daemon (MHD_USE_ERROR_LOG,\n                        port, NULL, NULL, &ahc_echo, \"GET\", MHD_OPTION_END);\n  if (d == NULL)\n    return 256;\n  if (0 == port)\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (d, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        { MHD_stop_daemon (d); return 32; }\n      port = (int)dinfo->port;\n    }\n  c = curl_easy_init ();\n  curl_easy_setopt (c, CURLOPT_URL, \"http://127.0.0.1/hello_world\");\n  curl_easy_setopt (c, CURLOPT_PORT, (long)port);\n  curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n  curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc);\n  curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n  /* note that the string below intentionally uses the\n     various ways cookies can be specified to exercise the\n     parser! Do not change! */\n  curl_easy_setopt (c, CURLOPT_COOKIE,\n                    \"name1=var1; name2=var2,name3 ;name4=\\\"var4 with spaces\\\";\");\n  if (oneone)\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n  else\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0);\n  curl_easy_setopt (c, CURLOPT_TIMEOUT, 150L);\n  curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT, 150L);\n  /* NOTE: use of CONNECTTIMEOUT without also\n     setting NOSIGNAL results in really weird\n     crashes on my system! */\n  curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n\n\n  multi = curl_multi_init ();\n  if (multi == NULL)\n    {\n      curl_easy_cleanup (c);\n      MHD_stop_daemon (d);\n      return 512;\n    }\n  mret = curl_multi_add_handle (multi, c);\n  if (mret != CURLM_OK)\n    {\n      curl_multi_cleanup (multi);\n      curl_easy_cleanup (c);\n      MHD_stop_daemon (d);\n      return 1024;\n    }\n  start = time (NULL);\n  while ((time (NULL) - start < 5) && (multi != NULL))\n    {\n      maxsock = MHD_INVALID_SOCKET;\n      maxposixs = -1;\n      FD_ZERO (&rs);\n      FD_ZERO (&ws);\n      FD_ZERO (&es);\n      curl_multi_perform (multi, &running);\n      mret = curl_multi_fdset (multi, &rs, &ws, &es, &maxposixs);\n      if (mret != CURLM_OK)\n        {\n          curl_multi_remove_handle (multi, c);\n          curl_multi_cleanup (multi);\n          curl_easy_cleanup (c);\n          MHD_stop_daemon (d);\n          return 2048;\n        }\n      if (MHD_YES != MHD_get_fdset (d, &rs, &ws, &es, &maxsock))\n        {\n          curl_multi_remove_handle (multi, c);\n          curl_multi_cleanup (multi);\n          curl_easy_cleanup (c);\n          MHD_stop_daemon (d);\n          return 4096;\n        }\n      tv.tv_sec = 0;\n      tv.tv_usec = 1000;\n      if (-1 == select (maxposixs + 1, &rs, &ws, &es, &tv))\n        {\n#ifdef MHD_POSIX_SOCKETS\n          if (EINTR != errno)\n            abort ();\n#else\n          if (WSAEINVAL != WSAGetLastError() || 0 != rs.fd_count || 0 != ws.fd_count || 0 != es.fd_count)\n            abort ();\n          Sleep (1000);\n#endif\n        }\n      curl_multi_perform (multi, &running);\n      if (running == 0)\n        {\n          msg = curl_multi_info_read (multi, &running);\n          if (msg == NULL)\n            break;\n          if (msg->msg == CURLMSG_DONE)\n            {\n              if (msg->data.result != CURLE_OK)\n                printf (\"%s failed at %s:%d: `%s'\\n\",\n                        \"curl_multi_perform\",\n                        __FILE__,\n                        __LINE__, curl_easy_strerror (msg->data.result));\n              curl_multi_remove_handle (multi, c);\n              curl_multi_cleanup (multi);\n              curl_easy_cleanup (c);\n              c = NULL;\n              multi = NULL;\n            }\n        }\n      MHD_run (d);\n    }\n  if (multi != NULL)\n    {\n      curl_multi_remove_handle (multi, c);\n      curl_easy_cleanup (c);\n      curl_multi_cleanup (multi);\n    }\n  MHD_stop_daemon (d);\n  if (cbc.pos != strlen (\"/hello_world\"))\n    return 8192;\n  if (0 != strncmp (\"/hello_world\", cbc.buf, strlen (\"/hello_world\")))\n    return 16384;\n  return 0;\n}",
      "lines": 161,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        270,
        0
      ],
      "end_point": [
        285,
        1
      ],
      "content": "int\nmain (int argc, char *const *argv)\n{\n  unsigned int errorCount = 0;\n  (void)argc;   /* Unused. Silent compiler warning. */\n\n  oneone = (NULL != strrchr (argv[0], (int) '/')) ?\n    (NULL != strstr (strrchr (argv[0], (int) '/'), \"11\")) : 0;\n  if (0 != curl_global_init (CURL_GLOBAL_WIN32))\n    return 2;\n  errorCount += testExternalGet ();\n  if (errorCount != 0)\n    fprintf (stderr, \"Error (code: %u)\\n\", errorCount);\n  curl_global_cleanup ();\n  return errorCount != 0;       /* 0 == pass */\n}",
      "lines": 16,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/testcurl/test_post.c": {
    "completed_cb": {
      "start_point": [
        64,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "static void\ncompleted_cb (void *cls,\n\t      struct MHD_Connection *connection,\n\t      void **con_cls,\n\t      enum MHD_RequestTerminationCode toe)\n{\n  struct MHD_PostProcessor *pp = *con_cls;\n  (void)cls;(void)connection;(void)toe; /* Unused. Silent compiler warning. */\n\n  if (NULL != pp)\n    MHD_destroy_post_processor (pp);\n  *con_cls = NULL;\n}",
      "lines": 13,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "copyBuffer": {
      "start_point": [
        79,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "static size_t\ncopyBuffer (void *ptr, size_t size, size_t nmemb, void *ctx)\n{\n  struct CBC *cbc = ctx;\n\n  if (cbc->pos + size * nmemb > cbc->size)\n    return 0;                   /* overflow */\n  memcpy (&cbc->buf[cbc->pos], ptr, size * nmemb);\n  cbc->pos += size * nmemb;\n  return size * nmemb;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "post_iterator": {
      "start_point": [
        97,
        0
      ],
      "end_point": [
        117,
        1
      ],
      "content": "static int\npost_iterator (void *cls,\n               enum MHD_ValueKind kind,\n               const char *key,\n               const char *filename,\n               const char *content_type,\n               const char *transfer_encoding,\n               const char *value, uint64_t off, size_t size)\n{\n  int *eok = cls;\n  (void)kind;(void)filename;(void)content_type; /* Unused. Silent compiler warning. */\n  (void)transfer_encoding;(void)off;            /* Unused. Silent compiler warning. */\n\n  if ((0 == strcasecmp (key, \"name\")) &&\n      (size == strlen (\"daniel\")) && (0 == strncmp (value, \"daniel\", size)))\n    (*eok) |= 1;\n  if ((0 == strcasecmp (key, \"project\")) &&\n      (size == strlen (\"curl\")) && (0 == strncmp (value, \"curl\", size)))\n    (*eok) |= 2;\n  return MHD_YES;\n}",
      "lines": 21,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "ahc_echo": {
      "start_point": [
        120,
        0
      ],
      "end_point": [
        161,
        1
      ],
      "content": "static int\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data, size_t *upload_data_size,\n          void **unused)\n{\n  static int eok;\n  struct MHD_Response *response;\n  struct MHD_PostProcessor *pp;\n  int ret;\n  (void)cls;(void)version;      /* Unused. Silent compiler warning. */\n\n  if (0 != strcasecmp (\"POST\", method))\n    {\n      printf (\"METHOD: %s\\n\", method);\n      return MHD_NO;            /* unexpected method */\n    }\n  pp = *unused;\n  if (pp == NULL)\n    {\n      eok = 0;\n      pp = MHD_create_post_processor (connection, 1024, &post_iterator, &eok);\n      *unused = pp;\n    }\n  MHD_post_process (pp, upload_data, *upload_data_size);\n  if ((eok == 3) && (0 == *upload_data_size))\n    {\n      response = MHD_create_response_from_buffer (strlen (url),\n\t\t\t\t\t\t  (void *) url,\n\t\t\t\t\t\t  MHD_RESPMEM_MUST_COPY);\n      ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n      MHD_destroy_response (response);\n      MHD_destroy_post_processor (pp);\n      *unused = NULL;\n      return ret;\n    }\n  *upload_data_size = 0;\n  return MHD_YES;\n}",
      "lines": 42,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testInternalPost": {
      "start_point": [
        164,
        0
      ],
      "end_point": [
        235,
        1
      ],
      "content": "static int\ntestInternalPost ()\n{\n  struct MHD_Daemon *d;\n  CURL *c;\n  char buf[2048];\n  struct CBC cbc;\n  CURLcode errornum;\n  int port;\n\n  if (MHD_NO != MHD_is_feature_supported (MHD_FEATURE_AUTODETECT_BIND_PORT))\n    port = 0;\n  else\n    {\n      port = 1370;\n      if (oneone)\n        port += 10;\n    }\n\n  cbc.buf = buf;\n  cbc.size = 2048;\n  cbc.pos = 0;\n  d = MHD_start_daemon (MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_ERROR_LOG,\n                        port, NULL, NULL, &ahc_echo, NULL,\n\t\t\tMHD_OPTION_NOTIFY_COMPLETED, &completed_cb, NULL,\n\t\t\tMHD_OPTION_END);\n  if (d == NULL)\n    return 1;\n  if (0 == port)\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (d, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        { MHD_stop_daemon (d); return 32; }\n      port = (int)dinfo->port;\n    }\n  c = curl_easy_init ();\n  curl_easy_setopt (c, CURLOPT_URL, \"http://127.0.0.1/hello_world\");\n  curl_easy_setopt (c, CURLOPT_PORT, (long)port);\n  curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n  curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc);\n  curl_easy_setopt (c, CURLOPT_POSTFIELDS, POST_DATA);\n  curl_easy_setopt (c, CURLOPT_POSTFIELDSIZE, strlen (POST_DATA));\n  curl_easy_setopt (c, CURLOPT_POST, 1L);\n  curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n  curl_easy_setopt (c, CURLOPT_TIMEOUT, 150L);\n  if (oneone)\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n  else\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0);\n  curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT, 150L);\n  /* NOTE: use of CONNECTTIMEOUT without also\n   *   setting NOSIGNAL results in really weird\n   *   crashes on my system! */\n  curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n  if (CURLE_OK != (errornum = curl_easy_perform (c)))\n    {\n      fprintf (stderr,\n               \"curl_easy_perform failed: `%s'\\n\",\n               curl_easy_strerror (errornum));\n      curl_easy_cleanup (c);\n      MHD_stop_daemon (d);\n      return 2;\n    }\n  curl_easy_cleanup (c);\n  MHD_stop_daemon (d);\n  if (cbc.pos != strlen (\"/hello_world\"))\n    return 4;\n  if (0 != strncmp (\"/hello_world\", cbc.buf, strlen (\"/hello_world\")))\n    return 8;\n  return 0;\n}",
      "lines": 72,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testMultithreadedPost": {
      "start_point": [
        237,
        0
      ],
      "end_point": [
        308,
        1
      ],
      "content": "static int\ntestMultithreadedPost ()\n{\n  struct MHD_Daemon *d;\n  CURL *c;\n  char buf[2048];\n  struct CBC cbc;\n  CURLcode errornum;\n  int port;\n\n  if (MHD_NO != MHD_is_feature_supported (MHD_FEATURE_AUTODETECT_BIND_PORT))\n    port = 0;\n  else\n    {\n      port = 1371;\n      if (oneone)\n        port += 10;\n    }\n\n  cbc.buf = buf;\n  cbc.size = 2048;\n  cbc.pos = 0;\n  d = MHD_start_daemon (MHD_USE_THREAD_PER_CONNECTION | MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_ERROR_LOG,\n                        port, NULL, NULL, &ahc_echo, NULL,\n\t\t\tMHD_OPTION_NOTIFY_COMPLETED, &completed_cb, NULL,\n\t\t\tMHD_OPTION_END);\n  if (d == NULL)\n    return 16;\n  if (0 == port)\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (d, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        { MHD_stop_daemon (d); return 32; }\n      port = (int)dinfo->port;\n    }\n  c = curl_easy_init ();\n  curl_easy_setopt (c, CURLOPT_URL, \"http://127.0.0.1/hello_world\");\n  curl_easy_setopt (c, CURLOPT_PORT, (long)port);\n  curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n  curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc);\n  curl_easy_setopt (c, CURLOPT_POSTFIELDS, POST_DATA);\n  curl_easy_setopt (c, CURLOPT_POSTFIELDSIZE, strlen (POST_DATA));\n  curl_easy_setopt (c, CURLOPT_POST, 1L);\n  curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n  curl_easy_setopt (c, CURLOPT_TIMEOUT, 150L);\n  if (oneone)\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n  else\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0);\n  curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT, 150L);\n  /* NOTE: use of CONNECTTIMEOUT without also\n   *   setting NOSIGNAL results in really weird\n   *   crashes on my system! */\n  curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n  if (CURLE_OK != (errornum = curl_easy_perform (c)))\n    {\n      fprintf (stderr,\n               \"curl_easy_perform failed: `%s'\\n\",\n               curl_easy_strerror (errornum));\n      curl_easy_cleanup (c);\n      MHD_stop_daemon (d);\n      return 32;\n    }\n  curl_easy_cleanup (c);\n  MHD_stop_daemon (d);\n  if (cbc.pos != strlen (\"/hello_world\"))\n    return 64;\n  if (0 != strncmp (\"/hello_world\", cbc.buf, strlen (\"/hello_world\")))\n    return 128;\n  return 0;\n}",
      "lines": 72,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testMultithreadedPoolPost": {
      "start_point": [
        310,
        0
      ],
      "end_point": [
        382,
        1
      ],
      "content": "static int\ntestMultithreadedPoolPost ()\n{\n  struct MHD_Daemon *d;\n  CURL *c;\n  char buf[2048];\n  struct CBC cbc;\n  CURLcode errornum;\n  int port;\n\n  if (MHD_NO != MHD_is_feature_supported (MHD_FEATURE_AUTODETECT_BIND_PORT))\n    port = 0;\n  else\n    {\n      port = 1372;\n      if (oneone)\n        port += 10;\n    }\n\n  cbc.buf = buf;\n  cbc.size = 2048;\n  cbc.pos = 0;\n  d = MHD_start_daemon (MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_ERROR_LOG,\n                        port, NULL, NULL, &ahc_echo, NULL,\n                        MHD_OPTION_THREAD_POOL_SIZE, CPU_COUNT,\n\t\t\tMHD_OPTION_NOTIFY_COMPLETED, &completed_cb, NULL,\n\t\t\tMHD_OPTION_END);\n  if (d == NULL)\n    return 16;\n  if (0 == port)\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (d, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        { MHD_stop_daemon (d); return 32; }\n      port = (int)dinfo->port;\n    }\n  c = curl_easy_init ();\n  curl_easy_setopt (c, CURLOPT_URL, \"http://127.0.0.1/hello_world\");\n  curl_easy_setopt (c, CURLOPT_PORT, (long)port);\n  curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n  curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc);\n  curl_easy_setopt (c, CURLOPT_POSTFIELDS, POST_DATA);\n  curl_easy_setopt (c, CURLOPT_POSTFIELDSIZE, strlen (POST_DATA));\n  curl_easy_setopt (c, CURLOPT_POST, 1L);\n  curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n  curl_easy_setopt (c, CURLOPT_TIMEOUT, 150L);\n  if (oneone)\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n  else\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0);\n  curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT, 150L);\n  /* NOTE: use of CONNECTTIMEOUT without also\n   *   setting NOSIGNAL results in really weird\n   *   crashes on my system! */\n  curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n  if (CURLE_OK != (errornum = curl_easy_perform (c)))\n    {\n      fprintf (stderr,\n               \"curl_easy_perform failed: `%s'\\n\",\n               curl_easy_strerror (errornum));\n      curl_easy_cleanup (c);\n      MHD_stop_daemon (d);\n      return 32;\n    }\n  curl_easy_cleanup (c);\n  MHD_stop_daemon (d);\n  if (cbc.pos != strlen (\"/hello_world\"))\n    return 64;\n  if (0 != strncmp (\"/hello_world\", cbc.buf, strlen (\"/hello_world\")))\n    return 128;\n  return 0;\n}",
      "lines": 73,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testExternalPost": {
      "start_point": [
        384,
        0
      ],
      "end_point": [
        543,
        1
      ],
      "content": "static int\ntestExternalPost ()\n{\n  struct MHD_Daemon *d;\n  CURL *c;\n  char buf[2048];\n  struct CBC cbc;\n  CURLM *multi;\n  CURLMcode mret;\n  fd_set rs;\n  fd_set ws;\n  fd_set es;\n  MHD_socket maxsock;\n#ifdef MHD_WINSOCK_SOCKETS\n  int maxposixs; /* Max socket number unused on W32 */\n#else  /* MHD_POSIX_SOCKETS */\n#define maxposixs maxsock\n#endif /* MHD_POSIX_SOCKETS */\n  int running;\n  struct CURLMsg *msg;\n  time_t start;\n  struct timeval tv;\n  int port;\n\n  if (MHD_NO != MHD_is_feature_supported (MHD_FEATURE_AUTODETECT_BIND_PORT))\n    port = 0;\n  else\n    {\n      port = 1373;\n      if (oneone)\n        port += 10;\n    }\n\n  multi = NULL;\n  cbc.buf = buf;\n  cbc.size = 2048;\n  cbc.pos = 0;\n  d = MHD_start_daemon (MHD_USE_ERROR_LOG,\n                        port, NULL, NULL, &ahc_echo, NULL,\n\t\t\tMHD_OPTION_NOTIFY_COMPLETED, &completed_cb, NULL,\n\t\t\tMHD_OPTION_END);\n  if (d == NULL)\n    return 256;\n  if (0 == port)\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (d, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        { MHD_stop_daemon (d); return 32; }\n      port = (int)dinfo->port;\n    }\n  c = curl_easy_init ();\n  curl_easy_setopt (c, CURLOPT_URL, \"http://127.0.0.1/hello_world\");\n  curl_easy_setopt (c, CURLOPT_PORT, (long)port);\n  curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n  curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc);\n  curl_easy_setopt (c, CURLOPT_POSTFIELDS, POST_DATA);\n  curl_easy_setopt (c, CURLOPT_POSTFIELDSIZE, strlen (POST_DATA));\n  curl_easy_setopt (c, CURLOPT_POST, 1L);\n  curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n  curl_easy_setopt (c, CURLOPT_TIMEOUT, 150L);\n  if (oneone)\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n  else\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0);\n  curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT, 150L);\n  /* NOTE: use of CONNECTTIMEOUT without also\n   *   setting NOSIGNAL results in really weird\n   *   crashes on my system! */\n  curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n\n\n  multi = curl_multi_init ();\n  if (multi == NULL)\n    {\n      curl_easy_cleanup (c);\n      MHD_stop_daemon (d);\n      return 512;\n    }\n  mret = curl_multi_add_handle (multi, c);\n  if (mret != CURLM_OK)\n    {\n      curl_multi_cleanup (multi);\n      curl_easy_cleanup (c);\n      MHD_stop_daemon (d);\n      return 1024;\n    }\n  start = time (NULL);\n  while ((time (NULL) - start < 5) && (multi != NULL))\n    {\n      maxsock = MHD_INVALID_SOCKET;\n      maxposixs = -1;\n      FD_ZERO (&rs);\n      FD_ZERO (&ws);\n      FD_ZERO (&es);\n      curl_multi_perform (multi, &running);\n      mret = curl_multi_fdset (multi, &rs, &ws, &es, &maxposixs);\n      if (mret != CURLM_OK)\n        {\n          curl_multi_remove_handle (multi, c);\n          curl_multi_cleanup (multi);\n          curl_easy_cleanup (c);\n          MHD_stop_daemon (d);\n          return 2048;\n        }\n      if (MHD_YES != MHD_get_fdset (d, &rs, &ws, &es, &maxsock))\n        {\n          curl_multi_remove_handle (multi, c);\n          curl_multi_cleanup (multi);\n          curl_easy_cleanup (c);\n          MHD_stop_daemon (d);\n          return 4096;\n        }\n      tv.tv_sec = 0;\n      tv.tv_usec = 1000;\n      if (-1 == select (maxposixs + 1, &rs, &ws, &es, &tv))\n        {\n#ifdef MHD_POSIX_SOCKETS\n          if (EINTR != errno)\n            abort ();\n#else\n          if (WSAEINVAL != WSAGetLastError() || 0 != rs.fd_count || 0 != ws.fd_count || 0 != es.fd_count)\n            abort ();\n          Sleep (1000);\n#endif\n        }\n      curl_multi_perform (multi, &running);\n      if (running == 0)\n        {\n          msg = curl_multi_info_read (multi, &running);\n          if (msg == NULL)\n            break;\n          if (msg->msg == CURLMSG_DONE)\n            {\n              if (msg->data.result != CURLE_OK)\n                printf (\"%s failed at %s:%d: `%s'\\n\",\n                        \"curl_multi_perform\",\n                        __FILE__,\n                        __LINE__, curl_easy_strerror (msg->data.result));\n              curl_multi_remove_handle (multi, c);\n              curl_multi_cleanup (multi);\n              curl_easy_cleanup (c);\n              c = NULL;\n              multi = NULL;\n            }\n        }      MHD_run (d);\n    }\n  if (multi != NULL)\n    {\n      curl_multi_remove_handle (multi, c);\n      curl_easy_cleanup (c);\n      curl_multi_cleanup (multi);\n    }\n  MHD_stop_daemon (d);\n  if (cbc.pos != strlen (\"/hello_world\"))\n    return 8192;\n  if (0 != strncmp (\"/hello_world\", cbc.buf, strlen (\"/hello_world\")))\n    return 16384;\n  return 0;\n}",
      "lines": 160,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "ahc_cancel": {
      "start_point": [
        546,
        0
      ],
      "end_point": [
        585,
        1
      ],
      "content": "static int\nahc_cancel (void *cls,\n\t    struct MHD_Connection *connection,\n\t    const char *url,\n\t    const char *method,\n\t    const char *version,\n\t    const char *upload_data, size_t *upload_data_size,\n\t    void **unused)\n{\n  struct MHD_Response *response;\n  int ret;\n  (void)cls;(void)url;(void)version;            /* Unused. Silent compiler warning. */\n  (void)upload_data;(void)upload_data_size;     /* Unused. Silent compiler warning. */\n\n  if (0 != strcasecmp (\"POST\", method))\n    {\n      fprintf (stderr,\n\t       \"Unexpected method `%s'\\n\", method);\n      return MHD_NO;\n    }\n\n  if (*unused == NULL)\n    {\n      *unused = \"wibble\";\n      /* We don't want the body. Send a 500. */\n      response = MHD_create_response_from_buffer (0, NULL,\n\t\t\t\t\t\t  MHD_RESPMEM_PERSISTENT);\n      ret = MHD_queue_response(connection, 500, response);\n      if (ret != MHD_YES)\n\tfprintf(stderr, \"Failed to queue response\\n\");\n      MHD_destroy_response(response);\n      return ret;\n    }\n  else\n    {\n      fprintf(stderr,\n\t      \"In ahc_cancel again. This should not happen.\\n\");\n      return MHD_NO;\n    }\n}",
      "lines": 40,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "readBuffer": {
      "start_point": [
        595,
        0
      ],
      "end_point": [
        609,
        1
      ],
      "content": "static size_t\nreadBuffer(void *p, size_t size, size_t nmemb, void *opaque)\n{\n  struct CRBC *data = opaque;\n  size_t required = size * nmemb;\n  size_t left = data->size - data->pos;\n\n  if (required > left)\n    required = left;\n\n  memcpy(p, data->buffer + data->pos, required);\n  data->pos += required;\n\n  return required/size;\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "slowReadBuffer": {
      "start_point": [
        612,
        0
      ],
      "end_point": [
        617,
        1
      ],
      "content": "static size_t\nslowReadBuffer(void *p, size_t size, size_t nmemb, void *opaque)\n{\n  (void)sleep(1);\n  return readBuffer(p, size, nmemb, opaque);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "testMultithreadedPostCancelPart": {
      "start_point": [
        627,
        0
      ],
      "end_point": [
        752,
        1
      ],
      "content": "static int\ntestMultithreadedPostCancelPart(int flags)\n{\n  struct MHD_Daemon *d;\n  CURL *c;\n  char buf[2048];\n  struct CBC cbc;\n  CURLcode errornum;\n  struct curl_slist *headers = NULL;\n  long response_code;\n  CURLcode cc;\n  int result = 0;\n  struct CRBC crbc;\n  int port;\n\n  if (MHD_NO != MHD_is_feature_supported (MHD_FEATURE_AUTODETECT_BIND_PORT))\n    port = 0;\n  else\n    {\n      port = 1374;\n      if (oneone)\n        port += 10;\n    }\n\n  /* Don't test features that aren't available with HTTP/1.0 in\n   * HTTP/1.0 mode. */\n  if (!oneone && (flags & (FLAG_EXPECT_CONTINUE | FLAG_CHUNKED)))\n    return 0;\n\n  cbc.buf = buf;\n  cbc.size = 2048;\n  cbc.pos = 0;\n  d = MHD_start_daemon (MHD_USE_THREAD_PER_CONNECTION | MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_ERROR_LOG,\n                        port, NULL, NULL, &ahc_cancel, NULL,\n\t\t\tMHD_OPTION_END);\n  if (d == NULL)\n    return 32768;\n  if (0 == port)\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (d, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        { MHD_stop_daemon (d); return 32; }\n      port = (int)dinfo->port;\n    }\n\n  crbc.buffer = \"Test content\";\n  crbc.size = strlen(crbc.buffer);\n  crbc.pos = 0;\n\n  c = curl_easy_init ();\n  curl_easy_setopt (c, CURLOPT_URL, \"http://127.0.0.1/hello_world\");\n  curl_easy_setopt (c, CURLOPT_PORT, (long)port);\n  curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n  curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc);\n  curl_easy_setopt (c, CURLOPT_READFUNCTION, (flags & FLAG_SLOW_READ) ? &slowReadBuffer : &readBuffer);\n  curl_easy_setopt (c, CURLOPT_READDATA, &crbc);\n  curl_easy_setopt (c, CURLOPT_POSTFIELDS, NULL);\n  curl_easy_setopt (c, CURLOPT_POSTFIELDSIZE, crbc.size);\n  curl_easy_setopt (c, CURLOPT_POST, 1L);\n  curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n  curl_easy_setopt (c, CURLOPT_TIMEOUT, 150L);\n  if (oneone)\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n  else\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0);\n  curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT, 150L);\n  /* NOTE: use of CONNECTTIMEOUT without also\n   *   setting NOSIGNAL results in really weird\n   *   crashes on my system! */\n  curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n\n  if (flags & FLAG_CHUNKED)\n      headers = curl_slist_append(headers, \"Transfer-Encoding: chunked\");\n  if (!(flags & FLAG_FORM_DATA))\n  headers = curl_slist_append(headers, \"Content-Type: application/octet-stream\");\n  if (flags & FLAG_EXPECT_CONTINUE)\n      headers = curl_slist_append(headers, \"Expect: 100-Continue\");\n  curl_easy_setopt(c, CURLOPT_HTTPHEADER, headers);\n\n  if (CURLE_HTTP_RETURNED_ERROR != (errornum = curl_easy_perform (c)))\n    {\n#ifdef _WIN32\n      curl_version_info_data *curlverd = curl_version_info(CURLVERSION_NOW);\n      if (0 != (flags & FLAG_SLOW_READ) && CURLE_RECV_ERROR == errornum &&\n          (curlverd == NULL || curlverd->ares_num < 0x073100) )\n        { /* libcurl up to version 7.49.0 didn't have workaround for WinSock bug */\n          fprintf (stderr, \"Ignored curl_easy_perform expected failure on W32 with \\\"slow read\\\".\\n\");\n          result = 0;\n        }\n      else\n#else  /* ! _WIN32 */\n      if(1)\n#endif /* ! _WIN32 */\n        {\n          fprintf (stderr,\n                   \"flibbet curl_easy_perform didn't fail as expected: `%s' %d\\n\",\n                   curl_easy_strerror (errornum), errornum);\n          result = 65536;\n        }\n      curl_easy_cleanup (c);\n      MHD_stop_daemon (d);\n      curl_slist_free_all(headers);\n      return result;\n    }\n\n  if (CURLE_OK != (cc = curl_easy_getinfo(c, CURLINFO_RESPONSE_CODE, &response_code)))\n    {\n      fprintf(stderr, \"curl_easy_getinfo failed: '%s'\\n\", curl_easy_strerror(errornum));\n      result = 65536;\n    }\n\n  if (!result && (response_code != 500))\n    {\n      fprintf(stderr, \"Unexpected response code: %ld\\n\", response_code);\n      result = 131072;\n    }\n\n  if (!result && (cbc.pos != 0))\n    result = 262144;\n\n  curl_easy_cleanup (c);\n  MHD_stop_daemon (d);\n  curl_slist_free_all(headers);\n  return result;\n}",
      "lines": 126,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testMultithreadedPostCancel": {
      "start_point": [
        755,
        0
      ],
      "end_point": [
        763,
        1
      ],
      "content": "static int\ntestMultithreadedPostCancel()\n{\n  int result = 0;\n  int flags;\n  for(flags = 0; flags < FLAG_COUNT; ++flags)\n    result |= testMultithreadedPostCancelPart(flags);\n  return result;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        766,
        0
      ],
      "end_point": [
        785,
        1
      ],
      "content": "int\nmain (int argc, char *const *argv)\n{\n  unsigned int errorCount = 0;\n  (void)argc;   /* Unused. Silent compiler warning. */\n\n  oneone = (NULL != strrchr (argv[0], (int) '/')) ?\n    (NULL != strstr (strrchr (argv[0], (int) '/'), \"11\")) : 0;\n  if (0 != curl_global_init (CURL_GLOBAL_WIN32))\n    return 2;\n  errorCount += testMultithreadedPostCancel ();\n  errorCount += testInternalPost ();\n  errorCount += testMultithreadedPost ();\n  errorCount += testMultithreadedPoolPost ();\n  errorCount += testExternalPost ();\n  if (errorCount != 0)\n    fprintf (stderr, \"Error (code: %u)\\n\", errorCount);\n  curl_global_cleanup ();\n  return errorCount != 0;       /* 0 == pass */\n}",
      "lines": 20,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/testcurl/test_postform.c": {
    "completed_cb": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "static void\ncompleted_cb (void *cls,\n\t      struct MHD_Connection *connection,\n\t      void **con_cls,\n\t      enum MHD_RequestTerminationCode toe)\n{\n  struct MHD_PostProcessor *pp = *con_cls;\n  (void)cls;(void)connection;(void)toe;            /* Unused. Silent compiler warning. */\n\n  if (NULL != pp)\n    MHD_destroy_post_processor (pp);\n  *con_cls = NULL;\n}",
      "lines": 13,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "copyBuffer": {
      "start_point": [
        75,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "static size_t\ncopyBuffer (void *ptr, size_t size, size_t nmemb, void *ctx)\n{\n  struct CBC *cbc = ctx;\n\n  if (cbc->pos + size * nmemb > cbc->size)\n    return 0;                   /* overflow */\n  memcpy (&cbc->buf[cbc->pos], ptr, size * nmemb);\n  cbc->pos += size * nmemb;\n  return size * nmemb;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "post_iterator": {
      "start_point": [
        93,
        0
      ],
      "end_point": [
        116,
        1
      ],
      "content": "static int\npost_iterator (void *cls,\n               enum MHD_ValueKind kind,\n               const char *key,\n               const char *filename,\n               const char *content_type,\n               const char *transfer_encoding,\n               const char *value, uint64_t off, size_t size)\n{\n  int *eok = cls;\n  (void)kind;(void)filename;(void)content_type; /* Unused. Silent compiler warning. */\n  (void)transfer_encoding;(void)off;            /* Unused. Silent compiler warning. */\n\n#if 0\n  fprintf (stderr, \"PI sees %s-%.*s\\n\", key, size, value);\n#endif\n  if ((0 == strcmp (key, \"name\")) &&\n      (size == strlen (\"daniel\")) && (0 == strncmp (value, \"daniel\", size)))\n    (*eok) |= 1;\n  if ((0 == strcmp (key, \"project\")) &&\n      (size == strlen (\"curl\")) && (0 == strncmp (value, \"curl\", size)))\n    (*eok) |= 2;\n  return MHD_YES;\n}",
      "lines": 24,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "ahc_echo": {
      "start_point": [
        119,
        0
      ],
      "end_point": [
        162,
        1
      ],
      "content": "static int\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data, size_t *upload_data_size,\n          void **unused)\n{\n  static int eok;\n  struct MHD_Response *response;\n  struct MHD_PostProcessor *pp;\n  int ret;\n  (void)cls;(void)version;      /* Unused. Silent compiler warning. */\n\n  if (0 != strcmp (\"POST\", method))\n    {\n      printf (\"METHOD: %s\\n\", method);\n      return MHD_NO;            /* unexpected method */\n    }\n  pp = *unused;\n  if (pp == NULL)\n    {\n      eok = 0;\n      pp = MHD_create_post_processor (connection, 1024, &post_iterator, &eok);\n      if (pp == NULL)\n        abort ();\n      *unused = pp;\n    }\n  MHD_post_process (pp, upload_data, *upload_data_size);\n  if ((eok == 3) && (0 == *upload_data_size))\n    {\n      response = MHD_create_response_from_buffer (strlen (url),\n\t\t\t\t\t\t  (void *) url,\n\t\t\t\t\t\t  MHD_RESPMEM_MUST_COPY);\n      ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n      MHD_destroy_response (response);\n      MHD_destroy_post_processor (pp);\n      *unused = NULL;\n      return ret;\n    }\n  *upload_data_size = 0;\n  return MHD_YES;\n}",
      "lines": 44,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "make_form": {
      "start_point": [
        164,
        0
      ],
      "end_point": [
        175,
        1
      ],
      "content": "static struct curl_httppost *\nmake_form ()\n{\n  struct curl_httppost *post = NULL;\n  struct curl_httppost *last = NULL;\n\n  curl_formadd (&post, &last, CURLFORM_COPYNAME, \"name\",\n                CURLFORM_COPYCONTENTS, \"daniel\", CURLFORM_END);\n  curl_formadd (&post, &last, CURLFORM_COPYNAME, \"project\",\n                CURLFORM_COPYCONTENTS, \"curl\", CURLFORM_END);\n  return post;\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "struct curl_httppost",
        "struct",
        "curl_httppost",
        "*\nmake_form ()",
        "*"
      ]
    },
    "testInternalPost": {
      "start_point": [
        178,
        0
      ],
      "end_point": [
        251,
        1
      ],
      "content": "static int\ntestInternalPost ()\n{\n  struct MHD_Daemon *d;\n  CURL *c;\n  char buf[2048];\n  struct CBC cbc;\n  CURLcode errornum;\n  struct curl_httppost *pd;\n  int port;\n\n  if (MHD_NO != MHD_is_feature_supported (MHD_FEATURE_AUTODETECT_BIND_PORT))\n    port = 0;\n  else\n    {\n      port = 1390;\n      if (oneone)\n        port += 10;\n    }\n\n  cbc.buf = buf;\n  cbc.size = 2048;\n  cbc.pos = 0;\n  d = MHD_start_daemon (MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_ERROR_LOG,\n                        port, NULL, NULL, &ahc_echo, NULL,\n\t\t\tMHD_OPTION_NOTIFY_COMPLETED, &completed_cb, NULL,\n\t\t\tMHD_OPTION_END);\n  if (d == NULL)\n    return 1;\n  if (0 == port)\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (d, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        { MHD_stop_daemon (d); return 32; }\n      port = (int)dinfo->port;\n    }\n  c = curl_easy_init ();\n  curl_easy_setopt (c, CURLOPT_URL, \"http://127.0.0.1/hello_world\");\n  curl_easy_setopt (c, CURLOPT_PORT, (long)port);\n  curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n  curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc);\n  pd = make_form ();\n  curl_easy_setopt (c, CURLOPT_HTTPPOST, pd);\n  curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n  curl_easy_setopt (c, CURLOPT_TIMEOUT, 150L);\n  if (oneone)\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n  else\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0);\n  curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT, 150L);\n  /* NOTE: use of CONNECTTIMEOUT without also\n   *   setting NOSIGNAL results in really weird\n   *   crashes on my system! */\n  curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n  if (CURLE_OK != (errornum = curl_easy_perform (c)))\n    {\n      fprintf (stderr,\n               \"curl_easy_perform failed: `%s'\\n\",\n               curl_easy_strerror (errornum));\n      curl_easy_cleanup (c);\n      curl_formfree (pd);\n      MHD_stop_daemon (d);\n      return 2;\n    }\n  curl_easy_cleanup (c);\n  curl_formfree (pd);\n  MHD_stop_daemon (d);\n  if (cbc.pos != strlen (\"/hello_world\"))\n    return 4;\n  if (0 != strncmp (\"/hello_world\", cbc.buf, strlen (\"/hello_world\")))\n    return 8;\n  return 0;\n}",
      "lines": 74,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testMultithreadedPost": {
      "start_point": [
        253,
        0
      ],
      "end_point": [
        326,
        1
      ],
      "content": "static int\ntestMultithreadedPost ()\n{\n  struct MHD_Daemon *d;\n  CURL *c;\n  char buf[2048];\n  struct CBC cbc;\n  CURLcode errornum;\n  struct curl_httppost *pd;\n  int port;\n\n  if (MHD_NO != MHD_is_feature_supported (MHD_FEATURE_AUTODETECT_BIND_PORT))\n    port = 0;\n  else\n    {\n      port = 1390;\n      if (oneone)\n        port += 10;\n    }\n\n  cbc.buf = buf;\n  cbc.size = 2048;\n  cbc.pos = 0;\n  d = MHD_start_daemon (MHD_USE_THREAD_PER_CONNECTION | MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_ERROR_LOG,\n                        port, NULL, NULL, &ahc_echo, NULL,\n\t\t\tMHD_OPTION_NOTIFY_COMPLETED, &completed_cb, NULL,\n\t\t\tMHD_OPTION_END);\n  if (d == NULL)\n    return 16;\n  if (0 == port)\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (d, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        { MHD_stop_daemon (d); return 32; }\n      port = (int)dinfo->port;\n    }\n  c = curl_easy_init ();\n  curl_easy_setopt (c, CURLOPT_URL, \"http://127.0.0.1/hello_world\");\n  curl_easy_setopt (c, CURLOPT_PORT, (long)port);\n  curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n  curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc);\n  pd = make_form ();\n  curl_easy_setopt (c, CURLOPT_HTTPPOST, pd);\n  curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n  curl_easy_setopt (c, CURLOPT_TIMEOUT, 150L);\n  if (oneone)\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n  else\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0);\n  curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT, 5L);\n  /* NOTE: use of CONNECTTIMEOUT without also\n   *   setting NOSIGNAL results in really weird\n   *   crashes on my system! */\n  curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n  if (CURLE_OK != (errornum = curl_easy_perform (c)))\n    {\n      fprintf (stderr,\n               \"curl_easy_perform failed: `%s'\\n\",\n               curl_easy_strerror (errornum));\n      curl_easy_cleanup (c);\n      curl_formfree (pd);\n      MHD_stop_daemon (d);\n      return 32;\n    }\n  curl_easy_cleanup (c);\n  curl_formfree (pd);\n  MHD_stop_daemon (d);\n  if (cbc.pos != strlen (\"/hello_world\"))\n    return 64;\n  if (0 != strncmp (\"/hello_world\", cbc.buf, strlen (\"/hello_world\")))\n    return 128;\n  return 0;\n}",
      "lines": 74,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testMultithreadedPoolPost": {
      "start_point": [
        328,
        0
      ],
      "end_point": [
        402,
        1
      ],
      "content": "static int\ntestMultithreadedPoolPost ()\n{\n  struct MHD_Daemon *d;\n  CURL *c;\n  char buf[2048];\n  struct CBC cbc;\n  CURLcode errornum;\n  struct curl_httppost *pd;\n  int port;\n\n  if (MHD_NO != MHD_is_feature_supported (MHD_FEATURE_AUTODETECT_BIND_PORT))\n    port = 0;\n  else\n    {\n      port = 1391;\n      if (oneone)\n        port += 10;\n    }\n\n  cbc.buf = buf;\n  cbc.size = 2048;\n  cbc.pos = 0;\n  d = MHD_start_daemon (MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_ERROR_LOG,\n                        port, NULL, NULL, &ahc_echo, NULL,\n                        MHD_OPTION_THREAD_POOL_SIZE, CPU_COUNT,\n\t\t\tMHD_OPTION_NOTIFY_COMPLETED, &completed_cb, NULL,\n\t\t\tMHD_OPTION_END);\n  if (d == NULL)\n    return 16;\n  if (0 == port)\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (d, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        { MHD_stop_daemon (d); return 32; }\n      port = (int)dinfo->port;\n    }\n  c = curl_easy_init ();\n  curl_easy_setopt (c, CURLOPT_URL, \"http://127.0.0.1/hello_world\");\n  curl_easy_setopt (c, CURLOPT_PORT, (long)port);\n  curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n  curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc);\n  pd = make_form ();\n  curl_easy_setopt (c, CURLOPT_HTTPPOST, pd);\n  curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n  curl_easy_setopt (c, CURLOPT_TIMEOUT, 150L);\n  if (oneone)\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n  else\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0);\n  curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT, 5L);\n  /* NOTE: use of CONNECTTIMEOUT without also\n   *   setting NOSIGNAL results in really weird\n   *   crashes on my system! */\n  curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n  if (CURLE_OK != (errornum = curl_easy_perform (c)))\n    {\n      fprintf (stderr,\n               \"curl_easy_perform failed: `%s'\\n\",\n               curl_easy_strerror (errornum));\n      curl_easy_cleanup (c);\n      curl_formfree (pd);\n      MHD_stop_daemon (d);\n      return 32;\n    }\n  curl_easy_cleanup (c);\n  curl_formfree (pd);\n  MHD_stop_daemon (d);\n  if (cbc.pos != strlen (\"/hello_world\"))\n    return 64;\n  if (0 != strncmp (\"/hello_world\", cbc.buf, strlen (\"/hello_world\")))\n    return 128;\n  return 0;\n}",
      "lines": 75,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testExternalPost": {
      "start_point": [
        404,
        0
      ],
      "end_point": [
        570,
        1
      ],
      "content": "static int\ntestExternalPost ()\n{\n  struct MHD_Daemon *d;\n  CURL *c;\n  char buf[2048];\n  struct CBC cbc;\n  CURLM *multi;\n  CURLMcode mret;\n  fd_set rs;\n  fd_set ws;\n  fd_set es;\n  MHD_socket maxsock;\n#ifdef MHD_WINSOCK_SOCKETS\n  int maxposixs; /* Max socket number unused on W32 */\n#else  /* MHD_POSIX_SOCKETS */\n#define maxposixs maxsock\n#endif /* MHD_POSIX_SOCKETS */\n  int running;\n  struct CURLMsg *msg;\n  time_t start;\n  struct timeval tv;\n  struct curl_httppost *pd;\n  int port;\n\n  if (MHD_NO != MHD_is_feature_supported (MHD_FEATURE_AUTODETECT_BIND_PORT))\n    port = 0;\n  else\n    {\n      port = 1392;\n      if (oneone)\n        port += 10;\n    }\n\n  multi = NULL;\n  cbc.buf = buf;\n  cbc.size = 2048;\n  cbc.pos = 0;\n  d = MHD_start_daemon (MHD_USE_ERROR_LOG,\n                        port, NULL, NULL, &ahc_echo, NULL,\n\t\t\tMHD_OPTION_NOTIFY_COMPLETED, &completed_cb, NULL,\n\t\t\tMHD_OPTION_END);\n  if (d == NULL)\n    return 256;\n  if (0 == port)\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (d, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        { MHD_stop_daemon (d); return 32; }\n      port = (int)dinfo->port;\n    }\n  c = curl_easy_init ();\n  curl_easy_setopt (c, CURLOPT_URL, \"http://127.0.0.1/hello_world\");\n  curl_easy_setopt (c, CURLOPT_PORT, (long)port);\n  curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n  curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc);\n  pd = make_form ();\n  curl_easy_setopt (c, CURLOPT_HTTPPOST, pd);\n  curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n  curl_easy_setopt (c, CURLOPT_TIMEOUT, 150L);\n  if (oneone)\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n  else\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0);\n  curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT, 150L);\n  /* NOTE: use of CONNECTTIMEOUT without also\n   *   setting NOSIGNAL results in really weird\n   *   crashes on my system! */\n  curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n\n\n  multi = curl_multi_init ();\n  if (multi == NULL)\n    {\n      curl_easy_cleanup (c);\n      curl_formfree (pd);\n      MHD_stop_daemon (d);\n      return 512;\n    }\n  mret = curl_multi_add_handle (multi, c);\n  if (mret != CURLM_OK)\n    {\n      curl_multi_cleanup (multi);\n      curl_formfree (pd);\n      curl_easy_cleanup (c);\n      MHD_stop_daemon (d);\n      return 1024;\n    }\n  start = time (NULL);\n  while ((time (NULL) - start < 5) && (multi != NULL))\n    {\n      maxsock = MHD_INVALID_SOCKET;\n      maxposixs = -1;\n      FD_ZERO (&rs);\n      FD_ZERO (&ws);\n      FD_ZERO (&es);\n      curl_multi_perform (multi, &running);\n      mret = curl_multi_fdset (multi, &rs, &ws, &es, &maxposixs);\n      if (mret != CURLM_OK)\n        {\n          curl_multi_remove_handle (multi, c);\n          curl_multi_cleanup (multi);\n          curl_easy_cleanup (c);\n          MHD_stop_daemon (d);\n          curl_formfree (pd);\n          return 2048;\n        }\n      if (MHD_YES != MHD_get_fdset (d, &rs, &ws, &es, &maxsock))\n        {\n          curl_multi_remove_handle (multi, c);\n          curl_multi_cleanup (multi);\n          curl_easy_cleanup (c);\n          curl_formfree (pd);\n          MHD_stop_daemon (d);\n          return 4096;\n        }\n      tv.tv_sec = 0;\n      tv.tv_usec = 1000;\n      if (-1 == select (maxposixs + 1, &rs, &ws, &es, &tv))\n        {\n#ifdef MHD_POSIX_SOCKETS\n          if (EINTR != errno)\n            abort ();\n#else\n          if (WSAEINVAL != WSAGetLastError() || 0 != rs.fd_count || 0 != ws.fd_count || 0 != es.fd_count)\n            abort ();\n          Sleep (1000);\n#endif\n        }\n      curl_multi_perform (multi, &running);\n      if (running == 0)\n        {\n          msg = curl_multi_info_read (multi, &running);\n          if (msg == NULL)\n            break;\n          if (msg->msg == CURLMSG_DONE)\n            {\n              if (msg->data.result != CURLE_OK)\n                printf (\"%s failed at %s:%d: `%s'\\n\",\n                        \"curl_multi_perform\",\n                        __FILE__,\n                        __LINE__,\n                        curl_easy_strerror (msg->data.result));\n              curl_multi_remove_handle (multi, c);\n              curl_multi_cleanup (multi);\n              curl_easy_cleanup (c);\n              c = NULL;\n              multi = NULL;\n            }\n        }\n      MHD_run (d);\n    }\n  if (multi != NULL)\n    {\n      curl_multi_remove_handle (multi, c);\n      curl_easy_cleanup (c);\n      curl_multi_cleanup (multi);\n    }\n  curl_formfree (pd);\n  MHD_stop_daemon (d);\n  if (cbc.pos != strlen (\"/hello_world\"))\n    return 8192;\n  if (0 != strncmp (\"/hello_world\", cbc.buf, strlen (\"/hello_world\")))\n    return 16384;\n  return 0;\n}",
      "lines": 167,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        573,
        0
      ],
      "end_point": [
        599,
        1
      ],
      "content": "int\nmain (int argc, char *const *argv)\n{\n  unsigned int errorCount = 0;\n  (void)argc;   /* Unused. Silent compiler warning. */\n\n#ifdef MHD_HTTPS_REQUIRE_GRYPT\n#ifdef HAVE_GCRYPT_H\n  gcry_control (GCRYCTL_ENABLE_QUICK_RANDOM, 0);\n#ifdef GCRYCTL_INITIALIZATION_FINISHED\n  gcry_control (GCRYCTL_INITIALIZATION_FINISHED, 0);\n#endif\n#endif\n#endif /* MHD_HTTPS_REQUIRE_GRYPT */\n  oneone = (NULL != strrchr (argv[0], (int) '/')) ?\n    (NULL != strstr (strrchr (argv[0], (int) '/'), \"11\")) : 0;\n  if (0 != curl_global_init (CURL_GLOBAL_WIN32))\n    return 2;\n  errorCount += testInternalPost ();\n  errorCount += testMultithreadedPost ();\n  errorCount += testMultithreadedPoolPost ();\n  errorCount += testExternalPost ();\n  if (errorCount != 0)\n    fprintf (stderr, \"Error (code: %u)\\n\", errorCount);\n  curl_global_cleanup ();\n  return errorCount != 0;       /* 0 == pass */\n}",
      "lines": 27,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/testcurl/test_post_loop.c": {
    "copyBuffer": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        69,
        1
      ],
      "content": "static size_t\ncopyBuffer (void *ptr, size_t size, size_t nmemb, void *ctx)\n{\n  struct CBC *cbc = ctx;\n\n  if (cbc->pos + size * nmemb > cbc->size)\n    return 0;                   /* overflow */\n  memcpy (&cbc->buf[cbc->pos], ptr, size * nmemb);\n  cbc->pos += size * nmemb;\n  return size * nmemb;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "ahc_echo": {
      "start_point": [
        71,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "static int\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data, size_t *upload_data_size,\n          void **mptr)\n{\n  static int marker;\n  struct MHD_Response *response;\n  int ret;\n  (void)cls;(void)url;(void)version;            /* Unused. Silent compiler warning. */\n  (void)upload_data;(void)upload_data_size;     /* Unused. Silent compiler warning. */\n\n  if (0 != strcmp (\"POST\", method))\n    {\n      printf (\"METHOD: %s\\n\", method);\n      return MHD_NO;            /* unexpected method */\n    }\n  if ((*mptr != NULL) && (0 == *upload_data_size))\n    {\n      if (*mptr != &marker)\n        abort ();\n      response = MHD_create_response_from_buffer (2, \"OK\", \n\t\t\t\t\t\t  MHD_RESPMEM_PERSISTENT);\n      ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n      MHD_destroy_response (response);\n      *mptr = NULL;\n      return ret;\n    }\n  if (strlen (POST_DATA) != *upload_data_size)\n    return MHD_YES;\n  *upload_data_size = 0;\n  *mptr = &marker;\n  return MHD_YES;\n}",
      "lines": 37,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testInternalPost": {
      "start_point": [
        110,
        0
      ],
      "end_point": [
        190,
        1
      ],
      "content": "static int\ntestInternalPost ()\n{\n  struct MHD_Daemon *d;\n  CURL *c;\n  char buf[2048];\n  struct CBC cbc;\n  CURLcode errornum;\n  int i;\n  char url[1024];\n  int port;\n\n  if (MHD_NO != MHD_is_feature_supported (MHD_FEATURE_AUTODETECT_BIND_PORT))\n    port = 0;\n  else\n    {\n      port = 1350;\n      if (oneone)\n        port += 10;\n    }\n\n  cbc.buf = buf;\n  cbc.size = 2048;\n  d = MHD_start_daemon (MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_ERROR_LOG,\n                        port, NULL, NULL, &ahc_echo, NULL, MHD_OPTION_END);\n  if (d == NULL)\n    return 1;\n  if (0 == port)\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (d, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        { MHD_stop_daemon (d); return 32; }\n      port = (int)dinfo->port;\n    }\n  for (i = 0; i < LOOPCOUNT; i++)\n    {\n      if (99 == i % 100)\n        fprintf (stderr, \".\");\n      c = curl_easy_init ();\n      cbc.pos = 0;\n      buf[0] = '\\0';\n      sprintf (url, \"http://127.0.0.1:%d/hw%d\", port, i);\n      curl_easy_setopt (c, CURLOPT_URL, url);\n      curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n      curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc);\n      curl_easy_setopt (c, CURLOPT_POSTFIELDS, POST_DATA);\n      curl_easy_setopt (c, CURLOPT_POSTFIELDSIZE, strlen (POST_DATA));\n      curl_easy_setopt (c, CURLOPT_POST, 1L);\n      curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n      curl_easy_setopt (c, CURLOPT_TIMEOUT, 150L);\n      if (oneone)\n        curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n      else\n        curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0);\n      curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT, 150L);\n      /* NOTE: use of CONNECTTIMEOUT without also\n       *   setting NOSIGNAL results in really weird\n       *   crashes on my system! */\n      curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n      if (CURLE_OK != (errornum = curl_easy_perform (c)))\n        {\n          fprintf (stderr,\n                   \"curl_easy_perform failed: `%s'\\n\",\n                   curl_easy_strerror (errornum));\n          curl_easy_cleanup (c);\n          MHD_stop_daemon (d);\n          return 2;\n        }\n      curl_easy_cleanup (c);\n      if ((buf[0] != 'O') || (buf[1] != 'K'))\n        {\n          MHD_stop_daemon (d);\n          return 4;\n        }\n    }\n  MHD_stop_daemon (d);\n  if (LOOPCOUNT >= 99)\n    fprintf (stderr, \"\\n\");\n  return 0;\n}",
      "lines": 81,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testMultithreadedPost": {
      "start_point": [
        192,
        0
      ],
      "end_point": [
        272,
        1
      ],
      "content": "static int\ntestMultithreadedPost ()\n{\n  struct MHD_Daemon *d;\n  CURL *c;\n  char buf[2048];\n  struct CBC cbc;\n  CURLcode errornum;\n  int i;\n  char url[1024];\n  int port;\n\n  if (MHD_NO != MHD_is_feature_supported (MHD_FEATURE_AUTODETECT_BIND_PORT))\n    port = 0;\n  else\n    {\n      port = 1351;\n      if (oneone)\n        port += 10;\n    }\n\n  cbc.buf = buf;\n  cbc.size = 2048;\n  d = MHD_start_daemon (MHD_USE_THREAD_PER_CONNECTION | MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_ERROR_LOG,\n                        port, NULL, NULL, &ahc_echo, NULL, MHD_OPTION_END);\n  if (d == NULL)\n    return 16;\n  if (0 == port)\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (d, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        { MHD_stop_daemon (d); return 32; }\n      port = (int)dinfo->port;\n    }\n  for (i = 0; i < LOOPCOUNT; i++)\n    {\n      if (99 == i % 100)\n        fprintf (stderr, \".\");\n      c = curl_easy_init ();\n      cbc.pos = 0;\n      buf[0] = '\\0';\n      sprintf (url, \"http://127.0.0.1:%d/hw%d\", port, i);\n      curl_easy_setopt (c, CURLOPT_URL, url);\n      curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n      curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc);\n      curl_easy_setopt (c, CURLOPT_POSTFIELDS, POST_DATA);\n      curl_easy_setopt (c, CURLOPT_POSTFIELDSIZE, strlen (POST_DATA));\n      curl_easy_setopt (c, CURLOPT_POST, 1L);\n      curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n      curl_easy_setopt (c, CURLOPT_TIMEOUT, 150L);\n      if (oneone)\n        curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n      else\n        curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0);\n      curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT, 150L);\n      /* NOTE: use of CONNECTTIMEOUT without also\n       *   setting NOSIGNAL results in really weird\n       *   crashes on my system! */\n      curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n      if (CURLE_OK != (errornum = curl_easy_perform (c)))\n        {\n          fprintf (stderr,\n                   \"curl_easy_perform failed: `%s'\\n\",\n                   curl_easy_strerror (errornum));\n          curl_easy_cleanup (c);\n          MHD_stop_daemon (d);\n          return 32;\n        }\n      curl_easy_cleanup (c);\n      if ((buf[0] != 'O') || (buf[1] != 'K'))\n        {\n          MHD_stop_daemon (d);\n          return 64;\n        }\n    }\n  MHD_stop_daemon (d);\n  if (LOOPCOUNT >= 99)\n    fprintf (stderr, \"\\n\");\n  return 0;\n}",
      "lines": 81,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testMultithreadedPoolPost": {
      "start_point": [
        274,
        0
      ],
      "end_point": [
        355,
        1
      ],
      "content": "static int\ntestMultithreadedPoolPost ()\n{\n  struct MHD_Daemon *d;\n  CURL *c;\n  char buf[2048];\n  struct CBC cbc;\n  CURLcode errornum;\n  int i;\n  char url[1024];\n  int port;\n\n  if (MHD_NO != MHD_is_feature_supported (MHD_FEATURE_AUTODETECT_BIND_PORT))\n    port = 0;\n  else\n    {\n      port = 1352;\n      if (oneone)\n        port += 10;\n    }\n\n  cbc.buf = buf;\n  cbc.size = 2048;\n  d = MHD_start_daemon (MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_ERROR_LOG,\n                        port, NULL, NULL, &ahc_echo, NULL,\n                        MHD_OPTION_THREAD_POOL_SIZE, CPU_COUNT, MHD_OPTION_END);\n  if (d == NULL)\n    return 16;\n  if (0 == port)\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (d, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        { MHD_stop_daemon (d); return 32; }\n      port = (int)dinfo->port;\n    }\n  for (i = 0; i < LOOPCOUNT; i++)\n    {\n      if (99 == i % 100)\n        fprintf (stderr, \".\");\n      c = curl_easy_init ();\n      cbc.pos = 0;\n      buf[0] = '\\0';\n      sprintf (url, \"http://127.0.0.1:%d/hw%d\", port, i);\n      curl_easy_setopt (c, CURLOPT_URL, url);\n      curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n      curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc);\n      curl_easy_setopt (c, CURLOPT_POSTFIELDS, POST_DATA);\n      curl_easy_setopt (c, CURLOPT_POSTFIELDSIZE, strlen (POST_DATA));\n      curl_easy_setopt (c, CURLOPT_POST, 1L);\n      curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n      curl_easy_setopt (c, CURLOPT_TIMEOUT, 150L);\n      if (oneone)\n        curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n      else\n        curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0);\n      curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT, 150L);\n      /* NOTE: use of CONNECTTIMEOUT without also\n       *   setting NOSIGNAL results in really weird\n       *   crashes on my system! */\n      curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n      if (CURLE_OK != (errornum = curl_easy_perform (c)))\n        {\n          fprintf (stderr,\n                   \"curl_easy_perform failed: `%s'\\n\",\n                   curl_easy_strerror (errornum));\n          curl_easy_cleanup (c);\n          MHD_stop_daemon (d);\n          return 32;\n        }\n      curl_easy_cleanup (c);\n      if ((buf[0] != 'O') || (buf[1] != 'K'))\n        {\n          MHD_stop_daemon (d);\n          return 64;\n        }\n    }\n  MHD_stop_daemon (d);\n  if (LOOPCOUNT >= 99)\n    fprintf (stderr, \"\\n\");\n  return 0;\n}",
      "lines": 82,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testExternalPost": {
      "start_point": [
        357,
        0
      ],
      "end_point": [
        532,
        1
      ],
      "content": "static int\ntestExternalPost ()\n{\n  struct MHD_Daemon *d;\n  CURL *c;\n  char buf[2048];\n  struct CBC cbc;\n  CURLM *multi;\n  CURLMcode mret;\n  fd_set rs;\n  fd_set ws;\n  fd_set es;\n  MHD_socket maxsock;\n#ifdef MHD_WINSOCK_SOCKETS\n  int maxposixs; /* Max socket number unused on W32 */\n#else  /* MHD_POSIX_SOCKETS */\n#define maxposixs maxsock\n#endif /* MHD_POSIX_SOCKETS */\n  int running;\n  struct CURLMsg *msg;\n  time_t start;\n  struct timeval tv;\n  int i;\n  unsigned long long timeout;\n  long ctimeout;\n  char url[1024];\n  int port;\n\n  if (MHD_NO != MHD_is_feature_supported (MHD_FEATURE_AUTODETECT_BIND_PORT))\n    port = 0;\n  else\n    {\n      port = 1353;\n      if (oneone)\n        port += 10;\n    }\n\n  multi = NULL;\n  cbc.buf = buf;\n  cbc.size = 2048;\n  cbc.pos = 0;\n  d = MHD_start_daemon (MHD_USE_ERROR_LOG,\n                        port, NULL, NULL, &ahc_echo, NULL, MHD_OPTION_END);\n  if (d == NULL)\n    return 256;\n  if (0 == port)\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (d, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        { MHD_stop_daemon (d); return 32; }\n      port = (int)dinfo->port;\n    }\n  multi = curl_multi_init ();\n  if (multi == NULL)\n    {\n      MHD_stop_daemon (d);\n      return 512;\n    }\n  for (i = 0; i < LOOPCOUNT; i++)\n    {\n      if (99 == i % 100)\n\tfprintf (stderr, \".\");\n      c = curl_easy_init ();\n      cbc.pos = 0;\n      buf[0] = '\\0';\n      sprintf (url, \"http://127.0.0.1:%d/hw%d\", port, i);\n      curl_easy_setopt (c, CURLOPT_URL, url);\n      curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n      curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc);\n      curl_easy_setopt (c, CURLOPT_POSTFIELDS, POST_DATA);\n      curl_easy_setopt (c, CURLOPT_POSTFIELDSIZE, strlen (POST_DATA));\n      curl_easy_setopt (c, CURLOPT_POST, 1L);\n      curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n      curl_easy_setopt (c, CURLOPT_TIMEOUT, 150L);\n      if (oneone)\n        curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n      else\n        curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0);\n      curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT, 150L);\n      /* NOTE: use of CONNECTTIMEOUT without also\n       *   setting NOSIGNAL results in really weird\n       *   crashes on my system! */\n      curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n      mret = curl_multi_add_handle (multi, c);\n      if (mret != CURLM_OK)\n        {\n          curl_multi_cleanup (multi);\n          curl_easy_cleanup (c);\n          MHD_stop_daemon (d);\n          return 1024;\n        }\n      start = time (NULL);\n      while ((time (NULL) - start < 5) && (multi != NULL))\n        {\n          maxsock = MHD_INVALID_SOCKET;\n          maxposixs = -1;\n          FD_ZERO (&rs);\n          FD_ZERO (&ws);\n          FD_ZERO (&es);\n          while (CURLM_CALL_MULTI_PERFORM ==\n                 curl_multi_perform (multi, &running));\n          mret = curl_multi_fdset (multi, &rs, &ws, &es, &maxposixs);\n          if (mret != CURLM_OK)\n            {\n              curl_multi_remove_handle (multi, c);\n              curl_multi_cleanup (multi);\n              curl_easy_cleanup (c);\n              MHD_stop_daemon (d);\n              return 2048;\n            }\n          if (MHD_YES != MHD_get_fdset (d, &rs, &ws, &es, &maxsock))\n            {\n              curl_multi_remove_handle (multi, c);\n              curl_multi_cleanup (multi);\n              curl_easy_cleanup (c);\n              MHD_stop_daemon (d);\n              return 4096;\n            }\n          if (MHD_NO == MHD_get_timeout (d, &timeout))\n            timeout = 100;      /* 100ms == INFTY -- CURL bug... */\n          if ((CURLM_OK == curl_multi_timeout (multi, &ctimeout)) &&\n              (ctimeout < (long long)timeout) && (ctimeout >= 0))\n            timeout = ctimeout;\n\t  if ( (c == NULL) || (running == 0) )\n\t    timeout = 0; /* terminate quickly... */\n          tv.tv_sec = timeout / 1000;\n          tv.tv_usec = (timeout % 1000) * 1000;\n          if (-1 == select (maxposixs + 1, &rs, &ws, &es, &tv))\n\t    {\n\t      if (EINTR == errno)\n\t\tcontinue;\n\t      fprintf (stderr,\n\t\t       \"select failed: %s\\n\",\n\t\t       strerror (errno));\n\t      break;\t      \n\t    }\n          while (CURLM_CALL_MULTI_PERFORM ==\n                 curl_multi_perform (multi, &running));\n          if (running == 0)\n            {\n              msg = curl_multi_info_read (multi, &running);\n              if (msg == NULL)\n                break;\n              if (msg->msg == CURLMSG_DONE)\n                {\n                  if (msg->data.result != CURLE_OK)\n                    printf (\"%s failed at %s:%d: `%s'\\n\",\n                            \"curl_multi_perform\",\n                            __FILE__,\n                            __LINE__, curl_easy_strerror (msg->data.result));\n                  curl_multi_remove_handle (multi, c);\n                  curl_easy_cleanup (c);\n                  c = NULL;\n                }\n            }\n          MHD_run (d);\n        }\n      if (c != NULL)\n        {\n          curl_multi_remove_handle (multi, c);\n          curl_easy_cleanup (c);\n        }\n      if ((buf[0] != 'O') || (buf[1] != 'K'))\n        {\n          curl_multi_cleanup (multi);\n          MHD_stop_daemon (d);\n          return 8192;\n        }\n    }\n  curl_multi_cleanup (multi);\n  MHD_stop_daemon (d);\n  if (LOOPCOUNT >= 99)\n    fprintf (stderr, \"\\n\");\n  return 0;\n}",
      "lines": 176,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "now": {
      "start_point": [
        546,
        0
      ],
      "end_point": [
        554,
        1
      ],
      "content": "static unsigned long long \nnow ()\n{\n  struct timeval tv;\n\n  gettimeofday (&tv, NULL);\n  return (((unsigned long long) tv.tv_sec * 1000LL) +\n\t  ((unsigned long long) tv.tv_usec / 1000LL));\n}",
      "lines": 9,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "unsigned long long",
        "unsigned",
        "long",
        "long"
      ]
    },
    "main": {
      "start_point": [
        557,
        0
      ],
      "end_point": [
        611,
        1
      ],
      "content": "int\nmain (int argc, char *const *argv)\n{\n  unsigned int errorCount = 0;\n  (void)argc;   /* Unused. Silent compiler warning. */\n\n  oneone = (NULL != strrchr (argv[0], (int) '/')) ?\n    (NULL != strstr (strrchr (argv[0], (int) '/'), \"11\")) : 0;\n  if (0 != curl_global_init (CURL_GLOBAL_WIN32))\n    return 2;\n  start_time = now();\n  errorCount += testInternalPost ();\n  fprintf (stderr,\n\t   oneone ? \"%s: Sequential POSTs (http/1.1) %f/s\\n\" : \"%s: Sequential POSTs (http/1.0) %f/s\\n\",\n\t   \"internal select\",\n\t   (double) 1000 * LOOPCOUNT / (now() - start_time + 1.0));\n  GAUGER (\"internal select\",\n\t  oneone ? \"Sequential POSTs (http/1.1)\" : \"Sequential POSTs (http/1.0)\",\n\t  (double) 1000 * LOOPCOUNT / (now() - start_time + 1.0),\n\t  \"requests/s\");\n  start_time = now();\n  errorCount += testMultithreadedPost ();\n  fprintf (stderr,\n\t   oneone ? \"%s: Sequential POSTs (http/1.1) %f/s\\n\" : \"%s: Sequential POSTs (http/1.0) %f/s\\n\",\n\t   \"multithreaded post\",\n\t   (double) 1000 * LOOPCOUNT / (now() - start_time + 1.0));\n  GAUGER (\"Multithreaded select\",\n\t  oneone ? \"Sequential POSTs (http/1.1)\" : \"Sequential POSTs (http/1.0)\",\n\t  (double) 1000 * LOOPCOUNT / (now() - start_time + 1.0),\n\t  \"requests/s\");\n  start_time = now();\n  errorCount += testMultithreadedPoolPost ();\n  fprintf (stderr,\n\t   oneone ? \"%s: Sequential POSTs (http/1.1) %f/s\\n\" : \"%s: Sequential POSTs (http/1.0) %f/s\\n\",\n\t   \"thread with pool\",\n\t   (double) 1000 * LOOPCOUNT / (now() - start_time + 1.0));\n  GAUGER (\"thread with pool\",\n\t  oneone ? \"Sequential POSTs (http/1.1)\" : \"Sequential POSTs (http/1.0)\",\n\t  (double) 1000 * LOOPCOUNT / (now() - start_time + 1.0),\n\t  \"requests/s\");\n  start_time = now();\n  errorCount += testExternalPost ();\n  fprintf (stderr,\n\t   oneone ? \"%s: Sequential POSTs (http/1.1) %f/s\\n\" : \"%s: Sequential POSTs (http/1.0) %f/s\\n\",\n\t   \"external select\",\n\t   (double) 1000 * LOOPCOUNT / (now() - start_time + 1.0));\n  GAUGER (\"external select\",\n\t  oneone ? \"Sequential POSTs (http/1.1)\" : \"Sequential POSTs (http/1.0)\",\n\t  (double) 1000 * LOOPCOUNT / (now() - start_time + 1.0),\n\t  \"requests/s\");\n  if (errorCount != 0)\n    fprintf (stderr, \"Error (code: %u)\\n\", errorCount);\n  curl_global_cleanup ();\n  return errorCount != 0;       /* 0 == pass */\n}",
      "lines": 55,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/testcurl/test_process_arguments.c": {
    "copyBuffer": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "static size_t\ncopyBuffer (void *ptr, size_t size, size_t nmemb, void *ctx)\n{\n  struct CBC *cbc = ctx;\n\n  if (cbc->pos + size * nmemb > cbc->size)\n    return 0;                   /* overflow */\n  memcpy (&cbc->buf[cbc->pos], ptr, size * nmemb);\n  cbc->pos += size * nmemb;\n  return size * nmemb;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "ahc_echo": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        108,
        1
      ],
      "content": "static int\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data, size_t *upload_data_size,\n          void **unused)\n{\n  static int ptr;\n  const char *me = cls;\n  struct MHD_Response *response;\n  int ret;\n  const char *hdr;\n  (void)version;(void)upload_data;(void)upload_data_size;       /* Unused. Silent compiler warning. */\n\n  if (0 != strcmp (me, method))\n    return MHD_NO;              /* unexpected method */\n  if (&ptr != *unused)\n    {\n      *unused = &ptr;\n      return MHD_YES;\n    }\n  *unused = NULL;\n  hdr = MHD_lookup_connection_value (connection, MHD_GET_ARGUMENT_KIND, \"k\");\n  if ((hdr == NULL) || (0 != strcmp (hdr, \"v x\")))\n    abort ();\n  hdr = MHD_lookup_connection_value (connection,\n                                     MHD_GET_ARGUMENT_KIND, \"hash\");\n  if ((hdr == NULL) || (0 != strcmp (hdr, \"#foo\")))\n    abort ();\n  hdr = MHD_lookup_connection_value (connection,\n                                     MHD_GET_ARGUMENT_KIND, \"space\");\n  if ((hdr == NULL) || (0 != strcmp (hdr, \"\\240bar\")))\n    abort ();\n  if (3 != MHD_get_connection_values (connection,\n\t\t\t\t      MHD_GET_ARGUMENT_KIND,\n\t\t\t\t      NULL, NULL))\n    abort ();\n  response = MHD_create_response_from_buffer (strlen (url),\n\t\t\t\t\t      (void *) url,\n\t\t\t\t\t      MHD_RESPMEM_MUST_COPY);\n  ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n  MHD_destroy_response (response);\n  if (ret == MHD_NO)\n    abort ();\n  return ret;\n}",
      "lines": 48,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testExternalGet": {
      "start_point": [
        111,
        0
      ],
      "end_point": [
        267,
        1
      ],
      "content": "static int\ntestExternalGet ()\n{\n  struct MHD_Daemon *d;\n  CURL *c;\n  char buf[2048];\n  struct CBC cbc;\n  CURLM *multi;\n  CURLMcode mret;\n  fd_set rs;\n  fd_set ws;\n  fd_set es;\n  MHD_socket maxsock;\n#ifdef MHD_WINSOCK_SOCKETS\n  int maxposixs; /* Max socket number unused on W32 */\n#else  /* MHD_POSIX_SOCKETS */\n#define maxposixs maxsock\n#endif /* MHD_POSIX_SOCKETS */\n  int running;\n  struct CURLMsg *msg;\n  time_t start;\n  struct timeval tv;\n  int port;\n\n  if (MHD_NO != MHD_is_feature_supported (MHD_FEATURE_AUTODETECT_BIND_PORT))\n    port = 0;\n  else\n    {\n      port = 1410;\n      if (oneone)\n        port += 5;\n    }\n\n  multi = NULL;\n  cbc.buf = buf;\n  cbc.size = 2048;\n  cbc.pos = 0;\n  d = MHD_start_daemon (MHD_USE_ERROR_LOG,\n                        port, NULL, NULL, &ahc_echo, \"GET\", MHD_OPTION_END);\n  if (d == NULL)\n    return 256;\n  if (0 == port)\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (d, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        { MHD_stop_daemon (d); return 32; }\n      port = (int)dinfo->port;\n    }\n  c = curl_easy_init ();\n  curl_easy_setopt (c, CURLOPT_URL,\n                    \"http://127.0.0.1/hello+world?k=v+x&hash=%23foo&space=%A0bar\");\n  curl_easy_setopt (c, CURLOPT_PORT, (long)port);\n  curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n  curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc);\n  curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n  if (oneone)\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n  else\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0);\n  curl_easy_setopt (c, CURLOPT_TIMEOUT, 150L);\n  curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT, 150L);\n  /* NOTE: use of CONNECTTIMEOUT without also\n     setting NOSIGNAL results in really weird\n     crashes on my system! */\n  curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n\n\n  multi = curl_multi_init ();\n  if (multi == NULL)\n    {\n      curl_easy_cleanup (c);\n      MHD_stop_daemon (d);\n      return 512;\n    }\n  mret = curl_multi_add_handle (multi, c);\n  if (mret != CURLM_OK)\n    {\n      curl_multi_cleanup (multi);\n      curl_easy_cleanup (c);\n      MHD_stop_daemon (d);\n      return 1024;\n    }\n  start = time (NULL);\n  while ((time (NULL) - start < 5) && (multi != NULL))\n    {\n      maxsock = MHD_INVALID_SOCKET;\n      maxposixs = -1;\n      FD_ZERO (&rs);\n      FD_ZERO (&ws);\n      FD_ZERO (&es);\n      curl_multi_perform (multi, &running);\n      mret = curl_multi_fdset (multi, &rs, &ws, &es, &maxposixs);\n      if (mret != CURLM_OK)\n        {\n          curl_multi_remove_handle (multi, c);\n          curl_multi_cleanup (multi);\n          curl_easy_cleanup (c);\n          MHD_stop_daemon (d);\n          return 2048;\n        }\n      if (MHD_YES != MHD_get_fdset (d, &rs, &ws, &es, &maxsock))\n        {\n          curl_multi_remove_handle (multi, c);\n          curl_multi_cleanup (multi);\n          curl_easy_cleanup (c);\n          MHD_stop_daemon (d);\n          return 4096;\n        }\n      tv.tv_sec = 0;\n      tv.tv_usec = 1000;\n      if (-1 == select (maxposixs + 1, &rs, &ws, &es, &tv))\n        {\n#ifdef MHD_POSIX_SOCKETS\n          if (EINTR != errno)\n            abort ();\n#else\n          if (WSAEINVAL != WSAGetLastError() || 0 != rs.fd_count || 0 != ws.fd_count || 0 != es.fd_count)\n            abort ();\n          Sleep (1000);\n#endif\n        }\n      curl_multi_perform (multi, &running);\n      if (running == 0)\n        {\n          msg = curl_multi_info_read (multi, &running);\n          if (msg == NULL)\n            break;\n          if (msg->msg == CURLMSG_DONE)\n            {\n              if (msg->data.result != CURLE_OK)\n                printf (\"%s failed at %s:%d: `%s'\\n\",\n                        \"curl_multi_perform\",\n                        __FILE__,\n                        __LINE__, curl_easy_strerror (msg->data.result));\n              curl_multi_remove_handle (multi, c);\n              curl_multi_cleanup (multi);\n              curl_easy_cleanup (c);\n              c = NULL;\n              multi = NULL;\n            }\n        }\n      MHD_run (d);\n    }\n  if (multi != NULL)\n    {\n      curl_multi_remove_handle (multi, c);\n      curl_easy_cleanup (c);\n      curl_multi_cleanup (multi);\n    }\n  MHD_stop_daemon (d);\n  if (cbc.pos != strlen (\"/hello+world\"))\n    return 8192;\n  if (0 != strncmp (\"/hello+world\", cbc.buf, strlen (\"/hello+world\")))\n    return 16384;\n  return 0;\n}",
      "lines": 157,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        270,
        0
      ],
      "end_point": [
        285,
        1
      ],
      "content": "int\nmain (int argc, char *const *argv)\n{\n  unsigned int errorCount = 0;\n  (void)argc;   /* Unused. Silent compiler warning. */\n\n  oneone = (NULL != strrchr (argv[0], (int) '/')) ?\n    (NULL != strstr (strrchr (argv[0], (int) '/'), \"11\")) : 0;\n  if (0 != curl_global_init (CURL_GLOBAL_WIN32))\n    return 2;\n  errorCount += testExternalGet ();\n  if (errorCount != 0)\n    fprintf (stderr, \"Error (code: %u)\\n\", errorCount);\n  curl_global_cleanup ();\n  return errorCount != 0;       /* 0 == pass */\n}",
      "lines": 16,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/testcurl/test_process_headers.c": {
    "copyBuffer": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        65,
        1
      ],
      "content": "static size_t\ncopyBuffer (void *ptr, size_t size, size_t nmemb, void *ctx)\n{\n  struct CBC *cbc = ctx;\n\n  if (cbc->pos + size * nmemb > cbc->size)\n    return 0;                   /* overflow */\n  memcpy (&cbc->buf[cbc->pos], ptr, size * nmemb);\n  cbc->pos += size * nmemb;\n  return size * nmemb;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "kv_cb": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "static int\nkv_cb (void *cls, enum MHD_ValueKind kind, const char *key, const char *value)\n{\n  if ((0 == strcmp (key, MHD_HTTP_HEADER_HOST)) &&\n      (0 == strncmp (value, \"127.0.0.1\", strlen(\"127.0.0.1\"))) && (kind == MHD_HEADER_KIND))\n    {\n      *((int *) cls) = 1;\n      return MHD_NO;\n    }\n  return MHD_YES;\n}",
      "lines": 11,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "ahc_echo": {
      "start_point": [
        79,
        0
      ],
      "end_point": [
        147,
        1
      ],
      "content": "static int\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data, size_t *upload_data_size,\n          void **unused)\n{\n  static int ptr;\n  const char *me = cls;\n  struct MHD_Response *response;\n  int ret;\n  const char *hdr;\n  (void)version;(void)upload_data;(void)upload_data_size;       /* Unused. Silent compiler warning. */\n\n  if (0 != strcmp (me, method))\n    return MHD_NO;              /* unexpected method */\n  if (&ptr != *unused)\n    {\n      *unused = &ptr;\n      return MHD_YES;\n    }\n  *unused = NULL;\n  ret = 0;\n  MHD_get_connection_values (connection, MHD_HEADER_KIND, &kv_cb, &ret);\n  if (ret != 1)\n    abort ();\n  hdr = MHD_lookup_connection_value (connection, MHD_HEADER_KIND, \"NotFound\");\n  if (hdr != NULL)\n    abort ();\n  hdr = MHD_lookup_connection_value (connection,\n                                     MHD_HEADER_KIND, MHD_HTTP_HEADER_ACCEPT);\n  if ((hdr == NULL) || (0 != strcmp (hdr, \"*/*\")))\n    abort ();\n  hdr = MHD_lookup_connection_value (connection,\n                                     MHD_HEADER_KIND, MHD_HTTP_HEADER_HOST);\n  if ((hdr == NULL) || (0 != strncmp (hdr, \"127.0.0.1\", strlen(\"127.0.0.1\"))))\n    abort ();\n  MHD_set_connection_value (connection,\n                            MHD_HEADER_KIND, \"FakeHeader\", \"NowPresent\");\n  hdr = MHD_lookup_connection_value (connection,\n                                     MHD_HEADER_KIND, \"FakeHeader\");\n  if ((hdr == NULL) || (0 != strcmp (hdr, \"NowPresent\")))\n    abort ();\n\n  response = MHD_create_response_from_buffer (strlen (url),\n\t\t\t\t\t      (void *) url,\n\t\t\t\t\t      MHD_RESPMEM_MUST_COPY);\n  if (NULL == response)\n    abort ();\n  MHD_add_response_header (response, \"MyHeader\", \"MyValue\");\n  hdr = MHD_get_response_header (response, \"MyHeader\");\n  if (0 != strcmp (\"MyValue\", hdr))\n    abort ();\n  MHD_add_response_header (response, \"MyHeader\", \"MyValueToo\");\n  if (MHD_YES != MHD_del_response_header (response, \"MyHeader\", \"MyValue\"))\n    abort ();\n  hdr = MHD_get_response_header (response, \"MyHeader\");\n  if (0 != strcmp (\"MyValueToo\", hdr))\n    abort ();\n  if (1 != MHD_get_response_headers (response, NULL, NULL))\n    abort ();\n  ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n  MHD_destroy_response (response);\n  if (ret == MHD_NO)\n    abort ();\n  return ret;\n}",
      "lines": 69,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testInternalGet": {
      "start_point": [
        150,
        0
      ],
      "end_point": [
        216,
        1
      ],
      "content": "static int\ntestInternalGet ()\n{\n  struct MHD_Daemon *d;\n  CURL *c;\n  char buf[2048];\n  struct CBC cbc;\n  CURLcode errornum;\n  int port;\n\n  if (MHD_NO != MHD_is_feature_supported (MHD_FEATURE_AUTODETECT_BIND_PORT))\n    port = 0;\n  else\n    {\n      port = 1420;\n      if (oneone)\n        port += 10;\n    }\n\n  cbc.buf = buf;\n  cbc.size = 2048;\n  cbc.pos = 0;\n  d = MHD_start_daemon (MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_ERROR_LOG,\n                        port, NULL, NULL, &ahc_echo, \"GET\", MHD_OPTION_END);\n  if (d == NULL)\n    return 1;\n  if (0 == port)\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (d, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        { MHD_stop_daemon (d); return 32; }\n      port = (int)dinfo->port;\n    }\n  c = curl_easy_init ();\n  curl_easy_setopt (c, CURLOPT_URL, \"http://127.0.0.1/hello_world\");\n  curl_easy_setopt (c, CURLOPT_PORT, (long)port);\n  curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n  curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc);\n  curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n  curl_easy_setopt (c, CURLOPT_TIMEOUT, 150L);\n  curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT, 150L);\n  if (oneone)\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n  else\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0);\n  /* NOTE: use of CONNECTTIMEOUT without also\n     setting NOSIGNAL results in really weird\n     crashes on my system! */\n  curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n  if (CURLE_OK != (errornum = curl_easy_perform (c)))\n    {\n      fprintf (stderr,\n               \"curl_easy_perform failed: `%s'\\n\",\n               curl_easy_strerror (errornum));\n      curl_easy_cleanup (c);\n      MHD_stop_daemon (d);\n      return 2;\n    }\n  curl_easy_cleanup (c);\n  MHD_stop_daemon (d);\n  if (cbc.pos != strlen (\"/hello_world\"))\n    return 4;\n  if (0 != strncmp (\"/hello_world\", cbc.buf, strlen (\"/hello_world\")))\n    return 8;\n  return 0;\n}",
      "lines": 67,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testMultithreadedGet": {
      "start_point": [
        218,
        0
      ],
      "end_point": [
        284,
        1
      ],
      "content": "static int\ntestMultithreadedGet ()\n{\n  struct MHD_Daemon *d;\n  CURL *c;\n  char buf[2048];\n  struct CBC cbc;\n  CURLcode errornum;\n  int port;\n\n  if (MHD_NO != MHD_is_feature_supported (MHD_FEATURE_AUTODETECT_BIND_PORT))\n    port = 0;\n  else\n    {\n      port = 1421;\n      if (oneone)\n        port += 10;\n    }\n\n  cbc.buf = buf;\n  cbc.size = 2048;\n  cbc.pos = 0;\n  d = MHD_start_daemon (MHD_USE_THREAD_PER_CONNECTION | MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_ERROR_LOG,\n                        port, NULL, NULL, &ahc_echo, \"GET\", MHD_OPTION_END);\n  if (d == NULL)\n    return 16;\n  if (0 == port)\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (d, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        { MHD_stop_daemon (d); return 32; }\n      port = (int)dinfo->port;\n    }\n  c = curl_easy_init ();\n  curl_easy_setopt (c, CURLOPT_URL, \"http://127.0.0.1/hello_world\");\n  curl_easy_setopt (c, CURLOPT_PORT, (long)port);\n  curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n  curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc);\n  curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n  curl_easy_setopt (c, CURLOPT_TIMEOUT, 150L);\n  if (oneone)\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n  else\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0);\n  curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT, 150L);\n  /* NOTE: use of CONNECTTIMEOUT without also\n     setting NOSIGNAL results in really weird\n     crashes on my system! */\n  curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n  if (CURLE_OK != (errornum = curl_easy_perform (c)))\n    {\n      fprintf (stderr,\n               \"curl_easy_perform failed: `%s'\\n\",\n               curl_easy_strerror (errornum));\n      curl_easy_cleanup (c);\n      MHD_stop_daemon (d);\n      return 32;\n    }\n  curl_easy_cleanup (c);\n  MHD_stop_daemon (d);\n  if (cbc.pos != strlen (\"/hello_world\"))\n    return 64;\n  if (0 != strncmp (\"/hello_world\", cbc.buf, strlen (\"/hello_world\")))\n    return 128;\n  return 0;\n}",
      "lines": 67,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testMultithreadedPoolGet": {
      "start_point": [
        286,
        0
      ],
      "end_point": [
        353,
        1
      ],
      "content": "static int\ntestMultithreadedPoolGet ()\n{\n  struct MHD_Daemon *d;\n  CURL *c;\n  char buf[2048];\n  struct CBC cbc;\n  CURLcode errornum;\n  int port;\n\n  if (MHD_NO != MHD_is_feature_supported (MHD_FEATURE_AUTODETECT_BIND_PORT))\n    port = 0;\n  else\n    {\n      port = 1422;\n      if (oneone)\n        port += 10;\n    }\n\n  cbc.buf = buf;\n  cbc.size = 2048;\n  cbc.pos = 0;\n  d = MHD_start_daemon (MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_ERROR_LOG,\n                        port, NULL, NULL, &ahc_echo, \"GET\",\n                        MHD_OPTION_THREAD_POOL_SIZE, CPU_COUNT, MHD_OPTION_END);\n  if (d == NULL)\n    return 16;\n  if (0 == port)\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (d, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        { MHD_stop_daemon (d); return 32; }\n      port = (int)dinfo->port;\n    }\n  c = curl_easy_init ();\n  curl_easy_setopt (c, CURLOPT_URL, \"http://127.0.0.1/hello_world\");\n  curl_easy_setopt (c, CURLOPT_PORT, (long)port);\n  curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n  curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc);\n  curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n  curl_easy_setopt (c, CURLOPT_TIMEOUT, 150L);\n  if (oneone)\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n  else\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0);\n  curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT, 150L);\n  /* NOTE: use of CONNECTTIMEOUT without also\n     setting NOSIGNAL results in really weird\n     crashes on my system! */\n  curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n  if (CURLE_OK != (errornum = curl_easy_perform (c)))\n    {\n      fprintf (stderr,\n               \"curl_easy_perform failed: `%s'\\n\",\n               curl_easy_strerror (errornum));\n      curl_easy_cleanup (c);\n      MHD_stop_daemon (d);\n      return 32;\n    }\n  curl_easy_cleanup (c);\n  MHD_stop_daemon (d);\n  if (cbc.pos != strlen (\"/hello_world\"))\n    return 64;\n  if (0 != strncmp (\"/hello_world\", cbc.buf, strlen (\"/hello_world\")))\n    return 128;\n  return 0;\n}",
      "lines": 68,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testExternalGet": {
      "start_point": [
        355,
        0
      ],
      "end_point": [
        510,
        1
      ],
      "content": "static int\ntestExternalGet ()\n{\n  struct MHD_Daemon *d;\n  CURL *c;\n  char buf[2048];\n  struct CBC cbc;\n  CURLM *multi;\n  CURLMcode mret;\n  fd_set rs;\n  fd_set ws;\n  fd_set es;\n  MHD_socket maxsock;\n#ifdef MHD_WINSOCK_SOCKETS\n  int maxposixs; /* Max socket number unused on W32 */\n#else  /* MHD_POSIX_SOCKETS */\n#define maxposixs maxsock\n#endif /* MHD_POSIX_SOCKETS */\n  int running;\n  struct CURLMsg *msg;\n  time_t start;\n  struct timeval tv;\n  int port;\n\n  if (MHD_NO != MHD_is_feature_supported (MHD_FEATURE_AUTODETECT_BIND_PORT))\n    port = 0;\n  else\n    {\n      port = 1423;\n      if (oneone)\n        port += 10;\n    }\n\n  multi = NULL;\n  cbc.buf = buf;\n  cbc.size = 2048;\n  cbc.pos = 0;\n  d = MHD_start_daemon (MHD_USE_ERROR_LOG,\n                        port, NULL, NULL, &ahc_echo, \"GET\", MHD_OPTION_END);\n  if (d == NULL)\n    return 256;\n  if (0 == port)\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (d, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        { MHD_stop_daemon (d); return 32; }\n      port = (int)dinfo->port;\n    }\n  c = curl_easy_init ();\n  curl_easy_setopt (c, CURLOPT_URL, \"http://127.0.0.1/hello_world\");\n  curl_easy_setopt (c, CURLOPT_PORT, (long)port);\n  curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n  curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc);\n  curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n  if (oneone)\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n  else\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0);\n  curl_easy_setopt (c, CURLOPT_TIMEOUT, 150L);\n  curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT, 150L);\n  /* NOTE: use of CONNECTTIMEOUT without also\n     setting NOSIGNAL results in really weird\n     crashes on my system! */\n  curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n\n\n  multi = curl_multi_init ();\n  if (multi == NULL)\n    {\n      curl_easy_cleanup (c);\n      MHD_stop_daemon (d);\n      return 512;\n    }\n  mret = curl_multi_add_handle (multi, c);\n  if (mret != CURLM_OK)\n    {\n      curl_multi_cleanup (multi);\n      curl_easy_cleanup (c);\n      MHD_stop_daemon (d);\n      return 1024;\n    }\n  start = time (NULL);\n  while ((time (NULL) - start < 5) && (multi != NULL))\n    {\n      maxsock = MHD_INVALID_SOCKET;\n      maxposixs = -1;\n      FD_ZERO (&rs);\n      FD_ZERO (&ws);\n      FD_ZERO (&es);\n      curl_multi_perform (multi, &running);\n      mret = curl_multi_fdset (multi, &rs, &ws, &es, &maxposixs);\n      if (mret != CURLM_OK)\n        {\n          curl_multi_remove_handle (multi, c);\n          curl_multi_cleanup (multi);\n          curl_easy_cleanup (c);\n          MHD_stop_daemon (d);\n          return 2048;\n        }\n      if (MHD_YES != MHD_get_fdset (d, &rs, &ws, &es, &maxsock))\n        {\n          curl_multi_remove_handle (multi, c);\n          curl_multi_cleanup (multi);\n          curl_easy_cleanup (c);\n          MHD_stop_daemon (d);\n          return 4096;\n        }\n      tv.tv_sec = 0;\n      tv.tv_usec = 1000;\n      if (-1 == select (maxposixs + 1, &rs, &ws, &es, &tv))\n        {\n#ifdef MHD_POSIX_SOCKETS\n          if (EINTR != errno)\n            abort ();\n#else\n          if (WSAEINVAL != WSAGetLastError() || 0 != rs.fd_count || 0 != ws.fd_count || 0 != es.fd_count)\n            abort ();\n          Sleep (1000);\n#endif\n        }\n      curl_multi_perform (multi, &running);\n      if (running == 0)\n        {\n          msg = curl_multi_info_read (multi, &running);\n          if (msg == NULL)\n            break;\n          if (msg->msg == CURLMSG_DONE)\n            {\n              if (msg->data.result != CURLE_OK)\n                printf (\"%s failed at %s:%d: `%s'\\n\",\n                        \"curl_multi_perform\",\n                        __FILE__,\n                        __LINE__, curl_easy_strerror (msg->data.result));\n              curl_multi_remove_handle (multi, c);\n              curl_multi_cleanup (multi);\n              curl_easy_cleanup (c);\n              c = NULL;\n              multi = NULL;\n            }\n        }\n      MHD_run (d);\n    }\n  if (multi != NULL)\n    {\n      curl_multi_remove_handle (multi, c);\n      curl_easy_cleanup (c);\n      curl_multi_cleanup (multi);\n    }\n  MHD_stop_daemon (d);\n  if (cbc.pos != strlen (\"/hello_world\"))\n    return 8192;\n  if (0 != strncmp (\"/hello_world\", cbc.buf, strlen (\"/hello_world\")))\n    return 16384;\n  return 0;\n}",
      "lines": 156,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        514,
        0
      ],
      "end_point": [
        530,
        1
      ],
      "content": "int\nmain (int argc, char *const *argv)\n{\n  unsigned int errorCount = 0;\n  (void)argc;   /* Unused. Silent compiler warning. */\n\n  oneone = (NULL != strrchr (argv[0], (int) '/')) ?\n    (NULL != strstr (strrchr (argv[0], (int) '/'), \"11\")) : 0;\n  errorCount += testInternalGet ();\n  errorCount += testMultithreadedGet ();\n  errorCount += testMultithreadedPoolGet ();\n  errorCount += testExternalGet ();\n  if (errorCount != 0)\n    fprintf (stderr, \"Error (code: %u)\\n\", errorCount);\n  curl_global_cleanup ();\n  return errorCount != 0;       /* 0 == pass */\n}",
      "lines": 17,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/testcurl/test_put.c": {
    "putBuffer": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "static size_t\nputBuffer (void *stream, size_t size, size_t nmemb, void *ptr)\n{\n  unsigned int *pos = ptr;\n  unsigned int wrt;\n\n  wrt = size * nmemb;\n  if (wrt > 8 - (*pos))\n    wrt = 8 - (*pos);\n  memcpy (stream, &(\"Hello123\"[*pos]), wrt);\n  (*pos) += wrt;\n  return wrt;\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "copyBuffer": {
      "start_point": [
        68,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "static size_t\ncopyBuffer (void *ptr, size_t size, size_t nmemb, void *ctx)\n{\n  struct CBC *cbc = ctx;\n\n  if (cbc->pos + size * nmemb > cbc->size)\n    return 0;                   /* overflow */\n  memcpy (&cbc->buf[cbc->pos], ptr, size * nmemb);\n  cbc->pos += size * nmemb;\n  return size * nmemb;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "ahc_echo": {
      "start_point": [
        80,
        0
      ],
      "end_point": [
        117,
        1
      ],
      "content": "static int\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data, size_t *upload_data_size,\n          void **unused)\n{\n  int *done = cls;\n  struct MHD_Response *response;\n  int ret;\n  (void)version;(void)unused;   /* Unused. Silent compiler warning. */\n\n  if (0 != strcasecmp (\"PUT\", method))\n    return MHD_NO;              /* unexpected method */\n  if ((*done) == 0)\n    {\n      if (*upload_data_size != 8)\n        return MHD_YES;         /* not yet ready */\n      if (0 == memcmp (upload_data, \"Hello123\", 8))\n        {\n          *upload_data_size = 0;\n        }\n      else\n        {\n          printf (\"Invalid upload data `%8s'!\\n\", upload_data);\n          return MHD_NO;\n        }\n      *done = 1;\n      return MHD_YES;\n    }\n  response = MHD_create_response_from_buffer (strlen (url), (void*) url,\n\t\t\t\t\t      MHD_RESPMEM_MUST_COPY);\n  ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n  MHD_destroy_response (response);\n  return ret;\n}",
      "lines": 38,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testInternalPut": {
      "start_point": [
        120,
        0
      ],
      "end_point": [
        193,
        1
      ],
      "content": "static int\ntestInternalPut ()\n{\n  struct MHD_Daemon *d;\n  CURL *c;\n  char buf[2048];\n  struct CBC cbc;\n  unsigned int pos = 0;\n  int done_flag = 0;\n  CURLcode errornum;\n  int port;\n\n  if (MHD_NO != MHD_is_feature_supported (MHD_FEATURE_AUTODETECT_BIND_PORT))\n    port = 0;\n  else\n    {\n      port = 1450;\n      if (oneone)\n        port += 10;\n    }\n\n  cbc.buf = buf;\n  cbc.size = 2048;\n  cbc.pos = 0;\n  d = MHD_start_daemon (MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_ERROR_LOG,\n                        port,\n                        NULL, NULL, &ahc_echo, &done_flag, MHD_OPTION_END);\n  if (d == NULL)\n    return 1;\n  if (0 == port)\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (d, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        { MHD_stop_daemon (d); return 32; }\n      port = (int)dinfo->port;\n    }\n  c = curl_easy_init ();\n  curl_easy_setopt (c, CURLOPT_URL, \"http://127.0.0.1/hello_world\");\n  curl_easy_setopt (c, CURLOPT_PORT, (long)port);\n  curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n  curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc);\n  curl_easy_setopt (c, CURLOPT_READFUNCTION, &putBuffer);\n  curl_easy_setopt (c, CURLOPT_READDATA, &pos);\n  curl_easy_setopt (c, CURLOPT_UPLOAD, 1L);\n  curl_easy_setopt (c, CURLOPT_INFILESIZE_LARGE, (curl_off_t) 8L);\n  curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n  curl_easy_setopt (c, CURLOPT_TIMEOUT, 150L);\n  if (oneone)\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n  else\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0);\n  curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT, 150L);\n  /* NOTE: use of CONNECTTIMEOUT without also\n   *   setting NOSIGNAL results in really weird\n   *   crashes on my system! */\n  curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n  if (CURLE_OK != (errornum = curl_easy_perform (c)))\n    {\n      fprintf (stderr,\n               \"curl_easy_perform failed: `%s'\\n\",\n               curl_easy_strerror (errornum));\n      curl_easy_cleanup (c);\n      MHD_stop_daemon (d);\n      return 2;\n    }\n  curl_easy_cleanup (c);\n  MHD_stop_daemon (d);\n  if (cbc.pos != strlen (\"/hello_world\"))\n    return 4;\n  if (0 != strncmp (\"/hello_world\", cbc.buf, strlen (\"/hello_world\")))\n    return 8;\n  return 0;\n}",
      "lines": 74,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testMultithreadedPut": {
      "start_point": [
        195,
        0
      ],
      "end_point": [
        269,
        1
      ],
      "content": "static int\ntestMultithreadedPut ()\n{\n  struct MHD_Daemon *d;\n  CURL *c;\n  char buf[2048];\n  struct CBC cbc;\n  unsigned int pos = 0;\n  int done_flag = 0;\n  CURLcode errornum;\n  int port;\n\n  if (MHD_NO != MHD_is_feature_supported (MHD_FEATURE_AUTODETECT_BIND_PORT))\n    port = 0;\n  else\n    {\n      port = 1451;\n      if (oneone)\n        port += 10;\n    }\n\n  cbc.buf = buf;\n  cbc.size = 2048;\n  cbc.pos = 0;\n  d = MHD_start_daemon (MHD_USE_THREAD_PER_CONNECTION | MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_ERROR_LOG,\n                        port,\n                        NULL, NULL, &ahc_echo, &done_flag, MHD_OPTION_END);\n  if (d == NULL)\n    return 16;\n  if (0 == port)\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (d, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        { MHD_stop_daemon (d); return 32; }\n      port = (int)dinfo->port;\n    }\n  c = curl_easy_init ();\n  curl_easy_setopt (c, CURLOPT_URL, \"http://127.0.0.1/hello_world\");\n  curl_easy_setopt (c, CURLOPT_PORT, (long)port);\n  curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n  curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc);\n  curl_easy_setopt (c, CURLOPT_READFUNCTION, &putBuffer);\n  curl_easy_setopt (c, CURLOPT_READDATA, &pos);\n  curl_easy_setopt (c, CURLOPT_UPLOAD, 1L);\n  curl_easy_setopt (c, CURLOPT_INFILESIZE_LARGE, (curl_off_t) 8L);\n  curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n  curl_easy_setopt (c, CURLOPT_TIMEOUT, 150L);\n  if (oneone)\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n  else\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0);\n  curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT, 150L);\n  /* NOTE: use of CONNECTTIMEOUT without also\n   *   setting NOSIGNAL results in really weird\n   *   crashes on my system! */\n  curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n  if (CURLE_OK != (errornum = curl_easy_perform (c)))\n    {\n      fprintf (stderr,\n               \"curl_easy_perform failed: `%s'\\n\",\n               curl_easy_strerror (errornum));\n      curl_easy_cleanup (c);\n      MHD_stop_daemon (d);\n      return 32;\n    }\n  curl_easy_cleanup (c);\n  MHD_stop_daemon (d);\n  if (cbc.pos != strlen (\"/hello_world\"))\n    return 64;\n  if (0 != strncmp (\"/hello_world\", cbc.buf, strlen (\"/hello_world\")))\n    return 128;\n\n  return 0;\n}",
      "lines": 75,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testMultithreadedPoolPut": {
      "start_point": [
        271,
        0
      ],
      "end_point": [
        346,
        1
      ],
      "content": "static int\ntestMultithreadedPoolPut ()\n{\n  struct MHD_Daemon *d;\n  CURL *c;\n  char buf[2048];\n  struct CBC cbc;\n  unsigned int pos = 0;\n  int done_flag = 0;\n  CURLcode errornum;\n  int port;\n\n  if (MHD_NO != MHD_is_feature_supported (MHD_FEATURE_AUTODETECT_BIND_PORT))\n    port = 0;\n  else\n    {\n      port = 1452;\n      if (oneone)\n        port += 10;\n    }\n\n  cbc.buf = buf;\n  cbc.size = 2048;\n  cbc.pos = 0;\n  d = MHD_start_daemon (MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_ERROR_LOG,\n                        port,\n                        NULL, NULL, &ahc_echo, &done_flag,\n                        MHD_OPTION_THREAD_POOL_SIZE, CPU_COUNT, MHD_OPTION_END);\n  if (d == NULL)\n    return 16;\n  if (0 == port)\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (d, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        { MHD_stop_daemon (d); return 32; }\n      port = (int)dinfo->port;\n    }\n  c = curl_easy_init ();\n  curl_easy_setopt (c, CURLOPT_URL, \"http://127.0.0.1/hello_world\");\n  curl_easy_setopt (c, CURLOPT_PORT, (long)port);\n  curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n  curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc);\n  curl_easy_setopt (c, CURLOPT_READFUNCTION, &putBuffer);\n  curl_easy_setopt (c, CURLOPT_READDATA, &pos);\n  curl_easy_setopt (c, CURLOPT_UPLOAD, 1L);\n  curl_easy_setopt (c, CURLOPT_INFILESIZE_LARGE, (curl_off_t) 8L);\n  curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n  curl_easy_setopt (c, CURLOPT_TIMEOUT, 150L);\n  if (oneone)\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n  else\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0);\n  curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT, 150L);\n  /* NOTE: use of CONNECTTIMEOUT without also\n   *   setting NOSIGNAL results in really weird\n   *   crashes on my system! */\n  curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n  if (CURLE_OK != (errornum = curl_easy_perform (c)))\n    {\n      fprintf (stderr,\n               \"curl_easy_perform failed: `%s'\\n\",\n               curl_easy_strerror (errornum));\n      curl_easy_cleanup (c);\n      MHD_stop_daemon (d);\n      return 32;\n    }\n  curl_easy_cleanup (c);\n  MHD_stop_daemon (d);\n  if (cbc.pos != strlen (\"/hello_world\"))\n    return 64;\n  if (0 != strncmp (\"/hello_world\", cbc.buf, strlen (\"/hello_world\")))\n    return 128;\n\n  return 0;\n}",
      "lines": 76,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testExternalPut": {
      "start_point": [
        349,
        0
      ],
      "end_point": [
        511,
        1
      ],
      "content": "static int\ntestExternalPut ()\n{\n  struct MHD_Daemon *d;\n  CURL *c;\n  char buf[2048];\n  struct CBC cbc;\n  CURLM *multi;\n  CURLMcode mret;\n  fd_set rs;\n  fd_set ws;\n  fd_set es;\n  MHD_socket maxsock;\n#ifdef MHD_WINSOCK_SOCKETS\n  int maxposixs; /* Max socket number unused on W32 */\n#else  /* MHD_POSIX_SOCKETS */\n#define maxposixs maxsock\n#endif /* MHD_POSIX_SOCKETS */\n  int running;\n  struct CURLMsg *msg;\n  time_t start;\n  struct timeval tv;\n  unsigned int pos = 0;\n  int done_flag = 0;\n  int port;\n\n  if (MHD_NO != MHD_is_feature_supported (MHD_FEATURE_AUTODETECT_BIND_PORT))\n    port = 0;\n  else\n    {\n      port = 1453;\n      if (oneone)\n        port += 10;\n    }\n\n  multi = NULL;\n  cbc.buf = buf;\n  cbc.size = 2048;\n  cbc.pos = 0;\n  d = MHD_start_daemon (MHD_USE_ERROR_LOG,\n                        port,\n                        NULL, NULL, &ahc_echo, &done_flag, MHD_OPTION_END);\n  if (d == NULL)\n    return 256;\n  if (0 == port)\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (d, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        { MHD_stop_daemon (d); return 32; }\n      port = (int)dinfo->port;\n    }\n  c = curl_easy_init ();\n  curl_easy_setopt (c, CURLOPT_URL, \"http://127.0.0.1/hello_world\");\n  curl_easy_setopt (c, CURLOPT_PORT, (long)port);\ncurl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n  curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc);\n  curl_easy_setopt (c, CURLOPT_READFUNCTION, &putBuffer);\n  curl_easy_setopt (c, CURLOPT_READDATA, &pos);\n  curl_easy_setopt (c, CURLOPT_UPLOAD, 1L);\n  curl_easy_setopt (c, CURLOPT_INFILESIZE_LARGE, (curl_off_t) 8L);\n  curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n  curl_easy_setopt (c, CURLOPT_TIMEOUT, 150L);\n  if (oneone)\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n  else\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0);\n  curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT, 150L);\n  /* NOTE: use of CONNECTTIMEOUT without also\n   *   setting NOSIGNAL results in really weird\n   *   crashes on my system! */\n  curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n\n\n  multi = curl_multi_init ();\n  if (multi == NULL)\n    {\n      curl_easy_cleanup (c);\n      MHD_stop_daemon (d);\n      return 512;\n    }\n  mret = curl_multi_add_handle (multi, c);\n  if (mret != CURLM_OK)\n    {\n      curl_multi_cleanup (multi);\n      curl_easy_cleanup (c);\n      MHD_stop_daemon (d);\n      return 1024;\n    }\n  start = time (NULL);\n  while ((time (NULL) - start < 5) && (multi != NULL))\n    {\n      maxsock = MHD_INVALID_SOCKET;\n      maxposixs = -1;\n      FD_ZERO (&rs);\n      FD_ZERO (&ws);\n      FD_ZERO (&es);\n      curl_multi_perform (multi, &running);\n      mret = curl_multi_fdset (multi, &rs, &ws, &es, &maxposixs);\n      if (mret != CURLM_OK)\n        {\n          curl_multi_remove_handle (multi, c);\n          curl_multi_cleanup (multi);\n          curl_easy_cleanup (c);\n          MHD_stop_daemon (d);\n          return 2048;\n        }\n      if (MHD_YES != MHD_get_fdset (d, &rs, &ws, &es, &maxsock))\n        {\n          curl_multi_remove_handle (multi, c);\n          curl_multi_cleanup (multi);\n          curl_easy_cleanup (c);\n          MHD_stop_daemon (d);\n          return 4096;\n        }\n      tv.tv_sec = 0;\n      tv.tv_usec = 1000;\n      if (-1 == select (maxposixs + 1, &rs, &ws, &es, &tv))\n        {\n#ifdef MHD_POSIX_SOCKETS\n          if (EINTR != errno)\n            abort ();\n#else\n          if (WSAEINVAL != WSAGetLastError() || 0 != rs.fd_count || 0 != ws.fd_count || 0 != es.fd_count)\n            abort ();\n          Sleep (1000);\n#endif\n        }\n      curl_multi_perform (multi, &running);\n      if (running == 0)\n        {\n          msg = curl_multi_info_read (multi, &running);\n          if (msg == NULL)\n            break;\n          if (msg->msg == CURLMSG_DONE)\n            {\n              if (msg->data.result != CURLE_OK)\n                printf (\"%s failed at %s:%d: `%s'\\n\",\n                        \"curl_multi_perform\",\n                        __FILE__,\n                        __LINE__, curl_easy_strerror (msg->data.result));\n              curl_multi_remove_handle (multi, c);\n              curl_multi_cleanup (multi);\n              curl_easy_cleanup (c);\n              c = NULL;\n              multi = NULL;\n            }\n        }\n      MHD_run (d);\n    }\n  if (multi != NULL)\n    {\n      curl_multi_remove_handle (multi, c);\n      curl_easy_cleanup (c);\n      curl_multi_cleanup (multi);\n    }\n  MHD_stop_daemon (d);\n  if (cbc.pos != strlen (\"/hello_world\"))\n    return 8192;\n  if (0 != strncmp (\"/hello_world\", cbc.buf, strlen (\"/hello_world\")))\n    return 16384;\n  return 0;\n}",
      "lines": 163,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        515,
        0
      ],
      "end_point": [
        533,
        1
      ],
      "content": "int\nmain (int argc, char *const *argv)\n{\n  unsigned int errorCount = 0;\n  (void)argc;   /* Unused. Silent compiler warning. */\n\n  oneone = (NULL != strrchr (argv[0], (int) '/')) ?\n    (NULL != strstr (strrchr (argv[0], (int) '/'), \"11\")) : 0;\n  if (0 != curl_global_init (CURL_GLOBAL_WIN32))\n    return 2;\n  errorCount += testInternalPut ();\n  errorCount += testMultithreadedPut ();\n  errorCount += testMultithreadedPoolPut ();\n  errorCount += testExternalPut ();\n  if (errorCount != 0)\n    fprintf (stderr, \"Error (code: %u)\\n\", errorCount);\n  curl_global_cleanup ();\n  return errorCount != 0;       /* 0 == pass */\n}",
      "lines": 19,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/testcurl/test_put_chunked.c": {
    "putBuffer": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "static size_t\nputBuffer (void *stream, size_t size, size_t nmemb, void *ptr)\n{\n  unsigned int *pos = ptr;\n  unsigned int wrt;\n\n  wrt = size * nmemb;\n  if (wrt > 8 - (*pos))\n    wrt = 8 - (*pos);\n  if (wrt > 4)\n    wrt = 4;                    /* only send half at first => force multiple chunks! */\n  memcpy (stream, &(\"Hello123\"[*pos]), wrt);\n  (*pos) += wrt;\n  return wrt;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "copyBuffer": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "static size_t\ncopyBuffer (void *ptr, size_t size, size_t nmemb, void *ctx)\n{\n  struct CBC *cbc = ctx;\n\n  if (cbc->pos + size * nmemb > cbc->size)\n    return 0;                   /* overflow */\n  memcpy (&cbc->buf[cbc->pos], ptr, size * nmemb);\n  cbc->pos += size * nmemb;\n  return size * nmemb;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "ahc_echo": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        127,
        1
      ],
      "content": "static int\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data, size_t *upload_data_size,\n          void **unused)\n{\n  int *done = cls;\n  struct MHD_Response *response;\n  int ret;\n  int have;\n  (void)version;(void)unused;   /* Unused. Silent compiler warning. */\n\n  if (0 != strcmp (\"PUT\", method))\n    return MHD_NO;              /* unexpected method */\n  if ((*done) < 8)\n    {\n      have = *upload_data_size;\n      if (have + *done > 8)\n        {\n          printf (\"Invalid upload data `%8s'!\\n\", upload_data);\n          return MHD_NO;\n        }\n      if (0 == memcmp (upload_data, &\"Hello123\"[*done], have))\n        {\n          *done += have;\n          *upload_data_size = 0;\n        }\n      else\n        {\n          printf (\"Invalid upload data `%8s'!\\n\", upload_data);\n          return MHD_NO;\n        }\n#if 0\n      fprintf (stderr, \"Not ready for response: %u/%u\\n\", *done, 8);\n#endif\n      return MHD_YES;\n    }\n  response = MHD_create_response_from_buffer (strlen (url),\n\t\t\t\t\t      (void *) url,\n\t\t\t\t\t      MHD_RESPMEM_MUST_COPY);\n  ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n  MHD_destroy_response (response);\n  return ret;\n}",
      "lines": 47,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testInternalPut": {
      "start_point": [
        130,
        0
      ],
      "end_point": [
        199,
        1
      ],
      "content": "static int\ntestInternalPut ()\n{\n  struct MHD_Daemon *d;\n  CURL *c;\n  char buf[2048];\n  struct CBC cbc;\n  unsigned int pos = 0;\n  int done_flag = 0;\n  CURLcode errornum;\n  int port;\n\n  if (MHD_NO != MHD_is_feature_supported (MHD_FEATURE_AUTODETECT_BIND_PORT))\n    port = 0;\n  else\n    port = 1440;\n\n  cbc.buf = buf;\n  cbc.size = 2048;\n  cbc.pos = 0;\n  d = MHD_start_daemon (MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_ERROR_LOG,\n                        port,\n                        NULL, NULL, &ahc_echo, &done_flag, MHD_OPTION_END);\n  if (d == NULL)\n    return 1;\n  if (0 == port)\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (d, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        { MHD_stop_daemon (d); return 32; }\n      port = (int)dinfo->port;\n    }\n  c = curl_easy_init ();\n  curl_easy_setopt (c, CURLOPT_URL, \"http://127.0.0.1/hello_world\");\n  curl_easy_setopt (c, CURLOPT_PORT, (long)port);\n  curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n  curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc);\n  curl_easy_setopt (c, CURLOPT_READFUNCTION, &putBuffer);\n  curl_easy_setopt (c, CURLOPT_READDATA, &pos);\n  curl_easy_setopt (c, CURLOPT_UPLOAD, 1L);\n  /* by not giving the file size, we force chunking! */\n  /*\n     curl_easy_setopt (c, CURLOPT_INFILESIZE_LARGE, (curl_off_t) 8L);\n   */\n  curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n  curl_easy_setopt (c, CURLOPT_TIMEOUT, 150L);\n  curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n  curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT, 150L);\n  /* NOTE: use of CONNECTTIMEOUT without also\n   *   setting NOSIGNAL results in really weird\n   *   crashes on my system! */\n  curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n  if (CURLE_OK != (errornum = curl_easy_perform (c)))\n    {\n      fprintf (stderr,\n               \"curl_easy_perform failed: `%s'\\n\",\n               curl_easy_strerror (errornum));\n      curl_easy_cleanup (c);\n      MHD_stop_daemon (d);\n      return 2;\n    }\n  curl_easy_cleanup (c);\n  MHD_stop_daemon (d);\n  if (cbc.pos != strlen (\"/hello_world\"))\n    return 4;\n  if (0 != strncmp (\"/hello_world\", cbc.buf, strlen (\"/hello_world\")))\n    return 8;\n  return 0;\n}",
      "lines": 70,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testMultithreadedPut": {
      "start_point": [
        201,
        0
      ],
      "end_point": [
        271,
        1
      ],
      "content": "static int\ntestMultithreadedPut ()\n{\n  struct MHD_Daemon *d;\n  CURL *c;\n  char buf[2048];\n  struct CBC cbc;\n  unsigned int pos = 0;\n  int done_flag = 0;\n  CURLcode errornum;\n  int port;\n\n  if (MHD_NO != MHD_is_feature_supported (MHD_FEATURE_AUTODETECT_BIND_PORT))\n    port = 0;\n  else\n    port = 1441;\n\n  cbc.buf = buf;\n  cbc.size = 2048;\n  cbc.pos = 0;\n  d = MHD_start_daemon (MHD_USE_THREAD_PER_CONNECTION | MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_ERROR_LOG,\n                        port,\n                        NULL, NULL, &ahc_echo, &done_flag, MHD_OPTION_END);\n  if (d == NULL)\n    return 16;\n  if (0 == port)\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (d, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        { MHD_stop_daemon (d); return 32; }\n      port = (int)dinfo->port;\n    }\n  c = curl_easy_init ();\n  curl_easy_setopt (c, CURLOPT_URL, \"http://127.0.0.1/hello_world\");\n  curl_easy_setopt (c, CURLOPT_PORT, (long)port);\n  curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n  curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc);\n  curl_easy_setopt (c, CURLOPT_READFUNCTION, &putBuffer);\n  curl_easy_setopt (c, CURLOPT_READDATA, &pos);\n  curl_easy_setopt (c, CURLOPT_UPLOAD, 1L);\n  /* by not giving the file size, we force chunking! */\n  /*\n     curl_easy_setopt (c, CURLOPT_INFILESIZE_LARGE, (curl_off_t) 8L);\n   */\n  curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n  curl_easy_setopt (c, CURLOPT_TIMEOUT, 150L);\n  curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n  curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT, 150L);\n  /* NOTE: use of CONNECTTIMEOUT without also\n   *   setting NOSIGNAL results in really weird\n   *   crashes on my system! */\n  curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n  if (CURLE_OK != (errornum = curl_easy_perform (c)))\n    {\n      fprintf (stderr,\n               \"curl_easy_perform failed: `%s'\\n\",\n               curl_easy_strerror (errornum));\n      curl_easy_cleanup (c);\n      MHD_stop_daemon (d);\n      return 32;\n    }\n  curl_easy_cleanup (c);\n  MHD_stop_daemon (d);\n  if (cbc.pos != strlen (\"/hello_world\"))\n    return 64;\n  if (0 != strncmp (\"/hello_world\", cbc.buf, strlen (\"/hello_world\")))\n    return 128;\n\n  return 0;\n}",
      "lines": 71,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testMultithreadedPoolPut": {
      "start_point": [
        273,
        0
      ],
      "end_point": [
        344,
        1
      ],
      "content": "static int\ntestMultithreadedPoolPut ()\n{\n  struct MHD_Daemon *d;\n  CURL *c;\n  char buf[2048];\n  struct CBC cbc;\n  unsigned int pos = 0;\n  int done_flag = 0;\n  CURLcode errornum;\n  int port;\n\n  if (MHD_NO != MHD_is_feature_supported (MHD_FEATURE_AUTODETECT_BIND_PORT))\n    port = 0;\n  else\n    port = 1442;\n\n  cbc.buf = buf;\n  cbc.size = 2048;\n  cbc.pos = 0;\n  d = MHD_start_daemon (MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_ERROR_LOG,\n                        port,\n                        NULL, NULL, &ahc_echo, &done_flag,\n                        MHD_OPTION_THREAD_POOL_SIZE, CPU_COUNT, MHD_OPTION_END);\n  if (d == NULL)\n    return 16;\n  if (0 == port)\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (d, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        { MHD_stop_daemon (d); return 32; }\n      port = (int)dinfo->port;\n    }\n  c = curl_easy_init ();\n  curl_easy_setopt (c, CURLOPT_URL, \"http://127.0.0.1/hello_world\");\n  curl_easy_setopt (c, CURLOPT_PORT, (long)port);\n  curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n  curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc);\n  curl_easy_setopt (c, CURLOPT_READFUNCTION, &putBuffer);\n  curl_easy_setopt (c, CURLOPT_READDATA, &pos);\n  curl_easy_setopt (c, CURLOPT_UPLOAD, 1L);\n  /* by not giving the file size, we force chunking! */\n  /*\n     curl_easy_setopt (c, CURLOPT_INFILESIZE_LARGE, (curl_off_t) 8L);\n   */\n  curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n  curl_easy_setopt (c, CURLOPT_TIMEOUT, 150L);\n  curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n  curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT, 150L);\n  /* NOTE: use of CONNECTTIMEOUT without also\n   *   setting NOSIGNAL results in really weird\n   *   crashes on my system! */\n  curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n  if (CURLE_OK != (errornum = curl_easy_perform (c)))\n    {\n      fprintf (stderr,\n               \"curl_easy_perform failed: `%s'\\n\",\n               curl_easy_strerror (errornum));\n      curl_easy_cleanup (c);\n      MHD_stop_daemon (d);\n      return 32;\n    }\n  curl_easy_cleanup (c);\n  MHD_stop_daemon (d);\n  if (cbc.pos != strlen (\"/hello_world\"))\n    return 64;\n  if (0 != strncmp (\"/hello_world\", cbc.buf, strlen (\"/hello_world\")))\n    return 128;\n\n  return 0;\n}",
      "lines": 72,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testExternalPut": {
      "start_point": [
        347,
        0
      ],
      "end_point": [
        506,
        1
      ],
      "content": "static int\ntestExternalPut ()\n{\n  struct MHD_Daemon *d;\n  CURL *c;\n  char buf[2048];\n  struct CBC cbc;\n  CURLM *multi;\n  CURLMcode mret;\n  fd_set rs;\n  fd_set ws;\n  fd_set es;\n  MHD_socket maxsock;\n#ifdef MHD_WINSOCK_SOCKETS\n  int maxposixs; /* Max socket number unused on W32 */\n#else  /* MHD_POSIX_SOCKETS */\n#define maxposixs maxsock\n#endif /* MHD_POSIX_SOCKETS */\n  int running;\n  struct CURLMsg *msg;\n  time_t start;\n  struct timeval tv;\n  unsigned int pos = 0;\n  int done_flag = 0;\n  int port;\n\n  if (MHD_NO != MHD_is_feature_supported (MHD_FEATURE_AUTODETECT_BIND_PORT))\n    port = 0;\n  else\n    port = 1443;\n\n  multi = NULL;\n  cbc.buf = buf;\n  cbc.size = 2048;\n  cbc.pos = 0;\n  d = MHD_start_daemon (MHD_USE_ERROR_LOG,\n                        port,\n                        NULL, NULL, &ahc_echo, &done_flag, MHD_OPTION_END);\n  if (d == NULL)\n    return 256;\n  if (0 == port)\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (d, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        { MHD_stop_daemon (d); return 32; }\n      port = (int)dinfo->port;\n    }\n  c = curl_easy_init ();\n  curl_easy_setopt (c, CURLOPT_URL, \"http://127.0.0.1/hello_world\");\n  curl_easy_setopt (c, CURLOPT_PORT, (long)port);\n  curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n  curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc);\n  curl_easy_setopt (c, CURLOPT_READFUNCTION, &putBuffer);\n  curl_easy_setopt (c, CURLOPT_READDATA, &pos);\n  curl_easy_setopt (c, CURLOPT_UPLOAD, 1L);\n  /* by not giving the file size, we force chunking! */\n  /*\n     curl_easy_setopt (c, CURLOPT_INFILESIZE_LARGE, (curl_off_t) 8L);\n   */\n  curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n  curl_easy_setopt (c, CURLOPT_TIMEOUT, 150L);\n  curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n  curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT, 150L);\n  /* NOTE: use of CONNECTTIMEOUT without also\n   *   setting NOSIGNAL results in really weird\n   *   crashes on my system! */\n  curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n\n\n  multi = curl_multi_init ();\n  if (multi == NULL)\n    {\n      curl_easy_cleanup (c);\n      MHD_stop_daemon (d);\n      return 512;\n    }\n  mret = curl_multi_add_handle (multi, c);\n  if (mret != CURLM_OK)\n    {\n      curl_multi_cleanup (multi);\n      curl_easy_cleanup (c);\n      MHD_stop_daemon (d);\n      return 1024;\n    }\n  start = time (NULL);\n  while ((time (NULL) - start < 5) && (multi != NULL))\n    {\n      maxsock = MHD_INVALID_SOCKET;\n      maxposixs = -1;\n      FD_ZERO (&rs);\n      FD_ZERO (&ws);\n      FD_ZERO (&es);\n      curl_multi_perform (multi, &running);\n      mret = curl_multi_fdset (multi, &rs, &ws, &es, &maxposixs);\n      if (mret != CURLM_OK)\n        {\n          curl_multi_remove_handle (multi, c);\n          curl_multi_cleanup (multi);\n          curl_easy_cleanup (c);\n          MHD_stop_daemon (d);\n          return 2048;\n        }\n      if (MHD_YES != MHD_get_fdset (d, &rs, &ws, &es, &maxsock))\n        {\n          curl_multi_remove_handle (multi, c);\n          curl_multi_cleanup (multi);\n          curl_easy_cleanup (c);\n          MHD_stop_daemon (d);\n          return 4096;\n        }\n      tv.tv_sec = 0;\n      tv.tv_usec = 1000;\n      if (-1 == select (maxposixs + 1, &rs, &ws, &es, &tv))\n        {\n#ifdef MHD_POSIX_SOCKETS\n          if (EINTR != errno)\n            abort ();\n#else\n          if (WSAEINVAL != WSAGetLastError() || 0 != rs.fd_count || 0 != ws.fd_count || 0 != es.fd_count)\n            abort ();\n          Sleep (1000);\n#endif\n        }\n      curl_multi_perform (multi, &running);\n      if (running == 0)\n        {\n          msg = curl_multi_info_read (multi, &running);\n          if (msg == NULL)\n            break;\n          if (msg->msg == CURLMSG_DONE)\n            {\n              if (msg->data.result != CURLE_OK)\n                printf (\"%s failed at %s:%d: `%s'\\n\",\n                        \"curl_multi_perform\",\n                        __FILE__,\n                        __LINE__,\n                        curl_easy_strerror (msg->data.result));\n              curl_multi_remove_handle (multi, c);\n              curl_multi_cleanup (multi);\n              curl_easy_cleanup (c);\n              c = NULL;\n              multi = NULL;\n            }\n        }\n      MHD_run (d);\n    }\n  if (multi != NULL)\n    {\n      curl_multi_remove_handle (multi, c);\n      curl_easy_cleanup (c);\n      curl_multi_cleanup (multi);\n    }\n  MHD_stop_daemon (d);\n  if (cbc.pos != strlen (\"/hello_world\"))\n    return 8192;\n  if (0 != strncmp (\"/hello_world\", cbc.buf, strlen (\"/hello_world\")))\n    return 16384;\n  return 0;\n}",
      "lines": 160,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        510,
        0
      ],
      "end_point": [
        526,
        1
      ],
      "content": "int\nmain (int argc, char *const *argv)\n{\n  unsigned int errorCount = 0;\n  (void)argc; (void)argv; /* Unused. Silent compiler warning. */\n\n  if (0 != curl_global_init (CURL_GLOBAL_WIN32))\n    return 2;\n  errorCount += testInternalPut ();\n  errorCount += testMultithreadedPut ();\n  errorCount += testMultithreadedPoolPut ();\n  errorCount += testExternalPut ();\n  if (errorCount != 0)\n    fprintf (stderr, \"Error (code: %u)\\n\", errorCount);\n  curl_global_cleanup ();\n  return errorCount != 0;       /* 0 == pass */\n}",
      "lines": 17,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/testcurl/test_quiesce.c": {
    "copyBuffer": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        69,
        1
      ],
      "content": "static size_t\ncopyBuffer (void *ptr, size_t size, size_t nmemb, void *ctx)\n{\n  struct CBC *cbc = ctx;\n\n  if (cbc->pos + size * nmemb > cbc->size)\n    return 0;                   /* overflow */\n  memcpy (&cbc->buf[cbc->pos], ptr, size * nmemb);\n  cbc->pos += size * nmemb;\n  return size * nmemb;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "ahc_echo": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "static int\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data, size_t *upload_data_size,\n          void **unused)\n{\n  static int ptr;\n  const char *me = cls;\n  struct MHD_Response *response;\n  int ret;\n  (void)version;(void)upload_data;(void)upload_data_size;       /* Unused. Silent compiler warning. */\n\n  if (0 != strcmp (me, method))\n    return MHD_NO;              /* unexpected method */\n  if (&ptr != *unused)\n    {\n      *unused = &ptr;\n      return MHD_YES;\n    }\n  *unused = NULL;\n  response = MHD_create_response_from_buffer (strlen (url),\n  \t\t\t\t      (void *) url,\n\t\t\t\t\t      MHD_RESPMEM_MUST_COPY);\n  ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n  MHD_destroy_response (response);\n  if (ret == MHD_NO)\n    abort ();\n  return ret;\n}",
      "lines": 32,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "request_completed": {
      "start_point": [
        106,
        0
      ],
      "end_point": [
        113,
        1
      ],
      "content": "static void\nrequest_completed (void *cls, struct MHD_Connection *connection,\n\t\t   void **con_cls, enum MHD_RequestTerminationCode code)\n{\n  (void)connection;(void)con_cls;(void)code;    /* Unused. Silent compiler warning. */\n  int *done = (int *)cls;\n  *done = 1;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "ServeOneRequest": {
      "start_point": [
        116,
        0
      ],
      "end_point": [
        174,
        1
      ],
      "content": "static void *\nServeOneRequest(void *param)\n{\n  struct MHD_Daemon *d;\n  fd_set rs;\n  fd_set ws;\n  fd_set es;\n  MHD_socket fd, max;\n  time_t start;\n  struct timeval tv;\n  int done = 0;\n\n  fd = (MHD_socket) (intptr_t) param;\n\n  d = MHD_start_daemon (MHD_USE_ERROR_LOG,\n                        0, NULL, NULL, &ahc_echo, \"GET\",\n                        MHD_OPTION_LISTEN_SOCKET, fd,\n                        MHD_OPTION_NOTIFY_COMPLETED, &request_completed, &done,\n                        MHD_OPTION_END);\n  if (d == NULL)\n    return \"MHD_start_daemon() failed\";\n\n  start = time (NULL);\n  while ((time (NULL) - start < 5) && done == 0)\n    {\n      max = 0;\n      FD_ZERO (&rs);\n      FD_ZERO (&ws);\n      FD_ZERO (&es);\n      if (MHD_YES != MHD_get_fdset (d, &rs, &ws, &es, &max))\n        {\n          MHD_stop_daemon (d);\n          MHD_socket_close_chk_(fd);\n          return \"MHD_get_fdset() failed\";\n        }\n      tv.tv_sec = 0;\n      tv.tv_usec = 1000;\n      if (-1 == MHD_SYS_select_ (max + 1, &rs, &ws, &es, &tv))\n        {\n#ifdef MHD_POSIX_SOCKETS\n          if (EINTR != errno)\n            abort ();\n#else\n          if (WSAEINVAL != WSAGetLastError() || 0 != rs.fd_count || 0 != ws.fd_count || 0 != es.fd_count)\n            abort ();\n          Sleep (1000);\n#endif\n        }\n      MHD_run (d);\n    }\n  fd = MHD_quiesce_daemon (d);\n  if (MHD_INVALID_SOCKET == fd)\n    {\n      MHD_stop_daemon (d);\n      return \"MHD_quiesce_daemon() failed in ServeOneRequest()\";\n    }\n  MHD_stop_daemon (d);\n  return done ? NULL : \"Requests was not served by ServeOneRequest()\";\n}",
      "lines": 59,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nServeOneRequest(void *param)",
        "*"
      ]
    },
    "setupCURL": {
      "start_point": [
        177,
        0
      ],
      "end_point": [
        197,
        1
      ],
      "content": "static CURL *\nsetupCURL (void *cbc)\n{\n  CURL *c;\n\n  c = curl_easy_init ();\n  curl_easy_setopt (c, CURLOPT_URL, \"http://127.0.0.1/hello_world\");\n  curl_easy_setopt (c, CURLOPT_PORT, (long)port);\n  curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n  curl_easy_setopt (c, CURLOPT_WRITEDATA, cbc);\n  curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n  curl_easy_setopt (c, CURLOPT_TIMEOUT_MS, 150L);\n  curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT_MS, 150L);\n  curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0);\n  /* NOTE: use of CONNECTTIMEOUT without also\n     setting NOSIGNAL results in really weird\n     crashes on my system!*/\n  curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n\n  return c;\n}",
      "lines": 21,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "CURL",
        "*\nsetupCURL (void *cbc)",
        "*"
      ]
    },
    "testGet": {
      "start_point": [
        200,
        0
      ],
      "end_point": [
        339,
        1
      ],
      "content": "static int\ntestGet (int type, int pool_count, int poll_flag)\n{\n  struct MHD_Daemon *d;\n  CURL *c;\n  char buf[2048];\n  struct CBC cbc;\n  CURLcode errornum;\n  MHD_socket fd;\n  pthread_t thrd;\n  const char *thrdRet;\n\n  if (MHD_NO != MHD_is_feature_supported (MHD_FEATURE_AUTODETECT_BIND_PORT))\n    port = 0;\n  else\n    port = 1480;\n\n  cbc.buf = buf;\n  cbc.size = 2048;\n  cbc.pos = 0;\n  if (pool_count > 0) {\n    d = MHD_start_daemon (type | MHD_USE_ERROR_LOG | MHD_USE_ITC | poll_flag,\n                          port, NULL, NULL, &ahc_echo, \"GET\",\n                          MHD_OPTION_THREAD_POOL_SIZE, pool_count, MHD_OPTION_END);\n\n  } else {\n    d = MHD_start_daemon (type | MHD_USE_ERROR_LOG | MHD_USE_ITC | poll_flag,\n                          port, NULL, NULL, &ahc_echo, \"GET\", MHD_OPTION_END);\n  }\n  if (d == NULL)\n    return 1;\n  if (0 == port)\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (d, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        { MHD_stop_daemon (d); return 32; }\n      port = (int)dinfo->port;\n    }\n\n  c = setupCURL(&cbc);\n\n  if (CURLE_OK != (errornum = curl_easy_perform (c)))\n    {\n      fprintf (stderr,\n               \"curl_easy_perform failed: `%s'\\n\",\n               curl_easy_strerror (errornum));\n      curl_easy_cleanup (c);\n      MHD_stop_daemon (d);\n      return 2;\n    }\n\n  if (cbc.pos != strlen (\"/hello_world\")) {\n    curl_easy_cleanup (c);\n    MHD_stop_daemon (d);\n    return 4;\n  }\n  if (0 != strncmp (\"/hello_world\", cbc.buf, strlen (\"/hello_world\"))) {\n    curl_easy_cleanup (c);\n    MHD_stop_daemon (d);\n    return 8;\n  }\n\n  fd = MHD_quiesce_daemon (d);\n  if (MHD_INVALID_SOCKET == fd)\n    {\n      fprintf (stderr,\n               \"MHD_quiesce_daemon failed.\\n\");\n      curl_easy_cleanup (c);\n      MHD_stop_daemon (d);\n      return 2;\n    }\n  if (0 != pthread_create(&thrd, NULL, &ServeOneRequest, (void*)(intptr_t) fd))\n    {\n      fprintf (stderr, \"pthread_create failed\\n\");\n      curl_easy_cleanup (c);\n      MHD_stop_daemon (d);\n      return 16;\n    }\n\n  cbc.pos = 0;\n  if (CURLE_OK != (errornum = curl_easy_perform (c)))\n    {\n      fprintf (stderr,\n               \"curl_easy_perform failed: `%s'\\n\",\n               curl_easy_strerror (errornum));\n      curl_easy_cleanup (c);\n      MHD_stop_daemon (d);\n      return 2;\n    }\n\n  if (0 != pthread_join(thrd, (void**)&thrdRet))\n    {\n      fprintf (stderr, \"pthread_join failed\\n\");\n      curl_easy_cleanup (c);\n      MHD_stop_daemon (d);\n      return 16;\n    }\n  if (NULL != thrdRet)\n    {\n      fprintf (stderr, \"ServeOneRequest() error: %s\\n\", thrdRet);\n      curl_easy_cleanup (c);\n      MHD_stop_daemon (d);\n      return 16;\n    }\n\n  if (cbc.pos != strlen (\"/hello_world\"))\n    {\n      fprintf(stderr, \"%s\\n\", cbc.buf);\n      curl_easy_cleanup (c);\n      MHD_stop_daemon (d);\n      MHD_socket_close_chk_(fd);\n      return 4;\n    }\n  if (0 != strncmp (\"/hello_world\", cbc.buf, strlen (\"/hello_world\")))\n    {\n      fprintf(stderr, \"%s\\n\", cbc.buf);\n      curl_easy_cleanup (c);\n      MHD_stop_daemon (d);\n      MHD_socket_close_chk_(fd);\n      return 8;\n    }\n\n  /* at this point, the forked server quit, and the new\n   * server has quiesced, so new requests should fail\n   */\n  if (CURLE_OK == (errornum = curl_easy_perform (c)))\n    {\n      fprintf (stderr, \"curl_easy_perform should fail\\n\");\n      curl_easy_cleanup (c);\n      MHD_stop_daemon (d);\n      MHD_socket_close_chk_(fd);\n      return 2;\n    }\n  curl_easy_cleanup (c);\n  MHD_stop_daemon (d);\n  MHD_socket_close_chk_(fd);\n\n  return 0;\n}",
      "lines": 140,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testExternalGet": {
      "start_point": [
        342,
        0
      ],
      "end_point": [
        521,
        1
      ],
      "content": "static int\ntestExternalGet ()\n{\n  struct MHD_Daemon *d;\n  CURL *c;\n  char buf[2048];\n  struct CBC cbc;\n  CURLM *multi;\n  CURLMcode mret;\n  fd_set rs;\n  fd_set ws;\n  fd_set es;\n  MHD_socket maxsock;\n#ifdef MHD_WINSOCK_SOCKETS\n  int maxposixs; /* Max socket number unused on W32 */\n#else  /* MHD_POSIX_SOCKETS */\n#define maxposixs maxsock\n#endif /* MHD_POSIX_SOCKETS */\n  int running;\n  struct CURLMsg *msg;\n  time_t start;\n  struct timeval tv;\n  int i;\n  MHD_socket fd;\n\n  if (MHD_NO != MHD_is_feature_supported (MHD_FEATURE_AUTODETECT_BIND_PORT))\n    port = 0;\n  else\n    port = 1481;\n\n  multi = NULL;\n  cbc.buf = buf;\n  cbc.size = 2048;\n  cbc.pos = 0;\n  d = MHD_start_daemon (MHD_USE_ERROR_LOG,\n                        port,\n                        NULL, NULL,\n                        &ahc_echo, \"GET\",\n                        MHD_OPTION_END);\n  if (d == NULL)\n    return 256;\n  if (0 == port)\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (d, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        { MHD_stop_daemon (d); return 32; }\n      port = (int)dinfo->port;\n    }\n  c = setupCURL(&cbc);\n\n  multi = curl_multi_init ();\n  if (multi == NULL)\n    {\n      curl_easy_cleanup (c);\n      MHD_stop_daemon (d);\n      return 512;\n    }\n  mret = curl_multi_add_handle (multi, c);\n  if (mret != CURLM_OK)\n    {\n      curl_multi_cleanup (multi);\n      curl_easy_cleanup (c);\n      MHD_stop_daemon (d);\n      return 1024;\n    }\n\n  for (i = 0; i < 2; i++)\n    {\n      start = time (NULL);\n      while ( (time (NULL) - start < 5) &&\n              (NULL != multi) )\n        {\n          maxsock = MHD_INVALID_SOCKET;\n          maxposixs = -1;\n          FD_ZERO (&rs);\n          FD_ZERO (&ws);\n          FD_ZERO (&es);\n          curl_multi_perform (multi, &running);\n          mret = curl_multi_fdset (multi, &rs, &ws, &es, &maxposixs);\n          if (mret != CURLM_OK)\n            {\n              curl_multi_remove_handle (multi, c);\n              curl_multi_cleanup (multi);\n              curl_easy_cleanup (c);\n              MHD_stop_daemon (d);\n              return 2048;\n            }\n          if (MHD_YES != MHD_get_fdset (d, &rs, &ws, &es, &maxsock))\n            {\n              curl_multi_remove_handle (multi, c);\n              curl_multi_cleanup (multi);\n              curl_easy_cleanup (c);\n              MHD_stop_daemon (d);\n              return 4096;\n            }\n          tv.tv_sec = 0;\n          tv.tv_usec = 1000;\n          if (-1 == select (maxposixs + 1, &rs, &ws, &es, &tv))\n            {\n#ifdef MHD_POSIX_SOCKETS\n              if (EINTR != errno)\n                abort ();\n#else\n              if (WSAEINVAL != WSAGetLastError() || 0 != rs.fd_count || 0 != ws.fd_count || 0 != es.fd_count)\n                abort ();\n              Sleep (1000);\n#endif\n            }\n          curl_multi_perform (multi, &running);\n          if (0 == running)\n            {\n              msg = curl_multi_info_read (multi, &running);\n              if (NULL == msg)\n                break;\n              if (msg->msg == CURLMSG_DONE)\n                {\n                  if (i == 0 && msg->data.result != CURLE_OK)\n                    printf (\"%s failed at %s:%d: `%s'\\n\",\n                            \"curl_multi_perform\",\n                            __FILE__,\n                            __LINE__,\n                            curl_easy_strerror (msg->data.result));\n                  else if ( (i == 1) &&\n                            (msg->data.result == CURLE_OK) )\n                    printf (\"%s should have failed at %s:%d\\n\",\n                            \"curl_multi_perform\",\n                            __FILE__,\n                            __LINE__);\n                  curl_multi_remove_handle (multi, c);\n                  curl_multi_cleanup (multi);\n                  curl_easy_cleanup (c);\n                  c = NULL;\n                  multi = NULL;\n                }\n            }\n          MHD_run (d);\n        }\n\n      if (0 == i)\n        {\n          /* quiesce the daemon on the 1st iteration, so the 2nd should fail */\n          fd = MHD_quiesce_daemon(d);\n          if (MHD_INVALID_SOCKET == fd)\n            {\n              fprintf (stderr,\n                       \"MHD_quiesce_daemon failed.\\n\");\n              curl_multi_remove_handle (multi, c);\n              curl_multi_cleanup (multi);\n              curl_easy_cleanup (c);\n              MHD_stop_daemon (d);\n              return 2;\n            }\n          c = setupCURL (&cbc);\n          multi = curl_multi_init ();\n          mret = curl_multi_add_handle (multi, c);\n          if (mret != CURLM_OK)\n            {\n              curl_multi_remove_handle (multi, c);\n              curl_multi_cleanup (multi);\n              curl_easy_cleanup (c);\n              MHD_stop_daemon (d);\n              return 32768;\n            }\n        }\n    }\n  if (NULL != multi)\n    {\n      curl_multi_remove_handle (multi, c);\n      curl_easy_cleanup (c);\n      curl_multi_cleanup (multi);\n    }\n  MHD_stop_daemon (d);\n  MHD_socket_close_chk_ (fd);\n  if (cbc.pos != strlen (\"/hello_world\"))\n    return 8192;\n  if (0 != strncmp (\"/hello_world\", cbc.buf, strlen (\"/hello_world\")))\n    return 16384;\n  return 0;\n}",
      "lines": 180,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        524,
        0
      ],
      "end_point": [
        551,
        1
      ],
      "content": "int\nmain (int argc, char *const *argv)\n{\n  unsigned int errorCount = 0;\n  (void)argc; (void)argv; /* Unused. Silent compiler warning. */\n\n  if (0 != curl_global_init (CURL_GLOBAL_WIN32))\n    return 2;\n  errorCount += testGet (MHD_USE_INTERNAL_POLLING_THREAD, 0, 0);\n  errorCount += testGet (MHD_USE_THREAD_PER_CONNECTION | MHD_USE_INTERNAL_POLLING_THREAD, 0, 0);\n  errorCount += testGet (MHD_USE_INTERNAL_POLLING_THREAD, CPU_COUNT, 0);\n  errorCount += testExternalGet ();\n  if (MHD_YES == MHD_is_feature_supported(MHD_FEATURE_POLL))\n    {\n      errorCount += testGet(MHD_USE_INTERNAL_POLLING_THREAD, 0, MHD_USE_POLL);\n      errorCount += testGet (MHD_USE_THREAD_PER_CONNECTION | MHD_USE_INTERNAL_POLLING_THREAD, 0, MHD_USE_POLL);\n      errorCount += testGet (MHD_USE_INTERNAL_POLLING_THREAD, CPU_COUNT, MHD_USE_POLL);\n    }\n  if (MHD_YES == MHD_is_feature_supported(MHD_FEATURE_EPOLL))\n    {\n      errorCount += testGet (MHD_USE_INTERNAL_POLLING_THREAD, 0, MHD_USE_EPOLL);\n      errorCount += testGet (MHD_USE_INTERNAL_POLLING_THREAD, CPU_COUNT, MHD_USE_EPOLL);\n    }\n  if (errorCount != 0)\n    fprintf (stderr, \"Error (code: %u)\\n\", errorCount);\n  curl_global_cleanup ();\n  return errorCount != 0;       /* 0 == pass */\n}",
      "lines": 28,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/testcurl/test_quiesce_stream.c": {
    "http_PanicCallback": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "static void\nhttp_PanicCallback (void *cls,\n                    const char *file,\n                    unsigned int line,\n                    const char *reason)\n{\n  (void)cls;    /* Unused. Silent compiler warning. */\n  fprintf( stderr,\n           \"PANIC: exit process: %s at %s:%u\\n\",\n           reason,\n           file,\n           line);\n  exit (EXIT_FAILURE);\n}",
      "lines": 14,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "resume_connection": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "static void *\nresume_connection (void *arg)\n{\n  struct MHD_Connection *connection = arg;\n\n  /* fprintf (stderr, \"Calling resume\\n\"); */\n  MHD_resume_connection (connection);\n  return NULL;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nresume_connection (void *arg)",
        "*"
      ]
    },
    "suspend_connection": {
      "start_point": [
        71,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "static void\nsuspend_connection (struct MHD_Connection *connection)\n{\n  pthread_t thread_id;\n\n  /* fprintf (stderr, \"Calling suspend\\n\"); */\n  MHD_suspend_connection (connection);\n  int status = pthread_create (&thread_id,\n                               NULL,\n                               &resume_connection,\n                               connection);\n  if (0 != status)\n    {\n      fprintf (stderr,\n               \"Could not create thead\\n\");\n      exit( EXIT_FAILURE );\n    }\n  pthread_detach (thread_id);\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "http_ContentReaderCallback": {
      "start_point": [
        99,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "static ssize_t\nhttp_ContentReaderCallback (void *cls,\n                            uint64_t pos,\n                            char *buf,\n                            size_t max)\n{\n  static const char alphabet[] = \"\\nABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n  struct ContentReaderUserdata *userdata = cls;\n  (void)pos;(void)max;  /* Unused. Silent compiler warning. */\n\n  if( userdata->bytes_written >= 1024)\n    {\n      fprintf( stderr,\n               \"finish: %d\\n\",\n               request_counter);\n      return MHD_CONTENT_READER_END_OF_STREAM;\n    }\n  userdata->bytes_written++;\n  buf[0] = alphabet[userdata->bytes_written % (sizeof(alphabet) - 1)];\n  suspend_connection (userdata->connection);\n\n  return 1;\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "ssize_t"
      ]
    },
    "http_AccessHandlerCallback": {
      "start_point": [
        124,
        0
      ],
      "end_point": [
        170,
        1
      ],
      "content": "static int\nhttp_AccessHandlerCallback (void *cls,\n                            struct MHD_Connection *connection,\n                            const char *url,\n                            const char *method,\n                            const char *version,\n                            const char *upload_data,\n                            size_t *upload_data_size,\n                            void **con_cls )\n{\n  int ret;\n  (void)cls;(void)url;                          /* Unused. Silent compiler warning. */\n  (void)method;(void)version;(void)upload_data; /* Unused. Silent compiler warning. */\n  (void)upload_data_size;                       /* Unused. Silent compiler warning. */\n\n  /* Never respond on first call */\n  if (NULL == *con_cls)\n  {\n    fprintf (stderr,\n             \"start: %d\\n\",\n              ++request_counter);\n\n    struct ContentReaderUserdata *userdata = malloc (sizeof(struct ContentReaderUserdata));\n\n    if (NULL == userdata)\n      return MHD_NO;\n    userdata->bytes_written = 0;\n    userdata->connection = connection;\n    *con_cls = userdata;\n    return MHD_YES;\n  }\n\n  /* Second call: create response */\n  struct MHD_Response *response\n    = MHD_create_response_from_callback (-1,\n                                         32 * 1024,\n                                         &http_ContentReaderCallback,\n                                         *con_cls,\n                                         NULL);\n  ret = MHD_queue_response (connection,\n                            MHD_HTTP_OK,\n                            response);\n  MHD_destroy_response (response);\n\n  suspend_connection (connection);\n  return ret;\n}",
      "lines": 47,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        173,
        0
      ],
      "end_point": [
        236,
        1
      ],
      "content": "int\nmain(void)\n{\n  int port;\n  char command_line[1024];\n\n  if (MHD_NO != MHD_is_feature_supported (MHD_FEATURE_AUTODETECT_BIND_PORT))\n    port = 0;\n  else\n    port = 1470;\n\n  /* Panic callback */\n  MHD_set_panic_func (&http_PanicCallback,\n                      NULL);\n\n  /* Flags */\n  unsigned int daemon_flags\n    = MHD_USE_INTERNAL_POLLING_THREAD\n    | MHD_USE_AUTO\n    | MHD_ALLOW_SUSPEND_RESUME\n    | MHD_USE_ITC;\n\n  /* Create daemon */\n  struct MHD_Daemon *daemon = MHD_start_daemon (daemon_flags,\n                                                port,\n                                                NULL,\n                                                NULL,\n                                                &http_AccessHandlerCallback,\n                                                NULL,\n                                                MHD_OPTION_END);\n  if (NULL == daemon)\n    return 1;\n  if (0 == port)\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (daemon, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        { MHD_stop_daemon (daemon); return 32; }\n      port = (int)dinfo->port;\n    }\n  sprintf(command_line, \"curl -s http://127.0.0.1:%d\", port);\n\n  if (0 != system (command_line))\n    {\n      MHD_stop_daemon (daemon);\n      return 1;\n    }\n  /* wait for a request */\n  while (0 == request_counter)\n    (void)sleep (1);\n\n  fprintf (stderr,\n           \"quiesce\\n\");\n  MHD_quiesce_daemon (daemon);\n\n  /* wait a second */\n  (void)sleep (1);\n\n  fprintf (stderr,\n           \"stopping daemon\\n\");\n  MHD_stop_daemon (daemon);\n\n  return 0;\n}",
      "lines": 64,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/testcurl/test_termination.c": {
    "connection_handler": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        82,
        1
      ],
      "content": "static int\nconnection_handler (void *cls,\n                    struct MHD_Connection *connection,\n                    const char *url,\n                    const char *method,\n                    const char *version,\n                    const char *upload_data, size_t * upload_data_size,\n                    void **ptr)\n{\n  static int i;\n  (void)cls;(void)url;                          /* Unused. Silent compiler warning. */\n  (void)method;(void)version;(void)upload_data; /* Unused. Silent compiler warning. */\n  (void)upload_data_size;                       /* Unused. Silent compiler warning. */\n\n  if (*ptr == NULL)\n    {\n      *ptr = &i;\n      return MHD_YES;\n    }\n\n  if (*upload_data_size != 0)\n    {\n      (*upload_data_size) = 0;\n      return MHD_YES;\n    }\n\n  struct MHD_Response *response =\n    MHD_create_response_from_buffer (strlen (\"Response\"), \"Response\",\n\t\t\t\t     MHD_RESPMEM_PERSISTENT);\n  int ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n  MHD_destroy_response (response);\n\n  return ret;\n}",
      "lines": 34,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "write_data": {
      "start_point": [
        84,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "static size_t\nwrite_data (void *ptr, size_t size, size_t nmemb, void *stream)\n{\n  (void)ptr;(void)stream;       /* Unused. Silent compiler warning. */\n  return size * nmemb;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "main": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        142,
        1
      ],
      "content": "int\nmain (void)\n{\n  struct MHD_Daemon *daemon;\n  int port;\n\n  if (MHD_NO != MHD_is_feature_supported (MHD_FEATURE_AUTODETECT_BIND_PORT))\n    port = 0;\n  else\n    port = 1490;\n\n\n  daemon = MHD_start_daemon (MHD_USE_THREAD_PER_CONNECTION | MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_ERROR_LOG,\n                             port,\n                             NULL,\n                             NULL, connection_handler, NULL, MHD_OPTION_END);\n\n  if (daemon == NULL)\n    {\n      fprintf (stderr, \"Daemon cannot be started!\");\n      exit (1);\n    }\n  if (0 == port)\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (daemon, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        { MHD_stop_daemon (daemon); return 32; }\n      port = (int)dinfo->port;\n    }\n\n  CURL *curl = curl_easy_init ();\n  /* curl_easy_setopt(curl, CURLOPT_POST, 1L); */\n  char url[255];\n  sprintf (url, \"http://127.0.0.1:%d\", port);\n  curl_easy_setopt (curl, CURLOPT_URL, url);\n  curl_easy_setopt (curl, CURLOPT_WRITEFUNCTION, write_data);\n\n  CURLcode success = curl_easy_perform (curl);\n  if (success != 0)\n    {\n      fprintf (stderr, \"CURL Error\");\n      exit (1);\n    }\n  /* CPU used to go crazy here */\n  (void)sleep (1);\n\n  curl_easy_cleanup (curl);\n  MHD_stop_daemon (daemon);\n\n  return 0;\n}",
      "lines": 52,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/testcurl/test_timeout.c": {
    "termination_cb": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        83,
        1
      ],
      "content": "static void \ntermination_cb (void *cls,\n\t\tstruct MHD_Connection *connection,\n\t\tvoid **con_cls,\n\t\tenum MHD_RequestTerminationCode toe)\n{\n  int *test = cls;\n  (void)connection;(void)con_cls;       /* Unused. Silent compiler warning. */\n\n  switch (toe)\n    {\n    case MHD_REQUEST_TERMINATED_COMPLETED_OK :\n      if (test == &withoutTimeout)\n\t{\n\t  withoutTimeout = 0;\n\t}\n      break;\n    case MHD_REQUEST_TERMINATED_WITH_ERROR :\n    case MHD_REQUEST_TERMINATED_READ_ERROR :\n      break;\n    case MHD_REQUEST_TERMINATED_TIMEOUT_REACHED :\n      if (test == &withTimeout)\n\t{\n\t  withTimeout = 0;\n\t}\n      break;\n    case MHD_REQUEST_TERMINATED_DAEMON_SHUTDOWN:\n      break;\n    case MHD_REQUEST_TERMINATED_CLIENT_ABORT:\n      break;\n    }\n}",
      "lines": 32,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "putBuffer": {
      "start_point": [
        86,
        0
      ],
      "end_point": [
        98,
        1
      ],
      "content": "static size_t\nputBuffer (void *stream, size_t size, size_t nmemb, void *ptr)\n{\n  unsigned int *pos = ptr;\n  unsigned int wrt;\n\n  wrt = size * nmemb;\n  if (wrt > 8 - (*pos))\n\twrt = 8 - (*pos);\n  memcpy (stream, &(\"Hello123\"[*pos]), wrt);\n  (*pos) += wrt;\n  return wrt;\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "putBuffer_fail": {
      "start_point": [
        101,
        0
      ],
      "end_point": [
        106,
        1
      ],
      "content": "static size_t\nputBuffer_fail (void *stream, size_t size, size_t nmemb, void *ptr)\n{\n  (void)stream;(void)size;(void)nmemb;(void)ptr;        /* Unused. Silent compiler warning. */\n  return 0;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "copyBuffer": {
      "start_point": [
        109,
        0
      ],
      "end_point": [
        119,
        1
      ],
      "content": "static size_t\ncopyBuffer (void *ptr, size_t size, size_t nmemb, void *ctx)\n{\n  struct CBC *cbc = ctx;\n\n  if (cbc->pos + size * nmemb > cbc->size)\n    return 0;                   /* overflow */\n  memcpy (&cbc->buf[cbc->pos], ptr, size * nmemb);\n  cbc->pos += size * nmemb;\n  return size * nmemb;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "ahc_echo": {
      "start_point": [
        122,
        0
      ],
      "end_point": [
        160,
        1
      ],
      "content": "static int\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data, size_t *upload_data_size,\n          void **unused)\n{\n  int *done = cls;\n  struct MHD_Response *response;\n  int ret;\n  (void)version;(void)unused;   /* Unused. Silent compiler warning. */\n\n  if (0 != strcmp (\"PUT\", method))\n    return MHD_NO;              /* unexpected method */\n  if ((*done) == 0)\n    {\n      if (*upload_data_size != 8)\n        return MHD_YES;         /* not yet ready */\n      if (0 == memcmp (upload_data, \"Hello123\", 8))\n        {\n          *upload_data_size = 0;\n        }\n      else\n        {\n          printf (\"Invalid upload data `%8s'!\\n\", upload_data);\n          return MHD_NO;\n        }\n      *done = 1;\n      return MHD_YES;\n    }\n  response = MHD_create_response_from_buffer (strlen (url),\n\t\t\t\t\t      (void *) url, \n\t\t\t\t\t      MHD_RESPMEM_MUST_COPY);\n  ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n  MHD_destroy_response (response);\n  return ret;\n}",
      "lines": 39,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testWithoutTimeout": {
      "start_point": [
        163,
        0
      ],
      "end_point": [
        236,
        1
      ],
      "content": "static int\ntestWithoutTimeout ()\n{\n  struct MHD_Daemon *d;\n  CURL *c;\n  char buf[2048];\n  struct CBC cbc;\n  unsigned int pos = 0;\n  int done_flag = 0;\n  CURLcode errornum;\n  int port;\n\n  if (MHD_NO != MHD_is_feature_supported (MHD_FEATURE_AUTODETECT_BIND_PORT))\n    port = 0;\n  else\n    {\n      port = 1500;\n      if (oneone)\n        port += 5;\n    }\n\n  cbc.buf = buf;\n  cbc.size = 2048;\n  cbc.pos = 0;\n  d = MHD_start_daemon (MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_ERROR_LOG,\n                        port,\n                        NULL, NULL, &ahc_echo, &done_flag,\n                        MHD_OPTION_CONNECTION_TIMEOUT, 2,\n                        MHD_OPTION_NOTIFY_COMPLETED, &termination_cb, &withTimeout,\n                        MHD_OPTION_END);\n  if (d == NULL)\n    return 1;\n  if (0 == port)\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (d, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        { MHD_stop_daemon (d); return 32; }\n      port = (int)dinfo->port;\n    }\n  c = curl_easy_init ();\n  curl_easy_setopt (c, CURLOPT_URL, \"http://127.0.0.1/hello_world\");\n  curl_easy_setopt (c, CURLOPT_PORT, (long)port);\n  curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n  curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc);\n  curl_easy_setopt (c, CURLOPT_READFUNCTION, &putBuffer);\n  curl_easy_setopt (c, CURLOPT_READDATA, &pos);\n  curl_easy_setopt (c, CURLOPT_UPLOAD, 1L);\n  curl_easy_setopt (c, CURLOPT_INFILESIZE_LARGE, (curl_off_t) 8L);\n  curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n  curl_easy_setopt (c, CURLOPT_TIMEOUT, 150L);\n  if (oneone)\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n  else\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0);\n  curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT, 150L);\n  /* NOTE: use of CONNECTTIMEOUT without also\n   *   setting NOSIGNAL results in really weird\n   *   crashes on my system! */\n  curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n  if (CURLE_OK != (errornum = curl_easy_perform (c)))\n    {\n      curl_easy_cleanup (c);\n      MHD_stop_daemon (d);\n      return 2;\n    }\n  curl_easy_cleanup (c);\n  MHD_stop_daemon (d);\n  if (cbc.pos != strlen (\"/hello_world\"))\n    return 4;\n  if (0 != strncmp (\"/hello_world\", cbc.buf, strlen (\"/hello_world\")))\n    return 8;\n  return 0;\n}",
      "lines": 74,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testWithTimeout": {
      "start_point": [
        238,
        0
      ],
      "end_point": [
        311,
        1
      ],
      "content": "static int\ntestWithTimeout ()\n{\n  struct MHD_Daemon *d;\n  CURL *c;\n  char buf[2048];\n  struct CBC cbc;\n  int done_flag = 0;\n  CURLcode errornum;\n  int port;\n\n  if (MHD_NO != MHD_is_feature_supported (MHD_FEATURE_AUTODETECT_BIND_PORT))\n    port = 0;\n  else\n    {\n      port = 1501;\n      if (oneone)\n        port += 5;\n    }\n\n  cbc.buf = buf;\n  cbc.size = 2048;\n  cbc.pos = 0;\n  d = MHD_start_daemon (MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_ERROR_LOG,\n                        port,\n                        NULL, NULL, &ahc_echo, &done_flag,\n                        MHD_OPTION_CONNECTION_TIMEOUT, 2,\n                        MHD_OPTION_NOTIFY_COMPLETED, &termination_cb, &withoutTimeout,\n                        MHD_OPTION_END);\n  if (d == NULL)\n    return 16;\n  if (0 == port)\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (d, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        { MHD_stop_daemon (d); return 32; }\n      port = (int)dinfo->port;\n    }\n  c = curl_easy_init ();\n  curl_easy_setopt (c, CURLOPT_URL, \"http://127.0.0.1/hello_world\");\n  curl_easy_setopt (c, CURLOPT_PORT, (long)port);\n  curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n  curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc);\n  curl_easy_setopt (c, CURLOPT_READFUNCTION, &putBuffer_fail);\n  curl_easy_setopt (c, CURLOPT_READDATA, &testWithTimeout);\n  curl_easy_setopt (c, CURLOPT_UPLOAD, 1L);\n  curl_easy_setopt (c, CURLOPT_INFILESIZE_LARGE, (curl_off_t) 8L);\n  curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n  curl_easy_setopt (c, CURLOPT_TIMEOUT, 150L);\n  if (oneone)\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n  else\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0);\n  curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT, 150L);\n  /* NOTE: use of CONNECTTIMEOUT without also\n   *   setting NOSIGNAL results in really weird\n   *   crashes on my system! */\n  curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n  if (CURLE_OK != (errornum = curl_easy_perform (c)))\n    {\n      curl_easy_cleanup (c);\n      MHD_stop_daemon (d);\n      if (errornum == CURLE_GOT_NOTHING)\n    \t  /* mhd had the timeout */\n    \t  return 0;\n      else\n    \t  /* curl had the timeout first */\n    \t  return 32;\n    }\n  curl_easy_cleanup (c);\n  MHD_stop_daemon (d);\n  return 64;\n}",
      "lines": 74,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        314,
        0
      ],
      "end_point": [
        335,
        1
      ],
      "content": "int\nmain (int argc, char *const *argv)\n{\n  unsigned int errorCount = 0;\n  (void)argc;   /* Unused. Silent compiler warning. */\n\n  oneone = (NULL != strrchr (argv[0], (int) '/')) ?\n    (NULL != strstr (strrchr (argv[0], (int) '/'), \"11\")) : 0;\n  if (0 != curl_global_init (CURL_GLOBAL_WIN32))\n    return 16;\n  errorCount += testWithoutTimeout ();\n  errorCount += testWithTimeout ();\n  if (errorCount != 0)\n    fprintf (stderr, \n\t     \"Error during test execution (code: %u)\\n\",\n\t     errorCount);\n  curl_global_cleanup ();\n  if ((withTimeout == 0) && (withoutTimeout == 0))\n    return 0;\n  else\n    return errorCount;       /* 0 == pass */\n}",
      "lines": 22,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/testcurl/test_urlparse.c": {
    "copyBuffer": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "static size_t\ncopyBuffer (void *ptr, size_t size, size_t nmemb, void *ctx)\n{\n  struct CBC *cbc = ctx;\n\n  if (cbc->pos + size * nmemb > cbc->size)\n    return 0;                   /* overflow */\n  memcpy (&cbc->buf[cbc->pos], ptr, size * nmemb);\n  cbc->pos += size * nmemb;\n  return size * nmemb;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "test_values": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "static int \ntest_values (void *cls,\n\t     enum MHD_ValueKind kind,\n\t     const char *key,\n\t     const char *value)\n{\n  (void)cls;(void)kind;         /* Unused. Silent compiler warning. */\n  if ( (0 == strcmp (key, \"a\")) &&\n       (0 == strcmp (value, \"b\")) )\n    matches += 1;\n  if ( (0 == strcmp (key, \"c\")) &&\n       (0 == strcmp (value, \"\")) )\n    matches += 2;\n  if ( (0 == strcmp (key, \"d\")) &&\n       (NULL == value) )\n    matches += 4;\n  return MHD_YES;\n}",
      "lines": 18,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "ahc_echo": {
      "start_point": [
        88,
        0
      ],
      "end_point": [
        123,
        1
      ],
      "content": "static int\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data, size_t *upload_data_size,\n          void **unused)\n{\n  static int ptr;\n  const char *me = cls;\n  struct MHD_Response *response;\n  int ret;\n  (void)version;(void)upload_data;(void)upload_data_size;       /* Unused. Silent compiler warning. */\n\n  if (0 != strcmp (me, method))\n    return MHD_NO;              /* unexpected method */\n  if (&ptr != *unused)\n    {\n      *unused = &ptr;\n      return MHD_YES;\n    }\n  MHD_get_connection_values (connection,\n\t\t\t     MHD_GET_ARGUMENT_KIND,\n\t\t\t     &test_values,\n\t\t\t     NULL);\n  *unused = NULL;\n  response = MHD_create_response_from_buffer (strlen (url),\n\t\t\t\t\t      (void *) url,\n\t\t\t\t\t      MHD_RESPMEM_MUST_COPY);\n  ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n  MHD_destroy_response (response);\n  if (ret == MHD_NO)\n    abort ();\n  return ret;\n}",
      "lines": 36,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testInternalGet": {
      "start_point": [
        126,
        0
      ],
      "end_point": [
        194,
        1
      ],
      "content": "static int\ntestInternalGet (int poll_flag)\n{\n  struct MHD_Daemon *d;\n  CURL *c;\n  char buf[2048];\n  struct CBC cbc;\n  CURLcode errornum;\n  int port;\n\n  if (MHD_NO != MHD_is_feature_supported (MHD_FEATURE_AUTODETECT_BIND_PORT))\n    port = 0;\n  else\n    {\n      port = 1510;\n      if (oneone)\n        port += 5;\n    }\n\n  cbc.buf = buf;\n  cbc.size = 2048;\n  cbc.pos = 0;\n  d = MHD_start_daemon (MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_ERROR_LOG  | poll_flag,\n                        port, NULL, NULL, &ahc_echo, \"GET\", MHD_OPTION_END);\n  if (d == NULL)\n    return 1;\n  if (0 == port)\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (d, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        { MHD_stop_daemon (d); return 32; }\n      port = (int)dinfo->port;\n    }\n  c = curl_easy_init ();\n  curl_easy_setopt (c, CURLOPT_URL, \"http://127.0.0.1/hello_world?a=b&c=&d\");\n  curl_easy_setopt (c, CURLOPT_PORT, (long)port);\n  curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n  curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc);\n  curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n  curl_easy_setopt (c, CURLOPT_TIMEOUT, 150L);\n  curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT, 150L);\n  if (oneone)\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n  else\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0);\n  /* NOTE: use of CONNECTTIMEOUT without also\n     setting NOSIGNAL results in really weird\n     crashes on my system!*/\n  curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n  if (CURLE_OK != (errornum = curl_easy_perform (c)))\n    {\n      fprintf (stderr,\n               \"curl_easy_perform failed: `%s'\\n\",\n               curl_easy_strerror (errornum));\n      curl_easy_cleanup (c);\n      MHD_stop_daemon (d);\n      return 2;\n    }\n  curl_easy_cleanup (c);\n  MHD_stop_daemon (d);\n  if (cbc.pos != strlen (\"/hello_world\"))\n    return 4;\n  if (0 != strncmp (\"/hello_world\", cbc.buf, strlen (\"/hello_world\")))\n    return 8;\n  if (matches != 7)\n    return 16;\n  return 0;\n}",
      "lines": 69,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        197,
        0
      ],
      "end_point": [
        212,
        1
      ],
      "content": "int\nmain (int argc, char *const *argv)\n{\n  unsigned int errorCount = 0;\n  (void)argc;   /* Unused. Silent compiler warning. */\n\n  oneone = (NULL != strrchr (argv[0], (int) '/')) ?\n    (NULL != strstr (strrchr (argv[0], (int) '/'), \"11\")) : 0;\n  if (0 != curl_global_init (CURL_GLOBAL_WIN32))\n    return 2;\n  errorCount += testInternalGet (0);\n  if (errorCount != 0)\n    fprintf (stderr, \"Error (code: %u)\\n\", errorCount);\n  curl_global_cleanup ();\n  return errorCount != 0;       /* 0 == pass */\n}",
      "lines": 16,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/testcurl/https/test_empty_response.c": {
    "ahc_echo": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "static int\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data, size_t *upload_data_size,\n          void **unused)\n{\n  struct MHD_Response *response;\n  int ret;\n  (void)cls;(void)url;(void)method;(void)version;               /* Unused. Silent compiler warning. */\n  (void)upload_data;(void)upload_data_size;(void)unused;        /* Unused. Silent compiler warning. */\n\n  response = MHD_create_response_from_buffer (0, NULL,\n\t\t\t\t\t      MHD_RESPMEM_PERSISTENT);\n  ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n  MHD_destroy_response (response);\n  return ret;\n}",
      "lines": 20,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testInternalSelectGet": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        215,
        1
      ],
      "content": "static int\ntestInternalSelectGet ()\n{\n  struct MHD_Daemon *d;\n  CURL *c;\n  char buf[2048];\n  struct CBC cbc;\n  CURLM *multi;\n  CURLMcode mret;\n  fd_set rs;\n  fd_set ws;\n  fd_set es;\n  int maxposixs; /* Max socket number unused on W32 */\n  int running;\n  struct CURLMsg *msg;\n  time_t start;\n  struct timeval tv;\n  int port;\n\n  if (MHD_NO != MHD_is_feature_supported (MHD_FEATURE_AUTODETECT_BIND_PORT))\n    port = 0;\n  else\n    port = 3000;\n\n  multi = NULL;\n  cbc.buf = buf;\n  cbc.size = 2048;\n  cbc.pos = 0;\n  d = MHD_start_daemon (MHD_USE_ERROR_LOG | MHD_USE_TLS | MHD_USE_INTERNAL_POLLING_THREAD,\n                        port, NULL, NULL, &ahc_echo, \"GET\",\n                        MHD_OPTION_HTTPS_MEM_KEY, srv_key_pem,\n                        MHD_OPTION_HTTPS_MEM_CERT, srv_self_signed_cert_pem,\n\t\t\tMHD_OPTION_END);\n  if (d == NULL)\n    return 256;\n\n  if (0 == port)\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (d, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        { MHD_stop_daemon (d); return 32; }\n      port = (int)dinfo->port;\n    }\n  char *aes256_sha = \"AES256-SHA\";\n  if (curl_uses_nss_ssl() == 0)\n    {\n      aes256_sha = \"rsa_aes_256_sha\";\n    }\n\n  c = curl_easy_init ();\n  curl_easy_setopt (c, CURLOPT_URL, \"https://127.0.0.1/hello_world\");\n  curl_easy_setopt (c, CURLOPT_PORT, (long)port);\n  curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n  curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc);\n  /* TLS options */\n  curl_easy_setopt (c, CURLOPT_SSLVERSION, CURL_SSLVERSION_TLSv1);\n  curl_easy_setopt (c, CURLOPT_SSL_CIPHER_LIST, aes256_sha);\n  curl_easy_setopt (c, CURLOPT_SSL_VERIFYPEER, 0);\n  curl_easy_setopt (c, CURLOPT_SSL_VERIFYHOST, 0);\n  curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n  if (oneone)\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n  else\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0);\n  curl_easy_setopt (c, CURLOPT_TIMEOUT, 150L);\n  curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT, 150L);\n  /* NOTE: use of CONNECTTIMEOUT without also\n     setting NOSIGNAL results in really weird\n     crashes on my system! */\n  curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n\n\n  multi = curl_multi_init ();\n  if (multi == NULL)\n    {\n      curl_easy_cleanup (c);\n      MHD_stop_daemon (d);\n      return 512;\n    }\n  mret = curl_multi_add_handle (multi, c);\n  if (mret != CURLM_OK)\n    {\n      curl_multi_cleanup (multi);\n      curl_easy_cleanup (c);\n      MHD_stop_daemon (d);\n      return 1024;\n    }\n  start = time (NULL);\n  while ((time (NULL) - start < 5) && (multi != NULL))\n    {\n      maxposixs = -1;\n      FD_ZERO (&rs);\n      FD_ZERO (&ws);\n      FD_ZERO (&es);\n      mret = curl_multi_fdset (multi, &rs, &ws, &es, &maxposixs);\n      if (mret != CURLM_OK)\n        {\n          curl_multi_remove_handle (multi, c);\n          curl_multi_cleanup (multi);\n          curl_easy_cleanup (c);\n          MHD_stop_daemon (d);\n          return 2048;\n        }\n      tv.tv_sec = 0;\n      tv.tv_usec = 1000;\n      if (-1 != maxposixs)\n        {\n          if (-1 == select (maxposixs + 1, &rs, &ws, &es, &tv))\n            {\n#ifdef MHD_POSIX_SOCKETS\n              if (EINTR != errno)\n                abort ();\n#else\n              if (WSAEINVAL != WSAGetLastError() || 0 != rs.fd_count || 0 != ws.fd_count || 0 != es.fd_count)\n                abort ();\n              Sleep (1000);\n#endif\n            }\n        }\n      else\n        (void)sleep (1);\n      curl_multi_perform (multi, &running);\n      if (running == 0)\n        {\n          msg = curl_multi_info_read (multi, &running);\n          if (msg == NULL)\n            break;\n          if (msg->msg == CURLMSG_DONE)\n            {\n              if (msg->data.result != CURLE_OK)\n                printf (\"%s failed at %s:%d: `%s'\\n\",\n                        \"curl_multi_perform\",\n                        __FILE__,\n                        __LINE__, curl_easy_strerror (msg->data.result));\n              curl_multi_remove_handle (multi, c);\n              curl_multi_cleanup (multi);\n              curl_easy_cleanup (c);\n              c = NULL;\n              multi = NULL;\n            }\n        }\n    }\n  if (multi != NULL)\n    {\n      curl_multi_remove_handle (multi, c);\n      curl_easy_cleanup (c);\n      curl_multi_cleanup (multi);\n    }\n  MHD_stop_daemon (d);\n  if (cbc.pos != 0)\n    return 8192;\n  return 0;\n}",
      "lines": 154,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        218,
        0
      ],
      "end_point": [
        236,
        1
      ],
      "content": "int\nmain (int argc, char *const *argv)\n{\n  unsigned int errorCount = 0;\n  (void)argc;   /* Unused. Silent compiler warning. */\n\n  if (!testsuite_curl_global_init ())\n    return 99;\n  if (NULL == curl_version_info (CURLVERSION_NOW)->ssl_version)\n    {\n      fprintf (stderr, \"Curl does not support SSL.  Cannot run the test.\\n\");\n      curl_global_cleanup ();\n      return 77;\n    }\n  if (0 != (errorCount = testInternalSelectGet ()))\n    fprintf (stderr, \"Failed test: %s, error: %u.\\n\", argv[0], errorCount);\n  curl_global_cleanup ();\n  return errorCount != 0 ? 1 : 0;\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/testcurl/https/test_https_get.c": {
    "test_secure_get": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "static int\ntest_secure_get (FILE * test_fd,\n\t\t const char *cipher_suite,\n\t\t int proto_version)\n{\n  int ret;\n  struct MHD_Daemon *d;\n  int port;\n\n  if (MHD_NO != MHD_is_feature_supported (MHD_FEATURE_AUTODETECT_BIND_PORT))\n    port = 0;\n  else\n    port = 3041;\n\n  d = MHD_start_daemon (MHD_USE_THREAD_PER_CONNECTION | MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_TLS |\n                        MHD_USE_ERROR_LOG, port,\n                        NULL, NULL, &http_ahc, NULL,\n                        MHD_OPTION_HTTPS_MEM_KEY, srv_signed_key_pem,\n                        MHD_OPTION_HTTPS_MEM_CERT, srv_signed_cert_pem,\n                        MHD_OPTION_END);\n\n  if (d == NULL)\n    {\n      fprintf (stderr, MHD_E_SERVER_INIT);\n      return -1;\n    }\n  if (0 == port)\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (d, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        { MHD_stop_daemon (d); return -1; }\n      port = (int)dinfo->port;\n    }\n\n  ret = test_https_transfer (test_fd, port, cipher_suite, proto_version);\n\n  MHD_stop_daemon (d);\n  return ret;\n}",
      "lines": 40,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        82,
        0
      ],
      "end_point": [
        116,
        1
      ],
      "content": "int\nmain (int argc, char *const *argv)\n{\n  unsigned int errorCount = 0;\n  const char *aes256_sha_tlsv1   = \"AES256-SHA\";\n  (void)argc;   /* Unused. Silent compiler warning. */\n\n#ifdef MHD_HTTPS_REQUIRE_GRYPT\n  gcry_control (GCRYCTL_ENABLE_QUICK_RANDOM, 0);\n#ifdef GCRYCTL_INITIALIZATION_FINISHED\n  gcry_control (GCRYCTL_INITIALIZATION_FINISHED, 0);\n#endif\n#endif /* MHD_HTTPS_REQUIRE_GRYPT */\n  if (!testsuite_curl_global_init ())\n    return 99;\n  if (NULL == curl_version_info (CURLVERSION_NOW)->ssl_version)\n    {\n      fprintf (stderr, \"Curl does not support SSL.  Cannot run the test.\\n\");\n      curl_global_cleanup ();\n      return 77;\n    }\n\n  if (curl_uses_nss_ssl() == 0)\n    {\n      aes256_sha_tlsv1 = \"rsa_aes_256_sha\";\n    }\n\n  errorCount +=\n    test_secure_get (NULL, aes256_sha_tlsv1, CURL_SSLVERSION_TLSv1);\n  print_test_result (errorCount, argv[0]);\n\n  curl_global_cleanup ();\n\n  return errorCount != 0 ? 1 : 0;\n}",
      "lines": 35,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/testcurl/https/test_https_get_parallel.c": {
    "https_transfer_thread_adapter": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        69,
        1
      ],
      "content": "static void *\nhttps_transfer_thread_adapter (void *args)\n{\n  static int nonnull;\n  struct https_test_data *cargs = args;\n  int ret;\n\n  /* time spread incomming requests */\n  usleep ((useconds_t) 10.0 * ((double) rand ()) / ((double) RAND_MAX));\n  ret = test_https_transfer (NULL, cargs->port,\n                             cargs->cipher_suite, cargs->proto_version);\n  if (ret == 0)\n    return NULL;\n  return &nonnull;\n}",
      "lines": 15,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nhttps_transfer_thread_adapter (void *args)",
        "*"
      ]
    },
    "test_single_client": {
      "start_point": [
        79,
        0
      ],
      "end_point": [
        92,
        1
      ],
      "content": "static int\ntest_single_client (void *cls, int port, const char *cipher_suite,\n                    int curl_proto_version)\n{\n  void *client_thread_ret;\n  struct https_test_data client_args =\n    { NULL, port, cipher_suite, curl_proto_version };\n  (void)cls;    /* Unused. Silent compiler warning. */\n\n  client_thread_ret = https_transfer_thread_adapter (&client_args);\n  if (client_thread_ret != NULL)\n    return -1;\n  return 0;\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "test_parallel_clients": {
      "start_point": [
        102,
        0
      ],
      "end_point": [
        133,
        1
      ],
      "content": "static int\ntest_parallel_clients (void * cls, int port, const char *cipher_suite,\n                       int curl_proto_version)\n{\n  int i;\n  int client_count = (CPU_COUNT - 1);\n  void *client_thread_ret;\n  pthread_t client_arr[client_count];\n  struct https_test_data client_args =\n    { NULL, port, cipher_suite, curl_proto_version };\n  (void)cls;    /* Unused. Silent compiler warning. */\n\n  for (i = 0; i < client_count; ++i)\n    {\n      if (pthread_create (&client_arr[i], NULL,\n                          &https_transfer_thread_adapter, &client_args) != 0)\n        {\n          fprintf (stderr, \"Error: failed to spawn test client threads.\\n\");\n          return -1;\n        }\n    }\n\n  /* check all client requests fulfilled correctly */\n  for (i = 0; i < client_count; ++i)\n    {\n      if ((pthread_join (client_arr[i], &client_thread_ret) != 0) ||\n          (client_thread_ret != NULL))\n        return -1;\n    }\n\n  return 0;\n}",
      "lines": 32,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        136,
        0
      ],
      "end_point": [
        199,
        1
      ],
      "content": "int\nmain (int argc, char *const *argv)\n{  \n  unsigned int errorCount = 0;\n  const char *aes256_sha = \"AES256-SHA\";\n  int port;\n  (void)argc;   /* Unused. Silent compiler warning. */\n\n  if (MHD_NO != MHD_is_feature_supported (MHD_FEATURE_AUTODETECT_BIND_PORT))\n    port = 0;\n  else\n    port = 3020;\n\n  /* initialize random seed used by curl clients */\n  unsigned int iseed = (unsigned int) time (NULL);\n  srand (iseed);\n  if (!testsuite_curl_global_init ())\n    return 99;\n\n  if (NULL == curl_version_info (CURLVERSION_NOW)->ssl_version)\n    {\n      fprintf (stderr, \"Curl does not support SSL.  Cannot run the test.\\n\");\n      return 77;\n    }\n  if (curl_uses_nss_ssl() == 0)\n    aes256_sha = \"rsa_aes_256_sha\";\n#ifdef EPOLL_SUPPORT\n  errorCount +=\n    test_wrap (\"single threaded daemon, single client, epoll\", &test_single_client,\n               NULL, port,\n               MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_TLS | MHD_USE_ERROR_LOG | MHD_USE_EPOLL,\n               aes256_sha, CURL_SSLVERSION_TLSv1, MHD_OPTION_HTTPS_MEM_KEY,\n               srv_key_pem, MHD_OPTION_HTTPS_MEM_CERT,\n               srv_self_signed_cert_pem, MHD_OPTION_END);\n#endif\n  errorCount +=\n    test_wrap (\"single threaded daemon, single client\", &test_single_client,\n               NULL, port,\n               MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_TLS | MHD_USE_ERROR_LOG,\n               aes256_sha, CURL_SSLVERSION_TLSv1, MHD_OPTION_HTTPS_MEM_KEY,\n               srv_key_pem, MHD_OPTION_HTTPS_MEM_CERT,\n               srv_self_signed_cert_pem, MHD_OPTION_END);\n#ifdef EPOLL_SUPPORT\n  errorCount +=\n    test_wrap (\"single threaded daemon, parallel clients, epoll\",\n               &test_parallel_clients, NULL, port,\n               MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_TLS | MHD_USE_ERROR_LOG | MHD_USE_EPOLL,\n               aes256_sha, CURL_SSLVERSION_TLSv1, MHD_OPTION_HTTPS_MEM_KEY,\n               srv_key_pem, MHD_OPTION_HTTPS_MEM_CERT,\n               srv_self_signed_cert_pem, MHD_OPTION_END);\n#endif\n  errorCount +=\n    test_wrap (\"single threaded daemon, parallel clients\",\n               &test_parallel_clients, NULL, port,\n               MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_TLS | MHD_USE_ERROR_LOG,\n               aes256_sha, CURL_SSLVERSION_TLSv1, MHD_OPTION_HTTPS_MEM_KEY,\n               srv_key_pem, MHD_OPTION_HTTPS_MEM_CERT,\n               srv_self_signed_cert_pem, MHD_OPTION_END);\n\n  curl_global_cleanup ();\n  if (errorCount != 0)\n    fprintf (stderr, \"Failed test: %s, error: %u.\\n\", argv[0], errorCount);\n  return errorCount != 0 ? 1 : 0;\n}",
      "lines": 64,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/testcurl/https/test_https_get_parallel_threads.c": {
    "https_transfer_thread_adapter": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "static void *\nhttps_transfer_thread_adapter (void *args)\n{\n  static int nonnull;\n  struct https_test_data *cargs = args;\n  int ret;\n\n  /* time spread incomming requests */\n  usleep ((useconds_t) 10.0 * ((double) rand ()) / ((double) RAND_MAX));\n  ret = test_https_transfer (cargs->cls, cargs->port,\n                             cargs->cipher_suite, cargs->proto_version);\n  if (ret == 0)\n    return NULL;\n  return &nonnull;\n}",
      "lines": 15,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nhttps_transfer_thread_adapter (void *args)",
        "*"
      ]
    },
    "test_single_client": {
      "start_point": [
        79,
        0
      ],
      "end_point": [
        92,
        1
      ],
      "content": "static int\ntest_single_client (void *cls, int port, const char *cipher_suite,\n                    int curl_proto_version)\n{\n  void *client_thread_ret;\n  struct https_test_data client_args =\n    { NULL, port, cipher_suite, curl_proto_version };\n  (void)cls;    /* Unused. Silent compiler warning. */\n\n  client_thread_ret = https_transfer_thread_adapter (&client_args);\n  if (client_thread_ret != NULL)\n    return -1;\n  return 0;\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "test_parallel_clients": {
      "start_point": [
        102,
        0
      ],
      "end_point": [
        134,
        1
      ],
      "content": "static int\ntest_parallel_clients (void *cls, int port, const char *cipher_suite,\n                       int curl_proto_version)\n{\n  int i;\n  int client_count = (CPU_COUNT - 1);\n  void *client_thread_ret;\n  pthread_t client_arr[client_count];\n  struct https_test_data client_args =\n    { NULL, port, cipher_suite, curl_proto_version };\n  (void)cls;    /* Unused. Silent compiler warning. */\n\n  for (i = 0; i < client_count; ++i)\n    {\n      if (pthread_create (&client_arr[i], NULL,\n                          &https_transfer_thread_adapter, &client_args) != 0)\n        {\n          fprintf (stderr, \"Error: failed to spawn test client threads.\\n\");\n\n          return -1;\n        }\n    }\n\n  /* check all client requests fulfilled correctly */\n  for (i = 0; i < client_count; ++i)\n    {\n      if ((pthread_join (client_arr[i], &client_thread_ret) != 0) ||\n          (client_thread_ret != NULL))\n        return -1;\n    }\n\n  return 0;\n}",
      "lines": 33,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        137,
        0
      ],
      "end_point": [
        202,
        1
      ],
      "content": "int\nmain (int argc, char *const *argv)\n{\n  unsigned int errorCount = 0;\n  const char *ssl_version;\n  int port;\n  (void)argc;   /* Unused. Silent compiler warning. */\n\n  if (MHD_NO != MHD_is_feature_supported (MHD_FEATURE_AUTODETECT_BIND_PORT))\n    port = 0;\n  else\n    port = 3010;\n\n  /* initialize random seed used by curl clients */\n  unsigned int iseed = (unsigned int) time (NULL);\n\n#ifdef MHD_HTTPS_REQUIRE_GRYPT\n#ifdef GCRYCTL_INITIALIZATION_FINISHED\n  gcry_control (GCRYCTL_INITIALIZATION_FINISHED, 0);\n#endif\n#endif /* MHD_HTTPS_REQUIRE_GRYPT */\n  srand (iseed);\n  if (!testsuite_curl_global_init ())\n    return 99;\n  ssl_version = curl_version_info (CURLVERSION_NOW)->ssl_version;\n  if (NULL == ssl_version)\n    {\n      fprintf (stderr, \"Curl does not support SSL.  Cannot run the test.\\n\");\n      curl_global_cleanup ();\n      return 77;\n    }\n  if (0 != strncmp (ssl_version, \"GnuTLS\", 6))\n    {\n      fprintf (stderr, \"This test can be run only with libcurl-gnutls.\\n\");\n      curl_global_cleanup ();\n      return 77;\n    }\n\n  char *aes256_sha = \"AES256-SHA\";\n  if (curl_uses_nss_ssl() == 0)\n    {\n      aes256_sha = \"rsa_aes_256_sha\";\n    }\n\n  errorCount +=\n    test_wrap (\"multi threaded daemon, single client\", &test_single_client,\n               NULL, port,\n               MHD_USE_TLS | MHD_USE_ERROR_LOG | MHD_USE_THREAD_PER_CONNECTION | MHD_USE_INTERNAL_POLLING_THREAD,\n               aes256_sha, CURL_SSLVERSION_TLSv1, MHD_OPTION_HTTPS_MEM_KEY,\n               srv_key_pem, MHD_OPTION_HTTPS_MEM_CERT,\n               srv_self_signed_cert_pem, MHD_OPTION_END);\n\n  errorCount +=\n    test_wrap (\"multi threaded daemon, parallel client\",\n               &test_parallel_clients, NULL, port,\n               MHD_USE_TLS | MHD_USE_ERROR_LOG | MHD_USE_THREAD_PER_CONNECTION | MHD_USE_INTERNAL_POLLING_THREAD,\n               aes256_sha, CURL_SSLVERSION_TLSv1, MHD_OPTION_HTTPS_MEM_KEY,\n               srv_key_pem, MHD_OPTION_HTTPS_MEM_CERT,\n               srv_self_signed_cert_pem, MHD_OPTION_END);\n\n  if (errorCount != 0)\n    fprintf (stderr, \"Failed test: %s, error: %u.\\n\", argv[0], errorCount);\n\n  curl_global_cleanup ();\n  return errorCount != 0 ? 1 : 0;\n}",
      "lines": 66,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/testcurl/https/test_https_get_select.c": {
    "ahc_echo": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "static int\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data, size_t *upload_data_size,\n          void **unused)\n{\n  static int ptr;\n  const char *me = cls;\n  struct MHD_Response *response;\n  int ret;\n  (void)version;(void)upload_data;(void)upload_data_size;       /* Unused. Silent compiler warning. */\n\n  if (0 != strcmp (me, method))\n    return MHD_NO;              /* unexpected method */\n  if (&ptr != *unused)\n    {\n      *unused = &ptr;\n      return MHD_YES;\n    }\n  *unused = NULL;\n  response = MHD_create_response_from_buffer (strlen (url),\n\t\t\t\t\t      (void *) url,\n\t\t\t\t\t      MHD_RESPMEM_MUST_COPY);\n  ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n  MHD_destroy_response (response);\n  if (ret == MHD_NO)\n    abort ();\n  return ret;\n}",
      "lines": 32,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testExternalGet": {
      "start_point": [
        75,
        0
      ],
      "end_point": [
        243,
        1
      ],
      "content": "static int\ntestExternalGet (int flags)\n{\n  struct MHD_Daemon *d;\n  CURL *c;\n  char buf[2048];\n  struct CBC cbc;\n  CURLM *multi;\n  CURLMcode mret;\n  fd_set rs;\n  fd_set ws;\n  fd_set es;\n  MHD_socket maxsock;\n#ifdef MHD_WINSOCK_SOCKETS\n  int maxposixs; /* Max socket number unused on W32 */\n#else  /* MHD_POSIX_SOCKETS */\n#define maxposixs maxsock\n#endif /* MHD_POSIX_SOCKETS */\n  int running;\n  struct CURLMsg *msg;\n  time_t start;\n  struct timeval tv;\n  const char *aes256_sha = \"AES256-SHA\";\n  int port;\n\n  if (MHD_NO != MHD_is_feature_supported (MHD_FEATURE_AUTODETECT_BIND_PORT))\n    port = 0;\n  else\n    port = 3030;\n\n  multi = NULL;\n  cbc.buf = buf;\n  cbc.size = 2048;\n  cbc.pos = 0;\n  d = MHD_start_daemon (MHD_USE_ERROR_LOG | MHD_USE_TLS | flags,\n                        port, NULL, NULL, &ahc_echo, \"GET\",\n                        MHD_OPTION_HTTPS_MEM_KEY, srv_key_pem,\n                        MHD_OPTION_HTTPS_MEM_CERT, srv_self_signed_cert_pem,\n\t\t\tMHD_OPTION_END);\n  if (d == NULL)\n    return 256;\n  if (0 == port)\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (d, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        { MHD_stop_daemon (d); return 32; }\n      port = (int)dinfo->port;\n    }\n\n  if (curl_uses_nss_ssl() == 0)\n    aes256_sha = \"rsa_aes_256_sha\";\n\n  c = curl_easy_init ();\n  curl_easy_setopt (c, CURLOPT_URL, \"https://127.0.0.1/hello_world\");\n  curl_easy_setopt (c, CURLOPT_PORT, (long)port);\n  curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n  curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc);\n  /* TLS options */\n  curl_easy_setopt (c, CURLOPT_SSLVERSION, CURL_SSLVERSION_TLSv1);\n  curl_easy_setopt (c, CURLOPT_SSL_CIPHER_LIST, aes256_sha);\n  curl_easy_setopt (c, CURLOPT_SSL_VERIFYPEER, 0);\n  curl_easy_setopt (c, CURLOPT_SSL_VERIFYHOST, 0);\n  curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n  if (oneone)\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n  else\n    curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0);\n  curl_easy_setopt (c, CURLOPT_TIMEOUT, 150L);\n  curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT, 150L);\n  /* NOTE: use of CONNECTTIMEOUT without also\n     setting NOSIGNAL results in really weird\n     crashes on my system! */\n  curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n\n\n  multi = curl_multi_init ();\n  if (multi == NULL)\n    {\n      curl_easy_cleanup (c);\n      MHD_stop_daemon (d);\n      return 512;\n    }\n  mret = curl_multi_add_handle (multi, c);\n  if (mret != CURLM_OK)\n    {\n      curl_multi_cleanup (multi);\n      curl_easy_cleanup (c);\n      MHD_stop_daemon (d);\n      return 1024;\n    }\n  start = time (NULL);\n  while ((time (NULL) - start < 5) && (multi != NULL))\n    {\n      maxsock = MHD_INVALID_SOCKET;\n      maxposixs = -1;\n      FD_ZERO (&rs);\n      FD_ZERO (&ws);\n      FD_ZERO (&es);\n      mret = curl_multi_fdset (multi, &rs, &ws, &es, &maxposixs);\n      if (mret != CURLM_OK)\n        {\n          curl_multi_remove_handle (multi, c);\n          curl_multi_cleanup (multi);\n          curl_easy_cleanup (c);\n          MHD_stop_daemon (d);\n          return 2048;\n        }\n      if (MHD_YES != MHD_get_fdset (d, &rs, &ws, &es, &maxsock))\n        {\n          curl_multi_remove_handle (multi, c);\n          curl_multi_cleanup (multi);\n          curl_easy_cleanup (c);\n          MHD_stop_daemon (d);\n          return 4096;\n        }\n      tv.tv_sec = 0;\n      tv.tv_usec = 1000;\n      if (-1 != maxposixs)\n        {\n          if (-1 == select (maxposixs + 1, &rs, &ws, &es, &tv))\n            {\n#ifdef MHD_POSIX_SOCKETS\n              if (EINTR != errno)\n                abort ();\n#else\n              if (WSAEINVAL != WSAGetLastError() || 0 != rs.fd_count || 0 != ws.fd_count || 0 != es.fd_count)\n                abort ();\n              Sleep (1000);\n#endif\n            }\n        }\n      else\n        (void)sleep (1);\n      curl_multi_perform (multi, &running);\n      if (running == 0)\n        {\n          msg = curl_multi_info_read (multi, &running);\n          if (msg == NULL)\n            break;\n          if (msg->msg == CURLMSG_DONE)\n            {\n              if (msg->data.result != CURLE_OK)\n                printf (\"%s failed at %s:%d: `%s'\\n\",\n                        \"curl_multi_perform\",\n                        __FILE__,\n                        __LINE__, curl_easy_strerror (msg->data.result));\n              curl_multi_remove_handle (multi, c);\n              curl_multi_cleanup (multi);\n              curl_easy_cleanup (c);\n              c = NULL;\n              multi = NULL;\n            }\n        }\n      MHD_run (d);\n    }\n  if (multi != NULL)\n    {\n      curl_multi_remove_handle (multi, c);\n      curl_easy_cleanup (c);\n      curl_multi_cleanup (multi);\n    }\n  MHD_stop_daemon (d);\n  if (cbc.pos != strlen (\"/hello_world\"))\n    return 8192;\n  if (0 != strncmp (\"/hello_world\", cbc.buf, strlen (\"/hello_world\")))\n    return 16384;\n  return 0;\n}",
      "lines": 169,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        246,
        0
      ],
      "end_point": [
        269,
        1
      ],
      "content": "int\nmain (int argc, char *const *argv)\n{\n  unsigned int errorCount = 0;\n  (void)argc;   /* Unused. Silent compiler warning. */\n\n  if (!testsuite_curl_global_init ())\n    return 99;\n  if (NULL == curl_version_info (CURLVERSION_NOW)->ssl_version)\n    {\n      fprintf (stderr, \"Curl does not support SSL.  Cannot run the test.\\n\");\n      curl_global_cleanup ();\n      return 77;\n    }\n\n#ifdef EPOLL_SUPPORT\n  errorCount += testExternalGet (MHD_USE_EPOLL);\n#endif\n  errorCount += testExternalGet (0);\n  curl_global_cleanup ();\n  if (errorCount != 0)\n    fprintf (stderr, \"Failed test: %s, error: %u.\\n\", argv[0], errorCount);\n  return errorCount != 0 ? 1 : 0;\n}",
      "lines": 24,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/testcurl/https/test_https_multi_daemon.c": {
    "test_concurent_daemon_pair": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "static int\ntest_concurent_daemon_pair (void *cls,\n\t\t\t    const char *cipher_suite,\n                            int proto_version)\n{\n  int ret;\n  struct MHD_Daemon *d1;\n  struct MHD_Daemon *d2;\n  int port1, port2;\n  (void)cls;    /* Unused. Silent compiler warning. */\n\n\n  if (MHD_NO != MHD_is_feature_supported (MHD_FEATURE_AUTODETECT_BIND_PORT))\n    port1 = port2 = 0;\n  else\n    {\n      port1 = 3050;\n      port2 = 3051;\n    }\n\n  d1 = MHD_start_daemon (MHD_USE_THREAD_PER_CONNECTION | MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_TLS |\n                         MHD_USE_ERROR_LOG, port1,\n                         NULL, NULL, &http_ahc, NULL,\n                         MHD_OPTION_HTTPS_MEM_KEY, srv_key_pem,\n                         MHD_OPTION_HTTPS_MEM_CERT, srv_self_signed_cert_pem,\n                         MHD_OPTION_END);\n\n  if (d1 == NULL)\n    {\n      fprintf (stderr, MHD_E_SERVER_INIT);\n      return -1;\n    }\n  if (0 == port1)\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (d1, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        { MHD_stop_daemon (d1); return -1; }\n      port1 = (int)dinfo->port;\n    }\n\n  d2 = MHD_start_daemon (MHD_USE_THREAD_PER_CONNECTION | MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_TLS |\n                         MHD_USE_ERROR_LOG, port2,\n                         NULL, NULL, &http_ahc, NULL,\n                         MHD_OPTION_HTTPS_MEM_KEY, srv_key_pem,\n                         MHD_OPTION_HTTPS_MEM_CERT, srv_self_signed_cert_pem,\n                         MHD_OPTION_END);\n\n  if (d2 == NULL)\n    {\n      MHD_stop_daemon (d1);\n      fprintf (stderr, MHD_E_SERVER_INIT);\n      return -1;\n    }\n  if (0 == port2)\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (d2, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        {\n          MHD_stop_daemon (d1);\n          MHD_stop_daemon (d2);\n          return -1;\n        }\n      port2 = (int)dinfo->port;\n    }\n\n  ret =\n    test_daemon_get (NULL, cipher_suite, proto_version, port1, 0);\n  ret +=\n    test_daemon_get (NULL, cipher_suite, proto_version,\n                     port2, 0);\n\n  MHD_stop_daemon (d2);\n  ret +=\n    test_daemon_get (NULL, cipher_suite, proto_version, port1, 0);\n  MHD_stop_daemon (d1);\n  return ret;\n}",
      "lines": 79,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        124,
        0
      ],
      "end_point": [
        170,
        1
      ],
      "content": "int\nmain (int argc, char *const *argv)\n{\n  unsigned int errorCount = 0;\n  FILE *cert;\n  const char *aes256_sha = \"AES256-SHA\";\n  (void)argc; (void)argv;       /* Unused. Silent compiler warning. */\n\n#ifdef MHD_HTTPS_REQUIRE_GRYPT\n  gcry_control (GCRYCTL_ENABLE_QUICK_RANDOM, 0);\n#ifdef GCRYCTL_INITIALIZATION_FINISHED\n  gcry_control (GCRYCTL_INITIALIZATION_FINISHED, 0);\n#endif\n#endif /* MHD_HTTPS_REQUIRE_GRYPT */\n  if (!testsuite_curl_global_init ())\n    return 99;\n  if (NULL == curl_version_info (CURLVERSION_NOW)->ssl_version)\n    {\n      fprintf (stderr, \"Curl does not support SSL.  Cannot run the test.\\n\");\n      curl_global_cleanup ();\n      return 77;\n    }\n  if ((cert = setup_ca_cert ()) == NULL)\n    {\n      fprintf (stderr, MHD_E_TEST_FILE_CREAT);\n      curl_global_cleanup ();\n      return 99;\n    }\n\n  if (curl_uses_nss_ssl() == 0)\n    {\n      aes256_sha = \"rsa_aes_256_sha\";\n    }\n\n  errorCount +=\n    test_concurent_daemon_pair (NULL, aes256_sha, CURL_SSLVERSION_TLSv1);\n\n  print_test_result (errorCount, \"concurent_daemon_pair\");\n\n  curl_global_cleanup ();\n  fclose (cert);\n  if (0 != remove (ca_cert_file_name))\n    fprintf (stderr,\n\t     \"Failed to remove `%s'\\n\",\n\t     ca_cert_file_name);\n  return errorCount != 0 ? 1 : 0;\n}",
      "lines": 47,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/testcurl/https/test_https_session_info.c": {
    "query_session_ahc": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "static int\nquery_session_ahc (void *cls, struct MHD_Connection *connection,\n                   const char *url, const char *method,\n                   const char *version, const char *upload_data,\n                   size_t *upload_data_size, void **ptr)\n{\n  struct MHD_Response *response;\n  int ret;\n  (void)cls;(void)url;(void)method;(void)version;       /* Unused. Silent compiler warning. */\n  (void)upload_data;(void)upload_data_size;             /* Unused. Silent compiler warning. */\n\n  if (NULL == *ptr)\n    {\n      *ptr = (void*)&query_session_ahc;\n      return MHD_YES;\n    }\n\n  if (GNUTLS_TLS1_1 !=\n      (ret = MHD_get_connection_info\n       (connection,\n\tMHD_CONNECTION_INFO_PROTOCOL)->protocol))\n    {\n      if (GNUTLS_TLS1_2 == ret)\n      {\n        /* as usual, TLS implementations sometimes don't\n           quite do what was asked, just mildly complain... */\n        fprintf (stderr,\n                 \"Warning: requested TLS 1.1, got TLS 1.2\\n\");\n      }\n      else\n      {\n        /* really different version... */\n        fprintf (stderr,\n                 \"Error: requested protocol mismatch (wanted %d, got %d)\\n\",\n                 GNUTLS_TLS1_1,\n                 ret);\n        return -1;\n      }\n    }\n\n  response = MHD_create_response_from_buffer (strlen (EMPTY_PAGE),\n\t\t\t\t\t      (void *) EMPTY_PAGE,\n\t\t\t\t\t      MHD_RESPMEM_PERSISTENT);\n  ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n  MHD_destroy_response (response);\n  return ret;\n}",
      "lines": 47,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "test_query_session": {
      "start_point": [
        96,
        0
      ],
      "end_point": [
        184,
        1
      ],
      "content": "static int\ntest_query_session ()\n{\n  CURL *c;\n  struct CBC cbc;\n  CURLcode errornum;\n  char url[256];\n  int port;\n\n  if (MHD_NO != MHD_is_feature_supported (MHD_FEATURE_AUTODETECT_BIND_PORT))\n    port = 0;\n  else\n    port = 3060;\n\n  if (NULL == (cbc.buf = malloc (sizeof (char) * 255)))\n    return 16;\n  cbc.size = 255;\n  cbc.pos = 0;\n\n  /* setup test */\n  d = MHD_start_daemon (MHD_USE_THREAD_PER_CONNECTION | MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_TLS |\n                        MHD_USE_ERROR_LOG, port,\n                        NULL, NULL, &query_session_ahc, NULL,\n\t\t\tMHD_OPTION_HTTPS_PRIORITIES, \"NORMAL:+ARCFOUR-128\",\n                        MHD_OPTION_HTTPS_MEM_KEY, srv_key_pem,\n                        MHD_OPTION_HTTPS_MEM_CERT, srv_self_signed_cert_pem,\n                        MHD_OPTION_END);\n\n  if (d == NULL)\n    {\n      free (cbc.buf);\n      return 2;\n    }\n  if (0 == port)\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (d, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        { MHD_stop_daemon (d); return 32; }\n      port = (int)dinfo->port;\n    }\n\n  const char *aes256_sha = \"AES256-SHA\";\n  if (curl_uses_nss_ssl() == 0)\n    {\n      aes256_sha = \"rsa_aes_256_sha\";\n    }\n\n  gen_test_file_url (url,\n                     sizeof (url),\n                     port);\n  c = curl_easy_init ();\n#if DEBUG_HTTPS_TEST\n  curl_easy_setopt (c, CURLOPT_VERBOSE, 1);\n#endif\n  curl_easy_setopt (c, CURLOPT_URL, url);\n  curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n  curl_easy_setopt (c, CURLOPT_TIMEOUT, 10L);\n  curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT, 10L);\n  curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n  curl_easy_setopt (c, CURLOPT_FILE, &cbc);\n  /* TLS options */\n  curl_easy_setopt (c, CURLOPT_SSLVERSION, CURL_SSLVERSION_TLSv1_1);\n  curl_easy_setopt (c, CURLOPT_SSL_CIPHER_LIST, aes256_sha);\n  /* currently skip any peer authentication */\n  curl_easy_setopt (c, CURLOPT_SSL_VERIFYPEER, 0);\n  curl_easy_setopt (c, CURLOPT_SSL_VERIFYHOST, 0);\n  curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n\n  /* NOTE: use of CONNECTTIMEOUT without also\n   * setting NOSIGNAL results in really weird\n   * crashes on my system! */\n  curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n  if (CURLE_OK != (errornum = curl_easy_perform (c)))\n    {\n      fprintf (stderr, \"curl_easy_perform failed: `%s'\\n\",\n               curl_easy_strerror (errornum));\n\n      MHD_stop_daemon (d);\n      curl_easy_cleanup (c);\n      free (cbc.buf);\n      return -1;\n    }\n\n  curl_easy_cleanup (c);\n  MHD_stop_daemon (d);\n  free (cbc.buf);\n  return 0;\n}",
      "lines": 89,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        187,
        0
      ],
      "end_point": [
        224,
        1
      ],
      "content": "int\nmain (int argc, char *const *argv)\n{\n#if LIBCURL_VERSION_NUM >= 0x072200\n  unsigned int errorCount = 0;\n  const char *ssl_version;\n  (void)argc;   /* Unused. Silent compiler warning. */\n\n#ifdef MHD_HTTPS_REQUIRE_GRYPT\n  gcry_control (GCRYCTL_ENABLE_QUICK_RANDOM, 0);\n#ifdef GCRYCTL_INITIALIZATION_FINISHED\n  gcry_control (GCRYCTL_INITIALIZATION_FINISHED, 0);\n#endif\n#endif /* MHD_HTTPS_REQUIRE_GRYPT */\n  if (!testsuite_curl_global_init ())\n    return 99;\n\n  ssl_version = curl_version_info (CURLVERSION_NOW)->ssl_version;\n  if (NULL == ssl_version)\n  {\n    fprintf (stderr, \"Curl does not support SSL.  Cannot run the test.\\n\");\n    curl_global_cleanup ();\n    return 77;\n  }\n  if (0 != strncmp (ssl_version, \"GnuTLS\", 6))\n  {\n    fprintf (stderr, \"This test can be run only with libcurl-gnutls.\\n\");\n    curl_global_cleanup ();\n    return 77;\n  }\n  errorCount += test_query_session ();\n  print_test_result (errorCount, argv[0]);\n  curl_global_cleanup ();\n  return errorCount != 0 ? 1 : 0;\n#else  /* LIBCURL_VERSION_NUM < 0x072200 */\n  return 77;\n#endif /* LIBCURL_VERSION_NUM < 0x072200 */\n}",
      "lines": 38,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/testcurl/https/test_https_sni.c": {
    "load_keys": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        119,
        1
      ],
      "content": "static void\nload_keys(const char *hostname,\n          const char *CERT_FILE,\n          const char *KEY_FILE)\n{\n  int ret;\n  gnutls_datum_t data;\n  struct Hosts *host;\n\n  host = malloc (sizeof (struct Hosts));\n  if (NULL == host)\n    abort ();\n  host->hostname = hostname;\n  host->next = hosts;\n  hosts = host;\n\n  ret = gnutls_load_file (CERT_FILE, &data);\n  if (ret < 0)\n    {\n      fprintf (stderr,\n               \"*** Error loading certificate file %s.\\n\",\n               CERT_FILE);\n      exit (1);\n    }\n  ret =\n    gnutls_pcert_import_x509_raw (&host->pcrt, &data, GNUTLS_X509_FMT_PEM,\n                                  0);\n  if (ret < 0)\n    {\n      fprintf (stderr,\n               \"*** Error loading certificate file: %s\\n\",\n               gnutls_strerror (ret));\n      exit (1);\n    }\n  gnutls_free (data.data);\n\n  ret = gnutls_load_file (KEY_FILE, &data);\n  if (ret < 0)\n    {\n      fprintf (stderr,\n               \"*** Error loading key file %s.\\n\",\n               KEY_FILE);\n      exit (1);\n    }\n\n  gnutls_privkey_init (&host->key);\n  ret =\n    gnutls_privkey_import_x509_raw (host->key,\n                                    &data, GNUTLS_X509_FMT_PEM,\n                                    NULL, 0);\n  if (ret < 0)\n    {\n      fprintf (stderr,\n               \"*** Error loading key file: %s\\n\",\n               gnutls_strerror (ret));\n      exit (1);\n    }\n  gnutls_free (data.data);\n}",
      "lines": 59,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "sni_callback": {
      "start_point": [
        133,
        0
      ],
      "end_point": [
        178,
        1
      ],
      "content": "static int\nsni_callback (gnutls_session_t session,\n              const gnutls_datum_t* req_ca_dn,\n              int nreqs,\n              const gnutls_pk_algorithm_t* pk_algos,\n              int pk_algos_length,\n              gnutls_pcert_st** pcert,\n              unsigned int *pcert_length,\n              gnutls_privkey_t * pkey)\n{\n  char name[256];\n  size_t name_len;\n  struct Hosts *host;\n  unsigned int type;\n  (void)req_ca_dn;(void)nreqs;(void)pk_algos;(void)pk_algos_length;   /* Unused. Silent compiler warning. */\n\n  name_len = sizeof (name);\n  if (GNUTLS_E_SUCCESS !=\n      gnutls_server_name_get (session,\n                              name,\n                              &name_len,\n                              &type,\n                              0 /* index */))\n    return -1;\n  for (host = hosts; NULL != host; host = host->next)\n    if (0 == strncmp (name, host->hostname, name_len))\n      break;\n  if (NULL == host)\n    {\n      fprintf (stderr,\n               \"Need certificate for %.*s\\n\",\n               (int) name_len,\n               name);\n      return -1;\n    }\n#if 0\n  fprintf (stderr,\n           \"Returning certificate for %.*s\\n\",\n           (int) name_len,\n           name);\n#endif\n  *pkey = host->key;\n  *pcert_length = 1;\n  *pcert = &host->pcrt;\n  return 0;\n}",
      "lines": 46,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "do_get": {
      "start_point": [
        182,
        0
      ],
      "end_point": [
        249,
        1
      ],
      "content": "static int\ndo_get (const char *url, int port)\n{\n  CURL *c;\n  struct CBC cbc;\n  CURLcode errornum;\n  size_t len;\n  struct curl_slist *dns_info;\n  char buf[256];\n\n  len = strlen (test_data);\n  if (NULL == (cbc.buf = malloc (sizeof (char) * len)))\n    {\n      fprintf (stderr, MHD_E_MEM);\n      return -1;\n    }\n  cbc.size = len;\n  cbc.pos = 0;\n\n  c = curl_easy_init ();\n#if DEBUG_HTTPS_TEST\n  curl_easy_setopt (c, CURLOPT_VERBOSE, 1);\n#endif\n  curl_easy_setopt (c, CURLOPT_URL, url);\n  curl_easy_setopt (c, CURLOPT_PORT, (long)port);\n  curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0);\n  curl_easy_setopt (c, CURLOPT_TIMEOUT, 10L);\n  curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT, 10L);\n  curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n  curl_easy_setopt (c, CURLOPT_FILE, &cbc);\n\n  /* perform peer authentication */\n  /* TODO merge into send_curl_req */\n  curl_easy_setopt (c, CURLOPT_SSL_VERIFYPEER, 0);\n  curl_easy_setopt (c, CURLOPT_SSL_VERIFYHOST, 2);\n  sprintf(buf, \"host1:%d:127.0.0.1\", port);\n  dns_info = curl_slist_append (NULL, buf);\n  sprintf(buf, \"host2:%d:127.0.0.1\", port);\n  dns_info = curl_slist_append (dns_info, buf);\n  curl_easy_setopt (c, CURLOPT_RESOLVE, dns_info);\n  curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n\n  /* NOTE: use of CONNECTTIMEOUT without also\n     setting NOSIGNAL results in really weird\n     crashes on my system! */\n  curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n  if (CURLE_OK != (errornum = curl_easy_perform (c)))\n    {\n      fprintf (stderr, \"curl_easy_perform failed: `%s'\\n\",\n               curl_easy_strerror (errornum));\n      curl_easy_cleanup (c);\n      free (cbc.buf);\n      curl_slist_free_all (dns_info);\n      return errornum;\n    }\n\n  curl_easy_cleanup (c);\n  curl_slist_free_all (dns_info);\n  if (memcmp (cbc.buf, test_data, len) != 0)\n    {\n      fprintf (stderr, \"Error: local file & received file differ.\\n\");\n      free (cbc.buf);\n      return -1;\n    }\n\n  free (cbc.buf);\n  return 0;\n}",
      "lines": 68,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": [
      {
        "start_point": [
          252,
          0
        ],
        "end_point": [
          311,
          1
        ],
        "content": "int\nmain (int argc, char *const *argv)\n{\n  unsigned int error_count = 0;\n  struct MHD_Daemon *d;\n  int port;\n  (void)argc;   /* Unused. Silent compiler warning. */\n\n  if (MHD_NO != MHD_is_feature_supported (MHD_FEATURE_AUTODETECT_BIND_PORT))\n    port = 0;\n  else\n    port = 3060;\n\n#ifdef MHD_HTTPS_REQUIRE_GRYPT\n  gcry_control (GCRYCTL_ENABLE_QUICK_RANDOM, 0);\n#ifdef GCRYCTL_INITIALIZATION_FINISHED\n  gcry_control (GCRYCTL_INITIALIZATION_FINISHED, 0);\n#endif\n#endif /* MHD_HTTPS_REQUIRE_GRYPT */\n  if (!testsuite_curl_global_init ())\n    return 99;\n  if (NULL == curl_version_info (CURLVERSION_NOW)->ssl_version)\n    {\n      fprintf (stderr, \"Curl does not support SSL.  Cannot run the test.\\n\");\n      curl_global_cleanup ();\n      return 77;\n    }\n\n  load_keys (\"host1\", ABS_SRCDIR \"/host1.crt\", ABS_SRCDIR \"/host1.key\");\n  load_keys (\"host2\", ABS_SRCDIR \"/host2.crt\", ABS_SRCDIR \"/host2.key\");\n  d = MHD_start_daemon (MHD_USE_THREAD_PER_CONNECTION | MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_TLS | MHD_USE_ERROR_LOG,\n                        port,\n                        NULL, NULL,\n                        &http_ahc, NULL,\n                        MHD_OPTION_HTTPS_CERT_CALLBACK, &sni_callback,\n                        MHD_OPTION_END);\n  if (d == NULL)\n    {\n      fprintf (stderr, MHD_E_SERVER_INIT);\n      return -1;\n    }\n  if (0 == port)\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (d, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        { MHD_stop_daemon (d); return -1; }\n      port = (int)dinfo->port;\n    }\n  if (0 != do_get (\"https://host1/\", port))\n    error_count++;\n  if (0 != do_get (\"https://host2/\", port))\n    error_count++;\n\n  MHD_stop_daemon (d);\n  curl_global_cleanup ();\n  if (error_count != 0)\n    fprintf (stderr, \"Failed test: %s, error: %u.\\n\", argv[0], error_count);\n  return (0 != error_count) ? 1 : 0;\n}",
        "lines": 60,
        "depth": 10,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          316,
          0
        ],
        "end_point": [
          321,
          1
        ],
        "content": "int main (void)\n{\n  fprintf (stderr,\n           \"SNI not supported by GnuTLS < 3.0\\n\");\n  return 77;\n}",
        "lines": 6,
        "depth": 7,
        "decorators": [
          "int"
        ]
      }
    ]
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/testcurl/https/test_https_time_out.c": {
    "test_tls_session_time_out": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        99,
        1
      ],
      "content": "static int\ntest_tls_session_time_out (gnutls_session_t session, int port)\n{\n  int ret;\n  MHD_socket sd;\n  struct sockaddr_in sa;\n\n  sd = socket (AF_INET, SOCK_STREAM, 0);\n  if (sd == MHD_INVALID_SOCKET)\n    {\n      fprintf (stderr, \"Failed to create socket: %s\\n\", strerror (errno));\n      return -1;\n    }\n\n  memset (&sa, '\\0', sizeof (struct sockaddr_in));\n  sa.sin_family = AF_INET;\n  sa.sin_port = htons (port);\n  sa.sin_addr.s_addr = htonl (INADDR_LOOPBACK);\n\n  gnutls_transport_set_ptr (session, (gnutls_transport_ptr_t) (intptr_t) sd);\n\n  ret = connect (sd, (struct sockaddr *) &sa, sizeof (struct sockaddr_in));\n\n  if (ret < 0)\n    {\n      fprintf (stderr, \"Error: %s\\n\", MHD_E_FAILED_TO_CONNECT);\n      MHD_socket_close_chk_ (sd);\n      return -1;\n    }\n\n  ret = gnutls_handshake (session);\n  if (ret < 0)\n    {\n      fprintf (stderr, \"Handshake failed\\n\");\n      MHD_socket_close_chk_ (sd);\n      return -1;\n    }\n\n  (void)sleep (TIME_OUT + 1);\n\n  /* check that server has closed the connection */\n  /* TODO better RST trigger */\n  if (send (sd, \"\", 1, 0) == 0)\n    {\n      fprintf (stderr, \"Connection failed to time-out\\n\");\n      MHD_socket_close_chk_ (sd);\n      return -1;\n    }\n\n  MHD_socket_close_chk_ (sd);\n  return 0;\n}",
      "lines": 52,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        102,
        0
      ],
      "end_point": [
        164,
        1
      ],
      "content": "int\nmain (int argc, char *const *argv)\n{\n  int errorCount = 0;;\n  struct MHD_Daemon *d;\n  gnutls_session_t session;\n  gnutls_datum_t key;\n  gnutls_datum_t cert;\n  gnutls_certificate_credentials_t xcred;\n  int port;\n  (void)argc;   /* Unused. Silent compiler warning. */\n\n  if (MHD_NO != MHD_is_feature_supported (MHD_FEATURE_AUTODETECT_BIND_PORT))\n    port = 0;\n  else\n    port = 3070;\n\n#ifdef MHD_HTTPS_REQUIRE_GRYPT\n  gcry_control (GCRYCTL_ENABLE_QUICK_RANDOM, 0);\n#ifdef GCRYCTL_INITIALIZATION_FINISHED\n  gcry_control (GCRYCTL_INITIALIZATION_FINISHED, 0);\n#endif\n#endif /* MHD_HTTPS_REQUIRE_GRYPT */\n  gnutls_global_init ();\n  gnutls_global_set_log_level (11);\n\n  d = MHD_start_daemon (MHD_USE_THREAD_PER_CONNECTION | MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_TLS |\n                        MHD_USE_ERROR_LOG, port,\n                        NULL, NULL, &http_dummy_ahc, NULL,\n                        MHD_OPTION_CONNECTION_TIMEOUT, TIME_OUT,\n                        MHD_OPTION_HTTPS_MEM_KEY, srv_key_pem,\n                        MHD_OPTION_HTTPS_MEM_CERT, srv_self_signed_cert_pem,\n                        MHD_OPTION_END);\n\n  if (NULL == d)\n    {\n      fprintf (stderr, MHD_E_SERVER_INIT);\n      return -1;\n    }\n  if (0 == port)\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (d, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        { MHD_stop_daemon (d); return -1; }\n      port = (int)dinfo->port;\n    }\n\n  if (0 != setup_session (&session, &key, &cert, &xcred))\n    {\n      fprintf (stderr, \"failed to setup session\\n\");\n      return 1;\n    }\n  errorCount += test_tls_session_time_out (session, port);\n  teardown_session (session, &key, &cert, xcred);\n\n  print_test_result (errorCount, argv[0]);\n\n  MHD_stop_daemon (d);\n  gnutls_global_deinit ();\n\n  return errorCount != 0 ? 1 : 0;\n}",
      "lines": 63,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/testcurl/https/test_tls_authentication.c": {
    "test_secure_get": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        80,
        1
      ],
      "content": "static int\ntest_secure_get (void * cls, char *cipher_suite, int proto_version)\n{\n  int ret;\n  struct MHD_Daemon *d;\n  int port;\n  (void)cls;    /* Unused. Silent compiler warning. */\n\n  if (MHD_NO != MHD_is_feature_supported (MHD_FEATURE_AUTODETECT_BIND_PORT))\n    port = 0;\n  else\n    port = 3070;\n\n  d = MHD_start_daemon (MHD_USE_THREAD_PER_CONNECTION | MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_TLS |\n                        MHD_USE_ERROR_LOG, port,\n                        NULL, NULL, &http_ahc, NULL,\n                        MHD_OPTION_HTTPS_MEM_KEY, srv_signed_key_pem,\n                        MHD_OPTION_HTTPS_MEM_CERT, srv_signed_cert_pem,\n                        MHD_OPTION_END);\n\n  if (d == NULL)\n    {\n      fprintf (stderr, MHD_E_SERVER_INIT);\n      return -1;\n    }\n  if (0 == port)\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (d, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        { MHD_stop_daemon (d); return -1; }\n      port = (int)dinfo->port;\n    }\n\n  ret = test_daemon_get (NULL, cipher_suite, proto_version, port, 0);\n\n  MHD_stop_daemon (d);\n  return ret;\n}",
      "lines": 39,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        83,
        0
      ],
      "end_point": [
        128,
        1
      ],
      "content": "int\nmain (int argc, char *const *argv)\n{\n  unsigned int errorCount = 0;\n  char *aes256_sha = \"AES256-SHA\";\n  (void)argc; (void)argv;       /* Unused. Silent compiler warning. */\n\n#ifdef MHD_HTTPS_REQUIRE_GRYPT\n  gcry_control (GCRYCTL_ENABLE_QUICK_RANDOM, 0);\n#ifdef GCRYCTL_INITIALIZATION_FINISHED\n  gcry_control (GCRYCTL_INITIALIZATION_FINISHED, 0);\n#endif\n#endif /* MHD_HTTPS_REQUIRE_GRYPT */\n  if (!testsuite_curl_global_init ())\n    return 99;\n  if (NULL == curl_version_info (CURLVERSION_NOW)->ssl_version)\n    {\n      fprintf (stderr, \"Curl does not support SSL.  Cannot run the test.\\n\");\n      curl_global_cleanup ();\n      return 77;\n    }\n\n  if (setup_ca_cert () == NULL)\n    {\n      fprintf (stderr, MHD_E_TEST_FILE_CREAT);\n      curl_global_cleanup ();\n      return 99;\n    }\n\n  if (curl_uses_nss_ssl() == 0)\n    {\n      aes256_sha = \"rsa_aes_256_sha\";\n    }\n\n  errorCount +=\n    test_secure_get (NULL, aes256_sha, CURL_SSLVERSION_TLSv1);\n\n  print_test_result (errorCount, argv[0]);\n\n  curl_global_cleanup ();\n  if (0 != remove (ca_cert_file_name))\n    fprintf (stderr,\n\t     \"Failed to remove `%s'\\n\",\n\t     ca_cert_file_name);\n  return errorCount != 0 ? 1 : 0;\n}",
      "lines": 46,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/testcurl/https/test_tls_options.c": {
    "test_unmatching_ssl_version": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        81,
        1
      ],
      "content": "static int\ntest_unmatching_ssl_version (void * cls, int port, const char *cipher_suite,\n                             int curl_req_ssl_version)\n{\n  struct CBC cbc;\n  (void)cls;    /* Unused. Silent compiler warning. */\n  if (NULL == (cbc.buf = malloc (sizeof (char) * 256)))\n    {\n      fprintf (stderr, \"Error: failed to allocate: %s\\n\",\n               strerror (errno));\n      return -1;\n    }\n  cbc.size = 256;\n  cbc.pos = 0;\n\n  char url[255];\n  if (gen_test_file_url (url,\n                         sizeof (url),\n                         port))\n    {\n      free (cbc.buf);\n      fprintf (stderr,\n               \"Internal error in gen_test_file_url\\n\");\n      return -1;\n    }\n\n  /* assert daemon *rejected* request */\n  if (CURLE_OK ==\n      send_curl_req (url, &cbc, cipher_suite, curl_req_ssl_version))\n    {\n      free (cbc.buf);\n      fprintf (stderr, \"cURL failed to reject request despite SSL version missmatch!\\n\");\n      return -1;\n    }\n\n  free (cbc.buf);\n  return 0;\n}",
      "lines": 38,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        85,
        0
      ],
      "end_point": [
        166,
        1
      ],
      "content": "int\nmain (int argc, char *const *argv)\n{\n  unsigned int errorCount = 0;\n  const char *ssl_version;\n  int daemon_flags =\n    MHD_USE_THREAD_PER_CONNECTION | MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_TLS | MHD_USE_ERROR_LOG;\n  int port;\n  (void)argc; (void)argv;       /* Unused. Silent compiler warning. */\n\n  if (MHD_NO != MHD_is_feature_supported (MHD_FEATURE_AUTODETECT_BIND_PORT))\n    port = 0;\n  else\n    port = 3010;\n\n#ifdef MHD_HTTPS_REQUIRE_GRYPT\n  gcry_control (GCRYCTL_DISABLE_SECMEM, 0);\n  gcry_control (GCRYCTL_ENABLE_QUICK_RANDOM, 0);\n#ifdef GCRYCTL_INITIALIZATION_FINISHED\n  gcry_control (GCRYCTL_INITIALIZATION_FINISHED, 0);\n#endif\n#endif /* MHD_HTTPS_REQUIRE_GRYPT */\n if (curl_check_version (MHD_REQ_CURL_VERSION))\n    {\n      return 77;\n    }\n  ssl_version = curl_version_info (CURLVERSION_NOW)->ssl_version;\n  if (NULL == ssl_version)\n  {\n    fprintf (stderr, \"Curl does not support SSL.  Cannot run the test.\\n\");\n    return 77;\n  }\n  if (0 != strncmp (ssl_version, \"GnuTLS\", 6))\n  {\n    fprintf (stderr, \"This test can be run only with libcurl-gnutls.\\n\");\n    return 77;\n  }\n\n  if (!testsuite_curl_global_init ())\n    return 99;\n\n  const char *aes128_sha = \"AES128-SHA\";\n  const char *aes256_sha = \"AES256-SHA\";\n  if (curl_uses_nss_ssl() == 0)\n    {\n      aes128_sha = \"rsa_aes_128_sha\";\n      aes256_sha = \"rsa_aes_256_sha\";\n    }\n\n\n  if (0 !=\n    test_wrap (\"TLS1.0-AES-SHA1\",\n\t       &test_https_transfer, NULL, port, daemon_flags,\n\t       aes128_sha,\n\t       CURL_SSLVERSION_TLSv1,\n\t       MHD_OPTION_HTTPS_MEM_KEY, srv_key_pem,\n\t       MHD_OPTION_HTTPS_MEM_CERT, srv_self_signed_cert_pem,\n\t       MHD_OPTION_HTTPS_PRIORITIES, \"NONE:+VERS-TLS1.0:+AES-128-CBC:+SHA1:+RSA:+COMP-NULL\",\n\t       MHD_OPTION_END))\n    {\n      fprintf (stderr, \"TLS1.0-AES-SHA1 test failed\\n\");\n      errorCount++;\n    }\n  fprintf (stderr,\n\t   \"The following handshake should fail (and print an error message)...\\n\");\n  if (0 !=\n    test_wrap (\"TLS1.0 vs SSL3\",\n\t       &test_unmatching_ssl_version, NULL, port, daemon_flags,\n\t       aes256_sha,\n\t       CURL_SSLVERSION_SSLv3,\n\t       MHD_OPTION_HTTPS_MEM_KEY, srv_key_pem,\n\t       MHD_OPTION_HTTPS_MEM_CERT, srv_self_signed_cert_pem,\n\t       MHD_OPTION_HTTPS_PRIORITIES, \"NONE:+VERS-TLS1.0:+AES-256-CBC:+SHA1:+RSA:+COMP-NULL\",\n\t       MHD_OPTION_END))\n    {\n      fprintf (stderr, \"TLS1.0 vs SSL3 test failed\\n\");\n      errorCount++;\n    }\n  curl_global_cleanup ();\n\n  return errorCount != 0 ? 1 : 0;\n}",
      "lines": 82,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/testcurl/https/tls_test_common.c": {
    "setup_ca_cert": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "FILE *\nsetup_ca_cert ()\n{\n  FILE *cert_fd;\n\n  if (NULL == (cert_fd = fopen (ca_cert_file_name, \"wb+\")))\n    {\n      fprintf (stderr, \"Error: failed to open `%s': %s\\n\",\n               ca_cert_file_name, strerror (errno));\n      return NULL;\n    }\n  if (fwrite (ca_cert_pem, sizeof (char), strlen (ca_cert_pem) + 1, cert_fd)\n      != strlen (ca_cert_pem) + 1)\n    {\n      fprintf (stderr, \"Error: failed to write `%s. %s'\\n\",\n               ca_cert_file_name, strerror (errno));\n      fclose (cert_fd);\n      return NULL;\n    }\n  if (fflush (cert_fd))\n    {\n      fprintf (stderr, \"Error: failed to flush ca cert file stream. %s\\n\",\n               strerror (errno));\n      fclose (cert_fd);\n      return NULL;\n    }\n  return cert_fd;\n}",
      "lines": 28,
      "depth": 11,
      "decorators": [
        "FILE",
        "*\nsetup_ca_cert ()",
        "*"
      ]
    },
    "test_daemon_get": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        136,
        1
      ],
      "content": "int\ntest_daemon_get (void *cls,\n\t\t const char *cipher_suite, int proto_version,\n\t\t int port,\n\t\t int ver_peer)\n{\n  CURL *c;\n  struct CBC cbc;\n  CURLcode errornum;\n  char url[255];\n  size_t len;\n  (void)cls;    /* Unused. Silent compiler warning. */\n\n  len = strlen (test_data);\n  if (NULL == (cbc.buf = malloc (sizeof (char) * len)))\n    {\n      fprintf (stderr, MHD_E_MEM);\n      return -1;\n    }\n  cbc.size = len;\n  cbc.pos = 0;\n\n  /* construct url - this might use doc_path */\n  gen_test_file_url (url,\n                     sizeof (url),\n                     port);\n\n  c = curl_easy_init ();\n#if DEBUG_HTTPS_TEST\n  curl_easy_setopt (c, CURLOPT_VERBOSE, 1);\n#endif\n  curl_easy_setopt (c, CURLOPT_URL, url);\n  curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0);\n  curl_easy_setopt (c, CURLOPT_TIMEOUT, 10L);\n  curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT, 10L);\n  curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n  curl_easy_setopt (c, CURLOPT_FILE, &cbc);\n\n  /* TLS options */\n  curl_easy_setopt (c, CURLOPT_SSLVERSION, proto_version);\n  curl_easy_setopt (c, CURLOPT_SSL_CIPHER_LIST, cipher_suite);\n\n  /* perform peer authentication */\n  /* TODO merge into send_curl_req */\n  curl_easy_setopt (c, CURLOPT_SSL_VERIFYPEER, ver_peer);\n  if (ver_peer)\n    curl_easy_setopt (c, CURLOPT_CAINFO, ca_cert_file_name);\n  curl_easy_setopt (c, CURLOPT_SSL_VERIFYHOST, 0);\n  curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n\n  /* NOTE: use of CONNECTTIMEOUT without also\n     setting NOSIGNAL results in really weird\n     crashes on my system! */\n  curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n  if (CURLE_OK != (errornum = curl_easy_perform (c)))\n    {\n      fprintf (stderr, \"curl_easy_perform failed: `%s'\\n\",\n               curl_easy_strerror (errornum));\n      curl_easy_cleanup (c);\n      free (cbc.buf);\n      return errornum;\n    }\n\n  curl_easy_cleanup (c);\n\n  if (memcmp (cbc.buf, test_data, len) != 0)\n    {\n      fprintf (stderr, \"Error: local file & received file differ.\\n\");\n      free (cbc.buf);\n      return -1;\n    }\n\n  free (cbc.buf);\n  return 0;\n}",
      "lines": 75,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "print_test_result": {
      "start_point": [
        139,
        0
      ],
      "end_point": [
        148,
        1
      ],
      "content": "void\nprint_test_result (int test_outcome, char *test_name)\n{\n  if (test_outcome != 0)\n    fprintf (stderr, \"running test: %s [fail: %u]\\n\", test_name, (unsigned int)test_outcome);\n#if 0\n  else\n    fprintf (stdout, \"running test: %s [pass]\\n\", test_name);\n#endif\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "copyBuffer": {
      "start_point": [
        150,
        0
      ],
      "end_point": [
        160,
        1
      ],
      "content": "size_t\ncopyBuffer (void *ptr, size_t size, size_t nmemb, void *ctx)\n{\n  struct CBC *cbc = ctx;\n\n  if (cbc->pos + size * nmemb > cbc->size)\n    return 0;                   /* overflow */\n  memcpy (&cbc->buf[cbc->pos], ptr, size * nmemb);\n  cbc->pos += size * nmemb;\n  return size * nmemb;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "size_t"
      ]
    },
    "http_ahc": {
      "start_point": [
        165,
        0
      ],
      "end_point": [
        191,
        1
      ],
      "content": "int\nhttp_ahc (void *cls, struct MHD_Connection *connection,\n          const char *url, const char *method, const char *version,\n          const char *upload_data, size_t *upload_data_size, void **ptr)\n{\n  static int aptr;\n  struct MHD_Response *response;\n  int ret;\n  (void)cls;(void)url;(void)version;            /* Unused. Silent compiler warning. */\n  (void)upload_data;(void)upload_data_size;     /* Unused. Silent compiler warning. */\n\n  if (0 != strcmp (method, MHD_HTTP_METHOD_GET))\n    return MHD_NO;              /* unexpected method */\n  if (&aptr != *ptr)\n    {\n      /* do never respond on first call */\n      *ptr = &aptr;\n      return MHD_YES;\n    }\n  *ptr = NULL;                  /* reset when done */\n  response = MHD_create_response_from_buffer (strlen (test_data),\n\t\t\t\t\t      (void *) test_data,\n\t\t\t\t\t      MHD_RESPMEM_PERSISTENT);\n  ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n  MHD_destroy_response (response);\n  return ret;\n}",
      "lines": 27,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "http_dummy_ahc": {
      "start_point": [
        194,
        0
      ],
      "end_point": [
        203,
        1
      ],
      "content": "int\nhttp_dummy_ahc (void *cls, struct MHD_Connection *connection,\n                const char *url, const char *method, const char *version,\n                const char *upload_data, size_t *upload_data_size,\n                void **ptr)\n{\n  (void)cls;(void)connection;(void)url;(void)method;(void)version;      /* Unused. Silent compiler warning. */\n  (void)upload_data;(void)upload_data_size;(void)ptr;                   /* Unused. Silent compiler warning. */\n return 0;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "send_curl_req": {
      "start_point": [
        214,
        0
      ],
      "end_point": [
        259,
        1
      ],
      "content": "int\nsend_curl_req (char *url, struct CBC * cbc, const char *cipher_suite,\n               int proto_version)\n{\n  CURL *c;\n  CURLcode errornum;\n  c = curl_easy_init ();\n#if DEBUG_HTTPS_TEST\n  curl_easy_setopt (c, CURLOPT_VERBOSE, CURL_VERBOS_LEVEL);\n#endif\n  curl_easy_setopt (c, CURLOPT_URL, url);\n  curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0);\n  curl_easy_setopt (c, CURLOPT_TIMEOUT, 60L);\n  curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT, 60L);\n\n  if (cbc != NULL)\n    {\n      curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n      curl_easy_setopt (c, CURLOPT_FILE, cbc);\n    }\n\n  /* TLS options */\n  curl_easy_setopt (c, CURLOPT_SSLVERSION, proto_version);\n  curl_easy_setopt (c, CURLOPT_SSL_CIPHER_LIST, cipher_suite);\n\n  /* currently skip any peer authentication */\n  curl_easy_setopt (c, CURLOPT_SSL_VERIFYPEER, 0);\n  curl_easy_setopt (c, CURLOPT_SSL_VERIFYHOST, 0);\n\n  curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n\n  /* NOTE: use of CONNECTTIMEOUT without also\n     setting NOSIGNAL results in really weird\n     crashes on my system! */\n  curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n  if (CURLE_OK != (errornum = curl_easy_perform (c)))\n    {\n      fprintf (stderr, \"curl_easy_perform failed: `%s'\\n\",\n               curl_easy_strerror (errornum));\n      curl_easy_cleanup (c);\n      return errornum;\n    }\n  curl_easy_cleanup (c);\n\n  return CURLE_OK;\n}",
      "lines": 46,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "gen_test_file_url": {
      "start_point": [
        270,
        0
      ],
      "end_point": [
        329,
        1
      ],
      "content": "int\ngen_test_file_url (char *url,\n                   size_t url_len,\n                   int port)\n{\n  int ret = 0;\n  char *doc_path;\n  size_t doc_path_len;\n  /* setup test file path, url */\n#ifdef PATH_MAX\n  doc_path_len = PATH_MAX > 4096 ? 4096 : PATH_MAX;\n#else  /* ! PATH_MAX */\n  doc_path_len = 4096;\n#endif /* ! PATH_MAX */\n#ifdef WINDOWS\n  size_t i;\n#endif /* ! WINDOWS */\n  if (NULL == (doc_path = malloc (doc_path_len)))\n    {\n      fprintf (stderr, MHD_E_MEM);\n      return -1;\n    }\n  if (NULL == getcwd (doc_path, doc_path_len))\n    {\n      fprintf (stderr,\n               \"Error: failed to get working directory. %s\\n\",\n               strerror (errno));\n      free (doc_path);\n      return -1;\n    }\n#ifdef WINDOWS\n  for (i = 0; i < doc_path_len; i++)\n  {\n    if (doc_path[i] == 0)\n      break;\n    if (doc_path[i] == '\\\\')\n      {\n        doc_path[i] = '/';\n      }\n    if (doc_path[i] != ':')\n      continue;\n    if (i == 0)\n      break;\n    doc_path[i] = doc_path[i - 1];\n    doc_path[i - 1] = '/';\n  }\n#endif\n  /* construct url */\n  if (snprintf (url,\n                url_len,\n                \"%s:%d%s/%s\",\n                \"https://127.0.0.1\",\n                port,\n                doc_path,\n                \"urlpath\") >= (long long)url_len)\n    ret = -1;\n\n  free (doc_path);\n  return ret;\n}",
      "lines": 60,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "test_https_transfer": {
      "start_point": [
        335,
        0
      ],
      "end_point": [
        383,
        1
      ],
      "content": "int\ntest_https_transfer (void *cls,\n                     int port,\n                     const char *cipher_suite,\n                     int proto_version)\n{\n  int len;\n  int ret = 0;\n  struct CBC cbc;\n  char url[255];\n  (void)cls;    /* Unused. Silent compiler warning. */\n\n  len = strlen (test_data);\n  if (NULL == (cbc.buf = malloc (sizeof (char) * len)))\n    {\n      fprintf (stderr, MHD_E_MEM);\n      return -1;\n    }\n  cbc.size = len;\n  cbc.pos = 0;\n\n  if (gen_test_file_url (url,\n                         sizeof (url),\n                         port))\n    {\n      ret = -1;\n      goto cleanup;\n    }\n\n  if (CURLE_OK !=\n      send_curl_req (url, &cbc, cipher_suite, proto_version))\n    {\n      ret = -1;\n      goto cleanup;\n    }\n\n  /* compare test file & daemon responce */\n  if ( (len != strlen (test_data)) ||\n       (memcmp (cbc.buf,\n\t\ttest_data,\n\t\tlen) != 0) )\n    {\n      fprintf (stderr, \"Error: local file & received file differ.\\n\");\n      ret = -1;\n    }\ncleanup:\n  free (cbc.buf);\n  return ret;\n}",
      "lines": 49,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "setup_testcase": {
      "start_point": [
        393,
        0
      ],
      "end_point": [
        418,
        1
      ],
      "content": "int\nsetup_testcase (struct MHD_Daemon **d, int port, int daemon_flags, va_list arg_list)\n{\n  *d = MHD_start_daemon_va (daemon_flags, port,\n                            NULL, NULL, &http_ahc, NULL, arg_list);\n\n  if (*d == NULL)\n    {\n      fprintf (stderr, MHD_E_SERVER_INIT);\n      return 0;\n    }\n\n  if (0 == port)\n    {\n      const union MHD_DaemonInfo *dinfo;\n      dinfo = MHD_get_daemon_info (*d, MHD_DAEMON_INFO_BIND_PORT);\n      if (NULL == dinfo || 0 == dinfo->port)\n        {\n          MHD_stop_daemon (*d);\n          return 0;\n        }\n      port = (int)dinfo->port;\n    }\n\n  return port;\n}",
      "lines": 26,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "teardown_testcase": {
      "start_point": [
        420,
        0
      ],
      "end_point": [
        424,
        1
      ],
      "content": "void\nteardown_testcase (struct MHD_Daemon *d)\n{\n  MHD_stop_daemon (d);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "setup_session": {
      "start_point": [
        426,
        0
      ],
      "end_point": [
        469,
        1
      ],
      "content": "int\nsetup_session (gnutls_session_t * session,\n               gnutls_datum_t * key,\n               gnutls_datum_t * cert,\n\t       gnutls_certificate_credentials_t * xcred)\n{\n  int ret;\n  const char *err_pos;\n\n  gnutls_certificate_allocate_credentials (xcred);\n  key->size = strlen (srv_key_pem) + 1;\n  key->data = malloc (key->size);\n  if (NULL == key->data)\n     {\n       gnutls_certificate_free_credentials (*xcred);\n\treturn -1;\n     }\n  memcpy (key->data, srv_key_pem, key->size);\n  cert->size = strlen (srv_self_signed_cert_pem) + 1;\n  cert->data = malloc (cert->size);\n  if (NULL == cert->data)\n    {\n        gnutls_certificate_free_credentials (*xcred);\n\tfree (key->data);\n\treturn -1;\n    }\n  memcpy (cert->data, srv_self_signed_cert_pem, cert->size);\n  gnutls_certificate_set_x509_key_mem (*xcred, cert, key,\n\t\t\t\t       GNUTLS_X509_FMT_PEM);\n  gnutls_init (session, GNUTLS_CLIENT);\n  ret = gnutls_priority_set_direct (*session,\n\t\t\t\t    \"NORMAL\", &err_pos);\n  if (ret < 0)\n    {\n       gnutls_deinit (*session);\n       gnutls_certificate_free_credentials (*xcred);\n       free (key->data);\n       return -1;\n    }\n  gnutls_credentials_set (*session,\n\t\t\t  GNUTLS_CRD_CERTIFICATE,\n\t\t\t  *xcred);\n  return 0;\n}",
      "lines": 44,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "teardown_session": {
      "start_point": [
        471,
        0
      ],
      "end_point": [
        486,
        1
      ],
      "content": "int\nteardown_session (gnutls_session_t session,\n                  gnutls_datum_t * key,\n                  gnutls_datum_t * cert,\n                  gnutls_certificate_credentials_t xcred)\n{\n  free (key->data);\n  key->data = NULL;\n  key->size = 0;\n  free (cert->data);\n  cert->data = NULL;\n  cert->size = 0;\n  gnutls_deinit (session);\n  gnutls_certificate_free_credentials (xcred);\n  return 0;\n}",
      "lines": 16,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "test_wrap": {
      "start_point": [
        489,
        0
      ],
      "end_point": [
        526,
        1
      ],
      "content": "int\ntest_wrap (const char *test_name, int\n           (*test_function) (void * cls, int port, const char *cipher_suite,\n                             int proto_version), void * cls,\n           int port,\n           int daemon_flags, const char *cipher_suite, int proto_version, ...)\n{\n  int ret;\n  va_list arg_list;\n  struct MHD_Daemon *d;\n  (void)cls;    /* Unused. Silent compiler warning. */\n\n  va_start (arg_list, proto_version);\n  port = setup_testcase (&d, port, daemon_flags, arg_list);\n  if (0 == port)\n    {\n      va_end (arg_list);\n      fprintf (stderr, \"Failed to setup testcase %s\\n\", test_name);\n      return -1;\n    }\n#if 0\n  fprintf (stdout, \"running test: %s \", test_name);\n#endif\n  ret = test_function (NULL, port, cipher_suite, proto_version);\n#if 0\n  if (ret == 0)\n    {\n      fprintf (stdout, \"[pass]\\n\");\n    }\n  else\n    {\n      fprintf (stdout, \"[fail]\\n\");\n    }\n#endif\n  teardown_testcase (d);\n  va_end (arg_list);\n  return ret;\n}",
      "lines": 38,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "testsuite_curl_global_init": {
      "start_point": [
        528,
        0
      ],
      "end_point": [
        545,
        1
      ],
      "content": "int testsuite_curl_global_init (void)\n{\n  CURLcode res;\n#if LIBCURL_VERSION_NUM >= 0x073800\n  if (CURLSSLSET_OK != curl_global_sslset(CURLSSLBACKEND_GNUTLS, NULL, NULL))\n    {\n      if (CURLSSLSET_TOO_LATE == curl_global_sslset(CURLSSLBACKEND_OPENSSL, NULL, NULL))\n        fprintf (stderr, \"WARNING: libcurl was already initialised.\\n\");\n    }\n#endif /* LIBCURL_VERSION_NUM >= 0x07380 */\n  res = curl_global_init (CURL_GLOBAL_ALL);\n  if (CURLE_OK != res)\n    {\n      fprintf (stderr, \"libcurl initialisation error: %s\\n\", curl_easy_strerror(res));\n      return 0;\n    }\n  return 1;\n}",
      "lines": 18,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/testcurl/https/tls_test_common.h": {},
  "libmicrohttpd/libmicrohttpd-0.9.59/src/testcurl/https/tls_test_keys.h": {},
  "libmicrohttpd/libmicrohttpd-0.9.59/src/testzzuf/socat.c": {
    "zzuf_socat_start": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        95,
        1
      ],
      "content": "static void\nzzuf_socat_start ()\n{\n  int status;\n  char *const args[] = {\n    \"zzuf\",\n    \"--ratio=0.0:0.75\",\n    \"-n\",\n    \"-A\",\n    \"socat\",\n    \"-lf\",\n    \"/dev/null\",\n    \"TCP4-LISTEN:11081,reuseaddr,fork\",\n    \"TCP4:127.0.0.1:11080\",\n    NULL,\n  };\n  zzuf_pid = fork ();\n  if (zzuf_pid == -1)\n    {\n      fprintf (stderr, \"fork failed: %s\\n\", strerror (errno));\n      exit (1);\n    }\n  if (zzuf_pid != 0)\n    {\n      (void)sleep (1);                /* allow zzuf and socat to start */\n      status = 0;\n      if (0 < waitpid (zzuf_pid, &status, WNOHANG))\n        {\n          if (WIFEXITED (status))\n            fprintf (stderr,\n                     \"zzuf died with status code %d!\\n\",\n                     WEXITSTATUS (status));\n          if (WIFSIGNALED (status))\n            fprintf (stderr,\n                     \"zzuf died from signal %d!\\n\", WTERMSIG (status));\n          exit (1);\n        }\n      return;\n    }\n  setpgid (0, 0);\n  execvp (\"zzuf\", args);\n  fprintf (stderr, \"execution of `zzuf' failed: %s\\n\", strerror (errno));\n  zzuf_pid = 0;                 /* fork failed */\n  exit (1);\n}",
      "lines": 45,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "zzuf_socat_stop": {
      "start_point": [
        98,
        0
      ],
      "end_point": [
        110,
        1
      ],
      "content": "static void\nzzuf_socat_stop ()\n{\n  int status;\n  if (zzuf_pid != 0)\n    {\n      if (0 != killpg (zzuf_pid, SIGINT))\n        fprintf (stderr, \"Failed to killpg: %s\\n\", strerror (errno));\n      kill (zzuf_pid, SIGINT);\n      waitpid (zzuf_pid, &status, 0);\n      (void)sleep (1);                /* allow socat to also die in peace */\n    }\n}",
      "lines": 13,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/testzzuf/test_get.c": {
    "copyBuffer": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "static size_t\ncopyBuffer (void *ptr, size_t size, size_t nmemb, void *ctx)\n{\n  struct CBC *cbc = ctx;\n\n  if (cbc->pos + size * nmemb > cbc->size)\n    return 0;                   /* overflow */\n  memcpy (&cbc->buf[cbc->pos], ptr, size * nmemb);\n  cbc->pos += size * nmemb;\n  return size * nmemb;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "ahc_echo": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        92,
        1
      ],
      "content": "static int\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data, size_t *upload_data_size,\n          void **unused)\n{\n  static int ptr;\n  const char *me = cls;\n  struct MHD_Response *response;\n  int ret;\n  (void)version;(void)upload_data;(void)upload_data_size;       /* Unused. Silent compiler warning. */\n\n  if (0 != strcmp (me, method))\n    return MHD_NO;              /* unexpected method */\n  if (&ptr != *unused)\n    {\n      *unused = &ptr;\n      return MHD_YES;\n    }\n  *unused = NULL;\n  response = MHD_create_response_from_buffer (strlen (url),\n\t\t\t\t\t      (void *) url,\n\t\t\t\t\t      MHD_RESPMEM_MUST_COPY);\n  ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n  MHD_destroy_response (response);\n  if (ret == MHD_NO)\n    abort ();\n  return ret;\n}",
      "lines": 32,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testInternalGet": {
      "start_point": [
        95,
        0
      ],
      "end_point": [
        137,
        1
      ],
      "content": "static int\ntestInternalGet ()\n{\n  struct MHD_Daemon *d;\n  CURL *c;\n  char buf[2048];\n  struct CBC cbc;\n  int i;\n\n  cbc.buf = buf;\n  cbc.size = 2048;\n  cbc.pos = 0;\n  d = MHD_start_daemon (MHD_USE_INTERNAL_POLLING_THREAD /* | MHD_USE_ERROR_LOG */ ,\n                        11080, NULL, NULL, &ahc_echo, \"GET\", MHD_OPTION_END);\n  if (d == NULL)\n    return 1;\n  zzuf_socat_start ();\n  for (i = 0; i < LOOP_COUNT; i++)\n    {\n      fprintf (stderr, \".\");\n      c = curl_easy_init ();\n      curl_easy_setopt (c, CURLOPT_URL, \"http://127.0.0.1:11081/hello_world\");\n      curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n      curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc);\n      curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n      curl_easy_setopt (c, CURLOPT_TIMEOUT_MS, CURL_TIMEOUT);\n      curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT_MS, CURL_TIMEOUT);\n      if (oneone)\n        curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n      else\n        curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0);\n      /* NOTE: use of CONNECTTIMEOUT without also\n       *   setting NOSIGNAL results in really weird\n       *   crashes on my system! */\n      curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n      curl_easy_perform (c);\n      curl_easy_cleanup (c);\n    }\n  fprintf (stderr, \"\\n\");\n  zzuf_socat_stop ();\n  MHD_stop_daemon (d);\n  return 0;\n}",
      "lines": 43,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testMultithreadedGet": {
      "start_point": [
        139,
        0
      ],
      "end_point": [
        181,
        1
      ],
      "content": "static int\ntestMultithreadedGet ()\n{\n  struct MHD_Daemon *d;\n  CURL *c;\n  char buf[2048];\n  struct CBC cbc;\n  int i;\n\n  cbc.buf = buf;\n  cbc.size = 2048;\n  cbc.pos = 0;\n  d = MHD_start_daemon (MHD_USE_THREAD_PER_CONNECTION | MHD_USE_INTERNAL_POLLING_THREAD /* | MHD_USE_ERROR_LOG */ ,\n                        11080, NULL, NULL, &ahc_echo, \"GET\", MHD_OPTION_END);\n  if (d == NULL)\n    return 16;\n  zzuf_socat_start ();\n  for (i = 0; i < LOOP_COUNT; i++)\n    {\n      fprintf (stderr, \".\");\n      c = curl_easy_init ();\n      curl_easy_setopt (c, CURLOPT_URL, \"http://127.0.0.1:11081/hello_world\");\n      curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n      curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc);\n      curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n      curl_easy_setopt (c, CURLOPT_TIMEOUT_MS, CURL_TIMEOUT);\n      if (oneone)\n        curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n      else\n        curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0);\n      curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT_MS, CURL_TIMEOUT);\n      /* NOTE: use of CONNECTTIMEOUT without also\n       *   setting NOSIGNAL results in really weird\n       *   crashes on my system! */\n      curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n      curl_easy_perform (c);\n      curl_easy_cleanup (c);\n    }\n  fprintf (stderr, \"\\n\");\n  zzuf_socat_stop ();\n  MHD_stop_daemon (d);\n  return 0;\n}",
      "lines": 43,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testExternalGet": {
      "start_point": [
        184,
        0
      ],
      "end_point": [
        295,
        1
      ],
      "content": "static int\ntestExternalGet ()\n{\n  struct MHD_Daemon *d;\n  CURL *c;\n  char buf[2048];\n  struct CBC cbc;\n  CURLM *multi;\n  CURLMcode mret;\n  fd_set rs;\n  fd_set ws;\n  fd_set es;\n  int max;\n  int running;\n  time_t start;\n  struct timeval tv;\n  int i;\n\n  multi = NULL;\n  cbc.buf = buf;\n  cbc.size = 2048;\n  cbc.pos = 0;\n  d = MHD_start_daemon (MHD_NO_FLAG /* | MHD_USE_ERROR_LOG */ ,\n                        11080, NULL, NULL, &ahc_echo, \"GET\", MHD_OPTION_END);\n  if (d == NULL)\n    return 256;\n  multi = curl_multi_init ();\n  if (multi == NULL)\n    {\n      MHD_stop_daemon (d);\n      return 512;\n    }\n  zzuf_socat_start ();\n  for (i = 0; i < LOOP_COUNT; i++)\n    {\n      fprintf (stderr, \".\");\n      c = curl_easy_init ();\n      curl_easy_setopt (c, CURLOPT_URL, \"http://127.0.0.1:11081/hello_world\");\n      curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n      curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc);\n      curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n      if (oneone)\n        curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n      else\n        curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0);\n      curl_easy_setopt (c, CURLOPT_TIMEOUT_MS, CURL_TIMEOUT);\n      curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT_MS, CURL_TIMEOUT);\n      /* NOTE: use of CONNECTTIMEOUT without also\n       *   setting NOSIGNAL results in really weird\n       *   crashes on my system! */\n      curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n      mret = curl_multi_add_handle (multi, c);\n      if (mret != CURLM_OK)\n        {\n          curl_multi_cleanup (multi);\n          curl_easy_cleanup (c);\n          zzuf_socat_stop ();\n          MHD_stop_daemon (d);\n          return 1024;\n        }\n      start = time (NULL);\n      while ((time (NULL) - start < 5) && (c != NULL))\n        {\n          max = 0;\n          FD_ZERO (&rs);\n          FD_ZERO (&ws);\n          FD_ZERO (&es);\n          curl_multi_perform (multi, &running);\n          mret = curl_multi_fdset (multi, &rs, &ws, &es, &max);\n          if (mret != CURLM_OK)\n            {\n              curl_multi_remove_handle (multi, c);\n              curl_multi_cleanup (multi);\n              curl_easy_cleanup (c);\n              zzuf_socat_stop ();\n              MHD_stop_daemon (d);\n              return 2048;\n            }\n          if (MHD_YES != MHD_get_fdset (d, &rs, &ws, &es, &max))\n            {\n              curl_multi_remove_handle (multi, c);\n              curl_multi_cleanup (multi);\n              curl_easy_cleanup (c);\n              zzuf_socat_stop ();\n              MHD_stop_daemon (d);\n              return 4096;\n            }\n          tv.tv_sec = 0;\n          tv.tv_usec = 1000;\n          select (max + 1, &rs, &ws, &es, &tv);\n          curl_multi_perform (multi, &running);\n          if (running == 0)\n            {\n              curl_multi_info_read (multi, &running);\n              curl_multi_remove_handle (multi, c);\n              curl_easy_cleanup (c);\n              c = NULL;\n            }\n          MHD_run (d);\n        }\n      if (c != NULL)\n        {\n          curl_multi_remove_handle (multi, c);\n          curl_easy_cleanup (c);\n        }\n    }\n  fprintf (stderr, \"\\n\");\n  curl_multi_cleanup (multi);\n  zzuf_socat_stop ();\n  MHD_stop_daemon (d);\n  return 0;\n}",
      "lines": 112,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        298,
        0
      ],
      "end_point": [
        315,
        1
      ],
      "content": "int\nmain (int argc, char *const *argv)\n{\n  unsigned int errorCount = 0;\n  (void)argc;   /* Unused. Silent compiler warning. */\n\n  oneone = (NULL != strrchr (argv[0], (int) '/')) ?\n    (NULL != strstr (strrchr (argv[0], (int) '/'), \"11\")) : 0;\n  if (0 != curl_global_init (CURL_GLOBAL_WIN32))\n    return 2;\n  errorCount += testInternalGet ();\n  errorCount += testMultithreadedGet ();\n  errorCount += testExternalGet ();\n  if (errorCount != 0)\n    fprintf (stderr, \"Error (code: %u)\\n\", errorCount);\n  curl_global_cleanup ();\n  return errorCount != 0;       /* 0 == pass */\n}",
      "lines": 18,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/testzzuf/test_get_chunked.c": {
    "copyBuffer": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "static size_t\ncopyBuffer (void *ptr, size_t size, size_t nmemb, void *ctx)\n{\n  struct CBC *cbc = ctx;\n\n  if (cbc->pos + size * nmemb > cbc->size)\n    return 0;                   /* overflow */\n  memcpy (&cbc->buf[cbc->pos], ptr, size * nmemb);\n  cbc->pos += size * nmemb;\n  return size * nmemb;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "crc": {
      "start_point": [
        63,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "static ssize_t\ncrc (void *cls, uint64_t pos, char *buf, size_t max)\n{\n  struct MHD_Response **responseptr = cls;\n\n  if (pos == 128 * 10)\n    {\n      MHD_add_response_header (*responseptr, \"Footer\", \"working\");\n      return MHD_CONTENT_READER_END_OF_STREAM;\n    }\n  if (max < 128)\n    abort ();                   /* should not happen in this testcase... */\n  memset (buf, 'A' + (pos / 128), 128);\n  return 128;\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "ssize_t"
      ]
    },
    "crcf": {
      "start_point": [
        82,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "static void\ncrcf (void *ptr)\n{\n  free (ptr);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "ahc_echo": {
      "start_point": [
        88,
        0
      ],
      "end_point": [
        120,
        1
      ],
      "content": "static int\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data, size_t *upload_data_size, void **ptr)\n{\n  static int aptr;\n  const char *me = cls;\n  struct MHD_Response *response;\n  struct MHD_Response **responseptr;\n  int ret;\n  (void)url;(void)version;                      /* Unused. Silent compiler warning. */\n  (void)upload_data;(void)upload_data_size;     /* Unused. Silent compiler warning. */\n\n  if (0 != strcmp (me, method))\n    return MHD_NO;              /* unexpected method */\n  if (&aptr != *ptr)\n    {\n      /* do never respond on first call */\n      *ptr = &aptr;\n      return MHD_YES;\n    }\n  responseptr = malloc (sizeof (struct MHD_Response *));\n  response = MHD_create_response_from_callback (MHD_SIZE_UNKNOWN,\n                                                1024,\n                                                &crc, responseptr, &crcf);\n  *responseptr = response;\n  ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n  MHD_destroy_response (response);\n  return ret;\n}",
      "lines": 33,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testInternalGet": {
      "start_point": [
        122,
        0
      ],
      "end_point": [
        161,
        1
      ],
      "content": "static int\ntestInternalGet ()\n{\n  struct MHD_Daemon *d;\n  CURL *c;\n  char buf[2048];\n  struct CBC cbc;\n  int i;\n\n  cbc.buf = buf;\n  cbc.size = 2048;\n  cbc.pos = 0;\n  d = MHD_start_daemon (MHD_USE_INTERNAL_POLLING_THREAD /* | MHD_USE_ERROR_LOG */ ,\n                        11080, NULL, NULL, &ahc_echo, \"GET\", MHD_OPTION_END);\n  if (d == NULL)\n    return 1;\n  zzuf_socat_start ();\n  for (i = 0; i < LOOP_COUNT; i++)\n    {\n      fprintf (stderr, \".\");\n      c = curl_easy_init ();\n      curl_easy_setopt (c, CURLOPT_URL, \"http://127.0.0.1:11081/hello_world\");\n      curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n      curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc);\n      curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n      curl_easy_setopt (c, CURLOPT_TIMEOUT_MS, CURL_TIMEOUT);\n      curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT_MS, CURL_TIMEOUT);\n      curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n      /* NOTE: use of CONNECTTIMEOUT without also\n       *   setting NOSIGNAL results in really weird\n       *   crashes on my system! */\n      curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n      curl_easy_perform (c);\n      curl_easy_cleanup (c);\n    }\n  fprintf (stderr, \"\\n\");\n  zzuf_socat_stop ();\n  MHD_stop_daemon (d);\n  return 0;\n}",
      "lines": 40,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testMultithreadedGet": {
      "start_point": [
        163,
        0
      ],
      "end_point": [
        202,
        1
      ],
      "content": "static int\ntestMultithreadedGet ()\n{\n  struct MHD_Daemon *d;\n  CURL *c;\n  char buf[2048];\n  struct CBC cbc;\n  int i;\n\n  cbc.buf = buf;\n  cbc.size = 2048;\n  cbc.pos = 0;\n  d = MHD_start_daemon (MHD_USE_THREAD_PER_CONNECTION | MHD_USE_INTERNAL_POLLING_THREAD /* | MHD_USE_ERROR_LOG */ ,\n                        11080, NULL, NULL, &ahc_echo, \"GET\", MHD_OPTION_END);\n  if (d == NULL)\n    return 16;\n  zzuf_socat_start ();\n  for (i = 0; i < LOOP_COUNT; i++)\n    {\n      fprintf (stderr, \".\");\n      c = curl_easy_init ();\n      curl_easy_setopt (c, CURLOPT_URL, \"http://127.0.0.1:11081/hello_world\");\n      curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n      curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc);\n      curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n      curl_easy_setopt (c, CURLOPT_TIMEOUT_MS, CURL_TIMEOUT);\n      curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n      curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT_MS, CURL_TIMEOUT);\n      /* NOTE: use of CONNECTTIMEOUT without also\n       *   setting NOSIGNAL results in really weird\n       *   crashes on my system! */\n      curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n      curl_easy_perform (c);\n      curl_easy_cleanup (c);\n    }\n  fprintf (stderr, \"\\n\");\n  zzuf_socat_stop ();\n  MHD_stop_daemon (d);\n  return 0;\n}",
      "lines": 40,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testExternalGet": {
      "start_point": [
        205,
        0
      ],
      "end_point": [
        313,
        1
      ],
      "content": "static int\ntestExternalGet ()\n{\n  struct MHD_Daemon *d;\n  CURL *c;\n  char buf[2048];\n  struct CBC cbc;\n  CURLM *multi;\n  CURLMcode mret;\n  fd_set rs;\n  fd_set ws;\n  fd_set es;\n  int max;\n  int running;\n  time_t start;\n  struct timeval tv;\n  int i;\n\n  multi = NULL;\n  cbc.buf = buf;\n  cbc.size = 2048;\n  cbc.pos = 0;\n  d = MHD_start_daemon (MHD_NO_FLAG /* | MHD_USE_ERROR_LOG */ ,\n                        11080, NULL, NULL, &ahc_echo, \"GET\", MHD_OPTION_END);\n  if (d == NULL)\n    return 256;\n  multi = curl_multi_init ();\n  if (multi == NULL)\n    {\n      MHD_stop_daemon (d);\n      return 512;\n    }\n  zzuf_socat_start ();\n  for (i = 0; i < LOOP_COUNT; i++)\n    {\n      fprintf (stderr, \".\");\n      c = curl_easy_init ();\n      curl_easy_setopt (c, CURLOPT_URL, \"http://127.0.0.1:11081/hello_world\");\n      curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n      curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc);\n      curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n      curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n      curl_easy_setopt (c, CURLOPT_TIMEOUT_MS, CURL_TIMEOUT);\n      curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT_MS, CURL_TIMEOUT);\n      /* NOTE: use of CONNECTTIMEOUT without also\n       *   setting NOSIGNAL results in really weird\n       *   crashes on my system! */\n      curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n      mret = curl_multi_add_handle (multi, c);\n      if (mret != CURLM_OK)\n        {\n          curl_multi_cleanup (multi);\n          curl_easy_cleanup (c);\n          zzuf_socat_stop ();\n          MHD_stop_daemon (d);\n          return 1024;\n        }\n      start = time (NULL);\n      while ((time (NULL) - start < 5) && (c != NULL))\n        {\n          max = 0;\n          FD_ZERO (&rs);\n          FD_ZERO (&ws);\n          FD_ZERO (&es);\n          curl_multi_perform (multi, &running);\n          mret = curl_multi_fdset (multi, &rs, &ws, &es, &max);\n          if (mret != CURLM_OK)\n            {\n              curl_multi_remove_handle (multi, c);\n              curl_multi_cleanup (multi);\n              curl_easy_cleanup (c);\n              zzuf_socat_stop ();\n              MHD_stop_daemon (d);\n              return 2048;\n            }\n          if (MHD_YES != MHD_get_fdset (d, &rs, &ws, &es, &max))\n            {\n              curl_multi_remove_handle (multi, c);\n              curl_multi_cleanup (multi);\n              curl_easy_cleanup (c);\n              zzuf_socat_stop ();\n              MHD_stop_daemon (d);\n              return 4096;\n            }\n          tv.tv_sec = 0;\n          tv.tv_usec = 1000;\n          select (max + 1, &rs, &ws, &es, &tv);\n          curl_multi_perform (multi, &running);\n          if (running == 0)\n            {\n              curl_multi_info_read (multi, &running);\n              curl_multi_remove_handle (multi, c);\n              curl_easy_cleanup (c);\n              c = NULL;\n            }\n          MHD_run (d);\n        }\n      if (c != NULL)\n        {\n          curl_multi_remove_handle (multi, c);\n          curl_easy_cleanup (c);\n        }\n    }\n  fprintf (stderr, \"\\n\");\n  curl_multi_cleanup (multi);\n  zzuf_socat_stop ();\n  MHD_stop_daemon (d);\n  return 0;\n}",
      "lines": 109,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        317,
        0
      ],
      "end_point": [
        332,
        1
      ],
      "content": "int\nmain (int argc, char *const *argv)\n{\n  unsigned int errorCount = 0;\n  (void)argc; (void)argv; /* Unused. Silent compiler warning. */\n\n  if (0 != curl_global_init (CURL_GLOBAL_WIN32))\n    return 2;\n  errorCount += testInternalGet ();\n  errorCount += testMultithreadedGet ();\n  errorCount += testExternalGet ();\n  if (errorCount != 0)\n    fprintf (stderr, \"Error (code: %u)\\n\", errorCount);\n  curl_global_cleanup ();\n  return errorCount != 0;       /* 0 == pass */\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/testzzuf/test_long_header.c": {
    "apc_all": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "static int\napc_all (void *cls, const struct sockaddr *addr, socklen_t addrlen)\n{\n  (void)cls;(void)addr;(void)addrlen;   /* Unused. Silent compiler warning. */\n  return MHD_YES;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "copyBuffer": {
      "start_point": [
        63,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "static size_t\ncopyBuffer (void *ptr, size_t size, size_t nmemb, void *ctx)\n{\n  (void)ptr;(void)ctx;  /* Unused. Silent compiler warning. */\n  return size * nmemb;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "ahc_echo": {
      "start_point": [
        70,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "static int\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data, size_t *upload_data_size,\n          void **unused)\n{\n  const char *me = cls;\n  struct MHD_Response *response;\n  int ret;\n  (void)version;(void)upload_data;      /* Unused. Silent compiler warning. */\n  (void)upload_data_size;(void)unused;  /* Unused. Silent compiler warning. */\n\n  if (0 != strcmp (me, method))\n    return MHD_NO;              /* unexpected method */\n  response = MHD_create_response_from_buffer (strlen (url),\n\t\t\t\t\t      (void *) url,\n\t\t\t\t\t      MHD_RESPMEM_MUST_COPY);\n  ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n  MHD_destroy_response (response);\n  return ret;\n}",
      "lines": 24,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testLongUrlGet": {
      "start_point": [
        96,
        0
      ],
      "end_point": [
        154,
        1
      ],
      "content": "static int\ntestLongUrlGet ()\n{\n  struct MHD_Daemon *d;\n  CURL *c;\n  char buf[2048];\n  struct CBC cbc;\n  char *url;\n  int i;\n\n  cbc.buf = buf;\n  cbc.size = 2048;\n  cbc.pos = 0;\n  d = MHD_start_daemon (MHD_USE_INTERNAL_POLLING_THREAD /* | MHD_USE_ERROR_LOG */ ,\n                        11080,\n                        &apc_all,\n                        NULL,\n                        &ahc_echo,\n                        \"GET\",\n                        MHD_OPTION_CONNECTION_MEMORY_LIMIT,\n                        (size_t) (VERY_LONG / 2), MHD_OPTION_END);\n\n  if (d == NULL)\n    return 1;\n  zzuf_socat_start ();\n  for (i = 0; i < LOOP_COUNT; i++)\n    {\n      fprintf (stderr, \".\");\n\n      c = curl_easy_init ();\n      url = malloc (VERY_LONG);\n      memset (url, 'a', VERY_LONG);\n      url[VERY_LONG - 1] = '\\0';\n      memcpy (url, \"http://127.0.0.1:11081/\",\n              strlen (\"http://127.0.0.1:11081/\"));\n      curl_easy_setopt (c, CURLOPT_URL, url);\n      curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n      curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc);\n      curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n      curl_easy_setopt (c, CURLOPT_TIMEOUT_MS, CURL_TIMEOUT);\n      curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT_MS, CURL_TIMEOUT);\n      if (oneone)\n        curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n      else\n        curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0);\n      /* NOTE: use of CONNECTTIMEOUT without also\n       *   setting NOSIGNAL results in really weird\n       *   crashes on my system! */\n      curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n      curl_easy_perform (c);\n      curl_easy_cleanup (c);\n    }\n  fprintf (stderr, \"\\n\");\n  zzuf_socat_stop ();\n\n  MHD_stop_daemon (d);\n  free (url);\n  return 0;\n}",
      "lines": 59,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testLongHeaderGet": {
      "start_point": [
        157,
        0
      ],
      "end_point": [
        219,
        1
      ],
      "content": "static int\ntestLongHeaderGet ()\n{\n  struct MHD_Daemon *d;\n  CURL *c;\n  char buf[2048];\n  struct CBC cbc;\n  char *url;\n  struct curl_slist *header = NULL;\n  int i;\n\n  cbc.buf = buf;\n  cbc.size = 2048;\n  cbc.pos = 0;\n  d = MHD_start_daemon (MHD_USE_INTERNAL_POLLING_THREAD /* | MHD_USE_ERROR_LOG */ ,\n                        11080,\n                        &apc_all,\n                        NULL,\n                        &ahc_echo,\n                        \"GET\",\n                        MHD_OPTION_CONNECTION_MEMORY_LIMIT,\n                        (size_t) (VERY_LONG / 2), MHD_OPTION_END);\n  if (d == NULL)\n    return 16;\n  zzuf_socat_start ();\n  for (i = 0; i < LOOP_COUNT; i++)\n    {\n      fprintf (stderr, \".\");\n      c = curl_easy_init ();\n      url = malloc (VERY_LONG);\n      memset (url, 'a', VERY_LONG);\n      url[VERY_LONG - 1] = '\\0';\n      url[VERY_LONG / 2] = ':';\n      url[VERY_LONG / 2 + 1] = ' ';\n      header = curl_slist_append (header, url);\n\n      curl_easy_setopt (c, CURLOPT_HTTPHEADER, header);\n      curl_easy_setopt (c, CURLOPT_URL, \"http://127.0.0.1:11081/hello_world\");\n      curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n      curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc);\n      curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n      curl_easy_setopt (c, CURLOPT_TIMEOUT_MS, CURL_TIMEOUT);\n      curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT_MS, CURL_TIMEOUT);\n      if (oneone)\n        curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n      else\n        curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0);\n      /* NOTE: use of CONNECTTIMEOUT without also\n       *   setting NOSIGNAL results in really weird\n       *   crashes on my system! */\n      curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n      curl_easy_perform (c);\n      curl_slist_free_all (header);\n      header = NULL;\n      curl_easy_cleanup (c);\n    }\n  fprintf (stderr, \"\\n\");\n  zzuf_socat_stop ();\n\n  MHD_stop_daemon (d);\n  free (url);\n  return 0;\n}",
      "lines": 63,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        222,
        0
      ],
      "end_point": [
        238,
        1
      ],
      "content": "int\nmain (int argc, char *const *argv)\n{\n  unsigned int errorCount = 0;\n  (void)argc;   /* Unused. Silent compiler warning. */\n\n  oneone = (NULL != strrchr (argv[0], (int) '/')) ?\n    (NULL != strstr (strrchr (argv[0], (int) '/'), \"11\")) : 0;\n  if (0 != curl_global_init (CURL_GLOBAL_WIN32))\n    return 2;\n  errorCount += testLongUrlGet ();\n  errorCount += testLongHeaderGet ();\n  if (errorCount != 0)\n    fprintf (stderr, \"Error (code: %u)\\n\", errorCount);\n  curl_global_cleanup ();\n  return errorCount != 0;       /* 0 == pass */\n}",
      "lines": 17,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/testzzuf/test_post.c": {
    "completed_cb": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        65,
        1
      ],
      "content": "static void\ncompleted_cb (void *cls,\n\t      struct MHD_Connection *connection,\n\t      void **con_cls,\n\t      enum MHD_RequestTerminationCode toe)\n{\n  struct MHD_PostProcessor *pp = *con_cls;\n  (void)cls;(void)connection;(void)toe; /* Unused. Silent compiler warning. */\n\n  if (NULL != pp)\n    MHD_destroy_post_processor (pp);\n  *con_cls = NULL;\n}",
      "lines": 13,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "copyBuffer": {
      "start_point": [
        68,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "static size_t\ncopyBuffer (void *ptr, size_t size, size_t nmemb, void *ctx)\n{\n  struct CBC *cbc = ctx;\n\n  if (cbc->pos + size * nmemb > cbc->size)\n    return 0;                   /* overflow */\n  memcpy (&cbc->buf[cbc->pos], ptr, size * nmemb);\n  cbc->pos += size * nmemb;\n  return size * nmemb;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "post_iterator": {
      "start_point": [
        86,
        0
      ],
      "end_point": [
        106,
        1
      ],
      "content": "static int\npost_iterator (void *cls,\n               enum MHD_ValueKind kind,\n               const char *key,\n               const char *filename,\n               const char *content_type,\n               const char *transfer_encoding,\n               const char *value, uint64_t off, size_t size)\n{\n  int *eok = cls;\n  (void)kind;(void)filename;(void)content_type; /* Unused. Silent compiler warning. */\n  (void)transfer_encoding;(void)off;            /* Unused. Silent compiler warning. */\n\n  if ((0 == strcmp (key, \"name\")) &&\n      (size == strlen (\"daniel\")) && (0 == strncmp (value, \"daniel\", size)))\n    (*eok) |= 1;\n  if ((0 == strcmp (key, \"project\")) &&\n      (size == strlen (\"curl\")) && (0 == strncmp (value, \"curl\", size)))\n    (*eok) |= 2;\n  return MHD_YES;\n}",
      "lines": 21,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "ahc_echo": {
      "start_point": [
        108,
        0
      ],
      "end_point": [
        148,
        1
      ],
      "content": "static int\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data, size_t *upload_data_size,\n          void **unused)\n{\n  static int eok;\n  struct MHD_Response *response;\n  struct MHD_PostProcessor *pp;\n  int ret;\n  (void)cls;(void)version;      /* Unused. Silent compiler warning. */\n\n  if (0 != strcmp (\"POST\", method))\n    {\n      return MHD_NO;            /* unexpected method */\n    }\n  pp = *unused;\n  if (pp == NULL)\n    {\n      eok = 0;\n      pp = MHD_create_post_processor (connection, 1024, &post_iterator, &eok);\n      *unused = pp;\n    }\n  MHD_post_process (pp, upload_data, *upload_data_size);\n  if ((eok == 3) && (0 == *upload_data_size))\n    {\n      response = MHD_create_response_from_buffer (strlen (url),\n\t\t\t\t\t\t  (void *) url,\n\t\t\t\t\t\t  MHD_RESPMEM_MUST_COPY);\n      ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n      MHD_destroy_response (response);\n      MHD_destroy_post_processor (pp);\n      *unused = NULL;\n      return ret;\n    }\n  *upload_data_size = 0;\n  return MHD_YES;\n}",
      "lines": 41,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testInternalPost": {
      "start_point": [
        151,
        0
      ],
      "end_point": [
        200,
        1
      ],
      "content": "static int\ntestInternalPost ()\n{\n  struct MHD_Daemon *d;\n  CURL *c;\n  char buf[2048];\n  struct CBC cbc;\n  int i;\n\n  cbc.buf = buf;\n  cbc.size = 2048;\n  cbc.pos = 0;\n  d = MHD_start_daemon (MHD_USE_INTERNAL_POLLING_THREAD /* | MHD_USE_ERROR_LOG */ ,\n                        11080, NULL, NULL, &ahc_echo, NULL, \n\t\t\tMHD_OPTION_NOTIFY_COMPLETED, &completed_cb, NULL,\t\t\t\n\t\t\tMHD_OPTION_END);\n  if (d == NULL)\n    return 1;\n  zzuf_socat_start ();\n  for (i = 0; i < LOOP_COUNT; i++)\n    {\n      fprintf (stderr, \".\");\n\n      c = curl_easy_init ();\n      curl_easy_setopt (c, CURLOPT_URL, \"http://127.0.0.1:11081/hello_world\");\n      curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n      curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc);\n      curl_easy_setopt (c, CURLOPT_POSTFIELDS, POST_DATA);\n      curl_easy_setopt (c, CURLOPT_POSTFIELDSIZE, strlen (POST_DATA));\n      curl_easy_setopt (c, CURLOPT_POST, 1L);\n      curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n      curl_easy_setopt (c, CURLOPT_TIMEOUT_MS, CURL_TIMEOUT);\n      if (oneone)\n        curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n      else\n        curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0);\n      curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT_MS, CURL_TIMEOUT);\n      /* NOTE: use of CONNECTTIMEOUT without also\n       *   setting NOSIGNAL results in really weird\n       *   crashes on my system! */\n      curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n      curl_easy_perform (c);\n      curl_easy_cleanup (c);\n    }\n  fprintf (stderr, \"\\n\");\n  zzuf_socat_stop ();\n  MHD_stop_daemon (d);\n\n  return 0;\n}",
      "lines": 50,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testMultithreadedPost": {
      "start_point": [
        202,
        0
      ],
      "end_point": [
        252,
        1
      ],
      "content": "static int\ntestMultithreadedPost ()\n{\n  struct MHD_Daemon *d;\n  CURL *c;\n  char buf[2048];\n  struct CBC cbc;\n  int i;\n\n  cbc.buf = buf;\n  cbc.size = 2048;\n  cbc.pos = 0;\n  d = MHD_start_daemon (MHD_USE_THREAD_PER_CONNECTION | MHD_USE_INTERNAL_POLLING_THREAD /* | MHD_USE_ERROR_LOG */ ,\n                        11080, NULL, NULL, &ahc_echo, NULL, \n\t\t\tMHD_OPTION_NOTIFY_COMPLETED, &completed_cb, NULL,\n\t\t\tMHD_OPTION_END);\n  if (d == NULL)\n    return 16;\n\n  zzuf_socat_start ();\n  for (i = 0; i < LOOP_COUNT; i++)\n    {\n      fprintf (stderr, \".\");\n\n      c = curl_easy_init ();\n      curl_easy_setopt (c, CURLOPT_URL, \"http://127.0.0.1:11081/hello_world\");\n      curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n      curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc);\n      curl_easy_setopt (c, CURLOPT_POSTFIELDS, POST_DATA);\n      curl_easy_setopt (c, CURLOPT_POSTFIELDSIZE, strlen (POST_DATA));\n      curl_easy_setopt (c, CURLOPT_POST, 1L);\n      curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n      curl_easy_setopt (c, CURLOPT_TIMEOUT_MS, CURL_TIMEOUT);\n      if (oneone)\n        curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n      else\n        curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0);\n      curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT_MS, CURL_TIMEOUT);\n      /* NOTE: use of CONNECTTIMEOUT without also\n       *   setting NOSIGNAL results in really weird\n       *   crashes on my system! */\n      curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n      curl_easy_perform (c);\n      curl_easy_cleanup (c);\n    }\n  fprintf (stderr, \"\\n\");\n  zzuf_socat_stop ();\n\n  MHD_stop_daemon (d);\n  return 0;\n}",
      "lines": 51,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testExternalPost": {
      "start_point": [
        255,
        0
      ],
      "end_point": [
        378,
        1
      ],
      "content": "static int\ntestExternalPost ()\n{\n  struct MHD_Daemon *d;\n  CURL *c;\n  char buf[2048];\n  struct CBC cbc;\n  CURLM *multi;\n  CURLMcode mret;\n  fd_set rs;\n  fd_set ws;\n  fd_set es;\n  int max;\n  int running;\n  time_t start;\n  struct timeval tv;\n  int i;\n\n  multi = NULL;\n  cbc.buf = buf;\n  cbc.size = 2048;\n  cbc.pos = 0;\n  d = MHD_start_daemon (MHD_NO_FLAG /* | MHD_USE_ERROR_LOG */ ,\n                        1082, NULL, NULL, &ahc_echo, NULL, \n\t\t\tMHD_OPTION_NOTIFY_COMPLETED, &completed_cb, NULL,\n\t\t\tMHD_OPTION_END);\n  if (d == NULL)\n    return 256;\n  multi = curl_multi_init ();\n  if (multi == NULL)\n    {\n      MHD_stop_daemon (d);\n      return 512;\n    }\n\n  zzuf_socat_start ();\n  for (i = 0; i < LOOP_COUNT; i++)\n    {\n      fprintf (stderr, \".\");\n\n\n      c = curl_easy_init ();\n      curl_easy_setopt (c, CURLOPT_URL, \"http://127.0.0.1:1082/hello_world\");\n      curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n      curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc);\n      curl_easy_setopt (c, CURLOPT_POSTFIELDS, POST_DATA);\n      curl_easy_setopt (c, CURLOPT_POSTFIELDSIZE, strlen (POST_DATA));\n      curl_easy_setopt (c, CURLOPT_POST, 1L);\n      curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n      curl_easy_setopt (c, CURLOPT_TIMEOUT_MS, CURL_TIMEOUT);\n      if (oneone)\n        curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n      else\n        curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0);\n      curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT_MS, CURL_TIMEOUT);\n      /* NOTE: use of CONNECTTIMEOUT without also\n       *   setting NOSIGNAL results in really weird\n       *   crashes on my system! */\n      curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n\n\n      mret = curl_multi_add_handle (multi, c);\n      if (mret != CURLM_OK)\n        {\n          curl_multi_cleanup (multi);\n          curl_easy_cleanup (c);\n          zzuf_socat_stop ();\n          MHD_stop_daemon (d);\n          return 1024;\n        }\n      start = time (NULL);\n      while ((time (NULL) - start < 5) && (c != NULL))\n        {\n          max = 0;\n          FD_ZERO (&rs);\n          FD_ZERO (&ws);\n          FD_ZERO (&es);\n          curl_multi_perform (multi, &running);\n          mret = curl_multi_fdset (multi, &rs, &ws, &es, &max);\n          if (mret != CURLM_OK)\n            {\n              curl_multi_remove_handle (multi, c);\n              curl_multi_cleanup (multi);\n              curl_easy_cleanup (c);\n              zzuf_socat_stop ();\n              MHD_stop_daemon (d);\n              return 2048;\n            }\n          if (MHD_YES != MHD_get_fdset (d, &rs, &ws, &es, &max))\n            {\n              curl_multi_remove_handle (multi, c);\n              curl_multi_cleanup (multi);\n              curl_easy_cleanup (c);\n              zzuf_socat_stop ();\n              MHD_stop_daemon (d);\n              return 4096;\n            }\n          tv.tv_sec = 0;\n          tv.tv_usec = 1000;\n          select (max + 1, &rs, &ws, &es, &tv);\n          curl_multi_perform (multi, &running);\n          if (running == 0)\n            {\n              curl_multi_info_read (multi, &running);\n              curl_multi_remove_handle (multi, c);\n              curl_easy_cleanup (c);\n              c = NULL;\n            }\n          MHD_run (d);\n        }\n      if (c != NULL)\n        {\n          curl_multi_remove_handle (multi, c);\n          curl_easy_cleanup (c);\n        }\n\n    }\n  fprintf (stderr, \"\\n\");\n  curl_multi_cleanup (multi);\n  zzuf_socat_stop ();\n\n  MHD_stop_daemon (d);\n  return 0;\n}",
      "lines": 124,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        381,
        0
      ],
      "end_point": [
        398,
        1
      ],
      "content": "int\nmain (int argc, char *const *argv)\n{\n  unsigned int errorCount = 0;\n  (void)argc;   /* Unused. Silent compiler warning. */\n\n  oneone = (NULL != strrchr (argv[0], (int) '/')) ?\n    (NULL != strstr (strrchr (argv[0], (int) '/'), \"11\")) : 0;\n  if (0 != curl_global_init (CURL_GLOBAL_WIN32))\n    return 2;\n  errorCount += testInternalPost ();\n  errorCount += testMultithreadedPost ();\n  errorCount += testExternalPost ();\n  if (errorCount != 0)\n    fprintf (stderr, \"Error (code: %u)\\n\", errorCount);\n  curl_global_cleanup ();\n  return errorCount != 0;       /* 0 == pass */\n}",
      "lines": 18,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/testzzuf/test_post_form.c": {
    "completed_cb": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        63,
        1
      ],
      "content": "static void\ncompleted_cb (void *cls,\n\t      struct MHD_Connection *connection,\n\t      void **con_cls,\n\t      enum MHD_RequestTerminationCode toe)\n{\n  struct MHD_PostProcessor *pp = *con_cls;\n  (void)cls;(void)connection;(void)toe;            /* Unused. Silent compiler warning. */\n\n  if (NULL != pp)\n    MHD_destroy_post_processor (pp);\n  *con_cls = NULL;\n}",
      "lines": 13,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "copyBuffer": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "static size_t\ncopyBuffer (void *ptr, size_t size, size_t nmemb, void *ctx)\n{\n  struct CBC *cbc = ctx;\n\n  if (cbc->pos + size * nmemb > cbc->size)\n    return 0;                   /* overflow */\n  memcpy (&cbc->buf[cbc->pos], ptr, size * nmemb);\n  cbc->pos += size * nmemb;\n  return size * nmemb;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "post_iterator": {
      "start_point": [
        83,
        0
      ],
      "end_point": [
        108,
        1
      ],
      "content": "static int\npost_iterator (void *cls,\n               enum MHD_ValueKind kind,\n               const char *key,\n               const char *filename,\n               const char *content_type,\n               const char *transfer_encoding,\n               const char *value, uint64_t off, size_t size)\n{\n  int *eok = cls;\n  (void)kind;(void)filename;(void)content_type; /* Unused. Silent compiler warning. */\n  (void)transfer_encoding;(void)off;            /* Unused. Silent compiler warning. */\n\n  if (key == NULL)\n    return MHD_YES;\n#if 0\n  fprintf (stderr, \"PI sees %s-%.*s\\n\", key, size, value);\n#endif\n  if ((0 == strcmp (key, \"name\")) &&\n      (size == strlen (\"daniel\")) && (0 == strncmp (value, \"daniel\", size)))\n    (*eok) |= 1;\n  if ((0 == strcmp (key, \"project\")) &&\n      (size == strlen (\"curl\")) && (0 == strncmp (value, \"curl\", size)))\n    (*eok) |= 2;\n  return MHD_YES;\n}",
      "lines": 26,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "ahc_echo": {
      "start_point": [
        111,
        0
      ],
      "end_point": [
        153,
        1
      ],
      "content": "static int\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data, size_t *upload_data_size,\n          void **unused)\n{\n  static int eok;\n  struct MHD_Response *response;\n  struct MHD_PostProcessor *pp;\n  int ret;\n  (void)cls;(void)version;      /* Unused. Silent compiler warning. */\n\n  if (0 != strcmp (\"POST\", method))\n    {\n      return MHD_NO;            /* unexpected method */\n    }\n  pp = *unused;\n  if (pp == NULL)\n    {\n      eok = 0;\n      pp = MHD_create_post_processor (connection, 1024, &post_iterator, &eok);\n      if (pp == NULL)\n        return MHD_NO;\n      *unused = pp;\n    }\n  MHD_post_process (pp, upload_data, *upload_data_size);\n  if ((eok == 3) && (0 == *upload_data_size))\n    {\n      response = MHD_create_response_from_buffer (strlen (url),\n\t\t\t\t\t\t  (void *) url,\n\t\t\t\t\t\t  MHD_RESPMEM_MUST_COPY);\n      ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n      MHD_destroy_response (response);\n      MHD_destroy_post_processor (pp);\n      *unused = NULL;\n      return ret;\n    }\n  *upload_data_size = 0;\n  return MHD_YES;\n}",
      "lines": 43,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "make_form": {
      "start_point": [
        155,
        0
      ],
      "end_point": [
        166,
        1
      ],
      "content": "static struct curl_httppost *\nmake_form ()\n{\n  struct curl_httppost *post = NULL;\n  struct curl_httppost *last = NULL;\n\n  curl_formadd (&post, &last, CURLFORM_COPYNAME, \"name\",\n                CURLFORM_COPYCONTENTS, \"daniel\", CURLFORM_END);\n  curl_formadd (&post, &last, CURLFORM_COPYNAME, \"project\",\n                CURLFORM_COPYCONTENTS, \"curl\", CURLFORM_END);\n  return post;\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "struct curl_httppost",
        "struct",
        "curl_httppost",
        "*\nmake_form ()",
        "*"
      ]
    },
    "testInternalPost": {
      "start_point": [
        169,
        0
      ],
      "end_point": [
        217,
        1
      ],
      "content": "static int\ntestInternalPost ()\n{\n  struct MHD_Daemon *d;\n  CURL *c;\n  char buf[2048];\n  struct CBC cbc;\n  int i;\n  struct curl_httppost *pd;\n\n  cbc.buf = buf;\n  cbc.size = 2048;\n  cbc.pos = 0;\n  d = MHD_start_daemon (MHD_USE_INTERNAL_POLLING_THREAD /* | MHD_USE_ERROR_LOG */ ,\n                        11080, NULL, NULL, &ahc_echo, NULL, \n\t\t\tMHD_OPTION_NOTIFY_COMPLETED, &completed_cb, NULL,\n\t\t\tMHD_OPTION_END);\n  if (d == NULL)\n    return 1;\n  zzuf_socat_start ();\n  for (i = 0; i < LOOP_COUNT; i++)\n    {\n      fprintf (stderr, \".\");\n      c = curl_easy_init ();\n      curl_easy_setopt (c, CURLOPT_URL, \"http://127.0.0.1:11081/hello_world\");\n      curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n      curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc);\n      pd = make_form ();\n      curl_easy_setopt (c, CURLOPT_HTTPPOST, pd);\n      curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n      curl_easy_setopt (c, CURLOPT_TIMEOUT_MS, CURL_TIMEOUT);\n      if (oneone)\n        curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n      else\n        curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0);\n      curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT_MS, CURL_TIMEOUT);\n      /* NOTE: use of CONNECTTIMEOUT without also\n       *   setting NOSIGNAL results in really weird\n       *   crashes on my system! */\n      curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n      curl_easy_perform (c);\n      curl_easy_cleanup (c);\n      curl_formfree (pd);\n    }\n  fprintf (stderr, \"\\n\");\n  zzuf_socat_stop ();\n  MHD_stop_daemon (d);\n  return 0;\n}",
      "lines": 49,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testMultithreadedPost": {
      "start_point": [
        220,
        0
      ],
      "end_point": [
        268,
        1
      ],
      "content": "static int\ntestMultithreadedPost ()\n{\n  struct MHD_Daemon *d;\n  CURL *c;\n  char buf[2048];\n  struct CBC cbc;\n  int i;\n  struct curl_httppost *pd;\n\n  cbc.buf = buf;\n  cbc.size = 2048;\n  cbc.pos = 0;\n  d = MHD_start_daemon (MHD_USE_THREAD_PER_CONNECTION | MHD_USE_INTERNAL_POLLING_THREAD /* | MHD_USE_ERROR_LOG */ ,\n                        11080, NULL, NULL, &ahc_echo, NULL, \n\t\t\tMHD_OPTION_NOTIFY_COMPLETED, &completed_cb, NULL,\n\t\t\tMHD_OPTION_END);\n  if (d == NULL)\n    return 16;\n  zzuf_socat_start ();\n  for (i = 0; i < LOOP_COUNT; i++)\n    {\n      fprintf (stderr, \".\");\n      c = curl_easy_init ();\n      curl_easy_setopt (c, CURLOPT_URL, \"http://127.0.0.1:11081/hello_world\");\n      curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n      curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc);\n      pd = make_form ();\n      curl_easy_setopt (c, CURLOPT_HTTPPOST, pd);\n      curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n      curl_easy_setopt (c, CURLOPT_TIMEOUT_MS, CURL_TIMEOUT);\n      if (oneone)\n        curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n      else\n        curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0);\n      curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT_MS, CURL_TIMEOUT);\n      /* NOTE: use of CONNECTTIMEOUT without also\n       *   setting NOSIGNAL results in really weird\n       *   crashes on my system! */\n      curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n      curl_easy_perform (c);\n      curl_easy_cleanup (c);\n      curl_formfree (pd);\n    }\n  fprintf (stderr, \"\\n\");\n  zzuf_socat_stop ();\n  MHD_stop_daemon (d);\n  return 0;\n}",
      "lines": 49,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testExternalPost": {
      "start_point": [
        271,
        0
      ],
      "end_point": [
        394,
        1
      ],
      "content": "static int\ntestExternalPost ()\n{\n  struct MHD_Daemon *d;\n  CURL *c;\n  char buf[2048];\n  struct CBC cbc;\n  CURLM *multi;\n  CURLMcode mret;\n  fd_set rs;\n  fd_set ws;\n  fd_set es;\n  int max;\n  int running;\n  time_t start;\n  struct timeval tv;\n  struct curl_httppost *pd;\n  int i;\n\n  multi = NULL;\n  cbc.buf = buf;\n  cbc.size = 2048;\n  cbc.pos = 0;\n  d = MHD_start_daemon (MHD_NO_FLAG /* | MHD_USE_ERROR_LOG */ ,\n                        1082, NULL, NULL, &ahc_echo, NULL, \n\t\t\tMHD_OPTION_NOTIFY_COMPLETED, &completed_cb, NULL,\t\t\t\n\t\t\tMHD_OPTION_END);\n  if (d == NULL)\n    return 256;\n  multi = curl_multi_init ();\n  if (multi == NULL)\n    {\n      MHD_stop_daemon (d);\n      return 512;\n    }\n  zzuf_socat_start ();\n  for (i = 0; i < LOOP_COUNT; i++)\n    {\n      fprintf (stderr, \".\");\n\n      c = curl_easy_init ();\n      curl_easy_setopt (c, CURLOPT_URL, \"http://127.0.0.1:1082/hello_world\");\n      curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n      curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc);\n      pd = make_form ();\n      curl_easy_setopt (c, CURLOPT_HTTPPOST, pd);\n      curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n      curl_easy_setopt (c, CURLOPT_TIMEOUT, 150L);\n      if (oneone)\n        curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n      else\n        curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0);\n      curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT, 15L);\n      /* NOTE: use of CONNECTTIMEOUT without also\n       *   setting NOSIGNAL results in really weird\n       *   crashes on my system! */\n      curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n\n\n      mret = curl_multi_add_handle (multi, c);\n      if (mret != CURLM_OK)\n        {\n          curl_multi_cleanup (multi);\n          curl_formfree (pd);\n          curl_easy_cleanup (c);\n          zzuf_socat_stop ();\n          MHD_stop_daemon (d);\n          return 1024;\n        }\n      start = time (NULL);\n      while ((time (NULL) - start < 5) && (c != NULL))\n        {\n          max = 0;\n          FD_ZERO (&rs);\n          FD_ZERO (&ws);\n          FD_ZERO (&es);\n          curl_multi_perform (multi, &running);\n          mret = curl_multi_fdset (multi, &rs, &ws, &es, &max);\n          if (mret != CURLM_OK)\n            {\n              curl_multi_remove_handle (multi, c);\n              curl_multi_cleanup (multi);\n              curl_easy_cleanup (c);\n              zzuf_socat_stop ();\n              MHD_stop_daemon (d);\n              curl_formfree (pd);\n              return 2048;\n            }\n          if (MHD_YES != MHD_get_fdset (d, &rs, &ws, &es, &max))\n            {\n              curl_multi_remove_handle (multi, c);\n              curl_multi_cleanup (multi);\n              curl_easy_cleanup (c);\n              curl_formfree (pd);\n              zzuf_socat_stop ();\n              MHD_stop_daemon (d);\n              return 4096;\n            }\n          tv.tv_sec = 0;\n          tv.tv_usec = 1000;\n          select (max + 1, &rs, &ws, &es, &tv);\n          curl_multi_perform (multi, &running);\n          if (running == 0)\n            {\n              curl_multi_info_read (multi, &running);\n              curl_multi_remove_handle (multi, c);\n              curl_easy_cleanup (c);\n              c = NULL;\n            }\n          MHD_run (d);\n        }\n      if (c != NULL)\n        {\n          curl_multi_remove_handle (multi, c);\n          curl_easy_cleanup (c);\n        }\n      curl_formfree (pd);\n    }\n  fprintf (stderr, \"\\n\");\n  zzuf_socat_stop ();\n\n  MHD_stop_daemon (d);\n  return 0;\n}",
      "lines": 124,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        397,
        0
      ],
      "end_point": [
        414,
        1
      ],
      "content": "int\nmain (int argc, char *const *argv)\n{\n  unsigned int errorCount = 0;\n  (void)argc;   /* Unused. Silent compiler warning. */\n\n  oneone = (NULL != strrchr (argv[0], (int) '/')) ?\n    (NULL != strstr (strrchr (argv[0], (int) '/'), \"11\")) : 0;\n  if (0 != curl_global_init (CURL_GLOBAL_WIN32))\n    return 2;\n  errorCount += testInternalPost ();\n  errorCount += testMultithreadedPost ();\n  errorCount += testExternalPost ();\n  if (errorCount != 0)\n    fprintf (stderr, \"Error (code: %u)\\n\", errorCount);\n  curl_global_cleanup ();\n  return errorCount != 0;       /* 0 == pass */\n}",
      "lines": 18,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/testzzuf/test_put.c": {
    "putBuffer": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "static size_t\nputBuffer (void *stream, size_t size, size_t nmemb, void *ptr)\n{\n  unsigned int *pos = ptr;\n  unsigned int wrt;\n\n  wrt = size * nmemb;\n  if (wrt > 8 - (*pos))\n    wrt = 8 - (*pos);\n  memcpy (stream, &(\"Hello123\"[*pos]), wrt);\n  (*pos) += wrt;\n  return wrt;\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "copyBuffer": {
      "start_point": [
        64,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "static size_t\ncopyBuffer (void *ptr, size_t size, size_t nmemb, void *ctx)\n{\n  struct CBC *cbc = ctx;\n\n  if (cbc->pos + size * nmemb > cbc->size)\n    return 0;                   /* overflow */\n  memcpy (&cbc->buf[cbc->pos], ptr, size * nmemb);\n  cbc->pos += size * nmemb;\n  return size * nmemb;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "ahc_echo": {
      "start_point": [
        76,
        0
      ],
      "end_point": [
        114,
        1
      ],
      "content": "static int\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data, size_t *upload_data_size,\n          void **unused)\n{\n  int *done = cls;\n  struct MHD_Response *response;\n  int ret;\n  (void)version;(void)unused;   /* Unused. Silent compiler warning. */\n\n  if (0 != strcmp (\"PUT\", method))\n    return MHD_NO;              /* unexpected method */\n  if ((*done) == 0)\n    {\n      if (*upload_data_size != 8)\n        return MHD_YES;         /* not yet ready */\n      if (0 == memcmp (upload_data, \"Hello123\", 8))\n        {\n          *upload_data_size = 0;\n        }\n      else\n        {\n          printf (\"Invalid upload data `%8s'!\\n\", upload_data);\n          return MHD_NO;\n        }\n      *done = 1;\n      return MHD_YES;\n    }\n  response = MHD_create_response_from_buffer (strlen (url),\n\t\t\t\t\t      (void *) url,\n\t\t\t\t\t      MHD_RESPMEM_MUST_COPY);\n  ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n  MHD_destroy_response (response);\n  return ret;\n}",
      "lines": 39,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testInternalPut": {
      "start_point": [
        117,
        0
      ],
      "end_point": [
        166,
        1
      ],
      "content": "static int\ntestInternalPut ()\n{\n  struct MHD_Daemon *d;\n  CURL *c;\n  char buf[2048];\n  struct CBC cbc;\n  unsigned int pos = 0;\n  int done_flag = 0;\n  int i;\n\n  cbc.buf = buf;\n  cbc.size = 2048;\n  cbc.pos = 0;\n  d = MHD_start_daemon (MHD_USE_INTERNAL_POLLING_THREAD /* | MHD_USE_ERROR_LOG */ ,\n                        11080,\n                        NULL, NULL, &ahc_echo, &done_flag, MHD_OPTION_END);\n  if (d == NULL)\n    return 1;\n  zzuf_socat_start ();\n  for (i = 0; i < LOOP_COUNT; i++)\n    {\n      fprintf (stderr, \".\");\n      c = curl_easy_init ();\n      curl_easy_setopt (c, CURLOPT_URL, \"http://127.0.0.1:11081/hello_world\");\n      curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n      curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc);\n      curl_easy_setopt (c, CURLOPT_READFUNCTION, &putBuffer);\n      curl_easy_setopt (c, CURLOPT_READDATA, &pos);\n      curl_easy_setopt (c, CURLOPT_UPLOAD, 1L);\n      curl_easy_setopt (c, CURLOPT_INFILESIZE_LARGE, (curl_off_t) 8L);\n      curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n      curl_easy_setopt (c, CURLOPT_TIMEOUT_MS, CURL_TIMEOUT);\n      if (oneone)\n        curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n      else\n        curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0);\n      curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT_MS, CURL_TIMEOUT);\n      /* NOTE: use of CONNECTTIMEOUT without also\n       *   setting NOSIGNAL results in really weird\n       *   crashes on my system! */\n      curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n      curl_easy_perform (c);\n      curl_easy_cleanup (c);\n    }\n  fprintf (stderr, \"\\n\");\n  zzuf_socat_stop ();\n  MHD_stop_daemon (d);\n  return 0;\n}",
      "lines": 50,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testMultithreadedPut": {
      "start_point": [
        168,
        0
      ],
      "end_point": [
        217,
        1
      ],
      "content": "static int\ntestMultithreadedPut ()\n{\n  struct MHD_Daemon *d;\n  CURL *c;\n  char buf[2048];\n  struct CBC cbc;\n  unsigned int pos = 0;\n  int done_flag = 0;\n  int i;\n\n  cbc.buf = buf;\n  cbc.size = 2048;\n  cbc.pos = 0;\n  d = MHD_start_daemon (MHD_USE_THREAD_PER_CONNECTION | MHD_USE_INTERNAL_POLLING_THREAD /* | MHD_USE_ERROR_LOG */ ,\n                        11080,\n                        NULL, NULL, &ahc_echo, &done_flag, MHD_OPTION_END);\n  if (d == NULL)\n    return 16;\n  zzuf_socat_start ();\n  for (i = 0; i < LOOP_COUNT; i++)\n    {\n      fprintf (stderr, \".\");\n      c = curl_easy_init ();\n      curl_easy_setopt (c, CURLOPT_URL, \"http://127.0.0.1:11081/hello_world\");\n      curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n      curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc);\n      curl_easy_setopt (c, CURLOPT_READFUNCTION, &putBuffer);\n      curl_easy_setopt (c, CURLOPT_READDATA, &pos);\n      curl_easy_setopt (c, CURLOPT_UPLOAD, 1L);\n      curl_easy_setopt (c, CURLOPT_INFILESIZE_LARGE, (curl_off_t) 8L);\n      curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n      curl_easy_setopt (c, CURLOPT_TIMEOUT_MS, CURL_TIMEOUT);\n      if (oneone)\n        curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n      else\n        curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0);\n      curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT_MS, CURL_TIMEOUT);\n      /* NOTE: use of CONNECTTIMEOUT without also\n       *   setting NOSIGNAL results in really weird\n       *   crashes on my system! */\n      curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n      curl_easy_perform (c);\n      curl_easy_cleanup (c);\n    }\n  fprintf (stderr, \"\\n\");\n  zzuf_socat_stop ();\n  MHD_stop_daemon (d);\n  return 0;\n}",
      "lines": 50,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testExternalPut": {
      "start_point": [
        220,
        0
      ],
      "end_point": [
        342,
        1
      ],
      "content": "static int\ntestExternalPut ()\n{\n  struct MHD_Daemon *d;\n  CURL *c;\n  char buf[2048];\n  struct CBC cbc;\n  CURLM *multi;\n  CURLMcode mret;\n  fd_set rs;\n  fd_set ws;\n  fd_set es;\n  int max;\n  int running;\n  time_t start;\n  struct timeval tv;\n  unsigned int pos = 0;\n  int done_flag = 0;\n  int i;\n\n  multi = NULL;\n  cbc.buf = buf;\n  cbc.size = 2048;\n  cbc.pos = 0;\n  d = MHD_start_daemon (MHD_NO_FLAG /* | MHD_USE_ERROR_LOG */ ,\n                        11080,\n                        NULL, NULL, &ahc_echo, &done_flag, MHD_OPTION_END);\n  if (d == NULL)\n    return 256;\n  multi = curl_multi_init ();\n  if (multi == NULL)\n    {\n      MHD_stop_daemon (d);\n      return 512;\n    }\n  zzuf_socat_start ();\n  for (i = 0; i < LOOP_COUNT; i++)\n    {\n      fprintf (stderr, \".\");\n\n      c = curl_easy_init ();\n      curl_easy_setopt (c, CURLOPT_URL, \"http://127.0.0.1:11081/hello_world\");\n      curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n      curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc);\n      curl_easy_setopt (c, CURLOPT_READFUNCTION, &putBuffer);\n      curl_easy_setopt (c, CURLOPT_READDATA, &pos);\n      curl_easy_setopt (c, CURLOPT_UPLOAD, 1L);\n      curl_easy_setopt (c, CURLOPT_INFILESIZE_LARGE, (curl_off_t) 8L);\n      curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n      curl_easy_setopt (c, CURLOPT_TIMEOUT_MS, CURL_TIMEOUT);\n      if (oneone)\n        curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n      else\n        curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0);\n      curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT_MS, CURL_TIMEOUT);\n      /* NOTE: use of CONNECTTIMEOUT without also\n       *   setting NOSIGNAL results in really weird\n       *   crashes on my system! */\n      curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n\n\n\n      mret = curl_multi_add_handle (multi, c);\n      if (mret != CURLM_OK)\n        {\n          curl_multi_cleanup (multi);\n          curl_easy_cleanup (c);\n          zzuf_socat_stop ();\n          MHD_stop_daemon (d);\n          return 1024;\n        }\n      start = time (NULL);\n      while ((time (NULL) - start < 5) && (c != NULL))\n        {\n          max = 0;\n          FD_ZERO (&rs);\n          FD_ZERO (&ws);\n          FD_ZERO (&es);\n          curl_multi_perform (multi, &running);\n          mret = curl_multi_fdset (multi, &rs, &ws, &es, &max);\n          if (mret != CURLM_OK)\n            {\n              curl_multi_remove_handle (multi, c);\n              curl_multi_cleanup (multi);\n              curl_easy_cleanup (c);\n              zzuf_socat_stop ();\n              MHD_stop_daemon (d);\n              return 2048;\n            }\n          if (MHD_YES != MHD_get_fdset (d, &rs, &ws, &es, &max))\n            {\n              curl_multi_remove_handle (multi, c);\n              curl_multi_cleanup (multi);\n              curl_easy_cleanup (c);\n              zzuf_socat_stop ();\n              MHD_stop_daemon (d);\n              return 4096;\n            }\n          tv.tv_sec = 0;\n          tv.tv_usec = 1000;\n          select (max + 1, &rs, &ws, &es, &tv);\n          curl_multi_perform (multi, &running);\n          if (running == 0)\n            {\n              curl_multi_info_read (multi, &running);\n              curl_multi_remove_handle (multi, c);\n              curl_easy_cleanup (c);\n              c = NULL;\n            }\n          MHD_run (d);\n        }\n      if (c != NULL)\n        {\n          curl_multi_remove_handle (multi, c);\n          curl_easy_cleanup (c);\n        }\n    }\n  fprintf (stderr, \"\\n\");\n  curl_multi_cleanup (multi);\n  zzuf_socat_stop ();\n  MHD_stop_daemon (d);\n  return 0;\n}",
      "lines": 123,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        345,
        0
      ],
      "end_point": [
        362,
        1
      ],
      "content": "int\nmain (int argc, char *const *argv)\n{\n  unsigned int errorCount = 0;\n  (void)argc;   /* Unused. Silent compiler warning. */\n\n  oneone = (NULL != strrchr (argv[0], (int) '/')) ?\n    (NULL != strstr (strrchr (argv[0], (int) '/'), \"11\")) : 0;\n  if (0 != curl_global_init (CURL_GLOBAL_WIN32))\n    return 2;\n  errorCount += testInternalPut ();\n  errorCount += testMultithreadedPut ();\n  errorCount += testExternalPut ();\n  if (errorCount != 0)\n    fprintf (stderr, \"Error (code: %u)\\n\", errorCount);\n  curl_global_cleanup ();\n  return errorCount != 0;       /* 0 == pass */\n}",
      "lines": 18,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/testzzuf/test_put_chunked.c": {
    "putBuffer": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "static size_t\nputBuffer (void *stream, size_t size, size_t nmemb, void *ptr)\n{\n  unsigned int *pos = ptr;\n  unsigned int wrt;\n\n  wrt = size * nmemb;\n  if (wrt > 8 - (*pos))\n    wrt = 8 - (*pos);\n  if (wrt > 4)\n    wrt = 4;                    /* only send half at first => force multiple chunks! */\n  memcpy (stream, &(\"Hello123\"[*pos]), wrt);\n  (*pos) += wrt;\n  return wrt;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "copyBuffer": {
      "start_point": [
        64,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "static size_t\ncopyBuffer (void *ptr, size_t size, size_t nmemb, void *ctx)\n{\n  struct CBC *cbc = ctx;\n\n  if (cbc->pos + size * nmemb > cbc->size)\n    return 0;                   /* overflow */\n  memcpy (&cbc->buf[cbc->pos], ptr, size * nmemb);\n  cbc->pos += size * nmemb;\n  return size * nmemb;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "ahc_echo": {
      "start_point": [
        76,
        0
      ],
      "end_point": [
        120,
        1
      ],
      "content": "static int\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data, size_t *upload_data_size,\n          void **unused)\n{\n  int *done = cls;\n  struct MHD_Response *response;\n  int ret;\n  int have;\n  (void)version;(void)unused;   /* Unused. Silent compiler warning. */\n\n  if (0 != strcmp (\"PUT\", method))\n    return MHD_NO;              /* unexpected method */\n  if ((*done) < 8)\n    {\n      have = *upload_data_size;\n      if (have + *done > 8)\n        {\n          return MHD_NO;\n        }\n      if (0 == memcmp (upload_data, &\"Hello123\"[*done], have))\n        {\n          *done += have;\n          *upload_data_size = 0;\n        }\n      else\n        {\n          return MHD_NO;\n        }\n#if 0\n      fprintf (stderr, \"Not ready for response: %u/%u\\n\", *done, 8);\n#endif\n      return MHD_YES;\n    }\n  response = MHD_create_response_from_buffer (strlen (url),\n\t\t\t\t\t      (void *) url,\n\t\t\t\t\t      MHD_RESPMEM_MUST_COPY);\n  ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n  MHD_destroy_response (response);\n  return ret;\n}",
      "lines": 45,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testInternalPut": {
      "start_point": [
        123,
        0
      ],
      "end_point": [
        172,
        1
      ],
      "content": "static int\ntestInternalPut ()\n{\n  struct MHD_Daemon *d;\n  CURL *c;\n  char buf[2048];\n  struct CBC cbc;\n  unsigned int pos = 0;\n  int done_flag = 0;\n  int i;\n\n  cbc.buf = buf;\n  cbc.size = 2048;\n  cbc.pos = 0;\n  d = MHD_start_daemon (MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_ERROR_LOG,\n                        11080,\n                        NULL, NULL, &ahc_echo, &done_flag, MHD_OPTION_END);\n  if (d == NULL)\n    return 1;\n  zzuf_socat_start ();\n  for (i = 0; i < LOOP_COUNT; i++)\n    {\n      fprintf (stderr, \".\");\n      c = curl_easy_init ();\n      curl_easy_setopt (c, CURLOPT_URL, \"http://127.0.0.1:11080/hello_world\");\n      curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n      curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc);\n      curl_easy_setopt (c, CURLOPT_READFUNCTION, &putBuffer);\n      curl_easy_setopt (c, CURLOPT_READDATA, &pos);\n      curl_easy_setopt (c, CURLOPT_UPLOAD, 1L);\n      /* by not giving the file size, we force chunking! */\n      /*\n         curl_easy_setopt (c, CURLOPT_INFILESIZE_LARGE, (curl_off_t) 8L);\n       */\n      curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n      curl_easy_setopt (c, CURLOPT_TIMEOUT_MS, CURL_TIMEOUT);\n      curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n      curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT_MS, CURL_TIMEOUT);\n      /* NOTE: use of CONNECTTIMEOUT without also\n       *   setting NOSIGNAL results in really weird\n       *   crashes on my system! */\n      curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n      curl_easy_perform (c);\n      curl_easy_cleanup (c);\n    }\n  fprintf (stderr, \"\\n\");\n  zzuf_socat_stop ();\n  MHD_stop_daemon (d);\n  return 0;\n}",
      "lines": 50,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testMultithreadedPut": {
      "start_point": [
        174,
        0
      ],
      "end_point": [
        229,
        1
      ],
      "content": "static int\ntestMultithreadedPut ()\n{\n  struct MHD_Daemon *d;\n  CURL *c;\n  char buf[2048];\n  struct CBC cbc;\n  unsigned int pos = 0;\n  int done_flag = 0;\n  CURLcode errornum;\n\n  cbc.buf = buf;\n  cbc.size = 2048;\n  cbc.pos = 0;\n  d = MHD_start_daemon (MHD_USE_THREAD_PER_CONNECTION | MHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_ERROR_LOG,\n                        11081,\n                        NULL, NULL, &ahc_echo, &done_flag, MHD_OPTION_END);\n  if (d == NULL)\n    return 16;\n  c = curl_easy_init ();\n  curl_easy_setopt (c, CURLOPT_URL, \"http://127.0.0.1:11081/hello_world\");\n  curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n  curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc);\n  curl_easy_setopt (c, CURLOPT_READFUNCTION, &putBuffer);\n  curl_easy_setopt (c, CURLOPT_READDATA, &pos);\n  curl_easy_setopt (c, CURLOPT_UPLOAD, 1L);\n  /* by not giving the file size, we force chunking! */\n  /*\n     curl_easy_setopt (c, CURLOPT_INFILESIZE_LARGE, (curl_off_t) 8L);\n   */\n  curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n  curl_easy_setopt (c, CURLOPT_TIMEOUT, 150L);\n  curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n  curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT, 15L);\n  /* NOTE: use of CONNECTTIMEOUT without also\n   *   setting NOSIGNAL results in really weird\n   *   crashes on my system! */\n  curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n  if (CURLE_OK != (errornum = curl_easy_perform (c)))\n    {\n      fprintf (stderr,\n               \"curl_easy_perform failed: `%s'\\n\",\n               curl_easy_strerror (errornum));\n      curl_easy_cleanup (c);\n      MHD_stop_daemon (d);\n      return 32;\n    }\n  curl_easy_cleanup (c);\n  MHD_stop_daemon (d);\n  if (cbc.pos != strlen (\"/hello_world\"))\n    return 64;\n  if (0 != strncmp (\"/hello_world\", cbc.buf, strlen (\"/hello_world\")))\n    return 128;\n\n  return 0;\n}",
      "lines": 56,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testExternalPut": {
      "start_point": [
        232,
        0
      ],
      "end_point": [
        353,
        1
      ],
      "content": "static int\ntestExternalPut ()\n{\n  struct MHD_Daemon *d;\n  CURL *c;\n  char buf[2048];\n  struct CBC cbc;\n  CURLM *multi;\n  CURLMcode mret;\n  fd_set rs;\n  fd_set ws;\n  fd_set es;\n  int max;\n  int running;\n  time_t start;\n  struct timeval tv;\n  unsigned int pos = 0;\n  int done_flag = 0;\n  int i;\n\n  multi = NULL;\n  cbc.buf = buf;\n  cbc.size = 2048;\n  cbc.pos = 0;\n  d = MHD_start_daemon (MHD_USE_ERROR_LOG,\n                        11082,\n                        NULL, NULL, &ahc_echo, &done_flag, MHD_OPTION_END);\n  if (d == NULL)\n    return 256;\n\n  multi = curl_multi_init ();\n  if (multi == NULL)\n    {\n      MHD_stop_daemon (d);\n      return 512;\n    }\n  zzuf_socat_start ();\n  for (i = 0; i < LOOP_COUNT; i++)\n    {\n      fprintf (stderr, \".\");\n      c = curl_easy_init ();\n      curl_easy_setopt (c, CURLOPT_URL, \"http://127.0.0.1:11082/hello_world\");\n      curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n      curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc);\n      curl_easy_setopt (c, CURLOPT_READFUNCTION, &putBuffer);\n      curl_easy_setopt (c, CURLOPT_READDATA, &pos);\n      curl_easy_setopt (c, CURLOPT_UPLOAD, 1L);\n      /* by not giving the file size, we force chunking! */\n      /*\n         curl_easy_setopt (c, CURLOPT_INFILESIZE_LARGE, (curl_off_t) 8L);\n       */\n      curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n      curl_easy_setopt (c, CURLOPT_TIMEOUT_MS, CURL_TIMEOUT);\n      curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n      curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT_MS, CURL_TIMEOUT);\n      /* NOTE: use of CONNECTTIMEOUT without also\n       *   setting NOSIGNAL results in really weird\n       *   crashes on my system! */\n      curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n\n\n      mret = curl_multi_add_handle (multi, c);\n      if (mret != CURLM_OK)\n        {\n          curl_multi_cleanup (multi);\n          curl_easy_cleanup (c);\n          zzuf_socat_stop ();\n          MHD_stop_daemon (d);\n          return 1024;\n        }\n      start = time (NULL);\n      while ((time (NULL) - start < 5) && (c != NULL))\n        {\n          max = 0;\n          FD_ZERO (&rs);\n          FD_ZERO (&ws);\n          FD_ZERO (&es);\n          curl_multi_perform (multi, &running);\n          mret = curl_multi_fdset (multi, &rs, &ws, &es, &max);\n          if (mret != CURLM_OK)\n            {\n              curl_multi_remove_handle (multi, c);\n              curl_multi_cleanup (multi);\n              curl_easy_cleanup (c);\n              zzuf_socat_stop ();\n              MHD_stop_daemon (d);\n              return 2048;\n            }\n          if (MHD_YES != MHD_get_fdset (d, &rs, &ws, &es, &max))\n            {\n              curl_multi_remove_handle (multi, c);\n              curl_multi_cleanup (multi);\n              curl_easy_cleanup (c);\n              zzuf_socat_stop ();\n              MHD_stop_daemon (d);\n              return 4096;\n            }\n          tv.tv_sec = 0;\n          tv.tv_usec = 1000;\n          select (max + 1, &rs, &ws, &es, &tv);\n          curl_multi_perform (multi, &running);\n          if (running == 0)\n            {\n              curl_multi_info_read (multi, &running);\n              curl_multi_remove_handle (multi, c);\n              curl_easy_cleanup (c);\n              c = NULL;\n            }\n          MHD_run (d);\n        }\n      if (c != NULL)\n        {\n          curl_multi_remove_handle (multi, c);\n          curl_easy_cleanup (c);\n        }\n    }\n  fprintf (stderr, \"\\n\");\n  curl_multi_cleanup (multi);\n  zzuf_socat_stop ();\n  MHD_stop_daemon (d);\n  return 0;\n}",
      "lines": 122,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        357,
        0
      ],
      "end_point": [
        372,
        1
      ],
      "content": "int\nmain (int argc, char *const *argv)\n{\n  unsigned int errorCount = 0;\n  (void)argc; (void)argv; /* Unused. Silent compiler warning. */\n\n  if (0 != curl_global_init (CURL_GLOBAL_WIN32))\n    return 2;\n  errorCount += testInternalPut ();\n  errorCount += testMultithreadedPut ();\n  errorCount += testExternalPut ();\n  if (errorCount != 0)\n    fprintf (stderr, \"Error (code: %u)\\n\", errorCount);\n  curl_global_cleanup ();\n  return errorCount != 0;       /* 0 == pass */\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/src/testzzuf/test_put_large.c": {
    "putBuffer": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "static size_t\nputBuffer (void *stream, size_t size, size_t nmemb, void *ptr)\n{\n  unsigned int *pos = ptr;\n  unsigned int wrt;\n\n  wrt = size * nmemb;\n  if (wrt > PUT_SIZE - (*pos))\n    wrt = PUT_SIZE - (*pos);\n  memcpy (stream, &put_buffer[*pos], wrt);\n  (*pos) += wrt;\n  return wrt;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "copyBuffer": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        82,
        1
      ],
      "content": "static size_t\ncopyBuffer (void *ptr, size_t size, size_t nmemb, void *ctx)\n{\n  struct CBC *cbc = ctx;\n\n  if (cbc->pos + size * nmemb > cbc->size)\n    return 0;                   /* overflow */\n  memcpy (&cbc->buf[cbc->pos], ptr, size * nmemb);\n  cbc->pos += size * nmemb;\n  return size * nmemb;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "ahc_echo": {
      "start_point": [
        84,
        0
      ],
      "end_point": [
        128,
        1
      ],
      "content": "static int\nahc_echo (void *cls,\n          struct MHD_Connection *connection,\n          const char *url,\n          const char *method,\n          const char *version,\n          const char *upload_data, size_t *upload_data_size,\n          void **unused)\n{\n  int *done = cls;\n  struct MHD_Response *response;\n  int ret;\n  (void)version;(void)unused;\t/* Unused. Silent compiler warning. */\n\n  if (0 != strcmp (\"PUT\", method))\n    return MHD_NO;              /* unexpected method */\n  if ((*done) == 0)\n    {\n      if (*upload_data_size != PUT_SIZE)\n        {\n#if 0\n          fprintf (stderr,\n                   \"Waiting for more data (%u/%u)...\\n\",\n                   *upload_data_size, PUT_SIZE);\n#endif\n          return MHD_YES;       /* not yet ready */\n        }\n      if (0 == memcmp (upload_data, put_buffer, PUT_SIZE))\n        {\n          *upload_data_size = 0;\n        }\n      else\n        {\n          return MHD_NO;\n        }\n      *done = 1;\n      return MHD_YES;\n    }\n  response = MHD_create_response_from_buffer (strlen (url),\n\t\t\t\t\t      (void *) url, \n\t\t\t\t\t      MHD_RESPMEM_MUST_COPY);\n  ret = MHD_queue_response (connection, MHD_HTTP_OK, response);\n  MHD_destroy_response (response);\n  return ret;\n}",
      "lines": 45,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testInternalPut": {
      "start_point": [
        131,
        0
      ],
      "end_point": [
        181,
        1
      ],
      "content": "static int\ntestInternalPut ()\n{\n  struct MHD_Daemon *d;\n  CURL *c;\n  struct CBC cbc;\n  unsigned int pos = 0;\n  int done_flag = 0;\n  char buf[2048];\n  int i;\n\n  cbc.buf = buf;\n  cbc.size = 2048;\n  cbc.pos = 0;\n  d = MHD_start_daemon (MHD_USE_INTERNAL_POLLING_THREAD /* | MHD_USE_ERROR_LOG */ ,\n                        11080,\n                        NULL, NULL, &ahc_echo, &done_flag, MHD_OPTION_END);\n  if (d == NULL)\n    return 1;\n  zzuf_socat_start ();\n  for (i = 0; i < LOOP_COUNT; i++)\n    {\n      fprintf (stderr, \".\");\n\n      c = curl_easy_init ();\n      curl_easy_setopt (c, CURLOPT_URL, \"http://127.0.0.1:11081/hello_world\");\n      curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n      curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc);\n      curl_easy_setopt (c, CURLOPT_READFUNCTION, &putBuffer);\n      curl_easy_setopt (c, CURLOPT_READDATA, &pos);\n      curl_easy_setopt (c, CURLOPT_UPLOAD, 1L);\n      curl_easy_setopt (c, CURLOPT_INFILESIZE, (long) PUT_SIZE);\n      curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n      curl_easy_setopt (c, CURLOPT_TIMEOUT_MS, CURL_TIMEOUT);\n      if (oneone)\n        curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n      else\n        curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0);\n      curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT_MS, CURL_TIMEOUT);\n      /* NOTE: use of CONNECTTIMEOUT without also\n       *   setting NOSIGNAL results in really weird\n       *   crashes on my system! */\n      curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n      curl_easy_perform (c);\n      curl_easy_cleanup (c);\n    }\n  fprintf (stderr, \"\\n\");\n  zzuf_socat_stop ();\n  MHD_stop_daemon (d);\n  return 0;\n}",
      "lines": 51,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testMultithreadedPut": {
      "start_point": [
        183,
        0
      ],
      "end_point": [
        233,
        1
      ],
      "content": "static int\ntestMultithreadedPut ()\n{\n  struct MHD_Daemon *d;\n  CURL *c;\n  struct CBC cbc;\n  unsigned int pos = 0;\n  int done_flag = 0;\n  char buf[2048];\n  int i;\n\n  cbc.buf = buf;\n  cbc.size = 2048;\n  cbc.pos = 0;\n  d = MHD_start_daemon (MHD_USE_THREAD_PER_CONNECTION | MHD_USE_INTERNAL_POLLING_THREAD /* | MHD_USE_ERROR_LOG */ ,\n                        11080,\n                        NULL, NULL, &ahc_echo, &done_flag, MHD_OPTION_END);\n  if (d == NULL)\n    return 16;\n  zzuf_socat_start ();\n  for (i = 0; i < LOOP_COUNT; i++)\n    {\n      fprintf (stderr, \".\");\n\n      c = curl_easy_init ();\n      curl_easy_setopt (c, CURLOPT_URL, \"http://127.0.0.1:11081/hello_world\");\n      curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n      curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc);\n      curl_easy_setopt (c, CURLOPT_READFUNCTION, &putBuffer);\n      curl_easy_setopt (c, CURLOPT_READDATA, &pos);\n      curl_easy_setopt (c, CURLOPT_UPLOAD, 1L);\n      curl_easy_setopt (c, CURLOPT_INFILESIZE, (long) PUT_SIZE);\n      curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n      curl_easy_setopt (c, CURLOPT_TIMEOUT_MS, CURL_TIMEOUT);\n      if (oneone)\n        curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n      else\n        curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0);\n      curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT_MS, CURL_TIMEOUT);\n      /* NOTE: use of CONNECTTIMEOUT without also\n       *   setting NOSIGNAL results in really weird\n       *   crashes on my system! */\n      curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n      curl_easy_perform (c);\n      curl_easy_cleanup (c);\n    }\n  fprintf (stderr, \"\\n\");\n  zzuf_socat_stop ();\n  MHD_stop_daemon (d);\n  return 0;\n}",
      "lines": 51,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "testExternalPut": {
      "start_point": [
        236,
        0
      ],
      "end_point": [
        360,
        1
      ],
      "content": "static int\ntestExternalPut ()\n{\n  struct MHD_Daemon *d;\n  CURL *c;\n  struct CBC cbc;\n  CURLM *multi;\n  CURLMcode mret;\n  fd_set rs;\n  fd_set ws;\n  fd_set es;\n  int max;\n  int running;\n  time_t start;\n  struct timeval tv;\n  unsigned int pos = 0;\n  int done_flag = 0;\n  char buf[2048];\n  int i;\n\n  cbc.buf = buf;\n  cbc.size = 2048;\n  cbc.pos = 0;\n  multi = NULL;\n  d = MHD_start_daemon (MHD_NO_FLAG /* | MHD_USE_ERROR_LOG */,\n                        11080,\n                        NULL, NULL, &ahc_echo, &done_flag,\n                        MHD_OPTION_CONNECTION_MEMORY_LIMIT,\n                        (size_t) (PUT_SIZE * 4), MHD_OPTION_END);\n  if (d == NULL)\n    return 256;\n  multi = curl_multi_init ();\n  if (multi == NULL)\n    {\n      MHD_stop_daemon (d);\n      return 512;\n    }\n  zzuf_socat_start ();\n  for (i = 0; i < LOOP_COUNT; i++)\n    {\n      fprintf (stderr, \".\");\n\n      c = curl_easy_init ();\n      curl_easy_setopt (c, CURLOPT_URL, \"http://127.0.0.1:11081/hello_world\");\n      curl_easy_setopt (c, CURLOPT_WRITEFUNCTION, &copyBuffer);\n      curl_easy_setopt (c, CURLOPT_WRITEDATA, &cbc);\n      curl_easy_setopt (c, CURLOPT_READFUNCTION, &putBuffer);\n      curl_easy_setopt (c, CURLOPT_READDATA, &pos);\n      curl_easy_setopt (c, CURLOPT_UPLOAD, 1L);\n      curl_easy_setopt (c, CURLOPT_INFILESIZE, (long) PUT_SIZE);\n      curl_easy_setopt (c, CURLOPT_FAILONERROR, 1);\n      curl_easy_setopt (c, CURLOPT_TIMEOUT_MS, CURL_TIMEOUT);\n      if (oneone)\n        curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\n      else\n        curl_easy_setopt (c, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0);\n      curl_easy_setopt (c, CURLOPT_CONNECTTIMEOUT_MS, CURL_TIMEOUT);\n      /* NOTE: use of CONNECTTIMEOUT without also\n       *   setting NOSIGNAL results in really weird\n       *   crashes on my system! */\n      curl_easy_setopt (c, CURLOPT_NOSIGNAL, 1);\n\n\n\n      mret = curl_multi_add_handle (multi, c);\n      if (mret != CURLM_OK)\n        {\n          curl_multi_cleanup (multi);\n          curl_easy_cleanup (c);\n          zzuf_socat_stop ();\n          MHD_stop_daemon (d);\n          return 1024;\n        }\n      start = time (NULL);\n      while ((time (NULL) - start < 5) && (c != NULL))\n        {\n          max = 0;\n          FD_ZERO (&rs);\n          FD_ZERO (&ws);\n          FD_ZERO (&es);\n          curl_multi_perform (multi, &running);\n          mret = curl_multi_fdset (multi, &rs, &ws, &es, &max);\n          if (mret != CURLM_OK)\n            {\n              curl_multi_remove_handle (multi, c);\n              curl_multi_cleanup (multi);\n              curl_easy_cleanup (c);\n              zzuf_socat_stop ();\n              MHD_stop_daemon (d);\n              return 2048;\n            }\n          if (MHD_YES != MHD_get_fdset (d, &rs, &ws, &es, &max))\n            {\n              curl_multi_remove_handle (multi, c);\n              curl_multi_cleanup (multi);\n              curl_easy_cleanup (c);\n              zzuf_socat_stop ();\n              MHD_stop_daemon (d);\n              return 4096;\n            }\n          tv.tv_sec = 0;\n          tv.tv_usec = 1000;\n          select (max + 1, &rs, &ws, &es, &tv);\n          curl_multi_perform (multi, &running);\n          if (running == 0)\n            {\n              curl_multi_info_read (multi, &running);\n              curl_multi_remove_handle (multi, c);\n              curl_easy_cleanup (c);\n              c = NULL;\n            }\n          MHD_run (d);\n        }\n      if (c != NULL)\n        {\n          curl_multi_remove_handle (multi, c);\n          curl_easy_cleanup (c);\n        }\n    }\n  fprintf (stderr, \"\\n\");\n  zzuf_socat_stop ();\n  curl_multi_cleanup (multi);\n  MHD_stop_daemon (d);\n  return 0;\n}",
      "lines": 125,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        363,
        0
      ],
      "end_point": [
        383,
        1
      ],
      "content": "int\nmain (int argc, char *const *argv)\n{\n  unsigned int errorCount = 0;\n  (void)argc;\t/* Unused. Silent compiler warning. */\n\n  oneone = (NULL != strrchr (argv[0], (int) '/')) ?\n    (NULL != strstr (strrchr (argv[0], (int) '/'), \"11\")) : 0;\n  if (0 != curl_global_init (CURL_GLOBAL_WIN32))\n    return 2;\n  put_buffer = malloc (PUT_SIZE);\n  memset (put_buffer, 1, PUT_SIZE);\n  errorCount += testInternalPut ();\n  errorCount += testMultithreadedPut ();\n  errorCount += testExternalPut ();\n  free (put_buffer);\n  if (errorCount != 0)\n    fprintf (stderr, \"Error (code: %u)\\n\", errorCount);\n  curl_global_cleanup ();\n  return errorCount != 0;       /* 0 == pass */\n}",
      "lines": 21,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "libmicrohttpd/libmicrohttpd-0.9.59/w32/common/MHD_config.h": {}
}