{
  "readline/readline-7.0/ansi_stdlib.h": {},
  "readline/readline-7.0/bind.c": {
    "rl_get_keymap": {
      "start_point": [
        2102,
        0
      ],
      "end_point": [
        2106,
        1
      ],
      "content": "Keymap\nrl_get_keymap ()\n{\n  return (_rl_keymap);\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "Keymap"
      ]
    },
    "rl_set_keymap_from_edit_mode": {
      "start_point": [
        2108,
        0
      ],
      "end_point": [
        2117,
        1
      ],
      "content": "void\nrl_set_keymap_from_edit_mode ()\n{\n  if (rl_editing_mode == emacs_mode)\n    _rl_keymap = emacs_standard_keymap;\n#if defined (VI_MODE)\n  else if (rl_editing_mode == vi_mode)\n    _rl_keymap = vi_insertion_keymap;\n#endif /* VI_MODE */\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "rl_get_keymap_name_from_edit_mode": {
      "start_point": [
        2119,
        0
      ],
      "end_point": [
        2130,
        1
      ],
      "content": "char *\nrl_get_keymap_name_from_edit_mode ()\n{\n  if (rl_editing_mode == emacs_mode)\n    return \"emacs\";\n#if defined (VI_MODE)\n  else if (rl_editing_mode == vi_mode)\n    return \"vi\";\n#endif /* VI_MODE */\n  else\n    return \"none\";\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "char",
        "*\nrl_get_keymap_name_from_edit_mode ()",
        "*"
      ]
    },
    "rl_list_funmap_names": {
      "start_point": [
        2144,
        0
      ],
      "end_point": [
        2159,
        1
      ],
      "content": "void\nrl_list_funmap_names ()\n{\n  register int i;\n  const char **funmap_names;\n\n  funmap_names = rl_funmap_names ();\n\n  if (!funmap_names)\n    return;\n\n  for (i = 0; funmap_names[i]; i++)\n    fprintf (rl_outstream, \"%s\\n\", funmap_names[i]);\n\n  xfree (funmap_names);\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "readline/readline-7.0/callback.c": {
    "_rl_callback_newline": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        101,
        1
      ],
      "content": "static void\n_rl_callback_newline ()\n{\n  rl_initialize ();\n\n  if (in_handler == 0)\n    {\n      in_handler = 1;\n\n      if (rl_prep_term_function)\n\t(*rl_prep_term_function) (_rl_meta_flag);\n\n#if defined (HANDLE_SIGNALS)\n      if (rl_persistent_signal_handlers)\n\trl_set_signals ();\n#endif\n    }\n\n  readline_internal_setup ();\n  RL_CHECK_SIGNALS ();\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "rl_callback_read_char": {
      "start_point": [
        127,
        0
      ],
      "end_point": [
        297,
        1
      ],
      "content": "void\nrl_callback_read_char ()\n{\n  char *line;\n  int eof, jcode;\n  static procenv_t olevel;\n\n  if (rl_linefunc == NULL)\n    {\n      _rl_errmsg (\"readline_callback_read_char() called with no handler!\");\n      abort ();\n    }\n\n  memcpy ((void *)olevel, (void *)_rl_top_level, sizeof (procenv_t));\n#if defined (HAVE_POSIX_SIGSETJMP)\n  jcode = sigsetjmp (_rl_top_level, 0);\n#else\n  jcode = setjmp (_rl_top_level);\n#endif\n  if (jcode)\n    {\n      (*rl_redisplay_function) ();\n      _rl_want_redisplay = 0;\n      memcpy ((void *)_rl_top_level, (void *)olevel, sizeof (procenv_t));\n      CALLBACK_READ_RETURN ();\n    }\n\n#if defined (HANDLE_SIGNALS)\n  /* Install signal handlers only when readline has control. */\n  if (rl_persistent_signal_handlers == 0)\n    rl_set_signals ();\n#endif\n\n  do\n    {\n      RL_CHECK_SIGNALS ();\n      if  (RL_ISSTATE (RL_STATE_ISEARCH))\n\t{\n\t  eof = _rl_isearch_callback (_rl_iscxt);\n\t  if (eof == 0 && (RL_ISSTATE (RL_STATE_ISEARCH) == 0) && RL_ISSTATE (RL_STATE_INPUTPENDING))\n\t    rl_callback_read_char ();\n\n\t  CALLBACK_READ_RETURN ();\n\t}\n      else if  (RL_ISSTATE (RL_STATE_NSEARCH))\n\t{\n\t  eof = _rl_nsearch_callback (_rl_nscxt);\n\n\t  CALLBACK_READ_RETURN ();\n\t}\n#if defined (VI_MODE)\n      /* States that can occur while in state VIMOTION have to be checked\n\t before RL_STATE_VIMOTION */\n      else if (RL_ISSTATE (RL_STATE_CHARSEARCH))\n\t{\n\t  int k;\n\n\t  k = _rl_callback_data->i2;\n\n\t  eof = (*_rl_callback_func) (_rl_callback_data);\n\t  /* If the function `deregisters' itself, make sure the data is\n\t     cleaned up. */\n\t  if (_rl_callback_func == 0)\t/* XXX - just sanity check */\n\t    {\n\t      if (_rl_callback_data)\n\t\t{\n\t\t  _rl_callback_data_dispose (_rl_callback_data);\n\t\t  _rl_callback_data = 0;\n\t\t}\n\t    }\n\n\t  /* Messy case where vi motion command can be char search */\n\t  if (RL_ISSTATE (RL_STATE_VIMOTION))\n\t    {\n\t      _rl_vi_domove_motion_cleanup (k, _rl_vimvcxt);\n\t      _rl_internal_char_cleanup ();\n\t      CALLBACK_READ_RETURN ();\t      \n\t    }\n\n\t  _rl_internal_char_cleanup ();\n\t}\n      else if (RL_ISSTATE (RL_STATE_VIMOTION))\n\t{\n\t  eof = _rl_vi_domove_callback (_rl_vimvcxt);\n\t  /* Should handle everything, including cleanup, numeric arguments,\n\t     and turning off RL_STATE_VIMOTION */\n\t  if (RL_ISSTATE (RL_STATE_NUMERICARG) == 0)\n\t    _rl_internal_char_cleanup ();\n\n\t  CALLBACK_READ_RETURN ();\n\t}\n#endif\n      else if (RL_ISSTATE (RL_STATE_NUMERICARG))\n\t{\n\t  eof = _rl_arg_callback (_rl_argcxt);\n\t  if (eof == 0 && (RL_ISSTATE (RL_STATE_NUMERICARG) == 0) && RL_ISSTATE (RL_STATE_INPUTPENDING))\n\t    rl_callback_read_char ();\n\t  /* XXX - this should handle _rl_last_command_was_kill better */\n\t  else if (RL_ISSTATE (RL_STATE_NUMERICARG) == 0)\n\t    _rl_internal_char_cleanup ();\n\n\t  CALLBACK_READ_RETURN ();\n\t}\n      else if (RL_ISSTATE (RL_STATE_MULTIKEY))\n\t{\n\t  eof = _rl_dispatch_callback (_rl_kscxt);\t/* For now */\n\t  while ((eof == -1 || eof == -2) && RL_ISSTATE (RL_STATE_MULTIKEY) && _rl_kscxt && (_rl_kscxt->flags & KSEQ_DISPATCHED))\n\t    eof = _rl_dispatch_callback (_rl_kscxt);\n\t  if (RL_ISSTATE (RL_STATE_MULTIKEY) == 0)\n\t    {\n\t      _rl_internal_char_cleanup ();\n\t      _rl_want_redisplay = 1;\n\t    }\n\t}\n      else if (_rl_callback_func)\n\t{\n\t  /* This allows functions that simply need to read an additional\n\t     character (like quoted-insert) to register a function to be\n\t     called when input is available.  _rl_callback_data is a\n\t     pointer to a struct that has the argument count originally\n\t     passed to the registering function and space for any additional\n\t     parameters.  */\n\t  eof = (*_rl_callback_func) (_rl_callback_data);\n\t  /* If the function `deregisters' itself, make sure the data is\n\t     cleaned up. */\n\t  if (_rl_callback_func == 0)\n\t    {\n\t      if (_rl_callback_data) \t\n\t\t{\n\t\t  _rl_callback_data_dispose (_rl_callback_data);\n\t\t  _rl_callback_data = 0;\n\t\t}\n\t      _rl_internal_char_cleanup ();\n\t    }\n\t}\n      else\n\teof = readline_internal_char ();\n\n      RL_CHECK_SIGNALS ();\n      if (rl_done == 0 && _rl_want_redisplay)\n\t{\n\t  (*rl_redisplay_function) ();\n\t  _rl_want_redisplay = 0;\n\t}\n\n      if (rl_done)\n\t{\n\t  line = readline_internal_teardown (eof);\n\n\t  if (rl_deprep_term_function)\n\t    (*rl_deprep_term_function) ();\n#if defined (HANDLE_SIGNALS)\n\t  rl_clear_signals ();\n#endif\n\t  in_handler = 0;\n\t  (*rl_linefunc) (line);\n\n\t  /* If the user did not clear out the line, do it for him. */\n\t  if (rl_line_buffer[0])\n\t    _rl_init_line_state ();\n\n\t  /* Redisplay the prompt if readline_handler_{install,remove}\n\t     not called. */\n\t  if (in_handler == 0 && rl_linefunc)\n\t    _rl_callback_newline ();\n\t}\n    }\n  while (rl_pending_input || _rl_pushed_input_available () || RL_ISSTATE (RL_STATE_MACROINPUT));\n\n  CALLBACK_READ_RETURN ();\n}",
      "lines": 171,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "rl_callback_handler_remove": {
      "start_point": [
        300,
        0
      ],
      "end_point": [
        315,
        1
      ],
      "content": "void\nrl_callback_handler_remove ()\n{\n  rl_linefunc = NULL;\n  RL_UNSETSTATE (RL_STATE_CALLBACK);\n  RL_CHECK_SIGNALS ();\n  if (in_handler)\n    {\n      in_handler = 0;\n      if (rl_deprep_term_function)\n\t(*rl_deprep_term_function) ();\n#if defined (HANDLE_SIGNALS)\n      rl_clear_signals ();\n#endif\n    }\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "rl_callback_sigcleanup": {
      "start_point": [
        339,
        0
      ],
      "end_point": [
        362,
        1
      ],
      "content": "void\nrl_callback_sigcleanup ()\n{\n  if (RL_ISSTATE (RL_STATE_CALLBACK) == 0)\n    return;\n\n  if (RL_ISSTATE (RL_STATE_ISEARCH))\n    _rl_isearch_cleanup (_rl_iscxt, 0);\n  else if (RL_ISSTATE (RL_STATE_NSEARCH))\n    _rl_nsearch_cleanup (_rl_nscxt, 0);\n  else if (RL_ISSTATE (RL_STATE_VIMOTION))\n    RL_UNSETSTATE (RL_STATE_VIMOTION);\n  else if (RL_ISSTATE (RL_STATE_NUMERICARG))\n    {\n      _rl_argcxt = 0;\n      RL_UNSETSTATE (RL_STATE_NUMERICARG);\n    }\n  else if (RL_ISSTATE (RL_STATE_MULTIKEY))\n    RL_UNSETSTATE (RL_STATE_MULTIKEY);\n  if (RL_ISSTATE (RL_STATE_CHARSEARCH))\n    RL_UNSETSTATE (RL_STATE_CHARSEARCH);\n\n  _rl_callback_func = 0;\n}",
      "lines": 24,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "readline/readline-7.0/chardefs.h": {},
  "readline/readline-7.0/colors.c": {
    "_rl_put_indicator": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "void\n_rl_put_indicator (const struct bin_str *ind) {\n  fwrite (ind->string, ind->len, 1, rl_outstream);\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "is_colored": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        80,
        1
      ],
      "content": "static bool\nis_colored (enum indicator_no colored_filetype)\n{\n  size_t len = _rl_color_indicator[colored_filetype].len;\n  char const *s = _rl_color_indicator[colored_filetype].string;\n  return ! (len == 0\n            || (len == 1 && strncmp (s, \"0\", 1) == 0)\n            || (len == 2 && strncmp (s, \"00\", 2) == 0));\n}",
      "lines": 9,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "restore_default_color": {
      "start_point": [
        82,
        0
      ],
      "end_point": [
        87,
        1
      ],
      "content": "static void\nrestore_default_color (void)\n{\n  _rl_put_indicator (&_rl_color_indicator[C_LEFT]);\n  _rl_put_indicator (&_rl_color_indicator[C_RIGHT]);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "_rl_set_normal_color": {
      "start_point": [
        89,
        0
      ],
      "end_point": [
        98,
        1
      ],
      "content": "void\n_rl_set_normal_color (void)\n{\n  if (is_colored (C_NORM))\n    {\n      _rl_put_indicator (&_rl_color_indicator[C_LEFT]);\n      _rl_put_indicator (&_rl_color_indicator[C_NORM]);\n      _rl_put_indicator (&_rl_color_indicator[C_RIGHT]);\n    }\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "_rl_print_prefix_color": {
      "start_point": [
        100,
        0
      ],
      "end_point": [
        118,
        1
      ],
      "content": "bool\n_rl_print_prefix_color (void)\n{\n  struct bin_str *s;\n\n  /* What do we want to use for the prefix? Let's try cyan first, see colors.h */\n  s = &_rl_color_indicator[C_PREFIX];\n  if (s->string != NULL)\n    {\n      if (is_colored (C_NORM))\n\trestore_default_color ();\n      _rl_put_indicator (&_rl_color_indicator[C_LEFT]);\n      _rl_put_indicator (s);\n      _rl_put_indicator (&_rl_color_indicator[C_RIGHT]);\n      return 0;\n    }\n  else\n    return 1;\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "bool"
      ]
    },
    "_rl_print_color_indicator": {
      "start_point": [
        121,
        0
      ],
      "end_point": [
        264,
        1
      ],
      "content": "bool\n_rl_print_color_indicator (const char *f)\n{\n  enum indicator_no colored_filetype;\n  COLOR_EXT_TYPE *ext;\t/* Color extension */\n  size_t len;\t\t/* Length of name */\n\n  const char* name;\n  char *filename;\n  struct stat astat, linkstat;\n  mode_t mode;\n  int linkok;\t/* 1 == ok, 0 == dangling symlink, -1 == missing */\n  int stat_ok;\n\n  name = f;\n\n  /* This should already have undergone tilde expansion */\n  filename = 0;\n  if (rl_filename_stat_hook)\n    {\n      filename = savestring (f);\n      (*rl_filename_stat_hook) (&filename);\n      name = filename;\n    }\n\n#if defined (HAVE_LSTAT)\n  stat_ok = lstat(name, &astat);\n#else\n  stat_ok = stat(name, &astat);\n#endif\n  if (stat_ok == 0)\n    {\n      mode = astat.st_mode;\n#if defined (HAVE_LSTAT)\n      if (S_ISLNK (mode))\n\t{\n\t  linkok = stat (name, &linkstat) == 0;\n\t  if (linkok && strncmp (_rl_color_indicator[C_LINK].string, \"target\", 6) == 0)\n\t    mode = linkstat.st_mode;\n\t}\n      else\n#endif\n\tlinkok = 1;\n    }\n  else\n    linkok = -1;\n\n  /* Is this a nonexistent file?  If so, linkok == -1.  */\n\n  if (linkok == -1 && _rl_color_indicator[C_MISSING].string != NULL)\n    colored_filetype = C_MISSING;\n  else if (linkok == 0 && S_ISLNK(mode) && _rl_color_indicator[C_ORPHAN].string != NULL)\n    colored_filetype = C_ORPHAN;\t/* dangling symlink */\n  else if(stat_ok != 0)\n    {\n      static enum indicator_no filetype_indicator[] = FILETYPE_INDICATORS;\n      colored_filetype = filetype_indicator[normal]; //f->filetype];\n    }\n  else\n    {\n      if (S_ISREG (mode))\n        {\n          colored_filetype = C_FILE;\n\n          if ((mode & S_ISUID) != 0 && is_colored (C_SETUID))\n            colored_filetype = C_SETUID;\n          else if ((mode & S_ISGID) != 0 && is_colored (C_SETGID))\n            colored_filetype = C_SETGID;\n          else if (is_colored (C_CAP) && 0) //f->has_capability)\n            colored_filetype = C_CAP;\n          else if ((mode & S_IXUGO) != 0 && is_colored (C_EXEC))\n            colored_filetype = C_EXEC;\n          else if ((1 < astat.st_nlink) && is_colored (C_MULTIHARDLINK))\n            colored_filetype = C_MULTIHARDLINK;\n        }\n      else if (S_ISDIR (mode))\n        {\n          colored_filetype = C_DIR;\n\n#if defined (S_ISVTX)\n          if ((mode & S_ISVTX) && (mode & S_IWOTH)\n              && is_colored (C_STICKY_OTHER_WRITABLE))\n            colored_filetype = C_STICKY_OTHER_WRITABLE;\n          else\n#endif\n          if ((mode & S_IWOTH) != 0 && is_colored (C_OTHER_WRITABLE))\n            colored_filetype = C_OTHER_WRITABLE;\n#if defined (S_ISVTX)\n          else if ((mode & S_ISVTX) != 0 && is_colored (C_STICKY))\n            colored_filetype = C_STICKY;\n#endif\n        }\n      else if (S_ISLNK (mode))\n        colored_filetype = C_LINK;\n      else if (S_ISFIFO (mode))\n        colored_filetype = C_FIFO;\n      else if (S_ISSOCK (mode))\n        colored_filetype = C_SOCK;\n      else if (S_ISBLK (mode))\n        colored_filetype = C_BLK;\n      else if (S_ISCHR (mode))\n        colored_filetype = C_CHR;\n      else\n        {\n          /* Classify a file of some other type as C_ORPHAN.  */\n          colored_filetype = C_ORPHAN;\n        }\n    }\n\n  /* Check the file's suffix only if still classified as C_FILE.  */\n  ext = NULL;\n  if (colored_filetype == C_FILE)\n    {\n      /* Test if NAME has a recognized suffix.  */\n      len = strlen (name);\n      name += len;\t\t/* Pointer to final \\0.  */\n      for (ext = _rl_color_ext_list; ext != NULL; ext = ext->next)\n        {\n          if (ext->ext.len <= len\n              && strncmp (name - ext->ext.len, ext->ext.string,\n                          ext->ext.len) == 0)\n            break;\n        }\n    }\n\n  free (filename);\t/* NULL or savestring return value */\n\n  {\n    const struct bin_str *const s\n      = ext ? &(ext->seq) : &_rl_color_indicator[colored_filetype];\n    if (s->string != NULL)\n      {\n        /* Need to reset so not dealing with attribute combinations */\n        if (is_colored (C_NORM))\n\t  restore_default_color ();\n        _rl_put_indicator (&_rl_color_indicator[C_LEFT]);\n        _rl_put_indicator (s);\n        _rl_put_indicator (&_rl_color_indicator[C_RIGHT]);\n        return 0;\n      }\n    else\n      return 1;\n  }\n}",
      "lines": 144,
      "depth": 19,
      "decorators": [
        "bool"
      ]
    },
    "_rl_prep_non_filename_text": {
      "start_point": [
        266,
        0
      ],
      "end_point": [
        277,
        1
      ],
      "content": "void\n_rl_prep_non_filename_text (void)\n{\n  if (_rl_color_indicator[C_END].string != NULL)\n    _rl_put_indicator (&_rl_color_indicator[C_END]);\n  else\n    {\n      _rl_put_indicator (&_rl_color_indicator[C_LEFT]);\n      _rl_put_indicator (&_rl_color_indicator[C_RESET]);\n      _rl_put_indicator (&_rl_color_indicator[C_RIGHT]);\n    }\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "readline/readline-7.0/colors.h": {},
  "readline/readline-7.0/compat.c": {
    "free_undo_list": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "void\nfree_undo_list ()\n{\n  rl_free_undo_list ();\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "maybe_replace_line": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "int\nmaybe_replace_line ()\n{\n  return rl_maybe_replace_line ();\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "maybe_save_line": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        63,
        1
      ],
      "content": "int\nmaybe_save_line ()\n{\n  return rl_maybe_save_line ();\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "maybe_unsave_line": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        69,
        1
      ],
      "content": "int\nmaybe_unsave_line ()\n{\n  return rl_maybe_unsave_line ();\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "ding": {
      "start_point": [
        71,
        0
      ],
      "end_point": [
        75,
        1
      ],
      "content": "int\nding ()\n{\n  return rl_ding ();\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "crlf": {
      "start_point": [
        77,
        0
      ],
      "end_point": [
        81,
        1
      ],
      "content": "int\ncrlf ()\n{\n  return rl_crlf ();\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "readline/readline-7.0/complete.c": {
    "_rl_reset_completion_state": {
      "start_point": [
        484,
        0
      ],
      "end_point": [
        489,
        1
      ],
      "content": "void\n_rl_reset_completion_state ()\n{\n  rl_completion_found_quote = 0;\n  rl_completion_quote_character = 0;\n}",
      "lines": 6,
      "depth": 5,
      "decorators": [
        "void"
      ]
    },
    "colored_stat_end": {
      "start_point": [
        684,
        0
      ],
      "end_point": [
        689,
        1
      ],
      "content": "static void\ncolored_stat_end ()\n{\n  _rl_prep_non_filename_text ();\n  _rl_put_indicator (&_rl_color_indicator[C_CLR_TO_EOL]);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "colored_prefix_start": {
      "start_point": [
        691,
        0
      ],
      "end_point": [
        696,
        1
      ],
      "content": "static int\ncolored_prefix_start ()\n{\n  _rl_set_normal_color ();\n  return (_rl_print_prefix_color ());\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "colored_prefix_end": {
      "start_point": [
        698,
        0
      ],
      "end_point": [
        702,
        1
      ],
      "content": "static void\ncolored_prefix_end ()\n{\n  colored_stat_end ();\t\t/* for now */\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "complete_get_screenwidth": {
      "start_point": [
        1538,
        0
      ],
      "end_point": [
        1553,
        1
      ],
      "content": "static int\ncomplete_get_screenwidth ()\n{\n  int cols;\n  char *envcols;\n\n  cols = _rl_completion_columns;\n  if (cols >= 0 && cols <= _rl_screenwidth)\n    return cols;\n  envcols = getenv (\"COLUMNS\");\n  if (envcols && *envcols)\n    cols = atoi (envcols);\n  if (cols >= 0 && cols <= _rl_screenwidth)\n    return cols;\n  return _rl_screenwidth;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "readline/readline-7.0/display.c": {
    "_rl_reset_prompt": {
      "start_point": [
        446,
        0
      ],
      "end_point": [
        450,
        1
      ],
      "content": "void\n_rl_reset_prompt ()\n{\n  rl_visible_prompt_length = rl_expand_prompt (rl_prompt);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "rl_redisplay": {
      "start_point": [
        578,
        0
      ],
      "end_point": [
        1365,
        1
      ],
      "content": "void\nrl_redisplay ()\n{\n  register int in, out, c, linenum, cursor_linenum;\n  register char *line;\n  int inv_botlin, lb_botlin, lb_linenum, o_cpos;\n  int newlines, lpos, temp, n0, num, prompt_lines_estimate;\n  char *prompt_this_line;\n  int mb_cur_max = MB_CUR_MAX;\n#if defined (HANDLE_MULTIBYTE)\n  wchar_t wc;\n  size_t wc_bytes;\n  int wc_width;\n  mbstate_t ps;\n  int _rl_wrapped_multicolumn = 0;\n#endif\n\n  if (_rl_echoing_p == 0)\n    return;\n\n  /* Block keyboard interrupts because this function manipulates global\n     data structures. */\n  _rl_block_sigint ();  \n  RL_SETSTATE (RL_STATE_REDISPLAYING);\n\n  if (!rl_display_prompt)\n    rl_display_prompt = \"\";\n\n  if (line_structures_initialized == 0)\n    {\n      init_line_structures (0);\n      rl_on_new_line ();\n    }\n\n  /* Draw the line into the buffer. */\n  cpos_buffer_position = -1;\n\n  prompt_multibyte_chars = prompt_visible_length - prompt_physical_chars;\n\n  line = invisible_line;\n  out = inv_botlin = 0;\n\n  /* Mark the line as modified or not.  We only do this for history\n     lines. */\n  modmark = 0;\n  if (_rl_mark_modified_lines && current_history () && rl_undo_list)\n    {\n      line[out++] = '*';\n      line[out] = '\\0';\n      modmark = 1;\n    }\n\n  /* If someone thought that the redisplay was handled, but the currently\n     visible line has a different modification state than the one about\n     to become visible, then correct the caller's misconception. */\n  if (visible_line[0] != invisible_line[0])\n    rl_display_fixed = 0;\n\n  /* If the prompt to be displayed is the `primary' readline prompt (the\n     one passed to readline()), use the values we have already expanded.\n     If not, use what's already in rl_display_prompt.  WRAP_OFFSET is the\n     number of non-visible characters in the prompt string. */\n  if (rl_display_prompt == rl_prompt || local_prompt)\n    {\n      if (local_prompt_prefix && forced_display)\n\t_rl_output_some_chars (local_prompt_prefix, strlen (local_prompt_prefix));\n\n      if (local_prompt_len > 0)\n\t{\n\t  temp = local_prompt_len + out + 2;\n\t  if (temp >= line_size)\n\t    {\n\t      line_size = (temp + 1024) - (temp % 1024);\n\t      visible_line = (char *)xrealloc (visible_line, line_size);\n\t      line = invisible_line = (char *)xrealloc (invisible_line, line_size);\n\t    }\n\t  strncpy (line + out, local_prompt, local_prompt_len);\n\t  out += local_prompt_len;\n\t}\n      line[out] = '\\0';\n      wrap_offset = local_prompt_len - prompt_visible_length;\n    }\n  else\n    {\n      int pmtlen;\n      prompt_this_line = strrchr (rl_display_prompt, '\\n');\n      if (!prompt_this_line)\n\tprompt_this_line = rl_display_prompt;\n      else\n\t{\n\t  prompt_this_line++;\n\t  pmtlen = prompt_this_line - rl_display_prompt;\t/* temp var */\n\t  if (forced_display)\n\t    {\n\t      _rl_output_some_chars (rl_display_prompt, pmtlen);\n\t      /* Make sure we are at column zero even after a newline,\n\t\t regardless of the state of terminal output processing. */\n\t      if (pmtlen < 2 || prompt_this_line[-2] != '\\r')\n\t\tcr ();\n\t    }\n\t}\n\n      prompt_physical_chars = pmtlen = strlen (prompt_this_line);\n      temp = pmtlen + out + 2;\n      if (temp >= line_size)\n\t{\n\t  line_size = (temp + 1024) - (temp % 1024);\n\t  visible_line = (char *)xrealloc (visible_line, line_size);\n\t  line = invisible_line = (char *)xrealloc (invisible_line, line_size);\n\t}\n      strncpy (line + out,  prompt_this_line, pmtlen);\n      out += pmtlen;\n      line[out] = '\\0';\n      wrap_offset = prompt_invis_chars_first_line = 0;\n    }\n\n#define CHECK_INV_LBREAKS() \\\n      do { \\\n\tif (newlines >= (inv_lbsize - 2)) \\\n\t  { \\\n\t    inv_lbsize *= 2; \\\n\t    inv_lbreaks = (int *)xrealloc (inv_lbreaks, inv_lbsize * sizeof (int)); \\\n\t  } \\\n      } while (0)\n\n#if defined (HANDLE_MULTIBYTE)\t  \n#define CHECK_LPOS() \\\n      do { \\\n\tlpos++; \\\n\tif (lpos >= _rl_screenwidth) \\\n\t  { \\\n\t    if (newlines >= (inv_lbsize - 2)) \\\n\t      { \\\n\t\tinv_lbsize *= 2; \\\n\t\tinv_lbreaks = (int *)xrealloc (inv_lbreaks, inv_lbsize * sizeof (int)); \\\n\t      } \\\n\t    inv_lbreaks[++newlines] = out; \\\n\t    if (newlines >= (line_state_invisible->wbsize - 1)) \\\n\t      { \\\n\t\tline_state_invisible->wbsize *= 2; \\\n\t\tline_state_invisible->wrapped_line = (int *)xrealloc (line_state_invisible->wrapped_line, line_state_invisible->wbsize * sizeof(int)); \\\n\t      } \\\n\t    line_state_invisible->wrapped_line[newlines] = _rl_wrapped_multicolumn; \\\n\t    lpos = 0; \\\n\t  } \\\n      } while (0)\n#else\n#define CHECK_LPOS() \\\n      do { \\\n\tlpos++; \\\n\tif (lpos >= _rl_screenwidth) \\\n\t  { \\\n\t    if (newlines >= (inv_lbsize - 2)) \\\n\t      { \\\n\t\tinv_lbsize *= 2; \\\n\t\tinv_lbreaks = (int *)xrealloc (inv_lbreaks, inv_lbsize * sizeof (int)); \\\n\t      } \\\n\t    inv_lbreaks[++newlines] = out; \\\n\t    lpos = 0; \\\n\t  } \\\n      } while (0)\n#endif\n\n  /* inv_lbreaks[i] is where line i starts in the buffer. */\n  inv_lbreaks[newlines = 0] = 0;\n  /* lpos is a physical cursor position, so it needs to be adjusted by the\n     number of invisible characters in the prompt, per line */\n  lpos = prompt_physical_chars + modmark;\n\n#if defined (HANDLE_MULTIBYTE)\n  memset (line_state_invisible->wrapped_line, 0, line_state_invisible->wbsize * sizeof (int));\n  num = 0;\n#endif\n\n  /* prompt_invis_chars_first_line is the number of invisible characters in\n     the first physical line of the prompt.\n     wrap_offset - prompt_invis_chars_first_line is the number of invis\n     chars on the second (or, more generally, last) line. */\n\n  /* This is zero-based, used to set the newlines */\n  prompt_lines_estimate = lpos / _rl_screenwidth;\n\n  /* what if lpos is already >= _rl_screenwidth before we start drawing the\n     contents of the command line? */\n  while (lpos >= _rl_screenwidth)\n    {\n      int z, p;\n      int nocorrect, wadjust;\n\n      nocorrect = 0;\n      /* Adjust depending on the invisible characters in the line.  We use a\n\t heuristic based on experience: invisible characters nearly always\n\t appear in the first and last lines of the prompt */\n      wadjust = (newlines == 0)\n\t\t  ? prompt_invis_chars_first_line\n\t\t  : ((newlines == prompt_lines_estimate) ? wrap_offset : prompt_invis_chars_first_line);\n\n      /* fix from Darin Johnson <darin@acuson.com> for prompt string with\n         invisible characters that is longer than the screen width.  The\n         prompt_invis_chars_first_line variable could be made into an array\n         saying how many invisible characters there are per line, but that's\n         probably too much work for the benefit gained.  How many people have\n         prompts that exceed two physical lines?\n         Additional logic fix from Edward Catmur <ed@catmur.co.uk> */\n#if defined (HANDLE_MULTIBYTE)\n      if (mb_cur_max > 1 && rl_byte_oriented == 0 && prompt_multibyte_chars > 0)\n\t{\n\t  nocorrect = 1;\n\t  n0 = num;\n          temp = local_prompt_len;\n          while (num < temp)\n\t    {\n\t      /* This has to take invisible characters in the prompt into\n\t\t account. */\n\t      z = _rl_col_width  (local_prompt, n0, num, 1) - wadjust;\n\t      if (z > _rl_screenwidth)\n\t\t{\n\t          num = _rl_find_prev_mbchar (local_prompt, num, MB_FIND_ANY);\n\t          break;\n\t\t}\n\t      else if (z == _rl_screenwidth)\n\t\t{\n\t\t  /* If we are in the middle or at the end of a multibyte\n\t\t     character, we want to move to the start, then find out\n\t\t     where it ends so we know where to insert the newline.\n\t\t     If this isn't a multibyte character, its the same as num++ */\n\t\t  p = _rl_find_prev_mbchar (local_prompt, num, MB_FIND_ANY);\n\t\t  num = _rl_find_next_mbchar (local_prompt, p, 1, MB_FIND_ANY);\n\t\t  break;\n\t\t}\n\t      num++;\n\t    }\n          temp = num;\n\t}\n      else\n#endif /* !HANDLE_MULTIBYTE */\n\ttemp = ((newlines + 1) * _rl_screenwidth);\n\n      /* Now account for invisible characters in the current line. */\n      /* XXX - this assumes that the invisible characters may be split, but only\n\t between the first and the last lines. */\n      if (nocorrect == 0)\n\ttemp += wadjust;\n\n      inv_lbreaks[++newlines] = temp;\n#if defined (HANDLE_MULTIBYTE)\n      /* lpos is a physical cursor position, so it needs to take the invisible\n\t characters into account. */\n      if (mb_cur_max > 1 && rl_byte_oriented == 0 && prompt_multibyte_chars > 0)\n\tlpos -= _rl_col_width (local_prompt, n0, num, 1) - wadjust;\n      else\n#endif\n\tlpos -= _rl_screenwidth;\t/* all physical cursor positions */\n    }\n\n  prompt_last_screen_line = newlines;\n\n  /* Draw the rest of the line (after the prompt) into invisible_line, keeping\n     track of where the cursor is (cpos_buffer_position), the number of the line containing\n     the cursor (lb_linenum), the last line number (lb_botlin and inv_botlin).\n     It maintains an array of line breaks for display (inv_lbreaks).\n     This handles expanding tabs for display and displaying meta characters. */\n  lb_linenum = 0;\n#if defined (HANDLE_MULTIBYTE)\n  in = 0;\n  if (mb_cur_max > 1 && rl_byte_oriented == 0)\n    {\n      memset (&ps, 0, sizeof (mbstate_t));\n      /* XXX - what if wc_bytes ends up <= 0? check for MB_INVALIDCH */\n      wc_bytes = mbrtowc (&wc, rl_line_buffer, rl_end, &ps);\n    }\n  else\n    wc_bytes = 1;\n  while (in < rl_end)\n#else\n  for (in = 0; in < rl_end; in++)\n#endif\n    {\n      c = (unsigned char)rl_line_buffer[in];\n\n#if defined (HANDLE_MULTIBYTE)\n      if (mb_cur_max > 1 && rl_byte_oriented == 0)\n\t{\n\t  if (MB_INVALIDCH (wc_bytes))\n\t    {\n\t      /* Byte sequence is invalid or shortened.  Assume that the\n\t         first byte represents a character. */\n\t      wc_bytes = 1;\n\t      /* Assume that a character occupies a single column. */\n\t      wc_width = 1;\n\t      memset (&ps, 0, sizeof (mbstate_t));\n\t    }\n\t  else if (MB_NULLWCH (wc_bytes))\n\t    break;\t\t\t/* Found '\\0' */\n\t  else\n\t    {\n\t      temp = WCWIDTH (wc);\n\t      wc_width = (temp >= 0) ? temp : 1;\n\t    }\n\t}\n#endif\n\n      if (out + 8 >= line_size)\t\t/* XXX - 8 for \\t */\n\t{\n\t  line_size *= 2;\n\t  visible_line = (char *)xrealloc (visible_line, line_size);\n\t  invisible_line = (char *)xrealloc (invisible_line, line_size);\n\t  line = invisible_line;\n\t}\n\n      if (in == rl_point)\n\t{\n\t  cpos_buffer_position = out;\n\t  lb_linenum = newlines;\n\t}\n\n#if defined (HANDLE_MULTIBYTE)\n      if (META_CHAR (c) && _rl_output_meta_chars == 0)\t/* XXX - clean up */\n#else\n      if (META_CHAR (c))\n#endif\n\t{\n\t  if (_rl_output_meta_chars == 0)\n\t    {\n\t      sprintf (line + out, \"\\\\%o\", c);\n\n\t      if (lpos + 4 >= _rl_screenwidth)\n\t\t{\n\t\t  temp = _rl_screenwidth - lpos;\n\t\t  CHECK_INV_LBREAKS ();\n\t\t  inv_lbreaks[++newlines] = out + temp;\n\t\t  lpos = 4 - temp;\n\t\t}\n\t      else\n\t\tlpos += 4;\n\n\t      out += 4;\n\t    }\n\t  else\n\t    {\n\t      line[out++] = c;\n\t      CHECK_LPOS();\n\t    }\n\t}\n#if defined (DISPLAY_TABS)\n      else if (c == '\\t')\n\t{\n\t  register int newout;\n\n#if 0\n\t  newout = (out | (int)7) + 1;\n#else\n\t  newout = out + 8 - lpos % 8;\n#endif\n\t  temp = newout - out;\n\t  if (lpos + temp >= _rl_screenwidth)\n\t    {\n\t      register int temp2;\n\t      temp2 = _rl_screenwidth - lpos;\n\t      CHECK_INV_LBREAKS ();\n\t      inv_lbreaks[++newlines] = out + temp2;\n\t      lpos = temp - temp2;\n\t      while (out < newout)\n\t\tline[out++] = ' ';\n\t    }\n\t  else\n\t    {\n\t      while (out < newout)\n\t\tline[out++] = ' ';\n\t      lpos += temp;\n\t    }\n\t}\n#endif\n      else if (c == '\\n' && _rl_horizontal_scroll_mode == 0 && _rl_term_up && *_rl_term_up)\n\t{\n\t  line[out++] = '\\0';\t/* XXX - sentinel */\n\t  CHECK_INV_LBREAKS ();\n\t  inv_lbreaks[++newlines] = out;\n\t  lpos = 0;\n\t}\n      else if (CTRL_CHAR (c) || c == RUBOUT)\n\t{\n\t  line[out++] = '^';\n\t  CHECK_LPOS();\n\t  line[out++] = CTRL_CHAR (c) ? UNCTRL (c) : '?';\n\t  CHECK_LPOS();\n\t}\n      else\n\t{\n#if defined (HANDLE_MULTIBYTE)\n\t  if (mb_cur_max > 1 && rl_byte_oriented == 0)\n\t    {\n\t      register int i;\n\n\t      _rl_wrapped_multicolumn = 0;\n\n\t      if (_rl_screenwidth < lpos + wc_width)\n\t\tfor (i = lpos; i < _rl_screenwidth; i++)\n\t\t  {\n\t\t    /* The space will be removed in update_line() */\n\t\t    line[out++] = ' ';\n\t\t    _rl_wrapped_multicolumn++;\n\t\t    CHECK_LPOS();\n\t\t  }\n\t      if (in == rl_point)\n\t\t{\n\t\t  cpos_buffer_position = out;\n\t\t  lb_linenum = newlines;\n\t\t}\n\t      for (i = in; i < in+wc_bytes; i++)\n\t\tline[out++] = rl_line_buffer[i];\n\t      for (i = 0; i < wc_width; i++)\n\t\tCHECK_LPOS();\n\t    }\n\t  else\n\t    {\n\t      line[out++] = c;\n\t      CHECK_LPOS();\n\t    }\n#else\n\t  line[out++] = c;\n\t  CHECK_LPOS();\n#endif\n\t}\n\n#if defined (HANDLE_MULTIBYTE)\n      if (mb_cur_max > 1 && rl_byte_oriented == 0)\n\t{\n\t  in += wc_bytes;\n\t  /* XXX - what if wc_bytes ends up <= 0? check for MB_INVALIDCH */\n\t  wc_bytes = mbrtowc (&wc, rl_line_buffer + in, rl_end - in, &ps);\n\t}\n      else\n        in++;\n#endif\n\n    }\n  line[out] = '\\0';\n  if (cpos_buffer_position < 0)\n    {\n      cpos_buffer_position = out;\n      lb_linenum = newlines;\n    }\n\n  inv_botlin = lb_botlin = _rl_inv_botlin = newlines;\n  CHECK_INV_LBREAKS ();\n  inv_lbreaks[newlines+1] = out;\n  cursor_linenum = lb_linenum;\n\n  /* CPOS_BUFFER_POSITION == position in buffer where cursor should be placed.\n     CURSOR_LINENUM == line number where the cursor should be placed. */\n\n  /* PWP: now is when things get a bit hairy.  The visible and invisible\n     line buffers are really multiple lines, which would wrap every\n     (screenwidth - 1) characters.  Go through each in turn, finding\n     the changed region and updating it.  The line order is top to bottom. */\n\n  /* If we can move the cursor up and down, then use multiple lines,\n     otherwise, let long lines display in a single terminal line, and\n     horizontally scroll it. */\n  displaying_prompt_first_line = 1;\n  if (_rl_horizontal_scroll_mode == 0 && _rl_term_up && *_rl_term_up)\n    {\n      int nleft, pos, changed_screen_line, tx;\n\n      if (!rl_display_fixed || forced_display)\n\t{\n\t  forced_display = 0;\n\n\t  /* If we have more than a screenful of material to display, then\n\t     only display a screenful.  We should display the last screen,\n\t     not the first.  */\n\t  if (out >= _rl_screenchars)\n\t    {\n#if defined (HANDLE_MULTIBYTE)\n\t      if (mb_cur_max > 1 && rl_byte_oriented == 0)\n\t\tout = _rl_find_prev_mbchar (line, _rl_screenchars, MB_FIND_ANY);\n\t      else\n#endif\n\t\tout = _rl_screenchars - 1;\n\t    }\n\n\t  /* The first line is at character position 0 in the buffer.  The\n\t     second and subsequent lines start at inv_lbreaks[N], offset by\n\t     OFFSET (which has already been calculated above).  */\n\n#define INVIS_FIRST()\t(prompt_physical_chars > _rl_screenwidth ? prompt_invis_chars_first_line : wrap_offset)\n#define WRAP_OFFSET(line, offset)  ((line == 0) \\\n\t\t\t\t\t? (offset ? INVIS_FIRST() : 0) \\\n\t\t\t\t\t: ((line == prompt_last_screen_line) ? wrap_offset-prompt_invis_chars_first_line : 0))\n#define W_OFFSET(line, offset) ((line) == 0 ? offset : 0)\n#define VIS_LLEN(l)\t((l) > _rl_vis_botlin ? 0 : (vis_lbreaks[l+1] - vis_lbreaks[l]))\n#define INV_LLEN(l)\t(inv_lbreaks[l+1] - inv_lbreaks[l])\n#define VIS_CHARS(line) (visible_line + vis_lbreaks[line])\n#define VIS_LINE(line) ((line) > _rl_vis_botlin) ? \"\" : VIS_CHARS(line)\n#define INV_LINE(line) (invisible_line + inv_lbreaks[line])\n\n#define OLD_CPOS_IN_PROMPT() (cpos_adjusted == 0 && \\\n\t\t\t_rl_last_c_pos != o_cpos && \\\n\t\t\t_rl_last_c_pos > wrap_offset && \\\n\t\t\to_cpos < prompt_last_invisible)\n\n\t  /* For each line in the buffer, do the updating display. */\n\t  for (linenum = 0; linenum <= inv_botlin; linenum++)\n\t    {\n\t      /* This can lead us astray if we execute a program that changes\n\t\t the locale from a non-multibyte to a multibyte one. */\n\t      o_cpos = _rl_last_c_pos;\n\t      cpos_adjusted = 0;\n\t      update_line (VIS_LINE(linenum), INV_LINE(linenum), linenum,\n\t\t\t   VIS_LLEN(linenum), INV_LLEN(linenum), inv_botlin);\n\n\t      /* update_line potentially changes _rl_last_c_pos, but doesn't\n\t\t take invisible characters into account, since _rl_last_c_pos\n\t\t is an absolute cursor position in a multibyte locale.  See\n\t\t if compensating here is the right thing, or if we have to\n\t\t change update_line itself.  There are several cases in which\n\t\t update_line adjusts _rl_last_c_pos itself (so it can pass\n\t\t _rl_move_cursor_relative accurate values); it communicates\n\t\t this back by setting cpos_adjusted.  If we assume that\n\t\t _rl_last_c_pos is correct (an absolute cursor position) each\n\t\t time update_line is called, then we can assume in our\n\t\t calculations that o_cpos does not need to be adjusted by\n\t\t wrap_offset. */\n\t      if (linenum == 0 && (mb_cur_max > 1 && rl_byte_oriented == 0) && OLD_CPOS_IN_PROMPT())\n\t\t_rl_last_c_pos -= prompt_invis_chars_first_line;\t/* XXX - was wrap_offset */\n\t      else if (linenum == prompt_last_screen_line && prompt_physical_chars > _rl_screenwidth &&\n\t\t\t(mb_cur_max > 1 && rl_byte_oriented == 0) &&\n\t\t\tcpos_adjusted == 0 &&\n\t\t\t_rl_last_c_pos != o_cpos &&\n\t\t\t_rl_last_c_pos > (prompt_last_invisible - _rl_screenwidth - prompt_invis_chars_first_line))\n\t\t_rl_last_c_pos -= (wrap_offset-prompt_invis_chars_first_line);\n\n\t      /* If this is the line with the prompt, we might need to\n\t\t compensate for invisible characters in the new line. Do\n\t\t this only if there is not more than one new line (which\n\t\t implies that we completely overwrite the old visible line)\n\t\t and the new line is shorter than the old.  Make sure we are\n\t\t at the end of the new line before clearing. */\n\t      if (linenum == 0 &&\n\t\t  inv_botlin == 0 && _rl_last_c_pos == out &&\n\t\t  (wrap_offset > visible_wrap_offset) &&\n\t\t  (_rl_last_c_pos < visible_first_line_len))\n\t\t{\n\t\t  if (mb_cur_max > 1 && rl_byte_oriented == 0)\n\t\t    nleft = _rl_screenwidth - _rl_last_c_pos;\n\t\t  else\n\t\t    nleft = _rl_screenwidth + wrap_offset - _rl_last_c_pos;\n\t\t  if (nleft)\n\t\t    _rl_clear_to_eol (nleft);\n\t\t}\n#if 0\n\t      /* This segment is intended to handle the case where the prompt\n\t\t has invisible characters on the second line and the new line\n\t\t to be displayed needs to clear the rest of the old characters\n\t\t out (e.g., when printing the i-search prompt).  In general,\n\t\t the case of the new line being shorter than the old.\n\t\t Incomplete */\n\t      else if (linenum == prompt_last_screen_line &&\n\t\t       prompt_physical_chars > _rl_screenwidth &&\n\t\t       wrap_offset != prompt_invis_chars_first_line &&\n\t\t       _rl_last_c_pos == out &&\n#endif\n\n\n\t      /* Since the new first line is now visible, save its length. */\n\t      if (linenum == 0)\n\t\tvisible_first_line_len = (inv_botlin > 0) ? inv_lbreaks[1] : out - wrap_offset;\n\t    }\n\n\t  /* We may have deleted some lines.  If so, clear the left over\n\t     blank ones at the bottom out. */\n\t  if (_rl_vis_botlin > inv_botlin)\n\t    {\n\t      char *tt;\n\t      for (; linenum <= _rl_vis_botlin; linenum++)\n\t\t{\n\t\t  tt = VIS_CHARS (linenum);\n\t\t  _rl_move_vert (linenum);\n\t\t  _rl_move_cursor_relative (0, tt);\n\t\t  _rl_clear_to_eol\n\t\t    ((linenum == _rl_vis_botlin) ? strlen (tt) : _rl_screenwidth);\n\t\t}\n\t    }\n\t  _rl_vis_botlin = inv_botlin;\n\n\t  /* CHANGED_SCREEN_LINE is set to 1 if we have moved to a\n\t     different screen line during this redisplay. */\n\t  changed_screen_line = _rl_last_v_pos != cursor_linenum;\n\t  if (changed_screen_line)\n\t    {\n\t      _rl_move_vert (cursor_linenum);\n\t      /* If we moved up to the line with the prompt using _rl_term_up,\n\t\t the physical cursor position on the screen stays the same,\n\t\t but the buffer position needs to be adjusted to account\n\t\t for invisible characters. */\n\t      if ((mb_cur_max == 1 || rl_byte_oriented) && cursor_linenum == 0 && wrap_offset)\n\t\t_rl_last_c_pos += wrap_offset;\n\t    }\n\n\t  /* We have to reprint the prompt if it contains invisible\n\t     characters, since it's not generally OK to just reprint\n\t     the characters from the current cursor position.  But we\n\t     only need to reprint it if the cursor is before the last\n\t     invisible character in the prompt string. */\n\t  nleft = prompt_visible_length + wrap_offset;\n\t  if (cursor_linenum == 0 && wrap_offset > 0 && _rl_last_c_pos > 0 &&\n#if 0\n\t      _rl_last_c_pos <= PROMPT_ENDING_INDEX && local_prompt)\n#else\n\t      _rl_last_c_pos < PROMPT_ENDING_INDEX && local_prompt)\n#endif\n\t    {\n#if defined (__MSDOS__)\n\t      putc ('\\r', rl_outstream);\n#else\n\t      if (_rl_term_cr)\n\t\ttputs (_rl_term_cr, 1, _rl_output_character_function);\n#endif\n\t      if (modmark)\n\t\t_rl_output_some_chars (\"*\", 1);\n\n\t      _rl_output_some_chars (local_prompt, nleft);\n\t      if (mb_cur_max > 1 && rl_byte_oriented == 0)\n\t\t_rl_last_c_pos = _rl_col_width (local_prompt, 0, nleft, 1) - wrap_offset + modmark;\n\t      else\n\t\t_rl_last_c_pos = nleft + modmark;\n\t    }\n\n\t  /* Where on that line?  And where does that line start\n\t     in the buffer? */\n\t  pos = inv_lbreaks[cursor_linenum];\n\t  /* nleft == number of characters in the line buffer between the\n\t     start of the line and the desired cursor position. */\n\t  nleft = cpos_buffer_position - pos;\n\n\t  /* NLEFT is now a number of characters in a buffer.  When in a\n\t     multibyte locale, however, _rl_last_c_pos is an absolute cursor\n\t     position that doesn't take invisible characters in the prompt\n\t     into account.  We use a fudge factor to compensate. */\n\n\t  /* Since _rl_backspace() doesn't know about invisible characters in the\n\t     prompt, and there's no good way to tell it, we compensate for\n\t     those characters here and call _rl_backspace() directly. */\n\t  if (wrap_offset && cursor_linenum == 0 && nleft < _rl_last_c_pos)\n\t    {\n\t      /* TX == new physical cursor position in multibyte locale. */\n\t      if (mb_cur_max > 1 && rl_byte_oriented == 0)\n\t\ttx = _rl_col_width (&visible_line[pos], 0, nleft, 1) - visible_wrap_offset;\n\t      else\n\t\ttx = nleft;\n\t      if (tx >= 0 && _rl_last_c_pos > tx)\n\t\t{\n\t          _rl_backspace (_rl_last_c_pos - tx);\t/* XXX */\n\t          _rl_last_c_pos = tx;\n\t\t}\n\t    }\n\n\t  /* We need to note that in a multibyte locale we are dealing with\n\t     _rl_last_c_pos as an absolute cursor position, but moving to a\n\t     point specified by a buffer position (NLEFT) that doesn't take\n\t     invisible characters into account. */\n\t  if (mb_cur_max > 1 && rl_byte_oriented == 0)\n\t    _rl_move_cursor_relative (nleft, &invisible_line[pos]);\n\t  else if (nleft != _rl_last_c_pos)\n\t    _rl_move_cursor_relative (nleft, &invisible_line[pos]);\n\t}\n    }\n  else\t\t\t\t/* Do horizontal scrolling. */\n    {\n#define M_OFFSET(margin, offset) ((margin) == 0 ? offset : 0)\n      int lmargin, ndisp, nleft, phys_c_pos, t;\n\n      /* Always at top line. */\n      _rl_last_v_pos = 0;\n\n      /* Compute where in the buffer the displayed line should start.  This\n\t will be LMARGIN. */\n\n      /* The number of characters that will be displayed before the cursor. */\n      ndisp = cpos_buffer_position - wrap_offset;\n      nleft  = prompt_visible_length + wrap_offset;\n      /* Where the new cursor position will be on the screen.  This can be\n\t longer than SCREENWIDTH; if it is, lmargin will be adjusted. */\n      phys_c_pos = cpos_buffer_position - (last_lmargin ? last_lmargin : wrap_offset);\n      t = _rl_screenwidth / 3;\n\n      /* If the number of characters had already exceeded the screenwidth,\n\t last_lmargin will be > 0. */\n\n      /* If the number of characters to be displayed is more than the screen\n\t width, compute the starting offset so that the cursor is about\n\t two-thirds of the way across the screen. */\n      if (phys_c_pos > _rl_screenwidth - 2)\n\t{\n\t  lmargin = cpos_buffer_position - (2 * t);\n\t  if (lmargin < 0)\n\t    lmargin = 0;\n\t  /* If the left margin would be in the middle of a prompt with\n\t     invisible characters, don't display the prompt at all. */\n\t  if (wrap_offset && lmargin > 0 && lmargin < nleft)\n\t    lmargin = nleft;\n\t}\n      else if (ndisp < _rl_screenwidth - 2)\t\t/* XXX - was -1 */\n\tlmargin = 0;\n      else if (phys_c_pos < 1)\n\t{\n\t  /* If we are moving back towards the beginning of the line and\n\t     the last margin is no longer correct, compute a new one. */\n\t  lmargin = ((cpos_buffer_position - 1) / t) * t;\t/* XXX */\n\t  if (wrap_offset && lmargin > 0 && lmargin < nleft)\n\t    lmargin = nleft;\n\t}\n      else\n\tlmargin = last_lmargin;\n\n      displaying_prompt_first_line = lmargin < nleft;\n\n      /* If the first character on the screen isn't the first character\n\t in the display line, indicate this with a special character. */\n      if (lmargin > 0)\n\tline[lmargin] = '<';\n\n      /* If SCREENWIDTH characters starting at LMARGIN do not encompass\n\t the whole line, indicate that with a special character at the\n\t right edge of the screen.  If LMARGIN is 0, we need to take the\n\t wrap offset into account. */\n      t = lmargin + M_OFFSET (lmargin, wrap_offset) + _rl_screenwidth;\n      if (t < out)\n\tline[t - 1] = '>';\n\n      if (rl_display_fixed == 0 || forced_display || lmargin != last_lmargin)\n\t{\n\t  forced_display = 0;\n\t  o_cpos = _rl_last_c_pos;\n\t  cpos_adjusted = 0;\n\t  update_line (&visible_line[last_lmargin],\n\t\t       &invisible_line[lmargin],\n\t\t       0,\n\t\t       _rl_screenwidth + visible_wrap_offset,\n\t\t       _rl_screenwidth + (lmargin ? 0 : wrap_offset),\n\t\t       0);\n\n\t  if ((mb_cur_max > 1 && rl_byte_oriented == 0) &&\n\t\tdisplaying_prompt_first_line && OLD_CPOS_IN_PROMPT())\n\t    _rl_last_c_pos -= prompt_invis_chars_first_line;\t/* XXX - was wrap_offset */\n\n\t  /* If the visible new line is shorter than the old, but the number\n\t     of invisible characters is greater, and we are at the end of\n\t     the new line, we need to clear to eol. */\n\t  t = _rl_last_c_pos - M_OFFSET (lmargin, wrap_offset);\n\t  if ((M_OFFSET (lmargin, wrap_offset) > visible_wrap_offset) &&\n\t      (_rl_last_c_pos == out) && displaying_prompt_first_line &&\n\t      t < visible_first_line_len)\n\t    {\n\t      nleft = _rl_screenwidth - t;\n\t      _rl_clear_to_eol (nleft);\n\t    }\n\t  visible_first_line_len = out - lmargin - M_OFFSET (lmargin, wrap_offset);\n\t  if (visible_first_line_len > _rl_screenwidth)\n\t    visible_first_line_len = _rl_screenwidth;\n\n\t  _rl_move_cursor_relative (cpos_buffer_position - lmargin, &invisible_line[lmargin]);\n\t  last_lmargin = lmargin;\n\t}\n    }\n  fflush (rl_outstream);\n\n  /* Swap visible and non-visible lines. */\n  {\n    struct line_state *vtemp = line_state_visible;\n\n    line_state_visible = line_state_invisible;\n    line_state_invisible = vtemp;\n\n    rl_display_fixed = 0;\n    /* If we are displaying on a single line, and last_lmargin is > 0, we\n       are not displaying any invisible characters, so set visible_wrap_offset\n       to 0. */\n    if (_rl_horizontal_scroll_mode && last_lmargin)\n      visible_wrap_offset = 0;\n    else\n      visible_wrap_offset = wrap_offset;\n  }\n\n  RL_UNSETSTATE (RL_STATE_REDISPLAYING);\n  _rl_release_sigint ();\n}",
      "lines": 788,
      "depth": 20,
      "decorators": [
        "void"
      ]
    },
    "rl_on_new_line": {
      "start_point": [
        2018,
        0
      ],
      "end_point": [
        2030,
        1
      ],
      "content": "int\nrl_on_new_line ()\n{\n  if (visible_line)\n    visible_line[0] = '\\0';\n\n  _rl_last_c_pos = _rl_last_v_pos = 0;\n  _rl_vis_botlin = last_lmargin = 0;\n  if (vis_lbreaks)\n    vis_lbreaks[0] = vis_lbreaks[1] = 0;\n  visible_wrap_offset = 0;\n  return 0;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "rl_clear_visible_line": {
      "start_point": [
        2034,
        0
      ],
      "end_point": [
        2058,
        1
      ],
      "content": "int\nrl_clear_visible_line ()\n{\n  int curr_line;\n\n  /* Make sure we move to column 0 so we clear the entire line */\n#if defined (__MSDOS__)\n  putc ('\\r', rl_outstream);\n#else\n  tputs (_rl_term_cr, 1, _rl_output_character_function);\n#endif\n  _rl_last_c_pos = 0;\n\n  /* Move to the last screen line of the current visible line */\n  _rl_move_vert (_rl_vis_botlin);\n\n  /* And erase screen lines going up to line 0 (first visible line) */\n  for (curr_line = _rl_last_v_pos; curr_line >= 0; curr_line--)\n    {\n      _rl_move_vert (curr_line);\n      _rl_clear_to_eol (0);\n    }\n\n  return 0;\n}",
      "lines": 25,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "rl_on_new_line_with_prompt": {
      "start_point": [
        2064,
        0
      ],
      "end_point": [
        2117,
        1
      ],
      "content": "int\nrl_on_new_line_with_prompt ()\n{\n  int prompt_size, i, l, real_screenwidth, newlines;\n  char *prompt_last_line, *lprompt;\n\n  /* Initialize visible_line and invisible_line to ensure that they can hold\n     the already-displayed prompt. */\n  prompt_size = strlen (rl_prompt) + 1;\n  init_line_structures (prompt_size);\n\n  /* Make sure the line structures hold the already-displayed prompt for\n     redisplay. */\n  lprompt = local_prompt ? local_prompt : rl_prompt;\n  strcpy (visible_line, lprompt);\n  strcpy (invisible_line, lprompt);\n\n  /* If the prompt contains newlines, take the last tail. */\n  prompt_last_line = strrchr (rl_prompt, '\\n');\n  if (!prompt_last_line)\n    prompt_last_line = rl_prompt;\n\n  l = strlen (prompt_last_line);\n  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n    _rl_last_c_pos = _rl_col_width (prompt_last_line, 0, l, 1);\t/* XXX */\n  else\n    _rl_last_c_pos = l;\n\n  /* Dissect prompt_last_line into screen lines. Note that here we have\n     to use the real screenwidth. Readline's notion of screenwidth might be\n     one less, see terminal.c. */\n  real_screenwidth = _rl_screenwidth + (_rl_term_autowrap ? 0 : 1);\n  _rl_last_v_pos = l / real_screenwidth;\n  /* If the prompt length is a multiple of real_screenwidth, we don't know\n     whether the cursor is at the end of the last line, or already at the\n     beginning of the next line. Output a newline just to be safe. */\n  if (l > 0 && (l % real_screenwidth) == 0)\n    _rl_output_some_chars (\"\\n\", 1);\n  last_lmargin = 0;\n\n  newlines = 0; i = 0;\n  while (i <= l)\n    {\n      _rl_vis_botlin = newlines;\n      vis_lbreaks[newlines++] = i;\n      i += real_screenwidth;\n    }\n  vis_lbreaks[newlines] = l;\n  visible_wrap_offset = 0;\n\n  rl_display_prompt = rl_prompt;\t/* XXX - make sure it's set */\n\n  return 0;\n}",
      "lines": 54,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "rl_forced_update_display": {
      "start_point": [
        2120,
        0
      ],
      "end_point": [
        2135,
        1
      ],
      "content": "int\nrl_forced_update_display ()\n{\n  register char *temp;\n\n  if (visible_line)\n    {\n      temp = visible_line;\n      while (*temp)\n\t*temp++ = '\\0';\n    }\n  rl_on_new_line ();\n  forced_display++;\n  (*rl_redisplay_function) ();\n  return 0;\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "rl_redraw_prompt_last_line": {
      "start_point": [
        2138,
        0
      ],
      "end_point": [
        2148,
        1
      ],
      "content": "void\nrl_redraw_prompt_last_line ()\n{\n  char *t;\n\n  t = strrchr (rl_display_prompt, '\\n');\n  if (t)\n    redraw_prompt (++t);\n  else\n    rl_forced_update_display ();\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "rl_clear_message": {
      "start_point": [
        2520,
        0
      ],
      "end_point": [
        2531,
        1
      ],
      "content": "int\nrl_clear_message ()\n{\n  rl_display_prompt = rl_prompt;\n  if (msg_saved_prompt)\n    {\n      rl_restore_prompt ();\n      msg_saved_prompt = 0;\n    }\n  (*rl_redisplay_function) ();\n  return 0;\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "rl_reset_line_state": {
      "start_point": [
        2533,
        0
      ],
      "end_point": [
        2541,
        1
      ],
      "content": "int\nrl_reset_line_state ()\n{\n  rl_on_new_line ();\n\n  rl_display_prompt = rl_prompt ? rl_prompt : \"\";\n  forced_display = 1;\n  return 0;\n}",
      "lines": 9,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "rl_save_prompt": {
      "start_point": [
        2543,
        0
      ],
      "end_point": [
        2559,
        1
      ],
      "content": "void\nrl_save_prompt ()\n{\n  saved_local_prompt = local_prompt;\n  saved_local_prefix = local_prompt_prefix;\n  saved_prefix_length = prompt_prefix_length;\n  saved_local_length = local_prompt_len;\n  saved_last_invisible = prompt_last_invisible;\n  saved_visible_length = prompt_visible_length;\n  saved_invis_chars_first_line = prompt_invis_chars_first_line;\n  saved_physical_chars = prompt_physical_chars;\n\n  local_prompt = local_prompt_prefix = (char *)0;\n  local_prompt_len = 0;\n  prompt_last_invisible = prompt_visible_length = prompt_prefix_length = 0;\n  prompt_invis_chars_first_line = prompt_physical_chars = 0;\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "rl_restore_prompt": {
      "start_point": [
        2561,
        0
      ],
      "end_point": [
        2581,
        1
      ],
      "content": "void\nrl_restore_prompt ()\n{\n  FREE (local_prompt);\n  FREE (local_prompt_prefix);\n\n  local_prompt = saved_local_prompt;\n  local_prompt_prefix = saved_local_prefix;\n  local_prompt_len = saved_local_length;\n  prompt_prefix_length = saved_prefix_length;\n  prompt_last_invisible = saved_last_invisible;\n  prompt_visible_length = saved_visible_length;\n  prompt_invis_chars_first_line = saved_invis_chars_first_line;\n  prompt_physical_chars = saved_physical_chars;\n\n  /* can test saved_local_prompt to see if prompt info has been saved. */\n  saved_local_prompt = saved_local_prefix = (char *)0;\n  saved_local_length = 0;\n  saved_last_invisible = saved_visible_length = saved_prefix_length = 0;\n  saved_invis_chars_first_line = saved_physical_chars = 0;\n}",
      "lines": 21,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "_rl_clear_screen": {
      "start_point": [
        2666,
        0
      ],
      "end_point": [
        2678,
        1
      ],
      "content": "void\n_rl_clear_screen ()\n{\n#ifndef __DJGPP__\n  if (_rl_term_clrpag)\n    tputs (_rl_term_clrpag, 1, _rl_output_character_function);\n  else\n    rl_crlf ();\n#else\n  ScreenClear ();\n  ScreenSetCursor (0, 0);\n#endif /* __DJGPP__ */\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "_rl_update_final": {
      "start_point": [
        2753,
        0
      ],
      "end_point": [
        2783,
        1
      ],
      "content": "void\n_rl_update_final ()\n{\n  int full_lines;\n\n  full_lines = 0;\n  /* If the cursor is the only thing on an otherwise-blank last line,\n     compensate so we don't print an extra CRLF. */\n  if (_rl_vis_botlin && _rl_last_c_pos == 0 &&\n\tvisible_line[vis_lbreaks[_rl_vis_botlin]] == 0)\n    {\n      _rl_vis_botlin--;\n      full_lines = 1;\n    }\n  _rl_move_vert (_rl_vis_botlin);\n  /* If we've wrapped lines, remove the final xterm line-wrap flag. */\n  if (full_lines && _rl_term_autowrap && (VIS_LLEN(_rl_vis_botlin) == _rl_screenwidth))\n    {\n      char *last_line;\n\n      last_line = &visible_line[vis_lbreaks[_rl_vis_botlin]];\n      cpos_buffer_position = -1;\t/* don't know where we are in buffer */\n      _rl_move_cursor_relative (_rl_screenwidth - 1, last_line);\t/* XXX */\n      _rl_clear_to_eol (0);\n      putc (last_line[_rl_screenwidth - 1], rl_outstream);\n    }\n  _rl_vis_botlin = 0;\n  rl_crlf ();\n  fflush (rl_outstream);\n  rl_display_fixed++;\n}",
      "lines": 31,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "cr": {
      "start_point": [
        2786,
        0
      ],
      "end_point": [
        2798,
        1
      ],
      "content": "static void\ncr ()\n{\n  if (_rl_term_cr)\n    {\n#if defined (__MSDOS__)\n      putc ('\\r', rl_outstream);\n#else\n      tputs (_rl_term_cr, 1, _rl_output_character_function);\n#endif\n      _rl_last_c_pos = 0;\n    }\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "_rl_redisplay_after_sigwinch": {
      "start_point": [
        2828,
        0
      ],
      "end_point": [
        2871,
        1
      ],
      "content": "void\n_rl_redisplay_after_sigwinch ()\n{\n  char *t;\n\n  /* Clear the last line (assuming that the screen size change will result in\n     either more or fewer characters on that line only) and put the cursor at\n     column 0.  Make sure the right thing happens if we have wrapped to a new\n     screen line. */\n  if (_rl_term_cr)\n    {\n      _rl_move_vert (_rl_vis_botlin);\n\n#if defined (__MSDOS__)\n      putc ('\\r', rl_outstream);\n#else\n      tputs (_rl_term_cr, 1, _rl_output_character_function);\n#endif\n      _rl_last_c_pos = 0;\n#if defined (__MSDOS__)\n      space_to_eol (_rl_screenwidth);\n      putc ('\\r', rl_outstream);\n#else\n      if (_rl_term_clreol)\n\ttputs (_rl_term_clreol, 1, _rl_output_character_function);\n      else\n\t{\n\t  space_to_eol (_rl_screenwidth);\n\t  tputs (_rl_term_cr, 1, _rl_output_character_function);\n\t}\n#endif\n      if (_rl_last_v_pos > 0)\n\t_rl_move_vert (0);\n    }\n  else\n    rl_crlf ();\n\n  /* Redraw only the last line of a multi-line prompt. */\n  t = strrchr (rl_display_prompt, '\\n');\n  if (t)\n    redraw_prompt (++t);\n  else\n    rl_forced_update_display ();\n}",
      "lines": 44,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "_rl_clean_up_for_exit": {
      "start_point": [
        2873,
        0
      ],
      "end_point": [
        2884,
        1
      ],
      "content": "void\n_rl_clean_up_for_exit ()\n{\n  if (_rl_echoing_p)\n    {\n      if (_rl_vis_botlin > 0)\t/* minor optimization plus bug fix */\n\t_rl_move_vert (_rl_vis_botlin);\n      _rl_vis_botlin = 0;\n      fflush (rl_outstream);\n      rl_restart_output (1, 0);\n    }\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "_rl_erase_entire_line": {
      "start_point": [
        2886,
        0
      ],
      "end_point": [
        2893,
        1
      ],
      "content": "void\n_rl_erase_entire_line ()\n{\n  cr ();\n  _rl_clear_to_eol (0);\n  cr ();\n  fflush (rl_outstream);\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "_rl_ttyflush": {
      "start_point": [
        2895,
        0
      ],
      "end_point": [
        2899,
        1
      ],
      "content": "void\n_rl_ttyflush ()\n{\n  fflush (rl_outstream);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "_rl_current_display_line": {
      "start_point": [
        2903,
        0
      ],
      "end_point": [
        2921,
        1
      ],
      "content": "int\n_rl_current_display_line ()\n{\n  int ret, nleft;\n\n  /* Find out whether or not there might be invisible characters in the\n     editing buffer. */\n  if (rl_display_prompt == rl_prompt)\n    nleft = _rl_last_c_pos - _rl_screenwidth - rl_visible_prompt_length;\n  else\n    nleft = _rl_last_c_pos - _rl_screenwidth;\n\n  if (nleft > 0)\n    ret = 1 + nleft / _rl_screenwidth;\n  else\n    ret = 0;\n\n  return ret;\n}",
      "lines": 19,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "readline/readline-7.0/emacs_keymap.c": {},
  "readline/readline-7.0/funmap.c": {
    "rl_initialize_funmap": {
      "start_point": [
        227,
        0
      ],
      "end_point": [
        240,
        1
      ],
      "content": "void\nrl_initialize_funmap ()\n{\n  register int i;\n\n  if (funmap_initialized)\n    return;\n\n  for (i = 0; default_funmap[i].name; i++)\n    rl_add_funmap_entry (default_funmap[i].name, default_funmap[i].function);\n\n  funmap_initialized = 1;\n  funmap_program_specific_entry_start = i;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "rl_funmap_names": {
      "start_point": [
        245,
        0
      ],
      "end_point": [
        268,
        1
      ],
      "content": "const char **\nrl_funmap_names ()\n{\n  const char **result;\n  int result_size, result_index;\n\n  /* Make sure that the function map has been initialized. */\n  rl_initialize_funmap ();\n\n  for (result_index = result_size = 0, result = (const char **)NULL; funmap[result_index]; result_index++)\n    {\n      if (result_index + 2 > result_size)\n\t{\n\t  result_size += 20;\n\t  result = (const char **)xrealloc (result, result_size * sizeof (char *));\n\t}\n\n      result[result_index] = funmap[result_index]->name;\n      result[result_index + 1] = (char *)NULL;\n    }\n\n  qsort (result, result_index, sizeof (char *), (QSFUNC *)_rl_qsort_string_compare);\n  return (result);\n}",
      "lines": 24,
      "depth": 16,
      "decorators": [
        "const",
        "const",
        "char",
        "**\nrl_funmap_names ()",
        "*",
        "*\nrl_funmap_names ()",
        "*"
      ]
    }
  },
  "readline/readline-7.0/histexpand.c": {
    "postproc_subst_rhs": {
      "start_point": [
        491,
        0
      ],
      "end_point": [
        521,
        1
      ],
      "content": "static void\npostproc_subst_rhs ()\n{\n  char *new;\n  int i, j, new_size;\n\n  new = (char *)xmalloc (new_size = subst_rhs_len + subst_lhs_len);\n  for (i = j = 0; i < subst_rhs_len; i++)\n    {\n      if (subst_rhs[i] == '&')\n\t{\n\t  if (j + subst_lhs_len >= new_size)\n\t    new = (char *)xrealloc (new, (new_size = new_size * 2 + subst_lhs_len));\n\t  strcpy (new + j, subst_lhs);\n\t  j += subst_lhs_len;\n\t}\n      else\n\t{\n\t  /* a single backslash protects the `&' from lhs interpolation */\n\t  if (subst_rhs[i] == '\\\\' && subst_rhs[i + 1] == '&')\n\t    i++;\n\t  if (j >= new_size)\n\t    new = (char *)xrealloc (new, new_size *= 2);\n\t  new[j++] = subst_rhs[i];\n\t}\n    }\n  new[j] = '\\0';\n  xfree (subst_rhs);\n  subst_rhs = new;\n  subst_rhs_len = j;\n}",
      "lines": 31,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "readline/readline-7.0/histfile.c": {},
  "readline/readline-7.0/histlib.h": {},
  "readline/readline-7.0/history.c": {
    "history_get_history_state": {
      "start_point": [
        96,
        0
      ],
      "end_point": [
        111,
        1
      ],
      "content": "HISTORY_STATE *\nhistory_get_history_state ()\n{\n  HISTORY_STATE *state;\n\n  state = (HISTORY_STATE *)xmalloc (sizeof (HISTORY_STATE));\n  state->entries = the_history;\n  state->offset = history_offset;\n  state->length = history_length;\n  state->size = history_size;\n  state->flags = 0;\n  if (history_stifled)\n    state->flags |= HS_STIFLED;\n\n  return (state);\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "HISTORY_STATE",
        "*\nhistory_get_history_state ()",
        "*"
      ]
    },
    "using_history": {
      "start_point": [
        128,
        0
      ],
      "end_point": [
        132,
        1
      ],
      "content": "void\nusing_history ()\n{\n  history_offset = history_length;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "void"
      ]
    },
    "history_total_bytes": {
      "start_point": [
        137,
        0
      ],
      "end_point": [
        146,
        1
      ],
      "content": "int\nhistory_total_bytes ()\n{\n  register int i, result;\n\n  for (i = result = 0; the_history && the_history[i]; i++)\n    result += HISTENT_BYTES (the_history[i]);\n\n  return (result);\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "where_history": {
      "start_point": [
        150,
        0
      ],
      "end_point": [
        154,
        1
      ],
      "content": "int\nwhere_history ()\n{\n  return (history_offset);\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    },
    "history_list": {
      "start_point": [
        171,
        0
      ],
      "end_point": [
        175,
        1
      ],
      "content": "HIST_ENTRY **\nhistory_list ()\n{\n  return (the_history);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "HIST_ENTRY",
        "**\nhistory_list ()",
        "*",
        "*\nhistory_list ()",
        "*"
      ]
    },
    "current_history": {
      "start_point": [
        179,
        0
      ],
      "end_point": [
        185,
        1
      ],
      "content": "HIST_ENTRY *\ncurrent_history ()\n{\n  return ((history_offset == history_length) || the_history == 0)\n\t\t? (HIST_ENTRY *)NULL\n\t\t: the_history[history_offset];\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "HIST_ENTRY",
        "*\ncurrent_history ()",
        "*"
      ]
    },
    "previous_history": {
      "start_point": [
        190,
        0
      ],
      "end_point": [
        194,
        1
      ],
      "content": "HIST_ENTRY *\nprevious_history ()\n{\n  return history_offset ? the_history[--history_offset] : (HIST_ENTRY *)NULL;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "HIST_ENTRY",
        "*\nprevious_history ()",
        "*"
      ]
    },
    "next_history": {
      "start_point": [
        199,
        0
      ],
      "end_point": [
        203,
        1
      ],
      "content": "HIST_ENTRY *\nnext_history ()\n{\n  return (history_offset == history_length) ? (HIST_ENTRY *)NULL : the_history[++history_offset];\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "HIST_ENTRY",
        "*\nnext_history ()",
        "*"
      ]
    },
    "hist_inittime": {
      "start_point": [
        254,
        0
      ],
      "end_point": [
        270,
        1
      ],
      "content": "static char *\nhist_inittime ()\n{\n  time_t t;\n  char ts[64], *ret;\n\n  t = (time_t) time ((time_t *)0);\n#if defined (HAVE_VSNPRINTF)\t\t/* assume snprintf if vsnprintf exists */\n  snprintf (ts, sizeof (ts) - 1, \"X%lu\", (unsigned long) t);\n#else\n  sprintf (ts, \"X%lu\", (unsigned long) t);\n#endif\n  ret = savestring (ts);\n  ret[0] = history_comment_char;\n\n  return ret;\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nhist_inittime ()",
        "*"
      ]
    },
    "unstifle_history": {
      "start_point": [
        531,
        0
      ],
      "end_point": [
        541,
        1
      ],
      "content": "int\nunstifle_history ()\n{\n  if (history_stifled)\n    {\n      history_stifled = 0;\n      return (history_max_entries);\n    }\n  else\n    return (-history_max_entries);\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "history_is_stifled": {
      "start_point": [
        543,
        0
      ],
      "end_point": [
        547,
        1
      ],
      "content": "int\nhistory_is_stifled ()\n{\n  return (history_stifled);\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    },
    "clear_history": {
      "start_point": [
        549,
        0
      ],
      "end_point": [
        562,
        1
      ],
      "content": "void\nclear_history ()\n{\n  register int i;\n\n  /* This loses because we cannot free the data. */\n  for (i = 0; i < history_length; i++)\n    {\n      free_history_entry (the_history[i]);\n      the_history[i] = (HIST_ENTRY *)NULL;\n    }\n\n  history_offset = history_length = 0;\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "readline/readline-7.0/history.h": {},
  "readline/readline-7.0/histsearch.c": {},
  "readline/readline-7.0/input.c": {
    "win32_isatty": {
      "start_point": [
        104,
        0
      ],
      "end_point": [
        108,
        1
      ],
      "content": "int\nwin32_isatty (int fd)\n{\n  return (_isatty (fd) ? ((((long) (HANDLE) _get_osfhandle (fd)) & 3) == 3) : 0);\n}",
      "lines": 5,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "_rl_any_typein": {
      "start_point": [
        125,
        0
      ],
      "end_point": [
        129,
        1
      ],
      "content": "int\n_rl_any_typein ()\n{\n  return any_typein;\n}",
      "lines": 5,
      "depth": 4,
      "decorators": [
        "int"
      ]
    },
    "_rl_pushed_input_available": {
      "start_point": [
        131,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "int\n_rl_pushed_input_available ()\n{\n  return (push_index != pop_index);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "ibuffer_space": {
      "start_point": [
        139,
        0
      ],
      "end_point": [
        146,
        1
      ],
      "content": "static int\nibuffer_space ()\n{\n  if (pop_index > push_index)\n    return (pop_index - push_index - 1);\n  else\n    return (ibuffer_len - (push_index - pop_index));\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rl_gather_tyi": {
      "start_point": [
        190,
        0
      ],
      "end_point": [
        291,
        1
      ],
      "content": "static int\nrl_gather_tyi ()\n{\n  int tty;\n  register int tem, result;\n  int chars_avail, k;\n  char input;\n#if defined(HAVE_SELECT)\n  fd_set readfds, exceptfds;\n  struct timeval timeout;\n#endif\n\n  chars_avail = 0;\n  input = 0;\n  tty = fileno (rl_instream);\n\n#if defined (HAVE_SELECT)\n  FD_ZERO (&readfds);\n  FD_ZERO (&exceptfds);\n  FD_SET (tty, &readfds);\n  FD_SET (tty, &exceptfds);\n  USEC_TO_TIMEVAL (_keyboard_input_timeout, timeout);\n  result = select (tty + 1, &readfds, (fd_set *)NULL, &exceptfds, &timeout);\n  if (result <= 0)\n    return 0;\t/* Nothing to read. */\n#endif\n\n  result = -1;\n  errno = 0;\n#if defined (FIONREAD)\n  result = ioctl (tty, FIONREAD, &chars_avail);\n  if (result == -1 && errno == EIO)\n    return -1;\n  if (result == -1)\n    chars_avail = 0;\n#endif\n\n#if defined (O_NDELAY)\n  if (result == -1)\n    {\n      tem = fcntl (tty, F_GETFL, 0);\n\n      fcntl (tty, F_SETFL, (tem | O_NDELAY));\n      chars_avail = read (tty, &input, 1);\n\n      fcntl (tty, F_SETFL, tem);\n      if (chars_avail == -1 && errno == EAGAIN)\n\treturn 0;\n      if (chars_avail == -1 && errno == EIO)\n\treturn -1;\n      if (chars_avail == 0)\t/* EOF */\n\t{\n\t  rl_stuff_char (EOF);\n\t  return (0);\n\t}\n    }\n#endif /* O_NDELAY */\n\n#if defined (__MINGW32__)\n  /* Use getch/_kbhit to check for available console input, in the same way\n     that we read it normally. */\n   chars_avail = isatty (tty) ? _kbhit () : 0;\n   result = 0;\n#endif\n\n  /* If there's nothing available, don't waste time trying to read\n     something. */\n  if (chars_avail <= 0)\n    return 0;\n\n  tem = ibuffer_space ();\n\n  if (chars_avail > tem)\n    chars_avail = tem;\n\n  /* One cannot read all of the available input.  I can only read a single\n     character at a time, or else programs which require input can be\n     thwarted.  If the buffer is larger than one character, I lose.\n     Damn! */\n  if (tem < ibuffer_len)\n    chars_avail = 0;\n\n  if (result != -1)\n    {\n      while (chars_avail--)\n\t{\n\t  RL_CHECK_SIGNALS ();\n\t  k = (*rl_getc_function) (rl_instream);\n\t  if (rl_stuff_char (k) == 0)\n\t    break;\t\t\t/* some problem; no more room */\n\t  if (k == NEWLINE || k == RETURN)\n\t    break;\n\t}\n    }\n  else\n    {\n      if (chars_avail)\n\trl_stuff_char (input);\n    }\n\n  return 1;\n}",
      "lines": 102,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "_rl_input_available": {
      "start_point": [
        311,
        0
      ],
      "end_point": [
        351,
        1
      ],
      "content": "int\n_rl_input_available ()\n{\n#if defined(HAVE_SELECT)\n  fd_set readfds, exceptfds;\n  struct timeval timeout;\n#endif\n#if !defined (HAVE_SELECT) && defined(FIONREAD)\n  int chars_avail;\n#endif\n  int tty;\n\n  if (rl_input_available_hook)\n    return (*rl_input_available_hook) ();\n\n  tty = fileno (rl_instream);\n\n#if defined (HAVE_SELECT)\n  FD_ZERO (&readfds);\n  FD_ZERO (&exceptfds);\n  FD_SET (tty, &readfds);\n  FD_SET (tty, &exceptfds);\n  timeout.tv_sec = 0;\n  timeout.tv_usec = _keyboard_input_timeout;\n  return (select (tty + 1, &readfds, (fd_set *)NULL, &exceptfds, &timeout) > 0);\n#else\n\n#if defined (FIONREAD)\n  if (ioctl (tty, FIONREAD, &chars_avail) == 0)\n    return (chars_avail);\n#endif\n\n#endif\n\n#if defined (__MINGW32__)\n  if (isatty (tty))\n    return (_kbhit ());\n#endif\n\n  return 0;\n}",
      "lines": 41,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "rl_clear_pending_input": {
      "start_point": [
        426,
        0
      ],
      "end_point": [
        432,
        1
      ],
      "content": "int\nrl_clear_pending_input ()\n{\n  rl_pending_input = 0;\n  RL_UNSETSTATE (RL_STATE_INPUTPENDING);\n  return 0;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "rl_read_key": {
      "start_point": [
        441,
        0
      ],
      "end_point": [
        489,
        1
      ],
      "content": "int\nrl_read_key ()\n{\n  int c, r;\n\n  if (rl_pending_input)\n    {\n      c = rl_pending_input;\n      rl_clear_pending_input ();\n    }\n  else\n    {\n      /* If input is coming from a macro, then use that. */\n      if (c = _rl_next_macro_key ())\n\treturn (c);\n\n      /* If the user has an event function, then call it periodically. */\n      if (rl_event_hook)\n\t{\n\t  while (rl_event_hook)\n\t    {\n\t      if (rl_get_char (&c) != 0)\n\t\tbreak;\n\t\t\n\t      if ((r = rl_gather_tyi ()) < 0)\t/* XXX - EIO */\n\t\t{\n\t\t  rl_done = 1;\n\t\t  return (errno == EIO ? (RL_ISSTATE (RL_STATE_READCMD) ? READERR : EOF) : '\\n');\n\t\t}\n\t      else if (r > 0)\t\t\t/* read something */\n\t\tcontinue;\n\n\t      RL_CHECK_SIGNALS ();\n\t      if (rl_done)\t\t/* XXX - experimental */\n\t\treturn ('\\n');\n\t      (*rl_event_hook) ();\n\t    }\n\t}\n      else\n\t{\n\t  if (rl_get_char (&c) == 0)\n\t    c = (*rl_getc_function) (rl_instream);\n/* fprintf(stderr, \"rl_read_key: calling RL_CHECK_SIGNALS: _rl_caught_signal = %d\", _rl_caught_signal); */\n\t  RL_CHECK_SIGNALS ();\n\t}\n    }\n\n  return (c);\n}",
      "lines": 49,
      "depth": 18,
      "decorators": [
        "int"
      ]
    }
  },
  "readline/readline-7.0/isearch.c": {},
  "readline/readline-7.0/keymaps.c": {
    "rl_make_bare_keymap": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "Keymap\nrl_make_bare_keymap ()\n{\n  register int i;\n  Keymap keymap;\n\n  keymap = (Keymap)xmalloc (KEYMAP_SIZE * sizeof (KEYMAP_ENTRY));\n  for (i = 0; i < KEYMAP_SIZE; i++)\n    {\n      keymap[i].type = ISFUNC;\n      keymap[i].function = (rl_command_func_t *)NULL;\n    }\n\n#if 0\n  for (i = 'A'; i < ('Z' + 1); i++)\n    {\n      keymap[i].type = ISFUNC;\n      keymap[i].function = rl_do_lowercase_version;\n    }\n#endif\n\n  return (keymap);\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "Keymap"
      ]
    },
    "rl_make_keymap": {
      "start_point": [
        100,
        0
      ],
      "end_point": [
        123,
        1
      ],
      "content": "Keymap\nrl_make_keymap ()\n{\n  register int i;\n  Keymap newmap;\n\n  newmap = rl_make_bare_keymap ();\n\n  /* All ASCII printing characters are self-inserting. */\n  for (i = ' '; i < 127; i++)\n    newmap[i].function = rl_insert;\n\n  newmap[TAB].function = rl_insert;\n  newmap[RUBOUT].function = rl_rubout;\t/* RUBOUT == 127 */\n  newmap[CTRL('H')].function = rl_rubout;\n\n#if KEYMAP_SIZE > 128\n  /* Printing characters in ISO Latin-1 and some 8-bit character sets. */\n  for (i = 128; i < 256; i++)\n    newmap[i].function = rl_insert;\n#endif /* KEYMAP_SIZE > 128 */\n\n  return (newmap);\n}",
      "lines": 24,
      "depth": 10,
      "decorators": [
        "Keymap"
      ]
    }
  },
  "readline/readline-7.0/keymaps.h": {},
  "readline/readline-7.0/kill.c": {},
  "readline/readline-7.0/macro.c": {
    "_rl_next_macro_key": {
      "start_point": [
        99,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "int\n_rl_next_macro_key ()\n{\n  int c;\n\n  if (rl_executing_macro == 0)\n    return (0);\n\n  if (rl_executing_macro[executing_macro_index] == 0)\n    {\n      _rl_pop_executing_macro ();\n      return (_rl_next_macro_key ());\n    }\n\n#if defined (READLINE_CALLBACKS)\n  c = rl_executing_macro[executing_macro_index++];\n  if (RL_ISSTATE (RL_STATE_CALLBACK) && RL_ISSTATE (RL_STATE_READCMD|RL_STATE_MOREINPUT) && rl_executing_macro[executing_macro_index] == 0)\n      _rl_pop_executing_macro ();\n  return c;\n#else\n  return (rl_executing_macro[executing_macro_index++]);\n#endif\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "_rl_prev_macro_key": {
      "start_point": [
        123,
        0
      ],
      "end_point": [
        134,
        1
      ],
      "content": "int\n_rl_prev_macro_key ()\n{\n  if (rl_executing_macro == 0)\n    return (0);\n\n  if (executing_macro_index == 0)\n    return (0);\n\n  executing_macro_index--;\n  return (rl_executing_macro[executing_macro_index]);\n}",
      "lines": 12,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "_rl_push_executing_macro": {
      "start_point": [
        137,
        0
      ],
      "end_point": [
        148,
        1
      ],
      "content": "void\n_rl_push_executing_macro ()\n{\n  struct saved_macro *saver;\n\n  saver = (struct saved_macro *)xmalloc (sizeof (struct saved_macro));\n  saver->next = macro_list;\n  saver->sindex = executing_macro_index;\n  saver->string = rl_executing_macro;\n\n  macro_list = saver;\n}",
      "lines": 12,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "_rl_pop_executing_macro": {
      "start_point": [
        152,
        0
      ],
      "end_point": [
        172,
        1
      ],
      "content": "void\n_rl_pop_executing_macro ()\n{\n  struct saved_macro *macro;\n\n  FREE (rl_executing_macro);\n  rl_executing_macro = (char *)NULL;\n  executing_macro_index = 0;\n\n  if (macro_list)\n    {\n      macro = macro_list;\n      rl_executing_macro = macro_list->string;\n      executing_macro_index = macro_list->sindex;\n      macro_list = macro_list->next;\n      xfree (macro);\n    }\n\n  if (rl_executing_macro == 0)\n    RL_UNSETSTATE(RL_STATE_MACROINPUT);\n}",
      "lines": 21,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "_rl_kill_kbd_macro": {
      "start_point": [
        191,
        0
      ],
      "end_point": [
        206,
        1
      ],
      "content": "void\n_rl_kill_kbd_macro ()\n{\n  if (current_macro)\n    {\n      xfree (current_macro);\n      current_macro = (char *) NULL;\n    }\n  current_macro_size = current_macro_index = 0;\n\n  FREE (rl_executing_macro);\n  rl_executing_macro = (char *) NULL;\n  executing_macro_index = 0;\n\n  RL_UNSETSTATE(RL_STATE_MACRODEF);\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "readline/readline-7.0/mbutil.c": {},
  "readline/readline-7.0/misc.c": {
    "_rl_arg_overflow": {
      "start_point": [
        77,
        0
      ],
      "end_point": [
        91,
        1
      ],
      "content": "int\n_rl_arg_overflow ()\n{\n  if (rl_numeric_arg > 1000000)\n    {\n      _rl_argcxt = 0;\n      rl_explicit_arg = rl_numeric_arg = 0;\n      rl_ding ();\n      rl_restore_prompt ();\n      rl_clear_message ();\n      RL_UNSETSTATE(RL_STATE_NUMERICARG);\n      return 1;\n    }\n  return 0;\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "_rl_arg_init": {
      "start_point": [
        93,
        0
      ],
      "end_point": [
        99,
        1
      ],
      "content": "void\n_rl_arg_init ()\n{\n  rl_save_prompt ();\n  _rl_argcxt = 0;\n  RL_SETSTATE(RL_STATE_NUMERICARG);\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "_rl_arg_getchar": {
      "start_point": [
        101,
        0
      ],
      "end_point": [
        112,
        1
      ],
      "content": "int\n_rl_arg_getchar ()\n{\n  int c;\n\n  rl_message (\"(arg: %d) \", rl_arg_sign * rl_numeric_arg);\n  RL_SETSTATE(RL_STATE_MOREINPUT);\n  c = rl_read_key ();\n  RL_UNSETSTATE(RL_STATE_MOREINPUT);\n\n  return c;\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "rl_digit_loop": {
      "start_point": [
        194,
        0
      ],
      "end_point": [
        218,
        1
      ],
      "content": "static int\nrl_digit_loop ()\n{\n  int c, r;\n\n  while (1)\n    {\n      if (_rl_arg_overflow ())\n\treturn 1;\n\n      c = _rl_arg_getchar ();\n\n      if (c < 0)\n\t{\n\t  _rl_abort_internal ();\n\t  return -1;\n\t}\n\n      r = _rl_arg_dispatch (_rl_argcxt, c);\n      if (r <= 0 || (RL_ISSTATE (RL_STATE_NUMERICARG) == 0))\n        break;\n    }\n\n  return r;\n}",
      "lines": 25,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "_rl_reset_argument": {
      "start_point": [
        221,
        0
      ],
      "end_point": [
        227,
        1
      ],
      "content": "void\n_rl_reset_argument ()\n{\n  rl_numeric_arg = rl_arg_sign = 1;\n  rl_explicit_arg = 0;\n  _rl_argcxt = 0;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "rl_discard_argument": {
      "start_point": [
        286,
        0
      ],
      "end_point": [
        294,
        1
      ],
      "content": "int\nrl_discard_argument ()\n{\n  rl_ding ();\n  rl_clear_message ();\n  _rl_reset_argument ();\n\n  return 0;\n}",
      "lines": 9,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "_rl_start_using_history": {
      "start_point": [
        311,
        0
      ],
      "end_point": [
        319,
        1
      ],
      "content": "void\n_rl_start_using_history ()\n{\n  using_history ();\n  if (_rl_saved_line_for_history)\n    _rl_free_history_entry (_rl_saved_line_for_history);\n\n  _rl_saved_line_for_history = (HIST_ENTRY *)NULL;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "rl_maybe_replace_line": {
      "start_point": [
        336,
        0
      ],
      "end_point": [
        351,
        1
      ],
      "content": "int\nrl_maybe_replace_line ()\n{\n  HIST_ENTRY *temp;\n\n  temp = current_history ();\n  /* If the current line has changed, save the changes. */\n  if (temp && ((UNDO_LIST *)(temp->data) != rl_undo_list))\n    {\n      temp = replace_history_entry (where_history (), rl_line_buffer, (histdata_t)rl_undo_list);\n      xfree (temp->line);\n      FREE (temp->timestamp);\n      xfree (temp);\n    }\n  return 0;\n}",
      "lines": 16,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "rl_maybe_unsave_line": {
      "start_point": [
        354,
        0
      ],
      "end_point": [
        370,
        1
      ],
      "content": "int\nrl_maybe_unsave_line ()\n{\n  if (_rl_saved_line_for_history)\n    {\n      /* Can't call with `1' because rl_undo_list might point to an undo\n\t list from a history entry, as in rl_replace_from_history() below. */\n      rl_replace_line (_rl_saved_line_for_history->line, 0);\n      rl_undo_list = (UNDO_LIST *)_rl_saved_line_for_history->data;\n      _rl_free_history_entry (_rl_saved_line_for_history);\n      _rl_saved_line_for_history = (HIST_ENTRY *)NULL;\n      rl_point = rl_end;\t/* rl_replace_line sets rl_end */\n    }\n  else\n    rl_ding ();\n  return 0;\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "rl_maybe_save_line": {
      "start_point": [
        373,
        0
      ],
      "end_point": [
        385,
        1
      ],
      "content": "int\nrl_maybe_save_line ()\n{\n  if (_rl_saved_line_for_history == 0)\n    {\n      _rl_saved_line_for_history = (HIST_ENTRY *)xmalloc (sizeof (HIST_ENTRY));\n      _rl_saved_line_for_history->line = savestring (rl_line_buffer);\n      _rl_saved_line_for_history->timestamp = (char *)NULL;\n      _rl_saved_line_for_history->data = (char *)rl_undo_list;\n    }\n\n  return 0;\n}",
      "lines": 13,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "_rl_free_saved_history_line": {
      "start_point": [
        387,
        0
      ],
      "end_point": [
        396,
        1
      ],
      "content": "int\n_rl_free_saved_history_line ()\n{\n  if (_rl_saved_line_for_history)\n    {\n      _rl_free_history_entry (_rl_saved_line_for_history);\n      _rl_saved_line_for_history = (HIST_ENTRY *)NULL;\n    }\n  return 0;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "_rl_history_set_point": {
      "start_point": [
        398,
        0
      ],
      "end_point": [
        414,
        1
      ],
      "content": "static void\n_rl_history_set_point ()\n{\n  rl_point = (_rl_history_preserve_point && _rl_history_saved_point != -1)\n\t\t? _rl_history_saved_point\n\t\t: rl_end;\n  if (rl_point > rl_end)\n    rl_point = rl_end;\n\n#if defined (VI_MODE)\n  if (rl_editing_mode == vi_mode && _rl_keymap != vi_insertion_keymap)\n    rl_point = 0;\n#endif /* VI_MODE */\n\n  if (rl_editing_mode == emacs_mode)\n    rl_mark = (rl_point == rl_end ? 0 : rl_end);\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "_rl_revert_all_lines": {
      "start_point": [
        442,
        0
      ],
      "end_point": [
        485,
        1
      ],
      "content": "void\n_rl_revert_all_lines ()\n{\n  int hpos;\n  HIST_ENTRY *entry;\n  UNDO_LIST *ul, *saved_undo_list;\n  char *lbuf;\n\n  lbuf = savestring (rl_line_buffer);\n  saved_undo_list = rl_undo_list;\n  hpos = where_history ();\n\n  entry = (hpos == history_length) ? previous_history () : current_history ();\n  while (entry)\n    {\n      if (ul = (UNDO_LIST *)entry->data)\n\t{\n\t  if (ul == saved_undo_list)\n\t    saved_undo_list = 0;\n\t  /* Set up rl_line_buffer and other variables from history entry */\n\t  rl_replace_from_history (entry, 0);\t/* entry->line is now current */\n\t  entry->data = 0;\t\t\t/* entry->data is now current undo list */\n\t  /* Undo all changes to this history entry */\n\t  while (rl_undo_list)\n\t    rl_do_undo ();\n\t  /* And copy the reverted line back to the history entry, preserving\n\t     the timestamp. */\n\t  FREE (entry->line);\n\t  entry->line = savestring (rl_line_buffer);\n\t}\n      entry = previous_history ();\n    }\n\n  /* Restore history state */\n  rl_undo_list = saved_undo_list;\t/* may have been set to null */\n  history_set_pos (hpos);\n  \n  /* reset the line buffer */\n  rl_replace_line (lbuf, 0);\n  _rl_set_the_line ();\n\n  /* and clean up */\n  xfree (lbuf);\n}",
      "lines": 44,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "rl_clear_history": {
      "start_point": [
        491,
        0
      ],
      "end_point": [
        516,
        1
      ],
      "content": "void\nrl_clear_history ()\n{\n  HIST_ENTRY **hlist, *hent;\n  register int i;\n  UNDO_LIST *ul, *saved_undo_list;\n\n  saved_undo_list = rl_undo_list;\n  hlist = history_list ();\t\t/* direct pointer, not copy */\n\n  for (i = 0; i < history_length; i++)\n    {\n      hent = hlist[i];\n      if (ul = (UNDO_LIST *)hent->data)\n\t{\n\t  if (ul == saved_undo_list)\n\t    saved_undo_list = 0;\n\t  _rl_free_undo_list (ul);\n\t  hent->data = 0;\n\t}\n      _rl_free_history_entry (hent);\n    }\n\n  history_offset = history_length = 0;\n  rl_undo_list = saved_undo_list;\t/* should be NULL */\n}",
      "lines": 26,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "readline/readline-7.0/nls.c": {
    "_rl_init_eightbit": {
      "start_point": [
        123,
        0
      ],
      "end_point": [
        180,
        1
      ],
      "content": "int\n_rl_init_eightbit ()\n{\n/* If we have setlocale(3), just check the current LC_CTYPE category\n   value, and go into eight-bit mode if it's not C or POSIX. */\n#if defined (HAVE_SETLOCALE)\n  char *lspec, *t;\n\n  /* Set the LC_CTYPE locale category from environment variables. */\n  lspec = _rl_get_locale_var (\"LC_CTYPE\");\n  /* Since _rl_get_locale_var queries the right environment variables,\n     we query the current locale settings with setlocale(), and, if\n     that doesn't return anything, we set lspec to the empty string to\n     force the subsequent call to setlocale() to define the `native'\n     environment. */\n  if (lspec == 0 || *lspec == 0)\n    lspec = setlocale (LC_CTYPE, (char *)NULL);\n  if (lspec == 0)\n    lspec = \"\";\n  t = setlocale (LC_CTYPE, lspec);\n\n  if (t && *t)\n    _rl_utf8locale = utf8locale (t);\n\n  if (t && *t && (t[0] != 'C' || t[1]) && (STREQ (t, \"POSIX\") == 0))\n    {\n      _rl_meta_flag = 1;\n      _rl_convert_meta_chars_to_ascii = 0;\n      _rl_output_meta_chars = 1;\n      return (1);\n    }\n  else\n    return (0);\n\n#else /* !HAVE_SETLOCALE */\n  char *lspec, *t;\n  int i;\n\n  /* We don't have setlocale.  Finesse it.  Check the environment for the\n     appropriate variables and set eight-bit mode if they have the right\n     values. */\n  lspec = _rl_get_locale_var (\"LC_CTYPE\");\n\n  if (lspec == 0 || (t = normalize_codeset (lspec)) == 0)\n    return (0);\n  for (i = 0; t && legal_lang_values[i]; i++)\n    if (STREQ (t, legal_lang_values[i]))\n      {\n\t_rl_meta_flag = 1;\n\t_rl_convert_meta_chars_to_ascii = 0;\n\t_rl_output_meta_chars = 1;\n\tbreak;\n      }\n  xfree (t);\n  return (legal_lang_values[i] ? 1 : 0);\n\n#endif /* !HAVE_SETLOCALE */\n}",
      "lines": 58,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "readline/readline-7.0/parens.c": {},
  "readline/readline-7.0/parse-colors.c": {
    "get_funky_string": {
      "start_point": [
        102,
        0
      ],
      "end_point": [
        296,
        1
      ],
      "content": "static bool\nget_funky_string (char **dest, const char **src, bool equals_end, size_t *output_count) {\n  char num;\t\t\t/* For numerical codes */\n  size_t count;\t\t\t/* Something to count with */\n  enum {\n    ST_GND, ST_BACKSLASH, ST_OCTAL, ST_HEX, ST_CARET, ST_END, ST_ERROR\n  } state;\n  const char *p;\n  char *q;\n\n  p = *src;\t\t\t/* We don't want to double-indirect */\n  q = *dest;\t\t\t/* the whole darn time.  */\n\n  count = 0;\t\t\t/* No characters counted in yet.  */\n  num = 0;\n\n  state = ST_GND;\t\t/* Start in ground state.  */\n  while (state < ST_END)\n    {\n      switch (state)\n        {\n        case ST_GND:\t\t/* Ground state (no escapes) */\n          switch (*p)\n            {\n            case ':':\n            case '\\0':\n              state = ST_END;\t/* End of string */\n              break;\n            case '\\\\':\n              state = ST_BACKSLASH; /* Backslash scape sequence */\n              ++p;\n              break;\n            case '^':\n              state = ST_CARET; /* Caret escape */\n              ++p;\n              break;\n            case '=':\n              if (equals_end)\n                {\n                  state = ST_END; /* End */\n                  break;\n                }\n              /* else fall through */\n            default:\n              *(q++) = *(p++);\n              ++count;\n              break;\n            }\n          break;\n\n        case ST_BACKSLASH:\t/* Backslash escaped character */\n          switch (*p)\n            {\n            case '0':\n            case '1':\n            case '2':\n            case '3':\n            case '4':\n            case '5':\n            case '6':\n            case '7':\n              state = ST_OCTAL;\t/* Octal sequence */\n              num = *p - '0';\n              break;\n            case 'x':\n            case 'X':\n              state = ST_HEX;\t/* Hex sequence */\n              num = 0;\n              break;\n            case 'a':\t\t/* Bell */\n              num = '\\a';\n              break;\n            case 'b':\t\t/* Backspace */\n              num = '\\b';\n              break;\n            case 'e':\t\t/* Escape */\n              num = 27;\n              break;\n            case 'f':\t\t/* Form feed */\n              num = '\\f';\n              break;\n            case 'n':\t\t/* Newline */\n              num = '\\n';\n              break;\n            case 'r':\t\t/* Carriage return */\n              num = '\\r';\n              break;\n            case 't':\t\t/* Tab */\n              num = '\\t';\n              break;\n            case 'v':\t\t/* Vtab */\n              num = '\\v';\n              break;\n            case '?':\t\t/* Delete */\n              num = 127;\n              break;\n            case '_':\t\t/* Space */\n              num = ' ';\n              break;\n            case '\\0':\t\t/* End of string */\n              state = ST_ERROR;\t/* Error! */\n              break;\n            default:\t\t/* Escaped character like \\ ^ : = */\n              num = *p;\n              break;\n            }\n          if (state == ST_BACKSLASH)\n            {\n              *(q++) = num;\n              ++count;\n              state = ST_GND;\n            }\n          ++p;\n          break;\n\n        case ST_OCTAL:\t\t/* Octal sequence */\n          if (*p < '0' || *p > '7')\n            {\n              *(q++) = num;\n              ++count;\n              state = ST_GND;\n            }\n          else\n            num = (num << 3) + (*(p++) - '0');\n          break;\n\n        case ST_HEX:\t\t/* Hex sequence */\n          switch (*p)\n            {\n            case '0':\n            case '1':\n            case '2':\n            case '3':\n            case '4':\n            case '5':\n            case '6':\n            case '7':\n            case '8':\n            case '9':\n              num = (num << 4) + (*(p++) - '0');\n              break;\n            case 'a':\n            case 'b':\n            case 'c':\n            case 'd':\n            case 'e':\n            case 'f':\n              num = (num << 4) + (*(p++) - 'a') + 10;\n              break;\n            case 'A':\n            case 'B':\n            case 'C':\n            case 'D':\n            case 'E':\n            case 'F':\n              num = (num << 4) + (*(p++) - 'A') + 10;\n              break;\n            default:\n              *(q++) = num;\n              ++count;\n              state = ST_GND;\n              break;\n            }\n          break;\n\n        case ST_CARET:\t\t/* Caret escape */\n          state = ST_GND;\t/* Should be the next state... */\n          if (*p >= '@' && *p <= '~')\n            {\n              *(q++) = *(p++) & 037;\n              ++count;\n            }\n          else if (*p == '?')\n            {\n              *(q++) = 127;\n              ++count;\n            }\n          else\n            state = ST_ERROR;\n          break;\n\n        default:\n\t  /* should we ? */\n          /* abort ();\tno, we should not */\n          state = ST_ERROR;\n          break;\n        }\n    }\n\n  *dest = q;\n  *src = p;\n  *output_count = count;\n\n  return state != ST_ERROR;\n}",
      "lines": 195,
      "depth": 20,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "_rl_parse_colors": {
      "start_point": [
        299,
        0
      ],
      "end_point": [
        439,
        1
      ],
      "content": "void _rl_parse_colors()\n{\n#if defined (COLOR_SUPPORT)\n  const char *p;\t\t/* Pointer to character being parsed */\n  char *buf;\t\t\t/* color_buf buffer pointer */\n  int state;\t\t\t/* State of parser */\n  int ind_no;\t\t\t/* Indicator number */\n  char label[3];\t\t/* Indicator label */\n  COLOR_EXT_TYPE *ext;\t\t/* Extension we are working on */\n\n  p = sh_get_env_value (\"LS_COLORS\");\n  if (p == 0 || *p == '\\0')\n    {\n      _rl_color_ext_list = NULL;\n      return;\n    }\n\n  ext = NULL;\n  strcpy (label, \"??\");\n\n  /* This is an overly conservative estimate, but any possible\n     LS_COLORS string will *not* generate a color_buf longer than\n     itself, so it is a safe way of allocating a buffer in\n     advance.  */\n  buf = color_buf = savestring (p);\n\n  state = 1;\n  while (state > 0)\n    {\n      switch (state)\n        {\n        case 1:\t\t/* First label character */\n          switch (*p)\n            {\n            case ':':\n              ++p;\n              break;\n\n            case '*':\n              /* Allocate new extension block and add to head of\n                 linked list (this way a later definition will\n                 override an earlier one, which can be useful for\n                 having terminal-specific defs override global).  */\n\n              ext = (COLOR_EXT_TYPE *)xmalloc (sizeof *ext);\n              ext->next = _rl_color_ext_list;\n              _rl_color_ext_list = ext;\n\n              ++p;\n              ext->ext.string = buf;\n\n              state = (get_funky_string (&buf, &p, true, &ext->ext.len)\n                       ? 4 : -1);\n              break;\n\n            case '\\0':\n              state = 0;\t/* Done! */\n              break;\n\n            default:\t/* Assume it is file type label */\n              label[0] = *(p++);\n              state = 2;\n              break;\n            }\n          break;\n\n        case 2:\t\t/* Second label character */\n          if (*p)\n            {\n              label[1] = *(p++);\n              state = 3;\n            }\n          else\n            state = -1;\t/* Error */\n          break;\n\n        case 3:\t\t/* Equal sign after indicator label */\n          state = -1;\t/* Assume failure...  */\n          if (*(p++) == '=')/* It *should* be...  */\n            {\n              for (ind_no = 0; indicator_name[ind_no] != NULL; ++ind_no)\n                {\n                  if (STREQ (label, indicator_name[ind_no]))\n                    {\n                      _rl_color_indicator[ind_no].string = buf;\n                      state = (get_funky_string (&buf, &p, false,\n                                                 &_rl_color_indicator[ind_no].len)\n                               ? 1 : -1);\n                      break;\n                    }\n                }\n              if (state == -1)\n\t\t{\n                  _rl_errmsg (\"LS_COLORS: unrecognized prefix: %s\", label);\n                  /* recover from an unrecognized prefix */\n                  while (p && *p && *p != ':')\n\t\t    p++;\n\t\t  if (p && *p == ':')\n\t\t    state = 1;\n\t\t  else if (p && *p == 0)\n\t\t    state = 0;\n\t\t}\n            }\n          break;\n\n        case 4:\t\t/* Equal sign after *.ext */\n          if (*(p++) == '=')\n            {\n              ext->seq.string = buf;\n              state = (get_funky_string (&buf, &p, false, &ext->seq.len)\n                       ? 1 : -1);\n            }\n          else\n            state = -1;\n          /* XXX - recover here as with an unrecognized prefix? */\n          if (state == -1 && ext->ext.string)\n\t    _rl_errmsg (\"LS_COLORS: syntax error: %s\", ext->ext.string);\n          break;\n        }\n    }\n\n  if (state < 0)\n    {\n      COLOR_EXT_TYPE *e;\n      COLOR_EXT_TYPE *e2;\n\n      _rl_errmsg (\"unparsable value for LS_COLORS environment variable\");\n      free (color_buf);\n      for (e = _rl_color_ext_list; e != NULL; /* empty */)\n        {\n          e2 = e;\n          e = e->next;\n          free (e2);\n        }\n      _rl_color_ext_list = NULL;\n      _rl_colored_stats = 0;\t/* can't have colored stats without colors */\n    }\n#else /* !COLOR_SUPPORT */\n  ;\n#endif /* !COLOR_SUPPORT */\n}",
      "lines": 141,
      "depth": 24,
      "decorators": [
        "void"
      ]
    }
  },
  "readline/readline-7.0/parse-colors.h": {},
  "readline/readline-7.0/posixdir.h": {},
  "readline/readline-7.0/posixjmp.h": {},
  "readline/readline-7.0/posixselect.h": {},
  "readline/readline-7.0/posixstat.h": {},
  "readline/readline-7.0/readline.c": {
    "readline_internal_setup": {
      "start_point": [
        402,
        0
      ],
      "end_point": [
        449,
        1
      ],
      "content": "STATIC_CALLBACK void\nreadline_internal_setup ()\n{\n  char *nprompt;\n\n  _rl_in_stream = rl_instream;\n  _rl_out_stream = rl_outstream;\n\n  /* Enable the meta key only for the duration of readline(), if this\n     terminal has one and the terminal has been initialized */\n  if (_rl_enable_meta & RL_ISSTATE (RL_STATE_TERMPREPPED))\n    _rl_enable_meta_key ();\n\n  if (rl_startup_hook)\n    (*rl_startup_hook) ();\n\n#if defined (VI_MODE)\n  if (rl_editing_mode == vi_mode)\n    rl_vi_insertion_mode (1, 'i');\t/* don't want to reset last */\n#endif /* VI_MODE */\n\n  /* If we're not echoing, we still want to at least print a prompt, because\n     rl_redisplay will not do it for us.  If the calling application has a\n     custom redisplay function, though, let that function handle it. */\n  if (_rl_echoing_p == 0 && rl_redisplay_function == rl_redisplay)\n    {\n      if (rl_prompt && rl_already_prompted == 0)\n\t{\n\t  nprompt = _rl_strip_prompt (rl_prompt);\n\t  fprintf (_rl_out_stream, \"%s\", nprompt);\n\t  fflush (_rl_out_stream);\n\t  xfree (nprompt);\n\t}\n    }\n  else\n    {\n      if (rl_prompt && rl_already_prompted)\n\trl_on_new_line_with_prompt ();\n      else\n\trl_on_new_line ();\n      (*rl_redisplay_function) ();\n    }\n\n  if (rl_pre_input_hook)\n    (*rl_pre_input_hook) ();\n\n  RL_CHECK_SIGNALS ();\n}",
      "lines": 48,
      "depth": 11,
      "decorators": [
        "STATIC_CALLBACK",
        "void",
        "void"
      ]
    },
    "_rl_internal_char_cleanup": {
      "start_point": [
        494,
        0
      ],
      "end_point": [
        522,
        1
      ],
      "content": "void\n_rl_internal_char_cleanup ()\n{\n#if defined (VI_MODE)\n  /* In vi mode, when you exit insert mode, the cursor moves back\n     over the previous character.  We explicitly check for that here. */\n  if (rl_editing_mode == vi_mode && _rl_keymap == vi_movement_keymap)\n    rl_vi_check ();\n#endif /* VI_MODE */\n\n  if (rl_num_chars_to_read && rl_end >= rl_num_chars_to_read)\n    {\n      (*rl_redisplay_function) ();\n      _rl_want_redisplay = 0;\n      rl_newline (1, '\\n');\n    }\n\n  if (rl_done == 0)\n    {\n      (*rl_redisplay_function) ();\n      _rl_want_redisplay = 0;\n    }\n\n  /* If the application writer has told us to erase the entire line if\n     the only character typed was something bound to rl_newline, do so. */\n  if (rl_erase_empty_line && rl_done && rl_last_func == rl_newline &&\n      rl_point == 0 && rl_end == 0)\n    _rl_erase_entire_line ();\n}",
      "lines": 29,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "readline_internal_charloop": {
      "start_point": [
        649,
        0
      ],
      "end_point": [
        657,
        1
      ],
      "content": "static int\nreadline_internal_charloop ()\n{\n  int eof = 1;\n\n  while (rl_done == 0)\n    eof = readline_internal_char ();\n  return (eof);\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "readline_internal": {
      "start_point": [
        663,
        0
      ],
      "end_point": [
        671,
        1
      ],
      "content": "static char *\nreadline_internal ()\n{\n  int eof;\n\n  readline_internal_setup ();\n  eof = readline_internal_charloop ();\n  return (readline_internal_teardown (eof));\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nreadline_internal ()",
        "*"
      ]
    },
    "_rl_init_line_state": {
      "start_point": [
        673,
        0
      ],
      "end_point": [
        679,
        1
      ],
      "content": "void\n_rl_init_line_state ()\n{\n  rl_point = rl_end = rl_mark = 0;\n  the_line = rl_line_buffer;\n  the_line[0] = 0;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "_rl_set_the_line": {
      "start_point": [
        681,
        0
      ],
      "end_point": [
        685,
        1
      ],
      "content": "void\n_rl_set_the_line ()\n{\n  the_line = rl_line_buffer;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "void"
      ]
    },
    "_rl_keyseq_cxt_alloc": {
      "start_point": [
        688,
        0
      ],
      "end_point": [
        702,
        1
      ],
      "content": "_rl_keyseq_cxt *\n_rl_keyseq_cxt_alloc ()\n{\n  _rl_keyseq_cxt *cxt;\n\n  cxt = (_rl_keyseq_cxt *)xmalloc (sizeof (_rl_keyseq_cxt));\n\n  cxt->flags = cxt->subseq_arg = cxt->subseq_retval = 0;\n\n  cxt->okey = 0;\n  cxt->ocxt = _rl_kscxt;\n  cxt->childval = 42;\t\t/* sentinel value */\n\n  return cxt;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "_rl_keyseq_cxt",
        "*\n_rl_keyseq_cxt_alloc ()",
        "*"
      ]
    },
    "_rl_keyseq_chain_dispose": {
      "start_point": [
        711,
        0
      ],
      "end_point": [
        722,
        1
      ],
      "content": "void\n_rl_keyseq_chain_dispose ()\n{\n  _rl_keyseq_cxt *cxt;\n\n  while (_rl_kscxt)\n    {\n      cxt = _rl_kscxt;\n      _rl_kscxt = _rl_kscxt->ocxt;\n      _rl_keyseq_cxt_dispose (cxt);\n    }\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "rl_initialize": {
      "start_point": [
        1092,
        0
      ],
      "end_point": [
        1134,
        1
      ],
      "content": "int\nrl_initialize ()\n{\n  /* If we have never been called before, initialize the\n     terminal and data structures. */\n  if (!rl_initialized)\n    {\n      RL_SETSTATE(RL_STATE_INITIALIZING);\n      readline_initialize_everything ();\n      RL_UNSETSTATE(RL_STATE_INITIALIZING);\n      rl_initialized++;\n      RL_SETSTATE(RL_STATE_INITIALIZED);\n    }\n\n  /* Initialize the current line information. */\n  _rl_init_line_state ();\n\n  /* We aren't done yet.  We haven't even gotten started yet! */\n  rl_done = 0;\n  RL_UNSETSTATE(RL_STATE_DONE);\n\n  /* Tell the history routines what is going on. */\n  _rl_start_using_history ();\n\n  /* Make the display buffer match the state of the line. */\n  rl_reset_line_state ();\n\n  /* No such function typed yet. */\n  rl_last_func = (rl_command_func_t *)NULL;\n\n  /* Parsing of key-bindings begins in an enabled state. */\n  _rl_parsing_conditionalized_out = 0;\n\n#if defined (VI_MODE)\n  if (rl_editing_mode == vi_mode)\n    _rl_vi_initialize_line ();\n#endif\n\n  /* Each line starts in insert mode (the default). */\n  _rl_set_insert_mode (RL_IM_DEFAULT, 1);\n\n  return 0;\n}",
      "lines": 43,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "_emx_build_environ": {
      "start_point": [
        1138,
        0
      ],
      "end_point": [
        1158,
        1
      ],
      "content": "static void\n_emx_build_environ ()\n{\n  TIB *tibp;\n  PIB *pibp;\n  char *t, **tp;\n  int c;\n\n  DosGetInfoBlocks (&tibp, &pibp);\n  t = pibp->pib_pchenv;\n  for (c = 1; *t; c++)\n    t += strlen (t) + 1;\n  tp = environ = (char **)xmalloc ((c + 1) * sizeof (char *));\n  t = pibp->pib_pchenv;\n  while (*t)\n    {\n      *tp++ = t;\n      t += strlen (t) + 1;\n    }\n  *tp = 0;\n}",
      "lines": 21,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "readline_initialize_everything": {
      "start_point": [
        1163,
        0
      ],
      "end_point": [
        1243,
        1
      ],
      "content": "static void\nreadline_initialize_everything ()\n{\n#if 0\n#if defined (__EMX__)\n  if (environ == 0)\n    _emx_build_environ ();\n#endif\n#endif\n\n#if 0\n  /* Find out if we are running in Emacs -- UNUSED. */\n  running_in_emacs = sh_get_env_value (\"EMACS\") != (char *)0;\n#endif\n\n  /* Set up input and output if they are not already set up. */\n  if (!rl_instream)\n    rl_instream = stdin;\n\n  if (!rl_outstream)\n    rl_outstream = stdout;\n\n  /* Bind _rl_in_stream and _rl_out_stream immediately.  These values\n     may change, but they may also be used before readline_internal ()\n     is called. */\n  _rl_in_stream = rl_instream;\n  _rl_out_stream = rl_outstream;\n\n  /* Allocate data structures. */\n  if (rl_line_buffer == 0)\n    rl_line_buffer = (char *)xmalloc (rl_line_buffer_len = DEFAULT_BUFFER_SIZE);\n\n  /* Initialize the terminal interface. */\n  if (rl_terminal_name == 0)\n    rl_terminal_name = sh_get_env_value (\"TERM\");\n  _rl_init_terminal_io (rl_terminal_name);\n\n  /* Bind tty characters to readline functions. */\n  readline_default_bindings ();\n\n  /* Initialize the function names. */\n  rl_initialize_funmap ();\n\n  /* Decide whether we should automatically go into eight-bit mode. */\n  _rl_init_eightbit ();\n      \n  /* Read in the init file. */\n  rl_read_init_file ((char *)NULL);\n\n  /* XXX */\n  if (_rl_horizontal_scroll_mode && _rl_term_autowrap)\n    {\n      _rl_screenwidth--;\n      _rl_screenchars -= _rl_screenheight;\n    }\n\n  /* Override the effect of any `set keymap' assignments in the\n     inputrc file. */\n  rl_set_keymap_from_edit_mode ();\n\n  /* Try to bind a common arrow key prefix, if not already bound. */\n  bind_arrow_keys ();\n\n  /* Bind the bracketed paste prefix assuming that the user will enable\n     it on terminals that support it. */\n  bind_bracketed_paste_prefix ();\n\n  /* If the completion parser's default word break characters haven't\n     been set yet, then do so now. */\n  if (rl_completer_word_break_characters == (char *)NULL)\n    rl_completer_word_break_characters = (char *)rl_basic_word_break_characters;\n\n#if defined (COLOR_SUPPORT)\n  if (_rl_colored_stats || _rl_colored_completion_prefix)\n    _rl_parse_colors ();\n#endif\n\n  rl_executing_keyseq = malloc (_rl_executing_keyseq_size = 16);\n  if (rl_executing_keyseq)\n    rl_executing_keyseq[0] = '\\0';\n}",
      "lines": 81,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "readline_default_bindings": {
      "start_point": [
        1248,
        0
      ],
      "end_point": [
        1253,
        1
      ],
      "content": "static void\nreadline_default_bindings ()\n{\n  if (_rl_bind_stty_chars)\n    rl_tty_set_default_bindings (_rl_keymap);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "reset_default_bindings": {
      "start_point": [
        1257,
        0
      ],
      "end_point": [
        1265,
        1
      ],
      "content": "static void\nreset_default_bindings ()\n{\n  if (_rl_bind_stty_chars)\n    {\n      rl_tty_unset_default_bindings (_rl_keymap);\n      rl_tty_set_default_bindings (_rl_keymap);\n    }\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bind_arrow_keys": {
      "start_point": [
        1325,
        0
      ],
      "end_point": [
        1338,
        1
      ],
      "content": "static void\nbind_arrow_keys ()\n{\n  bind_arrow_keys_internal (emacs_standard_keymap);\n\n#if defined (VI_MODE)\n  bind_arrow_keys_internal (vi_movement_keymap);\n  /* Unbind vi_movement_keymap[ESC] to allow users to repeatedly hit ESC\n     in vi command mode while still allowing the arrow keys to work. */\n  if (vi_movement_keymap[ESC].type == ISKMAP)\n    rl_bind_keyseq_in_map (\"\\033\", (rl_command_func_t *)NULL, vi_movement_keymap);\n  bind_arrow_keys_internal (vi_insertion_keymap);\n#endif\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bind_bracketed_paste_prefix": {
      "start_point": [
        1340,
        0
      ],
      "end_point": [
        1354,
        1
      ],
      "content": "static void\nbind_bracketed_paste_prefix ()\n{\n  Keymap xkeymap;\n\n  xkeymap = _rl_keymap;\n\n  _rl_keymap = emacs_standard_keymap;\n  rl_bind_keyseq_if_unbound (BRACK_PASTE_PREF, rl_bracketed_paste_begin);\n  \n  _rl_keymap = vi_insertion_keymap;\n  rl_bind_keyseq_if_unbound (BRACK_PASTE_PREF, rl_bracketed_paste_begin);\n\n  _rl_keymap = xkeymap;\n}",
      "lines": 15,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "readline/readline-7.0/readline.h": {},
  "readline/readline-7.0/rlconf.h": {},
  "readline/readline-7.0/rldefs.h": {},
  "readline/readline-7.0/rlmbutil.h": {},
  "readline/readline-7.0/rlprivate.h": {},
  "readline/readline-7.0/rlshell.h": {},
  "readline/readline-7.0/rlstdc.h": {},
  "readline/readline-7.0/rltty.c": {
    "rl_deprep_terminal": [
      {
        "start_point": [
          593,
          0
        ],
        "end_point": [
          596,
          1
        ],
        "content": "void\nrl_deprep_terminal ()\n{\n}",
        "lines": 4,
        "depth": 4,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          683,
          0
        ],
        "end_point": [
          714,
          1
        ],
        "content": "void\nrl_deprep_terminal ()\n{\n  int tty;\n\n  if (terminal_prepped == 0)\n    return;\n\n  /* Try to keep this function from being interrupted. */\n  _rl_block_sigint ();\n\n  tty = rl_instream ? fileno (rl_instream) : fileno (stdin);\n\n  if (terminal_prepped & TPX_BRACKPASTE)\n    fprintf (rl_outstream, BRACK_PASTE_FINI);\n\n  if (_rl_enable_keypad)\n    _rl_control_keypad (0);\n\n  fflush (rl_outstream);\n\n  if (set_tty_settings (tty, &otio) < 0)\n    {\n      _rl_release_sigint ();\n      return;\n    }\n\n  terminal_prepped = 0;\n  RL_UNSETSTATE(RL_STATE_TERMPREPPED);\n\n  _rl_release_sigint ();\n}",
        "lines": 32,
        "depth": 9,
        "decorators": [
          "void"
        ]
      }
    ],
    "_rl_disable_tty_signals": [
      {
        "start_point": [
          955,
          0
        ],
        "end_point": [
          959,
          1
        ],
        "content": "int\n_rl_disable_tty_signals ()\n{\n  return 0;\n}",
        "lines": 5,
        "depth": 4,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          971,
          0
        ],
        "end_point": [
          990,
          1
        ],
        "content": "int\n_rl_disable_tty_signals ()\n{\n  if (tty_sigs_disabled)\n    return 0;\n\n  if (_get_tty_settings (fileno (rl_instream), &sigstty) < 0)\n    return -1;\n\n  nosigstty = sigstty;\n\n  nosigstty.c_lflag &= ~ISIG;\n  nosigstty.c_iflag &= ~IXON;\n\n  if (_set_tty_settings (fileno (rl_instream), &nosigstty) < 0)\n    return (_set_tty_settings (fileno (rl_instream), &sigstty));\n\n  tty_sigs_disabled = 1;\n  return 0;\n}",
        "lines": 20,
        "depth": 10,
        "decorators": [
          "int"
        ]
      }
    ],
    "_rl_restore_tty_signals": [
      {
        "start_point": [
          961,
          0
        ],
        "end_point": [
          965,
          1
        ],
        "content": "int\n_rl_restore_tty_signals ()\n{\n  return 0;\n}",
        "lines": 5,
        "depth": 4,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          992,
          0
        ],
        "end_point": [
          1006,
          1
        ],
        "content": "int\n_rl_restore_tty_signals ()\n{\n  int r;\n\n  if (tty_sigs_disabled == 0)\n    return 0;\n\n  r = _set_tty_settings (fileno (rl_instream), &sigstty);\n\n  if (r == 0)\n    tty_sigs_disabled = 0;\n\n  return r;\n}",
        "lines": 15,
        "depth": 9,
        "decorators": [
          "int"
        ]
      }
    ]
  },
  "readline/readline-7.0/rltty.h": {},
  "readline/readline-7.0/rltypedefs.h": {},
  "readline/readline-7.0/rlwinsize.h": {},
  "readline/readline-7.0/savestring.c": {},
  "readline/readline-7.0/search.c": {},
  "readline/readline-7.0/shell.c": {
    "sh_get_home_dir": {
      "start_point": [
        156,
        0
      ],
      "end_point": [
        181,
        1
      ],
      "content": "char *\nsh_get_home_dir ()\n{\n  static char *home_dir = (char *)NULL;\n  struct passwd *entry;\n\n  if (home_dir)\n    return (home_dir);\n\n  home_dir = (char *)NULL;\n#if defined (HAVE_GETPWUID)\n#  if defined (__TANDEM)\n  entry = getpwnam (getlogin ());\n#  else\n  entry = getpwuid (getuid ());\n#  endif\n  if (entry)\n    home_dir = savestring (entry->pw_dir);\n#endif\n\n#if defined (HAVE_GETPWENT)\n  endpwent ();\t\t/* some systems need this */\n#endif\n\n  return (home_dir);\n}",
      "lines": 26,
      "depth": 12,
      "decorators": [
        "char",
        "*\nsh_get_home_dir ()",
        "*"
      ]
    }
  },
  "readline/readline-7.0/signals.c": {
    "rl_set_signals": {
      "start_point": [
        402,
        0
      ],
      "end_point": [
        499,
        1
      ],
      "content": "int\nrl_set_signals ()\n{\n  sighandler_cxt dummy;\n  SigHandler *oh;\n#if defined (HAVE_POSIX_SIGNALS)\n  static int sigmask_set = 0;\n  static sigset_t bset, oset;\n#endif\n\n#if defined (HAVE_POSIX_SIGNALS)\n  if (rl_catch_signals && sigmask_set == 0)\n    {\n      sigemptyset (&bset);\n\n      sigaddset (&bset, SIGINT);\n      sigaddset (&bset, SIGTERM);\n#if defined (SIGHUP)\n      sigaddset (&bset, SIGHUP);\n#endif\n#if defined (SIGQUIT)\n      sigaddset (&bset, SIGQUIT);\n#endif\n#if defined (SIGALRM)\n      sigaddset (&bset, SIGALRM);\n#endif\n#if defined (SIGTSTP)\n      sigaddset (&bset, SIGTSTP);\n#endif\n#if defined (SIGTTIN)\n      sigaddset (&bset, SIGTTIN);\n#endif\n#if defined (SIGTTOU)\n      sigaddset (&bset, SIGTTOU);\n#endif\n      sigmask_set = 1;\n    }      \n#endif /* HAVE_POSIX_SIGNALS */\n\n  if (rl_catch_signals && signals_set_flag == 0)\n    {\n#if defined (HAVE_POSIX_SIGNALS)\n      sigemptyset (&oset);\n      sigprocmask (SIG_BLOCK, &bset, &oset);\n#endif\n\n      rl_maybe_set_sighandler (SIGINT, rl_signal_handler, &old_int);\n      rl_maybe_set_sighandler (SIGTERM, rl_signal_handler, &old_term);\n#if defined (SIGHUP)\n      rl_maybe_set_sighandler (SIGHUP, rl_signal_handler, &old_hup);\n#endif\n#if defined (SIGQUIT)\n      rl_maybe_set_sighandler (SIGQUIT, rl_signal_handler, &old_quit);\n#endif\n\n#if defined (SIGALRM)\n      oh = rl_set_sighandler (SIGALRM, rl_signal_handler, &old_alrm);\n      if (oh == (SigHandler *)SIG_IGN)\n\trl_sigaction (SIGALRM, &old_alrm, &dummy);\n#if defined (HAVE_POSIX_SIGNALS) && defined (SA_RESTART)\n      /* If the application using readline has already installed a signal\n\t handler with SA_RESTART, SIGALRM will cause reads to be restarted\n\t automatically, so readline should just get out of the way.  Since\n\t we tested for SIG_IGN above, we can just test for SIG_DFL here. */\n      if (oh != (SigHandler *)SIG_DFL && (old_alrm.sa_flags & SA_RESTART))\n\trl_sigaction (SIGALRM, &old_alrm, &dummy);\n#endif /* HAVE_POSIX_SIGNALS */\n#endif /* SIGALRM */\n\n#if defined (SIGTSTP)\n      rl_maybe_set_sighandler (SIGTSTP, rl_signal_handler, &old_tstp);\n#endif /* SIGTSTP */\n\n#if defined (SIGTTOU)\n      rl_maybe_set_sighandler (SIGTTOU, rl_signal_handler, &old_ttou);\n#endif /* SIGTTOU */\n\n#if defined (SIGTTIN)\n      rl_maybe_set_sighandler (SIGTTIN, rl_signal_handler, &old_ttin);\n#endif /* SIGTTIN */\n\n      signals_set_flag = 1;\n\n#if defined (HAVE_POSIX_SIGNALS)\n      sigprocmask (SIG_SETMASK, &oset, (sigset_t *)NULL);\n#endif\n    }\n\n#if defined (SIGWINCH)\n  if (rl_catch_sigwinch && sigwinch_set_flag == 0)\n    {\n      rl_maybe_set_sighandler (SIGWINCH, rl_sigwinch_handler, &old_winch);\n      sigwinch_set_flag = 1;\n    }\n#endif /* SIGWINCH */\n\n  return 0;\n}",
      "lines": 98,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "rl_clear_signals": {
      "start_point": [
        501,
        0
      ],
      "end_point": [
        552,
        1
      ],
      "content": "int\nrl_clear_signals ()\n{\n  sighandler_cxt dummy;\n\n  if (rl_catch_signals && signals_set_flag == 1)\n    {\n      sigemptyset (&dummy.sa_mask);\n\n      /* Since rl_maybe_set_sighandler doesn't override a SIG_IGN handler,\n\t we should in theory not have to restore a handler where\n\t old_xxx.sa_handler == SIG_IGN.  That's what rl_maybe_restore_sighandler\n\t does.  Fewer system calls should reduce readline's per-line\n\t overhead */\n      rl_maybe_restore_sighandler (SIGINT, &old_int);\n      rl_maybe_restore_sighandler (SIGTERM, &old_term);\n#if defined (SIGHUP)\n      rl_maybe_restore_sighandler (SIGHUP, &old_hup);\n#endif\n#if defined (SIGQUIT)\n      rl_maybe_restore_sighandler (SIGQUIT, &old_quit);\n#endif\n#if defined (SIGALRM)\n      rl_maybe_restore_sighandler (SIGALRM, &old_alrm);\n#endif\n\n#if defined (SIGTSTP)\n      rl_maybe_restore_sighandler (SIGTSTP, &old_tstp);\n#endif /* SIGTSTP */\n\n#if defined (SIGTTOU)\n      rl_maybe_restore_sighandler (SIGTTOU, &old_ttou);\n#endif /* SIGTTOU */\n\n#if defined (SIGTTIN)\n      rl_maybe_restore_sighandler (SIGTTIN, &old_ttin);\n#endif /* SIGTTIN */\n\n      signals_set_flag = 0;\n    }\n\n#if defined (SIGWINCH)\n  if (rl_catch_sigwinch && sigwinch_set_flag == 1)\n    {\n      sigemptyset (&dummy.sa_mask);\n      rl_sigaction (SIGWINCH, &old_winch, &dummy);\n      sigwinch_set_flag = 0;\n    }\n#endif\n\n  return 0;\n}",
      "lines": 52,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "rl_cleanup_after_signal": {
      "start_point": [
        556,
        0
      ],
      "end_point": [
        564,
        1
      ],
      "content": "void\nrl_cleanup_after_signal ()\n{\n  _rl_clean_up_for_exit ();\n  if (rl_deprep_term_function)\n    (*rl_deprep_term_function) ();\n  rl_clear_pending_input ();\n  rl_clear_signals ();\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "rl_reset_after_signal": {
      "start_point": [
        567,
        0
      ],
      "end_point": [
        573,
        1
      ],
      "content": "void\nrl_reset_after_signal ()\n{\n  if (rl_prep_term_function)\n    (*rl_prep_term_function) (_rl_meta_flag);\n  rl_set_signals ();\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "rl_free_line_state": {
      "start_point": [
        579,
        0
      ],
      "end_point": [
        593,
        1
      ],
      "content": "void\nrl_free_line_state ()\n{\n  register HIST_ENTRY *entry;\n\n  rl_free_undo_list ();\n\n  entry = current_history ();\n  if (entry)\n    entry->data = (char *)NULL;\n\n  _rl_kill_kbd_macro ();\n  rl_clear_message ();\n  _rl_reset_argument ();\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "rl_pending_signal": {
      "start_point": [
        595,
        0
      ],
      "end_point": [
        599,
        1
      ],
      "content": "int\nrl_pending_signal ()\n{\n  return (_rl_caught_signal);\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    },
    "_rl_block_sigint": {
      "start_point": [
        623,
        0
      ],
      "end_point": [
        630,
        1
      ],
      "content": "void\n_rl_block_sigint ()\n{\n  if (sigint_blocked)\n    return;\n\n  sigint_blocked = 1;\n}",
      "lines": 8,
      "depth": 5,
      "decorators": [
        "void"
      ]
    },
    "_rl_release_sigint": {
      "start_point": [
        633,
        0
      ],
      "end_point": [
        641,
        1
      ],
      "content": "void\n_rl_release_sigint ()\n{\n  if (sigint_blocked == 0)\n    return;\n\n  sigint_blocked = 0;\n  RL_CHECK_SIGNALS ();\n}",
      "lines": 9,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "_rl_block_sigwinch": {
      "start_point": [
        645,
        0
      ],
      "end_point": [
        671,
        1
      ],
      "content": "void\n_rl_block_sigwinch ()\n{\n  if (sigwinch_blocked)\n    return;\n\n#if defined (SIGWINCH)\n\n#if defined (HAVE_POSIX_SIGNALS)\n  sigemptyset (&sigwinch_set);\n  sigemptyset (&sigwinch_oset);\n  sigaddset (&sigwinch_set, SIGWINCH);\n  sigprocmask (SIG_BLOCK, &sigwinch_set, &sigwinch_oset);\n#else /* !HAVE_POSIX_SIGNALS */\n#  if defined (HAVE_BSD_SIGNALS)\n  sigwinch_oldmask = sigblock (sigmask (SIGWINCH));\n#  else /* !HAVE_BSD_SIGNALS */\n#    if defined (HAVE_USG_SIGHOLD)\n  sighold (SIGWINCH);\n#    endif /* HAVE_USG_SIGHOLD */\n#  endif /* !HAVE_BSD_SIGNALS */\n#endif /* !HAVE_POSIX_SIGNALS */\n\n#endif /* SIGWINCH */\n\n  sigwinch_blocked = 1;\n}",
      "lines": 27,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "_rl_release_sigwinch": {
      "start_point": [
        674,
        0
      ],
      "end_point": [
        697,
        1
      ],
      "content": "void\n_rl_release_sigwinch ()\n{\n  if (sigwinch_blocked == 0)\n    return;\n\n#if defined (SIGWINCH)\n\n#if defined (HAVE_POSIX_SIGNALS)\n  sigprocmask (SIG_SETMASK, &sigwinch_oset, (sigset_t *)NULL);\n#else\n#  if defined (HAVE_BSD_SIGNALS)\n  sigsetmask (sigwinch_oldmask);\n#  else /* !HAVE_BSD_SIGNALS */\n#    if defined (HAVE_USG_SIGHOLD)\n  sigrelse (SIGWINCH);\n#    endif /* HAVE_USG_SIGHOLD */\n#  endif /* !HAVE_BSD_SIGNALS */\n#endif /* !HAVE_POSIX_SIGNALS */\n\n#endif /* SIGWINCH */\n\n  sigwinch_blocked = 0;\n}",
      "lines": 24,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "readline/readline-7.0/tcap.h": {},
  "readline/readline-7.0/terminal.c": {
    "rl_reset_screen_size": {
      "start_point": [
        356,
        0
      ],
      "end_point": [
        360,
        1
      ],
      "content": "void\nrl_reset_screen_size ()\n{\n  _rl_get_screen_size (fileno (rl_instream), 0);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "_rl_sigwinch_resize_terminal": {
      "start_point": [
        362,
        0
      ],
      "end_point": [
        366,
        1
      ],
      "content": "void\n_rl_sigwinch_resize_terminal ()\n{\n  _rl_get_screen_size (fileno (rl_instream), 1);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "rl_resize_terminal": {
      "start_point": [
        368,
        0
      ],
      "end_point": [
        379,
        1
      ],
      "content": "void\nrl_resize_terminal ()\n{\n  _rl_get_screen_size (fileno (rl_instream), 1);\n  if (_rl_echoing_p)\n    {\n      if (CUSTOM_REDISPLAY_FUNC ())\n\trl_forced_update_display ();\n      else if (RL_ISSTATE(RL_STATE_REDISPLAYING) == 0)\n\t_rl_redisplay_after_sigwinch ();\n    }\n}",
      "lines": 12,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "rl_crlf": {
      "start_point": [
        679,
        0
      ],
      "end_point": [
        688,
        1
      ],
      "content": "int\nrl_crlf ()\n{\n#if defined (NEW_TTY_DRIVER) || defined (__MINT__)\n  if (_rl_term_cr)\n    tputs (_rl_term_cr, 1, _rl_output_character_function);\n#endif /* NEW_TTY_DRIVER || __MINT__ */\n  putc ('\\n', _rl_out_stream);\n  return 0;\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "rl_ding": {
      "start_point": [
        691,
        0
      ],
      "end_point": [
        720,
        1
      ],
      "content": "int\nrl_ding ()\n{\n  if (_rl_echoing_p)\n    {\n      switch (_rl_bell_preference)\n        {\n\tcase NO_BELL:\n\tdefault:\n\t  break;\n\tcase VISIBLE_BELL:\n\t  if (_rl_visible_bell)\n\t    {\n#ifdef __DJGPP__\n\t      ScreenVisualBell ();\n#else\n\t      tputs (_rl_visible_bell, 1, _rl_output_character_function);\n#endif\n\t      break;\n\t    }\n\t  /* FALLTHROUGH */\n\tcase AUDIBLE_BELL:\n\t  fprintf (stderr, \"\\007\");\n\t  fflush (stderr);\n\t  break;\n        }\n      return (0);\n    }\n  return (-1);\n}",
      "lines": 30,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "_rl_enable_meta_key": {
      "start_point": [
        730,
        0
      ],
      "end_point": [
        740,
        1
      ],
      "content": "void\n_rl_enable_meta_key ()\n{\n#if !defined (__DJGPP__)\n  if (term_has_meta && _rl_term_mm)\n    {\n      tputs (_rl_term_mm, 1, _rl_output_character_function);\n      enabled_meta = 1;\n    }\n#endif\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "_rl_disable_meta_key": {
      "start_point": [
        742,
        0
      ],
      "end_point": [
        752,
        1
      ],
      "content": "void\n_rl_disable_meta_key ()\n{\n#if !defined (__DJGPP__)\n  if (term_has_meta && _rl_term_mo && enabled_meta)\n    {\n      tputs (_rl_term_mo, 1, _rl_output_character_function);\n      enabled_meta = 0;\n    }\n#endif\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "readline/readline-7.0/text.c": {},
  "readline/readline-7.0/tilde.c": {
    "memory_error_and_abort": {
      "start_point": [
        497,
        0
      ],
      "end_point": [
        502,
        1
      ],
      "content": "static void\nmemory_error_and_abort ()\n{\n  fprintf (stderr, \"readline: out of virtual memory\\n\");\n  abort ();\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "readline/readline-7.0/tilde.h": {},
  "readline/readline-7.0/undo.c": {
    "rl_free_undo_list": {
      "start_point": [
        122,
        0
      ],
      "end_point": [
        131,
        1
      ],
      "content": "void\nrl_free_undo_list ()\n{\n  UNDO_LIST *release, *orig_list;\n\n  orig_list = rl_undo_list;\n  _rl_free_undo_list (rl_undo_list);\n  rl_undo_list = (UNDO_LIST *)NULL;\n  _hs_replace_history_data (-1, (histdata_t *)orig_list, (histdata_t *)NULL);\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "rl_do_undo": {
      "start_point": [
        174,
        0
      ],
      "end_point": [
        253,
        1
      ],
      "content": "int\nrl_do_undo ()\n{\n  UNDO_LIST *release;\n  int waiting_for_begin, start, end;\n  HIST_ENTRY *cur, *temp;\n\n#define TRANS(i) ((i) == -1 ? rl_point : ((i) == -2 ? rl_end : (i)))\n\n  start = end = waiting_for_begin = 0;\n  do\n    {\n      if (rl_undo_list == 0)\n\treturn (0);\n\n      _rl_doing_an_undo = 1;\n      RL_SETSTATE(RL_STATE_UNDOING);\n\n      /* To better support vi-mode, a start or end value of -1 means\n\t rl_point, and a value of -2 means rl_end. */\n      if (rl_undo_list->what == UNDO_DELETE || rl_undo_list->what == UNDO_INSERT)\n\t{\n\t  start = TRANS (rl_undo_list->start);\n\t  end = TRANS (rl_undo_list->end);\n\t}\n\n      switch (rl_undo_list->what)\n\t{\n\t/* Undoing deletes means inserting some text. */\n\tcase UNDO_DELETE:\n\t  rl_point = start;\n\t  rl_insert_text (rl_undo_list->text);\n\t  xfree (rl_undo_list->text);\n\t  break;\n\n\t/* Undoing inserts means deleting some text. */\n\tcase UNDO_INSERT:\n\t  rl_delete_text (start, end);\n\t  rl_point = start;\n\t  break;\n\n\t/* Undoing an END means undoing everything 'til we get to a BEGIN. */\n\tcase UNDO_END:\n\t  waiting_for_begin++;\n\t  break;\n\n\t/* Undoing a BEGIN means that we are done with this group. */\n\tcase UNDO_BEGIN:\n\t  if (waiting_for_begin)\n\t    waiting_for_begin--;\n\t  else\n\t    rl_ding ();\n\t  break;\n\t}\n\n      _rl_doing_an_undo = 0;\n      RL_UNSETSTATE(RL_STATE_UNDOING);\n\n      release = rl_undo_list;\n      rl_undo_list = rl_undo_list->next;\n\n      /* If we are editing a history entry, make sure the change is replicated\n\t in the history entry's line */\n      cur = current_history ();\n      if (cur && cur->data && (UNDO_LIST *)cur->data == release)\n\t{\n\t  temp = replace_history_entry (where_history (), rl_line_buffer, (histdata_t)rl_undo_list);\n\t  xfree (temp->line);\n\t  FREE (temp->timestamp);\n\t  xfree (temp);\n\t}\n\n      _hs_replace_history_data (-1, (histdata_t *)release, (histdata_t *)rl_undo_list);\n\n      xfree (release);\n    }\n  while (waiting_for_begin);\n\n  return (1);\n}",
      "lines": 80,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "rl_begin_undo_group": {
      "start_point": [
        275,
        0
      ],
      "end_point": [
        281,
        1
      ],
      "content": "int\nrl_begin_undo_group ()\n{\n  rl_add_undo (UNDO_BEGIN, 0, 0, 0);\n  _rl_undo_group_level++;\n  return 0;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "rl_end_undo_group": {
      "start_point": [
        284,
        0
      ],
      "end_point": [
        290,
        1
      ],
      "content": "int\nrl_end_undo_group ()\n{\n  rl_add_undo (UNDO_END, 0, 0, 0);\n  _rl_undo_group_level--;\n  return 0;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "readline/readline-7.0/util.c": {
    "_rl_walphabetic": {
      "start_point": [
        83,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "int\n_rl_walphabetic (wchar_t wc)\n{\n  int c;\n\n  if (iswalnum (wc))\n    return (1);     \n\n  c = wc & 0177;\n  return (_rl_allow_pathname_alphabetic_chars &&\n\t    strchr (pathname_alphabetic_chars, c) != NULL);\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "_rl_abort_internal": {
      "start_point": [
        98,
        0
      ],
      "end_point": [
        116,
        1
      ],
      "content": "int\n_rl_abort_internal ()\n{\n  rl_ding ();\n  rl_clear_message ();\n  _rl_reset_argument ();\n  rl_clear_pending_input ();\n\n  RL_UNSETSTATE (RL_STATE_MACRODEF);\n  while (rl_executing_macro)\n    _rl_pop_executing_macro ();\n\n  RL_UNSETSTATE (RL_STATE_MULTIKEY);\t/* XXX */\n\n  rl_last_func = (rl_command_func_t *)NULL;\n\n  _rl_longjmp (_rl_top_level, 1);\n  return (0);\n}",
      "lines": 19,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "_rl_tropen": {
      "start_point": [
        513,
        0
      ],
      "end_point": [
        531,
        1
      ],
      "content": "int\n_rl_tropen ()\n{\n  char fnbuf[128], *x;\n\n  if (_rl_tracefp)\n    fclose (_rl_tracefp);\n#if defined (_WIN32) && !defined (__CYGWIN__)\n  x = sh_get_env_value (\"TEMP\");\n  if (x == 0)\n    x = \".\";\n#else\n  x = \"/var/tmp\";\n#endif\n  sprintf (fnbuf, \"%s/rltrace.%ld\", x, (long)getpid());\n  unlink(fnbuf);\n  _rl_tracefp = fopen (fnbuf, \"w+\");\n  return _rl_tracefp != 0;\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "_rl_trclose": {
      "start_point": [
        533,
        0
      ],
      "end_point": [
        541,
        1
      ],
      "content": "int\n_rl_trclose ()\n{\n  int r;\n\n  r = fclose (_rl_tracefp);\n  _rl_tracefp = 0;\n  return r;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "readline/readline-7.0/vi_keymap.c": {},
  "readline/readline-7.0/vi_mode.c": {
    "_rl_vi_initialize_line": {
      "start_point": [
        147,
        0
      ],
      "end_point": [
        157,
        1
      ],
      "content": "void\n_rl_vi_initialize_line ()\n{\n  register int i, n;\n\n  n = sizeof (vi_mark_chars) / sizeof (vi_mark_chars[0]);\n  for (i = 0; i < n; i++)\n    vi_mark_chars[i] = -1;\n\n  RL_UNSETSTATE(RL_STATE_VICMDONCE);\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "_rl_vi_reset_last": {
      "start_point": [
        159,
        0
      ],
      "end_point": [
        166,
        1
      ],
      "content": "void\n_rl_vi_reset_last ()\n{\n  _rl_vi_last_command = 'i';\n  _rl_vi_last_repeat = 1;\n  _rl_vi_last_arg_sign = 1;\n  _rl_vi_last_motion = 0;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "_rl_vi_save_replace": {
      "start_point": [
        744,
        0
      ],
      "end_point": [
        765,
        1
      ],
      "content": "static void\n_rl_vi_save_replace ()\n{\n  int len, start, end;\n  UNDO_LIST *up;\n\n  up = rl_undo_list;\n  if (up == 0 || up->what != UNDO_END || vi_replace_count <= 0)\n    {\n      if (vi_insert_buffer_size >= 1)\n\tvi_insert_buffer[0] = '\\0';\n      return;\n    }\n  /* Let's try it the quick and easy way for now.  This should essentially\n     accommodate every UNDO_INSERT and save the inserted text to\n     vi_insert_buffer */\n  end = rl_point;\n  start = end - vi_replace_count + 1;\n  len = vi_replace_count + 1;\n\n  vi_save_insert_buffer (start, len);  \n}",
      "lines": 22,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "_rl_vi_done_inserting": {
      "start_point": [
        787,
        0
      ],
      "end_point": [
        820,
        1
      ],
      "content": "void\n_rl_vi_done_inserting ()\n{\n  if (_rl_vi_doing_insert)\n    {\n      /* The `C', `s', and `S' commands set this. */\n      rl_end_undo_group ();\n      /* Now, the text between rl_undo_list->next->start and\n\t rl_undo_list->next->end is what was inserted while in insert\n\t mode.  It gets copied to VI_INSERT_BUFFER because it depends\n\t on absolute indices into the line which may change (though they\n\t probably will not). */\n      _rl_vi_doing_insert = 0;\n      if (_rl_vi_last_key_before_insert == 'R')\n\t_rl_vi_save_replace ();\t\t/* Half the battle */\n      else\n\t_rl_vi_save_insert (rl_undo_list->next);\n      vi_continued_command = 1;\n    }\n  else\n    {\n      if (rl_undo_list && (_rl_vi_last_key_before_insert == 'i' ||\n\t\t\t   _rl_vi_last_key_before_insert == 'a' ||\n\t\t\t   _rl_vi_last_key_before_insert == 'I' ||\n\t\t\t   _rl_vi_last_key_before_insert == 'A'))\n\t_rl_vi_save_insert (rl_undo_list);\n      /* XXX - Other keys probably need to be checked. */\n      else if (_rl_vi_last_key_before_insert == 'C')\n\trl_end_undo_group ();\n      while (_rl_undo_group_level > 0)\n\trl_end_undo_group ();\n      vi_continued_command = 0;\n    }\n}",
      "lines": 34,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "_rl_vi_backup": {
      "start_point": [
        971,
        0
      ],
      "end_point": [
        978,
        1
      ],
      "content": "static void\n_rl_vi_backup ()\n{\n  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n    rl_point = _rl_find_prev_mbchar (rl_line_buffer, rl_point, MB_FIND_NONZERO);\n  else\n    rl_point--;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "rl_vi_check": {
      "start_point": [
        980,
        0
      ],
      "end_point": [
        991,
        1
      ],
      "content": "int\nrl_vi_check ()\n{\n  if (rl_point && rl_point == rl_end)\n    {\n      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n\trl_point = _rl_find_prev_mbchar (rl_line_buffer, rl_point, MB_FIND_NONZERO);\n      else\n\trl_point--;\n    }\n  return (0);\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "rl_digit_loop1": {
      "start_point": [
        1042,
        0
      ],
      "end_point": [
        1061,
        1
      ],
      "content": "static int\nrl_digit_loop1 ()\n{\n  int c, r;\n\n  while (1)\n    {\n      if (_rl_arg_overflow ())\n\treturn 1;\n\n      c = _rl_arg_getchar ();\n\n      r = _rl_vi_arg_dispatch (c);\n      if (r <= 0)\n\tbreak;\n    }\n\n  RL_UNSETSTATE(RL_STATE_NUMERICARG);\n  return (0);\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rl_vi_possible_completions": {
      "start_point": [
        2146,
        0
      ],
      "end_point": [
        2167,
        1
      ],
      "content": "int\nrl_vi_possible_completions()\n{\n  int save_pos = rl_point;\n\n  if (rl_line_buffer[rl_point] != ' ' && rl_line_buffer[rl_point] != ';')\n    {\n      while (rl_point < rl_end && rl_line_buffer[rl_point] != ' ' &&\n\t     rl_line_buffer[rl_point] != ';')\n\trl_point++;\n    }\n  else if (rl_line_buffer[rl_point - 1] == ';')\n    {\n      rl_ding ();\n      return (0);\n    }\n\n  rl_possible_completions ();\n  rl_point = save_pos;\n\n  return (0);\n}",
      "lines": 22,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "_rl_vi_set_mark": {
      "start_point": [
        2171,
        0
      ],
      "end_point": [
        2188,
        1
      ],
      "content": "static int\n_rl_vi_set_mark ()\n{\n  int ch;\n\n  RL_SETSTATE(RL_STATE_MOREINPUT);\n  ch = rl_read_key ();\n  RL_UNSETSTATE(RL_STATE_MOREINPUT);\n\n  if (ch < 0 || ch < 'a' || ch > 'z')\t/* make test against 0 explicit */\n    {\n      rl_ding ();\n      return 1;\n    }\n  ch -= 'a';\n  vi_mark_chars[ch] = rl_point;\n  return 0;\n}",
      "lines": 18,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "_rl_vi_goto_mark": {
      "start_point": [
        2218,
        0
      ],
      "end_point": [
        2246,
        1
      ],
      "content": "static int\n_rl_vi_goto_mark ()\n{\n  int ch;\n\n  RL_SETSTATE(RL_STATE_MOREINPUT);\n  ch = rl_read_key ();\n  RL_UNSETSTATE(RL_STATE_MOREINPUT);\n\n  if (ch == '`')\n    {\n      rl_point = rl_mark;\n      return 0;\n    }\n  else if (ch < 0 || ch < 'a' || ch > 'z')\t/* make test against 0 explicit */\n    {\n      rl_ding ();\n      return 1;\n    }\n\n  ch -= 'a';\n  if (vi_mark_chars[ch] == -1)\n    {\n      rl_ding ();\n      return 1;\n    }\n  rl_point = vi_mark_chars[ch];\n  return 0;\n}",
      "lines": 29,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "readline/readline-7.0/xfree.c": {},
  "readline/readline-7.0/xmalloc.c": {},
  "readline/readline-7.0/xmalloc.h": {},
  "readline/readline-7.0/examples/excallback.c": {
    "main": {
      "start_point": [
        101,
        0
      ],
      "end_point": [
        140,
        1
      ],
      "content": "int \nmain()\n{\n    fd_set fds;\n\n    /* Adjust the terminal slightly before the handler is installed. Disable\n     * canonical mode processing and set the input character time flag to be\n     * non-blocking.\n     */\n    if( tcgetattr(STDIN_FILENO, &term) < 0 ) {\n        perror(\"tcgetattr\");\n        exit(1);\n    }\n    old_lflag = term.c_lflag;\n    old_vtime = term.c_cc[VTIME];\n    term.c_lflag &= ~ICANON;\n    term.c_cc[VTIME] = 1;\n    /* COMMENT LINE BELOW - see above */\n    if( tcsetattr(STDIN_FILENO, TCSANOW, &term) < 0 ) {\n        perror(\"tcsetattr\");\n        exit(1);\n    }\n\n    rl_add_defun(\"change-prompt\", change_prompt, CTRL('t'));\n    rl_callback_handler_install(get_prompt(), process_line);\n\n    while(1) {\n      FD_ZERO(&fds);\n      FD_SET(fileno(stdin), &fds);\n\n      if( select(FD_SETSIZE, &fds, NULL, NULL, NULL) < 0) {\n        perror(\"select\");\n        exit(1);\n      }\n\n      if( FD_ISSET(fileno(stdin), &fds) ) {\n        rl_callback_read_char();\n      }\n    }\n}",
      "lines": 40,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "process_line": {
      "start_point": [
        142,
        0
      ],
      "end_point": [
        165,
        1
      ],
      "content": "void\nprocess_line(char *line)\n{\n  if( line == NULL ) {\n    fprintf(stderr, \"\\n\", line);\n\n    /* reset the old terminal setting before exiting */\n    term.c_lflag     = old_lflag;\n    term.c_cc[VTIME] = old_vtime;\n    if( tcsetattr(STDIN_FILENO, TCSANOW, &term) < 0 ) {\n        perror(\"tcsetattr\");\n        exit(1);\n    }\n    exit(0);\n  }\n\n  if( strcmp(line, \"sleep\") == 0 ) {\n    sleep(3);\n  } else {\n    fprintf(stderr, \"|%s|\\n\", line);\n  }\n\n  free (line);\n}",
      "lines": 24,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "change_prompt": {
      "start_point": [
        167,
        0
      ],
      "end_point": [
        186,
        1
      ],
      "content": "int\nchange_prompt(void)\n{\n  /* toggle the prompt variable */\n  prompt = !prompt;\n\n  /* save away the current contents of the line */\n  strcpy(line_buf, rl_line_buffer);\n\n  /* install a new handler which will change the prompt and erase the current line */\n  rl_callback_handler_install(get_prompt(), process_line);\n\n  /* insert the old text on the new line */\n  rl_insert_text(line_buf);\n\n  /* redraw the current line - this is an undocumented function. It invokes the\n   * redraw-current-line command.\n   */\n  rl_refresh_line(0, 0);\n}",
      "lines": 20,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "get_prompt": {
      "start_point": [
        188,
        0
      ],
      "end_point": [
        195,
        1
      ],
      "content": "char *\nget_prompt(void)\n{\n  /* The prompts can even be different lengths! */\n  sprintf(prompt_buf, \"%s\", \n    prompt ? \"Hit ctrl-t to toggle prompt> \" : \"Pretty cool huh?> \");\n  return prompt_buf;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "char",
        "*\nget_prompt(void)",
        "*"
      ]
    }
  },
  "readline/readline-7.0/examples/fileman.c": {
    "initialize_readline": {
      "start_point": [
        250,
        0
      ],
      "end_point": [
        258,
        1
      ],
      "content": "void\ninitialize_readline ()\n{\n  /* Allow conditional parsing of the ~/.inputrc file. */\n  rl_readline_name = \"FileMan\";\n\n  /* Tell the completer that we want a crack first. */\n  rl_attempted_completion_function = fileman_completion;\n}",
      "lines": 9,
      "depth": 6,
      "decorators": [
        "void"
      ]
    }
  },
  "readline/readline-7.0/examples/histexamp.c": {},
  "readline/readline-7.0/examples/hist_erasedups.c": {
    "usage": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "static void\nusage()\n{\n  fprintf (stderr, \"hist_erasedups: usage: hist_erasedups [-t] [filename]\\n\");\n  exit (2);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "hist_erasedups": {
      "start_point": [
        93,
        0
      ],
      "end_point": [
        118,
        1
      ],
      "content": "int\nhist_erasedups ()\n{\n  int r, n;\n  HIST_ENTRY *h, *temp;\n\n  using_history ();\n  while (h = previous_history ())\n    {\n      r = where_history ();\n      for (n = 0; n < r; n++)\n\t{\n\t  temp = history_get (n+history_base);\n\t  if (STREQ (h->line, temp->line))\n\t    {\n\t      remove_history (n);\n\t      r--;\t\t\t/* have to get one fewer now */\n\t      n--;\t\t\t/* compensate for above increment */\n\t      history_offset--;\t\t/* moving backwards in history list */\n\t    }\n\t}\n    }\n  using_history ();\n\n  return r;\n}",
      "lines": 26,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "readline/readline-7.0/examples/hist_purgecmd.c": {
    "usage": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "static void\nusage()\n{\n  fprintf (stderr, \"hist_purgecmd: usage: hist_purgecmd [-r] [-t] [-f filename] command-spec\\n\");\n  exit (2);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "readline/readline-7.0/examples/manexamp.c": {
    "rl_gets": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "char *\nrl_gets ()\n{\n  /* If the buffer has already been allocated, return the memory\n     to the free pool. */\n  if (line_read)\n    {\n      free (line_read);\n      line_read = (char *)NULL;\n    }\n\n  /* Get a line from the user. */\n  line_read = readline (\"\");\n\n  /* If the line has any text in it, save it on the history. */\n  if (line_read && *line_read)\n    add_history (line_read);\n\n  return (line_read);\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "char",
        "*\nrl_gets ()",
        "*"
      ]
    }
  },
  "readline/readline-7.0/examples/readlinebuf.h": {
    "showmanyc": [
      {
        "start_point": [
          45,
          0
        ],
        "end_point": [
          136,
          1
        ],
        "content": "class readlinebuf : public streambuf {\npublic:\n#if (defined __GNUC__) && (__GNUC__ < 3)\n\ttypedef char char_type;\n\ttypedef int int_type;\n\ttypedef streampos pos_type;\n\ttypedef streamoff off_type;\n#endif\n\tstatic const int_type eof = EOF; // this is -1\n\tstatic const int_type not_eof = 0;\n\nprivate:\n\tconst char* prompt_;\n\tbool history_;\n\tchar* line_;\n\tint low_;\n\tint high_;\n\nprotected:\n\t\t\n\tvirtual int_type showmanyc() const { return high_ - low_; }\n\t\t\n\tvirtual streamsize xsgetn( char_type* buf, streamsize n ) {\n\t\tint rd = n > (high_ - low_)? (high_ - low_) : n;\n\t\tmemcpy( buf, line_, rd );\n\t\tlow_ += rd;\n\t\t\t\n\t\tif ( rd < n ) {\n\t\t\tlow_ = high_ = 0;\n\t\t\tfree( line_ ); // free( NULL ) is a noop\n\t\t\tline_ = readline( prompt_ );\n\t\t\tif ( line_ ) {\n\t\t\t\thigh_ = strlen( line_ );\n\t\t\t\tif ( history_ && high_ ) add_history( line_ );\n\t\t\t\trd += xsgetn( buf + rd, n - rd );\n\t\t\t}\n\t\t}\n\t\t\t\n\t\treturn rd; \n\t}\n\t\t\n\tvirtual int_type underflow() {\n\t\tif ( high_ == low_ ) {\n\t\t\tlow_ = high_ = 0;\n\t\t\tfree( line_ ); // free( NULL ) is a noop\n\t\t\tline_ = readline( prompt_ );\n\t\t\tif ( line_ ) {\n\t\t\t\thigh_ = strlen( line_ );\n\t\t\t\tif ( history_ && high_ ) add_history( line_ );\n\t\t\t}\n\t\t}\n\t\t\t\n\t\tif ( low_ < high_ ) return line_[low_];\n\t\telse return eof;\n\t}\n\t\t\n\tvirtual int_type uflow() {\n\t\tint_type c = underflow();\n\t\tif ( c != eof ) ++low_;\n\t\treturn c;\n\t}\n\t\t\n\tvirtual int_type pbackfail( int_type c = eof ) {\n\t\tif ( low_ > 0 )\t--low_;\n\t\telse if ( c != eof ) {\n\t\t\tif ( high_ > 0 ) {\n\t\t\t\tchar* nl = (char*)realloc( line_, high_ + 1 );\n\t\t\t\tif ( nl ) {\n\t\t\t\t\tline_ = (char*)memcpy( nl + 1, line_, high_ );\n\t\t\t\t\thigh_ += 1;\n\t\t\t\t\tline_[0] = char( c );\n\t\t\t\t} else return eof;\n\t\t\t} else {\n\t\t\t\tassert( !line_ );\n\t\t\t\tline_ = (char*)malloc( sizeof( char ) );\n\t\t\t\t*line_ = char( c );\n\t\t\t\thigh_ = 1;\n\t\t\t}\n\t\t} else return eof;\n\n\t\treturn not_eof;\n\t}\n \t\t\npublic:\n\treadlinebuf( const char* prompt = NULL, bool history = true ) \n\t\t: prompt_( prompt ), history_( history ),\n\t\t  line_( NULL ), low_( 0 ), high_( 0 ) {\n\t\tsetbuf( 0, 0 );\n\t}\n\t\t\n\t\t\n}",
        "lines": 92,
        "depth": 18,
        "decorators": [
          "class",
          "readlinebuf",
          ": public streambuf",
          ":",
          "public",
          "streambuf",
          "{\npublic:\n#if (defined __GNUC__) && (__GNUC__ < 3)\n\ttypedef char char_type;\n\ttypedef int int_type;\n\ttypedef streampos pos_type;\n\ttypedef streamoff off_type;\n#endif\n\tstatic const int_type eof = EOF; // this is -1\n\tstatic const int_type not_eof = 0;\n\nprivate:\n\tconst char* prompt_;\n\tbool history_;\n\tchar* line_;\n\tint low_;\n\tint high_;\n\nprotected:\n\t\t\n\tvirtual int_type showmanyc() const { return high_ - low_; }\n\t\t\n\tvirtual streamsize xsgetn( char_type* buf, streamsize n ) {\n\t\tint rd = n > (high_ - low_)? (high_ - low_) : n;\n\t\tmemcpy( buf, line_, rd );\n\t\tlow_ += rd;\n\t\t\t\n\t\tif ( rd < n ) {\n\t\t\tlow_ = high_ = 0;\n\t\t\tfree( line_ ); // free( NULL ) is a noop\n\t\t\tline_ = readline( prompt_ );\n\t\t\tif ( line_ ) {\n\t\t\t\thigh_ = strlen( line_ );\n\t\t\t\tif ( history_ && high_ ) add_history( line_ );\n\t\t\t\trd += xsgetn( buf + rd, n - rd );\n\t\t\t}\n\t\t}\n\t\t\t\n\t\treturn rd; \n\t}\n\t\t\n\tvirtual int_type underflow() {\n\t\tif ( high_ == low_ ) {\n\t\t\tlow_ = high_ = 0;\n\t\t\tfree( line_ ); // free( NULL ) is a noop\n\t\t\tline_ = readline( prompt_ );\n\t\t\tif ( line_ ) {\n\t\t\t\thigh_ = strlen( line_ );\n\t\t\t\tif ( history_ && high_ ) add_history( line_ );\n\t\t\t}\n\t\t}\n\t\t\t\n\t\tif ( low_ < high_ ) return line_[low_];\n\t\telse return eof;\n\t}\n\t\t\n\tvirtual int_type uflow() {\n\t\tint_type c = underflow();\n\t\tif ( c != eof ) ++low_;\n\t\treturn c;\n\t}\n\t\t\n\tvirtual int_type pbackfail( int_type c = eof ) {\n\t\tif ( low_ > 0 )\t--low_;\n\t\telse if ( c != eof ) {\n\t\t\tif ( high_ > 0 ) {\n\t\t\t\tchar* nl = (char*)realloc( line_, high_ + 1 );\n\t\t\t\tif ( nl ) {\n\t\t\t\t\tline_ = (char*)memcpy( nl + 1, line_, high_ );\n\t\t\t\t\thigh_ += 1;\n\t\t\t\t\tline_[0] = char( c );\n\t\t\t\t} else return eof;\n\t\t\t} else {\n\t\t\t\tassert( !line_ );\n\t\t\t\tline_ = (char*)malloc( sizeof( char ) );\n\t\t\t\t*line_ = char( c );\n\t\t\t\thigh_ = 1;\n\t\t\t}\n\t\t} else return eof;\n\n\t\treturn not_eof;\n\t}\n \t\t\npublic:\n\treadlinebuf( const char* prompt = NULL, bool history = true ) \n\t\t: prompt_( prompt ), history_( history ),\n\t\t  line_( NULL ), low_( 0 ), high_( 0 ) {\n\t\tsetbuf( 0, 0 );\n\t}\n\t\t\n\t\t\n}",
          "{",
          "public:",
          "public",
          ":",
          "",
          "",
          "#if (defined __GNUC__) && (__GNUC__ < 3)\n\ttypedef char char_type;\n\ttypedef int int_type;\n\ttypedef streampos pos_type;\n\ttypedef streamoff off_type;\n#endif",
          "#if",
          "(defined __GNUC__) && (__GNUC__ < 3)",
          "(defined __GNUC__)",
          "(",
          "defined __GNUC__",
          "defined",
          "__GNUC__",
          ")",
          "&&",
          "(__GNUC__ < 3)",
          "(",
          "__GNUC__ < 3",
          "__GNUC__",
          "<",
          "3",
          ")",
          "\n",
          "typedef char char_type;",
          "typedef",
          "char",
          "char_type",
          ";",
          "typedef int int_type;",
          "typedef",
          "int",
          "int_type",
          ";",
          "typedef streampos pos_type;",
          "typedef",
          "streampos",
          "pos_type",
          ";",
          "typedef streamoff off_type;",
          "typedef",
          "streamoff",
          "off_type",
          ";",
          "#endif",
          "static const int_type eof = EOF;",
          "static",
          "static",
          "const",
          "const",
          "int_type",
          "eof = EOF",
          "eof",
          "=",
          "EOF",
          ";",
          "// this is -1",
          "static const int_type not_eof = 0;",
          "static",
          "static",
          "const",
          "const",
          "int_type",
          "not_eof = 0",
          "not_eof",
          "=",
          "0",
          ";",
          "private:\n\tconst char* prompt_;",
          "private",
          ":",
          "const char* prompt_;",
          "const char* prompt_",
          "const",
          "char",
          "char",
          "*",
          "prompt_",
          ";",
          "bool history_;",
          "bool",
          "history_",
          ";",
          "char* line_;",
          "char",
          "* line_",
          "*",
          "line_",
          ";",
          "int low_;",
          "int",
          "low_",
          ";",
          "int high_;",
          "int",
          "high_",
          ";",
          "protected:\n\t\t\n\tvirtual",
          "protected",
          ":",
          "virtual",
          "virtual",
          "",
          "int_type"
        ]
      },
      {
        "start_point": [
          65,
          9
        ],
        "end_point": [
          65,
          60
        ],
        "content": "int_type showmanyc() const { return high_ - low_; }",
        "lines": 1,
        "depth": 5,
        "decorators": [
          "int_type"
        ]
      }
    ],
    "xsgetn": {
      "start_point": [
        67,
        1
      ],
      "end_point": [
        84,
        2
      ],
      "content": "virtual streamsize xsgetn( char_type* buf, streamsize n ) {\n\t\tint rd = n > (high_ - low_)? (high_ - low_) : n;\n\t\tmemcpy( buf, line_, rd );\n\t\tlow_ += rd;\n\t\t\t\n\t\tif ( rd < n ) {\n\t\t\tlow_ = high_ = 0;\n\t\t\tfree( line_ ); // free( NULL ) is a noop\n\t\t\tline_ = readline( prompt_ );\n\t\t\tif ( line_ ) {\n\t\t\t\thigh_ = strlen( line_ );\n\t\t\t\tif ( history_ && high_ ) add_history( line_ );\n\t\t\t\trd += xsgetn( buf + rd, n - rd );\n\t\t\t}\n\t\t}\n\t\t\t\n\t\treturn rd; \n\t}",
      "lines": 18,
      "depth": 12,
      "decorators": [
        "virtual",
        "streamsize",
        "streamsize"
      ]
    },
    "underflow": {
      "start_point": [
        86,
        1
      ],
      "end_point": [
        99,
        2
      ],
      "content": "virtual int_type underflow() {\n\t\tif ( high_ == low_ ) {\n\t\t\tlow_ = high_ = 0;\n\t\t\tfree( line_ ); // free( NULL ) is a noop\n\t\t\tline_ = readline( prompt_ );\n\t\t\tif ( line_ ) {\n\t\t\t\thigh_ = strlen( line_ );\n\t\t\t\tif ( history_ && high_ ) add_history( line_ );\n\t\t\t}\n\t\t}\n\t\t\t\n\t\tif ( low_ < high_ ) return line_[low_];\n\t\telse return eof;\n\t}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "virtual",
        "int_type",
        "int_type"
      ]
    },
    "uflow": {
      "start_point": [
        101,
        1
      ],
      "end_point": [
        105,
        2
      ],
      "content": "virtual int_type uflow() {\n\t\tint_type c = underflow();\n\t\tif ( c != eof ) ++low_;\n\t\treturn c;\n\t}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "virtual",
        "int_type",
        "int_type"
      ]
    },
    "pbackfail": {
      "start_point": [
        107,
        1
      ],
      "end_point": [
        126,
        2
      ],
      "content": "virtual int_type pbackfail( int_type c = eof ) {\n\t\tif ( low_ > 0 )\t--low_;\n\t\telse if ( c != eof ) {\n\t\t\tif ( high_ > 0 ) {\n\t\t\t\tchar* nl = (char*)realloc( line_, high_ + 1 );\n\t\t\t\tif ( nl ) {\n\t\t\t\t\tline_ = (char*)memcpy( nl + 1, line_, high_ );\n\t\t\t\t\thigh_ += 1;\n\t\t\t\t\tline_[0] = char( c );\n\t\t\t\t} else return eof;\n\t\t\t} else {\n\t\t\t\tassert( !line_ );\n\t\t\t\tline_ = (char*)malloc( sizeof( char ) );\n\t\t\t\t*line_ = char( c );\n\t\t\t\thigh_ = 1;\n\t\t\t}\n\t\t} else return eof;\n\n\t\treturn not_eof;\n\t}",
      "lines": 20,
      "depth": 16,
      "decorators": [
        "virtual",
        "int_type",
        "int_type"
      ]
    }
  },
  "readline/readline-7.0/examples/rl-callbacktest.c": {
    "sighandler": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "static void\nsighandler (int sig)\n{\n  sigwinch_received = 1;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "cb_linehandler": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "static void\ncb_linehandler (char *line)\n{\n  /* Can use ^D (stty eof) or `exit' to exit. */\n  if (line == NULL || strcmp (line, \"exit\") == 0)\n    {\n      if (line == 0)\n        printf (\"\\n\");\n      printf (\"exit\\n\");\n      /* This function needs to be called to reset the terminal settings,\n\t and calling it from the line handler keeps one extra prompt from\n\t being displayed. */\n      rl_callback_handler_remove ();\n\n      running = 0;\n    }\n  else\n    {\n      if (*line)\n\tadd_history (line);\n      printf (\"input line: %s\\n\", line);\n      free (line);\n    }\n}",
      "lines": 24,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        68,
        0
      ],
      "end_point": [
        114,
        1
      ],
      "content": "int\nmain (int c, char **v)\n{\n  fd_set fds;\n  int r;\n\n\n  setlocale (LC_ALL, \"\");\n\n  /* Handle SIGWINCH */\n  signal (SIGWINCH, sighandler);\n  \n  /* Install the line handler. */\n  rl_callback_handler_install (prompt, cb_linehandler);\n\n  /* Enter a simple event loop.  This waits until something is available\n     to read on readline's input stream (defaults to standard input) and\n     calls the builtin character read callback to read it.  It does not\n     have to modify the user's terminal settings. */\n  running = 1;\n  while (running)\n    {\n      FD_ZERO (&fds);\n      FD_SET (fileno (rl_instream), &fds);    \n\n      r = select (FD_SETSIZE, &fds, NULL, NULL, NULL);\n      if (r < 0 && errno != EINTR)\n\t{\n\t  perror (\"rltest: select\");\n\t  rl_callback_handler_remove ();\n\t  break;\n\t}\n      if (sigwinch_received)\n\t{\n\t  rl_resize_terminal ();\n\t  sigwinch_received = 0;\n\t}\n      if (r < 0)\n\tcontinue;\n\n      if (FD_ISSET (fileno (rl_instream), &fds))\n\trl_callback_read_char ();\n    }\n\n  printf (\"rltest: Event loop has exited\\n\");\n  return 0;\n}",
      "lines": 47,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "readline/readline-7.0/examples/rl-fgets.c": {
    "my_fgets_reset": {
      "start_point": [
        155,
        0
      ],
      "end_point": [
        171,
        1
      ],
      "content": "static void\nmy_fgets_reset (\n  void\n) {\n  if ( my_fgets_names && (my_fgets_number_of_names > 0) ) {\n    int i ;\n    if ( my_fgets_debug_flag ) {\n      printf ( \"libfgets:  removing command list\\n\" ) ;\n    }\n    for ( i = 0 ; i < my_fgets_number_of_names ; i ++ ) {\n      if ( my_fgets_names[i] ) free ( my_fgets_names[i] ) ;\n    }\n    free ( my_fgets_names ) ;\n  }\n  my_fgets_names = NULL ;\n  my_fgets_number_of_names = 0 ;\n}",
      "lines": 17,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "my_fgets_dump": {
      "start_point": [
        176,
        0
      ],
      "end_point": [
        197,
        1
      ],
      "content": "static void\nmy_fgets_dump (\n  void\n) {\n  char * s ;\n  printf ( \"\\n\" ) ;\n  s = getenv ( \"FGETS_PROMPT\" ) ;\n  printf ( \"FGETS_PROMPT       = %s\\n\", s ? s : \"\" ) ;\n  s = getenv ( \"FGETS_COMMAND_FILE\" ) ;\n  printf ( \"FGETS_COMMAND_FILE = %s\\n\", s ? s : \"\" ) ;\n  printf ( \"debug flag         = %d\\n\", my_fgets_debug_flag ) ;\n  printf ( \"#commands          = %d\\n\", my_fgets_number_of_names ) ;\n  if ( my_fgets_debug_flag ) {\n    if ( my_fgets_names && (my_fgets_number_of_names > 0) ) {\n      int i ;\n      for ( i = 0 ; i < my_fgets_number_of_names ; i ++ ) {\n        printf ( \"%s\\n\", my_fgets_names[i] ) ;\n      }\n    }\n  }\n  printf ( \"\\n\" ) ;\n}",
      "lines": 22,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "my_fgets_debug_toggle": {
      "start_point": [
        202,
        0
      ],
      "end_point": [
        210,
        1
      ],
      "content": "static void\nmy_fgets_debug_toggle (\n  void\n) {\n  my_fgets_debug_flag = my_fgets_debug_flag ? 0 : 1 ;\n  if ( my_fgets_debug_flag ) {\n    printf ( \"libfgets:  debug flag = %d\\n\", my_fgets_debug_flag ) ;\n  }\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "my_fgets_lookup": {
      "start_point": [
        215,
        0
      ],
      "end_point": [
        269,
        1
      ],
      "content": "static char *\nmy_fgets_lookup (\n  int index\n) {\n  if ( (! my_fgets_names) || (! my_fgets_number_of_names) ) {\n    char * fname ;\n    FILE * fp ;\n    fgets_t _fgets ;\n    int i ;\n    char buf1[256], buf2[256] ;\n    fname = getenv ( \"FGETS_COMMAND_FILE\" ) ;\n    if ( ! fname ) {\n      if ( my_fgets_debug_flag ) {\n        printf ( \"libfgets:  empty or unset FGETS_COMMAND_FILE\\n\" ) ;\n      }\n      return NULL ;\n    }\n    fp = fopen ( fname, \"r\" ) ;\n    if ( ! fp ) {\n      if ( my_fgets_debug_flag ) {\n        printf ( \"libfgets:  cannot open '%s' for reading\\n\", fname ) ;\n      }\n      return NULL ;\n    }\n    _fgets = (fgets_t) dlsym ( REAL_LIBC, \"fgets\" ) ;\n    if ( ! _fgets ) {\n      fprintf ( stderr,\n        \"libfgets:  failed to dynamically link to native fgets()\\n\"\n      ) ;\n      return NULL ;\n    }\n    for ( i = 0 ; _fgets(buf1,255,fp) ; i ++ ) ;\n    if ( ! i ) { fclose(fp) ; return NULL ; }\n    my_fgets_names = (char**) calloc ( i, sizeof(char*) ) ;\n    rewind ( fp ) ;\n    i = 0 ;\n    while ( _fgets(buf1,255,fp) ) {\n      buf1[255] = 0 ;\n      if ( 1 == sscanf(buf1,\"%s\",buf2) ) {\n        my_fgets_names[i] = strdup(buf2) ;\n        i ++ ;\n      }\n    }\n    fclose ( fp ) ;\n    my_fgets_number_of_names = i ;\n    if ( my_fgets_debug_flag ) {\n      printf ( \"libfgets:  successfully read %d commands\\n\", i ) ;\n    }\n  }\n  if ( index < my_fgets_number_of_names ) {\n    return my_fgets_names[index] ;\n  } else {\n    return NULL ;\n  }\n}",
      "lines": 55,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nmy_fgets_lookup (\n  int index\n)",
        "*"
      ]
    },
    "my_fgets_generator": {
      "start_point": [
        274,
        0
      ],
      "end_point": [
        293,
        1
      ],
      "content": "static char *\nmy_fgets_generator (\n  const char * text,\n  int          state\n)\n{\n  static int list_index, len ;\n  char *     name ;\n  if ( ! state ) {\n    list_index = 0 ;\n    len = strlen ( text ) ;\n  }\n  while ( ( name = my_fgets_lookup(list_index) ) ) {\n    list_index ++ ;\n    if ( ! strncmp ( name, text, len ) ) {\n      return ( strdup ( name ) ) ;\n    }\n  }\n  return ( NULL ) ;\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nmy_fgets_generator (\n  const char * text,\n  int          state\n)",
        "*"
      ]
    },
    "my_fgets_completion": {
      "start_point": [
        298,
        0
      ],
      "end_point": [
        311,
        1
      ],
      "content": "static char **\nmy_fgets_completion (\n  const char * text,\n  int          start,\n  int          end\n)\n{\n  char ** matches ;\n  matches = NULL ;\n  if ( ! start ) {\n    matches = rl_completion_matches ( text, my_fgets_generator ) ;\n  }\n  return ( matches ) ;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "char",
        "**\nmy_fgets_completion (\n  const char * text,\n  int          start,\n  int          end\n)",
        "*",
        "*\nmy_fgets_completion (\n  const char * text,\n  int          start,\n  int          end\n)",
        "*"
      ]
    },
    "fgets": {
      "start_point": [
        316,
        0
      ],
      "end_point": [
        373,
        1
      ],
      "content": "char *\nfgets (\n  char * s,\n  int    n,\n  FILE * stream\n)\n{\n  if ( ! s ) return NULL ;\n  if ( stream == stdin ) {\n    char * prompt ;\n    char * my_fgets_line ;\n    rl_already_prompted = 1 ;\n    rl_attempted_completion_function = my_fgets_completion ;\n    rl_catch_signals = 1 ;\n    rl_catch_sigwinch = 1 ;\n    rl_set_signals () ;\n    prompt = getenv ( \"FGETS_PROMPT\" ) ;\n    for (\n      my_fgets_line = 0 ; ! my_fgets_line ; my_fgets_line=readline(prompt)\n    ) ;\n    if ( ! strncmp(my_fgets_line, \"_fgets_reset_\", 13) ) {\n      my_fgets_reset () ;\n      free ( my_fgets_line ) ;\n      strcpy ( s, \"\\n\" ) ;\n      return ( s ) ;\n    }\n    if ( ! strncmp(my_fgets_line, \"_fgets_dump_\", 12) ) {\n      my_fgets_dump () ;\n      free ( my_fgets_line ) ;\n      strcpy ( s, \"\\n\" ) ;\n      return ( s ) ;\n    }\n    if ( ! strncmp(my_fgets_line, \"_fgets_debug_\", 13) ) {\n      my_fgets_debug_toggle () ;\n      free ( my_fgets_line ) ;\n      strcpy ( s, \"\\n\" ) ;\n      return ( s ) ;\n    }\n    (void) strncpy ( s, my_fgets_line, n-1 ) ;\n    (void) strcat ( s, \"\\n\" ) ;\n    if ( *my_fgets_line ) add_history ( my_fgets_line ) ;\n    free ( my_fgets_line ) ;\n    return ( s ) ;\n  } else {\n    static fgets_t _fgets ;\n    _fgets = (fgets_t) dlsym ( REAL_LIBC, \"fgets\" ) ;\n    if ( ! _fgets ) {\n      fprintf ( stderr,\n        \"libfgets:  failed to dynamically link to native fgets()\\n\"\n      ) ;\n      strcpy ( s, \"\\n\" ) ;\n      return ( s ) ;\n    }\n    return (\n      _fgets ( s, n, stream )\n    ) ;\n  }\n}",
      "lines": 58,
      "depth": 11,
      "decorators": [
        "char",
        "*\nfgets (\n  char * s,\n  int    n,\n  FILE * stream\n)",
        "*"
      ]
    }
  },
  "readline/readline-7.0/examples/rl.c": {
    "set_deftext": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "static int\nset_deftext ()\n{\n  if (deftext)\n    {\n      rl_insert_text (deftext);\n      deftext = (char *)NULL;\n      rl_startup_hook = (rl_hook_func_t *)NULL;\n    }\n  return 0;\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "usage": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "static void\nusage()\n{\n  fprintf (stderr, \"%s: usage: %s [-p prompt] [-u unit] [-d default] [-n nchars]\\n\",\n\t\tprogname, progname);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "readline/readline-7.0/examples/rlbasic.c": {
    "main": {
      "start_point": [
        13,
        0
      ],
      "end_point": [
        28,
        1
      ],
      "content": "int\nmain (int c, char **v)\n{\n\tchar *input;\n\n\tfor (;;) {\n\t\tinput = readline ((char *)NULL);\n\t\tif (input == 0)\n\t\t\tbreak;\n\t\tprintf (\"%s\\n\", input);\n\t\tif (strcmp (input, \"exit\") == 0)\n\t\t\tbreak;\n\t\tfree (input);\n\t}\n\texit (0);\n}",
      "lines": 16,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "readline/readline-7.0/examples/rlcat.c": {
    "usage": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "static void\nusage()\n{\n  fprintf (stderr, \"%s: usage: %s [-vEVN] [filename]\\n\", progname, progname);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "readline/readline-7.0/examples/rlevent.c": {
    "event_hook": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        65,
        1
      ],
      "content": "static int\nevent_hook ()\n{\n  fprintf (stderr, \"ding!\\n\");\n  sleep (1);\n  return 0;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "set_deftext": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "static int\nset_deftext ()\n{\n  if (deftext)\n    {\n      rl_insert_text (deftext);\n      deftext = (char *)NULL;\n      rl_startup_hook = (rl_hook_func_t *)NULL;\n    }\n  return 0;\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "usage": {
      "start_point": [
        79,
        0
      ],
      "end_point": [
        84,
        1
      ],
      "content": "static void\nusage()\n{\n  fprintf (stderr, \"%s: usage: %s [-p prompt] [-u unit] [-d default] [-n nchars]\\n\",\n\t\tprogname, progname);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "readline/readline-7.0/examples/rlptytest.c": {
    "user_input": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        73,
        1
      ],
      "content": "static int \nuser_input()\n{\n  int size;\n  const int MAX = 1024;\n  char *buf = (char *)malloc(MAX+1);\n\n  size = read (STDIN_FILENO, buf, MAX);\n  if (size == -1)\n    return -1;\n\n  size = write (masterfd, buf, size);\n  if (size == -1)\n    return -1;\n\n  return 0;\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "readline_input": {
      "start_point": [
        75,
        0
      ],
      "end_point": [
        99,
        1
      ],
      "content": "static int \nreadline_input()\n{\n  const int MAX = 1024;\n  char *buf = (char *)malloc(MAX+1);\n  int size;\n\n  size = read (masterfd, buf, MAX);\n  if (size == -1)\n    {\n      free( buf );\n      buf = NULL;\n      return -1;\n    }\n\n  buf[size] = 0;\n\n  /* Display output from readline */\n  if ( size > 0 )\n    fprintf(stderr, \"%s\", buf);\n\n  free( buf );\n  buf = NULL;\n  return 0;\n}",
      "lines": 25,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rlctx_send_user_command": {
      "start_point": [
        101,
        0
      ],
      "end_point": [
        119,
        1
      ],
      "content": "static void \nrlctx_send_user_command(char *line)\n{\n  /* This happens when rl_callback_read_char gets EOF */\n  if ( line == NULL )\n    return;\n    \n  if (strcmp (line, \"exit\") == 0) {\n  \ttty_reset (STDIN_FILENO);\n  \tclose (masterfd);\n  \tclose (slavefd);\n  \tprintf (\"\\n\");\n\texit (0);\n  }\n  \n  /* Don't add the enter command */\n  if ( line && *line != '\\0' )\n    add_history(line);\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "custom_deprep_term_function": {
      "start_point": [
        121,
        0
      ],
      "end_point": [
        124,
        1
      ],
      "content": "static void \ncustom_deprep_term_function ()\n{\n}",
      "lines": 4,
      "depth": 4,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "init_readline": {
      "start_point": [
        126,
        0
      ],
      "end_point": [
        159,
        1
      ],
      "content": "static int \ninit_readline (int inputfd, int outputfd) \n{\n  FILE *inputFILE, *outputFILE;\n\n  inputFILE = fdopen (inputfd, \"r\");\n  if (!inputFILE)\n    return -1;\n\n  outputFILE = fdopen (outputfd, \"w\");\n  if (!outputFILE)\n    return -1;\n\n  rl_instream = inputFILE;\n  rl_outstream = outputFILE;\n\n  /* Tell readline what the prompt is if it needs to put it back */\n  rl_callback_handler_install(\"(rltest):  \", rlctx_send_user_command);\n\n  /* Set the terminal type to dumb so the output of readline can be\n   * understood by tgdb */\n  if ( rl_reset_terminal(\"dumb\") == -1 )\n    return -1;\n\n  /* For some reason, readline can not deprep the terminal.\n   * However, it doesn't matter because no other application is working on\n   * the terminal besides readline */\n  rl_deprep_term_function = custom_deprep_term_function;\n\n  using_history();\n  read_history(\".history\"); \n\n  return 0;\n}",
      "lines": 34,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main_loop": {
      "start_point": [
        161,
        0
      ],
      "end_point": [
        208,
        1
      ],
      "content": "static int \nmain_loop(void)\n{\n  fd_set rset;\n  int max;\n    \n  max = (masterfd > STDIN_FILENO) ? masterfd : STDIN_FILENO;\n  max = (max > slavefd) ? max : slavefd;\n\n  for (;;)\n    {\n      /* Reset the fd_set, and watch for input from GDB or stdin */\n      FD_ZERO(&rset);\n        \n      FD_SET(STDIN_FILENO, &rset);\n      FD_SET(slavefd, &rset);\n      FD_SET(masterfd, &rset);\n\n      /* Wait for input */\n      if (select(max + 1, &rset, NULL, NULL, NULL) == -1)\n        {\n          if (errno == EINTR)\n             continue;\n          else\n            return -1;\n        }\n\n      /* Input received through the pty:  Handle it \n       * Wrote to masterfd, slave fd has that input, alert readline to read it. \n       */\n      if (FD_ISSET(slavefd, &rset))\n        rl_callback_read_char();\n\n      /* Input received through the pty.\n       * Readline read from slavefd, and it wrote to the masterfd. \n       */\n      if (FD_ISSET(masterfd, &rset))\n        if ( readline_input() == -1 )\n          return -1;\n\n      /* Input received:  Handle it, write to masterfd (input to readline) */\n      if (FD_ISSET(STDIN_FILENO, &rset))\n        if ( user_input() == -1 )\n          return -1;\n  }\n\n  return 0;\n}",
      "lines": 48,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "tty_cbreak": {
      "start_point": [
        224,
        0
      ],
      "end_point": [
        274,
        1
      ],
      "content": "int tty_cbreak(int fd){\n   struct termios buf;\n    int ttysavefd = -1;\n   \n   if(tcgetattr(fd, &save_termios) < 0)\n      return -1;\n      \n   buf = save_termios;\n   buf.c_lflag &= ~(ECHO | ICANON);\n   buf.c_iflag &= ~(ICRNL | INLCR);\n   buf.c_cc[VMIN] = 1;\n   buf.c_cc[VTIME] = 0;\n\n#if defined (VLNEXT) && defined (_POSIX_VDISABLE)\n   buf.c_cc[VLNEXT] = _POSIX_VDISABLE;\n#endif\n\n#if defined (VDSUSP) && defined (_POSIX_VDISABLE)\n   buf.c_cc[VDSUSP] = _POSIX_VDISABLE;\n#endif\n\n  /* enable flow control; only stty start char can restart output */\n#if 0\n  buf.c_iflag |= (IXON|IXOFF);\n#ifdef IXANY\n  buf.c_iflag &= ~IXANY;\n#endif\n#endif\n\n  /* disable flow control; let ^S and ^Q through to pty */\n  buf.c_iflag &= ~(IXON|IXOFF);\n#ifdef IXANY\n  buf.c_iflag &= ~IXANY;\n#endif\n\n  if(tcsetattr(fd, TCSAFLUSH, &buf) < 0)\n      return -1;\n\n   ttystate = TCBREAK;\n   ttysavefd = fd;\n\n   /* set size */\n   if(ioctl(fd, TIOCGWINSZ, (char *)&size) < 0)\n      return -1;\n\n#ifdef DEBUG\n   err_msg(\"%d rows and %d cols\\n\", size.ws_row, size.ws_col);   \n#endif\n   \n   return (0);   \n}",
      "lines": 51,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "tty_off_xon_xoff": {
      "start_point": [
        276,
        0
      ],
      "end_point": [
        291,
        1
      ],
      "content": "int \ntty_off_xon_xoff (int fd)\n{\n  struct termios buf;\n  int ttysavefd = -1;\n\n  if(tcgetattr(fd, &buf) < 0)\n    return -1;\n     \n  buf.c_iflag &= ~(IXON|IXOFF);\n\n  if(tcsetattr(fd, TCSAFLUSH, &buf) < 0)\n    return -1;\n\n  return 0;   \n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "tty_reset": {
      "start_point": [
        300,
        0
      ],
      "end_point": [
        311,
        1
      ],
      "content": "int tty_reset(int fd)\n{\n   if(ttystate != TCBREAK)\n      return (0);\n\n   if(tcsetattr(fd, TCSAFLUSH, &save_termios) < 0)\n      return (-1);\n      \n   ttystate = RESET;\n   \n   return 0;   \n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "main": {
      "start_point": [
        313,
        0
      ],
      "end_point": [
        344,
        1
      ],
      "content": "int \nmain()\n{\n  int val;\n  val = openpty (&masterfd, &slavefd, NULL, NULL, NULL);\n  if (val == -1)\n    return -1;\n\n  val = tty_off_xon_xoff (masterfd);\n  if (val == -1)\n    return -1;\n\n  signal (SIGWINCH, sigwinch);\n  signal (SIGINT, sigint);\n\n  val = init_readline (slavefd, slavefd);\n  if (val == -1)\n    return -1;\n\n  val = tty_cbreak (STDIN_FILENO);\n  if (val == -1)\n    return -1;\n\n  val = main_loop ();\n\n  tty_reset (STDIN_FILENO);\n\n  if (val == -1)\n    return -1;\n\n  return 0;\n}",
      "lines": 32,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "readline/readline-7.0/examples/rltest.c": {},
  "readline/readline-7.0/examples/rlversion.c": {
    "main": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "int\nmain()\n{\n\tprintf (\"%s\\n\", rl_library_version ? rl_library_version : \"unknown\");\n\texit (0);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "readline/readline-7.0/examples/rlfe/extern.h": {},
  "readline/readline-7.0/examples/rlfe/os.h": {},
  "readline/readline-7.0/examples/rlfe/pty.c": {},
  "readline/readline-7.0/examples/rlfe/rlfe.c": {
    "sig_child": {
      "start_point": [
        155,
        0
      ],
      "end_point": [
        169,
        1
      ],
      "content": "static void\nsig_child (int signo)\n{\n  int status;\n  wait (&status);\n  if (hist_file != 0)\n    {\n      write_history (hist_file);\n      if (hist_size)\n\thistory_truncate_file (hist_file, hist_size);\n    }\n  DPRINT0 (\"(Child process died.)\\n\");\n  tcsetattr(STDIN_FILENO, TCSANOW, &orig_term);\n  exit (0);\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "sigwinch_handler": {
      "start_point": [
        177,
        0
      ],
      "end_point": [
        179,
        1
      ],
      "content": "void sigwinch_handler(int signal) { \n   propagate_sigwinch = 1;\n}",
      "lines": 3,
      "depth": 5,
      "decorators": [
        "void"
      ]
    },
    "get_slave_pty": {
      "start_point": [
        187,
        0
      ],
      "end_point": [
        220,
        1
      ],
      "content": "int get_slave_pty(char *name) { \n   struct group *gptr;\n   gid_t gid;\n   int slave = -1;\n\n   /* chown/chmod the corresponding pty, if possible.\n    * This will only work if the process has root permissions.\n    * Alternatively, write and exec a small setuid program that\n    * does just this.\n    */\n   if ((gptr = getgrnam(\"tty\")) != 0) {\n      gid = gptr->gr_gid;\n   } else {\n      /* if the tty group does not exist, don't change the\n       * group on the slave pty, only the owner\n       */\n      gid = -1;\n   }\n\n   /* Note that we do not check for errors here.  If this is code\n    * where these actions are critical, check for errors!\n    */\n   chown(name, getuid(), gid);\n   /* This code only makes the slave read/writeable for the user.\n    * If this is for an interactive shell that will want to\n    * receive \"write\" and \"wall\" messages, OR S_IWGRP into the\n    * second argument below.\n    */\n   chmod(name, S_IRUSR|S_IWUSR);\n\n   /* open the corresponding slave pty */\n   slave = open(name, O_RDWR);\n   return (slave);\n}",
      "lines": 34,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "add_special_char": {
      "start_point": [
        228,
        0
      ],
      "end_point": [
        233,
        1
      ],
      "content": "static void\nadd_special_char(int ch)\n{\n  if (ch != 0)\n    special_chars[special_chars_count++] = ch;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "is_special_char": {
      "start_point": [
        237,
        0
      ],
      "end_point": [
        249,
        1
      ],
      "content": "static int\nis_special_char(int ch)\n{\n  int i;\n#if 0\n  if (ch == eof_char && rl_point == rl_end)\n    return 1;\n#endif\n  for (i = special_chars_count;  --i >= 0; )\n    if (special_chars[i] == ch)\n      return 1;\n  return 0;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "maybe_emphasize_input": {
      "start_point": [
        264,
        0
      ],
      "end_point": [
        272,
        1
      ],
      "content": "static void maybe_emphasize_input (int on)\n{\n  if (on == current_emphasize_input\n      || (on && ! do_emphasize_input))\n    return;\n  fprintf (rl_outstream, on ? start_input_mode : end_input_mode);\n  fflush (rl_outstream);\n  current_emphasize_input = on;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "null_prep_terminal": {
      "start_point": [
        274,
        0
      ],
      "end_point": [
        277,
        1
      ],
      "content": "static void\nnull_prep_terminal (int meta)\n{\n}",
      "lines": 4,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "null_deprep_terminal": {
      "start_point": [
        279,
        0
      ],
      "end_point": [
        283,
        1
      ],
      "content": "static void\nnull_deprep_terminal ()\n{\n  maybe_emphasize_input (0);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "pre_input_change_mode": {
      "start_point": [
        285,
        0
      ],
      "end_point": [
        289,
        1
      ],
      "content": "static int\npre_input_change_mode (void)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "line_handler": {
      "start_point": [
        293,
        0
      ],
      "end_point": [
        355,
        1
      ],
      "content": "static void\nline_handler (char *line)\n{\n  if (line == NULL)\n    {\n      char buf[1];\n      DPRINT0(\"saw eof!\\n\");\n      buf[0] = '\\004'; /* ctrl/d */\n      write (out_to_inferior_fd, buf, 1);\n    }\n  else\n    {\n      static char enter[] = \"\\r\";\n      /*  Send line to inferior: */\n      int length = strlen (line);\n      if (length > ECHO_SUPPRESS_MAX-2)\n\t{\n\t  echo_suppress_start = 0;\n\t  echo_suppress_limit = 0;\n\t}\n      else\n\t{\n\t  if (echo_suppress_limit + length > ECHO_SUPPRESS_MAX - 2)\n\t    {\n\t      if (echo_suppress_limit - echo_suppress_start + length\n\t\t  <= ECHO_SUPPRESS_MAX - 2)\n\t\t{\n\t\t  memmove (echo_suppress_buffer,\n\t\t\t   echo_suppress_buffer + echo_suppress_start,\n\t\t\t   echo_suppress_limit - echo_suppress_start);\n\t\t  echo_suppress_limit -= echo_suppress_start;\n\t\t  echo_suppress_start = 0;\n\t\t}\n\t      else\n\t\t{\n\t\t  echo_suppress_limit = 0;\n\t\t}\n\t      echo_suppress_start = 0;\n\t    }\n\t  memcpy (echo_suppress_buffer + echo_suppress_limit,\n\t\t  line, length);\n\t  echo_suppress_limit += length;\n\t  echo_suppress_buffer[echo_suppress_limit++] = '\\r';\n\t  echo_suppress_buffer[echo_suppress_limit++] = '\\n';\n\t}\n      write (out_to_inferior_fd, line, length);\n      if (pending_special_char == 0)\n        {\n          write (out_to_inferior_fd, enter, sizeof(enter)-1);\n          if (*line)\n            add_history (line);\n        }\n      free (line);\n    }\n  rl_callback_handler_remove ();\n  buf_count = 0;\n  num_keys = 0;\n  if (pending_special_char != 0)\n    {\n      write (out_to_inferior_fd, &pending_special_char, 1);\n      pending_special_char = 0;\n    }\n}",
      "lines": 63,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "my_rl_getc": {
      "start_point": [
        361,
        0
      ],
      "end_point": [
        371,
        1
      ],
      "content": "int\nmy_rl_getc (FILE *dummy)\n{\n  int ch = rl_getc (stdin);\n  if (is_special_char (ch))\n    {\n      pending_special_char = ch;\n      return '\\r';\n    }\n  return ch;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "main": {
      "start_point": [
        373,
        0
      ],
      "end_point": [
        756,
        1
      ],
      "content": "int\nmain(int argc, char** argv)\n{\n  char *path;\n  int i;\n  int master;\n  char *name;\n  int in_from_tty_fd;\n  struct sigaction act;\n  struct winsize ws;\n  struct termios t;\n  int maxfd;\n  fd_set in_set;\n  static char empty_string[1] = \"\";\n  char *prompt = empty_string;\n  int ioctl_err = 0;\n  int arg_base = 1;\n\n#ifdef DEBUG\n  logfile = fopen(\"/tmp/rlfe.log\", \"w\");\n#endif\n\n  while (arg_base<argc)\n    {\n      if (argv[arg_base][0] != '-')\n\tbreak;\n      if (arg_base+1 >= argc )\n\tusage_exit();\n      switch(argv[arg_base][1])\n\t{\n\tcase 'h':\n\t  arg_base++;\n\t  hist_file = argv[arg_base];\n\t  break;\n\tcase 's':\n\t  arg_base++;\n\t  hist_size = atoi(argv[arg_base]);\n\t  if (hist_size<0)\n\t    usage_exit();\n\t  break;\n\tdefault:\n\t  usage_exit();\n\t}\n      arg_base++;\n    }\n  if (hist_file)\n    read_history (hist_file);\n\n  set_edit_mode ();\n\n  rl_readline_name = APPLICATION_NAME;\n  \n  if ((master = OpenPTY (&name)) < 0)\n    {\n      perror(\"ptypair: could not open master pty\");\n      exit(1);\n    }\n\n  DPRINT1(\"pty name: '%s'\\n\", name);\n\n  /* set up SIGWINCH handler */\n  act.sa_handler = sigwinch_handler;\n  sigemptyset(&(act.sa_mask));\n  act.sa_flags = 0;\n  if (sigaction(SIGWINCH, &act, NULL) < 0)\n    {\n      perror(\"ptypair: could not handle SIGWINCH \");\n      exit(1);\n    }\n\n  if (ioctl(STDIN_FILENO, TIOCGWINSZ, &ws) < 0)\n    {\n      perror(\"ptypair: could not get window size\");\n      exit(1);\n    }\n\n  if ((child = fork()) < 0)\n    {\n      perror(\"cannot fork\");\n      exit(1);\n    }\n\n  if (child == 0)\n    { \n      int slave;  /* file descriptor for slave pty */\n\n      /* We are in the child process */\n      close(master);\n\n#ifdef TIOCSCTTY\n      if ((slave = get_slave_pty(name)) < 0)\n\t{\n\t  perror(\"ptypair: could not open slave pty\");\n\t  exit(1);\n\t}\n#endif\n\n      /* We need to make this process a session group leader, because\n       * it is on a new PTY, and things like job control simply will\n       * not work correctly unless there is a session group leader\n       * and process group leader (which a session group leader\n       * automatically is). This also disassociates us from our old\n       * controlling tty. \n       */\n      if (setsid() < 0)\n\t{\n\t  perror(\"could not set session leader\");\n\t}\n\n      /* Tie us to our new controlling tty. */\n#ifdef TIOCSCTTY\n      if (ioctl(slave, TIOCSCTTY, NULL))\n\t{\n\t  perror(\"could not set new controlling tty\");\n\t}\n#else\n      if ((slave = get_slave_pty(name)) < 0)\n\t{\n\t  perror(\"ptypair: could not open slave pty\");\n\t  exit(1);\n\t}\n#endif\n\n      /* make slave pty be standard in, out, and error */\n      dup2(slave, STDIN_FILENO);\n      dup2(slave, STDOUT_FILENO);\n      dup2(slave, STDERR_FILENO);\n\n      /* at this point the slave pty should be standard input */\n      if (slave > 2)\n\t{\n\t  close(slave);\n\t}\n\n      /* Try to restore window size; failure isn't critical */\n      if (ioctl(STDOUT_FILENO, TIOCSWINSZ, &ws) < 0)\n\t{\n\t  perror(\"could not restore window size\");\n\t}\n\n      /* now start the shell */\n      {\n\tstatic char* command_args[] = { COMMAND_ARGS, NULL };\n\tstatic char* alt_command_args[] = { ALT_COMMAND_ARGS, NULL };\n\tif (argc <= 1)\n\t  {\n\t    execvp (COMMAND, command_args);\n\t    execvp (ALT_COMMAND, alt_command_args);\n\t  }\n\telse\n\t  execvp (argv[arg_base], &argv[arg_base]);\n      }\n\n      /* should never be reached */\n      exit(1);\n    }\n\n  /* parent */\n  signal (SIGCHLD, sig_child);\n\n  /* Note that we only set termios settings for standard input;\n   * the master side of a pty is NOT a tty.\n   */\n  tcgetattr(STDIN_FILENO, &orig_term);\n\n  t = orig_term;\n  eof_char = t.c_cc[VEOF];\n  /*  add_special_char(t.c_cc[VEOF]);*/\n  add_special_char(t.c_cc[VINTR]);\n  add_special_char(t.c_cc[VQUIT]);\n  add_special_char(t.c_cc[VSUSP]);\n#if defined (VDISCARD)\n  add_special_char(t.c_cc[VDISCARD]);\n#endif\n\n  t.c_lflag &= ~(ICANON | ISIG | ECHO | ECHOCTL | ECHOE | \\\n\t\t ECHOK | ECHONL\n#if defined (ECHOKE)\n\t\t| ECHOKE\n#endif\n#if defined (ECHOPRT)\n\t\t| ECHOPRT\n#endif\n\t\t);\n  t.c_iflag &= ~ICRNL;\n  t.c_iflag |= IGNBRK;\n  t.c_cc[VMIN] = 1;\n  t.c_cc[VTIME] = 0;\n  tcsetattr(STDIN_FILENO, TCSANOW, &t);\n  in_from_inferior_fd = master;\n  out_to_inferior_fd = master;\n  rl_instream = fdopen (master, \"r\");\n  rl_getc_function = my_rl_getc;\n\n  rl_prep_term_function = null_prep_terminal; \n  rl_deprep_term_function = null_deprep_terminal;\n  rl_pre_input_hook = pre_input_change_mode;\n  rl_callback_handler_install (prompt, line_handler);\n\n  in_from_tty_fd = STDIN_FILENO;\n  FD_ZERO (&in_set);\n  maxfd = in_from_inferior_fd > in_from_tty_fd ? in_from_inferior_fd\n    : in_from_tty_fd;\n  for (;;)\n    {\n      int num;\n      FD_SET (in_from_inferior_fd, &in_set);\n      FD_SET (in_from_tty_fd, &in_set);\n\n      num = select(maxfd+1, &in_set, NULL, NULL, NULL);\n\n      if (propagate_sigwinch)\n\t{\n\t  struct winsize ws;\n\t  if (ioctl (STDIN_FILENO, TIOCGWINSZ, &ws) >= 0)\n\t    {\n\t      ioctl (master, TIOCSWINSZ, &ws);\n\t    }\n\t  propagate_sigwinch = 0;\n\t  continue;\n\t}\n\n      if (num <= 0)\n\t{\n\t  perror (\"select\");\n\t  exit (-1);\n\t}\n      if (FD_ISSET (in_from_tty_fd, &in_set))\n\t{\n\t  extern int _rl_echoing_p;\n\t  struct termios term_master;\n\t  int do_canon = 1;\n\t  int do_icrnl = 1;\n\t  int ioctl_ret;\n\n\t  DPRINT1(\"[tty avail num_keys:%d]\\n\", num_keys);\n\n\t  /* If we can't get tty modes for the master side of the pty, we\n\t     can't handle non-canonical-mode programs.  Always assume the\n\t     master is in canonical echo mode if we can't tell. */\n\t  ioctl_ret = tcgetattr(master, &term_master);\n\n\t  if (ioctl_ret >= 0)\n\t    {\n\t      do_canon = (term_master.c_lflag & ICANON) != 0;\n\t      do_icrnl = (term_master.c_lflag & ICRNL) != 0;\n\t      _rl_echoing_p = (term_master.c_lflag & ECHO) != 0;\n\t      DPRINT1 (\"echo,canon,crnl:%03d\\n\",\n\t\t       100 * _rl_echoing_p\n\t\t       + 10 * do_canon\n\t\t       + 1 * do_icrnl);\n\t    }\n\t  else\n\t    {\n\t      if (ioctl_err == 0)\n\t\tDPRINT1(\"tcgetattr on master fd failed: errno = %d\\n\", errno);\n\t      ioctl_err = 1;\n\t    }\n\n\t  if (do_canon == 0 && num_keys == 0)\n\t    {\n\t      char ch[10];\n\t      int count = read (STDIN_FILENO, ch, sizeof(ch));\n\t      DPRINT1(\"[read %d chars from stdin: \", count);\n\t      DPRINT2(\" \\\"%.*s\\\"]\\n\", count, ch);\n\t      if (do_icrnl)\n\t\t{\n\t\t  int i = count;\n\t\t  while (--i >= 0)\n\t\t    {\n\t\t      if (ch[i] == '\\r')\n\t\t\tch[i] = '\\n';\n\t\t    }\n\t\t}\n\t      maybe_emphasize_input (1);\n\t      write (out_to_inferior_fd, ch, count);\n\t    }\n\t  else\n\t    {\n\t      if (num_keys == 0)\n\t\t{\n\t\t  int i;\n\t\t  /* Re-install callback handler for new prompt. */\n\t\t  if (prompt != empty_string)\n\t\t    free (prompt);\n\t\t  if (prompt == NULL)\n\t\t    {\n\t\t      DPRINT0(\"New empty prompt\\n\");\n\t\t      prompt = empty_string;\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      if (do_emphasize_input && buf_count > 0)\n\t\t\t{\n\t\t\t  prompt = malloc (buf_count + strlen (end_input_mode)\n\t\t\t\t\t   + strlen (start_input_mode) + 5);\n\t\t\t  sprintf (prompt, \"\\001%s\\002%.*s\\001%s\\002\",\n\t\t\t\t   end_input_mode,\n\t\t\t\t   buf_count, buf,\n\t\t\t\t   start_input_mode);\n\t\t\t}\n\t\t      else\n\t\t\t{\n\t\t\t  prompt = malloc (buf_count + 1);\n\t\t\t  memcpy (prompt, buf, buf_count);\n\t\t\t  prompt[buf_count] = '\\0';\n\t\t\t}\n\t\t      DPRINT1(\"New prompt '%s'\\n\", prompt);\n#if 0 /* ifdef HAVE_RL_ALREADY_PROMPTED */\n\t\t      /* Doesn't quite work when do_emphasize_input is 1. */\n\t\t      rl_already_prompted = buf_count > 0;\n#else\n\t\t      if (buf_count > 0)\n\t\t\twrite (1, \"\\r\", 1);\n#endif\n\t\t    }\n\n\t\t  rl_callback_handler_install (prompt, line_handler);\n\t\t}\n\t      num_keys++;\n\t      maybe_emphasize_input (1);\n\t      rl_callback_read_char ();\n\t    }\n\t}\n      else /* output from inferior. */\n\t{\n\t  int i;\n\t  int count;\n\t  int old_count;\n\t  if (buf_count > (sizeof(buf) >> 2))\n\t    buf_count = 0;\n\t  count = read (in_from_inferior_fd, buf+buf_count,\n\t\t\tsizeof(buf) - buf_count);\n          DPRINT2(\"read %d from inferior, buf_count=%d\", count, buf_count);\n\t  DPRINT2(\": \\\"%.*s\\\"\", count, buf+buf_count);\n\t  maybe_emphasize_input (0);\n\t  if (count <= 0)\n\t    {\n\t      DPRINT0 (\"(Connection closed by foreign host.)\\n\");\n\t      tcsetattr(STDIN_FILENO, TCSANOW, &orig_term);\n\t      exit (0);\n\t    }\n\t  old_count = buf_count;\n\n          /* Look for any pending echo that we need to suppress. */\n\t  while (echo_suppress_start < echo_suppress_limit\n\t\t && count > 0\n\t\t && buf[buf_count] == echo_suppress_buffer[echo_suppress_start])\n\t    {\n\t      count--;\n\t      buf_count++;\n\t      echo_suppress_start++;\n\t    }\n\t  DPRINT1(\"suppressed %d characters of echo.\\n\", buf_count-old_count);\n\n          /* Write to the terminal anything that was not suppressed. */\n          if (count > 0)\n            write (1, buf + buf_count, count);\n\n          /* Finally, look for a prompt candidate.\n           * When we get around to going input (from the keyboard),\n           * we will consider the prompt to be anything since the last\n           * line terminator.  So we need to save that text in the\n           * initial part of buf.  However, anything before the\n           * most recent end-of-line is not interesting. */\n\t  buf_count += count;\n#if 1\n\t  for (i = buf_count;  --i >= old_count; )\n#else\n\t  for (i = buf_count - 1;  i-- >= buf_count - count; )\n#endif\n\t    {\n\t      if (buf[i] == '\\n' || buf[i] == '\\r')\n\t\t{\n\t\t  i++;\n\t\t  memmove (buf, buf+i, buf_count - i);\n\t\t  buf_count -= i;\n\t\t  break;\n\t\t}\n\t    }\n\t  DPRINT2(\"-> i: %d, buf_count: %d\\n\", i, buf_count);\n\t}\n    }\n}",
      "lines": 384,
      "depth": 24,
      "decorators": [
        "int"
      ]
    },
    "set_edit_mode": {
      "start_point": [
        758,
        0
      ],
      "end_point": [
        784,
        1
      ],
      "content": "static void set_edit_mode ()\n{\n  int vi = 0;\n  char *shellopts;\n\n  shellopts = getenv (\"SHELLOPTS\");\n  while (shellopts != 0)\n    {\n      if (strncmp (\"vi\", shellopts, 2) == 0)\n\t{\n\t  vi = 1;\n\t  break;\n\t}\n      shellopts = strchr (shellopts + 1, ':');\n    }\n\n  if (!vi)\n    {\n      if (getenv (\"EDITOR\") != 0)\n\tvi |= strcmp (getenv (\"EDITOR\"), \"vi\") == 0;\n    }\n\n  if (vi)\n    rl_variable_bind (\"editing-mode\", \"vi\");\n  else\n    rl_variable_bind (\"editing-mode\", \"emacs\");\n}",
      "lines": 27,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "usage_exit": {
      "start_point": [
        787,
        0
      ],
      "end_point": [
        791,
        1
      ],
      "content": "static void usage_exit ()\n{\n  fprintf (stderr, \"Usage: rlfe [-h histfile] [-s size] cmd [arg1] [arg2] ...\\n\\n\");\n  exit (1);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "readline/readline-7.0/examples/rlfe/screen.h": {},
  "readline/readline-7.0/support/wcwidth.c": {
    "bisearch": {
      "start_point": [
        73,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "static int bisearch(wchar_t ucs, const struct interval *table, int max) {\n  int min = 0;\n  int mid;\n\n  if (ucs < table[0].first || ucs > table[max].last)\n    return 0;\n  while (max >= min) {\n    mid = (min + max) / 2;\n    if (ucs > table[mid].last)\n      min = mid + 1;\n    else if (ucs < table[mid].first)\n      max = mid - 1;\n    else\n      return 1;\n  }\n\n  return 0;\n}",
      "lines": 18,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "mk_wcwidth": {
      "start_point": [
        125,
        0
      ],
      "end_point": [
        207,
        1
      ],
      "content": "int mk_wcwidth(wchar_t ucs)\n{\n  /* sorted list of non-overlapping intervals of non-spacing characters */\n  /* generated by \"uniset +cat=Me +cat=Mn +cat=Cf -00AD +1160-11FF +200B c\" */\n  static const struct interval combining[] = {\n    { 0x0300, 0x036F }, { 0x0483, 0x0486 }, { 0x0488, 0x0489 },\n    { 0x0591, 0x05BD }, { 0x05BF, 0x05BF }, { 0x05C1, 0x05C2 },\n    { 0x05C4, 0x05C5 }, { 0x05C7, 0x05C7 }, { 0x0600, 0x0603 },\n    { 0x0610, 0x0615 }, { 0x064B, 0x065E }, { 0x0670, 0x0670 },\n    { 0x06D6, 0x06E4 }, { 0x06E7, 0x06E8 }, { 0x06EA, 0x06ED },\n    { 0x070F, 0x070F }, { 0x0711, 0x0711 }, { 0x0730, 0x074A },\n    { 0x07A6, 0x07B0 }, { 0x07EB, 0x07F3 }, { 0x0901, 0x0902 },\n    { 0x093C, 0x093C }, { 0x0941, 0x0948 }, { 0x094D, 0x094D },\n    { 0x0951, 0x0954 }, { 0x0962, 0x0963 }, { 0x0981, 0x0981 },\n    { 0x09BC, 0x09BC }, { 0x09C1, 0x09C4 }, { 0x09CD, 0x09CD },\n    { 0x09E2, 0x09E3 }, { 0x0A01, 0x0A02 }, { 0x0A3C, 0x0A3C },\n    { 0x0A41, 0x0A42 }, { 0x0A47, 0x0A48 }, { 0x0A4B, 0x0A4D },\n    { 0x0A70, 0x0A71 }, { 0x0A81, 0x0A82 }, { 0x0ABC, 0x0ABC },\n    { 0x0AC1, 0x0AC5 }, { 0x0AC7, 0x0AC8 }, { 0x0ACD, 0x0ACD },\n    { 0x0AE2, 0x0AE3 }, { 0x0B01, 0x0B01 }, { 0x0B3C, 0x0B3C },\n    { 0x0B3F, 0x0B3F }, { 0x0B41, 0x0B43 }, { 0x0B4D, 0x0B4D },\n    { 0x0B56, 0x0B56 }, { 0x0B82, 0x0B82 }, { 0x0BC0, 0x0BC0 },\n    { 0x0BCD, 0x0BCD }, { 0x0C3E, 0x0C40 }, { 0x0C46, 0x0C48 },\n    { 0x0C4A, 0x0C4D }, { 0x0C55, 0x0C56 }, { 0x0CBC, 0x0CBC },\n    { 0x0CBF, 0x0CBF }, { 0x0CC6, 0x0CC6 }, { 0x0CCC, 0x0CCD },\n    { 0x0CE2, 0x0CE3 }, { 0x0D41, 0x0D43 }, { 0x0D4D, 0x0D4D },\n    { 0x0DCA, 0x0DCA }, { 0x0DD2, 0x0DD4 }, { 0x0DD6, 0x0DD6 },\n    { 0x0E31, 0x0E31 }, { 0x0E34, 0x0E3A }, { 0x0E47, 0x0E4E },\n    { 0x0EB1, 0x0EB1 }, { 0x0EB4, 0x0EB9 }, { 0x0EBB, 0x0EBC },\n    { 0x0EC8, 0x0ECD }, { 0x0F18, 0x0F19 }, { 0x0F35, 0x0F35 },\n    { 0x0F37, 0x0F37 }, { 0x0F39, 0x0F39 }, { 0x0F71, 0x0F7E },\n    { 0x0F80, 0x0F84 }, { 0x0F86, 0x0F87 }, { 0x0F90, 0x0F97 },\n    { 0x0F99, 0x0FBC }, { 0x0FC6, 0x0FC6 }, { 0x102D, 0x1030 },\n    { 0x1032, 0x1032 }, { 0x1036, 0x1037 }, { 0x1039, 0x1039 },\n    { 0x1058, 0x1059 }, { 0x1160, 0x11FF }, { 0x135F, 0x135F },\n    { 0x1712, 0x1714 }, { 0x1732, 0x1734 }, { 0x1752, 0x1753 },\n    { 0x1772, 0x1773 }, { 0x17B4, 0x17B5 }, { 0x17B7, 0x17BD },\n    { 0x17C6, 0x17C6 }, { 0x17C9, 0x17D3 }, { 0x17DD, 0x17DD },\n    { 0x180B, 0x180D }, { 0x18A9, 0x18A9 }, { 0x1920, 0x1922 },\n    { 0x1927, 0x1928 }, { 0x1932, 0x1932 }, { 0x1939, 0x193B },\n    { 0x1A17, 0x1A18 }, { 0x1B00, 0x1B03 }, { 0x1B34, 0x1B34 },\n    { 0x1B36, 0x1B3A }, { 0x1B3C, 0x1B3C }, { 0x1B42, 0x1B42 },\n    { 0x1B6B, 0x1B73 }, { 0x1DC0, 0x1DCA }, { 0x1DFE, 0x1DFF },\n    { 0x200B, 0x200F }, { 0x202A, 0x202E }, { 0x2060, 0x2063 },\n    { 0x206A, 0x206F }, { 0x20D0, 0x20EF }, { 0x302A, 0x302F },\n    { 0x3099, 0x309A }, { 0xA806, 0xA806 }, { 0xA80B, 0xA80B },\n    { 0xA825, 0xA826 }, { 0xFB1E, 0xFB1E }, { 0xFE00, 0xFE0F },\n    { 0xFE20, 0xFE23 }, { 0xFEFF, 0xFEFF }, { 0xFFF9, 0xFFFB },\n    { 0x10A01, 0x10A03 }, { 0x10A05, 0x10A06 }, { 0x10A0C, 0x10A0F },\n    { 0x10A38, 0x10A3A }, { 0x10A3F, 0x10A3F }, { 0x1D167, 0x1D169 },\n    { 0x1D173, 0x1D182 }, { 0x1D185, 0x1D18B }, { 0x1D1AA, 0x1D1AD },\n    { 0x1D242, 0x1D244 }, { 0xE0001, 0xE0001 }, { 0xE0020, 0xE007F },\n    { 0xE0100, 0xE01EF }\n  };\n\n  /* test for 8-bit control characters */\n  if (ucs == 0)\n    return 0;\n  if (ucs < 32 || (ucs >= 0x7f && ucs < 0xa0))\n    return -1;\n\n  /* binary search in table of non-spacing characters */\n  if (bisearch(ucs, combining,\n\t       sizeof(combining) / sizeof(struct interval) - 1))\n    return 0;\n\n  /* if we arrive here, ucs is not a combining or C0/C1 control character */\n\n  return 1 + \n    (ucs >= 0x1100 &&\n     (ucs <= 0x115f ||                    /* Hangul Jamo init. consonants */\n      ucs == 0x2329 || ucs == 0x232a ||\n      (ucs >= 0x2e80 && ucs <= 0xa4cf &&\n       ucs != 0x303f) ||                  /* CJK ... Yi */\n      (ucs >= 0xac00 && ucs <= 0xd7a3) || /* Hangul Syllables */\n      (ucs >= 0xf900 && ucs <= 0xfaff) || /* CJK Compatibility Ideographs */\n      (ucs >= 0xfe10 && ucs <= 0xfe19) || /* Vertical forms */\n      (ucs >= 0xfe30 && ucs <= 0xfe6f) || /* CJK Compatibility Forms */\n      (ucs >= 0xff00 && ucs <= 0xff60) || /* Fullwidth Forms */\n      (ucs >= 0xffe0 && ucs <= 0xffe6) ||\n      (ucs >= 0x20000 && ucs <= 0x2fffd) ||\n      (ucs >= 0x30000 && ucs <= 0x3fffd)));\n}",
      "lines": 83,
      "depth": 21,
      "decorators": [
        "int"
      ]
    },
    "mk_wcswidth": {
      "start_point": [
        210,
        0
      ],
      "end_point": [
        221,
        1
      ],
      "content": "int mk_wcswidth(const wchar_t *pwcs, size_t n)\n{\n  int w, width = 0;\n\n  for (;*pwcs && n-- > 0; pwcs++)\n    if ((w = mk_wcwidth(*pwcs)) < 0)\n      return -1;\n    else\n      width += w;\n\n  return width;\n}",
      "lines": 12,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "mk_wcwidth_cjk": {
      "start_point": [
        233,
        0
      ],
      "end_point": [
        298,
        1
      ],
      "content": "int mk_wcwidth_cjk(wchar_t ucs)\n{\n  /* sorted list of non-overlapping intervals of East Asian Ambiguous\n   * characters, generated by \"uniset +WIDTH-A -cat=Me -cat=Mn -cat=Cf c\" */\n  static const struct interval ambiguous[] = {\n    { 0x00A1, 0x00A1 }, { 0x00A4, 0x00A4 }, { 0x00A7, 0x00A8 },\n    { 0x00AA, 0x00AA }, { 0x00AE, 0x00AE }, { 0x00B0, 0x00B4 },\n    { 0x00B6, 0x00BA }, { 0x00BC, 0x00BF }, { 0x00C6, 0x00C6 },\n    { 0x00D0, 0x00D0 }, { 0x00D7, 0x00D8 }, { 0x00DE, 0x00E1 },\n    { 0x00E6, 0x00E6 }, { 0x00E8, 0x00EA }, { 0x00EC, 0x00ED },\n    { 0x00F0, 0x00F0 }, { 0x00F2, 0x00F3 }, { 0x00F7, 0x00FA },\n    { 0x00FC, 0x00FC }, { 0x00FE, 0x00FE }, { 0x0101, 0x0101 },\n    { 0x0111, 0x0111 }, { 0x0113, 0x0113 }, { 0x011B, 0x011B },\n    { 0x0126, 0x0127 }, { 0x012B, 0x012B }, { 0x0131, 0x0133 },\n    { 0x0138, 0x0138 }, { 0x013F, 0x0142 }, { 0x0144, 0x0144 },\n    { 0x0148, 0x014B }, { 0x014D, 0x014D }, { 0x0152, 0x0153 },\n    { 0x0166, 0x0167 }, { 0x016B, 0x016B }, { 0x01CE, 0x01CE },\n    { 0x01D0, 0x01D0 }, { 0x01D2, 0x01D2 }, { 0x01D4, 0x01D4 },\n    { 0x01D6, 0x01D6 }, { 0x01D8, 0x01D8 }, { 0x01DA, 0x01DA },\n    { 0x01DC, 0x01DC }, { 0x0251, 0x0251 }, { 0x0261, 0x0261 },\n    { 0x02C4, 0x02C4 }, { 0x02C7, 0x02C7 }, { 0x02C9, 0x02CB },\n    { 0x02CD, 0x02CD }, { 0x02D0, 0x02D0 }, { 0x02D8, 0x02DB },\n    { 0x02DD, 0x02DD }, { 0x02DF, 0x02DF }, { 0x0391, 0x03A1 },\n    { 0x03A3, 0x03A9 }, { 0x03B1, 0x03C1 }, { 0x03C3, 0x03C9 },\n    { 0x0401, 0x0401 }, { 0x0410, 0x044F }, { 0x0451, 0x0451 },\n    { 0x2010, 0x2010 }, { 0x2013, 0x2016 }, { 0x2018, 0x2019 },\n    { 0x201C, 0x201D }, { 0x2020, 0x2022 }, { 0x2024, 0x2027 },\n    { 0x2030, 0x2030 }, { 0x2032, 0x2033 }, { 0x2035, 0x2035 },\n    { 0x203B, 0x203B }, { 0x203E, 0x203E }, { 0x2074, 0x2074 },\n    { 0x207F, 0x207F }, { 0x2081, 0x2084 }, { 0x20AC, 0x20AC },\n    { 0x2103, 0x2103 }, { 0x2105, 0x2105 }, { 0x2109, 0x2109 },\n    { 0x2113, 0x2113 }, { 0x2116, 0x2116 }, { 0x2121, 0x2122 },\n    { 0x2126, 0x2126 }, { 0x212B, 0x212B }, { 0x2153, 0x2154 },\n    { 0x215B, 0x215E }, { 0x2160, 0x216B }, { 0x2170, 0x2179 },\n    { 0x2190, 0x2199 }, { 0x21B8, 0x21B9 }, { 0x21D2, 0x21D2 },\n    { 0x21D4, 0x21D4 }, { 0x21E7, 0x21E7 }, { 0x2200, 0x2200 },\n    { 0x2202, 0x2203 }, { 0x2207, 0x2208 }, { 0x220B, 0x220B },\n    { 0x220F, 0x220F }, { 0x2211, 0x2211 }, { 0x2215, 0x2215 },\n    { 0x221A, 0x221A }, { 0x221D, 0x2220 }, { 0x2223, 0x2223 },\n    { 0x2225, 0x2225 }, { 0x2227, 0x222C }, { 0x222E, 0x222E },\n    { 0x2234, 0x2237 }, { 0x223C, 0x223D }, { 0x2248, 0x2248 },\n    { 0x224C, 0x224C }, { 0x2252, 0x2252 }, { 0x2260, 0x2261 },\n    { 0x2264, 0x2267 }, { 0x226A, 0x226B }, { 0x226E, 0x226F },\n    { 0x2282, 0x2283 }, { 0x2286, 0x2287 }, { 0x2295, 0x2295 },\n    { 0x2299, 0x2299 }, { 0x22A5, 0x22A5 }, { 0x22BF, 0x22BF },\n    { 0x2312, 0x2312 }, { 0x2460, 0x24E9 }, { 0x24EB, 0x254B },\n    { 0x2550, 0x2573 }, { 0x2580, 0x258F }, { 0x2592, 0x2595 },\n    { 0x25A0, 0x25A1 }, { 0x25A3, 0x25A9 }, { 0x25B2, 0x25B3 },\n    { 0x25B6, 0x25B7 }, { 0x25BC, 0x25BD }, { 0x25C0, 0x25C1 },\n    { 0x25C6, 0x25C8 }, { 0x25CB, 0x25CB }, { 0x25CE, 0x25D1 },\n    { 0x25E2, 0x25E5 }, { 0x25EF, 0x25EF }, { 0x2605, 0x2606 },\n    { 0x2609, 0x2609 }, { 0x260E, 0x260F }, { 0x2614, 0x2615 },\n    { 0x261C, 0x261C }, { 0x261E, 0x261E }, { 0x2640, 0x2640 },\n    { 0x2642, 0x2642 }, { 0x2660, 0x2661 }, { 0x2663, 0x2665 },\n    { 0x2667, 0x266A }, { 0x266C, 0x266D }, { 0x266F, 0x266F },\n    { 0x273D, 0x273D }, { 0x2776, 0x277F }, { 0xE000, 0xF8FF },\n    { 0xFFFD, 0xFFFD }, { 0xF0000, 0xFFFFD }, { 0x100000, 0x10FFFD }\n  };\n\n  /* binary search in table of non-spacing characters */\n  if (bisearch(ucs, ambiguous,\n\t       sizeof(ambiguous) / sizeof(struct interval) - 1))\n    return 2;\n\n  return mk_wcwidth(ucs);\n}",
      "lines": 66,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "mk_wcswidth_cjk": {
      "start_point": [
        301,
        0
      ],
      "end_point": [
        312,
        1
      ],
      "content": "int mk_wcswidth_cjk(const wchar_t *pwcs, size_t n)\n{\n  int w, width = 0;\n\n  for (;*pwcs && n-- > 0; pwcs++)\n    if ((w = mk_wcwidth_cjk(*pwcs)) < 0)\n      return -1;\n    else\n      width += w;\n\n  return width;\n}",
      "lines": 12,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  }
}