{
  "findutils/findutils-4.6.0/build-aux/snippet/arg-nonnull.h": {},
  "findutils/findutils-4.6.0/build-aux/snippet/c++defs.h": {},
  "findutils/findutils-4.6.0/build-aux/snippet/unused-parameter.h": {},
  "findutils/findutils-4.6.0/build-aux/snippet/warn-on-use.h": {},
  "findutils/findutils-4.6.0/build-aux/snippet/_Noreturn.h": {},
  "findutils/findutils-4.6.0/find/defs.h": {},
  "findutils/findutils-4.6.0/find/exec.c": {
    "initialize_wd_for_exec": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "static bool\ninitialize_wd_for_exec (struct exec_val *execp, int cwd_fd, const char *dir)\n{\n  execp->wd_for_exec = xmalloc (sizeof (*execp->wd_for_exec));\n  execp->wd_for_exec->name = NULL;\n  execp->wd_for_exec->desc = openat (cwd_fd, dir, O_RDONLY);\n  if (execp->wd_for_exec->desc < 0)\n    return false;\n  set_cloexec_flag (execp->wd_for_exec->desc, true);\n  return true;\n}",
      "lines": 11,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "record_exec_dir": {
      "start_point": [
        75,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "static bool\nrecord_exec_dir (struct exec_val *execp)\n{\n  if (!execp->state.todo)\n    {\n      /* working directory not already known, so must be a *dir variant,\n\t and this must be the first arg we added.   However, this may\n\t be -execdir foo {} \\; (i.e. not multiple).  */\n      assert (!execp->state.todo);\n\n      /* Record the WD. If we're using -L or fts chooses to do so for\n\t any other reason, state.cwd_dir_fd may in fact not be the\n\t directory containing the target file.  When this happens,\n\t rel_path will contain directory components (since it is the\n\t path from state.cwd_dir_fd to the target file).\n\n\t We deal with this by extracting any directory part and using\n\t that to adjust what goes into execp->wd_for_exec.\n      */\n      if (strchr (state.rel_pathname, '/'))\n\t{\n\t  char *dir = mdir_name (state.rel_pathname);\n\t  bool result = initialize_wd_for_exec (execp, state.cwd_dir_fd, dir);\n\t  free (dir);\n\t  return result;\n\t}\n      else\n\t{\n\t  return initialize_wd_for_exec (execp, state.cwd_dir_fd, \".\");\n\t}\n    }\n  return true;\n}",
      "lines": 33,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "impl_pred_exec": {
      "start_point": [
        112,
        0
      ],
      "end_point": [
        224,
        1
      ],
      "content": "bool\nimpl_pred_exec (const char *pathname,\n                struct stat *stat_buf,\n                struct predicate *pred_ptr)\n{\n  struct exec_val *execp = &pred_ptr->args.exec_vec;\n  char *buf = NULL;\n  const char *target;\n  bool result;\n  const bool local = is_exec_in_local_dir (pred_ptr->pred_func);\n  char *prefix;\n  size_t pfxlen;\n\n  (void) stat_buf;\n  if (local)\n    {\n      /* For -execdir/-okdir predicates, the parser did not fill in\n         the wd_for_exec member of struct exec_val.  So for those\n         predicates, we do so now.\n      */\n      if (!record_exec_dir (execp))\n        {\n          error (EXIT_FAILURE, errno,\n                 _(\"Failed to save working directory in order to \"\n                   \"run a command on %s\"),\n                 safely_quote_err_filename (0, pathname));\n          /*NOTREACHED*/\n        }\n      target = buf = base_name (state.rel_pathname);\n      if ('/' == target[0])\n        {\n          /* find / execdir ls -d {} \\; */\n          prefix = NULL;\n          pfxlen = 0;\n        }\n      else\n        {\n          prefix = \"./\";\n          pfxlen = 2u;\n        }\n    }\n  else\n    {\n      /* For the others (-exec, -ok), the parser should\n         have set wd_for_exec to initial_wd, indicating\n         that the exec should take place from find's initial\n         working directory.\n      */\n      assert (execp->wd_for_exec == initial_wd);\n      target = pathname;\n      prefix = NULL;\n      pfxlen = 0u;\n    }\n\n  if (execp->multiple)\n    {\n      /* Push the argument onto the current list.\n       * The command may or may not be run at this point,\n       * depending on the command line length limits.\n       */\n      bc_push_arg (&execp->ctl,\n                   &execp->state,\n                   target, strlen (target)+1,\n                   prefix, pfxlen,\n                   0);\n\n      /* remember that there are pending execdirs. */\n      if (execp->state.todo)\n        state.execdirs_outstanding = true;\n\n      /* POSIX: If the primary expression is punctuated by a plus\n       * sign, the primary shall always evaluate as true\n       */\n      result = true;\n    }\n  else\n    {\n      int i;\n\n      for (i=0; i<execp->num_args; ++i)\n        {\n          bc_do_insert (&execp->ctl,\n                        &execp->state,\n                        execp->replace_vec[i],\n                        strlen (execp->replace_vec[i]),\n                        prefix, pfxlen,\n                        target, strlen (target),\n                        0);\n        }\n\n      /* Actually invoke the command. */\n      bc_do_exec (&execp->ctl, &execp->state);\n      if (WIFEXITED(execp->last_child_status))\n        {\n          if (0 == WEXITSTATUS(execp->last_child_status))\n            result = true;        /* The child succeeded. */\n          else\n            result = false;\n        }\n      else\n        {\n          result = false;\n        }\n      if (local)\n        free_cwd (execp->wd_for_exec);\n    }\n  if (buf)\n    {\n      assert (local);\n      free (buf);\n    }\n  return result;\n}",
      "lines": 113,
      "depth": 14,
      "decorators": [
        "bool"
      ]
    },
    "prep_child_for_exec": {
      "start_point": [
        245,
        0
      ],
      "end_point": [
        290,
        1
      ],
      "content": "static bool\nprep_child_for_exec (bool close_stdin, const struct saved_cwd *wd)\n{\n  bool ok = true;\n  if (close_stdin)\n    {\n      const char inputfile[] = \"/dev/null\";\n\n      if (close (0) < 0)\n\t{\n\t  error (0, errno, _(\"Cannot close standard input\"));\n\t  ok = false;\n\t}\n      else\n\t{\n\t  if (open (inputfile, O_RDONLY\n#if defined O_LARGEFILE\n\t\t   |O_LARGEFILE\n#endif\n\t\t   ) < 0)\n\t    {\n\t      /* This is not entirely fatal, since\n\t       * executing the child with a closed\n\t       * stdin is almost as good as executing it\n\t       * with its stdin attached to /dev/null.\n\t       */\n\t      error (0, errno, \"%s\", safely_quote_err_filename (0, inputfile));\n\t      /* do not set ok=false, it is OK to continue anyway. */\n\t    }\n\t}\n    }\n\n  /* Even if DebugSearch is set, don't announce our change of\n   * directory, since we're not going to emit a subsequent\n   * announcement of a call to stat() anyway, as we're about to exec\n   * something.\n   */\n  if (0 != restore_cwd (wd))\n    {\n      error (0, errno, _(\"Failed to change directory%s%s\"),\n\t     (wd->desc < 0 && wd->name) ? \": \" : \"\",\n\t     (wd->desc < 0 && wd->name) ? wd->name : \"\");\n      ok = false;\n    }\n  return ok;\n}",
      "lines": 46,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "launch": {
      "start_point": [
        293,
        0
      ],
      "end_point": [
        389,
        1
      ],
      "content": "int\nlaunch (struct buildcmd_control *ctl, void *usercontext, int argc, char **argv)\n{\n  pid_t child_pid;\n  static int first_time = 1;\n  struct exec_val *execp = usercontext;\n\n  /* Make sure output of command doesn't get mixed with find output. */\n  fflush (stdout);\n  fflush (stderr);\n\n  /* Make sure to listen for the kids.  */\n  if (first_time)\n    {\n      first_time = 0;\n      signal (SIGCHLD, SIG_DFL);\n    }\n\n  child_pid = fork ();\n  if (child_pid == -1)\n    error (EXIT_FAILURE, errno, _(\"cannot fork\"));\n  if (child_pid == 0)\n    {\n      /* We are the child. */\n      assert (NULL != execp->wd_for_exec);\n      if (!prep_child_for_exec (execp->close_stdin, execp->wd_for_exec))\n\t{\n\t  _exit (1);\n\t}\n      else\n\t{\n\t  if (fd_leak_check_is_enabled ())\n\t    {\n\t      complain_about_leaky_fds ();\n\t    }\n\t}\n\n      if (bc_args_exceed_testing_limit (argv))\n\terrno = E2BIG;\n      else\n\texecvp (argv[0], argv);\n      /* TODO: use a pipe to pass back the errno value, like xargs does */\n      error (0, errno, \"%s\",\n\t     safely_quote_err_filename (0, argv[0]));\n      _exit (1);\n    }\n\n  while (waitpid (child_pid, &(execp->last_child_status), 0) == (pid_t) -1)\n    {\n      if (errno != EINTR)\n\t{\n\t  error (0, errno, _(\"error waiting for %s\"),\n\t\t safely_quote_err_filename (0, argv[0]));\n\t  state.exit_status = 1;\n\t  return 0;\t\t/* FAIL */\n\t}\n    }\n\n  if (WIFSIGNALED (execp->last_child_status))\n    {\n      error (0, 0, _(\"%s terminated by signal %d\"),\n\t     quotearg_n_style (0, options.err_quoting_style, argv[0]),\n\t     WTERMSIG (execp->last_child_status));\n\n      if (execp->multiple)\n\t{\n\t  /* -exec   \\; just returns false if the invoked command fails.\n\t   * -exec {} + returns true if the invoked command fails, but\n\t   *            sets the program exit status.\n\t   */\n\t  state.exit_status = 1;\n\t}\n\n      return 1;\t\t\t/* OK */\n    }\n\n  if (0 == WEXITSTATUS (execp->last_child_status))\n    {\n      return 1;\t\t\t/* OK */\n    }\n  else\n    {\n      if (execp->multiple)\n\t{\n\t  /* -exec   \\; just returns false if the invoked command fails.\n\t   * -exec {} + returns true if the invoked command fails, but\n\t   *            sets the program exit status.\n\t   */\n\t  state.exit_status = 1;\n\t}\n      /* The child failed, but this is the exec callback.  We\n       * don't want to run the child again in this case anwyay.\n       */\n      return 1;\t\t\t/* FAIL (but don't try again) */\n    }\n\n}",
      "lines": 97,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/find/finddata.c": {},
  "findutils/findutils-4.6.0/find/fstype.c": {
    "free_file_system_list": {
      "start_point": [
        77,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "static void\nfree_file_system_list (struct mount_entry *p)\n{\n  while (p)\n    {\n      struct mount_entry *pnext = p->me_next;\n\n      free (p->me_devname);\n      free (p->me_mountdir);\n\n      if (p->me_type_malloced)\n\tfree (p->me_type);\n      p->me_next = NULL;\n      free (p);\n      p = pnext;\n    }\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "in_afs": {
      "start_point": [
        111,
        0
      ],
      "end_point": [
        125,
        1
      ],
      "content": "static int\nin_afs (char *path)\n{\n  static char space[2048];\n  struct ViceIoctl vi;\n\n  vi.in_size = 0;\n  vi.out_size = sizeof (space);\n  vi.out = space;\n\n  if (pioctl (path, VIOC_FILE_CELL_NAME, &vi, 1)\n      && (errno == EINVAL || errno == ENOENT))\n\treturn 0;\n  return 1;\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "filesystem_type": {
      "start_point": [
        136,
        0
      ],
      "end_point": [
        151,
        1
      ],
      "content": "char *\nfilesystem_type (const struct stat *statp, const char *path)\n{\n  static char *current_fstype = NULL;\n  static dev_t current_dev;\n\n  if (current_fstype != NULL)\n    {\n      if (fstype_known && statp->st_dev == current_dev)\n\treturn current_fstype;\t/* Cached value.  */\n      free (current_fstype);\n    }\n  current_dev = statp->st_dev;\n  current_fstype = file_system_type_uncached (statp, path);\n  return current_fstype;\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "char",
        "*\nfilesystem_type (const struct stat *statp, const char *path)",
        "*"
      ]
    },
    "set_fstype_devno": {
      "start_point": [
        153,
        0
      ],
      "end_point": [
        172,
        1
      ],
      "content": "static int\nset_fstype_devno (struct mount_entry *p)\n{\n  struct stat stbuf;\n\n  if (p->me_dev == (dev_t)-1)\n    {\n      set_stat_placeholders (&stbuf);\n      if (0 == (options.xstat)(p->me_mountdir, &stbuf))\n\t{\n\t  p->me_dev = stbuf.st_dev;\n\t  return 0;\n\t}\n      else\n\t{\n\t  return -1;\n\t}\n    }\n  return 0;\t\t\t/* not needed */\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "must_read_fs_list": {
      "start_point": [
        174,
        0
      ],
      "end_point": [
        187,
        1
      ],
      "content": "static struct mount_entry *\nmust_read_fs_list (bool need_fs_type)\n{\n  struct mount_entry *entries = read_file_system_list (need_fs_type);\n  if (NULL == entries)\n    {\n      /* We cannot determine for sure which file we were trying to\n       * use because gnulib has abstracted all that stuff away.\n       * Hence we cannot issue a specific error message here.\n       */\n      error (EXIT_FAILURE, 0, _(\"Cannot read mounted file system list\"));\n    }\n  return entries;\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "struct mount_entry",
        "struct",
        "mount_entry",
        "*\nmust_read_fs_list (bool need_fs_type)",
        "*"
      ]
    },
    "file_system_type_uncached": {
      "start_point": [
        196,
        0
      ],
      "end_point": [
        244,
        1
      ],
      "content": "static char *\nfile_system_type_uncached (const struct stat *statp, const char *path)\n{\n  struct mount_entry *entries, *entry, *best;\n  char *type;\n\n  (void) path;\n\n#ifdef AFS\n  if (in_afs (path))\n    {\n      fstype_known = 1;\n      return xstrdup (\"afs\");\n    }\n#endif\n\n  best = NULL;\n  entries = must_read_fs_list (true);\n  for (type=NULL, entry=entries; entry; entry=entry->me_next)\n    {\n#ifdef MNTTYPE_IGNORE\n      if (!strcmp (entry->me_type, MNTTYPE_IGNORE))\n\tcontinue;\n#endif\n      if (0 == set_fstype_devno (entry))\n\t{\n\t  if (entry->me_dev == statp->st_dev)\n\t    {\n\t      best = entry;\n\t      /* Don't exit the loop, because some systems (for\n\t\t example Linux-based systems in which /etc/mtab is a\n\t\t symlink to /proc/mounts) can have duplicate entries\n\t\t in the filesystem list.  This happens most frequently\n\t\t for /.\n\t      */\n\t    }\n\t}\n    }\n  if (best)\n    {\n      type = xstrdup (best->me_type);\n    }\n  free_file_system_list (entries);\n\n  /* Don't cache unknown values. */\n  fstype_known = (type != NULL);\n\n  return type ? type : xstrdup (_(\"unknown\"));\n}",
      "lines": 49,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nfile_system_type_uncached (const struct stat *statp, const char *path)",
        "*"
      ]
    },
    "get_mounted_filesystems": {
      "start_point": [
        247,
        0
      ],
      "end_point": [
        282,
        1
      ],
      "content": "char *\nget_mounted_filesystems (void)\n{\n  char *result = NULL;\n  size_t alloc_size = 0u;\n  size_t used = 0u;\n  struct mount_entry *entries, *entry;\n  void *p;\n\n  entries = must_read_fs_list (false);\n  for (entry=entries; entry; entry=entry->me_next)\n    {\n      size_t len;\n\n#ifdef MNTTYPE_IGNORE\n      if (!strcmp (entry->me_type, MNTTYPE_IGNORE))\n\tcontinue;\n#endif\n\n      len = strlen (entry->me_mountdir) + 1;\n      p = extendbuf (result, used+len, &alloc_size);\n      if (p)\n\t{\n\t  result = p;\n\t  strcpy (&result[used], entry->me_mountdir);\n\t  used += len;\t\t/* len already includes one for the \\0 */\n\t}\n      else\n\t{\n\t  break;\n\t}\n    }\n\n  free_file_system_list (entries);\n  return result;\n}",
      "lines": 36,
      "depth": 12,
      "decorators": [
        "char",
        "*\nget_mounted_filesystems (void)",
        "*"
      ]
    },
    "get_mounted_devices": {
      "start_point": [
        285,
        0
      ],
      "end_point": [
        325,
        1
      ],
      "content": "dev_t *\nget_mounted_devices (size_t *n)\n{\n  size_t alloc_size = 0u;\n  size_t used = 0u;\n  struct mount_entry *entries, *entry;\n  dev_t *result = NULL;\n\n  /* Use read_file_system_list () rather than must_read_fs_list()\n   * because on some system this is always called at startup,\n   * and find should only exit fatally if it needs to use the\n   * result of this operation.   If we can't get the fs list\n   * but we never need the information, there is no need to fail.\n   */\n  for (entry = entries = read_file_system_list (false);\n       entry;\n       entry = entry->me_next)\n    {\n      void *p = extendbuf (result, sizeof(dev_t)*(used+1), &alloc_size);\n      if (p)\n\t{\n\t  result = p;\n\t  if (0 == set_fstype_devno (entry))\n\t    {\n\t      result[used] = entry->me_dev;\n\t      ++used;\n\t    }\n\t}\n      else\n\t{\n\t  free (result);\n\t  result = NULL;\n\t}\n    }\n  free_file_system_list (entries);\n  if (result)\n    {\n      *n = used;\n    }\n  return result;\n}",
      "lines": 41,
      "depth": 13,
      "decorators": [
        "dev_t",
        "*\nget_mounted_devices (size_t *n)",
        "*"
      ]
    }
  },
  "findutils/findutils-4.6.0/find/ftsfind.c": {
    "left_dir": {
      "start_point": [
        92,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "static void\nleft_dir (void)\n{\n  if (ftsoptions & FTS_CWDFD)\n    {\n      if (curr_fd >= 0)\n\t{\n\t  close (curr_fd);\n\t  curr_fd = -1;\n\t}\n    }\n  else\n    {\n      /* do nothing. */\n    }\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "inside_dir": {
      "start_point": [
        114,
        0
      ],
      "end_point": [
        149,
        1
      ],
      "content": "static void\ninside_dir (int dir_fd)\n{\n  if (ftsoptions & FTS_CWDFD)\n    {\n      assert (dir_fd == AT_FDCWD || dir_fd >= 0);\n\n      state.cwd_dir_fd = dir_fd;\n      if (curr_fd < 0)\n\t{\n\t  if (AT_FDCWD == dir_fd)\n\t    {\n\t      curr_fd = AT_FDCWD;\n\t    }\n\t  else if (dir_fd >= 0)\n\t    {\n\t      curr_fd = dup_cloexec (dir_fd);\n\t    }\n\t  else\n\t    {\n\t      /* curr_fd is invalid, but dir_fd is also invalid.\n\t       * This should not have happened.\n\t       */\n\t      assert (curr_fd >= 0 || dir_fd >= 0);\n\t    }\n\t}\n    }\n  else\n    {\n      /* FTS_CWDFD is not in use.  We can always assume that\n       * AT_FDCWD refers to the directory we are currentl searching.\n       *\n       * Therefore there is nothing to do.\n       */\n    }\n}",
      "lines": 36,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "get_fts_info_name": {
      "start_point": [
        160,
        0
      ],
      "end_point": [
        184,
        1
      ],
      "content": "static char *\nget_fts_info_name (int info)\n{\n  static char buf[10];\n  switch (info)\n    {\n      HANDLECASE(FTS_D);\n      HANDLECASE(FTS_DC);\n      HANDLECASE(FTS_DEFAULT);\n      HANDLECASE(FTS_DNR);\n      HANDLECASE(FTS_DOT);\n      HANDLECASE(FTS_DP);\n      HANDLECASE(FTS_ERR);\n      HANDLECASE(FTS_F);\n      HANDLECASE(FTS_INIT);\n      HANDLECASE(FTS_NS);\n      HANDLECASE(FTS_NSOK);\n      HANDLECASE(FTS_SL);\n      HANDLECASE(FTS_SLNONE);\n      HANDLECASE(FTS_W);\n    default:\n      sprintf (buf, \"[%d]\", info);\n      return buf;\n    }\n}",
      "lines": 25,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nget_fts_info_name (int info)",
        "*"
      ]
    },
    "visit": {
      "start_point": [
        186,
        0
      ],
      "end_point": [
        204,
        1
      ],
      "content": "static void\nvisit (FTS *p, FTSENT *ent, struct stat *pstat)\n{\n  struct predicate *eval_tree;\n\n  state.have_stat = (ent->fts_info != FTS_NS) && (ent->fts_info != FTS_NSOK);\n  state.rel_pathname = ent->fts_accpath;\n  state.cwd_dir_fd   = p->fts_cwd_fd;\n\n  /* Apply the predicates to this path. */\n  eval_tree = get_eval_tree ();\n  apply_predicate (ent->fts_path, pstat, eval_tree);\n\n  /* Deal with any side effects of applying the predicates. */\n  if (state.stop_at_current_level)\n    {\n      fts_set (p, ent, FTS_SKIP);\n    }\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "partial_quotearg_n": {
      "start_point": [
        206,
        0
      ],
      "end_point": [
        224,
        1
      ],
      "content": "static const char*\npartial_quotearg_n (int n, char *s, size_t len, enum quoting_style style)\n{\n  if (0 == len)\n    {\n      return quotearg_n_style (n, style, \"\");\n    }\n  else\n    {\n      char saved;\n      const char *result;\n\n      saved = s[len];\n      s[len] = 0;\n      result = quotearg_n_style (n, style, s);\n      s[len] = saved;\n      return result;\n    }\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\npartial_quotearg_n (int n, char *s, size_t len, enum quoting_style style)",
        "*"
      ]
    },
    "issue_loop_warning": {
      "start_point": [
        238,
        0
      ],
      "end_point": [
        266,
        1
      ],
      "content": "static void\nissue_loop_warning (FTSENT * ent)\n{\n  if (S_ISLNK(ent->fts_statp->st_mode))\n    {\n      error (0, 0,\n\t     _(\"Symbolic link %s is part of a loop in the directory hierarchy; we have already visited the directory to which it points.\"),\n\t     safely_quote_err_filename (0, ent->fts_path));\n    }\n  else\n    {\n      /* We have found an infinite loop.  POSIX requires us to\n       * issue a diagnostic.  Usually we won't get to here\n       * because when the leaf optimisation is on, it will cause\n       * the subdirectory to be skipped.  If /a/b/c/d is a hard\n       * link to /a/b, then the link count of /a/b/c is 2,\n       * because the \"..\" entry of /a/b/c/d points to /a, not\n       * to /a/b/c.\n       */\n      error (0, 0,\n\t     _(\"File system loop detected; \"\n\t       \"%s is part of the same file system loop as %s.\"),\n\t     safely_quote_err_filename (0, ent->fts_path),\n\t     partial_quotearg_n (1,\n\t\t\t\t ent->fts_cycle->fts_path,\n\t\t\t\t ent->fts_cycle->fts_pathlen,\n\t\t\t\t options.err_quoting_style));\n    }\n}",
      "lines": 29,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "symlink_loop": {
      "start_point": [
        274,
        0
      ],
      "end_point": [
        280,
        1
      ],
      "content": "static bool\nsymlink_loop (const char *name)\n{\n  struct stat stbuf;\n  const int rv = options.xstat (name, &stbuf);\n  return (0 != rv) && (ELOOP == errno);\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "show_outstanding_execdirs": {
      "start_point": [
        283,
        0
      ],
      "end_point": [
        328,
        1
      ],
      "content": "static void\nshow_outstanding_execdirs (FILE *fp)\n{\n  if (options.debug_options & DebugExec)\n    {\n      int seen=0;\n      struct predicate *p;\n      p = get_eval_tree ();\n      fprintf (fp, \"Outstanding execdirs:\");\n\n      while (p)\n\t{\n\t  const char *pfx;\n\n\t  if (pred_is (p, pred_execdir))\n\t    pfx = \"-execdir\";\n\t  else if (pred_is (p, pred_okdir))\n\t    pfx = \"-okdir\";\n\t  else\n\t    pfx = NULL;\n\t  if (pfx)\n\t    {\n\t      size_t i;\n\t      const struct exec_val *execp = &p->args.exec_vec;\n\t      ++seen;\n\n\t      fprintf (fp, \"%s \", pfx);\n\t      if (execp->multiple)\n\t\tfprintf (fp, \"multiple \");\n\t      fprintf (fp, \"%\" PRIuMAX \" args: \", (uintmax_t) execp->state.cmd_argc);\n\t      for (i=0; i<execp->state.cmd_argc; ++i)\n\t\t{\n\t\t  fprintf (fp, \"%s \", execp->state.cmd_argv[i]);\n\t\t}\n\t      fprintf (fp, \"\\n\");\n\t    }\n\t  p = p->pred_next;\n\t}\n      if (!seen)\n\tfprintf (fp, \" none\\n\");\n    }\n  else\n    {\n      /* No debug output is wanted. */\n    }\n}",
      "lines": 46,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "consider_visiting": {
      "start_point": [
        330,
        0
      ],
      "end_point": [
        520,
        1
      ],
      "content": "static void\nconsider_visiting (FTS *p, FTSENT *ent)\n{\n  struct stat statbuf;\n  mode_t mode;\n  int ignore, isdir;\n\n  if (options.debug_options & DebugSearch)\n    fprintf (stderr,\n\t     \"consider_visiting (early): %s: \"\n\t     \"fts_info=%-6s, fts_level=%2d, prev_depth=%d \"\n\t     \"fts_path=%s, fts_accpath=%s\\n\",\n\t     quotearg_n_style (0, options.err_quoting_style, ent->fts_path),\n\t     get_fts_info_name (ent->fts_info),\n\t     (int)ent->fts_level, prev_depth,\n\t     quotearg_n_style (1, options.err_quoting_style, ent->fts_path),\n\t     quotearg_n_style (2, options.err_quoting_style, ent->fts_accpath));\n\n  if (ent->fts_info == FTS_DP)\n    {\n      left_dir ();\n    }\n  else if (ent->fts_level > prev_depth || ent->fts_level==0)\n    {\n      left_dir ();\n    }\n  inside_dir (p->fts_cwd_fd);\n  prev_depth = ent->fts_level;\n\n  statbuf.st_ino = ent->fts_statp->st_ino;\n\n  /* Cope with various error conditions. */\n  if (ent->fts_info == FTS_ERR\n      || ent->fts_info == FTS_DNR)\n    {\n      nonfatal_target_file_error (ent->fts_errno, ent->fts_path);\n      return;\n    }\n  else if (ent->fts_info == FTS_DC)\n    {\n      issue_loop_warning (ent);\n      error_severity (EXIT_FAILURE);\n      return;\n    }\n  else if (ent->fts_info == FTS_SLNONE)\n    {\n      /* fts_read() claims that ent->fts_accpath is a broken symbolic\n       * link.  That would be fine, but if this is part of a symbolic\n       * link loop, we diagnose the problem and also ensure that the\n       * eventual return value is nonzero.   Note that while the path\n       * we stat is local (fts_accpath), we print the full path name\n       * of the file (fts_path) in the error message.\n       */\n      if (symlink_loop (ent->fts_accpath))\n\t{\n\t  nonfatal_target_file_error (ELOOP, ent->fts_path);\n\t  return;\n\t}\n    }\n  else if (ent->fts_info == FTS_NS)\n    {\n      if (ent->fts_level == 0)\n\t{\n\t  /* e.g., nonexistent starting point */\n\t  nonfatal_target_file_error (ent->fts_errno, ent->fts_path);\n\t  return;\n\t}\n      else\n\t{\n\t  /* The following if statement fixes Savannah bug #19605\n\t   * (failure to diagnose a symbolic link loop)\n\t   */\n\t  if (symlink_loop (ent->fts_accpath))\n\t    {\n\t      nonfatal_target_file_error (ELOOP, ent->fts_path);\n\t      return;\n\t    }\n\t  else\n\t    {\n\t      nonfatal_target_file_error (ent->fts_errno, ent->fts_path);\n\t      /* Continue despite the error, as file name without stat info\n\t       * might be better than not even processing the file name. This\n\t       * can lead to repeated error messages later on, though, if a\n\t       * predicate requires stat information.\n\t       *\n\t       * Not printing an error message here would be even more wrong,\n\t       * though, as this could cause the contents of a directory to be\n\t       * silently ignored, as the directory wouldn't be identified as\n\t       * such.\n\t       */\n\t    }\n\n\t}\n    }\n\n  /* Cope with the usual cases. */\n  if (ent->fts_info == FTS_NSOK\n      || ent->fts_info == FTS_NS /* e.g. symlink loop */)\n    {\n      assert (!state.have_stat);\n      assert (ent->fts_info == FTS_NSOK || state.type == 0);\n      mode = state.type;\n    }\n  else\n    {\n      state.have_stat = true;\n      state.have_type = true;\n      statbuf = *(ent->fts_statp);\n      state.type = mode = statbuf.st_mode;\n\n      if (00000 == mode)\n\t{\n\t  /* Savannah bug #16378. */\n\t  error (0, 0, _(\"WARNING: file %s appears to have mode 0000\"),\n\t\t quotearg_n_style (0, options.err_quoting_style, ent->fts_path));\n\t}\n    }\n\n  /* update state.curdepth before calling digest_mode(), because digest_mode\n   * may call following_links().\n   */\n  state.curdepth = ent->fts_level;\n  if (mode)\n    {\n      if (!digest_mode (&mode, ent->fts_path, ent->fts_name, &statbuf, 0))\n\treturn;\n    }\n\n  /* examine this item. */\n  ignore = 0;\n  isdir = S_ISDIR(mode)\n    || (FTS_D  == ent->fts_info)\n    || (FTS_DP == ent->fts_info)\n    || (FTS_DC == ent->fts_info);\n\n  if (isdir && (ent->fts_info == FTS_NSOK))\n    {\n      /* This is a directory, but fts did not stat it, so\n       * presumably would not be planning to search its\n       * children.  Force a stat of the file so that the\n       * children can be checked.\n       */\n      fts_set (p, ent, FTS_AGAIN);\n      return;\n    }\n\n  if (options.maxdepth >= 0)\n    {\n      if (ent->fts_level >= options.maxdepth)\n\t{\n\t  fts_set (p, ent, FTS_SKIP); /* descend no further */\n\n\t  if (ent->fts_level > options.maxdepth)\n\t    ignore = 1;\t\t/* don't even look at this one */\n\t}\n    }\n\n  if ( (ent->fts_info == FTS_D) && !options.do_dir_first )\n    {\n      /* this is the preorder visit, but user said -depth */\n      ignore = 1;\n    }\n  else if ( (ent->fts_info == FTS_DP) && options.do_dir_first )\n    {\n      /* this is the postorder visit, but user didn't say -depth */\n      ignore = 1;\n    }\n  else if (ent->fts_level < options.mindepth)\n    {\n      ignore = 1;\n    }\n\n  if (options.debug_options & DebugSearch)\n    fprintf (stderr,\n\t     \"consider_visiting (late): %s: \"\n\t     \"fts_info=%-6s, isdir=%d ignore=%d have_stat=%d have_type=%d \\n\",\n\t     quotearg_n_style (0, options.err_quoting_style, ent->fts_path),\n\t     get_fts_info_name (ent->fts_info),\n\t     isdir, ignore, state.have_stat, state.have_type);\n\n  if (!ignore)\n    {\n      visit (p, ent, &statbuf);\n    }\n\n  if (ent->fts_info == FTS_DP)\n    {\n      /* we're leaving a directory. */\n      state.stop_at_current_level = false;\n    }\n}",
      "lines": 191,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "find": {
      "start_point": [
        524,
        0
      ],
      "end_point": [
        616,
        1
      ],
      "content": "static bool\nfind (char *arg)\n{\n  char * arglist[2];\n  FTS *p;\n  FTSENT *ent;\n\n  state.starting_path_length = strlen (arg);\n  inside_dir (AT_FDCWD);\n\n  arglist[0] = arg;\n  arglist[1] = NULL;\n\n  switch (options.symlink_handling)\n    {\n    case SYMLINK_ALWAYS_DEREF:\n      ftsoptions |= FTS_COMFOLLOW|FTS_LOGICAL;\n      break;\n\n    case SYMLINK_DEREF_ARGSONLY:\n      ftsoptions |= FTS_COMFOLLOW|FTS_PHYSICAL;\n      break;\n\n    case SYMLINK_NEVER_DEREF:\n      ftsoptions |= FTS_PHYSICAL;\n      break;\n    }\n\n  if (options.stay_on_filesystem)\n    ftsoptions |= FTS_XDEV;\n\n  p = fts_open (arglist, ftsoptions, NULL);\n  if (NULL == p)\n    {\n      error (0, errno, _(\"cannot search %s\"),\n\t     safely_quote_err_filename (0, arg));\n      error_severity (EXIT_FAILURE);\n    }\n  else\n    {\n      int level = INT_MIN;\n\n      while ( (errno=0, ent=fts_read (p)) != NULL )\n\t{\n\t  if (state.execdirs_outstanding)\n\t    {\n\t      /* If we changed level, perform any outstanding\n\t       * execdirs.  If we see a sequence of directory entries\n\t       * like this: fffdfffdfff, we could build a command line\n\t       * of 9 files, but this simple-minded implementation\n\t       * builds a command line for only 3 files at a time\n\t       * (since fts descends into the directories).\n\t       */\n\t      if ((int)ent->fts_level != level)\n\t\t{\n\t\t  show_outstanding_execdirs (stderr);\n\t\t  complete_pending_execdirs ();\n\t\t}\n\t    }\n\t  level = (int)ent->fts_level;\n\n\t  state.already_issued_stat_error_msg = false;\n\t  state.have_stat = false;\n\t  state.have_type = !!ent->fts_statp->st_mode;\n\t  state.type = state.have_type ? ent->fts_statp->st_mode : 0;\n\t  consider_visiting (p, ent);\n\t}\n      /* fts_read returned NULL; distinguish between \"finished\" and \"error\". */\n      if (errno)\n\t{\n\t  error (0, errno,\n\t\t \"failed to read file names from file system at or below %s\",\n\t\t safely_quote_err_filename (0, arg));\n\t  error_severity (EXIT_FAILURE);\n\t  return false;\n\t}\n\n      if (0 != fts_close (p))\n\t{\n\t  /* Here we break the abstraction of fts_close a bit, because we\n\t   * are going to skip the rest of the start points, and return with\n\t   * nonzero exit status.  Hence we need to issue a diagnostic on\n\t   * stderr. */\n\t  error (0, errno,\n\t\t _(\"failed to restore working directory after searching %s\"),\n\t\t arg);\n\t  error_severity (EXIT_FAILURE);\n\t  return false;\n\t}\n      p = NULL;\n    }\n  return true;\n}",
      "lines": 93,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "process_all_startpoints": {
      "start_point": [
        619,
        0
      ],
      "end_point": [
        644,
        1
      ],
      "content": "static bool\nprocess_all_startpoints (int argc, char *argv[])\n{\n  int i;\n\n  /* figure out how many start points there are */\n  for (i = 0; i < argc && !looks_like_expression (argv[i], true); i++)\n    {\n      state.starting_path_length = strlen (argv[i]); /* TODO: is this redundant? */\n      if (!find (argv[i]))\n\treturn false;\n    }\n\n  if (i == 0)\n    {\n      /*\n       * We use a temporary variable here because some actions modify\n       * the path temporarily.  Hence if we use a string constant,\n       * we get a coredump.  The best example of this is if we say\n       * \"find -printf %H\" (note, not \"find . -printf %H\").\n       */\n      char defaultpath[2] = \".\";\n      return find (defaultpath);\n    }\n  return true;\n}",
      "lines": 26,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "main": {
      "start_point": [
        649,
        0
      ],
      "end_point": [
        748,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  int end_of_leading_options = 0; /* First arg after any -H/-L etc. */\n  struct predicate *eval_tree;\n\n  if (argv[0])\n    set_program_name (argv[0]);\n  else\n    set_program_name (\"find\");\n\n  record_initial_cwd ();\n\n  state.already_issued_stat_error_msg = false;\n  state.exit_status = 0;\n  state.execdirs_outstanding = false;\n  state.cwd_dir_fd = AT_FDCWD;\n\n  if (fd_leak_check_is_enabled ())\n    {\n      remember_non_cloexec_fds ();\n    }\n\n  state.shared_files = sharefile_init (\"w\");\n  if (NULL == state.shared_files)\n    {\n      error (EXIT_FAILURE, errno,\n\t     _(\"Failed to initialize shared-file hash table\"));\n    }\n\n  /* Set the option defaults before we do the locale initialisation as\n   * check_nofollow() needs to be executed in the POSIX locale.\n   */\n  set_option_defaults (&options);\n\n#ifdef HAVE_SETLOCALE\n  setlocale (LC_ALL, \"\");\n#endif\n\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n  if (atexit (close_stdout))\n    {\n      error (EXIT_FAILURE, errno, _(\"The atexit library function failed\"));\n    }\n\n  /* Check for -P, -H or -L options.  Also -D and -O, which are\n   * both GNU extensions.\n   */\n  end_of_leading_options = process_leading_options (argc, argv);\n\n  if (options.debug_options & DebugStat)\n    options.xstat = debug_stat;\n\n#ifdef DEBUG\n  fprintf (stderr, \"cur_day_start = %s\", ctime (&options.cur_day_start));\n#endif /* DEBUG */\n\n\n  /* We are now processing the part of the \"find\" command line\n   * after the -H/-L options (if any).\n   */\n  eval_tree = build_expression_tree (argc, argv, end_of_leading_options);\n\n  /* safely_chdir() needs to check that it has ended up in the right place.\n   * To avoid bailing out when something gets automounted, it checks if\n   * the target directory appears to have had a directory mounted on it as\n   * we chdir()ed.  The problem with this is that in order to notice that\n   * a file system was mounted, we would need to lstat() all the mount points.\n   * That strategy loses if our machine is a client of a dead NFS server.\n   *\n   * Hence if safely_chdir() and wd_sanity_check() can manage without needing\n   * to know the mounted device list, we do that.\n   */\n  if (!options.open_nofollow_available)\n    {\n#ifdef STAT_MOUNTPOINTS\n      init_mounted_dev_list ();\n#endif\n    }\n\n\n  /* process_all_startpoints processes the starting points named on\n   * the command line.  A false return value from it means that we\n   * failed to restore the original context.  That means it would not\n   * be safe to call cleanup() since we might complete an execdir in\n   * the wrong directory for example.\n   */\n  if (process_all_startpoints (argc-end_of_leading_options,\n\t\t\t       argv+end_of_leading_options))\n    {\n      /* If \"-exec ... {} +\" has been used, there may be some\n       * partially-full command lines which have been built,\n       * but which are not yet complete.   Execute those now.\n       */\n      show_success_rates (eval_tree);\n      cleanup ();\n    }\n  return state.exit_status;\n}",
      "lines": 100,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "is_fts_enabled": {
      "start_point": [
        750,
        0
      ],
      "end_point": [
        756,
        1
      ],
      "content": "bool\nis_fts_enabled (int *fts_options)\n{\n  /* this version of find (i.e. this main()) uses fts. */\n  *fts_options = ftsoptions;\n  return true;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "bool"
      ]
    }
  },
  "findutils/findutils-4.6.0/find/oldfind.c": {
    "type_to_mode": {
      "start_point": [
        136,
        0
      ],
      "end_point": [
        165,
        1
      ],
      "content": "static mode_t\ntype_to_mode (unsigned type)\n{\n  switch (type)\n    {\n#ifdef DT_FIFO\n    case DT_FIFO: return S_IFIFO;\n#endif\n#ifdef DT_CHR\n    case DT_CHR:  return S_IFCHR;\n#endif\n#ifdef DT_DIR\n    case DT_DIR:  return S_IFDIR;\n#endif\n#ifdef DT_BLK\n    case DT_BLK:  return S_IFBLK;\n#endif\n#ifdef DT_REG\n    case DT_REG:  return S_IFREG;\n#endif\n#ifdef DT_LNK\n    case DT_LNK:  return S_IFLNK;\n#endif\n#ifdef DT_SOCK\n    case DT_SOCK: return S_IFSOCK;\n#endif\n    default:\n      return 0;\t\t\t/* Unknown. */\n    }\n}",
      "lines": 30,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "mode_t"
      ]
    },
    "get_current_dirfd": {
      "start_point": [
        169,
        0
      ],
      "end_point": [
        173,
        1
      ],
      "content": "int\nget_current_dirfd (void)\n{\n  return AT_FDCWD;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    },
    "main": {
      "start_point": [
        177,
        0
      ],
      "end_point": [
        291,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  int i;\n  int end_of_leading_options = 0; /* First arg after any -H/-L etc. */\n  struct predicate *eval_tree;\n\n  if (argv[0])\n    set_program_name (argv[0]);\n  else\n    set_program_name (\"find\");\n\n  state.exit_status = 0;\n\n  if (fd_leak_check_is_enabled ())\n    {\n      remember_non_cloexec_fds ();\n    }\n\n  record_initial_cwd ();\n\n  state.already_issued_stat_error_msg = false;\n  state.shared_files = sharefile_init (\"w\");\n  if (NULL == state.shared_files)\n    {\n      error (EXIT_FAILURE, errno,\n\t     _(\"Failed to initialize shared-file hash table\"));\n    }\n\n  /* Set the option defaults before we do the locale\n   * initialisation as check_nofollow () needs to be executed in the\n   * POSIX locale.\n   */\n  set_option_defaults (&options);\n\n#ifdef HAVE_SETLOCALE\n  setlocale (LC_ALL, \"\");\n#endif\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n  if (atexit (close_stdin))\n    {\n      error (EXIT_FAILURE, errno, _(\"The atexit library function failed\"));\n    }\n\n  /* Check for -P, -H or -L options. */\n  end_of_leading_options = process_leading_options (argc, argv);\n\n  if (options.debug_options & DebugStat)\n    options.xstat = debug_stat;\n\n#ifdef DEBUG\n  fprintf (stderr, \"cur_day_start = %s\", ctime (&options.cur_day_start));\n#endif /* DEBUG */\n\n  /* state.cwd_dir_fd has to be initialized before we call build_expression_tree ()\n   * because command-line parsing may lead us to stat some files.\n   */\n  state.cwd_dir_fd = AT_FDCWD;\n\n  /* We are now processing the part of the \"find\" command line\n   * after the -H/-L options (if any).\n   */\n  eval_tree = build_expression_tree (argc, argv, end_of_leading_options);\n\n\n  /* safely_chdir () needs to check that it has ended up in the right place.\n   * To avoid bailing out when something gets automounted, it checks if\n   * the target directory appears to have had a directory mounted on it as\n   * we chdir ()ed.  The problem with this is that in order to notice that\n   * a file system was mounted, we would need to lstat () all the mount points.\n   * That strategy loses if our machine is a client of a dead NFS server.\n   *\n   * Hence if safely_chdir () and wd_sanity_check () can manage without needing\n   * to know the mounted device list, we do that.\n   */\n  if (!options.open_nofollow_available)\n    {\n#ifdef STAT_MOUNTPOINTS\n      init_mounted_dev_list (0);\n#endif\n    }\n\n\n  set_stat_placeholders (&starting_stat_buf);\n  if ((*options.xstat) (\".\", &starting_stat_buf) != 0)\n    error (EXIT_FAILURE, errno, _(\"cannot stat current directory\"));\n\n  /* If no paths are given, default to \".\".  */\n  for (i = end_of_leading_options; i < argc && !looks_like_expression (argv[i], true); i++)\n    {\n      process_top_path (argv[i], 0, starting_stat_buf.st_ino);\n    }\n\n  /* If there were no path arguments, default to \".\". */\n  if (i == end_of_leading_options)\n    {\n      /*\n       * We use a temporary variable here because some actions modify\n       * the path temporarily.  Hence if we use a string constant,\n       * we get a coredump.  The best example of this is if we say\n       * \"find -printf %H\" (note, not \"find . -printf %H\").\n       */\n      char defaultpath[2] = \".\";\n      process_top_path (defaultpath, 0, starting_stat_buf.st_ino);\n    }\n\n  /* If \"-exec ... {} +\" has been used, there may be some\n   * partially-full command lines which have been built,\n   * but which are not yet complete.   Execute those now.\n   */\n  show_success_rates (eval_tree);\n  cleanup ();\n  return state.exit_status;\n}",
      "lines": 115,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "is_fts_enabled": {
      "start_point": [
        293,
        0
      ],
      "end_point": [
        298,
        1
      ],
      "content": "bool is_fts_enabled (int *ftsoptions)\n{\n  /* this version of find (i.e. this main ()) does not use fts. */\n  *ftsoptions = 0;\n  return false;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "bool"
      ]
    },
    "specific_dirname": {
      "start_point": [
        301,
        0
      ],
      "end_point": [
        326,
        1
      ],
      "content": "static char *\nspecific_dirname (const char *dir)\n{\n  char dirbuf[1024];\n\n  if (0 == strcmp (\".\", dir))\n    {\n      /* OK, what's '.'? */\n      if (NULL != getcwd (dirbuf, sizeof (dirbuf)))\n\t{\n\t  return strdup (dirbuf);\n\t}\n      else\n\t{\n\t  return strdup (dir);\n\t}\n    }\n  else\n    {\n      char *result = canonicalize_filename_mode (dir, CAN_EXISTING);\n      if (NULL == result)\n\treturn strdup (dir);\n      else\n\treturn result;\n    }\n}",
      "lines": 26,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nspecific_dirname (const char *dir)",
        "*"
      ]
    },
    "fs_likely_to_be_automounted": {
      "start_point": [
        333,
        0
      ],
      "end_point": [
        337,
        1
      ],
      "content": "static int\nfs_likely_to_be_automounted (const char *fs)\n{\n  return ( (0==strcmp (fs, \"nfs\")) || (0==strcmp (fs, \"autofs\")) || (0==strcmp (fs, \"subfs\")));\n}",
      "lines": 5,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "init_mounted_dev_list": {
      "start_point": [
        346,
        0
      ],
      "end_point": [
        356,
        1
      ],
      "content": "static void\ninit_mounted_dev_list (int mandatory)\n{\n  assert (NULL == mounted_devices);\n  assert (0 == num_mounted_devices);\n  mounted_devices = get_mounted_devices (&num_mounted_devices);\n  if (mandatory && (NULL == mounted_devices))\n    {\n      error (EXIT_FAILURE, 0, _(\"Cannot read list of mounted devices.\"));\n    }\n}",
      "lines": 11,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "refresh_mounted_dev_list": {
      "start_point": [
        358,
        0
      ],
      "end_point": [
        368,
        1
      ],
      "content": "static void\nrefresh_mounted_dev_list (void)\n{\n  if (mounted_devices)\n    {\n      free (mounted_devices);\n      mounted_devices = 0;\n    }\n  num_mounted_devices = 0u;\n  init_mounted_dev_list (1);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "dev_present": {
      "start_point": [
        372,
        0
      ],
      "end_point": [
        384,
        1
      ],
      "content": "static int\ndev_present (dev_t dev, const dev_t *list, size_t n)\n{\n  if (list)\n    {\n      while (n-- > 0u)\n\t{\n\t  if ( (*list++) == dev )\n\t    return 1;\n\t}\n    }\n  return 0;\n}",
      "lines": 13,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "get_mount_state": {
      "start_point": [
        395,
        0
      ],
      "end_point": [
        410,
        1
      ],
      "content": "static enum MountPointStateChange\nget_mount_state (dev_t newdev)\n{\n  int new_is_present, new_was_present;\n\n  new_was_present = dev_present (newdev, mounted_devices, num_mounted_devices);\n  refresh_mounted_dev_list ();\n  new_is_present  = dev_present (newdev, mounted_devices, num_mounted_devices);\n\n  if (new_was_present == new_is_present)\n    return MountPointStateUnchanged;\n  else if (new_is_present)\n    return MountPointRecentlyMounted;\n  else\n    return MountPointRecentlyUnmounted;\n}",
      "lines": 16,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "enum MountPointStateChange",
        "enum",
        "MountPointStateChange"
      ]
    },
    "dirchange_is_fatal": {
      "start_point": [
        429,
        0
      ],
      "end_point": [
        464,
        1
      ],
      "content": "static enum WdSanityCheckFatality\ndirchange_is_fatal (const char *specific_what,\n\t\t    enum WdSanityCheckFatality isfatal,\n\t\t    int silent,\n\t\t    struct stat *newinfo)\n{\n  enum MountPointStateChange transition = get_mount_state (newinfo->st_dev);\n  switch (transition)\n    {\n    case MountPointRecentlyUnmounted:\n      isfatal = NON_FATAL_IF_SANITY_CHECK_FAILS;\n      if (!silent)\n\t{\n\t  error (0, 0,\n\t\t _(\"WARNING: file system %s has recently been unmounted.\"),\n\t\t safely_quote_err_filename (0, specific_what));\n\t}\n      break;\n\n    case MountPointRecentlyMounted:\n      isfatal = NON_FATAL_IF_SANITY_CHECK_FAILS;\n      if (!silent)\n\t{\n\t  error (0, 0,\n\t\t _(\"WARNING: file system %s has recently been mounted.\"),\n\t\t safely_quote_err_filename (0, specific_what));\n\t}\n      break;\n\n    case MountPointStateUnchanged:\n      /* leave isfatal as it is */\n      break;\n    }\n\n  return isfatal;\n}",
      "lines": 36,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "enum WdSanityCheckFatality",
        "enum",
        "WdSanityCheckFatality"
      ]
    },
    "wd_sanity_check": {
      "start_point": [
        499,
        0
      ],
      "end_point": [
        602,
        1
      ],
      "content": "static bool\nwd_sanity_check (const char *thing_to_stat,\n\t\tconst char *progname,\n\t\tconst char *what,\n\t\tdev_t old_dev,\n\t\tino_t old_ino,\n\t\tstruct stat *newinfo,\n\t\tint parent,\n\t\tint line_no,\n\t\tenum TraversalDirection direction,\n\t\tenum WdSanityCheckFatality isfatal,\n\t\tbool *changed) /* output parameter */\n{\n  const char *fstype;\n  char *specific_what = NULL;\n  int silent = 0;\n  const char *current_dir = \".\";\n\n  *changed = false;\n\n  set_stat_placeholders (newinfo);\n  if ((*options.xstat) (current_dir, newinfo) != 0)\n    fatal_target_file_error (errno, thing_to_stat);\n\n  if (old_dev != newinfo->st_dev)\n    {\n      *changed = true;\n      specific_what = specific_dirname (what);\n      fstype = filesystem_type (newinfo, current_dir);\n      silent = fs_likely_to_be_automounted (fstype);\n\n      /* This condition is rare, so once we are here it is\n       * reasonable to perform an expensive computation to\n       * determine if we should continue or fail.\n       */\n      if (TraversingDown == direction)\n\t{\n#ifdef STAT_MOUNTPOINTS\n\t  isfatal = dirchange_is_fatal (specific_what,isfatal,silent,newinfo);\n#else\n\t  (void) silent;\n\t  isfatal = RETRY_IF_SANITY_CHECK_FAILS;\n#endif\n\t}\n\n      switch (isfatal)\n\t{\n\tcase FATAL_IF_SANITY_CHECK_FAILS:\n\t  {\n\t    fstype = filesystem_type (newinfo, current_dir);\n\t    error (EXIT_FAILURE, 0,\n\t\t   _(\"%s%s changed during execution of %s (old device number %ld, new device number %ld, file system type is %s) [ref %ld]\"),\n\t\t   safely_quote_err_filename (0, specific_what),\n\t\t   parent ? \"/..\" : \"\",\n\t\t   safely_quote_err_filename (1, progname),\n\t\t   (long) old_dev,\n\t\t   (long) newinfo->st_dev,\n\t\t   fstype,\n\t\t   (long)line_no);\n\t    /*NOTREACHED*/\n\t    return false;\n\t  }\n\n\tcase NON_FATAL_IF_SANITY_CHECK_FAILS:\n\t  {\n\t    /* Since the device has changed under us, the inode number\n\t     * will almost certainly also be different. However, we have\n\t     * already decided that this is not a problem.  Hence we return\n\t     * without checking the inode number.\n\t     */\n\t    free (specific_what);\n\t    return true;\n\t  }\n\n\tcase RETRY_IF_SANITY_CHECK_FAILS:\n\t  return false;\n\t}\n    }\n\n  /* Device number was the same, check if the inode has changed. */\n  if (old_ino != newinfo->st_ino)\n    {\n      *changed = true;\n      specific_what = specific_dirname (what);\n      fstype = filesystem_type (newinfo, current_dir);\n\n      error ((isfatal == FATAL_IF_SANITY_CHECK_FAILS) ? 1 : 0,\n\t     0,\t\t\t/* no relevant errno value */\n\t     _(\"%s%s changed during execution of %s \"\n\t       \"(old inode number %\" PRIuMAX \", new inode number %\" PRIuMAX\n\t       \", file system type is %s) [ref %ld]\"),\n\t     safely_quote_err_filename (0, specific_what),\n\t     parent ? \"/..\" : \"\",\n\t     safely_quote_err_filename (1, progname),\n\t     (uintmax_t) old_ino,\n\t     (uintmax_t) newinfo->st_ino,\n\t     fstype,\n\t     (long)line_no);\n      free (specific_what);\n      return false;\n    }\n\n  return true;\n}",
      "lines": 104,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "safely_chdir_lstat": {
      "start_point": [
        623,
        0
      ],
      "end_point": [
        839,
        1
      ],
      "content": "static enum SafeChdirStatus\nsafely_chdir_lstat (const char *dest,\n\t\t    enum TraversalDirection direction,\n\t\t    struct stat *statbuf_dest,\n\t\t    enum ChdirSymlinkHandling symlink_follow_option,\n\t\t    bool *did_stat)\n{\n  struct stat statbuf_arrived;\n  int rv, dotfd=-1;\n  int saved_errno;\t\t/* specific_dirname() changes errno. */\n  bool rv_set = false;\n  bool statflag = false;\n  int tries = 0;\n  enum WdSanityCheckFatality isfatal = RETRY_IF_SANITY_CHECK_FAILS;\n\n  saved_errno = errno = 0;\n\n  dotfd = open_cloexec (\".\", O_RDONLY\n#if defined O_LARGEFILE\n\t\t\t|O_LARGEFILE\n#endif\n\t\t\t);\n\n  /* We jump back to here if wd_sanity_check()\n   * recoverably triggers an alert.\n   */\n retry:\n  ++tries;\n\n  if (dotfd >= 0)\n    {\n      /* Stat the directory we're going to. */\n      set_stat_placeholders (statbuf_dest);\n      if (0 == options.xstat (dest, statbuf_dest))\n\t{\n\t  statflag = true;\n\n#ifdef S_ISLNK\n\t  /* symlink_follow_option might be set to SymlinkFollowOk, which\n\t   * would allow us to chdir() into a symbolic link.  This is\n\t   * only useful for the case where the directory we're\n\t   * chdir()ing into is the basename of a command line\n\t   * argument, for example where \"foo/bar/baz\" is specified on\n\t   * the command line.  When -P is in effect (the default),\n\t   * baz will not be followed if it is a symlink, but if bar\n\t   * is a symlink, it _should_ be followed.  Hence we need the\n\t   * ability to override the policy set by following_links().\n\t   */\n\t  if (!following_links () && S_ISLNK(statbuf_dest->st_mode))\n\t    {\n\t      /* We're not supposed to be following links, but this is\n\t       * a link.  Check symlink_follow_option to see if we should\n\t       * make a special exception.\n\t       */\n\t      if (symlink_follow_option == SymlinkFollowOk)\n\t\t{\n\t\t  /* We need to re-stat() the file so that the\n\t\t   * sanity check can pass.\n\t\t   */\n\t\t  if (0 != stat (dest, statbuf_dest))\n\t\t    {\n\t\t      rv = SafeChdirFailNonexistent;\n\t\t      rv_set = true;\n\t\t      saved_errno = errno;\n\t\t      goto fail;\n\t\t    }\n\t\t  statflag = true;\n\t\t}\n\t      else\n\t\t{\n\t\t  /* Not following symlinks, so the attempt to\n\t\t   * chdir() into a symlink should be prevented.\n\t\t   */\n\t\t  rv = SafeChdirFailSymlink;\n\t\t  rv_set = true;\n\t\t  saved_errno = 0;\t/* silence the error message */\n\t\t  goto fail;\n\t\t}\n\t    }\n#endif\n#ifdef S_ISDIR\n\t  /* Although the immediately following chdir() would detect\n\t   * the fact that this is not a directory for us, this would\n\t   * result in an extra system call that fails.  Anybody\n\t   * examining the system-call trace should ideally not be\n\t   * concerned that something is actually failing.\n\t   */\n\t  if (!S_ISDIR(statbuf_dest->st_mode))\n\t    {\n\t      rv = SafeChdirFailNotDir;\n\t      rv_set = true;\n\t      saved_errno = 0;\t/* silence the error message */\n\t      goto fail;\n\t    }\n#endif\n\n\t  if (options.debug_options & DebugSearch)\n\t    fprintf (stderr, \"safely_chdir(): chdir(\\\"%s\\\")\\n\", dest);\n\n\t  if (0 == chdir (dest))\n\t    {\n\t      /* check we ended up where we wanted to go */\n\t      bool changed = false;\n\t      if (!wd_sanity_check (\".\", program_name, \".\",\n\t\t\t\t    statbuf_dest->st_dev,\n\t\t\t\t    statbuf_dest->st_ino,\n\t\t\t\t    &statbuf_arrived,\n\t\t\t\t    0, __LINE__, direction,\n\t\t\t\t    isfatal,\n\t\t\t\t    &changed))\n\t\t{\n\t\t  /* Only allow one failure. */\n\t\t  if (RETRY_IF_SANITY_CHECK_FAILS == isfatal)\n\t\t    {\n\t\t      if (0 == fchdir (dotfd))\n\t\t\t{\n\t\t\t  isfatal = FATAL_IF_SANITY_CHECK_FAILS;\n\t\t\t  goto retry;\n\t\t\t}\n\t\t      else\n\t\t\t{\n\t\t\t  /* Failed to return to original directory,\n\t\t\t   * but we know that the current working\n\t\t\t   * directory is not the one that we intend\n\t\t\t   * to be in.  Since fchdir() failed, we\n\t\t\t   * can't recover from this and so this error\n\t\t\t   * is fatal.\n\t\t\t   */\n\t\t\t  error (EXIT_FAILURE, errno,\n\t\t\t\t _(\"failed to return to parent directory\"));\n\t\t\t}\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      /* XXX: not sure what to use as an excuse here. */\n\t\t      rv = SafeChdirFailNonexistent;\n\t\t      rv_set = true;\n\t\t      saved_errno = 0;\n\t\t      goto fail;\n\t\t    }\n\t\t}\n\n\t      close (dotfd);\n\t      return SafeChdirOK;\n\t    }\n\t  else\n\t    {\n\t      saved_errno = errno;\n\t      if (ENOENT == saved_errno)\n\t\t{\n\t\t  rv = SafeChdirFailNonexistent;\n\t\t  rv_set = true;\n\t\t  if (options.ignore_readdir_race)\n\t\t    errno = 0;\t/* don't issue err msg */\n\t\t}\n\t      else if (ENOTDIR == saved_errno)\n\t\t{\n\t\t  /* This can happen if the we stat a directory,\n\t\t   * and then file system activity changes it into\n\t\t   * a non-directory.\n\t\t   */\n\t\t  saved_errno = 0;\t/* don't issue err msg */\n\t\t  rv = SafeChdirFailNotDir;\n\t\t  rv_set = true;\n\t\t}\n\t      else\n\t\t{\n\t\t  rv = SafeChdirFailChdirFailed;\n\t\t  rv_set = true;\n\t\t}\n\t      goto fail;\n\t    }\n\t}\n      else\n\t{\n\t  saved_errno = errno;\n\t  rv = SafeChdirFailStat;\n\t  rv_set = true;\n\n\t  if ( (ENOENT == saved_errno) || (0 == state.curdepth))\n\t    saved_errno = 0;\t/* don't issue err msg */\n\t  goto fail;\n\t}\n    }\n  else\n    {\n      /* We do not have read permissions on \".\" */\n      rv = SafeChdirFailWouldBeUnableToReturn;\n      rv_set = true;\n      goto fail;\n    }\n\n  /* This is the success path, so we clear errno.  The caller probably\n   * won't be calling error() anyway.\n   */\n  saved_errno = 0;\n\n  /* We use the same exit path for success or failure.\n   * which has occurred is recorded in RV.\n   */\n fail:\n  /* We do not call error() as this would result in a duplicate error\n   * message when the caller does the same thing.\n   */\n  if (saved_errno)\n    errno = saved_errno;\n\n  if (dotfd >= 0)\n    {\n      close (dotfd);\n      dotfd = -1;\n    }\n\n  *did_stat = statflag;\n  assert (rv_set);\n  return rv;\n}",
      "lines": 217,
      "depth": 21,
      "decorators": [
        "static",
        "static",
        "enum SafeChdirStatus",
        "enum",
        "SafeChdirStatus"
      ]
    },
    "safely_chdir_nofollow": {
      "start_point": [
        847,
        0
      ],
      "end_point": [
        923,
        1
      ],
      "content": "static enum SafeChdirStatus\nsafely_chdir_nofollow (const char *dest,\n\t\t       enum TraversalDirection direction,\n\t\t       struct stat *statbuf_dest,\n\t\t       enum ChdirSymlinkHandling symlink_follow_option,\n\t\t       bool *did_stat)\n{\n  int extraflags, fd;\n\n  (void) direction;\n  (void) statbuf_dest;\n\n  extraflags = 0;\n  *did_stat = false;\n\n  switch (symlink_follow_option)\n    {\n    case SymlinkFollowOk:\n      extraflags = 0;\n      break;\n\n    case SymlinkHandleDefault:\n      if (following_links ())\n\textraflags = 0;\n      else\n\textraflags = O_NOFOLLOW; /* ... which may still be 0. */\n      break;\n    }\n\n  errno = 0;\n  fd = open (dest, O_RDONLY\n#if defined O_LARGEFILE\n\t    |O_LARGEFILE\n#endif\n#if defined O_CLOEXEC\n\t    |O_CLOEXEC\n#endif\n\t    |extraflags);\n  if (fd < 0)\n    {\n      switch (errno)\n\t{\n\tcase ELOOP:\n\t  return SafeChdirFailSymlink; /* This is why we use O_NOFOLLOW */\n\tcase ENOENT:\n\t  return SafeChdirFailNonexistent;\n\tdefault:\n\t  return SafeChdirFailDestUnreadable;\n\t}\n    }\n\n  errno = 0;\n  if (0 == fchdir (fd))\n    {\n      close (fd);\n      return SafeChdirOK;\n    }\n  else\n    {\n      int saved_errno = errno;\n      close (fd);\n      errno = saved_errno;\n\n      switch (errno)\n\t{\n\tcase ENOTDIR:\n\t  return SafeChdirFailNotDir;\n\n\tcase EACCES:\n\tcase EBADF:\t\t/* Shouldn't happen */\n\tcase EINTR:\n\tcase EIO:\n\tdefault:\n\t  return SafeChdirFailChdirFailed;\n\t}\n    }\n}",
      "lines": 77,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "enum SafeChdirStatus",
        "enum",
        "SafeChdirStatus"
      ]
    },
    "safely_chdir": {
      "start_point": [
        925,
        0
      ],
      "end_point": [
        965,
        1
      ],
      "content": "static enum SafeChdirStatus\nsafely_chdir (const char *dest,\n\t      enum TraversalDirection direction,\n\t      struct stat *statbuf_dest,\n\t      enum ChdirSymlinkHandling symlink_follow_option,\n\t      bool *did_stat)\n{\n  enum SafeChdirStatus result;\n\n  /* We're about to leave a directory.  If there are any -execdir\n   * argument lists which have been built but have not yet been\n   * processed, do them now because they must be done in the same\n   * directory.\n   */\n  complete_pending_execdirs ();\n\n  /* gnulib defines O_NOFOLLOW to 0 if the OS doesn't have it. */\n  options.open_nofollow_available = !!O_NOFOLLOW;\n  if (options.open_nofollow_available)\n    {\n      result = safely_chdir_nofollow (dest, direction, statbuf_dest,\n\t\t\t\t     symlink_follow_option, did_stat);\n      if (SafeChdirFailDestUnreadable != result)\n\t{\n\t  return result;\n\t}\n      else\n\t{\n\t  /* Savannah bug #15384: fall through to use safely_chdir_lstat\n\t   * if the directory is not readable.\n\t   */\n\t  /* Do nothing. */\n\t}\n    }\n  /* Even if O_NOFOLLOW is available, we may need to use the alternative\n   * method, since parent of the start point may be executable but not\n   * readable.\n   */\n  return safely_chdir_lstat (dest, direction, statbuf_dest,\n\t\t\t     symlink_follow_option, did_stat);\n}",
      "lines": 41,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "enum SafeChdirStatus",
        "enum",
        "SafeChdirStatus"
      ]
    },
    "chdir_back": {
      "start_point": [
        970,
        0
      ],
      "end_point": [
        977,
        1
      ],
      "content": "static void\nchdir_back (void)\n{\n  if (options.debug_options & DebugSearch)\n    fprintf (stderr, \"chdir_back(): chdir to start point\\n\");\n\n  restore_cwd (initial_wd);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "at_top": {
      "start_point": [
        983,
        0
      ],
      "end_point": [
        1056,
        1
      ],
      "content": "static void\nat_top (char *pathname,\n\tmode_t mode,\n\tino_t inum,\n\tstruct stat *pstat,\n\tvoid (*action)(char *pathname,\n\t\t       char *basename,\n\t\t       int mode,\n\t\t       ino_t inum,\n\t\t       struct stat *pstat))\n{\n  int dirchange;\n  char *parent_dir = dir_name (pathname);\n  char *base = last_component (pathname);\n\n  state.curdepth = 0;\n  state.starting_path_length = strlen (pathname);\n\n  if (0 == *base\n      || 0 == strcmp (parent_dir, \".\"))\n    {\n      dirchange = 0;\n      base = pathname;\n    }\n  else\n    {\n      enum TraversalDirection direction;\n      enum SafeChdirStatus chdir_status;\n      struct stat st;\n      bool did_stat = false;\n\n      dirchange = 1;\n      if (0 == strcmp (base, \"..\"))\n\tdirection = TraversingUp;\n      else\n\tdirection = TraversingDown;\n\n      /* We pass SymlinkFollowOk to safely_chdir(), which allows it to\n       * chdir() into a symbolic link.  This is only useful for the\n       * case where the directory we're chdir()ing into is the\n       * basename of a command line argument, for example where\n       * \"foo/bar/baz\" is specified on the command line.  When -P is\n       * in effect (the default), baz will not be followed if it is a\n       * symlink, but if bar is a symlink, it _should_ be followed.\n       * Hence we need the ability to override the policy set by\n       * following_links().\n       */\n      chdir_status = safely_chdir (parent_dir, direction, &st, SymlinkFollowOk, &did_stat);\n      if (SafeChdirOK != chdir_status)\n\t{\n\t  const char *what = (SafeChdirFailWouldBeUnableToReturn == chdir_status) ? \".\" : parent_dir;\n\t  if (errno)\n\t    error (0, errno, \"%s\",\n\t\t   safely_quote_err_filename (0, what));\n\t  else\n\t    error (0, 0, _(\"Failed to safely change directory into %s\"),\n\t\t   safely_quote_err_filename (0, parent_dir));\n\n\t  /* We can't process this command-line argument. */\n\t  state.exit_status = 1;\n\t  return;\n\t}\n    }\n\n  free (parent_dir);\n  parent_dir = NULL;\n\n  action (pathname, base, mode, inum, pstat);\n\n  if (dirchange)\n    {\n      chdir_back ();\n    }\n}",
      "lines": 74,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "do_process_top_dir": {
      "start_point": [
        1059,
        0
      ],
      "end_point": [
        1069,
        1
      ],
      "content": "static void do_process_top_dir (char *pathname,\n\t\t\t\tchar *base,\n\t\t\t\tint mode,\n\t\t\t\tino_t inum,\n\t\t\t\tstruct stat *pstat)\n{\n  (void) pstat;\n\n  process_path (pathname, base, false, \".\", mode, inum);\n  complete_pending_execdirs ();\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "do_process_predicate": {
      "start_point": [
        1071,
        0
      ],
      "end_point": [
        1082,
        1
      ],
      "content": "static void\ndo_process_predicate (char *pathname,\n\t\t      char *base,\n\t\t      int mode,\n\t\t      ino_t inum,\n\t\t      struct stat *pstat)\n{\n  (void) mode;\n  (void) inum;\n  state.rel_pathname = base;\t/* cwd_dir_fd was already set by safely_chdir */\n  apply_predicate (pathname, pstat, get_eval_tree ());\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "process_top_path": {
      "start_point": [
        1097,
        0
      ],
      "end_point": [
        1101,
        1
      ],
      "content": "static void\nprocess_top_path (char *pathname, mode_t mode, ino_t inum)\n{\n  at_top (pathname, mode, inum, NULL, do_process_top_dir);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "issue_loop_warning": {
      "start_point": [
        1128,
        0
      ],
      "end_point": [
        1165,
        1
      ],
      "content": "static void\nissue_loop_warning (const char *name, const char *pathname, int level)\n{\n  struct stat stbuf_link;\n  if (lstat (name, &stbuf_link) != 0)\n    stbuf_link.st_mode = S_IFREG;\n\n  if (S_ISLNK(stbuf_link.st_mode))\n    {\n      error (0, 0,\n\t     _(\"Symbolic link %s is part of a loop in the directory hierarchy; we have already visited the directory to which it points.\"),\n\t     safely_quote_err_filename (0, pathname));\n      /* XXX: POSIX appears to require that the exit status be non-zero if a\n       * diagnostic is issued.\n       */\n    }\n  else\n    {\n      int distance = 1 + (dir_curr-level);\n      /* We have found an infinite loop.  POSIX requires us to\n       * issue a diagnostic.  Usually we won't get to here\n       * because when the leaf optimisation is on, it will cause\n       * the subdirectory to be skipped.  If /a/b/c/d is a hard\n       * link to /a/b, then the link count of /a/b/c is 2,\n       * because the \"..\" entry of /b/b/c/d points to /a, not\n       * to /a/b/c.\n       */\n      error (0, 0,\n\t     ngettext (\n\t\t       \"Filesystem loop detected; %s has the same device number and inode as \"\n\t\t       \"a directory which is %d level higher in the file system hierarchy\",\n\t\t       \"Filesystem loop detected; %s has the same device number and inode as \"\n\t\t       \"a directory which is %d levels higher in the file system hierarchy\",\n\t\t       (long)distance),\n\t     safely_quote_err_filename (0, pathname),\n\t     distance);\n    }\n}",
      "lines": 38,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "process_path": {
      "start_point": [
        1183,
        0
      ],
      "end_point": [
        1295,
        1
      ],
      "content": "static int\nprocess_path (char *pathname, char *name, bool leaf, char *parent,\n\t      mode_t mode, ino_t inum)\n{\n  struct stat stat_buf;\n  static dev_t root_dev;\t/* Device ID of current argument pathname. */\n  int i;\n  struct predicate *eval_tree;\n\n  eval_tree = get_eval_tree ();\n  /* Assume it is a non-directory initially. */\n  stat_buf.st_mode = 0;\n\n  /* The caller usually knows the inode number, either from readdir or\n   * a *stat call.  We use that value (the caller passes 0 to indicate\n   * ignorance of the inode number).\n   */\n  stat_buf.st_ino = inum;\n\n  state.rel_pathname = name;\n  state.type = 0;\n  state.have_stat = false;\n  state.have_type = false;\n  state.already_issued_stat_error_msg = false;\n\n  if (!digest_mode (&mode, pathname, name, &stat_buf, leaf))\n    return 0;\n\n  if (!S_ISDIR (state.type))\n    {\n      if (state.curdepth >= options.mindepth)\n\tapply_predicate (pathname, &stat_buf, eval_tree);\n      return 0;\n    }\n\n  /* From here on, we're working on a directory.  */\n\n\n  /* Now we really need to stat the directory, even if we know the\n   * type, because we need information like struct stat.st_rdev.\n   */\n  if (get_statinfo (pathname, name, &stat_buf) != 0)\n    return 0;\n\n  state.have_stat = true;\n  mode = state.type = stat_buf.st_mode;\t/* use full info now that we have it. */\n  state.stop_at_current_level =\n    options.maxdepth >= 0\n    && state.curdepth >= options.maxdepth;\n\n  /* If we've already seen this directory on this branch,\n     don't descend it again.  */\n  for (i = 0; i <= dir_curr; i++)\n    if (stat_buf.st_ino == dir_ids[i].ino &&\n\tstat_buf.st_dev == dir_ids[i].dev)\n      {\n\tstate.stop_at_current_level = true;\n\tissue_loop_warning (name, pathname, i);\n      }\n\n  if (dir_alloc <= ++dir_curr)\n    {\n      dir_alloc += DIR_ALLOC_STEP;\n      dir_ids = (struct dir_id *)\n\txrealloc ((char *) dir_ids, dir_alloc * sizeof (struct dir_id));\n    }\n  dir_ids[dir_curr].ino = stat_buf.st_ino;\n  dir_ids[dir_curr].dev = stat_buf.st_dev;\n\n  if (options.stay_on_filesystem)\n    {\n      if (state.curdepth == 0)\n\troot_dev = stat_buf.st_dev;\n      else if (stat_buf.st_dev != root_dev)\n\tstate.stop_at_current_level = true;\n    }\n\n  if (options.do_dir_first && state.curdepth >= options.mindepth)\n    apply_predicate (pathname, &stat_buf, eval_tree);\n\n  if (options.debug_options & DebugSearch)\n    fprintf (stderr, \"pathname = %s, stop_at_current_level = %d\\n\",\n\t     pathname, state.stop_at_current_level);\n\n  if (state.stop_at_current_level == false)\n    {\n      /* Scan directory on disk. */\n      process_dir (pathname, name, strlen (pathname), &stat_buf, parent);\n    }\n\n  if (options.do_dir_first == false && state.curdepth >= options.mindepth)\n    {\n      /* The fields in 'state' are now out of date.  Correct them.\n       */\n      if (!digest_mode (&mode, pathname, name, &stat_buf, leaf))\n\treturn 0;\n\n      if (0 == dir_curr)\n\t{\n\t  at_top (pathname, mode, stat_buf.st_ino, &stat_buf,\n\t\t  do_process_predicate);\n\t}\n      else\n\t{\n\t  do_process_predicate (pathname, name, mode, stat_buf.st_ino,\n\t\t\t\t&stat_buf);\n\t}\n    }\n\n  dir_curr--;\n\n  return 1;\n}",
      "lines": 113,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "process_dir": {
      "start_point": [
        1309,
        0
      ],
      "end_point": [
        1580,
        1
      ],
      "content": "static void\nprocess_dir (char *pathname, char *name, int pathlen, const struct stat *statp, char *parent)\n{\n  int subdirs_left;\t\t/* Number of unexamined subdirs in PATHNAME. */\n  bool subdirs_unreliable;\t/* if true, cannot use dir link count as subdir limif (if false, it may STILL be unreliable) */\n  struct stat stat_buf;\n  size_t dircount = 0u;\n  DIR *dirp;\n\n  if (statp->st_nlink < 2)\n    {\n      subdirs_unreliable = true;\n      subdirs_left = 0;\n    }\n  else\n    {\n      subdirs_unreliable = false; /* not necessarily right */\n      subdirs_left = statp->st_nlink - 2; /* Account for name and \".\". */\n    }\n\n  errno = 0;\n  dirp = opendir_safer (name);\n\n  if (dirp == NULL)\n    {\n      assert (errno != 0);\n      error (0, errno, \"%s\", safely_quote_err_filename (0, pathname));\n      state.exit_status = 1;\n    }\n  else\n    {\n      char *cur_path;\t\t/* Full path of each file to process. */\n      char *cur_name;\t\t/* Base name of each file to process. */\n      unsigned cur_path_size;\t/* Bytes allocated for `cur_path'. */\n      register unsigned file_len; /* Length of each path to process. */\n      register unsigned pathname_len; /* PATHLEN plus trailing '/'. */\n      bool did_stat = false;\n\n      if (pathname[pathlen - 1] == '/')\n\tpathname_len = pathlen + 1; /* For '\\0'; already have '/'. */\n      else\n\tpathname_len = pathlen + 2; /* For '/' and '\\0'. */\n      cur_path_size = 0;\n      cur_path = NULL;\n\n      /* We're about to leave the directory.  If there are any\n       * -execdir argument lists which have been built but have not\n       * yet been processed, do them now because they must be done in\n       * the same directory.\n       */\n      complete_pending_execdirs ();\n\n      if (strcmp (name, \".\"))\n\t{\n\t  enum SafeChdirStatus status = safely_chdir (name, TraversingDown, &stat_buf, SymlinkHandleDefault, &did_stat);\n\t  switch (status)\n\t    {\n\t    case SafeChdirOK:\n\t      /* If there had been a change but wd_sanity_check()\n\t       * accepted it, we need to accept that on the\n\t       * way back up as well, so modify our record\n\t       * of what we think we should see later.\n\t       * If there was no change, the assignments are a no-op.\n\t       *\n\t       * However, before performing the assignment, we need to\n\t       * check that we have the stat information.   If O_NOFOLLOW\n\t       * is available, safely_chdir() will not have needed to use\n\t       * stat(), and so stat_buf will just contain random data.\n\t       */\n\t      if (!did_stat)\n\t\t{\n\t\t  /* If there is a link we need to follow it.  Hence\n\t\t   * the direct call to stat() not through (options.xstat)\n\t\t   */\n\t\t  set_stat_placeholders (&stat_buf);\n\t\t  if (0 != stat (\".\", &stat_buf))\n\t\t    break;\t/* skip the assignment. */\n\t\t}\n\t      dir_ids[dir_curr].dev = stat_buf.st_dev;\n\t      dir_ids[dir_curr].ino = stat_buf.st_ino;\n\n\t      break;\n\n\t    case SafeChdirFailWouldBeUnableToReturn:\n\t      error (0, errno, \".\");\n\t      state.exit_status = 1;\n\t      break;\n\n\t    case SafeChdirFailNonexistent:\n\t    case SafeChdirFailDestUnreadable:\n\t    case SafeChdirFailStat:\n\t    case SafeChdirFailNotDir:\n\t    case SafeChdirFailChdirFailed:\n\t      error (0, errno, \"%s\",\n\t\t     safely_quote_err_filename (0, pathname));\n\t      state.exit_status = 1;\n\t      return;\n\n\t    case SafeChdirFailSymlink:\n\t      error (0, 0,\n\t\t     _(\"warning: not following the symbolic link %s\"),\n\t\t     safely_quote_err_filename (0, pathname));\n\t      state.exit_status = 1;\n\t      return;\n\t    }\n\t}\n\n      while (1)\n\t{\n\t  const char *namep;\n\t  mode_t mode = 0;\n\t  const struct dirent *dp;\n\n\t  /* We reset errno here to distinguish between end-of-directory and an error */\n\t  errno = 0;\n\t  dp = readdir (dirp);\n\t  if (NULL == dp)\n\t    {\n\t      if (errno)\n\t\t{\n\t\t  /* an error occurred, but we are not yet at the end\n\t\t     of the directory stream. */\n\t\t  error (0, errno, \"%s\", safely_quote_err_filename (0, pathname));\n\t\t  continue;\n\t\t}\n\t      else\n\t\t{\n\t\t  break;\t/* End of the directory stream. */\n\t\t}\n\t    }\n\t  else\n\t    {\n\t      namep = dp->d_name;\n\t      /* Skip \"\", \".\", and \"..\".  \"\" is returned by at least one buggy\n\t\t implementation: Solaris 2.4 readdir on NFS file systems.  */\n\t      if (!namep[0] ||\n                  (namep[0] == '.' && (namep[1] == 0 ||\n                                       (namep[1] == '.' && namep[2] == 0))))\n\t\tcontinue;\n\t    }\n\n#if defined HAVE_STRUCT_DIRENT_D_TYPE\n\t  if (dp->d_type != DT_UNKNOWN)\n\t    mode = type_to_mode (dp->d_type);\n#endif\n\n\t  /* Append this directory entry's name to the path being searched. */\n\t  file_len = pathname_len + strlen (namep);\n\t  if (file_len > cur_path_size)\n\t    {\n\t      while (file_len > cur_path_size)\n\t\tcur_path_size += 1024;\n\t      free (cur_path);\n\t      cur_path = xmalloc (cur_path_size);\n\t      strcpy (cur_path, pathname);\n\t      cur_path[pathname_len - 2] = '/';\n\t    }\n\t  cur_name = cur_path + pathname_len - 1;\n\t  strcpy (cur_name, namep);\n\n\t  state.curdepth++;\n\t  if (!options.no_leaf_check && !subdirs_unreliable)\n\t    {\n\t      if (mode && S_ISDIR(mode) && (subdirs_left == 0))\n\t\t{\n\t\t  /* This is a subdirectory, but the number of directories we\n\t\t   * have found now exceeds the number we would expect given\n\t\t   * the hard link count on the parent.   This is likely to be\n\t\t   * a bug in the file system driver (e.g. Linux's\n\t\t   * /proc file system) or may just be a fact that the OS\n\t\t   * doesn't really handle hard links with Unix semantics.\n\t\t   * In the latter case, -noleaf should be used routinely.\n\t\t   */\n\t\t  error (0, 0, _(\"WARNING: Hard link count is wrong for %s (saw only st_nlink=%\" PRIuMAX  \" but we already saw %\" PRIuMAX \" subdirectories): this may be a bug in your file system driver.  Automatically turning on find's -noleaf option.  Earlier results may have failed to include directories that should have been searched.\"),\n\t\t\t safely_quote_err_filename(0, pathname),\n\t\t\t (uintmax_t) statp->st_nlink,\n\t\t\t (uintmax_t) dircount);\n\t\t  state.exit_status = 1; /* We know the result is wrong, now */\n\t\t  options.no_leaf_check = true;\t/* Don't make same\n\t\t\t\t\t\t   mistake again */\n\t\t  subdirs_unreliable = 1;\n\t\t  subdirs_left = 1; /* band-aid for this iteration. */\n\t\t}\n\n\t      /* Normal case optimization.  On normal Unix\n\t\t file systems, a directory that has no subdirectories\n\t\t has two links: its name, and \".\".  Any additional\n\t\t links are to the \"..\" entries of its subdirectories.\n\t\t Once we have processed as many subdirectories as\n\t\t there are additional links, we know that the rest of\n\t\t the entries are non-directories -- in other words,\n\t\t leaf files. */\n\t      {\n\t\tint count;\n\t\tcount = process_path (cur_path, cur_name,\n\t\t\t\t      subdirs_left == 0, pathname,\n\t\t\t\t      mode, D_INO(dp));\n\t\tsubdirs_left -= count;\n\t\tdircount += count;\n\t      }\n\t    }\n\t  else\n\t    {\n\t      /* There might be weird (e.g., CD-ROM or MS-DOS) file systems\n\t\t mounted, which don't have Unix-like directory link counts. */\n\t      process_path (cur_path, cur_name, false, pathname, mode,\n\t\t\t    D_INO(dp));\n\t    }\n\n\t  state.curdepth--;\n\t}\n\n\n      /* We're about to leave the directory.  If there are any\n       * -execdir argument lists which have been built but have not\n       * yet been processed, do them now because they must be done in\n       * the same directory.\n       */\n      complete_pending_execdirs ();\n\n      if (strcmp (name, \".\"))\n\t{\n\t  enum SafeChdirStatus status;\n\n\t  /* We could go back and do the next command-line arg\n\t     instead, maybe using longjmp.  */\n\t  char const *dir;\n\t  bool deref = following_links () ? true : false;\n\n\t  if ( (state.curdepth>0) && !deref)\n\t    dir = \"..\";\n\t  else\n\t    {\n\t      chdir_back ();\n\t      dir = parent;\n\t    }\n\n\t  did_stat = false;\n\t  status = safely_chdir (dir, TraversingUp, &stat_buf, SymlinkHandleDefault, &did_stat);\n\t  switch (status)\n\t    {\n\t    case SafeChdirOK:\n\t      break;\n\n\t    case SafeChdirFailWouldBeUnableToReturn:\n\t      error (EXIT_FAILURE, errno, \".\");\n\t      return;\n\n\t    case SafeChdirFailNonexistent:\n\t    case SafeChdirFailDestUnreadable:\n\t    case SafeChdirFailStat:\n\t    case SafeChdirFailSymlink:\n\t    case SafeChdirFailNotDir:\n\t    case SafeChdirFailChdirFailed:\n\t      error (EXIT_FAILURE, errno,\n\t\t     \"%s\", safely_quote_err_filename (0, pathname));\n\t      return;\n\t    }\n\t}\n\n      free (cur_path);\n      CLOSEDIR (dirp);\n    }\n\n  if (subdirs_unreliable)\n    {\n      /* Make sure we hasn't used the variable subdirs_left if we knew\n       * we shouldn't do so.\n       */\n      assert (0 == subdirs_left || options.no_leaf_check);\n    }\n}",
      "lines": 272,
      "depth": 20,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "findutils/findutils-4.6.0/find/parser.c": {
    "fallback_getfilecon": {
      "start_point": [
        335,
        0
      ],
      "end_point": [
        362,
        1
      ],
      "content": "static int\nfallback_getfilecon (int fd, const char *name, security_context_t *p,\n\t\t     int prev_rv)\n{\n  /* Our original getfilecon () call failed.  Perhaps we can't follow a\n   * symbolic link.  If that might be the problem, lgetfilecon () the link.\n   * Otherwise, admit defeat. */\n  switch (errno)\n    {\n      case ENOENT:\n      case ENOTDIR:\n#ifdef DEBUG_STAT\n\tfprintf (stderr, \"fallback_getfilecon(): getfilecon(%s) failed; falling \"\n\t\t\t\"back on lgetfilecon()\\n\", name);\n#endif\n\treturn lgetfileconat (fd, name, p);\n\n      case EACCES:\n      case EIO:\n      case ELOOP:\n      case ENAMETOOLONG:\n#ifdef EOVERFLOW\n      case EOVERFLOW:        /* EOVERFLOW is not #defined on UNICOS. */\n#endif\n      default:\n\treturn prev_rv;\n    }\n}",
      "lines": 28,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "optionh_getfilecon": {
      "start_point": [
        373,
        0
      ],
      "end_point": [
        392,
        1
      ],
      "content": "static int\noptionh_getfilecon (int fd, const char *name, security_context_t *p)\n{\n  int rv;\n  if (0 == state.curdepth)\n    {\n      /* This file is from the command line; dereference the link (if it is\n\t a link). */\n      rv = getfileconat (fd, name, p);\n      if (0 == rv)\n\treturn 0;               /* success */\n      else\n\treturn fallback_getfilecon (fd, name, p, rv);\n    }\n  else\n    {\n      /* Not a file on the command line; do not dereference the link. */\n      return lgetfileconat (fd, name, p);\n    }\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "optionl_getfilecon": {
      "start_point": [
        397,
        0
      ],
      "end_point": [
        405,
        1
      ],
      "content": "static int\noptionl_getfilecon (int fd, const char *name, security_context_t *p)\n{\n  int rv = getfileconat (fd, name, p);\n  if (0 == rv)\n    return 0;                  /* normal case. */\n  else\n    return fallback_getfilecon (fd, name, p, rv);\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "optionp_getfilecon": {
      "start_point": [
        410,
        0
      ],
      "end_point": [
        414,
        1
      ],
      "content": "static int\noptionp_getfilecon (int fd, const char *name, security_context_t *p)\n{\n  return lgetfileconat (fd, name, p);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "check_option_combinations": {
      "start_point": [
        416,
        0
      ],
      "end_point": [
        457,
        1
      ],
      "content": "void\ncheck_option_combinations (const struct predicate *p)\n{\n  enum { seen_delete=1u, seen_prune=2u };\n  unsigned int predicates = 0u;\n\n  while (p)\n    {\n      if (p->pred_func == pred_delete)\n\tpredicates |= seen_delete;\n      else if (p->pred_func == pred_prune)\n\tpredicates |= seen_prune;\n      p = p->pred_next;\n    }\n\n  if ((predicates & seen_prune) && (predicates & seen_delete))\n    {\n      /* The user specified both -delete and -prune.  One might test\n       * this by first doing\n       *    find dirs   .... -prune ..... -print\n       * to fnd out what's going to get deleted, and then switch to\n       *    find dirs   .... -prune ..... -delete\n       * once we are happy.  Unfortunately, the -delete action also\n       * implicitly turns on -depth, which will affect the behaviour\n       * of -prune (in fact, it makes it a no-op).  In this case we\n       * would like to prevent unfortunate accidents, so we require\n       * the user to have explicitly used -depth.\n       *\n       * We only get away with this because the -delete predicate is not\n       * in POSIX.   If it was, we couldn't issue a fatal error here.\n       */\n      if (!options.explicit_depth)\n\t{\n\t  /* This fixes Savannah bug #20865. */\n\t  error (EXIT_FAILURE, 0,\n\t\t _(\"The -delete action automatically turns on -depth, \"\n\t\t   \"but -prune does nothing when -depth is in effect.  \"\n\t\t   \"If you want to carry on anyway, just explicitly use \"\n\t\t   \"the -depth option.\"));\n\t}\n    }\n}",
      "lines": 42,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "get_noop": {
      "start_point": [
        460,
        0
      ],
      "end_point": [
        476,
        1
      ],
      "content": "static const struct parser_table*\nget_noop (void)\n{\n  int i;\n  if (NULL == noop)\n    {\n      for (i = 0; parse_table[i].parser_name != 0; i++)\n\t{\n\t  if (ARG_NOOP ==parse_table[i].type)\n\t    {\n\t      noop = &(parse_table[i]);\n\t      break;\n\t    }\n\t}\n    }\n  return noop;\n}",
      "lines": 17,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "struct parser_table",
        "struct",
        "parser_table",
        "*\nget_noop (void)",
        "*"
      ]
    },
    "get_stat_Ytime": {
      "start_point": [
        478,
        0
      ],
      "end_point": [
        501,
        1
      ],
      "content": "static int\nget_stat_Ytime (const struct stat *p,\n\t\tchar what,\n\t\tstruct timespec *ret)\n{\n  switch (what)\n    {\n    case 'a':\n      *ret = get_stat_atime (p);\n      return 1;\n    case 'B':\n      *ret = get_stat_birthtime (p);\n      return (ret->tv_nsec >= 0);\n    case 'c':\n      *ret = get_stat_ctime (p);\n      return 1;\n    case 'm':\n      *ret = get_stat_mtime (p);\n      return 1;\n    default:\n      assert (0);\n      abort ();\n    }\n}",
      "lines": 24,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "set_follow_state": {
      "start_point": [
        503,
        0
      ],
      "end_point": [
        538,
        1
      ],
      "content": "void\nset_follow_state (enum SymlinkOption opt)\n{\n  if (options.debug_options & DebugStat)\n    {\n      /* For DebugStat, the choice is made at runtime within debug_stat()\n       * by checking the contents of the symlink_handling variable.\n       */\n      options.xstat = debug_stat;\n    }\n  else\n    {\n      switch (opt)\n\t{\n\tcase SYMLINK_ALWAYS_DEREF:  /* -L */\n\t  options.xstat = optionl_stat;\n\t  options.x_getfilecon = optionl_getfilecon;\n\t  options.no_leaf_check = true;\n\t  break;\n\n\tcase SYMLINK_NEVER_DEREF:\t/* -P (default) */\n\t  options.xstat = optionp_stat;\n\t  options.x_getfilecon = optionp_getfilecon;\n\t  /* Can't turn no_leaf_check off because the user might have specified\n\t   * -noleaf anyway\n\t   */\n\t  break;\n\n\tcase SYMLINK_DEREF_ARGSONLY: /* -H */\n\t  options.xstat = optionh_stat;\n\t  options.x_getfilecon = optionh_getfilecon;\n\t  options.no_leaf_check = true;\n\t}\n    }\n  options.symlink_handling = opt;\n}",
      "lines": 36,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "parse_begin_user_args": {
      "start_point": [
        541,
        0
      ],
      "end_point": [
        551,
        1
      ],
      "content": "void\nparse_begin_user_args (char **args, int argno,\n\t\t       const struct predicate *last,\n\t\t       const struct predicate *predicates)\n{\n  (void) args;\n  (void) argno;\n  (void) last;\n  (void) predicates;\n  first_nonoption_arg = NULL;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "parse_end_user_args": {
      "start_point": [
        553,
        0
      ],
      "end_point": [
        563,
        1
      ],
      "content": "void\nparse_end_user_args (char **args, int argno,\n\t\t     const struct predicate *last,\n\t\t     const struct predicate *predicates)\n{\n  /* does nothing */\n  (void) args;\n  (void) argno;\n  (void) last;\n  (void) predicates;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "should_issue_warnings": {
      "start_point": [
        565,
        0
      ],
      "end_point": [
        572,
        1
      ],
      "content": "static bool\nshould_issue_warnings (void)\n{\n  if (options.posixly_correct)\n    return false;\n  else\n    return options.warnings;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "found_parser": {
      "start_point": [
        578,
        0
      ],
      "end_point": [
        632,
        1
      ],
      "content": "static const struct parser_table*\nfound_parser (const char *original_arg, const struct parser_table *entry)\n{\n  /* If this is an option, but we have already had a\n   * non-option argument, the user may be under the\n   * impression that the behaviour of the option\n   * argument is conditional on some preceding\n   * tests.  This might typically be the case with,\n   * for example, -maxdepth.\n   *\n   * The options -daystart and -follow are exempt\n   * from this treatment, since their positioning\n   * in the command line does have an effect on\n   * subsequent tests but not previous ones.  That\n   * might be intentional on the part of the user.\n   */\n  if (entry->type != ARG_POSITIONAL_OPTION)\n    {\n      /* Something other than -follow/-daystart.\n       * If this is an option, check if it followed\n       * a non-option and if so, issue a warning.\n       */\n      if (entry->type == ARG_OPTION)\n\t{\n\t  if ((first_nonoption_arg != NULL)\n\t      && should_issue_warnings ())\n\t    {\n\t      /* option which follows a non-option */\n\t      error (0, 0,\n\t\t     _(\"warning: you have specified the %s \"\n\t\t       \"option after a non-option argument %s, \"\n\t\t       \"but options are not positional (%s affects \"\n\t\t       \"tests specified before it as well as those \"\n\t\t       \"specified after it).  Please specify options \"\n\t\t       \"before other arguments.\\n\"),\n\t\t     original_arg,\n\t\t     first_nonoption_arg,\n\t\t     original_arg);\n\t    }\n\t}\n      else\n\t{\n\t  /* Not an option or a positional option,\n\t   * so remember we've seen it in order to\n\t   * use it in a possible future warning message.\n\t   */\n\t  if (first_nonoption_arg == NULL)\n\t    {\n\t      first_nonoption_arg = original_arg;\n\t    }\n\t}\n    }\n\n  return entry;\n}",
      "lines": 55,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "struct parser_table",
        "struct",
        "parser_table",
        "*\nfound_parser (const char *original_arg, const struct parser_table *entry)",
        "*"
      ]
    },
    "find_parser": {
      "start_point": [
        639,
        0
      ],
      "end_point": [
        663,
        1
      ],
      "content": "const struct parser_table*\nfind_parser (const char *search_name)\n{\n  int i;\n  const char *original_arg = search_name;\n\n  /* Ugh.  Special case -newerXY. */\n  if (0 == strncmp (\"-newer\", search_name, 6)\n      && (8 == strlen (search_name)))\n    {\n      return found_parser (original_arg, &parse_entry_newerXY);\n    }\n\n  if (*search_name == '-')\n    search_name++;\n\n  for (i = 0; parse_table[i].parser_name != 0; i++)\n    {\n      if (strcmp (parse_table[i].parser_name, search_name) == 0)\n\t{\n\t  return found_parser (original_arg, &parse_table[i]);\n\t}\n    }\n  return NULL;\n}",
      "lines": 25,
      "depth": 12,
      "decorators": [
        "const",
        "const",
        "struct parser_table",
        "struct",
        "parser_table",
        "*\nfind_parser (const char *search_name)",
        "*"
      ]
    },
    "estimate_file_age_success_rate": {
      "start_point": [
        665,
        0
      ],
      "end_point": [
        688,
        1
      ],
      "content": "static float\nestimate_file_age_success_rate (float num_days)\n{\n  if (num_days < 0.1)\n    {\n      /* Assume 1% of files have timestamps in the future */\n      return 0.01f;\n    }\n  else if (num_days < 1)\n    {\n      /* Assume 30% of files have timestamps today */\n      return 0.3f;\n    }\n  else if (num_days > 100)\n    {\n      /* Assume 30% of files are very old */\n      return 0.3f;\n    }\n  else\n    {\n      /* Assume 39% of files are between 1 and 100 days old. */\n      return 0.39f;\n    }\n}",
      "lines": 24,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "float"
      ]
    },
    "estimate_timestamp_success_rate": {
      "start_point": [
        690,
        0
      ],
      "end_point": [
        699,
        1
      ],
      "content": "static float\nestimate_timestamp_success_rate (time_t when)\n{\n  /* This calculation ignores the nanoseconds field of the\n   * origin, but I don't think that makes much difference\n   * to our estimate.\n   */\n  int num_days = (options.cur_day_start.tv_sec - when) / 86400;\n  return estimate_file_age_success_rate (num_days);\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "float"
      ]
    },
    "collect_arg_nonconst": {
      "start_point": [
        704,
        0
      ],
      "end_point": [
        718,
        1
      ],
      "content": "static bool\ncollect_arg_nonconst (char **argv, int *arg_ptr, char **collected_arg)\n{\n  if ((argv == NULL) || (argv[*arg_ptr] == NULL))\n    {\n      *collected_arg = NULL;\n      return false;\n    }\n  else\n    {\n      *collected_arg = argv[*arg_ptr];\n      (*arg_ptr)++;\n      return true;\n    }\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "collect_arg": {
      "start_point": [
        720,
        0
      ],
      "end_point": [
        727,
        1
      ],
      "content": "static bool\ncollect_arg (char **argv, int *arg_ptr, const char **collected_arg)\n{\n  char *arg;\n  const bool result = collect_arg_nonconst (argv, arg_ptr, &arg);\n  *collected_arg = arg;\n  return result;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "collect_arg_stat_info": {
      "start_point": [
        731,
        0
      ],
      "end_point": [
        753,
        1
      ],
      "content": "static bool\ncollect_arg_stat_info (char **argv, int *arg_ptr, struct stat *p,\n\t\t       const char **argument)\n{\n  const char *filename;\n  if (collect_arg (argv, arg_ptr, &filename))\n    {\n      *argument = filename;\n      if (0 == (options.xstat)(filename, p))\n\t{\n\t  return true;\n\t}\n      else\n\t{\n\t  fatal_target_file_error (errno, filename);\n\t}\n    }\n  else\n    {\n      *argument = NULL;\n      return false;\n    }\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "parse_and": {
      "start_point": [
        766,
        0
      ],
      "end_point": [
        780,
        1
      ],
      "content": "static bool\nparse_and (const struct parser_table* entry, char **argv, int *arg_ptr)\n{\n  struct predicate *our_pred;\n\n  (void) argv;\n  (void) arg_ptr;\n\n  our_pred = get_new_pred_noarg (entry);\n  our_pred->pred_func = pred_and;\n  our_pred->p_type = BI_OP;\n  our_pred->p_prec = AND_PREC;\n  our_pred->need_stat = our_pred->need_type = false;\n  return true;\n}",
      "lines": 15,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "parse_anewer": {
      "start_point": [
        782,
        0
      ],
      "end_point": [
        799,
        1
      ],
      "content": "static bool\nparse_anewer (const struct parser_table* entry, char **argv, int *arg_ptr)\n{\n  struct stat stat_newer;\n  const char *arg;\n\n  set_stat_placeholders (&stat_newer);\n  if (collect_arg_stat_info (argv, arg_ptr, &stat_newer, &arg))\n    {\n      struct predicate *our_pred = insert_primary (entry, arg);\n      our_pred->args.reftime.xval = XVAL_ATIME;\n      our_pred->args.reftime.ts = get_stat_mtime (&stat_newer);\n      our_pred->args.reftime.kind = COMP_GT;\n      our_pred->est_success_rate = estimate_timestamp_success_rate (stat_newer.st_mtime);\n      return true;\n    }\n  return false;\n}",
      "lines": 18,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "parse_closeparen": {
      "start_point": [
        801,
        0
      ],
      "end_point": [
        815,
        1
      ],
      "content": "bool\nparse_closeparen (const struct parser_table* entry, char **argv, int *arg_ptr)\n{\n  struct predicate *our_pred;\n\n  (void) argv;\n  (void) arg_ptr;\n\n  our_pred = get_new_pred_noarg (entry);\n  our_pred->pred_func = pred_closeparen;\n  our_pred->p_type = CLOSE_PAREN;\n  our_pred->p_prec = NO_PREC;\n  our_pred->need_stat = our_pred->need_type = false;\n  return true;\n}",
      "lines": 15,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    },
    "parse_cnewer": {
      "start_point": [
        817,
        0
      ],
      "end_point": [
        834,
        1
      ],
      "content": "static bool\nparse_cnewer (const struct parser_table* entry, char **argv, int *arg_ptr)\n{\n  struct stat stat_newer;\n  const char *arg;\n\n  set_stat_placeholders (&stat_newer);\n  if (collect_arg_stat_info (argv, arg_ptr, &stat_newer, &arg))\n    {\n      struct predicate *our_pred = insert_primary (entry, arg);\n      our_pred->args.reftime.xval = XVAL_CTIME; /* like -newercm */\n      our_pred->args.reftime.ts = get_stat_mtime (&stat_newer);\n      our_pred->args.reftime.kind = COMP_GT;\n      our_pred->est_success_rate = estimate_timestamp_success_rate (stat_newer.st_mtime);\n      return true;\n    }\n  return false;\n}",
      "lines": 18,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "parse_comma": {
      "start_point": [
        836,
        0
      ],
      "end_point": [
        851,
        1
      ],
      "content": "static bool\nparse_comma (const struct parser_table* entry, char **argv, int *arg_ptr)\n{\n  struct predicate *our_pred;\n\n  (void) argv;\n  (void) arg_ptr;\n\n  our_pred = get_new_pred_noarg (entry);\n  our_pred->pred_func = pred_comma;\n  our_pred->p_type = BI_OP;\n  our_pred->p_prec = COMMA_PREC;\n  our_pred->need_stat = our_pred->need_type = false;\n  our_pred->est_success_rate = 1.0f;\n  return true;\n}",
      "lines": 16,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "parse_daystart": {
      "start_point": [
        853,
        0
      ],
      "end_point": [
        874,
        1
      ],
      "content": "static bool\nparse_daystart (const struct parser_table* entry, char **argv, int *arg_ptr)\n{\n  struct tm *local;\n\n  (void) entry;\n  (void) argv;\n  (void) arg_ptr;\n\n  if (options.full_days == false)\n    {\n      options.cur_day_start.tv_sec += DAYSECS;\n      options.cur_day_start.tv_nsec = 0;\n      local = localtime (&options.cur_day_start.tv_sec);\n      options.cur_day_start.tv_sec -= (local\n\t\t\t\t       ? (local->tm_sec + local->tm_min * 60\n\t\t\t\t\t  + local->tm_hour * 3600)\n\t\t\t\t       : options.cur_day_start.tv_sec % DAYSECS);\n      options.full_days = true;\n    }\n  return true;\n}",
      "lines": 22,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "parse_delete": {
      "start_point": [
        876,
        0
      ],
      "end_point": [
        895,
        1
      ],
      "content": "static bool\nparse_delete (const struct parser_table* entry, char *argv[], int *arg_ptr)\n{\n  struct predicate *our_pred;\n  (void) argv;\n  (void) arg_ptr;\n\n  our_pred = insert_primary_noarg (entry);\n  our_pred->side_effects = our_pred->no_default_print = true;\n  /* -delete implies -depth */\n  options.do_dir_first = false;\n\n  /* We do not need stat information because we check for the case\n   * (errno==EISDIR) in pred_delete.\n   */\n  our_pred->need_stat = our_pred->need_type = false;\n\n  our_pred->est_success_rate = 1.0f;\n  return true;\n}",
      "lines": 20,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "parse_depth": {
      "start_point": [
        897,
        0
      ],
      "end_point": [
        906,
        1
      ],
      "content": "static bool\nparse_depth (const struct parser_table* entry, char **argv, int *arg_ptr)\n{\n  (void) entry;\n  (void) argv;\n\n  options.do_dir_first = false;\n  options.explicit_depth = true;\n  return parse_noop (entry, argv, arg_ptr);\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "parse_d": {
      "start_point": [
        908,
        0
      ],
      "end_point": [
        919,
        1
      ],
      "content": "static bool\nparse_d (const struct parser_table* entry, char **argv, int *arg_ptr)\n{\n  if (should_issue_warnings ())\n    {\n      error (0, 0,\n\t     _(\"warning: the -d option is deprecated; please use \"\n\t       \"-depth instead, because the latter is a \"\n\t       \"POSIX-compliant feature.\"));\n    }\n  return parse_depth (entry, argv, arg_ptr);\n}",
      "lines": 12,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "parse_empty": {
      "start_point": [
        921,
        0
      ],
      "end_point": [
        931,
        1
      ],
      "content": "static bool\nparse_empty (const struct parser_table* entry, char **argv, int *arg_ptr)\n{\n  struct predicate *our_pred;\n  (void) argv;\n  (void) arg_ptr;\n\n  our_pred = insert_primary_noarg (entry);\n  our_pred->est_success_rate = 0.01f; /* assume 1% of files are empty. */\n  return true;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "parse_exec": {
      "start_point": [
        933,
        0
      ],
      "end_point": [
        937,
        1
      ],
      "content": "static bool\nparse_exec (const struct parser_table* entry, char **argv, int *arg_ptr)\n{\n  return insert_exec_ok (\"-exec\", entry, argv, arg_ptr);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "parse_execdir": {
      "start_point": [
        939,
        0
      ],
      "end_point": [
        943,
        1
      ],
      "content": "static bool\nparse_execdir (const struct parser_table* entry, char **argv, int *arg_ptr)\n{\n  return insert_exec_ok (\"-execdir\", entry, argv, arg_ptr);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "insert_false": {
      "start_point": [
        945,
        0
      ],
      "end_point": [
        957,
        1
      ],
      "content": "static bool\ninsert_false(void)\n{\n  struct predicate *our_pred;\n  const struct parser_table *entry_false;\n\n  entry_false = find_parser(\"false\");\n  our_pred = insert_primary_noarg (entry_false);\n  our_pred->need_stat = our_pred->need_type = false;\n  our_pred->side_effects = our_pred->no_default_print = false;\n  our_pred->est_success_rate = 0.0f;\n  return true;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "parse_false": {
      "start_point": [
        960,
        0
      ],
      "end_point": [
        967,
        1
      ],
      "content": "static bool\nparse_false (const struct parser_table* entry, char **argv, int *arg_ptr)\n{\n  (void) entry;\n  (void) argv;\n  (void) arg_ptr;\n  return insert_false ();\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "insert_fls": {
      "start_point": [
        969,
        0
      ],
      "end_point": [
        980,
        1
      ],
      "content": "static bool\ninsert_fls (const struct parser_table* entry, const char *filename)\n{\n  struct predicate *our_pred = insert_primary_noarg (entry);\n  if (filename)\n    open_output_file (filename, &our_pred->args.printf_vec);\n  else\n    open_stdout (&our_pred->args.printf_vec);\n  our_pred->side_effects = our_pred->no_default_print = true;\n  our_pred->est_success_rate = 1.0f;\n  return true;\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "parse_fls": {
      "start_point": [
        983,
        0
      ],
      "end_point": [
        995,
        1
      ],
      "content": "static bool\nparse_fls (const struct parser_table* entry, char **argv, int *arg_ptr)\n{\n  const char *filename;\n  if (collect_arg (argv, arg_ptr, &filename))\n    {\n      if (insert_fls (entry, filename))\n\treturn true;\n      else\n\t--*arg_ptr;\t\t/* don't consume the invalid arg. */\n    }\n  return false;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "parse_follow": {
      "start_point": [
        997,
        0
      ],
      "end_point": [
        1002,
        1
      ],
      "content": "static bool\nparse_follow (const struct parser_table* entry, char **argv, int *arg_ptr)\n{\n  set_follow_state (SYMLINK_ALWAYS_DEREF);\n  return parse_noop (entry, argv, arg_ptr);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "parse_fprint": {
      "start_point": [
        1004,
        0
      ],
      "end_point": [
        1022,
        1
      ],
      "content": "static bool\nparse_fprint (const struct parser_table* entry, char **argv, int *arg_ptr)\n{\n  struct predicate *our_pred;\n  const char *filename;\n  if (collect_arg (argv, arg_ptr, &filename))\n    {\n      our_pred = insert_primary (entry, filename);\n      open_output_file (filename, &our_pred->args.printf_vec);\n      our_pred->side_effects = our_pred->no_default_print = true;\n      our_pred->need_stat = our_pred->need_type = false;\n      our_pred->est_success_rate = 1.0f;\n      return true;\n    }\n  else\n    {\n      return false;\n    }\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "insert_fprint": {
      "start_point": [
        1024,
        0
      ],
      "end_point": [
        1036,
        1
      ],
      "content": "static bool\ninsert_fprint (const struct parser_table* entry, const char *filename)\n{\n  struct predicate *our_pred = insert_primary (entry, filename);\n  if (filename)\n    open_output_file (filename, &our_pred->args.printf_vec);\n  else\n    open_stdout (&our_pred->args.printf_vec);\n  our_pred->side_effects = our_pred->no_default_print = true;\n  our_pred->need_stat = our_pred->need_type = false;\n  our_pred->est_success_rate = 1.0f;\n  return true;\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "parse_fprint0": {
      "start_point": [
        1039,
        0
      ],
      "end_point": [
        1051,
        1
      ],
      "content": "static bool\nparse_fprint0 (const struct parser_table* entry, char **argv, int *arg_ptr)\n{\n  const char *filename;\n  if (collect_arg (argv, arg_ptr, &filename))\n    {\n      if (insert_fprint (entry, filename))\n\treturn true;\n      else\n\t--*arg_ptr;\t\t/* don't consume the bad arg. */\n    }\n  return false;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "estimate_fstype_success_rate": {
      "start_point": [
        1053,
        0
      ],
      "end_point": [
        1067,
        1
      ],
      "content": "static float estimate_fstype_success_rate (const char *fsname)\n{\n  struct stat dir_stat;\n  const char *the_root_dir = \"/\";\n  if (0 == stat (the_root_dir, &dir_stat)) /* it's an absolute path anyway */\n    {\n      const char *fstype = filesystem_type (&dir_stat, the_root_dir);\n      /* Assume most files are on the same file system type as the root fs. */\n      if (0 == strcmp (fsname, fstype))\n\t  return 0.7f;\n      else\n\treturn 0.3f;\n    }\n  return 1.0f;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "float"
      ]
    },
    "is_used_fs_type": {
      "start_point": [
        1071,
        0
      ],
      "end_point": [
        1098,
        1
      ],
      "content": "static bool\nis_used_fs_type(const char *name)\n{\n  if (0 == strcmp(\"afs\", name))\n    {\n      /* I guess AFS may not appear in /etc/mtab (or equivalent) but still be in use,\n\t so assume we always need to check for AFS.  */\n      return true;\n    }\n  else\n    {\n      const struct mount_entry *entries = read_file_system_list(false);\n      if (entries)\n\t{\n\t  const struct mount_entry *entry;\n\t  for (entry = entries; entry; entry = entry->me_next)\n\t    {\n\t      if (0 == strcmp(name, entry->me_type))\n\t\treturn true;\n\t    }\n\t}\n      else\n\t{\n\t  return true;\n\t}\n    }\n  return false;\n}",
      "lines": 28,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "parse_fstype": {
      "start_point": [
        1101,
        0
      ],
      "end_point": [
        1139,
        1
      ],
      "content": "static bool\nparse_fstype (const struct parser_table* entry, char **argv, int *arg_ptr)\n{\n  const char *typename;\n  if (collect_arg (argv, arg_ptr, &typename))\n    {\n      if (options.optimisation_level < 2 || is_used_fs_type (typename))\n\t{\n\t  struct predicate *our_pred = insert_primary (entry, typename);\n\t  our_pred->args.str = typename;\n\n\t  /* This is an expensive operation, so although there are\n\t   * circumstances where it is selective, we ignore this fact\n\t   * because we probably don't want to promote this test to the\n\t   * front anyway.\n\t   */\n\t  our_pred->est_success_rate = estimate_fstype_success_rate (typename);\n\t  return true;\n\t}\n      else\n\t{\n\t  /* This filesystem type is not listed in the mount table.\n\t   * Hence this predicate will always return false (with this argument).\n\t   * Substitute a predicate with the same effect as -false.\n\t   */\n\t  if (options.debug_options & DebugTreeOpt)\n\t    {\n\t      fprintf (stderr,\n\t\t       \"-fstype %s can never succeed, substituting -false\\n\",\n\t\t       typename);\n\t    }\n\t  return insert_false ();\n\t}\n    }\n  else\n    {\n      return false;\n    }\n}",
      "lines": 39,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "parse_gid": {
      "start_point": [
        1141,
        0
      ],
      "end_point": [
        1155,
        1
      ],
      "content": "static bool\nparse_gid (const struct parser_table* entry, char **argv, int *arg_ptr)\n{\n  struct predicate *p = insert_num (argv, arg_ptr, entry);\n  if (p)\n    {\n      p->est_success_rate = (p->args.numinfo.l_val < 100) ? 0.99 : 0.2;\n      return true;\n    }\n  else\n    {\n      --*arg_ptr;\t\t/* don't consume the invalid argument. */\n      return false;\n    }\n}",
      "lines": 15,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "parse_group": {
      "start_point": [
        1158,
        0
      ],
      "end_point": [
        1220,
        1
      ],
      "content": "static bool\nparse_group (const struct parser_table* entry, char **argv, int *arg_ptr)\n{\n  const char *groupname;\n  const int saved_argc = *arg_ptr;\n\n  if (collect_arg (argv, arg_ptr, &groupname))\n    {\n      gid_t gid;\n      struct predicate *our_pred;\n      struct group *cur_gr = getgrnam (groupname);\n      endgrent ();\n      if (cur_gr)\n\t{\n\t  gid = cur_gr->gr_gid;\n\t}\n      else\n\t{\n\t  const int gid_len = strspn (groupname, \"0123456789\");\n\t  if (gid_len)\n\t    {\n\t      if (groupname[gid_len] == 0)\n\t\t{\n\t\t  gid = safe_atoi (groupname, options.err_quoting_style);\n\t\t}\n\t      else\n\t\t{\n\t\t  /* XXX: no test in test suite for this */\n\t\t  error (EXIT_FAILURE, 0,\n\t\t\t _(\"%s is not the name of an existing group and\"\n\t\t\t   \" it does not look like a numeric group ID \"\n\t\t\t   \"because it has the unexpected suffix %s\"),\n\t\t\t quotearg_n_style (0, options.err_quoting_style, groupname),\n\t\t\t quotearg_n_style (1, options.err_quoting_style, groupname+gid_len));\n\t\t  *arg_ptr = saved_argc; /* don't consume the invalid argument. */\n\t\t  return false;\n\t\t}\n\t    }\n\t  else\n\t    {\n\t      if (*groupname)\n\t\t{\n\t\t  /* XXX: no test in test suite for this */\n\t\t  error (EXIT_FAILURE, 0,\n\t\t\t _(\"%s is not the name of an existing group\"),\n\t\t\t quotearg_n_style (0, options.err_quoting_style, groupname));\n\t\t}\n\t      else\n\t\t{\n\t\t  error (EXIT_FAILURE, 0,\n\t\t\t _(\"argument to -group is empty, but should be a group name\"));\n\t\t}\n\t      *arg_ptr = saved_argc; /* don't consume the invalid argument. */\n\t      return false;\n\t    }\n\t}\n      our_pred = insert_primary (entry, groupname);\n      our_pred->args.gid = gid;\n      our_pred->est_success_rate = (our_pred->args.numinfo.l_val < 100) ? 0.99 : 0.2;\n      return true;\n    }\n  return false;\n}",
      "lines": 63,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "parse_help": {
      "start_point": [
        1222,
        0
      ],
      "end_point": [
        1264,
        1
      ],
      "content": "static bool\nparse_help (const struct parser_table* entry, char **argv, int *arg_ptr)\n{\n  (void) entry;\n  (void) argv;\n  (void) arg_ptr;\n\n  usage (stdout, 0, NULL);\n  puts (_(\"\\n\\\ndefault path is the current directory; default expression is -print\\n\\\nexpression may consist of: operators, options, tests, and actions:\\n\"));\n  puts (_(\"\\\noperators (decreasing precedence; -and is implicit where no others are given):\\n\\\n      ( EXPR )   ! EXPR   -not EXPR   EXPR1 -a EXPR2   EXPR1 -and EXPR2\\n\\\n      EXPR1 -o EXPR2   EXPR1 -or EXPR2   EXPR1 , EXPR2\\n\"));\n  puts (_(\"\\\npositional options (always true): -daystart -follow -regextype\\n\\n\\\nnormal options (always true, specified before other expressions):\\n\\\n      -depth --help -maxdepth LEVELS -mindepth LEVELS -mount -noleaf\\n\\\n      --version -xdev -ignore_readdir_race -noignore_readdir_race\\n\"));\n  puts (_(\"\\\ntests (N can be +N or -N or N): -amin N -anewer FILE -atime N -cmin N\\n\\\n      -cnewer FILE -ctime N -empty -false -fstype TYPE -gid N -group NAME\\n\\\n      -ilname PATTERN -iname PATTERN -inum N -iwholename PATTERN -iregex PATTERN\\n\\\n      -links N -lname PATTERN -mmin N -mtime N -name PATTERN -newer FILE\"));\n  puts (_(\"\\\n      -nouser -nogroup -path PATTERN -perm [-/]MODE -regex PATTERN\\n\\\n      -readable -writable -executable\\n\\\n      -wholename PATTERN -size N[bcwkMG] -true -type [bcdpflsD] -uid N\\n\\\n      -used N -user NAME -xtype [bcdpfls]\"));\n  puts (_(\"\\\n      -context CONTEXT\\n\"));\n  puts (_(\"\\n\\\nactions: -delete -print0 -printf FORMAT -fprintf FILE FORMAT -print \\n\\\n      -fprint0 FILE -fprint FILE -ls -fls FILE -prune -quit\\n\\\n      -exec COMMAND ; -exec COMMAND {} + -ok COMMAND ;\\n\\\n      -execdir COMMAND ; -execdir COMMAND {} + -okdir COMMAND ;\\n\\\n\"));\n  puts (_(\"Report (and track progress on fixing) bugs via the findutils bug-reporting\\n\\\npage at http://savannah.gnu.org/ or, if you have no web access, by sending\\n\\\nemail to <bug-findutils@gnu.org>.\"));\n  exit (EXIT_SUCCESS);\n}",
      "lines": 43,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "estimate_pattern_match_rate": {
      "start_point": [
        1266,
        0
      ],
      "end_point": [
        1278,
        1
      ],
      "content": "static float\nestimate_pattern_match_rate (const char *pattern, int is_regex)\n{\n  if (strpbrk (pattern, \"*?[\") || (is_regex && strpbrk(pattern, \".\")))\n    {\n      /* A wildcard; assume the pattern matches most files. */\n      return 0.8f;\n    }\n  else\n    {\n      return 0.1f;\n    }\n}",
      "lines": 13,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "float"
      ]
    },
    "parse_ilname": {
      "start_point": [
        1280,
        0
      ],
      "end_point": [
        1298,
        1
      ],
      "content": "static bool\nparse_ilname (const struct parser_table* entry, char **argv, int *arg_ptr)\n{\n  const char *name;\n  if (collect_arg (argv, arg_ptr, &name))\n    {\n      struct predicate *our_pred = insert_primary (entry, name);\n      our_pred->args.str = name;\n      /* Use the generic glob pattern estimator to figure out how many\n       * links will match, but bear in mind that most files won't be links.\n       */\n      our_pred->est_success_rate = 0.1 * estimate_pattern_match_rate (name, 0);\n      return true;\n    }\n  else\n    {\n      return false;\n    }\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "fnmatch_sanitycheck": {
      "start_point": [
        1304,
        0
      ],
      "end_point": [
        1321,
        1
      ],
      "content": "static bool\nfnmatch_sanitycheck (void)\n{\n  static bool checked = false;\n  if (!checked)\n    {\n      if (0 != fnmatch (\"foo\", \"foo\", 0)\n\t  || 0 == fnmatch (\"Foo\", \"foo\", 0)\n\t  || 0 != fnmatch (\"Foo\", \"foo\", FNM_CASEFOLD))\n\t{\n\t  error (EXIT_FAILURE, 0,\n\t\t _(\"sanity check of the fnmatch() library function failed.\"));\n\t  return false;\n\t}\n      checked = true;\n    }\n  return checked;\n}",
      "lines": 18,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "check_name_arg": {
      "start_point": [
        1324,
        0
      ],
      "end_point": [
        1341,
        1
      ],
      "content": "static bool\ncheck_name_arg (const char *pred, const char *arg)\n{\n  if (should_issue_warnings () && strchr (arg, '/'))\n    {\n      error (0, 0,_(\"warning: Unix filenames usually don't contain slashes \"\n\t\t    \"(though pathnames do).  That means that '%s %s' will \"\n\t\t    \"probably evaluate to false all the time on this system.  \"\n\t\t    \"You might find the '-wholename' test more useful, or \"\n\t\t    \"perhaps '-samefile'.  Alternatively, if you are using \"\n\t\t    \"GNU grep, you could \"\n\t\t    \"use 'find ... -print0 | grep -FzZ %s'.\"),\n\t    pred,\n\t    safely_quote_err_filename (0, arg),\n\t    safely_quote_err_filename (1, arg));\n    }\n  return true;\t\t\t/* allow it anyway */\n}",
      "lines": 18,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "parse_iname": {
      "start_point": [
        1345,
        0
      ],
      "end_point": [
        1362,
        1
      ],
      "content": "static bool\nparse_iname (const struct parser_table* entry, char **argv, int *arg_ptr)\n{\n  const char *name;\n  fnmatch_sanitycheck ();\n  if (collect_arg (argv, arg_ptr, &name))\n    {\n      if (check_name_arg (\"-iname\", name))\n\t{\n\t  struct predicate *our_pred = insert_primary (entry, name);\n\t  our_pred->need_stat = our_pred->need_type = false;\n\t  our_pred->args.str = name;\n\t  our_pred->est_success_rate = estimate_pattern_match_rate (name, 0);\n\t  return true;\n\t}\n    }\n  return false;\n}",
      "lines": 18,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "parse_inum": {
      "start_point": [
        1364,
        0
      ],
      "end_point": [
        1384,
        1
      ],
      "content": "static bool\nparse_inum (const struct parser_table* entry, char **argv, int *arg_ptr)\n{\n  struct predicate *p =  insert_num (argv, arg_ptr, entry);\n  if (p)\n    {\n      /* inode number is exact match only, so very low proportions of\n       * files match\n       */\n      p->est_success_rate = 1e-6;\n      p->need_inum = true;\n      p->need_stat = false;\n      p->need_type = false;\n      return true;\n    }\n  else\n    {\n      --*arg_ptr;\t\t/* don't consume the invalid argument. */\n      return false;\n    }\n}",
      "lines": 21,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "parse_iregex": {
      "start_point": [
        1386,
        0
      ],
      "end_point": [
        1390,
        1
      ],
      "content": "static bool\nparse_iregex (const struct parser_table* entry, char **argv, int *arg_ptr)\n{\n  return insert_regex (argv, arg_ptr, entry, RE_ICASE|options.regex_options);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "parse_links": {
      "start_point": [
        1392,
        0
      ],
      "end_point": [
        1411,
        1
      ],
      "content": "static bool\nparse_links (const struct parser_table* entry, char **argv, int *arg_ptr)\n{\n  struct predicate *p = insert_num (argv, arg_ptr, entry);\n  if (p)\n    {\n      if (p->args.numinfo.l_val == 1)\n\tp->est_success_rate = 0.99;\n      else if (p->args.numinfo.l_val == 2)\n\tp->est_success_rate = 0.01;\n      else\n\tp->est_success_rate = 1e-3;\n      return true;\n    }\n  else\n    {\n      --*arg_ptr;\t\t/* don't consume the invalid argument. */\n      return false;\n    }\n}",
      "lines": 20,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "parse_lname": {
      "start_point": [
        1413,
        0
      ],
      "end_point": [
        1426,
        1
      ],
      "content": "static bool\nparse_lname (const struct parser_table* entry, char **argv, int *arg_ptr)\n{\n  const char *name;\n  fnmatch_sanitycheck ();\n  if (collect_arg (argv, arg_ptr, &name))\n    {\n      struct predicate *our_pred = insert_primary (entry, name);\n      our_pred->args.str = name;\n      our_pred->est_success_rate = 0.1 * estimate_pattern_match_rate (name, 0);\n      return true;\n    }\n  return false;\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "parse_ls": {
      "start_point": [
        1428,
        0
      ],
      "end_point": [
        1434,
        1
      ],
      "content": "static bool\nparse_ls (const struct parser_table* entry, char **argv, int *arg_ptr)\n{\n  (void) &argv;\n  (void) &arg_ptr;\n  return insert_fls (entry, NULL);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "insert_depthspec": {
      "start_point": [
        1436,
        0
      ],
      "end_point": [
        1463,
        1
      ],
      "content": "static bool\ninsert_depthspec (const struct parser_table* entry, char **argv, int *arg_ptr,\n\t\t  int *limitptr)\n{\n  const char *depthstr;\n  int depth_len;\n  const char *predicate = argv[(*arg_ptr)-1];\n  if (collect_arg (argv, arg_ptr, &depthstr))\n    {\n      depth_len = strspn (depthstr, \"0123456789\");\n      if ((depth_len > 0) && (depthstr[depth_len] == 0))\n\t{\n\t  (*limitptr) = safe_atoi (depthstr, options.err_quoting_style);\n\t  if (*limitptr >= 0)\n\t    {\n\t      return parse_noop (entry, argv, arg_ptr);\n\t    }\n\t}\n      error (EXIT_FAILURE, 0,\n\t     _(\"Expected a positive decimal integer argument to %s, but got %s\"),\n\t     predicate,\n\t     quotearg_n_style (0, options.err_quoting_style, depthstr));\n      /* NOTREACHED */\n      return false;\n    }\n  /* missing argument */\n  return false;\n}",
      "lines": 28,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "parse_maxdepth": {
      "start_point": [
        1466,
        0
      ],
      "end_point": [
        1470,
        1
      ],
      "content": "static bool\nparse_maxdepth (const struct parser_table* entry, char **argv, int *arg_ptr)\n{\n  return insert_depthspec (entry, argv, arg_ptr, &options.maxdepth);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "parse_mindepth": {
      "start_point": [
        1472,
        0
      ],
      "end_point": [
        1476,
        1
      ],
      "content": "static bool\nparse_mindepth (const struct parser_table* entry, char **argv, int *arg_ptr)\n{\n  return insert_depthspec (entry, argv, arg_ptr, &options.mindepth);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "do_parse_xmin": {
      "start_point": [
        1479,
        0
      ],
      "end_point": [
        1510,
        1
      ],
      "content": "static bool\ndo_parse_xmin (const struct parser_table* entry,\n\t       char **argv,\n\t       int *arg_ptr,\n\t       enum xval xv)\n{\n  const char *minutes;\n  const int saved_argc = *arg_ptr;\n\n  if (collect_arg (argv, arg_ptr, &minutes))\n    {\n      struct time_val tval;\n      struct timespec origin = options.cur_day_start;\n      tval.xval = xv;\n      origin.tv_sec += DAYSECS;\n      if (get_relative_timestamp (minutes, &tval, origin, 60,\n\t\t\t\t  \"arithmetic overflow while converting %s \"\n\t\t\t\t  \"minutes to a number of seconds\"))\n\t{\n\t  struct predicate *our_pred = insert_primary (entry, minutes);\n\t  our_pred->args.reftime = tval;\n\t  our_pred->est_success_rate = estimate_timestamp_success_rate (tval.ts.tv_sec);\n\t  return true;\n\t}\n      else\n\t{\n\t  /* Don't consume the invalid argument. */\n\t  *arg_ptr = saved_argc;\n\t}\n    }\n  return false;\n}",
      "lines": 32,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "parse_amin": {
      "start_point": [
        1511,
        0
      ],
      "end_point": [
        1515,
        1
      ],
      "content": "static bool\nparse_amin (const struct parser_table* entry, char **argv, int *arg_ptr)\n{\n  return do_parse_xmin (entry, argv, arg_ptr, XVAL_ATIME);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "parse_cmin": {
      "start_point": [
        1517,
        0
      ],
      "end_point": [
        1521,
        1
      ],
      "content": "static bool\nparse_cmin (const struct parser_table* entry, char **argv, int *arg_ptr)\n{\n  return do_parse_xmin (entry, argv, arg_ptr, XVAL_CTIME);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "parse_mmin": {
      "start_point": [
        1524,
        0
      ],
      "end_point": [
        1528,
        1
      ],
      "content": "static bool\nparse_mmin (const struct parser_table* entry, char **argv, int *arg_ptr)\n{\n  return do_parse_xmin (entry, argv, arg_ptr, XVAL_MTIME);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "parse_name": {
      "start_point": [
        1530,
        0
      ],
      "end_point": [
        1553,
        1
      ],
      "content": "static bool\nparse_name (const struct parser_table* entry, char **argv, int *arg_ptr)\n{\n  const char *name;\n  const int saved_argc = *arg_ptr;\n\n  if (collect_arg (argv, arg_ptr, &name))\n    {\n      fnmatch_sanitycheck ();\n      if (check_name_arg (\"-name\", name))\n\t{\n\t  struct predicate *our_pred = insert_primary (entry, name);\n\t  our_pred->need_stat = our_pred->need_type = false;\n\t  our_pred->args.str = name;\n\t  our_pred->est_success_rate = estimate_pattern_match_rate (name, 0);\n\t  return true;\n\t}\n      else\n\t{\n\t  *arg_ptr = saved_argc; /* don't consume the invalid argument. */\n\t}\n    }\n  return false;\n}",
      "lines": 24,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "parse_negate": {
      "start_point": [
        1555,
        0
      ],
      "end_point": [
        1569,
        1
      ],
      "content": "static bool\nparse_negate (const struct parser_table* entry, char **argv, int *arg_ptr)\n{\n  struct predicate *our_pred;\n\n  (void) &argv;\n  (void) &arg_ptr;\n\n  our_pred = get_new_pred_chk_op (entry, NULL);\n  our_pred->pred_func = pred_negate;\n  our_pred->p_type = UNI_OP;\n  our_pred->p_prec = NEGATE_PREC;\n  our_pred->need_stat = our_pred->need_type = false;\n  return true;\n}",
      "lines": 15,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "parse_newer": {
      "start_point": [
        1571,
        0
      ],
      "end_point": [
        1589,
        1
      ],
      "content": "static bool\nparse_newer (const struct parser_table* entry, char **argv, int *arg_ptr)\n{\n  struct predicate *our_pred;\n  struct stat stat_newer;\n  const char *arg;\n\n  set_stat_placeholders (&stat_newer);\n  if (collect_arg_stat_info (argv, arg_ptr, &stat_newer, &arg))\n    {\n      our_pred = insert_primary (entry, arg);\n      our_pred->args.reftime.ts = get_stat_mtime (&stat_newer);\n      our_pred->args.reftime.xval = XVAL_MTIME;\n      our_pred->args.reftime.kind = COMP_GT;\n      our_pred->est_success_rate = estimate_timestamp_success_rate (stat_newer.st_mtime);\n      return true;\n    }\n  return false;\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "parse_newerXY": {
      "start_point": [
        1592,
        0
      ],
      "end_point": [
        1709,
        1
      ],
      "content": "static bool\nparse_newerXY (const struct parser_table* entry, char **argv, int *arg_ptr)\n{\n  (void) argv;\n  (void) arg_ptr;\n\n  if ((argv == NULL) || (argv[*arg_ptr] == NULL))\n    {\n      return false;\n    }\n  else if (8u != strlen (argv[*arg_ptr]))\n    {\n      return false;\n    }\n  else\n    {\n      char x, y;\n      const char validchars[] = \"aBcmt\";\n\n      assert (0 == strncmp (\"-newer\", argv[*arg_ptr], 6));\n      x = argv[*arg_ptr][6];\n      y = argv[*arg_ptr][7];\n\n\n#if !defined HAVE_STRUCT_STAT_ST_BIRTHTIME && !defined HAVE_STRUCT_STAT_ST_BIRTHTIMENSEC && !defined HAVE_STRUCT_STAT_ST_BIRTHTIMESPEC_TV_NSEC && !defined HAVE_STRUCT_STAT_ST_BIRTHTIM_TV_NSEC\n      if ('B' == x || 'B' == y)\n\t{\n\t  error (0, 0,\n\t\t _(\"This system does not provide a way to find the birth time of a file.\"));\n\t  return false;\n\t}\n#endif\n\n      /* -newertY (for any Y) is invalid. */\n      if (x == 't'\n\t  || (NULL == strchr (validchars, x))\n\t  || (NULL == strchr ( validchars, y)))\n\t{\n\t  return false;\n\t}\n      else\n\t{\n\t  struct predicate *our_pred;\n\n\t  /* Because this item is ARG_SPECIAL_PARSE, we have to advance arg_ptr\n\t   * past the test name (for most other tests, this is already done)\n\t   */\n\t  if (argv[1+*arg_ptr] == NULL)\n\t    {\n\t      error (EXIT_FAILURE, 0, _(\"The %s test needs an argument\"),\n\t\t     quotearg_n_style (0, options.err_quoting_style, argv[*arg_ptr]));\n\t    }\n\t  else\n\t    {\n\t      (*arg_ptr)++;\n\t    }\n\n\t  our_pred = insert_primary (entry, argv[*arg_ptr]);\n\n\n\t  switch (x)\n\t    {\n\t    case 'a':\n\t      our_pred->args.reftime.xval = XVAL_ATIME;\n\t      break;\n\t    case 'B':\n\t      our_pred->args.reftime.xval = XVAL_BIRTHTIME;\n\t      break;\n\t    case 'c':\n\t      our_pred->args.reftime.xval = XVAL_CTIME;\n\t      break;\n\t    case 'm':\n\t      our_pred->args.reftime.xval = XVAL_MTIME;\n\t      break;\n\t    default:\n\t      assert (strchr (validchars, x));\n\t      assert (0);\n\t    }\n\n\t  if ('t' == y)\n\t    {\n\t      if (!parse_datetime (&our_pred->args.reftime.ts,\n\t\t\t\t   argv[*arg_ptr],\n\t\t\t\t   &options.start_time))\n\t\t{\n\t\t  error (EXIT_FAILURE, 0,\n\t\t\t _(\"I cannot figure out how to interpret %s as a date or time\"),\n\t\t\t quotearg_n_style (0, options.err_quoting_style, argv[*arg_ptr]));\n\t\t}\n\t    }\n\t  else\n\t    {\n\t      struct stat stat_newer;\n\n\t      /* Stat the named file. */\n\t      set_stat_placeholders (&stat_newer);\n\t      if ((*options.xstat) (argv[*arg_ptr], &stat_newer))\n\t\tfatal_target_file_error (errno, argv[*arg_ptr]);\n\n\t      if (!get_stat_Ytime (&stat_newer, y, &our_pred->args.reftime.ts))\n\t\t{\n\t\t  /* We cannot extract a timestamp from the struct stat. */\n\t\t  error (EXIT_FAILURE, 0,\n\t\t\t _(\"Cannot obtain birth time of file %s\"),\n\t\t\t safely_quote_err_filename (0, argv[*arg_ptr]));\n\t\t}\n\t    }\n\t  our_pred->args.reftime.kind = COMP_GT;\n\t  our_pred->est_success_rate = estimate_timestamp_success_rate (our_pred->args.reftime.ts.tv_sec);\n\t  (*arg_ptr)++;\n\n\t  assert (our_pred->pred_func != NULL);\n\t  assert (our_pred->pred_func == pred_newerXY);\n\t  assert (our_pred->need_stat);\n\t  return true;\n\t}\n    }\n}",
      "lines": 118,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "parse_noleaf": {
      "start_point": [
        1712,
        0
      ],
      "end_point": [
        1717,
        1
      ],
      "content": "static bool\nparse_noleaf (const struct parser_table* entry, char **argv, int *arg_ptr)\n{\n  options.no_leaf_check = true;\n  return parse_noop (entry, argv, arg_ptr);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "parse_nogroup": {
      "start_point": [
        1719,
        0
      ],
      "end_point": [
        1730,
        1
      ],
      "content": "static bool\nparse_nogroup (const struct parser_table* entry, char **argv, int *arg_ptr)\n{\n  struct predicate *our_pred;\n\n  (void) &argv;\n  (void) &arg_ptr;\n\n  our_pred = insert_primary (entry, NULL);\n  our_pred->est_success_rate = 1e-4;\n  return true;\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "parse_nouser": {
      "start_point": [
        1732,
        0
      ],
      "end_point": [
        1743,
        1
      ],
      "content": "static bool\nparse_nouser (const struct parser_table* entry, char **argv, int *arg_ptr)\n{\n  struct predicate *our_pred;\n  (void) argv;\n  (void) arg_ptr;\n\n\n  our_pred = insert_primary_noarg (entry);\n  our_pred->est_success_rate = 1e-3;\n  return true;\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "parse_nowarn": {
      "start_point": [
        1745,
        0
      ],
      "end_point": [
        1750,
        1
      ],
      "content": "static bool\nparse_nowarn (const struct parser_table* entry, char **argv, int *arg_ptr)\n{\n  options.warnings = false;\n  return parse_noop (entry, argv, arg_ptr);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "parse_ok": {
      "start_point": [
        1752,
        0
      ],
      "end_point": [
        1756,
        1
      ],
      "content": "static bool\nparse_ok (const struct parser_table* entry, char **argv, int *arg_ptr)\n{\n  return insert_exec_ok (\"-ok\", entry, argv, arg_ptr);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "parse_okdir": {
      "start_point": [
        1758,
        0
      ],
      "end_point": [
        1762,
        1
      ],
      "content": "static bool\nparse_okdir (const struct parser_table* entry, char **argv, int *arg_ptr)\n{\n  return insert_exec_ok (\"-okdir\", entry, argv, arg_ptr);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "parse_openparen": {
      "start_point": [
        1764,
        0
      ],
      "end_point": [
        1778,
        1
      ],
      "content": "bool\nparse_openparen (const struct parser_table* entry, char **argv, int *arg_ptr)\n{\n  struct predicate *our_pred;\n\n  (void) argv;\n  (void) arg_ptr;\n\n  our_pred = get_new_pred_chk_op (entry, NULL);\n  our_pred->pred_func = pred_openparen;\n  our_pred->p_type = OPEN_PAREN;\n  our_pred->p_prec = NO_PREC;\n  our_pred->need_stat = our_pred->need_type = false;\n  return true;\n}",
      "lines": 15,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    },
    "parse_or": {
      "start_point": [
        1780,
        0
      ],
      "end_point": [
        1794,
        1
      ],
      "content": "static bool\nparse_or (const struct parser_table* entry, char **argv, int *arg_ptr)\n{\n  struct predicate *our_pred;\n\n  (void) argv;\n  (void) arg_ptr;\n\n  our_pred = get_new_pred_noarg (entry);\n  our_pred->pred_func = pred_or;\n  our_pred->p_type = BI_OP;\n  our_pred->p_prec = OR_PREC;\n  our_pred->need_stat = our_pred->need_type = false;\n  return true;\n}",
      "lines": 15,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "is_feasible_path_argument": {
      "start_point": [
        1796,
        0
      ],
      "end_point": [
        1814,
        1
      ],
      "content": "static bool\nis_feasible_path_argument (const char *arg, bool foldcase)\n{\n  const char *last = strrchr (arg, '/');\n  if (last && !last[1])\n    {\n      /* The name ends with \"/\". */\n      if (matches_start_point (arg, foldcase))\n\t{\n\t  /* \"-path foo/\" can succeed if one of the start points is \"foo/\". */\n\t  return true;\n\t}\n      else\n\t{\n\t  return false;\n\t}\n    }\n  return true;\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "insert_path_check": {
      "start_point": [
        1817,
        0
      ],
      "end_point": [
        1847,
        1
      ],
      "content": "static bool\ninsert_path_check (const struct parser_table* entry, char **argv, int *arg_ptr,\n\t\t   const char *predicate_name, PREDICATEFUNCTION pred)\n{\n  const char *name;\n  bool foldcase = false;\n\n  if (pred == pred_ipath)\n    foldcase = true;\n\n  fnmatch_sanitycheck ();\n\n  if (collect_arg (argv, arg_ptr, &name))\n    {\n      struct predicate *our_pred = insert_primary_withpred (entry, pred, name);\n      our_pred->need_stat = our_pred->need_type = false;\n      our_pred->args.str = name;\n      our_pred->est_success_rate = estimate_pattern_match_rate (name, 0);\n\n      if (!options.posixly_correct\n\t  && !is_feasible_path_argument (name, foldcase))\n\t{\n\t  error (0, 0, _(\"warning: -%s %s will not match anything \"\n\t\t\t \"because it ends with /.\"),\n\t\t predicate_name, name);\n\t  our_pred->est_success_rate = 1.0e-8;\n\t}\n      return true;\n    }\n  return false;\n}",
      "lines": 31,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "parse_path": {
      "start_point": [
        1859,
        0
      ],
      "end_point": [
        1863,
        1
      ],
      "content": "static bool\nparse_path (const struct parser_table* entry, char **argv, int *arg_ptr)\n{\n  return insert_path_check (entry, argv, arg_ptr, \"path\", pred_path);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "parse_wholename": {
      "start_point": [
        1865,
        0
      ],
      "end_point": [
        1869,
        1
      ],
      "content": "static bool\nparse_wholename (const struct parser_table* entry, char **argv, int *arg_ptr)\n{\n  return insert_path_check (entry, argv, arg_ptr, \"wholename\", pred_path);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "parse_ipath": {
      "start_point": [
        1877,
        0
      ],
      "end_point": [
        1881,
        1
      ],
      "content": "static bool\nparse_ipath (const struct parser_table* entry, char **argv, int *arg_ptr)\n{\n  return insert_path_check (entry, argv, arg_ptr, \"ipath\", pred_ipath);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "parse_iwholename": {
      "start_point": [
        1883,
        0
      ],
      "end_point": [
        1887,
        1
      ],
      "content": "static bool\nparse_iwholename (const struct parser_table* entry, char **argv, int *arg_ptr)\n{\n  return insert_path_check (entry, argv, arg_ptr, \"iwholename\", pred_ipath);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "parse_perm": {
      "start_point": [
        1890,
        0
      ],
      "end_point": [
        1974,
        1
      ],
      "content": "static bool\nparse_perm (const struct parser_table* entry, char **argv, int *arg_ptr)\n{\n  mode_t perm_val[2];\n  float rate;\n  int mode_start = 0;\n  enum permissions_type kind = PERM_EXACT;\n  struct mode_change *change;\n  struct predicate *our_pred;\n  const char *perm_expr;\n\n  if (!collect_arg (argv, arg_ptr, &perm_expr))\n    return false;\n\n  switch (perm_expr[0])\n    {\n    case '-':\n      mode_start = 1;\n      kind = PERM_AT_LEAST;\n      rate = 0.2;\n      break;\n\n    case '/':\t\t\t/* GNU extension */\n      mode_start = 1;\n      kind = PERM_ANY;\n      rate = 0.3;\n      break;\n\n    default:\n      /* For example, '-perm 0644', which is valid and matches\n       * only files whose mode is exactly 0644.\n       */\n      mode_start = 0;\n      kind = PERM_EXACT;\n      rate = 0.01;\n      break;\n    }\n\n  change = mode_compile (perm_expr + mode_start);\n\n  /* Reject invalid modes, or modes of the form +NUMERICMODE.\n     The latter were formerly accepted as a GNU extension, but that\n     extension was incompatible with how GNU 'chmod' treats these modes now,\n     and it would be confusing if 'find' continued to support it.  */\n  if (NULL == change\n      || (perm_expr[0] == '+' && '0' <= perm_expr[1] && perm_expr[1] < '8'))\n    error (EXIT_FAILURE, 0, _(\"invalid mode %s\"),\n\t   quotearg_n_style (0, options.err_quoting_style, perm_expr));\n  perm_val[0] = mode_adjust (0, false, 0, change, NULL);\n  perm_val[1] = mode_adjust (0, true, 0, change, NULL);\n  free (change);\n\n  if (('/' == perm_expr[0]) && (0 == perm_val[0]) && (0 == perm_val[1]))\n    {\n      /* The meaning of -perm /000 will change in the future.  It\n       * currently matches no files, but like -perm -000 it should\n       * match all files.\n       *\n       * Starting in 2005, we used to issue a warning message\n       * informing the user that the behaviour would change in the\n       * future.  We have now changed the behaviour and issue a\n       * warning message that the behaviour recently changed.\n       */\n      error (0, 0,\n\t     _(\"warning: you have specified a mode pattern %s (which is \"\n\t       \"equivalent to /000). The meaning of -perm /000 has now been \"\n\t       \"changed to be consistent with -perm -000; that is, while it \"\n\t       \"used to match no files, it now matches all files.\"),\n\t     perm_expr);\n\n      kind = PERM_AT_LEAST;\n\n      /* The \"magic\" number below is just the fraction of files on my\n       * own system that \"-type l -xtype l\" fails for (i.e. unbroken symlinks).\n       * Actual totals are 1472 and 1073833.\n       */\n      rate = 0.9986; /* probably matches anything but a broken symlink */\n    }\n\n  our_pred = insert_primary (entry, perm_expr);\n  our_pred->est_success_rate = rate;\n  our_pred->args.perm.kind = kind;\n  memcpy (our_pred->args.perm.val, perm_val, sizeof perm_val);\n  return true;\n}",
      "lines": 85,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "parse_print": {
      "start_point": [
        1976,
        0
      ],
      "end_point": [
        1992,
        1
      ],
      "content": "bool\nparse_print (const struct parser_table* entry, char **argv, int *arg_ptr)\n{\n  struct predicate *our_pred;\n\n  (void) argv;\n  (void) arg_ptr;\n\n  our_pred = insert_primary_noarg (entry);\n  /* -print has the side effect of printing.  This prevents us\n     from doing undesired multiple printing when the user has\n     already specified -print. */\n  our_pred->side_effects = our_pred->no_default_print = true;\n  our_pred->need_stat = our_pred->need_type = false;\n  open_stdout (&our_pred->args.printf_vec);\n  return true;\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    },
    "parse_print0": {
      "start_point": [
        1994,
        0
      ],
      "end_point": [
        2001,
        1
      ],
      "content": "static bool\nparse_print0 (const struct parser_table* entry, char **argv, int *arg_ptr)\n{\n  (void) entry;\n  (void) argv;\n  (void) arg_ptr;\n  return insert_fprint (entry, NULL);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "parse_printf": {
      "start_point": [
        2003,
        0
      ],
      "end_point": [
        2024,
        1
      ],
      "content": "static bool\nparse_printf (const struct parser_table* entry, char **argv, int *arg_ptr)\n{\n  char *format;\n  const int saved_argc = *arg_ptr;\n\n  if (collect_arg_nonconst (argv, arg_ptr, &format))\n    {\n      struct format_val fmt;\n      open_stdout (&fmt);\n      if (insert_fprintf (&fmt, entry, format))\n\t{\n\t  return true;\n\t}\n      else\n\t{\n\t  *arg_ptr = saved_argc; /* don't consume the invalid argument. */\n\t  return false;\n\t}\n    }\n  return false;\n}",
      "lines": 22,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "parse_fprintf": {
      "start_point": [
        2026,
        0
      ],
      "end_point": [
        2047,
        1
      ],
      "content": "static bool\nparse_fprintf (const struct parser_table* entry, char **argv, int *arg_ptr)\n{\n  const char *filename;\n  char *format;\n  int saved_argc = *arg_ptr;\n\n  if (collect_arg (argv, arg_ptr, &filename))\n    {\n      if (collect_arg_nonconst (argv, arg_ptr, &format))\n\t{\n\t  struct format_val fmt;\n\t  open_output_file (filename, &fmt);\n\t  saved_argc = *arg_ptr;\n\n\t  if (insert_fprintf (&fmt, entry, format))\n\t    return true;\n\t}\n    }\n  *arg_ptr = saved_argc; /* don't consume the invalid argument. */\n  return false;\n}",
      "lines": 22,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "parse_prune": {
      "start_point": [
        2049,
        0
      ],
      "end_point": [
        2065,
        1
      ],
      "content": "static bool\nparse_prune (const struct parser_table* entry, char **argv, int *arg_ptr)\n{\n  struct predicate *our_pred;\n\n  (void) argv;\n  (void) arg_ptr;\n\n  our_pred = insert_primary_noarg (entry);\n  if (options.do_dir_first == false)\n    our_pred->need_stat = our_pred->need_type = false;\n  /* -prune has a side effect that it does not descend into\n     the current directory. */\n  our_pred->side_effects = true;\n  our_pred->no_default_print = false;\n  return true;\n}",
      "lines": 17,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "parse_quit": {
      "start_point": [
        2067,
        0
      ],
      "end_point": [
        2078,
        1
      ],
      "content": "static bool\nparse_quit  (const struct parser_table* entry, char **argv, int *arg_ptr)\n{\n  struct predicate *our_pred = insert_primary_noarg (entry);\n  (void) argv;\n  (void) arg_ptr;\n  our_pred->need_stat = our_pred->need_type = false;\n  our_pred->side_effects = true; /* Exiting is a side effect... */\n  our_pred->no_default_print = false; /* Don't inhibit the default print, though. */\n  our_pred->est_success_rate = 1.0f;\n  return true;\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "parse_regextype": {
      "start_point": [
        2081,
        0
      ],
      "end_point": [
        2092,
        1
      ],
      "content": "static bool\nparse_regextype (const struct parser_table* entry, char **argv, int *arg_ptr)\n{\n  const char *type_name;\n  if (collect_arg (argv, arg_ptr, &type_name))\n    {\n      /* collect the regex type name */\n      options.regex_options = get_regex_type (type_name);\n      return parse_noop (entry, argv, arg_ptr);\n    }\n  return false;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "parse_regex": {
      "start_point": [
        2095,
        0
      ],
      "end_point": [
        2099,
        1
      ],
      "content": "static bool\nparse_regex (const struct parser_table* entry, char **argv, int *arg_ptr)\n{\n  return insert_regex (argv, arg_ptr, entry, options.regex_options);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "insert_regex": {
      "start_point": [
        2101,
        0
      ],
      "end_point": [
        2133,
        1
      ],
      "content": "static bool\ninsert_regex (char **argv,\n\t      int *arg_ptr,\n\t      const struct parser_table *entry,\n\t      int regex_options)\n{\n  const char *rx;\n  if (collect_arg (argv, arg_ptr, &rx))\n    {\n      struct re_pattern_buffer *re;\n      const char *error_message;\n      struct predicate *our_pred = insert_primary_withpred (entry, pred_regex, rx);\n      our_pred->need_stat = our_pred->need_type = false;\n      re = xmalloc (sizeof (struct re_pattern_buffer));\n      our_pred->args.regex = re;\n      re->allocated = 100;\n      re->buffer = xmalloc (re->allocated);\n      re->fastmap = NULL;\n\n      re_set_syntax (regex_options);\n      re->syntax = regex_options;\n      re->translate = NULL;\n\n      error_message = re_compile_pattern (rx, strlen (rx), re);\n      if (error_message)\n        error (EXIT_FAILURE, 0,\n\t       _(\"failed to compile regular expression '%s': %s\"),\n\t       rx, error_message);\n      our_pred->est_success_rate = estimate_pattern_match_rate (rx, 1);\n      return true;\n    }\n  return false;\n}",
      "lines": 33,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "parse_size": {
      "start_point": [
        2135,
        0
      ],
      "end_point": [
        2236,
        1
      ],
      "content": "static bool\nparse_size (const struct parser_table* entry, char **argv, int *arg_ptr)\n{\n  struct predicate *our_pred;\n  char *arg;\n  uintmax_t num;\n  char suffix;\n  enum comparison_type c_type;\n\n  int blksize = 512;\n  int len;\n\n  /* XXX: cannot (yet) convert to ue collect_arg() as this\n   * function modifies the args in-place.\n   */\n  if ((argv == NULL) || (argv[*arg_ptr] == NULL))\n    return false;\n  arg = argv[*arg_ptr];\n\n  len = strlen (arg);\n  if (len == 0)\n    error (EXIT_FAILURE, 0, _(\"invalid null argument to -size\"));\n\n  suffix = arg[len - 1];\n  switch (suffix)\n    {\n    case 'b':\n      blksize = 512;\n      arg[len - 1] = '\\0';\n      break;\n\n    case 'c':\n      blksize = 1;\n      arg[len - 1] = '\\0';\n      break;\n\n    case 'k':\n      blksize = 1024;\n      arg[len - 1] = '\\0';\n      break;\n\n    case 'M':\t\t\t/* Megabytes */\n      blksize = 1024*1024;\n      arg[len - 1] = '\\0';\n      break;\n\n    case 'G':\t\t\t/* Gigabytes */\n      blksize = 1024*1024*1024;\n      arg[len - 1] = '\\0';\n      break;\n\n    case 'w':\n      blksize = 2;\n      arg[len - 1] = '\\0';\n      break;\n\n    case '0':\n    case '1':\n    case '2':\n    case '3':\n    case '4':\n    case '5':\n    case '6':\n    case '7':\n    case '8':\n    case '9':\n      suffix = 0;\n      break;\n\n    default:\n      error (EXIT_FAILURE, 0,\n\t     _(\"invalid -size type `%c'\"), argv[*arg_ptr][len - 1]);\n    }\n  /* TODO: accept fractional megabytes etc. ? */\n  if (!get_num (arg, &num, &c_type))\n    {\n      char tail[2];\n      tail[0] = suffix;\n      tail[1] = 0;\n\n      error (EXIT_FAILURE, 0,\n\t     _(\"Invalid argument `%s%s' to -size\"),\n\t     arg, tail);\n      return false;\n    }\n  our_pred = insert_primary (entry, arg);\n  our_pred->args.size.kind = c_type;\n  our_pred->args.size.blocksize = blksize;\n  our_pred->args.size.size = num;\n  our_pred->need_stat = true;\n  our_pred->need_type = false;\n\n  if (COMP_GT == c_type)\n    our_pred->est_success_rate = (num*blksize > 20480) ? 0.1 : 0.9;\n  else if (COMP_LT == c_type)\n    our_pred->est_success_rate = (num*blksize > 20480) ? 0.9 : 0.1;\n  else\n    our_pred->est_success_rate = 0.01;\n\n  (*arg_ptr)++;\n  return true;\n}",
      "lines": 102,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "parse_samefile": {
      "start_point": [
        2239,
        0
      ],
      "end_point": [
        2386,
        1
      ],
      "content": "static bool\nparse_samefile (const struct parser_table* entry, char **argv, int *arg_ptr)\n{\n  /* General idea: stat the file, remember device and inode numbers.\n   * If a candidate file matches those, it's the same file.\n   */\n  struct predicate *our_pred;\n  struct stat st, fst;\n  int fd, openflags;\n  const char *filename;\n\n  set_stat_placeholders (&st);\n  if (!collect_arg_stat_info (argv, arg_ptr, &st, &filename))\n    return false;\n\n  set_stat_placeholders (&fst);\n  /* POSIX systems are free to re-use the inode number of a deleted\n   * file.  To ensure that we are not fooled by inode reuse, we hold\n   * the file open if we can.  This would prevent the system reusing\n   * the file.\n   */\n  fd = -3;\t\t\t/* -3 means uninitialized */\n  openflags = O_RDONLY;\n\n  if (options.symlink_handling == SYMLINK_NEVER_DEREF)\n    {\n      if (options.open_nofollow_available)\n\t{\n\t  assert (O_NOFOLLOW != 0);\n\t  openflags |= O_NOFOLLOW;\n\t  fd = -1;\t\t/* safe to open it. */\n\t}\n      else\n\t{\n\t  if (S_ISLNK(st.st_mode))\n\t    {\n\t      /* no way to ensure that a symlink will not be followed\n\t       * by open(2), so fall back on using lstat().  Accept\n\t       * the risk that the named file will be deleted and\n\t       * replaced with another having the same inode.\n\t       *\n\t       * Avoid opening the file.\n\t       */\n\t      fd = -2;\t\t/* Do not open it */\n\t    }\n\t  else\n\t    {\n\t      fd = -1;\n\t      /* Race condition here: the file might become a symlink here. */\n\t    }\n\t}\n    }\n  else\n    {\n      /* We want to dereference the symlink anyway */\n      fd = -1;\t\t\t/* safe to open it without O_NOFOLLOW */\n    }\n\n  assert (fd != -3);\t\t/* check we made a decision */\n  if (fd == -1)\n    {\n      /* Race condition here.  The file might become a\n       * symbolic link in between our call to stat and\n       * the call to open_cloexec.\n       */\n      fd = open_cloexec (filename, openflags);\n\n      if (fd >= 0)\n\t{\n\t  /* We stat the file again here to prevent a race condition\n\t   * between the first stat and the call to open(2).\n\t   */\n\t  if (0 != fstat (fd, &fst))\n\t    {\n\t      fatal_target_file_error (errno, filename);\n\t    }\n\t  else\n\t    {\n\t      /* Worry about the race condition.  If the file became a\n\t       * symlink after our first stat and before our call to\n\t       * open, fst may contain the stat information for the\n\t       * destination of the link, not the link itself.\n\t       */\n\t      if ((*options.xstat) (filename, &st))\n\t\tfatal_target_file_error (errno, filename);\n\n\t      if ((options.symlink_handling == SYMLINK_NEVER_DEREF)\n\t\t  && (!options.open_nofollow_available))\n\t\t{\n\t\t  if (S_ISLNK(st.st_mode))\n\t\t    {\n\t\t      /* We lost the race.  Leave the data in st.  The\n\t\t       * file descriptor points to the wrong thing.\n\t\t       */\n\t\t      close (fd);\n\t\t      fd = -1;\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      /* Several possibilities here:\n\t\t       * 1. There was no race\n\t\t       * 2. The file changed into a symlink after the stat and\n\t\t       *    before the open, and then back into a non-symlink\n\t\t       *    before the second stat.\n\t\t       *\n\t\t       * In case (1) there is no problem.  In case (2),\n\t\t       * the stat() and fstat() calls will have returned\n\t\t       * different data.  O_NOFOLLOW was not available,\n\t\t       * so the open() call may have followed a symlink\n\t\t       * even if the -P option is in effect.\n\t\t       */\n\t\t      if ((st.st_dev == fst.st_dev)\n\t\t\t  && (st.st_ino == fst.st_ino))\n\t\t\t{\n\t\t\t  /* No race.  No need to copy fst to st,\n\t\t\t   * since they should be identical (modulo\n\t\t\t   * differences in padding bytes).\n\t\t\t   */\n\t\t\t}\n\t\t      else\n\t\t\t{\n\t\t\t  /* We lost the race.  Leave the data in st.  The\n\t\t\t   * file descriptor points to the wrong thing.\n\t\t\t   */\n\t\t\t  close (fd);\n\t\t\t  fd = -1;\n\t\t\t}\n\t\t    }\n\t\t}\n\t      else\n\t\t{\n\t\t  st = fst;\n\t\t}\n\t    }\n\t}\n    }\n\n  our_pred = insert_primary (entry, filename);\n  our_pred->args.samefileid.ino = st.st_ino;\n  our_pred->args.samefileid.dev = st.st_dev;\n  our_pred->args.samefileid.fd  = fd;\n  our_pred->need_type = false;\n  /* smarter way: compare type and inode number first. */\n  /* TODO: maybe optimise this away by being optimistic */\n  our_pred->need_stat = true;\n  our_pred->est_success_rate = 0.01f;\n  return true;\n}",
      "lines": 148,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "parse_show_control_chars": {
      "start_point": [
        2392,
        0
      ],
      "end_point": [
        2427,
        1
      ],
      "content": "static bool\nparse_show_control_chars (const struct parser_table* entry,\n\t\t\t  char **argv,\n\t\t\t  int *arg_ptr)\n{\n  const char *arg;\n  const char *errmsg = _(\"The -show-control-chars option takes \"\n\t\t\t \"a single argument which \"\n\t\t\t \"must be 'literal' or 'safe'\");\n\n  if ((argv == NULL) || (argv[*arg_ptr] == NULL))\n    {\n      error (EXIT_FAILURE, errno, \"%s\", errmsg);\n      return false;\n    }\n  else\n    {\n      arg = argv[*arg_ptr];\n\n      if (0 == strcmp (\"literal\", arg))\n\t{\n\t  options.literal_control_chars = true;\n\t}\n      else if (0 == strcmp (\"safe\", arg))\n\t{\n\t  options.literal_control_chars = false;\n\t}\n      else\n\t{\n\t  error (EXIT_FAILURE, errno, \"%s\", errmsg);\n\t  return false;\n\t}\n      (*arg_ptr)++;\t\t/* consume the argument. */\n      return true;\n    }\n}",
      "lines": 36,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "parse_true": {
      "start_point": [
        2431,
        0
      ],
      "end_point": [
        2443,
        1
      ],
      "content": "static bool\nparse_true (const struct parser_table* entry, char **argv, int *arg_ptr)\n{\n  struct predicate *our_pred;\n\n  (void) argv;\n  (void) arg_ptr;\n\n  our_pred = insert_primary_noarg (entry);\n  our_pred->need_stat = our_pred->need_type = false;\n  our_pred->est_success_rate = 1.0f;\n  return true;\n}",
      "lines": 13,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "parse_noop": {
      "start_point": [
        2445,
        0
      ],
      "end_point": [
        2450,
        1
      ],
      "content": "static bool\nparse_noop (const struct parser_table* entry, char **argv, int *arg_ptr)\n{\n  (void) entry;\n  return parse_true (get_noop (), argv, arg_ptr);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "parse_accesscheck": {
      "start_point": [
        2452,
        0
      ],
      "end_point": [
        2466,
        1
      ],
      "content": "static bool\nparse_accesscheck (const struct parser_table* entry, char **argv, int *arg_ptr)\n{\n  struct predicate *our_pred;\n  (void) argv;\n  (void) arg_ptr;\n  our_pred = insert_primary_noarg (entry);\n  our_pred->need_stat = our_pred->need_type = false;\n  our_pred->side_effects = our_pred->no_default_print = false;\n  if (pred_is(our_pred, pred_executable))\n    our_pred->est_success_rate = 0.2;\n  else\n    our_pred->est_success_rate = 0.9;\n  return true;\n}",
      "lines": 15,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "parse_type": {
      "start_point": [
        2468,
        0
      ],
      "end_point": [
        2472,
        1
      ],
      "content": "static bool\nparse_type (const struct parser_table* entry, char **argv, int *arg_ptr)\n{\n  return insert_type (argv, arg_ptr, entry, pred_type);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "parse_uid": {
      "start_point": [
        2474,
        0
      ],
      "end_point": [
        2488,
        1
      ],
      "content": "static bool\nparse_uid (const struct parser_table* entry, char **argv, int *arg_ptr)\n{\n  struct predicate *p = insert_num (argv, arg_ptr, entry);\n  if (p)\n    {\n      p->est_success_rate = (p->args.numinfo.l_val < 100) ? 0.99 : 0.2;\n      return true;\n    }\n  else\n    {\n      --*arg_ptr;\t\t/* don't consume the invalid argument. */\n      return false;\n    }\n}",
      "lines": 15,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "parse_used": {
      "start_point": [
        2490,
        0
      ],
      "end_point": [
        2521,
        1
      ],
      "content": "static bool\nparse_used (const struct parser_table* entry, char **argv, int *arg_ptr)\n{\n  struct predicate *our_pred;\n  struct time_val tval;\n  const char *offset_str;\n  const char *errmsg = \"arithmetic overflow while converting %s days to a number of seconds\";\n\n  if (collect_arg (argv, arg_ptr, &offset_str))\n    {\n      /* The timespec is actually a delta value, so we use an origin of 0. */\n      struct timespec zero = {0,0};\n      if (get_relative_timestamp (offset_str, &tval, zero, DAYSECS, errmsg))\n\t{\n\t  our_pred = insert_primary (entry, offset_str);\n\t  our_pred->args.reftime = tval;\n\t  our_pred->est_success_rate = estimate_file_age_success_rate (tval.ts.tv_sec / DAYSECS);\n\t  return true;\n\t}\n      else\n\t{\n\t  error (EXIT_FAILURE, 0,\n\t\t _(\"Invalid argument %s to -used\"), offset_str);\n\t  /*NOTREACHED*/\n\t  return false;\n\t}\n    }\n  else\n    {\n      return false;\t\t/* missing argument */\n    }\n}",
      "lines": 32,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "parse_user": {
      "start_point": [
        2523,
        0
      ],
      "end_point": [
        2572,
        1
      ],
      "content": "static bool\nparse_user (const struct parser_table* entry, char **argv, int *arg_ptr)\n{\n  const char *username;\n\n  if (collect_arg (argv, arg_ptr, &username))\n    {\n      struct predicate *our_pred;\n      uid_t uid;\n      struct passwd *cur_pwd = getpwnam (username);\n      endpwent ();\n      if (cur_pwd != NULL)\n\t{\n\t  uid = cur_pwd->pw_uid;\n\t}\n      else\n\t{\n\t  const size_t uid_len = strspn (username, \"0123456789\");\n\t  if (uid_len && (username[uid_len]==0))\n\t    {\n\t      uid = safe_atoi (username, options.err_quoting_style);\n\t    }\n\t  else\n\t    {\n\t      /* This is a fatal error (if we just return false, the caller\n\t       * will say \"invalid argument `username' to -user\", which is\n\t       * not as helpful). */\n\t      if (username[0])\n\t\t{\n\t\t  error (EXIT_FAILURE, 0,\n\t\t\t _(\"%s is not the name of a known user\"),\n\t\t\t quotearg_n_style (0, options.err_quoting_style,\n\t\t\t\t\t   username));\n\t\t}\n\t      else\n\t\t{\n\t\t  error (EXIT_FAILURE, 0,\n\t\t\t _(\"The argument to -user should not be empty\"));\n\t\t}\n\t      /*NOTREACHED*/\n\t      return false;\n\t    }\n\t}\n      our_pred = insert_primary (entry, username);\n      our_pred->args.uid = uid;\n      our_pred->est_success_rate = (our_pred->args.uid < 100) ? 0.99 : 0.2;\n      return true;\n    }\n  return false;\n}",
      "lines": 50,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "parse_version": {
      "start_point": [
        2574,
        0
      ],
      "end_point": [
        2649,
        1
      ],
      "content": "static bool\nparse_version (const struct parser_table* entry, char **argv, int *arg_ptr)\n{\n  bool has_features = false;\n  int flags;\n\n  (void) argv;\n  (void) arg_ptr;\n  (void) entry;\n\n  display_findutils_version (\"find\");\n  printf (_(\"Features enabled: \"));\n\n#if CACHE_IDS\n  printf (\"CACHE_IDS(ignored) \");\n  has_features = true;\n#endif\n#if DEBUG\n  printf (\"DEBUG \");\n  has_features = true;\n#endif\n#if DEBUG_STAT\n  printf (\"DEBUG_STAT \");\n  has_features = true;\n#endif\n#if defined HAVE_STRUCT_DIRENT_D_TYPE\n  printf (\"D_TYPE \");\n  has_features = true;\n#endif\n#if defined O_NOFOLLOW\n  printf (\"O_NOFOLLOW(%s) \",\n\t  (options.open_nofollow_available ? \"enabled\" : \"disabled\"));\n  has_features = true;\n#endif\n#if defined LEAF_OPTIMISATION\n  printf (\"LEAF_OPTIMISATION \");\n  has_features = true;\n#endif\n  if (0 < is_selinux_enabled ())\n    {\n      printf (\"SELINUX \");\n      has_features = true;\n    }\n\n  flags = 0;\n  if (is_fts_enabled (&flags))\n    {\n      int nflags = 0;\n      printf (\"FTS(\");\n      has_features = true;\n\n      if (flags & FTS_CWDFD)\n\t{\n\t  if (nflags)\n\t    {\n\t      printf (\",\");\n\t    }\n\t  printf (\"FTS_CWDFD\");\n\t  has_features = true;\n\t}\n      printf (\") \");\n    }\n\n  printf (\"CBO(level=%d) \", (int)(options.optimisation_level));\n  has_features = true;\n\n  if (!has_features)\n    {\n      /* For the moment, leave this as English in case someone wants\n\t to parse these strings. */\n      printf (\"none\");\n    }\n  printf (\"\\n\");\n\n  exit (EXIT_SUCCESS);\n}",
      "lines": 76,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "parse_context": {
      "start_point": [
        2651,
        0
      ],
      "end_point": [
        2675,
        1
      ],
      "content": "static bool\nparse_context (const struct parser_table* entry, char **argv, int *arg_ptr)\n{\n  struct predicate *our_pred;\n\n  if ((argv == NULL) || (argv[*arg_ptr] == NULL))\n    return false;\n\n  if (is_selinux_enabled () <= 0)\n    {\n      error (EXIT_FAILURE, 0,\n\t     _(\"invalid predicate -context: SELinux is not enabled.\"));\n      return false;\n    }\n  our_pred = insert_primary (entry, NULL);\n  our_pred->est_success_rate = 0.01f;\n  our_pred->need_stat = false;\n#ifdef DEBUG\n  our_pred->p_name = find_pred_name (pred_context);\n#endif /*DEBUG*/\n  our_pred->args.scontext = argv[*arg_ptr];\n\n  (*arg_ptr)++;\n  return true;\n}",
      "lines": 25,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "parse_xdev": {
      "start_point": [
        2677,
        0
      ],
      "end_point": [
        2682,
        1
      ],
      "content": "static bool\nparse_xdev (const struct parser_table* entry, char **argv, int *arg_ptr)\n{\n  options.stay_on_filesystem = true;\n  return parse_noop (entry, argv, arg_ptr);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "parse_ignore_race": {
      "start_point": [
        2684,
        0
      ],
      "end_point": [
        2689,
        1
      ],
      "content": "static bool\nparse_ignore_race (const struct parser_table* entry, char **argv, int *arg_ptr)\n{\n  options.ignore_readdir_race = true;\n  return parse_noop (entry, argv, arg_ptr);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "parse_noignore_race": {
      "start_point": [
        2691,
        0
      ],
      "end_point": [
        2696,
        1
      ],
      "content": "static bool\nparse_noignore_race (const struct parser_table* entry, char **argv, int *arg_ptr)\n{\n  options.ignore_readdir_race = false;\n  return parse_noop (entry, argv, arg_ptr);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "parse_warn": {
      "start_point": [
        2698,
        0
      ],
      "end_point": [
        2703,
        1
      ],
      "content": "static bool\nparse_warn (const struct parser_table* entry, char **argv, int *arg_ptr)\n{\n  options.warnings = true;\n  return parse_noop (entry, argv, arg_ptr);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "parse_xtype": {
      "start_point": [
        2705,
        0
      ],
      "end_point": [
        2709,
        1
      ],
      "content": "static bool\nparse_xtype (const struct parser_table* entry, char **argv, int *arg_ptr)\n{\n  return insert_type (argv, arg_ptr, entry, pred_xtype);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "insert_type": {
      "start_point": [
        2711,
        0
      ],
      "end_point": [
        2820,
        1
      ],
      "content": "static bool\ninsert_type (char **argv, int *arg_ptr,\n\t     const struct parser_table *entry,\n\t     PRED_FUNC which_pred)\n{\n  mode_t type_cell;\n  struct predicate *our_pred;\n  float rate = 0.5;\n  const char *typeletter;\n\n  if (collect_arg (argv, arg_ptr, &typeletter))\n    {\n      if (strlen (typeletter) != 1u)\n\t{\n\t  error (EXIT_FAILURE, 0,\n\t\t _(\"Arguments to -type should contain only one letter\"));\n\t  /*NOTREACHED*/\n\t  return false;\n\t}\n\n      switch (typeletter[0])\n\t{\n\tcase 'b':\t\t\t/* block special */\n\t  type_cell = S_IFBLK;\n\t  rate = 0.01f;\n\t  break;\n\tcase 'c':\t\t\t/* character special */\n\t  type_cell = S_IFCHR;\n\t  rate = 0.01f;\n\t  break;\n\tcase 'd':\t\t\t/* directory */\n\t  type_cell = S_IFDIR;\n\t  rate = 0.4f;\n\t  break;\n\tcase 'f':\t\t\t/* regular file */\n\t  type_cell = S_IFREG;\n\t  rate = 0.95f;\n\t  break;\n\tcase 'l':\t\t\t/* symbolic link */\n#ifdef S_IFLNK\n\t  type_cell = S_IFLNK;\n\t  rate = 0.1f;\n#else\n\t  error (EXIT_FAILURE, 0,\n\t\t _(\"-type %c is not supported because symbolic links \"\n\t\t   \"are not supported on the platform find was compiled on.\"),\n\t\t (*typeletter));\n#endif\n\t  break;\n\tcase 'p':\t\t\t/* pipe */\n#ifdef S_IFIFO\n\t  type_cell = S_IFIFO;\n\t  rate = 0.01f;\n#else\n\t  error (EXIT_FAILURE, 0,\n\t\t _(\"-type %c is not supported because FIFOs \"\n\t\t   \"are not supported on the platform find was compiled on.\"),\n\t\t (*typeletter));\n#endif\n\t  break;\n\tcase 's':\t\t\t/* socket */\n#ifdef S_IFSOCK\n\t  type_cell = S_IFSOCK;\n\t  rate = 0.01f;\n#else\n\t  error (EXIT_FAILURE, 0,\n\t\t _(\"-type %c is not supported because named sockets \"\n\t\t   \"are not supported on the platform find was compiled on.\"),\n\t\t (*typeletter));\n#endif\n\t  break;\n\tcase 'D':\t\t\t/* Solaris door */\n#ifdef S_IFDOOR\n\t  type_cell = S_IFDOOR;\n\t  rate = 0.01f;\n#else\n\t  error (EXIT_FAILURE, 0,\n\t\t _(\"-type %c is not supported because Solaris doors \"\n\t\t   \"are not supported on the platform find was compiled on.\"),\n\t\t (*typeletter));\n#endif\n\t  break;\n\tdefault:\t\t\t/* None of the above ... nuke 'em. */\n\t  error (EXIT_FAILURE, 0,\n\t\t _(\"Unknown argument to -type: %c\"), (*typeletter));\n\t  /*NOTREACHED*/\n\t  return false;\n\t}\n      our_pred = insert_primary_withpred (entry, which_pred, typeletter);\n      our_pred->est_success_rate = rate;\n\n      /* Figure out if we will need to stat the file, because if we don't\n       * need to follow symlinks, we can avoid a stat call by using\n       * struct dirent.d_type.\n       */\n      if (which_pred == pred_xtype)\n\t{\n\t  our_pred->need_stat = true;\n\t  our_pred->need_type = false;\n\t}\n      else\n\t{\n\t  our_pred->need_stat = false; /* struct dirent is enough */\n\t  our_pred->need_type = true;\n\t}\n      our_pred->args.type = type_cell;\n      return true;\n    }\n  return false;\n}",
      "lines": 110,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "stream_is_tty": {
      "start_point": [
        2825,
        0
      ],
      "end_point": [
        2838,
        1
      ],
      "content": "static bool\nstream_is_tty (FILE *fp)\n{\n  int fd = fileno (fp);\n  if (-1 == fd)\n    {\n      return false; /* not a valid stream */\n    }\n  else\n    {\n      return isatty (fd) ? true : false;\n    }\n\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "check_path_safety": {
      "start_point": [
        2845,
        0
      ],
      "end_point": [
        2891,
        1
      ],
      "content": "static void\ncheck_path_safety (const char *action)\n{\n  const char *path = getenv (\"PATH\");\n  const char *path_separators = \":\";\n  size_t pos, len;\n\n  if (NULL == path)\n    {\n      /* $PATH is not set.  Assume the OS default is safe.\n       * That may not be true on Windows, but I'm not aware\n       * of a way to get Windows to avoid searching the\n       * current directory anyway.\n       */\n      return;\n    }\n\n  splitstring (path, path_separators, true, &pos, &len);\n  do\n    {\n      if (0 == len || (1 == len && path[pos] == '.'))\n\t{\n\t  /* empty field signifies . */\n\t  error (EXIT_FAILURE, 0,\n\t\t _(\"The current directory is included in the PATH \"\n\t\t   \"environment variable, which is insecure in \"\n\t\t   \"combination with the %s action of find.  \"\n\t\t   \"Please remove the current directory from your \"\n\t\t   \"$PATH (that is, remove \\\".\\\", doubled colons, \"\n\t\t   \"or leading or trailing colons)\"),\n\t\t action);\n\t}\n      else if (path[pos] != '/')\n\t{\n\t  char *relpath = strndup (&path[pos], len);\n\t  error (EXIT_FAILURE, 0,\n\t\t _(\"The relative path %s is included in the PATH \"\n\t\t   \"environment variable, which is insecure in \"\n\t\t   \"combination with the %s action of find.  \"\n\t\t   \"Please remove that entry from $PATH\"),\n\t\t safely_quote_err_filename (0, relpath ? relpath : &path[pos]),\n\t\t action);\n\t  /*NOTREACHED*/\n\t  free (relpath);\n\t}\n    } while (splitstring (path, path_separators, false, &pos, &len));\n}",
      "lines": 47,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "insert_exec_ok": {
      "start_point": [
        2895,
        0
      ],
      "end_point": [
        3113,
        1
      ],
      "content": "static bool\ninsert_exec_ok (const char *action,\n\t\tconst struct parser_table *entry,\n\t\tchar **argv,\n\t\tint *arg_ptr)\n{\n  int start, end;\t\t/* Indexes in ARGV of start & end of cmd. */\n  int i;\t\t\t/* Index into cmd args */\n  int saw_braces;\t\t/* True if previous arg was '{}'. */\n  bool allow_plus;\t\t/* True if + is a valid terminator */\n  int brace_count;\t\t/* Number of instances of {}. */\n  const char *brace_arg;\t/* Which arg did {} appear in? */\n  PRED_FUNC func = entry->pred_func;\n  enum BC_INIT_STATUS bcstatus;\n\n  struct predicate *our_pred;\n  struct exec_val *execp;\t/* Pointer for efficiency. */\n\n  if ((argv == NULL) || (argv[*arg_ptr] == NULL))\n    return false;\n\n  our_pred = insert_primary_withpred (entry, func, \"(some -exec* arguments)\");\n  our_pred->side_effects = our_pred->no_default_print = true;\n  our_pred->need_type = our_pred->need_stat = false;\n\n  execp = &our_pred->args.exec_vec;\n  execp->wd_for_exec = NULL;\n\n  if ((func != pred_okdir) && (func != pred_ok))\n    {\n      allow_plus = true;\n      execp->close_stdin = false;\n    }\n  else\n    {\n      allow_plus = false;\n      /* If find reads stdin (i.e. for -ok and similar), close stdin\n       * in the child to prevent some script from consiming the output\n       * intended for find.\n       */\n      execp->close_stdin = true;\n    }\n\n\n  if ((func == pred_execdir) || (func == pred_okdir))\n    {\n      execp->wd_for_exec = NULL;\n      options.ignore_readdir_race = false;\n      check_path_safety (action);\n    }\n  else\n    {\n      assert (NULL != initial_wd);\n      execp->wd_for_exec = initial_wd;\n    }\n\n  our_pred->args.exec_vec.multiple = 0;\n\n  /* Count the number of args with path replacements, up until the ';'.\n   * Also figure out if the command is terminated by \";\" or by \"+\".\n   */\n  start = *arg_ptr;\n  for (end = start, saw_braces=0, brace_count=0, brace_arg=NULL;\n       (argv[end] != NULL)\n       && ((argv[end][0] != ';') || (argv[end][1] != '\\0'));\n       end++)\n    {\n      /* For -exec and -execdir, \"{} +\" can terminate the command. */\n      if ( allow_plus\n\t   && argv[end][0] == '+' && argv[end][1] == 0\n\t   && saw_braces)\n\t{\n\t  our_pred->args.exec_vec.multiple = 1;\n\t  break;\n\t}\n\n      saw_braces = 0;\n      if (mbsstr (argv[end], \"{}\"))\n\t{\n\t  saw_braces = 1;\n\t  brace_arg = argv[end];\n\t  ++brace_count;\n\n\t  if (0 == end && (func == pred_execdir || func == pred_okdir))\n\t    {\n\t      /* The POSIX standard says that {} replacement should\n\t       * occur even in the utility name.  This is insecure\n\t       * since it means we will be executing a command whose\n\t       * name is chosen according to whatever find finds in\n\t       * the file system.  That can be influenced by an\n\t       * attacker.  Hence for -execdir and -okdir this is not\n\t       * allowed.  We can specify this as those options are\n\t       * not defined by POSIX.\n\t       */\n\t      error (EXIT_FAILURE, 0,\n\t\t     _(\"You may not use {} within the utility name for \"\n\t\t       \"-execdir and -okdir, because this is a potential \"\n\t\t       \"security problem.\"));\n\t    }\n\t}\n    }\n\n  /* Fail if no command given or no semicolon found. */\n  if ((end == start) || (argv[end] == NULL))\n    {\n      *arg_ptr = end;\n      free (our_pred);\n      return false;\n    }\n\n  if (our_pred->args.exec_vec.multiple)\n    {\n      const char *suffix;\n      if (func == pred_execdir)\n\tsuffix = \"dir\";\n      else\n\tsuffix = \"\";\n\n      if (brace_count > 1)\n\t{\n\t  error (EXIT_FAILURE, 0,\n\t\t _(\"Only one instance of {} is supported with -exec%s ... +\"),\n\t\t suffix);\n\t}\n      else if (strlen (brace_arg) != 2u)\n\t{\n\t  enum { MsgBufSize = 19 };\n\t  char buf[MsgBufSize];\n\t  const size_t needed = snprintf (buf, MsgBufSize, \"-exec%s ... {} +\", suffix);\n\t  assert (needed <= MsgBufSize);  /* If this assertion fails, correct the value of MsgBufSize. */\n\t  error (EXIT_FAILURE, 0,\n\t\t _(\"In %s the %s must appear by itself, but you specified %s\"),\n\t\t quotearg_n_style (0, options.err_quoting_style, buf),\n\t\t quotearg_n_style (1, options.err_quoting_style, \"{}\"),\n\t\t quotearg_n_style (2, options.err_quoting_style, brace_arg));\n\t}\n    }\n\n  /* We use a switch statement here so that the compiler warns us when\n   * we forget to handle a newly invented enum value.\n   *\n   * Like xargs, we allow 2KiB of headroom for the launched utility to\n   * export its own environment variables before calling something\n   * else.\n   */\n  bcstatus = bc_init_controlinfo (&execp->ctl, 2048u);\n  switch (bcstatus)\n    {\n    case BC_INIT_ENV_TOO_BIG:\n    case BC_INIT_CANNOT_ACCOMODATE_HEADROOM:\n      error (EXIT_FAILURE, 0,\n\t     _(\"The environment is too large for exec().\"));\n      break;\n    case BC_INIT_OK:\n      /* Good news.  Carry on. */\n      break;\n    }\n  bc_use_sensible_arg_max (&execp->ctl);\n\n\n  execp->ctl.exec_callback = launch;\n\n  if (our_pred->args.exec_vec.multiple)\n    {\n      /* \"+\" terminator, so we can just append our arguments after the\n       * command and initial arguments.\n       */\n      execp->replace_vec = NULL;\n      execp->ctl.replace_pat = NULL;\n      execp->ctl.rplen = 0;\n      execp->ctl.lines_per_exec = 0; /* no limit */\n      execp->ctl.args_per_exec = 0; /* no limit */\n\n      /* remember how many arguments there are */\n      execp->ctl.initial_argc = (end-start) - 1;\n\n      /* execp->state = xmalloc(sizeof struct buildcmd_state); */\n      bc_init_state (&execp->ctl, &execp->state, execp);\n\n      /* Gather the initial arguments.  Skip the {}. */\n      for (i=start; i<end-1; ++i)\n\t{\n\t  bc_push_arg (&execp->ctl, &execp->state,\n\t\t       argv[i], strlen (argv[i])+1,\n\t\t       NULL, 0,\n\t\t       1);\n\t}\n    }\n  else\n    {\n      /* Semicolon terminator - more than one {} is supported, so we\n       * have to do brace-replacement.\n       */\n      execp->num_args = end - start;\n\n      execp->ctl.replace_pat = \"{}\";\n      execp->ctl.rplen = strlen (execp->ctl.replace_pat);\n      execp->ctl.lines_per_exec = 0; /* no limit */\n      execp->ctl.args_per_exec = 0; /* no limit */\n      execp->replace_vec = xmalloc (sizeof(char*)*execp->num_args);\n\n\n      /* execp->state = xmalloc(sizeof(*(execp->state))); */\n      bc_init_state (&execp->ctl, &execp->state, execp);\n\n      /* Remember the (pre-replacement) arguments for later. */\n      for (i=0; i<execp->num_args; ++i)\n\t{\n\t  execp->replace_vec[i] = argv[i+start];\n\t}\n    }\n\n  if (argv[end] == NULL)\n    *arg_ptr = end;\n  else\n    *arg_ptr = end + 1;\n\n  return true;\n}",
      "lines": 219,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "get_relative_timestamp": {
      "start_point": [
        3130,
        0
      ],
      "end_point": [
        3194,
        1
      ],
      "content": "static bool\nget_relative_timestamp (const char *str,\n\t\t\tstruct time_val *result,\n\t\t\tstruct timespec origin,\n\t\t\tdouble sec_per_unit,\n\t\t\tconst char *overflowmessage)\n{\n  double offset, seconds, nanosec;\n  static const long nanosec_per_sec = 1000000000;\n\n  if (get_comp_type (&str, &result->kind))\n    {\n      /* Invert the sense of the comparison */\n      switch (result->kind)\n\t{\n\tcase COMP_LT: result->kind = COMP_GT; break;\n\tcase COMP_GT: result->kind = COMP_LT; break;\n\tcase COMP_EQ:\n\t  break; /* inversion leaves it unchanged */\n\t}\n\n      /* Convert the ASCII number into floating-point. */\n      if (xstrtod (str, NULL, &offset, strtod))\n\t{\n\t  /* Separate the floating point number the user specified\n\t   * (which is a number of days, or minutes, etc) into an\n\t   * integral number of seconds (SECONDS) and a fraction (NANOSEC).\n\t   */\n\t  nanosec = modf (offset * sec_per_unit, &seconds);\n\t  nanosec *= 1.0e9;\t/* convert from fractional seconds to ns. */\n\t  assert (nanosec < nanosec_per_sec);\n\n\t  /* Perform the subtraction, and then check for overflow.\n\t   * On systems where signed aritmetic overflow does not\n\t   * wrap, this check may be unreliable.   The C standard\n\t   * does not require this approach to work, but I am aware\n\t   * of no platforms where it fails.\n\t   */\n\t  result->ts.tv_sec  = origin.tv_sec - seconds;\n\t  if ((origin.tv_sec < result->ts.tv_sec) != (seconds < 0))\n\t    {\n\t      /* an overflow has occurred. */\n\t      error (EXIT_FAILURE, 0, overflowmessage, str);\n\t    }\n\n\t  result->ts.tv_nsec = origin.tv_nsec - nanosec;\n\t  if (origin.tv_nsec < nanosec)\n\t    {\n\t      /* Perform a carry operation */\n\t      result->ts.tv_nsec += nanosec_per_sec;\n\t      result->ts.tv_sec  -= 1;\n\t    }\n\t  return true;\n\t}\n      else\n\t{\n\t  /* Conversion from ASCII to double failed. */\n\t  return false;\n\t}\n    }\n  else\n    {\n      return false;\n    }\n}",
      "lines": 65,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "parse_time": {
      "start_point": [
        3208,
        0
      ],
      "end_point": [
        3283,
        1
      ],
      "content": "static bool\nparse_time (const struct parser_table* entry, char *argv[], int *arg_ptr)\n{\n  struct predicate *our_pred;\n  struct time_val tval;\n  enum comparison_type comp;\n  const char *timearg, *orig_timearg;\n  const char *errmsg = _(\"arithmetic overflow while converting %s \"\n\t\t\t \"days to a number of seconds\");\n  struct timespec origin;\n  const int saved_argc = *arg_ptr;\n\n  if (!collect_arg (argv, arg_ptr, &timearg))\n    return false;\n  orig_timearg = timearg;\n\n  /* Decide the origin by previewing the comparison type. */\n  origin = options.cur_day_start;\n\n  if (get_comp_type (&timearg, &comp))\n    {\n      /* Remember, we invert the sense of the comparison, so this tests\n       * against COMP_LT instead of COMP_GT...\n       */\n      if (COMP_LT == comp)\n\t{\n\t  uintmax_t expected = origin.tv_sec + (DAYSECS-1);\n\t  origin.tv_sec += (DAYSECS-1);\n\t  if (origin.tv_sec != expected)\n\t    {\n\t      error (EXIT_FAILURE, 0,\n\t\t     _(\"arithmetic overflow when trying to calculate the end of today\"));\n\t    }\n\t}\n    }\n  /* We discard the value of comp here, as get_relative_timestamp\n   * will set tval.kind.  For that to work, we have to restore\n   * timearg so that it points to the +/- prefix, if any.  get_comp_type()\n   * will have advanced timearg, so we restore it.\n   */\n  timearg = orig_timearg;\n\n  if (!get_relative_timestamp (timearg, &tval, origin, DAYSECS, errmsg))\n    {\n      *arg_ptr = saved_argc;\t/* don't consume the invalid argument */\n      return false;\n    }\n\n  our_pred = insert_primary (entry, orig_timearg);\n  our_pred->args.reftime = tval;\n  our_pred->est_success_rate = estimate_timestamp_success_rate (tval.ts.tv_sec);\n\n  if (options.debug_options & DebugExpressionTree)\n    {\n      time_t t;\n\n      fprintf (stderr, \"inserting %s\\n\", our_pred->p_name);\n      fprintf (stderr, \"    type: %s    %s  \",\n\t       (tval.kind == COMP_GT) ? \"gt\" :\n\t       ((tval.kind == COMP_LT) ? \"lt\" : ((tval.kind == COMP_EQ) ? \"eq\" : \"?\")),\n\t       (tval.kind == COMP_GT) ? \" >\" :\n\t       ((tval.kind == COMP_LT) ? \" <\" : ((tval.kind == COMP_EQ) ? \">=\" : \" ?\")));\n      t = our_pred->args.reftime.ts.tv_sec;\n      fprintf (stderr, \"%ju %s\",\n\t       (uintmax_t) our_pred->args.reftime.ts.tv_sec,\n\t       ctime (&t));\n      if (tval.kind == COMP_EQ)\n\t{\n\t  t = our_pred->args.reftime.ts.tv_sec + DAYSECS;\n\t  fprintf (stderr, \"                 <  %ju %s\",\n\t\t   (uintmax_t) t, ctime (&t));\n\t}\n    }\n\n  return true;\n}",
      "lines": 76,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "get_comp_type": {
      "start_point": [
        3291,
        0
      ],
      "end_point": [
        3309,
        1
      ],
      "content": "static bool\nget_comp_type (const char **str, enum comparison_type *comp_type)\n{\n  switch (**str)\n    {\n    case '+':\n      *comp_type = COMP_GT;\n      (*str)++;\n      break;\n    case '-':\n      *comp_type = COMP_LT;\n      (*str)++;\n      break;\n    default:\n      *comp_type = COMP_EQ;\n      break;\n    }\n  return true;\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "get_num": {
      "start_point": [
        3325,
        0
      ],
      "end_point": [
        3343,
        1
      ],
      "content": "static bool\nget_num (const char *str,\n\t uintmax_t *num,\n\t enum comparison_type *comp_type)\n{\n  char *pend;\n\n  if (str == NULL)\n    return false;\n\n  /* Figure out the comparison type if the caller accepts one. */\n  if (comp_type)\n    {\n      if (!get_comp_type (&str, comp_type))\n\treturn false;\n    }\n\n  return xstrtoumax (str, &pend, 10, num, \"\") == LONGINT_OK;\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "insert_num": {
      "start_point": [
        3357,
        0
      ],
      "end_point": [
        3387,
        1
      ],
      "content": "static struct predicate *\ninsert_num (char **argv, int *arg_ptr, const struct parser_table *entry)\n{\n  const char *numstr;\n\n  if (collect_arg (argv, arg_ptr, &numstr))\n  {\n    uintmax_t num;\n    enum comparison_type c_type;\n\n    if (get_num (numstr, &num, &c_type))\n      {\n\tstruct predicate *our_pred = insert_primary (entry, numstr);\n\tour_pred->args.numinfo.kind = c_type;\n\tour_pred->args.numinfo.l_val = num;\n\n\tif (options.debug_options & DebugExpressionTree)\n\t  {\n\t    fprintf (stderr, \"inserting %s\\n\", our_pred->p_name);\n\t    fprintf (stderr, \"    type: %s    %s  \",\n\t\t     (c_type == COMP_GT) ? \"gt\" :\n\t\t     ((c_type == COMP_LT) ? \"lt\" : ((c_type == COMP_EQ) ? \"eq\" : \"?\")),\n\t\t     (c_type == COMP_GT) ? \" >\" :\n\t\t     ((c_type == COMP_LT) ? \" <\" : ((c_type == COMP_EQ) ? \" =\" : \" ?\")));\n\t    fprintf (stderr, \"%ju\\n\", our_pred->args.numinfo.l_val);\n\t  }\n\treturn our_pred;\n      }\n  }\n  return NULL;\n}",
      "lines": 31,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "struct predicate",
        "struct",
        "predicate",
        "*\ninsert_num (char **argv, int *arg_ptr, const struct parser_table *entry)",
        "*"
      ]
    },
    "open_output_file": {
      "start_point": [
        3389,
        0
      ],
      "end_point": [
        3417,
        1
      ],
      "content": "static void\nopen_output_file (const char *path, struct format_val *p)\n{\n  p->segment = NULL;\n  p->quote_opts = clone_quoting_options (NULL);\n\n  if (!strcmp (path, \"/dev/stderr\"))\n    {\n      p->stream = stderr;\n      p->filename = _(\"standard error\");\n    }\n  else if (!strcmp (path, \"/dev/stdout\"))\n    {\n      p->stream = stdout;\n      p->filename = _(\"standard output\");\n    }\n  else\n    {\n      p->stream = sharefile_fopen (state.shared_files, path);\n      p->filename = path;\n\n      if (p->stream == NULL)\n\t{\n\t  fatal_nontarget_file_error (errno, path);\n\t}\n    }\n\n  p->dest_is_tty = stream_is_tty (p->stream);\n}",
      "lines": 29,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "open_stdout": {
      "start_point": [
        3419,
        0
      ],
      "end_point": [
        3423,
        1
      ],
      "content": "static void\nopen_stdout (struct format_val *p)\n{\n  open_output_file (\"/dev/stdout\", p);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "findutils/findutils-4.6.0/find/pred.c": {
    "ts_difference": {
      "start_point": [
        150,
        0
      ],
      "end_point": [
        156,
        1
      ],
      "content": "static double ts_difference (struct timespec ts1,\n\t\t\t     struct timespec ts2)\n{\n  double d =  difftime (ts1.tv_sec, ts2.tv_sec)\n    + (1.0e-9 * (ts1.tv_nsec - ts2.tv_nsec));\n  return d;\n}",
      "lines": 7,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "compare_ts": {
      "start_point": [
        159,
        0
      ],
      "end_point": [
        173,
        1
      ],
      "content": "static int\ncompare_ts (struct timespec ts1,\n\t    struct timespec ts2)\n{\n  if ((ts1.tv_sec == ts2.tv_sec) &&\n      (ts1.tv_nsec == ts2.tv_nsec))\n    {\n      return 0;\n    }\n  else\n    {\n      double diff = ts_difference (ts1, ts2);\n      return diff < 0.0 ? -1 : +1;\n    }\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "pred_timewindow": {
      "start_point": [
        191,
        0
      ],
      "end_point": [
        223,
        1
      ],
      "content": "static bool\npred_timewindow (struct timespec ts, struct predicate const *pred_ptr, int window)\n{\n  switch (pred_ptr->args.reftime.kind)\n    {\n    case COMP_GT:\n      return compare_ts (ts, pred_ptr->args.reftime.ts) > 0;\n\n    case COMP_LT:\n      return compare_ts (ts, pred_ptr->args.reftime.ts) < 0;\n\n    case COMP_EQ:\n      {\n\t/* consider \"find . -mtime 0\".\n\t *\n\t * Here, the origin is exactly 86400 seconds before the start\n\t * of the program (since -daystart was not specified).   This\n\t * function will be called with window=86400 and\n\t * pred_ptr->args.reftime.ts as the origin.  Hence a file\n\t * created the instant the program starts will show a time\n\t * difference (value of delta) of 86400.   Similarly, a file\n\t * created exactly 24h ago would be the newest file which was\n\t * _not_ created today.   So, if delta is 0.0, the file\n\t * was not created today.  If the delta is 86400, the file\n\t * was created this instant.\n\t */\n\tdouble delta = ts_difference (ts, pred_ptr->args.reftime.ts);\n\treturn (delta > 0.0 && delta <= window);\n      }\n    }\n  assert (0);\n  abort ();\n}",
      "lines": 33,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "pred_amin": {
      "start_point": [
        226,
        0
      ],
      "end_point": [
        231,
        1
      ],
      "content": "bool\npred_amin (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)\n{\n  (void) &pathname;\n  return pred_timewindow (get_stat_atime(stat_buf), pred_ptr, 60);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "bool"
      ]
    },
    "pred_and": {
      "start_point": [
        233,
        0
      ],
      "end_point": [
        243,
        1
      ],
      "content": "bool\npred_and (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)\n{\n  if (pred_ptr->pred_left == NULL\n      || apply_predicate (pathname, stat_buf, pred_ptr->pred_left))\n    {\n      return apply_predicate (pathname, stat_buf, pred_ptr->pred_right);\n    }\n  else\n    return false;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    },
    "pred_anewer": {
      "start_point": [
        245,
        0
      ],
      "end_point": [
        251,
        1
      ],
      "content": "bool\npred_anewer (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)\n{\n  (void) &pathname;\n  assert (COMP_GT == pred_ptr->args.reftime.kind);\n  return compare_ts (get_stat_atime(stat_buf), pred_ptr->args.reftime.ts) > 0;\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "bool"
      ]
    },
    "pred_atime": {
      "start_point": [
        253,
        0
      ],
      "end_point": [
        258,
        1
      ],
      "content": "bool\npred_atime (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)\n{\n  (void) &pathname;\n  return pred_timewindow (get_stat_atime(stat_buf), pred_ptr, DAYSECS);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "bool"
      ]
    },
    "pred_closeparen": {
      "start_point": [
        260,
        0
      ],
      "end_point": [
        268,
        1
      ],
      "content": "bool\npred_closeparen (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)\n{\n  (void) &pathname;\n  (void) &stat_buf;\n  (void) &pred_ptr;\n\n  return true;\n}",
      "lines": 9,
      "depth": 6,
      "decorators": [
        "bool"
      ]
    },
    "pred_cmin": {
      "start_point": [
        270,
        0
      ],
      "end_point": [
        275,
        1
      ],
      "content": "bool\npred_cmin (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)\n{\n  (void) pathname;\n  return pred_timewindow (get_stat_ctime(stat_buf), pred_ptr, 60);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "bool"
      ]
    },
    "pred_cnewer": {
      "start_point": [
        277,
        0
      ],
      "end_point": [
        284,
        1
      ],
      "content": "bool\npred_cnewer (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)\n{\n  (void) pathname;\n\n  assert (COMP_GT == pred_ptr->args.reftime.kind);\n  return compare_ts (get_stat_ctime(stat_buf), pred_ptr->args.reftime.ts) > 0;\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "bool"
      ]
    },
    "pred_comma": {
      "start_point": [
        286,
        0
      ],
      "end_point": [
        294,
        1
      ],
      "content": "bool\npred_comma (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)\n{\n  if (pred_ptr->pred_left != NULL)\n    {\n      apply_predicate (pathname, stat_buf,pred_ptr->pred_left);\n    }\n  return apply_predicate (pathname, stat_buf, pred_ptr->pred_right);\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    },
    "pred_ctime": {
      "start_point": [
        296,
        0
      ],
      "end_point": [
        301,
        1
      ],
      "content": "bool\npred_ctime (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)\n{\n  (void) &pathname;\n  return pred_timewindow (get_stat_ctime(stat_buf), pred_ptr, DAYSECS);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "bool"
      ]
    },
    "perform_delete": {
      "start_point": [
        303,
        0
      ],
      "end_point": [
        307,
        1
      ],
      "content": "static bool\nperform_delete (int flags)\n{\n  return 0 == unlinkat (state.cwd_dir_fd, state.rel_pathname, flags);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "pred_delete": {
      "start_point": [
        310,
        0
      ],
      "end_point": [
        357,
        1
      ],
      "content": "bool\npred_delete (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)\n{\n  (void) pred_ptr;\n  (void) stat_buf;\n  if (strcmp (state.rel_pathname, \".\"))\n    {\n      int flags=0;\n      if (state.have_stat && S_ISDIR(stat_buf->st_mode))\n\tflags |= AT_REMOVEDIR;\n      if (perform_delete (flags))\n\t{\n\t  return true;\n\t}\n      else\n\t{\n\t  if (EISDIR == errno)\n\t    {\n\t      if ((flags & AT_REMOVEDIR) == 0)\n\t\t{\n\t\t  /* unlink() operation failed because we should have done rmdir(). */\n\t\t  flags |= AT_REMOVEDIR;\n\t\t  if (perform_delete (flags))\n\t\t    return true;\n\t\t}\n\t    }\n\t}\n      error (0, errno, _(\"cannot delete %s\"),\n\t     safely_quote_err_filename (0, pathname));\n      /* Previously I had believed that having the -delete action\n       * return false provided the user with control over whether an\n       * error message is issued.  While this is true, the policy of\n       * not affecting the exit status is contrary to the POSIX\n       * requirement that diagnostic messages are accompanied by a\n       * nonzero exit status.  While -delete is not a POSIX option and\n       * we can therefore opt not to follow POSIX in this case, that\n       * seems somewhat arbitrary and confusing.  So, as of\n       * findutils-4.3.11, we also set the exit status in this case.\n       */\n      state.exit_status = 1;\n      return false;\n    }\n  else\n    {\n      /* nothing to do. */\n      return true;\n    }\n}",
      "lines": 48,
      "depth": 15,
      "decorators": [
        "bool"
      ]
    },
    "pred_empty": {
      "start_point": [
        359,
        0
      ],
      "end_point": [
        412,
        1
      ],
      "content": "bool\npred_empty (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)\n{\n  (void) pathname;\n  (void) pred_ptr;\n\n  if (S_ISDIR (stat_buf->st_mode))\n    {\n      int fd;\n      DIR *d;\n      struct dirent *dp;\n      bool empty = true;\n\n      errno = 0;\n      if ((fd = openat (state.cwd_dir_fd, state.rel_pathname, O_RDONLY\n#if defined O_LARGEFILE\n\t\t\t|O_LARGEFILE\n#endif\n\t\t       )) < 0)\n\t{\n\t  error (0, errno, \"%s\", safely_quote_err_filename (0, pathname));\n\t  state.exit_status = 1;\n\t  return false;\n\t}\n      d = fdopendir (fd);\n      if (d == NULL)\n\t{\n\t  error (0, errno, \"%s\", safely_quote_err_filename (0, pathname));\n\t  state.exit_status = 1;\n\t  return false;\n\t}\n      for (dp = readdir (d); dp; dp = readdir (d))\n\t{\n\t  if (dp->d_name[0] != '.'\n\t      || (dp->d_name[1] != '\\0'\n\t\t  && (dp->d_name[1] != '.' || dp->d_name[2] != '\\0')))\n\t    {\n\t      empty = false;\n\t      break;\n\t    }\n\t}\n      if (CLOSEDIR (d))\n\t{\n\t  error (0, errno, \"%s\", safely_quote_err_filename (0, pathname));\n\t  state.exit_status = 1;\n\t  return false;\n\t}\n      return (empty);\n    }\n  else if (S_ISREG (stat_buf->st_mode))\n    return (stat_buf->st_size == 0);\n  else\n    return (false);\n}",
      "lines": 54,
      "depth": 17,
      "decorators": [
        "bool"
      ]
    },
    "pred_exec": {
      "start_point": [
        415,
        0
      ],
      "end_point": [
        419,
        1
      ],
      "content": "bool\npred_exec (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)\n{\n  return impl_pred_exec (pathname, stat_buf, pred_ptr);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "bool"
      ]
    },
    "pred_execdir": {
      "start_point": [
        421,
        0
      ],
      "end_point": [
        426,
        1
      ],
      "content": "bool\npred_execdir (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)\n{\n   (void) &pathname;\n   return impl_pred_exec (state.rel_pathname, stat_buf, pred_ptr);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    },
    "pred_false": {
      "start_point": [
        428,
        0
      ],
      "end_point": [
        437,
        1
      ],
      "content": "bool\npred_false (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)\n{\n  (void) &pathname;\n  (void) &stat_buf;\n  (void) &pred_ptr;\n\n\n  return (false);\n}",
      "lines": 10,
      "depth": 6,
      "decorators": [
        "bool"
      ]
    },
    "pred_fls": {
      "start_point": [
        439,
        0
      ],
      "end_point": [
        448,
        1
      ],
      "content": "bool\npred_fls (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)\n{\n  FILE * stream = pred_ptr->args.printf_vec.stream;\n  list_file (pathname, state.cwd_dir_fd, state.rel_pathname, stat_buf,\n\t     options.start_time.tv_sec,\n\t     options.output_block_size,\n\t     pred_ptr->literal_control_chars, stream);\n  return true;\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "bool"
      ]
    },
    "pred_fprint": {
      "start_point": [
        450,
        0
      ],
      "end_point": [
        462,
        1
      ],
      "content": "bool\npred_fprint (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)\n{\n  (void) &pathname;\n  (void) &stat_buf;\n\n  print_quoted (pred_ptr->args.printf_vec.stream,\n\t\tpred_ptr->args.printf_vec.quote_opts,\n\t\tpred_ptr->args.printf_vec.dest_is_tty,\n\t\t\"%s\\n\",\n\t\tpathname);\n  return true;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    },
    "pred_fprint0": {
      "start_point": [
        464,
        0
      ],
      "end_point": [
        474,
        1
      ],
      "content": "bool\npred_fprint0 (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)\n{\n  FILE * fp = pred_ptr->args.printf_vec.stream;\n\n  (void) &stat_buf;\n\n  fputs (pathname, fp);\n  putc (0, fp);\n  return true;\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "bool"
      ]
    },
    "pred_fstype": {
      "start_point": [
        478,
        0
      ],
      "end_point": [
        487,
        1
      ],
      "content": "bool\npred_fstype (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)\n{\n  (void) pathname;\n\n  if (strcmp (filesystem_type (stat_buf, pathname), pred_ptr->args.str) == 0)\n    return true;\n  else\n    return false;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "bool"
      ]
    },
    "pred_gid": {
      "start_point": [
        489,
        0
      ],
      "end_point": [
        510,
        1
      ],
      "content": "bool\npred_gid (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)\n{\n  (void) pathname;\n\n  switch (pred_ptr->args.numinfo.kind)\n    {\n    case COMP_GT:\n      if (stat_buf->st_gid > pred_ptr->args.numinfo.l_val)\n\treturn (true);\n      break;\n    case COMP_LT:\n      if (stat_buf->st_gid < pred_ptr->args.numinfo.l_val)\n\treturn (true);\n      break;\n    case COMP_EQ:\n      if (stat_buf->st_gid == pred_ptr->args.numinfo.l_val)\n\treturn (true);\n      break;\n    }\n  return (false);\n}",
      "lines": 22,
      "depth": 12,
      "decorators": [
        "bool"
      ]
    },
    "pred_group": {
      "start_point": [
        512,
        0
      ],
      "end_point": [
        521,
        1
      ],
      "content": "bool\npred_group (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)\n{\n  (void) pathname;\n\n  if (pred_ptr->args.gid == stat_buf->st_gid)\n    return (true);\n  else\n    return (false);\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "bool"
      ]
    },
    "pred_ilname": {
      "start_point": [
        523,
        0
      ],
      "end_point": [
        527,
        1
      ],
      "content": "bool\npred_ilname (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)\n{\n  return match_lname (pathname, stat_buf, pred_ptr, true);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "bool"
      ]
    },
    "pred_name_common": {
      "start_point": [
        533,
        0
      ],
      "end_point": [
        552,
        1
      ],
      "content": "static bool\npred_name_common (const char *pathname, const char *str, int flags)\n{\n  bool b;\n  /* We used to use last_component() here, but that would not allow us to modify the\n   * input string, which is const.   We could optimise by duplicating the string only\n   * if we need to modify it, and I'll do that if there is a measurable\n   * performance difference on a machine built after 1990...\n   */\n  char *base = base_name (pathname);\n  /* remove trailing slashes, but leave  \"/\" or \"//foo\" unchanged. */\n  strip_trailing_slashes (base);\n\n  /* FNM_PERIOD is not used here because POSIX requires that it not be.\n   * See http://standards.ieee.org/reading/ieee/interp/1003-2-92_int/pasc-1003.2-126.html\n   */\n  b = fnmatch (str, base, flags) == 0;\n  free (base);\n  return b;\n}",
      "lines": 20,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "pred_iname": {
      "start_point": [
        554,
        0
      ],
      "end_point": [
        559,
        1
      ],
      "content": "bool\npred_iname (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)\n{\n  (void) stat_buf;\n  return pred_name_common (pathname, pred_ptr->args.str, FNM_CASEFOLD);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "bool"
      ]
    },
    "pred_inum": {
      "start_point": [
        561,
        0
      ],
      "end_point": [
        584,
        1
      ],
      "content": "bool\npred_inum (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)\n{\n  (void) pathname;\n\n  assert (stat_buf->st_ino != 0);\n\n  switch (pred_ptr->args.numinfo.kind)\n    {\n    case COMP_GT:\n      if (stat_buf->st_ino > pred_ptr->args.numinfo.l_val)\n\treturn (true);\n      break;\n    case COMP_LT:\n      if (stat_buf->st_ino < pred_ptr->args.numinfo.l_val)\n\treturn (true);\n      break;\n    case COMP_EQ:\n      if (stat_buf->st_ino == pred_ptr->args.numinfo.l_val)\n\treturn (true);\n      break;\n    }\n  return (false);\n}",
      "lines": 24,
      "depth": 12,
      "decorators": [
        "bool"
      ]
    },
    "pred_ipath": {
      "start_point": [
        586,
        0
      ],
      "end_point": [
        594,
        1
      ],
      "content": "bool\npred_ipath (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)\n{\n  (void) stat_buf;\n\n  if (fnmatch (pred_ptr->args.str, pathname, FNM_CASEFOLD) == 0)\n    return (true);\n  return (false);\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "bool"
      ]
    },
    "pred_links": {
      "start_point": [
        596,
        0
      ],
      "end_point": [
        617,
        1
      ],
      "content": "bool\npred_links (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)\n{\n  (void) pathname;\n\n  switch (pred_ptr->args.numinfo.kind)\n    {\n    case COMP_GT:\n      if (stat_buf->st_nlink > pred_ptr->args.numinfo.l_val)\n\treturn (true);\n      break;\n    case COMP_LT:\n      if (stat_buf->st_nlink < pred_ptr->args.numinfo.l_val)\n\treturn (true);\n      break;\n    case COMP_EQ:\n      if (stat_buf->st_nlink == pred_ptr->args.numinfo.l_val)\n\treturn (true);\n      break;\n    }\n  return (false);\n}",
      "lines": 22,
      "depth": 12,
      "decorators": [
        "bool"
      ]
    },
    "pred_lname": {
      "start_point": [
        619,
        0
      ],
      "end_point": [
        623,
        1
      ],
      "content": "bool\npred_lname (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)\n{\n  return match_lname (pathname, stat_buf, pred_ptr, false);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "bool"
      ]
    },
    "match_lname": {
      "start_point": [
        625,
        0
      ],
      "end_point": [
        648,
        1
      ],
      "content": "static bool\nmatch_lname (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr, bool ignore_case)\n{\n  bool ret = false;\n#ifdef S_ISLNK\n  if (S_ISLNK (stat_buf->st_mode))\n    {\n      char *linkname = areadlinkat (state.cwd_dir_fd, state.rel_pathname);\n      if (linkname)\n\t{\n\t  if (fnmatch (pred_ptr->args.str, linkname,\n\t\t       ignore_case ? FNM_CASEFOLD : 0) == 0)\n\t    ret = true;\n\t}\n      else\n\t{\n\t  nonfatal_target_file_error (errno, pathname);\n\t  state.exit_status = 1;\n\t}\n      free (linkname);\n    }\n#endif /* S_ISLNK */\n  return ret;\n}",
      "lines": 24,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "pred_ls": {
      "start_point": [
        650,
        0
      ],
      "end_point": [
        654,
        1
      ],
      "content": "bool\npred_ls (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)\n{\n  return pred_fls (pathname, stat_buf, pred_ptr);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "bool"
      ]
    },
    "pred_mmin": {
      "start_point": [
        656,
        0
      ],
      "end_point": [
        661,
        1
      ],
      "content": "bool\npred_mmin (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)\n{\n  (void) &pathname;\n  return pred_timewindow (get_stat_mtime(stat_buf), pred_ptr, 60);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "bool"
      ]
    },
    "pred_mtime": {
      "start_point": [
        663,
        0
      ],
      "end_point": [
        668,
        1
      ],
      "content": "bool\npred_mtime (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)\n{\n  (void) pathname;\n  return pred_timewindow (get_stat_mtime(stat_buf), pred_ptr, DAYSECS);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "bool"
      ]
    },
    "pred_name": {
      "start_point": [
        670,
        0
      ],
      "end_point": [
        675,
        1
      ],
      "content": "bool\npred_name (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)\n{\n  (void) stat_buf;\n  return pred_name_common (pathname, pred_ptr->args.str, 0);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "bool"
      ]
    },
    "pred_negate": {
      "start_point": [
        677,
        0
      ],
      "end_point": [
        681,
        1
      ],
      "content": "bool\npred_negate (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)\n{\n  return !apply_predicate (pathname, stat_buf, pred_ptr->pred_right);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "bool"
      ]
    },
    "pred_newer": {
      "start_point": [
        683,
        0
      ],
      "end_point": [
        690,
        1
      ],
      "content": "bool\npred_newer (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)\n{\n  (void) pathname;\n\n  assert (COMP_GT == pred_ptr->args.reftime.kind);\n  return compare_ts (get_stat_mtime(stat_buf), pred_ptr->args.reftime.ts) > 0;\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "bool"
      ]
    },
    "pred_newerXY": {
      "start_point": [
        692,
        0
      ],
      "end_point": [
        736,
        1
      ],
      "content": "bool\npred_newerXY (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)\n{\n  struct timespec ts;\n  bool collected = false;\n\n  assert (COMP_GT == pred_ptr->args.reftime.kind);\n\n  switch (pred_ptr->args.reftime.xval)\n    {\n    case XVAL_TIME:\n      assert (pred_ptr->args.reftime.xval != XVAL_TIME);\n      return false;\n\n    case XVAL_ATIME:\n      ts = get_stat_atime (stat_buf);\n      collected = true;\n      break;\n\n    case XVAL_BIRTHTIME:\n      ts = get_stat_birthtime (stat_buf);\n      collected = true;\n      if (ts.tv_nsec < 0)\n\t{\n\t  /* XXX: Cannot determine birth time.  Warn once. */\n\t  error (0, 0, _(\"WARNING: cannot determine birth time of file %s\"),\n\t\t safely_quote_err_filename (0, pathname));\n\t  return false;\n\t}\n      break;\n\n    case XVAL_CTIME:\n      ts = get_stat_ctime (stat_buf);\n      collected = true;\n      break;\n\n    case XVAL_MTIME:\n      ts = get_stat_mtime (stat_buf);\n      collected = true;\n      break;\n    }\n\n  assert (collected);\n  return compare_ts (ts, pred_ptr->args.reftime.ts) > 0;\n}",
      "lines": 45,
      "depth": 14,
      "decorators": [
        "bool"
      ]
    },
    "pred_nogroup": {
      "start_point": [
        738,
        0
      ],
      "end_point": [
        744,
        1
      ],
      "content": "bool\npred_nogroup (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)\n{\n  (void) pathname;\n  (void) pred_ptr;\n  return getgrgid (stat_buf->st_gid) == NULL;\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "bool"
      ]
    },
    "pred_nouser": {
      "start_point": [
        746,
        0
      ],
      "end_point": [
        752,
        1
      ],
      "content": "bool\npred_nouser (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)\n{\n  (void) pathname;\n  (void) pred_ptr;\n  return getpwuid (stat_buf->st_uid) == NULL;\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "bool"
      ]
    },
    "is_ok": {
      "start_point": [
        755,
        0
      ],
      "end_point": [
        771,
        1
      ],
      "content": "static bool\nis_ok (const char *program, const char *arg)\n{\n  fflush (stdout);\n  /* The draft open standard requires that, in the POSIX locale,\n     the last non-blank character of this prompt be '?'.\n     The exact format is not specified.\n     This standard does not have requirements for locales other than POSIX\n  */\n  /* XXX: printing UNTRUSTED data here. */\n  if (fprintf (stderr, _(\"< %s ... %s > ? \"), program, arg) < 0)\n    {\n      error (EXIT_FAILURE, errno, _(\"Failed to write prompt for -ok\"));\n    }\n  fflush (stderr);\n  return yesno ();\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "pred_ok": {
      "start_point": [
        773,
        0
      ],
      "end_point": [
        780,
        1
      ],
      "content": "bool\npred_ok (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)\n{\n  if (is_ok (pred_ptr->args.exec_vec.replace_vec[0], pathname))\n    return impl_pred_exec (pathname, stat_buf, pred_ptr);\n  else\n    return false;\n}",
      "lines": 8,
      "depth": 11,
      "decorators": [
        "bool"
      ]
    },
    "pred_okdir": {
      "start_point": [
        782,
        0
      ],
      "end_point": [
        789,
        1
      ],
      "content": "bool\npred_okdir (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)\n{\n  if (is_ok (pred_ptr->args.exec_vec.replace_vec[0], pathname))\n    return impl_pred_exec (state.rel_pathname, stat_buf, pred_ptr);\n  else\n    return false;\n}",
      "lines": 8,
      "depth": 11,
      "decorators": [
        "bool"
      ]
    },
    "pred_openparen": {
      "start_point": [
        791,
        0
      ],
      "end_point": [
        798,
        1
      ],
      "content": "bool\npred_openparen (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)\n{\n  (void) pathname;\n  (void) stat_buf;\n  (void) pred_ptr;\n  return true;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "bool"
      ]
    },
    "pred_or": {
      "start_point": [
        800,
        0
      ],
      "end_point": [
        810,
        1
      ],
      "content": "bool\npred_or (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)\n{\n  if (pred_ptr->pred_left == NULL\n      || !apply_predicate (pathname, stat_buf, pred_ptr->pred_left))\n    {\n      return apply_predicate (pathname, stat_buf, pred_ptr->pred_right);\n    }\n  else\n    return true;\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "bool"
      ]
    },
    "pred_path": {
      "start_point": [
        812,
        0
      ],
      "end_point": [
        819,
        1
      ],
      "content": "bool\npred_path (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)\n{\n  (void) stat_buf;\n  if (fnmatch (pred_ptr->args.str, pathname, 0) == 0)\n    return (true);\n  return (false);\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "bool"
      ]
    },
    "pred_perm": {
      "start_point": [
        821,
        0
      ],
      "end_point": [
        858,
        1
      ],
      "content": "bool\npred_perm (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)\n{\n  mode_t mode = stat_buf->st_mode;\n  mode_t perm_val = pred_ptr->args.perm.val[S_ISDIR (mode) != 0];\n  (void) pathname;\n  switch (pred_ptr->args.perm.kind)\n    {\n    case PERM_AT_LEAST:\n      return (mode & perm_val) == perm_val;\n      break;\n\n    case PERM_ANY:\n      /* True if any of the bits set in the mask are also set in the file's mode.\n       *\n       *\n       * Otherwise, if onum is prefixed by a hyphen, the primary shall\n       * evaluate as true if at least all of the bits specified in\n       * onum that are also set in the octal mask 07777 are set.\n       *\n       * Eric Blake's interpretation is that the mode argument is zero,\n\n       */\n      if (0 == perm_val)\n\treturn true;\t\t/* Savannah bug 14748; we used to return false */\n      else\n\treturn (mode & perm_val) != 0;\n      break;\n\n    case PERM_EXACT:\n      return (mode & MODE_ALL) == perm_val;\n      break;\n\n    default:\n      abort ();\n      break;\n    }\n}",
      "lines": 38,
      "depth": 11,
      "decorators": [
        "bool"
      ]
    },
    "pred_executable": {
      "start_point": [
        861,
        0
      ],
      "end_point": [
        870,
        1
      ],
      "content": "bool\npred_executable (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)\n{\n  (void) pathname;\n  (void) stat_buf;\n  (void) pred_ptr;\n\n  /* As for access, the check is performed with the real user id. */\n  return 0 == faccessat (state.cwd_dir_fd, state.rel_pathname, X_OK, 0);\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "bool"
      ]
    },
    "pred_readable": {
      "start_point": [
        872,
        0
      ],
      "end_point": [
        881,
        1
      ],
      "content": "bool\npred_readable (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)\n{\n  (void) pathname;\n  (void) stat_buf;\n  (void) pred_ptr;\n\n  /* As for access, the check is performed with the real user id. */\n  return 0 == faccessat (state.cwd_dir_fd, state.rel_pathname, R_OK, 0);\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "bool"
      ]
    },
    "pred_writable": {
      "start_point": [
        883,
        0
      ],
      "end_point": [
        892,
        1
      ],
      "content": "bool\npred_writable (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)\n{\n  (void) pathname;\n  (void) stat_buf;\n  (void) pred_ptr;\n\n  /* As for access, the check is performed with the real user id. */\n  return 0 == faccessat (state.cwd_dir_fd, state.rel_pathname, W_OK, 0);\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "bool"
      ]
    },
    "pred_print": {
      "start_point": [
        894,
        0
      ],
      "end_point": [
        905,
        1
      ],
      "content": "bool\npred_print (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)\n{\n  (void) stat_buf;\n  (void) pred_ptr;\n\n  print_quoted (pred_ptr->args.printf_vec.stream,\n\t\tpred_ptr->args.printf_vec.quote_opts,\n\t\tpred_ptr->args.printf_vec.dest_is_tty,\n\t\t\"%s\\n\", pathname);\n  return true;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    },
    "pred_print0": {
      "start_point": [
        907,
        0
      ],
      "end_point": [
        911,
        1
      ],
      "content": "bool\npred_print0 (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)\n{\n  return pred_fprint0(pathname, stat_buf, pred_ptr);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "bool"
      ]
    },
    "pred_prune": {
      "start_point": [
        913,
        0
      ],
      "end_point": [
        931,
        1
      ],
      "content": "bool\npred_prune (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)\n{\n  (void) pathname;\n  (void) pred_ptr;\n\n  if (options.do_dir_first == true) { /* no effect with -depth */\n    assert (state.have_stat);\n    if (stat_buf != NULL &&\n\tS_ISDIR(stat_buf->st_mode))\n      state.stop_at_current_level = true;\n  }\n\n  /* findutils used to return options.do_dir_first here, so that -prune\n   * returns true only if -depth is not in effect.   But POSIX requires\n   * that -prune always evaluate as true.\n   */\n  return true;\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "bool"
      ]
    },
    "pred_quit": {
      "start_point": [
        933,
        0
      ],
      "end_point": [
        949,
        1
      ],
      "content": "bool\npred_quit (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)\n{\n  (void) pathname;\n  (void) stat_buf;\n  (void) pred_ptr;\n\n  /* Run any cleanups.  This includes executing any command lines\n   * we have partly built but not executed.\n   */\n  cleanup ();\n\n  /* Since -exec and friends don't leave child processes running in the\n   * background, there is no need to wait for them here.\n   */\n  exit (state.exit_status);\t/* 0 for success, etc. */\n}",
      "lines": 17,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    },
    "pred_regex": {
      "start_point": [
        951,
        0
      ],
      "end_point": [
        960,
        1
      ],
      "content": "bool\npred_regex (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)\n{\n  int len = strlen (pathname);\n(void) stat_buf;\n  if (re_match (pred_ptr->args.regex, pathname, len, 0,\n\t\t(struct re_registers *) NULL) == len)\n    return (true);\n  return (false);\n}",
      "lines": 10,
      "depth": 11,
      "decorators": [
        "bool"
      ]
    },
    "pred_size": {
      "start_point": [
        962,
        0
      ],
      "end_point": [
        986,
        1
      ],
      "content": "bool\npred_size (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)\n{\n  uintmax_t f_val;\n\n  (void) pathname;\n  f_val = ((stat_buf->st_size / pred_ptr->args.size.blocksize)\n\t   + (stat_buf->st_size % pred_ptr->args.size.blocksize != 0));\n  switch (pred_ptr->args.size.kind)\n    {\n    case COMP_GT:\n      if (f_val > pred_ptr->args.size.size)\n\treturn (true);\n      break;\n    case COMP_LT:\n      if (f_val < pred_ptr->args.size.size)\n\treturn (true);\n      break;\n    case COMP_EQ:\n      if (f_val == pred_ptr->args.size.size)\n\treturn (true);\n      break;\n    }\n  return (false);\n}",
      "lines": 25,
      "depth": 13,
      "decorators": [
        "bool"
      ]
    },
    "pred_samefile": {
      "start_point": [
        988,
        0
      ],
      "end_point": [
        1027,
        1
      ],
      "content": "bool\npred_samefile (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)\n{\n  /* Potential optimisation: because of the loop protection, we always\n   * know the device of the current directory, hence the device number\n   * of the file we're currently considering.  If -L is not in effect,\n   * and the device number of the file we're looking for is not the\n   * same as the device number of the current directory, this\n   * predicate cannot return true.  Hence there would be no need to\n   * stat the file we're looking at.\n   *\n   * For the moment, we simply compare inode numbers, which should cut\n   * down greatly on the number of calls to stat.  Some of the\n   * remainder will be unnecessary, but the additional complexity\n   * probably isn't worthwhile.\n   */\n  (void) pathname;\n\n  /* We will often still have an fd open on the file under consideration,\n   * but that's just to ensure inode number stability by maintaining\n   * a reference to it; we don't need the file for anything else.\n   */\n  if (stat_buf->st_ino)\n    {\n      if (stat_buf->st_ino != pred_ptr->args.samefileid.ino)\n\treturn false;\n    }\n  /* Now stat the file to check the device number. */\n  if (0 == get_statinfo (pathname, state.rel_pathname, stat_buf))\n    {\n      /* the repeated test here is necessary in case stat_buf.st_ino had been zero. */\n      return stat_buf->st_ino == pred_ptr->args.samefileid.ino\n\t&& stat_buf->st_dev == pred_ptr->args.samefileid.dev;\n    }\n  else\n    {\n      /* get_statinfo will already have emitted an error message. */\n      return false;\n    }\n}",
      "lines": 40,
      "depth": 11,
      "decorators": [
        "bool"
      ]
    },
    "pred_true": {
      "start_point": [
        1029,
        0
      ],
      "end_point": [
        1036,
        1
      ],
      "content": "bool\npred_true (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)\n{\n  (void) pathname;\n  (void) stat_buf;\n  (void) pred_ptr;\n  return true;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "bool"
      ]
    },
    "pred_type": {
      "start_point": [
        1038,
        0
      ],
      "end_point": [
        1087,
        1
      ],
      "content": "bool\npred_type (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)\n{\n  mode_t mode;\n  mode_t type = pred_ptr->args.type;\n\n  assert (state.have_type);\n\n  if (0 == state.type)\n    {\n      /* This can sometimes happen with broken NFS servers.\n       * See Savannah bug #16378.\n       */\n      return false;\n    }\n\n  (void) pathname;\n\n  if (state.have_stat)\n     mode = stat_buf->st_mode;\n  else\n     mode = state.type;\n\n#ifndef S_IFMT\n  /* POSIX system; check `mode' the slow way. */\n  if ((S_ISBLK (mode) && type == S_IFBLK)\n      || (S_ISCHR (mode) && type == S_IFCHR)\n      || (S_ISDIR (mode) && type == S_IFDIR)\n      || (S_ISREG (mode) && type == S_IFREG)\n#ifdef S_IFLNK\n      || (S_ISLNK (mode) && type == S_IFLNK)\n#endif\n#ifdef S_IFIFO\n      || (S_ISFIFO (mode) && type == S_IFIFO)\n#endif\n#ifdef S_IFSOCK\n      || (S_ISSOCK (mode) && type == S_IFSOCK)\n#endif\n#ifdef S_IFDOOR\n      || (S_ISDOOR (mode) && type == S_IFDOOR)\n#endif\n      )\n#else /* S_IFMT */\n  /* Unix system; check `mode' the fast way. */\n  if ((mode & S_IFMT) == type)\n#endif /* S_IFMT */\n    return (true);\n  else\n    return (false);\n}",
      "lines": 50,
      "depth": 17,
      "decorators": [
        "bool"
      ]
    },
    "pred_uid": {
      "start_point": [
        1089,
        0
      ],
      "end_point": [
        1109,
        1
      ],
      "content": "bool\npred_uid (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)\n{\n  (void) pathname;\n  switch (pred_ptr->args.numinfo.kind)\n    {\n    case COMP_GT:\n      if (stat_buf->st_uid > pred_ptr->args.numinfo.l_val)\n\treturn (true);\n      break;\n    case COMP_LT:\n      if (stat_buf->st_uid < pred_ptr->args.numinfo.l_val)\n\treturn (true);\n      break;\n    case COMP_EQ:\n      if (stat_buf->st_uid == pred_ptr->args.numinfo.l_val)\n\treturn (true);\n      break;\n    }\n  return (false);\n}",
      "lines": 21,
      "depth": 12,
      "decorators": [
        "bool"
      ]
    },
    "pred_used": {
      "start_point": [
        1111,
        0
      ],
      "end_point": [
        1129,
        1
      ],
      "content": "bool\npred_used (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)\n{\n  struct timespec delta, at, ct;\n\n  (void) pathname;\n\n  /* TODO: this needs to be retested carefully (manually, if necessary) */\n  at = get_stat_atime (stat_buf);\n  ct = get_stat_ctime (stat_buf);\n  delta.tv_sec  = at.tv_sec  - ct.tv_sec;\n  delta.tv_nsec = at.tv_nsec - ct.tv_nsec;\n  if (delta.tv_nsec < 0)\n    {\n      delta.tv_nsec += 1000000000;\n      delta.tv_sec  -=          1;\n    }\n  return pred_timewindow (delta, pred_ptr, DAYSECS);\n}",
      "lines": 19,
      "depth": 8,
      "decorators": [
        "bool"
      ]
    },
    "pred_user": {
      "start_point": [
        1131,
        0
      ],
      "end_point": [
        1139,
        1
      ],
      "content": "bool\npred_user (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)\n{\n  (void) pathname;\n  if (pred_ptr->args.uid == stat_buf->st_uid)\n    return (true);\n  else\n    return (false);\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "bool"
      ]
    },
    "pred_xtype": {
      "start_point": [
        1141,
        0
      ],
      "end_point": [
        1177,
        1
      ],
      "content": "bool\npred_xtype (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)\n{\n  struct stat sbuf;\t\t/* local copy, not stat_buf because we're using a different stat method */\n  int (*ystat) (const char*, struct stat *p);\n\n  /* If we would normally stat the link itself, stat the target instead.\n   * If we would normally follow the link, stat the link itself instead.\n   */\n  if (following_links ())\n    ystat = optionp_stat;\n  else\n    ystat = optionl_stat;\n\n  set_stat_placeholders (&sbuf);\n  if ((*ystat) (state.rel_pathname, &sbuf) != 0)\n    {\n      if (following_links () && errno == ENOENT)\n\t{\n\t  /* If we failed to follow the symlink,\n\t   * fall back on looking at the symlink itself.\n\t   */\n\t  /* Mimic behavior of ls -lL. */\n\t  return (pred_type (pathname, stat_buf, pred_ptr));\n\t}\n      else\n\t{\n\t  error (0, errno, \"%s\", safely_quote_err_filename (0, pathname));\n\t  state.exit_status = 1;\n\t}\n      return false;\n    }\n  /* Now that we have our stat() information, query it in the same\n   * way that -type does.\n   */\n  return (pred_type (pathname, &sbuf, pred_ptr));\n}",
      "lines": 37,
      "depth": 12,
      "decorators": [
        "bool"
      ]
    },
    "pred_context": {
      "start_point": [
        1180,
        0
      ],
      "end_point": [
        1199,
        1
      ],
      "content": "bool\npred_context (const char *pathname, struct stat *stat_buf,\n\t      struct predicate *pred_ptr)\n{\n  security_context_t scontext;\n  int rv = (*options.x_getfilecon) (state.cwd_dir_fd, state.rel_pathname,\n\t\t\t\t    &scontext);\n  (void) stat_buf;\n\n  if (rv < 0)\n    {\n      error (0, errno, _(\"getfilecon failed: %s\"),\n\t     safely_quote_err_filename (0, pathname));\n      return false;\n    }\n\n  rv = (fnmatch (pred_ptr->args.scontext, scontext, 0) == 0);\n  freecon (scontext);\n  return rv;\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "bool"
      ]
    },
    "blank_rtrim": {
      "start_point": [
        1204,
        0
      ],
      "end_point": [
        1217,
        1
      ],
      "content": "static char *\nblank_rtrim (const char *str, char *buf)\n{\n  int i;\n\n  if (str == NULL)\n    return (NULL);\n  strcpy (buf, str);\n  i = strlen (buf) - 1;\n  while ((i >= 0) && ((buf[i] == ' ') || buf[i] == '\\t'))\n    i--;\n  buf[++i] = '\\0';\n  return buf;\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nblank_rtrim (const char *str, char *buf)",
        "*"
      ]
    },
    "print_list": {
      "start_point": [
        1220,
        0
      ],
      "end_point": [
        1233,
        1
      ],
      "content": "void\nprint_list (FILE *fp, struct predicate *node)\n{\n  struct predicate *cur;\n  char name[256];\n\n  cur = node;\n  while (cur != NULL)\n    {\n      fprintf (fp, \"[%s] \", blank_rtrim (cur->p_name, name));\n      cur = cur->pred_next;\n    }\n  fprintf (fp, \"\\n\");\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "print_parenthesised": {
      "start_point": [
        1236,
        0
      ],
      "end_point": [
        1263,
        1
      ],
      "content": "static void\nprint_parenthesised (FILE *fp, struct predicate *node)\n{\n  int parens = 0;\n\n  if (node)\n    {\n      if ((pred_is (node, pred_or) || pred_is (node, pred_and))\n\t  && node->pred_left == NULL)\n\t{\n\t  /* We print \"<nothing> or  X\" as just \"X\"\n\t   * We print \"<nothing> and X\" as just \"X\"\n\t   */\n\t  print_parenthesised(fp, node->pred_right);\n\t}\n      else\n\t{\n\t  if (node->pred_left || node->pred_right)\n\t    parens = 1;\n\n\t  if (parens)\n\t    fprintf (fp, \"%s\", \" ( \");\n\t  print_optlist (fp, node);\n\t  if (parens)\n\t    fprintf (fp, \"%s\", \" ) \");\n\t}\n    }\n}",
      "lines": 28,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "print_optlist": {
      "start_point": [
        1265,
        0
      ],
      "end_point": [
        1293,
        1
      ],
      "content": "void\nprint_optlist (FILE *fp, const struct predicate *p)\n{\n  if (p)\n    {\n      print_parenthesised (fp, p->pred_left);\n      fprintf (fp,\n\t       \"%s%s%s\",\n\t       p->need_stat ? \"[call stat] \" : \"\",\n\t       p->need_type ? \"[need type] \" : \"\",\n\t       p->need_inum ? \"[need inum] \" : \"\");\n      print_predicate (fp, p);\n      fprintf (fp, \" [%g] \", p->est_success_rate);\n      if (options.debug_options & DebugSuccessRates)\n\t{\n\t  fprintf (fp, \"[%ld/%ld\", p->perf.successes, p->perf.visits);\n\t  if (p->perf.visits)\n\t    {\n\t      double real_rate = (double)p->perf.successes / (double)p->perf.visits;\n\t      fprintf (fp, \"=%g] \", real_rate);\n\t    }\n\t  else\n\t    {\n\t      fprintf (fp, \"=_] \");\n\t    }\n\t}\n      print_parenthesised (fp, p->pred_right);\n    }\n}",
      "lines": 29,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "show_success_rates": {
      "start_point": [
        1295,
        0
      ],
      "end_point": [
        1303,
        1
      ],
      "content": "void show_success_rates (const struct predicate *p)\n{\n  if (options.debug_options & DebugSuccessRates)\n    {\n      fprintf (stderr, \"Predicate success rates after completion:\\n\");\n      print_optlist (stderr, p);\n      fprintf (stderr, \"\\n\");\n    }\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "pred_sanity_check": [
      {
        "start_point": [
          1313,
          0
        ],
        "end_point": [
          1318,
          1
        ],
        "content": "void\npred_sanity_check (const struct predicate *predicates)\n{\n  /* Do nothing, since assert is a no-op with _NDEBUG set */\n  return;\n}",
        "lines": 6,
        "depth": 6,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          1320,
          0
        ],
        "end_point": [
          1386,
          1
        ],
        "content": "void\npred_sanity_check (const struct predicate *predicates)\n{\n  const struct predicate *p;\n\n  for (p=predicates; p != NULL; p=p->pred_next)\n    {\n      /* All predicates must do something. */\n      assert (p->pred_func != NULL);\n\n      /* All predicates must have a parser table entry. */\n      assert (p->parser_entry != NULL);\n\n      /* If the parser table tells us that just one predicate function is\n       * possible, verify that that is still the one that is in effect.\n       * If the parser has NULL for the predicate function, that means that\n       * the parse_xxx function fills it in, so we can't check it.\n       */\n      if (p->parser_entry->pred_func)\n\t{\n\t  assert (p->parser_entry->pred_func == p->pred_func);\n\t}\n\n      switch (p->parser_entry->type)\n\t{\n\t  /* Options all take effect during parsing, so there should\n\t   * be no predicate entries corresponding to them.  Hence we\n\t   * should not see any ARG_OPTION or ARG_POSITIONAL_OPTION\n\t   * items.\n\t   *\n\t   * This is a silly way of coding this test, but it prevents\n\t   * a compiler warning (i.e. otherwise it would think that\n\t   * there would be case statements missing).\n\t   */\n\tcase ARG_OPTION:\n\tcase ARG_POSITIONAL_OPTION:\n\t  assert (p->parser_entry->type != ARG_OPTION);\n\t  assert (p->parser_entry->type != ARG_POSITIONAL_OPTION);\n\t  break;\n\n\tcase ARG_ACTION:\n\t  assert (p->side_effects); /* actions have side effects. */\n\t  if (!pred_is (p, pred_prune) && !pred_is(p, pred_quit))\n\t    {\n\t      /* actions other than -prune and -quit should\n\t       * inhibit the default -print\n\t       */\n\t      assert (p->no_default_print);\n\t    }\n\t  break;\n\n\t/* We happen to know that the only user of ARG_SPECIAL_PARSE\n\t * is a test, so handle it like ARG_TEST.\n\t */\n\tcase ARG_SPECIAL_PARSE:\n\tcase ARG_TEST:\n\tcase ARG_PUNCTUATION:\n\tcase ARG_NOOP:\n\t  /* Punctuation and tests should have no side\n\t   * effects and not inhibit default print.\n\t   */\n\t  assert (!p->no_default_print);\n\t  assert (!p->side_effects);\n\t  break;\n\t}\n    }\n}",
        "lines": 67,
        "depth": 14,
        "decorators": [
          "void"
        ]
      }
    ]
  },
  "findutils/findutils-4.6.0/find/print.c": {
    "make_segment": {
      "start_point": [
        76,
        0
      ],
      "end_point": [
        216,
        1
      ],
      "content": "struct segment **\nmake_segment (struct segment **segment,\n              char *format,\n              int len,\n              int kind,\n              char format_char,\n              char aux_format_char,\n              struct predicate *pred)\n{\n  enum EvaluationCost mycost = NeedsNothing;\n  char *fmt;\n\n  assert (format_char != '{');\n  assert (format_char != '[');\n  assert (format_char != '(');\n\n  *segment = xmalloc (sizeof (struct segment));\n\n  (*segment)->segkind = kind;\n  (*segment)->format_char[0] = format_char;\n  (*segment)->format_char[1] = aux_format_char;\n  (*segment)->next = NULL;\n  (*segment)->text_len = len;\n\n  fmt = (*segment)->text = xmalloc (len + sizeof \"d\");\n  strncpy (fmt, format, len);\n  fmt += len;\n\n  if (kind == KIND_PLAIN     /* Plain text string, no % conversion. */\n      || kind == KIND_STOP)  /* Terminate argument, no newline. */\n    {\n      assert (0 == format_char);\n      assert (0 == aux_format_char);\n      *fmt = '\\0';\n      if (mycost > pred->p_cost)\n        pred->p_cost = NeedsNothing;\n      return &(*segment)->next;\n    }\n\n  assert (kind == KIND_FORMAT);\n  switch (format_char)\n    {\n    case '%':                   /* literal % */\n      *fmt++ = '%';\n      break;\n\n    case 'l':                   /* object of symlink */\n      pred->need_stat = true;\n      mycost = NeedsLinkName;\n      *fmt++ = 's';\n      break;\n\n    case 'y':                   /* file type */\n      pred->need_type = true;\n      mycost = NeedsType;\n      *fmt++ = 's';\n      break;\n\n    case 'i':                   /* inode number */\n      pred->need_inum = true;\n      mycost = NeedsInodeNumber;\n      *fmt++ = 's';\n      break;\n\n    case 'a':                   /* atime in `ctime' format */\n    case 'A':                   /* atime in user-specified strftime format */\n    case 'B':                   /* birth time in user-specified strftime format */\n    case 'c':                   /* ctime in `ctime' format */\n    case 'C':                   /* ctime in user-specified strftime format */\n    case 'F':                   /* file system type */\n    case 'g':                   /* group name */\n    case 'M':                   /* mode in `ls -l' format (eg., \"drwxr-xr-x\") */\n    case 's':                   /* size in bytes */\n    case 't':                   /* mtime in `ctime' format */\n    case 'T':                   /* mtime in user-specified strftime format */\n    case 'u':                   /* user name */\n      pred->need_stat = true;\n      mycost = NeedsStatInfo;\n      *fmt++ = 's';\n      break;\n\n    case 'S':                   /* sparseness */\n      pred->need_stat = true;\n      mycost = NeedsStatInfo;\n      *fmt++ = 'g';\n      break;\n\n    case 'Y':                   /* symlink pointed file type */\n      pred->need_stat = true;\n      mycost = NeedsType;       /* true for amortised effect */\n      *fmt++ = 's';\n      break;\n\n    case 'f':                   /* basename of path */\n    case 'h':                   /* leading directories part of path */\n    case 'p':                   /* pathname */\n    case 'P':                   /* pathname with ARGV element stripped */\n      *fmt++ = 's';\n      break;\n\n    case 'Z':                   /* SELinux security context */\n      mycost = NeedsAccessInfo;\n      *fmt++ = 's';\n      break;\n\n    case 'H':                   /* ARGV element file was found under */\n      *fmt++ = 's';\n      break;\n\n      /* Numeric items that one might expect to honour\n       * #, 0, + flags but which do not.\n       */\n    case 'G':                   /* GID number */\n    case 'U':                   /* UID number */\n    case 'b':                   /* size in 512-byte blocks (NOT birthtime in ctime fmt)*/\n    case 'D':                   /* Filesystem device on which the file exits */\n    case 'k':                   /* size in 1K blocks */\n    case 'n':                   /* number of links */\n      pred->need_stat = true;\n      mycost = NeedsStatInfo;\n      *fmt++ = 's';\n      break;\n\n      /* Numeric items that DO honour #, 0, + flags.\n       */\n    case 'd':                   /* depth in search tree (0 = ARGV element) */\n      *fmt++ = 'd';\n      break;\n\n    case 'm':                   /* mode as octal number (perms only) */\n      *fmt++ = 'o';\n      pred->need_stat = true;\n      mycost = NeedsStatInfo;\n      break;\n    }\n  *fmt = '\\0';\n\n  if (mycost > pred->p_cost)\n    pred->p_cost = mycost;\n  return &(*segment)->next;\n}",
      "lines": 141,
      "depth": 11,
      "decorators": [
        "struct segment",
        "struct",
        "segment",
        "**\nmake_segment (struct segment **segment,\n              char *format,\n              int len,\n              int kind,\n              char format_char,\n              char aux_format_char,\n              struct predicate *pred)",
        "*",
        "*\nmake_segment (struct segment **segment,\n              char *format,\n              int len,\n              int kind,\n              char format_char,\n              char aux_format_char,\n              struct predicate *pred)",
        "*"
      ]
    },
    "is_octal_char": {
      "start_point": [
        218,
        0
      ],
      "end_point": [
        222,
        1
      ],
      "content": "static bool\nis_octal_char (char ch)\n{\n  return ch >= '0' && ch <= '7';\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "parse_octal_escape": {
      "start_point": [
        224,
        0
      ],
      "end_point": [
        237,
        1
      ],
      "content": "static char\nparse_octal_escape(const char *p, size_t *consumed)\n{\n  register int n, i;\n  size_t pos = 0;\n\n  for (i = n = 0; i < 3 && is_octal_char(p[pos]); i++, pos++)\n    {\n      n = 8 * n + p[pos] - '0';\n    }\n  --pos;\n  *consumed = pos;\n  return n;\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "char"
      ]
    },
    "parse_escape_char": {
      "start_point": [
        239,
        0
      ],
      "end_point": [
        271,
        1
      ],
      "content": "static int\nparse_escape_char(const char ch)\n{\n  char value = 0;\n  switch (ch)\n    {\n    case 'a':\n      value = '\\a';\n      break;\n    case 'b':\n      value = '\\b';\n      break;\n    case 'f':\n      value = '\\f';\n      break;\n    case 'n':\n      value = '\\n';\n      break;\n    case 'r':\n      value = '\\r';\n      break;\n    case 't':\n      value = '\\t';\n      break;\n    case 'v':\n      value = '\\v';\n      break;\n    case '\\\\':\n      value = '\\\\';\n      break;\n    }\n  return value;\n}",
      "lines": 33,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "get_format_flags_length": {
      "start_point": [
        274,
        0
      ],
      "end_point": [
        289,
        1
      ],
      "content": "static size_t\nget_format_flags_length(const char *p)\n{\n  size_t n = 0;\n  /* Scan past flags, width and precision, to verify kind. */\n  for (; p[++n] && strchr (\"-+ #\", p[n]);)\n    {\n      /* Do nothing. */\n    }\n  while (ISDIGIT (p[n]))\n    n++;\n  if (p[n] == '.')\n    for (n++; ISDIGIT (p[n]); n++)\n      /* Do nothing. */ ;\n  return n;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "get_format_specifer_length": {
      "start_point": [
        291,
        0
      ],
      "end_point": [
        306,
        1
      ],
      "content": "static size_t\nget_format_specifer_length(char ch)\n{\n  if (strchr (\"abcdDfFgGhHiklmMnpPsStuUyYZ%\", ch))\n    {\n      return 1;\n    }\n  else if (strchr (\"ABCT\", ch))\n    {\n      return 2;\n    }\n  else\n    {\n      return 0;\n    }\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "insert_fprintf": {
      "start_point": [
        309,
        0
      ],
      "end_point": [
        440,
        1
      ],
      "content": "bool\ninsert_fprintf (struct format_val *vec,\n                const struct parser_table *entry,\n                char *format)\n{\n  char *segstart = format;\n  char *fmt_editpos;       /* Current address in scanning `format'. */\n  struct segment **segmentp;      /* Address of current segment. */\n  struct predicate *our_pred;\n\n  our_pred = insert_primary_withpred (entry, pred_fprintf, format);\n  our_pred->side_effects = our_pred->no_default_print = true;\n  our_pred->args.printf_vec = *vec;\n  our_pred->need_type = false;\n  our_pred->need_stat = false;\n  our_pred->p_cost    = NeedsNothing;\n\n  segmentp = &our_pred->args.printf_vec.segment;\n  *segmentp = NULL;\n\n  for (fmt_editpos = segstart; *fmt_editpos; fmt_editpos++)\n    {\n      if (fmt_editpos[0] == '\\\\' && fmt_editpos[1] == 'c')\n        {\n          make_segment (segmentp, segstart, fmt_editpos - segstart,\n                        KIND_STOP, 0, 0,\n                        our_pred);\n          if (our_pred->need_stat && (our_pred->p_cost < NeedsStatInfo))\n            our_pred->p_cost = NeedsStatInfo;\n          return true;\n        }\n      else if (*fmt_editpos == '\\\\')\n        {\n          size_t readpos = 1;\n          if (!fmt_editpos[readpos])\n            {\n              error (0, 0, _(\"warning: escape `\\\\' followed by nothing at all\"));\n              --readpos;\n              /* (*fmt_editpos) is already '\\\\' and that's a reasonable result. */\n            }\n          else if (is_octal_char(fmt_editpos[readpos]))\n            {\n              size_t consumed = 0;\n              *fmt_editpos = parse_octal_escape(fmt_editpos + readpos, &consumed);\n              readpos += consumed;\n            }\n          else\n            {\n              const char val = parse_escape_char(fmt_editpos[readpos]);\n              if (val)\n                {\n                  fmt_editpos[0] = val;\n                }\n              else\n                {\n                  error (0, 0, _(\"warning: unrecognized escape `\\\\%c'\"),\n                         fmt_editpos[readpos]);\n                  fmt_editpos += readpos;\n                  continue;\n                }\n            }\n          segmentp = make_segment (segmentp,\n                                   segstart, fmt_editpos - segstart + 1,\n                                   KIND_PLAIN, 0, 0,\n                                   our_pred);\n          segstart = fmt_editpos + readpos + 1; /* Move past the escape. */\n          fmt_editpos += readpos;  /* Incremented immediately by `for'. */\n        }\n      else if (fmt_editpos[0] == '%')\n        {\n          size_t len;\n          if (fmt_editpos[1] == 0)\n            {\n              /* Trailing %.  We don't like those. */\n              error (EXIT_FAILURE, 0,\n                     _(\"error: %s at end of format string\"), fmt_editpos);\n            }\n\n          if (fmt_editpos[1] == '%') /* %% produces just %. */\n            len = 1;\n          else\n            len = get_format_flags_length(fmt_editpos);\n          fmt_editpos += len;\n\n          len = get_format_specifer_length (fmt_editpos[0]);\n          if (len && (fmt_editpos[len-1]))\n            {\n              const char fmt2 = (len == 2) ? fmt_editpos[1] : 0;\n              segmentp = make_segment (segmentp, segstart,\n                                       fmt_editpos - segstart,\n                                       KIND_FORMAT, fmt_editpos[0], fmt2,\n                                       our_pred);\n              fmt_editpos += (len - 1);\n            }\n          else\n            {\n              if (strchr (\"{[(\", fmt_editpos[0]))\n                {\n                  error (EXIT_FAILURE, 0,\n                         _(\"error: the format directive `%%%c' is reserved for future use\"),\n                         (int)fmt_editpos[0]);\n                  /*NOTREACHED*/\n                }\n\n              if (len == 2 && !fmt_editpos[1])\n                {\n                  error (0, 0,\n                         _(\"warning: format directive `%%%c' \"\n                           \"should be followed by another character\"),\n                         fmt_editpos[0]);\n                }\n              else\n                {\n                  /* An unrecognized % escape.  Print the char after the %. */\n                  error (0, 0,\n                         _(\"warning: unrecognized format directive `%%%c'\"),\n                         fmt_editpos[0]);\n                }\n              segmentp = make_segment (segmentp,\n                                       segstart, fmt_editpos + 1 - segstart,\n                                       KIND_PLAIN, 0, 0,\n                                       our_pred);\n            }\n          segstart = fmt_editpos + 1;\n        }\n    }\n\n  if (fmt_editpos > segstart)\n    make_segment (segmentp, segstart, fmt_editpos - segstart, KIND_PLAIN, 0, 0,\n                  our_pred);\n  return true;\n}",
      "lines": 132,
      "depth": 20,
      "decorators": [
        "bool"
      ]
    },
    "scan_for_digit_differences": {
      "start_point": [
        442,
        0
      ],
      "end_point": [
        483,
        1
      ],
      "content": "static bool\nscan_for_digit_differences (const char *p, const char *q,\n                            size_t *first, size_t *n)\n{\n  bool seen = false;\n  size_t i;\n\n  for (i=0; p[i] && q[i]; i++)\n    {\n      if (p[i] != q[i])\n        {\n          if (!isdigit ((unsigned char)q[i]) || !isdigit ((unsigned char)q[i]))\n            return false;\n\n          if (!seen)\n            {\n              *first = i;\n              *n = 1;\n              seen = 1;\n            }\n          else\n            {\n              if (i-*first == *n)\n                {\n                  /* Still in the first sequence of differing digits. */\n                  ++*n;\n                }\n              else\n                {\n                  /* More than one differing contiguous character sequence. */\n                  return false;\n                }\n            }\n        }\n    }\n  if (p[i] || q[i])\n    {\n      /* strings are different lengths. */\n      return false;\n    }\n  return true;\n}",
      "lines": 42,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "do_time_format": {
      "start_point": [
        485,
        0
      ],
      "end_point": [
        581,
        1
      ],
      "content": "static char*\ndo_time_format (const char *fmt, const struct tm *p, const char *ns, size_t ns_size)\n{\n  static char *buf = NULL;\n  static size_t buf_size;\n  char *timefmt = NULL;\n  struct tm altered_time;\n\n\n  /* If the format expands to nothing (%p in some locales, for\n   * example), strftime can return 0.  We actually want to distinguish\n   * the error case where the buffer is too short, so we just prepend\n   * an otherwise uninteresting character to prevent the no-output\n   * case.\n   */\n  timefmt = xmalloc (strlen (fmt) + 2u);\n  timefmt[0] = '_';\n  memcpy (timefmt + 1, fmt, strlen (fmt) + 1);\n\n  /* altered_time is a similar time, but in which both\n   * digits of the seconds field are different.\n   */\n  altered_time = *p;\n  if (altered_time.tm_sec >= 11)\n    altered_time.tm_sec -= 11;\n  else\n    altered_time.tm_sec += 11;\n\n  /* If we call strftime() with buf_size=0, the program will coredump\n   * on Solaris, since it unconditionally writes the terminating null\n   * character.\n   */\n  if (buf == NULL)\n    {\n      buf_size = 1u;\n      buf = xmalloc (buf_size);\n    }\n  while (true)\n    {\n      /* I'm not sure that Solaris will return 0 when the buffer is too small.\n       * Therefore we do not check for (buf_used != 0) as the termination\n       * condition.\n       */\n      size_t buf_used = strftime (buf, buf_size, timefmt, p);\n      if (buf_used              /* Conforming POSIX system */\n          && (buf_used < buf_size)) /* Solaris workaround */\n        {\n          char *altbuf;\n          size_t i = 0, n = 0;\n          size_t final_len = (buf_used\n                              + 1u /* for \\0 */\n                              + ns_size);\n          buf = xrealloc (buf, final_len);\n          buf_size = final_len;\n          altbuf = xmalloc (final_len);\n          strftime (altbuf, buf_size, timefmt, &altered_time);\n\n          /* Find the seconds digits; they should be the only changed part.\n           * In theory the result of the two formatting operations could differ in\n           * more than just one sequence of decimal digits (for example %X might\n           * in theory return a spelled-out time like \"thirty seconds past noon\").\n           * When that happens, we just avoid inserting the nanoseconds field.\n           */\n          if (scan_for_digit_differences (buf, altbuf, &i, &n)\n              && (2==n) && !isdigit ((unsigned char)buf[i+n]))\n            {\n              const size_t end_of_seconds = i + n;\n              const size_t suffix_len = buf_used-(end_of_seconds)+1;\n\n              /* Move the tail (including the \\0).  Note that this\n               * is a move of an overlapping memory block, so we\n               * must use memmove instead of memcpy.  Then insert\n               * the nanoseconds (but not its trailing \\0).\n               */\n              assert (end_of_seconds + ns_size + suffix_len == final_len);\n              memmove (buf+end_of_seconds+ns_size,\n                       buf+end_of_seconds,\n                       suffix_len);\n              memcpy (buf+i+n, ns, ns_size);\n            }\n          else\n            {\n              /* No seconds digits.  No need to insert anything. */\n            }\n          /* The first character of buf is the underscore, which we actually\n           * don't want.\n           */\n          free (timefmt);\n          free (altbuf);\n          return buf+1;\n        }\n      else\n        {\n          buf = x2nrealloc (buf, &buf_size, sizeof *buf);\n        }\n    }\n}",
      "lines": 97,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "char",
        "*\ndo_time_format (const char *fmt, const struct tm *p, const char *ns, size_t ns_size)",
        "*"
      ]
    },
    "format_date": {
      "start_point": [
        593,
        0
      ],
      "end_point": [
        731,
        1
      ],
      "content": "static char *\nformat_date (struct timespec ts, int kind)\n{\n  /* In theory, we use an extra 10 characters for 9 digits of\n   * nanoseconds and 1 for the decimal point.  However, the real\n   * world is more complex than that.\n   *\n   * For example, some systems return junk in the tv_nsec part of\n   * st_birthtime.  An example of this is the NetBSD-4.0-RELENG kernel\n   * (at Sat Mar 24 18:46:46 2007) running a NetBSD-3.1-RELEASE\n   * runtime and examining files on an msdos filesytem.  So for that\n   * reason we set NS_BUF_LEN to 32, which is simply \"long enough\" as\n   * opposed to \"exactly the right size\".  Note that the behaviour of\n   * NetBSD appears to be a result of the use of uninitialized data,\n   * as it's not 100% reproducible (more like 25%).\n   */\n  enum {\n    NS_BUF_LEN = 32,\n    DATE_LEN_PERCENT_APLUS=21   /* length of result of %A+ (it's longer than %c)*/\n  };\n  static char buf[128u+10u + MAX(DATE_LEN_PERCENT_APLUS,\n                            MAX (LONGEST_HUMAN_READABLE + 2, NS_BUF_LEN+64+200))];\n  char ns_buf[NS_BUF_LEN]; /* -.9999999990 (- sign can happen!)*/\n  int  charsprinted, need_ns_suffix;\n  struct tm *tm;\n  char fmt[6];\n\n  /* human_readable() assumes we pass a buffer which is at least as\n   * long as LONGEST_HUMAN_READABLE.  We use an assertion here to\n   * ensure that no nasty unsigned overflow happened in our calculation\n   * of the size of buf.  Do the assertion here rather than in the\n   * code for %@ so that we find the problem quickly if it exists.  If\n   * you want to submit a patch to move this into the if statement, go\n   * ahead, I'll apply it.  But include performance timings\n   * demonstrating that the performance difference is actually\n   * measurable.\n   */\n  verify (sizeof (buf) >= LONGEST_HUMAN_READABLE);\n\n  charsprinted = 0;\n  need_ns_suffix = 0;\n\n  /* Format the main part of the time. */\n  if (kind == '+')\n    {\n      strcpy (fmt, \"%F+%T\");\n      need_ns_suffix = 1;\n    }\n  else\n    {\n      fmt[0] = '%';\n      fmt[1] = kind;\n      fmt[2] = '\\0';\n\n      /* %a, %c, and %t are handled in ctime_format() */\n      switch (kind)\n        {\n        case 'S':\n        case 'T':\n        case 'X':\n        case '@':\n          need_ns_suffix = 1;\n          break;\n        default:\n          need_ns_suffix = 0;\n          break;\n        }\n    }\n\n  if (need_ns_suffix)\n    {\n      /* Format the nanoseconds part.  Leave a trailing zero to\n       * discourage people from writing scripts which extract the\n       * fractional part of the timestamp by using column offsets.\n       * The reason for discouraging this is that in the future, the\n       * granularity may not be nanoseconds.\n       */\n      charsprinted = snprintf (ns_buf, NS_BUF_LEN, \".%09ld0\", (long int)ts.tv_nsec);\n      assert (charsprinted < NS_BUF_LEN);\n    }\n  else\n    {\n      charsprinted = 0;\n      ns_buf[0] = 0;\n    }\n\n  if (kind != '@')\n    {\n      tm = localtime (&ts.tv_sec);\n      if (tm)\n        {\n          char *s = do_time_format (fmt, tm, ns_buf, charsprinted);\n          if (s)\n            return s;\n        }\n    }\n\n  /* If we get to here, either the format was %@, or we have fallen back to it\n   * because strftime failed.\n   */\n  if (1)\n    {\n      uintmax_t w = ts.tv_sec;\n      size_t used, len, remaining;\n\n      /* XXX: note that we are negating an unsigned type which is the\n       * widest possible unsigned type.\n       */\n      char *p = human_readable (ts.tv_sec < 0 ? -w : w, buf + 1,\n                                human_ceiling, 1, 1);\n      assert (p > buf);\n      assert (p < (buf + (sizeof buf)));\n      if (ts.tv_sec < 0)\n        *--p = '-'; /* XXX: Ugh, relying on internal details of human_readable(). */\n\n      /* Add the nanoseconds part.  Because we cannot enforce a\n       * particlar implementation of human_readable, we cannot assume\n       * any particular value for (p-buf).  So we need to be careful\n       * that there is enough space remaining in the buffer.\n       */\n      if (need_ns_suffix)\n        {\n          len = strlen (p);\n          used = (p-buf) + len; /* Offset into buf of current end */\n          assert (sizeof buf > used); /* Ensure we can perform subtraction safely. */\n          remaining = sizeof buf - used - 1u; /* allow space for NUL */\n\n          if (strlen (ns_buf) >= remaining)\n            {\n              error (0, 0,\n                     \"charsprinted=%ld but remaining=%lu: ns_buf=%s\",\n                     (long)charsprinted, (unsigned long)remaining, ns_buf);\n            }\n          assert (strlen (ns_buf) < remaining);\n          strcat (p, ns_buf);\n        }\n      return p;\n    }\n}",
      "lines": 139,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nformat_date (struct timespec ts, int kind)",
        "*"
      ]
    },
    "ctime_format": {
      "start_point": [
        744,
        0
      ],
      "end_point": [
        785,
        1
      ],
      "content": "static char *\nctime_format (struct timespec ts)\n{\n  const struct tm * ptm;\n#define TIME_BUF_LEN 1024\n  static char resultbuf[TIME_BUF_LEN];\n  int nout;\n\n  ptm = localtime (&ts.tv_sec);\n  if (ptm)\n    {\n      assert (ptm->tm_wday >=  0);\n      assert (ptm->tm_wday <   7);\n      assert (ptm->tm_mon  >=  0);\n      assert (ptm->tm_mon  <  12);\n      assert (ptm->tm_hour >=  0);\n      assert (ptm->tm_hour <  24);\n      assert (ptm->tm_min  <  60);\n      assert (ptm->tm_sec  <= 61); /* allows 2 leap seconds. */\n\n      /* wkday mon mday hh:mm:ss.nnnnnnnnn yyyy */\n      nout = snprintf (resultbuf, TIME_BUF_LEN,\n                       \"%3s %3s %2d %02d:%02d:%02d.%09ld0 %04d\",\n                       weekdays[ptm->tm_wday],\n                       months[ptm->tm_mon],\n                       ptm->tm_mday,\n                       ptm->tm_hour,\n                       ptm->tm_min,\n                       ptm->tm_sec,\n                       (long int)ts.tv_nsec,\n                       1900 + ptm->tm_year);\n\n      assert (nout < TIME_BUF_LEN);\n      return resultbuf;\n    }\n  else\n    {\n      /* The time cannot be represented as a struct tm.\n         Output it as an integer.  */\n      return format_date (ts, '@');\n    }\n}",
      "lines": 42,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nctime_format (struct timespec ts)",
        "*"
      ]
    },
    "file_sparseness": {
      "start_point": [
        787,
        0
      ],
      "end_point": [
        802,
        1
      ],
      "content": "static double\nfile_sparseness (const struct stat *p)\n{\n  if (0 == p->st_size)\n    {\n      if (0 == ST_NBLOCKS(*p))\n        return 1.0;\n      else\n        return ST_NBLOCKS(*p) < 0 ? -HUGE_VAL : HUGE_VAL;\n    }\n  else\n    {\n      double blklen = ST_NBLOCKSIZE * (double)ST_NBLOCKS(*p);\n      return blklen / p->st_size;\n    }\n}",
      "lines": 16,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "checked_fprintf": {
      "start_point": [
        804,
        0
      ],
      "end_point": [
        814,
        1
      ],
      "content": "static void\nchecked_fprintf (struct format_val *dest, const char *fmt, ...)\n{\n  int rv;\n  va_list ap;\n\n  va_start (ap, fmt);\n  rv = vfprintf (dest->stream, fmt, ap);\n  if (rv < 0)\n    nonfatal_nontarget_file_error (errno, dest->filename);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "checked_print_quoted": {
      "start_point": [
        816,
        0
      ],
      "end_point": [
        824,
        1
      ],
      "content": "static void\nchecked_print_quoted (struct format_val *dest,\n                           const char *format, const char *s)\n{\n  int rv = print_quoted (dest->stream, dest->quote_opts, dest->dest_is_tty,\n                         format, s);\n  if (rv < 0)\n    nonfatal_nontarget_file_error (errno, dest->filename);\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "checked_fwrite": {
      "start_point": [
        827,
        0
      ],
      "end_point": [
        833,
        1
      ],
      "content": "static void\nchecked_fwrite (void *p, size_t siz, size_t nmemb, struct format_val *dest)\n{\n  const size_t items_written = fwrite (p, siz, nmemb, dest->stream);\n  if (items_written < nmemb)\n    nonfatal_nontarget_file_error (errno, dest->filename);\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "checked_fflush": {
      "start_point": [
        835,
        0
      ],
      "end_point": [
        842,
        1
      ],
      "content": "static void\nchecked_fflush (struct format_val *dest)\n{\n  if (0 != fflush (dest->stream))\n    {\n      nonfatal_nontarget_file_error (errno, dest->filename);\n    }\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mode_to_filetype": {
      "start_point": [
        844,
        0
      ],
      "end_point": [
        873,
        1
      ],
      "content": "static const char*\nmode_to_filetype (mode_t m)\n{\n#define HANDLE_TYPE(t,letter) if (m==t) { return letter; }\n#ifdef S_IFREG\n  HANDLE_TYPE(S_IFREG,  \"f\");   /* regular file */\n#endif\n#ifdef S_IFDIR\n  HANDLE_TYPE(S_IFDIR,  \"d\");   /* directory */\n#endif\n#ifdef S_IFLNK\n  HANDLE_TYPE(S_IFLNK,  \"l\");   /* symbolic link */\n#endif\n#ifdef S_IFSOCK\n  HANDLE_TYPE(S_IFSOCK, \"s\");   /* Unix domain socket */\n#endif\n#ifdef S_IFBLK\n  HANDLE_TYPE(S_IFBLK,  \"b\");   /* block device */\n#endif\n#ifdef S_IFCHR\n  HANDLE_TYPE(S_IFCHR,  \"c\");   /* character device */\n#endif\n#ifdef S_IFIFO\n  HANDLE_TYPE(S_IFIFO,  \"p\");   /* FIFO */\n#endif\n#ifdef S_IFDOOR\n  HANDLE_TYPE(S_IFDOOR, \"D\");   /* Door (e.g. on Solaris) */\n#endif\n  return \"U\";                   /* Unknown */\n}",
      "lines": 30,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nmode_to_filetype (mode_t m)",
        "*"
      ]
    },
    "do_fprintf": {
      "start_point": [
        877,
        0
      ],
      "end_point": [
        1258,
        1
      ],
      "content": "static void\ndo_fprintf (struct format_val *dest,\n            struct segment *segment,\n            const char *pathname,\n            const struct stat *stat_buf)\n{\n  char hbuf[LONGEST_HUMAN_READABLE + 1];\n  const char *cp;\n\n  switch (segment->segkind)\n    {\n    case KIND_PLAIN:    /* Plain text string (no % conversion). */\n      /* trusted */\n      checked_fwrite(segment->text, 1, segment->text_len, dest);\n      break;\n\n    case KIND_STOP:             /* Terminate argument and flush output. */\n      /* trusted */\n      checked_fwrite (segment->text, 1, segment->text_len, dest);\n      checked_fflush (dest);\n      break;\n\n    case KIND_FORMAT:\n      switch (segment->format_char[0])\n        {\n        case 'a':               /* atime in `ctime' format. */\n          /* UNTRUSTED, probably unexploitable */\n          checked_fprintf (dest, segment->text, ctime_format (get_stat_atime (stat_buf)));\n          break;\n        case 'b':               /* size in 512-byte blocks */\n          /* UNTRUSTED, probably unexploitable */\n          checked_fprintf (dest, segment->text,\n                           human_readable ((uintmax_t) ST_NBLOCKS (*stat_buf),\n                                           hbuf, human_ceiling,\n                                           ST_NBLOCKSIZE, 512));\n          break;\n        case 'c':               /* ctime in `ctime' format */\n          /* UNTRUSTED, probably unexploitable */\n          checked_fprintf (dest, segment->text, ctime_format (get_stat_ctime (stat_buf)));\n          break;\n        case 'd':               /* depth in search tree */\n          /* UNTRUSTED, probably unexploitable */\n          checked_fprintf (dest, segment->text, state.curdepth);\n          break;\n        case 'D':               /* Device on which file exists (stat.st_dev) */\n          /* trusted */\n          checked_fprintf (dest, segment->text,\n                           human_readable ((uintmax_t) stat_buf->st_dev, hbuf,\n                                           human_ceiling, 1, 1));\n          break;\n        case 'f':               /* base name of path */\n          /* sanitised */\n          {\n            char *base = base_name (pathname);\n            checked_print_quoted (dest, segment->text, base);\n            free (base);\n          }\n          break;\n        case 'F':               /* file system type */\n          /* trusted */\n          checked_print_quoted (dest, segment->text, filesystem_type (stat_buf, pathname));\n          break;\n        case 'g':               /* group name */\n          /* trusted */\n          /* (well, the actual group is selected by the user but\n           * its name was selected by the system administrator)\n           */\n          {\n            struct group *g;\n\n            g = getgrgid (stat_buf->st_gid);\n            if (g)\n              {\n                segment->text[segment->text_len] = 's';\n                checked_fprintf (dest, segment->text, g->gr_name);\n                break;\n              }\n            else\n              {\n                /* Do nothing. */\n                /*FALLTHROUGH*/\n              }\n          }\n          /*FALLTHROUGH*/ /*...sometimes, so 'G' case.*/\n\n        case 'G':               /* GID number */\n          /* UNTRUSTED, probably unexploitable */\n          checked_fprintf (dest, segment->text,\n                           human_readable ((uintmax_t) stat_buf->st_gid, hbuf,\n                                           human_ceiling, 1, 1));\n          break;\n        case 'h':               /* leading directories part of path */\n          /* sanitised */\n          {\n            cp = strrchr (pathname, '/');\n            if (cp == NULL)     /* No leading directories. */\n              {\n                /* If there is no slash in the pathname, we still\n                 * print the string because it contains characters\n                 * other than just '%s'.  The %h expands to \".\".\n                 */\n                checked_print_quoted (dest, segment->text, \".\");\n              }\n            else\n              {\n                char *s = strdup (pathname);\n                s[cp - pathname] = 0;\n                checked_print_quoted (dest, segment->text, s);\n                free (s);\n              }\n          }\n          break;\n\n        case 'H':               /* ARGV element file was found under */\n          /* trusted */\n          {\n            char *s = xmalloc (state.starting_path_length+1);\n            memcpy (s, pathname, state.starting_path_length);\n            s[state.starting_path_length] = 0;\n            checked_fprintf (dest, segment->text, s);\n            free (s);\n          }\n          break;\n\n        case 'i':               /* inode number */\n          /* UNTRUSTED, but not exploitable I think */\n          /* POSIX does not guarantee that ino_t is unsigned or even\n           * integral (except as an XSI extension), but we'll work on\n           * fixing that if we ever get a report of a system where\n           * ino_t is indeed a signed integral type or a non-integral\n           * arithmetic type. */\n          checked_fprintf (dest, segment->text,\n                           human_readable ((uintmax_t) stat_buf->st_ino, hbuf,\n                                           human_ceiling,\n                                           1, 1));\n          break;\n        case 'k':               /* size in 1K blocks */\n          /* UNTRUSTED, but not exploitable I think */\n          checked_fprintf (dest, segment->text,\n                           human_readable ((uintmax_t) ST_NBLOCKS (*stat_buf),\n                                           hbuf, human_ceiling,\n                                           ST_NBLOCKSIZE, 1024));\n          break;\n        case 'l':               /* object of symlink */\n          /* sanitised */\n#ifdef S_ISLNK\n          {\n            char *linkname = 0;\n\n            if (S_ISLNK (stat_buf->st_mode))\n              {\n                linkname = areadlinkat (state.cwd_dir_fd, state.rel_pathname);\n                if (linkname == NULL)\n                  {\n                    nonfatal_target_file_error (errno, pathname);\n                    state.exit_status = 1;\n                  }\n              }\n            if (linkname)\n              {\n                checked_print_quoted (dest, segment->text, linkname);\n              }\n            else\n              {\n                /* We still need to honour the field width etc., so this is\n                 * not a no-op.\n                 */\n                checked_print_quoted (dest, segment->text, \"\");\n              }\n            free (linkname);\n          }\n#endif                          /* S_ISLNK */\n          break;\n\n        case 'M':               /* mode as 10 chars (eg., \"-rwxr-x--x\" */\n          /* UNTRUSTED, probably unexploitable */\n          {\n            char modestring[16] ;\n            filemodestring (stat_buf, modestring);\n            modestring[10] = '\\0';\n            checked_fprintf (dest, segment->text, modestring);\n          }\n          break;\n\n        case 'm':               /* mode as octal number (perms only) */\n          /* UNTRUSTED, probably unexploitable */\n          {\n            /* Output the mode portably using the traditional numbers,\n               even if the host unwisely uses some other numbering\n               scheme.  But help the compiler in the common case where\n               the host uses the traditional numbering scheme.  */\n            mode_t m = stat_buf->st_mode;\n            bool traditional_numbering_scheme =\n              (S_ISUID == 04000 && S_ISGID == 02000 && S_ISVTX == 01000\n               && S_IRUSR == 00400 && S_IWUSR == 00200 && S_IXUSR == 00100\n               && S_IRGRP == 00040 && S_IWGRP == 00020 && S_IXGRP == 00010\n               && S_IROTH == 00004 && S_IWOTH == 00002 && S_IXOTH == 00001);\n            checked_fprintf (dest, segment->text,\n                     (traditional_numbering_scheme\n                      ? m & MODE_ALL\n                      : ((m & S_ISUID ? 04000 : 0)\n                         | (m & S_ISGID ? 02000 : 0)\n                         | (m & S_ISVTX ? 01000 : 0)\n                         | (m & S_IRUSR ? 00400 : 0)\n                         | (m & S_IWUSR ? 00200 : 0)\n                         | (m & S_IXUSR ? 00100 : 0)\n                         | (m & S_IRGRP ? 00040 : 0)\n                         | (m & S_IWGRP ? 00020 : 0)\n                         | (m & S_IXGRP ? 00010 : 0)\n                         | (m & S_IROTH ? 00004 : 0)\n                         | (m & S_IWOTH ? 00002 : 0)\n                         | (m & S_IXOTH ? 00001 : 0))));\n          }\n          break;\n\n        case 'n':               /* number of links */\n          /* UNTRUSTED, probably unexploitable */\n          checked_fprintf (dest, segment->text,\n                   human_readable ((uintmax_t) stat_buf->st_nlink,\n                                   hbuf,\n                                   human_ceiling,\n                                   1, 1));\n          break;\n\n        case 'p':               /* pathname */\n          /* sanitised */\n          checked_print_quoted (dest, segment->text, pathname);\n          break;\n\n        case 'P':               /* pathname with ARGV element stripped */\n          /* sanitised */\n          if (state.curdepth > 0)\n            {\n              cp = pathname + state.starting_path_length;\n              if (*cp == '/')\n                /* Move past the slash between the ARGV element\n                   and the rest of the pathname.  But if the ARGV element\n                   ends in a slash, we didn't add another, so we've\n                   already skipped past it.  */\n                cp++;\n            }\n          else\n            {\n              cp = \"\";\n            }\n          checked_print_quoted (dest, segment->text, cp);\n          break;\n\n        case 's':               /* size in bytes */\n          /* UNTRUSTED, probably unexploitable */\n          checked_fprintf (dest, segment->text,\n                   human_readable ((uintmax_t) stat_buf->st_size,\n                                   hbuf, human_ceiling, 1, 1));\n          break;\n\n        case 'S':               /* sparseness */\n          /* UNTRUSTED, probably unexploitable */\n          checked_fprintf (dest, segment->text, file_sparseness (stat_buf));\n          break;\n\n        case 't':               /* mtime in `ctime' format */\n          /* UNTRUSTED, probably unexploitable */\n          checked_fprintf (dest, segment->text,\n                           ctime_format (get_stat_mtime (stat_buf)));\n          break;\n\n        case 'u':               /* user name */\n          /* trusted */\n          /* (well, the actual user is selected by the user on systems\n           * where chown is not restricted, but the user name was\n           * selected by the system administrator)\n           */\n          {\n            struct passwd *p;\n\n            p = getpwuid (stat_buf->st_uid);\n            if (p)\n              {\n                segment->text[segment->text_len] = 's';\n                checked_fprintf (dest, segment->text, p->pw_name);\n                break;\n              }\n            /* else fallthru */\n          }\n          /* FALLTHROUGH*/ /* .. to case U */\n\n        case 'U':               /* UID number */\n          /* UNTRUSTED, probably unexploitable */\n          checked_fprintf (dest, segment->text,\n                           human_readable ((uintmax_t) stat_buf->st_uid, hbuf,\n                                           human_ceiling, 1, 1));\n          break;\n\n          /* %Y: type of file system entry like `ls -l`:\n           *     (d,-,l,s,p,b,c,n) n=nonexistent (symlink)\n           */\n        case 'Y':               /* in case of symlink */\n          /* trusted */\n          {\n#ifdef S_ISLNK\n            if (S_ISLNK (stat_buf->st_mode))\n              {\n                struct stat sbuf;\n                /* If we would normally follow links, do not do so.\n                 * If we would normally not follow links, do so.\n                 */\n                if ((following_links () ? optionp_stat : optionl_stat)\n                    (state.rel_pathname, &sbuf) != 0)\n                  {\n                    if ( errno == ENOENT )\n                      {\n                        checked_fprintf (dest, segment->text, \"N\");\n                        break;\n                      }\n                    else if ( errno == ELOOP )\n                      {\n                        checked_fprintf (dest, segment->text, \"L\");\n                        break;\n                      }\n                    else\n                      {\n                        checked_fprintf (dest, segment->text, \"?\");\n                        error (0, errno, \"%s\",\n                               safely_quote_err_filename (0, pathname));\n                        /* exit_status = 1;\n                           return ; */\n                        break;\n                      }\n                  }\n                checked_fprintf (dest, segment->text,\n                                 mode_to_filetype (sbuf.st_mode & S_IFMT));\n              }\n#endif /* S_ISLNK */\n            else\n              {\n                checked_fprintf (dest, segment->text,\n                                 mode_to_filetype (stat_buf->st_mode & S_IFMT));\n              }\n          }\n          break;\n\n        case 'y':\n          /* trusted */\n          {\n            checked_fprintf (dest, segment->text,\n                             mode_to_filetype (stat_buf->st_mode & S_IFMT));\n          }\n          break;\n\n        case 'Z':               /* SELinux security context */\n          {\n            security_context_t scontext;\n            int rv = (*options.x_getfilecon) (state.cwd_dir_fd, state.rel_pathname,\n                                              &scontext);\n            if (rv < 0)\n              {\n                /* If getfilecon fails, there will in the general case\n                   still be some text to print.   We just make %Z expand\n                   to an empty string. */\n                checked_fprintf (dest, segment->text, \"\");\n\n                error (0, errno, _(\"getfilecon failed: %s\"),\n                    safely_quote_err_filename (0, pathname));\n                state.exit_status = 1;\n              }\n            else\n              {\n                checked_fprintf (dest, segment->text, scontext);\n                freecon (scontext);\n              }\n          }\n          break;\n\n        case 0:\n        case '%':\n          checked_fprintf (dest, segment->text);\n          break;\n        }\n      /* end of KIND_FORMAT case */\n      break;\n    }\n}",
      "lines": 382,
      "depth": 30,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "pred_fprintf": {
      "start_point": [
        1260,
        0
      ],
      "end_point": [
        1326,
        1
      ],
      "content": "bool\npred_fprintf (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)\n{\n  struct format_val *dest = &pred_ptr->args.printf_vec;\n  struct segment *segment;\n\n  for (segment = dest->segment; segment; segment = segment->next)\n    {\n      if ( (KIND_FORMAT == segment->segkind) && segment->format_char[1]) /* Component of date. */\n        {\n          struct timespec ts;\n          int valid = 0;\n\n          switch (segment->format_char[0])\n            {\n            case 'A':\n              ts = get_stat_atime (stat_buf);\n              valid = 1;\n              break;\n            case 'B':\n              ts = get_stat_birthtime (stat_buf);\n              if ('@' == segment->format_char[1])\n                valid = 1;\n              else\n                valid = (ts.tv_nsec >= 0);\n              break;\n            case 'C':\n              ts = get_stat_ctime (stat_buf);\n              valid = 1;\n              break;\n            case 'T':\n              ts = get_stat_mtime (stat_buf);\n              valid = 1;\n              break;\n            default:\n              assert (0);\n              abort ();\n            }\n          /* We trust the output of format_date not to contain\n           * nasty characters, though the value of the date\n           * is itself untrusted data.\n           */\n          if (valid)\n            {\n              /* trusted */\n              checked_fprintf (dest, segment->text,\n                               format_date (ts, segment->format_char[1]));\n            }\n          else\n            {\n              /* The specified timestamp is not available, output\n               * nothing for the timestamp, but use the rest (so that\n               * for example find foo -printf '[%Bs] %p\\n' can print\n               * \"[] foo\").\n               */\n              /* trusted */\n              checked_fprintf (dest, segment->text, \"\");\n            }\n        }\n      else\n        {\n          /* Print a segment which is not a date. */\n          do_fprintf (dest, segment, pathname, stat_buf);\n        }\n    }\n  return true;\n}",
      "lines": 67,
      "depth": 16,
      "decorators": [
        "bool"
      ]
    }
  },
  "findutils/findutils-4.6.0/find/print.h": {},
  "findutils/findutils-4.6.0/find/sharefile.c": {
    "entry_comparator": {
      "start_point": [
        68,
        0
      ],
      "end_point": [
        73,
        1
      ],
      "content": "static bool\nentry_comparator (const void *av, const void *bv)\n{\n  const struct SharefileEntry *a=av, *b=bv;\n  return (a->inode == b->inode) && (a->device == b->device);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "entry_free": {
      "start_point": [
        75,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "static void\nentry_free (void *pv)\n{\n  struct SharefileEntry *p = pv;\n  if (p->fp)\n    {\n      if (0 != fclose (p->fp))\n\tfatal_nontarget_file_error (errno, p->name);\n    }\n  free (p->name);\n  free (p);\n}",
      "lines": 12,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "entry_hashfunc": {
      "start_point": [
        88,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "static size_t\nentry_hashfunc (const void *pv, size_t buckets)\n{\n  const struct SharefileEntry *p = pv;\n  return (p->device ^ p->inode) % buckets;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "sharefile_init": {
      "start_point": [
        97,
        0
      ],
      "end_point": [
        128,
        1
      ],
      "content": "sharefile_handle\nsharefile_init (const char *mode)\n{\n  struct Hash_tuning;\n\n  struct sharefile *p = malloc (sizeof (struct sharefile));\n  if (p)\n    {\n      p->mode = strdup (mode);\n      if (p->mode)\n\t{\n\t  p->table = hash_initialize (DefaultHashTableSize, NULL,\n\t\t\t\t      entry_hashfunc,\n\t\t\t\t      entry_comparator,\n\t\t\t\t      entry_free);\n\t  if (p->table)\n\t    {\n\t      return p;\n\t    }\n\t  else\n\t    {\n\t      free (p->mode);\n\t      free (p);\n\t    }\n\t}\n      else\n\t{\n\t  free (p);\n\t}\n    }\n  return NULL;\n}",
      "lines": 32,
      "depth": 13,
      "decorators": [
        "sharefile_handle"
      ]
    },
    "sharefile_destroy": {
      "start_point": [
        130,
        0
      ],
      "end_point": [
        136,
        1
      ],
      "content": "void\nsharefile_destroy (sharefile_handle pv)\n{\n  struct sharefile *p = pv;\n  free (p->mode);\n  hash_free (p->table);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "sharefile_fopen": {
      "start_point": [
        139,
        0
      ],
      "end_point": [
        202,
        1
      ],
      "content": "FILE *\nsharefile_fopen (sharefile_handle h, const char *filename)\n{\n  struct sharefile *p = h;\n  struct SharefileEntry *new_entry;\n\n  new_entry = malloc (sizeof (struct SharefileEntry));\n  if (!new_entry)\n    return NULL;\n\n  new_entry->name = strdup (filename);\n  if (NULL == new_entry->name)\n    {\n      free (new_entry);\n      return NULL;\n    }\n\n  if (NULL == (new_entry->fp = fopen_safer (filename, p->mode)))\n    {\n      free (new_entry);\n      return NULL;\n    }\n  else\n    {\n      struct stat st;\n      const int fd = fileno (new_entry->fp);\n      assert (fd >= 0);\n\n      set_cloexec_flag (fd, true);\n      if (fstat (fd, &st) < 0)\n        {\n\t  entry_free (new_entry);\n          return NULL;\n        }\n      else\n        {\n\t  void *existing;\n\n          new_entry->device = st.st_dev;\n          new_entry->inode = st.st_ino;\n\n          existing = hash_lookup (p->table, new_entry);\n          if (existing)\t    /* We have previously opened that file. */\n\t    {\n\t      entry_free (new_entry); /* don't need new_entry. */\n\t      return ((const struct SharefileEntry*)existing)->fp;\n\t    }\n          else /* We didn't open it already */\n\t    {\n\t      if (hash_insert (p->table, new_entry))\n\t\t{\n\t\t  return new_entry->fp;\n\t\t}\n\t      else\t\t\t/* failed to insert in hashtable. */\n\t\t{\n\t\t  const int save_errno = errno;\n\t\t  entry_free (new_entry);\n\t\t  errno = save_errno;\n\t\t  return NULL;\n\t\t}\n\t    }\n        }\n    }\n}",
      "lines": 64,
      "depth": 15,
      "decorators": [
        "FILE",
        "*\nsharefile_fopen (sharefile_handle h, const char *filename)",
        "*"
      ]
    }
  },
  "findutils/findutils-4.6.0/find/sharefile.h": {},
  "findutils/findutils-4.6.0/find/tree.c": {
    "matches_start_point": {
      "start_point": [
        76,
        0
      ],
      "end_point": [
        97,
        1
      ],
      "content": "bool\nmatches_start_point (const char *glob, bool foldcase)\n{\n  int fnmatch_flags = 0;\n  if (foldcase)\n    fnmatch_flags |= FNM_CASEFOLD;\n\n  if (num_start_points)\n    {\n      size_t i;\n      for (i=0; i<num_start_points; i++)\n\t{\n\t  if (fnmatch (glob, start_points[i], fnmatch_flags) == 0)\n\t    return true;\n\t}\n      return false;\n    }\n  else\n    {\n      return fnmatch (glob, \".\", fnmatch_flags) == 0;\n    }\n}",
      "lines": 22,
      "depth": 13,
      "decorators": [
        "bool"
      ]
    },
    "get_expr": {
      "start_point": [
        119,
        0
      ],
      "end_point": [
        226,
        1
      ],
      "content": "static struct predicate *\nget_expr (struct predicate **input,\n\t  short int prev_prec,\n\t  const struct predicate* prev_pred)\n{\n  struct predicate *next = NULL;\n  struct predicate *this_pred = (*input);\n\n  if (*input == NULL)\n    error (EXIT_FAILURE, 0, _(\"invalid expression\"));\n\n  switch ((*input)->p_type)\n    {\n    case NO_TYPE:\n      error (EXIT_FAILURE, 0, _(\"invalid expression\"));\n      break;\n\n    case BI_OP:\n      /* e.g. \"find . -a\" */\n      error (EXIT_FAILURE, 0,\n\t     _(\"invalid expression; you have used a binary operator '%s' with nothing before it.\"),\n\t     this_pred->p_name);\n      break;\n\n    case CLOSE_PAREN:\n      if ((UNI_OP == prev_pred->p_type\n\t  || BI_OP == prev_pred->p_type)\n\t  && !this_pred->artificial)\n\t{\n\t  /* e.g. \"find \\( -not \\)\" or \"find \\( -true -a \\\" */\n\t  error (EXIT_FAILURE, 0,\n\t\t _(\"expected an expression between '%s' and ')'\"),\n\t\t prev_pred->p_name);\n\t}\n      else if ( (*input)->artificial )\n\t{\n\t  /* We have reached the end of the user-supplied predicates\n\t   * unexpectedly.\n\t   */\n\t  /* e.g. \"find . -true -a\" */\n\t  error (EXIT_FAILURE, 0,\n\t\t _(\"expected an expression after '%s'\"), prev_pred->p_name);\n\t}\n      else\n\t{\n\t  error (EXIT_FAILURE, 0,\n\t\t _(\"invalid expression; you have too many ')'\"));\n\t}\n      break;\n\n    case PRIMARY_TYPE:\n      next = *input;\n      *input = (*input)->pred_next;\n      break;\n\n    case UNI_OP:\n      next = *input;\n      *input = (*input)->pred_next;\n      next->pred_right = get_expr (input, NEGATE_PREC, next);\n      break;\n\n    case OPEN_PAREN:\n      if ( (NULL == (*input)->pred_next) || (*input)->pred_next->artificial )\n\t{\n\t  /* user typed something like \"find . (\", and so the ) we are\n\t   * looking at is from the artificial \"( ) -print\" that we\n\t   * add.\n\t   */\n\t  error (EXIT_FAILURE, 0,\n\t\t _(\"invalid expression; expected to find a ')' but didn't see one.  Perhaps you need an extra predicate after '%s'\"),\n\t\t this_pred->p_name);\n\t}\n      prev_pred = (*input);\n      *input = (*input)->pred_next;\n      if ( (*input)->p_type == CLOSE_PAREN )\n\t{\n\t  error (EXIT_FAILURE, 0,\n\t\t _(\"invalid expression; empty parentheses are not allowed.\"));\n\t}\n      next = get_expr (input, NO_PREC, prev_pred);\n      if ((*input == NULL)\n\t  || ((*input)->p_type != CLOSE_PAREN))\n\terror (EXIT_FAILURE, 0,\n\t       _(\"invalid expression; I was expecting to find a ')' somewhere but did not see one.\"));\n\n      *input = (*input)->pred_next;\t/* move over close */\n      break;\n\n    default:\n      error (EXIT_FAILURE, 0, _(\"oops -- invalid expression type!\"));\n      break;\n    }\n\n  /* We now have the first expression and are positioned to check\n     out the next operator.  If NULL, all done.  Otherwise, if\n     PREV_PREC < the current node precedence, we must continue;\n     the expression we just nabbed is more tightly bound to the\n     following expression than to the previous one. */\n  if (*input == NULL)\n    return (next);\n  if ((int) (*input)->p_prec > (int) prev_prec)\n    {\n      next = scan_rest (input, next, prev_prec);\n      if (next == NULL)\n\terror (EXIT_FAILURE, 0, _(\"invalid expression\"));\n    }\n  return (next);\n}",
      "lines": 108,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "struct predicate",
        "struct",
        "predicate",
        "*\nget_expr (struct predicate **input,\n\t  short int prev_prec,\n\t  const struct predicate* prev_pred)",
        "*"
      ]
    },
    "scan_rest": {
      "start_point": [
        241,
        0
      ],
      "end_point": [
        286,
        1
      ],
      "content": "static struct predicate *\nscan_rest (struct predicate **input,\n\t   struct predicate *head,\n\t   short int prev_prec)\n{\n  struct predicate *tree;\t/* The new tree we are building. */\n\n  if ((*input == NULL) || ((*input)->p_type == CLOSE_PAREN))\n    return (NULL);\n  tree = head;\n  while ((*input != NULL) && ((int) (*input)->p_prec > (int) prev_prec))\n    {\n      switch ((*input)->p_type)\n\t{\n\tcase NO_TYPE:\n\tcase PRIMARY_TYPE:\n\tcase UNI_OP:\n\tcase OPEN_PAREN:\n\t  /* I'm not sure how we get here, so it is not obvious what\n\t   * sort of mistakes might give rise to this condition.\n\t   */\n\t  error (EXIT_FAILURE, 0, _(\"invalid expression\"));\n\t  break;\n\n\tcase BI_OP:\n\t  {\n\t    struct predicate *prev = (*input);\n\t    (*input)->pred_left = tree;\n\t    tree = *input;\n\t    *input = (*input)->pred_next;\n\t    tree->pred_right = get_expr (input, tree->p_prec, prev);\n\t    break;\n\t  }\n\n\tcase CLOSE_PAREN:\n\t  return tree;\n\n\tdefault:\n\t  error (EXIT_FAILURE, 0,\n\t\t _(\"oops -- invalid expression type (%d)!\"),\n\t\t (int)(*input)->p_type);\n\t  break;\n\t}\n    }\n  return tree;\n}",
      "lines": 46,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "struct predicate",
        "struct",
        "predicate",
        "*\nscan_rest (struct predicate **input,\n\t   struct predicate *head,\n\t   short int prev_prec)",
        "*"
      ]
    },
    "predicate_is_cost_free": {
      "start_point": [
        289,
        0
      ],
      "end_point": [
        316,
        1
      ],
      "content": "static bool\npredicate_is_cost_free (const struct predicate *p)\n{\n  if (pred_is(p, pred_name) ||\n      pred_is(p, pred_path) ||\n      pred_is(p, pred_iname) ||\n      pred_is(p, pred_ipath))\n    {\n      /* Traditionally (at least 4.1.7 through 4.2.x) GNU find always\n       * optimised these cases.\n       */\n      return true;\n    }\n  else if (options.optimisation_level > 0)\n    {\n      if (pred_is(p, pred_and) ||\n\t  pred_is(p, pred_negate) ||\n\t  pred_is(p, pred_comma) ||\n\t  pred_is(p, pred_or))\n\treturn false;\n      else\n\treturn NeedsNothing == p->p_cost;\n    }\n  else\n    {\n      return false;\n    }\n}",
      "lines": 28,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "print_predicate": {
      "start_point": [
        319,
        0
      ],
      "end_point": [
        329,
        1
      ],
      "content": "void print_predicate (FILE *fp, const struct predicate *p)\n{\n  if (p->arg_text)\n    {\n      fprintf (fp, \"%s %s\", p->p_name, p->arg_text);\n    }\n  else\n    {\n      fprintf (fp, \"%s\", p->p_name);\n    }\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "predlist_init": {
      "start_point": [
        338,
        0
      ],
      "end_point": [
        342,
        1
      ],
      "content": "static void\npredlist_init (struct predlist *p)\n{\n  p->head = p->tail = NULL;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "predlist_insert": {
      "start_point": [
        344,
        0
      ],
      "end_point": [
        356,
        1
      ],
      "content": "static void\npredlist_insert (struct predlist *list,\n\t\t struct predicate *curr,\n\t\t struct predicate **pprev)\n{\n  struct predicate **insertpos = &(list->head);\n\n  *pprev = curr->pred_left;\n  curr->pred_left = (*insertpos);\n  (*insertpos) = curr;\n  if (NULL == list->tail)\n    list->tail = list->head;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "pred_cost_compare": {
      "start_point": [
        358,
        0
      ],
      "end_point": [
        374,
        1
      ],
      "content": "static int\npred_cost_compare (const struct predicate *p1, const struct predicate *p2, bool wantfailure)\n{\n  if (p1->p_cost == p2->p_cost)\n    {\n      if (p1->est_success_rate == p2->est_success_rate)\n\treturn 0;\n      else if (wantfailure)\n\treturn p1->est_success_rate < p2->est_success_rate ? -1 :  1;\n      else\n\treturn p1->est_success_rate < p2->est_success_rate ?  1 : -1;\n    }\n  else\n    {\n      return p1->p_cost < p2->p_cost ? -1 : 1;\n    }\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "predlist_merge_sort": {
      "start_point": [
        377,
        0
      ],
      "end_point": [
        443,
        1
      ],
      "content": "static void\npredlist_merge_sort (struct predlist *list,\n\t\t     struct predicate **last)\n{\n  struct predlist new_list;\n  struct predicate *p, *q;\n\n  if (NULL == list->head)\n    return;\t\t\t/* nothing to do */\n\n  if (options.debug_options & DebugTreeOpt)\n    {\n      fprintf (stderr, \"%s:\\n\", \"predlist before merge sort\");\n      print_tree (stderr, list->head, 2);\n    }\n\n  calculate_derived_rates (list->head);\n  predlist_init (&new_list);\n  while (list->head)\n    {\n      /* remove head of source list */\n      q = list->head;\n      list->head = list->head->pred_left;\n      q->pred_left = NULL;\n\n      /* insert it into the new list */\n      for (p=new_list.head; p; p=p->pred_left)\n\t{\n\t  /* If these operations are OR operations, we want to get a\n\t   * successful test as soon as possible, to take advantage of\n\t   * the short-circuit evaluation.  If they're AND, we want to\n\t   * get an unsuccessful result early for the same reason.\n\t   * Therefore we invert the sense of the comparison for the\n\t   * OR case.  We only want to invert the sense of the success\n\t   * rate comparison, not the operation cost comparison.  Hence we\n\t   * pass a flag into pred_cost_compare().\n\t   */\n\t  const bool wantfailure = (OR_PREC != p->p_prec);\n\t  if (pred_cost_compare (p->pred_right, q->pred_right, wantfailure) >= 0)\n\t    break;\n\t}\n      if (p)\n\t{\n\t  /* insert into existing list */\n\t  q->pred_left = p->pred_left;\n\t  if (NULL == q->pred_left)\n\t    new_list.tail = q;\n\t  p->pred_left = q;\n\t}\n      else\n\t{\n\t  q->pred_left = new_list.head;\t/* prepend */\n\t  new_list.head = q;\n\t  if (NULL == new_list.tail)\n\t    new_list.tail = q; /* first item in new list */\n\t}\n    }\n  if (options.debug_options & DebugTreeOpt)\n    {\n      fprintf (stderr, \"%s:\\n\", \"predlist after merge sort\");\n      print_tree (stderr, new_list.head, 2);\n    }\n\n  calculate_derived_rates(new_list.head);\n  merge_pred (new_list.head, new_list.tail, last);\n  predlist_init (list);\n}",
      "lines": 67,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "merge_lists": {
      "start_point": [
        445,
        0
      ],
      "end_point": [
        461,
        1
      ],
      "content": "static void\nmerge_lists (struct predlist lists[], int nlists,\n\t     struct predlist *name_list,\n\t     struct predlist *regex_list,\n\t     struct predicate **last)\n{\n  int i;\n  static void (*mergefn)(struct predlist *, struct predicate**);\n\n  mergefn = predlist_merge_sort;\n\n  mergefn (name_list,   last);\n  mergefn (regex_list,  last);\n\n  for (i=0; i<nlists; i++)\n    mergefn (&lists[i], last);\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "subtree_has_side_effects": {
      "start_point": [
        465,
        0
      ],
      "end_point": [
        479,
        1
      ],
      "content": "static bool\nsubtree_has_side_effects (const struct predicate *p)\n{\n  if (p)\n    {\n      return p->side_effects\n\t|| subtree_has_side_effects (p->pred_left)\n\t|| subtree_has_side_effects (p->pred_right);\n    }\n  else\n    {\n\n      return false;\n    }\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "worst_cost": {
      "start_point": [
        481,
        0
      ],
      "end_point": [
        498,
        1
      ],
      "content": "static int\nworst_cost (const struct predicate *p)\n{\n  if (p)\n    {\n      unsigned int cost_r, cost_l, worst;\n      cost_l = worst_cost (p->pred_left);\n      cost_r = worst_cost (p->pred_right);\n      worst = (cost_l > cost_r) ? cost_l : cost_r;\n      if (worst < p->p_cost)\n\tworst = p->p_cost;\n      return worst;\n    }\n  else\n    {\n      return 0;\n    }\n}",
      "lines": 18,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "perform_arm_swap": {
      "start_point": [
        502,
        0
      ],
      "end_point": [
        508,
        1
      ],
      "content": "static void\nperform_arm_swap (struct predicate *p)\n{\n  struct predicate *tmp = p->pred_left->pred_right;\n  p->pred_left->pred_right = p->pred_right;\n  p->pred_right = tmp;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "consider_arm_swap": {
      "start_point": [
        526,
        0
      ],
      "end_point": [
        629,
        1
      ],
      "content": "static bool\nconsider_arm_swap (struct predicate *p)\n{\n  int left_cost, right_cost;\n  const char *reason = NULL;\n  struct predicate **pl, **pr;\n\n  if (BI_OP != p->p_type)\n    reason = \"Not a binary operation\";\n\n  if (!reason)\n    {\n      if (NULL == p->pred_left || NULL == p->pred_right)\n\treason = \"Doesn't have two arms\";\n    }\n\n\n  if (!reason)\n    {\n      if (NULL == p->pred_left->pred_right)\n\treason = \"Left arm has no child on RHS\";\n    }\n  pr = &p->pred_right;\n  pl = &p->pred_left->pred_right;\n\n  if (!reason)\n    {\n      if (subtree_has_side_effects (*pl))\n\treason = \"Left subtree has side-effects\";\n    }\n  if (!reason)\n    {\n      if (subtree_has_side_effects (*pr))\n\treason = \"Right subtree has side-effects\";\n    }\n\n  if (!reason)\n    {\n      left_cost = worst_cost (*pl);\n      right_cost = worst_cost (*pr);\n\n      if (left_cost < right_cost)\n\t{\n\t  reason = \"efficient as-is\";\n\t}\n    }\n  if (!reason)\n    {\n      bool want_swap;\n\n      if (left_cost == right_cost)\n\t{\n\t  /* it's a candidate */\n\t  float succ_rate_l = (*pl)->est_success_rate;\n\t  float succ_rate_r = (*pr)->est_success_rate;\n\n\t  if (options.debug_options & DebugTreeOpt)\n\t    {\n\t      fprintf (stderr, \"Success rates: l=%f, r=%f\\n\", succ_rate_l, succ_rate_r);\n\t    }\n\n\t  if (pred_is (p, pred_or))\n\t    {\n\t      want_swap = succ_rate_r < succ_rate_l;\n\t      if (!want_swap)\n\t\treason = \"Operation is OR; right success rate >= left\";\n\t    }\n\t  else if (pred_is (p, pred_and))\n\t    {\n\t      want_swap = succ_rate_r > succ_rate_l;\n\t      if (!want_swap)\n\t\treason = \"Operation is AND; right success rate <= left\";\n\t    }\n\t  else\n\t    {\n\t      want_swap = false;\n\t      reason = \"Not 'AND' or 'OR'\";\n\t    }\n\t}\n      else\n\t{\n\t  want_swap = true;\n\t}\n\n      if (want_swap)\n\t{\n\t  if (options.debug_options & DebugTreeOpt)\n\t    {\n\t      fprintf (stderr, \"Performing arm swap on:\\n\");\n\t      print_tree (stderr, p, 0);\n\t    }\n\t  perform_arm_swap (p);\n\t  return true;\n\t}\n    }\n\n\n  if (options.debug_options & DebugTreeOpt)\n    {\n      fprintf (stderr, \"Not an arm swap candidate (%s):\\n\", reason);\n      print_tree (stderr, p, 0);\n    }\n  return false;\n}",
      "lines": 104,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "do_arm_swaps": {
      "start_point": [
        631,
        0
      ],
      "end_point": [
        653,
        1
      ],
      "content": "static bool\ndo_arm_swaps (struct predicate *p)\n{\n  if (p)\n    {\n      bool swapped;\n      do\n\t{\n\t  swapped = false;\n\t  if (consider_arm_swap (p)\n\t      || do_arm_swaps (p->pred_left)\n\t      || do_arm_swaps (p->pred_right))\n\t    {\n\t      swapped = true;\n\t    }\n\t} while (swapped);\n      return swapped;\n    }\n  else\n    {\n      return false;\n    }\n}",
      "lines": 23,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "opt_expr": {
      "start_point": [
        688,
        0
      ],
      "end_point": [
        852,
        1
      ],
      "content": "static bool\nopt_expr (struct predicate **eval_treep)\n{\n  struct predlist regex_list={NULL,NULL}, name_list={NULL,NULL};\n  struct predlist cbo_list[NumEvaluationCosts];\n  int i;\n  struct predicate *curr;\n  struct predicate **prevp;\t/* Address of `curr' node. */\n  struct predicate **last_sidep; /* Last predicate with side effects. */\n  PRED_FUNC pred_func;\n  enum predicate_type p_type;\n  bool has_side_effects = false; /* Return value. */\n  enum predicate_precedence prev_prec, /* precedence of last BI_OP in branch */\n\t\t\t    biop_prec; /* topmost BI_OP precedence in branch */\n\n  if (eval_treep == NULL || *eval_treep == NULL)\n    return (false);\n\n  for (i=0; i<NumEvaluationCosts; i++)\n    predlist_init (&cbo_list[i]);\n\n  /* Set up to normalize tree as a left-linked list of ANDs or ORs.\n     Set `curr' to the leftmost node, `prevp' to its address, and\n     `pred_func' to the predicate type of its parent. */\n  prevp = eval_treep;\n  prev_prec = AND_PREC;\n  curr = *prevp;\n  while (curr->pred_left != NULL)\n    {\n      prevp = &curr->pred_left;\n      prev_prec = curr->p_prec;\t/* must be a BI_OP */\n      curr = curr->pred_left;\n    }\n\n  /* Link in the appropriate BI_OP for the last expression, if needed. */\n  if (curr->p_type != BI_OP)\n    set_new_parent (curr, prev_prec, prevp);\n\n  if (options.debug_options & (DebugExpressionTree|DebugTreeOpt))\n    {\n      /* Normalized tree. */\n      fprintf (stderr, \"Normalized Eval Tree:\\n\");\n      print_tree (stderr, *eval_treep, 0);\n    }\n\n  /* Rearrange the predicates. */\n  prevp = eval_treep;\n  biop_prec = NO_PREC; /* not COMMA_PREC */\n  if ((*prevp) && (*prevp)->p_type == BI_OP)\n    biop_prec = (*prevp)->p_prec;\n  while ((curr = *prevp) != NULL)\n    {\n      /* If there is a BI_OP of different precedence from the first\n\t in the pred_left chain, create a new parent of the\n\t original precedence, link the new parent to the left of the\n\t previous and link CURR to the right of the new parent.\n\t This preserves the precedence of expressions in the tree\n\t in case we rearrange them. */\n      if (curr->p_type == BI_OP)\n\t{\n          if (curr->p_prec != biop_prec)\n\t    curr = set_new_parent (curr, biop_prec, prevp);\n\t}\n\n      /* See which predicate type we have. */\n      p_type = curr->pred_right->p_type;\n      pred_func = curr->pred_right->pred_func;\n\n\n      switch (p_type)\n\t{\n\tcase NO_TYPE:\n\tcase PRIMARY_TYPE:\n\t  /* Don't rearrange the arguments of the comma operator, it is\n\t     not commutative.  */\n\t  if (biop_prec == COMMA_PREC)\n\t    break;\n\n\t  /* If this predicate has no side effects, consider reordering it. */\n\t  if (!curr->pred_right->side_effects)\n\t    {\n\t      bool reorder;\n\n\t      /* If it's one of our special primaries, move it to the\n\t\t front of the list for that primary. */\n\t      if (predicate_is_cost_free (curr->pred_right))\n\t\t{\n\t\t  if (options.debug_options & DebugTreeOpt)\n\t\t    {\n\t\t      fprintf (stderr, \"-O%d: promoting cheap predicate \",\n\t\t\t       (int)options.optimisation_level);\n\t\t      print_predicate (stderr, curr->pred_right);\n\t\t      fprintf (stderr, \" into name_list\\n\");\n\t\t    }\n\t\t  predlist_insert (&name_list, curr, prevp);\n\t\t  continue;\n\t\t}\n\n\t      if (pred_func == pred_regex)\n\t\t{\n\t\t  predlist_insert (&regex_list, curr, prevp);\n\t\t  continue;\n\t\t}\n\n\t      reorder = ((options.optimisation_level > 1)\n\t\t\t && (NeedsType == curr->pred_right->p_cost\n\t\t\t     || NeedsInodeNumber == curr->pred_right->p_cost)\n\t\t\t && !curr->pred_right->need_stat) ||\n\t\t(options.optimisation_level > 2);\n\n\t      if (reorder)\n\t\t{\n\t\t  if (options.debug_options & DebugTreeOpt)\n\t\t    {\n\t\t      fprintf (stderr, \"-O%d: categorising predicate \",\n\t\t\t       (int)options.optimisation_level);\n\t\t      print_predicate (stderr, curr->pred_right);\n\t\t      fprintf (stderr, \" by cost (%s)\\n\",\n\t\t\t       cost_name(curr->pred_right->p_cost));\n\t\t    }\n\t\t  predlist_insert (&cbo_list[curr->pred_right->p_cost], curr, prevp);\n\t\t  continue;\n\t\t}\n\t    }\n\n\t  break;\n\n\tcase UNI_OP:\n\t  /* For NOT, check the expression trees below the NOT. */\n\t  curr->pred_right->side_effects\n\t    = opt_expr (&curr->pred_right->pred_right);\n\t  break;\n\n\tcase BI_OP:\n\t  /* For nested 'AND' or 'OR', recurse (AND/OR form layers on\n\t     the left of the tree), and continue scanning this level\n\t     of 'AND' or 'OR'. */\n\t  curr->pred_right->side_effects = opt_expr (&curr->pred_right);\n\t  break;\n\n\t  /* At this point, get_expr and scan_rest have already removed\n\t     all of the user's parentheses. */\n\n\tdefault:\n\t  error (EXIT_FAILURE, 0, _(\"oops -- invalid expression type!\"));\n\t  break;\n\t}\n\n      if (curr->pred_right->side_effects == true)\n\t{\n\t  last_sidep = prevp;\n\n\t  /* Incorporate lists and reset list pointers for this group.  */\n\t  merge_lists (cbo_list, NumEvaluationCosts, &name_list, &regex_list, last_sidep);\n\t  has_side_effects = true;\n\t}\n\n      prevp = &curr->pred_left;\n    }\n\n  /* Do final list merges. */\n  last_sidep = prevp;\n  merge_lists (cbo_list, NumEvaluationCosts, &name_list, &regex_list, last_sidep);\n  return has_side_effects;\n}",
      "lines": 165,
      "depth": 21,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "constrain_rate": {
      "start_point": [
        854,
        0
      ],
      "end_point": [
        863,
        1
      ],
      "content": "static float\nconstrain_rate (float rate)\n{\n  if (rate > 1.0f)\n    return 1.0;\n  else if (rate < 0.0)\n    return 0.0;\n  else\n    return rate;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "float"
      ]
    },
    "set_new_parent": {
      "start_point": [
        868,
        0
      ],
      "end_point": [
        915,
        1
      ],
      "content": "static struct predicate *\nset_new_parent (struct predicate *curr, enum predicate_precedence high_prec, struct predicate **prevp)\n{\n  struct predicate *new_parent;\n\n  new_parent = xmalloc (sizeof (struct predicate));\n  new_parent->p_type = BI_OP;\n  new_parent->p_prec = high_prec;\n  new_parent->need_stat = false;\n  new_parent->need_type = false;\n  new_parent->need_inum = false;\n  new_parent->p_cost = NeedsNothing;\n  new_parent->arg_text = NULL;\n\n  switch (high_prec)\n    {\n    case COMMA_PREC:\n      new_parent->pred_func = pred_comma;\n      new_parent->p_name = \",\";\n      new_parent->est_success_rate = 1.0;\n      break;\n    case OR_PREC:\n      new_parent->pred_func = pred_or;\n      new_parent->p_name = \"-o\";\n      new_parent->est_success_rate = constrain_rate (curr->est_success_rate);\n      break;\n    case AND_PREC:\n      new_parent->pred_func = pred_and;\n      new_parent->p_name = \"-a\";\n      new_parent->est_success_rate = constrain_rate (curr->est_success_rate);\n      break;\n    default:\n      ;\t\t\t\t/* empty */\n    }\n\n  new_parent->side_effects = false;\n  new_parent->no_default_print = false;\n  new_parent->args.str = NULL;\n  new_parent->pred_next = NULL;\n\n  /* Link in new_parent.\n     Pushes rest of left branch down 1 level to new_parent->pred_right. */\n  new_parent->pred_left = NULL;\n  new_parent->pred_right = curr;\n  *prevp = new_parent;\n\n  return new_parent;\n}",
      "lines": 48,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "struct predicate",
        "struct",
        "predicate",
        "*\nset_new_parent (struct predicate *curr, enum predicate_precedence high_prec, struct predicate **prevp)",
        "*"
      ]
    },
    "merge_pred": {
      "start_point": [
        920,
        0
      ],
      "end_point": [
        925,
        1
      ],
      "content": "static void\nmerge_pred (struct predicate *beg_list, struct predicate *end_list, struct predicate **last_p)\n{\n  end_list->pred_left = *last_p;\n  *last_p = beg_list;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "check_sorted": {
      "start_point": [
        1007,
        0
      ],
      "end_point": [
        1022,
        1
      ],
      "content": "static bool\ncheck_sorted (void *base, size_t members, size_t membersize,\n\t      int (*cmpfn)(const void*, const void*))\n{\n  const char *p = base;\n  size_t i;\n  for (i=1u; i<members; ++i)\n    {\n      int result = cmpfn (p+i*membersize, p+(i-1)*membersize);\n      if (result < 0)\n\treturn false;\n      result = cmpfn (p+(i-1)*membersize, p+i*membersize);\n      assert (result <= 0);\n    }\n  return true;\n}",
      "lines": 16,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "cost_table_comparison": {
      "start_point": [
        1025,
        0
      ],
      "end_point": [
        1042,
        1
      ],
      "content": "static int\ncost_table_comparison (const void *p1, const void *p2)\n{\n  /* We have to compare the function pointers with memcmp(),\n   * because ISO C does not allow magnitude comparison of\n   * function pointers (just equality testing).\n   */\n  const struct pred_cost_lookup *pc1 = p1;\n  const struct pred_cost_lookup *pc2 = p2;\n  union {\n    PRED_FUNC pfn;\n    char mem[sizeof (PRED_FUNC)];\n  } u1, u2;\n\n  u1.pfn = pc1->fn;\n  u2.pfn = pc2->fn;\n  return memcmp (u1.mem, u2.mem, sizeof(u1.pfn));\n}",
      "lines": 18,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "get_pred_cost": {
      "start_point": [
        1044,
        0
      ],
      "end_point": [
        1130,
        1
      ],
      "content": "static enum EvaluationCost\nget_pred_cost (const struct predicate *p)\n{\n  enum EvaluationCost data_requirement_cost = NeedsNothing;\n  enum EvaluationCost inherent_cost = NeedsUnknown;\n\n  if (p->need_stat)\n    {\n      data_requirement_cost = NeedsStatInfo;\n    }\n  else if (p->need_inum)\n    {\n      data_requirement_cost = NeedsInodeNumber;\n    }\n  else if (p->need_type)\n    {\n      data_requirement_cost = NeedsType;\n    }\n  else\n    {\n      data_requirement_cost = NeedsNothing;\n    }\n\n  if (pred_is (p, pred_exec) || pred_is(p, pred_execdir))\n    {\n      if (p->args.exec_vec.multiple)\n\tinherent_cost = NeedsEventualExec;\n      else\n\tinherent_cost = NeedsImmediateExec;\n    }\n  else if (pred_is (p, pred_fprintf))\n    {\n      /* the parser calculated the cost for us. */\n      inherent_cost = p->p_cost;\n    }\n  else\n    {\n      struct pred_cost_lookup key;\n      void *entry;\n\n      if (!pred_table_sorted)\n\t{\n\t  qsort (costlookup,\n\t\t sizeof(costlookup)/sizeof(costlookup[0]),\n\t\t sizeof(costlookup[0]),\n\t\t cost_table_comparison);\n\n\t  if (!check_sorted (costlookup,\n\t\t\t     sizeof(costlookup)/sizeof(costlookup[0]),\n\t\t\t     sizeof(costlookup[0]),\n\t\t\t     cost_table_comparison))\n\t    {\n\t      error (EXIT_FAILURE, 0,\n\t\t     \"failed to sort the costlookup array\");\n\t    }\n\t  pred_table_sorted = 1;\n\t}\n      key.fn = p->pred_func;\n      entry = bsearch (&key, costlookup,\n\t\t       sizeof(costlookup)/sizeof(costlookup[0]),\n\t\t       sizeof(costlookup[0]),\n\t\t       cost_table_comparison);\n      if (entry)\n\t{\n\t  inherent_cost = ((const struct pred_cost_lookup*)entry)->cost;\n\t}\n      else\n\t{\n\t  /* This message indicates a bug.  If we issue the message, we\n\t     actually have two bugs: if find emits a diagnostic, its result\n\t     should be nonzero.  However, not having an entry for a predicate\n\t     will not affect the output (just the performance) so I think it\n\t     would be confusing to exit with a nonzero status.\n\t  */\n\t  error (0, 0,\n\t\t _(\"warning: there is no entry in the predicate evaluation \"\n\t\t   \"cost table for predicate %s; please report this as a bug\"),\n\t\t p->p_name);\n\t  inherent_cost = NeedsUnknown;\n\t}\n    }\n\n  if (inherent_cost > data_requirement_cost)\n    return inherent_cost;\n  else\n    return data_requirement_cost;\n}",
      "lines": 87,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "enum EvaluationCost",
        "enum",
        "EvaluationCost"
      ]
    },
    "estimate_costs": {
      "start_point": [
        1132,
        0
      ],
      "end_point": [
        1142,
        1
      ],
      "content": "static void\nestimate_costs (struct predicate *tree)\n{\n  if (tree)\n    {\n      estimate_costs (tree->pred_right);\n      estimate_costs (tree->pred_left);\n\n      tree->p_cost = get_pred_cost(tree);\n    }\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "get_eval_tree": {
      "start_point": [
        1144,
        0
      ],
      "end_point": [
        1148,
        1
      ],
      "content": "struct predicate*\nget_eval_tree (void)\n{\n  return eval_tree;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "struct predicate",
        "struct",
        "predicate",
        "*\nget_eval_tree (void)",
        "*"
      ]
    },
    "getrate": {
      "start_point": [
        1150,
        0
      ],
      "end_point": [
        1157,
        1
      ],
      "content": "static float\ngetrate (const struct predicate *p)\n{\n  if (p)\n    return p->est_success_rate;\n  else\n    return 1.0f;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "float"
      ]
    },
    "calculate_derived_rates": {
      "start_point": [
        1160,
        0
      ],
      "end_point": [
        1225,
        1
      ],
      "content": "float\ncalculate_derived_rates (struct predicate *p)\n{\n  assert (NULL != p);\n\n  if (p->pred_right)\n    calculate_derived_rates (p->pred_right);\n  if (p->pred_left)\n    calculate_derived_rates (p->pred_left);\n\n  assert (p->p_type != CLOSE_PAREN);\n  assert (p->p_type != OPEN_PAREN);\n\n  switch (p->p_type)\n    {\n    case NO_TYPE:\n      assert (NULL == p->pred_right);\n      assert (NULL == p->pred_left);\n      return p->est_success_rate;\n\n    case PRIMARY_TYPE:\n      assert (NULL == p->pred_right);\n      assert (NULL == p->pred_left);\n      return p->est_success_rate;\n\n    case UNI_OP:\n      /* Unary operators must have exactly one operand */\n      assert (pred_is (p, pred_negate));\n      assert (NULL == p->pred_left);\n      p->est_success_rate = (1.0 - p->pred_right->est_success_rate);\n      return p->est_success_rate;\n\n    case BI_OP:\n      {\n\tfloat rate;\n\t/* Binary operators must have two operands */\n\tif (pred_is (p, pred_and))\n\t  {\n\t    rate = getrate (p->pred_right) * getrate(p->pred_left);\n\t  }\n\telse if (pred_is (p, pred_comma))\n\t  {\n\t    rate = 1.0f;\n\t  }\n\telse if (pred_is (p, pred_or))\n\t  {\n\t    rate = getrate (p->pred_right) + getrate(p->pred_left);\n\t  }\n\telse\n\t  {\n\t    /* only and, or and comma are BI_OP. */\n\t    assert (0);\n\t    abort ();\n\t  }\n\tp->est_success_rate = constrain_rate (rate);\n      }\n      return p->est_success_rate;\n\n    case OPEN_PAREN:\n    case CLOSE_PAREN:\n      p->est_success_rate = 1.0;\n      return p->est_success_rate;\n    }\n  assert (0);\n  abort ();\n}",
      "lines": 66,
      "depth": 17,
      "decorators": [
        "float"
      ]
    },
    "check_normalization": {
      "start_point": [
        1232,
        0
      ],
      "end_point": [
        1249,
        1
      ],
      "content": "static void\ncheck_normalization (struct predicate *p, bool at_root)\n{\n  if (at_root)\n    {\n      assert (BI_OP == p->p_type);\n    }\n\n  if (p->pred_left)\n    {\n      assert (BI_OP == p->pred_left->p_type);\n      check_normalization(p->pred_left, false);\n    }\n  if (p->pred_right)\n    {\n      check_normalization (p->pred_right, false);\n    }\n}",
      "lines": 18,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "build_expression_tree": {
      "start_point": [
        1251,
        0
      ],
      "end_point": [
        1452,
        1
      ],
      "content": "struct predicate*\nbuild_expression_tree (int argc, char *argv[], int end_of_leading_options)\n{\n  const struct parser_table *parse_entry; /* Pointer to the parsing table entry for this expression. */\n  char *predicate_name;\t\t/* Name of predicate being parsed. */\n  struct predicate *cur_pred;\n  const struct parser_table *entry_close, *entry_print, *entry_open;\n  int i, oldi;\n\n  predicates = NULL;\n\n  /* Find where in ARGV the predicates begin by skipping the list of\n   * start points.  As a side effect, also figure out which is the\n   * first and last start point.\n   */\n  start_points = argv + end_of_leading_options;\n  for (i = end_of_leading_options; i < argc && !looks_like_expression(argv[i], true); i++)\n    {\n      ++num_start_points;\n    }\n\n  /* Enclose the expression in `( ... )' so a default -print will\n     apply to the whole expression. */\n  entry_open  = find_parser (\"(\");\n  entry_close = find_parser (\")\");\n  entry_print = find_parser (\"print\");\n  assert (entry_open  != NULL);\n  assert (entry_close != NULL);\n  assert (entry_print != NULL);\n\n  parse_openparen (entry_open, argv, &argc);\n  last_pred->p_name = \"(\";\n  predicates->artificial = true;\n  parse_begin_user_args (argv, argc, last_pred, predicates);\n  pred_sanity_check (last_pred);\n\n  /* Build the input order list. */\n  while (i < argc )\n    {\n      state.already_issued_stat_error_msg = false;\n      if (!looks_like_expression (argv[i], false))\n\t{\n\t  error (0, 0, _(\"paths must precede expression: %s\"), argv[i]);\n\t  usage (stderr, 1, NULL);\n\t}\n\n      predicate_name = argv[i];\n      parse_entry = find_parser (predicate_name);\n      if (parse_entry == NULL)\n\t{\n\t  /* Command line option not recognized */\n\t  error (EXIT_FAILURE, 0, _(\"unknown predicate `%s'\"), predicate_name);\n\t}\n\n      /* We have recognised a test of the form -foo.  Eat that,\n       * unless it is a predicate like -newerXY.\n       */\n      if (parse_entry->type != ARG_SPECIAL_PARSE)\n\t{\n\t  i++;\n\t}\n      oldi = i;\n      if (!(*(parse_entry->parser_func)) (parse_entry, argv, &i))\n\t{\n\t  if (argv[i])\n\t    {\n\t      if ( (ARG_SPECIAL_PARSE == parse_entry->type) && (i == oldi) )\n\t\t{\n\t\t  /* The special parse function spat out the\n\t\t   * predicate.  It must be invalid, or not tasty.\n\t\t   */\n\t\t  error (EXIT_FAILURE, 0, _(\"invalid predicate `%s'\"),\n\t\t\t predicate_name);\n\t\t}\n\t      else\n\t\t{\n\t\t  error (EXIT_FAILURE, 0, _(\"invalid argument `%s' to `%s'\"),\n\t\t\t argv[i], predicate_name);\n\t\t}\n\t    }\n\t  else\n\t    {\n\t      /* Command line option requires an argument */\n\t      error (EXIT_FAILURE, 0,\n\t\t     _(\"missing argument to `%s'\"), predicate_name);\n\t    }\n\t}\n      else\n\t{\n\t  last_pred->p_name = predicate_name;\n\n\t  /* If the parser consumed an argument, save it. */\n\t  if (i != oldi)\n\t    last_pred->arg_text = argv[oldi];\n\t  else\n\t    last_pred->arg_text = NULL;\n\t}\n      pred_sanity_check(last_pred);\n      pred_sanity_check(predicates); /* XXX: expensive */\n    }\n  parse_end_user_args (argv, argc, last_pred, predicates);\n  if (predicates->pred_next == NULL)\n    {\n      /* No predicates that do something other than set a global variable\n\t were given; remove the unneeded initial `(' and add `-print'. */\n      cur_pred = predicates;\n      predicates = last_pred = predicates->pred_next;\n      free (cur_pred);\n      parse_print (entry_print, argv, &argc);\n      last_pred->p_name = \"-print\";\n      pred_sanity_check(last_pred);\n      pred_sanity_check(predicates); /* XXX: expensive */\n    }\n  else if (!default_prints (predicates->pred_next))\n    {\n      /* One or more predicates that produce output were given;\n\t remove the unneeded initial `('. */\n      cur_pred = predicates;\n      predicates = predicates->pred_next;\n      pred_sanity_check (predicates); /* XXX: expensive */\n      free (cur_pred);\n    }\n  else\n    {\n      /* `( user-supplied-expression ) -print'. */\n      parse_closeparen (entry_close, argv, &argc);\n      last_pred->p_name = \")\";\n      last_pred->artificial = true;\n      pred_sanity_check (last_pred);\n      parse_print (entry_print, argv, &argc);\n      last_pred->p_name = \"-print\";\n      last_pred->artificial = true;\n      pred_sanity_check (last_pred);\n      pred_sanity_check (predicates); /* XXX: expensive */\n    }\n\n  if (options.debug_options & (DebugExpressionTree|DebugTreeOpt))\n    {\n      fprintf (stderr, \"Predicate List:\\n\");\n      print_list (stderr, predicates);\n    }\n\n  /* do a sanity check */\n  check_option_combinations (predicates);\n  pred_sanity_check (predicates);\n\n  /* Done parsing the predicates.  Build the evaluation tree. */\n  cur_pred = predicates;\n  eval_tree = get_expr (&cur_pred, NO_PREC, NULL);\n  calculate_derived_rates (eval_tree);\n\n  /* Check if we have any left-over predicates (this fixes\n   * Debian bug #185202).\n   */\n  if (cur_pred != NULL)\n    {\n      /* cur_pred->p_name is often NULL here */\n      if (pred_is (cur_pred, pred_closeparen))\n\t{\n\t  /* e.g. \"find \\( -true \\) \\)\" */\n\t  error (EXIT_FAILURE, 0, _(\"you have too many ')'\"));\n\t}\n      else\n\t{\n\t  if (cur_pred->p_name)\n\t    error (EXIT_FAILURE, 0,\n\t\t   _(\"unexpected extra predicate '%s'\"), cur_pred->p_name);\n\t  else\n\t    error (EXIT_FAILURE, 0, _(\"unexpected extra predicate\"));\n\t}\n    }\n\n  if (options.debug_options & (DebugExpressionTree|DebugTreeOpt))\n    {\n      fprintf (stderr, \"Eval Tree:\\n\");\n      print_tree (stderr, eval_tree, 0);\n    }\n\n  estimate_costs (eval_tree);\n\n  /* Rearrange the eval tree in optimal-predicate order. */\n  opt_expr (&eval_tree);\n\n  /* Check that the tree is in normalised order (opt_expr does this) */\n  check_normalization (eval_tree, true);\n\n  do_arm_swaps (eval_tree);\n\n  /* Check that the tree is still in normalised order */\n  check_normalization (eval_tree, true);\n\n  if (options.debug_options & (DebugExpressionTree|DebugTreeOpt))\n    {\n      fprintf (stderr, \"Optimized Eval Tree:\\n\");\n      print_tree (stderr, eval_tree, 0);\n      fprintf (stderr, \"Optimized command line:\\n\");\n      print_optlist (stderr, eval_tree);\n      fprintf (stderr, \"\\n\");\n    }\n\n  return eval_tree;\n}",
      "lines": 202,
      "depth": 17,
      "decorators": [
        "struct predicate",
        "struct",
        "predicate",
        "*\nbuild_expression_tree (int argc, char *argv[], int end_of_leading_options)",
        "*"
      ]
    },
    "init_pred_perf": {
      "start_point": [
        1456,
        0
      ],
      "end_point": [
        1461,
        1
      ],
      "content": "static void\ninit_pred_perf (struct predicate *pred)\n{\n  struct predicate_performance_info *p = &pred->perf;\n  p->visits = p->successes = 0;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "get_new_pred_noarg": {
      "start_point": [
        1464,
        0
      ],
      "end_point": [
        1473,
        1
      ],
      "content": "struct predicate *\nget_new_pred_noarg (const struct parser_table *entry)\n{\n  struct predicate *p = get_new_pred (entry);\n  if (p)\n    {\n      p->arg_text = NULL;\n    }\n  return p;\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "struct predicate",
        "struct",
        "predicate",
        "*\nget_new_pred_noarg (const struct parser_table *entry)",
        "*"
      ]
    },
    "get_new_pred": {
      "start_point": [
        1484,
        0
      ],
      "end_point": [
        1528,
        1
      ],
      "content": "struct predicate *\nget_new_pred (const struct parser_table *entry)\n{\n  register struct predicate *new_pred;\n  (void) entry;\n\n  /* Options should not be turned into predicates. */\n  assert (entry->type != ARG_OPTION);\n  assert (entry->type != ARG_POSITIONAL_OPTION);\n\n  if (predicates == NULL)\n    {\n      predicates = (struct predicate *)\n\txmalloc (sizeof (struct predicate));\n      last_pred = predicates;\n    }\n  else\n    {\n      new_pred = xmalloc (sizeof (struct predicate));\n      last_pred->pred_next = new_pred;\n      last_pred = new_pred;\n    }\n  last_pred->parser_entry = entry;\n  last_pred->pred_func = NULL;\n  last_pred->p_name = NULL;\n  last_pred->p_type = NO_TYPE;\n  last_pred->p_prec = NO_PREC;\n  last_pred->side_effects = false;\n  last_pred->no_default_print = false;\n  last_pred->need_stat = true;\n  last_pred->need_type = true;\n  last_pred->need_inum = false;\n  last_pred->p_cost = NeedsUnknown;\n  last_pred->arg_text = \"ThisShouldBeSetToSomethingElse\";\n  last_pred->args.str = NULL;\n  last_pred->args.scontext = NULL;\n  last_pred->pred_next = NULL;\n  last_pred->pred_left = NULL;\n  last_pred->pred_right = NULL;\n  last_pred->literal_control_chars = options.literal_control_chars;\n  last_pred->artificial = false;\n  last_pred->est_success_rate = 1.0;\n  init_pred_perf (last_pred);\n  return last_pred;\n}",
      "lines": 45,
      "depth": 13,
      "decorators": [
        "struct predicate",
        "struct",
        "predicate",
        "*\nget_new_pred (const struct parser_table *entry)",
        "*"
      ]
    },
    "get_new_pred_chk_op": {
      "start_point": [
        1534,
        0
      ],
      "end_point": [
        1580,
        1
      ],
      "content": "struct predicate *\nget_new_pred_chk_op (const struct parser_table *entry,\n\t\t     const char *arg)\n{\n  struct predicate *new_pred;\n  static const struct parser_table *entry_and = NULL;\n\n  /* Locate the entry in the parser table for the \"and\" operator */\n  if (NULL == entry_and)\n    entry_and = find_parser (\"and\");\n\n  /* Check that it's actually there. If not, that is a bug.*/\n  assert (entry_and != NULL);\n\n  if (last_pred)\n    switch (last_pred->p_type)\n      {\n      case NO_TYPE:\n\terror (EXIT_FAILURE, 0, _(\"oops -- invalid default insertion of and!\"));\n\tbreak;\n\n      case PRIMARY_TYPE:\n      case CLOSE_PAREN:\n\t/* We need to interpose the and operator. */\n\tnew_pred = get_new_pred_noarg (entry_and);\n\tnew_pred->pred_func = pred_and;\n\tnew_pred->p_name = \"-a\";\n\tnew_pred->p_type = BI_OP;\n\tnew_pred->p_prec = AND_PREC;\n\tnew_pred->need_stat = false;\n\tnew_pred->need_type = false;\n\tnew_pred->need_inum = false;\n\tnew_pred->arg_text = NULL;\n\tnew_pred->args.str = NULL;\n\tnew_pred->side_effects = false;\n\tnew_pred->no_default_print = false;\n\tbreak;\n\n      default:\n\tbreak;\n      }\n\n  new_pred = get_new_pred (entry);\n  new_pred->arg_text = arg;\n  new_pred->parser_entry = entry;\n  return new_pred;\n}",
      "lines": 47,
      "depth": 13,
      "decorators": [
        "struct predicate",
        "struct",
        "predicate",
        "*\nget_new_pred_chk_op (const struct parser_table *entry,\n\t\t     const char *arg)",
        "*"
      ]
    },
    "cost_name": {
      "start_point": [
        1636,
        0
      ],
      "end_point": [
        1646,
        1
      ],
      "content": "static const char *\ncost_name (enum EvaluationCost cost)\n{\n  unsigned int i;\n  unsigned int n = sizeof (cost_table)/sizeof(cost_table[0]);\n\n  for (i = 0; i<n; ++i)\n    if (cost_table[i].cost == cost)\n      return cost_table[i].name;\n  return \"unknown\";\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\ncost_name (enum EvaluationCost cost)",
        "*"
      ]
    },
    "type_name": {
      "start_point": [
        1649,
        0
      ],
      "end_point": [
        1658,
        1
      ],
      "content": "static const char *\ntype_name (short type)\n{\n  int i;\n\n  for (i = 0; type_table[i].type != (short) -1; i++)\n    if (type_table[i].type == type)\n      break;\n  return type_table[i].type_name;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\ntype_name (short type)",
        "*"
      ]
    },
    "prec_name": {
      "start_point": [
        1660,
        0
      ],
      "end_point": [
        1669,
        1
      ],
      "content": "static const char *\nprec_name (short prec)\n{\n  int i;\n\n  for (i = 0; prec_table[i].prec != (short) -1; i++)\n    if (prec_table[i].prec == prec)\n      break;\n  return prec_table[i].prec_name;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nprec_name (short prec)",
        "*"
      ]
    },
    "print_tree": {
      "start_point": [
        1675,
        0
      ],
      "end_point": [
        1746,
        1
      ],
      "content": "void\nprint_tree (FILE *fp, struct predicate *node, int indent)\n{\n  int i;\n\n  if (node == NULL)\n    return;\n  for (i = 0; i < indent; i++)\n    fprintf (fp, \"    \");\n  fprintf (fp, \"pred=[\");\n  print_predicate (fp, node);\n  fprintf (fp, \"] type=%s prec=%s\",\n\t  type_name (node->p_type), prec_name (node->p_prec));\n  fprintf (fp, \" cost=%s rate=%#03.2g %sside effects \",\n\t   cost_name (node->p_cost),\n\t   node->est_success_rate,\n\t   (node->side_effects ? \"\" : \"no \"));\n\n  if (node->need_stat || node->need_type || node->need_inum)\n    {\n      int comma = 0;\n\n      fprintf (fp, \"Needs \");\n      if (node->need_stat)\n\t{\n\t  fprintf (fp, \"stat\");\n\t  comma = 1;\n\t}\n      if (node->need_inum)\n\t{\n\t  fprintf (fp, \"%sinode\", comma ? \",\" : \"\");\n\t  comma = 1;\n\t}\n      if (node->need_type)\n\t{\n\t  fprintf (fp, \"%stype\", comma ? \",\" : \"\");\n\t}\n    }\n  fprintf (fp, \"\\n\");\n\n\n  for (i = 0; i < indent; i++)\n    fprintf (fp, \"    \");\n  if (NULL == node->pred_left && NULL == node->pred_right)\n    {\n      fprintf (fp, \"no children.\\n\");\n    }\n  else\n    {\n      if (node->pred_left)\n\t{\n\t  fprintf (fp, \"left:\\n\");\n\t  print_tree (fp, node->pred_left, indent + 1);\n\t}\n      else\n\t{\n\t  fprintf (fp, \"no left.\\n\");\n\t}\n\n      for (i = 0; i < indent; i++)\n\tfprintf (fp, \"    \");\n      if (node->pred_right)\n\t{\n\t  fprintf (fp, \"right:\\n\");\n\t  print_tree (fp, node->pred_right, indent + 1);\n\t}\n      else\n\t{\n\t  fprintf (fp, \"no right.\\n\");\n\t}\n    }\n}",
      "lines": 72,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "findutils/findutils-4.6.0/find/util.c": {
    "insert_primary_withpred": {
      "start_point": [
        98,
        0
      ],
      "end_point": [
        112,
        1
      ],
      "content": "struct predicate *\ninsert_primary_withpred (const struct parser_table *entry,\n\t\t\t PRED_FUNC pred_func,\n\t\t\t const char *arg)\n{\n  struct predicate *new_pred;\n\n  new_pred = get_new_pred_chk_op (entry, arg);\n  new_pred->pred_func = pred_func;\n  new_pred->p_name = entry->parser_name;\n  new_pred->args.str = NULL;\n  new_pred->p_type = PRIMARY_TYPE;\n  new_pred->p_prec = NO_PREC;\n  return new_pred;\n}",
      "lines": 15,
      "depth": 7,
      "decorators": [
        "struct predicate",
        "struct",
        "predicate",
        "*\ninsert_primary_withpred (const struct parser_table *entry,\n\t\t\t PRED_FUNC pred_func,\n\t\t\t const char *arg)",
        "*"
      ]
    },
    "insert_primary": {
      "start_point": [
        129,
        0
      ],
      "end_point": [
        134,
        1
      ],
      "content": "struct predicate *\ninsert_primary (const struct parser_table *entry, const char *arg)\n{\n  assert (entry->pred_func != NULL);\n  return insert_primary_withpred (entry, entry->pred_func, arg);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "struct predicate",
        "struct",
        "predicate",
        "*\ninsert_primary (const struct parser_table *entry, const char *arg)",
        "*"
      ]
    },
    "insert_primary_noarg": {
      "start_point": [
        136,
        0
      ],
      "end_point": [
        140,
        1
      ],
      "content": "struct predicate *\ninsert_primary_noarg (const struct parser_table *entry)\n{\n  return insert_primary (entry, NULL);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "struct predicate",
        "struct",
        "predicate",
        "*\ninsert_primary_noarg (const struct parser_table *entry)",
        "*"
      ]
    },
    "show_valid_debug_options": {
      "start_point": [
        144,
        0
      ],
      "end_point": [
        165,
        1
      ],
      "content": "static void\nshow_valid_debug_options (FILE *fp, int full)\n{\n  size_t i;\n  if (full)\n    {\n      fprintf (fp, \"Valid arguments for -D:\\n\");\n      for (i=0; i<N_DEBUGASSOC; ++i)\n\t{\n\t  fprintf (fp, \"%-10s %s\\n\",\n\t\t   debugassoc[i].name,\n\t\t   debugassoc[i].docstring);\n\t}\n    }\n  else\n    {\n      for (i=0; i<N_DEBUGASSOC; ++i)\n\t{\n\t  fprintf (fp, \"%s%s\", (i>0 ? \"|\" : \"\"), debugassoc[i].name);\n\t}\n    }\n}",
      "lines": 22,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "usage": {
      "start_point": [
        167,
        0
      ],
      "end_point": [
        178,
        1
      ],
      "content": "void\nusage (FILE *fp, int status, char *msg)\n{\n  if (msg)\n    fprintf (fp, \"%s: %s\\n\", program_name, msg);\n\n  fprintf (fp, _(\"Usage: %s [-H] [-L] [-P] [-Olevel] [-D \"), program_name);\n  show_valid_debug_options (fp, 0);\n  fprintf (fp, _(\"] [path...] [expression]\\n\"));\n  if (0 != status)\n    exit (status);\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "set_stat_placeholders": {
      "start_point": [
        180,
        0
      ],
      "end_point": [
        199,
        1
      ],
      "content": "void\nset_stat_placeholders (struct stat *p)\n{\n#if HAVE_STRUCT_STAT_ST_BIRTHTIME\n  p->st_birthtime = 0;\n#endif\n#if HAVE_STRUCT_STAT_ST_BIRTHTIMENSEC\n  p->st_birthtimensec = 0;\n#endif\n#if HAVE_STRUCT_STAT_ST_BIRTHTIMESPEC_TV_NSEC\n  p->st_birthtimespec.tv_nsec = -1;\n#endif\n#if HAVE_STRUCT_STAT_ST_BIRTHTIMESPEC_TV_SEC\n  p->st_birthtimespec.tv_sec = 0;\n#else\n  /* Avoid pointless compiler warning about unused parameters if none of these\n     macros are set to nonzero values. */\n  (void) p;\n#endif\n}",
      "lines": 20,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "get_statinfo": {
      "start_point": [
        205,
        0
      ],
      "end_point": [
        239,
        1
      ],
      "content": "int\nget_statinfo (const char *pathname, const char *name, struct stat *p)\n{\n  /* Set markers in fields so we have a good idea if the implementation\n   * didn't bother to set them (e.g., NetBSD st_birthtimespec for MS-DOS\n   * files)\n   */\n  if (!state.have_stat)\n    {\n      set_stat_placeholders (p);\n      if (0 == (*options.xstat) (name, p))\n\t{\n\t  if (00000 == p->st_mode)\n\t    {\n\t      /* Savannah bug #16378. */\n\t      error (0, 0, _(\"WARNING: file %s appears to have mode 0000\"),\n\t\t     quotearg_n_style (0, options.err_quoting_style, name));\n\t      error_severity (1);\n\t    }\n\t}\n      else\n\t{\n\t  if (!options.ignore_readdir_race || (errno != ENOENT) )\n\t    {\n\t      nonfatal_target_file_error (errno, pathname);\n\t    }\n\t  return -1;\n\t}\n    }\n  state.have_stat = true;\n  state.have_type = true;\n  state.type = p->st_mode;\n\n  return 0;\n}",
      "lines": 35,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "get_info": {
      "start_point": [
        244,
        0
      ],
      "end_point": [
        305,
        1
      ],
      "content": "int\nget_info (const char *pathname,\n\t  struct stat *p,\n\t  struct predicate *pred_ptr)\n{\n  bool todo = false;\n\n  /* If we need the full stat info, or we need the type info but don't\n   * already have it, stat the file now.\n   */\n  if (pred_ptr->need_stat)\n    {\n      todo = true;\t\t/* need full stat info */\n    }\n  else if (pred_ptr->need_type && !state.have_type)\n    {\n      todo = true;\t\t/* need to stat to get the type */\n    }\n  else if (pred_ptr->need_inum)\n    {\n      if (!p->st_ino)\n\t{\n\t  todo = true;\t\t/* need to stat to get the inode number */\n\t}\n      else if ((!state.have_type) || S_ISDIR(p->st_mode))\n\t{\n\t  /* For now we decide not to trust struct dirent.d_ino for\n\t   * directory entries that are subdirectories, in case this\n\t   * subdirectory is a mount point.  We also need to call a\n\t   * stat function if we don't have st_ino (i.e. it is zero).\n\t   */\n\t  todo = true;\n\t}\n    }\n  if (todo)\n    {\n      int result = get_statinfo (pathname, state.rel_pathname, p);\n      if (result != 0)\n\t{\n\t  return -1;\t\t/* failure. */\n\t}\n      else\n\t{\n\t  /* Verify some postconditions.  We can't check st_mode for\n\t     non-zero-ness because of Savannah bug #16378 (which is\n\t     that broken NFS servers can return st_mode==0). */\n\t  if (pred_ptr->need_type)\n\t    {\n\t      assert (state.have_type);\n\t    }\n\t  if (pred_ptr->need_inum)\n\t    {\n\t      assert (p->st_ino);\n\t    }\n\t  return 0;\t\t/* success. */\n\t}\n    }\n  else\n    {\n      return 0;\t\t\t/* success; nothing to do. */\n    }\n}",
      "lines": 62,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "check_nofollow": {
      "start_point": [
        310,
        0
      ],
      "end_point": [
        342,
        1
      ],
      "content": "bool\ncheck_nofollow (void)\n{\n  struct utsname uts;\n  float  release;\n\n  if (0 == O_NOFOLLOW)\n    {\n      return false;\n    }\n\n  if (0 == uname (&uts))\n    {\n      /* POSIX requires that atof ignores \"unrecognised suffixes\"; we specifically\n       * want that behaviour. */\n      double (*conversion)(const char*) = atof;  /* avoid sc_prohibit_atoi_atof check. */\n      release = conversion (uts.release);\n\n      if (0 == strcmp (\"Linux\", uts.sysname))\n\t{\n\t  /* Linux kernels 2.1.126 and earlier ignore the O_NOFOLLOW flag. */\n\t  return release >= 2.2; /* close enough */\n\t}\n      else if (0 == strcmp (\"FreeBSD\", uts.sysname))\n\t{\n\t  /* FreeBSD 3.0-CURRENT and later support it */\n\t  return release >= 3.1;\n\t}\n    }\n\n  /* Well, O_NOFOLLOW was defined, so we'll try to use it. */\n  return true;\n}",
      "lines": 33,
      "depth": 12,
      "decorators": [
        "bool"
      ]
    },
    "exec_cb": {
      "start_point": [
        346,
        0
      ],
      "end_point": [
        352,
        1
      ],
      "content": "static int\nexec_cb (void *context)\n{\n  struct exec_val *execp = context;\n  bc_do_exec (&execp->ctl, &execp->state);\n  return 0;\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "do_exec": {
      "start_point": [
        354,
        0
      ],
      "end_point": [
        364,
        1
      ],
      "content": "static void\ndo_exec (struct exec_val *execp)\n{\n  run_in_dir (execp->wd_for_exec, exec_cb, execp);\n  if (execp->wd_for_exec != initial_wd)\n    {\n      free_cwd (execp->wd_for_exec);\n      free (execp->wd_for_exec);\n      execp->wd_for_exec = NULL;\n    }\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "do_complete_pending_execdirs": {
      "start_point": [
        372,
        0
      ],
      "end_point": [
        401,
        1
      ],
      "content": "static void\ndo_complete_pending_execdirs (struct predicate *p)\n{\n  if (NULL == p)\n    return;\n\n  assert (state.execdirs_outstanding);\n\n  do_complete_pending_execdirs (p->pred_left);\n\n  if (pred_is (p, pred_execdir) || pred_is(p, pred_okdir))\n    {\n      /* It's an exec-family predicate.  p->args.exec_val is valid. */\n      if (p->args.exec_vec.multiple)\n\t{\n\t  struct exec_val *execp = &p->args.exec_vec;\n\n\t  /* This one was terminated by '+' and so might have some\n\t   * left... Run it if necessary.\n\t   */\n\t  if (execp->state.todo)\n\t    {\n\t      /* There are not-yet-executed arguments. */\n\t      do_exec (execp);\n\t    }\n\t}\n    }\n\n  do_complete_pending_execdirs (p->pred_right);\n}",
      "lines": 30,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "complete_pending_execdirs": {
      "start_point": [
        403,
        0
      ],
      "end_point": [
        411,
        1
      ],
      "content": "void\ncomplete_pending_execdirs (void)\n{\n  if (state.execdirs_outstanding)\n    {\n      do_complete_pending_execdirs (get_eval_tree());\n      state.execdirs_outstanding = false;\n    }\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "complete_pending_execs": {
      "start_point": [
        420,
        0
      ],
      "end_point": [
        448,
        1
      ],
      "content": "void\ncomplete_pending_execs (struct predicate *p)\n{\n  if (NULL == p)\n    return;\n\n  complete_pending_execs (p->pred_left);\n\n  /* It's an exec-family predicate then p->args.exec_val is valid\n   * and we can check it.\n   */\n  /* XXX: what about pred_ok() ? */\n  if (pred_is (p, pred_exec) && p->args.exec_vec.multiple)\n    {\n      struct exec_val *execp = &p->args.exec_vec;\n\n      /* This one was terminated by '+' and so might have some\n       * left... Run it if necessary.  Set state.exit_status if\n       * there are any problems.\n       */\n      if (execp->state.todo)\n\t{\n\t  /* There are not-yet-executed arguments. */\n\t  bc_do_exec (&execp->ctl, &execp->state);\n\t}\n    }\n\n  complete_pending_execs (p->pred_right);\n}",
      "lines": 29,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "record_initial_cwd": {
      "start_point": [
        450,
        0
      ],
      "end_point": [
        461,
        1
      ],
      "content": "void\nrecord_initial_cwd (void)\n{\n  initial_wd = xmalloc (sizeof (*initial_wd));\n  if (0 != save_cwd (initial_wd))\n    {\n      error (EXIT_FAILURE, errno,\n\t     _(\"Failed to save initial working directory%s%s\"),\n\t     (initial_wd->desc < 0 && initial_wd->name) ? \": \" : \"\",\n\t     (initial_wd->desc < 0 && initial_wd->name) ? initial_wd->name : \"\");\n    }\n}",
      "lines": 12,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "cleanup_initial_cwd": {
      "start_point": [
        463,
        0
      ],
      "end_point": [
        481,
        1
      ],
      "content": "static void\ncleanup_initial_cwd (void)\n{\n  if (0 == restore_cwd (initial_wd))\n    {\n      free_cwd (initial_wd);\n      free (initial_wd);\n      initial_wd = NULL;\n    }\n  else\n    {\n      /* since we may already be in atexit, die with _exit(). */\n      error (0, errno,\n\t     _(\"Failed to restore initial working directory%s%s\"),\n\t     (initial_wd->desc < 0 && initial_wd->name) ? \": \" : \"\",\n\t     (initial_wd->desc < 0 && initial_wd->name) ? initial_wd->name : \"\");\n      _exit (EXIT_FAILURE);\n    }\n}",
      "lines": 19,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "traverse_tree": {
      "start_point": [
        484,
        0
      ],
      "end_point": [
        495,
        1
      ],
      "content": "static void\ntraverse_tree (struct predicate *tree,\n\t\t\t  void (*callback)(struct predicate*))\n{\n  if (tree->pred_left)\n    traverse_tree (tree->pred_left, callback);\n\n  callback (tree);\n\n  if (tree->pred_right)\n    traverse_tree (tree->pred_right, callback);\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "undangle_file_pointers": {
      "start_point": [
        501,
        0
      ],
      "end_point": [
        512,
        1
      ],
      "content": "static void\nundangle_file_pointers (struct predicate *p)\n{\n  if (pred_is (p, pred_fprint)\n      || pred_is (p, pred_fprintf)\n      || pred_is (p, pred_fls)\n      || pred_is (p, pred_fprint0))\n    {\n      /* The file was already fclose()d by sharefile_destroy. */\n      p->args.printf_vec.stream = NULL;\n    }\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "fd_leak_check_is_enabled": {
      "start_point": [
        516,
        0
      ],
      "end_point": [
        524,
        1
      ],
      "content": "bool\nfd_leak_check_is_enabled (void)\n{\n  if (getenv (\"GNU_FINDUTILS_FD_LEAK_CHECK\"))\n    return true;\n  else\n    return false;\n\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "bool"
      ]
    },
    "cleanup": {
      "start_point": [
        529,
        0
      ],
      "end_point": [
        554,
        1
      ],
      "content": "void\ncleanup (void)\n{\n  struct predicate *eval_tree = get_eval_tree ();\n  if (eval_tree)\n    {\n      traverse_tree (eval_tree, complete_pending_execs);\n      complete_pending_execdirs ();\n    }\n\n  /* Close ouptut files and NULL out references to them. */\n  sharefile_destroy (state.shared_files);\n  if (eval_tree)\n    traverse_tree (eval_tree, undangle_file_pointers);\n\n  cleanup_initial_cwd ();\n\n  if (fd_leak_check_is_enabled ())\n    {\n      complain_about_leaky_fds ();\n      forget_non_cloexec_fds ();\n    }\n\n  if (fflush (stdout) == EOF)\n    nonfatal_nontarget_file_error (errno, \"standard output\");\n}",
      "lines": 26,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "fallback_stat": {
      "start_point": [
        557,
        0
      ],
      "end_point": [
        582,
        1
      ],
      "content": "static int\nfallback_stat (const char *name, struct stat *p, int prev_rv)\n{\n  /* Our original stat() call failed.  Perhaps we can't follow a\n   * symbolic link.  If that might be the problem, lstat() the link.\n   * Otherwise, admit defeat.\n   */\n  switch (errno)\n    {\n    case ENOENT:\n    case ENOTDIR:\n      if (options.debug_options & DebugStat)\n\tfprintf(stderr, \"fallback_stat(): stat(%s) failed; falling back on lstat()\\n\", name);\n      return fstatat(state.cwd_dir_fd, name, p, AT_SYMLINK_NOFOLLOW);\n\n    case EACCES:\n    case EIO:\n    case ELOOP:\n    case ENAMETOOLONG:\n#ifdef EOVERFLOW\n    case EOVERFLOW:\t    /* EOVERFLOW is not #defined on UNICOS. */\n#endif\n    default:\n      return prev_rv;\n    }\n}",
      "lines": 26,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "optionh_stat": {
      "start_point": [
        595,
        0
      ],
      "end_point": [
        619,
        1
      ],
      "content": "int\noptionh_stat (const char *name, struct stat *p)\n{\n  if (AT_FDCWD != state.cwd_dir_fd)\n    assert (state.cwd_dir_fd >= 0);\n  set_stat_placeholders (p);\n  if (0 == state.curdepth)\n    {\n      /* This file is from the command line; deference the link (if it\n       * is a link).\n       */\n      int rv;\n      rv = fstatat (state.cwd_dir_fd, name, p, 0);\n      if (0 == rv)\n\treturn 0;\t\t/* success */\n      else\n\treturn fallback_stat (name, p, rv);\n    }\n  else\n    {\n      /* Not a file on the command line; do not dereference the link.\n       */\n      return fstatat (state.cwd_dir_fd, name, p, AT_SYMLINK_NOFOLLOW);\n    }\n}",
      "lines": 25,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "optionl_stat": {
      "start_point": [
        625,
        0
      ],
      "end_point": [
        638,
        1
      ],
      "content": "int\noptionl_stat(const char *name, struct stat *p)\n{\n  int rv;\n  if (AT_FDCWD != state.cwd_dir_fd)\n    assert (state.cwd_dir_fd >= 0);\n\n  set_stat_placeholders (p);\n  rv = fstatat (state.cwd_dir_fd, name, p, 0);\n  if (0 == rv)\n    return 0;\t\t\t/* normal case. */\n  else\n    return fallback_stat (name, p, rv);\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "optionp_stat": {
      "start_point": [
        644,
        0
      ],
      "end_point": [
        650,
        1
      ],
      "content": "int\noptionp_stat (const char *name, struct stat *p)\n{\n  assert ((state.cwd_dir_fd >= 0) || (state.cwd_dir_fd==AT_FDCWD));\n  set_stat_placeholders (p);\n  return fstatat (state.cwd_dir_fd, name, p, AT_SYMLINK_NOFOLLOW);\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "debug_stat": {
      "start_point": [
        655,
        0
      ],
      "end_point": [
        673,
        1
      ],
      "content": "int\ndebug_stat (const char *file, struct stat *bufp)\n{\n  ++stat_count;\n  fprintf (stderr, \"debug_stat (%s)\\n\", file);\n\n  switch (options.symlink_handling)\n    {\n    case SYMLINK_ALWAYS_DEREF:\n      return optionl_stat (file, bufp);\n    case SYMLINK_DEREF_ARGSONLY:\n      return optionh_stat (file, bufp);\n    case SYMLINK_NEVER_DEREF:\n      return optionp_stat (file, bufp);\n    }\n  /*NOTREACHED*/\n  assert (0);\n  return -1;\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "following_links": {
      "start_point": [
        676,
        0
      ],
      "end_point": [
        689,
        1
      ],
      "content": "bool\nfollowing_links(void)\n{\n  switch (options.symlink_handling)\n    {\n    case SYMLINK_ALWAYS_DEREF:\n      return true;\n    case SYMLINK_DEREF_ARGSONLY:\n      return (state.curdepth == 0);\n    case SYMLINK_NEVER_DEREF:\n    default:\n      return false;\n    }\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "bool"
      ]
    },
    "digest_mode": {
      "start_point": [
        694,
        0
      ],
      "end_point": [
        749,
        1
      ],
      "content": "bool\ndigest_mode (mode_t *mode,\n\t     const char *pathname,\n\t     const char *name,\n\t     struct stat *pstat,\n\t     bool leaf)\n{\n  /* If we know the type of the directory entry, and it is not a\n   * symbolic link, we may be able to avoid a stat() or lstat() call.\n   */\n  if (*mode)\n    {\n      if (S_ISLNK(*mode) && following_links())\n\t{\n\t  /* mode is wrong because we should have followed the symlink. */\n\t  if (get_statinfo (pathname, name, pstat) != 0)\n\t    return false;\n\t  *mode = state.type = pstat->st_mode;\n\t  state.have_type = true;\n\t}\n      else\n\t{\n\t  state.have_type = true;\n\t  pstat->st_mode = state.type = *mode;\n\t}\n    }\n  else\n    {\n      /* Mode is not yet known; may have to stat the file unless we\n       * can deduce that it is not a directory (which is all we need to\n       * know at this stage)\n       */\n      if (leaf)\n\t{\n\t  state.have_stat = false;\n\t  state.have_type = false;\n\t  state.type = 0;\n\t}\n      else\n\t{\n\t  if (get_statinfo (pathname, name, pstat) != 0)\n\t    return false;\n\n\t  /* If -L is in effect and we are dealing with a symlink,\n\t   * st_mode is the mode of the pointed-to file, while mode is\n\t   * the mode of the directory entry (S_IFLNK).  Hence now\n\t   * that we have the stat information, override \"mode\".\n\t   */\n\t  state.type = *mode = pstat->st_mode;\n\t  state.have_type = true;\n\t}\n    }\n\n  /* success. */\n  return true;\n}",
      "lines": 56,
      "depth": 12,
      "decorators": [
        "bool"
      ]
    },
    "default_prints": {
      "start_point": [
        756,
        0
      ],
      "end_point": [
        766,
        1
      ],
      "content": "bool\ndefault_prints (struct predicate *pred)\n{\n  while (pred != NULL)\n    {\n      if (pred->no_default_print)\n\treturn (false);\n      pred = pred->pred_next;\n    }\n  return (true);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "bool"
      ]
    },
    "looks_like_expression": {
      "start_point": [
        768,
        0
      ],
      "end_point": [
        800,
        1
      ],
      "content": "bool\nlooks_like_expression (const char *arg, bool leading)\n{\n  switch (arg[0])\n    {\n    case '-':\n      if (arg[1])\t\t/* \"-foo\" is an expression.  */\n\treturn true;\n      else\n\treturn false;\t\t/* Just \"-\" is a filename. */\n      break;\n\n    case ')':\n    case ',':\n      if (arg[1])\n\treturn false;\t\t/* )x and ,z are not expressions */\n      else\n\treturn !leading;\t/* A leading ) or , is not either */\n\n      /* ( and ! are part of an expression, but (2 and !foo are\n       * filenames.\n       */\n    case '!':\n    case '(':\n      if (arg[1])\n\treturn false;\n      else\n\treturn true;\n\n    default:\n      return false;\n    }\n}",
      "lines": 33,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    },
    "process_debug_options": {
      "start_point": [
        802,
        0
      ],
      "end_point": [
        840,
        1
      ],
      "content": "static void\nprocess_debug_options (char *arg)\n{\n  const char *p;\n  char *token_context = NULL;\n  const char delimiters[] = \",\";\n  bool empty = true;\n  size_t i;\n\n  p = strtok_r (arg, delimiters, &token_context);\n  while (p)\n    {\n      empty = false;\n\n      for (i=0; i<N_DEBUGASSOC; ++i)\n\t{\n\t  if (0 == strcmp (debugassoc[i].name, p))\n\t    {\n\t      options.debug_options |= debugassoc[i].val;\n\t      break;\n\t    }\n\t}\n      if (i >= N_DEBUGASSOC)\n\t{\n\t  error (0, 0, _(\"Ignoring unrecognised debug flag %s\"),\n\t\t quotearg_n_style (0, options.err_quoting_style, arg));\n\t}\n      p = strtok_r (NULL, delimiters, &token_context);\n    }\n  if (empty)\n    {\n      error(EXIT_FAILURE, 0, _(\"Empty argument to the -D option.\"));\n    }\n  else if (options.debug_options & DebugHelp)\n    {\n      show_valid_debug_options (stdout, 1);\n      exit (EXIT_SUCCESS);\n    }\n}",
      "lines": 39,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "process_optimisation_option": {
      "start_point": [
        843,
        0
      ],
      "end_point": [
        900,
        1
      ],
      "content": "static void\nprocess_optimisation_option (const char *arg)\n{\n  if (0 == arg[0])\n    {\n      error (EXIT_FAILURE, 0,\n\t     _(\"The -O option must be immediately followed by a decimal integer\"));\n    }\n  else\n    {\n      unsigned long opt_level;\n      char *end;\n\n      if (!isdigit ( (unsigned char) arg[0] ))\n\t{\n\t  error (EXIT_FAILURE, 0,\n\t\t _(\"Please specify a decimal number immediately after -O\"));\n\t}\n      else\n\t{\n\t  int prev_errno = errno;\n\t  errno  = 0;\n\n\t  opt_level = strtoul (arg, &end, 10);\n\t  if ( (0==opt_level) && (end==arg) )\n\t    {\n\t      error (EXIT_FAILURE, 0,\n\t\t     _(\"Please specify a decimal number immediately after -O\"));\n\t    }\n\t  else if (*end)\n\t    {\n\t      /* unwanted trailing characters. */\n\t      error (EXIT_FAILURE, 0, _(\"Invalid optimisation level %s\"), arg);\n\t    }\n\t  else if ( (ULONG_MAX==opt_level) && errno)\n\t    {\n\t      error (EXIT_FAILURE, errno,\n\t\t     _(\"Invalid optimisation level %s\"), arg);\n\t    }\n\t  else if (opt_level > USHRT_MAX)\n\t    {\n\t      /* tricky to test, as on some platforms USHORT_MAX and ULONG_MAX\n\t       * can have the same value, though this is unusual.\n\t       */\n\t      error (EXIT_FAILURE, 0,\n\t\t     _(\"Optimisation level %lu is too high.  \"\n\t\t       \"If you want to find files very quickly, \"\n\t\t       \"consider using GNU locate.\"),\n\t\t     opt_level);\n\t    }\n\t  else\n\t    {\n\t      options.optimisation_level = opt_level;\n\t      errno = prev_errno;\n\t    }\n\t}\n    }\n}",
      "lines": 58,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "process_leading_options": {
      "start_point": [
        902,
        0
      ],
      "end_point": [
        950,
        1
      ],
      "content": "int\nprocess_leading_options (int argc, char *argv[])\n{\n  int i, end_of_leading_options;\n\n  for (i=1; (end_of_leading_options = i) < argc; ++i)\n    {\n      if (0 == strcmp (\"-H\", argv[i]))\n\t{\n\t  /* Meaning: dereference symbolic links on command line, but nowhere else. */\n\t  set_follow_state (SYMLINK_DEREF_ARGSONLY);\n\t}\n      else if (0 == strcmp (\"-L\", argv[i]))\n\t{\n\t  /* Meaning: dereference all symbolic links. */\n\t  set_follow_state (SYMLINK_ALWAYS_DEREF);\n\t}\n      else if (0 == strcmp (\"-P\", argv[i]))\n\t{\n\t  /* Meaning: never dereference symbolic links (default). */\n\t  set_follow_state (SYMLINK_NEVER_DEREF);\n\t}\n      else if (0 == strcmp (\"--\", argv[i]))\n\t{\n\t  /* -- signifies the end of options. */\n\t  end_of_leading_options = i+1;\t/* Next time start with the next option */\n\t  break;\n\t}\n      else if (0 == strcmp (\"-D\", argv[i]))\n\t{\n\t  process_debug_options (argv[i+1]);\n\t  ++i;\t\t\t/* skip the argument too. */\n\t}\n      else if (0 == strncmp (\"-O\", argv[i], 2))\n\t{\n\t  process_optimisation_option (argv[i]+2);\n\t}\n      else\n\t{\n\t  /* Hmm, must be one of\n\t   * (a) A path name\n\t   * (b) A predicate\n\t   */\n\t  end_of_leading_options = i; /* Next time start with this option */\n\t  break;\n\t}\n    }\n  return end_of_leading_options;\n}",
      "lines": 49,
      "depth": 17,
      "decorators": [
        "int"
      ]
    },
    "now": {
      "start_point": [
        952,
        0
      ],
      "end_point": [
        970,
        1
      ],
      "content": "static struct timespec\nnow(void)\n{\n  struct timespec retval;\n  struct timeval tv;\n  time_t t;\n\n  if (0 == gettimeofday (&tv, NULL))\n    {\n      retval.tv_sec  = tv.tv_sec;\n      retval.tv_nsec = tv.tv_usec * 1000; /* convert unit from microseconds to nanoseconds */\n      return retval;\n    }\n  t = time (NULL);\n  assert (t != (time_t)-1);\n  retval.tv_sec = t;\n  retval.tv_nsec = 0;\n  return retval;\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "struct timespec",
        "struct",
        "timespec"
      ]
    },
    "set_option_defaults": {
      "start_point": [
        972,
        0
      ],
      "end_point": [
        1046,
        1
      ],
      "content": "void\nset_option_defaults (struct options *p)\n{\n  if (getenv (\"POSIXLY_CORRECT\"))\n    p->posixly_correct = true;\n  else\n    p->posixly_correct = false;\n\n  /* We call check_nofollow() before setlocale() because the numbers\n   * for which we check (in the results of uname) definitiely have \".\"\n   * as the decimal point indicator even under locales for which that\n   * is not normally true.   Hence atof would do the wrong thing\n   * if we call it after setlocale().\n   */\n#ifdef O_NOFOLLOW\n  p->open_nofollow_available = check_nofollow ();\n#else\n  p->open_nofollow_available = false;\n#endif\n\n  p->regex_options = RE_SYNTAX_EMACS;\n\n  if (isatty (0))\n    {\n      p->warnings = true;\n      p->literal_control_chars = false;\n    }\n  else\n    {\n      p->warnings = false;\n      p->literal_control_chars = false; /* may change */\n    }\n  if (p->posixly_correct)\n    {\n      p->warnings = false;\n    }\n\n  p->do_dir_first = true;\n  p->explicit_depth = false;\n  p->maxdepth = p->mindepth = -1;\n\n  p->start_time = now ();\n  p->cur_day_start.tv_sec = p->start_time.tv_sec - DAYSECS;\n  p->cur_day_start.tv_nsec = p->start_time.tv_nsec;\n\n  p->full_days = false;\n  p->stay_on_filesystem = false;\n  p->ignore_readdir_race = false;\n\n  if (p->posixly_correct)\n    p->output_block_size = 512;\n  else\n    p->output_block_size = 1024;\n\n  p->debug_options = 0uL;\n  p->optimisation_level = 2;\n\n  if (getenv (\"FIND_BLOCK_SIZE\"))\n    {\n      error (EXIT_FAILURE, 0,\n\t     _(\"The environment variable FIND_BLOCK_SIZE is not supported, the only thing that affects the block size is the POSIXLY_CORRECT environment variable\"));\n    }\n\n#if LEAF_OPTIMISATION\n  /* The leaf optimisation is enabled. */\n  p->no_leaf_check = false;\n#else\n  /* The leaf optimisation is disabled. */\n  p->no_leaf_check = true;\n#endif\n\n  set_follow_state (SYMLINK_NEVER_DEREF); /* The default is equivalent to -P. */\n\n  p->err_quoting_style = locale_quoting_style;\n}",
      "lines": 75,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "apply_predicate": {
      "start_point": [
        1052,
        0
      ],
      "end_point": [
        1072,
        1
      ],
      "content": "bool\napply_predicate(const char *pathname, struct stat *stat_buf, struct predicate *p)\n{\n  ++p->perf.visits;\n\n  if (p->need_stat || p->need_type || p->need_inum)\n    {\n      /* We may need a stat here. */\n      if (get_info(pathname, stat_buf, p) != 0)\n\t    return false;\n    }\n  if ((p->pred_func)(pathname, stat_buf, p))\n    {\n      ++(p->perf.successes);\n      return true;\n    }\n  else\n    {\n      return false;\n    }\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "bool"
      ]
    },
    "is_exec_in_local_dir": {
      "start_point": [
        1078,
        0
      ],
      "end_point": [
        1082,
        1
      ],
      "content": "bool\nis_exec_in_local_dir (const PRED_FUNC pred_func)\n{\n  return pred_execdir == pred_func || pred_okdir == pred_func;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "bool"
      ]
    },
    "safely_quote_err_filename": {
      "start_point": [
        1087,
        0
      ],
      "end_point": [
        1091,
        1
      ],
      "content": "const char *\nsafely_quote_err_filename (int n, char const *arg)\n{\n  return quotearg_n_style (n, options.err_quoting_style, arg);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nsafely_quote_err_filename (int n, char const *arg)",
        "*"
      ]
    },
    "error_severity": {
      "start_point": [
        1098,
        0
      ],
      "end_point": [
        1103,
        1
      ],
      "content": "void\nerror_severity (int level)\n{\n  if (state.exit_status < level)\n    state.exit_status = level;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "report_file_err": {
      "start_point": [
        1108,
        0
      ],
      "end_point": [
        1125,
        1
      ],
      "content": "static void\nreport_file_err(int exitval, int errno_value,\n\t\tbool is_target_file, const char *name)\n{\n  /* It is important that the errno value is passed in as a function\n   * argument before we call safely_quote_err_filename(), because otherwise\n   * we might find that safely_quote_err_filename() changes errno.\n   */\n  if (!is_target_file || !state.already_issued_stat_error_msg)\n    {\n      error (exitval, errno_value, \"%s\", safely_quote_err_filename (0, name));\n      error_severity (1);\n    }\n  if (is_target_file)\n    {\n      state.already_issued_stat_error_msg = true;\n    }\n}",
      "lines": 18,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "nonfatal_target_file_error": {
      "start_point": [
        1129,
        0
      ],
      "end_point": [
        1133,
        1
      ],
      "content": "void\nnonfatal_target_file_error (int errno_value, const char *name)\n{\n  report_file_err (0, errno_value, true, name);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "fatal_target_file_error": {
      "start_point": [
        1141,
        0
      ],
      "end_point": [
        1147,
        1
      ],
      "content": "void\nfatal_target_file_error(int errno_value, const char *name)\n{\n  report_file_err (1, errno_value, true, name);\n  /*NOTREACHED*/\n  abort ();\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "nonfatal_nontarget_file_error": {
      "start_point": [
        1152,
        0
      ],
      "end_point": [
        1156,
        1
      ],
      "content": "void\nnonfatal_nontarget_file_error (int errno_value, const char *name)\n{\n  report_file_err (0, errno_value, false, name);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "fatal_nontarget_file_error": {
      "start_point": [
        1161,
        0
      ],
      "end_point": [
        1172,
        1
      ],
      "content": "void\nfatal_nontarget_file_error(int errno_value, const char *name)\n{\n  /* We're going to exit fatally, so make sure we always isssue the error\n   * message, even if it will be duplicate.   Motivation: otherwise it may\n   * not be clear what went wrong.\n   */\n  state.already_issued_stat_error_msg = false;\n  report_file_err (1, errno_value, false, name);\n  /*NOTREACHED*/\n  abort ();\n}",
      "lines": 12,
      "depth": 6,
      "decorators": [
        "void"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/alloca.c": {
    "find_stack_direction": {
      "start_point": [
        95,
        0
      ],
      "end_point": [
        104,
        1
      ],
      "content": "static int\nfind_stack_direction (int *addr, int depth)\n{\n  int dir, dummy = 0;\n  if (! addr)\n    addr = &dummy;\n  *addr = addr < &dummy ? 1 : addr == &dummy ? 0 : -1;\n  dir = depth ? find_stack_direction (addr, depth - 1) : 0;\n  return dir + dummy;\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "alloca": {
      "start_point": [
        138,
        0
      ],
      "end_point": [
        206,
        1
      ],
      "content": "void *\nalloca (size_t size)\n{\n  auto char probe;              /* Probes stack depth: */\n  register char *depth = ADDRESS_FUNCTION (probe);\n\n#  if STACK_DIRECTION == 0\n  if (STACK_DIR == 0)           /* Unknown growth direction.  */\n    STACK_DIR = find_stack_direction (NULL, (size & 1) + 20);\n#  endif\n\n  /* Reclaim garbage, defined as all alloca'd storage that\n     was allocated from deeper in the stack than currently.  */\n\n  {\n    register header *hp;        /* Traverses linked list.  */\n\n#  ifdef emacs\n    BLOCK_INPUT;\n#  endif\n\n    for (hp = last_alloca_header; hp != NULL;)\n      if ((STACK_DIR > 0 && hp->h.deep > depth)\n          || (STACK_DIR < 0 && hp->h.deep < depth))\n        {\n          register header *np = hp->h.next;\n\n          free (hp);            /* Collect garbage.  */\n\n          hp = np;              /* -> next header.  */\n        }\n      else\n        break;                  /* Rest are not deeper.  */\n\n    last_alloca_header = hp;    /* -> last valid storage.  */\n\n#  ifdef emacs\n    UNBLOCK_INPUT;\n#  endif\n  }\n\n  if (size == 0)\n    return NULL;                /* No allocation required.  */\n\n  /* Allocate combined header + user data storage.  */\n\n  {\n    /* Address of header.  */\n    register header *new;\n\n    size_t combined_size = sizeof (header) + size;\n    if (combined_size < sizeof (header))\n      memory_full ();\n\n    new = malloc (combined_size);\n\n    if (! new)\n      memory_full ();\n\n    new->h.next = last_alloca_header;\n    new->h.deep = depth;\n\n    last_alloca_header = new;\n\n    /* User storage begins just after header.  */\n\n    return (void *) (new + 1);\n  }\n}",
      "lines": 69,
      "depth": 13,
      "decorators": [
        "void",
        "*\nalloca (size_t size)",
        "*"
      ]
    },
    "i00afunc": [
      {
        "start_point": [
          328,
          0
        ],
        "end_point": [
          393,
          1
        ],
        "content": "static long\ni00afunc (long *address)\n{\n  struct stk_stat status;\n  struct stk_trailer *trailer;\n  long *block, size;\n  long result = 0;\n\n  /* We want to iterate through all of the segments.  The first\n     step is to get the stack status structure.  We could do this\n     more quickly and more directly, perhaps, by referencing the\n     $LM00 common block, but I know that this works.  */\n\n  STKSTAT (&status);\n\n  /* Set up the iteration.  */\n\n  trailer = (struct stk_trailer *) (status.current_address\n                                    + status.current_size\n                                    - 15);\n\n  /* There must be at least one stack segment.  Therefore it is\n     a fatal error if \"trailer\" is null.  */\n\n  if (trailer == 0)\n    abort ();\n\n  /* Discard segments that do not contain our argument address.  */\n\n  while (trailer != 0)\n    {\n      block = (long *) trailer->this_address;\n      size = trailer->this_size;\n      if (block == 0 || size == 0)\n        abort ();\n      trailer = (struct stk_trailer *) trailer->link;\n      if ((block <= address) && (address < (block + size)))\n        break;\n    }\n\n  /* Set the result to the offset in this segment and add the sizes\n     of all predecessor segments.  */\n\n  result = address - block;\n\n  if (trailer == 0)\n    {\n      return result;\n    }\n\n  do\n    {\n      if (trailer->this_size <= 0)\n        abort ();\n      result += trailer->this_size;\n      trailer = (struct stk_trailer *) trailer->link;\n    }\n  while (trailer != 0);\n\n  /* We are done.  Note that if you present a bogus address (one\n     not in any segment), you will get a different number back, formed\n     from subtracting the address of the first block.  This is probably\n     not what you want.  */\n\n  return (result);\n}",
        "lines": 66,
        "depth": 12,
        "decorators": [
          "static",
          "static",
          "long",
          "long"
        ]
      },
      {
        "start_point": [
          402,
          0
        ],
        "end_point": [
          471,
          1
        ],
        "content": "static long\ni00afunc (long address)\n{\n  long stkl = 0;\n\n  long size, pseg, this_segment, stack;\n  long result = 0;\n\n  struct stack_segment_linkage *ssptr;\n\n  /* Register B67 contains the address of the end of the\n     current stack segment.  If you (as a subprogram) store\n     your registers on the stack and find that you are past\n     the contents of B67, you have overflowed the segment.\n\n     B67 also points to the stack segment linkage control\n     area, which is what we are really interested in.  */\n\n  stkl = CRAY_STACKSEG_END ();\n  ssptr = (struct stack_segment_linkage *) stkl;\n\n  /* If one subtracts 'size' from the end of the segment,\n     one has the address of the first word of the segment.\n\n     If this is not the first segment, 'pseg' will be\n     nonzero.  */\n\n  pseg = ssptr->sspseg;\n  size = ssptr->sssize;\n\n  this_segment = stkl - size;\n\n  /* It is possible that calling this routine itself caused\n     a stack overflow.  Discard stack segments which do not\n     contain the target address.  */\n\n  while (!(this_segment <= address && address <= stkl))\n    {\n#    ifdef DEBUG_I00AFUNC\n      fprintf (stderr, \"%011o %011o %011o\\n\", this_segment, address, stkl);\n#    endif\n      if (pseg == 0)\n        break;\n      stkl = stkl - pseg;\n      ssptr = (struct stack_segment_linkage *) stkl;\n      size = ssptr->sssize;\n      pseg = ssptr->sspseg;\n      this_segment = stkl - size;\n    }\n\n  result = address - this_segment;\n\n  /* If you subtract pseg from the current end of the stack,\n     you get the address of the previous stack segment's end.\n     This seems a little convoluted to me, but I'll bet you save\n     a cycle somewhere.  */\n\n  while (pseg != 0)\n    {\n#    ifdef DEBUG_I00AFUNC\n      fprintf (stderr, \"%011o %011o\\n\", pseg, size);\n#    endif\n      stkl = stkl - pseg;\n      ssptr = (struct stack_segment_linkage *) stkl;\n      size = ssptr->sssize;\n      pseg = ssptr->sspseg;\n      result += size;\n    }\n  return (result);\n}",
        "lines": 70,
        "depth": 10,
        "decorators": [
          "static",
          "static",
          "long",
          "long"
        ]
      }
    ]
  },
  "findutils/findutils-4.6.0/gl/lib/alloca.in.h": {},
  "findutils/findutils-4.6.0/gl/lib/allocator.c": {},
  "findutils/findutils-4.6.0/gl/lib/allocator.h": {},
  "findutils/findutils-4.6.0/gl/lib/areadlink-with-size.c": {
    "areadlink_with_size": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "char *\nareadlink_with_size (char const *file, size_t size)\n{\n  /* Some buggy file systems report garbage in st_size.  Defend\n     against them by ignoring outlandish st_size values in the initial\n     memory allocation.  */\n  size_t symlink_max = SYMLINK_MAX;\n  size_t INITIAL_LIMIT_BOUND = 8 * 1024;\n  size_t initial_limit = (symlink_max < INITIAL_LIMIT_BOUND\n                          ? symlink_max + 1\n                          : INITIAL_LIMIT_BOUND);\n\n  /* The initial buffer size for the link value.  */\n  size_t buf_size = size < initial_limit ? size + 1 : initial_limit;\n\n  while (1)\n    {\n      ssize_t r;\n      size_t link_length;\n      char *buffer = malloc (buf_size);\n\n      if (buffer == NULL)\n        return NULL;\n      r = readlink (file, buffer, buf_size);\n      link_length = r;\n\n      /* On AIX 5L v5.3 and HP-UX 11i v2 04/09, readlink returns -1\n         with errno == ERANGE if the buffer is too small.  */\n      if (r < 0 && errno != ERANGE)\n        {\n          int saved_errno = errno;\n          free (buffer);\n          errno = saved_errno;\n          return NULL;\n        }\n\n      if (link_length < buf_size)\n        {\n          buffer[link_length] = 0;\n          return buffer;\n        }\n\n      free (buffer);\n      if (buf_size <= MAXSIZE / 2)\n        buf_size *= 2;\n      else if (buf_size < MAXSIZE)\n        buf_size = MAXSIZE;\n      else\n        {\n          errno = ENOMEM;\n          return NULL;\n        }\n    }\n}",
      "lines": 54,
      "depth": 10,
      "decorators": [
        "char",
        "*\nareadlink_with_size (char const *file, size_t size)",
        "*"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/areadlink.c": {
    "careadlinkatcwd": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "static ssize_t\ncareadlinkatcwd (int fd, char const *filename, char *buffer,\n                 size_t buffer_size)\n{\n  /* FD must be AT_FDCWD here, otherwise the caller is using this\n     function in contexts it was not meant for.  */\n  if (fd != AT_FDCWD)\n    abort ();\n  return readlink (filename, buffer, buffer_size);\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "ssize_t"
      ]
    },
    "areadlink": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "char *\nareadlink (char const *filename)\n{\n  return careadlinkat (AT_FDCWD, filename, NULL, 0, NULL, careadlinkatcwd);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nareadlink (char const *filename)",
        "*"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/areadlink.h": {},
  "findutils/findutils-4.6.0/gl/lib/areadlinkat.c": {
    "areadlinkat": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        42,
        1
      ],
      "content": "char *\nareadlinkat (int fd, char const *filename)\n{\n  return careadlinkat (fd, filename, NULL, 0, NULL, readlinkat);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nareadlinkat (int fd, char const *filename)",
        "*"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/argmatch.c": {
    "__argmatch_die": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        63,
        1
      ],
      "content": "static void\n__argmatch_die (void)\n{\n  ARGMATCH_DIE;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "argmatch": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "ptrdiff_t\nargmatch (const char *arg, const char *const *arglist,\n          const char *vallist, size_t valsize)\n{\n  size_t i;                     /* Temporary index in ARGLIST.  */\n  size_t arglen;                /* Length of ARG.  */\n  ptrdiff_t matchind = -1;      /* Index of first nonexact match.  */\n  bool ambiguous = false;       /* If true, multiple nonexact match(es).  */\n\n  arglen = strlen (arg);\n\n  /* Test all elements for either exact match or abbreviated matches.  */\n  for (i = 0; arglist[i]; i++)\n    {\n      if (!strncmp (arglist[i], arg, arglen))\n        {\n          if (strlen (arglist[i]) == arglen)\n            /* Exact match found.  */\n            return i;\n          else if (matchind == -1)\n            /* First nonexact match found.  */\n            matchind = i;\n          else\n            {\n              /* Second nonexact match found.  */\n              if (vallist == NULL\n                  || memcmp (vallist + valsize * matchind,\n                             vallist + valsize * i, valsize))\n                {\n                  /* There is a real ambiguity, or we could not\n                     disambiguate. */\n                  ambiguous = true;\n                }\n            }\n        }\n    }\n  if (ambiguous)\n    return -2;\n  else\n    return matchind;\n}",
      "lines": 41,
      "depth": 17,
      "decorators": [
        "ptrdiff_t"
      ]
    },
    "argmatch_invalid": {
      "start_point": [
        128,
        0
      ],
      "end_point": [
        137,
        1
      ],
      "content": "void\nargmatch_invalid (const char *context, const char *value, ptrdiff_t problem)\n{\n  char const *format = (problem == -1\n                        ? _(\"invalid argument %s for %s\")\n                        : _(\"ambiguous argument %s for %s\"));\n\n  error (0, 0, format, quotearg_n_style (0, ARGMATCH_QUOTING_STYLE, value),\n         quote_n (1, context));\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "argmatch_valid": {
      "start_point": [
        143,
        0
      ],
      "end_point": [
        165,
        1
      ],
      "content": "void\nargmatch_valid (const char *const *arglist,\n                const char *vallist, size_t valsize)\n{\n  size_t i;\n  const char *last_val = NULL;\n\n  /* We try to put synonyms on the same line.  The assumption is that\n     synonyms follow each other */\n  fputs (_(\"Valid arguments are:\"), stderr);\n  for (i = 0; arglist[i]; i++)\n    if ((i == 0)\n        || memcmp (last_val, vallist + valsize * i, valsize))\n      {\n        fprintf (stderr, \"\\n  - %s\", quote (arglist[i]));\n        last_val = vallist + valsize * i;\n      }\n    else\n      {\n        fprintf (stderr, \", %s\", quote (arglist[i]));\n      }\n  putc ('\\n', stderr);\n}",
      "lines": 23,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "__xargmatch_internal": {
      "start_point": [
        173,
        0
      ],
      "end_point": [
        190,
        1
      ],
      "content": "ptrdiff_t\n__xargmatch_internal (const char *context,\n                      const char *arg, const char *const *arglist,\n                      const char *vallist, size_t valsize,\n                      argmatch_exit_fn exit_fn)\n{\n  ptrdiff_t res = argmatch (arg, arglist, vallist, valsize);\n  if (res >= 0)\n    /* Success. */\n    return res;\n\n  /* We failed.  Explain why. */\n  argmatch_invalid (context, arg, res);\n  argmatch_valid (arglist, vallist, valsize);\n  (*exit_fn) ();\n\n  return -1; /* To please the compilers. */\n}",
      "lines": 18,
      "depth": 7,
      "decorators": [
        "ptrdiff_t"
      ]
    },
    "argmatch_to_argument": {
      "start_point": [
        194,
        0
      ],
      "end_point": [
        205,
        1
      ],
      "content": "const char *\nargmatch_to_argument (const char *value,\n                      const char *const *arglist,\n                      const char *vallist, size_t valsize)\n{\n  size_t i;\n\n  for (i = 0; arglist[i]; i++)\n    if (!memcmp (value, vallist + valsize * i, valsize))\n      return arglist[i];\n  return NULL;\n}",
      "lines": 12,
      "depth": 11,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nargmatch_to_argument (const char *value,\n                      const char *const *arglist,\n                      const char *vallist, size_t valsize)",
        "*"
      ]
    },
    "main": {
      "start_point": [
        249,
        0
      ],
      "end_point": [
        275,
        1
      ],
      "content": "int\nmain (int argc, const char *const *argv)\n{\n  const char *cp;\n  enum backup_type backup_type = no_backups;\n\n  program_name = (char *) argv[0];\n\n  if (argc > 2)\n    {\n      fprintf (stderr, \"Usage: %s [VERSION_CONTROL]\\n\", program_name);\n      exit (1);\n    }\n\n  if ((cp = getenv (\"VERSION_CONTROL\")))\n    backup_type = XARGMATCH (\"$VERSION_CONTROL\", cp,\n                             backup_args, backup_vals);\n\n  if (argc == 2)\n    backup_type = XARGMATCH (program_name, argv[1],\n                             backup_args, backup_vals);\n\n  printf (\"The version control is '%s'\\n\",\n          ARGMATCH_TO_ARGUMENT (backup_type, backup_args, backup_vals));\n\n  return 0;\n}",
      "lines": 27,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/argmatch.h": {},
  "findutils/findutils-4.6.0/gl/lib/asnprintf.c": {
    "asnprintf": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        33,
        1
      ],
      "content": "char *\nasnprintf (char *resultbuf, size_t *lengthp, const char *format, ...)\n{\n  va_list args;\n  char *result;\n\n  va_start (args, format);\n  result = vasnprintf (resultbuf, lengthp, format, args);\n  va_end (args);\n  return result;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "char",
        "*\nasnprintf (char *resultbuf, size_t *lengthp, const char *format, ...)",
        "*"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/assure.h": {},
  "findutils/findutils-4.6.0/gl/lib/at-func.c": {
    "AT_FUNC_NAME": {
      "start_point": [
        68,
        0
      ],
      "end_point": [
        142,
        1
      ],
      "content": "FUNC_RESULT\nAT_FUNC_NAME (int fd, char const *file AT_FUNC_POST_FILE_PARAM_DECLS)\n{\n  VALIDATE_FLAG (flag);\n\n  if (fd == AT_FDCWD || IS_ABSOLUTE_FILE_NAME (file))\n    return CALL_FUNC (file);\n\n#ifdef GNULIB_SUPPORT_ONLY_AT_FDCWD\n  errno = ENOTSUP;\n  return FUNC_FAIL;\n#else\n  {\n  /* Be careful to choose names unlikely to conflict with\n     AT_FUNC_POST_FILE_PARAM_DECLS.  */\n  struct saved_cwd saved_cwd;\n  int saved_errno;\n  FUNC_RESULT err;\n\n  {\n    char proc_buf[OPENAT_BUFFER_SIZE];\n    char *proc_file = openat_proc_name (proc_buf, fd, file);\n    if (proc_file)\n      {\n        FUNC_RESULT proc_result = CALL_FUNC (proc_file);\n        int proc_errno = errno;\n        if (proc_file != proc_buf)\n          free (proc_file);\n        /* If the syscall succeeds, or if it fails with an unexpected\n           errno value, then return right away.  Otherwise, fall through\n           and resort to using save_cwd/restore_cwd.  */\n        if (FUNC_FAIL != proc_result)\n          return proc_result;\n        if (! EXPECTED_ERRNO (proc_errno))\n          {\n            errno = proc_errno;\n            return proc_result;\n          }\n      }\n  }\n\n  if (save_cwd (&saved_cwd) != 0)\n    openat_save_fail (errno);\n  if (0 <= fd && fd == saved_cwd.desc)\n    {\n      /* If saving the working directory collides with the user's\n         requested fd, then the user's fd must have been closed to\n         begin with.  */\n      free_cwd (&saved_cwd);\n      errno = EBADF;\n      return FUNC_FAIL;\n    }\n\n  if (fchdir (fd) != 0)\n    {\n      saved_errno = errno;\n      free_cwd (&saved_cwd);\n      errno = saved_errno;\n      return FUNC_FAIL;\n    }\n\n  err = CALL_FUNC (file);\n  saved_errno = (err == FUNC_FAIL ? errno : 0);\n\n  if (restore_cwd (&saved_cwd) != 0)\n    openat_restore_fail (errno);\n\n  free_cwd (&saved_cwd);\n\n  if (saved_errno)\n    errno = saved_errno;\n  return err;\n  }\n#endif\n}",
      "lines": 75,
      "depth": 14,
      "decorators": [
        "FUNC_RESULT"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/basename-lgpl.c": {
    "last_component": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "char *\nlast_component (char const *name)\n{\n  char const *base = name + FILE_SYSTEM_PREFIX_LEN (name);\n  char const *p;\n  bool saw_slash = false;\n\n  while (ISSLASH (*base))\n    base++;\n\n  for (p = base; *p; p++)\n    {\n      if (ISSLASH (*p))\n        saw_slash = true;\n      else if (saw_slash)\n        {\n          base = p;\n          saw_slash = false;\n        }\n    }\n\n  return (char *) base;\n}",
      "lines": 23,
      "depth": 10,
      "decorators": [
        "char",
        "*\nlast_component (char const *name)",
        "*"
      ]
    },
    "base_len": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "size_t\nbase_len (char const *name)\n{\n  size_t len;\n  size_t prefix_len = FILE_SYSTEM_PREFIX_LEN (name);\n\n  for (len = strlen (name);  1 < len && ISSLASH (name[len - 1]);  len--)\n    continue;\n\n  if (DOUBLE_SLASH_IS_DISTINCT_ROOT && len == 1\n      && ISSLASH (name[0]) && ISSLASH (name[1]) && ! name[2])\n    return 2;\n\n  if (FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE && prefix_len\n      && len == prefix_len && ISSLASH (name[prefix_len]))\n    return prefix_len + 1;\n\n  return len;\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "size_t"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/basename.c": {
    "base_name": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "char *\nbase_name (char const *name)\n{\n  char const *base = last_component (name);\n  size_t length;\n\n  /* If there is no last component, then name is a file system root or the\n     empty string.  */\n  if (! *base)\n    return xstrndup (name, base_len (name));\n\n  /* Collapse a sequence of trailing slashes into one.  */\n  length = base_len (base);\n  if (ISSLASH (base[length]))\n    length++;\n\n  /* On systems with drive letters, \"a/b:c\" must return \"./b:c\" rather\n     than \"b:c\" to avoid confusion with a drive letter.  On systems\n     with pure POSIX semantics, this is not an issue.  */\n  if (FILE_SYSTEM_PREFIX_LEN (base))\n    {\n      char *p = xmalloc (length + 3);\n      p[0] = '.';\n      p[1] = '/';\n      memcpy (p + 2, base, length);\n      p[length + 2] = '\\0';\n      return p;\n    }\n\n  /* Finally, copy the basename.  */\n  return xstrndup (base, length);\n}",
      "lines": 32,
      "depth": 10,
      "decorators": [
        "char",
        "*\nbase_name (char const *name)",
        "*"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/bitrotate.c": {},
  "findutils/findutils-4.6.0/gl/lib/bitrotate.h": {
    "uint64_t": [
      {
        "start_point": [
          37,
          0
        ],
        "end_point": [
          41,
          1
        ],
        "content": "BITROTATE_INLINE uint64_t\nrotl64 (uint64_t x, int n)\n{\n  return ((x << n) | (x >> (64 - n))) & UINT64_MAX;\n}",
        "lines": 5,
        "depth": 11,
        "decorators": [
          "BITROTATE_INLINE"
        ]
      },
      {
        "start_point": [
          46,
          0
        ],
        "end_point": [
          50,
          1
        ],
        "content": "BITROTATE_INLINE uint64_t\nrotr64 (uint64_t x, int n)\n{\n  return ((x >> n) | (x << (64 - n))) & UINT64_MAX;\n}",
        "lines": 5,
        "depth": 11,
        "decorators": [
          "BITROTATE_INLINE"
        ]
      }
    ],
    "uint32_t": [
      {
        "start_point": [
          56,
          0
        ],
        "end_point": [
          60,
          1
        ],
        "content": "BITROTATE_INLINE uint32_t\nrotl32 (uint32_t x, int n)\n{\n  return ((x << n) | (x >> (32 - n))) & UINT32_MAX;\n}",
        "lines": 5,
        "depth": 11,
        "decorators": [
          "BITROTATE_INLINE"
        ]
      },
      {
        "start_point": [
          65,
          0
        ],
        "end_point": [
          69,
          1
        ],
        "content": "BITROTATE_INLINE uint32_t\nrotr32 (uint32_t x, int n)\n{\n  return ((x >> n) | (x << (32 - n))) & UINT32_MAX;\n}",
        "lines": 5,
        "depth": 11,
        "decorators": [
          "BITROTATE_INLINE"
        ]
      }
    ],
    "rotl_sz": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "BITROTATE_INLINE size_t\nrotl_sz (size_t x, int n)\n{\n  return ((x << n) | (x >> ((CHAR_BIT * sizeof x) - n))) & SIZE_MAX;\n}",
      "lines": 5,
      "depth": 14,
      "decorators": [
        "BITROTATE_INLINE",
        "size_t",
        "size_t"
      ]
    },
    "rotr_sz": {
      "start_point": [
        83,
        0
      ],
      "end_point": [
        87,
        1
      ],
      "content": "BITROTATE_INLINE size_t\nrotr_sz (size_t x, int n)\n{\n  return ((x >> n) | (x << ((CHAR_BIT * sizeof x) - n))) & SIZE_MAX;\n}",
      "lines": 5,
      "depth": 14,
      "decorators": [
        "BITROTATE_INLINE",
        "size_t",
        "size_t"
      ]
    },
    "uint16_t": [
      {
        "start_point": [
          94,
          0
        ],
        "end_point": [
          98,
          1
        ],
        "content": "BITROTATE_INLINE uint16_t\nrotl16 (uint16_t x, int n)\n{\n  return ((x << n) | (x >> (16 - n))) & UINT16_MAX;\n}",
        "lines": 5,
        "depth": 11,
        "decorators": [
          "BITROTATE_INLINE"
        ]
      },
      {
        "start_point": [
          105,
          0
        ],
        "end_point": [
          109,
          1
        ],
        "content": "BITROTATE_INLINE uint16_t\nrotr16 (uint16_t x, int n)\n{\n  return ((x >> n) | (x << (16 - n))) & UINT16_MAX;\n}",
        "lines": 5,
        "depth": 11,
        "decorators": [
          "BITROTATE_INLINE"
        ]
      }
    ],
    "uint8_t": [
      {
        "start_point": [
          116,
          0
        ],
        "end_point": [
          120,
          1
        ],
        "content": "BITROTATE_INLINE uint8_t\nrotl8 (uint8_t x, int n)\n{\n  return ((x << n) | (x >> (8 - n))) & UINT8_MAX;\n}",
        "lines": 5,
        "depth": 11,
        "decorators": [
          "BITROTATE_INLINE"
        ]
      },
      {
        "start_point": [
          127,
          0
        ],
        "end_point": [
          131,
          1
        ],
        "content": "BITROTATE_INLINE uint8_t\nrotr8 (uint8_t x, int n)\n{\n  return ((x >> n) | (x << (8 - n))) & UINT8_MAX;\n}",
        "lines": 5,
        "depth": 11,
        "decorators": [
          "BITROTATE_INLINE"
        ]
      }
    ]
  },
  "findutils/findutils-4.6.0/gl/lib/btowc.c": {
    "btowc": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "wint_t\nbtowc (int c)\n{\n  if (c != EOF)\n    {\n      char buf[1];\n      wchar_t wc;\n\n      buf[0] = c;\n      if (mbtowc (&wc, buf, 1) >= 0)\n        return wc;\n    }\n  return WEOF;\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "wint_t"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/byteswap.in.h": {},
  "findutils/findutils-4.6.0/gl/lib/c-ctype.c": {},
  "findutils/findutils-4.6.0/gl/lib/c-ctype.h": {
    "c_isalnum": {
      "start_point": [
        167,
        0
      ],
      "end_point": [
        179,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_isalnum (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_DIGIT:\n    _C_CTYPE_LOWER:\n    _C_CTYPE_UPPER:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_isalpha": {
      "start_point": [
        181,
        0
      ],
      "end_point": [
        192,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_isalpha (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_LOWER:\n    _C_CTYPE_UPPER:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_isascii": {
      "start_point": [
        196,
        0
      ],
      "end_point": [
        211,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_isascii (int c)\n{\n  switch (c)\n    {\n    case ' ':\n    _C_CTYPE_CNTRL:\n    _C_CTYPE_DIGIT:\n    _C_CTYPE_LOWER:\n    _C_CTYPE_PUNCT:\n    _C_CTYPE_UPPER:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 16,
      "depth": 12,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_isblank": {
      "start_point": [
        213,
        0
      ],
      "end_point": [
        217,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_isblank (int c)\n{\n  return c == ' ' || c == '\\t';\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_iscntrl": {
      "start_point": [
        219,
        0
      ],
      "end_point": [
        229,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_iscntrl (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_CNTRL:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_isdigit": {
      "start_point": [
        231,
        0
      ],
      "end_point": [
        241,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_isdigit (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_DIGIT:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_isgraph": {
      "start_point": [
        243,
        0
      ],
      "end_point": [
        256,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_isgraph (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_DIGIT:\n    _C_CTYPE_LOWER:\n    _C_CTYPE_PUNCT:\n    _C_CTYPE_UPPER:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_islower": {
      "start_point": [
        258,
        0
      ],
      "end_point": [
        268,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_islower (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_LOWER:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_isprint": {
      "start_point": [
        270,
        0
      ],
      "end_point": [
        284,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_isprint (int c)\n{\n  switch (c)\n    {\n    case ' ':\n    _C_CTYPE_DIGIT:\n    _C_CTYPE_LOWER:\n    _C_CTYPE_PUNCT:\n    _C_CTYPE_UPPER:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_ispunct": {
      "start_point": [
        286,
        0
      ],
      "end_point": [
        296,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_ispunct (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_PUNCT:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_isspace": {
      "start_point": [
        298,
        0
      ],
      "end_point": [
        308,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_isspace (int c)\n{\n  switch (c)\n    {\n    case ' ': case '\\t': case '\\n': case '\\v': case '\\f': case '\\r':\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_isupper": {
      "start_point": [
        310,
        0
      ],
      "end_point": [
        320,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_isupper (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_UPPER:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_isxdigit": {
      "start_point": [
        322,
        0
      ],
      "end_point": [
        333,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_isxdigit (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_DIGIT:\n    _C_CTYPE_A_THRU_F:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_tolower": {
      "start_point": [
        335,
        0
      ],
      "end_point": [
        345,
        1
      ],
      "content": "C_CTYPE_INLINE int\nc_tolower (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_UPPER:\n      return c - 'A' + 'a';\n    default:\n      return c;\n    }\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "C_CTYPE_INLINE",
        "int",
        "int"
      ]
    },
    "c_toupper": {
      "start_point": [
        347,
        0
      ],
      "end_point": [
        357,
        1
      ],
      "content": "C_CTYPE_INLINE int\nc_toupper (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_LOWER:\n      return c - 'a' + 'A';\n    default:\n      return c;\n    }\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "C_CTYPE_INLINE",
        "int",
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/c-strcase.h": {},
  "findutils/findutils-4.6.0/gl/lib/c-strcasecmp.c": {
    "c_strcasecmp": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "int\nc_strcasecmp (const char *s1, const char *s2)\n{\n  register const unsigned char *p1 = (const unsigned char *) s1;\n  register const unsigned char *p2 = (const unsigned char *) s2;\n  unsigned char c1, c2;\n\n  if (p1 == p2)\n    return 0;\n\n  do\n    {\n      c1 = c_tolower (*p1);\n      c2 = c_tolower (*p2);\n\n      if (c1 == '\\0')\n        break;\n\n      ++p1;\n      ++p2;\n    }\n  while (c1 == c2);\n\n  if (UCHAR_MAX <= INT_MAX)\n    return c1 - c2;\n  else\n    /* On machines where 'char' and 'int' are types of the same size, the\n       difference of two 'unsigned char' values - including the sign bit -\n       doesn't fit in an 'int'.  */\n    return (c1 > c2 ? 1 : c1 < c2 ? -1 : 0);\n}",
      "lines": 31,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/c-strcaseeq.h": {
    "strcaseeq9": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "static inline int\nstrcaseeq9 (const char *s1, const char *s2)\n{\n  return c_strcasecmp (s1 + 9, s2 + 9) == 0;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq8": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "static inline int\nstrcaseeq8 (const char *s1, const char *s2, char s28)\n{\n  if (CASEEQ (s1[8], s28))\n    {\n      if (s28 == 0)\n        return 1;\n      else\n        return strcaseeq9 (s1, s2);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq7": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "static inline int\nstrcaseeq7 (const char *s1, const char *s2, char s27, char s28)\n{\n  if (CASEEQ (s1[7], s27))\n    {\n      if (s27 == 0)\n        return 1;\n      else\n        return strcaseeq8 (s1, s2, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq6": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "static inline int\nstrcaseeq6 (const char *s1, const char *s2, char s26, char s27, char s28)\n{\n  if (CASEEQ (s1[6], s26))\n    {\n      if (s26 == 0)\n        return 1;\n      else\n        return strcaseeq7 (s1, s2, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq5": {
      "start_point": [
        88,
        0
      ],
      "end_point": [
        100,
        1
      ],
      "content": "static inline int\nstrcaseeq5 (const char *s1, const char *s2, char s25, char s26, char s27, char s28)\n{\n  if (CASEEQ (s1[5], s25))\n    {\n      if (s25 == 0)\n        return 1;\n      else\n        return strcaseeq6 (s1, s2, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq4": {
      "start_point": [
        102,
        0
      ],
      "end_point": [
        114,
        1
      ],
      "content": "static inline int\nstrcaseeq4 (const char *s1, const char *s2, char s24, char s25, char s26, char s27, char s28)\n{\n  if (CASEEQ (s1[4], s24))\n    {\n      if (s24 == 0)\n        return 1;\n      else\n        return strcaseeq5 (s1, s2, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq3": {
      "start_point": [
        116,
        0
      ],
      "end_point": [
        128,
        1
      ],
      "content": "static inline int\nstrcaseeq3 (const char *s1, const char *s2, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (CASEEQ (s1[3], s23))\n    {\n      if (s23 == 0)\n        return 1;\n      else\n        return strcaseeq4 (s1, s2, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq2": {
      "start_point": [
        130,
        0
      ],
      "end_point": [
        142,
        1
      ],
      "content": "static inline int\nstrcaseeq2 (const char *s1, const char *s2, char s22, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (CASEEQ (s1[2], s22))\n    {\n      if (s22 == 0)\n        return 1;\n      else\n        return strcaseeq3 (s1, s2, s23, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq1": {
      "start_point": [
        144,
        0
      ],
      "end_point": [
        156,
        1
      ],
      "content": "static inline int\nstrcaseeq1 (const char *s1, const char *s2, char s21, char s22, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (CASEEQ (s1[1], s21))\n    {\n      if (s21 == 0)\n        return 1;\n      else\n        return strcaseeq2 (s1, s2, s22, s23, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq0": {
      "start_point": [
        158,
        0
      ],
      "end_point": [
        170,
        1
      ],
      "content": "static inline int\nstrcaseeq0 (const char *s1, const char *s2, char s20, char s21, char s22, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (CASEEQ (s1[0], s20))\n    {\n      if (s20 == 0)\n        return 1;\n      else\n        return strcaseeq1 (s1, s2, s21, s22, s23, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/c-strcasestr.c": {
    "c_strcasestr": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "char *\nc_strcasestr (const char *haystack_start, const char *needle_start)\n{\n  const char *haystack = haystack_start;\n  const char *needle = needle_start;\n  size_t needle_len; /* Length of NEEDLE.  */\n  size_t haystack_len; /* Known minimum length of HAYSTACK.  */\n  bool ok = true; /* True if NEEDLE is prefix of HAYSTACK.  */\n\n  /* Determine length of NEEDLE, and in the process, make sure\n     HAYSTACK is at least as long (no point processing all of a long\n     NEEDLE if HAYSTACK is too short).  */\n  while (*haystack && *needle)\n    ok &= (c_tolower ((unsigned char) *haystack++)\n           == c_tolower ((unsigned char) *needle++));\n  if (*needle)\n    return NULL;\n  if (ok)\n    return (char *) haystack_start;\n  needle_len = needle - needle_start;\n  haystack = haystack_start + 1;\n  haystack_len = needle_len - 1;\n\n  /* Perform the search.  Abstract memory is considered to be an array\n     of 'unsigned char' values, not an array of 'char' values.  See\n     ISO C 99 section 6.2.6.1.  */\n  if (needle_len < LONG_NEEDLE_THRESHOLD)\n    return two_way_short_needle ((const unsigned char *) haystack,\n                                 haystack_len,\n                                 (const unsigned char *) needle_start,\n                                 needle_len);\n  return two_way_long_needle ((const unsigned char *) haystack, haystack_len,\n                              (const unsigned char *) needle_start,\n                              needle_len);\n}",
      "lines": 35,
      "depth": 13,
      "decorators": [
        "char",
        "*\nc_strcasestr (const char *haystack_start, const char *needle_start)",
        "*"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/c-strcasestr.h": {},
  "findutils/findutils-4.6.0/gl/lib/c-strncasecmp.c": {
    "c_strncasecmp": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "int\nc_strncasecmp (const char *s1, const char *s2, size_t n)\n{\n  register const unsigned char *p1 = (const unsigned char *) s1;\n  register const unsigned char *p2 = (const unsigned char *) s2;\n  unsigned char c1, c2;\n\n  if (p1 == p2 || n == 0)\n    return 0;\n\n  do\n    {\n      c1 = c_tolower (*p1);\n      c2 = c_tolower (*p2);\n\n      if (--n == 0 || c1 == '\\0')\n        break;\n\n      ++p1;\n      ++p2;\n    }\n  while (c1 == c2);\n\n  if (UCHAR_MAX <= INT_MAX)\n    return c1 - c2;\n  else\n    /* On machines where 'char' and 'int' are types of the same size, the\n       difference of two 'unsigned char' values - including the sign bit -\n       doesn't fit in an 'int'.  */\n    return (c1 > c2 ? 1 : c1 < c2 ? -1 : 0);\n}",
      "lines": 31,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/c-strstr.c": {
    "c_strstr": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        31,
        1
      ],
      "content": "char *\nc_strstr (const char *haystack, const char *needle)\n{\n  /* POSIX says that strstr() interprets the strings as byte sequences, not\n     as character sequences in the current locale.  */\n  return strstr (haystack, needle);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "char",
        "*\nc_strstr (const char *haystack, const char *needle)",
        "*"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/c-strstr.h": {},
  "findutils/findutils-4.6.0/gl/lib/canonicalize.c": {
    "canonicalize_file_name": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        63,
        1
      ],
      "content": "char *\ncanonicalize_file_name (const char *name)\n{\n  return canonicalize_filename_mode (name, CAN_EXISTING);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\ncanonicalize_file_name (const char *name)",
        "*"
      ]
    },
    "seen_triple": {
      "start_point": [
        68,
        0
      ],
      "end_point": [
        88,
        1
      ],
      "content": "static bool\nseen_triple (Hash_table **ht, char const *filename, struct stat const *st)\n{\n  if (*ht == NULL)\n    {\n      size_t initial_capacity = 7;\n      *ht = hash_initialize (initial_capacity,\n                            NULL,\n                            triple_hash,\n                            triple_compare_ino_str,\n                            triple_free);\n      if (*ht == NULL)\n        xalloc_die ();\n    }\n\n  if (seen_file (*ht, filename, st))\n    return true;\n\n  record_file (*ht, filename, st);\n  return false;\n}",
      "lines": 21,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "canonicalize_filename_mode": {
      "start_point": [
        97,
        0
      ],
      "end_point": [
        353,
        1
      ],
      "content": "char *\ncanonicalize_filename_mode (const char *name, canonicalize_mode_t can_mode)\n{\n  char *rname, *dest, *extra_buf = NULL;\n  char const *start;\n  char const *end;\n  char const *rname_limit;\n  size_t extra_len = 0;\n  Hash_table *ht = NULL;\n  int saved_errno;\n  int can_flags = can_mode & ~CAN_MODE_MASK;\n  bool logical = can_flags & CAN_NOLINKS;\n  size_t prefix_len;\n\n  can_mode &= CAN_MODE_MASK;\n\n  if (MULTIPLE_BITS_SET (can_mode))\n    {\n      errno = EINVAL;\n      return NULL;\n    }\n\n  if (name == NULL)\n    {\n      errno = EINVAL;\n      return NULL;\n    }\n\n  if (name[0] == '\\0')\n    {\n      errno = ENOENT;\n      return NULL;\n    }\n\n  /* This is always zero for Posix hosts, but can be 2 for MS-Windows\n     and MS-DOS X:/foo/bar file names.  */\n  prefix_len = FILE_SYSTEM_PREFIX_LEN (name);\n\n  if (!IS_ABSOLUTE_FILE_NAME (name))\n    {\n      rname = xgetcwd ();\n      if (!rname)\n        return NULL;\n      dest = strchr (rname, '\\0');\n      if (dest - rname < PATH_MAX)\n        {\n          char *p = xrealloc (rname, PATH_MAX);\n          dest = p + (dest - rname);\n          rname = p;\n          rname_limit = rname + PATH_MAX;\n        }\n      else\n        {\n          rname_limit = dest;\n        }\n      start = name;\n      prefix_len = FILE_SYSTEM_PREFIX_LEN (rname);\n    }\n  else\n    {\n      rname = xmalloc (PATH_MAX);\n      rname_limit = rname + PATH_MAX;\n      dest = rname;\n      if (prefix_len)\n        {\n          memcpy (rname, name, prefix_len);\n          dest += prefix_len;\n        }\n      *dest++ = '/';\n      if (DOUBLE_SLASH_IS_DISTINCT_ROOT)\n        {\n          if (ISSLASH (name[1]) && !ISSLASH (name[2]) && !prefix_len)\n            *dest++ = '/';\n          *dest = '\\0';\n        }\n      start = name + prefix_len;\n    }\n\n  for ( ; *start; start = end)\n    {\n      /* Skip sequence of multiple file name separators.  */\n      while (ISSLASH (*start))\n        ++start;\n\n      /* Find end of component.  */\n      for (end = start; *end && !ISSLASH (*end); ++end)\n        /* Nothing.  */;\n\n      if (end - start == 0)\n        break;\n      else if (end - start == 1 && start[0] == '.')\n        /* nothing */;\n      else if (end - start == 2 && start[0] == '.' && start[1] == '.')\n        {\n          /* Back up to previous component, ignore if at root already.  */\n          if (dest > rname + prefix_len + 1)\n            for (--dest; dest > rname && !ISSLASH (dest[-1]); --dest)\n              continue;\n          if (DOUBLE_SLASH_IS_DISTINCT_ROOT && dest == rname + 1\n              && !prefix_len && ISSLASH (*dest) && !ISSLASH (dest[1]))\n            dest++;\n        }\n      else\n        {\n          struct stat st;\n\n          if (!ISSLASH (dest[-1]))\n            *dest++ = '/';\n\n          if (dest + (end - start) >= rname_limit)\n            {\n              ptrdiff_t dest_offset = dest - rname;\n              size_t new_size = rname_limit - rname;\n\n              if (end - start + 1 > PATH_MAX)\n                new_size += end - start + 1;\n              else\n                new_size += PATH_MAX;\n              rname = xrealloc (rname, new_size);\n              rname_limit = rname + new_size;\n\n              dest = rname + dest_offset;\n            }\n\n          dest = memcpy (dest, start, end - start);\n          dest += end - start;\n          *dest = '\\0';\n\n          if (logical && (can_mode == CAN_MISSING))\n            {\n              /* Avoid the stat in this case as it's inconsequential.\n                 i.e. we're neither resolving symlinks or testing\n                 component existence.  */\n              st.st_mode = 0;\n            }\n          else if ((logical ? stat (rname, &st) : lstat (rname, &st)) != 0)\n            {\n              saved_errno = errno;\n              if (can_mode == CAN_EXISTING)\n                goto error;\n              if (can_mode == CAN_ALL_BUT_LAST)\n                {\n                  if (end[strspn (end, SLASHES)] || saved_errno != ENOENT)\n                    goto error;\n                  continue;\n                }\n              st.st_mode = 0;\n            }\n\n          if (S_ISLNK (st.st_mode))\n            {\n              char *buf;\n              size_t n, len;\n\n              /* Detect loops.  We cannot use the cycle-check module here,\n                 since it's actually possible to encounter the same symlink\n                 more than once in a given traversal.  However, encountering\n                 the same symlink,NAME pair twice does indicate a loop.  */\n              if (seen_triple (&ht, name, &st))\n                {\n                  if (can_mode == CAN_MISSING)\n                    continue;\n                  saved_errno = ELOOP;\n                  goto error;\n                }\n\n              buf = areadlink_with_size (rname, st.st_size);\n              if (!buf)\n                {\n                  if (can_mode == CAN_MISSING && errno != ENOMEM)\n                    continue;\n                  saved_errno = errno;\n                  goto error;\n                }\n\n              n = strlen (buf);\n              len = strlen (end);\n\n              if (!extra_len)\n                {\n                  extra_len =\n                    ((n + len + 1) > PATH_MAX) ? (n + len + 1) : PATH_MAX;\n                  extra_buf = xmalloc (extra_len);\n                }\n              else if ((n + len + 1) > extra_len)\n                {\n                  extra_len = n + len + 1;\n                  extra_buf = xrealloc (extra_buf, extra_len);\n                }\n\n              /* Careful here, end may be a pointer into extra_buf... */\n              memmove (&extra_buf[n], end, len + 1);\n              name = end = memcpy (extra_buf, buf, n);\n\n              if (IS_ABSOLUTE_FILE_NAME (buf))\n                {\n                  size_t pfxlen = FILE_SYSTEM_PREFIX_LEN (buf);\n\n                  if (pfxlen)\n                    memcpy (rname, buf, pfxlen);\n                  dest = rname + pfxlen;\n                  *dest++ = '/'; /* It's an absolute symlink */\n                  if (DOUBLE_SLASH_IS_DISTINCT_ROOT)\n                    {\n                      if (ISSLASH (buf[1]) && !ISSLASH (buf[2]) && !pfxlen)\n                        *dest++ = '/';\n                      *dest = '\\0';\n                    }\n                  /* Install the new prefix to be in effect hereafter.  */\n                  prefix_len = pfxlen;\n                }\n              else\n                {\n                  /* Back up to previous component, ignore if at root\n                     already: */\n                  if (dest > rname + prefix_len + 1)\n                    for (--dest; dest > rname && !ISSLASH (dest[-1]); --dest)\n                      continue;\n                  if (DOUBLE_SLASH_IS_DISTINCT_ROOT && dest == rname + 1\n                      && ISSLASH (*dest) && !ISSLASH (dest[1]) && !prefix_len)\n                    dest++;\n                }\n\n              free (buf);\n            }\n          else\n            {\n              if (!S_ISDIR (st.st_mode) && *end && (can_mode != CAN_MISSING))\n                {\n                  saved_errno = ENOTDIR;\n                  goto error;\n                }\n            }\n        }\n    }\n  if (dest > rname + prefix_len + 1 && ISSLASH (dest[-1]))\n    --dest;\n  if (DOUBLE_SLASH_IS_DISTINCT_ROOT && dest == rname + 1 && !prefix_len\n      && ISSLASH (*dest) && !ISSLASH (dest[1]))\n    dest++;\n  *dest = '\\0';\n  if (rname_limit != dest + 1)\n    rname = xrealloc (rname, dest - rname + 1);\n\n  free (extra_buf);\n  if (ht)\n    hash_free (ht);\n  return rname;\n\nerror:\n  free (extra_buf);\n  free (rname);\n  if (ht)\n    hash_free (ht);\n  errno = saved_errno;\n  return NULL;\n}",
      "lines": 257,
      "depth": 23,
      "decorators": [
        "char",
        "*\ncanonicalize_filename_mode (const char *name, canonicalize_mode_t can_mode)",
        "*"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/canonicalize.h": {},
  "findutils/findutils-4.6.0/gl/lib/careadlinkat.c": {
    "careadlinkat": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        159,
        1
      ],
      "content": "char *\ncareadlinkat (int fd, char const *filename,\n              char *buffer, size_t buffer_size,\n              struct allocator const *alloc,\n              ssize_t (*preadlinkat) (int, char const *, char *, size_t))\n{\n  char *buf;\n  size_t buf_size;\n  size_t buf_size_max =\n    SSIZE_MAX < SIZE_MAX ? (size_t) SSIZE_MAX + 1 : SIZE_MAX;\n  char stack_buf[1024];\n\n  if (! alloc)\n    alloc = &stdlib_allocator;\n\n  if (! buffer_size)\n    {\n      /* Allocate the initial buffer on the stack.  This way, in the\n         common case of a symlink of small size, we get away with a\n         single small malloc() instead of a big malloc() followed by a\n         shrinking realloc().  */\n      buffer = stack_buf;\n      buffer_size = sizeof stack_buf;\n    }\n\n  buf = buffer;\n  buf_size = buffer_size;\n\n  do\n    {\n      /* Attempt to read the link into the current buffer.  */\n      ssize_t link_length = preadlinkat (fd, filename, buf, buf_size);\n      size_t link_size;\n      if (link_length < 0)\n        {\n          /* On AIX 5L v5.3 and HP-UX 11i v2 04/09, readlink returns -1\n             with errno == ERANGE if the buffer is too small.  */\n          int readlinkat_errno = errno;\n          if (readlinkat_errno != ERANGE)\n            {\n              if (buf != buffer)\n                {\n                  alloc->free (buf);\n                  errno = readlinkat_errno;\n                }\n              return NULL;\n            }\n        }\n\n      link_size = link_length;\n\n      if (link_size < buf_size)\n        {\n          buf[link_size++] = '\\0';\n\n          if (buf == stack_buf)\n            {\n              char *b = (char *) alloc->allocate (link_size);\n              buf_size = link_size;\n              if (! b)\n                break;\n              memcpy (b, buf, link_size);\n              buf = b;\n            }\n          else if (link_size < buf_size && buf != buffer && alloc->reallocate)\n            {\n              /* Shrink BUF before returning it.  */\n              char *b = (char *) alloc->reallocate (buf, link_size);\n              if (b)\n                buf = b;\n            }\n\n          return buf;\n        }\n\n      if (buf != buffer)\n        alloc->free (buf);\n\n      if (buf_size <= buf_size_max / 2)\n        buf_size *= 2;\n      else if (buf_size < buf_size_max)\n        buf_size = buf_size_max;\n      else if (buf_size_max < SIZE_MAX)\n        {\n          errno = ENAMETOOLONG;\n          return NULL;\n        }\n      else\n        break;\n      buf = (char *) alloc->allocate (buf_size);\n    }\n  while (buf);\n\n  if (alloc->die)\n    alloc->die (buf_size);\n  errno = ENOMEM;\n  return NULL;\n}",
      "lines": 98,
      "depth": 15,
      "decorators": [
        "char",
        "*\ncareadlinkat (int fd, char const *filename,\n              char *buffer, size_t buffer_size,\n              struct allocator const *alloc,\n              ssize_t (*preadlinkat) (int, char const *, char *, size_t))",
        "*"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/careadlinkat.h": {},
  "findutils/findutils-4.6.0/gl/lib/chdir-long.c": {
    "cdb_init": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "static void\ncdb_init (struct cd_buf *cdb)\n{\n  cdb->fd = AT_FDCWD;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "cdb_fchdir": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "static int\ncdb_fchdir (struct cd_buf const *cdb)\n{\n  return fchdir (cdb->fd);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cdb_free": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        65,
        1
      ],
      "content": "static void\ncdb_free (struct cd_buf const *cdb)\n{\n  if (0 <= cdb->fd)\n    {\n      bool close_fail = close (cdb->fd);\n      assure (! close_fail);\n    }\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "cdb_advance_fd": {
      "start_point": [
        71,
        0
      ],
      "end_point": [
        83,
        1
      ],
      "content": "static int\ncdb_advance_fd (struct cd_buf *cdb, char const *dir)\n{\n  int new_fd = openat (cdb->fd, dir,\n                       O_SEARCH | O_DIRECTORY | O_NOCTTY | O_NONBLOCK);\n  if (new_fd < 0)\n    return -1;\n\n  cdb_free (cdb);\n  cdb->fd = new_fd;\n\n  return 0;\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "find_non_slash": {
      "start_point": [
        86,
        0
      ],
      "end_point": [
        91,
        1
      ],
      "content": "static char * _GL_ATTRIBUTE_PURE\nfind_non_slash (char const *s)\n{\n  size_t n_slash = strspn (s, \"/\");\n  return (char *) s + n_slash;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "char",
        "* _GL_ATTRIBUTE_PURE\nfind_non_slash (char const *s)",
        "*",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "chdir_long": {
      "start_point": [
        108,
        0
      ],
      "end_point": [
        207,
        1
      ],
      "content": "int\nchdir_long (char *dir)\n{\n  int e = chdir (dir);\n  if (e == 0 || errno != ENAMETOOLONG)\n    return e;\n\n  {\n    size_t len = strlen (dir);\n    char *dir_end = dir + len;\n    struct cd_buf cdb;\n    size_t n_leading_slash;\n\n    cdb_init (&cdb);\n\n    /* If DIR is the empty string, then the chdir above\n       must have failed and set errno to ENOENT.  */\n    assure (0 < len);\n    assure (PATH_MAX <= len);\n\n    /* Count leading slashes.  */\n    n_leading_slash = strspn (dir, \"/\");\n\n    /* Handle any leading slashes as well as any name that matches\n       the regular expression, m!^//hostname[/]*! .  Handling this\n       prefix separately usually results in a single additional\n       cdb_advance_fd call, but it's worthwhile, since it makes the\n       code in the following loop cleaner.  */\n    if (n_leading_slash == 2)\n      {\n        int err;\n        /* Find next slash.\n           We already know that dir[2] is neither a slash nor '\\0'.  */\n        char *slash = memchr (dir + 3, '/', dir_end - (dir + 3));\n        if (slash == NULL)\n          {\n            errno = ENAMETOOLONG;\n            return -1;\n          }\n        *slash = '\\0';\n        err = cdb_advance_fd (&cdb, dir);\n        *slash = '/';\n        if (err != 0)\n          goto Fail;\n        dir = find_non_slash (slash + 1);\n      }\n    else if (n_leading_slash)\n      {\n        if (cdb_advance_fd (&cdb, \"/\") != 0)\n          goto Fail;\n        dir += n_leading_slash;\n      }\n\n    assure (*dir != '/');\n    assure (dir <= dir_end);\n\n    while (PATH_MAX <= dir_end - dir)\n      {\n        int err;\n        /* Find a slash that is PATH_MAX or fewer bytes away from dir.\n           I.e. see if there is a slash that will give us a name of\n           length PATH_MAX-1 or less.  */\n        char *slash = memrchr (dir, '/', PATH_MAX);\n        if (slash == NULL)\n          {\n            errno = ENAMETOOLONG;\n            return -1;\n          }\n\n        *slash = '\\0';\n        assure (slash - dir < PATH_MAX);\n        err = cdb_advance_fd (&cdb, dir);\n        *slash = '/';\n        if (err != 0)\n          goto Fail;\n\n        dir = find_non_slash (slash + 1);\n      }\n\n    if (dir < dir_end)\n      {\n        if (cdb_advance_fd (&cdb, dir) != 0)\n          goto Fail;\n      }\n\n    if (cdb_fchdir (&cdb) != 0)\n      goto Fail;\n\n    cdb_free (&cdb);\n    return 0;\n\n   Fail:\n    {\n      int saved_errno = errno;\n      cdb_free (&cdb);\n      errno = saved_errno;\n      return -1;\n    }\n  }\n}",
      "lines": 100,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "main": {
      "start_point": [
        216,
        0
      ],
      "end_point": [
        259,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  char *line = NULL;\n  size_t n = 0;\n  int len;\n\n  program_name = argv[0];\n  atexit (close_stdout);\n\n  len = getline (&line, &n, stdin);\n  if (len < 0)\n    {\n      int saved_errno = errno;\n      if (feof (stdin))\n        exit (0);\n\n      error (EXIT_FAILURE, saved_errno,\n             \"reading standard input\");\n    }\n  else if (len == 0)\n    exit (0);\n\n  if (line[len-1] == '\\n')\n    line[len-1] = '\\0';\n\n  if (chdir_long (line) != 0)\n    error (EXIT_FAILURE, errno,\n           \"chdir_long failed: %s\", line);\n\n  if (argc <= 1)\n    {\n      /* Using 'pwd' here makes sense only if it is a robust implementation,\n         like the one in coreutils after the 2004-04-19 changes.  */\n      char const *cmd = \"pwd\";\n      execlp (cmd, (char *) NULL);\n      error (EXIT_FAILURE, errno, \"%s\", cmd);\n    }\n\n  fclose (stdin);\n  fclose (stderr);\n\n  exit (EXIT_SUCCESS);\n}",
      "lines": 44,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/chdir-long.h": {},
  "findutils/findutils-4.6.0/gl/lib/cloexec.c": {
    "set_cloexec_flag": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "int\nset_cloexec_flag (int desc, bool value)\n{\n#ifdef F_SETFD\n\n  int flags = fcntl (desc, F_GETFD, 0);\n\n  if (0 <= flags)\n    {\n      int newflags = (value ? flags | FD_CLOEXEC : flags & ~FD_CLOEXEC);\n\n      if (flags == newflags\n          || fcntl (desc, F_SETFD, newflags) != -1)\n        return 0;\n    }\n\n  return -1;\n\n#else /* !F_SETFD */\n\n  /* Use dup2 to reject invalid file descriptors; the cloexec flag\n     will be unaffected.  */\n  if (desc < 0)\n    {\n      errno = EBADF;\n      return -1;\n    }\n  if (dup2 (desc, desc) < 0)\n    /* errno is EBADF here.  */\n    return -1;\n\n  /* There is nothing we can do on this kind of platform.  Punt.  */\n  return 0;\n#endif /* !F_SETFD */\n}",
      "lines": 35,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "dup_cloexec": {
      "start_point": [
        78,
        0
      ],
      "end_point": [
        82,
        1
      ],
      "content": "int\ndup_cloexec (int fd)\n{\n  return fcntl (fd, F_DUPFD_CLOEXEC, 0);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/cloexec.h": {},
  "findutils/findutils-4.6.0/gl/lib/close-stream.c": {
    "close_stream": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "int\nclose_stream (FILE *stream)\n{\n  const bool some_pending = (__fpending (stream) != 0);\n  const bool prev_fail = (ferror (stream) != 0);\n  const bool fclose_fail = (fclose (stream) != 0);\n\n  /* Return an error indication if there was a previous failure or if\n     fclose failed, with one exception: ignore an fclose failure if\n     there was no previous error, no data remains to be flushed, and\n     fclose failed with EBADF.  That can happen when a program like cp\n     is invoked like this 'cp a b >&-' (i.e., with standard output\n     closed) and doesn't generate any output (hence no previous error\n     and nothing to be flushed).  */\n\n  if (prev_fail || (fclose_fail && (some_pending || errno != EBADF)))\n    {\n      if (! fclose_fail)\n        errno = 0;\n      return EOF;\n    }\n\n  return 0;\n}",
      "lines": 24,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/close-stream.h": {},
  "findutils/findutils-4.6.0/gl/lib/close.c": {
    "close_nothrow": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        37,
        5
      ],
      "content": "static int\nclose_nothrow (int fd)\n{\n  int result;\n\n  TRY_MSVC_INVAL\n    {\n      result = close (fd);\n    }",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_close": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "int\nrpl_close (int fd)\n{\n#if WINDOWS_SOCKETS\n  int retval = execute_all_close_hooks (close_nothrow, fd);\n#else\n  int retval = close_nothrow (fd);\n#endif\n\n#if REPLACE_FCHDIR\n  if (retval >= 0)\n    _gl_unregister_fd (fd);\n#endif\n\n  return retval;\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/closedir.c": {
    "closedir": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "int\nclosedir (DIR *dirp)\n{\n# if REPLACE_FCHDIR\n  int fd = dirfd (dirp);\n# endif\n  int retval;\n\n#if HAVE_CLOSEDIR\n# undef closedir\n\n  retval = closedir (dirp);\n\n#else\n\n  if (dirp->current != INVALID_HANDLE_VALUE)\n    FindClose (dirp->current);\n  free (dirp);\n\n  retval = 0;\n\n#endif\n\n#if REPLACE_FCHDIR\n  if (retval >= 0)\n    _gl_unregister_fd (fd);\n#endif\n  return retval;\n}",
      "lines": 29,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/closein.c": {
    "close_stdin_set_file_name": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "void\nclose_stdin_set_file_name (const char *file)\n{\n  file_name = file;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "close_stdin": {
      "start_point": [
        77,
        0
      ],
      "end_point": [
        111,
        1
      ],
      "content": "void\nclose_stdin (void)\n{\n  bool fail = false;\n\n  /* There is no need to flush stdin if we can determine quickly that stdin's\n     input buffer is empty; in this case we know that if stdin is seekable,\n     (fseeko (stdin, 0, SEEK_CUR), ftello (stdin))\n     == lseek (0, 0, SEEK_CUR).  */\n  if (freadahead (stdin) > 0)\n    {\n      /* Only attempt flush if stdin is seekable, as fflush is entitled to\n         fail on non-seekable streams.  */\n      if (fseeko (stdin, 0, SEEK_CUR) == 0 && fflush (stdin) != 0)\n        fail = true;\n    }\n  if (close_stream (stdin) != 0)\n    fail = true;\n  if (fail)\n    {\n      /* Report failure, but defer exit until after closing stdout,\n         since the failure report should still be flushed.  */\n      char const *close_error = _(\"error closing file\");\n      if (file_name)\n        error (0, errno, \"%s: %s\", quotearg_colon (file_name),\n               close_error);\n      else\n        error (0, errno, \"%s\", close_error);\n    }\n\n  close_stdout ();\n\n  if (fail)\n    _exit (exit_failure);\n}",
      "lines": 35,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/closein.h": {},
  "findutils/findutils-4.6.0/gl/lib/closeout.c": {
    "close_stdout_set_file_name": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "void\nclose_stdout_set_file_name (const char *file)\n{\n  file_name = file;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "close_stdout_set_ignore_EPIPE": {
      "start_point": [
        76,
        0
      ],
      "end_point": [
        80,
        1
      ],
      "content": "void\nclose_stdout_set_ignore_EPIPE (bool ignore)\n{\n  ignore_EPIPE = ignore;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "void"
      ]
    },
    "close_stdout": {
      "start_point": [
        105,
        0
      ],
      "end_point": [
        123,
        1
      ],
      "content": "void\nclose_stdout (void)\n{\n  if (close_stream (stdout) != 0\n      && !(ignore_EPIPE && errno == EPIPE))\n    {\n      char const *write_error = _(\"write error\");\n      if (file_name)\n        error (0, errno, \"%s: %s\", quotearg_colon (file_name),\n               write_error);\n      else\n        error (0, errno, \"%s\", write_error);\n\n      _exit (exit_failure);\n    }\n\n   if (close_stream (stderr) != 0)\n     _exit (exit_failure);\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/closeout.h": {},
  "findutils/findutils-4.6.0/gl/lib/creat-safer.c": {
    "creat_safer": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        30,
        1
      ],
      "content": "int\ncreat_safer (char const *file, mode_t mode)\n{\n  return fd_safer (creat (file, mode));\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/ctype.in.h": {},
  "findutils/findutils-4.6.0/gl/lib/cycle-check.c": {
    "is_zero_or_power_of_two": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        39,
        1
      ],
      "content": "static bool\nis_zero_or_power_of_two (uintmax_t i)\n{\n  return (i & (i - 1)) == 0;\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "cycle_check_init": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        46,
        1
      ],
      "content": "void\ncycle_check_init (struct cycle_check_state *state)\n{\n  state->chdir_counter = 0;\n  state->magic = CC_MAGIC;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "cycle_check": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        84,
        1
      ],
      "content": "bool\ncycle_check (struct cycle_check_state *state, struct stat const *sb)\n{\n  assure (state->magic == CC_MAGIC);\n\n  /* If the current directory ever happens to be the same\n     as the one we last recorded for the cycle detection,\n     then it's obviously part of a cycle.  */\n  if (state->chdir_counter && SAME_INODE (*sb, state->dev_ino))\n    return true;\n\n  /* If the number of \"descending\" chdir calls is a power of two,\n     record the dev/ino of the current directory.  */\n  if (is_zero_or_power_of_two (++(state->chdir_counter)))\n    {\n      /* On all architectures that we know about, if the counter\n         overflows then there is a directory cycle here somewhere,\n         even if we haven't detected it yet.  Typically this happens\n         only after the counter is incremented 2**64 times, so it's a\n         fairly theoretical point.  */\n      if (state->chdir_counter == 0)\n        return true;\n\n      state->dev_ino.st_dev = sb->st_dev;\n      state->dev_ino.st_ino = sb->st_ino;\n    }\n\n  return false;\n}",
      "lines": 29,
      "depth": 10,
      "decorators": [
        "bool"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/cycle-check.h": {},
  "findutils/findutils-4.6.0/gl/lib/dev-ino.h": {},
  "findutils/findutils-4.6.0/gl/lib/dirent--.h": {},
  "findutils/findutils-4.6.0/gl/lib/dirent-private.h": {},
  "findutils/findutils-4.6.0/gl/lib/dirent-safer.h": {},
  "findutils/findutils-4.6.0/gl/lib/dirent.in.h": {
    "dirfd": {
      "start_point": [
        164,
        0
      ],
      "end_point": [
        164,
        58
      ],
      "content": "static inline int (dirfd) (DIR *dp) { return dirfd (dp); }",
      "lines": 1,
      "depth": 6,
      "decorators": null
    }
  },
  "findutils/findutils-4.6.0/gl/lib/dirfd.c": {
    "dirfd": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        31,
        1
      ],
      "content": "int\ndirfd (DIR *dir_p)\n{\n  int fd = DIR_TO_FD (dir_p);\n  if (fd == -1)\n    errno = ENOTSUP;\n  return fd;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/dirname-lgpl.c": {
    "dir_len": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "size_t\ndir_len (char const *file)\n{\n  size_t prefix_length = FILE_SYSTEM_PREFIX_LEN (file);\n  size_t length;\n\n  /* Advance prefix_length beyond important leading slashes.  */\n  prefix_length += (prefix_length != 0\n                    ? (FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE\n                       && ISSLASH (file[prefix_length]))\n                    : (ISSLASH (file[0])\n                       ? ((DOUBLE_SLASH_IS_DISTINCT_ROOT\n                           && ISSLASH (file[1]) && ! ISSLASH (file[2])\n                           ? 2 : 1))\n                       : 0));\n\n  /* Strip the basename and any redundant slashes before it.  */\n  for (length = last_component (file) - file;\n       prefix_length < length; length--)\n    if (! ISSLASH (file[length - 1]))\n      break;\n  return length;\n}",
      "lines": 23,
      "depth": 17,
      "decorators": [
        "size_t"
      ]
    },
    "mdir_name": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "char *\nmdir_name (char const *file)\n{\n  size_t length = dir_len (file);\n  bool append_dot = (length == 0\n                     || (FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE\n                         && length == FILE_SYSTEM_PREFIX_LEN (file)\n                         && file[2] != '\\0' && ! ISSLASH (file[2])));\n  char *dir = malloc (length + append_dot + 1);\n  if (!dir)\n    return NULL;\n  memcpy (dir, file, length);\n  if (append_dot)\n    dir[length++] = '.';\n  dir[length] = '\\0';\n  return dir;\n}",
      "lines": 17,
      "depth": 14,
      "decorators": [
        "char",
        "*\nmdir_name (char const *file)",
        "*"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/dirname.c": {
    "dir_name": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "char *\ndir_name (char const *file)\n{\n  char *result = mdir_name (file);\n  if (!result)\n    xalloc_die ();\n  return result;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "char",
        "*\ndir_name (char const *file)",
        "*"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/dirname.h": {},
  "findutils/findutils-4.6.0/gl/lib/dosname.h": {},
  "findutils/findutils-4.6.0/gl/lib/dup-safer.c": {
    "dup_safer": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        33,
        1
      ],
      "content": "int\ndup_safer (int fd)\n{\n  return fcntl (fd, F_DUPFD, STDERR_FILENO + 1);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/dup.c": {
    "dup_nothrow": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        37,
        5
      ],
      "content": "static int\ndup_nothrow (int fd)\n{\n  int result;\n\n  TRY_MSVC_INVAL\n    {\n      result = dup (fd);\n    }",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_dup": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "int\nrpl_dup (int fd)\n{\n  int result = dup_nothrow (fd);\n#if REPLACE_FCHDIR\n  if (result >= 0)\n    result = _gl_register_dup (fd, result);\n#endif\n  return result;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/dup2.c": {
    "ms_windows_dup2": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        71,
        5
      ],
      "content": "static int\nms_windows_dup2 (int fd, int desired_fd)\n{\n  int result;\n\n  /* If fd is closed, mingw hangs on dup2 (fd, fd).  If fd is open,\n     dup2 (fd, fd) returns 0, but all further attempts to use fd in\n     future dup2 calls will hang.  */\n  if (fd == desired_fd)\n    {\n      if ((HANDLE) _get_osfhandle (fd) == INVALID_HANDLE_VALUE)\n        {\n          errno = EBADF;\n          return -1;\n        }\n      return fd;\n    }\n\n  /* Wine 1.0.1 return 0 when desired_fd is negative but not -1:\n     http://bugs.winehq.org/show_bug.cgi?id=21289 */\n  if (desired_fd < 0)\n    {\n      errno = EBADF;\n      return -1;\n    }\n\n  TRY_MSVC_INVAL\n    {\n      result = dup2 (fd, desired_fd);\n    }",
      "lines": 30,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_dup2": {
      "start_point": [
        89,
        0
      ],
      "end_point": [
        119,
        1
      ],
      "content": "int\nrpl_dup2 (int fd, int desired_fd)\n{\n  int result;\n\n# ifdef F_GETFL\n  /* On Linux kernels 2.6.26-2.6.29, dup2 (fd, fd) returns -EBADF.\n     On Cygwin 1.5.x, dup2 (1, 1) returns 0.\n     On Cygwin 1.7.17, dup2 (1, -1) dumps core.\n     On Cygwin 1.7.25, dup2 (1, 256) can dump core.\n     On Haiku, dup2 (fd, fd) mistakenly clears FD_CLOEXEC.  */\n#  if HAVE_SETDTABLESIZE\n  setdtablesize (desired_fd + 1);\n#  endif\n  if (desired_fd < 0)\n    fd = desired_fd;\n  if (fd == desired_fd)\n    return fcntl (fd, F_GETFL) == -1 ? -1 : fd;\n# endif\n\n  result = dup2 (fd, desired_fd);\n\n  /* Correct an errno value on FreeBSD 6.1 and Cygwin 1.5.x.  */\n  if (result == -1 && errno == EMFILE)\n    errno = EBADF;\n# if REPLACE_FCHDIR\n  if (fd != desired_fd && result != -1)\n    result = _gl_register_dup (fd, result);\n# endif\n  return result;\n}",
      "lines": 31,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "dupfd": {
      "start_point": [
        126,
        0
      ],
      "end_point": [
        140,
        1
      ],
      "content": "static int\ndupfd (int fd, int desired_fd)\n{\n  int duplicated_fd = dup (fd);\n  if (duplicated_fd < 0 || duplicated_fd == desired_fd)\n    return duplicated_fd;\n  else\n    {\n      int r = dupfd (fd, desired_fd);\n      int e = errno;\n      close (duplicated_fd);\n      errno = e;\n      return r;\n    }\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "dup2": {
      "start_point": [
        143,
        0
      ],
      "end_point": [
        162,
        1
      ],
      "content": "int\ndup2 (int fd, int desired_fd)\n{\n  int result = fcntl (fd, F_GETFL) < 0 ? -1 : fd;\n  if (result == -1 || fd == desired_fd)\n    return result;\n  close (desired_fd);\n# ifdef F_DUPFD\n  result = fcntl (fd, F_DUPFD, desired_fd);\n#  if REPLACE_FCHDIR\n  if (0 <= result)\n    result = _gl_register_dup (fd, result);\n#  endif\n# else\n  result = dupfd (fd, desired_fd);\n# endif\n  if (result == -1 && (errno == EMFILE || errno == EINVAL))\n    errno = EBADF;\n  return result;\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/errno.in.h": {},
  "findutils/findutils-4.6.0/gl/lib/error.c": {
    "is_open": {
      "start_point": [
        126,
        0
      ],
      "end_point": [
        141,
        1
      ],
      "content": "static int\nis_open (int fd)\n{\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n  /* On native Windows: The initial state of unassigned standard file\n     descriptors is that they are open but point to an INVALID_HANDLE_VALUE.\n     There is no fcntl, and the gnulib replacement fcntl does not support\n     F_GETFL.  */\n  return (HANDLE) _get_osfhandle (fd) != INVALID_HANDLE_VALUE;\n# else\n#  ifndef F_GETFL\n#   error Please port fcntl to your platform\n#  endif\n  return 0 <= fcntl (fd, F_GETFL);\n# endif\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "flush_stdout": {
      "start_point": [
        144,
        0
      ],
      "end_point": [
        167,
        1
      ],
      "content": "static void\nflush_stdout (void)\n{\n#if !_LIBC\n  int stdout_fd;\n\n# if GNULIB_FREOPEN_SAFER\n  /* Use of gnulib's freopen-safer module normally ensures that\n       fileno (stdout) == 1\n     whenever stdout is open.  */\n  stdout_fd = STDOUT_FILENO;\n# else\n  /* POSIX states that fileno (stdout) after fclose is unspecified.  But in\n     practice it is not a problem, because stdout is statically allocated and\n     the fd of a FILE stream is stored as a field in its allocated memory.  */\n  stdout_fd = fileno (stdout);\n# endif\n  /* POSIX states that fflush (stdout) after fclose is unspecified; it\n     is safe in glibc, but not on all other platforms.  fflush (NULL)\n     is always defined, but too draconian.  */\n  if (0 <= stdout_fd && is_open (stdout_fd))\n#endif\n    fflush (stdout);\n}",
      "lines": 24,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "print_errno_message": {
      "start_point": [
        169,
        0
      ],
      "end_point": [
        198,
        1
      ],
      "content": "static void\nprint_errno_message (int errnum)\n{\n  char const *s;\n\n#if defined HAVE_STRERROR_R || _LIBC\n  char errbuf[1024];\n# if _LIBC || STRERROR_R_CHAR_P\n  s = __strerror_r (errnum, errbuf, sizeof errbuf);\n# else\n  if (__strerror_r (errnum, errbuf, sizeof errbuf) == 0)\n    s = errbuf;\n  else\n    s = 0;\n# endif\n#else\n  s = strerror (errnum);\n#endif\n\n#if !_LIBC\n  if (! s)\n    s = _(\"Unknown system error\");\n#endif\n\n#if _LIBC\n  __fxprintf (NULL, \": %s\", s);\n#else\n  fprintf (stderr, \": %s\", s);\n#endif\n}",
      "lines": 30,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "error_tail": {
      "start_point": [
        201,
        42
      ],
      "end_point": [
        283,
        1
      ],
      "content": "char *message, va_list args)\n{\n#if _LIBC\n  if (_IO_fwide (stderr, 0) > 0)\n    {\n      size_t len = strlen (message) + 1;\n      wchar_t *wmessage = NULL;\n      mbstate_t st;\n      size_t res;\n      const char *tmp;\n      bool use_malloc = false;\n\n      while (1)\n        {\n          if (__libc_use_alloca (len * sizeof (wchar_t)))\n            wmessage = (wchar_t *) alloca (len * sizeof (wchar_t));\n          else\n            {\n              if (!use_malloc)\n                wmessage = NULL;\n\n              wchar_t *p = (wchar_t *) realloc (wmessage,\n                                                len * sizeof (wchar_t));\n              if (p == NULL)\n                {\n                  free (wmessage);\n                  fputws_unlocked (L\"out of memory\\n\", stderr);\n                  return;\n                }\n              wmessage = p;\n              use_malloc = true;\n            }\n\n          memset (&st, '\\0', sizeof (st));\n          tmp = message;\n\n          res = mbsrtowcs (wmessage, &tmp, len, &st);\n          if (res != len)\n            break;\n\n          if (__builtin_expect (len >= SIZE_MAX / sizeof (wchar_t) / 2, 0))\n            {\n              /* This really should not happen if everything is fine.  */\n              res = (size_t) -1;\n              break;\n            }\n\n          len *= 2;\n        }\n\n      if (res == (size_t) -1)\n        {\n          /* The string cannot be converted.  */\n          if (use_malloc)\n            {\n              free (wmessage);\n              use_malloc = false;\n            }\n          wmessage = (wchar_t *) L\"???\";\n        }\n\n      __vfwprintf (stderr, wmessage, args);\n\n      if (use_malloc)\n        free (wmessage);\n    }\n  else\n#endif\n    vfprintf (stderr, message, args);\n  va_end (args);\n\n  ++error_message_count;\n  if (errnum)\n    print_errno_message (errnum);\n#if _LIBC\n  __fxprintf (NULL, \"\\n\");\n#else\n  putc ('\\n', stderr);\n#endif\n  fflush (stderr);\n  if (status)\n    exit (status);\n}",
      "lines": 83,
      "depth": 18,
      "decorators": null
    },
    "error": {
      "start_point": [
        290,
        0
      ],
      "end_point": [
        327,
        1
      ],
      "content": "void\nerror (int status, int errnum, const char *message, ...)\n{\n  va_list args;\n\n#if defined _LIBC && defined __libc_ptf_call\n  /* We do not want this call to be cut short by a thread\n     cancellation.  Therefore disable cancellation for now.  */\n  int state = PTHREAD_CANCEL_ENABLE;\n  __libc_ptf_call (pthread_setcancelstate, (PTHREAD_CANCEL_DISABLE, &state),\n                   0);\n#endif\n\n  flush_stdout ();\n#ifdef _LIBC\n  _IO_flockfile (stderr);\n#endif\n  if (error_print_progname)\n    (*error_print_progname) ();\n  else\n    {\n#if _LIBC\n      __fxprintf (NULL, \"%s: \", program_name);\n#else\n      fprintf (stderr, \"%s: \", program_name);\n#endif\n    }\n\n  va_start (args, message);\n  error_tail (status, errnum, message, args);\n\n#ifdef _LIBC\n  _IO_funlockfile (stderr);\n# ifdef __libc_ptf_call\n  __libc_ptf_call (pthread_setcancelstate, (state, NULL), 0);\n# endif\n#endif\n}",
      "lines": 38,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "error_at_line": {
      "start_point": [
        333,
        0
      ],
      "end_point": [
        397,
        1
      ],
      "content": "void\nerror_at_line (int status, int errnum, const char *file_name,\n               unsigned int line_number, const char *message, ...)\n{\n  va_list args;\n\n  if (error_one_per_line)\n    {\n      static const char *old_file_name;\n      static unsigned int old_line_number;\n\n      if (old_line_number == line_number\n          && (file_name == old_file_name\n              || (old_file_name != NULL\n                  && file_name != NULL\n                  && strcmp (old_file_name, file_name) == 0)))\n\n        /* Simply return and print nothing.  */\n        return;\n\n      old_file_name = file_name;\n      old_line_number = line_number;\n    }\n\n#if defined _LIBC && defined __libc_ptf_call\n  /* We do not want this call to be cut short by a thread\n     cancellation.  Therefore disable cancellation for now.  */\n  int state = PTHREAD_CANCEL_ENABLE;\n  __libc_ptf_call (pthread_setcancelstate, (PTHREAD_CANCEL_DISABLE, &state),\n                   0);\n#endif\n\n  flush_stdout ();\n#ifdef _LIBC\n  _IO_flockfile (stderr);\n#endif\n  if (error_print_progname)\n    (*error_print_progname) ();\n  else\n    {\n#if _LIBC\n      __fxprintf (NULL, \"%s:\", program_name);\n#else\n      fprintf (stderr, \"%s:\", program_name);\n#endif\n    }\n\n#if _LIBC\n  __fxprintf (NULL, file_name != NULL ? \"%s:%u: \" : \" \",\n              file_name, line_number);\n#else\n  fprintf (stderr, file_name != NULL ? \"%s:%u: \" : \" \",\n           file_name, line_number);\n#endif\n\n  va_start (args, message);\n  error_tail (status, errnum, message, args);\n\n#ifdef _LIBC\n  _IO_funlockfile (stderr);\n# ifdef __libc_ptf_call\n  __libc_ptf_call (pthread_setcancelstate, (state, NULL), 0);\n# endif\n#endif\n}",
      "lines": 65,
      "depth": 15,
      "decorators": [
        "void"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/error.h": {},
  "findutils/findutils-4.6.0/gl/lib/euidaccess.c": {
    "euidaccess": {
      "start_point": [
        75,
        0
      ],
      "end_point": [
        188,
        1
      ],
      "content": "int\neuidaccess (const char *file, int mode)\n{\n#if HAVE_FACCESSAT                   /* glibc, AIX 7, Solaris 11, Cygwin 1.7 */\n  return faccessat (AT_FDCWD, file, mode, AT_EACCESS);\n#elif defined EFF_ONLY_OK               /* IRIX, OSF/1, Interix */\n  return access (file, mode | EFF_ONLY_OK);\n#elif defined ACC_SELF                  /* AIX */\n  return accessx (file, mode, ACC_SELF);\n#elif HAVE_EACCESS                      /* FreeBSD */\n  return eaccess (file, mode);\n#else       /* Mac OS X, NetBSD, OpenBSD, HP-UX, Solaris, Cygwin, mingw, BeOS */\n\n  uid_t uid = getuid ();\n  gid_t gid = getgid ();\n  uid_t euid = geteuid ();\n  gid_t egid = getegid ();\n  struct stat stats;\n\n# if HAVE_DECL_SETREGID && PREFER_NONREENTRANT_EUIDACCESS\n\n  /* Define PREFER_NONREENTRANT_EUIDACCESS if you prefer euidaccess to\n     return the correct result even if this would make it\n     nonreentrant.  Define this only if your entire application is\n     safe even if the uid or gid might temporarily change.  If your\n     application uses signal handlers or threads it is probably not\n     safe.  */\n\n  if (mode == F_OK)\n    return stat (file, &stats);\n  else\n    {\n      int result;\n      int saved_errno;\n\n      if (uid != euid)\n        setreuid (euid, uid);\n      if (gid != egid)\n        setregid (egid, gid);\n\n      result = access (file, mode);\n      saved_errno = errno;\n\n      /* Restore them.  */\n      if (uid != euid)\n        setreuid (uid, euid);\n      if (gid != egid)\n        setregid (gid, egid);\n\n      errno = saved_errno;\n      return result;\n    }\n\n# else\n\n  /* The following code assumes the traditional Unix model, and is not\n     correct on systems that have ACLs or the like.  However, it's\n     better than nothing, and it is reentrant.  */\n\n  unsigned int granted;\n  if (uid == euid && gid == egid)\n    /* If we are not set-uid or set-gid, access does the same.  */\n    return access (file, mode);\n\n  if (stat (file, &stats) != 0)\n    return -1;\n\n  /* The super-user can read and write any file, and execute any file\n     that anyone can execute.  */\n  if (euid == ROOT_UID\n      && ((mode & X_OK) == 0\n          || (stats.st_mode & (S_IXUSR | S_IXGRP | S_IXOTH))))\n    return 0;\n\n  /* Convert the mode to traditional form, clearing any bogus bits.  */\n  if (R_OK == 4 && W_OK == 2 && X_OK == 1 && F_OK == 0)\n    mode &= 7;\n  else\n    mode = ((mode & R_OK ? 4 : 0)\n            + (mode & W_OK ? 2 : 0)\n            + (mode & X_OK ? 1 : 0));\n\n  if (mode == 0)\n    return 0;                   /* The file exists.  */\n\n  /* Convert the file's permission bits to traditional form.  */\n  if (S_IRUSR == (4 << 6) && S_IWUSR == (2 << 6) && S_IXUSR == (1 << 6)\n      && S_IRGRP == (4 << 3) && S_IWGRP == (2 << 3) && S_IXGRP == (1 << 3)\n      && S_IROTH == (4 << 0) && S_IWOTH == (2 << 0) && S_IXOTH == (1 << 0))\n    granted = stats.st_mode;\n  else\n    granted = ((stats.st_mode & S_IRUSR ? 4 << 6 : 0)\n               + (stats.st_mode & S_IWUSR ? 2 << 6 : 0)\n               + (stats.st_mode & S_IXUSR ? 1 << 6 : 0)\n               + (stats.st_mode & S_IRGRP ? 4 << 3 : 0)\n               + (stats.st_mode & S_IWGRP ? 2 << 3 : 0)\n               + (stats.st_mode & S_IXGRP ? 1 << 3 : 0)\n               + (stats.st_mode & S_IROTH ? 4 << 0 : 0)\n               + (stats.st_mode & S_IWOTH ? 2 << 0 : 0)\n               + (stats.st_mode & S_IXOTH ? 1 << 0 : 0));\n\n  if (euid == stats.st_uid)\n    granted >>= 6;\n  else if (egid == stats.st_gid || group_member (stats.st_gid))\n    granted >>= 3;\n\n  if ((mode & ~granted) == 0)\n    return 0;\n  __set_errno (EACCESS);\n  return -1;\n\n# endif\n#endif\n}",
      "lines": 114,
      "depth": 26,
      "decorators": [
        "int"
      ]
    },
    "main": {
      "start_point": [
        201,
        0
      ],
      "end_point": [
        219,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  char *file;\n  int mode;\n  int err;\n\n  program_name = argv[0];\n  if (argc < 3)\n    abort ();\n  file = argv[1];\n  mode = atoi (argv[2]);\n\n  err = euidaccess (file, mode);\n  printf (\"%d\\n\", err);\n  if (err != 0)\n    error (0, errno, \"%s\", file);\n  exit (0);\n}",
      "lines": 19,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/exitfail.c": {},
  "findutils/findutils-4.6.0/gl/lib/exitfail.h": {},
  "findutils/findutils-4.6.0/gl/lib/faccessat.c": {},
  "findutils/findutils-4.6.0/gl/lib/fchdir.c": {
    "ensure_dirs_slot": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        84,
        1
      ],
      "content": "static bool\nensure_dirs_slot (size_t fd)\n{\n  if (fd < dirs_allocated)\n    free (dirs[fd].name);\n  else\n    {\n      size_t new_allocated;\n      dir_info_t *new_dirs;\n\n      new_allocated = 2 * dirs_allocated + 1;\n      if (new_allocated <= fd)\n        new_allocated = fd + 1;\n      new_dirs =\n        (dirs != NULL\n         ? (dir_info_t *) realloc (dirs, new_allocated * sizeof *dirs)\n         : (dir_info_t *) malloc (new_allocated * sizeof *dirs));\n      if (new_dirs == NULL)\n        return false;\n      memset (new_dirs + dirs_allocated, 0,\n              (new_allocated - dirs_allocated) * sizeof *dirs);\n      dirs = new_dirs;\n      dirs_allocated = new_allocated;\n    }\n  return true;\n}",
      "lines": 26,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "get_name": {
      "start_point": [
        87,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "static char *\nget_name (char const *dir)\n{\n  char *cwd;\n  char *result;\n  int saved_errno;\n\n  if (IS_ABSOLUTE_FILE_NAME (dir))\n    return strdup (dir);\n\n  /* We often encounter \".\"; treat it as a special case.  */\n  cwd = getcwd (NULL, 0);\n  if (!cwd || (dir[0] == '.' && dir[1] == '\\0'))\n    return cwd;\n\n  result = mfile_name_concat (cwd, dir, NULL);\n  saved_errno = errno;\n  free (cwd);\n  errno = saved_errno;\n  return result;\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nget_name (char const *dir)",
        "*"
      ]
    },
    "_gl_unregister_fd": {
      "start_point": [
        114,
        0
      ],
      "end_point": [
        122,
        1
      ],
      "content": "void\n_gl_unregister_fd (int fd)\n{\n  if (fd >= 0 && fd < dirs_allocated)\n    {\n      free (dirs[fd].name);\n      dirs[fd].name = NULL;\n    }\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "_gl_register_fd": {
      "start_point": [
        129,
        0
      ],
      "end_point": [
        148,
        1
      ],
      "content": "int\n_gl_register_fd (int fd, const char *filename)\n{\n  struct stat statbuf;\n\n  assure (0 <= fd);\n  if (REPLACE_OPEN_DIRECTORY\n      || (fstat (fd, &statbuf) == 0 && S_ISDIR (statbuf.st_mode)))\n    {\n      if (!ensure_dirs_slot (fd)\n          || (dirs[fd].name = get_name (filename)) == NULL)\n        {\n          int saved_errno = errno;\n          close (fd);\n          errno = saved_errno;\n          return -1;\n        }\n    }\n  return fd;\n}",
      "lines": 20,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "_gl_register_dup": {
      "start_point": [
        155,
        0
      ],
      "end_point": [
        178,
        1
      ],
      "content": "int\n_gl_register_dup (int oldfd, int newfd)\n{\n  assure (0 <= oldfd && 0 <= newfd && oldfd != newfd);\n  if (oldfd < dirs_allocated && dirs[oldfd].name)\n    {\n      /* Duplicated a directory; must ensure newfd is allocated.  */\n      if (!ensure_dirs_slot (newfd)\n          || (dirs[newfd].name = strdup (dirs[oldfd].name)) == NULL)\n        {\n          int saved_errno = errno;\n          close (newfd);\n          errno = saved_errno;\n          newfd = -1;\n        }\n    }\n  else if (newfd < dirs_allocated)\n    {\n      /* Duplicated a non-directory; ensure newfd is cleared.  */\n      free (dirs[newfd].name);\n      dirs[newfd].name = NULL;\n    }\n  return newfd;\n}",
      "lines": 24,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "_gl_directory_name": {
      "start_point": [
        182,
        0
      ],
      "end_point": [
        197,
        1
      ],
      "content": "const char *\n_gl_directory_name (int fd)\n{\n  if (0 <= fd && fd < dirs_allocated && dirs[fd].name != NULL)\n    return dirs[fd].name;\n  /* At this point, fd is either invalid, or open but not a directory.\n     If dup2 fails, errno is correctly EBADF.  */\n  if (0 <= fd)\n    {\n      if (dup2 (fd, fd) == fd)\n        errno = ENOTDIR;\n    }\n  else\n    errno = EBADF;\n  return NULL;\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "const",
        "const",
        "char",
        "*\n_gl_directory_name (int fd)",
        "*"
      ]
    },
    "fchdir": {
      "start_point": [
        202,
        0
      ],
      "end_point": [
        207,
        1
      ],
      "content": "int\nfchdir (int fd)\n{\n  const char *name = _gl_directory_name (fd);\n  return name ? chdir (name) : -1;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/fcntl--.h": {},
  "findutils/findutils-4.6.0/gl/lib/fcntl-safer.h": {},
  "findutils/findutils-4.6.0/gl/lib/fcntl.c": {
    "dupfd": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        161,
        1
      ],
      "content": "static int\ndupfd (int oldfd, int newfd, int flags)\n{\n  /* Mingw has no way to create an arbitrary fd.  Iterate until all\n     file descriptors less than newfd are filled up.  */\n  HANDLE curr_process = GetCurrentProcess ();\n  HANDLE old_handle = (HANDLE) _get_osfhandle (oldfd);\n  unsigned char fds_to_close[OPEN_MAX_MAX / CHAR_BIT];\n  unsigned int fds_to_close_bound = 0;\n  int result;\n  BOOL inherit = flags & O_CLOEXEC ? FALSE : TRUE;\n  int mode;\n\n  if (newfd < 0 || getdtablesize () <= newfd)\n    {\n      errno = EINVAL;\n      return -1;\n    }\n  if (old_handle == INVALID_HANDLE_VALUE\n      || (mode = setmode (oldfd, O_BINARY)) == -1)\n    {\n      /* oldfd is not open, or is an unassigned standard file\n         descriptor.  */\n      errno = EBADF;\n      return -1;\n    }\n  setmode (oldfd, mode);\n  flags |= mode;\n\n  for (;;)\n    {\n      HANDLE new_handle;\n      int duplicated_fd;\n      unsigned int index;\n\n      if (!DuplicateHandle (curr_process,           /* SourceProcessHandle */\n                            old_handle,             /* SourceHandle */\n                            curr_process,           /* TargetProcessHandle */\n                            (PHANDLE) &new_handle,  /* TargetHandle */\n                            (DWORD) 0,              /* DesiredAccess */\n                            inherit,                /* InheritHandle */\n                            DUPLICATE_SAME_ACCESS)) /* Options */\n        {\n          switch (GetLastError ())\n            {\n              case ERROR_TOO_MANY_OPEN_FILES:\n                errno = EMFILE;\n                break;\n              case ERROR_INVALID_HANDLE:\n              case ERROR_INVALID_TARGET_HANDLE:\n              case ERROR_DIRECT_ACCESS_HANDLE:\n                errno = EBADF;\n                break;\n              case ERROR_INVALID_PARAMETER:\n              case ERROR_INVALID_FUNCTION:\n              case ERROR_INVALID_ACCESS:\n                errno = EINVAL;\n                break;\n              default:\n                errno = EACCES;\n                break;\n            }\n          result = -1;\n          break;\n        }\n      duplicated_fd = _open_osfhandle ((intptr_t) new_handle, flags);\n      if (duplicated_fd < 0)\n        {\n          CloseHandle (new_handle);\n          result = -1;\n          break;\n        }\n      if (newfd <= duplicated_fd)\n        {\n          result = duplicated_fd;\n          break;\n        }\n\n      /* Set the bit duplicated_fd in fds_to_close[].  */\n      index = (unsigned int) duplicated_fd / CHAR_BIT;\n      if (fds_to_close_bound <= index)\n        {\n          if (sizeof fds_to_close <= index)\n            /* Need to increase OPEN_MAX_MAX.  */\n            abort ();\n          memset (fds_to_close + fds_to_close_bound, '\\0',\n                  index + 1 - fds_to_close_bound);\n          fds_to_close_bound = index + 1;\n        }\n      fds_to_close[index] |= 1 << ((unsigned int) duplicated_fd % CHAR_BIT);\n    }\n\n  /* Close the previous fds that turned out to be too small.  */\n  {\n    int saved_errno = errno;\n    unsigned int duplicated_fd;\n\n    for (duplicated_fd = 0;\n         duplicated_fd < fds_to_close_bound * CHAR_BIT;\n         duplicated_fd++)\n      if ((fds_to_close[duplicated_fd / CHAR_BIT]\n           >> (duplicated_fd % CHAR_BIT))\n          & 1)\n        close (duplicated_fd);\n\n    errno = saved_errno;\n  }\n\n# if REPLACE_FCHDIR\n  if (0 <= result)\n    result = _gl_register_dup (oldfd, result);\n# endif\n  return result;\n}",
      "lines": 114,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_fcntl": {
      "start_point": [
        183,
        0
      ],
      "end_point": [
        326,
        1
      ],
      "content": "int\nrpl_fcntl (int fd, int action, /* arg */...)\n{\n  va_list arg;\n  int result = -1;\n  va_start (arg, action);\n  switch (action)\n    {\n\n#if !HAVE_FCNTL\n    case F_DUPFD:\n      {\n        int target = va_arg (arg, int);\n        result = dupfd (fd, target, 0);\n        break;\n      }\n#elif FCNTL_DUPFD_BUGGY || REPLACE_FCHDIR\n    case F_DUPFD:\n      {\n        int target = va_arg (arg, int);\n        /* Detect invalid target; needed for cygwin 1.5.x.  */\n        if (target < 0 || getdtablesize () <= target)\n          errno = EINVAL;\n        else\n          {\n            /* Haiku alpha 2 loses fd flags on original.  */\n            int flags = fcntl (fd, F_GETFD);\n            if (flags < 0)\n              {\n                result = -1;\n                break;\n              }\n            result = fcntl (fd, action, target);\n            if (0 <= result && fcntl (fd, F_SETFD, flags) == -1)\n              {\n                int saved_errno = errno;\n                close (result);\n                result = -1;\n                errno = saved_errno;\n              }\n# if REPLACE_FCHDIR\n            if (0 <= result)\n              result = _gl_register_dup (fd, result);\n# endif\n          }\n        break;\n      } /* F_DUPFD */\n#endif /* FCNTL_DUPFD_BUGGY || REPLACE_FCHDIR */\n\n    case F_DUPFD_CLOEXEC:\n      {\n        int target = va_arg (arg, int);\n\n#if !HAVE_FCNTL\n        result = dupfd (fd, target, O_CLOEXEC);\n        break;\n#else /* HAVE_FCNTL */\n        /* Try the system call first, if the headers claim it exists\n           (that is, if GNULIB_defined_F_DUPFD_CLOEXEC is 0), since we\n           may be running with a glibc that has the macro but with an\n           older kernel that does not support it.  Cache the\n           information on whether the system call really works, but\n           avoid caching failure if the corresponding F_DUPFD fails\n           for any reason.  0 = unknown, 1 = yes, -1 = no.  */\n        static int have_dupfd_cloexec = GNULIB_defined_F_DUPFD_CLOEXEC ? -1 : 0;\n        if (0 <= have_dupfd_cloexec)\n          {\n            result = fcntl (fd, action, target);\n            if (0 <= result || errno != EINVAL)\n              {\n                have_dupfd_cloexec = 1;\n# if REPLACE_FCHDIR\n                if (0 <= result)\n                  result = _gl_register_dup (fd, result);\n# endif\n              }\n            else\n              {\n                result = rpl_fcntl (fd, F_DUPFD, target);\n                if (result < 0)\n                  break;\n                have_dupfd_cloexec = -1;\n              }\n          }\n        else\n          result = rpl_fcntl (fd, F_DUPFD, target);\n        if (0 <= result && have_dupfd_cloexec == -1)\n          {\n            int flags = fcntl (result, F_GETFD);\n            if (flags < 0 || fcntl (result, F_SETFD, flags | FD_CLOEXEC) == -1)\n              {\n                int saved_errno = errno;\n                close (result);\n                errno = saved_errno;\n                result = -1;\n              }\n          }\n        break;\n#endif /* HAVE_FCNTL */\n      } /* F_DUPFD_CLOEXEC */\n\n#if !HAVE_FCNTL\n    case F_GETFD:\n      {\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n        HANDLE handle = (HANDLE) _get_osfhandle (fd);\n        DWORD flags;\n        if (handle == INVALID_HANDLE_VALUE\n            || GetHandleInformation (handle, &flags) == 0)\n          errno = EBADF;\n        else\n          result = (flags & HANDLE_FLAG_INHERIT) ? 0 : FD_CLOEXEC;\n# else /* !W32 */\n        /* Use dup2 to reject invalid file descriptors.  No way to\n           access this information, so punt.  */\n        if (0 <= dup2 (fd, fd))\n          result = 0;\n# endif /* !W32 */\n        break;\n      } /* F_GETFD */\n#endif /* !HAVE_FCNTL */\n\n      /* Implementing F_SETFD on mingw is not trivial - there is no\n         API for changing the O_NOINHERIT bit on an fd, and merely\n         changing the HANDLE_FLAG_INHERIT bit on the underlying handle\n         can lead to odd state.  It may be possible by duplicating the\n         handle, using _open_osfhandle with the right flags, then\n         using dup2 to move the duplicate onto the original, but that\n         is not supported for now.  */\n\n    default:\n      {\n#if HAVE_FCNTL\n        void *p = va_arg (arg, void *);\n        result = fcntl (fd, action, p);\n#else\n        errno = EINVAL;\n#endif\n        break;\n      }\n    }\n  va_end (arg);\n  return result;\n}",
      "lines": 144,
      "depth": 19,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/fcntl.in.h": {},
  "findutils/findutils-4.6.0/gl/lib/fd-hook.c": {
    "execute_close_hooks": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        42,
        1
      ],
      "content": "int\nexecute_close_hooks (const struct fd_hook *remaining_list, gl_close_fn primary,\n                     int fd)\n{\n  if (remaining_list == &anchor)\n    /* End of list reached.  */\n    return primary (fd);\n  else\n    return remaining_list->private_close_fn (remaining_list->private_next,\n                                             primary, fd);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "execute_all_close_hooks": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "int\nexecute_all_close_hooks (gl_close_fn primary, int fd)\n{\n  return execute_close_hooks (anchor.private_next, primary, fd);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "execute_ioctl_hooks": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "int\nexecute_ioctl_hooks (const struct fd_hook *remaining_list, gl_ioctl_fn primary,\n                     int fd, int request, void *arg)\n{\n  if (remaining_list == &anchor)\n    /* End of list reached.  */\n    return primary (fd, request, arg);\n  else\n    return remaining_list->private_ioctl_fn (remaining_list->private_next,\n                                             primary, fd, request, arg);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "execute_all_ioctl_hooks": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "int\nexecute_all_ioctl_hooks (gl_ioctl_fn primary,\n                         int fd, int request, void *arg)\n{\n  return execute_ioctl_hooks (anchor.private_next, primary, fd, request, arg);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "register_fd_hook": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "void\nregister_fd_hook (close_hook_fn close_hook, ioctl_hook_fn ioctl_hook, struct fd_hook *link)\n{\n  if (close_hook == NULL)\n    close_hook = execute_close_hooks;\n  if (ioctl_hook == NULL)\n    ioctl_hook = execute_ioctl_hooks;\n\n  if (link->private_next == NULL && link->private_prev == NULL)\n    {\n      /* Add the link to the doubly linked list.  */\n      link->private_next = anchor.private_next;\n      link->private_prev = &anchor;\n      link->private_close_fn = close_hook;\n      link->private_ioctl_fn = ioctl_hook;\n      anchor.private_next->private_prev = link;\n      anchor.private_next = link;\n    }\n  else\n    {\n      /* The link is already in use.  */\n      if (link->private_close_fn != close_hook\n          || link->private_ioctl_fn != ioctl_hook)\n        abort ();\n    }\n}",
      "lines": 26,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "unregister_fd_hook": {
      "start_point": [
        96,
        0
      ],
      "end_point": [
        113,
        1
      ],
      "content": "void\nunregister_fd_hook (struct fd_hook *link)\n{\n  struct fd_hook *next = link->private_next;\n  struct fd_hook *prev = link->private_prev;\n\n  if (next != NULL && prev != NULL)\n    {\n      /* The link is in use.  Remove it from the doubly linked list.  */\n      prev->private_next = next;\n      next->private_prev = prev;\n      /* Clear the link, to mark it unused.  */\n      link->private_next = NULL;\n      link->private_prev = NULL;\n      link->private_close_fn = NULL;\n      link->private_ioctl_fn = NULL;\n    }\n}",
      "lines": 18,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/fd-hook.h": {},
  "findutils/findutils-4.6.0/gl/lib/fd-safer.c": {
    "fd_safer": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "int\nfd_safer (int fd)\n{\n  if (STDIN_FILENO <= fd && fd <= STDERR_FILENO)\n    {\n      int f = dup_safer (fd);\n      int e = errno;\n      close (fd);\n      errno = e;\n      fd = f;\n    }\n\n  return fd;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/fdopendir.c": {
    "fdopendir": {
      "start_point": [
        64,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "DIR *\nfdopendir (int fd)\n{\n  DIR *dir = fdopendir_with_dup (fd, -1, NULL);\n\n  if (! REPLACE_FCHDIR && ! dir)\n    {\n      int saved_errno = errno;\n      if (EXPECTED_ERRNO (saved_errno))\n        {\n          struct saved_cwd cwd;\n          if (save_cwd (&cwd) != 0)\n            openat_save_fail (errno);\n          dir = fdopendir_with_dup (fd, -1, &cwd);\n          saved_errno = errno;\n          free_cwd (&cwd);\n          errno = saved_errno;\n        }\n    }\n\n  return dir;\n}",
      "lines": 22,
      "depth": 13,
      "decorators": [
        "DIR",
        "*\nfdopendir (int fd)",
        "*"
      ]
    },
    "fdopendir_with_dup": {
      "start_point": [
        98,
        0
      ],
      "end_point": [
        133,
        1
      ],
      "content": "static DIR *\nfdopendir_with_dup (int fd, int older_dupfd, struct saved_cwd const *cwd)\n{\n  int dupfd = dup (fd);\n  if (dupfd < 0 && errno == EMFILE)\n    dupfd = older_dupfd;\n  if (dupfd < 0)\n    return NULL;\n  else\n    {\n      DIR *dir;\n      int saved_errno;\n      if (dupfd < fd - 1 && dupfd != older_dupfd)\n        {\n          dir = fdopendir_with_dup (fd, dupfd, cwd);\n          saved_errno = errno;\n        }\n      else\n        {\n          close (fd);\n          dir = fd_clone_opendir (dupfd, cwd);\n          saved_errno = errno;\n          if (! dir)\n            {\n              int fd1 = dup (dupfd);\n              if (fd1 != fd)\n                openat_save_fail (fd1 < 0 ? errno : EBADF);\n            }\n        }\n\n      if (dupfd != older_dupfd)\n        close (dupfd);\n      errno = saved_errno;\n      return dir;\n    }\n}",
      "lines": 36,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "DIR",
        "*\nfdopendir_with_dup (int fd, int older_dupfd, struct saved_cwd const *cwd)",
        "*"
      ]
    },
    "fd_clone_opendir": {
      "start_point": [
        138,
        0
      ],
      "end_point": [
        187,
        1
      ],
      "content": "static DIR *\nfd_clone_opendir (int fd, struct saved_cwd const *cwd)\n{\n  if (REPLACE_FCHDIR || ! cwd)\n    {\n      DIR *dir = NULL;\n      int saved_errno = EOPNOTSUPP;\n      char buf[OPENAT_BUFFER_SIZE];\n      char *proc_file = openat_proc_name (buf, fd, \".\");\n      if (proc_file)\n        {\n          dir = opendir (proc_file);\n          saved_errno = errno;\n          if (proc_file != buf)\n            free (proc_file);\n        }\n# if REPLACE_FCHDIR\n      if (! dir && EXPECTED_ERRNO (saved_errno))\n        {\n          char const *name = _gl_directory_name (fd);\n          DIR *dp = name ? opendir (name) : NULL;\n\n          /* The caller has done an elaborate dance to arrange for opendir to\n             consume just the right file descriptor.  If dirfd returns -1,\n             though, we're on a system like mingw where opendir does not\n             consume a file descriptor.  Consume it via 'dup' instead.  */\n          if (dp && dirfd (dp) < 0)\n            dup (fd);\n\n          return dp;\n        }\n# endif\n      errno = saved_errno;\n      return dir;\n    }\n  else\n    {\n      if (fchdir (fd) != 0)\n        return NULL;\n      else\n        {\n          DIR *dir = opendir (\".\");\n          int saved_errno = errno;\n          if (restore_cwd (cwd) != 0)\n            openat_restore_fail (errno);\n          errno = saved_errno;\n          return dir;\n        }\n    }\n}",
      "lines": 50,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "DIR",
        "*\nfd_clone_opendir (int fd, struct saved_cwd const *cwd)",
        "*"
      ]
    },
    "rpl_fdopendir": {
      "start_point": [
        198,
        0
      ],
      "end_point": [
        210,
        1
      ],
      "content": "DIR *\nrpl_fdopendir (int fd)\n{\n  struct stat st;\n  if (fstat (fd, &st))\n    return NULL;\n  if (!S_ISDIR (st.st_mode))\n    {\n      errno = ENOTDIR;\n      return NULL;\n    }\n  return fdopendir (fd);\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "DIR",
        "*\nrpl_fdopendir (int fd)",
        "*"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/fflush.c": {
    "clear_ungetc_buffer_preserving_position": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "static void\nclear_ungetc_buffer_preserving_position (FILE *fp)\n{\n  if (fp->_flags & _IO_IN_BACKUP)\n    /* _IO_free_backup_area is a bit complicated.  Simply call fseek.  */\n    fseeko (fp, 0, SEEK_CUR);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "clear_ungetc_buffer": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "static void\nclear_ungetc_buffer (FILE *fp)\n{\n# if defined __sferror || defined __DragonFly__ || defined __ANDROID__\n  /* FreeBSD, NetBSD, OpenBSD, DragonFly, Mac OS X, Cygwin, Android */\n  if (HASUB (fp))\n    {\n      fp_->_p += fp_->_r;\n      fp_->_r = 0;\n    }\n# elif defined __EMX__              /* emx+gcc */\n  if (fp->_ungetc_count > 0)\n    {\n      fp->_ungetc_count = 0;\n      fp->_rcount = - fp->_rcount;\n    }\n# elif defined _IOERR               /* Minix, AIX, HP-UX, IRIX, OSF/1, Solaris, OpenServer, mingw, NonStop Kernel */\n  /* Nothing to do.  */\n# else                              /* other implementations */\n  fseeko (fp, 0, SEEK_CUR);\n# endif\n}",
      "lines": 22,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "disable_seek_optimization": {
      "start_point": [
        79,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "static int\ndisable_seek_optimization (FILE *fp)\n{\n  int saved_flags = fp_->_flags & (__SOPT | __SNPT);\n  fp_->_flags = (fp_->_flags & ~__SOPT) | __SNPT;\n  return saved_flags;\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "restore_seek_optimization": {
      "start_point": [
        87,
        0
      ],
      "end_point": [
        91,
        1
      ],
      "content": "static void\nrestore_seek_optimization (FILE *fp, int saved_flags)\n{\n  fp_->_flags = (fp_->_flags & ~(__SOPT | __SNPT)) | saved_flags;\n}",
      "lines": 5,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "update_fpos_cache": {
      "start_point": [
        95,
        0
      ],
      "end_point": [
        119,
        1
      ],
      "content": "static void\nupdate_fpos_cache (FILE *fp _GL_UNUSED_PARAMETER,\n                   off_t pos _GL_UNUSED_PARAMETER)\n{\n#  if defined __sferror || defined __DragonFly__ || defined __ANDROID__\n  /* FreeBSD, NetBSD, OpenBSD, DragonFly, Mac OS X, Cygwin, Android */\n#   if defined __CYGWIN__\n  /* fp_->_offset is typed as an integer.  */\n  fp_->_offset = pos;\n#   else\n  /* fp_->_offset is an fpos_t.  */\n  /* Use a union, since on NetBSD, the compilation flags determine\n     whether fpos_t is typedef'd to off_t or a struct containing a\n     single off_t member.  */\n  union\n    {\n      fpos_t f;\n      off_t o;\n    } u;\n  u.o = pos;\n  fp_->_offset = u.f;\n#   endif\n  fp_->_flags |= __SOFF;\n#  endif\n}",
      "lines": 25,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "rpl_fflush": {
      "start_point": [
        125,
        0
      ],
      "end_point": [
        228,
        1
      ],
      "content": "int\nrpl_fflush (FILE *stream)\n{\n  /* When stream is NULL, POSIX and C99 only require flushing of \"output\n     streams and update streams in which the most recent operation was not\n     input\", and all implementations do this.\n\n     When stream is \"an output stream or an update stream in which the most\n     recent operation was not input\", POSIX and C99 requires that fflush\n     writes out any buffered data, and all implementations do this.\n\n     When stream is, however, an input stream or an update stream in\n     which the most recent operation was input, C99 specifies nothing,\n     and POSIX only specifies behavior if the stream is seekable.\n     mingw, in particular, drops the input buffer, leaving the file\n     descriptor positioned at the end of the input buffer. I.e. ftell\n     (stream) is lost.  We don't want to call the implementation's\n     fflush in this case.\n\n     We test ! freading (stream) here, rather than fwriting (stream), because\n     what we need to know is whether the stream holds a \"read buffer\", and on\n     mingw this is indicated by _IOREAD, regardless of _IOWRT.  */\n  if (stream == NULL || ! freading (stream))\n    return fflush (stream);\n\n#if defined _IO_ftrylockfile || __GNU_LIBRARY__ == 1 /* GNU libc, BeOS, Haiku, Linux libc5 */\n\n  clear_ungetc_buffer_preserving_position (stream);\n\n  return fflush (stream);\n\n#else\n  {\n    /* Notes about the file-position indicator:\n       1) The file position indicator is incremented by fgetc() and decremented\n          by ungetc():\n          <http://www.opengroup.org/susv3/functions/fgetc.html>\n            \"... the fgetc() function shall ... advance the associated file\n             position indicator for the stream ...\"\n          <http://www.opengroup.org/susv3/functions/ungetc.html>\n            \"The file-position indicator is decremented by each successful\n             call to ungetc()...\"\n       2) <http://www.opengroup.org/susv3/functions/ungetc.html> says:\n            \"The value of the file-position indicator for the stream after\n             reading or discarding all pushed-back bytes shall be the same\n             as it was before the bytes were pushed back.\"\n          Here we are discarding all pushed-back bytes.  But more specifically,\n       3) <http://www.opengroup.org/austin/aardvark/latest/xshbug3.txt> says:\n            \"[After fflush(),] the file offset of the underlying open file\n             description shall be set to the file position of the stream, and\n             any characters pushed back onto the stream by ungetc() ... shall\n             be discarded.\"  */\n\n    /* POSIX does not specify fflush behavior for non-seekable input\n       streams.  Some implementations purge unread data, some return\n       EBADF, some do nothing.  */\n    off_t pos = ftello (stream);\n    if (pos == -1)\n      {\n        errno = EBADF;\n        return EOF;\n      }\n\n    /* Clear the ungetc buffer.  */\n    clear_ungetc_buffer (stream);\n\n    /* To get here, we must be flushing a seekable input stream, so the\n       semantics of fpurge are now appropriate to clear the buffer.  To\n       avoid losing data, the lseek is also necessary.  */\n    {\n      int result = fpurge (stream);\n      if (result != 0)\n        return result;\n    }\n\n# if (defined __sferror || defined __DragonFly__ || defined __ANDROID__) && defined __SNPT\n    /* FreeBSD, NetBSD, OpenBSD, DragonFly, Mac OS X, Cygwin, Android */\n\n    {\n      /* Disable seek optimization for the next fseeko call.  This tells the\n         following fseeko call to seek to the desired position directly, rather\n         than to seek to a block-aligned boundary.  */\n      int saved_flags = disable_seek_optimization (stream);\n      int result = fseeko (stream, pos, SEEK_SET);\n\n      restore_seek_optimization (stream, saved_flags);\n      return result;\n    }\n\n# else\n\n    pos = lseek (fileno (stream), pos, SEEK_SET);\n    if (pos == -1)\n      return EOF;\n    /* After a successful lseek, update the file descriptor's position cache\n       in the stream.  */\n    update_fpos_cache (stream, pos);\n\n    return 0;\n\n# endif\n  }\n#endif\n}",
      "lines": 104,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/file-set.c": {
    "record_file": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "void\nrecord_file (Hash_table *ht, char const *file, struct stat const *stats)\n{\n  struct F_triple *ent;\n\n  if (ht == NULL)\n    return;\n\n  ent = xmalloc (sizeof *ent);\n  ent->name = xstrdup (file);\n  ent->st_ino = stats->st_ino;\n  ent->st_dev = stats->st_dev;\n\n  {\n    struct F_triple *ent_from_table = hash_insert (ht, ent);\n    if (ent_from_table == NULL)\n      {\n        /* Insertion failed due to lack of memory.  */\n        xalloc_die ();\n      }\n\n    if (ent_from_table != ent)\n      {\n        /* There was alread a matching entry in the table, so ENT was\n           not inserted.  Free it.  */\n        triple_free (ent);\n      }\n  }\n}",
      "lines": 29,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "seen_file": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        73,
        1
      ],
      "content": "bool\nseen_file (Hash_table const *ht, char const *file,\n           struct stat const *stats)\n{\n  struct F_triple new_ent;\n\n  if (ht == NULL)\n    return false;\n\n  new_ent.name = (char *) file;\n  new_ent.st_ino = stats->st_ino;\n  new_ent.st_dev = stats->st_dev;\n\n  return !!hash_lookup (ht, &new_ent);\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/file-set.h": {},
  "findutils/findutils-4.6.0/gl/lib/fileblocks.c": {
    "st_blocks": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "off_t\nst_blocks (off_t size)\n{\n  off_t datablks = size / 512 + (size % 512 != 0);\n  off_t indrblks = 0;\n\n  if (datablks > NDIR)\n    {\n      indrblks = (datablks - NDIR - 1) / NINDIR + 1;\n\n      if (datablks > NDIR + NINDIR)\n        {\n          indrblks += (datablks - NDIR - NINDIR - 1) / (NINDIR * NINDIR) + 1;\n\n          if (datablks > NDIR + NINDIR + NINDIR * NINDIR)\n            indrblks++;\n        }\n    }\n\n  return datablks + indrblks;\n}",
      "lines": 21,
      "depth": 15,
      "decorators": [
        "off_t"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/filemode.c": {
    "ftypelet": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "static char\nftypelet (mode_t bits)\n{\n  /* These are the most common, so test for them first.  */\n  if (S_ISREG (bits))\n    return '-';\n  if (S_ISDIR (bits))\n    return 'd';\n\n  /* Other letters standardized by POSIX 1003.1-2004.  */\n  if (S_ISBLK (bits))\n    return 'b';\n  if (S_ISCHR (bits))\n    return 'c';\n  if (S_ISLNK (bits))\n    return 'l';\n  if (S_ISFIFO (bits))\n    return 'p';\n\n  /* Other file types (though not letters) standardized by POSIX.  */\n  if (S_ISSOCK (bits))\n    return 's';\n\n  /* Nonstandard file types.  */\n  if (S_ISCTG (bits))\n    return 'C';\n  if (S_ISDOOR (bits))\n    return 'D';\n  if (S_ISMPB (bits) || S_ISMPC (bits) || S_ISMPX (bits))\n    return 'm';\n  if (S_ISNWK (bits))\n    return 'n';\n  if (S_ISPORT (bits))\n    return 'P';\n  if (S_ISWHT (bits))\n    return 'w';\n\n  return '?';\n}",
      "lines": 39,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "char"
      ]
    },
    "strmode": {
      "start_point": [
        94,
        0
      ],
      "end_point": [
        115,
        1
      ],
      "content": "void\nstrmode (mode_t mode, char *str)\n{\n  str[0] = ftypelet (mode);\n  str[1] = mode & S_IRUSR ? 'r' : '-';\n  str[2] = mode & S_IWUSR ? 'w' : '-';\n  str[3] = (mode & S_ISUID\n            ? (mode & S_IXUSR ? 's' : 'S')\n            : (mode & S_IXUSR ? 'x' : '-'));\n  str[4] = mode & S_IRGRP ? 'r' : '-';\n  str[5] = mode & S_IWGRP ? 'w' : '-';\n  str[6] = (mode & S_ISGID\n            ? (mode & S_IXGRP ? 's' : 'S')\n            : (mode & S_IXGRP ? 'x' : '-'));\n  str[7] = mode & S_IROTH ? 'r' : '-';\n  str[8] = mode & S_IWOTH ? 'w' : '-';\n  str[9] = (mode & S_ISVTX\n            ? (mode & S_IXOTH ? 't' : 'T')\n            : (mode & S_IXOTH ? 'x' : '-'));\n  str[10] = ' ';\n  str[11] = '\\0';\n}",
      "lines": 22,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "filemodestring": {
      "start_point": [
        164,
        0
      ],
      "end_point": [
        179,
        1
      ],
      "content": "void\nfilemodestring (struct stat const *statp, char *str)\n{\n  strmode (statp->st_mode, str);\n\n  if (S_TYPEISSEM (statp))\n    str[0] = 'F';\n  else if (IS_MIGRATED_FILE (statp))\n    str[0] = 'M';\n  else if (S_TYPEISMQ (statp))\n    str[0] = 'Q';\n  else if (S_TYPEISSHM (statp))\n    str[0] = 'S';\n  else if (S_TYPEISTMO (statp))\n    str[0] = 'T';\n}",
      "lines": 16,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/filemode.h": {},
  "findutils/findutils-4.6.0/gl/lib/filename.h": {},
  "findutils/findutils-4.6.0/gl/lib/filenamecat-lgpl.c": {
    "longest_relative_suffix": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        42,
        1
      ],
      "content": "static char const * _GL_ATTRIBUTE_PURE\nlongest_relative_suffix (char const *f)\n{\n  for (f += FILE_SYSTEM_PREFIX_LEN (f); ISSLASH (*f); f++)\n    continue;\n  return f;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "char",
        "const",
        "const",
        "* _GL_ATTRIBUTE_PURE\nlongest_relative_suffix (char const *f)",
        "*",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "mfile_name_concat": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        87,
        1
      ],
      "content": "char *\nmfile_name_concat (char const *dir, char const *abase, char **base_in_result)\n{\n  char const *dirbase = last_component (dir);\n  size_t dirbaselen = base_len (dirbase);\n  size_t dirlen = dirbase - dir + dirbaselen;\n  size_t needs_separator = (dirbaselen && ! ISSLASH (dirbase[dirbaselen - 1]));\n\n  char const *base = longest_relative_suffix (abase);\n  size_t baselen = strlen (base);\n\n  char *p_concat = malloc (dirlen + needs_separator + baselen + 1);\n  char *p;\n\n  if (p_concat == NULL)\n    return NULL;\n\n  p = mempcpy (p_concat, dir, dirlen);\n  *p = DIRECTORY_SEPARATOR;\n  p += needs_separator;\n\n  if (base_in_result)\n    *base_in_result = p - IS_ABSOLUTE_FILE_NAME (abase);\n\n  p = mempcpy (p, base, baselen);\n  *p = '\\0';\n\n  return p_concat;\n}",
      "lines": 29,
      "depth": 12,
      "decorators": [
        "char",
        "*\nmfile_name_concat (char const *dir, char const *abase, char **base_in_result)",
        "*"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/filenamecat.h": {},
  "findutils/findutils-4.6.0/gl/lib/float+.h": {},
  "findutils/findutils-4.6.0/gl/lib/float.c": {},
  "findutils/findutils-4.6.0/gl/lib/float.in.h": {},
  "findutils/findutils-4.6.0/gl/lib/fnmatch.c": {
    "is_char_class": {
      "start_point": [
        205,
        0
      ],
      "end_point": [
        262,
        1
      ],
      "content": "static wctype_t\nis_char_class (const wchar_t *wcs)\n{\n  char s[CHAR_CLASS_MAX_LENGTH + 1];\n  char *cp = s;\n\n  do\n    {\n      /* Test for a printable character from the portable character set.  */\n#  ifdef _LIBC\n      if (*wcs < 0x20 || *wcs > 0x7e\n          || *wcs == 0x24 || *wcs == 0x40 || *wcs == 0x60)\n        return (wctype_t) 0;\n#  else\n      switch (*wcs)\n        {\n        case L' ': case L'!': case L'\"': case L'#': case L'%':\n        case L'&': case L'\\'': case L'(': case L')': case L'*':\n        case L'+': case L',': case L'-': case L'.': case L'/':\n        case L'0': case L'1': case L'2': case L'3': case L'4':\n        case L'5': case L'6': case L'7': case L'8': case L'9':\n        case L':': case L';': case L'<': case L'=': case L'>':\n        case L'?':\n        case L'A': case L'B': case L'C': case L'D': case L'E':\n        case L'F': case L'G': case L'H': case L'I': case L'J':\n        case L'K': case L'L': case L'M': case L'N': case L'O':\n        case L'P': case L'Q': case L'R': case L'S': case L'T':\n        case L'U': case L'V': case L'W': case L'X': case L'Y':\n        case L'Z':\n        case L'[': case L'\\\\': case L']': case L'^': case L'_':\n        case L'a': case L'b': case L'c': case L'd': case L'e':\n        case L'f': case L'g': case L'h': case L'i': case L'j':\n        case L'k': case L'l': case L'm': case L'n': case L'o':\n        case L'p': case L'q': case L'r': case L's': case L't':\n        case L'u': case L'v': case L'w': case L'x': case L'y':\n        case L'z': case L'{': case L'|': case L'}': case L'~':\n          break;\n        default:\n          return (wctype_t) 0;\n        }\n#  endif\n\n      /* Avoid overrunning the buffer.  */\n      if (cp == s + CHAR_CLASS_MAX_LENGTH)\n        return (wctype_t) 0;\n\n      *cp++ = (char) *wcs++;\n    }\n  while (*wcs != L'\\0');\n\n  *cp = '\\0';\n\n#  ifdef _LIBC\n  return __wctype (s);\n#  else\n  return wctype (s);\n#  endif\n}",
      "lines": 58,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "wctype_t"
      ]
    },
    "fnmatch": {
      "start_point": [
        269,
        0
      ],
      "end_point": [
        337,
        1
      ],
      "content": "int\nfnmatch (const char *pattern, const char *string, int flags)\n{\n# if HANDLE_MULTIBYTE\n#  define ALLOCA_LIMIT 2000\n  if (__builtin_expect (MB_CUR_MAX, 1) != 1)\n    {\n      mbstate_t ps;\n      size_t patsize;\n      size_t strsize;\n      size_t totsize;\n      wchar_t *wpattern;\n      wchar_t *wstring;\n      int res;\n\n      /* Calculate the size needed to convert the strings to\n         wide characters.  */\n      memset (&ps, '\\0', sizeof (ps));\n      patsize = mbsrtowcs (NULL, &pattern, 0, &ps) + 1;\n      if (__builtin_expect (patsize != 0, 1))\n        {\n          assert (mbsinit (&ps));\n          strsize = mbsrtowcs (NULL, &string, 0, &ps) + 1;\n          if (__builtin_expect (strsize != 0, 1))\n            {\n              assert (mbsinit (&ps));\n              totsize = patsize + strsize;\n              if (__builtin_expect (! (patsize <= totsize\n                                       && totsize <= SIZE_MAX / sizeof (wchar_t)),\n                                    0))\n                {\n                  errno = ENOMEM;\n                  return -1;\n                }\n\n              /* Allocate room for the wide characters.  */\n              if (__builtin_expect (totsize < ALLOCA_LIMIT, 1))\n                wpattern = (wchar_t *) alloca (totsize * sizeof (wchar_t));\n              else\n                {\n                  wpattern = malloc (totsize * sizeof (wchar_t));\n                  if (__builtin_expect (! wpattern, 0))\n                    {\n                      errno = ENOMEM;\n                      return -1;\n                    }\n                }\n              wstring = wpattern + patsize;\n\n              /* Convert the strings into wide characters.  */\n              mbsrtowcs (wpattern, &pattern, patsize, &ps);\n              assert (mbsinit (&ps));\n              mbsrtowcs (wstring, &string, strsize, &ps);\n\n              res = internal_fnwmatch (wpattern, wstring, wstring + strsize - 1,\n                                       flags & FNM_PERIOD, flags);\n\n              if (__builtin_expect (! (totsize < ALLOCA_LIMIT), 0))\n                free (wpattern);\n              return res;\n            }\n        }\n    }\n\n# endif /* HANDLE_MULTIBYTE */\n\n  return internal_fnmatch (pattern, string, string + strlen (string),\n                           flags & FNM_PERIOD, flags);\n}",
      "lines": 69,
      "depth": 21,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/fnmatch.in.h": {},
  "findutils/findutils-4.6.0/gl/lib/fnmatch_loop.c": {
    "internal_function": [
      {
        "start_point": [
          23,
          0
        ],
        "end_point": [
          981,
          1
        ],
        "content": "static int\ninternal_function\nFCT (const CHAR *pattern, const CHAR *string, const CHAR *string_end,\n     bool no_leading_period, int flags)\n{\n  register const CHAR *p = pattern, *n = string;\n  register UCHAR c;\n#ifdef _LIBC\n# if WIDE_CHAR_VERSION\n  const char *collseq = (const char *)\n    _NL_CURRENT(LC_COLLATE, _NL_COLLATE_COLLSEQWC);\n# else\n  const UCHAR *collseq = (const UCHAR *)\n    _NL_CURRENT(LC_COLLATE, _NL_COLLATE_COLLSEQMB);\n# endif\n#endif\n\n  while ((c = *p++) != L_('\\0'))\n    {\n      bool new_no_leading_period = false;\n      c = FOLD (c);\n\n      switch (c)\n        {\n        case L_('?'):\n          if (__builtin_expect (flags & FNM_EXTMATCH, 0) && *p == '(')\n            {\n              int res;\n\n              res = EXT (c, p, n, string_end, no_leading_period,\n                         flags);\n              if (res != -1)\n                return res;\n            }\n\n          if (n == string_end)\n            return FNM_NOMATCH;\n          else if (*n == L_('/') && (flags & FNM_FILE_NAME))\n            return FNM_NOMATCH;\n          else if (*n == L_('.') && no_leading_period)\n            return FNM_NOMATCH;\n          break;\n\n        case L_('\\\\'):\n          if (!(flags & FNM_NOESCAPE))\n            {\n              c = *p++;\n              if (c == L_('\\0'))\n                /* Trailing \\ loses.  */\n                return FNM_NOMATCH;\n              c = FOLD (c);\n            }\n          if (n == string_end || FOLD ((UCHAR) *n) != c)\n            return FNM_NOMATCH;\n          break;\n\n        case L_('*'):\n          if (__builtin_expect (flags & FNM_EXTMATCH, 0) && *p == '(')\n            {\n              int res;\n\n              res = EXT (c, p, n, string_end, no_leading_period,\n                         flags);\n              if (res != -1)\n                return res;\n            }\n\n          if (n != string_end && *n == L_('.') && no_leading_period)\n            return FNM_NOMATCH;\n\n          for (c = *p++; c == L_('?') || c == L_('*'); c = *p++)\n            {\n              if (*p == L_('(') && (flags & FNM_EXTMATCH) != 0)\n                {\n                  const CHAR *endp = END (p);\n                  if (endp != p)\n                    {\n                      /* This is a pattern.  Skip over it.  */\n                      p = endp;\n                      continue;\n                    }\n                }\n\n              if (c == L_('?'))\n                {\n                  /* A ? needs to match one character.  */\n                  if (n == string_end)\n                    /* There isn't another character; no match.  */\n                    return FNM_NOMATCH;\n                  else if (*n == L_('/')\n                           && __builtin_expect (flags & FNM_FILE_NAME, 0))\n                    /* A slash does not match a wildcard under\n                       FNM_FILE_NAME.  */\n                    return FNM_NOMATCH;\n                  else\n                    /* One character of the string is consumed in matching\n                       this ? wildcard, so *??? won't match if there are\n                       less than three characters.  */\n                    ++n;\n                }\n            }\n\n          if (c == L_('\\0'))\n            /* The wildcard(s) is/are the last element of the pattern.\n               If the name is a file name and contains another slash\n               this means it cannot match, unless the FNM_LEADING_DIR\n               flag is set.  */\n            {\n              int result = (flags & FNM_FILE_NAME) == 0 ? 0 : FNM_NOMATCH;\n\n              if (flags & FNM_FILE_NAME)\n                {\n                  if (flags & FNM_LEADING_DIR)\n                    result = 0;\n                  else\n                    {\n                      if (MEMCHR (n, L_('/'), string_end - n) == NULL)\n                        result = 0;\n                    }\n                }\n\n              return result;\n            }\n          else\n            {\n              const CHAR *endp;\n\n              endp = MEMCHR (n, (flags & FNM_FILE_NAME) ? L_('/') : L_('\\0'),\n                             string_end - n);\n              if (endp == NULL)\n                endp = string_end;\n\n              if (c == L_('[')\n                  || (__builtin_expect (flags & FNM_EXTMATCH, 0) != 0\n                      && (c == L_('@') || c == L_('+') || c == L_('!'))\n                      && *p == L_('(')))\n                {\n                  int flags2 = ((flags & FNM_FILE_NAME)\n                                ? flags : (flags & ~FNM_PERIOD));\n                  bool no_leading_period2 = no_leading_period;\n\n                  for (--p; n < endp; ++n, no_leading_period2 = false)\n                    if (FCT (p, n, string_end, no_leading_period2, flags2)\n                        == 0)\n                      return 0;\n                }\n              else if (c == L_('/') && (flags & FNM_FILE_NAME))\n                {\n                  while (n < string_end && *n != L_('/'))\n                    ++n;\n                  if (n < string_end && *n == L_('/')\n                      && (FCT (p, n + 1, string_end, flags & FNM_PERIOD, flags)\n                          == 0))\n                    return 0;\n                }\n              else\n                {\n                  int flags2 = ((flags & FNM_FILE_NAME)\n                                ? flags : (flags & ~FNM_PERIOD));\n                  int no_leading_period2 = no_leading_period;\n\n                  if (c == L_('\\\\') && !(flags & FNM_NOESCAPE))\n                    c = *p;\n                  c = FOLD (c);\n                  for (--p; n < endp; ++n, no_leading_period2 = false)\n                    if (FOLD ((UCHAR) *n) == c\n                        && (FCT (p, n, string_end, no_leading_period2, flags2)\n                            == 0))\n                      return 0;\n                }\n            }\n\n          /* If we come here no match is possible with the wildcard.  */\n          return FNM_NOMATCH;\n\n        case L_('['):\n          {\n            /* Nonzero if the sense of the character class is inverted.  */\n            const CHAR *p_init = p;\n            const CHAR *n_init = n;\n            register bool not;\n            CHAR cold;\n            UCHAR fn;\n\n            if (posixly_correct == 0)\n              posixly_correct = getenv (\"POSIXLY_CORRECT\") != NULL ? 1 : -1;\n\n            if (n == string_end)\n              return FNM_NOMATCH;\n\n            if (*n == L_('.') && no_leading_period)\n              return FNM_NOMATCH;\n\n            if (*n == L_('/') && (flags & FNM_FILE_NAME))\n              /* '/' cannot be matched.  */\n              return FNM_NOMATCH;\n\n            not = (*p == L_('!') || (posixly_correct < 0 && *p == L_('^')));\n            if (not)\n              ++p;\n\n            fn = FOLD ((UCHAR) *n);\n\n            c = *p++;\n            for (;;)\n              {\n\t\tbool is_range = false;\n\n                if (!(flags & FNM_NOESCAPE) && c == L_('\\\\'))\n                  {\n                    if (*p == L_('\\0'))\n                      return FNM_NOMATCH;\n                    c = FOLD ((UCHAR) *p);\n                    ++p;\n\n                    goto normal_bracket;\n                  }\n                else if (c == L_('[') && *p == L_(':'))\n                  {\n                    /* Leave room for the null.  */\n                    CHAR str[CHAR_CLASS_MAX_LENGTH + 1];\n                    size_t c1 = 0;\n#if defined _LIBC || WIDE_CHAR_SUPPORT\n                    wctype_t wt;\n#endif\n                    const CHAR *startp = p;\n\n                    for (;;)\n                      {\n                        if (c1 == CHAR_CLASS_MAX_LENGTH)\n                          /* The name is too long and therefore the pattern\n                             is ill-formed.  */\n                          return FNM_NOMATCH;\n\n                        c = *++p;\n                        if (c == L_(':') && p[1] == L_(']'))\n                          {\n                            p += 2;\n                            break;\n                          }\n                        if (c < L_('a') || c >= L_('z'))\n                          {\n                            /* This cannot possibly be a character class name.\n                               Match it as a normal range.  */\n                            p = startp;\n                            c = L_('[');\n                            goto normal_bracket;\n                          }\n                        str[c1++] = c;\n                      }\n                    str[c1] = L_('\\0');\n\n#if defined _LIBC || WIDE_CHAR_SUPPORT\n                    wt = IS_CHAR_CLASS (str);\n                    if (wt == 0)\n                      /* Invalid character class name.  */\n                      return FNM_NOMATCH;\n\n# if defined _LIBC && ! WIDE_CHAR_VERSION\n                    /* The following code is glibc specific but does\n                       there a good job in speeding up the code since\n                       we can avoid the btowc() call.  */\n                    if (_ISCTYPE ((UCHAR) *n, wt))\n                      goto matched;\n# else\n                    if (ISWCTYPE (BTOWC ((UCHAR) *n), wt))\n                      goto matched;\n# endif\n#else\n                    if ((STREQ (str, L_(\"alnum\")) && isalnum ((UCHAR) *n))\n                        || (STREQ (str, L_(\"alpha\")) && isalpha ((UCHAR) *n))\n                        || (STREQ (str, L_(\"blank\")) && isblank ((UCHAR) *n))\n                        || (STREQ (str, L_(\"cntrl\")) && iscntrl ((UCHAR) *n))\n                        || (STREQ (str, L_(\"digit\")) && isdigit ((UCHAR) *n))\n                        || (STREQ (str, L_(\"graph\")) && isgraph ((UCHAR) *n))\n                        || (STREQ (str, L_(\"lower\")) && islower ((UCHAR) *n))\n                        || (STREQ (str, L_(\"print\")) && isprint ((UCHAR) *n))\n                        || (STREQ (str, L_(\"punct\")) && ispunct ((UCHAR) *n))\n                        || (STREQ (str, L_(\"space\")) && isspace ((UCHAR) *n))\n                        || (STREQ (str, L_(\"upper\")) && isupper ((UCHAR) *n))\n                        || (STREQ (str, L_(\"xdigit\")) && isxdigit ((UCHAR) *n)))\n                      goto matched;\n#endif\n                    c = *p++;\n                  }\n#ifdef _LIBC\n                else if (c == L_('[') && *p == L_('='))\n                  {\n                    UCHAR str[1];\n                    uint32_t nrules =\n                      _NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_NRULES);\n                    const CHAR *startp = p;\n\n                    c = *++p;\n                    if (c == L_('\\0'))\n                      {\n                        p = startp;\n                        c = L_('[');\n                        goto normal_bracket;\n                      }\n                    str[0] = c;\n\n                    c = *++p;\n                    if (c != L_('=') || p[1] != L_(']'))\n                      {\n                        p = startp;\n                        c = L_('[');\n                        goto normal_bracket;\n                      }\n                    p += 2;\n\n                    if (nrules == 0)\n                      {\n                        if ((UCHAR) *n == str[0])\n                          goto matched;\n                      }\n                    else\n                      {\n                        const int32_t *table;\n# if WIDE_CHAR_VERSION\n                        const int32_t *weights;\n                        const int32_t *extra;\n# else\n                        const unsigned char *weights;\n                        const unsigned char *extra;\n# endif\n                        const int32_t *indirect;\n                        int32_t idx;\n                        const UCHAR *cp = (const UCHAR *) str;\n\n                        /* This #include defines a local function!  */\n# if WIDE_CHAR_VERSION\n#  include <locale/weightwc.h>\n# else\n#  include <locale/weight.h>\n# endif\n\n# if WIDE_CHAR_VERSION\n                        table = (const int32_t *)\n                          _NL_CURRENT (LC_COLLATE, _NL_COLLATE_TABLEWC);\n                        weights = (const int32_t *)\n                          _NL_CURRENT (LC_COLLATE, _NL_COLLATE_WEIGHTWC);\n                        extra = (const int32_t *)\n                          _NL_CURRENT (LC_COLLATE, _NL_COLLATE_EXTRAWC);\n                        indirect = (const int32_t *)\n                          _NL_CURRENT (LC_COLLATE, _NL_COLLATE_INDIRECTWC);\n# else\n                        table = (const int32_t *)\n                          _NL_CURRENT (LC_COLLATE, _NL_COLLATE_TABLEMB);\n                        weights = (const unsigned char *)\n                          _NL_CURRENT (LC_COLLATE, _NL_COLLATE_WEIGHTMB);\n                        extra = (const unsigned char *)\n                          _NL_CURRENT (LC_COLLATE, _NL_COLLATE_EXTRAMB);\n                        indirect = (const int32_t *)\n                          _NL_CURRENT (LC_COLLATE, _NL_COLLATE_INDIRECTMB);\n# endif\n\n                        idx = findidx (&cp);\n                        if (idx != 0)\n                          {\n                            /* We found a table entry.  Now see whether the\n                               character we are currently at has the same\n                               equivalence class value.  */\n                            int len = weights[idx & 0xffffff];\n                            int32_t idx2;\n                            const UCHAR *np = (const UCHAR *) n;\n\n                            idx2 = findidx (&np);\n                            if (idx2 != 0\n                                && (idx >> 24) == (idx2 >> 24)\n                                && len == weights[idx2 & 0xffffff])\n                              {\n                                int cnt = 0;\n\n                                idx &= 0xffffff;\n                                idx2 &= 0xffffff;\n\n                                while (cnt < len\n                                       && (weights[idx + 1 + cnt]\n                                           == weights[idx2 + 1 + cnt]))\n                                  ++cnt;\n\n                                if (cnt == len)\n                                  goto matched;\n                              }\n                          }\n                      }\n\n                    c = *p++;\n                  }\n#endif\n                else if (c == L_('\\0'))\n                  {\n                    /* [ unterminated, treat as normal character.  */\n                    p = p_init;\n                    n = n_init;\n                    c = L_('[');\n                    goto normal_match;\n                  }\n                else\n                  {\n#ifdef _LIBC\n                    bool is_seqval = false;\n\n                    if (c == L_('[') && *p == L_('.'))\n                      {\n                        uint32_t nrules =\n                          _NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_NRULES);\n                        const CHAR *startp = p;\n                        size_t c1 = 0;\n\n                        while (1)\n                          {\n                            c = *++p;\n                            if (c == L_('.') && p[1] == L_(']'))\n                              {\n                                p += 2;\n                                break;\n                              }\n                            if (c == '\\0')\n                              return FNM_NOMATCH;\n                            ++c1;\n                          }\n\n                        /* We have to handling the symbols differently in\n                           ranges since then the collation sequence is\n                           important.  */\n                        is_range = *p == L_('-') && p[1] != L_('\\0');\n\n                        if (nrules == 0)\n                          {\n                            /* There are no names defined in the collation\n                               data.  Therefore we only accept the trivial\n                               names consisting of the character itself.  */\n                            if (c1 != 1)\n                              return FNM_NOMATCH;\n\n                            if (!is_range && *n == startp[1])\n                              goto matched;\n\n                            cold = startp[1];\n                            c = *p++;\n                          }\n                        else\n                          {\n                            int32_t table_size;\n                            const int32_t *symb_table;\n# ifdef WIDE_CHAR_VERSION\n                            char str[c1];\n                            size_t strcnt;\n# else\n#  define str (startp + 1)\n# endif\n                            const unsigned char *extra;\n                            int32_t idx;\n                            int32_t elem;\n                            int32_t second;\n                            int32_t hash;\n\n# ifdef WIDE_CHAR_VERSION\n                            /* We have to convert the name to a single-byte\n                               string.  This is possible since the names\n                               consist of ASCII characters and the internal\n                               representation is UCS4.  */\n                            for (strcnt = 0; strcnt < c1; ++strcnt)\n                              str[strcnt] = startp[1 + strcnt];\n# endif\n\n                            table_size =\n                              _NL_CURRENT_WORD (LC_COLLATE,\n                                                _NL_COLLATE_SYMB_HASH_SIZEMB);\n                            symb_table = (const int32_t *)\n                              _NL_CURRENT (LC_COLLATE,\n                                           _NL_COLLATE_SYMB_TABLEMB);\n                            extra = (const unsigned char *)\n                              _NL_CURRENT (LC_COLLATE,\n                                           _NL_COLLATE_SYMB_EXTRAMB);\n\n                            /* Locate the character in the hashing table.  */\n                            hash = elem_hash (str, c1);\n\n                            idx = 0;\n                            elem = hash % table_size;\n                            if (symb_table[2 * elem] != 0)\n                              {\n                                second = hash % (table_size - 2) + 1;\n\n                                do\n                                  {\n                                    /* First compare the hashing value.  */\n                                    if (symb_table[2 * elem] == hash\n                                        && (c1\n                                            == extra[symb_table[2 * elem + 1]])\n                                        && memcmp (str,\n                                                   &extra[symb_table[2 * elem\n                                                                     + 1]\n                                                          + 1], c1) == 0)\n                                      {\n                                        /* Yep, this is the entry.  */\n                                        idx = symb_table[2 * elem + 1];\n                                        idx += 1 + extra[idx];\n                                        break;\n                                      }\n\n                                    /* Next entry.  */\n                                    elem += second;\n                                  }\n                                while (symb_table[2 * elem] != 0);\n                              }\n\n                            if (symb_table[2 * elem] != 0)\n                              {\n                                /* Compare the byte sequence but only if\n                                   this is not part of a range.  */\n# ifdef WIDE_CHAR_VERSION\n                                int32_t *wextra;\n\n                                idx += 1 + extra[idx];\n                                /* Adjust for the alignment.  */\n                                idx = (idx + 3) & ~3;\n\n                                wextra = (int32_t *) &extra[idx + 4];\n# endif\n\n                                if (! is_range)\n                                  {\n# ifdef WIDE_CHAR_VERSION\n                                    for (c1 = 0;\n                                         (int32_t) c1 < wextra[idx];\n                                         ++c1)\n                                      if (n[c1] != wextra[1 + c1])\n                                        break;\n\n                                    if ((int32_t) c1 == wextra[idx])\n                                      goto matched;\n# else\n                                    for (c1 = 0; c1 < extra[idx]; ++c1)\n                                      if (n[c1] != extra[1 + c1])\n                                        break;\n\n                                    if (c1 == extra[idx])\n                                      goto matched;\n# endif\n                                  }\n\n                                /* Get the collation sequence value.  */\n                                is_seqval = true;\n# ifdef WIDE_CHAR_VERSION\n                                cold = wextra[1 + wextra[idx]];\n# else\n                                /* Adjust for the alignment.  */\n                                idx += 1 + extra[idx];\n                                idx = (idx + 3) & ~4;\n                                cold = *((int32_t *) &extra[idx]);\n# endif\n\n                                c = *p++;\n                              }\n                            else if (c1 == 1)\n                              {\n                                /* No valid character.  Match it as a\n                                   single byte.  */\n                                if (!is_range && *n == str[0])\n                                  goto matched;\n\n                                cold = str[0];\n                                c = *p++;\n                              }\n                            else\n                              return FNM_NOMATCH;\n                          }\n                      }\n                    else\n# undef str\n#endif\n                      {\n                        c = FOLD (c);\n                      normal_bracket:\n\n                        /* We have to handling the symbols differently in\n                           ranges since then the collation sequence is\n                           important.  */\n                        is_range = (*p == L_('-') && p[1] != L_('\\0')\n                                    && p[1] != L_(']'));\n\n                        if (!is_range && c == fn)\n                          goto matched;\n\n#if _LIBC\n                        /* This is needed if we goto normal_bracket; from\n                           outside of is_seqval's scope.  */\n                        is_seqval = false;\n#endif\n\n                        cold = c;\n                        c = *p++;\n                      }\n\n                    if (c == L_('-') && *p != L_(']'))\n                      {\n#if _LIBC\n                        /* We have to find the collation sequence\n                           value for C.  Collation sequence is nothing\n                           we can regularly access.  The sequence\n                           value is defined by the order in which the\n                           definitions of the collation values for the\n                           various characters appear in the source\n                           file.  A strange concept, nowhere\n                           documented.  */\n                        uint32_t fcollseq;\n                        uint32_t lcollseq;\n                        UCHAR cend = *p++;\n\n# ifdef WIDE_CHAR_VERSION\n                        /* Search in the 'names' array for the characters.  */\n                        fcollseq = __collseq_table_lookup (collseq, fn);\n                        if (fcollseq == ~((uint32_t) 0))\n                          /* XXX We don't know anything about the character\n                             we are supposed to match.  This means we are\n                             failing.  */\n                          goto range_not_matched;\n\n                        if (is_seqval)\n                          lcollseq = cold;\n                        else\n                          lcollseq = __collseq_table_lookup (collseq, cold);\n# else\n                        fcollseq = collseq[fn];\n                        lcollseq = is_seqval ? cold : collseq[(UCHAR) cold];\n# endif\n\n                        is_seqval = false;\n                        if (cend == L_('[') && *p == L_('.'))\n                          {\n                            uint32_t nrules =\n                              _NL_CURRENT_WORD (LC_COLLATE,\n                                                _NL_COLLATE_NRULES);\n                            const CHAR *startp = p;\n                            size_t c1 = 0;\n\n                            while (1)\n                              {\n                                c = *++p;\n                                if (c == L_('.') && p[1] == L_(']'))\n                                  {\n                                    p += 2;\n                                    break;\n                                  }\n                                if (c == '\\0')\n                                  return FNM_NOMATCH;\n                                ++c1;\n                              }\n\n                            if (nrules == 0)\n                              {\n                                /* There are no names defined in the\n                                   collation data.  Therefore we only\n                                   accept the trivial names consisting\n                                   of the character itself.  */\n                                if (c1 != 1)\n                                  return FNM_NOMATCH;\n\n                                cend = startp[1];\n                              }\n                            else\n                              {\n                                int32_t table_size;\n                                const int32_t *symb_table;\n# ifdef WIDE_CHAR_VERSION\n                                char str[c1];\n                                size_t strcnt;\n# else\n#  define str (startp + 1)\n# endif\n                                const unsigned char *extra;\n                                int32_t idx;\n                                int32_t elem;\n                                int32_t second;\n                                int32_t hash;\n\n# ifdef WIDE_CHAR_VERSION\n                                /* We have to convert the name to a single-byte\n                                   string.  This is possible since the names\n                                   consist of ASCII characters and the internal\n                                   representation is UCS4.  */\n                                for (strcnt = 0; strcnt < c1; ++strcnt)\n                                  str[strcnt] = startp[1 + strcnt];\n# endif\n\n                                table_size =\n                                  _NL_CURRENT_WORD (LC_COLLATE,\n                                                    _NL_COLLATE_SYMB_HASH_SIZEMB);\n                                symb_table = (const int32_t *)\n                                  _NL_CURRENT (LC_COLLATE,\n                                               _NL_COLLATE_SYMB_TABLEMB);\n                                extra = (const unsigned char *)\n                                  _NL_CURRENT (LC_COLLATE,\n                                               _NL_COLLATE_SYMB_EXTRAMB);\n\n                                /* Locate the character in the hashing\n                                   table.  */\n                                hash = elem_hash (str, c1);\n\n                                idx = 0;\n                                elem = hash % table_size;\n                                if (symb_table[2 * elem] != 0)\n                                  {\n                                    second = hash % (table_size - 2) + 1;\n\n                                    do\n                                      {\n                                        /* First compare the hashing value.  */\n                                        if (symb_table[2 * elem] == hash\n                                            && (c1\n                                                == extra[symb_table[2 * elem + 1]])\n                                            && memcmp (str,\n                                                       &extra[symb_table[2 * elem + 1]\n                                                              + 1], c1) == 0)\n                                          {\n                                            /* Yep, this is the entry.  */\n                                            idx = symb_table[2 * elem + 1];\n                                            idx += 1 + extra[idx];\n                                            break;\n                                          }\n\n                                        /* Next entry.  */\n                                        elem += second;\n                                      }\n                                    while (symb_table[2 * elem] != 0);\n                                  }\n\n                                if (symb_table[2 * elem] != 0)\n                                  {\n                                    /* Compare the byte sequence but only if\n                                       this is not part of a range.  */\n# ifdef WIDE_CHAR_VERSION\n                                    int32_t *wextra;\n\n                                    idx += 1 + extra[idx];\n                                    /* Adjust for the alignment.  */\n                                    idx = (idx + 3) & ~4;\n\n                                    wextra = (int32_t *) &extra[idx + 4];\n# endif\n                                    /* Get the collation sequence value.  */\n                                    is_seqval = true;\n# ifdef WIDE_CHAR_VERSION\n                                    cend = wextra[1 + wextra[idx]];\n# else\n                                    /* Adjust for the alignment.  */\n                                    idx += 1 + extra[idx];\n                                    idx = (idx + 3) & ~4;\n                                    cend = *((int32_t *) &extra[idx]);\n# endif\n                                  }\n                                else if (symb_table[2 * elem] != 0 && c1 == 1)\n                                  {\n                                    cend = str[0];\n                                    c = *p++;\n                                  }\n                                else\n                                  return FNM_NOMATCH;\n                              }\n# undef str\n                          }\n                        else\n                          {\n                            if (!(flags & FNM_NOESCAPE) && cend == L_('\\\\'))\n                              cend = *p++;\n                            if (cend == L_('\\0'))\n                              return FNM_NOMATCH;\n                            cend = FOLD (cend);\n                          }\n\n                        /* XXX It is not entirely clear to me how to handle\n                           characters which are not mentioned in the\n                           collation specification.  */\n                        if (\n# ifdef WIDE_CHAR_VERSION\n                            lcollseq == 0xffffffff ||\n# endif\n                            lcollseq <= fcollseq)\n                          {\n                            /* We have to look at the upper bound.  */\n                            uint32_t hcollseq;\n\n                            if (is_seqval)\n                              hcollseq = cend;\n                            else\n                              {\n# ifdef WIDE_CHAR_VERSION\n                                hcollseq =\n                                  __collseq_table_lookup (collseq, cend);\n                                if (hcollseq == ~((uint32_t) 0))\n                                  {\n                                    /* Hum, no information about the upper\n                                       bound.  The matching succeeds if the\n                                       lower bound is matched exactly.  */\n                                    if (lcollseq != fcollseq)\n                                      goto range_not_matched;\n\n                                    goto matched;\n                                  }\n# else\n                                hcollseq = collseq[cend];\n# endif\n                              }\n\n                            if (lcollseq <= hcollseq && fcollseq <= hcollseq)\n                              goto matched;\n                          }\n# ifdef WIDE_CHAR_VERSION\n                      range_not_matched:\n# endif\n#else\n                        /* We use a boring value comparison of the character\n                           values.  This is better than comparing using\n                           'strcoll' since the latter would have surprising\n                           and sometimes fatal consequences.  */\n                        UCHAR cend = *p++;\n\n                        if (!(flags & FNM_NOESCAPE) && cend == L_('\\\\'))\n                          cend = *p++;\n                        if (cend == L_('\\0'))\n                          return FNM_NOMATCH;\n\n                        /* It is a range.  */\n                        if (cold <= fn && fn <= cend)\n                          goto matched;\n#endif\n\n                        c = *p++;\n                      }\n                  }\n\n                if (c == L_(']'))\n                  break;\n              }\n\n            if (!not)\n              return FNM_NOMATCH;\n            break;\n\n          matched:\n            /* Skip the rest of the [...] that already matched.  */\n            do\n              {\n              ignore_next:\n                c = *p++;\n\n                if (c == L_('\\0'))\n                  /* [... (unterminated) loses.  */\n                  return FNM_NOMATCH;\n\n                if (!(flags & FNM_NOESCAPE) && c == L_('\\\\'))\n                  {\n                    if (*p == L_('\\0'))\n                      return FNM_NOMATCH;\n                    /* XXX 1003.2d11 is unclear if this is right.  */\n                    ++p;\n                  }\n                else if (c == L_('[') && *p == L_(':'))\n                  {\n                    int c1 = 0;\n                    const CHAR *startp = p;\n\n                    while (1)\n                      {\n                        c = *++p;\n                        if (++c1 == CHAR_CLASS_MAX_LENGTH)\n                          return FNM_NOMATCH;\n\n                        if (*p == L_(':') && p[1] == L_(']'))\n                          break;\n\n                        if (c < L_('a') || c >= L_('z'))\n                          {\n                            p = startp;\n                            goto ignore_next;\n                          }\n                      }\n                    p += 2;\n                    c = *p++;\n                  }\n                else if (c == L_('[') && *p == L_('='))\n                  {\n                    c = *++p;\n                    if (c == L_('\\0'))\n                      return FNM_NOMATCH;\n                    c = *++p;\n                    if (c != L_('=') || p[1] != L_(']'))\n                      return FNM_NOMATCH;\n                    p += 2;\n                    c = *p++;\n                  }\n                else if (c == L_('[') && *p == L_('.'))\n                  {\n                    ++p;\n                    while (1)\n                      {\n                        c = *++p;\n                        if (c == '\\0')\n                          return FNM_NOMATCH;\n\n                        if (*p == L_('.') && p[1] == L_(']'))\n                          break;\n                      }\n                    p += 2;\n                    c = *p++;\n                  }\n              }\n            while (c != L_(']'));\n            if (not)\n              return FNM_NOMATCH;\n          }\n          break;\n\n        case L_('+'):\n        case L_('@'):\n        case L_('!'):\n          if (__builtin_expect (flags & FNM_EXTMATCH, 0) && *p == '(')\n            {\n              int res;\n\n              res = EXT (c, p, n, string_end, no_leading_period, flags);\n              if (res != -1)\n                return res;\n            }\n          goto normal_match;\n\n        case L_('/'):\n          if (NO_LEADING_PERIOD (flags))\n            {\n              if (n == string_end || c != (UCHAR) *n)\n                return FNM_NOMATCH;\n\n              new_no_leading_period = true;\n              break;\n            }\n          /* FALLTHROUGH */\n        default:\n        normal_match:\n          if (n == string_end || c != FOLD ((UCHAR) *n))\n            return FNM_NOMATCH;\n        }\n\n      no_leading_period = new_no_leading_period;\n      ++n;\n    }\n\n  if (n == string_end)\n    return 0;\n\n  if ((flags & FNM_LEADING_DIR) && n != string_end && *n == L_('/'))\n    /* The FNM_LEADING_DIR flag says that \"foo*\" matches \"foobar/frobozz\".  */\n    return 0;\n\n  return FNM_NOMATCH;\n}",
        "lines": 959,
        "depth": 36,
        "decorators": [
          "static",
          "static",
          "int"
        ]
      },
      {
        "start_point": [
          984,
          0
        ],
        "end_point": [
          1020,
          1
        ],
        "content": "static const CHAR *\ninternal_function\nEND (const CHAR *pattern)\n{\n  const CHAR *p = pattern;\n\n  while (1)\n    if (*++p == L_('\\0'))\n      /* This is an invalid pattern.  */\n      return pattern;\n    else if (*p == L_('['))\n      {\n        /* Handle brackets special.  */\n        if (posixly_correct == 0)\n          posixly_correct = getenv (\"POSIXLY_CORRECT\") != NULL ? 1 : -1;\n\n        /* Skip the not sign.  We have to recognize it because of a possibly\n           following ']'.  */\n        if (*++p == L_('!') || (posixly_correct < 0 && *p == L_('^')))\n          ++p;\n        /* A leading ']' is recognized as such.  */\n        if (*p == L_(']'))\n          ++p;\n        /* Skip over all characters of the list.  */\n        while (*p != L_(']'))\n          if (*p++ == L_('\\0'))\n            /* This is no valid pattern.  */\n            return pattern;\n      }\n    else if ((*p == L_('?') || *p == L_('*') || *p == L_('+') || *p == L_('@')\n              || *p == L_('!')) && p[1] == L_('('))\n      p = END (p + 1);\n    else if (*p == L_(')'))\n      break;\n\n  return p + 1;\n}",
        "lines": 37,
        "depth": 18,
        "decorators": [
          "static",
          "static",
          "const",
          "const",
          "CHAR",
          "*\ninternal_function\nEND (const CHAR *pattern)",
          "*"
        ]
      },
      {
        "start_point": [
          1023,
          0
        ],
        "end_point": [
          1203,
          1
        ],
        "content": "static int\ninternal_function\nEXT (INT opt, const CHAR *pattern, const CHAR *string, const CHAR *string_end,\n     bool no_leading_period, int flags)\n{\n  const CHAR *startp;\n  size_t level;\n  struct patternlist\n  {\n    struct patternlist *next;\n    CHAR str[1];\n  } *list = NULL;\n  struct patternlist **lastp = &list;\n  size_t pattern_len = STRLEN (pattern);\n  const CHAR *p;\n  const CHAR *rs;\n  enum { ALLOCA_LIMIT = 8000 };\n\n  /* Parse the pattern.  Store the individual parts in the list.  */\n  level = 0;\n  for (startp = p = pattern + 1; ; ++p)\n    if (*p == L_('\\0'))\n      /* This is an invalid pattern.  */\n      return -1;\n    else if (*p == L_('['))\n      {\n        /* Handle brackets special.  */\n        if (posixly_correct == 0)\n          posixly_correct = getenv (\"POSIXLY_CORRECT\") != NULL ? 1 : -1;\n\n        /* Skip the not sign.  We have to recognize it because of a possibly\n           following ']'.  */\n        if (*++p == L_('!') || (posixly_correct < 0 && *p == L_('^')))\n          ++p;\n        /* A leading ']' is recognized as such.  */\n        if (*p == L_(']'))\n          ++p;\n        /* Skip over all characters of the list.  */\n        while (*p != L_(']'))\n          if (*p++ == L_('\\0'))\n            /* This is no valid pattern.  */\n            return -1;\n      }\n    else if ((*p == L_('?') || *p == L_('*') || *p == L_('+') || *p == L_('@')\n              || *p == L_('!')) && p[1] == L_('('))\n      /* Remember the nesting level.  */\n      ++level;\n    else if (*p == L_(')'))\n      {\n        if (level-- == 0)\n          {\n            /* This means we found the end of the pattern.  */\n#define NEW_PATTERN \\\n            struct patternlist *newp;                                         \\\n            size_t plen;                                                      \\\n            size_t plensize;                                                  \\\n            size_t newpsize;                                                  \\\n                                                                              \\\n            plen = (opt == L_('?') || opt == L_('@')                          \\\n                    ? pattern_len                                             \\\n                    : p - startp + 1UL);                                      \\\n            plensize = plen * sizeof (CHAR);                                  \\\n            newpsize = offsetof (struct patternlist, str) + plensize;         \\\n            if ((size_t) -1 / sizeof (CHAR) < plen                            \\\n                || newpsize < offsetof (struct patternlist, str)              \\\n                || ALLOCA_LIMIT <= newpsize)                                  \\\n              return -1;                                                      \\\n            newp = (struct patternlist *) alloca (newpsize);                  \\\n            *((CHAR *) MEMPCPY (newp->str, startp, p - startp)) = L_('\\0');    \\\n            newp->next = NULL;                                                \\\n            *lastp = newp;                                                    \\\n            lastp = &newp->next\n            NEW_PATTERN;\n            break;\n          }\n      }\n    else if (*p == L_('|'))\n      {\n        if (level == 0)\n          {\n            NEW_PATTERN;\n            startp = p + 1;\n          }\n      }\n  assert (list != NULL);\n  assert (p[-1] == L_(')'));\n#undef NEW_PATTERN\n\n  switch (opt)\n    {\n    case L_('*'):\n      if (FCT (p, string, string_end, no_leading_period, flags) == 0)\n        return 0;\n      /* FALLTHROUGH */\n\n    case L_('+'):\n      do\n        {\n          for (rs = string; rs <= string_end; ++rs)\n            /* First match the prefix with the current pattern with the\n               current pattern.  */\n            if (FCT (list->str, string, rs, no_leading_period,\n                     flags & FNM_FILE_NAME ? flags : flags & ~FNM_PERIOD) == 0\n                /* This was successful.  Now match the rest with the rest\n                   of the pattern.  */\n                && (FCT (p, rs, string_end,\n                         rs == string\n                         ? no_leading_period\n                         : rs[-1] == '/' && NO_LEADING_PERIOD (flags),\n                         flags & FNM_FILE_NAME\n                         ? flags : flags & ~FNM_PERIOD) == 0\n                    /* This didn't work.  Try the whole pattern.  */\n                    || (rs != string\n                        && FCT (pattern - 1, rs, string_end,\n                                rs == string\n                                ? no_leading_period\n                                : rs[-1] == '/' && NO_LEADING_PERIOD (flags),\n                                flags & FNM_FILE_NAME\n                                ? flags : flags & ~FNM_PERIOD) == 0)))\n              /* It worked.  Signal success.  */\n              return 0;\n        }\n      while ((list = list->next) != NULL);\n\n      /* None of the patterns lead to a match.  */\n      return FNM_NOMATCH;\n\n    case L_('?'):\n      if (FCT (p, string, string_end, no_leading_period, flags) == 0)\n        return 0;\n      /* FALLTHROUGH */\n\n    case L_('@'):\n      do\n        /* I cannot believe it but 'strcat' is actually acceptable\n           here.  Match the entire string with the prefix from the\n           pattern list and the rest of the pattern following the\n           pattern list.  */\n        if (FCT (STRCAT (list->str, p), string, string_end,\n                 no_leading_period,\n                 flags & FNM_FILE_NAME ? flags : flags & ~FNM_PERIOD) == 0)\n          /* It worked.  Signal success.  */\n          return 0;\n      while ((list = list->next) != NULL);\n\n      /* None of the patterns lead to a match.  */\n      return FNM_NOMATCH;\n\n    case L_('!'):\n      for (rs = string; rs <= string_end; ++rs)\n        {\n          struct patternlist *runp;\n\n          for (runp = list; runp != NULL; runp = runp->next)\n            if (FCT (runp->str, string, rs,  no_leading_period,\n                     flags & FNM_FILE_NAME ? flags : flags & ~FNM_PERIOD) == 0)\n              break;\n\n          /* If none of the patterns matched see whether the rest does.  */\n          if (runp == NULL\n              && (FCT (p, rs, string_end,\n                       rs == string\n                       ? no_leading_period\n                       : rs[-1] == '/' && NO_LEADING_PERIOD (flags),\n                       flags & FNM_FILE_NAME ? flags : flags & ~FNM_PERIOD)\n                  == 0))\n            /* This is successful.  */\n            return 0;\n        }\n\n      /* None of the patterns together with the rest of the pattern\n         lead to a match.  */\n      return FNM_NOMATCH;\n\n    default:\n      assert (! \"Invalid extended matching operator\");\n      break;\n    }\n\n  return -1;\n}",
        "lines": 181,
        "depth": 23,
        "decorators": [
          "static",
          "static",
          "int"
        ]
      }
    ]
  },
  "findutils/findutils-4.6.0/gl/lib/fopen-safer.c": {
    "fopen_safer": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "FILE *\nfopen_safer (char const *file, char const *mode)\n{\n  FILE *fp = fopen (file, mode);\n\n  if (fp)\n    {\n      int fd = fileno (fp);\n\n      if (0 <= fd && fd <= STDERR_FILENO)\n        {\n          int f = dup_safer (fd);\n\n          if (f < 0)\n            {\n              int e = errno;\n              fclose (fp);\n              errno = e;\n              return NULL;\n            }\n\n          if (fclose (fp) != 0\n              || ! (fp = fdopen (f, mode)))\n            {\n              int e = errno;\n              close (f);\n              errno = e;\n              return NULL;\n            }\n        }\n    }\n\n  return fp;\n}",
      "lines": 34,
      "depth": 15,
      "decorators": [
        "FILE",
        "*\nfopen_safer (char const *file, char const *mode)",
        "*"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/fopen.c": {
    "orig_fopen": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        32,
        1
      ],
      "content": "static FILE *\norig_fopen (const char *filename, const char *mode)\n{\n  return fopen (filename, mode);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "FILE",
        "*\norig_fopen (const char *filename, const char *mode)",
        "*"
      ]
    },
    "rpl_fopen": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        109,
        1
      ],
      "content": "FILE *\nrpl_fopen (const char *filename, const char *mode)\n{\n#if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n  if (strcmp (filename, \"/dev/null\") == 0)\n    filename = \"NUL\";\n#endif\n\n#if FOPEN_TRAILING_SLASH_BUG\n  /* If the filename ends in a slash and a mode that requires write access is\n     specified, then fail.\n     Rationale: POSIX <http://www.opengroup.org/susv3/basedefs/xbd_chap04.html>\n     says that\n       \"A pathname that contains at least one non-slash character and that\n        ends with one or more trailing slashes shall be resolved as if a\n        single dot character ( '.' ) were appended to the pathname.\"\n     and\n       \"The special filename dot shall refer to the directory specified by\n        its predecessor.\"\n     If the named file already exists as a directory, then if a mode that\n     requires write access is specified, fopen() must fail because POSIX\n     <http://www.opengroup.org/susv3/functions/fopen.html> says that it\n     fails with errno = EISDIR in this case.\n     If the named file does not exist or does not name a directory, then\n     fopen() must fail since the file does not contain a '.' directory.  */\n  {\n    size_t len = strlen (filename);\n    if (len > 0 && filename[len - 1] == '/')\n      {\n        int fd;\n        struct stat statbuf;\n        FILE *fp;\n\n        if (mode[0] == 'w' || mode[0] == 'a')\n          {\n            errno = EISDIR;\n            return NULL;\n          }\n\n        fd = open (filename, O_RDONLY);\n        if (fd < 0)\n          return NULL;\n\n        if (fstat (fd, &statbuf) >= 0 && !S_ISDIR (statbuf.st_mode))\n          {\n            close (fd);\n            errno = ENOTDIR;\n            return NULL;\n          }\n\n        fp = fdopen (fd, mode);\n        if (fp == NULL)\n          {\n            int saved_errno = errno;\n            close (fd);\n            errno = saved_errno;\n          }\n        return fp;\n      }\n  }\n# endif\n\n  return orig_fopen (filename, mode);\n}",
      "lines": 64,
      "depth": 14,
      "decorators": [
        "FILE",
        "*\nrpl_fopen (const char *filename, const char *mode)",
        "*"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/fpending.c": {
    "__fpending": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        29,
        1
      ],
      "content": "size_t\n__fpending (FILE *fp)\n{\n  return PENDING_OUTPUT_N_BYTES;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "size_t"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/fpending.h": {},
  "findutils/findutils-4.6.0/gl/lib/fpurge.c": {
    "fpurge": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        146,
        1
      ],
      "content": "int\nfpurge (FILE *fp)\n{\n#if HAVE___FPURGE                   /* glibc >= 2.2, Haiku, Solaris >= 7, musl libc */\n\n  __fpurge (fp);\n  /* The __fpurge function does not have a return value.  */\n  return 0;\n\n#elif HAVE_FPURGE                   /* FreeBSD, NetBSD, OpenBSD, DragonFly, Mac OS X, Cygwin 1.7 */\n\n  /* Call the system's fpurge function.  */\n# undef fpurge\n# if !HAVE_DECL_FPURGE\n  extern int fpurge (FILE *);\n# endif\n  int result = fpurge (fp);\n# if defined __sferror || defined __DragonFly__ || defined __ANDROID__\n  /* FreeBSD, NetBSD, OpenBSD, DragonFly, Mac OS X, Cygwin, Android */\n  if (result == 0)\n    /* Correct the invariants that fpurge broke.\n       <stdio.h> on BSD systems says:\n         \"The following always hold: if _flags & __SRD, _w is 0.\"\n       If this invariant is not fulfilled and the stream is read-write but\n       currently reading, subsequent putc or fputc calls will write directly\n       into the buffer, although they shouldn't be allowed to.  */\n    if ((fp_->_flags & __SRD) != 0)\n      fp_->_w = 0;\n# endif\n  return result;\n\n#else\n\n  /* Most systems provide FILE as a struct and the necessary bitmask in\n     <stdio.h>, because they need it for implementing getc() and putc() as\n     fast macros.  */\n# if defined _IO_ftrylockfile || __GNU_LIBRARY__ == 1 /* GNU libc, BeOS, Haiku, Linux libc5 */\n  fp->_IO_read_end = fp->_IO_read_ptr;\n  fp->_IO_write_ptr = fp->_IO_write_base;\n  /* Avoid memory leak when there is an active ungetc buffer.  */\n  if (fp->_IO_save_base != NULL)\n    {\n      free (fp->_IO_save_base);\n      fp->_IO_save_base = NULL;\n    }\n  return 0;\n# elif defined __sferror || defined __DragonFly__ || defined __ANDROID__\n  /* FreeBSD, NetBSD, OpenBSD, DragonFly, Mac OS X, Cygwin, Android */\n  fp_->_p = fp_->_bf._base;\n  fp_->_r = 0;\n  fp_->_w = ((fp_->_flags & (__SLBF | __SNBF | __SRD)) == 0 /* fully buffered and not currently reading? */\n             ? fp_->_bf._size\n             : 0);\n  /* Avoid memory leak when there is an active ungetc buffer.  */\n  if (fp_ub._base != NULL)\n    {\n      if (fp_ub._base != fp_->_ubuf)\n        free (fp_ub._base);\n      fp_ub._base = NULL;\n    }\n  return 0;\n# elif defined __EMX__              /* emx+gcc */\n  fp->_ptr = fp->_buffer;\n  fp->_rcount = 0;\n  fp->_wcount = 0;\n  fp->_ungetc_count = 0;\n  return 0;\n# elif defined __minix              /* Minix */\n  fp->_ptr = fp->_buf;\n  if (fp->_ptr != NULL)\n    fp->_count = 0;\n  return 0;\n# elif defined _IOERR               /* AIX, HP-UX, IRIX, OSF/1, Solaris, OpenServer, mingw, NonStop Kernel */\n  fp->_ptr = fp->_base;\n  if (fp->_ptr != NULL)\n    fp->_cnt = 0;\n  return 0;\n# elif defined __UCLIBC__           /* uClibc */\n#  ifdef __STDIO_BUFFERS\n  if (fp->__modeflags & __FLAG_WRITING)\n    fp->__bufpos = fp->__bufstart;\n  else if (fp->__modeflags & (__FLAG_READONLY | __FLAG_READING))\n    fp->__bufpos = fp->__bufread;\n#  endif\n  return 0;\n# elif defined __QNX__              /* QNX */\n  fp->_Rback = fp->_Back + sizeof (fp->_Back);\n  fp->_Rsave = NULL;\n  if (fp->_Mode & 0x2000 /* _MWRITE */)\n    /* fp->_Buf <= fp->_Next <= fp->_Wend */\n    fp->_Next = fp->_Buf;\n  else\n    /* fp->_Buf <= fp->_Next <= fp->_Rend */\n    fp->_Rend = fp->_Next;\n  return 0;\n# elif defined __MINT__             /* Atari FreeMiNT */\n  if (fp->__pushed_back)\n    {\n      fp->__bufp = fp->__pushback_bufp;\n      fp->__pushed_back = 0;\n    }\n  /* Preserve the current file position.  */\n  if (fp->__target != -1)\n    fp->__target += fp->__bufp - fp->__buffer;\n  fp->__bufp = fp->__buffer;\n  /* Nothing in the buffer, next getc is nontrivial.  */\n  fp->__get_limit = fp->__bufp;\n  /* Nothing in the buffer, next putc is nontrivial.  */\n  fp->__put_limit = fp->__buffer;\n  return 0;\n# elif defined EPLAN9               /* Plan9 */\n  fp->rp = fp->wp = fp->lp = fp->buf;\n  return 0;\n# else\n#  error \"Please port gnulib fpurge.c to your platform! Look at the definitions of fflush, setvbuf and ungetc on your system, then report this to bug-gnulib.\"\n# endif\n\n#endif\n}",
      "lines": 119,
      "depth": 20,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/freadahead.c": {
    "freadahead": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "size_t\nfreadahead (FILE *fp)\n{\n#if defined _IO_ftrylockfile || __GNU_LIBRARY__ == 1 /* GNU libc, BeOS, Haiku, Linux libc5 */\n  if (fp->_IO_write_ptr > fp->_IO_write_base)\n    return 0;\n  return (fp->_IO_read_end - fp->_IO_read_ptr)\n         + (fp->_flags & _IO_IN_BACKUP ? fp->_IO_save_end - fp->_IO_save_base :\n            0);\n#elif defined __sferror || defined __DragonFly__ || defined __ANDROID__\n  /* FreeBSD, NetBSD, OpenBSD, DragonFly, Mac OS X, Cygwin, Android */\n  if ((fp_->_flags & __SWR) != 0 || fp_->_r < 0)\n    return 0;\n# if defined __DragonFly__\n  return __sreadahead (fp);\n# else\n  return fp_->_r\n         + (HASUB (fp) ? fp_->_ur : 0);\n# endif\n#elif defined __EMX__               /* emx+gcc */\n  if ((fp->_flags & _IOWRT) != 0)\n    return 0;\n  /* Note: fp->_ungetc_count > 0 implies fp->_rcount <= 0,\n           fp->_ungetc_count = 0 implies fp->_rcount >= 0.  */\n  /* equivalent to\n     (fp->_ungetc_count == 0 ? fp->_rcount : fp->_ungetc_count - fp->_rcount) */\n  return (fp->_rcount > 0 ? fp->_rcount : fp->_ungetc_count - fp->_rcount);\n#elif defined __minix               /* Minix */\n  if ((fp_->_flags & _IOWRITING) != 0)\n    return 0;\n  return fp_->_count;\n#elif defined _IOERR                /* AIX, HP-UX, IRIX, OSF/1, Solaris, OpenServer, mingw, NonStop Kernel */\n  if ((fp_->_flag & _IOWRT) != 0)\n    return 0;\n  return fp_->_cnt;\n#elif defined __UCLIBC__            /* uClibc */\n# ifdef __STDIO_BUFFERS\n  if (fp->__modeflags & __FLAG_WRITING)\n    return 0;\n  return (fp->__bufread - fp->__bufpos)\n         + (fp->__modeflags & __FLAG_UNGOT ? 1 : 0);\n# else\n  return 0;\n# endif\n#elif defined __QNX__               /* QNX */\n  if ((fp->_Mode & 0x2000 /* _MWRITE */) != 0)\n    return 0;\n  /* fp->_Buf <= fp->_Next <= fp->_Rend,\n     and fp->_Rend may be overridden by fp->_Rsave. */\n  return ((fp->_Rsave ? fp->_Rsave : fp->_Rend) - fp->_Next)\n         + (fp->_Mode & 0x4000 /* _MBYTE */\n            ? (fp->_Back + sizeof (fp->_Back)) - fp->_Rback\n            : 0);\n#elif defined __MINT__              /* Atari FreeMiNT */\n  if (!fp->__mode.__read)\n    return 0;\n  return (fp->__pushed_back\n          ? fp->__get_limit - fp->__pushback_bufp + 1\n          : fp->__get_limit - fp->__bufp);\n#elif defined EPLAN9                /* Plan9 */\n  if (fp->state == 4 /* WR */ || fp->rp >= fp->wp)\n    return 0;\n  return fp->wp - fp->rp;\n#elif defined SLOW_BUT_NO_HACKS     /* users can define this */\n  abort ();\n  return 0;\n#else\n #error \"Please port gnulib freadahead.c to your platform! Look at the definition of fflush, fread, ungetc on your system, then report this to bug-gnulib.\"\n#endif\n}",
      "lines": 70,
      "depth": 20,
      "decorators": [
        "size_t"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/freadahead.h": {},
  "findutils/findutils-4.6.0/gl/lib/freading.c": {
    "freading": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "bool\nfreading (FILE *fp)\n{\n  /* Most systems provide FILE as a struct and the necessary bitmask in\n     <stdio.h>, because they need it for implementing getc() and putc() as\n     fast macros.  */\n# if defined _IO_ftrylockfile || __GNU_LIBRARY__ == 1 /* GNU libc, BeOS, Haiku, Linux libc5 */\n  return ((fp->_flags & _IO_NO_WRITES) != 0\n          || ((fp->_flags & (_IO_NO_READS | _IO_CURRENTLY_PUTTING)) == 0\n              && fp->_IO_read_base != NULL));\n# elif defined __sferror || defined __DragonFly__ || defined __ANDROID__\n  /* FreeBSD, NetBSD, OpenBSD, DragonFly, Mac OS X, Cygwin, Android */\n  return (fp_->_flags & __SRD) != 0;\n# elif defined __EMX__               /* emx+gcc */\n  return (fp->_flags & _IOREAD) != 0;\n# elif defined __minix               /* Minix */\n  return (fp->_flags & _IOREADING) != 0;\n# elif defined _IOERR                /* AIX, HP-UX, IRIX, OSF/1, Solaris, OpenServer, mingw, NonStop Kernel */\n#  if defined __sun                  /* Solaris */\n  return (fp->_flag & _IOREAD) != 0 && (fp->_flag & _IOWRT) == 0;\n#  else\n  return (fp->_flag & _IOREAD) != 0;\n#  endif\n# elif defined __UCLIBC__            /* uClibc */\n  return (fp->__modeflags & (__FLAG_READONLY | __FLAG_READING)) != 0;\n# elif defined __QNX__               /* QNX */\n  return ((fp->_Mode & 0x2 /* _MOPENW */) == 0\n          || (fp->_Mode & 0x1000 /* _MREAD */) != 0);\n# elif defined __MINT__              /* Atari FreeMiNT */\n  if (!fp->__mode.__write)\n    return 1;\n  if (!fp->__mode.__read)\n    return 0;\n#  ifdef _IO_CURRENTLY_GETTING /* Flag added on 2009-02-28 */\n  return (fp->__flags & _IO_CURRENTLY_GETTING) != 0;\n#  else\n  return (fp->__buffer < fp->__get_limit /*|| fp->__bufp == fp->__put_limit ??*/);\n#  endif\n# elif defined EPLAN9                /* Plan9 */\n  if (fp->state == 0 /* CLOSED */ || fp->state == 4 /* WR */)\n    return 0;\n  return (fp->state == 3 /* RD */ && (fp->bufl == 0 || fp->rp < fp->wp));\n# else\n#  error \"Please port gnulib freading.c to your platform!\"\n# endif\n}",
      "lines": 46,
      "depth": 19,
      "decorators": [
        "bool"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/freading.h": {},
  "findutils/findutils-4.6.0/gl/lib/fseek.c": {
    "fseek": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        29,
        1
      ],
      "content": "int\nfseek (FILE *fp, long offset, int whence)\n{\n  /* Use the replacement fseeko function with all its workarounds.  */\n  return fseeko (fp, (off_t)offset, whence);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/fseeko.c": {},
  "findutils/findutils-4.6.0/gl/lib/fstat.c": {
    "orig_fstat": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "static int\norig_fstat (int fd, struct stat *buf)\n{\n  return fstat (fd, buf);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "fstat_nothrow": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        61,
        5
      ],
      "content": "static int\nfstat_nothrow (int fd, struct stat *buf)\n{\n  int result;\n\n  TRY_MSVC_INVAL\n    {\n      result = orig_fstat (fd, buf);\n    }",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_fstat": {
      "start_point": [
        75,
        0
      ],
      "end_point": [
        87,
        1
      ],
      "content": "int\nrpl_fstat (int fd, struct stat *buf)\n{\n#if REPLACE_FCHDIR && REPLACE_OPEN_DIRECTORY\n  /* Handle the case when rpl_open() used a dummy file descriptor to work\n     around an open() that can't normally visit directories.  */\n  const char *name = _gl_directory_name (fd);\n  if (name != NULL)\n    return stat (name, buf);\n#endif\n\n  return fstat_nothrow (fd, buf);\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/fstatat.c": {
    "orig_fstatat": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        35,
        1
      ],
      "content": "static int\norig_fstatat (int fd, char const *filename, struct stat *buf, int flags)\n{\n  return fstatat (fd, filename, buf, flags);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_fstatat": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "int\nrpl_fstatat (int fd, char const *file, struct stat *st, int flag)\n{\n  int result = orig_fstatat (fd, file, st, flag);\n  size_t len;\n\n  if (LSTAT_FOLLOWS_SLASHED_SYMLINK || result != 0)\n    return result;\n  len = strlen (file);\n  if (flag & AT_SYMLINK_NOFOLLOW)\n    {\n      /* Fix lstat behavior.  */\n      if (file[len - 1] != '/' || S_ISDIR (st->st_mode))\n        return 0;\n      if (!S_ISLNK (st->st_mode))\n        {\n          errno = ENOTDIR;\n          return -1;\n        }\n      result = orig_fstatat (fd, file, st, flag & ~AT_SYMLINK_NOFOLLOW);\n    }\n  /* Fix stat behavior.  */\n  if (result == 0 && !S_ISDIR (st->st_mode) && file[len - 1] == '/')\n    {\n      errno = ENOTDIR;\n      return -1;\n    }\n  return result;\n}",
      "lines": 29,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "stat_func": {
      "start_point": [
        99,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "static int\nstat_func (char const *name, struct stat *st)\n{\n  return stat (name, st);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/ftell.c": {
    "ftell": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "long\nftell (FILE *fp)\n{\n  /* Use the replacement ftello function with all its workarounds.  */\n  off_t offset = ftello (fp);\n  if (LONG_MIN <= offset && offset <= LONG_MAX)\n    return /* (long) */ offset;\n  else\n    {\n      errno = EOVERFLOW;\n      return -1;\n    }\n}",
      "lines": 13,
      "depth": 7,
      "decorators": [
        "long",
        "long"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/ftello.c": {},
  "findutils/findutils-4.6.0/gl/lib/fts-cycle.c": {
    "AD_compare": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "static bool\nAD_compare (void const *x, void const *y)\n{\n  struct Active_dir const *ax = x;\n  struct Active_dir const *ay = y;\n  return ax->ino == ay->ino\n      && ax->dev == ay->dev;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "AD_hash": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "static size_t\nAD_hash (void const *x, size_t table_size)\n{\n  struct Active_dir const *ax = x;\n  return (uintmax_t) ax->ino % table_size;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "setup_dir": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "static bool\nsetup_dir (FTS *fts)\n{\n  if (fts->fts_options & (FTS_TIGHT_CYCLE_CHECK | FTS_LOGICAL))\n    {\n      enum { HT_INITIAL_SIZE = 31 };\n      fts->fts_cycle.ht = hash_initialize (HT_INITIAL_SIZE, NULL, AD_hash,\n                                           AD_compare, free);\n      if (! fts->fts_cycle.ht)\n        return false;\n    }\n  else\n    {\n      fts->fts_cycle.state = malloc (sizeof *fts->fts_cycle.state);\n      if (! fts->fts_cycle.state)\n        return false;\n      cycle_check_init (fts->fts_cycle.state);\n    }\n\n  return true;\n}",
      "lines": 21,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "enter_dir": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        119,
        1
      ],
      "content": "static bool\nenter_dir (FTS *fts, FTSENT *ent)\n{\n  if (fts->fts_options & (FTS_TIGHT_CYCLE_CHECK | FTS_LOGICAL))\n    {\n      struct stat const *st = ent->fts_statp;\n      struct Active_dir *ad = malloc (sizeof *ad);\n      struct Active_dir *ad_from_table;\n\n      if (!ad)\n        return false;\n\n      ad->dev = st->st_dev;\n      ad->ino = st->st_ino;\n      ad->fts_ent = ent;\n\n      /* See if we've already encountered this directory.\n         This can happen when following symlinks as well as\n         with a corrupted directory hierarchy. */\n      ad_from_table = hash_insert (fts->fts_cycle.ht, ad);\n\n      if (ad_from_table != ad)\n        {\n          free (ad);\n          if (!ad_from_table)\n            return false;\n\n          /* There was an entry with matching dev/inode already in the table.\n             Record the fact that we've found a cycle.  */\n          ent->fts_cycle = ad_from_table->fts_ent;\n          ent->fts_info = FTS_DC;\n        }\n    }\n  else\n    {\n      if (cycle_check (fts->fts_cycle.state, ent->fts_statp))\n        {\n          /* FIXME: setting fts_cycle like this isn't proper.\n             To do what the documentation requires, we'd have to\n             go around the cycle again and find the right entry.\n             But no callers in coreutils use the fts_cycle member. */\n          ent->fts_cycle = ent;\n          ent->fts_info = FTS_DC;\n        }\n    }\n\n  return true;\n}",
      "lines": 48,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "leave_dir": {
      "start_point": [
        123,
        0
      ],
      "end_point": [
        145,
        1
      ],
      "content": "static void\nleave_dir (FTS *fts, FTSENT *ent)\n{\n  struct stat const *st = ent->fts_statp;\n  if (fts->fts_options & (FTS_TIGHT_CYCLE_CHECK | FTS_LOGICAL))\n    {\n      struct Active_dir obj;\n      void *found;\n      obj.dev = st->st_dev;\n      obj.ino = st->st_ino;\n      found = hash_delete (fts->fts_cycle.ht, &obj);\n      if (!found)\n        abort ();\n      free (found);\n    }\n  else\n    {\n      FTSENT *parent = ent->fts_parent;\n      if (parent != NULL && 0 <= parent->fts_level)\n        CYCLE_CHECK_REFLECT_CHDIR_UP (fts->fts_cycle.state,\n                                      *(parent->fts_statp), *st);\n    }\n}",
      "lines": 23,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "free_dir": {
      "start_point": [
        149,
        0
      ],
      "end_point": [
        159,
        1
      ],
      "content": "static void\nfree_dir (FTS *sp)\n{\n  if (sp->fts_options & (FTS_TIGHT_CYCLE_CHECK | FTS_LOGICAL))\n    {\n      if (sp->fts_cycle.ht)\n        hash_free (sp->fts_cycle.ht);\n    }\n  else\n    free (sp->fts_cycle.state);\n}",
      "lines": 11,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/fts.c": {
    "fd_ring_clear": {
      "start_point": [
        269,
        0
      ],
      "end_point": [
        278,
        1
      ],
      "content": "static void\nfd_ring_clear (I_ring *fd_ring)\n{\n  while ( ! i_ring_empty (fd_ring))\n    {\n      int fd = i_ring_pop (fd_ring);\n      if (0 <= fd)\n        close (fd);\n    }\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "fts_set_stat_required": {
      "start_point": [
        283,
        0
      ],
      "end_point": [
        290,
        1
      ],
      "content": "static void\nfts_set_stat_required (FTSENT *p, bool required)\n{\n  fts_assert (p->fts_info == FTS_NSOK);\n  p->fts_statp->st_size = (required\n                           ? FTS_STAT_REQUIRED\n                           : FTS_NO_STAT_REQUIRED);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "internal_function": [
      {
        "start_point": [
          294,
          0
        ],
        "end_point": [
          316,
          1
        ],
        "content": "static DIR *\ninternal_function\nopendirat (int fd, char const *dir, int extra_flags, int *pdir_fd)\n{\n  int new_fd = openat (fd, dir,\n                       (O_RDONLY | O_DIRECTORY | O_NOCTTY | O_NONBLOCK\n                        | extra_flags));\n  DIR *dirp;\n\n  if (new_fd < 0)\n    return NULL;\n  set_cloexec_flag (new_fd, true);\n  dirp = fdopendir (new_fd);\n  if (dirp)\n    *pdir_fd = new_fd;\n  else\n    {\n      int saved_errno = errno;\n      close (new_fd);\n      errno = saved_errno;\n    }\n  return dirp;\n}",
        "lines": 23,
        "depth": 12,
        "decorators": [
          "static",
          "static",
          "DIR",
          "*\ninternal_function\nopendirat (int fd, char const *dir, int extra_flags, int *pdir_fd)",
          "*"
        ]
      },
      {
        "start_point": [
          364,
          0
        ],
        "end_point": [
          378,
          1
        ],
        "content": "static int\ninternal_function\ndiropen (FTS const *sp, char const *dir)\n{\n  int open_flags = (O_SEARCH | O_DIRECTORY | O_NOCTTY | O_NONBLOCK\n                    | (ISSET (FTS_PHYSICAL) ? O_NOFOLLOW : 0)\n                    | (ISSET (FTS_NOATIME) ? O_NOATIME : 0));\n\n  int fd = (ISSET (FTS_CWDFD)\n            ? openat (sp->fts_cwd_fd, dir, open_flags)\n            : open (dir, open_flags));\n  if (0 <= fd)\n    set_cloexec_flag (fd, true);\n  return fd;\n}",
        "lines": 15,
        "depth": 12,
        "decorators": [
          "static",
          "static",
          "int"
        ]
      },
      {
        "start_point": [
          570,
          0
        ],
        "end_point": [
          592,
          1
        ],
        "content": "static void\ninternal_function\nfts_load (FTS *sp, register FTSENT *p)\n{\n        register size_t len;\n        register char *cp;\n\n        /*\n         * Load the stream structure for the next traversal.  Since we don't\n         * actually enter the directory until after the preorder visit, set\n         * the fts_accpath field specially so the chdir gets done to the right\n         * place and the user can access the first node.  From fts_open it's\n         * known that the file name will fit.\n         */\n        len = p->fts_pathlen = p->fts_namelen;\n        memmove(sp->fts_path, p->fts_name, len + 1);\n        if ((cp = strrchr(p->fts_name, '/')) && (cp != p->fts_name || cp[1])) {\n                len = strlen(++cp);\n                memmove(p->fts_name, cp, len + 1);\n                p->fts_namelen = len;\n        }\n        p->fts_accpath = p->fts_path = sp->fts_path;\n}",
        "lines": 23,
        "depth": 11,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          1288,
          0
        ],
        "end_point": [
          1646,
          1
        ],
        "content": "static FTSENT *\ninternal_function\nfts_build (register FTS *sp, int type)\n{\n        register FTSENT *p, *head;\n        register size_t nitems;\n        FTSENT *tail;\n        void *oldaddr;\n        int saved_errno;\n        bool descend;\n        bool doadjust;\n        ptrdiff_t level;\n        nlink_t nlinks;\n        bool nostat;\n        size_t len, maxlen, new_len;\n        char *cp;\n        int dir_fd;\n        FTSENT *cur = sp->fts_cur;\n        bool continue_readdir = !!cur->fts_dirp;\n        size_t max_entries;\n\n        /* When cur->fts_dirp is non-NULL, that means we should\n           continue calling readdir on that existing DIR* pointer\n           rather than opening a new one.  */\n        if (continue_readdir)\n          {\n            DIR *dp = cur->fts_dirp;\n            dir_fd = dirfd (dp);\n            if (dir_fd < 0)\n              {\n                closedir_and_clear (cur->fts_dirp);\n                if (type == BREAD)\n                  {\n                    cur->fts_info = FTS_DNR;\n                    cur->fts_errno = errno;\n                  }\n                return NULL;\n              }\n          }\n        else\n          {\n            /* Open the directory for reading.  If this fails, we're done.\n               If being called from fts_read, set the fts_info field. */\n            if ((cur->fts_dirp = fts_opendir(cur->fts_accpath, &dir_fd)) == NULL)\n              {\n                if (type == BREAD)\n                  {\n                    cur->fts_info = FTS_DNR;\n                    cur->fts_errno = errno;\n                  }\n                return NULL;\n              }\n            /* Rather than calling fts_stat for each and every entry encountered\n               in the readdir loop (below), stat each directory only right after\n               opening it.  */\n            if (cur->fts_info == FTS_NSOK)\n              cur->fts_info = fts_stat(sp, cur, false);\n            else if (sp->fts_options & FTS_TIGHT_CYCLE_CHECK)\n              {\n                /* Now read the stat info again after opening a directory to\n                   reveal eventual changes caused by a submount triggered by\n                   the traversal.  But do it only for utilities which use\n                   FTS_TIGHT_CYCLE_CHECK.  Therefore, only find and du\n                   benefit/suffer from this feature for now.  */\n                LEAVE_DIR (sp, cur, \"4\");\n                fts_stat (sp, cur, false);\n                if (! enter_dir (sp, cur))\n                  {\n                    __set_errno (ENOMEM);\n                    return NULL;\n                  }\n              }\n          }\n\n        /* Maximum number of readdir entries to read at one time.  This\n           limitation is to avoid reading millions of entries into memory\n           at once.  When an fts_compar function is specified, we have no\n           choice: we must read all entries into memory before calling that\n           function.  But when no such function is specified, we can read\n           entries in batches that are large enough to help us with inode-\n           sorting, yet not so large that we risk exhausting memory.  */\n        max_entries = sp->fts_compar ? SIZE_MAX : FTS_MAX_READDIR_ENTRIES;\n\n        /*\n         * Nlinks is the number of possible entries of type directory in the\n         * directory if we're cheating on stat calls, 0 if we're not doing\n         * any stat calls at all, (nlink_t) -1 if we're statting everything.\n         */\n        if (type == BNAMES) {\n                nlinks = 0;\n                /* Be quiet about nostat, GCC. */\n                nostat = false;\n        } else if (ISSET(FTS_NOSTAT) && ISSET(FTS_PHYSICAL)) {\n                nlinks = (cur->fts_statp->st_nlink\n                          - (ISSET(FTS_SEEDOT) ? 0 : 2));\n                nostat = true;\n        } else {\n                nlinks = -1;\n                nostat = false;\n        }\n\n        /*\n         * If we're going to need to stat anything or we want to descend\n         * and stay in the directory, chdir.  If this fails we keep going,\n         * but set a flag so we don't chdir after the post-order visit.\n         * We won't be able to stat anything, but we can still return the\n         * names themselves.  Note, that since fts_read won't be able to\n         * chdir into the directory, it will have to return different file\n         * names than before, i.e. \"a/b\" instead of \"b\".  Since the node\n         * has already been visited in pre-order, have to wait until the\n         * post-order visit to return the error.  There is a special case\n         * here, if there was nothing to stat then it's not an error to\n         * not be able to stat.  This is all fairly nasty.  If a program\n         * needed sorted entries or stat information, they had better be\n         * checking FTS_NS on the returned nodes.\n         */\n        if (continue_readdir)\n          {\n            /* When resuming a short readdir run, we already have\n               the required dirp and dir_fd.  */\n            descend = true;\n          }\n        else if (nlinks || type == BREAD) {\n                if (ISSET(FTS_CWDFD))\n                  {\n                    dir_fd = dup (dir_fd);\n                    if (0 <= dir_fd)\n                      set_cloexec_flag (dir_fd, true);\n                  }\n                if (dir_fd < 0 || fts_safe_changedir(sp, cur, dir_fd, NULL)) {\n                        if (nlinks && type == BREAD)\n                                cur->fts_errno = errno;\n                        cur->fts_flags |= FTS_DONTCHDIR;\n                        descend = false;\n                        closedir_and_clear(cur->fts_dirp);\n                        if (ISSET(FTS_CWDFD) && 0 <= dir_fd)\n                                close (dir_fd);\n                        cur->fts_dirp = NULL;\n                } else\n                        descend = true;\n        } else\n                descend = false;\n\n        /*\n         * Figure out the max file name length that can be stored in the\n         * current buffer -- the inner loop allocates more space as necessary.\n         * We really wouldn't have to do the maxlen calculations here, we\n         * could do them in fts_read before returning the name, but it's a\n         * lot easier here since the length is part of the dirent structure.\n         *\n         * If not changing directories set a pointer so that can just append\n         * each new component into the file name.\n         */\n        len = NAPPEND(cur);\n        if (ISSET(FTS_NOCHDIR)) {\n                cp = sp->fts_path + len;\n                *cp++ = '/';\n        } else {\n                /* GCC, you're too verbose. */\n                cp = NULL;\n        }\n        len++;\n        maxlen = sp->fts_pathlen - len;\n\n        level = cur->fts_level + 1;\n\n        /* Read the directory, attaching each entry to the \"link\" pointer. */\n        doadjust = false;\n        head = NULL;\n        tail = NULL;\n        nitems = 0;\n        while (cur->fts_dirp) {\n                bool is_dir;\n                size_t d_namelen;\n                struct dirent *dp = readdir(cur->fts_dirp);\n                if (dp == NULL)\n                        break;\n                if (!ISSET(FTS_SEEDOT) && ISDOT(dp->d_name))\n                        continue;\n\n                d_namelen = _D_EXACT_NAMLEN (dp);\n                p = fts_alloc (sp, dp->d_name, d_namelen);\n                if (!p)\n                        goto mem1;\n                if (d_namelen >= maxlen) {\n                        /* include space for NUL */\n                        oldaddr = sp->fts_path;\n                        if (! fts_palloc(sp, d_namelen + len + 1)) {\n                                /*\n                                 * No more memory.  Save\n                                 * errno, free up the current structure and the\n                                 * structures already allocated.\n                                 */\nmem1:                           saved_errno = errno;\n                                free(p);\n                                fts_lfree(head);\n                                closedir_and_clear(cur->fts_dirp);\n                                cur->fts_info = FTS_ERR;\n                                SET(FTS_STOP);\n                                __set_errno (saved_errno);\n                                return (NULL);\n                        }\n                        /* Did realloc() change the pointer? */\n                        if (oldaddr != sp->fts_path) {\n                                doadjust = true;\n                                if (ISSET(FTS_NOCHDIR))\n                                        cp = sp->fts_path + len;\n                        }\n                        maxlen = sp->fts_pathlen - len;\n                }\n\n                new_len = len + d_namelen;\n                if (new_len < len) {\n                        /*\n                         * In the unlikely event that we would end up\n                         * with a file name longer than SIZE_MAX, free up\n                         * the current structure and the structures already\n                         * allocated, then error out with ENAMETOOLONG.\n                         */\n                        free(p);\n                        fts_lfree(head);\n                        closedir_and_clear(cur->fts_dirp);\n                        cur->fts_info = FTS_ERR;\n                        SET(FTS_STOP);\n                        __set_errno (ENAMETOOLONG);\n                        return (NULL);\n                }\n                p->fts_level = level;\n                p->fts_parent = sp->fts_cur;\n                p->fts_pathlen = new_len;\n\n                /* Store dirent.d_ino, in case we need to sort\n                   entries before processing them.  */\n                p->fts_statp->st_ino = D_INO (dp);\n\n                /* Build a file name for fts_stat to stat. */\n                if (ISSET(FTS_NOCHDIR)) {\n                        p->fts_accpath = p->fts_path;\n                        memmove(cp, p->fts_name, p->fts_namelen + 1);\n                } else\n                        p->fts_accpath = p->fts_name;\n\n                if (sp->fts_compar == NULL || ISSET(FTS_DEFER_STAT)) {\n                        /* Record what fts_read will have to do with this\n                           entry. In many cases, it will simply fts_stat it,\n                           but we can take advantage of any d_type information\n                           to optimize away the unnecessary stat calls.  I.e.,\n                           if FTS_NOSTAT is in effect and we're not following\n                           symlinks (FTS_PHYSICAL) and d_type indicates this\n                           is *not* a directory, then we won't have to stat it\n                           at all.  If it *is* a directory, then (currently)\n                           we stat it regardless, in order to get device and\n                           inode numbers.  Some day we might optimize that\n                           away, too, for directories where d_ino is known to\n                           be valid.  */\n                        bool skip_stat = (ISSET(FTS_PHYSICAL)\n                                          && ISSET(FTS_NOSTAT)\n                                          && DT_IS_KNOWN(dp)\n                                          && ! DT_MUST_BE(dp, DT_DIR));\n                        p->fts_info = FTS_NSOK;\n                        /* Propagate dirent.d_type information back\n                           to caller, when possible.  */\n                        set_stat_type (p->fts_statp, D_TYPE (dp));\n                        fts_set_stat_required(p, !skip_stat);\n                        is_dir = (ISSET(FTS_PHYSICAL)\n                                  && DT_MUST_BE(dp, DT_DIR));\n                } else {\n                        p->fts_info = fts_stat(sp, p, false);\n                        is_dir = (p->fts_info == FTS_D\n                                  || p->fts_info == FTS_DC\n                                  || p->fts_info == FTS_DOT);\n                }\n\n                /* Decrement link count if applicable. */\n                if (nlinks > 0 && is_dir)\n                        nlinks -= nostat;\n\n                /* We walk in directory order so \"ls -f\" doesn't get upset. */\n                p->fts_link = NULL;\n                if (head == NULL)\n                        head = tail = p;\n                else {\n                        tail->fts_link = p;\n                        tail = p;\n                }\n                ++nitems;\n                if (max_entries <= nitems) {\n                        /* When there are too many dir entries, leave\n                           fts_dirp open, so that a subsequent fts_read\n                           can take up where we leave off.  */\n                        goto break_without_closedir;\n                }\n        }\n\n        if (cur->fts_dirp)\n                closedir_and_clear(cur->fts_dirp);\n\n break_without_closedir:\n\n        /*\n         * If realloc() changed the address of the file name, adjust the\n         * addresses for the rest of the tree and the dir list.\n         */\n        if (doadjust)\n                fts_padjust(sp, head);\n\n        /*\n         * If not changing directories, reset the file name back to original\n         * state.\n         */\n        if (ISSET(FTS_NOCHDIR)) {\n                if (len == sp->fts_pathlen || nitems == 0)\n                        --cp;\n                *cp = '\\0';\n        }\n\n        /*\n         * If descended after called from fts_children or after called from\n         * fts_read and nothing found, get back.  At the root level we use\n         * the saved fd; if one of fts_open()'s arguments is a relative name\n         * to an empty directory, we wind up here with no other way back.  If\n         * can't get back, we're done.\n         */\n        if (!continue_readdir && descend && (type == BCHILD || !nitems) &&\n            (cur->fts_level == FTS_ROOTLEVEL\n             ? restore_initial_cwd(sp)\n             : fts_safe_changedir(sp, cur->fts_parent, -1, \"..\"))) {\n                cur->fts_info = FTS_ERR;\n                SET(FTS_STOP);\n                fts_lfree(head);\n                return (NULL);\n        }\n\n        /* If didn't find anything, return NULL. */\n        if (!nitems) {\n                if (type == BREAD)\n                        cur->fts_info = FTS_DP;\n                fts_lfree(head);\n                return (NULL);\n        }\n\n        /* If there are many entries, no sorting function has been specified,\n           and this file system is of a type that may be slow with a large\n           number of entries, then sort the directory entries on increasing\n           inode numbers.  */\n        if (nitems > _FTS_INODE_SORT_DIR_ENTRIES_THRESHOLD\n            && !sp->fts_compar\n            && ISSET (FTS_CWDFD)\n            && dirent_inode_sort_may_be_useful (sp->fts_cwd_fd)) {\n                sp->fts_compar = fts_compare_ino;\n                head = fts_sort (sp, head, nitems);\n                sp->fts_compar = NULL;\n        }\n\n        /* Sort the entries. */\n        if (sp->fts_compar && nitems > 1)\n                head = fts_sort(sp, head, nitems);\n        return (head);\n}",
        "lines": 359,
        "depth": 15,
        "decorators": [
          "static",
          "static",
          "FTSENT",
          "*\ninternal_function\nfts_build (register FTS *sp, int type)",
          "*"
        ]
      },
      {
        "start_point": [
          1855,
          0
        ],
        "end_point": [
          1903,
          1
        ],
        "content": "static FTSENT *\ninternal_function\nfts_sort (FTS *sp, FTSENT *head, register size_t nitems)\n{\n        register FTSENT **ap, *p;\n\n        /* On most modern hosts, void * and FTSENT ** have the same\n           run-time representation, and one can convert sp->fts_compar to\n           the type qsort expects without problem.  Use the heuristic that\n           this is OK if the two pointer types are the same size, and if\n           converting FTSENT ** to long int is the same as converting\n           FTSENT ** to void * and then to long int.  This heuristic isn't\n           valid in general but we don't know of any counterexamples.  */\n        FTSENT *dummy;\n        int (*compare) (void const *, void const *) =\n          ((sizeof &dummy == sizeof (void *)\n            && (long int) &dummy == (long int) (void *) &dummy)\n           ? (int (*) (void const *, void const *)) sp->fts_compar\n           : fts_compar);\n\n        /*\n         * Construct an array of pointers to the structures and call qsort(3).\n         * Reassemble the array in the order returned by qsort.  If unable to\n         * sort for memory reasons, return the directory entries in their\n         * current order.  Allocate enough space for the current needs plus\n         * 40 so don't realloc one entry at a time.\n         */\n        if (nitems > sp->fts_nitems) {\n                FTSENT **a;\n\n                sp->fts_nitems = nitems + 40;\n                if (SIZE_MAX / sizeof *a < sp->fts_nitems\n                    || ! (a = realloc (sp->fts_array,\n                                       sp->fts_nitems * sizeof *a))) {\n                        free(sp->fts_array);\n                        sp->fts_array = NULL;\n                        sp->fts_nitems = 0;\n                        return (head);\n                }\n                sp->fts_array = a;\n        }\n        for (ap = sp->fts_array, p = head; p; p = p->fts_link)\n                *ap++ = p;\n        qsort((void *)sp->fts_array, nitems, sizeof(FTSENT *), compare);\n        for (head = *(ap = sp->fts_array); --nitems; ++ap)\n                ap[0]->fts_link = ap[1];\n        ap[0]->fts_link = NULL;\n        return (head);\n}",
        "lines": 49,
        "depth": 16,
        "decorators": [
          "static",
          "static",
          "FTSENT",
          "*\ninternal_function\nfts_sort (FTS *sp, FTSENT *head, register size_t nitems)",
          "*"
        ]
      },
      {
        "start_point": [
          1905,
          0
        ],
        "end_point": [
          1944,
          1
        ],
        "content": "static FTSENT *\ninternal_function\nfts_alloc (FTS *sp, const char *name, register size_t namelen)\n{\n        register FTSENT *p;\n        size_t len;\n\n        /*\n         * The file name is a variable length array.  Allocate the FTSENT\n         * structure and the file name in one chunk.\n         */\n        len = offsetof(FTSENT, fts_name) + namelen + 1;\n        /* Align the allocation size so that it works for FTSENT,\n           so that trailing padding may be referenced by direct access\n           to the flexible array members, without triggering undefined behavior\n           by accessing bytes beyond the heap allocation.  This implicit access\n           was seen for example with ISDOT() and GCC 5.1.1 at -O2.\n           Do not use alignof (FTSENT) here, since C11 prohibits\n           taking the alignment of a structure containing a flexible\n           array member.  */\n        len += alignof (max_align_t) - 1;\n        len &= ~ (alignof (max_align_t) - 1);\n        if ((p = malloc(len)) == NULL)\n                return (NULL);\n\n        /* Copy the name and guarantee NUL termination. */\n        memcpy(p->fts_name, name, namelen);\n        p->fts_name[namelen] = '\\0';\n\n        p->fts_namelen = namelen;\n        p->fts_fts = sp;\n        p->fts_path = sp->fts_path;\n        p->fts_errno = 0;\n        p->fts_dirp = NULL;\n        p->fts_flags = 0;\n        p->fts_instr = FTS_NOINSTR;\n        p->fts_number = 0;\n        p->fts_pointer = NULL;\n        return (p);\n}",
        "lines": 40,
        "depth": 10,
        "decorators": [
          "static",
          "static",
          "FTSENT",
          "*\ninternal_function\nfts_alloc (FTS *sp, const char *name, register size_t namelen)",
          "*"
        ]
      },
      {
        "start_point": [
          1946,
          0
        ],
        "end_point": [
          1959,
          1
        ],
        "content": "static void\ninternal_function\nfts_lfree (register FTSENT *head)\n{\n        register FTSENT *p;\n\n        /* Free a linked list of structures. */\n        while ((p = head)) {\n                head = head->fts_link;\n                if (p->fts_dirp)\n                        closedir (p->fts_dirp);\n                free(p);\n        }\n}",
        "lines": 14,
        "depth": 10,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          1968,
          0
        ],
        "end_point": [
          1993,
          1
        ],
        "content": "static bool\ninternal_function\nfts_palloc (FTS *sp, size_t more)\n{\n        char *p;\n        size_t new_len = sp->fts_pathlen + more + 256;\n\n        /*\n         * See if fts_pathlen would overflow.\n         */\n        if (new_len < sp->fts_pathlen) {\n                free(sp->fts_path);\n                sp->fts_path = NULL;\n                __set_errno (ENAMETOOLONG);\n                return false;\n        }\n        sp->fts_pathlen = new_len;\n        p = realloc(sp->fts_path, sp->fts_pathlen);\n        if (p == NULL) {\n                free(sp->fts_path);\n                sp->fts_path = NULL;\n                return false;\n        }\n        sp->fts_path = p;\n        return true;\n}",
        "lines": 26,
        "depth": 9,
        "decorators": [
          "static",
          "static",
          "bool"
        ]
      }
    ],
    "cwd_advance_fd": {
      "start_point": [
        323,
        0
      ],
      "end_point": [
        346,
        1
      ],
      "content": "static void\ninternal_function\ncwd_advance_fd (FTS *sp, int fd, bool chdir_down_one)\n{\n  int old = sp->fts_cwd_fd;\n  fts_assert (old != fd || old == AT_FDCWD);\n\n  if (chdir_down_one)\n    {\n      /* Push \"old\" onto the ring.\n         If the displaced file descriptor is non-negative, close it.  */\n      int prev_fd_in_slot = i_ring_push (&sp->fts_fd_ring, old);\n      fd_ring_print (sp, stderr, \"post-push\");\n      if (0 <= prev_fd_in_slot)\n        close (prev_fd_in_slot); /* ignore any close failure */\n    }\n  else if ( ! ISSET (FTS_NOCHDIR))\n    {\n      if (0 <= old)\n        close (old); /* ignore any close failure */\n    }\n\n  sp->fts_cwd_fd = fd;\n}",
      "lines": 24,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void",
        "internal_function",
        "internal_function"
      ]
    },
    "restore_initial_cwd": {
      "start_point": [
        352,
        0
      ],
      "end_point": [
        358,
        1
      ],
      "content": "static int\nrestore_initial_cwd (FTS *sp)\n{\n  int fail = FCHDIR (sp, ISSET (FTS_CWDFD) ? AT_FDCWD : sp->fts_rfd);\n  fd_ring_clear (&(sp->fts_fd_ring));\n  return fail;\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "fts_open": {
      "start_point": [
        380,
        0
      ],
      "end_point": [
        568,
        1
      ],
      "content": "FTS *\nfts_open (char * const *argv,\n          register int options,\n          int (*compar) (FTSENT const **, FTSENT const **))\n{\n        register FTS *sp;\n        register FTSENT *p, *root;\n        register size_t nitems;\n        FTSENT *parent = NULL;\n        FTSENT *tmp = NULL;     /* pacify gcc */\n        bool defer_stat;\n\n        /* Options check. */\n        if (options & ~FTS_OPTIONMASK) {\n                __set_errno (EINVAL);\n                return (NULL);\n        }\n        if ((options & FTS_NOCHDIR) && (options & FTS_CWDFD)) {\n                __set_errno (EINVAL);\n                return (NULL);\n        }\n        if ( ! (options & (FTS_LOGICAL | FTS_PHYSICAL))) {\n                __set_errno (EINVAL);\n                return (NULL);\n        }\n\n        /* Allocate/initialize the stream */\n        if ((sp = malloc(sizeof(FTS))) == NULL)\n                return (NULL);\n        memset(sp, 0, sizeof(FTS));\n        sp->fts_compar = compar;\n        sp->fts_options = options;\n\n        /* Logical walks turn on NOCHDIR; symbolic links are too hard. */\n        if (ISSET(FTS_LOGICAL)) {\n                SET(FTS_NOCHDIR);\n                CLR(FTS_CWDFD);\n        }\n\n        /* Initialize fts_cwd_fd.  */\n        sp->fts_cwd_fd = AT_FDCWD;\n        if ( ISSET(FTS_CWDFD) && ! HAVE_OPENAT_SUPPORT)\n          {\n            /* While it isn't technically necessary to open \".\" this\n               early, doing it here saves us the trouble of ensuring\n               later (where it'd be messier) that \".\" can in fact\n               be opened.  If not, revert to FTS_NOCHDIR mode.  */\n            int fd = open (\".\",\n                           O_SEARCH | (ISSET (FTS_NOATIME) ? O_NOATIME : 0));\n            if (fd < 0)\n              {\n                /* Even if \".\" is unreadable, don't revert to FTS_NOCHDIR mode\n                   on systems like Linux+PROC_FS, where our openat emulation\n                   is good enough.  Note: on a system that emulates\n                   openat via /proc, this technique can still fail, but\n                   only in extreme conditions, e.g., when the working\n                   directory cannot be saved (i.e. save_cwd fails) --\n                   and that happens on Linux only when \".\" is unreadable\n                   and the CWD would be longer than PATH_MAX.\n                   FIXME: once Linux kernel openat support is well established,\n                   replace the above open call and this entire if/else block\n                   with the body of the if-block below.  */\n                if ( openat_needs_fchdir ())\n                  {\n                    SET(FTS_NOCHDIR);\n                    CLR(FTS_CWDFD);\n                  }\n              }\n            else\n              {\n                close (fd);\n              }\n          }\n\n        /*\n         * Start out with 1K of file name space, and enough, in any case,\n         * to hold the user's file names.\n         */\n#ifndef MAXPATHLEN\n# define MAXPATHLEN 1024\n#endif\n        {\n          size_t maxarglen = fts_maxarglen(argv);\n          if (! fts_palloc(sp, MAX(maxarglen, MAXPATHLEN)))\n                  goto mem1;\n        }\n\n        /* Allocate/initialize root's parent. */\n        if (*argv != NULL) {\n                if ((parent = fts_alloc(sp, \"\", 0)) == NULL)\n                        goto mem2;\n                parent->fts_level = FTS_ROOTPARENTLEVEL;\n          }\n\n        /* The classic fts implementation would call fts_stat with\n           a new entry for each iteration of the loop below.\n           If the comparison function is not specified or if the\n           FTS_DEFER_STAT option is in effect, don't stat any entry\n           in this loop.  This is an attempt to minimize the interval\n           between the initial stat/lstat/fstatat and the point at which\n           a directory argument is first opened.  This matters for any\n           directory command line argument that resides on a file system\n           without genuine i-nodes.  If you specify FTS_DEFER_STAT along\n           with a comparison function, that function must not access any\n           data via the fts_statp pointer.  */\n        defer_stat = (compar == NULL || ISSET(FTS_DEFER_STAT));\n\n        /* Allocate/initialize root(s). */\n        for (root = NULL, nitems = 0; *argv != NULL; ++argv, ++nitems) {\n                /* *Do* allow zero-length file names. */\n                size_t len = strlen(*argv);\n\n                if ( ! (options & FTS_VERBATIM))\n                  {\n                    /* If there are two or more trailing slashes, trim all but one,\n                       but don't change \"//\" to \"/\", and do map \"///\" to \"/\".  */\n                    char const *v = *argv;\n                    if (2 < len && v[len - 1] == '/')\n                      while (1 < len && v[len - 2] == '/')\n                        --len;\n                  }\n\n                if ((p = fts_alloc(sp, *argv, len)) == NULL)\n                        goto mem3;\n                p->fts_level = FTS_ROOTLEVEL;\n                p->fts_parent = parent;\n                p->fts_accpath = p->fts_name;\n                /* Even when defer_stat is true, be sure to stat the first\n                   command line argument, since fts_read (at least with\n                   FTS_XDEV) requires that.  */\n                if (defer_stat && root != NULL) {\n                        p->fts_info = FTS_NSOK;\n                        fts_set_stat_required(p, true);\n                } else {\n                        p->fts_info = fts_stat(sp, p, false);\n                }\n\n                /*\n                 * If comparison routine supplied, traverse in sorted\n                 * order; otherwise traverse in the order specified.\n                 */\n                if (compar) {\n                        p->fts_link = root;\n                        root = p;\n                } else {\n                        p->fts_link = NULL;\n                        if (root == NULL)\n                                tmp = root = p;\n                        else {\n                                tmp->fts_link = p;\n                                tmp = p;\n                        }\n                }\n        }\n        if (compar && nitems > 1)\n                root = fts_sort(sp, root, nitems);\n\n        /*\n         * Allocate a dummy pointer and make fts_read think that we've just\n         * finished the node before the root(s); set p->fts_info to FTS_INIT\n         * so that everything about the \"current\" node is ignored.\n         */\n        if ((sp->fts_cur = fts_alloc(sp, \"\", 0)) == NULL)\n                goto mem3;\n        sp->fts_cur->fts_link = root;\n        sp->fts_cur->fts_info = FTS_INIT;\n        if (! setup_dir (sp))\n                goto mem3;\n\n        /*\n         * If using chdir(2), grab a file descriptor pointing to dot to ensure\n         * that we can get back here; this could be avoided for some file names,\n         * but almost certainly not worth the effort.  Slashes, symbolic links,\n         * and \"..\" are all fairly nasty problems.  Note, if we can't get the\n         * descriptor we run anyway, just more slowly.\n         */\n        if (!ISSET(FTS_NOCHDIR) && !ISSET(FTS_CWDFD)\n            && (sp->fts_rfd = diropen (sp, \".\")) < 0)\n                SET(FTS_NOCHDIR);\n\n        i_ring_init (&sp->fts_fd_ring, -1);\n        return (sp);\n\nmem3:   fts_lfree(root);\n        free(parent);\nmem2:   free(sp->fts_path);\nmem1:   free(sp);\n        return (NULL);\n}",
      "lines": 189,
      "depth": 14,
      "decorators": [
        "FTS",
        "*\nfts_open (char * const *argv,\n          register int options,\n          int (*compar) (FTSENT const **, FTSENT const **))",
        "*"
      ]
    },
    "fts_close": {
      "start_point": [
        594,
        0
      ],
      "end_point": [
        656,
        1
      ],
      "content": "int\nfts_close (FTS *sp)\n{\n        register FTSENT *freep, *p;\n        int saved_errno = 0;\n\n        /*\n         * This still works if we haven't read anything -- the dummy structure\n         * points to the root list, so we step through to the end of the root\n         * list which has a valid parent pointer.\n         */\n        if (sp->fts_cur) {\n                for (p = sp->fts_cur; p->fts_level >= FTS_ROOTLEVEL;) {\n                        freep = p;\n                        p = p->fts_link != NULL ? p->fts_link : p->fts_parent;\n                        free(freep);\n                }\n                free(p);\n        }\n\n        /* Free up child linked list, sort array, file name buffer. */\n        if (sp->fts_child)\n                fts_lfree(sp->fts_child);\n        free(sp->fts_array);\n        free(sp->fts_path);\n\n        if (ISSET(FTS_CWDFD))\n          {\n            if (0 <= sp->fts_cwd_fd)\n              if (close (sp->fts_cwd_fd))\n                saved_errno = errno;\n          }\n        else if (!ISSET(FTS_NOCHDIR))\n          {\n            /* Return to original directory, save errno if necessary. */\n            if (fchdir(sp->fts_rfd))\n              saved_errno = errno;\n\n            /* If close fails, record errno only if saved_errno is zero,\n               so that we report the probably-more-meaningful fchdir errno.  */\n            if (close (sp->fts_rfd))\n              if (saved_errno == 0)\n                saved_errno = errno;\n          }\n\n        fd_ring_clear (&sp->fts_fd_ring);\n\n        if (sp->fts_leaf_optimization_works_ht)\n          hash_free (sp->fts_leaf_optimization_works_ht);\n\n        free_dir (sp);\n\n        /* Free up the stream pointer. */\n        free(sp);\n\n        /* Set errno and return. */\n        if (saved_errno) {\n                __set_errno (saved_errno);\n                return (-1);\n        }\n\n        return (0);\n}",
      "lines": 63,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "dirent_inode_sort_may_be_useful": [
      {
        "start_point": [
          674,
          0
        ],
        "end_point": [
          701,
          1
        ],
        "content": "static bool\ndirent_inode_sort_may_be_useful (int dir_fd)\n{\n  /* Skip the sort only if we can determine efficiently\n     that skipping it is the right thing to do.\n     The cost of performing an unnecessary sort is negligible,\n     while the cost of *not* performing it can be O(N^2) with\n     a very large constant.  */\n  struct statfs fs_buf;\n\n  /* If fstatfs fails, assume sorting would be useful.  */\n  if (fstatfs (dir_fd, &fs_buf) != 0)\n    return true;\n\n  /* FIXME: what about when f_type is not an integral type?\n     deal with that if/when it's encountered.  */\n  switch (fs_buf.f_type)\n    {\n    case S_MAGIC_TMPFS:\n    case S_MAGIC_NFS:\n      /* On a file system of any of these types, sorting\n         is unnecessary, and hence wasteful.  */\n      return false;\n\n    default:\n      return true;\n    }\n}",
        "lines": 28,
        "depth": 9,
        "decorators": [
          "static",
          "static",
          "bool"
        ]
      },
      {
        "start_point": [
          743,
          0
        ],
        "end_point": [
          744,
          72
        ],
        "content": "static bool\ndirent_inode_sort_may_be_useful (int dir_fd _GL_UNUSED) { return true; }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "bool"
        ]
      }
    ],
    "leaf_optimization_applies": [
      {
        "start_point": [
          706,
          0
        ],
        "end_point": [
          740,
          1
        ],
        "content": "static bool\nleaf_optimization_applies (int dir_fd)\n{\n  struct statfs fs_buf;\n\n  /* If fstatfs fails, assume we can't use the optimization.  */\n  if (fstatfs (dir_fd, &fs_buf) != 0)\n    return false;\n\n  /* FIXME: do we need to detect AFS mount points?  I doubt it,\n     unless fstatfs can report S_MAGIC_REISERFS for such a directory.  */\n\n  switch (fs_buf.f_type)\n    {\n    case S_MAGIC_NFS:\n      /* NFS provides usable dirent.d_type but not necessarily for all entries\n         of large directories.  See <https://bugzilla.redhat.com/1252549>.  */\n      return true;\n\n      /* List here the file system types that lack usable dirent.d_type\n         info, yet for which the optimization does apply.  */\n    case S_MAGIC_REISERFS:\n    case S_MAGIC_XFS:\n      return true;\n\n    case S_MAGIC_PROC:\n      /* Explicitly listing this or any other file system type for which\n         the optimization is not applicable is not necessary, but we leave\n         it here to document the risk.  Per http://bugs.debian.org/143111,\n         /proc may have bogus stat.st_nlink values.  */\n      /* fall through */\n    default:\n      return false;\n    }\n}",
        "lines": 35,
        "depth": 9,
        "decorators": [
          "static",
          "static",
          "bool"
        ]
      },
      {
        "start_point": [
          745,
          0
        ],
        "end_point": [
          746,
          67
        ],
        "content": "static bool\nleaf_optimization_applies (int dir_fd _GL_UNUSED) { return false; }",
        "lines": 2,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "bool"
        ]
      }
    ],
    "LCO_hash": {
      "start_point": [
        762,
        0
      ],
      "end_point": [
        767,
        1
      ],
      "content": "static size_t\nLCO_hash (void const *x, size_t table_size)\n{\n  struct LCO_ent const *ax = x;\n  return (uintmax_t) ax->st_dev % table_size;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "LCO_compare": {
      "start_point": [
        769,
        0
      ],
      "end_point": [
        775,
        1
      ],
      "content": "static bool\nLCO_compare (void const *x, void const *y)\n{\n  struct LCO_ent const *ax = x;\n  struct LCO_ent const *ay = y;\n  return ax->st_dev == ay->st_dev;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "link_count_optimize_ok": {
      "start_point": [
        780,
        0
      ],
      "end_point": [
        829,
        1
      ],
      "content": "static bool\nlink_count_optimize_ok (FTSENT const *p)\n{\n  FTS *sp = p->fts_fts;\n  Hash_table *h = sp->fts_leaf_optimization_works_ht;\n  struct LCO_ent tmp;\n  struct LCO_ent *ent;\n  bool opt_ok;\n  struct LCO_ent *t2;\n\n  /* If we're not in CWDFD mode, don't bother with this optimization,\n     since the caller is not serious about performance. */\n  if (!ISSET(FTS_CWDFD))\n    return false;\n\n  /* map st_dev to the boolean, leaf_optimization_works */\n  if (h == NULL)\n    {\n      h = sp->fts_leaf_optimization_works_ht\n        = hash_initialize (LCO_HT_INITIAL_SIZE, NULL, LCO_hash,\n                           LCO_compare, free);\n      if (h == NULL)\n        return false;\n    }\n  tmp.st_dev = p->fts_statp->st_dev;\n  ent = hash_lookup (h, &tmp);\n  if (ent)\n    return ent->opt_ok;\n\n  /* Look-up failed.  Query directly and cache the result.  */\n  t2 = malloc (sizeof *t2);\n  if (t2 == NULL)\n    return false;\n\n  /* Is it ok to perform the optimization in the dir, FTS_CWD_FD?  */\n  opt_ok = leaf_optimization_applies (sp->fts_cwd_fd);\n  t2->opt_ok = opt_ok;\n  t2->st_dev = p->fts_statp->st_dev;\n\n  ent = hash_insert (h, t2);\n  if (ent == NULL)\n    {\n      /* insertion failed */\n      free (t2);\n      return false;\n    }\n  fts_assert (ent == t2);\n\n  return opt_ok;\n}",
      "lines": 50,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "fts_read": {
      "start_point": [
        839,
        0
      ],
      "end_point": [
        1109,
        1
      ],
      "content": "FTSENT *\nfts_read (register FTS *sp)\n{\n        register FTSENT *p, *tmp;\n        register unsigned short int instr;\n        register char *t;\n\n        /* If finished or unrecoverable error, return NULL. */\n        if (sp->fts_cur == NULL || ISSET(FTS_STOP))\n                return (NULL);\n\n        /* Set current node pointer. */\n        p = sp->fts_cur;\n\n        /* Save and zero out user instructions. */\n        instr = p->fts_instr;\n        p->fts_instr = FTS_NOINSTR;\n\n        /* Any type of file may be re-visited; re-stat and re-turn. */\n        if (instr == FTS_AGAIN) {\n                p->fts_info = fts_stat(sp, p, false);\n                return (p);\n        }\n        Dprintf ((\"fts_read: p=%s\\n\",\n                  p->fts_info == FTS_INIT ? \"\" : p->fts_path));\n\n        /*\n         * Following a symlink -- SLNONE test allows application to see\n         * SLNONE and recover.  If indirecting through a symlink, have\n         * keep a pointer to current location.  If unable to get that\n         * pointer, follow fails.\n         */\n        if (instr == FTS_FOLLOW &&\n            (p->fts_info == FTS_SL || p->fts_info == FTS_SLNONE)) {\n                p->fts_info = fts_stat(sp, p, true);\n                if (p->fts_info == FTS_D && !ISSET(FTS_NOCHDIR)) {\n                        if ((p->fts_symfd = diropen (sp, \".\")) < 0) {\n                                p->fts_errno = errno;\n                                p->fts_info = FTS_ERR;\n                        } else\n                                p->fts_flags |= FTS_SYMFOLLOW;\n                }\n                goto check_for_dir;\n        }\n\n        /* Directory in pre-order. */\n        if (p->fts_info == FTS_D) {\n                /* If skipped or crossed mount point, do post-order visit. */\n                if (instr == FTS_SKIP ||\n                    (ISSET(FTS_XDEV) && p->fts_statp->st_dev != sp->fts_dev)) {\n                        if (p->fts_flags & FTS_SYMFOLLOW)\n                                (void)close(p->fts_symfd);\n                        if (sp->fts_child) {\n                                fts_lfree(sp->fts_child);\n                                sp->fts_child = NULL;\n                        }\n                        p->fts_info = FTS_DP;\n                        LEAVE_DIR (sp, p, \"1\");\n                        return (p);\n                }\n\n                /* Rebuild if only read the names and now traversing. */\n                if (sp->fts_child != NULL && ISSET(FTS_NAMEONLY)) {\n                        CLR(FTS_NAMEONLY);\n                        fts_lfree(sp->fts_child);\n                        sp->fts_child = NULL;\n                }\n\n                /*\n                 * Cd to the subdirectory.\n                 *\n                 * If have already read and now fail to chdir, whack the list\n                 * to make the names come out right, and set the parent errno\n                 * so the application will eventually get an error condition.\n                 * Set the FTS_DONTCHDIR flag so that when we logically change\n                 * directories back to the parent we don't do a chdir.\n                 *\n                 * If haven't read do so.  If the read fails, fts_build sets\n                 * FTS_STOP or the fts_info field of the node.\n                 */\n                if (sp->fts_child != NULL) {\n                        if (fts_safe_changedir(sp, p, -1, p->fts_accpath)) {\n                                p->fts_errno = errno;\n                                p->fts_flags |= FTS_DONTCHDIR;\n                                for (p = sp->fts_child; p != NULL;\n                                     p = p->fts_link)\n                                        p->fts_accpath =\n                                            p->fts_parent->fts_accpath;\n                        }\n                } else if ((sp->fts_child = fts_build(sp, BREAD)) == NULL) {\n                        if (ISSET(FTS_STOP))\n                                return (NULL);\n                        /* If fts_build's call to fts_safe_changedir failed\n                           because it was not able to fchdir into a\n                           subdirectory, tell the caller.  */\n                        if (p->fts_errno && p->fts_info != FTS_DNR)\n                                p->fts_info = FTS_ERR;\n                        LEAVE_DIR (sp, p, \"2\");\n                        return (p);\n                }\n                p = sp->fts_child;\n                sp->fts_child = NULL;\n                goto name;\n        }\n\n        /* Move to the next node on this level. */\nnext:   tmp = p;\n\n        /* If we have so many directory entries that we're reading them\n           in batches, and we've reached the end of the current batch,\n           read in a new batch.  */\n        if (p->fts_link == NULL && p->fts_parent->fts_dirp)\n          {\n            p = tmp->fts_parent;\n            sp->fts_cur = p;\n            sp->fts_path[p->fts_pathlen] = '\\0';\n\n            if ((p = fts_build (sp, BREAD)) == NULL)\n              {\n                if (ISSET(FTS_STOP))\n                  return NULL;\n                goto cd_dot_dot;\n              }\n\n            free(tmp);\n            goto name;\n          }\n\n        if ((p = p->fts_link) != NULL) {\n                sp->fts_cur = p;\n                free(tmp);\n\n                /*\n                 * If reached the top, return to the original directory (or\n                 * the root of the tree), and load the file names for the next\n                 * root.\n                 */\n                if (p->fts_level == FTS_ROOTLEVEL) {\n                        if (restore_initial_cwd(sp)) {\n                                SET(FTS_STOP);\n                                return (NULL);\n                        }\n                        free_dir(sp);\n                        fts_load(sp, p);\n                        setup_dir(sp);\n                        goto check_for_dir;\n                }\n\n                /*\n                 * User may have called fts_set on the node.  If skipped,\n                 * ignore.  If followed, get a file descriptor so we can\n                 * get back if necessary.\n                 */\n                if (p->fts_instr == FTS_SKIP)\n                        goto next;\n                if (p->fts_instr == FTS_FOLLOW) {\n                        p->fts_info = fts_stat(sp, p, true);\n                        if (p->fts_info == FTS_D && !ISSET(FTS_NOCHDIR)) {\n                                if ((p->fts_symfd = diropen (sp, \".\")) < 0) {\n                                        p->fts_errno = errno;\n                                        p->fts_info = FTS_ERR;\n                                } else\n                                        p->fts_flags |= FTS_SYMFOLLOW;\n                        }\n                        p->fts_instr = FTS_NOINSTR;\n                }\n\nname:           t = sp->fts_path + NAPPEND(p->fts_parent);\n                *t++ = '/';\n                memmove(t, p->fts_name, p->fts_namelen + 1);\ncheck_for_dir:\n                sp->fts_cur = p;\n                if (p->fts_info == FTS_NSOK)\n                  {\n                    if (p->fts_statp->st_size == FTS_STAT_REQUIRED)\n                      {\n                        FTSENT *parent = p->fts_parent;\n                        if (FTS_ROOTLEVEL < p->fts_level\n                            /* ->fts_n_dirs_remaining is not valid\n                               for command-line-specified names.  */\n                            && parent->fts_n_dirs_remaining == 0\n                            && ISSET(FTS_NOSTAT)\n                            && ISSET(FTS_PHYSICAL)\n                            && link_count_optimize_ok (parent))\n                          {\n                            /* nothing more needed */\n                          }\n                        else\n                          {\n                            p->fts_info = fts_stat(sp, p, false);\n                            if (S_ISDIR(p->fts_statp->st_mode)\n                                && p->fts_level != FTS_ROOTLEVEL\n                                && parent->fts_n_dirs_remaining)\n                                  parent->fts_n_dirs_remaining--;\n                          }\n                      }\n                    else\n                      fts_assert (p->fts_statp->st_size == FTS_NO_STAT_REQUIRED);\n                  }\n\n                if (p->fts_info == FTS_D)\n                  {\n                    /* Now that P->fts_statp is guaranteed to be valid,\n                       if this is a command-line directory, record its\n                       device number, to be used for FTS_XDEV.  */\n                    if (p->fts_level == FTS_ROOTLEVEL)\n                      sp->fts_dev = p->fts_statp->st_dev;\n                    Dprintf ((\"  entering: %s\\n\", p->fts_path));\n                    if (! enter_dir (sp, p))\n                      {\n                        __set_errno (ENOMEM);\n                        return NULL;\n                      }\n                  }\n                return p;\n        }\ncd_dot_dot:\n\n        /* Move up to the parent node. */\n        p = tmp->fts_parent;\n        sp->fts_cur = p;\n        free(tmp);\n\n        if (p->fts_level == FTS_ROOTPARENTLEVEL) {\n                /*\n                 * Done; free everything up and set errno to 0 so the user\n                 * can distinguish between error and EOF.\n                 */\n                free(p);\n                __set_errno (0);\n                return (sp->fts_cur = NULL);\n        }\n\n        fts_assert (p->fts_info != FTS_NSOK);\n\n        /* NUL terminate the file name.  */\n        sp->fts_path[p->fts_pathlen] = '\\0';\n\n        /*\n         * Return to the parent directory.  If at a root node, restore\n         * the initial working directory.  If we came through a symlink,\n         * go back through the file descriptor.  Otherwise, move up\n         * one level, via \"..\".\n         */\n        if (p->fts_level == FTS_ROOTLEVEL) {\n                if (restore_initial_cwd(sp)) {\n                        p->fts_errno = errno;\n                        SET(FTS_STOP);\n                }\n        } else if (p->fts_flags & FTS_SYMFOLLOW) {\n                if (FCHDIR(sp, p->fts_symfd)) {\n                        p->fts_errno = errno;\n                        SET(FTS_STOP);\n                }\n                (void)close(p->fts_symfd);\n        } else if (!(p->fts_flags & FTS_DONTCHDIR) &&\n                   fts_safe_changedir(sp, p->fts_parent, -1, \"..\")) {\n                p->fts_errno = errno;\n                SET(FTS_STOP);\n        }\n\n        /* If the directory causes a cycle, preserve the FTS_DC flag and keep\n           the corresponding dev/ino pair in the hash table.  It is going to be\n           removed when leaving the original directory.  */\n        if (p->fts_info != FTS_DC) {\n                p->fts_info = p->fts_errno ? FTS_ERR : FTS_DP;\n                if (p->fts_errno == 0)\n                        LEAVE_DIR (sp, p, \"3\");\n        }\n        return ISSET(FTS_STOP) ? NULL : p;\n}",
      "lines": 271,
      "depth": 19,
      "decorators": [
        "FTSENT",
        "*\nfts_read (register FTS *sp)",
        "*"
      ]
    },
    "fts_set": {
      "start_point": [
        1118,
        0
      ],
      "end_point": [
        1128,
        1
      ],
      "content": "int\nfts_set(FTS *sp _GL_UNUSED, FTSENT *p, int instr)\n{\n        if (instr != 0 && instr != FTS_AGAIN && instr != FTS_FOLLOW &&\n            instr != FTS_NOINSTR && instr != FTS_SKIP) {\n                __set_errno (EINVAL);\n                return (1);\n        }\n        p->fts_instr = instr;\n        return (0);\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "fts_children": {
      "start_point": [
        1130,
        0
      ],
      "end_point": [
        1206,
        1
      ],
      "content": "FTSENT *\nfts_children (register FTS *sp, int instr)\n{\n        register FTSENT *p;\n        int fd;\n\n        if (instr != 0 && instr != FTS_NAMEONLY) {\n                __set_errno (EINVAL);\n                return (NULL);\n        }\n\n        /* Set current node pointer. */\n        p = sp->fts_cur;\n\n        /*\n         * Errno set to 0 so user can distinguish empty directory from\n         * an error.\n         */\n        __set_errno (0);\n\n        /* Fatal errors stop here. */\n        if (ISSET(FTS_STOP))\n                return (NULL);\n\n        /* Return logical hierarchy of user's arguments. */\n        if (p->fts_info == FTS_INIT)\n                return (p->fts_link);\n\n        /*\n         * If not a directory being visited in pre-order, stop here.  Could\n         * allow FTS_DNR, assuming the user has fixed the problem, but the\n         * same effect is available with FTS_AGAIN.\n         */\n        if (p->fts_info != FTS_D /* && p->fts_info != FTS_DNR */)\n                return (NULL);\n\n        /* Free up any previous child list. */\n        if (sp->fts_child != NULL)\n                fts_lfree(sp->fts_child);\n\n        if (instr == FTS_NAMEONLY) {\n                SET(FTS_NAMEONLY);\n                instr = BNAMES;\n        } else\n                instr = BCHILD;\n\n        /*\n         * If using chdir on a relative file name and called BEFORE fts_read\n         * does its chdir to the root of a traversal, we can lose -- we need to\n         * chdir into the subdirectory, and we don't know where the current\n         * directory is, so we can't get back so that the upcoming chdir by\n         * fts_read will work.\n         */\n        if (p->fts_level != FTS_ROOTLEVEL || p->fts_accpath[0] == '/' ||\n            ISSET(FTS_NOCHDIR))\n                return (sp->fts_child = fts_build(sp, instr));\n\n        if ((fd = diropen (sp, \".\")) < 0)\n                return (sp->fts_child = NULL);\n        sp->fts_child = fts_build(sp, instr);\n        if (ISSET(FTS_CWDFD))\n          {\n            cwd_advance_fd (sp, fd, true);\n          }\n        else\n          {\n            if (fchdir(fd))\n              {\n                int saved_errno = errno;\n                close (fd);\n                __set_errno (saved_errno);\n                return NULL;\n              }\n            close (fd);\n          }\n        return (sp->fts_child);\n}",
      "lines": 77,
      "depth": 11,
      "decorators": [
        "FTSENT",
        "*\nfts_children (register FTS *sp, int instr)",
        "*"
      ]
    },
    "fts_compare_ino": {
      "start_point": [
        1213,
        0
      ],
      "end_point": [
        1218,
        1
      ],
      "content": "static int\nfts_compare_ino (struct _ftsent const **a, struct _ftsent const **b)\n{\n  return (a[0]->fts_statp->st_ino < b[0]->fts_statp->st_ino ? -1\n          : b[0]->fts_statp->st_ino < a[0]->fts_statp->st_ino ? 1 : 0);\n}",
      "lines": 6,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "set_stat_type": {
      "start_point": [
        1222,
        0
      ],
      "end_point": [
        1253,
        1
      ],
      "content": "static void\nset_stat_type (struct stat *st, unsigned int dtype)\n{\n  mode_t type;\n  switch (dtype)\n    {\n    case DT_BLK:\n      type = S_IFBLK;\n      break;\n    case DT_CHR:\n      type = S_IFCHR;\n      break;\n    case DT_DIR:\n      type = S_IFDIR;\n      break;\n    case DT_FIFO:\n      type = S_IFIFO;\n      break;\n    case DT_LNK:\n      type = S_IFLNK;\n      break;\n    case DT_REG:\n      type = S_IFREG;\n      break;\n    case DT_SOCK:\n      type = S_IFSOCK;\n      break;\n    default:\n      type = 0;\n    }\n  st->st_mode = type;\n}",
      "lines": 32,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "find_matching_ancestor": {
      "start_point": [
        1653,
        0
      ],
      "end_point": [
        1674,
        1
      ],
      "content": "static void\nfind_matching_ancestor (FTSENT const *e_curr, struct Active_dir const *ad)\n{\n  FTSENT const *ent;\n  for (ent = e_curr; ent->fts_level >= FTS_ROOTLEVEL; ent = ent->fts_parent)\n    {\n      if (ad->ino == ent->fts_statp->st_ino\n          && ad->dev == ent->fts_statp->st_dev)\n        return;\n    }\n  printf (\"ERROR: tree dir, %s, not active\\n\", ad->fts_ent->fts_accpath);\n  printf (\"active dirs:\\n\");\n  for (ent = e_curr;\n       ent->fts_level >= FTS_ROOTLEVEL; ent = ent->fts_parent)\n    printf (\"  %s(%\"PRIuMAX\"/%\"PRIuMAX\") to %s(%\"PRIuMAX\"/%\"PRIuMAX\")...\\n\",\n            ad->fts_ent->fts_accpath,\n            (uintmax_t) ad->dev,\n            (uintmax_t) ad->ino,\n            ent->fts_accpath,\n            (uintmax_t) ent->fts_statp->st_dev,\n            (uintmax_t) ent->fts_statp->st_ino);\n}",
      "lines": 22,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "fts_cross_check": {
      "start_point": [
        1676,
        0
      ],
      "end_point": [
        1708,
        1
      ],
      "content": "void\nfts_cross_check (FTS const *sp)\n{\n  FTSENT const *ent = sp->fts_cur;\n  FTSENT const *t;\n  if ( ! ISSET (FTS_TIGHT_CYCLE_CHECK))\n    return;\n\n  Dprintf ((\"fts-cross-check cur=%s\\n\", ent->fts_path));\n  /* Make sure every parent dir is in the tree.  */\n  for (t = ent->fts_parent; t->fts_level >= FTS_ROOTLEVEL; t = t->fts_parent)\n    {\n      struct Active_dir ad;\n      ad.ino = t->fts_statp->st_ino;\n      ad.dev = t->fts_statp->st_dev;\n      if ( ! hash_lookup (sp->fts_cycle.ht, &ad))\n        printf (\"ERROR: active dir, %s, not in tree\\n\", t->fts_path);\n    }\n\n  /* Make sure every dir in the tree is an active dir.\n     But ENT is not necessarily a directory.  If so, just skip this part. */\n  if (ent->fts_parent->fts_level >= FTS_ROOTLEVEL\n      && (ent->fts_info == FTS_DP\n          || ent->fts_info == FTS_D))\n    {\n      struct Active_dir *ad;\n      for (ad = hash_get_first (sp->fts_cycle.ht); ad != NULL;\n           ad = hash_get_next (sp->fts_cycle.ht, ad))\n        {\n          find_matching_ancestor (ent, ad);\n        }\n    }\n}",
      "lines": 33,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "same_fd": {
      "start_point": [
        1710,
        0
      ],
      "end_point": [
        1717,
        1
      ],
      "content": "static bool\nsame_fd (int fd1, int fd2)\n{\n  struct stat sb1, sb2;\n  return (fstat (fd1, &sb1) == 0\n          && fstat (fd2, &sb2) == 0\n          && SAME_INODE (sb1, sb2));\n}",
      "lines": 8,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "fd_ring_print": {
      "start_point": [
        1719,
        0
      ],
      "end_point": [
        1745,
        1
      ],
      "content": "static void\nfd_ring_print (FTS const *sp, FILE *stream, char const *msg)\n{\n  I_ring const *fd_ring = &sp->fts_fd_ring;\n  unsigned int i = fd_ring->fts_front;\n  char *cwd = getcwdat (sp->fts_cwd_fd, NULL, 0);\n  fprintf (stream, \"=== %s ========== %s\\n\", msg, cwd);\n  free (cwd);\n  if (i_ring_empty (fd_ring))\n    return;\n\n  while (true)\n    {\n      int fd = fd_ring->fts_fd_ring[i];\n      if (fd < 0)\n        fprintf (stream, \"%d: %d:\\n\", i, fd);\n      else\n        {\n          char *wd = getcwdat (fd, NULL, 0);\n          fprintf (stream, \"%d: %d: %s\\n\", i, fd, wd);\n          free (wd);\n        }\n      if (i == fd_ring->fts_back)\n        break;\n      i = (i + I_RING_SIZE - 1) % I_RING_SIZE;\n    }\n}",
      "lines": 27,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "fd_ring_check": {
      "start_point": [
        1749,
        0
      ],
      "end_point": [
        1789,
        1
      ],
      "content": "static void\nfd_ring_check (FTS const *sp)\n{\n  if (!fts_debug)\n    return;\n\n  /* Make a writable copy.  */\n  I_ring fd_w = sp->fts_fd_ring;\n\n  int cwd_fd = sp->fts_cwd_fd;\n  cwd_fd = dup (cwd_fd);\n  char *dot = getcwdat (cwd_fd, NULL, 0);\n  error (0, 0, \"===== check ===== cwd: %s\", dot);\n  free (dot);\n  while ( ! i_ring_empty (&fd_w))\n    {\n      int fd = i_ring_pop (&fd_w);\n      if (0 <= fd)\n        {\n          int parent_fd = openat (cwd_fd, \"..\", O_SEARCH | O_NOATIME);\n          if (parent_fd < 0)\n            {\n              // Warn?\n              break;\n            }\n          if (!same_fd (fd, parent_fd))\n            {\n              char *cwd = getcwdat (fd, NULL, 0);\n              error (0, errno, \"ring  : %s\", cwd);\n              char *c2 = getcwdat (parent_fd, NULL, 0);\n              error (0, errno, \"parent: %s\", c2);\n              free (cwd);\n              free (c2);\n              fts_assert (0);\n            }\n          close (cwd_fd);\n          cwd_fd = parent_fd;\n        }\n    }\n  close (cwd_fd);\n}",
      "lines": 41,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "fts_stat": {
      "start_point": [
        1792,
        0
      ],
      "end_point": [
        1840,
        1
      ],
      "content": "static unsigned short int\ninternal_function\nfts_stat(FTS *sp, register FTSENT *p, bool follow)\n{\n        struct stat *sbp = p->fts_statp;\n        int saved_errno;\n\n        if (p->fts_level == FTS_ROOTLEVEL && ISSET(FTS_COMFOLLOW))\n                follow = true;\n\n        /*\n         * If doing a logical walk, or application requested FTS_FOLLOW, do\n         * a stat(2).  If that fails, check for a non-existent symlink.  If\n         * fail, set the errno from the stat call.\n         */\n        if (ISSET(FTS_LOGICAL) || follow) {\n                if (stat(p->fts_accpath, sbp)) {\n                        saved_errno = errno;\n                        if (errno == ENOENT\n                            && lstat(p->fts_accpath, sbp) == 0) {\n                                __set_errno (0);\n                                return (FTS_SLNONE);\n                        }\n                        p->fts_errno = saved_errno;\n                        goto err;\n                }\n        } else if (fstatat(sp->fts_cwd_fd, p->fts_accpath, sbp,\n                           AT_SYMLINK_NOFOLLOW)) {\n                p->fts_errno = errno;\nerr:            memset(sbp, 0, sizeof(struct stat));\n                return (FTS_NS);\n        }\n\n        if (S_ISDIR(sbp->st_mode)) {\n                p->fts_n_dirs_remaining = (sbp->st_nlink\n                                           - (ISSET(FTS_SEEDOT) ? 0 : 2));\n                if (ISDOT(p->fts_name)) {\n                        /* Command-line \".\" and \"..\" are real directories. */\n                        return (p->fts_level == FTS_ROOTLEVEL ? FTS_D : FTS_DOT);\n                }\n\n                return (FTS_D);\n        }\n        if (S_ISLNK(sbp->st_mode))\n                return (FTS_SL);\n        if (S_ISREG(sbp->st_mode))\n                return (FTS_F);\n        return (FTS_DEFAULT);\n}",
      "lines": 49,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "unsigned short int",
        "unsigned",
        "short",
        "int",
        "internal_function",
        "internal_function"
      ]
    },
    "fts_compar": {
      "start_point": [
        1842,
        0
      ],
      "end_point": [
        1853,
        1
      ],
      "content": "static int\nfts_compar (void const *a, void const *b)\n{\n  /* Convert A and B to the correct types, to pacify the compiler, and\n     for portability to bizarre hosts where \"void const *\" and \"FTSENT\n     const **\" differ in runtime representation.  The comparison\n     function cannot modify *a and *b, but there is no compile-time\n     check for this.  */\n  FTSENT const **pa = (FTSENT const **) a;\n  FTSENT const **pb = (FTSENT const **) b;\n  return pa[0]->fts_fts->fts_compar (pa, pb);\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "fts_padjust": {
      "start_point": [
        1999,
        0
      ],
      "end_point": [
        2022,
        1
      ],
      "content": "static void\ninternal_function\nfts_padjust (FTS *sp, FTSENT *head)\n{\n        FTSENT *p;\n        char *addr = sp->fts_path;\n\n#define ADJUST(p) do {                                                  \\\n        if ((p)->fts_accpath != (p)->fts_name) {                        \\\n                (p)->fts_accpath =                                      \\\n                    (char *)addr + ((p)->fts_accpath - (p)->fts_path);  \\\n        }                                                               \\\n        (p)->fts_path = addr;                                           \\\n} while (0)\n        /* Adjust the current set of children. */\n        for (p = sp->fts_child; p; p = p->fts_link)\n                ADJUST(p);\n\n        /* Adjust the rest of the tree, including the current level. */\n        for (p = head; p->fts_level >= FTS_ROOTLEVEL;) {\n                ADJUST(p);\n                p = p->fts_link ? p->fts_link : p->fts_parent;\n        }\n}",
      "lines": 24,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void",
        "internal_function",
        "internal_function"
      ]
    },
    "fts_maxarglen": {
      "start_point": [
        2025,
        18
      ],
      "end_point": [
        2034,
        1
      ],
      "content": "_GL_ATTRIBUTE_PURE\nfts_maxarglen (char * const *argv)\n{\n        size_t len, max;\n\n        for (max = 0; *argv; ++argv)\n                if ((len = strlen(*argv)) > max)\n                        max = len;\n        return (max + 1);\n}",
      "lines": 10,
      "depth": 12,
      "decorators": [
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "fts_safe_changedir": {
      "start_point": [
        2045,
        0
      ],
      "end_point": [
        2129,
        1
      ],
      "content": "static int\ninternal_function\nfts_safe_changedir (FTS *sp, FTSENT *p, int fd, char const *dir)\n{\n        int ret;\n        bool is_dotdot = dir && STREQ (dir, \"..\");\n        int newfd;\n\n        /* This clause handles the unusual case in which FTS_NOCHDIR\n           is specified, along with FTS_CWDFD.  In that case, there is\n           no need to change even the virtual cwd file descriptor.\n           However, if FD is non-negative, we do close it here.  */\n        if (ISSET (FTS_NOCHDIR))\n          {\n            if (ISSET (FTS_CWDFD) && 0 <= fd)\n              close (fd);\n            return 0;\n          }\n\n        if (fd < 0 && is_dotdot && ISSET (FTS_CWDFD))\n          {\n            /* When possible, skip the diropen and subsequent fstat+dev/ino\n               comparison.  I.e., when changing to parent directory\n               (chdir (\"..\")), use a file descriptor from the ring and\n               save the overhead of diropen+fstat, as well as avoiding\n               failure when we lack \"x\" access to the virtual cwd.  */\n            if ( ! i_ring_empty (&sp->fts_fd_ring))\n              {\n                int parent_fd;\n                fd_ring_print (sp, stderr, \"pre-pop\");\n                parent_fd = i_ring_pop (&sp->fts_fd_ring);\n                is_dotdot = true;\n                if (0 <= parent_fd)\n                  {\n                    fd = parent_fd;\n                    dir = NULL;\n                  }\n              }\n          }\n\n        newfd = fd;\n        if (fd < 0 && (newfd = diropen (sp, dir)) < 0)\n          return -1;\n\n        /* The following dev/inode check is necessary if we're doing a\n           \"logical\" traversal (through symlinks, a la chown -L), if the\n           system lacks O_NOFOLLOW support, or if we're changing to \"..\"\n           (but not via a popped file descriptor).  When changing to the\n           name \"..\", O_NOFOLLOW can't help.  In general, when the target is\n           not \"..\", diropen's use of O_NOFOLLOW ensures we don't mistakenly\n           follow a symlink, so we can avoid the expense of this fstat.  */\n        if (ISSET(FTS_LOGICAL) || ! HAVE_WORKING_O_NOFOLLOW\n            || (dir && STREQ (dir, \"..\")))\n          {\n            struct stat sb;\n            if (fstat(newfd, &sb))\n              {\n                ret = -1;\n                goto bail;\n              }\n            if (p->fts_statp->st_dev != sb.st_dev\n                || p->fts_statp->st_ino != sb.st_ino)\n              {\n                __set_errno (ENOENT);           /* disinformation */\n                ret = -1;\n                goto bail;\n              }\n          }\n\n        if (ISSET(FTS_CWDFD))\n          {\n            cwd_advance_fd (sp, newfd, ! is_dotdot);\n            return 0;\n          }\n\n        ret = fchdir(newfd);\nbail:\n        if (fd < 0)\n          {\n            int oerrno = errno;\n            (void)close(newfd);\n            __set_errno (oerrno);\n          }\n        return ret;\n}",
      "lines": 85,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int",
        "internal_function",
        "internal_function"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/fts_.h": {},
  "findutils/findutils-4.6.0/gl/lib/getcwd-lgpl.c": {
    "rpl_getcwd": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        123,
        1
      ],
      "content": "char *\nrpl_getcwd (char *buf, size_t size)\n{\n  char *ptr;\n  char *result;\n\n  /* Handle single size operations.  */\n  if (buf)\n    {\n      if (!size)\n        {\n          errno = EINVAL;\n          return NULL;\n        }\n      return getcwd (buf, size);\n    }\n\n  if (size)\n    {\n      buf = malloc (size);\n      if (!buf)\n        {\n          errno = ENOMEM;\n          return NULL;\n        }\n      result = getcwd (buf, size);\n      if (!result)\n        {\n          int saved_errno = errno;\n          free (buf);\n          errno = saved_errno;\n        }\n      return result;\n    }\n\n  /* Flexible sizing requested.  Avoid over-allocation for the common\n     case of a name that fits within a 4k page, minus some space for\n     local variables, to be sure we don't skip over a guard page.  */\n  {\n    char tmp[4032];\n    size = sizeof tmp;\n    ptr = getcwd (tmp, size);\n    if (ptr)\n      {\n        result = strdup (ptr);\n        if (!result)\n          errno = ENOMEM;\n        return result;\n      }\n    if (errno != ERANGE)\n      return NULL;\n  }\n\n  /* My what a large directory name we have.  */\n  do\n    {\n      size <<= 1;\n      ptr = realloc (buf, size);\n      if (ptr == NULL)\n        {\n          free (buf);\n          errno = ENOMEM;\n          return NULL;\n        }\n      buf = ptr;\n      result = getcwd (buf, size);\n    }\n  while (!result && errno == ERANGE);\n\n  if (!result)\n    {\n      int saved_errno = errno;\n      free (buf);\n      errno = saved_errno;\n    }\n  else\n    {\n      /* Trim to fit, if possible.  */\n      result = realloc (buf, strlen (buf) + 1);\n      if (!result)\n        result = buf;\n    }\n  return result;\n}",
      "lines": 84,
      "depth": 12,
      "decorators": [
        "char",
        "*\nrpl_getcwd (char *buf, size_t size)",
        "*"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/getcwd.c": {
    "__getcwd": {
      "start_point": [
        108,
        0
      ],
      "end_point": [
        441,
        1
      ],
      "content": "char *\n__getcwd (char *buf, size_t size)\n{\n  /* Lengths of big file name components and entire file names, and a\n     deep level of file name nesting.  These numbers are not upper\n     bounds; they are merely large values suitable for initial\n     allocations, designed to be large enough for most real-world\n     uses.  */\n  enum\n    {\n      BIG_FILE_NAME_COMPONENT_LENGTH = 255,\n      BIG_FILE_NAME_LENGTH = MIN (4095, PATH_MAX - 1),\n      DEEP_NESTING = 100\n    };\n\n#if HAVE_OPENAT_SUPPORT\n  int fd = AT_FDCWD;\n  bool fd_needs_closing = false;\n#else\n  char dots[DEEP_NESTING * sizeof \"..\" + BIG_FILE_NAME_COMPONENT_LENGTH + 1];\n  char *dotlist = dots;\n  size_t dotsize = sizeof dots;\n  size_t dotlen = 0;\n#endif\n  DIR *dirstream = NULL;\n  dev_t rootdev, thisdev;\n  ino_t rootino, thisino;\n  char *dir;\n  register char *dirp;\n  struct stat st;\n  size_t allocated = size;\n  size_t used;\n\n#if HAVE_MINIMALLY_WORKING_GETCWD\n  /* If AT_FDCWD is not defined, the algorithm below is O(N**2) and\n     this is much slower than the system getcwd (at least on\n     GNU/Linux).  So trust the system getcwd's results unless they\n     look suspicious.\n\n     Use the system getcwd even if we have openat support, since the\n     system getcwd works even when a parent is unreadable, while the\n     openat-based approach does not.\n\n     But on AIX 5.1..7.1, the system getcwd is not even minimally\n     working: If the current directory name is slightly longer than\n     PATH_MAX, it omits the first directory component and returns\n     this wrong result with errno = 0.  */\n\n# undef getcwd\n  dir = getcwd (buf, size);\n  if (dir || (size && errno == ERANGE))\n    return dir;\n\n  /* Solaris getcwd (NULL, 0) fails with errno == EINVAL, but it has\n     internal magic that lets it work even if an ancestor directory is\n     inaccessible, which is better in many cases.  So in this case try\n     again with a buffer that's almost always big enough.  */\n  if (errno == EINVAL && buf == NULL && size == 0)\n    {\n      char big_buffer[BIG_FILE_NAME_LENGTH + 1];\n      dir = getcwd (big_buffer, sizeof big_buffer);\n      if (dir)\n        return strdup (dir);\n    }\n\n# if HAVE_PARTLY_WORKING_GETCWD\n  /* The system getcwd works, except it sometimes fails when it\n     shouldn't, setting errno to ERANGE, ENAMETOOLONG, or ENOENT.    */\n  if (errno != ERANGE && errno != ENAMETOOLONG && errno != ENOENT)\n    return NULL;\n# endif\n#endif\n\n  if (size == 0)\n    {\n      if (buf != NULL)\n        {\n          __set_errno (EINVAL);\n          return NULL;\n        }\n\n      allocated = BIG_FILE_NAME_LENGTH + 1;\n    }\n\n  if (buf == NULL)\n    {\n      dir = malloc (allocated);\n      if (dir == NULL)\n        return NULL;\n    }\n  else\n    dir = buf;\n\n  dirp = dir + allocated;\n  *--dirp = '\\0';\n\n  if (__lstat (\".\", &st) < 0)\n    goto lose;\n  thisdev = st.st_dev;\n  thisino = st.st_ino;\n\n  if (__lstat (\"/\", &st) < 0)\n    goto lose;\n  rootdev = st.st_dev;\n  rootino = st.st_ino;\n\n  while (!(thisdev == rootdev && thisino == rootino))\n    {\n      struct dirent *d;\n      dev_t dotdev;\n      ino_t dotino;\n      bool mount_point;\n      int parent_status;\n      size_t dirroom;\n      size_t namlen;\n      bool use_d_ino = true;\n\n      /* Look at the parent directory.  */\n#if HAVE_OPENAT_SUPPORT\n      fd = openat (fd, \"..\", O_RDONLY);\n      if (fd < 0)\n        goto lose;\n      fd_needs_closing = true;\n      parent_status = fstat (fd, &st);\n#else\n      dotlist[dotlen++] = '.';\n      dotlist[dotlen++] = '.';\n      dotlist[dotlen] = '\\0';\n      parent_status = __lstat (dotlist, &st);\n#endif\n      if (parent_status != 0)\n        goto lose;\n\n      if (dirstream && __closedir (dirstream) != 0)\n        {\n          dirstream = NULL;\n          goto lose;\n        }\n\n      /* Figure out if this directory is a mount point.  */\n      dotdev = st.st_dev;\n      dotino = st.st_ino;\n      mount_point = dotdev != thisdev;\n\n      /* Search for the last directory.  */\n#if HAVE_OPENAT_SUPPORT\n      dirstream = fdopendir (fd);\n      if (dirstream == NULL)\n        goto lose;\n      fd_needs_closing = false;\n#else\n      dirstream = __opendir (dotlist);\n      if (dirstream == NULL)\n        goto lose;\n      dotlist[dotlen++] = '/';\n#endif\n      for (;;)\n        {\n          /* Clear errno to distinguish EOF from error if readdir returns\n             NULL.  */\n          __set_errno (0);\n          d = __readdir (dirstream);\n\n          /* When we've iterated through all directory entries without finding\n             one with a matching d_ino, rewind the stream and consider each\n             name again, but this time, using lstat.  This is necessary in a\n             chroot on at least one system (glibc-2.3.6 + linux 2.6.12), where\n             .., ../.., ../../.., etc. all had the same device number, yet the\n             d_ino values for entries in / did not match those obtained\n             via lstat.  */\n          if (d == NULL && errno == 0 && use_d_ino)\n            {\n              use_d_ino = false;\n              rewinddir (dirstream);\n              d = __readdir (dirstream);\n            }\n\n          if (d == NULL)\n            {\n              if (errno == 0)\n                /* EOF on dirstream, which can mean e.g., that the current\n                   directory has been removed.  */\n                __set_errno (ENOENT);\n              goto lose;\n            }\n          if (d->d_name[0] == '.' &&\n              (d->d_name[1] == '\\0' ||\n               (d->d_name[1] == '.' && d->d_name[2] == '\\0')))\n            continue;\n\n          if (use_d_ino)\n            {\n              bool match = (MATCHING_INO (d, thisino) || mount_point);\n              if (! match)\n                continue;\n            }\n\n          {\n            int entry_status;\n#if HAVE_OPENAT_SUPPORT\n            entry_status = fstatat (fd, d->d_name, &st, AT_SYMLINK_NOFOLLOW);\n#else\n            /* Compute size needed for this file name, or for the file\n               name \"..\" in the same directory, whichever is larger.\n               Room for \"..\" might be needed the next time through\n               the outer loop.  */\n            size_t name_alloc = _D_ALLOC_NAMLEN (d);\n            size_t filesize = dotlen + MAX (sizeof \"..\", name_alloc);\n\n            if (filesize < dotlen)\n              goto memory_exhausted;\n\n            if (dotsize < filesize)\n              {\n                /* My, what a deep directory tree you have, Grandma.  */\n                size_t newsize = MAX (filesize, dotsize * 2);\n                size_t i;\n                if (newsize < dotsize)\n                  goto memory_exhausted;\n                if (dotlist != dots)\n                  free (dotlist);\n                dotlist = malloc (newsize);\n                if (dotlist == NULL)\n                  goto lose;\n                dotsize = newsize;\n\n                i = 0;\n                do\n                  {\n                    dotlist[i++] = '.';\n                    dotlist[i++] = '.';\n                    dotlist[i++] = '/';\n                  }\n                while (i < dotlen);\n              }\n\n            memcpy (dotlist + dotlen, d->d_name, _D_ALLOC_NAMLEN (d));\n            entry_status = __lstat (dotlist, &st);\n#endif\n            /* We don't fail here if we cannot stat() a directory entry.\n               This can happen when (network) file systems fail.  If this\n               entry is in fact the one we are looking for we will find\n               out soon as we reach the end of the directory without\n               having found anything.  */\n            if (entry_status == 0 && S_ISDIR (st.st_mode)\n                && st.st_dev == thisdev && st.st_ino == thisino)\n              break;\n          }\n        }\n\n      dirroom = dirp - dir;\n      namlen = _D_EXACT_NAMLEN (d);\n\n      if (dirroom <= namlen)\n        {\n          if (size != 0)\n            {\n              __set_errno (ERANGE);\n              goto lose;\n            }\n          else\n            {\n              char *tmp;\n              size_t oldsize = allocated;\n\n              allocated += MAX (allocated, namlen);\n              if (allocated < oldsize\n                  || ! (tmp = realloc (dir, allocated)))\n                goto memory_exhausted;\n\n              /* Move current contents up to the end of the buffer.\n                 This is guaranteed to be non-overlapping.  */\n              dirp = memcpy (tmp + allocated - (oldsize - dirroom),\n                             tmp + dirroom,\n                             oldsize - dirroom);\n              dir = tmp;\n            }\n        }\n      dirp -= namlen;\n      memcpy (dirp, d->d_name, namlen);\n      *--dirp = '/';\n\n      thisdev = dotdev;\n      thisino = dotino;\n    }\n\n  if (dirstream && __closedir (dirstream) != 0)\n    {\n      dirstream = NULL;\n      goto lose;\n    }\n\n  if (dirp == &dir[allocated - 1])\n    *--dirp = '/';\n\n#if ! HAVE_OPENAT_SUPPORT\n  if (dotlist != dots)\n    free (dotlist);\n#endif\n\n  used = dir + allocated - dirp;\n  memmove (dir, dirp, used);\n\n  if (size == 0)\n    /* Ensure that the buffer is only as large as necessary.  */\n    buf = realloc (dir, used);\n\n  if (buf == NULL)\n    /* Either buf was NULL all along, or 'realloc' failed but\n       we still have the original string.  */\n    buf = dir;\n\n  return buf;\n\n memory_exhausted:\n  __set_errno (ENOMEM);\n lose:\n  {\n    int save = errno;\n    if (dirstream)\n      __closedir (dirstream);\n#if HAVE_OPENAT_SUPPORT\n    if (fd_needs_closing)\n      close (fd);\n#else\n    if (dotlist != dots)\n      free (dotlist);\n#endif\n    if (buf == NULL)\n      free (dir);\n    __set_errno (save);\n  }\n  return NULL;\n}",
      "lines": 334,
      "depth": 18,
      "decorators": [
        "char",
        "*\n__getcwd (char *buf, size_t size)",
        "*"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/getdelim.c": {
    "getdelim": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        134,
        1
      ],
      "content": "ssize_t\ngetdelim (char **lineptr, size_t *n, int delimiter, FILE *fp)\n{\n  ssize_t result;\n  size_t cur_len = 0;\n\n  if (lineptr == NULL || n == NULL || fp == NULL)\n    {\n      errno = EINVAL;\n      return -1;\n    }\n\n  flockfile (fp);\n\n  if (*lineptr == NULL || *n == 0)\n    {\n      char *new_lineptr;\n      *n = 120;\n      new_lineptr = (char *) realloc (*lineptr, *n);\n      if (new_lineptr == NULL)\n        {\n          result = -1;\n          goto unlock_return;\n        }\n      *lineptr = new_lineptr;\n    }\n\n  for (;;)\n    {\n      int i;\n\n      i = getc_maybe_unlocked (fp);\n      if (i == EOF)\n        {\n          result = -1;\n          break;\n        }\n\n      /* Make enough space for len+1 (for final NUL) bytes.  */\n      if (cur_len + 1 >= *n)\n        {\n          size_t needed_max =\n            SSIZE_MAX < SIZE_MAX ? (size_t) SSIZE_MAX + 1 : SIZE_MAX;\n          size_t needed = 2 * *n + 1;   /* Be generous. */\n          char *new_lineptr;\n\n          if (needed_max < needed)\n            needed = needed_max;\n          if (cur_len + 1 >= needed)\n            {\n              result = -1;\n              errno = EOVERFLOW;\n              goto unlock_return;\n            }\n\n          new_lineptr = (char *) realloc (*lineptr, needed);\n          if (new_lineptr == NULL)\n            {\n              result = -1;\n              goto unlock_return;\n            }\n\n          *lineptr = new_lineptr;\n          *n = needed;\n        }\n\n      (*lineptr)[cur_len] = i;\n      cur_len++;\n\n      if (i == delimiter)\n        break;\n    }\n  (*lineptr)[cur_len] = '\\0';\n  result = cur_len ? cur_len : result;\n\n unlock_return:\n  funlockfile (fp); /* doesn't set errno */\n\n  return result;\n}",
      "lines": 80,
      "depth": 13,
      "decorators": [
        "ssize_t"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/getdtablesize.c": {
    "_setmaxstdio_nothrow": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        37,
        5
      ],
      "content": "static int\n_setmaxstdio_nothrow (int newmax)\n{\n  int result;\n\n  TRY_MSVC_INVAL\n    {\n      result = _setmaxstdio (newmax);\n    }",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "getdtablesize": [
      {
        "start_point": [
          53,
          0
        ],
        "end_point": [
          84,
          1
        ],
        "content": "int\ngetdtablesize (void)\n{\n  if (dtablesize == 0)\n    {\n      /* We are looking for the number N such that the valid file descriptors\n         are 0..N-1.  It can be obtained through a loop as follows:\n           {\n             int fd;\n             for (fd = 3; fd < 65536; fd++)\n               if (dup2 (0, fd) == -1)\n                 break;\n             return fd;\n           }\n         On Windows XP, the result is 2048.\n         The drawback of this loop is that it allocates memory for a libc\n         internal array that is never freed.\n\n         The number N can also be obtained as the upper bound for\n         _getmaxstdio ().  _getmaxstdio () returns the maximum number of open\n         FILE objects.  The sanity check in _setmaxstdio reveals the maximum\n         number of file descriptors.  This too allocates memory, but it is\n         freed when we call _setmaxstdio with the original value.  */\n      int orig_max_stdio = _getmaxstdio ();\n      unsigned int bound;\n      for (bound = 0x10000; _setmaxstdio (bound) < 0; bound = bound / 2)\n        ;\n      _setmaxstdio (orig_max_stdio);\n      dtablesize = bound;\n    }\n  return dtablesize;\n}",
        "lines": 32,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          105,
          0
        ],
        "end_point": [
          118,
          1
        ],
        "content": "int\ngetdtablesize (void)\n{\n  struct rlimit lim;\n\n  if (getrlimit (RLIMIT_NOFILE, &lim) == 0\n      && 0 <= lim.rlim_cur && lim.rlim_cur <= INT_MAX\n      && lim.rlim_cur != RLIM_INFINITY\n      && lim.rlim_cur != RLIM_SAVED_CUR\n      && lim.rlim_cur != RLIM_SAVED_MAX)\n    return lim.rlim_cur;\n\n  return INT_MAX;\n}",
        "lines": 14,
        "depth": 14,
        "decorators": [
          "int"
        ]
      }
    ]
  },
  "findutils/findutils-4.6.0/gl/lib/getfilecon.c": {
    "map_to_failure": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        65,
        1
      ],
      "content": "static int\nmap_to_failure (int ret, security_context_t *con)\n{\n  if (ret == 0)\n    {\n      errno = ENOTSUP;\n      return -1;\n    }\n\n  if (ret == 10 && strcmp (*con, \"unlabeled\") == 0)\n    {\n      freecon (*con);\n      *con = NULL;\n      errno = ENODATA;\n      return -1;\n    }\n\n  return ret;\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_getfilecon": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "int\nrpl_getfilecon (char const *file, security_context_t *con)\n{\n  int ret = getfilecon (file, con);\n  return map_to_failure (ret, con);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "rpl_lgetfilecon": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "int\nrpl_lgetfilecon (char const *file, security_context_t *con)\n{\n  int ret = lgetfilecon (file, con);\n  return map_to_failure (ret, con);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "rpl_fgetfilecon": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "int\nrpl_fgetfilecon (int fd, security_context_t *con)\n{\n  int ret = fgetfilecon (fd, con);\n  return map_to_failure (ret, con);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/getgroups.c": {
    "getgroups": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "int\ngetgroups (int n _GL_UNUSED, GETGROUPS_T *groups _GL_UNUSED)\n{\n  errno = ENOSYS;\n  return -1;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "rpl_getgroups": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        128,
        1
      ],
      "content": "int\nrpl_getgroups (int n, gid_t *group)\n{\n  int n_groups;\n  GETGROUPS_T *gbuf;\n  int saved_errno;\n\n  if (n < 0)\n    {\n      errno = EINVAL;\n      return -1;\n    }\n\n  if (n != 0 || !GETGROUPS_ZERO_BUG)\n    {\n      int result;\n      if (sizeof *group == sizeof *gbuf)\n        return getgroups (n, (GETGROUPS_T *) group);\n\n      if (SIZE_MAX / sizeof *gbuf <= n)\n        {\n          errno = ENOMEM;\n          return -1;\n        }\n      gbuf = malloc (n * sizeof *gbuf);\n      if (!gbuf)\n        return -1;\n      result = getgroups (n, gbuf);\n      if (0 <= result)\n        {\n          n = result;\n          while (n--)\n            group[n] = gbuf[n];\n        }\n      saved_errno = errno;\n      free (gbuf);\n      errno = saved_errno;\n      return result;\n    }\n\n  n = 20;\n  while (1)\n    {\n      /* No need to worry about address arithmetic overflow here,\n         since the ancient systems that we're running on have low\n         limits on the number of secondary groups.  */\n      gbuf = malloc (n * sizeof *gbuf);\n      if (!gbuf)\n        return -1;\n      n_groups = getgroups (n, gbuf);\n      if (n_groups == -1 ? errno != EINVAL : n_groups < n)\n        break;\n      free (gbuf);\n      n *= 2;\n    }\n\n  saved_errno = errno;\n  free (gbuf);\n  errno = saved_errno;\n\n  return n_groups;\n}",
      "lines": 62,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/gethostname.c": {
    "gethostname": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "int\ngethostname (char *name, size_t len)\n{\n#ifdef HAVE_UNAME\n  struct utsname uts;\n\n  if (uname (&uts) == -1)\n    return -1;\n  if (len > sizeof (uts.nodename))\n    {\n      /* More space than we need is available.  */\n      name[sizeof (uts.nodename)] = '\\0';\n      len = sizeof (uts.nodename);\n    }\n  strncpy (name, uts.nodename, len);\n#else\n  strcpy (name, \"\");            /* Hardcode your system name if you want.  */\n#endif\n  return 0;\n}",
      "lines": 20,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "rpl_gethostname": {
      "start_point": [
        88,
        0
      ],
      "end_point": [
        101,
        1
      ],
      "content": "int\nrpl_gethostname (char *name, size_t len)\n{\n  int r;\n\n  if (len > INT_MAX)\n    len = INT_MAX;\n  gl_sockets_startup (SOCKETS_1_1);\n  r = gethostname (name, (int) len);\n  if (r < 0)\n    set_winsock_errno ();\n\n  return r;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/getline.c": {
    "getline": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        26,
        1
      ],
      "content": "ssize_t\ngetline (char **lineptr, size_t *n, FILE *stream)\n{\n  return getdelim (lineptr, n, '\\n', stream);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "ssize_t"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/getopt.c": {
    "exchange": {
      "start_point": [
        142,
        0
      ],
      "end_point": [
        219,
        1
      ],
      "content": "static void\nexchange (char **argv, struct _getopt_data *d)\n{\n  int bottom = d->__first_nonopt;\n  int middle = d->__last_nonopt;\n  int top = d->optind;\n  char *tem;\n\n  /* Exchange the shorter segment with the far end of the longer segment.\n     That puts the shorter segment into the right place.\n     It leaves the longer segment in the right place overall,\n     but it consists of two parts that need to be swapped next.  */\n\n#if defined _LIBC && defined USE_NONOPTION_FLAGS\n  /* First make sure the handling of the '__getopt_nonoption_flags'\n     string can work normally.  Our top argument must be in the range\n     of the string.  */\n  if (d->__nonoption_flags_len > 0 && top >= d->__nonoption_flags_max_len)\n    {\n      /* We must extend the array.  The user plays games with us and\n         presents new arguments.  */\n      char *new_str = malloc (top + 1);\n      if (new_str == NULL)\n        d->__nonoption_flags_len = d->__nonoption_flags_max_len = 0;\n      else\n        {\n          memset (__mempcpy (new_str, __getopt_nonoption_flags,\n                             d->__nonoption_flags_max_len),\n                  '\\0', top + 1 - d->__nonoption_flags_max_len);\n          d->__nonoption_flags_max_len = top + 1;\n          __getopt_nonoption_flags = new_str;\n        }\n    }\n#endif\n\n  while (top > middle && middle > bottom)\n    {\n      if (top - middle > middle - bottom)\n        {\n          /* Bottom segment is the short one.  */\n          int len = middle - bottom;\n          register int i;\n\n          /* Swap it with the top part of the top segment.  */\n          for (i = 0; i < len; i++)\n            {\n              tem = argv[bottom + i];\n              argv[bottom + i] = argv[top - (middle - bottom) + i];\n              argv[top - (middle - bottom) + i] = tem;\n              SWAP_FLAGS (bottom + i, top - (middle - bottom) + i);\n            }\n          /* Exclude the moved bottom segment from further swapping.  */\n          top -= len;\n        }\n      else\n        {\n          /* Top segment is the short one.  */\n          int len = top - middle;\n          register int i;\n\n          /* Swap it with the bottom part of the bottom segment.  */\n          for (i = 0; i < len; i++)\n            {\n              tem = argv[bottom + i];\n              argv[bottom + i] = argv[middle + i];\n              argv[middle + i] = tem;\n              SWAP_FLAGS (bottom + i, middle + i);\n            }\n          /* Exclude the moved top segment from further swapping.  */\n          bottom += len;\n        }\n    }\n\n  /* Update records for the slots the non-options now occupy.  */\n\n  d->__first_nonopt += (d->optind - d->__last_nonopt);\n  d->__last_nonopt = d->optind;\n}",
      "lines": 78,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "_getopt_initialize": {
      "start_point": [
        223,
        0
      ],
      "end_point": [
        286,
        1
      ],
      "content": "static const char *\n_getopt_initialize (int argc _GL_UNUSED,\n                    char **argv _GL_UNUSED, const char *optstring,\n                    struct _getopt_data *d, int posixly_correct)\n{\n  /* Start processing options with ARGV-element 1 (since ARGV-element 0\n     is the program name); the sequence of previously skipped\n     non-option ARGV-elements is empty.  */\n\n  d->__first_nonopt = d->__last_nonopt = d->optind;\n\n  d->__nextchar = NULL;\n\n  d->__posixly_correct = posixly_correct || !!getenv (\"POSIXLY_CORRECT\");\n\n  /* Determine how to handle the ordering of options and nonoptions.  */\n\n  if (optstring[0] == '-')\n    {\n      d->__ordering = RETURN_IN_ORDER;\n      ++optstring;\n    }\n  else if (optstring[0] == '+')\n    {\n      d->__ordering = REQUIRE_ORDER;\n      ++optstring;\n    }\n  else if (d->__posixly_correct)\n    d->__ordering = REQUIRE_ORDER;\n  else\n    d->__ordering = PERMUTE;\n\n#if defined _LIBC && defined USE_NONOPTION_FLAGS\n  if (!d->__posixly_correct\n      && argc == __libc_argc && argv == __libc_argv)\n    {\n      if (d->__nonoption_flags_max_len == 0)\n        {\n          if (__getopt_nonoption_flags == NULL\n              || __getopt_nonoption_flags[0] == '\\0')\n            d->__nonoption_flags_max_len = -1;\n          else\n            {\n              const char *orig_str = __getopt_nonoption_flags;\n              int len = d->__nonoption_flags_max_len = strlen (orig_str);\n              if (d->__nonoption_flags_max_len < argc)\n                d->__nonoption_flags_max_len = argc;\n              __getopt_nonoption_flags =\n                (char *) malloc (d->__nonoption_flags_max_len);\n              if (__getopt_nonoption_flags == NULL)\n                d->__nonoption_flags_max_len = -1;\n              else\n                memset (__mempcpy (__getopt_nonoption_flags, orig_str, len),\n                        '\\0', d->__nonoption_flags_max_len - len);\n            }\n        }\n      d->__nonoption_flags_len = d->__nonoption_flags_max_len;\n    }\n  else\n    d->__nonoption_flags_len = 0;\n#endif\n\n  return optstring;\n}",
      "lines": 64,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\n_getopt_initialize (int argc _GL_UNUSED,\n                    char **argv _GL_UNUSED, const char *optstring,\n                    struct _getopt_data *d, int posixly_correct)",
        "*"
      ]
    },
    "_getopt_internal_r": {
      "start_point": [
        344,
        0
      ],
      "end_point": [
        1154,
        1
      ],
      "content": "int\n_getopt_internal_r (int argc, char **argv, const char *optstring,\n                    const struct option *longopts, int *longind,\n                    int long_only, struct _getopt_data *d, int posixly_correct)\n{\n  int print_errors = d->opterr;\n\n  if (argc < 1)\n    return -1;\n\n  d->optarg = NULL;\n\n  if (d->optind == 0 || !d->__initialized)\n    {\n      if (d->optind == 0)\n        d->optind = 1;  /* Don't scan ARGV[0], the program name.  */\n      optstring = _getopt_initialize (argc, argv, optstring, d,\n                                      posixly_correct);\n      d->__initialized = 1;\n    }\n  else if (optstring[0] == '-' || optstring[0] == '+')\n    optstring++;\n  if (optstring[0] == ':')\n    print_errors = 0;\n\n  /* Test whether ARGV[optind] points to a non-option argument.\n     Either it does not have option syntax, or there is an environment flag\n     from the shell indicating it is not an option.  The later information\n     is only used when the used in the GNU libc.  */\n#if defined _LIBC && defined USE_NONOPTION_FLAGS\n# define NONOPTION_P (argv[d->optind][0] != '-' || argv[d->optind][1] == '\\0' \\\n                      || (d->optind < d->__nonoption_flags_len                \\\n                          && __getopt_nonoption_flags[d->optind] == '1'))\n#else\n# define NONOPTION_P (argv[d->optind][0] != '-' || argv[d->optind][1] == '\\0')\n#endif\n\n  if (d->__nextchar == NULL || *d->__nextchar == '\\0')\n    {\n      /* Advance to the next ARGV-element.  */\n\n      /* Give FIRST_NONOPT & LAST_NONOPT rational values if OPTIND has been\n         moved back by the user (who may also have changed the arguments).  */\n      if (d->__last_nonopt > d->optind)\n        d->__last_nonopt = d->optind;\n      if (d->__first_nonopt > d->optind)\n        d->__first_nonopt = d->optind;\n\n      if (d->__ordering == PERMUTE)\n        {\n          /* If we have just processed some options following some non-options,\n             exchange them so that the options come first.  */\n\n          if (d->__first_nonopt != d->__last_nonopt\n              && d->__last_nonopt != d->optind)\n            exchange ((char **) argv, d);\n          else if (d->__last_nonopt != d->optind)\n            d->__first_nonopt = d->optind;\n\n          /* Skip any additional non-options\n             and extend the range of non-options previously skipped.  */\n\n          while (d->optind < argc && NONOPTION_P)\n            d->optind++;\n          d->__last_nonopt = d->optind;\n        }\n\n      /* The special ARGV-element '--' means premature end of options.\n         Skip it like a null option,\n         then exchange with previous non-options as if it were an option,\n         then skip everything else like a non-option.  */\n\n      if (d->optind != argc && !strcmp (argv[d->optind], \"--\"))\n        {\n          d->optind++;\n\n          if (d->__first_nonopt != d->__last_nonopt\n              && d->__last_nonopt != d->optind)\n            exchange ((char **) argv, d);\n          else if (d->__first_nonopt == d->__last_nonopt)\n            d->__first_nonopt = d->optind;\n          d->__last_nonopt = argc;\n\n          d->optind = argc;\n        }\n\n      /* If we have done all the ARGV-elements, stop the scan\n         and back over any non-options that we skipped and permuted.  */\n\n      if (d->optind == argc)\n        {\n          /* Set the next-arg-index to point at the non-options\n             that we previously skipped, so the caller will digest them.  */\n          if (d->__first_nonopt != d->__last_nonopt)\n            d->optind = d->__first_nonopt;\n          return -1;\n        }\n\n      /* If we have come to a non-option and did not permute it,\n         either stop the scan or describe it to the caller and pass it by.  */\n\n      if (NONOPTION_P)\n        {\n          if (d->__ordering == REQUIRE_ORDER)\n            return -1;\n          d->optarg = argv[d->optind++];\n          return 1;\n        }\n\n      /* We have found another option-ARGV-element.\n         Skip the initial punctuation.  */\n\n      d->__nextchar = (argv[d->optind] + 1\n                  + (longopts != NULL && argv[d->optind][1] == '-'));\n    }\n\n  /* Decode the current option-ARGV-element.  */\n\n  /* Check whether the ARGV-element is a long option.\n\n     If long_only and the ARGV-element has the form \"-f\", where f is\n     a valid short option, don't consider it an abbreviated form of\n     a long option that starts with f.  Otherwise there would be no\n     way to give the -f short option.\n\n     On the other hand, if there's a long option \"fubar\" and\n     the ARGV-element is \"-fu\", do consider that an abbreviation of\n     the long option, just like \"--fu\", and not \"-f\" with arg \"u\".\n\n     This distinction seems to be the most useful approach.  */\n\n  if (longopts != NULL\n      && (argv[d->optind][1] == '-'\n          || (long_only && (argv[d->optind][2]\n                            || !strchr (optstring, argv[d->optind][1])))))\n    {\n      char *nameend;\n      unsigned int namelen;\n      const struct option *p;\n      const struct option *pfound = NULL;\n      struct option_list\n      {\n        const struct option *p;\n        struct option_list *next;\n      } *ambig_list = NULL;\n#ifdef _LIBC\n/* malloc() not used for _LIBC to simplify failure messages.  */\n# define free_option_list(l)\n#else\n# define free_option_list(l)\t\t\t\\\n      while (l != NULL)\t\t\t\t\\\n        {\t\t\t\t\t\\\n          struct option_list *pn = l->next;\t\\\n          free (l);\t\t\t\t\\\n          l = pn;\t\t\t\t\\\n        }\n#endif\n      int exact = 0;\n      int ambig = 0;\n      int indfound = -1;\n      int option_index;\n\n      for (nameend = d->__nextchar; *nameend && *nameend != '='; nameend++)\n        /* Do nothing.  */ ;\n      namelen = nameend - d->__nextchar;\n\n      /* Test all long options for either exact match\n         or abbreviated matches.  */\n      for (p = longopts, option_index = 0; p->name; p++, option_index++)\n        if (!strncmp (p->name, d->__nextchar, namelen))\n          {\n            if (namelen == (unsigned int) strlen (p->name))\n              {\n                /* Exact match found.  */\n                pfound = p;\n                indfound = option_index;\n                exact = 1;\n                break;\n              }\n            else if (pfound == NULL)\n              {\n                /* First nonexact match found.  */\n                pfound = p;\n                indfound = option_index;\n              }\n            else if (ambig)\n              ; /* Taking simpler path to handling ambiguities.  */\n            else if (long_only\n                     || pfound->has_arg != p->has_arg\n                     || pfound->flag != p->flag\n                     || pfound->val != p->val)\n              {\n                /* Second or later nonexact match found.  */\n#ifdef _LIBC\n                struct option_list *newp = alloca (sizeof (*newp));\n#else\n                struct option_list *newp = malloc (sizeof (*newp));\n                if (newp == NULL)\n                  {\n                    free_option_list (ambig_list);\n                    ambig_list = NULL;\n                    ambig = 1; /* Use simpler fallback message.  */\n                  }\n                else\n#endif\n                  {\n                    newp->p = p;\n                    newp->next = ambig_list;\n                    ambig_list = newp;\n                  }\n              }\n          }\n\n      if ((ambig || ambig_list) && !exact)\n        {\n          if (print_errors && ambig_list)\n            {\n              struct option_list first;\n              first.p = pfound;\n              first.next = ambig_list;\n              ambig_list = &first;\n\n#if defined _LIBC && defined USE_IN_LIBIO\n              char *buf = NULL;\n              size_t buflen = 0;\n\n              FILE *fp = open_memstream (&buf, &buflen);\n              if (fp != NULL)\n                {\n                  fprintf (fp,\n                           _(\"%s: option '%s' is ambiguous; possibilities:\"),\n                           argv[0], argv[d->optind]);\n\n                  do\n                    {\n                      fprintf (fp, \" '--%s'\", ambig_list->p->name);\n                      ambig_list = ambig_list->next;\n                    }\n                  while (ambig_list != NULL);\n\n                  fputc_unlocked ('\\n', fp);\n\n                  if (__builtin_expect (fclose (fp) != EOF, 1))\n                    {\n                      _IO_flockfile (stderr);\n\n                      int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                      ((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;\n\n                      __fxprintf (NULL, \"%s\", buf);\n\n                      ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                      _IO_funlockfile (stderr);\n\n                      free (buf);\n                    }\n                }\n#else\n              fprintf (stderr,\n                       _(\"%s: option '%s' is ambiguous; possibilities:\"),\n                       argv[0], argv[d->optind]);\n              do\n                {\n                  fprintf (stderr, \" '--%s'\", ambig_list->p->name);\n                  ambig_list = ambig_list->next;\n                }\n              while (ambig_list != NULL);\n\n              fputc ('\\n', stderr);\n#endif\n            }\n          else if (print_errors && ambig)\n            {\n              fprintf (stderr,\n                       _(\"%s: option '%s' is ambiguous\\n\"),\n                       argv[0], argv[d->optind]);\n            }\n          d->__nextchar += strlen (d->__nextchar);\n          d->optind++;\n          d->optopt = 0;\n          free_option_list (ambig_list);\n          return '?';\n        }\n\n      free_option_list (ambig_list);\n\n      if (pfound != NULL)\n        {\n          option_index = indfound;\n          d->optind++;\n          if (*nameend)\n            {\n              /* Don't test has_arg with >, because some C compilers don't\n                 allow it to be used on enums.  */\n              if (pfound->has_arg)\n                d->optarg = nameend + 1;\n              else\n                {\n                  if (print_errors)\n                    {\n#if defined _LIBC && defined USE_IN_LIBIO\n                      char *buf;\n                      int n;\n#endif\n\n                      if (argv[d->optind - 1][1] == '-')\n                        {\n                          /* --option */\n#if defined _LIBC && defined USE_IN_LIBIO\n                          n = __asprintf (&buf, _(\"\\\n%s: option '--%s' doesn't allow an argument\\n\"),\n                                          argv[0], pfound->name);\n#else\n                          fprintf (stderr, _(\"\\\n%s: option '--%s' doesn't allow an argument\\n\"),\n                                   argv[0], pfound->name);\n#endif\n                        }\n                      else\n                        {\n                          /* +option or -option */\n#if defined _LIBC && defined USE_IN_LIBIO\n                          n = __asprintf (&buf, _(\"\\\n%s: option '%c%s' doesn't allow an argument\\n\"),\n                                          argv[0], argv[d->optind - 1][0],\n                                          pfound->name);\n#else\n                          fprintf (stderr, _(\"\\\n%s: option '%c%s' doesn't allow an argument\\n\"),\n                                   argv[0], argv[d->optind - 1][0],\n                                   pfound->name);\n#endif\n                        }\n\n#if defined _LIBC && defined USE_IN_LIBIO\n                      if (n >= 0)\n                        {\n                          _IO_flockfile (stderr);\n\n                          int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                          ((_IO_FILE *) stderr)->_flags2\n                            |= _IO_FLAGS2_NOTCANCEL;\n\n                          __fxprintf (NULL, \"%s\", buf);\n\n                          ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                          _IO_funlockfile (stderr);\n\n                          free (buf);\n                        }\n#endif\n                    }\n\n                  d->__nextchar += strlen (d->__nextchar);\n\n                  d->optopt = pfound->val;\n                  return '?';\n                }\n            }\n          else if (pfound->has_arg == 1)\n            {\n              if (d->optind < argc)\n                d->optarg = argv[d->optind++];\n              else\n                {\n                  if (print_errors)\n                    {\n#if defined _LIBC && defined USE_IN_LIBIO\n                      char *buf;\n\n                      if (__asprintf (&buf, _(\"\\\n%s: option '--%s' requires an argument\\n\"),\n                                      argv[0], pfound->name) >= 0)\n                        {\n                          _IO_flockfile (stderr);\n\n                          int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                          ((_IO_FILE *) stderr)->_flags2\n                            |= _IO_FLAGS2_NOTCANCEL;\n\n                          __fxprintf (NULL, \"%s\", buf);\n\n                          ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                          _IO_funlockfile (stderr);\n\n                          free (buf);\n                        }\n#else\n                      fprintf (stderr,\n                               _(\"%s: option '--%s' requires an argument\\n\"),\n                               argv[0], pfound->name);\n#endif\n                    }\n                  d->__nextchar += strlen (d->__nextchar);\n                  d->optopt = pfound->val;\n                  return optstring[0] == ':' ? ':' : '?';\n                }\n            }\n          d->__nextchar += strlen (d->__nextchar);\n          if (longind != NULL)\n            *longind = option_index;\n          if (pfound->flag)\n            {\n              *(pfound->flag) = pfound->val;\n              return 0;\n            }\n          return pfound->val;\n        }\n\n      /* Can't find it as a long option.  If this is not getopt_long_only,\n         or the option starts with '--' or is not a valid short\n         option, then it's an error.\n         Otherwise interpret it as a short option.  */\n      if (!long_only || argv[d->optind][1] == '-'\n          || strchr (optstring, *d->__nextchar) == NULL)\n        {\n          if (print_errors)\n            {\n#if defined _LIBC && defined USE_IN_LIBIO\n              char *buf;\n              int n;\n#endif\n\n              if (argv[d->optind][1] == '-')\n                {\n                  /* --option */\n#if defined _LIBC && defined USE_IN_LIBIO\n                  n = __asprintf (&buf, _(\"%s: unrecognized option '--%s'\\n\"),\n                                  argv[0], d->__nextchar);\n#else\n                  fprintf (stderr, _(\"%s: unrecognized option '--%s'\\n\"),\n                           argv[0], d->__nextchar);\n#endif\n                }\n              else\n                {\n                  /* +option or -option */\n#if defined _LIBC && defined USE_IN_LIBIO\n                  n = __asprintf (&buf, _(\"%s: unrecognized option '%c%s'\\n\"),\n                                  argv[0], argv[d->optind][0], d->__nextchar);\n#else\n                  fprintf (stderr, _(\"%s: unrecognized option '%c%s'\\n\"),\n                           argv[0], argv[d->optind][0], d->__nextchar);\n#endif\n                }\n\n#if defined _LIBC && defined USE_IN_LIBIO\n              if (n >= 0)\n                {\n                  _IO_flockfile (stderr);\n\n                  int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                  ((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;\n\n                  __fxprintf (NULL, \"%s\", buf);\n\n                  ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                  _IO_funlockfile (stderr);\n\n                  free (buf);\n                }\n#endif\n            }\n          d->__nextchar = (char *) \"\";\n          d->optind++;\n          d->optopt = 0;\n          return '?';\n        }\n    }\n\n  /* Look at and handle the next short option-character.  */\n\n  {\n    char c = *d->__nextchar++;\n    const char *temp = strchr (optstring, c);\n\n    /* Increment 'optind' when we start to process its last character.  */\n    if (*d->__nextchar == '\\0')\n      ++d->optind;\n\n    if (temp == NULL || c == ':' || c == ';')\n      {\n        if (print_errors)\n          {\n#if defined _LIBC && defined USE_IN_LIBIO\n              char *buf;\n              int n;\n#endif\n\n#if defined _LIBC && defined USE_IN_LIBIO\n              n = __asprintf (&buf, _(\"%s: invalid option -- '%c'\\n\"),\n                              argv[0], c);\n#else\n              fprintf (stderr, _(\"%s: invalid option -- '%c'\\n\"), argv[0], c);\n#endif\n\n#if defined _LIBC && defined USE_IN_LIBIO\n            if (n >= 0)\n              {\n                _IO_flockfile (stderr);\n\n                int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                ((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;\n\n                __fxprintf (NULL, \"%s\", buf);\n\n                ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                _IO_funlockfile (stderr);\n\n                free (buf);\n              }\n#endif\n          }\n        d->optopt = c;\n        return '?';\n      }\n    /* Convenience. Treat POSIX -W foo same as long option --foo */\n    if (temp[0] == 'W' && temp[1] == ';')\n      {\n        char *nameend;\n        const struct option *p;\n        const struct option *pfound = NULL;\n        int exact = 0;\n        int ambig = 0;\n        int indfound = 0;\n        int option_index;\n\n        if (longopts == NULL)\n          goto no_longs;\n\n        /* This is an option that requires an argument.  */\n        if (*d->__nextchar != '\\0')\n          {\n            d->optarg = d->__nextchar;\n            /* If we end this ARGV-element by taking the rest as an arg,\n               we must advance to the next element now.  */\n            d->optind++;\n          }\n        else if (d->optind == argc)\n          {\n            if (print_errors)\n              {\n#if defined _LIBC && defined USE_IN_LIBIO\n                char *buf;\n\n                if (__asprintf (&buf,\n                                _(\"%s: option requires an argument -- '%c'\\n\"),\n                                argv[0], c) >= 0)\n                  {\n                    _IO_flockfile (stderr);\n\n                    int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                    ((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;\n\n                    __fxprintf (NULL, \"%s\", buf);\n\n                    ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                    _IO_funlockfile (stderr);\n\n                    free (buf);\n                  }\n#else\n                fprintf (stderr,\n                         _(\"%s: option requires an argument -- '%c'\\n\"),\n                         argv[0], c);\n#endif\n              }\n            d->optopt = c;\n            if (optstring[0] == ':')\n              c = ':';\n            else\n              c = '?';\n            return c;\n          }\n        else\n          /* We already incremented 'd->optind' once;\n             increment it again when taking next ARGV-elt as argument.  */\n          d->optarg = argv[d->optind++];\n\n        /* optarg is now the argument, see if it's in the\n           table of longopts.  */\n\n        for (d->__nextchar = nameend = d->optarg; *nameend && *nameend != '=';\n             nameend++)\n          /* Do nothing.  */ ;\n\n        /* Test all long options for either exact match\n           or abbreviated matches.  */\n        for (p = longopts, option_index = 0; p->name; p++, option_index++)\n          if (!strncmp (p->name, d->__nextchar, nameend - d->__nextchar))\n            {\n              if ((unsigned int) (nameend - d->__nextchar) == strlen (p->name))\n                {\n                  /* Exact match found.  */\n                  pfound = p;\n                  indfound = option_index;\n                  exact = 1;\n                  break;\n                }\n              else if (pfound == NULL)\n                {\n                  /* First nonexact match found.  */\n                  pfound = p;\n                  indfound = option_index;\n                }\n              else if (long_only\n                       || pfound->has_arg != p->has_arg\n                       || pfound->flag != p->flag\n                       || pfound->val != p->val)\n                /* Second or later nonexact match found.  */\n                ambig = 1;\n            }\n        if (ambig && !exact)\n          {\n            if (print_errors)\n              {\n#if defined _LIBC && defined USE_IN_LIBIO\n                char *buf;\n\n                if (__asprintf (&buf, _(\"%s: option '-W %s' is ambiguous\\n\"),\n                                argv[0], d->optarg) >= 0)\n                  {\n                    _IO_flockfile (stderr);\n\n                    int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                    ((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;\n\n                    __fxprintf (NULL, \"%s\", buf);\n\n                    ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                    _IO_funlockfile (stderr);\n\n                    free (buf);\n                  }\n#else\n                fprintf (stderr, _(\"%s: option '-W %s' is ambiguous\\n\"),\n                         argv[0], d->optarg);\n#endif\n              }\n            d->__nextchar += strlen (d->__nextchar);\n            d->optind++;\n            return '?';\n          }\n        if (pfound != NULL)\n          {\n            option_index = indfound;\n            if (*nameend)\n              {\n                /* Don't test has_arg with >, because some C compilers don't\n                   allow it to be used on enums.  */\n                if (pfound->has_arg)\n                  d->optarg = nameend + 1;\n                else\n                  {\n                    if (print_errors)\n                      {\n#if defined _LIBC && defined USE_IN_LIBIO\n                        char *buf;\n\n                        if (__asprintf (&buf, _(\"\\\n%s: option '-W %s' doesn't allow an argument\\n\"),\n                                        argv[0], pfound->name) >= 0)\n                          {\n                            _IO_flockfile (stderr);\n\n                            int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                            ((_IO_FILE *) stderr)->_flags2\n                              |= _IO_FLAGS2_NOTCANCEL;\n\n                            __fxprintf (NULL, \"%s\", buf);\n\n                            ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                            _IO_funlockfile (stderr);\n\n                            free (buf);\n                          }\n#else\n                        fprintf (stderr, _(\"\\\n%s: option '-W %s' doesn't allow an argument\\n\"),\n                                 argv[0], pfound->name);\n#endif\n                      }\n\n                    d->__nextchar += strlen (d->__nextchar);\n                    return '?';\n                  }\n              }\n            else if (pfound->has_arg == 1)\n              {\n                if (d->optind < argc)\n                  d->optarg = argv[d->optind++];\n                else\n                  {\n                    if (print_errors)\n                      {\n#if defined _LIBC && defined USE_IN_LIBIO\n                        char *buf;\n\n                        if (__asprintf (&buf, _(\"\\\n%s: option '-W %s' requires an argument\\n\"),\n                                        argv[0], pfound->name) >= 0)\n                          {\n                            _IO_flockfile (stderr);\n\n                            int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                            ((_IO_FILE *) stderr)->_flags2\n                              |= _IO_FLAGS2_NOTCANCEL;\n\n                            __fxprintf (NULL, \"%s\", buf);\n\n                            ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                            _IO_funlockfile (stderr);\n\n                            free (buf);\n                          }\n#else\n                        fprintf (stderr, _(\"\\\n%s: option '-W %s' requires an argument\\n\"),\n                                 argv[0], pfound->name);\n#endif\n                      }\n                    d->__nextchar += strlen (d->__nextchar);\n                    return optstring[0] == ':' ? ':' : '?';\n                  }\n              }\n            else\n              d->optarg = NULL;\n            d->__nextchar += strlen (d->__nextchar);\n            if (longind != NULL)\n              *longind = option_index;\n            if (pfound->flag)\n              {\n                *(pfound->flag) = pfound->val;\n                return 0;\n              }\n            return pfound->val;\n          }\n\n      no_longs:\n        d->__nextchar = NULL;\n        return 'W';   /* Let the application handle it.   */\n      }\n    if (temp[1] == ':')\n      {\n        if (temp[2] == ':')\n          {\n            /* This is an option that accepts an argument optionally.  */\n            if (*d->__nextchar != '\\0')\n              {\n                d->optarg = d->__nextchar;\n                d->optind++;\n              }\n            else\n              d->optarg = NULL;\n            d->__nextchar = NULL;\n          }\n        else\n          {\n            /* This is an option that requires an argument.  */\n            if (*d->__nextchar != '\\0')\n              {\n                d->optarg = d->__nextchar;\n                /* If we end this ARGV-element by taking the rest as an arg,\n                   we must advance to the next element now.  */\n                d->optind++;\n              }\n            else if (d->optind == argc)\n              {\n                if (print_errors)\n                  {\n#if defined _LIBC && defined USE_IN_LIBIO\n                    char *buf;\n\n                    if (__asprintf (&buf, _(\"\\\n%s: option requires an argument -- '%c'\\n\"),\n                                    argv[0], c) >= 0)\n                      {\n                        _IO_flockfile (stderr);\n\n                        int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                        ((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;\n\n                        __fxprintf (NULL, \"%s\", buf);\n\n                        ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                        _IO_funlockfile (stderr);\n\n                        free (buf);\n                      }\n#else\n                    fprintf (stderr,\n                             _(\"%s: option requires an argument -- '%c'\\n\"),\n                             argv[0], c);\n#endif\n                  }\n                d->optopt = c;\n                if (optstring[0] == ':')\n                  c = ':';\n                else\n                  c = '?';\n              }\n            else\n              /* We already incremented 'optind' once;\n                 increment it again when taking next ARGV-elt as argument.  */\n              d->optarg = argv[d->optind++];\n            d->__nextchar = NULL;\n          }\n      }\n    return c;\n  }\n}",
      "lines": 811,
      "depth": 25,
      "decorators": [
        "int"
      ]
    },
    "_getopt_internal": {
      "start_point": [
        1156,
        0
      ],
      "end_point": [
        1175,
        1
      ],
      "content": "int\n_getopt_internal (int argc, char **argv, const char *optstring,\n                  const struct option *longopts, int *longind, int long_only,\n                  int posixly_correct)\n{\n  int result;\n\n  getopt_data.optind = optind;\n  getopt_data.opterr = opterr;\n\n  result = _getopt_internal_r (argc, argv, optstring, longopts,\n                               longind, long_only, &getopt_data,\n                               posixly_correct);\n\n  optind = getopt_data.optind;\n  optarg = getopt_data.optarg;\n  optopt = getopt_data.optopt;\n\n  return result;\n}",
      "lines": 20,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "getopt": {
      "start_point": [
        1185,
        0
      ],
      "end_point": [
        1192,
        1
      ],
      "content": "int\ngetopt (int argc, char *const *argv, const char *optstring)\n{\n  return _getopt_internal (argc, (char **) argv, optstring,\n                           (const struct option *) 0,\n                           (int *) 0,\n                           0, POSIXLY_CORRECT);\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "__posix_getopt": {
      "start_point": [
        1195,
        0
      ],
      "end_point": [
        1202,
        1
      ],
      "content": "int\n__posix_getopt (int argc, char *const *argv, const char *optstring)\n{\n  return _getopt_internal (argc, argv, optstring,\n                           (const struct option *) 0,\n                           (int *) 0,\n                           0, 1);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "main": {
      "start_point": [
        1211,
        0
      ],
      "end_point": [
        1272,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  int c;\n  int digit_optind = 0;\n\n  while (1)\n    {\n      int this_option_optind = optind ? optind : 1;\n\n      c = getopt (argc, argv, \"abc:d:0123456789\");\n      if (c == -1)\n        break;\n\n      switch (c)\n        {\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n          if (digit_optind != 0 && digit_optind != this_option_optind)\n            printf (\"digits occur in two different argv-elements.\\n\");\n          digit_optind = this_option_optind;\n          printf (\"option %c\\n\", c);\n          break;\n\n        case 'a':\n          printf (\"option a\\n\");\n          break;\n\n        case 'b':\n          printf (\"option b\\n\");\n          break;\n\n        case 'c':\n          printf (\"option c with value '%s'\\n\", optarg);\n          break;\n\n        case '?':\n          break;\n\n        default:\n          printf (\"?? getopt returned character code 0%o ??\\n\", c);\n        }\n    }\n\n  if (optind < argc)\n    {\n      printf (\"non-option ARGV-elements: \");\n      while (optind < argc)\n        printf (\"%s \", argv[optind++]);\n      printf (\"\\n\");\n    }\n\n  exit (0);\n}",
      "lines": 62,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/getopt.in.h": {},
  "findutils/findutils-4.6.0/gl/lib/getopt1.c": {
    "getopt_long": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "int\ngetopt_long (int argc, char *__getopt_argv_const *argv, const char *options,\n             const struct option *long_options, int *opt_index)\n{\n  return _getopt_internal (argc, (char **) argv, options, long_options,\n                           opt_index, 0, 0);\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "_getopt_long_r": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "int\n_getopt_long_r (int argc, char **argv, const char *options,\n                const struct option *long_options, int *opt_index,\n                struct _getopt_data *d)\n{\n  return _getopt_internal_r (argc, argv, options, long_options, opt_index,\n                             0, d, 0);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "getopt_long_only": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "int\ngetopt_long_only (int argc, char *__getopt_argv_const *argv,\n                  const char *options,\n                  const struct option *long_options, int *opt_index)\n{\n  return _getopt_internal (argc, (char **) argv, options, long_options,\n                           opt_index, 1, 0);\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "_getopt_long_only_r": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "int\n_getopt_long_only_r (int argc, char **argv, const char *options,\n                     const struct option *long_options, int *opt_index,\n                     struct _getopt_data *d)\n{\n  return _getopt_internal_r (argc, argv, options, long_options, opt_index,\n                             1, d, 0);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "main": {
      "start_point": [
        83,
        0
      ],
      "end_point": [
        167,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  int c;\n  int digit_optind = 0;\n\n  while (1)\n    {\n      int this_option_optind = optind ? optind : 1;\n      int option_index = 0;\n      static const struct option long_options[] =\n      {\n        {\"add\", 1, 0, 0},\n        {\"append\", 0, 0, 0},\n        {\"delete\", 1, 0, 0},\n        {\"verbose\", 0, 0, 0},\n        {\"create\", 0, 0, 0},\n        {\"file\", 1, 0, 0},\n        {0, 0, 0, 0}\n      };\n\n      c = getopt_long (argc, argv, \"abc:d:0123456789\",\n                       long_options, &option_index);\n      if (c == -1)\n        break;\n\n      switch (c)\n        {\n        case 0:\n          printf (\"option %s\", long_options[option_index].name);\n          if (optarg)\n            printf (\" with arg %s\", optarg);\n          printf (\"\\n\");\n          break;\n\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n          if (digit_optind != 0 && digit_optind != this_option_optind)\n            printf (\"digits occur in two different argv-elements.\\n\");\n          digit_optind = this_option_optind;\n          printf (\"option %c\\n\", c);\n          break;\n\n        case 'a':\n          printf (\"option a\\n\");\n          break;\n\n        case 'b':\n          printf (\"option b\\n\");\n          break;\n\n        case 'c':\n          printf (\"option c with value '%s'\\n\", optarg);\n          break;\n\n        case 'd':\n          printf (\"option d with value '%s'\\n\", optarg);\n          break;\n\n        case '?':\n          break;\n\n        default:\n          printf (\"?? getopt returned character code 0%o ??\\n\", c);\n        }\n    }\n\n  if (optind < argc)\n    {\n      printf (\"non-option ARGV-elements: \");\n      while (optind < argc)\n        printf (\"%s \", argv[optind++]);\n      printf (\"\\n\");\n    }\n\n  exit (0);\n}",
      "lines": 85,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/getopt_int.h": {},
  "findutils/findutils-4.6.0/gl/lib/gettext.h": {
    "pgettext_aux": {
      "start_point": [
        146,
        0
      ],
      "end_point": [
        156,
        1
      ],
      "content": "static const char *\npgettext_aux (const char *domain,\n              const char *msg_ctxt_id, const char *msgid,\n              int category)\n{\n  const char *translation = dcgettext (domain, msg_ctxt_id, category);\n  if (translation == msg_ctxt_id)\n    return msgid;\n  else\n    return translation;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\npgettext_aux (const char *domain,\n              const char *msg_ctxt_id, const char *msgid,\n              int category)",
        "*"
      ]
    },
    "npgettext_aux": {
      "start_point": [
        165,
        0
      ],
      "end_point": [
        177,
        1
      ],
      "content": "static const char *\nnpgettext_aux (const char *domain,\n               const char *msg_ctxt_id, const char *msgid,\n               const char *msgid_plural, unsigned long int n,\n               int category)\n{\n  const char *translation =\n    dcngettext (domain, msg_ctxt_id, msgid_plural, n, category);\n  if (translation == msg_ctxt_id || translation == msgid_plural)\n    return (n == 1 ? msgid : msgid_plural);\n  else\n    return translation;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nnpgettext_aux (const char *domain,\n               const char *msg_ctxt_id, const char *msgid,\n               const char *msgid_plural, unsigned long int n,\n               int category)",
        "*"
      ]
    },
    "dcpgettext_expr": {
      "start_point": [
        208,
        0
      ],
      "end_point": [
        239,
        1
      ],
      "content": "static const char *\ndcpgettext_expr (const char *domain,\n                 const char *msgctxt, const char *msgid,\n                 int category)\n{\n  size_t msgctxt_len = strlen (msgctxt) + 1;\n  size_t msgid_len = strlen (msgid) + 1;\n  const char *translation;\n#if _LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n  char msg_ctxt_id[msgctxt_len + msgid_len];\n#else\n  char buf[1024];\n  char *msg_ctxt_id =\n    (msgctxt_len + msgid_len <= sizeof (buf)\n     ? buf\n     : (char *) malloc (msgctxt_len + msgid_len));\n  if (msg_ctxt_id != NULL)\n#endif\n    {\n      memcpy (msg_ctxt_id, msgctxt, msgctxt_len - 1);\n      msg_ctxt_id[msgctxt_len - 1] = '\\004';\n      memcpy (msg_ctxt_id + msgctxt_len, msgid, msgid_len);\n      translation = dcgettext (domain, msg_ctxt_id, category);\n#if !_LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n      if (msg_ctxt_id != buf)\n        free (msg_ctxt_id);\n#endif\n      if (translation != msg_ctxt_id)\n        return translation;\n    }\n  return msgid;\n}",
      "lines": 32,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\ndcpgettext_expr (const char *domain,\n                 const char *msgctxt, const char *msgid,\n                 int category)",
        "*"
      ]
    },
    "dcnpgettext_expr": {
      "start_point": [
        253,
        0
      ],
      "end_point": [
        285,
        1
      ],
      "content": "static const char *\ndcnpgettext_expr (const char *domain,\n                  const char *msgctxt, const char *msgid,\n                  const char *msgid_plural, unsigned long int n,\n                  int category)\n{\n  size_t msgctxt_len = strlen (msgctxt) + 1;\n  size_t msgid_len = strlen (msgid) + 1;\n  const char *translation;\n#if _LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n  char msg_ctxt_id[msgctxt_len + msgid_len];\n#else\n  char buf[1024];\n  char *msg_ctxt_id =\n    (msgctxt_len + msgid_len <= sizeof (buf)\n     ? buf\n     : (char *) malloc (msgctxt_len + msgid_len));\n  if (msg_ctxt_id != NULL)\n#endif\n    {\n      memcpy (msg_ctxt_id, msgctxt, msgctxt_len - 1);\n      msg_ctxt_id[msgctxt_len - 1] = '\\004';\n      memcpy (msg_ctxt_id + msgctxt_len, msgid, msgid_len);\n      translation = dcngettext (domain, msg_ctxt_id, msgid_plural, n, category);\n#if !_LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n      if (msg_ctxt_id != buf)\n        free (msg_ctxt_id);\n#endif\n      if (!(translation == msg_ctxt_id || translation == msgid_plural))\n        return translation;\n    }\n  return (n == 1 ? msgid : msgid_plural);\n}",
      "lines": 33,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\ndcnpgettext_expr (const char *domain,\n                  const char *msgctxt, const char *msgid,\n                  const char *msgid_plural, unsigned long int n,\n                  int category)",
        "*"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/gettime.c": {
    "gettime": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "void\ngettime (struct timespec *ts)\n{\n#if HAVE_NANOTIME\n  nanotime (ts);\n#else\n\n# if defined CLOCK_REALTIME && HAVE_CLOCK_GETTIME\n  if (clock_gettime (CLOCK_REALTIME, ts) == 0)\n    return;\n# endif\n\n  {\n    struct timeval tv;\n    gettimeofday (&tv, NULL);\n    ts->tv_sec = tv.tv_sec;\n    ts->tv_nsec = tv.tv_usec * 1000;\n  }\n\n#endif\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/gettimeofday.c": {
    "rpl_localtime": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "struct tm *\nrpl_localtime (time_t const *timep)\n{\n  struct tm *tm = localtime (timep);\n\n  if (localtime_buffer_addr == &tm_zero_buffer)\n    localtime_buffer_addr = tm;\n\n  return tm;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "struct tm",
        "struct",
        "tm",
        "*\nrpl_localtime (time_t const *timep)",
        "*"
      ]
    },
    "rpl_gmtime": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "struct tm *\nrpl_gmtime (time_t const *timep)\n{\n  struct tm *tm = gmtime (timep);\n\n  if (localtime_buffer_addr == &tm_zero_buffer)\n    localtime_buffer_addr = tm;\n\n  return tm;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "struct tm",
        "struct",
        "tm",
        "*\nrpl_gmtime (time_t const *timep)",
        "*"
      ]
    },
    "rpl_tzset": {
      "start_point": [
        85,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "void\nrpl_tzset (void)\n{\n  /* Save and restore the contents of the buffer used for localtime's\n     result around the call to tzset.  */\n  struct tm save = *localtime_buffer_addr;\n  tzset ();\n  *localtime_buffer_addr = save;\n}",
      "lines": 9,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "gettimeofday": {
      "start_point": [
        100,
        0
      ],
      "end_point": [
        153,
        1
      ],
      "content": "int\ngettimeofday (struct timeval *restrict tv, void *restrict tz)\n{\n#undef gettimeofday\n#if HAVE_GETTIMEOFDAY\n# if GETTIMEOFDAY_CLOBBERS_LOCALTIME\n  /* Save and restore the contents of the buffer used for localtime's\n     result around the call to gettimeofday.  */\n  struct tm save = *localtime_buffer_addr;\n# endif\n\n# if defined timeval /* 'struct timeval' overridden by gnulib?  */\n#  undef timeval\n  struct timeval otv;\n  int result = gettimeofday (&otv, (struct timezone *) tz);\n  if (result == 0)\n    {\n      tv->tv_sec = otv.tv_sec;\n      tv->tv_usec = otv.tv_usec;\n    }\n# else\n  int result = gettimeofday (tv, (struct timezone *) tz);\n# endif\n\n# if GETTIMEOFDAY_CLOBBERS_LOCALTIME\n  *localtime_buffer_addr = save;\n# endif\n\n  return result;\n\n#else\n\n# if HAVE__FTIME\n\n  struct _timeb timebuf;\n  _ftime (&timebuf);\n  tv->tv_sec = timebuf.time;\n  tv->tv_usec = timebuf.millitm * 1000;\n\n# else\n\n#  if !defined OK_TO_USE_1S_CLOCK\n#   error \"Only 1-second nominal clock resolution found.  Is that intended?\" \\\n          \"If so, compile with the -DOK_TO_USE_1S_CLOCK option.\"\n#  endif\n  tv->tv_sec = time (NULL);\n  tv->tv_usec = 0;\n\n# endif\n\n  return 0;\n\n#endif\n}",
      "lines": 54,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/group-member.c": {
    "free_group_info": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "static void\nfree_group_info (struct group_info const *g)\n{\n  if (g->group != g->groupbuf)\n    free (g->group);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "get_group_info": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "static int\nget_group_info (struct group_info *gi)\n{\n  int n_groups = getgroups (GROUPBUF_SIZE, gi->groupbuf);\n  gi->group = gi->groupbuf;\n\n  if (n_groups < 0)\n    {\n      int n_group_slots = getgroups (0, NULL);\n      if (0 <= n_group_slots\n          && ! xalloc_oversized (n_group_slots, sizeof *gi->group))\n        {\n          gi->group = malloc (n_group_slots * sizeof *gi->group);\n          if (gi->group)\n            n_groups = getgroups (n_group_slots, gi->group);\n        }\n    }\n\n  /* In case of error, the user loses.  */\n  return n_groups;\n}",
      "lines": 21,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "group_member": {
      "start_point": [
        73,
        0
      ],
      "end_point": [
        95,
        1
      ],
      "content": "int\ngroup_member (gid_t gid)\n{\n  int i;\n  int found;\n  struct group_info gi;\n  int n_groups = get_group_info (&gi);\n\n  /* Search through the list looking for GID. */\n  found = 0;\n  for (i = 0; i < n_groups; i++)\n    {\n      if (gid == gi.group[i])\n        {\n          found = 1;\n          break;\n        }\n    }\n\n  free_group_info (&gi);\n\n  return found;\n}",
      "lines": 23,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "main": {
      "start_point": [
        101,
        0
      ],
      "end_point": [
        116,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  int i;\n\n  program_name = argv[0];\n\n  for (i = 1; i < argc; i++)\n    {\n      gid_t gid;\n\n      gid = atoi (argv[i]);\n      printf (\"%d: %s\\n\", gid, group_member (gid) ? \"yes\" : \"no\");\n    }\n  exit (0);\n}",
      "lines": 16,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/hash-pjw.c": {
    "hash_pjw": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        39,
        1
      ],
      "content": "size_t\nhash_pjw (const void *x, size_t tablesize)\n{\n  const char *s;\n  size_t h = 0;\n\n  for (s = x; *s; s++)\n    h = *s + ((h << 9) | (h >> (SIZE_BITS - 9)));\n\n  return h % tablesize;\n}",
      "lines": 11,
      "depth": 13,
      "decorators": [
        "size_t"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/hash-pjw.h": {},
  "findutils/findutils-4.6.0/gl/lib/hash-triple.c": {
    "triple_hash": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "size_t\ntriple_hash (void const *x, size_t table_size)\n{\n  struct F_triple const *p = x;\n  size_t tmp = hash_pjw (p->name, table_size);\n\n  /* Ignoring the device number here should be fine.  */\n  return (tmp ^ p->st_ino) % table_size;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "size_t"
      ]
    },
    "triple_hash_no_name": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "size_t\ntriple_hash_no_name (void const *x, size_t table_size)\n{\n  struct F_triple const *p = x;\n\n  /* Ignoring the device number here should be fine.  */\n  return p->st_ino % table_size;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "size_t"
      ]
    },
    "triple_compare": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "bool\ntriple_compare (void const *x, void const *y)\n{\n  struct F_triple const *a = x;\n  struct F_triple const *b = y;\n  return (SAME_INODE (*a, *b) && same_name (a->name, b->name)) ? true : false;\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "bool"
      ]
    },
    "triple_compare_ino_str": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "bool\ntriple_compare_ino_str (void const *x, void const *y)\n{\n  struct F_triple const *a = x;\n  struct F_triple const *b = y;\n  return (SAME_INODE (*a, *b) && STREQ (a->name, b->name)) ? true : false;\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "bool"
      ]
    },
    "triple_free": {
      "start_point": [
        70,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "void\ntriple_free (void *x)\n{\n  struct F_triple *a = x;\n  free (a->name);\n  free (a);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/hash-triple.h": {},
  "findutils/findutils-4.6.0/gl/lib/hash.c": {
    "hash_get_n_buckets": {
      "start_point": [
        148,
        0
      ],
      "end_point": [
        152,
        1
      ],
      "content": "size_t\nhash_get_n_buckets (const Hash_table *table)\n{\n  return table->n_buckets;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "size_t"
      ]
    },
    "hash_get_n_buckets_used": {
      "start_point": [
        156,
        0
      ],
      "end_point": [
        160,
        1
      ],
      "content": "size_t\nhash_get_n_buckets_used (const Hash_table *table)\n{\n  return table->n_buckets_used;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "size_t"
      ]
    },
    "hash_get_n_entries": {
      "start_point": [
        164,
        0
      ],
      "end_point": [
        168,
        1
      ],
      "content": "size_t\nhash_get_n_entries (const Hash_table *table)\n{\n  return table->n_entries;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "size_t"
      ]
    },
    "hash_get_max_bucket_length": {
      "start_point": [
        172,
        0
      ],
      "end_point": [
        194,
        1
      ],
      "content": "size_t\nhash_get_max_bucket_length (const Hash_table *table)\n{\n  struct hash_entry const *bucket;\n  size_t max_bucket_length = 0;\n\n  for (bucket = table->bucket; bucket < table->bucket_limit; bucket++)\n    {\n      if (bucket->data)\n        {\n          struct hash_entry const *cursor = bucket;\n          size_t bucket_length = 1;\n\n          while (cursor = cursor->next, cursor)\n            bucket_length++;\n\n          if (bucket_length > max_bucket_length)\n            max_bucket_length = bucket_length;\n        }\n    }\n\n  return max_bucket_length;\n}",
      "lines": 23,
      "depth": 12,
      "decorators": [
        "size_t"
      ]
    },
    "hash_table_ok": {
      "start_point": [
        199,
        0
      ],
      "end_point": [
        226,
        1
      ],
      "content": "bool\nhash_table_ok (const Hash_table *table)\n{\n  struct hash_entry const *bucket;\n  size_t n_buckets_used = 0;\n  size_t n_entries = 0;\n\n  for (bucket = table->bucket; bucket < table->bucket_limit; bucket++)\n    {\n      if (bucket->data)\n        {\n          struct hash_entry const *cursor = bucket;\n\n          /* Count bucket head.  */\n          n_buckets_used++;\n          n_entries++;\n\n          /* Count bucket overflow.  */\n          while (cursor = cursor->next, cursor)\n            n_entries++;\n        }\n    }\n\n  if (n_buckets_used == table->n_buckets_used && n_entries == table->n_entries)\n    return true;\n\n  return false;\n}",
      "lines": 28,
      "depth": 12,
      "decorators": [
        "bool"
      ]
    },
    "hash_print_statistics": {
      "start_point": [
        228,
        0
      ],
      "end_point": [
        243,
        1
      ],
      "content": "void\nhash_print_statistics (const Hash_table *table, FILE *stream)\n{\n  size_t n_entries = hash_get_n_entries (table);\n  size_t n_buckets = hash_get_n_buckets (table);\n  size_t n_buckets_used = hash_get_n_buckets_used (table);\n  size_t max_bucket_length = hash_get_max_bucket_length (table);\n\n  fprintf (stream, \"# entries:         %lu\\n\", (unsigned long int) n_entries);\n  fprintf (stream, \"# buckets:         %lu\\n\", (unsigned long int) n_buckets);\n  fprintf (stream, \"# buckets used:    %lu (%.2f%%)\\n\",\n           (unsigned long int) n_buckets_used,\n           (100.0 * n_buckets_used) / n_buckets);\n  fprintf (stream, \"max bucket length: %lu\\n\",\n           (unsigned long int) max_bucket_length);\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "safe_hasher": {
      "start_point": [
        247,
        0
      ],
      "end_point": [
        254,
        1
      ],
      "content": "static struct hash_entry *\nsafe_hasher (const Hash_table *table, const void *key)\n{\n  size_t n = table->hasher (key, table->n_buckets);\n  if (! (n < table->n_buckets))\n    abort ();\n  return table->bucket + n;\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "struct hash_entry",
        "struct",
        "hash_entry",
        "*\nsafe_hasher (const Hash_table *table, const void *key)",
        "*"
      ]
    },
    "hash_lookup": {
      "start_point": [
        259,
        0
      ],
      "end_point": [
        273,
        1
      ],
      "content": "void *\nhash_lookup (const Hash_table *table, const void *entry)\n{\n  struct hash_entry const *bucket = safe_hasher (table, entry);\n  struct hash_entry const *cursor;\n\n  if (bucket->data == NULL)\n    return NULL;\n\n  for (cursor = bucket; cursor; cursor = cursor->next)\n    if (entry == cursor->data || table->comparator (entry, cursor->data))\n      return cursor->data;\n\n  return NULL;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "void",
        "*\nhash_lookup (const Hash_table *table, const void *entry)",
        "*"
      ]
    },
    "hash_get_first": {
      "start_point": [
        286,
        0
      ],
      "end_point": [
        299,
        1
      ],
      "content": "void *\nhash_get_first (const Hash_table *table)\n{\n  struct hash_entry const *bucket;\n\n  if (table->n_entries == 0)\n    return NULL;\n\n  for (bucket = table->bucket; ; bucket++)\n    if (! (bucket < table->bucket_limit))\n      abort ();\n    else if (bucket->data)\n      return bucket->data;\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "void",
        "*\nhash_get_first (const Hash_table *table)",
        "*"
      ]
    },
    "hash_get_next": {
      "start_point": [
        305,
        0
      ],
      "end_point": [
        328,
        1
      ],
      "content": "void *\nhash_get_next (const Hash_table *table, const void *entry)\n{\n  struct hash_entry const *bucket = safe_hasher (table, entry);\n  struct hash_entry const *cursor;\n\n  /* Find next entry in the same bucket.  */\n  cursor = bucket;\n  do\n    {\n      if (cursor->data == entry && cursor->next)\n        return cursor->next->data;\n      cursor = cursor->next;\n    }\n  while (cursor != NULL);\n\n  /* Find first entry in any subsequent bucket.  */\n  while (++bucket < table->bucket_limit)\n    if (bucket->data)\n      return bucket->data;\n\n  /* None found.  */\n  return NULL;\n}",
      "lines": 24,
      "depth": 10,
      "decorators": [
        "void",
        "*\nhash_get_next (const Hash_table *table, const void *entry)",
        "*"
      ]
    },
    "hash_get_entries": {
      "start_point": [
        334,
        0
      ],
      "end_point": [
        356,
        1
      ],
      "content": "size_t\nhash_get_entries (const Hash_table *table, void **buffer,\n                  size_t buffer_size)\n{\n  size_t counter = 0;\n  struct hash_entry const *bucket;\n  struct hash_entry const *cursor;\n\n  for (bucket = table->bucket; bucket < table->bucket_limit; bucket++)\n    {\n      if (bucket->data)\n        {\n          for (cursor = bucket; cursor; cursor = cursor->next)\n            {\n              if (counter >= buffer_size)\n                return counter;\n              buffer[counter++] = cursor->data;\n            }\n        }\n    }\n\n  return counter;\n}",
      "lines": 23,
      "depth": 13,
      "decorators": [
        "size_t"
      ]
    },
    "hash_do_for_each": {
      "start_point": [
        366,
        0
      ],
      "end_point": [
        388,
        1
      ],
      "content": "size_t\nhash_do_for_each (const Hash_table *table, Hash_processor processor,\n                  void *processor_data)\n{\n  size_t counter = 0;\n  struct hash_entry const *bucket;\n  struct hash_entry const *cursor;\n\n  for (bucket = table->bucket; bucket < table->bucket_limit; bucket++)\n    {\n      if (bucket->data)\n        {\n          for (cursor = bucket; cursor; cursor = cursor->next)\n            {\n              if (! processor (cursor->data, processor_data))\n                return counter;\n              counter++;\n            }\n        }\n    }\n\n  return counter;\n}",
      "lines": 23,
      "depth": 15,
      "decorators": [
        "size_t"
      ]
    },
    "hash_string": [
      {
        "start_point": [
          403,
          0
        ],
        "end_point": [
          417,
          1
        ],
        "content": "size_t\nhash_string (const char *string, size_t n_buckets)\n{\n# define HASH_ONE_CHAR(Value, Byte) \\\n  ((Byte) + rotl_sz (Value, 7))\n\n  size_t value = 0;\n  unsigned char ch;\n\n  for (; (ch = *string); string++)\n    value = HASH_ONE_CHAR (value, ch);\n  return value % n_buckets;\n\n# undef HASH_ONE_CHAR\n}",
        "lines": 15,
        "depth": 8,
        "decorators": [
          "size_t"
        ]
      },
      {
        "start_point": [
          426,
          0
        ],
        "end_point": [
          435,
          1
        ],
        "content": "size_t\nhash_string (const char *string, size_t n_buckets)\n{\n  size_t value = 0;\n  unsigned char ch;\n\n  for (; (ch = *string); string++)\n    value = (value * 31 + ch) % n_buckets;\n  return value;\n}",
        "lines": 10,
        "depth": 10,
        "decorators": [
          "size_t"
        ]
      }
    ],
    "_GL_ATTRIBUTE_CONST": [
      {
        "start_point": [
          442,
          0
        ],
        "end_point": [
          456,
          1
        ],
        "content": "static bool _GL_ATTRIBUTE_CONST\nis_prime (size_t candidate)\n{\n  size_t divisor = 3;\n  size_t square = divisor * divisor;\n\n  while (square < candidate && (candidate % divisor))\n    {\n      divisor++;\n      square += 4 * divisor;\n      divisor++;\n    }\n\n  return (candidate % divisor ? true : false);\n}",
        "lines": 15,
        "depth": 8,
        "decorators": [
          "static",
          "static",
          "bool"
        ]
      },
      {
        "start_point": [
          461,
          0
        ],
        "end_point": [
          475,
          1
        ],
        "content": "static size_t _GL_ATTRIBUTE_CONST\nnext_prime (size_t candidate)\n{\n  /* Skip small primes.  */\n  if (candidate < 10)\n    candidate = 10;\n\n  /* Make it definitely odd.  */\n  candidate |= 1;\n\n  while (SIZE_MAX != candidate && !is_prime (candidate))\n    candidate += 2;\n\n  return candidate;\n}",
        "lines": 15,
        "depth": 9,
        "decorators": [
          "static",
          "static",
          "size_t"
        ]
      }
    ],
    "hash_reset_tuning": {
      "start_point": [
        477,
        0
      ],
      "end_point": [
        481,
        1
      ],
      "content": "void\nhash_reset_tuning (Hash_tuning *tuning)\n{\n  *tuning = default_tuning;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "raw_hasher": {
      "start_point": [
        484,
        0
      ],
      "end_point": [
        494,
        1
      ],
      "content": "static size_t\nraw_hasher (const void *data, size_t n)\n{\n  /* When hashing unique pointers, it is often the case that they were\n     generated by malloc and thus have the property that the low-order\n     bits are 0.  As this tends to give poorer performance with small\n     tables, we rotate the pointer value before performing division,\n     in an attempt to improve hash quality.  */\n  size_t val = rotr_sz ((size_t) data, 3);\n  return val % n;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "raw_comparator": {
      "start_point": [
        497,
        0
      ],
      "end_point": [
        501,
        1
      ],
      "content": "static bool\nraw_comparator (const void *a, const void *b)\n{\n  return a == b;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "check_tuning": {
      "start_point": [
        510,
        0
      ],
      "end_point": [
        536,
        1
      ],
      "content": "static bool\ncheck_tuning (Hash_table *table)\n{\n  const Hash_tuning *tuning = table->tuning;\n  float epsilon;\n  if (tuning == &default_tuning)\n    return true;\n\n  /* Be a bit stricter than mathematics would require, so that\n     rounding errors in size calculations do not cause allocations to\n     fail to grow or shrink as they should.  The smallest allocation\n     is 11 (due to next_prime's algorithm), so an epsilon of 0.1\n     should be good enough.  */\n  epsilon = 0.1f;\n\n  if (epsilon < tuning->growth_threshold\n      && tuning->growth_threshold < 1 - epsilon\n      && 1 + epsilon < tuning->growth_factor\n      && 0 <= tuning->shrink_threshold\n      && tuning->shrink_threshold + epsilon < tuning->shrink_factor\n      && tuning->shrink_factor <= 1\n      && tuning->shrink_threshold + epsilon < tuning->growth_threshold)\n    return true;\n\n  table->tuning = &default_tuning;\n  return false;\n}",
      "lines": 27,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "compute_bucket_size": {
      "start_point": [
        542,
        0
      ],
      "end_point": [
        556,
        1
      ],
      "content": "static size_t _GL_ATTRIBUTE_PURE\ncompute_bucket_size (size_t candidate, const Hash_tuning *tuning)\n{\n  if (!tuning->is_n_buckets)\n    {\n      float new_candidate = candidate / tuning->growth_threshold;\n      if (SIZE_MAX <= new_candidate)\n        return 0;\n      candidate = new_candidate;\n    }\n  candidate = next_prime (candidate);\n  if (xalloc_oversized (candidate, sizeof (struct hash_entry *)))\n    return 0;\n  return candidate;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "size_t",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "hash_initialize": {
      "start_point": [
        592,
        0
      ],
      "end_point": [
        645,
        1
      ],
      "content": "Hash_table *\nhash_initialize (size_t candidate, const Hash_tuning *tuning,\n                 Hash_hasher hasher, Hash_comparator comparator,\n                 Hash_data_freer data_freer)\n{\n  Hash_table *table;\n\n  if (hasher == NULL)\n    hasher = raw_hasher;\n  if (comparator == NULL)\n    comparator = raw_comparator;\n\n  table = malloc (sizeof *table);\n  if (table == NULL)\n    return NULL;\n\n  if (!tuning)\n    tuning = &default_tuning;\n  table->tuning = tuning;\n  if (!check_tuning (table))\n    {\n      /* Fail if the tuning options are invalid.  This is the only occasion\n         when the user gets some feedback about it.  Once the table is created,\n         if the user provides invalid tuning options, we silently revert to\n         using the defaults, and ignore further request to change the tuning\n         options.  */\n      goto fail;\n    }\n\n  table->n_buckets = compute_bucket_size (candidate, tuning);\n  if (!table->n_buckets)\n    goto fail;\n\n  table->bucket = calloc (table->n_buckets, sizeof *table->bucket);\n  if (table->bucket == NULL)\n    goto fail;\n  table->bucket_limit = table->bucket + table->n_buckets;\n  table->n_buckets_used = 0;\n  table->n_entries = 0;\n\n  table->hasher = hasher;\n  table->comparator = comparator;\n  table->data_freer = data_freer;\n\n  table->free_entry_list = NULL;\n#if USE_OBSTACK\n  obstack_init (&table->entry_stack);\n#endif\n  return table;\n\n fail:\n  free (table);\n  return NULL;\n}",
      "lines": 54,
      "depth": 10,
      "decorators": [
        "Hash_table",
        "*\nhash_initialize (size_t candidate, const Hash_tuning *tuning,\n                 Hash_hasher hasher, Hash_comparator comparator,\n                 Hash_data_freer data_freer)",
        "*"
      ]
    },
    "hash_clear": {
      "start_point": [
        651,
        0
      ],
      "end_point": [
        687,
        1
      ],
      "content": "void\nhash_clear (Hash_table *table)\n{\n  struct hash_entry *bucket;\n\n  for (bucket = table->bucket; bucket < table->bucket_limit; bucket++)\n    {\n      if (bucket->data)\n        {\n          struct hash_entry *cursor;\n          struct hash_entry *next;\n\n          /* Free the bucket overflow.  */\n          for (cursor = bucket->next; cursor; cursor = next)\n            {\n              if (table->data_freer)\n                table->data_freer (cursor->data);\n              cursor->data = NULL;\n\n              next = cursor->next;\n              /* Relinking is done one entry at a time, as it is to be expected\n                 that overflows are either rare or short.  */\n              cursor->next = table->free_entry_list;\n              table->free_entry_list = cursor;\n            }\n\n          /* Free the bucket head.  */\n          if (table->data_freer)\n            table->data_freer (bucket->data);\n          bucket->data = NULL;\n          bucket->next = NULL;\n        }\n    }\n\n  table->n_buckets_used = 0;\n  table->n_entries = 0;\n}",
      "lines": 37,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "hash_free": {
      "start_point": [
        694,
        0
      ],
      "end_point": [
        742,
        1
      ],
      "content": "void\nhash_free (Hash_table *table)\n{\n  struct hash_entry *bucket;\n  struct hash_entry *cursor;\n  struct hash_entry *next;\n\n  /* Call the user data_freer function.  */\n  if (table->data_freer && table->n_entries)\n    {\n      for (bucket = table->bucket; bucket < table->bucket_limit; bucket++)\n        {\n          if (bucket->data)\n            {\n              for (cursor = bucket; cursor; cursor = cursor->next)\n                table->data_freer (cursor->data);\n            }\n        }\n    }\n\n#if USE_OBSTACK\n\n  obstack_free (&table->entry_stack, NULL);\n\n#else\n\n  /* Free all bucket overflowed entries.  */\n  for (bucket = table->bucket; bucket < table->bucket_limit; bucket++)\n    {\n      for (cursor = bucket->next; cursor; cursor = next)\n        {\n          next = cursor->next;\n          free (cursor);\n        }\n    }\n\n  /* Also reclaim the internal list of previously freed entries.  */\n  for (cursor = table->free_entry_list; cursor; cursor = next)\n    {\n      next = cursor->next;\n      free (cursor);\n    }\n\n#endif\n\n  /* Free the remainder of the hash table structure.  */\n  free (table->bucket);\n  free (table);\n}",
      "lines": 49,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "allocate_entry": {
      "start_point": [
        749,
        0
      ],
      "end_point": [
        769,
        1
      ],
      "content": "static struct hash_entry *\nallocate_entry (Hash_table *table)\n{\n  struct hash_entry *new;\n\n  if (table->free_entry_list)\n    {\n      new = table->free_entry_list;\n      table->free_entry_list = new->next;\n    }\n  else\n    {\n#if USE_OBSTACK\n      new = obstack_alloc (&table->entry_stack, sizeof *new);\n#else\n      new = malloc (sizeof *new);\n#endif\n    }\n\n  return new;\n}",
      "lines": 21,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "struct hash_entry",
        "struct",
        "hash_entry",
        "*\nallocate_entry (Hash_table *table)",
        "*"
      ]
    },
    "free_entry": {
      "start_point": [
        774,
        0
      ],
      "end_point": [
        780,
        1
      ],
      "content": "static void\nfree_entry (Hash_table *table, struct hash_entry *entry)\n{\n  entry->data = NULL;\n  entry->next = table->free_entry_list;\n  table->free_entry_list = entry;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "hash_find_entry": {
      "start_point": [
        788,
        0
      ],
      "end_point": [
        850,
        1
      ],
      "content": "static void *\nhash_find_entry (Hash_table *table, const void *entry,\n                 struct hash_entry **bucket_head, bool delete)\n{\n  struct hash_entry *bucket = safe_hasher (table, entry);\n  struct hash_entry *cursor;\n\n  *bucket_head = bucket;\n\n  /* Test for empty bucket.  */\n  if (bucket->data == NULL)\n    return NULL;\n\n  /* See if the entry is the first in the bucket.  */\n  if (entry == bucket->data || table->comparator (entry, bucket->data))\n    {\n      void *data = bucket->data;\n\n      if (delete)\n        {\n          if (bucket->next)\n            {\n              struct hash_entry *next = bucket->next;\n\n              /* Bump the first overflow entry into the bucket head, then save\n                 the previous first overflow entry for later recycling.  */\n              *bucket = *next;\n              free_entry (table, next);\n            }\n          else\n            {\n              bucket->data = NULL;\n            }\n        }\n\n      return data;\n    }\n\n  /* Scan the bucket overflow.  */\n  for (cursor = bucket; cursor->next; cursor = cursor->next)\n    {\n      if (entry == cursor->next->data\n          || table->comparator (entry, cursor->next->data))\n        {\n          void *data = cursor->next->data;\n\n          if (delete)\n            {\n              struct hash_entry *next = cursor->next;\n\n              /* Unlink the entry to delete, then save the freed entry for later\n                 recycling.  */\n              cursor->next = next->next;\n              free_entry (table, next);\n            }\n\n          return data;\n        }\n    }\n\n  /* No entry found.  */\n  return NULL;\n}",
      "lines": 63,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nhash_find_entry (Hash_table *table, const void *entry,\n                 struct hash_entry **bucket_head, bool delete)",
        "*"
      ]
    },
    "transfer_entries": {
      "start_point": [
        858,
        0
      ],
      "end_point": [
        931,
        1
      ],
      "content": "static bool\ntransfer_entries (Hash_table *dst, Hash_table *src, bool safe)\n{\n  struct hash_entry *bucket;\n  struct hash_entry *cursor;\n  struct hash_entry *next;\n  for (bucket = src->bucket; bucket < src->bucket_limit; bucket++)\n    if (bucket->data)\n      {\n        void *data;\n        struct hash_entry *new_bucket;\n\n        /* Within each bucket, transfer overflow entries first and\n           then the bucket head, to minimize memory pressure.  After\n           all, the only time we might allocate is when moving the\n           bucket head, but moving overflow entries first may create\n           free entries that can be recycled by the time we finally\n           get to the bucket head.  */\n        for (cursor = bucket->next; cursor; cursor = next)\n          {\n            data = cursor->data;\n            new_bucket = safe_hasher (dst, data);\n\n            next = cursor->next;\n\n            if (new_bucket->data)\n              {\n                /* Merely relink an existing entry, when moving from a\n                   bucket overflow into a bucket overflow.  */\n                cursor->next = new_bucket->next;\n                new_bucket->next = cursor;\n              }\n            else\n              {\n                /* Free an existing entry, when moving from a bucket\n                   overflow into a bucket header.  */\n                new_bucket->data = data;\n                dst->n_buckets_used++;\n                free_entry (dst, cursor);\n              }\n          }\n        /* Now move the bucket head.  Be sure that if we fail due to\n           allocation failure that the src table is in a consistent\n           state.  */\n        data = bucket->data;\n        bucket->next = NULL;\n        if (safe)\n          continue;\n        new_bucket = safe_hasher (dst, data);\n\n        if (new_bucket->data)\n          {\n            /* Allocate or recycle an entry, when moving from a bucket\n               header into a bucket overflow.  */\n            struct hash_entry *new_entry = allocate_entry (dst);\n\n            if (new_entry == NULL)\n              return false;\n\n            new_entry->data = data;\n            new_entry->next = new_bucket->next;\n            new_bucket->next = new_entry;\n          }\n        else\n          {\n            /* Move from one bucket header to another.  */\n            new_bucket->data = data;\n            dst->n_buckets_used++;\n          }\n        bucket->data = NULL;\n        src->n_buckets_used--;\n      }\n  return true;\n}",
      "lines": 74,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "hash_rehash": {
      "start_point": [
        941,
        0
      ],
      "end_point": [
        1018,
        1
      ],
      "content": "bool\nhash_rehash (Hash_table *table, size_t candidate)\n{\n  Hash_table storage;\n  Hash_table *new_table;\n  size_t new_size = compute_bucket_size (candidate, table->tuning);\n\n  if (!new_size)\n    return false;\n  if (new_size == table->n_buckets)\n    return true;\n  new_table = &storage;\n  new_table->bucket = calloc (new_size, sizeof *new_table->bucket);\n  if (new_table->bucket == NULL)\n    return false;\n  new_table->n_buckets = new_size;\n  new_table->bucket_limit = new_table->bucket + new_size;\n  new_table->n_buckets_used = 0;\n  new_table->n_entries = 0;\n  new_table->tuning = table->tuning;\n  new_table->hasher = table->hasher;\n  new_table->comparator = table->comparator;\n  new_table->data_freer = table->data_freer;\n\n  /* In order for the transfer to successfully complete, we need\n     additional overflow entries when distinct buckets in the old\n     table collide into a common bucket in the new table.  The worst\n     case possible is a hasher that gives a good spread with the old\n     size, but returns a constant with the new size; if we were to\n     guarantee table->n_buckets_used-1 free entries in advance, then\n     the transfer would be guaranteed to not allocate memory.\n     However, for large tables, a guarantee of no further allocation\n     introduces a lot of extra memory pressure, all for an unlikely\n     corner case (most rehashes reduce, rather than increase, the\n     number of overflow entries needed).  So, we instead ensure that\n     the transfer process can be reversed if we hit a memory\n     allocation failure mid-transfer.  */\n\n  /* Merely reuse the extra old space into the new table.  */\n#if USE_OBSTACK\n  new_table->entry_stack = table->entry_stack;\n#endif\n  new_table->free_entry_list = table->free_entry_list;\n\n  if (transfer_entries (new_table, table, false))\n    {\n      /* Entries transferred successfully; tie up the loose ends.  */\n      free (table->bucket);\n      table->bucket = new_table->bucket;\n      table->bucket_limit = new_table->bucket_limit;\n      table->n_buckets = new_table->n_buckets;\n      table->n_buckets_used = new_table->n_buckets_used;\n      table->free_entry_list = new_table->free_entry_list;\n      /* table->n_entries and table->entry_stack already hold their value.  */\n      return true;\n    }\n\n  /* We've allocated new_table->bucket (and possibly some entries),\n     exhausted the free list, and moved some but not all entries into\n     new_table.  We must undo the partial move before returning\n     failure.  The only way to get into this situation is if new_table\n     uses fewer buckets than the old table, so we will reclaim some\n     free entries as overflows in the new table are put back into\n     distinct buckets in the old table.\n\n     There are some pathological cases where a single pass through the\n     table requires more intermediate overflow entries than using two\n     passes.  Two passes give worse cache performance and takes\n     longer, but at this point, we're already out of memory, so slow\n     and safe is better than failure.  */\n  table->free_entry_list = new_table->free_entry_list;\n  if (! (transfer_entries (table, new_table, true)\n         && transfer_entries (table, new_table, false)))\n    abort ();\n  /* table->n_entries already holds its value.  */\n  free (new_table->bucket);\n  return false;\n}",
      "lines": 78,
      "depth": 10,
      "decorators": [
        "bool"
      ]
    },
    "hash_insert_if_absent": {
      "start_point": [
        1036,
        0
      ],
      "end_point": [
        1116,
        1
      ],
      "content": "int\nhash_insert_if_absent (Hash_table *table, void const *entry,\n                       void const **matched_ent)\n{\n  void *data;\n  struct hash_entry *bucket;\n\n  /* The caller cannot insert a NULL entry, since hash_lookup returns NULL\n     to indicate \"not found\", and hash_find_entry uses \"bucket->data == NULL\"\n     to indicate an empty bucket.  */\n  if (! entry)\n    abort ();\n\n  /* If there's a matching entry already in the table, return that.  */\n  if ((data = hash_find_entry (table, entry, &bucket, false)) != NULL)\n    {\n      if (matched_ent)\n        *matched_ent = data;\n      return 0;\n    }\n\n  /* If the growth threshold of the buckets in use has been reached, increase\n     the table size and rehash.  There's no point in checking the number of\n     entries:  if the hashing function is ill-conditioned, rehashing is not\n     likely to improve it.  */\n\n  if (table->n_buckets_used\n      > table->tuning->growth_threshold * table->n_buckets)\n    {\n      /* Check more fully, before starting real work.  If tuning arguments\n         became invalid, the second check will rely on proper defaults.  */\n      check_tuning (table);\n      if (table->n_buckets_used\n          > table->tuning->growth_threshold * table->n_buckets)\n        {\n          const Hash_tuning *tuning = table->tuning;\n          float candidate =\n            (tuning->is_n_buckets\n             ? (table->n_buckets * tuning->growth_factor)\n             : (table->n_buckets * tuning->growth_factor\n                * tuning->growth_threshold));\n\n          if (SIZE_MAX <= candidate)\n            return -1;\n\n          /* If the rehash fails, arrange to return NULL.  */\n          if (!hash_rehash (table, candidate))\n            return -1;\n\n          /* Update the bucket we are interested in.  */\n          if (hash_find_entry (table, entry, &bucket, false) != NULL)\n            abort ();\n        }\n    }\n\n  /* ENTRY is not matched, it should be inserted.  */\n\n  if (bucket->data)\n    {\n      struct hash_entry *new_entry = allocate_entry (table);\n\n      if (new_entry == NULL)\n        return -1;\n\n      /* Add ENTRY in the overflow of the bucket.  */\n\n      new_entry->data = (void *) entry;\n      new_entry->next = bucket->next;\n      bucket->next = new_entry;\n      table->n_entries++;\n      return 1;\n    }\n\n  /* Add ENTRY right in the bucket head.  */\n\n  bucket->data = (void *) entry;\n  table->n_entries++;\n  table->n_buckets_used++;\n\n  return 1;\n}",
      "lines": 81,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "hash_insert": {
      "start_point": [
        1124,
        0
      ],
      "end_point": [
        1132,
        1
      ],
      "content": "void *\nhash_insert (Hash_table *table, void const *entry)\n{\n  void const *matched_ent;\n  int err = hash_insert_if_absent (table, entry, &matched_ent);\n  return (err == -1\n          ? NULL\n          : (void *) (err == 0 ? matched_ent : entry));\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "void",
        "*\nhash_insert (Hash_table *table, void const *entry)",
        "*"
      ]
    },
    "hash_delete": {
      "start_point": [
        1138,
        0
      ],
      "end_point": [
        1196,
        1
      ],
      "content": "void *\nhash_delete (Hash_table *table, const void *entry)\n{\n  void *data;\n  struct hash_entry *bucket;\n\n  data = hash_find_entry (table, entry, &bucket, true);\n  if (!data)\n    return NULL;\n\n  table->n_entries--;\n  if (!bucket->data)\n    {\n      table->n_buckets_used--;\n\n      /* If the shrink threshold of the buckets in use has been reached,\n         rehash into a smaller table.  */\n\n      if (table->n_buckets_used\n          < table->tuning->shrink_threshold * table->n_buckets)\n        {\n          /* Check more fully, before starting real work.  If tuning arguments\n             became invalid, the second check will rely on proper defaults.  */\n          check_tuning (table);\n          if (table->n_buckets_used\n              < table->tuning->shrink_threshold * table->n_buckets)\n            {\n              const Hash_tuning *tuning = table->tuning;\n              size_t candidate =\n                (tuning->is_n_buckets\n                 ? table->n_buckets * tuning->shrink_factor\n                 : (table->n_buckets * tuning->shrink_factor\n                    * tuning->growth_threshold));\n\n              if (!hash_rehash (table, candidate))\n                {\n                  /* Failure to allocate memory in an attempt to\n                     shrink the table is not fatal.  But since memory\n                     is low, we can at least be kind and free any\n                     spare entries, rather than keeping them tied up\n                     in the free entry list.  */\n#if ! USE_OBSTACK\n                  struct hash_entry *cursor = table->free_entry_list;\n                  struct hash_entry *next;\n                  while (cursor)\n                    {\n                      next = cursor->next;\n                      free (cursor);\n                      cursor = next;\n                    }\n                  table->free_entry_list = NULL;\n#endif\n                }\n            }\n        }\n    }\n\n  return data;\n}",
      "lines": 59,
      "depth": 17,
      "decorators": [
        "void",
        "*\nhash_delete (Hash_table *table, const void *entry)",
        "*"
      ]
    },
    "hash_print": {
      "start_point": [
        1202,
        0
      ],
      "end_point": [
        1222,
        1
      ],
      "content": "void\nhash_print (const Hash_table *table)\n{\n  struct hash_entry *bucket = (struct hash_entry *) table->bucket;\n\n  for ( ; bucket < table->bucket_limit; bucket++)\n    {\n      struct hash_entry *cursor;\n\n      if (bucket)\n        printf (\"%lu:\\n\", (unsigned long int) (bucket - table->bucket));\n\n      for (cursor = bucket; cursor; cursor = cursor->next)\n        {\n          char const *s = cursor->data;\n          /* FIXME */\n          if (s)\n            printf (\"  %s\\n\", s);\n        }\n    }\n}",
      "lines": 21,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/hash.h": {},
  "findutils/findutils-4.6.0/gl/lib/human.c": {
    "adjust_value": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "static long double\nadjust_value (int inexact_style, long double value)\n{\n  /* Do not use the floorl or ceill functions, as that would mean\n     checking for their presence and possibly linking with the\n     standard math library, which is a porting pain.  So leave the\n     value alone if it is too large to easily round.  */\n  if (inexact_style != human_round_to_nearest && value < UINTMAX_MAX)\n    {\n      uintmax_t u = value;\n      value = u + (inexact_style == human_ceiling && u != value);\n    }\n\n  return value;\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "long double",
        "long",
        "double"
      ]
    },
    "group_number": {
      "start_point": [
        77,
        0
      ],
      "end_point": [
        115,
        1
      ],
      "content": "static char *\ngroup_number (char *number, size_t numberlen,\n              char const *grouping, char const *thousands_sep)\n{\n  register char *d;\n  size_t grouplen = SIZE_MAX;\n  size_t thousands_seplen = strlen (thousands_sep);\n  size_t i = numberlen;\n\n  /* The maximum possible value for NUMBERLEN is the number of digits\n     in the square of the largest uintmax_t, so double the size needed.  */\n  char buf[2 * INT_STRLEN_BOUND (uintmax_t) + 1];\n\n  memcpy (buf, number, numberlen);\n  d = number + numberlen;\n\n  for (;;)\n    {\n      unsigned char g = *grouping;\n\n      if (g)\n        {\n          grouplen = g < CHAR_MAX ? g : i;\n          grouping++;\n        }\n\n      if (i < grouplen)\n        grouplen = i;\n\n      d -= grouplen;\n      i -= grouplen;\n      memcpy (d, buf + i, grouplen);\n      if (i == 0)\n        return d;\n\n      d -= thousands_seplen;\n      memcpy (d, thousands_sep, thousands_seplen);\n    }\n}",
      "lines": 39,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "char",
        "*\ngroup_number (char *number, size_t numberlen,\n              char const *grouping, char const *thousands_sep)",
        "*"
      ]
    },
    "human_readable": {
      "start_point": [
        151,
        0
      ],
      "end_point": [
        387,
        1
      ],
      "content": "char *\nhuman_readable (uintmax_t n, char *buf, int opts,\n                uintmax_t from_block_size, uintmax_t to_block_size)\n{\n  int inexact_style =\n    opts & (human_round_to_nearest | human_floor | human_ceiling);\n  unsigned int base = opts & human_base_1024 ? 1024 : 1000;\n  uintmax_t amt;\n  int tenths;\n  int exponent = -1;\n  int exponent_max = sizeof power_letter - 1;\n  char *p;\n  char *psuffix;\n  char const *integerlim;\n\n  /* 0 means adjusted N == AMT.TENTHS;\n     1 means AMT.TENTHS < adjusted N < AMT.TENTHS + 0.05;\n     2 means adjusted N == AMT.TENTHS + 0.05;\n     3 means AMT.TENTHS + 0.05 < adjusted N < AMT.TENTHS + 0.1.  */\n  int rounding;\n\n  char const *decimal_point = \".\";\n  size_t decimal_pointlen = 1;\n  char const *grouping = \"\";\n  char const *thousands_sep = \"\";\n  struct lconv const *l = localeconv ();\n  size_t pointlen = strlen (l->decimal_point);\n  if (0 < pointlen && pointlen <= MB_LEN_MAX)\n    {\n      decimal_point = l->decimal_point;\n      decimal_pointlen = pointlen;\n    }\n  grouping = l->grouping;\n  if (strlen (l->thousands_sep) <= MB_LEN_MAX)\n    thousands_sep = l->thousands_sep;\n\n  psuffix = buf + LONGEST_HUMAN_READABLE - HUMAN_READABLE_SUFFIX_LENGTH_MAX;\n  p = psuffix;\n\n  /* Adjust AMT out of FROM_BLOCK_SIZE units and into TO_BLOCK_SIZE\n     units.  If this can be done exactly with integer arithmetic, do\n     not use floating point operations.  */\n  if (to_block_size <= from_block_size)\n    {\n      if (from_block_size % to_block_size == 0)\n        {\n          uintmax_t multiplier = from_block_size / to_block_size;\n          amt = n * multiplier;\n          if (amt / multiplier == n)\n            {\n              tenths = 0;\n              rounding = 0;\n              goto use_integer_arithmetic;\n            }\n        }\n    }\n  else if (from_block_size != 0 && to_block_size % from_block_size == 0)\n    {\n      uintmax_t divisor = to_block_size / from_block_size;\n      uintmax_t r10 = (n % divisor) * 10;\n      uintmax_t r2 = (r10 % divisor) * 2;\n      amt = n / divisor;\n      tenths = r10 / divisor;\n      rounding = r2 < divisor ? 0 < r2 : 2 + (divisor < r2);\n      goto use_integer_arithmetic;\n    }\n\n  {\n    /* Either the result cannot be computed easily using uintmax_t,\n       or from_block_size is zero.  Fall back on floating point.\n       FIXME: This can yield answers that are slightly off.  */\n\n    long double dto_block_size = to_block_size;\n    long double damt = n * (from_block_size / dto_block_size);\n    size_t buflen;\n    size_t nonintegerlen;\n\n    if (! (opts & human_autoscale))\n      {\n        sprintf (buf, \"%.0Lf\", adjust_value (inexact_style, damt));\n        buflen = strlen (buf);\n        nonintegerlen = 0;\n      }\n    else\n      {\n        long double e = 1;\n        exponent = 0;\n\n        do\n          {\n            e *= base;\n            exponent++;\n          }\n        while (e * base <= damt && exponent < exponent_max);\n\n        damt /= e;\n\n        sprintf (buf, \"%.1Lf\", adjust_value (inexact_style, damt));\n        buflen = strlen (buf);\n        nonintegerlen = decimal_pointlen + 1;\n\n        if (1 + nonintegerlen + ! (opts & human_base_1024) < buflen\n            || ((opts & human_suppress_point_zero)\n                && buf[buflen - 1] == '0'))\n          {\n            sprintf (buf, \"%.0Lf\",\n                     adjust_value (inexact_style, damt * 10) / 10);\n            buflen = strlen (buf);\n            nonintegerlen = 0;\n          }\n      }\n\n    p = psuffix - buflen;\n    memmove (p, buf, buflen);\n    integerlim = p + buflen - nonintegerlen;\n  }\n  goto do_grouping;\n\n use_integer_arithmetic:\n  {\n    /* The computation can be done exactly, with integer arithmetic.\n\n       Use power of BASE notation if requested and if adjusted AMT is\n       large enough.  */\n\n    if (opts & human_autoscale)\n      {\n        exponent = 0;\n\n        if (base <= amt)\n          {\n            do\n              {\n                unsigned int r10 = (amt % base) * 10 + tenths;\n                unsigned int r2 = (r10 % base) * 2 + (rounding >> 1);\n                amt /= base;\n                tenths = r10 / base;\n                rounding = (r2 < base\n                            ? (r2 + rounding) != 0\n                            : 2 + (base < r2 + rounding));\n                exponent++;\n              }\n            while (base <= amt && exponent < exponent_max);\n\n            if (amt < 10)\n              {\n                if (inexact_style == human_round_to_nearest\n                    ? 2 < rounding + (tenths & 1)\n                    : inexact_style == human_ceiling && 0 < rounding)\n                  {\n                    tenths++;\n                    rounding = 0;\n\n                    if (tenths == 10)\n                      {\n                        amt++;\n                        tenths = 0;\n                      }\n                  }\n\n                if (amt < 10\n                    && (tenths || ! (opts & human_suppress_point_zero)))\n                  {\n                    *--p = '0' + tenths;\n                    p -= decimal_pointlen;\n                    memcpy (p, decimal_point, decimal_pointlen);\n                    tenths = rounding = 0;\n                  }\n              }\n          }\n      }\n\n    if (inexact_style == human_round_to_nearest\n        ? 5 < tenths + (0 < rounding + (amt & 1))\n        : inexact_style == human_ceiling && 0 < tenths + rounding)\n      {\n        amt++;\n\n        if ((opts & human_autoscale)\n            && amt == base && exponent < exponent_max)\n          {\n            exponent++;\n            if (! (opts & human_suppress_point_zero))\n              {\n                *--p = '0';\n                p -= decimal_pointlen;\n                memcpy (p, decimal_point, decimal_pointlen);\n              }\n            amt = 1;\n          }\n      }\n\n    integerlim = p;\n\n    do\n      {\n        int digit = amt % 10;\n        *--p = digit + '0';\n      }\n    while ((amt /= 10) != 0);\n  }\n\n do_grouping:\n  if (opts & human_group_digits)\n    p = group_number (p, integerlim - p, grouping, thousands_sep);\n\n  if (opts & human_SI)\n    {\n      if (exponent < 0)\n        {\n          uintmax_t power;\n          exponent = 0;\n          for (power = 1; power < to_block_size; power *= base)\n            if (++exponent == exponent_max)\n              break;\n        }\n\n      if ((exponent | (opts & human_B)) && (opts & human_space_before_unit))\n        *psuffix++ = ' ';\n\n      if (exponent)\n        *psuffix++ = (! (opts & human_base_1024) && exponent == 1\n                      ? 'k'\n                      : power_letter[exponent]);\n\n      if (opts & human_B)\n        {\n          if ((opts & human_base_1024) && exponent)\n            *psuffix++ = 'i';\n          *psuffix++ = 'B';\n        }\n    }\n\n  *psuffix = '\\0';\n\n  return p;\n}",
      "lines": 237,
      "depth": 19,
      "decorators": [
        "char",
        "*\nhuman_readable (uintmax_t n, char *buf, int opts,\n                uintmax_t from_block_size, uintmax_t to_block_size)",
        "*"
      ]
    },
    "default_block_size": {
      "start_point": [
        403,
        0
      ],
      "end_point": [
        407,
        1
      ],
      "content": "static uintmax_t\ndefault_block_size (void)\n{\n  return getenv (\"POSIXLY_CORRECT\") ? 512 : DEFAULT_BLOCK_SIZE;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "uintmax_t"
      ]
    },
    "humblock": {
      "start_point": [
        409,
        0
      ],
      "end_point": [
        457,
        1
      ],
      "content": "static strtol_error\nhumblock (char const *spec, uintmax_t *block_size, int *options)\n{\n  int i;\n  int opts = 0;\n\n  if (! spec\n      && ! (spec = getenv (\"BLOCK_SIZE\"))\n      && ! (spec = getenv (\"BLOCKSIZE\")))\n    *block_size = default_block_size ();\n  else\n    {\n      if (*spec == '\\'')\n        {\n          opts |= human_group_digits;\n          spec++;\n        }\n\n      if (0 <= (i = ARGMATCH (spec, block_size_args, block_size_opts)))\n        {\n          opts |= block_size_opts[i];\n          *block_size = 1;\n        }\n      else\n        {\n          char *ptr;\n          strtol_error e = xstrtoumax (spec, &ptr, 0, block_size,\n                                       \"eEgGkKmMpPtTyYzZ0\");\n          if (e != LONGINT_OK)\n            {\n              *options = 0;\n              return e;\n            }\n          for (; ! ('0' <= *spec && *spec <= '9'); spec++)\n            if (spec == ptr)\n              {\n                opts |= human_SI;\n                if (ptr[-1] == 'B')\n                  opts |= human_B;\n                if (ptr[-1] != 'B' || ptr[-2] == 'i')\n                  opts |= human_base_1024;\n                break;\n              }\n        }\n    }\n\n  *options = opts;\n  return LONGINT_OK;\n}",
      "lines": 49,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "strtol_error"
      ]
    },
    "human_options": {
      "start_point": [
        459,
        0
      ],
      "end_point": [
        469,
        1
      ],
      "content": "enum strtol_error\nhuman_options (char const *spec, int *opts, uintmax_t *block_size)\n{\n  strtol_error e = humblock (spec, block_size, opts);\n  if (*block_size == 0)\n    {\n      *block_size = default_block_size ();\n      e = LONGINT_INVALID;\n    }\n  return e;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "enum strtol_error",
        "enum",
        "strtol_error"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/human.h": {},
  "findutils/findutils-4.6.0/gl/lib/i-ring.c": {
    "i_ring_init": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        33,
        1
      ],
      "content": "void\ni_ring_init (I_ring *ir, int default_val)\n{\n  int i;\n  ir->ir_empty = true;\n  ir->ir_front = 0;\n  ir->ir_back = 0;\n  for (i = 0; i < I_RING_SIZE; i++)\n    ir->ir_data[i] = default_val;\n  ir->ir_default_val = default_val;\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "i_ring_empty": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        39,
        1
      ],
      "content": "bool\ni_ring_empty (I_ring const *ir)\n{\n  return ir->ir_empty;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "bool"
      ]
    },
    "i_ring_push": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "int\ni_ring_push (I_ring *ir, int val)\n{\n  unsigned int dest_idx = (ir->ir_front + !ir->ir_empty) % I_RING_SIZE;\n  int old_val = ir->ir_data[dest_idx];\n  ir->ir_data[dest_idx] = val;\n  ir->ir_front = dest_idx;\n  if (dest_idx == ir->ir_back)\n    ir->ir_back = (ir->ir_back + !ir->ir_empty) % I_RING_SIZE;\n  ir->ir_empty = false;\n  return old_val;\n}",
      "lines": 12,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "i_ring_pop": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "int\ni_ring_pop (I_ring *ir)\n{\n  int top_val;\n  if (i_ring_empty (ir))\n    abort ();\n  top_val = ir->ir_data[ir->ir_front];\n  ir->ir_data[ir->ir_front] = ir->ir_default_val;\n  if (ir->ir_front == ir->ir_back)\n    ir->ir_empty = true;\n  else\n    ir->ir_front = ((ir->ir_front + I_RING_SIZE - 1) % I_RING_SIZE);\n  return top_val;\n}",
      "lines": 14,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/i-ring.h": {},
  "findutils/findutils-4.6.0/gl/lib/idcache.c": {
    "getuser": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        95,
        1
      ],
      "content": "char *\ngetuser (uid_t uid)\n{\n  struct userid *tail;\n  struct userid *match = NULL;\n\n  for (tail = user_alist; tail; tail = tail->next)\n    {\n      if (tail->id.u == uid)\n        {\n          match = tail;\n          break;\n        }\n    }\n\n  if (match == NULL)\n    {\n      struct passwd *pwent = getpwuid (uid);\n      char const *name = pwent ? pwent->pw_name : \"\";\n      match = xmalloc (offsetof (struct userid, name) + strlen (name) + 1);\n      match->id.u = uid;\n      strcpy (match->name, name);\n\n      /* Add to the head of the list, so most recently used is first.  */\n      match->next = user_alist;\n      user_alist = match;\n    }\n\n  return match->name[0] ? match->name : NULL;\n}",
      "lines": 30,
      "depth": 14,
      "decorators": [
        "char",
        "*\ngetuser (uid_t uid)",
        "*"
      ]
    },
    "getuidbyname": {
      "start_point": [
        102,
        0
      ],
      "end_point": [
        144,
        1
      ],
      "content": "uid_t *\ngetuidbyname (const char *user)\n{\n  struct userid *tail;\n  struct passwd *pwent;\n\n  for (tail = user_alist; tail; tail = tail->next)\n    /* Avoid a function call for the most common case.  */\n    if (*tail->name == *user && !strcmp (tail->name, user))\n      return &tail->id.u;\n\n  for (tail = nouser_alist; tail; tail = tail->next)\n    /* Avoid a function call for the most common case.  */\n    if (*tail->name == *user && !strcmp (tail->name, user))\n      return NULL;\n\n  pwent = getpwnam (user);\n#ifdef __DJGPP__\n  /* We need to pretend to be the user USER, to make\n     pwd functions know about an arbitrary user name.  */\n  if (!pwent && strspn (user, digits) < strlen (user))\n    {\n      setenv (\"USER\", user, 1);\n      pwent = getpwnam (user);  /* now it will succeed */\n    }\n#endif\n\n  tail = xmalloc (offsetof (struct userid, name) + strlen (user) + 1);\n  strcpy (tail->name, user);\n\n  /* Add to the head of the list, so most recently used is first.  */\n  if (pwent)\n    {\n      tail->id.u = pwent->pw_uid;\n      tail->next = user_alist;\n      user_alist = tail;\n      return &tail->id.u;\n    }\n\n  tail->next = nouser_alist;\n  nouser_alist = tail;\n  return NULL;\n}",
      "lines": 43,
      "depth": 12,
      "decorators": [
        "uid_t",
        "*\ngetuidbyname (const char *user)",
        "*"
      ]
    },
    "getgroup": {
      "start_point": [
        148,
        0
      ],
      "end_point": [
        177,
        1
      ],
      "content": "char *\ngetgroup (gid_t gid)\n{\n  struct userid *tail;\n  struct userid *match = NULL;\n\n  for (tail = group_alist; tail; tail = tail->next)\n    {\n      if (tail->id.g == gid)\n        {\n          match = tail;\n          break;\n        }\n    }\n\n  if (match == NULL)\n    {\n      struct group *grent = getgrgid (gid);\n      char const *name = grent ? grent->gr_name : \"\";\n      match = xmalloc (offsetof (struct userid, name) + strlen (name) + 1);\n      match->id.g = gid;\n      strcpy (match->name, name);\n\n      /* Add to the head of the list, so most recently used is first.  */\n      match->next = group_alist;\n      group_alist = match;\n    }\n\n  return match->name[0] ? match->name : NULL;\n}",
      "lines": 30,
      "depth": 14,
      "decorators": [
        "char",
        "*\ngetgroup (gid_t gid)",
        "*"
      ]
    },
    "getgidbyname": {
      "start_point": [
        184,
        0
      ],
      "end_point": [
        226,
        1
      ],
      "content": "gid_t *\ngetgidbyname (const char *group)\n{\n  struct userid *tail;\n  struct group *grent;\n\n  for (tail = group_alist; tail; tail = tail->next)\n    /* Avoid a function call for the most common case.  */\n    if (*tail->name == *group && !strcmp (tail->name, group))\n      return &tail->id.g;\n\n  for (tail = nogroup_alist; tail; tail = tail->next)\n    /* Avoid a function call for the most common case.  */\n    if (*tail->name == *group && !strcmp (tail->name, group))\n      return NULL;\n\n  grent = getgrnam (group);\n#ifdef __DJGPP__\n  /* We need to pretend to belong to group GROUP, to make\n     grp functions know about an arbitrary group name.  */\n  if (!grent && strspn (group, digits) < strlen (group))\n    {\n      setenv (\"GROUP\", group, 1);\n      grent = getgrnam (group); /* now it will succeed */\n    }\n#endif\n\n  tail = xmalloc (offsetof (struct userid, name) + strlen (group) + 1);\n  strcpy (tail->name, group);\n\n  /* Add to the head of the list, so most recently used is first.  */\n  if (grent)\n    {\n      tail->id.g = grent->gr_gid;\n      tail->next = group_alist;\n      group_alist = tail;\n      return &tail->id.g;\n    }\n\n  tail->next = nogroup_alist;\n  nogroup_alist = tail;\n  return NULL;\n}",
      "lines": 43,
      "depth": 12,
      "decorators": [
        "gid_t",
        "*\ngetgidbyname (const char *group)",
        "*"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/idcache.h": {},
  "findutils/findutils-4.6.0/gl/lib/intprops.h": {},
  "findutils/findutils-4.6.0/gl/lib/inttypes.in.h": {},
  "findutils/findutils-4.6.0/gl/lib/isblank.c": {
    "isblank": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        32,
        1
      ],
      "content": "int\nisblank (int c)\n{\n  /* On all known platforms, in all predefined locales, isblank(c) is likely\n     equivalent with  (c == ' ' || c == '\\t').  Look at the glibc definition\n     (in glibc/localedata/locales/i18n): The \"blank\" characters are '\\t', ' ',\n     U+1680, U+180E, U+2000..U+2006, U+2008..U+200A, U+205F, U+3000, and none\n     except the first two is present in a common 8-bit encoding.  Therefore\n     the substitute for other platforms is not more complicated than this.  */\n  return (c == ' ' || c == '\\t');\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/isfinite.c": {
    "gl_isfinitef": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "int gl_isfinitef (float x)\n{\n  return !isnanf (x) && x - x == zerof;\n}",
      "lines": 4,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "gl_isfinited": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "int gl_isfinited (double x)\n{\n  return !isnand (x) && x - x == zerod;\n}",
      "lines": 4,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "gl_isfinitel": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "int gl_isfinitel (long double x)\n{\n  return !isnanl (x) && x - x == zerol;\n}",
      "lines": 4,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/isinf.c": {
    "gl_isinff": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        26,
        1
      ],
      "content": "int\ngl_isinff (float x)\n{\n  return x < -FLT_MAX || x > FLT_MAX;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "gl_isinfd": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        32,
        1
      ],
      "content": "int\ngl_isinfd (double x)\n{\n  return x < -DBL_MAX || x > DBL_MAX;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "gl_isinfl": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "int\ngl_isinfl (long double x)\n{\n  return x < -LDBL_MAX || x > LDBL_MAX;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/isnan.c": {
    "FUNC": {
      "start_point": [
        92,
        0
      ],
      "end_point": [
        188,
        1
      ],
      "content": "int\nFUNC (DOUBLE x)\n{\n#if defined KNOWN_EXPBIT0_LOCATION && IEEE_FLOATING_POINT\n# if defined USE_LONG_DOUBLE && ((defined __ia64 && LDBL_MANT_DIG == 64) || (defined __x86_64__ || defined __amd64__) || (defined __i386 || defined __i386__ || defined _I386 || defined _M_IX86 || defined _X86_)) && !HAVE_SAME_LONG_DOUBLE_AS_DOUBLE\n  /* Special CPU dependent code is needed to treat bit patterns outside the\n     IEEE 754 specification (such as Pseudo-NaNs, Pseudo-Infinities,\n     Pseudo-Zeroes, Unnormalized Numbers, and Pseudo-Denormals) as NaNs.\n     These bit patterns are:\n       - exponent = 0x0001..0x7FFF, mantissa bit 63 = 0,\n       - exponent = 0x0000, mantissa bit 63 = 1.\n     The NaN bit pattern is:\n       - exponent = 0x7FFF, mantissa >= 0x8000000000000001.  */\n  memory_double m;\n  unsigned int exponent;\n\n  m.value = x;\n  exponent = (m.word[EXPBIT0_WORD] >> EXPBIT0_BIT) & EXP_MASK;\n#  ifdef WORDS_BIGENDIAN\n  /* Big endian: EXPBIT0_WORD = 0, EXPBIT0_BIT = 16.  */\n  if (exponent == 0)\n    return 1 & (m.word[0] >> 15);\n  else if (exponent == EXP_MASK)\n    return (((m.word[0] ^ 0x8000U) << 16) | m.word[1] | (m.word[2] >> 16)) != 0;\n  else\n    return 1 & ~(m.word[0] >> 15);\n#  else\n  /* Little endian: EXPBIT0_WORD = 2, EXPBIT0_BIT = 0.  */\n  if (exponent == 0)\n    return (m.word[1] >> 31);\n  else if (exponent == EXP_MASK)\n    return ((m.word[1] ^ 0x80000000U) | m.word[0]) != 0;\n  else\n    return (m.word[1] >> 31) ^ 1;\n#  endif\n# else\n  /* Be careful to not do any floating-point operation on x, such as x == x,\n     because x may be a signaling NaN.  */\n#  if defined __SUNPRO_C || defined __ICC || defined _MSC_VER \\\n      || defined __DECC || defined __TINYC__ \\\n      || (defined __sgi && !defined __GNUC__)\n  /* The Sun C 5.0, Intel ICC 10.0, Microsoft Visual C/C++ 9.0, Compaq (ex-DEC)\n     6.4, and TinyCC compilers don't recognize the initializers as constant\n     expressions.  The Compaq compiler also fails when constant-folding\n     0.0 / 0.0 even when constant-folding is not required.  The Microsoft\n     Visual C/C++ compiler also fails when constant-folding 1.0 / 0.0 even\n     when constant-folding is not required. The SGI MIPSpro C compiler\n     complains about \"floating-point operation result is out of range\".  */\n  static DOUBLE zero = L_(0.0);\n  memory_double nan;\n  DOUBLE plus_inf = L_(1.0) / zero;\n  DOUBLE minus_inf = -L_(1.0) / zero;\n  nan.value = zero / zero;\n#  else\n  static memory_double nan = { L_(0.0) / L_(0.0) };\n  static DOUBLE plus_inf = L_(1.0) / L_(0.0);\n  static DOUBLE minus_inf = -L_(1.0) / L_(0.0);\n#  endif\n  {\n    memory_double m;\n\n    /* A NaN can be recognized through its exponent.  But exclude +Infinity and\n       -Infinity, which have the same exponent.  */\n    m.value = x;\n    if (((m.word[EXPBIT0_WORD] ^ nan.word[EXPBIT0_WORD])\n         & (EXP_MASK << EXPBIT0_BIT))\n        == 0)\n      return (memcmp (&m.value, &plus_inf, SIZE) != 0\n              && memcmp (&m.value, &minus_inf, SIZE) != 0);\n    else\n      return 0;\n  }\n# endif\n#else\n  /* The configuration did not find sufficient information, or does\n     not use IEEE floating point.  Give up about the signaling NaNs;\n     handle only the quiet NaNs.  */\n  if (x == x)\n    {\n# if defined USE_LONG_DOUBLE && ((defined __ia64 && LDBL_MANT_DIG == 64) || (defined __x86_64__ || defined __amd64__) || (defined __i386 || defined __i386__ || defined _I386 || defined _M_IX86 || defined _X86_)) && !HAVE_SAME_LONG_DOUBLE_AS_DOUBLE\n      /* Detect any special bit patterns that pass ==; see comment above.  */\n      memory_double m1;\n      memory_double m2;\n\n      memset (&m1.value, 0, SIZE);\n      memset (&m2.value, 0, SIZE);\n      m1.value = x;\n      m2.value = x + (x ? 0.0L : -0.0L);\n      if (memcmp (&m1.value, &m2.value, SIZE) != 0)\n        return 1;\n# endif\n      return 0;\n    }\n  else\n    return 1;\n#endif\n}",
      "lines": 97,
      "depth": 19,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/isnand-nolibm.h": {},
  "findutils/findutils-4.6.0/gl/lib/isnand.c": {},
  "findutils/findutils-4.6.0/gl/lib/isnanf-nolibm.h": {},
  "findutils/findutils-4.6.0/gl/lib/isnanf.c": {},
  "findutils/findutils-4.6.0/gl/lib/isnanl-nolibm.h": {},
  "findutils/findutils-4.6.0/gl/lib/isnanl.c": {},
  "findutils/findutils-4.6.0/gl/lib/iswblank.c": {
    "iswblank": {
      "start_point": [
        21,
        0
      ],
      "end_point": [
        25,
        1
      ],
      "content": "int\niswblank (wint_t wc)\n{\n  return wc == ' ' || wc == '\\t';\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/itold.c": {
    "_Qp_itoq": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        27,
        1
      ],
      "content": "void\n_Qp_itoq (long double *result, int a)\n{\n  /* Convert from 'int' to 'double', then from 'double' to 'long double'.  */\n  *result = (double) a;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/langinfo.in.h": {},
  "findutils/findutils-4.6.0/gl/lib/localcharset.c": {
    "get_charset_aliases": {
      "start_point": [
        122,
        0
      ],
      "end_point": [
        380,
        1
      ],
      "content": "static const char *\nget_charset_aliases (void)\n{\n  const char *cp;\n\n  cp = charset_aliases;\n  if (cp == NULL)\n    {\n#if !(defined DARWIN7 || defined VMS || defined WINDOWS_NATIVE || defined __CYGWIN__ || defined OS2)\n      const char *dir;\n      const char *base = \"charset.alias\";\n      char *file_name;\n\n      /* Make it possible to override the charset.alias location.  This is\n         necessary for running the testsuite before \"make install\".  */\n      dir = getenv (\"CHARSETALIASDIR\");\n      if (dir == NULL || dir[0] == '\\0')\n        dir = relocate (LIBDIR);\n\n      /* Concatenate dir and base into freshly allocated file_name.  */\n      {\n        size_t dir_len = strlen (dir);\n        size_t base_len = strlen (base);\n        int add_slash = (dir_len > 0 && !ISSLASH (dir[dir_len - 1]));\n        file_name = (char *) malloc (dir_len + add_slash + base_len + 1);\n        if (file_name != NULL)\n          {\n            memcpy (file_name, dir, dir_len);\n            if (add_slash)\n              file_name[dir_len] = DIRECTORY_SEPARATOR;\n            memcpy (file_name + dir_len + add_slash, base, base_len + 1);\n          }\n      }\n\n      if (file_name == NULL)\n        /* Out of memory.  Treat the file as empty.  */\n        cp = \"\";\n      else\n        {\n          int fd;\n\n          /* Open the file.  Reject symbolic links on platforms that support\n             O_NOFOLLOW.  This is a security feature.  Without it, an attacker\n             could retrieve parts of the contents (namely, the tail of the\n             first line that starts with \"* \") of an arbitrary file by placing\n             a symbolic link to that file under the name \"charset.alias\" in\n             some writable directory and defining the environment variable\n             CHARSETALIASDIR to point to that directory.  */\n          fd = open (file_name,\n                     O_RDONLY | (HAVE_WORKING_O_NOFOLLOW ? O_NOFOLLOW : 0));\n          if (fd < 0)\n            /* File not found.  Treat it as empty.  */\n            cp = \"\";\n          else\n            {\n              FILE *fp;\n\n              fp = fdopen (fd, \"r\");\n              if (fp == NULL)\n                {\n                  /* Out of memory.  Treat the file as empty.  */\n                  close (fd);\n                  cp = \"\";\n                }\n              else\n                {\n                  /* Parse the file's contents.  */\n                  char *res_ptr = NULL;\n                  size_t res_size = 0;\n\n                  for (;;)\n                    {\n                      int c;\n                      char buf1[50+1];\n                      char buf2[50+1];\n                      size_t l1, l2;\n                      char *old_res_ptr;\n\n                      c = getc (fp);\n                      if (c == EOF)\n                        break;\n                      if (c == '\\n' || c == ' ' || c == '\\t')\n                        continue;\n                      if (c == '#')\n                        {\n                          /* Skip comment, to end of line.  */\n                          do\n                            c = getc (fp);\n                          while (!(c == EOF || c == '\\n'));\n                          if (c == EOF)\n                            break;\n                          continue;\n                        }\n                      ungetc (c, fp);\n                      if (fscanf (fp, \"%50s %50s\", buf1, buf2) < 2)\n                        break;\n                      l1 = strlen (buf1);\n                      l2 = strlen (buf2);\n                      old_res_ptr = res_ptr;\n                      if (res_size == 0)\n                        {\n                          res_size = l1 + 1 + l2 + 1;\n                          res_ptr = (char *) malloc (res_size + 1);\n                        }\n                      else\n                        {\n                          res_size += l1 + 1 + l2 + 1;\n                          res_ptr = (char *) realloc (res_ptr, res_size + 1);\n                        }\n                      if (res_ptr == NULL)\n                        {\n                          /* Out of memory. */\n                          res_size = 0;\n                          free (old_res_ptr);\n                          break;\n                        }\n                      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);\n                      strcpy (res_ptr + res_size - (l2 + 1), buf2);\n                    }\n                  fclose (fp);\n                  if (res_size == 0)\n                    cp = \"\";\n                  else\n                    {\n                      *(res_ptr + res_size) = '\\0';\n                      cp = res_ptr;\n                    }\n                }\n            }\n\n          free (file_name);\n        }\n\n#else\n\n# if defined DARWIN7\n      /* To avoid the trouble of installing a file that is shared by many\n         GNU packages -- many packaging systems have problems with this --,\n         simply inline the aliases here.  */\n      cp = \"ISO8859-1\" \"\\0\" \"ISO-8859-1\" \"\\0\"\n           \"ISO8859-2\" \"\\0\" \"ISO-8859-2\" \"\\0\"\n           \"ISO8859-4\" \"\\0\" \"ISO-8859-4\" \"\\0\"\n           \"ISO8859-5\" \"\\0\" \"ISO-8859-5\" \"\\0\"\n           \"ISO8859-7\" \"\\0\" \"ISO-8859-7\" \"\\0\"\n           \"ISO8859-9\" \"\\0\" \"ISO-8859-9\" \"\\0\"\n           \"ISO8859-13\" \"\\0\" \"ISO-8859-13\" \"\\0\"\n           \"ISO8859-15\" \"\\0\" \"ISO-8859-15\" \"\\0\"\n           \"KOI8-R\" \"\\0\" \"KOI8-R\" \"\\0\"\n           \"KOI8-U\" \"\\0\" \"KOI8-U\" \"\\0\"\n           \"CP866\" \"\\0\" \"CP866\" \"\\0\"\n           \"CP949\" \"\\0\" \"CP949\" \"\\0\"\n           \"CP1131\" \"\\0\" \"CP1131\" \"\\0\"\n           \"CP1251\" \"\\0\" \"CP1251\" \"\\0\"\n           \"eucCN\" \"\\0\" \"GB2312\" \"\\0\"\n           \"GB2312\" \"\\0\" \"GB2312\" \"\\0\"\n           \"eucJP\" \"\\0\" \"EUC-JP\" \"\\0\"\n           \"eucKR\" \"\\0\" \"EUC-KR\" \"\\0\"\n           \"Big5\" \"\\0\" \"BIG5\" \"\\0\"\n           \"Big5HKSCS\" \"\\0\" \"BIG5-HKSCS\" \"\\0\"\n           \"GBK\" \"\\0\" \"GBK\" \"\\0\"\n           \"GB18030\" \"\\0\" \"GB18030\" \"\\0\"\n           \"SJIS\" \"\\0\" \"SHIFT_JIS\" \"\\0\"\n           \"ARMSCII-8\" \"\\0\" \"ARMSCII-8\" \"\\0\"\n           \"PT154\" \"\\0\" \"PT154\" \"\\0\"\n         /*\"ISCII-DEV\" \"\\0\" \"?\" \"\\0\"*/\n           \"*\" \"\\0\" \"UTF-8\" \"\\0\";\n# endif\n\n# if defined VMS\n      /* To avoid the troubles of an extra file charset.alias_vms in the\n         sources of many GNU packages, simply inline the aliases here.  */\n      /* The list of encodings is taken from the OpenVMS 7.3-1 documentation\n         \"Compaq C Run-Time Library Reference Manual for OpenVMS systems\"\n         section 10.7 \"Handling Different Character Sets\".  */\n      cp = \"ISO8859-1\" \"\\0\" \"ISO-8859-1\" \"\\0\"\n           \"ISO8859-2\" \"\\0\" \"ISO-8859-2\" \"\\0\"\n           \"ISO8859-5\" \"\\0\" \"ISO-8859-5\" \"\\0\"\n           \"ISO8859-7\" \"\\0\" \"ISO-8859-7\" \"\\0\"\n           \"ISO8859-8\" \"\\0\" \"ISO-8859-8\" \"\\0\"\n           \"ISO8859-9\" \"\\0\" \"ISO-8859-9\" \"\\0\"\n           /* Japanese */\n           \"eucJP\" \"\\0\" \"EUC-JP\" \"\\0\"\n           \"SJIS\" \"\\0\" \"SHIFT_JIS\" \"\\0\"\n           \"DECKANJI\" \"\\0\" \"DEC-KANJI\" \"\\0\"\n           \"SDECKANJI\" \"\\0\" \"EUC-JP\" \"\\0\"\n           /* Chinese */\n           \"eucTW\" \"\\0\" \"EUC-TW\" \"\\0\"\n           \"DECHANYU\" \"\\0\" \"DEC-HANYU\" \"\\0\"\n           \"DECHANZI\" \"\\0\" \"GB2312\" \"\\0\"\n           /* Korean */\n           \"DECKOREAN\" \"\\0\" \"EUC-KR\" \"\\0\";\n# endif\n\n# if defined WINDOWS_NATIVE || defined __CYGWIN__\n      /* To avoid the troubles of installing a separate file in the same\n         directory as the DLL and of retrieving the DLL's directory at\n         runtime, simply inline the aliases here.  */\n\n      cp = \"CP936\" \"\\0\" \"GBK\" \"\\0\"\n           \"CP1361\" \"\\0\" \"JOHAB\" \"\\0\"\n           \"CP20127\" \"\\0\" \"ASCII\" \"\\0\"\n           \"CP20866\" \"\\0\" \"KOI8-R\" \"\\0\"\n           \"CP20936\" \"\\0\" \"GB2312\" \"\\0\"\n           \"CP21866\" \"\\0\" \"KOI8-RU\" \"\\0\"\n           \"CP28591\" \"\\0\" \"ISO-8859-1\" \"\\0\"\n           \"CP28592\" \"\\0\" \"ISO-8859-2\" \"\\0\"\n           \"CP28593\" \"\\0\" \"ISO-8859-3\" \"\\0\"\n           \"CP28594\" \"\\0\" \"ISO-8859-4\" \"\\0\"\n           \"CP28595\" \"\\0\" \"ISO-8859-5\" \"\\0\"\n           \"CP28596\" \"\\0\" \"ISO-8859-6\" \"\\0\"\n           \"CP28597\" \"\\0\" \"ISO-8859-7\" \"\\0\"\n           \"CP28598\" \"\\0\" \"ISO-8859-8\" \"\\0\"\n           \"CP28599\" \"\\0\" \"ISO-8859-9\" \"\\0\"\n           \"CP28605\" \"\\0\" \"ISO-8859-15\" \"\\0\"\n           \"CP38598\" \"\\0\" \"ISO-8859-8\" \"\\0\"\n           \"CP51932\" \"\\0\" \"EUC-JP\" \"\\0\"\n           \"CP51936\" \"\\0\" \"GB2312\" \"\\0\"\n           \"CP51949\" \"\\0\" \"EUC-KR\" \"\\0\"\n           \"CP51950\" \"\\0\" \"EUC-TW\" \"\\0\"\n           \"CP54936\" \"\\0\" \"GB18030\" \"\\0\"\n           \"CP65001\" \"\\0\" \"UTF-8\" \"\\0\";\n# endif\n# if defined OS2\n      /* To avoid the troubles of installing a separate file in the same\n         directory as the DLL and of retrieving the DLL's directory at\n         runtime, simply inline the aliases here.  */\n\n      /* The list of encodings is taken from \"List of OS/2 Codepages\"\n         by Alex Taylor:\n         <http://altsan.org/os2/toolkits/uls/index.html#codepages>.\n         See also \"IBM Globalization - Code page identifiers\":\n         <http://www-01.ibm.com/software/globalization/cp/cp_cpgid.html>.  */\n      cp = \"CP813\" \"\\0\" \"ISO-8859-7\" \"\\0\"\n           \"CP878\" \"\\0\" \"KOI8-R\" \"\\0\"\n           \"CP819\" \"\\0\" \"ISO-8859-1\" \"\\0\"\n           \"CP912\" \"\\0\" \"ISO-8859-2\" \"\\0\"\n           \"CP913\" \"\\0\" \"ISO-8859-3\" \"\\0\"\n           \"CP914\" \"\\0\" \"ISO-8859-4\" \"\\0\"\n           \"CP915\" \"\\0\" \"ISO-8859-5\" \"\\0\"\n           \"CP916\" \"\\0\" \"ISO-8859-8\" \"\\0\"\n           \"CP920\" \"\\0\" \"ISO-8859-9\" \"\\0\"\n           \"CP921\" \"\\0\" \"ISO-8859-13\" \"\\0\"\n           \"CP923\" \"\\0\" \"ISO-8859-15\" \"\\0\"\n           \"CP954\" \"\\0\" \"EUC-JP\" \"\\0\"\n           \"CP964\" \"\\0\" \"EUC-TW\" \"\\0\"\n           \"CP970\" \"\\0\" \"EUC-KR\" \"\\0\"\n           \"CP1089\" \"\\0\" \"ISO-8859-6\" \"\\0\"\n           \"CP1208\" \"\\0\" \"UTF-8\" \"\\0\"\n           \"CP1381\" \"\\0\" \"GB2312\" \"\\0\"\n           \"CP1386\" \"\\0\" \"GBK\" \"\\0\"\n           \"CP3372\" \"\\0\" \"EUC-JP\" \"\\0\";\n# endif\n#endif\n\n      charset_aliases = cp;\n    }\n\n  return cp;\n}",
      "lines": 259,
      "depth": 23,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nget_charset_aliases (void)",
        "*"
      ]
    },
    "locale_charset": {
      "start_point": [
        391,
        0
      ],
      "end_point": [
        612,
        1
      ],
      "content": "const char *\nlocale_charset (void)\n{\n  const char *codeset;\n  const char *aliases;\n\n#if !(defined WINDOWS_NATIVE || defined OS2)\n\n# if HAVE_LANGINFO_CODESET\n\n  /* Most systems support nl_langinfo (CODESET) nowadays.  */\n  codeset = nl_langinfo (CODESET);\n\n#  ifdef __CYGWIN__\n  /* Cygwin < 1.7 does not have locales.  nl_langinfo (CODESET) always\n     returns \"US-ASCII\".  Return the suffix of the locale name from the\n     environment variables (if present) or the codepage as a number.  */\n  if (codeset != NULL && strcmp (codeset, \"US-ASCII\") == 0)\n    {\n      const char *locale;\n      static char buf[2 + 10 + 1];\n\n      locale = getenv (\"LC_ALL\");\n      if (locale == NULL || locale[0] == '\\0')\n        {\n          locale = getenv (\"LC_CTYPE\");\n          if (locale == NULL || locale[0] == '\\0')\n            locale = getenv (\"LANG\");\n        }\n      if (locale != NULL && locale[0] != '\\0')\n        {\n          /* If the locale name contains an encoding after the dot, return\n             it.  */\n          const char *dot = strchr (locale, '.');\n\n          if (dot != NULL)\n            {\n              const char *modifier;\n\n              dot++;\n              /* Look for the possible @... trailer and remove it, if any.  */\n              modifier = strchr (dot, '@');\n              if (modifier == NULL)\n                return dot;\n              if (modifier - dot < sizeof (buf))\n                {\n                  memcpy (buf, dot, modifier - dot);\n                  buf [modifier - dot] = '\\0';\n                  return buf;\n                }\n            }\n        }\n\n      /* The Windows API has a function returning the locale's codepage as a\n         number: GetACP().  This encoding is used by Cygwin, unless the user\n         has set the environment variable CYGWIN=codepage:oem (which very few\n         people do).\n         Output directed to console windows needs to be converted (to\n         GetOEMCP() if the console is using a raster font, or to\n         GetConsoleOutputCP() if it is using a TrueType font).  Cygwin does\n         this conversion transparently (see winsup/cygwin/fhandler_console.cc),\n         converting to GetConsoleOutputCP().  This leads to correct results,\n         except when SetConsoleOutputCP has been called and a raster font is\n         in use.  */\n      sprintf (buf, \"CP%u\", GetACP ());\n      codeset = buf;\n    }\n#  endif\n\n# else\n\n  /* On old systems which lack it, use setlocale or getenv.  */\n  const char *locale = NULL;\n\n  /* But most old systems don't have a complete set of locales.  Some\n     (like SunOS 4 or DJGPP) have only the C locale.  Therefore we don't\n     use setlocale here; it would return \"C\" when it doesn't support the\n     locale name the user has set.  */\n#  if 0\n  locale = setlocale (LC_CTYPE, NULL);\n#  endif\n  if (locale == NULL || locale[0] == '\\0')\n    {\n      locale = getenv (\"LC_ALL\");\n      if (locale == NULL || locale[0] == '\\0')\n        {\n          locale = getenv (\"LC_CTYPE\");\n          if (locale == NULL || locale[0] == '\\0')\n            locale = getenv (\"LANG\");\n        }\n    }\n\n  /* On some old systems, one used to set locale = \"iso8859_1\". On others,\n     you set it to \"language_COUNTRY.charset\". In any case, we resolve it\n     through the charset.alias file.  */\n  codeset = locale;\n\n# endif\n\n#elif defined WINDOWS_NATIVE\n\n  static char buf[2 + 10 + 1];\n\n  /* The Windows API has a function returning the locale's codepage as\n     a number, but the value doesn't change according to what the\n     'setlocale' call specified.  So we use it as a last resort, in\n     case the string returned by 'setlocale' doesn't specify the\n     codepage.  */\n  char *current_locale = setlocale (LC_ALL, NULL);\n  char *pdot;\n\n  /* If they set different locales for different categories,\n     'setlocale' will return a semi-colon separated list of locale\n     values.  To make sure we use the correct one, we choose LC_CTYPE.  */\n  if (strchr (current_locale, ';'))\n    current_locale = setlocale (LC_CTYPE, NULL);\n\n  pdot = strrchr (current_locale, '.');\n  if (pdot)\n    sprintf (buf, \"CP%s\", pdot + 1);\n  else\n    {\n      /* The Windows API has a function returning the locale's codepage as a\n        number: GetACP().\n        When the output goes to a console window, it needs to be provided in\n        GetOEMCP() encoding if the console is using a raster font, or in\n        GetConsoleOutputCP() encoding if it is using a TrueType font.\n        But in GUI programs and for output sent to files and pipes, GetACP()\n        encoding is the best bet.  */\n      sprintf (buf, \"CP%u\", GetACP ());\n    }\n  codeset = buf;\n\n#elif defined OS2\n\n  const char *locale;\n  static char buf[2 + 10 + 1];\n  ULONG cp[3];\n  ULONG cplen;\n\n  codeset = NULL;\n\n  /* Allow user to override the codeset, as set in the operating system,\n     with standard language environment variables.  */\n  locale = getenv (\"LC_ALL\");\n  if (locale == NULL || locale[0] == '\\0')\n    {\n      locale = getenv (\"LC_CTYPE\");\n      if (locale == NULL || locale[0] == '\\0')\n        locale = getenv (\"LANG\");\n    }\n  if (locale != NULL && locale[0] != '\\0')\n    {\n      /* If the locale name contains an encoding after the dot, return it.  */\n      const char *dot = strchr (locale, '.');\n\n      if (dot != NULL)\n        {\n          const char *modifier;\n\n          dot++;\n          /* Look for the possible @... trailer and remove it, if any.  */\n          modifier = strchr (dot, '@');\n          if (modifier == NULL)\n            return dot;\n          if (modifier - dot < sizeof (buf))\n            {\n              memcpy (buf, dot, modifier - dot);\n              buf [modifier - dot] = '\\0';\n              return buf;\n            }\n        }\n\n      /* For the POSIX locale, don't use the system's codepage.  */\n      if (strcmp (locale, \"C\") == 0 || strcmp (locale, \"POSIX\") == 0)\n        codeset = \"\";\n    }\n\n  if (codeset == NULL)\n    {\n      /* OS/2 has a function returning the locale's codepage as a number.  */\n      if (DosQueryCp (sizeof (cp), cp, &cplen))\n        codeset = \"\";\n      else\n        {\n          sprintf (buf, \"CP%u\", cp[0]);\n          codeset = buf;\n        }\n    }\n\n#endif\n\n  if (codeset == NULL)\n    /* The canonical name cannot be determined.  */\n    codeset = \"\";\n\n  /* Resolve alias. */\n  for (aliases = get_charset_aliases ();\n       *aliases != '\\0';\n       aliases += strlen (aliases) + 1, aliases += strlen (aliases) + 1)\n    if (strcmp (codeset, aliases) == 0\n        || (aliases[0] == '*' && aliases[1] == '\\0'))\n      {\n        codeset = aliases + strlen (aliases) + 1;\n        break;\n      }\n\n  /* Don't return an empty string.  GNU libc and GNU libiconv interpret\n     the empty string as denoting \"the locale's character encoding\",\n     thus GNU libiconv would call this function a second time.  */\n  if (codeset[0] == '\\0')\n    codeset = \"ASCII\";\n\n#ifdef DARWIN7\n  /* Mac OS X sets MB_CUR_MAX to 1 when LC_ALL=C, and \"UTF-8\"\n     (the default codeset) does not work when MB_CUR_MAX is 1.  */\n  if (strcmp (codeset, \"UTF-8\") == 0 && MB_CUR_MAX_L (uselocale (NULL)) <= 1)\n    codeset = \"ASCII\";\n#endif\n\n  return codeset;\n}",
      "lines": 222,
      "depth": 18,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nlocale_charset (void)",
        "*"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/localcharset.h": {},
  "findutils/findutils-4.6.0/gl/lib/locale.in.h": {},
  "findutils/findutils-4.6.0/gl/lib/localeconv.c": {
    "localeconv": [
      {
        "start_point": [
          26,
          0
        ],
        "end_point": [
          60,
          1
        ],
        "content": "struct lconv *\nlocaleconv (void)\n{\n  static struct lconv result;\n# undef lconv\n# undef localeconv\n  struct lconv *sys_result = localeconv ();\n\n  result.decimal_point = sys_result->decimal_point;\n  result.thousands_sep = sys_result->thousands_sep;\n  result.grouping = sys_result->grouping;\n  result.mon_decimal_point = sys_result->mon_decimal_point;\n  result.mon_thousands_sep = sys_result->mon_thousands_sep;\n  result.mon_grouping = sys_result->mon_grouping;\n  result.positive_sign = sys_result->positive_sign;\n  result.negative_sign = sys_result->negative_sign;\n  result.currency_symbol = sys_result->currency_symbol;\n  result.frac_digits = sys_result->frac_digits;\n  result.p_cs_precedes = sys_result->p_cs_precedes;\n  result.p_sign_posn = sys_result->p_sign_posn;\n  result.p_sep_by_space = sys_result->p_sep_by_space;\n  result.n_cs_precedes = sys_result->n_cs_precedes;\n  result.n_sign_posn = sys_result->n_sign_posn;\n  result.n_sep_by_space = sys_result->n_sep_by_space;\n  result.int_curr_symbol = sys_result->int_curr_symbol;\n  result.int_frac_digits = sys_result->int_frac_digits;\n  result.int_p_cs_precedes = sys_result->p_cs_precedes;\n  result.int_p_sign_posn = sys_result->p_sign_posn;\n  result.int_p_sep_by_space = sys_result->p_sep_by_space;\n  result.int_n_cs_precedes = sys_result->n_cs_precedes;\n  result.int_n_sign_posn = sys_result->n_sign_posn;\n  result.int_n_sep_by_space = sys_result->n_sep_by_space;\n\n  return &result;\n}",
        "lines": 35,
        "depth": 7,
        "decorators": [
          "struct lconv",
          "struct",
          "lconv",
          "*\nlocaleconv (void)",
          "*"
        ]
      },
      {
        "start_point": [
          68,
          0
        ],
        "end_point": [
          100,
          1
        ],
        "content": "struct lconv *\nlocaleconv (void)\n{\n  static /*const*/ struct lconv result =\n    {\n      /* decimal_point */ \".\",\n      /* thousands_sep */ \"\",\n      /* grouping */ \"\",\n      /* mon_decimal_point */ \"\",\n      /* mon_thousands_sep */ \"\",\n      /* mon_grouping */ \"\",\n      /* positive_sign */ \"\",\n      /* negative_sign */ \"\",\n      /* currency_symbol */ \"\",\n      /* frac_digits */ CHAR_MAX,\n      /* p_cs_precedes */ CHAR_MAX,\n      /* p_sign_posn */ CHAR_MAX,\n      /* p_sep_by_space */ CHAR_MAX,\n      /* n_cs_precedes */ CHAR_MAX,\n      /* n_sign_posn */ CHAR_MAX,\n      /* n_sep_by_space */ CHAR_MAX,\n      /* int_curr_symbol */ \"\",\n      /* int_frac_digits */ CHAR_MAX,\n      /* int_p_cs_precedes */ CHAR_MAX,\n      /* int_p_sign_posn */ CHAR_MAX,\n      /* int_p_sep_by_space */ CHAR_MAX,\n      /* int_n_cs_precedes */ CHAR_MAX,\n      /* int_n_sign_posn */ CHAR_MAX,\n      /* int_n_sep_by_space */ CHAR_MAX\n    };\n\n  return &result;\n}",
        "lines": 33,
        "depth": 7,
        "decorators": [
          "struct lconv",
          "struct",
          "lconv",
          "*\nlocaleconv (void)",
          "*"
        ]
      }
    ]
  },
  "findutils/findutils-4.6.0/gl/lib/lseek.c": {
    "rpl_lseek": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "off_t\nrpl_lseek (int fd, off_t offset, int whence)\n{\n#if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n  /* mingw lseek mistakenly succeeds on pipes, sockets, and terminals.  */\n  HANDLE h = (HANDLE) _get_osfhandle (fd);\n  if (h == INVALID_HANDLE_VALUE)\n    {\n      errno = EBADF;\n      return -1;\n    }\n  if (GetFileType (h) != FILE_TYPE_DISK)\n    {\n      errno = ESPIPE;\n      return -1;\n    }\n#else\n  /* BeOS lseek mistakenly succeeds on pipes...  */\n  struct stat statbuf;\n  if (fstat (fd, &statbuf) < 0)\n    return -1;\n  if (!S_ISREG (statbuf.st_mode))\n    {\n      errno = ESPIPE;\n      return -1;\n    }\n#endif\n#if _GL_WINDOWS_64_BIT_OFF_T\n  return _lseeki64 (fd, offset, whence);\n#else\n  return lseek (fd, offset, whence);\n#endif\n}",
      "lines": 33,
      "depth": 11,
      "decorators": [
        "off_t"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/lstat.c": {
    "orig_lstat": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        41,
        1
      ],
      "content": "static int\norig_lstat (const char *filename, struct stat *buf)\n{\n  return lstat (filename, buf);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_lstat": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "int\nrpl_lstat (const char *file, struct stat *sbuf)\n{\n  size_t len;\n  int lstat_result = orig_lstat (file, sbuf);\n\n  if (lstat_result != 0)\n    return lstat_result;\n\n  /* This replacement file can blindly check against '/' rather than\n     using the ISSLASH macro, because all platforms with '\\\\' either\n     lack symlinks (mingw) or have working lstat (cygwin) and thus do\n     not compile this file.  0 len should have already been filtered\n     out above, with a failure return of ENOENT.  */\n  len = strlen (file);\n  if (file[len - 1] != '/' || S_ISDIR (sbuf->st_mode))\n    return 0;\n\n  /* At this point, a trailing slash is only permitted on\n     symlink-to-dir; but it should have found information on the\n     directory, not the symlink.  Call stat() to get info about the\n     link's referent.  Our replacement stat guarantees valid results,\n     even if the symlink is not pointing to a directory.  */\n  if (!S_ISLNK (sbuf->st_mode))\n    {\n      errno = ENOTDIR;\n      return -1;\n    }\n  return stat (file, sbuf);\n}",
      "lines": 30,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/malloc.c": {
    "rpl_malloc": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "void *\nrpl_malloc (size_t n)\n{\n  void *result;\n\n#if NEED_MALLOC_GNU\n  if (n == 0)\n    n = 1;\n#endif\n\n  result = malloc (n);\n\n#if !HAVE_MALLOC_POSIX\n  if (result == NULL)\n    errno = ENOMEM;\n#endif\n\n  return result;\n}",
      "lines": 19,
      "depth": 7,
      "decorators": [
        "void",
        "*\nrpl_malloc (size_t n)",
        "*"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/malloca.c": {
    "mmalloca": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        111,
        1
      ],
      "content": "void *\nmmalloca (size_t n)\n{\n#if HAVE_ALLOCA\n  /* Allocate one more word, that serves as an indicator for malloc()ed\n     memory, so that freea() of an alloca() result is fast.  */\n  size_t nplus = n + HEADER_SIZE;\n\n  if (nplus >= n)\n    {\n      void *p = malloc (nplus);\n\n      if (p != NULL)\n        {\n          size_t slot;\n          union header *h = p;\n\n          p = h + 1;\n\n          /* Put a magic number into the indicator word.  */\n          h->magic.word = MAGIC_NUMBER;\n\n          /* Enter p into the hash table.  */\n          slot = (uintptr_t) p % HASH_TABLE_SIZE;\n          h->next = mmalloca_results[slot];\n          mmalloca_results[slot] = p;\n\n          return p;\n        }\n    }\n  /* Out of memory.  */\n  return NULL;\n#else\n# if !MALLOC_0_IS_NONNULL\n  if (n == 0)\n    n = 1;\n# endif\n  return malloc (n);\n#endif\n}",
      "lines": 40,
      "depth": 13,
      "decorators": [
        "void",
        "*\nmmalloca (size_t n)",
        "*"
      ]
    },
    "freea": {
      "start_point": [
        114,
        0
      ],
      "end_point": [
        147,
        1
      ],
      "content": "void\nfreea (void *p)\n{\n  /* mmalloca() may have returned NULL.  */\n  if (p != NULL)\n    {\n      /* Attempt to quickly distinguish the mmalloca() result - which has\n         a magic indicator word - and the alloca() result - which has an\n         uninitialized indicator word.  It is for this test that sa_increment\n         additional bytes are allocated in the alloca() case.  */\n      if (((int *) p)[-1] == MAGIC_NUMBER)\n        {\n          /* Looks like a mmalloca() result.  To see whether it really is one,\n             perform a lookup in the hash table.  */\n          size_t slot = (uintptr_t) p % HASH_TABLE_SIZE;\n          void **chain = &mmalloca_results[slot];\n          for (; *chain != NULL;)\n            {\n              union header *h = p;\n              if (*chain == p)\n                {\n                  /* Found it.  Remove it from the hash table and free it.  */\n                  union header *p_begin = h - 1;\n                  *chain = p_begin->next;\n                  free (p_begin);\n                  return;\n                }\n              h = *chain;\n              chain = &h[-1].next;\n            }\n        }\n      /* At this point, we know it was not a mmalloca() result.  */\n    }\n}",
      "lines": 34,
      "depth": 14,
      "decorators": [
        "void"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/malloca.h": {},
  "findutils/findutils-4.6.0/gl/lib/math.c": {},
  "findutils/findutils-4.6.0/gl/lib/math.in.h": {
    "float": {
      "start_point": [
        133,
        0
      ],
      "end_point": [
        138,
        1
      ],
      "content": "_GL_MATH_INLINE float\n_NaN ()\n{\n  static float zero = 0.0f;\n  return zero / zero;\n}",
      "lines": 6,
      "depth": 5,
      "decorators": [
        "_GL_MATH_INLINE"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/mbchar.c": {},
  "findutils/findutils-4.6.0/gl/lib/mbchar.h": {
    "mb_width_aux": {
      "start_point": [
        245,
        0
      ],
      "end_point": [
        252,
        1
      ],
      "content": "MBCHAR_INLINE int\nmb_width_aux (wint_t wc)\n{\n  int w = wcwidth (wc);\n  /* For unprintable characters, arbitrarily return 0 for control characters\n     and MB_UNPRINTABLE_WIDTH otherwise.  */\n  return (w >= 0 ? w : iswcntrl (wc) ? 0 : MB_UNPRINTABLE_WIDTH);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "MBCHAR_INLINE",
        "int",
        "int"
      ]
    },
    "mb_copy": {
      "start_point": [
        266,
        0
      ],
      "end_point": [
        279,
        1
      ],
      "content": "MBCHAR_INLINE void\nmb_copy (mbchar_t *new_mbc, const mbchar_t *old_mbc)\n{\n  if (old_mbc->ptr == &old_mbc->buf[0])\n    {\n      memcpy (&new_mbc->buf[0], &old_mbc->buf[0], old_mbc->bytes);\n      new_mbc->ptr = &new_mbc->buf[0];\n    }\n  else\n    new_mbc->ptr = old_mbc->ptr;\n  new_mbc->bytes = old_mbc->bytes;\n  if ((new_mbc->wc_valid = old_mbc->wc_valid))\n    new_mbc->wc = old_mbc->wc;\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "MBCHAR_INLINE",
        "void",
        "void"
      ]
    },
    "is_basic": [
      {
        "start_point": [
          314,
          0
        ],
        "end_point": [
          319,
          1
        ],
        "content": "MBCHAR_INLINE bool\nis_basic (char c)\n{\n  return (is_basic_table [(unsigned char) c >> 5] >> ((unsigned char) c & 31))\n         & 1;\n}",
        "lines": 6,
        "depth": 12,
        "decorators": [
          "MBCHAR_INLINE",
          "bool",
          "bool"
        ]
      },
      {
        "start_point": [
          323,
          0
        ],
        "end_point": [
          353,
          1
        ],
        "content": "MBCHAR_INLINE bool\nis_basic (char c)\n{\n  switch (c)\n    {\n    case '\\t': case '\\v': case '\\f':\n    case ' ': case '!': case '\"': case '#': case '%':\n    case '&': case '\\'': case '(': case ')': case '*':\n    case '+': case ',': case '-': case '.': case '/':\n    case '0': case '1': case '2': case '3': case '4':\n    case '5': case '6': case '7': case '8': case '9':\n    case ':': case ';': case '<': case '=': case '>':\n    case '?':\n    case 'A': case 'B': case 'C': case 'D': case 'E':\n    case 'F': case 'G': case 'H': case 'I': case 'J':\n    case 'K': case 'L': case 'M': case 'N': case 'O':\n    case 'P': case 'Q': case 'R': case 'S': case 'T':\n    case 'U': case 'V': case 'W': case 'X': case 'Y':\n    case 'Z':\n    case '[': case '\\\\': case ']': case '^': case '_':\n    case 'a': case 'b': case 'c': case 'd': case 'e':\n    case 'f': case 'g': case 'h': case 'i': case 'j':\n    case 'k': case 'l': case 'm': case 'n': case 'o':\n    case 'p': case 'q': case 'r': case 's': case 't':\n    case 'u': case 'v': case 'w': case 'x': case 'y':\n    case 'z': case '{': case '|': case '}': case '~':\n      return 1;\n    default:\n      return 0;\n    }\n}",
        "lines": 31,
        "depth": 7,
        "decorators": [
          "MBCHAR_INLINE",
          "bool",
          "bool"
        ]
      }
    ]
  },
  "findutils/findutils-4.6.0/gl/lib/mbrtowc.c": {
    "mbrtowc": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        320,
        1
      ],
      "content": "size_t\nmbrtowc (wchar_t *pwc, const char *s, size_t n, mbstate_t *ps)\n{\n  char *pstate = (char *)ps;\n\n  if (s == NULL)\n    {\n      pwc = NULL;\n      s = \"\";\n      n = 1;\n    }\n\n  if (n == 0)\n    return (size_t)(-2);\n\n  /* Here n > 0.  */\n\n  if (pstate == NULL)\n    pstate = internal_state;\n\n  {\n    size_t nstate = pstate[0];\n    char buf[4];\n    const char *p;\n    size_t m;\n\n    switch (nstate)\n      {\n      case 0:\n        p = s;\n        m = n;\n        break;\n      case 3:\n        buf[2] = pstate[3];\n        /*FALLTHROUGH*/\n      case 2:\n        buf[1] = pstate[2];\n        /*FALLTHROUGH*/\n      case 1:\n        buf[0] = pstate[1];\n        p = buf;\n        m = nstate;\n        buf[m++] = s[0];\n        if (n >= 2 && m < 4)\n          {\n            buf[m++] = s[1];\n            if (n >= 3 && m < 4)\n              buf[m++] = s[2];\n          }\n        break;\n      default:\n        errno = EINVAL;\n        return (size_t)(-1);\n      }\n\n    /* Here m > 0.  */\n\n# if __GLIBC__ || defined __UCLIBC__\n    /* Work around bug <http://sourceware.org/bugzilla/show_bug.cgi?id=9674> */\n    mbtowc (NULL, NULL, 0);\n# endif\n    {\n      int res = mbtowc (pwc, p, m);\n\n      if (res >= 0)\n        {\n          if (pwc != NULL && ((*pwc == 0) != (res == 0)))\n            abort ();\n          if (nstate >= (res > 0 ? res : 1))\n            abort ();\n          res -= nstate;\n          pstate[0] = 0;\n          return res;\n        }\n\n      /* mbtowc does not distinguish between invalid and incomplete multibyte\n         sequences.  But mbrtowc needs to make this distinction.\n         There are two possible approaches:\n           - Use iconv() and its return value.\n           - Use built-in knowledge about the possible encodings.\n         Given the low quality of implementation of iconv() on the systems that\n         lack mbrtowc(), we use the second approach.\n         The possible encodings are:\n           - 8-bit encodings,\n           - EUC-JP, EUC-KR, GB2312, EUC-TW, BIG5, GB18030, SJIS,\n           - UTF-8.\n         Use specialized code for each.  */\n      if (m >= 4 || m >= MB_CUR_MAX)\n        goto invalid;\n      /* Here MB_CUR_MAX > 1 and 0 < m < 4.  */\n      {\n        const char *encoding = locale_charset ();\n\n        if (STREQ_OPT (encoding, \"UTF-8\", 'U', 'T', 'F', '-', '8', 0, 0, 0, 0))\n          {\n            /* Cf. unistr/u8-mblen.c.  */\n            unsigned char c = (unsigned char) p[0];\n\n            if (c >= 0xc2)\n              {\n                if (c < 0xe0)\n                  {\n                    if (m == 1)\n                      goto incomplete;\n                  }\n                else if (c < 0xf0)\n                  {\n                    if (m == 1)\n                      goto incomplete;\n                    if (m == 2)\n                      {\n                        unsigned char c2 = (unsigned char) p[1];\n\n                        if ((c2 ^ 0x80) < 0x40\n                            && (c >= 0xe1 || c2 >= 0xa0)\n                            && (c != 0xed || c2 < 0xa0))\n                          goto incomplete;\n                      }\n                  }\n                else if (c <= 0xf4)\n                  {\n                    if (m == 1)\n                      goto incomplete;\n                    else /* m == 2 || m == 3 */\n                      {\n                        unsigned char c2 = (unsigned char) p[1];\n\n                        if ((c2 ^ 0x80) < 0x40\n                            && (c >= 0xf1 || c2 >= 0x90)\n                            && (c < 0xf4 || (c == 0xf4 && c2 < 0x90)))\n                          {\n                            if (m == 2)\n                              goto incomplete;\n                            else /* m == 3 */\n                              {\n                                unsigned char c3 = (unsigned char) p[2];\n\n                                if ((c3 ^ 0x80) < 0x40)\n                                  goto incomplete;\n                              }\n                          }\n                      }\n                  }\n              }\n            goto invalid;\n          }\n\n        /* As a reference for this code, you can use the GNU libiconv\n           implementation.  Look for uses of the RET_TOOFEW macro.  */\n\n        if (STREQ_OPT (encoding,\n                       \"EUC-JP\", 'E', 'U', 'C', '-', 'J', 'P', 0, 0, 0))\n          {\n            if (m == 1)\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if ((c >= 0xa1 && c < 0xff) || c == 0x8e || c == 0x8f)\n                  goto incomplete;\n              }\n            if (m == 2)\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if (c == 0x8f)\n                  {\n                    unsigned char c2 = (unsigned char) p[1];\n\n                    if (c2 >= 0xa1 && c2 < 0xff)\n                      goto incomplete;\n                  }\n              }\n            goto invalid;\n          }\n        if (STREQ_OPT (encoding,\n                       \"EUC-KR\", 'E', 'U', 'C', '-', 'K', 'R', 0, 0, 0)\n            || STREQ_OPT (encoding,\n                          \"GB2312\", 'G', 'B', '2', '3', '1', '2', 0, 0, 0)\n            || STREQ_OPT (encoding,\n                          \"BIG5\", 'B', 'I', 'G', '5', 0, 0, 0, 0, 0))\n          {\n            if (m == 1)\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if (c >= 0xa1 && c < 0xff)\n                  goto incomplete;\n              }\n            goto invalid;\n          }\n        if (STREQ_OPT (encoding,\n                       \"EUC-TW\", 'E', 'U', 'C', '-', 'T', 'W', 0, 0, 0))\n          {\n            if (m == 1)\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if ((c >= 0xa1 && c < 0xff) || c == 0x8e)\n                  goto incomplete;\n              }\n            else /* m == 2 || m == 3 */\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if (c == 0x8e)\n                  goto incomplete;\n              }\n            goto invalid;\n          }\n        if (STREQ_OPT (encoding,\n                       \"GB18030\", 'G', 'B', '1', '8', '0', '3', '0', 0, 0))\n          {\n            if (m == 1)\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if ((c >= 0x90 && c <= 0xe3) || (c >= 0xf8 && c <= 0xfe))\n                  goto incomplete;\n              }\n            else /* m == 2 || m == 3 */\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if (c >= 0x90 && c <= 0xe3)\n                  {\n                    unsigned char c2 = (unsigned char) p[1];\n\n                    if (c2 >= 0x30 && c2 <= 0x39)\n                      {\n                        if (m == 2)\n                          goto incomplete;\n                        else /* m == 3 */\n                          {\n                            unsigned char c3 = (unsigned char) p[2];\n\n                            if (c3 >= 0x81 && c3 <= 0xfe)\n                              goto incomplete;\n                          }\n                      }\n                  }\n              }\n            goto invalid;\n          }\n        if (STREQ_OPT (encoding, \"SJIS\", 'S', 'J', 'I', 'S', 0, 0, 0, 0, 0))\n          {\n            if (m == 1)\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if ((c >= 0x81 && c <= 0x9f) || (c >= 0xe0 && c <= 0xea)\n                    || (c >= 0xf0 && c <= 0xf9))\n                  goto incomplete;\n              }\n            goto invalid;\n          }\n\n        /* An unknown multibyte encoding.  */\n        goto incomplete;\n      }\n\n     incomplete:\n      {\n        size_t k = nstate;\n        /* Here 0 <= k < m < 4.  */\n        pstate[++k] = s[0];\n        if (k < m)\n          {\n            pstate[++k] = s[1];\n            if (k < m)\n              pstate[++k] = s[2];\n          }\n        if (k != m)\n          abort ();\n      }\n      pstate[0] = m;\n      return (size_t)(-2);\n\n     invalid:\n      errno = EILSEQ;\n      /* The conversion state is undefined, says POSIX.  */\n      return (size_t)(-1);\n    }\n  }\n}",
      "lines": 284,
      "depth": 25,
      "decorators": [
        "size_t"
      ]
    },
    "rpl_mbrtowc": {
      "start_point": [
        327,
        0
      ],
      "end_point": [
        404,
        1
      ],
      "content": "size_t\nrpl_mbrtowc (wchar_t *pwc, const char *s, size_t n, mbstate_t *ps)\n{\n# if MBRTOWC_NULL_ARG2_BUG || MBRTOWC_RETVAL_BUG || MBRTOWC_EMPTY_INPUT_BUG\n  if (s == NULL)\n    {\n      pwc = NULL;\n      s = \"\";\n      n = 1;\n    }\n# endif\n\n# if MBRTOWC_EMPTY_INPUT_BUG\n  if (n == 0)\n    return (size_t) -2;\n# endif\n\n# if MBRTOWC_RETVAL_BUG\n  {\n    static mbstate_t internal_state;\n\n    /* Override mbrtowc's internal state.  We cannot call mbsinit() on the\n       hidden internal state, but we can call it on our variable.  */\n    if (ps == NULL)\n      ps = &internal_state;\n\n    if (!mbsinit (ps))\n      {\n        /* Parse the rest of the multibyte character byte for byte.  */\n        size_t count = 0;\n        for (; n > 0; s++, n--)\n          {\n            wchar_t wc;\n            size_t ret = mbrtowc (&wc, s, 1, ps);\n\n            if (ret == (size_t)(-1))\n              return (size_t)(-1);\n            count++;\n            if (ret != (size_t)(-2))\n              {\n                /* The multibyte character has been completed.  */\n                if (pwc != NULL)\n                  *pwc = wc;\n                return (wc == 0 ? 0 : count);\n              }\n          }\n        return (size_t)(-2);\n      }\n  }\n# endif\n\n# if MBRTOWC_NUL_RETVAL_BUG\n  {\n    wchar_t wc;\n    size_t ret = mbrtowc (&wc, s, n, ps);\n\n    if (ret != (size_t)(-1) && ret != (size_t)(-2))\n      {\n        if (pwc != NULL)\n          *pwc = wc;\n        if (wc == 0)\n          ret = 0;\n      }\n    return ret;\n  }\n# else\n  {\n#   if MBRTOWC_NULL_ARG1_BUG\n    wchar_t dummy;\n\n    if (pwc == NULL)\n      pwc = &dummy;\n#   endif\n\n    return mbrtowc (pwc, s, n, ps);\n  }\n# endif\n}",
      "lines": 78,
      "depth": 15,
      "decorators": [
        "size_t"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/mbscasestr.c": {
    "knuth_morris_pratt_multibyte": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        191,
        1
      ],
      "content": "static bool\nknuth_morris_pratt_multibyte (const char *haystack, const char *needle,\n                              const char **resultp)\n{\n  size_t m = mbslen (needle);\n  mbchar_t *needle_mbchars;\n  size_t *table;\n\n  /* Allocate room for needle_mbchars and the table.  */\n  char *memory = (char *) nmalloca (m, sizeof (mbchar_t) + sizeof (size_t));\n  if (memory == NULL)\n    return false;\n  needle_mbchars = (mbchar_t *) memory;\n  table = (size_t *) (memory + m * sizeof (mbchar_t));\n\n  /* Fill needle_mbchars.  */\n  {\n    mbui_iterator_t iter;\n    size_t j;\n\n    j = 0;\n    for (mbui_init (iter, needle); mbui_avail (iter); mbui_advance (iter), j++)\n      {\n        mb_copy (&needle_mbchars[j], &mbui_cur (iter));\n        if (needle_mbchars[j].wc_valid)\n          needle_mbchars[j].wc = towlower (needle_mbchars[j].wc);\n      }\n  }\n\n  /* Fill the table.\n     For 0 < i < m:\n       0 < table[i] <= i is defined such that\n       forall 0 < x < table[i]: needle[x..i-1] != needle[0..i-1-x],\n       and table[i] is as large as possible with this property.\n     This implies:\n     1) For 0 < i < m:\n          If table[i] < i,\n          needle[table[i]..i-1] = needle[0..i-1-table[i]].\n     2) For 0 < i < m:\n          rhaystack[0..i-1] == needle[0..i-1]\n          and exists h, i <= h < m: rhaystack[h] != needle[h]\n          implies\n          forall 0 <= x < table[i]: rhaystack[x..x+m-1] != needle[0..m-1].\n     table[0] remains uninitialized.  */\n  {\n    size_t i, j;\n\n    /* i = 1: Nothing to verify for x = 0.  */\n    table[1] = 1;\n    j = 0;\n\n    for (i = 2; i < m; i++)\n      {\n        /* Here: j = i-1 - table[i-1].\n           The inequality needle[x..i-1] != needle[0..i-1-x] is known to hold\n           for x < table[i-1], by induction.\n           Furthermore, if j>0: needle[i-1-j..i-2] = needle[0..j-1].  */\n        mbchar_t *b = &needle_mbchars[i - 1];\n\n        for (;;)\n          {\n            /* Invariants: The inequality needle[x..i-1] != needle[0..i-1-x]\n               is known to hold for x < i-1-j.\n               Furthermore, if j>0: needle[i-1-j..i-2] = needle[0..j-1].  */\n            if (mb_equal (*b, needle_mbchars[j]))\n              {\n                /* Set table[i] := i-1-j.  */\n                table[i] = i - ++j;\n                break;\n              }\n            /* The inequality needle[x..i-1] != needle[0..i-1-x] also holds\n               for x = i-1-j, because\n                 needle[i-1] != needle[j] = needle[i-1-x].  */\n            if (j == 0)\n              {\n                /* The inequality holds for all possible x.  */\n                table[i] = i;\n                break;\n              }\n            /* The inequality needle[x..i-1] != needle[0..i-1-x] also holds\n               for i-1-j < x < i-1-j+table[j], because for these x:\n                 needle[x..i-2]\n                 = needle[x-(i-1-j)..j-1]\n                 != needle[0..j-1-(x-(i-1-j))]  (by definition of table[j])\n                    = needle[0..i-2-x],\n               hence needle[x..i-1] != needle[0..i-1-x].\n               Furthermore\n                 needle[i-1-j+table[j]..i-2]\n                 = needle[table[j]..j-1]\n                 = needle[0..j-1-table[j]]  (by definition of table[j]).  */\n            j = j - table[j];\n          }\n        /* Here: j = i - table[i].  */\n      }\n  }\n\n  /* Search, using the table to accelerate the processing.  */\n  {\n    size_t j;\n    mbui_iterator_t rhaystack;\n    mbui_iterator_t phaystack;\n\n    *resultp = NULL;\n    j = 0;\n    mbui_init (rhaystack, haystack);\n    mbui_init (phaystack, haystack);\n    /* Invariant: phaystack = rhaystack + j.  */\n    while (mbui_avail (phaystack))\n      {\n        mbchar_t c;\n\n        mb_copy (&c, &mbui_cur (phaystack));\n        if (c.wc_valid)\n          c.wc = towlower (c.wc);\n        if (mb_equal (needle_mbchars[j], c))\n          {\n            j++;\n            mbui_advance (phaystack);\n            if (j == m)\n              {\n                /* The entire needle has been found.  */\n                *resultp = mbui_cur_ptr (rhaystack);\n                break;\n              }\n          }\n        else if (j > 0)\n          {\n            /* Found a match of needle[0..j-1], mismatch at needle[j].  */\n            size_t count = table[j];\n            j -= count;\n            for (; count > 0; count--)\n              {\n                if (!mbui_avail (rhaystack))\n                  abort ();\n                mbui_advance (rhaystack);\n              }\n          }\n        else\n          {\n            /* Found a mismatch at needle[0] already.  */\n            if (!mbui_avail (rhaystack))\n              abort ();\n            mbui_advance (rhaystack);\n            mbui_advance (phaystack);\n          }\n      }\n  }\n\n  freea (memory);\n  return true;\n}",
      "lines": 151,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "mbscasestr": {
      "start_point": [
        197,
        0
      ],
      "end_point": [
        411,
        1
      ],
      "content": "char *\nmbscasestr (const char *haystack, const char *needle)\n{\n  /* Be careful not to look at the entire extent of haystack or needle\n     until needed.  This is useful because of these two cases:\n       - haystack may be very long, and a match of needle found early,\n       - needle may be very long, and not even a short initial segment of\n         needle may be found in haystack.  */\n  if (MB_CUR_MAX > 1)\n    {\n      mbui_iterator_t iter_needle;\n\n      mbui_init (iter_needle, needle);\n      if (mbui_avail (iter_needle))\n        {\n          /* Minimizing the worst-case complexity:\n             Let n = mbslen(haystack), m = mbslen(needle).\n             The na\u00c3\u00afve algorithm is O(n*m) worst-case.\n             The Knuth-Morris-Pratt algorithm is O(n) worst-case but it needs a\n             memory allocation.\n             To achieve linear complexity and yet amortize the cost of the\n             memory allocation, we activate the Knuth-Morris-Pratt algorithm\n             only once the na\u00c3\u00afve algorithm has already run for some time; more\n             precisely, when\n               - the outer loop count is >= 10,\n               - the average number of comparisons per outer loop is >= 5,\n               - the total number of comparisons is >= m.\n             But we try it only once.  If the memory allocation attempt failed,\n             we don't retry it.  */\n          bool try_kmp = true;\n          size_t outer_loop_count = 0;\n          size_t comparison_count = 0;\n          size_t last_ccount = 0;                  /* last comparison count */\n          mbui_iterator_t iter_needle_last_ccount; /* = needle + last_ccount */\n\n          mbchar_t b;\n          mbui_iterator_t iter_haystack;\n\n          mbui_init (iter_needle_last_ccount, needle);\n\n          mb_copy (&b, &mbui_cur (iter_needle));\n          if (b.wc_valid)\n            b.wc = towlower (b.wc);\n\n          mbui_init (iter_haystack, haystack);\n          for (;; mbui_advance (iter_haystack))\n            {\n              mbchar_t c;\n\n              if (!mbui_avail (iter_haystack))\n                /* No match.  */\n                return NULL;\n\n              /* See whether it's advisable to use an asymptotically faster\n                 algorithm.  */\n              if (try_kmp\n                  && outer_loop_count >= 10\n                  && comparison_count >= 5 * outer_loop_count)\n                {\n                  /* See if needle + comparison_count now reaches the end of\n                     needle.  */\n                  size_t count = comparison_count - last_ccount;\n                  for (;\n                       count > 0 && mbui_avail (iter_needle_last_ccount);\n                       count--)\n                    mbui_advance (iter_needle_last_ccount);\n                  last_ccount = comparison_count;\n                  if (!mbui_avail (iter_needle_last_ccount))\n                    {\n                      /* Try the Knuth-Morris-Pratt algorithm.  */\n                      const char *result;\n                      bool success =\n                        knuth_morris_pratt_multibyte (haystack, needle,\n                                                      &result);\n                      if (success)\n                        return (char *) result;\n                      try_kmp = false;\n                    }\n                }\n\n              outer_loop_count++;\n              comparison_count++;\n              mb_copy (&c, &mbui_cur (iter_haystack));\n              if (c.wc_valid)\n                c.wc = towlower (c.wc);\n              if (mb_equal (c, b))\n                /* The first character matches.  */\n                {\n                  mbui_iterator_t rhaystack;\n                  mbui_iterator_t rneedle;\n\n                  memcpy (&rhaystack, &iter_haystack, sizeof (mbui_iterator_t));\n                  mbui_advance (rhaystack);\n\n                  mbui_init (rneedle, needle);\n                  if (!mbui_avail (rneedle))\n                    abort ();\n                  mbui_advance (rneedle);\n\n                  for (;; mbui_advance (rhaystack), mbui_advance (rneedle))\n                    {\n                      if (!mbui_avail (rneedle))\n                        /* Found a match.  */\n                        return (char *) mbui_cur_ptr (iter_haystack);\n                      if (!mbui_avail (rhaystack))\n                        /* No match.  */\n                        return NULL;\n                      comparison_count++;\n                      if (!mb_caseequal (mbui_cur (rhaystack),\n                                         mbui_cur (rneedle)))\n                        /* Nothing in this round.  */\n                        break;\n                    }\n                }\n            }\n        }\n      else\n        return (char *) haystack;\n    }\n  else\n    {\n      if (*needle != '\\0')\n        {\n          /* Minimizing the worst-case complexity:\n             Let n = strlen(haystack), m = strlen(needle).\n             The na\u00c3\u00afve algorithm is O(n*m) worst-case.\n             The Knuth-Morris-Pratt algorithm is O(n) worst-case but it needs a\n             memory allocation.\n             To achieve linear complexity and yet amortize the cost of the\n             memory allocation, we activate the Knuth-Morris-Pratt algorithm\n             only once the na\u00c3\u00afve algorithm has already run for some time; more\n             precisely, when\n               - the outer loop count is >= 10,\n               - the average number of comparisons per outer loop is >= 5,\n               - the total number of comparisons is >= m.\n             But we try it only once.  If the memory allocation attempt failed,\n             we don't retry it.  */\n          bool try_kmp = true;\n          size_t outer_loop_count = 0;\n          size_t comparison_count = 0;\n          size_t last_ccount = 0;                  /* last comparison count */\n          const char *needle_last_ccount = needle; /* = needle + last_ccount */\n\n          /* Speed up the following searches of needle by caching its first\n             character.  */\n          unsigned char b = TOLOWER ((unsigned char) *needle);\n\n          needle++;\n          for (;; haystack++)\n            {\n              if (*haystack == '\\0')\n                /* No match.  */\n                return NULL;\n\n              /* See whether it's advisable to use an asymptotically faster\n                 algorithm.  */\n              if (try_kmp\n                  && outer_loop_count >= 10\n                  && comparison_count >= 5 * outer_loop_count)\n                {\n                  /* See if needle + comparison_count now reaches the end of\n                     needle.  */\n                  if (needle_last_ccount != NULL)\n                    {\n                      needle_last_ccount +=\n                        strnlen (needle_last_ccount,\n                                 comparison_count - last_ccount);\n                      if (*needle_last_ccount == '\\0')\n                        needle_last_ccount = NULL;\n                      last_ccount = comparison_count;\n                    }\n                  if (needle_last_ccount == NULL)\n                    {\n                      /* Try the Knuth-Morris-Pratt algorithm.  */\n                      const unsigned char *result;\n                      bool success =\n                        knuth_morris_pratt ((const unsigned char *) haystack,\n                                            (const unsigned char *) (needle - 1),\n                                            strlen (needle - 1),\n                                            &result);\n                      if (success)\n                        return (char *) result;\n                      try_kmp = false;\n                    }\n                }\n\n              outer_loop_count++;\n              comparison_count++;\n              if (TOLOWER ((unsigned char) *haystack) == b)\n                /* The first character matches.  */\n                {\n                  const char *rhaystack = haystack + 1;\n                  const char *rneedle = needle;\n\n                  for (;; rhaystack++, rneedle++)\n                    {\n                      if (*rneedle == '\\0')\n                        /* Found a match.  */\n                        return (char *) haystack;\n                      if (*rhaystack == '\\0')\n                        /* No match.  */\n                        return NULL;\n                      comparison_count++;\n                      if (TOLOWER ((unsigned char) *rhaystack)\n                          != TOLOWER ((unsigned char) *rneedle))\n                        /* Nothing in this round.  */\n                        break;\n                    }\n                }\n            }\n        }\n      else\n        return (char *) haystack;\n    }\n}",
      "lines": 215,
      "depth": 21,
      "decorators": [
        "char",
        "*\nmbscasestr (const char *haystack, const char *needle)",
        "*"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/mbsinit.c": {
    "mbsinit": [
      {
        "start_point": [
          28,
          0
        ],
        "end_point": [
          32,
          1
        ],
        "content": "int\nmbsinit (const mbstate_t *ps)\n{\n  return ps == NULL || *ps == 0;\n}",
        "lines": 5,
        "depth": 7,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          52,
          0
        ],
        "end_point": [
          58,
          1
        ],
        "content": "int\nmbsinit (const mbstate_t *ps)\n{\n  const char *pstate = (const char *)ps;\n\n  return pstate == NULL || pstate[0] == 0;\n}",
        "lines": 7,
        "depth": 8,
        "decorators": [
          "int"
        ]
      }
    ]
  },
  "findutils/findutils-4.6.0/gl/lib/mbslen.c": {
    "mbslen": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "size_t\nmbslen (const char *string)\n{\n  if (MB_CUR_MAX > 1)\n    {\n      size_t count;\n      mbui_iterator_t iter;\n\n      count = 0;\n      for (mbui_init (iter, string); mbui_avail (iter); mbui_advance (iter))\n        count++;\n\n      return count;\n    }\n  else\n    return strlen (string);\n}",
      "lines": 17,
      "depth": 8,
      "decorators": [
        "size_t"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/mbsrtowcs-impl.h": {
    "mbsrtowcs": {
      "start_point": [
        17,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "size_t\nmbsrtowcs (wchar_t *dest, const char **srcp, size_t len, mbstate_t *ps)\n{\n  if (ps == NULL)\n    ps = &_gl_mbsrtowcs_state;\n  {\n    const char *src = *srcp;\n\n    if (dest != NULL)\n      {\n        wchar_t *destptr = dest;\n\n        for (; len > 0; destptr++, len--)\n          {\n            size_t src_avail;\n            size_t ret;\n\n            /* An optimized variant of\n               src_avail = strnlen1 (src, MB_LEN_MAX);  */\n            if (src[0] == '\\0')\n              src_avail = 1;\n            else if (src[1] == '\\0')\n              src_avail = 2;\n            else if (src[2] == '\\0')\n              src_avail = 3;\n            else if (MB_LEN_MAX <= 4 || src[3] == '\\0')\n              src_avail = 4;\n            else\n              src_avail = 4 + strnlen1 (src + 4, MB_LEN_MAX - 4);\n\n            /* Parse the next multibyte character.  */\n            ret = mbrtowc (destptr, src, src_avail, ps);\n\n            if (ret == (size_t)(-2))\n              /* Encountered a multibyte character that extends past a '\\0' byte\n                 or that is longer than MB_LEN_MAX bytes.  Cannot happen.  */\n              abort ();\n\n            if (ret == (size_t)(-1))\n              goto bad_input;\n            if (ret == 0)\n              {\n                src = NULL;\n                /* Here mbsinit (ps).  */\n                break;\n              }\n            src += ret;\n          }\n\n        *srcp = src;\n        return destptr - dest;\n      }\n    else\n      {\n        /* Ignore dest and len, don't store *srcp at the end, and\n           don't clobber *ps.  */\n        mbstate_t state = *ps;\n        size_t totalcount = 0;\n\n        for (;; totalcount++)\n          {\n            size_t src_avail;\n            size_t ret;\n\n            /* An optimized variant of\n               src_avail = strnlen1 (src, MB_LEN_MAX);  */\n            if (src[0] == '\\0')\n              src_avail = 1;\n            else if (src[1] == '\\0')\n              src_avail = 2;\n            else if (src[2] == '\\0')\n              src_avail = 3;\n            else if (MB_LEN_MAX <= 4 || src[3] == '\\0')\n              src_avail = 4;\n            else\n              src_avail = 4 + strnlen1 (src + 4, MB_LEN_MAX - 4);\n\n            /* Parse the next multibyte character.  */\n            ret = mbrtowc (NULL, src, src_avail, &state);\n\n            if (ret == (size_t)(-2))\n              /* Encountered a multibyte character that extends past a '\\0' byte\n                 or that is longer than MB_LEN_MAX bytes.  Cannot happen.  */\n              abort ();\n\n            if (ret == (size_t)(-1))\n              goto bad_input2;\n            if (ret == 0)\n              {\n                /* Here mbsinit (&state).  */\n                break;\n              }\n            src += ret;\n          }\n\n        return totalcount;\n      }\n\n   bad_input:\n    *srcp = src;\n   bad_input2:\n    errno = EILSEQ;\n    return (size_t)(-1);\n  }\n}",
      "lines": 105,
      "depth": 18,
      "decorators": [
        "size_t"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/mbsrtowcs-state.c": {},
  "findutils/findutils-4.6.0/gl/lib/mbsrtowcs.c": {},
  "findutils/findutils-4.6.0/gl/lib/mbsstr.c": {
    "knuth_morris_pratt_multibyte": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        179,
        1
      ],
      "content": "static bool\nknuth_morris_pratt_multibyte (const char *haystack, const char *needle,\n                              const char **resultp)\n{\n  size_t m = mbslen (needle);\n  mbchar_t *needle_mbchars;\n  size_t *table;\n\n  /* Allocate room for needle_mbchars and the table.  */\n  void *memory = nmalloca (m, sizeof (mbchar_t) + sizeof (size_t));\n  void *table_memory;\n  if (memory == NULL)\n    return false;\n  needle_mbchars = memory;\n  table_memory = needle_mbchars + m;\n  table = table_memory;\n\n  /* Fill needle_mbchars.  */\n  {\n    mbui_iterator_t iter;\n    size_t j;\n\n    j = 0;\n    for (mbui_init (iter, needle); mbui_avail (iter); mbui_advance (iter), j++)\n      mb_copy (&needle_mbchars[j], &mbui_cur (iter));\n  }\n\n  /* Fill the table.\n     For 0 < i < m:\n       0 < table[i] <= i is defined such that\n       forall 0 < x < table[i]: needle[x..i-1] != needle[0..i-1-x],\n       and table[i] is as large as possible with this property.\n     This implies:\n     1) For 0 < i < m:\n          If table[i] < i,\n          needle[table[i]..i-1] = needle[0..i-1-table[i]].\n     2) For 0 < i < m:\n          rhaystack[0..i-1] == needle[0..i-1]\n          and exists h, i <= h < m: rhaystack[h] != needle[h]\n          implies\n          forall 0 <= x < table[i]: rhaystack[x..x+m-1] != needle[0..m-1].\n     table[0] remains uninitialized.  */\n  {\n    size_t i, j;\n\n    /* i = 1: Nothing to verify for x = 0.  */\n    table[1] = 1;\n    j = 0;\n\n    for (i = 2; i < m; i++)\n      {\n        /* Here: j = i-1 - table[i-1].\n           The inequality needle[x..i-1] != needle[0..i-1-x] is known to hold\n           for x < table[i-1], by induction.\n           Furthermore, if j>0: needle[i-1-j..i-2] = needle[0..j-1].  */\n        mbchar_t *b = &needle_mbchars[i - 1];\n\n        for (;;)\n          {\n            /* Invariants: The inequality needle[x..i-1] != needle[0..i-1-x]\n               is known to hold for x < i-1-j.\n               Furthermore, if j>0: needle[i-1-j..i-2] = needle[0..j-1].  */\n            if (mb_equal (*b, needle_mbchars[j]))\n              {\n                /* Set table[i] := i-1-j.  */\n                table[i] = i - ++j;\n                break;\n              }\n            /* The inequality needle[x..i-1] != needle[0..i-1-x] also holds\n               for x = i-1-j, because\n                 needle[i-1] != needle[j] = needle[i-1-x].  */\n            if (j == 0)\n              {\n                /* The inequality holds for all possible x.  */\n                table[i] = i;\n                break;\n              }\n            /* The inequality needle[x..i-1] != needle[0..i-1-x] also holds\n               for i-1-j < x < i-1-j+table[j], because for these x:\n                 needle[x..i-2]\n                 = needle[x-(i-1-j)..j-1]\n                 != needle[0..j-1-(x-(i-1-j))]  (by definition of table[j])\n                    = needle[0..i-2-x],\n               hence needle[x..i-1] != needle[0..i-1-x].\n               Furthermore\n                 needle[i-1-j+table[j]..i-2]\n                 = needle[table[j]..j-1]\n                 = needle[0..j-1-table[j]]  (by definition of table[j]).  */\n            j = j - table[j];\n          }\n        /* Here: j = i - table[i].  */\n      }\n  }\n\n  /* Search, using the table to accelerate the processing.  */\n  {\n    size_t j;\n    mbui_iterator_t rhaystack;\n    mbui_iterator_t phaystack;\n\n    *resultp = NULL;\n    j = 0;\n    mbui_init (rhaystack, haystack);\n    mbui_init (phaystack, haystack);\n    /* Invariant: phaystack = rhaystack + j.  */\n    while (mbui_avail (phaystack))\n      if (mb_equal (needle_mbchars[j], mbui_cur (phaystack)))\n        {\n          j++;\n          mbui_advance (phaystack);\n          if (j == m)\n            {\n              /* The entire needle has been found.  */\n              *resultp = mbui_cur_ptr (rhaystack);\n              break;\n            }\n        }\n      else if (j > 0)\n        {\n          /* Found a match of needle[0..j-1], mismatch at needle[j].  */\n          size_t count = table[j];\n          j -= count;\n          for (; count > 0; count--)\n            {\n              if (!mbui_avail (rhaystack))\n                abort ();\n              mbui_advance (rhaystack);\n            }\n        }\n      else\n        {\n          /* Found a mismatch at needle[0] already.  */\n          if (!mbui_avail (rhaystack))\n            abort ();\n          mbui_advance (rhaystack);\n          mbui_advance (phaystack);\n        }\n  }\n\n  freea (memory);\n  return true;\n}",
      "lines": 142,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "mbsstr": {
      "start_point": [
        183,
        0
      ],
      "end_point": [
        383,
        1
      ],
      "content": "char *\nmbsstr (const char *haystack, const char *needle)\n{\n  /* Be careful not to look at the entire extent of haystack or needle\n     until needed.  This is useful because of these two cases:\n       - haystack may be very long, and a match of needle found early,\n       - needle may be very long, and not even a short initial segment of\n         needle may be found in haystack.  */\n  if (MB_CUR_MAX > 1)\n    {\n      mbui_iterator_t iter_needle;\n\n      mbui_init (iter_needle, needle);\n      if (mbui_avail (iter_needle))\n        {\n          /* Minimizing the worst-case complexity:\n             Let n = mbslen(haystack), m = mbslen(needle).\n             The na\u00c3\u00afve algorithm is O(n*m) worst-case.\n             The Knuth-Morris-Pratt algorithm is O(n) worst-case but it needs a\n             memory allocation.\n             To achieve linear complexity and yet amortize the cost of the\n             memory allocation, we activate the Knuth-Morris-Pratt algorithm\n             only once the na\u00c3\u00afve algorithm has already run for some time; more\n             precisely, when\n               - the outer loop count is >= 10,\n               - the average number of comparisons per outer loop is >= 5,\n               - the total number of comparisons is >= m.\n             But we try it only once.  If the memory allocation attempt failed,\n             we don't retry it.  */\n          bool try_kmp = true;\n          size_t outer_loop_count = 0;\n          size_t comparison_count = 0;\n          size_t last_ccount = 0;                  /* last comparison count */\n          mbui_iterator_t iter_needle_last_ccount; /* = needle + last_ccount */\n\n          mbui_iterator_t iter_haystack;\n\n          mbui_init (iter_needle_last_ccount, needle);\n          mbui_init (iter_haystack, haystack);\n          for (;; mbui_advance (iter_haystack))\n            {\n              if (!mbui_avail (iter_haystack))\n                /* No match.  */\n                return NULL;\n\n              /* See whether it's advisable to use an asymptotically faster\n                 algorithm.  */\n              if (try_kmp\n                  && outer_loop_count >= 10\n                  && comparison_count >= 5 * outer_loop_count)\n                {\n                  /* See if needle + comparison_count now reaches the end of\n                     needle.  */\n                  size_t count = comparison_count - last_ccount;\n                  for (;\n                       count > 0 && mbui_avail (iter_needle_last_ccount);\n                       count--)\n                    mbui_advance (iter_needle_last_ccount);\n                  last_ccount = comparison_count;\n                  if (!mbui_avail (iter_needle_last_ccount))\n                    {\n                      /* Try the Knuth-Morris-Pratt algorithm.  */\n                      const char *result;\n                      bool success =\n                        knuth_morris_pratt_multibyte (haystack, needle,\n                                                      &result);\n                      if (success)\n                        return (char *) result;\n                      try_kmp = false;\n                    }\n                }\n\n              outer_loop_count++;\n              comparison_count++;\n              if (mb_equal (mbui_cur (iter_haystack), mbui_cur (iter_needle)))\n                /* The first character matches.  */\n                {\n                  mbui_iterator_t rhaystack;\n                  mbui_iterator_t rneedle;\n\n                  memcpy (&rhaystack, &iter_haystack, sizeof (mbui_iterator_t));\n                  mbui_advance (rhaystack);\n\n                  mbui_init (rneedle, needle);\n                  if (!mbui_avail (rneedle))\n                    abort ();\n                  mbui_advance (rneedle);\n\n                  for (;; mbui_advance (rhaystack), mbui_advance (rneedle))\n                    {\n                      if (!mbui_avail (rneedle))\n                        /* Found a match.  */\n                        return (char *) mbui_cur_ptr (iter_haystack);\n                      if (!mbui_avail (rhaystack))\n                        /* No match.  */\n                        return NULL;\n                      comparison_count++;\n                      if (!mb_equal (mbui_cur (rhaystack), mbui_cur (rneedle)))\n                        /* Nothing in this round.  */\n                        break;\n                    }\n                }\n            }\n        }\n      else\n        return (char *) haystack;\n    }\n  else\n    {\n      if (*needle != '\\0')\n        {\n          /* Minimizing the worst-case complexity:\n             Let n = strlen(haystack), m = strlen(needle).\n             The na\u00c3\u00afve algorithm is O(n*m) worst-case.\n             The Knuth-Morris-Pratt algorithm is O(n) worst-case but it needs a\n             memory allocation.\n             To achieve linear complexity and yet amortize the cost of the\n             memory allocation, we activate the Knuth-Morris-Pratt algorithm\n             only once the na\u00c3\u00afve algorithm has already run for some time; more\n             precisely, when\n               - the outer loop count is >= 10,\n               - the average number of comparisons per outer loop is >= 5,\n               - the total number of comparisons is >= m.\n             But we try it only once.  If the memory allocation attempt failed,\n             we don't retry it.  */\n          bool try_kmp = true;\n          size_t outer_loop_count = 0;\n          size_t comparison_count = 0;\n          size_t last_ccount = 0;                  /* last comparison count */\n          const char *needle_last_ccount = needle; /* = needle + last_ccount */\n\n          /* Speed up the following searches of needle by caching its first\n             character.  */\n          char b = *needle++;\n\n          for (;; haystack++)\n            {\n              if (*haystack == '\\0')\n                /* No match.  */\n                return NULL;\n\n              /* See whether it's advisable to use an asymptotically faster\n                 algorithm.  */\n              if (try_kmp\n                  && outer_loop_count >= 10\n                  && comparison_count >= 5 * outer_loop_count)\n                {\n                  /* See if needle + comparison_count now reaches the end of\n                     needle.  */\n                  if (needle_last_ccount != NULL)\n                    {\n                      needle_last_ccount +=\n                        strnlen (needle_last_ccount,\n                                 comparison_count - last_ccount);\n                      if (*needle_last_ccount == '\\0')\n                        needle_last_ccount = NULL;\n                      last_ccount = comparison_count;\n                    }\n                  if (needle_last_ccount == NULL)\n                    {\n                      /* Try the Knuth-Morris-Pratt algorithm.  */\n                      const unsigned char *result;\n                      bool success =\n                        knuth_morris_pratt ((const unsigned char *) haystack,\n                                            (const unsigned char *) (needle - 1),\n                                            strlen (needle - 1),\n                                            &result);\n                      if (success)\n                        return (char *) result;\n                      try_kmp = false;\n                    }\n                }\n\n              outer_loop_count++;\n              comparison_count++;\n              if (*haystack == b)\n                /* The first character matches.  */\n                {\n                  const char *rhaystack = haystack + 1;\n                  const char *rneedle = needle;\n\n                  for (;; rhaystack++, rneedle++)\n                    {\n                      if (*rneedle == '\\0')\n                        /* Found a match.  */\n                        return (char *) haystack;\n                      if (*rhaystack == '\\0')\n                        /* No match.  */\n                        return NULL;\n                      comparison_count++;\n                      if (*rhaystack != *rneedle)\n                        /* Nothing in this round.  */\n                        break;\n                    }\n                }\n            }\n        }\n      else\n        return (char *) haystack;\n    }\n}",
      "lines": 201,
      "depth": 20,
      "decorators": [
        "char",
        "*\nmbsstr (const char *haystack, const char *needle)",
        "*"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/mbswidth.c": {
    "mbswidth": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "int\nmbswidth (const char *string, int flags)\n{\n  return mbsnwidth (string, strlen (string), flags);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "mbsnwidth": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        192,
        1
      ],
      "content": "int\nmbsnwidth (const char *string, size_t nbytes, int flags)\n{\n  const char *p = string;\n  const char *plimit = p + nbytes;\n  int width;\n\n  width = 0;\n  if (MB_CUR_MAX > 1)\n    {\n      while (p < plimit)\n        switch (*p)\n          {\n            case ' ': case '!': case '\"': case '#': case '%':\n            case '&': case '\\'': case '(': case ')': case '*':\n            case '+': case ',': case '-': case '.': case '/':\n            case '0': case '1': case '2': case '3': case '4':\n            case '5': case '6': case '7': case '8': case '9':\n            case ':': case ';': case '<': case '=': case '>':\n            case '?':\n            case 'A': case 'B': case 'C': case 'D': case 'E':\n            case 'F': case 'G': case 'H': case 'I': case 'J':\n            case 'K': case 'L': case 'M': case 'N': case 'O':\n            case 'P': case 'Q': case 'R': case 'S': case 'T':\n            case 'U': case 'V': case 'W': case 'X': case 'Y':\n            case 'Z':\n            case '[': case '\\\\': case ']': case '^': case '_':\n            case 'a': case 'b': case 'c': case 'd': case 'e':\n            case 'f': case 'g': case 'h': case 'i': case 'j':\n            case 'k': case 'l': case 'm': case 'n': case 'o':\n            case 'p': case 'q': case 'r': case 's': case 't':\n            case 'u': case 'v': case 'w': case 'x': case 'y':\n            case 'z': case '{': case '|': case '}': case '~':\n              /* These characters are printable ASCII characters.  */\n              p++;\n              width++;\n              break;\n            default:\n              /* If we have a multibyte sequence, scan it up to its end.  */\n              {\n                mbstate_t mbstate;\n                memset (&mbstate, 0, sizeof mbstate);\n                do\n                  {\n                    wchar_t wc;\n                    size_t bytes;\n                    int w;\n\n                    bytes = mbrtowc (&wc, p, plimit - p, &mbstate);\n\n                    if (bytes == (size_t) -1)\n                      /* An invalid multibyte sequence was encountered.  */\n                      {\n                        if (!(flags & MBSW_REJECT_INVALID))\n                          {\n                            p++;\n                            width++;\n                            break;\n                          }\n                        else\n                          return -1;\n                      }\n\n                    if (bytes == (size_t) -2)\n                      /* An incomplete multibyte character at the end.  */\n                      {\n                        if (!(flags & MBSW_REJECT_INVALID))\n                          {\n                            p = plimit;\n                            width++;\n                            break;\n                          }\n                        else\n                          return -1;\n                      }\n\n                    if (bytes == 0)\n                      /* A null wide character was encountered.  */\n                      bytes = 1;\n\n                    w = wcwidth (wc);\n                    if (w >= 0)\n                      /* A printable multibyte character.  */\n                      {\n                        if (w > INT_MAX - width)\n                          goto overflow;\n                        width += w;\n                      }\n                    else\n                      /* An unprintable multibyte character.  */\n                      if (!(flags & MBSW_REJECT_UNPRINTABLE))\n                        {\n                          if (!iswcntrl (wc))\n                            {\n                              if (width == INT_MAX)\n                                goto overflow;\n                              width++;\n                            }\n                        }\n                      else\n                        return -1;\n\n                    p += bytes;\n                  }\n                while (! mbsinit (&mbstate));\n              }\n              break;\n          }\n      return width;\n    }\n\n  while (p < plimit)\n    {\n      unsigned char c = (unsigned char) *p++;\n\n      if (isprint (c))\n        {\n          if (width == INT_MAX)\n            goto overflow;\n          width++;\n        }\n      else if (!(flags & MBSW_REJECT_UNPRINTABLE))\n        {\n          if (!iscntrl (c))\n            {\n              if (width == INT_MAX)\n                goto overflow;\n              width++;\n            }\n        }\n      else\n        return -1;\n    }\n  return width;\n\n overflow:\n  return INT_MAX;\n}",
      "lines": 138,
      "depth": 20,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/mbswidth.h": {},
  "findutils/findutils-4.6.0/gl/lib/mbtowc-impl.h": {
    "mbtowc": {
      "start_point": [
        21,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "int\nmbtowc (wchar_t *pwc, const char *s, size_t n)\n{\n  if (s == NULL)\n    return 0;\n  else\n    {\n      mbstate_t state;\n      wchar_t wc;\n      size_t result;\n\n      memset (&state, 0, sizeof (mbstate_t));\n      result = mbrtowc (&wc, s, n, &state);\n      if (result == (size_t)-1 || result == (size_t)-2)\n        {\n          errno = EILSEQ;\n          return -1;\n        }\n      if (pwc != NULL)\n        *pwc = wc;\n      return (wc == 0 ? 0 : result);\n    }\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/mbtowc.c": {},
  "findutils/findutils-4.6.0/gl/lib/mbuiter.c": {},
  "findutils/findutils-4.6.0/gl/lib/mbuiter.h": {
    "mbuiter_multi_next": {
      "start_point": [
        130,
        0
      ],
      "end_point": [
        189,
        1
      ],
      "content": "MBUITER_INLINE void\nmbuiter_multi_next (struct mbuiter_multi *iter)\n{\n  if (iter->next_done)\n    return;\n  if (iter->in_shift)\n    goto with_shift;\n  /* Handle most ASCII characters quickly, without calling mbrtowc().  */\n  if (is_basic (*iter->cur.ptr))\n    {\n      /* These characters are part of the basic character set.  ISO C 99\n         guarantees that their wide character code is identical to their\n         char code.  */\n      iter->cur.bytes = 1;\n      iter->cur.wc = *iter->cur.ptr;\n      iter->cur.wc_valid = true;\n    }\n  else\n    {\n      assert (mbsinit (&iter->state));\n      iter->in_shift = true;\n    with_shift:\n      iter->cur.bytes = mbrtowc (&iter->cur.wc, iter->cur.ptr,\n                                 strnlen1 (iter->cur.ptr, MB_CUR_MAX),\n                                 &iter->state);\n      if (iter->cur.bytes == (size_t) -1)\n        {\n          /* An invalid multibyte sequence was encountered.  */\n          iter->cur.bytes = 1;\n          iter->cur.wc_valid = false;\n          /* Whether to set iter->in_shift = false and reset iter->state\n             or not is not very important; the string is bogus anyway.  */\n        }\n      else if (iter->cur.bytes == (size_t) -2)\n        {\n          /* An incomplete multibyte character at the end.  */\n          iter->cur.bytes = strlen (iter->cur.ptr);\n          iter->cur.wc_valid = false;\n          /* Whether to set iter->in_shift = false and reset iter->state\n             or not is not important; the string end is reached anyway.  */\n        }\n      else\n        {\n          if (iter->cur.bytes == 0)\n            {\n              /* A null wide character was encountered.  */\n              iter->cur.bytes = 1;\n              assert (*iter->cur.ptr == '\\0');\n              assert (iter->cur.wc == 0);\n            }\n          iter->cur.wc_valid = true;\n\n          /* When in the initial state, we can go back treating ASCII\n             characters more quickly.  */\n          if (mbsinit (&iter->state))\n            iter->in_shift = false;\n        }\n    }\n  iter->next_done = true;\n}",
      "lines": 60,
      "depth": 17,
      "decorators": [
        "MBUITER_INLINE",
        "void",
        "void"
      ]
    },
    "mbuiter_multi_reloc": {
      "start_point": [
        191,
        0
      ],
      "end_point": [
        195,
        1
      ],
      "content": "MBUITER_INLINE void\nmbuiter_multi_reloc (struct mbuiter_multi *iter, ptrdiff_t ptrdiff)\n{\n  iter->cur.ptr += ptrdiff;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "MBUITER_INLINE",
        "void",
        "void"
      ]
    },
    "mbuiter_multi_copy": {
      "start_point": [
        197,
        0
      ],
      "end_point": [
        206,
        1
      ],
      "content": "MBUITER_INLINE void\nmbuiter_multi_copy (struct mbuiter_multi *new_iter, const struct mbuiter_multi *old_iter)\n{\n  if ((new_iter->in_shift = old_iter->in_shift))\n    memcpy (&new_iter->state, &old_iter->state, sizeof (mbstate_t));\n  else\n    memset (&new_iter->state, 0, sizeof (mbstate_t));\n  new_iter->next_done = old_iter->next_done;\n  mb_copy (&new_iter->cur, &old_iter->cur);\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "MBUITER_INLINE",
        "void",
        "void"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/memchr.c": {
    "__memchr": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        168,
        1
      ],
      "content": "void *\n__memchr (void const *s, int c_in, size_t n)\n{\n  /* On 32-bit hardware, choosing longword to be a 32-bit unsigned\n     long instead of a 64-bit uintmax_t tends to give better\n     performance.  On 64-bit hardware, unsigned long is generally 64\n     bits already.  Change this typedef to experiment with\n     performance.  */\n  typedef unsigned long int longword;\n\n  const unsigned char *char_ptr;\n  const longword *longword_ptr;\n  longword repeated_one;\n  longword repeated_c;\n  unsigned reg_char c;\n\n  c = (unsigned char) c_in;\n\n  /* Handle the first few bytes by reading one byte at a time.\n     Do this until CHAR_PTR is aligned on a longword boundary.  */\n  for (char_ptr = (const unsigned char *) s;\n       n > 0 && (size_t) char_ptr % sizeof (longword) != 0;\n       --n, ++char_ptr)\n    if (*char_ptr == c)\n      return (void *) char_ptr;\n\n  longword_ptr = (const longword *) char_ptr;\n\n  /* All these elucidatory comments refer to 4-byte longwords,\n     but the theory applies equally well to any size longwords.  */\n\n  /* Compute auxiliary longword values:\n     repeated_one is a value which has a 1 in every byte.\n     repeated_c has c in every byte.  */\n  repeated_one = 0x01010101;\n  repeated_c = c | (c << 8);\n  repeated_c |= repeated_c << 16;\n  if (0xffffffffU < (longword) -1)\n    {\n      repeated_one |= repeated_one << 31 << 1;\n      repeated_c |= repeated_c << 31 << 1;\n      if (8 < sizeof (longword))\n        {\n          size_t i;\n\n          for (i = 64; i < sizeof (longword) * 8; i *= 2)\n            {\n              repeated_one |= repeated_one << i;\n              repeated_c |= repeated_c << i;\n            }\n        }\n    }\n\n  /* Instead of the traditional loop which tests each byte, we will test a\n     longword at a time.  The tricky part is testing if *any of the four*\n     bytes in the longword in question are equal to c.  We first use an xor\n     with repeated_c.  This reduces the task to testing whether *any of the\n     four* bytes in longword1 is zero.\n\n     We compute tmp =\n       ((longword1 - repeated_one) & ~longword1) & (repeated_one << 7).\n     That is, we perform the following operations:\n       1. Subtract repeated_one.\n       2. & ~longword1.\n       3. & a mask consisting of 0x80 in every byte.\n     Consider what happens in each byte:\n       - If a byte of longword1 is zero, step 1 and 2 transform it into 0xff,\n         and step 3 transforms it into 0x80.  A carry can also be propagated\n         to more significant bytes.\n       - If a byte of longword1 is nonzero, let its lowest 1 bit be at\n         position k (0 <= k <= 7); so the lowest k bits are 0.  After step 1,\n         the byte ends in a single bit of value 0 and k bits of value 1.\n         After step 2, the result is just k bits of value 1: 2^k - 1.  After\n         step 3, the result is 0.  And no carry is produced.\n     So, if longword1 has only non-zero bytes, tmp is zero.\n     Whereas if longword1 has a zero byte, call j the position of the least\n     significant zero byte.  Then the result has a zero at positions 0, ...,\n     j-1 and a 0x80 at position j.  We cannot predict the result at the more\n     significant bytes (positions j+1..3), but it does not matter since we\n     already have a non-zero bit at position 8*j+7.\n\n     So, the test whether any byte in longword1 is zero is equivalent to\n     testing whether tmp is nonzero.  */\n\n  while (n >= sizeof (longword))\n    {\n      longword longword1 = *longword_ptr ^ repeated_c;\n\n      if ((((longword1 - repeated_one) & ~longword1)\n           & (repeated_one << 7)) != 0)\n        break;\n      longword_ptr++;\n      n -= sizeof (longword);\n    }\n\n  char_ptr = (const unsigned char *) longword_ptr;\n\n  /* At this point, we know that either n < sizeof (longword), or one of the\n     sizeof (longword) bytes starting at char_ptr is == c.  On little-endian\n     machines, we could determine the first such byte without any further\n     memory accesses, just by looking at the tmp result from the last loop\n     iteration.  But this does not work on big-endian machines.  Choose code\n     that works in both cases.  */\n\n  for (; n > 0; --n, ++char_ptr)\n    {\n      if (*char_ptr == c)\n        return (void *) char_ptr;\n    }\n\n  return NULL;\n}",
      "lines": 112,
      "depth": 14,
      "decorators": [
        "void",
        "*\n__memchr (void const *s, int c_in, size_t n)",
        "*"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/mempcpy.c": {
    "mempcpy": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        27,
        1
      ],
      "content": "void *\nmempcpy (void *dest, const void *src, size_t n)\n{\n  return (char *) memcpy (dest, src, n) + n;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void",
        "*\nmempcpy (void *dest, const void *src, size_t n)",
        "*"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/memrchr.c": {
    "__memrchr": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        157,
        1
      ],
      "content": "void *\n__memrchr (void const *s, int c_in, size_t n)\n{\n  /* On 32-bit hardware, choosing longword to be a 32-bit unsigned\n     long instead of a 64-bit uintmax_t tends to give better\n     performance.  On 64-bit hardware, unsigned long is generally 64\n     bits already.  Change this typedef to experiment with\n     performance.  */\n  typedef unsigned long int longword;\n\n  const unsigned char *char_ptr;\n  const longword *longword_ptr;\n  longword repeated_one;\n  longword repeated_c;\n  unsigned reg_char c;\n\n  c = (unsigned char) c_in;\n\n  /* Handle the last few bytes by reading one byte at a time.\n     Do this until CHAR_PTR is aligned on a longword boundary.  */\n  for (char_ptr = (const unsigned char *) s + n;\n       n > 0 && (size_t) char_ptr % sizeof (longword) != 0;\n       --n)\n    if (*--char_ptr == c)\n      return (void *) char_ptr;\n\n  longword_ptr = (const longword *) char_ptr;\n\n  /* All these elucidatory comments refer to 4-byte longwords,\n     but the theory applies equally well to any size longwords.  */\n\n  /* Compute auxiliary longword values:\n     repeated_one is a value which has a 1 in every byte.\n     repeated_c has c in every byte.  */\n  repeated_one = 0x01010101;\n  repeated_c = c | (c << 8);\n  repeated_c |= repeated_c << 16;\n  if (0xffffffffU < (longword) -1)\n    {\n      repeated_one |= repeated_one << 31 << 1;\n      repeated_c |= repeated_c << 31 << 1;\n      if (8 < sizeof (longword))\n        {\n          size_t i;\n\n          for (i = 64; i < sizeof (longword) * 8; i *= 2)\n            {\n              repeated_one |= repeated_one << i;\n              repeated_c |= repeated_c << i;\n            }\n        }\n    }\n\n  /* Instead of the traditional loop which tests each byte, we will test a\n     longword at a time.  The tricky part is testing if *any of the four*\n     bytes in the longword in question are equal to c.  We first use an xor\n     with repeated_c.  This reduces the task to testing whether *any of the\n     four* bytes in longword1 is zero.\n\n     We compute tmp =\n       ((longword1 - repeated_one) & ~longword1) & (repeated_one << 7).\n     That is, we perform the following operations:\n       1. Subtract repeated_one.\n       2. & ~longword1.\n       3. & a mask consisting of 0x80 in every byte.\n     Consider what happens in each byte:\n       - If a byte of longword1 is zero, step 1 and 2 transform it into 0xff,\n         and step 3 transforms it into 0x80.  A carry can also be propagated\n         to more significant bytes.\n       - If a byte of longword1 is nonzero, let its lowest 1 bit be at\n         position k (0 <= k <= 7); so the lowest k bits are 0.  After step 1,\n         the byte ends in a single bit of value 0 and k bits of value 1.\n         After step 2, the result is just k bits of value 1: 2^k - 1.  After\n         step 3, the result is 0.  And no carry is produced.\n     So, if longword1 has only non-zero bytes, tmp is zero.\n     Whereas if longword1 has a zero byte, call j the position of the least\n     significant zero byte.  Then the result has a zero at positions 0, ...,\n     j-1 and a 0x80 at position j.  We cannot predict the result at the more\n     significant bytes (positions j+1..3), but it does not matter since we\n     already have a non-zero bit at position 8*j+7.\n\n     So, the test whether any byte in longword1 is zero is equivalent to\n     testing whether tmp is nonzero.  */\n\n  while (n >= sizeof (longword))\n    {\n      longword longword1 = *--longword_ptr ^ repeated_c;\n\n      if ((((longword1 - repeated_one) & ~longword1)\n           & (repeated_one << 7)) != 0)\n        {\n          longword_ptr++;\n          break;\n        }\n      n -= sizeof (longword);\n    }\n\n  char_ptr = (const unsigned char *) longword_ptr;\n\n  /* At this point, we know that either n < sizeof (longword), or one of the\n     sizeof (longword) bytes starting at char_ptr is == c.  On little-endian\n     machines, we could determine the first such byte without any further\n     memory accesses, just by looking at the tmp result from the last loop\n     iteration.  But this does not work on big-endian machines.  Choose code\n     that works in both cases.  */\n\n  while (n-- > 0)\n    {\n      if (*--char_ptr == c)\n        return (void *) char_ptr;\n    }\n\n  return NULL;\n}",
      "lines": 114,
      "depth": 14,
      "decorators": [
        "void",
        "*\n__memrchr (void const *s, int c_in, size_t n)",
        "*"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/mktime-internal.h": {},
  "findutils/findutils-4.6.0/gl/lib/mktime.c": {
    "leapyear": {
      "start_point": [
        144,
        0
      ],
      "end_point": [
        153,
        1
      ],
      "content": "static int\nleapyear (long_int year)\n{\n  /* Don't add YEAR to TM_YEAR_BASE, as that might overflow.\n     Also, work even if YEAR is negative.  */\n  return\n    ((year & 3) == 0\n     && (year % 100 != 0\n\t || ((year / 100) & 3) == (- (TM_YEAR_BASE / 100) & 3)));\n}",
      "lines": 10,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "isdst_differ": {
      "start_point": [
        181,
        0
      ],
      "end_point": [
        185,
        1
      ],
      "content": "static int\nisdst_differ (int a, int b)\n{\n  return (!a != !b) && (0 <= a) && (0 <= b);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "ydhms_diff": {
      "start_point": [
        198,
        0
      ],
      "end_point": [
        223,
        1
      ],
      "content": "static time_t\nydhms_diff (long_int year1, long_int yday1, int hour1, int min1, int sec1,\n\t    int year0, int yday0, int hour0, int min0, int sec0)\n{\n  verify (C99_integer_division, -1 / 2 == 0);\n\n  /* Compute intervening leap days correctly even if year is negative.\n     Take care to avoid integer overflow here.  */\n  int a4 = SHR (year1, 2) + SHR (TM_YEAR_BASE, 2) - ! (year1 & 3);\n  int b4 = SHR (year0, 2) + SHR (TM_YEAR_BASE, 2) - ! (year0 & 3);\n  int a100 = a4 / 25 - (a4 % 25 < 0);\n  int b100 = b4 / 25 - (b4 % 25 < 0);\n  int a400 = SHR (a100, 2);\n  int b400 = SHR (b100, 2);\n  int intervening_leap_days = (a4 - b4) - (a100 - b100) + (a400 - b400);\n\n  /* Compute the desired time in time_t precision.  Overflow might\n     occur here.  */\n  time_t tyear1 = year1;\n  time_t years = tyear1 - year0;\n  time_t days = 365 * years + yday1 - yday0 + intervening_leap_days;\n  time_t hours = 24 * days + hour1 - hour0;\n  time_t minutes = 60 * hours + min1 - min0;\n  time_t seconds = 60 * minutes + sec1 - sec0;\n  return seconds;\n}",
      "lines": 26,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "time_t"
      ]
    },
    "time_t_avg": {
      "start_point": [
        226,
        0
      ],
      "end_point": [
        230,
        1
      ],
      "content": "static time_t\ntime_t_avg (time_t a, time_t b)\n{\n  return SHR (a, 1) + SHR (b, 1) + (a & b & 1);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "time_t"
      ]
    },
    "time_t_add_ok": {
      "start_point": [
        235,
        0
      ],
      "end_point": [
        253,
        1
      ],
      "content": "static int\ntime_t_add_ok (time_t a, time_t b)\n{\n  if (! TYPE_SIGNED (time_t))\n    {\n      time_t sum = a + b;\n      return (sum < a) == (TIME_T_MIDPOINT <= b);\n    }\n  else if (WRAPV)\n    {\n      time_t sum = a + b;\n      return (sum < a) == (b < 0);\n    }\n  else\n    {\n      time_t avg = time_t_avg (a, b);\n      return TIME_T_MIN / 2 <= avg && avg <= TIME_T_MAX / 2;\n    }\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "time_t_int_add_ok": {
      "start_point": [
        256,
        0
      ],
      "end_point": [
        271,
        1
      ],
      "content": "static int\ntime_t_int_add_ok (time_t a, int b)\n{\n  verify (int_no_wider_than_time_t, INT_MAX <= TIME_T_MAX);\n  if (WRAPV)\n    {\n      time_t sum = a + b;\n      return (sum < a) == (b < 0);\n    }\n  else\n    {\n      int a_odd = a & 1;\n      time_t avg = SHR (a, 1) + (SHR (b, 1) + (a_odd & b));\n      return TIME_T_MIN / 2 <= avg && avg <= TIME_T_MAX / 2;\n    }\n}",
      "lines": 16,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "guess_time_tm": {
      "start_point": [
        279,
        0
      ],
      "end_point": [
        300,
        1
      ],
      "content": "static time_t\nguess_time_tm (long_int year, long_int yday, int hour, int min, int sec,\n\t       const time_t *t, const struct tm *tp)\n{\n  if (tp)\n    {\n      time_t d = ydhms_diff (year, yday, hour, min, sec,\n\t\t\t     tp->tm_year, tp->tm_yday,\n\t\t\t     tp->tm_hour, tp->tm_min, tp->tm_sec);\n      if (time_t_add_ok (*t, d))\n\treturn *t + d;\n    }\n\n  /* Overflow occurred one way or another.  Return the nearest result\n     that is actually in range, except don't report a zero difference\n     if the actual difference is nonzero, as that would cause a false\n     match; and don't oscillate between two values, as that would\n     confuse the spring-forward gap detector.  */\n  return (*t < TIME_T_MIDPOINT\n\t  ? (*t <= TIME_T_MIN + 1 ? *t + 1 : TIME_T_MIN)\n\t  : (TIME_T_MAX - 1 <= *t ? *t - 1 : TIME_T_MAX));\n}",
      "lines": 22,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "time_t"
      ]
    },
    "ranged_convert": {
      "start_point": [
        305,
        0
      ],
      "end_point": [
        339,
        1
      ],
      "content": "static struct tm *\nranged_convert (struct tm *(*convert) (const time_t *, struct tm *),\n\t\ttime_t *t, struct tm *tp)\n{\n  struct tm *r = convert (t, tp);\n\n  if (!r && *t)\n    {\n      time_t bad = *t;\n      time_t ok = 0;\n\n      /* BAD is a known unconvertible time_t, and OK is a known good one.\n\t Use binary search to narrow the range between BAD and OK until\n\t they differ by 1.  */\n      while (bad != ok + (bad < 0 ? -1 : 1))\n\t{\n\t  time_t mid = *t = time_t_avg (ok, bad);\n\t  r = convert (t, tp);\n\t  if (r)\n\t    ok = mid;\n\t  else\n\t    bad = mid;\n\t}\n\n      if (!r && ok)\n\t{\n\t  /* The last conversion attempt failed;\n\t     revert to the most recent successful attempt.  */\n\t  *t = ok;\n\t  r = convert (t, tp);\n\t}\n    }\n\n  return r;\n}",
      "lines": 35,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "struct tm",
        "struct",
        "tm",
        "*\nranged_convert (struct tm *(*convert) (const time_t *, struct tm *),\n\t\ttime_t *t, struct tm *tp)",
        "*"
      ]
    },
    "__mktime_internal": {
      "start_point": [
        348,
        0
      ],
      "end_point": [
        570,
        1
      ],
      "content": "time_t\n__mktime_internal (struct tm *tp,\n\t\t   struct tm *(*convert) (const time_t *, struct tm *),\n\t\t   time_t *offset)\n{\n  time_t t, gt, t0, t1, t2;\n  struct tm tm;\n\n  /* The maximum number of probes (calls to CONVERT) should be enough\n     to handle any combinations of time zone rule changes, solar time,\n     leap seconds, and oscillations around a spring-forward gap.\n     POSIX.1 prohibits leap seconds, but some hosts have them anyway.  */\n  int remaining_probes = 6;\n\n  /* Time requested.  Copy it in case CONVERT modifies *TP; this can\n     occur if TP is localtime's returned value and CONVERT is localtime.  */\n  int sec = tp->tm_sec;\n  int min = tp->tm_min;\n  int hour = tp->tm_hour;\n  int mday = tp->tm_mday;\n  int mon = tp->tm_mon;\n  int year_requested = tp->tm_year;\n  int isdst = tp->tm_isdst;\n\n  /* 1 if the previous probe was DST.  */\n  int dst2;\n\n  /* Ensure that mon is in range, and set year accordingly.  */\n  int mon_remainder = mon % 12;\n  int negative_mon_remainder = mon_remainder < 0;\n  int mon_years = mon / 12 - negative_mon_remainder;\n  long_int lyear_requested = year_requested;\n  long_int year = lyear_requested + mon_years;\n\n  /* The other values need not be in range:\n     the remaining code handles minor overflows correctly,\n     assuming int and time_t arithmetic wraps around.\n     Major overflows are caught at the end.  */\n\n  /* Calculate day of year from year, month, and day of month.\n     The result need not be in range.  */\n  int mon_yday = ((__mon_yday[leapyear (year)]\n\t\t   [mon_remainder + 12 * negative_mon_remainder])\n\t\t  - 1);\n  long_int lmday = mday;\n  long_int yday = mon_yday + lmday;\n\n  time_t guessed_offset = *offset;\n\n  int sec_requested = sec;\n\n  if (LEAP_SECONDS_POSSIBLE)\n    {\n      /* Handle out-of-range seconds specially,\n\t since ydhms_tm_diff assumes every minute has 60 seconds.  */\n      if (sec < 0)\n\tsec = 0;\n      if (59 < sec)\n\tsec = 59;\n    }\n\n  /* Invert CONVERT by probing.  First assume the same offset as last\n     time.  */\n\n  t0 = ydhms_diff (year, yday, hour, min, sec,\n\t\t   EPOCH_YEAR - TM_YEAR_BASE, 0, 0, 0, - guessed_offset);\n\n  if (TIME_T_MAX / INT_MAX / 366 / 24 / 60 / 60 < 3)\n    {\n      /* time_t isn't large enough to rule out overflows, so check\n\t for major overflows.  A gross check suffices, since if t0\n\t has overflowed, it is off by a multiple of TIME_T_MAX -\n\t TIME_T_MIN + 1.  So ignore any component of the difference\n\t that is bounded by a small value.  */\n\n      /* Approximate log base 2 of the number of time units per\n\t biennium.  A biennium is 2 years; use this unit instead of\n\t years to avoid integer overflow.  For example, 2 average\n\t Gregorian years are 2 * 365.2425 * 24 * 60 * 60 seconds,\n\t which is 63113904 seconds, and rint (log2 (63113904)) is\n\t 26.  */\n      int ALOG2_SECONDS_PER_BIENNIUM = 26;\n      int ALOG2_MINUTES_PER_BIENNIUM = 20;\n      int ALOG2_HOURS_PER_BIENNIUM = 14;\n      int ALOG2_DAYS_PER_BIENNIUM = 10;\n      int LOG2_YEARS_PER_BIENNIUM = 1;\n\n      int approx_requested_biennia =\n\t(SHR (year_requested, LOG2_YEARS_PER_BIENNIUM)\n\t - SHR (EPOCH_YEAR - TM_YEAR_BASE, LOG2_YEARS_PER_BIENNIUM)\n\t + SHR (mday, ALOG2_DAYS_PER_BIENNIUM)\n\t + SHR (hour, ALOG2_HOURS_PER_BIENNIUM)\n\t + SHR (min, ALOG2_MINUTES_PER_BIENNIUM)\n\t + (LEAP_SECONDS_POSSIBLE\n\t    ? 0\n\t    : SHR (sec, ALOG2_SECONDS_PER_BIENNIUM)));\n\n      int approx_biennia = SHR (t0, ALOG2_SECONDS_PER_BIENNIUM);\n      int diff = approx_biennia - approx_requested_biennia;\n      int approx_abs_diff = diff < 0 ? -1 - diff : diff;\n\n      /* IRIX 4.0.5 cc miscalculates TIME_T_MIN / 3: it erroneously\n\t gives a positive value of 715827882.  Setting a variable\n\t first then doing math on it seems to work.\n\t (ghazi@caip.rutgers.edu) */\n      time_t time_t_max = TIME_T_MAX;\n      time_t time_t_min = TIME_T_MIN;\n      time_t overflow_threshold =\n\t(time_t_max / 3 - time_t_min / 3) >> ALOG2_SECONDS_PER_BIENNIUM;\n\n      if (overflow_threshold < approx_abs_diff)\n\t{\n\t  /* Overflow occurred.  Try repairing it; this might work if\n\t     the time zone offset is enough to undo the overflow.  */\n\t  time_t repaired_t0 = -1 - t0;\n\t  approx_biennia = SHR (repaired_t0, ALOG2_SECONDS_PER_BIENNIUM);\n\t  diff = approx_biennia - approx_requested_biennia;\n\t  approx_abs_diff = diff < 0 ? -1 - diff : diff;\n\t  if (overflow_threshold < approx_abs_diff)\n\t    return -1;\n\t  guessed_offset += repaired_t0 - t0;\n\t  t0 = repaired_t0;\n\t}\n    }\n\n  /* Repeatedly use the error to improve the guess.  */\n\n  for (t = t1 = t2 = t0, dst2 = 0;\n       (gt = guess_time_tm (year, yday, hour, min, sec, &t,\n\t\t\t    ranged_convert (convert, &t, &tm)),\n\tt != gt);\n       t1 = t2, t2 = t, t = gt, dst2 = tm.tm_isdst != 0)\n    if (t == t1 && t != t2\n\t&& (tm.tm_isdst < 0\n\t    || (isdst < 0\n\t\t? dst2 <= (tm.tm_isdst != 0)\n\t\t: (isdst != 0) != (tm.tm_isdst != 0))))\n      /* We can't possibly find a match, as we are oscillating\n\t between two values.  The requested time probably falls\n\t within a spring-forward gap of size GT - T.  Follow the common\n\t practice in this case, which is to return a time that is GT - T\n\t away from the requested time, preferring a time whose\n\t tm_isdst differs from the requested value.  (If no tm_isdst\n\t was requested and only one of the two values has a nonzero\n\t tm_isdst, prefer that value.)  In practice, this is more\n\t useful than returning -1.  */\n      goto offset_found;\n    else if (--remaining_probes == 0)\n      return -1;\n\n  /* We have a match.  Check whether tm.tm_isdst has the requested\n     value, if any.  */\n  if (isdst_differ (isdst, tm.tm_isdst))\n    {\n      /* tm.tm_isdst has the wrong value.  Look for a neighboring\n\t time with the right value, and use its UTC offset.\n\n\t Heuristic: probe the adjacent timestamps in both directions,\n\t looking for the desired isdst.  This should work for all real\n\t time zone histories in the tz database.  */\n\n      /* Distance between probes when looking for a DST boundary.  In\n\t tzdata2003a, the shortest period of DST is 601200 seconds\n\t (e.g., America/Recife starting 2000-10-08 01:00), and the\n\t shortest period of non-DST surrounded by DST is 694800\n\t seconds (Africa/Tunis starting 1943-04-17 01:00).  Use the\n\t minimum of these two values, so we don't miss these short\n\t periods when probing.  */\n      int stride = 601200;\n\n      /* The longest period of DST in tzdata2003a is 536454000 seconds\n\t (e.g., America/Jujuy starting 1946-10-01 01:00).  The longest\n\t period of non-DST is much longer, but it makes no real sense\n\t to search for more than a year of non-DST, so use the DST\n\t max.  */\n      int duration_max = 536454000;\n\n      /* Search in both directions, so the maximum distance is half\n\t the duration; add the stride to avoid off-by-1 problems.  */\n      int delta_bound = duration_max / 2 + stride;\n\n      int delta, direction;\n\n      for (delta = stride; delta < delta_bound; delta += stride)\n\tfor (direction = -1; direction <= 1; direction += 2)\n\t  if (time_t_int_add_ok (t, delta * direction))\n\t    {\n\t      time_t ot = t + delta * direction;\n\t      struct tm otm;\n\t      ranged_convert (convert, &ot, &otm);\n\t      if (! isdst_differ (isdst, otm.tm_isdst))\n\t\t{\n\t\t  /* We found the desired tm_isdst.\n\t\t     Extrapolate back to the desired time.  */\n\t\t  t = guess_time_tm (year, yday, hour, min, sec, &ot, &otm);\n\t\t  ranged_convert (convert, &t, &tm);\n\t\t  goto offset_found;\n\t\t}\n\t    }\n    }\n\n offset_found:\n  *offset = guessed_offset + t - t0;\n\n  if (LEAP_SECONDS_POSSIBLE && sec_requested != tm.tm_sec)\n    {\n      /* Adjust time to reflect the tm_sec requested, not the normalized value.\n\t Also, repair any damage from a false match due to a leap second.  */\n      int sec_adjustment = (sec == 0 && tm.tm_sec == 60) - sec;\n      if (! time_t_int_add_ok (t, sec_requested))\n\treturn -1;\n      t1 = t + sec_requested;\n      if (! time_t_int_add_ok (t1, sec_adjustment))\n\treturn -1;\n      t2 = t1 + sec_adjustment;\n      if (! convert (&t2, &tm))\n\treturn -1;\n      t = t2;\n    }\n\n  *tp = tm;\n  return t;\n}",
      "lines": 223,
      "depth": 16,
      "decorators": [
        "time_t"
      ]
    },
    "mktime": {
      "start_point": [
        580,
        0
      ],
      "end_point": [
        591,
        1
      ],
      "content": "time_t\nmktime (struct tm *tp)\n{\n#ifdef _LIBC\n  /* POSIX.1 8.1.1 requires that whenever mktime() is called, the\n     time zone names contained in the external variable 'tzname' shall\n     be set as if the tzset() function had been called.  */\n  __tzset ();\n#endif\n\n  return __mktime_internal (tp, __localtime_r, &localtime_offset);\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "time_t"
      ]
    },
    "not_equal_tm": {
      "start_point": [
        604,
        0
      ],
      "end_point": [
        615,
        1
      ],
      "content": "static int\nnot_equal_tm (const struct tm *a, const struct tm *b)\n{\n  return ((a->tm_sec ^ b->tm_sec)\n\t  | (a->tm_min ^ b->tm_min)\n\t  | (a->tm_hour ^ b->tm_hour)\n\t  | (a->tm_mday ^ b->tm_mday)\n\t  | (a->tm_mon ^ b->tm_mon)\n\t  | (a->tm_year ^ b->tm_year)\n\t  | (a->tm_yday ^ b->tm_yday)\n\t  | isdst_differ (a->tm_isdst, b->tm_isdst));\n}",
      "lines": 12,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "print_tm": {
      "start_point": [
        617,
        0
      ],
      "end_point": [
        627,
        1
      ],
      "content": "static void\nprint_tm (const struct tm *tp)\n{\n  if (tp)\n    printf (\"%04d-%02d-%02d %02d:%02d:%02d yday %03d wday %d isdst %d\",\n\t    tp->tm_year + TM_YEAR_BASE, tp->tm_mon + 1, tp->tm_mday,\n\t    tp->tm_hour, tp->tm_min, tp->tm_sec,\n\t    tp->tm_yday, tp->tm_wday, tp->tm_isdst);\n  else\n    printf (\"0\");\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "check_result": {
      "start_point": [
        629,
        0
      ],
      "end_point": [
        643,
        1
      ],
      "content": "static int\ncheck_result (time_t tk, struct tm tmk, time_t tl, const struct tm *lt)\n{\n  if (tk != tl || !lt || not_equal_tm (&tmk, lt))\n    {\n      printf (\"mktime (\");\n      print_tm (lt);\n      printf (\")\\nyields (\");\n      print_tm (&tmk);\n      printf (\") == %ld, should be %ld\\n\", (long int) tk, (long int) tl);\n      return 1;\n    }\n\n  return 0;\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        645,
        0
      ],
      "end_point": [
        732,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  int status = 0;\n  struct tm tm, tmk, tml;\n  struct tm *lt;\n  time_t tk, tl, tl1;\n  char trailer;\n\n  if ((argc == 3 || argc == 4)\n      && (sscanf (argv[1], \"%d-%d-%d%c\",\n\t\t  &tm.tm_year, &tm.tm_mon, &tm.tm_mday, &trailer)\n\t  == 3)\n      && (sscanf (argv[2], \"%d:%d:%d%c\",\n\t\t  &tm.tm_hour, &tm.tm_min, &tm.tm_sec, &trailer)\n\t  == 3))\n    {\n      tm.tm_year -= TM_YEAR_BASE;\n      tm.tm_mon--;\n      tm.tm_isdst = argc == 3 ? -1 : atoi (argv[3]);\n      tmk = tm;\n      tl = mktime (&tmk);\n      lt = localtime (&tl);\n      if (lt)\n\t{\n\t  tml = *lt;\n\t  lt = &tml;\n\t}\n      printf (\"mktime returns %ld == \", (long int) tl);\n      print_tm (&tmk);\n      printf (\"\\n\");\n      status = check_result (tl, tmk, tl, lt);\n    }\n  else if (argc == 4 || (argc == 5 && strcmp (argv[4], \"-\") == 0))\n    {\n      time_t from = atol (argv[1]);\n      time_t by = atol (argv[2]);\n      time_t to = atol (argv[3]);\n\n      if (argc == 4)\n\tfor (tl = from; by < 0 ? to <= tl : tl <= to; tl = tl1)\n\t  {\n\t    lt = localtime (&tl);\n\t    if (lt)\n\t      {\n\t\ttmk = tml = *lt;\n\t\ttk = mktime (&tmk);\n\t\tstatus |= check_result (tk, tmk, tl, &tml);\n\t      }\n\t    else\n\t      {\n\t\tprintf (\"localtime (%ld) yields 0\\n\", (long int) tl);\n\t\tstatus = 1;\n\t      }\n\t    tl1 = tl + by;\n\t    if ((tl1 < tl) != (by < 0))\n\t      break;\n\t  }\n      else\n\tfor (tl = from; by < 0 ? to <= tl : tl <= to; tl = tl1)\n\t  {\n\t    /* Null benchmark.  */\n\t    lt = localtime (&tl);\n\t    if (lt)\n\t      {\n\t\ttmk = tml = *lt;\n\t\ttk = tl;\n\t\tstatus |= check_result (tk, tmk, tl, &tml);\n\t      }\n\t    else\n\t      {\n\t\tprintf (\"localtime (%ld) yields 0\\n\", (long int) tl);\n\t\tstatus = 1;\n\t      }\n\t    tl1 = tl + by;\n\t    if ((tl1 < tl) != (by < 0))\n\t      break;\n\t  }\n    }\n  else\n    printf (\"Usage:\\\n\\t%s YYYY-MM-DD HH:MM:SS [ISDST] # Test given time.\\n\\\n\\t%s FROM BY TO # Test values FROM, FROM+BY, ..., TO.\\n\\\n\\t%s FROM BY TO - # Do not test those values (for benchmark).\\n\",\n\t    argv[0], argv[0], argv[0]);\n\n  return status;\n}",
      "lines": 88,
      "depth": 17,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/modechange.c": {
    "octal_to_mode": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "static mode_t\noctal_to_mode (unsigned int octal)\n{\n  /* Help the compiler optimize the usual case where mode_t uses\n     the traditional octal representation.  */\n  return ((S_ISUID == SUID && S_ISGID == SGID && S_ISVTX == SVTX\n           && S_IRUSR == RUSR && S_IWUSR == WUSR && S_IXUSR == XUSR\n           && S_IRGRP == RGRP && S_IWGRP == WGRP && S_IXGRP == XGRP\n           && S_IROTH == ROTH && S_IWOTH == WOTH && S_IXOTH == XOTH)\n          ? octal\n          : (mode_t) ((octal & SUID ? S_ISUID : 0)\n                      | (octal & SGID ? S_ISGID : 0)\n                      | (octal & SVTX ? S_ISVTX : 0)\n                      | (octal & RUSR ? S_IRUSR : 0)\n                      | (octal & WUSR ? S_IWUSR : 0)\n                      | (octal & XUSR ? S_IXUSR : 0)\n                      | (octal & RGRP ? S_IRGRP : 0)\n                      | (octal & WGRP ? S_IWGRP : 0)\n                      | (octal & XGRP ? S_IXGRP : 0)\n                      | (octal & ROTH ? S_IROTH : 0)\n                      | (octal & WOTH ? S_IWOTH : 0)\n                      | (octal & XOTH ? S_IXOTH : 0)));\n}",
      "lines": 23,
      "depth": 22,
      "decorators": [
        "static",
        "static",
        "mode_t"
      ]
    },
    "make_node_op_equals": {
      "start_point": [
        110,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "static struct mode_change *\nmake_node_op_equals (mode_t new_mode, mode_t mentioned)\n{\n  struct mode_change *p = xmalloc (2 * sizeof *p);\n  p->op = '=';\n  p->flag = MODE_ORDINARY_CHANGE;\n  p->affected = CHMOD_MODE_BITS;\n  p->value = new_mode;\n  p->mentioned = mentioned;\n  p[1].flag = MODE_DONE;\n  return p;\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "struct mode_change",
        "struct",
        "mode_change",
        "*\nmake_node_op_equals (mode_t new_mode, mode_t mentioned)",
        "*"
      ]
    },
    "mode_compile": {
      "start_point": [
        132,
        0
      ],
      "end_point": [
        309,
        1
      ],
      "content": "struct mode_change *\nmode_compile (char const *mode_string)\n{\n  /* The array of mode-change directives to be returned.  */\n  struct mode_change *mc;\n  size_t used = 0;\n  char const *p;\n\n  if ('0' <= *mode_string && *mode_string < '8')\n    {\n      unsigned int octal_mode = 0;\n      mode_t mode;\n      mode_t mentioned;\n\n      p = mode_string;\n      do\n        {\n          octal_mode = 8 * octal_mode + *p++ - '0';\n          if (ALLM < octal_mode)\n            return NULL;\n        }\n      while ('0' <= *p && *p < '8');\n\n      if (*p)\n        return NULL;\n\n      mode = octal_to_mode (octal_mode);\n      mentioned = (p - mode_string < 5\n                   ? (mode & (S_ISUID | S_ISGID)) | S_ISVTX | S_IRWXUGO\n                   : CHMOD_MODE_BITS);\n      return make_node_op_equals (mode, mentioned);\n    }\n\n  /* Allocate enough space to hold the result.  */\n  {\n    size_t needed = 1;\n    for (p = mode_string; *p; p++)\n      needed += (*p == '=' || *p == '+' || *p == '-');\n    mc = xnmalloc (needed, sizeof *mc);\n  }\n\n  /* One loop iteration for each\n     '[ugoa]*([-+=]([rwxXst]*|[ugo]))+|[-+=][0-7]+'.  */\n  for (p = mode_string; ; p++)\n    {\n      /* Which bits in the mode are operated on.  */\n      mode_t affected = 0;\n\n      /* Turn on all the bits in 'affected' for each group given.  */\n      for (;; p++)\n        switch (*p)\n          {\n          default:\n            goto invalid;\n          case 'u':\n            affected |= S_ISUID | S_IRWXU;\n            break;\n          case 'g':\n            affected |= S_ISGID | S_IRWXG;\n            break;\n          case 'o':\n            affected |= S_ISVTX | S_IRWXO;\n            break;\n          case 'a':\n            affected |= CHMOD_MODE_BITS;\n            break;\n          case '=': case '+': case '-':\n            goto no_more_affected;\n          }\n    no_more_affected:;\n\n      do\n        {\n          char op = *p++;\n          mode_t value;\n          mode_t mentioned = 0;\n          char flag = MODE_COPY_EXISTING;\n          struct mode_change *change;\n\n          switch (*p)\n            {\n            case '0': case '1': case '2': case '3':\n            case '4': case '5': case '6': case '7':\n              {\n                unsigned int octal_mode = 0;\n\n                do\n                  {\n                    octal_mode = 8 * octal_mode + *p++ - '0';\n                    if (ALLM < octal_mode)\n                      goto invalid;\n                  }\n                while ('0' <= *p && *p < '8');\n\n                if (affected || (*p && *p != ','))\n                  goto invalid;\n                affected = mentioned = CHMOD_MODE_BITS;\n                value = octal_to_mode (octal_mode);\n                flag = MODE_ORDINARY_CHANGE;\n                break;\n              }\n\n            case 'u':\n              /* Set the affected bits to the value of the \"u\" bits\n                 on the same file.  */\n              value = S_IRWXU;\n              p++;\n              break;\n            case 'g':\n              /* Set the affected bits to the value of the \"g\" bits\n                 on the same file.  */\n              value = S_IRWXG;\n              p++;\n              break;\n            case 'o':\n              /* Set the affected bits to the value of the \"o\" bits\n                 on the same file.  */\n              value = S_IRWXO;\n              p++;\n              break;\n\n            default:\n              value = 0;\n              flag = MODE_ORDINARY_CHANGE;\n\n              for (;; p++)\n                switch (*p)\n                  {\n                  case 'r':\n                    value |= S_IRUSR | S_IRGRP | S_IROTH;\n                    break;\n                  case 'w':\n                    value |= S_IWUSR | S_IWGRP | S_IWOTH;\n                    break;\n                  case 'x':\n                    value |= S_IXUSR | S_IXGRP | S_IXOTH;\n                    break;\n                  case 'X':\n                    flag = MODE_X_IF_ANY_X;\n                    break;\n                  case 's':\n                    /* Set the setuid/gid bits if 'u' or 'g' is selected.  */\n                    value |= S_ISUID | S_ISGID;\n                    break;\n                  case 't':\n                    /* Set the \"save text image\" bit if 'o' is selected.  */\n                    value |= S_ISVTX;\n                    break;\n                  default:\n                    goto no_more_values;\n                  }\n            no_more_values:;\n            }\n\n          change = &mc[used++];\n          change->op = op;\n          change->flag = flag;\n          change->affected = affected;\n          change->value = value;\n          change->mentioned =\n            (mentioned ? mentioned : affected ? affected & value : value);\n        }\n      while (*p == '=' || *p == '+' || *p == '-');\n\n      if (*p != ',')\n        break;\n    }\n\n  if (*p == 0)\n    {\n      mc[used].flag = MODE_DONE;\n      return mc;\n    }\n\ninvalid:\n  free (mc);\n  return NULL;\n}",
      "lines": 178,
      "depth": 19,
      "decorators": [
        "struct mode_change",
        "struct",
        "mode_change",
        "*\nmode_compile (char const *mode_string)",
        "*"
      ]
    },
    "mode_create_from_ref": {
      "start_point": [
        314,
        0
      ],
      "end_point": [
        322,
        1
      ],
      "content": "struct mode_change *\nmode_create_from_ref (const char *ref_file)\n{\n  struct stat ref_stats;\n\n  if (stat (ref_file, &ref_stats) != 0)\n    return NULL;\n  return make_node_op_equals (ref_stats.st_mode, CHMOD_MODE_BITS);\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "struct mode_change",
        "struct",
        "mode_change",
        "*\nmode_create_from_ref (const char *ref_file)",
        "*"
      ]
    },
    "mode_adjust": {
      "start_point": [
        337,
        0
      ],
      "end_point": [
        413,
        1
      ],
      "content": "mode_t\nmode_adjust (mode_t oldmode, bool dir, mode_t umask_value,\n             struct mode_change const *changes, mode_t *pmode_bits)\n{\n  /* The adjusted mode.  */\n  mode_t newmode = oldmode & CHMOD_MODE_BITS;\n\n  /* File mode bits that CHANGES cares about.  */\n  mode_t mode_bits = 0;\n\n  for (; changes->flag != MODE_DONE; changes++)\n    {\n      mode_t affected = changes->affected;\n      mode_t omit_change =\n        (dir ? S_ISUID | S_ISGID : 0) & ~ changes->mentioned;\n      mode_t value = changes->value;\n\n      switch (changes->flag)\n        {\n        case MODE_ORDINARY_CHANGE:\n          break;\n\n        case MODE_COPY_EXISTING:\n          /* Isolate in 'value' the bits in 'newmode' to copy.  */\n          value &= newmode;\n\n          /* Copy the isolated bits to the other two parts.  */\n          value |= ((value & (S_IRUSR | S_IRGRP | S_IROTH)\n                     ? S_IRUSR | S_IRGRP | S_IROTH : 0)\n                    | (value & (S_IWUSR | S_IWGRP | S_IWOTH)\n                       ? S_IWUSR | S_IWGRP | S_IWOTH : 0)\n                    | (value & (S_IXUSR | S_IXGRP | S_IXOTH)\n                       ? S_IXUSR | S_IXGRP | S_IXOTH : 0));\n          break;\n\n        case MODE_X_IF_ANY_X:\n          /* Affect the execute bits if execute bits are already set\n             or if the file is a directory.  */\n          if ((newmode & (S_IXUSR | S_IXGRP | S_IXOTH)) | dir)\n            value |= S_IXUSR | S_IXGRP | S_IXOTH;\n          break;\n        }\n\n      /* If WHO was specified, limit the change to the affected bits.\n         Otherwise, apply the umask.  Either way, omit changes as\n         requested.  */\n      value &= (affected ? affected : ~umask_value) & ~ omit_change;\n\n      switch (changes->op)\n        {\n        case '=':\n          /* If WHO was specified, preserve the previous values of\n             bits that are not affected by this change operation.\n             Otherwise, clear all the bits.  */\n          {\n            mode_t preserved = (affected ? ~affected : 0) | omit_change;\n            mode_bits |= CHMOD_MODE_BITS & ~preserved;\n            newmode = (newmode & preserved) | value;\n            break;\n          }\n\n        case '+':\n          mode_bits |= value;\n          newmode |= value;\n          break;\n\n        case '-':\n          mode_bits |= value;\n          newmode &= ~value;\n          break;\n        }\n    }\n\n  if (pmode_bits)\n    *pmode_bits = mode_bits;\n  return newmode;\n}",
      "lines": 77,
      "depth": 19,
      "decorators": [
        "mode_t"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/modechange.h": {},
  "findutils/findutils-4.6.0/gl/lib/modf.c": {
    "modf": {
      "start_point": [
        21,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "double\nmodf (double x, double *iptr)\n{\n  if (isfinite (x))\n    {\n      double integer_part = trunc (x);\n      *iptr = integer_part;\n      return x - integer_part;\n    }\n  else\n    {\n      if (isinf (x))\n        {\n          *iptr = x;\n          return 1.0 / x;\n        }\n      else /* isnand (x) */\n        {\n          *iptr = x;\n          return x;\n        }\n    }\n}",
      "lines": 23,
      "depth": 10,
      "decorators": [
        "double"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/mountlist.c": {
    "me_remote": {
      "start_point": [
        197,
        0
      ],
      "end_point": [
        214,
        1
      ],
      "content": "static bool\nme_remote (char const *fs_name, char const *fs_type _GL_UNUSED)\n{\n  if (fs_name[0] && fs_name[1] == ':')\n    {\n      char drive[4];\n      sprintf (drive, \"%c:\\\\\", fs_name[0]);\n      switch (GetDriveType (drive))\n        {\n        case DRIVE_REMOVABLE:\n        case DRIVE_FIXED:\n        case DRIVE_CDROM:\n        case DRIVE_RAMDISK:\n          return false;\n        }\n    }\n  return true;\n}",
      "lines": 18,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "fstype_to_string": [
      {
        "start_point": [
          231,
          0
        ],
        "end_point": [
          323,
          1
        ],
        "content": "static char *\nfstype_to_string (short int t)\n{\n  switch (t)\n    {\n#  ifdef MOUNT_PC\n    case MOUNT_PC:\n      return \"pc\";\n#  endif\n#  ifdef MOUNT_MFS\n    case MOUNT_MFS:\n      return \"mfs\";\n#  endif\n#  ifdef MOUNT_LO\n    case MOUNT_LO:\n      return \"lo\";\n#  endif\n#  ifdef MOUNT_TFS\n    case MOUNT_TFS:\n      return \"tfs\";\n#  endif\n#  ifdef MOUNT_TMP\n    case MOUNT_TMP:\n      return \"tmp\";\n#  endif\n#  ifdef MOUNT_UFS\n   case MOUNT_UFS:\n     return \"ufs\" ;\n#  endif\n#  ifdef MOUNT_NFS\n   case MOUNT_NFS:\n     return \"nfs\" ;\n#  endif\n#  ifdef MOUNT_MSDOS\n   case MOUNT_MSDOS:\n     return \"msdos\" ;\n#  endif\n#  ifdef MOUNT_LFS\n   case MOUNT_LFS:\n     return \"lfs\" ;\n#  endif\n#  ifdef MOUNT_LOFS\n   case MOUNT_LOFS:\n     return \"lofs\" ;\n#  endif\n#  ifdef MOUNT_FDESC\n   case MOUNT_FDESC:\n     return \"fdesc\" ;\n#  endif\n#  ifdef MOUNT_PORTAL\n   case MOUNT_PORTAL:\n     return \"portal\" ;\n#  endif\n#  ifdef MOUNT_NULL\n   case MOUNT_NULL:\n     return \"null\" ;\n#  endif\n#  ifdef MOUNT_UMAP\n   case MOUNT_UMAP:\n     return \"umap\" ;\n#  endif\n#  ifdef MOUNT_KERNFS\n   case MOUNT_KERNFS:\n     return \"kernfs\" ;\n#  endif\n#  ifdef MOUNT_PROCFS\n   case MOUNT_PROCFS:\n     return \"procfs\" ;\n#  endif\n#  ifdef MOUNT_AFS\n   case MOUNT_AFS:\n     return \"afs\" ;\n#  endif\n#  ifdef MOUNT_CD9660\n   case MOUNT_CD9660:\n     return \"cd9660\" ;\n#  endif\n#  ifdef MOUNT_UNION\n   case MOUNT_UNION:\n     return \"union\" ;\n#  endif\n#  ifdef MOUNT_DEVFS\n   case MOUNT_DEVFS:\n     return \"devfs\" ;\n#  endif\n#  ifdef MOUNT_EXT2FS\n   case MOUNT_EXT2FS:\n     return \"ext2fs\" ;\n#  endif\n    default:\n      return \"?\";\n    }\n}",
        "lines": 93,
        "depth": 9,
        "decorators": [
          "static",
          "static",
          "char",
          "*\nfstype_to_string (short int t)",
          "*"
        ]
      },
      {
        "start_point": [
          339,
          0
        ],
        "end_point": [
          349,
          1
        ],
        "content": "static char *\nfstype_to_string (int t)\n{\n  struct vfs_ent *e;\n\n  e = getvfsbytype (t);\n  if (!e || !e->vfsent_name)\n    return \"none\";\n  else\n    return e->vfsent_name;\n}",
        "lines": 11,
        "depth": 8,
        "decorators": [
          "static",
          "static",
          "char",
          "*\nfstype_to_string (int t)",
          "*"
        ]
      }
    ],
    "fsp_to_string": {
      "start_point": [
        326,
        0
      ],
      "end_point": [
        334,
        1
      ],
      "content": "static char *\nfsp_to_string (const struct statfs *fsp)\n{\n# if HAVE_STRUCT_STATFS_F_FSTYPENAME\n  return (char *) (fsp->f_fstypename);\n# else\n  return fstype_to_string (fsp->f_type);\n# endif\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nfsp_to_string (const struct statfs *fsp)",
        "*"
      ]
    },
    "dev_from_mount_options": {
      "start_point": [
        357,
        0
      ],
      "end_point": [
        385,
        1
      ],
      "content": "static dev_t\ndev_from_mount_options (char const *mount_options)\n{\n  /* GNU/Linux allows file system implementations to define their own\n     meaning for \"dev=\" mount options, so don't trust the meaning\n     here.  */\n# ifndef __linux__\n\n  static char const dev_pattern[] = \",dev=\";\n  char const *devopt = strstr (mount_options, dev_pattern);\n\n  if (devopt)\n    {\n      char const *optval = devopt + sizeof dev_pattern - 1;\n      char *optvalend;\n      unsigned long int dev;\n      errno = 0;\n      dev = strtoul (optval, &optvalend, 16);\n      if (optval != optvalend\n          && (*optvalend == '\\0' || *optvalend == ',')\n          && ! (dev == ULONG_MAX && errno == ERANGE)\n          && dev == (dev_t) dev)\n        return dev;\n    }\n\n# endif\n  (void) mount_options;\n  return -1;\n}",
      "lines": 29,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "dev_t"
      ]
    },
    "unescape_tab": {
      "start_point": [
        394,
        0
      ],
      "end_point": [
        414,
        1
      ],
      "content": "static void\nunescape_tab (char *str)\n{\n  size_t i, j = 0;\n  size_t len = strlen (str) + 1;\n  for (i = 0; i < len; i++)\n    {\n      if (str[i] == '\\\\' && (i + 4 < len)\n          && str[i + 1] >= '0' && str[i + 1] <= '3'\n          && str[i + 2] >= '0' && str[i + 2] <= '7'\n          && str[i + 3] >= '0' && str[i + 3] <= '7')\n        {\n          str[j++] = (str[i + 1] - '0') * 64 +\n                     (str[i + 2] - '0') * 8 +\n                     (str[i + 3] - '0');\n          i += 3;\n        }\n      else\n        str[j++] = str[i];\n    }\n}",
      "lines": 21,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "read_file_system_list": {
      "start_point": [
        422,
        0
      ],
      "end_point": [
        1116,
        1
      ],
      "content": "struct mount_entry *\nread_file_system_list (bool need_fs_type)\n{\n  struct mount_entry *mount_list;\n  struct mount_entry *me;\n  struct mount_entry **mtail = &mount_list;\n  (void) need_fs_type;\n\n#ifdef MOUNTED_LISTMNTENT\n  {\n    struct tabmntent *mntlist, *p;\n    struct mntent *mnt;\n\n    /* the third and fourth arguments could be used to filter mounts,\n       but Crays doesn't seem to have any mounts that we want to\n       remove. Specifically, automount create normal NFS mounts.\n       */\n\n    if (listmntent (&mntlist, KMTAB, NULL, NULL) < 0)\n      return NULL;\n    for (p = mntlist; p; p = p->next)\n      {\n        mnt = p->ment;\n        me = xmalloc (sizeof *me);\n        me->me_devname = xstrdup (mnt->mnt_fsname);\n        me->me_mountdir = xstrdup (mnt->mnt_dir);\n        me->me_mntroot = NULL;\n        me->me_type = xstrdup (mnt->mnt_type);\n        me->me_type_malloced = 1;\n        me->me_dummy = ME_DUMMY (me->me_devname, me->me_type);\n        me->me_remote = ME_REMOTE (me->me_devname, me->me_type);\n        me->me_dev = -1;\n        *mtail = me;\n        mtail = &me->me_next;\n      }\n    freemntlist (mntlist);\n  }\n#endif\n\n#ifdef MOUNTED_GETMNTENT1 /* GNU/Linux, 4.3BSD, SunOS, HP-UX, Dynix, Irix.  */\n  {\n    FILE *fp;\n\n#ifdef __linux__\n    /* Try parsing mountinfo first, as that make device IDs available.\n       Note we could use libmount routines to simplify this parsing a little\n       (and that code is in previous versions of this function), however\n       libmount depends on libselinux which pulls in many dependencies.  */\n    char const *mountinfo = \"/proc/self/mountinfo\";\n    fp = fopen (mountinfo, \"r\");\n    if (fp != NULL)\n      {\n        char *line = NULL;\n        size_t buf_size = 0;\n\n        while (getline (&line, &buf_size, fp) != -1)\n          {\n            unsigned int devmaj, devmin;\n            int target_s, target_e, type_s, type_e;\n            int source_s, source_e, mntroot_s, mntroot_e;\n            char test;\n            char *dash;\n            int rc;\n\n            rc = sscanf(line, \"%*u \"        /* id - discarded  */\n                              \"%*u \"        /* parent - discarded */\n                              \"%u:%u \"      /* dev major:minor  */\n                              \"%n%*s%n \"    /* mountroot */\n                              \"%n%*s%n\"     /* target, start and end  */\n                              \"%c\",         /* more data...  */\n                              &devmaj, &devmin,\n                              &mntroot_s, &mntroot_e,\n                              &target_s, &target_e,\n                              &test);\n\n            if (rc != 3 && rc != 7)  /* 7 if %n included in count.  */\n              continue;\n\n            /* skip optional fields, terminated by \" - \"  */\n            dash = strstr (line + target_e, \" - \");\n            if (! dash)\n              continue;\n\n            rc = sscanf(dash, \" - \"\n                              \"%n%*s%n \"    /* FS type, start and end  */\n                              \"%n%*s%n \"    /* source, start and end  */\n                              \"%c\",         /* more data...  */\n                              &type_s, &type_e,\n                              &source_s, &source_e,\n                              &test);\n            if (rc != 1 && rc != 5)  /* 5 if %n included in count.  */\n              continue;\n\n            /* manipulate the sub-strings in place.  */\n            line[mntroot_e] = '\\0';\n            line[target_e] = '\\0';\n            dash[type_e] = '\\0';\n            dash[source_e] = '\\0';\n            unescape_tab (dash + source_s);\n            unescape_tab (line + target_s);\n            unescape_tab (line + mntroot_s);\n\n            me = xmalloc (sizeof *me);\n\n            me->me_devname = xstrdup (dash + source_s);\n            me->me_mountdir = xstrdup (line + target_s);\n            me->me_mntroot = xstrdup (line + mntroot_s);\n            me->me_type = xstrdup (dash + type_s);\n            me->me_type_malloced = 1;\n            me->me_dev = makedev (devmaj, devmin);\n            /* we pass \"false\" for the \"Bind\" option as that's only\n               significant when the Fs_type is \"none\" which will not be\n               the case when parsing \"/proc/self/mountinfo\", and only\n               applies for static /etc/mtab files.  */\n            me->me_dummy = ME_DUMMY (me->me_devname, me->me_type, false);\n            me->me_remote = ME_REMOTE (me->me_devname, me->me_type);\n\n            /* Add to the linked list. */\n            *mtail = me;\n            mtail = &me->me_next;\n          }\n\n        free (line);\n\n        if (ferror (fp))\n          {\n            int saved_errno = errno;\n            fclose (fp);\n            errno = saved_errno;\n            goto free_then_fail;\n          }\n\n        if (fclose (fp) == EOF)\n          goto free_then_fail;\n      }\n    else /* fallback to /proc/self/mounts (/etc/mtab).  */\n#endif /* __linux __ */\n      {\n        struct mntent *mnt;\n        char const *table = MOUNTED;\n\n        fp = setmntent (table, \"r\");\n        if (fp == NULL)\n          return NULL;\n\n        while ((mnt = getmntent (fp)))\n          {\n            bool bind = hasmntopt (mnt, \"bind\");\n\n            me = xmalloc (sizeof *me);\n            me->me_devname = xstrdup (mnt->mnt_fsname);\n            me->me_mountdir = xstrdup (mnt->mnt_dir);\n            me->me_mntroot = NULL;\n            me->me_type = xstrdup (mnt->mnt_type);\n            me->me_type_malloced = 1;\n            me->me_dummy = ME_DUMMY (me->me_devname, me->me_type, bind);\n            me->me_remote = ME_REMOTE (me->me_devname, me->me_type);\n            me->me_dev = dev_from_mount_options (mnt->mnt_opts);\n\n            /* Add to the linked list. */\n            *mtail = me;\n            mtail = &me->me_next;\n          }\n\n        if (endmntent (fp) == 0)\n          goto free_then_fail;\n      }\n  }\n#endif /* MOUNTED_GETMNTENT1. */\n\n#ifdef MOUNTED_GETMNTINFO       /* 4.4BSD.  */\n  {\n    struct statfs *fsp;\n    int entries;\n\n    entries = getmntinfo (&fsp, MNT_NOWAIT);\n    if (entries < 0)\n      return NULL;\n    for (; entries-- > 0; fsp++)\n      {\n        char *fs_type = fsp_to_string (fsp);\n\n        me = xmalloc (sizeof *me);\n        me->me_devname = xstrdup (fsp->f_mntfromname);\n        me->me_mountdir = xstrdup (fsp->f_mntonname);\n        me->me_mntroot = NULL;\n        me->me_type = fs_type;\n        me->me_type_malloced = 0;\n        me->me_dummy = ME_DUMMY (me->me_devname, me->me_type);\n        me->me_remote = ME_REMOTE (me->me_devname, me->me_type);\n        me->me_dev = (dev_t) -1;        /* Magic; means not known yet. */\n\n        /* Add to the linked list. */\n        *mtail = me;\n        mtail = &me->me_next;\n      }\n  }\n#endif /* MOUNTED_GETMNTINFO */\n\n#ifdef MOUNTED_GETMNTINFO2      /* NetBSD 3.0.  */\n  {\n    struct statvfs *fsp;\n    int entries;\n\n    entries = getmntinfo (&fsp, MNT_NOWAIT);\n    if (entries < 0)\n      return NULL;\n    for (; entries-- > 0; fsp++)\n      {\n        me = xmalloc (sizeof *me);\n        me->me_devname = xstrdup (fsp->f_mntfromname);\n        me->me_mountdir = xstrdup (fsp->f_mntonname);\n        me->me_mntroot = NULL;\n        me->me_type = xstrdup (fsp->f_fstypename);\n        me->me_type_malloced = 1;\n        me->me_dummy = ME_DUMMY (me->me_devname, me->me_type);\n        me->me_remote = ME_REMOTE (me->me_devname, me->me_type);\n        me->me_dev = (dev_t) -1;        /* Magic; means not known yet. */\n\n        /* Add to the linked list. */\n        *mtail = me;\n        mtail = &me->me_next;\n      }\n  }\n#endif /* MOUNTED_GETMNTINFO2 */\n\n#ifdef MOUNTED_GETMNT           /* Ultrix.  */\n  {\n    int offset = 0;\n    int val;\n    struct fs_data fsd;\n\n    while (errno = 0,\n           0 < (val = getmnt (&offset, &fsd, sizeof (fsd), NOSTAT_MANY,\n                              (char *) 0)))\n      {\n        me = xmalloc (sizeof *me);\n        me->me_devname = xstrdup (fsd.fd_req.devname);\n        me->me_mountdir = xstrdup (fsd.fd_req.path);\n        me->me_mntroot = NULL;\n        me->me_type = gt_names[fsd.fd_req.fstype];\n        me->me_type_malloced = 0;\n        me->me_dummy = ME_DUMMY (me->me_devname, me->me_type);\n        me->me_remote = ME_REMOTE (me->me_devname, me->me_type);\n        me->me_dev = fsd.fd_req.dev;\n\n        /* Add to the linked list. */\n        *mtail = me;\n        mtail = &me->me_next;\n      }\n    if (val < 0)\n      goto free_then_fail;\n  }\n#endif /* MOUNTED_GETMNT. */\n\n#if defined MOUNTED_FS_STAT_DEV /* BeOS */\n  {\n    /* The next_dev() and fs_stat_dev() system calls give the list of\n       all file systems, including the information returned by statvfs()\n       (fs type, total blocks, free blocks etc.), but without the mount\n       point. But on BeOS all file systems except / are mounted in the\n       rootfs, directly under /.\n       The directory name of the mount point is often, but not always,\n       identical to the volume name of the device.\n       We therefore get the list of subdirectories of /, and the list\n       of all file systems, and match the two lists.  */\n\n    DIR *dirp;\n    struct rootdir_entry\n      {\n        char *name;\n        dev_t dev;\n        ino_t ino;\n        struct rootdir_entry *next;\n      };\n    struct rootdir_entry *rootdir_list;\n    struct rootdir_entry **rootdir_tail;\n    int32 pos;\n    dev_t dev;\n    fs_info fi;\n\n    /* All volumes are mounted in the rootfs, directly under /. */\n    rootdir_list = NULL;\n    rootdir_tail = &rootdir_list;\n    dirp = opendir (\"/\");\n    if (dirp)\n      {\n        struct dirent *d;\n\n        while ((d = readdir (dirp)) != NULL)\n          {\n            char *name;\n            struct stat statbuf;\n\n            if (strcmp (d->d_name, \"..\") == 0)\n              continue;\n\n            if (strcmp (d->d_name, \".\") == 0)\n              name = xstrdup (\"/\");\n            else\n              {\n                name = xmalloc (1 + strlen (d->d_name) + 1);\n                name[0] = '/';\n                strcpy (name + 1, d->d_name);\n              }\n\n            if (lstat (name, &statbuf) >= 0 && S_ISDIR (statbuf.st_mode))\n              {\n                struct rootdir_entry *re = xmalloc (sizeof *re);\n                re->name = name;\n                re->dev = statbuf.st_dev;\n                re->ino = statbuf.st_ino;\n\n                /* Add to the linked list.  */\n                *rootdir_tail = re;\n                rootdir_tail = &re->next;\n              }\n            else\n              free (name);\n          }\n        closedir (dirp);\n      }\n    *rootdir_tail = NULL;\n\n    for (pos = 0; (dev = next_dev (&pos)) >= 0; )\n      if (fs_stat_dev (dev, &fi) >= 0)\n        {\n          /* Note: fi.dev == dev. */\n          struct rootdir_entry *re;\n\n          for (re = rootdir_list; re; re = re->next)\n            if (re->dev == fi.dev && re->ino == fi.root)\n              break;\n\n          me = xmalloc (sizeof *me);\n          me->me_devname = xstrdup (fi.device_name[0] != '\\0'\n                                    ? fi.device_name : fi.fsh_name);\n          me->me_mountdir = xstrdup (re != NULL ? re->name : fi.fsh_name);\n          me->me_mntroot = NULL;\n          me->me_type = xstrdup (fi.fsh_name);\n          me->me_type_malloced = 1;\n          me->me_dev = fi.dev;\n          me->me_dummy = 0;\n          me->me_remote = (fi.flags & B_FS_IS_SHARED) != 0;\n\n          /* Add to the linked list. */\n          *mtail = me;\n          mtail = &me->me_next;\n        }\n    *mtail = NULL;\n\n    while (rootdir_list != NULL)\n      {\n        struct rootdir_entry *re = rootdir_list;\n        rootdir_list = re->next;\n        free (re->name);\n        free (re);\n      }\n  }\n#endif /* MOUNTED_FS_STAT_DEV */\n\n#if defined MOUNTED_GETFSSTAT   /* __alpha running OSF_1 */\n  {\n    int numsys, counter;\n    size_t bufsize;\n    struct statfs *stats;\n\n    numsys = getfsstat (NULL, 0L, MNT_NOWAIT);\n    if (numsys < 0)\n      return NULL;\n    if (SIZE_MAX / sizeof *stats <= numsys)\n      xalloc_die ();\n\n    bufsize = (1 + numsys) * sizeof *stats;\n    stats = xmalloc (bufsize);\n    numsys = getfsstat (stats, bufsize, MNT_NOWAIT);\n\n    if (numsys < 0)\n      {\n        free (stats);\n        return NULL;\n      }\n\n    for (counter = 0; counter < numsys; counter++)\n      {\n        me = xmalloc (sizeof *me);\n        me->me_devname = xstrdup (stats[counter].f_mntfromname);\n        me->me_mountdir = xstrdup (stats[counter].f_mntonname);\n        me->me_mntroot = NULL;\n        me->me_type = xstrdup (FS_TYPE (stats[counter]));\n        me->me_type_malloced = 1;\n        me->me_dummy = ME_DUMMY (me->me_devname, me->me_type);\n        me->me_remote = ME_REMOTE (me->me_devname, me->me_type);\n        me->me_dev = (dev_t) -1;        /* Magic; means not known yet. */\n\n        /* Add to the linked list. */\n        *mtail = me;\n        mtail = &me->me_next;\n      }\n\n    free (stats);\n  }\n#endif /* MOUNTED_GETFSSTAT */\n\n#if defined MOUNTED_FREAD || defined MOUNTED_FREAD_FSTYP /* SVR[23].  */\n  {\n    struct mnttab mnt;\n    char *table = \"/etc/mnttab\";\n    FILE *fp;\n\n    fp = fopen (table, \"r\");\n    if (fp == NULL)\n      return NULL;\n\n    while (fread (&mnt, sizeof mnt, 1, fp) > 0)\n      {\n        me = xmalloc (sizeof *me);\n# ifdef GETFSTYP                        /* SVR3.  */\n        me->me_devname = xstrdup (mnt.mt_dev);\n# else\n        me->me_devname = xmalloc (strlen (mnt.mt_dev) + 6);\n        strcpy (me->me_devname, \"/dev/\");\n        strcpy (me->me_devname + 5, mnt.mt_dev);\n# endif\n        me->me_mountdir = xstrdup (mnt.mt_filsys);\n        me->me_mntroot = NULL;\n        me->me_dev = (dev_t) -1;        /* Magic; means not known yet. */\n        me->me_type = \"\";\n        me->me_type_malloced = 0;\n# ifdef GETFSTYP                        /* SVR3.  */\n        if (need_fs_type)\n          {\n            struct statfs fsd;\n            char typebuf[FSTYPSZ];\n\n            if (statfs (me->me_mountdir, &fsd, sizeof fsd, 0) != -1\n                && sysfs (GETFSTYP, fsd.f_fstyp, typebuf) != -1)\n              {\n                me->me_type = xstrdup (typebuf);\n                me->me_type_malloced = 1;\n              }\n          }\n# endif\n        me->me_dummy = ME_DUMMY (me->me_devname, me->me_type);\n        me->me_remote = ME_REMOTE (me->me_devname, me->me_type);\n\n        /* Add to the linked list. */\n        *mtail = me;\n        mtail = &me->me_next;\n      }\n\n    if (ferror (fp))\n      {\n        /* The last fread() call must have failed.  */\n        int saved_errno = errno;\n        fclose (fp);\n        errno = saved_errno;\n        goto free_then_fail;\n      }\n\n    if (fclose (fp) == EOF)\n      goto free_then_fail;\n  }\n#endif /* MOUNTED_FREAD || MOUNTED_FREAD_FSTYP.  */\n\n#ifdef MOUNTED_GETMNTTBL        /* DolphinOS goes its own way.  */\n  {\n    struct mntent **mnttbl = getmnttbl (), **ent;\n    for (ent = mnttbl; *ent; ent++)\n      {\n        me = xmalloc (sizeof *me);\n        me->me_devname = xstrdup ((*ent)->mt_resource);\n        me->me_mountdir = xstrdup ((*ent)->mt_directory);\n        me->me_mntroot = NULL;\n        me->me_type = xstrdup ((*ent)->mt_fstype);\n        me->me_type_malloced = 1;\n        me->me_dummy = ME_DUMMY (me->me_devname, me->me_type);\n        me->me_remote = ME_REMOTE (me->me_devname, me->me_type);\n        me->me_dev = (dev_t) -1;        /* Magic; means not known yet. */\n\n        /* Add to the linked list. */\n        *mtail = me;\n        mtail = &me->me_next;\n      }\n    endmnttbl ();\n  }\n#endif\n\n#ifdef MOUNTED_GETMNTENT2       /* SVR4.  */\n  {\n    struct mnttab mnt;\n    char *table = MNTTAB;\n    FILE *fp;\n    int ret;\n    int lockfd = -1;\n\n# if defined F_RDLCK && defined F_SETLKW\n    /* MNTTAB_LOCK is a macro name of our own invention; it's not present in\n       e.g. Solaris 2.6.  If the SVR4 folks ever define a macro\n       for this file name, we should use their macro name instead.\n       (Why not just lock MNTTAB directly?  We don't know.)  */\n#  ifndef MNTTAB_LOCK\n#   define MNTTAB_LOCK \"/etc/.mnttab.lock\"\n#  endif\n    lockfd = open (MNTTAB_LOCK, O_RDONLY);\n    if (0 <= lockfd)\n      {\n        struct flock flock;\n        flock.l_type = F_RDLCK;\n        flock.l_whence = SEEK_SET;\n        flock.l_start = 0;\n        flock.l_len = 0;\n        while (fcntl (lockfd, F_SETLKW, &flock) == -1)\n          if (errno != EINTR)\n            {\n              int saved_errno = errno;\n              close (lockfd);\n              errno = saved_errno;\n              return NULL;\n            }\n      }\n    else if (errno != ENOENT)\n      return NULL;\n# endif\n\n    errno = 0;\n    fp = fopen (table, \"r\");\n    if (fp == NULL)\n      ret = errno;\n    else\n      {\n        while ((ret = getmntent (fp, &mnt)) == 0)\n          {\n            me = xmalloc (sizeof *me);\n            me->me_devname = xstrdup (mnt.mnt_special);\n            me->me_mountdir = xstrdup (mnt.mnt_mountp);\n            me->me_mntroot = NULL;\n            me->me_type = xstrdup (mnt.mnt_fstype);\n            me->me_type_malloced = 1;\n            me->me_dummy = MNT_IGNORE (&mnt) != 0;\n            me->me_remote = ME_REMOTE (me->me_devname, me->me_type);\n            me->me_dev = dev_from_mount_options (mnt.mnt_mntopts);\n\n            /* Add to the linked list. */\n            *mtail = me;\n            mtail = &me->me_next;\n          }\n\n        ret = fclose (fp) == EOF ? errno : 0 < ret ? 0 : -1;\n      }\n\n    if (0 <= lockfd && close (lockfd) != 0)\n      ret = errno;\n\n    if (0 <= ret)\n      {\n        errno = ret;\n        goto free_then_fail;\n      }\n  }\n#endif /* MOUNTED_GETMNTENT2.  */\n\n#ifdef MOUNTED_VMOUNT           /* AIX.  */\n  {\n    int bufsize;\n    void *entries;\n    char *thisent;\n    struct vmount *vmp;\n    int n_entries;\n    int i;\n\n    /* Ask how many bytes to allocate for the mounted file system info.  */\n    entries = &bufsize;\n    if (mntctl (MCTL_QUERY, sizeof bufsize, entries) != 0)\n      return NULL;\n    entries = xmalloc (bufsize);\n\n    /* Get the list of mounted file systems.  */\n    n_entries = mntctl (MCTL_QUERY, bufsize, entries);\n    if (n_entries < 0)\n      {\n        int saved_errno = errno;\n        free (entries);\n        errno = saved_errno;\n        return NULL;\n      }\n\n    for (i = 0, thisent = entries;\n         i < n_entries;\n         i++, thisent += vmp->vmt_length)\n      {\n        char *options, *ignore;\n\n        vmp = (struct vmount *) thisent;\n        me = xmalloc (sizeof *me);\n        if (vmp->vmt_flags & MNT_REMOTE)\n          {\n            char *host, *dir;\n\n            me->me_remote = 1;\n            /* Prepend the remote dirname.  */\n            host = thisent + vmp->vmt_data[VMT_HOSTNAME].vmt_off;\n            dir = thisent + vmp->vmt_data[VMT_OBJECT].vmt_off;\n            me->me_devname = xmalloc (strlen (host) + strlen (dir) + 2);\n            strcpy (me->me_devname, host);\n            strcat (me->me_devname, \":\");\n            strcat (me->me_devname, dir);\n          }\n        else\n          {\n            me->me_remote = 0;\n            me->me_devname = xstrdup (thisent +\n                                      vmp->vmt_data[VMT_OBJECT].vmt_off);\n          }\n        me->me_mountdir = xstrdup (thisent + vmp->vmt_data[VMT_STUB].vmt_off);\n        me->me_mntroot = NULL;\n        me->me_type = xstrdup (fstype_to_string (vmp->vmt_gfstype));\n        me->me_type_malloced = 1;\n        options = thisent + vmp->vmt_data[VMT_ARGS].vmt_off;\n        ignore = strstr (options, \"ignore\");\n        me->me_dummy = (ignore\n                        && (ignore == options || ignore[-1] == ',')\n                        && (ignore[sizeof \"ignore\" - 1] == ','\n                            || ignore[sizeof \"ignore\" - 1] == '\\0'));\n        me->me_dev = (dev_t) -1; /* vmt_fsid might be the info we want.  */\n\n        /* Add to the linked list. */\n        *mtail = me;\n        mtail = &me->me_next;\n      }\n    free (entries);\n  }\n#endif /* MOUNTED_VMOUNT. */\n\n#ifdef MOUNTED_INTERIX_STATVFS\n  {\n    DIR *dirp = opendir (\"/dev/fs\");\n    char node[9 + NAME_MAX];\n\n    if (!dirp)\n      goto free_then_fail;\n\n    while (1)\n      {\n        struct statvfs dev;\n        struct dirent entry;\n        struct dirent *result;\n\n        if (readdir_r (dirp, &entry, &result) || result == NULL)\n          break;\n\n        strcpy (node, \"/dev/fs/\");\n        strcat (node, entry.d_name);\n\n        if (statvfs (node, &dev) == 0)\n          {\n            me = xmalloc (sizeof *me);\n            me->me_devname = xstrdup (dev.f_mntfromname);\n            me->me_mountdir = xstrdup (dev.f_mntonname);\n            me->me_mntroot = NULL;\n            me->me_type = xstrdup (dev.f_fstypename);\n            me->me_type_malloced = 1;\n            me->me_dummy = ME_DUMMY (me->me_devname, me->me_type);\n            me->me_remote = ME_REMOTE (me->me_devname, me->me_type);\n            me->me_dev = (dev_t) -1;        /* Magic; means not known yet. */\n\n            /* Add to the linked list. */\n            *mtail = me;\n            mtail = &me->me_next;\n          }\n      }\n    closedir (dirp);\n  }\n#endif /* MOUNTED_INTERIX_STATVFS */\n\n  *mtail = NULL;\n  return mount_list;\n\n\n free_then_fail: _GL_UNUSED_LABEL\n  {\n    int saved_errno = errno;\n    *mtail = NULL;\n\n    while (mount_list)\n      {\n        me = mount_list->me_next;\n        free_mount_entry (mount_list);\n        mount_list = me;\n      }\n\n    errno = saved_errno;\n    return NULL;\n  }\n}",
      "lines": 695,
      "depth": 20,
      "decorators": [
        "struct mount_entry",
        "struct",
        "mount_entry",
        "*\nread_file_system_list (bool need_fs_type)",
        "*"
      ]
    },
    "free_mount_entry": {
      "start_point": [
        1120,
        0
      ],
      "end_point": [
        1128,
        1
      ],
      "content": "void free_mount_entry (struct mount_entry *me)\n{\n  free (me->me_devname);\n  free (me->me_mountdir);\n  free (me->me_mntroot);\n  if (me->me_type_malloced)\n    free (me->me_type);\n  free (me);\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/mountlist.h": {},
  "findutils/findutils-4.6.0/gl/lib/msvc-inval.c": {
    "gl_msvc_invalid_parameter_handler": [
      {
        "start_point": [
          30,
          0
        ],
        "end_point": [
          37,
          1
        ],
        "content": "static void __cdecl\ngl_msvc_invalid_parameter_handler (const wchar_t *expression,\n                                   const wchar_t *function,\n                                   const wchar_t *file,\n                                   unsigned int line,\n                                   uintptr_t dummy)\n{\n}",
        "lines": 8,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void",
          "__cdecl",
          "__cdecl"
        ]
      },
      {
        "start_point": [
          47,
          0
        ],
        "end_point": [
          55,
          1
        ],
        "content": "static void __cdecl\ngl_msvc_invalid_parameter_handler (const wchar_t *expression,\n                                   const wchar_t *function,\n                                   const wchar_t *file,\n                                   unsigned int line,\n                                   uintptr_t dummy)\n{\n  RaiseException (STATUS_GNULIB_INVALID_PARAMETER, 0, 0, NULL);\n}",
        "lines": 9,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void",
          "__cdecl",
          "__cdecl"
        ]
      },
      {
        "start_point": [
          96,
          0
        ],
        "end_point": [
          110,
          1
        ],
        "content": "static void __cdecl\ngl_msvc_invalid_parameter_handler (const wchar_t *expression,\n                                   const wchar_t *function,\n                                   const wchar_t *file,\n                                   unsigned int line,\n                                   uintptr_t dummy)\n{\n  struct gl_msvc_inval_per_thread *current = gl_msvc_inval_current ();\n  if (current->restart_valid)\n    longjmp (current->restart, 1);\n  else\n    /* An invalid parameter notification from outside the gnulib code.\n       Give the caller a chance to intervene.  */\n    RaiseException (STATUS_GNULIB_INVALID_PARAMETER, 0, 0, NULL);\n}",
        "lines": 15,
        "depth": 8,
        "decorators": [
          "static",
          "static",
          "void",
          "__cdecl",
          "__cdecl"
        ]
      }
    ],
    "gl_msvc_inval_current": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "struct gl_msvc_inval_per_thread *\ngl_msvc_inval_current (void)\n{\n  if (!tls_initialized)\n    {\n      tls_index = TlsAlloc ();\n      tls_initialized = 1;\n    }\n  if (tls_index == TLS_OUT_OF_INDEXES)\n    /* TlsAlloc had failed.  */\n    return &not_per_thread;\n  else\n    {\n      struct gl_msvc_inval_per_thread *pointer =\n        (struct gl_msvc_inval_per_thread *) TlsGetValue (tls_index);\n      if (pointer == NULL)\n        {\n          /* First call.  Allocate a new 'struct gl_msvc_inval_per_thread'.  */\n          pointer =\n            (struct gl_msvc_inval_per_thread *)\n            malloc (sizeof (struct gl_msvc_inval_per_thread));\n          if (pointer == NULL)\n            /* Could not allocate memory.  Use the global storage.  */\n            pointer = &not_per_thread;\n          TlsSetValue (tls_index, pointer);\n        }\n      return pointer;\n    }\n}",
      "lines": 29,
      "depth": 15,
      "decorators": [
        "struct gl_msvc_inval_per_thread",
        "struct",
        "gl_msvc_inval_per_thread",
        "*\ngl_msvc_inval_current (void)",
        "*"
      ]
    },
    "gl_msvc_inval_ensure_handler": {
      "start_point": [
        118,
        0
      ],
      "end_point": [
        126,
        1
      ],
      "content": "void\ngl_msvc_inval_ensure_handler (void)\n{\n  if (gl_msvc_inval_initialized == 0)\n    {\n      _set_invalid_parameter_handler (gl_msvc_invalid_parameter_handler);\n      gl_msvc_inval_initialized = 1;\n    }\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/msvc-inval.h": {},
  "findutils/findutils-4.6.0/gl/lib/msvc-nothrow.c": {
    "_gl_nothrow_get_osfhandle": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        39,
        5
      ],
      "content": "intptr_t\n_gl_nothrow_get_osfhandle (int fd)\n{\n  intptr_t result;\n\n  TRY_MSVC_INVAL\n    {\n      result = _get_osfhandle (fd);\n    }",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "intptr_t"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/msvc-nothrow.h": {},
  "findutils/findutils-4.6.0/gl/lib/nl_langinfo.c": {
    "ctype_codeset": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        81,
        1
      ],
      "content": "static char *\nctype_codeset (void)\n{\n  static char buf[2 + 10 + 1];\n  size_t buflen = 0;\n  char const *locale = setlocale (LC_CTYPE, NULL);\n  char *codeset = buf;\n  size_t codesetlen;\n  codeset[0] = '\\0';\n\n  if (locale && locale[0])\n    {\n      /* If the locale name contains an encoding after the dot, return it.  */\n      char *dot = strchr (locale, '.');\n\n      if (dot)\n        {\n          /* Look for the possible @... trailer and remove it, if any.  */\n          char *codeset_start = dot + 1;\n          char const *modifier = strchr (codeset_start, '@');\n\n          if (! modifier)\n            codeset = codeset_start;\n          else\n            {\n              codesetlen = modifier - codeset_start;\n              if (codesetlen < sizeof buf)\n                {\n                  codeset = memcpy (buf, codeset_start, codesetlen);\n                  codeset[codesetlen] = '\\0';\n                }\n            }\n        }\n    }\n\n#if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n  /* If setlocale is successful, it returns the number of the\n     codepage, as a string.  Otherwise, fall back on Windows API\n     GetACP, which returns the locale's codepage as a number (although\n     this doesn't change according to what the 'setlocale' call specified).\n     Either way, prepend \"CP\" to make it a valid codeset name.  */\n  codesetlen = strlen (codeset);\n  if (0 < codesetlen && codesetlen < sizeof buf - 2)\n    memmove (buf + 2, codeset, codesetlen + 1);\n  else\n    sprintf (buf + 2, \"%u\", GetACP ());\n  codeset = memcpy (buf, \"CP\", 2);\n#endif\n  return codeset;\n}",
      "lines": 50,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nctype_codeset (void)",
        "*"
      ]
    },
    "rpl_nl_langinfo": {
      "start_point": [
        90,
        0
      ],
      "end_point": [
        139,
        1
      ],
      "content": "char *\nrpl_nl_langinfo (nl_item item)\n{\n  switch (item)\n    {\n# if GNULIB_defined_CODESET\n    case CODESET:\n      return ctype_codeset ();\n# endif\n# if GNULIB_defined_T_FMT_AMPM\n    case T_FMT_AMPM:\n      return \"%I:%M:%S %p\";\n# endif\n# if GNULIB_defined_ERA\n    case ERA:\n      /* The format is not standardized.  In glibc it is a sequence of strings\n         of the form \"direction:offset:start_date:end_date:era_name:era_format\"\n         with an empty string at the end.  */\n      return \"\";\n    case ERA_D_FMT:\n      /* The %Ex conversion in strftime behaves like %x if the locale does not\n         have an alternative time format.  */\n      item = D_FMT;\n      break;\n    case ERA_D_T_FMT:\n      /* The %Ec conversion in strftime behaves like %c if the locale does not\n         have an alternative time format.  */\n      item = D_T_FMT;\n      break;\n    case ERA_T_FMT:\n      /* The %EX conversion in strftime behaves like %X if the locale does not\n         have an alternative time format.  */\n      item = T_FMT;\n      break;\n    case ALT_DIGITS:\n      /* The format is not standardized.  In glibc it is a sequence of 10\n         strings, appended in memory.  */\n      return \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\";\n# endif\n# if GNULIB_defined_YESEXPR || !FUNC_NL_LANGINFO_YESEXPR_WORKS\n    case YESEXPR:\n      return \"^[yY]\";\n    case NOEXPR:\n      return \"^[nN]\";\n# endif\n    default:\n      break;\n    }\n  return nl_langinfo (item);\n}",
      "lines": 50,
      "depth": 10,
      "decorators": [
        "char",
        "*\nrpl_nl_langinfo (nl_item item)",
        "*"
      ]
    },
    "nl_langinfo": {
      "start_point": [
        149,
        0
      ],
      "end_point": [
        319,
        1
      ],
      "content": "char *\nnl_langinfo (nl_item item)\n{\n  static char nlbuf[100];\n  struct tm tmm = { 0 };\n\n  switch (item)\n    {\n    /* nl_langinfo items of the LC_CTYPE category */\n    case CODESET:\n      {\n        char *codeset = ctype_codeset ();\n        if (*codeset)\n          return codeset;\n      }\n# ifdef __BEOS__\n      return \"UTF-8\";\n# else\n      return \"ISO-8859-1\";\n# endif\n    /* nl_langinfo items of the LC_NUMERIC category */\n    case RADIXCHAR:\n      return localeconv () ->decimal_point;\n    case THOUSEP:\n      return localeconv () ->thousands_sep;\n    case GROUPING:\n      return localeconv () ->grouping;\n    /* nl_langinfo items of the LC_TIME category.\n       TODO: Really use the locale.  */\n    case D_T_FMT:\n    case ERA_D_T_FMT:\n      return \"%a %b %e %H:%M:%S %Y\";\n    case D_FMT:\n    case ERA_D_FMT:\n      return \"%m/%d/%y\";\n    case T_FMT:\n    case ERA_T_FMT:\n      return \"%H:%M:%S\";\n    case T_FMT_AMPM:\n      return \"%I:%M:%S %p\";\n    case AM_STR:\n      if (!strftime (nlbuf, sizeof nlbuf, \"%p\", &tmm))\n        return \"AM\";\n      return nlbuf;\n    case PM_STR:\n      tmm.tm_hour = 12;\n      if (!strftime (nlbuf, sizeof nlbuf, \"%p\", &tmm))\n        return \"PM\";\n      return nlbuf;\n    case DAY_1:\n    case DAY_2:\n    case DAY_3:\n    case DAY_4:\n    case DAY_5:\n    case DAY_6:\n    case DAY_7:\n      {\n        static char const days[][sizeof \"Wednesday\"] = {\n          \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\",\n          \"Friday\", \"Saturday\"\n        };\n        tmm.tm_wday = item - DAY_1;\n        if (!strftime (nlbuf, sizeof nlbuf, \"%A\", &tmm))\n          return (char *) days[item - DAY_1];\n        return nlbuf;\n      }\n    case ABDAY_1:\n    case ABDAY_2:\n    case ABDAY_3:\n    case ABDAY_4:\n    case ABDAY_5:\n    case ABDAY_6:\n    case ABDAY_7:\n      {\n        static char const abdays[][sizeof \"Sun\"] = {\n          \"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"\n        };\n        tmm.tm_wday = item - ABDAY_1;\n        if (!strftime (nlbuf, sizeof nlbuf, \"%a\", &tmm))\n          return (char *) abdays[item - ABDAY_1];\n        return nlbuf;\n      }\n    case MON_1:\n    case MON_2:\n    case MON_3:\n    case MON_4:\n    case MON_5:\n    case MON_6:\n    case MON_7:\n    case MON_8:\n    case MON_9:\n    case MON_10:\n    case MON_11:\n    case MON_12:\n      {\n        static char const months[][sizeof \"September\"] = {\n          \"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\",\n          \"September\", \"October\", \"November\", \"December\"\n        };\n        tmm.tm_mon = item - MON_1;\n        if (!strftime (nlbuf, sizeof nlbuf, \"%B\", &tmm))\n          return (char *) months[item - MON_1];\n        return nlbuf;\n      }\n    case ABMON_1:\n    case ABMON_2:\n    case ABMON_3:\n    case ABMON_4:\n    case ABMON_5:\n    case ABMON_6:\n    case ABMON_7:\n    case ABMON_8:\n    case ABMON_9:\n    case ABMON_10:\n    case ABMON_11:\n    case ABMON_12:\n      {\n        static char const abmonths[][sizeof \"Jan\"] = {\n          \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\",\n          \"Sep\", \"Oct\", \"Nov\", \"Dec\"\n        };\n        tmm.tm_mon = item - ABMON_1;\n        if (!strftime (nlbuf, sizeof nlbuf, \"%b\", &tmm))\n          return (char *) abmonths[item - ABMON_1];\n        return nlbuf;\n      }\n    case ERA:\n      return \"\";\n    case ALT_DIGITS:\n      return \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\";\n    /* nl_langinfo items of the LC_MONETARY category.  */\n    case CRNCYSTR:\n      return localeconv () ->currency_symbol;\n    case INT_CURR_SYMBOL:\n      return localeconv () ->int_curr_symbol;\n    case MON_DECIMAL_POINT:\n      return localeconv () ->mon_decimal_point;\n    case MON_THOUSANDS_SEP:\n      return localeconv () ->mon_thousands_sep;\n    case MON_GROUPING:\n      return localeconv () ->mon_grouping;\n    case POSITIVE_SIGN:\n      return localeconv () ->positive_sign;\n    case NEGATIVE_SIGN:\n      return localeconv () ->negative_sign;\n    case FRAC_DIGITS:\n      return & localeconv () ->frac_digits;\n    case INT_FRAC_DIGITS:\n      return & localeconv () ->int_frac_digits;\n    case P_CS_PRECEDES:\n      return & localeconv () ->p_cs_precedes;\n    case N_CS_PRECEDES:\n      return & localeconv () ->n_cs_precedes;\n    case P_SEP_BY_SPACE:\n      return & localeconv () ->p_sep_by_space;\n    case N_SEP_BY_SPACE:\n      return & localeconv () ->n_sep_by_space;\n    case P_SIGN_POSN:\n      return & localeconv () ->p_sign_posn;\n    case N_SIGN_POSN:\n      return & localeconv () ->n_sign_posn;\n    /* nl_langinfo items of the LC_MESSAGES category\n       TODO: Really use the locale. */\n    case YESEXPR:\n      return \"^[yY]\";\n    case NOEXPR:\n      return \"^[nN]\";\n    default:\n      return \"\";\n    }\n}",
      "lines": 171,
      "depth": 13,
      "decorators": [
        "char",
        "*\nnl_langinfo (nl_item item)",
        "*"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/open-safer.c": {
    "open_safer": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "int\nopen_safer (char const *file, int flags, ...)\n{\n  mode_t mode = 0;\n\n  if (flags & O_CREAT)\n    {\n      va_list ap;\n      va_start (ap, flags);\n\n      /* We have to use PROMOTED_MODE_T instead of mode_t, otherwise GCC 4\n         creates crashing code when 'mode_t' is smaller than 'int'.  */\n      mode = va_arg (ap, PROMOTED_MODE_T);\n\n      va_end (ap);\n    }\n\n  return fd_safer (open (file, flags, mode));\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/open.c": {
    "orig_open": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        33,
        1
      ],
      "content": "static int\norig_open (const char *filename, int flags, mode_t mode)\n{\n  return open (filename, flags, mode);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "open": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        180,
        1
      ],
      "content": "int\nopen (const char *filename, int flags, ...)\n{\n  mode_t mode;\n  int fd;\n\n  mode = 0;\n  if (flags & O_CREAT)\n    {\n      va_list arg;\n      va_start (arg, flags);\n\n      /* We have to use PROMOTED_MODE_T instead of mode_t, otherwise GCC 4\n         creates crashing code when 'mode_t' is smaller than 'int'.  */\n      mode = va_arg (arg, PROMOTED_MODE_T);\n\n      va_end (arg);\n    }\n\n#if GNULIB_defined_O_NONBLOCK\n  /* The only known platform that lacks O_NONBLOCK is mingw, but it\n     also lacks named pipes and Unix sockets, which are the only two\n     file types that require non-blocking handling in open().\n     Therefore, it is safe to ignore O_NONBLOCK here.  It is handy\n     that mingw also lacks openat(), so that is also covered here.  */\n  flags &= ~O_NONBLOCK;\n#endif\n\n#if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n  if (strcmp (filename, \"/dev/null\") == 0)\n    filename = \"NUL\";\n#endif\n\n#if OPEN_TRAILING_SLASH_BUG\n  /* If the filename ends in a slash and one of O_CREAT, O_WRONLY, O_RDWR\n     is specified, then fail.\n     Rationale: POSIX <http://www.opengroup.org/susv3/basedefs/xbd_chap04.html>\n     says that\n       \"A pathname that contains at least one non-slash character and that\n        ends with one or more trailing slashes shall be resolved as if a\n        single dot character ( '.' ) were appended to the pathname.\"\n     and\n       \"The special filename dot shall refer to the directory specified by\n        its predecessor.\"\n     If the named file already exists as a directory, then\n       - if O_CREAT is specified, open() must fail because of the semantics\n         of O_CREAT,\n       - if O_WRONLY or O_RDWR is specified, open() must fail because POSIX\n         <http://www.opengroup.org/susv3/functions/open.html> says that it\n         fails with errno = EISDIR in this case.\n     If the named file does not exist or does not name a directory, then\n       - if O_CREAT is specified, open() must fail since open() cannot create\n         directories,\n       - if O_WRONLY or O_RDWR is specified, open() must fail because the\n         file does not contain a '.' directory.  */\n  if (flags & (O_CREAT | O_WRONLY | O_RDWR))\n    {\n      size_t len = strlen (filename);\n      if (len > 0 && filename[len - 1] == '/')\n        {\n          errno = EISDIR;\n          return -1;\n        }\n    }\n#endif\n\n  fd = orig_open (filename, flags, mode);\n\n#if REPLACE_FCHDIR\n  /* Implementing fchdir and fdopendir requires the ability to open a\n     directory file descriptor.  If open doesn't support that (as on\n     mingw), we use a dummy file that behaves the same as directories\n     on Linux (ie. always reports EOF on attempts to read()), and\n     override fstat() in fchdir.c to hide the fact that we have a\n     dummy.  */\n  if (REPLACE_OPEN_DIRECTORY && fd < 0 && errno == EACCES\n      && ((flags & O_ACCMODE) == O_RDONLY\n          || (O_SEARCH != O_RDONLY && (flags & O_ACCMODE) == O_SEARCH)))\n    {\n      struct stat statbuf;\n      if (stat (filename, &statbuf) == 0 && S_ISDIR (statbuf.st_mode))\n        {\n          /* Maximum recursion depth of 1.  */\n          fd = open (\"/dev/null\", flags, mode);\n          if (0 <= fd)\n            fd = _gl_register_fd (fd, filename);\n        }\n      else\n        errno = EACCES;\n    }\n#endif\n\n#if OPEN_TRAILING_SLASH_BUG\n  /* If the filename ends in a slash and fd does not refer to a directory,\n     then fail.\n     Rationale: POSIX <http://www.opengroup.org/susv3/basedefs/xbd_chap04.html>\n     says that\n       \"A pathname that contains at least one non-slash character and that\n        ends with one or more trailing slashes shall be resolved as if a\n        single dot character ( '.' ) were appended to the pathname.\"\n     and\n       \"The special filename dot shall refer to the directory specified by\n        its predecessor.\"\n     If the named file without the slash is not a directory, open() must fail\n     with ENOTDIR.  */\n  if (fd >= 0)\n    {\n      /* We know len is positive, since open did not fail with ENOENT.  */\n      size_t len = strlen (filename);\n      if (filename[len - 1] == '/')\n        {\n          struct stat statbuf;\n\n          if (fstat (fd, &statbuf) >= 0 && !S_ISDIR (statbuf.st_mode))\n            {\n              close (fd);\n              errno = ENOTDIR;\n              return -1;\n            }\n        }\n    }\n#endif\n\n#if REPLACE_FCHDIR\n  if (!REPLACE_OPEN_DIRECTORY && 0 <= fd)\n    fd = _gl_register_fd (fd, filename);\n#endif\n\n  return fd;\n}",
      "lines": 130,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/openat-die.c": {
    "openat_save_fail": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "_Noreturn void\nopenat_save_fail (int errnum)\n{\n#ifndef GNULIB_LIBPOSIX\n  error (exit_failure, errnum,\n         _(\"unable to record current working directory\"));\n#endif\n  /* _Noreturn cannot be applied to error, since it returns\n     when its first argument is 0.  To help compilers understand that this\n     function does not return, call abort.  Also, the abort is a\n     safety feature if exit_failure is 0 (which shouldn't happen).  */\n  abort ();\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "_Noreturn",
        "void",
        "void"
      ]
    },
    "openat_restore_fail": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "_Noreturn void\nopenat_restore_fail (int errnum)\n{\n#ifndef GNULIB_LIBPOSIX\n  error (exit_failure, errnum,\n         _(\"failed to return to initial working directory\"));\n#endif\n\n  /* As above.  */\n  abort ();\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "_Noreturn",
        "void",
        "void"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/openat-priv.h": {},
  "findutils/findutils-4.6.0/gl/lib/openat-proc.c": {
    "openat_proc_name": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        101,
        1
      ],
      "content": "char *\nopenat_proc_name (char buf[OPENAT_BUFFER_SIZE], int fd, char const *file)\n{\n  static int proc_status = 0;\n\n  /* Make sure the caller gets ENOENT when appropriate.  */\n  if (!*file)\n    {\n      buf[0] = '\\0';\n      return buf;\n    }\n\n  if (! proc_status)\n    {\n      /* Set PROC_STATUS to a positive value if /proc/self/fd is\n         reliable, and a negative value otherwise.  Solaris 10\n         /proc/self/fd mishandles \"..\", and any file name might expand\n         to \"..\" after symbolic link expansion, so avoid /proc/self/fd\n         if it mishandles \"..\".  Solaris 10 has openat, but this\n         problem is exhibited on code that built on Solaris 8 and\n         running on Solaris 10.  */\n\n      int proc_self_fd = open (\"/proc/self/fd\",\n                               O_SEARCH | O_DIRECTORY | O_NOCTTY | O_NONBLOCK);\n      if (proc_self_fd < 0)\n        proc_status = -1;\n      else\n        {\n          /* Detect whether /proc/self/fd/%i/../fd exists, where %i is the\n             number of a file descriptor open on /proc/self/fd.  On Linux,\n             that name resolves to /proc/self/fd, which was opened above.\n             However, on Solaris, it may resolve to /proc/self/fd/fd, which\n             cannot exist, since all names in /proc/self/fd are numeric.  */\n          char dotdot_buf[PROC_SELF_FD_NAME_SIZE_BOUND (sizeof \"../fd\" - 1)];\n          sprintf (dotdot_buf, PROC_SELF_FD_FORMAT, proc_self_fd, \"../fd\");\n          proc_status = access (dotdot_buf, F_OK) ? -1 : 1;\n          close (proc_self_fd);\n        }\n    }\n\n  if (proc_status < 0)\n    return NULL;\n  else\n    {\n      size_t bufsize = PROC_SELF_FD_NAME_SIZE_BOUND (strlen (file));\n      char *result = buf;\n      if (OPENAT_BUFFER_SIZE < bufsize)\n        {\n          result = malloc (bufsize);\n          if (! result)\n            return NULL;\n        }\n      sprintf (result, PROC_SELF_FD_FORMAT, fd, file);\n      return result;\n    }\n}",
      "lines": 56,
      "depth": 14,
      "decorators": [
        "char",
        "*\nopenat_proc_name (char buf[OPENAT_BUFFER_SIZE], int fd, char const *file)",
        "*"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/openat-safer.c": {
    "openat_safer": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "int\nopenat_safer (int fd, char const *file, int flags, ...)\n{\n  mode_t mode = 0;\n\n  if (flags & O_CREAT)\n    {\n      va_list ap;\n      va_start (ap, flags);\n\n      /* We have to use PROMOTED_MODE_T instead of mode_t, otherwise GCC 4\n         creates crashing code when 'mode_t' is smaller than 'int'.  */\n      mode = va_arg (ap, PROMOTED_MODE_T);\n\n      va_end (ap);\n    }\n\n  return fd_safer (openat (fd, file, flags, mode));\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/openat.c": {
    "orig_openat": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        34,
        1
      ],
      "content": "static int\norig_openat (int fd, char const *filename, int flags, mode_t mode)\n{\n  return openat (fd, filename, flags, mode);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_openat": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        139,
        1
      ],
      "content": "int\nrpl_openat (int dfd, char const *filename, int flags, ...)\n{\n  mode_t mode;\n  int fd;\n\n  mode = 0;\n  if (flags & O_CREAT)\n    {\n      va_list arg;\n      va_start (arg, flags);\n\n      /* We have to use PROMOTED_MODE_T instead of mode_t, otherwise GCC 4\n         creates crashing code when 'mode_t' is smaller than 'int'.  */\n      mode = va_arg (arg, PROMOTED_MODE_T);\n\n      va_end (arg);\n    }\n\n# if OPEN_TRAILING_SLASH_BUG\n  /* If the filename ends in a slash and one of O_CREAT, O_WRONLY, O_RDWR\n     is specified, then fail.\n     Rationale: POSIX <http://www.opengroup.org/susv3/basedefs/xbd_chap04.html>\n     says that\n       \"A pathname that contains at least one non-slash character and that\n        ends with one or more trailing slashes shall be resolved as if a\n        single dot character ( '.' ) were appended to the pathname.\"\n     and\n       \"The special filename dot shall refer to the directory specified by\n        its predecessor.\"\n     If the named file already exists as a directory, then\n       - if O_CREAT is specified, open() must fail because of the semantics\n         of O_CREAT,\n       - if O_WRONLY or O_RDWR is specified, open() must fail because POSIX\n         <http://www.opengroup.org/susv3/functions/open.html> says that it\n         fails with errno = EISDIR in this case.\n     If the named file does not exist or does not name a directory, then\n       - if O_CREAT is specified, open() must fail since open() cannot create\n         directories,\n       - if O_WRONLY or O_RDWR is specified, open() must fail because the\n         file does not contain a '.' directory.  */\n  if (flags & (O_CREAT | O_WRONLY | O_RDWR))\n    {\n      size_t len = strlen (filename);\n      if (len > 0 && filename[len - 1] == '/')\n        {\n          errno = EISDIR;\n          return -1;\n        }\n    }\n# endif\n\n  fd = orig_openat (dfd, filename, flags, mode);\n\n# if OPEN_TRAILING_SLASH_BUG\n  /* If the filename ends in a slash and fd does not refer to a directory,\n     then fail.\n     Rationale: POSIX <http://www.opengroup.org/susv3/basedefs/xbd_chap04.html>\n     says that\n       \"A pathname that contains at least one non-slash character and that\n        ends with one or more trailing slashes shall be resolved as if a\n        single dot character ( '.' ) were appended to the pathname.\"\n     and\n       \"The special filename dot shall refer to the directory specified by\n        its predecessor.\"\n     If the named file without the slash is not a directory, open() must fail\n     with ENOTDIR.  */\n  if (fd >= 0)\n    {\n      /* We know len is positive, since open did not fail with ENOENT.  */\n      size_t len = strlen (filename);\n      if (filename[len - 1] == '/')\n        {\n          struct stat statbuf;\n\n          if (fstat (fd, &statbuf) >= 0 && !S_ISDIR (statbuf.st_mode))\n            {\n              close (fd);\n              errno = ENOTDIR;\n              return -1;\n            }\n        }\n    }\n# endif\n\n  return fd;\n}",
      "lines": 87,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "openat": {
      "start_point": [
        155,
        0
      ],
      "end_point": [
        173,
        1
      ],
      "content": "int\nopenat (int fd, char const *file, int flags, ...)\n{\n  mode_t mode = 0;\n\n  if (flags & O_CREAT)\n    {\n      va_list arg;\n      va_start (arg, flags);\n\n      /* We have to use PROMOTED_MODE_T instead of mode_t, otherwise GCC 4\n         creates crashing code when 'mode_t' is smaller than 'int'.  */\n      mode = va_arg (arg, PROMOTED_MODE_T);\n\n      va_end (arg);\n    }\n\n  return openat_permissive (fd, file, flags, mode, NULL);\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "openat_permissive": {
      "start_point": [
        186,
        0
      ],
      "end_point": [
        259,
        1
      ],
      "content": "int\nopenat_permissive (int fd, char const *file, int flags, mode_t mode,\n                   int *cwd_errno)\n{\n  struct saved_cwd saved_cwd;\n  int saved_errno;\n  int err;\n  bool save_ok;\n\n  if (fd == AT_FDCWD || IS_ABSOLUTE_FILE_NAME (file))\n    return open (file, flags, mode);\n\n  {\n    char buf[OPENAT_BUFFER_SIZE];\n    char *proc_file = openat_proc_name (buf, fd, file);\n    if (proc_file)\n      {\n        int open_result = open (proc_file, flags, mode);\n        int open_errno = errno;\n        if (proc_file != buf)\n          free (proc_file);\n        /* If the syscall succeeds, or if it fails with an unexpected\n           errno value, then return right away.  Otherwise, fall through\n           and resort to using save_cwd/restore_cwd.  */\n        if (0 <= open_result || ! EXPECTED_ERRNO (open_errno))\n          {\n            errno = open_errno;\n            return open_result;\n          }\n      }\n  }\n\n  save_ok = (save_cwd (&saved_cwd) == 0);\n  if (! save_ok)\n    {\n      if (! cwd_errno)\n        openat_save_fail (errno);\n      *cwd_errno = errno;\n    }\n  if (0 <= fd && fd == saved_cwd.desc)\n    {\n      /* If saving the working directory collides with the user's\n         requested fd, then the user's fd must have been closed to\n         begin with.  */\n      free_cwd (&saved_cwd);\n      errno = EBADF;\n      return -1;\n    }\n\n  err = fchdir (fd);\n  saved_errno = errno;\n\n  if (! err)\n    {\n      err = open (file, flags, mode);\n      saved_errno = errno;\n      if (save_ok && restore_cwd (&saved_cwd) != 0)\n        {\n          if (! cwd_errno)\n            {\n              /* Don't write a message to just-created fd 2.  */\n              saved_errno = errno;\n              if (err == STDERR_FILENO)\n                close (err);\n              openat_restore_fail (saved_errno);\n            }\n          *cwd_errno = errno;\n        }\n    }\n\n  free_cwd (&saved_cwd);\n  errno = saved_errno;\n  return err;\n}",
      "lines": 74,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "openat_needs_fchdir": {
      "start_point": [
        263,
        0
      ],
      "end_point": [
        283,
        1
      ],
      "content": "bool\nopenat_needs_fchdir (void)\n{\n  bool needs_fchdir = true;\n  int fd = open (\"/\", O_SEARCH);\n\n  if (0 <= fd)\n    {\n      char buf[OPENAT_BUFFER_SIZE];\n      char *proc_file = openat_proc_name (buf, fd, \".\");\n      if (proc_file)\n        {\n          needs_fchdir = false;\n          if (proc_file != buf)\n            free (proc_file);\n        }\n      close (fd);\n    }\n\n  return needs_fchdir;\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "bool"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/openat.h": {
    "chownat": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "FCHOWNAT_INLINE int\nchownat (int fd, char const *file, uid_t owner, gid_t group)\n{\n  return fchownat (fd, file, owner, group, 0);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "FCHOWNAT_INLINE",
        "int",
        "int"
      ]
    },
    "lchownat": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "FCHOWNAT_INLINE int\nlchownat (int fd, char const *file, uid_t owner, gid_t group)\n{\n  return fchownat (fd, file, owner, group, AT_SYMLINK_NOFOLLOW);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "FCHOWNAT_INLINE",
        "int",
        "int"
      ]
    },
    "chmodat": {
      "start_point": [
        80,
        0
      ],
      "end_point": [
        84,
        1
      ],
      "content": "FCHMODAT_INLINE int\nchmodat (int fd, char const *file, mode_t mode)\n{\n  return fchmodat (fd, file, mode, 0);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "FCHMODAT_INLINE",
        "int",
        "int"
      ]
    },
    "lchmodat": {
      "start_point": [
        86,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "FCHMODAT_INLINE int\nlchmodat (int fd, char const *file, mode_t mode)\n{\n  return fchmodat (fd, file, mode, AT_SYMLINK_NOFOLLOW);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "FCHMODAT_INLINE",
        "int",
        "int"
      ]
    },
    "statat": {
      "start_point": [
        100,
        0
      ],
      "end_point": [
        104,
        1
      ],
      "content": "STATAT_INLINE int\nstatat (int fd, char const *name, struct stat *st)\n{\n  return fstatat (fd, name, st, 0);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "STATAT_INLINE",
        "int",
        "int"
      ]
    },
    "lstatat": {
      "start_point": [
        106,
        0
      ],
      "end_point": [
        110,
        1
      ],
      "content": "STATAT_INLINE int\nlstatat (int fd, char const *name, struct stat *st)\n{\n  return fstatat (fd, name, st, AT_SYMLINK_NOFOLLOW);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "STATAT_INLINE",
        "int",
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/opendir-safer.c": {
    "opendir_safer": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        75,
        1
      ],
      "content": "DIR *\nopendir_safer (char const *name)\n{\n  DIR *dp = opendir (name);\n\n  if (dp)\n    {\n      int fd = dirfd (dp);\n\n      if (0 <= fd && fd <= STDERR_FILENO)\n        {\n          /* If fdopendir is native (as on Linux), then it is safe to\n             assume dirfd(fdopendir(n))==n.  If we are using the\n             gnulib module fdopendir, then this guarantee is not met,\n             but fdopendir recursively calls opendir_safer up to 3\n             times to at least get a safe fd.  If fdopendir is not\n             present but dirfd is accurate (as on cygwin 1.5.x), then\n             we recurse up to 3 times ourselves.  Finally, if dirfd\n             always fails (as on mingw), then we are already safe.  */\n          DIR *newdp;\n          int e;\n#if HAVE_FDOPENDIR || GNULIB_FDOPENDIR\n          int f = dup_safer (fd);\n          if (f < 0)\n            {\n              e = errno;\n              newdp = NULL;\n            }\n          else\n            {\n              newdp = fdopendir (f);\n              e = errno;\n              if (! newdp)\n                close (f);\n            }\n#else /* !FDOPENDIR */\n          newdp = opendir_safer (name);\n          e = errno;\n#endif\n          closedir (dp);\n          errno = e;\n          dp = newdp;\n        }\n    }\n\n  return dp;\n}",
      "lines": 47,
      "depth": 14,
      "decorators": [
        "DIR",
        "*\nopendir_safer (char const *name)",
        "*"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/opendir.c": {
    "opendir": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        147,
        1
      ],
      "content": "DIR *\nopendir (const char *dir_name)\n{\n#if HAVE_OPENDIR\n# undef opendir\n  DIR *dirp;\n\n  dirp = opendir (dir_name);\n  if (dirp == NULL)\n    return NULL;\n\n#else\n\n  char dir_name_mask[MAX_PATH + 1 + 1 + 1];\n  int status;\n  HANDLE current;\n  WIN32_FIND_DATA entry;\n  struct gl_directory *dirp;\n\n  if (dir_name[0] == '\\0')\n    {\n      errno = ENOENT;\n      return NULL;\n    }\n\n  /* Make the dir_name absolute, so that we continue reading the same\n     directory if the current directory changed between this opendir()\n     call and a subsequent rewinddir() call.  */\n  if (!GetFullPathName (dir_name, MAX_PATH, dir_name_mask, NULL))\n    {\n      errno = EINVAL;\n      return NULL;\n    }\n\n  /* Append the mask.\n     \"*\" and \"*.*\" appear to be equivalent.  */\n  {\n    char *p;\n\n    p = dir_name_mask + strlen (dir_name_mask);\n    if (p > dir_name_mask && !ISSLASH (p[-1]))\n      *p++ = '\\\\';\n    *p++ = '*';\n    *p = '\\0';\n  }\n\n  /* Start searching the directory.  */\n  status = -1;\n  current = FindFirstFile (dir_name_mask, &entry);\n  if (current == INVALID_HANDLE_VALUE)\n    {\n      switch (GetLastError ())\n        {\n        case ERROR_FILE_NOT_FOUND:\n          status = -2;\n          break;\n        case ERROR_PATH_NOT_FOUND:\n          errno = ENOENT;\n          return NULL;\n        case ERROR_DIRECTORY:\n          errno = ENOTDIR;\n          return NULL;\n        case ERROR_ACCESS_DENIED:\n          errno = EACCES;\n          return NULL;\n        default:\n          errno = EIO;\n          return NULL;\n        }\n    }\n\n  /* Allocate the result.  */\n  dirp =\n    (struct gl_directory *)\n    malloc (offsetof (struct gl_directory, dir_name_mask[0])\n            + strlen (dir_name_mask) + 1);\n  if (dirp == NULL)\n    {\n      if (current != INVALID_HANDLE_VALUE)\n        FindClose (current);\n      errno = ENOMEM;\n      return NULL;\n    }\n  dirp->status = status;\n  dirp->current = current;\n  if (status == -1)\n    memcpy (&dirp->entry, &entry, sizeof (WIN32_FIND_DATA));\n  strcpy (dirp->dir_name_mask, dir_name_mask);\n\n#endif\n\n#if REPLACE_FCHDIR\n  {\n    int fd = dirfd (dirp);\n    if (0 <= fd && _gl_register_fd (fd, dir_name) != fd)\n      {\n        int saved_errno = errno;\n        closedir (dirp);\n        errno = saved_errno;\n        return NULL;\n      }\n  }\n#endif\n\n  return dirp;\n}",
      "lines": 106,
      "depth": 15,
      "decorators": [
        "DIR",
        "*\nopendir (const char *dir_name)",
        "*"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/parse-datetime.c": {
    "to_uchar": {
      "start_point": [
        183,
        0
      ],
      "end_point": [
        183,
        54
      ],
      "content": "static unsigned char to_uchar (char ch) { return ch; }",
      "lines": 1,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "unsigned char",
        "unsigned",
        "char"
      ]
    },
    "digits_to_date_time": {
      "start_point": [
        288,
        0
      ],
      "end_point": [
        322,
        1
      ],
      "content": "static void\ndigits_to_date_time (parser_control *pc, textint text_int)\n{\n  if (pc->dates_seen && ! pc->year.digits\n      && ! pc->rels_seen && (pc->times_seen || 2 < text_int.digits))\n    pc->year = text_int;\n  else\n    {\n      if (4 < text_int.digits)\n        {\n          pc->dates_seen++;\n          pc->day = text_int.value % 100;\n          pc->month = (text_int.value / 100) % 100;\n          pc->year.value = text_int.value / 10000;\n          pc->year.digits = text_int.digits - 4;\n        }\n      else\n        {\n          pc->times_seen++;\n          if (text_int.digits <= 2)\n            {\n              pc->hour = text_int.value;\n              pc->minutes = 0;\n            }\n          else\n            {\n              pc->hour = text_int.value / 100;\n              pc->minutes = text_int.value % 100;\n            }\n          pc->seconds.tv_sec = 0;\n          pc->seconds.tv_nsec = 0;\n          pc->meridian = MER24;\n        }\n    }\n}",
      "lines": 35,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "apply_relative_time": {
      "start_point": [
        325,
        0
      ],
      "end_point": [
        336,
        1
      ],
      "content": "static void\napply_relative_time (parser_control *pc, relative_time rel, int factor)\n{\n  pc->rel.ns += factor * rel.ns;\n  pc->rel.seconds += factor * rel.seconds;\n  pc->rel.minutes += factor * rel.minutes;\n  pc->rel.hour += factor * rel.hour;\n  pc->rel.day += factor * rel.day;\n  pc->rel.month += factor * rel.month;\n  pc->rel.year += factor * rel.year;\n  pc->rels_seen = true;\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "set_hhmmss": {
      "start_point": [
        339,
        0
      ],
      "end_point": [
        347,
        1
      ],
      "content": "static void\nset_hhmmss (parser_control *pc, long int hour, long int minutes,\n            time_t sec, long int nsec)\n{\n  pc->hour = hour;\n  pc->minutes = minutes;\n  pc->seconds.tv_sec = sec;\n  pc->seconds.tv_nsec = nsec;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yy_symbol_value_print": {
      "start_point": [
        1011,
        0
      ],
      "end_point": [
        1024,
        1
      ],
      "content": "static void\nyy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep, parser_control *pc)\n{\n  FILE *yyo = yyoutput;\n  YYUSE (yyo);\n  YYUSE (pc);\n  if (!yyvaluep)\n    return;\n# ifdef YYPRINT\n  if (yytype < YYNTOKENS)\n    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);\n# endif\n  YYUSE (yytype);\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yy_symbol_print": {
      "start_point": [
        1031,
        0
      ],
      "end_point": [
        1039,
        1
      ],
      "content": "static void\nyy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep, parser_control *pc)\n{\n  YYFPRINTF (yyoutput, \"%s %s (\",\n             yytype < YYNTOKENS ? \"token\" : \"nterm\", yytname[yytype]);\n\n  yy_symbol_value_print (yyoutput, yytype, yyvaluep, pc);\n  YYFPRINTF (yyoutput, \")\");\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yy_stack_print": {
      "start_point": [
        1046,
        0
      ],
      "end_point": [
        1056,
        1
      ],
      "content": "static void\nyy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)\n{\n  YYFPRINTF (stderr, \"Stack now\");\n  for (; yybottom <= yytop; yybottom++)\n    {\n      int yybot = *yybottom;\n      YYFPRINTF (stderr, \" %d\", yybot);\n    }\n  YYFPRINTF (stderr, \"\\n\");\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yy_reduce_print": {
      "start_point": [
        1069,
        0
      ],
      "end_point": [
        1087,
        1
      ],
      "content": "static void\nyy_reduce_print (yytype_int16 *yyssp, YYSTYPE *yyvsp, int yyrule, parser_control *pc)\n{\n  unsigned long int yylno = yyrline[yyrule];\n  int yynrhs = yyr2[yyrule];\n  int yyi;\n  YYFPRINTF (stderr, \"Reducing stack by rule %d (line %lu):\\n\",\n             yyrule - 1, yylno);\n  /* The symbols being reduced.  */\n  for (yyi = 0; yyi < yynrhs; yyi++)\n    {\n      YYFPRINTF (stderr, \"   $%d = \", yyi + 1);\n      yy_symbol_print (stderr,\n                       yystos[yyssp[yyi + 1 - yynrhs]],\n                       &(yyvsp[(yyi + 1) - (yynrhs)])\n                                              , pc);\n      YYFPRINTF (stderr, \"\\n\");\n    }\n}",
      "lines": 19,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yystrlen": {
      "start_point": [
        1130,
        0
      ],
      "end_point": [
        1137,
        1
      ],
      "content": "static YYSIZE_T\nyystrlen (const char *yystr)\n{\n  YYSIZE_T yylen;\n  for (yylen = 0; yystr[yylen]; yylen++)\n    continue;\n  return yylen;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "YYSIZE_T"
      ]
    },
    "yystpcpy": {
      "start_point": [
        1147,
        0
      ],
      "end_point": [
        1157,
        1
      ],
      "content": "static char *\nyystpcpy (char *yydest, const char *yysrc)\n{\n  char *yyd = yydest;\n  const char *yys = yysrc;\n\n  while ((*yyd++ = *yys++) != '\\0')\n    continue;\n\n  return yyd - 1;\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nyystpcpy (char *yydest, const char *yysrc)",
        "*"
      ]
    },
    "yytnamerr": {
      "start_point": [
        1169,
        0
      ],
      "end_point": [
        1206,
        1
      ],
      "content": "static YYSIZE_T\nyytnamerr (char *yyres, const char *yystr)\n{\n  if (*yystr == '\"')\n    {\n      YYSIZE_T yyn = 0;\n      char const *yyp = yystr;\n\n      for (;;)\n        switch (*++yyp)\n          {\n          case '\\'':\n          case ',':\n            goto do_not_strip_quotes;\n\n          case '\\\\':\n            if (*++yyp != '\\\\')\n              goto do_not_strip_quotes;\n            /* Fall through.  */\n          default:\n            if (yyres)\n              yyres[yyn] = *yyp;\n            yyn++;\n            break;\n\n          case '\"':\n            if (yyres)\n              yyres[yyn] = '\\0';\n            return yyn;\n          }\n    do_not_strip_quotes: ;\n    }\n\n  if (! yyres)\n    return yystrlen (yystr);\n\n  return yystpcpy (yyres, yystr) - yyres;\n}",
      "lines": 38,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "YYSIZE_T"
      ]
    },
    "yysyntax_error": {
      "start_point": [
        1217,
        0
      ],
      "end_point": [
        1342,
        1
      ],
      "content": "static int\nyysyntax_error (YYSIZE_T *yymsg_alloc, char **yymsg,\n                yytype_int16 *yyssp, int yytoken)\n{\n  YYSIZE_T yysize0 = yytnamerr (YY_NULLPTR, yytname[yytoken]);\n  YYSIZE_T yysize = yysize0;\n  enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };\n  /* Internationalized format string. */\n  const char *yyformat = YY_NULLPTR;\n  /* Arguments of yyformat. */\n  char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];\n  /* Number of reported tokens (one for the \"unexpected\", one per\n     \"expected\"). */\n  int yycount = 0;\n\n  /* There are many possibilities here to consider:\n     - If this state is a consistent state with a default action, then\n       the only way this function was invoked is if the default action\n       is an error action.  In that case, don't check for expected\n       tokens because there are none.\n     - The only way there can be no lookahead present (in yychar) is if\n       this state is a consistent state with a default action.  Thus,\n       detecting the absence of a lookahead is sufficient to determine\n       that there is no unexpected or expected token to report.  In that\n       case, just report a simple \"syntax error\".\n     - Don't assume there isn't a lookahead just because this state is a\n       consistent state with a default action.  There might have been a\n       previous inconsistent state, consistent state with a non-default\n       action, or user semantic action that manipulated yychar.\n     - Of course, the expected token list depends on states to have\n       correct lookahead information, and it depends on the parser not\n       to perform extra reductions after fetching a lookahead from the\n       scanner and before detecting a syntax error.  Thus, state merging\n       (from LALR or IELR) and default reductions corrupt the expected\n       token list.  However, the list is correct for canonical LR with\n       one exception: it will still contain any token that will not be\n       accepted due to an error action in a later state.\n  */\n  if (yytoken != YYEMPTY)\n    {\n      int yyn = yypact[*yyssp];\n      yyarg[yycount++] = yytname[yytoken];\n      if (!yypact_value_is_default (yyn))\n        {\n          /* Start YYX at -YYN if negative to avoid negative indexes in\n             YYCHECK.  In other words, skip the first -YYN actions for\n             this state because they are default actions.  */\n          int yyxbegin = yyn < 0 ? -yyn : 0;\n          /* Stay within bounds of both yycheck and yytname.  */\n          int yychecklim = YYLAST - yyn + 1;\n          int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;\n          int yyx;\n\n          for (yyx = yyxbegin; yyx < yyxend; ++yyx)\n            if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR\n                && !yytable_value_is_error (yytable[yyx + yyn]))\n              {\n                if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)\n                  {\n                    yycount = 1;\n                    yysize = yysize0;\n                    break;\n                  }\n                yyarg[yycount++] = yytname[yyx];\n                {\n                  YYSIZE_T yysize1 = yysize + yytnamerr (YY_NULLPTR, yytname[yyx]);\n                  if (! (yysize <= yysize1\n                         && yysize1 <= YYSTACK_ALLOC_MAXIMUM))\n                    return 2;\n                  yysize = yysize1;\n                }\n              }\n        }\n    }\n\n  switch (yycount)\n    {\n# define YYCASE_(N, S)                      \\\n      case N:                               \\\n        yyformat = S;                       \\\n      break\n      YYCASE_(0, YY_(\"syntax error\"));\n      YYCASE_(1, YY_(\"syntax error, unexpected %s\"));\n      YYCASE_(2, YY_(\"syntax error, unexpected %s, expecting %s\"));\n      YYCASE_(3, YY_(\"syntax error, unexpected %s, expecting %s or %s\"));\n      YYCASE_(4, YY_(\"syntax error, unexpected %s, expecting %s or %s or %s\"));\n      YYCASE_(5, YY_(\"syntax error, unexpected %s, expecting %s or %s or %s or %s\"));\n# undef YYCASE_\n    }\n\n  {\n    YYSIZE_T yysize1 = yysize + yystrlen (yyformat);\n    if (! (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM))\n      return 2;\n    yysize = yysize1;\n  }\n\n  if (*yymsg_alloc < yysize)\n    {\n      *yymsg_alloc = 2 * yysize;\n      if (! (yysize <= *yymsg_alloc\n             && *yymsg_alloc <= YYSTACK_ALLOC_MAXIMUM))\n        *yymsg_alloc = YYSTACK_ALLOC_MAXIMUM;\n      return 1;\n    }\n\n  /* Avoid sprintf, as that infringes on the user's name space.\n     Don't have undefined behavior even if the translation\n     produced a string with the wrong number of \"%s\"s.  */\n  {\n    char *yyp = *yymsg;\n    int yyi = 0;\n    while ((*yyp = *yyformat) != '\\0')\n      if (*yyp == '%' && yyformat[1] == 's' && yyi < yycount)\n        {\n          yyp += yytnamerr (yyp, yyarg[yyi++]);\n          yyformat += 2;\n        }\n      else\n        {\n          yyp++;\n          yyformat++;\n        }\n  }\n  return 0;\n}",
      "lines": 126,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "yydestruct": {
      "start_point": [
        1349,
        0
      ],
      "end_point": [
        1361,
        1
      ],
      "content": "static void\nyydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep, parser_control *pc)\n{\n  YYUSE (yyvaluep);\n  YYUSE (pc);\n  if (!yymsg)\n    yymsg = \"Deleting\";\n  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);\n\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  YYUSE (yytype);\n  YY_IGNORE_MAYBE_UNINITIALIZED_END\n}",
      "lines": 13,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yyparse": {
      "start_point": [
        1370,
        0
      ],
      "end_point": [
        2379,
        1
      ],
      "content": "int\nyyparse (parser_control *pc)\n{\n/* The lookahead symbol.  */\nint yychar;\n\n\n/* The semantic value of the lookahead symbol.  */\n/* Default value used for initialization, for pacifying older GCCs\n   or non-GCC compilers.  */\nYY_INITIAL_VALUE (static YYSTYPE yyval_default;)\nYYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n\n    /* Number of syntax errors so far.  */\n    int yynerrs;\n\n    int yystate;\n    /* Number of tokens to shift before error messages enabled.  */\n    int yyerrstatus;\n\n    /* The stacks and their tools:\n       'yyss': related to states.\n       'yyvs': related to semantic values.\n\n       Refer to the stacks through separate pointers, to allow yyoverflow\n       to reallocate them elsewhere.  */\n\n    /* The state stack.  */\n    yytype_int16 yyssa[YYINITDEPTH];\n    yytype_int16 *yyss;\n    yytype_int16 *yyssp;\n\n    /* The semantic value stack.  */\n    YYSTYPE yyvsa[YYINITDEPTH];\n    YYSTYPE *yyvs;\n    YYSTYPE *yyvsp;\n\n    YYSIZE_T yystacksize;\n\n  int yyn;\n  int yyresult;\n  /* Lookahead token as an internal (translated) token number.  */\n  int yytoken = 0;\n  /* The variables used to return semantic value and location from the\n     action routines.  */\n  YYSTYPE yyval;\n\n#if YYERROR_VERBOSE\n  /* Buffer for error messages, and its allocated size.  */\n  char yymsgbuf[128];\n  char *yymsg = yymsgbuf;\n  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;\n#endif\n\n#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))\n\n  /* The number of symbols on the RHS of the reduced rule.\n     Keep to zero when no symbol should be popped.  */\n  int yylen = 0;\n\n  yyssp = yyss = yyssa;\n  yyvsp = yyvs = yyvsa;\n  yystacksize = YYINITDEPTH;\n\n  YYDPRINTF ((stderr, \"Starting parse\\n\"));\n\n  yystate = 0;\n  yyerrstatus = 0;\n  yynerrs = 0;\n  yychar = YYEMPTY; /* Cause a token to be read.  */\n  goto yysetstate;\n\n/*------------------------------------------------------------.\n| yynewstate -- Push a new state, which is found in yystate.  |\n`------------------------------------------------------------*/\n yynewstate:\n  /* In all cases, when you get here, the value and location stacks\n     have just been pushed.  So pushing a state here evens the stacks.  */\n  yyssp++;\n\n yysetstate:\n  *yyssp = yystate;\n\n  if (yyss + yystacksize - 1 <= yyssp)\n    {\n      /* Get the current used size of the three stacks, in elements.  */\n      YYSIZE_T yysize = yyssp - yyss + 1;\n\n#ifdef yyoverflow\n      {\n        /* Give user a chance to reallocate the stack.  Use copies of\n           these so that the &'s don't force the real ones into\n           memory.  */\n        YYSTYPE *yyvs1 = yyvs;\n        yytype_int16 *yyss1 = yyss;\n\n        /* Each stack pointer address is followed by the size of the\n           data in use in that stack, in bytes.  This used to be a\n           conditional around just the two extra args, but that might\n           be undefined if yyoverflow is a macro.  */\n        yyoverflow (YY_(\"memory exhausted\"),\n                    &yyss1, yysize * sizeof (*yyssp),\n                    &yyvs1, yysize * sizeof (*yyvsp),\n                    &yystacksize);\n\n        yyss = yyss1;\n        yyvs = yyvs1;\n      }\n#else /* no yyoverflow */\n# ifndef YYSTACK_RELOCATE\n      goto yyexhaustedlab;\n# else\n      /* Extend the stack our own way.  */\n      if (YYMAXDEPTH <= yystacksize)\n        goto yyexhaustedlab;\n      yystacksize *= 2;\n      if (YYMAXDEPTH < yystacksize)\n        yystacksize = YYMAXDEPTH;\n\n      {\n        yytype_int16 *yyss1 = yyss;\n        union yyalloc *yyptr =\n          (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));\n        if (! yyptr)\n          goto yyexhaustedlab;\n        YYSTACK_RELOCATE (yyss_alloc, yyss);\n        YYSTACK_RELOCATE (yyvs_alloc, yyvs);\n#  undef YYSTACK_RELOCATE\n        if (yyss1 != yyssa)\n          YYSTACK_FREE (yyss1);\n      }\n# endif\n#endif /* no yyoverflow */\n\n      yyssp = yyss + yysize - 1;\n      yyvsp = yyvs + yysize - 1;\n\n      YYDPRINTF ((stderr, \"Stack size increased to %lu\\n\",\n                  (unsigned long int) yystacksize));\n\n      if (yyss + yystacksize - 1 <= yyssp)\n        YYABORT;\n    }\n\n  YYDPRINTF ((stderr, \"Entering state %d\\n\", yystate));\n\n  if (yystate == YYFINAL)\n    YYACCEPT;\n\n  goto yybackup;\n\n/*-----------.\n| yybackup.  |\n`-----------*/\nyybackup:\n\n  /* Do appropriate processing given the current state.  Read a\n     lookahead token if we need one and don't already have one.  */\n\n  /* First try to decide what to do without reference to lookahead token.  */\n  yyn = yypact[yystate];\n  if (yypact_value_is_default (yyn))\n    goto yydefault;\n\n  /* Not known => get a lookahead token if don't already have one.  */\n\n  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */\n  if (yychar == YYEMPTY)\n    {\n      YYDPRINTF ((stderr, \"Reading a token: \"));\n      yychar = yylex (&yylval, pc);\n    }\n\n  if (yychar <= YYEOF)\n    {\n      yychar = yytoken = YYEOF;\n      YYDPRINTF ((stderr, \"Now at end of input.\\n\"));\n    }\n  else\n    {\n      yytoken = YYTRANSLATE (yychar);\n      YY_SYMBOL_PRINT (\"Next token is\", yytoken, &yylval, &yylloc);\n    }\n\n  /* If the proper action on seeing token YYTOKEN is to reduce or to\n     detect an error, take that action.  */\n  yyn += yytoken;\n  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)\n    goto yydefault;\n  yyn = yytable[yyn];\n  if (yyn <= 0)\n    {\n      if (yytable_value_is_error (yyn))\n        goto yyerrlab;\n      yyn = -yyn;\n      goto yyreduce;\n    }\n\n  /* Count tokens shifted since error; after three, turn off error\n     status.  */\n  if (yyerrstatus)\n    yyerrstatus--;\n\n  /* Shift the lookahead token.  */\n  YY_SYMBOL_PRINT (\"Shifting\", yytoken, &yylval, &yylloc);\n\n  /* Discard the shifted token.  */\n  yychar = YYEMPTY;\n\n  yystate = yyn;\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  *++yyvsp = yylval;\n  YY_IGNORE_MAYBE_UNINITIALIZED_END\n\n  goto yynewstate;\n\n\n/*-----------------------------------------------------------.\n| yydefault -- do the default action for the current state.  |\n`-----------------------------------------------------------*/\nyydefault:\n  yyn = yydefact[yystate];\n  if (yyn == 0)\n    goto yyerrlab;\n  goto yyreduce;\n\n\n/*-----------------------------.\n| yyreduce -- Do a reduction.  |\n`-----------------------------*/\nyyreduce:\n  /* yyn is the number of a rule to reduce with.  */\n  yylen = yyr2[yyn];\n\n  /* If YYLEN is nonzero, implement the default value of the action:\n     '$$ = $1'.\n\n     Otherwise, the following line sets YYVAL to garbage.\n     This behavior is undocumented and Bison\n     users should not rely upon it.  Assigning to YYVAL\n     unconditionally makes the parser a bit smaller, and it avoids a\n     GCC warning that YYVAL may be used uninitialized.  */\n  yyval = yyvsp[1-yylen];\n\n\n  YY_REDUCE_PRINT (yyn);\n  switch (yyn)\n    {\n        case 4:\n#line 330 \"/home/james/source/GNU/findutils/git/gnu/findutils/gl/lib/parse-datetime.y\" /* yacc.c:1646  */\n    {\n        pc->seconds = (yyvsp[0].timespec);\n        pc->timespec_seen = true;\n      }\n#line 1626 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 7:\n#line 343 \"/home/james/source/GNU/findutils/git/gnu/findutils/gl/lib/parse-datetime.y\" /* yacc.c:1646  */\n    { pc->times_seen++; pc->dates_seen++; }\n#line 1632 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 8:\n#line 345 \"/home/james/source/GNU/findutils/git/gnu/findutils/gl/lib/parse-datetime.y\" /* yacc.c:1646  */\n    { pc->times_seen++; }\n#line 1638 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 9:\n#line 347 \"/home/james/source/GNU/findutils/git/gnu/findutils/gl/lib/parse-datetime.y\" /* yacc.c:1646  */\n    { pc->local_zones_seen++; }\n#line 1644 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 10:\n#line 349 \"/home/james/source/GNU/findutils/git/gnu/findutils/gl/lib/parse-datetime.y\" /* yacc.c:1646  */\n    { pc->zones_seen++; }\n#line 1650 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 11:\n#line 351 \"/home/james/source/GNU/findutils/git/gnu/findutils/gl/lib/parse-datetime.y\" /* yacc.c:1646  */\n    { pc->dates_seen++; }\n#line 1656 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 12:\n#line 353 \"/home/james/source/GNU/findutils/git/gnu/findutils/gl/lib/parse-datetime.y\" /* yacc.c:1646  */\n    { pc->days_seen++; }\n#line 1662 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 18:\n#line 369 \"/home/james/source/GNU/findutils/git/gnu/findutils/gl/lib/parse-datetime.y\" /* yacc.c:1646  */\n    {\n        set_hhmmss (pc, (yyvsp[-1].textintval).value, 0, 0, 0);\n        pc->meridian = (yyvsp[0].intval);\n      }\n#line 1671 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 19:\n#line 374 \"/home/james/source/GNU/findutils/git/gnu/findutils/gl/lib/parse-datetime.y\" /* yacc.c:1646  */\n    {\n        set_hhmmss (pc, (yyvsp[-3].textintval).value, (yyvsp[-1].textintval).value, 0, 0);\n        pc->meridian = (yyvsp[0].intval);\n      }\n#line 1680 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 20:\n#line 379 \"/home/james/source/GNU/findutils/git/gnu/findutils/gl/lib/parse-datetime.y\" /* yacc.c:1646  */\n    {\n        set_hhmmss (pc, (yyvsp[-5].textintval).value, (yyvsp[-3].textintval).value, (yyvsp[-1].timespec).tv_sec, (yyvsp[-1].timespec).tv_nsec);\n        pc->meridian = (yyvsp[0].intval);\n      }\n#line 1689 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 22:\n#line 388 \"/home/james/source/GNU/findutils/git/gnu/findutils/gl/lib/parse-datetime.y\" /* yacc.c:1646  */\n    {\n        set_hhmmss (pc, (yyvsp[-1].textintval).value, 0, 0, 0);\n        pc->meridian = MER24;\n      }\n#line 1698 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 23:\n#line 393 \"/home/james/source/GNU/findutils/git/gnu/findutils/gl/lib/parse-datetime.y\" /* yacc.c:1646  */\n    {\n        set_hhmmss (pc, (yyvsp[-3].textintval).value, (yyvsp[-1].textintval).value, 0, 0);\n        pc->meridian = MER24;\n      }\n#line 1707 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 24:\n#line 398 \"/home/james/source/GNU/findutils/git/gnu/findutils/gl/lib/parse-datetime.y\" /* yacc.c:1646  */\n    {\n        set_hhmmss (pc, (yyvsp[-5].textintval).value, (yyvsp[-3].textintval).value, (yyvsp[-1].timespec).tv_sec, (yyvsp[-1].timespec).tv_nsec);\n        pc->meridian = MER24;\n      }\n#line 1716 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 27:\n#line 411 \"/home/james/source/GNU/findutils/git/gnu/findutils/gl/lib/parse-datetime.y\" /* yacc.c:1646  */\n    {\n        pc->zones_seen++;\n        pc->time_zone = time_zone_hhmm (pc, (yyvsp[-1].textintval), (yyvsp[0].intval));\n      }\n#line 1725 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 28:\n#line 419 \"/home/james/source/GNU/findutils/git/gnu/findutils/gl/lib/parse-datetime.y\" /* yacc.c:1646  */\n    {\n        pc->local_isdst = (yyvsp[0].intval);\n        pc->dsts_seen += (0 < (yyvsp[0].intval));\n      }\n#line 1734 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 29:\n#line 424 \"/home/james/source/GNU/findutils/git/gnu/findutils/gl/lib/parse-datetime.y\" /* yacc.c:1646  */\n    {\n        pc->local_isdst = 1;\n        pc->dsts_seen += (0 < (yyvsp[-1].intval)) + 1;\n      }\n#line 1743 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 30:\n#line 434 \"/home/james/source/GNU/findutils/git/gnu/findutils/gl/lib/parse-datetime.y\" /* yacc.c:1646  */\n    { pc->time_zone = (yyvsp[0].intval); }\n#line 1749 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 31:\n#line 436 \"/home/james/source/GNU/findutils/git/gnu/findutils/gl/lib/parse-datetime.y\" /* yacc.c:1646  */\n    { pc->time_zone = HOUR(7); }\n#line 1755 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 32:\n#line 438 \"/home/james/source/GNU/findutils/git/gnu/findutils/gl/lib/parse-datetime.y\" /* yacc.c:1646  */\n    { pc->time_zone = (yyvsp[-1].intval);\n        apply_relative_time (pc, (yyvsp[0].rel), 1); }\n#line 1762 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 33:\n#line 441 \"/home/james/source/GNU/findutils/git/gnu/findutils/gl/lib/parse-datetime.y\" /* yacc.c:1646  */\n    { pc->time_zone = HOUR(7);\n        apply_relative_time (pc, (yyvsp[0].rel), 1); }\n#line 1769 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 34:\n#line 444 \"/home/james/source/GNU/findutils/git/gnu/findutils/gl/lib/parse-datetime.y\" /* yacc.c:1646  */\n    { pc->time_zone = (yyvsp[-2].intval) + time_zone_hhmm (pc, (yyvsp[-1].textintval), (yyvsp[0].intval)); }\n#line 1775 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 35:\n#line 446 \"/home/james/source/GNU/findutils/git/gnu/findutils/gl/lib/parse-datetime.y\" /* yacc.c:1646  */\n    { pc->time_zone = (yyvsp[0].intval) + 60; }\n#line 1781 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 36:\n#line 448 \"/home/james/source/GNU/findutils/git/gnu/findutils/gl/lib/parse-datetime.y\" /* yacc.c:1646  */\n    { pc->time_zone = (yyvsp[-1].intval) + 60; }\n#line 1787 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 37:\n#line 453 \"/home/james/source/GNU/findutils/git/gnu/findutils/gl/lib/parse-datetime.y\" /* yacc.c:1646  */\n    {\n        pc->day_ordinal = 0;\n        pc->day_number = (yyvsp[0].intval);\n      }\n#line 1796 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 38:\n#line 458 \"/home/james/source/GNU/findutils/git/gnu/findutils/gl/lib/parse-datetime.y\" /* yacc.c:1646  */\n    {\n        pc->day_ordinal = 0;\n        pc->day_number = (yyvsp[-1].intval);\n      }\n#line 1805 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 39:\n#line 463 \"/home/james/source/GNU/findutils/git/gnu/findutils/gl/lib/parse-datetime.y\" /* yacc.c:1646  */\n    {\n        pc->day_ordinal = (yyvsp[-1].intval);\n        pc->day_number = (yyvsp[0].intval);\n      }\n#line 1814 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 40:\n#line 468 \"/home/james/source/GNU/findutils/git/gnu/findutils/gl/lib/parse-datetime.y\" /* yacc.c:1646  */\n    {\n        pc->day_ordinal = (yyvsp[-1].textintval).value;\n        pc->day_number = (yyvsp[0].intval);\n      }\n#line 1823 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 41:\n#line 476 \"/home/james/source/GNU/findutils/git/gnu/findutils/gl/lib/parse-datetime.y\" /* yacc.c:1646  */\n    {\n        pc->month = (yyvsp[-2].textintval).value;\n        pc->day = (yyvsp[0].textintval).value;\n      }\n#line 1832 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 42:\n#line 481 \"/home/james/source/GNU/findutils/git/gnu/findutils/gl/lib/parse-datetime.y\" /* yacc.c:1646  */\n    {\n        /* Interpret as YYYY/MM/DD if the first value has 4 or more digits,\n           otherwise as MM/DD/YY.\n           The goal in recognizing YYYY/MM/DD is solely to support legacy\n           machine-generated dates like those in an RCS log listing.  If\n           you want portability, use the ISO 8601 format.  */\n        if (4 <= (yyvsp[-4].textintval).digits)\n          {\n            pc->year = (yyvsp[-4].textintval);\n            pc->month = (yyvsp[-2].textintval).value;\n            pc->day = (yyvsp[0].textintval).value;\n          }\n        else\n          {\n            pc->month = (yyvsp[-4].textintval).value;\n            pc->day = (yyvsp[-2].textintval).value;\n            pc->year = (yyvsp[0].textintval);\n          }\n      }\n#line 1856 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 43:\n#line 501 \"/home/james/source/GNU/findutils/git/gnu/findutils/gl/lib/parse-datetime.y\" /* yacc.c:1646  */\n    {\n        /* e.g. 17-JUN-1992.  */\n        pc->day = (yyvsp[-2].textintval).value;\n        pc->month = (yyvsp[-1].intval);\n        pc->year.value = -(yyvsp[0].textintval).value;\n        pc->year.digits = (yyvsp[0].textintval).digits;\n      }\n#line 1868 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 44:\n#line 509 \"/home/james/source/GNU/findutils/git/gnu/findutils/gl/lib/parse-datetime.y\" /* yacc.c:1646  */\n    {\n        /* e.g. JUN-17-1992.  */\n        pc->month = (yyvsp[-2].intval);\n        pc->day = -(yyvsp[-1].textintval).value;\n        pc->year.value = -(yyvsp[0].textintval).value;\n        pc->year.digits = (yyvsp[0].textintval).digits;\n      }\n#line 1880 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 45:\n#line 517 \"/home/james/source/GNU/findutils/git/gnu/findutils/gl/lib/parse-datetime.y\" /* yacc.c:1646  */\n    {\n        pc->month = (yyvsp[-1].intval);\n        pc->day = (yyvsp[0].textintval).value;\n      }\n#line 1889 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 46:\n#line 522 \"/home/james/source/GNU/findutils/git/gnu/findutils/gl/lib/parse-datetime.y\" /* yacc.c:1646  */\n    {\n        pc->month = (yyvsp[-3].intval);\n        pc->day = (yyvsp[-2].textintval).value;\n        pc->year = (yyvsp[0].textintval);\n      }\n#line 1899 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 47:\n#line 528 \"/home/james/source/GNU/findutils/git/gnu/findutils/gl/lib/parse-datetime.y\" /* yacc.c:1646  */\n    {\n        pc->day = (yyvsp[-1].textintval).value;\n        pc->month = (yyvsp[0].intval);\n      }\n#line 1908 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 48:\n#line 533 \"/home/james/source/GNU/findutils/git/gnu/findutils/gl/lib/parse-datetime.y\" /* yacc.c:1646  */\n    {\n        pc->day = (yyvsp[-2].textintval).value;\n        pc->month = (yyvsp[-1].intval);\n        pc->year = (yyvsp[0].textintval);\n      }\n#line 1918 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 50:\n#line 543 \"/home/james/source/GNU/findutils/git/gnu/findutils/gl/lib/parse-datetime.y\" /* yacc.c:1646  */\n    {\n        /* ISO 8601 format.  YYYY-MM-DD.  */\n        pc->year = (yyvsp[-2].textintval);\n        pc->month = -(yyvsp[-1].textintval).value;\n        pc->day = -(yyvsp[0].textintval).value;\n      }\n#line 1929 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 51:\n#line 553 \"/home/james/source/GNU/findutils/git/gnu/findutils/gl/lib/parse-datetime.y\" /* yacc.c:1646  */\n    { apply_relative_time (pc, (yyvsp[-1].rel), (yyvsp[0].intval)); }\n#line 1935 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 52:\n#line 555 \"/home/james/source/GNU/findutils/git/gnu/findutils/gl/lib/parse-datetime.y\" /* yacc.c:1646  */\n    { apply_relative_time (pc, (yyvsp[0].rel), 1); }\n#line 1941 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 53:\n#line 557 \"/home/james/source/GNU/findutils/git/gnu/findutils/gl/lib/parse-datetime.y\" /* yacc.c:1646  */\n    { apply_relative_time (pc, (yyvsp[0].rel), 1); }\n#line 1947 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 54:\n#line 562 \"/home/james/source/GNU/findutils/git/gnu/findutils/gl/lib/parse-datetime.y\" /* yacc.c:1646  */\n    { (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).year = (yyvsp[-1].intval); }\n#line 1953 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 55:\n#line 564 \"/home/james/source/GNU/findutils/git/gnu/findutils/gl/lib/parse-datetime.y\" /* yacc.c:1646  */\n    { (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).year = (yyvsp[-1].textintval).value; }\n#line 1959 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 56:\n#line 566 \"/home/james/source/GNU/findutils/git/gnu/findutils/gl/lib/parse-datetime.y\" /* yacc.c:1646  */\n    { (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).year = 1; }\n#line 1965 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 57:\n#line 568 \"/home/james/source/GNU/findutils/git/gnu/findutils/gl/lib/parse-datetime.y\" /* yacc.c:1646  */\n    { (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).month = (yyvsp[-1].intval); }\n#line 1971 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 58:\n#line 570 \"/home/james/source/GNU/findutils/git/gnu/findutils/gl/lib/parse-datetime.y\" /* yacc.c:1646  */\n    { (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).month = (yyvsp[-1].textintval).value; }\n#line 1977 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 59:\n#line 572 \"/home/james/source/GNU/findutils/git/gnu/findutils/gl/lib/parse-datetime.y\" /* yacc.c:1646  */\n    { (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).month = 1; }\n#line 1983 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 60:\n#line 574 \"/home/james/source/GNU/findutils/git/gnu/findutils/gl/lib/parse-datetime.y\" /* yacc.c:1646  */\n    { (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).day = (yyvsp[-1].intval) * (yyvsp[0].intval); }\n#line 1989 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 61:\n#line 576 \"/home/james/source/GNU/findutils/git/gnu/findutils/gl/lib/parse-datetime.y\" /* yacc.c:1646  */\n    { (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).day = (yyvsp[-1].textintval).value * (yyvsp[0].intval); }\n#line 1995 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 62:\n#line 578 \"/home/james/source/GNU/findutils/git/gnu/findutils/gl/lib/parse-datetime.y\" /* yacc.c:1646  */\n    { (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).day = (yyvsp[0].intval); }\n#line 2001 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 63:\n#line 580 \"/home/james/source/GNU/findutils/git/gnu/findutils/gl/lib/parse-datetime.y\" /* yacc.c:1646  */\n    { (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).hour = (yyvsp[-1].intval); }\n#line 2007 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 64:\n#line 582 \"/home/james/source/GNU/findutils/git/gnu/findutils/gl/lib/parse-datetime.y\" /* yacc.c:1646  */\n    { (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).hour = (yyvsp[-1].textintval).value; }\n#line 2013 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 65:\n#line 584 \"/home/james/source/GNU/findutils/git/gnu/findutils/gl/lib/parse-datetime.y\" /* yacc.c:1646  */\n    { (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).hour = 1; }\n#line 2019 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 66:\n#line 586 \"/home/james/source/GNU/findutils/git/gnu/findutils/gl/lib/parse-datetime.y\" /* yacc.c:1646  */\n    { (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).minutes = (yyvsp[-1].intval); }\n#line 2025 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 67:\n#line 588 \"/home/james/source/GNU/findutils/git/gnu/findutils/gl/lib/parse-datetime.y\" /* yacc.c:1646  */\n    { (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).minutes = (yyvsp[-1].textintval).value; }\n#line 2031 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 68:\n#line 590 \"/home/james/source/GNU/findutils/git/gnu/findutils/gl/lib/parse-datetime.y\" /* yacc.c:1646  */\n    { (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).minutes = 1; }\n#line 2037 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 69:\n#line 592 \"/home/james/source/GNU/findutils/git/gnu/findutils/gl/lib/parse-datetime.y\" /* yacc.c:1646  */\n    { (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).seconds = (yyvsp[-1].intval); }\n#line 2043 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 70:\n#line 594 \"/home/james/source/GNU/findutils/git/gnu/findutils/gl/lib/parse-datetime.y\" /* yacc.c:1646  */\n    { (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).seconds = (yyvsp[-1].textintval).value; }\n#line 2049 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 71:\n#line 596 \"/home/james/source/GNU/findutils/git/gnu/findutils/gl/lib/parse-datetime.y\" /* yacc.c:1646  */\n    { (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).seconds = (yyvsp[-1].timespec).tv_sec; (yyval.rel).ns = (yyvsp[-1].timespec).tv_nsec; }\n#line 2055 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 72:\n#line 598 \"/home/james/source/GNU/findutils/git/gnu/findutils/gl/lib/parse-datetime.y\" /* yacc.c:1646  */\n    { (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).seconds = (yyvsp[-1].timespec).tv_sec; (yyval.rel).ns = (yyvsp[-1].timespec).tv_nsec; }\n#line 2061 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 73:\n#line 600 \"/home/james/source/GNU/findutils/git/gnu/findutils/gl/lib/parse-datetime.y\" /* yacc.c:1646  */\n    { (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).seconds = 1; }\n#line 2067 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 75:\n#line 606 \"/home/james/source/GNU/findutils/git/gnu/findutils/gl/lib/parse-datetime.y\" /* yacc.c:1646  */\n    { (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).year = (yyvsp[-1].textintval).value; }\n#line 2073 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 76:\n#line 608 \"/home/james/source/GNU/findutils/git/gnu/findutils/gl/lib/parse-datetime.y\" /* yacc.c:1646  */\n    { (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).month = (yyvsp[-1].textintval).value; }\n#line 2079 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 77:\n#line 610 \"/home/james/source/GNU/findutils/git/gnu/findutils/gl/lib/parse-datetime.y\" /* yacc.c:1646  */\n    { (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).day = (yyvsp[-1].textintval).value * (yyvsp[0].intval); }\n#line 2085 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 78:\n#line 612 \"/home/james/source/GNU/findutils/git/gnu/findutils/gl/lib/parse-datetime.y\" /* yacc.c:1646  */\n    { (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).hour = (yyvsp[-1].textintval).value; }\n#line 2091 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 79:\n#line 614 \"/home/james/source/GNU/findutils/git/gnu/findutils/gl/lib/parse-datetime.y\" /* yacc.c:1646  */\n    { (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).minutes = (yyvsp[-1].textintval).value; }\n#line 2097 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 80:\n#line 616 \"/home/james/source/GNU/findutils/git/gnu/findutils/gl/lib/parse-datetime.y\" /* yacc.c:1646  */\n    { (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).seconds = (yyvsp[-1].textintval).value; }\n#line 2103 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 81:\n#line 621 \"/home/james/source/GNU/findutils/git/gnu/findutils/gl/lib/parse-datetime.y\" /* yacc.c:1646  */\n    { (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).day = (yyvsp[0].intval); }\n#line 2109 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 85:\n#line 629 \"/home/james/source/GNU/findutils/git/gnu/findutils/gl/lib/parse-datetime.y\" /* yacc.c:1646  */\n    { (yyval.timespec).tv_sec = (yyvsp[0].textintval).value; (yyval.timespec).tv_nsec = 0; }\n#line 2115 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 87:\n#line 635 \"/home/james/source/GNU/findutils/git/gnu/findutils/gl/lib/parse-datetime.y\" /* yacc.c:1646  */\n    { (yyval.timespec).tv_sec = (yyvsp[0].textintval).value; (yyval.timespec).tv_nsec = 0; }\n#line 2121 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 88:\n#line 640 \"/home/james/source/GNU/findutils/git/gnu/findutils/gl/lib/parse-datetime.y\" /* yacc.c:1646  */\n    { digits_to_date_time (pc, (yyvsp[0].textintval)); }\n#line 2127 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 89:\n#line 645 \"/home/james/source/GNU/findutils/git/gnu/findutils/gl/lib/parse-datetime.y\" /* yacc.c:1646  */\n    {\n        /* Hybrid all-digit and relative offset, so that we accept e.g.,\n           \"YYYYMMDD +N days\" as well as \"YYYYMMDD N days\".  */\n        digits_to_date_time (pc, (yyvsp[-1].textintval));\n        apply_relative_time (pc, (yyvsp[0].rel), 1);\n      }\n#line 2138 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 90:\n#line 655 \"/home/james/source/GNU/findutils/git/gnu/findutils/gl/lib/parse-datetime.y\" /* yacc.c:1646  */\n    { (yyval.intval) = -1; }\n#line 2144 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n  case 91:\n#line 657 \"/home/james/source/GNU/findutils/git/gnu/findutils/gl/lib/parse-datetime.y\" /* yacc.c:1646  */\n    { (yyval.intval) = (yyvsp[0].textintval).value; }\n#line 2150 \"parse-datetime.c\" /* yacc.c:1646  */\n    break;\n\n\n#line 2154 \"parse-datetime.c\" /* yacc.c:1646  */\n      default: break;\n    }\n  /* User semantic actions sometimes alter yychar, and that requires\n     that yytoken be updated with the new translation.  We take the\n     approach of translating immediately before every use of yytoken.\n     One alternative is translating here after every semantic action,\n     but that translation would be missed if the semantic action invokes\n     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or\n     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an\n     incorrect destructor might then be invoked immediately.  In the\n     case of YYERROR or YYBACKUP, subsequent parser actions might lead\n     to an incorrect destructor call or verbose syntax error message\n     before the lookahead is translated.  */\n  YY_SYMBOL_PRINT (\"-> $$ =\", yyr1[yyn], &yyval, &yyloc);\n\n  YYPOPSTACK (yylen);\n  yylen = 0;\n  YY_STACK_PRINT (yyss, yyssp);\n\n  *++yyvsp = yyval;\n\n  /* Now 'shift' the result of the reduction.  Determine what state\n     that goes to, based on the state we popped back to and the rule\n     number reduced by.  */\n\n  yyn = yyr1[yyn];\n\n  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;\n  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)\n    yystate = yytable[yystate];\n  else\n    yystate = yydefgoto[yyn - YYNTOKENS];\n\n  goto yynewstate;\n\n\n/*--------------------------------------.\n| yyerrlab -- here on detecting error.  |\n`--------------------------------------*/\nyyerrlab:\n  /* Make sure we have latest lookahead translation.  See comments at\n     user semantic actions for why this is necessary.  */\n  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);\n\n  /* If not already recovering from an error, report this error.  */\n  if (!yyerrstatus)\n    {\n      ++yynerrs;\n#if ! YYERROR_VERBOSE\n      yyerror (pc, YY_(\"syntax error\"));\n#else\n# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \\\n                                        yyssp, yytoken)\n      {\n        char const *yymsgp = YY_(\"syntax error\");\n        int yysyntax_error_status;\n        yysyntax_error_status = YYSYNTAX_ERROR;\n        if (yysyntax_error_status == 0)\n          yymsgp = yymsg;\n        else if (yysyntax_error_status == 1)\n          {\n            if (yymsg != yymsgbuf)\n              YYSTACK_FREE (yymsg);\n            yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);\n            if (!yymsg)\n              {\n                yymsg = yymsgbuf;\n                yymsg_alloc = sizeof yymsgbuf;\n                yysyntax_error_status = 2;\n              }\n            else\n              {\n                yysyntax_error_status = YYSYNTAX_ERROR;\n                yymsgp = yymsg;\n              }\n          }\n        yyerror (pc, yymsgp);\n        if (yysyntax_error_status == 2)\n          goto yyexhaustedlab;\n      }\n# undef YYSYNTAX_ERROR\n#endif\n    }\n\n\n\n  if (yyerrstatus == 3)\n    {\n      /* If just tried and failed to reuse lookahead token after an\n         error, discard it.  */\n\n      if (yychar <= YYEOF)\n        {\n          /* Return failure if at end of input.  */\n          if (yychar == YYEOF)\n            YYABORT;\n        }\n      else\n        {\n          yydestruct (\"Error: discarding\",\n                      yytoken, &yylval, pc);\n          yychar = YYEMPTY;\n        }\n    }\n\n  /* Else will try to reuse lookahead token after shifting the error\n     token.  */\n  goto yyerrlab1;\n\n\n/*---------------------------------------------------.\n| yyerrorlab -- error raised explicitly by YYERROR.  |\n`---------------------------------------------------*/\nyyerrorlab:\n\n  /* Pacify compilers like GCC when the user code never invokes\n     YYERROR and the label yyerrorlab therefore never appears in user\n     code.  */\n  if (/*CONSTCOND*/ 0)\n     goto yyerrorlab;\n\n  /* Do not reclaim the symbols of the rule whose action triggered\n     this YYERROR.  */\n  YYPOPSTACK (yylen);\n  yylen = 0;\n  YY_STACK_PRINT (yyss, yyssp);\n  yystate = *yyssp;\n  goto yyerrlab1;\n\n\n/*-------------------------------------------------------------.\n| yyerrlab1 -- common code for both syntax error and YYERROR.  |\n`-------------------------------------------------------------*/\nyyerrlab1:\n  yyerrstatus = 3;      /* Each real token shifted decrements this.  */\n\n  for (;;)\n    {\n      yyn = yypact[yystate];\n      if (!yypact_value_is_default (yyn))\n        {\n          yyn += YYTERROR;\n          if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)\n            {\n              yyn = yytable[yyn];\n              if (0 < yyn)\n                break;\n            }\n        }\n\n      /* Pop the current state because it cannot handle the error token.  */\n      if (yyssp == yyss)\n        YYABORT;\n\n\n      yydestruct (\"Error: popping\",\n                  yystos[yystate], yyvsp, pc);\n      YYPOPSTACK (1);\n      yystate = *yyssp;\n      YY_STACK_PRINT (yyss, yyssp);\n    }\n\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  *++yyvsp = yylval;\n  YY_IGNORE_MAYBE_UNINITIALIZED_END\n\n\n  /* Shift the error token.  */\n  YY_SYMBOL_PRINT (\"Shifting\", yystos[yyn], yyvsp, yylsp);\n\n  yystate = yyn;\n  goto yynewstate;\n\n\n/*-------------------------------------.\n| yyacceptlab -- YYACCEPT comes here.  |\n`-------------------------------------*/\nyyacceptlab:\n  yyresult = 0;\n  goto yyreturn;\n\n/*-----------------------------------.\n| yyabortlab -- YYABORT comes here.  |\n`-----------------------------------*/\nyyabortlab:\n  yyresult = 1;\n  goto yyreturn;\n\n#if !defined yyoverflow || YYERROR_VERBOSE\n/*-------------------------------------------------.\n| yyexhaustedlab -- memory exhaustion comes here.  |\n`-------------------------------------------------*/\nyyexhaustedlab:\n  yyerror (pc, YY_(\"memory exhausted\"));\n  yyresult = 2;\n  /* Fall through.  */\n#endif\n\nyyreturn:\n  if (yychar != YYEMPTY)\n    {\n      /* Make sure we have latest lookahead translation.  See comments at\n         user semantic actions for why this is necessary.  */\n      yytoken = YYTRANSLATE (yychar);\n      yydestruct (\"Cleanup: discarding lookahead\",\n                  yytoken, &yylval, pc);\n    }\n  /* Do not reclaim the symbols of the rule whose action triggered\n     this YYABORT or YYACCEPT.  */\n  YYPOPSTACK (yylen);\n  YY_STACK_PRINT (yyss, yyssp);\n  while (yyssp != yyss)\n    {\n      yydestruct (\"Cleanup: popping\",\n                  yystos[*yyssp], yyvsp, pc);\n      YYPOPSTACK (1);\n    }\n#ifndef yyoverflow\n  if (yyss != yyssa)\n    YYSTACK_FREE (yyss);\n#endif\n#if YYERROR_VERBOSE\n  if (yymsg != yymsgbuf)\n    YYSTACK_FREE (yymsg);\n#endif\n  return yyresult;\n}",
      "lines": 1010,
      "depth": 17,
      "decorators": [
        "int"
      ]
    },
    "time_zone_hhmm": {
      "start_point": [
        2579,
        0
      ],
      "end_point": [
        2601,
        1
      ],
      "content": "static long int\ntime_zone_hhmm (parser_control *pc, textint s, long int mm)\n{\n  long int n_minutes;\n\n  /* If the length of S is 1 or 2 and no minutes are specified,\n     interpret it as a number of hours.  */\n  if (s.digits <= 2 && mm < 0)\n    s.value *= 100;\n\n  if (mm < 0)\n    n_minutes = (s.value / 100) * 60 + s.value % 100;\n  else\n    n_minutes = s.value * 60 + (s.negative ? -mm : mm);\n\n  /* If the absolute number of minutes is larger than 24 hours,\n     arrange to reject it by incrementing pc->zones_seen.  Thus,\n     we allow only values in the range UTC-24:00 to UTC+24:00.  */\n  if (24 * 60 < abs (n_minutes))\n    pc->zones_seen++;\n\n  return n_minutes;\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "long int",
        "long",
        "int"
      ]
    },
    "to_hour": {
      "start_point": [
        2603,
        0
      ],
      "end_point": [
        2616,
        1
      ],
      "content": "static int\nto_hour (long int hours, int meridian)\n{\n  switch (meridian)\n    {\n    default: /* Pacify GCC.  */\n    case MER24:\n      return 0 <= hours && hours < 24 ? hours : -1;\n    case MERam:\n      return 0 < hours && hours < 12 ? hours : hours == 12 ? 0 : -1;\n    case MERpm:\n      return 0 < hours && hours < 12 ? hours + 12 : hours == 12 ? 12 : -1;\n    }\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "to_year": {
      "start_point": [
        2618,
        0
      ],
      "end_point": [
        2632,
        1
      ],
      "content": "static long int\nto_year (textint textyear)\n{\n  long int year = textyear.value;\n\n  if (year < 0)\n    year = -year;\n\n  /* XPG4 suggests that years 00-68 map to 2000-2068, and\n     years 69-99 map to 1969-1999.  */\n  else if (textyear.digits == 2)\n    year += year < 69 ? 2000 : 1900;\n\n  return year;\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "long int",
        "long",
        "int"
      ]
    },
    "lookup_zone": {
      "start_point": [
        2634,
        0
      ],
      "end_point": [
        2654,
        1
      ],
      "content": "static table const * _GL_ATTRIBUTE_PURE\nlookup_zone (parser_control const *pc, char const *name)\n{\n  table const *tp;\n\n  for (tp = universal_time_zone_table; tp->name; tp++)\n    if (strcmp (name, tp->name) == 0)\n      return tp;\n\n  /* Try local zone abbreviations before those in time_zone_table, as\n     the local ones are more likely to be right.  */\n  for (tp = pc->local_time_zone_table; tp->name; tp++)\n    if (strcmp (name, tp->name) == 0)\n      return tp;\n\n  for (tp = time_zone_table; tp->name; tp++)\n    if (strcmp (name, tp->name) == 0)\n      return tp;\n\n  return NULL;\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "table",
        "const",
        "const",
        "* _GL_ATTRIBUTE_PURE\nlookup_zone (parser_control const *pc, char const *name)",
        "*",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "tm_diff": {
      "start_point": [
        2661,
        0
      ],
      "end_point": [
        2680,
        1
      ],
      "content": "static long int\ntm_diff (struct tm const *a, struct tm const *b)\n{\n  /* Compute intervening leap days correctly even if year is negative.\n     Take care to avoid int overflow in leap day calculations.  */\n  int a4 = SHR (a->tm_year, 2) + SHR (TM_YEAR_BASE, 2) - ! (a->tm_year & 3);\n  int b4 = SHR (b->tm_year, 2) + SHR (TM_YEAR_BASE, 2) - ! (b->tm_year & 3);\n  int a100 = a4 / 25 - (a4 % 25 < 0);\n  int b100 = b4 / 25 - (b4 % 25 < 0);\n  int a400 = SHR (a100, 2);\n  int b400 = SHR (b100, 2);\n  int intervening_leap_days = (a4 - b4) - (a100 - b100) + (a400 - b400);\n  long int ayear = a->tm_year;\n  long int years = ayear - b->tm_year;\n  long int days = (365 * years + intervening_leap_days\n                   + (a->tm_yday - b->tm_yday));\n  return (60 * (60 * (24 * days + (a->tm_hour - b->tm_hour))\n                + (a->tm_min - b->tm_min))\n          + (a->tm_sec - b->tm_sec));\n}",
      "lines": 20,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "long int",
        "long",
        "int"
      ]
    },
    "lookup_word": {
      "start_point": [
        2683,
        0
      ],
      "end_point": [
        2752,
        1
      ],
      "content": "static table const *\nlookup_word (parser_control const *pc, char *word)\n{\n  char *p;\n  char *q;\n  size_t wordlen;\n  table const *tp;\n  bool period_found;\n  bool abbrev;\n\n  /* Make it uppercase.  */\n  for (p = word; *p; p++)\n    {\n      unsigned char ch = *p;\n      *p = c_toupper (ch);\n    }\n\n  for (tp = meridian_table; tp->name; tp++)\n    if (strcmp (word, tp->name) == 0)\n      return tp;\n\n  /* See if we have an abbreviation for a month. */\n  wordlen = strlen (word);\n  abbrev = wordlen == 3 || (wordlen == 4 && word[3] == '.');\n\n  for (tp = month_and_day_table; tp->name; tp++)\n    if ((abbrev ? strncmp (word, tp->name, 3) : strcmp (word, tp->name)) == 0)\n      return tp;\n\n  if ((tp = lookup_zone (pc, word)))\n    return tp;\n\n  if (strcmp (word, dst_table[0].name) == 0)\n    return dst_table;\n\n  for (tp = time_units_table; tp->name; tp++)\n    if (strcmp (word, tp->name) == 0)\n      return tp;\n\n  /* Strip off any plural and try the units table again. */\n  if (word[wordlen - 1] == 'S')\n    {\n      word[wordlen - 1] = '\\0';\n      for (tp = time_units_table; tp->name; tp++)\n        if (strcmp (word, tp->name) == 0)\n          return tp;\n      word[wordlen - 1] = 'S';  /* For \"this\" in relative_time_table.  */\n    }\n\n  for (tp = relative_time_table; tp->name; tp++)\n    if (strcmp (word, tp->name) == 0)\n      return tp;\n\n  /* Military time zones. */\n  if (wordlen == 1)\n    for (tp = military_table; tp->name; tp++)\n      if (word[0] == tp->name[0])\n        return tp;\n\n  /* Drop out any periods and try the time zone table again. */\n  for (period_found = false, p = q = word; (*p = *q); q++)\n    if (*q == '.')\n      period_found = true;\n    else\n      p++;\n  if (period_found && (tp = lookup_zone (pc, word)))\n    return tp;\n\n  return NULL;\n}",
      "lines": 70,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "table",
        "const",
        "const",
        "*\nlookup_word (parser_control const *pc, char *word)",
        "*"
      ]
    },
    "yylex": {
      "start_point": [
        2754,
        0
      ],
      "end_point": [
        2915,
        1
      ],
      "content": "static int\nyylex (union YYSTYPE *lvalp, parser_control *pc)\n{\n  unsigned char c;\n  size_t count;\n\n  for (;;)\n    {\n      while (c = *pc->input, c_isspace (c))\n        pc->input++;\n\n      if (ISDIGIT (c) || c == '-' || c == '+')\n        {\n          char const *p;\n          int sign;\n          unsigned long int value;\n          if (c == '-' || c == '+')\n            {\n              sign = c == '-' ? -1 : 1;\n              while (c = *++pc->input, c_isspace (c))\n                continue;\n              if (! ISDIGIT (c))\n                /* skip the '-' sign */\n                continue;\n            }\n          else\n            sign = 0;\n          p = pc->input;\n          for (value = 0; ; value *= 10)\n            {\n              unsigned long int value1 = value + (c - '0');\n              if (value1 < value)\n                return '?';\n              value = value1;\n              c = *++p;\n              if (! ISDIGIT (c))\n                break;\n              if (ULONG_MAX / 10 < value)\n                return '?';\n            }\n          if ((c == '.' || c == ',') && ISDIGIT (p[1]))\n            {\n              time_t s;\n              int ns;\n              int digits;\n              unsigned long int value1;\n\n              /* Check for overflow when converting value to time_t.  */\n              if (sign < 0)\n                {\n                  s = - value;\n                  if (0 < s)\n                    return '?';\n                  value1 = -s;\n                }\n              else\n                {\n                  s = value;\n                  if (s < 0)\n                    return '?';\n                  value1 = s;\n                }\n              if (value != value1)\n                return '?';\n\n              /* Accumulate fraction, to ns precision.  */\n              p++;\n              ns = *p++ - '0';\n              for (digits = 2; digits <= LOG10_BILLION; digits++)\n                {\n                  ns *= 10;\n                  if (ISDIGIT (*p))\n                    ns += *p++ - '0';\n                }\n\n              /* Skip excess digits, truncating toward -Infinity.  */\n              if (sign < 0)\n                for (; ISDIGIT (*p); p++)\n                  if (*p != '0')\n                    {\n                      ns++;\n                      break;\n                    }\n              while (ISDIGIT (*p))\n                p++;\n\n              /* Adjust to the timespec convention, which is that\n                 tv_nsec is always a positive offset even if tv_sec is\n                 negative.  */\n              if (sign < 0 && ns)\n                {\n                  s--;\n                  if (! (s < 0))\n                    return '?';\n                  ns = BILLION - ns;\n                }\n\n              lvalp->timespec.tv_sec = s;\n              lvalp->timespec.tv_nsec = ns;\n              pc->input = p;\n              return sign ? tSDECIMAL_NUMBER : tUDECIMAL_NUMBER;\n            }\n          else\n            {\n              lvalp->textintval.negative = sign < 0;\n              if (sign < 0)\n                {\n                  lvalp->textintval.value = - value;\n                  if (0 < lvalp->textintval.value)\n                    return '?';\n                }\n              else\n                {\n                  lvalp->textintval.value = value;\n                  if (lvalp->textintval.value < 0)\n                    return '?';\n                }\n              lvalp->textintval.digits = p - pc->input;\n              pc->input = p;\n              return sign ? tSNUMBER : tUNUMBER;\n            }\n        }\n\n      if (c_isalpha (c))\n        {\n          char buff[20];\n          char *p = buff;\n          table const *tp;\n\n          do\n            {\n              if (p < buff + sizeof buff - 1)\n                *p++ = c;\n              c = *++pc->input;\n            }\n          while (c_isalpha (c) || c == '.');\n\n          *p = '\\0';\n          tp = lookup_word (pc, buff);\n          if (! tp)\n            return '?';\n          lvalp->intval = tp->value;\n          return tp->type;\n        }\n\n      if (c != '(')\n        return to_uchar (*pc->input++);\n\n      count = 0;\n      do\n        {\n          c = *pc->input++;\n          if (c == '\\0')\n            return c;\n          if (c == '(')\n            count++;\n          else if (c == ')')\n            count--;\n        }\n      while (count != 0);\n    }\n}",
      "lines": 162,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "yyerror": {
      "start_point": [
        2918,
        0
      ],
      "end_point": [
        2923,
        1
      ],
      "content": "static int\nyyerror (parser_control const *pc _GL_UNUSED,\n         char const *s _GL_UNUSED)\n{\n  return 0;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "mktime_ok": {
      "start_point": [
        2929,
        0
      ],
      "end_point": [
        2948,
        1
      ],
      "content": "static bool\nmktime_ok (struct tm const *tm0, struct tm const *tm1, time_t t)\n{\n  if (t == (time_t) -1)\n    {\n      /* Guard against falsely reporting an error when parsing a time\n         stamp that happens to equal (time_t) -1, on a host that\n         supports such a time stamp.  */\n      tm1 = localtime (&t);\n      if (!tm1)\n        return false;\n    }\n\n  return ! ((tm0->tm_sec ^ tm1->tm_sec)\n            | (tm0->tm_min ^ tm1->tm_min)\n            | (tm0->tm_hour ^ tm1->tm_hour)\n            | (tm0->tm_mday ^ tm1->tm_mday)\n            | (tm0->tm_mon ^ tm1->tm_mon)\n            | (tm0->tm_year ^ tm1->tm_year));\n}",
      "lines": 20,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "get_tz": {
      "start_point": [
        2956,
        0
      ],
      "end_point": [
        2968,
        1
      ],
      "content": "static char *\nget_tz (char tzbuf[TZBUFSIZE])\n{\n  char *tz = getenv (\"TZ\");\n  if (tz)\n    {\n      size_t tzsize = strlen (tz) + 1;\n      tz = (tzsize <= TZBUFSIZE\n            ? memcpy (tzbuf, tz, tzsize)\n            : xmemdup (tz, tzsize));\n    }\n  return tz;\n}",
      "lines": 13,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nget_tz (char tzbuf[TZBUFSIZE])",
        "*"
      ]
    },
    "parse_datetime": {
      "start_point": [
        2974,
        0
      ],
      "end_point": [
        3311,
        1
      ],
      "content": "bool\nparse_datetime (struct timespec *result, char const *p,\n                struct timespec const *now)\n{\n  time_t Start;\n  long int Start_ns;\n  struct tm const *tmp;\n  struct tm tm;\n  struct tm tm0;\n  parser_control pc;\n  struct timespec gettime_buffer;\n  unsigned char c;\n  bool tz_was_altered = false;\n  char *tz0 = NULL;\n  char tz0buf[TZBUFSIZE];\n  bool ok = true;\n\n  if (! now)\n    {\n      gettime (&gettime_buffer);\n      now = &gettime_buffer;\n    }\n\n  Start = now->tv_sec;\n  Start_ns = now->tv_nsec;\n\n  tmp = localtime (&now->tv_sec);\n  if (! tmp)\n    return false;\n\n  while (c = *p, c_isspace (c))\n    p++;\n\n  if (strncmp (p, \"TZ=\\\"\", 4) == 0)\n    {\n      char const *tzbase = p + 4;\n      size_t tzsize = 1;\n      char const *s;\n\n      for (s = tzbase; *s; s++, tzsize++)\n        if (*s == '\\\\')\n          {\n            s++;\n            if (! (*s == '\\\\' || *s == '\"'))\n              break;\n          }\n        else if (*s == '\"')\n          {\n            char *z;\n            char *tz1;\n            char tz1buf[TZBUFSIZE];\n            bool large_tz = TZBUFSIZE < tzsize;\n            bool setenv_ok;\n            tz0 = get_tz (tz0buf);\n            z = tz1 = large_tz ? xmalloc (tzsize) : tz1buf;\n            for (s = tzbase; *s != '\"'; s++)\n              *z++ = *(s += *s == '\\\\');\n            *z = '\\0';\n            setenv_ok = setenv (\"TZ\", tz1, 1) == 0;\n            if (large_tz)\n              free (tz1);\n            if (!setenv_ok)\n              goto fail;\n            tz_was_altered = true;\n\n            p = s + 1;\n            while (c = *p, c_isspace (c))\n              p++;\n\n            break;\n          }\n    }\n\n  /* As documented, be careful to treat the empty string just like\n     a date string of \"0\".  Without this, an empty string would be\n     declared invalid when parsed during a DST transition.  */\n  if (*p == '\\0')\n    p = \"0\";\n\n  pc.input = p;\n  pc.year.value = tmp->tm_year;\n  pc.year.value += TM_YEAR_BASE;\n  pc.year.digits = 0;\n  pc.month = tmp->tm_mon + 1;\n  pc.day = tmp->tm_mday;\n  pc.hour = tmp->tm_hour;\n  pc.minutes = tmp->tm_min;\n  pc.seconds.tv_sec = tmp->tm_sec;\n  pc.seconds.tv_nsec = Start_ns;\n  tm.tm_isdst = tmp->tm_isdst;\n\n  pc.meridian = MER24;\n  pc.rel = RELATIVE_TIME_0;\n  pc.timespec_seen = false;\n  pc.rels_seen = false;\n  pc.dates_seen = 0;\n  pc.days_seen = 0;\n  pc.times_seen = 0;\n  pc.local_zones_seen = 0;\n  pc.dsts_seen = 0;\n  pc.zones_seen = 0;\n\n#if HAVE_STRUCT_TM_TM_ZONE\n  pc.local_time_zone_table[0].name = tmp->tm_zone;\n  pc.local_time_zone_table[0].type = tLOCAL_ZONE;\n  pc.local_time_zone_table[0].value = tmp->tm_isdst;\n  pc.local_time_zone_table[1].name = NULL;\n\n  /* Probe the names used in the next three calendar quarters, looking\n     for a tm_isdst different from the one we already have.  */\n  {\n    int quarter;\n    for (quarter = 1; quarter <= 3; quarter++)\n      {\n        time_t probe = Start + quarter * (90 * 24 * 60 * 60);\n        struct tm const *probe_tm = localtime (&probe);\n        if (probe_tm && probe_tm->tm_zone\n            && probe_tm->tm_isdst != pc.local_time_zone_table[0].value)\n          {\n              {\n                pc.local_time_zone_table[1].name = probe_tm->tm_zone;\n                pc.local_time_zone_table[1].type = tLOCAL_ZONE;\n                pc.local_time_zone_table[1].value = probe_tm->tm_isdst;\n                pc.local_time_zone_table[2].name = NULL;\n              }\n            break;\n          }\n      }\n  }\n#else\n#if HAVE_TZNAME\n  {\n# if !HAVE_DECL_TZNAME\n    extern char *tzname[];\n# endif\n    int i;\n    for (i = 0; i < 2; i++)\n      {\n        pc.local_time_zone_table[i].name = tzname[i];\n        pc.local_time_zone_table[i].type = tLOCAL_ZONE;\n        pc.local_time_zone_table[i].value = i;\n      }\n    pc.local_time_zone_table[i].name = NULL;\n  }\n#else\n  pc.local_time_zone_table[0].name = NULL;\n#endif\n#endif\n\n  if (pc.local_time_zone_table[0].name && pc.local_time_zone_table[1].name\n      && ! strcmp (pc.local_time_zone_table[0].name,\n                   pc.local_time_zone_table[1].name))\n    {\n      /* This locale uses the same abbreviation for standard and\n         daylight times.  So if we see that abbreviation, we don't\n         know whether it's daylight time.  */\n      pc.local_time_zone_table[0].value = -1;\n      pc.local_time_zone_table[1].name = NULL;\n    }\n\n  if (yyparse (&pc) != 0)\n    goto fail;\n\n  if (pc.timespec_seen)\n    *result = pc.seconds;\n  else\n    {\n      if (1 < (pc.times_seen | pc.dates_seen | pc.days_seen | pc.dsts_seen\n               | (pc.local_zones_seen + pc.zones_seen)))\n        goto fail;\n\n      tm.tm_year = to_year (pc.year) - TM_YEAR_BASE;\n      tm.tm_mon = pc.month - 1;\n      tm.tm_mday = pc.day;\n      if (pc.times_seen || (pc.rels_seen && ! pc.dates_seen && ! pc.days_seen))\n        {\n          tm.tm_hour = to_hour (pc.hour, pc.meridian);\n          if (tm.tm_hour < 0)\n            goto fail;\n          tm.tm_min = pc.minutes;\n          tm.tm_sec = pc.seconds.tv_sec;\n        }\n      else\n        {\n          tm.tm_hour = tm.tm_min = tm.tm_sec = 0;\n          pc.seconds.tv_nsec = 0;\n        }\n\n      /* Let mktime deduce tm_isdst if we have an absolute time stamp.  */\n      if (pc.dates_seen | pc.days_seen | pc.times_seen)\n        tm.tm_isdst = -1;\n\n      /* But if the input explicitly specifies local time with or without\n         DST, give mktime that information.  */\n      if (pc.local_zones_seen)\n        tm.tm_isdst = pc.local_isdst;\n\n      tm0 = tm;\n\n      Start = mktime (&tm);\n\n      if (! mktime_ok (&tm0, &tm, Start))\n        {\n          if (! pc.zones_seen)\n            goto fail;\n          else\n            {\n              /* Guard against falsely reporting errors near the time_t\n                 boundaries when parsing times in other time zones.  For\n                 example, suppose the input string \"1969-12-31 23:00:00 -0100\",\n                 the current time zone is 8 hours ahead of UTC, and the min\n                 time_t value is 1970-01-01 00:00:00 UTC.  Then the min\n                 localtime value is 1970-01-01 08:00:00, and mktime will\n                 therefore fail on 1969-12-31 23:00:00.  To work around the\n                 problem, set the time zone to 1 hour behind UTC temporarily\n                 by setting TZ=\"XXX1:00\" and try mktime again.  */\n\n              long int time_zone = pc.time_zone;\n              long int abs_time_zone = time_zone < 0 ? - time_zone : time_zone;\n              long int abs_time_zone_hour = abs_time_zone / 60;\n              int abs_time_zone_min = abs_time_zone % 60;\n              char tz1buf[sizeof \"XXX+0:00\"\n                          + sizeof pc.time_zone * CHAR_BIT / 3];\n              if (!tz_was_altered)\n                tz0 = get_tz (tz0buf);\n              sprintf (tz1buf, \"XXX%s%ld:%02d\", &\"-\"[time_zone < 0],\n                       abs_time_zone_hour, abs_time_zone_min);\n              if (setenv (\"TZ\", tz1buf, 1) != 0)\n                goto fail;\n              tz_was_altered = true;\n              tm = tm0;\n              Start = mktime (&tm);\n              if (! mktime_ok (&tm0, &tm, Start))\n                goto fail;\n            }\n        }\n\n      if (pc.days_seen && ! pc.dates_seen)\n        {\n          tm.tm_mday += ((pc.day_number - tm.tm_wday + 7) % 7\n                         + 7 * (pc.day_ordinal\n                                - (0 < pc.day_ordinal\n                                   && tm.tm_wday != pc.day_number)));\n          tm.tm_isdst = -1;\n          Start = mktime (&tm);\n          if (Start == (time_t) -1)\n            goto fail;\n        }\n\n      /* Add relative date.  */\n      if (pc.rel.year | pc.rel.month | pc.rel.day)\n        {\n          int year = tm.tm_year + pc.rel.year;\n          int month = tm.tm_mon + pc.rel.month;\n          int day = tm.tm_mday + pc.rel.day;\n          if (((year < tm.tm_year) ^ (pc.rel.year < 0))\n              | ((month < tm.tm_mon) ^ (pc.rel.month < 0))\n              | ((day < tm.tm_mday) ^ (pc.rel.day < 0)))\n            goto fail;\n          tm.tm_year = year;\n          tm.tm_mon = month;\n          tm.tm_mday = day;\n          tm.tm_hour = tm0.tm_hour;\n          tm.tm_min = tm0.tm_min;\n          tm.tm_sec = tm0.tm_sec;\n          tm.tm_isdst = tm0.tm_isdst;\n          Start = mktime (&tm);\n          if (Start == (time_t) -1)\n            goto fail;\n        }\n\n      /* The only \"output\" of this if-block is an updated Start value,\n         so this block must follow others that clobber Start.  */\n      if (pc.zones_seen)\n        {\n          long int delta = pc.time_zone * 60;\n          time_t t1;\n#ifdef HAVE_TM_GMTOFF\n          delta -= tm.tm_gmtoff;\n#else\n          time_t t = Start;\n          struct tm const *gmt = gmtime (&t);\n          if (! gmt)\n            goto fail;\n          delta -= tm_diff (&tm, gmt);\n#endif\n          t1 = Start - delta;\n          if ((Start < t1) != (delta < 0))\n            goto fail;  /* time_t overflow */\n          Start = t1;\n        }\n\n      /* Add relative hours, minutes, and seconds.  On hosts that support\n         leap seconds, ignore the possibility of leap seconds; e.g.,\n         \"+ 10 minutes\" adds 600 seconds, even if one of them is a\n         leap second.  Typically this is not what the user wants, but it's\n         too hard to do it the other way, because the time zone indicator\n         must be applied before relative times, and if mktime is applied\n         again the time zone will be lost.  */\n      {\n        long int sum_ns = pc.seconds.tv_nsec + pc.rel.ns;\n        long int normalized_ns = (sum_ns % BILLION + BILLION) % BILLION;\n        time_t t0 = Start;\n        long int d1 = 60 * 60 * pc.rel.hour;\n        time_t t1 = t0 + d1;\n        long int d2 = 60 * pc.rel.minutes;\n        time_t t2 = t1 + d2;\n        long_time_t d3 = pc.rel.seconds;\n        long_time_t t3 = t2 + d3;\n        long int d4 = (sum_ns - normalized_ns) / BILLION;\n        long_time_t t4 = t3 + d4;\n        time_t t5 = t4;\n\n        if ((d1 / (60 * 60) ^ pc.rel.hour)\n            | (d2 / 60 ^ pc.rel.minutes)\n            | ((t1 < t0) ^ (d1 < 0))\n            | ((t2 < t1) ^ (d2 < 0))\n            | ((t3 < t2) ^ (d3 < 0))\n            | ((t4 < t3) ^ (d4 < 0))\n            | (t5 != t4))\n          goto fail;\n\n        result->tv_sec = t5;\n        result->tv_nsec = normalized_ns;\n      }\n    }\n\n  goto done;\n\n fail:\n  ok = false;\n done:\n  if (tz_was_altered)\n    ok &= (tz0 ? setenv (\"TZ\", tz0, 1) : unsetenv (\"TZ\")) == 0;\n  if (tz0 != tz0buf)\n    free (tz0);\n  return ok;\n}",
      "lines": 338,
      "depth": 19,
      "decorators": [
        "bool"
      ]
    },
    "main": {
      "start_point": [
        3315,
        0
      ],
      "end_point": [
        3346,
        1
      ],
      "content": "int\nmain (int ac, char **av)\n{\n  char buff[BUFSIZ];\n\n  printf (\"Enter date, or blank line to exit.\\n\\t> \");\n  fflush (stdout);\n\n  buff[BUFSIZ - 1] = '\\0';\n  while (fgets (buff, BUFSIZ - 1, stdin) && buff[0])\n    {\n      struct timespec d;\n      struct tm const *tm;\n      if (! parse_datetime (&d, buff, NULL))\n        printf (\"Bad format - couldn't convert.\\n\");\n      else if (! (tm = localtime (&d.tv_sec)))\n        {\n          long int sec = d.tv_sec;\n          printf (\"localtime (%ld) failed\\n\", sec);\n        }\n      else\n        {\n          int ns = d.tv_nsec;\n          printf (\"%04ld-%02d-%02d %02d:%02d:%02d.%09d\\n\",\n                  tm->tm_year + 1900L, tm->tm_mon + 1, tm->tm_mday,\n                  tm->tm_hour, tm->tm_min, tm->tm_sec, ns);\n        }\n      printf (\"\\t> \");\n      fflush (stdout);\n    }\n  return 0;\n}",
      "lines": 32,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/parse-datetime.h": {},
  "findutils/findutils-4.6.0/gl/lib/parse-datetime.y": {
    "to_uchar": {
      "start_point": [
        118,
        0
      ],
      "end_point": [
        118,
        54
      ],
      "content": "static unsigned char to_uchar (char ch) { return ch; }",
      "lines": 1,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "unsigned char",
        "unsigned",
        "char"
      ]
    },
    "digits_to_date_time": {
      "start_point": [
        223,
        0
      ],
      "end_point": [
        257,
        1
      ],
      "content": "static void\ndigits_to_date_time (parser_control *pc, textint text_int)\n{\n  if (pc->dates_seen && ! pc->year.digits\n      && ! pc->rels_seen && (pc->times_seen || 2 < text_int.digits))\n    pc->year = text_int;\n  else\n    {\n      if (4 < text_int.digits)\n        {\n          pc->dates_seen++;\n          pc->day = text_int.value % 100;\n          pc->month = (text_int.value / 100) % 100;\n          pc->year.value = text_int.value / 10000;\n          pc->year.digits = text_int.digits - 4;\n        }\n      else\n        {\n          pc->times_seen++;\n          if (text_int.digits <= 2)\n            {\n              pc->hour = text_int.value;\n              pc->minutes = 0;\n            }\n          else\n            {\n              pc->hour = text_int.value / 100;\n              pc->minutes = text_int.value % 100;\n            }\n          pc->seconds.tv_sec = 0;\n          pc->seconds.tv_nsec = 0;\n          pc->meridian = MER24;\n        }\n    }\n}",
      "lines": 35,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "apply_relative_time": {
      "start_point": [
        260,
        0
      ],
      "end_point": [
        271,
        1
      ],
      "content": "static void\napply_relative_time (parser_control *pc, relative_time rel, int factor)\n{\n  pc->rel.ns += factor * rel.ns;\n  pc->rel.seconds += factor * rel.seconds;\n  pc->rel.minutes += factor * rel.minutes;\n  pc->rel.hour += factor * rel.hour;\n  pc->rel.day += factor * rel.day;\n  pc->rel.month += factor * rel.month;\n  pc->rel.year += factor * rel.year;\n  pc->rels_seen = true;\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "set_hhmmss": {
      "start_point": [
        274,
        0
      ],
      "end_point": [
        282,
        1
      ],
      "content": "static void\nset_hhmmss (parser_control *pc, long int hour, long int minutes,\n            time_t sec, long int nsec)\n{\n  pc->hour = hour;\n  pc->minutes = minutes;\n  pc->seconds.tv_sec = sec;\n  pc->seconds.tv_nsec = nsec;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "tZONE": [
      {
        "start_point": [
          377,
          30
        ],
        "end_point": [
          381,
          7
        ],
        "content": "unsigned_seconds tMERIDIAN\n      {\n        set_hhmmss (pc, $1.value, $3.value, $5.tv_sec, $5.tv_nsec);\n        pc->meridian = $6;\n      }",
        "lines": 5,
        "depth": 7,
        "decorators": null
      },
      {
        "start_point": [
          396,
          30
        ],
        "end_point": [
          400,
          7
        ],
        "content": "unsigned_seconds o_zone_offset\n      {\n        set_hhmmss (pc, $1.value, $3.value, $5.tv_sec, $5.tv_nsec);\n        pc->meridian = MER24;\n      }",
        "lines": 5,
        "depth": 7,
        "decorators": null
      },
      {
        "start_point": [
          422,
          4
        ],
        "end_point": [
          426,
          7
        ],
        "content": "tLOCAL_ZONE tDST\n      {\n        pc->local_isdst = 1;\n        pc->dsts_seen += (0 < $1) + 1;\n      }",
        "lines": 5,
        "depth": 9,
        "decorators": null
      },
      {
        "start_point": [
          436,
          4
        ],
        "end_point": [
          438,
          42
        ],
        "content": "tZONE relunit_snumber\n      { pc->time_zone = $1;\n        apply_relative_time (pc, $2, 1); }",
        "lines": 3,
        "depth": 7,
        "decorators": null
      },
      {
        "start_point": [
          442,
          4
        ],
        "end_point": [
          443,
          59
        ],
        "content": "tZONE tSNUMBER o_colon_minutes\n      { pc->time_zone = $1 + time_zone_hhmm (pc, $2, $3); }",
        "lines": 2,
        "depth": 9,
        "decorators": null
      },
      {
        "start_point": [
          446,
          4
        ],
        "end_point": [
          447,
          34
        ],
        "content": "tZONE tDST\n      { pc->time_zone = $1 + 60; }",
        "lines": 2,
        "depth": 6,
        "decorators": null
      },
      {
        "start_point": [
          461,
          4
        ],
        "end_point": [
          465,
          7
        ],
        "content": "tORDINAL tDAY\n      {\n        pc->day_ordinal = $1;\n        pc->day_number = $2;\n      }",
        "lines": 5,
        "depth": 6,
        "decorators": null
      },
      {
        "start_point": [
          466,
          4
        ],
        "end_point": [
          470,
          7
        ],
        "content": "tUNUMBER tDAY\n      {\n        pc->day_ordinal = $1.value;\n        pc->day_number = $2;\n      }",
        "lines": 5,
        "depth": 6,
        "decorators": null
      },
      {
        "start_point": [
          499,
          4
        ],
        "end_point": [
          506,
          7
        ],
        "content": "tUNUMBER tMONTH tSNUMBER\n      {\n        /* e.g. 17-JUN-1992.  */\n        pc->day = $1.value;\n        pc->month = $2;\n        pc->year.value = -$3.value;\n        pc->year.digits = $3.digits;\n      }",
        "lines": 8,
        "depth": 7,
        "decorators": null
      },
      {
        "start_point": [
          507,
          4
        ],
        "end_point": [
          514,
          7
        ],
        "content": "tMONTH tSNUMBER tSNUMBER\n      {\n        /* e.g. JUN-17-1992.  */\n        pc->month = $1;\n        pc->day = -$2.value;\n        pc->year.value = -$3.value;\n        pc->year.digits = $3.digits;\n      }",
        "lines": 8,
        "depth": 7,
        "decorators": null
      },
      {
        "start_point": [
          515,
          4
        ],
        "end_point": [
          519,
          7
        ],
        "content": "tMONTH tUNUMBER\n      {\n        pc->month = $1;\n        pc->day = $2.value;\n      }",
        "lines": 5,
        "depth": 6,
        "decorators": null
      }
    ],
    "tUNUMBER": [
      {
        "start_point": [
          526,
          4
        ],
        "end_point": [
          530,
          7
        ],
        "content": "tUNUMBER tMONTH\n      {\n        pc->day = $1.value;\n        pc->month = $2;\n      }",
        "lines": 5,
        "depth": 6,
        "decorators": null
      },
      {
        "start_point": [
          531,
          4
        ],
        "end_point": [
          536,
          7
        ],
        "content": "tUNUMBER tMONTH tUNUMBER\n      {\n        pc->day = $1.value;\n        pc->month = $2;\n        pc->year = $3;\n      }",
        "lines": 6,
        "depth": 6,
        "decorators": null
      },
      {
        "start_point": [
          541,
          13
        ],
        "end_point": [
          547,
          7
        ],
        "content": "tSNUMBER tSNUMBER\n      {\n        /* ISO 8601 format.  YYYY-MM-DD.  */\n        pc->year = $1;\n        pc->month = -$2.value;\n        pc->day = -$3.value;\n      }",
        "lines": 7,
        "depth": 7,
        "decorators": null
      }
    ],
    "time_zone_hhmm": {
      "start_point": [
        857,
        0
      ],
      "end_point": [
        879,
        1
      ],
      "content": "static long int\ntime_zone_hhmm (parser_control *pc, textint s, long int mm)\n{\n  long int n_minutes;\n\n  /* If the length of S is 1 or 2 and no minutes are specified,\n     interpret it as a number of hours.  */\n  if (s.digits <= 2 && mm < 0)\n    s.value *= 100;\n\n  if (mm < 0)\n    n_minutes = (s.value / 100) * 60 + s.value % 100;\n  else\n    n_minutes = s.value * 60 + (s.negative ? -mm : mm);\n\n  /* If the absolute number of minutes is larger than 24 hours,\n     arrange to reject it by incrementing pc->zones_seen.  Thus,\n     we allow only values in the range UTC-24:00 to UTC+24:00.  */\n  if (24 * 60 < abs (n_minutes))\n    pc->zones_seen++;\n\n  return n_minutes;\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "long int",
        "long",
        "int"
      ]
    },
    "to_hour": {
      "start_point": [
        881,
        0
      ],
      "end_point": [
        894,
        1
      ],
      "content": "static int\nto_hour (long int hours, int meridian)\n{\n  switch (meridian)\n    {\n    default: /* Pacify GCC.  */\n    case MER24:\n      return 0 <= hours && hours < 24 ? hours : -1;\n    case MERam:\n      return 0 < hours && hours < 12 ? hours : hours == 12 ? 0 : -1;\n    case MERpm:\n      return 0 < hours && hours < 12 ? hours + 12 : hours == 12 ? 12 : -1;\n    }\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "to_year": {
      "start_point": [
        896,
        0
      ],
      "end_point": [
        910,
        1
      ],
      "content": "static long int\nto_year (textint textyear)\n{\n  long int year = textyear.value;\n\n  if (year < 0)\n    year = -year;\n\n  /* XPG4 suggests that years 00-68 map to 2000-2068, and\n     years 69-99 map to 1969-1999.  */\n  else if (textyear.digits == 2)\n    year += year < 69 ? 2000 : 1900;\n\n  return year;\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "long int",
        "long",
        "int"
      ]
    },
    "lookup_zone": {
      "start_point": [
        912,
        0
      ],
      "end_point": [
        932,
        1
      ],
      "content": "static table const * _GL_ATTRIBUTE_PURE\nlookup_zone (parser_control const *pc, char const *name)\n{\n  table const *tp;\n\n  for (tp = universal_time_zone_table; tp->name; tp++)\n    if (strcmp (name, tp->name) == 0)\n      return tp;\n\n  /* Try local zone abbreviations before those in time_zone_table, as\n     the local ones are more likely to be right.  */\n  for (tp = pc->local_time_zone_table; tp->name; tp++)\n    if (strcmp (name, tp->name) == 0)\n      return tp;\n\n  for (tp = time_zone_table; tp->name; tp++)\n    if (strcmp (name, tp->name) == 0)\n      return tp;\n\n  return NULL;\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "table",
        "const",
        "const",
        "* _GL_ATTRIBUTE_PURE\nlookup_zone (parser_control const *pc, char const *name)",
        "*",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "tm_diff": {
      "start_point": [
        939,
        0
      ],
      "end_point": [
        958,
        1
      ],
      "content": "static long int\ntm_diff (struct tm const *a, struct tm const *b)\n{\n  /* Compute intervening leap days correctly even if year is negative.\n     Take care to avoid int overflow in leap day calculations.  */\n  int a4 = SHR (a->tm_year, 2) + SHR (TM_YEAR_BASE, 2) - ! (a->tm_year & 3);\n  int b4 = SHR (b->tm_year, 2) + SHR (TM_YEAR_BASE, 2) - ! (b->tm_year & 3);\n  int a100 = a4 / 25 - (a4 % 25 < 0);\n  int b100 = b4 / 25 - (b4 % 25 < 0);\n  int a400 = SHR (a100, 2);\n  int b400 = SHR (b100, 2);\n  int intervening_leap_days = (a4 - b4) - (a100 - b100) + (a400 - b400);\n  long int ayear = a->tm_year;\n  long int years = ayear - b->tm_year;\n  long int days = (365 * years + intervening_leap_days\n                   + (a->tm_yday - b->tm_yday));\n  return (60 * (60 * (24 * days + (a->tm_hour - b->tm_hour))\n                + (a->tm_min - b->tm_min))\n          + (a->tm_sec - b->tm_sec));\n}",
      "lines": 20,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "long int",
        "long",
        "int"
      ]
    },
    "lookup_word": {
      "start_point": [
        961,
        0
      ],
      "end_point": [
        1030,
        1
      ],
      "content": "static table const *\nlookup_word (parser_control const *pc, char *word)\n{\n  char *p;\n  char *q;\n  size_t wordlen;\n  table const *tp;\n  bool period_found;\n  bool abbrev;\n\n  /* Make it uppercase.  */\n  for (p = word; *p; p++)\n    {\n      unsigned char ch = *p;\n      *p = c_toupper (ch);\n    }\n\n  for (tp = meridian_table; tp->name; tp++)\n    if (strcmp (word, tp->name) == 0)\n      return tp;\n\n  /* See if we have an abbreviation for a month. */\n  wordlen = strlen (word);\n  abbrev = wordlen == 3 || (wordlen == 4 && word[3] == '.');\n\n  for (tp = month_and_day_table; tp->name; tp++)\n    if ((abbrev ? strncmp (word, tp->name, 3) : strcmp (word, tp->name)) == 0)\n      return tp;\n\n  if ((tp = lookup_zone (pc, word)))\n    return tp;\n\n  if (strcmp (word, dst_table[0].name) == 0)\n    return dst_table;\n\n  for (tp = time_units_table; tp->name; tp++)\n    if (strcmp (word, tp->name) == 0)\n      return tp;\n\n  /* Strip off any plural and try the units table again. */\n  if (word[wordlen - 1] == 'S')\n    {\n      word[wordlen - 1] = '\\0';\n      for (tp = time_units_table; tp->name; tp++)\n        if (strcmp (word, tp->name) == 0)\n          return tp;\n      word[wordlen - 1] = 'S';  /* For \"this\" in relative_time_table.  */\n    }\n\n  for (tp = relative_time_table; tp->name; tp++)\n    if (strcmp (word, tp->name) == 0)\n      return tp;\n\n  /* Military time zones. */\n  if (wordlen == 1)\n    for (tp = military_table; tp->name; tp++)\n      if (word[0] == tp->name[0])\n        return tp;\n\n  /* Drop out any periods and try the time zone table again. */\n  for (period_found = false, p = q = word; (*p = *q); q++)\n    if (*q == '.')\n      period_found = true;\n    else\n      p++;\n  if (period_found && (tp = lookup_zone (pc, word)))\n    return tp;\n\n  return NULL;\n}",
      "lines": 70,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "table",
        "const",
        "const",
        "*\nlookup_word (parser_control const *pc, char *word)",
        "*"
      ]
    },
    "yylex": {
      "start_point": [
        1032,
        0
      ],
      "end_point": [
        1193,
        1
      ],
      "content": "static int\nyylex (union YYSTYPE *lvalp, parser_control *pc)\n{\n  unsigned char c;\n  size_t count;\n\n  for (;;)\n    {\n      while (c = *pc->input, c_isspace (c))\n        pc->input++;\n\n      if (ISDIGIT (c) || c == '-' || c == '+')\n        {\n          char const *p;\n          int sign;\n          unsigned long int value;\n          if (c == '-' || c == '+')\n            {\n              sign = c == '-' ? -1 : 1;\n              while (c = *++pc->input, c_isspace (c))\n                continue;\n              if (! ISDIGIT (c))\n                /* skip the '-' sign */\n                continue;\n            }\n          else\n            sign = 0;\n          p = pc->input;\n          for (value = 0; ; value *= 10)\n            {\n              unsigned long int value1 = value + (c - '0');\n              if (value1 < value)\n                return '?';\n              value = value1;\n              c = *++p;\n              if (! ISDIGIT (c))\n                break;\n              if (ULONG_MAX / 10 < value)\n                return '?';\n            }\n          if ((c == '.' || c == ',') && ISDIGIT (p[1]))\n            {\n              time_t s;\n              int ns;\n              int digits;\n              unsigned long int value1;\n\n              /* Check for overflow when converting value to time_t.  */\n              if (sign < 0)\n                {\n                  s = - value;\n                  if (0 < s)\n                    return '?';\n                  value1 = -s;\n                }\n              else\n                {\n                  s = value;\n                  if (s < 0)\n                    return '?';\n                  value1 = s;\n                }\n              if (value != value1)\n                return '?';\n\n              /* Accumulate fraction, to ns precision.  */\n              p++;\n              ns = *p++ - '0';\n              for (digits = 2; digits <= LOG10_BILLION; digits++)\n                {\n                  ns *= 10;\n                  if (ISDIGIT (*p))\n                    ns += *p++ - '0';\n                }\n\n              /* Skip excess digits, truncating toward -Infinity.  */\n              if (sign < 0)\n                for (; ISDIGIT (*p); p++)\n                  if (*p != '0')\n                    {\n                      ns++;\n                      break;\n                    }\n              while (ISDIGIT (*p))\n                p++;\n\n              /* Adjust to the timespec convention, which is that\n                 tv_nsec is always a positive offset even if tv_sec is\n                 negative.  */\n              if (sign < 0 && ns)\n                {\n                  s--;\n                  if (! (s < 0))\n                    return '?';\n                  ns = BILLION - ns;\n                }\n\n              lvalp->timespec.tv_sec = s;\n              lvalp->timespec.tv_nsec = ns;\n              pc->input = p;\n              return sign ? tSDECIMAL_NUMBER : tUDECIMAL_NUMBER;\n            }\n          else\n            {\n              lvalp->textintval.negative = sign < 0;\n              if (sign < 0)\n                {\n                  lvalp->textintval.value = - value;\n                  if (0 < lvalp->textintval.value)\n                    return '?';\n                }\n              else\n                {\n                  lvalp->textintval.value = value;\n                  if (lvalp->textintval.value < 0)\n                    return '?';\n                }\n              lvalp->textintval.digits = p - pc->input;\n              pc->input = p;\n              return sign ? tSNUMBER : tUNUMBER;\n            }\n        }\n\n      if (c_isalpha (c))\n        {\n          char buff[20];\n          char *p = buff;\n          table const *tp;\n\n          do\n            {\n              if (p < buff + sizeof buff - 1)\n                *p++ = c;\n              c = *++pc->input;\n            }\n          while (c_isalpha (c) || c == '.');\n\n          *p = '\\0';\n          tp = lookup_word (pc, buff);\n          if (! tp)\n            return '?';\n          lvalp->intval = tp->value;\n          return tp->type;\n        }\n\n      if (c != '(')\n        return to_uchar (*pc->input++);\n\n      count = 0;\n      do\n        {\n          c = *pc->input++;\n          if (c == '\\0')\n            return c;\n          if (c == '(')\n            count++;\n          else if (c == ')')\n            count--;\n        }\n      while (count != 0);\n    }\n}",
      "lines": 162,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "yyerror": {
      "start_point": [
        1196,
        0
      ],
      "end_point": [
        1201,
        1
      ],
      "content": "static int\nyyerror (parser_control const *pc _GL_UNUSED,\n         char const *s _GL_UNUSED)\n{\n  return 0;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "mktime_ok": {
      "start_point": [
        1207,
        0
      ],
      "end_point": [
        1226,
        1
      ],
      "content": "static bool\nmktime_ok (struct tm const *tm0, struct tm const *tm1, time_t t)\n{\n  if (t == (time_t) -1)\n    {\n      /* Guard against falsely reporting an error when parsing a time\n         stamp that happens to equal (time_t) -1, on a host that\n         supports such a time stamp.  */\n      tm1 = localtime (&t);\n      if (!tm1)\n        return false;\n    }\n\n  return ! ((tm0->tm_sec ^ tm1->tm_sec)\n            | (tm0->tm_min ^ tm1->tm_min)\n            | (tm0->tm_hour ^ tm1->tm_hour)\n            | (tm0->tm_mday ^ tm1->tm_mday)\n            | (tm0->tm_mon ^ tm1->tm_mon)\n            | (tm0->tm_year ^ tm1->tm_year));\n}",
      "lines": 20,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "get_tz": {
      "start_point": [
        1234,
        0
      ],
      "end_point": [
        1246,
        1
      ],
      "content": "static char *\nget_tz (char tzbuf[TZBUFSIZE])\n{\n  char *tz = getenv (\"TZ\");\n  if (tz)\n    {\n      size_t tzsize = strlen (tz) + 1;\n      tz = (tzsize <= TZBUFSIZE\n            ? memcpy (tzbuf, tz, tzsize)\n            : xmemdup (tz, tzsize));\n    }\n  return tz;\n}",
      "lines": 13,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nget_tz (char tzbuf[TZBUFSIZE])",
        "*"
      ]
    },
    "parse_datetime": {
      "start_point": [
        1252,
        0
      ],
      "end_point": [
        1589,
        1
      ],
      "content": "bool\nparse_datetime (struct timespec *result, char const *p,\n                struct timespec const *now)\n{\n  time_t Start;\n  long int Start_ns;\n  struct tm const *tmp;\n  struct tm tm;\n  struct tm tm0;\n  parser_control pc;\n  struct timespec gettime_buffer;\n  unsigned char c;\n  bool tz_was_altered = false;\n  char *tz0 = NULL;\n  char tz0buf[TZBUFSIZE];\n  bool ok = true;\n\n  if (! now)\n    {\n      gettime (&gettime_buffer);\n      now = &gettime_buffer;\n    }\n\n  Start = now->tv_sec;\n  Start_ns = now->tv_nsec;\n\n  tmp = localtime (&now->tv_sec);\n  if (! tmp)\n    return false;\n\n  while (c = *p, c_isspace (c))\n    p++;\n\n  if (strncmp (p, \"TZ=\\\"\", 4) == 0)\n    {\n      char const *tzbase = p + 4;\n      size_t tzsize = 1;\n      char const *s;\n\n      for (s = tzbase; *s; s++, tzsize++)\n        if (*s == '\\\\')\n          {\n            s++;\n            if (! (*s == '\\\\' || *s == '\"'))\n              break;\n          }\n        else if (*s == '\"')\n          {\n            char *z;\n            char *tz1;\n            char tz1buf[TZBUFSIZE];\n            bool large_tz = TZBUFSIZE < tzsize;\n            bool setenv_ok;\n            tz0 = get_tz (tz0buf);\n            z = tz1 = large_tz ? xmalloc (tzsize) : tz1buf;\n            for (s = tzbase; *s != '\"'; s++)\n              *z++ = *(s += *s == '\\\\');\n            *z = '\\0';\n            setenv_ok = setenv (\"TZ\", tz1, 1) == 0;\n            if (large_tz)\n              free (tz1);\n            if (!setenv_ok)\n              goto fail;\n            tz_was_altered = true;\n\n            p = s + 1;\n            while (c = *p, c_isspace (c))\n              p++;\n\n            break;\n          }\n    }\n\n  /* As documented, be careful to treat the empty string just like\n     a date string of \"0\".  Without this, an empty string would be\n     declared invalid when parsed during a DST transition.  */\n  if (*p == '\\0')\n    p = \"0\";\n\n  pc.input = p;\n  pc.year.value = tmp->tm_year;\n  pc.year.value += TM_YEAR_BASE;\n  pc.year.digits = 0;\n  pc.month = tmp->tm_mon + 1;\n  pc.day = tmp->tm_mday;\n  pc.hour = tmp->tm_hour;\n  pc.minutes = tmp->tm_min;\n  pc.seconds.tv_sec = tmp->tm_sec;\n  pc.seconds.tv_nsec = Start_ns;\n  tm.tm_isdst = tmp->tm_isdst;\n\n  pc.meridian = MER24;\n  pc.rel = RELATIVE_TIME_0;\n  pc.timespec_seen = false;\n  pc.rels_seen = false;\n  pc.dates_seen = 0;\n  pc.days_seen = 0;\n  pc.times_seen = 0;\n  pc.local_zones_seen = 0;\n  pc.dsts_seen = 0;\n  pc.zones_seen = 0;\n\n#if HAVE_STRUCT_TM_TM_ZONE\n  pc.local_time_zone_table[0].name = tmp->tm_zone;\n  pc.local_time_zone_table[0].type = tLOCAL_ZONE;\n  pc.local_time_zone_table[0].value = tmp->tm_isdst;\n  pc.local_time_zone_table[1].name = NULL;\n\n  /* Probe the names used in the next three calendar quarters, looking\n     for a tm_isdst different from the one we already have.  */\n  {\n    int quarter;\n    for (quarter = 1; quarter <= 3; quarter++)\n      {\n        time_t probe = Start + quarter * (90 * 24 * 60 * 60);\n        struct tm const *probe_tm = localtime (&probe);\n        if (probe_tm && probe_tm->tm_zone\n            && probe_tm->tm_isdst != pc.local_time_zone_table[0].value)\n          {\n              {\n                pc.local_time_zone_table[1].name = probe_tm->tm_zone;\n                pc.local_time_zone_table[1].type = tLOCAL_ZONE;\n                pc.local_time_zone_table[1].value = probe_tm->tm_isdst;\n                pc.local_time_zone_table[2].name = NULL;\n              }\n            break;\n          }\n      }\n  }\n#else\n#if HAVE_TZNAME\n  {\n# if !HAVE_DECL_TZNAME\n    extern char *tzname[];\n# endif\n    int i;\n    for (i = 0; i < 2; i++)\n      {\n        pc.local_time_zone_table[i].name = tzname[i];\n        pc.local_time_zone_table[i].type = tLOCAL_ZONE;\n        pc.local_time_zone_table[i].value = i;\n      }\n    pc.local_time_zone_table[i].name = NULL;\n  }\n#else\n  pc.local_time_zone_table[0].name = NULL;\n#endif\n#endif\n\n  if (pc.local_time_zone_table[0].name && pc.local_time_zone_table[1].name\n      && ! strcmp (pc.local_time_zone_table[0].name,\n                   pc.local_time_zone_table[1].name))\n    {\n      /* This locale uses the same abbreviation for standard and\n         daylight times.  So if we see that abbreviation, we don't\n         know whether it's daylight time.  */\n      pc.local_time_zone_table[0].value = -1;\n      pc.local_time_zone_table[1].name = NULL;\n    }\n\n  if (yyparse (&pc) != 0)\n    goto fail;\n\n  if (pc.timespec_seen)\n    *result = pc.seconds;\n  else\n    {\n      if (1 < (pc.times_seen | pc.dates_seen | pc.days_seen | pc.dsts_seen\n               | (pc.local_zones_seen + pc.zones_seen)))\n        goto fail;\n\n      tm.tm_year = to_year (pc.year) - TM_YEAR_BASE;\n      tm.tm_mon = pc.month - 1;\n      tm.tm_mday = pc.day;\n      if (pc.times_seen || (pc.rels_seen && ! pc.dates_seen && ! pc.days_seen))\n        {\n          tm.tm_hour = to_hour (pc.hour, pc.meridian);\n          if (tm.tm_hour < 0)\n            goto fail;\n          tm.tm_min = pc.minutes;\n          tm.tm_sec = pc.seconds.tv_sec;\n        }\n      else\n        {\n          tm.tm_hour = tm.tm_min = tm.tm_sec = 0;\n          pc.seconds.tv_nsec = 0;\n        }\n\n      /* Let mktime deduce tm_isdst if we have an absolute time stamp.  */\n      if (pc.dates_seen | pc.days_seen | pc.times_seen)\n        tm.tm_isdst = -1;\n\n      /* But if the input explicitly specifies local time with or without\n         DST, give mktime that information.  */\n      if (pc.local_zones_seen)\n        tm.tm_isdst = pc.local_isdst;\n\n      tm0 = tm;\n\n      Start = mktime (&tm);\n\n      if (! mktime_ok (&tm0, &tm, Start))\n        {\n          if (! pc.zones_seen)\n            goto fail;\n          else\n            {\n              /* Guard against falsely reporting errors near the time_t\n                 boundaries when parsing times in other time zones.  For\n                 example, suppose the input string \"1969-12-31 23:00:00 -0100\",\n                 the current time zone is 8 hours ahead of UTC, and the min\n                 time_t value is 1970-01-01 00:00:00 UTC.  Then the min\n                 localtime value is 1970-01-01 08:00:00, and mktime will\n                 therefore fail on 1969-12-31 23:00:00.  To work around the\n                 problem, set the time zone to 1 hour behind UTC temporarily\n                 by setting TZ=\"XXX1:00\" and try mktime again.  */\n\n              long int time_zone = pc.time_zone;\n              long int abs_time_zone = time_zone < 0 ? - time_zone : time_zone;\n              long int abs_time_zone_hour = abs_time_zone / 60;\n              int abs_time_zone_min = abs_time_zone % 60;\n              char tz1buf[sizeof \"XXX+0:00\"\n                          + sizeof pc.time_zone * CHAR_BIT / 3];\n              if (!tz_was_altered)\n                tz0 = get_tz (tz0buf);\n              sprintf (tz1buf, \"XXX%s%ld:%02d\", &\"-\"[time_zone < 0],\n                       abs_time_zone_hour, abs_time_zone_min);\n              if (setenv (\"TZ\", tz1buf, 1) != 0)\n                goto fail;\n              tz_was_altered = true;\n              tm = tm0;\n              Start = mktime (&tm);\n              if (! mktime_ok (&tm0, &tm, Start))\n                goto fail;\n            }\n        }\n\n      if (pc.days_seen && ! pc.dates_seen)\n        {\n          tm.tm_mday += ((pc.day_number - tm.tm_wday + 7) % 7\n                         + 7 * (pc.day_ordinal\n                                - (0 < pc.day_ordinal\n                                   && tm.tm_wday != pc.day_number)));\n          tm.tm_isdst = -1;\n          Start = mktime (&tm);\n          if (Start == (time_t) -1)\n            goto fail;\n        }\n\n      /* Add relative date.  */\n      if (pc.rel.year | pc.rel.month | pc.rel.day)\n        {\n          int year = tm.tm_year + pc.rel.year;\n          int month = tm.tm_mon + pc.rel.month;\n          int day = tm.tm_mday + pc.rel.day;\n          if (((year < tm.tm_year) ^ (pc.rel.year < 0))\n              | ((month < tm.tm_mon) ^ (pc.rel.month < 0))\n              | ((day < tm.tm_mday) ^ (pc.rel.day < 0)))\n            goto fail;\n          tm.tm_year = year;\n          tm.tm_mon = month;\n          tm.tm_mday = day;\n          tm.tm_hour = tm0.tm_hour;\n          tm.tm_min = tm0.tm_min;\n          tm.tm_sec = tm0.tm_sec;\n          tm.tm_isdst = tm0.tm_isdst;\n          Start = mktime (&tm);\n          if (Start == (time_t) -1)\n            goto fail;\n        }\n\n      /* The only \"output\" of this if-block is an updated Start value,\n         so this block must follow others that clobber Start.  */\n      if (pc.zones_seen)\n        {\n          long int delta = pc.time_zone * 60;\n          time_t t1;\n#ifdef HAVE_TM_GMTOFF\n          delta -= tm.tm_gmtoff;\n#else\n          time_t t = Start;\n          struct tm const *gmt = gmtime (&t);\n          if (! gmt)\n            goto fail;\n          delta -= tm_diff (&tm, gmt);\n#endif\n          t1 = Start - delta;\n          if ((Start < t1) != (delta < 0))\n            goto fail;  /* time_t overflow */\n          Start = t1;\n        }\n\n      /* Add relative hours, minutes, and seconds.  On hosts that support\n         leap seconds, ignore the possibility of leap seconds; e.g.,\n         \"+ 10 minutes\" adds 600 seconds, even if one of them is a\n         leap second.  Typically this is not what the user wants, but it's\n         too hard to do it the other way, because the time zone indicator\n         must be applied before relative times, and if mktime is applied\n         again the time zone will be lost.  */\n      {\n        long int sum_ns = pc.seconds.tv_nsec + pc.rel.ns;\n        long int normalized_ns = (sum_ns % BILLION + BILLION) % BILLION;\n        time_t t0 = Start;\n        long int d1 = 60 * 60 * pc.rel.hour;\n        time_t t1 = t0 + d1;\n        long int d2 = 60 * pc.rel.minutes;\n        time_t t2 = t1 + d2;\n        long_time_t d3 = pc.rel.seconds;\n        long_time_t t3 = t2 + d3;\n        long int d4 = (sum_ns - normalized_ns) / BILLION;\n        long_time_t t4 = t3 + d4;\n        time_t t5 = t4;\n\n        if ((d1 / (60 * 60) ^ pc.rel.hour)\n            | (d2 / 60 ^ pc.rel.minutes)\n            | ((t1 < t0) ^ (d1 < 0))\n            | ((t2 < t1) ^ (d2 < 0))\n            | ((t3 < t2) ^ (d3 < 0))\n            | ((t4 < t3) ^ (d4 < 0))\n            | (t5 != t4))\n          goto fail;\n\n        result->tv_sec = t5;\n        result->tv_nsec = normalized_ns;\n      }\n    }\n\n  goto done;\n\n fail:\n  ok = false;\n done:\n  if (tz_was_altered)\n    ok &= (tz0 ? setenv (\"TZ\", tz0, 1) : unsetenv (\"TZ\")) == 0;\n  if (tz0 != tz0buf)\n    free (tz0);\n  return ok;\n}",
      "lines": 338,
      "depth": 19,
      "decorators": [
        "bool"
      ]
    },
    "main": {
      "start_point": [
        1593,
        0
      ],
      "end_point": [
        1624,
        1
      ],
      "content": "int\nmain (int ac, char **av)\n{\n  char buff[BUFSIZ];\n\n  printf (\"Enter date, or blank line to exit.\\n\\t> \");\n  fflush (stdout);\n\n  buff[BUFSIZ - 1] = '\\0';\n  while (fgets (buff, BUFSIZ - 1, stdin) && buff[0])\n    {\n      struct timespec d;\n      struct tm const *tm;\n      if (! parse_datetime (&d, buff, NULL))\n        printf (\"Bad format - couldn't convert.\\n\");\n      else if (! (tm = localtime (&d.tv_sec)))\n        {\n          long int sec = d.tv_sec;\n          printf (\"localtime (%ld) failed\\n\", sec);\n        }\n      else\n        {\n          int ns = d.tv_nsec;\n          printf (\"%04ld-%02d-%02d %02d:%02d:%02d.%09d\\n\",\n                  tm->tm_year + 1900L, tm->tm_mon + 1, tm->tm_mday,\n                  tm->tm_hour, tm->tm_min, tm->tm_sec, ns);\n        }\n      printf (\"\\t> \");\n      fflush (stdout);\n    }\n  return 0;\n}",
      "lines": 32,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/pathmax.h": {},
  "findutils/findutils-4.6.0/gl/lib/perror.c": {
    "perror": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "void\nperror (const char *string)\n{\n  char stackbuf[STACKBUF_LEN];\n  int ret;\n\n  /* Our implementation guarantees that this will be a non-empty\n     string, even if it returns EINVAL; and stackbuf should be sized\n     large enough to avoid ERANGE.  */\n  ret = strerror_r (errno, stackbuf, sizeof stackbuf);\n  if (ret == ERANGE)\n    abort ();\n\n  if (string != NULL && *string != '\\0')\n    fprintf (stderr, \"%s: %s\\n\", string, stackbuf);\n  else\n    fprintf (stderr, \"%s\\n\", stackbuf);\n}",
      "lines": 18,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/pipe-safer.c": {
    "pipe_safer": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "int\npipe_safer (int fd[2])\n{\n#if HAVE_PIPE\n  if (pipe (fd) == 0)\n    {\n      int i;\n      for (i = 0; i < 2; i++)\n        {\n          fd[i] = fd_safer (fd[i]);\n          if (fd[i] < 0)\n            {\n              int e = errno;\n              close (fd[1 - i]);\n              errno = e;\n              return -1;\n            }\n        }\n\n      return 0;\n    }\n#else\n  errno = ENOSYS;\n#endif\n\n  return -1;\n}",
      "lines": 27,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/printf-args.c": {
    "PRINTF_FETCHARGS": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        186,
        1
      ],
      "content": "int\nPRINTF_FETCHARGS (va_list args, arguments *a)\n{\n  size_t i;\n  argument *ap;\n\n  for (i = 0, ap = &a->arg[0]; i < a->count; i++, ap++)\n    switch (ap->type)\n      {\n      case TYPE_SCHAR:\n        ap->a.a_schar = va_arg (args, /*signed char*/ int);\n        break;\n      case TYPE_UCHAR:\n        ap->a.a_uchar = va_arg (args, /*unsigned char*/ int);\n        break;\n      case TYPE_SHORT:\n        ap->a.a_short = va_arg (args, /*short*/ int);\n        break;\n      case TYPE_USHORT:\n        ap->a.a_ushort = va_arg (args, /*unsigned short*/ int);\n        break;\n      case TYPE_INT:\n        ap->a.a_int = va_arg (args, int);\n        break;\n      case TYPE_UINT:\n        ap->a.a_uint = va_arg (args, unsigned int);\n        break;\n      case TYPE_LONGINT:\n        ap->a.a_longint = va_arg (args, long int);\n        break;\n      case TYPE_ULONGINT:\n        ap->a.a_ulongint = va_arg (args, unsigned long int);\n        break;\n#if HAVE_LONG_LONG_INT\n      case TYPE_LONGLONGINT:\n        ap->a.a_longlongint = va_arg (args, long long int);\n        break;\n      case TYPE_ULONGLONGINT:\n        ap->a.a_ulonglongint = va_arg (args, unsigned long long int);\n        break;\n#endif\n      case TYPE_DOUBLE:\n        ap->a.a_double = va_arg (args, double);\n        break;\n      case TYPE_LONGDOUBLE:\n        ap->a.a_longdouble = va_arg (args, long double);\n        break;\n      case TYPE_CHAR:\n        ap->a.a_char = va_arg (args, int);\n        break;\n#if HAVE_WINT_T\n      case TYPE_WIDE_CHAR:\n        /* Although ISO C 99 7.24.1.(2) says that wint_t is \"unchanged by\n           default argument promotions\", this is not the case in mingw32,\n           where wint_t is 'unsigned short'.  */\n        ap->a.a_wide_char =\n          (sizeof (wint_t) < sizeof (int)\n           ? (wint_t) va_arg (args, int)\n           : va_arg (args, wint_t));\n        break;\n#endif\n      case TYPE_STRING:\n        ap->a.a_string = va_arg (args, const char *);\n        /* A null pointer is an invalid argument for \"%s\", but in practice\n           it occurs quite frequently in printf statements that produce\n           debug output.  Use a fallback in this case.  */\n        if (ap->a.a_string == NULL)\n          ap->a.a_string = \"(NULL)\";\n        break;\n#if HAVE_WCHAR_T\n      case TYPE_WIDE_STRING:\n        ap->a.a_wide_string = va_arg (args, const wchar_t *);\n        /* A null pointer is an invalid argument for \"%ls\", but in practice\n           it occurs quite frequently in printf statements that produce\n           debug output.  Use a fallback in this case.  */\n        if (ap->a.a_wide_string == NULL)\n          {\n            static const wchar_t wide_null_string[] =\n              {\n                (wchar_t)'(',\n                (wchar_t)'N', (wchar_t)'U', (wchar_t)'L', (wchar_t)'L',\n                (wchar_t)')',\n                (wchar_t)0\n              };\n            ap->a.a_wide_string = wide_null_string;\n          }\n        break;\n#endif\n      case TYPE_POINTER:\n        ap->a.a_pointer = va_arg (args, void *);\n        break;\n      case TYPE_COUNT_SCHAR_POINTER:\n        ap->a.a_count_schar_pointer = va_arg (args, signed char *);\n        break;\n      case TYPE_COUNT_SHORT_POINTER:\n        ap->a.a_count_short_pointer = va_arg (args, short *);\n        break;\n      case TYPE_COUNT_INT_POINTER:\n        ap->a.a_count_int_pointer = va_arg (args, int *);\n        break;\n      case TYPE_COUNT_LONGINT_POINTER:\n        ap->a.a_count_longint_pointer = va_arg (args, long int *);\n        break;\n#if HAVE_LONG_LONG_INT\n      case TYPE_COUNT_LONGLONGINT_POINTER:\n        ap->a.a_count_longlongint_pointer = va_arg (args, long long int *);\n        break;\n#endif\n#if ENABLE_UNISTDIO\n      /* The unistdio extensions.  */\n      case TYPE_U8_STRING:\n        ap->a.a_u8_string = va_arg (args, const uint8_t *);\n        /* A null pointer is an invalid argument for \"%U\", but in practice\n           it occurs quite frequently in printf statements that produce\n           debug output.  Use a fallback in this case.  */\n        if (ap->a.a_u8_string == NULL)\n          {\n            static const uint8_t u8_null_string[] =\n              { '(', 'N', 'U', 'L', 'L', ')', 0 };\n            ap->a.a_u8_string = u8_null_string;\n          }\n        break;\n      case TYPE_U16_STRING:\n        ap->a.a_u16_string = va_arg (args, const uint16_t *);\n        /* A null pointer is an invalid argument for \"%lU\", but in practice\n           it occurs quite frequently in printf statements that produce\n           debug output.  Use a fallback in this case.  */\n        if (ap->a.a_u16_string == NULL)\n          {\n            static const uint16_t u16_null_string[] =\n              { '(', 'N', 'U', 'L', 'L', ')', 0 };\n            ap->a.a_u16_string = u16_null_string;\n          }\n        break;\n      case TYPE_U32_STRING:\n        ap->a.a_u32_string = va_arg (args, const uint32_t *);\n        /* A null pointer is an invalid argument for \"%llU\", but in practice\n           it occurs quite frequently in printf statements that produce\n           debug output.  Use a fallback in this case.  */\n        if (ap->a.a_u32_string == NULL)\n          {\n            static const uint32_t u32_null_string[] =\n              { '(', 'N', 'U', 'L', 'L', ')', 0 };\n            ap->a.a_u32_string = u32_null_string;\n          }\n        break;\n#endif\n      default:\n        /* Unknown type.  */\n        return -1;\n      }\n  return 0;\n}",
      "lines": 153,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/printf-args.h": {},
  "findutils/findutils-4.6.0/gl/lib/printf-parse.c": {
    "PRINTF_PARSE": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        631,
        1
      ],
      "content": "int\nPRINTF_PARSE (const CHAR_T *format, DIRECTIVES *d, arguments *a)\n{\n  const CHAR_T *cp = format;    /* pointer into format */\n  size_t arg_posn = 0;          /* number of regular arguments consumed */\n  size_t d_allocated;           /* allocated elements of d->dir */\n  size_t a_allocated;           /* allocated elements of a->arg */\n  size_t max_width_length = 0;\n  size_t max_precision_length = 0;\n\n  d->count = 0;\n  d_allocated = N_DIRECT_ALLOC_DIRECTIVES;\n  d->dir = d->direct_alloc_dir;\n\n  a->count = 0;\n  a_allocated = N_DIRECT_ALLOC_ARGUMENTS;\n  a->arg = a->direct_alloc_arg;\n\n#define REGISTER_ARG(_index_,_type_) \\\n  {                                                                     \\\n    size_t n = (_index_);                                               \\\n    if (n >= a_allocated)                                               \\\n      {                                                                 \\\n        size_t memory_size;                                             \\\n        argument *memory;                                               \\\n                                                                        \\\n        a_allocated = xtimes (a_allocated, 2);                          \\\n        if (a_allocated <= n)                                           \\\n          a_allocated = xsum (n, 1);                                    \\\n        memory_size = xtimes (a_allocated, sizeof (argument));          \\\n        if (size_overflow_p (memory_size))                              \\\n          /* Overflow, would lead to out of memory.  */                 \\\n          goto out_of_memory;                                           \\\n        memory = (argument *) (a->arg != a->direct_alloc_arg            \\\n                               ? realloc (a->arg, memory_size)          \\\n                               : malloc (memory_size));                 \\\n        if (memory == NULL)                                             \\\n          /* Out of memory.  */                                         \\\n          goto out_of_memory;                                           \\\n        if (a->arg == a->direct_alloc_arg)                              \\\n          memcpy (memory, a->arg, a->count * sizeof (argument));        \\\n        a->arg = memory;                                                \\\n      }                                                                 \\\n    while (a->count <= n)                                               \\\n      a->arg[a->count++].type = TYPE_NONE;                              \\\n    if (a->arg[n].type == TYPE_NONE)                                    \\\n      a->arg[n].type = (_type_);                                        \\\n    else if (a->arg[n].type != (_type_))                                \\\n      /* Ambiguous type for positional argument.  */                    \\\n      goto error;                                                       \\\n  }\n\n  while (*cp != '\\0')\n    {\n      CHAR_T c = *cp++;\n      if (c == '%')\n        {\n          size_t arg_index = ARG_NONE;\n          DIRECTIVE *dp = &d->dir[d->count]; /* pointer to next directive */\n\n          /* Initialize the next directive.  */\n          dp->dir_start = cp - 1;\n          dp->flags = 0;\n          dp->width_start = NULL;\n          dp->width_end = NULL;\n          dp->width_arg_index = ARG_NONE;\n          dp->precision_start = NULL;\n          dp->precision_end = NULL;\n          dp->precision_arg_index = ARG_NONE;\n          dp->arg_index = ARG_NONE;\n\n          /* Test for positional argument.  */\n          if (*cp >= '0' && *cp <= '9')\n            {\n              const CHAR_T *np;\n\n              for (np = cp; *np >= '0' && *np <= '9'; np++)\n                ;\n              if (*np == '$')\n                {\n                  size_t n = 0;\n\n                  for (np = cp; *np >= '0' && *np <= '9'; np++)\n                    n = xsum (xtimes (n, 10), *np - '0');\n                  if (n == 0)\n                    /* Positional argument 0.  */\n                    goto error;\n                  if (size_overflow_p (n))\n                    /* n too large, would lead to out of memory later.  */\n                    goto error;\n                  arg_index = n - 1;\n                  cp = np + 1;\n                }\n            }\n\n          /* Read the flags.  */\n          for (;;)\n            {\n              if (*cp == '\\'')\n                {\n                  dp->flags |= FLAG_GROUP;\n                  cp++;\n                }\n              else if (*cp == '-')\n                {\n                  dp->flags |= FLAG_LEFT;\n                  cp++;\n                }\n              else if (*cp == '+')\n                {\n                  dp->flags |= FLAG_SHOWSIGN;\n                  cp++;\n                }\n              else if (*cp == ' ')\n                {\n                  dp->flags |= FLAG_SPACE;\n                  cp++;\n                }\n              else if (*cp == '#')\n                {\n                  dp->flags |= FLAG_ALT;\n                  cp++;\n                }\n              else if (*cp == '0')\n                {\n                  dp->flags |= FLAG_ZERO;\n                  cp++;\n                }\n#if __GLIBC__ >= 2 && !defined __UCLIBC__\n              else if (*cp == 'I')\n                {\n                  dp->flags |= FLAG_LOCALIZED;\n                  cp++;\n                }\n#endif\n              else\n                break;\n            }\n\n          /* Parse the field width.  */\n          if (*cp == '*')\n            {\n              dp->width_start = cp;\n              cp++;\n              dp->width_end = cp;\n              if (max_width_length < 1)\n                max_width_length = 1;\n\n              /* Test for positional argument.  */\n              if (*cp >= '0' && *cp <= '9')\n                {\n                  const CHAR_T *np;\n\n                  for (np = cp; *np >= '0' && *np <= '9'; np++)\n                    ;\n                  if (*np == '$')\n                    {\n                      size_t n = 0;\n\n                      for (np = cp; *np >= '0' && *np <= '9'; np++)\n                        n = xsum (xtimes (n, 10), *np - '0');\n                      if (n == 0)\n                        /* Positional argument 0.  */\n                        goto error;\n                      if (size_overflow_p (n))\n                        /* n too large, would lead to out of memory later.  */\n                        goto error;\n                      dp->width_arg_index = n - 1;\n                      cp = np + 1;\n                    }\n                }\n              if (dp->width_arg_index == ARG_NONE)\n                {\n                  dp->width_arg_index = arg_posn++;\n                  if (dp->width_arg_index == ARG_NONE)\n                    /* arg_posn wrapped around.  */\n                    goto error;\n                }\n              REGISTER_ARG (dp->width_arg_index, TYPE_INT);\n            }\n          else if (*cp >= '0' && *cp <= '9')\n            {\n              size_t width_length;\n\n              dp->width_start = cp;\n              for (; *cp >= '0' && *cp <= '9'; cp++)\n                ;\n              dp->width_end = cp;\n              width_length = dp->width_end - dp->width_start;\n              if (max_width_length < width_length)\n                max_width_length = width_length;\n            }\n\n          /* Parse the precision.  */\n          if (*cp == '.')\n            {\n              cp++;\n              if (*cp == '*')\n                {\n                  dp->precision_start = cp - 1;\n                  cp++;\n                  dp->precision_end = cp;\n                  if (max_precision_length < 2)\n                    max_precision_length = 2;\n\n                  /* Test for positional argument.  */\n                  if (*cp >= '0' && *cp <= '9')\n                    {\n                      const CHAR_T *np;\n\n                      for (np = cp; *np >= '0' && *np <= '9'; np++)\n                        ;\n                      if (*np == '$')\n                        {\n                          size_t n = 0;\n\n                          for (np = cp; *np >= '0' && *np <= '9'; np++)\n                            n = xsum (xtimes (n, 10), *np - '0');\n                          if (n == 0)\n                            /* Positional argument 0.  */\n                            goto error;\n                          if (size_overflow_p (n))\n                            /* n too large, would lead to out of memory\n                               later.  */\n                            goto error;\n                          dp->precision_arg_index = n - 1;\n                          cp = np + 1;\n                        }\n                    }\n                  if (dp->precision_arg_index == ARG_NONE)\n                    {\n                      dp->precision_arg_index = arg_posn++;\n                      if (dp->precision_arg_index == ARG_NONE)\n                        /* arg_posn wrapped around.  */\n                        goto error;\n                    }\n                  REGISTER_ARG (dp->precision_arg_index, TYPE_INT);\n                }\n              else\n                {\n                  size_t precision_length;\n\n                  dp->precision_start = cp - 1;\n                  for (; *cp >= '0' && *cp <= '9'; cp++)\n                    ;\n                  dp->precision_end = cp;\n                  precision_length = dp->precision_end - dp->precision_start;\n                  if (max_precision_length < precision_length)\n                    max_precision_length = precision_length;\n                }\n            }\n\n          {\n            arg_type type;\n\n            /* Parse argument type/size specifiers.  */\n            {\n              int flags = 0;\n\n              for (;;)\n                {\n                  if (*cp == 'h')\n                    {\n                      flags |= (1 << (flags & 1));\n                      cp++;\n                    }\n                  else if (*cp == 'L')\n                    {\n                      flags |= 4;\n                      cp++;\n                    }\n                  else if (*cp == 'l')\n                    {\n                      flags += 8;\n                      cp++;\n                    }\n                  else if (*cp == 'j')\n                    {\n                      if (sizeof (intmax_t) > sizeof (long))\n                        {\n                          /* intmax_t = long long */\n                          flags += 16;\n                        }\n                      else if (sizeof (intmax_t) > sizeof (int))\n                        {\n                          /* intmax_t = long */\n                          flags += 8;\n                        }\n                      cp++;\n                    }\n                  else if (*cp == 'z' || *cp == 'Z')\n                    {\n                      /* 'z' is standardized in ISO C 99, but glibc uses 'Z'\n                         because the warning facility in gcc-2.95.2 understands\n                         only 'Z' (see gcc-2.95.2/gcc/c-common.c:1784).  */\n                      if (sizeof (size_t) > sizeof (long))\n                        {\n                          /* size_t = long long */\n                          flags += 16;\n                        }\n                      else if (sizeof (size_t) > sizeof (int))\n                        {\n                          /* size_t = long */\n                          flags += 8;\n                        }\n                      cp++;\n                    }\n                  else if (*cp == 't')\n                    {\n                      if (sizeof (ptrdiff_t) > sizeof (long))\n                        {\n                          /* ptrdiff_t = long long */\n                          flags += 16;\n                        }\n                      else if (sizeof (ptrdiff_t) > sizeof (int))\n                        {\n                          /* ptrdiff_t = long */\n                          flags += 8;\n                        }\n                      cp++;\n                    }\n#if defined __APPLE__ && defined __MACH__\n                  /* On Mac OS X 10.3, PRIdMAX is defined as \"qd\".\n                     We cannot change it to \"lld\" because PRIdMAX must also\n                     be understood by the system's printf routines.  */\n                  else if (*cp == 'q')\n                    {\n                      if (64 / 8 > sizeof (long))\n                        {\n                          /* int64_t = long long */\n                          flags += 16;\n                        }\n                      else\n                        {\n                          /* int64_t = long */\n                          flags += 8;\n                        }\n                      cp++;\n                    }\n#endif\n#if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n                  /* On native Windows, PRIdMAX is defined as \"I64d\".\n                     We cannot change it to \"lld\" because PRIdMAX must also\n                     be understood by the system's printf routines.  */\n                  else if (*cp == 'I' && cp[1] == '6' && cp[2] == '4')\n                    {\n                      if (64 / 8 > sizeof (long))\n                        {\n                          /* __int64 = long long */\n                          flags += 16;\n                        }\n                      else\n                        {\n                          /* __int64 = long */\n                          flags += 8;\n                        }\n                      cp += 3;\n                    }\n#endif\n                  else\n                    break;\n                }\n\n              /* Read the conversion character.  */\n              c = *cp++;\n              switch (c)\n                {\n                case 'd': case 'i':\n#if HAVE_LONG_LONG_INT\n                  /* If 'long long' exists and is larger than 'long':  */\n                  if (flags >= 16 || (flags & 4))\n                    type = TYPE_LONGLONGINT;\n                  else\n#endif\n                  /* If 'long long' exists and is the same as 'long', we parse\n                     \"lld\" into TYPE_LONGINT.  */\n                  if (flags >= 8)\n                    type = TYPE_LONGINT;\n                  else if (flags & 2)\n                    type = TYPE_SCHAR;\n                  else if (flags & 1)\n                    type = TYPE_SHORT;\n                  else\n                    type = TYPE_INT;\n                  break;\n                case 'o': case 'u': case 'x': case 'X':\n#if HAVE_LONG_LONG_INT\n                  /* If 'long long' exists and is larger than 'long':  */\n                  if (flags >= 16 || (flags & 4))\n                    type = TYPE_ULONGLONGINT;\n                  else\n#endif\n                  /* If 'unsigned long long' exists and is the same as\n                     'unsigned long', we parse \"llu\" into TYPE_ULONGINT.  */\n                  if (flags >= 8)\n                    type = TYPE_ULONGINT;\n                  else if (flags & 2)\n                    type = TYPE_UCHAR;\n                  else if (flags & 1)\n                    type = TYPE_USHORT;\n                  else\n                    type = TYPE_UINT;\n                  break;\n                case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                case 'a': case 'A':\n                  if (flags >= 16 || (flags & 4))\n                    type = TYPE_LONGDOUBLE;\n                  else\n                    type = TYPE_DOUBLE;\n                  break;\n                case 'c':\n                  if (flags >= 8)\n#if HAVE_WINT_T\n                    type = TYPE_WIDE_CHAR;\n#else\n                    goto error;\n#endif\n                  else\n                    type = TYPE_CHAR;\n                  break;\n#if HAVE_WINT_T\n                case 'C':\n                  type = TYPE_WIDE_CHAR;\n                  c = 'c';\n                  break;\n#endif\n                case 's':\n                  if (flags >= 8)\n#if HAVE_WCHAR_T\n                    type = TYPE_WIDE_STRING;\n#else\n                    goto error;\n#endif\n                  else\n                    type = TYPE_STRING;\n                  break;\n#if HAVE_WCHAR_T\n                case 'S':\n                  type = TYPE_WIDE_STRING;\n                  c = 's';\n                  break;\n#endif\n                case 'p':\n                  type = TYPE_POINTER;\n                  break;\n                case 'n':\n#if HAVE_LONG_LONG_INT\n                  /* If 'long long' exists and is larger than 'long':  */\n                  if (flags >= 16 || (flags & 4))\n                    type = TYPE_COUNT_LONGLONGINT_POINTER;\n                  else\n#endif\n                  /* If 'long long' exists and is the same as 'long', we parse\n                     \"lln\" into TYPE_COUNT_LONGINT_POINTER.  */\n                  if (flags >= 8)\n                    type = TYPE_COUNT_LONGINT_POINTER;\n                  else if (flags & 2)\n                    type = TYPE_COUNT_SCHAR_POINTER;\n                  else if (flags & 1)\n                    type = TYPE_COUNT_SHORT_POINTER;\n                  else\n                    type = TYPE_COUNT_INT_POINTER;\n                  break;\n#if ENABLE_UNISTDIO\n                /* The unistdio extensions.  */\n                case 'U':\n                  if (flags >= 16)\n                    type = TYPE_U32_STRING;\n                  else if (flags >= 8)\n                    type = TYPE_U16_STRING;\n                  else\n                    type = TYPE_U8_STRING;\n                  break;\n#endif\n                case '%':\n                  type = TYPE_NONE;\n                  break;\n                default:\n                  /* Unknown conversion character.  */\n                  goto error;\n                }\n            }\n\n            if (type != TYPE_NONE)\n              {\n                dp->arg_index = arg_index;\n                if (dp->arg_index == ARG_NONE)\n                  {\n                    dp->arg_index = arg_posn++;\n                    if (dp->arg_index == ARG_NONE)\n                      /* arg_posn wrapped around.  */\n                      goto error;\n                  }\n                REGISTER_ARG (dp->arg_index, type);\n              }\n            dp->conversion = c;\n            dp->dir_end = cp;\n          }\n\n          d->count++;\n          if (d->count >= d_allocated)\n            {\n              size_t memory_size;\n              DIRECTIVE *memory;\n\n              d_allocated = xtimes (d_allocated, 2);\n              memory_size = xtimes (d_allocated, sizeof (DIRECTIVE));\n              if (size_overflow_p (memory_size))\n                /* Overflow, would lead to out of memory.  */\n                goto out_of_memory;\n              memory = (DIRECTIVE *) (d->dir != d->direct_alloc_dir\n                                      ? realloc (d->dir, memory_size)\n                                      : malloc (memory_size));\n              if (memory == NULL)\n                /* Out of memory.  */\n                goto out_of_memory;\n              if (d->dir == d->direct_alloc_dir)\n                memcpy (memory, d->dir, d->count * sizeof (DIRECTIVE));\n              d->dir = memory;\n            }\n        }\n#if CHAR_T_ONLY_ASCII\n      else if (!c_isascii (c))\n        {\n          /* Non-ASCII character.  Not supported.  */\n          goto error;\n        }\n#endif\n    }\n  d->dir[d->count].dir_start = cp;\n\n  d->max_width_length = max_width_length;\n  d->max_precision_length = max_precision_length;\n  return 0;\n\nerror:\n  if (a->arg != a->direct_alloc_arg)\n    free (a->arg);\n  if (d->dir != d->direct_alloc_dir)\n    free (d->dir);\n  errno = EINVAL;\n  return -1;\n\nout_of_memory:\n  if (a->arg != a->direct_alloc_arg)\n    free (a->arg);\n  if (d->dir != d->direct_alloc_dir)\n    free (d->dir);\n  errno = ENOMEM;\n  return -1;\n}",
      "lines": 551,
      "depth": 24,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/printf-parse.h": {},
  "findutils/findutils-4.6.0/gl/lib/progname.c": {
    "set_program_name": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        91,
        1
      ],
      "content": "void\nset_program_name (const char *argv0)\n{\n  /* libtool creates a temporary executable whose name is sometimes prefixed\n     with \"lt-\" (depends on the platform).  It also makes argv[0] absolute.\n     But the name of the temporary executable is a detail that should not be\n     visible to the end user and to the test suite.\n     Remove this \"<dirname>/.libs/\" or \"<dirname>/.libs/lt-\" prefix here.  */\n  const char *slash;\n  const char *base;\n\n  /* Sanity check.  POSIX requires the invoking process to pass a non-NULL\n     argv[0].  */\n  if (argv0 == NULL)\n    {\n      /* It's a bug in the invoking program.  Help diagnosing it.  */\n      fputs (\"A NULL argv[0] was passed through an exec system call.\\n\",\n             stderr);\n      abort ();\n    }\n\n  slash = strrchr (argv0, '/');\n  base = (slash != NULL ? slash + 1 : argv0);\n  if (base - argv0 >= 7 && strncmp (base - 7, \"/.libs/\", 7) == 0)\n    {\n      argv0 = base;\n      if (strncmp (base, \"lt-\", 3) == 0)\n        {\n          argv0 = base + 3;\n          /* On glibc systems, remove the \"lt-\" prefix from the variable\n             program_invocation_short_name.  */\n#if HAVE_DECL_PROGRAM_INVOCATION_SHORT_NAME\n          program_invocation_short_name = (char *) argv0;\n#endif\n        }\n    }\n\n  /* But don't strip off a leading <dirname>/ in general, because when the user\n     runs\n         /some/hidden/place/bin/cp foo foo\n     he should get the error message\n         /some/hidden/place/bin/cp: `foo' and `foo' are the same file\n     not\n         cp: `foo' and `foo' are the same file\n   */\n\n  program_name = argv0;\n\n  /* On glibc systems, the error() function comes from libc and uses the\n     variable program_invocation_name, not program_name.  So set this variable\n     as well.  */\n#if HAVE_DECL_PROGRAM_INVOCATION_NAME\n  program_invocation_name = (char *) argv0;\n#endif\n}",
      "lines": 55,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/progname.h": {},
  "findutils/findutils-4.6.0/gl/lib/quote.h": {},
  "findutils/findutils-4.6.0/gl/lib/quotearg.c": {
    "clone_quoting_options": {
      "start_point": [
        110,
        0
      ],
      "end_point": [
        118,
        1
      ],
      "content": "struct quoting_options *\nclone_quoting_options (struct quoting_options *o)\n{\n  int e = errno;\n  struct quoting_options *p = xmemdup (o ? o : &default_quoting_options,\n                                       sizeof *o);\n  errno = e;\n  return p;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "struct quoting_options",
        "struct",
        "quoting_options",
        "*\nclone_quoting_options (struct quoting_options *o)",
        "*"
      ]
    },
    "get_quoting_style": {
      "start_point": [
        121,
        0
      ],
      "end_point": [
        125,
        1
      ],
      "content": "enum quoting_style\nget_quoting_style (struct quoting_options const *o)\n{\n  return (o ? o : &default_quoting_options)->style;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "enum quoting_style",
        "enum",
        "quoting_style"
      ]
    },
    "set_quoting_style": {
      "start_point": [
        129,
        0
      ],
      "end_point": [
        133,
        1
      ],
      "content": "void\nset_quoting_style (struct quoting_options *o, enum quoting_style s)\n{\n  (o ? o : &default_quoting_options)->style = s;\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "set_char_quoting": {
      "start_point": [
        140,
        0
      ],
      "end_point": [
        150,
        1
      ],
      "content": "int\nset_char_quoting (struct quoting_options *o, char c, int i)\n{\n  unsigned char uc = c;\n  unsigned int *p =\n    (o ? o : &default_quoting_options)->quote_these_too + uc / INT_BITS;\n  int shift = uc % INT_BITS;\n  int r = (*p >> shift) & 1;\n  *p ^= ((i & 1) ^ r) << shift;\n  return r;\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "set_quoting_flags": {
      "start_point": [
        156,
        0
      ],
      "end_point": [
        165,
        1
      ],
      "content": "int\nset_quoting_flags (struct quoting_options *o, int i)\n{\n  int r;\n  if (!o)\n    o = &default_quoting_options;\n  r = o->flags;\n  o->flags = i;\n  return r;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "set_custom_quoting": {
      "start_point": [
        167,
        0
      ],
      "end_point": [
        178,
        1
      ],
      "content": "void\nset_custom_quoting (struct quoting_options *o,\n                    char const *left_quote, char const *right_quote)\n{\n  if (!o)\n    o = &default_quoting_options;\n  o->style = custom_quoting_style;\n  if (!left_quote || !right_quote)\n    abort ();\n  o->left_quote = left_quote;\n  o->right_quote = right_quote;\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "quoting_options_from_style": {
      "start_point": [
        181,
        0
      ],
      "end_point": [
        189,
        1
      ],
      "content": "static struct quoting_options /* NOT PURE!! */\nquoting_options_from_style (enum quoting_style style)\n{\n  struct quoting_options o = { literal_quoting_style, 0, { 0 }, NULL, NULL };\n  if (style == custom_quoting_style)\n    abort ();\n  o.style = style;\n  return o;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "struct quoting_options",
        "struct",
        "quoting_options",
        "/* NOT PURE!! */"
      ]
    },
    "gettext_quote": {
      "start_point": [
        195,
        0
      ],
      "end_point": [
        229,
        1
      ],
      "content": "static char const *\ngettext_quote (char const *msgid, enum quoting_style s)\n{\n  char const *translation = _(msgid);\n  char const *locale_code;\n\n  if (translation != msgid)\n    return translation;\n\n  /* For UTF-8 and GB-18030, use single quotes U+2018 and U+2019.\n     Here is a list of other locales that include U+2018 and U+2019:\n\n        ISO-8859-7   0xA1                 KOI8-T       0x91\n        CP869        0x8B                 CP874        0x91\n        CP932        0x81 0x65            CP936        0xA1 0xAE\n        CP949        0xA1 0xAE            CP950        0xA1 0xA5\n        CP1250       0x91                 CP1251       0x91\n        CP1252       0x91                 CP1253       0x91\n        CP1254       0x91                 CP1255       0x91\n        CP1256       0x91                 CP1257       0x91\n        EUC-JP       0xA1 0xC6            EUC-KR       0xA1 0xAE\n        EUC-TW       0xA1 0xE4            BIG5         0xA1 0xA5\n        BIG5-HKSCS   0xA1 0xA5            EUC-CN       0xA1 0xAE\n        GBK          0xA1 0xAE            Georgian-PS  0x91\n        PT154        0x91\n\n     None of these is still in wide use; using iconv is overkill.  */\n  locale_code = locale_charset ();\n  if (STRCASEEQ (locale_code, \"UTF-8\", 'U','T','F','-','8',0,0,0,0))\n    return msgid[0] == '`' ? \"\\xe2\\x80\\x98\": \"\\xe2\\x80\\x99\";\n  if (STRCASEEQ (locale_code, \"GB18030\", 'G','B','1','8','0','3','0',0,0))\n    return msgid[0] == '`' ? \"\\xa1\\ae\": \"\\xa1\\xaf\";\n\n  return (s == clocale_quoting_style ? \"\\\"\" : \"'\");\n}",
      "lines": 35,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "char",
        "const",
        "const",
        "*\ngettext_quote (char const *msgid, enum quoting_style s)",
        "*"
      ]
    },
    "quotearg_buffer_restyled": {
      "start_point": [
        244,
        0
      ],
      "end_point": [
        714,
        1
      ],
      "content": "static size_t\nquotearg_buffer_restyled (char *buffer, size_t buffersize,\n                          char const *arg, size_t argsize,\n                          enum quoting_style quoting_style, int flags,\n                          unsigned int const *quote_these_too,\n                          char const *left_quote,\n                          char const *right_quote)\n{\n  size_t i;\n  size_t len = 0;\n  char const *quote_string = 0;\n  size_t quote_string_len = 0;\n  bool backslash_escapes = false;\n  bool unibyte_locale = MB_CUR_MAX == 1;\n  bool elide_outer_quotes = (flags & QA_ELIDE_OUTER_QUOTES) != 0;\n  bool pending_shell_escape_end = false;\n\n#define STORE(c) \\\n    do \\\n      { \\\n        if (len < buffersize) \\\n          buffer[len] = (c); \\\n        len++; \\\n      } \\\n    while (0)\n\n#define START_ESC() \\\n    do \\\n      { \\\n        if (elide_outer_quotes) \\\n          goto force_outer_quoting_style; \\\n        escaping = true; \\\n        if (quoting_style == shell_always_quoting_style \\\n            && ! pending_shell_escape_end) \\\n          { \\\n            STORE ('\\''); \\\n            STORE ('$'); \\\n            STORE ('\\''); \\\n            pending_shell_escape_end = true; \\\n          } \\\n        STORE ('\\\\'); \\\n      } \\\n    while (0)\n\n#define END_ESC() \\\n    do \\\n      { \\\n        if (pending_shell_escape_end && ! escaping) \\\n          { \\\n            STORE ('\\''); \\\n            STORE ('\\''); \\\n            pending_shell_escape_end = false; \\\n          } \\\n      } \\\n    while (0)\n\n  switch (quoting_style)\n    {\n    case c_maybe_quoting_style:\n      quoting_style = c_quoting_style;\n      elide_outer_quotes = true;\n      /* Fall through.  */\n    case c_quoting_style:\n      if (!elide_outer_quotes)\n        STORE ('\"');\n      backslash_escapes = true;\n      quote_string = \"\\\"\";\n      quote_string_len = 1;\n      break;\n\n    case escape_quoting_style:\n      backslash_escapes = true;\n      elide_outer_quotes = false;\n      break;\n\n    case locale_quoting_style:\n    case clocale_quoting_style:\n    case custom_quoting_style:\n      {\n        if (quoting_style != custom_quoting_style)\n          {\n            /* TRANSLATORS:\n               Get translations for open and closing quotation marks.\n               The message catalog should translate \"`\" to a left\n               quotation mark suitable for the locale, and similarly for\n               \"'\".  For example, a French Unicode local should translate\n               these to U+00AB (LEFT-POINTING DOUBLE ANGLE\n               QUOTATION MARK), and U+00BB (RIGHT-POINTING DOUBLE ANGLE\n               QUOTATION MARK), respectively.\n\n               If the catalog has no translation, we will try to\n               use Unicode U+2018 (LEFT SINGLE QUOTATION MARK) and\n               Unicode U+2019 (RIGHT SINGLE QUOTATION MARK).  If the\n               current locale is not Unicode, locale_quoting_style\n               will quote 'like this', and clocale_quoting_style will\n               quote \"like this\".  You should always include translations\n               for \"`\" and \"'\" even if U+2018 and U+2019 are appropriate\n               for your locale.\n\n               If you don't know what to put here, please see\n               <http://en.wikipedia.org/wiki/Quotation_marks_in_other_languages>\n               and use glyphs suitable for your language.  */\n            left_quote = gettext_quote (N_(\"`\"), quoting_style);\n            right_quote = gettext_quote (N_(\"'\"), quoting_style);\n          }\n        if (!elide_outer_quotes)\n          for (quote_string = left_quote; *quote_string; quote_string++)\n            STORE (*quote_string);\n        backslash_escapes = true;\n        quote_string = right_quote;\n        quote_string_len = strlen (quote_string);\n      }\n      break;\n\n    case shell_escape_quoting_style:\n      backslash_escapes = true;\n      /* Fall through.  */\n    case shell_quoting_style:\n      elide_outer_quotes = true;\n      /* Fall through.  */\n    case shell_escape_always_quoting_style:\n      if (!elide_outer_quotes)\n        backslash_escapes = true;\n      /* Fall through.  */\n    case shell_always_quoting_style:\n      quoting_style = shell_always_quoting_style;\n      if (!elide_outer_quotes)\n        STORE ('\\'');\n      quote_string = \"'\";\n      quote_string_len = 1;\n      break;\n\n    case literal_quoting_style:\n      elide_outer_quotes = false;\n      break;\n\n    default:\n      abort ();\n    }\n\n  for (i = 0;  ! (argsize == SIZE_MAX ? arg[i] == '\\0' : i == argsize);  i++)\n    {\n      unsigned char c;\n      unsigned char esc;\n      bool is_right_quote = false;\n      bool escaping = false;\n\n      if (backslash_escapes\n          && quoting_style != shell_always_quoting_style\n          && quote_string_len\n          && (i + quote_string_len\n              <= (argsize == SIZE_MAX && 1 < quote_string_len\n                  /* Use strlen only if we must: when argsize is SIZE_MAX,\n                     and when the quote string is more than 1 byte long.\n                     If we do call strlen, save the result.  */\n                  ? (argsize = strlen (arg)) : argsize))\n          && memcmp (arg + i, quote_string, quote_string_len) == 0)\n        {\n          if (elide_outer_quotes)\n            goto force_outer_quoting_style;\n          is_right_quote = true;\n        }\n\n      c = arg[i];\n      switch (c)\n        {\n        case '\\0':\n          if (backslash_escapes)\n            {\n              START_ESC ();\n              /* If quote_string were to begin with digits, we'd need to\n                 test for the end of the arg as well.  However, it's\n                 hard to imagine any locale that would use digits in\n                 quotes, and set_custom_quoting is documented not to\n                 accept them.  Use only a single \\0 with shell-escape\n                 as currently digits are not printed within $'...'  */\n              if (quoting_style != shell_always_quoting_style\n                  && i + 1 < argsize && '0' <= arg[i + 1] && arg[i + 1] <= '9')\n                {\n                  STORE ('0');\n                  STORE ('0');\n                }\n              c = '0';\n              /* We don't have to worry that this last '0' will be\n                 backslash-escaped because, again, quote_string should\n                 not start with it and because quote_these_too is\n                 documented as not accepting it.  */\n            }\n          else if (flags & QA_ELIDE_NULL_BYTES)\n            continue;\n          break;\n\n        case '?':\n          switch (quoting_style)\n            {\n            case shell_always_quoting_style:\n              if (elide_outer_quotes)\n                goto force_outer_quoting_style;\n              break;\n\n            case c_quoting_style:\n              if ((flags & QA_SPLIT_TRIGRAPHS)\n                  && i + 2 < argsize && arg[i + 1] == '?')\n                switch (arg[i + 2])\n                  {\n                  case '!': case '\\'':\n                  case '(': case ')': case '-': case '/':\n                  case '<': case '=': case '>':\n                    /* Escape the second '?' in what would otherwise be\n                       a trigraph.  */\n                    if (elide_outer_quotes)\n                      goto force_outer_quoting_style;\n                    c = arg[i + 2];\n                    i += 2;\n                    STORE ('?');\n                    STORE ('\"');\n                    STORE ('\"');\n                    STORE ('?');\n                    break;\n\n                  default:\n                    break;\n                  }\n              break;\n\n            default:\n              break;\n            }\n          break;\n\n        case '\\a': esc = 'a'; goto c_escape;\n        case '\\b': esc = 'b'; goto c_escape;\n        case '\\f': esc = 'f'; goto c_escape;\n        case '\\n': esc = 'n'; goto c_and_shell_escape;\n        case '\\r': esc = 'r'; goto c_and_shell_escape;\n        case '\\t': esc = 't'; goto c_and_shell_escape;\n        case '\\v': esc = 'v'; goto c_escape;\n        case '\\\\': esc = c;\n          /* Never need to escape '\\' in shell case.  */\n          if (quoting_style == shell_always_quoting_style)\n            {\n              if (elide_outer_quotes)\n                goto force_outer_quoting_style;\n              goto store_c;\n            }\n\n          /* No need to escape the escape if we are trying to elide\n             outer quotes and nothing else is problematic.  */\n          if (backslash_escapes && elide_outer_quotes && quote_string_len)\n            goto store_c;\n\n        c_and_shell_escape:\n          if (quoting_style == shell_always_quoting_style\n              && elide_outer_quotes)\n            goto force_outer_quoting_style;\n          /* Fall through.  */\n        c_escape:\n          if (backslash_escapes)\n            {\n              c = esc;\n              goto store_escape;\n            }\n          break;\n\n        case '{': case '}': /* sometimes special if isolated */\n          if (! (argsize == SIZE_MAX ? arg[1] == '\\0' : argsize == 1))\n            break;\n          /* Fall through.  */\n        case '#': case '~':\n          if (i != 0)\n            break;\n          /* Fall through.  */\n        case ' ':\n        case '!': /* special in bash */\n        case '\"': case '$': case '&':\n        case '(': case ')': case '*': case ';':\n        case '<':\n        case '=': /* sometimes special in 0th or (with \"set -k\") later args */\n        case '>': case '[':\n        case '^': /* special in old /bin/sh, e.g. SunOS 4.1.4 */\n        case '`': case '|':\n          /* A shell special character.  In theory, '$' and '`' could\n             be the first bytes of multibyte characters, which means\n             we should check them with mbrtowc, but in practice this\n             doesn't happen so it's not worth worrying about.  */\n          if (quoting_style == shell_always_quoting_style\n              && elide_outer_quotes)\n            goto force_outer_quoting_style;\n          break;\n\n        case '\\'':\n          if (quoting_style == shell_always_quoting_style)\n            {\n              if (elide_outer_quotes)\n                goto force_outer_quoting_style;\n              STORE ('\\'');\n              STORE ('\\\\');\n              STORE ('\\'');\n              pending_shell_escape_end = false;\n            }\n          break;\n\n        case '%': case '+': case ',': case '-': case '.': case '/':\n        case '0': case '1': case '2': case '3': case '4': case '5':\n        case '6': case '7': case '8': case '9': case ':':\n        case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n        case 'G': case 'H': case 'I': case 'J': case 'K': case 'L':\n        case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':\n        case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n        case 'Y': case 'Z': case ']': case '_': case 'a': case 'b':\n        case 'c': case 'd': case 'e': case 'f': case 'g': case 'h':\n        case 'i': case 'j': case 'k': case 'l': case 'm': case 'n':\n        case 'o': case 'p': case 'q': case 'r': case 's': case 't':\n        case 'u': case 'v': case 'w': case 'x': case 'y': case 'z':\n          /* These characters don't cause problems, no matter what the\n             quoting style is.  They cannot start multibyte sequences.\n             A digit or a special letter would cause trouble if it\n             appeared at the beginning of quote_string because we'd then\n             escape by prepending a backslash.  However, it's hard to\n             imagine any locale that would use digits or letters as\n             quotes, and set_custom_quoting is documented not to accept\n             them.  Also, a digit or a special letter would cause\n             trouble if it appeared in quote_these_too, but that's also\n             documented as not accepting them.  */\n          break;\n\n        default:\n          /* If we have a multibyte sequence, copy it until we reach\n             its end, find an error, or come back to the initial shift\n             state.  For C-like styles, if the sequence has\n             unprintable characters, escape the whole sequence, since\n             we can't easily escape single characters within it.  */\n          {\n            /* Length of multibyte sequence found so far.  */\n            size_t m;\n\n            bool printable;\n\n            if (unibyte_locale)\n              {\n                m = 1;\n                printable = isprint (c) != 0;\n              }\n            else\n              {\n                mbstate_t mbstate;\n                memset (&mbstate, 0, sizeof mbstate);\n\n                m = 0;\n                printable = true;\n                if (argsize == SIZE_MAX)\n                  argsize = strlen (arg);\n\n                do\n                  {\n                    wchar_t w;\n                    size_t bytes = mbrtowc (&w, &arg[i + m],\n                                            argsize - (i + m), &mbstate);\n                    if (bytes == 0)\n                      break;\n                    else if (bytes == (size_t) -1)\n                      {\n                        printable = false;\n                        break;\n                      }\n                    else if (bytes == (size_t) -2)\n                      {\n                        printable = false;\n                        while (i + m < argsize && arg[i + m])\n                          m++;\n                        break;\n                      }\n                    else\n                      {\n                        /* Work around a bug with older shells that \"see\" a '\\'\n                           that is really the 2nd byte of a multibyte character.\n                           In practice the problem is limited to ASCII\n                           chars >= '@' that are shell special chars.  */\n                        if ('[' == 0x5b && elide_outer_quotes\n                            && quoting_style == shell_always_quoting_style)\n                          {\n                            size_t j;\n                            for (j = 1; j < bytes; j++)\n                              switch (arg[i + m + j])\n                                {\n                                case '[': case '\\\\': case '^':\n                                case '`': case '|':\n                                  goto force_outer_quoting_style;\n\n                                default:\n                                  break;\n                                }\n                          }\n\n                        if (! iswprint (w))\n                          printable = false;\n                        m += bytes;\n                      }\n                  }\n                while (! mbsinit (&mbstate));\n              }\n\n            if (1 < m || (backslash_escapes && ! printable))\n              {\n                /* Output a multibyte sequence, or an escaped\n                   unprintable unibyte character.  */\n                size_t ilim = i + m;\n\n                for (;;)\n                  {\n                    if (backslash_escapes && ! printable)\n                      {\n                        START_ESC ();\n                        STORE ('0' + (c >> 6));\n                        STORE ('0' + ((c >> 3) & 7));\n                        c = '0' + (c & 7);\n                      }\n                    else if (is_right_quote)\n                      {\n                        STORE ('\\\\');\n                        is_right_quote = false;\n                      }\n                    if (ilim <= i + 1)\n                      break;\n                    END_ESC ();\n                    STORE (c);\n                    c = arg[++i];\n                  }\n\n                goto store_c;\n              }\n          }\n        }\n\n      if (! (((backslash_escapes && quoting_style != shell_always_quoting_style)\n              || elide_outer_quotes)\n             && quote_these_too\n             && quote_these_too[c / INT_BITS] >> (c % INT_BITS) & 1)\n          && !is_right_quote)\n        goto store_c;\n\n    store_escape:\n      START_ESC ();\n\n    store_c:\n      END_ESC ();\n      STORE (c);\n    }\n\n  if (len == 0 && quoting_style == shell_always_quoting_style\n      && elide_outer_quotes)\n    goto force_outer_quoting_style;\n\n  if (quote_string && !elide_outer_quotes)\n    for (; *quote_string; quote_string++)\n      STORE (*quote_string);\n\n  if (len < buffersize)\n    buffer[len] = '\\0';\n  return len;\n\n force_outer_quoting_style:\n  /* Don't reuse quote_these_too, since the addition of outer quotes\n     sufficiently quotes the specified characters.  */\n  if (quoting_style == shell_always_quoting_style && backslash_escapes)\n    quoting_style = shell_escape_always_quoting_style;\n  return quotearg_buffer_restyled (buffer, buffersize, arg, argsize,\n                                   quoting_style,\n                                   flags & ~QA_ELIDE_OUTER_QUOTES, NULL,\n                                   left_quote, right_quote);\n}",
      "lines": 471,
      "depth": 25,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "quotearg_buffer": {
      "start_point": [
        725,
        0
      ],
      "end_point": [
        737,
        1
      ],
      "content": "size_t\nquotearg_buffer (char *buffer, size_t buffersize,\n                 char const *arg, size_t argsize,\n                 struct quoting_options const *o)\n{\n  struct quoting_options const *p = o ? o : &default_quoting_options;\n  int e = errno;\n  size_t r = quotearg_buffer_restyled (buffer, buffersize, arg, argsize,\n                                       p->style, p->flags, p->quote_these_too,\n                                       p->left_quote, p->right_quote);\n  errno = e;\n  return r;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "size_t"
      ]
    },
    "quotearg_alloc": {
      "start_point": [
        740,
        0
      ],
      "end_point": [
        745,
        1
      ],
      "content": "char *\nquotearg_alloc (char const *arg, size_t argsize,\n                struct quoting_options const *o)\n{\n  return quotearg_alloc_mem (arg, argsize, NULL, o);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_alloc (char const *arg, size_t argsize,\n                struct quoting_options const *o)",
        "*"
      ]
    },
    "quotearg_alloc_mem": {
      "start_point": [
        753,
        0
      ],
      "end_point": [
        773,
        1
      ],
      "content": "char *\nquotearg_alloc_mem (char const *arg, size_t argsize, size_t *size,\n                    struct quoting_options const *o)\n{\n  struct quoting_options const *p = o ? o : &default_quoting_options;\n  int e = errno;\n  /* Elide embedded null bytes if we can't return a size.  */\n  int flags = p->flags | (size ? 0 : QA_ELIDE_NULL_BYTES);\n  size_t bufsize = quotearg_buffer_restyled (0, 0, arg, argsize, p->style,\n                                             flags, p->quote_these_too,\n                                             p->left_quote,\n                                             p->right_quote) + 1;\n  char *buf = xcharalloc (bufsize);\n  quotearg_buffer_restyled (buf, bufsize, arg, argsize, p->style, flags,\n                            p->quote_these_too,\n                            p->left_quote, p->right_quote);\n  errno = e;\n  if (size)\n    *size = bufsize - 1;\n  return buf;\n}",
      "lines": 21,
      "depth": 9,
      "decorators": [
        "char",
        "*\nquotearg_alloc_mem (char const *arg, size_t argsize, size_t *size,\n                    struct quoting_options const *o)",
        "*"
      ]
    },
    "quotearg_free": {
      "start_point": [
        789,
        0
      ],
      "end_point": [
        808,
        1
      ],
      "content": "void\nquotearg_free (void)\n{\n  struct slotvec *sv = slotvec;\n  unsigned int i;\n  for (i = 1; i < nslots; i++)\n    free (sv[i].val);\n  if (sv[0].val != slot0)\n    {\n      free (sv[0].val);\n      slotvec0.size = sizeof slot0;\n      slotvec0.val = slot0;\n    }\n  if (sv != &slotvec0)\n    {\n      free (sv);\n      slotvec = &slotvec0;\n    }\n  nslots = 1;\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "quotearg_n_options": {
      "start_point": [
        818,
        0
      ],
      "end_point": [
        876,
        1
      ],
      "content": "static char *\nquotearg_n_options (int n, char const *arg, size_t argsize,\n                    struct quoting_options const *options)\n{\n  int e = errno;\n\n  unsigned int n0 = n;\n  struct slotvec *sv = slotvec;\n\n  if (n < 0)\n    abort ();\n\n  if (nslots <= n0)\n    {\n      /* FIXME: technically, the type of n1 should be 'unsigned int',\n         but that evokes an unsuppressible warning from gcc-4.0.1 and\n         older.  If gcc ever provides an option to suppress that warning,\n         revert to the original type, so that the test in xalloc_oversized\n         is once again performed only at compile time.  */\n      size_t n1 = n0 + 1;\n      bool preallocated = (sv == &slotvec0);\n\n      if (xalloc_oversized (n1, sizeof *sv))\n        xalloc_die ();\n\n      slotvec = sv = xrealloc (preallocated ? NULL : sv, n1 * sizeof *sv);\n      if (preallocated)\n        *sv = slotvec0;\n      memset (sv + nslots, 0, (n1 - nslots) * sizeof *sv);\n      nslots = n1;\n    }\n\n  {\n    size_t size = sv[n].size;\n    char *val = sv[n].val;\n    /* Elide embedded null bytes since we don't return a size.  */\n    int flags = options->flags | QA_ELIDE_NULL_BYTES;\n    size_t qsize = quotearg_buffer_restyled (val, size, arg, argsize,\n                                             options->style, flags,\n                                             options->quote_these_too,\n                                             options->left_quote,\n                                             options->right_quote);\n\n    if (size <= qsize)\n      {\n        sv[n].size = size = qsize + 1;\n        if (val != slot0)\n          free (val);\n        sv[n].val = val = xcharalloc (size);\n        quotearg_buffer_restyled (val, size, arg, argsize, options->style,\n                                  flags, options->quote_these_too,\n                                  options->left_quote,\n                                  options->right_quote);\n      }\n\n    errno = e;\n    return val;\n  }\n}",
      "lines": 59,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nquotearg_n_options (int n, char const *arg, size_t argsize,\n                    struct quoting_options const *options)",
        "*"
      ]
    },
    "quotearg_n": {
      "start_point": [
        878,
        0
      ],
      "end_point": [
        882,
        1
      ],
      "content": "char *\nquotearg_n (int n, char const *arg)\n{\n  return quotearg_n_options (n, arg, SIZE_MAX, &default_quoting_options);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_n (int n, char const *arg)",
        "*"
      ]
    },
    "quotearg_n_mem": {
      "start_point": [
        884,
        0
      ],
      "end_point": [
        888,
        1
      ],
      "content": "char *\nquotearg_n_mem (int n, char const *arg, size_t argsize)\n{\n  return quotearg_n_options (n, arg, argsize, &default_quoting_options);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_n_mem (int n, char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quotearg": {
      "start_point": [
        890,
        0
      ],
      "end_point": [
        894,
        1
      ],
      "content": "char *\nquotearg (char const *arg)\n{\n  return quotearg_n (0, arg);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg (char const *arg)",
        "*"
      ]
    },
    "quotearg_mem": {
      "start_point": [
        896,
        0
      ],
      "end_point": [
        900,
        1
      ],
      "content": "char *\nquotearg_mem (char const *arg, size_t argsize)\n{\n  return quotearg_n_mem (0, arg, argsize);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_mem (char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quotearg_n_style": {
      "start_point": [
        902,
        0
      ],
      "end_point": [
        907,
        1
      ],
      "content": "char *\nquotearg_n_style (int n, enum quoting_style s, char const *arg)\n{\n  struct quoting_options const o = quoting_options_from_style (s);\n  return quotearg_n_options (n, arg, SIZE_MAX, &o);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_n_style (int n, enum quoting_style s, char const *arg)",
        "*"
      ]
    },
    "quotearg_n_style_mem": {
      "start_point": [
        909,
        0
      ],
      "end_point": [
        915,
        1
      ],
      "content": "char *\nquotearg_n_style_mem (int n, enum quoting_style s,\n                      char const *arg, size_t argsize)\n{\n  struct quoting_options const o = quoting_options_from_style (s);\n  return quotearg_n_options (n, arg, argsize, &o);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_n_style_mem (int n, enum quoting_style s,\n                      char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quotearg_style": {
      "start_point": [
        917,
        0
      ],
      "end_point": [
        921,
        1
      ],
      "content": "char *\nquotearg_style (enum quoting_style s, char const *arg)\n{\n  return quotearg_n_style (0, s, arg);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_style (enum quoting_style s, char const *arg)",
        "*"
      ]
    },
    "quotearg_style_mem": {
      "start_point": [
        923,
        0
      ],
      "end_point": [
        927,
        1
      ],
      "content": "char *\nquotearg_style_mem (enum quoting_style s, char const *arg, size_t argsize)\n{\n  return quotearg_n_style_mem (0, s, arg, argsize);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_style_mem (enum quoting_style s, char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quotearg_char_mem": {
      "start_point": [
        929,
        0
      ],
      "end_point": [
        936,
        1
      ],
      "content": "char *\nquotearg_char_mem (char const *arg, size_t argsize, char ch)\n{\n  struct quoting_options options;\n  options = default_quoting_options;\n  set_char_quoting (&options, ch, 1);\n  return quotearg_n_options (0, arg, argsize, &options);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_char_mem (char const *arg, size_t argsize, char ch)",
        "*"
      ]
    },
    "quotearg_char": {
      "start_point": [
        938,
        0
      ],
      "end_point": [
        942,
        1
      ],
      "content": "char *\nquotearg_char (char const *arg, char ch)\n{\n  return quotearg_char_mem (arg, SIZE_MAX, ch);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_char (char const *arg, char ch)",
        "*"
      ]
    },
    "quotearg_colon": {
      "start_point": [
        944,
        0
      ],
      "end_point": [
        948,
        1
      ],
      "content": "char *\nquotearg_colon (char const *arg)\n{\n  return quotearg_char (arg, ':');\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_colon (char const *arg)",
        "*"
      ]
    },
    "quotearg_colon_mem": {
      "start_point": [
        950,
        0
      ],
      "end_point": [
        954,
        1
      ],
      "content": "char *\nquotearg_colon_mem (char const *arg, size_t argsize)\n{\n  return quotearg_char_mem (arg, argsize, ':');\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_colon_mem (char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quotearg_n_style_colon": {
      "start_point": [
        956,
        0
      ],
      "end_point": [
        963,
        1
      ],
      "content": "char *\nquotearg_n_style_colon (int n, enum quoting_style s, char const *arg)\n{\n  struct quoting_options options;\n  options = quoting_options_from_style (s);\n  set_char_quoting (&options, ':', 1);\n  return quotearg_n_options (n, arg, SIZE_MAX, &options);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_n_style_colon (int n, enum quoting_style s, char const *arg)",
        "*"
      ]
    },
    "quotearg_n_custom": {
      "start_point": [
        965,
        0
      ],
      "end_point": [
        971,
        1
      ],
      "content": "char *\nquotearg_n_custom (int n, char const *left_quote,\n                   char const *right_quote, char const *arg)\n{\n  return quotearg_n_custom_mem (n, left_quote, right_quote, arg,\n                                SIZE_MAX);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_n_custom (int n, char const *left_quote,\n                   char const *right_quote, char const *arg)",
        "*"
      ]
    },
    "quotearg_n_custom_mem": {
      "start_point": [
        973,
        0
      ],
      "end_point": [
        981,
        1
      ],
      "content": "char *\nquotearg_n_custom_mem (int n, char const *left_quote,\n                       char const *right_quote,\n                       char const *arg, size_t argsize)\n{\n  struct quoting_options o = default_quoting_options;\n  set_custom_quoting (&o, left_quote, right_quote);\n  return quotearg_n_options (n, arg, argsize, &o);\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_n_custom_mem (int n, char const *left_quote,\n                       char const *right_quote,\n                       char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quotearg_custom": {
      "start_point": [
        983,
        0
      ],
      "end_point": [
        988,
        1
      ],
      "content": "char *\nquotearg_custom (char const *left_quote, char const *right_quote,\n                 char const *arg)\n{\n  return quotearg_n_custom (0, left_quote, right_quote, arg);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_custom (char const *left_quote, char const *right_quote,\n                 char const *arg)",
        "*"
      ]
    },
    "quotearg_custom_mem": {
      "start_point": [
        990,
        0
      ],
      "end_point": [
        996,
        1
      ],
      "content": "char *\nquotearg_custom_mem (char const *left_quote, char const *right_quote,\n                     char const *arg, size_t argsize)\n{\n  return quotearg_n_custom_mem (0, left_quote, right_quote, arg,\n                                argsize);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_custom_mem (char const *left_quote, char const *right_quote,\n                     char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quote_n_mem": {
      "start_point": [
        1008,
        0
      ],
      "end_point": [
        1012,
        1
      ],
      "content": "char const *\nquote_n_mem (int n, char const *arg, size_t argsize)\n{\n  return quotearg_n_options (n, arg, argsize, &quote_quoting_options);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "const",
        "const",
        "*\nquote_n_mem (int n, char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quote_mem": {
      "start_point": [
        1014,
        0
      ],
      "end_point": [
        1018,
        1
      ],
      "content": "char const *\nquote_mem (char const *arg, size_t argsize)\n{\n  return quote_n_mem (0, arg, argsize);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "const",
        "const",
        "*\nquote_mem (char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quote_n": {
      "start_point": [
        1020,
        0
      ],
      "end_point": [
        1024,
        1
      ],
      "content": "char const *\nquote_n (int n, char const *arg)\n{\n  return quote_n_mem (n, arg, SIZE_MAX);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "const",
        "const",
        "*\nquote_n (int n, char const *arg)",
        "*"
      ]
    },
    "quote": {
      "start_point": [
        1026,
        0
      ],
      "end_point": [
        1030,
        1
      ],
      "content": "char const *\nquote (char const *arg)\n{\n  return quote_n (0, arg);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "const",
        "const",
        "*\nquote (char const *arg)",
        "*"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/quotearg.h": {},
  "findutils/findutils-4.6.0/gl/lib/read.c": {
    "read_nothrow": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        44,
        5
      ],
      "content": "static ssize_t\nread_nothrow (int fd, void *buf, size_t count)\n{\n  ssize_t result;\n\n  TRY_MSVC_INVAL\n    {\n      result = read (fd, buf, count);\n    }",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "ssize_t"
      ]
    },
    "rpl_read": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        82,
        1
      ],
      "content": "ssize_t\nrpl_read (int fd, void *buf, size_t count)\n{\n  ssize_t ret = read_nothrow (fd, buf, count);\n\n# if GNULIB_NONBLOCKING\n  if (ret < 0\n      && GetLastError () == ERROR_NO_DATA)\n    {\n      HANDLE h = (HANDLE) _get_osfhandle (fd);\n      if (GetFileType (h) == FILE_TYPE_PIPE)\n        {\n          /* h is a pipe or socket.  */\n          DWORD state;\n          if (GetNamedPipeHandleState (h, &state, NULL, NULL, NULL, NULL, 0)\n              && (state & PIPE_NOWAIT) != 0)\n            /* h is a pipe in non-blocking mode.\n               Change errno from EINVAL to EAGAIN.  */\n            errno = EAGAIN;\n        }\n    }\n# endif\n\n  return ret;\n}",
      "lines": 25,
      "depth": 14,
      "decorators": [
        "ssize_t"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/readdir.c": {
    "readdir": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        97,
        1
      ],
      "content": "struct dirent *\nreaddir (DIR *dirp)\n{\n  char type;\n  struct dirent *result;\n\n  /* There is no need to add code to produce entries for \".\" and \"..\".\n     According to the POSIX:2008 section \"4.12 Pathname Resolution\"\n     <http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html>\n     \".\" and \"..\" are syntactic entities.\n     POSIX also says:\n       \"If entries for dot or dot-dot exist, one entry shall be returned\n        for dot and one entry shall be returned for dot-dot; otherwise,\n        they shall not be returned.\"  */\n\n  switch (dirp->status)\n    {\n    case -2:\n      /* End of directory already reached.  */\n      return NULL;\n    case -1:\n      break;\n    case 0:\n      if (!FindNextFile (dirp->current, &dirp->entry))\n        {\n          switch (GetLastError ())\n            {\n            case ERROR_NO_MORE_FILES:\n              dirp->status = -2;\n              return NULL;\n            default:\n              errno = EIO;\n              return NULL;\n            }\n        }\n      break;\n    default:\n      errno = dirp->status;\n      return NULL;\n    }\n\n  dirp->status = 0;\n\n  if (dirp->entry.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)\n    type = DT_DIR;\n  else if (dirp->entry.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT)\n    type = DT_LNK;\n  else if ((dirp->entry.dwFileAttributes\n            & ~(FILE_ATTRIBUTE_READONLY\n                | FILE_ATTRIBUTE_HIDDEN\n                | FILE_ATTRIBUTE_SYSTEM\n                | FILE_ATTRIBUTE_ARCHIVE\n                | FILE_ATTRIBUTE_NORMAL\n                | FILE_ATTRIBUTE_TEMPORARY\n                | FILE_ATTRIBUTE_SPARSE_FILE\n                | FILE_ATTRIBUTE_COMPRESSED\n                | FILE_ATTRIBUTE_NOT_CONTENT_INDEXED\n                | FILE_ATTRIBUTE_ENCRYPTED)) == 0)\n    /* Devices like COM1, LPT1, NUL would also have the attributes 0x20 but\n       they cannot occur here.  */\n    type = DT_REG;\n  else\n    type = DT_UNKNOWN;\n\n  /* Reuse the memory of dirp->entry for the result.  */\n  result =\n    (struct dirent *)\n    ((char *) dirp->entry.cFileName - offsetof (struct dirent, d_name[0]));\n  result->d_type = type;\n\n  return result;\n}",
      "lines": 72,
      "depth": 21,
      "decorators": [
        "struct dirent",
        "struct",
        "dirent",
        "*\nreaddir (DIR *dirp)",
        "*"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/readlink.c": {
    "readlink": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        42,
        1
      ],
      "content": "ssize_t\nreadlink (const char *name, char *buf _GL_UNUSED,\n          size_t bufsize _GL_UNUSED)\n{\n  struct stat statbuf;\n\n  /* In general we should use lstat() here, not stat().  But on platforms\n     without symbolic links, lstat() - if it exists - would be equivalent to\n     stat(), therefore we can use stat().  This saves us a configure check.  */\n  if (stat (name, &statbuf) >= 0)\n    errno = EINVAL;\n  return -1;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "ssize_t"
      ]
    },
    "rpl_readlink": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "ssize_t\nrpl_readlink (const char *name, char *buf, size_t bufsize)\n{\n# if READLINK_TRAILING_SLASH_BUG\n  size_t len = strlen (name);\n  if (len && name[len - 1] == '/')\n    {\n      /* Even if name without the slash is a symlink to a directory,\n         both lstat() and stat() must resolve the trailing slash to\n         the directory rather than the symlink.  We can therefore\n         safely use stat() to distinguish between EINVAL and\n         ENOTDIR/ENOENT, avoiding extra overhead of rpl_lstat().  */\n      struct stat st;\n      if (stat (name, &st) == 0)\n        errno = EINVAL;\n      return -1;\n    }\n# endif /* READLINK_TRAILING_SLASH_BUG */\n  return readlink (name, buf, bufsize);\n}",
      "lines": 20,
      "depth": 12,
      "decorators": [
        "ssize_t"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/readlinkat.c": {
    "rpl_readlinkat": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "ssize_t\nrpl_readlinkat (int fd, char const *file, char *buf, size_t len)\n{\n# if READLINK_TRAILING_SLASH_BUG\n  size_t file_len = strlen (file);\n  if (file_len && file[file_len - 1] == '/')\n    {\n      /* Even if FILE without the slash is a symlink to a directory,\n         both lstat() and stat() must resolve the trailing slash to\n         the directory rather than the symlink.  We can therefore\n         safely use stat() to distinguish between EINVAL and\n         ENOTDIR/ENOENT, avoiding extra overhead of rpl_lstat().  */\n      struct stat st;\n      if (stat (file, &st) == 0)\n        errno = EINVAL;\n      return -1;\n    }\n# endif /* READLINK_TRAILING_SLASH_BUG */\n  return readlinkat (fd, file, buf, len);\n}",
      "lines": 20,
      "depth": 12,
      "decorators": [
        "ssize_t"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/realloc.c": {
    "rpl_realloc": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "void *\nrpl_realloc (void *p, size_t n)\n{\n  void *result;\n\n#if NEED_REALLOC_GNU\n  if (n == 0)\n    {\n      n = 1;\n\n      /* In theory realloc might fail, so don't rely on it to free.  */\n      free (p);\n      p = NULL;\n    }\n#endif\n\n  if (p == NULL)\n    {\n#if GNULIB_REALLOC_GNU && !NEED_REALLOC_GNU && !SYSTEM_MALLOC_GLIBC_COMPATIBLE\n      if (n == 0)\n        n = 1;\n#endif\n      result = malloc (n);\n    }\n  else\n    result = realloc (p, n);\n\n#if !HAVE_REALLOC_POSIX\n  if (result == NULL)\n    errno = ENOMEM;\n#endif\n\n  return result;\n}",
      "lines": 34,
      "depth": 9,
      "decorators": [
        "void",
        "*\nrpl_realloc (void *p, size_t n)",
        "*"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/regcomp.c": {
    "re_set_fastmap": {
      "start_point": [
        297,
        0
      ],
      "end_point": [
        304,
        1
      ],
      "content": "static inline void\n__attribute__ ((always_inline))\nre_set_fastmap (char *fastmap, bool icase, int ch)\n{\n  fastmap[ch] = 1;\n  if (icase)\n    fastmap[tolower (ch)] = 1;\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void",
        "__attribute__ ((always_inline))",
        "__attribute__",
        "(",
        "(always_inline)",
        "(",
        "always_inline",
        ")",
        ")"
      ]
    },
    "re_compile_fastmap_iter": {
      "start_point": [
        309,
        0
      ],
      "end_point": [
        437,
        1
      ],
      "content": "static void\nre_compile_fastmap_iter (regex_t *bufp, const re_dfastate_t *init_state,\n\t\t\t char *fastmap)\n{\n  re_dfa_t *dfa = bufp->buffer;\n  Idx node_cnt;\n  bool icase = (dfa->mb_cur_max == 1 && (bufp->syntax & RE_ICASE));\n  for (node_cnt = 0; node_cnt < init_state->nodes.nelem; ++node_cnt)\n    {\n      Idx node = init_state->nodes.elems[node_cnt];\n      re_token_type_t type = dfa->nodes[node].type;\n\n      if (type == CHARACTER)\n\t{\n\t  re_set_fastmap (fastmap, icase, dfa->nodes[node].opr.c);\n#ifdef RE_ENABLE_I18N\n\t  if ((bufp->syntax & RE_ICASE) && dfa->mb_cur_max > 1)\n\t    {\n\t      unsigned char buf[MB_LEN_MAX];\n\t      unsigned char *p;\n\t      wchar_t wc;\n\t      mbstate_t state;\n\n\t      p = buf;\n\t      *p++ = dfa->nodes[node].opr.c;\n\t      while (++node < dfa->nodes_len\n\t\t     &&\tdfa->nodes[node].type == CHARACTER\n\t\t     && dfa->nodes[node].mb_partial)\n\t\t*p++ = dfa->nodes[node].opr.c;\n\t      memset (&state, '\\0', sizeof (state));\n\t      if (__mbrtowc (&wc, (const char *) buf, p - buf,\n\t\t\t     &state) == p - buf\n\t\t  && (__wcrtomb ((char *) buf, __towlower (wc), &state)\n\t\t      != (size_t) -1))\n\t\tre_set_fastmap (fastmap, false, buf[0]);\n\t    }\n#endif\n\t}\n      else if (type == SIMPLE_BRACKET)\n\t{\n\t  int i, ch;\n\t  for (i = 0, ch = 0; i < BITSET_WORDS; ++i)\n\t    {\n\t      int j;\n\t      bitset_word_t w = dfa->nodes[node].opr.sbcset[i];\n\t      for (j = 0; j < BITSET_WORD_BITS; ++j, ++ch)\n\t\tif (w & ((bitset_word_t) 1 << j))\n\t\t  re_set_fastmap (fastmap, icase, ch);\n\t    }\n\t}\n#ifdef RE_ENABLE_I18N\n      else if (type == COMPLEX_BRACKET)\n\t{\n\t  re_charset_t *cset = dfa->nodes[node].opr.mbcset;\n\t  Idx i;\n\n# ifdef _LIBC\n\t  /* See if we have to try all bytes which start multiple collation\n\t     elements.\n\t     e.g. In da_DK, we want to catch 'a' since \"aa\" is a valid\n\t\t  collation element, and don't catch 'b' since 'b' is\n\t\t  the only collation element which starts from 'b' (and\n\t\t  it is caught by SIMPLE_BRACKET).  */\n\t      if (_NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_NRULES) != 0\n\t\t  && (cset->ncoll_syms || cset->nranges))\n\t\t{\n\t\t  const int32_t *table = (const int32_t *)\n\t\t    _NL_CURRENT (LC_COLLATE, _NL_COLLATE_TABLEMB);\n\t\t  for (i = 0; i < SBC_MAX; ++i)\n\t\t    if (table[i] < 0)\n\t\t      re_set_fastmap (fastmap, icase, i);\n\t\t}\n# endif /* _LIBC */\n\n\t  /* See if we have to start the match at all multibyte characters,\n\t     i.e. where we would not find an invalid sequence.  This only\n\t     applies to multibyte character sets; for single byte character\n\t     sets, the SIMPLE_BRACKET again suffices.  */\n\t  if (dfa->mb_cur_max > 1\n\t      && (cset->nchar_classes || cset->non_match || cset->nranges\n# ifdef _LIBC\n\t\t  || cset->nequiv_classes\n# endif /* _LIBC */\n\t\t ))\n\t    {\n\t      unsigned char c = 0;\n\t      do\n\t\t{\n\t\t  mbstate_t mbs;\n\t\t  memset (&mbs, 0, sizeof (mbs));\n\t\t  if (__mbrtowc (NULL, (char *) &c, 1, &mbs) == (size_t) -2)\n\t\t    re_set_fastmap (fastmap, false, (int) c);\n\t\t}\n\t      while (++c != 0);\n\t    }\n\n\t  else\n\t    {\n\t      /* ... Else catch all bytes which can start the mbchars.  */\n\t      for (i = 0; i < cset->nmbchars; ++i)\n\t\t{\n\t\t  char buf[256];\n\t\t  mbstate_t state;\n\t\t  memset (&state, '\\0', sizeof (state));\n\t\t  if (__wcrtomb (buf, cset->mbchars[i], &state) != (size_t) -1)\n\t\t    re_set_fastmap (fastmap, icase, *(unsigned char *) buf);\n\t\t  if ((bufp->syntax & RE_ICASE) && dfa->mb_cur_max > 1)\n\t\t    {\n\t\t      if (__wcrtomb (buf, __towlower (cset->mbchars[i]), &state)\n\t\t\t  != (size_t) -1)\n\t\t\tre_set_fastmap (fastmap, false, *(unsigned char *) buf);\n\t\t    }\n\t\t}\n\t    }\n\t}\n#endif /* RE_ENABLE_I18N */\n      else if (type == OP_PERIOD\n#ifdef RE_ENABLE_I18N\n\t       || type == OP_UTF8_PERIOD\n#endif /* RE_ENABLE_I18N */\n\t       || type == END_OF_RE)\n\t{\n\t  memset (fastmap, '\\1', sizeof (char) * SBC_MAX);\n\t  if (type == END_OF_RE)\n\t    bufp->can_be_null = 1;\n\t  return;\n\t}\n    }\n}",
      "lines": 129,
      "depth": 23,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "regerror": {
      "start_point": [
        545,
        0
      ],
      "end_point": [
        578,
        1
      ],
      "content": "size_t\nregerror (int errcode, const regex_t *_Restrict_ preg,\n\t  char *_Restrict_ errbuf, size_t errbuf_size)\n#endif\n{\n  const char *msg;\n  size_t msg_size;\n\n  if (BE (errcode < 0\n\t  || errcode >= (int) (sizeof (__re_error_msgid_idx)\n\t\t\t       / sizeof (__re_error_msgid_idx[0])), 0))\n    /* Only error codes returned by the rest of the code should be passed\n       to this routine.  If we are given anything else, or if other regex\n       code generates an invalid error code, then the program has a bug.\n       Dump core so we can fix it.  */\n    abort ();\n\n  msg = gettext (__re_error_msgid + __re_error_msgid_idx[errcode]);\n\n  msg_size = strlen (msg) + 1; /* Includes the null.  */\n\n  if (BE (errbuf_size != 0, 1))\n    {\n      size_t cpy_size = msg_size;\n      if (BE (msg_size > errbuf_size, 0))\n\t{\n\t  cpy_size = errbuf_size - 1;\n\t  errbuf[cpy_size] = '\\0';\n\t}\n      memcpy (errbuf, msg, cpy_size);\n    }\n\n  return msg_size;\n}",
      "lines": 34,
      "depth": 15,
      "decorators": [
        "size_t"
      ]
    },
    "free_dfa_content": {
      "start_point": [
        613,
        0
      ],
      "end_point": [
        658,
        1
      ],
      "content": "static void\nfree_dfa_content (re_dfa_t *dfa)\n{\n  Idx i, j;\n\n  if (dfa->nodes)\n    for (i = 0; i < dfa->nodes_len; ++i)\n      free_token (dfa->nodes + i);\n  re_free (dfa->nexts);\n  for (i = 0; i < dfa->nodes_len; ++i)\n    {\n      if (dfa->eclosures != NULL)\n\tre_node_set_free (dfa->eclosures + i);\n      if (dfa->inveclosures != NULL)\n\tre_node_set_free (dfa->inveclosures + i);\n      if (dfa->edests != NULL)\n\tre_node_set_free (dfa->edests + i);\n    }\n  re_free (dfa->edests);\n  re_free (dfa->eclosures);\n  re_free (dfa->inveclosures);\n  re_free (dfa->nodes);\n\n  if (dfa->state_table)\n    for (i = 0; i <= dfa->state_hash_mask; ++i)\n      {\n\tstruct re_state_table_entry *entry = dfa->state_table + i;\n\tfor (j = 0; j < entry->num; ++j)\n\t  {\n\t    re_dfastate_t *state = entry->array[j];\n\t    free_state (state);\n\t  }\n\tre_free (entry->array);\n      }\n  re_free (dfa->state_table);\n#ifdef RE_ENABLE_I18N\n  if (dfa->sb_char != utf8_sb_map)\n    re_free (dfa->sb_char);\n#endif\n  re_free (dfa->subexp_map);\n#ifdef DEBUG\n  re_free (dfa->re_str);\n#endif\n\n  re_free (dfa);\n}",
      "lines": 46,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "free_mem": {
      "start_point": [
        747,
        0
      ],
      "end_point": [
        750,
        1
      ],
      "content": "libc_freeres_fn (free_mem)\n{\n  __regfree (&re_comp_buf);\n}",
      "lines": 4,
      "depth": 7,
      "decorators": null
    },
    "re_compile_internal": {
      "start_point": [
        759,
        0
      ],
      "end_point": [
        855,
        1
      ],
      "content": "static reg_errcode_t\nre_compile_internal (regex_t *preg, const char * pattern, size_t length,\n\t\t     reg_syntax_t syntax)\n{\n  reg_errcode_t err = REG_NOERROR;\n  re_dfa_t *dfa;\n  re_string_t regexp;\n\n  /* Initialize the pattern buffer.  */\n  preg->fastmap_accurate = 0;\n  preg->syntax = syntax;\n  preg->not_bol = preg->not_eol = 0;\n  preg->used = 0;\n  preg->re_nsub = 0;\n  preg->can_be_null = 0;\n  preg->regs_allocated = REGS_UNALLOCATED;\n\n  /* Initialize the dfa.  */\n  dfa = preg->buffer;\n  if (BE (preg->allocated < sizeof (re_dfa_t), 0))\n    {\n      /* If zero allocated, but buffer is non-null, try to realloc\n\t enough space.  This loses if buffer's address is bogus, but\n\t that is the user's responsibility.  If ->buffer is NULL this\n\t is a simple allocation.  */\n      dfa = re_realloc (preg->buffer, re_dfa_t, 1);\n      if (dfa == NULL)\n\treturn REG_ESPACE;\n      preg->allocated = sizeof (re_dfa_t);\n      preg->buffer = dfa;\n    }\n  preg->used = sizeof (re_dfa_t);\n\n  err = init_dfa (dfa, length);\n  if (BE (err == REG_NOERROR && lock_init (dfa->lock) != 0, 0))\n    err = REG_ESPACE;\n  if (BE (err != REG_NOERROR, 0))\n    {\n      free_dfa_content (dfa);\n      preg->buffer = NULL;\n      preg->allocated = 0;\n      return err;\n    }\n#ifdef DEBUG\n  /* Note: length+1 will not overflow since it is checked in init_dfa.  */\n  dfa->re_str = re_malloc (char, length + 1);\n  strncpy (dfa->re_str, pattern, length + 1);\n#endif\n\n  err = re_string_construct (&regexp, pattern, length, preg->translate,\n\t\t\t     (syntax & RE_ICASE) != 0, dfa);\n  if (BE (err != REG_NOERROR, 0))\n    {\n    re_compile_internal_free_return:\n      free_workarea_compile (preg);\n      re_string_destruct (&regexp);\n      lock_fini (dfa->lock);\n      free_dfa_content (dfa);\n      preg->buffer = NULL;\n      preg->allocated = 0;\n      return err;\n    }\n\n  /* Parse the regular expression, and build a structure tree.  */\n  preg->re_nsub = 0;\n  dfa->str_tree = parse (&regexp, preg, syntax, &err);\n  if (BE (dfa->str_tree == NULL, 0))\n    goto re_compile_internal_free_return;\n\n  /* Analyze the tree and create the nfa.  */\n  err = analyze (preg);\n  if (BE (err != REG_NOERROR, 0))\n    goto re_compile_internal_free_return;\n\n#ifdef RE_ENABLE_I18N\n  /* If possible, do searching in single byte encoding to speed things up.  */\n  if (dfa->is_utf8 && !(syntax & RE_ICASE) && preg->translate == NULL)\n    optimize_utf8 (dfa);\n#endif\n\n  /* Then create the initial state of the dfa.  */\n  err = create_initial_state (dfa);\n\n  /* Release work areas.  */\n  free_workarea_compile (preg);\n  re_string_destruct (&regexp);\n\n  if (BE (err != REG_NOERROR, 0))\n    {\n      lock_fini (dfa->lock);\n      free_dfa_content (dfa);\n      preg->buffer = NULL;\n      preg->allocated = 0;\n    }\n\n  return err;\n}",
      "lines": 97,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "init_dfa": {
      "start_point": [
        860,
        0
      ],
      "end_point": [
        954,
        1
      ],
      "content": "static reg_errcode_t\ninit_dfa (re_dfa_t *dfa, size_t pat_len)\n{\n  __re_size_t table_size;\n#ifndef _LIBC\n  const char *codeset_name;\n#endif\n#ifdef RE_ENABLE_I18N\n  size_t max_i18n_object_size = MAX (sizeof (wchar_t), sizeof (wctype_t));\n#else\n  size_t max_i18n_object_size = 0;\n#endif\n  size_t max_object_size =\n    MAX (sizeof (struct re_state_table_entry),\n\t MAX (sizeof (re_token_t),\n\t      MAX (sizeof (re_node_set),\n\t\t   MAX (sizeof (regmatch_t),\n\t\t\tmax_i18n_object_size))));\n\n  memset (dfa, '\\0', sizeof (re_dfa_t));\n\n  /* Force allocation of str_tree_storage the first time.  */\n  dfa->str_tree_storage_idx = BIN_TREE_STORAGE_SIZE;\n\n  /* Avoid overflows.  The extra \"/ 2\" is for the table_size doubling\n     calculation below, and for similar doubling calculations\n     elsewhere.  And it's <= rather than <, because some of the\n     doubling calculations add 1 afterwards.  */\n  if (BE (MIN (IDX_MAX, SIZE_MAX / max_object_size) / 2 <= pat_len, 0))\n    return REG_ESPACE;\n\n  dfa->nodes_alloc = pat_len + 1;\n  dfa->nodes = re_malloc (re_token_t, dfa->nodes_alloc);\n\n  /*  table_size = 2 ^ ceil(log pat_len) */\n  for (table_size = 1; ; table_size <<= 1)\n    if (table_size > pat_len)\n      break;\n\n  dfa->state_table = calloc (sizeof (struct re_state_table_entry), table_size);\n  dfa->state_hash_mask = table_size - 1;\n\n  dfa->mb_cur_max = MB_CUR_MAX;\n#ifdef _LIBC\n  if (dfa->mb_cur_max == 6\n      && strcmp (_NL_CURRENT (LC_CTYPE, _NL_CTYPE_CODESET_NAME), \"UTF-8\") == 0)\n    dfa->is_utf8 = 1;\n  dfa->map_notascii = (_NL_CURRENT_WORD (LC_CTYPE, _NL_CTYPE_MAP_TO_NONASCII)\n\t\t       != 0);\n#else\n  codeset_name = nl_langinfo (CODESET);\n  if ((codeset_name[0] == 'U' || codeset_name[0] == 'u')\n      && (codeset_name[1] == 'T' || codeset_name[1] == 't')\n      && (codeset_name[2] == 'F' || codeset_name[2] == 'f')\n      && strcmp (codeset_name + 3 + (codeset_name[3] == '-'), \"8\") == 0)\n    dfa->is_utf8 = 1;\n\n  /* We check exhaustively in the loop below if this charset is a\n     superset of ASCII.  */\n  dfa->map_notascii = 0;\n#endif\n\n#ifdef RE_ENABLE_I18N\n  if (dfa->mb_cur_max > 1)\n    {\n      if (dfa->is_utf8)\n\tdfa->sb_char = (re_bitset_ptr_t) utf8_sb_map;\n      else\n\t{\n\t  int i, j, ch;\n\n\t  dfa->sb_char = (re_bitset_ptr_t) calloc (sizeof (bitset_t), 1);\n\t  if (BE (dfa->sb_char == NULL, 0))\n\t    return REG_ESPACE;\n\n\t  /* Set the bits corresponding to single byte chars.  */\n\t  for (i = 0, ch = 0; i < BITSET_WORDS; ++i)\n\t    for (j = 0; j < BITSET_WORD_BITS; ++j, ++ch)\n\t      {\n\t\twint_t wch = __btowc (ch);\n\t\tif (wch != WEOF)\n\t\t  dfa->sb_char[i] |= (bitset_word_t) 1 << j;\n# ifndef _LIBC\n\t\tif (isascii (ch) && wch != ch)\n\t\t  dfa->map_notascii = 1;\n# endif\n\t      }\n\t}\n    }\n#endif\n\n  if (BE (dfa->nodes == NULL || dfa->state_table == NULL, 0))\n    return REG_ESPACE;\n  return REG_NOERROR;\n}",
      "lines": 95,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "init_word_char": {
      "start_point": [
        960,
        0
      ],
      "end_point": [
        1004,
        1
      ],
      "content": "static void\ninternal_function\ninit_word_char (re_dfa_t *dfa)\n{\n  int i = 0;\n  int j;\n  int ch = 0;\n  dfa->word_ops_used = 1;\n  if (BE (dfa->map_notascii == 0, 1))\n    {\n      bitset_word_t bits0 = 0x00000000;\n      bitset_word_t bits1 = 0x03ff0000;\n      bitset_word_t bits2 = 0x87fffffe;\n      bitset_word_t bits3 = 0x07fffffe;\n      if (BITSET_WORD_BITS == 64)\n\t{\n\t  dfa->word_char[0] = bits1 << 31 << 1 | bits0;\n\t  dfa->word_char[1] = bits3 << 31 << 1 | bits2;\n\t  i = 2;\n\t}\n      else if (BITSET_WORD_BITS == 32)\n\t{\n\t  dfa->word_char[0] = bits0;\n\t  dfa->word_char[1] = bits1;\n\t  dfa->word_char[2] = bits2;\n\t  dfa->word_char[3] = bits3;\n\t  i = 4;\n\t}\n      else\n        goto general_case;\n      ch = 128;\n\n      if (BE (dfa->is_utf8, 1))\n\t{\n\t  memset (&dfa->word_char[i], '\\0', (SBC_MAX - ch) / 8);\n\t  return;\n\t}\n    }\n\n general_case:\n  for (; i < BITSET_WORDS; ++i)\n    for (j = 0; j < BITSET_WORD_BITS; ++j, ++ch)\n      if (isalnum (ch) || ch == '_')\n\tdfa->word_char[i] |= (bitset_word_t) 1 << j;\n}",
      "lines": 45,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void",
        "internal_function",
        "internal_function"
      ]
    },
    "free_workarea_compile": {
      "start_point": [
        1008,
        0
      ],
      "end_point": [
        1023,
        1
      ],
      "content": "static void\nfree_workarea_compile (regex_t *preg)\n{\n  re_dfa_t *dfa = preg->buffer;\n  bin_tree_storage_t *storage, *next;\n  for (storage = dfa->str_tree_storage; storage; storage = next)\n    {\n      next = storage->next;\n      re_free (storage);\n    }\n  dfa->str_tree_storage = NULL;\n  dfa->str_tree_storage_idx = BIN_TREE_STORAGE_SIZE;\n  dfa->str_tree = NULL;\n  re_free (dfa->org_indices);\n  dfa->org_indices = NULL;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "create_initial_state": {
      "start_point": [
        1027,
        0
      ],
      "end_point": [
        1105,
        1
      ],
      "content": "static reg_errcode_t\ncreate_initial_state (re_dfa_t *dfa)\n{\n  Idx first, i;\n  reg_errcode_t err;\n  re_node_set init_nodes;\n\n  /* Initial states have the epsilon closure of the node which is\n     the first node of the regular expression.  */\n  first = dfa->str_tree->first->node_idx;\n  dfa->init_node = first;\n  err = re_node_set_init_copy (&init_nodes, dfa->eclosures + first);\n  if (BE (err != REG_NOERROR, 0))\n    return err;\n\n  /* The back-references which are in initial states can epsilon transit,\n     since in this case all of the subexpressions can be null.\n     Then we add epsilon closures of the nodes which are the next nodes of\n     the back-references.  */\n  if (dfa->nbackref > 0)\n    for (i = 0; i < init_nodes.nelem; ++i)\n      {\n\tIdx node_idx = init_nodes.elems[i];\n\tre_token_type_t type = dfa->nodes[node_idx].type;\n\n\tIdx clexp_idx;\n\tif (type != OP_BACK_REF)\n\t  continue;\n\tfor (clexp_idx = 0; clexp_idx < init_nodes.nelem; ++clexp_idx)\n\t  {\n\t    re_token_t *clexp_node;\n\t    clexp_node = dfa->nodes + init_nodes.elems[clexp_idx];\n\t    if (clexp_node->type == OP_CLOSE_SUBEXP\n\t\t&& clexp_node->opr.idx == dfa->nodes[node_idx].opr.idx)\n\t      break;\n\t  }\n\tif (clexp_idx == init_nodes.nelem)\n\t  continue;\n\n\tif (type == OP_BACK_REF)\n\t  {\n\t    Idx dest_idx = dfa->edests[node_idx].elems[0];\n\t    if (!re_node_set_contains (&init_nodes, dest_idx))\n\t      {\n\t\treg_errcode_t merge_err\n                  = re_node_set_merge (&init_nodes, dfa->eclosures + dest_idx);\n\t\tif (merge_err != REG_NOERROR)\n\t\t  return merge_err;\n\t\ti = 0;\n\t      }\n\t  }\n      }\n\n  /* It must be the first time to invoke acquire_state.  */\n  dfa->init_state = re_acquire_state_context (&err, dfa, &init_nodes, 0);\n  /* We don't check ERR here, since the initial state must not be NULL.  */\n  if (BE (dfa->init_state == NULL, 0))\n    return err;\n  if (dfa->init_state->has_constraint)\n    {\n      dfa->init_state_word = re_acquire_state_context (&err, dfa, &init_nodes,\n\t\t\t\t\t\t       CONTEXT_WORD);\n      dfa->init_state_nl = re_acquire_state_context (&err, dfa, &init_nodes,\n\t\t\t\t\t\t     CONTEXT_NEWLINE);\n      dfa->init_state_begbuf = re_acquire_state_context (&err, dfa,\n\t\t\t\t\t\t\t &init_nodes,\n\t\t\t\t\t\t\t CONTEXT_NEWLINE\n\t\t\t\t\t\t\t | CONTEXT_BEGBUF);\n      if (BE (dfa->init_state_word == NULL || dfa->init_state_nl == NULL\n\t      || dfa->init_state_begbuf == NULL, 0))\n\treturn err;\n    }\n  else\n    dfa->init_state_word = dfa->init_state_nl\n      = dfa->init_state_begbuf = dfa->init_state;\n\n  re_node_set_free (&init_nodes);\n  return REG_NOERROR;\n}",
      "lines": 79,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "optimize_utf8": {
      "start_point": [
        1112,
        0
      ],
      "end_point": [
        1186,
        1
      ],
      "content": "static void\noptimize_utf8 (re_dfa_t *dfa)\n{\n  Idx node;\n  int i;\n  bool mb_chars = false;\n  bool has_period = false;\n\n  for (node = 0; node < dfa->nodes_len; ++node)\n    switch (dfa->nodes[node].type)\n      {\n      case CHARACTER:\n\tif (dfa->nodes[node].opr.c >= ASCII_CHARS)\n\t  mb_chars = true;\n\tbreak;\n      case ANCHOR:\n\tswitch (dfa->nodes[node].opr.ctx_type)\n\t  {\n\t  case LINE_FIRST:\n\t  case LINE_LAST:\n\t  case BUF_FIRST:\n\t  case BUF_LAST:\n\t    break;\n\t  default:\n\t    /* Word anchors etc. cannot be handled.  It's okay to test\n\t       opr.ctx_type since constraints (for all DFA nodes) are\n\t       created by ORing one or more opr.ctx_type values.  */\n\t    return;\n\t  }\n\tbreak;\n      case OP_PERIOD:\n\thas_period = true;\n\tbreak;\n      case OP_BACK_REF:\n      case OP_ALT:\n      case END_OF_RE:\n      case OP_DUP_ASTERISK:\n      case OP_OPEN_SUBEXP:\n      case OP_CLOSE_SUBEXP:\n\tbreak;\n      case COMPLEX_BRACKET:\n\treturn;\n      case SIMPLE_BRACKET:\n\t/* Just double check.  */\n\t{\n\t  int rshift = (ASCII_CHARS % BITSET_WORD_BITS == 0\n\t\t\t? 0\n\t\t\t: BITSET_WORD_BITS - ASCII_CHARS % BITSET_WORD_BITS);\n\t  for (i = ASCII_CHARS / BITSET_WORD_BITS; i < BITSET_WORDS; ++i)\n\t    {\n\t      if (dfa->nodes[node].opr.sbcset[i] >> rshift != 0)\n\t\treturn;\n\t      rshift = 0;\n\t    }\n\t}\n\tbreak;\n      default:\n\tabort ();\n      }\n\n  if (mb_chars || has_period)\n    for (node = 0; node < dfa->nodes_len; ++node)\n      {\n\tif (dfa->nodes[node].type == CHARACTER\n\t    && dfa->nodes[node].opr.c >= ASCII_CHARS)\n\t  dfa->nodes[node].mb_partial = 0;\n\telse if (dfa->nodes[node].type == OP_PERIOD)\n\t  dfa->nodes[node].type = OP_UTF8_PERIOD;\n      }\n\n  /* The search can be in single byte locale.  */\n  dfa->mb_cur_max = 1;\n  dfa->is_utf8 = 0;\n  dfa->has_mb_node = dfa->nbackref > 0 || has_period;\n}",
      "lines": 75,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "analyze": {
      "start_point": [
        1192,
        0
      ],
      "end_point": [
        1250,
        1
      ],
      "content": "static reg_errcode_t\nanalyze (regex_t *preg)\n{\n  re_dfa_t *dfa = preg->buffer;\n  reg_errcode_t ret;\n\n  /* Allocate arrays.  */\n  dfa->nexts = re_malloc (Idx, dfa->nodes_alloc);\n  dfa->org_indices = re_malloc (Idx, dfa->nodes_alloc);\n  dfa->edests = re_malloc (re_node_set, dfa->nodes_alloc);\n  dfa->eclosures = re_malloc (re_node_set, dfa->nodes_alloc);\n  if (BE (dfa->nexts == NULL || dfa->org_indices == NULL || dfa->edests == NULL\n\t  || dfa->eclosures == NULL, 0))\n    return REG_ESPACE;\n\n  dfa->subexp_map = re_malloc (Idx, preg->re_nsub);\n  if (dfa->subexp_map != NULL)\n    {\n      Idx i;\n      for (i = 0; i < preg->re_nsub; i++)\n\tdfa->subexp_map[i] = i;\n      preorder (dfa->str_tree, optimize_subexps, dfa);\n      for (i = 0; i < preg->re_nsub; i++)\n\tif (dfa->subexp_map[i] != i)\n\t  break;\n      if (i == preg->re_nsub)\n\t{\n\t  free (dfa->subexp_map);\n\t  dfa->subexp_map = NULL;\n\t}\n    }\n\n  ret = postorder (dfa->str_tree, lower_subexps, preg);\n  if (BE (ret != REG_NOERROR, 0))\n    return ret;\n  ret = postorder (dfa->str_tree, calc_first, dfa);\n  if (BE (ret != REG_NOERROR, 0))\n    return ret;\n  preorder (dfa->str_tree, calc_next, dfa);\n  ret = preorder (dfa->str_tree, link_nfa_nodes, dfa);\n  if (BE (ret != REG_NOERROR, 0))\n    return ret;\n  ret = calc_eclosure (dfa);\n  if (BE (ret != REG_NOERROR, 0))\n    return ret;\n\n  /* We only need this during the prune_impossible_nodes pass in regexec.c;\n     skip it if p_i_n will not run, as calc_inveclosure can be quadratic.  */\n  if ((!preg->no_sub && preg->re_nsub > 0 && dfa->has_plural_match)\n      || dfa->nbackref)\n    {\n      dfa->inveclosures = re_malloc (re_node_set, dfa->nodes_len);\n      if (BE (dfa->inveclosures == NULL, 0))\n\treturn REG_ESPACE;\n      ret = calc_inveclosure (dfa);\n    }\n\n  return ret;\n}",
      "lines": 59,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "postorder": {
      "start_point": [
        1255,
        0
      ],
      "end_point": [
        1285,
        1
      ],
      "content": "static reg_errcode_t\npostorder (bin_tree_t *root, reg_errcode_t (fn (void *, bin_tree_t *)),\n\t   void *extra)\n{\n  bin_tree_t *node, *prev;\n\n  for (node = root; ; )\n    {\n      /* Descend down the tree, preferably to the left (or to the right\n\t if that's the only child).  */\n      while (node->left || node->right)\n\tif (node->left)\n\t  node = node->left;\n\telse\n\t  node = node->right;\n\n      do\n\t{\n\t  reg_errcode_t err = fn (extra, node);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return err;\n\t  if (node->parent == NULL)\n\t    return REG_NOERROR;\n\t  prev = node;\n\t  node = node->parent;\n\t}\n      /* Go up while we have a node that is reached from the right.  */\n      while (node->right == prev || node->right == NULL);\n      node = node->right;\n    }\n}",
      "lines": 31,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "preorder": {
      "start_point": [
        1287,
        0
      ],
      "end_point": [
        1315,
        1
      ],
      "content": "static reg_errcode_t\npreorder (bin_tree_t *root, reg_errcode_t (fn (void *, bin_tree_t *)),\n\t  void *extra)\n{\n  bin_tree_t *node;\n\n  for (node = root; ; )\n    {\n      reg_errcode_t err = fn (extra, node);\n      if (BE (err != REG_NOERROR, 0))\n\treturn err;\n\n      /* Go to the left node, or up and to the right.  */\n      if (node->left)\n\tnode = node->left;\n      else\n\t{\n\t  bin_tree_t *prev = NULL;\n\t  while (node->right == prev || node->right == NULL)\n\t    {\n\t      prev = node;\n\t      node = node->parent;\n\t      if (!node)\n\t\treturn REG_NOERROR;\n\t    }\n\t  node = node->right;\n\t}\n    }\n}",
      "lines": 29,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "optimize_subexps": {
      "start_point": [
        1320,
        0
      ],
      "end_point": [
        1347,
        1
      ],
      "content": "static reg_errcode_t\noptimize_subexps (void *extra, bin_tree_t *node)\n{\n  re_dfa_t *dfa = (re_dfa_t *) extra;\n\n  if (node->token.type == OP_BACK_REF && dfa->subexp_map)\n    {\n      int idx = node->token.opr.idx;\n      node->token.opr.idx = dfa->subexp_map[idx];\n      dfa->used_bkref_map |= 1 << node->token.opr.idx;\n    }\n\n  else if (node->token.type == SUBEXP\n\t   && node->left && node->left->token.type == SUBEXP)\n    {\n      Idx other_idx = node->left->token.opr.idx;\n\n      node->left = node->left->left;\n      if (node->left)\n\tnode->left->parent = node;\n\n      dfa->subexp_map[other_idx] = dfa->subexp_map[node->token.opr.idx];\n      if (other_idx < BITSET_WORD_BITS)\n\tdfa->used_bkref_map &= ~((bitset_word_t) 1 << other_idx);\n    }\n\n  return REG_NOERROR;\n}",
      "lines": 28,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "lower_subexps": {
      "start_point": [
        1351,
        0
      ],
      "end_point": [
        1371,
        1
      ],
      "content": "static reg_errcode_t\nlower_subexps (void *extra, bin_tree_t *node)\n{\n  regex_t *preg = (regex_t *) extra;\n  reg_errcode_t err = REG_NOERROR;\n\n  if (node->left && node->left->token.type == SUBEXP)\n    {\n      node->left = lower_subexp (&err, preg, node->left);\n      if (node->left)\n\tnode->left->parent = node;\n    }\n  if (node->right && node->right->token.type == SUBEXP)\n    {\n      node->right = lower_subexp (&err, preg, node->right);\n      if (node->right)\n\tnode->right->parent = node;\n    }\n\n  return err;\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "lower_subexp": {
      "start_point": [
        1373,
        0
      ],
      "end_point": [
        1406,
        1
      ],
      "content": "static bin_tree_t *\nlower_subexp (reg_errcode_t *err, regex_t *preg, bin_tree_t *node)\n{\n  re_dfa_t *dfa = preg->buffer;\n  bin_tree_t *body = node->left;\n  bin_tree_t *op, *cls, *tree1, *tree;\n\n  if (preg->no_sub\n      /* We do not optimize empty subexpressions, because otherwise we may\n\t have bad CONCAT nodes with NULL children.  This is obviously not\n\t very common, so we do not lose much.  An example that triggers\n\t this case is the sed \"script\" /\\(\\)/x.  */\n      && node->left != NULL\n      && (node->token.opr.idx >= BITSET_WORD_BITS\n\t  || !(dfa->used_bkref_map\n\t       & ((bitset_word_t) 1 << node->token.opr.idx))))\n    return node->left;\n\n  /* Convert the SUBEXP node to the concatenation of an\n     OP_OPEN_SUBEXP, the contents, and an OP_CLOSE_SUBEXP.  */\n  op = create_tree (dfa, NULL, NULL, OP_OPEN_SUBEXP);\n  cls = create_tree (dfa, NULL, NULL, OP_CLOSE_SUBEXP);\n  tree1 = body ? create_tree (dfa, body, cls, CONCAT) : cls;\n  tree = create_tree (dfa, op, tree1, CONCAT);\n  if (BE (tree == NULL || tree1 == NULL || op == NULL || cls == NULL, 0))\n    {\n      *err = REG_ESPACE;\n      return NULL;\n    }\n\n  op->token.opr.idx = cls->token.opr.idx = node->token.opr.idx;\n  op->token.opt_subexp = cls->token.opt_subexp = node->token.opt_subexp;\n  return tree;\n}",
      "lines": 34,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\nlower_subexp (reg_errcode_t *err, regex_t *preg, bin_tree_t *node)",
        "*"
      ]
    },
    "calc_first": {
      "start_point": [
        1410,
        0
      ],
      "end_point": [
        1429,
        1
      ],
      "content": "static reg_errcode_t\ncalc_first (void *extra, bin_tree_t *node)\n{\n  re_dfa_t *dfa = (re_dfa_t *) extra;\n  if (node->token.type == CONCAT)\n    {\n      node->first = node->left->first;\n      node->node_idx = node->left->node_idx;\n    }\n  else\n    {\n      node->first = node;\n      node->node_idx = re_dfa_add_node (dfa, node->token);\n      if (BE (node->node_idx == REG_MISSING, 0))\n\treturn REG_ESPACE;\n      if (node->token.type == ANCHOR)\n\tdfa->nodes[node->node_idx].constraint = node->token.opr.ctx_type;\n    }\n  return REG_NOERROR;\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "calc_next": {
      "start_point": [
        1432,
        0
      ],
      "end_point": [
        1452,
        1
      ],
      "content": "static reg_errcode_t\ncalc_next (void *extra, bin_tree_t *node)\n{\n  switch (node->token.type)\n    {\n    case OP_DUP_ASTERISK:\n      node->left->next = node;\n      break;\n    case CONCAT:\n      node->left->next = node->right->first;\n      node->right->next = node->next;\n      break;\n    default:\n      if (node->left)\n\tnode->left->next = node->next;\n      if (node->right)\n\tnode->right->next = node->next;\n      break;\n    }\n  return REG_NOERROR;\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "link_nfa_nodes": {
      "start_point": [
        1455,
        0
      ],
      "end_point": [
        1509,
        1
      ],
      "content": "static reg_errcode_t\nlink_nfa_nodes (void *extra, bin_tree_t *node)\n{\n  re_dfa_t *dfa = (re_dfa_t *) extra;\n  Idx idx = node->node_idx;\n  reg_errcode_t err = REG_NOERROR;\n\n  switch (node->token.type)\n    {\n    case CONCAT:\n      break;\n\n    case END_OF_RE:\n      assert (node->next == NULL);\n      break;\n\n    case OP_DUP_ASTERISK:\n    case OP_ALT:\n      {\n\tIdx left, right;\n\tdfa->has_plural_match = 1;\n\tif (node->left != NULL)\n\t  left = node->left->first->node_idx;\n\telse\n\t  left = node->next->node_idx;\n\tif (node->right != NULL)\n\t  right = node->right->first->node_idx;\n\telse\n\t  right = node->next->node_idx;\n\tassert (REG_VALID_INDEX (left));\n\tassert (REG_VALID_INDEX (right));\n\terr = re_node_set_init_2 (dfa->edests + idx, left, right);\n      }\n      break;\n\n    case ANCHOR:\n    case OP_OPEN_SUBEXP:\n    case OP_CLOSE_SUBEXP:\n      err = re_node_set_init_1 (dfa->edests + idx, node->next->node_idx);\n      break;\n\n    case OP_BACK_REF:\n      dfa->nexts[idx] = node->next->node_idx;\n      if (node->token.type == OP_BACK_REF)\n\terr = re_node_set_init_1 (dfa->edests + idx, dfa->nexts[idx]);\n      break;\n\n    default:\n      assert (!IS_EPSILON_NODE (node->token.type));\n      dfa->nexts[idx] = node->next->node_idx;\n      break;\n    }\n\n  return err;\n}",
      "lines": 55,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "duplicate_node_closure": {
      "start_point": [
        1515,
        0
      ],
      "end_point": [
        1618,
        1
      ],
      "content": "static reg_errcode_t\ninternal_function\nduplicate_node_closure (re_dfa_t *dfa, Idx top_org_node, Idx top_clone_node,\n\t\t\tIdx root_node, unsigned int init_constraint)\n{\n  Idx org_node, clone_node;\n  bool ok;\n  unsigned int constraint = init_constraint;\n  for (org_node = top_org_node, clone_node = top_clone_node;;)\n    {\n      Idx org_dest, clone_dest;\n      if (dfa->nodes[org_node].type == OP_BACK_REF)\n\t{\n\t  /* If the back reference epsilon-transit, its destination must\n\t     also have the constraint.  Then duplicate the epsilon closure\n\t     of the destination of the back reference, and store it in\n\t     edests of the back reference.  */\n\t  org_dest = dfa->nexts[org_node];\n\t  re_node_set_empty (dfa->edests + clone_node);\n\t  clone_dest = duplicate_node (dfa, org_dest, constraint);\n\t  if (BE (clone_dest == REG_MISSING, 0))\n\t    return REG_ESPACE;\n\t  dfa->nexts[clone_node] = dfa->nexts[org_node];\n\t  ok = re_node_set_insert (dfa->edests + clone_node, clone_dest);\n\t  if (BE (! ok, 0))\n\t    return REG_ESPACE;\n\t}\n      else if (dfa->edests[org_node].nelem == 0)\n\t{\n\t  /* In case of the node can't epsilon-transit, don't duplicate the\n\t     destination and store the original destination as the\n\t     destination of the node.  */\n\t  dfa->nexts[clone_node] = dfa->nexts[org_node];\n\t  break;\n\t}\n      else if (dfa->edests[org_node].nelem == 1)\n\t{\n\t  /* In case of the node can epsilon-transit, and it has only one\n\t     destination.  */\n\t  org_dest = dfa->edests[org_node].elems[0];\n\t  re_node_set_empty (dfa->edests + clone_node);\n\t  /* If the node is root_node itself, it means the epsilon closure\n\t     has a loop.  Then tie it to the destination of the root_node.  */\n\t  if (org_node == root_node && clone_node != org_node)\n\t    {\n\t      ok = re_node_set_insert (dfa->edests + clone_node, org_dest);\n\t      if (BE (! ok, 0))\n\t        return REG_ESPACE;\n\t      break;\n\t    }\n\t  /* In case the node has another constraint, append it.  */\n\t  constraint |= dfa->nodes[org_node].constraint;\n\t  clone_dest = duplicate_node (dfa, org_dest, constraint);\n\t  if (BE (clone_dest == REG_MISSING, 0))\n\t    return REG_ESPACE;\n\t  ok = re_node_set_insert (dfa->edests + clone_node, clone_dest);\n\t  if (BE (! ok, 0))\n\t    return REG_ESPACE;\n\t}\n      else /* dfa->edests[org_node].nelem == 2 */\n\t{\n\t  /* In case of the node can epsilon-transit, and it has two\n\t     destinations. In the bin_tree_t and DFA, that's '|' and '*'.   */\n\t  org_dest = dfa->edests[org_node].elems[0];\n\t  re_node_set_empty (dfa->edests + clone_node);\n\t  /* Search for a duplicated node which satisfies the constraint.  */\n\t  clone_dest = search_duplicated_node (dfa, org_dest, constraint);\n\t  if (clone_dest == REG_MISSING)\n\t    {\n\t      /* There is no such duplicated node, create a new one.  */\n\t      reg_errcode_t err;\n\t      clone_dest = duplicate_node (dfa, org_dest, constraint);\n\t      if (BE (clone_dest == REG_MISSING, 0))\n\t\treturn REG_ESPACE;\n\t      ok = re_node_set_insert (dfa->edests + clone_node, clone_dest);\n\t      if (BE (! ok, 0))\n\t\treturn REG_ESPACE;\n\t      err = duplicate_node_closure (dfa, org_dest, clone_dest,\n\t\t\t\t\t    root_node, constraint);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\treturn err;\n\t    }\n\t  else\n\t    {\n\t      /* There is a duplicated node which satisfies the constraint,\n\t\t use it to avoid infinite loop.  */\n\t      ok = re_node_set_insert (dfa->edests + clone_node, clone_dest);\n\t      if (BE (! ok, 0))\n\t\treturn REG_ESPACE;\n\t    }\n\n\t  org_dest = dfa->edests[org_node].elems[1];\n\t  clone_dest = duplicate_node (dfa, org_dest, constraint);\n\t  if (BE (clone_dest == REG_MISSING, 0))\n\t    return REG_ESPACE;\n\t  ok = re_node_set_insert (dfa->edests + clone_node, clone_dest);\n\t  if (BE (! ok, 0))\n\t    return REG_ESPACE;\n\t}\n      org_node = org_dest;\n      clone_node = clone_dest;\n    }\n  return REG_NOERROR;\n}",
      "lines": 104,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "internal_function",
        "internal_function"
      ]
    },
    "search_duplicated_node": {
      "start_point": [
        1623,
        0
      ],
      "end_point": [
        1635,
        1
      ],
      "content": "static Idx\nsearch_duplicated_node (const re_dfa_t *dfa, Idx org_node,\n\t\t\tunsigned int constraint)\n{\n  Idx idx;\n  for (idx = dfa->nodes_len - 1; dfa->nodes[idx].duplicated && idx > 0; --idx)\n    {\n      if (org_node == dfa->org_indices[idx]\n\t  && constraint == dfa->nodes[idx].constraint)\n\treturn idx; /* Found.  */\n    }\n  return REG_MISSING; /* Not found.  */\n}",
      "lines": 13,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "Idx"
      ]
    },
    "duplicate_node": {
      "start_point": [
        1641,
        0
      ],
      "end_point": [
        1655,
        1
      ],
      "content": "static Idx\nduplicate_node (re_dfa_t *dfa, Idx org_idx, unsigned int constraint)\n{\n  Idx dup_idx = re_dfa_add_node (dfa, dfa->nodes[org_idx]);\n  if (BE (dup_idx != REG_MISSING, 1))\n    {\n      dfa->nodes[dup_idx].constraint = constraint;\n      dfa->nodes[dup_idx].constraint |= dfa->nodes[org_idx].constraint;\n      dfa->nodes[dup_idx].duplicated = 1;\n\n      /* Store the index of the original node.  */\n      dfa->org_indices[dup_idx] = org_idx;\n    }\n  return dup_idx;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "Idx"
      ]
    },
    "calc_inveclosure": {
      "start_point": [
        1657,
        0
      ],
      "end_point": [
        1677,
        1
      ],
      "content": "static reg_errcode_t\ncalc_inveclosure (re_dfa_t *dfa)\n{\n  Idx src, idx;\n  bool ok;\n  for (idx = 0; idx < dfa->nodes_len; ++idx)\n    re_node_set_init_empty (dfa->inveclosures + idx);\n\n  for (src = 0; src < dfa->nodes_len; ++src)\n    {\n      Idx *elems = dfa->eclosures[src].elems;\n      for (idx = 0; idx < dfa->eclosures[src].nelem; ++idx)\n\t{\n\t  ok = re_node_set_insert_last (dfa->inveclosures + elems[idx], src);\n\t  if (BE (! ok, 0))\n\t    return REG_ESPACE;\n\t}\n    }\n\n  return REG_NOERROR;\n}",
      "lines": 21,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "calc_eclosure": {
      "start_point": [
        1681,
        0
      ],
      "end_point": [
        1722,
        1
      ],
      "content": "static reg_errcode_t\ncalc_eclosure (re_dfa_t *dfa)\n{\n  Idx node_idx;\n  bool incomplete;\n#ifdef DEBUG\n  assert (dfa->nodes_len > 0);\n#endif\n  incomplete = false;\n  /* For each nodes, calculate epsilon closure.  */\n  for (node_idx = 0; ; ++node_idx)\n    {\n      reg_errcode_t err;\n      re_node_set eclosure_elem;\n      if (node_idx == dfa->nodes_len)\n\t{\n\t  if (!incomplete)\n\t    break;\n\t  incomplete = false;\n\t  node_idx = 0;\n\t}\n\n#ifdef DEBUG\n      assert (dfa->eclosures[node_idx].nelem != REG_MISSING);\n#endif\n\n      /* If we have already calculated, skip it.  */\n      if (dfa->eclosures[node_idx].nelem != 0)\n\tcontinue;\n      /* Calculate epsilon closure of 'node_idx'.  */\n      err = calc_eclosure_iter (&eclosure_elem, dfa, node_idx, true);\n      if (BE (err != REG_NOERROR, 0))\n\treturn err;\n\n      if (dfa->eclosures[node_idx].nelem == 0)\n\t{\n\t  incomplete = true;\n\t  re_node_set_free (&eclosure_elem);\n\t}\n    }\n  return REG_NOERROR;\n}",
      "lines": 42,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "calc_eclosure_iter": {
      "start_point": [
        1726,
        0
      ],
      "end_point": [
        1800,
        1
      ],
      "content": "static reg_errcode_t\ncalc_eclosure_iter (re_node_set *new_set, re_dfa_t *dfa, Idx node, bool root)\n{\n  reg_errcode_t err;\n  Idx i;\n  re_node_set eclosure;\n  bool ok;\n  bool incomplete = false;\n  err = re_node_set_alloc (&eclosure, dfa->edests[node].nelem + 1);\n  if (BE (err != REG_NOERROR, 0))\n    return err;\n\n  /* This indicates that we are calculating this node now.\n     We reference this value to avoid infinite loop.  */\n  dfa->eclosures[node].nelem = REG_MISSING;\n\n  /* If the current node has constraints, duplicate all nodes\n     since they must inherit the constraints.  */\n  if (dfa->nodes[node].constraint\n      && dfa->edests[node].nelem\n      && !dfa->nodes[dfa->edests[node].elems[0]].duplicated)\n    {\n      err = duplicate_node_closure (dfa, node, node, node,\n\t\t\t\t    dfa->nodes[node].constraint);\n      if (BE (err != REG_NOERROR, 0))\n\treturn err;\n    }\n\n  /* Expand each epsilon destination nodes.  */\n  if (IS_EPSILON_NODE(dfa->nodes[node].type))\n    for (i = 0; i < dfa->edests[node].nelem; ++i)\n      {\n\tre_node_set eclosure_elem;\n\tIdx edest = dfa->edests[node].elems[i];\n\t/* If calculating the epsilon closure of 'edest' is in progress,\n\t   return intermediate result.  */\n\tif (dfa->eclosures[edest].nelem == REG_MISSING)\n\t  {\n\t    incomplete = true;\n\t    continue;\n\t  }\n\t/* If we haven't calculated the epsilon closure of 'edest' yet,\n\t   calculate now. Otherwise use calculated epsilon closure.  */\n\tif (dfa->eclosures[edest].nelem == 0)\n\t  {\n\t    err = calc_eclosure_iter (&eclosure_elem, dfa, edest, false);\n\t    if (BE (err != REG_NOERROR, 0))\n\t      return err;\n\t  }\n\telse\n\t  eclosure_elem = dfa->eclosures[edest];\n\t/* Merge the epsilon closure of 'edest'.  */\n\terr = re_node_set_merge (&eclosure, &eclosure_elem);\n\tif (BE (err != REG_NOERROR, 0))\n\t  return err;\n\t/* If the epsilon closure of 'edest' is incomplete,\n\t   the epsilon closure of this node is also incomplete.  */\n\tif (dfa->eclosures[edest].nelem == 0)\n\t  {\n\t    incomplete = true;\n\t    re_node_set_free (&eclosure_elem);\n\t  }\n      }\n\n  /* An epsilon closure includes itself.  */\n  ok = re_node_set_insert (&eclosure, node);\n  if (BE (! ok, 0))\n    return REG_ESPACE;\n  if (incomplete && !root)\n    dfa->eclosures[node].nelem = 0;\n  else\n    dfa->eclosures[node] = eclosure;\n  *new_set = eclosure;\n  return REG_NOERROR;\n}",
      "lines": 75,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "fetch_token": {
      "start_point": [
        1807,
        0
      ],
      "end_point": [
        1812,
        1
      ],
      "content": "static void\ninternal_function\nfetch_token (re_token_t *result, re_string_t *input, reg_syntax_t syntax)\n{\n  re_string_skip_bytes (input, peek_token (result, input, syntax));\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void",
        "internal_function",
        "internal_function"
      ]
    },
    "internal_function": {
      "start_point": [
        1817,
        0
      ],
      "end_point": [
        2051,
        1
      ],
      "content": "static int\ninternal_function\npeek_token (re_token_t *token, re_string_t *input, reg_syntax_t syntax)\n{\n  unsigned char c;\n\n  if (re_string_eoi (input))\n    {\n      token->type = END_OF_RE;\n      return 0;\n    }\n\n  c = re_string_peek_byte (input, 0);\n  token->opr.c = c;\n\n  token->word_char = 0;\n#ifdef RE_ENABLE_I18N\n  token->mb_partial = 0;\n  if (input->mb_cur_max > 1 &&\n      !re_string_first_byte (input, re_string_cur_idx (input)))\n    {\n      token->type = CHARACTER;\n      token->mb_partial = 1;\n      return 1;\n    }\n#endif\n  if (c == '\\\\')\n    {\n      unsigned char c2;\n      if (re_string_cur_idx (input) + 1 >= re_string_length (input))\n\t{\n\t  token->type = BACK_SLASH;\n\t  return 1;\n\t}\n\n      c2 = re_string_peek_byte_case (input, 1);\n      token->opr.c = c2;\n      token->type = CHARACTER;\n#ifdef RE_ENABLE_I18N\n      if (input->mb_cur_max > 1)\n\t{\n\t  wint_t wc = re_string_wchar_at (input,\n\t\t\t\t\t  re_string_cur_idx (input) + 1);\n\t  token->word_char = IS_WIDE_WORD_CHAR (wc) != 0;\n\t}\n      else\n#endif\n\ttoken->word_char = IS_WORD_CHAR (c2) != 0;\n\n      switch (c2)\n\t{\n\tcase '|':\n\t  if (!(syntax & RE_LIMITED_OPS) && !(syntax & RE_NO_BK_VBAR))\n\t    token->type = OP_ALT;\n\t  break;\n\tcase '1': case '2': case '3': case '4': case '5':\n\tcase '6': case '7': case '8': case '9':\n\t  if (!(syntax & RE_NO_BK_REFS))\n\t    {\n\t      token->type = OP_BACK_REF;\n\t      token->opr.idx = c2 - '1';\n\t    }\n\t  break;\n\tcase '<':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    {\n\t      token->type = ANCHOR;\n\t      token->opr.ctx_type = WORD_FIRST;\n\t    }\n\t  break;\n\tcase '>':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    {\n\t      token->type = ANCHOR;\n\t      token->opr.ctx_type = WORD_LAST;\n\t    }\n\t  break;\n\tcase 'b':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    {\n\t      token->type = ANCHOR;\n\t      token->opr.ctx_type = WORD_DELIM;\n\t    }\n\t  break;\n\tcase 'B':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    {\n\t      token->type = ANCHOR;\n\t      token->opr.ctx_type = NOT_WORD_DELIM;\n\t    }\n\t  break;\n\tcase 'w':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    token->type = OP_WORD;\n\t  break;\n\tcase 'W':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    token->type = OP_NOTWORD;\n\t  break;\n\tcase 's':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    token->type = OP_SPACE;\n\t  break;\n\tcase 'S':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    token->type = OP_NOTSPACE;\n\t  break;\n\tcase '`':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    {\n\t      token->type = ANCHOR;\n\t      token->opr.ctx_type = BUF_FIRST;\n\t    }\n\t  break;\n\tcase '\\'':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    {\n\t      token->type = ANCHOR;\n\t      token->opr.ctx_type = BUF_LAST;\n\t    }\n\t  break;\n\tcase '(':\n\t  if (!(syntax & RE_NO_BK_PARENS))\n\t    token->type = OP_OPEN_SUBEXP;\n\t  break;\n\tcase ')':\n\t  if (!(syntax & RE_NO_BK_PARENS))\n\t    token->type = OP_CLOSE_SUBEXP;\n\t  break;\n\tcase '+':\n\t  if (!(syntax & RE_LIMITED_OPS) && (syntax & RE_BK_PLUS_QM))\n\t    token->type = OP_DUP_PLUS;\n\t  break;\n\tcase '?':\n\t  if (!(syntax & RE_LIMITED_OPS) && (syntax & RE_BK_PLUS_QM))\n\t    token->type = OP_DUP_QUESTION;\n\t  break;\n\tcase '{':\n\t  if ((syntax & RE_INTERVALS) && (!(syntax & RE_NO_BK_BRACES)))\n\t    token->type = OP_OPEN_DUP_NUM;\n\t  break;\n\tcase '}':\n\t  if ((syntax & RE_INTERVALS) && (!(syntax & RE_NO_BK_BRACES)))\n\t    token->type = OP_CLOSE_DUP_NUM;\n\t  break;\n\tdefault:\n\t  break;\n\t}\n      return 2;\n    }\n\n  token->type = CHARACTER;\n#ifdef RE_ENABLE_I18N\n  if (input->mb_cur_max > 1)\n    {\n      wint_t wc = re_string_wchar_at (input, re_string_cur_idx (input));\n      token->word_char = IS_WIDE_WORD_CHAR (wc) != 0;\n    }\n  else\n#endif\n    token->word_char = IS_WORD_CHAR (token->opr.c);\n\n  switch (c)\n    {\n    case '\\n':\n      if (syntax & RE_NEWLINE_ALT)\n\ttoken->type = OP_ALT;\n      break;\n    case '|':\n      if (!(syntax & RE_LIMITED_OPS) && (syntax & RE_NO_BK_VBAR))\n\ttoken->type = OP_ALT;\n      break;\n    case '*':\n      token->type = OP_DUP_ASTERISK;\n      break;\n    case '+':\n      if (!(syntax & RE_LIMITED_OPS) && !(syntax & RE_BK_PLUS_QM))\n\ttoken->type = OP_DUP_PLUS;\n      break;\n    case '?':\n      if (!(syntax & RE_LIMITED_OPS) && !(syntax & RE_BK_PLUS_QM))\n\ttoken->type = OP_DUP_QUESTION;\n      break;\n    case '{':\n      if ((syntax & RE_INTERVALS) && (syntax & RE_NO_BK_BRACES))\n\ttoken->type = OP_OPEN_DUP_NUM;\n      break;\n    case '}':\n      if ((syntax & RE_INTERVALS) && (syntax & RE_NO_BK_BRACES))\n\ttoken->type = OP_CLOSE_DUP_NUM;\n      break;\n    case '(':\n      if (syntax & RE_NO_BK_PARENS)\n\ttoken->type = OP_OPEN_SUBEXP;\n      break;\n    case ')':\n      if (syntax & RE_NO_BK_PARENS)\n\ttoken->type = OP_CLOSE_SUBEXP;\n      break;\n    case '[':\n      token->type = OP_OPEN_BRACKET;\n      break;\n    case '.':\n      token->type = OP_PERIOD;\n      break;\n    case '^':\n      if (!(syntax & (RE_CONTEXT_INDEP_ANCHORS | RE_CARET_ANCHORS_HERE)) &&\n\t  re_string_cur_idx (input) != 0)\n\t{\n\t  char prev = re_string_peek_byte (input, -1);\n\t  if (!(syntax & RE_NEWLINE_ALT) || prev != '\\n')\n\t    break;\n\t}\n      token->type = ANCHOR;\n      token->opr.ctx_type = LINE_FIRST;\n      break;\n    case '$':\n      if (!(syntax & RE_CONTEXT_INDEP_ANCHORS) &&\n\t  re_string_cur_idx (input) + 1 != re_string_length (input))\n\t{\n\t  re_token_t next;\n\t  re_string_skip_bytes (input, 1);\n\t  peek_token (&next, input, syntax);\n\t  re_string_skip_bytes (input, -1);\n\t  if (next.type != OP_ALT && next.type != OP_CLOSE_SUBEXP)\n\t    break;\n\t}\n      token->type = ANCHOR;\n      token->opr.ctx_type = LINE_LAST;\n      break;\n    default:\n      break;\n    }\n  return 1;\n}",
      "lines": 235,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "peek_token_bracket": {
      "start_point": [
        2056,
        0
      ],
      "end_point": [
        2137,
        1
      ],
      "content": "static int\ninternal_function\npeek_token_bracket (re_token_t *token, re_string_t *input, reg_syntax_t syntax)\n{\n  unsigned char c;\n  if (re_string_eoi (input))\n    {\n      token->type = END_OF_RE;\n      return 0;\n    }\n  c = re_string_peek_byte (input, 0);\n  token->opr.c = c;\n\n#ifdef RE_ENABLE_I18N\n  if (input->mb_cur_max > 1 &&\n      !re_string_first_byte (input, re_string_cur_idx (input)))\n    {\n      token->type = CHARACTER;\n      return 1;\n    }\n#endif /* RE_ENABLE_I18N */\n\n  if (c == '\\\\' && (syntax & RE_BACKSLASH_ESCAPE_IN_LISTS)\n      && re_string_cur_idx (input) + 1 < re_string_length (input))\n    {\n      /* In this case, '\\' escape a character.  */\n      unsigned char c2;\n      re_string_skip_bytes (input, 1);\n      c2 = re_string_peek_byte (input, 0);\n      token->opr.c = c2;\n      token->type = CHARACTER;\n      return 1;\n    }\n  if (c == '[') /* '[' is a special char in a bracket exps.  */\n    {\n      unsigned char c2;\n      int token_len;\n      if (re_string_cur_idx (input) + 1 < re_string_length (input))\n\tc2 = re_string_peek_byte (input, 1);\n      else\n\tc2 = 0;\n      token->opr.c = c2;\n      token_len = 2;\n      switch (c2)\n\t{\n\tcase '.':\n\t  token->type = OP_OPEN_COLL_ELEM;\n\t  break;\n\tcase '=':\n\t  token->type = OP_OPEN_EQUIV_CLASS;\n\t  break;\n\tcase ':':\n\t  if (syntax & RE_CHAR_CLASSES)\n\t    {\n\t      token->type = OP_OPEN_CHAR_CLASS;\n\t      break;\n\t    }\n\t  /* else fall through.  */\n\tdefault:\n\t  token->type = CHARACTER;\n\t  token->opr.c = c;\n\t  token_len = 1;\n\t  break;\n\t}\n      return token_len;\n    }\n  switch (c)\n    {\n    case '-':\n      token->type = OP_CHARSET_RANGE;\n      break;\n    case ']':\n      token->type = OP_CLOSE_BRACKET;\n      break;\n    case '^':\n      token->type = OP_NON_MATCH_LIST;\n      break;\n    default:\n      token->type = CHARACTER;\n    }\n  return 1;\n}",
      "lines": 82,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int",
        "internal_function",
        "internal_function"
      ]
    },
    "parse": {
      "start_point": [
        2153,
        0
      ],
      "end_point": [
        2176,
        1
      ],
      "content": "static bin_tree_t *\nparse (re_string_t *regexp, regex_t *preg, reg_syntax_t syntax,\n       reg_errcode_t *err)\n{\n  re_dfa_t *dfa = preg->buffer;\n  bin_tree_t *tree, *eor, *root;\n  re_token_t current_token;\n  dfa->syntax = syntax;\n  fetch_token (&current_token, regexp, syntax | RE_CARET_ANCHORS_HERE);\n  tree = parse_reg_exp (regexp, preg, &current_token, syntax, 0, err);\n  if (BE (*err != REG_NOERROR && tree == NULL, 0))\n    return NULL;\n  eor = create_tree (dfa, NULL, NULL, END_OF_RE);\n  if (tree != NULL)\n    root = create_tree (dfa, tree, eor, CONCAT);\n  else\n    root = eor;\n  if (BE (eor == NULL || root == NULL, 0))\n    {\n      *err = REG_ESPACE;\n      return NULL;\n    }\n  return root;\n}",
      "lines": 24,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\nparse (re_string_t *regexp, regex_t *preg, reg_syntax_t syntax,\n       reg_errcode_t *err)",
        "*"
      ]
    },
    "parse_reg_exp": {
      "start_point": [
        2187,
        0
      ],
      "end_point": [
        2225,
        1
      ],
      "content": "static bin_tree_t *\nparse_reg_exp (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t       reg_syntax_t syntax, Idx nest, reg_errcode_t *err)\n{\n  re_dfa_t *dfa = preg->buffer;\n  bin_tree_t *tree, *branch = NULL;\n  bitset_word_t initial_bkref_map = dfa->completed_bkref_map;\n  tree = parse_branch (regexp, preg, token, syntax, nest, err);\n  if (BE (*err != REG_NOERROR && tree == NULL, 0))\n    return NULL;\n\n  while (token->type == OP_ALT)\n    {\n      fetch_token (token, regexp, syntax | RE_CARET_ANCHORS_HERE);\n      if (token->type != OP_ALT && token->type != END_OF_RE\n\t  && (nest == 0 || token->type != OP_CLOSE_SUBEXP))\n\t{\n\t  bitset_word_t accumulated_bkref_map = dfa->completed_bkref_map;\n\t  dfa->completed_bkref_map = initial_bkref_map;\n\t  branch = parse_branch (regexp, preg, token, syntax, nest, err);\n\t  if (BE (*err != REG_NOERROR && branch == NULL, 0))\n\t    {\n\t      if (tree != NULL)\n\t\tpostorder (tree, free_tree, NULL);\n\t      return NULL;\n\t    }\n\t  dfa->completed_bkref_map |= accumulated_bkref_map;\n\t}\n      else\n\tbranch = NULL;\n      tree = create_tree (dfa, tree, branch, OP_ALT);\n      if (BE (tree == NULL, 0))\n\t{\n\t  *err = REG_ESPACE;\n\t  return NULL;\n\t}\n    }\n  return tree;\n}",
      "lines": 39,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\nparse_reg_exp (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t       reg_syntax_t syntax, Idx nest, reg_errcode_t *err)",
        "*"
      ]
    },
    "parse_branch": {
      "start_point": [
        2236,
        0
      ],
      "end_point": [
        2273,
        1
      ],
      "content": "static bin_tree_t *\nparse_branch (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t      reg_syntax_t syntax, Idx nest, reg_errcode_t *err)\n{\n  bin_tree_t *tree, *expr;\n  re_dfa_t *dfa = preg->buffer;\n  tree = parse_expression (regexp, preg, token, syntax, nest, err);\n  if (BE (*err != REG_NOERROR && tree == NULL, 0))\n    return NULL;\n\n  while (token->type != OP_ALT && token->type != END_OF_RE\n\t && (nest == 0 || token->type != OP_CLOSE_SUBEXP))\n    {\n      expr = parse_expression (regexp, preg, token, syntax, nest, err);\n      if (BE (*err != REG_NOERROR && expr == NULL, 0))\n\t{\n\t  if (tree != NULL)\n\t    postorder (tree, free_tree, NULL);\n\t  return NULL;\n\t}\n      if (tree != NULL && expr != NULL)\n\t{\n\t  bin_tree_t *newtree = create_tree (dfa, tree, expr, CONCAT);\n\t  if (newtree == NULL)\n\t    {\n\t      postorder (expr, free_tree, NULL);\n\t      postorder (tree, free_tree, NULL);\n\t      *err = REG_ESPACE;\n\t      return NULL;\n\t    }\n\t  tree = newtree;\n\t}\n      else if (tree == NULL)\n\ttree = expr;\n      /* Otherwise expr == NULL, we don't need to create new tree.  */\n    }\n  return tree;\n}",
      "lines": 38,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\nparse_branch (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t      reg_syntax_t syntax, Idx nest, reg_errcode_t *err)",
        "*"
      ]
    },
    "parse_expression": {
      "start_point": [
        2281,
        0
      ],
      "end_point": [
        2496,
        1
      ],
      "content": "static bin_tree_t *\nparse_expression (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t\t  reg_syntax_t syntax, Idx nest, reg_errcode_t *err)\n{\n  re_dfa_t *dfa = preg->buffer;\n  bin_tree_t *tree;\n  switch (token->type)\n    {\n    case CHARACTER:\n      tree = create_token_tree (dfa, NULL, NULL, token);\n      if (BE (tree == NULL, 0))\n\t{\n\t  *err = REG_ESPACE;\n\t  return NULL;\n\t}\n#ifdef RE_ENABLE_I18N\n      if (dfa->mb_cur_max > 1)\n\t{\n\t  while (!re_string_eoi (regexp)\n\t\t && !re_string_first_byte (regexp, re_string_cur_idx (regexp)))\n\t    {\n\t      bin_tree_t *mbc_remain;\n\t      fetch_token (token, regexp, syntax);\n\t      mbc_remain = create_token_tree (dfa, NULL, NULL, token);\n\t      tree = create_tree (dfa, tree, mbc_remain, CONCAT);\n\t      if (BE (mbc_remain == NULL || tree == NULL, 0))\n\t\t{\n\t\t  *err = REG_ESPACE;\n\t\t  return NULL;\n\t\t}\n\t    }\n\t}\n#endif\n      break;\n    case OP_OPEN_SUBEXP:\n      tree = parse_sub_exp (regexp, preg, token, syntax, nest + 1, err);\n      if (BE (*err != REG_NOERROR && tree == NULL, 0))\n\treturn NULL;\n      break;\n    case OP_OPEN_BRACKET:\n      tree = parse_bracket_exp (regexp, dfa, token, syntax, err);\n      if (BE (*err != REG_NOERROR && tree == NULL, 0))\n\treturn NULL;\n      break;\n    case OP_BACK_REF:\n      if (!BE (dfa->completed_bkref_map & (1 << token->opr.idx), 1))\n\t{\n\t  *err = REG_ESUBREG;\n\t  return NULL;\n\t}\n      dfa->used_bkref_map |= 1 << token->opr.idx;\n      tree = create_token_tree (dfa, NULL, NULL, token);\n      if (BE (tree == NULL, 0))\n\t{\n\t  *err = REG_ESPACE;\n\t  return NULL;\n\t}\n      ++dfa->nbackref;\n      dfa->has_mb_node = 1;\n      break;\n    case OP_OPEN_DUP_NUM:\n      if (syntax & RE_CONTEXT_INVALID_DUP)\n\t{\n\t  *err = REG_BADRPT;\n\t  return NULL;\n\t}\n      /* FALLTHROUGH */\n    case OP_DUP_ASTERISK:\n    case OP_DUP_PLUS:\n    case OP_DUP_QUESTION:\n      if (syntax & RE_CONTEXT_INVALID_OPS)\n\t{\n\t  *err = REG_BADRPT;\n\t  return NULL;\n\t}\n      else if (syntax & RE_CONTEXT_INDEP_OPS)\n\t{\n\t  fetch_token (token, regexp, syntax);\n\t  return parse_expression (regexp, preg, token, syntax, nest, err);\n\t}\n      /* else fall through  */\n    case OP_CLOSE_SUBEXP:\n      if ((token->type == OP_CLOSE_SUBEXP) &&\n\t  !(syntax & RE_UNMATCHED_RIGHT_PAREN_ORD))\n\t{\n\t  *err = REG_ERPAREN;\n\t  return NULL;\n\t}\n      /* else fall through  */\n    case OP_CLOSE_DUP_NUM:\n      /* We treat it as a normal character.  */\n\n      /* Then we can these characters as normal characters.  */\n      token->type = CHARACTER;\n      /* mb_partial and word_char bits should be initialized already\n\t by peek_token.  */\n      tree = create_token_tree (dfa, NULL, NULL, token);\n      if (BE (tree == NULL, 0))\n\t{\n\t  *err = REG_ESPACE;\n\t  return NULL;\n\t}\n      break;\n    case ANCHOR:\n      if ((token->opr.ctx_type\n\t   & (WORD_DELIM | NOT_WORD_DELIM | WORD_FIRST | WORD_LAST))\n\t  && dfa->word_ops_used == 0)\n\tinit_word_char (dfa);\n      if (token->opr.ctx_type == WORD_DELIM\n\t  || token->opr.ctx_type == NOT_WORD_DELIM)\n\t{\n\t  bin_tree_t *tree_first, *tree_last;\n\t  if (token->opr.ctx_type == WORD_DELIM)\n\t    {\n\t      token->opr.ctx_type = WORD_FIRST;\n\t      tree_first = create_token_tree (dfa, NULL, NULL, token);\n\t      token->opr.ctx_type = WORD_LAST;\n\t    }\n\t  else\n\t    {\n\t      token->opr.ctx_type = INSIDE_WORD;\n\t      tree_first = create_token_tree (dfa, NULL, NULL, token);\n\t      token->opr.ctx_type = INSIDE_NOTWORD;\n\t    }\n\t  tree_last = create_token_tree (dfa, NULL, NULL, token);\n\t  tree = create_tree (dfa, tree_first, tree_last, OP_ALT);\n\t  if (BE (tree_first == NULL || tree_last == NULL || tree == NULL, 0))\n\t    {\n\t      *err = REG_ESPACE;\n\t      return NULL;\n\t    }\n\t}\n      else\n\t{\n\t  tree = create_token_tree (dfa, NULL, NULL, token);\n\t  if (BE (tree == NULL, 0))\n\t    {\n\t      *err = REG_ESPACE;\n\t      return NULL;\n\t    }\n\t}\n      /* We must return here, since ANCHORs can't be followed\n\t by repetition operators.\n\t eg. RE\"^*\" is invalid or \"<ANCHOR(^)><CHAR(*)>\",\n\t     it must not be \"<ANCHOR(^)><REPEAT(*)>\".  */\n      fetch_token (token, regexp, syntax);\n      return tree;\n    case OP_PERIOD:\n      tree = create_token_tree (dfa, NULL, NULL, token);\n      if (BE (tree == NULL, 0))\n\t{\n\t  *err = REG_ESPACE;\n\t  return NULL;\n\t}\n      if (dfa->mb_cur_max > 1)\n\tdfa->has_mb_node = 1;\n      break;\n    case OP_WORD:\n    case OP_NOTWORD:\n      tree = build_charclass_op (dfa, regexp->trans,\n\t\t\t\t \"alnum\",\n\t\t\t\t \"_\",\n\t\t\t\t token->type == OP_NOTWORD, err);\n      if (BE (*err != REG_NOERROR && tree == NULL, 0))\n\treturn NULL;\n      break;\n    case OP_SPACE:\n    case OP_NOTSPACE:\n      tree = build_charclass_op (dfa, regexp->trans,\n\t\t\t\t \"space\",\n\t\t\t\t \"\",\n\t\t\t\t token->type == OP_NOTSPACE, err);\n      if (BE (*err != REG_NOERROR && tree == NULL, 0))\n\treturn NULL;\n      break;\n    case OP_ALT:\n    case END_OF_RE:\n      return NULL;\n    case BACK_SLASH:\n      *err = REG_EESCAPE;\n      return NULL;\n    default:\n      /* Must not happen?  */\n#ifdef DEBUG\n      assert (0);\n#endif\n      return NULL;\n    }\n  fetch_token (token, regexp, syntax);\n\n  while (token->type == OP_DUP_ASTERISK || token->type == OP_DUP_PLUS\n\t || token->type == OP_DUP_QUESTION || token->type == OP_OPEN_DUP_NUM)\n    {\n      bin_tree_t *dup_tree = parse_dup_op (tree, regexp, dfa, token,\n\t\t\t\t\t   syntax, err);\n      if (BE (*err != REG_NOERROR && dup_tree == NULL, 0))\n\t{\n\t  if (tree != NULL)\n\t    postorder (tree, free_tree, NULL);\n\t  return NULL;\n\t}\n      tree = dup_tree;\n      /* In BRE consecutive duplications are not allowed.  */\n      if ((syntax & RE_CONTEXT_INVALID_DUP)\n\t  && (token->type == OP_DUP_ASTERISK\n\t      || token->type == OP_OPEN_DUP_NUM))\n\t{\n\t  if (tree != NULL)\n\t    postorder (tree, free_tree, NULL);\n\t  *err = REG_BADRPT;\n\t  return NULL;\n\t}\n    }\n\n  return tree;\n}",
      "lines": 216,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\nparse_expression (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t\t  reg_syntax_t syntax, Idx nest, reg_errcode_t *err)",
        "*"
      ]
    },
    "parse_sub_exp": {
      "start_point": [
        2505,
        0
      ],
      "end_point": [
        2543,
        1
      ],
      "content": "static bin_tree_t *\nparse_sub_exp (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t       reg_syntax_t syntax, Idx nest, reg_errcode_t *err)\n{\n  re_dfa_t *dfa = preg->buffer;\n  bin_tree_t *tree;\n  size_t cur_nsub;\n  cur_nsub = preg->re_nsub++;\n\n  fetch_token (token, regexp, syntax | RE_CARET_ANCHORS_HERE);\n\n  /* The subexpression may be a null string.  */\n  if (token->type == OP_CLOSE_SUBEXP)\n    tree = NULL;\n  else\n    {\n      tree = parse_reg_exp (regexp, preg, token, syntax, nest, err);\n      if (BE (*err == REG_NOERROR && token->type != OP_CLOSE_SUBEXP, 0))\n\t{\n\t  if (tree != NULL)\n\t    postorder (tree, free_tree, NULL);\n\t  *err = REG_EPAREN;\n\t}\n      if (BE (*err != REG_NOERROR, 0))\n\treturn NULL;\n    }\n\n  if (cur_nsub <= '9' - '1')\n    dfa->completed_bkref_map |= 1 << cur_nsub;\n\n  tree = create_tree (dfa, tree, NULL, SUBEXP);\n  if (BE (tree == NULL, 0))\n    {\n      *err = REG_ESPACE;\n      return NULL;\n    }\n  tree->token.opr.idx = cur_nsub;\n  return tree;\n}",
      "lines": 39,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\nparse_sub_exp (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t       reg_syntax_t syntax, Idx nest, reg_errcode_t *err)",
        "*"
      ]
    },
    "parse_dup_op": {
      "start_point": [
        2547,
        0
      ],
      "end_point": [
        2691,
        1
      ],
      "content": "static bin_tree_t *\nparse_dup_op (bin_tree_t *elem, re_string_t *regexp, re_dfa_t *dfa,\n\t      re_token_t *token, reg_syntax_t syntax, reg_errcode_t *err)\n{\n  bin_tree_t *tree = NULL, *old_tree = NULL;\n  Idx i, start, end, start_idx = re_string_cur_idx (regexp);\n  re_token_t start_token = *token;\n\n  if (token->type == OP_OPEN_DUP_NUM)\n    {\n      end = 0;\n      start = fetch_number (regexp, token, syntax);\n      if (start == REG_MISSING)\n\t{\n\t  if (token->type == CHARACTER && token->opr.c == ',')\n\t    start = 0; /* We treat \"{,m}\" as \"{0,m}\".  */\n\t  else\n\t    {\n\t      *err = REG_BADBR; /* <re>{} is invalid.  */\n\t      return NULL;\n\t    }\n\t}\n      if (BE (start != REG_ERROR, 1))\n\t{\n\t  /* We treat \"{n}\" as \"{n,n}\".  */\n\t  end = ((token->type == OP_CLOSE_DUP_NUM) ? start\n\t\t : ((token->type == CHARACTER && token->opr.c == ',')\n\t\t    ? fetch_number (regexp, token, syntax) : REG_ERROR));\n\t}\n      if (BE (start == REG_ERROR || end == REG_ERROR, 0))\n\t{\n\t  /* Invalid sequence.  */\n\t  if (BE (!(syntax & RE_INVALID_INTERVAL_ORD), 0))\n\t    {\n\t      if (token->type == END_OF_RE)\n\t\t*err = REG_EBRACE;\n\t      else\n\t\t*err = REG_BADBR;\n\n\t      return NULL;\n\t    }\n\n\t  /* If the syntax bit is set, rollback.  */\n\t  re_string_set_index (regexp, start_idx);\n\t  *token = start_token;\n\t  token->type = CHARACTER;\n\t  /* mb_partial and word_char bits should be already initialized by\n\t     peek_token.  */\n\t  return elem;\n\t}\n\n      if (BE ((end != REG_MISSING && start > end)\n\t      || token->type != OP_CLOSE_DUP_NUM, 0))\n\t{\n\t  /* First number greater than second.  */\n\t  *err = REG_BADBR;\n\t  return NULL;\n\t}\n\n      if (BE (RE_DUP_MAX < (end == REG_MISSING ? start : end), 0))\n\t{\n\t  *err = REG_ESIZE;\n\t  return NULL;\n\t}\n    }\n  else\n    {\n      start = (token->type == OP_DUP_PLUS) ? 1 : 0;\n      end = (token->type == OP_DUP_QUESTION) ? 1 : REG_MISSING;\n    }\n\n  fetch_token (token, regexp, syntax);\n\n  if (BE (elem == NULL, 0))\n    return NULL;\n  if (BE (start == 0 && end == 0, 0))\n    {\n      postorder (elem, free_tree, NULL);\n      return NULL;\n    }\n\n  /* Extract \"<re>{n,m}\" to \"<re><re>...<re><re>{0,<m-n>}\".  */\n  if (BE (start > 0, 0))\n    {\n      tree = elem;\n      for (i = 2; i <= start; ++i)\n\t{\n\t  elem = duplicate_tree (elem, dfa);\n\t  tree = create_tree (dfa, tree, elem, CONCAT);\n\t  if (BE (elem == NULL || tree == NULL, 0))\n\t    goto parse_dup_op_espace;\n\t}\n\n      if (start == end)\n\treturn tree;\n\n      /* Duplicate ELEM before it is marked optional.  */\n      elem = duplicate_tree (elem, dfa);\n      if (BE (elem == NULL, 0))\n        goto parse_dup_op_espace;\n      old_tree = tree;\n    }\n  else\n    old_tree = NULL;\n\n  if (elem->token.type == SUBEXP)\n    {\n      uintptr_t subidx = elem->token.opr.idx;\n      postorder (elem, mark_opt_subexp, (void *) subidx);\n    }\n\n  tree = create_tree (dfa, elem, NULL,\n\t\t      (end == REG_MISSING ? OP_DUP_ASTERISK : OP_ALT));\n  if (BE (tree == NULL, 0))\n    goto parse_dup_op_espace;\n\n/* From gnulib's \"intprops.h\":\n   True if the arithmetic type T is signed.  */\n#define TYPE_SIGNED(t) (! ((t) 0 < (t) -1))\n\n  /* This loop is actually executed only when end != REG_MISSING,\n     to rewrite <re>{0,n} as (<re>(<re>...<re>?)?)?...  We have\n     already created the start+1-th copy.  */\n  if (TYPE_SIGNED (Idx) || end != REG_MISSING)\n    for (i = start + 2; i <= end; ++i)\n      {\n\telem = duplicate_tree (elem, dfa);\n\ttree = create_tree (dfa, tree, elem, CONCAT);\n\tif (BE (elem == NULL || tree == NULL, 0))\n\t  goto parse_dup_op_espace;\n\n\ttree = create_tree (dfa, tree, NULL, OP_ALT);\n\tif (BE (tree == NULL, 0))\n\t  goto parse_dup_op_espace;\n      }\n\n  if (old_tree)\n    tree = create_tree (dfa, old_tree, tree, CONCAT);\n\n  return tree;\n\n parse_dup_op_espace:\n  *err = REG_ESPACE;\n  return NULL;\n}",
      "lines": 145,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\nparse_dup_op (bin_tree_t *elem, re_string_t *regexp, re_dfa_t *dfa,\n\t      re_token_t *token, reg_syntax_t syntax, reg_errcode_t *err)",
        "*"
      ]
    },
    "start_elem": {
      "start_point": [
        2718,
        23
      ],
      "end_point": [
        2817,
        1
      ],
      "content": "bracket_elem_t *end_elem)\n# endif /* not RE_ENABLE_I18N */\n{\n  unsigned int start_ch, end_ch;\n  /* Equivalence Classes and Character Classes can't be a range start/end.  */\n  if (BE (start_elem->type == EQUIV_CLASS || start_elem->type == CHAR_CLASS\n\t  || end_elem->type == EQUIV_CLASS || end_elem->type == CHAR_CLASS,\n\t  0))\n    return REG_ERANGE;\n\n  /* We can handle no multi character collating elements without libc\n     support.  */\n  if (BE ((start_elem->type == COLL_SYM\n\t   && strlen ((char *) start_elem->opr.name) > 1)\n\t  || (end_elem->type == COLL_SYM\n\t      && strlen ((char *) end_elem->opr.name) > 1), 0))\n    return REG_ECOLLATE;\n\n# ifdef RE_ENABLE_I18N\n  {\n    wchar_t wc;\n    wint_t start_wc;\n    wint_t end_wc;\n\n    start_ch = ((start_elem->type == SB_CHAR) ? start_elem->opr.ch\n\t\t: ((start_elem->type == COLL_SYM) ? start_elem->opr.name[0]\n\t\t   : 0));\n    end_ch = ((end_elem->type == SB_CHAR) ? end_elem->opr.ch\n\t      : ((end_elem->type == COLL_SYM) ? end_elem->opr.name[0]\n\t\t : 0));\n    start_wc = ((start_elem->type == SB_CHAR || start_elem->type == COLL_SYM)\n\t\t? __btowc (start_ch) : start_elem->opr.wch);\n    end_wc = ((end_elem->type == SB_CHAR || end_elem->type == COLL_SYM)\n\t      ? __btowc (end_ch) : end_elem->opr.wch);\n    if (start_wc == WEOF || end_wc == WEOF)\n      return REG_ECOLLATE;\n    else if (BE ((syntax & RE_NO_EMPTY_RANGES) && start_wc > end_wc, 0))\n      return REG_ERANGE;\n\n    /* Got valid collation sequence values, add them as a new entry.\n       However, for !_LIBC we have no collation elements: if the\n       character set is single byte, the single byte character set\n       that we build below suffices.  parse_bracket_exp passes\n       no MBCSET if dfa->mb_cur_max == 1.  */\n    if (mbcset)\n      {\n\t/* Check the space of the arrays.  */\n\tif (BE (*range_alloc == mbcset->nranges, 0))\n\t  {\n\t    /* There is not enough space, need realloc.  */\n\t    wchar_t *new_array_start, *new_array_end;\n\t    Idx new_nranges;\n\n\t    /* +1 in case of mbcset->nranges is 0.  */\n\t    new_nranges = 2 * mbcset->nranges + 1;\n\t    /* Use realloc since mbcset->range_starts and mbcset->range_ends\n\t       are NULL if *range_alloc == 0.  */\n\t    new_array_start = re_realloc (mbcset->range_starts, wchar_t,\n\t\t\t\t\t  new_nranges);\n\t    new_array_end = re_realloc (mbcset->range_ends, wchar_t,\n\t\t\t\t\tnew_nranges);\n\n\t    if (BE (new_array_start == NULL || new_array_end == NULL, 0))\n\t      return REG_ESPACE;\n\n\t    mbcset->range_starts = new_array_start;\n\t    mbcset->range_ends = new_array_end;\n\t    *range_alloc = new_nranges;\n\t  }\n\n\tmbcset->range_starts[mbcset->nranges] = start_wc;\n\tmbcset->range_ends[mbcset->nranges++] = end_wc;\n      }\n\n    /* Build the table for single byte characters.  */\n    for (wc = 0; wc < SBC_MAX; ++wc)\n      {\n\tif (start_wc <= wc && wc <= end_wc)\n\t  bitset_set (sbcset, wc);\n      }\n  }\n# else /* not RE_ENABLE_I18N */\n  {\n    unsigned int ch;\n    start_ch = ((start_elem->type == SB_CHAR ) ? start_elem->opr.ch\n\t\t: ((start_elem->type == COLL_SYM) ? start_elem->opr.name[0]\n\t\t   : 0));\n    end_ch = ((end_elem->type == SB_CHAR ) ? end_elem->opr.ch\n\t      : ((end_elem->type == COLL_SYM) ? end_elem->opr.name[0]\n\t\t : 0));\n    if (start_ch > end_ch)\n      return REG_ERANGE;\n    /* Build the table for single byte characters.  */\n    for (ch = 0; ch < SBC_MAX; ++ch)\n      if (start_ch <= ch  && ch <= end_ch)\n\tbitset_set (sbcset, ch);\n  }\n# endif /* not RE_ENABLE_I18N */\n  return REG_NOERROR;\n}",
      "lines": 100,
      "depth": 16,
      "decorators": null
    },
    "parse_bracket_exp": {
      "start_point": [
        2850,
        0
      ],
      "end_point": [
        3395,
        1
      ],
      "content": "static bin_tree_t *\nparse_bracket_exp (re_string_t *regexp, re_dfa_t *dfa, re_token_t *token,\n\t\t   reg_syntax_t syntax, reg_errcode_t *err)\n{\n#ifdef _LIBC\n  const unsigned char *collseqmb;\n  const char *collseqwc;\n  uint32_t nrules;\n  int32_t table_size;\n  const int32_t *symb_table;\n  const unsigned char *extra;\n\n  /* Local function for parse_bracket_exp used in _LIBC environment.\n     Seek the collating symbol entry corresponding to NAME.\n     Return the index of the symbol in the SYMB_TABLE,\n     or -1 if not found.  */\n\n  auto inline int32_t\n  __attribute__ ((always_inline))\n  seek_collating_symbol_entry (const unsigned char *name, size_t name_len)\n    {\n      int32_t elem;\n\n      for (elem = 0; elem < table_size; elem++)\n\tif (symb_table[2 * elem] != 0)\n\t  {\n\t    int32_t idx = symb_table[2 * elem + 1];\n\t    /* Skip the name of collating element name.  */\n\t    idx += 1 + extra[idx];\n\t    if (/* Compare the length of the name.  */\n\t\tname_len == extra[idx]\n\t\t/* Compare the name.  */\n\t\t&& memcmp (name, &extra[idx + 1], name_len) == 0)\n\t      /* Yep, this is the entry.  */\n\t      return elem;\n\t  }\n      return -1;\n    }\n\n  /* Local function for parse_bracket_exp used in _LIBC environment.\n     Look up the collation sequence value of BR_ELEM.\n     Return the value if succeeded, UINT_MAX otherwise.  */\n\n  auto inline unsigned int\n  __attribute__ ((always_inline))\n  lookup_collation_sequence_value (bracket_elem_t *br_elem)\n    {\n      if (br_elem->type == SB_CHAR)\n\t{\n\t  /*\n\t  if (MB_CUR_MAX == 1)\n\t  */\n\t  if (nrules == 0)\n\t    return collseqmb[br_elem->opr.ch];\n\t  else\n\t    {\n\t      wint_t wc = __btowc (br_elem->opr.ch);\n\t      return __collseq_table_lookup (collseqwc, wc);\n\t    }\n\t}\n      else if (br_elem->type == MB_CHAR)\n\t{\n\t  if (nrules != 0)\n\t    return __collseq_table_lookup (collseqwc, br_elem->opr.wch);\n\t}\n      else if (br_elem->type == COLL_SYM)\n\t{\n\t  size_t sym_name_len = strlen ((char *) br_elem->opr.name);\n\t  if (nrules != 0)\n\t    {\n\t      int32_t elem, idx;\n\t      elem = seek_collating_symbol_entry (br_elem->opr.name,\n\t\t\t\t\t\t  sym_name_len);\n\t      if (elem != -1)\n\t\t{\n\t\t  /* We found the entry.  */\n\t\t  idx = symb_table[2 * elem + 1];\n\t\t  /* Skip the name of collating element name.  */\n\t\t  idx += 1 + extra[idx];\n\t\t  /* Skip the byte sequence of the collating element.  */\n\t\t  idx += 1 + extra[idx];\n\t\t  /* Adjust for the alignment.  */\n\t\t  idx = (idx + 3) & ~3;\n\t\t  /* Skip the multibyte collation sequence value.  */\n\t\t  idx += sizeof (unsigned int);\n\t\t  /* Skip the wide char sequence of the collating element.  */\n\t\t  idx += sizeof (unsigned int) *\n\t\t    (1 + *(unsigned int *) (extra + idx));\n\t\t  /* Return the collation sequence value.  */\n\t\t  return *(unsigned int *) (extra + idx);\n\t\t}\n\t      else if (sym_name_len == 1)\n\t\t{\n\t\t  /* No valid character.  Match it as a single byte\n\t\t     character.  */\n\t\t  return collseqmb[br_elem->opr.name[0]];\n\t\t}\n\t    }\n\t  else if (sym_name_len == 1)\n\t    return collseqmb[br_elem->opr.name[0]];\n\t}\n      return UINT_MAX;\n    }\n\n  /* Local function for parse_bracket_exp used in _LIBC environment.\n     Build the range expression which starts from START_ELEM, and ends\n     at END_ELEM.  The result are written to MBCSET and SBCSET.\n     RANGE_ALLOC is the allocated size of mbcset->range_starts, and\n     mbcset->range_ends, is a pointer argument since we may\n     update it.  */\n\n  auto inline reg_errcode_t\n  __attribute__ ((always_inline))\n  build_range_exp (bitset_t sbcset, re_charset_t *mbcset, int *range_alloc,\n\t\t   bracket_elem_t *start_elem, bracket_elem_t *end_elem)\n    {\n      unsigned int ch;\n      uint32_t start_collseq;\n      uint32_t end_collseq;\n\n      /* Equivalence Classes and Character Classes can't be a range\n\t start/end.  */\n      if (BE (start_elem->type == EQUIV_CLASS || start_elem->type == CHAR_CLASS\n\t      || end_elem->type == EQUIV_CLASS || end_elem->type == CHAR_CLASS,\n\t      0))\n\treturn REG_ERANGE;\n\n      /* FIXME: Implement rational ranges here, too.  */\n      start_collseq = lookup_collation_sequence_value (start_elem);\n      end_collseq = lookup_collation_sequence_value (end_elem);\n      /* Check start/end collation sequence values.  */\n      if (BE (start_collseq == UINT_MAX || end_collseq == UINT_MAX, 0))\n\treturn REG_ECOLLATE;\n      if (BE ((syntax & RE_NO_EMPTY_RANGES) && start_collseq > end_collseq, 0))\n\treturn REG_ERANGE;\n\n      /* Got valid collation sequence values, add them as a new entry.\n\t However, if we have no collation elements, and the character set\n\t is single byte, the single byte character set that we\n\t build below suffices. */\n      if (nrules > 0 || dfa->mb_cur_max > 1)\n\t{\n\t  /* Check the space of the arrays.  */\n\t  if (BE (*range_alloc == mbcset->nranges, 0))\n\t    {\n\t      /* There is not enough space, need realloc.  */\n\t      uint32_t *new_array_start;\n\t      uint32_t *new_array_end;\n\t      Idx new_nranges;\n\n\t      /* +1 in case of mbcset->nranges is 0.  */\n\t      new_nranges = 2 * mbcset->nranges + 1;\n\t      new_array_start = re_realloc (mbcset->range_starts, uint32_t,\n\t\t\t\t\t    new_nranges);\n\t      new_array_end = re_realloc (mbcset->range_ends, uint32_t,\n\t\t\t\t\t  new_nranges);\n\n\t      if (BE (new_array_start == NULL || new_array_end == NULL, 0))\n\t\treturn REG_ESPACE;\n\n\t      mbcset->range_starts = new_array_start;\n\t      mbcset->range_ends = new_array_end;\n\t      *range_alloc = new_nranges;\n\t    }\n\n\t  mbcset->range_starts[mbcset->nranges] = start_collseq;\n\t  mbcset->range_ends[mbcset->nranges++] = end_collseq;\n\t}\n\n      /* Build the table for single byte characters.  */\n      for (ch = 0; ch < SBC_MAX; ch++)\n\t{\n\t  uint32_t ch_collseq;\n\t  /*\n\t  if (MB_CUR_MAX == 1)\n\t  */\n\t  if (nrules == 0)\n\t    ch_collseq = collseqmb[ch];\n\t  else\n\t    ch_collseq = __collseq_table_lookup (collseqwc, __btowc (ch));\n\t  if (start_collseq <= ch_collseq && ch_collseq <= end_collseq)\n\t    bitset_set (sbcset, ch);\n\t}\n      return REG_NOERROR;\n    }\n\n  /* Local function for parse_bracket_exp used in _LIBC environment.\n     Build the collating element which is represented by NAME.\n     The result are written to MBCSET and SBCSET.\n     COLL_SYM_ALLOC is the allocated size of mbcset->coll_sym, is a\n     pointer argument since we may update it.  */\n\n  auto inline reg_errcode_t\n  __attribute__ ((always_inline))\n  build_collating_symbol (bitset_t sbcset, re_charset_t *mbcset,\n\t\t\t  Idx *coll_sym_alloc, const unsigned char *name)\n    {\n      int32_t elem, idx;\n      size_t name_len = strlen ((const char *) name);\n      if (nrules != 0)\n\t{\n\t  elem = seek_collating_symbol_entry (name, name_len);\n\t  if (elem != -1)\n\t    {\n\t      /* We found the entry.  */\n\t      idx = symb_table[2 * elem + 1];\n\t      /* Skip the name of collating element name.  */\n\t      idx += 1 + extra[idx];\n\t    }\n\t  else if (name_len == 1)\n\t    {\n\t      /* No valid character, treat it as a normal\n\t\t character.  */\n\t      bitset_set (sbcset, name[0]);\n\t      return REG_NOERROR;\n\t    }\n\t  else\n\t    return REG_ECOLLATE;\n\n\t  /* Got valid collation sequence, add it as a new entry.  */\n\t  /* Check the space of the arrays.  */\n\t  if (BE (*coll_sym_alloc == mbcset->ncoll_syms, 0))\n\t    {\n\t      /* Not enough, realloc it.  */\n\t      /* +1 in case of mbcset->ncoll_syms is 0.  */\n\t      Idx new_coll_sym_alloc = 2 * mbcset->ncoll_syms + 1;\n\t      /* Use realloc since mbcset->coll_syms is NULL\n\t\t if *alloc == 0.  */\n\t      int32_t *new_coll_syms = re_realloc (mbcset->coll_syms, int32_t,\n\t\t\t\t\t\t   new_coll_sym_alloc);\n\t      if (BE (new_coll_syms == NULL, 0))\n\t\treturn REG_ESPACE;\n\t      mbcset->coll_syms = new_coll_syms;\n\t      *coll_sym_alloc = new_coll_sym_alloc;\n\t    }\n\t  mbcset->coll_syms[mbcset->ncoll_syms++] = idx;\n\t  return REG_NOERROR;\n\t}\n      else\n\t{\n\t  if (BE (name_len != 1, 0))\n\t    return REG_ECOLLATE;\n\t  else\n\t    {\n\t      bitset_set (sbcset, name[0]);\n\t      return REG_NOERROR;\n\t    }\n\t}\n    }\n#endif\n\n  re_token_t br_token;\n  re_bitset_ptr_t sbcset;\n#ifdef RE_ENABLE_I18N\n  re_charset_t *mbcset;\n  Idx coll_sym_alloc = 0, range_alloc = 0, mbchar_alloc = 0;\n  Idx equiv_class_alloc = 0, char_class_alloc = 0;\n#endif /* not RE_ENABLE_I18N */\n  bool non_match = false;\n  bin_tree_t *work_tree;\n  int token_len;\n  bool first_round = true;\n#ifdef _LIBC\n  collseqmb = (const unsigned char *)\n    _NL_CURRENT (LC_COLLATE, _NL_COLLATE_COLLSEQMB);\n  nrules = _NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_NRULES);\n  if (nrules)\n    {\n      /*\n      if (MB_CUR_MAX > 1)\n      */\n      collseqwc = _NL_CURRENT (LC_COLLATE, _NL_COLLATE_COLLSEQWC);\n      table_size = _NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_SYMB_HASH_SIZEMB);\n      symb_table = (const int32_t *) _NL_CURRENT (LC_COLLATE,\n\t\t\t\t\t\t  _NL_COLLATE_SYMB_TABLEMB);\n      extra = (const unsigned char *) _NL_CURRENT (LC_COLLATE,\n\t\t\t\t\t\t   _NL_COLLATE_SYMB_EXTRAMB);\n    }\n#endif\n  sbcset = (re_bitset_ptr_t) calloc (sizeof (bitset_t), 1);\n#ifdef RE_ENABLE_I18N\n  mbcset = (re_charset_t *) calloc (sizeof (re_charset_t), 1);\n#endif /* RE_ENABLE_I18N */\n#ifdef RE_ENABLE_I18N\n  if (BE (sbcset == NULL || mbcset == NULL, 0))\n#else\n  if (BE (sbcset == NULL, 0))\n#endif /* RE_ENABLE_I18N */\n    {\n      re_free (sbcset);\n#ifdef RE_ENABLE_I18N\n      re_free (mbcset);\n#endif\n      *err = REG_ESPACE;\n      return NULL;\n    }\n\n  token_len = peek_token_bracket (token, regexp, syntax);\n  if (BE (token->type == END_OF_RE, 0))\n    {\n      *err = REG_BADPAT;\n      goto parse_bracket_exp_free_return;\n    }\n  if (token->type == OP_NON_MATCH_LIST)\n    {\n#ifdef RE_ENABLE_I18N\n      mbcset->non_match = 1;\n#endif /* not RE_ENABLE_I18N */\n      non_match = true;\n      if (syntax & RE_HAT_LISTS_NOT_NEWLINE)\n\tbitset_set (sbcset, '\\n');\n      re_string_skip_bytes (regexp, token_len); /* Skip a token.  */\n      token_len = peek_token_bracket (token, regexp, syntax);\n      if (BE (token->type == END_OF_RE, 0))\n\t{\n\t  *err = REG_BADPAT;\n\t  goto parse_bracket_exp_free_return;\n\t}\n    }\n\n  /* We treat the first ']' as a normal character.  */\n  if (token->type == OP_CLOSE_BRACKET)\n    token->type = CHARACTER;\n\n  while (1)\n    {\n      bracket_elem_t start_elem, end_elem;\n      unsigned char start_name_buf[BRACKET_NAME_BUF_SIZE];\n      unsigned char end_name_buf[BRACKET_NAME_BUF_SIZE];\n      reg_errcode_t ret;\n      int token_len2 = 0;\n      bool is_range_exp = false;\n      re_token_t token2;\n\n      start_elem.opr.name = start_name_buf;\n      start_elem.type = COLL_SYM;\n      ret = parse_bracket_element (&start_elem, regexp, token, token_len, dfa,\n\t\t\t\t   syntax, first_round);\n      if (BE (ret != REG_NOERROR, 0))\n\t{\n\t  *err = ret;\n\t  goto parse_bracket_exp_free_return;\n\t}\n      first_round = false;\n\n      /* Get information about the next token.  We need it in any case.  */\n      token_len = peek_token_bracket (token, regexp, syntax);\n\n      /* Do not check for ranges if we know they are not allowed.  */\n      if (start_elem.type != CHAR_CLASS && start_elem.type != EQUIV_CLASS)\n\t{\n\t  if (BE (token->type == END_OF_RE, 0))\n\t    {\n\t      *err = REG_EBRACK;\n\t      goto parse_bracket_exp_free_return;\n\t    }\n\t  if (token->type == OP_CHARSET_RANGE)\n\t    {\n\t      re_string_skip_bytes (regexp, token_len); /* Skip '-'.  */\n\t      token_len2 = peek_token_bracket (&token2, regexp, syntax);\n\t      if (BE (token2.type == END_OF_RE, 0))\n\t\t{\n\t\t  *err = REG_EBRACK;\n\t\t  goto parse_bracket_exp_free_return;\n\t\t}\n\t      if (token2.type == OP_CLOSE_BRACKET)\n\t\t{\n\t\t  /* We treat the last '-' as a normal character.  */\n\t\t  re_string_skip_bytes (regexp, -token_len);\n\t\t  token->type = CHARACTER;\n\t\t}\n\t      else\n\t\tis_range_exp = true;\n\t    }\n\t}\n\n      if (is_range_exp == true)\n\t{\n\t  end_elem.opr.name = end_name_buf;\n\t  end_elem.type = COLL_SYM;\n\t  ret = parse_bracket_element (&end_elem, regexp, &token2, token_len2,\n\t\t\t\t       dfa, syntax, true);\n\t  if (BE (ret != REG_NOERROR, 0))\n\t    {\n\t      *err = ret;\n\t      goto parse_bracket_exp_free_return;\n\t    }\n\n\t  token_len = peek_token_bracket (token, regexp, syntax);\n\n#ifdef _LIBC\n\t  *err = build_range_exp (sbcset, mbcset, &range_alloc,\n\t\t\t\t  &start_elem, &end_elem);\n#else\n# ifdef RE_ENABLE_I18N\n\t  *err = build_range_exp (syntax, sbcset,\n\t\t\t\t  dfa->mb_cur_max > 1 ? mbcset : NULL,\n\t\t\t\t  &range_alloc, &start_elem, &end_elem);\n# else\n\t  *err = build_range_exp (syntax, sbcset, &start_elem, &end_elem);\n# endif\n#endif /* RE_ENABLE_I18N */\n\t  if (BE (*err != REG_NOERROR, 0))\n\t    goto parse_bracket_exp_free_return;\n\t}\n      else\n\t{\n\t  switch (start_elem.type)\n\t    {\n\t    case SB_CHAR:\n\t      bitset_set (sbcset, start_elem.opr.ch);\n\t      break;\n#ifdef RE_ENABLE_I18N\n\t    case MB_CHAR:\n\t      /* Check whether the array has enough space.  */\n\t      if (BE (mbchar_alloc == mbcset->nmbchars, 0))\n\t\t{\n\t\t  wchar_t *new_mbchars;\n\t\t  /* Not enough, realloc it.  */\n\t\t  /* +1 in case of mbcset->nmbchars is 0.  */\n\t\t  mbchar_alloc = 2 * mbcset->nmbchars + 1;\n\t\t  /* Use realloc since array is NULL if *alloc == 0.  */\n\t\t  new_mbchars = re_realloc (mbcset->mbchars, wchar_t,\n\t\t\t\t\t    mbchar_alloc);\n\t\t  if (BE (new_mbchars == NULL, 0))\n\t\t    goto parse_bracket_exp_espace;\n\t\t  mbcset->mbchars = new_mbchars;\n\t\t}\n\t      mbcset->mbchars[mbcset->nmbchars++] = start_elem.opr.wch;\n\t      break;\n#endif /* RE_ENABLE_I18N */\n\t    case EQUIV_CLASS:\n\t      *err = build_equiv_class (sbcset,\n#ifdef RE_ENABLE_I18N\n\t\t\t\t\tmbcset, &equiv_class_alloc,\n#endif /* RE_ENABLE_I18N */\n\t\t\t\t\tstart_elem.opr.name);\n\t      if (BE (*err != REG_NOERROR, 0))\n\t\tgoto parse_bracket_exp_free_return;\n\t      break;\n\t    case COLL_SYM:\n\t      *err = build_collating_symbol (sbcset,\n#ifdef RE_ENABLE_I18N\n\t\t\t\t\t     mbcset, &coll_sym_alloc,\n#endif /* RE_ENABLE_I18N */\n\t\t\t\t\t     start_elem.opr.name);\n\t      if (BE (*err != REG_NOERROR, 0))\n\t\tgoto parse_bracket_exp_free_return;\n\t      break;\n\t    case CHAR_CLASS:\n\t      *err = build_charclass (regexp->trans, sbcset,\n#ifdef RE_ENABLE_I18N\n\t\t\t\t      mbcset, &char_class_alloc,\n#endif /* RE_ENABLE_I18N */\n\t\t\t\t      (const char *) start_elem.opr.name,\n\t\t\t\t      syntax);\n\t      if (BE (*err != REG_NOERROR, 0))\n\t       goto parse_bracket_exp_free_return;\n\t      break;\n\t    default:\n\t      assert (0);\n\t      break;\n\t    }\n\t}\n      if (BE (token->type == END_OF_RE, 0))\n\t{\n\t  *err = REG_EBRACK;\n\t  goto parse_bracket_exp_free_return;\n\t}\n      if (token->type == OP_CLOSE_BRACKET)\n\tbreak;\n    }\n\n  re_string_skip_bytes (regexp, token_len); /* Skip a token.  */\n\n  /* If it is non-matching list.  */\n  if (non_match)\n    bitset_not (sbcset);\n\n#ifdef RE_ENABLE_I18N\n  /* Ensure only single byte characters are set.  */\n  if (dfa->mb_cur_max > 1)\n    bitset_mask (sbcset, dfa->sb_char);\n\n  if (mbcset->nmbchars || mbcset->ncoll_syms || mbcset->nequiv_classes\n      || mbcset->nranges || (dfa->mb_cur_max > 1 && (mbcset->nchar_classes\n\t\t\t\t\t\t     || mbcset->non_match)))\n    {\n      bin_tree_t *mbc_tree;\n      int sbc_idx;\n      /* Build a tree for complex bracket.  */\n      dfa->has_mb_node = 1;\n      br_token.type = COMPLEX_BRACKET;\n      br_token.opr.mbcset = mbcset;\n      mbc_tree = create_token_tree (dfa, NULL, NULL, &br_token);\n      if (BE (mbc_tree == NULL, 0))\n\tgoto parse_bracket_exp_espace;\n      for (sbc_idx = 0; sbc_idx < BITSET_WORDS; ++sbc_idx)\n\tif (sbcset[sbc_idx])\n\t  break;\n      /* If there are no bits set in sbcset, there is no point\n\t of having both SIMPLE_BRACKET and COMPLEX_BRACKET.  */\n      if (sbc_idx < BITSET_WORDS)\n\t{\n\t  /* Build a tree for simple bracket.  */\n\t  br_token.type = SIMPLE_BRACKET;\n\t  br_token.opr.sbcset = sbcset;\n\t  work_tree = create_token_tree (dfa, NULL, NULL, &br_token);\n\t  if (BE (work_tree == NULL, 0))\n\t    goto parse_bracket_exp_espace;\n\n\t  /* Then join them by ALT node.  */\n\t  work_tree = create_tree (dfa, work_tree, mbc_tree, OP_ALT);\n\t  if (BE (work_tree == NULL, 0))\n\t    goto parse_bracket_exp_espace;\n\t}\n      else\n\t{\n\t  re_free (sbcset);\n\t  work_tree = mbc_tree;\n\t}\n    }\n  else\n#endif /* not RE_ENABLE_I18N */\n    {\n#ifdef RE_ENABLE_I18N\n      free_charset (mbcset);\n#endif\n      /* Build a tree for simple bracket.  */\n      br_token.type = SIMPLE_BRACKET;\n      br_token.opr.sbcset = sbcset;\n      work_tree = create_token_tree (dfa, NULL, NULL, &br_token);\n      if (BE (work_tree == NULL, 0))\n\tgoto parse_bracket_exp_espace;\n    }\n  return work_tree;\n\n parse_bracket_exp_espace:\n  *err = REG_ESPACE;\n parse_bracket_exp_free_return:\n  re_free (sbcset);\n#ifdef RE_ENABLE_I18N\n  free_charset (mbcset);\n#endif /* RE_ENABLE_I18N */\n  return NULL;\n}",
      "lines": 546,
      "depth": 25,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\nparse_bracket_exp (re_string_t *regexp, re_dfa_t *dfa, re_token_t *token,\n\t\t   reg_syntax_t syntax, reg_errcode_t *err)",
        "*"
      ]
    },
    "seek_collating_symbol_entry": {
      "start_point": [
        2867,
        2
      ],
      "end_point": [
        2887,
        5
      ],
      "content": "auto inline int32_t\n  __attribute__ ((always_inline))\n  seek_collating_symbol_entry (const unsigned char *name, size_t name_len)\n    {\n      int32_t elem;\n\n      for (elem = 0; elem < table_size; elem++)\n\tif (symb_table[2 * elem] != 0)\n\t  {\n\t    int32_t idx = symb_table[2 * elem + 1];\n\t    /* Skip the name of collating element name.  */\n\t    idx += 1 + extra[idx];\n\t    if (/* Compare the length of the name.  */\n\t\tname_len == extra[idx]\n\t\t/* Compare the name.  */\n\t\t&& memcmp (name, &extra[idx + 1], name_len) == 0)\n\t      /* Yep, this is the entry.  */\n\t      return elem;\n\t  }\n      return -1;\n    }",
      "lines": 21,
      "depth": 15,
      "decorators": [
        "auto",
        "auto",
        "inline",
        "inline",
        "int32_t",
        "__attribute__ ((always_inline))",
        "__attribute__",
        "(",
        "(always_inline)",
        "(",
        "always_inline",
        ")",
        ")"
      ]
    },
    "lookup_collation_sequence_value": {
      "start_point": [
        2893,
        2
      ],
      "end_point": [
        2952,
        5
      ],
      "content": "auto inline unsigned int\n  __attribute__ ((always_inline))\n  lookup_collation_sequence_value (bracket_elem_t *br_elem)\n    {\n      if (br_elem->type == SB_CHAR)\n\t{\n\t  /*\n\t  if (MB_CUR_MAX == 1)\n\t  */\n\t  if (nrules == 0)\n\t    return collseqmb[br_elem->opr.ch];\n\t  else\n\t    {\n\t      wint_t wc = __btowc (br_elem->opr.ch);\n\t      return __collseq_table_lookup (collseqwc, wc);\n\t    }\n\t}\n      else if (br_elem->type == MB_CHAR)\n\t{\n\t  if (nrules != 0)\n\t    return __collseq_table_lookup (collseqwc, br_elem->opr.wch);\n\t}\n      else if (br_elem->type == COLL_SYM)\n\t{\n\t  size_t sym_name_len = strlen ((char *) br_elem->opr.name);\n\t  if (nrules != 0)\n\t    {\n\t      int32_t elem, idx;\n\t      elem = seek_collating_symbol_entry (br_elem->opr.name,\n\t\t\t\t\t\t  sym_name_len);\n\t      if (elem != -1)\n\t\t{\n\t\t  /* We found the entry.  */\n\t\t  idx = symb_table[2 * elem + 1];\n\t\t  /* Skip the name of collating element name.  */\n\t\t  idx += 1 + extra[idx];\n\t\t  /* Skip the byte sequence of the collating element.  */\n\t\t  idx += 1 + extra[idx];\n\t\t  /* Adjust for the alignment.  */\n\t\t  idx = (idx + 3) & ~3;\n\t\t  /* Skip the multibyte collation sequence value.  */\n\t\t  idx += sizeof (unsigned int);\n\t\t  /* Skip the wide char sequence of the collating element.  */\n\t\t  idx += sizeof (unsigned int) *\n\t\t    (1 + *(unsigned int *) (extra + idx));\n\t\t  /* Return the collation sequence value.  */\n\t\t  return *(unsigned int *) (extra + idx);\n\t\t}\n\t      else if (sym_name_len == 1)\n\t\t{\n\t\t  /* No valid character.  Match it as a single byte\n\t\t     character.  */\n\t\t  return collseqmb[br_elem->opr.name[0]];\n\t\t}\n\t    }\n\t  else if (sym_name_len == 1)\n\t    return collseqmb[br_elem->opr.name[0]];\n\t}\n      return UINT_MAX;\n    }",
      "lines": 60,
      "depth": 22,
      "decorators": [
        "auto",
        "auto",
        "inline",
        "inline",
        "unsigned int",
        "unsigned",
        "int",
        "__attribute__ ((always_inline))",
        "__attribute__",
        "(",
        "(always_inline)",
        "(",
        "always_inline",
        ")",
        ")"
      ]
    },
    "build_range_exp": {
      "start_point": [
        2961,
        2
      ],
      "end_point": [
        3034,
        5
      ],
      "content": "auto inline reg_errcode_t\n  __attribute__ ((always_inline))\n  build_range_exp (bitset_t sbcset, re_charset_t *mbcset, int *range_alloc,\n\t\t   bracket_elem_t *start_elem, bracket_elem_t *end_elem)\n    {\n      unsigned int ch;\n      uint32_t start_collseq;\n      uint32_t end_collseq;\n\n      /* Equivalence Classes and Character Classes can't be a range\n\t start/end.  */\n      if (BE (start_elem->type == EQUIV_CLASS || start_elem->type == CHAR_CLASS\n\t      || end_elem->type == EQUIV_CLASS || end_elem->type == CHAR_CLASS,\n\t      0))\n\treturn REG_ERANGE;\n\n      /* FIXME: Implement rational ranges here, too.  */\n      start_collseq = lookup_collation_sequence_value (start_elem);\n      end_collseq = lookup_collation_sequence_value (end_elem);\n      /* Check start/end collation sequence values.  */\n      if (BE (start_collseq == UINT_MAX || end_collseq == UINT_MAX, 0))\n\treturn REG_ECOLLATE;\n      if (BE ((syntax & RE_NO_EMPTY_RANGES) && start_collseq > end_collseq, 0))\n\treturn REG_ERANGE;\n\n      /* Got valid collation sequence values, add them as a new entry.\n\t However, if we have no collation elements, and the character set\n\t is single byte, the single byte character set that we\n\t build below suffices. */\n      if (nrules > 0 || dfa->mb_cur_max > 1)\n\t{\n\t  /* Check the space of the arrays.  */\n\t  if (BE (*range_alloc == mbcset->nranges, 0))\n\t    {\n\t      /* There is not enough space, need realloc.  */\n\t      uint32_t *new_array_start;\n\t      uint32_t *new_array_end;\n\t      Idx new_nranges;\n\n\t      /* +1 in case of mbcset->nranges is 0.  */\n\t      new_nranges = 2 * mbcset->nranges + 1;\n\t      new_array_start = re_realloc (mbcset->range_starts, uint32_t,\n\t\t\t\t\t    new_nranges);\n\t      new_array_end = re_realloc (mbcset->range_ends, uint32_t,\n\t\t\t\t\t  new_nranges);\n\n\t      if (BE (new_array_start == NULL || new_array_end == NULL, 0))\n\t\treturn REG_ESPACE;\n\n\t      mbcset->range_starts = new_array_start;\n\t      mbcset->range_ends = new_array_end;\n\t      *range_alloc = new_nranges;\n\t    }\n\n\t  mbcset->range_starts[mbcset->nranges] = start_collseq;\n\t  mbcset->range_ends[mbcset->nranges++] = end_collseq;\n\t}\n\n      /* Build the table for single byte characters.  */\n      for (ch = 0; ch < SBC_MAX; ch++)\n\t{\n\t  uint32_t ch_collseq;\n\t  /*\n\t  if (MB_CUR_MAX == 1)\n\t  */\n\t  if (nrules == 0)\n\t    ch_collseq = collseqmb[ch];\n\t  else\n\t    ch_collseq = __collseq_table_lookup (collseqwc, __btowc (ch));\n\t  if (start_collseq <= ch_collseq && ch_collseq <= end_collseq)\n\t    bitset_set (sbcset, ch);\n\t}\n      return REG_NOERROR;\n    }",
      "lines": 74,
      "depth": 13,
      "decorators": [
        "auto",
        "auto",
        "inline",
        "inline",
        "reg_errcode_t",
        "__attribute__ ((always_inline))",
        "__attribute__",
        "(",
        "(always_inline)",
        "(",
        "always_inline",
        ")",
        ")"
      ]
    },
    "build_collating_symbol": {
      "start_point": [
        3042,
        2
      ],
      "end_point": [
        3098,
        5
      ],
      "content": "auto inline reg_errcode_t\n  __attribute__ ((always_inline))\n  build_collating_symbol (bitset_t sbcset, re_charset_t *mbcset,\n\t\t\t  Idx *coll_sym_alloc, const unsigned char *name)\n    {\n      int32_t elem, idx;\n      size_t name_len = strlen ((const char *) name);\n      if (nrules != 0)\n\t{\n\t  elem = seek_collating_symbol_entry (name, name_len);\n\t  if (elem != -1)\n\t    {\n\t      /* We found the entry.  */\n\t      idx = symb_table[2 * elem + 1];\n\t      /* Skip the name of collating element name.  */\n\t      idx += 1 + extra[idx];\n\t    }\n\t  else if (name_len == 1)\n\t    {\n\t      /* No valid character, treat it as a normal\n\t\t character.  */\n\t      bitset_set (sbcset, name[0]);\n\t      return REG_NOERROR;\n\t    }\n\t  else\n\t    return REG_ECOLLATE;\n\n\t  /* Got valid collation sequence, add it as a new entry.  */\n\t  /* Check the space of the arrays.  */\n\t  if (BE (*coll_sym_alloc == mbcset->ncoll_syms, 0))\n\t    {\n\t      /* Not enough, realloc it.  */\n\t      /* +1 in case of mbcset->ncoll_syms is 0.  */\n\t      Idx new_coll_sym_alloc = 2 * mbcset->ncoll_syms + 1;\n\t      /* Use realloc since mbcset->coll_syms is NULL\n\t\t if *alloc == 0.  */\n\t      int32_t *new_coll_syms = re_realloc (mbcset->coll_syms, int32_t,\n\t\t\t\t\t\t   new_coll_sym_alloc);\n\t      if (BE (new_coll_syms == NULL, 0))\n\t\treturn REG_ESPACE;\n\t      mbcset->coll_syms = new_coll_syms;\n\t      *coll_sym_alloc = new_coll_sym_alloc;\n\t    }\n\t  mbcset->coll_syms[mbcset->ncoll_syms++] = idx;\n\t  return REG_NOERROR;\n\t}\n      else\n\t{\n\t  if (BE (name_len != 1, 0))\n\t    return REG_ECOLLATE;\n\t  else\n\t    {\n\t      bitset_set (sbcset, name[0]);\n\t      return REG_NOERROR;\n\t    }\n\t}\n    }",
      "lines": 57,
      "depth": 12,
      "decorators": [
        "auto",
        "auto",
        "inline",
        "inline",
        "reg_errcode_t",
        "__attribute__ ((always_inline))",
        "__attribute__",
        "(",
        "(always_inline)",
        "(",
        "always_inline",
        ")",
        ")"
      ]
    },
    "parse_bracket_element": {
      "start_point": [
        3399,
        0
      ],
      "end_point": [
        3433,
        1
      ],
      "content": "static reg_errcode_t\nparse_bracket_element (bracket_elem_t *elem, re_string_t *regexp,\n\t\t       re_token_t *token, int token_len, re_dfa_t *dfa,\n\t\t       reg_syntax_t syntax, bool accept_hyphen)\n{\n#ifdef RE_ENABLE_I18N\n  int cur_char_size;\n  cur_char_size = re_string_char_size_at (regexp, re_string_cur_idx (regexp));\n  if (cur_char_size > 1)\n    {\n      elem->type = MB_CHAR;\n      elem->opr.wch = re_string_wchar_at (regexp, re_string_cur_idx (regexp));\n      re_string_skip_bytes (regexp, cur_char_size);\n      return REG_NOERROR;\n    }\n#endif /* RE_ENABLE_I18N */\n  re_string_skip_bytes (regexp, token_len); /* Skip a token.  */\n  if (token->type == OP_OPEN_COLL_ELEM || token->type == OP_OPEN_CHAR_CLASS\n      || token->type == OP_OPEN_EQUIV_CLASS)\n    return parse_bracket_symbol (elem, regexp, token);\n  if (BE (token->type == OP_CHARSET_RANGE, 0) && !accept_hyphen)\n    {\n      /* A '-' must only appear as anything but a range indicator before\n\t the closing bracket.  Everything else is an error.  */\n      re_token_t token2;\n      (void) peek_token_bracket (&token2, regexp, syntax);\n      if (token2.type != OP_CLOSE_BRACKET)\n\t/* The actual error value is not standardized since this whole\n\t   case is undefined.  But ERANGE makes good sense.  */\n\treturn REG_ERANGE;\n    }\n  elem->type = SB_CHAR;\n  elem->opr.ch = token->opr.c;\n  return REG_NOERROR;\n}",
      "lines": 35,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "parse_bracket_symbol": {
      "start_point": [
        3439,
        0
      ],
      "end_point": [
        3478,
        1
      ],
      "content": "static reg_errcode_t\nparse_bracket_symbol (bracket_elem_t *elem, re_string_t *regexp,\n\t\t      re_token_t *token)\n{\n  unsigned char ch, delim = token->opr.c;\n  int i = 0;\n  if (re_string_eoi(regexp))\n    return REG_EBRACK;\n  for (;; ++i)\n    {\n      if (i >= BRACKET_NAME_BUF_SIZE)\n\treturn REG_EBRACK;\n      if (token->type == OP_OPEN_CHAR_CLASS)\n\tch = re_string_fetch_byte_case (regexp);\n      else\n\tch = re_string_fetch_byte (regexp);\n      if (re_string_eoi(regexp))\n\treturn REG_EBRACK;\n      if (ch == delim && re_string_peek_byte (regexp, 0) == ']')\n\tbreak;\n      elem->opr.name[i] = ch;\n    }\n  re_string_skip_bytes (regexp, 1);\n  elem->opr.name[i] = '\\0';\n  switch (token->type)\n    {\n    case OP_OPEN_COLL_ELEM:\n      elem->type = COLL_SYM;\n      break;\n    case OP_OPEN_EQUIV_CLASS:\n      elem->type = EQUIV_CLASS;\n      break;\n    case OP_OPEN_CHAR_CLASS:\n      elem->type = CHAR_CLASS;\n      break;\n    default:\n      break;\n    }\n  return REG_NOERROR;\n}",
      "lines": 40,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "build_charclass": {
      "start_point": [
        3586,
        9
      ],
      "end_point": [
        3660,
        1
      ],
      "content": "char *class_name, reg_syntax_t syntax)\n#endif /* not RE_ENABLE_I18N */\n{\n  int i;\n  const char *name = class_name;\n\n  /* In case of REG_ICASE \"upper\" and \"lower\" match the both of\n     upper and lower cases.  */\n  if ((syntax & RE_ICASE)\n      && (strcmp (name, \"upper\") == 0 || strcmp (name, \"lower\") == 0))\n    name = \"alpha\";\n\n#ifdef RE_ENABLE_I18N\n  /* Check the space of the arrays.  */\n  if (BE (*char_class_alloc == mbcset->nchar_classes, 0))\n    {\n      /* Not enough, realloc it.  */\n      /* +1 in case of mbcset->nchar_classes is 0.  */\n      Idx new_char_class_alloc = 2 * mbcset->nchar_classes + 1;\n      /* Use realloc since array is NULL if *alloc == 0.  */\n      wctype_t *new_char_classes = re_realloc (mbcset->char_classes, wctype_t,\n\t\t\t\t\t       new_char_class_alloc);\n      if (BE (new_char_classes == NULL, 0))\n\treturn REG_ESPACE;\n      mbcset->char_classes = new_char_classes;\n      *char_class_alloc = new_char_class_alloc;\n    }\n  mbcset->char_classes[mbcset->nchar_classes++] = __wctype (name);\n#endif /* RE_ENABLE_I18N */\n\n#define BUILD_CHARCLASS_LOOP(ctype_func)\t\\\n  do {\t\t\t\t\t\t\\\n    if (BE (trans != NULL, 0))\t\t\t\\\n      {\t\t\t\t\t\t\\\n\tfor (i = 0; i < SBC_MAX; ++i)\t\t\\\n\t  if (ctype_func (i))\t\t\t\\\n\t    bitset_set (sbcset, trans[i]);\t\\\n      }\t\t\t\t\t\t\\\n    else\t\t\t\t\t\\\n      {\t\t\t\t\t\t\\\n\tfor (i = 0; i < SBC_MAX; ++i)\t\t\\\n\t  if (ctype_func (i))\t\t\t\\\n\t    bitset_set (sbcset, i);\t\t\\\n      }\t\t\t\t\t\t\\\n  } while (0)\n\n  if (strcmp (name, \"alnum\") == 0)\n    BUILD_CHARCLASS_LOOP (isalnum);\n  else if (strcmp (name, \"cntrl\") == 0)\n    BUILD_CHARCLASS_LOOP (iscntrl);\n  else if (strcmp (name, \"lower\") == 0)\n    BUILD_CHARCLASS_LOOP (islower);\n  else if (strcmp (name, \"space\") == 0)\n    BUILD_CHARCLASS_LOOP (isspace);\n  else if (strcmp (name, \"alpha\") == 0)\n    BUILD_CHARCLASS_LOOP (isalpha);\n  else if (strcmp (name, \"digit\") == 0)\n    BUILD_CHARCLASS_LOOP (isdigit);\n  else if (strcmp (name, \"print\") == 0)\n    BUILD_CHARCLASS_LOOP (isprint);\n  else if (strcmp (name, \"upper\") == 0)\n    BUILD_CHARCLASS_LOOP (isupper);\n  else if (strcmp (name, \"blank\") == 0)\n    BUILD_CHARCLASS_LOOP (isblank);\n  else if (strcmp (name, \"graph\") == 0)\n    BUILD_CHARCLASS_LOOP (isgraph);\n  else if (strcmp (name, \"punct\") == 0)\n    BUILD_CHARCLASS_LOOP (ispunct);\n  else if (strcmp (name, \"xdigit\") == 0)\n    BUILD_CHARCLASS_LOOP (isxdigit);\n  else\n    return REG_ECTYPE;\n\n  return REG_NOERROR;\n}",
      "lines": 75,
      "depth": 20,
      "decorators": null
    },
    "build_charclass_op": {
      "start_point": [
        3662,
        0
      ],
      "end_point": [
        3768,
        1
      ],
      "content": "static bin_tree_t *\nbuild_charclass_op (re_dfa_t *dfa, RE_TRANSLATE_TYPE trans,\n\t\t    const char *class_name,\n\t\t    const char *extra, bool non_match,\n\t\t    reg_errcode_t *err)\n{\n  re_bitset_ptr_t sbcset;\n#ifdef RE_ENABLE_I18N\n  re_charset_t *mbcset;\n  Idx alloc = 0;\n#endif /* not RE_ENABLE_I18N */\n  reg_errcode_t ret;\n  re_token_t br_token;\n  bin_tree_t *tree;\n\n  sbcset = (re_bitset_ptr_t) calloc (sizeof (bitset_t), 1);\n#ifdef RE_ENABLE_I18N\n  mbcset = (re_charset_t *) calloc (sizeof (re_charset_t), 1);\n#endif /* RE_ENABLE_I18N */\n\n#ifdef RE_ENABLE_I18N\n  if (BE (sbcset == NULL || mbcset == NULL, 0))\n#else /* not RE_ENABLE_I18N */\n  if (BE (sbcset == NULL, 0))\n#endif /* not RE_ENABLE_I18N */\n    {\n      *err = REG_ESPACE;\n      return NULL;\n    }\n\n  if (non_match)\n    {\n#ifdef RE_ENABLE_I18N\n      mbcset->non_match = 1;\n#endif /* not RE_ENABLE_I18N */\n    }\n\n  /* We don't care the syntax in this case.  */\n  ret = build_charclass (trans, sbcset,\n#ifdef RE_ENABLE_I18N\n\t\t\t mbcset, &alloc,\n#endif /* RE_ENABLE_I18N */\n\t\t\t class_name, 0);\n\n  if (BE (ret != REG_NOERROR, 0))\n    {\n      re_free (sbcset);\n#ifdef RE_ENABLE_I18N\n      free_charset (mbcset);\n#endif /* RE_ENABLE_I18N */\n      *err = ret;\n      return NULL;\n    }\n  /* \\w match '_' also.  */\n  for (; *extra; extra++)\n    bitset_set (sbcset, *extra);\n\n  /* If it is non-matching list.  */\n  if (non_match)\n    bitset_not (sbcset);\n\n#ifdef RE_ENABLE_I18N\n  /* Ensure only single byte characters are set.  */\n  if (dfa->mb_cur_max > 1)\n    bitset_mask (sbcset, dfa->sb_char);\n#endif\n\n  /* Build a tree for simple bracket.  */\n  br_token.type = SIMPLE_BRACKET;\n  br_token.opr.sbcset = sbcset;\n  tree = create_token_tree (dfa, NULL, NULL, &br_token);\n  if (BE (tree == NULL, 0))\n    goto build_word_op_espace;\n\n#ifdef RE_ENABLE_I18N\n  if (dfa->mb_cur_max > 1)\n    {\n      bin_tree_t *mbc_tree;\n      /* Build a tree for complex bracket.  */\n      br_token.type = COMPLEX_BRACKET;\n      br_token.opr.mbcset = mbcset;\n      dfa->has_mb_node = 1;\n      mbc_tree = create_token_tree (dfa, NULL, NULL, &br_token);\n      if (BE (mbc_tree == NULL, 0))\n\tgoto build_word_op_espace;\n      /* Then join them by ALT node.  */\n      tree = create_tree (dfa, tree, mbc_tree, OP_ALT);\n      if (BE (mbc_tree != NULL, 1))\n\treturn tree;\n    }\n  else\n    {\n      free_charset (mbcset);\n      return tree;\n    }\n#else /* not RE_ENABLE_I18N */\n  return tree;\n#endif /* not RE_ENABLE_I18N */\n\n build_word_op_espace:\n  re_free (sbcset);\n#ifdef RE_ENABLE_I18N\n  free_charset (mbcset);\n#endif /* RE_ENABLE_I18N */\n  *err = REG_ESPACE;\n  return NULL;\n}",
      "lines": 107,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\nbuild_charclass_op (re_dfa_t *dfa, RE_TRANSLATE_TYPE trans,\n\t\t    const char *class_name,\n\t\t    const char *extra, bool non_match,\n\t\t    reg_errcode_t *err)",
        "*"
      ]
    },
    "fetch_number": {
      "start_point": [
        3776,
        0
      ],
      "end_point": [
        3797,
        1
      ],
      "content": "static Idx\nfetch_number (re_string_t *input, re_token_t *token, reg_syntax_t syntax)\n{\n  Idx num = REG_MISSING;\n  unsigned char c;\n  while (1)\n    {\n      fetch_token (token, input, syntax);\n      c = token->opr.c;\n      if (BE (token->type == END_OF_RE, 0))\n\treturn REG_ERROR;\n      if (token->type == OP_CLOSE_DUP_NUM || c == ',')\n\tbreak;\n      num = ((token->type != CHARACTER || c < '0' || '9' < c\n\t      || num == REG_ERROR)\n\t     ? REG_ERROR\n\t     : num == REG_MISSING\n\t     ? c - '0'\n\t     : MIN (RE_DUP_MAX + 1, num * 10 + c - '0'));\n    }\n  return num;\n}",
      "lines": 22,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "Idx"
      ]
    },
    "free_charset": {
      "start_point": [
        3800,
        0
      ],
      "end_point": [
        3812,
        1
      ],
      "content": "static void\nfree_charset (re_charset_t *cset)\n{\n  re_free (cset->mbchars);\n# ifdef _LIBC\n  re_free (cset->coll_syms);\n  re_free (cset->equiv_classes);\n  re_free (cset->range_starts);\n  re_free (cset->range_ends);\n# endif\n  re_free (cset->char_classes);\n  re_free (cset);\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "create_tree": {
      "start_point": [
        3819,
        0
      ],
      "end_point": [
        3826,
        1
      ],
      "content": "static bin_tree_t *\ncreate_tree (re_dfa_t *dfa, bin_tree_t *left, bin_tree_t *right,\n\t     re_token_type_t type)\n{\n  re_token_t t;\n  t.type = type;\n  return create_token_tree (dfa, left, right, &t);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\ncreate_tree (re_dfa_t *dfa, bin_tree_t *left, bin_tree_t *right,\n\t     re_token_type_t type)",
        "*"
      ]
    },
    "create_token_tree": {
      "start_point": [
        3828,
        0
      ],
      "end_point": [
        3860,
        1
      ],
      "content": "static bin_tree_t *\ncreate_token_tree (re_dfa_t *dfa, bin_tree_t *left, bin_tree_t *right,\n\t\t   const re_token_t *token)\n{\n  bin_tree_t *tree;\n  if (BE (dfa->str_tree_storage_idx == BIN_TREE_STORAGE_SIZE, 0))\n    {\n      bin_tree_storage_t *storage = re_malloc (bin_tree_storage_t, 1);\n\n      if (storage == NULL)\n\treturn NULL;\n      storage->next = dfa->str_tree_storage;\n      dfa->str_tree_storage = storage;\n      dfa->str_tree_storage_idx = 0;\n    }\n  tree = &dfa->str_tree_storage->data[dfa->str_tree_storage_idx++];\n\n  tree->parent = NULL;\n  tree->left = left;\n  tree->right = right;\n  tree->token = *token;\n  tree->token.duplicated = 0;\n  tree->token.opt_subexp = 0;\n  tree->first = NULL;\n  tree->next = NULL;\n  tree->node_idx = REG_MISSING;\n\n  if (left != NULL)\n    left->parent = tree;\n  if (right != NULL)\n    right->parent = tree;\n  return tree;\n}",
      "lines": 33,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\ncreate_token_tree (re_dfa_t *dfa, bin_tree_t *left, bin_tree_t *right,\n\t\t   const re_token_t *token)",
        "*"
      ]
    },
    "mark_opt_subexp": {
      "start_point": [
        3865,
        0
      ],
      "end_point": [
        3873,
        1
      ],
      "content": "static reg_errcode_t\nmark_opt_subexp (void *extra, bin_tree_t *node)\n{\n  Idx idx = (uintptr_t) extra;\n  if (node->token.type == SUBEXP && node->token.opr.idx == idx)\n    node->token.opt_subexp = 1;\n\n  return REG_NOERROR;\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "free_token": {
      "start_point": [
        3877,
        0
      ],
      "end_point": [
        3887,
        1
      ],
      "content": "static void\nfree_token (re_token_t *node)\n{\n#ifdef RE_ENABLE_I18N\n  if (node->type == COMPLEX_BRACKET && node->duplicated == 0)\n    free_charset (node->opr.mbcset);\n  else\n#endif /* RE_ENABLE_I18N */\n    if (node->type == SIMPLE_BRACKET && node->duplicated == 0)\n      re_free (node->opr.sbcset);\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "free_tree": {
      "start_point": [
        3892,
        0
      ],
      "end_point": [
        3897,
        1
      ],
      "content": "static reg_errcode_t\nfree_tree (void *extra, bin_tree_t *node)\n{\n  free_token (&node->token);\n  return REG_NOERROR;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "duplicate_tree": {
      "start_point": [
        3905,
        0
      ],
      "end_point": [
        3943,
        1
      ],
      "content": "static bin_tree_t *\nduplicate_tree (const bin_tree_t *root, re_dfa_t *dfa)\n{\n  const bin_tree_t *node;\n  bin_tree_t *dup_root;\n  bin_tree_t **p_new = &dup_root, *dup_node = root->parent;\n\n  for (node = root; ; )\n    {\n      /* Create a new tree and link it back to the current parent.  */\n      *p_new = create_token_tree (dfa, NULL, NULL, &node->token);\n      if (*p_new == NULL)\n\treturn NULL;\n      (*p_new)->parent = dup_node;\n      (*p_new)->token.duplicated = 1;\n      dup_node = *p_new;\n\n      /* Go to the left node, or up and to the right.  */\n      if (node->left)\n\t{\n\t  node = node->left;\n\t  p_new = &dup_node->left;\n\t}\n      else\n\t{\n\t  const bin_tree_t *prev = NULL;\n\t  while (node->right == prev || node->right == NULL)\n\t    {\n\t      prev = node;\n\t      node = node->parent;\n\t      dup_node = dup_node->parent;\n\t      if (!node)\n\t\treturn dup_root;\n\t    }\n\t  node = node->right;\n\t  p_new = &dup_node->right;\n\t}\n    }\n}",
      "lines": 39,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\nduplicate_tree (const bin_tree_t *root, re_dfa_t *dfa)",
        "*"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/regex.c": {},
  "findutils/findutils-4.6.0/gl/lib/regex.h": {},
  "findutils/findutils-4.6.0/gl/lib/regexec.c": {
    "__compat_regexec": {
      "start_point": [
        264,
        0
      ],
      "end_point": [
        272,
        1
      ],
      "content": "int\nattribute_compat_text_section\n__compat_regexec (const regex_t *_Restrict_ preg,\n\t\t  const char *_Restrict_ string, size_t nmatch,\n\t\t  regmatch_t pmatch[], int eflags)\n{\n  return regexec (preg, string, nmatch, pmatch,\n\t\t  eflags & (REG_NOTBOL | REG_NOTEOL));\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "int",
        "attribute_compat_text_section",
        "attribute_compat_text_section"
      ]
    },
    "re_search_2_stub": {
      "start_point": [
        363,
        0
      ],
      "end_point": [
        403,
        1
      ],
      "content": "static regoff_t\nre_search_2_stub (struct re_pattern_buffer *bufp,\n\t\t  const char *string1, Idx length1,\n\t\t  const char *string2, Idx length2,\n\t\t  Idx start, regoff_t range, struct re_registers *regs,\n\t\t  Idx stop, bool ret_len)\n{\n  const char *str;\n  regoff_t rval;\n  Idx len = length1 + length2;\n  char *s = NULL;\n\n  if (BE (length1 < 0 || length2 < 0 || stop < 0 || len < length1, 0))\n    return -2;\n\n  /* Concatenate the strings.  */\n  if (length2 > 0)\n    if (length1 > 0)\n      {\n\ts = re_malloc (char, len);\n\n\tif (BE (s == NULL, 0))\n\t  return -2;\n#ifdef _LIBC\n\tmemcpy (__mempcpy (s, string1, length1), string2, length2);\n#else\n\tmemcpy (s, string1, length1);\n\tmemcpy (s + length1, string2, length2);\n#endif\n\tstr = s;\n      }\n    else\n      str = string2;\n  else\n    str = string1;\n\n  rval = re_search_stub (bufp, str, len, start, range, stop, regs,\n\t\t\t ret_len);\n  re_free (s);\n  return rval;\n}",
      "lines": 41,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "regoff_t"
      ]
    },
    "re_search_stub": {
      "start_point": [
        410,
        0
      ],
      "end_point": [
        498,
        1
      ],
      "content": "static regoff_t\nre_search_stub (struct re_pattern_buffer *bufp,\n\t\tconst char *string, Idx length,\n\t\tIdx start, regoff_t range, Idx stop, struct re_registers *regs,\n\t\tbool ret_len)\n{\n  reg_errcode_t result;\n  regmatch_t *pmatch;\n  Idx nregs;\n  regoff_t rval;\n  int eflags = 0;\n  re_dfa_t *dfa = bufp->buffer;\n  Idx last_start = start + range;\n\n  /* Check for out-of-range.  */\n  if (BE (start < 0 || start > length, 0))\n    return -1;\n  if (BE (length < last_start || (0 <= range && last_start < start), 0))\n    last_start = length;\n  else if (BE (last_start < 0 || (range < 0 && start <= last_start), 0))\n    last_start = 0;\n\n  lock_lock (dfa->lock);\n\n  eflags |= (bufp->not_bol) ? REG_NOTBOL : 0;\n  eflags |= (bufp->not_eol) ? REG_NOTEOL : 0;\n\n  /* Compile fastmap if we haven't yet.  */\n  if (start < last_start && bufp->fastmap != NULL && !bufp->fastmap_accurate)\n    re_compile_fastmap (bufp);\n\n  if (BE (bufp->no_sub, 0))\n    regs = NULL;\n\n  /* We need at least 1 register.  */\n  if (regs == NULL)\n    nregs = 1;\n  else if (BE (bufp->regs_allocated == REGS_FIXED\n\t       && regs->num_regs <= bufp->re_nsub, 0))\n    {\n      nregs = regs->num_regs;\n      if (BE (nregs < 1, 0))\n\t{\n\t  /* Nothing can be copied to regs.  */\n\t  regs = NULL;\n\t  nregs = 1;\n\t}\n    }\n  else\n    nregs = bufp->re_nsub + 1;\n  pmatch = re_malloc (regmatch_t, nregs);\n  if (BE (pmatch == NULL, 0))\n    {\n      rval = -2;\n      goto out;\n    }\n\n  result = re_search_internal (bufp, string, length, start, last_start, stop,\n\t\t\t       nregs, pmatch, eflags);\n\n  rval = 0;\n\n  /* I hope we needn't fill their regs with -1's when no match was found.  */\n  if (result != REG_NOERROR)\n    rval = result == REG_NOMATCH ? -1 : -2;\n  else if (regs != NULL)\n    {\n      /* If caller wants register contents data back, copy them.  */\n      bufp->regs_allocated = re_copy_regs (regs, pmatch, nregs,\n\t\t\t\t\t   bufp->regs_allocated);\n      if (BE (bufp->regs_allocated == REGS_UNALLOCATED, 0))\n\trval = -2;\n    }\n\n  if (BE (rval == 0, 1))\n    {\n      if (ret_len)\n\t{\n\t  assert (pmatch[0].rm_so == start);\n\t  rval = pmatch[0].rm_eo - start;\n\t}\n      else\n\trval = pmatch[0].rm_so;\n    }\n  re_free (pmatch);\n out:\n  lock_unlock (dfa->lock);\n  return rval;\n}",
      "lines": 89,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "regoff_t"
      ]
    },
    "re_copy_regs": {
      "start_point": [
        500,
        0
      ],
      "end_point": [
        563,
        1
      ],
      "content": "static unsigned\nre_copy_regs (struct re_registers *regs, regmatch_t *pmatch, Idx nregs,\n\t      int regs_allocated)\n{\n  int rval = REGS_REALLOCATE;\n  Idx i;\n  Idx need_regs = nregs + 1;\n  /* We need one extra element beyond 'num_regs' for the '-1' marker GNU code\n     uses.  */\n\n  /* Have the register data arrays been allocated?  */\n  if (regs_allocated == REGS_UNALLOCATED)\n    { /* No.  So allocate them with malloc.  */\n      regs->start = re_malloc (regoff_t, need_regs);\n      if (BE (regs->start == NULL, 0))\n\treturn REGS_UNALLOCATED;\n      regs->end = re_malloc (regoff_t, need_regs);\n      if (BE (regs->end == NULL, 0))\n\t{\n\t  re_free (regs->start);\n\t  return REGS_UNALLOCATED;\n\t}\n      regs->num_regs = need_regs;\n    }\n  else if (regs_allocated == REGS_REALLOCATE)\n    { /* Yes.  If we need more elements than were already\n\t allocated, reallocate them.  If we need fewer, just\n\t leave it alone.  */\n      if (BE (need_regs > regs->num_regs, 0))\n\t{\n\t  regoff_t *new_start = re_realloc (regs->start, regoff_t, need_regs);\n\t  regoff_t *new_end;\n\t  if (BE (new_start == NULL, 0))\n\t    return REGS_UNALLOCATED;\n\t  new_end = re_realloc (regs->end, regoff_t, need_regs);\n\t  if (BE (new_end == NULL, 0))\n\t    {\n\t      re_free (new_start);\n\t      return REGS_UNALLOCATED;\n\t    }\n\t  regs->start = new_start;\n\t  regs->end = new_end;\n\t  regs->num_regs = need_regs;\n\t}\n    }\n  else\n    {\n      assert (regs_allocated == REGS_FIXED);\n      /* This function may not be called with REGS_FIXED and nregs too big.  */\n      assert (regs->num_regs >= nregs);\n      rval = REGS_FIXED;\n    }\n\n  /* Copy the regs.  */\n  for (i = 0; i < nregs; ++i)\n    {\n      regs->start[i] = pmatch[i].rm_so;\n      regs->end[i] = pmatch[i].rm_eo;\n    }\n  for ( ; i < regs->num_regs; ++i)\n    regs->start[i] = regs->end[i] = -1;\n\n  return rval;\n}",
      "lines": 64,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "unsigned",
        "unsigned"
      ]
    },
    "re_search_internal": {
      "start_point": [
        629,
        0
      ],
      "end_point": [
        963,
        1
      ],
      "content": "static reg_errcode_t\n__attribute_warn_unused_result__\nre_search_internal (const regex_t *preg,\n\t\t    const char *string, Idx length,\n\t\t    Idx start, Idx last_start, Idx stop,\n\t\t    size_t nmatch, regmatch_t pmatch[],\n\t\t    int eflags)\n{\n  reg_errcode_t err;\n  const re_dfa_t *dfa = preg->buffer;\n  Idx left_lim, right_lim;\n  int incr;\n  bool fl_longest_match;\n  int match_kind;\n  Idx match_first;\n  Idx match_last = REG_MISSING;\n  Idx extra_nmatch;\n  bool sb;\n  int ch;\n#if defined _LIBC || (defined __STDC_VERSION__ && __STDC_VERSION__ >= 199901L)\n  re_match_context_t mctx = { .dfa = dfa };\n#else\n  re_match_context_t mctx;\n#endif\n  char *fastmap = ((preg->fastmap != NULL && preg->fastmap_accurate\n\t\t    && start != last_start && !preg->can_be_null)\n\t\t   ? preg->fastmap : NULL);\n  RE_TRANSLATE_TYPE t = preg->translate;\n\n#if !(defined _LIBC || (defined __STDC_VERSION__ && __STDC_VERSION__ >= 199901L))\n  memset (&mctx, '\\0', sizeof (re_match_context_t));\n  mctx.dfa = dfa;\n#endif\n\n  extra_nmatch = (nmatch > preg->re_nsub) ? nmatch - (preg->re_nsub + 1) : 0;\n  nmatch -= extra_nmatch;\n\n  /* Check if the DFA haven't been compiled.  */\n  if (BE (preg->used == 0 || dfa->init_state == NULL\n\t  || dfa->init_state_word == NULL || dfa->init_state_nl == NULL\n\t  || dfa->init_state_begbuf == NULL, 0))\n    return REG_NOMATCH;\n\n#ifdef DEBUG\n  /* We assume front-end functions already check them.  */\n  assert (0 <= last_start && last_start <= length);\n#endif\n\n  /* If initial states with non-begbuf contexts have no elements,\n     the regex must be anchored.  If preg->newline_anchor is set,\n     we'll never use init_state_nl, so do not check it.  */\n  if (dfa->init_state->nodes.nelem == 0\n      && dfa->init_state_word->nodes.nelem == 0\n      && (dfa->init_state_nl->nodes.nelem == 0\n\t  || !preg->newline_anchor))\n    {\n      if (start != 0 && last_start != 0)\n        return REG_NOMATCH;\n      start = last_start = 0;\n    }\n\n  /* We must check the longest matching, if nmatch > 0.  */\n  fl_longest_match = (nmatch != 0 || dfa->nbackref);\n\n  err = re_string_allocate (&mctx.input, string, length, dfa->nodes_len + 1,\n\t\t\t    preg->translate, (preg->syntax & RE_ICASE) != 0,\n\t\t\t    dfa);\n  if (BE (err != REG_NOERROR, 0))\n    goto free_return;\n  mctx.input.stop = stop;\n  mctx.input.raw_stop = stop;\n  mctx.input.newline_anchor = preg->newline_anchor;\n\n  err = match_ctx_init (&mctx, eflags, dfa->nbackref * 2);\n  if (BE (err != REG_NOERROR, 0))\n    goto free_return;\n\n  /* We will log all the DFA states through which the dfa pass,\n     if nmatch > 1, or this dfa has \"multibyte node\", which is a\n     back-reference or a node which can accept multibyte character or\n     multi character collating element.  */\n  if (nmatch > 1 || dfa->has_mb_node)\n    {\n      /* Avoid overflow.  */\n      if (BE ((MIN (IDX_MAX, SIZE_MAX / sizeof (re_dfastate_t *))\n               <= mctx.input.bufs_len), 0))\n\t{\n\t  err = REG_ESPACE;\n\t  goto free_return;\n\t}\n\n      mctx.state_log = re_malloc (re_dfastate_t *, mctx.input.bufs_len + 1);\n      if (BE (mctx.state_log == NULL, 0))\n\t{\n\t  err = REG_ESPACE;\n\t  goto free_return;\n\t}\n    }\n  else\n    mctx.state_log = NULL;\n\n  match_first = start;\n  mctx.input.tip_context = (eflags & REG_NOTBOL) ? CONTEXT_BEGBUF\n\t\t\t   : CONTEXT_NEWLINE | CONTEXT_BEGBUF;\n\n  /* Check incrementally whether the input string matches.  */\n  incr = (last_start < start) ? -1 : 1;\n  left_lim = (last_start < start) ? last_start : start;\n  right_lim = (last_start < start) ? start : last_start;\n  sb = dfa->mb_cur_max == 1;\n  match_kind =\n    (fastmap\n     ? ((sb || !(preg->syntax & RE_ICASE || t) ? 4 : 0)\n\t| (start <= last_start ? 2 : 0)\n\t| (t != NULL ? 1 : 0))\n     : 8);\n\n  for (;; match_first += incr)\n    {\n      err = REG_NOMATCH;\n      if (match_first < left_lim || right_lim < match_first)\n\tgoto free_return;\n\n      /* Advance as rapidly as possible through the string, until we\n\t find a plausible place to start matching.  This may be done\n\t with varying efficiency, so there are various possibilities:\n\t only the most common of them are specialized, in order to\n\t save on code size.  We use a switch statement for speed.  */\n      switch (match_kind)\n\t{\n\tcase 8:\n\t  /* No fastmap.  */\n\t  break;\n\n\tcase 7:\n\t  /* Fastmap with single-byte translation, match forward.  */\n\t  while (BE (match_first < right_lim, 1)\n\t\t && !fastmap[t[(unsigned char) string[match_first]]])\n\t    ++match_first;\n\t  goto forward_match_found_start_or_reached_end;\n\n\tcase 6:\n\t  /* Fastmap without translation, match forward.  */\n\t  while (BE (match_first < right_lim, 1)\n\t\t && !fastmap[(unsigned char) string[match_first]])\n\t    ++match_first;\n\n\tforward_match_found_start_or_reached_end:\n\t  if (BE (match_first == right_lim, 0))\n\t    {\n\t      ch = match_first >= length\n\t\t       ? 0 : (unsigned char) string[match_first];\n\t      if (!fastmap[t ? t[ch] : ch])\n\t\tgoto free_return;\n\t    }\n\t  break;\n\n\tcase 4:\n\tcase 5:\n\t  /* Fastmap without multi-byte translation, match backwards.  */\n\t  while (match_first >= left_lim)\n\t    {\n\t      ch = match_first >= length\n\t\t       ? 0 : (unsigned char) string[match_first];\n\t      if (fastmap[t ? t[ch] : ch])\n\t\tbreak;\n\t      --match_first;\n\t    }\n\t  if (match_first < left_lim)\n\t    goto free_return;\n\t  break;\n\n\tdefault:\n\t  /* In this case, we can't determine easily the current byte,\n\t     since it might be a component byte of a multibyte\n\t     character.  Then we use the constructed buffer instead.  */\n\t  for (;;)\n\t    {\n\t      /* If MATCH_FIRST is out of the valid range, reconstruct the\n\t\t buffers.  */\n\t      __re_size_t offset = match_first - mctx.input.raw_mbs_idx;\n\t      if (BE (offset >= (__re_size_t) mctx.input.valid_raw_len, 0))\n\t\t{\n\t\t  err = re_string_reconstruct (&mctx.input, match_first,\n\t\t\t\t\t       eflags);\n\t\t  if (BE (err != REG_NOERROR, 0))\n\t\t    goto free_return;\n\n\t\t  offset = match_first - mctx.input.raw_mbs_idx;\n\t\t}\n\t      /* If MATCH_FIRST is out of the buffer, leave it as '\\0'.\n\t\t Note that MATCH_FIRST must not be smaller than 0.  */\n\t      ch = (match_first >= length\n\t\t    ? 0 : re_string_byte_at (&mctx.input, offset));\n\t      if (fastmap[ch])\n\t\tbreak;\n\t      match_first += incr;\n\t      if (match_first < left_lim || match_first > right_lim)\n\t\t{\n\t\t  err = REG_NOMATCH;\n\t\t  goto free_return;\n\t\t}\n\t    }\n\t  break;\n\t}\n\n      /* Reconstruct the buffers so that the matcher can assume that\n\t the matching starts from the beginning of the buffer.  */\n      err = re_string_reconstruct (&mctx.input, match_first, eflags);\n      if (BE (err != REG_NOERROR, 0))\n\tgoto free_return;\n\n#ifdef RE_ENABLE_I18N\n     /* Don't consider this char as a possible match start if it part,\n\tyet isn't the head, of a multibyte character.  */\n      if (!sb && !re_string_first_byte (&mctx.input, 0))\n\tcontinue;\n#endif\n\n      /* It seems to be appropriate one, then use the matcher.  */\n      /* We assume that the matching starts from 0.  */\n      mctx.state_log_top = mctx.nbkref_ents = mctx.max_mb_elem_len = 0;\n      match_last = check_matching (&mctx, fl_longest_match,\n\t\t\t\t   start <= last_start ? &match_first : NULL);\n      if (match_last != REG_MISSING)\n\t{\n\t  if (BE (match_last == REG_ERROR, 0))\n\t    {\n\t      err = REG_ESPACE;\n\t      goto free_return;\n\t    }\n\t  else\n\t    {\n\t      mctx.match_last = match_last;\n\t      if ((!preg->no_sub && nmatch > 1) || dfa->nbackref)\n\t\t{\n\t\t  re_dfastate_t *pstate = mctx.state_log[match_last];\n\t\t  mctx.last_node = check_halt_state_context (&mctx, pstate,\n\t\t\t\t\t\t\t     match_last);\n\t\t}\n\t      if ((!preg->no_sub && nmatch > 1 && dfa->has_plural_match)\n\t\t  || dfa->nbackref)\n\t\t{\n\t\t  err = prune_impossible_nodes (&mctx);\n\t\t  if (err == REG_NOERROR)\n\t\t    break;\n\t\t  if (BE (err != REG_NOMATCH, 0))\n\t\t    goto free_return;\n\t\t  match_last = REG_MISSING;\n\t\t}\n\t      else\n\t\tbreak; /* We found a match.  */\n\t    }\n\t}\n\n      match_ctx_clean (&mctx);\n    }\n\n#ifdef DEBUG\n  assert (match_last != REG_MISSING);\n  assert (err == REG_NOERROR);\n#endif\n\n  /* Set pmatch[] if we need.  */\n  if (nmatch > 0)\n    {\n      Idx reg_idx;\n\n      /* Initialize registers.  */\n      for (reg_idx = 1; reg_idx < nmatch; ++reg_idx)\n\tpmatch[reg_idx].rm_so = pmatch[reg_idx].rm_eo = -1;\n\n      /* Set the points where matching start/end.  */\n      pmatch[0].rm_so = 0;\n      pmatch[0].rm_eo = mctx.match_last;\n      /* FIXME: This function should fail if mctx.match_last exceeds\n\t the maximum possible regoff_t value.  We need a new error\n\t code REG_OVERFLOW.  */\n\n      if (!preg->no_sub && nmatch > 1)\n\t{\n\t  err = set_regs (preg, &mctx, nmatch, pmatch,\n\t\t\t  dfa->has_plural_match && dfa->nbackref > 0);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    goto free_return;\n\t}\n\n      /* At last, add the offset to each register, since we slid\n\t the buffers so that we could assume that the matching starts\n\t from 0.  */\n      for (reg_idx = 0; reg_idx < nmatch; ++reg_idx)\n\tif (pmatch[reg_idx].rm_so != -1)\n\t  {\n#ifdef RE_ENABLE_I18N\n\t    if (BE (mctx.input.offsets_needed != 0, 0))\n\t      {\n\t\tpmatch[reg_idx].rm_so =\n\t\t  (pmatch[reg_idx].rm_so == mctx.input.valid_len\n\t\t   ? mctx.input.valid_raw_len\n\t\t   : mctx.input.offsets[pmatch[reg_idx].rm_so]);\n\t\tpmatch[reg_idx].rm_eo =\n\t\t  (pmatch[reg_idx].rm_eo == mctx.input.valid_len\n\t\t   ? mctx.input.valid_raw_len\n\t\t   : mctx.input.offsets[pmatch[reg_idx].rm_eo]);\n\t      }\n#else\n\t    assert (mctx.input.offsets_needed == 0);\n#endif\n\t    pmatch[reg_idx].rm_so += match_first;\n\t    pmatch[reg_idx].rm_eo += match_first;\n\t  }\n      for (reg_idx = 0; reg_idx < extra_nmatch; ++reg_idx)\n\t{\n\t  pmatch[nmatch + reg_idx].rm_so = -1;\n\t  pmatch[nmatch + reg_idx].rm_eo = -1;\n\t}\n\n      if (dfa->subexp_map)\n\tfor (reg_idx = 0; reg_idx + 1 < nmatch; reg_idx++)\n\t  if (dfa->subexp_map[reg_idx] != reg_idx)\n\t    {\n\t      pmatch[reg_idx + 1].rm_so\n\t\t= pmatch[dfa->subexp_map[reg_idx] + 1].rm_so;\n\t      pmatch[reg_idx + 1].rm_eo\n\t\t= pmatch[dfa->subexp_map[reg_idx] + 1].rm_eo;\n\t    }\n    }\n\n free_return:\n  re_free (mctx.state_log);\n  if (dfa->nbackref)\n    match_ctx_free (&mctx);\n  re_string_destruct (&mctx.input);\n  return err;\n}",
      "lines": 335,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "__attribute_warn_unused_result__",
        "__attribute_warn_unused_result__"
      ]
    },
    "prune_impossible_nodes": {
      "start_point": [
        965,
        0
      ],
      "end_point": [
        1055,
        1
      ],
      "content": "static reg_errcode_t\n__attribute_warn_unused_result__\nprune_impossible_nodes (re_match_context_t *mctx)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  Idx halt_node, match_last;\n  reg_errcode_t ret;\n  re_dfastate_t **sifted_states;\n  re_dfastate_t **lim_states = NULL;\n  re_sift_context_t sctx;\n#ifdef DEBUG\n  assert (mctx->state_log != NULL);\n#endif\n  match_last = mctx->match_last;\n  halt_node = mctx->last_node;\n\n  /* Avoid overflow.  */\n  if (BE (MIN (IDX_MAX, SIZE_MAX / sizeof (re_dfastate_t *)) <= match_last, 0))\n    return REG_ESPACE;\n\n  sifted_states = re_malloc (re_dfastate_t *, match_last + 1);\n  if (BE (sifted_states == NULL, 0))\n    {\n      ret = REG_ESPACE;\n      goto free_return;\n    }\n  if (dfa->nbackref)\n    {\n      lim_states = re_malloc (re_dfastate_t *, match_last + 1);\n      if (BE (lim_states == NULL, 0))\n\t{\n\t  ret = REG_ESPACE;\n\t  goto free_return;\n\t}\n      while (1)\n\t{\n\t  memset (lim_states, '\\0',\n\t\t  sizeof (re_dfastate_t *) * (match_last + 1));\n\t  sift_ctx_init (&sctx, sifted_states, lim_states, halt_node,\n\t\t\t match_last);\n\t  ret = sift_states_backward (mctx, &sctx);\n\t  re_node_set_free (&sctx.limits);\n\t  if (BE (ret != REG_NOERROR, 0))\n\t      goto free_return;\n\t  if (sifted_states[0] != NULL || lim_states[0] != NULL)\n\t    break;\n\t  do\n\t    {\n\t      --match_last;\n\t      if (! REG_VALID_INDEX (match_last))\n\t\t{\n\t\t  ret = REG_NOMATCH;\n\t\t  goto free_return;\n\t\t}\n\t    } while (mctx->state_log[match_last] == NULL\n\t\t     || !mctx->state_log[match_last]->halt);\n\t  halt_node = check_halt_state_context (mctx,\n\t\t\t\t\t\tmctx->state_log[match_last],\n\t\t\t\t\t\tmatch_last);\n\t}\n      ret = merge_state_array (dfa, sifted_states, lim_states,\n\t\t\t       match_last + 1);\n      re_free (lim_states);\n      lim_states = NULL;\n      if (BE (ret != REG_NOERROR, 0))\n\tgoto free_return;\n    }\n  else\n    {\n      sift_ctx_init (&sctx, sifted_states, lim_states, halt_node, match_last);\n      ret = sift_states_backward (mctx, &sctx);\n      re_node_set_free (&sctx.limits);\n      if (BE (ret != REG_NOERROR, 0))\n\tgoto free_return;\n      if (sifted_states[0] == NULL)\n\t{\n\t  ret = REG_NOMATCH;\n\t  goto free_return;\n\t}\n    }\n  re_free (mctx->state_log);\n  mctx->state_log = sifted_states;\n  sifted_states = NULL;\n  mctx->last_node = halt_node;\n  mctx->match_last = match_last;\n  ret = REG_NOERROR;\n free_return:\n  re_free (sifted_states);\n  re_free (lim_states);\n  return ret;\n}",
      "lines": 91,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "__attribute_warn_unused_result__",
        "__attribute_warn_unused_result__"
      ]
    },
    "acquire_init_state_context": {
      "start_point": [
        1062,
        32
      ],
      "end_point": [
        1092,
        1
      ],
      "content": "internal_function\nacquire_init_state_context (reg_errcode_t *err, const re_match_context_t *mctx,\n\t\t\t    Idx idx)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  if (dfa->init_state->has_constraint)\n    {\n      unsigned int context;\n      context = re_string_context_at (&mctx->input, idx - 1, mctx->eflags);\n      if (IS_WORD_CONTEXT (context))\n\treturn dfa->init_state_word;\n      else if (IS_ORDINARY_CONTEXT (context))\n\treturn dfa->init_state;\n      else if (IS_BEGBUF_CONTEXT (context) && IS_NEWLINE_CONTEXT (context))\n\treturn dfa->init_state_begbuf;\n      else if (IS_NEWLINE_CONTEXT (context))\n\treturn dfa->init_state_nl;\n      else if (IS_BEGBUF_CONTEXT (context))\n\t{\n\t  /* It is relatively rare case, then calculate on demand.  */\n\t  return re_acquire_state_context (err, dfa,\n\t\t\t\t\t   dfa->init_state->entrance_nodes,\n\t\t\t\t\t   context);\n\t}\n      else\n\t/* Must not happen?  */\n\treturn dfa->init_state;\n    }\n  else\n    return dfa->init_state;\n}",
      "lines": 31,
      "depth": 16,
      "decorators": [
        "internal_function"
      ]
    },
    "check_matching": {
      "start_point": [
        1104,
        18
      ],
      "end_point": [
        1232,
        1
      ],
      "content": "__attribute_warn_unused_result__\ncheck_matching (re_match_context_t *mctx, bool fl_longest_match,\n\t\tIdx *p_match_first)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  reg_errcode_t err;\n  Idx match = 0;\n  Idx match_last = REG_MISSING;\n  Idx cur_str_idx = re_string_cur_idx (&mctx->input);\n  re_dfastate_t *cur_state;\n  bool at_init_state = p_match_first != NULL;\n  Idx next_start_idx = cur_str_idx;\n\n  err = REG_NOERROR;\n  cur_state = acquire_init_state_context (&err, mctx, cur_str_idx);\n  /* An initial state must not be NULL (invalid).  */\n  if (BE (cur_state == NULL, 0))\n    {\n      assert (err == REG_ESPACE);\n      return REG_ERROR;\n    }\n\n  if (mctx->state_log != NULL)\n    {\n      mctx->state_log[cur_str_idx] = cur_state;\n\n      /* Check OP_OPEN_SUBEXP in the initial state in case that we use them\n\t later.  E.g. Processing back references.  */\n      if (BE (dfa->nbackref, 0))\n\t{\n\t  at_init_state = false;\n\t  err = check_subexp_matching_top (mctx, &cur_state->nodes, 0);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return err;\n\n\t  if (cur_state->has_backref)\n\t    {\n\t      err = transit_state_bkref (mctx, &cur_state->nodes);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\treturn err;\n\t    }\n\t}\n    }\n\n  /* If the RE accepts NULL string.  */\n  if (BE (cur_state->halt, 0))\n    {\n      if (!cur_state->has_constraint\n\t  || check_halt_state_context (mctx, cur_state, cur_str_idx))\n\t{\n\t  if (!fl_longest_match)\n\t    return cur_str_idx;\n\t  else\n\t    {\n\t      match_last = cur_str_idx;\n\t      match = 1;\n\t    }\n\t}\n    }\n\n  while (!re_string_eoi (&mctx->input))\n    {\n      re_dfastate_t *old_state = cur_state;\n      Idx next_char_idx = re_string_cur_idx (&mctx->input) + 1;\n\n      if ((BE (next_char_idx >= mctx->input.bufs_len, 0)\n\t   && mctx->input.bufs_len < mctx->input.len)\n\t  || (BE (next_char_idx >= mctx->input.valid_len, 0)\n\t      && mctx->input.valid_len < mctx->input.len))\n\t{\n\t  err = extend_buffers (mctx, next_char_idx + 1);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    {\n\t      assert (err == REG_ESPACE);\n\t      return REG_ERROR;\n\t    }\n\t}\n\n      cur_state = transit_state (&err, mctx, cur_state);\n      if (mctx->state_log != NULL)\n\tcur_state = merge_state_with_log (&err, mctx, cur_state);\n\n      if (cur_state == NULL)\n\t{\n\t  /* Reached the invalid state or an error.  Try to recover a valid\n\t     state using the state log, if available and if we have not\n\t     already found a valid (even if not the longest) match.  */\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return REG_ERROR;\n\n\t  if (mctx->state_log == NULL\n\t      || (match && !fl_longest_match)\n\t      || (cur_state = find_recover_state (&err, mctx)) == NULL)\n\t    break;\n\t}\n\n      if (BE (at_init_state, 0))\n\t{\n\t  if (old_state == cur_state)\n\t    next_start_idx = next_char_idx;\n\t  else\n\t    at_init_state = false;\n\t}\n\n      if (cur_state->halt)\n\t{\n\t  /* Reached a halt state.\n\t     Check the halt state can satisfy the current context.  */\n\t  if (!cur_state->has_constraint\n\t      || check_halt_state_context (mctx, cur_state,\n\t\t\t\t\t   re_string_cur_idx (&mctx->input)))\n\t    {\n\t      /* We found an appropriate halt state.  */\n\t      match_last = re_string_cur_idx (&mctx->input);\n\t      match = 1;\n\n\t      /* We found a match, do not modify match_first below.  */\n\t      p_match_first = NULL;\n\t      if (!fl_longest_match)\n\t\tbreak;\n\t    }\n\t}\n    }\n\n  if (p_match_first)\n    *p_match_first += next_start_idx;\n\n  return match_last;\n}",
      "lines": 129,
      "depth": 16,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "check_halt_node_context": {
      "start_point": [
        1236,
        0
      ],
      "end_point": [
        1249,
        1
      ],
      "content": "static bool\ninternal_function\ncheck_halt_node_context (const re_dfa_t *dfa, Idx node, unsigned int context)\n{\n  re_token_type_t type = dfa->nodes[node].type;\n  unsigned int constraint = dfa->nodes[node].constraint;\n  if (type != END_OF_RE)\n    return false;\n  if (!constraint)\n    return true;\n  if (NOT_SATISFY_NEXT_CONSTRAINT (constraint, context))\n    return false;\n  return true;\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "bool",
        "internal_function",
        "internal_function"
      ]
    },
    "check_halt_state_context": {
      "start_point": [
        1255,
        0
      ],
      "end_point": [
        1270,
        1
      ],
      "content": "static Idx\ninternal_function\ncheck_halt_state_context (const re_match_context_t *mctx,\n\t\t\t  const re_dfastate_t *state, Idx idx)\n{\n  Idx i;\n  unsigned int context;\n#ifdef DEBUG\n  assert (state->halt);\n#endif\n  context = re_string_context_at (&mctx->input, idx, mctx->eflags);\n  for (i = 0; i < state->nodes.nelem; ++i)\n    if (check_halt_node_context (mctx->dfa, state->nodes.elems[i], context))\n      return state->nodes.elems[i];\n  return 0;\n}",
      "lines": 16,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "Idx",
        "internal_function",
        "internal_function"
      ]
    },
    "proceed_next_node": {
      "start_point": [
        1277,
        0
      ],
      "end_point": [
        1377,
        1
      ],
      "content": "static Idx\ninternal_function\nproceed_next_node (const re_match_context_t *mctx, Idx nregs, regmatch_t *regs,\n\t\t   Idx *pidx, Idx node, re_node_set *eps_via_nodes,\n\t\t   struct re_fail_stack_t *fs)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  Idx i;\n  bool ok;\n  if (IS_EPSILON_NODE (dfa->nodes[node].type))\n    {\n      re_node_set *cur_nodes = &mctx->state_log[*pidx]->nodes;\n      re_node_set *edests = &dfa->edests[node];\n      Idx dest_node;\n      ok = re_node_set_insert (eps_via_nodes, node);\n      if (BE (! ok, 0))\n\treturn REG_ERROR;\n      /* Pick up a valid destination, or return REG_MISSING if none\n\t is found.  */\n      for (dest_node = REG_MISSING, i = 0; i < edests->nelem; ++i)\n\t{\n\t  Idx candidate = edests->elems[i];\n\t  if (!re_node_set_contains (cur_nodes, candidate))\n\t    continue;\n          if (dest_node == REG_MISSING)\n\t    dest_node = candidate;\n\n\t  else\n\t    {\n\t      /* In order to avoid infinite loop like \"(a*)*\", return the second\n\t\t epsilon-transition if the first was already considered.  */\n\t      if (re_node_set_contains (eps_via_nodes, dest_node))\n\t\treturn candidate;\n\n\t      /* Otherwise, push the second epsilon-transition on the fail stack.  */\n\t      else if (fs != NULL\n\t\t       && push_fail_stack (fs, *pidx, candidate, nregs, regs,\n\t\t\t\t\t   eps_via_nodes))\n\t\treturn REG_ERROR;\n\n\t      /* We know we are going to exit.  */\n\t      break;\n\t    }\n\t}\n      return dest_node;\n    }\n  else\n    {\n      Idx naccepted = 0;\n      re_token_type_t type = dfa->nodes[node].type;\n\n#ifdef RE_ENABLE_I18N\n      if (dfa->nodes[node].accept_mb)\n\tnaccepted = check_node_accept_bytes (dfa, node, &mctx->input, *pidx);\n      else\n#endif /* RE_ENABLE_I18N */\n      if (type == OP_BACK_REF)\n\t{\n\t  Idx subexp_idx = dfa->nodes[node].opr.idx + 1;\n\t  naccepted = regs[subexp_idx].rm_eo - regs[subexp_idx].rm_so;\n\t  if (fs != NULL)\n\t    {\n\t      if (regs[subexp_idx].rm_so == -1 || regs[subexp_idx].rm_eo == -1)\n\t\treturn REG_MISSING;\n\t      else if (naccepted)\n\t\t{\n\t\t  char *buf = (char *) re_string_get_buffer (&mctx->input);\n\t\t  if (memcmp (buf + regs[subexp_idx].rm_so, buf + *pidx,\n\t\t\t      naccepted) != 0)\n\t\t    return REG_MISSING;\n\t\t}\n\t    }\n\n\t  if (naccepted == 0)\n\t    {\n\t      Idx dest_node;\n\t      ok = re_node_set_insert (eps_via_nodes, node);\n\t      if (BE (! ok, 0))\n\t\treturn REG_ERROR;\n\t      dest_node = dfa->edests[node].elems[0];\n\t      if (re_node_set_contains (&mctx->state_log[*pidx]->nodes,\n\t\t\t\t\tdest_node))\n\t\treturn dest_node;\n\t    }\n\t}\n\n      if (naccepted != 0\n\t  || check_node_accept (mctx, dfa->nodes + node, *pidx))\n\t{\n\t  Idx dest_node = dfa->nexts[node];\n\t  *pidx = (naccepted == 0) ? *pidx + 1 : *pidx + naccepted;\n\t  if (fs && (*pidx > mctx->match_last || mctx->state_log[*pidx] == NULL\n\t\t     || !re_node_set_contains (&mctx->state_log[*pidx]->nodes,\n\t\t\t\t\t       dest_node)))\n\t    return REG_MISSING;\n\t  re_node_set_empty (eps_via_nodes);\n\t  return dest_node;\n\t}\n    }\n  return REG_MISSING;\n}",
      "lines": 101,
      "depth": 20,
      "decorators": [
        "static",
        "static",
        "Idx",
        "internal_function",
        "internal_function"
      ]
    },
    "push_fail_stack": {
      "start_point": [
        1380,
        18
      ],
      "end_point": [
        1404,
        1
      ],
      "content": "__attribute_warn_unused_result__\npush_fail_stack (struct re_fail_stack_t *fs, Idx str_idx, Idx dest_node,\n\t\t Idx nregs, regmatch_t *regs, re_node_set *eps_via_nodes)\n{\n  reg_errcode_t err;\n  Idx num = fs->num++;\n  if (fs->num == fs->alloc)\n    {\n      struct re_fail_stack_ent_t *new_array;\n      new_array = realloc (fs->stack, (sizeof (struct re_fail_stack_ent_t)\n\t\t\t\t       * fs->alloc * 2));\n      if (new_array == NULL)\n\treturn REG_ESPACE;\n      fs->alloc *= 2;\n      fs->stack = new_array;\n    }\n  fs->stack[num].idx = str_idx;\n  fs->stack[num].node = dest_node;\n  fs->stack[num].regs = re_malloc (regmatch_t, nregs);\n  if (fs->stack[num].regs == NULL)\n    return REG_ESPACE;\n  memcpy (fs->stack[num].regs, regs, sizeof (regmatch_t) * nregs);\n  err = re_node_set_init_copy (&fs->stack[num].eps_via_nodes, eps_via_nodes);\n  return err;\n}",
      "lines": 25,
      "depth": 15,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "pop_fail_stack": {
      "start_point": [
        1406,
        0
      ],
      "end_point": [
        1419,
        1
      ],
      "content": "static Idx\ninternal_function\npop_fail_stack (struct re_fail_stack_t *fs, Idx *pidx, Idx nregs,\n\t\tregmatch_t *regs, re_node_set *eps_via_nodes)\n{\n  Idx num = --fs->num;\n  assert (REG_VALID_INDEX (num));\n  *pidx = fs->stack[num].idx;\n  memcpy (regs, fs->stack[num].regs, sizeof (regmatch_t) * nregs);\n  re_node_set_free (eps_via_nodes);\n  re_free (fs->stack[num].regs);\n  *eps_via_nodes = fs->stack[num].eps_via_nodes;\n  return fs->stack[num].node;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "Idx",
        "internal_function",
        "internal_function"
      ]
    },
    "set_regs": {
      "start_point": [
        1427,
        18
      ],
      "end_point": [
        1531,
        1
      ],
      "content": "__attribute_warn_unused_result__\nset_regs (const regex_t *preg, const re_match_context_t *mctx, size_t nmatch,\n\t  regmatch_t *pmatch, bool fl_backtrack)\n{\n  const re_dfa_t *dfa = preg->buffer;\n  Idx idx, cur_node;\n  re_node_set eps_via_nodes;\n  struct re_fail_stack_t *fs;\n  struct re_fail_stack_t fs_body = { 0, 2, NULL };\n  regmatch_t *prev_idx_match;\n  bool prev_idx_match_malloced = false;\n\n#ifdef DEBUG\n  assert (nmatch > 1);\n  assert (mctx->state_log != NULL);\n#endif\n  if (fl_backtrack)\n    {\n      fs = &fs_body;\n      fs->stack = re_malloc (struct re_fail_stack_ent_t, fs->alloc);\n      if (fs->stack == NULL)\n\treturn REG_ESPACE;\n    }\n  else\n    fs = NULL;\n\n  cur_node = dfa->init_node;\n  re_node_set_init_empty (&eps_via_nodes);\n\n  if (__libc_use_alloca (nmatch * sizeof (regmatch_t)))\n    prev_idx_match = (regmatch_t *) alloca (nmatch * sizeof (regmatch_t));\n  else\n    {\n      prev_idx_match = re_malloc (regmatch_t, nmatch);\n      if (prev_idx_match == NULL)\n\t{\n\t  free_fail_stack_return (fs);\n\t  return REG_ESPACE;\n\t}\n      prev_idx_match_malloced = true;\n    }\n  memcpy (prev_idx_match, pmatch, sizeof (regmatch_t) * nmatch);\n\n  for (idx = pmatch[0].rm_so; idx <= pmatch[0].rm_eo ;)\n    {\n      update_regs (dfa, pmatch, prev_idx_match, cur_node, idx, nmatch);\n\n      if (idx == pmatch[0].rm_eo && cur_node == mctx->last_node)\n\t{\n\t  Idx reg_idx;\n\t  if (fs)\n\t    {\n\t      for (reg_idx = 0; reg_idx < nmatch; ++reg_idx)\n\t\tif (pmatch[reg_idx].rm_so > -1 && pmatch[reg_idx].rm_eo == -1)\n\t\t  break;\n\t      if (reg_idx == nmatch)\n\t\t{\n\t\t  re_node_set_free (&eps_via_nodes);\n\t\t  if (prev_idx_match_malloced)\n\t\t    re_free (prev_idx_match);\n\t\t  return free_fail_stack_return (fs);\n\t\t}\n\t      cur_node = pop_fail_stack (fs, &idx, nmatch, pmatch,\n\t\t\t\t\t &eps_via_nodes);\n\t    }\n\t  else\n\t    {\n\t      re_node_set_free (&eps_via_nodes);\n\t      if (prev_idx_match_malloced)\n\t\tre_free (prev_idx_match);\n\t      return REG_NOERROR;\n\t    }\n\t}\n\n      /* Proceed to next node.  */\n      cur_node = proceed_next_node (mctx, nmatch, pmatch, &idx, cur_node,\n\t\t\t\t    &eps_via_nodes, fs);\n\n      if (BE (! REG_VALID_INDEX (cur_node), 0))\n\t{\n\t  if (BE (cur_node == REG_ERROR, 0))\n\t    {\n\t      re_node_set_free (&eps_via_nodes);\n\t      if (prev_idx_match_malloced)\n\t\tre_free (prev_idx_match);\n\t      free_fail_stack_return (fs);\n\t      return REG_ESPACE;\n\t    }\n\t  if (fs)\n\t    cur_node = pop_fail_stack (fs, &idx, nmatch, pmatch,\n\t\t\t\t       &eps_via_nodes);\n\t  else\n\t    {\n\t      re_node_set_free (&eps_via_nodes);\n\t      if (prev_idx_match_malloced)\n\t\tre_free (prev_idx_match);\n\t      return REG_NOMATCH;\n\t    }\n\t}\n    }\n  re_node_set_free (&eps_via_nodes);\n  if (prev_idx_match_malloced)\n    re_free (prev_idx_match);\n  return free_fail_stack_return (fs);\n}",
      "lines": 105,
      "depth": 16,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "free_fail_stack_return": {
      "start_point": [
        1533,
        0
      ],
      "end_point": [
        1548,
        1
      ],
      "content": "static reg_errcode_t\ninternal_function\nfree_fail_stack_return (struct re_fail_stack_t *fs)\n{\n  if (fs)\n    {\n      Idx fs_idx;\n      for (fs_idx = 0; fs_idx < fs->num; ++fs_idx)\n\t{\n\t  re_node_set_free (&fs->stack[fs_idx].eps_via_nodes);\n\t  re_free (fs->stack[fs_idx].regs);\n\t}\n      re_free (fs->stack);\n    }\n  return REG_NOERROR;\n}",
      "lines": 16,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "internal_function",
        "internal_function"
      ]
    },
    "update_regs": {
      "start_point": [
        1550,
        0
      ],
      "end_point": [
        1597,
        1
      ],
      "content": "static void\ninternal_function\nupdate_regs (const re_dfa_t *dfa, regmatch_t *pmatch,\n\t     regmatch_t *prev_idx_match, Idx cur_node, Idx cur_idx, Idx nmatch)\n{\n  int type = dfa->nodes[cur_node].type;\n  if (type == OP_OPEN_SUBEXP)\n    {\n      Idx reg_num = dfa->nodes[cur_node].opr.idx + 1;\n\n      /* We are at the first node of this sub expression.  */\n      if (reg_num < nmatch)\n\t{\n\t  pmatch[reg_num].rm_so = cur_idx;\n\t  pmatch[reg_num].rm_eo = -1;\n\t}\n    }\n  else if (type == OP_CLOSE_SUBEXP)\n    {\n      Idx reg_num = dfa->nodes[cur_node].opr.idx + 1;\n      if (reg_num < nmatch)\n\t{\n\t  /* We are at the last node of this sub expression.  */\n\t  if (pmatch[reg_num].rm_so < cur_idx)\n\t    {\n\t      pmatch[reg_num].rm_eo = cur_idx;\n\t      /* This is a non-empty match or we are not inside an optional\n\t\t subexpression.  Accept this right away.  */\n\t      memcpy (prev_idx_match, pmatch, sizeof (regmatch_t) * nmatch);\n\t    }\n\t  else\n\t    {\n\t      if (dfa->nodes[cur_node].opt_subexp\n\t\t  && prev_idx_match[reg_num].rm_so != -1)\n\t\t/* We transited through an empty match for an optional\n\t\t   subexpression, like (a?)*, and this is not the subexp's\n\t\t   first match.  Copy back the old content of the registers\n\t\t   so that matches of an inner subexpression are undone as\n\t\t   well, like in ((a?))*.  */\n\t\tmemcpy (pmatch, prev_idx_match, sizeof (regmatch_t) * nmatch);\n\t      else\n\t\t/* We completed a subexpression, but it may be part of\n\t\t   an optional one, so do not update PREV_IDX_MATCH.  */\n\t\tpmatch[reg_num].rm_eo = cur_idx;\n\t    }\n\t}\n    }\n}",
      "lines": 48,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "void",
        "internal_function",
        "internal_function"
      ]
    },
    "sift_states_backward": {
      "start_point": [
        1622,
        0
      ],
      "end_point": [
        1678,
        1
      ],
      "content": "static reg_errcode_t\ninternal_function\nsift_states_backward (const re_match_context_t *mctx, re_sift_context_t *sctx)\n{\n  reg_errcode_t err;\n  int null_cnt = 0;\n  Idx str_idx = sctx->last_str_idx;\n  re_node_set cur_dest;\n\n#ifdef DEBUG\n  assert (mctx->state_log != NULL && mctx->state_log[str_idx] != NULL);\n#endif\n\n  /* Build sifted state_log[str_idx].  It has the nodes which can epsilon\n     transit to the last_node and the last_node itself.  */\n  err = re_node_set_init_1 (&cur_dest, sctx->last_node);\n  if (BE (err != REG_NOERROR, 0))\n    return err;\n  err = update_cur_sifted_state (mctx, sctx, str_idx, &cur_dest);\n  if (BE (err != REG_NOERROR, 0))\n    goto free_return;\n\n  /* Then check each states in the state_log.  */\n  while (str_idx > 0)\n    {\n      /* Update counters.  */\n      null_cnt = (sctx->sifted_states[str_idx] == NULL) ? null_cnt + 1 : 0;\n      if (null_cnt > mctx->max_mb_elem_len)\n\t{\n\t  memset (sctx->sifted_states, '\\0',\n\t\t  sizeof (re_dfastate_t *) * str_idx);\n\t  re_node_set_free (&cur_dest);\n\t  return REG_NOERROR;\n\t}\n      re_node_set_empty (&cur_dest);\n      --str_idx;\n\n      if (mctx->state_log[str_idx])\n\t{\n\t  err = build_sifted_states (mctx, sctx, str_idx, &cur_dest);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    goto free_return;\n\t}\n\n      /* Add all the nodes which satisfy the following conditions:\n\t - It can epsilon transit to a node in CUR_DEST.\n\t - It is in CUR_SRC.\n\t And update state_log.  */\n      err = update_cur_sifted_state (mctx, sctx, str_idx, &cur_dest);\n      if (BE (err != REG_NOERROR, 0))\n\tgoto free_return;\n    }\n  err = REG_NOERROR;\n free_return:\n  re_node_set_free (&cur_dest);\n  return err;\n}",
      "lines": 57,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "internal_function",
        "internal_function"
      ]
    },
    "build_sifted_states": {
      "start_point": [
        1681,
        18
      ],
      "end_point": [
        1738,
        1
      ],
      "content": "__attribute_warn_unused_result__\nbuild_sifted_states (const re_match_context_t *mctx, re_sift_context_t *sctx,\n\t\t     Idx str_idx, re_node_set *cur_dest)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  const re_node_set *cur_src = &mctx->state_log[str_idx]->non_eps_nodes;\n  Idx i;\n\n  /* Then build the next sifted state.\n     We build the next sifted state on 'cur_dest', and update\n     'sifted_states[str_idx]' with 'cur_dest'.\n     Note:\n     'cur_dest' is the sifted state from 'state_log[str_idx + 1]'.\n     'cur_src' points the node_set of the old 'state_log[str_idx]'\n     (with the epsilon nodes pre-filtered out).  */\n  for (i = 0; i < cur_src->nelem; i++)\n    {\n      Idx prev_node = cur_src->elems[i];\n      int naccepted = 0;\n      bool ok;\n\n#ifdef DEBUG\n      re_token_type_t type = dfa->nodes[prev_node].type;\n      assert (!IS_EPSILON_NODE (type));\n#endif\n#ifdef RE_ENABLE_I18N\n      /* If the node may accept \"multi byte\".  */\n      if (dfa->nodes[prev_node].accept_mb)\n\tnaccepted = sift_states_iter_mb (mctx, sctx, prev_node,\n\t\t\t\t\t str_idx, sctx->last_str_idx);\n#endif /* RE_ENABLE_I18N */\n\n      /* We don't check backreferences here.\n\t See update_cur_sifted_state().  */\n      if (!naccepted\n\t  && check_node_accept (mctx, dfa->nodes + prev_node, str_idx)\n\t  && STATE_NODE_CONTAINS (sctx->sifted_states[str_idx + 1],\n\t\t\t\t  dfa->nexts[prev_node]))\n\tnaccepted = 1;\n\n      if (naccepted == 0)\n\tcontinue;\n\n      if (sctx->limits.nelem)\n\t{\n\t  Idx to_idx = str_idx + naccepted;\n\t  if (check_dst_limits (mctx, &sctx->limits,\n\t\t\t\tdfa->nexts[prev_node], to_idx,\n\t\t\t\tprev_node, str_idx))\n\t    continue;\n\t}\n      ok = re_node_set_insert (cur_dest, prev_node);\n      if (BE (! ok, 0))\n\treturn REG_ESPACE;\n    }\n\n  return REG_NOERROR;\n}",
      "lines": 58,
      "depth": 13,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "clean_state_log_if_needed": {
      "start_point": [
        1742,
        0
      ],
      "end_point": [
        1766,
        1
      ],
      "content": "static reg_errcode_t\ninternal_function\nclean_state_log_if_needed (re_match_context_t *mctx, Idx next_state_log_idx)\n{\n  Idx top = mctx->state_log_top;\n\n  if ((next_state_log_idx >= mctx->input.bufs_len\n       && mctx->input.bufs_len < mctx->input.len)\n      || (next_state_log_idx >= mctx->input.valid_len\n\t  && mctx->input.valid_len < mctx->input.len))\n    {\n      reg_errcode_t err;\n      err = extend_buffers (mctx, next_state_log_idx + 1);\n      if (BE (err != REG_NOERROR, 0))\n\treturn err;\n    }\n\n  if (top < next_state_log_idx)\n    {\n      memset (mctx->state_log + top + 1, '\\0',\n\t      sizeof (re_dfastate_t *) * (next_state_log_idx - top));\n      mctx->state_log_top = next_state_log_idx;\n    }\n  return REG_NOERROR;\n}",
      "lines": 25,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "internal_function",
        "internal_function"
      ]
    },
    "merge_state_array": {
      "start_point": [
        1768,
        0
      ],
      "end_point": [
        1793,
        1
      ],
      "content": "static reg_errcode_t\ninternal_function\nmerge_state_array (const re_dfa_t *dfa, re_dfastate_t **dst,\n\t\t   re_dfastate_t **src, Idx num)\n{\n  Idx st_idx;\n  reg_errcode_t err;\n  for (st_idx = 0; st_idx < num; ++st_idx)\n    {\n      if (dst[st_idx] == NULL)\n\tdst[st_idx] = src[st_idx];\n      else if (src[st_idx] != NULL)\n\t{\n\t  re_node_set merged_set;\n\t  err = re_node_set_init_union (&merged_set, &dst[st_idx]->nodes,\n\t\t\t\t\t&src[st_idx]->nodes);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return err;\n\t  dst[st_idx] = re_acquire_state (&err, dfa, &merged_set);\n\t  re_node_set_free (&merged_set);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return err;\n\t}\n    }\n  return REG_NOERROR;\n}",
      "lines": 26,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "internal_function",
        "internal_function"
      ]
    },
    "update_cur_sifted_state": {
      "start_point": [
        1795,
        0
      ],
      "end_point": [
        1841,
        1
      ],
      "content": "static reg_errcode_t\ninternal_function\nupdate_cur_sifted_state (const re_match_context_t *mctx,\n\t\t\t re_sift_context_t *sctx, Idx str_idx,\n\t\t\t re_node_set *dest_nodes)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  reg_errcode_t err = REG_NOERROR;\n  const re_node_set *candidates;\n  candidates = ((mctx->state_log[str_idx] == NULL) ? NULL\n\t\t: &mctx->state_log[str_idx]->nodes);\n\n  if (dest_nodes->nelem == 0)\n    sctx->sifted_states[str_idx] = NULL;\n  else\n    {\n      if (candidates)\n\t{\n\t  /* At first, add the nodes which can epsilon transit to a node in\n\t     DEST_NODE.  */\n\t  err = add_epsilon_src_nodes (dfa, dest_nodes, candidates);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return err;\n\n\t  /* Then, check the limitations in the current sift_context.  */\n\t  if (sctx->limits.nelem)\n\t    {\n\t      err = check_subexp_limits (dfa, dest_nodes, candidates, &sctx->limits,\n\t\t\t\t\t mctx->bkref_ents, str_idx);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\treturn err;\n\t    }\n\t}\n\n      sctx->sifted_states[str_idx] = re_acquire_state (&err, dfa, dest_nodes);\n      if (BE (err != REG_NOERROR, 0))\n\treturn err;\n    }\n\n  if (candidates && mctx->state_log[str_idx]->has_backref)\n    {\n      err = sift_states_bkref (mctx, sctx, str_idx, candidates);\n      if (BE (err != REG_NOERROR, 0))\n\treturn err;\n    }\n  return REG_NOERROR;\n}",
      "lines": 47,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "internal_function",
        "internal_function"
      ]
    },
    "add_epsilon_src_nodes": {
      "start_point": [
        1844,
        18
      ],
      "end_point": [
        1870,
        1
      ],
      "content": "__attribute_warn_unused_result__\nadd_epsilon_src_nodes (const re_dfa_t *dfa, re_node_set *dest_nodes,\n\t\t       const re_node_set *candidates)\n{\n  reg_errcode_t err = REG_NOERROR;\n  Idx i;\n\n  re_dfastate_t *state = re_acquire_state (&err, dfa, dest_nodes);\n  if (BE (err != REG_NOERROR, 0))\n    return err;\n\n  if (!state->inveclosure.alloc)\n    {\n      err = re_node_set_alloc (&state->inveclosure, dest_nodes->nelem);\n      if (BE (err != REG_NOERROR, 0))\n\treturn REG_ESPACE;\n      for (i = 0; i < dest_nodes->nelem; i++)\n\t{\n\t  err = re_node_set_merge (&state->inveclosure,\n\t\t\t\t   dfa->inveclosures + dest_nodes->elems[i]);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return REG_ESPACE;\n\t}\n    }\n  return re_node_set_add_intersect (dest_nodes, candidates,\n\t\t\t\t    &state->inveclosure);\n}",
      "lines": 27,
      "depth": 14,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "sub_epsilon_src_nodes": {
      "start_point": [
        1872,
        0
      ],
      "end_point": [
        1919,
        1
      ],
      "content": "static reg_errcode_t\ninternal_function\nsub_epsilon_src_nodes (const re_dfa_t *dfa, Idx node, re_node_set *dest_nodes,\n\t\t       const re_node_set *candidates)\n{\n    Idx ecl_idx;\n    reg_errcode_t err;\n    re_node_set *inv_eclosure = dfa->inveclosures + node;\n    re_node_set except_nodes;\n    re_node_set_init_empty (&except_nodes);\n    for (ecl_idx = 0; ecl_idx < inv_eclosure->nelem; ++ecl_idx)\n      {\n\tIdx cur_node = inv_eclosure->elems[ecl_idx];\n\tif (cur_node == node)\n\t  continue;\n\tif (IS_EPSILON_NODE (dfa->nodes[cur_node].type))\n\t  {\n\t    Idx edst1 = dfa->edests[cur_node].elems[0];\n\t    Idx edst2 = ((dfa->edests[cur_node].nelem > 1)\n\t\t\t ? dfa->edests[cur_node].elems[1] : REG_MISSING);\n\t    if ((!re_node_set_contains (inv_eclosure, edst1)\n\t\t && re_node_set_contains (dest_nodes, edst1))\n\t\t|| (REG_VALID_NONZERO_INDEX (edst2)\n\t\t    && !re_node_set_contains (inv_eclosure, edst2)\n\t\t    && re_node_set_contains (dest_nodes, edst2)))\n\t      {\n\t\terr = re_node_set_add_intersect (&except_nodes, candidates,\n\t\t\t\t\t\t dfa->inveclosures + cur_node);\n\t\tif (BE (err != REG_NOERROR, 0))\n\t\t  {\n\t\t    re_node_set_free (&except_nodes);\n\t\t    return err;\n\t\t  }\n\t      }\n\t  }\n      }\n    for (ecl_idx = 0; ecl_idx < inv_eclosure->nelem; ++ecl_idx)\n      {\n\tIdx cur_node = inv_eclosure->elems[ecl_idx];\n\tif (!re_node_set_contains (&except_nodes, cur_node))\n\t  {\n\t    Idx idx = re_node_set_contains (dest_nodes, cur_node) - 1;\n\t    re_node_set_remove_at (dest_nodes, idx);\n\t  }\n      }\n    re_node_set_free (&except_nodes);\n    return REG_NOERROR;\n}",
      "lines": 48,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "internal_function",
        "internal_function"
      ]
    },
    "check_dst_limits": {
      "start_point": [
        1921,
        0
      ],
      "end_point": [
        1955,
        1
      ],
      "content": "static bool\ninternal_function\ncheck_dst_limits (const re_match_context_t *mctx, const re_node_set *limits,\n\t\t  Idx dst_node, Idx dst_idx, Idx src_node, Idx src_idx)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  Idx lim_idx, src_pos, dst_pos;\n\n  Idx dst_bkref_idx = search_cur_bkref_entry (mctx, dst_idx);\n  Idx src_bkref_idx = search_cur_bkref_entry (mctx, src_idx);\n  for (lim_idx = 0; lim_idx < limits->nelem; ++lim_idx)\n    {\n      Idx subexp_idx;\n      struct re_backref_cache_entry *ent;\n      ent = mctx->bkref_ents + limits->elems[lim_idx];\n      subexp_idx = dfa->nodes[ent->node].opr.idx;\n\n      dst_pos = check_dst_limits_calc_pos (mctx, limits->elems[lim_idx],\n\t\t\t\t\t   subexp_idx, dst_node, dst_idx,\n\t\t\t\t\t   dst_bkref_idx);\n      src_pos = check_dst_limits_calc_pos (mctx, limits->elems[lim_idx],\n\t\t\t\t\t   subexp_idx, src_node, src_idx,\n\t\t\t\t\t   src_bkref_idx);\n\n      /* In case of:\n\t <src> <dst> ( <subexp> )\n\t ( <subexp> ) <src> <dst>\n\t ( <subexp1> <src> <subexp2> <dst> <subexp3> )  */\n      if (src_pos == dst_pos)\n\tcontinue; /* This is unrelated limitation.  */\n      else\n\treturn true;\n    }\n  return false;\n}",
      "lines": 35,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "bool",
        "internal_function",
        "internal_function"
      ]
    },
    "check_dst_limits_calc_pos_1": {
      "start_point": [
        1957,
        0
      ],
      "end_point": [
        2037,
        1
      ],
      "content": "static int\ninternal_function\ncheck_dst_limits_calc_pos_1 (const re_match_context_t *mctx, int boundaries,\n\t\t\t     Idx subexp_idx, Idx from_node, Idx bkref_idx)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  const re_node_set *eclosures = dfa->eclosures + from_node;\n  Idx node_idx;\n\n  /* Else, we are on the boundary: examine the nodes on the epsilon\n     closure.  */\n  for (node_idx = 0; node_idx < eclosures->nelem; ++node_idx)\n    {\n      Idx node = eclosures->elems[node_idx];\n      switch (dfa->nodes[node].type)\n\t{\n\tcase OP_BACK_REF:\n\t  if (bkref_idx != REG_MISSING)\n\t    {\n\t      struct re_backref_cache_entry *ent = mctx->bkref_ents + bkref_idx;\n\t      do\n\t\t{\n\t\t  Idx dst;\n\t\t  int cpos;\n\n\t\t  if (ent->node != node)\n\t\t    continue;\n\n\t\t  if (subexp_idx < BITSET_WORD_BITS\n\t\t      && !(ent->eps_reachable_subexps_map\n\t\t\t   & ((bitset_word_t) 1 << subexp_idx)))\n\t\t    continue;\n\n\t\t  /* Recurse trying to reach the OP_OPEN_SUBEXP and\n\t\t     OP_CLOSE_SUBEXP cases below.  But, if the\n\t\t     destination node is the same node as the source\n\t\t     node, don't recurse because it would cause an\n\t\t     infinite loop: a regex that exhibits this behavior\n\t\t     is ()\\1*\\1*  */\n\t\t  dst = dfa->edests[node].elems[0];\n\t\t  if (dst == from_node)\n\t\t    {\n\t\t      if (boundaries & 1)\n\t\t\treturn -1;\n\t\t      else /* if (boundaries & 2) */\n\t\t\treturn 0;\n\t\t    }\n\n\t\t  cpos =\n\t\t    check_dst_limits_calc_pos_1 (mctx, boundaries, subexp_idx,\n\t\t\t\t\t\t dst, bkref_idx);\n\t\t  if (cpos == -1 /* && (boundaries & 1) */)\n\t\t    return -1;\n\t\t  if (cpos == 0 && (boundaries & 2))\n\t\t    return 0;\n\n\t\t  if (subexp_idx < BITSET_WORD_BITS)\n\t\t    ent->eps_reachable_subexps_map\n\t\t      &= ~((bitset_word_t) 1 << subexp_idx);\n\t\t}\n\t      while (ent++->more);\n\t    }\n\t  break;\n\n\tcase OP_OPEN_SUBEXP:\n\t  if ((boundaries & 1) && subexp_idx == dfa->nodes[node].opr.idx)\n\t    return -1;\n\t  break;\n\n\tcase OP_CLOSE_SUBEXP:\n\t  if ((boundaries & 2) && subexp_idx == dfa->nodes[node].opr.idx)\n\t    return 0;\n\t  break;\n\n\tdefault:\n\t    break;\n\t}\n    }\n\n  return (boundaries & 2) ? 1 : 0;\n}",
      "lines": 81,
      "depth": 22,
      "decorators": [
        "static",
        "static",
        "int",
        "internal_function",
        "internal_function"
      ]
    },
    "check_dst_limits_calc_pos": {
      "start_point": [
        2039,
        0
      ],
      "end_point": [
        2064,
        1
      ],
      "content": "static int\ninternal_function\ncheck_dst_limits_calc_pos (const re_match_context_t *mctx, Idx limit,\n\t\t\t   Idx subexp_idx, Idx from_node, Idx str_idx,\n\t\t\t   Idx bkref_idx)\n{\n  struct re_backref_cache_entry *lim = mctx->bkref_ents + limit;\n  int boundaries;\n\n  /* If we are outside the range of the subexpression, return -1 or 1.  */\n  if (str_idx < lim->subexp_from)\n    return -1;\n\n  if (lim->subexp_to < str_idx)\n    return 1;\n\n  /* If we are within the subexpression, return 0.  */\n  boundaries = (str_idx == lim->subexp_from);\n  boundaries |= (str_idx == lim->subexp_to) << 1;\n  if (boundaries == 0)\n    return 0;\n\n  /* Else, examine epsilon closure.  */\n  return check_dst_limits_calc_pos_1 (mctx, boundaries, subexp_idx,\n\t\t\t\t      from_node, bkref_idx);\n}",
      "lines": 26,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int",
        "internal_function",
        "internal_function"
      ]
    },
    "check_subexp_limits": {
      "start_point": [
        2069,
        0
      ],
      "end_point": [
        2155,
        1
      ],
      "content": "static reg_errcode_t\ninternal_function\ncheck_subexp_limits (const re_dfa_t *dfa, re_node_set *dest_nodes,\n\t\t     const re_node_set *candidates, re_node_set *limits,\n\t\t     struct re_backref_cache_entry *bkref_ents, Idx str_idx)\n{\n  reg_errcode_t err;\n  Idx node_idx, lim_idx;\n\n  for (lim_idx = 0; lim_idx < limits->nelem; ++lim_idx)\n    {\n      Idx subexp_idx;\n      struct re_backref_cache_entry *ent;\n      ent = bkref_ents + limits->elems[lim_idx];\n\n      if (str_idx <= ent->subexp_from || ent->str_idx < str_idx)\n\tcontinue; /* This is unrelated limitation.  */\n\n      subexp_idx = dfa->nodes[ent->node].opr.idx;\n      if (ent->subexp_to == str_idx)\n\t{\n\t  Idx ops_node = REG_MISSING;\n\t  Idx cls_node = REG_MISSING;\n\t  for (node_idx = 0; node_idx < dest_nodes->nelem; ++node_idx)\n\t    {\n\t      Idx node = dest_nodes->elems[node_idx];\n\t      re_token_type_t type = dfa->nodes[node].type;\n\t      if (type == OP_OPEN_SUBEXP\n\t\t  && subexp_idx == dfa->nodes[node].opr.idx)\n\t\tops_node = node;\n\t      else if (type == OP_CLOSE_SUBEXP\n\t\t       && subexp_idx == dfa->nodes[node].opr.idx)\n\t\tcls_node = node;\n\t    }\n\n\t  /* Check the limitation of the open subexpression.  */\n\t  /* Note that (ent->subexp_to = str_idx != ent->subexp_from).  */\n\t  if (REG_VALID_INDEX (ops_node))\n\t    {\n\t      err = sub_epsilon_src_nodes (dfa, ops_node, dest_nodes,\n\t\t\t\t\t   candidates);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\treturn err;\n\t    }\n\n\t  /* Check the limitation of the close subexpression.  */\n\t  if (REG_VALID_INDEX (cls_node))\n\t    for (node_idx = 0; node_idx < dest_nodes->nelem; ++node_idx)\n\t      {\n\t\tIdx node = dest_nodes->elems[node_idx];\n\t\tif (!re_node_set_contains (dfa->inveclosures + node,\n\t\t\t\t\t   cls_node)\n\t\t    && !re_node_set_contains (dfa->eclosures + node,\n\t\t\t\t\t      cls_node))\n\t\t  {\n\t\t    /* It is against this limitation.\n\t\t       Remove it form the current sifted state.  */\n\t\t    err = sub_epsilon_src_nodes (dfa, node, dest_nodes,\n\t\t\t\t\t\t candidates);\n\t\t    if (BE (err != REG_NOERROR, 0))\n\t\t      return err;\n\t\t    --node_idx;\n\t\t  }\n\t      }\n\t}\n      else /* (ent->subexp_to != str_idx)  */\n\t{\n\t  for (node_idx = 0; node_idx < dest_nodes->nelem; ++node_idx)\n\t    {\n\t      Idx node = dest_nodes->elems[node_idx];\n\t      re_token_type_t type = dfa->nodes[node].type;\n\t      if (type == OP_CLOSE_SUBEXP || type == OP_OPEN_SUBEXP)\n\t\t{\n\t\t  if (subexp_idx != dfa->nodes[node].opr.idx)\n\t\t    continue;\n\t\t  /* It is against this limitation.\n\t\t     Remove it form the current sifted state.  */\n\t\t  err = sub_epsilon_src_nodes (dfa, node, dest_nodes,\n\t\t\t\t\t       candidates);\n\t\t  if (BE (err != REG_NOERROR, 0))\n\t\t    return err;\n\t\t}\n\t    }\n\t}\n    }\n  return REG_NOERROR;\n}",
      "lines": 87,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "internal_function",
        "internal_function"
      ]
    },
    "sift_states_bkref": {
      "start_point": [
        2158,
        18
      ],
      "end_point": [
        2253,
        1
      ],
      "content": "__attribute_warn_unused_result__\nsift_states_bkref (const re_match_context_t *mctx, re_sift_context_t *sctx,\n\t\t   Idx str_idx, const re_node_set *candidates)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  reg_errcode_t err;\n  Idx node_idx, node;\n  re_sift_context_t local_sctx;\n  Idx first_idx = search_cur_bkref_entry (mctx, str_idx);\n\n  if (first_idx == REG_MISSING)\n    return REG_NOERROR;\n\n  local_sctx.sifted_states = NULL; /* Mark that it hasn't been initialized.  */\n\n  for (node_idx = 0; node_idx < candidates->nelem; ++node_idx)\n    {\n      Idx enabled_idx;\n      re_token_type_t type;\n      struct re_backref_cache_entry *entry;\n      node = candidates->elems[node_idx];\n      type = dfa->nodes[node].type;\n      /* Avoid infinite loop for the REs like \"()\\1+\".  */\n      if (node == sctx->last_node && str_idx == sctx->last_str_idx)\n\tcontinue;\n      if (type != OP_BACK_REF)\n\tcontinue;\n\n      entry = mctx->bkref_ents + first_idx;\n      enabled_idx = first_idx;\n      do\n\t{\n\t  Idx subexp_len;\n\t  Idx to_idx;\n\t  Idx dst_node;\n\t  bool ok;\n\t  re_dfastate_t *cur_state;\n\n\t  if (entry->node != node)\n\t    continue;\n\t  subexp_len = entry->subexp_to - entry->subexp_from;\n\t  to_idx = str_idx + subexp_len;\n\t  dst_node = (subexp_len ? dfa->nexts[node]\n\t\t      : dfa->edests[node].elems[0]);\n\n\t  if (to_idx > sctx->last_str_idx\n\t      || sctx->sifted_states[to_idx] == NULL\n\t      || !STATE_NODE_CONTAINS (sctx->sifted_states[to_idx], dst_node)\n\t      || check_dst_limits (mctx, &sctx->limits, node,\n\t\t\t\t   str_idx, dst_node, to_idx))\n\t    continue;\n\n\t  if (local_sctx.sifted_states == NULL)\n\t    {\n\t      local_sctx = *sctx;\n\t      err = re_node_set_init_copy (&local_sctx.limits, &sctx->limits);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\tgoto free_return;\n\t    }\n\t  local_sctx.last_node = node;\n\t  local_sctx.last_str_idx = str_idx;\n\t  ok = re_node_set_insert (&local_sctx.limits, enabled_idx);\n\t  if (BE (! ok, 0))\n\t    {\n\t      err = REG_ESPACE;\n\t      goto free_return;\n\t    }\n\t  cur_state = local_sctx.sifted_states[str_idx];\n\t  err = sift_states_backward (mctx, &local_sctx);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    goto free_return;\n\t  if (sctx->limited_states != NULL)\n\t    {\n\t      err = merge_state_array (dfa, sctx->limited_states,\n\t\t\t\t       local_sctx.sifted_states,\n\t\t\t\t       str_idx + 1);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\tgoto free_return;\n\t    }\n\t  local_sctx.sifted_states[str_idx] = cur_state;\n\t  re_node_set_remove (&local_sctx.limits, enabled_idx);\n\n\t  /* mctx->bkref_ents may have changed, reload the pointer.  */\n\t  entry = mctx->bkref_ents + enabled_idx;\n\t}\n      while (enabled_idx++, entry++->more);\n    }\n  err = REG_NOERROR;\n free_return:\n  if (local_sctx.sifted_states != NULL)\n    {\n      re_node_set_free (&local_sctx.limits);\n    }\n\n  return err;\n}",
      "lines": 96,
      "depth": 16,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "sift_states_iter_mb": {
      "start_point": [
        2257,
        0
      ],
      "end_point": [
        2276,
        1
      ],
      "content": "static int\ninternal_function\nsift_states_iter_mb (const re_match_context_t *mctx, re_sift_context_t *sctx,\n\t\t     Idx node_idx, Idx str_idx, Idx max_str_idx)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  int naccepted;\n  /* Check the node can accept \"multi byte\".  */\n  naccepted = check_node_accept_bytes (dfa, node_idx, &mctx->input, str_idx);\n  if (naccepted > 0 && str_idx + naccepted <= max_str_idx &&\n      !STATE_NODE_CONTAINS (sctx->sifted_states[str_idx + naccepted],\n\t\t\t    dfa->nexts[node_idx]))\n    /* The node can't accept the \"multi byte\", or the\n       destination was already thrown away, then the node\n       could't accept the current input \"multi byte\".   */\n    naccepted = 0;\n  /* Otherwise, it is sure that the node could accept\n     'naccepted' bytes input.  */\n  return naccepted;\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int",
        "internal_function",
        "internal_function"
      ]
    },
    "transit_state": {
      "start_point": [
        2288,
        18
      ],
      "end_point": [
        2342,
        1
      ],
      "content": "__attribute_warn_unused_result__\ntransit_state (reg_errcode_t *err, re_match_context_t *mctx,\n\t       re_dfastate_t *state)\n{\n  re_dfastate_t **trtable;\n  unsigned char ch;\n\n#ifdef RE_ENABLE_I18N\n  /* If the current state can accept multibyte.  */\n  if (BE (state->accept_mb, 0))\n    {\n      *err = transit_state_mb (mctx, state);\n      if (BE (*err != REG_NOERROR, 0))\n\treturn NULL;\n    }\n#endif /* RE_ENABLE_I18N */\n\n  /* Then decide the next state with the single byte.  */\n#if 0\n  if (0)\n    /* don't use transition table  */\n    return transit_state_sb (err, mctx, state);\n#endif\n\n  /* Use transition table  */\n  ch = re_string_fetch_byte (&mctx->input);\n  for (;;)\n    {\n      trtable = state->trtable;\n      if (BE (trtable != NULL, 1))\n\treturn trtable[ch];\n\n      trtable = state->word_trtable;\n      if (BE (trtable != NULL, 1))\n\t{\n\t  unsigned int context;\n\t  context\n\t    = re_string_context_at (&mctx->input,\n\t\t\t\t    re_string_cur_idx (&mctx->input) - 1,\n\t\t\t\t    mctx->eflags);\n\t  if (IS_WORD_CONTEXT (context))\n\t    return trtable[ch + SBC_MAX];\n\t  else\n\t    return trtable[ch];\n\t}\n\n      if (!build_trtable (mctx->dfa, state))\n\t{\n\t  *err = REG_ESPACE;\n\t  return NULL;\n\t}\n\n      /* Retry, we now have a transition table.  */\n    }\n}",
      "lines": 55,
      "depth": 16,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "merge_state_with_log": {
      "start_point": [
        2345,
        0
      ],
      "end_point": [
        2419,
        1
      ],
      "content": "static re_dfastate_t *\ninternal_function\nmerge_state_with_log (reg_errcode_t *err, re_match_context_t *mctx,\n\t\t      re_dfastate_t *next_state)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  Idx cur_idx = re_string_cur_idx (&mctx->input);\n\n  if (cur_idx > mctx->state_log_top)\n    {\n      mctx->state_log[cur_idx] = next_state;\n      mctx->state_log_top = cur_idx;\n    }\n  else if (mctx->state_log[cur_idx] == 0)\n    {\n      mctx->state_log[cur_idx] = next_state;\n    }\n  else\n    {\n      re_dfastate_t *pstate;\n      unsigned int context;\n      re_node_set next_nodes, *log_nodes, *table_nodes = NULL;\n      /* If (state_log[cur_idx] != 0), it implies that cur_idx is\n\t the destination of a multibyte char/collating element/\n\t back reference.  Then the next state is the union set of\n\t these destinations and the results of the transition table.  */\n      pstate = mctx->state_log[cur_idx];\n      log_nodes = pstate->entrance_nodes;\n      if (next_state != NULL)\n\t{\n\t  table_nodes = next_state->entrance_nodes;\n\t  *err = re_node_set_init_union (&next_nodes, table_nodes,\n\t\t\t\t\t     log_nodes);\n\t  if (BE (*err != REG_NOERROR, 0))\n\t    return NULL;\n\t}\n      else\n\tnext_nodes = *log_nodes;\n      /* Note: We already add the nodes of the initial state,\n\t then we don't need to add them here.  */\n\n      context = re_string_context_at (&mctx->input,\n\t\t\t\t      re_string_cur_idx (&mctx->input) - 1,\n\t\t\t\t      mctx->eflags);\n      next_state = mctx->state_log[cur_idx]\n\t= re_acquire_state_context (err, dfa, &next_nodes, context);\n      /* We don't need to check errors here, since the return value of\n\t this function is next_state and ERR is already set.  */\n\n      if (table_nodes != NULL)\n\tre_node_set_free (&next_nodes);\n    }\n\n  if (BE (dfa->nbackref, 0) && next_state != NULL)\n    {\n      /* Check OP_OPEN_SUBEXP in the current state in case that we use them\n\t later.  We must check them here, since the back references in the\n\t next state might use them.  */\n      *err = check_subexp_matching_top (mctx, &next_state->nodes,\n\t\t\t\t\tcur_idx);\n      if (BE (*err != REG_NOERROR, 0))\n\treturn NULL;\n\n      /* If the next state has back references.  */\n      if (next_state->has_backref)\n\t{\n\t  *err = transit_state_bkref (mctx, &next_state->nodes);\n\t  if (BE (*err != REG_NOERROR, 0))\n\t    return NULL;\n\t  next_state = mctx->state_log[cur_idx];\n\t}\n    }\n\n  return next_state;\n}",
      "lines": 75,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "re_dfastate_t",
        "*\ninternal_function\nmerge_state_with_log (reg_errcode_t *err, re_match_context_t *mctx,\n\t\t      re_dfastate_t *next_state)",
        "*",
        "internal_function",
        "internal_function"
      ]
    },
    "find_recover_state": {
      "start_point": [
        2424,
        0
      ],
      "end_point": [
        2446,
        1
      ],
      "content": "static re_dfastate_t *\ninternal_function\nfind_recover_state (reg_errcode_t *err, re_match_context_t *mctx)\n{\n  re_dfastate_t *cur_state;\n  do\n    {\n      Idx max = mctx->state_log_top;\n      Idx cur_str_idx = re_string_cur_idx (&mctx->input);\n\n      do\n\t{\n\t  if (++cur_str_idx > max)\n\t    return NULL;\n\t  re_string_skip_bytes (&mctx->input, 1);\n\t}\n      while (mctx->state_log[cur_str_idx] == NULL);\n\n      cur_state = merge_state_with_log (err, mctx, NULL);\n    }\n  while (*err == REG_NOERROR && cur_state == NULL);\n  return cur_state;\n}",
      "lines": 23,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "re_dfastate_t",
        "*\ninternal_function\nfind_recover_state (reg_errcode_t *err, re_match_context_t *mctx)",
        "*",
        "internal_function",
        "internal_function"
      ]
    },
    "check_subexp_matching_top": {
      "start_point": [
        2455,
        0
      ],
      "end_point": [
        2483,
        1
      ],
      "content": "static reg_errcode_t\ninternal_function\ncheck_subexp_matching_top (re_match_context_t *mctx, re_node_set *cur_nodes,\n\t\t\t   Idx str_idx)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  Idx node_idx;\n  reg_errcode_t err;\n\n  /* TODO: This isn't efficient.\n\t   Because there might be more than one nodes whose types are\n\t   OP_OPEN_SUBEXP and whose index is SUBEXP_IDX, we must check all\n\t   nodes.\n\t   E.g. RE: (a){2}  */\n  for (node_idx = 0; node_idx < cur_nodes->nelem; ++node_idx)\n    {\n      Idx node = cur_nodes->elems[node_idx];\n      if (dfa->nodes[node].type == OP_OPEN_SUBEXP\n\t  && dfa->nodes[node].opr.idx < BITSET_WORD_BITS\n\t  && (dfa->used_bkref_map\n\t      & ((bitset_word_t) 1 << dfa->nodes[node].opr.idx)))\n\t{\n\t  err = match_ctx_add_subtop (mctx, node, str_idx);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return err;\n\t}\n    }\n  return REG_NOERROR;\n}",
      "lines": 29,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "internal_function",
        "internal_function"
      ]
    },
    "transit_state_sb": {
      "start_point": [
        2489,
        0
      ],
      "end_point": [
        2524,
        1
      ],
      "content": "static re_dfastate_t *\ntransit_state_sb (reg_errcode_t *err, re_match_context_t *mctx,\n\t\t  re_dfastate_t *state)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  re_node_set next_nodes;\n  re_dfastate_t *next_state;\n  Idx node_cnt, cur_str_idx = re_string_cur_idx (&mctx->input);\n  unsigned int context;\n\n  *err = re_node_set_alloc (&next_nodes, state->nodes.nelem + 1);\n  if (BE (*err != REG_NOERROR, 0))\n    return NULL;\n  for (node_cnt = 0; node_cnt < state->nodes.nelem; ++node_cnt)\n    {\n      Idx cur_node = state->nodes.elems[node_cnt];\n      if (check_node_accept (mctx, dfa->nodes + cur_node, cur_str_idx))\n\t{\n\t  *err = re_node_set_merge (&next_nodes,\n\t\t\t\t    dfa->eclosures + dfa->nexts[cur_node]);\n\t  if (BE (*err != REG_NOERROR, 0))\n\t    {\n\t      re_node_set_free (&next_nodes);\n\t      return NULL;\n\t    }\n\t}\n    }\n  context = re_string_context_at (&mctx->input, cur_str_idx, mctx->eflags);\n  next_state = re_acquire_state_context (err, dfa, &next_nodes, context);\n  /* We don't need to check errors here, since the return value of\n     this function is next_state and ERR is already set.  */\n\n  re_node_set_free (&next_nodes);\n  re_string_skip_bytes (&mctx->input, 1);\n  return next_state;\n}",
      "lines": 36,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "re_dfastate_t",
        "*\ntransit_state_sb (reg_errcode_t *err, re_match_context_t *mctx,\n\t\t  re_dfastate_t *state)",
        "*"
      ]
    },
    "transit_state_mb": {
      "start_point": [
        2528,
        0
      ],
      "end_point": [
        2596,
        1
      ],
      "content": "static reg_errcode_t\ninternal_function\ntransit_state_mb (re_match_context_t *mctx, re_dfastate_t *pstate)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  reg_errcode_t err;\n  Idx i;\n\n  for (i = 0; i < pstate->nodes.nelem; ++i)\n    {\n      re_node_set dest_nodes, *new_nodes;\n      Idx cur_node_idx = pstate->nodes.elems[i];\n      int naccepted;\n      Idx dest_idx;\n      unsigned int context;\n      re_dfastate_t *dest_state;\n\n      if (!dfa->nodes[cur_node_idx].accept_mb)\n\tcontinue;\n\n      if (dfa->nodes[cur_node_idx].constraint)\n\t{\n\t  context = re_string_context_at (&mctx->input,\n\t\t\t\t\t  re_string_cur_idx (&mctx->input),\n\t\t\t\t\t  mctx->eflags);\n\t  if (NOT_SATISFY_NEXT_CONSTRAINT (dfa->nodes[cur_node_idx].constraint,\n\t\t\t\t\t   context))\n\t    continue;\n\t}\n\n      /* How many bytes the node can accept?  */\n      naccepted = check_node_accept_bytes (dfa, cur_node_idx, &mctx->input,\n\t\t\t\t\t   re_string_cur_idx (&mctx->input));\n      if (naccepted == 0)\n\tcontinue;\n\n      /* The node can accepts 'naccepted' bytes.  */\n      dest_idx = re_string_cur_idx (&mctx->input) + naccepted;\n      mctx->max_mb_elem_len = ((mctx->max_mb_elem_len < naccepted) ? naccepted\n\t\t\t       : mctx->max_mb_elem_len);\n      err = clean_state_log_if_needed (mctx, dest_idx);\n      if (BE (err != REG_NOERROR, 0))\n\treturn err;\n#ifdef DEBUG\n      assert (dfa->nexts[cur_node_idx] != REG_MISSING);\n#endif\n      new_nodes = dfa->eclosures + dfa->nexts[cur_node_idx];\n\n      dest_state = mctx->state_log[dest_idx];\n      if (dest_state == NULL)\n\tdest_nodes = *new_nodes;\n      else\n\t{\n\t  err = re_node_set_init_union (&dest_nodes,\n\t\t\t\t\tdest_state->entrance_nodes, new_nodes);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return err;\n\t}\n      context = re_string_context_at (&mctx->input, dest_idx - 1,\n\t\t\t\t      mctx->eflags);\n      mctx->state_log[dest_idx]\n\t= re_acquire_state_context (&err, dfa, &dest_nodes, context);\n      if (dest_state != NULL)\n\tre_node_set_free (&dest_nodes);\n      if (BE (mctx->state_log[dest_idx] == NULL && err != REG_NOERROR, 0))\n\treturn err;\n    }\n  return REG_NOERROR;\n}",
      "lines": 69,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "internal_function",
        "internal_function"
      ]
    },
    "transit_state_bkref": {
      "start_point": [
        2599,
        0
      ],
      "end_point": [
        2705,
        1
      ],
      "content": "static reg_errcode_t\ninternal_function\ntransit_state_bkref (re_match_context_t *mctx, const re_node_set *nodes)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  reg_errcode_t err;\n  Idx i;\n  Idx cur_str_idx = re_string_cur_idx (&mctx->input);\n\n  for (i = 0; i < nodes->nelem; ++i)\n    {\n      Idx dest_str_idx, prev_nelem, bkc_idx;\n      Idx node_idx = nodes->elems[i];\n      unsigned int context;\n      const re_token_t *node = dfa->nodes + node_idx;\n      re_node_set *new_dest_nodes;\n\n      /* Check whether 'node' is a backreference or not.  */\n      if (node->type != OP_BACK_REF)\n\tcontinue;\n\n      if (node->constraint)\n\t{\n\t  context = re_string_context_at (&mctx->input, cur_str_idx,\n\t\t\t\t\t  mctx->eflags);\n\t  if (NOT_SATISFY_NEXT_CONSTRAINT (node->constraint, context))\n\t    continue;\n\t}\n\n      /* 'node' is a backreference.\n\t Check the substring which the substring matched.  */\n      bkc_idx = mctx->nbkref_ents;\n      err = get_subexp (mctx, node_idx, cur_str_idx);\n      if (BE (err != REG_NOERROR, 0))\n\tgoto free_return;\n\n      /* And add the epsilon closures (which is 'new_dest_nodes') of\n\t the backreference to appropriate state_log.  */\n#ifdef DEBUG\n      assert (dfa->nexts[node_idx] != REG_MISSING);\n#endif\n      for (; bkc_idx < mctx->nbkref_ents; ++bkc_idx)\n\t{\n\t  Idx subexp_len;\n\t  re_dfastate_t *dest_state;\n\t  struct re_backref_cache_entry *bkref_ent;\n\t  bkref_ent = mctx->bkref_ents + bkc_idx;\n\t  if (bkref_ent->node != node_idx || bkref_ent->str_idx != cur_str_idx)\n\t    continue;\n\t  subexp_len = bkref_ent->subexp_to - bkref_ent->subexp_from;\n\t  new_dest_nodes = (subexp_len == 0\n\t\t\t    ? dfa->eclosures + dfa->edests[node_idx].elems[0]\n\t\t\t    : dfa->eclosures + dfa->nexts[node_idx]);\n\t  dest_str_idx = (cur_str_idx + bkref_ent->subexp_to\n\t\t\t  - bkref_ent->subexp_from);\n\t  context = re_string_context_at (&mctx->input, dest_str_idx - 1,\n\t\t\t\t\t  mctx->eflags);\n\t  dest_state = mctx->state_log[dest_str_idx];\n\t  prev_nelem = ((mctx->state_log[cur_str_idx] == NULL) ? 0\n\t\t\t: mctx->state_log[cur_str_idx]->nodes.nelem);\n\t  /* Add 'new_dest_node' to state_log.  */\n\t  if (dest_state == NULL)\n\t    {\n\t      mctx->state_log[dest_str_idx]\n\t\t= re_acquire_state_context (&err, dfa, new_dest_nodes,\n\t\t\t\t\t    context);\n\t      if (BE (mctx->state_log[dest_str_idx] == NULL\n\t\t      && err != REG_NOERROR, 0))\n\t\tgoto free_return;\n\t    }\n\t  else\n\t    {\n\t      re_node_set dest_nodes;\n\t      err = re_node_set_init_union (&dest_nodes,\n\t\t\t\t\t    dest_state->entrance_nodes,\n\t\t\t\t\t    new_dest_nodes);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\t{\n\t\t  re_node_set_free (&dest_nodes);\n\t\t  goto free_return;\n\t\t}\n\t      mctx->state_log[dest_str_idx]\n\t\t= re_acquire_state_context (&err, dfa, &dest_nodes, context);\n\t      re_node_set_free (&dest_nodes);\n\t      if (BE (mctx->state_log[dest_str_idx] == NULL\n\t\t      && err != REG_NOERROR, 0))\n\t\tgoto free_return;\n\t    }\n\t  /* We need to check recursively if the backreference can epsilon\n\t     transit.  */\n\t  if (subexp_len == 0\n\t      && mctx->state_log[cur_str_idx]->nodes.nelem > prev_nelem)\n\t    {\n\t      err = check_subexp_matching_top (mctx, new_dest_nodes,\n\t\t\t\t\t       cur_str_idx);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\tgoto free_return;\n\t      err = transit_state_bkref (mctx, new_dest_nodes);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\tgoto free_return;\n\t    }\n\t}\n    }\n  err = REG_NOERROR;\n free_return:\n  return err;\n}",
      "lines": 107,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "internal_function",
        "internal_function"
      ]
    },
    "get_subexp": {
      "start_point": [
        2714,
        18
      ],
      "end_point": [
        2855,
        1
      ],
      "content": "__attribute_warn_unused_result__\nget_subexp (re_match_context_t *mctx, Idx bkref_node, Idx bkref_str_idx)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  Idx subexp_num, sub_top_idx;\n  const char *buf = (const char *) re_string_get_buffer (&mctx->input);\n  /* Return if we have already checked BKREF_NODE at BKREF_STR_IDX.  */\n  Idx cache_idx = search_cur_bkref_entry (mctx, bkref_str_idx);\n  if (cache_idx != REG_MISSING)\n    {\n      const struct re_backref_cache_entry *entry\n\t= mctx->bkref_ents + cache_idx;\n      do\n\tif (entry->node == bkref_node)\n\t  return REG_NOERROR; /* We already checked it.  */\n      while (entry++->more);\n    }\n\n  subexp_num = dfa->nodes[bkref_node].opr.idx;\n\n  /* For each sub expression  */\n  for (sub_top_idx = 0; sub_top_idx < mctx->nsub_tops; ++sub_top_idx)\n    {\n      reg_errcode_t err;\n      re_sub_match_top_t *sub_top = mctx->sub_tops[sub_top_idx];\n      re_sub_match_last_t *sub_last;\n      Idx sub_last_idx, sl_str, bkref_str_off;\n\n      if (dfa->nodes[sub_top->node].opr.idx != subexp_num)\n\tcontinue; /* It isn't related.  */\n\n      sl_str = sub_top->str_idx;\n      bkref_str_off = bkref_str_idx;\n      /* At first, check the last node of sub expressions we already\n\t evaluated.  */\n      for (sub_last_idx = 0; sub_last_idx < sub_top->nlasts; ++sub_last_idx)\n\t{\n\t  regoff_t sl_str_diff;\n\t  sub_last = sub_top->lasts[sub_last_idx];\n\t  sl_str_diff = sub_last->str_idx - sl_str;\n\t  /* The matched string by the sub expression match with the substring\n\t     at the back reference?  */\n\t  if (sl_str_diff > 0)\n\t    {\n\t      if (BE (bkref_str_off + sl_str_diff > mctx->input.valid_len, 0))\n\t\t{\n\t\t  /* Not enough chars for a successful match.  */\n\t\t  if (bkref_str_off + sl_str_diff > mctx->input.len)\n\t\t    break;\n\n\t\t  err = clean_state_log_if_needed (mctx,\n\t\t\t\t\t\t   bkref_str_off\n\t\t\t\t\t\t   + sl_str_diff);\n\t\t  if (BE (err != REG_NOERROR, 0))\n\t\t    return err;\n\t\t  buf = (const char *) re_string_get_buffer (&mctx->input);\n\t\t}\n\t      if (memcmp (buf + bkref_str_off, buf + sl_str, sl_str_diff) != 0)\n\t\t/* We don't need to search this sub expression any more.  */\n\t\tbreak;\n\t    }\n\t  bkref_str_off += sl_str_diff;\n\t  sl_str += sl_str_diff;\n\t  err = get_subexp_sub (mctx, sub_top, sub_last, bkref_node,\n\t\t\t\tbkref_str_idx);\n\n\t  /* Reload buf, since the preceding call might have reallocated\n\t     the buffer.  */\n\t  buf = (const char *) re_string_get_buffer (&mctx->input);\n\n\t  if (err == REG_NOMATCH)\n\t    continue;\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return err;\n\t}\n\n      if (sub_last_idx < sub_top->nlasts)\n\tcontinue;\n      if (sub_last_idx > 0)\n\t++sl_str;\n      /* Then, search for the other last nodes of the sub expression.  */\n      for (; sl_str <= bkref_str_idx; ++sl_str)\n\t{\n\t  Idx cls_node;\n\t  regoff_t sl_str_off;\n\t  const re_node_set *nodes;\n\t  sl_str_off = sl_str - sub_top->str_idx;\n\t  /* The matched string by the sub expression match with the substring\n\t     at the back reference?  */\n\t  if (sl_str_off > 0)\n\t    {\n\t      if (BE (bkref_str_off >= mctx->input.valid_len, 0))\n\t\t{\n\t\t  /* If we are at the end of the input, we cannot match.  */\n\t\t  if (bkref_str_off >= mctx->input.len)\n\t\t    break;\n\n\t\t  err = extend_buffers (mctx, bkref_str_off + 1);\n\t\t  if (BE (err != REG_NOERROR, 0))\n\t\t    return err;\n\n\t\t  buf = (const char *) re_string_get_buffer (&mctx->input);\n\t\t}\n\t      if (buf [bkref_str_off++] != buf[sl_str - 1])\n\t\tbreak; /* We don't need to search this sub expression\n\t\t\t  any more.  */\n\t    }\n\t  if (mctx->state_log[sl_str] == NULL)\n\t    continue;\n\t  /* Does this state have a ')' of the sub expression?  */\n\t  nodes = &mctx->state_log[sl_str]->nodes;\n\t  cls_node = find_subexp_node (dfa, nodes, subexp_num,\n\t\t\t\t       OP_CLOSE_SUBEXP);\n\t  if (cls_node == REG_MISSING)\n\t    continue; /* No.  */\n\t  if (sub_top->path == NULL)\n\t    {\n\t      sub_top->path = calloc (sizeof (state_array_t),\n\t\t\t\t      sl_str - sub_top->str_idx + 1);\n\t      if (sub_top->path == NULL)\n\t\treturn REG_ESPACE;\n\t    }\n\t  /* Can the OP_OPEN_SUBEXP node arrive the OP_CLOSE_SUBEXP node\n\t     in the current context?  */\n\t  err = check_arrival (mctx, sub_top->path, sub_top->node,\n\t\t\t       sub_top->str_idx, cls_node, sl_str,\n\t\t\t       OP_CLOSE_SUBEXP);\n\t  if (err == REG_NOMATCH)\n\t      continue;\n\t  if (BE (err != REG_NOERROR, 0))\n\t      return err;\n\t  sub_last = match_ctx_add_sublast (sub_top, cls_node, sl_str);\n\t  if (BE (sub_last == NULL, 0))\n\t    return REG_ESPACE;\n\t  err = get_subexp_sub (mctx, sub_top, sub_last, bkref_node,\n\t\t\t\tbkref_str_idx);\n\t  if (err == REG_NOMATCH)\n\t    continue;\n\t}\n    }\n  return REG_NOERROR;\n}",
      "lines": 142,
      "depth": 18,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "get_subexp_sub": {
      "start_point": [
        2863,
        0
      ],
      "end_point": [
        2882,
        1
      ],
      "content": "static reg_errcode_t\ninternal_function\nget_subexp_sub (re_match_context_t *mctx, const re_sub_match_top_t *sub_top,\n\t\tre_sub_match_last_t *sub_last, Idx bkref_node, Idx bkref_str)\n{\n  reg_errcode_t err;\n  Idx to_idx;\n  /* Can the subexpression arrive the back reference?  */\n  err = check_arrival (mctx, &sub_last->path, sub_last->node,\n\t\t       sub_last->str_idx, bkref_node, bkref_str,\n\t\t       OP_OPEN_SUBEXP);\n  if (err != REG_NOERROR)\n    return err;\n  err = match_ctx_add_entry (mctx, bkref_node, bkref_str, sub_top->str_idx,\n\t\t\t     sub_last->str_idx);\n  if (BE (err != REG_NOERROR, 0))\n    return err;\n  to_idx = bkref_str + sub_last->str_idx - sub_top->str_idx;\n  return clean_state_log_if_needed (mctx, to_idx);\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "internal_function",
        "internal_function"
      ]
    },
    "find_subexp_node": {
      "start_point": [
        2892,
        0
      ],
      "end_point": [
        2907,
        1
      ],
      "content": "static Idx\ninternal_function\nfind_subexp_node (const re_dfa_t *dfa, const re_node_set *nodes,\n\t\t  Idx subexp_idx, int type)\n{\n  Idx cls_idx;\n  for (cls_idx = 0; cls_idx < nodes->nelem; ++cls_idx)\n    {\n      Idx cls_node = nodes->elems[cls_idx];\n      const re_token_t *node = dfa->nodes + cls_node;\n      if (node->type == type\n\t  && node->opr.idx == subexp_idx)\n\treturn cls_node;\n    }\n  return REG_MISSING;\n}",
      "lines": 16,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "Idx",
        "internal_function",
        "internal_function"
      ]
    },
    "check_arrival": {
      "start_point": [
        2915,
        18
      ],
      "end_point": [
        3069,
        1
      ],
      "content": "__attribute_warn_unused_result__\ncheck_arrival (re_match_context_t *mctx, state_array_t *path, Idx top_node,\n\t       Idx top_str, Idx last_node, Idx last_str, int type)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  reg_errcode_t err = REG_NOERROR;\n  Idx subexp_num, backup_cur_idx, str_idx, null_cnt;\n  re_dfastate_t *cur_state = NULL;\n  re_node_set *cur_nodes, next_nodes;\n  re_dfastate_t **backup_state_log;\n  unsigned int context;\n\n  subexp_num = dfa->nodes[top_node].opr.idx;\n  /* Extend the buffer if we need.  */\n  if (BE (path->alloc < last_str + mctx->max_mb_elem_len + 1, 0))\n    {\n      re_dfastate_t **new_array;\n      Idx old_alloc = path->alloc;\n      Idx incr_alloc = last_str + mctx->max_mb_elem_len + 1;\n      Idx new_alloc;\n      if (BE (IDX_MAX - old_alloc < incr_alloc, 0))\n\treturn REG_ESPACE;\n      new_alloc = old_alloc + incr_alloc;\n      if (BE (SIZE_MAX / sizeof (re_dfastate_t *) < new_alloc, 0))\n\treturn REG_ESPACE;\n      new_array = re_realloc (path->array, re_dfastate_t *, new_alloc);\n      if (BE (new_array == NULL, 0))\n\treturn REG_ESPACE;\n      path->array = new_array;\n      path->alloc = new_alloc;\n      memset (new_array + old_alloc, '\\0',\n\t      sizeof (re_dfastate_t *) * (path->alloc - old_alloc));\n    }\n\n  str_idx = path->next_idx ? path->next_idx : top_str;\n\n  /* Temporary modify MCTX.  */\n  backup_state_log = mctx->state_log;\n  backup_cur_idx = mctx->input.cur_idx;\n  mctx->state_log = path->array;\n  mctx->input.cur_idx = str_idx;\n\n  /* Setup initial node set.  */\n  context = re_string_context_at (&mctx->input, str_idx - 1, mctx->eflags);\n  if (str_idx == top_str)\n    {\n      err = re_node_set_init_1 (&next_nodes, top_node);\n      if (BE (err != REG_NOERROR, 0))\n\treturn err;\n      err = check_arrival_expand_ecl (dfa, &next_nodes, subexp_num, type);\n      if (BE (err != REG_NOERROR, 0))\n\t{\n\t  re_node_set_free (&next_nodes);\n\t  return err;\n\t}\n    }\n  else\n    {\n      cur_state = mctx->state_log[str_idx];\n      if (cur_state && cur_state->has_backref)\n\t{\n\t  err = re_node_set_init_copy (&next_nodes, &cur_state->nodes);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return err;\n\t}\n      else\n\tre_node_set_init_empty (&next_nodes);\n    }\n  if (str_idx == top_str || (cur_state && cur_state->has_backref))\n    {\n      if (next_nodes.nelem)\n\t{\n\t  err = expand_bkref_cache (mctx, &next_nodes, str_idx,\n\t\t\t\t    subexp_num, type);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    {\n\t      re_node_set_free (&next_nodes);\n\t      return err;\n\t    }\n\t}\n      cur_state = re_acquire_state_context (&err, dfa, &next_nodes, context);\n      if (BE (cur_state == NULL && err != REG_NOERROR, 0))\n\t{\n\t  re_node_set_free (&next_nodes);\n\t  return err;\n\t}\n      mctx->state_log[str_idx] = cur_state;\n    }\n\n  for (null_cnt = 0; str_idx < last_str && null_cnt <= mctx->max_mb_elem_len;)\n    {\n      re_node_set_empty (&next_nodes);\n      if (mctx->state_log[str_idx + 1])\n\t{\n\t  err = re_node_set_merge (&next_nodes,\n\t\t\t\t   &mctx->state_log[str_idx + 1]->nodes);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    {\n\t      re_node_set_free (&next_nodes);\n\t      return err;\n\t    }\n\t}\n      if (cur_state)\n\t{\n\t  err = check_arrival_add_next_nodes (mctx, str_idx,\n\t\t\t\t\t      &cur_state->non_eps_nodes,\n\t\t\t\t\t      &next_nodes);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    {\n\t      re_node_set_free (&next_nodes);\n\t      return err;\n\t    }\n\t}\n      ++str_idx;\n      if (next_nodes.nelem)\n\t{\n\t  err = check_arrival_expand_ecl (dfa, &next_nodes, subexp_num, type);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    {\n\t      re_node_set_free (&next_nodes);\n\t      return err;\n\t    }\n\t  err = expand_bkref_cache (mctx, &next_nodes, str_idx,\n\t\t\t\t    subexp_num, type);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    {\n\t      re_node_set_free (&next_nodes);\n\t      return err;\n\t    }\n\t}\n      context = re_string_context_at (&mctx->input, str_idx - 1, mctx->eflags);\n      cur_state = re_acquire_state_context (&err, dfa, &next_nodes, context);\n      if (BE (cur_state == NULL && err != REG_NOERROR, 0))\n\t{\n\t  re_node_set_free (&next_nodes);\n\t  return err;\n\t}\n      mctx->state_log[str_idx] = cur_state;\n      null_cnt = cur_state == NULL ? null_cnt + 1 : 0;\n    }\n  re_node_set_free (&next_nodes);\n  cur_nodes = (mctx->state_log[last_str] == NULL ? NULL\n\t       : &mctx->state_log[last_str]->nodes);\n  path->next_idx = str_idx;\n\n  /* Fix MCTX.  */\n  mctx->state_log = backup_state_log;\n  mctx->input.cur_idx = backup_cur_idx;\n\n  /* Then check the current node set has the node LAST_NODE.  */\n  if (cur_nodes != NULL && re_node_set_contains (cur_nodes, last_node))\n    return REG_NOERROR;\n\n  return REG_NOMATCH;\n}",
      "lines": 155,
      "depth": 15,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "check_arrival_add_next_nodes": {
      "start_point": [
        3080,
        18
      ],
      "end_point": [
        3152,
        1
      ],
      "content": "__attribute_warn_unused_result__\ncheck_arrival_add_next_nodes (re_match_context_t *mctx, Idx str_idx,\n\t\t\t      re_node_set *cur_nodes, re_node_set *next_nodes)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  bool ok;\n  Idx cur_idx;\n#ifdef RE_ENABLE_I18N\n  reg_errcode_t err = REG_NOERROR;\n#endif\n  re_node_set union_set;\n  re_node_set_init_empty (&union_set);\n  for (cur_idx = 0; cur_idx < cur_nodes->nelem; ++cur_idx)\n    {\n      int naccepted = 0;\n      Idx cur_node = cur_nodes->elems[cur_idx];\n#ifdef DEBUG\n      re_token_type_t type = dfa->nodes[cur_node].type;\n      assert (!IS_EPSILON_NODE (type));\n#endif\n#ifdef RE_ENABLE_I18N\n      /* If the node may accept \"multi byte\".  */\n      if (dfa->nodes[cur_node].accept_mb)\n\t{\n\t  naccepted = check_node_accept_bytes (dfa, cur_node, &mctx->input,\n\t\t\t\t\t       str_idx);\n\t  if (naccepted > 1)\n\t    {\n\t      re_dfastate_t *dest_state;\n\t      Idx next_node = dfa->nexts[cur_node];\n\t      Idx next_idx = str_idx + naccepted;\n\t      dest_state = mctx->state_log[next_idx];\n\t      re_node_set_empty (&union_set);\n\t      if (dest_state)\n\t\t{\n\t\t  err = re_node_set_merge (&union_set, &dest_state->nodes);\n\t\t  if (BE (err != REG_NOERROR, 0))\n\t\t    {\n\t\t      re_node_set_free (&union_set);\n\t\t      return err;\n\t\t    }\n\t\t}\n\t      ok = re_node_set_insert (&union_set, next_node);\n\t      if (BE (! ok, 0))\n\t\t{\n\t\t  re_node_set_free (&union_set);\n\t\t  return REG_ESPACE;\n\t\t}\n\t      mctx->state_log[next_idx] = re_acquire_state (&err, dfa,\n\t\t\t\t\t\t\t    &union_set);\n\t      if (BE (mctx->state_log[next_idx] == NULL\n\t\t      && err != REG_NOERROR, 0))\n\t\t{\n\t\t  re_node_set_free (&union_set);\n\t\t  return err;\n\t\t}\n\t    }\n\t}\n#endif /* RE_ENABLE_I18N */\n      if (naccepted\n\t  || check_node_accept (mctx, dfa->nodes + cur_node, str_idx))\n\t{\n\t  ok = re_node_set_insert (next_nodes, dfa->nexts[cur_node]);\n\t  if (BE (! ok, 0))\n\t    {\n\t      re_node_set_free (&union_set);\n\t      return REG_ESPACE;\n\t    }\n\t}\n    }\n  re_node_set_free (&union_set);\n  return REG_NOERROR;\n}",
      "lines": 73,
      "depth": 18,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "check_arrival_expand_ecl": {
      "start_point": [
        3160,
        0
      ],
      "end_point": [
        3207,
        1
      ],
      "content": "static reg_errcode_t\ninternal_function\ncheck_arrival_expand_ecl (const re_dfa_t *dfa, re_node_set *cur_nodes,\n\t\t\t  Idx ex_subexp, int type)\n{\n  reg_errcode_t err;\n  Idx idx, outside_node;\n  re_node_set new_nodes;\n#ifdef DEBUG\n  assert (cur_nodes->nelem);\n#endif\n  err = re_node_set_alloc (&new_nodes, cur_nodes->nelem);\n  if (BE (err != REG_NOERROR, 0))\n    return err;\n  /* Create a new node set NEW_NODES with the nodes which are epsilon\n     closures of the node in CUR_NODES.  */\n\n  for (idx = 0; idx < cur_nodes->nelem; ++idx)\n    {\n      Idx cur_node = cur_nodes->elems[idx];\n      const re_node_set *eclosure = dfa->eclosures + cur_node;\n      outside_node = find_subexp_node (dfa, eclosure, ex_subexp, type);\n      if (outside_node == REG_MISSING)\n\t{\n\t  /* There are no problematic nodes, just merge them.  */\n\t  err = re_node_set_merge (&new_nodes, eclosure);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    {\n\t      re_node_set_free (&new_nodes);\n\t      return err;\n\t    }\n\t}\n      else\n\t{\n\t  /* There are problematic nodes, re-calculate incrementally.  */\n\t  err = check_arrival_expand_ecl_sub (dfa, &new_nodes, cur_node,\n\t\t\t\t\t      ex_subexp, type);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    {\n\t      re_node_set_free (&new_nodes);\n\t      return err;\n\t    }\n\t}\n    }\n  re_node_set_free (cur_nodes);\n  *cur_nodes = new_nodes;\n  return REG_NOERROR;\n}",
      "lines": 48,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "internal_function",
        "internal_function"
      ]
    },
    "check_arrival_expand_ecl_sub": {
      "start_point": [
        3214,
        18
      ],
      "end_point": [
        3251,
        1
      ],
      "content": "__attribute_warn_unused_result__\ncheck_arrival_expand_ecl_sub (const re_dfa_t *dfa, re_node_set *dst_nodes,\n\t\t\t      Idx target, Idx ex_subexp, int type)\n{\n  Idx cur_node;\n  for (cur_node = target; !re_node_set_contains (dst_nodes, cur_node);)\n    {\n      bool ok;\n\n      if (dfa->nodes[cur_node].type == type\n\t  && dfa->nodes[cur_node].opr.idx == ex_subexp)\n\t{\n\t  if (type == OP_CLOSE_SUBEXP)\n\t    {\n\t      ok = re_node_set_insert (dst_nodes, cur_node);\n\t      if (BE (! ok, 0))\n\t\treturn REG_ESPACE;\n\t    }\n\t  break;\n\t}\n      ok = re_node_set_insert (dst_nodes, cur_node);\n      if (BE (! ok, 0))\n\treturn REG_ESPACE;\n      if (dfa->edests[cur_node].nelem == 0)\n\tbreak;\n      if (dfa->edests[cur_node].nelem == 2)\n\t{\n\t  reg_errcode_t err;\n\t  err = check_arrival_expand_ecl_sub (dfa, dst_nodes,\n\t\t\t\t\t      dfa->edests[cur_node].elems[1],\n\t\t\t\t\t      ex_subexp, type);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return err;\n\t}\n      cur_node = dfa->edests[cur_node].elems[0];\n    }\n  return REG_NOERROR;\n}",
      "lines": 38,
      "depth": 15,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "expand_bkref_cache": {
      "start_point": [
        3259,
        18
      ],
      "end_point": [
        3342,
        1
      ],
      "content": "__attribute_warn_unused_result__\nexpand_bkref_cache (re_match_context_t *mctx, re_node_set *cur_nodes,\n\t\t    Idx cur_str, Idx subexp_num, int type)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  reg_errcode_t err;\n  Idx cache_idx_start = search_cur_bkref_entry (mctx, cur_str);\n  struct re_backref_cache_entry *ent;\n\n  if (cache_idx_start == REG_MISSING)\n    return REG_NOERROR;\n\n restart:\n  ent = mctx->bkref_ents + cache_idx_start;\n  do\n    {\n      Idx to_idx, next_node;\n\n      /* Is this entry ENT is appropriate?  */\n      if (!re_node_set_contains (cur_nodes, ent->node))\n\tcontinue; /* No.  */\n\n      to_idx = cur_str + ent->subexp_to - ent->subexp_from;\n      /* Calculate the destination of the back reference, and append it\n\t to MCTX->STATE_LOG.  */\n      if (to_idx == cur_str)\n\t{\n\t  /* The backreference did epsilon transit, we must re-check all the\n\t     node in the current state.  */\n\t  re_node_set new_dests;\n\t  reg_errcode_t err2, err3;\n\t  next_node = dfa->edests[ent->node].elems[0];\n\t  if (re_node_set_contains (cur_nodes, next_node))\n\t    continue;\n\t  err = re_node_set_init_1 (&new_dests, next_node);\n\t  err2 = check_arrival_expand_ecl (dfa, &new_dests, subexp_num, type);\n\t  err3 = re_node_set_merge (cur_nodes, &new_dests);\n\t  re_node_set_free (&new_dests);\n\t  if (BE (err != REG_NOERROR || err2 != REG_NOERROR\n\t\t  || err3 != REG_NOERROR, 0))\n\t    {\n\t      err = (err != REG_NOERROR ? err\n\t\t     : (err2 != REG_NOERROR ? err2 : err3));\n\t      return err;\n\t    }\n\t  /* TODO: It is still inefficient...  */\n\t  goto restart;\n\t}\n      else\n\t{\n\t  re_node_set union_set;\n\t  next_node = dfa->nexts[ent->node];\n\t  if (mctx->state_log[to_idx])\n\t    {\n\t      bool ok;\n\t      if (re_node_set_contains (&mctx->state_log[to_idx]->nodes,\n\t\t\t\t\tnext_node))\n\t\tcontinue;\n\t      err = re_node_set_init_copy (&union_set,\n\t\t\t\t\t   &mctx->state_log[to_idx]->nodes);\n\t      ok = re_node_set_insert (&union_set, next_node);\n\t      if (BE (err != REG_NOERROR || ! ok, 0))\n\t\t{\n\t\t  re_node_set_free (&union_set);\n\t\t  err = err != REG_NOERROR ? err : REG_ESPACE;\n\t\t  return err;\n\t\t}\n\t    }\n\t  else\n\t    {\n\t      err = re_node_set_init_1 (&union_set, next_node);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\treturn err;\n\t    }\n\t  mctx->state_log[to_idx] = re_acquire_state (&err, dfa, &union_set);\n\t  re_node_set_free (&union_set);\n\t  if (BE (mctx->state_log[to_idx] == NULL\n\t\t  && err != REG_NOERROR, 0))\n\t    return err;\n\t}\n    }\n  while (ent++->more);\n  return REG_NOERROR;\n}",
      "lines": 84,
      "depth": 17,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "build_trtable": {
      "start_point": [
        3347,
        0
      ],
      "end_point": [
        3578,
        1
      ],
      "content": "static bool\ninternal_function\nbuild_trtable (const re_dfa_t *dfa, re_dfastate_t *state)\n{\n  reg_errcode_t err;\n  Idx i, j;\n  int ch;\n  bool need_word_trtable = false;\n  bitset_word_t elem, mask;\n  bool dests_node_malloced = false;\n  bool dest_states_malloced = false;\n  Idx ndests; /* Number of the destination states from 'state'.  */\n  re_dfastate_t **trtable;\n  re_dfastate_t **dest_states = NULL, **dest_states_word, **dest_states_nl;\n  re_node_set follows, *dests_node;\n  bitset_t *dests_ch;\n  bitset_t acceptable;\n\n  struct dests_alloc\n  {\n    re_node_set dests_node[SBC_MAX];\n    bitset_t dests_ch[SBC_MAX];\n  } *dests_alloc;\n\n  /* We build DFA states which corresponds to the destination nodes\n     from 'state'.  'dests_node[i]' represents the nodes which i-th\n     destination state contains, and 'dests_ch[i]' represents the\n     characters which i-th destination state accepts.  */\n  if (__libc_use_alloca (sizeof (struct dests_alloc)))\n    dests_alloc = (struct dests_alloc *) alloca (sizeof (struct dests_alloc));\n  else\n    {\n      dests_alloc = re_malloc (struct dests_alloc, 1);\n      if (BE (dests_alloc == NULL, 0))\n\treturn false;\n      dests_node_malloced = true;\n    }\n  dests_node = dests_alloc->dests_node;\n  dests_ch = dests_alloc->dests_ch;\n\n  /* Initialize transition table.  */\n  state->word_trtable = state->trtable = NULL;\n\n  /* At first, group all nodes belonging to 'state' into several\n     destinations.  */\n  ndests = group_nodes_into_DFAstates (dfa, state, dests_node, dests_ch);\n  if (BE (! REG_VALID_NONZERO_INDEX (ndests), 0))\n    {\n      if (dests_node_malloced)\n\tfree (dests_alloc);\n      /* Return false in case of an error, true otherwise.  */\n      if (ndests == 0)\n\t{\n\t  state->trtable = (re_dfastate_t **)\n\t    calloc (sizeof (re_dfastate_t *), SBC_MAX);\n          if (BE (state->trtable == NULL, 0))\n            return false;\n\t  return true;\n\t}\n      return false;\n    }\n\n  err = re_node_set_alloc (&follows, ndests + 1);\n  if (BE (err != REG_NOERROR, 0))\n    goto out_free;\n\n  /* Avoid arithmetic overflow in size calculation.  */\n  if (BE ((((SIZE_MAX - (sizeof (re_node_set) + sizeof (bitset_t)) * SBC_MAX)\n\t    / (3 * sizeof (re_dfastate_t *)))\n\t   < ndests),\n\t  0))\n    goto out_free;\n\n  if (__libc_use_alloca ((sizeof (re_node_set) + sizeof (bitset_t)) * SBC_MAX\n\t\t\t + ndests * 3 * sizeof (re_dfastate_t *)))\n    dest_states = (re_dfastate_t **)\n      alloca (ndests * 3 * sizeof (re_dfastate_t *));\n  else\n    {\n      dest_states = (re_dfastate_t **)\n\tmalloc (ndests * 3 * sizeof (re_dfastate_t *));\n      if (BE (dest_states == NULL, 0))\n\t{\nout_free:\n\t  if (dest_states_malloced)\n\t    free (dest_states);\n\t  re_node_set_free (&follows);\n\t  for (i = 0; i < ndests; ++i)\n\t    re_node_set_free (dests_node + i);\n\t  if (dests_node_malloced)\n\t    free (dests_alloc);\n\t  return false;\n\t}\n      dest_states_malloced = true;\n    }\n  dest_states_word = dest_states + ndests;\n  dest_states_nl = dest_states_word + ndests;\n  bitset_empty (acceptable);\n\n  /* Then build the states for all destinations.  */\n  for (i = 0; i < ndests; ++i)\n    {\n      Idx next_node;\n      re_node_set_empty (&follows);\n      /* Merge the follows of this destination states.  */\n      for (j = 0; j < dests_node[i].nelem; ++j)\n\t{\n\t  next_node = dfa->nexts[dests_node[i].elems[j]];\n\t  if (next_node != REG_MISSING)\n\t    {\n\t      err = re_node_set_merge (&follows, dfa->eclosures + next_node);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\tgoto out_free;\n\t    }\n\t}\n      dest_states[i] = re_acquire_state_context (&err, dfa, &follows, 0);\n      if (BE (dest_states[i] == NULL && err != REG_NOERROR, 0))\n\tgoto out_free;\n      /* If the new state has context constraint,\n\t build appropriate states for these contexts.  */\n      if (dest_states[i]->has_constraint)\n\t{\n\t  dest_states_word[i] = re_acquire_state_context (&err, dfa, &follows,\n\t\t\t\t\t\t\t  CONTEXT_WORD);\n\t  if (BE (dest_states_word[i] == NULL && err != REG_NOERROR, 0))\n\t    goto out_free;\n\n\t  if (dest_states[i] != dest_states_word[i] && dfa->mb_cur_max > 1)\n\t    need_word_trtable = true;\n\n\t  dest_states_nl[i] = re_acquire_state_context (&err, dfa, &follows,\n\t\t\t\t\t\t\tCONTEXT_NEWLINE);\n\t  if (BE (dest_states_nl[i] == NULL && err != REG_NOERROR, 0))\n\t    goto out_free;\n\t}\n      else\n\t{\n\t  dest_states_word[i] = dest_states[i];\n\t  dest_states_nl[i] = dest_states[i];\n\t}\n      bitset_merge (acceptable, dests_ch[i]);\n    }\n\n  if (!BE (need_word_trtable, 0))\n    {\n      /* We don't care about whether the following character is a word\n\t character, or we are in a single-byte character set so we can\n\t discern by looking at the character code: allocate a\n\t 256-entry transition table.  */\n      trtable = state->trtable =\n\t(re_dfastate_t **) calloc (sizeof (re_dfastate_t *), SBC_MAX);\n      if (BE (trtable == NULL, 0))\n\tgoto out_free;\n\n      /* For all characters ch...:  */\n      for (i = 0; i < BITSET_WORDS; ++i)\n\tfor (ch = i * BITSET_WORD_BITS, elem = acceptable[i], mask = 1;\n\t     elem;\n\t     mask <<= 1, elem >>= 1, ++ch)\n\t  if (BE (elem & 1, 0))\n\t    {\n\t      /* There must be exactly one destination which accepts\n\t\t character ch.  See group_nodes_into_DFAstates.  */\n\t      for (j = 0; (dests_ch[j][i] & mask) == 0; ++j)\n\t\t;\n\n\t      /* j-th destination accepts the word character ch.  */\n\t      if (dfa->word_char[i] & mask)\n\t\ttrtable[ch] = dest_states_word[j];\n\t      else\n\t\ttrtable[ch] = dest_states[j];\n\t    }\n    }\n  else\n    {\n      /* We care about whether the following character is a word\n\t character, and we are in a multi-byte character set: discern\n\t by looking at the character code: build two 256-entry\n\t transition tables, one starting at trtable[0] and one\n\t starting at trtable[SBC_MAX].  */\n      trtable = state->word_trtable =\n\t(re_dfastate_t **) calloc (sizeof (re_dfastate_t *), 2 * SBC_MAX);\n      if (BE (trtable == NULL, 0))\n\tgoto out_free;\n\n      /* For all characters ch...:  */\n      for (i = 0; i < BITSET_WORDS; ++i)\n\tfor (ch = i * BITSET_WORD_BITS, elem = acceptable[i], mask = 1;\n\t     elem;\n\t     mask <<= 1, elem >>= 1, ++ch)\n\t  if (BE (elem & 1, 0))\n\t    {\n\t      /* There must be exactly one destination which accepts\n\t\t character ch.  See group_nodes_into_DFAstates.  */\n\t      for (j = 0; (dests_ch[j][i] & mask) == 0; ++j)\n\t\t;\n\n\t      /* j-th destination accepts the word character ch.  */\n\t      trtable[ch] = dest_states[j];\n\t      trtable[ch + SBC_MAX] = dest_states_word[j];\n\t    }\n    }\n\n  /* new line */\n  if (bitset_contain (acceptable, NEWLINE_CHAR))\n    {\n      /* The current state accepts newline character.  */\n      for (j = 0; j < ndests; ++j)\n\tif (bitset_contain (dests_ch[j], NEWLINE_CHAR))\n\t  {\n\t    /* k-th destination accepts newline character.  */\n\t    trtable[NEWLINE_CHAR] = dest_states_nl[j];\n\t    if (need_word_trtable)\n\t      trtable[NEWLINE_CHAR + SBC_MAX] = dest_states_nl[j];\n\t    /* There must be only one destination which accepts\n\t       newline.  See group_nodes_into_DFAstates.  */\n\t    break;\n\t  }\n    }\n\n  if (dest_states_malloced)\n    free (dest_states);\n\n  re_node_set_free (&follows);\n  for (i = 0; i < ndests; ++i)\n    re_node_set_free (dests_node + i);\n\n  if (dests_node_malloced)\n    free (dests_alloc);\n\n  return true;\n}",
      "lines": 232,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "bool",
        "internal_function",
        "internal_function"
      ]
    },
    "group_nodes_into_DFAstates": {
      "start_point": [
        3585,
        0
      ],
      "end_point": [
        3767,
        1
      ],
      "content": "static Idx\ninternal_function\ngroup_nodes_into_DFAstates (const re_dfa_t *dfa, const re_dfastate_t *state,\n\t\t\t    re_node_set *dests_node, bitset_t *dests_ch)\n{\n  reg_errcode_t err;\n  bool ok;\n  Idx i, j, k;\n  Idx ndests; /* Number of the destinations from 'state'.  */\n  bitset_t accepts; /* Characters a node can accept.  */\n  const re_node_set *cur_nodes = &state->nodes;\n  bitset_empty (accepts);\n  ndests = 0;\n\n  /* For all the nodes belonging to 'state',  */\n  for (i = 0; i < cur_nodes->nelem; ++i)\n    {\n      re_token_t *node = &dfa->nodes[cur_nodes->elems[i]];\n      re_token_type_t type = node->type;\n      unsigned int constraint = node->constraint;\n\n      /* Enumerate all single byte character this node can accept.  */\n      if (type == CHARACTER)\n\tbitset_set (accepts, node->opr.c);\n      else if (type == SIMPLE_BRACKET)\n\t{\n\t  bitset_merge (accepts, node->opr.sbcset);\n\t}\n      else if (type == OP_PERIOD)\n\t{\n#ifdef RE_ENABLE_I18N\n\t  if (dfa->mb_cur_max > 1)\n\t    bitset_merge (accepts, dfa->sb_char);\n\t  else\n#endif\n\t    bitset_set_all (accepts);\n\t  if (!(dfa->syntax & RE_DOT_NEWLINE))\n\t    bitset_clear (accepts, '\\n');\n\t  if (dfa->syntax & RE_DOT_NOT_NULL)\n\t    bitset_clear (accepts, '\\0');\n\t}\n#ifdef RE_ENABLE_I18N\n      else if (type == OP_UTF8_PERIOD)\n\t{\n\t  if (ASCII_CHARS % BITSET_WORD_BITS == 0)\n\t    memset (accepts, -1, ASCII_CHARS / CHAR_BIT);\n\t  else\n\t    bitset_merge (accepts, utf8_sb_map);\n\t  if (!(dfa->syntax & RE_DOT_NEWLINE))\n\t    bitset_clear (accepts, '\\n');\n\t  if (dfa->syntax & RE_DOT_NOT_NULL)\n\t    bitset_clear (accepts, '\\0');\n\t}\n#endif\n      else\n\tcontinue;\n\n      /* Check the 'accepts' and sift the characters which are not\n\t match it the context.  */\n      if (constraint)\n\t{\n\t  if (constraint & NEXT_NEWLINE_CONSTRAINT)\n\t    {\n\t      bool accepts_newline = bitset_contain (accepts, NEWLINE_CHAR);\n\t      bitset_empty (accepts);\n\t      if (accepts_newline)\n\t\tbitset_set (accepts, NEWLINE_CHAR);\n\t      else\n\t\tcontinue;\n\t    }\n\t  if (constraint & NEXT_ENDBUF_CONSTRAINT)\n\t    {\n\t      bitset_empty (accepts);\n\t      continue;\n\t    }\n\n\t  if (constraint & NEXT_WORD_CONSTRAINT)\n\t    {\n\t      bitset_word_t any_set = 0;\n\t      if (type == CHARACTER && !node->word_char)\n\t\t{\n\t\t  bitset_empty (accepts);\n\t\t  continue;\n\t\t}\n#ifdef RE_ENABLE_I18N\n\t      if (dfa->mb_cur_max > 1)\n\t\tfor (j = 0; j < BITSET_WORDS; ++j)\n\t\t  any_set |= (accepts[j] &= (dfa->word_char[j] | ~dfa->sb_char[j]));\n\t      else\n#endif\n\t\tfor (j = 0; j < BITSET_WORDS; ++j)\n\t\t  any_set |= (accepts[j] &= dfa->word_char[j]);\n\t      if (!any_set)\n\t\tcontinue;\n\t    }\n\t  if (constraint & NEXT_NOTWORD_CONSTRAINT)\n\t    {\n\t      bitset_word_t any_set = 0;\n\t      if (type == CHARACTER && node->word_char)\n\t\t{\n\t\t  bitset_empty (accepts);\n\t\t  continue;\n\t\t}\n#ifdef RE_ENABLE_I18N\n\t      if (dfa->mb_cur_max > 1)\n\t\tfor (j = 0; j < BITSET_WORDS; ++j)\n\t\t  any_set |= (accepts[j] &= ~(dfa->word_char[j] & dfa->sb_char[j]));\n\t      else\n#endif\n\t\tfor (j = 0; j < BITSET_WORDS; ++j)\n\t\t  any_set |= (accepts[j] &= ~dfa->word_char[j]);\n\t      if (!any_set)\n\t\tcontinue;\n\t    }\n\t}\n\n      /* Then divide 'accepts' into DFA states, or create a new\n\t state.  Above, we make sure that accepts is not empty.  */\n      for (j = 0; j < ndests; ++j)\n\t{\n\t  bitset_t intersec; /* Intersection sets, see below.  */\n\t  bitset_t remains;\n\t  /* Flags, see below.  */\n\t  bitset_word_t has_intersec, not_subset, not_consumed;\n\n\t  /* Optimization, skip if this state doesn't accept the character.  */\n\t  if (type == CHARACTER && !bitset_contain (dests_ch[j], node->opr.c))\n\t    continue;\n\n\t  /* Enumerate the intersection set of this state and 'accepts'.  */\n\t  has_intersec = 0;\n\t  for (k = 0; k < BITSET_WORDS; ++k)\n\t    has_intersec |= intersec[k] = accepts[k] & dests_ch[j][k];\n\t  /* And skip if the intersection set is empty.  */\n\t  if (!has_intersec)\n\t    continue;\n\n\t  /* Then check if this state is a subset of 'accepts'.  */\n\t  not_subset = not_consumed = 0;\n\t  for (k = 0; k < BITSET_WORDS; ++k)\n\t    {\n\t      not_subset |= remains[k] = ~accepts[k] & dests_ch[j][k];\n\t      not_consumed |= accepts[k] = accepts[k] & ~dests_ch[j][k];\n\t    }\n\n\t  /* If this state isn't a subset of 'accepts', create a\n\t     new group state, which has the 'remains'. */\n\t  if (not_subset)\n\t    {\n\t      bitset_copy (dests_ch[ndests], remains);\n\t      bitset_copy (dests_ch[j], intersec);\n\t      err = re_node_set_init_copy (dests_node + ndests, &dests_node[j]);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\tgoto error_return;\n\t      ++ndests;\n\t    }\n\n\t  /* Put the position in the current group. */\n\t  ok = re_node_set_insert (&dests_node[j], cur_nodes->elems[i]);\n\t  if (BE (! ok, 0))\n\t    goto error_return;\n\n\t  /* If all characters are consumed, go to next node. */\n\t  if (!not_consumed)\n\t    break;\n\t}\n      /* Some characters remain, create a new group. */\n      if (j == ndests)\n\t{\n\t  bitset_copy (dests_ch[ndests], accepts);\n\t  err = re_node_set_init_1 (dests_node + ndests, cur_nodes->elems[i]);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    goto error_return;\n\t  ++ndests;\n\t  bitset_empty (accepts);\n\t}\n    }\n  return ndests;\n error_return:\n  for (j = 0; j < ndests; ++j)\n    re_node_set_free (dests_node + j);\n  return REG_MISSING;\n}",
      "lines": 183,
      "depth": 21,
      "decorators": [
        "static",
        "static",
        "Idx",
        "internal_function",
        "internal_function"
      ]
    },
    "check_node_accept_bytes": {
      "start_point": [
        3782,
        0
      ],
      "end_point": [
        4009,
        1
      ],
      "content": "static int\ninternal_function\ncheck_node_accept_bytes (const re_dfa_t *dfa, Idx node_idx,\n\t\t\t const re_string_t *input, Idx str_idx)\n{\n  const re_token_t *node = dfa->nodes + node_idx;\n  int char_len, elem_len;\n  Idx i;\n\n  if (BE (node->type == OP_UTF8_PERIOD, 0))\n    {\n      unsigned char c = re_string_byte_at (input, str_idx), d;\n      if (BE (c < 0xc2, 1))\n\treturn 0;\n\n      if (str_idx + 2 > input->len)\n\treturn 0;\n\n      d = re_string_byte_at (input, str_idx + 1);\n      if (c < 0xe0)\n\treturn (d < 0x80 || d > 0xbf) ? 0 : 2;\n      else if (c < 0xf0)\n\t{\n\t  char_len = 3;\n\t  if (c == 0xe0 && d < 0xa0)\n\t    return 0;\n\t}\n      else if (c < 0xf8)\n\t{\n\t  char_len = 4;\n\t  if (c == 0xf0 && d < 0x90)\n\t    return 0;\n\t}\n      else if (c < 0xfc)\n\t{\n\t  char_len = 5;\n\t  if (c == 0xf8 && d < 0x88)\n\t    return 0;\n\t}\n      else if (c < 0xfe)\n\t{\n\t  char_len = 6;\n\t  if (c == 0xfc && d < 0x84)\n\t    return 0;\n\t}\n      else\n\treturn 0;\n\n      if (str_idx + char_len > input->len)\n\treturn 0;\n\n      for (i = 1; i < char_len; ++i)\n\t{\n\t  d = re_string_byte_at (input, str_idx + i);\n\t  if (d < 0x80 || d > 0xbf)\n\t    return 0;\n\t}\n      return char_len;\n    }\n\n  char_len = re_string_char_size_at (input, str_idx);\n  if (node->type == OP_PERIOD)\n    {\n      if (char_len <= 1)\n\treturn 0;\n      /* FIXME: I don't think this if is needed, as both '\\n'\n\t and '\\0' are char_len == 1.  */\n      /* '.' accepts any one character except the following two cases.  */\n      if ((!(dfa->syntax & RE_DOT_NEWLINE) &&\n\t   re_string_byte_at (input, str_idx) == '\\n') ||\n\t  ((dfa->syntax & RE_DOT_NOT_NULL) &&\n\t   re_string_byte_at (input, str_idx) == '\\0'))\n\treturn 0;\n      return char_len;\n    }\n\n  elem_len = re_string_elem_size_at (input, str_idx);\n  if ((elem_len <= 1 && char_len <= 1) || char_len == 0)\n    return 0;\n\n  if (node->type == COMPLEX_BRACKET)\n    {\n      const re_charset_t *cset = node->opr.mbcset;\n# ifdef _LIBC\n      const unsigned char *pin\n\t= ((const unsigned char *) re_string_get_buffer (input) + str_idx);\n      Idx j;\n      uint32_t nrules;\n# endif /* _LIBC */\n      int match_len = 0;\n      wchar_t wc = ((cset->nranges || cset->nchar_classes || cset->nmbchars)\n\t\t    ? re_string_wchar_at (input, str_idx) : 0);\n\n      /* match with multibyte character?  */\n      for (i = 0; i < cset->nmbchars; ++i)\n\tif (wc == cset->mbchars[i])\n\t  {\n\t    match_len = char_len;\n\t    goto check_node_accept_bytes_match;\n\t  }\n      /* match with character_class?  */\n      for (i = 0; i < cset->nchar_classes; ++i)\n\t{\n\t  wctype_t wt = cset->char_classes[i];\n\t  if (__iswctype (wc, wt))\n\t    {\n\t      match_len = char_len;\n\t      goto check_node_accept_bytes_match;\n\t    }\n\t}\n\n# ifdef _LIBC\n      nrules = _NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_NRULES);\n      if (nrules != 0)\n\t{\n\t  unsigned int in_collseq = 0;\n\t  const int32_t *table, *indirect;\n\t  const unsigned char *weights, *extra;\n\t  const char *collseqwc;\n\n\t  /* match with collating_symbol?  */\n\t  if (cset->ncoll_syms)\n\t    extra = (const unsigned char *)\n\t      _NL_CURRENT (LC_COLLATE, _NL_COLLATE_SYMB_EXTRAMB);\n\t  for (i = 0; i < cset->ncoll_syms; ++i)\n\t    {\n\t      const unsigned char *coll_sym = extra + cset->coll_syms[i];\n\t      /* Compare the length of input collating element and\n\t\t the length of current collating element.  */\n\t      if (*coll_sym != elem_len)\n\t\tcontinue;\n\t      /* Compare each bytes.  */\n\t      for (j = 0; j < *coll_sym; j++)\n\t\tif (pin[j] != coll_sym[1 + j])\n\t\t  break;\n\t      if (j == *coll_sym)\n\t\t{\n\t\t  /* Match if every bytes is equal.  */\n\t\t  match_len = j;\n\t\t  goto check_node_accept_bytes_match;\n\t\t}\n\t    }\n\n\t  if (cset->nranges)\n\t    {\n\t      if (elem_len <= char_len)\n\t\t{\n\t\t  collseqwc = _NL_CURRENT (LC_COLLATE, _NL_COLLATE_COLLSEQWC);\n\t\t  in_collseq = __collseq_table_lookup (collseqwc, wc);\n\t\t}\n\t      else\n\t\tin_collseq = find_collation_sequence_value (pin, elem_len);\n\t    }\n\t  /* match with range expression?  */\n\t  /* FIXME: Implement rational ranges here, too.  */\n\t  for (i = 0; i < cset->nranges; ++i)\n\t    if (cset->range_starts[i] <= in_collseq\n\t\t&& in_collseq <= cset->range_ends[i])\n\t      {\n\t\tmatch_len = elem_len;\n\t\tgoto check_node_accept_bytes_match;\n\t      }\n\n\t  /* match with equivalence_class?  */\n\t  if (cset->nequiv_classes)\n\t    {\n\t      const unsigned char *cp = pin;\n\t      table = (const int32_t *)\n\t\t_NL_CURRENT (LC_COLLATE, _NL_COLLATE_TABLEMB);\n\t      weights = (const unsigned char *)\n\t\t_NL_CURRENT (LC_COLLATE, _NL_COLLATE_WEIGHTMB);\n\t      extra = (const unsigned char *)\n\t\t_NL_CURRENT (LC_COLLATE, _NL_COLLATE_EXTRAMB);\n\t      indirect = (const int32_t *)\n\t\t_NL_CURRENT (LC_COLLATE, _NL_COLLATE_INDIRECTMB);\n\t      int32_t idx = findidx (table, indirect, extra, &cp, elem_len);\n\t      if (idx > 0)\n\t\tfor (i = 0; i < cset->nequiv_classes; ++i)\n\t\t  {\n\t\t    int32_t equiv_class_idx = cset->equiv_classes[i];\n\t\t    size_t weight_len = weights[idx & 0xffffff];\n\t\t    if (weight_len == weights[equiv_class_idx & 0xffffff]\n\t\t\t&& (idx >> 24) == (equiv_class_idx >> 24))\n\t\t      {\n\t\t\tIdx cnt = 0;\n\n\t\t\tidx &= 0xffffff;\n\t\t\tequiv_class_idx &= 0xffffff;\n\n\t\t\twhile (cnt <= weight_len\n\t\t\t       && (weights[equiv_class_idx + 1 + cnt]\n\t\t\t\t   == weights[idx + 1 + cnt]))\n\t\t\t  ++cnt;\n\t\t\tif (cnt > weight_len)\n\t\t\t  {\n\t\t\t    match_len = elem_len;\n\t\t\t    goto check_node_accept_bytes_match;\n\t\t\t  }\n\t\t      }\n\t\t  }\n\t    }\n\t}\n      else\n# endif /* _LIBC */\n\t{\n\t  /* match with range expression?  */\n\t  for (i = 0; i < cset->nranges; ++i)\n\t    {\n\t      if (cset->range_starts[i] <= wc && wc <= cset->range_ends[i])\n\t\t{\n\t\t  match_len = char_len;\n\t\t  goto check_node_accept_bytes_match;\n\t\t}\n\t    }\n\t}\n    check_node_accept_bytes_match:\n      if (!cset->non_match)\n\treturn match_len;\n      else\n\t{\n\t  if (match_len > 0)\n\t    return 0;\n\t  else\n\t    return (elem_len > char_len) ? elem_len : char_len;\n\t}\n    }\n  return 0;\n}",
      "lines": 228,
      "depth": 23,
      "decorators": [
        "static",
        "static",
        "int",
        "internal_function",
        "internal_function"
      ]
    },
    "find_collation_sequence_value": {
      "start_point": [
        4012,
        0
      ],
      "end_point": [
        4069,
        1
      ],
      "content": "static unsigned int\ninternal_function\nfind_collation_sequence_value (const unsigned char *mbs, size_t mbs_len)\n{\n  uint32_t nrules = _NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_NRULES);\n  if (nrules == 0)\n    {\n      if (mbs_len == 1)\n\t{\n\t  /* No valid character.  Match it as a single byte character.  */\n\t  const unsigned char *collseq = (const unsigned char *)\n\t    _NL_CURRENT (LC_COLLATE, _NL_COLLATE_COLLSEQMB);\n\t  return collseq[mbs[0]];\n\t}\n      return UINT_MAX;\n    }\n  else\n    {\n      int32_t idx;\n      const unsigned char *extra = (const unsigned char *)\n\t_NL_CURRENT (LC_COLLATE, _NL_COLLATE_SYMB_EXTRAMB);\n      int32_t extrasize = (const unsigned char *)\n\t_NL_CURRENT (LC_COLLATE, _NL_COLLATE_SYMB_EXTRAMB + 1) - extra;\n\n      for (idx = 0; idx < extrasize;)\n\t{\n\t  int mbs_cnt;\n\t  bool found = false;\n\t  int32_t elem_mbs_len;\n\t  /* Skip the name of collating element name.  */\n\t  idx = idx + extra[idx] + 1;\n\t  elem_mbs_len = extra[idx++];\n\t  if (mbs_len == elem_mbs_len)\n\t    {\n\t      for (mbs_cnt = 0; mbs_cnt < elem_mbs_len; ++mbs_cnt)\n\t\tif (extra[idx + mbs_cnt] != mbs[mbs_cnt])\n\t\t  break;\n\t      if (mbs_cnt == elem_mbs_len)\n\t\t/* Found the entry.  */\n\t\tfound = true;\n\t    }\n\t  /* Skip the byte sequence of the collating element.  */\n\t  idx += elem_mbs_len;\n\t  /* Adjust for the alignment.  */\n\t  idx = (idx + 3) & ~3;\n\t  /* Skip the collation sequence value.  */\n\t  idx += sizeof (uint32_t);\n\t  /* Skip the wide char sequence of the collating element.  */\n\t  idx = idx + sizeof (uint32_t) * (*(int32_t *) (extra + idx) + 1);\n\t  /* If we found the entry, return the sequence value.  */\n\t  if (found)\n\t    return *(uint32_t *) (extra + idx);\n\t  /* Skip the collation sequence value.  */\n\t  idx += sizeof (uint32_t);\n\t}\n      return UINT_MAX;\n    }\n}",
      "lines": 58,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "unsigned int",
        "unsigned",
        "int",
        "internal_function",
        "internal_function"
      ]
    },
    "check_node_accept": {
      "start_point": [
        4076,
        0
      ],
      "end_point": [
        4122,
        1
      ],
      "content": "static bool\ninternal_function\ncheck_node_accept (const re_match_context_t *mctx, const re_token_t *node,\n\t\t   Idx idx)\n{\n  unsigned char ch;\n  ch = re_string_byte_at (&mctx->input, idx);\n  switch (node->type)\n    {\n    case CHARACTER:\n      if (node->opr.c != ch)\n        return false;\n      break;\n\n    case SIMPLE_BRACKET:\n      if (!bitset_contain (node->opr.sbcset, ch))\n        return false;\n      break;\n\n#ifdef RE_ENABLE_I18N\n    case OP_UTF8_PERIOD:\n      if (ch >= ASCII_CHARS)\n        return false;\n      /* FALLTHROUGH */\n#endif\n    case OP_PERIOD:\n      if ((ch == '\\n' && !(mctx->dfa->syntax & RE_DOT_NEWLINE))\n\t  || (ch == '\\0' && (mctx->dfa->syntax & RE_DOT_NOT_NULL)))\n\treturn false;\n      break;\n\n    default:\n      return false;\n    }\n\n  if (node->constraint)\n    {\n      /* The node has constraints.  Check whether the current context\n\t satisfies the constraints.  */\n      unsigned int context = re_string_context_at (&mctx->input, idx,\n\t\t\t\t\t\t   mctx->eflags);\n      if (NOT_SATISFY_NEXT_CONSTRAINT (node->constraint, context))\n\treturn false;\n    }\n\n  return true;\n}",
      "lines": 47,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "bool",
        "internal_function",
        "internal_function"
      ]
    },
    "extend_buffers": {
      "start_point": [
        4127,
        18
      ],
      "end_point": [
        4185,
        1
      ],
      "content": "__attribute_warn_unused_result__\nextend_buffers (re_match_context_t *mctx, int min_len)\n{\n  reg_errcode_t ret;\n  re_string_t *pstr = &mctx->input;\n\n  /* Avoid overflow.  */\n  if (BE (MIN (IDX_MAX, SIZE_MAX / sizeof (re_dfastate_t *)) / 2\n          <= pstr->bufs_len, 0))\n    return REG_ESPACE;\n\n  /* Double the lengths of the buffers, but allocate at least MIN_LEN.  */\n  ret = re_string_realloc_buffers (pstr,\n\t\t\t\t   MAX (min_len,\n\t\t\t\t\tMIN (pstr->len, pstr->bufs_len * 2)));\n  if (BE (ret != REG_NOERROR, 0))\n    return ret;\n\n  if (mctx->state_log != NULL)\n    {\n      /* And double the length of state_log.  */\n      /* XXX We have no indication of the size of this buffer.  If this\n\t allocation fail we have no indication that the state_log array\n\t does not have the right size.  */\n      re_dfastate_t **new_array = re_realloc (mctx->state_log, re_dfastate_t *,\n\t\t\t\t\t      pstr->bufs_len + 1);\n      if (BE (new_array == NULL, 0))\n\treturn REG_ESPACE;\n      mctx->state_log = new_array;\n    }\n\n  /* Then reconstruct the buffers.  */\n  if (pstr->icase)\n    {\n#ifdef RE_ENABLE_I18N\n      if (pstr->mb_cur_max > 1)\n\t{\n\t  ret = build_wcs_upper_buffer (pstr);\n\t  if (BE (ret != REG_NOERROR, 0))\n\t    return ret;\n\t}\n      else\n#endif /* RE_ENABLE_I18N  */\n\tbuild_upper_buffer (pstr);\n    }\n  else\n    {\n#ifdef RE_ENABLE_I18N\n      if (pstr->mb_cur_max > 1)\n\tbuild_wcs_buffer (pstr);\n      else\n#endif /* RE_ENABLE_I18N  */\n\t{\n\t  if (pstr->trans != NULL)\n\t    re_string_translate_buffer (pstr);\n\t}\n    }\n  return REG_NOERROR;\n}",
      "lines": 59,
      "depth": 15,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "match_ctx_init": {
      "start_point": [
        4193,
        18
      ],
      "end_point": [
        4221,
        1
      ],
      "content": "__attribute_warn_unused_result__\nmatch_ctx_init (re_match_context_t *mctx, int eflags, Idx n)\n{\n  mctx->eflags = eflags;\n  mctx->match_last = REG_MISSING;\n  if (n > 0)\n    {\n      /* Avoid overflow.  */\n      size_t max_object_size =\n\tMAX (sizeof (struct re_backref_cache_entry),\n\t     sizeof (re_sub_match_top_t *));\n      if (BE (MIN (IDX_MAX, SIZE_MAX / max_object_size) < n, 0))\n\treturn REG_ESPACE;\n\n      mctx->bkref_ents = re_malloc (struct re_backref_cache_entry, n);\n      mctx->sub_tops = re_malloc (re_sub_match_top_t *, n);\n      if (BE (mctx->bkref_ents == NULL || mctx->sub_tops == NULL, 0))\n\treturn REG_ESPACE;\n    }\n  /* Already zero-ed by the caller.\n     else\n       mctx->bkref_ents = NULL;\n     mctx->nbkref_ents = 0;\n     mctx->nsub_tops = 0;  */\n  mctx->abkref_ents = n;\n  mctx->max_mb_elem_len = 1;\n  mctx->asub_tops = n;\n  return REG_NOERROR;\n}",
      "lines": 29,
      "depth": 13,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "match_ctx_clean": {
      "start_point": [
        4227,
        0
      ],
      "end_point": [
        4253,
        1
      ],
      "content": "static void\ninternal_function\nmatch_ctx_clean (re_match_context_t *mctx)\n{\n  Idx st_idx;\n  for (st_idx = 0; st_idx < mctx->nsub_tops; ++st_idx)\n    {\n      Idx sl_idx;\n      re_sub_match_top_t *top = mctx->sub_tops[st_idx];\n      for (sl_idx = 0; sl_idx < top->nlasts; ++sl_idx)\n\t{\n\t  re_sub_match_last_t *last = top->lasts[sl_idx];\n\t  re_free (last->path.array);\n\t  re_free (last);\n\t}\n      re_free (top->lasts);\n      if (top->path)\n\t{\n\t  re_free (top->path->array);\n\t  re_free (top->path);\n\t}\n      free (top);\n    }\n\n  mctx->nsub_tops = 0;\n  mctx->nbkref_ents = 0;\n}",
      "lines": 27,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void",
        "internal_function",
        "internal_function"
      ]
    },
    "match_ctx_free": {
      "start_point": [
        4257,
        0
      ],
      "end_point": [
        4265,
        1
      ],
      "content": "static void\ninternal_function\nmatch_ctx_free (re_match_context_t *mctx)\n{\n  /* First, free all the memory associated with MCTX->SUB_TOPS.  */\n  match_ctx_clean (mctx);\n  re_free (mctx->sub_tops);\n  re_free (mctx->bkref_ents);\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void",
        "internal_function",
        "internal_function"
      ]
    },
    "match_ctx_add_entry": {
      "start_point": [
        4273,
        18
      ],
      "end_point": [
        4316,
        1
      ],
      "content": "__attribute_warn_unused_result__\nmatch_ctx_add_entry (re_match_context_t *mctx, Idx node, Idx str_idx, Idx from,\n\t\t     Idx to)\n{\n  if (mctx->nbkref_ents >= mctx->abkref_ents)\n    {\n      struct re_backref_cache_entry* new_entry;\n      new_entry = re_realloc (mctx->bkref_ents, struct re_backref_cache_entry,\n\t\t\t      mctx->abkref_ents * 2);\n      if (BE (new_entry == NULL, 0))\n\t{\n\t  re_free (mctx->bkref_ents);\n\t  return REG_ESPACE;\n\t}\n      mctx->bkref_ents = new_entry;\n      memset (mctx->bkref_ents + mctx->nbkref_ents, '\\0',\n\t      sizeof (struct re_backref_cache_entry) * mctx->abkref_ents);\n      mctx->abkref_ents *= 2;\n    }\n  if (mctx->nbkref_ents > 0\n      && mctx->bkref_ents[mctx->nbkref_ents - 1].str_idx == str_idx)\n    mctx->bkref_ents[mctx->nbkref_ents - 1].more = 1;\n\n  mctx->bkref_ents[mctx->nbkref_ents].node = node;\n  mctx->bkref_ents[mctx->nbkref_ents].str_idx = str_idx;\n  mctx->bkref_ents[mctx->nbkref_ents].subexp_from = from;\n  mctx->bkref_ents[mctx->nbkref_ents].subexp_to = to;\n\n  /* This is a cache that saves negative results of check_dst_limits_calc_pos.\n     If bit N is clear, means that this entry won't epsilon-transition to\n     an OP_OPEN_SUBEXP or OP_CLOSE_SUBEXP for the N+1-th subexpression.  If\n     it is set, check_dst_limits_calc_pos_1 will recurse and try to find one\n     such node.\n\n     A backreference does not epsilon-transition unless it is empty, so set\n     to all zeros if FROM != TO.  */\n  mctx->bkref_ents[mctx->nbkref_ents].eps_reachable_subexps_map\n    = (from == to ? -1 : 0);\n\n  mctx->bkref_ents[mctx->nbkref_ents++].more = 0;\n  if (mctx->max_mb_elem_len < to - from)\n    mctx->max_mb_elem_len = to - from;\n  return REG_NOERROR;\n}",
      "lines": 44,
      "depth": 12,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "search_cur_bkref_entry": {
      "start_point": [
        4321,
        0
      ],
      "end_point": [
        4339,
        1
      ],
      "content": "static Idx\ninternal_function\nsearch_cur_bkref_entry (const re_match_context_t *mctx, Idx str_idx)\n{\n  Idx left, right, mid, last;\n  last = right = mctx->nbkref_ents;\n  for (left = 0; left < right;)\n    {\n      mid = (left + right) / 2;\n      if (mctx->bkref_ents[mid].str_idx < str_idx)\n\tleft = mid + 1;\n      else\n\tright = mid;\n    }\n  if (left < last && mctx->bkref_ents[left].str_idx == str_idx)\n    return left;\n  else\n    return REG_MISSING;\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "Idx",
        "internal_function",
        "internal_function"
      ]
    },
    "match_ctx_add_subtop": {
      "start_point": [
        4345,
        18
      ],
      "end_point": [
        4369,
        1
      ],
      "content": "__attribute_warn_unused_result__\nmatch_ctx_add_subtop (re_match_context_t *mctx, Idx node, Idx str_idx)\n{\n#ifdef DEBUG\n  assert (mctx->sub_tops != NULL);\n  assert (mctx->asub_tops > 0);\n#endif\n  if (BE (mctx->nsub_tops == mctx->asub_tops, 0))\n    {\n      Idx new_asub_tops = mctx->asub_tops * 2;\n      re_sub_match_top_t **new_array = re_realloc (mctx->sub_tops,\n\t\t\t\t\t\t   re_sub_match_top_t *,\n\t\t\t\t\t\t   new_asub_tops);\n      if (BE (new_array == NULL, 0))\n\treturn REG_ESPACE;\n      mctx->sub_tops = new_array;\n      mctx->asub_tops = new_asub_tops;\n    }\n  mctx->sub_tops[mctx->nsub_tops] = calloc (1, sizeof (re_sub_match_top_t));\n  if (BE (mctx->sub_tops[mctx->nsub_tops] == NULL, 0))\n    return REG_ESPACE;\n  mctx->sub_tops[mctx->nsub_tops]->node = node;\n  mctx->sub_tops[mctx->nsub_tops++]->str_idx = str_idx;\n  return REG_NOERROR;\n}",
      "lines": 25,
      "depth": 10,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "match_ctx_add_sublast": {
      "start_point": [
        4374,
        0
      ],
      "end_point": [
        4399,
        1
      ],
      "content": "static re_sub_match_last_t *\ninternal_function\nmatch_ctx_add_sublast (re_sub_match_top_t *subtop, Idx node, Idx str_idx)\n{\n  re_sub_match_last_t *new_entry;\n  if (BE (subtop->nlasts == subtop->alasts, 0))\n    {\n      Idx new_alasts = 2 * subtop->alasts + 1;\n      re_sub_match_last_t **new_array = re_realloc (subtop->lasts,\n\t\t\t\t\t\t    re_sub_match_last_t *,\n\t\t\t\t\t\t    new_alasts);\n      if (BE (new_array == NULL, 0))\n\treturn NULL;\n      subtop->lasts = new_array;\n      subtop->alasts = new_alasts;\n    }\n  new_entry = calloc (1, sizeof (re_sub_match_last_t));\n  if (BE (new_entry != NULL, 1))\n    {\n      subtop->lasts[subtop->nlasts] = new_entry;\n      new_entry->node = node;\n      new_entry->str_idx = str_idx;\n      ++subtop->nlasts;\n    }\n  return new_entry;\n}",
      "lines": 26,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "re_sub_match_last_t",
        "*\ninternal_function\nmatch_ctx_add_sublast (re_sub_match_top_t *subtop, Idx node, Idx str_idx)",
        "*",
        "internal_function",
        "internal_function"
      ]
    },
    "sift_ctx_init": {
      "start_point": [
        4401,
        0
      ],
      "end_point": [
        4411,
        1
      ],
      "content": "static void\ninternal_function\nsift_ctx_init (re_sift_context_t *sctx, re_dfastate_t **sifted_sts,\n\t       re_dfastate_t **limited_sts, Idx last_node, Idx last_str_idx)\n{\n  sctx->sifted_states = sifted_sts;\n  sctx->limited_states = limited_sts;\n  sctx->last_node = last_node;\n  sctx->last_str_idx = last_str_idx;\n  re_node_set_init_empty (&sctx->limits);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void",
        "internal_function",
        "internal_function"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/regex_internal.c": {
    "re_string_allocate": {
      "start_point": [
        37,
        18
      ],
      "end_point": [
        60,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_string_allocate (re_string_t *pstr, const char *str, Idx len, Idx init_len,\n\t\t    RE_TRANSLATE_TYPE trans, bool icase, const re_dfa_t *dfa)\n{\n  reg_errcode_t ret;\n  Idx init_buf_len;\n\n  /* Ensure at least one character fits into the buffers.  */\n  if (init_len < dfa->mb_cur_max)\n    init_len = dfa->mb_cur_max;\n  init_buf_len = (len + 1 < init_len) ? len + 1: init_len;\n  re_string_construct_common (str, len, pstr, trans, icase, dfa);\n\n  ret = re_string_realloc_buffers (pstr, init_buf_len);\n  if (BE (ret != REG_NOERROR, 0))\n    return ret;\n\n  pstr->word_char = dfa->word_char;\n  pstr->word_ops_used = dfa->word_ops_used;\n  pstr->mbs = pstr->mbs_allocated ? pstr->mbs : (unsigned char *) str;\n  pstr->valid_len = (pstr->mbs_allocated || dfa->mb_cur_max > 1) ? 0 : len;\n  pstr->valid_raw_len = pstr->valid_len;\n  return REG_NOERROR;\n}",
      "lines": 24,
      "depth": 10,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "re_string_construct": {
      "start_point": [
        65,
        18
      ],
      "end_point": [
        123,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_string_construct (re_string_t *pstr, const char *str, Idx len,\n\t\t     RE_TRANSLATE_TYPE trans, bool icase, const re_dfa_t *dfa)\n{\n  reg_errcode_t ret;\n  memset (pstr, '\\0', sizeof (re_string_t));\n  re_string_construct_common (str, len, pstr, trans, icase, dfa);\n\n  if (len > 0)\n    {\n      ret = re_string_realloc_buffers (pstr, len + 1);\n      if (BE (ret != REG_NOERROR, 0))\n\treturn ret;\n    }\n  pstr->mbs = pstr->mbs_allocated ? pstr->mbs : (unsigned char *) str;\n\n  if (icase)\n    {\n#ifdef RE_ENABLE_I18N\n      if (dfa->mb_cur_max > 1)\n\t{\n\t  while (1)\n\t    {\n\t      ret = build_wcs_upper_buffer (pstr);\n\t      if (BE (ret != REG_NOERROR, 0))\n\t\treturn ret;\n\t      if (pstr->valid_raw_len >= len)\n\t\tbreak;\n\t      if (pstr->bufs_len > pstr->valid_len + dfa->mb_cur_max)\n\t\tbreak;\n\t      ret = re_string_realloc_buffers (pstr, pstr->bufs_len * 2);\n\t      if (BE (ret != REG_NOERROR, 0))\n\t\treturn ret;\n\t    }\n\t}\n      else\n#endif /* RE_ENABLE_I18N  */\n\tbuild_upper_buffer (pstr);\n    }\n  else\n    {\n#ifdef RE_ENABLE_I18N\n      if (dfa->mb_cur_max > 1)\n\tbuild_wcs_buffer (pstr);\n      else\n#endif /* RE_ENABLE_I18N  */\n\t{\n\t  if (trans != NULL)\n\t    re_string_translate_buffer (pstr);\n\t  else\n\t    {\n\t      pstr->valid_len = pstr->bufs_len;\n\t      pstr->valid_raw_len = pstr->bufs_len;\n\t    }\n\t}\n    }\n\n  return REG_NOERROR;\n}",
      "lines": 59,
      "depth": 16,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "re_string_realloc_buffers": {
      "start_point": [
        128,
        18
      ],
      "end_point": [
        164,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_string_realloc_buffers (re_string_t *pstr, Idx new_buf_len)\n{\n#ifdef RE_ENABLE_I18N\n  if (pstr->mb_cur_max > 1)\n    {\n      wint_t *new_wcs;\n\n      /* Avoid overflow in realloc.  */\n      const size_t max_object_size = MAX (sizeof (wint_t), sizeof (Idx));\n      if (BE (MIN (IDX_MAX, SIZE_MAX / max_object_size) < new_buf_len, 0))\n\treturn REG_ESPACE;\n\n      new_wcs = re_realloc (pstr->wcs, wint_t, new_buf_len);\n      if (BE (new_wcs == NULL, 0))\n\treturn REG_ESPACE;\n      pstr->wcs = new_wcs;\n      if (pstr->offsets != NULL)\n\t{\n\t  Idx *new_offsets = re_realloc (pstr->offsets, Idx, new_buf_len);\n\t  if (BE (new_offsets == NULL, 0))\n\t    return REG_ESPACE;\n\t  pstr->offsets = new_offsets;\n\t}\n    }\n#endif /* RE_ENABLE_I18N  */\n  if (pstr->mbs_allocated)\n    {\n      unsigned char *new_mbs = re_realloc (pstr->mbs, unsigned char,\n\t\t\t\t\t   new_buf_len);\n      if (BE (new_mbs == NULL, 0))\n\treturn REG_ESPACE;\n      pstr->mbs = new_mbs;\n    }\n  pstr->bufs_len = new_buf_len;\n  return REG_NOERROR;\n}",
      "lines": 37,
      "depth": 14,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "re_string_construct_common": {
      "start_point": [
        167,
        0
      ],
      "end_point": [
        184,
        1
      ],
      "content": "static void\ninternal_function\nre_string_construct_common (const char *str, Idx len, re_string_t *pstr,\n\t\t\t    RE_TRANSLATE_TYPE trans, bool icase,\n\t\t\t    const re_dfa_t *dfa)\n{\n  pstr->raw_mbs = (const unsigned char *) str;\n  pstr->len = len;\n  pstr->raw_len = len;\n  pstr->trans = trans;\n  pstr->icase = icase;\n  pstr->mbs_allocated = (trans != NULL || icase);\n  pstr->mb_cur_max = dfa->mb_cur_max;\n  pstr->is_utf8 = dfa->is_utf8;\n  pstr->map_notascii = dfa->map_notascii;\n  pstr->stop = pstr->len;\n  pstr->raw_stop = pstr->stop;\n}",
      "lines": 18,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void",
        "internal_function",
        "internal_function"
      ]
    },
    "build_wcs_buffer": {
      "start_point": [
        199,
        0
      ],
      "end_point": [
        263,
        1
      ],
      "content": "static void\ninternal_function\nbuild_wcs_buffer (re_string_t *pstr)\n{\n#ifdef _LIBC\n  unsigned char buf[MB_LEN_MAX];\n  assert (MB_LEN_MAX >= pstr->mb_cur_max);\n#else\n  unsigned char buf[64];\n#endif\n  mbstate_t prev_st;\n  Idx byte_idx, end_idx, remain_len;\n  size_t mbclen;\n\n  /* Build the buffers from pstr->valid_len to either pstr->len or\n     pstr->bufs_len.  */\n  end_idx = (pstr->bufs_len > pstr->len) ? pstr->len : pstr->bufs_len;\n  for (byte_idx = pstr->valid_len; byte_idx < end_idx;)\n    {\n      wchar_t wc;\n      const char *p;\n\n      remain_len = end_idx - byte_idx;\n      prev_st = pstr->cur_state;\n      /* Apply the translation if we need.  */\n      if (BE (pstr->trans != NULL, 0))\n\t{\n\t  int i, ch;\n\n\t  for (i = 0; i < pstr->mb_cur_max && i < remain_len; ++i)\n\t    {\n\t      ch = pstr->raw_mbs [pstr->raw_mbs_idx + byte_idx + i];\n\t      buf[i] = pstr->mbs[byte_idx + i] = pstr->trans[ch];\n\t    }\n\t  p = (const char *) buf;\n\t}\n      else\n\tp = (const char *) pstr->raw_mbs + pstr->raw_mbs_idx + byte_idx;\n      mbclen = __mbrtowc (&wc, p, remain_len, &pstr->cur_state);\n      if (BE (mbclen == (size_t) -1 || mbclen == 0\n\t      || (mbclen == (size_t) -2 && pstr->bufs_len >= pstr->len), 0))\n\t{\n\t  /* We treat these cases as a singlebyte character.  */\n\t  mbclen = 1;\n\t  wc = (wchar_t) pstr->raw_mbs[pstr->raw_mbs_idx + byte_idx];\n\t  if (BE (pstr->trans != NULL, 0))\n\t    wc = pstr->trans[wc];\n\t  pstr->cur_state = prev_st;\n\t}\n      else if (BE (mbclen == (size_t) -2, 0))\n\t{\n\t  /* The buffer doesn't have enough space, finish to build.  */\n\t  pstr->cur_state = prev_st;\n\t  break;\n\t}\n\n      /* Write wide character and padding.  */\n      pstr->wcs[byte_idx++] = wc;\n      /* Write paddings.  */\n      for (remain_len = byte_idx + mbclen - 1; byte_idx < remain_len ;)\n\tpstr->wcs[byte_idx++] = WEOF;\n    }\n  pstr->valid_len = byte_idx;\n  pstr->valid_raw_len = byte_idx;\n}",
      "lines": 65,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void",
        "internal_function",
        "internal_function"
      ]
    },
    "build_wcs_upper_buffer": {
      "start_point": [
        269,
        18
      ],
      "end_point": [
        480,
        1
      ],
      "content": "__attribute_warn_unused_result__\nbuild_wcs_upper_buffer (re_string_t *pstr)\n{\n  mbstate_t prev_st;\n  Idx src_idx, byte_idx, end_idx, remain_len;\n  size_t mbclen;\n#ifdef _LIBC\n  char buf[MB_LEN_MAX];\n  assert (MB_LEN_MAX >= pstr->mb_cur_max);\n#else\n  char buf[64];\n#endif\n\n  byte_idx = pstr->valid_len;\n  end_idx = (pstr->bufs_len > pstr->len) ? pstr->len : pstr->bufs_len;\n\n  /* The following optimization assumes that ASCII characters can be\n     mapped to wide characters with a simple cast.  */\n  if (! pstr->map_notascii && pstr->trans == NULL && !pstr->offsets_needed)\n    {\n      while (byte_idx < end_idx)\n\t{\n\t  wchar_t wc;\n\n\t  if (isascii (pstr->raw_mbs[pstr->raw_mbs_idx + byte_idx])\n\t      && mbsinit (&pstr->cur_state))\n\t    {\n\t      /* In case of a singlebyte character.  */\n\t      pstr->mbs[byte_idx]\n\t\t= toupper (pstr->raw_mbs[pstr->raw_mbs_idx + byte_idx]);\n\t      /* The next step uses the assumption that wchar_t is encoded\n\t\t ASCII-safe: all ASCII values can be converted like this.  */\n\t      pstr->wcs[byte_idx] = (wchar_t) pstr->mbs[byte_idx];\n\t      ++byte_idx;\n\t      continue;\n\t    }\n\n\t  remain_len = end_idx - byte_idx;\n\t  prev_st = pstr->cur_state;\n\t  mbclen = __mbrtowc (&wc,\n\t\t\t      ((const char *) pstr->raw_mbs + pstr->raw_mbs_idx\n\t\t\t       + byte_idx), remain_len, &pstr->cur_state);\n\t  if (BE (mbclen < (size_t) -2, 1))\n\t    {\n\t      wchar_t wcu = __towupper (wc);\n\t      if (wcu != wc)\n\t\t{\n\t\t  size_t mbcdlen;\n\n\t\t  mbcdlen = __wcrtomb (buf, wcu, &prev_st);\n\t\t  if (BE (mbclen == mbcdlen, 1))\n\t\t    memcpy (pstr->mbs + byte_idx, buf, mbclen);\n\t\t  else\n\t\t    {\n\t\t      src_idx = byte_idx;\n\t\t      goto offsets_needed;\n\t\t    }\n\t\t}\n\t      else\n\t\tmemcpy (pstr->mbs + byte_idx,\n\t\t\tpstr->raw_mbs + pstr->raw_mbs_idx + byte_idx, mbclen);\n\t      pstr->wcs[byte_idx++] = wcu;\n\t      /* Write paddings.  */\n\t      for (remain_len = byte_idx + mbclen - 1; byte_idx < remain_len ;)\n\t\tpstr->wcs[byte_idx++] = WEOF;\n\t    }\n\t  else if (mbclen == (size_t) -1 || mbclen == 0\n\t\t   || (mbclen == (size_t) -2 && pstr->bufs_len >= pstr->len))\n\t    {\n\t      /* It is an invalid character, an incomplete character\n\t\t at the end of the string, or '\\0'.  Just use the byte.  */\n\t      int ch = pstr->raw_mbs[pstr->raw_mbs_idx + byte_idx];\n\t      pstr->mbs[byte_idx] = ch;\n\t      /* And also cast it to wide char.  */\n\t      pstr->wcs[byte_idx++] = (wchar_t) ch;\n\t      if (BE (mbclen == (size_t) -1, 0))\n\t\tpstr->cur_state = prev_st;\n\t    }\n\t  else\n\t    {\n\t      /* The buffer doesn't have enough space, finish to build.  */\n\t      pstr->cur_state = prev_st;\n\t      break;\n\t    }\n\t}\n      pstr->valid_len = byte_idx;\n      pstr->valid_raw_len = byte_idx;\n      return REG_NOERROR;\n    }\n  else\n    for (src_idx = pstr->valid_raw_len; byte_idx < end_idx;)\n      {\n\twchar_t wc;\n\tconst char *p;\n      offsets_needed:\n\tremain_len = end_idx - byte_idx;\n\tprev_st = pstr->cur_state;\n\tif (BE (pstr->trans != NULL, 0))\n\t  {\n\t    int i, ch;\n\n\t    for (i = 0; i < pstr->mb_cur_max && i < remain_len; ++i)\n\t      {\n\t\tch = pstr->raw_mbs [pstr->raw_mbs_idx + src_idx + i];\n\t\tbuf[i] = pstr->trans[ch];\n\t      }\n\t    p = (const char *) buf;\n\t  }\n\telse\n\t  p = (const char *) pstr->raw_mbs + pstr->raw_mbs_idx + src_idx;\n\tmbclen = __mbrtowc (&wc, p, remain_len, &pstr->cur_state);\n\tif (BE (mbclen < (size_t) -2, 1))\n\t  {\n\t    wchar_t wcu = __towupper (wc);\n\t    if (wcu != wc)\n\t      {\n\t\tsize_t mbcdlen;\n\n\t\tmbcdlen = wcrtomb ((char *) buf, wcu, &prev_st);\n\t\tif (BE (mbclen == mbcdlen, 1))\n\t\t  memcpy (pstr->mbs + byte_idx, buf, mbclen);\n\t\telse if (mbcdlen != (size_t) -1)\n\t\t  {\n\t\t    size_t i;\n\n\t\t    if (byte_idx + mbcdlen > pstr->bufs_len)\n\t\t      {\n\t\t\tpstr->cur_state = prev_st;\n\t\t\tbreak;\n\t\t      }\n\n\t\t    if (pstr->offsets == NULL)\n\t\t      {\n\t\t\tpstr->offsets = re_malloc (Idx, pstr->bufs_len);\n\n\t\t\tif (pstr->offsets == NULL)\n\t\t\t  return REG_ESPACE;\n\t\t      }\n\t\t    if (!pstr->offsets_needed)\n\t\t      {\n\t\t\tfor (i = 0; i < (size_t) byte_idx; ++i)\n\t\t\t  pstr->offsets[i] = i;\n\t\t\tpstr->offsets_needed = 1;\n\t\t      }\n\n\t\t    memcpy (pstr->mbs + byte_idx, buf, mbcdlen);\n\t\t    pstr->wcs[byte_idx] = wcu;\n\t\t    pstr->offsets[byte_idx] = src_idx;\n\t\t    for (i = 1; i < mbcdlen; ++i)\n\t\t      {\n\t\t\tpstr->offsets[byte_idx + i]\n\t\t\t  = src_idx + (i < mbclen ? i : mbclen - 1);\n\t\t\tpstr->wcs[byte_idx + i] = WEOF;\n\t\t      }\n\t\t    pstr->len += mbcdlen - mbclen;\n\t\t    if (pstr->raw_stop > src_idx)\n\t\t      pstr->stop += mbcdlen - mbclen;\n\t\t    end_idx = (pstr->bufs_len > pstr->len)\n\t\t\t      ? pstr->len : pstr->bufs_len;\n\t\t    byte_idx += mbcdlen;\n\t\t    src_idx += mbclen;\n\t\t    continue;\n\t\t  }\n\t\telse\n\t\t  memcpy (pstr->mbs + byte_idx, p, mbclen);\n\t      }\n\t    else\n\t      memcpy (pstr->mbs + byte_idx, p, mbclen);\n\n\t    if (BE (pstr->offsets_needed != 0, 0))\n\t      {\n\t\tsize_t i;\n\t\tfor (i = 0; i < mbclen; ++i)\n\t\t  pstr->offsets[byte_idx + i] = src_idx + i;\n\t      }\n\t    src_idx += mbclen;\n\n\t    pstr->wcs[byte_idx++] = wcu;\n\t    /* Write paddings.  */\n\t    for (remain_len = byte_idx + mbclen - 1; byte_idx < remain_len ;)\n\t      pstr->wcs[byte_idx++] = WEOF;\n\t  }\n\telse if (mbclen == (size_t) -1 || mbclen == 0\n\t\t || (mbclen == (size_t) -2 && pstr->bufs_len >= pstr->len))\n\t  {\n\t    /* It is an invalid character or '\\0'.  Just use the byte.  */\n\t    int ch = pstr->raw_mbs[pstr->raw_mbs_idx + src_idx];\n\n\t    if (BE (pstr->trans != NULL, 0))\n\t      ch = pstr->trans [ch];\n\t    pstr->mbs[byte_idx] = ch;\n\n\t    if (BE (pstr->offsets_needed != 0, 0))\n\t      pstr->offsets[byte_idx] = src_idx;\n\t    ++src_idx;\n\n\t    /* And also cast it to wide char.  */\n\t    pstr->wcs[byte_idx++] = (wchar_t) ch;\n\t    if (BE (mbclen == (size_t) -1, 0))\n\t      pstr->cur_state = prev_st;\n\t  }\n\telse\n\t  {\n\t    /* The buffer doesn't have enough space, finish to build.  */\n\t    pstr->cur_state = prev_st;\n\t    break;\n\t  }\n      }\n  pstr->valid_len = byte_idx;\n  pstr->valid_raw_len = src_idx;\n  return REG_NOERROR;\n}",
      "lines": 212,
      "depth": 21,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "re_string_skip_chars": {
      "start_point": [
        485,
        0
      ],
      "end_point": [
        520,
        1
      ],
      "content": "static Idx\ninternal_function\nre_string_skip_chars (re_string_t *pstr, Idx new_raw_idx, wint_t *last_wc)\n{\n  mbstate_t prev_st;\n  Idx rawbuf_idx;\n  size_t mbclen;\n  wint_t wc = WEOF;\n\n  /* Skip the characters which are not necessary to check.  */\n  for (rawbuf_idx = pstr->raw_mbs_idx + pstr->valid_raw_len;\n       rawbuf_idx < new_raw_idx;)\n    {\n      wchar_t wc2;\n      Idx remain_len = pstr->raw_len - rawbuf_idx;\n      prev_st = pstr->cur_state;\n      mbclen = __mbrtowc (&wc2, (const char *) pstr->raw_mbs + rawbuf_idx,\n\t\t\t  remain_len, &pstr->cur_state);\n      if (BE (mbclen == (size_t) -2 || mbclen == (size_t) -1 || mbclen == 0, 0))\n\t{\n\t  /* We treat these cases as a single byte character.  */\n\t  if (mbclen == 0 || remain_len == 0)\n\t    wc = L'\\0';\n\t  else\n\t    wc = *(unsigned char *) (pstr->raw_mbs + rawbuf_idx);\n\t  mbclen = 1;\n\t  pstr->cur_state = prev_st;\n\t}\n      else\n\twc = wc2;\n      /* Then proceed the next character.  */\n      rawbuf_idx += mbclen;\n    }\n  *last_wc = wc;\n  return rawbuf_idx;\n}",
      "lines": 36,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "Idx",
        "internal_function",
        "internal_function"
      ]
    },
    "build_upper_buffer": {
      "start_point": [
        526,
        0
      ],
      "end_point": [
        542,
        1
      ],
      "content": "static void\ninternal_function\nbuild_upper_buffer (re_string_t *pstr)\n{\n  Idx char_idx, end_idx;\n  end_idx = (pstr->bufs_len > pstr->len) ? pstr->len : pstr->bufs_len;\n\n  for (char_idx = pstr->valid_len; char_idx < end_idx; ++char_idx)\n    {\n      int ch = pstr->raw_mbs[pstr->raw_mbs_idx + char_idx];\n      if (BE (pstr->trans != NULL, 0))\n\tch = pstr->trans[ch];\n      pstr->mbs[char_idx] = toupper (ch);\n    }\n  pstr->valid_len = char_idx;\n  pstr->valid_raw_len = char_idx;\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void",
        "internal_function",
        "internal_function"
      ]
    },
    "re_string_translate_buffer": {
      "start_point": [
        546,
        0
      ],
      "end_point": [
        561,
        1
      ],
      "content": "static void\ninternal_function\nre_string_translate_buffer (re_string_t *pstr)\n{\n  Idx buf_idx, end_idx;\n  end_idx = (pstr->bufs_len > pstr->len) ? pstr->len : pstr->bufs_len;\n\n  for (buf_idx = pstr->valid_len; buf_idx < end_idx; ++buf_idx)\n    {\n      int ch = pstr->raw_mbs[pstr->raw_mbs_idx + buf_idx];\n      pstr->mbs[buf_idx] = pstr->trans[ch];\n    }\n\n  pstr->valid_len = buf_idx;\n  pstr->valid_raw_len = buf_idx;\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void",
        "internal_function",
        "internal_function"
      ]
    },
    "re_string_reconstruct": {
      "start_point": [
        568,
        18
      ],
      "end_point": [
        828,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_string_reconstruct (re_string_t *pstr, Idx idx, int eflags)\n{\n  Idx offset;\n\n  if (BE (pstr->raw_mbs_idx <= idx, 0))\n    offset = idx - pstr->raw_mbs_idx;\n  else\n    {\n      /* Reset buffer.  */\n#ifdef RE_ENABLE_I18N\n      if (pstr->mb_cur_max > 1)\n\tmemset (&pstr->cur_state, '\\0', sizeof (mbstate_t));\n#endif /* RE_ENABLE_I18N */\n      pstr->len = pstr->raw_len;\n      pstr->stop = pstr->raw_stop;\n      pstr->valid_len = 0;\n      pstr->raw_mbs_idx = 0;\n      pstr->valid_raw_len = 0;\n      pstr->offsets_needed = 0;\n      pstr->tip_context = ((eflags & REG_NOTBOL) ? CONTEXT_BEGBUF\n\t\t\t   : CONTEXT_NEWLINE | CONTEXT_BEGBUF);\n      if (!pstr->mbs_allocated)\n\tpstr->mbs = (unsigned char *) pstr->raw_mbs;\n      offset = idx;\n    }\n\n  if (BE (offset != 0, 1))\n    {\n      /* Should the already checked characters be kept?  */\n      if (BE (offset < pstr->valid_raw_len, 1))\n\t{\n\t  /* Yes, move them to the front of the buffer.  */\n#ifdef RE_ENABLE_I18N\n\t  if (BE (pstr->offsets_needed, 0))\n\t    {\n\t      Idx low = 0, high = pstr->valid_len, mid;\n\t      do\n\t\t{\n\t\t  mid = (high + low) / 2;\n\t\t  if (pstr->offsets[mid] > offset)\n\t\t    high = mid;\n\t\t  else if (pstr->offsets[mid] < offset)\n\t\t    low = mid + 1;\n\t\t  else\n\t\t    break;\n\t\t}\n\t      while (low < high);\n\t      if (pstr->offsets[mid] < offset)\n\t\t++mid;\n\t      pstr->tip_context = re_string_context_at (pstr, mid - 1,\n\t\t\t\t\t\t\teflags);\n\t      /* This can be quite complicated, so handle specially\n\t\t only the common and easy case where the character with\n\t\t different length representation of lower and upper\n\t\t case is present at or after offset.  */\n\t      if (pstr->valid_len > offset\n\t\t  && mid == offset && pstr->offsets[mid] == offset)\n\t\t{\n\t\t  memmove (pstr->wcs, pstr->wcs + offset,\n\t\t\t   (pstr->valid_len - offset) * sizeof (wint_t));\n\t\t  memmove (pstr->mbs, pstr->mbs + offset, pstr->valid_len - offset);\n\t\t  pstr->valid_len -= offset;\n\t\t  pstr->valid_raw_len -= offset;\n\t\t  for (low = 0; low < pstr->valid_len; low++)\n\t\t    pstr->offsets[low] = pstr->offsets[low + offset] - offset;\n\t\t}\n\t      else\n\t\t{\n\t\t  /* Otherwise, just find out how long the partial multibyte\n\t\t     character at offset is and fill it with WEOF/255.  */\n\t\t  pstr->len = pstr->raw_len - idx + offset;\n\t\t  pstr->stop = pstr->raw_stop - idx + offset;\n\t\t  pstr->offsets_needed = 0;\n\t\t  while (mid > 0 && pstr->offsets[mid - 1] == offset)\n\t\t    --mid;\n\t\t  while (mid < pstr->valid_len)\n\t\t    if (pstr->wcs[mid] != WEOF)\n\t\t      break;\n\t\t    else\n\t\t      ++mid;\n\t\t  if (mid == pstr->valid_len)\n\t\t    pstr->valid_len = 0;\n\t\t  else\n\t\t    {\n\t\t      pstr->valid_len = pstr->offsets[mid] - offset;\n\t\t      if (pstr->valid_len)\n\t\t\t{\n\t\t\t  for (low = 0; low < pstr->valid_len; ++low)\n\t\t\t    pstr->wcs[low] = WEOF;\n\t\t\t  memset (pstr->mbs, 255, pstr->valid_len);\n\t\t\t}\n\t\t    }\n\t\t  pstr->valid_raw_len = pstr->valid_len;\n\t\t}\n\t    }\n\t  else\n#endif\n\t    {\n\t      pstr->tip_context = re_string_context_at (pstr, offset - 1,\n\t\t\t\t\t\t\teflags);\n#ifdef RE_ENABLE_I18N\n\t      if (pstr->mb_cur_max > 1)\n\t\tmemmove (pstr->wcs, pstr->wcs + offset,\n\t\t\t (pstr->valid_len - offset) * sizeof (wint_t));\n#endif /* RE_ENABLE_I18N */\n\t      if (BE (pstr->mbs_allocated, 0))\n\t\tmemmove (pstr->mbs, pstr->mbs + offset,\n\t\t\t pstr->valid_len - offset);\n\t      pstr->valid_len -= offset;\n\t      pstr->valid_raw_len -= offset;\n#if defined DEBUG && DEBUG\n\t      assert (pstr->valid_len > 0);\n#endif\n\t    }\n\t}\n      else\n\t{\n#ifdef RE_ENABLE_I18N\n\t  /* No, skip all characters until IDX.  */\n\t  Idx prev_valid_len = pstr->valid_len;\n\n\t  if (BE (pstr->offsets_needed, 0))\n\t    {\n\t      pstr->len = pstr->raw_len - idx + offset;\n\t      pstr->stop = pstr->raw_stop - idx + offset;\n\t      pstr->offsets_needed = 0;\n\t    }\n#endif\n\t  pstr->valid_len = 0;\n#ifdef RE_ENABLE_I18N\n\t  if (pstr->mb_cur_max > 1)\n\t    {\n\t      Idx wcs_idx;\n\t      wint_t wc = WEOF;\n\n\t      if (pstr->is_utf8)\n\t\t{\n\t\t  const unsigned char *raw, *p, *end;\n\n\t\t  /* Special case UTF-8.  Multi-byte chars start with any\n\t\t     byte other than 0x80 - 0xbf.  */\n\t\t  raw = pstr->raw_mbs + pstr->raw_mbs_idx;\n\t\t  end = raw + (offset - pstr->mb_cur_max);\n\t\t  if (end < pstr->raw_mbs)\n\t\t    end = pstr->raw_mbs;\n\t\t  p = raw + offset - 1;\n#ifdef _LIBC\n\t\t  /* We know the wchar_t encoding is UCS4, so for the simple\n\t\t     case, ASCII characters, skip the conversion step.  */\n\t\t  if (isascii (*p) && BE (pstr->trans == NULL, 1))\n\t\t    {\n\t\t      memset (&pstr->cur_state, '\\0', sizeof (mbstate_t));\n\t\t      /* pstr->valid_len = 0; */\n\t\t      wc = (wchar_t) *p;\n\t\t    }\n\t\t  else\n#endif\n\t\t    for (; p >= end; --p)\n\t\t      if ((*p & 0xc0) != 0x80)\n\t\t\t{\n\t\t\t  mbstate_t cur_state;\n\t\t\t  wchar_t wc2;\n\t\t\t  Idx mlen = raw + pstr->len - p;\n\t\t\t  unsigned char buf[6];\n\t\t\t  size_t mbclen;\n\n\t\t\t  const unsigned char *pp = p;\n\t\t\t  if (BE (pstr->trans != NULL, 0))\n\t\t\t    {\n\t\t\t      int i = mlen < 6 ? mlen : 6;\n\t\t\t      while (--i >= 0)\n\t\t\t\tbuf[i] = pstr->trans[p[i]];\n\t\t\t      pp = buf;\n\t\t\t    }\n\t\t\t  /* XXX Don't use mbrtowc, we know which conversion\n\t\t\t     to use (UTF-8 -> UCS4).  */\n\t\t\t  memset (&cur_state, 0, sizeof (cur_state));\n\t\t\t  mbclen = __mbrtowc (&wc2, (const char *) pp, mlen,\n\t\t\t\t\t      &cur_state);\n\t\t\t  if (raw + offset - p <= mbclen\n\t\t\t      && mbclen < (size_t) -2)\n\t\t\t    {\n\t\t\t      memset (&pstr->cur_state, '\\0',\n\t\t\t\t      sizeof (mbstate_t));\n\t\t\t      pstr->valid_len = mbclen - (raw + offset - p);\n\t\t\t      wc = wc2;\n\t\t\t    }\n\t\t\t  break;\n\t\t\t}\n\t\t}\n\n\t      if (wc == WEOF)\n\t\tpstr->valid_len = re_string_skip_chars (pstr, idx, &wc) - idx;\n\t      if (wc == WEOF)\n\t\tpstr->tip_context\n\t\t  = re_string_context_at (pstr, prev_valid_len - 1, eflags);\n\t      else\n\t\tpstr->tip_context = ((BE (pstr->word_ops_used != 0, 0)\n\t\t\t\t      && IS_WIDE_WORD_CHAR (wc))\n\t\t\t\t     ? CONTEXT_WORD\n\t\t\t\t     : ((IS_WIDE_NEWLINE (wc)\n\t\t\t\t\t && pstr->newline_anchor)\n\t\t\t\t\t? CONTEXT_NEWLINE : 0));\n\t      if (BE (pstr->valid_len, 0))\n\t\t{\n\t\t  for (wcs_idx = 0; wcs_idx < pstr->valid_len; ++wcs_idx)\n\t\t    pstr->wcs[wcs_idx] = WEOF;\n\t\t  if (pstr->mbs_allocated)\n\t\t    memset (pstr->mbs, 255, pstr->valid_len);\n\t\t}\n\t      pstr->valid_raw_len = pstr->valid_len;\n\t    }\n\t  else\n#endif /* RE_ENABLE_I18N */\n\t    {\n\t      int c = pstr->raw_mbs[pstr->raw_mbs_idx + offset - 1];\n\t      pstr->valid_raw_len = 0;\n\t      if (pstr->trans)\n\t\tc = pstr->trans[c];\n\t      pstr->tip_context = (bitset_contain (pstr->word_char, c)\n\t\t\t\t   ? CONTEXT_WORD\n\t\t\t\t   : ((IS_NEWLINE (c) && pstr->newline_anchor)\n\t\t\t\t      ? CONTEXT_NEWLINE : 0));\n\t    }\n\t}\n      if (!BE (pstr->mbs_allocated, 0))\n\tpstr->mbs += offset;\n    }\n  pstr->raw_mbs_idx = idx;\n  pstr->len -= offset;\n  pstr->stop -= offset;\n\n  /* Then build the buffers.  */\n#ifdef RE_ENABLE_I18N\n  if (pstr->mb_cur_max > 1)\n    {\n      if (pstr->icase)\n\t{\n\t  reg_errcode_t ret = build_wcs_upper_buffer (pstr);\n\t  if (BE (ret != REG_NOERROR, 0))\n\t    return ret;\n\t}\n      else\n\tbuild_wcs_buffer (pstr);\n    }\n  else\n#endif /* RE_ENABLE_I18N */\n    if (BE (pstr->mbs_allocated, 0))\n      {\n\tif (pstr->icase)\n\t  build_upper_buffer (pstr);\n\telse if (pstr->trans != NULL)\n\t  re_string_translate_buffer (pstr);\n      }\n    else\n      pstr->valid_len = pstr->len;\n\n  pstr->cur_idx = 0;\n  return REG_NOERROR;\n}",
      "lines": 261,
      "depth": 23,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "internal_function": {
      "start_point": [
        831,
        18
      ],
      "end_point": [
        865,
        1
      ],
      "content": "__attribute__ ((pure))\nre_string_peek_byte_case (const re_string_t *pstr, Idx idx)\n{\n  int ch;\n  Idx off;\n\n  /* Handle the common (easiest) cases first.  */\n  if (BE (!pstr->mbs_allocated, 1))\n    return re_string_peek_byte (pstr, idx);\n\n#ifdef RE_ENABLE_I18N\n  if (pstr->mb_cur_max > 1\n      && ! re_string_is_single_byte_char (pstr, pstr->cur_idx + idx))\n    return re_string_peek_byte (pstr, idx);\n#endif\n\n  off = pstr->cur_idx + idx;\n#ifdef RE_ENABLE_I18N\n  if (pstr->offsets_needed)\n    off = pstr->offsets[off];\n#endif\n\n  ch = pstr->raw_mbs[pstr->raw_mbs_idx + off];\n\n#ifdef RE_ENABLE_I18N\n  /* Ensure that e.g. for tr_TR.UTF-8 BACKSLASH DOTLESS SMALL LETTER I\n     this function returns CAPITAL LETTER I instead of first byte of\n     DOTLESS SMALL LETTER I.  The latter would confuse the parser,\n     since peek_byte_case doesn't advance cur_idx in any way.  */\n  if (pstr->offsets_needed && !isascii (ch))\n    return re_string_peek_byte (pstr, idx);\n#endif\n\n  return ch;\n}",
      "lines": 35,
      "depth": 12,
      "decorators": null
    },
    "re_string_fetch_byte_case": {
      "start_point": [
        867,
        0
      ],
      "end_point": [
        903,
        1
      ],
      "content": "static unsigned char\ninternal_function\nre_string_fetch_byte_case (re_string_t *pstr)\n{\n  if (BE (!pstr->mbs_allocated, 1))\n    return re_string_fetch_byte (pstr);\n\n#ifdef RE_ENABLE_I18N\n  if (pstr->offsets_needed)\n    {\n      Idx off;\n      int ch;\n\n      /* For tr_TR.UTF-8 [[:islower:]] there is\n\t [[: CAPITAL LETTER I WITH DOT lower:]] in mbs.  Skip\n\t in that case the whole multi-byte character and return\n\t the original letter.  On the other side, with\n\t [[: DOTLESS SMALL LETTER I return [[:I, as doing\n\t anything else would complicate things too much.  */\n\n      if (!re_string_first_byte (pstr, pstr->cur_idx))\n\treturn re_string_fetch_byte (pstr);\n\n      off = pstr->offsets[pstr->cur_idx];\n      ch = pstr->raw_mbs[pstr->raw_mbs_idx + off];\n\n      if (! isascii (ch))\n\treturn re_string_fetch_byte (pstr);\n\n      re_string_skip_bytes (pstr,\n\t\t\t    re_string_char_size_at (pstr, pstr->cur_idx));\n      return ch;\n    }\n#endif\n\n  return pstr->raw_mbs[pstr->raw_mbs_idx + pstr->cur_idx++];\n}",
      "lines": 37,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "unsigned char",
        "unsigned",
        "char",
        "internal_function",
        "internal_function"
      ]
    },
    "re_string_destruct": {
      "start_point": [
        905,
        0
      ],
      "end_point": [
        915,
        1
      ],
      "content": "static void\ninternal_function\nre_string_destruct (re_string_t *pstr)\n{\n#ifdef RE_ENABLE_I18N\n  re_free (pstr->wcs);\n  re_free (pstr->offsets);\n#endif /* RE_ENABLE_I18N  */\n  if (pstr->mbs_allocated)\n    re_free (pstr->mbs);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void",
        "internal_function",
        "internal_function"
      ]
    },
    "re_string_context_at": {
      "start_point": [
        919,
        0
      ],
      "end_point": [
        960,
        1
      ],
      "content": "static unsigned int\ninternal_function\nre_string_context_at (const re_string_t *input, Idx idx, int eflags)\n{\n  int c;\n  if (BE (! REG_VALID_INDEX (idx), 0))\n    /* In this case, we use the value stored in input->tip_context,\n       since we can't know the character in input->mbs[-1] here.  */\n    return input->tip_context;\n  if (BE (idx == input->len, 0))\n    return ((eflags & REG_NOTEOL) ? CONTEXT_ENDBUF\n\t    : CONTEXT_NEWLINE | CONTEXT_ENDBUF);\n#ifdef RE_ENABLE_I18N\n  if (input->mb_cur_max > 1)\n    {\n      wint_t wc;\n      Idx wc_idx = idx;\n      while(input->wcs[wc_idx] == WEOF)\n\t{\n#if defined DEBUG && DEBUG\n\t  /* It must not happen.  */\n\t  assert (REG_VALID_INDEX (wc_idx));\n#endif\n\t  --wc_idx;\n\t  if (! REG_VALID_INDEX (wc_idx))\n\t    return input->tip_context;\n\t}\n      wc = input->wcs[wc_idx];\n      if (BE (input->word_ops_used != 0, 0) && IS_WIDE_WORD_CHAR (wc))\n\treturn CONTEXT_WORD;\n      return (IS_WIDE_NEWLINE (wc) && input->newline_anchor\n\t      ? CONTEXT_NEWLINE : 0);\n    }\n  else\n#endif\n    {\n      c = re_string_byte_at (input, idx);\n      if (bitset_contain (input->word_char, c))\n\treturn CONTEXT_WORD;\n      return IS_NEWLINE (c) && input->newline_anchor ? CONTEXT_NEWLINE : 0;\n    }\n}",
      "lines": 42,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "unsigned int",
        "unsigned",
        "int",
        "internal_function",
        "internal_function"
      ]
    },
    "re_node_set_alloc": {
      "start_point": [
        965,
        18
      ],
      "end_point": [
        974,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_node_set_alloc (re_node_set *set, Idx size)\n{\n  set->alloc = size;\n  set->nelem = 0;\n  set->elems = re_malloc (Idx, size);\n  if (BE (set->elems == NULL, 0) && (MALLOC_0_IS_NONNULL || size != 0))\n    return REG_ESPACE;\n  return REG_NOERROR;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "re_node_set_init_1": {
      "start_point": [
        977,
        18
      ],
      "end_point": [
        990,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_node_set_init_1 (re_node_set *set, Idx elem)\n{\n  set->alloc = 1;\n  set->nelem = 1;\n  set->elems = re_malloc (Idx, 1);\n  if (BE (set->elems == NULL, 0))\n    {\n      set->alloc = set->nelem = 0;\n      return REG_ESPACE;\n    }\n  set->elems[0] = elem;\n  return REG_NOERROR;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "re_node_set_init_2": {
      "start_point": [
        993,
        18
      ],
      "end_point": [
        1020,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_node_set_init_2 (re_node_set *set, Idx elem1, Idx elem2)\n{\n  set->alloc = 2;\n  set->elems = re_malloc (Idx, 2);\n  if (BE (set->elems == NULL, 0))\n    return REG_ESPACE;\n  if (elem1 == elem2)\n    {\n      set->nelem = 1;\n      set->elems[0] = elem1;\n    }\n  else\n    {\n      set->nelem = 2;\n      if (elem1 < elem2)\n\t{\n\t  set->elems[0] = elem1;\n\t  set->elems[1] = elem2;\n\t}\n      else\n\t{\n\t  set->elems[0] = elem2;\n\t  set->elems[1] = elem1;\n\t}\n    }\n  return REG_NOERROR;\n}",
      "lines": 28,
      "depth": 11,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "re_node_set_init_copy": {
      "start_point": [
        1023,
        18
      ],
      "end_point": [
        1041,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_node_set_init_copy (re_node_set *dest, const re_node_set *src)\n{\n  dest->nelem = src->nelem;\n  if (src->nelem > 0)\n    {\n      dest->alloc = dest->nelem;\n      dest->elems = re_malloc (Idx, dest->alloc);\n      if (BE (dest->elems == NULL, 0))\n\t{\n\t  dest->alloc = dest->nelem = 0;\n\t  return REG_ESPACE;\n\t}\n      memcpy (dest->elems, src->elems, src->nelem * sizeof (Idx));\n    }\n  else\n    re_node_set_init_empty (dest);\n  return REG_NOERROR;\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "re_node_set_add_intersect": {
      "start_point": [
        1048,
        18
      ],
      "end_point": [
        1133,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_node_set_add_intersect (re_node_set *dest, const re_node_set *src1,\n\t\t\t   const re_node_set *src2)\n{\n  Idx i1, i2, is, id, delta, sbase;\n  if (src1->nelem == 0 || src2->nelem == 0)\n    return REG_NOERROR;\n\n  /* We need dest->nelem + 2 * elems_in_intersection; this is a\n     conservative estimate.  */\n  if (src1->nelem + src2->nelem + dest->nelem > dest->alloc)\n    {\n      Idx new_alloc = src1->nelem + src2->nelem + dest->alloc;\n      Idx *new_elems = re_realloc (dest->elems, Idx, new_alloc);\n      if (BE (new_elems == NULL, 0))\n\treturn REG_ESPACE;\n      dest->elems = new_elems;\n      dest->alloc = new_alloc;\n    }\n\n  /* Find the items in the intersection of SRC1 and SRC2, and copy\n     into the top of DEST those that are not already in DEST itself.  */\n  sbase = dest->nelem + src1->nelem + src2->nelem;\n  i1 = src1->nelem - 1;\n  i2 = src2->nelem - 1;\n  id = dest->nelem - 1;\n  for (;;)\n    {\n      if (src1->elems[i1] == src2->elems[i2])\n\t{\n\t  /* Try to find the item in DEST.  Maybe we could binary search?  */\n\t  while (REG_VALID_INDEX (id) && dest->elems[id] > src1->elems[i1])\n\t    --id;\n\n          if (! REG_VALID_INDEX (id) || dest->elems[id] != src1->elems[i1])\n            dest->elems[--sbase] = src1->elems[i1];\n\n\t  if (! REG_VALID_INDEX (--i1) || ! REG_VALID_INDEX (--i2))\n\t    break;\n\t}\n\n      /* Lower the highest of the two items.  */\n      else if (src1->elems[i1] < src2->elems[i2])\n\t{\n\t  if (! REG_VALID_INDEX (--i2))\n\t    break;\n\t}\n      else\n\t{\n\t  if (! REG_VALID_INDEX (--i1))\n\t    break;\n\t}\n    }\n\n  id = dest->nelem - 1;\n  is = dest->nelem + src1->nelem + src2->nelem - 1;\n  delta = is - sbase + 1;\n\n  /* Now copy.  When DELTA becomes zero, the remaining\n     DEST elements are already in place; this is more or\n     less the same loop that is in re_node_set_merge.  */\n  dest->nelem += delta;\n  if (delta > 0 && REG_VALID_INDEX (id))\n    for (;;)\n      {\n\tif (dest->elems[is] > dest->elems[id])\n\t  {\n\t    /* Copy from the top.  */\n\t    dest->elems[id + delta--] = dest->elems[is--];\n\t    if (delta == 0)\n\t      break;\n\t  }\n\telse\n\t  {\n\t    /* Slide from the bottom.  */\n\t    dest->elems[id + delta] = dest->elems[id];\n\t    if (! REG_VALID_INDEX (--id))\n\t      break;\n\t  }\n      }\n\n  /* Copy remaining SRC elements.  */\n  memcpy (dest->elems, dest->elems + sbase, delta * sizeof (Idx));\n\n  return REG_NOERROR;\n}",
      "lines": 86,
      "depth": 14,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "re_node_set_init_union": {
      "start_point": [
        1139,
        18
      ],
      "end_point": [
        1186,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_node_set_init_union (re_node_set *dest, const re_node_set *src1,\n\t\t\tconst re_node_set *src2)\n{\n  Idx i1, i2, id;\n  if (src1 != NULL && src1->nelem > 0 && src2 != NULL && src2->nelem > 0)\n    {\n      dest->alloc = src1->nelem + src2->nelem;\n      dest->elems = re_malloc (Idx, dest->alloc);\n      if (BE (dest->elems == NULL, 0))\n\treturn REG_ESPACE;\n    }\n  else\n    {\n      if (src1 != NULL && src1->nelem > 0)\n\treturn re_node_set_init_copy (dest, src1);\n      else if (src2 != NULL && src2->nelem > 0)\n\treturn re_node_set_init_copy (dest, src2);\n      else\n\tre_node_set_init_empty (dest);\n      return REG_NOERROR;\n    }\n  for (i1 = i2 = id = 0 ; i1 < src1->nelem && i2 < src2->nelem ;)\n    {\n      if (src1->elems[i1] > src2->elems[i2])\n\t{\n\t  dest->elems[id++] = src2->elems[i2++];\n\t  continue;\n\t}\n      if (src1->elems[i1] == src2->elems[i2])\n\t++i2;\n      dest->elems[id++] = src1->elems[i1++];\n    }\n  if (i1 < src1->nelem)\n    {\n      memcpy (dest->elems + id, src1->elems + i1,\n\t     (src1->nelem - i1) * sizeof (Idx));\n      id += src1->nelem - i1;\n    }\n  else if (i2 < src2->nelem)\n    {\n      memcpy (dest->elems + id, src2->elems + i2,\n\t     (src2->nelem - i2) * sizeof (Idx));\n      id += src2->nelem - i2;\n    }\n  dest->nelem = id;\n  return REG_NOERROR;\n}",
      "lines": 48,
      "depth": 13,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "re_node_set_merge": {
      "start_point": [
        1192,
        18
      ],
      "end_point": [
        1269,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_node_set_merge (re_node_set *dest, const re_node_set *src)\n{\n  Idx is, id, sbase, delta;\n  if (src == NULL || src->nelem == 0)\n    return REG_NOERROR;\n  if (dest->alloc < 2 * src->nelem + dest->nelem)\n    {\n      Idx new_alloc = 2 * (src->nelem + dest->alloc);\n      Idx *new_buffer = re_realloc (dest->elems, Idx, new_alloc);\n      if (BE (new_buffer == NULL, 0))\n\treturn REG_ESPACE;\n      dest->elems = new_buffer;\n      dest->alloc = new_alloc;\n    }\n\n  if (BE (dest->nelem == 0, 0))\n    {\n      dest->nelem = src->nelem;\n      memcpy (dest->elems, src->elems, src->nelem * sizeof (Idx));\n      return REG_NOERROR;\n    }\n\n  /* Copy into the top of DEST the items of SRC that are not\n     found in DEST.  Maybe we could binary search in DEST?  */\n  for (sbase = dest->nelem + 2 * src->nelem,\n       is = src->nelem - 1, id = dest->nelem - 1;\n       REG_VALID_INDEX (is) && REG_VALID_INDEX (id); )\n    {\n      if (dest->elems[id] == src->elems[is])\n\tis--, id--;\n      else if (dest->elems[id] < src->elems[is])\n\tdest->elems[--sbase] = src->elems[is--];\n      else /* if (dest->elems[id] > src->elems[is]) */\n\t--id;\n    }\n\n  if (REG_VALID_INDEX (is))\n    {\n      /* If DEST is exhausted, the remaining items of SRC must be unique.  */\n      sbase -= is + 1;\n      memcpy (dest->elems + sbase, src->elems, (is + 1) * sizeof (Idx));\n    }\n\n  id = dest->nelem - 1;\n  is = dest->nelem + 2 * src->nelem - 1;\n  delta = is - sbase + 1;\n  if (delta == 0)\n    return REG_NOERROR;\n\n  /* Now copy.  When DELTA becomes zero, the remaining\n     DEST elements are already in place.  */\n  dest->nelem += delta;\n  for (;;)\n    {\n      if (dest->elems[is] > dest->elems[id])\n\t{\n\t  /* Copy from the top.  */\n\t  dest->elems[id + delta--] = dest->elems[is--];\n\t  if (delta == 0)\n\t    break;\n\t}\n      else\n\t{\n\t  /* Slide from the bottom.  */\n\t  dest->elems[id + delta] = dest->elems[id];\n\t  if (! REG_VALID_INDEX (--id))\n\t    {\n\t      /* Copy remaining SRC elements.  */\n\t      memcpy (dest->elems, dest->elems + sbase,\n\t\t      delta * sizeof (Idx));\n\t      break;\n\t    }\n\t}\n    }\n\n  return REG_NOERROR;\n}",
      "lines": 78,
      "depth": 15,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "re_node_set_insert": {
      "start_point": [
        1276,
        18
      ],
      "end_point": [
        1321,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_node_set_insert (re_node_set *set, Idx elem)\n{\n  Idx idx;\n  /* In case the set is empty.  */\n  if (set->alloc == 0)\n    return BE (re_node_set_init_1 (set, elem) == REG_NOERROR, 1);\n\n  if (BE (set->nelem, 0) == 0)\n    {\n      /* We already guaranteed above that set->alloc != 0.  */\n      set->elems[0] = elem;\n      ++set->nelem;\n      return true;\n    }\n\n  /* Realloc if we need.  */\n  if (set->alloc == set->nelem)\n    {\n      Idx *new_elems;\n      set->alloc = set->alloc * 2;\n      new_elems = re_realloc (set->elems, Idx, set->alloc);\n      if (BE (new_elems == NULL, 0))\n\treturn false;\n      set->elems = new_elems;\n    }\n\n  /* Move the elements which follows the new element.  Test the\n     first element separately to skip a check in the inner loop.  */\n  if (elem < set->elems[0])\n    {\n      idx = 0;\n      for (idx = set->nelem; idx > 0; idx--)\n\tset->elems[idx] = set->elems[idx - 1];\n    }\n  else\n    {\n      for (idx = set->nelem; set->elems[idx - 1] > elem; idx--)\n\tset->elems[idx] = set->elems[idx - 1];\n    }\n\n  /* Insert the new element.  */\n  set->elems[idx] = elem;\n  ++set->nelem;\n  return true;\n}",
      "lines": 46,
      "depth": 10,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "re_node_set_insert_last": {
      "start_point": [
        1328,
        18
      ],
      "end_point": [
        1345,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_node_set_insert_last (re_node_set *set, Idx elem)\n{\n  /* Realloc if we need.  */\n  if (set->alloc == set->nelem)\n    {\n      Idx *new_elems;\n      set->alloc = (set->alloc + 1) * 2;\n      new_elems = re_realloc (set->elems, Idx, set->alloc);\n      if (BE (new_elems == NULL, 0))\n\treturn false;\n      set->elems = new_elems;\n    }\n\n  /* Insert the new element.  */\n  set->elems[set->nelem++] = elem;\n  return true;\n}",
      "lines": 18,
      "depth": 11,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "pure": {
      "start_point": [
        1352,
        52
      ],
      "end_point": [
        1361,
        1
      ],
      "content": "re_node_set *set2)\n{\n  Idx i;\n  if (set1 == NULL || set2 == NULL || set1->nelem != set2->nelem)\n    return false;\n  for (i = set1->nelem ; REG_VALID_INDEX (--i) ; )\n    if (set1->elems[i] != set2->elems[i])\n      return false;\n  return true;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": null
    },
    "re_node_set_remove_at": {
      "start_point": [
        1387,
        0
      ],
      "end_point": [
        1396,
        1
      ],
      "content": "static void\ninternal_function\nre_node_set_remove_at (re_node_set *set, Idx idx)\n{\n  if (idx < 0 || idx >= set->nelem)\n    return;\n  --set->nelem;\n  for (; idx < set->nelem; idx++)\n    set->elems[idx] = set->elems[idx + 1];\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void",
        "internal_function",
        "internal_function"
      ]
    },
    "re_dfa_add_node": {
      "start_point": [
        1402,
        0
      ],
      "end_point": [
        1448,
        1
      ],
      "content": "static Idx\ninternal_function\nre_dfa_add_node (re_dfa_t *dfa, re_token_t token)\n{\n  if (BE (dfa->nodes_len >= dfa->nodes_alloc, 0))\n    {\n      size_t new_nodes_alloc = dfa->nodes_alloc * 2;\n      Idx *new_nexts, *new_indices;\n      re_node_set *new_edests, *new_eclosures;\n      re_token_t *new_nodes;\n\n      /* Avoid overflows in realloc.  */\n      const size_t max_object_size = MAX (sizeof (re_token_t),\n\t\t\t\t\t  MAX (sizeof (re_node_set),\n\t\t\t\t\t       sizeof (Idx)));\n      if (BE (MIN (IDX_MAX, SIZE_MAX / max_object_size) < new_nodes_alloc, 0))\n\treturn REG_MISSING;\n\n      new_nodes = re_realloc (dfa->nodes, re_token_t, new_nodes_alloc);\n      if (BE (new_nodes == NULL, 0))\n\treturn REG_MISSING;\n      dfa->nodes = new_nodes;\n      new_nexts = re_realloc (dfa->nexts, Idx, new_nodes_alloc);\n      new_indices = re_realloc (dfa->org_indices, Idx, new_nodes_alloc);\n      new_edests = re_realloc (dfa->edests, re_node_set, new_nodes_alloc);\n      new_eclosures = re_realloc (dfa->eclosures, re_node_set, new_nodes_alloc);\n      if (BE (new_nexts == NULL || new_indices == NULL\n\t      || new_edests == NULL || new_eclosures == NULL, 0))\n\treturn REG_MISSING;\n      dfa->nexts = new_nexts;\n      dfa->org_indices = new_indices;\n      dfa->edests = new_edests;\n      dfa->eclosures = new_eclosures;\n      dfa->nodes_alloc = new_nodes_alloc;\n    }\n  dfa->nodes[dfa->nodes_len] = token;\n  dfa->nodes[dfa->nodes_len].constraint = 0;\n#ifdef RE_ENABLE_I18N\n  dfa->nodes[dfa->nodes_len].accept_mb =\n    ((token.type == OP_PERIOD && dfa->mb_cur_max > 1)\n     || token.type == COMPLEX_BRACKET);\n#endif\n  dfa->nexts[dfa->nodes_len] = REG_MISSING;\n  re_node_set_init_empty (dfa->edests + dfa->nodes_len);\n  re_node_set_init_empty (dfa->eclosures + dfa->nodes_len);\n  return dfa->nodes_len++;\n}",
      "lines": 47,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "Idx",
        "internal_function",
        "internal_function"
      ]
    },
    "calc_state_hash": {
      "start_point": [
        1450,
        0
      ],
      "end_point": [
        1459,
        1
      ],
      "content": "static re_hashval_t\ninternal_function\ncalc_state_hash (const re_node_set *nodes, unsigned int context)\n{\n  re_hashval_t hash = nodes->nelem + context;\n  Idx i;\n  for (i = 0 ; i < nodes->nelem ; i++)\n    hash += nodes->elems[i];\n  return hash;\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "re_hashval_t",
        "internal_function",
        "internal_function"
      ]
    },
    "re_acquire_state": {
      "start_point": [
        1471,
        18
      ],
      "end_point": [
        1506,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_acquire_state (reg_errcode_t *err, const re_dfa_t *dfa,\n\t\t  const re_node_set *nodes)\n{\n  re_hashval_t hash;\n  re_dfastate_t *new_state;\n  struct re_state_table_entry *spot;\n  Idx i;\n#ifdef lint\n  /* Suppress bogus uninitialized-variable warnings.  */\n  *err = REG_NOERROR;\n#endif\n  if (BE (nodes->nelem == 0, 0))\n    {\n      *err = REG_NOERROR;\n      return NULL;\n    }\n  hash = calc_state_hash (nodes, 0);\n  spot = dfa->state_table + (hash & dfa->state_hash_mask);\n\n  for (i = 0 ; i < spot->num ; i++)\n    {\n      re_dfastate_t *state = spot->array[i];\n      if (hash != state->hash)\n\tcontinue;\n      if (re_node_set_compare (&state->nodes, nodes))\n\treturn state;\n    }\n\n  /* There are no appropriate state in the dfa, create the new one.  */\n  new_state = create_ci_newstate (dfa, nodes, hash);\n  if (BE (new_state == NULL, 0))\n    *err = REG_ESPACE;\n\n  return new_state;\n}",
      "lines": 36,
      "depth": 11,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "re_acquire_state_context": {
      "start_point": [
        1519,
        18
      ],
      "end_point": [
        1553,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_acquire_state_context (reg_errcode_t *err, const re_dfa_t *dfa,\n\t\t\t  const re_node_set *nodes, unsigned int context)\n{\n  re_hashval_t hash;\n  re_dfastate_t *new_state;\n  struct re_state_table_entry *spot;\n  Idx i;\n#ifdef lint\n  /* Suppress bogus uninitialized-variable warnings.  */\n  *err = REG_NOERROR;\n#endif\n  if (nodes->nelem == 0)\n    {\n      *err = REG_NOERROR;\n      return NULL;\n    }\n  hash = calc_state_hash (nodes, context);\n  spot = dfa->state_table + (hash & dfa->state_hash_mask);\n\n  for (i = 0 ; i < spot->num ; i++)\n    {\n      re_dfastate_t *state = spot->array[i];\n      if (state->hash == hash\n\t  && state->context == context\n\t  && re_node_set_compare (state->entrance_nodes, nodes))\n\treturn state;\n    }\n  /* There are no appropriate state in 'dfa', create the new one.  */\n  new_state = create_cd_newstate (dfa, nodes, context, hash);\n  if (BE (new_state == NULL, 0))\n    *err = REG_ESPACE;\n\n  return new_state;\n}",
      "lines": 35,
      "depth": 11,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "register_state": {
      "start_point": [
        1559,
        0
      ],
      "end_point": [
        1593,
        1
      ],
      "content": "static reg_errcode_t\n__attribute_warn_unused_result__\nregister_state (const re_dfa_t *dfa, re_dfastate_t *newstate,\n\t\tre_hashval_t hash)\n{\n  struct re_state_table_entry *spot;\n  reg_errcode_t err;\n  Idx i;\n\n  newstate->hash = hash;\n  err = re_node_set_alloc (&newstate->non_eps_nodes, newstate->nodes.nelem);\n  if (BE (err != REG_NOERROR, 0))\n    return REG_ESPACE;\n  for (i = 0; i < newstate->nodes.nelem; i++)\n    {\n      Idx elem = newstate->nodes.elems[i];\n      if (!IS_EPSILON_NODE (dfa->nodes[elem].type))\n\tif (! re_node_set_insert_last (&newstate->non_eps_nodes, elem))\n\t  return REG_ESPACE;\n    }\n\n  spot = dfa->state_table + (hash & dfa->state_hash_mask);\n  if (BE (spot->alloc <= spot->num, 0))\n    {\n      Idx new_alloc = 2 * spot->num + 2;\n      re_dfastate_t **new_array = re_realloc (spot->array, re_dfastate_t *,\n\t\t\t\t\t      new_alloc);\n      if (BE (new_array == NULL, 0))\n\treturn REG_ESPACE;\n      spot->array = new_array;\n      spot->alloc = new_alloc;\n    }\n  spot->array[spot->num++] = newstate;\n  return REG_NOERROR;\n}",
      "lines": 35,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "__attribute_warn_unused_result__",
        "__attribute_warn_unused_result__"
      ]
    },
    "free_state": {
      "start_point": [
        1595,
        0
      ],
      "end_point": [
        1609,
        1
      ],
      "content": "static void\nfree_state (re_dfastate_t *state)\n{\n  re_node_set_free (&state->non_eps_nodes);\n  re_node_set_free (&state->inveclosure);\n  if (state->entrance_nodes != &state->nodes)\n    {\n      re_node_set_free (state->entrance_nodes);\n      re_free (state->entrance_nodes);\n    }\n  re_node_set_free (&state->nodes);\n  re_free (state->word_trtable);\n  re_free (state->trtable);\n  re_free (state);\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "create_ci_newstate": {
      "start_point": [
        1615,
        18
      ],
      "end_point": [
        1659,
        1
      ],
      "content": "__attribute_warn_unused_result__\ncreate_ci_newstate (const re_dfa_t *dfa, const re_node_set *nodes,\n\t\t    re_hashval_t hash)\n{\n  Idx i;\n  reg_errcode_t err;\n  re_dfastate_t *newstate;\n\n  newstate = (re_dfastate_t *) calloc (sizeof (re_dfastate_t), 1);\n  if (BE (newstate == NULL, 0))\n    return NULL;\n  err = re_node_set_init_copy (&newstate->nodes, nodes);\n  if (BE (err != REG_NOERROR, 0))\n    {\n      re_free (newstate);\n      return NULL;\n    }\n\n  newstate->entrance_nodes = &newstate->nodes;\n  for (i = 0 ; i < nodes->nelem ; i++)\n    {\n      re_token_t *node = dfa->nodes + nodes->elems[i];\n      re_token_type_t type = node->type;\n      if (type == CHARACTER && !node->constraint)\n\tcontinue;\n#ifdef RE_ENABLE_I18N\n      newstate->accept_mb |= node->accept_mb;\n#endif /* RE_ENABLE_I18N */\n\n      /* If the state has the halt node, the state is a halt state.  */\n      if (type == END_OF_RE)\n\tnewstate->halt = 1;\n      else if (type == OP_BACK_REF)\n\tnewstate->has_backref = 1;\n      else if (type == ANCHOR || node->constraint)\n\tnewstate->has_constraint = 1;\n    }\n  err = register_state (dfa, newstate, hash);\n  if (BE (err != REG_NOERROR, 0))\n    {\n      free_state (newstate);\n      newstate = NULL;\n    }\n  return newstate;\n}",
      "lines": 45,
      "depth": 11,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "create_cd_newstate": {
      "start_point": [
        1665,
        18
      ],
      "end_point": [
        1735,
        1
      ],
      "content": "__attribute_warn_unused_result__\ncreate_cd_newstate (const re_dfa_t *dfa, const re_node_set *nodes,\n\t\t    unsigned int context, re_hashval_t hash)\n{\n  Idx i, nctx_nodes = 0;\n  reg_errcode_t err;\n  re_dfastate_t *newstate;\n\n  newstate = (re_dfastate_t *) calloc (sizeof (re_dfastate_t), 1);\n  if (BE (newstate == NULL, 0))\n    return NULL;\n  err = re_node_set_init_copy (&newstate->nodes, nodes);\n  if (BE (err != REG_NOERROR, 0))\n    {\n      re_free (newstate);\n      return NULL;\n    }\n\n  newstate->context = context;\n  newstate->entrance_nodes = &newstate->nodes;\n\n  for (i = 0 ; i < nodes->nelem ; i++)\n    {\n      re_token_t *node = dfa->nodes + nodes->elems[i];\n      re_token_type_t type = node->type;\n      unsigned int constraint = node->constraint;\n\n      if (type == CHARACTER && !constraint)\n\tcontinue;\n#ifdef RE_ENABLE_I18N\n      newstate->accept_mb |= node->accept_mb;\n#endif /* RE_ENABLE_I18N */\n\n      /* If the state has the halt node, the state is a halt state.  */\n      if (type == END_OF_RE)\n\tnewstate->halt = 1;\n      else if (type == OP_BACK_REF)\n\tnewstate->has_backref = 1;\n\n      if (constraint)\n\t{\n\t  if (newstate->entrance_nodes == &newstate->nodes)\n\t    {\n\t      newstate->entrance_nodes = re_malloc (re_node_set, 1);\n\t      if (BE (newstate->entrance_nodes == NULL, 0))\n\t\t{\n\t\t  free_state (newstate);\n\t\t  return NULL;\n\t\t}\n\t      if (re_node_set_init_copy (newstate->entrance_nodes, nodes)\n\t\t  != REG_NOERROR)\n\t\treturn NULL;\n\t      nctx_nodes = 0;\n\t      newstate->has_constraint = 1;\n\t    }\n\n\t  if (NOT_SATISFY_PREV_CONSTRAINT (constraint,context))\n\t    {\n\t      re_node_set_remove_at (&newstate->nodes, i - nctx_nodes);\n\t      ++nctx_nodes;\n\t    }\n\t}\n    }\n  err = register_state (dfa, newstate, hash);\n  if (BE (err != REG_NOERROR, 0))\n    {\n      free_state (newstate);\n      newstate = NULL;\n    }\n  return  newstate;\n}",
      "lines": 71,
      "depth": 15,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/regex_internal.h": {
    "bitset_set": {
      "start_point": [
        773,
        0
      ],
      "end_point": [
        777,
        1
      ],
      "content": "static void\nbitset_set (bitset_t set, Idx i)\n{\n  set[i / BITSET_WORD_BITS] |= (bitset_word_t) 1 << i % BITSET_WORD_BITS;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bitset_clear": {
      "start_point": [
        779,
        0
      ],
      "end_point": [
        783,
        1
      ],
      "content": "static void\nbitset_clear (bitset_t set, Idx i)\n{\n  set[i / BITSET_WORD_BITS] &= ~ ((bitset_word_t) 1 << i % BITSET_WORD_BITS);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bitset_contain": {
      "start_point": [
        785,
        0
      ],
      "end_point": [
        789,
        1
      ],
      "content": "static bool\nbitset_contain (const bitset_t set, Idx i)\n{\n  return (set[i / BITSET_WORD_BITS] >> i % BITSET_WORD_BITS) & 1;\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "bitset_empty": {
      "start_point": [
        791,
        0
      ],
      "end_point": [
        795,
        1
      ],
      "content": "static void\nbitset_empty (bitset_t set)\n{\n  memset (set, '\\0', sizeof (bitset_t));\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bitset_set_all": {
      "start_point": [
        797,
        0
      ],
      "end_point": [
        804,
        1
      ],
      "content": "static void\nbitset_set_all (bitset_t set)\n{\n  memset (set, -1, sizeof (bitset_word_t) * (SBC_MAX / BITSET_WORD_BITS));\n  if (SBC_MAX % BITSET_WORD_BITS != 0)\n    set[BITSET_WORDS - 1] =\n      ((bitset_word_t) 1 << SBC_MAX % BITSET_WORD_BITS) - 1;\n}",
      "lines": 8,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bitset_copy": {
      "start_point": [
        806,
        0
      ],
      "end_point": [
        810,
        1
      ],
      "content": "static void\nbitset_copy (bitset_t dest, const bitset_t src)\n{\n  memcpy (dest, src, sizeof (bitset_t));\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bitset_not": {
      "start_point": [
        812,
        0
      ],
      "end_point": [
        822,
        1
      ],
      "content": "static void __attribute__ ((unused))\nbitset_not (bitset_t set)\n{\n  int bitset_i;\n  for (bitset_i = 0; bitset_i < SBC_MAX / BITSET_WORD_BITS; ++bitset_i)\n    set[bitset_i] = ~set[bitset_i];\n  if (SBC_MAX % BITSET_WORD_BITS != 0)\n    set[BITSET_WORDS - 1] =\n      ((((bitset_word_t) 1 << SBC_MAX % BITSET_WORD_BITS) - 1)\n       & ~set[BITSET_WORDS - 1]);\n}",
      "lines": 11,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void",
        "__attribute__ ((unused))",
        "__attribute__",
        "(",
        "(unused)",
        "(",
        "unused",
        ")",
        ")"
      ]
    },
    "bitset_merge": {
      "start_point": [
        824,
        0
      ],
      "end_point": [
        830,
        1
      ],
      "content": "static void __attribute__ ((unused))\nbitset_merge (bitset_t dest, const bitset_t src)\n{\n  int bitset_i;\n  for (bitset_i = 0; bitset_i < BITSET_WORDS; ++bitset_i)\n    dest[bitset_i] |= src[bitset_i];\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void",
        "__attribute__ ((unused))",
        "__attribute__",
        "(",
        "(unused)",
        "(",
        "unused",
        ")",
        ")"
      ]
    },
    "bitset_mask": {
      "start_point": [
        832,
        0
      ],
      "end_point": [
        838,
        1
      ],
      "content": "static void __attribute__ ((unused))\nbitset_mask (bitset_t dest, const bitset_t src)\n{\n  int bitset_i;\n  for (bitset_i = 0; bitset_i < BITSET_WORDS; ++bitset_i)\n    dest[bitset_i] &= src[bitset_i];\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void",
        "__attribute__ ((unused))",
        "__attribute__",
        "(",
        "(unused)",
        "(",
        "unused",
        ")",
        ")"
      ]
    },
    "internal_function": [
      {
        "start_point": [
          843,
          18
        ],
        "end_point": [
          853,
          1
        ],
        "content": "__attribute__ ((pure, unused))\nre_string_char_size_at (const re_string_t *pstr, Idx idx)\n{\n  int byte_idx;\n  if (pstr->mb_cur_max == 1)\n    return 1;\n  for (byte_idx = 1; idx + byte_idx < pstr->valid_len; ++byte_idx)\n    if (pstr->wcs[idx + byte_idx] != WEOF)\n      break;\n  return byte_idx;\n}",
        "lines": 11,
        "depth": 9,
        "decorators": null
      },
      {
        "start_point": [
          856,
          18
        ],
        "end_point": [
          862,
          1
        ],
        "content": "__attribute__ ((pure, unused))\nre_string_wchar_at (const re_string_t *pstr, Idx idx)\n{\n  if (pstr->mb_cur_max == 1)\n    return (wint_t) pstr->mbs[idx];\n  return (wint_t) pstr->wcs[idx];\n}",
        "lines": 7,
        "depth": 8,
        "decorators": null
      },
      {
        "start_point": [
          869,
          18
        ],
        "end_point": [
          891,
          1
        ],
        "content": "__attribute__ ((pure, unused))\nre_string_elem_size_at (const re_string_t *pstr, Idx idx)\n{\n# ifdef _LIBC\n  const unsigned char *p, *extra;\n  const int32_t *table, *indirect;\n  uint_fast32_t nrules = _NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_NRULES);\n\n  if (nrules != 0)\n    {\n      table = (const int32_t *) _NL_CURRENT (LC_COLLATE, _NL_COLLATE_TABLEMB);\n      extra = (const unsigned char *)\n\t_NL_CURRENT (LC_COLLATE, _NL_COLLATE_EXTRAMB);\n      indirect = (const int32_t *) _NL_CURRENT (LC_COLLATE,\n\t\t\t\t\t\t_NL_COLLATE_INDIRECTMB);\n      p = pstr->mbs + idx;\n      findidx (table, indirect, extra, &p, pstr->len - idx);\n      return p - pstr->mbs - idx;\n    }\n  else\n# endif /* _LIBC */\n    return 1;\n}",
        "lines": 23,
        "depth": 11,
        "decorators": null
      }
    ]
  },
  "findutils/findutils-4.6.0/gl/lib/rewinddir.c": {
    "rewinddir": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "void\nrewinddir (DIR *dirp)\n{\n  /* Like in closedir().  */\n  if (dirp->current != INVALID_HANDLE_VALUE)\n    FindClose (dirp->current);\n\n  /* Like in opendir().  */\n  dirp->status = -1;\n  dirp->current = FindFirstFile (dirp->dir_name_mask, &dirp->entry);\n  if (dirp->current == INVALID_HANDLE_VALUE)\n    {\n      switch (GetLastError ())\n        {\n        case ERROR_FILE_NOT_FOUND:\n          dirp->status = -2;\n          break;\n        default:\n          /* Save the error code for the next readdir() call.  */\n          dirp->status = ENOENT;\n          break;\n        }\n    }\n}",
      "lines": 24,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/rmdir.c": {
    "rpl_rmdir": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "int\nrpl_rmdir (char const *dir)\n{\n  /* Work around cygwin 1.5.x bug where rmdir(\"dir/./\") succeeds.  */\n  size_t len = strlen (dir);\n  int result;\n  while (len && ISSLASH (dir[len - 1]))\n    len--;\n  if (len && dir[len - 1] == '.' && (1 == len || ISSLASH (dir[len - 2])))\n    {\n      errno = EINVAL;\n      return -1;\n    }\n  result = rmdir (dir);\n  /* Work around mingw bug, where rmdir(\"file/\") fails with EINVAL\n     instead of ENOTDIR.  We've already filtered out trailing ., the\n     only reason allowed by POSIX for EINVAL.  */\n  if (result == -1 && errno == EINVAL)\n    errno = ENOTDIR;\n  return result;\n}",
      "lines": 21,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/root-uid.h": {},
  "findutils/findutils-4.6.0/gl/lib/rpmatch.c": {
    "localized_pattern": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        84,
        1
      ],
      "content": "static const char *\nlocalized_pattern (const char *english_pattern, nl_item nl_index,\n                   bool posixly_correct)\n{\n  const char *translated_pattern;\n\n  /* We prefer to get the patterns from a PO file.  It would be possible to\n     always use nl_langinfo (YESEXPR) instead of _(\"^[yY]\"), and\n     nl_langinfo (NOEXPR) instead of _(\"^[nN]\"), if we could assume that the\n     system's locale support is good.  But this is not the case e.g. on Cygwin.\n     The localizations of gnulib.pot are of better quality in general.\n     Also, if we use locale info from non-free systems that don't have a\n     'localedef' command, we deprive the users of the freedom to localize\n     this pattern for their preferred language.\n     But some programs, such as 'cp', 'mv', 'rm', 'find', 'xargs', are\n     specified by POSIX to use nl_langinfo (YESEXPR).  We implement this\n     behaviour if POSIXLY_CORRECT is set, for the sake of these programs.  */\n\n  /* If the user wants strict POSIX compliance, use nl_langinfo.  */\n  if (posixly_correct)\n    {\n      translated_pattern = nl_langinfo (nl_index);\n      /* Check against a broken system return value.  */\n      if (translated_pattern != NULL && translated_pattern[0] != '\\0')\n        return translated_pattern;\n   }\n\n  /* Look in the gnulib message catalog.  */\n  translated_pattern = _(english_pattern);\n  if (translated_pattern == english_pattern)\n    {\n      /* The gnulib message catalog provides no translation.\n         Try the system's message catalog.  */\n      translated_pattern = nl_langinfo (nl_index);\n      /* Check against a broken system return value.  */\n      if (translated_pattern != NULL && translated_pattern[0] != '\\0')\n        return translated_pattern;\n      /* Fall back to English.  */\n      translated_pattern = english_pattern;\n    }\n  return translated_pattern;\n}",
      "lines": 42,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nlocalized_pattern (const char *english_pattern, nl_item nl_index,\n                   bool posixly_correct)",
        "*"
      ]
    },
    "try": {
      "start_point": [
        90,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "static int\ntry (const char *response, const char *pattern, char **lastp, regex_t *re)\n{\n  if (*lastp == NULL || strcmp (pattern, *lastp) != 0)\n    {\n      char *safe_pattern;\n\n      /* The pattern has changed.  */\n      if (*lastp != NULL)\n        {\n          /* Free the old compiled pattern.  */\n          regfree (re);\n          free (*lastp);\n          *lastp = NULL;\n        }\n      /* Put the PATTERN into safe memory before calling regcomp.\n         (regcomp may call nl_langinfo, overwriting PATTERN's storage.  */\n      safe_pattern = strdup (pattern);\n      if (safe_pattern == NULL)\n        return -1;\n      /* Compile the pattern and cache it for future runs.  */\n      if (regcomp (re, safe_pattern, REG_EXTENDED) != 0)\n        {\n          free (safe_pattern);\n          return -1;\n        }\n      *lastp = safe_pattern;\n    }\n\n  /* See if the regular expression matches RESPONSE.  */\n  return regexec (re, response, 0, NULL, 0) == 0;\n}",
      "lines": 32,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpmatch": {
      "start_point": [
        125,
        0
      ],
      "end_point": [
        175,
        1
      ],
      "content": "int\nrpmatch (const char *response)\n{\n#if ENABLE_NLS\n  /* Match against one of the response patterns, compiling the pattern\n     first if necessary.  */\n\n  /* We cache the response patterns and compiled regexps here.  */\n  static char *last_yesexpr, *last_noexpr;\n  static regex_t cached_yesre, cached_nore;\n\n# if HAVE_LANGINFO_YESEXPR\n  bool posixly_correct = (getenv (\"POSIXLY_CORRECT\") != NULL);\n# endif\n\n  const char *yesexpr, *noexpr;\n  int result;\n\n  /* TRANSLATORS: A regular expression testing for an affirmative answer\n     (english: \"yes\").  Testing the first character may be sufficient.\n     Take care to consider upper and lower case.\n     To enquire the regular expression that your system uses for this\n     purpose, you can use the command\n       locale -k LC_MESSAGES | grep '^yesexpr='  */\n  yesexpr = localized_pattern (N_(\"^[yY]\"), YESEXPR, posixly_correct);\n  result = try (response, yesexpr, &last_yesexpr, &cached_yesre);\n  if (result < 0)\n    return -1;\n  if (result)\n    return 1;\n\n  /* TRANSLATORS: A regular expression testing for a negative answer\n     (english: \"no\").  Testing the first character may be sufficient.\n     Take care to consider upper and lower case.\n     To enquire the regular expression that your system uses for this\n     purpose, you can use the command\n       locale -k LC_MESSAGES | grep '^noexpr='  */\n  noexpr = localized_pattern (N_(\"^[nN]\"), NOEXPR, posixly_correct);\n  result = try (response, noexpr, &last_noexpr, &cached_nore);\n  if (result < 0)\n    return -1;\n  if (result)\n    return 0;\n\n  return -1;\n#else\n  /* Test against \"^[yY]\" and \"^[nN]\", hardcoded to avoid requiring regex */\n  return (*response == 'y' || *response == 'Y' ? 1\n          : *response == 'n' || *response == 'N' ? 0 : -1);\n#endif\n}",
      "lines": 51,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/safe-read.c": {
    "safe_rw": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "size_t\nsafe_rw (int fd, void const *buf, size_t count)\n{\n  /* Work around a bug in Tru64 5.1.  Attempting to read more than\n     INT_MAX bytes fails with errno == EINVAL.  See\n     <http://lists.gnu.org/archive/html/bug-gnu-utils/2002-04/msg00010.html>.\n     When decreasing COUNT, keep it block-aligned.  */\n  enum { BUGGY_READ_MAXIMUM = INT_MAX & ~8191 };\n\n  for (;;)\n    {\n      ssize_t result = rw (fd, buf, count);\n\n      if (0 <= result)\n        return result;\n      else if (IS_EINTR (errno))\n        continue;\n      else if (errno == EINVAL && BUGGY_READ_MAXIMUM < count)\n        count = BUGGY_READ_MAXIMUM;\n      else\n        return result;\n    }\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "size_t"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/safe-read.h": {},
  "findutils/findutils-4.6.0/gl/lib/same-inode.h": {},
  "findutils/findutils-4.6.0/gl/lib/same.c": {
    "same_name": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        122,
        1
      ],
      "content": "bool\nsame_name (const char *source, const char *dest)\n{\n  /* Compare the basenames.  */\n  char const *source_basename = last_component (source);\n  char const *dest_basename = last_component (dest);\n  size_t source_baselen = base_len (source_basename);\n  size_t dest_baselen = base_len (dest_basename);\n  bool identical_basenames =\n    (source_baselen == dest_baselen\n     && memcmp (source_basename, dest_basename, dest_baselen) == 0);\n  bool compare_dirs = identical_basenames;\n  bool same = false;\n\n#if ! _POSIX_NO_TRUNC && HAVE_PATHCONF && defined _PC_NAME_MAX\n  /* This implementation silently truncates components of file names.  If\n     the base names might be truncated, check whether the truncated\n     base names are the same, while checking the directories.  */\n  size_t slen_max = HAVE_LONG_FILE_NAMES ? 255 : _POSIX_NAME_MAX;\n  size_t min_baselen = MIN (source_baselen, dest_baselen);\n  if (slen_max <= min_baselen\n      && memcmp (source_basename, dest_basename, slen_max) == 0)\n    compare_dirs = true;\n#endif\n\n  if (compare_dirs)\n    {\n      struct stat source_dir_stats;\n      struct stat dest_dir_stats;\n      char *source_dirname, *dest_dirname;\n\n      /* Compare the parent directories (via the device and inode numbers).  */\n      source_dirname = dir_name (source);\n      dest_dirname = dir_name (dest);\n\n      if (stat (source_dirname, &source_dir_stats))\n        {\n          /* Shouldn't happen.  */\n          error (1, errno, \"%s\", source_dirname);\n        }\n\n      if (stat (dest_dirname, &dest_dir_stats))\n        {\n          /* Shouldn't happen.  */\n          error (1, errno, \"%s\", dest_dirname);\n        }\n\n      same = SAME_INODE (source_dir_stats, dest_dir_stats);\n\n#if ! _POSIX_NO_TRUNC && HAVE_PATHCONF && defined _PC_NAME_MAX\n      if (same && ! identical_basenames)\n        {\n          long name_max = (errno = 0, pathconf (dest_dirname, _PC_NAME_MAX));\n          if (name_max < 0)\n            {\n              if (errno)\n                {\n                  /* Shouldn't happen.  */\n                  error (1, errno, \"%s\", dest_dirname);\n                }\n              same = false;\n            }\n          else\n            same = (name_max <= min_baselen\n                    && memcmp (source_basename, dest_basename, name_max) == 0);\n        }\n#endif\n\n      free (source_dirname);\n      free (dest_dirname);\n    }\n\n  return same;\n}",
      "lines": 74,
      "depth": 16,
      "decorators": [
        "bool"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/same.h": {},
  "findutils/findutils-4.6.0/gl/lib/save-cwd.c": {
    "save_cwd": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "int\nsave_cwd (struct saved_cwd *cwd)\n{\n  cwd->name = NULL;\n\n  cwd->desc = open (\".\", O_SEARCH);\n  if (!GNULIB_FCNTL_SAFER)\n    cwd->desc = fd_safer (cwd->desc);\n  if (cwd->desc < 0)\n    {\n      cwd->name = getcwd (NULL, 0);\n      return cwd->name ? 0 : -1;\n    }\n\n  set_cloexec_flag (cwd->desc, true);\n  return 0;\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "restore_cwd": {
      "start_point": [
        83,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "int\nrestore_cwd (const struct saved_cwd *cwd)\n{\n  if (0 <= cwd->desc)\n    return fchdir (cwd->desc);\n  else\n    return chdir_long (cwd->name);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "free_cwd": {
      "start_point": [
        92,
        0
      ],
      "end_point": [
        98,
        1
      ],
      "content": "void\nfree_cwd (struct saved_cwd *cwd)\n{\n  if (cwd->desc >= 0)\n    close (cwd->desc);\n  free (cwd->name);\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/save-cwd.h": {},
  "findutils/findutils-4.6.0/gl/lib/savedir.c": {
    "direntry_cmp_name": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "static int\ndirentry_cmp_name (void const *a, void const *b)\n{\n  direntry_t const *dea = a;\n  direntry_t const *deb = b;\n\n  return strcmp (dea->name, deb->name);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "direntry_cmp_inode": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "static int\ndirentry_cmp_inode (void const *a, void const *b)\n{\n  direntry_t const *dea = a;\n  direntry_t const *deb = b;\n\n  return dea->ino < deb->ino ? -1 : dea->ino > deb->ino;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "streamsavedir": {
      "start_point": [
        89,
        0
      ],
      "end_point": [
        180,
        1
      ],
      "content": "char *\nstreamsavedir (DIR *dirp, enum savedir_option option)\n{\n  char *name_space = NULL;\n  size_t allocated = 0;\n  direntry_t *entries = NULL;\n  size_t entries_allocated = 0;\n  size_t entries_used = 0;\n  size_t used = 0;\n  int readdir_errno;\n  comparison_function cmp = comparison_function_table[option];\n\n  if (dirp == NULL)\n    return NULL;\n\n  for (;;)\n    {\n      struct dirent const *dp;\n      char const *entry;\n\n      errno = 0;\n      dp = readdir (dirp);\n      if (! dp)\n        break;\n\n      /* Skip \"\", \".\", and \"..\".  \"\" is returned by at least one buggy\n         implementation: Solaris 2.4 readdir on NFS file systems.  */\n      entry = dp->d_name;\n      if (entry[entry[0] != '.' ? 0 : entry[1] != '.' ? 1 : 2] != '\\0')\n        {\n          size_t entry_size = _D_EXACT_NAMLEN (dp) + 1;\n          if (cmp)\n            {\n              if (entries_allocated == entries_used)\n                {\n                  size_t n = entries_allocated;\n                  entries = x2nrealloc (entries, &n, sizeof *entries);\n                  entries_allocated = n;\n                }\n              entries[entries_used].name = xstrdup (entry);\n#if D_INO_IN_DIRENT\n              entries[entries_used].ino = dp->d_ino;\n#endif\n              entries_used++;\n            }\n          else\n            {\n              if (allocated - used <= entry_size)\n                {\n                  size_t n = used + entry_size;\n                  if (n < used)\n                    xalloc_die ();\n                  name_space = x2nrealloc (name_space, &n, 1);\n                  allocated = n;\n                }\n              memcpy (name_space + used, entry, entry_size);\n            }\n          used += entry_size;\n        }\n    }\n\n  readdir_errno = errno;\n  if (readdir_errno != 0)\n    {\n      free (entries);\n      free (name_space);\n      errno = readdir_errno;\n      return NULL;\n    }\n\n  if (cmp)\n    {\n      size_t i;\n\n      if (entries_used)\n        qsort (entries, entries_used, sizeof *entries, cmp);\n      name_space = xmalloc (used + 1);\n      used = 0;\n      for (i = 0; i < entries_used; i++)\n        {\n          char *dest = name_space + used;\n          used += stpcpy (dest, entries[i].name) - dest + 1;\n          free (entries[i].name);\n        }\n      free (entries);\n    }\n  else if (used == allocated)\n    name_space = xrealloc (name_space, used + 1);\n\n  name_space[used] = '\\0';\n  return name_space;\n}",
      "lines": 92,
      "depth": 17,
      "decorators": [
        "char",
        "*\nstreamsavedir (DIR *dirp, enum savedir_option option)",
        "*"
      ]
    },
    "savedir": {
      "start_point": [
        187,
        0
      ],
      "end_point": [
        205,
        1
      ],
      "content": "char *\nsavedir (char const *dir, enum savedir_option option)\n{\n  DIR *dirp = opendir (dir);\n  if (! dirp)\n    return NULL;\n  else\n    {\n      char *name_space = streamsavedir (dirp, option);\n      if (closedir (dirp) != 0)\n        {\n          int closedir_errno = errno;\n          free (name_space);\n          errno = closedir_errno;\n          return NULL;\n        }\n      return name_space;\n    }\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "char",
        "*\nsavedir (char const *dir, enum savedir_option option)",
        "*"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/savedir.h": {},
  "findutils/findutils-4.6.0/gl/lib/se-context.c": {},
  "findutils/findutils-4.6.0/gl/lib/se-context.in.h": {
    "context_new": {
      "start_point": [
        16,
        0
      ],
      "end_point": [
        17,
        32
      ],
      "content": "SE_CONTEXT_INLINE context_t context_new (char const *s _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return 0; }",
      "lines": 2,
      "depth": 7,
      "decorators": [
        "SE_CONTEXT_INLINE",
        "context_t",
        "context_t"
      ]
    },
    "context_str": {
      "start_point": [
        18,
        0
      ],
      "end_point": [
        19,
        41
      ],
      "content": "SE_CONTEXT_INLINE char *context_str (context_t con _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return (void *) 0; }",
      "lines": 2,
      "depth": 7,
      "decorators": [
        "SE_CONTEXT_INLINE",
        "char",
        "char",
        "*context_str (context_t con _GL_UNUSED_PARAMETER)",
        "*"
      ]
    },
    "context_free": {
      "start_point": [
        20,
        0
      ],
      "end_point": [
        20,
        73
      ],
      "content": "SE_CONTEXT_INLINE void context_free (context_t c _GL_UNUSED_PARAMETER) {}",
      "lines": 1,
      "depth": 6,
      "decorators": [
        "SE_CONTEXT_INLINE",
        "void",
        "void"
      ]
    },
    "context_user_set": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        24,
        33
      ],
      "content": "SE_CONTEXT_INLINE int context_user_set (context_t sc _GL_UNUSED_PARAMETER,\n                                        char const *s _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return -1; }",
      "lines": 3,
      "depth": 7,
      "decorators": [
        "SE_CONTEXT_INLINE",
        "int",
        "int"
      ]
    },
    "context_role_set": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        27,
        33
      ],
      "content": "SE_CONTEXT_INLINE int context_role_set (context_t sc _GL_UNUSED_PARAMETER,\n                                        char const *s _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return -1; }",
      "lines": 3,
      "depth": 7,
      "decorators": [
        "SE_CONTEXT_INLINE",
        "int",
        "int"
      ]
    },
    "context_range_set": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        30,
        33
      ],
      "content": "SE_CONTEXT_INLINE int context_range_set (context_t sc _GL_UNUSED_PARAMETER,\n                                         char const *s _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return -1; }",
      "lines": 3,
      "depth": 7,
      "decorators": [
        "SE_CONTEXT_INLINE",
        "int",
        "int"
      ]
    },
    "context_type_set": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        33,
        33
      ],
      "content": "SE_CONTEXT_INLINE int context_type_set (context_t sc _GL_UNUSED_PARAMETER,\n                                        char const *s _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return -1; }",
      "lines": 3,
      "depth": 7,
      "decorators": [
        "SE_CONTEXT_INLINE",
        "int",
        "int"
      ]
    },
    "context_type_get": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        35,
        41
      ],
      "content": "SE_CONTEXT_INLINE char *context_type_get (context_t sc _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return (void *) 0; }",
      "lines": 2,
      "depth": 7,
      "decorators": [
        "SE_CONTEXT_INLINE",
        "char",
        "char",
        "*context_type_get (context_t sc _GL_UNUSED_PARAMETER)",
        "*"
      ]
    },
    "context_range_get": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        37,
        41
      ],
      "content": "SE_CONTEXT_INLINE char *context_range_get (context_t sc _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return (void *) 0; }",
      "lines": 2,
      "depth": 7,
      "decorators": [
        "SE_CONTEXT_INLINE",
        "char",
        "char",
        "*context_range_get (context_t sc _GL_UNUSED_PARAMETER)",
        "*"
      ]
    },
    "context_role_get": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        39,
        41
      ],
      "content": "SE_CONTEXT_INLINE char *context_role_get (context_t sc _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return (void *) 0; }",
      "lines": 2,
      "depth": 7,
      "decorators": [
        "SE_CONTEXT_INLINE",
        "char",
        "char",
        "*context_role_get (context_t sc _GL_UNUSED_PARAMETER)",
        "*"
      ]
    },
    "context_user_get": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        41,
        41
      ],
      "content": "SE_CONTEXT_INLINE char *context_user_get (context_t sc _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return (void *) 0; }",
      "lines": 2,
      "depth": 7,
      "decorators": [
        "SE_CONTEXT_INLINE",
        "char",
        "char",
        "*context_user_get (context_t sc _GL_UNUSED_PARAMETER)",
        "*"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/se-selinux.c": {},
  "findutils/findutils-4.6.0/gl/lib/se-selinux.in.h": {
    "getcon": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        51,
        33
      ],
      "content": "SE_SELINUX_INLINE int\ngetcon (security_context_t *con _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return -1; }",
      "lines": 3,
      "depth": 7,
      "decorators": [
        "SE_SELINUX_INLINE",
        "int",
        "int"
      ]
    },
    "freecon": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        53,
        56
      ],
      "content": "SE_SELINUX_INLINE void\nfreecon (security_context_t con _GL_UNUSED_PARAMETER) {}",
      "lines": 2,
      "depth": 6,
      "decorators": [
        "SE_SELINUX_INLINE",
        "void",
        "void"
      ]
    },
    "getfscreatecon": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        57,
        33
      ],
      "content": "SE_SELINUX_INLINE int\ngetfscreatecon (security_context_t *con _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return -1; }",
      "lines": 3,
      "depth": 7,
      "decorators": [
        "SE_SELINUX_INLINE",
        "int",
        "int"
      ]
    },
    "setfscreatecon": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        60,
        33
      ],
      "content": "SE_SELINUX_INLINE int\nsetfscreatecon (security_context_t con _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return -1; }",
      "lines": 3,
      "depth": 6,
      "decorators": [
        "SE_SELINUX_INLINE",
        "int",
        "int"
      ]
    },
    "matchpathcon": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        65,
        33
      ],
      "content": "SE_SELINUX_INLINE int\nmatchpathcon (char const *file _GL_UNUSED_PARAMETER,\n              mode_t m _GL_UNUSED_PARAMETER,\n  security_context_t *con _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return -1; }",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "SE_SELINUX_INLINE",
        "int",
        "int"
      ]
    },
    "getfilecon": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        69,
        33
      ],
      "content": "SE_SELINUX_INLINE int\ngetfilecon (char const *file _GL_UNUSED_PARAMETER,\n            security_context_t *con _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return -1; }",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "SE_SELINUX_INLINE",
        "int",
        "int"
      ]
    },
    "lgetfilecon": {
      "start_point": [
        70,
        0
      ],
      "end_point": [
        73,
        33
      ],
      "content": "SE_SELINUX_INLINE int\nlgetfilecon (char const *file _GL_UNUSED_PARAMETER,\n             security_context_t *con _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return -1; }",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "SE_SELINUX_INLINE",
        "int",
        "int"
      ]
    },
    "fgetfilecon": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        76,
        33
      ],
      "content": "SE_SELINUX_INLINE int\nfgetfilecon (int fd, security_context_t *con _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return -1; }",
      "lines": 3,
      "depth": 7,
      "decorators": [
        "SE_SELINUX_INLINE",
        "int",
        "int"
      ]
    },
    "setfilecon": {
      "start_point": [
        77,
        0
      ],
      "end_point": [
        80,
        33
      ],
      "content": "SE_SELINUX_INLINE int\nsetfilecon (char const *file _GL_UNUSED_PARAMETER,\n            security_context_t con _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return -1; }",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "SE_SELINUX_INLINE",
        "int",
        "int"
      ]
    },
    "lsetfilecon": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        84,
        33
      ],
      "content": "SE_SELINUX_INLINE int\nlsetfilecon (char const *file _GL_UNUSED_PARAMETER,\n             security_context_t con _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return -1; }",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "SE_SELINUX_INLINE",
        "int",
        "int"
      ]
    },
    "fsetfilecon": {
      "start_point": [
        85,
        0
      ],
      "end_point": [
        88,
        33
      ],
      "content": "SE_SELINUX_INLINE int\nfsetfilecon (int fd _GL_UNUSED_PARAMETER,\n             security_context_t con _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return -1; }",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "SE_SELINUX_INLINE",
        "int",
        "int"
      ]
    },
    "security_check_context": {
      "start_point": [
        90,
        0
      ],
      "end_point": [
        92,
        33
      ],
      "content": "SE_SELINUX_INLINE int\nsecurity_check_context (security_context_t con _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return -1; }",
      "lines": 3,
      "depth": 6,
      "decorators": [
        "SE_SELINUX_INLINE",
        "int",
        "int"
      ]
    },
    "security_check_context_raw": {
      "start_point": [
        93,
        0
      ],
      "end_point": [
        95,
        33
      ],
      "content": "SE_SELINUX_INLINE int\nsecurity_check_context_raw (security_context_t con _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return -1; }",
      "lines": 3,
      "depth": 6,
      "decorators": [
        "SE_SELINUX_INLINE",
        "int",
        "int"
      ]
    },
    "setexeccon": {
      "start_point": [
        96,
        0
      ],
      "end_point": [
        98,
        33
      ],
      "content": "SE_SELINUX_INLINE int\nsetexeccon (security_context_t con _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return -1; }",
      "lines": 3,
      "depth": 6,
      "decorators": [
        "SE_SELINUX_INLINE",
        "int",
        "int"
      ]
    },
    "security_compute_create": {
      "start_point": [
        99,
        0
      ],
      "end_point": [
        104,
        33
      ],
      "content": "SE_SELINUX_INLINE int\nsecurity_compute_create (security_context_t scon _GL_UNUSED_PARAMETER,\n                         security_context_t tcon _GL_UNUSED_PARAMETER,\n                         security_class_t tclass _GL_UNUSED_PARAMETER,\n                         security_context_t *newcon _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return -1; }",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "SE_SELINUX_INLINE",
        "int",
        "int"
      ]
    },
    "string_to_security_class": {
      "start_point": [
        105,
        0
      ],
      "end_point": [
        107,
        32
      ],
      "content": "SE_SELINUX_INLINE security_class_t\nstring_to_security_class (char const *name)\n  { errno = ENOTSUP; return 0; }",
      "lines": 3,
      "depth": 6,
      "decorators": [
        "SE_SELINUX_INLINE",
        "security_class_t",
        "security_class_t"
      ]
    },
    "matchpathcon_init_prefix": {
      "start_point": [
        108,
        0
      ],
      "end_point": [
        111,
        33
      ],
      "content": "SE_SELINUX_INLINE int\nmatchpathcon_init_prefix (char const *path _GL_UNUSED_PARAMETER,\n                          char const *prefix _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return -1; }",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "SE_SELINUX_INLINE",
        "int",
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/selinux-at.c": {},
  "findutils/findutils-4.6.0/gl/lib/selinux-at.h": {},
  "findutils/findutils-4.6.0/gl/lib/setenv.c": {
    "__add_to_environ": {
      "start_point": [
        111,
        0
      ],
      "end_point": [
        287,
        1
      ],
      "content": "int\n__add_to_environ (const char *name, const char *value, const char *combined,\n                  int replace)\n{\n  char **ep;\n  size_t size;\n  const size_t namelen = strlen (name);\n  const size_t vallen = value != NULL ? strlen (value) + 1 : 0;\n\n  LOCK;\n\n  /* We have to get the pointer now that we have the lock and not earlier\n     since another thread might have created a new environment.  */\n  ep = __environ;\n\n  size = 0;\n  if (ep != NULL)\n    {\n      for (; *ep != NULL; ++ep)\n        if (!strncmp (*ep, name, namelen) && (*ep)[namelen] == '=')\n          break;\n        else\n          ++size;\n    }\n\n  if (ep == NULL || *ep == NULL)\n    {\n      char **new_environ;\n#ifdef USE_TSEARCH\n      char *new_value;\n#endif\n\n      /* We allocated this space; we can extend it.  */\n      new_environ =\n        (char **) (last_environ == NULL\n                   ? malloc ((size + 2) * sizeof (char *))\n                   : realloc (last_environ, (size + 2) * sizeof (char *)));\n      if (new_environ == NULL)\n        {\n          /* It's easier to set errno to ENOMEM than to rely on the\n             'malloc-posix' and 'realloc-posix' gnulib modules.  */\n          __set_errno (ENOMEM);\n          UNLOCK;\n          return -1;\n        }\n\n      /* If the whole entry is given add it.  */\n      if (combined != NULL)\n        /* We must not add the string to the search tree since it belongs\n           to the user.  */\n        new_environ[size] = (char *) combined;\n      else\n        {\n          /* See whether the value is already known.  */\n#ifdef USE_TSEARCH\n# ifdef _LIBC\n          new_value = (char *) alloca (namelen + 1 + vallen);\n          __mempcpy (__mempcpy (__mempcpy (new_value, name, namelen), \"=\", 1),\n                     value, vallen);\n# else\n          new_value = (char *) malloca (namelen + 1 + vallen);\n          if (new_value == NULL)\n            {\n              __set_errno (ENOMEM);\n              UNLOCK;\n              return -1;\n            }\n          memcpy (new_value, name, namelen);\n          new_value[namelen] = '=';\n          memcpy (&new_value[namelen + 1], value, vallen);\n# endif\n\n          new_environ[size] = KNOWN_VALUE (new_value);\n          if (new_environ[size] == NULL)\n#endif\n            {\n              new_environ[size] = (char *) malloc (namelen + 1 + vallen);\n              if (new_environ[size] == NULL)\n                {\n#if defined USE_TSEARCH && !defined _LIBC\n                  freea (new_value);\n#endif\n                  __set_errno (ENOMEM);\n                  UNLOCK;\n                  return -1;\n                }\n\n#ifdef USE_TSEARCH\n              memcpy (new_environ[size], new_value, namelen + 1 + vallen);\n#else\n              memcpy (new_environ[size], name, namelen);\n              new_environ[size][namelen] = '=';\n              memcpy (&new_environ[size][namelen + 1], value, vallen);\n#endif\n              /* And save the value now.  We cannot do this when we remove\n                 the string since then we cannot decide whether it is a\n                 user string or not.  */\n              STORE_VALUE (new_environ[size]);\n            }\n#if defined USE_TSEARCH && !defined _LIBC\n          freea (new_value);\n#endif\n        }\n\n      if (__environ != last_environ)\n        memcpy ((char *) new_environ, (char *) __environ,\n                size * sizeof (char *));\n\n      new_environ[size + 1] = NULL;\n\n      last_environ = __environ = new_environ;\n    }\n  else if (replace)\n    {\n      char *np;\n\n      /* Use the user string if given.  */\n      if (combined != NULL)\n        np = (char *) combined;\n      else\n        {\n#ifdef USE_TSEARCH\n          char *new_value;\n# ifdef _LIBC\n          new_value = alloca (namelen + 1 + vallen);\n          __mempcpy (__mempcpy (__mempcpy (new_value, name, namelen), \"=\", 1),\n                     value, vallen);\n# else\n          new_value = malloca (namelen + 1 + vallen);\n          if (new_value == NULL)\n            {\n              __set_errno (ENOMEM);\n              UNLOCK;\n              return -1;\n            }\n          memcpy (new_value, name, namelen);\n          new_value[namelen] = '=';\n          memcpy (&new_value[namelen + 1], value, vallen);\n# endif\n\n          np = KNOWN_VALUE (new_value);\n          if (np == NULL)\n#endif\n            {\n              np = (char *) malloc (namelen + 1 + vallen);\n              if (np == NULL)\n                {\n#if defined USE_TSEARCH && !defined _LIBC\n                  freea (new_value);\n#endif\n                  __set_errno (ENOMEM);\n                  UNLOCK;\n                  return -1;\n                }\n\n#ifdef USE_TSEARCH\n              memcpy (np, new_value, namelen + 1 + vallen);\n#else\n              memcpy (np, name, namelen);\n              np[namelen] = '=';\n              memcpy (&np[namelen + 1], value, vallen);\n#endif\n              /* And remember the value.  */\n              STORE_VALUE (np);\n            }\n#if defined USE_TSEARCH && !defined _LIBC\n          freea (new_value);\n#endif\n        }\n\n      *ep = np;\n    }\n\n  UNLOCK;\n\n  return 0;\n}",
      "lines": 177,
      "depth": 17,
      "decorators": [
        "int"
      ]
    },
    "setenv": {
      "start_point": [
        289,
        0
      ],
      "end_point": [
        299,
        1
      ],
      "content": "int\nsetenv (const char *name, const char *value, int replace)\n{\n  if (name == NULL || *name == '\\0' || strchr (name, '=') != NULL)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  return __add_to_environ (name, value, NULL, replace);\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "clearenv": {
      "start_point": [
        304,
        0
      ],
      "end_point": [
        322,
        1
      ],
      "content": "int\nclearenv (void)\n{\n  LOCK;\n\n  if (__environ == last_environ && __environ != NULL)\n    {\n      /* We allocated this environment so we can free it.  */\n      free (__environ);\n      last_environ = NULL;\n    }\n\n  /* Clear the environment pointer removes the whole environment.  */\n  __environ = NULL;\n\n  UNLOCK;\n\n  return 0;\n}",
      "lines": 19,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "free_mem": {
      "start_point": [
        325,
        0
      ],
      "end_point": [
        334,
        1
      ],
      "content": "static void\nfree_mem (void)\n{\n  /* Remove all traces.  */\n  clearenv ();\n\n  /* Now remove the search tree.  */\n  __tdestroy (known_values, free);\n  known_values = NULL;\n}",
      "lines": 10,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "rpl_setenv": {
      "start_point": [
        357,
        0
      ],
      "end_point": [
        387,
        1
      ],
      "content": "int\nrpl_setenv (const char *name, const char *value, int replace)\n{\n  int result;\n  if (!name || !*name || strchr (name, '='))\n    {\n      errno = EINVAL;\n      return -1;\n    }\n  /* Call the real setenv even if replace is 0, in case implementation\n     has underlying data to update, such as when environ changes.  */\n  result = setenv (name, value, replace);\n  if (result == 0 && replace && *value == '=')\n    {\n      char *tmp = getenv (name);\n      if (!STREQ (tmp, value))\n        {\n          int saved_errno;\n          size_t len = strlen (value);\n          tmp = malloca (len + 2);\n          /* Since leading '=' is eaten, double it up.  */\n          *tmp = '=';\n          memcpy (tmp + 1, value, len + 1);\n          result = setenv (name, tmp, replace);\n          saved_errno = errno;\n          freea (tmp);\n          errno = saved_errno;\n        }\n    }\n  return result;\n}",
      "lines": 31,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/size_max.h": {},
  "findutils/findutils-4.6.0/gl/lib/snprintf.c": {
    "snprintf": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "int\nsnprintf (char *str, size_t size, const char *format, ...)\n{\n  char *output;\n  size_t len;\n  size_t lenbuf = size;\n  va_list args;\n\n  va_start (args, format);\n  output = vasnprintf (str, &lenbuf, format, args);\n  len = lenbuf;\n  va_end (args);\n\n  if (!output)\n    return -1;\n\n  if (output != str)\n    {\n      if (size)\n        {\n          size_t pruned_len = (len < size ? len : size - 1);\n          memcpy (str, output, pruned_len);\n          str[pruned_len] = '\\0';\n        }\n\n      free (output);\n    }\n\n  if (INT_MAX < len)\n    {\n      errno = EOVERFLOW;\n      return -1;\n    }\n\n  return len;\n}",
      "lines": 36,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/sockets.c": {
    "close_fd_maybe_socket": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "static int\nclose_fd_maybe_socket (const struct fd_hook *remaining_list,\n                       gl_close_fn primary,\n                       int fd)\n{\n  /* Note about multithread-safety: There is a race condition where, between\n     our calls to closesocket() and the primary close(), some other thread\n     could make system calls that allocate precisely the same HANDLE value\n     as sock; then the primary close() would call CloseHandle() on it.  */\n  SOCKET sock;\n  WSANETWORKEVENTS ev;\n\n  /* Test whether fd refers to a socket.  */\n  sock = FD_TO_SOCKET (fd);\n  ev.lNetworkEvents = 0xDEADBEEF;\n  WSAEnumNetworkEvents (sock, NULL, &ev);\n  if (ev.lNetworkEvents != 0xDEADBEEF)\n    {\n      /* fd refers to a socket.  */\n      /* FIXME: other applications, like squid, use an undocumented\n         _free_osfhnd free function.  But this is not enough: The 'osfile'\n         flags for fd also needs to be cleared, but it is hard to access it.\n         Instead, here we just close twice the file descriptor.  */\n      if (closesocket (sock))\n        {\n          set_winsock_errno ();\n          return -1;\n        }\n      else\n        {\n          /* This call frees the file descriptor and does a\n             CloseHandle ((HANDLE) _get_osfhandle (fd)), which fails.  */\n          _close (fd);\n          return 0;\n        }\n    }\n  else\n    /* Some other type of file descriptor.  */\n    return execute_close_hooks (remaining_list, primary, fd);\n}",
      "lines": 40,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "ioctl_fd_maybe_socket": {
      "start_point": [
        76,
        0
      ],
      "end_point": [
        102,
        1
      ],
      "content": "static int\nioctl_fd_maybe_socket (const struct fd_hook *remaining_list,\n                       gl_ioctl_fn primary,\n                       int fd, int request, void *arg)\n{\n  SOCKET sock;\n  WSANETWORKEVENTS ev;\n\n  /* Test whether fd refers to a socket.  */\n  sock = FD_TO_SOCKET (fd);\n  ev.lNetworkEvents = 0xDEADBEEF;\n  WSAEnumNetworkEvents (sock, NULL, &ev);\n  if (ev.lNetworkEvents != 0xDEADBEEF)\n    {\n      /* fd refers to a socket.  */\n      if (ioctlsocket (sock, request, arg) < 0)\n        {\n          set_winsock_errno ();\n          return -1;\n        }\n      else\n        return 0;\n    }\n  else\n    /* Some other type of file descriptor.  */\n    return execute_ioctl_hooks (remaining_list, primary, fd, request, arg);\n}",
      "lines": 27,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "gl_sockets_startup": {
      "start_point": [
        110,
        0
      ],
      "end_point": [
        138,
        1
      ],
      "content": "int\ngl_sockets_startup (int version _GL_UNUSED)\n{\n#if WINDOWS_SOCKETS\n  if (version > initialized_sockets_version)\n    {\n      WSADATA data;\n      int err;\n\n      err = WSAStartup (version, &data);\n      if (err != 0)\n        return 1;\n\n      if (data.wVersion != version)\n        {\n          WSACleanup ();\n          return 2;\n        }\n\n      if (initialized_sockets_version == 0)\n        register_fd_hook (close_fd_maybe_socket, ioctl_fd_maybe_socket,\n                          &fd_sockets_hook);\n\n      initialized_sockets_version = version;\n    }\n#endif\n\n  return 0;\n}",
      "lines": 29,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "gl_sockets_cleanup": {
      "start_point": [
        140,
        0
      ],
      "end_point": [
        156,
        1
      ],
      "content": "int\ngl_sockets_cleanup (void)\n{\n#if WINDOWS_SOCKETS\n  int err;\n\n  initialized_sockets_version = 0;\n\n  unregister_fd_hook (&fd_sockets_hook);\n\n  err = WSACleanup ();\n  if (err != 0)\n    return 1;\n#endif\n\n  return 0;\n}",
      "lines": 17,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/sockets.h": {
    "gl_fd_to_handle": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "static inline SOCKET\ngl_fd_to_handle (int fd)\n{\n  return _get_osfhandle (fd);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "SOCKET"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/stat-macros.h": {},
  "findutils/findutils-4.6.0/gl/lib/stat-size.h": {},
  "findutils/findutils-4.6.0/gl/lib/stat-time.c": {},
  "findutils/findutils-4.6.0/gl/lib/stat-time.h": {
    "get_stat_atime_ns": {
      "start_point": [
        56,
        26
      ],
      "end_point": [
        66,
        1
      ],
      "content": "int _GL_ATTRIBUTE_PURE\nget_stat_atime_ns (struct stat const *st)\n{\n# if defined STAT_TIMESPEC\n  return STAT_TIMESPEC (st, st_atim).tv_nsec;\n# elif defined STAT_TIMESPEC_NS\n  return STAT_TIMESPEC_NS (st, st_atim);\n# else\n  return 0;\n# endif\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "int",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "get_stat_ctime_ns": {
      "start_point": [
        69,
        26
      ],
      "end_point": [
        79,
        1
      ],
      "content": "int _GL_ATTRIBUTE_PURE\nget_stat_ctime_ns (struct stat const *st)\n{\n# if defined STAT_TIMESPEC\n  return STAT_TIMESPEC (st, st_ctim).tv_nsec;\n# elif defined STAT_TIMESPEC_NS\n  return STAT_TIMESPEC_NS (st, st_ctim);\n# else\n  return 0;\n# endif\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "int",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "get_stat_mtime_ns": {
      "start_point": [
        82,
        26
      ],
      "end_point": [
        92,
        1
      ],
      "content": "int _GL_ATTRIBUTE_PURE\nget_stat_mtime_ns (struct stat const *st)\n{\n# if defined STAT_TIMESPEC\n  return STAT_TIMESPEC (st, st_mtim).tv_nsec;\n# elif defined STAT_TIMESPEC_NS\n  return STAT_TIMESPEC_NS (st, st_mtim);\n# else\n  return 0;\n# endif\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "int",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "get_stat_birthtime_ns": {
      "start_point": [
        95,
        26
      ],
      "end_point": [
        107,
        1
      ],
      "content": "int _GL_ATTRIBUTE_PURE\nget_stat_birthtime_ns (struct stat const *st)\n{\n# if defined HAVE_STRUCT_STAT_ST_BIRTHTIMESPEC_TV_NSEC\n  return STAT_TIMESPEC (st, st_birthtim).tv_nsec;\n# elif defined HAVE_STRUCT_STAT_ST_BIRTHTIMENSEC\n  return STAT_TIMESPEC_NS (st, st_birthtim);\n# else\n  /* Avoid a \"parameter unused\" warning.  */\n  (void) st;\n  return 0;\n# endif\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "int",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "get_stat_atime": {
      "start_point": [
        110,
        28
      ],
      "end_point": [
        121,
        1
      ],
      "content": "timespec _GL_ATTRIBUTE_PURE\nget_stat_atime (struct stat const *st)\n{\n#ifdef STAT_TIMESPEC\n  return STAT_TIMESPEC (st, st_atim);\n#else\n  struct timespec t;\n  t.tv_sec = st->st_atime;\n  t.tv_nsec = get_stat_atime_ns (st);\n  return t;\n#endif\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "timespec",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "get_stat_ctime": {
      "start_point": [
        124,
        28
      ],
      "end_point": [
        135,
        1
      ],
      "content": "timespec _GL_ATTRIBUTE_PURE\nget_stat_ctime (struct stat const *st)\n{\n#ifdef STAT_TIMESPEC\n  return STAT_TIMESPEC (st, st_ctim);\n#else\n  struct timespec t;\n  t.tv_sec = st->st_ctime;\n  t.tv_nsec = get_stat_ctime_ns (st);\n  return t;\n#endif\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "timespec",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "get_stat_mtime": {
      "start_point": [
        138,
        28
      ],
      "end_point": [
        149,
        1
      ],
      "content": "timespec _GL_ATTRIBUTE_PURE\nget_stat_mtime (struct stat const *st)\n{\n#ifdef STAT_TIMESPEC\n  return STAT_TIMESPEC (st, st_mtim);\n#else\n  struct timespec t;\n  t.tv_sec = st->st_mtime;\n  t.tv_nsec = get_stat_mtime_ns (st);\n  return t;\n#endif\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "timespec",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "get_stat_birthtime": {
      "start_point": [
        153,
        28
      ],
      "end_point": [
        194,
        1
      ],
      "content": "timespec _GL_ATTRIBUTE_PURE\nget_stat_birthtime (struct stat const *st)\n{\n  struct timespec t;\n\n#if (defined HAVE_STRUCT_STAT_ST_BIRTHTIMESPEC_TV_NSEC \\\n     || defined HAVE_STRUCT_STAT_ST_BIRTHTIM_TV_NSEC)\n  t = STAT_TIMESPEC (st, st_birthtim);\n#elif defined HAVE_STRUCT_STAT_ST_BIRTHTIMENSEC\n  t.tv_sec = st->st_birthtime;\n  t.tv_nsec = st->st_birthtimensec;\n#elif (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n  /* Native Windows platforms (but not Cygwin) put the \"file creation\n     time\" in st_ctime (!).  See\n     <http://msdn2.microsoft.com/de-de/library/14h5k7ff(VS.80).aspx>.  */\n  t.tv_sec = st->st_ctime;\n  t.tv_nsec = 0;\n#else\n  /* Birth time is not supported.  */\n  t.tv_sec = -1;\n  t.tv_nsec = -1;\n  /* Avoid a \"parameter unused\" warning.  */\n  (void) st;\n#endif\n\n#if (defined HAVE_STRUCT_STAT_ST_BIRTHTIMESPEC_TV_NSEC \\\n     || defined HAVE_STRUCT_STAT_ST_BIRTHTIM_TV_NSEC \\\n     || defined HAVE_STRUCT_STAT_ST_BIRTHTIMENSEC)\n  /* FreeBSD and NetBSD sometimes signal the absence of knowledge by\n     using zero.  Attempt to work around this problem.  Alas, this can\n     report failure even for valid time stamps.  Also, NetBSD\n     sometimes returns junk in the birth time fields; work around this\n     bug if it is detected.  */\n  if (! (t.tv_sec && 0 <= t.tv_nsec && t.tv_nsec < 1000000000))\n    {\n      t.tv_sec = -1;\n      t.tv_nsec = -1;\n    }\n#endif\n\n  return t;\n}",
      "lines": 42,
      "depth": 12,
      "decorators": [
        "timespec",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/stat.c": {
    "orig_stat": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "static int\norig_stat (const char *filename, struct stat *buf)\n{\n  return stat (filename, buf);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_stat": {
      "start_point": [
        78,
        0
      ],
      "end_point": [
        137,
        1
      ],
      "content": "int\nrpl_stat (char const *name, struct stat *st)\n{\n  int result = orig_stat (name, st);\n#if REPLACE_FUNC_STAT_FILE\n  /* Solaris 9 mistakenly succeeds when given a non-directory with a\n     trailing slash.  */\n  if (result == 0 && !S_ISDIR (st->st_mode))\n    {\n      size_t len = strlen (name);\n      if (ISSLASH (name[len - 1]))\n        {\n          errno = ENOTDIR;\n          return -1;\n        }\n    }\n#endif /* REPLACE_FUNC_STAT_FILE */\n#if REPLACE_FUNC_STAT_DIR\n\n  if (result == -1 && errno == ENOENT)\n    {\n      /* Due to mingw's oddities, there are some directories (like\n         c:\\) where stat() only succeeds with a trailing slash, and\n         other directories (like c:\\windows) where stat() only\n         succeeds without a trailing slash.  But we want the two to be\n         synonymous, since chdir() manages either style.  Likewise, Mingw also\n         reports ENOENT for names longer than PATH_MAX, when we want\n         ENAMETOOLONG, and for stat(\"file/\"), when we want ENOTDIR.\n         Fortunately, mingw PATH_MAX is small enough for stack\n         allocation.  */\n      char fixed_name[PATH_MAX + 1] = {0};\n      size_t len = strlen (name);\n      bool check_dir = false;\n      verify (PATH_MAX <= 4096);\n      if (PATH_MAX <= len)\n        errno = ENAMETOOLONG;\n      else if (len)\n        {\n          strcpy (fixed_name, name);\n          if (ISSLASH (fixed_name[len - 1]))\n            {\n              check_dir = true;\n              while (len && ISSLASH (fixed_name[len - 1]))\n                fixed_name[--len] = '\\0';\n              if (!len)\n                fixed_name[0] = '/';\n            }\n          else\n            fixed_name[len++] = '/';\n          result = orig_stat (fixed_name, st);\n          if (result == 0 && check_dir && !S_ISDIR (st->st_mode))\n            {\n              result = -1;\n              errno = ENOTDIR;\n            }\n        }\n    }\n#endif /* REPLACE_FUNC_STAT_DIR */\n  return result;\n}",
      "lines": 60,
      "depth": 18,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/statat.c": {},
  "findutils/findutils-4.6.0/gl/lib/stdalign.in.h": {},
  "findutils/findutils-4.6.0/gl/lib/stdarg.in.h": {},
  "findutils/findutils-4.6.0/gl/lib/stdbool.in.h": {},
  "findutils/findutils-4.6.0/gl/lib/stddef.in.h": {},
  "findutils/findutils-4.6.0/gl/lib/stdint.in.h": {},
  "findutils/findutils-4.6.0/gl/lib/stdio--.h": {},
  "findutils/findutils-4.6.0/gl/lib/stdio-impl.h": {},
  "findutils/findutils-4.6.0/gl/lib/stdio-safer.h": {},
  "findutils/findutils-4.6.0/gl/lib/stdio.in.h": {},
  "findutils/findutils-4.6.0/gl/lib/stdlib.in.h": {},
  "findutils/findutils-4.6.0/gl/lib/stpcpy.c": {
    "__stpcpy": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "char *\n__stpcpy (char *dest, const char *src)\n{\n  register char *d = dest;\n  register const char *s = src;\n\n  do\n    *d++ = *s;\n  while (*s++ != '\\0');\n\n  return d - 1;\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "char",
        "*\n__stpcpy (char *dest, const char *src)",
        "*"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/str-kmp.h": {
    "knuth_morris_pratt": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        150,
        1
      ],
      "content": "static bool\nknuth_morris_pratt (const UNIT *haystack,\n                    const UNIT *needle, size_t needle_len,\n                    const UNIT **resultp)\n{\n  size_t m = needle_len;\n\n  /* Allocate the table.  */\n  size_t *table = (size_t *) nmalloca (m, sizeof (size_t));\n  if (table == NULL)\n    return false;\n  /* Fill the table.\n     For 0 < i < m:\n       0 < table[i] <= i is defined such that\n       forall 0 < x < table[i]: needle[x..i-1] != needle[0..i-1-x],\n       and table[i] is as large as possible with this property.\n     This implies:\n     1) For 0 < i < m:\n          If table[i] < i,\n          needle[table[i]..i-1] = needle[0..i-1-table[i]].\n     2) For 0 < i < m:\n          rhaystack[0..i-1] == needle[0..i-1]\n          and exists h, i <= h < m: rhaystack[h] != needle[h]\n          implies\n          forall 0 <= x < table[i]: rhaystack[x..x+m-1] != needle[0..m-1].\n     table[0] remains uninitialized.  */\n  {\n    size_t i, j;\n\n    /* i = 1: Nothing to verify for x = 0.  */\n    table[1] = 1;\n    j = 0;\n\n    for (i = 2; i < m; i++)\n      {\n        /* Here: j = i-1 - table[i-1].\n           The inequality needle[x..i-1] != needle[0..i-1-x] is known to hold\n           for x < table[i-1], by induction.\n           Furthermore, if j>0: needle[i-1-j..i-2] = needle[0..j-1].  */\n        UNIT b = CANON_ELEMENT (needle[i - 1]);\n\n        for (;;)\n          {\n            /* Invariants: The inequality needle[x..i-1] != needle[0..i-1-x]\n               is known to hold for x < i-1-j.\n               Furthermore, if j>0: needle[i-1-j..i-2] = needle[0..j-1].  */\n            if (b == CANON_ELEMENT (needle[j]))\n              {\n                /* Set table[i] := i-1-j.  */\n                table[i] = i - ++j;\n                break;\n              }\n            /* The inequality needle[x..i-1] != needle[0..i-1-x] also holds\n               for x = i-1-j, because\n                 needle[i-1] != needle[j] = needle[i-1-x].  */\n            if (j == 0)\n              {\n                /* The inequality holds for all possible x.  */\n                table[i] = i;\n                break;\n              }\n            /* The inequality needle[x..i-1] != needle[0..i-1-x] also holds\n               for i-1-j < x < i-1-j+table[j], because for these x:\n                 needle[x..i-2]\n                 = needle[x-(i-1-j)..j-1]\n                 != needle[0..j-1-(x-(i-1-j))]  (by definition of table[j])\n                    = needle[0..i-2-x],\n               hence needle[x..i-1] != needle[0..i-1-x].\n               Furthermore\n                 needle[i-1-j+table[j]..i-2]\n                 = needle[table[j]..j-1]\n                 = needle[0..j-1-table[j]]  (by definition of table[j]).  */\n            j = j - table[j];\n          }\n        /* Here: j = i - table[i].  */\n      }\n  }\n\n  /* Search, using the table to accelerate the processing.  */\n  {\n    size_t j;\n    const UNIT *rhaystack;\n    const UNIT *phaystack;\n\n    *resultp = NULL;\n    j = 0;\n    rhaystack = haystack;\n    phaystack = haystack;\n    /* Invariant: phaystack = rhaystack + j.  */\n    while (*phaystack != 0)\n      if (CANON_ELEMENT (needle[j]) == CANON_ELEMENT (*phaystack))\n        {\n          j++;\n          phaystack++;\n          if (j == m)\n            {\n              /* The entire needle has been found.  */\n              *resultp = rhaystack;\n              break;\n            }\n        }\n      else if (j > 0)\n        {\n          /* Found a match of needle[0..j-1], mismatch at needle[j].  */\n          rhaystack += table[j];\n          j -= table[j];\n        }\n      else\n        {\n          /* Found a mismatch at needle[0] already.  */\n          rhaystack++;\n          phaystack++;\n        }\n  }\n\n  freea (table);\n  return true;\n}",
      "lines": 118,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/str-two-way.h": {
    "critical_factorization": {
      "start_point": [
        106,
        0
      ],
      "end_point": [
        221,
        1
      ],
      "content": "static size_t\ncritical_factorization (const unsigned char *needle, size_t needle_len,\n                        size_t *period)\n{\n  /* Index of last byte of left half, or SIZE_MAX.  */\n  size_t max_suffix, max_suffix_rev;\n  size_t j; /* Index into NEEDLE for current candidate suffix.  */\n  size_t k; /* Offset into current period.  */\n  size_t p; /* Intermediate period.  */\n  unsigned char a, b; /* Current comparison bytes.  */\n\n  /* Special case NEEDLE_LEN of 1 or 2 (all callers already filtered\n     out 0-length needles.  */\n  if (needle_len < 3)\n    {\n      *period = 1;\n      return needle_len - 1;\n    }\n\n  /* Invariants:\n     0 <= j < NEEDLE_LEN - 1\n     -1 <= max_suffix{,_rev} < j (treating SIZE_MAX as if it were signed)\n     min(max_suffix, max_suffix_rev) < global period of NEEDLE\n     1 <= p <= global period of NEEDLE\n     p == global period of the substring NEEDLE[max_suffix{,_rev}+1...j]\n     1 <= k <= p\n  */\n\n  /* Perform lexicographic search.  */\n  max_suffix = SIZE_MAX;\n  j = 0;\n  k = p = 1;\n  while (j + k < needle_len)\n    {\n      a = CANON_ELEMENT (needle[j + k]);\n      b = CANON_ELEMENT (needle[max_suffix + k]);\n      if (a < b)\n        {\n          /* Suffix is smaller, period is entire prefix so far.  */\n          j += k;\n          k = 1;\n          p = j - max_suffix;\n        }\n      else if (a == b)\n        {\n          /* Advance through repetition of the current period.  */\n          if (k != p)\n            ++k;\n          else\n            {\n              j += p;\n              k = 1;\n            }\n        }\n      else /* b < a */\n        {\n          /* Suffix is larger, start over from current location.  */\n          max_suffix = j++;\n          k = p = 1;\n        }\n    }\n  *period = p;\n\n  /* Perform reverse lexicographic search.  */\n  max_suffix_rev = SIZE_MAX;\n  j = 0;\n  k = p = 1;\n  while (j + k < needle_len)\n    {\n      a = CANON_ELEMENT (needle[j + k]);\n      b = CANON_ELEMENT (needle[max_suffix_rev + k]);\n      if (b < a)\n        {\n          /* Suffix is smaller, period is entire prefix so far.  */\n          j += k;\n          k = 1;\n          p = j - max_suffix_rev;\n        }\n      else if (a == b)\n        {\n          /* Advance through repetition of the current period.  */\n          if (k != p)\n            ++k;\n          else\n            {\n              j += p;\n              k = 1;\n            }\n        }\n      else /* a < b */\n        {\n          /* Suffix is larger, start over from current location.  */\n          max_suffix_rev = j++;\n          k = p = 1;\n        }\n    }\n\n  /* Choose the shorter suffix.  Return the index of the first byte of\n     the right half, rather than the last byte of the left half.\n\n     For some examples, 'banana' has two critical factorizations, both\n     exposed by the two lexicographic extreme suffixes of 'anana' and\n     'nana', where both suffixes have a period of 2.  On the other\n     hand, with 'aab' and 'bba', both strings have a single critical\n     factorization of the last byte, with the suffix having a period\n     of 1.  While the maximal lexicographic suffix of 'aab' is 'b',\n     the maximal lexicographic suffix of 'bba' is 'ba', which is not a\n     critical factorization.  Conversely, the maximal reverse\n     lexicographic suffix of 'a' works for 'bba', but not 'ab' for\n     'aab'.  The shorter suffix of the two will always be a critical\n     factorization.  */\n  if (max_suffix_rev + 1 < max_suffix + 1)\n    return max_suffix + 1;\n  *period = p;\n  return max_suffix_rev + 1;\n}",
      "lines": 116,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "two_way_short_needle": {
      "start_point": [
        233,
        0
      ],
      "end_point": [
        313,
        1
      ],
      "content": "static RETURN_TYPE\ntwo_way_short_needle (const unsigned char *haystack, size_t haystack_len,\n                      const unsigned char *needle, size_t needle_len)\n{\n  size_t i; /* Index into current byte of NEEDLE.  */\n  size_t j; /* Index into current window of HAYSTACK.  */\n  size_t period; /* The period of the right half of needle.  */\n  size_t suffix; /* The index of the right half of needle.  */\n\n  /* Factor the needle into two halves, such that the left half is\n     smaller than the global period, and the right half is\n     periodic (with a period as large as NEEDLE_LEN - suffix).  */\n  suffix = critical_factorization (needle, needle_len, &period);\n\n  /* Perform the search.  Each iteration compares the right half\n     first.  */\n  if (CMP_FUNC (needle, needle + period, suffix) == 0)\n    {\n      /* Entire needle is periodic; a mismatch in the left half can\n         only advance by the period, so use memory to avoid rescanning\n         known occurrences of the period in the right half.  */\n      size_t memory = 0;\n      j = 0;\n      while (AVAILABLE (haystack, haystack_len, j, needle_len))\n        {\n          /* Scan for matches in right half.  */\n          i = MAX (suffix, memory);\n          while (i < needle_len && (CANON_ELEMENT (needle[i])\n                                    == CANON_ELEMENT (haystack[i + j])))\n            ++i;\n          if (needle_len <= i)\n            {\n              /* Scan for matches in left half.  */\n              i = suffix - 1;\n              while (memory < i + 1 && (CANON_ELEMENT (needle[i])\n                                        == CANON_ELEMENT (haystack[i + j])))\n                --i;\n              if (i + 1 < memory + 1)\n                return (RETURN_TYPE) (haystack + j);\n              /* No match, so remember how many repetitions of period\n                 on the right half were scanned.  */\n              j += period;\n              memory = needle_len - period;\n            }\n          else\n            {\n              j += i - suffix + 1;\n              memory = 0;\n            }\n        }\n    }\n  else\n    {\n      /* The two halves of needle are distinct; no extra memory is\n         required, and any mismatch results in a maximal shift.  */\n      period = MAX (suffix, needle_len - suffix) + 1;\n      j = 0;\n      while (AVAILABLE (haystack, haystack_len, j, needle_len))\n        {\n          /* Scan for matches in right half.  */\n          i = suffix;\n          while (i < needle_len && (CANON_ELEMENT (needle[i])\n                                    == CANON_ELEMENT (haystack[i + j])))\n            ++i;\n          if (needle_len <= i)\n            {\n              /* Scan for matches in left half.  */\n              i = suffix - 1;\n              while (i != SIZE_MAX && (CANON_ELEMENT (needle[i])\n                                       == CANON_ELEMENT (haystack[i + j])))\n                --i;\n              if (i == SIZE_MAX)\n                return (RETURN_TYPE) (haystack + j);\n              j += period;\n            }\n          else\n            j += i - suffix + 1;\n        }\n    }\n  return NULL;\n}",
      "lines": 81,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "RETURN_TYPE"
      ]
    },
    "two_way_long_needle": {
      "start_point": [
        327,
        0
      ],
      "end_point": [
        445,
        1
      ],
      "content": "static RETURN_TYPE\ntwo_way_long_needle (const unsigned char *haystack, size_t haystack_len,\n                     const unsigned char *needle, size_t needle_len)\n{\n  size_t i; /* Index into current byte of NEEDLE.  */\n  size_t j; /* Index into current window of HAYSTACK.  */\n  size_t period; /* The period of the right half of needle.  */\n  size_t suffix; /* The index of the right half of needle.  */\n  size_t shift_table[1U << CHAR_BIT]; /* See below.  */\n\n  /* Factor the needle into two halves, such that the left half is\n     smaller than the global period, and the right half is\n     periodic (with a period as large as NEEDLE_LEN - suffix).  */\n  suffix = critical_factorization (needle, needle_len, &period);\n\n  /* Populate shift_table.  For each possible byte value c,\n     shift_table[c] is the distance from the last occurrence of c to\n     the end of NEEDLE, or NEEDLE_LEN if c is absent from the NEEDLE.\n     shift_table[NEEDLE[NEEDLE_LEN - 1]] contains the only 0.  */\n  for (i = 0; i < 1U << CHAR_BIT; i++)\n    shift_table[i] = needle_len;\n  for (i = 0; i < needle_len; i++)\n    shift_table[CANON_ELEMENT (needle[i])] = needle_len - i - 1;\n\n  /* Perform the search.  Each iteration compares the right half\n     first.  */\n  if (CMP_FUNC (needle, needle + period, suffix) == 0)\n    {\n      /* Entire needle is periodic; a mismatch in the left half can\n         only advance by the period, so use memory to avoid rescanning\n         known occurrences of the period in the right half.  */\n      size_t memory = 0;\n      size_t shift;\n      j = 0;\n      while (AVAILABLE (haystack, haystack_len, j, needle_len))\n        {\n          /* Check the last byte first; if it does not match, then\n             shift to the next possible match location.  */\n          shift = shift_table[CANON_ELEMENT (haystack[j + needle_len - 1])];\n          if (0 < shift)\n            {\n              if (memory && shift < period)\n                {\n                  /* Since needle is periodic, but the last period has\n                     a byte out of place, there can be no match until\n                     after the mismatch.  */\n                  shift = needle_len - period;\n                }\n              memory = 0;\n              j += shift;\n              continue;\n            }\n          /* Scan for matches in right half.  The last byte has\n             already been matched, by virtue of the shift table.  */\n          i = MAX (suffix, memory);\n          while (i < needle_len - 1 && (CANON_ELEMENT (needle[i])\n                                        == CANON_ELEMENT (haystack[i + j])))\n            ++i;\n          if (needle_len - 1 <= i)\n            {\n              /* Scan for matches in left half.  */\n              i = suffix - 1;\n              while (memory < i + 1 && (CANON_ELEMENT (needle[i])\n                                        == CANON_ELEMENT (haystack[i + j])))\n                --i;\n              if (i + 1 < memory + 1)\n                return (RETURN_TYPE) (haystack + j);\n              /* No match, so remember how many repetitions of period\n                 on the right half were scanned.  */\n              j += period;\n              memory = needle_len - period;\n            }\n          else\n            {\n              j += i - suffix + 1;\n              memory = 0;\n            }\n        }\n    }\n  else\n    {\n      /* The two halves of needle are distinct; no extra memory is\n         required, and any mismatch results in a maximal shift.  */\n      size_t shift;\n      period = MAX (suffix, needle_len - suffix) + 1;\n      j = 0;\n      while (AVAILABLE (haystack, haystack_len, j, needle_len))\n        {\n          /* Check the last byte first; if it does not match, then\n             shift to the next possible match location.  */\n          shift = shift_table[CANON_ELEMENT (haystack[j + needle_len - 1])];\n          if (0 < shift)\n            {\n              j += shift;\n              continue;\n            }\n          /* Scan for matches in right half.  The last byte has\n             already been matched, by virtue of the shift table.  */\n          i = suffix;\n          while (i < needle_len - 1 && (CANON_ELEMENT (needle[i])\n                                        == CANON_ELEMENT (haystack[i + j])))\n            ++i;\n          if (needle_len - 1 <= i)\n            {\n              /* Scan for matches in left half.  */\n              i = suffix - 1;\n              while (i != SIZE_MAX && (CANON_ELEMENT (needle[i])\n                                       == CANON_ELEMENT (haystack[i + j])))\n                --i;\n              if (i == SIZE_MAX)\n                return (RETURN_TYPE) (haystack + j);\n              j += period;\n            }\n          else\n            j += i - suffix + 1;\n        }\n    }\n  return NULL;\n}",
      "lines": 119,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "RETURN_TYPE"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/strcasecmp.c": {
    "strcasecmp": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "int\nstrcasecmp (const char *s1, const char *s2)\n{\n  const unsigned char *p1 = (const unsigned char *) s1;\n  const unsigned char *p2 = (const unsigned char *) s2;\n  unsigned char c1, c2;\n\n  if (p1 == p2)\n    return 0;\n\n  do\n    {\n      c1 = TOLOWER (*p1);\n      c2 = TOLOWER (*p2);\n\n      if (c1 == '\\0')\n        break;\n\n      ++p1;\n      ++p2;\n    }\n  while (c1 == c2);\n\n  if (UCHAR_MAX <= INT_MAX)\n    return c1 - c2;\n  else\n    /* On machines where 'char' and 'int' are types of the same size, the\n       difference of two 'unsigned char' values - including the sign bit -\n       doesn't fit in an 'int'.  */\n    return (c1 > c2 ? 1 : c1 < c2 ? -1 : 0);\n}",
      "lines": 31,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/strcasestr.c": {
    "strcasestr": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "char *\nstrcasestr (const char *haystack_start, const char *needle_start)\n{\n  const char *haystack = haystack_start;\n  const char *needle = needle_start;\n  size_t needle_len; /* Length of NEEDLE.  */\n  size_t haystack_len; /* Known minimum length of HAYSTACK.  */\n  bool ok = true; /* True if NEEDLE is prefix of HAYSTACK.  */\n\n  /* Determine length of NEEDLE, and in the process, make sure\n     HAYSTACK is at least as long (no point processing all of a long\n     NEEDLE if HAYSTACK is too short).  */\n  while (*haystack && *needle)\n    {\n      ok &= (TOLOWER ((unsigned char) *haystack)\n             == TOLOWER ((unsigned char) *needle));\n      haystack++;\n      needle++;\n    }\n  if (*needle)\n    return NULL;\n  if (ok)\n    return (char *) haystack_start;\n  needle_len = needle - needle_start;\n  haystack = haystack_start + 1;\n  haystack_len = needle_len - 1;\n\n  /* Perform the search.  Abstract memory is considered to be an array\n     of 'unsigned char' values, not an array of 'char' values.  See\n     ISO C 99 section 6.2.6.1.  */\n  if (needle_len < LONG_NEEDLE_THRESHOLD)\n    return two_way_short_needle ((const unsigned char *) haystack,\n                                 haystack_len,\n                                 (const unsigned char *) needle_start,\n                                 needle_len);\n  return two_way_long_needle ((const unsigned char *) haystack, haystack_len,\n                              (const unsigned char *) needle_start,\n                              needle_len);\n}",
      "lines": 39,
      "depth": 14,
      "decorators": [
        "char",
        "*\nstrcasestr (const char *haystack_start, const char *needle_start)",
        "*"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/strdup.c": {
    "__strdup": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "char *\n__strdup (const char *s)\n{\n  size_t len = strlen (s) + 1;\n  void *new = malloc (len);\n\n  if (new == NULL)\n    return NULL;\n\n  return (char *) memcpy (new, s, len);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "char",
        "*\n__strdup (const char *s)",
        "*"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/streq.h": {
    "streq9": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "static inline int\nstreq9 (const char *s1, const char *s2)\n{\n  return strcmp (s1 + 9, s2 + 9) == 0;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq8": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "static inline int\nstreq8 (const char *s1, const char *s2, char s28)\n{\n  if (s1[8] == s28)\n    {\n      if (s28 == 0)\n        return 1;\n      else\n        return streq9 (s1, s2);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq7": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        65,
        1
      ],
      "content": "static inline int\nstreq7 (const char *s1, const char *s2, char s27, char s28)\n{\n  if (s1[7] == s27)\n    {\n      if (s27 == 0)\n        return 1;\n      else\n        return streq8 (s1, s2, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq6": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "static inline int\nstreq6 (const char *s1, const char *s2, char s26, char s27, char s28)\n{\n  if (s1[6] == s26)\n    {\n      if (s26 == 0)\n        return 1;\n      else\n        return streq7 (s1, s2, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq5": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "static inline int\nstreq5 (const char *s1, const char *s2, char s25, char s26, char s27, char s28)\n{\n  if (s1[5] == s25)\n    {\n      if (s25 == 0)\n        return 1;\n      else\n        return streq6 (s1, s2, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq4": {
      "start_point": [
        95,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "static inline int\nstreq4 (const char *s1, const char *s2, char s24, char s25, char s26, char s27, char s28)\n{\n  if (s1[4] == s24)\n    {\n      if (s24 == 0)\n        return 1;\n      else\n        return streq5 (s1, s2, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq3": {
      "start_point": [
        109,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "static inline int\nstreq3 (const char *s1, const char *s2, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (s1[3] == s23)\n    {\n      if (s23 == 0)\n        return 1;\n      else\n        return streq4 (s1, s2, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq2": {
      "start_point": [
        123,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "static inline int\nstreq2 (const char *s1, const char *s2, char s22, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (s1[2] == s22)\n    {\n      if (s22 == 0)\n        return 1;\n      else\n        return streq3 (s1, s2, s23, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq1": {
      "start_point": [
        137,
        0
      ],
      "end_point": [
        149,
        1
      ],
      "content": "static inline int\nstreq1 (const char *s1, const char *s2, char s21, char s22, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (s1[1] == s21)\n    {\n      if (s21 == 0)\n        return 1;\n      else\n        return streq2 (s1, s2, s22, s23, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq0": {
      "start_point": [
        151,
        0
      ],
      "end_point": [
        163,
        1
      ],
      "content": "static inline int\nstreq0 (const char *s1, const char *s2, char s20, char s21, char s22, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (s1[0] == s20)\n    {\n      if (s20 == 0)\n        return 1;\n      else\n        return streq1 (s1, s2, s21, s22, s23, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/strerror-override.c": {
    "strerror_override": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        301,
        1
      ],
      "content": "const char *\nstrerror_override (int errnum)\n{\n  /* These error messages are taken from glibc/sysdeps/gnu/errlist.c.  */\n  switch (errnum)\n    {\n#if REPLACE_STRERROR_0\n    case 0:\n      return \"Success\";\n#endif\n\n#if GNULIB_defined_ESOCK /* native Windows platforms with older <errno.h> */\n    case EINPROGRESS:\n      return \"Operation now in progress\";\n    case EALREADY:\n      return \"Operation already in progress\";\n    case ENOTSOCK:\n      return \"Socket operation on non-socket\";\n    case EDESTADDRREQ:\n      return \"Destination address required\";\n    case EMSGSIZE:\n      return \"Message too long\";\n    case EPROTOTYPE:\n      return \"Protocol wrong type for socket\";\n    case ENOPROTOOPT:\n      return \"Protocol not available\";\n    case EPROTONOSUPPORT:\n      return \"Protocol not supported\";\n    case EOPNOTSUPP:\n      return \"Operation not supported\";\n    case EAFNOSUPPORT:\n      return \"Address family not supported by protocol\";\n    case EADDRINUSE:\n      return \"Address already in use\";\n    case EADDRNOTAVAIL:\n      return \"Cannot assign requested address\";\n    case ENETDOWN:\n      return \"Network is down\";\n    case ENETUNREACH:\n      return \"Network is unreachable\";\n    case ECONNRESET:\n      return \"Connection reset by peer\";\n    case ENOBUFS:\n      return \"No buffer space available\";\n    case EISCONN:\n      return \"Transport endpoint is already connected\";\n    case ENOTCONN:\n      return \"Transport endpoint is not connected\";\n    case ETIMEDOUT:\n      return \"Connection timed out\";\n    case ECONNREFUSED:\n      return \"Connection refused\";\n    case ELOOP:\n      return \"Too many levels of symbolic links\";\n    case EHOSTUNREACH:\n      return \"No route to host\";\n    case EWOULDBLOCK:\n      return \"Operation would block\";\n#endif\n#if GNULIB_defined_ESTREAMS /* native Windows platforms with older <errno.h> */\n    case ETXTBSY:\n      return \"Text file busy\";\n    case ENODATA:\n      return \"No data available\";\n    case ENOSR:\n      return \"Out of streams resources\";\n    case ENOSTR:\n      return \"Device not a stream\";\n    case ETIME:\n      return \"Timer expired\";\n    case EOTHER:\n      return \"Other error\";\n#endif\n#if GNULIB_defined_EWINSOCK /* native Windows platforms */\n    case ESOCKTNOSUPPORT:\n      return \"Socket type not supported\";\n    case EPFNOSUPPORT:\n      return \"Protocol family not supported\";\n    case ESHUTDOWN:\n      return \"Cannot send after transport endpoint shutdown\";\n    case ETOOMANYREFS:\n      return \"Too many references: cannot splice\";\n    case EHOSTDOWN:\n      return \"Host is down\";\n    case EPROCLIM:\n      return \"Too many processes\";\n    case EUSERS:\n      return \"Too many users\";\n    case EDQUOT:\n      return \"Disk quota exceeded\";\n    case ESTALE:\n      return \"Stale NFS file handle\";\n    case EREMOTE:\n      return \"Object is remote\";\n# if HAVE_WINSOCK2_H\n      /* WSA_INVALID_HANDLE maps to EBADF */\n      /* WSA_NOT_ENOUGH_MEMORY maps to ENOMEM */\n      /* WSA_INVALID_PARAMETER maps to EINVAL */\n    case WSA_OPERATION_ABORTED:\n      return \"Overlapped operation aborted\";\n    case WSA_IO_INCOMPLETE:\n      return \"Overlapped I/O event object not in signaled state\";\n    case WSA_IO_PENDING:\n      return \"Overlapped operations will complete later\";\n      /* WSAEINTR maps to EINTR */\n      /* WSAEBADF maps to EBADF */\n      /* WSAEACCES maps to EACCES */\n      /* WSAEFAULT maps to EFAULT */\n      /* WSAEINVAL maps to EINVAL */\n      /* WSAEMFILE maps to EMFILE */\n      /* WSAEWOULDBLOCK maps to EWOULDBLOCK */\n      /* WSAEINPROGRESS maps to EINPROGRESS */\n      /* WSAEALREADY maps to EALREADY */\n      /* WSAENOTSOCK maps to ENOTSOCK */\n      /* WSAEDESTADDRREQ maps to EDESTADDRREQ */\n      /* WSAEMSGSIZE maps to EMSGSIZE */\n      /* WSAEPROTOTYPE maps to EPROTOTYPE */\n      /* WSAENOPROTOOPT maps to ENOPROTOOPT */\n      /* WSAEPROTONOSUPPORT maps to EPROTONOSUPPORT */\n      /* WSAESOCKTNOSUPPORT is ESOCKTNOSUPPORT */\n      /* WSAEOPNOTSUPP maps to EOPNOTSUPP */\n      /* WSAEPFNOSUPPORT is EPFNOSUPPORT */\n      /* WSAEAFNOSUPPORT maps to EAFNOSUPPORT */\n      /* WSAEADDRINUSE maps to EADDRINUSE */\n      /* WSAEADDRNOTAVAIL maps to EADDRNOTAVAIL */\n      /* WSAENETDOWN maps to ENETDOWN */\n      /* WSAENETUNREACH maps to ENETUNREACH */\n      /* WSAENETRESET maps to ENETRESET */\n      /* WSAECONNABORTED maps to ECONNABORTED */\n      /* WSAECONNRESET maps to ECONNRESET */\n      /* WSAENOBUFS maps to ENOBUFS */\n      /* WSAEISCONN maps to EISCONN */\n      /* WSAENOTCONN maps to ENOTCONN */\n      /* WSAESHUTDOWN is ESHUTDOWN */\n      /* WSAETOOMANYREFS is ETOOMANYREFS */\n      /* WSAETIMEDOUT maps to ETIMEDOUT */\n      /* WSAECONNREFUSED maps to ECONNREFUSED */\n      /* WSAELOOP maps to ELOOP */\n      /* WSAENAMETOOLONG maps to ENAMETOOLONG */\n      /* WSAEHOSTDOWN is EHOSTDOWN */\n      /* WSAEHOSTUNREACH maps to EHOSTUNREACH */\n      /* WSAENOTEMPTY maps to ENOTEMPTY */\n      /* WSAEPROCLIM is EPROCLIM */\n      /* WSAEUSERS is EUSERS */\n      /* WSAEDQUOT is EDQUOT */\n      /* WSAESTALE is ESTALE */\n      /* WSAEREMOTE is EREMOTE */\n    case WSASYSNOTREADY:\n      return \"Network subsystem is unavailable\";\n    case WSAVERNOTSUPPORTED:\n      return \"Winsock.dll version out of range\";\n    case WSANOTINITIALISED:\n      return \"Successful WSAStartup not yet performed\";\n    case WSAEDISCON:\n      return \"Graceful shutdown in progress\";\n    case WSAENOMORE: case WSA_E_NO_MORE:\n      return \"No more results\";\n    case WSAECANCELLED: case WSA_E_CANCELLED:\n      return \"Call was canceled\";\n    case WSAEINVALIDPROCTABLE:\n      return \"Procedure call table is invalid\";\n    case WSAEINVALIDPROVIDER:\n      return \"Service provider is invalid\";\n    case WSAEPROVIDERFAILEDINIT:\n      return \"Service provider failed to initialize\";\n    case WSASYSCALLFAILURE:\n      return \"System call failure\";\n    case WSASERVICE_NOT_FOUND:\n      return \"Service not found\";\n    case WSATYPE_NOT_FOUND:\n      return \"Class type not found\";\n    case WSAEREFUSED:\n      return \"Database query was refused\";\n    case WSAHOST_NOT_FOUND:\n      return \"Host not found\";\n    case WSATRY_AGAIN:\n      return \"Nonauthoritative host not found\";\n    case WSANO_RECOVERY:\n      return \"Nonrecoverable error\";\n    case WSANO_DATA:\n      return \"Valid name, no data record of requested type\";\n      /* WSA_QOS_* omitted */\n# endif\n#endif\n\n#if GNULIB_defined_ENOMSG\n    case ENOMSG:\n      return \"No message of desired type\";\n#endif\n\n#if GNULIB_defined_EIDRM\n    case EIDRM:\n      return \"Identifier removed\";\n#endif\n\n#if GNULIB_defined_ENOLINK\n    case ENOLINK:\n      return \"Link has been severed\";\n#endif\n\n#if GNULIB_defined_EPROTO\n    case EPROTO:\n      return \"Protocol error\";\n#endif\n\n#if GNULIB_defined_EMULTIHOP\n    case EMULTIHOP:\n      return \"Multihop attempted\";\n#endif\n\n#if GNULIB_defined_EBADMSG\n    case EBADMSG:\n      return \"Bad message\";\n#endif\n\n#if GNULIB_defined_EOVERFLOW\n    case EOVERFLOW:\n      return \"Value too large for defined data type\";\n#endif\n\n#if GNULIB_defined_ENOTSUP\n    case ENOTSUP:\n      return \"Not supported\";\n#endif\n\n#if GNULIB_defined_ENETRESET\n    case ENETRESET:\n      return \"Network dropped connection on reset\";\n#endif\n\n#if GNULIB_defined_ECONNABORTED\n    case ECONNABORTED:\n      return \"Software caused connection abort\";\n#endif\n\n#if GNULIB_defined_ESTALE\n    case ESTALE:\n      return \"Stale NFS file handle\";\n#endif\n\n#if GNULIB_defined_EDQUOT\n    case EDQUOT:\n      return \"Disk quota exceeded\";\n#endif\n\n#if GNULIB_defined_ECANCELED\n    case ECANCELED:\n      return \"Operation canceled\";\n#endif\n\n#if GNULIB_defined_EOWNERDEAD\n    case EOWNERDEAD:\n      return \"Owner died\";\n#endif\n\n#if GNULIB_defined_ENOTRECOVERABLE\n    case ENOTRECOVERABLE:\n      return \"State not recoverable\";\n#endif\n\n#if GNULIB_defined_EILSEQ\n    case EILSEQ:\n      return \"Invalid or incomplete multibyte or wide character\";\n#endif\n\n    default:\n      return NULL;\n    }\n}",
      "lines": 269,
      "depth": 10,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nstrerror_override (int errnum)",
        "*"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/strerror-override.h": {},
  "findutils/findutils-4.6.0/gl/lib/strerror.c": {},
  "findutils/findutils-4.6.0/gl/lib/strerror_r.c": {
    "local_snprintf": {
      "start_point": [
        106,
        0
      ],
      "end_point": [
        118,
        1
      ],
      "content": "static int\nlocal_snprintf (char *buf, size_t buflen, const char *format, ...)\n{\n  va_list args;\n  int result;\n\n  va_start (args, format);\n  result = _vsnprintf (buf, buflen, format, args);\n  va_end (args);\n  if (buflen > 0 && (result < 0 || result >= buflen))\n    buf[buflen - 1] = '\\0';\n  return result;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "safe_copy": {
      "start_point": [
        124,
        0
      ],
      "end_point": [
        144,
        1
      ],
      "content": "static int\nsafe_copy (char *buf, size_t buflen, const char *msg)\n{\n  size_t len = strlen (msg);\n  int ret;\n\n  if (len < buflen)\n    {\n      /* Although POSIX allows memcpy() to corrupt errno, we don't\n         know of any implementation where this is a real problem.  */\n      memcpy (buf, msg, len + 1);\n      ret = 0;\n    }\n  else\n    {\n      memcpy (buf, msg, buflen - 1);\n      buf[buflen - 1] = '\\0';\n      ret = ERANGE;\n    }\n  return ret;\n}",
      "lines": 21,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/strftime.c": {
    "fwrite_lowcase": {
      "start_point": [
        286,
        0
      ],
      "end_point": [
        294,
        1
      ],
      "content": "static void\nfwrite_lowcase (FILE *fp, const CHAR_T *src, size_t len)\n{\n  while (len-- > 0)\n    {\n      fputc (TOLOWER ((UCHAR_T) *src, loc), fp);\n      ++src;\n    }\n}",
      "lines": 9,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "fwrite_uppcase": {
      "start_point": [
        296,
        0
      ],
      "end_point": [
        304,
        1
      ],
      "content": "static void\nfwrite_uppcase (FILE *fp, const CHAR_T *src, size_t len)\n{\n  while (len-- > 0)\n    {\n      fputc (TOUPPER ((UCHAR_T) *src, loc), fp);\n      ++src;\n    }\n}",
      "lines": 9,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "memcpy_lowcase": {
      "start_point": [
        306,
        0
      ],
      "end_point": [
        313,
        1
      ],
      "content": "static CHAR_T *\nmemcpy_lowcase (CHAR_T *dest, const CHAR_T *src,\n                size_t len LOCALE_PARAM_PROTO)\n{\n  while (len-- > 0)\n    dest[len] = TOLOWER ((UCHAR_T) src[len], loc);\n  return dest;\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "CHAR_T",
        "*\nmemcpy_lowcase (CHAR_T *dest, const CHAR_T *src,\n                size_t len LOCALE_PARAM_PROTO)",
        "*"
      ]
    },
    "memcpy_uppcase": {
      "start_point": [
        315,
        0
      ],
      "end_point": [
        322,
        1
      ],
      "content": "static CHAR_T *\nmemcpy_uppcase (CHAR_T *dest, const CHAR_T *src,\n                size_t len LOCALE_PARAM_PROTO)\n{\n  while (len-- > 0)\n    dest[len] = TOUPPER ((UCHAR_T) src[len], loc);\n  return dest;\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "CHAR_T",
        "*\nmemcpy_uppcase (CHAR_T *dest, const CHAR_T *src,\n                size_t len LOCALE_PARAM_PROTO)",
        "*"
      ]
    },
    "tm_diff": {
      "start_point": [
        330,
        0
      ],
      "end_point": [
        349,
        1
      ],
      "content": "static int\ntm_diff (const struct tm *a, const struct tm *b)\n{\n  /* Compute intervening leap days correctly even if year is negative.\n     Take care to avoid int overflow in leap day calculations,\n     but it's OK to assume that A and B are close to each other.  */\n  int a4 = SHR (a->tm_year, 2) + SHR (TM_YEAR_BASE, 2) - ! (a->tm_year & 3);\n  int b4 = SHR (b->tm_year, 2) + SHR (TM_YEAR_BASE, 2) - ! (b->tm_year & 3);\n  int a100 = a4 / 25 - (a4 % 25 < 0);\n  int b100 = b4 / 25 - (b4 % 25 < 0);\n  int a400 = SHR (a100, 2);\n  int b400 = SHR (b100, 2);\n  int intervening_leap_days = (a4 - b4) - (a100 - b100) + (a400 - b400);\n  int years = a->tm_year - b->tm_year;\n  int days = (365 * years + intervening_leap_days\n              + (a->tm_yday - b->tm_yday));\n  return (60 * (60 * (24 * days + (a->tm_hour - b->tm_hour))\n                + (a->tm_min - b->tm_min))\n          + (a->tm_sec - b->tm_sec));\n}",
      "lines": 20,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "iso_week_days": {
      "start_point": [
        364,
        0
      ],
      "end_point": [
        372,
        1
      ],
      "content": "static int\niso_week_days (int yday, int wday)\n{\n  /* Add enough to the first operand of % to make it nonnegative.  */\n  int big_enough_multiple_of_7 = (-YDAY_MINIMUM / 7 + 2) * 7;\n  return (yday\n          - (yday - wday + ISO_WEEK1_WDAY + big_enough_multiple_of_7) % 7\n          + ISO_WEEK1_WDAY - ISO_WEEK_START_WDAY);\n}",
      "lines": 9,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "strftime_case_": {
      "start_point": [
        406,
        0
      ],
      "end_point": [
        1445,
        1
      ],
      "content": "static size_t\nstrftime_case_ (bool upcase, STREAM_OR_CHAR_T *s,\n                STRFTIME_ARG (size_t maxsize)\n                const CHAR_T *format,\n                const struct tm *tp extra_args_spec LOCALE_PARAM_PROTO)\n{\n#if defined _LIBC && defined USE_IN_EXTENDED_LOCALE_MODEL\n  struct locale_data *const current = loc->__locales[LC_TIME];\n#endif\n#if FPRINTFTIME\n  size_t maxsize = (size_t) -1;\n#endif\n\n  int hour12 = tp->tm_hour;\n#ifdef _NL_CURRENT\n  /* We cannot make the following values variables since we must delay\n     the evaluation of these values until really needed since some\n     expressions might not be valid in every situation.  The 'struct tm'\n     might be generated by a strptime() call that initialized\n     only a few elements.  Dereference the pointers only if the format\n     requires this.  Then it is ok to fail if the pointers are invalid.  */\n# define a_wkday \\\n  ((const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(ABDAY_1) + tp->tm_wday))\n# define f_wkday \\\n  ((const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(DAY_1) + tp->tm_wday))\n# define a_month \\\n  ((const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(ABMON_1) + tp->tm_mon))\n# define f_month \\\n  ((const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(MON_1) + tp->tm_mon))\n# define ampm \\\n  ((const CHAR_T *) _NL_CURRENT (LC_TIME, tp->tm_hour > 11                    \\\n                                 ? NLW(PM_STR) : NLW(AM_STR)))\n\n# define aw_len STRLEN (a_wkday)\n# define am_len STRLEN (a_month)\n# define ap_len STRLEN (ampm)\n#endif\n#if HAVE_TZNAME\n  char **tzname_vec = tzname;\n#endif\n  const char *zone;\n  size_t i = 0;\n  STREAM_OR_CHAR_T *p = s;\n  const CHAR_T *f;\n#if DO_MULTIBYTE && !defined COMPILE_WIDE\n  const char *format_end = NULL;\n#endif\n\n#if ! defined _LIBC && ! HAVE_RUN_TZSET_TEST\n  /* Solaris 2.5.x and 2.6 tzset sometimes modify the storage returned\n     by localtime.  On such systems, we must either use the tzset and\n     localtime wrappers to work around the bug (which sets\n     HAVE_RUN_TZSET_TEST) or make a copy of the structure.  */\n  struct tm copy = *tp;\n  tp = &copy;\n#endif\n\n  zone = NULL;\n#if HAVE_TM_ZONE\n  /* The POSIX test suite assumes that setting\n     the environment variable TZ to a new value before calling strftime()\n     will influence the result (the %Z format) even if the information in\n     TP is computed with a totally different time zone.\n     This is bogus: though POSIX allows bad behavior like this,\n     POSIX does not require it.  Do the right thing instead.  */\n  zone = (const char *) tp->tm_zone;\n#endif\n#if HAVE_TZNAME\n  if (!tz)\n    {\n      if (! (zone && *zone))\n        zone = \"GMT\";\n    }\n  else\n    {\n# if !HAVE_TM_ZONE\n      /* Infer the zone name from *TZ instead of from TZNAME.  */\n      tzname_vec = tz->tzname_copy;\n# endif\n      /* POSIX.1 requires that local time zone information be used as\n         though strftime called tzset.  */\n# if HAVE_TZSET\n      tzset ();\n# endif\n    }\n  /* The tzset() call might have changed the value.  */\n  if (!(zone && *zone) && tp->tm_isdst >= 0)\n    zone = tzname_vec[tp->tm_isdst != 0];\n#endif\n  if (! zone)\n    zone = \"\";\n\n  if (hour12 > 12)\n    hour12 -= 12;\n  else\n    if (hour12 == 0)\n      hour12 = 12;\n\n  for (f = format; *f != '\\0'; ++f)\n    {\n      int pad = 0;              /* Padding for number ('-', '_', or 0).  */\n      int modifier;             /* Field modifier ('E', 'O', or 0).  */\n      int digits = 0;           /* Max digits for numeric format.  */\n      int number_value;         /* Numeric value to be printed.  */\n      unsigned int u_number_value; /* (unsigned int) number_value.  */\n      bool negative_number;     /* The number is negative.  */\n      bool always_output_a_sign; /* +/- should always be output.  */\n      int tz_colon_mask;        /* Bitmask of where ':' should appear.  */\n      const CHAR_T *subfmt;\n      CHAR_T sign_char;\n      CHAR_T *bufp;\n      CHAR_T buf[1\n                 + 2 /* for the two colons in a %::z or %:::z time zone */\n                 + (sizeof (int) < sizeof (time_t)\n                    ? INT_STRLEN_BOUND (time_t)\n                    : INT_STRLEN_BOUND (int))];\n      int width = -1;\n      bool to_lowcase = false;\n      bool to_uppcase = upcase;\n      size_t colons;\n      bool change_case = false;\n      int format_char;\n\n#if DO_MULTIBYTE && !defined COMPILE_WIDE\n      switch (*f)\n        {\n        case L_('%'):\n          break;\n\n        case L_('\\b'): case L_('\\t'): case L_('\\n'):\n        case L_('\\v'): case L_('\\f'): case L_('\\r'):\n        case L_(' '): case L_('!'): case L_('\"'): case L_('#'): case L_('&'):\n        case L_('\\''): case L_('('): case L_(')'): case L_('*'): case L_('+'):\n        case L_(','): case L_('-'): case L_('.'): case L_('/'): case L_('0'):\n        case L_('1'): case L_('2'): case L_('3'): case L_('4'): case L_('5'):\n        case L_('6'): case L_('7'): case L_('8'): case L_('9'): case L_(':'):\n        case L_(';'): case L_('<'): case L_('='): case L_('>'): case L_('?'):\n        case L_('A'): case L_('B'): case L_('C'): case L_('D'): case L_('E'):\n        case L_('F'): case L_('G'): case L_('H'): case L_('I'): case L_('J'):\n        case L_('K'): case L_('L'): case L_('M'): case L_('N'): case L_('O'):\n        case L_('P'): case L_('Q'): case L_('R'): case L_('S'): case L_('T'):\n        case L_('U'): case L_('V'): case L_('W'): case L_('X'): case L_('Y'):\n        case L_('Z'): case L_('['): case L_('\\\\'): case L_(']'): case L_('^'):\n        case L_('_'): case L_('a'): case L_('b'): case L_('c'): case L_('d'):\n        case L_('e'): case L_('f'): case L_('g'): case L_('h'): case L_('i'):\n        case L_('j'): case L_('k'): case L_('l'): case L_('m'): case L_('n'):\n        case L_('o'): case L_('p'): case L_('q'): case L_('r'): case L_('s'):\n        case L_('t'): case L_('u'): case L_('v'): case L_('w'): case L_('x'):\n        case L_('y'): case L_('z'): case L_('{'): case L_('|'): case L_('}'):\n        case L_('~'):\n          /* The C Standard requires these 98 characters (plus '%') to\n             be in the basic execution character set.  None of these\n             characters can start a multibyte sequence, so they need\n             not be analyzed further.  */\n          add1 (*f);\n          continue;\n\n        default:\n          /* Copy this multibyte sequence until we reach its end, find\n             an error, or come back to the initial shift state.  */\n          {\n            mbstate_t mbstate = mbstate_zero;\n            size_t len = 0;\n            size_t fsize;\n\n            if (! format_end)\n              format_end = f + strlen (f) + 1;\n            fsize = format_end - f;\n\n            do\n              {\n                size_t bytes = mbrlen (f + len, fsize - len, &mbstate);\n\n                if (bytes == 0)\n                  break;\n\n                if (bytes == (size_t) -2)\n                  {\n                    len += strlen (f + len);\n                    break;\n                  }\n\n                if (bytes == (size_t) -1)\n                  {\n                    len++;\n                    break;\n                  }\n\n                len += bytes;\n              }\n            while (! mbsinit (&mbstate));\n\n            cpy (len, f);\n            f += len - 1;\n            continue;\n          }\n        }\n\n#else /* ! DO_MULTIBYTE */\n\n      /* Either multibyte encodings are not supported, they are\n         safe for formats, so any non-'%' byte can be copied through,\n         or this is the wide character version.  */\n      if (*f != L_('%'))\n        {\n          add1 (*f);\n          continue;\n        }\n\n#endif /* ! DO_MULTIBYTE */\n\n      /* Check for flags that can modify a format.  */\n      while (1)\n        {\n          switch (*++f)\n            {\n              /* This influences the number formats.  */\n            case L_('_'):\n            case L_('-'):\n            case L_('0'):\n              pad = *f;\n              continue;\n\n              /* This changes textual output.  */\n            case L_('^'):\n              to_uppcase = true;\n              continue;\n            case L_('#'):\n              change_case = true;\n              continue;\n\n            default:\n              break;\n            }\n          break;\n        }\n\n      /* As a GNU extension we allow to specify the field width.  */\n      if (ISDIGIT (*f))\n        {\n          width = 0;\n          do\n            {\n              if (width > INT_MAX / 10\n                  || (width == INT_MAX / 10 && *f - L_('0') > INT_MAX % 10))\n                /* Avoid overflow.  */\n                width = INT_MAX;\n              else\n                {\n                  width *= 10;\n                  width += *f - L_('0');\n                }\n              ++f;\n            }\n          while (ISDIGIT (*f));\n        }\n\n      /* Check for modifiers.  */\n      switch (*f)\n        {\n        case L_('E'):\n        case L_('O'):\n          modifier = *f++;\n          break;\n\n        default:\n          modifier = 0;\n          break;\n        }\n\n      /* Now do the specified format.  */\n      format_char = *f;\n      switch (format_char)\n        {\n#define DO_NUMBER(d, v) \\\n          do                                                                  \\\n            {                                                                 \\\n              digits = d;                                                     \\\n              number_value = v;                                               \\\n              goto do_number;                                                 \\\n            }                                                                 \\\n          while (0)\n#define DO_SIGNED_NUMBER(d, negative, v) \\\n          do                                                                  \\\n            {                                                                 \\\n              digits = d;                                                     \\\n              negative_number = negative;                                     \\\n              u_number_value = v;                                             \\\n              goto do_signed_number;                                          \\\n            }                                                                 \\\n          while (0)\n\n          /* The mask is not what you might think.\n             When the ordinal i'th bit is set, insert a colon\n             before the i'th digit of the time zone representation.  */\n#define DO_TZ_OFFSET(d, negative, mask, v) \\\n          do                                                                  \\\n            {                                                                 \\\n              digits = d;                                                     \\\n              negative_number = negative;                                     \\\n              tz_colon_mask = mask;                                           \\\n              u_number_value = v;                                             \\\n              goto do_tz_offset;                                              \\\n            }                                                                 \\\n          while (0)\n#define DO_NUMBER_SPACEPAD(d, v) \\\n          do                                                                  \\\n            {                                                                 \\\n              digits = d;                                                     \\\n              number_value = v;                                               \\\n              goto do_number_spacepad;                                        \\\n            }                                                                 \\\n          while (0)\n\n        case L_('%'):\n          if (modifier != 0)\n            goto bad_format;\n          add1 (*f);\n          break;\n\n        case L_('a'):\n          if (modifier != 0)\n            goto bad_format;\n          if (change_case)\n            {\n              to_uppcase = true;\n              to_lowcase = false;\n            }\n#ifdef _NL_CURRENT\n          cpy (aw_len, a_wkday);\n          break;\n#else\n          goto underlying_strftime;\n#endif\n\n        case 'A':\n          if (modifier != 0)\n            goto bad_format;\n          if (change_case)\n            {\n              to_uppcase = true;\n              to_lowcase = false;\n            }\n#ifdef _NL_CURRENT\n          cpy (STRLEN (f_wkday), f_wkday);\n          break;\n#else\n          goto underlying_strftime;\n#endif\n\n        case L_('b'):\n        case L_('h'):\n          if (change_case)\n            {\n              to_uppcase = true;\n              to_lowcase = false;\n            }\n          if (modifier != 0)\n            goto bad_format;\n#ifdef _NL_CURRENT\n          cpy (am_len, a_month);\n          break;\n#else\n          goto underlying_strftime;\n#endif\n\n        case L_('B'):\n          if (modifier != 0)\n            goto bad_format;\n          if (change_case)\n            {\n              to_uppcase = true;\n              to_lowcase = false;\n            }\n#ifdef _NL_CURRENT\n          cpy (STRLEN (f_month), f_month);\n          break;\n#else\n          goto underlying_strftime;\n#endif\n\n        case L_('c'):\n          if (modifier == L_('O'))\n            goto bad_format;\n#ifdef _NL_CURRENT\n          if (! (modifier == 'E'\n                 && (*(subfmt =\n                       (const CHAR_T *) _NL_CURRENT (LC_TIME,\n                                                     NLW(ERA_D_T_FMT)))\n                     != '\\0')))\n            subfmt = (const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(D_T_FMT));\n#else\n          goto underlying_strftime;\n#endif\n\n        subformat:\n          {\n            size_t len = strftime_case_ (to_uppcase,\n                                         NULL, STRFTIME_ARG ((size_t) -1)\n                                         subfmt,\n                                         tp extra_args LOCALE_ARG);\n            add (len, strftime_case_ (to_uppcase, p,\n                                      STRFTIME_ARG (maxsize - i)\n                                      subfmt,\n                                      tp extra_args LOCALE_ARG));\n          }\n          break;\n\n#if !(defined _NL_CURRENT && HAVE_STRUCT_ERA_ENTRY)\n        underlying_strftime:\n          {\n            /* The relevant information is available only via the\n               underlying strftime implementation, so use that.  */\n            char ufmt[5];\n            char *u = ufmt;\n            char ubuf[1024]; /* enough for any single format in practice */\n            size_t len;\n            /* Make sure we're calling the actual underlying strftime.\n               In some cases, config.h contains something like\n               \"#define strftime rpl_strftime\".  */\n# ifdef strftime\n#  undef strftime\n            size_t strftime ();\n# endif\n\n            /* The space helps distinguish strftime failure from empty\n               output.  */\n            *u++ = ' ';\n            *u++ = '%';\n            if (modifier != 0)\n              *u++ = modifier;\n            *u++ = format_char;\n            *u = '\\0';\n            len = strftime (ubuf, sizeof ubuf, ufmt, tp);\n            if (len != 0)\n              cpy (len - 1, ubuf + 1);\n          }\n          break;\n#endif\n\n        case L_('C'):\n          if (modifier == L_('O'))\n            goto bad_format;\n          if (modifier == L_('E'))\n            {\n#if HAVE_STRUCT_ERA_ENTRY\n              struct era_entry *era = _nl_get_era_entry (tp HELPER_LOCALE_ARG);\n              if (era)\n                {\n# ifdef COMPILE_WIDE\n                  size_t len = __wcslen (era->era_wname);\n                  cpy (len, era->era_wname);\n# else\n                  size_t len = strlen (era->era_name);\n                  cpy (len, era->era_name);\n# endif\n                  break;\n                }\n#else\n              goto underlying_strftime;\n#endif\n            }\n\n          {\n            int century = tp->tm_year / 100 + TM_YEAR_BASE / 100;\n            century -= tp->tm_year % 100 < 0 && 0 < century;\n            DO_SIGNED_NUMBER (2, tp->tm_year < - TM_YEAR_BASE, century);\n          }\n\n        case L_('x'):\n          if (modifier == L_('O'))\n            goto bad_format;\n#ifdef _NL_CURRENT\n          if (! (modifier == L_('E')\n                 && (*(subfmt =\n                       (const CHAR_T *)_NL_CURRENT (LC_TIME, NLW(ERA_D_FMT)))\n                     != L_('\\0'))))\n            subfmt = (const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(D_FMT));\n          goto subformat;\n#else\n          goto underlying_strftime;\n#endif\n        case L_('D'):\n          if (modifier != 0)\n            goto bad_format;\n          subfmt = L_(\"%m/%d/%y\");\n          goto subformat;\n\n        case L_('d'):\n          if (modifier == L_('E'))\n            goto bad_format;\n\n          DO_NUMBER (2, tp->tm_mday);\n\n        case L_('e'):\n          if (modifier == L_('E'))\n            goto bad_format;\n\n          DO_NUMBER_SPACEPAD (2, tp->tm_mday);\n\n          /* All numeric formats set DIGITS and NUMBER_VALUE (or U_NUMBER_VALUE)\n             and then jump to one of these labels.  */\n\n        do_tz_offset:\n          always_output_a_sign = true;\n          goto do_number_body;\n\n        do_number_spacepad:\n          /* Force '_' flag unless overridden by '0' or '-' flag.  */\n          if (pad != L_('0') && pad != L_('-'))\n            pad = L_('_');\n\n        do_number:\n          /* Format NUMBER_VALUE according to the MODIFIER flag.  */\n          negative_number = number_value < 0;\n          u_number_value = number_value;\n\n        do_signed_number:\n          always_output_a_sign = false;\n          tz_colon_mask = 0;\n\n        do_number_body:\n          /* Format U_NUMBER_VALUE according to the MODIFIER flag.\n             NEGATIVE_NUMBER is nonzero if the original number was\n             negative; in this case it was converted directly to\n             unsigned int (i.e., modulo (UINT_MAX + 1)) without\n             negating it.  */\n          if (modifier == L_('O') && !negative_number)\n            {\n#ifdef _NL_CURRENT\n              /* Get the locale specific alternate representation of\n                 the number.  If none exist NULL is returned.  */\n              const CHAR_T *cp = nl_get_alt_digit (u_number_value\n                                                   HELPER_LOCALE_ARG);\n\n              if (cp != NULL)\n                {\n                  size_t digitlen = STRLEN (cp);\n                  if (digitlen != 0)\n                    {\n                      cpy (digitlen, cp);\n                      break;\n                    }\n                }\n#else\n              goto underlying_strftime;\n#endif\n            }\n\n          bufp = buf + sizeof (buf) / sizeof (buf[0]);\n\n          if (negative_number)\n            u_number_value = - u_number_value;\n\n          do\n            {\n              if (tz_colon_mask & 1)\n                *--bufp = ':';\n              tz_colon_mask >>= 1;\n              *--bufp = u_number_value % 10 + L_('0');\n              u_number_value /= 10;\n            }\n          while (u_number_value != 0 || tz_colon_mask != 0);\n\n        do_number_sign_and_padding:\n          if (digits < width)\n            digits = width;\n\n          sign_char = (negative_number ? L_('-')\n                       : always_output_a_sign ? L_('+')\n                       : 0);\n\n          if (pad == L_('-'))\n            {\n              if (sign_char)\n                add1 (sign_char);\n            }\n          else\n            {\n              int padding = digits - (buf + (sizeof (buf) / sizeof (buf[0]))\n                                      - bufp) - !!sign_char;\n\n              if (padding > 0)\n                {\n                  if (pad == L_('_'))\n                    {\n                      if ((size_t) padding >= maxsize - i)\n                        return 0;\n\n                      if (p)\n                        memset_space (p, padding);\n                      i += padding;\n                      width = width > padding ? width - padding : 0;\n                      if (sign_char)\n                        add1 (sign_char);\n                    }\n                  else\n                    {\n                      if ((size_t) digits >= maxsize - i)\n                        return 0;\n\n                      if (sign_char)\n                        add1 (sign_char);\n\n                      if (p)\n                        memset_zero (p, padding);\n                      i += padding;\n                      width = 0;\n                    }\n                }\n              else\n                {\n                  if (sign_char)\n                    add1 (sign_char);\n                }\n            }\n\n          cpy (buf + sizeof (buf) / sizeof (buf[0]) - bufp, bufp);\n          break;\n\n        case L_('F'):\n          if (modifier != 0)\n            goto bad_format;\n          subfmt = L_(\"%Y-%m-%d\");\n          goto subformat;\n\n        case L_('H'):\n          if (modifier == L_('E'))\n            goto bad_format;\n\n          DO_NUMBER (2, tp->tm_hour);\n\n        case L_('I'):\n          if (modifier == L_('E'))\n            goto bad_format;\n\n          DO_NUMBER (2, hour12);\n\n        case L_('k'):           /* GNU extension.  */\n          if (modifier == L_('E'))\n            goto bad_format;\n\n          DO_NUMBER_SPACEPAD (2, tp->tm_hour);\n\n        case L_('l'):           /* GNU extension.  */\n          if (modifier == L_('E'))\n            goto bad_format;\n\n          DO_NUMBER_SPACEPAD (2, hour12);\n\n        case L_('j'):\n          if (modifier == L_('E'))\n            goto bad_format;\n\n          DO_SIGNED_NUMBER (3, tp->tm_yday < -1, tp->tm_yday + 1U);\n\n        case L_('M'):\n          if (modifier == L_('E'))\n            goto bad_format;\n\n          DO_NUMBER (2, tp->tm_min);\n\n        case L_('m'):\n          if (modifier == L_('E'))\n            goto bad_format;\n\n          DO_SIGNED_NUMBER (2, tp->tm_mon < -1, tp->tm_mon + 1U);\n\n#ifndef _LIBC\n        case L_('N'):           /* GNU extension.  */\n          if (modifier == L_('E'))\n            goto bad_format;\n\n          number_value = ns;\n          if (width == -1)\n            width = 9;\n          else\n            {\n              /* Take an explicit width less than 9 as a precision.  */\n              int j;\n              for (j = width; j < 9; j++)\n                number_value /= 10;\n            }\n\n          DO_NUMBER (width, number_value);\n#endif\n\n        case L_('n'):\n          add1 (L_('\\n'));\n          break;\n\n        case L_('P'):\n          to_lowcase = true;\n#ifndef _NL_CURRENT\n          format_char = L_('p');\n#endif\n          /* FALLTHROUGH */\n\n        case L_('p'):\n          if (change_case)\n            {\n              to_uppcase = false;\n              to_lowcase = true;\n            }\n#ifdef _NL_CURRENT\n          cpy (ap_len, ampm);\n          break;\n#else\n          goto underlying_strftime;\n#endif\n\n        case L_('R'):\n          subfmt = L_(\"%H:%M\");\n          goto subformat;\n\n        case L_('r'):\n#ifdef _NL_CURRENT\n          if (*(subfmt = (const CHAR_T *) _NL_CURRENT (LC_TIME,\n                                                       NLW(T_FMT_AMPM)))\n              == L_('\\0'))\n            subfmt = L_(\"%I:%M:%S %p\");\n          goto subformat;\n#else\n          goto underlying_strftime;\n#endif\n\n        case L_('S'):\n          if (modifier == L_('E'))\n            goto bad_format;\n\n          DO_NUMBER (2, tp->tm_sec);\n\n        case L_('s'):           /* GNU extension.  */\n          {\n            struct tm ltm;\n            time_t t;\n\n            ltm = *tp;\n            t = mktime_z (tz, &ltm);\n\n            /* Generate string value for T using time_t arithmetic;\n               this works even if sizeof (long) < sizeof (time_t).  */\n\n            bufp = buf + sizeof (buf) / sizeof (buf[0]);\n            negative_number = t < 0;\n\n            do\n              {\n                int d = t % 10;\n                t /= 10;\n                *--bufp = (negative_number ? -d : d) + L_('0');\n              }\n            while (t != 0);\n\n            digits = 1;\n            always_output_a_sign = false;\n            goto do_number_sign_and_padding;\n          }\n\n        case L_('X'):\n          if (modifier == L_('O'))\n            goto bad_format;\n#ifdef _NL_CURRENT\n          if (! (modifier == L_('E')\n                 && (*(subfmt =\n                       (const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(ERA_T_FMT)))\n                     != L_('\\0'))))\n            subfmt = (const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(T_FMT));\n          goto subformat;\n#else\n          goto underlying_strftime;\n#endif\n        case L_('T'):\n          subfmt = L_(\"%H:%M:%S\");\n          goto subformat;\n\n        case L_('t'):\n          add1 (L_('\\t'));\n          break;\n\n        case L_('u'):\n          DO_NUMBER (1, (tp->tm_wday - 1 + 7) % 7 + 1);\n\n        case L_('U'):\n          if (modifier == L_('E'))\n            goto bad_format;\n\n          DO_NUMBER (2, (tp->tm_yday - tp->tm_wday + 7) / 7);\n\n        case L_('V'):\n        case L_('g'):\n        case L_('G'):\n          if (modifier == L_('E'))\n            goto bad_format;\n          {\n            /* YEAR is a leap year if and only if (tp->tm_year + TM_YEAR_BASE)\n               is a leap year, except that YEAR and YEAR - 1 both work\n               correctly even when (tp->tm_year + TM_YEAR_BASE) would\n               overflow.  */\n            int year = (tp->tm_year\n                        + (tp->tm_year < 0\n                           ? TM_YEAR_BASE % 400\n                           : TM_YEAR_BASE % 400 - 400));\n            int year_adjust = 0;\n            int days = iso_week_days (tp->tm_yday, tp->tm_wday);\n\n            if (days < 0)\n              {\n                /* This ISO week belongs to the previous year.  */\n                year_adjust = -1;\n                days = iso_week_days (tp->tm_yday + (365 + __isleap (year - 1)),\n                                      tp->tm_wday);\n              }\n            else\n              {\n                int d = iso_week_days (tp->tm_yday - (365 + __isleap (year)),\n                                       tp->tm_wday);\n                if (0 <= d)\n                  {\n                    /* This ISO week belongs to the next year.  */\n                    year_adjust = 1;\n                    days = d;\n                  }\n              }\n\n            switch (*f)\n              {\n              case L_('g'):\n                {\n                  int yy = (tp->tm_year % 100 + year_adjust) % 100;\n                  DO_NUMBER (2, (0 <= yy\n                                 ? yy\n                                 : tp->tm_year < -TM_YEAR_BASE - year_adjust\n                                 ? -yy\n                                 : yy + 100));\n                }\n\n              case L_('G'):\n                DO_SIGNED_NUMBER (4, tp->tm_year < -TM_YEAR_BASE - year_adjust,\n                                  (tp->tm_year + (unsigned int) TM_YEAR_BASE\n                                   + year_adjust));\n\n              default:\n                DO_NUMBER (2, days / 7 + 1);\n              }\n          }\n\n        case L_('W'):\n          if (modifier == L_('E'))\n            goto bad_format;\n\n          DO_NUMBER (2, (tp->tm_yday - (tp->tm_wday - 1 + 7) % 7 + 7) / 7);\n\n        case L_('w'):\n          if (modifier == L_('E'))\n            goto bad_format;\n\n          DO_NUMBER (1, tp->tm_wday);\n\n        case L_('Y'):\n          if (modifier == 'E')\n            {\n#if HAVE_STRUCT_ERA_ENTRY\n              struct era_entry *era = _nl_get_era_entry (tp HELPER_LOCALE_ARG);\n              if (era)\n                {\n# ifdef COMPILE_WIDE\n                  subfmt = era->era_wformat;\n# else\n                  subfmt = era->era_format;\n# endif\n                  goto subformat;\n                }\n#else\n              goto underlying_strftime;\n#endif\n            }\n          if (modifier == L_('O'))\n            goto bad_format;\n\n          DO_SIGNED_NUMBER (4, tp->tm_year < -TM_YEAR_BASE,\n                            tp->tm_year + (unsigned int) TM_YEAR_BASE);\n\n        case L_('y'):\n          if (modifier == L_('E'))\n            {\n#if HAVE_STRUCT_ERA_ENTRY\n              struct era_entry *era = _nl_get_era_entry (tp HELPER_LOCALE_ARG);\n              if (era)\n                {\n                  int delta = tp->tm_year - era->start_date[0];\n                  DO_NUMBER (1, (era->offset\n                                 + delta * era->absolute_direction));\n                }\n#else\n              goto underlying_strftime;\n#endif\n            }\n\n          {\n            int yy = tp->tm_year % 100;\n            if (yy < 0)\n              yy = tp->tm_year < - TM_YEAR_BASE ? -yy : yy + 100;\n            DO_NUMBER (2, yy);\n          }\n\n        case L_('Z'):\n          if (change_case)\n            {\n              to_uppcase = false;\n              to_lowcase = true;\n            }\n\n#ifdef COMPILE_WIDE\n          {\n            /* The zone string is always given in multibyte form.  We have\n               to transform it first.  */\n            wchar_t *wczone;\n            size_t len;\n            widen (zone, wczone, len);\n            cpy (len, wczone);\n          }\n#else\n          cpy (strlen (zone), zone);\n#endif\n          break;\n\n        case L_(':'):\n          /* :, ::, and ::: are valid only just before 'z'.\n             :::: etc. are rejected later.  */\n          for (colons = 1; f[colons] == L_(':'); colons++)\n            continue;\n          if (f[colons] != L_('z'))\n            goto bad_format;\n          f += colons;\n          goto do_z_conversion;\n\n        case L_('z'):\n          colons = 0;\n\n        do_z_conversion:\n          if (tp->tm_isdst < 0)\n            break;\n\n          {\n            int diff;\n            int hour_diff;\n            int min_diff;\n            int sec_diff;\n#if HAVE_TM_GMTOFF\n            diff = tp->tm_gmtoff;\n#else\n            if (!tz)\n              diff = 0;\n            else\n              {\n                struct tm gtm;\n                struct tm ltm;\n                time_t lt;\n\n                ltm = *tp;\n                lt = mktime_z (tz, &ltm);\n\n                if (lt == (time_t) -1)\n                  {\n                    /* mktime returns -1 for errors, but -1 is also a\n                       valid time_t value.  Check whether an error really\n                       occurred.  */\n                    struct tm tm;\n\n                    if (! localtime_rz (tz, &lt, &tm)\n                        || ((ltm.tm_sec ^ tm.tm_sec)\n                            | (ltm.tm_min ^ tm.tm_min)\n                            | (ltm.tm_hour ^ tm.tm_hour)\n                            | (ltm.tm_mday ^ tm.tm_mday)\n                            | (ltm.tm_mon ^ tm.tm_mon)\n                            | (ltm.tm_year ^ tm.tm_year)))\n                      break;\n                  }\n\n                if (! localtime_rz (0, &lt, &gtm))\n                  break;\n\n                diff = tm_diff (&ltm, &gtm);\n              }\n#endif\n\n            hour_diff = diff / 60 / 60;\n            min_diff = diff / 60 % 60;\n            sec_diff = diff % 60;\n\n            switch (colons)\n              {\n              case 0: /* +hhmm */\n                DO_TZ_OFFSET (5, diff < 0, 0, hour_diff * 100 + min_diff);\n\n              case 1: tz_hh_mm: /* +hh:mm */\n                DO_TZ_OFFSET (6, diff < 0, 04, hour_diff * 100 + min_diff);\n\n              case 2: tz_hh_mm_ss: /* +hh:mm:ss */\n                DO_TZ_OFFSET (9, diff < 0, 024,\n                              hour_diff * 10000 + min_diff * 100 + sec_diff);\n\n              case 3: /* +hh if possible, else +hh:mm, else +hh:mm:ss */\n                if (sec_diff != 0)\n                  goto tz_hh_mm_ss;\n                if (min_diff != 0)\n                  goto tz_hh_mm;\n                DO_TZ_OFFSET (3, diff < 0, 0, hour_diff);\n\n              default:\n                goto bad_format;\n              }\n          }\n\n        case L_('\\0'):          /* GNU extension: % at end of format.  */\n            --f;\n            /* Fall through.  */\n        default:\n          /* Unknown format; output the format, including the '%',\n             since this is most likely the right thing to do if a\n             multibyte string has been misparsed.  */\n        bad_format:\n          {\n            int flen;\n            for (flen = 1; f[1 - flen] != L_('%'); flen++)\n              continue;\n            cpy (flen, &f[1 - flen]);\n          }\n          break;\n        }\n    }\n\n#if ! FPRINTFTIME\n  if (p && maxsize != 0)\n    *p = L_('\\0');\n#endif\n\n  return i;\n}",
      "lines": 1040,
      "depth": 27,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "my_strftime": {
      "start_point": [
        1453,
        0
      ],
      "end_point": [
        1460,
        1
      ],
      "content": "size_t\nmy_strftime (STREAM_OR_CHAR_T *s, STRFTIME_ARG (size_t maxsize)\n             const CHAR_T *format,\n             const struct tm *tp extra_args_spec LOCALE_PARAM_PROTO)\n{\n  return strftime_case_ (false, s, STRFTIME_ARG (maxsize)\n                         format, tp extra_args LOCALE_ARG);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "size_t"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/strftime.h": {},
  "findutils/findutils-4.6.0/gl/lib/string.in.h": {},
  "findutils/findutils-4.6.0/gl/lib/strings.in.h": {},
  "findutils/findutils-4.6.0/gl/lib/stripslash.c": {
    "strip_trailing_slashes": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "bool\nstrip_trailing_slashes (char *file)\n{\n  char *base = last_component (file);\n  char *base_lim;\n  bool had_slash;\n\n  /* last_component returns \"\" for file system roots, but we need to turn\n     \"///\" into \"/\".  */\n  if (! *base)\n    base = file;\n  base_lim = base + base_len (base);\n  had_slash = (*base_lim != '\\0');\n  *base_lim = '\\0';\n  return had_slash;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "bool"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/strncasecmp.c": {
    "strncasecmp": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "int\nstrncasecmp (const char *s1, const char *s2, size_t n)\n{\n  register const unsigned char *p1 = (const unsigned char *) s1;\n  register const unsigned char *p2 = (const unsigned char *) s2;\n  unsigned char c1, c2;\n\n  if (p1 == p2 || n == 0)\n    return 0;\n\n  do\n    {\n      c1 = TOLOWER (*p1);\n      c2 = TOLOWER (*p2);\n\n      if (--n == 0 || c1 == '\\0')\n        break;\n\n      ++p1;\n      ++p2;\n    }\n  while (c1 == c2);\n\n  if (UCHAR_MAX <= INT_MAX)\n    return c1 - c2;\n  else\n    /* On machines where 'char' and 'int' are types of the same size, the\n       difference of two 'unsigned char' values - including the sign bit -\n       doesn't fit in an 'int'.  */\n    return (c1 > c2 ? 1 : c1 < c2 ? -1 : 0);\n}",
      "lines": 31,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/strndup.c": {
    "strndup": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        35,
        1
      ],
      "content": "char *\nstrndup (char const *s, size_t n)\n{\n  size_t len = strnlen (s, n);\n  char *new = malloc (len + 1);\n\n  if (new == NULL)\n    return NULL;\n\n  new[len] = '\\0';\n  return memcpy (new, s, len);\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "char",
        "*\nstrndup (char const *s, size_t n)",
        "*"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/strnlen.c": {
    "strnlen": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        29,
        1
      ],
      "content": "size_t\nstrnlen (const char *string, size_t maxlen)\n{\n  const char *end = memchr (string, '\\0', maxlen);\n  return end ? (size_t) (end - string) : maxlen;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "size_t"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/strnlen1.c": {
    "strnlen1": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        34,
        1
      ],
      "content": "size_t\nstrnlen1 (const char *string, size_t maxlen)\n{\n  const char *end = (const char *) memchr (string, '\\0', maxlen);\n  if (end != NULL)\n    return end - string + 1;\n  else\n    return maxlen;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "size_t"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/strnlen1.h": {},
  "findutils/findutils-4.6.0/gl/lib/strstr.c": {
    "strstr": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "char *\nstrstr (const char *haystack_start, const char *needle_start)\n{\n  const char *haystack = haystack_start;\n  const char *needle = needle_start;\n  size_t needle_len; /* Length of NEEDLE.  */\n  size_t haystack_len; /* Known minimum length of HAYSTACK.  */\n  bool ok = true; /* True if NEEDLE is prefix of HAYSTACK.  */\n\n  /* Determine length of NEEDLE, and in the process, make sure\n     HAYSTACK is at least as long (no point processing all of a long\n     NEEDLE if HAYSTACK is too short).  */\n  while (*haystack && *needle)\n    ok &= *haystack++ == *needle++;\n  if (*needle)\n    return NULL;\n  if (ok)\n    return (char *) haystack_start;\n\n  /* Reduce the size of haystack using strchr, since it has a smaller\n     linear coefficient than the Two-Way algorithm.  */\n  needle_len = needle - needle_start;\n  haystack = strchr (haystack_start + 1, *needle_start);\n  if (!haystack || __builtin_expect (needle_len == 1, 0))\n    return (char *) haystack;\n  needle -= needle_len;\n  haystack_len = (haystack > haystack_start + needle_len ? 1\n                  : needle_len + haystack_start - haystack);\n\n  /* Perform the search.  Abstract memory is considered to be an array\n     of 'unsigned char' values, not an array of 'char' values.  See\n     ISO C 99 section 6.2.6.1.  */\n  if (needle_len < LONG_NEEDLE_THRESHOLD)\n    return two_way_short_needle ((const unsigned char *) haystack,\n                                 haystack_len,\n                                 (const unsigned char *) needle, needle_len);\n  return two_way_long_needle ((const unsigned char *) haystack, haystack_len,\n                              (const unsigned char *) needle, needle_len);\n}",
      "lines": 39,
      "depth": 10,
      "decorators": [
        "char",
        "*\nstrstr (const char *haystack_start, const char *needle_start)",
        "*"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/strtoimax.c": {
    "Strtoimax": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        81,
        1
      ],
      "content": "Int\nStrtoimax (char const *ptr, char **endptr, int base)\n{\n#if Have_long_long\n  verify (sizeof (Int) == sizeof (Unsigned long int)\n          || sizeof (Int) == sizeof (Unsigned long long int));\n\n  if (sizeof (Int) != sizeof (Unsigned long int))\n    return Strtoll (ptr, endptr, base);\n#else\n  verify (sizeof (Int) == sizeof (Unsigned long int));\n#endif\n\n  return Strtol (ptr, endptr, base);\n}",
      "lines": 15,
      "depth": 12,
      "decorators": [
        "Int"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/strtol.c": {
    "INTERNAL": {
      "start_point": [
        236,
        0
      ],
      "end_point": [
        419,
        1
      ],
      "content": "INT\nINTERNAL (strtol) (const STRING_TYPE *nptr, STRING_TYPE **endptr,\n                   int base, int group LOCALE_PARAM_PROTO)\n{\n  int negative;\n  register unsigned LONG int cutoff;\n  register unsigned int cutlim;\n  register unsigned LONG int i;\n  register const STRING_TYPE *s;\n  register UCHAR_TYPE c;\n  const STRING_TYPE *save, *end;\n  int overflow;\n\n#ifdef USE_NUMBER_GROUPING\n# ifdef USE_IN_EXTENDED_LOCALE_MODEL\n  struct locale_data *current = loc->__locales[LC_NUMERIC];\n# endif\n  /* The thousands character of the current locale.  */\n  wchar_t thousands = L'\\0';\n  /* The numeric grouping specification of the current locale,\n     in the format described in <locale.h>.  */\n  const char *grouping;\n\n  if (group)\n    {\n      grouping = _NL_CURRENT (LC_NUMERIC, GROUPING);\n      if (*grouping <= 0 || *grouping == CHAR_MAX)\n        grouping = NULL;\n      else\n        {\n          /* Figure out the thousands separator character.  */\n# if defined _LIBC || defined _HAVE_BTOWC\n          thousands = __btowc (*_NL_CURRENT (LC_NUMERIC, THOUSANDS_SEP));\n          if (thousands == WEOF)\n            thousands = L'\\0';\n# endif\n          if (thousands == L'\\0')\n            grouping = NULL;\n        }\n    }\n  else\n    grouping = NULL;\n#endif\n\n  if (base < 0 || base == 1 || base > 36)\n    {\n      __set_errno (EINVAL);\n      return 0;\n    }\n\n  save = s = nptr;\n\n  /* Skip white space.  */\n  while (ISSPACE (*s))\n    ++s;\n  if (*s == L_('\\0'))\n    goto noconv;\n\n  /* Check for a sign.  */\n  if (*s == L_('-'))\n    {\n      negative = 1;\n      ++s;\n    }\n  else if (*s == L_('+'))\n    {\n      negative = 0;\n      ++s;\n    }\n  else\n    negative = 0;\n\n  /* Recognize number prefix and if BASE is zero, figure it out ourselves.  */\n  if (*s == L_('0'))\n    {\n      if ((base == 0 || base == 16) && TOUPPER (s[1]) == L_('X'))\n        {\n          s += 2;\n          base = 16;\n        }\n      else if (base == 0)\n        base = 8;\n    }\n  else if (base == 0)\n    base = 10;\n\n  /* Save the pointer so we can check later if anything happened.  */\n  save = s;\n\n#ifdef USE_NUMBER_GROUPING\n  if (group)\n    {\n      /* Find the end of the digit string and check its grouping.  */\n      end = s;\n      for (c = *end; c != L_('\\0'); c = *++end)\n        if ((wchar_t) c != thousands\n            && ((wchar_t) c < L_('0') || (wchar_t) c > L_('9'))\n            && (!ISALPHA (c) || (int) (TOUPPER (c) - L_('A') + 10) >= base))\n          break;\n      if (*s == thousands)\n        end = s;\n      else\n        end = correctly_grouped_prefix (s, end, thousands, grouping);\n    }\n  else\n#endif\n    end = NULL;\n\n  cutoff = STRTOL_ULONG_MAX / (unsigned LONG int) base;\n  cutlim = STRTOL_ULONG_MAX % (unsigned LONG int) base;\n\n  overflow = 0;\n  i = 0;\n  for (c = *s; c != L_('\\0'); c = *++s)\n    {\n      if (s == end)\n        break;\n      if (c >= L_('0') && c <= L_('9'))\n        c -= L_('0');\n      else if (ISALPHA (c))\n        c = TOUPPER (c) - L_('A') + 10;\n      else\n        break;\n      if ((int) c >= base)\n        break;\n      /* Check for overflow.  */\n      if (i > cutoff || (i == cutoff && c > cutlim))\n        overflow = 1;\n      else\n        {\n          i *= (unsigned LONG int) base;\n          i += c;\n        }\n    }\n\n  /* Check if anything actually happened.  */\n  if (s == save)\n    goto noconv;\n\n  /* Store in ENDPTR the address of one character\n     past the last character we converted.  */\n  if (endptr != NULL)\n    *endptr = (STRING_TYPE *) s;\n\n#if !UNSIGNED\n  /* Check for a value that is within the range of\n     'unsigned LONG int', but outside the range of 'LONG int'.  */\n  if (overflow == 0\n      && i > (negative\n              ? -((unsigned LONG int) (STRTOL_LONG_MIN + 1)) + 1\n              : (unsigned LONG int) STRTOL_LONG_MAX))\n    overflow = 1;\n#endif\n\n  if (overflow)\n    {\n      __set_errno (ERANGE);\n#if UNSIGNED\n      return STRTOL_ULONG_MAX;\n#else\n      return negative ? STRTOL_LONG_MIN : STRTOL_LONG_MAX;\n#endif\n    }\n\n  /* Return the result of the appropriate sign.  */\n  return negative ? -i : i;\n\nnoconv:\n  /* We must handle a special case here: the base is 0 or 16 and the\n     first two characters are '0' and 'x', but the rest are no\n     hexadecimal digits.  This is no error case.  We return 0 and\n     ENDPTR points to the 'x'.  */\n  if (endptr != NULL)\n    {\n      if (save - nptr >= 2 && TOUPPER (save[-1]) == L_('X')\n          && save[-2] == L_('0'))\n        *endptr = (STRING_TYPE *) &save[-1];\n      else\n        /*  There was no number to convert.  */\n        *endptr = (STRING_TYPE *) nptr;\n    }\n\n  return 0L;\n}",
      "lines": 184,
      "depth": 20,
      "decorators": [
        "INT"
      ]
    },
    "strtol": {
      "start_point": [
        426,
        0
      ],
      "end_point": [
        432,
        1
      ],
      "content": "weak_function\n#endif\nstrtol (const STRING_TYPE *nptr, STRING_TYPE **endptr,\n        int base LOCALE_PARAM_PROTO)\n{\n  return INTERNAL (strtol) (nptr, endptr, base, 0 LOCALE_PARAM);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "weak_function",
        "#endif",
        "#endif"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/strtoul.c": {},
  "findutils/findutils-4.6.0/gl/lib/strtoull.c": {},
  "findutils/findutils-4.6.0/gl/lib/strtoumax.c": {},
  "findutils/findutils-4.6.0/gl/lib/sys_socket.c": {},
  "findutils/findutils-4.6.0/gl/lib/sys_socket.in.h": {
    "rpl_fd_isset": {
      "start_point": [
        211,
        0
      ],
      "end_point": [
        223,
        1
      ],
      "content": "_GL_SYS_SOCKET_INLINE int\nrpl_fd_isset (SOCKET fd, fd_set * set)\n{\n  u_int i;\n  if (set == NULL)\n    return 0;\n\n  for (i = 0; i < set->fd_count; i++)\n    if (set->fd_array[i] == fd)\n      return 1;\n\n  return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "_GL_SYS_SOCKET_INLINE",
        "int",
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/sys_stat.in.h": {
    "rpl_mkdir": {
      "start_point": [
        503,
        0
      ],
      "end_point": [
        507,
        1
      ],
      "content": "static int\nrpl_mkdir (char const *name, mode_t mode)\n{\n  return _mkdir (name);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/sys_time.in.h": {},
  "findutils/findutils-4.6.0/gl/lib/sys_types.in.h": {},
  "findutils/findutils-4.6.0/gl/lib/sys_uio.in.h": {},
  "findutils/findutils-4.6.0/gl/lib/sys_utsname.in.h": {},
  "findutils/findutils-4.6.0/gl/lib/sys_wait.in.h": {},
  "findutils/findutils-4.6.0/gl/lib/time-internal.h": {},
  "findutils/findutils-4.6.0/gl/lib/time.in.h": {},
  "findutils/findutils-4.6.0/gl/lib/timegm.c": {
    "timegm": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "time_t\ntimegm (struct tm *tmp)\n{\n  static time_t gmtime_offset;\n  tmp->tm_isdst = 0;\n  return __mktime_internal (tmp, __gmtime_r, &gmtime_offset);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "time_t"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/timespec.c": {},
  "findutils/findutils-4.6.0/gl/lib/timespec.h": {
    "make_timespec": {
      "start_point": [
        39,
        27
      ],
      "end_point": [
        46,
        1
      ],
      "content": "timespec\nmake_timespec (time_t s, long int ns)\n{\n  struct timespec r;\n  r.tv_sec = s;\n  r.tv_nsec = ns;\n  return r;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "timespec"
      ]
    },
    "timespec_cmp": {
      "start_point": [
        76,
        24
      ],
      "end_point": [
        82,
        1
      ],
      "content": "_GL_ATTRIBUTE_PURE\ntimespec_cmp (struct timespec a, struct timespec b)\n{\n  return (a.tv_sec < b.tv_sec ? -1\n          : a.tv_sec > b.tv_sec ? 1\n          : (int) (a.tv_nsec - b.tv_nsec));\n}",
      "lines": 7,
      "depth": 11,
      "decorators": [
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "timespec_sign": {
      "start_point": [
        86,
        24
      ],
      "end_point": [
        90,
        1
      ],
      "content": "_GL_ATTRIBUTE_PURE\ntimespec_sign (struct timespec a)\n{\n  return a.tv_sec < 0 ? -1 : a.tv_sec || a.tv_nsec;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "timespectod": {
      "start_point": [
        100,
        0
      ],
      "end_point": [
        104,
        1
      ],
      "content": "_GL_TIMESPEC_INLINE double\ntimespectod (struct timespec a)\n{\n  return a.tv_sec + a.tv_nsec / 1e9;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "_GL_TIMESPEC_INLINE",
        "double",
        "double"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/time_r.c": {
    "copy_tm_result": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        30,
        1
      ],
      "content": "static struct tm *\ncopy_tm_result (struct tm *dest, struct tm const *src)\n{\n  if (! src)\n    return 0;\n  *dest = *src;\n  return dest;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "struct tm",
        "struct",
        "tm",
        "*\ncopy_tm_result (struct tm *dest, struct tm const *src)",
        "*"
      ]
    },
    "gmtime_r": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "struct tm *\ngmtime_r (time_t const * restrict t, struct tm * restrict tp)\n{\n  return copy_tm_result (tp, gmtime (t));\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "struct tm",
        "struct",
        "tm",
        "*\ngmtime_r (time_t const * restrict t, struct tm * restrict tp)",
        "*"
      ]
    },
    "localtime_r": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "struct tm *\nlocaltime_r (time_t const * restrict t, struct tm * restrict tp)\n{\n  return copy_tm_result (tp, localtime (t));\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "struct tm",
        "struct",
        "tm",
        "*\nlocaltime_r (time_t const * restrict t, struct tm * restrict tp)",
        "*"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/time_rz.c": {
    "tzset": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        37,
        28
      ],
      "content": "static void tzset (void) { }",
      "lines": 1,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "isdst_differ": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "static bool\nisdst_differ (int a, int b)\n{\n  return !a != !b && 0 <= a && 0 <= b;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "equal_tm": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "static int\nequal_tm (const struct tm *a, const struct tm *b)\n{\n  return ! ((a->tm_sec ^ b->tm_sec)\n            | (a->tm_min ^ b->tm_min)\n            | (a->tm_hour ^ b->tm_hour)\n            | (a->tm_mday ^ b->tm_mday)\n            | (a->tm_mon ^ b->tm_mon)\n            | (a->tm_year ^ b->tm_year)\n            | isdst_differ (a->tm_isdst, b->tm_isdst));\n}",
      "lines": 11,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "extend_abbrs": {
      "start_point": [
        84,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "static void\nextend_abbrs (char *abbrs, char const *abbr, size_t abbr_size)\n{\n  memcpy (abbrs, abbr, abbr_size);\n  abbrs[abbr_size] = '\\0';\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "tzalloc": {
      "start_point": [
        93,
        0
      ],
      "end_point": [
        111,
        1
      ],
      "content": "timezone_t\ntzalloc (char const *name)\n{\n  size_t name_size = name ? strlen (name) + 1 : 0;\n  size_t abbr_size = name_size < ABBR_SIZE_MIN ? ABBR_SIZE_MIN : name_size + 1;\n  timezone_t tz = malloc (offsetof (struct tm_zone, abbrs) + abbr_size);\n  if (tz)\n    {\n      tz->next = NULL;\n#if HAVE_TZNAME && !HAVE_TM_ZONE\n      tz->tzname_copy[0] = tz->tzname_copy[1] = NULL;\n#endif\n      tz->tz_is_set = !!name;\n      tz->abbrs[0] = '\\0';\n      if (name)\n        extend_abbrs (tz->abbrs, name, name_size);\n    }\n  return tz;\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "timezone_t"
      ]
    },
    "save_abbr": {
      "start_point": [
        117,
        0
      ],
      "end_point": [
        185,
        1
      ],
      "content": "static bool\nsave_abbr (timezone_t tz, struct tm *tm)\n{\n#if HAVE_TM_ZONE || HAVE_TZNAME\n  char const *zone = NULL;\n  char *zone_copy = (char *) \"\";\n\n# if HAVE_TZNAME\n  int tzname_index = -1;\n# endif\n\n# if HAVE_TM_ZONE\n  zone = tm->tm_zone;\n# endif\n\n# if HAVE_TZNAME\n  if (! (zone && *zone) && 0 <= tm->tm_isdst)\n    {\n      tzname_index = tm->tm_isdst != 0;\n      zone = tzname[tzname_index];\n    }\n# endif\n\n  /* No need to replace null zones, or zones within the struct tm.  */\n  if (!zone || ((char *) tm <= zone && zone < (char *) (tm + 1)))\n    return true;\n\n  if (*zone)\n    {\n      zone_copy = tz->abbrs;\n\n      while (strcmp (zone_copy, zone) != 0)\n        {\n          if (! (*zone_copy || (zone_copy == tz->abbrs && tz->tz_is_set)))\n            {\n              size_t zone_size = strlen (zone) + 1;\n              if (zone_size < tz->abbrs + ABBR_SIZE_MIN - zone_copy)\n                extend_abbrs (zone_copy, zone, zone_size);\n              else\n                {\n                  tz = tz->next = tzalloc (zone);\n                  if (!tz)\n                    return false;\n                  tz->tz_is_set = 0;\n                  zone_copy = tz->abbrs;\n                }\n              break;\n            }\n\n          zone_copy += strlen (zone_copy) + 1;\n          if (!*zone_copy && tz->next)\n            {\n              tz = tz->next;\n              zone_copy = tz->abbrs;\n            }\n        }\n    }\n\n  /* Replace the zone name so that its lifetime matches that of TZ.  */\n# if HAVE_TM_ZONE\n  tm->tm_zone = zone_copy;\n# else\n  if (0 <= tzname_index)\n    tz->tzname_copy[tzname_index] = zone_copy;\n# endif\n#endif\n\n  return true;\n}",
      "lines": 69,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "tzfree": {
      "start_point": [
        188,
        0
      ],
      "end_point": [
        198,
        1
      ],
      "content": "void\ntzfree (timezone_t tz)\n{\n  if (tz != local_tz)\n    while (tz)\n      {\n        timezone_t next = tz->next;\n        free (tz);\n        tz = next;\n      }\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "getenv_TZ": {
      "start_point": [
        204,
        0
      ],
      "end_point": [
        208,
        1
      ],
      "content": "static char *\ngetenv_TZ (void)\n{\n  return getenv (TZ);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "char",
        "*\ngetenv_TZ (void)",
        "*"
      ]
    },
    "setenv_TZ": {
      "start_point": [
        212,
        0
      ],
      "end_point": [
        216,
        1
      ],
      "content": "static int\nsetenv_TZ (char const *tz)\n{\n  return tz ? setenv (TZ, tz, 1) : unsetenv (TZ);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "change_env": {
      "start_point": [
        221,
        0
      ],
      "end_point": [
        228,
        1
      ],
      "content": "static bool\nchange_env (timezone_t tz)\n{\n  if (setenv_TZ (tz->tz_is_set ? tz->abbrs : NULL) != 0)\n    return false;\n  tzset ();\n  return true;\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "set_tz": {
      "start_point": [
        234,
        0
      ],
      "end_point": [
        256,
        1
      ],
      "content": "static timezone_t\nset_tz (timezone_t tz)\n{\n  char *env_tz = getenv_TZ ();\n  if (env_tz\n      ? tz->tz_is_set && strcmp (tz->abbrs, env_tz) == 0\n      : !tz->tz_is_set)\n    return local_tz;\n  else\n    {\n      timezone_t old_tz = tzalloc (env_tz);\n      if (!old_tz)\n        return old_tz;\n      if (! change_env (tz))\n        {\n          int saved_errno = errno;\n          tzfree (old_tz);\n          errno = saved_errno;\n          return NULL;\n        }\n      return old_tz;\n    }\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "timezone_t"
      ]
    },
    "revert_tz": {
      "start_point": [
        261,
        0
      ],
      "end_point": [
        276,
        1
      ],
      "content": "static bool\nrevert_tz (timezone_t tz)\n{\n  if (tz == local_tz)\n    return true;\n  else\n    {\n      int saved_errno = errno;\n      bool ok = change_env (tz);\n      if (!ok)\n        saved_errno = errno;\n      tzfree (tz);\n      errno = saved_errno;\n      return ok;\n    }\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "localtime_rz": {
      "start_point": [
        279,
        0
      ],
      "end_point": [
        295,
        1
      ],
      "content": "struct tm *\nlocaltime_rz (timezone_t tz, time_t const *t, struct tm *tm)\n{\n  if (!tz)\n    return gmtime_r (t, tm);\n  else\n    {\n      timezone_t old_tz = set_tz (tz);\n      if (old_tz)\n        {\n          bool abbr_saved = localtime_r (t, tm) && save_abbr (tz, tm);\n          if (revert_tz (old_tz) && abbr_saved)\n            return tm;\n        }\n      return NULL;\n    }\n}",
      "lines": 17,
      "depth": 12,
      "decorators": [
        "struct tm",
        "struct",
        "tm",
        "*\nlocaltime_rz (timezone_t tz, time_t const *t, struct tm *tm)",
        "*"
      ]
    },
    "mktime_z": {
      "start_point": [
        298,
        0
      ],
      "end_point": [
        322,
        1
      ],
      "content": "time_t\nmktime_z (timezone_t tz, struct tm *tm)\n{\n  if (!tz)\n    return timegm (tm);\n  else\n    {\n      timezone_t old_tz = set_tz (tz);\n      if (old_tz)\n        {\n          time_t t = mktime (tm);\n#if HAVE_TM_ZONE || HAVE_TZNAME\n          time_t badtime = -1;\n          struct tm tm_1;\n          if ((t != badtime\n               || (localtime_r (&t, &tm_1) && equal_tm (tm, &tm_1)))\n              && !save_abbr (tz, tm))\n            t = badtime;\n#endif\n          if (revert_tz (old_tz))\n            return t;\n        }\n      return -1;\n    }\n}",
      "lines": 25,
      "depth": 18,
      "decorators": [
        "time_t"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/trunc.c": {
    "FUNC": {
      "start_point": [
        73,
        0
      ],
      "end_point": [
        120,
        1
      ],
      "content": "DOUBLE\nFUNC (DOUBLE x)\n{\n  /* The use of 'volatile' guarantees that excess precision bits are dropped\n     at each addition step and before the following comparison at the caller's\n     site.  It is necessary on x86 systems where double-floats are not IEEE\n     compliant by default, to avoid that the results become platform and compiler\n     option dependent.  'volatile' is a portable alternative to gcc's\n     -ffloat-store option.  */\n  volatile DOUBLE y = x;\n  volatile DOUBLE z = y;\n\n  if (z > L_(0.0))\n    {\n      /* For 0 < x < 1, return +0.0 even if the current rounding mode is\n         FE_DOWNWARD.  */\n      if (z < L_(1.0))\n        z = L_(0.0);\n      /* Avoid rounding errors for values near 2^k, where k >= MANT_DIG-1.  */\n      else if (z < TWO_MANT_DIG)\n        {\n          /* Round to the next integer (nearest or up or down, doesn't matter).  */\n          z += TWO_MANT_DIG;\n          z -= TWO_MANT_DIG;\n          /* Enforce rounding down.  */\n          if (z > y)\n            z -= L_(1.0);\n        }\n    }\n  else if (z < L_(0.0))\n    {\n      /* For -1 < x < 0, return -0.0 regardless of the current rounding\n         mode.  */\n      if (z > L_(-1.0))\n        z = MINUS_ZERO;\n      /* Avoid rounding errors for values near -2^k, where k >= MANT_DIG-1.  */\n      else if (z > - TWO_MANT_DIG)\n        {\n          /* Round to the next integer (nearest or up or down, doesn't matter).  */\n          z -= TWO_MANT_DIG;\n          z += TWO_MANT_DIG;\n          /* Enforce rounding up.  */\n          if (z < y)\n            z += L_(1.0);\n        }\n    }\n  return z;\n}",
      "lines": 48,
      "depth": 14,
      "decorators": [
        "DOUBLE"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/uname.c": {
    "uname": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        265,
        1
      ],
      "content": "int\nuname (struct utsname *buf)\n{\n  OSVERSIONINFO version;\n  OSVERSIONINFOEX versionex;\n  BOOL have_versionex; /* indicates whether versionex is filled */\n  const char *super_version;\n\n  /* Preparation: Fill version and, if possible, also versionex.\n     But try to call GetVersionEx only once in the common case.  */\n  versionex.dwOSVersionInfoSize = sizeof (OSVERSIONINFOEX);\n  have_versionex = GetVersionEx ((OSVERSIONINFO *) &versionex);\n  if (have_versionex)\n    {\n      /* We know that OSVERSIONINFO is a subset of OSVERSIONINFOEX.  */\n      memcpy (&version, &versionex, sizeof (OSVERSIONINFO));\n    }\n  else\n    {\n      version.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);\n      if (!GetVersionEx (&version))\n        abort ();\n    }\n\n  /* Fill in nodename.  */\n  if (gethostname (buf->nodename, sizeof (buf->nodename)) < 0)\n    strcpy (buf->nodename, \"localhost\");\n\n  /* Determine major-major Windows version.  */\n  if (version.dwPlatformId == VER_PLATFORM_WIN32_NT)\n    {\n      /* Windows NT or newer.  */\n      super_version = \"NT\";\n    }\n  else if (version.dwPlatformId == VER_PLATFORM_WIN32_CE)\n    {\n      /* Windows CE or Embedded CE.  */\n      super_version = \"CE\";\n    }\n  else if (version.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)\n    {\n      /* Windows 95/98/ME.  */\n      switch (version.dwMinorVersion)\n        {\n        case 0:\n          super_version = \"95\";\n          break;\n        case 10:\n          super_version = \"98\";\n          break;\n        case 90:\n          super_version = \"ME\";\n          break;\n        default:\n          super_version = \"\";\n          break;\n        }\n    }\n  else\n    super_version = \"\";\n\n  /* Fill in sysname.  */\n#ifdef __MINGW32__\n  /* Returns a string compatible with the MSYS uname.exe program,\n     so that no further changes are needed to GNU config.guess.\n     For example,\n       $ ./uname.exe -s      => MINGW32_NT-5.1\n   */\n  sprintf (buf->sysname, \"MINGW32_%s-%u.%u\", super_version,\n           (unsigned int) version.dwMajorVersion,\n           (unsigned int) version.dwMinorVersion);\n#else\n  sprintf (buf->sysname, \"Windows%s\", super_version);\n#endif\n\n  /* Fill in release, version.  */\n  /* The MSYS uname.exe programs uses strings from a modified Cygwin runtime:\n       $ ./uname.exe -r      => 1.0.11(0.46/3/2)\n       $ ./uname.exe -v      => 2008-08-25 23:40\n     There is no point in imitating this behaviour.  */\n  if (version.dwPlatformId == VER_PLATFORM_WIN32_NT)\n    {\n      /* Windows NT or newer.  */\n      struct windows_version\n        {\n          int major;\n          int minor;\n          unsigned int server_offset;\n          const char *name;\n        };\n\n      /* Storing the workstation and server version names in a single\n         stream does not waste memory when they are the same.  These\n         macros abstract the representation.  VERSION1 is used if\n         version.wProductType does not matter, VERSION2 if it does.  */\n      #define VERSION1(major, minor, name) \\\n        { major, minor, 0, name }\n      #define VERSION2(major, minor, workstation, server) \\\n        { major, minor, sizeof workstation, workstation \"\\0\" server }\n      static const struct windows_version versions[] =\n        {\n          VERSION2 (3, -1, \"Windows NT Workstation\", \"Windows NT Server\"),\n          VERSION2 (4, -1, \"Windows NT Workstation\", \"Windows NT Server\"),\n          VERSION1 (5, 0, \"Windows 2000\"),\n          VERSION1 (5, 1, \"Windows XP\"),\n          VERSION1 (5, 2, \"Windows Server 2003\"),\n          VERSION2 (6, 0, \"Windows Vista\", \"Windows Server 2008\"),\n          VERSION2 (6, 1, \"Windows 7\", \"Windows Server 2008 R2\"),\n          VERSION2 (-1, -1, \"Windows\", \"Windows Server\")\n        };\n      const char *base;\n      const struct windows_version *v = versions;\n\n      /* Find a version that matches ours.  The last element is a\n         wildcard that always ends the loop.  */\n      while ((v->major != version.dwMajorVersion && v->major != -1)\n             || (v->minor != version.dwMinorVersion && v->minor != -1))\n        v++;\n\n      if (have_versionex && versionex.wProductType != VER_NT_WORKSTATION)\n        base = v->name + v->server_offset;\n      else\n        base = v->name;\n      if (v->major == -1 || v->minor == -1)\n        sprintf (buf->release, \"%s %u.%u\",\n                 base,\n                 (unsigned int) version.dwMajorVersion,\n                 (unsigned int) version.dwMinorVersion);\n      else\n        strcpy (buf->release, base);\n    }\n  else if (version.dwPlatformId == VER_PLATFORM_WIN32_CE)\n    {\n      /* Windows CE or Embedded CE.  */\n      sprintf (buf->release, \"Windows CE %u.%u\",\n               (unsigned int) version.dwMajorVersion,\n               (unsigned int) version.dwMinorVersion);\n    }\n  else\n    {\n      /* Windows 95/98/ME.  */\n      sprintf (buf->release, \"Windows %s\", super_version);\n    }\n  strcpy (buf->version, version.szCSDVersion);\n\n  /* Fill in machine.  */\n  {\n    SYSTEM_INFO info;\n\n    GetSystemInfo (&info);\n    /* Check for Windows NT or CE, since the info.wProcessorLevel is\n       garbage on Windows 95. */\n    if (version.dwPlatformId == VER_PLATFORM_WIN32_NT\n        || version.dwPlatformId == VER_PLATFORM_WIN32_CE)\n      {\n        /* Windows NT or newer, or Windows CE or Embedded CE.  */\n        switch (info.wProcessorArchitecture)\n          {\n          case PROCESSOR_ARCHITECTURE_AMD64:\n            strcpy (buf->machine, \"x86_64\");\n            break;\n          case PROCESSOR_ARCHITECTURE_IA64:\n            strcpy (buf->machine, \"ia64\");\n            break;\n          case PROCESSOR_ARCHITECTURE_INTEL:\n            strcpy (buf->machine, \"i386\");\n            if (info.wProcessorLevel >= 3)\n              buf->machine[1] =\n                '0' + (info.wProcessorLevel <= 6 ? info.wProcessorLevel : 6);\n            break;\n          case PROCESSOR_ARCHITECTURE_IA32_ON_WIN64:\n            strcpy (buf->machine, \"i686\");\n            break;\n          case PROCESSOR_ARCHITECTURE_MIPS:\n            strcpy (buf->machine, \"mips\");\n            break;\n          case PROCESSOR_ARCHITECTURE_ALPHA:\n          case PROCESSOR_ARCHITECTURE_ALPHA64:\n            strcpy (buf->machine, \"alpha\");\n            break;\n          case PROCESSOR_ARCHITECTURE_PPC:\n            strcpy (buf->machine, \"powerpc\");\n            break;\n          case PROCESSOR_ARCHITECTURE_SHX:\n            strcpy (buf->machine, \"sh\");\n            break;\n          case PROCESSOR_ARCHITECTURE_ARM:\n            strcpy (buf->machine, \"arm\");\n            break;\n          default:\n            strcpy (buf->machine, \"unknown\");\n            break;\n          }\n      }\n    else\n      {\n        /* Windows 95/98/ME.  */\n        switch (info.dwProcessorType)\n          {\n          case PROCESSOR_AMD_X8664:\n            strcpy (buf->machine, \"x86_64\");\n            break;\n          case PROCESSOR_INTEL_IA64:\n            strcpy (buf->machine, \"ia64\");\n            break;\n          default:\n            if (info.dwProcessorType % 100 == 86)\n              sprintf (buf->machine, \"i%u\",\n                       (unsigned int) info.dwProcessorType);\n            else\n              strcpy (buf->machine, \"unknown\");\n            break;\n          }\n      }\n  }\n\n  return 0;\n}",
      "lines": 218,
      "depth": 17,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/unistd--.h": {},
  "findutils/findutils-4.6.0/gl/lib/unistd-safer.h": {},
  "findutils/findutils-4.6.0/gl/lib/unistd.c": {},
  "findutils/findutils-4.6.0/gl/lib/unistd.in.h": {
    "rpl_environ": {
      "start_point": [
        423,
        0
      ],
      "end_point": [
        427,
        1
      ],
      "content": "_GL_UNISTD_INLINE char ***\nrpl_environ (void)\n{\n  return &environ;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "_GL_UNISTD_INLINE",
        "char",
        "char",
        "***\nrpl_environ (void)",
        "*",
        "**\nrpl_environ (void)",
        "*",
        "*\nrpl_environ (void)",
        "*"
      ]
    },
    "getpagesize": {
      "start_point": [
        890,
        0
      ],
      "end_point": [
        894,
        1
      ],
      "content": "_GL_UNISTD_INLINE int\ngetpagesize ()\n{\n  return _gl_getpagesize ();\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "_GL_UNISTD_INLINE",
        "int",
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/unitypes.in.h": {},
  "findutils/findutils-4.6.0/gl/lib/uniwidth.in.h": {},
  "findutils/findutils-4.6.0/gl/lib/unlink.c": {
    "rpl_unlink": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        96,
        1
      ],
      "content": "int\nrpl_unlink (char const *name)\n{\n  /* Work around Solaris 9 bug where unlink(\"file/\") succeeds.  */\n  size_t len = strlen (name);\n  int result = 0;\n  if (len && ISSLASH (name[len - 1]))\n    {\n      /* We can't unlink(2) something if it doesn't exist.  If it does\n         exist, then it resolved to a directory, due to the trailing\n         slash, and POSIX requires that the unlink attempt to remove\n         that directory (which would leave the symlink dangling).\n         Unfortunately, Solaris 9 is one of the platforms where the\n         root user can unlink directories, and we don't want to\n         cripple this behavior on real directories, even if it is\n         seldom needed (at any rate, it's nicer to let coreutils'\n         unlink(1) give the correct errno for non-root users).  But we\n         don't know whether name was an actual directory, or a symlink\n         to a directory; and due to the bug of ignoring trailing\n         slash, Solaris 9 would end up successfully unlinking the\n         symlink instead of the directory.  Technically, we could use\n         realpath to find the canonical directory name to attempt\n         deletion on.  But that is a lot of work for a corner case; so\n         we instead just use an lstat on the shortened name, and\n         reject symlinks with trailing slashes.  The root user of\n         unlink(1) will just have to live with the rule that they\n         can't delete a directory via a symlink.  */\n      struct stat st;\n      result = lstat (name, &st);\n      if (result == 0)\n        {\n          /* Trailing NUL will overwrite the trailing slash.  */\n          char *short_name = malloc (len);\n          if (!short_name)\n            {\n              errno = EPERM;\n              return -1;\n            }\n          memcpy (short_name, name, len);\n          while (len && ISSLASH (short_name[len - 1]))\n            short_name[--len] = '\\0';\n          if (len && (lstat (short_name, &st) || S_ISLNK (st.st_mode)))\n            {\n              free (short_name);\n              errno = EPERM;\n              return -1;\n            }\n          free (short_name);\n        }\n    }\n  if (!result)\n    {\n#if UNLINK_PARENT_BUG\n      if (len >= 2 && name[len - 1] == '.' && name[len - 2] == '.'\n          && (len == 2 || ISSLASH (name[len - 3])))\n        {\n          errno = EISDIR; /* could also use EPERM */\n          return -1;\n        }\n#endif\n      result = unlink (name);\n    }\n  return result;\n}",
      "lines": 64,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/unlinkat.c": {
    "rpl_unlinkat": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        95,
        1
      ],
      "content": "int\nrpl_unlinkat (int fd, char const *name, int flag)\n{\n  size_t len;\n  int result = 0;\n  /* rmdir behavior has no problems with trailing slash.  */\n  if (flag & AT_REMOVEDIR)\n    return unlinkat (fd, name, flag);\n\n  len = strlen (name);\n  if (len && ISSLASH (name[len - 1]))\n    {\n      /* See the lengthy comment in unlink.c why we disobey the POSIX\n         rule of letting unlink(\"link-to-dir/\") attempt to unlink a\n         directory.  */\n      struct stat st;\n      result = lstatat (fd, name, &st);\n      if (result == 0)\n        {\n          /* Trailing NUL will overwrite the trailing slash.  */\n          char *short_name = malloc (len);\n          if (!short_name)\n            {\n              errno = EPERM;\n              return -1;\n            }\n          memcpy (short_name, name, len);\n          while (len && ISSLASH (short_name[len - 1]))\n            short_name[--len] = '\\0';\n          if (len && (lstatat (fd, short_name, &st) || S_ISLNK (st.st_mode)))\n            {\n              free (short_name);\n              errno = EPERM;\n              return -1;\n            }\n          free (short_name);\n        }\n    }\n  if (!result)\n    {\n# if UNLINK_PARENT_BUG\n      if (len >= 2 && name[len - 1] == '.' && name[len - 2] == '.'\n          && (len == 2 || ISSLASH (name[len - 3])))\n        {\n          errno = EISDIR; /* could also use EPERM */\n          return -1;\n        }\n# endif\n      result = unlinkat (fd, name, flag);\n    }\n  return result;\n}",
      "lines": 52,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/unsetenv.c": {
    "unsetenv": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "int\nunsetenv (const char *name)\n{\n  size_t len;\n  char **ep;\n\n  if (name == NULL || *name == '\\0' || strchr (name, '=') != NULL)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  len = strlen (name);\n\n  LOCK;\n\n  ep = __environ;\n  while (*ep != NULL)\n    if (!strncmp (*ep, name, len) && (*ep)[len] == '=')\n      {\n        /* Found it.  Remove this pointer by moving later ones back.  */\n        char **dp = ep;\n\n        do\n          dp[0] = dp[1];\n        while (*dp++);\n        /* Continue the loop in case NAME appears again.  */\n      }\n    else\n      ++ep;\n\n  UNLOCK;\n\n  return 0;\n}",
      "lines": 35,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "rpl_unsetenv": {
      "start_point": [
        109,
        0
      ],
      "end_point": [
        124,
        1
      ],
      "content": "int\nrpl_unsetenv (const char *name)\n{\n  int result = 0;\n  if (!name || !*name || strchr (name, '='))\n    {\n      errno = EINVAL;\n      return -1;\n    }\n  while (getenv (name))\n# if !VOID_UNSETENV\n    result =\n# endif\n      unsetenv (name);\n  return result;\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/vasnprintf.c": {
    "local_strnlen": {
      "start_point": [
        216,
        0
      ],
      "end_point": [
        221,
        1
      ],
      "content": "static size_t\nlocal_strnlen (const char *string, size_t maxlen)\n{\n  const char *end = memchr (string, '\\0', maxlen);\n  return end ? (size_t) (end - string) : maxlen;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "local_wcslen": {
      "start_point": [
        236,
        0
      ],
      "end_point": [
        244,
        1
      ],
      "content": "static size_t\nlocal_wcslen (const wchar_t *s)\n{\n  const wchar_t *ptr;\n\n  for (ptr = s; *ptr != (wchar_t) 0; ptr++)\n    ;\n  return ptr - s;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "local_wcsnlen": {
      "start_point": [
        255,
        0
      ],
      "end_point": [
        263,
        1
      ],
      "content": "static size_t\nlocal_wcsnlen (const wchar_t *s, size_t maxlen)\n{\n  const wchar_t *ptr;\n\n  for (ptr = s; maxlen > 0 && *ptr != (wchar_t) 0; ptr++, maxlen--)\n    ;\n  return ptr - s;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "decimal_point_char": {
      "start_point": [
        272,
        0
      ],
      "end_point": [
        291,
        1
      ],
      "content": "static char\ndecimal_point_char (void)\n{\n  const char *point;\n  /* Determine it in a multithread-safe way.  We know nl_langinfo is\n     multithread-safe on glibc systems and Mac OS X systems, but is not required\n     to be multithread-safe by POSIX.  sprintf(), however, is multithread-safe.\n     localeconv() is rarely multithread-safe.  */\n#  if HAVE_NL_LANGINFO && (__GLIBC__ || defined __UCLIBC__ || (defined __APPLE__ && defined __MACH__))\n  point = nl_langinfo (RADIXCHAR);\n#  elif 1\n  char pointbuf[5];\n  sprintf (pointbuf, \"%#.0f\", 1.0);\n  point = &pointbuf[1];\n#  else\n  point = localeconv () -> decimal_point;\n#  endif\n  /* The decimal point is always a single byte: either '.' or ','.  */\n  return (point[0] != '\\0' ? point[0] : '.');\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "char"
      ]
    },
    "is_infinite_or_zero": {
      "start_point": [
        298,
        0
      ],
      "end_point": [
        302,
        1
      ],
      "content": "static int\nis_infinite_or_zero (double x)\n{\n  return isnand (x) || x + x == x;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "is_infinite_or_zerol": {
      "start_point": [
        309,
        0
      ],
      "end_point": [
        313,
        1
      ],
      "content": "static int\nis_infinite_or_zerol (long double x)\n{\n  return isnanl (x) || x + x == x;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "multiply": {
      "start_point": [
        341,
        0
      ],
      "end_point": [
        404,
        1
      ],
      "content": "static void *\nmultiply (mpn_t src1, mpn_t src2, mpn_t *dest)\n{\n  const mp_limb_t *p1;\n  const mp_limb_t *p2;\n  size_t len1;\n  size_t len2;\n\n  if (src1.nlimbs <= src2.nlimbs)\n    {\n      len1 = src1.nlimbs;\n      p1 = src1.limbs;\n      len2 = src2.nlimbs;\n      p2 = src2.limbs;\n    }\n  else\n    {\n      len1 = src2.nlimbs;\n      p1 = src2.limbs;\n      len2 = src1.nlimbs;\n      p2 = src1.limbs;\n    }\n  /* Now 0 <= len1 <= len2.  */\n  if (len1 == 0)\n    {\n      /* src1 or src2 is zero.  */\n      dest->nlimbs = 0;\n      dest->limbs = (mp_limb_t *) malloc (1);\n    }\n  else\n    {\n      /* Here 1 <= len1 <= len2.  */\n      size_t dlen;\n      mp_limb_t *dp;\n      size_t k, i, j;\n\n      dlen = len1 + len2;\n      dp = (mp_limb_t *) malloc (dlen * sizeof (mp_limb_t));\n      if (dp == NULL)\n        return NULL;\n      for (k = len2; k > 0; )\n        dp[--k] = 0;\n      for (i = 0; i < len1; i++)\n        {\n          mp_limb_t digit1 = p1[i];\n          mp_twolimb_t carry = 0;\n          for (j = 0; j < len2; j++)\n            {\n              mp_limb_t digit2 = p2[j];\n              carry += (mp_twolimb_t) digit1 * (mp_twolimb_t) digit2;\n              carry += dp[i + j];\n              dp[i + j] = (mp_limb_t) carry;\n              carry = carry >> GMP_LIMB_BITS;\n            }\n          dp[i + len2] = (mp_limb_t) carry;\n        }\n      /* Normalise.  */\n      while (dlen > 0 && dp[dlen - 1] == 0)\n        dlen--;\n      dest->nlimbs = dlen;\n      dest->limbs = dp;\n    }\n  return dest->limbs;\n}",
      "lines": 64,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nmultiply (mpn_t src1, mpn_t src2, mpn_t *dest)",
        "*"
      ]
    },
    "divide": {
      "start_point": [
        413,
        0
      ],
      "end_point": [
        836,
        1
      ],
      "content": "static void *\ndivide (mpn_t a, mpn_t b, mpn_t *q)\n{\n  /* Algorithm:\n     First normalise a and b: a=[a[m-1],...,a[0]], b=[b[n-1],...,b[0]]\n     with m>=0 and n>0 (in base beta = 2^GMP_LIMB_BITS).\n     If m<n, then q:=0 and r:=a.\n     If m>=n=1, perform a single-precision division:\n       r:=0, j:=m,\n       while j>0 do\n         {Here (q[m-1]*beta^(m-1)+...+q[j]*beta^j) * b[0] + r*beta^j =\n               = a[m-1]*beta^(m-1)+...+a[j]*beta^j und 0<=r<b[0]<beta}\n         j:=j-1, r:=r*beta+a[j], q[j]:=floor(r/b[0]), r:=r-b[0]*q[j].\n       Normalise [q[m-1],...,q[0]], yields q.\n     If m>=n>1, perform a multiple-precision division:\n       We have a/b < beta^(m-n+1).\n       s:=intDsize-1-(highest bit in b[n-1]), 0<=s<intDsize.\n       Shift a and b left by s bits, copying them. r:=a.\n       r=[r[m],...,r[0]], b=[b[n-1],...,b[0]] with b[n-1]>=beta/2.\n       For j=m-n,...,0: {Here 0 <= r < b*beta^(j+1).}\n         Compute q* :\n           q* := floor((r[j+n]*beta+r[j+n-1])/b[n-1]).\n           In case of overflow (q* >= beta) set q* := beta-1.\n           Compute c2 := ((r[j+n]*beta+r[j+n-1]) - q* * b[n-1])*beta + r[j+n-2]\n           and c3 := b[n-2] * q*.\n           {We have 0 <= c2 < 2*beta^2, even 0 <= c2 < beta^2 if no overflow\n            occurred.  Furthermore 0 <= c3 < beta^2.\n            If there was overflow and\n            r[j+n]*beta+r[j+n-1] - q* * b[n-1] >= beta, i.e. c2 >= beta^2,\n            the next test can be skipped.}\n           While c3 > c2, {Here 0 <= c2 < c3 < beta^2}\n             Put q* := q* - 1, c2 := c2 + b[n-1]*beta, c3 := c3 - b[n-2].\n           If q* > 0:\n             Put r := r - b * q* * beta^j. In detail:\n               [r[n+j],...,r[j]] := [r[n+j],...,r[j]] - q* * [b[n-1],...,b[0]].\n               hence: u:=0, for i:=0 to n-1 do\n                              u := u + q* * b[i],\n                              r[j+i]:=r[j+i]-(u mod beta) (+ beta, if carry),\n                              u:=u div beta (+ 1, if carry in subtraction)\n                      r[n+j]:=r[n+j]-u.\n               {Since always u = (q* * [b[i-1],...,b[0]] div beta^i) + 1\n                               < q* + 1 <= beta,\n                the carry u does not overflow.}\n             If a negative carry occurs, put q* := q* - 1\n               and [r[n+j],...,r[j]] := [r[n+j],...,r[j]] + [0,b[n-1],...,b[0]].\n         Set q[j] := q*.\n       Normalise [q[m-n],..,q[0]]; this yields the quotient q.\n       Shift [r[n-1],...,r[0]] right by s bits and normalise; this yields the\n       rest r.\n       The room for q[j] can be allocated at the memory location of r[n+j].\n     Finally, round-to-even:\n       Shift r left by 1 bit.\n       If r > b or if r = b and q[0] is odd, q := q+1.\n   */\n  const mp_limb_t *a_ptr = a.limbs;\n  size_t a_len = a.nlimbs;\n  const mp_limb_t *b_ptr = b.limbs;\n  size_t b_len = b.nlimbs;\n  mp_limb_t *roomptr;\n  mp_limb_t *tmp_roomptr = NULL;\n  mp_limb_t *q_ptr;\n  size_t q_len;\n  mp_limb_t *r_ptr;\n  size_t r_len;\n\n  /* Allocate room for a_len+2 digits.\n     (Need a_len+1 digits for the real division and 1 more digit for the\n     final rounding of q.)  */\n  roomptr = (mp_limb_t *) malloc ((a_len + 2) * sizeof (mp_limb_t));\n  if (roomptr == NULL)\n    return NULL;\n\n  /* Normalise a.  */\n  while (a_len > 0 && a_ptr[a_len - 1] == 0)\n    a_len--;\n\n  /* Normalise b.  */\n  for (;;)\n    {\n      if (b_len == 0)\n        /* Division by zero.  */\n        abort ();\n      if (b_ptr[b_len - 1] == 0)\n        b_len--;\n      else\n        break;\n    }\n\n  /* Here m = a_len >= 0 and n = b_len > 0.  */\n\n  if (a_len < b_len)\n    {\n      /* m<n: trivial case.  q=0, r := copy of a.  */\n      r_ptr = roomptr;\n      r_len = a_len;\n      memcpy (r_ptr, a_ptr, a_len * sizeof (mp_limb_t));\n      q_ptr = roomptr + a_len;\n      q_len = 0;\n    }\n  else if (b_len == 1)\n    {\n      /* n=1: single precision division.\n         beta^(m-1) <= a < beta^m  ==>  beta^(m-2) <= a/b < beta^m  */\n      r_ptr = roomptr;\n      q_ptr = roomptr + 1;\n      {\n        mp_limb_t den = b_ptr[0];\n        mp_limb_t remainder = 0;\n        const mp_limb_t *sourceptr = a_ptr + a_len;\n        mp_limb_t *destptr = q_ptr + a_len;\n        size_t count;\n        for (count = a_len; count > 0; count--)\n          {\n            mp_twolimb_t num =\n              ((mp_twolimb_t) remainder << GMP_LIMB_BITS) | *--sourceptr;\n            *--destptr = num / den;\n            remainder = num % den;\n          }\n        /* Normalise and store r.  */\n        if (remainder > 0)\n          {\n            r_ptr[0] = remainder;\n            r_len = 1;\n          }\n        else\n          r_len = 0;\n        /* Normalise q.  */\n        q_len = a_len;\n        if (q_ptr[q_len - 1] == 0)\n          q_len--;\n      }\n    }\n  else\n    {\n      /* n>1: multiple precision division.\n         beta^(m-1) <= a < beta^m, beta^(n-1) <= b < beta^n  ==>\n         beta^(m-n-1) <= a/b < beta^(m-n+1).  */\n      /* Determine s.  */\n      size_t s;\n      {\n        mp_limb_t msd = b_ptr[b_len - 1]; /* = b[n-1], > 0 */\n        /* Determine s = GMP_LIMB_BITS - integer_length (msd).\n           Code copied from gnulib's integer_length.c.  */\n# if __GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)\n        s = __builtin_clz (msd);\n# else\n#  if defined DBL_EXPBIT0_WORD && defined DBL_EXPBIT0_BIT\n        if (GMP_LIMB_BITS <= DBL_MANT_BIT)\n          {\n            /* Use 'double' operations.\n               Assumes an IEEE 754 'double' implementation.  */\n#   define DBL_EXP_MASK ((DBL_MAX_EXP - DBL_MIN_EXP) | 7)\n#   define DBL_EXP_BIAS (DBL_EXP_MASK / 2 - 1)\n#   define NWORDS \\\n     ((sizeof (double) + sizeof (unsigned int) - 1) / sizeof (unsigned int))\n            union { double value; unsigned int word[NWORDS]; } m;\n\n            /* Use a single integer to floating-point conversion.  */\n            m.value = msd;\n\n            s = GMP_LIMB_BITS\n                - (((m.word[DBL_EXPBIT0_WORD] >> DBL_EXPBIT0_BIT) & DBL_EXP_MASK)\n                   - DBL_EXP_BIAS);\n          }\n        else\n#   undef NWORDS\n#  endif\n          {\n            s = 31;\n            if (msd >= 0x10000)\n              {\n                msd = msd >> 16;\n                s -= 16;\n              }\n            if (msd >= 0x100)\n              {\n                msd = msd >> 8;\n                s -= 8;\n              }\n            if (msd >= 0x10)\n              {\n                msd = msd >> 4;\n                s -= 4;\n              }\n            if (msd >= 0x4)\n              {\n                msd = msd >> 2;\n                s -= 2;\n              }\n            if (msd >= 0x2)\n              {\n                msd = msd >> 1;\n                s -= 1;\n              }\n          }\n# endif\n      }\n      /* 0 <= s < GMP_LIMB_BITS.\n         Copy b, shifting it left by s bits.  */\n      if (s > 0)\n        {\n          tmp_roomptr = (mp_limb_t *) malloc (b_len * sizeof (mp_limb_t));\n          if (tmp_roomptr == NULL)\n            {\n              free (roomptr);\n              return NULL;\n            }\n          {\n            const mp_limb_t *sourceptr = b_ptr;\n            mp_limb_t *destptr = tmp_roomptr;\n            mp_twolimb_t accu = 0;\n            size_t count;\n            for (count = b_len; count > 0; count--)\n              {\n                accu += (mp_twolimb_t) *sourceptr++ << s;\n                *destptr++ = (mp_limb_t) accu;\n                accu = accu >> GMP_LIMB_BITS;\n              }\n            /* accu must be zero, since that was how s was determined.  */\n            if (accu != 0)\n              abort ();\n          }\n          b_ptr = tmp_roomptr;\n        }\n      /* Copy a, shifting it left by s bits, yields r.\n         Memory layout:\n         At the beginning: r = roomptr[0..a_len],\n         at the end: r = roomptr[0..b_len-1], q = roomptr[b_len..a_len]  */\n      r_ptr = roomptr;\n      if (s == 0)\n        {\n          memcpy (r_ptr, a_ptr, a_len * sizeof (mp_limb_t));\n          r_ptr[a_len] = 0;\n        }\n      else\n        {\n          const mp_limb_t *sourceptr = a_ptr;\n          mp_limb_t *destptr = r_ptr;\n          mp_twolimb_t accu = 0;\n          size_t count;\n          for (count = a_len; count > 0; count--)\n            {\n              accu += (mp_twolimb_t) *sourceptr++ << s;\n              *destptr++ = (mp_limb_t) accu;\n              accu = accu >> GMP_LIMB_BITS;\n            }\n          *destptr++ = (mp_limb_t) accu;\n        }\n      q_ptr = roomptr + b_len;\n      q_len = a_len - b_len + 1; /* q will have m-n+1 limbs */\n      {\n        size_t j = a_len - b_len; /* m-n */\n        mp_limb_t b_msd = b_ptr[b_len - 1]; /* b[n-1] */\n        mp_limb_t b_2msd = b_ptr[b_len - 2]; /* b[n-2] */\n        mp_twolimb_t b_msdd = /* b[n-1]*beta+b[n-2] */\n          ((mp_twolimb_t) b_msd << GMP_LIMB_BITS) | b_2msd;\n        /* Division loop, traversed m-n+1 times.\n           j counts down, b is unchanged, beta/2 <= b[n-1] < beta.  */\n        for (;;)\n          {\n            mp_limb_t q_star;\n            mp_limb_t c1;\n            if (r_ptr[j + b_len] < b_msd) /* r[j+n] < b[n-1] ? */\n              {\n                /* Divide r[j+n]*beta+r[j+n-1] by b[n-1], no overflow.  */\n                mp_twolimb_t num =\n                  ((mp_twolimb_t) r_ptr[j + b_len] << GMP_LIMB_BITS)\n                  | r_ptr[j + b_len - 1];\n                q_star = num / b_msd;\n                c1 = num % b_msd;\n              }\n            else\n              {\n                /* Overflow, hence r[j+n]*beta+r[j+n-1] >= beta*b[n-1].  */\n                q_star = (mp_limb_t)~(mp_limb_t)0; /* q* = beta-1 */\n                /* Test whether r[j+n]*beta+r[j+n-1] - (beta-1)*b[n-1] >= beta\n                   <==> r[j+n]*beta+r[j+n-1] + b[n-1] >= beta*b[n-1]+beta\n                   <==> b[n-1] < floor((r[j+n]*beta+r[j+n-1]+b[n-1])/beta)\n                        {<= beta !}.\n                   If yes, jump directly to the subtraction loop.\n                   (Otherwise, r[j+n]*beta+r[j+n-1] - (beta-1)*b[n-1] < beta\n                    <==> floor((r[j+n]*beta+r[j+n-1]+b[n-1])/beta) = b[n-1] ) */\n                if (r_ptr[j + b_len] > b_msd\n                    || (c1 = r_ptr[j + b_len - 1] + b_msd) < b_msd)\n                  /* r[j+n] >= b[n-1]+1 or\n                     r[j+n] = b[n-1] and the addition r[j+n-1]+b[n-1] gives a\n                     carry.  */\n                  goto subtract;\n              }\n            /* q_star = q*,\n               c1 = (r[j+n]*beta+r[j+n-1]) - q* * b[n-1] (>=0, <beta).  */\n            {\n              mp_twolimb_t c2 = /* c1*beta+r[j+n-2] */\n                ((mp_twolimb_t) c1 << GMP_LIMB_BITS) | r_ptr[j + b_len - 2];\n              mp_twolimb_t c3 = /* b[n-2] * q* */\n                (mp_twolimb_t) b_2msd * (mp_twolimb_t) q_star;\n              /* While c2 < c3, increase c2 and decrease c3.\n                 Consider c3-c2.  While it is > 0, decrease it by\n                 b[n-1]*beta+b[n-2].  Because of b[n-1]*beta+b[n-2] >= beta^2/2\n                 this can happen only twice.  */\n              if (c3 > c2)\n                {\n                  q_star = q_star - 1; /* q* := q* - 1 */\n                  if (c3 - c2 > b_msdd)\n                    q_star = q_star - 1; /* q* := q* - 1 */\n                }\n            }\n            if (q_star > 0)\n              subtract:\n              {\n                /* Subtract r := r - b * q* * beta^j.  */\n                mp_limb_t cr;\n                {\n                  const mp_limb_t *sourceptr = b_ptr;\n                  mp_limb_t *destptr = r_ptr + j;\n                  mp_twolimb_t carry = 0;\n                  size_t count;\n                  for (count = b_len; count > 0; count--)\n                    {\n                      /* Here 0 <= carry <= q*.  */\n                      carry =\n                        carry\n                        + (mp_twolimb_t) q_star * (mp_twolimb_t) *sourceptr++\n                        + (mp_limb_t) ~(*destptr);\n                      /* Here 0 <= carry <= beta*q* + beta-1.  */\n                      *destptr++ = ~(mp_limb_t) carry;\n                      carry = carry >> GMP_LIMB_BITS; /* <= q* */\n                    }\n                  cr = (mp_limb_t) carry;\n                }\n                /* Subtract cr from r_ptr[j + b_len], then forget about\n                   r_ptr[j + b_len].  */\n                if (cr > r_ptr[j + b_len])\n                  {\n                    /* Subtraction gave a carry.  */\n                    q_star = q_star - 1; /* q* := q* - 1 */\n                    /* Add b back.  */\n                    {\n                      const mp_limb_t *sourceptr = b_ptr;\n                      mp_limb_t *destptr = r_ptr + j;\n                      mp_limb_t carry = 0;\n                      size_t count;\n                      for (count = b_len; count > 0; count--)\n                        {\n                          mp_limb_t source1 = *sourceptr++;\n                          mp_limb_t source2 = *destptr;\n                          *destptr++ = source1 + source2 + carry;\n                          carry =\n                            (carry\n                             ? source1 >= (mp_limb_t) ~source2\n                             : source1 > (mp_limb_t) ~source2);\n                        }\n                    }\n                    /* Forget about the carry and about r[j+n].  */\n                  }\n              }\n            /* q* is determined.  Store it as q[j].  */\n            q_ptr[j] = q_star;\n            if (j == 0)\n              break;\n            j--;\n          }\n      }\n      r_len = b_len;\n      /* Normalise q.  */\n      if (q_ptr[q_len - 1] == 0)\n        q_len--;\n# if 0 /* Not needed here, since we need r only to compare it with b/2, and\n          b is shifted left by s bits.  */\n      /* Shift r right by s bits.  */\n      if (s > 0)\n        {\n          mp_limb_t ptr = r_ptr + r_len;\n          mp_twolimb_t accu = 0;\n          size_t count;\n          for (count = r_len; count > 0; count--)\n            {\n              accu = (mp_twolimb_t) (mp_limb_t) accu << GMP_LIMB_BITS;\n              accu += (mp_twolimb_t) *--ptr << (GMP_LIMB_BITS - s);\n              *ptr = (mp_limb_t) (accu >> GMP_LIMB_BITS);\n            }\n        }\n# endif\n      /* Normalise r.  */\n      while (r_len > 0 && r_ptr[r_len - 1] == 0)\n        r_len--;\n    }\n  /* Compare r << 1 with b.  */\n  if (r_len > b_len)\n    goto increment_q;\n  {\n    size_t i;\n    for (i = b_len;;)\n      {\n        mp_limb_t r_i =\n          (i <= r_len && i > 0 ? r_ptr[i - 1] >> (GMP_LIMB_BITS - 1) : 0)\n          | (i < r_len ? r_ptr[i] << 1 : 0);\n        mp_limb_t b_i = (i < b_len ? b_ptr[i] : 0);\n        if (r_i > b_i)\n          goto increment_q;\n        if (r_i < b_i)\n          goto keep_q;\n        if (i == 0)\n          break;\n        i--;\n      }\n  }\n  if (q_len > 0 && ((q_ptr[0] & 1) != 0))\n    /* q is odd.  */\n    increment_q:\n    {\n      size_t i;\n      for (i = 0; i < q_len; i++)\n        if (++(q_ptr[i]) != 0)\n          goto keep_q;\n      q_ptr[q_len++] = 1;\n    }\n  keep_q:\n  if (tmp_roomptr != NULL)\n    free (tmp_roomptr);\n  q->limbs = q_ptr;\n  q->nlimbs = q_len;\n  return roomptr;\n}",
      "lines": 424,
      "depth": 24,
      "decorators": [
        "static",
        "static",
        "void",
        "*\ndivide (mpn_t a, mpn_t b, mpn_t *q)",
        "*"
      ]
    },
    "convert_to_decimal": {
      "start_point": [
        844,
        0
      ],
      "end_point": [
        890,
        1
      ],
      "content": "static char *\nconvert_to_decimal (mpn_t a, size_t extra_zeroes)\n{\n  mp_limb_t *a_ptr = a.limbs;\n  size_t a_len = a.nlimbs;\n  /* 0.03345 is slightly larger than log(2)/(9*log(10)).  */\n  size_t c_len = 9 * ((size_t)(a_len * (GMP_LIMB_BITS * 0.03345f)) + 1);\n  char *c_ptr = (char *) malloc (xsum (c_len, extra_zeroes));\n  if (c_ptr != NULL)\n    {\n      char *d_ptr = c_ptr;\n      for (; extra_zeroes > 0; extra_zeroes--)\n        *d_ptr++ = '0';\n      while (a_len > 0)\n        {\n          /* Divide a by 10^9, in-place.  */\n          mp_limb_t remainder = 0;\n          mp_limb_t *ptr = a_ptr + a_len;\n          size_t count;\n          for (count = a_len; count > 0; count--)\n            {\n              mp_twolimb_t num =\n                ((mp_twolimb_t) remainder << GMP_LIMB_BITS) | *--ptr;\n              *ptr = num / 1000000000;\n              remainder = num % 1000000000;\n            }\n          /* Store the remainder as 9 decimal digits.  */\n          for (count = 9; count > 0; count--)\n            {\n              *d_ptr++ = '0' + (remainder % 10);\n              remainder = remainder / 10;\n            }\n          /* Normalize a.  */\n          if (a_ptr[a_len - 1] == 0)\n            a_len--;\n        }\n      /* Remove leading zeroes.  */\n      while (d_ptr > c_ptr && d_ptr[-1] == '0')\n        d_ptr--;\n      /* But keep at least one zero.  */\n      if (d_ptr == c_ptr)\n        *d_ptr++ = '0';\n      /* Terminate the string.  */\n      *d_ptr = '\\0';\n    }\n  return c_ptr;\n}",
      "lines": 47,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nconvert_to_decimal (mpn_t a, size_t extra_zeroes)",
        "*"
      ]
    },
    "decode_long_double": {
      "start_point": [
        898,
        0
      ],
      "end_point": [
        976,
        1
      ],
      "content": "static void *\ndecode_long_double (long double x, int *ep, mpn_t *mp)\n{\n  mpn_t m;\n  int exp;\n  long double y;\n  size_t i;\n\n  /* Allocate memory for result.  */\n  m.nlimbs = (LDBL_MANT_BIT + GMP_LIMB_BITS - 1) / GMP_LIMB_BITS;\n  m.limbs = (mp_limb_t *) malloc (m.nlimbs * sizeof (mp_limb_t));\n  if (m.limbs == NULL)\n    return NULL;\n  /* Split into exponential part and mantissa.  */\n  y = frexpl (x, &exp);\n  if (!(y >= 0.0L && y < 1.0L))\n    abort ();\n  /* x = 2^exp * y = 2^(exp - LDBL_MANT_BIT) * (y * 2^LDBL_MANT_BIT), and the\n     latter is an integer.  */\n  /* Convert the mantissa (y * 2^LDBL_MANT_BIT) to a sequence of limbs.\n     I'm not sure whether it's safe to cast a 'long double' value between\n     2^31 and 2^32 to 'unsigned int', therefore play safe and cast only\n     'long double' values between 0 and 2^16 (to 'unsigned int' or 'int',\n     doesn't matter).  */\n#  if (LDBL_MANT_BIT % GMP_LIMB_BITS) != 0\n#   if (LDBL_MANT_BIT % GMP_LIMB_BITS) > GMP_LIMB_BITS / 2\n    {\n      mp_limb_t hi, lo;\n      y *= (mp_limb_t) 1 << (LDBL_MANT_BIT % (GMP_LIMB_BITS / 2));\n      hi = (int) y;\n      y -= hi;\n      if (!(y >= 0.0L && y < 1.0L))\n        abort ();\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      lo = (int) y;\n      y -= lo;\n      if (!(y >= 0.0L && y < 1.0L))\n        abort ();\n      m.limbs[LDBL_MANT_BIT / GMP_LIMB_BITS] = (hi << (GMP_LIMB_BITS / 2)) | lo;\n    }\n#   else\n    {\n      mp_limb_t d;\n      y *= (mp_limb_t) 1 << (LDBL_MANT_BIT % GMP_LIMB_BITS);\n      d = (int) y;\n      y -= d;\n      if (!(y >= 0.0L && y < 1.0L))\n        abort ();\n      m.limbs[LDBL_MANT_BIT / GMP_LIMB_BITS] = d;\n    }\n#   endif\n#  endif\n  for (i = LDBL_MANT_BIT / GMP_LIMB_BITS; i > 0; )\n    {\n      mp_limb_t hi, lo;\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      hi = (int) y;\n      y -= hi;\n      if (!(y >= 0.0L && y < 1.0L))\n        abort ();\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      lo = (int) y;\n      y -= lo;\n      if (!(y >= 0.0L && y < 1.0L))\n        abort ();\n      m.limbs[--i] = (hi << (GMP_LIMB_BITS / 2)) | lo;\n    }\n#  if 0 /* On FreeBSD 6.1/x86, 'long double' numbers sometimes have excess\n           precision.  */\n  if (!(y == 0.0L))\n    abort ();\n#  endif\n  /* Normalise.  */\n  while (m.nlimbs > 0 && m.limbs[m.nlimbs - 1] == 0)\n    m.nlimbs--;\n  *mp = m;\n  *ep = exp - LDBL_MANT_BIT;\n  return m.limbs;\n}",
      "lines": 79,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void",
        "*\ndecode_long_double (long double x, int *ep, mpn_t *mp)",
        "*"
      ]
    },
    "decode_double": {
      "start_point": [
        986,
        0
      ],
      "end_point": [
        1061,
        1
      ],
      "content": "static void *\ndecode_double (double x, int *ep, mpn_t *mp)\n{\n  mpn_t m;\n  int exp;\n  double y;\n  size_t i;\n\n  /* Allocate memory for result.  */\n  m.nlimbs = (DBL_MANT_BIT + GMP_LIMB_BITS - 1) / GMP_LIMB_BITS;\n  m.limbs = (mp_limb_t *) malloc (m.nlimbs * sizeof (mp_limb_t));\n  if (m.limbs == NULL)\n    return NULL;\n  /* Split into exponential part and mantissa.  */\n  y = frexp (x, &exp);\n  if (!(y >= 0.0 && y < 1.0))\n    abort ();\n  /* x = 2^exp * y = 2^(exp - DBL_MANT_BIT) * (y * 2^DBL_MANT_BIT), and the\n     latter is an integer.  */\n  /* Convert the mantissa (y * 2^DBL_MANT_BIT) to a sequence of limbs.\n     I'm not sure whether it's safe to cast a 'double' value between\n     2^31 and 2^32 to 'unsigned int', therefore play safe and cast only\n     'double' values between 0 and 2^16 (to 'unsigned int' or 'int',\n     doesn't matter).  */\n#  if (DBL_MANT_BIT % GMP_LIMB_BITS) != 0\n#   if (DBL_MANT_BIT % GMP_LIMB_BITS) > GMP_LIMB_BITS / 2\n    {\n      mp_limb_t hi, lo;\n      y *= (mp_limb_t) 1 << (DBL_MANT_BIT % (GMP_LIMB_BITS / 2));\n      hi = (int) y;\n      y -= hi;\n      if (!(y >= 0.0 && y < 1.0))\n        abort ();\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      lo = (int) y;\n      y -= lo;\n      if (!(y >= 0.0 && y < 1.0))\n        abort ();\n      m.limbs[DBL_MANT_BIT / GMP_LIMB_BITS] = (hi << (GMP_LIMB_BITS / 2)) | lo;\n    }\n#   else\n    {\n      mp_limb_t d;\n      y *= (mp_limb_t) 1 << (DBL_MANT_BIT % GMP_LIMB_BITS);\n      d = (int) y;\n      y -= d;\n      if (!(y >= 0.0 && y < 1.0))\n        abort ();\n      m.limbs[DBL_MANT_BIT / GMP_LIMB_BITS] = d;\n    }\n#   endif\n#  endif\n  for (i = DBL_MANT_BIT / GMP_LIMB_BITS; i > 0; )\n    {\n      mp_limb_t hi, lo;\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      hi = (int) y;\n      y -= hi;\n      if (!(y >= 0.0 && y < 1.0))\n        abort ();\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      lo = (int) y;\n      y -= lo;\n      if (!(y >= 0.0 && y < 1.0))\n        abort ();\n      m.limbs[--i] = (hi << (GMP_LIMB_BITS / 2)) | lo;\n    }\n  if (!(y == 0.0))\n    abort ();\n  /* Normalise.  */\n  while (m.nlimbs > 0 && m.limbs[m.nlimbs - 1] == 0)\n    m.nlimbs--;\n  *mp = m;\n  *ep = exp - DBL_MANT_BIT;\n  return m.limbs;\n}",
      "lines": 76,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void",
        "*\ndecode_double (double x, int *ep, mpn_t *mp)",
        "*"
      ]
    },
    "scale10_round_decimal_decoded": {
      "start_point": [
        1070,
        0
      ],
      "end_point": [
        1283,
        1
      ],
      "content": "static char *\nscale10_round_decimal_decoded (int e, mpn_t m, void *memory, int n)\n{\n  int s;\n  size_t extra_zeroes;\n  unsigned int abs_n;\n  unsigned int abs_s;\n  mp_limb_t *pow5_ptr;\n  size_t pow5_len;\n  unsigned int s_limbs;\n  unsigned int s_bits;\n  mpn_t pow5;\n  mpn_t z;\n  void *z_memory;\n  char *digits;\n\n  if (memory == NULL)\n    return NULL;\n  /* x = 2^e * m, hence\n     y = round (2^e * 10^n * m) = round (2^(e+n) * 5^n * m)\n       = round (2^s * 5^n * m).  */\n  s = e + n;\n  extra_zeroes = 0;\n  /* Factor out a common power of 10 if possible.  */\n  if (s > 0 && n > 0)\n    {\n      extra_zeroes = (s < n ? s : n);\n      s -= extra_zeroes;\n      n -= extra_zeroes;\n    }\n  /* Here y = round (2^s * 5^n * m) * 10^extra_zeroes.\n     Before converting to decimal, we need to compute\n     z = round (2^s * 5^n * m).  */\n  /* Compute 5^|n|, possibly shifted by |s| bits if n and s have the same\n     sign.  2.322 is slightly larger than log(5)/log(2).  */\n  abs_n = (n >= 0 ? n : -n);\n  abs_s = (s >= 0 ? s : -s);\n  pow5_ptr = (mp_limb_t *) malloc (((int)(abs_n * (2.322f / GMP_LIMB_BITS)) + 1\n                                    + abs_s / GMP_LIMB_BITS + 1)\n                                   * sizeof (mp_limb_t));\n  if (pow5_ptr == NULL)\n    {\n      free (memory);\n      return NULL;\n    }\n  /* Initialize with 1.  */\n  pow5_ptr[0] = 1;\n  pow5_len = 1;\n  /* Multiply with 5^|n|.  */\n  if (abs_n > 0)\n    {\n      static mp_limb_t const small_pow5[13 + 1] =\n        {\n          1, 5, 25, 125, 625, 3125, 15625, 78125, 390625, 1953125, 9765625,\n          48828125, 244140625, 1220703125\n        };\n      unsigned int n13;\n      for (n13 = 0; n13 <= abs_n; n13 += 13)\n        {\n          mp_limb_t digit1 = small_pow5[n13 + 13 <= abs_n ? 13 : abs_n - n13];\n          size_t j;\n          mp_twolimb_t carry = 0;\n          for (j = 0; j < pow5_len; j++)\n            {\n              mp_limb_t digit2 = pow5_ptr[j];\n              carry += (mp_twolimb_t) digit1 * (mp_twolimb_t) digit2;\n              pow5_ptr[j] = (mp_limb_t) carry;\n              carry = carry >> GMP_LIMB_BITS;\n            }\n          if (carry > 0)\n            pow5_ptr[pow5_len++] = (mp_limb_t) carry;\n        }\n    }\n  s_limbs = abs_s / GMP_LIMB_BITS;\n  s_bits = abs_s % GMP_LIMB_BITS;\n  if (n >= 0 ? s >= 0 : s <= 0)\n    {\n      /* Multiply with 2^|s|.  */\n      if (s_bits > 0)\n        {\n          mp_limb_t *ptr = pow5_ptr;\n          mp_twolimb_t accu = 0;\n          size_t count;\n          for (count = pow5_len; count > 0; count--)\n            {\n              accu += (mp_twolimb_t) *ptr << s_bits;\n              *ptr++ = (mp_limb_t) accu;\n              accu = accu >> GMP_LIMB_BITS;\n            }\n          if (accu > 0)\n            {\n              *ptr = (mp_limb_t) accu;\n              pow5_len++;\n            }\n        }\n      if (s_limbs > 0)\n        {\n          size_t count;\n          for (count = pow5_len; count > 0;)\n            {\n              count--;\n              pow5_ptr[s_limbs + count] = pow5_ptr[count];\n            }\n          for (count = s_limbs; count > 0;)\n            {\n              count--;\n              pow5_ptr[count] = 0;\n            }\n          pow5_len += s_limbs;\n        }\n      pow5.limbs = pow5_ptr;\n      pow5.nlimbs = pow5_len;\n      if (n >= 0)\n        {\n          /* Multiply m with pow5.  No division needed.  */\n          z_memory = multiply (m, pow5, &z);\n        }\n      else\n        {\n          /* Divide m by pow5 and round.  */\n          z_memory = divide (m, pow5, &z);\n        }\n    }\n  else\n    {\n      pow5.limbs = pow5_ptr;\n      pow5.nlimbs = pow5_len;\n      if (n >= 0)\n        {\n          /* n >= 0, s < 0.\n             Multiply m with pow5, then divide by 2^|s|.  */\n          mpn_t numerator;\n          mpn_t denominator;\n          void *tmp_memory;\n          tmp_memory = multiply (m, pow5, &numerator);\n          if (tmp_memory == NULL)\n            {\n              free (pow5_ptr);\n              free (memory);\n              return NULL;\n            }\n          /* Construct 2^|s|.  */\n          {\n            mp_limb_t *ptr = pow5_ptr + pow5_len;\n            size_t i;\n            for (i = 0; i < s_limbs; i++)\n              ptr[i] = 0;\n            ptr[s_limbs] = (mp_limb_t) 1 << s_bits;\n            denominator.limbs = ptr;\n            denominator.nlimbs = s_limbs + 1;\n          }\n          z_memory = divide (numerator, denominator, &z);\n          free (tmp_memory);\n        }\n      else\n        {\n          /* n < 0, s > 0.\n             Multiply m with 2^s, then divide by pow5.  */\n          mpn_t numerator;\n          mp_limb_t *num_ptr;\n          num_ptr = (mp_limb_t *) malloc ((m.nlimbs + s_limbs + 1)\n                                          * sizeof (mp_limb_t));\n          if (num_ptr == NULL)\n            {\n              free (pow5_ptr);\n              free (memory);\n              return NULL;\n            }\n          {\n            mp_limb_t *destptr = num_ptr;\n            {\n              size_t i;\n              for (i = 0; i < s_limbs; i++)\n                *destptr++ = 0;\n            }\n            if (s_bits > 0)\n              {\n                const mp_limb_t *sourceptr = m.limbs;\n                mp_twolimb_t accu = 0;\n                size_t count;\n                for (count = m.nlimbs; count > 0; count--)\n                  {\n                    accu += (mp_twolimb_t) *sourceptr++ << s_bits;\n                    *destptr++ = (mp_limb_t) accu;\n                    accu = accu >> GMP_LIMB_BITS;\n                  }\n                if (accu > 0)\n                  *destptr++ = (mp_limb_t) accu;\n              }\n            else\n              {\n                const mp_limb_t *sourceptr = m.limbs;\n                size_t count;\n                for (count = m.nlimbs; count > 0; count--)\n                  *destptr++ = *sourceptr++;\n              }\n            numerator.limbs = num_ptr;\n            numerator.nlimbs = destptr - num_ptr;\n          }\n          z_memory = divide (numerator, pow5, &z);\n          free (num_ptr);\n        }\n    }\n  free (pow5_ptr);\n  free (memory);\n\n  /* Here y = round (x * 10^n) = z * 10^extra_zeroes.  */\n\n  if (z_memory == NULL)\n    return NULL;\n  digits = convert_to_decimal (z, extra_zeroes);\n  free (z_memory);\n  return digits;\n}",
      "lines": 214,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nscale10_round_decimal_decoded (int e, mpn_t m, void *memory, int n)",
        "*"
      ]
    },
    "scale10_round_decimal_long_double": {
      "start_point": [
        1292,
        0
      ],
      "end_point": [
        1299,
        1
      ],
      "content": "static char *\nscale10_round_decimal_long_double (long double x, int n)\n{\n  int e IF_LINT(= 0);\n  mpn_t m;\n  void *memory = decode_long_double (x, &e, &m);\n  return scale10_round_decimal_decoded (e, m, memory, n);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nscale10_round_decimal_long_double (long double x, int n)",
        "*"
      ]
    },
    "scale10_round_decimal_double": {
      "start_point": [
        1310,
        0
      ],
      "end_point": [
        1317,
        1
      ],
      "content": "static char *\nscale10_round_decimal_double (double x, int n)\n{\n  int e IF_LINT(= 0);\n  mpn_t m;\n  void *memory = decode_double (x, &e, &m);\n  return scale10_round_decimal_decoded (e, m, memory, n);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nscale10_round_decimal_double (double x, int n)",
        "*"
      ]
    },
    "floorlog10l": {
      "start_point": [
        1326,
        0
      ],
      "end_point": [
        1408,
        1
      ],
      "content": "static int\nfloorlog10l (long double x)\n{\n  int exp;\n  long double y;\n  double z;\n  double l;\n\n  /* Split into exponential part and mantissa.  */\n  y = frexpl (x, &exp);\n  if (!(y >= 0.0L && y < 1.0L))\n    abort ();\n  if (y == 0.0L)\n    return INT_MIN;\n  if (y < 0.5L)\n    {\n      while (y < (1.0L / (1 << (GMP_LIMB_BITS / 2)) / (1 << (GMP_LIMB_BITS / 2))))\n        {\n          y *= 1.0L * (1 << (GMP_LIMB_BITS / 2)) * (1 << (GMP_LIMB_BITS / 2));\n          exp -= GMP_LIMB_BITS;\n        }\n      if (y < (1.0L / (1 << 16)))\n        {\n          y *= 1.0L * (1 << 16);\n          exp -= 16;\n        }\n      if (y < (1.0L / (1 << 8)))\n        {\n          y *= 1.0L * (1 << 8);\n          exp -= 8;\n        }\n      if (y < (1.0L / (1 << 4)))\n        {\n          y *= 1.0L * (1 << 4);\n          exp -= 4;\n        }\n      if (y < (1.0L / (1 << 2)))\n        {\n          y *= 1.0L * (1 << 2);\n          exp -= 2;\n        }\n      if (y < (1.0L / (1 << 1)))\n        {\n          y *= 1.0L * (1 << 1);\n          exp -= 1;\n        }\n    }\n  if (!(y >= 0.5L && y < 1.0L))\n    abort ();\n  /* Compute an approximation for l = log2(x) = exp + log2(y).  */\n  l = exp;\n  z = y;\n  if (z < 0.70710678118654752444)\n    {\n      z *= 1.4142135623730950488;\n      l -= 0.5;\n    }\n  if (z < 0.8408964152537145431)\n    {\n      z *= 1.1892071150027210667;\n      l -= 0.25;\n    }\n  if (z < 0.91700404320467123175)\n    {\n      z *= 1.0905077326652576592;\n      l -= 0.125;\n    }\n  if (z < 0.9576032806985736469)\n    {\n      z *= 1.0442737824274138403;\n      l -= 0.0625;\n    }\n  /* Now 0.95 <= z <= 1.01.  */\n  z = 1 - z;\n  /* log2(1-z) = 1/log(2) * (- z - z^2/2 - z^3/3 - z^4/4 - ...)\n     Four terms are enough to get an approximation with error < 10^-7.  */\n  l -= 1.4426950408889634074 * z * (1.0 + z * (0.5 + z * ((1.0 / 3) + z * 0.25)));\n  /* Finally multiply with log(2)/log(10), yields an approximation for\n     log10(x).  */\n  l *= 0.30102999566398119523;\n  /* Round down to the next integer.  */\n  return (int) l + (l < 0 ? -1 : 0);\n}",
      "lines": 83,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "floorlog10": {
      "start_point": [
        1417,
        0
      ],
      "end_point": [
        1499,
        1
      ],
      "content": "static int\nfloorlog10 (double x)\n{\n  int exp;\n  double y;\n  double z;\n  double l;\n\n  /* Split into exponential part and mantissa.  */\n  y = frexp (x, &exp);\n  if (!(y >= 0.0 && y < 1.0))\n    abort ();\n  if (y == 0.0)\n    return INT_MIN;\n  if (y < 0.5)\n    {\n      while (y < (1.0 / (1 << (GMP_LIMB_BITS / 2)) / (1 << (GMP_LIMB_BITS / 2))))\n        {\n          y *= 1.0 * (1 << (GMP_LIMB_BITS / 2)) * (1 << (GMP_LIMB_BITS / 2));\n          exp -= GMP_LIMB_BITS;\n        }\n      if (y < (1.0 / (1 << 16)))\n        {\n          y *= 1.0 * (1 << 16);\n          exp -= 16;\n        }\n      if (y < (1.0 / (1 << 8)))\n        {\n          y *= 1.0 * (1 << 8);\n          exp -= 8;\n        }\n      if (y < (1.0 / (1 << 4)))\n        {\n          y *= 1.0 * (1 << 4);\n          exp -= 4;\n        }\n      if (y < (1.0 / (1 << 2)))\n        {\n          y *= 1.0 * (1 << 2);\n          exp -= 2;\n        }\n      if (y < (1.0 / (1 << 1)))\n        {\n          y *= 1.0 * (1 << 1);\n          exp -= 1;\n        }\n    }\n  if (!(y >= 0.5 && y < 1.0))\n    abort ();\n  /* Compute an approximation for l = log2(x) = exp + log2(y).  */\n  l = exp;\n  z = y;\n  if (z < 0.70710678118654752444)\n    {\n      z *= 1.4142135623730950488;\n      l -= 0.5;\n    }\n  if (z < 0.8408964152537145431)\n    {\n      z *= 1.1892071150027210667;\n      l -= 0.25;\n    }\n  if (z < 0.91700404320467123175)\n    {\n      z *= 1.0905077326652576592;\n      l -= 0.125;\n    }\n  if (z < 0.9576032806985736469)\n    {\n      z *= 1.0442737824274138403;\n      l -= 0.0625;\n    }\n  /* Now 0.95 <= z <= 1.01.  */\n  z = 1 - z;\n  /* log2(1-z) = 1/log(2) * (- z - z^2/2 - z^3/3 - z^4/4 - ...)\n     Four terms are enough to get an approximation with error < 10^-7.  */\n  l -= 1.4426950408889634074 * z * (1.0 + z * (0.5 + z * ((1.0 / 3) + z * 0.25)));\n  /* Finally multiply with log(2)/log(10), yields an approximation for\n     log10(x).  */\n  l *= 0.30102999566398119523;\n  /* Round down to the next integer.  */\n  return (int) l + (l < 0 ? -1 : 0);\n}",
      "lines": 83,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "is_borderline": {
      "start_point": [
        1505,
        0
      ],
      "end_point": [
        1515,
        1
      ],
      "content": "static int\nis_borderline (const char *digits, size_t precision)\n{\n  for (; precision > 0; precision--, digits++)\n    if (*digits != '0')\n      return 0;\n  if (*digits != '1')\n    return 0;\n  digits++;\n  return *digits == '\\0';\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "MAX_ROOM_NEEDED": {
      "start_point": [
        1532,
        0
      ],
      "end_point": [
        1767,
        1
      ],
      "content": "static size_t\nMAX_ROOM_NEEDED (const arguments *ap, size_t arg_index, FCHAR_T conversion,\n                 arg_type type, int flags, size_t width, int has_precision,\n                 size_t precision, int pad_ourselves)\n{\n  size_t tmp_length;\n\n  switch (conversion)\n    {\n    case 'd': case 'i': case 'u':\n# if HAVE_LONG_LONG_INT\n      if (type == TYPE_LONGLONGINT || type == TYPE_ULONGLONGINT)\n        tmp_length =\n          (unsigned int) (sizeof (unsigned long long) * CHAR_BIT\n                          * 0.30103 /* binary -> decimal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n# endif\n      if (type == TYPE_LONGINT || type == TYPE_ULONGINT)\n        tmp_length =\n          (unsigned int) (sizeof (unsigned long) * CHAR_BIT\n                          * 0.30103 /* binary -> decimal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n        tmp_length =\n          (unsigned int) (sizeof (unsigned int) * CHAR_BIT\n                          * 0.30103 /* binary -> decimal */\n                         )\n          + 1; /* turn floor into ceil */\n      if (tmp_length < precision)\n        tmp_length = precision;\n      /* Multiply by 2, as an estimate for FLAG_GROUP.  */\n      tmp_length = xsum (tmp_length, tmp_length);\n      /* Add 1, to account for a leading sign.  */\n      tmp_length = xsum (tmp_length, 1);\n      break;\n\n    case 'o':\n# if HAVE_LONG_LONG_INT\n      if (type == TYPE_LONGLONGINT || type == TYPE_ULONGLONGINT)\n        tmp_length =\n          (unsigned int) (sizeof (unsigned long long) * CHAR_BIT\n                          * 0.333334 /* binary -> octal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n# endif\n      if (type == TYPE_LONGINT || type == TYPE_ULONGINT)\n        tmp_length =\n          (unsigned int) (sizeof (unsigned long) * CHAR_BIT\n                          * 0.333334 /* binary -> octal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n        tmp_length =\n          (unsigned int) (sizeof (unsigned int) * CHAR_BIT\n                          * 0.333334 /* binary -> octal */\n                         )\n          + 1; /* turn floor into ceil */\n      if (tmp_length < precision)\n        tmp_length = precision;\n      /* Add 1, to account for a leading sign.  */\n      tmp_length = xsum (tmp_length, 1);\n      break;\n\n    case 'x': case 'X':\n# if HAVE_LONG_LONG_INT\n      if (type == TYPE_LONGLONGINT || type == TYPE_ULONGLONGINT)\n        tmp_length =\n          (unsigned int) (sizeof (unsigned long long) * CHAR_BIT\n                          * 0.25 /* binary -> hexadecimal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n# endif\n      if (type == TYPE_LONGINT || type == TYPE_ULONGINT)\n        tmp_length =\n          (unsigned int) (sizeof (unsigned long) * CHAR_BIT\n                          * 0.25 /* binary -> hexadecimal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n        tmp_length =\n          (unsigned int) (sizeof (unsigned int) * CHAR_BIT\n                          * 0.25 /* binary -> hexadecimal */\n                         )\n          + 1; /* turn floor into ceil */\n      if (tmp_length < precision)\n        tmp_length = precision;\n      /* Add 2, to account for a leading sign or alternate form.  */\n      tmp_length = xsum (tmp_length, 2);\n      break;\n\n    case 'f': case 'F':\n      if (type == TYPE_LONGDOUBLE)\n        tmp_length =\n          (unsigned int) (LDBL_MAX_EXP\n                          * 0.30103 /* binary -> decimal */\n                          * 2 /* estimate for FLAG_GROUP */\n                         )\n          + 1 /* turn floor into ceil */\n          + 10; /* sign, decimal point etc. */\n      else\n        tmp_length =\n          (unsigned int) (DBL_MAX_EXP\n                          * 0.30103 /* binary -> decimal */\n                          * 2 /* estimate for FLAG_GROUP */\n                         )\n          + 1 /* turn floor into ceil */\n          + 10; /* sign, decimal point etc. */\n      tmp_length = xsum (tmp_length, precision);\n      break;\n\n    case 'e': case 'E': case 'g': case 'G':\n      tmp_length =\n        12; /* sign, decimal point, exponent etc. */\n      tmp_length = xsum (tmp_length, precision);\n      break;\n\n    case 'a': case 'A':\n      if (type == TYPE_LONGDOUBLE)\n        tmp_length =\n          (unsigned int) (LDBL_DIG\n                          * 0.831 /* decimal -> hexadecimal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n        tmp_length =\n          (unsigned int) (DBL_DIG\n                          * 0.831 /* decimal -> hexadecimal */\n                         )\n          + 1; /* turn floor into ceil */\n      if (tmp_length < precision)\n        tmp_length = precision;\n      /* Account for sign, decimal point etc. */\n      tmp_length = xsum (tmp_length, 12);\n      break;\n\n    case 'c':\n# if HAVE_WINT_T && !WIDE_CHAR_VERSION\n      if (type == TYPE_WIDE_CHAR)\n        tmp_length = MB_CUR_MAX;\n      else\n# endif\n        tmp_length = 1;\n      break;\n\n    case 's':\n# if HAVE_WCHAR_T\n      if (type == TYPE_WIDE_STRING)\n        {\n#  if WIDE_CHAR_VERSION\n          /* ISO C says about %ls in fwprintf:\n               \"If the precision is not specified or is greater than the size\n                of the array, the array shall contain a null wide character.\"\n             So if there is a precision, we must not use wcslen.  */\n          const wchar_t *arg = ap->arg[arg_index].a.a_wide_string;\n\n          if (has_precision)\n            tmp_length = local_wcsnlen (arg, precision);\n          else\n            tmp_length = local_wcslen (arg);\n#  else\n          /* ISO C says about %ls in fprintf:\n               \"If a precision is specified, no more than that many bytes are\n                written (including shift sequences, if any), and the array\n                shall contain a null wide character if, to equal the multibyte\n                character sequence length given by the precision, the function\n                would need to access a wide character one past the end of the\n                array.\"\n             So if there is a precision, we must not use wcslen.  */\n          /* This case has already been handled separately in VASNPRINTF.  */\n          abort ();\n#  endif\n        }\n      else\n# endif\n        {\n# if WIDE_CHAR_VERSION\n          /* ISO C says about %s in fwprintf:\n               \"If the precision is not specified or is greater than the size\n                of the converted array, the converted array shall contain a\n                null wide character.\"\n             So if there is a precision, we must not use strlen.  */\n          /* This case has already been handled separately in VASNPRINTF.  */\n          abort ();\n# else\n          /* ISO C says about %s in fprintf:\n               \"If the precision is not specified or greater than the size of\n                the array, the array shall contain a null character.\"\n             So if there is a precision, we must not use strlen.  */\n          const char *arg = ap->arg[arg_index].a.a_string;\n\n          if (has_precision)\n            tmp_length = local_strnlen (arg, precision);\n          else\n            tmp_length = strlen (arg);\n# endif\n        }\n      break;\n\n    case 'p':\n      tmp_length =\n        (unsigned int) (sizeof (void *) * CHAR_BIT\n                        * 0.25 /* binary -> hexadecimal */\n                       )\n          + 1 /* turn floor into ceil */\n          + 2; /* account for leading 0x */\n      break;\n\n    default:\n      abort ();\n    }\n\n  if (!pad_ourselves)\n    {\n# if ENABLE_UNISTDIO\n      /* Padding considers the number of characters, therefore the number of\n         elements after padding may be\n           > max (tmp_length, width)\n         but is certainly\n           <= tmp_length + width.  */\n      tmp_length = xsum (tmp_length, width);\n# else\n      /* Padding considers the number of elements, says POSIX.  */\n      if (tmp_length < width)\n        tmp_length = width;\n# endif\n    }\n\n  tmp_length = xsum (tmp_length, 1); /* account for trailing NUL */\n\n  return tmp_length;\n}",
      "lines": 236,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "xsum": {
      "start_point": [
        4614,
        16
      ],
      "end_point": [
        5533,
        15
      ],
      "content": "int prefixes[2] IF_LINT (= { 0 });\n                int orig_errno;\n#if !USE_SNPRINTF\n                size_t tmp_length;\n                TCHAR_T tmpbuf[700];\n                TCHAR_T *tmp;\n#endif\n\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                has_width = 0;\n#endif\n#if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                width = 0;\n                if (dp->width_start != dp->width_end)\n                  {\n                    if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        width = arg;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    has_width = 1;\n#endif\n                  }\n#endif\n\n#if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || NEED_PRINTF_UNBOUNDED_PRECISION\n                has_precision = 0;\n                precision = 6;\n                if (dp->precision_start != dp->precision_end)\n                  {\n                    if (dp->precision_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }\n                  }\n#endif\n\n                /* Decide whether to handle the precision ourselves.  */\n#if NEED_PRINTF_UNBOUNDED_PRECISION\n                switch (dp->conversion)\n                  {\n                  case 'd': case 'i': case 'u':\n                  case 'o':\n                  case 'x': case 'X': case 'p':\n                    prec_ourselves = has_precision && (precision > 0);\n                    break;\n                  default:\n                    prec_ourselves = 0;\n                    break;\n                  }\n#endif\n\n                /* Decide whether to perform the padding ourselves.  */\n#if !NEED_PRINTF_FLAG_LEFTADJUST && (!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION)\n                switch (dp->conversion)\n                  {\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                  /* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */\n                  case 'c': case 's':\n# endif\n# if NEED_PRINTF_FLAG_ZERO\n                  case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                  case 'a': case 'A':\n# endif\n                    pad_ourselves = 1;\n                    break;\n                  default:\n                    pad_ourselves = prec_ourselves;\n                    break;\n                  }\n#endif\n\n#if !USE_SNPRINTF\n                /* Allocate a temporary buffer of sufficient size for calling\n                   sprintf.  */\n                tmp_length =\n                  MAX_ROOM_NEEDED (&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves);\n\n                if (tmp_length <= sizeof (tmpbuf) / sizeof (TCHAR_T))\n                  tmp = tmpbuf;\n                else\n                  {\n                    size_t tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T));\n\n                    if (size_overflow_p (tmp_memsize))\n                      /* Overflow, would lead to out of memory.  */\n                      goto out_of_memory;\n                    tmp = (TCHAR_T *) malloc (tmp_memsize);\n                    if (tmp == NULL)\n                      /* Out of memory.  */\n                      goto out_of_memory;\n                  }\n#endif\n\n                /* Construct the format string for calling snprintf or\n                   sprintf.  */\n                fbp = buf;\n                *fbp++ = '%';\n#if NEED_PRINTF_FLAG_GROUPING\n                /* The underlying implementation doesn't support the ' flag.\n                   Produce no grouping characters in this case; this is\n                   acceptable because the grouping is locale dependent.  */\n#else\n                if (flags & FLAG_GROUP)\n                  *fbp++ = '\\'';\n#endif\n                if (flags & FLAG_LEFT)\n                  *fbp++ = '-';\n                if (flags & FLAG_SHOWSIGN)\n                  *fbp++ = '+';\n                if (flags & FLAG_SPACE)\n                  *fbp++ = ' ';\n                if (flags & FLAG_ALT)\n                  *fbp++ = '#';\n#if __GLIBC__ >= 2 && !defined __UCLIBC__\n                if (flags & FLAG_LOCALIZED)\n                  *fbp++ = 'I';\n#endif\n                if (!pad_ourselves)\n                  {\n                    if (flags & FLAG_ZERO)\n                      *fbp++ = '0';\n                    if (dp->width_start != dp->width_end)\n                      {\n                        size_t n = dp->width_end - dp->width_start;\n                        /* The width specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }\n                if (!prec_ourselves)\n                  {\n                    if (dp->precision_start != dp->precision_end)\n                      {\n                        size_t n = dp->precision_end - dp->precision_start;\n                        /* The precision specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }\n\n                switch (type)\n                  {\n#if HAVE_LONG_LONG_INT\n                  case TYPE_LONGLONGINT:\n                  case TYPE_ULONGLONGINT:\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n                    *fbp++ = 'I';\n                    *fbp++ = '6';\n                    *fbp++ = '4';\n                    break;\n# else\n                    *fbp++ = 'l';\n                    /*FALLTHROUGH*/\n# endif\n#endif\n                  case TYPE_LONGINT:\n                  case TYPE_ULONGINT:\n#if HAVE_WINT_T\n                  case TYPE_WIDE_CHAR:\n#endif\n#if HAVE_WCHAR_T\n                  case TYPE_WIDE_STRING:\n#endif\n                    *fbp++ = 'l';\n                    break;\n                  case TYPE_LONGDOUBLE:\n                    *fbp++ = 'L';\n                    break;\n                  default:\n                    break;\n                  }\n#if NEED_PRINTF_DIRECTIVE_F\n                if (dp->conversion == 'F')\n                  *fbp = 'f';\n                else\n#endif\n                  *fbp = dp->conversion;\n#if USE_SNPRINTF\n# if !(((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)) && !defined __UCLIBC__) || ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__))\n                fbp[1] = '%';\n                fbp[2] = 'n';\n                fbp[3] = '\\0';\n# else\n                /* On glibc2 systems from glibc >= 2.3 - probably also older\n                   ones - we know that snprintf's return value conforms to\n                   ISO C 99: the tests gl_SNPRINTF_RETVAL_C99 and\n                   gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On glibc2 systems from 2004-10-18 or newer, the use of %n\n                   in format strings in writable memory may crash the program\n                   (if compiled with _FORTIFY_SOURCE=2), so we should avoid it\n                   in this situation.  */\n                /* On native Windows systems (such as mingw), we can avoid using\n                   %n because:\n                     - Although the gl_SNPRINTF_TRUNCATION_C99 test fails,\n                       snprintf does not write more than the specified number\n                       of bytes. (snprintf (buf, 3, \"%d %d\", 4567, 89) writes\n                       '4', '5', '6' into buf, not '4', '5', '\\0'.)\n                     - Although the gl_SNPRINTF_RETVAL_C99 test fails, snprintf\n                       allows us to recognize the case of an insufficient\n                       buffer size: it returns -1 in this case.\n                   On native Windows systems (such as mingw) where the OS is\n                   Windows Vista, the use of %n in format strings by default\n                   crashes the program. See\n                     <http://gcc.gnu.org/ml/gcc/2007-06/msg00122.html> and\n                     <http://msdn2.microsoft.com/en-us/library/ms175782(VS.80).aspx>\n                   So we should avoid %n in this situation.  */\n                fbp[1] = '\\0';\n# endif\n#else\n                fbp[1] = '\\0';\n#endif\n\n                /* Construct the arguments for calling snprintf or sprintf.  */\n                prefix_count = 0;\n                if (!pad_ourselves && dp->width_arg_index != ARG_NONE)\n                  {\n                    if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->width_arg_index].a.a_int;\n                  }\n                if (!prec_ourselves && dp->precision_arg_index != ARG_NONE)\n                  {\n                    if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->precision_arg_index].a.a_int;\n                  }\n\n#if USE_SNPRINTF\n                /* The SNPRINTF result is appended after result[0..length].\n                   The latter is an array of DCHAR_T; SNPRINTF appends an\n                   array of TCHAR_T to it.  This is possible because\n                   sizeof (TCHAR_T) divides sizeof (DCHAR_T) and\n                   alignof (TCHAR_T) <= alignof (DCHAR_T).  */\n# define TCHARS_PER_DCHAR (sizeof (DCHAR_T) / sizeof (TCHAR_T))\n                /* Ensure that maxlen below will be >= 2.  Needed on BeOS,\n                   where an snprintf() with maxlen==1 acts like sprintf().  */\n                ENSURE_ALLOCATION (xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR));\n                /* Prepare checking whether snprintf returns the count\n                   via %n.  */\n                *(TCHAR_T *) (result + length) = '\\0';\n#endif\n\n                orig_errno = errno;\n\n                for (;;)\n                  {\n                    int count = -1;\n\n#if USE_SNPRINTF\n                    int retcount = 0;\n                    size_t maxlen = allocated - length;\n                    /* SNPRINTF can fail if its second argument is\n                       > INT_MAX.  */\n                    if (maxlen > INT_MAX / TCHARS_PER_DCHAR)\n                      maxlen = INT_MAX / TCHARS_PER_DCHAR;\n                    maxlen = maxlen * TCHARS_PER_DCHAR;\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#else\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#endif\n\n                    errno = 0;\n                    switch (type)\n                      {\n                      case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      default:\n                        abort ();\n                      }\n\n#if USE_SNPRINTF\n                    /* Portability: Not all implementations of snprintf()\n                       are ISO C 99 compliant.  Determine the number of\n                       bytes that snprintf() has produced or would have\n                       produced.  */\n                    if (count >= 0)\n                      {\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }\n                    else\n                      {\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }\n#endif\n\n                    /* Attempt to handle failure.  */\n                    if (count < 0)\n                      {\n                        /* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */\n                        int saved_errno = errno;\n                        if (saved_errno == 0)\n                          {\n                            if (dp->conversion == 'c' || dp->conversion == 's')\n                              saved_errno = EILSEQ;\n                            else\n                              saved_errno = EINVAL;\n                          }\n\n                        if (!(result == resultbuf || result == NULL))\n                          free (result);\n                        if (buf_malloced != NULL)\n                          free (buf_malloced);\n                        CLEANUP ();\n\n                        errno = saved_errno;\n                        return NULL;\n                      }\n\n#if USE_SNPRINTF\n                    /* Handle overflow of the allocated buffer.\n                       If such an overflow occurs, a C99 compliant snprintf()\n                       returns a count >= maxlen.  However, a non-compliant\n                       snprintf() function returns only count = maxlen - 1.  To\n                       cover both cases, test whether count >= maxlen - 1.  */\n                    if ((unsigned int) count + 1 >= maxlen)\n                      {\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }\n#endif\n\n#if NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (prec_ourselves)\n                      {\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }\n#endif\n\n#if !USE_SNPRINTF\n                    if (count >= tmp_length)\n                      /* tmp_length was incorrectly calculated - fix the\n                         code above!  */\n                      abort ();\n#endif\n\n#if !DCHAR_IS_TCHAR\n                    /* Convert from TCHAR_T[] to DCHAR_T[].  */\n                    if (dp->conversion == 'c' || dp->conversion == 's')\n                      {\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }\n                    else\n                      {\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = *--tmpsrc;\n                          }\n                      }\n#endif\n\n#if DCHAR_IS_TCHAR && !USE_SNPRINTF\n                    /* Make room for the result.  */\n                    if (count > allocated - length)\n                      {\n                        /* Need at least count elements.  But allocate\n                           proportionally.  */\n                        size_t n =\n                          xmax (xsum (length, count), xtimes (allocated, 2));\n\n                        ENSURE_ALLOCATION (n);\n                      }\n#endif\n\n                    /* Here count <= allocated - length.  */\n\n                    /* Perform padding.  */\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (pad_ourselves && has_width)\n                      {\n                        size_t w;\n# if ENABLE_UNISTDIO\n                        /* Outside POSIX, it's preferable to compare the width\n                           against the number of _characters_ of the converted\n                           value.  */\n                        w = DCHAR_MBSNLEN (result + length, count);\n# else\n                        /* The width is compared against the number of _bytes_\n                           of the converted value, says POSIX.  */\n                        w = count;\n# endif\n                        if (w < width)\n                          {\n                            size_t pad = width - w;\n\n                            /* Make room for the result.  */\n                            if (xsum (count, pad) > allocated - length)\n                              {\n                                /* Need at least count + pad elements.  But\n                                   allocate proportionally.  */\n                                size_t n =\n                                  xmax (xsum3 (length, count, pad),\n                                        xtimes (allocated, 2));\n\n# if USE_SNPRINTF\n                                length += count;\n                                ENSURE_ALLOCATION (n);\n                                length -= count;\n# else\n                                ENSURE_ALLOCATION (n);\n# endif\n                              }\n                            /* Here count + pad <= allocated - length.  */\n\n                            {\n# if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                              DCHAR_T * const rp = result + length;\n# else\n                              DCHAR_T * const rp = tmp;\n# endif\n                              DCHAR_T *p = rp + count;\n                              DCHAR_T *end = p + pad;\n                              DCHAR_T *pad_ptr;\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                              if (dp->conversion == 'c'\n                                  || dp->conversion == 's')\n                                /* No zero-padding for string directives.  */\n                                pad_ptr = NULL;\n                              else\n# endif\n                                {\n                                  pad_ptr = (*rp == '-' ? rp + 1 : rp);\n                                  /* No zero-padding of \"inf\" and \"nan\".  */\n                                  if ((*pad_ptr >= 'A' && *pad_ptr <= 'Z')\n                                      || (*pad_ptr >= 'a' && *pad_ptr <= 'z'))\n                                    pad_ptr = NULL;\n                                }\n                              /* The generated string now extends from rp to p,\n                                 with the zero padding insertion point being at\n                                 pad_ptr.  */\n\n                              count = count + pad; /* = end - rp */\n\n                              if (flags & FLAG_LEFT)\n                                {\n                                  /* Pad with spaces on the right.  */\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                              else if ((flags & FLAG_ZERO) && pad_ptr != NULL)\n                                {\n                                  /* Pad with zeroes.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > pad_ptr)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = '0';\n                                }\n                              else\n                                {\n                                  /* Pad with spaces on the left.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > rp)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                            }\n                          }\n                      }\n#endif\n\n                    /* Here still count <= allocated - length.  */\n\n#if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                    /* The snprintf() result did fit.  */\n#else\n                    /* Append the sprintf() result.  */\n                    memcpy (result + length, tmp, count * sizeof (DCHAR_T));\n#endif\n#if !USE_SNPRINTF\n                    if (tmp != tmpbuf)\n                      free (tmp);\n#endif\n\n#if NEED_PRINTF_DIRECTIVE_F\n                    if (dp->conversion == 'F')\n                      {\n                        /* Convert the %f result to upper case for %F.  */\n                        DCHAR_T *rp = result + length;\n                        size_t rc;\n                        for (rc = count; rc > 0; rc--, rp++)\n                          if (*rp >= 'a' && *rp <= 'z')\n                            *rp = *rp - 'a' + 'A';\n                      }\n#endif\n\n                    length += count;\n                    break;\n                  }\n                errno = orig_errno;\n#undef pad_ourselves\n#undef prec_ourselves\n              }",
      "lines": 920,
      "depth": 24,
      "decorators": [
        "int",
        "prefixes[2]",
        "prefixes",
        "[",
        "2",
        "]",
        "IF_LINT (=",
        "IF_LINT",
        "(",
        "=",
        "{ 0 });\n                int orig_errno;\n#if !USE_SNPRINTF\n                size_t tmp_length;\n                TCHAR_T tmpbuf[700];\n                TCHAR_T *tmp;\n#endif\n\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                has_width = 0;\n#endif\n#if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                width = 0;\n                if (dp->width_start != dp->width_end)\n                  {\n                    if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        width = arg;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    has_width = 1;\n#endif\n                  }\n#endif\n\n#if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || NEED_PRINTF_UNBOUNDED_PRECISION\n                has_precision = 0;\n                precision = 6;\n                if (dp->precision_start != dp->precision_end)\n                  {\n                    if (dp->precision_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }\n                  }\n#endif\n\n                /* Decide whether to handle the precision ourselves.  */\n#if NEED_PRINTF_UNBOUNDED_PRECISION\n                switch (dp->conversion)\n                  {\n                  case 'd': case 'i': case 'u':\n                  case 'o':\n                  case 'x': case 'X': case 'p':\n                    prec_ourselves = has_precision && (precision > 0);\n                    break;\n                  default:\n                    prec_ourselves = 0;\n                    break;\n                  }\n#endif\n\n                /* Decide whether to perform the padding ourselves.  */\n#if !NEED_PRINTF_FLAG_LEFTADJUST && (!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION)\n                switch (dp->conversion)\n                  {\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                  /* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */\n                  case 'c': case 's':\n# endif\n# if NEED_PRINTF_FLAG_ZERO\n                  case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                  case 'a': case 'A':\n# endif\n                    pad_ourselves = 1;\n                    break;\n                  default:\n                    pad_ourselves = prec_ourselves;\n                    break;\n                  }\n#endif\n\n#if !USE_SNPRINTF\n                /* Allocate a temporary buffer of sufficient size for calling\n                   sprintf.  */\n                tmp_length =\n                  MAX_ROOM_NEEDED (&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves);\n\n                if (tmp_length <= sizeof (tmpbuf) / sizeof (TCHAR_T))\n                  tmp = tmpbuf;\n                else\n                  {\n                    size_t tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T));\n\n                    if (size_overflow_p (tmp_memsize))\n                      /* Overflow, would lead to out of memory.  */\n                      goto out_of_memory;\n                    tmp = (TCHAR_T *) malloc (tmp_memsize);\n                    if (tmp == NULL)\n                      /* Out of memory.  */\n                      goto out_of_memory;\n                  }\n#endif\n\n                /* Construct the format string for calling snprintf or\n                   sprintf.  */\n                fbp = buf;\n                *fbp++ = '%';\n#if NEED_PRINTF_FLAG_GROUPING\n                /* The underlying implementation doesn't support the ' flag.\n                   Produce no grouping characters in this case; this is\n                   acceptable because the grouping is locale dependent.  */\n#else\n                if (flags & FLAG_GROUP)\n                  *fbp++ = '\\'';\n#endif\n                if (flags & FLAG_LEFT)\n                  *fbp++ = '-';\n                if (flags & FLAG_SHOWSIGN)\n                  *fbp++ = '+';\n                if (flags & FLAG_SPACE)\n                  *fbp++ = ' ';\n                if (flags & FLAG_ALT)\n                  *fbp++ = '#';\n#if __GLIBC__ >= 2 && !defined __UCLIBC__\n                if (flags & FLAG_LOCALIZED)\n                  *fbp++ = 'I';\n#endif\n                if (!pad_ourselves)\n                  {\n                    if (flags & FLAG_ZERO)\n                      *fbp++ = '0';\n                    if (dp->width_start != dp->width_end)\n                      {\n                        size_t n = dp->width_end - dp->width_start;\n                        /* The width specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }\n                if (!prec_ourselves)\n                  {\n                    if (dp->precision_start != dp->precision_end)\n                      {\n                        size_t n = dp->precision_end - dp->precision_start;\n                        /* The precision specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }\n\n                switch (type)\n                  {\n#if HAVE_LONG_LONG_INT\n                  case TYPE_LONGLONGINT:\n                  case TYPE_ULONGLONGINT:\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n                    *fbp++ = 'I';\n                    *fbp++ = '6';\n                    *fbp++ = '4';\n                    break;\n# else\n                    *fbp++ = 'l';\n                    /*FALLTHROUGH*/\n# endif\n#endif\n                  case TYPE_LONGINT:\n                  case TYPE_ULONGINT:\n#if HAVE_WINT_T\n                  case TYPE_WIDE_CHAR:\n#endif\n#if HAVE_WCHAR_T\n                  case TYPE_WIDE_STRING:\n#endif\n                    *fbp++ = 'l';\n                    break;\n                  case TYPE_LONGDOUBLE:\n                    *fbp++ = 'L';\n                    break;\n                  default:\n                    break;\n                  }\n#if NEED_PRINTF_DIRECTIVE_F\n                if (dp->conversion == 'F')\n                  *fbp = 'f';\n                else\n#endif\n                  *fbp = dp->conversion;\n#if USE_SNPRINTF\n# if !(((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)) && !defined __UCLIBC__) || ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__))\n                fbp[1] = '%';\n                fbp[2] = 'n';\n                fbp[3] = '\\0';\n# else\n                /* On glibc2 systems from glibc >= 2.3 - probably also older\n                   ones - we know that snprintf's return value conforms to\n                   ISO C 99: the tests gl_SNPRINTF_RETVAL_C99 and\n                   gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On glibc2 systems from 2004-10-18 or newer, the use of %n\n                   in format strings in writable memory may crash the program\n                   (if compiled with _FORTIFY_SOURCE=2), so we should avoid it\n                   in this situation.  */\n                /* On native Windows systems (such as mingw), we can avoid using\n                   %n because:\n                     - Although the gl_SNPRINTF_TRUNCATION_C99 test fails,\n                       snprintf does not write more than the specified number\n                       of bytes. (snprintf (buf, 3, \"%d %d\", 4567, 89) writes\n                       '4', '5', '6' into buf, not '4', '5', '\\0'.)\n                     - Although the gl_SNPRINTF_RETVAL_C99 test fails, snprintf\n                       allows us to recognize the case of an insufficient\n                       buffer size: it returns -1 in this case.\n                   On native Windows systems (such as mingw) where the OS is\n                   Windows Vista, the use of %n in format strings by default\n                   crashes the program. See\n                     <http://gcc.gnu.org/ml/gcc/2007-06/msg00122.html> and\n                     <http://msdn2.microsoft.com/en-us/library/ms175782(VS.80).aspx>\n                   So we should avoid %n in this situation.  */\n                fbp[1] = '\\0';\n# endif\n#else\n                fbp[1] = '\\0';\n#endif\n\n                /* Construct the arguments for calling snprintf or sprintf.  */\n                prefix_count = 0;\n                if (!pad_ourselves && dp->width_arg_index != ARG_NONE)\n                  {\n                    if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->width_arg_index].a.a_int;\n                  }\n                if (!prec_ourselves && dp->precision_arg_index != ARG_NONE)\n                  {\n                    if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->precision_arg_index].a.a_int;\n                  }\n\n#if USE_SNPRINTF\n                /* The SNPRINTF result is appended after result[0..length].\n                   The latter is an array of DCHAR_T; SNPRINTF appends an\n                   array of TCHAR_T to it.  This is possible because\n                   sizeof (TCHAR_T) divides sizeof (DCHAR_T) and\n                   alignof (TCHAR_T) <= alignof (DCHAR_T).  */\n# define TCHARS_PER_DCHAR (sizeof (DCHAR_T) / sizeof (TCHAR_T))\n                /* Ensure that maxlen below will be >= 2.  Needed on BeOS,\n                   where an snprintf() with maxlen==1 acts like sprintf().  */\n                ENSURE_ALLOCATION (xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR));\n                /* Prepare checking whether snprintf returns the count\n                   via %n.  */\n                *(TCHAR_T *) (result + length) = '\\0';\n#endif\n\n                orig_errno = errno;\n\n                for (;;)\n                  {\n                    int count = -1;\n\n#if USE_SNPRINTF\n                    int retcount = 0;\n                    size_t maxlen = allocated - length;\n                    /* SNPRINTF can fail if its second argument is\n                       > INT_MAX.  */\n                    if (maxlen > INT_MAX / TCHARS_PER_DCHAR)\n                      maxlen = INT_MAX / TCHARS_PER_DCHAR;\n                    maxlen = maxlen * TCHARS_PER_DCHAR;\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#else\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#endif\n\n                    errno = 0;\n                    switch (type)\n                      {\n                      case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      default:\n                        abort ();\n                      }\n\n#if USE_SNPRINTF\n                    /* Portability: Not all implementations of snprintf()\n                       are ISO C 99 compliant.  Determine the number of\n                       bytes that snprintf() has produced or would have\n                       produced.  */\n                    if (count >= 0)\n                      {\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }\n                    else\n                      {\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }\n#endif\n\n                    /* Attempt to handle failure.  */\n                    if (count < 0)\n                      {\n                        /* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */\n                        int saved_errno = errno;\n                        if (saved_errno == 0)\n                          {\n                            if (dp->conversion == 'c' || dp->conversion == 's')\n                              saved_errno = EILSEQ;\n                            else\n                              saved_errno = EINVAL;\n                          }\n\n                        if (!(result == resultbuf || result == NULL))\n                          free (result);\n                        if (buf_malloced != NULL)\n                          free (buf_malloced);\n                        CLEANUP ();\n\n                        errno = saved_errno;\n                        return NULL;\n                      }\n\n#if USE_SNPRINTF\n                    /* Handle overflow of the allocated buffer.\n                       If such an overflow occurs, a C99 compliant snprintf()\n                       returns a count >= maxlen.  However, a non-compliant\n                       snprintf() function returns only count = maxlen - 1.  To\n                       cover both cases, test whether count >= maxlen - 1.  */\n                    if ((unsigned int) count + 1 >= maxlen)\n                      {\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }\n#endif\n\n#if NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (prec_ourselves)\n                      {\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }\n#endif\n\n#if !USE_SNPRINTF\n                    if (count >= tmp_length)\n                      /* tmp_length was incorrectly calculated - fix the\n                         code above!  */\n                      abort ();\n#endif\n\n#if !DCHAR_IS_TCHAR\n                    /* Convert from TCHAR_T[] to DCHAR_T[].  */\n                    if (dp->conversion == 'c' || dp->conversion == 's')\n                      {\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }\n                    else\n                      {\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = *--tmpsrc;\n                          }\n                      }\n#endif\n\n#if DCHAR_IS_TCHAR && !USE_SNPRINTF\n                    /* Make room for the result.  */\n                    if (count > allocated - length)\n                      {\n                        /* Need at least count elements.  But allocate\n                           proportionally.  */\n                        size_t n =\n                          xmax (xsum (length, count), xtimes (allocated, 2));\n\n                        ENSURE_ALLOCATION (n);\n                      }\n#endif\n\n                    /* Here count <= allocated - length.  */\n\n                    /* Perform padding.  */\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (pad_ourselves && has_width)\n                      {\n                        size_t w;\n# if ENABLE_UNISTDIO\n                        /* Outside POSIX, it's preferable to compare the width\n                           against the number of _characters_ of the converted\n                           value.  */\n                        w = DCHAR_MBSNLEN (result + length, count);\n# else\n                        /* The width is compared against the number of _bytes_\n                           of the converted value, says POSIX.  */\n                        w = count;\n# endif\n                        if (w < width)\n                          {\n                            size_t pad = width - w;\n\n                            /* Make room for the result.  */\n                            if (xsum (count, pad) > allocated - length)\n                              {\n                                /* Need at least count + pad elements.  But\n                                   allocate proportionally.  */\n                                size_t n =\n                                  xmax (xsum3 (length, count, pad),\n                                        xtimes (allocated, 2));\n\n# if USE_SNPRINTF\n                                length += count;\n                                ENSURE_ALLOCATION (n);\n                                length -= count;\n# else\n                                ENSURE_ALLOCATION (n);\n# endif\n                              }\n                            /* Here count + pad <= allocated - length.  */\n\n                            {\n# if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                              DCHAR_T * const rp = result + length;\n# else\n                              DCHAR_T * const rp = tmp;\n# endif\n                              DCHAR_T *p = rp + count;\n                              DCHAR_T *end = p + pad;\n                              DCHAR_T *pad_ptr;\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                              if (dp->conversion == 'c'\n                                  || dp->conversion == 's')\n                                /* No zero-padding for string directives.  */\n                                pad_ptr = NULL;\n                              else\n# endif\n                                {\n                                  pad_ptr = (*rp == '-' ? rp + 1 : rp);\n                                  /* No zero-padding of \"inf\" and \"nan\".  */\n                                  if ((*pad_ptr >= 'A' && *pad_ptr <= 'Z')\n                                      || (*pad_ptr >= 'a' && *pad_ptr <= 'z'))\n                                    pad_ptr = NULL;\n                                }\n                              /* The generated string now extends from rp to p,\n                                 with the zero padding insertion point being at\n                                 pad_ptr.  */\n\n                              count = count + pad; /* = end - rp */\n\n                              if (flags & FLAG_LEFT)\n                                {\n                                  /* Pad with spaces on the right.  */\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                              else if ((flags & FLAG_ZERO) && pad_ptr != NULL)\n                                {\n                                  /* Pad with zeroes.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > pad_ptr)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = '0';\n                                }\n                              else\n                                {\n                                  /* Pad with spaces on the left.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > rp)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                            }\n                          }\n                      }\n#endif\n\n                    /* Here still count <= allocated - length.  */\n\n#if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                    /* The snprintf() result did fit.  */\n#else\n                    /* Append the sprintf() result.  */\n                    memcpy (result + length, tmp, count * sizeof (DCHAR_T));\n#endif\n#if !USE_SNPRINTF\n                    if (tmp != tmpbuf)\n                      free (tmp);\n#endif\n\n#if NEED_PRINTF_DIRECTIVE_F\n                    if (dp->conversion == 'F')\n                      {\n                        /* Convert the %f result to upper case for %F.  */\n                        DCHAR_T *rp = result + length;\n                        size_t rc;\n                        for (rc = count; rc > 0; rc--, rp++)\n                          if (*rp >= 'a' && *rp <= 'z')\n                            *rp = *rp - 'a' + 'A';\n                      }\n#endif\n\n                    length += count;\n                    break;\n                  }\n                errno = orig_errno;\n#undef pad_ourselves\n#undef prec_ourselves\n              }",
        "{",
        "0 });",
        "0",
        "})",
        "}",
        ")",
        ";",
        "int orig_errno;",
        "int",
        "orig_errno",
        ";",
        "#if !USE_SNPRINTF\n                size_t tmp_length;\n                TCHAR_T tmpbuf[700];\n                TCHAR_T *tmp;\n#endif",
        "#if",
        "!USE_SNPRINTF",
        "!",
        "USE_SNPRINTF",
        "\n",
        "size_t tmp_length;",
        "size_t",
        "tmp_length",
        ";",
        "TCHAR_T tmpbuf[700];",
        "TCHAR_T",
        "tmpbuf[700]",
        "tmpbuf",
        "[",
        "700",
        "]",
        ";",
        "TCHAR_T *tmp;",
        "TCHAR_T",
        "*tmp",
        "*",
        "tmp",
        ";",
        "#endif",
        "#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                has_width = 0;\n#endif",
        "#if",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO",
        "!DCHAR_IS_TCHAR",
        "!",
        "DCHAR_IS_TCHAR",
        "||",
        "ENABLE_UNISTDIO",
        "||",
        "NEED_PRINTF_FLAG_LEFTADJUST",
        "||",
        "NEED_PRINTF_FLAG_ZERO",
        "||",
        "NEED_PRINTF_UNBOUNDED_PRECISION",
        "\n",
        "has_width = 0;",
        "has_width = 0",
        "has_width",
        "=",
        "0",
        ";",
        "#endif",
        "#if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                width = 0;\n                if (dp->width_start != dp->width_end)\n                  {\n                    if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        width = arg;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    has_width = 1;\n#endif\n                  }\n#endif",
        "#if",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || !DCHAR_IS_TCHAR",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99",
        "!USE_SNPRINTF",
        "!",
        "USE_SNPRINTF",
        "||",
        "!HAVE_SNPRINTF_RETVAL_C99",
        "!",
        "HAVE_SNPRINTF_RETVAL_C99",
        "||",
        "!DCHAR_IS_TCHAR",
        "!",
        "DCHAR_IS_TCHAR",
        "||",
        "ENABLE_UNISTDIO",
        "||",
        "NEED_PRINTF_FLAG_LEFTADJUST",
        "||",
        "NEED_PRINTF_FLAG_ZERO",
        "||",
        "NEED_PRINTF_UNBOUNDED_PRECISION",
        "\n",
        "width = 0;",
        "width = 0",
        "width",
        "=",
        "0",
        ";",
        "if (dp->width_start != dp->width_end)\n                  {\n                    if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        width = arg;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    has_width = 1;\n#endif\n                  }",
        "if",
        "(dp->width_start != dp->width_end)",
        "(",
        "dp->width_start != dp->width_end",
        "dp->width_start",
        "dp",
        "->",
        "width_start",
        "!=",
        "dp->width_end",
        "dp",
        "->",
        "width_end",
        ")",
        "{\n                    if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        width = arg;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    has_width = 1;\n#endif\n                  }",
        "{",
        "if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        width = arg;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }",
        "if",
        "(dp->width_arg_index != ARG_NONE)",
        "(",
        "dp->width_arg_index != ARG_NONE",
        "dp->width_arg_index",
        "dp",
        "->",
        "width_arg_index",
        "!=",
        "ARG_NONE",
        ")",
        "{\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        width = arg;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }\n                      }",
        "{",
        "int arg;",
        "int",
        "arg",
        ";",
        "if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();",
        "if",
        "(!(a.arg[dp->width_arg_index].type == TYPE_INT))",
        "(",
        "!(a.arg[dp->width_arg_index].type == TYPE_INT)",
        "!",
        "(a.arg[dp->width_arg_index].type == TYPE_INT)",
        "(",
        "a.arg[dp->width_arg_index].type == TYPE_INT",
        "a.arg[dp->width_arg_index].type",
        "a.arg[dp->width_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->width_arg_index",
        "dp",
        "->",
        "width_arg_index",
        "]",
        ".",
        "type",
        "==",
        "TYPE_INT",
        ")",
        ")",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "arg = a.arg[dp->width_arg_index].a.a_int;",
        "arg = a.arg[dp->width_arg_index].a.a_int",
        "arg",
        "=",
        "a.arg[dp->width_arg_index].a.a_int",
        "a.arg[dp->width_arg_index].a",
        "a.arg[dp->width_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->width_arg_index",
        "dp",
        "->",
        "width_arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_int",
        ";",
        "width = arg;",
        "width = arg",
        "width",
        "=",
        "arg",
        ";",
        "if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }",
        "if",
        "(arg < 0)",
        "(",
        "arg < 0",
        "arg",
        "<",
        "0",
        ")",
        "{\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }",
        "{",
        "/* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */",
        "flags |= FLAG_LEFT;",
        "flags |= FLAG_LEFT",
        "flags",
        "|=",
        "FLAG_LEFT",
        ";",
        "width = -width;",
        "width = -width",
        "width",
        "=",
        "-width",
        "-",
        "width",
        ";",
        "}",
        "}",
        "else",
        "{\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }",
        "{",
        "const FCHAR_T *digitp = dp->width_start;",
        "const",
        "const",
        "FCHAR_T",
        "*digitp = dp->width_start",
        "*digitp",
        "*",
        "digitp",
        "=",
        "dp->width_start",
        "dp",
        "->",
        "width_start",
        ";",
        "do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);",
        "do",
        "width = xsum (xtimes (width, 10), *digitp++ - '0');",
        "width = xsum (xtimes (width, 10), *digitp++ - '0')",
        "width",
        "=",
        "xsum (xtimes (width, 10), *digitp++ - '0')",
        "xsum",
        "(xtimes (width, 10), *digitp++ - '0')",
        "(",
        "xtimes (width, 10)",
        "xtimes",
        "(width, 10)",
        "(",
        "width",
        ",",
        "10",
        ")",
        ",",
        "*digitp++ - '0'",
        "*digitp++",
        "*",
        "digitp++",
        "digitp",
        "++",
        "-",
        "'0'",
        "'",
        "'",
        ")",
        ";",
        "while",
        "(digitp != dp->width_end)",
        "(",
        "digitp != dp->width_end",
        "digitp",
        "!=",
        "dp->width_end",
        "dp",
        "->",
        "width_end",
        ")",
        ";",
        "}",
        "#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    has_width = 1;\n#endif",
        "#if",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO",
        "!DCHAR_IS_TCHAR",
        "!",
        "DCHAR_IS_TCHAR",
        "||",
        "ENABLE_UNISTDIO",
        "||",
        "NEED_PRINTF_FLAG_LEFTADJUST",
        "||",
        "NEED_PRINTF_FLAG_ZERO",
        "||",
        "NEED_PRINTF_UNBOUNDED_PRECISION",
        "\n",
        "has_width = 1;",
        "has_width = 1",
        "has_width",
        "=",
        "1",
        ";",
        "#endif",
        "}",
        "#endif",
        "#if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || NEED_PRINTF_UNBOUNDED_PRECISION\n                has_precision = 0;\n                precision = 6;\n                if (dp->precision_start != dp->precision_end)\n                  {\n                    if (dp->precision_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }\n                  }\n#endif",
        "#if",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || NEED_PRINTF_UNBOUNDED_PRECISION",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99",
        "!USE_SNPRINTF",
        "!",
        "USE_SNPRINTF",
        "||",
        "!HAVE_SNPRINTF_RETVAL_C99",
        "!",
        "HAVE_SNPRINTF_RETVAL_C99",
        "||",
        "NEED_PRINTF_UNBOUNDED_PRECISION",
        "\n",
        "has_precision = 0;",
        "has_precision = 0",
        "has_precision",
        "=",
        "0",
        ";",
        "precision = 6;",
        "precision = 6",
        "precision",
        "=",
        "6",
        ";",
        "if (dp->precision_start != dp->precision_end)\n                  {\n                    if (dp->precision_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }\n                  }",
        "if",
        "(dp->precision_start != dp->precision_end)",
        "(",
        "dp->precision_start != dp->precision_end",
        "dp->precision_start",
        "dp",
        "->",
        "precision_start",
        "!=",
        "dp->precision_end",
        "dp",
        "->",
        "precision_end",
        ")",
        "{\n                    if (dp->precision_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }\n                  }",
        "{",
        "if (dp->precision_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }",
        "if",
        "(dp->precision_arg_index != ARG_NONE)",
        "(",
        "dp->precision_arg_index != ARG_NONE",
        "dp->precision_arg_index",
        "dp",
        "->",
        "precision_arg_index",
        "!=",
        "ARG_NONE",
        ")",
        "{\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }",
        "{",
        "int arg;",
        "int",
        "arg",
        ";",
        "if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();",
        "if",
        "(!(a.arg[dp->precision_arg_index].type == TYPE_INT))",
        "(",
        "!(a.arg[dp->precision_arg_index].type == TYPE_INT)",
        "!",
        "(a.arg[dp->precision_arg_index].type == TYPE_INT)",
        "(",
        "a.arg[dp->precision_arg_index].type == TYPE_INT",
        "a.arg[dp->precision_arg_index].type",
        "a.arg[dp->precision_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->precision_arg_index",
        "dp",
        "->",
        "precision_arg_index",
        "]",
        ".",
        "type",
        "==",
        "TYPE_INT",
        ")",
        ")",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "arg = a.arg[dp->precision_arg_index].a.a_int;",
        "arg = a.arg[dp->precision_arg_index].a.a_int",
        "arg",
        "=",
        "a.arg[dp->precision_arg_index].a.a_int",
        "a.arg[dp->precision_arg_index].a",
        "a.arg[dp->precision_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->precision_arg_index",
        "dp",
        "->",
        "precision_arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_int",
        ";",
        "/* \"A negative precision is taken as if the precision\n                            were omitted.\"  */",
        "if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }",
        "if",
        "(arg >= 0)",
        "(",
        "arg >= 0",
        "arg",
        ">=",
        "0",
        ")",
        "{\n                            precision = arg;\n                            has_precision = 1;\n                          }",
        "{",
        "precision = arg;",
        "precision = arg",
        "precision",
        "=",
        "arg",
        ";",
        "has_precision = 1;",
        "has_precision = 1",
        "has_precision",
        "=",
        "1",
        ";",
        "}",
        "}",
        "else",
        "{\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }",
        "{",
        "const FCHAR_T *digitp = dp->precision_start + 1;",
        "const",
        "const",
        "FCHAR_T",
        "*digitp = dp->precision_start + 1",
        "*digitp",
        "*",
        "digitp",
        "=",
        "dp->precision_start + 1",
        "dp->precision_start",
        "dp",
        "->",
        "precision_start",
        "+",
        "1",
        ";",
        "precision = 0;",
        "precision = 0",
        "precision",
        "=",
        "0",
        ";",
        "while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');",
        "while",
        "(digitp != dp->precision_end)",
        "(",
        "digitp != dp->precision_end",
        "digitp",
        "!=",
        "dp->precision_end",
        "dp",
        "->",
        "precision_end",
        ")",
        "precision = xsum (xtimes (precision, 10), *digitp++ - '0');",
        "precision = xsum (xtimes (precision, 10), *digitp++ - '0')",
        "precision",
        "=",
        "xsum (xtimes (precision, 10), *digitp++ - '0')",
        "xsum",
        "(xtimes (precision, 10), *digitp++ - '0')",
        "(",
        "xtimes (precision, 10)",
        "xtimes",
        "(precision, 10)",
        "(",
        "precision",
        ",",
        "10",
        ")",
        ",",
        "*digitp++ - '0'",
        "*digitp++",
        "*",
        "digitp++",
        "digitp",
        "++",
        "-",
        "'0'",
        "'",
        "'",
        ")",
        ";",
        "has_precision = 1;",
        "has_precision = 1",
        "has_precision",
        "=",
        "1",
        ";",
        "}",
        "}",
        "#endif",
        "/* Decide whether to handle the precision ourselves.  */",
        "#if NEED_PRINTF_UNBOUNDED_PRECISION\n                switch (dp->conversion)\n                  {\n                  case 'd': case 'i': case 'u':\n                  case 'o':\n                  case 'x': case 'X': case 'p':\n                    prec_ourselves = has_precision && (precision > 0);\n                    break;\n                  default:\n                    prec_ourselves = 0;\n                    break;\n                  }\n#endif",
        "#if",
        "NEED_PRINTF_UNBOUNDED_PRECISION",
        "\n",
        "switch (dp->conversion)\n                  {\n                  case 'd': case 'i': case 'u':\n                  case 'o':\n                  case 'x': case 'X': case 'p':\n                    prec_ourselves = has_precision && (precision > 0);\n                    break;\n                  default:\n                    prec_ourselves = 0;\n                    break;\n                  }",
        "switch",
        "(dp->conversion)",
        "(",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        ")",
        "{\n                  case 'd': case 'i': case 'u':\n                  case 'o':\n                  case 'x': case 'X': case 'p':\n                    prec_ourselves = has_precision && (precision > 0);\n                    break;\n                  default:\n                    prec_ourselves = 0;\n                    break;\n                  }",
        "{",
        "case 'd':",
        "case",
        "'d'",
        "'",
        "'",
        ":",
        "case 'i':",
        "case",
        "'i'",
        "'",
        "'",
        ":",
        "case 'u':",
        "case",
        "'u'",
        "'",
        "'",
        ":",
        "case 'o':",
        "case",
        "'o'",
        "'",
        "'",
        ":",
        "case 'x':",
        "case",
        "'x'",
        "'",
        "'",
        ":",
        "case 'X':",
        "case",
        "'X'",
        "'",
        "'",
        ":",
        "case 'p':\n                    prec_ourselves = has_precision && (precision > 0);\n                    break;",
        "case",
        "'p'",
        "'",
        "'",
        ":",
        "prec_ourselves = has_precision && (precision > 0);",
        "prec_ourselves = has_precision && (precision > 0)",
        "prec_ourselves",
        "=",
        "has_precision && (precision > 0)",
        "has_precision",
        "&&",
        "(precision > 0)",
        "(",
        "precision > 0",
        "precision",
        ">",
        "0",
        ")",
        ";",
        "break;",
        "break",
        ";",
        "default:\n                    prec_ourselves = 0;\n                    break;",
        "default",
        ":",
        "prec_ourselves = 0;",
        "prec_ourselves = 0",
        "prec_ourselves",
        "=",
        "0",
        ";",
        "break;",
        "break",
        ";",
        "}",
        "#endif",
        "/* Decide whether to perform the padding ourselves.  */",
        "#if !NEED_PRINTF_FLAG_LEFTADJUST && (!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION)\n                switch (dp->conversion)\n                  {\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                  /* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */\n                  case 'c': case 's':\n# endif\n# if NEED_PRINTF_FLAG_ZERO\n                  case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                  case 'a': case 'A':\n# endif\n                    pad_ourselves = 1;\n                    break;\n                  default:\n                    pad_ourselves = prec_ourselves;\n                    break;\n                  }\n#endif",
        "#if",
        "!NEED_PRINTF_FLAG_LEFTADJUST && (!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION)",
        "!NEED_PRINTF_FLAG_LEFTADJUST",
        "!",
        "NEED_PRINTF_FLAG_LEFTADJUST",
        "&&",
        "(!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION)",
        "(",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO",
        "!DCHAR_IS_TCHAR",
        "!",
        "DCHAR_IS_TCHAR",
        "||",
        "ENABLE_UNISTDIO",
        "||",
        "NEED_PRINTF_FLAG_ZERO",
        "||",
        "NEED_PRINTF_UNBOUNDED_PRECISION",
        ")",
        "\n",
        "switch (dp->conversion)\n                  {\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                  /* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */\n                  case 'c': case 's':\n# endif\n# if NEED_PRINTF_FLAG_ZERO\n                  case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                  case 'a': case 'A':\n# endif\n                    pad_ourselves = 1;\n                    break;\n                  default:\n                    pad_ourselves = prec_ourselves;\n                    break;\n                  }",
        "switch",
        "(dp->conversion)",
        "(",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        ")",
        "{\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                  /* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */\n                  case 'c': case 's':\n# endif\n# if NEED_PRINTF_FLAG_ZERO\n                  case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                  case 'a': case 'A':\n# endif\n                    pad_ourselves = 1;\n                    break;\n                  default:\n                    pad_ourselves = prec_ourselves;\n                    break;\n                  }",
        "{",
        "# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                  /* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */\n                  case 'c': case 's':\n# endif",
        "# if",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO",
        "!DCHAR_IS_TCHAR",
        "!",
        "DCHAR_IS_TCHAR",
        "||",
        "ENABLE_UNISTDIO",
        "\n",
        "/* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */",
        "case 'c':",
        "case",
        "'c'",
        "'",
        "'",
        ":",
        "case 's':",
        "case",
        "'s'",
        "'",
        "'",
        ":",
        "# endif",
        "# if NEED_PRINTF_FLAG_ZERO\n                  case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                  case 'a': case 'A':\n# endif",
        "# if",
        "NEED_PRINTF_FLAG_ZERO",
        "\n",
        "case 'f':",
        "case",
        "'f'",
        "'",
        "'",
        ":",
        "case 'F':",
        "case",
        "'F'",
        "'",
        "'",
        ":",
        "case 'e':",
        "case",
        "'e'",
        "'",
        "'",
        ":",
        "case 'E':",
        "case",
        "'E'",
        "'",
        "'",
        ":",
        "case 'g':",
        "case",
        "'g'",
        "'",
        "'",
        ":",
        "case 'G':",
        "case",
        "'G'",
        "'",
        "'",
        ":",
        "case 'a':",
        "case",
        "'a'",
        "'",
        "'",
        ":",
        "case 'A':",
        "case",
        "'A'",
        "'",
        "'",
        ":",
        "# endif",
        "pad_ourselves = 1;",
        "pad_ourselves = 1",
        "pad_ourselves",
        "=",
        "1",
        ";",
        "break;",
        "break",
        ";",
        "default:\n                    pad_ourselves = prec_ourselves;\n                    break;",
        "default",
        ":",
        "pad_ourselves = prec_ourselves;",
        "pad_ourselves = prec_ourselves",
        "pad_ourselves",
        "=",
        "prec_ourselves",
        ";",
        "break;",
        "break",
        ";",
        "}",
        "#endif",
        "#if !USE_SNPRINTF\n                /* Allocate a temporary buffer of sufficient size for calling\n                   sprintf.  */\n                tmp_length =\n                  MAX_ROOM_NEEDED (&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves);\n\n                if (tmp_length <= sizeof (tmpbuf) / sizeof (TCHAR_T))\n                  tmp = tmpbuf;\n                else\n                  {\n                    size_t tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T));\n\n                    if (size_overflow_p (tmp_memsize))\n                      /* Overflow, would lead to out of memory.  */\n                      goto out_of_memory;\n                    tmp = (TCHAR_T *) malloc (tmp_memsize);\n                    if (tmp == NULL)\n                      /* Out of memory.  */\n                      goto out_of_memory;\n                  }\n#endif",
        "#if",
        "!USE_SNPRINTF",
        "!",
        "USE_SNPRINTF",
        "\n",
        "/* Allocate a temporary buffer of sufficient size for calling\n                   sprintf.  */",
        "tmp_length =\n                  MAX_ROOM_NEEDED (&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves);",
        "tmp_length =\n                  MAX_ROOM_NEEDED (&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves)",
        "tmp_length",
        "=",
        "MAX_ROOM_NEEDED (&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves)",
        "MAX_ROOM_NEEDED",
        "(&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves)",
        "(",
        "&a",
        "&",
        "a",
        ",",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        ",",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        ",",
        "type",
        ",",
        "flags",
        ",",
        "width",
        ",",
        "has_precision",
        ",",
        "precision",
        ",",
        "pad_ourselves",
        ")",
        ";",
        "if (tmp_length <= sizeof (tmpbuf) / sizeof (TCHAR_T))\n                  tmp = tmpbuf;\n                else\n                  {\n                    size_t tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T));\n\n                    if (size_overflow_p (tmp_memsize))\n                      /* Overflow, would lead to out of memory.  */\n                      goto out_of_memory;\n                    tmp = (TCHAR_T *) malloc (tmp_memsize);\n                    if (tmp == NULL)\n                      /* Out of memory.  */\n                      goto out_of_memory;\n                  }",
        "if",
        "(tmp_length <= sizeof (tmpbuf) / sizeof (TCHAR_T))",
        "(",
        "tmp_length <= sizeof (tmpbuf) / sizeof (TCHAR_T)",
        "tmp_length",
        "<=",
        "sizeof (tmpbuf) / sizeof (TCHAR_T)",
        "sizeof (tmpbuf)",
        "sizeof",
        "(",
        "tmpbuf",
        "tmpbuf",
        ")",
        "/",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        "tmp = tmpbuf;",
        "tmp = tmpbuf",
        "tmp",
        "=",
        "tmpbuf",
        ";",
        "else",
        "{\n                    size_t tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T));\n\n                    if (size_overflow_p (tmp_memsize))\n                      /* Overflow, would lead to out of memory.  */\n                      goto out_of_memory;\n                    tmp = (TCHAR_T *) malloc (tmp_memsize);\n                    if (tmp == NULL)\n                      /* Out of memory.  */\n                      goto out_of_memory;\n                  }",
        "{",
        "size_t tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T));",
        "size_t",
        "tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T))",
        "tmp_memsize",
        "=",
        "xtimes (tmp_length, sizeof (TCHAR_T))",
        "xtimes",
        "(tmp_length, sizeof (TCHAR_T))",
        "(",
        "tmp_length",
        ",",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        ";",
        "if (size_overflow_p (tmp_memsize))\n                      /* Overflow, would lead to out of memory.  */\n                      goto out_of_memory;",
        "if",
        "(size_overflow_p (tmp_memsize))",
        "(",
        "size_overflow_p (tmp_memsize)",
        "size_overflow_p",
        "(tmp_memsize)",
        "(",
        "tmp_memsize",
        ")",
        ")",
        "/* Overflow, would lead to out of memory.  */",
        "goto out_of_memory;",
        "goto",
        "out_of_memory",
        ";",
        "tmp = (TCHAR_T *) malloc (tmp_memsize);",
        "tmp = (TCHAR_T *) malloc (tmp_memsize)",
        "tmp",
        "=",
        "(TCHAR_T *) malloc (tmp_memsize)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "*",
        ")",
        "malloc (tmp_memsize)",
        "malloc",
        "(tmp_memsize)",
        "(",
        "tmp_memsize",
        ")",
        ";",
        "if (tmp == NULL)\n                      /* Out of memory.  */\n                      goto out_of_memory;",
        "if",
        "(tmp == NULL)",
        "(",
        "tmp == NULL",
        "tmp",
        "==",
        "NULL",
        ")",
        "/* Out of memory.  */",
        "goto out_of_memory;",
        "goto",
        "out_of_memory",
        ";",
        "}",
        "#endif",
        "/* Construct the format string for calling snprintf or\n                   sprintf.  */",
        "fbp = buf;",
        "fbp = buf",
        "fbp",
        "=",
        "buf",
        ";",
        "*fbp++ = '%';",
        "*fbp++ = '%'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'%'",
        "'",
        "'",
        ";",
        "#if NEED_PRINTF_FLAG_GROUPING\n                /* The underlying implementation doesn't support the ' flag.\n                   Produce no grouping characters in this case; this is\n                   acceptable because the grouping is locale dependent.  */\n#else\n                if (flags & FLAG_GROUP)\n                  *fbp++ = '\\'';\n#endif",
        "#if",
        "NEED_PRINTF_FLAG_GROUPING",
        "\n",
        "/* The underlying implementation doesn't support the ' flag.\n                   Produce no grouping characters in this case; this is\n                   acceptable because the grouping is locale dependent.  */",
        "#else\n                if (flags & FLAG_GROUP)\n                  *fbp++ = '\\'';",
        "#else",
        "if (flags & FLAG_GROUP)\n                  *fbp++ = '\\'';",
        "if",
        "(flags & FLAG_GROUP)",
        "(",
        "flags & FLAG_GROUP",
        "flags",
        "&",
        "FLAG_GROUP",
        ")",
        "*fbp++ = '\\'';",
        "*fbp++ = '\\''",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'\\''",
        "'",
        "\\'",
        "'",
        ";",
        "#endif",
        "if (flags & FLAG_LEFT)\n                  *fbp++ = '-';",
        "if",
        "(flags & FLAG_LEFT)",
        "(",
        "flags & FLAG_LEFT",
        "flags",
        "&",
        "FLAG_LEFT",
        ")",
        "*fbp++ = '-';",
        "*fbp++ = '-'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'-'",
        "'",
        "'",
        ";",
        "if (flags & FLAG_SHOWSIGN)\n                  *fbp++ = '+';",
        "if",
        "(flags & FLAG_SHOWSIGN)",
        "(",
        "flags & FLAG_SHOWSIGN",
        "flags",
        "&",
        "FLAG_SHOWSIGN",
        ")",
        "*fbp++ = '+';",
        "*fbp++ = '+'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'+'",
        "'",
        "'",
        ";",
        "if (flags & FLAG_SPACE)\n                  *fbp++ = ' ';",
        "if",
        "(flags & FLAG_SPACE)",
        "(",
        "flags & FLAG_SPACE",
        "flags",
        "&",
        "FLAG_SPACE",
        ")",
        "*fbp++ = ' ';",
        "*fbp++ = ' '",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "' '",
        "'",
        "'",
        ";",
        "if (flags & FLAG_ALT)\n                  *fbp++ = '#';",
        "if",
        "(flags & FLAG_ALT)",
        "(",
        "flags & FLAG_ALT",
        "flags",
        "&",
        "FLAG_ALT",
        ")",
        "*fbp++ = '#';",
        "*fbp++ = '#'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'#'",
        "'",
        "'",
        ";",
        "#if __GLIBC__ >= 2 && !defined __UCLIBC__\n                if (flags & FLAG_LOCALIZED)\n                  *fbp++ = 'I';\n#endif",
        "#if",
        "__GLIBC__ >= 2 && !defined __UCLIBC__",
        "__GLIBC__ >= 2",
        "__GLIBC__",
        ">=",
        "2",
        "&&",
        "!defined __UCLIBC__",
        "!",
        "defined __UCLIBC__",
        "defined",
        "__UCLIBC__",
        "\n",
        "if (flags & FLAG_LOCALIZED)\n                  *fbp++ = 'I';",
        "if",
        "(flags & FLAG_LOCALIZED)",
        "(",
        "flags & FLAG_LOCALIZED",
        "flags",
        "&",
        "FLAG_LOCALIZED",
        ")",
        "*fbp++ = 'I';",
        "*fbp++ = 'I'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'I'",
        "'",
        "'",
        ";",
        "#endif",
        "if (!pad_ourselves)\n                  {\n                    if (flags & FLAG_ZERO)\n                      *fbp++ = '0';\n                    if (dp->width_start != dp->width_end)\n                      {\n                        size_t n = dp->width_end - dp->width_start;\n                        /* The width specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }",
        "if",
        "(!pad_ourselves)",
        "(",
        "!pad_ourselves",
        "!",
        "pad_ourselves",
        ")",
        "{\n                    if (flags & FLAG_ZERO)\n                      *fbp++ = '0';\n                    if (dp->width_start != dp->width_end)\n                      {\n                        size_t n = dp->width_end - dp->width_start;\n                        /* The width specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }",
        "{",
        "if (flags & FLAG_ZERO)\n                      *fbp++ = '0';",
        "if",
        "(flags & FLAG_ZERO)",
        "(",
        "flags & FLAG_ZERO",
        "flags",
        "&",
        "FLAG_ZERO",
        ")",
        "*fbp++ = '0';",
        "*fbp++ = '0'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'0'",
        "'",
        "'",
        ";",
        "if (dp->width_start != dp->width_end)\n                      {\n                        size_t n = dp->width_end - dp->width_start;\n                        /* The width specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }",
        "if",
        "(dp->width_start != dp->width_end)",
        "(",
        "dp->width_start != dp->width_end",
        "dp->width_start",
        "dp",
        "->",
        "width_start",
        "!=",
        "dp->width_end",
        "dp",
        "->",
        "width_end",
        ")",
        "{\n                        size_t n = dp->width_end - dp->width_start;\n                        /* The width specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }",
        "{",
        "size_t n = dp->width_end - dp->width_start;",
        "size_t",
        "n = dp->width_end - dp->width_start",
        "n",
        "=",
        "dp->width_end - dp->width_start",
        "dp->width_end",
        "dp",
        "->",
        "width_end",
        "-",
        "dp->width_start",
        "dp",
        "->",
        "width_start",
        ";",
        "/* The width specification is known to consist only\n                           of standard ASCII characters.  */",
        "if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }",
        "if",
        "(sizeof (FCHAR_T) == sizeof (TCHAR_T))",
        "(",
        "sizeof (FCHAR_T) == sizeof (TCHAR_T)",
        "sizeof (FCHAR_T)",
        "sizeof",
        "(FCHAR_T)",
        "(",
        "FCHAR_T",
        ")",
        "==",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        "{\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }",
        "{",
        "memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));",
        "memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T))",
        "memcpy",
        "(fbp, dp->width_start, n * sizeof (TCHAR_T))",
        "(",
        "fbp",
        ",",
        "dp->width_start",
        "dp",
        "->",
        "width_start",
        ",",
        "n * sizeof (TCHAR_T)",
        "n",
        "*",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        ";",
        "fbp += n;",
        "fbp += n",
        "fbp",
        "+=",
        "n",
        ";",
        "}",
        "else",
        "{\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }",
        "{",
        "const FCHAR_T *mp = dp->width_start;",
        "const",
        "const",
        "FCHAR_T",
        "*mp = dp->width_start",
        "*mp",
        "*",
        "mp",
        "=",
        "dp->width_start",
        "dp",
        "->",
        "width_start",
        ";",
        "do\n                              *fbp++ = *mp++;\n                            while (--n > 0);",
        "do",
        "*fbp++ = *mp++;",
        "*fbp++ = *mp++",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "*mp++",
        "*",
        "mp++",
        "mp",
        "++",
        ";",
        "while",
        "(--n > 0)",
        "(",
        "--n > 0",
        "--n",
        "--",
        "n",
        ">",
        "0",
        ")",
        ";",
        "}",
        "}",
        "}",
        "if (!prec_ourselves)\n                  {\n                    if (dp->precision_start != dp->precision_end)\n                      {\n                        size_t n = dp->precision_end - dp->precision_start;\n                        /* The precision specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }",
        "if",
        "(!prec_ourselves)",
        "(",
        "!prec_ourselves",
        "!",
        "prec_ourselves",
        ")",
        "{\n                    if (dp->precision_start != dp->precision_end)\n                      {\n                        size_t n = dp->precision_end - dp->precision_start;\n                        /* The precision specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }",
        "{",
        "if (dp->precision_start != dp->precision_end)\n                      {\n                        size_t n = dp->precision_end - dp->precision_start;\n                        /* The precision specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }",
        "if",
        "(dp->precision_start != dp->precision_end)",
        "(",
        "dp->precision_start != dp->precision_end",
        "dp->precision_start",
        "dp",
        "->",
        "precision_start",
        "!=",
        "dp->precision_end",
        "dp",
        "->",
        "precision_end",
        ")",
        "{\n                        size_t n = dp->precision_end - dp->precision_start;\n                        /* The precision specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }",
        "{",
        "size_t n = dp->precision_end - dp->precision_start;",
        "size_t",
        "n = dp->precision_end - dp->precision_start",
        "n",
        "=",
        "dp->precision_end - dp->precision_start",
        "dp->precision_end",
        "dp",
        "->",
        "precision_end",
        "-",
        "dp->precision_start",
        "dp",
        "->",
        "precision_start",
        ";",
        "/* The precision specification is known to consist only\n                           of standard ASCII characters.  */",
        "if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }",
        "if",
        "(sizeof (FCHAR_T) == sizeof (TCHAR_T))",
        "(",
        "sizeof (FCHAR_T) == sizeof (TCHAR_T)",
        "sizeof (FCHAR_T)",
        "sizeof",
        "(FCHAR_T)",
        "(",
        "FCHAR_T",
        ")",
        "==",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        "{\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }",
        "{",
        "memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));",
        "memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T))",
        "memcpy",
        "(fbp, dp->precision_start, n * sizeof (TCHAR_T))",
        "(",
        "fbp",
        ",",
        "dp->precision_start",
        "dp",
        "->",
        "precision_start",
        ",",
        "n * sizeof (TCHAR_T)",
        "n",
        "*",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        ";",
        "fbp += n;",
        "fbp += n",
        "fbp",
        "+=",
        "n",
        ";",
        "}",
        "else",
        "{\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }",
        "{",
        "const FCHAR_T *mp = dp->precision_start;",
        "const",
        "const",
        "FCHAR_T",
        "*mp = dp->precision_start",
        "*mp",
        "*",
        "mp",
        "=",
        "dp->precision_start",
        "dp",
        "->",
        "precision_start",
        ";",
        "do\n                              *fbp++ = *mp++;\n                            while (--n > 0);",
        "do",
        "*fbp++ = *mp++;",
        "*fbp++ = *mp++",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "*mp++",
        "*",
        "mp++",
        "mp",
        "++",
        ";",
        "while",
        "(--n > 0)",
        "(",
        "--n > 0",
        "--n",
        "--",
        "n",
        ">",
        "0",
        ")",
        ";",
        "}",
        "}",
        "}",
        "switch (type)\n                  {\n#if HAVE_LONG_LONG_INT\n                  case TYPE_LONGLONGINT:\n                  case TYPE_ULONGLONGINT:\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n                    *fbp++ = 'I';\n                    *fbp++ = '6';\n                    *fbp++ = '4';\n                    break;\n# else\n                    *fbp++ = 'l';\n                    /*FALLTHROUGH*/\n# endif\n#endif\n                  case TYPE_LONGINT:\n                  case TYPE_ULONGINT:\n#if HAVE_WINT_T\n                  case TYPE_WIDE_CHAR:\n#endif\n#if HAVE_WCHAR_T\n                  case TYPE_WIDE_STRING:\n#endif\n                    *fbp++ = 'l';\n                    break;\n                  case TYPE_LONGDOUBLE:\n                    *fbp++ = 'L';\n                    break;\n                  default:\n                    break;\n                  }",
        "switch",
        "(type)",
        "(",
        "type",
        ")",
        "{\n#if HAVE_LONG_LONG_INT\n                  case TYPE_LONGLONGINT:\n                  case TYPE_ULONGLONGINT:\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n                    *fbp++ = 'I';\n                    *fbp++ = '6';\n                    *fbp++ = '4';\n                    break;\n# else\n                    *fbp++ = 'l';\n                    /*FALLTHROUGH*/\n# endif\n#endif\n                  case TYPE_LONGINT:\n                  case TYPE_ULONGINT:\n#if HAVE_WINT_T\n                  case TYPE_WIDE_CHAR:\n#endif\n#if HAVE_WCHAR_T\n                  case TYPE_WIDE_STRING:\n#endif\n                    *fbp++ = 'l';\n                    break;\n                  case TYPE_LONGDOUBLE:\n                    *fbp++ = 'L';\n                    break;\n                  default:\n                    break;\n                  }",
        "{",
        "#if HAVE_LONG_LONG_INT\n                  case TYPE_LONGLONGINT:\n                  case TYPE_ULONGLONGINT:\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n                    *fbp++ = 'I';\n                    *fbp++ = '6';\n                    *fbp++ = '4';\n                    break;\n# else\n                    *fbp++ = 'l';\n                    /*FALLTHROUGH*/\n# endif\n#endif",
        "#if",
        "HAVE_LONG_LONG_INT",
        "\n",
        "case TYPE_LONGLONGINT:",
        "case",
        "TYPE_LONGLONGINT",
        ":",
        "case TYPE_ULONGLONGINT:",
        "case",
        "TYPE_ULONGLONGINT",
        ":",
        "# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n                    *fbp++ = 'I';\n                    *fbp++ = '6';\n                    *fbp++ = '4';\n                    break;\n# else\n                    *fbp++ = 'l';\n                    /*FALLTHROUGH*/\n# endif",
        "# if",
        "(defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__",
        "(defined _WIN32 || defined __WIN32__)",
        "(",
        "defined _WIN32 || defined __WIN32__",
        "defined _WIN32",
        "defined",
        "_WIN32",
        "||",
        "defined __WIN32__",
        "defined",
        "__WIN32__",
        ")",
        "&&",
        "! defined __CYGWIN__",
        "!",
        "defined __CYGWIN__",
        "defined",
        "__CYGWIN__",
        "\n",
        "*fbp++ = 'I';",
        "*fbp++ = 'I'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'I'",
        "'",
        "'",
        ";",
        "*fbp++ = '6';",
        "*fbp++ = '6'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'6'",
        "'",
        "'",
        ";",
        "*fbp++ = '4';",
        "*fbp++ = '4'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'4'",
        "'",
        "'",
        ";",
        "break;",
        "break",
        ";",
        "# else\n                    *fbp++ = 'l';",
        "# else",
        "*fbp++ = 'l';",
        "*fbp++ = 'l'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'l'",
        "'",
        "'",
        ";",
        "/*FALLTHROUGH*/",
        "# endif",
        "#endif",
        "case TYPE_LONGINT:",
        "case",
        "TYPE_LONGINT",
        ":",
        "case TYPE_ULONGINT:",
        "case",
        "TYPE_ULONGINT",
        ":",
        "#if HAVE_WINT_T\n                  case TYPE_WIDE_CHAR:\n#endif",
        "#if",
        "HAVE_WINT_T",
        "\n",
        "case TYPE_WIDE_CHAR:",
        "case",
        "TYPE_WIDE_CHAR",
        ":",
        "#endif",
        "#if HAVE_WCHAR_T\n                  case TYPE_WIDE_STRING:\n#endif",
        "#if",
        "HAVE_WCHAR_T",
        "\n",
        "case TYPE_WIDE_STRING:",
        "case",
        "TYPE_WIDE_STRING",
        ":",
        "#endif",
        "*fbp++ = 'l';",
        "*fbp++ = 'l'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'l'",
        "'",
        "'",
        ";",
        "break;",
        "break",
        ";",
        "case TYPE_LONGDOUBLE:\n                    *fbp++ = 'L';\n                    break;",
        "case",
        "TYPE_LONGDOUBLE",
        ":",
        "*fbp++ = 'L';",
        "*fbp++ = 'L'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'L'",
        "'",
        "'",
        ";",
        "break;",
        "break",
        ";",
        "default:\n                    break;",
        "default",
        ":",
        "break;",
        "break",
        ";",
        "}",
        "#if NEED_PRINTF_DIRECTIVE_F\n                if (dp->conversion == 'F')\n                  *fbp = 'f';\n                else\n#endif",
        "#if",
        "NEED_PRINTF_DIRECTIVE_F",
        "\n",
        "if (dp->conversion == 'F')\n                  *fbp = 'f';",
        "if",
        "(dp->conversion == 'F')",
        "(",
        "dp->conversion == 'F'",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        "==",
        "'F'",
        "'",
        "'",
        ")",
        "*fbp = 'f';",
        "*fbp = 'f'",
        "*fbp",
        "*",
        "fbp",
        "=",
        "'f'",
        "'",
        "'",
        ";",
        "else",
        "else",
        "#endif",
        "*fbp = dp->conversion;",
        "*fbp = dp->conversion",
        "*fbp",
        "*",
        "fbp",
        "=",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        ";",
        "#if USE_SNPRINTF\n# if !(((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)) && !defined __UCLIBC__) || ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__))\n                fbp[1] = '%';\n                fbp[2] = 'n';\n                fbp[3] = '\\0';\n# else\n                /* On glibc2 systems from glibc >= 2.3 - probably also older\n                   ones - we know that snprintf's return value conforms to\n                   ISO C 99: the tests gl_SNPRINTF_RETVAL_C99 and\n                   gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On glibc2 systems from 2004-10-18 or newer, the use of %n\n                   in format strings in writable memory may crash the program\n                   (if compiled with _FORTIFY_SOURCE=2), so we should avoid it\n                   in this situation.  */\n                /* On native Windows systems (such as mingw), we can avoid using\n                   %n because:\n                     - Although the gl_SNPRINTF_TRUNCATION_C99 test fails,\n                       snprintf does not write more than the specified number\n                       of bytes. (snprintf (buf, 3, \"%d %d\", 4567, 89) writes\n                       '4', '5', '6' into buf, not '4', '5', '\\0'.)\n                     - Although the gl_SNPRINTF_RETVAL_C99 test fails, snprintf\n                       allows us to recognize the case of an insufficient\n                       buffer size: it returns -1 in this case.\n                   On native Windows systems (such as mingw) where the OS is\n                   Windows Vista, the use of %n in format strings by default\n                   crashes the program. See\n                     <http://gcc.gnu.org/ml/gcc/2007-06/msg00122.html> and\n                     <http://msdn2.microsoft.com/en-us/library/ms175782(VS.80).aspx>\n                   So we should avoid %n in this situation.  */\n                fbp[1] = '\\0';\n# endif\n#else\n                fbp[1] = '\\0';\n#endif",
        "#if",
        "USE_SNPRINTF",
        "\n",
        "# if !(((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)) && !defined __UCLIBC__) || ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__))\n                fbp[1] = '%';\n                fbp[2] = 'n';\n                fbp[3] = '\\0';\n# else\n                /* On glibc2 systems from glibc >= 2.3 - probably also older\n                   ones - we know that snprintf's return value conforms to\n                   ISO C 99: the tests gl_SNPRINTF_RETVAL_C99 and\n                   gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On glibc2 systems from 2004-10-18 or newer, the use of %n\n                   in format strings in writable memory may crash the program\n                   (if compiled with _FORTIFY_SOURCE=2), so we should avoid it\n                   in this situation.  */\n                /* On native Windows systems (such as mingw), we can avoid using\n                   %n because:\n                     - Although the gl_SNPRINTF_TRUNCATION_C99 test fails,\n                       snprintf does not write more than the specified number\n                       of bytes. (snprintf (buf, 3, \"%d %d\", 4567, 89) writes\n                       '4', '5', '6' into buf, not '4', '5', '\\0'.)\n                     - Although the gl_SNPRINTF_RETVAL_C99 test fails, snprintf\n                       allows us to recognize the case of an insufficient\n                       buffer size: it returns -1 in this case.\n                   On native Windows systems (such as mingw) where the OS is\n                   Windows Vista, the use of %n in format strings by default\n                   crashes the program. See\n                     <http://gcc.gnu.org/ml/gcc/2007-06/msg00122.html> and\n                     <http://msdn2.microsoft.com/en-us/library/ms175782(VS.80).aspx>\n                   So we should avoid %n in this situation.  */\n                fbp[1] = '\\0';\n# endif",
        "# if",
        "!(((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)) && !defined __UCLIBC__) || ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__))",
        "!",
        "(((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)) && !defined __UCLIBC__) || ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__))",
        "(",
        "((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)) && !defined __UCLIBC__) || ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__)",
        "((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)) && !defined __UCLIBC__)",
        "(",
        "(__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)) && !defined __UCLIBC__",
        "(__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3))",
        "(",
        "__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)",
        "__GLIBC__ > 2",
        "__GLIBC__",
        ">",
        "2",
        "||",
        "(__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)",
        "(",
        "__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3",
        "__GLIBC__ == 2",
        "__GLIBC__",
        "==",
        "2",
        "&&",
        "__GLIBC_MINOR__ >= 3",
        "__GLIBC_MINOR__",
        ">=",
        "3",
        ")",
        ")",
        "&&",
        "!defined __UCLIBC__",
        "!",
        "defined __UCLIBC__",
        "defined",
        "__UCLIBC__",
        ")",
        "||",
        "((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__)",
        "(",
        "(defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__",
        "(defined _WIN32 || defined __WIN32__)",
        "(",
        "defined _WIN32 || defined __WIN32__",
        "defined _WIN32",
        "defined",
        "_WIN32",
        "||",
        "defined __WIN32__",
        "defined",
        "__WIN32__",
        ")",
        "&&",
        "! defined __CYGWIN__",
        "!",
        "defined __CYGWIN__",
        "defined",
        "__CYGWIN__",
        ")",
        ")",
        "\n",
        "fbp[1] = '%';",
        "fbp[1] = '%'",
        "fbp[1]",
        "fbp",
        "[",
        "1",
        "]",
        "=",
        "'%'",
        "'",
        "'",
        ";",
        "fbp[2] = 'n';",
        "fbp[2] = 'n'",
        "fbp[2]",
        "fbp",
        "[",
        "2",
        "]",
        "=",
        "'n'",
        "'",
        "'",
        ";",
        "fbp[3] = '\\0';",
        "fbp[3] = '\\0'",
        "fbp[3]",
        "fbp",
        "[",
        "3",
        "]",
        "=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ";",
        "# else\n                /* On glibc2 systems from glibc >= 2.3 - probably also older\n                   ones - we know that snprintf's return value conforms to\n                   ISO C 99: the tests gl_SNPRINTF_RETVAL_C99 and\n                   gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On glibc2 systems from 2004-10-18 or newer, the use of %n\n                   in format strings in writable memory may crash the program\n                   (if compiled with _FORTIFY_SOURCE=2), so we should avoid it\n                   in this situation.  */\n                /* On native Windows systems (such as mingw), we can avoid using\n                   %n because:\n                     - Although the gl_SNPRINTF_TRUNCATION_C99 test fails,\n                       snprintf does not write more than the specified number\n                       of bytes. (snprintf (buf, 3, \"%d %d\", 4567, 89) writes\n                       '4', '5', '6' into buf, not '4', '5', '\\0'.)\n                     - Although the gl_SNPRINTF_RETVAL_C99 test fails, snprintf\n                       allows us to recognize the case of an insufficient\n                       buffer size: it returns -1 in this case.\n                   On native Windows systems (such as mingw) where the OS is\n                   Windows Vista, the use of %n in format strings by default\n                   crashes the program. See\n                     <http://gcc.gnu.org/ml/gcc/2007-06/msg00122.html> and\n                     <http://msdn2.microsoft.com/en-us/library/ms175782(VS.80).aspx>\n                   So we should avoid %n in this situation.  */\n                fbp[1] = '\\0';",
        "# else",
        "/* On glibc2 systems from glibc >= 2.3 - probably also older\n                   ones - we know that snprintf's return value conforms to\n                   ISO C 99: the tests gl_SNPRINTF_RETVAL_C99 and\n                   gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On glibc2 systems from 2004-10-18 or newer, the use of %n\n                   in format strings in writable memory may crash the program\n                   (if compiled with _FORTIFY_SOURCE=2), so we should avoid it\n                   in this situation.  */",
        "/* On native Windows systems (such as mingw), we can avoid using\n                   %n because:\n                     - Although the gl_SNPRINTF_TRUNCATION_C99 test fails,\n                       snprintf does not write more than the specified number\n                       of bytes. (snprintf (buf, 3, \"%d %d\", 4567, 89) writes\n                       '4', '5', '6' into buf, not '4', '5', '\\0'.)\n                     - Although the gl_SNPRINTF_RETVAL_C99 test fails, snprintf\n                       allows us to recognize the case of an insufficient\n                       buffer size: it returns -1 in this case.\n                   On native Windows systems (such as mingw) where the OS is\n                   Windows Vista, the use of %n in format strings by default\n                   crashes the program. See\n                     <http://gcc.gnu.org/ml/gcc/2007-06/msg00122.html> and\n                     <http://msdn2.microsoft.com/en-us/library/ms175782(VS.80).aspx>\n                   So we should avoid %n in this situation.  */",
        "fbp[1] = '\\0';",
        "fbp[1] = '\\0'",
        "fbp[1]",
        "fbp",
        "[",
        "1",
        "]",
        "=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ";",
        "# endif",
        "#else\n                fbp[1] = '\\0';",
        "#else",
        "fbp[1] = '\\0';",
        "fbp[1] = '\\0'",
        "fbp[1]",
        "fbp",
        "[",
        "1",
        "]",
        "=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ";",
        "#endif",
        "/* Construct the arguments for calling snprintf or sprintf.  */",
        "prefix_count = 0;",
        "prefix_count = 0",
        "prefix_count",
        "=",
        "0",
        ";",
        "if (!pad_ourselves && dp->width_arg_index != ARG_NONE)\n                  {\n                    if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->width_arg_index].a.a_int;\n                  }",
        "if",
        "(!pad_ourselves && dp->width_arg_index != ARG_NONE)",
        "(",
        "!pad_ourselves && dp->width_arg_index != ARG_NONE",
        "!pad_ourselves",
        "!",
        "pad_ourselves",
        "&&",
        "dp->width_arg_index != ARG_NONE",
        "dp->width_arg_index",
        "dp",
        "->",
        "width_arg_index",
        "!=",
        "ARG_NONE",
        ")",
        "{\n                    if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->width_arg_index].a.a_int;\n                  }",
        "{",
        "if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                      abort ();",
        "if",
        "(!(a.arg[dp->width_arg_index].type == TYPE_INT))",
        "(",
        "!(a.arg[dp->width_arg_index].type == TYPE_INT)",
        "!",
        "(a.arg[dp->width_arg_index].type == TYPE_INT)",
        "(",
        "a.arg[dp->width_arg_index].type == TYPE_INT",
        "a.arg[dp->width_arg_index].type",
        "a.arg[dp->width_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->width_arg_index",
        "dp",
        "->",
        "width_arg_index",
        "]",
        ".",
        "type",
        "==",
        "TYPE_INT",
        ")",
        ")",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "prefixes[prefix_count++] = a.arg[dp->width_arg_index].a.a_int;",
        "prefixes[prefix_count++] = a.arg[dp->width_arg_index].a.a_int",
        "prefixes[prefix_count++]",
        "prefixes",
        "[",
        "prefix_count++",
        "prefix_count",
        "++",
        "]",
        "=",
        "a.arg[dp->width_arg_index].a.a_int",
        "a.arg[dp->width_arg_index].a",
        "a.arg[dp->width_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->width_arg_index",
        "dp",
        "->",
        "width_arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_int",
        ";",
        "}",
        "if (!prec_ourselves && dp->precision_arg_index != ARG_NONE)\n                  {\n                    if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->precision_arg_index].a.a_int;\n                  }",
        "if",
        "(!prec_ourselves && dp->precision_arg_index != ARG_NONE)",
        "(",
        "!prec_ourselves && dp->precision_arg_index != ARG_NONE",
        "!prec_ourselves",
        "!",
        "prec_ourselves",
        "&&",
        "dp->precision_arg_index != ARG_NONE",
        "dp->precision_arg_index",
        "dp",
        "->",
        "precision_arg_index",
        "!=",
        "ARG_NONE",
        ")",
        "{\n                    if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->precision_arg_index].a.a_int;\n                  }",
        "{",
        "if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                      abort ();",
        "if",
        "(!(a.arg[dp->precision_arg_index].type == TYPE_INT))",
        "(",
        "!(a.arg[dp->precision_arg_index].type == TYPE_INT)",
        "!",
        "(a.arg[dp->precision_arg_index].type == TYPE_INT)",
        "(",
        "a.arg[dp->precision_arg_index].type == TYPE_INT",
        "a.arg[dp->precision_arg_index].type",
        "a.arg[dp->precision_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->precision_arg_index",
        "dp",
        "->",
        "precision_arg_index",
        "]",
        ".",
        "type",
        "==",
        "TYPE_INT",
        ")",
        ")",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "prefixes[prefix_count++] = a.arg[dp->precision_arg_index].a.a_int;",
        "prefixes[prefix_count++] = a.arg[dp->precision_arg_index].a.a_int",
        "prefixes[prefix_count++]",
        "prefixes",
        "[",
        "prefix_count++",
        "prefix_count",
        "++",
        "]",
        "=",
        "a.arg[dp->precision_arg_index].a.a_int",
        "a.arg[dp->precision_arg_index].a",
        "a.arg[dp->precision_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->precision_arg_index",
        "dp",
        "->",
        "precision_arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_int",
        ";",
        "}",
        "#if USE_SNPRINTF\n                /* The SNPRINTF result is appended after result[0..length].\n                   The latter is an array of DCHAR_T; SNPRINTF appends an\n                   array of TCHAR_T to it.  This is possible because\n                   sizeof (TCHAR_T) divides sizeof (DCHAR_T) and\n                   alignof (TCHAR_T) <= alignof (DCHAR_T).  */\n# define TCHARS_PER_DCHAR (sizeof (DCHAR_T) / sizeof (TCHAR_T))\n                /* Ensure that maxlen below will be >= 2.  Needed on BeOS,\n                   where an snprintf() with maxlen==1 acts like sprintf().  */\n                ENSURE_ALLOCATION (xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR));\n                /* Prepare checking whether snprintf returns the count\n                   via %n.  */\n                *(TCHAR_T *) (result + length) = '\\0';\n#endif",
        "#if",
        "USE_SNPRINTF",
        "\n",
        "/* The SNPRINTF result is appended after result[0..length].\n                   The latter is an array of DCHAR_T; SNPRINTF appends an\n                   array of TCHAR_T to it.  This is possible because\n                   sizeof (TCHAR_T) divides sizeof (DCHAR_T) and\n                   alignof (TCHAR_T) <= alignof (DCHAR_T).  */",
        "# define TCHARS_PER_DCHAR (sizeof (DCHAR_T) / sizeof (TCHAR_T))\n",
        "# define",
        "TCHARS_PER_DCHAR",
        " (sizeof (DCHAR_T) / sizeof (TCHAR_T))",
        "\n",
        "/* Ensure that maxlen below will be >= 2.  Needed on BeOS,\n                   where an snprintf() with maxlen==1 acts like sprintf().  */",
        "ENSURE_ALLOCATION (xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR));",
        "ENSURE_ALLOCATION (xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR))",
        "ENSURE_ALLOCATION",
        "(xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR))",
        "(",
        "xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR)",
        "xsum",
        "(length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR)",
        "(",
        "length",
        ",",
        "(2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR",
        "(2 + TCHARS_PER_DCHAR - 1)",
        "(",
        "2 + TCHARS_PER_DCHAR - 1",
        "2 + TCHARS_PER_DCHAR",
        "2",
        "+",
        "TCHARS_PER_DCHAR",
        "-",
        "1",
        ")",
        "/",
        "TCHARS_PER_DCHAR",
        ")",
        ")",
        ";",
        "/* Prepare checking whether snprintf returns the count\n                   via %n.  */",
        "*(TCHAR_T *) (result + length) = '\\0';",
        "*(TCHAR_T *) (result + length) = '\\0'",
        "*(TCHAR_T *) (result + length)",
        "*",
        "(TCHAR_T *) (result + length)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "*",
        ")",
        "(result + length)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ")",
        "=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ";",
        "#endif",
        "orig_errno = errno;",
        "orig_errno = errno",
        "orig_errno",
        "=",
        "errno",
        ";",
        "for (;;)\n                  {\n                    int count = -1;\n\n#if USE_SNPRINTF\n                    int retcount = 0;\n                    size_t maxlen = allocated - length;\n                    /* SNPRINTF can fail if its second argument is\n                       > INT_MAX.  */\n                    if (maxlen > INT_MAX / TCHARS_PER_DCHAR)\n                      maxlen = INT_MAX / TCHARS_PER_DCHAR;\n                    maxlen = maxlen * TCHARS_PER_DCHAR;\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#else\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#endif\n\n                    errno = 0;\n                    switch (type)\n                      {\n                      case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      default:\n                        abort ();\n                      }\n\n#if USE_SNPRINTF\n                    /* Portability: Not all implementations of snprintf()\n                       are ISO C 99 compliant.  Determine the number of\n                       bytes that snprintf() has produced or would have\n                       produced.  */\n                    if (count >= 0)\n                      {\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }\n                    else\n                      {\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }\n#endif\n\n                    /* Attempt to handle failure.  */\n                    if (count < 0)\n                      {\n                        /* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */\n                        int saved_errno = errno;\n                        if (saved_errno == 0)\n                          {\n                            if (dp->conversion == 'c' || dp->conversion == 's')\n                              saved_errno = EILSEQ;\n                            else\n                              saved_errno = EINVAL;\n                          }\n\n                        if (!(result == resultbuf || result == NULL))\n                          free (result);\n                        if (buf_malloced != NULL)\n                          free (buf_malloced);\n                        CLEANUP ();\n\n                        errno = saved_errno;\n                        return NULL;\n                      }\n\n#if USE_SNPRINTF\n                    /* Handle overflow of the allocated buffer.\n                       If such an overflow occurs, a C99 compliant snprintf()\n                       returns a count >= maxlen.  However, a non-compliant\n                       snprintf() function returns only count = maxlen - 1.  To\n                       cover both cases, test whether count >= maxlen - 1.  */\n                    if ((unsigned int) count + 1 >= maxlen)\n                      {\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }\n#endif\n\n#if NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (prec_ourselves)\n                      {\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }\n#endif\n\n#if !USE_SNPRINTF\n                    if (count >= tmp_length)\n                      /* tmp_length was incorrectly calculated - fix the\n                         code above!  */\n                      abort ();\n#endif\n\n#if !DCHAR_IS_TCHAR\n                    /* Convert from TCHAR_T[] to DCHAR_T[].  */\n                    if (dp->conversion == 'c' || dp->conversion == 's')\n                      {\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }\n                    else\n                      {\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = *--tmpsrc;\n                          }\n                      }\n#endif\n\n#if DCHAR_IS_TCHAR && !USE_SNPRINTF\n                    /* Make room for the result.  */\n                    if (count > allocated - length)\n                      {\n                        /* Need at least count elements.  But allocate\n                           proportionally.  */\n                        size_t n =\n                          xmax (xsum (length, count), xtimes (allocated, 2));\n\n                        ENSURE_ALLOCATION (n);\n                      }\n#endif\n\n                    /* Here count <= allocated - length.  */\n\n                    /* Perform padding.  */\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (pad_ourselves && has_width)\n                      {\n                        size_t w;\n# if ENABLE_UNISTDIO\n                        /* Outside POSIX, it's preferable to compare the width\n                           against the number of _characters_ of the converted\n                           value.  */\n                        w = DCHAR_MBSNLEN (result + length, count);\n# else\n                        /* The width is compared against the number of _bytes_\n                           of the converted value, says POSIX.  */\n                        w = count;\n# endif\n                        if (w < width)\n                          {\n                            size_t pad = width - w;\n\n                            /* Make room for the result.  */\n                            if (xsum (count, pad) > allocated - length)\n                              {\n                                /* Need at least count + pad elements.  But\n                                   allocate proportionally.  */\n                                size_t n =\n                                  xmax (xsum3 (length, count, pad),\n                                        xtimes (allocated, 2));\n\n# if USE_SNPRINTF\n                                length += count;\n                                ENSURE_ALLOCATION (n);\n                                length -= count;\n# else\n                                ENSURE_ALLOCATION (n);\n# endif\n                              }\n                            /* Here count + pad <= allocated - length.  */\n\n                            {\n# if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                              DCHAR_T * const rp = result + length;\n# else\n                              DCHAR_T * const rp = tmp;\n# endif\n                              DCHAR_T *p = rp + count;\n                              DCHAR_T *end = p + pad;\n                              DCHAR_T *pad_ptr;\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                              if (dp->conversion == 'c'\n                                  || dp->conversion == 's')\n                                /* No zero-padding for string directives.  */\n                                pad_ptr = NULL;\n                              else\n# endif\n                                {\n                                  pad_ptr = (*rp == '-' ? rp + 1 : rp);\n                                  /* No zero-padding of \"inf\" and \"nan\".  */\n                                  if ((*pad_ptr >= 'A' && *pad_ptr <= 'Z')\n                                      || (*pad_ptr >= 'a' && *pad_ptr <= 'z'))\n                                    pad_ptr = NULL;\n                                }\n                              /* The generated string now extends from rp to p,\n                                 with the zero padding insertion point being at\n                                 pad_ptr.  */\n\n                              count = count + pad; /* = end - rp */\n\n                              if (flags & FLAG_LEFT)\n                                {\n                                  /* Pad with spaces on the right.  */\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                              else if ((flags & FLAG_ZERO) && pad_ptr != NULL)\n                                {\n                                  /* Pad with zeroes.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > pad_ptr)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = '0';\n                                }\n                              else\n                                {\n                                  /* Pad with spaces on the left.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > rp)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                            }\n                          }\n                      }\n#endif\n\n                    /* Here still count <= allocated - length.  */\n\n#if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                    /* The snprintf() result did fit.  */\n#else\n                    /* Append the sprintf() result.  */\n                    memcpy (result + length, tmp, count * sizeof (DCHAR_T));\n#endif\n#if !USE_SNPRINTF\n                    if (tmp != tmpbuf)\n                      free (tmp);\n#endif\n\n#if NEED_PRINTF_DIRECTIVE_F\n                    if (dp->conversion == 'F')\n                      {\n                        /* Convert the %f result to upper case for %F.  */\n                        DCHAR_T *rp = result + length;\n                        size_t rc;\n                        for (rc = count; rc > 0; rc--, rp++)\n                          if (*rp >= 'a' && *rp <= 'z')\n                            *rp = *rp - 'a' + 'A';\n                      }\n#endif\n\n                    length += count;\n                    break;\n                  }",
        "for",
        "(",
        ";",
        ";",
        ")",
        "{\n                    int count = -1;\n\n#if USE_SNPRINTF\n                    int retcount = 0;\n                    size_t maxlen = allocated - length;\n                    /* SNPRINTF can fail if its second argument is\n                       > INT_MAX.  */\n                    if (maxlen > INT_MAX / TCHARS_PER_DCHAR)\n                      maxlen = INT_MAX / TCHARS_PER_DCHAR;\n                    maxlen = maxlen * TCHARS_PER_DCHAR;\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#else\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#endif\n\n                    errno = 0;\n                    switch (type)\n                      {\n                      case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      default:\n                        abort ();\n                      }\n\n#if USE_SNPRINTF\n                    /* Portability: Not all implementations of snprintf()\n                       are ISO C 99 compliant.  Determine the number of\n                       bytes that snprintf() has produced or would have\n                       produced.  */\n                    if (count >= 0)\n                      {\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }\n                    else\n                      {\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }\n#endif\n\n                    /* Attempt to handle failure.  */\n                    if (count < 0)\n                      {\n                        /* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */\n                        int saved_errno = errno;\n                        if (saved_errno == 0)\n                          {\n                            if (dp->conversion == 'c' || dp->conversion == 's')\n                              saved_errno = EILSEQ;\n                            else\n                              saved_errno = EINVAL;\n                          }\n\n                        if (!(result == resultbuf || result == NULL))\n                          free (result);\n                        if (buf_malloced != NULL)\n                          free (buf_malloced);\n                        CLEANUP ();\n\n                        errno = saved_errno;\n                        return NULL;\n                      }\n\n#if USE_SNPRINTF\n                    /* Handle overflow of the allocated buffer.\n                       If such an overflow occurs, a C99 compliant snprintf()\n                       returns a count >= maxlen.  However, a non-compliant\n                       snprintf() function returns only count = maxlen - 1.  To\n                       cover both cases, test whether count >= maxlen - 1.  */\n                    if ((unsigned int) count + 1 >= maxlen)\n                      {\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }\n#endif\n\n#if NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (prec_ourselves)\n                      {\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }\n#endif\n\n#if !USE_SNPRINTF\n                    if (count >= tmp_length)\n                      /* tmp_length was incorrectly calculated - fix the\n                         code above!  */\n                      abort ();\n#endif\n\n#if !DCHAR_IS_TCHAR\n                    /* Convert from TCHAR_T[] to DCHAR_T[].  */\n                    if (dp->conversion == 'c' || dp->conversion == 's')\n                      {\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }\n                    else\n                      {\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = *--tmpsrc;\n                          }\n                      }\n#endif\n\n#if DCHAR_IS_TCHAR && !USE_SNPRINTF\n                    /* Make room for the result.  */\n                    if (count > allocated - length)\n                      {\n                        /* Need at least count elements.  But allocate\n                           proportionally.  */\n                        size_t n =\n                          xmax (xsum (length, count), xtimes (allocated, 2));\n\n                        ENSURE_ALLOCATION (n);\n                      }\n#endif\n\n                    /* Here count <= allocated - length.  */\n\n                    /* Perform padding.  */\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (pad_ourselves && has_width)\n                      {\n                        size_t w;\n# if ENABLE_UNISTDIO\n                        /* Outside POSIX, it's preferable to compare the width\n                           against the number of _characters_ of the converted\n                           value.  */\n                        w = DCHAR_MBSNLEN (result + length, count);\n# else\n                        /* The width is compared against the number of _bytes_\n                           of the converted value, says POSIX.  */\n                        w = count;\n# endif\n                        if (w < width)\n                          {\n                            size_t pad = width - w;\n\n                            /* Make room for the result.  */\n                            if (xsum (count, pad) > allocated - length)\n                              {\n                                /* Need at least count + pad elements.  But\n                                   allocate proportionally.  */\n                                size_t n =\n                                  xmax (xsum3 (length, count, pad),\n                                        xtimes (allocated, 2));\n\n# if USE_SNPRINTF\n                                length += count;\n                                ENSURE_ALLOCATION (n);\n                                length -= count;\n# else\n                                ENSURE_ALLOCATION (n);\n# endif\n                              }\n                            /* Here count + pad <= allocated - length.  */\n\n                            {\n# if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                              DCHAR_T * const rp = result + length;\n# else\n                              DCHAR_T * const rp = tmp;\n# endif\n                              DCHAR_T *p = rp + count;\n                              DCHAR_T *end = p + pad;\n                              DCHAR_T *pad_ptr;\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                              if (dp->conversion == 'c'\n                                  || dp->conversion == 's')\n                                /* No zero-padding for string directives.  */\n                                pad_ptr = NULL;\n                              else\n# endif\n                                {\n                                  pad_ptr = (*rp == '-' ? rp + 1 : rp);\n                                  /* No zero-padding of \"inf\" and \"nan\".  */\n                                  if ((*pad_ptr >= 'A' && *pad_ptr <= 'Z')\n                                      || (*pad_ptr >= 'a' && *pad_ptr <= 'z'))\n                                    pad_ptr = NULL;\n                                }\n                              /* The generated string now extends from rp to p,\n                                 with the zero padding insertion point being at\n                                 pad_ptr.  */\n\n                              count = count + pad; /* = end - rp */\n\n                              if (flags & FLAG_LEFT)\n                                {\n                                  /* Pad with spaces on the right.  */\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                              else if ((flags & FLAG_ZERO) && pad_ptr != NULL)\n                                {\n                                  /* Pad with zeroes.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > pad_ptr)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = '0';\n                                }\n                              else\n                                {\n                                  /* Pad with spaces on the left.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > rp)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                            }\n                          }\n                      }\n#endif\n\n                    /* Here still count <= allocated - length.  */\n\n#if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                    /* The snprintf() result did fit.  */\n#else\n                    /* Append the sprintf() result.  */\n                    memcpy (result + length, tmp, count * sizeof (DCHAR_T));\n#endif\n#if !USE_SNPRINTF\n                    if (tmp != tmpbuf)\n                      free (tmp);\n#endif\n\n#if NEED_PRINTF_DIRECTIVE_F\n                    if (dp->conversion == 'F')\n                      {\n                        /* Convert the %f result to upper case for %F.  */\n                        DCHAR_T *rp = result + length;\n                        size_t rc;\n                        for (rc = count; rc > 0; rc--, rp++)\n                          if (*rp >= 'a' && *rp <= 'z')\n                            *rp = *rp - 'a' + 'A';\n                      }\n#endif\n\n                    length += count;\n                    break;\n                  }",
        "{",
        "int count = -1;",
        "int",
        "count = -1",
        "count",
        "=",
        "-1",
        ";",
        "#if USE_SNPRINTF\n                    int retcount = 0;\n                    size_t maxlen = allocated - length;\n                    /* SNPRINTF can fail if its second argument is\n                       > INT_MAX.  */\n                    if (maxlen > INT_MAX / TCHARS_PER_DCHAR)\n                      maxlen = INT_MAX / TCHARS_PER_DCHAR;\n                    maxlen = maxlen * TCHARS_PER_DCHAR;\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#else\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#endif",
        "#if",
        "USE_SNPRINTF",
        "\n",
        "int retcount = 0;",
        "int",
        "retcount = 0",
        "retcount",
        "=",
        "0",
        ";",
        "size_t maxlen = allocated - length;",
        "size_t",
        "maxlen = allocated - length",
        "maxlen",
        "=",
        "allocated - length",
        "allocated",
        "-",
        "length",
        ";",
        "/* SNPRINTF can fail if its second argument is\n                       > INT_MAX.  */",
        "if (maxlen > INT_MAX / TCHARS_PER_DCHAR)\n                      maxlen = INT_MAX / TCHARS_PER_DCHAR;",
        "if",
        "(maxlen > INT_MAX / TCHARS_PER_DCHAR)",
        "(",
        "maxlen > INT_MAX / TCHARS_PER_DCHAR",
        "maxlen",
        ">",
        "INT_MAX / TCHARS_PER_DCHAR",
        "INT_MAX",
        "/",
        "TCHARS_PER_DCHAR",
        ")",
        "maxlen = INT_MAX / TCHARS_PER_DCHAR;",
        "maxlen = INT_MAX / TCHARS_PER_DCHAR",
        "maxlen",
        "=",
        "INT_MAX / TCHARS_PER_DCHAR",
        "INT_MAX",
        "/",
        "TCHARS_PER_DCHAR",
        ";",
        "maxlen = maxlen * TCHARS_PER_DCHAR;",
        "maxlen = maxlen * TCHARS_PER_DCHAR",
        "maxlen",
        "=",
        "maxlen * TCHARS_PER_DCHAR",
        "maxlen",
        "*",
        "TCHARS_PER_DCHAR",
        ";",
        "# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n",
        "# define",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        " \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }",
        "\n",
        "#else\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n",
        "#else",
        "# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n",
        "# define",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        " \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }",
        "\n",
        "#endif",
        "errno = 0;",
        "errno = 0",
        "errno",
        "=",
        "0",
        ";",
        "switch (type)\n                      {\n                      case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      default:\n                        abort ();\n                      }",
        "switch",
        "(type)",
        "(",
        "type",
        ")",
        "{\n                      case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      default:\n                        abort ();\n                      }",
        "{",
        "case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_SCHAR",
        ":",
        "{\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "int arg = a.arg[dp->arg_index].a.a_schar;",
        "int",
        "arg = a.arg[dp->arg_index].a.a_schar",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_schar",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_schar",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_UCHAR",
        ":",
        "{\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "unsigned int arg = a.arg[dp->arg_index].a.a_uchar;",
        "unsigned int",
        "unsigned",
        "int",
        "arg = a.arg[dp->arg_index].a.a_uchar",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_uchar",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_uchar",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_SHORT",
        ":",
        "{\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "int arg = a.arg[dp->arg_index].a.a_short;",
        "int",
        "arg = a.arg[dp->arg_index].a.a_short",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_short",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_short",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_USHORT",
        ":",
        "{\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "unsigned int arg = a.arg[dp->arg_index].a.a_ushort;",
        "unsigned int",
        "unsigned",
        "int",
        "arg = a.arg[dp->arg_index].a.a_ushort",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_ushort",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_ushort",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_INT",
        ":",
        "{\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "int arg = a.arg[dp->arg_index].a.a_int;",
        "int",
        "arg = a.arg[dp->arg_index].a.a_int",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_int",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_int",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_UINT",
        ":",
        "{\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "unsigned int arg = a.arg[dp->arg_index].a.a_uint;",
        "unsigned int",
        "unsigned",
        "int",
        "arg = a.arg[dp->arg_index].a.a_uint",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_uint",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_uint",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_LONGINT",
        ":",
        "{\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "long int arg = a.arg[dp->arg_index].a.a_longint;",
        "long int",
        "long",
        "int",
        "arg = a.arg[dp->arg_index].a.a_longint",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_longint",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_longint",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_ULONGINT",
        ":",
        "{\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;",
        "unsigned long int",
        "unsigned",
        "long",
        "int",
        "arg = a.arg[dp->arg_index].a.a_ulongint",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_ulongint",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_ulongint",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif",
        "#if",
        "HAVE_LONG_LONG_INT",
        "\n",
        "case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_LONGLONGINT",
        ":",
        "{\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "long long int arg = a.arg[dp->arg_index].a.a_longlongint;",
        "long long int",
        "long",
        "long",
        "int",
        "arg = a.arg[dp->arg_index].a.a_longlongint",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_longlongint",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_longlongint",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_ULONGLONGINT",
        ":",
        "{\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;",
        "unsigned long long int",
        "unsigned",
        "long",
        "long",
        "int",
        "arg = a.arg[dp->arg_index].a.a_ulonglongint",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_ulonglongint",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_ulonglongint",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "#endif",
        "case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_DOUBLE",
        ":",
        "{\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "double arg = a.arg[dp->arg_index].a.a_double;",
        "double",
        "arg = a.arg[dp->arg_index].a.a_double",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_double",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_double",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_LONGDOUBLE",
        ":",
        "{\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "long double arg = a.arg[dp->arg_index].a.a_longdouble;",
        "long double",
        "long",
        "double",
        "arg = a.arg[dp->arg_index].a.a_longdouble",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_longdouble",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_longdouble",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_CHAR",
        ":",
        "{\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "int arg = a.arg[dp->arg_index].a.a_char;",
        "int",
        "arg = a.arg[dp->arg_index].a.a_char",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_char",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_char",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif",
        "#if",
        "HAVE_WINT_T",
        "\n",
        "case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_WIDE_CHAR",
        ":",
        "{\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "wint_t arg = a.arg[dp->arg_index].a.a_wide_char;",
        "wint_t",
        "arg = a.arg[dp->arg_index].a.a_wide_char",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_wide_char",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_wide_char",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "#endif",
        "case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_STRING",
        ":",
        "{\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "const char *arg = a.arg[dp->arg_index].a.a_string;",
        "const",
        "const",
        "char",
        "*arg = a.arg[dp->arg_index].a.a_string",
        "*arg",
        "*",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_string",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_string",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif",
        "#if",
        "HAVE_WCHAR_T",
        "\n",
        "case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_WIDE_STRING",
        ":",
        "{\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;",
        "const",
        "const",
        "wchar_t",
        "*arg = a.arg[dp->arg_index].a.a_wide_string",
        "*arg",
        "*",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_wide_string",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_wide_string",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "#endif",
        "case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_POINTER",
        ":",
        "{\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "void *arg = a.arg[dp->arg_index].a.a_pointer;",
        "void",
        "*arg = a.arg[dp->arg_index].a.a_pointer",
        "*arg",
        "*",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_pointer",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_pointer",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "default:\n                        abort ();",
        "default",
        ":",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "}",
        "#if USE_SNPRINTF\n                    /* Portability: Not all implementations of snprintf()\n                       are ISO C 99 compliant.  Determine the number of\n                       bytes that snprintf() has produced or would have\n                       produced.  */\n                    if (count >= 0)\n                      {\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }\n                    else\n                      {\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }\n#endif",
        "#if",
        "USE_SNPRINTF",
        "\n",
        "/* Portability: Not all implementations of snprintf()\n                       are ISO C 99 compliant.  Determine the number of\n                       bytes that snprintf() has produced or would have\n                       produced.  */",
        "if (count >= 0)\n                      {\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }\n                    else\n                      {\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }",
        "if",
        "(count >= 0)",
        "(",
        "count >= 0",
        "count",
        ">=",
        "0",
        ")",
        "{\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }",
        "{",
        "/* Verify that snprintf() has NUL-terminated its\n                           result.  */",
        "if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();",
        "if",
        "(count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')",
        "(",
        "count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0'",
        "count < maxlen",
        "count",
        "<",
        "maxlen",
        "&&",
        "((TCHAR_T *) (result + length)) [count] != '\\0'",
        "((TCHAR_T *) (result + length)) [count]",
        "((TCHAR_T *) (result + length))",
        "(",
        "(TCHAR_T *) (result + length)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "*",
        ")",
        "(result + length)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ")",
        ")",
        "[",
        "count",
        "]",
        "!=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ")",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "/* Portability hack.  */",
        "if (retcount > count)\n                          count = retcount;",
        "if",
        "(retcount > count)",
        "(",
        "retcount > count",
        "retcount",
        ">",
        "count",
        ")",
        "count = retcount;",
        "count = retcount",
        "count",
        "=",
        "retcount",
        ";",
        "}",
        "else",
        "{\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }",
        "{",
        "/* snprintf() doesn't understand the '%n'\n                           directive.  */",
        "if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }",
        "if",
        "(fbp[1] != '\\0')",
        "(",
        "fbp[1] != '\\0'",
        "fbp[1]",
        "fbp",
        "[",
        "1",
        "]",
        "!=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ")",
        "{\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }",
        "{",
        "/* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */",
        "fbp[1] = '\\0';",
        "fbp[1] = '\\0'",
        "fbp[1]",
        "fbp",
        "[",
        "1",
        "]",
        "=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ";",
        "continue;",
        "continue",
        ";",
        "}",
        "else",
        "{\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }",
        "{",
        "/* Look at the snprintf() return value.  */",
        "if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;",
        "if",
        "(retcount < 0)",
        "(",
        "retcount < 0",
        "retcount",
        "<",
        "0",
        ")",
        "{\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }",
        "{",
        "# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif",
        "# if",
        "!HAVE_SNPRINTF_RETVAL_C99",
        "!",
        "HAVE_SNPRINTF_RETVAL_C99",
        "\n",
        "/* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */",
        "size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);",
        "size_t",
        "tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves)",
        "tmp_length",
        "=",
        "MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves)",
        "MAX_ROOM_NEEDED",
        "(&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves)",
        "(",
        "&a",
        "&",
        "a",
        ",",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        ",",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        ",",
        "type",
        ",",
        "flags",
        ",",
        "width",
        ",",
        "has_precision",
        ",",
        "precision",
        ",",
        "pad_ourselves",
        ")",
        ";",
        "if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }",
        "if",
        "(maxlen < tmp_length)",
        "(",
        "maxlen < tmp_length",
        "maxlen",
        "<",
        "tmp_length",
        ")",
        "{\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }",
        "{",
        "/* Make more room.  But try to do through\n                                       this reallocation only once.  */",
        "size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);",
        "size_t",
        "bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR)",
        "bigger_need",
        "=",
        "xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR)",
        "xsum",
        "(length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR)",
        "(",
        "length",
        ",",
        "xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR",
        "xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)",
        "xsum",
        "(tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)",
        "(",
        "tmp_length",
        ",",
        "TCHARS_PER_DCHAR - 1",
        "TCHARS_PER_DCHAR",
        "-",
        "1",
        ")",
        "/",
        "TCHARS_PER_DCHAR",
        ")",
        ";",
        "/* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */",
        "size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);",
        "size_t",
        "bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12)",
        "bigger_need2",
        "=",
        "xsum (xtimes (allocated, 2), 12)",
        "xsum",
        "(xtimes (allocated, 2), 12)",
        "(",
        "xtimes (allocated, 2)",
        "xtimes",
        "(allocated, 2)",
        "(",
        "allocated",
        ",",
        "2",
        ")",
        ",",
        "12",
        ")",
        ";",
        "if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;",
        "if",
        "(bigger_need < bigger_need2)",
        "(",
        "bigger_need < bigger_need2",
        "bigger_need",
        "<",
        "bigger_need2",
        ")",
        "bigger_need = bigger_need2;",
        "bigger_need = bigger_need2",
        "bigger_need",
        "=",
        "bigger_need2",
        ";",
        "ENSURE_ALLOCATION (bigger_need);",
        "ENSURE_ALLOCATION (bigger_need)",
        "ENSURE_ALLOCATION",
        "(bigger_need)",
        "(",
        "bigger_need",
        ")",
        ";",
        "continue;",
        "continue",
        ";",
        "}",
        "# endif",
        "}",
        "else",
        "count = retcount;",
        "count = retcount",
        "count",
        "=",
        "retcount",
        ";",
        "}",
        "}",
        "#endif",
        "/* Attempt to handle failure.  */",
        "if (count < 0)\n                      {\n                        /* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */\n                        int saved_errno = errno;\n                        if (saved_errno == 0)\n                          {\n                            if (dp->conversion == 'c' || dp->conversion == 's')\n                              saved_errno = EILSEQ;\n                            else\n                              saved_errno = EINVAL;\n                          }\n\n                        if (!(result == resultbuf || result == NULL))\n                          free (result);\n                        if (buf_malloced != NULL)\n                          free (buf_malloced);\n                        CLEANUP ();\n\n                        errno = saved_errno;\n                        return NULL;\n                      }",
        "if",
        "(count < 0)",
        "(",
        "count < 0",
        "count",
        "<",
        "0",
        ")",
        "{\n                        /* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */\n                        int saved_errno = errno;\n                        if (saved_errno == 0)\n                          {\n                            if (dp->conversion == 'c' || dp->conversion == 's')\n                              saved_errno = EILSEQ;\n                            else\n                              saved_errno = EINVAL;\n                          }\n\n                        if (!(result == resultbuf || result == NULL))\n                          free (result);\n                        if (buf_malloced != NULL)\n                          free (buf_malloced);\n                        CLEANUP ();\n\n                        errno = saved_errno;\n                        return NULL;\n                      }",
        "{",
        "/* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */",
        "int saved_errno = errno;",
        "int",
        "saved_errno = errno",
        "saved_errno",
        "=",
        "errno",
        ";",
        "if (saved_errno == 0)\n                          {\n                            if (dp->conversion == 'c' || dp->conversion == 's')\n                              saved_errno = EILSEQ;\n                            else\n                              saved_errno = EINVAL;\n                          }",
        "if",
        "(saved_errno == 0)",
        "(",
        "saved_errno == 0",
        "saved_errno",
        "==",
        "0",
        ")",
        "{\n                            if (dp->conversion == 'c' || dp->conversion == 's')\n                              saved_errno = EILSEQ;\n                            else\n                              saved_errno = EINVAL;\n                          }",
        "{",
        "if (dp->conversion == 'c' || dp->conversion == 's')\n                              saved_errno = EILSEQ;\n                            else\n                              saved_errno = EINVAL;",
        "if",
        "(dp->conversion == 'c' || dp->conversion == 's')",
        "(",
        "dp->conversion == 'c' || dp->conversion == 's'",
        "dp->conversion == 'c'",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        "==",
        "'c'",
        "'",
        "'",
        "||",
        "dp->conversion == 's'",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        "==",
        "'s'",
        "'",
        "'",
        ")",
        "saved_errno = EILSEQ;",
        "saved_errno = EILSEQ",
        "saved_errno",
        "=",
        "EILSEQ",
        ";",
        "else",
        "saved_errno = EINVAL;",
        "saved_errno = EINVAL",
        "saved_errno",
        "=",
        "EINVAL",
        ";",
        "}",
        "if (!(result == resultbuf || result == NULL))\n                          free (result);",
        "if",
        "(!(result == resultbuf || result == NULL))",
        "(",
        "!(result == resultbuf || result == NULL)",
        "!",
        "(result == resultbuf || result == NULL)",
        "(",
        "result == resultbuf || result == NULL",
        "result == resultbuf",
        "result",
        "==",
        "resultbuf",
        "||",
        "result == NULL",
        "result",
        "==",
        "NULL",
        ")",
        ")",
        "free (result);",
        "free (result)",
        "free",
        "(result)",
        "(",
        "result",
        ")",
        ";",
        "if (buf_malloced != NULL)\n                          free (buf_malloced);",
        "if",
        "(buf_malloced != NULL)",
        "(",
        "buf_malloced != NULL",
        "buf_malloced",
        "!=",
        "NULL",
        ")",
        "free (buf_malloced);",
        "free (buf_malloced)",
        "free",
        "(buf_malloced)",
        "(",
        "buf_malloced",
        ")",
        ";",
        "CLEANUP ();",
        "CLEANUP ()",
        "CLEANUP",
        "()",
        "(",
        ")",
        ";",
        "errno = saved_errno;",
        "errno = saved_errno",
        "errno",
        "=",
        "saved_errno",
        ";",
        "return NULL;",
        "return",
        "NULL",
        ";",
        "}",
        "#if USE_SNPRINTF\n                    /* Handle overflow of the allocated buffer.\n                       If such an overflow occurs, a C99 compliant snprintf()\n                       returns a count >= maxlen.  However, a non-compliant\n                       snprintf() function returns only count = maxlen - 1.  To\n                       cover both cases, test whether count >= maxlen - 1.  */\n                    if ((unsigned int) count + 1 >= maxlen)\n                      {\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }\n#endif",
        "#if",
        "USE_SNPRINTF",
        "\n",
        "/* Handle overflow of the allocated buffer.\n                       If such an overflow occurs, a C99 compliant snprintf()\n                       returns a count >= maxlen.  However, a non-compliant\n                       snprintf() function returns only count = maxlen - 1.  To\n                       cover both cases, test whether count >= maxlen - 1.  */",
        "if ((unsigned int) count + 1 >= maxlen)\n                      {\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }",
        "if",
        "((unsigned int) count + 1 >= maxlen)",
        "(",
        "(unsigned int) count + 1 >= maxlen",
        "(unsigned int) count + 1",
        "(unsigned int) count",
        "(",
        "unsigned int",
        "unsigned int",
        "unsigned",
        "int",
        ")",
        "count",
        "+",
        "1",
        ">=",
        "maxlen",
        ")",
        "{\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }",
        "{",
        "/* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */",
        "if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }",
        "if",
        "(maxlen == INT_MAX / TCHARS_PER_DCHAR)",
        "(",
        "maxlen == INT_MAX / TCHARS_PER_DCHAR",
        "maxlen",
        "==",
        "INT_MAX / TCHARS_PER_DCHAR",
        "INT_MAX",
        "/",
        "TCHARS_PER_DCHAR",
        ")",
        "goto overflow;",
        "goto",
        "overflow",
        ";",
        "else",
        "{\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }",
        "{",
        "/* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */",
        "size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));",
        "size_t",
        "n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2))",
        "n",
        "=",
        "xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2))",
        "xmax",
        "(xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2))",
        "(",
        "xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR)",
        "xsum",
        "(length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR)",
        "(",
        "length",
        ",",
        "((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR",
        "((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)",
        "(",
        "(unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1",
        "(unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR",
        "(unsigned int) count + 2",
        "(unsigned int) count",
        "(",
        "unsigned int",
        "unsigned int",
        "unsigned",
        "int",
        ")",
        "count",
        "+",
        "2",
        "+",
        "TCHARS_PER_DCHAR",
        "-",
        "1",
        ")",
        "/",
        "TCHARS_PER_DCHAR",
        ")",
        ",",
        "xtimes (allocated, 2)",
        "xtimes",
        "(allocated, 2)",
        "(",
        "allocated",
        ",",
        "2",
        ")",
        ")",
        ";",
        "ENSURE_ALLOCATION (n);",
        "ENSURE_ALLOCATION (n)",
        "ENSURE_ALLOCATION",
        "(n)",
        "(",
        "n",
        ")",
        ";",
        "continue;",
        "continue",
        ";",
        "}",
        "}",
        "#endif",
        "#if NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (prec_ourselves)\n                      {\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }\n#endif",
        "#if",
        "NEED_PRINTF_UNBOUNDED_PRECISION",
        "\n",
        "if (prec_ourselves)\n                      {\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }",
        "if",
        "(prec_ourselves)",
        "(",
        "prec_ourselves",
        ")",
        "{\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }",
        "{",
        "/* Handle the precision.  */",
        "TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);",
        "TCHAR_T",
        "*prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length)",
        "*prec_ptr",
        "*",
        "prec_ptr",
        "=",
        "# if",
        "# if",
        "USE_SNPRINTF\n                          (TCHAR_T *) (result + length)",
        "USE_SNPRINTF\n                          (TCHAR_T *)",
        "USE_SNPRINTF",
        "(TCHAR_T *)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "",
        ")",
        "(result + length)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ")",
        ";",
        "# else\n                          tmp;\n",
        "# else",
        "\n                          tmp;",
        "\n",
        "# endif\n                        size_t prefix_count;\n",
        "# endif",
        "\n                        size_t prefix_count;",
        "\n",
        "size_t move;",
        "size_t",
        "move",
        ";",
        "prefix_count = 0;",
        "prefix_count = 0",
        "prefix_count",
        "=",
        "0",
        ";",
        "/* Put the additional zeroes after the sign.  */",
        "if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;",
        "if",
        "(count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))",
        "(",
        "count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' ')",
        "count >= 1",
        "count",
        ">=",
        "1",
        "&&",
        "(*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' ')",
        "(",
        "*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '",
        "*prec_ptr == '-' || *prec_ptr == '+'",
        "*prec_ptr == '-'",
        "*prec_ptr",
        "*",
        "prec_ptr",
        "==",
        "'-'",
        "'",
        "'",
        "||",
        "*prec_ptr == '+'",
        "*prec_ptr",
        "*",
        "prec_ptr",
        "==",
        "'+'",
        "'",
        "'",
        "||",
        "*prec_ptr == ' '",
        "*prec_ptr",
        "*",
        "prec_ptr",
        "==",
        "' '",
        "'",
        "'",
        ")",
        ")",
        "prefix_count = 1;",
        "prefix_count = 1",
        "prefix_count",
        "=",
        "1",
        ";",
        "/* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */",
        "else",
        "if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;",
        "if",
        "(count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))",
        "(",
        "count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X')",
        "count >= 2\n                                 && prec_ptr[0] == '0'",
        "count >= 2",
        "count",
        ">=",
        "2",
        "&&",
        "prec_ptr[0] == '0'",
        "prec_ptr[0]",
        "prec_ptr",
        "[",
        "0",
        "]",
        "==",
        "'0'",
        "'",
        "'",
        "&&",
        "(prec_ptr[1] == 'x' || prec_ptr[1] == 'X')",
        "(",
        "prec_ptr[1] == 'x' || prec_ptr[1] == 'X'",
        "prec_ptr[1] == 'x'",
        "prec_ptr[1]",
        "prec_ptr",
        "[",
        "1",
        "]",
        "==",
        "'x'",
        "'",
        "'",
        "||",
        "prec_ptr[1] == 'X'",
        "prec_ptr[1]",
        "prec_ptr",
        "[",
        "1",
        "]",
        "==",
        "'X'",
        "'",
        "'",
        ")",
        ")",
        "prefix_count = 2;",
        "prefix_count = 2",
        "prefix_count",
        "=",
        "2",
        ";",
        "move = count - prefix_count;",
        "move = count - prefix_count",
        "move",
        "=",
        "count - prefix_count",
        "count",
        "-",
        "prefix_count",
        ";",
        "if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }",
        "if",
        "(precision > move)",
        "(",
        "precision > move",
        "precision",
        ">",
        "move",
        ")",
        "{\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }",
        "{",
        "/* Insert zeroes.  */",
        "size_t insert = precision - move;",
        "size_t",
        "insert = precision - move",
        "insert",
        "=",
        "precision - move",
        "precision",
        "-",
        "move",
        ";",
        "TCHAR_T *prec_end;",
        "TCHAR_T",
        "*prec_end",
        "*",
        "prec_end",
        ";",
        "# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif",
        "# if",
        "USE_SNPRINTF",
        "\n",
        "size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);",
        "size_t",
        "n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR)",
        "n",
        "=",
        "xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR)",
        "xsum",
        "(length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR)",
        "(",
        "length",
        ",",
        "(count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR",
        "(count + insert + TCHARS_PER_DCHAR - 1)",
        "(",
        "count + insert + TCHARS_PER_DCHAR - 1",
        "count + insert + TCHARS_PER_DCHAR",
        "count + insert",
        "count",
        "+",
        "insert",
        "+",
        "TCHARS_PER_DCHAR",
        "-",
        "1",
        ")",
        "/",
        "TCHARS_PER_DCHAR",
        ")",
        ";",
        "length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;",
        "length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR",
        "length",
        "+=",
        "(count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR",
        "(count + TCHARS_PER_DCHAR - 1)",
        "(",
        "count + TCHARS_PER_DCHAR - 1",
        "count + TCHARS_PER_DCHAR",
        "count",
        "+",
        "TCHARS_PER_DCHAR",
        "-",
        "1",
        ")",
        "/",
        "TCHARS_PER_DCHAR",
        ";",
        "ENSURE_ALLOCATION (n);",
        "ENSURE_ALLOCATION (n)",
        "ENSURE_ALLOCATION",
        "(n)",
        "(",
        "n",
        ")",
        ";",
        "length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;",
        "length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR",
        "length",
        "-=",
        "(count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR",
        "(count + TCHARS_PER_DCHAR - 1)",
        "(",
        "count + TCHARS_PER_DCHAR - 1",
        "count + TCHARS_PER_DCHAR",
        "count",
        "+",
        "TCHARS_PER_DCHAR",
        "-",
        "1",
        ")",
        "/",
        "TCHARS_PER_DCHAR",
        ";",
        "prec_ptr = (TCHAR_T *) (result + length);",
        "prec_ptr = (TCHAR_T *) (result + length)",
        "prec_ptr",
        "=",
        "(TCHAR_T *) (result + length)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "*",
        ")",
        "(result + length)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ")",
        ";",
        "# endif",
        "prec_end = prec_ptr + count;",
        "prec_end = prec_ptr + count",
        "prec_end",
        "=",
        "prec_ptr + count",
        "prec_ptr",
        "+",
        "count",
        ";",
        "prec_ptr += prefix_count;",
        "prec_ptr += prefix_count",
        "prec_ptr",
        "+=",
        "prefix_count",
        ";",
        "while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }",
        "while",
        "(prec_end > prec_ptr)",
        "(",
        "prec_end > prec_ptr",
        "prec_end",
        ">",
        "prec_ptr",
        ")",
        "{\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }",
        "{",
        "prec_end--;",
        "prec_end--",
        "prec_end",
        "--",
        ";",
        "prec_end[insert] = prec_end[0];",
        "prec_end[insert] = prec_end[0]",
        "prec_end[insert]",
        "prec_end",
        "[",
        "insert",
        "]",
        "=",
        "prec_end[0]",
        "prec_end",
        "[",
        "0",
        "]",
        ";",
        "}",
        "prec_end += insert;",
        "prec_end += insert",
        "prec_end",
        "+=",
        "insert",
        ";",
        "do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);",
        "do",
        "*--prec_end = '0';",
        "*--prec_end = '0'",
        "*--prec_end",
        "*",
        "--prec_end",
        "--",
        "prec_end",
        "=",
        "'0'",
        "'",
        "'",
        ";",
        "while",
        "(prec_end > prec_ptr)",
        "(",
        "prec_end > prec_ptr",
        "prec_end",
        ">",
        "prec_ptr",
        ")",
        ";",
        "count += insert;",
        "count += insert",
        "count",
        "+=",
        "insert",
        ";",
        "}",
        "}",
        "#endif",
        "#if !USE_SNPRINTF\n                    if (count >= tmp_length)\n                      /* tmp_length was incorrectly calculated - fix the\n                         code above!  */\n                      abort ();\n#endif",
        "#if",
        "!USE_SNPRINTF",
        "!",
        "USE_SNPRINTF",
        "\n",
        "if (count >= tmp_length)\n                      /* tmp_length was incorrectly calculated - fix the\n                         code above!  */\n                      abort ();",
        "if",
        "(count >= tmp_length)",
        "(",
        "count >= tmp_length",
        "count",
        ">=",
        "tmp_length",
        ")",
        "/* tmp_length was incorrectly calculated - fix the\n                         code above!  */",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "#endif",
        "#if !DCHAR_IS_TCHAR\n                    /* Convert from TCHAR_T[] to DCHAR_T[].  */\n                    if (dp->conversion == 'c' || dp->conversion == 's')\n                      {\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }\n                    else\n                      {\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = *--tmpsrc;\n                          }\n                      }\n#endif",
        "#if",
        "!DCHAR_IS_TCHAR",
        "!",
        "DCHAR_IS_TCHAR",
        "\n",
        "/* Convert from TCHAR_T[] to DCHAR_T[].  */",
        "if (dp->conversion == 'c' || dp->conversion == 's')\n                      {\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }\n                    else\n                      {\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = *--tmpsrc;\n                          }\n                      }",
        "if",
        "(dp->conversion == 'c' || dp->conversion == 's')",
        "(",
        "dp->conversion == 'c' || dp->conversion == 's'",
        "dp->conversion == 'c'",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        "==",
        "'c'",
        "'",
        "'",
        "||",
        "dp->conversion == 's'",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        "==",
        "'s'",
        "'",
        "'",
        ")",
        "{\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }",
        "{",
        "/* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */",
        "const TCHAR_T *tmpsrc;",
        "const",
        "const",
        "TCHAR_T",
        "*tmpsrc",
        "*",
        "tmpsrc",
        ";",
        "DCHAR_T *tmpdst;",
        "DCHAR_T",
        "*tmpdst",
        "*",
        "tmpdst",
        ";",
        "size_t tmpdst_len;",
        "size_t",
        "tmpdst_len",
        ";",
        "/* This code assumes that TCHAR_T is 'char'.  */",
        "verify (sizeof (TCHAR_T) == 1);",
        "verify (sizeof (TCHAR_T) == 1)",
        "verify",
        "(sizeof (TCHAR_T) == 1)",
        "(",
        "sizeof (TCHAR_T) == 1",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        "==",
        "1",
        ")",
        ";",
        "# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif",
        "# if",
        "USE_SNPRINTF",
        "\n",
        "tmpsrc = (TCHAR_T *) (result + length);",
        "tmpsrc = (TCHAR_T *) (result + length)",
        "tmpsrc",
        "=",
        "(TCHAR_T *) (result + length)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "*",
        ")",
        "(result + length)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ")",
        ";",
        "# else\n                        tmpsrc = tmp;",
        "# else",
        "tmpsrc = tmp;",
        "tmpsrc = tmp",
        "tmpsrc",
        "=",
        "tmp",
        ";",
        "# endif",
        "tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);",
        "tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len)",
        "tmpdst",
        "=",
        "DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len)",
        "DCHAR_CONV_FROM_ENCODING",
        "(locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len)",
        "(",
        "locale_charset ()",
        "locale_charset",
        "()",
        "(",
        ")",
        ",",
        "iconveh_question_mark",
        ",",
        "tmpsrc",
        ",",
        "count",
        ",",
        "NULL",
        ",",
        "NULL",
        ",",
        "&tmpdst_len",
        "&",
        "tmpdst_len",
        ")",
        ";",
        "if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }",
        "if",
        "(tmpdst == NULL)",
        "(",
        "tmpdst == NULL",
        "tmpdst",
        "==",
        "NULL",
        ")",
        "{\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }",
        "{",
        "int saved_errno = errno;",
        "int",
        "saved_errno = errno",
        "saved_errno",
        "=",
        "errno",
        ";",
        "if (!(result == resultbuf || result == NULL))\n                              free (result);",
        "if",
        "(!(result == resultbuf || result == NULL))",
        "(",
        "!(result == resultbuf || result == NULL)",
        "!",
        "(result == resultbuf || result == NULL)",
        "(",
        "result == resultbuf || result == NULL",
        "result == resultbuf",
        "result",
        "==",
        "resultbuf",
        "||",
        "result == NULL",
        "result",
        "==",
        "NULL",
        ")",
        ")",
        "free (result);",
        "free (result)",
        "free",
        "(result)",
        "(",
        "result",
        ")",
        ";",
        "if (buf_malloced != NULL)\n                              free (buf_malloced);",
        "if",
        "(buf_malloced != NULL)",
        "(",
        "buf_malloced != NULL",
        "buf_malloced",
        "!=",
        "NULL",
        ")",
        "free (buf_malloced);",
        "free (buf_malloced)",
        "free",
        "(buf_malloced)",
        "(",
        "buf_malloced",
        ")",
        ";",
        "CLEANUP ();",
        "CLEANUP ()",
        "CLEANUP",
        "()",
        "(",
        ")",
        ";",
        "errno = saved_errno;",
        "errno = saved_errno",
        "errno",
        "=",
        "saved_errno",
        ";",
        "return NULL;",
        "return",
        "NULL",
        ";",
        "}",
        "ENSURE_ALLOCATION (xsum (length, tmpdst_len));",
        "ENSURE_ALLOCATION (xsum (length, tmpdst_len))",
        "ENSURE_ALLOCATION",
        "(xsum (length, tmpdst_len))",
        "(",
        "xsum (length, tmpdst_len)",
        "xsum",
        "(length, tmpdst_len)",
        "(",
        "length",
        ",",
        "tmpdst_len",
        ")",
        ")",
        ";",
        "DCHAR_CPY (result + length, tmpdst, tmpdst_len);",
        "DCHAR_CPY (result + length, tmpdst, tmpdst_len)",
        "DCHAR_CPY",
        "(result + length, tmpdst, tmpdst_len)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ",",
        "tmpdst",
        ",",
        "tmpdst_len",
        ")",
        ";",
        "free (tmpdst);",
        "free (tmpdst)",
        "free",
        "(tmpdst)",
        "(",
        "tmpdst",
        ")",
        ";",
        "count = tmpdst_len;",
        "count = tmpdst_len",
        "count",
        "=",
        "tmpdst_len",
        ";",
        "}",
        "else",
        "{\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = *--tmpsrc;\n                          }\n                      }",
        "{",
        "/* The result string is ASCII.\n                           Simple 1:1 conversion.  */",
        "# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif",
        "# if",
        "USE_SNPRINTF",
        "\n",
        "/* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */",
        "if (sizeof (DCHAR_T) != sizeof (TCHAR_T))",
        "if",
        "(sizeof (DCHAR_T) != sizeof (TCHAR_T))",
        "(",
        "sizeof (DCHAR_T) != sizeof (TCHAR_T)",
        "sizeof (DCHAR_T)",
        "sizeof",
        "(DCHAR_T)",
        "(",
        "DCHAR_T",
        ")",
        "!=",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        "",
        "",
        "# endif",
        "{\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = *--tmpsrc;\n                          }",
        "{",
        "const TCHAR_T *tmpsrc;",
        "const",
        "const",
        "TCHAR_T",
        "*tmpsrc",
        "*",
        "tmpsrc",
        ";",
        "DCHAR_T *tmpdst;",
        "DCHAR_T",
        "*tmpdst",
        "*",
        "tmpdst",
        ";",
        "size_t n;",
        "size_t",
        "n",
        ";",
        "# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif",
        "# if",
        "USE_SNPRINTF",
        "\n",
        "if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }",
        "if",
        "(result == resultbuf)",
        "(",
        "result == resultbuf",
        "result",
        "==",
        "resultbuf",
        ")",
        "{\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }",
        "{",
        "tmpsrc = (TCHAR_T *) (result + length);",
        "tmpsrc = (TCHAR_T *) (result + length)",
        "tmpsrc",
        "=",
        "(TCHAR_T *) (result + length)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "*",
        ")",
        "(result + length)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ")",
        ";",
        "/* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */",
        "ENSURE_ALLOCATION (xsum (length, count));",
        "ENSURE_ALLOCATION",
        "(xsum (length, count))",
        "("
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/vasnprintf.h": {},
  "findutils/findutils-4.6.0/gl/lib/verify.h": {},
  "findutils/findutils-4.6.0/gl/lib/version-etc-fsf.c": {},
  "findutils/findutils-4.6.0/gl/lib/version-etc.c": {
    "version_etc_arn": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        172,
        1
      ],
      "content": "void\nversion_etc_arn (FILE *stream,\n                 const char *command_name, const char *package,\n                 const char *version,\n                 const char * const * authors, size_t n_authors)\n{\n  if (command_name)\n    fprintf (stream, \"%s (%s) %s\\n\", command_name, package, version);\n  else\n    fprintf (stream, \"%s %s\\n\", package, version);\n\n#ifdef PACKAGE_PACKAGER\n# ifdef PACKAGE_PACKAGER_VERSION\n  fprintf (stream, _(\"Packaged by %s (%s)\\n\"), PACKAGE_PACKAGER,\n           PACKAGE_PACKAGER_VERSION);\n# else\n  fprintf (stream, _(\"Packaged by %s\\n\"), PACKAGE_PACKAGER);\n# endif\n#endif\n\n  /* TRANSLATORS: Translate \"(C)\" to the copyright symbol\n     (C-in-a-circle), if this symbol is available in the user's\n     locale.  Otherwise, do not translate \"(C)\"; leave it as-is.  */\n  fprintf (stream, version_etc_copyright, _(\"(C)\"), COPYRIGHT_YEAR);\n\n  fputs (_(\"\\\n\\n\\\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.\\n\\\nThis is free software: you are free to change and redistribute it.\\n\\\nThere is NO WARRANTY, to the extent permitted by law.\\n\\\n\\n\\\n\"),\n         stream);\n\n  switch (n_authors)\n    {\n    case 0:\n      /* The caller must provide at least one author name.  */\n      abort ();\n    case 1:\n      /* TRANSLATORS: %s denotes an author name.  */\n      fprintf (stream, _(\"Written by %s.\\n\"), authors[0]);\n      break;\n    case 2:\n      /* TRANSLATORS: Each %s denotes an author name.  */\n      fprintf (stream, _(\"Written by %s and %s.\\n\"), authors[0], authors[1]);\n      break;\n    case 3:\n      /* TRANSLATORS: Each %s denotes an author name.  */\n      fprintf (stream, _(\"Written by %s, %s, and %s.\\n\"),\n               authors[0], authors[1], authors[2]);\n      break;\n    case 4:\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"Written by %s, %s, %s,\\nand %s.\\n\"),\n               authors[0], authors[1], authors[2], authors[3]);\n      break;\n    case 5:\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"Written by %s, %s, %s,\\n%s, and %s.\\n\"),\n               authors[0], authors[1], authors[2], authors[3], authors[4]);\n      break;\n    case 6:\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"Written by %s, %s, %s,\\n%s, %s, and %s.\\n\"),\n               authors[0], authors[1], authors[2], authors[3], authors[4],\n               authors[5]);\n      break;\n    case 7:\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"Written by %s, %s, %s,\\n%s, %s, %s, and %s.\\n\"),\n               authors[0], authors[1], authors[2], authors[3], authors[4],\n               authors[5], authors[6]);\n      break;\n    case 8:\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"\\\nWritten by %s, %s, %s,\\n%s, %s, %s, %s,\\nand %s.\\n\"),\n                authors[0], authors[1], authors[2], authors[3], authors[4],\n                authors[5], authors[6], authors[7]);\n      break;\n    case 9:\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"\\\nWritten by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, and %s.\\n\"),\n               authors[0], authors[1], authors[2], authors[3], authors[4],\n               authors[5], authors[6], authors[7], authors[8]);\n      break;\n    default:\n      /* 10 or more authors.  Use an abbreviation, since the human reader\n         will probably not want to read the entire list anyway.  */\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"\\\nWritten by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, %s, and others.\\n\"),\n                authors[0], authors[1], authors[2], authors[3], authors[4],\n                authors[5], authors[6], authors[7], authors[8]);\n      break;\n    }\n}",
      "lines": 113,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "version_etc_ar": {
      "start_point": [
        178,
        0
      ],
      "end_point": [
        188,
        1
      ],
      "content": "void\nversion_etc_ar (FILE *stream,\n                const char *command_name, const char *package,\n                const char *version, const char * const * authors)\n{\n  size_t n_authors;\n\n  for (n_authors = 0; authors[n_authors]; n_authors++)\n    ;\n  version_etc_arn (stream, command_name, package, version, authors, n_authors);\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "version_etc_va": {
      "start_point": [
        194,
        0
      ],
      "end_point": [
        209,
        1
      ],
      "content": "void\nversion_etc_va (FILE *stream,\n                const char *command_name, const char *package,\n                const char *version, va_list authors)\n{\n  size_t n_authors;\n  const char *authtab[10];\n\n  for (n_authors = 0;\n       n_authors < 10\n         && (authtab[n_authors] = va_arg (authors, const char *)) != NULL;\n       n_authors++)\n    ;\n  version_etc_arn (stream, command_name, package, version,\n                   authtab, n_authors);\n}",
      "lines": 16,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "version_etc": {
      "start_point": [
        225,
        0
      ],
      "end_point": [
        235,
        1
      ],
      "content": "void\nversion_etc (FILE *stream,\n             const char *command_name, const char *package,\n             const char *version, /* const char *author1, ...*/ ...)\n{\n  va_list authors;\n\n  va_start (authors, version);\n  version_etc_va (stream, command_name, package, version, authors);\n  va_end (authors);\n}",
      "lines": 11,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "emit_bug_reporting_address": {
      "start_point": [
        237,
        0
      ],
      "end_point": [
        257,
        1
      ],
      "content": "void\nemit_bug_reporting_address (void)\n{\n  /* TRANSLATORS: The placeholder indicates the bug-reporting address\n     for this package.  Please add _another line_ saying\n     \"Report translation bugs to <...>\\n\" with the address for translation\n     bugs (typically your translation team's web or email address).  */\n  printf (_(\"\\nReport bugs to: %s\\n\"), PACKAGE_BUGREPORT);\n#ifdef PACKAGE_PACKAGER_BUG_REPORTS\n  printf (_(\"Report %s bugs to: %s\\n\"), PACKAGE_PACKAGER,\n          PACKAGE_PACKAGER_BUG_REPORTS);\n#endif\n#ifdef PACKAGE_URL\n  printf (_(\"%s home page: <%s>\\n\"), PACKAGE_NAME, PACKAGE_URL);\n#else\n  printf (_(\"%s home page: <http://www.gnu.org/software/%s/>\\n\"),\n          PACKAGE_NAME, PACKAGE);\n#endif\n  fputs (_(\"General help using GNU software: <http://www.gnu.org/gethelp/>\\n\"),\n         stdout);\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/version-etc.h": {},
  "findutils/findutils-4.6.0/gl/lib/w32sock.h": {
    "set_winsock_errno": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "static inline void\nset_winsock_errno (void)\n{\n  int err = WSAGetLastError ();\n\n  /* Map some WSAE* errors to the runtime library's error codes.  */\n  switch (err)\n    {\n    case WSA_INVALID_HANDLE:\n      errno = EBADF;\n      break;\n    case WSA_NOT_ENOUGH_MEMORY:\n      errno = ENOMEM;\n      break;\n    case WSA_INVALID_PARAMETER:\n      errno = EINVAL;\n      break;\n    case WSAENAMETOOLONG:\n      errno = ENAMETOOLONG;\n      break;\n    case WSAENOTEMPTY:\n      errno = ENOTEMPTY;\n      break;\n    case WSAEWOULDBLOCK:\n      errno = EWOULDBLOCK;\n      break;\n    case WSAEINPROGRESS:\n      errno = EINPROGRESS;\n      break;\n    case WSAEALREADY:\n      errno = EALREADY;\n      break;\n    case WSAENOTSOCK:\n      errno = ENOTSOCK;\n      break;\n    case WSAEDESTADDRREQ:\n      errno = EDESTADDRREQ;\n      break;\n    case WSAEMSGSIZE:\n      errno = EMSGSIZE;\n      break;\n    case WSAEPROTOTYPE:\n      errno = EPROTOTYPE;\n      break;\n    case WSAENOPROTOOPT:\n      errno = ENOPROTOOPT;\n      break;\n    case WSAEPROTONOSUPPORT:\n      errno = EPROTONOSUPPORT;\n      break;\n    case WSAEOPNOTSUPP:\n      errno = EOPNOTSUPP;\n      break;\n    case WSAEAFNOSUPPORT:\n      errno = EAFNOSUPPORT;\n      break;\n    case WSAEADDRINUSE:\n      errno = EADDRINUSE;\n      break;\n    case WSAEADDRNOTAVAIL:\n      errno = EADDRNOTAVAIL;\n      break;\n    case WSAENETDOWN:\n      errno = ENETDOWN;\n      break;\n    case WSAENETUNREACH:\n      errno = ENETUNREACH;\n      break;\n    case WSAENETRESET:\n      errno = ENETRESET;\n      break;\n    case WSAECONNABORTED:\n      errno = ECONNABORTED;\n      break;\n    case WSAECONNRESET:\n      errno = ECONNRESET;\n      break;\n    case WSAENOBUFS:\n      errno = ENOBUFS;\n      break;\n    case WSAEISCONN:\n      errno = EISCONN;\n      break;\n    case WSAENOTCONN:\n      errno = ENOTCONN;\n      break;\n    case WSAETIMEDOUT:\n      errno = ETIMEDOUT;\n      break;\n    case WSAECONNREFUSED:\n      errno = ECONNREFUSED;\n      break;\n    case WSAELOOP:\n      errno = ELOOP;\n      break;\n    case WSAEHOSTUNREACH:\n      errno = EHOSTUNREACH;\n      break;\n    default:\n      errno = (err > 10000 && err < 10025) ? err - 10000 : err;\n      break;\n    }\n}",
      "lines": 103,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/wchar.in.h": {},
  "findutils/findutils-4.6.0/gl/lib/wcrtomb.c": {
    "wcrtomb": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "size_t\nwcrtomb (char *s, wchar_t wc, mbstate_t *ps)\n{\n  /* This implementation of wcrtomb on top of wctomb() supports only\n     stateless encodings.  ps must be in the initial state.  */\n  if (ps != NULL && !mbsinit (ps))\n    {\n      errno = EINVAL;\n      return (size_t)(-1);\n    }\n\n  if (s == NULL)\n    /* We know the NUL wide character corresponds to the NUL character.  */\n    return 1;\n  else\n    {\n      int ret = wctomb (s, wc);\n\n      if (ret >= 0)\n        return ret;\n      else\n        {\n          errno = EILSEQ;\n          return (size_t)(-1);\n        }\n    }\n}",
      "lines": 27,
      "depth": 10,
      "decorators": [
        "size_t"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/wctype-h.c": {},
  "findutils/findutils-4.6.0/gl/lib/wctype.in.h": {
    "rpl_towlower": {
      "start_point": [
        353,
        0
      ],
      "end_point": [
        357,
        1
      ],
      "content": "_GL_WCTYPE_INLINE wint_t\nrpl_towlower (wint_t wc)\n{\n  return (wint_t) (wchar_t) towlower (wc);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "_GL_WCTYPE_INLINE",
        "wint_t",
        "wint_t"
      ]
    },
    "rpl_towupper": {
      "start_point": [
        362,
        0
      ],
      "end_point": [
        366,
        1
      ],
      "content": "_GL_WCTYPE_INLINE wint_t\nrpl_towupper (wint_t wc)\n{\n  return (wint_t) (wchar_t) towupper (wc);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "_GL_WCTYPE_INLINE",
        "wint_t",
        "wint_t"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/wcwidth.c": {},
  "findutils/findutils-4.6.0/gl/lib/xalloc-die.c": {
    "xalloc_die": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "void\nxalloc_die (void)\n{\n  error (exit_failure, 0, \"%s\", _(\"memory exhausted\"));\n\n  /* _Noreturn cannot be given to error, since it may return if\n     its first argument is 0.  To help compilers understand the\n     xalloc_die does not return, call abort.  Also, the abort is a\n     safety feature if exit_failure is 0 (which shouldn't happen).  */\n  abort ();\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/xalloc-oversized.h": {},
  "findutils/findutils-4.6.0/gl/lib/xalloc.h": {
    "xnmalloc": {
      "start_point": [
        102,
        0
      ],
      "end_point": [
        108,
        1
      ],
      "content": "XALLOC_INLINE void *\nxnmalloc (size_t n, size_t s)\n{\n  if (xalloc_oversized (n, s))\n    xalloc_die ();\n  return xmalloc (n * s);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "XALLOC_INLINE",
        "void",
        "void",
        "*\nxnmalloc (size_t n, size_t s)",
        "*"
      ]
    },
    "xnrealloc": [
      {
        "start_point": [
          115,
          0
        ],
        "end_point": [
          121,
          1
        ],
        "content": "XALLOC_INLINE void *\nxnrealloc (void *p, size_t n, size_t s)\n{\n  if (xalloc_oversized (n, s))\n    xalloc_die ();\n  return xrealloc (p, n * s);\n}",
        "lines": 7,
        "depth": 7,
        "decorators": [
          "XALLOC_INLINE",
          "void",
          "void",
          "*\nxnrealloc (void *p, size_t n, size_t s)",
          "*"
        ]
      },
      {
        "start_point": [
          235,
          29
        ],
        "end_point": [
          239,
          1
        ],
        "content": "T *\nxnrealloc (T *p, size_t n, size_t s)\n{\n  return (T *) xnrealloc ((void *) p, n, s);\n}",
        "lines": 5,
        "depth": 10,
        "decorators": [
          "T",
          "*\nxnrealloc (T *p, size_t n, size_t s)",
          "*"
        ]
      }
    ],
    "x2nrealloc": [
      {
        "start_point": [
          177,
          0
        ],
        "end_point": [
          209,
          1
        ],
        "content": "XALLOC_INLINE void *\nx2nrealloc (void *p, size_t *pn, size_t s)\n{\n  size_t n = *pn;\n\n  if (! p)\n    {\n      if (! n)\n        {\n          /* The approximate size to use for initial small allocation\n             requests, when the invoking code specifies an old size of\n             zero.  This is the largest \"small\" request for the GNU C\n             library malloc.  */\n          enum { DEFAULT_MXFAST = 64 * sizeof (size_t) / 4 };\n\n          n = DEFAULT_MXFAST / s;\n          n += !n;\n        }\n    }\n  else\n    {\n      /* Set N = floor (1.5 * N) + 1 so that progress is made even if N == 0.\n         Check for overflow, so that N * S stays in size_t range.\n         The check may be slightly conservative, but an exact check isn't\n         worth the trouble.  */\n      if ((size_t) -1 / 3 * 2 / s <= n)\n        xalloc_die ();\n      n += n / 2 + 1;\n    }\n\n  *pn = n;\n  return xrealloc (p, n * s);\n}",
        "lines": 33,
        "depth": 14,
        "decorators": [
          "XALLOC_INLINE",
          "void",
          "void",
          "*\nx2nrealloc (void *p, size_t *pn, size_t s)",
          "*"
        ]
      },
      {
        "start_point": [
          247,
          29
        ],
        "end_point": [
          251,
          1
        ],
        "content": "T *\nx2nrealloc (T *p, size_t *pn, size_t s)\n{\n  return (T *) x2nrealloc ((void *) p, pn, s);\n}",
        "lines": 5,
        "depth": 10,
        "decorators": [
          "T",
          "*\nx2nrealloc (T *p, size_t *pn, size_t s)",
          "*"
        ]
      }
    ],
    "xcharalloc": {
      "start_point": [
        216,
        0
      ],
      "end_point": [
        220,
        1
      ],
      "content": "XALLOC_INLINE char *\nxcharalloc (size_t n)\n{\n  return XNMALLOC (n, char);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "XALLOC_INLINE",
        "char",
        "char",
        "*\nxcharalloc (size_t n)",
        "*"
      ]
    },
    "xrealloc": {
      "start_point": [
        229,
        29
      ],
      "end_point": [
        233,
        1
      ],
      "content": "T *\nxrealloc (T *p, size_t s)\n{\n  return (T *) xrealloc ((void *) p, s);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "T",
        "*\nxrealloc (T *p, size_t s)",
        "*"
      ]
    },
    "x2realloc": {
      "start_point": [
        241,
        29
      ],
      "end_point": [
        245,
        1
      ],
      "content": "T *\nx2realloc (T *p, size_t *pn)\n{\n  return (T *) x2realloc ((void *) p, pn);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "T",
        "*\nx2realloc (T *p, size_t *pn)",
        "*"
      ]
    },
    "xmemdup": {
      "start_point": [
        253,
        29
      ],
      "end_point": [
        257,
        1
      ],
      "content": "T *\nxmemdup (T const *p, size_t s)\n{\n  return (T *) xmemdup ((void const *) p, s);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "T",
        "*\nxmemdup (T const *p, size_t s)",
        "*"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/xgetcwd.c": {
    "xgetcwd": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "char *\nxgetcwd (void)\n{\n  char *cwd = getcwd (NULL, 0);\n  if (! cwd && errno == ENOMEM)\n    xalloc_die ();\n  return cwd;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "char",
        "*\nxgetcwd (void)",
        "*"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/xgetcwd.h": {},
  "findutils/findutils-4.6.0/gl/lib/xmalloc.c": {
    "xmalloc": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "void *\nxmalloc (size_t n)\n{\n  void *p = malloc (n);\n  if (!p && n != 0)\n    xalloc_die ();\n  return p;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void",
        "*\nxmalloc (size_t n)",
        "*"
      ]
    },
    "xrealloc": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "void *\nxrealloc (void *p, size_t n)\n{\n  if (!n && p)\n    {\n      /* The GNU and C99 realloc behaviors disagree here.  Act like\n         GNU, even if the underlying realloc is C99.  */\n      free (p);\n      return NULL;\n    }\n\n  p = realloc (p, n);\n  if (!p && n)\n    xalloc_die ();\n  return p;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "void",
        "*\nxrealloc (void *p, size_t n)",
        "*"
      ]
    },
    "x2realloc": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "void *\nx2realloc (void *p, size_t *pn)\n{\n  return x2nrealloc (p, pn, 1);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void",
        "*\nx2realloc (void *p, size_t *pn)",
        "*"
      ]
    },
    "xzalloc": {
      "start_point": [
        82,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "void *\nxzalloc (size_t s)\n{\n  return memset (xmalloc (s), 0, s);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void",
        "*\nxzalloc (size_t s)",
        "*"
      ]
    },
    "xcalloc": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "void *\nxcalloc (size_t n, size_t s)\n{\n  void *p;\n  /* Test for overflow, since some calloc implementations don't have\n     proper overflow checks.  But omit overflow and size-zero tests if\n     HAVE_GNU_CALLOC, since GNU calloc catches overflow and never\n     returns NULL if successful.  */\n  if ((! HAVE_GNU_CALLOC && xalloc_oversized (n, s))\n      || (! (p = calloc (n, s)) && (HAVE_GNU_CALLOC || n != 0)))\n    xalloc_die ();\n  return p;\n}",
      "lines": 13,
      "depth": 13,
      "decorators": [
        "void",
        "*\nxcalloc (size_t n, size_t s)",
        "*"
      ]
    },
    "xmemdup": {
      "start_point": [
        109,
        0
      ],
      "end_point": [
        113,
        1
      ],
      "content": "void *\nxmemdup (void const *p, size_t s)\n{\n  return memcpy (xmalloc (s), p, s);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void",
        "*\nxmemdup (void const *p, size_t s)",
        "*"
      ]
    },
    "xstrdup": {
      "start_point": [
        117,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "char *\nxstrdup (char const *string)\n{\n  return xmemdup (string, strlen (string) + 1);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "char",
        "*\nxstrdup (char const *string)",
        "*"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/xsize.c": {},
  "findutils/findutils-4.6.0/gl/lib/xsize.h": {
    "size_t": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "__attribute__ ((__pure__))\n#endif\nxsum (size_t size1, size_t size2)\n{\n  size_t sum = size1 + size2;\n  return (sum >= size1 ? sum : SIZE_MAX);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": null
    },
    "__pure__": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        98,
        1
      ],
      "content": "__attribute__ ((__pure__))\n#endif\nxmax (size_t size1, size_t size2)\n{\n  /* No explicit check is needed here, because for any n:\n     max (SIZE_MAX, n) == SIZE_MAX and max (n, SIZE_MAX) == SIZE_MAX.  */\n  return (size1 >= size2 ? size1 : size2);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": null
    }
  },
  "findutils/findutils-4.6.0/gl/lib/xstrndup.c": {
    "xstrndup": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        35,
        1
      ],
      "content": "char *\nxstrndup (const char *string, size_t n)\n{\n  char *s = strndup (string, n);\n  if (! s)\n    xalloc_die ();\n  return s;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "char",
        "*\nxstrndup (const char *string, size_t n)",
        "*"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/xstrndup.h": {},
  "findutils/findutils-4.6.0/gl/lib/xstrtod.c": {
    "XSTRTOD": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "bool\nXSTRTOD (char const *str, char const **ptr, DOUBLE *result,\n         DOUBLE (*convert) (char const *, char **))\n{\n  DOUBLE val;\n  char *terminator;\n  bool ok = true;\n\n  errno = 0;\n  val = convert (str, &terminator);\n\n  /* Having a non-zero terminator is an error only when PTR is NULL. */\n  if (terminator == str || (ptr == NULL && *terminator != '\\0'))\n    ok = false;\n  else\n    {\n      /* Allow underflow (in which case CONVERT returns zero),\n         but flag overflow as an error. */\n      if (val != 0 && errno == ERANGE)\n        ok = false;\n    }\n\n  if (ptr != NULL)\n    *ptr = terminator;\n\n  *result = val;\n  return ok;\n}",
      "lines": 28,
      "depth": 10,
      "decorators": [
        "bool"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/xstrtod.h": {},
  "findutils/findutils-4.6.0/gl/lib/xstrtol-error.c": {
    "xstrtol_error": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "static void\nxstrtol_error (enum strtol_error err,\n               int opt_idx, char c, struct option const *long_options,\n               char const *arg,\n               int exit_status)\n{\n  char const *hyphens = \"--\";\n  char const *msgid;\n  char const *option;\n  char option_buffer[2];\n\n  switch (err)\n    {\n    default:\n      abort ();\n\n    case LONGINT_INVALID:\n      msgid = N_(\"invalid %s%s argument '%s'\");\n      break;\n\n    case LONGINT_INVALID_SUFFIX_CHAR:\n    case LONGINT_INVALID_SUFFIX_CHAR_WITH_OVERFLOW:\n      msgid = N_(\"invalid suffix in %s%s argument '%s'\");\n      break;\n\n    case LONGINT_OVERFLOW:\n      msgid = N_(\"%s%s argument '%s' too large\");\n      break;\n    }\n\n  if (opt_idx < 0)\n    {\n      hyphens -= opt_idx;\n      option_buffer[0] = c;\n      option_buffer[1] = '\\0';\n      option = option_buffer;\n    }\n  else\n    option = long_options[opt_idx].name;\n\n  error (exit_status, 0, gettext (msgid), hyphens, option, arg);\n}",
      "lines": 42,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "xstrtol_fatal": {
      "start_point": [
        90,
        0
      ],
      "end_point": [
        97,
        1
      ],
      "content": "void\nxstrtol_fatal (enum strtol_error err,\n               int opt_idx, char c, struct option const *long_options,\n               char const *arg)\n{\n  xstrtol_error (err, opt_idx, c, long_options, arg, exit_failure);\n  abort ();\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "void"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/xstrtol.c": {
    "bkm_scale": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        73,
        1
      ],
      "content": "static strtol_error\nbkm_scale (__strtol_t *x, int scale_factor)\n{\n  if (TYPE_SIGNED (__strtol_t) && *x < STRTOL_T_MINIMUM / scale_factor)\n    {\n      *x = STRTOL_T_MINIMUM;\n      return LONGINT_OVERFLOW;\n    }\n  if (STRTOL_T_MAXIMUM / scale_factor < *x)\n    {\n      *x = STRTOL_T_MAXIMUM;\n      return LONGINT_OVERFLOW;\n    }\n  *x *= scale_factor;\n  return LONGINT_OK;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "strtol_error"
      ]
    },
    "bkm_scale_by_power": {
      "start_point": [
        75,
        0
      ],
      "end_point": [
        82,
        1
      ],
      "content": "static strtol_error\nbkm_scale_by_power (__strtol_t *x, int base, int power)\n{\n  strtol_error err = LONGINT_OK;\n  while (power--)\n    err |= bkm_scale (x, base);\n  return err;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "strtol_error"
      ]
    },
    "__xstrtol": {
      "start_point": [
        86,
        0
      ],
      "end_point": [
        241,
        1
      ],
      "content": "strtol_error\n__xstrtol (const char *s, char **ptr, int strtol_base,\n           __strtol_t *val, const char *valid_suffixes)\n{\n  char *t_ptr;\n  char **p;\n  __strtol_t tmp;\n  strtol_error err = LONGINT_OK;\n\n  assure (0 <= strtol_base && strtol_base <= 36);\n\n  p = (ptr ? ptr : &t_ptr);\n\n  errno = 0;\n\n  if (! TYPE_SIGNED (__strtol_t))\n    {\n      const char *q = s;\n      unsigned char ch = *q;\n      while (isspace (ch))\n        ch = *++q;\n      if (ch == '-')\n        return LONGINT_INVALID;\n    }\n\n  tmp = __strtol (s, p, strtol_base);\n\n  if (*p == s)\n    {\n      /* If there is no number but there is a valid suffix, assume the\n         number is 1.  The string is invalid otherwise.  */\n      if (valid_suffixes && **p && strchr (valid_suffixes, **p))\n        tmp = 1;\n      else\n        return LONGINT_INVALID;\n    }\n  else if (errno != 0)\n    {\n      if (errno != ERANGE)\n        return LONGINT_INVALID;\n      err = LONGINT_OVERFLOW;\n    }\n\n  /* Let valid_suffixes == NULL mean \"allow any suffix\".  */\n  /* FIXME: update all callers except the ones that allow suffixes\n     after the number, changing last parameter NULL to \"\".  */\n  if (!valid_suffixes)\n    {\n      *val = tmp;\n      return err;\n    }\n\n  if (**p != '\\0')\n    {\n      int base = 1024;\n      int suffixes = 1;\n      strtol_error overflow;\n\n      if (!strchr (valid_suffixes, **p))\n        {\n          *val = tmp;\n          return err | LONGINT_INVALID_SUFFIX_CHAR;\n        }\n\n      if (strchr (valid_suffixes, '0'))\n        {\n          /* The \"valid suffix\" '0' is a special flag meaning that\n             an optional second suffix is allowed, which can change\n             the base.  A suffix \"B\" (e.g. \"100MB\") stands for a power\n             of 1000, whereas a suffix \"iB\" (e.g. \"100MiB\") stands for\n             a power of 1024.  If no suffix (e.g. \"100M\"), assume\n             power-of-1024.  */\n\n          switch (p[0][1])\n            {\n            case 'i':\n              if (p[0][2] == 'B')\n                suffixes += 2;\n              break;\n\n            case 'B':\n            case 'D': /* 'D' is obsolescent */\n              base = 1000;\n              suffixes++;\n              break;\n            }\n        }\n\n      switch (**p)\n        {\n        case 'b':\n          overflow = bkm_scale (&tmp, 512);\n          break;\n\n        case 'B':\n          overflow = bkm_scale (&tmp, 1024);\n          break;\n\n        case 'c':\n          overflow = LONGINT_OK;\n          break;\n\n        case 'E': /* exa or exbi */\n          overflow = bkm_scale_by_power (&tmp, base, 6);\n          break;\n\n        case 'G': /* giga or gibi */\n        case 'g': /* 'g' is undocumented; for compatibility only */\n          overflow = bkm_scale_by_power (&tmp, base, 3);\n          break;\n\n        case 'k': /* kilo */\n        case 'K': /* kibi */\n          overflow = bkm_scale_by_power (&tmp, base, 1);\n          break;\n\n        case 'M': /* mega or mebi */\n        case 'm': /* 'm' is undocumented; for compatibility only */\n          overflow = bkm_scale_by_power (&tmp, base, 2);\n          break;\n\n        case 'P': /* peta or pebi */\n          overflow = bkm_scale_by_power (&tmp, base, 5);\n          break;\n\n        case 'T': /* tera or tebi */\n        case 't': /* 't' is undocumented; for compatibility only */\n          overflow = bkm_scale_by_power (&tmp, base, 4);\n          break;\n\n        case 'w':\n          overflow = bkm_scale (&tmp, 2);\n          break;\n\n        case 'Y': /* yotta or 2**80 */\n          overflow = bkm_scale_by_power (&tmp, base, 8);\n          break;\n\n        case 'Z': /* zetta or 2**70 */\n          overflow = bkm_scale_by_power (&tmp, base, 7);\n          break;\n\n        default:\n          *val = tmp;\n          return err | LONGINT_INVALID_SUFFIX_CHAR;\n        }\n\n      err |= overflow;\n      *p += suffixes;\n      if (**p)\n        err |= LONGINT_INVALID_SUFFIX_CHAR;\n    }\n\n  *val = tmp;\n  return err;\n}",
      "lines": 156,
      "depth": 15,
      "decorators": [
        "strtol_error"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/xstrtol.h": {},
  "findutils/findutils-4.6.0/gl/lib/xstrtoul.c": {},
  "findutils/findutils-4.6.0/gl/lib/xstrtoumax.c": {},
  "findutils/findutils-4.6.0/gl/lib/yesno.c": {
    "yesno": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "bool\nyesno (void)\n{\n  bool yes;\n\n#if ENABLE_NLS\n  char *response = NULL;\n  size_t response_size = 0;\n  ssize_t response_len = getline (&response, &response_size, stdin);\n\n  if (response_len <= 0)\n    yes = false;\n  else\n    {\n      /* Remove EOL if present as that's not part of the matched response,\n         and not matched by $ for example.  */\n      if (response[response_len - 1] == '\\n')\n        response[response_len - 1] = '\\0';\n      yes = (0 < rpmatch (response));\n    }\n\n  free (response);\n#else\n  /* Test against \"^[yY]\", hardcoded to avoid requiring getline,\n     regex, and rpmatch.  */\n  int c = getchar ();\n  yes = (c == 'y' || c == 'Y');\n  while (c != '\\n' && c != EOF)\n    c = getchar ();\n#endif\n\n  return yes;\n}",
      "lines": 33,
      "depth": 12,
      "decorators": [
        "bool"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/yesno.h": {},
  "findutils/findutils-4.6.0/gl/lib/glthread/lock.c": {
    "glthread_rwlock_init_multithreaded": [
      {
        "start_point": [
          36,
          0
        ],
        "end_point": [
          46,
          1
        ],
        "content": "int\nglthread_rwlock_init_multithreaded (gl_rwlock_t *lock)\n{\n  int err;\n\n  err = pthread_rwlock_init (&lock->rwlock, NULL);\n  if (err != 0)\n    return err;\n  lock->initialized = 1;\n  return 0;\n}",
        "lines": 11,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          126,
          0
        ],
        "end_point": [
          143,
          1
        ],
        "content": "int\nglthread_rwlock_init_multithreaded (gl_rwlock_t *lock)\n{\n  int err;\n\n  err = pthread_mutex_init (&lock->lock, NULL);\n  if (err != 0)\n    return err;\n  err = pthread_cond_init (&lock->waiting_readers, NULL);\n  if (err != 0)\n    return err;\n  err = pthread_cond_init (&lock->waiting_writers, NULL);\n  if (err != 0)\n    return err;\n  lock->waiting_writers_count = 0;\n  lock->runcount = 0;\n  return 0;\n}",
        "lines": 18,
        "depth": 9,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_rwlock_rdlock_multithreaded": [
      {
        "start_point": [
          48,
          0
        ],
        "end_point": [
          72,
          1
        ],
        "content": "int\nglthread_rwlock_rdlock_multithreaded (gl_rwlock_t *lock)\n{\n  if (!lock->initialized)\n    {\n      int err;\n\n      err = pthread_mutex_lock (&lock->guard);\n      if (err != 0)\n        return err;\n      if (!lock->initialized)\n        {\n          err = glthread_rwlock_init_multithreaded (lock);\n          if (err != 0)\n            {\n              pthread_mutex_unlock (&lock->guard);\n              return err;\n            }\n        }\n      err = pthread_mutex_unlock (&lock->guard);\n      if (err != 0)\n        return err;\n    }\n  return pthread_rwlock_rdlock (&lock->rwlock);\n}",
        "lines": 25,
        "depth": 14,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          145,
          0
        ],
        "end_point": [
          172,
          1
        ],
        "content": "int\nglthread_rwlock_rdlock_multithreaded (gl_rwlock_t *lock)\n{\n  int err;\n\n  err = pthread_mutex_lock (&lock->lock);\n  if (err != 0)\n    return err;\n  /* Test whether only readers are currently running, and whether the runcount\n     field will not overflow.  */\n  /* POSIX says: \"It is implementation-defined whether the calling thread\n     acquires the lock when a writer does not hold the lock and there are\n     writers blocked on the lock.\"  Let's say, no: give the writers a higher\n     priority.  */\n  while (!(lock->runcount + 1 > 0 && lock->waiting_writers_count == 0))\n    {\n      /* This thread has to wait for a while.  Enqueue it among the\n         waiting_readers.  */\n      err = pthread_cond_wait (&lock->waiting_readers, &lock->lock);\n      if (err != 0)\n        {\n          pthread_mutex_unlock (&lock->lock);\n          return err;\n        }\n    }\n  lock->runcount++;\n  return pthread_mutex_unlock (&lock->lock);\n}",
        "lines": 28,
        "depth": 12,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_rwlock_wrlock_multithreaded": [
      {
        "start_point": [
          74,
          0
        ],
        "end_point": [
          98,
          1
        ],
        "content": "int\nglthread_rwlock_wrlock_multithreaded (gl_rwlock_t *lock)\n{\n  if (!lock->initialized)\n    {\n      int err;\n\n      err = pthread_mutex_lock (&lock->guard);\n      if (err != 0)\n        return err;\n      if (!lock->initialized)\n        {\n          err = glthread_rwlock_init_multithreaded (lock);\n          if (err != 0)\n            {\n              pthread_mutex_unlock (&lock->guard);\n              return err;\n            }\n        }\n      err = pthread_mutex_unlock (&lock->guard);\n      if (err != 0)\n        return err;\n    }\n  return pthread_rwlock_wrlock (&lock->rwlock);\n}",
        "lines": 25,
        "depth": 14,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          174,
          0
        ],
        "end_point": [
          199,
          1
        ],
        "content": "int\nglthread_rwlock_wrlock_multithreaded (gl_rwlock_t *lock)\n{\n  int err;\n\n  err = pthread_mutex_lock (&lock->lock);\n  if (err != 0)\n    return err;\n  /* Test whether no readers or writers are currently running.  */\n  while (!(lock->runcount == 0))\n    {\n      /* This thread has to wait for a while.  Enqueue it among the\n         waiting_writers.  */\n      lock->waiting_writers_count++;\n      err = pthread_cond_wait (&lock->waiting_writers, &lock->lock);\n      if (err != 0)\n        {\n          lock->waiting_writers_count--;\n          pthread_mutex_unlock (&lock->lock);\n          return err;\n        }\n      lock->waiting_writers_count--;\n    }\n  lock->runcount--; /* runcount becomes -1 */\n  return pthread_mutex_unlock (&lock->lock);\n}",
        "lines": 26,
        "depth": 12,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_rwlock_unlock_multithreaded": [
      {
        "start_point": [
          100,
          0
        ],
        "end_point": [
          106,
          1
        ],
        "content": "int\nglthread_rwlock_unlock_multithreaded (gl_rwlock_t *lock)\n{\n  if (!lock->initialized)\n    return EINVAL;\n  return pthread_rwlock_unlock (&lock->rwlock);\n}",
        "lines": 7,
        "depth": 8,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          201,
          0
        ],
        "end_point": [
          255,
          1
        ],
        "content": "int\nglthread_rwlock_unlock_multithreaded (gl_rwlock_t *lock)\n{\n  int err;\n\n  err = pthread_mutex_lock (&lock->lock);\n  if (err != 0)\n    return err;\n  if (lock->runcount < 0)\n    {\n      /* Drop a writer lock.  */\n      if (!(lock->runcount == -1))\n        {\n          pthread_mutex_unlock (&lock->lock);\n          return EINVAL;\n        }\n      lock->runcount = 0;\n    }\n  else\n    {\n      /* Drop a reader lock.  */\n      if (!(lock->runcount > 0))\n        {\n          pthread_mutex_unlock (&lock->lock);\n          return EINVAL;\n        }\n      lock->runcount--;\n    }\n  if (lock->runcount == 0)\n    {\n      /* POSIX recommends that \"write locks shall take precedence over read\n         locks\", to avoid \"writer starvation\".  */\n      if (lock->waiting_writers_count > 0)\n        {\n          /* Wake up one of the waiting writers.  */\n          err = pthread_cond_signal (&lock->waiting_writers);\n          if (err != 0)\n            {\n              pthread_mutex_unlock (&lock->lock);\n              return err;\n            }\n        }\n      else\n        {\n          /* Wake up all waiting readers.  */\n          err = pthread_cond_broadcast (&lock->waiting_readers);\n          if (err != 0)\n            {\n              pthread_mutex_unlock (&lock->lock);\n              return err;\n            }\n        }\n    }\n  return pthread_mutex_unlock (&lock->lock);\n}",
        "lines": 55,
        "depth": 14,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_rwlock_destroy_multithreaded": [
      {
        "start_point": [
          108,
          0
        ],
        "end_point": [
          120,
          1
        ],
        "content": "int\nglthread_rwlock_destroy_multithreaded (gl_rwlock_t *lock)\n{\n  int err;\n\n  if (!lock->initialized)\n    return EINVAL;\n  err = pthread_rwlock_destroy (&lock->rwlock);\n  if (err != 0)\n    return err;\n  lock->initialized = 0;\n  return 0;\n}",
        "lines": 13,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          257,
          0
        ],
        "end_point": [
          272,
          1
        ],
        "content": "int\nglthread_rwlock_destroy_multithreaded (gl_rwlock_t *lock)\n{\n  int err;\n\n  err = pthread_mutex_destroy (&lock->lock);\n  if (err != 0)\n    return err;\n  err = pthread_cond_destroy (&lock->waiting_readers);\n  if (err != 0)\n    return err;\n  err = pthread_cond_destroy (&lock->waiting_writers);\n  if (err != 0)\n    return err;\n  return 0;\n}",
        "lines": 16,
        "depth": 9,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_recursive_lock_init_multithreaded": [
      {
        "start_point": [
          282,
          0
        ],
        "end_point": [
          307,
          1
        ],
        "content": "int\nglthread_recursive_lock_init_multithreaded (gl_recursive_lock_t *lock)\n{\n  pthread_mutexattr_t attributes;\n  int err;\n\n  err = pthread_mutexattr_init (&attributes);\n  if (err != 0)\n    return err;\n  err = pthread_mutexattr_settype (&attributes, PTHREAD_MUTEX_RECURSIVE);\n  if (err != 0)\n    {\n      pthread_mutexattr_destroy (&attributes);\n      return err;\n    }\n  err = pthread_mutex_init (lock, &attributes);\n  if (err != 0)\n    {\n      pthread_mutexattr_destroy (&attributes);\n      return err;\n    }\n  err = pthread_mutexattr_destroy (&attributes);\n  if (err != 0)\n    return err;\n  return 0;\n}",
        "lines": 26,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          311,
          0
        ],
        "end_point": [
          337,
          1
        ],
        "content": "int\nglthread_recursive_lock_init_multithreaded (gl_recursive_lock_t *lock)\n{\n  pthread_mutexattr_t attributes;\n  int err;\n\n  err = pthread_mutexattr_init (&attributes);\n  if (err != 0)\n    return err;\n  err = pthread_mutexattr_settype (&attributes, PTHREAD_MUTEX_RECURSIVE);\n  if (err != 0)\n    {\n      pthread_mutexattr_destroy (&attributes);\n      return err;\n    }\n  err = pthread_mutex_init (&lock->recmutex, &attributes);\n  if (err != 0)\n    {\n      pthread_mutexattr_destroy (&attributes);\n      return err;\n    }\n  err = pthread_mutexattr_destroy (&attributes);\n  if (err != 0)\n    return err;\n  lock->initialized = 1;\n  return 0;\n}",
        "lines": 27,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          391,
          0
        ],
        "end_point": [
          402,
          1
        ],
        "content": "int\nglthread_recursive_lock_init_multithreaded (gl_recursive_lock_t *lock)\n{\n  int err;\n\n  err = pthread_mutex_init (&lock->mutex, NULL);\n  if (err != 0)\n    return err;\n  lock->owner = (pthread_t) 0;\n  lock->depth = 0;\n  return 0;\n}",
        "lines": 12,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          530,
          0
        ],
        "end_point": [
          541,
          1
        ],
        "content": "int\nglthread_recursive_lock_init_multithreaded (gl_recursive_lock_t *lock)\n{\n  int err;\n\n  err = mutex_init (&lock->mutex, USYNC_THREAD, NULL);\n  if (err != 0)\n    return err;\n  lock->owner = (thread_t) 0;\n  lock->depth = 0;\n  return 0;\n}",
        "lines": 12,
        "depth": 9,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_recursive_lock_lock_multithreaded": [
      {
        "start_point": [
          339,
          0
        ],
        "end_point": [
          363,
          1
        ],
        "content": "int\nglthread_recursive_lock_lock_multithreaded (gl_recursive_lock_t *lock)\n{\n  if (!lock->initialized)\n    {\n      int err;\n\n      err = pthread_mutex_lock (&lock->guard);\n      if (err != 0)\n        return err;\n      if (!lock->initialized)\n        {\n          err = glthread_recursive_lock_init_multithreaded (lock);\n          if (err != 0)\n            {\n              pthread_mutex_unlock (&lock->guard);\n              return err;\n            }\n        }\n      err = pthread_mutex_unlock (&lock->guard);\n      if (err != 0)\n        return err;\n    }\n  return pthread_mutex_lock (&lock->recmutex);\n}",
        "lines": 25,
        "depth": 14,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          404,
          0
        ],
        "end_point": [
          423,
          1
        ],
        "content": "int\nglthread_recursive_lock_lock_multithreaded (gl_recursive_lock_t *lock)\n{\n  pthread_t self = pthread_self ();\n  if (lock->owner != self)\n    {\n      int err;\n\n      err = pthread_mutex_lock (&lock->mutex);\n      if (err != 0)\n        return err;\n      lock->owner = self;\n    }\n  if (++(lock->depth) == 0) /* wraparound? */\n    {\n      lock->depth--;\n      return EAGAIN;\n    }\n  return 0;\n}",
        "lines": 20,
        "depth": 11,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          543,
          0
        ],
        "end_point": [
          562,
          1
        ],
        "content": "int\nglthread_recursive_lock_lock_multithreaded (gl_recursive_lock_t *lock)\n{\n  thread_t self = thr_self ();\n  if (lock->owner != self)\n    {\n      int err;\n\n      err = mutex_lock (&lock->mutex);\n      if (err != 0)\n        return err;\n      lock->owner = self;\n    }\n  if (++(lock->depth) == 0) /* wraparound? */\n    {\n      lock->depth--;\n      return EAGAIN;\n    }\n  return 0;\n}",
        "lines": 20,
        "depth": 11,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_recursive_lock_unlock_multithreaded": [
      {
        "start_point": [
          365,
          0
        ],
        "end_point": [
          371,
          1
        ],
        "content": "int\nglthread_recursive_lock_unlock_multithreaded (gl_recursive_lock_t *lock)\n{\n  if (!lock->initialized)\n    return EINVAL;\n  return pthread_mutex_unlock (&lock->recmutex);\n}",
        "lines": 7,
        "depth": 8,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          425,
          0
        ],
        "end_point": [
          439,
          1
        ],
        "content": "int\nglthread_recursive_lock_unlock_multithreaded (gl_recursive_lock_t *lock)\n{\n  if (lock->owner != pthread_self ())\n    return EPERM;\n  if (lock->depth == 0)\n    return EINVAL;\n  if (--(lock->depth) == 0)\n    {\n      lock->owner = (pthread_t) 0;\n      return pthread_mutex_unlock (&lock->mutex);\n    }\n  else\n    return 0;\n}",
        "lines": 15,
        "depth": 10,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          564,
          0
        ],
        "end_point": [
          578,
          1
        ],
        "content": "int\nglthread_recursive_lock_unlock_multithreaded (gl_recursive_lock_t *lock)\n{\n  if (lock->owner != thr_self ())\n    return EPERM;\n  if (lock->depth == 0)\n    return EINVAL;\n  if (--(lock->depth) == 0)\n    {\n      lock->owner = (thread_t) 0;\n      return mutex_unlock (&lock->mutex);\n    }\n  else\n    return 0;\n}",
        "lines": 15,
        "depth": 10,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_recursive_lock_destroy_multithreaded": [
      {
        "start_point": [
          373,
          0
        ],
        "end_point": [
          385,
          1
        ],
        "content": "int\nglthread_recursive_lock_destroy_multithreaded (gl_recursive_lock_t *lock)\n{\n  int err;\n\n  if (!lock->initialized)\n    return EINVAL;\n  err = pthread_mutex_destroy (&lock->recmutex);\n  if (err != 0)\n    return err;\n  lock->initialized = 0;\n  return 0;\n}",
        "lines": 13,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          441,
          0
        ],
        "end_point": [
          447,
          1
        ],
        "content": "int\nglthread_recursive_lock_destroy_multithreaded (gl_recursive_lock_t *lock)\n{\n  if (lock->owner != (pthread_t) 0)\n    return EBUSY;\n  return pthread_mutex_destroy (&lock->mutex);\n}",
        "lines": 7,
        "depth": 8,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          580,
          0
        ],
        "end_point": [
          586,
          1
        ],
        "content": "int\nglthread_recursive_lock_destroy_multithreaded (gl_recursive_lock_t *lock)\n{\n  if (lock->owner != (thread_t) 0)\n    return EBUSY;\n  return mutex_destroy (&lock->mutex);\n}",
        "lines": 7,
        "depth": 8,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_once_singlethreaded": [
      {
        "start_point": [
          455,
          0
        ],
        "end_point": [
          469,
          1
        ],
        "content": "int\nglthread_once_singlethreaded (pthread_once_t *once_control)\n{\n  /* We don't know whether pthread_once_t is an integer type, a floating-point\n     type, a pointer type, or a structure type.  */\n  char *firstbyte = (char *)once_control;\n  if (*firstbyte == *(const char *)&fresh_once)\n    {\n      /* First time use of once_control.  Invert the first byte.  */\n      *firstbyte = ~ *(const char *)&fresh_once;\n      return 1;\n    }\n  else\n    return 0;\n}",
        "lines": 15,
        "depth": 12,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          502,
          0
        ],
        "end_point": [
          514,
          1
        ],
        "content": "int\nglthread_once_singlethreaded (pth_once_t *once_control)\n{\n  /* We know that pth_once_t is an integer type.  */\n  if (*once_control == PTH_ONCE_INIT)\n    {\n      /* First time use of once_control.  Invert the marker.  */\n      *once_control = ~ PTH_ONCE_INIT;\n      return 1;\n    }\n  else\n    return 0;\n}",
        "lines": 13,
        "depth": 8,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          613,
          0
        ],
        "end_point": [
          625,
          1
        ],
        "content": "int\nglthread_once_singlethreaded (gl_once_t *once_control)\n{\n  /* We know that gl_once_t contains an integer type.  */\n  if (!once_control->inited)\n    {\n      /* First time use of once_control.  Invert the marker.  */\n      once_control->inited = ~ 0;\n      return 1;\n    }\n  else\n    return 0;\n}",
        "lines": 13,
        "depth": 8,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_once_call": {
      "start_point": [
        487,
        0
      ],
      "end_point": [
        493,
        1
      ],
      "content": "static void\nglthread_once_call (void *arg)\n{\n  void (**gl_once_temp_addr) (void) = (void (**) (void)) arg;\n  void (*initfunction) (void) = *gl_once_temp_addr;\n  initfunction ();\n}",
      "lines": 7,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "glthread_once_multithreaded": [
      {
        "start_point": [
          495,
          0
        ],
        "end_point": [
          500,
          1
        ],
        "content": "int\nglthread_once_multithreaded (pth_once_t *once_control, void (*initfunction) (void))\n{\n  void (*temp) (void) = initfunction;\n  return (!pth_once (once_control, glthread_once_call, &temp) ? errno : 0);\n}",
        "lines": 6,
        "depth": 10,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          590,
          0
        ],
        "end_point": [
          611,
          1
        ],
        "content": "int\nglthread_once_multithreaded (gl_once_t *once_control, void (*initfunction) (void))\n{\n  if (!once_control->inited)\n    {\n      int err;\n\n      /* Use the mutex to guarantee that if another thread is already calling\n         the initfunction, this thread waits until it's finished.  */\n      err = mutex_lock (&once_control->mutex);\n      if (err != 0)\n        return err;\n      if (!once_control->inited)\n        {\n          once_control->inited = 1;\n          initfunction ();\n        }\n      return mutex_unlock (&once_control->mutex);\n    }\n  else\n    return 0;\n}",
        "lines": 22,
        "depth": 11,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_lock_init_func": {
      "start_point": [
        635,
        0
      ],
      "end_point": [
        640,
        1
      ],
      "content": "void\nglthread_lock_init_func (gl_lock_t *lock)\n{\n  InitializeCriticalSection (&lock->lock);\n  lock->guard.done = 1;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "glthread_lock_lock_func": {
      "start_point": [
        642,
        0
      ],
      "end_point": [
        658,
        1
      ],
      "content": "int\nglthread_lock_lock_func (gl_lock_t *lock)\n{\n  if (!lock->guard.done)\n    {\n      if (InterlockedIncrement (&lock->guard.started) == 0)\n        /* This thread is the first one to need this lock.  Initialize it.  */\n        glthread_lock_init (lock);\n      else\n        /* Yield the CPU while waiting for another thread to finish\n           initializing this lock.  */\n        while (!lock->guard.done)\n          Sleep (0);\n    }\n  EnterCriticalSection (&lock->lock);\n  return 0;\n}",
      "lines": 17,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "glthread_lock_unlock_func": {
      "start_point": [
        660,
        0
      ],
      "end_point": [
        667,
        1
      ],
      "content": "int\nglthread_lock_unlock_func (gl_lock_t *lock)\n{\n  if (!lock->guard.done)\n    return EINVAL;\n  LeaveCriticalSection (&lock->lock);\n  return 0;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "glthread_lock_destroy_func": {
      "start_point": [
        669,
        0
      ],
      "end_point": [
        677,
        1
      ],
      "content": "int\nglthread_lock_destroy_func (gl_lock_t *lock)\n{\n  if (!lock->guard.done)\n    return EINVAL;\n  DeleteCriticalSection (&lock->lock);\n  lock->guard.done = 0;\n  return 0;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "gl_waitqueue_init": {
      "start_point": [
        684,
        0
      ],
      "end_point": [
        691,
        1
      ],
      "content": "static void\ngl_waitqueue_init (gl_waitqueue_t *wq)\n{\n  wq->array = NULL;\n  wq->count = 0;\n  wq->alloc = 0;\n  wq->offset = 0;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "gl_waitqueue_add": {
      "start_point": [
        695,
        0
      ],
      "end_point": [
        742,
        1
      ],
      "content": "static HANDLE\ngl_waitqueue_add (gl_waitqueue_t *wq)\n{\n  HANDLE event;\n  unsigned int index;\n\n  if (wq->count == wq->alloc)\n    {\n      unsigned int new_alloc = 2 * wq->alloc + 1;\n      HANDLE *new_array =\n        (HANDLE *) realloc (wq->array, new_alloc * sizeof (HANDLE));\n      if (new_array == NULL)\n        /* No more memory.  */\n        return INVALID_HANDLE_VALUE;\n      /* Now is a good opportunity to rotate the array so that its contents\n         starts at offset 0.  */\n      if (wq->offset > 0)\n        {\n          unsigned int old_count = wq->count;\n          unsigned int old_alloc = wq->alloc;\n          unsigned int old_offset = wq->offset;\n          unsigned int i;\n          if (old_offset + old_count > old_alloc)\n            {\n              unsigned int limit = old_offset + old_count - old_alloc;\n              for (i = 0; i < limit; i++)\n                new_array[old_alloc + i] = new_array[i];\n            }\n          for (i = 0; i < old_count; i++)\n            new_array[i] = new_array[old_offset + i];\n          wq->offset = 0;\n        }\n      wq->array = new_array;\n      wq->alloc = new_alloc;\n    }\n  /* Whether the created event is a manual-reset one or an auto-reset one,\n     does not matter, since we will wait on it only once.  */\n  event = CreateEvent (NULL, TRUE, FALSE, NULL);\n  if (event == INVALID_HANDLE_VALUE)\n    /* No way to allocate an event.  */\n    return INVALID_HANDLE_VALUE;\n  index = wq->offset + wq->count;\n  if (index >= wq->alloc)\n    index -= wq->alloc;\n  wq->array[index] = event;\n  wq->count++;\n  return event;\n}",
      "lines": 48,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "HANDLE"
      ]
    },
    "gl_waitqueue_notify_first": {
      "start_point": [
        745,
        0
      ],
      "end_point": [
        753,
        1
      ],
      "content": "static void\ngl_waitqueue_notify_first (gl_waitqueue_t *wq)\n{\n  SetEvent (wq->array[wq->offset + 0]);\n  wq->offset++;\n  wq->count--;\n  if (wq->count == 0 || wq->offset == wq->alloc)\n    wq->offset = 0;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "gl_waitqueue_notify_all": {
      "start_point": [
        756,
        0
      ],
      "end_point": [
        770,
        1
      ],
      "content": "static void\ngl_waitqueue_notify_all (gl_waitqueue_t *wq)\n{\n  unsigned int i;\n\n  for (i = 0; i < wq->count; i++)\n    {\n      unsigned int index = wq->offset + i;\n      if (index >= wq->alloc)\n        index -= wq->alloc;\n      SetEvent (wq->array[index]);\n    }\n  wq->count = 0;\n  wq->offset = 0;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "glthread_rwlock_init_func": {
      "start_point": [
        772,
        0
      ],
      "end_point": [
        780,
        1
      ],
      "content": "void\nglthread_rwlock_init_func (gl_rwlock_t *lock)\n{\n  InitializeCriticalSection (&lock->lock);\n  gl_waitqueue_init (&lock->waiting_readers);\n  gl_waitqueue_init (&lock->waiting_writers);\n  lock->runcount = 0;\n  lock->guard.done = 1;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "glthread_rwlock_rdlock_func": {
      "start_point": [
        782,
        0
      ],
      "end_point": [
        834,
        1
      ],
      "content": "int\nglthread_rwlock_rdlock_func (gl_rwlock_t *lock)\n{\n  if (!lock->guard.done)\n    {\n      if (InterlockedIncrement (&lock->guard.started) == 0)\n        /* This thread is the first one to need this lock.  Initialize it.  */\n        glthread_rwlock_init (lock);\n      else\n        /* Yield the CPU while waiting for another thread to finish\n           initializing this lock.  */\n        while (!lock->guard.done)\n          Sleep (0);\n    }\n  EnterCriticalSection (&lock->lock);\n  /* Test whether only readers are currently running, and whether the runcount\n     field will not overflow.  */\n  if (!(lock->runcount + 1 > 0))\n    {\n      /* This thread has to wait for a while.  Enqueue it among the\n         waiting_readers.  */\n      HANDLE event = gl_waitqueue_add (&lock->waiting_readers);\n      if (event != INVALID_HANDLE_VALUE)\n        {\n          DWORD result;\n          LeaveCriticalSection (&lock->lock);\n          /* Wait until another thread signals this event.  */\n          result = WaitForSingleObject (event, INFINITE);\n          if (result == WAIT_FAILED || result == WAIT_TIMEOUT)\n            abort ();\n          CloseHandle (event);\n          /* The thread which signalled the event already did the bookkeeping:\n             removed us from the waiting_readers, incremented lock->runcount.  */\n          if (!(lock->runcount > 0))\n            abort ();\n          return 0;\n        }\n      else\n        {\n          /* Allocation failure.  Weird.  */\n          do\n            {\n              LeaveCriticalSection (&lock->lock);\n              Sleep (1);\n              EnterCriticalSection (&lock->lock);\n            }\n          while (!(lock->runcount + 1 > 0));\n        }\n    }\n  lock->runcount++;\n  LeaveCriticalSection (&lock->lock);\n  return 0;\n}",
      "lines": 53,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "glthread_rwlock_wrlock_func": {
      "start_point": [
        836,
        0
      ],
      "end_point": [
        887,
        1
      ],
      "content": "int\nglthread_rwlock_wrlock_func (gl_rwlock_t *lock)\n{\n  if (!lock->guard.done)\n    {\n      if (InterlockedIncrement (&lock->guard.started) == 0)\n        /* This thread is the first one to need this lock.  Initialize it.  */\n        glthread_rwlock_init (lock);\n      else\n        /* Yield the CPU while waiting for another thread to finish\n           initializing this lock.  */\n        while (!lock->guard.done)\n          Sleep (0);\n    }\n  EnterCriticalSection (&lock->lock);\n  /* Test whether no readers or writers are currently running.  */\n  if (!(lock->runcount == 0))\n    {\n      /* This thread has to wait for a while.  Enqueue it among the\n         waiting_writers.  */\n      HANDLE event = gl_waitqueue_add (&lock->waiting_writers);\n      if (event != INVALID_HANDLE_VALUE)\n        {\n          DWORD result;\n          LeaveCriticalSection (&lock->lock);\n          /* Wait until another thread signals this event.  */\n          result = WaitForSingleObject (event, INFINITE);\n          if (result == WAIT_FAILED || result == WAIT_TIMEOUT)\n            abort ();\n          CloseHandle (event);\n          /* The thread which signalled the event already did the bookkeeping:\n             removed us from the waiting_writers, set lock->runcount = -1.  */\n          if (!(lock->runcount == -1))\n            abort ();\n          return 0;\n        }\n      else\n        {\n          /* Allocation failure.  Weird.  */\n          do\n            {\n              LeaveCriticalSection (&lock->lock);\n              Sleep (1);\n              EnterCriticalSection (&lock->lock);\n            }\n          while (!(lock->runcount == 0));\n        }\n    }\n  lock->runcount--; /* runcount becomes -1 */\n  LeaveCriticalSection (&lock->lock);\n  return 0;\n}",
      "lines": 52,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "glthread_rwlock_unlock_func": {
      "start_point": [
        889,
        0
      ],
      "end_point": [
        931,
        1
      ],
      "content": "int\nglthread_rwlock_unlock_func (gl_rwlock_t *lock)\n{\n  if (!lock->guard.done)\n    return EINVAL;\n  EnterCriticalSection (&lock->lock);\n  if (lock->runcount < 0)\n    {\n      /* Drop a writer lock.  */\n      if (!(lock->runcount == -1))\n        abort ();\n      lock->runcount = 0;\n    }\n  else\n    {\n      /* Drop a reader lock.  */\n      if (!(lock->runcount > 0))\n        {\n          LeaveCriticalSection (&lock->lock);\n          return EPERM;\n        }\n      lock->runcount--;\n    }\n  if (lock->runcount == 0)\n    {\n      /* POSIX recommends that \"write locks shall take precedence over read\n         locks\", to avoid \"writer starvation\".  */\n      if (lock->waiting_writers.count > 0)\n        {\n          /* Wake up one of the waiting writers.  */\n          lock->runcount--;\n          gl_waitqueue_notify_first (&lock->waiting_writers);\n        }\n      else\n        {\n          /* Wake up all waiting readers.  */\n          lock->runcount += lock->waiting_readers.count;\n          gl_waitqueue_notify_all (&lock->waiting_readers);\n        }\n    }\n  LeaveCriticalSection (&lock->lock);\n  return 0;\n}",
      "lines": 43,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "glthread_rwlock_destroy_func": {
      "start_point": [
        933,
        0
      ],
      "end_point": [
        947,
        1
      ],
      "content": "int\nglthread_rwlock_destroy_func (gl_rwlock_t *lock)\n{\n  if (!lock->guard.done)\n    return EINVAL;\n  if (lock->runcount != 0)\n    return EBUSY;\n  DeleteCriticalSection (&lock->lock);\n  if (lock->waiting_readers.array != NULL)\n    free (lock->waiting_readers.array);\n  if (lock->waiting_writers.array != NULL)\n    free (lock->waiting_writers.array);\n  lock->guard.done = 0;\n  return 0;\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "glthread_recursive_lock_init_func": {
      "start_point": [
        951,
        0
      ],
      "end_point": [
        958,
        1
      ],
      "content": "void\nglthread_recursive_lock_init_func (gl_recursive_lock_t *lock)\n{\n  lock->owner = 0;\n  lock->depth = 0;\n  InitializeCriticalSection (&lock->lock);\n  lock->guard.done = 1;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "glthread_recursive_lock_lock_func": {
      "start_point": [
        960,
        0
      ],
      "end_point": [
        988,
        1
      ],
      "content": "int\nglthread_recursive_lock_lock_func (gl_recursive_lock_t *lock)\n{\n  if (!lock->guard.done)\n    {\n      if (InterlockedIncrement (&lock->guard.started) == 0)\n        /* This thread is the first one to need this lock.  Initialize it.  */\n        glthread_recursive_lock_init (lock);\n      else\n        /* Yield the CPU while waiting for another thread to finish\n           initializing this lock.  */\n        while (!lock->guard.done)\n          Sleep (0);\n    }\n  {\n    DWORD self = GetCurrentThreadId ();\n    if (lock->owner != self)\n      {\n        EnterCriticalSection (&lock->lock);\n        lock->owner = self;\n      }\n    if (++(lock->depth) == 0) /* wraparound? */\n      {\n        lock->depth--;\n        return EAGAIN;\n      }\n  }\n  return 0;\n}",
      "lines": 29,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "glthread_recursive_lock_unlock_func": {
      "start_point": [
        990,
        0
      ],
      "end_point": [
        1003,
        1
      ],
      "content": "int\nglthread_recursive_lock_unlock_func (gl_recursive_lock_t *lock)\n{\n  if (lock->owner != GetCurrentThreadId ())\n    return EPERM;\n  if (lock->depth == 0)\n    return EINVAL;\n  if (--(lock->depth) == 0)\n    {\n      lock->owner = 0;\n      LeaveCriticalSection (&lock->lock);\n    }\n  return 0;\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "glthread_recursive_lock_destroy_func": {
      "start_point": [
        1005,
        0
      ],
      "end_point": [
        1013,
        1
      ],
      "content": "int\nglthread_recursive_lock_destroy_func (gl_recursive_lock_t *lock)\n{\n  if (lock->owner != 0)\n    return EBUSY;\n  DeleteCriticalSection (&lock->lock);\n  lock->guard.done = 0;\n  return 0;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "glthread_once_func": {
      "start_point": [
        1017,
        0
      ],
      "end_point": [
        1052,
        1
      ],
      "content": "void\nglthread_once_func (gl_once_t *once_control, void (*initfunction) (void))\n{\n  if (once_control->inited <= 0)\n    {\n      if (InterlockedIncrement (&once_control->started) == 0)\n        {\n          /* This thread is the first one to come to this once_control.  */\n          InitializeCriticalSection (&once_control->lock);\n          EnterCriticalSection (&once_control->lock);\n          once_control->inited = 0;\n          initfunction ();\n          once_control->inited = 1;\n          LeaveCriticalSection (&once_control->lock);\n        }\n      else\n        {\n          /* Undo last operation.  */\n          InterlockedDecrement (&once_control->started);\n          /* Some other thread has already started the initialization.\n             Yield the CPU while waiting for the other thread to finish\n             initializing and taking the lock.  */\n          while (once_control->inited < 0)\n            Sleep (0);\n          if (once_control->inited <= 0)\n            {\n              /* Take the lock.  This blocks until the other thread has\n                 finished calling the initfunction.  */\n              EnterCriticalSection (&once_control->lock);\n              LeaveCriticalSection (&once_control->lock);\n              if (!(once_control->inited > 0))\n                abort ();\n            }\n        }\n    }\n}",
      "lines": 36,
      "depth": 15,
      "decorators": [
        "void"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/glthread/lock.h": {},
  "findutils/findutils-4.6.0/gl/lib/glthread/threadlib.c": {
    "dummy_thread_func": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "static void *\ndummy_thread_func (void *arg)\n{\n  return arg;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void",
        "*\ndummy_thread_func (void *arg)",
        "*"
      ]
    },
    "glthread_in_use": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "int\nglthread_in_use (void)\n{\n  static int tested;\n  static int result; /* 1: linked with -lpthread, 0: only with libc */\n\n  if (!tested)\n    {\n      pthread_t thread;\n\n      if (pthread_create (&thread, NULL, dummy_thread_func, NULL) != 0)\n        /* Thread creation failed.  */\n        result = 0;\n      else\n        {\n          /* Thread creation works.  */\n          void *retval;\n          if (pthread_join (thread, &retval) != 0)\n            abort ();\n          result = 1;\n        }\n      tested = 1;\n    }\n  return result;\n}",
      "lines": 25,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/uniwidth/cjk.h": {
    "is_cjk_encoding": {
      "start_point": [
        19,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "static int\nis_cjk_encoding (const char *encoding)\n{\n  if (0\n      /* Legacy Japanese encodings */\n      || STREQ_OPT (encoding, \"EUC-JP\", 'E', 'U', 'C', '-', 'J', 'P', 0, 0, 0)\n      /* Legacy Chinese encodings */\n      || STREQ_OPT (encoding, \"GB2312\", 'G', 'B', '2', '3', '1', '2', 0, 0, 0)\n      || STREQ_OPT (encoding, \"GBK\", 'G', 'B', 'K', 0, 0, 0, 0, 0, 0)\n      || STREQ_OPT (encoding, \"EUC-TW\", 'E', 'U', 'C', '-', 'T', 'W', 0, 0, 0)\n      || STREQ_OPT (encoding, \"BIG5\", 'B', 'I', 'G', '5', 0, 0, 0, 0, 0)\n      /* Legacy Korean encodings */\n      || STREQ_OPT (encoding, \"EUC-KR\", 'E', 'U', 'C', '-', 'K', 'R', 0, 0, 0)\n      || STREQ_OPT (encoding, \"CP949\", 'C', 'P', '9', '4', '9', 0, 0, 0, 0)\n      || STREQ_OPT (encoding, \"JOHAB\", 'J', 'O', 'H', 'A', 'B', 0, 0, 0, 0))\n    return 1;\n  return 0;\n}",
      "lines": 18,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/gl/lib/uniwidth/width.c": {
    "uc_width": {
      "start_point": [
        395,
        0
      ],
      "end_point": [
        449,
        1
      ],
      "content": "int\nuc_width (ucs4_t uc, const char *encoding)\n{\n  /* Test for non-spacing or control character.  */\n  if ((uc >> 9) < 248)\n    {\n      int ind = nonspacing_table_ind[uc >> 9];\n      if (ind >= 0)\n        if ((nonspacing_table_data[64*ind + ((uc >> 3) & 63)] >> (uc & 7)) & 1)\n          {\n            if (uc > 0 && uc < 0xa0)\n              return -1;\n            else\n              return 0;\n          }\n    }\n  else if ((uc >> 9) == (0xe0000 >> 9))\n    {\n      if (uc >= 0xe0100)\n        {\n          if (uc <= 0xe01ef)\n            return 0;\n        }\n      else\n        {\n          if (uc >= 0xe0020 ? uc <= 0xe007f : uc == 0xe0001)\n            return 0;\n        }\n    }\n  /* Test for double-width character.\n   * Generated from \"grep '^[^;]\\{4,5\\};[WF]' EastAsianWidth.txt\"\n   * and            \"grep '^[^;]\\{4,5\\};[^WF]' EastAsianWidth.txt\"\n   */\n  if (uc >= 0x1100\n      && ((uc < 0x1160) /* Hangul Jamo */\n          || (uc >= 0x2329 && uc < 0x232b) /* Angle Brackets */\n          || (uc >= 0x2e80 && uc < 0xa4d0  /* CJK ... Yi */\n              && !(uc == 0x303f) && !(uc >= 0x4dc0 && uc < 0x4e00))\n          || (uc >= 0xac00 && uc < 0xd7a4) /* Hangul Syllables */\n          || (uc >= 0xf900 && uc < 0xfb00) /* CJK Compatibility Ideographs */\n          || (uc >= 0xfe10 && uc < 0xfe20) /* Presentation Forms for Vertical */\n          || (uc >= 0xfe30 && uc < 0xfe70) /* CJK Compatibility Forms */\n          || (uc >= 0xff00 && uc < 0xff61) /* Fullwidth Forms */\n          || (uc >= 0xffe0 && uc < 0xffe7) /* Fullwidth Signs */\n          || (uc >= 0x20000 && uc <= 0x2ffff) /* Supplementary Ideographic Plane */\n          || (uc >= 0x30000 && uc <= 0x3ffff) /* Tertiary Ideographic Plane */\n     )   )\n    return 2;\n  /* In ancient CJK encodings, Cyrillic and most other characters are\n     double-width as well.  */\n  if (uc >= 0x00A1 && uc < 0xFF61 && uc != 0x20A9\n      && is_cjk_encoding (encoding))\n    return 2;\n  return 1;\n}",
      "lines": 55,
      "depth": 22,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/lib/buildcmd.c": {
    "bc_args_complete": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "static void\nbc_args_complete (struct buildcmd_control *ctl,\n\t\t  struct buildcmd_state *state)\n{\n  bc_push_arg (ctl, state, special_terminating_arg, 0, NULL, 0, 0);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bc_do_insert": {
      "start_point": [
        92,
        0
      ],
      "end_point": [
        166,
        1
      ],
      "content": "void\nbc_do_insert (struct buildcmd_control *ctl,\n              struct buildcmd_state *state,\n              char *arg, size_t arglen,\n              const char *prefix, size_t pfxlen,\n              const char *linebuf, size_t lblen,\n              int initial_args)\n{\n  /* Temporary copy of each arg with the replace pattern replaced by the\n     real arg.  */\n  static char *insertbuf;\n  char *p;\n  size_t bytes_left = ctl->arg_max - 1;    /* Bytes left on the command line.  */\n\n  /* XXX: on systems lacking an upper limit for exec args, ctl->arg_max\n   *      may have been set to LONG_MAX (see bc_get_arg_max()).  Hence\n   *      this xmalloc call may be a bad idea, especially since we are\n   *      adding 1 to it...\n   */\n  if (!insertbuf)\n    insertbuf = xmalloc (ctl->arg_max + 1);\n  p = insertbuf;\n\n  do\n    {\n      size_t len;               /* Length in ARG before `replace_pat'.  */\n      char *s = mbsstr (arg, ctl->replace_pat);\n      if (s)\n        {\n          len = s - arg;\n        }\n      else\n        {\n          len = arglen;\n        }\n\n      if (bytes_left <= len)\n        break;\n      else\n\tbytes_left -= len;\n\n      strncpy (p, arg, len);\n      p += len;\n      arg += len;\n      arglen -= len;\n\n      if (s)\n        {\n\t  if (bytes_left <= (lblen + pfxlen))\n\t    break;\n\t  else\n\t    bytes_left -= (lblen + pfxlen);\n\n\t  if (prefix)\n\t    {\n\t      strcpy (p, prefix);\n\t      p += pfxlen;\n\t    }\n          strcpy (p, linebuf);\n          p += lblen;\n\n          arg += ctl->rplen;\n          arglen -= ctl->rplen;\n        }\n    }\n  while (*arg);\n  if (*arg)\n    error (EXIT_FAILURE, 0, _(\"command too long\"));\n  *p++ = '\\0';\n\n  bc_push_arg (ctl, state,\n\t       insertbuf, p - insertbuf,\n               NULL, 0,\n               initial_args);\n}",
      "lines": 75,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "update_limit": {
      "start_point": [
        172,
        0
      ],
      "end_point": [
        234,
        1
      ],
      "content": "static size_t\nupdate_limit (struct buildcmd_control *ctl,\n\t      struct buildcmd_state *state,\n\t      bool success,\n\t      size_t limit)\n{\n  if (success)\n    {\n      if (limit > state->largest_successful_arg_count)\n\tstate->largest_successful_arg_count = limit;\n    }\n  else\n    {\n      if (limit < state->smallest_failed_arg_count\n\t  || (0 == state->smallest_failed_arg_count))\n\tstate->smallest_failed_arg_count = limit;\n    }\n\n  if (0 == (state->largest_successful_arg_count)\n      || (state->smallest_failed_arg_count <= state->largest_successful_arg_count))\n    {\n      /* No success yet, or running on a system which has\n\t limits on total argv length, but not arg count. */\n      if (success)\n\t{\n\t  if (limit < SIZE_MAX)\n\t    ++limit;\n\t}\n      else\n\t{\n\t  limit /= 2;\n\t}\n    }\n  else  /* We can use bisection. */\n    {\n      const size_t shift = (state->smallest_failed_arg_count\n\t\t\t  - state->largest_successful_arg_count) / 2;\n      if (success)\n\t{\n\t  if (shift)\n\t    limit += shift;\n\t  else\n\t    ++limit;\n\t}\n      else\n\t{\n\t  if (shift)\n\t    limit -= shift;\n\t  else\n\t    --limit;\n\t}\n    }\n\n  /* Make sure the returned value is such that progress is\n   * actually possible.\n   */\n  if (ctl->initial_argc && (limit <= ctl->initial_argc + 1u))\n    limit = ctl->initial_argc + 1u;\n  if (0 == limit)\n    limit = 1u;\n\n  return limit;\n}",
      "lines": 63,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "copy_args": {
      "start_point": [
        240,
        0
      ],
      "end_point": [
        260,
        1
      ],
      "content": "static size_t\ncopy_args (struct buildcmd_control *ctl,\n\t   struct buildcmd_state *state,\n\t   char** working_args, size_t limit, size_t done)\n{\n  size_t dst_pos = 0;\n  size_t src_pos = 0;\n\n  while (src_pos < ctl->initial_argc)\n    {\n      working_args[dst_pos++] = state->cmd_argv[src_pos++];\n    }\n  src_pos += done;\n  while (src_pos < state->cmd_argc && dst_pos < limit)\n    {\n      working_args[dst_pos++] = state->cmd_argv[src_pos++];\n    }\n  assert (dst_pos >= ctl->initial_argc);\n  working_args[dst_pos] = NULL;\n  return dst_pos;\n}",
      "lines": 21,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "bc_do_exec": {
      "start_point": [
        266,
        0
      ],
      "end_point": [
        314,
        1
      ],
      "content": "void\nbc_do_exec (struct buildcmd_control *ctl,\n\t    struct buildcmd_state *state)\n{\n    char** working_args;\n    size_t limit, done;\n\n    /* Terminate the args. */\n    bc_args_complete (ctl, state);\n    /* Verify that the argument list is terminated. */\n    assert (state->cmd_argc > 0);\n    assert (state->cmd_argv[state->cmd_argc-1] == NULL);\n\n    working_args = xmalloc ((1+state->cmd_argc) * sizeof (char*));\n    done = 0;\n    limit = state->cmd_argc;\n\n    do\n      {\n\tconst size_t dst_pos = copy_args (ctl, state, working_args,\n\t\t\t\t\t  limit, done);\n\tif (ctl->exec_callback (ctl, state->usercontext, dst_pos, working_args))\n\t  {\n\t    limit = update_limit (ctl, state, true, limit);\n\t    done += (dst_pos - ctl->initial_argc);\n\t  }\n\telse  /* got E2BIG, adjust arguments */\n\t  {\n\t    if (limit <= ctl->initial_argc + 1)\n\t      {\n\t\t/* No room to reduce the length of the argument list.\n\t\t   Issue an error message and give up. */\n\t\terror (EXIT_FAILURE, 0,\n\t\t       _(\"can't call exec() due to argument size restrictions\"));\n\t      }\n\t    else\n\t      {\n\t\t/* Try fewer arguments. */\n\t\tlimit = update_limit (ctl, state, false, limit);\n\t      }\n\t  }\n      }\n    while ((done + 1) < (state->cmd_argc - ctl->initial_argc));\n    /* (state->cmd_argc - ctl->initial_argc) includes the terminating NULL,\n     * which is why we add 1 to done in the test above. */\n\n    free (working_args);\n    bc_clear_args (ctl, state);\n}",
      "lines": 49,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "bc_argc_limit_reached": {
      "start_point": [
        324,
        0
      ],
      "end_point": [
        339,
        1
      ],
      "content": "static int\nbc_argc_limit_reached (int initial_args,\n\t\t       const struct buildcmd_control *ctl,\n\t\t       struct buildcmd_state *state)\n{\n  /* Check to see if we about to exceed a limit set by xargs' -n option */\n  if (!initial_args && ctl->args_per_exec &&\n      ( (state->cmd_argc - ctl->initial_argc) == ctl->args_per_exec))\n    return 1;\n\n  /* We deliberately use an equality test here rather than >= in order\n   * to force a software failure if the code is modified in such a way\n   * that it fails to call this function for every new argument.\n   */\n  return state->cmd_argc == ctl->max_arg_count;\n}",
      "lines": 16,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "bc_push_arg": {
      "start_point": [
        347,
        0
      ],
      "end_point": [
        426,
        1
      ],
      "content": "void\nbc_push_arg (struct buildcmd_control *ctl,\n             struct buildcmd_state *state,\n             const char *arg, size_t len,\n             const char *prefix, size_t pfxlen,\n             int initial_args)\n{\n  const int terminate = (arg == special_terminating_arg);\n\n  assert (arg != NULL);\n\n  if (!initial_args)\n    {\n      state->todo = 1;\n    }\n\n  if (!terminate)\n    {\n      if (state->cmd_argv_chars + len + pfxlen > ctl->arg_max)\n        {\n          if (initial_args || state->cmd_argc == ctl->initial_argc)\n            error (EXIT_FAILURE, 0,\n\t\t   _(\"cannot fit single argument within argument list size limit\"));\n\n          /* xargs option -i (replace_pat) implies -x (exit_if_size_exceeded) */\n          if (ctl->replace_pat\n              || (ctl->exit_if_size_exceeded &&\n                  (ctl->lines_per_exec || ctl->args_per_exec)))\n            error (EXIT_FAILURE, 0, _(\"argument list too long\"));\n            bc_do_exec (ctl, state);\n        }\n      if (bc_argc_limit_reached (initial_args, ctl, state))\n            bc_do_exec (ctl, state);\n    }\n\n  if (state->cmd_argc >= state->cmd_argv_alloc)\n    {\n      /* XXX: we could use extendbuf() here. */\n      if (!state->cmd_argv)\n        {\n          state->cmd_argv_alloc = 64;\n          state->cmd_argv = xmalloc (sizeof (char *) * state->cmd_argv_alloc);\n        }\n      else\n        {\n          state->cmd_argv_alloc *= 2;\n          state->cmd_argv = xrealloc (state->cmd_argv,\n\t\t\t\t      sizeof (char *) * state->cmd_argv_alloc);\n        }\n    }\n\n  if (terminate)\n    state->cmd_argv[state->cmd_argc++] = NULL;\n  else\n    {\n      state->cmd_argv[state->cmd_argc++] = state->argbuf + state->cmd_argv_chars;\n      if (prefix)\n        {\n          strcpy (state->argbuf + state->cmd_argv_chars, prefix);\n          state->cmd_argv_chars += pfxlen;\n        }\n\n      strcpy (state->argbuf + state->cmd_argv_chars, arg);\n      state->cmd_argv_chars += len;\n\n      /* If we have now collected enough arguments,\n       * do the exec immediately.\n       */\n      if (bc_argc_limit_reached (initial_args, ctl, state))\n\t{\n\t  bc_do_exec (ctl, state);\n\t}\n    }\n\n  /* If this is an initial argument, set the high-water mark. */\n  if (initial_args)\n    {\n      state->cmd_initial_argv_chars = state->cmd_argv_chars;\n    }\n}",
      "lines": 80,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "bc_get_arg_max": {
      "start_point": [
        429,
        0
      ],
      "end_point": [
        463,
        1
      ],
      "content": "size_t\nbc_get_arg_max (void)\n{\n  long val;\n\n  /* We may resort to using LONG_MAX, so check it fits. */\n  /* XXX: better to do a compile-time check */\n  assert ( (~(size_t)0) >= LONG_MAX);\n\n#ifdef _SC_ARG_MAX\n  val = sysconf (_SC_ARG_MAX);\n#else\n  val = -1;\n#endif\n\n  if (val > 0)\n    return val;\n\n  /* either _SC_ARG_MAX was not available or\n   * there is no particular limit.\n   */\n#ifdef ARG_MAX\n  val = ARG_MAX;\n  if (val > 0)\n    return val;\n#endif\n\n  /* The value returned by this function bounds the\n   * value applied as the ceiling for the -s option.\n   * Hence it the system won't tell us what its limit\n   * is, we allow the user to specify more or less\n   * whatever value they like.\n   */\n  return LONG_MAX;\n}",
      "lines": 35,
      "depth": 11,
      "decorators": [
        "size_t"
      ]
    },
    "cb_exec_noop": {
      "start_point": [
        466,
        0
      ],
      "end_point": [
        479,
        1
      ],
      "content": "static int\ncb_exec_noop (struct buildcmd_control * ctl,\n\t      void *usercontext,\n\t      int argc,\n\t      char **argv)\n{\n  /* does nothing. */\n  (void) ctl;\n  (void) usercontext;\n  (void) argc;\n  (void) argv;\n\n  return 0;\n}",
      "lines": 14,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "bc_size_of_environment": {
      "start_point": [
        483,
        0
      ],
      "end_point": [
        493,
        1
      ],
      "content": "size_t\nbc_size_of_environment (void)\n{\n  size_t len = 0u;\n  char **envp = environ;\n\n  while (*envp)\n    len += strlen (*envp++) + 1;\n\n  return len;\n}",
      "lines": 11,
      "depth": 11,
      "decorators": [
        "size_t"
      ]
    },
    "bc_init_controlinfo": {
      "start_point": [
        496,
        0
      ],
      "end_point": [
        547,
        1
      ],
      "content": "enum BC_INIT_STATUS\nbc_init_controlinfo (struct buildcmd_control *ctl,\n\t\t     size_t headroom)\n{\n  size_t size_of_environment = bc_size_of_environment ();\n\n  /* POSIX requires that _POSIX_ARG_MAX is 4096.  That is the lowest\n   * possible value for ARG_MAX on a POSIX compliant system.  See\n   * http://www.opengroup.org/onlinepubs/009695399/basedefs/limits.h.html\n   */\n  ctl->posix_arg_size_min = _POSIX_ARG_MAX;\n  ctl->posix_arg_size_max = bc_get_arg_max ();\n\n  ctl->exit_if_size_exceeded = 0;\n\n  /* Take the size of the environment into account.  */\n  if (size_of_environment > ctl->posix_arg_size_max)\n    {\n      return BC_INIT_ENV_TOO_BIG;\n    }\n  else if ((headroom + size_of_environment) >= ctl->posix_arg_size_max)\n    {\n      /* POSIX.2 requires xargs to subtract 2048, but ARG_MAX is\n       * guaranteed to be at least 4096.  Although xargs could use an\n       * assertion here, we use a runtime check which returns an error\n       * code, because our caller may not be xargs.\n       */\n      return BC_INIT_CANNOT_ACCOMODATE_HEADROOM;\n    }\n  else\n    {\n      ctl->posix_arg_size_max -= size_of_environment;\n      ctl->posix_arg_size_max -= headroom;\n    }\n\n  /* need to subtract 2 on the following line - for Linux/PPC */\n  ctl->max_arg_count = (ctl->posix_arg_size_max / sizeof (char*)) - 2u;\n  assert (ctl->max_arg_count > 0);\n  ctl->rplen = 0u;\n  ctl->replace_pat = NULL;\n  ctl->initial_argc = 0;\n  ctl->exec_callback = cb_exec_noop;\n  ctl->lines_per_exec = 0;\n  ctl->args_per_exec = 0;\n\n  /* Set the initial value of arg_max to the largest value we can\n   * tolerate.\n   */\n  ctl->arg_max = ctl->posix_arg_size_max;\n\n  return BC_INIT_OK;\n}",
      "lines": 52,
      "depth": 11,
      "decorators": [
        "enum BC_INIT_STATUS",
        "enum",
        "BC_INIT_STATUS"
      ]
    },
    "bc_use_sensible_arg_max": {
      "start_point": [
        549,
        0
      ],
      "end_point": [
        565,
        1
      ],
      "content": "void\nbc_use_sensible_arg_max (struct buildcmd_control *ctl)\n{\n#ifdef DEFAULT_ARG_SIZE\n  enum { arg_size = DEFAULT_ARG_SIZE };\n#else\n  enum { arg_size = (128u * 1024u) };\n#endif\n\n  /* Check against the upper and lower limits. */\n  if (arg_size > ctl->posix_arg_size_max)\n    ctl->arg_max = ctl->posix_arg_size_max;\n  else if (arg_size < ctl->posix_arg_size_min)\n    ctl->arg_max = ctl->posix_arg_size_min;\n  else\n    ctl->arg_max = arg_size;\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "bc_init_state": {
      "start_point": [
        570,
        0
      ],
      "end_point": [
        594,
        1
      ],
      "content": "void\nbc_init_state (const struct buildcmd_control *ctl,\n\t       struct buildcmd_state *state,\n\t       void *context)\n{\n  state->cmd_argc = 0;\n  state->cmd_argv_chars = 0;\n  state->cmd_argv = NULL;\n  state->cmd_argv_alloc = 0;\n  state->largest_successful_arg_count = 0;\n  state->smallest_failed_arg_count = 0;\n\n  /* XXX: the following memory allocation is inadvisable on systems\n   * with no ARG_MAX, because ctl->arg_max may actually be close to\n   * LONG_MAX.   Adding one to it is safe though because earlier we\n   * subtracted 2048.\n   */\n  assert (ctl->arg_max <= (LONG_MAX - 2048L));\n  state->argbuf = xmalloc (ctl->arg_max + 1u);\n\n  state->cmd_argv_chars = state->cmd_initial_argv_chars = 0;\n  state->todo = 0;\n  state->dir_fd = -1;\n  state->usercontext = context;\n}",
      "lines": 25,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "bc_clear_args": {
      "start_point": [
        596,
        0
      ],
      "end_point": [
        604,
        1
      ],
      "content": "void\nbc_clear_args (const struct buildcmd_control *ctl,\n\t       struct buildcmd_state *state)\n{\n  state->cmd_argc = ctl->initial_argc;\n  state->cmd_argv_chars = state->cmd_initial_argv_chars;\n  state->todo = 0;\n  state->dir_fd = -1;\n}",
      "lines": 9,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "exceeds": {
      "start_point": [
        610,
        0
      ],
      "end_point": [
        634,
        1
      ],
      "content": "static int\nexceeds (const char *env_var_name, size_t quantity)\n{\n  const char *val = getenv (env_var_name);\n  if (val)\n    {\n      char *tmp;\n      unsigned long limit;\n\n      if (xstrtoul (val, &tmp, 10, &limit, NULL) == LONGINT_OK)\n\t{\n\t  if (quantity > limit)\n\t    return 1;\n\t}\n      else\n\t{\n\t  error (EXIT_FAILURE, errno,\n\t\t _(\"Environment variable %s is not set to a \"\n\t\t   \"valid decimal number\"),\n\t\t env_var_name);\n\t  return 0;\n\t}\n    }\n  return 0;\n}",
      "lines": 25,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "bc_args_exceed_testing_limit": {
      "start_point": [
        640,
        0
      ],
      "end_point": [
        653,
        1
      ],
      "content": "bool\nbc_args_exceed_testing_limit (char **argv)\n{\n  size_t chars, args;\n\n  for (chars=args=0; *argv; ++argv)\n    {\n      ++args;\n      chars += strlen(*argv);\n    }\n\n  return (exceeds (\"__GNU_FINDUTILS_EXEC_ARG_COUNT_LIMIT\", args) ||\n\t  exceeds (\"__GNU_FINDUTILS_EXEC_ARG_LENGTH_LIMIT\", chars));\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "bool"
      ]
    }
  },
  "findutils/findutils-4.6.0/lib/buildcmd.h": {},
  "findutils/findutils-4.6.0/lib/dircallback.c": {
    "run_in_dir": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        69,
        1
      ],
      "content": "int\nrun_in_dir (const struct saved_cwd *there,\n\t    int (*callback)(void*), void *usercontext)\n{\n  int err = -1;\n  int saved_errno = 0;\n  struct saved_cwd here;\n  if (0 == save_cwd (&here))\n    {\n      if (0 == restore_cwd (there))\n\t{\n\t  err = callback(usercontext);\n\t  saved_errno = (err < 0 ? errno : 0);\n\t}\n      else\n\t{\n\t  openat_restore_fail (errno);\n\t}\n\n      if (restore_cwd (&here) != 0)\n\topenat_restore_fail (errno);\n\n      free_cwd (&here);\n    }\n  else\n    {\n      openat_save_fail (errno);\n    }\n  if (saved_errno)\n    errno = saved_errno;\n  return err;\n}",
      "lines": 32,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "run_in_dirfd": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        108,
        1
      ],
      "content": "int\nrun_in_dirfd (int dir_fd, int (*callback)(void*), void *usercontext)\n{\n  if (dir_fd == AT_FDCWD)\n    {\n      return (*callback)(usercontext);\n    }\n  else\n    {\n      struct saved_cwd saved_cwd;\n      int saved_errno;\n      int err;\n\n      if (save_cwd (&saved_cwd) != 0)\n\topenat_save_fail (errno);\n\n      if (fchdir (dir_fd) != 0)\n\t{\n\t  saved_errno = errno;\n\t  free_cwd (&saved_cwd);\n\t  errno = saved_errno;\n\t  return -1;\n\t}\n\n      err = (*callback)(usercontext);\n      saved_errno = (err < 0 ? errno : 0);\n\n      if (restore_cwd (&saved_cwd) != 0)\n\topenat_restore_fail (errno);\n\n      free_cwd (&saved_cwd);\n\n      if (saved_errno)\n\terrno = saved_errno;\n      return err;\n    }\n}",
      "lines": 37,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/lib/dircallback.h": {},
  "findutils/findutils-4.6.0/lib/extendbuf.c": {
    "decide_size": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "static size_t\ndecide_size (size_t current, size_t wanted)\n{\n  size_t newsize;\n\n  if (0 == current)\n    newsize = SIZE_DEFAULT;\n  else\n    newsize = current;\n\n  while (newsize < wanted)\n    {\n      if (2 * newsize < newsize)\n\treturn wanted;\n      newsize *= 2;\n    }\n  return newsize;\n}",
      "lines": 18,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "extendbuf": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        108,
        1
      ],
      "content": "void *\nextendbuf (void* existing, size_t wanted, size_t *allocated)\n{\n  int saved_errno;\n  size_t newsize;\n  void *result; /* leave uninitialized to allow static code checkers to identify bugs */\n\n  saved_errno = errno;\n\n  assert (wanted > 0u);\n  newsize = decide_size (*allocated, wanted);\n\n  if ( (*allocated) == 0 )\n    {\n      /* Sanity check: If there is no existing allocation size, there\n       * must be no existing allocated buffer.\n       */\n      assert (NULL == existing);\n\n      (*allocated) = newsize;\n      result = malloc (newsize);\n    }\n  else\n    {\n      if (newsize != (*allocated) )\n\t{\n\t  (*allocated) = newsize;\n\t  result = realloc (existing, newsize);\n\t  if (NULL == result)\n\t    {\n\t      saved_errno = errno;\n\t    }\n\t}\n      else\n\t{\n\t  result = existing;\n\t}\n    }\n\n  if (result)\n    {\n      /* malloc () or realloc () may have changed errno, but in the\n\t success case we want to preserve the previous value.\n      */\n      errno = saved_errno;\n    }\n  return result;\n}",
      "lines": 48,
      "depth": 11,
      "decorators": [
        "void",
        "*\nextendbuf (void* existing, size_t wanted, size_t *allocated)",
        "*"
      ]
    },
    "xextendbuf": {
      "start_point": [
        111,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "void *\nxextendbuf (void* existing, size_t wanted, size_t *allocated)\n{\n  void *p = extendbuf (existing, wanted, allocated);\n  if (NULL == p)\n    {\n      free (existing);\n      xalloc_die ();\n    }\n  return p;\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "void",
        "*\nxextendbuf (void* existing, size_t wanted, size_t *allocated)",
        "*"
      ]
    }
  },
  "findutils/findutils-4.6.0/lib/extendbuf.h": {},
  "findutils/findutils-4.6.0/lib/fdleak.c": {
    "get_proc_max_fd": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        102,
        1
      ],
      "content": "static int\nget_proc_max_fd (void)\n{\n  const char *path = \"/proc/self/fd\";\n  int maxfd = -1;\n  /* We don't use readdir_r, because we cannot trust pathconf\n   * to tell us the maximum possible length of a path in\n   * a given directory (the manpage for readdir_r claims this\n   * is the approved method, but the manpage for pathconf indicates\n   * that _PC_NAME_MAX is not an upper limit). */\n  DIR *dir = opendir_safer (path);\n  if (dir)\n    {\n      int good = 0;\n      struct dirent *dent;\n\n      while ((dent=readdir (dir)) != NULL)\n\t{\n\t  if (dent->d_name[0] != '.'\n\t      || (dent->d_name[0] != 0\n\t\t  && dent->d_name[1] != 0 && dent->d_name[1] != '.'))\n\t    {\n\t      const int fd = safe_atoi (dent->d_name, literal_quoting_style);\n\t      if (fd > maxfd)\n\t\tmaxfd = fd;\n\t      good = 1;\n\t    }\n\t}\n      closedir (dir);\n      if (good)\n\treturn maxfd;\n    }\n  return -1;\n}",
      "lines": 34,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "get_max_fd": {
      "start_point": [
        107,
        0
      ],
      "end_point": [
        133,
        1
      ],
      "content": "static int\nget_max_fd (void)\n{\n  struct rlimit fd_limit;\n  long open_max;\n\n  open_max = get_proc_max_fd ();\n  if (open_max >= 0)\n    return open_max;\n\n  open_max = sysconf (_SC_OPEN_MAX);\n  if (open_max == -1)\n    open_max = _POSIX_OPEN_MAX;\t/* underestimate */\n\n  /* We assume if RLIMIT_NOFILE is defined, all the related macros are, too. */\n#if defined HAVE_GETRLIMIT && defined RLIMIT_NOFILE\n  if (0 == getrlimit (RLIMIT_NOFILE, &fd_limit))\n    {\n      if (fd_limit.rlim_cur == RLIM_INFINITY)\n\treturn open_max;\n      else\n\treturn (int) fd_limit.rlim_cur;\n    }\n#endif\n  /* cannot determine the limit's value */\n  return open_max;\n}",
      "lines": 27,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "visit_open_fds": {
      "start_point": [
        136,
        0
      ],
      "end_point": [
        177,
        1
      ],
      "content": "static int\nvisit_open_fds (int fd_min, int fd_max,\n\t\tint (*callback)(int, void*), void *cb_context)\n{\n  enum { MAX_POLL = 64 };\n  struct pollfd pf[MAX_POLL];\n  int rv = 0;\n\n  while (fd_min < fd_max)\n    {\n      int i;\n      int limit = fd_max - fd_min;\n      if (limit > MAX_POLL)\n\tlimit = MAX_POLL;\n\n      for (i=0; i<limit; i++)\n\t{\n\t  pf[i].events = POLLIN|POLLOUT;\n\t  pf[i].revents = 0;\n\t  pf[i].fd = fd_min + i;\n\t}\n      rv = poll (pf, limit, 0);\n      if (-1 == rv)\n\t{\n\t  return -1;\n\t}\n      else\n\t{\n\t  int j;\n\t  for (j=0; j<limit; j++)\n\t    {\n\t      if (pf[j].revents != POLLNVAL)\n\t\t{\n\t\t  if (0 != (rv = callback (pf[j].fd, cb_context)))\n\t\t    return rv;\n\t\t}\n\t    }\n\t}\n      fd_min += limit;\n    }\n  return 0;\n}",
      "lines": 42,
      "depth": 20,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "fd_is_cloexec": {
      "start_point": [
        179,
        0
      ],
      "end_point": [
        184,
        1
      ],
      "content": "static int\nfd_is_cloexec (int fd)\n{\n  const int flags = fcntl (fd, F_GETFD);\n  return flags & FD_CLOEXEC;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "remember_fd_if_non_cloexec": {
      "start_point": [
        197,
        0
      ],
      "end_point": [
        222,
        1
      ],
      "content": "static int\nremember_fd_if_non_cloexec (int fd, void *context)\n{\n  if (fd_is_cloexec (fd))\n    {\n      return 0;\n    }\n  else\n    {\n      struct remember_fd_context * const p = context;\n      void *newbuf = extendbuf (p->buf,\n\t\t\t\tsizeof (p->buf[0])*(p->used+1),\n\t\t\t\t&(p->allocated));\n      if (newbuf)\n\t{\n\t  p->buf = newbuf;\n\t  p->buf[p->used] = fd;\n\t  ++p->used;\n\t  return 0;\n\t}\n      else\n\t{\n\t  return -1;\n\t}\n    }\n}",
      "lines": 26,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "remember_non_cloexec_fds": {
      "start_point": [
        224,
        0
      ],
      "end_point": [
        238,
        1
      ],
      "content": "void\nremember_non_cloexec_fds (void)\n{\n  int max_fd = get_max_fd ();\n  struct remember_fd_context cb_data;\n  cb_data.buf = NULL;\n  cb_data.used = cb_data.allocated = 0;\n\n  if (max_fd < INT_MAX)\n    ++max_fd;\n  visit_open_fds (0, max_fd, remember_fd_if_non_cloexec, &cb_data);\n\n  non_cloexec_fds = cb_data.buf;\n  num_cloexec_fds = cb_data.used;\n}",
      "lines": 15,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "find_first_leak_callback": {
      "start_point": [
        252,
        0
      ],
      "end_point": [
        281,
        1
      ],
      "content": "static int\nfind_first_leak_callback (int fd, void *context)\n{\n  if (!fd_is_cloexec (fd))\n    {\n      struct fd_leak_context *p = context;\n      while (p->lookup_pos < p->used)\n\t{\n\t  if (p->prev_buf[p->lookup_pos] < fd)\n\t    {\n\t      ++p->lookup_pos;\n\t    }\n\t  else if (p->prev_buf[p->lookup_pos] == fd)\n\t    {\n\t      /* FD was open and still is, it's not a leak. */\n\t      return 0;\n\t    }\n\t  else\n\t    {\n\t      break;\n\t    }\n\t}\n      /* We come here if p->prev_buf[p->lookup_pos] > fd, or\n\t if we ran out of items in the lookup table.\n\t Either way, this is a leak. */\n      p->leaked_fd = fd;\n      return -1;\t\t/* No more callbacks needed. */\n    }\n  return 0;\n}",
      "lines": 30,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "find_first_leaked_fd": {
      "start_point": [
        284,
        0
      ],
      "end_point": [
        298,
        1
      ],
      "content": "static int\nfind_first_leaked_fd (const int* prev_non_cloexec_fds, size_t n)\n{\n  struct fd_leak_context context;\n  int max_fd = get_max_fd ();\n\n  if (max_fd < INT_MAX)\n    ++max_fd;\n  context.prev_buf = prev_non_cloexec_fds;\n  context.used = n;\n  context.lookup_pos = 0;\n  context.leaked_fd = -1;\n  visit_open_fds (0, max_fd, find_first_leak_callback, &context);\n  return context.leaked_fd;\n}",
      "lines": 15,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "o_cloexec_works": {
      "start_point": [
        303,
        0
      ],
      "end_point": [
        314,
        1
      ],
      "content": "static bool\no_cloexec_works (void)\n{\n  bool result = false;\n  int fd = open (\"/\", O_RDONLY|O_CLOEXEC);\n  if (fd >= 0)\n    {\n      result = fd_is_cloexec (fd);\n      close (fd);\n    }\n  return result;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "open_cloexec": {
      "start_point": [
        317,
        0
      ],
      "end_point": [
        355,
        1
      ],
      "content": "int\nopen_cloexec (const char *path, int flags, ...)\n{\n  int fd;\n  mode_t mode = 0;\n  static bool cloexec_works = false;\n  static bool cloexec_status_known = false;\n\n  if (flags & O_CREAT)\n    {\n      /* this code is copied from gnulib's open-safer.c. */\n      va_list ap;\n      va_start (ap, flags);\n\n      /* We have to use PROMOTED_MODE_T instead of mode_t, otherwise GCC 4\n         creates crashing code when 'mode_t' is smaller than 'int'.  */\n      mode = va_arg (ap, PROMOTED_MODE_T);\n\n      va_end (ap);\n    }\n\n  /* Kernels usually ignore open flags they don't recognise, so it\n   * is possible this program was built against a library which\n   * defines O_CLOEXEC, but is running on a kernel that (silently)\n   * does not recognise it.   We figure this out by just trying it,\n   * once.\n   */\n  if (!cloexec_status_known)\n    {\n      cloexec_works = o_cloexec_works ();\n      cloexec_status_known = true;\n    }\n  fd = open (path, flags|O_CLOEXEC, mode);\n  if ((fd >= 0) && !(O_CLOEXEC && cloexec_works))\n    {\n      set_cloexec_flag (fd, true);\n    }\n  return fd;\n}",
      "lines": 39,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "forget_non_cloexec_fds": {
      "start_point": [
        357,
        0
      ],
      "end_point": [
        363,
        1
      ],
      "content": "void\nforget_non_cloexec_fds (void)\n{\n  free (non_cloexec_fds);\n  non_cloexec_fds = NULL;\n  num_cloexec_fds = 0;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "complain_about_leaky_fds": {
      "start_point": [
        366,
        0
      ],
      "end_point": [
        382,
        1
      ],
      "content": "void\ncomplain_about_leaky_fds (void)\n{\n  int no_leaks = 1;\n  const int leaking_fd = find_first_leaked_fd (non_cloexec_fds, num_cloexec_fds);\n\n  if (leaking_fd >= 0)\n    {\n      no_leaks = 0;\n      error (0, 0,\n\t     _(\"File descriptor %d will leak; please report this as a bug, \"\n\t       \"remembering to include a detailed description of the simplest \"\n\t       \"way to reproduce this problem.\"),\n\t     leaking_fd);\n    }\n  assert (no_leaks);\n}",
      "lines": 17,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "findutils/findutils-4.6.0/lib/fdleak.h": {},
  "findutils/findutils-4.6.0/lib/findutils-version.c": {
    "display_findutils_version": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "void\ndisplay_findutils_version (const char *official_name)\n{\n  /* We use official_name rather than program name in the version\n   * information.  This is deliberate, it is specified by the\n   * GNU coding standard.\n   */\n  fflush (stderr);\n  version_etc (stdout,\n\t       official_name, PACKAGE_NAME, version_string,\n\t       _(\"Eric B. Decker\"),\n\t       _(\"James Youngman\"),\n\t       _(\"Kevin Dalley\"),\n\t       (const char*) NULL);\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "findutils/findutils-4.6.0/lib/findutils-version.h": {},
  "findutils/findutils-4.6.0/lib/forcefindlib.c": {
    "forcefindlib": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        46,
        1
      ],
      "content": "void\nforcefindlib (void)\n{\n  /* does nothing, exists only to ensure that FINDLIB_REPLACE_FUNCS works. */\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "void"
      ]
    }
  },
  "findutils/findutils-4.6.0/lib/listfile.c": {
    "print_num": {
      "start_point": [
        95,
        0
      ],
      "end_point": [
        105,
        1
      ],
      "content": "static bool print_num(FILE *stream, unsigned long num, int *width)\n{\n  const int chars_out = fprintf (stream, \"%*lu\", *width, num);\n  if (chars_out >= 0)\n    {\n      if (*width < chars_out)\n        *width = chars_out;\n      return true;\n    }\n  return false;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "list_file": {
      "start_point": [
        116,
        0
      ],
      "end_point": [
        452,
        1
      ],
      "content": "void\nlist_file (const char *name,\n           int dir_fd,\n           char *relname,\n           const struct stat *statp,\n           time_t current_time,\n           int output_block_size,\n           int literal_control_chars,\n           FILE *stream)\n{\n  char modebuf[12];\n  struct tm const *when_local;\n  char const *user_name;\n  char const *group_name;\n  char hbuf[LONGEST_HUMAN_READABLE + 1];\n  bool output_good = true;\n  int chars_out;\n  int failed_at = 000;\n  int inode_field_width;\n\n#if HAVE_ST_DM_MODE\n  /* Cray DMF: look at the file's migrated, not real, status */\n  strmode (statp->st_dm_mode, modebuf);\n#else\n  strmode (statp->st_mode, modebuf);\n#endif\n\n  chars_out = fprintf (stream, \"%*s\", inode_number_width,\n                       human_readable ((uintmax_t) statp->st_ino, hbuf,\n                                       human_ceiling,\n                                       1u, 1u));\n  if (chars_out < 0)\n    {\n      output_good = false;\n      failed_at = 100;\n    }\n  else if (chars_out > inode_number_width)\n    {\n      inode_number_width = chars_out;\n    }\n  if (output_good)\n    {\n      if (EOF == putc(' ', stream))\n        {\n          output_good = false;\n          failed_at = 150;\n        }\n      chars_out = fprintf (stream, \"%*s\",\n                           block_size_width,\n                           human_readable ((uintmax_t) ST_NBLOCKS (*statp), hbuf,\n                                           human_ceiling,\n                                           ST_NBLOCKSIZE, output_block_size));\n      if (chars_out < 0)\n        {\n          output_good = false;\n          failed_at = 200;\n        }\n      else\n        {\n          if (chars_out > block_size_width)\n            block_size_width = chars_out;\n        }\n    }\n\n  if (output_good)\n    {\n      if (EOF == putc(' ', stream))\n        {\n          output_good = false;\n          failed_at = 250;\n        }\n      /* modebuf includes the space between the mode and the number of links,\n         as the POSIX \"optional alternate access method flag\".  */\n      if (fprintf (stream, \"%s%3lu \", modebuf, (unsigned long) statp->st_nlink) < 0)\n        {\n          output_good = false;\n          failed_at = 300;\n        }\n    }\n\n  if (output_good)\n    {\n      if (EOF == putc(' ', stream))\n        {\n          output_good = false;\n          failed_at = 250;\n        }\n      user_name = getuser (statp->st_uid);\n      if (user_name)\n        {\n          int len = mbswidth (user_name, 0);\n          if (len > owner_width)\n            owner_width = len;\n          output_good = (fprintf (stream, \"%-*s \", owner_width, user_name) >= 0);\n          if (!output_good)\n            failed_at = 400;\n        }\n      else\n        {\n          chars_out = fprintf (stream, \"%-8lu \", (unsigned long) statp->st_uid);\n          if (chars_out > owner_width)\n            owner_width = chars_out;\n          output_good = (chars_out > 0);\n          if (!output_good)\n            failed_at = 450;\n        }\n    }\n\n  if (output_good)\n    {\n      group_name = getgroup (statp->st_gid);\n      if (group_name)\n        {\n          int len = mbswidth (group_name, 0);\n          if (len > group_width)\n            group_width = len;\n          output_good = (fprintf (stream, \"%-*s \", group_width, group_name) >= 0);\n          if (!output_good)\n            failed_at = 500;\n        }\n      else\n        {\n          chars_out = fprintf (stream, \"%-*lu\",\n                               group_width, (unsigned long) statp->st_gid);\n          if (chars_out > group_width)\n            group_width = chars_out;\n          output_good = (chars_out >= 0);\n          if (output_good)\n            {\n              if (EOF == putc(' ', stream))\n                {\n                  output_good = false;\n                  failed_at = 525;\n                }\n            }\n          else\n            {\n              if (!output_good)\n                failed_at = 550;\n            }\n        }\n    }\n\n  if (output_good)\n    {\n      if (S_ISCHR (statp->st_mode) || S_ISBLK (statp->st_mode))\n        {\n#ifdef HAVE_STRUCT_STAT_ST_RDEV\n          if (!print_num (stream,\n                          (unsigned long) major (statp->st_rdev),\n                          &major_device_number_width))\n            {\n              output_good = false;\n              failed_at = 600;\n            }\n          if (output_good)\n            {\n              if (fprintf (stream, \", \") < 0)\n                {\n                  output_good = false;\n                  failed_at = 625;\n                }\n            }\n          if (output_good)\n            {\n              if (!print_num (stream,\n                              (unsigned long) minor (statp->st_rdev),\n                              &minor_device_number_width))\n                {\n                  output_good = false;\n                  failed_at = 650;\n                }\n            }\n#else\n          if (fprintf (stream, \"%*s  %*s\",\n                       major_device_number_width,\n                       minor_device_number_width) < 0)\n            {\n              output_good = false;\n              failed_at = 700;\n            }\n#endif\n        }\n      else\n        {\n          const int blocksize = output_block_size < 0 ? output_block_size : 1;\n          chars_out = fprintf (stream, \"%*s\",\n                               file_size_width,\n                               human_readable ((uintmax_t) statp->st_size, hbuf,\n                                               human_ceiling,\n                                               1, blocksize));\n          if (chars_out < 0)\n            {\n              output_good = false;\n              failed_at = 800;\n            }\n          else\n            {\n              if (chars_out > file_size_width)\n                {\n                  file_size_width = chars_out;\n                }\n            }\n        }\n    }\n\n  if (output_good)\n    {\n      if (EOF == putc(' ', stream))\n        {\n          output_good = false;\n          failed_at = 850;\n        }\n    }\n\n  if (output_good)\n    {\n      if ((when_local = localtime (&statp->st_mtime)))\n        {\n          char init_bigbuf[256];\n          char *buf = init_bigbuf;\n          size_t bufsize = sizeof init_bigbuf;\n\n          /* Use strftime rather than ctime, because the former can produce\n             locale-dependent names for the month (%b).\n\n             Output the year if the file is fairly old or in the future.\n             POSIX says the cutoff is 6 months old;\n             approximate this by 6*30 days.\n             Allow a 1 hour slop factor for what is considered \"the future\",\n             to allow for NFS server/client clock disagreement.  */\n          char const *fmt =\n            ((current_time - 6 * 30 * 24 * 60 * 60 <= statp->st_mtime\n              && statp->st_mtime <= current_time + 60 * 60)\n             ? \"%b %e %H:%M\"\n             : \"%b %e  %Y\");\n\n          while (!strftime (buf, bufsize, fmt, when_local))\n            buf = alloca (bufsize *= 2);\n\n          if (fprintf (stream, \"%s \", buf) < 0)\n            {\n              output_good = false;\n              failed_at = 900;\n            }\n        }\n      else\n        {\n          /* The time cannot be represented as a local time;\n             print it as a huge integer number of seconds.  */\n          int width = 12;\n\n          if (statp->st_mtime < 0)\n            {\n              char const *num = human_readable (- (uintmax_t) statp->st_mtime,\n                                                hbuf, human_ceiling, 1, 1);\n              int sign_width = width - strlen (num);\n              if (fprintf (stream, \"%*s%s \",\n                           sign_width < 0 ? 0 : sign_width, \"-\", num) < 0)\n                {\n                  output_good = false;\n                  failed_at = 1000;\n                }\n            }\n          else\n            {\n              if (fprintf (stream, \"%*s \", width,\n                           human_readable ((uintmax_t) statp->st_mtime, hbuf,\n                                           human_ceiling,\n                                           1, 1)) < 0)\n                {\n                  output_good = false;\n                  failed_at = 1100;\n                }\n            }\n        }\n    }\n\n  if (output_good)\n    {\n      output_good = print_name (name, stream, literal_control_chars);\n      if (!output_good)\n        {\n          failed_at = 1200;\n        }\n    }\n\n  if (output_good)\n    {\n      if (S_ISLNK (statp->st_mode))\n        {\n          char *linkname = areadlinkat (dir_fd, relname);\n          if (linkname)\n            {\n              if (fputs (\" -> \", stream) < 0)\n                {\n                  output_good = false;\n                  failed_at = 1300;\n                }\n              if (output_good)\n                {\n                  output_good = print_name (linkname, stream, literal_control_chars);\n                  if (!output_good)\n                    {\n                      failed_at = 1350;\n                    }\n                }\n            }\n          else\n            {\n              /* POSIX requires in the case of find that if we issue a\n               * diagnostic we should have a nonzero status.  However,\n               * this function doesn't have a way of telling the caller to\n               * do that.  However, since this function is only used when\n               * processing \"-ls\", we're already using an extension.\n               */\n              error (0, errno, \"%s\", name);\n            }\n          free (linkname);\n        }\n      if (output_good)\n        {\n          if (EOF == putc ('\\n', stream))\n            {\n              output_good = false;\n              if (!output_good)\n                {\n                  failed_at = 1400;\n                }\n            }\n        }\n    }\n  if (!output_good)\n    {\n      error (EXIT_FAILURE, errno, _(\"Failed to write output (at stage %d)\"), failed_at);\n    }\n}",
      "lines": 337,
      "depth": 19,
      "decorators": [
        "void"
      ]
    },
    "print_name_without_quoting": {
      "start_point": [
        455,
        0
      ],
      "end_point": [
        459,
        1
      ],
      "content": "static bool\nprint_name_without_quoting (const char *p, FILE *stream)\n{\n  return (fprintf (stream, \"%s\", p) >= 0);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "print_name_with_quoting": {
      "start_point": [
        462,
        0
      ],
      "end_point": [
        520,
        1
      ],
      "content": "static bool\nprint_name_with_quoting (register const char *p, FILE *stream)\n{\n  register unsigned char c;\n\n  while ((c = *p++) != '\\0')\n    {\n      int fprintf_result = -1;\n      switch (c)\n        {\n        case '\\\\':\n          fprintf_result = fprintf (stream, \"\\\\\\\\\");\n          break;\n\n        case '\\n':\n          fprintf_result = fprintf (stream, \"\\\\n\");\n          break;\n\n        case '\\b':\n          fprintf_result = fprintf (stream, \"\\\\b\");\n          break;\n\n        case '\\r':\n          fprintf_result = fprintf (stream, \"\\\\r\");\n          break;\n\n        case '\\t':\n          fprintf_result = fprintf (stream, \"\\\\t\");\n          break;\n\n        case '\\f':\n          fprintf_result = fprintf (stream, \"\\\\f\");\n          break;\n\n        case ' ':\n          fprintf_result = fprintf (stream, \"\\\\ \");\n          break;\n\n        case '\"':\n          fprintf_result = fprintf (stream, \"\\\\\\\"\");\n          break;\n\n        default:\n          if (c > 040 && c < 0177)\n            {\n              if (EOF == putc (c, stream))\n                return false;\n              fprintf_result = 1; /* otherwise it's used uninitialized. */\n            }\n          else\n            {\n              fprintf_result = fprintf (stream, \"\\\\%03o\", (unsigned int) c);\n            }\n        }\n      if (fprintf_result < 0)\n        return false;\n    }\n  return true;\n}",
      "lines": 59,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "print_name": {
      "start_point": [
        522,
        0
      ],
      "end_point": [
        528,
        1
      ],
      "content": "static bool print_name (register const char *p, FILE *stream, int literal_control_chars)\n{\n  if (literal_control_chars)\n    return print_name_without_quoting (p, stream);\n  else\n    return print_name_with_quoting (p, stream);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    }
  },
  "findutils/findutils-4.6.0/lib/listfile.h": {},
  "findutils/findutils-4.6.0/lib/printquoted.c": {
    "print_quoted": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "int\nprint_quoted (FILE *fp,\n\t      const struct quoting_options *qopts,\n\t      bool dest_is_tty,\n\t      const char *format,\n\t      const char *s)\n{\n  int rv;\n\n  if (dest_is_tty)\n    {\n      char smallbuf[BUFSIZ];\n      size_t len = quotearg_buffer (smallbuf, sizeof smallbuf, s, -1, qopts);\n      char *buf;\n      if (len < sizeof smallbuf)\n\tbuf = smallbuf;\n      else\n\t{\n\t  /* The original coreutils code uses alloca(), but I don't\n\t   * want to take on the anguish of introducing alloca() to\n\t   * 'find'.\n\t   * XXX: newsflash: we already have alloca().\n\t   */\n\t  buf = xmalloc (len + 1);\n\t  quotearg_buffer (buf, len + 1, s, -1, qopts);\n\t}\n\n      /* Replace any remaining funny characters with '?'. */\n      len = qmark_chars (buf, len);\n\n      rv = fprintf (fp, format, buf);\t/* Print the quoted version */\n      if (buf != smallbuf)\n\t{\n\t  free (buf);\n\t  buf = NULL;\n\t}\n    }\n  else\n    {\n      /* no need to quote things. */\n      rv = fprintf (fp, format, s);\n    }\n  return rv;\n}",
      "lines": 44,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/lib/printquoted.h": {},
  "findutils/findutils-4.6.0/lib/qmark.c": {
    "to_uchar": {
      "start_point": [
        83,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "static inline unsigned char to_uchar (char ch)\n{\n  return ch;\n}",
      "lines": 4,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "unsigned char",
        "unsigned",
        "char"
      ]
    },
    "unibyte_qmark_chars": {
      "start_point": [
        89,
        0
      ],
      "end_point": [
        102,
        1
      ],
      "content": "static size_t\nunibyte_qmark_chars (char *buf, size_t len)\n{\n  char *p = buf;\n  char const *plimit = buf + len;\n\n  while (p < plimit)\n    {\n      if (! ISPRINT (to_uchar (*p)))\n\t*p = '?';\n      p++;\n    }\n  return len;\n}",
      "lines": 14,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "qmark_chars": {
      "start_point": [
        115,
        0
      ],
      "end_point": [
        219,
        1
      ],
      "content": "size_t\nqmark_chars (char *buf, size_t len)\n{\n  if (MB_CUR_MAX <= 1)\n    {\n      return unibyte_qmark_chars (buf, len);\n    }\n  else\n    {\n      char const *p = buf;\n      char const *plimit = buf + len;\n      char *q = buf;\n\n      while (p < plimit)\n\tswitch (*p)\n\t  {\n\t  case ' ': case '!': case '\"': case '#': case '%':\n\t  case '&': case '\\'': case '(': case ')': case '*':\n\t  case '+': case ',': case '-': case '.': case '/':\n\t  case '0': case '1': case '2': case '3': case '4':\n\t  case '5': case '6': case '7': case '8': case '9':\n\t  case ':': case ';': case '<': case '=': case '>':\n\t  case '?':\n\t  case 'A': case 'B': case 'C': case 'D': case 'E':\n\t  case 'F': case 'G': case 'H': case 'I': case 'J':\n\t  case 'K': case 'L': case 'M': case 'N': case 'O':\n\t  case 'P': case 'Q': case 'R': case 'S': case 'T':\n\t  case 'U': case 'V': case 'W': case 'X': case 'Y':\n\t  case 'Z':\n\t  case '[': case '\\\\': case ']': case '^': case '_':\n\t  case 'a': case 'b': case 'c': case 'd': case 'e':\n\t  case 'f': case 'g': case 'h': case 'i': case 'j':\n\t  case 'k': case 'l': case 'm': case 'n': case 'o':\n\t  case 'p': case 'q': case 'r': case 's': case 't':\n\t  case 'u': case 'v': case 'w': case 'x': case 'y':\n\t  case 'z': case '{': case '|': case '}': case '~':\n\t    /* These characters are printable ASCII characters.  */\n\t    *q++ = *p++;\n\t    break;\n\t  default:\n\t    /* If we have a multibyte sequence, copy it until we\n\t       reach its end, replacing each non-printable multibyte\n\t       character with a single question mark.  */\n\t    {\n\t      mbstate_t mbstate;\n\t      memset (&mbstate, 0, sizeof mbstate);\n\t      do\n\t\t{\n\t\t  wchar_t wc;\n\t\t  size_t bytes;\n\t\t  int w;\n\n\t\t  bytes = mbrtowc (&wc, p, plimit - p, &mbstate);\n\n\t\t  if (bytes == (size_t) -1)\n\t\t    {\n\t\t      /* An invalid multibyte sequence was\n\t\t\t encountered.  Skip one input byte, and\n\t\t\t put a question mark.  */\n\t\t      p++;\n\t\t      *q++ = '?';\n\t\t      break;\n\t\t    }\n\n\t\t  if (bytes == (size_t) -2)\n\t\t    {\n\t\t      /* An incomplete multibyte character\n\t\t\t at the end.  Replace it entirely with\n\t\t\t a question mark.  */\n\t\t      p = plimit;\n\t\t      *q++ = '?';\n\t\t      break;\n\t\t    }\n\n\t\t  if (bytes == 0)\n\t\t    /* A null wide character was encountered.  */\n\t\t    bytes = 1;\n\n\t\t  w = wcwidth (wc);\n\t\t  if (w >= 0)\n\t\t    {\n\t\t      /* A printable multibyte character.\n\t\t\t Keep it.  */\n\t\t      for (; bytes > 0; --bytes)\n\t\t\t*q++ = *p++;\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      /* An unprintable multibyte character.\n\t\t\t Replace it entirely with a question\n\t\t\t mark.  */\n\t\t      p += bytes;\n\t\t      *q++ = '?';\n\t\t    }\n\t\t}\n\t      while (! mbsinit (&mbstate));\n\t    }\n\t    break;\n\t  }\n\n      /* The buffer may have shrunk.  */\n      len = q - buf;\n      return len;\n    }\n}",
      "lines": 105,
      "depth": 19,
      "decorators": [
        "size_t"
      ]
    }
  },
  "findutils/findutils-4.6.0/lib/regexprops.c": {
    "output": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "static void\noutput (const char *s, int escape)\n{\n  (void) escape;\n\n  fputs (s, stdout);\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "newline": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "static void\nnewline (void)\n{\n  output (\"\\n\", 0);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "content": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        63,
        1
      ],
      "content": "static void\ncontent (const char *s)\n{\n  output (s, 1);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "literal": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        69,
        1
      ],
      "content": "static void\nliteral (const char *s)\n{\n  output (s, 0);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "directive": {
      "start_point": [
        71,
        0
      ],
      "end_point": [
        75,
        1
      ],
      "content": "static void\ndirective (const char *s)\n{\n  output (s, 0);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "comment": {
      "start_point": [
        77,
        0
      ],
      "end_point": [
        83,
        1
      ],
      "content": "static void\ncomment (const char *s)\n{\n  directive (\"@c \");\n  literal (s);\n  newline ();\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "enum_item": {
      "start_point": [
        85,
        0
      ],
      "end_point": [
        92,
        1
      ],
      "content": "static void\nenum_item (const char *s)\n{\n  newline ();\n  directive (\"@item \");\n  literal (s);\n  newline ();\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "begin_subsection": {
      "start_point": [
        94,
        0
      ],
      "end_point": [
        117,
        1
      ],
      "content": "static void\nbegin_subsection (const char *name,\n\t\t  const char *next,\n\t\t  const char *prev,\n\t\t  const char *up)\n{\n  (void) next;\n  (void) prev;\n  (void) up;\n\n  newline ();\n\n  directive (\"@node \");\n  content (name);\n  content (\" regular expression syntax\");\n  newline ();\n\n  directive (\"@subsection \");\n  output (\"@samp{\", 0);\n  content (name);\n  output (\"}\", 0);\n  content (\" regular expression syntax\");\n  newline ();\n}",
      "lines": 24,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "begintable_markup": {
      "start_point": [
        119,
        0
      ],
      "end_point": [
        126,
        1
      ],
      "content": "static void\nbegintable_markup (char const *markup)\n{\n  newline ();\n  directive (\"@table \");\n  literal (markup);\n  newline ();\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "endtable": {
      "start_point": [
        128,
        0
      ],
      "end_point": [
        134,
        1
      ],
      "content": "static void\nendtable ()\n{\n  newline ();\n  directive (\"@end table\");\n  newline ();\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "beginenum": {
      "start_point": [
        136,
        0
      ],
      "end_point": [
        142,
        1
      ],
      "content": "static void\nbeginenum ()\n{\n  newline ();\n  directive (\"@enumerate\");\n  newline ();\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "endenum": {
      "start_point": [
        144,
        0
      ],
      "end_point": [
        150,
        1
      ],
      "content": "static void\nendenum ()\n{\n  newline ();\n  directive (\"@end enumerate\");\n  newline ();\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "newpara": {
      "start_point": [
        152,
        0
      ],
      "end_point": [
        156,
        1
      ],
      "content": "static void\nnewpara ()\n{\n  content (\"\\n\\n\");\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "describe_regex_syntax": {
      "start_point": [
        159,
        0
      ],
      "end_point": [
        447,
        1
      ],
      "content": "static void\ndescribe_regex_syntax (int options)\n{\n  newpara ();\n  content (\"The character @samp{.} matches any single character\");\n  if ( (options & RE_DOT_NEWLINE)  == 0 )\n    {\n      content (\" except newline\");\n    }\n  if (options & RE_DOT_NOT_NULL)\n    {\n      if ( (options & RE_DOT_NEWLINE)  == 0 )\n\tcontent (\" and\");\n      else\n\tcontent (\" except\");\n\n      content (\" the null character\");\n    }\n  content (\".  \");\n  newpara ();\n\n  if (!(options & RE_LIMITED_OPS))\n    {\n      begintable_markup (\"@samp\");\n      if (options & RE_BK_PLUS_QM)\n\t{\n\t  enum_item (\"\\\\+\");\n\t  content (\"indicates that the regular expression should match one\"\n\t\t   \" or more occurrences of the previous atom or regexp.  \");\n\t  enum_item (\"\\\\?\");\n\t  content (\"indicates that the regular expression should match zero\"\n\t\t   \" or one occurrence of the previous atom or regexp.  \");\n\t  enum_item (\"+ and ? \");\n\t  content (\"match themselves.  \");\n\t}\n      else\n\t{\n\t  enum_item (\"+\");\n\t  content (\"indicates that the regular expression should match one\"\n\t\t   \" or more occurrences of the previous atom or regexp.  \");\n\t  enum_item (\"?\");\n\t  content (\"indicates that the regular expression should match zero\"\n\t\t   \" or one occurrence of the previous atom or regexp.  \");\n\t  enum_item (\"\\\\+\");\n\t  literal (\"matches a @samp{+}\");\n\t  enum_item (\"\\\\?\");\n\t  literal (\"matches a @samp{?}.  \");\n\t}\n      endtable ();\n    }\n\n  newpara ();\n\n  content (\"Bracket expressions are used to match ranges of characters.  \");\n  literal (\"Bracket expressions where the range is backward, for example @samp{[z-a]}, are \");\n  if (options & RE_NO_EMPTY_RANGES)\n    content (\"invalid\");\n  else\n    content (\"ignored\");\n  content (\".  \");\n\n  if (options &  RE_BACKSLASH_ESCAPE_IN_LISTS)\n    literal (\"Within square brackets, @samp{\\\\} can be used to quote \"\n\t     \"the following character.  \");\n  else\n    literal (\"Within square brackets, @samp{\\\\} is taken literally.  \");\n\n  if (options & RE_CHAR_CLASSES)\n    content (\"Character classes are supported; for example \"\n\t     \"@samp{[[:digit:]]} will match a single decimal digit.  \");\n  else\n    literal (\"Character classes are not supported, so for example \"\n\t     \"you would need to use @samp{[0-9]} \"\n\t     \"instead of @samp{[[:digit:]]}.  \");\n\n  if (options & RE_HAT_LISTS_NOT_NEWLINE)\n    {\n      literal (\"Non-matching lists @samp{[^@dots{}]} do not ever match newline.  \");\n    }\n  newpara ();\n  if (options & RE_NO_GNU_OPS)\n    {\n      content (\"GNU extensions are not supported and so \"\n\t       \"@samp{\\\\w}, @samp{\\\\W}, @samp{\\\\<}, @samp{\\\\>}, @samp{\\\\b}, @samp{\\\\B}, @samp{\\\\`}, and @samp{\\\\'} \"\n\t       \"match \"\n\t       \"@samp{w}, @samp{W}, @samp{<}, @samp{>}, @samp{b}, @samp{B}, @samp{`}, and @samp{'} respectively.  \");\n    }\n  else\n    {\n      content (\"GNU extensions are supported:\");\n      beginenum ();\n      enum_item (\"@samp{\\\\w} matches a character within a word\");\n      enum_item (\"@samp{\\\\W} matches a character which is not within a word\");\n      enum_item (\"@samp{\\\\<} matches the beginning of a word\");\n      enum_item (\"@samp{\\\\>} matches the end of a word\");\n      enum_item (\"@samp{\\\\b} matches a word boundary\");\n      enum_item (\"@samp{\\\\B} matches characters which are not a word boundary\");\n      enum_item (\"@samp{\\\\`} matches the beginning of the whole input\");\n      enum_item (\"@samp{\\\\'} matches the end of the whole input\");\n      endenum ();\n    }\n\n  newpara ();\n\n\n  if (options & RE_NO_BK_PARENS)\n    {\n      literal (\"Grouping is performed with parentheses @samp{()}.  \");\n\n      if (options & RE_UNMATCHED_RIGHT_PAREN_ORD)\n\tliteral (\"An unmatched @samp{)} matches just itself.  \");\n    }\n  else\n    {\n      literal (\"Grouping is performed with backslashes followed by parentheses @samp{\\\\(}, @samp{\\\\)}.  \");\n    }\n\n  if (options & RE_NO_BK_REFS)\n    {\n      content (\"A backslash followed by a digit matches that digit.  \");\n    }\n  else\n    {\n      literal (\"A backslash followed by a digit acts as a back-reference and matches the same thing as the previous grouped expression indicated by that number.  For example @samp{\\\\2} matches the second group expression.  The order of group expressions is determined by the position of their opening parenthesis \");\n      if (options & RE_NO_BK_PARENS)\n\tliteral (\"@samp{(}\");\n      else\n\tliteral (\"@samp{\\\\(}\");\n      content (\".  \");\n    }\n\n\n  newpara ();\n  if (!(options & RE_LIMITED_OPS))\n    {\n      if (options & RE_NO_BK_VBAR)\n\tliteral (\"The alternation operator is @samp{|}.  \");\n      else\n\tliteral (\"The alternation operator is @samp{\\\\|}. \");\n    }\n  newpara ();\n\n  if (options & RE_CONTEXT_INDEP_ANCHORS)\n    {\n      literal (\"The characters @samp{^} and @samp{$} always represent the beginning and end of a string respectively, except within square brackets.  Within brackets, @samp{^} can be used to invert the membership of the character class being specified.  \");\n    }\n  else\n    {\n      literal (\"The character @samp{^} only represents the beginning of a string when it appears:\");\n      beginenum ();\n      enum_item (\"\\nAt the beginning of a regular expression\");\n      enum_item (\"After an open-group, signified by \");\n      if (options & RE_NO_BK_PARENS)\n\t{\n\t  literal (\"@samp{(}\");\n\t}\n      else\n\t{\n\t  literal (\"@samp{\\\\(}\");\n\t}\n      newline ();\n      if (!(options & RE_LIMITED_OPS))\n\t{\n\t  if (options & RE_NEWLINE_ALT)\n\t    enum_item (\"After a newline\");\n\n\t  if (options & RE_NO_BK_VBAR )\n\t    enum_item (\"After the alternation operator @samp{|}\");\n\t  else\n\t    enum_item (\"After the alternation operator @samp{\\\\|}\");\n\t}\n      endenum ();\n\n      newpara ();\n      literal (\"The character @samp{$} only represents the end of a string when it appears:\");\n      beginenum ();\n      enum_item (\"At the end of a regular expression\");\n      enum_item (\"Before a close-group, signified by \");\n      if (options & RE_NO_BK_PARENS)\n\t{\n\t  literal (\"@samp{)}\");\n\t}\n      else\n\t{\n\t  literal (\"@samp{\\\\)}\");\n\t}\n      if (!(options & RE_LIMITED_OPS))\n\t{\n\t  if (options & RE_NEWLINE_ALT)\n\t    enum_item (\"Before a newline\");\n\n\t  if (options & RE_NO_BK_VBAR)\n\t    enum_item (\"Before the alternation operator @samp{|}\");\n\t  else\n\t    enum_item (\"Before the alternation operator @samp{\\\\|}\");\n\t}\n      endenum ();\n    }\n  newpara ();\n  if (!(options & RE_LIMITED_OPS) )\n    {\n      if ((options & RE_CONTEXT_INDEP_OPS)\n\t  && !(options & RE_CONTEXT_INVALID_OPS))\n\t{\n\t  literal (\"The characters @samp{*}, @samp{+} and @samp{?} are special anywhere in a regular expression.  \");\n\t}\n      else\n\t{\n\t  if (options & RE_BK_PLUS_QM)\n\t    literal (\"@samp{\\\\*}, @samp{\\\\+} and @samp{\\\\?} \");\n\t  else\n\t    literal (\"@samp{*}, @samp{+} and @samp{?} \");\n\n\t  if (options & RE_CONTEXT_INVALID_OPS)\n\t    {\n\t      content (\"are special at any point in a regular expression except the following places, where they are not allowed:\");\n\t    }\n\t  else\n\t    {\n\t      content (\"are special at any point in a regular expression except:\");\n\t    }\n\n\t  beginenum ();\n\t  enum_item (\"At the beginning of a regular expression\");\n\t  enum_item (\"After an open-group, signified by \");\n\t  if (options & RE_NO_BK_PARENS)\n\t    {\n\t      literal (\"@samp{(}\");\n\t    }\n\t  else\n\t    {\n\t      literal (\"@samp{\\\\(}\");\n\t    }\n\t  if (!(options & RE_LIMITED_OPS))\n\t    {\n\t      if (options & RE_NEWLINE_ALT)\n\t\tenum_item (\"After a newline\");\n\n\t      if (options & RE_NO_BK_VBAR)\n\t\tenum_item (\"After the alternation operator @samp{|}\");\n\t      else\n\t\tenum_item (\"After the alternation operator @samp{\\\\|}\");\n\t    }\n\t  endenum ();\n\t}\n    }\n\n\n  newpara ();\n  if (options & RE_INTERVALS)\n    {\n      if (options & RE_NO_BK_BRACES)\n\t{\n\t  literal (\"Intervals are specified by @samp{@{} and @samp{@}}.  \");\n\t  if (options & RE_INVALID_INTERVAL_ORD)\n\t    {\n\t      literal (\"Invalid intervals are treated as literals, for example @samp{a@{1} is treated as @samp{a\\\\@{1}\");\n\t    }\n\t  else\n\t    {\n\t      literal (\"Invalid intervals such as @samp{a@{1z} are not accepted.  \");\n\t    }\n\t}\n      else\n\t{\n\t  literal (\"Intervals are specified by @samp{\\\\@{} and @samp{\\\\@}}.  \");\n\t  if (options & RE_INVALID_INTERVAL_ORD)\n\t    {\n\t      literal (\"Invalid intervals are treated as literals, for example @samp{a\\\\@{1} is treated as @samp{a@{1}\");\n\t    }\n\t  else\n\t    {\n\t      literal (\"Invalid intervals such as @samp{a\\\\@{1z} are not accepted.  \");\n\t    }\n\t}\n\n    }\n\n  newpara ();\n  if (options & RE_NO_POSIX_BACKTRACKING)\n    {\n      content (\"Matching succeeds as soon as the whole pattern is matched, meaning that the result may not be the longest possible match.  \");\n    }\n  else\n    {\n      content (\"The longest possible match is returned; this applies to the regular expression as a whole and (subject to this constraint) to subexpressions within groups.  \");\n    }\n  newpara ();\n}",
      "lines": 289,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "copying": {
      "start_point": [
        450,
        0
      ],
      "end_point": [
        470,
        1
      ],
      "content": "static void\ncopying (void)\n{\n  static const char *copy_para[]=\n    {\n      \"Copyright (C) 1994, 1996, 1998, 2000, 2001, 2003, 2004, 2005, 2006,\"\n      ,\"2007, 2009, 2010, 2011 Free Software Foundation, Inc.\"\n      ,\"\"\n      ,\"Permission is granted to copy, distribute and/or modify this document\"\n      ,\"under the terms of the GNU Free Documentation License, Version 1.3 or\"\n      ,\"any later version published by the Free Software Foundation; with no\"\n      ,\"Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.\"\n      ,\"A copy of the license is included in the ``GNU Free\"\n      ,\"Documentation License'' file as part of this distribution.\"\n      \"\"\n      ,NULL\n    };\n  const char **s = copy_para;\n  while (*s)\n    comment (*s++);\n}",
      "lines": 21,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "ignore": {
      "start_point": [
        472,
        0
      ],
      "end_point": [
        476,
        1
      ],
      "content": "static int\nignore (int ix, const unsigned int context)\n{\n  return 0 == (get_regex_type_context (ix) & context);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "menu": {
      "start_point": [
        478,
        0
      ],
      "end_point": [
        500,
        1
      ],
      "content": "static void\nmenu (unsigned int context)\n{\n  int i, options;\n  const char *name;\n\n  output (\"@menu\\n\", 0);\n  for (i=0;\n       options = get_regex_type_flags (i),\n\t name=get_regex_type_name (i);\n       ++i)\n    {\n      if (!ignore (i, context))\n\t{\n\t  output (\"* \", 0);\n\t  output (name, 0);\n\t  content (\" regular expression syntax\");\n\t  output (\"::\", 0);\n\t  newline ();\n\t}\n    }\n  output (\"@end menu\\n\", 0);\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "get_next": {
      "start_point": [
        504,
        0
      ],
      "end_point": [
        521,
        1
      ],
      "content": "static const char *\nget_next (unsigned int ix, unsigned int context)\n{\n  const char *next;\n  while (get_regex_type_name (ix))\n    {\n      if (!ignore (ix, context))\n\t{\n\t  next = get_regex_type_name (ix);\n\t  if (NULL == next)\n\t    return \"\";\n\t  else\n\t    return next;\n\t}\n      ++ix;\n    }\n  return \"\";\n}",
      "lines": 18,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nget_next (unsigned int ix, unsigned int context)",
        "*"
      ]
    },
    "describe_all": {
      "start_point": [
        524,
        0
      ],
      "end_point": [
        574,
        1
      ],
      "content": "static void\ndescribe_all (const char *contextname,\n\t      unsigned int context,\n\t      const char *up)\n{\n  const char *name, *next, *previous;\n  int options;\n  int i, parent;\n\n  copying ();\n  newline ();\n  literal (\"@c this regular expression description is for: \");\n  literal (contextname);\n  newline ();\n  newline ();\n  menu (context);\n\n  previous = \"\";\n\n  for (i=0;\n       options = get_regex_type_flags (i),\n\t name=get_regex_type_name (i);\n       ++i)\n    {\n      if (ignore (i, context))\n\t{\n\t  fprintf (stderr,\n\t\t   \"Skipping regexp type %s for context %s\\n\",\n\t\t   name, contextname);\n\t  name = previous;\n\t  continue;\n\t}\n\n      next = get_next (i+1, context);\n      if (NULL == next)\n\tnext = \"\";\n      begin_subsection (name, next, previous, up);\n      parent = get_regex_type_synonym (i);\n      if (parent >= 0)\n\t{\n\t  content (\"This is a synonym for \");\n\t  content (get_regex_type_name (parent));\n\t  content (\".\");\n\t}\n      else\n\t{\n\t  describe_regex_syntax (options);\n\t}\n      previous = name;\n    }\n}",
      "lines": 51,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        578,
        0
      ],
      "end_point": [
        613,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  const char *up = \"\";\n  unsigned int context = CONTEXT_ALL;\n  const char *contextname = \"all\";\n\n  if (argc)\n    set_program_name (argv[0]);\n  else\n    set_program_name (\"regexprops\");\n\n  if (argc > 1)\n    {\n      up = argv[1];\n    }\n  if (argc > 2)\n    {\n      contextname = argv[2];\n      if (0 == strcmp (contextname, \"findutils\"))\n\tcontext = CONTEXT_FINDUTILS;\n      else if (0 == strcmp (contextname, \"generic\"))\n\tcontext = CONTEXT_GENERIC;\n      else if (0 == strcmp (contextname, \"all\"))\n\tcontext = CONTEXT_ALL;\n      else\n\t{\n\t  fprintf (stderr, \"Unexpected context %s\",\n\t\t   contextname);\n\t  return 1;\n\t}\n    }\n\n  describe_all (contextname, context, up);\n  return 0;\n}",
      "lines": 36,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/lib/regextype.c": {
    "get_regex_type": {
      "start_point": [
        78,
        0
      ],
      "end_point": [
        114,
        1
      ],
      "content": "int\nget_regex_type (const char *s)\n{\n  unsigned i;\n  size_t msglen;\n  char *buf, *p;\n\n  msglen = 0u;\n  for (i=0u; i<N_REGEX_MAP_ENTRIES; ++i)\n    {\n      if (0 == strcmp (regex_map[i].name, s))\n\treturn regex_map[i].option_val;\n      else\n\tmsglen += strlen (quote (regex_map[i].name)) + 2u;\n    }\n\n  /* We didn't find a match for the type of regular expression that the\n   * user indicated they wanted.  Tell them what the options are.\n   */\n  p = buf = xmalloc (1u + msglen);\n  for (i=0u; i<N_REGEX_MAP_ENTRIES; ++i)\n    {\n      if (i > 0u)\n\t{\n\t  strcpy (p, \", \");\n\t  p += 2;\n\t}\n      p += sprintf (p, \"%s\", quote (regex_map[i].name));\n    }\n\n  error (EXIT_FAILURE, 0,\n\t _(\"Unknown regular expression type %s; valid types are %s.\"),\n\t quote (s),\n\t buf);\n  /*NOTREACHED*/\n  return -1;\n}",
      "lines": 37,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "get_regex_type_name": {
      "start_point": [
        117,
        0
      ],
      "end_point": [
        124,
        1
      ],
      "content": "const char *\nget_regex_type_name (unsigned int ix)\n{\n  if (ix < N_REGEX_MAP_ENTRIES)\n    return regex_map[ix].name;\n  else\n    return NULL;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nget_regex_type_name (unsigned int ix)",
        "*"
      ]
    },
    "get_regex_type_flags": {
      "start_point": [
        126,
        0
      ],
      "end_point": [
        133,
        1
      ],
      "content": "int\nget_regex_type_flags (unsigned int ix)\n{\n  if (ix < N_REGEX_MAP_ENTRIES)\n    return regex_map[ix].option_val;\n  else\n    return -1;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "get_regex_type_context": {
      "start_point": [
        135,
        0
      ],
      "end_point": [
        141,
        1
      ],
      "content": "unsigned int get_regex_type_context (unsigned int ix)\n{\n  if (ix < N_REGEX_MAP_ENTRIES)\n    return regex_map[ix].context;\n  else\n    return 0u;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "unsigned int",
        "unsigned",
        "int"
      ]
    },
    "get_regex_type_synonym": {
      "start_point": [
        143,
        0
      ],
      "end_point": [
        161,
        1
      ],
      "content": "int\nget_regex_type_synonym (unsigned int ix)\n{\n  unsigned i;\n  int flags;\n\n  if (ix >= N_REGEX_MAP_ENTRIES)\n    return -1;\n\n  flags = regex_map[ix].option_val;\n  for (i=0u; i<ix; ++i)\n    {\n      if (flags == regex_map[i].option_val)\n\t{\n\t  return i;\n\t}\n    }\n  return -1;\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/lib/regextype.h": {},
  "findutils/findutils-4.6.0/lib/safe-atoi.c": {
    "safe_atoi": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "int\nsafe_atoi (const char *s, enum quoting_style style)\n{\n  long lval;\n  char *end;\n\n  errno = 0;\n  lval = strtol (s, &end, 10);\n  if ( (LONG_MAX == lval) || (LONG_MIN == lval) )\n    {\n      /* max/min possible value, or an error. */\n      if (errno == ERANGE)\n\t{\n\t  /* too big, or too small. */\n\t  error (EXIT_FAILURE, errno, \"%s\", s);\n\t}\n      else\n\t{\n\t  /* not a valid number */\n\t  error (EXIT_FAILURE, errno, \"%s\", s);\n\t}\n      /* Otherwise, we do a range chack against INT_MAX and INT_MIN\n       * below.\n       */\n    }\n\n  if (lval > INT_MAX || lval < INT_MIN)\n    {\n      /* The number was in range for long, but not int. */\n      errno = ERANGE;\n      error (EXIT_FAILURE, errno, \"%s\", s);\n    }\n  else if (*end)\n    {\n      error (EXIT_FAILURE, errno, _(\"Unexpected suffix %s on %s\"),\n\t     quotearg_n_style (0, style, end),\n\t     quotearg_n_style (1, style, s));\n    }\n  else if (end == s)\n    {\n      error (EXIT_FAILURE, errno, _(\"Expected an integer: %s\"),\n\t     quotearg_n_style (0, style, s));\n    }\n  return (int)lval;\n}",
      "lines": 45,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/lib/safe-atoi.h": {},
  "findutils/findutils-4.6.0/lib/splitstring.c": {
    "field_length": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        42,
        1
      ],
      "content": "static size_t\nfield_length (const char *str, const char *separators)\n{\n  /* if there are no separators, the whole input is one field. */\n  if (*separators)\n    {\n      const char *end = strpbrk (str, separators);\n      if (end)\n\treturn end - str;\n    }\n  return strlen (str);\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "splitstring": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "bool\nsplitstring(const char *s, const char *separators, bool first,\n\t    size_t *pos, size_t *len)\n{\n  if (first)\n    {\n      *pos = 0u;\n      *len = 0u;\n    }\n  else\n    {\n      *pos += *len;\t\t/* advance to the next field. */\n      if (s[*pos])\n\t++*pos;\t\t\t/* skip the separator */\n      else\n\treturn false;\t\t/* we reached the end. */\n    }\n  *len = field_length (&s[*pos], separators);\n  return true;\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "bool"
      ]
    }
  },
  "findutils/findutils-4.6.0/lib/splitstring.h": {},
  "findutils/findutils-4.6.0/lib/test_splitstring.c": {
    "assertEqualFunc": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "static void\nassertEqualFunc(const char *file, int line, const char *label,\n\t\tsize_t expected, size_t got)\n{\n  if (expected != got)\n    fprintf(stderr, \"%s line %d: %s: expected %lu, got %lu\\n\",\n\t    file, line, label, (unsigned long)expected, (unsigned long)got);\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_empty": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "static void\ntest_empty (void)\n{\n  size_t len, pos;\n  bool result;\n  const char *empty = \"\";\n\n  result = splitstring (empty, \":\", true, &pos, &len);\n  assert (result);\n  ASSERT_EQUAL (0, pos);\n  ASSERT_EQUAL (0, len);\n  result = splitstring (empty, \":\", false, &pos, &len);\n  assert (!result);\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_onefield": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "static void test_onefield (void)\n{\n  size_t len, pos;\n  bool result;\n  const char *input = \"aaa\";\n\n  result = splitstring (input, \":\", true, &pos, &len);\n  assert (result);\n  ASSERT_EQUAL (0, pos);\n  ASSERT_EQUAL (3, len);\n  result = splitstring (input, \":\", false, &pos, &len);\n  assert (!result);\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_not_colon": {
      "start_point": [
        73,
        0
      ],
      "end_point": [
        92,
        1
      ],
      "content": "static void test_not_colon (void)\n{\n  size_t len, pos;\n  bool result;\n  const char *separators = \"!\";\n  const char *input = \"aa!b\";\n\n  result = splitstring (input, separators, true, &pos, &len);\n  assert (result);\n  ASSERT_EQUAL (0, pos);\n  ASSERT_EQUAL (2, len);\n\n  result = splitstring (input, separators, false, &pos, &len);\n  assert (result);\n  ASSERT_EQUAL (3, pos);\n  ASSERT_EQUAL (1, len);\n\n  result = splitstring (input, separators, false, &pos, &len);\n  assert (!result);\n}",
      "lines": 20,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_empty_back": {
      "start_point": [
        94,
        0
      ],
      "end_point": [
        110,
        1
      ],
      "content": "static void test_empty_back (void)\n{\n  size_t len, pos;\n  bool result;\n  const char *input = \"aa:\";\n\n  result = splitstring (input, \":\", true, &pos, &len);\n  assert (result);\n  ASSERT_EQUAL (0, pos);\n  ASSERT_EQUAL (2, len);\n  result = splitstring (input, \":\", false, &pos, &len);\n  assert (result);\n  ASSERT_EQUAL (3, pos);\n  ASSERT_EQUAL (0, len);\n  result = splitstring (input, \":\", false, &pos, &len);\n  assert (!result);\n}",
      "lines": 17,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_empty_front": {
      "start_point": [
        112,
        0
      ],
      "end_point": [
        128,
        1
      ],
      "content": "static void test_empty_front (void)\n{\n  size_t len, pos;\n  bool result;\n  const char *input = \":aaa\";\n\n  result = splitstring (input, \":\", true, &pos, &len);\n  assert (result);\n  ASSERT_EQUAL (0, pos);\n  ASSERT_EQUAL (0, len);\n  result = splitstring (input, \":\", false, &pos, &len);\n  assert (result);\n  ASSERT_EQUAL (1, pos);\n  ASSERT_EQUAL (3, len);\n  result = splitstring (input, \":\", false, &pos, &len);\n  assert (!result);\n}",
      "lines": 17,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_twofields": {
      "start_point": [
        130,
        0
      ],
      "end_point": [
        146,
        1
      ],
      "content": "static void test_twofields (void)\n{\n  size_t len, pos;\n  bool result;\n  const char *input = \"aaa:bb\";\n\n  result = splitstring (input, \":\", true, &pos, &len);\n  assert (result);\n  ASSERT_EQUAL (0, pos);\n  ASSERT_EQUAL (3, len);\n  result = splitstring (input, \":\", false, &pos, &len);\n  assert (result);\n  ASSERT_EQUAL (4, pos);\n  ASSERT_EQUAL (2, len);\n  result = splitstring (input, \":\", false, &pos, &len);\n  assert (!result);\n}",
      "lines": 17,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_twoseparators": {
      "start_point": [
        148,
        0
      ],
      "end_point": [
        168,
        1
      ],
      "content": "static void test_twoseparators (void)\n{\n  size_t len, pos;\n  bool result;\n  const char *input = \"a:bb!c\";\n\n  result = splitstring (input, \":!\", true, &pos, &len);\n  assert (result);\n  ASSERT_EQUAL (0, pos);\n  ASSERT_EQUAL (1, len);\n  result = splitstring (input, \":!\", false, &pos, &len);\n  assert (result);\n  ASSERT_EQUAL (2,  pos);\n  ASSERT_EQUAL (2, len);\n  result = splitstring (input, \":!\", false, &pos, &len);\n  assert (result);\n  ASSERT_EQUAL (5, pos);\n  ASSERT_EQUAL (1, len);\n  result = splitstring (input, \":!\", false, &pos, &len);\n  assert (!result);\n}",
      "lines": 21,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_consecutive_empty": {
      "start_point": [
        170,
        0
      ],
      "end_point": [
        194,
        1
      ],
      "content": "static void test_consecutive_empty (void)\n{\n  size_t len, pos;\n  bool result;\n  const char *input = \"a::b\";\n  const char *separators = \":\";\n\n  result = splitstring (input, separators, true, &pos, &len);\n  assert (result);\n  ASSERT_EQUAL (0, pos);\n  ASSERT_EQUAL (1, len);\n\n  result = splitstring (input, separators, false, &pos, &len);\n  assert (result);\n  ASSERT_EQUAL (2, pos);\n  ASSERT_EQUAL (0, len);\n\n  result = splitstring (input, separators, false, &pos, &len);\n  assert (result);\n  ASSERT_EQUAL (3, pos);\n  ASSERT_EQUAL (1, len);\n\n  result = splitstring (input, separators, false, &pos, &len);\n  assert (!result);\n}",
      "lines": 25,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        196,
        0
      ],
      "end_point": [
        207,
        1
      ],
      "content": "int main (int argc, char *argv[])\n{\n  test_empty ();\n  test_onefield ();\n  test_not_colon ();\n  test_empty_back ();\n  test_empty_front ();\n  test_twofields ();\n  test_twoseparators ();\n  test_consecutive_empty ();\n  return 0;\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/lib/unused-result.h": {},
  "findutils/findutils-4.6.0/lib/waitpid.c": {
    "waitpid": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "pid_t\nwaitpid (pid_t pid, int *stat_loc, int options)\n{\n  int i;\n  pid_t p;\n\n  if (!options && (pid == -1 || 0 < pid))\n    {\n      /* If we have already waited for this child, return it immediately.  */\n      for (i = 0;  i < WAITPID_CHILDREN;  i++)\n\t{\n\t  p = waited_pid[i];\n\t  if (p && (p == pid || pid == -1))\n\t    {\n\t      waited_pid[i] = 0;\n\t      goto success;\n\t    }\n\t}\n\n      /* The child has not returned yet; wait for it, accumulating status.  */\n      for (i = 0;  i < WAITPID_CHILDREN;  i++)\n\tif (! waited_pid[i])\n\t  {\n\t    p = wait (&waited_status[i]);\n\t    if (p < 0)\n\t      return p;\n\t    if (p == pid || pid == -1)\n\t      goto success;\n\t    waited_pid[i] = p;\n\t  }\n    }\n\n  /* We cannot emulate this wait call, e.g. because of too many children.  */\n  errno = EINVAL;\n  return -1;\n\nsuccess:\n  if (stat_loc)\n    *stat_loc = waited_status[i];\n  return p;\n}",
      "lines": 41,
      "depth": 14,
      "decorators": [
        "pid_t"
      ]
    }
  },
  "findutils/findutils-4.6.0/locate/bigram.c": {
    "prefix_length": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        80,
        1
      ],
      "content": "static int\nprefix_length (char *s1, char *s2)\n{\n  register char *start;\n\n  for (start = s1; *s1 == *s2 && *s1 != '\\0'; s1++, s2++)\n    ;\n  return s1 - start;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        82,
        0
      ],
      "end_point": [
        145,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  char *path;\t\t\t/* The current input entry.  */\n  char *oldpath;\t\t/* The previous input entry.  */\n  size_t pathsize, oldpathsize;\t/* Amounts allocated for them.  */\n  int line_len;\t\t\t/* Length of input line.  */\n\n  if (argv[0])\n    set_program_name (argv[0]);\n  else\n    set_program_name (\"bigram\");\n\n#ifdef HAVE_SETLOCALE\n  setlocale (LC_ALL, \"\");\n#endif\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  (void) argc;\n  if (atexit (close_stdout))\n    {\n      error (EXIT_FAILURE, errno, _(\"The atexit library function failed\"));\n    }\n\n  pathsize = oldpathsize = 1026; /* Increased as necessary by getline.  */\n  path = xmalloc (pathsize);\n  oldpath = xmalloc (oldpathsize);\n\n  /* Set to empty string, to force the first prefix count to 0.  */\n  oldpath[0] = '\\0';\n\n  while ((line_len = getline (&path, &pathsize, stdin)) > 0)\n    {\n      register int count;\t/* The prefix length.  */\n      register int j;\t\t/* Index into input line.  */\n\n      path[line_len - 1] = '\\0'; /* Remove the newline. */\n\n      /* Output bigrams in the remainder only. */\n      count = prefix_length (oldpath, path);\n      for (j = count; path[j] != '\\0' && path[j + 1] != '\\0'; j += 2)\n\t{\n\t  putchar (path[j]);\n\t  putchar (path[j + 1]);\n\t  putchar ('\\n');\n\t}\n\n      {\n\t/* Swap path and oldpath and their sizes.  */\n\tchar *tmppath = oldpath;\n\tsize_t tmppathsize = oldpathsize;\n\toldpath = path;\n\toldpathsize = pathsize;\n\tpath = tmppath;\n\tpathsize = tmppathsize;\n      }\n    }\n\n  free (path);\n  free (oldpath);\n\n  return 0;\n}",
      "lines": 64,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/locate/code.c": {
    "strindex": {
      "start_point": [
        95,
        0
      ],
      "end_point": [
        111,
        1
      ],
      "content": "static int\nstrindex (char *string, char *pattern)\n{\n  register char *s;\n\n  for (s = string; *s != '\\0'; s++)\n    /* Fast first char check. */\n    if (*s == *pattern)\n      {\n\tregister char *p2 = pattern + 1, *s2 = s + 1;\n\twhile (*p2 != '\\0' && *p2 == *s2)\n\t  p2++, s2++;\n\tif (*p2 == '\\0')\n\t  return s2 - strlen (pattern) - string;\n      }\n  return -1;\n}",
      "lines": 17,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "prefix_length": {
      "start_point": [
        115,
        0
      ],
      "end_point": [
        123,
        1
      ],
      "content": "static int\nprefix_length (char *s1, char *s2)\n{\n  register char *start;\n\n  for (start = s1; *s1 == *s2 && *s1 != '\\0'; s1++, s2++)\n    ;\n  return s1 - start;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "usage": {
      "start_point": [
        127,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "static void\nusage (FILE *stream)\n{\n  fprintf (stream, _(\"\\\nUsage: %s [--version | --help]\\n\\\nor     %s most_common_bigrams < file-list > locate-database\\n\"),\n\t   program_name, program_name);\n  fputs (_(\"\\nReport bugs to <bug-findutils@gnu.org>.\\n\"), stream);\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "inerr": {
      "start_point": [
        141,
        0
      ],
      "end_point": [
        147,
        1
      ],
      "content": "static void\ninerr (const char *filename)\n{\n  error (EXIT_FAILURE, errno, \"%s\", filename);\n  /*NOTREACHED*/\n  abort ();\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "outerr": {
      "start_point": [
        149,
        0
      ],
      "end_point": [
        155,
        1
      ],
      "content": "static void\nouterr (void)\n{\n  error (EXIT_FAILURE, errno, _(\"write error\"));\n  /*NOTREACHED*/\n  abort ();\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        158,
        0
      ],
      "end_point": [
        290,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  char *path;\t\t\t/* The current input entry.  */\n  char *oldpath;\t\t/* The previous input entry.  */\n  size_t pathsize, oldpathsize;\t/* Amounts allocated for them.  */\n  int count, oldcount, diffcount; /* Their prefix lengths & the difference. */\n  char bigram[3];\t\t/* Bigram to search for in table.  */\n  int code;\t\t\t/* Index of `bigram' in bigrams table.  */\n  FILE *fp;\t\t\t/* Most common bigrams file.  */\n  int line_len;\t\t\t/* Length of input line.  */\n\n  set_program_name (argv[0]);\n  if (atexit (close_stdout))\n    {\n      error (EXIT_FAILURE, errno, _(\"The atexit library function failed\"));\n    }\n\n  bigram[2] = '\\0';\n\n  if (argc != 2)\n    {\n      usage (stderr);\n      return 2;\n    }\n\n  if (0 == strcmp (argv[1], \"--help\"))\n    {\n      usage (stdout);\n      return 0;\n    }\n  else if (0 == strcmp (argv[1], \"--version\"))\n    {\n      display_findutils_version (\"code\");\n      return 0;\n    }\n\n  fp = fopen (argv[1], \"r\");\n  if (fp == NULL)\n    {\n      fprintf (stderr, \"%s: \", argv[0]);\n      perror (argv[1]);\n      return 1;\n    }\n\n  pathsize = oldpathsize = 1026; /* Increased as necessary by getline.  */\n  path = xmalloc (pathsize);\n  oldpath = xmalloc (oldpathsize);\n\n  /* Set to empty string, to force the first prefix count to 0.  */\n  oldpath[0] = '\\0';\n  oldcount = 0;\n\n  /* Copy the list of most common bigrams to the output,\n     padding with NULs if there are <128 of them.  */\n  if (NULL == fgets (bigrams, 257, fp))\n    inerr (argv[1]);\n\n  if (256 != fwrite (bigrams, 1, 256, stdout))\n     outerr ();\n\n  if (EOF == fclose (fp))\n     inerr (argv[1]);\n\n  while ((line_len = getline (&path, &pathsize, stdin)) > 0)\n    {\n      char *pp;\n\n      path[line_len - 1] = '\\0'; /* Remove newline. */\n\n      /* Squelch unprintable chars in path so as not to botch decoding.  */\n      for (pp = path; *pp != '\\0'; pp++)\n\t{\n\t  if (!(*pp >= 040 && *pp < 0177))\n\t    *pp = '?';\n\t}\n\n      count = prefix_length (oldpath, path);\n      diffcount = count - oldcount;\n      oldcount = count;\n      /* If the difference is small, it fits in one byte;\n\t otherwise, two bytes plus a marker noting that fact.  */\n      if (diffcount < -LOCATEDB_OLD_OFFSET || diffcount > LOCATEDB_OLD_OFFSET)\n\t{\n\t  if (EOF ==- putc (LOCATEDB_OLD_ESCAPE, stdout))\n\t    outerr ();\n\n\t  if (!putword (stdout,\n\t\t\tdiffcount+LOCATEDB_OLD_OFFSET,\n\t\t\tGetwordEndianStateNative))\n\t    outerr ();\n\t}\n      else\n\t{\n\t  if (EOF == putc (diffcount + LOCATEDB_OLD_OFFSET, stdout))\n\t    outerr ();\n\t}\n\n      /* Look for bigrams in the remainder of the path.  */\n      for (pp = path + count; *pp != '\\0'; pp += 2)\n\t{\n\t  if (pp[1] == '\\0')\n\t    {\n\t      /* No bigram is possible; only one char is left.  */\n\t      putchar (*pp);\n\t      break;\n\t    }\n\t  bigram[0] = *pp;\n\t  bigram[1] = pp[1];\n\t  /* Linear search for specific bigram in string table. */\n\t  code = strindex (bigrams, bigram);\n\t  if (code % 2 == 0)\n\t    putchar ((code / 2) | 0200); /* It's a common bigram.  */\n\t  else\n\t    fputs (bigram, stdout); /* Write the text as printable ASCII.  */\n\t}\n\n      {\n\t/* Swap path and oldpath and their sizes.  */\n\tchar *tmppath = oldpath;\n\tsize_t tmppathsize = oldpathsize;\n\toldpath = path;\n\toldpathsize = pathsize;\n\tpath = tmppath;\n\tpathsize = tmppathsize;\n      }\n    }\n\n  free (path);\n  free (oldpath);\n\n  return 0;\n}",
      "lines": 133,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/locate/frcode.c": {
    "put_short": {
      "start_point": [
        115,
        0
      ],
      "end_point": [
        125,
        1
      ],
      "content": "static int\nput_short (int c, FILE *fp)\n{\n  /* XXX: The value of c may be negative.  ANSI C 1989 (section 6.3.7)\n   * indicates that the result of shifting a negative value right is\n   * implementation defined.\n   */\n  assert (c <= SHRT_MAX);\n  assert (c >= SHRT_MIN);\n  return (putc (c >> 8, fp) != EOF) && (putc (c, fp) != EOF);\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "prefix_length": {
      "start_point": [
        129,
        0
      ],
      "end_point": [
        143,
        1
      ],
      "content": "static int\nprefix_length (char *s1, char *s2)\n{\n  register char *start;\n  int limit = INT_MAX;\n  for (start = s1; *s1 == *s2 && *s1 != '\\0'; s1++, s2++)\n    {\n      /* Don't emit a prefix length that will not fit into\n       * our return type.\n       */\n      if (0 == --limit)\n\tbreak;\n    }\n  return s1 - start;\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "usage": {
      "start_point": [
        155,
        0
      ],
      "end_point": [
        162,
        1
      ],
      "content": "static void\nusage (FILE *stream)\n{\n  fprintf (stream,\n\t   _(\"Usage: %s [-0 | --null] [--version] [--help]\\n\"),\n\t   program_name);\n  fputs (_(\"\\nReport bugs to <bug-findutils@gnu.org>.\\n\"), stream);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "get_seclevel": {
      "start_point": [
        164,
        0
      ],
      "end_point": [
        203,
        1
      ],
      "content": "static long\nget_seclevel (char *s)\n{\n  long result;\n  char *p;\n\n  /* Reset errno in oreder to be able to distinguish LONG_MAX/LONG_MIN\n   * from values whichare actually out of range\n   */\n  errno = 0;\n\n  result = strtol (s, &p, 10);\n  if ((0==result) && (p == optarg))\n    {\n      error (EXIT_FAILURE, 0,\n\t     _(\"You need to specify a security level as a decimal integer.\"));\n      /*NOTREACHED*/\n      return -1;\n    }\n  else if ((LONG_MIN==result || LONG_MAX==result) && errno)\n\n    {\n      error (EXIT_FAILURE, 0,\n\t     _(\"Security level %s is outside the convertible range.\"), s);\n      /*NOTREACHED*/\n      return -1;\n    }\n  else if (*p)\n    {\n      /* Some suffix exists */\n      error (EXIT_FAILURE, 0,\n\t     _(\"Security level %s has unexpected suffix %s.\"), s, p);\n      /*NOTREACHED*/\n      return -1;\n    }\n  else\n    {\n      return result;\n    }\n}",
      "lines": 40,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "long",
        "long"
      ]
    },
    "outerr": {
      "start_point": [
        205,
        0
      ],
      "end_point": [
        210,
        1
      ],
      "content": "static void\nouterr (void)\n{\n  /* Issue the same error message as closeout () would. */\n  error (EXIT_FAILURE, errno, _(\"write error\"));\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        212,
        0
      ],
      "end_point": [
        361,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  char *path;\t\t\t/* The current input entry.  */\n  char *oldpath;\t\t/* The previous input entry.  */\n  size_t pathsize, oldpathsize;\t/* Amounts allocated for them.  */\n  int count, oldcount, diffcount; /* Their prefix lengths & the difference. */\n  int line_len;\t\t\t/* Length of input line.  */\n  int delimiter = '\\n';\n  int optc;\n  int slocate_compat = 0;\n  long slocate_seclevel = 0L;\n\n  if (argv[0])\n    set_program_name (argv[0]);\n  else\n    set_program_name (\"frcode\");\n\n  if (atexit (close_stdout))\n    {\n      error (EXIT_FAILURE, errno, _(\"The atexit library function failed\"));\n    }\n\n  pathsize = oldpathsize = 1026; /* Increased as necessary by getline.  */\n  path = xmalloc (pathsize);\n  oldpath = xmalloc (oldpathsize);\n\n  oldpath[0] = 0;\n  oldcount = 0;\n\n\n  while ((optc = getopt_long (argc, argv, \"hv0S:\", longopts, (int *) 0)) != -1)\n    switch (optc)\n      {\n      case '0':\n\tdelimiter = 0;\n\tbreak;\n\n      case 'S':\n\tslocate_compat = 1;\n\tslocate_seclevel = get_seclevel (optarg);\n\tif (slocate_seclevel < 0 || slocate_seclevel > 1)\n\t  {\n\t    error (EXIT_FAILURE, 0,\n\t\t   _(\"slocate security level %ld is unsupported.\"),\n\t\t   slocate_seclevel);\n\t  }\n\tbreak;\n\n      case 'h':\n\tusage (stdout);\n\treturn 0;\n\n      case 'v':\n\tdisplay_findutils_version (\"frcode\");\n\treturn 0;\n\n      default:\n\tusage (stderr);\n\treturn 1;\n      }\n\n  /* We expect to have no arguments. */\n  if (optind != argc)\n    {\n      usage (stderr);\n      return 1;\n    }\n\n\n  if (slocate_compat)\n    {\n      fputc (slocate_seclevel ? '1' : '0', stdout);\n      fputc (0, stdout);\n\n    }\n  else\n    {\n      /* GNU LOCATE02 format */\n      if (fwrite (LOCATEDB_MAGIC, 1, sizeof (LOCATEDB_MAGIC), stdout)\n\t  != sizeof (LOCATEDB_MAGIC))\n\t{\n\t  error (EXIT_FAILURE, errno, _(\"Failed to write to standard output\"));\n\t}\n    }\n\n\n  while ((line_len = getdelim (&path, &pathsize, delimiter, stdin)) > 0)\n    {\n      path[line_len - 1] = '\\0'; /* FIXME temporary: nuke the newline.  */\n\n      count = prefix_length (oldpath, path);\n      diffcount = count - oldcount;\n      if ( (diffcount > SHRT_MAX) || (diffcount < SHRT_MIN) )\n\t{\n\t  /* We do this to prevent overflow of the value we\n\t   * write with put_short ()\n\t   */\n\t  count = 0;\n\t  diffcount = (-oldcount);\n\t}\n      oldcount = count;\n\n      if (slocate_compat)\n\t{\n\t  /* Emit no count for the first pathname. */\n\t  slocate_compat = 0;\n\t}\n      else\n\t{\n\t  /* If the difference is small, it fits in one byte;\n\t     otherwise, two bytes plus a marker noting that fact.  */\n\t  if (diffcount < LOCATEDB_ONEBYTE_MIN\n\t      || diffcount > LOCATEDB_ONEBYTE_MAX)\n\t    {\n\t      if (EOF == putc (LOCATEDB_ESCAPE, stdout))\n\t\touterr ();\n\t      if (!put_short (diffcount, stdout))\n\t\touterr ();\n\t    }\n\t  else\n\t    {\n\t      if (EOF == putc (diffcount, stdout))\n\t\touterr ();\n\t    }\n\t}\n\n      if ( (EOF == fputs (path + count, stdout))\n\t   || (EOF == putc ('\\0', stdout)))\n\t{\n\t  outerr ();\n\t}\n\n      if (1)\n\t{\n\t  /* Swap path and oldpath and their sizes.  */\n\t  char *tmppath = oldpath;\n\t  size_t tmppathsize = oldpathsize;\n\t  oldpath = path;\n\t  oldpathsize = pathsize;\n\t  path = tmppath;\n\t  pathsize = tmppathsize;\n\t}\n    }\n\n  free (path);\n  free (oldpath);\n\n  return 0;\n}",
      "lines": 150,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/locate/locate.c": {
    "set_max_db_age": {
      "start_point": [
        167,
        0
      ],
      "end_point": [
        207,
        1
      ],
      "content": "static void\nset_max_db_age (const char *s)\n{\n  char *end;\n  unsigned long int val;\n  /* XXX: we ignore the case where the input is negative, which is allowed(!). */\n\n  if (0 == *s)\n    {\n      error (EXIT_FAILURE, 0,\n             _(\"The argument for option --max-database-age must not be empty\"));\n    }\n\n\n  /* We have to set errno here, otherwise when the function returns ULONG_MAX,\n   * we would not be able to tell if that is the correct answer, or whether it\n   * signifies an error.\n   */\n  errno = 0;\n  val = strtoul (s, &end, 10);\n\n  /* Diagnose number too large, non-numbes and trailing junk. */\n  if ((ULONG_MAX == val && ERANGE == errno) ||\n      (0 == val && EINVAL == errno))\n    {\n      error (EXIT_FAILURE, errno,\n             _(\"Invalid argument %s for option --max-database-age\"),\n             quotearg_n_style (0, locale_quoting_style, s));\n    }\n  else if (*end)\n    {\n      /* errno wasn't set, don't print its message */\n      error (EXIT_FAILURE, 0,\n             _(\"Invalid argument %s for option --max-database-age\"),\n             quotearg_n_style (0, locale_quoting_style, s));\n    }\n  else\n    {\n      warn_number_units = val;\n    }\n}",
      "lines": 41,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "get_short": {
      "start_point": [
        213,
        0
      ],
      "end_point": [
        222,
        1
      ],
      "content": "static short\nget_short (FILE *fp)\n{\n\n  register short x;\n\n  x = (signed char) fgetc (fp) << 8;\n  x |= (fgetc (fp) & 0xff);\n  return x;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "short",
        "short"
      ]
    },
    "contains_metacharacter": {
      "start_point": [
        228,
        0
      ],
      "end_point": [
        235,
        1
      ],
      "content": "static int\ncontains_metacharacter (const char *s)\n{\n  if (NULL == strpbrk (s, metacharacters))\n    return 0;\n  else\n    return 1;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "locate_read_str": {
      "start_point": [
        251,
        0
      ],
      "end_point": [
        282,
        1
      ],
      "content": "static int\nlocate_read_str (char **buf, size_t *siz, FILE *fp, int delimiter, int offs)\n{\n  char * p = NULL;\n  size_t sz = 0;\n  int nread;\n  size_t needed;\n\n  nread = getdelim (&p, &sz, delimiter, fp);\n  if (nread >= 0)\n    {\n      assert (p != NULL);\n\n      needed = offs + nread + 1u;\n      if (needed > (*siz))\n        {\n          char *pnew = realloc (*buf, needed);\n          if (NULL == pnew)\n            {\n              return -1;        /* FAIL */\n            }\n          else\n            {\n              *siz = needed;\n              *buf = pnew;\n            }\n        }\n      memcpy((*buf)+offs, p, nread + 1);\n      free(p);\n    }\n  return nread;\n}",
      "lines": 32,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "visit": {
      "start_point": [
        344,
        0
      ],
      "end_point": [
        356,
        1
      ],
      "content": "static inline int visit (const struct visitor *p,\n                         int accept_flags,\n                         struct process_data *procdata,\n                         const struct visitor * const stop)\n{\n  register int result = accept_flags;\n  while ( (accept_flags & result) && (stop != p) )\n    {\n      result = (p->inspector)(procdata, p->context);\n      p = p->next;\n    }\n  return result;\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "process_simple": {
      "start_point": [
        359,
        0
      ],
      "end_point": [
        363,
        1
      ],
      "content": "static int\nprocess_simple (struct process_data *procdata)\n{\n  return visit (inspectors, (VISIT_CONTINUE|VISIT_ACCEPTED), procdata, NULL);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "process_or": {
      "start_point": [
        366,
        0
      ],
      "end_point": [
        382,
        1
      ],
      "content": "static int\nprocess_or (struct process_data *procdata)\n{\n  int result;\n\n  result = visit (inspectors, (VISIT_CONTINUE|VISIT_REJECTED), procdata, past_pat_inspector);\n  if (result == VISIT_CONTINUE)\n    result = VISIT_REJECTED;\n  if (result & (VISIT_ABORT | VISIT_REJECTED))\n    return result;\n\n  result = visit (past_pat_inspector, VISIT_CONTINUE, procdata, NULL);\n  if (VISIT_CONTINUE == result)\n    return VISIT_ACCEPTED;\n  else\n    return result;\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "process_and": {
      "start_point": [
        385,
        0
      ],
      "end_point": [
        401,
        1
      ],
      "content": "static int\nprocess_and (struct process_data *procdata)\n{\n  int result;\n\n  result = visit (inspectors, (VISIT_CONTINUE|VISIT_ACCEPTED), procdata, past_pat_inspector);\n  if (result == VISIT_CONTINUE)\n    result = VISIT_REJECTED;\n  if (result & (VISIT_ABORT | VISIT_REJECTED))\n    return result;\n\n  result = visit (past_pat_inspector, VISIT_CONTINUE, procdata, NULL);\n  if (VISIT_CONTINUE == result)\n    return VISIT_ACCEPTED;\n  else\n    return result;\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "add_visitor": {
      "start_point": [
        407,
        0
      ],
      "end_point": [
        424,
        1
      ],
      "content": "static void\nadd_visitor (visitfunc fn, void *context)\n{\n  struct visitor *p = xmalloc (sizeof (struct visitor));\n  p->inspector = fn;\n  p->context   = context;\n  p->next = NULL;\n\n  if (NULL == lastinspector)\n    {\n      lastinspector = inspectors = p;\n    }\n  else\n    {\n      lastinspector->next = p;\n      lastinspector = p;\n    }\n}",
      "lines": 18,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "visit_justprint_quoted": {
      "start_point": [
        426,
        0
      ],
      "end_point": [
        435,
        1
      ],
      "content": "static int\nvisit_justprint_quoted (struct process_data *procdata, void *context)\n{\n  (void) context;\n  print_quoted (stdout, quote_opts, stdout_is_a_tty,\n                \"%s\",\n                procdata->original_filename);\n  putchar (separator);\n  return VISIT_CONTINUE;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "visit_justprint_unquoted": {
      "start_point": [
        437,
        0
      ],
      "end_point": [
        444,
        1
      ],
      "content": "static int\nvisit_justprint_unquoted (struct process_data *procdata, void *context)\n{\n  (void) context;\n  fputs (procdata->original_filename, stdout);\n  putchar (separator);\n  return VISIT_CONTINUE;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "toolong": {
      "start_point": [
        446,
        0
      ],
      "end_point": [
        453,
        1
      ],
      "content": "static void\ntoolong (struct process_data *procdata)\n{\n  error (EXIT_FAILURE, 0,\n         _(\"locate database %s contains a \"\n           \"filename longer than locate can handle\"),\n         procdata->dbfile);\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "extend": {
      "start_point": [
        455,
        0
      ],
      "end_point": [
        470,
        1
      ],
      "content": "static void\nextend (struct process_data *procdata, size_t siz1, size_t siz2)\n{\n  /* Figure out if the addition operation is safe before performing it. */\n  if (SIZE_MAX - siz1 < siz2)\n    {\n      toolong (procdata);\n    }\n  else if (procdata->pathsize < (siz1+siz2))\n    {\n      procdata->pathsize = siz1+siz2;\n      procdata->original_filename = x2nrealloc (procdata->original_filename,\n                                                &procdata->pathsize,\n                                                1);\n    }\n}",
      "lines": 16,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "visit_old_format": {
      "start_point": [
        472,
        0
      ],
      "end_point": [
        538,
        1
      ],
      "content": "static int\nvisit_old_format (struct process_data *procdata, void *context)\n{\n  register size_t i;\n  (void) context;\n\n  if (EOF == procdata->c)\n    return VISIT_ABORT;\n\n  /* Get the offset in the path where this path info starts.  */\n  if (procdata->c == LOCATEDB_OLD_ESCAPE)\n    {\n      int minval, maxval;\n      int word;\n\n      procdata->count -= LOCATEDB_OLD_OFFSET;\n      minval = (0       - procdata->count);\n      if (procdata->count >= 0)\n        maxval = (procdata->len - procdata->count);\n      else\n        maxval = (procdata->len - 0);\n      word = getword (procdata->fp, procdata->dbfile,\n                      minval, maxval, &procdata->endian_state);\n      procdata->count += word;\n      assert (procdata->count >= 0);\n    }\n  else\n    {\n      procdata->count += (procdata->c - LOCATEDB_OLD_OFFSET);\n      assert (procdata->count >= 0);\n    }\n\n  /* Overlay the old path with the remainder of the new.  Read\n   * more data until we get to the next filename.\n   */\n  for (i=procdata->count;\n       (procdata->c = getc (procdata->fp)) > LOCATEDB_OLD_ESCAPE;)\n    {\n      if (EOF == procdata->c)\n        break;\n\n      if (procdata->c < 0200)\n        {\n          /* An ordinary character. */\n          extend (procdata, i, 1u);\n          procdata->original_filename[i++] = procdata->c;\n        }\n      else\n        {\n          /* Bigram markers have the high bit set. */\n          extend (procdata, i, 2u);\n          procdata->c &= 0177;\n          procdata->original_filename[i++] = procdata->bigram1[procdata->c];\n          procdata->original_filename[i++] = procdata->bigram2[procdata->c];\n        }\n    }\n\n  /* Consider the case where we executed the loop body zero times; we\n   * still need space for the terminating null byte.\n   */\n  extend (procdata, i, 1u);\n  procdata->original_filename[i] = 0;\n  procdata->len = i;\n  procdata->munged_filename = procdata->original_filename;\n\n  return VISIT_CONTINUE;\n}",
      "lines": 67,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "visit_locate02_format": {
      "start_point": [
        540,
        0
      ],
      "end_point": [
        591,
        1
      ],
      "content": "static int\nvisit_locate02_format (struct process_data *procdata, void *context)\n{\n  register char *s;\n  int nread;\n  (void) context;\n\n  if (procdata->c == LOCATEDB_ESCAPE)\n    procdata->count += (short)get_short (procdata->fp);\n  else if (procdata->c > 127)\n    procdata->count += procdata->c - 256;\n  else\n    procdata->count += procdata->c;\n\n  if (procdata->count > procdata->len || procdata->count < 0)\n    {\n      /* This should not happen generally, but since we're\n       * reading in data which is outside our control, we\n       * cannot prevent it.\n       */\n      error (EXIT_FAILURE, 0, _(\"locate database %s is corrupt or invalid\"),\n             quotearg_n_style (0, locale_quoting_style, procdata->dbfile));\n    }\n\n  /* Overlay the old path with the remainder of the new.  */\n  nread = locate_read_str (&procdata->original_filename,\n                           &procdata->pathsize,\n                           procdata->fp, 0, procdata->count);\n  if (nread < 1)\n    return VISIT_ABORT;\n  procdata->c = getc (procdata->fp);\n  procdata->len = procdata->count + nread - 1; /* Number of chars in path. */\n\n  if (procdata->len < 1)\n    {\n      /* This should not happen generally, but since we're\n       * reading in data which is outside our control, we\n       * cannot prevent it.\n       */\n      error(1, 0, _(\"locate database %s is corrupt or invalid\"),\n            quotearg_n_style(0, locale_quoting_style, procdata->dbfile));\n    }\n\n  s = procdata->original_filename + procdata->len - 1; /* Move to the last char in path.  */\n  assert (s[0] != '\\0');\n  assert (s[1] == '\\0'); /* Our terminator.  */\n  assert (s[2] == '\\0'); /* Added by locate_read_str.  */\n\n  procdata->munged_filename = procdata->original_filename;\n\n  return VISIT_CONTINUE;\n}",
      "lines": 52,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "visit_basename": {
      "start_point": [
        593,
        0
      ],
      "end_point": [
        600,
        1
      ],
      "content": "static int\nvisit_basename (struct process_data *procdata, void *context)\n{\n  (void) context;\n  procdata->munged_filename = last_component (procdata->original_filename);\n\n  return VISIT_CONTINUE;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "visit_existing_follow": {
      "start_point": [
        604,
        0
      ],
      "end_point": [
        623,
        1
      ],
      "content": "static int\nvisit_existing_follow (struct process_data *procdata, void *context)\n{\n  struct stat st;\n  (void) context;\n\n  /* munged_filename has been converted in some way (to lower case,\n   * or is just the base name of the file), and original_filename has not.\n   * Hence only original_filename is still actually the name of the file\n   * whose existence we would need to check.\n   */\n  if (stat (procdata->original_filename, &st) != 0)\n    {\n      return VISIT_REJECTED;\n    }\n  else\n    {\n      return VISIT_CONTINUE;\n    }\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "visit_non_existing_follow": {
      "start_point": [
        626,
        0
      ],
      "end_point": [
        645,
        1
      ],
      "content": "static int\nvisit_non_existing_follow (struct process_data *procdata, void *context)\n{\n  struct stat st;\n  (void) context;\n\n  /* munged_filename has been converted in some way (to lower case,\n   * or is just the base name of the file), and original_filename has not.\n   * Hence only original_filename is still actually the name of the file\n   * whose existence we would need to check.\n   */\n  if (stat (procdata->original_filename, &st) == 0)\n    {\n      return VISIT_REJECTED;\n    }\n  else\n    {\n      return VISIT_CONTINUE;\n    }\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "visit_existing_nofollow": {
      "start_point": [
        648,
        0
      ],
      "end_point": [
        667,
        1
      ],
      "content": "static int\nvisit_existing_nofollow (struct process_data *procdata, void *context)\n{\n  struct stat st;\n  (void) context;\n\n  /* munged_filename has been converted in some way (to lower case,\n   * or is just the base name of the file), and original_filename has not.\n   * Hence only original_filename is still actually the name of the file\n   * whose existence we would need to check.\n   */\n  if (lstat (procdata->original_filename, &st) != 0)\n    {\n      return VISIT_REJECTED;\n    }\n  else\n    {\n      return VISIT_CONTINUE;\n    }\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "visit_non_existing_nofollow": {
      "start_point": [
        670,
        0
      ],
      "end_point": [
        689,
        1
      ],
      "content": "static int\nvisit_non_existing_nofollow (struct process_data *procdata, void *context)\n{\n  struct stat st;\n  (void) context;\n\n  /* munged_filename has been converted in some way (to lower case,\n   * or is just the base name of the file), and original_filename has not.\n   * Hence only original_filename is still actually the name of the file\n   * whose existence we would need to check.\n   */\n  if (lstat (procdata->original_filename, &st) == 0)\n    {\n      return VISIT_REJECTED;\n    }\n  else\n    {\n      return VISIT_CONTINUE;\n    }\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "visit_substring_match_nocasefold_wide": {
      "start_point": [
        691,
        0
      ],
      "end_point": [
        700,
        1
      ],
      "content": "static int\nvisit_substring_match_nocasefold_wide (struct process_data *procdata, void *context)\n{\n  const char *pattern = context;\n\n  if (NULL != mbsstr (procdata->munged_filename, pattern))\n    return VISIT_ACCEPTED;\n  else\n    return VISIT_REJECTED;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "visit_substring_match_nocasefold_narrow": {
      "start_point": [
        702,
        0
      ],
      "end_point": [
        711,
        1
      ],
      "content": "static int\nvisit_substring_match_nocasefold_narrow (struct process_data *procdata, void *context)\n{\n  const char *pattern = context;\n  assert (MB_CUR_MAX == 1);\n  if (NULL != strstr (procdata->munged_filename, pattern))\n    return VISIT_ACCEPTED;\n  else\n    return VISIT_REJECTED;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "visit_substring_match_casefold_wide": {
      "start_point": [
        713,
        0
      ],
      "end_point": [
        722,
        1
      ],
      "content": "static int\nvisit_substring_match_casefold_wide (struct process_data *procdata, void *context)\n{\n  const char *pattern = context;\n\n  if (NULL != mbscasestr (procdata->munged_filename, pattern))\n    return VISIT_ACCEPTED;\n  else\n    return VISIT_REJECTED;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "visit_substring_match_casefold_narrow": {
      "start_point": [
        725,
        0
      ],
      "end_point": [
        735,
        1
      ],
      "content": "static int\nvisit_substring_match_casefold_narrow (struct process_data *procdata, void *context)\n{\n  const char *pattern = context;\n\n  assert (MB_CUR_MAX == 1);\n  if (NULL != strcasestr (procdata->munged_filename, pattern))\n    return VISIT_ACCEPTED;\n  else\n    return VISIT_REJECTED;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "visit_globmatch_nofold": {
      "start_point": [
        738,
        0
      ],
      "end_point": [
        746,
        1
      ],
      "content": "static int\nvisit_globmatch_nofold (struct process_data *procdata, void *context)\n{\n  const char *glob = context;\n  if (fnmatch (glob, procdata->munged_filename, 0) != 0)\n    return VISIT_REJECTED;\n  else\n    return VISIT_ACCEPTED;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "visit_globmatch_casefold": {
      "start_point": [
        749,
        0
      ],
      "end_point": [
        757,
        1
      ],
      "content": "static int\nvisit_globmatch_casefold (struct process_data *procdata, void *context)\n{\n  const char *glob = context;\n  if (fnmatch (glob, procdata->munged_filename, FNM_CASEFOLD) != 0)\n    return VISIT_REJECTED;\n  else\n    return VISIT_ACCEPTED;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "visit_regex": {
      "start_point": [
        760,
        0
      ],
      "end_point": [
        777,
        1
      ],
      "content": "static int\nvisit_regex (struct process_data *procdata, void *context)\n{\n  struct regular_expression *p = context;\n  const size_t len = strlen (procdata->munged_filename);\n\n  int rv = re_search (&p->regex, procdata->munged_filename,\n                      len, 0, len,\n                      (struct re_registers *) NULL);\n  if (rv < 0)\n    {\n      return VISIT_REJECTED;    /* no match (-1), or internal error (-2) */\n    }\n  else\n    {\n      return VISIT_ACCEPTED;    /* match */\n    }\n}",
      "lines": 18,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "visit_stats": {
      "start_point": [
        780,
        0
      ],
      "end_point": [
        814,
        1
      ],
      "content": "static int\nvisit_stats (struct process_data *procdata, void *context)\n{\n  struct locate_stats *p = context;\n  size_t len = strlen (procdata->original_filename);\n  const char *s;\n  int highbit, whitespace, newline;\n\n  ++(p->total_filename_count);\n  p->total_filename_length += len;\n\n  highbit = whitespace = newline = 0;\n  for (s=procdata->original_filename; *s; ++s)\n    {\n      if ( (int)(*s) & 128 )\n        highbit = 1;\n      if ('\\n' == *s)\n        {\n          newline = whitespace = 1;\n        }\n      else if (isspace ((unsigned char)*s))\n        {\n          whitespace = 1;\n        }\n    }\n\n  if (highbit)\n    ++(p->highbit_filename_count);\n  if (whitespace)\n    ++(p->whitespace_count);\n  if (newline)\n    ++(p->newline_count);\n\n  return VISIT_CONTINUE;\n}",
      "lines": 35,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "visit_limit": {
      "start_point": [
        817,
        0
      ],
      "end_point": [
        828,
        1
      ],
      "content": "static int\nvisit_limit (struct process_data *procdata, void *context)\n{\n  struct locate_limits *p = context;\n\n  (void) procdata;\n\n  if (++p->items_accepted >= p->limit)\n    return VISIT_ABORT;\n  else\n    return VISIT_CONTINUE;\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "visit_count": {
      "start_point": [
        830,
        0
      ],
      "end_point": [
        839,
        1
      ],
      "content": "static int\nvisit_count (struct process_data *procdata, void *context)\n{\n  struct locate_limits *p = context;\n\n  (void) procdata;\n\n  ++p->items_accepted;\n  return VISIT_CONTINUE;\n}",
      "lines": 10,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "print_stats": {
      "start_point": [
        843,
        0
      ],
      "end_point": [
        924,
        1
      ],
      "content": "static void\nprint_stats (int argc, size_t database_file_size, const struct timespec* database_mtime)\n{\n  char hbuf1[LONGEST_HUMAN_READABLE + 1];\n  char hbuf2[LONGEST_HUMAN_READABLE + 1];\n  char hbuf3[LONGEST_HUMAN_READABLE + 1];\n  char hbuf4[LONGEST_HUMAN_READABLE + 1];\n\n  if (database_mtime)\n    {\n      const struct tm *ptm = localtime (&(database_mtime->tv_sec));\n      if (ptm)\n        {\n          enum { TIME_BUF_LEN = 20 };\n          char whenbuf[TIME_BUF_LEN];\n          size_t printed = strftime (whenbuf, TIME_BUF_LEN,\n                                     \"%Y:%m:%d %H:%M:%S\", ptm);\n          /* Ensure the buffer is exactly the right length. */\n          assert (printed == TIME_BUF_LEN-1);\n          assert (whenbuf[TIME_BUF_LEN-1] == 0);\n          assert (whenbuf[TIME_BUF_LEN-2] != 0);\n          printf (_(\"Database was last modified at %s.%09ld\"),\n                  whenbuf, (long int) database_mtime->tv_nsec);\n          printed = strftime (whenbuf, TIME_BUF_LEN, \"%z\", ptm);\n          assert (printed == 5);\n          printf(\" %s\\n\", whenbuf);\n        }\n    }\n\n  printf (ngettext (\"Locate database size: %s byte\\n\",\n                  \"Locate database size: %s bytes\\n\",\n                  database_file_size),\n         human_readable ((uintmax_t) database_file_size,\n                         hbuf1, human_ceiling, 1, 1));\n  printf ( (results_were_filtered ?\n           _(\"Matching Filenames: %s\\n\") :\n           _(\"All Filenames: %s\\n\")),\n          human_readable (statistics.total_filename_count,\n                         hbuf1, human_ceiling, 1, 1));\n  /* XXX: We would ideally use ngettext () here, but I don't know\n   *      how to use it to handle more than one possibly-plural thing/\n   */\n  printf (_(\"File names have a cumulative length of %s bytes.\\n\"\n           \"Of those file names,\\n\"\n           \"\\n\\t%s contain whitespace, \"\n           \"\\n\\t%s contain newline characters, \"\n           \"\\n\\tand %s contain characters with the high bit set.\\n\"),\n         human_readable (statistics.total_filename_length,  hbuf1, human_ceiling, 1, 1),\n         human_readable (statistics.whitespace_count,       hbuf2, human_ceiling, 1, 1),\n         human_readable (statistics.newline_count,          hbuf3, human_ceiling, 1, 1),\n         human_readable (statistics.highbit_filename_count, hbuf4, human_ceiling, 1, 1));\n\n  if (!argc)\n    {\n      if (results_were_filtered)\n        {\n          printf (_(\"Some filenames may have been filtered out, \"\n                   \"so we cannot compute the compression ratio.\\n\"));\n        }\n      else\n        {\n          if (statistics.total_filename_length)\n            {\n              /* A negative compression ratio just means that the\n               * compressed database is larger than the list of\n               * filenames.  This can happen for example for\n               * old-format databases containing a small list of short\n               * filenames, because the bigram list is 256 bytes.\n               */\n              printf (_(\"Compression ratio %4.2f%% (higher is better)\\n\"),\n                     100.0 * ((double)statistics.total_filename_length\n                              - (double) database_file_size)\n                     / (double) statistics.total_filename_length);\n            }\n          else\n            {\n              printf (_(\"Compression ratio is undefined\\n\"));\n            }\n        }\n    }\n  printf (\"\\n\");\n}",
      "lines": 82,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "looking_at_gnu_locatedb": {
      "start_point": [
        930,
        0
      ],
      "end_point": [
        939,
        1
      ],
      "content": "static int\nlooking_at_gnu_locatedb (const char *data, size_t len)\n{\n  if (len < sizeof (LOCATEDB_MAGIC))\n    return 0;\n  else if (0 == memcmp (data, LOCATEDB_MAGIC, sizeof (LOCATEDB_MAGIC)))\n    return 1;                   /* We saw the magic byte sequence */\n  else\n    return 0;\n}",
      "lines": 10,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "looking_at_slocate_locatedb": {
      "start_point": [
        945,
        0
      ],
      "end_point": [
        998,
        1
      ],
      "content": "static int\nlooking_at_slocate_locatedb (const char *filename,\n                             const char *data,\n                             size_t len,\n                             int *seclevel)\n{\n  assert (len <= 2);\n\n  if (len < 2)\n    {\n      return 0;\n    }\n  else\n    {\n      /* Check that the magic number is a one-byte string */\n      if (0 == data[1])\n        {\n          if (isdigit ((unsigned char)data[0]))\n            {\n              /* looks promising. */\n              *seclevel = (data[0] - '0');\n\n              if (*seclevel > 1)\n                {\n                  /* Hmm, well it's probably an slocate database\n                   * of some awsomely huge security level, like 2.\n                   * We don't know how to handle those.\n                   */\n                  error (0, 0,\n                         _(\"locate database %s looks like an slocate \"\n                           \"database but it seems to have security level %c, \"\n                           \"which GNU findutils does not currently support\"),\n                         quotearg_n_style (0, locale_quoting_style, filename),\n                         data[1]);\n                  return 1;\n                }\n              else\n                {\n                  return 1;\n                }\n            }\n          else\n            {\n              /* Not a digit. */\n              return 0;\n            }\n        }\n      else\n        {\n          /* Definitely not slocate. */\n          return 0;\n        }\n    }\n}",
      "lines": 54,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "i_am_little_endian": {
      "start_point": [
        1001,
        0
      ],
      "end_point": [
        1013,
        1
      ],
      "content": "static int\ni_am_little_endian (void)\n{\n  union\n  {\n    unsigned char uch[4];\n    unsigned int ui;\n  } u;\n  u.ui = 0u;\n  u.uch[0] = 1;\n  u.uch[1] = u.uch[2] = u.uch[3] = 0;\n  return u.ui == 1;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "search_one_database": {
      "start_point": [
        1021,
        0
      ],
      "end_point": [
        1376,
        1
      ],
      "content": "static unsigned long\nsearch_one_database (int argc,\n                     char **argv,\n                     const char *dbfile,\n                     FILE *fp,\n                     off_t filesize,\n                     const struct timespec *database_mtime,\n                     int ignore_case,\n                     int enable_print,\n                     int basename_only,\n                     int use_limit,\n                     struct locate_limits *plimit,\n                     int stats,\n                     int op_and,\n                     int regex,\n                     int regex_options)\n{\n  char *pathpart;               /* A pattern to consider. */\n  int argn;                     /* Index to current pattern in argv. */\n  int nread;                 /* number of bytes read from an entry. */\n  struct process_data procdata; /* Storage for data shared with visitors. */\n  int slocate_seclevel;\n  int oldformat;\n  int slocatedb_format;\n  struct visitor* pvis; /* temp for determining past_pat_inspector. */\n  const char *format_name;\n  enum ExistenceCheckType do_check_existence;\n\n\n  /* We may turn on existence checking for a given database.\n   * We ensure that we can return to the previous behaviour\n   * by using two variables, do_check_existence (which we act on)\n   * and check_existence (which indicates the default before we\n   * adjust it on the bassis of what kind of database we;re using\n   */\n  do_check_existence = check_existence;\n\n\n  if (ignore_case)\n    regex_options |= RE_ICASE;\n\n  oldformat = 0;\n  procdata.endian_state = GetwordEndianStateInitial;\n  procdata.len = procdata.count = 0;\n\n  procdata.dbfile = dbfile;\n  procdata.fp = fp;\n\n  /* Set up the inspection regime */\n  inspectors = NULL;\n  lastinspector = NULL;\n  past_pat_inspector = NULL;\n  results_were_filtered = false;\n  procdata.pathsize = 128;      /* Increased as necessary by locate_read_str.  */\n  procdata.original_filename = xmalloc (procdata.pathsize);\n\n\n  nread = fread (procdata.original_filename, 1, SLOCATE_DB_MAGIC_LEN,\n                 procdata.fp);\n  slocate_seclevel = 0;\n  if (looking_at_slocate_locatedb (procdata.dbfile,\n                                   procdata.original_filename,\n                                   nread,\n                                   &slocate_seclevel))\n    {\n      error (0, 0,\n             _(\"%s is an slocate database.  \"\n               \"Support for these is new, expect problems for now.\"),\n             quotearg_n_style (0, locale_quoting_style, procdata.dbfile));\n\n      /* slocate also uses frcode, but with a different header.\n       * We handle the header here and then work with the data\n       * in the normal way.\n       */\n      if (slocate_seclevel > 1)\n        {\n          /* We don't know what those security levels mean,\n           * so do nothing further\n           */\n          error (0, 0,\n                 _(\"%s is an slocate database of unsupported security level %d; skipping it.\"),\n                 quotearg_n_style (0, locale_quoting_style, procdata.dbfile),\n                 slocate_seclevel);\n          return 0;\n        }\n      else if (slocate_seclevel > 0)\n        {\n          /* Don't show the filenames to the user if they don't exist.\n           * Showing stats is safe since filenames are only counted\n           * after the existence check\n           */\n          if (ACCEPT_NON_EXISTING == check_existence)\n            {\n              /* Do not allow the user to see a list of filenames that they\n               * cannot stat().\n               */\n              error (0, 0,\n                     _(\"You specified the -E option, but that option \"\n                       \"cannot be used with slocate-format databases \"\n                       \"with a non-zero security level.  No results will be \"\n                       \"generated for this database.\\n\"));\n              return 0;\n            }\n          if (ACCEPT_EXISTING != do_check_existence)\n            {\n              if (enable_print || stats)\n                {\n                  error (0, 0,\n                         _(\"%s is an slocate database.  \"\n                           \"Turning on the '-e' option.\"),\n                         quotearg_n_style (0, locale_quoting_style, procdata.dbfile));\n                }\n              do_check_existence = ACCEPT_EXISTING;\n            }\n        }\n      add_visitor (visit_locate02_format, NULL);\n      format_name = \"slocate\";\n      slocatedb_format = 1;\n    }\n  else\n    {\n      int nread2;\n\n      slocatedb_format = 0;\n      extend (&procdata, sizeof (LOCATEDB_MAGIC), 0u);\n      nread2 = fread (procdata.original_filename+nread, 1, sizeof (LOCATEDB_MAGIC)-nread,\n                      procdata.fp);\n      if (looking_at_gnu_locatedb (procdata.original_filename, nread+nread2))\n        {\n          add_visitor (visit_locate02_format, NULL);\n          format_name = \"GNU LOCATE02\";\n        }\n      else                              /* Use the old format */\n        {\n          int i;\n\n          nread += nread2;\n          extend (&procdata, 256u, 0u);\n          /* Read the list of the most common bigrams in the database.  */\n          if (nread < 256)\n            {\n              int more_read = fread (procdata.original_filename + nread, 1,\n                                     256 - nread, procdata.fp);\n              if ( (more_read + nread) != 256 )\n                {\n                  error (EXIT_FAILURE, 0,\n                         _(\"Old-format locate database %s is \"\n                           \"too short to be valid\"),\n                         quotearg_n_style (0, locale_quoting_style, dbfile));\n\n                }\n            }\n\n          for (i = 0; i < 128; i++)\n            {\n              procdata.bigram1[i] = procdata.original_filename[i << 1];\n              procdata.bigram2[i] = procdata.original_filename[(i << 1) + 1];\n            }\n          format_name = \"old\";\n          oldformat = 1;\n          add_visitor (visit_old_format, NULL);\n        }\n    }\n\n  if (basename_only)\n    add_visitor (visit_basename, NULL);\n\n  /* Add an inspector for each pattern we're looking for. */\n  for ( argn = 0; argn < argc; argn++ )\n    {\n      results_were_filtered = true;\n      pathpart = argv[argn];\n      if (regex)\n        {\n          struct regular_expression *p = xmalloc (sizeof (*p));\n          const char *error_message = NULL;\n\n          memset (&p->regex, 0, sizeof (p->regex));\n\n          re_set_syntax (regex_options);\n          p->regex.allocated = 100;\n          p->regex.buffer = xmalloc (p->regex.allocated);\n          p->regex.fastmap = NULL;\n          p->regex.syntax = regex_options;\n          p->regex.translate = NULL;\n\n          error_message = re_compile_pattern (pathpart, strlen (pathpart),\n                                              &p->regex);\n          if (error_message)\n            {\n              error (EXIT_FAILURE, 0, \"%s\", error_message);\n            }\n          else\n            {\n              add_visitor (visit_regex, p);\n            }\n        }\n      else if (contains_metacharacter (pathpart))\n        {\n          if (ignore_case)\n            add_visitor (visit_globmatch_casefold, pathpart);\n          else\n            add_visitor (visit_globmatch_nofold, pathpart);\n        }\n      else\n        {\n          /* No glob characters used.  Hence we match on\n           * _any part_ of the filename, not just the\n           * basename.  This seems odd to me, but it is the\n           * traditional behaviour.\n           * James Youngman <jay@gnu.org>\n           */\n          visitfunc matcher;\n          if (1 == MB_CUR_MAX)\n            {\n              /* As an optimisation, use a strstr () matcher if we are\n               * in a unibyte locale.  This can give a x2 speedup in\n               * the C locale.  Some light testing reveals that\n               * glibc's strstr () is somewhere around 40% faster than\n               * gnulib's, so we just use strstr ().\n               */\n              matcher = ignore_case ?\n                visit_substring_match_casefold_narrow  :\n                visit_substring_match_nocasefold_narrow;\n            }\n          else\n            {\n              matcher = ignore_case ?\n                visit_substring_match_casefold_wide  :\n                visit_substring_match_nocasefold_wide;\n            }\n          add_visitor (matcher, pathpart);\n        }\n    }\n\n  pvis = lastinspector;\n\n  /* We add visit_existing_*() as late as possible to reduce the\n   * number of stat() calls.\n   */\n  switch (do_check_existence)\n    {\n      case ACCEPT_EXISTING:\n        results_were_filtered = true;\n        if (follow_symlinks)    /* -L, default */\n          add_visitor (visit_existing_follow, NULL);\n        else                    /* -P */\n          add_visitor (visit_existing_nofollow, NULL);\n        break;\n\n      case ACCEPT_NON_EXISTING:\n        results_were_filtered = true;\n        if (follow_symlinks)    /* -L, default */\n          add_visitor (visit_non_existing_follow, NULL);\n        else                    /* -P */\n          add_visitor (visit_non_existing_nofollow, NULL);\n        break;\n\n      case ACCEPT_EITHER:       /* Default, neither -E nor -e */\n        /* do nothing; no extra processing. */\n        break;\n    }\n\n  /* Security issue: The stats visitor must be added immediately\n   * before the print visitor, because otherwise the -S option would\n   * leak information about files that the caller cannot see.\n   */\n  if (stats)\n    add_visitor (visit_stats, &statistics);\n\n  if (enable_print)\n    {\n      if (print_quoted_filename)\n        add_visitor (visit_justprint_quoted,   NULL);\n      else\n        add_visitor (visit_justprint_unquoted, NULL);\n    }\n\n\n  if (use_limit)\n    add_visitor (visit_limit, plimit);\n  else\n    add_visitor (visit_count, plimit);\n\n\n  if (argc > 1)\n    {\n      past_pat_inspector = pvis->next;\n      if (op_and)\n        mainprocessor = process_and;\n      else\n        mainprocessor = process_or;\n    }\n  else\n    mainprocessor = process_simple;\n\n  if (stats)\n    {\n      printf (_(\"Database %s is in the %s format.\\n\"),\n              procdata.dbfile,\n              format_name);\n    }\n\n\n  procdata.c = getc (procdata.fp);\n  if (slocatedb_format  && (procdata.c != EOF))\n    {\n      /* Make slocate database look like GNU locate database. */\n      ungetc(procdata.c, procdata.fp);\n      procdata.c = 0;\n    }\n  /* If we are searching for filename patterns, the inspector list\n   * will contain an entry for each pattern for which we are searching.\n   */\n  while ( (procdata.c != EOF) &&\n          (VISIT_ABORT != (mainprocessor)(&procdata)) )\n    {\n      /* Do nothing; all the work is done in the visitor functions. */\n    }\n\n  if (stats)\n    {\n      if (oldformat)\n        {\n          int host_little_endian = i_am_little_endian ();\n          const char *little = _(\"The database has little-endian \"\n                                 \"machine-word encoding.\\n\");\n          const char *big    = _(\"The database has big-endian \"\n                                 \"machine-word encoding.\\n\");\n\n          if (GetwordEndianStateNative == procdata.endian_state)\n            {\n              printf (\"%s\", (host_little_endian ? little : big));\n            }\n          else if (GetwordEndianStateSwab == procdata.endian_state)\n            {\n              printf (\"%s\", (host_little_endian ? big : little));\n            }\n          else\n            {\n              printf (_(\"The database machine-word encoding order \"\n                       \"is not obvious.\\n\"));\n            }\n        }\n      if (filesize || (database_mtime != NULL))\n        print_stats (argc, filesize, database_mtime);\n    }\n\n  if (ferror (procdata.fp))\n    {\n      error (0, errno, \"%s\",\n             quotearg_n_style (0, locale_quoting_style, procdata.dbfile));\n      return 0;\n    }\n  return plimit->items_accepted;\n}",
      "lines": 356,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "unsigned long",
        "unsigned",
        "long"
      ]
    },
    "usage": {
      "start_point": [
        1381,
        0
      ],
      "end_point": [
        1394,
        1
      ],
      "content": "static void\nusage (FILE *stream)\n{\n  fprintf (stream, _(\"\\\nUsage: %s [-d path | --database=path] [-e | -E | --[non-]existing]\\n\\\n      [-i | --ignore-case] [-w | --wholename] [-b | --basename] \\n\\\n      [--limit=N | -l N] [-S | --statistics] [-0 | --null] [-c | --count]\\n\\\n      [-P | -H | --nofollow] [-L | --follow] [-m | --mmap] [-s | --stdio]\\n\\\n      [-A | --all] [-p | --print] [-r | --regex] [--regextype=TYPE]\\n\\\n      [--max-database-age D] [--version] [--help]\\n\\\n      pattern...\\n\"),\n           program_name);\n  fputs (_(\"\\nReport bugs to <bug-findutils@gnu.org>.\\n\"), stream);\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "drop_privs": {
      "start_point": [
        1430,
        0
      ],
      "end_point": [
        1516,
        1
      ],
      "content": "static int\ndrop_privs (void)\n{\n  const char * what = \"failed\";\n  const uid_t orig_euid = geteuid ();\n  const uid_t uid       = getuid ();\n  const gid_t gid       = getgid ();\n\n#if HAVE_SETGROUPS\n  /* Use of setgroups () is restricted to root only. */\n  if (0 == orig_euid)\n    {\n      /* We're either root or running setuid-root. */\n      gid_t groups[1];\n      groups[0] = gid;\n      if (0 != setgroups (1u, groups))\n        {\n          what = _(\"failed to drop group privileges\");\n          goto fail;\n        }\n    }\n#endif\n\n  /* Drop any setuid privileges */\n  if (uid != orig_euid)\n    {\n      if (0 == uid)\n        {\n          /* We're really root anyway, but are setuid to something else. Leave it. */\n        }\n      else\n        {\n          errno = 0;\n          if (0 != setuid (getuid ()))\n            {\n              what = _(\"failed to drop setuid privileges\");\n              goto fail;\n            }\n\n          /* Defend against the case where the attacker runs us with the\n           * capability to call setuid () turned off, which on some systems\n           * will cause the above attempt to drop privileges fail (leaving us\n           * privileged).\n           */\n          else\n            {\n              /* Check that we can no longer switch bask to root */\n              if (0 == setuid (0))\n                {\n                  what = _(\"Failed to fully drop privileges\");\n                  /* The errno value here is not interesting (since\n                   * the system call we are complaining about\n                   * succeeded when we wanted it to fail).  Arrange\n                   * for the call to error () not to print the errno\n                   * value by setting errno=0.\n                   */\n                  errno = 0;\n                  goto fail;\n                }\n            }\n        }\n    }\n\n  /* Drop any setgid privileges */\n  errno = 0;\n  if (0 != setgid (gid))\n    {\n      what = _(\"failed to drop setgid privileges\");\n      goto fail;\n    }\n\n  /* success. */\n  return 0;\n\n fail:\n  error (EXIT_FAILURE, errno, \"%s\",\n         quotearg_n_style (0, locale_quoting_style, what));\n  abort ();\n  kill (0, SIGKILL);\n  _exit (1);\n  /*NOTREACHED*/\n  /* ... we hope. */\n  for (;;)\n    {\n      /* deliberate infinite loop */\n    }\n}",
      "lines": 87,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "opendb": {
      "start_point": [
        1518,
        0
      ],
      "end_point": [
        1536,
        1
      ],
      "content": "static int\nopendb (const char *name)\n{\n  int fd = open (name, O_RDONLY\n#if defined O_LARGEFILE\n                |O_LARGEFILE\n#endif\n                );\n  if (fd >= 0)\n    {\n      /* Make sure it won't survive an exec */\n      if (0 != fcntl (fd, F_SETFD, FD_CLOEXEC))\n        {\n          close (fd);\n          fd = -1;\n        }\n    }\n  return fd;\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cleanup_quote_opts": {
      "start_point": [
        1538,
        0
      ],
      "end_point": [
        1542,
        1
      ],
      "content": "static void\ncleanup_quote_opts (void)\n{\n  free (quote_opts);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "dolocate": {
      "start_point": [
        1545,
        0
      ],
      "end_point": [
        1922,
        1
      ],
      "content": "int\ndolocate (int argc, char **argv, int secure_db_fd)\n{\n  char *path_element = NULL;\n  size_t path_element_pos, path_element_len;\n  const char *user_selected_locate_path;\n  const char *db_name;\n  const char *path_separators = \":\";\n  unsigned long int found = 0uL;\n  int ignore_case = 0;\n  int print = 0;\n  int just_count = 0;\n  int basename_only = 0;\n  int use_limit = 0;\n  int regex = 0;\n  int regex_options = RE_SYNTAX_EMACS;\n  int stats = 0;\n  int op_and = 0;\n  FILE *fp;\n  bool did_stdin = false;       /* Set to prevent rereading stdin. */\n\n  if (argv[0])\n    set_program_name (argv[0]);\n  else\n    set_program_name (\"locate\");\n\n#ifdef HAVE_SETLOCALE\n  setlocale (LC_ALL, \"\");\n#endif\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  quote_opts = clone_quoting_options (NULL);\n  if (atexit (close_stdout) || atexit (cleanup_quote_opts))\n    {\n      error (EXIT_FAILURE, errno, _(\"The atexit library function failed\"));\n    }\n\n  limits.limit = 0;\n  limits.items_accepted = 0;\n\n  print_quoted_filename = true;\n\n  /* We cannot simultaneously trust $LOCATE_PATH and use the\n   * setuid-access-controlled database,, since that could cause a leak\n   * of private data.\n   */\n  user_selected_locate_path = getenv (\"LOCATE_PATH\");\n\n  check_existence = ACCEPT_EITHER;\n\n  for (;;)\n    {\n      int opti = -1;\n      int optc = getopt_long (argc, argv, \"Abcd:eEil:prsm0SwHPL\", longopts,\n                              &opti);\n      if (optc == -1)\n        break;\n\n      switch (optc)\n        {\n        case '0':\n          separator = 0;\n          print_quoted_filename = false; /* print filename 'raw'. */\n          break;\n\n        case 'A':\n          op_and = 1;\n          break;\n\n        case 'b':\n          basename_only = 1;\n          break;\n\n        case 'c':\n          just_count = 1;\n          break;\n\n        case 'd':\n          user_selected_locate_path = optarg;\n          assert (optarg != NULL);\n          break;\n\n        case 'e':\n          check_existence = ACCEPT_EXISTING;\n          break;\n\n        case 'E':\n          check_existence = ACCEPT_NON_EXISTING;\n          break;\n\n        case 'i':\n          ignore_case = 1;\n          break;\n\n        case 'h':\n          usage (stdout);\n          return 0;\n\n        case MAX_DB_AGE:\n          /* XXX: nothing in the test suite for this option. */\n          set_max_db_age (optarg);\n          break;\n\n        case 'p':\n          print = 1;\n          break;\n\n        case 'v':\n          display_findutils_version (\"locate\");\n          return 0;\n\n        case 'w':\n          basename_only = 0;\n          break;\n\n        case 'r':\n          regex = 1;\n          break;\n\n        case REGEXTYPE_OPTION:\n          regex_options = get_regex_type (optarg);\n          break;\n\n        case 'S':\n          stats = 1;\n          break;\n\n        case 'L':\n          follow_symlinks = 1;\n          break;\n\n          /* In find, -P and -H differ in the way they handle paths\n           * given on the command line.  This is not relevant for\n           * locate, but the -H option is supported because it is\n           * probably more intuitive to do so.\n           */\n        case 'P':\n        case 'H':\n          follow_symlinks = 0;\n          break;\n\n        case 'l':\n          {\n            char *end = optarg;\n            strtol_error err = xstrtoumax (optarg, &end, 10, &limits.limit,\n                                           NULL);\n            if (LONGINT_OK != err)\n              xstrtol_fatal (err, opti, optc, longopts, optarg);\n            use_limit = 1;\n          }\n          break;\n\n        case 's':                       /* use stdio */\n        case 'm':                       /* use mmap  */\n          /* These options are implemented simply for\n           * compatibility with FreeBSD\n           */\n          break;\n\n        default:\n          usage (stderr);\n          return 1;\n        }\n    }\n\n\n  /* If the user gave the -d option or set LOCATE_PATH,\n   * relinquish access to the secure database.\n   */\n  if (user_selected_locate_path)\n    {\n      if (secure_db_fd >= 0)\n        {\n          close (secure_db_fd);\n          secure_db_fd = -1;\n        }\n    }\n\n  if (!just_count && !stats)\n    print = 1;\n\n  if (stats)\n    {\n      if (optind == argc)\n        use_limit = 0;\n    }\n  else\n    {\n      if (!just_count && optind == argc)\n        {\n          usage (stderr);\n          return 1;\n        }\n    }\n\n  if (1 == isatty (STDOUT_FILENO))\n    stdout_is_a_tty = true;\n  else\n    stdout_is_a_tty = false;\n\n  if (user_selected_locate_path)\n    {\n      splitstring (user_selected_locate_path, path_separators, true,\n                   &path_element_pos, &path_element_len);\n    }\n\n  /* Bail out early if limit already reached. */\n  while (!use_limit || limits.limit > limits.items_accepted)\n    {\n      struct stat st;\n      struct timespec database_mtime;\n      int have_mtime;\n      int fd;\n      off_t filesize;\n\n      statistics.compressed_bytes =\n      statistics.total_filename_count =\n      statistics.total_filename_length =\n      statistics.whitespace_count =\n      statistics.newline_count =\n      statistics.highbit_filename_count = 0u;\n\n      if (user_selected_locate_path)\n        {\n          /* Take the next element from the list of databases */\n          if (1 == path_element_len\n              && '-' == user_selected_locate_path[path_element_pos])\n            {\n              if (did_stdin)\n                {\n                  error (0, 0,\n                         _(\"warning: the locate database can only be read from stdin once.\"));\n                  return 0;\n                }\n              else\n                {\n                  db_name = \"<stdin>\";\n                  fd = 0;\n                  did_stdin = true;\n                }\n            }\n          else\n            {\n              if (0 == path_element_len\n                  || (1 == path_element_len\n                      && '.' == user_selected_locate_path[path_element_pos]))\n                {\n                  db_name = LOCATE_DB;\n                }\n              else\n                {\n                  path_element = strndup (&user_selected_locate_path[path_element_pos],\n                                          path_element_len);\n                  db_name = path_element;\n                }\n\n              /* open the database */\n              fd = opendb (db_name);\n              if (fd < 0)\n                {\n                  error (0, errno, \"%s\",\n                         quotearg_n_style (0, locale_quoting_style, db_name));\n                  return 0;\n                }\n            }\n        }\n      else\n        {\n          if (-1 == secure_db_fd)\n            {\n              /* Already searched the database, it's time to exit the loop */\n              break;\n            }\n          else\n            {\n              db_name = selected_secure_db;\n              fd = secure_db_fd;\n              secure_db_fd = -1;\n            }\n        }\n\n      /* Check the database to see if it is old. */\n      if (fstat (fd, &st))\n        {\n          error (0, errno, \"%s\",\n                 quotearg_n_style (0, locale_quoting_style, db_name));\n          /* continue anyway */\n          filesize = (off_t)0;\n          have_mtime = 0;\n        }\n      else\n        {\n          time_t now;\n\n          filesize = st.st_size;\n          database_mtime = get_stat_mtime(&st);\n          have_mtime = 1;\n\n          if ((time_t)-1 == time (&now))\n            {\n              /* If we can't tell the time, we don't know how old the\n               * database is.  But since the message is just advisory,\n               * we continue anyway.\n               */\n              error (0, errno, _(\"time system call failed\"));\n            }\n          else\n            {\n              double age          = difftime (now, st.st_mtime);\n              double warn_seconds = SECONDS_PER_UNIT * warn_number_units;\n              if (age > warn_seconds)\n                {\n                  /* For example:\n                     warning: database `fred' is more than 8 days old (actual age is 10 days)*/\n                  error (0, 0,\n                         _(\"warning: database %s is more than %d %s old (actual age is %.1f %s)\"),\n                         quotearg_n_style (0,  locale_quoting_style, db_name),\n                         warn_number_units,              _(warn_name_units),\n                         (age/(double)SECONDS_PER_UNIT), _(warn_name_units));\n                }\n            }\n        }\n\n      fp = fdopen (fd, \"r\");\n      if (NULL == fp)\n        {\n          error (0, errno, \"%s\",\n                 quotearg_n_style (0, locale_quoting_style, db_name));\n          return 0;\n        }\n\n      /* Search this database for all patterns simultaneously */\n      found = search_one_database (argc - optind, &argv[optind],\n                                   db_name, fp, filesize,\n                                   have_mtime ? (&database_mtime) : NULL,\n                                   ignore_case, print, basename_only,\n                                   use_limit, &limits, stats,\n                                   op_and, regex, regex_options);\n\n      /* Close the databsase (even if it is stdin) */\n      if (fclose (fp) == EOF)\n        {\n          error (0, errno, \"%s\",\n                 quotearg_n_style (0, locale_quoting_style, db_name));\n          return 0;\n        }\n       if (path_element)\n        {\n          free (path_element);\n          path_element = NULL;\n        }\n\n       if (!user_selected_locate_path)\n         {\n           /* We're not actually iterating through the values in\n              $LOCATE_PATH so we don't want to check for the next\n              element in user_selected_locate_path (since we manually set db_name =\n              LOCATE_DB without using user_selected_locate_path). */\n           break;\n         }\n       else if (!splitstring (user_selected_locate_path, path_separators, false,\n                              &path_element_pos, &path_element_len))\n         {\n           break;\n         }\n    }\n\n  if (just_count)\n    {\n      printf (\"%ld\\n\", found);\n    }\n\n  if (found || (use_limit && (limits.limit==0)) || stats )\n    return 0;\n  else\n    return 1;\n}",
      "lines": 378,
      "depth": 18,
      "decorators": [
        "int"
      ]
    },
    "open_secure_db": {
      "start_point": [
        1925,
        0
      ],
      "end_point": [
        1946,
        1
      ],
      "content": "static int\nopen_secure_db (void)\n{\n  int fd, i;\n\n  const char * secure_db_list[] =\n    {\n      LOCATE_DB,\n      \"/var/lib/slocate/slocate.db\",\n      NULL\n    };\n  for (i=0; secure_db_list[i]; ++i)\n    {\n      fd = opendb (secure_db_list[i]);\n      if (fd >= 0)\n        {\n          selected_secure_db = secure_db_list[i];\n          return fd;\n        }\n    }\n  return -1;\n}",
      "lines": 22,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        1948,
        0
      ],
      "end_point": [
        1955,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  int dbfd = open_secure_db ();\n  drop_privs ();\n\n  return dolocate (argc, argv, dbfd);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/locate/locatedb.h": {},
  "findutils/findutils-4.6.0/locate/word_io.c": {
    "decode_value": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        120,
        1
      ],
      "content": "static int\ndecode_value (const unsigned char data[],\n\t      int limit,\n\t      GetwordEndianState *endian_state_flag,\n\t      const char *filename)\n{\n  int swapped;\n  union\n  {\n    int ival;\t\t\t/* native representation */\n    unsigned char data[WORDBYTES];\n  } u;\n  u.ival = 0;\n  memcpy (&u.data, data, WORDBYTES);\n  swapped = bswap_32(u.ival);\t/* byteswapped */\n\n  if (*endian_state_flag == GetwordEndianStateInitial)\n    {\n      if (u.ival <= limit)\n\t{\n\t  if (swapped > limit)\n\t    {\n\t      /* the native value is inside the limit and the\n\t       * swapped value is not.  We take this as proof\n\t       * that we should be using the ative byte order.\n\t       */\n\t      *endian_state_flag = GetwordEndianStateNative;\n\t    }\n\t  return u.ival;\n\t}\n      else\n\t{\n\t  if (swapped <= limit)\n\t    {\n\t      /* Aha, now we know we have to byte-swap. */\n\t      error (0, 0,\n\t\t     _(\"WARNING: locate database %s was \"\n\t\t       \"built with a different byte order\"),\n\t\t     quotearg_n_style (0, locale_quoting_style, filename));\n\t      *endian_state_flag = GetwordEndianStateSwab;\n\t      return swapped;\n\t    }\n\t  else\n\t    {\n\t      /* u.ival > limit and swapped > limit.  For the moment, assume\n\t       * native ordering.\n\t       */\n\t      return u.ival;\n\t    }\n\t}\n    }\n  else\n    {\n      /* We already know the byte order. */\n      if (*endian_state_flag == GetwordEndianStateSwab)\n\treturn swapped;\n      else\n\treturn u.ival;\n    }\n}",
      "lines": 60,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "getword": {
      "start_point": [
        124,
        0
      ],
      "end_point": [
        154,
        1
      ],
      "content": "int\ngetword (FILE *fp,\n\t const char *filename,\n\t size_t minvalue,\n\t size_t maxvalue,\n\t GetwordEndianState *endian_state_flag)\n{\n  unsigned char data[4];\n  size_t bytes_read;\n\n  clearerr (fp);\n  bytes_read = fread (data, WORDBYTES, 1, fp);\n  if (bytes_read != 1)\n    {\n      const char * quoted_name = quotearg_n_style (0, locale_quoting_style,\n\t\t\t\t\t\t   filename);\n      /* Distinguish between a truncated database and an I/O error.\n       * Either condition is fatal.\n       */\n      if (feof (fp))\n\terror (EXIT_FAILURE, 0, _(\"unexpected EOF in %s\"), quoted_name);\n      else\n\terror (EXIT_FAILURE, errno,\n\t       _(\"error reading a word from %s\"), quoted_name);\n      abort ();\n    }\n  else\n    {\n      return decode_value (data, maxvalue, endian_state_flag, filename);\n    }\n}",
      "lines": 31,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "putword": {
      "start_point": [
        157,
        0
      ],
      "end_point": [
        177,
        1
      ],
      "content": "bool\nputword (FILE *fp, int word,\n\t GetwordEndianState endian_state_flag)\n{\n  size_t items_written;\n\n  /* You must decide before calling this function which\n   * endianness you want to use.\n   */\n  assert (endian_state_flag != GetwordEndianStateInitial);\n  if (GetwordEndianStateSwab == endian_state_flag)\n    {\n      word = bswap_32(word);\n    }\n\n  items_written = fwrite (&word, sizeof (word), 1, fp);\n  if (1 == items_written)\n    return true;\n  else\n    return false;\n}",
      "lines": 21,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/accept.c": {
    "rpl_accept": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "int\nrpl_accept (int fd, struct sockaddr *addr, socklen_t *addrlen)\n{\n  SOCKET sock = FD_TO_SOCKET (fd);\n\n  if (sock == INVALID_SOCKET)\n    {\n      errno = EBADF;\n      return -1;\n    }\n  else\n    {\n      SOCKET fh = accept (sock, addr, addrlen);\n      if (fh == INVALID_SOCKET)\n        {\n          set_winsock_errno ();\n          return -1;\n        }\n      else\n        return SOCKET_TO_FD (fh);\n    }\n}",
      "lines": 22,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/anytostr.c": {
    "__attribute_warn_unused_result__": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "char * __attribute_warn_unused_result__\nanytostr (inttype i, char *buf)\n{\n  char *p = buf + INT_STRLEN_BOUND (inttype);\n  *p = 0;\n\n  if (i < 0)\n    {\n      do\n        *--p = '0' - i % 10;\n      while ((i /= 10) != 0);\n\n      *--p = '-';\n    }\n  else\n    {\n      do\n        *--p = '0' + i % 10;\n      while ((i /= 10) != 0);\n    }\n\n  return p;\n}",
      "lines": 23,
      "depth": 10,
      "decorators": [
        "char",
        "* __attribute_warn_unused_result__\nanytostr (inttype i, char *buf)",
        "*"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/arpa_inet.in.h": {},
  "findutils/findutils-4.6.0/tests/at-func.c": {
    "AT_FUNC_NAME": {
      "start_point": [
        68,
        0
      ],
      "end_point": [
        142,
        1
      ],
      "content": "FUNC_RESULT\nAT_FUNC_NAME (int fd, char const *file AT_FUNC_POST_FILE_PARAM_DECLS)\n{\n  VALIDATE_FLAG (flag);\n\n  if (fd == AT_FDCWD || IS_ABSOLUTE_FILE_NAME (file))\n    return CALL_FUNC (file);\n\n#ifdef GNULIB_SUPPORT_ONLY_AT_FDCWD\n  errno = ENOTSUP;\n  return FUNC_FAIL;\n#else\n  {\n  /* Be careful to choose names unlikely to conflict with\n     AT_FUNC_POST_FILE_PARAM_DECLS.  */\n  struct saved_cwd saved_cwd;\n  int saved_errno;\n  FUNC_RESULT err;\n\n  {\n    char proc_buf[OPENAT_BUFFER_SIZE];\n    char *proc_file = openat_proc_name (proc_buf, fd, file);\n    if (proc_file)\n      {\n        FUNC_RESULT proc_result = CALL_FUNC (proc_file);\n        int proc_errno = errno;\n        if (proc_file != proc_buf)\n          free (proc_file);\n        /* If the syscall succeeds, or if it fails with an unexpected\n           errno value, then return right away.  Otherwise, fall through\n           and resort to using save_cwd/restore_cwd.  */\n        if (FUNC_FAIL != proc_result)\n          return proc_result;\n        if (! EXPECTED_ERRNO (proc_errno))\n          {\n            errno = proc_errno;\n            return proc_result;\n          }\n      }\n  }\n\n  if (save_cwd (&saved_cwd) != 0)\n    openat_save_fail (errno);\n  if (0 <= fd && fd == saved_cwd.desc)\n    {\n      /* If saving the working directory collides with the user's\n         requested fd, then the user's fd must have been closed to\n         begin with.  */\n      free_cwd (&saved_cwd);\n      errno = EBADF;\n      return FUNC_FAIL;\n    }\n\n  if (fchdir (fd) != 0)\n    {\n      saved_errno = errno;\n      free_cwd (&saved_cwd);\n      errno = saved_errno;\n      return FUNC_FAIL;\n    }\n\n  err = CALL_FUNC (file);\n  saved_errno = (err == FUNC_FAIL ? errno : 0);\n\n  if (restore_cwd (&saved_cwd) != 0)\n    openat_restore_fail (errno);\n\n  free_cwd (&saved_cwd);\n\n  if (saved_errno)\n    errno = saved_errno;\n  return err;\n  }\n#endif\n}",
      "lines": 75,
      "depth": 14,
      "decorators": [
        "FUNC_RESULT"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/binary-io.c": {},
  "findutils/findutils-4.6.0/tests/binary-io.h": {
    "set_binary_mode": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "BINARY_IO_INLINE int\nset_binary_mode (int fd, int mode)\n{\n  (void) fd;\n  (void) mode;\n  return O_BINARY;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "BINARY_IO_INLINE",
        "int",
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/bind.c": {
    "rpl_bind": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "int\nrpl_bind (int fd, const struct sockaddr *sockaddr, socklen_t len)\n{\n  SOCKET sock = FD_TO_SOCKET (fd);\n\n  if (sock == INVALID_SOCKET)\n    {\n      errno = EBADF;\n      return -1;\n    }\n  else\n    {\n      int r = bind (sock, sockaddr, len);\n      if (r < 0)\n        set_winsock_errno ();\n\n      return r;\n    }\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/connect.c": {
    "rpl_connect": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "int\nrpl_connect (int fd, const struct sockaddr *sockaddr, socklen_t len)\n{\n  SOCKET sock = FD_TO_SOCKET (fd);\n\n  if (sock == INVALID_SOCKET)\n    {\n      errno = EBADF;\n      return -1;\n    }\n  else\n    {\n      int r = connect (sock, sockaddr, len);\n      if (r < 0)\n        {\n          /* EINPROGRESS is not returned by WinSock 2.0; for backwards\n             compatibility, connect(2) uses EWOULDBLOCK.  */\n          if (WSAGetLastError () == WSAEWOULDBLOCK)\n            WSASetLastError (WSAEINPROGRESS);\n\n          set_winsock_errno ();\n        }\n\n      return r;\n    }\n}",
      "lines": 26,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/dtotimespec.c": {
    "dtotimespec": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "struct timespec\ndtotimespec (double sec)\n{\n  double min_representable = TYPE_MINIMUM (time_t);\n  double max_representable =\n    ((TYPE_MAXIMUM (time_t) * (double) TIMESPEC_RESOLUTION\n      + (TIMESPEC_RESOLUTION - 1))\n     / TIMESPEC_RESOLUTION);\n\n  if (! (min_representable < sec))\n    return make_timespec (TYPE_MINIMUM (time_t), 0);\n  else if (! (sec < max_representable))\n    return make_timespec (TYPE_MAXIMUM (time_t), TIMESPEC_RESOLUTION - 1);\n  else\n    {\n      time_t s = sec;\n      double frac = TIMESPEC_RESOLUTION * (sec - s);\n      long ns = frac;\n      ns += ns < frac;\n      s += ns / TIMESPEC_RESOLUTION;\n      ns %= TIMESPEC_RESOLUTION;\n\n      if (ns < 0)\n        {\n          s--;\n          ns += TIMESPEC_RESOLUTION;\n        }\n\n      return make_timespec (s, ns);\n    }\n}",
      "lines": 31,
      "depth": 12,
      "decorators": [
        "struct timespec",
        "struct",
        "timespec"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/dup-safer-flag.c": {
    "dup_safer_flag": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "int\ndup_safer_flag (int fd, int flag)\n{\n  return fcntl (fd, (flag & O_CLOEXEC) ? F_DUPFD_CLOEXEC : F_DUPFD,\n                STDERR_FILENO + 1);\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/fd-safer-flag.c": {
    "fd_safer_flag": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "int\nfd_safer_flag (int fd, int flag)\n{\n  if (STDIN_FILENO <= fd && fd <= STDERR_FILENO)\n    {\n      int f = dup_safer_flag (fd, flag);\n      int e = errno;\n      close (fd);\n      errno = e;\n      fd = f;\n    }\n\n  return fd;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/fdopen.c": {
    "fdopen_nothrow": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        38,
        5
      ],
      "content": "static FILE *\nfdopen_nothrow (int fd, const char *mode)\n{\n  FILE *result;\n\n  TRY_MSVC_INVAL\n    {\n      result = fdopen (fd, mode);\n    }",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "FILE",
        "*\nfdopen_nothrow (int fd, const char *mode)",
        "*"
      ]
    },
    "rpl_fdopen": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "FILE *\nrpl_fdopen (int fd, const char *mode)\n{\n  int saved_errno = errno;\n  FILE *fp;\n\n  errno = 0;\n  fp = fdopen_nothrow (fd, mode);\n  if (fp == NULL)\n    {\n      if (errno == 0)\n        errno = EBADF;\n    }\n  else\n    errno = saved_errno;\n\n  return fp;\n}",
      "lines": 18,
      "depth": 8,
      "decorators": [
        "FILE",
        "*\nrpl_fdopen (int fd, const char *mode)",
        "*"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/fpucw.h": {},
  "findutils/findutils-4.6.0/tests/ftruncate.c": {
    "SetFileSize": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        115,
        1
      ],
      "content": "static BOOL\nSetFileSize (HANDLE h, LONGLONG size)\n{\n  LARGE_INTEGER old_size;\n\n  if (!GetFileSizeEx (h, &old_size))\n    return FALSE;\n\n  if (size != old_size.QuadPart)\n    {\n      /* Duplicate the handle, so we are free to modify its file position.  */\n      HANDLE curr_process = GetCurrentProcess ();\n      HANDLE tmph;\n\n      if (!DuplicateHandle (curr_process,           /* SourceProcessHandle */\n                            h,                      /* SourceHandle */\n                            curr_process,           /* TargetProcessHandle */\n                            (PHANDLE) &tmph,        /* TargetHandle */\n                            (DWORD) 0,              /* DesiredAccess */\n                            FALSE,                  /* InheritHandle */\n                            DUPLICATE_SAME_ACCESS)) /* Options */\n        return FALSE;\n\n      if (size < old_size.QuadPart)\n        {\n          /* Reduce the size.  */\n          LONG size_hi = (LONG) (size >> 32);\n          if (SetFilePointer (tmph, (LONG) size, &size_hi, FILE_BEGIN)\n              == INVALID_SET_FILE_POINTER\n              && GetLastError() != NO_ERROR)\n            {\n              CloseHandle (tmph);\n              return FALSE;\n            }\n          if (!SetEndOfFile (tmph))\n            {\n              CloseHandle (tmph);\n              return FALSE;\n            }\n        }\n      else\n        {\n          /* Increase the size by adding zero bytes at the end.  */\n          static char zero_bytes[1024];\n          LONG pos_hi = 0;\n          LONG pos_lo = SetFilePointer (tmph, (LONG) 0, &pos_hi, FILE_END);\n          LONGLONG pos;\n          if (pos_lo == INVALID_SET_FILE_POINTER\n              && GetLastError() != NO_ERROR)\n            {\n              CloseHandle (tmph);\n              return FALSE;\n            }\n          pos = ((LONGLONG) pos_hi << 32) | (ULONGLONG) (ULONG) pos_lo;\n          while (pos < size)\n            {\n              DWORD written;\n              LONGLONG count = size - pos;\n              if (count > sizeof (zero_bytes))\n                count = sizeof (zero_bytes);\n              if (!WriteFile (tmph, zero_bytes, (DWORD) count, &written, NULL)\n                  || written == 0)\n                {\n                  CloseHandle (tmph);\n                  return FALSE;\n                }\n              pos += (ULONGLONG) (ULONG) written;\n            }\n        }\n      /* Close the handle.  */\n      CloseHandle (tmph);\n    }\n  return TRUE;\n}",
      "lines": 74,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "BOOL"
      ]
    },
    "ftruncate": [
      {
        "start_point": [
          117,
          0
        ],
        "end_point": [
          151,
          1
        ],
        "content": "int\nftruncate (int fd, off_t length)\n{\n  HANDLE handle = (HANDLE) _get_osfhandle (fd);\n\n  if (handle == INVALID_HANDLE_VALUE)\n    {\n      errno = EBADF;\n      return -1;\n    }\n  if (length < 0)\n    {\n      errno = EINVAL;\n      return -1;\n    }\n  if (!SetFileSize (handle, length))\n    {\n      switch (GetLastError ())\n        {\n        case ERROR_ACCESS_DENIED:\n          errno = EACCES;\n          break;\n        case ERROR_HANDLE_DISK_FULL:\n        case ERROR_DISK_FULL:\n        case ERROR_DISK_TOO_FRAGMENTED:\n          errno = ENOSPC;\n          break;\n        default:\n          errno = EIO;\n          break;\n        }\n      return -1;\n    }\n  return 0;\n}",
        "lines": 35,
        "depth": 10,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          180,
          0
        ],
        "end_point": [
          184,
          1
        ],
        "content": "int\nftruncate (int fd, off_t length)\n{\n  return chsize (fd, length);\n}",
        "lines": 5,
        "depth": 6,
        "decorators": [
          "int"
        ]
      }
    ],
    "chsize_nothrow": {
      "start_point": [
        159,
        0
      ],
      "end_point": [
        167,
        5
      ],
      "content": "static int\nchsize_nothrow (int fd, long length)\n{\n  int result;\n\n  TRY_MSVC_INVAL\n    {\n      result = chsize (fd, length);\n    }",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/getpagesize.c": {
    "getpagesize": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "int\ngetpagesize (void)\n{\n  SYSTEM_INFO system_info;\n  GetSystemInfo (&system_info);\n  return system_info.dwPageSize;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/ignore-value.h": {},
  "findutils/findutils-4.6.0/tests/imaxtostr.c": {},
  "findutils/findutils-4.6.0/tests/inet_pton.c": {
    "rpl_inet_pton": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "int\nrpl_inet_pton (int af, const char *restrict src, void *restrict dst)\n{\n  return inet_pton (af, src, dst);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "inet_pton": {
      "start_point": [
        80,
        0
      ],
      "end_point": [
        98,
        1
      ],
      "content": "int\ninet_pton (int af, const char *restrict src, void *restrict dst)\n{\n  switch (af)\n    {\n    case AF_INET:\n      return (inet_pton4 (src, dst));\n\n# if HAVE_IPV6\n    case AF_INET6:\n      return (inet_pton6 (src, dst));\n# endif\n\n    default:\n      errno = EAFNOSUPPORT;\n      return (-1);\n    }\n  /* NOTREACHED */\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "inet_pton4": {
      "start_point": [
        111,
        0
      ],
      "end_point": [
        153,
        1
      ],
      "content": "static int\ninet_pton4 (const char *restrict src, unsigned char *restrict dst)\n{\n  int saw_digit, octets, ch;\n  unsigned char tmp[NS_INADDRSZ], *tp;\n\n  saw_digit = 0;\n  octets = 0;\n  *(tp = tmp) = 0;\n  while ((ch = *src++) != '\\0')\n    {\n\n      if (ch >= '0' && ch <= '9')\n        {\n          unsigned new = *tp * 10 + (ch - '0');\n\n          if (saw_digit && *tp == 0)\n            return (0);\n          if (new > 255)\n            return (0);\n          *tp = new;\n          if (!saw_digit)\n            {\n              if (++octets > 4)\n                return (0);\n              saw_digit = 1;\n            }\n        }\n      else if (ch == '.' && saw_digit)\n        {\n          if (octets == 4)\n            return (0);\n          *++tp = 0;\n          saw_digit = 0;\n        }\n      else\n        return (0);\n    }\n  if (octets < 4)\n    return (0);\n  memcpy (dst, tmp, NS_INADDRSZ);\n  return (1);\n}",
      "lines": 43,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "inet_pton6": {
      "start_point": [
        170,
        0
      ],
      "end_point": [
        263,
        1
      ],
      "content": "static int\ninet_pton6 (const char *restrict src, unsigned char *restrict dst)\n{\n  static const char xdigits[] = \"0123456789abcdef\";\n  unsigned char tmp[NS_IN6ADDRSZ], *tp, *endp, *colonp;\n  const char *curtok;\n  int ch, saw_xdigit;\n  unsigned val;\n\n  tp = memset (tmp, '\\0', NS_IN6ADDRSZ);\n  endp = tp + NS_IN6ADDRSZ;\n  colonp = NULL;\n  /* Leading :: requires some special handling. */\n  if (*src == ':')\n    if (*++src != ':')\n      return (0);\n  curtok = src;\n  saw_xdigit = 0;\n  val = 0;\n  while ((ch = c_tolower (*src++)) != '\\0')\n    {\n      const char *pch;\n\n      pch = strchr (xdigits, ch);\n      if (pch != NULL)\n        {\n          val <<= 4;\n          val |= (pch - xdigits);\n          if (val > 0xffff)\n            return (0);\n          saw_xdigit = 1;\n          continue;\n        }\n      if (ch == ':')\n        {\n          curtok = src;\n          if (!saw_xdigit)\n            {\n              if (colonp)\n                return (0);\n              colonp = tp;\n              continue;\n            }\n          else if (*src == '\\0')\n            {\n              return (0);\n            }\n          if (tp + NS_INT16SZ > endp)\n            return (0);\n          *tp++ = (u_char) (val >> 8) & 0xff;\n          *tp++ = (u_char) val & 0xff;\n          saw_xdigit = 0;\n          val = 0;\n          continue;\n        }\n      if (ch == '.' && ((tp + NS_INADDRSZ) <= endp) &&\n          inet_pton4 (curtok, tp) > 0)\n        {\n          tp += NS_INADDRSZ;\n          saw_xdigit = 0;\n          break;                /* '\\0' was seen by inet_pton4(). */\n        }\n      return (0);\n    }\n  if (saw_xdigit)\n    {\n      if (tp + NS_INT16SZ > endp)\n        return (0);\n      *tp++ = (u_char) (val >> 8) & 0xff;\n      *tp++ = (u_char) val & 0xff;\n    }\n  if (colonp != NULL)\n    {\n      /*\n       * Since some memmove()'s erroneously fail to handle\n       * overlapping regions, we'll do the shift by hand.\n       */\n      const int n = tp - colonp;\n      int i;\n\n      if (tp == endp)\n        return (0);\n      for (i = 1; i <= n; i++)\n        {\n          endp[-i] = colonp[n - i];\n          colonp[n - i] = 0;\n        }\n      tp = endp;\n    }\n  if (tp != endp)\n    return (0);\n  memcpy (dst, tmp, NS_IN6ADDRSZ);\n  return (1);\n}",
      "lines": 94,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/infinity.h": {
    "Infinityf": {
      "start_point": [
        21,
        0
      ],
      "end_point": [
        26,
        1
      ],
      "content": "static float\nInfinityf ()\n{\n  static float zero = 0.0f;\n  return 1.0f / zero;\n}",
      "lines": 6,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "float"
      ]
    },
    "Infinityd": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        41,
        1
      ],
      "content": "static double\nInfinityd ()\n{\n  static double zero = 0.0;\n  return 1.0 / zero;\n}",
      "lines": 6,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "Infinityl": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "static double\nInfinityl ()\n{\n  static long double zero = 0.0L;\n  return 1.0L / zero;\n}",
      "lines": 6,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/inttostr.c": {},
  "findutils/findutils-4.6.0/tests/inttostr.h": {},
  "findutils/findutils-4.6.0/tests/ioctl.c": {
    "rpl_ioctl": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        42,
        1
      ],
      "content": "int\nrpl_ioctl (int fd, int request, ... /* {void *,char *} arg */)\n{\n  void *buf;\n  va_list args;\n\n  va_start (args, request);\n  buf = va_arg (args, void *);\n  va_end (args);\n\n  /* Cast 'request' so that when the system's ioctl function takes a 64-bit\n     request argument, the value gets zero-extended, not sign-extended.  */\n  return ioctl (fd, (unsigned int) request, buf);\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "primary_ioctl": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "static int\nprimary_ioctl (int fd, int request, void *arg)\n{\n  /* We don't support FIONBIO on pipes here.  If you want to make pipe\n     fds non-blocking, use the gnulib 'nonblocking' module, until\n     gnulib implements fcntl F_GETFL / F_SETFL with O_NONBLOCK.  */\n\n  if ((HANDLE) _get_osfhandle (fd) != INVALID_HANDLE_VALUE)\n    errno = ENOSYS;\n  else\n    errno = EBADF;\n  return -1;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "ioctl": {
      "start_point": [
        70,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "int\nioctl (int fd, int request, ... /* {void *,char *} arg */)\n{\n  void *arg;\n  va_list args;\n\n  va_start (args, request);\n  arg = va_arg (args, void *);\n  va_end (args);\n\n# if WINDOWS_SOCKETS\n  return execute_all_ioctl_hooks (primary_ioctl, fd, request, arg);\n# else\n  return primary_ioctl (fd, request, arg);\n# endif\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/listen.c": {
    "rpl_listen": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "int\nrpl_listen (int fd, int backlog)\n{\n  SOCKET sock = FD_TO_SOCKET (fd);\n\n  if (sock == INVALID_SOCKET)\n    {\n      errno = EBADF;\n      return -1;\n    }\n  else\n    {\n      int r = listen (sock, backlog);\n      if (r < 0)\n        set_winsock_errno ();\n\n      return r;\n    }\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/localename.c": {
    "gl_locale_name_canonicalize": [
      {
        "start_point": [
          1152,
          0
        ],
        "end_point": [
          1415,
          1
        ],
        "content": "void\ngl_locale_name_canonicalize (char *name)\n{\n  /* This conversion is based on a posting by\n     Deborah GoldSmith <goldsmit@apple.com> on 2005-03-08,\n     http://lists.apple.com/archives/carbon-dev/2005/Mar/msg00293.html */\n\n  /* Convert legacy (NeXTstep inherited) English names to Unix (ISO 639 and\n     ISO 3166) names.  Prior to Mac OS X 10.3, there is no API for doing this.\n     Therefore we do it ourselves, using a table based on the results of the\n     Mac OS X 10.3.8 function\n     CFLocaleCreateCanonicalLocaleIdentifierFromString().  */\n  typedef struct { const char legacy[21+1]; const char unixy[5+1]; }\n          legacy_entry;\n  static const legacy_entry legacy_table[] = {\n    { \"Afrikaans\",             \"af\" },\n    { \"Albanian\",              \"sq\" },\n    { \"Amharic\",               \"am\" },\n    { \"Arabic\",                \"ar\" },\n    { \"Armenian\",              \"hy\" },\n    { \"Assamese\",              \"as\" },\n    { \"Aymara\",                \"ay\" },\n    { \"Azerbaijani\",           \"az\" },\n    { \"Basque\",                \"eu\" },\n    { \"Belarusian\",            \"be\" },\n    { \"Belorussian\",           \"be\" },\n    { \"Bengali\",               \"bn\" },\n    { \"Brazilian Portugese\",   \"pt_BR\" },\n    { \"Brazilian Portuguese\",  \"pt_BR\" },\n    { \"Breton\",                \"br\" },\n    { \"Bulgarian\",             \"bg\" },\n    { \"Burmese\",               \"my\" },\n    { \"Byelorussian\",          \"be\" },\n    { \"Catalan\",               \"ca\" },\n    { \"Chewa\",                 \"ny\" },\n    { \"Chichewa\",              \"ny\" },\n    { \"Chinese\",               \"zh\" },\n    { \"Chinese, Simplified\",   \"zh_CN\" },\n    { \"Chinese, Traditional\",  \"zh_TW\" },\n    { \"Chinese, Tradtional\",   \"zh_TW\" },\n    { \"Croatian\",              \"hr\" },\n    { \"Czech\",                 \"cs\" },\n    { \"Danish\",                \"da\" },\n    { \"Dutch\",                 \"nl\" },\n    { \"Dzongkha\",              \"dz\" },\n    { \"English\",               \"en\" },\n    { \"Esperanto\",             \"eo\" },\n    { \"Estonian\",              \"et\" },\n    { \"Faroese\",               \"fo\" },\n    { \"Farsi\",                 \"fa\" },\n    { \"Finnish\",               \"fi\" },\n    { \"Flemish\",               \"nl_BE\" },\n    { \"French\",                \"fr\" },\n    { \"Galician\",              \"gl\" },\n    { \"Gallegan\",              \"gl\" },\n    { \"Georgian\",              \"ka\" },\n    { \"German\",                \"de\" },\n    { \"Greek\",                 \"el\" },\n    { \"Greenlandic\",           \"kl\" },\n    { \"Guarani\",               \"gn\" },\n    { \"Gujarati\",              \"gu\" },\n    { \"Hawaiian\",              \"haw\" }, /* Yes, \"haw\", not \"cpe\".  */\n    { \"Hebrew\",                \"he\" },\n    { \"Hindi\",                 \"hi\" },\n    { \"Hungarian\",             \"hu\" },\n    { \"Icelandic\",             \"is\" },\n    { \"Indonesian\",            \"id\" },\n    { \"Inuktitut\",             \"iu\" },\n    { \"Irish\",                 \"ga\" },\n    { \"Italian\",               \"it\" },\n    { \"Japanese\",              \"ja\" },\n    { \"Javanese\",              \"jv\" },\n    { \"Kalaallisut\",           \"kl\" },\n    { \"Kannada\",               \"kn\" },\n    { \"Kashmiri\",              \"ks\" },\n    { \"Kazakh\",                \"kk\" },\n    { \"Khmer\",                 \"km\" },\n    { \"Kinyarwanda\",           \"rw\" },\n    { \"Kirghiz\",               \"ky\" },\n    { \"Korean\",                \"ko\" },\n    { \"Kurdish\",               \"ku\" },\n    { \"Latin\",                 \"la\" },\n    { \"Latvian\",               \"lv\" },\n    { \"Lithuanian\",            \"lt\" },\n    { \"Macedonian\",            \"mk\" },\n    { \"Malagasy\",              \"mg\" },\n    { \"Malay\",                 \"ms\" },\n    { \"Malayalam\",             \"ml\" },\n    { \"Maltese\",               \"mt\" },\n    { \"Manx\",                  \"gv\" },\n    { \"Marathi\",               \"mr\" },\n    { \"Moldavian\",             \"mo\" },\n    { \"Mongolian\",             \"mn\" },\n    { \"Nepali\",                \"ne\" },\n    { \"Norwegian\",             \"nb\" }, /* Yes, \"nb\", not the obsolete \"no\".  */\n    { \"Nyanja\",                \"ny\" },\n    { \"Nynorsk\",               \"nn\" },\n    { \"Oriya\",                 \"or\" },\n    { \"Oromo\",                 \"om\" },\n    { \"Panjabi\",               \"pa\" },\n    { \"Pashto\",                \"ps\" },\n    { \"Persian\",               \"fa\" },\n    { \"Polish\",                \"pl\" },\n    { \"Portuguese\",            \"pt\" },\n    { \"Portuguese, Brazilian\", \"pt_BR\" },\n    { \"Punjabi\",               \"pa\" },\n    { \"Pushto\",                \"ps\" },\n    { \"Quechua\",               \"qu\" },\n    { \"Romanian\",              \"ro\" },\n    { \"Ruanda\",                \"rw\" },\n    { \"Rundi\",                 \"rn\" },\n    { \"Russian\",               \"ru\" },\n    { \"Sami\",                  \"se_NO\" }, /* Not just \"se\".  */\n    { \"Sanskrit\",              \"sa\" },\n    { \"Scottish\",              \"gd\" },\n    { \"Serbian\",               \"sr\" },\n    { \"Simplified Chinese\",    \"zh_CN\" },\n    { \"Sindhi\",                \"sd\" },\n    { \"Sinhalese\",             \"si\" },\n    { \"Slovak\",                \"sk\" },\n    { \"Slovenian\",             \"sl\" },\n    { \"Somali\",                \"so\" },\n    { \"Spanish\",               \"es\" },\n    { \"Sundanese\",             \"su\" },\n    { \"Swahili\",               \"sw\" },\n    { \"Swedish\",               \"sv\" },\n    { \"Tagalog\",               \"tl\" },\n    { \"Tajik\",                 \"tg\" },\n    { \"Tajiki\",                \"tg\" },\n    { \"Tamil\",                 \"ta\" },\n    { \"Tatar\",                 \"tt\" },\n    { \"Telugu\",                \"te\" },\n    { \"Thai\",                  \"th\" },\n    { \"Tibetan\",               \"bo\" },\n    { \"Tigrinya\",              \"ti\" },\n    { \"Tongan\",                \"to\" },\n    { \"Traditional Chinese\",   \"zh_TW\" },\n    { \"Turkish\",               \"tr\" },\n    { \"Turkmen\",               \"tk\" },\n    { \"Uighur\",                \"ug\" },\n    { \"Ukrainian\",             \"uk\" },\n    { \"Urdu\",                  \"ur\" },\n    { \"Uzbek\",                 \"uz\" },\n    { \"Vietnamese\",            \"vi\" },\n    { \"Welsh\",                 \"cy\" },\n    { \"Yiddish\",               \"yi\" }\n  };\n\n  /* Convert new-style locale names with language tags (ISO 639 and ISO 15924)\n     to Unix (ISO 639 and ISO 3166) names.  */\n  typedef struct { const char langtag[7+1]; const char unixy[12+1]; }\n          langtag_entry;\n  static const langtag_entry langtag_table[] = {\n    /* Mac OS X has \"az-Arab\", \"az-Cyrl\", \"az-Latn\".\n       The default script for az on Unix is Latin.  */\n    { \"az-Latn\", \"az\" },\n    /* Mac OS X has \"ga-dots\".  Does not yet exist on Unix.  */\n    { \"ga-dots\", \"ga\" },\n    /* Mac OS X has \"kk-Cyrl\".  Does not yet exist on Unix.  */\n    /* Mac OS X has \"mn-Cyrl\", \"mn-Mong\".\n       The default script for mn on Unix is Cyrillic.  */\n    { \"mn-Cyrl\", \"mn\" },\n    /* Mac OS X has \"ms-Arab\", \"ms-Latn\".\n       The default script for ms on Unix is Latin.  */\n    { \"ms-Latn\", \"ms\" },\n    /* Mac OS X has \"tg-Cyrl\".\n       The default script for tg on Unix is Cyrillic.  */\n    { \"tg-Cyrl\", \"tg\" },\n    /* Mac OS X has \"tk-Cyrl\".  Does not yet exist on Unix.  */\n    /* Mac OS X has \"tt-Cyrl\".\n       The default script for tt on Unix is Cyrillic.  */\n    { \"tt-Cyrl\", \"tt\" },\n    /* Mac OS X has \"zh-Hans\", \"zh-Hant\".\n       Country codes are used to distinguish these on Unix.  */\n    { \"zh-Hans\", \"zh_CN\" },\n    { \"zh-Hant\", \"zh_TW\" }\n  };\n\n  /* Convert script names (ISO 15924) to Unix conventions.\n     See http://www.unicode.org/iso15924/iso15924-codes.html  */\n  typedef struct { const char script[4+1]; const char unixy[9+1]; }\n          script_entry;\n  static const script_entry script_table[] = {\n    { \"Arab\", \"arabic\" },\n    { \"Cyrl\", \"cyrillic\" },\n    { \"Mong\", \"mongolian\" }\n  };\n\n  /* Step 1: Convert using legacy_table.  */\n  if (name[0] >= 'A' && name[0] <= 'Z')\n    {\n      unsigned int i1, i2;\n      i1 = 0;\n      i2 = sizeof (legacy_table) / sizeof (legacy_entry);\n      while (i2 - i1 > 1)\n        {\n          /* At this point we know that if name occurs in legacy_table,\n             its index must be >= i1 and < i2.  */\n          unsigned int i = (i1 + i2) >> 1;\n          const legacy_entry *p = &legacy_table[i];\n          if (strcmp (name, p->legacy) < 0)\n            i2 = i;\n          else\n            i1 = i;\n        }\n      if (strcmp (name, legacy_table[i1].legacy) == 0)\n        {\n          strcpy (name, legacy_table[i1].unixy);\n          return;\n        }\n    }\n\n  /* Step 2: Convert using langtag_table and script_table.  */\n  if (strlen (name) == 7 && name[2] == '-')\n    {\n      unsigned int i1, i2;\n      i1 = 0;\n      i2 = sizeof (langtag_table) / sizeof (langtag_entry);\n      while (i2 - i1 > 1)\n        {\n          /* At this point we know that if name occurs in langtag_table,\n             its index must be >= i1 and < i2.  */\n          unsigned int i = (i1 + i2) >> 1;\n          const langtag_entry *p = &langtag_table[i];\n          if (strcmp (name, p->langtag) < 0)\n            i2 = i;\n          else\n            i1 = i;\n        }\n      if (strcmp (name, langtag_table[i1].langtag) == 0)\n        {\n          strcpy (name, langtag_table[i1].unixy);\n          return;\n        }\n\n      i1 = 0;\n      i2 = sizeof (script_table) / sizeof (script_entry);\n      while (i2 - i1 > 1)\n        {\n          /* At this point we know that if (name + 3) occurs in script_table,\n             its index must be >= i1 and < i2.  */\n          unsigned int i = (i1 + i2) >> 1;\n          const script_entry *p = &script_table[i];\n          if (strcmp (name + 3, p->script) < 0)\n            i2 = i;\n          else\n            i1 = i;\n        }\n      if (strcmp (name + 3, script_table[i1].script) == 0)\n        {\n          name[2] = '@';\n          strcpy (name + 3, script_table[i1].unixy);\n          return;\n        }\n    }\n\n  /* Step 3: Convert new-style dash to Unix underscore. */\n  {\n    char *p;\n    for (p = name; *p != '\\0'; p++)\n      if (*p == '-')\n        *p = '_';\n  }\n}",
        "lines": 264,
        "depth": 13,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          1429,
          0
        ],
        "end_point": [
          1453,
          1
        ],
        "content": "void\ngl_locale_name_canonicalize (char *name)\n{\n  /* FIXME: This is probably incomplete: it does not handle \"zh-Hans\" and\n     \"zh-Hant\".  */\n  char *p;\n\n  for (p = name; *p != '\\0'; p++)\n    if (*p == '-')\n      {\n        *p = '_';\n        p++;\n        for (; *p != '\\0'; p++)\n          {\n            if (*p >= 'a' && *p <= 'z')\n              *p += 'A' - 'a';\n            if (*p == '-')\n              {\n                *p = '\\0';\n                return;\n              }\n          }\n        return;\n      }\n}",
        "lines": 25,
        "depth": 13,
        "decorators": [
          "void"
        ]
      }
    ],
    "gl_locale_name_from_win32_LANGID": {
      "start_point": [
        1458,
        0
      ],
      "end_point": [
        2501,
        1
      ],
      "content": "const char *\ngl_locale_name_from_win32_LANGID (LANGID langid)\n{\n  /* Activate the new code only when the GETTEXT_MUI environment variable is\n     set, for the time being, since the new code is not well tested.  */\n  if (getenv (\"GETTEXT_MUI\") != NULL)\n    {\n      static char namebuf[256];\n\n      /* Query the system's notion of locale name.\n         On Windows95/98/ME, GetLocaleInfoA returns some incorrect results.\n         But we don't need to support systems that are so old.  */\n      if (GetLocaleInfoA (MAKELCID (langid, SORT_DEFAULT), LOCALE_SNAME,\n                          namebuf, sizeof (namebuf) - 1))\n        {\n          /* Convert it to a Unix locale name.  */\n          gl_locale_name_canonicalize (namebuf);\n          return namebuf;\n        }\n    }\n  /* Internet Explorer has an LCID to RFC3066 name mapping stored in\n     HKEY_CLASSES_ROOT\\Mime\\Database\\Rfc1766.  But we better don't use that\n     since IE's i18n subsystem is known to be inconsistent with the native\n     Windows base (e.g. they have different character conversion facilities\n     that produce different results).  */\n  /* Use our own table.  */\n  {\n    int primary, sub;\n\n    /* Split into language and territory part.  */\n    primary = PRIMARYLANGID (langid);\n    sub = SUBLANGID (langid);\n\n    /* Dispatch on language.\n       See also http://www.unicode.org/unicode/onlinedat/languages.html .\n       For details about languages, see http://www.ethnologue.com/ .  */\n    switch (primary)\n      {\n      case LANG_AFRIKAANS:\n        switch (sub)\n          {\n          case SUBLANG_AFRIKAANS_SOUTH_AFRICA: return \"af_ZA\";\n          }\n        return \"af\";\n      case LANG_ALBANIAN:\n        switch (sub)\n          {\n          case SUBLANG_ALBANIAN_ALBANIA: return \"sq_AL\";\n          }\n        return \"sq\";\n      case LANG_ALSATIAN:\n        switch (sub)\n          {\n          case SUBLANG_ALSATIAN_FRANCE: return \"gsw_FR\";\n          }\n        return \"gsw\";\n      case LANG_AMHARIC:\n        switch (sub)\n          {\n          case SUBLANG_AMHARIC_ETHIOPIA: return \"am_ET\";\n          }\n        return \"am\";\n      case LANG_ARABIC:\n        switch (sub)\n          {\n          case SUBLANG_ARABIC_SAUDI_ARABIA: return \"ar_SA\";\n          case SUBLANG_ARABIC_IRAQ: return \"ar_IQ\";\n          case SUBLANG_ARABIC_EGYPT: return \"ar_EG\";\n          case SUBLANG_ARABIC_LIBYA: return \"ar_LY\";\n          case SUBLANG_ARABIC_ALGERIA: return \"ar_DZ\";\n          case SUBLANG_ARABIC_MOROCCO: return \"ar_MA\";\n          case SUBLANG_ARABIC_TUNISIA: return \"ar_TN\";\n          case SUBLANG_ARABIC_OMAN: return \"ar_OM\";\n          case SUBLANG_ARABIC_YEMEN: return \"ar_YE\";\n          case SUBLANG_ARABIC_SYRIA: return \"ar_SY\";\n          case SUBLANG_ARABIC_JORDAN: return \"ar_JO\";\n          case SUBLANG_ARABIC_LEBANON: return \"ar_LB\";\n          case SUBLANG_ARABIC_KUWAIT: return \"ar_KW\";\n          case SUBLANG_ARABIC_UAE: return \"ar_AE\";\n          case SUBLANG_ARABIC_BAHRAIN: return \"ar_BH\";\n          case SUBLANG_ARABIC_QATAR: return \"ar_QA\";\n          }\n        return \"ar\";\n      case LANG_ARMENIAN:\n        switch (sub)\n          {\n          case SUBLANG_ARMENIAN_ARMENIA: return \"hy_AM\";\n          }\n        return \"hy\";\n      case LANG_ASSAMESE:\n        switch (sub)\n          {\n          case SUBLANG_ASSAMESE_INDIA: return \"as_IN\";\n          }\n        return \"as\";\n      case LANG_AZERI:\n        switch (sub)\n          {\n          /* FIXME: Adjust this when Azerbaijani locales appear on Unix.  */\n          case 0x1e: return \"az@latin\";\n          case SUBLANG_AZERI_LATIN: return \"az_AZ@latin\";\n          case 0x1d: return \"az@cyrillic\";\n          case SUBLANG_AZERI_CYRILLIC: return \"az_AZ@cyrillic\";\n          }\n        return \"az\";\n      case LANG_BASHKIR:\n        switch (sub)\n          {\n          case SUBLANG_BASHKIR_RUSSIA: return \"ba_RU\";\n          }\n        return \"ba\";\n      case LANG_BASQUE:\n        switch (sub)\n          {\n          case SUBLANG_BASQUE_BASQUE: return \"eu_ES\";\n          }\n        return \"eu\"; /* Ambiguous: could be \"eu_ES\" or \"eu_FR\".  */\n      case LANG_BELARUSIAN:\n        switch (sub)\n          {\n          case SUBLANG_BELARUSIAN_BELARUS: return \"be_BY\";\n          }\n        return \"be\";\n      case LANG_BENGALI:\n        switch (sub)\n          {\n          case SUBLANG_BENGALI_INDIA: return \"bn_IN\";\n          case SUBLANG_BENGALI_BANGLADESH: return \"bn_BD\";\n          }\n        return \"bn\";\n      case LANG_BRETON:\n        switch (sub)\n          {\n          case SUBLANG_BRETON_FRANCE: return \"br_FR\";\n          }\n        return \"br\";\n      case LANG_BULGARIAN:\n        switch (sub)\n          {\n          case SUBLANG_BULGARIAN_BULGARIA: return \"bg_BG\";\n          }\n        return \"bg\";\n      case LANG_BURMESE:\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"my_MM\";\n          }\n        return \"my\";\n      case LANG_CAMBODIAN:\n        switch (sub)\n          {\n          case SUBLANG_CAMBODIAN_CAMBODIA: return \"km_KH\";\n          }\n        return \"km\";\n      case LANG_CATALAN:\n        switch (sub)\n          {\n          case SUBLANG_CATALAN_SPAIN: return \"ca_ES\";\n          }\n        return \"ca\";\n      case LANG_CHEROKEE:\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"chr_US\";\n          }\n        return \"chr\";\n      case LANG_CHINESE:\n        switch (sub)\n          {\n          case SUBLANG_CHINESE_TRADITIONAL: case 0x1f: return \"zh_TW\";\n          case SUBLANG_CHINESE_SIMPLIFIED: case 0x00: return \"zh_CN\";\n          case SUBLANG_CHINESE_HONGKONG: return \"zh_HK\"; /* traditional */\n          case SUBLANG_CHINESE_SINGAPORE: return \"zh_SG\"; /* simplified */\n          case SUBLANG_CHINESE_MACAU: return \"zh_MO\"; /* traditional */\n          }\n        return \"zh\";\n      case LANG_CORSICAN:\n        switch (sub)\n          {\n          case SUBLANG_CORSICAN_FRANCE: return \"co_FR\";\n          }\n        return \"co\";\n      case LANG_CROATIAN:      /* LANG_CROATIAN == LANG_SERBIAN == LANG_BOSNIAN\n                                * What used to be called Serbo-Croatian\n                                * should really now be two separate\n                                * languages because of political reasons.\n                                * (Says tml, who knows nothing about Serbian\n                                * or Croatian.)\n                                * (I can feel those flames coming already.)\n                                */\n        switch (sub)\n          {\n          /* Croatian */\n          case 0x00: return \"hr\";\n          case SUBLANG_CROATIAN_CROATIA: return \"hr_HR\";\n          case SUBLANG_CROATIAN_BOSNIA_HERZEGOVINA_LATIN: return \"hr_BA\";\n          /* Serbian */\n          case 0x1f: return \"sr\";\n          case 0x1c: return \"sr\"; /* latin */\n          case SUBLANG_SERBIAN_LATIN: return \"sr_CS\"; /* latin */\n          case 0x09: return \"sr_RS\"; /* latin */\n          case 0x0b: return \"sr_ME\"; /* latin */\n          case 0x06: return \"sr_BA\"; /* latin */\n          case 0x1b: return \"sr@cyrillic\";\n          case SUBLANG_SERBIAN_CYRILLIC: return \"sr_CS@cyrillic\";\n          case 0x0a: return \"sr_RS@cyrillic\";\n          case 0x0c: return \"sr_ME@cyrillic\";\n          case 0x07: return \"sr_BA@cyrillic\";\n          /* Bosnian */\n          case 0x1e: return \"bs\";\n          case 0x1a: return \"bs\"; /* latin */\n          case SUBLANG_BOSNIAN_BOSNIA_HERZEGOVINA_LATIN: return \"bs_BA\"; /* latin */\n          case 0x19: return \"bs@cyrillic\";\n          case SUBLANG_BOSNIAN_BOSNIA_HERZEGOVINA_CYRILLIC: return \"bs_BA@cyrillic\";\n          }\n        return \"hr\";\n      case LANG_CZECH:\n        switch (sub)\n          {\n          case SUBLANG_CZECH_CZECH_REPUBLIC: return \"cs_CZ\";\n          }\n        return \"cs\";\n      case LANG_DANISH:\n        switch (sub)\n          {\n          case SUBLANG_DANISH_DENMARK: return \"da_DK\";\n          }\n        return \"da\";\n      case LANG_DARI:\n        /* FIXME: Adjust this when such locales appear on Unix.  */\n        switch (sub)\n          {\n          case SUBLANG_DARI_AFGHANISTAN: return \"prs_AF\";\n          }\n        return \"prs\";\n      case LANG_DIVEHI:\n        switch (sub)\n          {\n          case SUBLANG_DIVEHI_MALDIVES: return \"dv_MV\";\n          }\n        return \"dv\";\n      case LANG_DUTCH:\n        switch (sub)\n          {\n          case SUBLANG_DUTCH: return \"nl_NL\";\n          case SUBLANG_DUTCH_BELGIAN: /* FLEMISH, VLAAMS */ return \"nl_BE\";\n          case SUBLANG_DUTCH_SURINAM: return \"nl_SR\";\n          }\n        return \"nl\";\n      case LANG_EDO:\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"bin_NG\";\n          }\n        return \"bin\";\n      case LANG_ENGLISH:\n        switch (sub)\n          {\n          /* SUBLANG_ENGLISH_US == SUBLANG_DEFAULT. Heh. I thought\n           * English was the language spoken in England.\n           * Oh well.\n           */\n          case SUBLANG_ENGLISH_US: return \"en_US\";\n          case SUBLANG_ENGLISH_UK: return \"en_GB\";\n          case SUBLANG_ENGLISH_AUS: return \"en_AU\";\n          case SUBLANG_ENGLISH_CAN: return \"en_CA\";\n          case SUBLANG_ENGLISH_NZ: return \"en_NZ\";\n          case SUBLANG_ENGLISH_EIRE: return \"en_IE\";\n          case SUBLANG_ENGLISH_SOUTH_AFRICA: return \"en_ZA\";\n          case SUBLANG_ENGLISH_JAMAICA: return \"en_JM\";\n          case SUBLANG_ENGLISH_CARIBBEAN: return \"en_GD\"; /* Grenada? */\n          case SUBLANG_ENGLISH_BELIZE: return \"en_BZ\";\n          case SUBLANG_ENGLISH_TRINIDAD: return \"en_TT\";\n          case SUBLANG_ENGLISH_ZIMBABWE: return \"en_ZW\";\n          case SUBLANG_ENGLISH_PHILIPPINES: return \"en_PH\";\n          case SUBLANG_ENGLISH_INDONESIA: return \"en_ID\";\n          case SUBLANG_ENGLISH_HONGKONG: return \"en_HK\";\n          case SUBLANG_ENGLISH_INDIA: return \"en_IN\";\n          case SUBLANG_ENGLISH_MALAYSIA: return \"en_MY\";\n          case SUBLANG_ENGLISH_SINGAPORE: return \"en_SG\";\n          }\n        return \"en\";\n      case LANG_ESTONIAN:\n        switch (sub)\n          {\n          case SUBLANG_ESTONIAN_ESTONIA: return \"et_EE\";\n          }\n        return \"et\";\n      case LANG_FAEROESE:\n        switch (sub)\n          {\n          case SUBLANG_FAEROESE_FAROE_ISLANDS: return \"fo_FO\";\n          }\n        return \"fo\";\n      case LANG_FARSI:\n        switch (sub)\n          {\n          case SUBLANG_FARSI_IRAN: return \"fa_IR\";\n          }\n        return \"fa\";\n      case LANG_FINNISH:\n        switch (sub)\n          {\n          case SUBLANG_FINNISH_FINLAND: return \"fi_FI\";\n          }\n        return \"fi\";\n      case LANG_FRENCH:\n        switch (sub)\n          {\n          case SUBLANG_FRENCH: return \"fr_FR\";\n          case SUBLANG_FRENCH_BELGIAN: /* WALLOON */ return \"fr_BE\";\n          case SUBLANG_FRENCH_CANADIAN: return \"fr_CA\";\n          case SUBLANG_FRENCH_SWISS: return \"fr_CH\";\n          case SUBLANG_FRENCH_LUXEMBOURG: return \"fr_LU\";\n          case SUBLANG_FRENCH_MONACO: return \"fr_MC\";\n          case SUBLANG_FRENCH_WESTINDIES: return \"fr\"; /* Caribbean? */\n          case SUBLANG_FRENCH_REUNION: return \"fr_RE\";\n          case SUBLANG_FRENCH_CONGO: return \"fr_CG\";\n          case SUBLANG_FRENCH_SENEGAL: return \"fr_SN\";\n          case SUBLANG_FRENCH_CAMEROON: return \"fr_CM\";\n          case SUBLANG_FRENCH_COTEDIVOIRE: return \"fr_CI\";\n          case SUBLANG_FRENCH_MALI: return \"fr_ML\";\n          case SUBLANG_FRENCH_MOROCCO: return \"fr_MA\";\n          case SUBLANG_FRENCH_HAITI: return \"fr_HT\";\n          }\n        return \"fr\";\n      case LANG_FRISIAN:\n        switch (sub)\n          {\n          case SUBLANG_FRISIAN_NETHERLANDS: return \"fy_NL\";\n          }\n        return \"fy\";\n      case LANG_FULFULDE:\n        /* Spoken in Nigeria, Guinea, Senegal, Mali, Niger, Cameroon, Benin.  */\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"ff_NG\";\n          }\n        return \"ff\";\n      case LANG_GAELIC:\n        switch (sub)\n          {\n          case 0x01: /* SCOTTISH */\n            /* old, superseded by LANG_SCOTTISH_GAELIC */\n            return \"gd_GB\";\n          case SUBLANG_IRISH_IRELAND: return \"ga_IE\";\n          }\n        return \"ga\";\n      case LANG_GALICIAN:\n        switch (sub)\n          {\n          case SUBLANG_GALICIAN_SPAIN: return \"gl_ES\";\n          }\n        return \"gl\";\n      case LANG_GEORGIAN:\n        switch (sub)\n          {\n          case SUBLANG_GEORGIAN_GEORGIA: return \"ka_GE\";\n          }\n        return \"ka\";\n      case LANG_GERMAN:\n        switch (sub)\n          {\n          case SUBLANG_GERMAN: return \"de_DE\";\n          case SUBLANG_GERMAN_SWISS: return \"de_CH\";\n          case SUBLANG_GERMAN_AUSTRIAN: return \"de_AT\";\n          case SUBLANG_GERMAN_LUXEMBOURG: return \"de_LU\";\n          case SUBLANG_GERMAN_LIECHTENSTEIN: return \"de_LI\";\n          }\n        return \"de\";\n      case LANG_GREEK:\n        switch (sub)\n          {\n          case SUBLANG_GREEK_GREECE: return \"el_GR\";\n          }\n        return \"el\";\n      case LANG_GREENLANDIC:\n        switch (sub)\n          {\n          case SUBLANG_GREENLANDIC_GREENLAND: return \"kl_GL\";\n          }\n        return \"kl\";\n      case LANG_GUARANI:\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"gn_PY\";\n          }\n        return \"gn\";\n      case LANG_GUJARATI:\n        switch (sub)\n          {\n          case SUBLANG_GUJARATI_INDIA: return \"gu_IN\";\n          }\n        return \"gu\";\n      case LANG_HAUSA:\n        switch (sub)\n          {\n          case 0x1f: return \"ha\";\n          case SUBLANG_HAUSA_NIGERIA_LATIN: return \"ha_NG\";\n          }\n        return \"ha\";\n      case LANG_HAWAIIAN:\n        /* FIXME: Do they mean Hawaiian (\"haw_US\", 1000 speakers)\n           or Hawaii Creole English (\"cpe_US\", 600000 speakers)?  */\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"cpe_US\";\n          }\n        return \"cpe\";\n      case LANG_HEBREW:\n        switch (sub)\n          {\n          case SUBLANG_HEBREW_ISRAEL: return \"he_IL\";\n          }\n        return \"he\";\n      case LANG_HINDI:\n        switch (sub)\n          {\n          case SUBLANG_HINDI_INDIA: return \"hi_IN\";\n          }\n        return \"hi\";\n      case LANG_HUNGARIAN:\n        switch (sub)\n          {\n          case SUBLANG_HUNGARIAN_HUNGARY: return \"hu_HU\";\n          }\n        return \"hu\";\n      case LANG_IBIBIO:\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"nic_NG\";\n          }\n        return \"nic\";\n      case LANG_ICELANDIC:\n        switch (sub)\n          {\n          case SUBLANG_ICELANDIC_ICELAND: return \"is_IS\";\n          }\n        return \"is\";\n      case LANG_IGBO:\n        switch (sub)\n          {\n          case SUBLANG_IGBO_NIGERIA: return \"ig_NG\";\n          }\n        return \"ig\";\n      case LANG_INDONESIAN:\n        switch (sub)\n          {\n          case SUBLANG_INDONESIAN_INDONESIA: return \"id_ID\";\n          }\n        return \"id\";\n      case LANG_INUKTITUT:\n        switch (sub)\n          {\n          case 0x1e: return \"iu\"; /* syllabic */\n          case SUBLANG_INUKTITUT_CANADA: return \"iu_CA\"; /* syllabic */\n          case 0x1f: return \"iu@latin\";\n          case SUBLANG_INUKTITUT_CANADA_LATIN: return \"iu_CA@latin\";\n          }\n        return \"iu\";\n      case LANG_ITALIAN:\n        switch (sub)\n          {\n          case SUBLANG_ITALIAN: return \"it_IT\";\n          case SUBLANG_ITALIAN_SWISS: return \"it_CH\";\n          }\n        return \"it\";\n      case LANG_JAPANESE:\n        switch (sub)\n          {\n          case SUBLANG_JAPANESE_JAPAN: return \"ja_JP\";\n          }\n        return \"ja\";\n      case LANG_KANNADA:\n        switch (sub)\n          {\n          case SUBLANG_KANNADA_INDIA: return \"kn_IN\";\n          }\n        return \"kn\";\n      case LANG_KANURI:\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"kr_NG\";\n          }\n        return \"kr\";\n      case LANG_KASHMIRI:\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"ks_PK\";\n          case SUBLANG_KASHMIRI_INDIA: return \"ks_IN\";\n          }\n        return \"ks\";\n      case LANG_KAZAK:\n        switch (sub)\n          {\n          case SUBLANG_KAZAK_KAZAKHSTAN: return \"kk_KZ\";\n          }\n        return \"kk\";\n      case LANG_KICHE:\n        /* FIXME: Adjust this when such locales appear on Unix.  */\n        switch (sub)\n          {\n          case SUBLANG_KICHE_GUATEMALA: return \"qut_GT\";\n          }\n        return \"qut\";\n      case LANG_KINYARWANDA:\n        switch (sub)\n          {\n          case SUBLANG_KINYARWANDA_RWANDA: return \"rw_RW\";\n          }\n        return \"rw\";\n      case LANG_KONKANI:\n        /* FIXME: Adjust this when such locales appear on Unix.  */\n        switch (sub)\n          {\n          case SUBLANG_KONKANI_INDIA: return \"kok_IN\";\n          }\n        return \"kok\";\n      case LANG_KOREAN:\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"ko_KR\";\n          }\n        return \"ko\";\n      case LANG_KYRGYZ:\n        switch (sub)\n          {\n          case SUBLANG_KYRGYZ_KYRGYZSTAN: return \"ky_KG\";\n          }\n        return \"ky\";\n      case LANG_LAO:\n        switch (sub)\n          {\n          case SUBLANG_LAO_LAOS: return \"lo_LA\";\n          }\n        return \"lo\";\n      case LANG_LATIN:\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"la_VA\";\n          }\n        return \"la\";\n      case LANG_LATVIAN:\n        switch (sub)\n          {\n          case SUBLANG_LATVIAN_LATVIA: return \"lv_LV\";\n          }\n        return \"lv\";\n      case LANG_LITHUANIAN:\n        switch (sub)\n          {\n          case SUBLANG_LITHUANIAN_LITHUANIA: return \"lt_LT\";\n          }\n        return \"lt\";\n      case LANG_LUXEMBOURGISH:\n        switch (sub)\n          {\n          case SUBLANG_LUXEMBOURGISH_LUXEMBOURG: return \"lb_LU\";\n          }\n        return \"lb\";\n      case LANG_MACEDONIAN:\n        switch (sub)\n          {\n          case SUBLANG_MACEDONIAN_MACEDONIA: return \"mk_MK\";\n          }\n        return \"mk\";\n      case LANG_MALAY:\n        switch (sub)\n          {\n          case SUBLANG_MALAY_MALAYSIA: return \"ms_MY\";\n          case SUBLANG_MALAY_BRUNEI_DARUSSALAM: return \"ms_BN\";\n          }\n        return \"ms\";\n      case LANG_MALAYALAM:\n        switch (sub)\n          {\n          case SUBLANG_MALAYALAM_INDIA: return \"ml_IN\";\n          }\n        return \"ml\";\n      case LANG_MALTESE:\n        switch (sub)\n          {\n          case SUBLANG_MALTESE_MALTA: return \"mt_MT\";\n          }\n        return \"mt\";\n      case LANG_MANIPURI:\n        /* FIXME: Adjust this when such locales appear on Unix.  */\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"mni_IN\";\n          }\n        return \"mni\";\n      case LANG_MAORI:\n        switch (sub)\n          {\n          case SUBLANG_MAORI_NEW_ZEALAND: return \"mi_NZ\";\n          }\n        return \"mi\";\n      case LANG_MAPUDUNGUN:\n        switch (sub)\n          {\n          case SUBLANG_MAPUDUNGUN_CHILE: return \"arn_CL\";\n          }\n        return \"arn\";\n      case LANG_MARATHI:\n        switch (sub)\n          {\n          case SUBLANG_MARATHI_INDIA: return \"mr_IN\";\n          }\n        return \"mr\";\n      case LANG_MOHAWK:\n        switch (sub)\n          {\n          case SUBLANG_MOHAWK_CANADA: return \"moh_CA\";\n          }\n        return \"moh\";\n      case LANG_MONGOLIAN:\n        switch (sub)\n          {\n          case SUBLANG_MONGOLIAN_CYRILLIC_MONGOLIA: case 0x1e: return \"mn_MN\";\n          case SUBLANG_MONGOLIAN_PRC: case 0x1f: return \"mn_CN\";\n          }\n        return \"mn\"; /* Ambiguous: could be \"mn_CN\" or \"mn_MN\".  */\n      case LANG_NEPALI:\n        switch (sub)\n          {\n          case SUBLANG_NEPALI_NEPAL: return \"ne_NP\";\n          case SUBLANG_NEPALI_INDIA: return \"ne_IN\";\n          }\n        return \"ne\";\n      case LANG_NORWEGIAN:\n        switch (sub)\n          {\n          case 0x1f: return \"nb\";\n          case SUBLANG_NORWEGIAN_BOKMAL: return \"nb_NO\";\n          case 0x1e: return \"nn\";\n          case SUBLANG_NORWEGIAN_NYNORSK: return \"nn_NO\";\n          }\n        return \"no\";\n      case LANG_OCCITAN:\n        switch (sub)\n          {\n          case SUBLANG_OCCITAN_FRANCE: return \"oc_FR\";\n          }\n        return \"oc\";\n      case LANG_ORIYA:\n        switch (sub)\n          {\n          case SUBLANG_ORIYA_INDIA: return \"or_IN\";\n          }\n        return \"or\";\n      case LANG_OROMO:\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"om_ET\";\n          }\n        return \"om\";\n      case LANG_PAPIAMENTU:\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"pap_AN\";\n          }\n        return \"pap\";\n      case LANG_PASHTO:\n        switch (sub)\n          {\n          case SUBLANG_PASHTO_AFGHANISTAN: return \"ps_AF\";\n          }\n        return \"ps\"; /* Ambiguous: could be \"ps_PK\" or \"ps_AF\".  */\n      case LANG_POLISH:\n        switch (sub)\n          {\n          case SUBLANG_POLISH_POLAND: return \"pl_PL\";\n          }\n        return \"pl\";\n      case LANG_PORTUGUESE:\n        switch (sub)\n          {\n          /* Hmm. SUBLANG_PORTUGUESE_BRAZILIAN == SUBLANG_DEFAULT.\n             Same phenomenon as SUBLANG_ENGLISH_US == SUBLANG_DEFAULT. */\n          case SUBLANG_PORTUGUESE_BRAZILIAN: return \"pt_BR\";\n          case SUBLANG_PORTUGUESE: return \"pt_PT\";\n          }\n        return \"pt\";\n      case LANG_PUNJABI:\n        switch (sub)\n          {\n          case SUBLANG_PUNJABI_INDIA: return \"pa_IN\"; /* Gurmukhi script */\n          case SUBLANG_PUNJABI_PAKISTAN: return \"pa_PK\"; /* Arabic script */\n          }\n        return \"pa\";\n      case LANG_QUECHUA:\n        /* Note: Microsoft uses the non-ISO language code \"quz\".  */\n        switch (sub)\n          {\n          case SUBLANG_QUECHUA_BOLIVIA: return \"qu_BO\";\n          case SUBLANG_QUECHUA_ECUADOR: return \"qu_EC\";\n          case SUBLANG_QUECHUA_PERU: return \"qu_PE\";\n          }\n        return \"qu\";\n      case LANG_ROMANIAN:\n        switch (sub)\n          {\n          case SUBLANG_ROMANIAN_ROMANIA: return \"ro_RO\";\n          case SUBLANG_ROMANIAN_MOLDOVA: return \"ro_MD\";\n          }\n        return \"ro\";\n      case LANG_ROMANSH:\n        switch (sub)\n          {\n          case SUBLANG_ROMANSH_SWITZERLAND: return \"rm_CH\";\n          }\n        return \"rm\";\n      case LANG_RUSSIAN:\n        switch (sub)\n          {\n          case SUBLANG_RUSSIAN_RUSSIA: return \"ru_RU\";\n          case SUBLANG_RUSSIAN_MOLDAVIA: return \"ru_MD\";\n          }\n        return \"ru\"; /* Ambiguous: could be \"ru_RU\" or \"ru_UA\" or \"ru_MD\".  */\n      case LANG_SAMI:\n        switch (sub)\n          {\n          /* Northern Sami */\n          case 0x00: return \"se\";\n          case SUBLANG_SAMI_NORTHERN_NORWAY: return \"se_NO\";\n          case SUBLANG_SAMI_NORTHERN_SWEDEN: return \"se_SE\";\n          case SUBLANG_SAMI_NORTHERN_FINLAND: return \"se_FI\";\n          /* Lule Sami */\n          case 0x1f: return \"smj\";\n          case SUBLANG_SAMI_LULE_NORWAY: return \"smj_NO\";\n          case SUBLANG_SAMI_LULE_SWEDEN: return \"smj_SE\";\n          /* Southern Sami */\n          case 0x1e: return \"sma\";\n          case SUBLANG_SAMI_SOUTHERN_NORWAY: return \"sma_NO\";\n          case SUBLANG_SAMI_SOUTHERN_SWEDEN: return \"sma_SE\";\n          /* Skolt Sami */\n          case 0x1d: return \"sms\";\n          case SUBLANG_SAMI_SKOLT_FINLAND: return \"sms_FI\";\n          /* Inari Sami */\n          case 0x1c: return \"smn\";\n          case SUBLANG_SAMI_INARI_FINLAND: return \"smn_FI\";\n          }\n        return \"se\"; /* or \"smi\"? */\n      case LANG_SANSKRIT:\n        switch (sub)\n          {\n          case SUBLANG_SANSKRIT_INDIA: return \"sa_IN\";\n          }\n        return \"sa\";\n      case LANG_SCOTTISH_GAELIC:\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"gd_GB\";\n          }\n        return \"gd\";\n      case LANG_SINDHI:\n        switch (sub)\n          {\n          case SUBLANG_SINDHI_INDIA: return \"sd_IN\";\n          case SUBLANG_SINDHI_PAKISTAN: return \"sd_PK\";\n          /*case SUBLANG_SINDHI_AFGHANISTAN: return \"sd_AF\";*/\n          }\n        return \"sd\";\n      case LANG_SINHALESE:\n        switch (sub)\n          {\n          case SUBLANG_SINHALESE_SRI_LANKA: return \"si_LK\";\n          }\n        return \"si\";\n      case LANG_SLOVAK:\n        switch (sub)\n          {\n          case SUBLANG_SLOVAK_SLOVAKIA: return \"sk_SK\";\n          }\n        return \"sk\";\n      case LANG_SLOVENIAN:\n        switch (sub)\n          {\n          case SUBLANG_SLOVENIAN_SLOVENIA: return \"sl_SI\";\n          }\n        return \"sl\";\n      case LANG_SOMALI:\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"so_SO\";\n          }\n        return \"so\";\n      case LANG_SORBIAN:\n        /* FIXME: Adjust this when such locales appear on Unix.  */\n        switch (sub)\n          {\n          /* Upper Sorbian */\n          case 0x00: return \"hsb\";\n          case SUBLANG_UPPER_SORBIAN_GERMANY: return \"hsb_DE\";\n          /* Lower Sorbian */\n          case 0x1f: return \"dsb\";\n          case SUBLANG_LOWER_SORBIAN_GERMANY: return \"dsb_DE\";\n          }\n        return \"wen\";\n      case LANG_SOTHO:\n        /* <http://www.microsoft.com/globaldev/reference/lcid-all.mspx> calls\n           it \"Sepedi\"; according to\n           <http://www.ethnologue.com/show_language.asp?code=nso>\n           <http://www.ethnologue.com/show_language.asp?code=sot>\n           it's the same as Northern Sotho.  */\n        switch (sub)\n          {\n          case SUBLANG_SOTHO_SOUTH_AFRICA: return \"nso_ZA\";\n          }\n        return \"nso\";\n      case LANG_SPANISH:\n        switch (sub)\n          {\n          case SUBLANG_SPANISH: return \"es_ES\";\n          case SUBLANG_SPANISH_MEXICAN: return \"es_MX\";\n          case SUBLANG_SPANISH_MODERN:\n            return \"es_ES@modern\";      /* not seen on Unix */\n          case SUBLANG_SPANISH_GUATEMALA: return \"es_GT\";\n          case SUBLANG_SPANISH_COSTA_RICA: return \"es_CR\";\n          case SUBLANG_SPANISH_PANAMA: return \"es_PA\";\n          case SUBLANG_SPANISH_DOMINICAN_REPUBLIC: return \"es_DO\";\n          case SUBLANG_SPANISH_VENEZUELA: return \"es_VE\";\n          case SUBLANG_SPANISH_COLOMBIA: return \"es_CO\";\n          case SUBLANG_SPANISH_PERU: return \"es_PE\";\n          case SUBLANG_SPANISH_ARGENTINA: return \"es_AR\";\n          case SUBLANG_SPANISH_ECUADOR: return \"es_EC\";\n          case SUBLANG_SPANISH_CHILE: return \"es_CL\";\n          case SUBLANG_SPANISH_URUGUAY: return \"es_UY\";\n          case SUBLANG_SPANISH_PARAGUAY: return \"es_PY\";\n          case SUBLANG_SPANISH_BOLIVIA: return \"es_BO\";\n          case SUBLANG_SPANISH_EL_SALVADOR: return \"es_SV\";\n          case SUBLANG_SPANISH_HONDURAS: return \"es_HN\";\n          case SUBLANG_SPANISH_NICARAGUA: return \"es_NI\";\n          case SUBLANG_SPANISH_PUERTO_RICO: return \"es_PR\";\n          case SUBLANG_SPANISH_US: return \"es_US\";\n          }\n        return \"es\";\n      case LANG_SUTU:\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"bnt_TZ\"; /* or \"st_LS\" or \"nso_ZA\"? */\n          }\n        return \"bnt\";\n      case LANG_SWAHILI:\n        switch (sub)\n          {\n          case SUBLANG_SWAHILI_KENYA: return \"sw_KE\";\n          }\n        return \"sw\";\n      case LANG_SWEDISH:\n        switch (sub)\n          {\n          case SUBLANG_SWEDISH_SWEDEN: return \"sv_SE\";\n          case SUBLANG_SWEDISH_FINLAND: return \"sv_FI\";\n          }\n        return \"sv\";\n      case LANG_SYRIAC:\n        switch (sub)\n          {\n          case SUBLANG_SYRIAC_SYRIA: return \"syr_SY\"; /* An extinct language.  */\n          }\n        return \"syr\";\n      case LANG_TAGALOG:\n        switch (sub)\n          {\n          case SUBLANG_TAGALOG_PHILIPPINES: return \"tl_PH\"; /* or \"fil_PH\"? */\n          }\n        return \"tl\"; /* or \"fil\"? */\n      case LANG_TAJIK:\n        switch (sub)\n          {\n          case 0x1f: return \"tg\";\n          case SUBLANG_TAJIK_TAJIKISTAN: return \"tg_TJ\";\n          }\n        return \"tg\";\n      case LANG_TAMAZIGHT:\n        /* Note: Microsoft uses the non-ISO language code \"tmz\".  */\n        switch (sub)\n          {\n          /* FIXME: Adjust this when Tamazight locales appear on Unix.  */\n          case SUBLANG_TAMAZIGHT_ARABIC: return \"ber_MA@arabic\";\n          case 0x1f: return \"ber@latin\";\n          case SUBLANG_TAMAZIGHT_ALGERIA_LATIN: return \"ber_DZ@latin\";\n          }\n        return \"ber\";\n      case LANG_TAMIL:\n        switch (sub)\n          {\n          case SUBLANG_TAMIL_INDIA: return \"ta_IN\";\n          }\n        return \"ta\"; /* Ambiguous: could be \"ta_IN\" or \"ta_LK\" or \"ta_SG\".  */\n      case LANG_TATAR:\n        switch (sub)\n          {\n          case SUBLANG_TATAR_RUSSIA: return \"tt_RU\";\n          }\n        return \"tt\";\n      case LANG_TELUGU:\n        switch (sub)\n          {\n          case SUBLANG_TELUGU_INDIA: return \"te_IN\";\n          }\n        return \"te\";\n      case LANG_THAI:\n        switch (sub)\n          {\n          case SUBLANG_THAI_THAILAND: return \"th_TH\";\n          }\n        return \"th\";\n      case LANG_TIBETAN:\n        switch (sub)\n          {\n          case SUBLANG_TIBETAN_PRC:\n            /* Most Tibetans would not like \"bo_CN\".  But Tibet does not yet\n               have a country code of its own.  */\n            return \"bo\";\n          case SUBLANG_TIBETAN_BHUTAN: return \"bo_BT\";\n          }\n        return \"bo\";\n      case LANG_TIGRINYA:\n        switch (sub)\n          {\n          case SUBLANG_TIGRINYA_ETHIOPIA: return \"ti_ET\";\n          case SUBLANG_TIGRINYA_ERITREA: return \"ti_ER\";\n          }\n        return \"ti\";\n      case LANG_TSONGA:\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"ts_ZA\";\n          }\n        return \"ts\";\n      case LANG_TSWANA:\n        /* Spoken in South Africa, Botswana.  */\n        switch (sub)\n          {\n          case SUBLANG_TSWANA_SOUTH_AFRICA: return \"tn_ZA\";\n          }\n        return \"tn\";\n      case LANG_TURKISH:\n        switch (sub)\n          {\n          case SUBLANG_TURKISH_TURKEY: return \"tr_TR\";\n          }\n        return \"tr\";\n      case LANG_TURKMEN:\n        switch (sub)\n          {\n          case SUBLANG_TURKMEN_TURKMENISTAN: return \"tk_TM\";\n          }\n        return \"tk\";\n      case LANG_UIGHUR:\n        switch (sub)\n          {\n          case SUBLANG_UIGHUR_PRC: return \"ug_CN\";\n          }\n        return \"ug\";\n      case LANG_UKRAINIAN:\n        switch (sub)\n          {\n          case SUBLANG_UKRAINIAN_UKRAINE: return \"uk_UA\";\n          }\n        return \"uk\";\n      case LANG_URDU:\n        switch (sub)\n          {\n          case SUBLANG_URDU_PAKISTAN: return \"ur_PK\";\n          case SUBLANG_URDU_INDIA: return \"ur_IN\";\n          }\n        return \"ur\";\n      case LANG_UZBEK:\n        switch (sub)\n          {\n          case 0x1f: return \"uz\";\n          case SUBLANG_UZBEK_LATIN: return \"uz_UZ\";\n          case 0x1e: return \"uz@cyrillic\";\n          case SUBLANG_UZBEK_CYRILLIC: return \"uz_UZ@cyrillic\";\n          }\n        return \"uz\";\n      case LANG_VENDA:\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"ve_ZA\";\n          }\n        return \"ve\";\n      case LANG_VIETNAMESE:\n        switch (sub)\n          {\n          case SUBLANG_VIETNAMESE_VIETNAM: return \"vi_VN\";\n          }\n        return \"vi\";\n      case LANG_WELSH:\n        switch (sub)\n          {\n          case SUBLANG_WELSH_UNITED_KINGDOM: return \"cy_GB\";\n          }\n        return \"cy\";\n      case LANG_WOLOF:\n        switch (sub)\n          {\n          case SUBLANG_WOLOF_SENEGAL: return \"wo_SN\";\n          }\n        return \"wo\";\n      case LANG_XHOSA:\n        switch (sub)\n          {\n          case SUBLANG_XHOSA_SOUTH_AFRICA: return \"xh_ZA\";\n          }\n        return \"xh\";\n      case LANG_YAKUT:\n        switch (sub)\n          {\n          case SUBLANG_YAKUT_RUSSIA: return \"sah_RU\";\n          }\n        return \"sah\";\n      case LANG_YI:\n        switch (sub)\n          {\n          case SUBLANG_YI_PRC: return \"ii_CN\";\n          }\n        return \"ii\";\n      case LANG_YIDDISH:\n        switch (sub)\n          {\n          case SUBLANG_DEFAULT: return \"yi_IL\";\n          }\n        return \"yi\";\n      case LANG_YORUBA:\n        switch (sub)\n          {\n          case SUBLANG_YORUBA_NIGERIA: return \"yo_NG\";\n          }\n        return \"yo\";\n      case LANG_ZULU:\n        switch (sub)\n          {\n          case SUBLANG_ZULU_SOUTH_AFRICA: return \"zu_ZA\";\n          }\n        return \"zu\";\n      default: return \"C\";\n      }\n  }\n}",
      "lines": 1044,
      "depth": 12,
      "decorators": [
        "const",
        "const",
        "char",
        "*\ngl_locale_name_from_win32_LANGID (LANGID langid)",
        "*"
      ]
    },
    "gl_locale_name_from_win32_LCID": {
      "start_point": [
        2506,
        0
      ],
      "end_point": [
        2515,
        1
      ],
      "content": "const char *\ngl_locale_name_from_win32_LCID (LCID lcid)\n{\n  LANGID langid;\n\n  /* Strip off the sorting rules, keep only the language part.  */\n  langid = LANGIDFROMLCID (lcid);\n\n  return gl_locale_name_from_win32_LANGID (langid);\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "const",
        "const",
        "char",
        "*\ngl_locale_name_from_win32_LCID (LCID lcid)",
        "*"
      ]
    },
    "enum_locales_fn": {
      "start_point": [
        2525,
        0
      ],
      "end_point": [
        2551,
        1
      ],
      "content": "static BOOL CALLBACK\nenum_locales_fn (LPTSTR locale_num_str)\n{\n  char *endp;\n  char locval[2 * LOCALE_NAME_MAX_LENGTH + 1 + 1];\n  LCID try_lcid = strtoul (locale_num_str, &endp, 16);\n\n  if (GetLocaleInfo (try_lcid, LOCALE_SENGLANGUAGE,\n                    locval, LOCALE_NAME_MAX_LENGTH))\n    {\n      strcat (locval, \"_\");\n      if (GetLocaleInfo (try_lcid, LOCALE_SENGCOUNTRY,\n                        locval + strlen (locval), LOCALE_NAME_MAX_LENGTH))\n       {\n         size_t locval_len = strlen (locval);\n\n         if (strncmp (locval, lname, locval_len) == 0\n             && (lname[locval_len] == '.'\n                 || lname[locval_len] == '\\0'))\n           {\n             found_lcid = try_lcid;\n             return FALSE;\n           }\n       }\n    }\n  return TRUE;\n}",
      "lines": 27,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "BOOL",
        "CALLBACK",
        "CALLBACK"
      ]
    },
    "get_lcid": {
      "start_point": [
        2560,
        0
      ],
      "end_point": [
        2586,
        1
      ],
      "content": "static LCID\nget_lcid (const char *locale_name)\n{\n  /* A simple cache.  */\n  static LCID last_lcid;\n  static char last_locale[1000];\n\n  /* Lock while looking for an LCID, to protect access to static\n     variables: last_lcid, last_locale, found_lcid, and lname.  */\n  gl_lock_lock (get_lcid_lock);\n  if (last_lcid > 0 && strcmp (locale_name, last_locale) == 0)\n    {\n      gl_lock_unlock (get_lcid_lock);\n      return last_lcid;\n    }\n  strncpy (lname, locale_name, sizeof (lname) - 1);\n  lname[sizeof (lname) - 1] = '\\0';\n  found_lcid = 0;\n  EnumSystemLocales (enum_locales_fn, LCID_SUPPORTED);\n  if (found_lcid > 0)\n    {\n      last_lcid = found_lcid;\n      strcpy (last_locale, locale_name);\n    }\n  gl_lock_unlock (get_lcid_lock);\n  return found_lcid;\n}",
      "lines": 27,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "LCID"
      ]
    },
    "string_hash": {
      "start_point": [
        2602,
        0
      ],
      "end_point": [
        2612,
        1
      ],
      "content": "static size_t _GL_ATTRIBUTE_PURE\nstring_hash (const void *x)\n{\n  const char *s = (const char *) x;\n  size_t h = 0;\n\n  for (; *s; s++)\n    h = *s + ((h << 9) | (h >> (SIZE_BITS - 9)));\n\n  return h;\n}",
      "lines": 11,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "size_t",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "struniq": {
      "start_point": [
        2634,
        0
      ],
      "end_point": [
        2672,
        1
      ],
      "content": "static const char *\nstruniq (const char *string)\n{\n  size_t hashcode = string_hash (string);\n  size_t slot = hashcode % HASH_TABLE_SIZE;\n  size_t size;\n  struct hash_node *new_node;\n  struct hash_node *p;\n  for (p = struniq_hash_table[slot]; p != NULL; p = p->next)\n    if (strcmp (p->contents, string) == 0)\n      return p->contents;\n  size = strlen (string) + 1;\n  new_node =\n    (struct hash_node *)\n    malloc (offsetof (struct hash_node, contents[0]) + size);\n  if (new_node == NULL)\n    /* Out of memory.  Return a statically allocated string.  */\n    return \"C\";\n  memcpy (new_node->contents, string, size);\n  /* Lock while inserting new_node.  */\n  gl_lock_lock (struniq_lock);\n  /* Check whether another thread already added the string while we were\n     waiting on the lock.  */\n  for (p = struniq_hash_table[slot]; p != NULL; p = p->next)\n    if (strcmp (p->contents, string) == 0)\n      {\n        free (new_node);\n        new_node = p;\n        goto done;\n      }\n  /* Really insert new_node into the hash table.  Fill new_node entirely first,\n     because other threads may be iterating over the linked list.  */\n  new_node->next = struniq_hash_table[slot];\n  struniq_hash_table[slot] = new_node;\n done:\n  /* Unlock after new_node is inserted.  */\n  gl_lock_unlock (struniq_lock);\n  return new_node->contents;\n}",
      "lines": 39,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nstruniq (const char *string)",
        "*"
      ]
    },
    "gl_locale_name_thread_unsafe": {
      "start_point": [
        2684,
        0
      ],
      "end_point": [
        2741,
        1
      ],
      "content": "const char *\ngl_locale_name_thread_unsafe (int category, const char *categoryname)\n{\n# if HAVE_USELOCALE\n  {\n    locale_t thread_locale = uselocale (NULL);\n    if (thread_locale != LC_GLOBAL_LOCALE)\n      {\n#  if __GLIBC__ >= 2 && !defined __UCLIBC__\n        /* Work around an incorrect definition of the _NL_LOCALE_NAME macro in\n           glibc < 2.12.\n           See <http://sourceware.org/bugzilla/show_bug.cgi?id=10968>.  */\n        const char *name =\n          nl_langinfo (_NL_ITEM ((category), _NL_ITEM_INDEX (-1)));\n        if (name[0] == '\\0')\n          /* Fallback code for glibc < 2.4, which did not implement\n             nl_langinfo (_NL_LOCALE_NAME (category)).  */\n          name = thread_locale->__names[category];\n        return name;\n#  elif defined __FreeBSD__ || (defined __APPLE__ && defined __MACH__)\n        /* FreeBSD, Mac OS X */\n        int mask;\n\n        switch (category)\n          {\n          case LC_CTYPE:\n            mask = LC_CTYPE_MASK;\n            break;\n          case LC_NUMERIC:\n            mask = LC_NUMERIC_MASK;\n            break;\n          case LC_TIME:\n            mask = LC_TIME_MASK;\n            break;\n          case LC_COLLATE:\n            mask = LC_COLLATE_MASK;\n            break;\n          case LC_MONETARY:\n            mask = LC_MONETARY_MASK;\n            break;\n          case LC_MESSAGES:\n            mask = LC_MESSAGES_MASK;\n            break;\n          default: /* We shouldn't get here.  */\n            return \"\";\n          }\n        return querylocale (mask, thread_locale);\n#  elif defined __sun && HAVE_GETLOCALENAME_L\n        /* Solaris >= 12.  */\n        return getlocalename_l (category, thread_locale);\n#  elif defined __ANDROID__\n        return MB_CUR_MAX == 4 ? \"C.UTF-8\" : \"C\";\n#  endif\n      }\n  }\n# endif\n  return NULL;\n}",
      "lines": 58,
      "depth": 16,
      "decorators": [
        "const",
        "const",
        "char",
        "*\ngl_locale_name_thread_unsafe (int category, const char *categoryname)",
        "*"
      ]
    },
    "gl_locale_name_thread": {
      "start_point": [
        2745,
        0
      ],
      "end_point": [
        2775,
        1
      ],
      "content": "const char *\ngl_locale_name_thread (int category, const char *categoryname)\n{\n#if HAVE_USELOCALE\n  const char *name = gl_locale_name_thread_unsafe (category, categoryname);\n  if (name != NULL)\n    return struniq (name);\n#elif defined WINDOWS_NATIVE\n  if (LC_MIN <= category && category <= LC_MAX)\n    {\n      char *locname = setlocale (category, NULL);\n      LCID lcid = 0;\n\n      /* If CATEGORY is LC_ALL, the result might be a semi-colon\n        separated list of locales.  We need only one, so we take the\n        one corresponding to LC_CTYPE, as the most important for\n        character translations.  */\n      if (strchr (locname, ';'))\n       locname = setlocale (LC_CTYPE, NULL);\n\n      /* Convert locale name to LCID.  We don't want to use\n         LocaleNameToLCID because (a) it is only available since Vista,\n         and (b) it doesn't accept locale names returned by 'setlocale'.  */\n      lcid = get_lcid (locname);\n\n      if (lcid > 0)\n        return gl_locale_name_from_win32_LCID (lcid);\n    }\n#endif\n  return NULL;\n}",
      "lines": 31,
      "depth": 12,
      "decorators": [
        "const",
        "const",
        "char",
        "*\ngl_locale_name_thread (int category, const char *categoryname)",
        "*"
      ]
    },
    "gl_locale_name_posix": {
      "start_point": [
        2787,
        0
      ],
      "end_point": [
        2814,
        1
      ],
      "content": "const char *\ngl_locale_name_posix (int category, const char *categoryname)\n{\n  /* Use the POSIX methods of looking to 'LC_ALL', 'LC_xxx', and 'LANG'.\n     On some systems this can be done by the 'setlocale' function itself.  */\n#if defined HAVE_SETLOCALE && defined HAVE_LC_MESSAGES && defined HAVE_LOCALE_NULL\n  return setlocale (category, NULL);\n#else\n  /* On other systems we ignore what setlocale reports and instead look at the\n     environment variables directly.  This is necessary\n       1. on systems which have a facility for customizing the default locale\n          (Mac OS X, native Windows, Cygwin) and where the system's setlocale()\n          function ignores this default locale (Mac OS X, Cygwin), in two cases:\n          a. when the user missed to use the setlocale() override from libintl\n             (for example by not including <libintl.h>),\n          b. when setlocale supports only the \"C\" locale, such as on Cygwin\n             1.5.x.  In this case even the override from libintl cannot help.\n       2. on all systems where setlocale supports only the \"C\" locale.  */\n  /* Strictly speaking, it is a POSIX violation to look at the environment\n     variables regardless whether setlocale has been called or not.  POSIX\n     says:\n         \"For C-language programs, the POSIX locale shall be the\n          default locale when the setlocale() function is not called.\"\n     But we assume that all programs that use internationalized APIs call\n     setlocale (LC_ALL, \"\").  */\n  return gl_locale_name_environ (category, categoryname);\n#endif\n}",
      "lines": 28,
      "depth": 8,
      "decorators": [
        "const",
        "const",
        "char",
        "*\ngl_locale_name_posix (int category, const char *categoryname)",
        "*"
      ]
    },
    "gl_locale_name_environ": {
      "start_point": [
        2816,
        0
      ],
      "end_point": [
        2847,
        1
      ],
      "content": "const char *\ngl_locale_name_environ (int category, const char *categoryname)\n{\n  const char *retval;\n\n  /* Setting of LC_ALL overrides all other.  */\n  retval = getenv (\"LC_ALL\");\n  if (retval != NULL && retval[0] != '\\0')\n    return retval;\n  /* Next comes the name of the desired category.  */\n  retval = getenv (categoryname);\n  if (retval != NULL && retval[0] != '\\0')\n    return retval;\n  /* Last possibility is the LANG environment variable.  */\n  retval = getenv (\"LANG\");\n  if (retval != NULL && retval[0] != '\\0')\n    {\n#if HAVE_CFLOCALECOPYCURRENT || HAVE_CFPREFERENCESCOPYAPPVALUE\n      /* Mac OS X 10.2 or newer.\n         Ignore invalid LANG value set by the Terminal application.  */\n      if (strcmp (retval, \"UTF-8\") != 0)\n#endif\n#if defined __CYGWIN__\n      /* Cygwin.\n         Ignore dummy LANG value set by ~/.profile.  */\n      if (strcmp (retval, \"C.UTF-8\") != 0)\n#endif\n        return retval;\n    }\n\n  return NULL;\n}",
      "lines": 32,
      "depth": 12,
      "decorators": [
        "const",
        "const",
        "char",
        "*\ngl_locale_name_environ (int category, const char *categoryname)",
        "*"
      ]
    },
    "gl_locale_name_default": {
      "start_point": [
        2849,
        0
      ],
      "end_point": [
        2946,
        1
      ],
      "content": "const char *\ngl_locale_name_default (void)\n{\n  /* POSIX:2001 says:\n     \"All implementations shall define a locale as the default locale, to be\n      invoked when no environment variables are set, or set to the empty\n      string.  This default locale can be the POSIX locale or any other\n      implementation-defined locale.  Some implementations may provide\n      facilities for local installation administrators to set the default\n      locale, customizing it for each location.  POSIX:2001 does not require\n      such a facility.\n\n     The systems with such a facility are Mac OS X and Windows: They provide a\n     GUI that allows the user to choose a locale.\n       - On Mac OS X, by default, none of LC_* or LANG are set.  Starting with\n         Mac OS X 10.4 or 10.5, LANG is set for processes launched by the\n         'Terminal' application (but sometimes to an incorrect value \"UTF-8\").\n         When no environment variable is set, setlocale (LC_ALL, \"\") uses the\n         \"C\" locale.\n       - On native Windows, by default, none of LC_* or LANG are set.\n         When no environment variable is set, setlocale (LC_ALL, \"\") uses the\n         locale chosen by the user.\n       - On Cygwin 1.5.x, by default, none of LC_* or LANG are set.\n         When no environment variable is set, setlocale (LC_ALL, \"\") uses the\n         \"C\" locale.\n       - On Cygwin 1.7, by default, LANG is set to \"C.UTF-8\" when the default\n         ~/.profile is executed.\n         When no environment variable is set, setlocale (LC_ALL, \"\") uses the\n         \"C.UTF-8\" locale, which operates in the same way as the \"C\" locale.\n  */\n\n#if !(HAVE_CFLOCALECOPYCURRENT || HAVE_CFPREFERENCESCOPYAPPVALUE || defined WINDOWS_NATIVE || defined __CYGWIN__)\n\n  /* The system does not have a way of setting the locale, other than the\n     POSIX specified environment variables.  We use C as default locale.  */\n  return \"C\";\n\n#else\n\n  /* Return an XPG style locale name language[_territory][@modifier].\n     Don't even bother determining the codeset; it's not useful in this\n     context, because message catalogs are not specific to a single\n     codeset.  */\n\n# if HAVE_CFLOCALECOPYCURRENT || HAVE_CFPREFERENCESCOPYAPPVALUE\n  /* Mac OS X 10.2 or newer */\n  {\n    /* Cache the locale name, since CoreFoundation calls are expensive.  */\n    static const char *cached_localename;\n\n    if (cached_localename == NULL)\n      {\n        char namebuf[256];\n#  if HAVE_CFLOCALECOPYCURRENT /* Mac OS X 10.3 or newer */\n        CFLocaleRef locale = CFLocaleCopyCurrent ();\n        CFStringRef name = CFLocaleGetIdentifier (locale);\n\n        if (CFStringGetCString (name, namebuf, sizeof (namebuf),\n                                kCFStringEncodingASCII))\n          {\n            gl_locale_name_canonicalize (namebuf);\n            cached_localename = strdup (namebuf);\n          }\n        CFRelease (locale);\n#  elif HAVE_CFPREFERENCESCOPYAPPVALUE /* Mac OS X 10.2 or newer */\n        CFTypeRef value =\n          CFPreferencesCopyAppValue (CFSTR (\"AppleLocale\"),\n                                     kCFPreferencesCurrentApplication);\n        if (value != NULL\n            && CFGetTypeID (value) == CFStringGetTypeID ()\n            && CFStringGetCString ((CFStringRef)value,\n                                   namebuf, sizeof (namebuf),\n                                   kCFStringEncodingASCII))\n          {\n            gl_locale_name_canonicalize (namebuf);\n            cached_localename = strdup (namebuf);\n          }\n#  endif\n        if (cached_localename == NULL)\n          cached_localename = \"C\";\n      }\n    return cached_localename;\n  }\n\n# endif\n\n# if defined WINDOWS_NATIVE || defined __CYGWIN__ /* Native Windows or Cygwin */\n  {\n    LCID lcid;\n\n    /* Use native Windows API locale ID.  */\n    lcid = GetThreadLocale ();\n\n    return gl_locale_name_from_win32_LCID (lcid);\n  }\n# endif\n#endif\n}",
      "lines": 98,
      "depth": 18,
      "decorators": [
        "const",
        "const",
        "char",
        "*\ngl_locale_name_default (void)",
        "*"
      ]
    },
    "gl_locale_name": {
      "start_point": [
        2954,
        0
      ],
      "end_point": [
        2968,
        1
      ],
      "content": "const char *\ngl_locale_name (int category, const char *categoryname)\n{\n  const char *retval;\n\n  retval = gl_locale_name_thread (category, categoryname);\n  if (retval != NULL)\n    return retval;\n\n  retval = gl_locale_name_posix (category, categoryname);\n  if (retval != NULL)\n    return retval;\n\n  return gl_locale_name_default ();\n}",
      "lines": 15,
      "depth": 7,
      "decorators": [
        "const",
        "const",
        "char",
        "*\ngl_locale_name (int category, const char *categoryname)",
        "*"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/localename.h": {},
  "findutils/findutils-4.6.0/tests/macros.h": {},
  "findutils/findutils-4.6.0/tests/minus-zero.h": {
    "compute_minus_zerof": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        32,
        1
      ],
      "content": "static float\ncompute_minus_zerof (void)\n{\n  return -FLT_MIN * FLT_MIN;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "float"
      ]
    },
    "compute_minus_zerod": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "static double\ncompute_minus_zerod (void)\n{\n  return -DBL_MIN * DBL_MIN;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "compute_minus_zerol": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        69,
        1
      ],
      "content": "static long double\ncompute_minus_zerol (void)\n{\n  return -LDBL_MIN * LDBL_MIN;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "long double",
        "long",
        "double"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/nan.h": {
    "NaNf": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        27,
        1
      ],
      "content": "static float\nNaNf ()\n{\n  static float zero = 0.0f;\n  return zero / zero;\n}",
      "lines": 6,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "float"
      ]
    },
    "NaNd": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "static double\nNaNd ()\n{\n  static double zero = 0.0;\n  return zero / zero;\n}",
      "lines": 6,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "NaNl": [
      {
        "start_point": [
          55,
          0
        ],
        "end_point": [
          59,
          1
        ],
        "content": "static long double NaNl ()\n{\n  double zero = 0.0;\n  return zero / zero;\n}",
        "lines": 5,
        "depth": 5,
        "decorators": [
          "static",
          "static",
          "long double",
          "long",
          "double"
        ]
      },
      {
        "start_point": [
          61,
          0
        ],
        "end_point": [
          66,
          1
        ],
        "content": "static long double\nNaNl ()\n{\n  static long double zero = 0.0L;\n  return zero / zero;\n}",
        "lines": 6,
        "depth": 5,
        "decorators": [
          "static",
          "static",
          "long double",
          "long",
          "double"
        ]
      }
    ]
  },
  "findutils/findutils-4.6.0/tests/nanosleep.c": {
    "nanosleep": [
      {
        "start_point": [
          100,
          0
        ],
        "end_point": [
          180,
          1
        ],
        "content": "int\nnanosleep (const struct timespec *requested_delay,\n           struct timespec *remaining_delay)\n{\n  static bool initialized;\n  /* Number of performance counter increments per nanosecond,\n     or zero if it could not be determined.  */\n  static double ticks_per_nanosecond;\n\n  if (requested_delay->tv_nsec < 0 || BILLION <= requested_delay->tv_nsec)\n    {\n      errno = EINVAL;\n      return -1;\n    }\n\n  /* For requested delays of one second or more, 15ms resolution is\n     sufficient.  */\n  if (requested_delay->tv_sec == 0)\n    {\n      if (!initialized)\n        {\n          /* Initialize ticks_per_nanosecond.  */\n          LARGE_INTEGER ticks_per_second;\n\n          if (QueryPerformanceFrequency (&ticks_per_second))\n            ticks_per_nanosecond =\n              (double) ticks_per_second.QuadPart / 1000000000.0;\n\n          initialized = true;\n        }\n      if (ticks_per_nanosecond)\n        {\n          /* QueryPerformanceFrequency worked.  We can use\n             QueryPerformanceCounter.  Use a combination of Sleep and\n             busy-looping.  */\n          /* Number of milliseconds to pass to the Sleep function.\n             Since Sleep can take up to 8 ms less or 8 ms more than requested\n             (or maybe more if the system is loaded), we subtract 10 ms.  */\n          int sleep_millis = (int) requested_delay->tv_nsec / 1000000 - 10;\n          /* Determine how many ticks to delay.  */\n          LONGLONG wait_ticks = requested_delay->tv_nsec * ticks_per_nanosecond;\n          /* Start.  */\n          LARGE_INTEGER counter_before;\n          if (QueryPerformanceCounter (&counter_before))\n            {\n              /* Wait until the performance counter has reached this value.\n                 We don't need to worry about overflow, because the performance\n                 counter is reset at reboot, and with a frequency of 3.6E6\n                 ticks per second 63 bits suffice for over 80000 years.  */\n              LONGLONG wait_until = counter_before.QuadPart + wait_ticks;\n              /* Use Sleep for the longest part.  */\n              if (sleep_millis > 0)\n                Sleep (sleep_millis);\n              /* Busy-loop for the rest.  */\n              for (;;)\n                {\n                  LARGE_INTEGER counter_after;\n                  if (!QueryPerformanceCounter (&counter_after))\n                    /* QueryPerformanceCounter failed, but succeeded earlier.\n                       Should not happen.  */\n                    break;\n                  if (counter_after.QuadPart >= wait_until)\n                    /* The requested time has elapsed.  */\n                    break;\n                }\n              goto done;\n            }\n        }\n    }\n  /* Implementation for long delays and as fallback.  */\n  Sleep (requested_delay->tv_sec * 1000 + requested_delay->tv_nsec / 1000000);\n\n done:\n  /* Sleep is not interruptible.  So there is no remaining delay.  */\n  if (remaining_delay != NULL)\n    {\n      remaining_delay->tv_sec = 0;\n      remaining_delay->tv_nsec = 0;\n    }\n  return 0;\n}",
        "lines": 81,
        "depth": 17,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          226,
          0
        ],
        "end_point": [
          274,
          1
        ],
        "content": "int\nnanosleep (const struct timespec *requested_delay,\n           struct timespec *remaining_delay)\n{\n  static bool initialized;\n\n  if (requested_delay->tv_nsec < 0 || BILLION <= requested_delay->tv_nsec)\n    {\n      errno = EINVAL;\n      return -1;\n    }\n\n  /* set up sig handler */\n  if (! initialized)\n    {\n      struct sigaction oldact;\n\n      sigaction (SIGCONT, NULL, &oldact);\n      if (get_handler (&oldact) != SIG_IGN)\n        {\n          struct sigaction newact;\n\n          newact.sa_handler = sighandler;\n          sigemptyset (&newact.sa_mask);\n          newact.sa_flags = 0;\n          sigaction (SIGCONT, &newact, NULL);\n        }\n      initialized = true;\n    }\n\n  suspended = 0;\n\n  if (my_usleep (requested_delay) == -1)\n    {\n      if (suspended)\n        {\n          /* Calculate time remaining.  */\n          /* FIXME: the code in sleep doesn't use this, so there's no\n             rush to implement it.  */\n\n          errno = EINTR;\n        }\n      return -1;\n    }\n\n  /* FIXME: Restore sig handler?  */\n\n  return 0;\n}",
        "lines": 49,
        "depth": 12,
        "decorators": [
          "int"
        ]
      }
    ],
    "sighandler": {
      "start_point": [
        196,
        0
      ],
      "end_point": [
        200,
        1
      ],
      "content": "static void\nsighandler (int sig)\n{\n  suspended = 1;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "my_usleep": {
      "start_point": [
        204,
        0
      ],
      "end_point": [
        221,
        1
      ],
      "content": "static int\nmy_usleep (const struct timespec *ts_delay)\n{\n  struct timeval tv_delay;\n  tv_delay.tv_sec = ts_delay->tv_sec;\n  tv_delay.tv_usec = (ts_delay->tv_nsec + 999) / 1000;\n  if (tv_delay.tv_usec == 1000000)\n    {\n      if (tv_delay.tv_sec == TYPE_MAXIMUM (time_t))\n        tv_delay.tv_usec = 1000000 - 1; /* close enough */\n      else\n        {\n          tv_delay.tv_sec++;\n          tv_delay.tv_usec = 0;\n        }\n    }\n  return select (0, NULL, NULL, NULL, &tv_delay);\n}",
      "lines": 18,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/nap.h": {
    "diff_timespec": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "static int\ndiff_timespec (struct timespec a, struct timespec b)\n{\n  time_t as = a.tv_sec;\n  time_t bs = b.tv_sec;\n  int ans = a.tv_nsec;\n  int bns = b.tv_nsec;\n\n  if (! (bs < as || (bs == as && bns < ans)))\n    return 0;\n  if (as - bs <= INT_MAX / 1000000000)\n    {\n      int sdiff = (as - bs) * 1000000000;\n      int usdiff = ans - bns;\n      if (usdiff < INT_MAX - sdiff)\n        return sdiff + usdiff;\n    }\n  return INT_MAX;\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "get_stat": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "static void\nget_stat (int fd, struct stat *st, int do_write)\n{\n  if (do_write)\n    ASSERT (write (fd, \"\\n\", 1) == 1);\n  ASSERT (fstat (fd, st) == 0);\n}",
      "lines": 7,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "nap_works": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "static bool\nnap_works (int fd, int delay, struct stat old_st)\n{\n  struct stat st;\n  struct timespec delay_spec;\n  delay_spec.tv_sec = delay / 1000000000;\n  delay_spec.tv_nsec = delay % 1000000000;\n  ASSERT (nanosleep (&delay_spec, 0) == 0);\n  get_stat (fd, &st, 1);\n\n  if (   diff_timespec (get_stat_ctime (&st), get_stat_ctime (&old_st))\n      && diff_timespec (get_stat_mtime (&st), get_stat_mtime (&old_st)))\n    return true;\n\n  return false;\n}",
      "lines": 16,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "clear_temp_file": {
      "start_point": [
        80,
        0
      ],
      "end_point": [
        88,
        1
      ],
      "content": "static void\nclear_temp_file (void)\n{\n  if (0 <= nap_fd)\n    {\n      ASSERT (close (nap_fd) != -1);\n      ASSERT (unlink (TEMPFILE) != -1);\n    }\n}",
      "lines": 9,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "nap": {
      "start_point": [
        97,
        0
      ],
      "end_point": [
        125,
        1
      ],
      "content": "static void\nnap (void)\n{\n  struct stat old_st;\n  static int delay = 1;\n\n  if (-1 == nap_fd)\n    {\n      atexit (clear_temp_file);\n      ASSERT ((nap_fd = creat (TEMPFILE, 0600)) != -1);\n      get_stat (nap_fd, &old_st, 0);\n    }\n  else\n    {\n      ASSERT (0 <= nap_fd);\n      get_stat (nap_fd, &old_st, 1);\n    }\n\n  if (1 < delay)\n    delay = delay / 2;  /* Try half of the previous delay.  */\n  ASSERT (0 < delay);\n\n  for ( ; delay <= 2147483647; delay = delay * 2)\n    if (nap_works (nap_fd, delay, old_st))\n      return;\n\n  /* Bummer: even the highest nap delay didn't work. */\n  ASSERT (0);\n}",
      "lines": 29,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/netinet_in.in.h": {},
  "findutils/findutils-4.6.0/tests/offtostr.c": {},
  "findutils/findutils-4.6.0/tests/pipe.c": {
    "pipe": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "int\npipe (int fd[2])\n{\n  /* Mingw changes fd to {-1,-1} on failure, but this violates\n     http://austingroupbugs.net/view.php?id=467 */\n  int tmp[2];\n  int result = _pipe (tmp, 4096, _O_BINARY);\n  if (!result)\n    {\n      fd[0] = tmp[0];\n      fd[1] = tmp[1];\n    }\n  return result;\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/priv-set.c": {
    "priv_set_initialize": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "static int\npriv_set_initialize (void)\n{\n  if (! initialized)\n    {\n      eff_set = priv_allocset ();\n      if (!eff_set)\n        {\n          return -1;\n        }\n      rem_set = priv_allocset ();\n      if (!rem_set)\n        {\n          priv_freeset (eff_set);\n          return -1;\n        }\n      if (getppriv (PRIV_EFFECTIVE, eff_set) != 0)\n        {\n          priv_freeset (eff_set);\n          priv_freeset (rem_set);\n          return -1;\n        }\n      priv_emptyset (rem_set);\n      initialized = true;\n    }\n\n  return 0;\n}",
      "lines": 28,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "priv_set_ismember": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "int\npriv_set_ismember (const char *priv)\n{\n  if (! initialized && priv_set_initialize () != 0)\n    return -1;\n\n  return priv_ismember (eff_set, priv);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "priv_set_remove": {
      "start_point": [
        85,
        0
      ],
      "end_point": [
        110,
        1
      ],
      "content": "int\npriv_set_remove (const char *priv)\n{\n  if (! initialized && priv_set_initialize () != 0)\n    return -1;\n\n  if (priv_ismember (eff_set, priv))\n    {\n      /* priv_addset/priv_delset can only fail if priv is invalid, which is\n         checked above by the priv_ismember call.  */\n      priv_delset (eff_set, priv);\n      if (setppriv (PRIV_SET, PRIV_EFFECTIVE, eff_set) != 0)\n        {\n          priv_addset (eff_set, priv);\n          return -1;\n        }\n      priv_addset (rem_set, priv);\n    }\n  else\n    {\n      errno = EINVAL;\n      return -1;\n    }\n\n  return 0;\n}",
      "lines": 26,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "priv_set_restore": {
      "start_point": [
        117,
        0
      ],
      "end_point": [
        142,
        1
      ],
      "content": "int\npriv_set_restore (const char *priv)\n{\n  if (! initialized && priv_set_initialize () != 0)\n    return -1;\n\n  if (priv_ismember (rem_set, priv))\n    {\n      /* priv_addset/priv_delset can only fail if priv is invalid, which is\n         checked above by the priv_ismember call.  */\n      priv_addset (eff_set, priv);\n      if (setppriv (PRIV_SET, PRIV_EFFECTIVE, eff_set) != 0)\n        {\n          priv_delset (eff_set, priv);\n          return -1;\n        }\n      priv_delset (rem_set, priv);\n    }\n  else\n    {\n      errno = EINVAL;\n      return -1;\n    }\n\n  return 0;\n}",
      "lines": 26,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/priv-set.h": {
    "priv_set_remove_linkdir": [
      {
        "start_point": [
          35,
          0
        ],
        "end_point": [
          39,
          1
        ],
        "content": "PRIV_SET_INLINE int\npriv_set_remove_linkdir (void)\n{\n  return priv_set_remove (PRIV_SYS_LINKDIR);\n}",
        "lines": 5,
        "depth": 6,
        "decorators": [
          "PRIV_SET_INLINE",
          "int",
          "int"
        ]
      },
      {
        "start_point": [
          49,
          0
        ],
        "end_point": [
          53,
          1
        ],
        "content": "PRIV_SET_INLINE int\npriv_set_remove_linkdir (void)\n{\n  return -1;\n}",
        "lines": 5,
        "depth": 5,
        "decorators": [
          "PRIV_SET_INLINE",
          "int",
          "int"
        ]
      }
    ],
    "priv_set_restore_linkdir": [
      {
        "start_point": [
          41,
          0
        ],
        "end_point": [
          45,
          1
        ],
        "content": "PRIV_SET_INLINE int\npriv_set_restore_linkdir (void)\n{\n  return priv_set_restore (PRIV_SYS_LINKDIR);\n}",
        "lines": 5,
        "depth": 6,
        "decorators": [
          "PRIV_SET_INLINE",
          "int",
          "int"
        ]
      },
      {
        "start_point": [
          55,
          0
        ],
        "end_point": [
          59,
          1
        ],
        "content": "PRIV_SET_INLINE int\npriv_set_restore_linkdir (void)\n{\n  return -1;\n}",
        "lines": 5,
        "depth": 5,
        "decorators": [
          "PRIV_SET_INLINE",
          "int",
          "int"
        ]
      }
    ]
  },
  "findutils/findutils-4.6.0/tests/putenv.c": {
    "_unsetenv": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        112,
        1
      ],
      "content": "static int\n_unsetenv (const char *name)\n{\n  size_t len;\n#if !HAVE_DECL__PUTENV\n  char **ep;\n#endif\n\n  if (name == NULL || *name == '\\0' || strchr (name, '=') != NULL)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  len = strlen (name);\n\n#if HAVE_DECL__PUTENV\n  {\n    int putenv_result, putenv_errno;\n    char *name_ = malloc (len + 2);\n    memcpy (name_, name, len);\n    name_[len] = '=';\n    name_[len + 1] = 0;\n    putenv_result = _putenv (name_);\n    putenv_errno = errno;\n    free (name_);\n    __set_errno (putenv_errno);\n    return putenv_result;\n  }\n#else\n\n  LOCK;\n\n  ep = environ;\n  while (*ep != NULL)\n    if (!strncmp (*ep, name, len) && (*ep)[len] == '=')\n      {\n        /* Found it.  Remove this pointer by moving later ones back.  */\n        char **dp = ep;\n\n        do\n          dp[0] = dp[1];\n        while (*dp++);\n        /* Continue the loop in case NAME appears again.  */\n      }\n    else\n      ++ep;\n\n  UNLOCK;\n\n  return 0;\n#endif\n}",
      "lines": 53,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "putenv": {
      "start_point": [
        117,
        0
      ],
      "end_point": [
        193,
        1
      ],
      "content": "int\nputenv (char *string)\n{\n  const char *name_end = strchr (string, '=');\n  char **ep;\n\n  if (name_end == NULL)\n    {\n      /* Remove the variable from the environment.  */\n      return _unsetenv (string);\n    }\n\n#if HAVE_DECL__PUTENV\n  /* Rely on _putenv to allocate the new environment.  If other\n     parts of the application use _putenv, the !HAVE_DECL__PUTENV code\n     would fight over who owns the environ vector, causing a crash.  */\n  if (name_end[1])\n    return _putenv (string);\n  else\n    {\n      /* _putenv (\"NAME=\") unsets NAME, so invoke _putenv (\"NAME= \")\n         to allocate the environ vector and then replace the new\n         entry with \"NAME=\".  */\n      int putenv_result, putenv_errno;\n      char *name_x = malloc (name_end - string + sizeof \"= \");\n      if (!name_x)\n        return -1;\n      memcpy (name_x, string, name_end - string + 1);\n      name_x[name_end - string + 1] = ' ';\n      name_x[name_end - string + 2] = 0;\n      putenv_result = _putenv (name_x);\n      putenv_errno = errno;\n      for (ep = environ; *ep; ep++)\n        if (strcmp (*ep, name_x) == 0)\n          {\n            *ep = string;\n            break;\n          }\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n      if (putenv_result == 0)\n        {\n          /* _putenv propagated \"NAME= \" into the subprocess environment;\n             fix that by calling SetEnvironmentVariable directly.  */\n          name_x[name_end - string] = 0;\n          putenv_result = SetEnvironmentVariable (name_x, \"\") ? 0 : -1;\n          putenv_errno = ENOMEM; /* ENOMEM is the only way to fail.  */\n        }\n# endif\n      free (name_x);\n      __set_errno (putenv_errno);\n      return putenv_result;\n    }\n#else\n  for (ep = environ; *ep; ep++)\n    if (strncmp (*ep, string, name_end - string) == 0\n        && (*ep)[name_end - string] == '=')\n      break;\n\n  if (*ep)\n    *ep = string;\n  else\n    {\n      static char **last_environ = NULL;\n      size_t size = ep - environ;\n      char **new_environ = malloc ((size + 2) * sizeof *new_environ);\n      if (! new_environ)\n        return -1;\n      new_environ[0] = string;\n      memcpy (new_environ + 1, environ, (size + 1) * sizeof *new_environ);\n      free (last_environ);\n      last_environ = new_environ;\n      environ = new_environ;\n    }\n\n  return 0;\n#endif\n}",
      "lines": 77,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/raise.c": {
    "raise_nothrow": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        42,
        5
      ],
      "content": "static int\nraise_nothrow (int sig)\n{\n  int result;\n\n  TRY_MSVC_INVAL\n    {\n      result = raise (sig);\n    }",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_raise": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "int\nrpl_raise (int sig)\n{\n#if GNULIB_defined_signal_blocking && GNULIB_defined_SIGPIPE\n  if (sig == SIGPIPE)\n    return _gl_raise_SIGPIPE ();\n#endif\n\n#if HAVE_RAISE\n  return raise_nothrow (sig);\n#else\n  return kill (getpid (), sig);\n#endif\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/randomd.c": {},
  "findutils/findutils-4.6.0/tests/select.c": {
    "IsConsoleHandle": {
      "start_point": [
        84,
        0
      ],
      "end_point": [
        88,
        1
      ],
      "content": "static BOOL IsConsoleHandle (HANDLE h)\n{\n  DWORD mode;\n  return GetConsoleMode (h, &mode) != 0;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "BOOL"
      ]
    },
    "IsSocketHandle": {
      "start_point": [
        90,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "static BOOL\nIsSocketHandle (HANDLE h)\n{\n  WSANETWORKEVENTS ev;\n\n  if (IsConsoleHandle (h))\n    return FALSE;\n\n  /* Under Wine, it seems that getsockopt returns 0 for pipes too.\n     WSAEnumNetworkEvents instead distinguishes the two correctly.  */\n  ev.lNetworkEvents = 0xDEADBEEF;\n  WSAEnumNetworkEvents ((SOCKET) h, NULL, &ev);\n  return ev.lNetworkEvents != 0xDEADBEEF;\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "BOOL"
      ]
    },
    "windows_poll_handle": {
      "start_point": [
        108,
        0
      ],
      "end_point": [
        240,
        1
      ],
      "content": "static int\nwindows_poll_handle (HANDLE h, int fd,\n                     struct bitset *rbits,\n                     struct bitset *wbits,\n                     struct bitset *xbits)\n{\n  BOOL read, write, except;\n  int i, ret;\n  INPUT_RECORD *irbuffer;\n  DWORD avail, nbuffer;\n  BOOL bRet;\n  IO_STATUS_BLOCK iosb;\n  FILE_PIPE_LOCAL_INFORMATION fpli;\n  static PNtQueryInformationFile NtQueryInformationFile;\n  static BOOL once_only;\n\n  read = write = except = FALSE;\n  switch (GetFileType (h))\n    {\n    case FILE_TYPE_DISK:\n      read = TRUE;\n      write = TRUE;\n      break;\n\n    case FILE_TYPE_PIPE:\n      if (!once_only)\n        {\n          NtQueryInformationFile = (PNtQueryInformationFile)\n            GetProcAddress (GetModuleHandle (\"ntdll.dll\"),\n                            \"NtQueryInformationFile\");\n          once_only = TRUE;\n        }\n\n      if (PeekNamedPipe (h, NULL, 0, NULL, &avail, NULL) != 0)\n        {\n          if (avail)\n            read = TRUE;\n        }\n      else if (GetLastError () == ERROR_BROKEN_PIPE)\n        ;\n\n      else\n        {\n          /* It was the write-end of the pipe.  Check if it is writable.\n             If NtQueryInformationFile fails, optimistically assume the pipe is\n             writable.  This could happen on Windows 9x, where\n             NtQueryInformationFile is not available, or if we inherit a pipe\n             that doesn't permit FILE_READ_ATTRIBUTES access on the write end\n             (I think this should not happen since Windows XP SP2; WINE seems\n             fine too).  Otherwise, ensure that enough space is available for\n             atomic writes.  */\n          memset (&iosb, 0, sizeof (iosb));\n          memset (&fpli, 0, sizeof (fpli));\n\n          if (!NtQueryInformationFile\n              || NtQueryInformationFile (h, &iosb, &fpli, sizeof (fpli),\n                                         FilePipeLocalInformation)\n              || fpli.WriteQuotaAvailable >= PIPE_BUF\n              || (fpli.OutboundQuota < PIPE_BUF &&\n                  fpli.WriteQuotaAvailable == fpli.OutboundQuota))\n            write = TRUE;\n        }\n      break;\n\n    case FILE_TYPE_CHAR:\n      write = TRUE;\n      if (!(rbits->in[fd / CHAR_BIT] & (1 << (fd & (CHAR_BIT - 1)))))\n        break;\n\n      ret = WaitForSingleObject (h, 0);\n      if (ret == WAIT_OBJECT_0)\n        {\n          if (!IsConsoleHandle (h))\n            {\n              read = TRUE;\n              break;\n            }\n\n          nbuffer = avail = 0;\n          bRet = GetNumberOfConsoleInputEvents (h, &nbuffer);\n\n          /* Screen buffers handles are filtered earlier.  */\n          assert (bRet);\n          if (nbuffer == 0)\n            {\n              except = TRUE;\n              break;\n            }\n\n          irbuffer = (INPUT_RECORD *) alloca (nbuffer * sizeof (INPUT_RECORD));\n          bRet = PeekConsoleInput (h, irbuffer, nbuffer, &avail);\n          if (!bRet || avail == 0)\n            {\n              except = TRUE;\n              break;\n            }\n\n          for (i = 0; i < avail; i++)\n            if (irbuffer[i].EventType == KEY_EVENT)\n              read = TRUE;\n        }\n      break;\n\n    default:\n      ret = WaitForSingleObject (h, 0);\n      write = TRUE;\n      if (ret == WAIT_OBJECT_0)\n        read = TRUE;\n\n      break;\n    }\n\n  ret = 0;\n  if (read && (rbits->in[fd / CHAR_BIT] & (1 << (fd & (CHAR_BIT - 1)))))\n    {\n      rbits->out[fd / CHAR_BIT] |= (1 << (fd & (CHAR_BIT - 1)));\n      ret++;\n    }\n\n  if (write && (wbits->in[fd / CHAR_BIT] & (1 << (fd & (CHAR_BIT - 1)))))\n    {\n      wbits->out[fd / CHAR_BIT] |= (1 << (fd & (CHAR_BIT - 1)));\n      ret++;\n    }\n\n  if (except && (xbits->in[fd / CHAR_BIT] & (1 << (fd & (CHAR_BIT - 1)))))\n    {\n      xbits->out[fd / CHAR_BIT] |= (1 << (fd & (CHAR_BIT - 1)));\n      ret++;\n    }\n\n  return ret;\n}",
      "lines": 133,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_select": {
      "start_point": [
        542,
        0
      ],
      "end_point": [
        572,
        1
      ],
      "content": "int\nrpl_select (int nfds, fd_set *rfds, fd_set *wfds, fd_set *xfds,\n            struct timeval *timeout)\n{\n  int i;\n\n  /* FreeBSD 8.2 has a bug: it does not always detect invalid fds.  */\n  if (nfds < 0 || nfds > FD_SETSIZE)\n    {\n      errno = EINVAL;\n      return -1;\n    }\n  for (i = 0; i < nfds; i++)\n    {\n      if (((rfds && FD_ISSET (i, rfds))\n           || (wfds && FD_ISSET (i, wfds))\n           || (xfds && FD_ISSET (i, xfds)))\n          && dup2 (i, i) != i)\n        return -1;\n    }\n\n  /* Interix 3.5 has a bug: it does not support nfds == 0.  */\n  if (nfds == 0)\n    {\n      nfds = 1;\n      rfds = NULL;\n      wfds = NULL;\n      xfds = NULL;\n    }\n  return select (nfds, rfds, wfds, xfds, timeout);\n}",
      "lines": 31,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/setlocale.c": {
    "category_to_name": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "static const char *\ncategory_to_name (int category)\n{\n  const char *retval;\n\n  switch (category)\n  {\n  case LC_COLLATE:\n    retval = \"LC_COLLATE\";\n    break;\n  case LC_CTYPE:\n    retval = \"LC_CTYPE\";\n    break;\n  case LC_MONETARY:\n    retval = \"LC_MONETARY\";\n    break;\n  case LC_NUMERIC:\n    retval = \"LC_NUMERIC\";\n    break;\n  case LC_TIME:\n    retval = \"LC_TIME\";\n    break;\n  case LC_MESSAGES:\n    retval = \"LC_MESSAGES\";\n    break;\n  default:\n    /* If you have a better idea for a default value let me know.  */\n    retval = \"LC_XXX\";\n  }\n\n  return retval;\n}",
      "lines": 32,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\ncategory_to_name (int category)",
        "*"
      ]
    },
    "search": {
      "start_point": [
        566,
        0
      ],
      "end_point": [
        622,
        1
      ],
      "content": "static void\nsearch (const struct table_entry *table, size_t table_size, const char *string,\n        range_t *result)\n{\n  /* The table is sorted.  Perform a binary search.  */\n  size_t hi = table_size;\n  size_t lo = 0;\n  while (lo < hi)\n    {\n      /* Invariant:\n         for i < lo, strcmp (table[i].code, string) < 0,\n         for i >= hi, strcmp (table[i].code, string) > 0.  */\n      size_t mid = (hi + lo) >> 1; /* >= lo, < hi */\n      int cmp = strcmp (table[mid].code, string);\n      if (cmp < 0)\n        lo = mid + 1;\n      else if (cmp > 0)\n        hi = mid;\n      else\n        {\n          /* Found an i with\n               strcmp (language_table[i].code, string) == 0.\n             Find the entire interval of such i.  */\n          {\n            size_t i;\n\n            for (i = mid; i > lo; )\n              {\n                i--;\n                if (strcmp (table[i].code, string) < 0)\n                  {\n                    lo = i + 1;\n                    break;\n                  }\n              }\n          }\n          {\n            size_t i;\n\n            for (i = mid; i < hi; i++)\n              {\n                if (strcmp (table[i].code, string) > 0)\n                  {\n                    hi = i;\n                    break;\n                  }\n              }\n          }\n          /* The set of i with\n               strcmp (language_table[i].code, string) == 0\n             is the interval [lo, hi-1].  */\n          break;\n        }\n    }\n  result->lo = lo;\n  result->hi = hi;\n}",
      "lines": 57,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "setlocale_unixlike": {
      "start_point": [
        626,
        0
      ],
      "end_point": [
        775,
        1
      ],
      "content": "static char *\nsetlocale_unixlike (int category, const char *locale)\n{\n  char *result;\n  char llCC_buf[64];\n  char ll_buf[64];\n  char CC_buf[64];\n\n  /* First, try setlocale with the original argument unchanged.  */\n  result = setlocale (category, locale);\n  if (result != NULL)\n    return result;\n\n  /* Otherwise, assume the argument is in the form\n       language[_territory][.codeset][@modifier]\n     and try to map it using the tables.  */\n  if (strlen (locale) < sizeof (llCC_buf))\n    {\n      /* Second try: Remove the codeset part.  */\n      {\n        const char *p = locale;\n        char *q = llCC_buf;\n\n        /* Copy the part before the dot.  */\n        for (; *p != '\\0' && *p != '.'; p++, q++)\n          *q = *p;\n        if (*p == '.')\n          /* Skip the part up to the '@', if any.  */\n          for (; *p != '\\0' && *p != '@'; p++)\n            ;\n        /* Copy the part starting with '@', if any.  */\n        for (; *p != '\\0'; p++, q++)\n          *q = *p;\n        *q = '\\0';\n      }\n      /* llCC_buf now contains\n           language[_territory][@modifier]\n       */\n      if (strcmp (llCC_buf, locale) != 0)\n        {\n          result = setlocale (category, llCC_buf);\n          if (result != NULL)\n            return result;\n        }\n      /* Look it up in language_table.  */\n      {\n        range_t range;\n        size_t i;\n\n        search (language_table,\n                sizeof (language_table) / sizeof (language_table[0]),\n                llCC_buf,\n                &range);\n\n        for (i = range.lo; i < range.hi; i++)\n          {\n            /* Try the replacement in language_table[i].  */\n            result = setlocale (category, language_table[i].english);\n            if (result != NULL)\n              return result;\n          }\n      }\n      /* Split language[_territory][@modifier]\n         into  ll_buf = language[@modifier]\n         and   CC_buf = territory\n       */\n      {\n        const char *underscore = strchr (llCC_buf, '_');\n        if (underscore != NULL)\n          {\n            const char *territory_start = underscore + 1;\n            const char *territory_end = strchr (territory_start, '@');\n            if (territory_end == NULL)\n              territory_end = territory_start + strlen (territory_start);\n\n            memcpy (ll_buf, llCC_buf, underscore - llCC_buf);\n            strcpy (ll_buf + (underscore - llCC_buf), territory_end);\n\n            memcpy (CC_buf, territory_start, territory_end - territory_start);\n            CC_buf[territory_end - territory_start] = '\\0';\n\n            {\n              /* Look up ll_buf in language_table\n                 and CC_buf in country_table.  */\n              range_t language_range;\n\n              search (language_table,\n                      sizeof (language_table) / sizeof (language_table[0]),\n                      ll_buf,\n                      &language_range);\n              if (language_range.lo < language_range.hi)\n                {\n                  range_t country_range;\n\n                  search (country_table,\n                          sizeof (country_table) / sizeof (country_table[0]),\n                          CC_buf,\n                          &country_range);\n                  if (country_range.lo < country_range.hi)\n                    {\n                      size_t i;\n                      size_t j;\n\n                      for (i = language_range.lo; i < language_range.hi; i++)\n                        for (j = country_range.lo; j < country_range.hi; j++)\n                          {\n                            /* Concatenate the replacements.  */\n                            const char *part1 = language_table[i].english;\n                            size_t part1_len = strlen (part1);\n                            const char *part2 = country_table[j].english;\n                            size_t part2_len = strlen (part2) + 1;\n                            char buf[64+64];\n\n                            if (!(part1_len + 1 + part2_len <= sizeof (buf)))\n                              abort ();\n                            memcpy (buf, part1, part1_len);\n                            buf[part1_len] = '_';\n                            memcpy (buf + part1_len + 1, part2, part2_len);\n\n                            /* Try the concatenated replacements.  */\n                            result = setlocale (category, buf);\n                            if (result != NULL)\n                              return result;\n                          }\n                    }\n\n                  /* Try omitting the country entirely.  This may set a locale\n                     corresponding to the wrong country, but is better than\n                     failing entirely.  */\n                  {\n                    size_t i;\n\n                    for (i = language_range.lo; i < language_range.hi; i++)\n                      {\n                        /* Try only the language replacement.  */\n                        result =\n                          setlocale (category, language_table[i].english);\n                        if (result != NULL)\n                          return result;\n                      }\n                  }\n                }\n            }\n          }\n      }\n    }\n\n  /* Failed.  */\n  return NULL;\n}",
      "lines": 150,
      "depth": 23,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nsetlocale_unixlike (int category, const char *locale)",
        "*"
      ]
    },
    "setlocale_single": {
      "start_point": [
        787,
        0
      ],
      "end_point": [
        801,
        1
      ],
      "content": "static char *\nsetlocale_single (int category, const char *locale)\n{\n  if (category == LC_MESSAGES)\n    {\n      if (locale != NULL)\n        {\n          lc_messages_name[sizeof (lc_messages_name) - 1] = '\\0';\n          strncpy (lc_messages_name, locale, sizeof (lc_messages_name) - 1);\n        }\n      return lc_messages_name;\n    }\n  else\n    return setlocale_unixlike (category, locale);\n}",
      "lines": 15,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nsetlocale_single (int category, const char *locale)",
        "*"
      ]
    },
    "rpl_setlocale": {
      "start_point": [
        807,
        0
      ],
      "end_point": [
        935,
        1
      ],
      "content": "char *\nrpl_setlocale (int category, const char *locale)\n{\n  if (locale != NULL && locale[0] == '\\0')\n    {\n      /* A request to the set the current locale to the default locale.  */\n      if (category == LC_ALL)\n        {\n          /* Set LC_CTYPE first.  Then the other categories.  */\n          static int const categories[] =\n            {\n              LC_NUMERIC,\n              LC_TIME,\n              LC_COLLATE,\n              LC_MONETARY,\n              LC_MESSAGES\n            };\n          char *saved_locale;\n          const char *base_name;\n          unsigned int i;\n\n          /* Back up the old locale, in case one of the steps fails.  */\n          saved_locale = setlocale (LC_ALL, NULL);\n          if (saved_locale == NULL)\n            return NULL;\n          saved_locale = strdup (saved_locale);\n          if (saved_locale == NULL)\n            return NULL;\n\n          /* Set LC_CTYPE category.  Set all other categories (except possibly\n             LC_MESSAGES) to the same value in the same call; this is likely to\n             save calls.  */\n          base_name =\n            gl_locale_name_environ (LC_CTYPE, category_to_name (LC_CTYPE));\n          if (base_name == NULL)\n            base_name = gl_locale_name_default ();\n\n          if (setlocale_unixlike (LC_ALL, base_name) == NULL)\n            goto fail;\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n          /* On native Windows, setlocale(LC_ALL,...) may succeed but set the\n             LC_CTYPE category to an invalid value (\"C\") when it does not\n             support the specified encoding.  Report a failure instead.  */\n          if (strchr (base_name, '.') != NULL\n              && strcmp (setlocale (LC_CTYPE, NULL), \"C\") == 0)\n            goto fail;\n# endif\n\n          for (i = 0; i < sizeof (categories) / sizeof (categories[0]); i++)\n            {\n              int cat = categories[i];\n              const char *name;\n\n              name = gl_locale_name_environ (cat, category_to_name (cat));\n              if (name == NULL)\n                name = gl_locale_name_default ();\n\n              /* If name is the same as base_name, it has already been set\n                 through the setlocale call before the loop.  */\n              if (strcmp (name, base_name) != 0\n# if LC_MESSAGES == 1729\n                  || cat == LC_MESSAGES\n# endif\n                 )\n                if (setlocale_single (cat, name) == NULL)\n                  goto fail;\n            }\n\n          /* All steps were successful.  */\n          free (saved_locale);\n          return setlocale (LC_ALL, NULL);\n\n        fail:\n          if (saved_locale[0] != '\\0') /* don't risk an endless recursion */\n            setlocale (LC_ALL, saved_locale);\n          free (saved_locale);\n          return NULL;\n        }\n      else\n        {\n          const char *name =\n            gl_locale_name_environ (category, category_to_name (category));\n          if (name == NULL)\n            name = gl_locale_name_default ();\n\n          return setlocale_single (category, name);\n        }\n    }\n  else\n    {\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n      if (category == LC_ALL && locale != NULL && strchr (locale, '.') != NULL)\n        {\n          char *saved_locale;\n\n          /* Back up the old locale.  */\n          saved_locale = setlocale (LC_ALL, NULL);\n          if (saved_locale == NULL)\n            return NULL;\n          saved_locale = strdup (saved_locale);\n          if (saved_locale == NULL)\n            return NULL;\n\n          if (setlocale_unixlike (LC_ALL, locale) == NULL)\n            {\n              free (saved_locale);\n              return NULL;\n            }\n\n          /* On native Windows, setlocale(LC_ALL,...) may succeed but set the\n             LC_CTYPE category to an invalid value (\"C\") when it does not\n             support the specified encoding.  Report a failure instead.  */\n          if (strcmp (setlocale (LC_CTYPE, NULL), \"C\") == 0)\n            {\n              if (saved_locale[0] != '\\0') /* don't risk an endless recursion */\n                setlocale (LC_ALL, saved_locale);\n              free (saved_locale);\n              return NULL;\n            }\n\n          /* It was really successful.  */\n          free (saved_locale);\n          return setlocale (LC_ALL, NULL);\n        }\n      else\n# endif\n        return setlocale_single (category, locale);\n    }\n}",
      "lines": 129,
      "depth": 16,
      "decorators": [
        "char",
        "*\nrpl_setlocale (int category, const char *locale)",
        "*"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/setsockopt.c": {
    "rpl_setsockopt": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "int\nrpl_setsockopt (int fd, int level, int optname, const void *optval, socklen_t optlen)\n{\n  SOCKET sock = FD_TO_SOCKET (fd);\n  int r;\n\n  if (sock == INVALID_SOCKET)\n    {\n      errno = EBADF;\n      return -1;\n    }\n  else\n    {\n      if (level == SOL_SOCKET\n          && (optname == SO_RCVTIMEO || optname == SO_SNDTIMEO))\n        {\n          const struct timeval *tv = optval;\n          int milliseconds = tv->tv_sec * 1000 + tv->tv_usec / 1000;\n          optval = &milliseconds;\n          r = setsockopt (sock, level, optname, optval, sizeof (int));\n        }\n      else\n        {\n          r = setsockopt (sock, level, optname, optval, optlen);\n        }\n\n      if (r < 0)\n        set_winsock_errno ();\n\n      return r;\n    }\n}",
      "lines": 32,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/sig-handler.c": {},
  "findutils/findutils-4.6.0/tests/sig-handler.h": {
    "get_handler": {
      "start_point": [
        36,
        32
      ],
      "end_point": [
        49,
        1
      ],
      "content": "_GL_ATTRIBUTE_PURE\nget_handler (struct sigaction const *a)\n{\n#ifdef SA_SIGINFO\n  /* POSIX says that special values like SIG_IGN can only occur when\n     action.sa_flags does not contain SA_SIGINFO.  But in Linux 2.4,\n     for example, sa_sigaction and sa_handler are aliases and a signal\n     is ignored if sa_sigaction (after casting) equals SIG_IGN.  So\n     use (and cast) sa_sigaction in that case.  */\n  if (a->sa_flags & SA_SIGINFO)\n    return (sa_handler_t) a->sa_sigaction;\n#endif\n  return a->sa_handler;\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "_GL_ATTRIBUTE_PURE"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/sigaction.c": {
    "sigaction_handler": {
      "start_point": [
        82,
        0
      ],
      "end_point": [
        123,
        1
      ],
      "content": "static void\nsigaction_handler (int sig)\n{\n  handler_t handler;\n  sigset_t mask;\n  sigset_t oldmask;\n  int saved_errno = errno;\n  if (sig < 0 || NSIG <= sig || !action_array[sig].sa_handler)\n    {\n      /* Unexpected situation; be careful to avoid recursive abort.  */\n      if (sig == SIGABRT)\n        signal (SIGABRT, SIG_DFL);\n      abort ();\n    }\n\n  /* Reinstall the signal handler when required; otherwise update the\n     bookkeeping so that the user's handler may call sigaction and get\n     accurate results.  We know the signal isn't currently blocked, or\n     we wouldn't be in its handler, therefore we know that we are not\n     interrupting a sigaction() call.  There is a race where any\n     asynchronous instance of the same signal occurring before we\n     reinstall the handler will trigger the default handler; oh\n     well.  */\n  handler = action_array[sig].sa_handler;\n  if ((action_array[sig].sa_flags & SA_RESETHAND) == 0)\n    signal (sig, sigaction_handler);\n  else\n    action_array[sig].sa_handler = NULL;\n\n  /* Block appropriate signals.  */\n  mask = action_array[sig].sa_mask;\n  if ((action_array[sig].sa_flags & SA_NODEFER) == 0)\n    sigaddset (&mask, sig);\n  sigprocmask (SIG_BLOCK, &mask, &oldmask);\n\n  /* Invoke the user's handler, then restore prior mask.  */\n  errno = saved_errno;\n  handler (sig);\n  saved_errno = errno;\n  sigprocmask (SIG_SETMASK, &oldmask, NULL);\n  errno = saved_errno;\n}",
      "lines": 42,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "sigaction": {
      "start_point": [
        129,
        0
      ],
      "end_point": [
        203,
        1
      ],
      "content": "int\nsigaction (int sig, const struct sigaction *restrict act,\n           struct sigaction *restrict oact)\n{\n  sigset_t mask;\n  sigset_t oldmask;\n  int saved_errno;\n\n  if (sig < 0 || NSIG <= sig || sig == SIGKILL || sig == SIGSTOP\n      || (act && act->sa_handler == SIG_ERR))\n    {\n      errno = EINVAL;\n      return -1;\n    }\n\n#ifdef SIGABRT_COMPAT\n  if (sig == SIGABRT_COMPAT)\n    sig = SIGABRT;\n#endif\n\n  /* POSIX requires sigaction() to be async-signal-safe.  In other\n     words, if an asynchronous signal can occur while we are anywhere\n     inside this function, the user's handler could then call\n     sigaction() recursively and expect consistent results.  We meet\n     this rule by using sigprocmask to block all signals before\n     modifying any data structure that could be read from a signal\n     handler; this works since we know that the gnulib sigprocmask\n     replacement does not try to use sigaction() from its handler.  */\n  if (!act && !oact)\n    return 0;\n  sigfillset (&mask);\n  sigprocmask (SIG_BLOCK, &mask, &oldmask);\n  if (oact)\n    {\n      if (action_array[sig].sa_handler)\n        *oact = action_array[sig];\n      else\n        {\n          /* Safe to change the handler at will here, since all\n             signals are currently blocked.  */\n          oact->sa_handler = signal (sig, SIG_DFL);\n          if (oact->sa_handler == SIG_ERR)\n            goto failure;\n          signal (sig, oact->sa_handler);\n          oact->sa_flags = SA_RESETHAND | SA_NODEFER;\n          sigemptyset (&oact->sa_mask);\n        }\n    }\n\n  if (act)\n    {\n      /* Safe to install the handler before updating action_array,\n         since all signals are currently blocked.  */\n      if (act->sa_handler == SIG_DFL || act->sa_handler == SIG_IGN)\n        {\n          if (signal (sig, act->sa_handler) == SIG_ERR)\n            goto failure;\n          action_array[sig].sa_handler = NULL;\n        }\n      else\n        {\n          if (signal (sig, sigaction_handler) == SIG_ERR)\n            goto failure;\n          action_array[sig] = *act;\n        }\n    }\n  sigprocmask (SIG_SETMASK, &oldmask, NULL);\n  return 0;\n\n failure:\n  saved_errno = errno;\n  sigprocmask (SIG_SETMASK, &oldmask, NULL);\n  errno = saved_errno;\n  return -1;\n}",
      "lines": 75,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/signal.in.h": {},
  "findutils/findutils-4.6.0/tests/signature.h": {},
  "findutils/findutils-4.6.0/tests/sigprocmask.c": {
    "signal_nothrow": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        73,
        5
      ],
      "content": "static handler_t\nsignal_nothrow (int sig, handler_t handler)\n{\n  handler_t result;\n\n  TRY_MSVC_INVAL\n    {\n      result = signal (sig, handler);\n    }",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "handler_t"
      ]
    },
    "ext_signal": {
      "start_point": [
        93,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "static handler_t\next_signal (int sig, handler_t handler)\n{\n  switch (sig)\n    {\n    case SIGPIPE:\n      {\n        handler_t old_handler = SIGPIPE_handler;\n        SIGPIPE_handler = handler;\n        return old_handler;\n      }\n    default: /* System defined signal */\n      return signal (sig, handler);\n    }\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "handler_t"
      ]
    },
    "sigismember": {
      "start_point": [
        112,
        0
      ],
      "end_point": [
        126,
        1
      ],
      "content": "int\nsigismember (const sigset_t *set, int sig)\n{\n  if (sig >= 0 && sig < NSIG)\n    {\n      #ifdef SIGABRT_COMPAT\n      if (sig == SIGABRT_COMPAT)\n        sig = SIGABRT;\n      #endif\n\n      return (*set >> sig) & 1;\n    }\n  else\n    return 0;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "sigemptyset": {
      "start_point": [
        128,
        0
      ],
      "end_point": [
        133,
        1
      ],
      "content": "int\nsigemptyset (sigset_t *set)\n{\n  *set = 0;\n  return 0;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "sigaddset": {
      "start_point": [
        135,
        0
      ],
      "end_point": [
        153,
        1
      ],
      "content": "int\nsigaddset (sigset_t *set, int sig)\n{\n  if (sig >= 0 && sig < NSIG)\n    {\n      #ifdef SIGABRT_COMPAT\n      if (sig == SIGABRT_COMPAT)\n        sig = SIGABRT;\n      #endif\n\n      *set |= 1U << sig;\n      return 0;\n    }\n  else\n    {\n      errno = EINVAL;\n      return -1;\n    }\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "sigdelset": {
      "start_point": [
        155,
        0
      ],
      "end_point": [
        173,
        1
      ],
      "content": "int\nsigdelset (sigset_t *set, int sig)\n{\n  if (sig >= 0 && sig < NSIG)\n    {\n      #ifdef SIGABRT_COMPAT\n      if (sig == SIGABRT_COMPAT)\n        sig = SIGABRT;\n      #endif\n\n      *set &= ~(1U << sig);\n      return 0;\n    }\n  else\n    {\n      errno = EINVAL;\n      return -1;\n    }\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "sigfillset": {
      "start_point": [
        176,
        0
      ],
      "end_point": [
        181,
        1
      ],
      "content": "int\nsigfillset (sigset_t *set)\n{\n  *set = ((2U << (NSIG - 1)) - 1) & ~ SIGABRT_COMPAT_MASK;\n  return 0;\n}",
      "lines": 6,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "blocked_handler": {
      "start_point": [
        190,
        0
      ],
      "end_point": [
        201,
        1
      ],
      "content": "static void\nblocked_handler (int sig)\n{\n  /* Reinstall the handler, in case the signal occurs multiple times\n     while blocked.  There is an inherent race where an asynchronous\n     signal in between when the kernel uninstalled the handler and\n     when we reinstall it will trigger the default handler; oh\n     well.  */\n  signal (sig, blocked_handler);\n  if (sig >= 0 && sig < NSIG)\n    pending_array[sig] = 1;\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "sigpending": {
      "start_point": [
        203,
        0
      ],
      "end_point": [
        214,
        1
      ],
      "content": "int\nsigpending (sigset_t *set)\n{\n  sigset_t pending = 0;\n  int sig;\n\n  for (sig = 0; sig < NSIG; sig++)\n    if (pending_array[sig])\n      pending |= 1U << sig;\n  *set = pending;\n  return 0;\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "sigprocmask": {
      "start_point": [
        220,
        0
      ],
      "end_point": [
        289,
        1
      ],
      "content": "int\nsigprocmask (int operation, const sigset_t *set, sigset_t *old_set)\n{\n  if (old_set != NULL)\n    *old_set = blocked_set;\n\n  if (set != NULL)\n    {\n      sigset_t new_blocked_set;\n      sigset_t to_unblock;\n      sigset_t to_block;\n\n      switch (operation)\n        {\n        case SIG_BLOCK:\n          new_blocked_set = blocked_set | *set;\n          break;\n        case SIG_SETMASK:\n          new_blocked_set = *set;\n          break;\n        case SIG_UNBLOCK:\n          new_blocked_set = blocked_set & ~*set;\n          break;\n        default:\n          errno = EINVAL;\n          return -1;\n        }\n      to_unblock = blocked_set & ~new_blocked_set;\n      to_block = new_blocked_set & ~blocked_set;\n\n      if (to_block != 0)\n        {\n          int sig;\n\n          for (sig = 0; sig < NSIG; sig++)\n            if ((to_block >> sig) & 1)\n              {\n                pending_array[sig] = 0;\n                if ((old_handlers[sig] = signal (sig, blocked_handler)) != SIG_ERR)\n                  blocked_set |= 1U << sig;\n              }\n        }\n\n      if (to_unblock != 0)\n        {\n          sig_atomic_t received[NSIG];\n          int sig;\n\n          for (sig = 0; sig < NSIG; sig++)\n            if ((to_unblock >> sig) & 1)\n              {\n                if (signal (sig, old_handlers[sig]) != blocked_handler)\n                  /* The application changed a signal handler while the signal\n                     was blocked, bypassing our rpl_signal replacement.\n                     We don't support this.  */\n                  abort ();\n                received[sig] = pending_array[sig];\n                blocked_set &= ~(1U << sig);\n                pending_array[sig] = 0;\n              }\n            else\n              received[sig] = 0;\n\n          for (sig = 0; sig < NSIG; sig++)\n            if (received[sig])\n              raise (sig);\n        }\n    }\n  return 0;\n}",
      "lines": 70,
      "depth": 17,
      "decorators": [
        "int"
      ]
    },
    "rpl_signal": {
      "start_point": [
        293,
        0
      ],
      "end_point": [
        329,
        1
      ],
      "content": "handler_t\nrpl_signal (int sig, handler_t handler)\n{\n  /* We must provide a wrapper, so that a user can query what handler\n     they installed even if that signal is currently blocked.  */\n  if (sig >= 0 && sig < NSIG && sig != SIGKILL && sig != SIGSTOP\n      && handler != SIG_ERR)\n    {\n      #ifdef SIGABRT_COMPAT\n      if (sig == SIGABRT_COMPAT)\n        sig = SIGABRT;\n      #endif\n\n      if (blocked_set & (1U << sig))\n        {\n          /* POSIX states that sigprocmask and signal are both\n             async-signal-safe.  This is not true of our\n             implementation - there is a slight data race where an\n             asynchronous interrupt on signal A can occur after we\n             install blocked_handler but before we have updated\n             old_handlers for signal B, such that handler A can see\n             stale information if it calls signal(B).  Oh well -\n             signal handlers really shouldn't try to manipulate the\n             installed handlers of unrelated signals.  */\n          handler_t result = old_handlers[sig];\n          old_handlers[sig] = handler;\n          return result;\n        }\n      else\n        return signal (sig, handler);\n    }\n  else\n    {\n      errno = EINVAL;\n      return SIG_ERR;\n    }\n}",
      "lines": 37,
      "depth": 10,
      "decorators": [
        "handler_t"
      ]
    },
    "_gl_raise_SIGPIPE": {
      "start_point": [
        333,
        0
      ],
      "end_point": [
        347,
        1
      ],
      "content": "int\n_gl_raise_SIGPIPE (void)\n{\n  if (blocked_set & (1U << SIGPIPE))\n    pending_array[SIGPIPE] = 1;\n  else\n    {\n      handler_t handler = SIGPIPE_handler;\n      if (handler == SIG_DFL)\n        exit (128 + SIGPIPE);\n      else if (handler != SIG_IGN)\n        (*handler) (SIGPIPE);\n    }\n  return 0;\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/sleep.c": {
    "sleep": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "unsigned int\nsleep (unsigned int seconds)\n{\n  unsigned int remaining;\n\n  /* Sleep for 1 second many times, because\n       1. Sleep is not interruptible by Ctrl-C,\n       2. we want to avoid arithmetic overflow while multiplying with 1000.  */\n  for (remaining = seconds; remaining > 0; remaining--)\n    Sleep (1000);\n\n  return remaining;\n}",
      "lines": 13,
      "depth": 7,
      "decorators": [
        "unsigned int",
        "unsigned",
        "int"
      ]
    },
    "rpl_sleep": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        69,
        1
      ],
      "content": "unsigned int\nrpl_sleep (unsigned int seconds)\n{\n  /* This requires int larger than 16 bits.  */\n  verify (UINT_MAX / 24 / 24 / 60 / 60);\n  const unsigned int limit = 24 * 24 * 60 * 60;\n  while (limit < seconds)\n    {\n      unsigned int result;\n      seconds -= limit;\n      result = sleep (limit);\n      if (result)\n        return seconds + result;\n    }\n  return sleep (seconds);\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "unsigned int",
        "unsigned",
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/socket.c": {
    "rpl_socket": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "int\nrpl_socket (int domain, int type, int protocol)\n{\n  SOCKET fh;\n\n  gl_sockets_startup (SOCKETS_1_1);\n\n  /* We have to use WSASocket() to create non-overlapped IO sockets.\n     Overlapped IO sockets cannot be used with read/write.  */\n  fh = WSASocket (domain, type, protocol, NULL, 0, 0);\n\n  if (fh == INVALID_SOCKET)\n    {\n      set_winsock_errno ();\n      return -1;\n    }\n  else\n    return SOCKET_TO_FD (fh);\n}",
      "lines": 19,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/symlink.c": {
    "rpl_symlink": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "int\nrpl_symlink (char const *contents, char const *name)\n{\n  size_t len = strlen (name);\n  if (len && name[len - 1] == '/')\n    {\n      struct stat st;\n      if (lstat (name, &st) == 0)\n        errno = EEXIST;\n      return -1;\n    }\n  return symlink (contents, name);\n}",
      "lines": 13,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "symlink": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "int\nsymlink (char const *contents _GL_UNUSED,\n         char const *name _GL_UNUSED)\n{\n  errno = ENOSYS;\n  return -1;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/symlinkat.c": {
    "rpl_symlinkat": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        42,
        1
      ],
      "content": "int\nrpl_symlinkat (char const *contents, int fd, char const *name)\n{\n  size_t len = strlen (name);\n  if (len && name[len - 1] == '/')\n    {\n      struct stat st;\n      if (fstatat (fd, name, &st, 0) == 0)\n        errno = EEXIST;\n      return -1;\n    }\n  return symlinkat (contents, fd, name);\n}",
      "lines": 13,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "symlinkat": [
      {
        "start_point": [
          48,
          0
        ],
        "end_point": [
          54,
          1
        ],
        "content": "int\nsymlinkat (char const *path1 _GL_UNUSED, int fd _GL_UNUSED,\n           char const *path2 _GL_UNUSED)\n{\n  errno = ENOSYS;\n  return -1;\n}",
        "lines": 7,
        "depth": 7,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          89,
          0
        ],
        "end_point": [
          93,
          1
        ],
        "content": "int\nsymlinkat (char const *contents, int fd, char const *file)\n{\n  return symlinkat_reversed (fd, file, contents);\n}",
        "lines": 5,
        "depth": 6,
        "decorators": [
          "int"
        ]
      }
    ],
    "symlink_reversed": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "static int\nsymlink_reversed (char const *file, char const *contents)\n{\n  return symlink (contents, file);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/sys_ioctl.in.h": {},
  "findutils/findutils-4.6.0/tests/sys_select.in.h": {
    "rpl_fd_isset": {
      "start_point": [
        148,
        0
      ],
      "end_point": [
        160,
        1
      ],
      "content": "static int\nrpl_fd_isset (SOCKET fd, fd_set * set)\n{\n  u_int i;\n  if (set == NULL)\n    return 0;\n\n  for (i = 0; i < set->fd_count; i++)\n    if (set->fd_array[i] == fd)\n      return 1;\n\n  return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-accept.c": {
    "main": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "int\nmain (void)\n{\n  (void) gl_sockets_startup (SOCKETS_1_1);\n\n  /* Test behaviour for invalid file descriptors.  */\n  {\n    struct sockaddr_in addr;\n    socklen_t addrlen = sizeof (addr);\n\n    errno = 0;\n    ASSERT (accept (-1, (struct sockaddr *) &addr, &addrlen) == -1);\n    ASSERT (errno == EBADF);\n  }\n  {\n    struct sockaddr_in addr;\n    socklen_t addrlen = sizeof (addr);\n\n    close (99);\n    errno = 0;\n    ASSERT (accept (99, (struct sockaddr *) &addr, &addrlen) == -1);\n    ASSERT (errno == EBADF);\n  }\n\n  return 0;\n}",
      "lines": 26,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-alloca-opt.c": {
    "do_allocation": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        29,
        1
      ],
      "content": "static void\ndo_allocation (int n)\n{\n  void *ptr = alloca (n);\n  (void) ptr;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "int\nmain ()\n{\n#if HAVE_ALLOCA\n  int i;\n\n  /* Repeat a lot of times, to make sure there's no memory leak.  */\n  for (i = 0; i < 100000; i++)\n    {\n      /* Try various values.\n         n = 0 gave a crash on Alpha with gcc-2.5.8.\n         Some versions of Mac OS X have a stack size limit of 512 KB.  */\n      func (34);\n      func (134);\n      func (399);\n      func (510823);\n      func (129321);\n      func (0);\n      func (4070);\n      func (4095);\n      func (1);\n      func (16582);\n    }\n#endif\n\n  return 0;\n}",
      "lines": 27,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-areadlink-with-size.c": {
    "main": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "int\nmain (void)\n{\n  /* Remove any leftovers from a previous partial run.  */\n  ignore_value (system (\"rm -rf \" BASE \"*\"));\n\n  return test_areadlink (areadlink_with_size, true);\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-areadlink.c": {
    "do_areadlink": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "static char *\ndo_areadlink (char const *name, size_t ignored _GL_UNUSED)\n{\n  return areadlink (name);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "char",
        "*\ndo_areadlink (char const *name, size_t ignored _GL_UNUSED)",
        "*"
      ]
    },
    "main": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "int\nmain (void)\n{\n  /* Remove any leftovers from a previous partial run.  */\n  ignore_value (system (\"rm -rf \" BASE \"*\"));\n\n  return test_areadlink (do_areadlink, true);\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-areadlink.h": {
    "test_areadlink": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        82,
        1
      ],
      "content": "static int\ntest_areadlink (char * (*func) (char const *, size_t), bool print)\n{\n  /* Sanity checks of failures.  Mingw lacks symlink, but areadlink can\n     still distinguish between various errors.  */\n  errno = 0;\n  ASSERT (func (\"no_such\", 1) == NULL);\n  ASSERT (errno == ENOENT);\n  errno = 0;\n  ASSERT (func (\"no_such/\", 1) == NULL);\n  ASSERT (errno == ENOENT);\n  errno = 0;\n  ASSERT (func (\"\", 1) == NULL);\n  ASSERT (errno == ENOENT || errno == EINVAL);\n  errno = 0;\n  ASSERT (func (\".\", 1) == NULL);\n  ASSERT (errno == EINVAL);\n  errno = 0;\n  ASSERT (func (\"./\", 1) == NULL);\n  ASSERT (errno == EINVAL);\n  ASSERT (close (creat (BASE \"file\", 0600)) == 0);\n  errno = 0;\n  ASSERT (func (BASE \"file\", 1) == NULL);\n  ASSERT (errno == EINVAL);\n  errno = 0;\n  ASSERT (func (BASE \"file/\", 1) == NULL);\n  ASSERT (errno == ENOTDIR || errno == EINVAL); /* AIX yields EINVAL */\n  ASSERT (unlink (BASE \"file\") == 0);\n\n  /* Now test actual symlinks.  */\n  if (symlink (BASE \"dir\", BASE \"link\"))\n    {\n      if (print)\n        fputs (\"skipping test: symlinks not supported on this file system\\n\",\n               stderr);\n      return 77;\n    }\n  ASSERT (mkdir (BASE \"dir\", 0700) == 0);\n  errno = 0;\n  ASSERT (func (BASE \"link/\", 1) == NULL);\n  ASSERT (errno == EINVAL);\n  {\n    /* Too small a guess is okay.  */\n    char *buf = func (BASE \"link\", 1);\n    ASSERT (buf);\n    ASSERT (strcmp (buf, BASE \"dir\") == 0);\n    free (buf);\n    /* Too large a guess is okay.  */\n    buf = func (BASE \"link\", 10000000);\n    ASSERT (buf);\n    ASSERT (strcmp (buf, BASE \"dir\") == 0);\n    free (buf);\n  }\n  ASSERT (rmdir (BASE \"dir\") == 0);\n  ASSERT (unlink (BASE \"link\") == 0);\n\n  return 0;\n}",
      "lines": 58,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-areadlinkat.c": {
    "do_areadlinkat": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "static char *\ndo_areadlinkat (char const *name, size_t ignored _GL_UNUSED)\n{\n  return areadlinkat (dfd, name);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "char",
        "*\ndo_areadlinkat (char const *name, size_t ignored _GL_UNUSED)",
        "*"
      ]
    },
    "main": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        88,
        1
      ],
      "content": "int\nmain (void)\n{\n  int result;\n\n  /* Remove any leftovers from a previous partial run.  */\n  ignore_value (system (\"rm -rf \" BASE \"*\"));\n\n  /* Basic tests.  */\n  result = test_areadlink (do_areadlinkat, false);\n  dfd = open (\".\", O_RDONLY);\n  ASSERT (0 <= dfd);\n  ASSERT (test_areadlink (do_areadlinkat, false) == result);\n\n  /* Relative tests.  */\n  if (result == 77)\n    fputs (\"skipping test: symlinks not supported on this file system\\n\",\n           stderr);\n  else\n    {\n      char *buf;\n      ASSERT (symlink (\"nowhere\", BASE \"link\") == 0);\n      ASSERT (mkdir (BASE \"dir\", 0700) == 0);\n      ASSERT (chdir (BASE \"dir\") == 0);\n      buf = areadlinkat (dfd, BASE \"link\");\n      ASSERT (buf);\n      ASSERT (strcmp (buf, \"nowhere\") == 0);\n      free (buf);\n      errno = 0;\n      ASSERT (areadlinkat (-1, BASE \"link\") == NULL);\n      ASSERT (errno == EBADF);\n      errno = 0;\n      ASSERT (areadlinkat (AT_FDCWD, BASE \"link\") == NULL);\n      ASSERT (errno == ENOENT);\n      ASSERT (chdir (\"..\") == 0);\n      ASSERT (rmdir (BASE \"dir\") == 0);\n      ASSERT (unlink (BASE \"link\") == 0);\n    }\n\n  ASSERT (close (dfd) == 0);\n  return result;\n}",
      "lines": 42,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-argmatch.c": {
    "main": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        100,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  set_program_name (argv[0]);\n\n  /* Not found.  */\n  ASSERT (ARGMATCH (\"klingon\", backup_args, backup_vals) == -1);\n\n  /* Exact match.  */\n  ASSERT (ARGMATCH (\"none\", backup_args, backup_vals) == 1);\n  ASSERT (ARGMATCH (\"nil\", backup_args, backup_vals) == 7);\n\n  /* Too long.  */\n  ASSERT (ARGMATCH (\"nilpotent\", backup_args, backup_vals) == -1);\n\n  /* Abbreviated.  */\n  ASSERT (ARGMATCH (\"simpl\", backup_args, backup_vals) == 3);\n  ASSERT (ARGMATCH (\"simp\", backup_args, backup_vals) == 3);\n  ASSERT (ARGMATCH (\"sim\", backup_args, backup_vals) == 3);\n\n  /* Exact match and abbreviated.  */\n  ASSERT (ARGMATCH (\"numbered\", backup_args, backup_vals) == 9);\n  ASSERT (ARGMATCH (\"numbere\", backup_args, backup_vals) == -2);\n  ASSERT (ARGMATCH (\"number\", backup_args, backup_vals) == -2);\n  ASSERT (ARGMATCH (\"numbe\", backup_args, backup_vals) == -2);\n  ASSERT (ARGMATCH (\"numb\", backup_args, backup_vals) == -2);\n  ASSERT (ARGMATCH (\"num\", backup_args, backup_vals) == -2);\n  ASSERT (ARGMATCH (\"nu\", backup_args, backup_vals) == -2);\n  ASSERT (ARGMATCH (\"n\", backup_args, backup_vals) == -2);\n\n  /* Ambiguous abbreviated.  */\n  ASSERT (ARGMATCH (\"ne\", backup_args, backup_vals) == -2);\n\n  /* Ambiguous abbreviated, but same value.  */\n  ASSERT (ARGMATCH (\"si\", backup_args, backup_vals) == 3);\n  ASSERT (ARGMATCH (\"s\", backup_args, backup_vals) == 3);\n\n  return 0;\n}",
      "lines": 39,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-arpa_inet.c": {
    "main": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        26,
        1
      ],
      "content": "int\nmain (void)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-binary-io.c": {
    "main": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  /* Test the O_BINARY macro.  */\n  {\n    int fd =\n      open (\"t-bin-out0.tmp\", O_CREAT | O_TRUNC | O_RDWR | O_BINARY, 0600);\n    if (write (fd, \"Hello\\n\", 6) < 0)\n      exit (1);\n    close (fd);\n  }\n  {\n    struct stat statbuf;\n    if (stat (\"t-bin-out0.tmp\", &statbuf) < 0)\n      exit (1);\n    ASSERT (statbuf.st_size == 6);\n  }\n\n  switch (argv[1][0])\n    {\n    case '1':\n      /* Test the set_binary_mode() function.  */\n      set_binary_mode (1, O_BINARY);\n      fputs (\"Hello\\n\", stdout);\n      break;\n\n    case '2':\n      /* Test the SET_BINARY macro.  */\n      SET_BINARY (1);\n      fputs (\"Hello\\n\", stdout);\n      break;\n\n    default:\n      break;\n    }\n\n  return 0;\n}",
      "lines": 38,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-bind.c": {
    "main": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "int\nmain (void)\n{\n  (void) gl_sockets_startup (SOCKETS_1_1);\n\n  /* Test behaviour for invalid file descriptors.  */\n  {\n    struct sockaddr_in addr;\n\n    addr.sin_family = AF_INET;\n    inet_pton (AF_INET, \"127.0.0.1\", &addr.sin_addr);\n    addr.sin_port = htons (80);\n    {\n      errno = 0;\n      ASSERT (bind (-1, (const struct sockaddr *) &addr, sizeof (addr)) == -1);\n      ASSERT (errno == EBADF);\n    }\n    {\n      close (99);\n      errno = 0;\n      ASSERT (bind (99, (const struct sockaddr *) &addr, sizeof (addr)) == -1);\n      ASSERT (errno == EBADF);\n    }\n  }\n\n  return 0;\n}",
      "lines": 27,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-bitrotate.c": {
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        278,
        1
      ],
      "content": "int\nmain (void)\n{\n  ASSERT (rotl8 (42, 0) == 42);\n  ASSERT (rotl8 (42, 1) == 84);\n  ASSERT (rotl8 (42, 2) == 168);\n  ASSERT (rotl8 (42, 3) == 81);\n  ASSERT (rotl8 (42, 4) == 162);\n  ASSERT (rotl8 (42, 5) == 69);\n  ASSERT (rotl8 (42, 6) == 138);\n  ASSERT (rotl8 (42, 7) == 21);\n  ASSERT (rotl8 (42, 8) == 42);\n\n  ASSERT (rotr8 (42, 0) == 42);\n  ASSERT (rotr8 (42, 1) == 21);\n  ASSERT (rotr8 (42, 2) == 138);\n  ASSERT (rotr8 (42, 3) == 69);\n  ASSERT (rotr8 (42, 4) == 162);\n  ASSERT (rotr8 (42, 5) == 81);\n  ASSERT (rotr8 (42, 6) == 168);\n  ASSERT (rotr8 (42, 7) == 84);\n  ASSERT (rotr8 (42, 8) == 42);\n\n  ASSERT (rotl16 (43981, 0) == 43981);\n  ASSERT (rotl16 (43981, 1) == 22427);\n  ASSERT (rotl16 (43981, 2) == 44854);\n  ASSERT (rotl16 (43981, 3) == 24173);\n  ASSERT (rotl16 (43981, 4) == 48346);\n  ASSERT (rotl16 (43981, 5) == 31157);\n  ASSERT (rotl16 (43981, 6) == 62314);\n  ASSERT (rotl16 (43981, 7) == 59093);\n  ASSERT (rotl16 (43981, 8) == 52651);\n  ASSERT (rotl16 (43981, 9) == 39767);\n  ASSERT (rotl16 (43981, 10) == 13999);\n  ASSERT (rotl16 (43981, 11) == 27998);\n  ASSERT (rotl16 (43981, 12) == 55996);\n  ASSERT (rotl16 (43981, 13) == 46457);\n  ASSERT (rotl16 (43981, 14) == 27379);\n  ASSERT (rotl16 (43981, 15) == 54758);\n  ASSERT (rotl16 (43981, 16) == 43981);\n\n  ASSERT (rotr16 (43981, 0) == 43981);\n  ASSERT (rotr16 (43981, 1) == 54758);\n  ASSERT (rotr16 (43981, 2) == 27379);\n  ASSERT (rotr16 (43981, 3) == 46457);\n  ASSERT (rotr16 (43981, 4) == 55996);\n  ASSERT (rotr16 (43981, 5) == 27998);\n  ASSERT (rotr16 (43981, 6) == 13999);\n  ASSERT (rotr16 (43981, 7) == 39767);\n  ASSERT (rotr16 (43981, 8) == 52651);\n  ASSERT (rotr16 (43981, 9) == 59093);\n  ASSERT (rotr16 (43981, 10) == 62314);\n  ASSERT (rotr16 (43981, 11) == 31157);\n  ASSERT (rotr16 (43981, 12) == 48346);\n  ASSERT (rotr16 (43981, 13) == 24173);\n  ASSERT (rotr16 (43981, 14) == 44854);\n  ASSERT (rotr16 (43981, 15) == 22427);\n  ASSERT (rotr16 (43981, 16) == 43981);\n\n  ASSERT (rotl32 (2309737967U, 1) == 324508639U);\n  ASSERT (rotl32 (2309737967U, 2) == 649017278U);\n  ASSERT (rotl32 (2309737967U, 3) == 1298034556U);\n  ASSERT (rotl32 (2309737967U, 4) == 2596069112U);\n  ASSERT (rotl32 (2309737967U, 5) == 897170929U);\n  ASSERT (rotl32 (2309737967U, 6) == 1794341858U);\n  ASSERT (rotl32 (2309737967U, 7) == 3588683716U);\n  ASSERT (rotl32 (2309737967U, 8) == 2882400137U);\n  ASSERT (rotl32 (2309737967U, 9) == 1469832979U);\n  ASSERT (rotl32 (2309737967U, 10) == 2939665958U);\n  ASSERT (rotl32 (2309737967U, 11) == 1584364621U);\n  ASSERT (rotl32 (2309737967U, 12) == 3168729242U);\n  ASSERT (rotl32 (2309737967U, 13) == 2042491189U);\n  ASSERT (rotl32 (2309737967U, 14) == 4084982378U);\n  ASSERT (rotl32 (2309737967U, 15) == 3874997461U);\n  ASSERT (rotl32 (2309737967U, 16) == 3455027627U);\n  ASSERT (rotl32 (2309737967U, 17) == 2615087959U);\n  ASSERT (rotl32 (2309737967U, 18) == 935208623U);\n  ASSERT (rotl32 (2309737967U, 19) == 1870417246U);\n  ASSERT (rotl32 (2309737967U, 20) == 3740834492U);\n  ASSERT (rotl32 (2309737967U, 21) == 3186701689U);\n  ASSERT (rotl32 (2309737967U, 22) == 2078436083U);\n  ASSERT (rotl32 (2309737967U, 23) == 4156872166U);\n  ASSERT (rotl32 (2309737967U, 24) == 4018777037U);\n  ASSERT (rotl32 (2309737967U, 25) == 3742586779U);\n  ASSERT (rotl32 (2309737967U, 26) == 3190206263U);\n  ASSERT (rotl32 (2309737967U, 27) == 2085445231U);\n  ASSERT (rotl32 (2309737967U, 28) == 4170890462U);\n  ASSERT (rotl32 (2309737967U, 29) == 4046813629U);\n  ASSERT (rotl32 (2309737967U, 30) == 3798659963U);\n  ASSERT (rotl32 (2309737967U, 31) == 3302352631U);\n\n  ASSERT (rotr32 (2309737967U, 1) == 3302352631lU);\n  ASSERT (rotr32 (2309737967U, 2) == 3798659963lU);\n  ASSERT (rotr32 (2309737967U, 3) == 4046813629lU);\n  ASSERT (rotr32 (2309737967U, 4) == 4170890462lU);\n  ASSERT (rotr32 (2309737967U, 5) == 2085445231lU);\n  ASSERT (rotr32 (2309737967U, 6) == 3190206263lU);\n  ASSERT (rotr32 (2309737967U, 7) == 3742586779lU);\n  ASSERT (rotr32 (2309737967U, 8) == 4018777037lU);\n  ASSERT (rotr32 (2309737967U, 9) == 4156872166lU);\n  ASSERT (rotr32 (2309737967U, 10) == 2078436083lU);\n  ASSERT (rotr32 (2309737967U, 11) == 3186701689lU);\n  ASSERT (rotr32 (2309737967U, 12) == 3740834492lU);\n  ASSERT (rotr32 (2309737967U, 13) == 1870417246lU);\n  ASSERT (rotr32 (2309737967U, 14) == 935208623lU);\n  ASSERT (rotr32 (2309737967U, 15) == 2615087959lU);\n  ASSERT (rotr32 (2309737967U, 16) == 3455027627lU);\n  ASSERT (rotr32 (2309737967U, 17) == 3874997461lU);\n  ASSERT (rotr32 (2309737967U, 18) == 4084982378lU);\n  ASSERT (rotr32 (2309737967U, 19) == 2042491189lU);\n  ASSERT (rotr32 (2309737967U, 20) == 3168729242lU);\n  ASSERT (rotr32 (2309737967U, 21) == 1584364621lU);\n  ASSERT (rotr32 (2309737967U, 22) == 2939665958lU);\n  ASSERT (rotr32 (2309737967U, 23) == 1469832979lU);\n  ASSERT (rotr32 (2309737967U, 24) == 2882400137lU);\n  ASSERT (rotr32 (2309737967U, 25) == 3588683716lU);\n  ASSERT (rotr32 (2309737967U, 26) == 1794341858lU);\n  ASSERT (rotr32 (2309737967U, 27) == 897170929lU);\n  ASSERT (rotr32 (2309737967U, 28) == 2596069112lU);\n  ASSERT (rotr32 (2309737967U, 29) == 1298034556lU);\n  ASSERT (rotr32 (2309737967U, 30) == 649017278lU);\n  ASSERT (rotr32 (2309737967U, 31) == 324508639lU);\n\n#ifdef UINT64_MAX\n  ASSERT (rotl64 (16045690984503098046ULL, 1) == 13644637895296644477ULL);\n  ASSERT (rotl64 (16045690984503098046ULL, 2) == 8842531716883737339ULL);\n  ASSERT (rotl64 (16045690984503098046ULL, 3) == 17685063433767474678ULL);\n  ASSERT (rotl64 (16045690984503098046ULL, 4) == 16923382793825397741ULL);\n  ASSERT (rotl64 (16045690984503098046ULL, 5) == 15400021513941243867ULL);\n  ASSERT (rotl64 (16045690984503098046ULL, 6) == 12353298954172936119ULL);\n  ASSERT (rotl64 (16045690984503098046ULL, 7) == 6259853834636320623ULL);\n  ASSERT (rotl64 (16045690984503098046ULL, 8) == 12519707669272641246ULL);\n  ASSERT (rotl64 (16045690984503098046ULL, 9) == 6592671264835730877ULL);\n  ASSERT (rotl64 (16045690984503098046ULL, 10) == 13185342529671461754ULL);\n  ASSERT (rotl64 (16045690984503098046ULL, 11) == 7923940985633371893ULL);\n  ASSERT (rotl64 (16045690984503098046ULL, 12) == 15847881971266743786ULL);\n  ASSERT (rotl64 (16045690984503098046ULL, 13) == 13249019868823935957ULL);\n  ASSERT (rotl64 (16045690984503098046ULL, 14) == 8051295663938320299ULL);\n  ASSERT (rotl64 (16045690984503098046ULL, 15) == 16102591327876640598ULL);\n  ASSERT (rotl64 (16045690984503098046ULL, 16) == 13758438582043729581ULL);\n  ASSERT (rotl64 (16045690984503098046ULL, 17) == 9070133090377907547ULL);\n  ASSERT (rotl64 (16045690984503098046ULL, 18) == 18140266180755815094ULL);\n  ASSERT (rotl64 (16045690984503098046ULL, 19) == 17833788287802078573ULL);\n  ASSERT (rotl64 (16045690984503098046ULL, 20) == 17220832501894605531ULL);\n  ASSERT (rotl64 (16045690984503098046ULL, 21) == 15994920930079659447ULL);\n  ASSERT (rotl64 (16045690984503098046ULL, 22) == 13543097786449767279ULL);\n  ASSERT (rotl64 (16045690984503098046ULL, 23) == 8639451499189982943ULL);\n  ASSERT (rotl64 (16045690984503098046ULL, 24) == 17278902998379965886ULL);\n  ASSERT (rotl64 (16045690984503098046ULL, 25) == 16111061923050380157ULL);\n  ASSERT (rotl64 (16045690984503098046ULL, 26) == 13775379772391208699ULL);\n  ASSERT (rotl64 (16045690984503098046ULL, 27) == 9104015471072865783ULL);\n  ASSERT (rotl64 (16045690984503098046ULL, 28) == 18208030942145731566ULL);\n  ASSERT (rotl64 (16045690984503098046ULL, 29) == 17969317810581911517ULL);\n  ASSERT (rotl64 (16045690984503098046ULL, 30) == 17491891547454271419ULL);\n  ASSERT (rotl64 (16045690984503098046ULL, 31) == 16537039021198991223ULL);\n  ASSERT (rotl64 (16045690984503098046ULL, 32) == 14627333968688430831ULL);\n  ASSERT (rotl64 (16045690984503098046ULL, 33) == 10807923863667310047ULL);\n  ASSERT (rotl64 (16045690984503098046ULL, 34) == 3169103653625068479ULL);\n  ASSERT (rotl64 (16045690984503098046ULL, 35) == 6338207307250136958ULL);\n  ASSERT (rotl64 (16045690984503098046ULL, 36) == 12676414614500273916ULL);\n  ASSERT (rotl64 (16045690984503098046ULL, 37) == 6906085155290996217ULL);\n  ASSERT (rotl64 (16045690984503098046ULL, 38) == 13812170310581992434ULL);\n  ASSERT (rotl64 (16045690984503098046ULL, 39) == 9177596547454433253ULL);\n  ASSERT (rotl64 (16045690984503098046ULL, 40) == 18355193094908866506ULL);\n  ASSERT (rotl64 (16045690984503098046ULL, 41) == 18263642116108181397ULL);\n  ASSERT (rotl64 (16045690984503098046ULL, 42) == 18080540158506811179ULL);\n  ASSERT (rotl64 (16045690984503098046ULL, 43) == 17714336243304070743ULL);\n  ASSERT (rotl64 (16045690984503098046ULL, 44) == 16981928412898589871ULL);\n  ASSERT (rotl64 (16045690984503098046ULL, 45) == 15517112752087628127ULL);\n  ASSERT (rotl64 (16045690984503098046ULL, 46) == 12587481430465704639ULL);\n  ASSERT (rotl64 (16045690984503098046ULL, 47) == 6728218787221857663ULL);\n  ASSERT (rotl64 (16045690984503098046ULL, 48) == 13456437574443715326ULL);\n  ASSERT (rotl64 (16045690984503098046ULL, 49) == 8466131075177879037ULL);\n  ASSERT (rotl64 (16045690984503098046ULL, 50) == 16932262150355758074ULL);\n  ASSERT (rotl64 (16045690984503098046ULL, 51) == 15417780227001964533ULL);\n  ASSERT (rotl64 (16045690984503098046ULL, 52) == 12388816380294377451ULL);\n  ASSERT (rotl64 (16045690984503098046ULL, 53) == 6330888686879203287ULL);\n  ASSERT (rotl64 (16045690984503098046ULL, 54) == 12661777373758406574ULL);\n  ASSERT (rotl64 (16045690984503098046ULL, 55) == 6876810673807261533ULL);\n  ASSERT (rotl64 (16045690984503098046ULL, 56) == 13753621347614523066ULL);\n  ASSERT (rotl64 (16045690984503098046ULL, 57) == 9060498621519494517ULL);\n  ASSERT (rotl64 (16045690984503098046ULL, 58) == 18120997243038989034ULL);\n  ASSERT (rotl64 (16045690984503098046ULL, 59) == 17795250412368426453ULL);\n  ASSERT (rotl64 (16045690984503098046ULL, 60) == 17143756751027301291ULL);\n  ASSERT (rotl64 (16045690984503098046ULL, 61) == 15840769428345050967ULL);\n  ASSERT (rotl64 (16045690984503098046ULL, 62) == 13234794782980550319ULL);\n  ASSERT (rotl64 (16045690984503098046ULL, 63) == 8022845492251549023ULL);\n\n  ASSERT (rotr64 (16045690984503098046ULL, 1) == 8022845492251549023ULL);\n  ASSERT (rotr64 (16045690984503098046ULL, 2) == 13234794782980550319ULL);\n  ASSERT (rotr64 (16045690984503098046ULL, 3) == 15840769428345050967ULL);\n  ASSERT (rotr64 (16045690984503098046ULL, 4) == 17143756751027301291ULL);\n  ASSERT (rotr64 (16045690984503098046ULL, 5) == 17795250412368426453ULL);\n  ASSERT (rotr64 (16045690984503098046ULL, 6) == 18120997243038989034ULL);\n  ASSERT (rotr64 (16045690984503098046ULL, 7) == 9060498621519494517ULL);\n  ASSERT (rotr64 (16045690984503098046ULL, 8) == 13753621347614523066ULL);\n  ASSERT (rotr64 (16045690984503098046ULL, 9) == 6876810673807261533ULL);\n  ASSERT (rotr64 (16045690984503098046ULL, 10) == 12661777373758406574ULL);\n  ASSERT (rotr64 (16045690984503098046ULL, 11) == 6330888686879203287ULL);\n  ASSERT (rotr64 (16045690984503098046ULL, 12) == 12388816380294377451ULL);\n  ASSERT (rotr64 (16045690984503098046ULL, 13) == 15417780227001964533ULL);\n  ASSERT (rotr64 (16045690984503098046ULL, 14) == 16932262150355758074ULL);\n  ASSERT (rotr64 (16045690984503098046ULL, 15) == 8466131075177879037ULL);\n  ASSERT (rotr64 (16045690984503098046ULL, 16) == 13456437574443715326ULL);\n  ASSERT (rotr64 (16045690984503098046ULL, 17) == 6728218787221857663ULL);\n  ASSERT (rotr64 (16045690984503098046ULL, 18) == 12587481430465704639ULL);\n  ASSERT (rotr64 (16045690984503098046ULL, 19) == 15517112752087628127ULL);\n  ASSERT (rotr64 (16045690984503098046ULL, 20) == 16981928412898589871ULL);\n  ASSERT (rotr64 (16045690984503098046ULL, 21) == 17714336243304070743ULL);\n  ASSERT (rotr64 (16045690984503098046ULL, 22) == 18080540158506811179ULL);\n  ASSERT (rotr64 (16045690984503098046ULL, 23) == 18263642116108181397ULL);\n  ASSERT (rotr64 (16045690984503098046ULL, 24) == 18355193094908866506ULL);\n  ASSERT (rotr64 (16045690984503098046ULL, 25) == 9177596547454433253ULL);\n  ASSERT (rotr64 (16045690984503098046ULL, 26) == 13812170310581992434ULL);\n  ASSERT (rotr64 (16045690984503098046ULL, 27) == 6906085155290996217ULL);\n  ASSERT (rotr64 (16045690984503098046ULL, 28) == 12676414614500273916ULL);\n  ASSERT (rotr64 (16045690984503098046ULL, 29) == 6338207307250136958ULL);\n  ASSERT (rotr64 (16045690984503098046ULL, 30) == 3169103653625068479ULL);\n  ASSERT (rotr64 (16045690984503098046ULL, 31) == 10807923863667310047ULL);\n  ASSERT (rotr64 (16045690984503098046ULL, 32) == 14627333968688430831ULL);\n  ASSERT (rotr64 (16045690984503098046ULL, 33) == 16537039021198991223ULL);\n  ASSERT (rotr64 (16045690984503098046ULL, 34) == 17491891547454271419ULL);\n  ASSERT (rotr64 (16045690984503098046ULL, 35) == 17969317810581911517ULL);\n  ASSERT (rotr64 (16045690984503098046ULL, 36) == 18208030942145731566ULL);\n  ASSERT (rotr64 (16045690984503098046ULL, 37) == 9104015471072865783ULL);\n  ASSERT (rotr64 (16045690984503098046ULL, 38) == 13775379772391208699ULL);\n  ASSERT (rotr64 (16045690984503098046ULL, 39) == 16111061923050380157ULL);\n  ASSERT (rotr64 (16045690984503098046ULL, 40) == 17278902998379965886ULL);\n  ASSERT (rotr64 (16045690984503098046ULL, 41) == 8639451499189982943ULL);\n  ASSERT (rotr64 (16045690984503098046ULL, 42) == 13543097786449767279ULL);\n  ASSERT (rotr64 (16045690984503098046ULL, 43) == 15994920930079659447ULL);\n  ASSERT (rotr64 (16045690984503098046ULL, 44) == 17220832501894605531ULL);\n  ASSERT (rotr64 (16045690984503098046ULL, 45) == 17833788287802078573ULL);\n  ASSERT (rotr64 (16045690984503098046ULL, 46) == 18140266180755815094ULL);\n  ASSERT (rotr64 (16045690984503098046ULL, 47) == 9070133090377907547ULL);\n  ASSERT (rotr64 (16045690984503098046ULL, 48) == 13758438582043729581ULL);\n  ASSERT (rotr64 (16045690984503098046ULL, 49) == 16102591327876640598ULL);\n  ASSERT (rotr64 (16045690984503098046ULL, 50) == 8051295663938320299ULL);\n  ASSERT (rotr64 (16045690984503098046ULL, 51) == 13249019868823935957ULL);\n  ASSERT (rotr64 (16045690984503098046ULL, 52) == 15847881971266743786ULL);\n  ASSERT (rotr64 (16045690984503098046ULL, 53) == 7923940985633371893ULL);\n  ASSERT (rotr64 (16045690984503098046ULL, 54) == 13185342529671461754ULL);\n  ASSERT (rotr64 (16045690984503098046ULL, 55) == 6592671264835730877ULL);\n  ASSERT (rotr64 (16045690984503098046ULL, 56) == 12519707669272641246ULL);\n  ASSERT (rotr64 (16045690984503098046ULL, 57) == 6259853834636320623ULL);\n  ASSERT (rotr64 (16045690984503098046ULL, 58) == 12353298954172936119ULL);\n  ASSERT (rotr64 (16045690984503098046ULL, 59) == 15400021513941243867ULL);\n  ASSERT (rotr64 (16045690984503098046ULL, 60) == 16923382793825397741ULL);\n  ASSERT (rotr64 (16045690984503098046ULL, 61) == 17685063433767474678ULL);\n  ASSERT (rotr64 (16045690984503098046ULL, 62) == 8842531716883737339ULL);\n  ASSERT (rotr64 (16045690984503098046ULL, 63) == 13644637895296644477ULL);\n#endif /* UINT64_MAX */\n\n  return 0;\n}",
      "lines": 255,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-btowc.c": {
    "main": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  int c;\n\n  /* configure should already have checked that the locale is supported.  */\n  if (setlocale (LC_ALL, \"\") == NULL)\n    return 1;\n\n  ASSERT (btowc (EOF) == WEOF);\n\n  if (argc > 1)\n    switch (argv[1][0])\n      {\n      case '1':\n        /* Locale encoding is ISO-8859-1 or ISO-8859-15.  */\n        for (c = 0; c < 0x80; c++)\n          ASSERT (btowc (c) == c);\n        for (c = 0xA0; c < 0x100; c++)\n          ASSERT (btowc (c) != WEOF);\n        return 0;\n\n      case '2':\n        /* Locale encoding is UTF-8.  */\n        for (c = 0; c < 0x80; c++)\n          ASSERT (btowc (c) == c);\n        for (c = 0x80; c < 0x100; c++)\n          ASSERT (btowc (c) == WEOF);\n        return 0;\n      }\n\n  return 1;\n}",
      "lines": 33,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-byteswap.c": {
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        31,
        1
      ],
      "content": "int\nmain ()\n{\n  ASSERT (bswap_16 (0xABCD) == 0xCDAB);\n  ASSERT (bswap_32 (0xDEADBEEF) == 0xEFBEADDE);\n\n  return 0;\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-c-ctype.c": {
    "test_agree_with_C_locale": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "static void\ntest_agree_with_C_locale (void)\n{\n  int c;\n\n  for (c = 0; c <= UCHAR_MAX; c++)\n    {\n      ASSERT (c_isascii (c) == (isascii (c) != 0));\n      if (c_isascii (c))\n        {\n          ASSERT (c_isalnum (c) == (isalnum (c) != 0));\n          ASSERT (c_isalpha (c) == (isalpha (c) != 0));\n          ASSERT (c_isblank (c) == (isblank (c) != 0));\n          ASSERT (c_iscntrl (c) == (iscntrl (c) != 0));\n          ASSERT (c_isdigit (c) == (isdigit (c) != 0));\n          ASSERT (c_islower (c) == (islower (c) != 0));\n          ASSERT (c_isgraph (c) == (isgraph (c) != 0));\n          ASSERT (c_isprint (c) == (isprint (c) != 0));\n          ASSERT (c_ispunct (c) == (ispunct (c) != 0));\n          ASSERT (c_isspace (c) == (isspace (c) != 0));\n          ASSERT (c_isupper (c) == (isupper (c) != 0));\n          ASSERT (c_isxdigit (c) == (isxdigit (c) != 0));\n          ASSERT (c_tolower (c) == tolower (c));\n          ASSERT (c_toupper (c) == toupper (c));\n        }\n    }\n}",
      "lines": 27,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_all": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        211,
        1
      ],
      "content": "static void\ntest_all (void)\n{\n  int c;\n  int n_isascii = 0;\n\n  for (c = CHAR_MIN; c <= UCHAR_MAX; c++)\n    {\n      if (! (0 <= c && c <= CHAR_MAX))\n        {\n          ASSERT (! c_isascii (c));\n          ASSERT (! c_isalnum (c));\n          ASSERT (! c_isalpha (c));\n          ASSERT (! c_isblank (c));\n          ASSERT (! c_iscntrl (c));\n          ASSERT (! c_isdigit (c));\n          ASSERT (! c_islower (c));\n          ASSERT (! c_isgraph (c));\n          ASSERT (! c_isprint (c));\n          ASSERT (! c_ispunct (c));\n          ASSERT (! c_isspace (c));\n          ASSERT (! c_isupper (c));\n          ASSERT (! c_isxdigit (c));\n          ASSERT (c_tolower (c) == c);\n          ASSERT (c_toupper (c) == c);\n        }\n\n      n_isascii += c_isascii (c);\n\n#ifdef C_CTYPE_ASCII\n      ASSERT (c_isascii (c) == (0 <= c && c <= 0x7f));\n#endif\n\n      ASSERT (c_isascii (c) == (c_isprint (c) || c_iscntrl (c)));\n\n      ASSERT (c_isalnum (c) == (c_isalpha (c) || c_isdigit (c)));\n\n      ASSERT (c_isalpha (c) == (c_islower (c) || c_isupper (c)));\n\n      switch (c)\n        {\n        case '\\t': case ' ':\n          ASSERT (c_isblank (c) == 1);\n          break;\n        default:\n          ASSERT (c_isblank (c) == 0);\n          break;\n        }\n\n#ifdef C_CTYPE_ASCII\n      ASSERT (c_iscntrl (c) == ((c >= 0 && c < 0x20) || c == 0x7f));\n#endif\n\n      switch (c)\n        {\n        case '\\a': case '\\b': case '\\f': case '\\n':\n        case '\\r': case '\\t': case '\\v':\n          ASSERT (c_iscntrl (c));\n          break;\n        }\n\n      ASSERT (! (c_iscntrl (c) && c_isprint (c)));\n\n      switch (c)\n        {\n        case '0': case '1': case '2': case '3': case '4': case '5':\n        case '6': case '7': case '8': case '9':\n          ASSERT (c_isdigit (c) == 1);\n          break;\n        default:\n          ASSERT (c_isdigit (c) == 0);\n          break;\n        }\n\n      switch (c)\n        {\n        case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n        case 'g': case 'h': case 'i': case 'j': case 'k': case 'l':\n        case 'm': case 'n': case 'o': case 'p': case 'q': case 'r':\n        case 's': case 't': case 'u': case 'v': case 'w': case 'x':\n        case 'y': case 'z':\n          ASSERT (c_islower (c) == 1);\n          ASSERT (c_toupper (c) == c - 'a' + 'A');\n          break;\n        default:\n          ASSERT (c_islower (c) == 0);\n          ASSERT (c_toupper (c) == c);\n          break;\n        }\n\n#ifdef C_CTYPE_ASCII\n      ASSERT (c_isgraph (c) == ((c >= 0x20 && c < 0x7f) && c != ' '));\n\n      ASSERT (c_isprint (c) == (c >= 0x20 && c < 0x7f));\n#endif\n\n      ASSERT (c_isgraph (c) == (c_isalnum (c) || c_ispunct (c)));\n\n      ASSERT (c_isprint (c) == (c_isgraph (c) || c == ' '));\n\n      switch (c)\n        {\n        case '!': case '\"': case '#': case '$': case '%': case '&': case '\\'':\n        case '(': case ')': case '*': case '+': case ',': case '-': case '.':\n        case '/': case ':': case ';': case '<': case '=': case '>': case '?':\n        case '@': case '[': case'\\\\': case ']': case '^': case '_': case '`':\n        case '{': case '|': case '}': case '~':\n          ASSERT (c_ispunct (c) == 1);\n          break;\n        default:\n          ASSERT (c_ispunct (c) == 0);\n          break;\n        }\n\n      switch (c)\n        {\n        case ' ': case '\\t': case '\\n': case '\\v': case '\\f': case '\\r':\n          ASSERT (c_isspace (c) == 1);\n          break;\n        default:\n          ASSERT (c_isspace (c) == 0);\n          break;\n        }\n\n      switch (c)\n        {\n        case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n        case 'G': case 'H': case 'I': case 'J': case 'K': case 'L':\n        case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':\n        case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n        case 'Y': case 'Z':\n          ASSERT (c_isupper (c) == 1);\n          ASSERT (c_tolower (c) == c - 'A' + 'a');\n          break;\n        default:\n          ASSERT (c_isupper (c) == 0);\n          ASSERT (c_tolower (c) == c);\n          break;\n        }\n\n      switch (c)\n        {\n        case '0': case '1': case '2': case '3': case '4': case '5':\n        case '6': case '7': case '8': case '9':\n        case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n        case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n          ASSERT (c_isxdigit (c) == 1);\n          break;\n        default:\n          ASSERT (c_isxdigit (c) == 0);\n          break;\n        }\n    }\n\n  ASSERT (n_isascii == 128);\n}",
      "lines": 156,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        213,
        0
      ],
      "end_point": [
        227,
        1
      ],
      "content": "int\nmain ()\n{\n  test_agree_with_C_locale ();\n\n  test_all ();\n\n  setlocale (LC_ALL, \"de_DE\");\n  test_all ();\n\n  setlocale (LC_ALL, \"ja_JP.EUC-JP\");\n  test_all ();\n\n  return 0;\n}",
      "lines": 15,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-c-strcasecmp.c": {
    "main": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  if (argc > 1)\n    {\n      /* configure should already have checked that the locale is supported.  */\n      if (setlocale (LC_ALL, \"\") == NULL)\n        return 1;\n    }\n\n  ASSERT (c_strcasecmp (\"paragraph\", \"Paragraph\") == 0);\n\n  ASSERT (c_strcasecmp (\"paragrapH\", \"parAgRaph\") == 0);\n\n  ASSERT (c_strcasecmp (\"paragraph\", \"paraLyzed\") < 0);\n  ASSERT (c_strcasecmp (\"paraLyzed\", \"paragraph\") > 0);\n\n  ASSERT (c_strcasecmp (\"para\", \"paragraph\") < 0);\n  ASSERT (c_strcasecmp (\"paragraph\", \"para\") > 0);\n\n  /* The following tests shows how c_strcasecmp() is different from\n     strcasecmp().  */\n\n  ASSERT (c_strcasecmp (\"\\311mile\", \"\\351mile\") < 0);\n  ASSERT (c_strcasecmp (\"\\351mile\", \"\\311mile\") > 0);\n\n  /* The following tests shows how c_strcasecmp() is different from\n     mbscasecmp().  */\n\n  ASSERT (c_strcasecmp (\"\\303\\266zg\\303\\274r\", \"\\303\\226ZG\\303\\234R\") > 0); /* \u00c3\u00b6zg\u00c3\u00bcr */\n  ASSERT (c_strcasecmp (\"\\303\\226ZG\\303\\234R\", \"\\303\\266zg\\303\\274r\") < 0); /* \u00c3\u00b6zg\u00c3\u00bcr */\n\n  /* This test shows how strings of different size cannot compare equal.  */\n  ASSERT (c_strcasecmp (\"turkish\", \"TURK\\304\\260SH\") < 0);\n  ASSERT (c_strcasecmp (\"TURK\\304\\260SH\", \"turkish\") > 0);\n\n  return 0;\n}",
      "lines": 38,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-c-strcasestr.c": {
    "main": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        240,
        1
      ],
      "content": "int\nmain ()\n{\n  {\n    const char input[] = \"foo\";\n    const char *result = c_strcasestr (input, \"\");\n    ASSERT (result == input);\n  }\n\n  {\n    const char input[] = \"foo\";\n    const char *result = c_strcasestr (input, \"O\");\n    ASSERT (result == input + 1);\n  }\n\n  {\n    const char input[] = \"ABC ABCDAB ABCDABCDABDE\";\n    const char *result = c_strcasestr (input, \"ABCDaBD\");\n    ASSERT (result == input + 15);\n  }\n\n  {\n    const char input[] = \"ABC ABCDAB ABCDABCDABDE\";\n    const char *result = c_strcasestr (input, \"ABCDaBE\");\n    ASSERT (result == NULL);\n  }\n\n  {\n    const char input[] = \"ABC ABCDAB ABCDABCDABDE\";\n    const char *result = c_strcasestr (input, \"ABCDaBCD\");\n    ASSERT (result == input + 11);\n  }\n\n  /* Check that a long periodic needle does not cause false positives.  */\n  {\n    const char input[] = (\"F_BD_CE_BD_EF_BF_BD_EF_BF_BD_EF_BF_BD_EF_BF_BD\"\n                          \"_C3_88_20_EF_BF_BD_EF_BF_BD_EF_BF_BD\"\n                          \"_C3_A7_20_EF_BF_BD\");\n    const char need[] = \"_EF_BF_BD_EF_BF_BD_EF_BF_BD_EF_BF_BD_EF_BF_BD\";\n    const char *result = c_strcasestr (input, need);\n    ASSERT (result == NULL);\n  }\n  {\n    const char input[] = (\"F_BD_CE_BD_EF_BF_BD_EF_BF_BD_EF_BF_BD_EF_BF_BD\"\n                          \"_C3_88_20_EF_BF_BD_EF_BF_BD_EF_BF_BD\"\n                          \"_C3_A7_20_EF_BF_BD_DA_B5_C2_A6_20\"\n                          \"_EF_BF_BD_EF_BF_BD_EF_BF_BD_EF_BF_BD_EF_BF_BD\");\n    const char need[] = \"_EF_BF_BD_EF_BF_BD_EF_BF_BD_EF_BF_BD_EF_BF_BD\";\n    const char *result = c_strcasestr (input, need);\n    ASSERT (result == input + 115);\n  }\n\n  /* Check that a very long haystack is handled quickly if the needle is\n     short and occurs near the beginning.  */\n  {\n    size_t repeat = 10000;\n    size_t m = 1000000;\n    const char *needle =\n      \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaAaaaaaaAAAAaaaaaaa\"\n      \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\";\n    char *haystack = (char *) malloc (m + 1);\n    if (haystack != NULL)\n      {\n        memset (haystack, 'A', m);\n        haystack[0] = 'B';\n        haystack[m] = '\\0';\n\n        for (; repeat > 0; repeat--)\n          {\n            ASSERT (c_strcasestr (haystack, needle) == haystack + 1);\n          }\n\n        free (haystack);\n      }\n  }\n\n  /* Check that a very long needle is discarded quickly if the haystack is\n     short.  */\n  {\n    size_t repeat = 10000;\n    size_t m = 1000000;\n    const char *haystack =\n      \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n      \"ABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABAB\";\n    char *needle = (char *) malloc (m + 1);\n    if (needle != NULL)\n      {\n        memset (needle, 'A', m);\n        needle[m] = '\\0';\n\n        for (; repeat > 0; repeat--)\n          {\n            ASSERT (c_strcasestr (haystack, needle) == NULL);\n          }\n\n        free (needle);\n      }\n  }\n\n  /* Check that the asymptotic worst-case complexity is not quadratic.  */\n  {\n    size_t m = 1000000;\n    char *haystack = (char *) malloc (2 * m + 2);\n    char *needle = (char *) malloc (m + 2);\n    if (haystack != NULL && needle != NULL)\n      {\n        const char *result;\n\n        memset (haystack, 'A', 2 * m);\n        haystack[2 * m] = 'B';\n        haystack[2 * m + 1] = '\\0';\n\n        memset (needle, 'a', m);\n        needle[m] = 'B';\n        needle[m + 1] = '\\0';\n\n        result = c_strcasestr (haystack, needle);\n        ASSERT (result == haystack + m);\n      }\n    free (needle);\n    free (haystack);\n  }\n\n  {\n    /* Ensure that with a barely periodic \"short\" needle, c_strcasestr's\n       search does not mistakenly skip just past the match point.\n       This use of c_strcasestr would mistakenly return NULL before\n       gnulib v0.0-4927.  */\n    const char *haystack =\n      \"\\n\"\n      \"with_build_libsubdir\\n\"\n      \"with_local_prefix\\n\"\n      \"with_gxx_include_dir\\n\"\n      \"with_cpp_install_dir\\n\"\n      \"enable_generated_files_in_srcdir\\n\"\n      \"with_gnu_ld\\n\"\n      \"with_ld\\n\"\n      \"with_demangler_in_ld\\n\"\n      \"with_gnu_as\\n\"\n      \"with_as\\n\"\n      \"enable_largefile\\n\"\n      \"enable_werror_always\\n\"\n      \"enable_checking\\n\"\n      \"enable_coverage\\n\"\n      \"enable_gather_detailed_mem_stats\\n\"\n      \"enable_build_with_cxx\\n\"\n      \"with_stabs\\n\"\n      \"enable_multilib\\n\"\n      \"enable___cxa_atexit\\n\"\n      \"enable_decimal_float\\n\"\n      \"enable_fixed_point\\n\"\n      \"enable_threads\\n\"\n      \"enable_tls\\n\"\n      \"enable_objc_gc\\n\"\n      \"with_dwarf2\\n\"\n      \"enable_shared\\n\"\n      \"with_build_sysroot\\n\"\n      \"with_sysroot\\n\"\n      \"with_specs\\n\"\n      \"with_pkgversion\\n\"\n      \"with_bugurl\\n\"\n      \"enable_languages\\n\"\n      \"with_multilib_list\\n\";\n    const char *needle = \"\\n\"\n      \"with_GNU_ld\\n\";\n    const char* p = c_strcasestr (haystack, needle);\n    ASSERT (p - haystack == 114);\n  }\n\n  {\n    /* Same bug, shorter trigger.  */\n    const char *haystack = \"..wi.D.\";\n    const char *needle = \".d.\";\n    const char* p = c_strcasestr (haystack, needle);\n    ASSERT (p - haystack == 4);\n  }\n\n  {\n    /* Like the above, but trigger the flaw in two_way_long_needle\n       by using a needle of length LONG_NEEDLE_THRESHOLD (32) or greater.\n       Rather than trying to find the right alignment manually, I've\n       arbitrarily chosen the following needle and template for the\n       haystack, and ensure that for each placement of the needle in\n       that haystack, c_strcasestr finds it.  */\n    const char *needle = \"\\nwith_gnu_ld-extend-to-len-32-b\\n\";\n    const char *h =\n      \"\\n\"\n      \"with_build_libsubdir\\n\"\n      \"with_local_prefix\\n\"\n      \"with_gxx_include_dir\\n\"\n      \"with_cpp_install_dir\\n\"\n      \"with_e_\\n\"\n      \"..............................\\n\"\n      \"with_FGHIJKLMNOPQRSTUVWXYZ\\n\"\n      \"with_567890123456789\\n\"\n      \"with_multilib_list\\n\";\n    size_t h_len = strlen (h);\n    char *haystack = malloc (h_len + 1);\n    size_t i;\n    ASSERT (haystack);\n    for (i = 0; i < h_len - strlen (needle); i++)\n      {\n        const char *p;\n        memcpy (haystack, h, h_len + 1);\n        memcpy (haystack + i, needle, strlen (needle) + 1);\n        p = c_strcasestr (haystack, needle);\n        ASSERT (p);\n        ASSERT (p - haystack == i);\n      }\n  }\n\n  return 0;\n}",
      "lines": 214,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-c-strncasecmp.c": {
    "main": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  if (argc > 1)\n    {\n      /* configure should already have checked that the locale is supported.  */\n      if (setlocale (LC_ALL, \"\") == NULL)\n        return 1;\n    }\n\n  ASSERT (c_strncasecmp (\"paragraph\", \"Paragraph\", 1000000) == 0);\n  ASSERT (c_strncasecmp (\"paragraph\", \"Paragraph\", 9) == 0);\n\n  ASSERT (c_strncasecmp (\"paragrapH\", \"parAgRaph\", 1000000) == 0);\n  ASSERT (c_strncasecmp (\"paragrapH\", \"parAgRaph\", 9) == 0);\n\n  ASSERT (c_strncasecmp (\"paragraph\", \"paraLyzed\", 10) < 0);\n  ASSERT (c_strncasecmp (\"paragraph\", \"paraLyzed\", 9) < 0);\n  ASSERT (c_strncasecmp (\"paragraph\", \"paraLyzed\", 5) < 0);\n  ASSERT (c_strncasecmp (\"paragraph\", \"paraLyzed\", 4) == 0);\n  ASSERT (c_strncasecmp (\"paraLyzed\", \"paragraph\", 10) > 0);\n  ASSERT (c_strncasecmp (\"paraLyzed\", \"paragraph\", 9) > 0);\n  ASSERT (c_strncasecmp (\"paraLyzed\", \"paragraph\", 5) > 0);\n  ASSERT (c_strncasecmp (\"paraLyzed\", \"paragraph\", 4) == 0);\n\n  ASSERT (c_strncasecmp (\"para\", \"paragraph\", 10) < 0);\n  ASSERT (c_strncasecmp (\"para\", \"paragraph\", 9) < 0);\n  ASSERT (c_strncasecmp (\"para\", \"paragraph\", 5) < 0);\n  ASSERT (c_strncasecmp (\"para\", \"paragraph\", 4) == 0);\n  ASSERT (c_strncasecmp (\"paragraph\", \"para\", 10) > 0);\n  ASSERT (c_strncasecmp (\"paragraph\", \"para\", 9) > 0);\n  ASSERT (c_strncasecmp (\"paragraph\", \"para\", 5) > 0);\n  ASSERT (c_strncasecmp (\"paragraph\", \"para\", 4) == 0);\n\n  /* The following tests shows how c_strncasecmp() is different from\n     strncasecmp().  */\n\n  ASSERT (c_strncasecmp (\"\\311mily\", \"\\351mile\", 4) < 0);\n  ASSERT (c_strncasecmp (\"\\351mile\", \"\\311mily\", 4) > 0);\n\n  /* The following tests shows how c_strncasecmp() is different from\n     mbsncasecmp().  */\n\n  ASSERT (c_strncasecmp (\"\\303\\266zg\\303\\274r\", \"\\303\\226ZG\\303\\234R\", 99) > 0); /* \u00c3\u00b6zg\u00c3\u00bcr */\n  ASSERT (c_strncasecmp (\"\\303\\226ZG\\303\\234R\", \"\\303\\266zg\\303\\274r\", 99) < 0); /* \u00c3\u00b6zg\u00c3\u00bcr */\n\n  /* This test shows how strings of different size cannot compare equal.  */\n  ASSERT (c_strncasecmp (\"turkish\", \"TURK\\304\\260SH\", 7) < 0);\n  ASSERT (c_strncasecmp (\"TURK\\304\\260SH\", \"turkish\", 7) > 0);\n\n  return 0;\n}",
      "lines": 52,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-c-strstr.c": {
    "main": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        126,
        1
      ],
      "content": "int\nmain ()\n{\n  {\n    const char input[] = \"foo\";\n    const char *result = c_strstr (input, \"\");\n    ASSERT (result == input);\n  }\n\n  {\n    const char input[] = \"foo\";\n    const char *result = c_strstr (input, \"o\");\n    ASSERT (result == input + 1);\n  }\n\n  {\n    const char input[] = \"ABC ABCDAB ABCDABCDABDE\";\n    const char *result = c_strstr (input, \"ABCDABD\");\n    ASSERT (result == input + 15);\n  }\n\n  {\n    const char input[] = \"ABC ABCDAB ABCDABCDABDE\";\n    const char *result = c_strstr (input, \"ABCDABE\");\n    ASSERT (result == NULL);\n  }\n\n  /* Check that a very long haystack is handled quickly if the needle is\n     short and occurs near the beginning.  */\n  {\n    size_t repeat = 10000;\n    size_t m = 1000000;\n    const char *needle =\n      \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n      \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\";\n    char *haystack = (char *) malloc (m + 1);\n    if (haystack != NULL)\n      {\n        memset (haystack, 'A', m);\n        haystack[0] = 'B';\n        haystack[m] = '\\0';\n\n        for (; repeat > 0; repeat--)\n          {\n            ASSERT (c_strstr (haystack, needle) == haystack + 1);\n          }\n\n        free (haystack);\n      }\n  }\n\n  /* Check that a very long needle is discarded quickly if the haystack is\n     short.  */\n  {\n    size_t repeat = 10000;\n    size_t m = 1000000;\n    const char *haystack =\n      \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n      \"ABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABAB\";\n    char *needle = (char *) malloc (m + 1);\n    if (needle != NULL)\n      {\n        memset (needle, 'A', m);\n        needle[m] = '\\0';\n\n        for (; repeat > 0; repeat--)\n          {\n            ASSERT (c_strstr (haystack, needle) == NULL);\n          }\n\n        free (needle);\n      }\n  }\n\n  /* Check that the asymptotic worst-case complexity is not quadratic.  */\n  {\n    size_t m = 1000000;\n    char *haystack = (char *) malloc (2 * m + 2);\n    char *needle = (char *) malloc (m + 2);\n    if (haystack != NULL && needle != NULL)\n      {\n        const char *result;\n\n        memset (haystack, 'A', 2 * m);\n        haystack[2 * m] = 'B';\n        haystack[2 * m + 1] = '\\0';\n\n        memset (needle, 'A', m);\n        needle[m] = 'B';\n        needle[m + 1] = '\\0';\n\n        result = c_strstr (haystack, needle);\n        ASSERT (result == haystack + m);\n      }\n    free (needle);\n    free (haystack);\n  }\n\n  return 0;\n}",
      "lines": 100,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-canonicalize.c": {
    "null_ptr": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "static void *\nnull_ptr (void)\n{\n  return NULL;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nnull_ptr (void)",
        "*"
      ]
    },
    "main": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        358,
        1
      ],
      "content": "int\nmain (void)\n{\n  /* Setup some hierarchy to be used by this test.  Start by removing\n     any leftovers from a previous partial run.  */\n  {\n    int fd;\n    ignore_value (system (\"rm -rf \" BASE \" ise\"));\n    ASSERT (mkdir (BASE, 0700) == 0);\n    fd = creat (BASE \"/tra\", 0600);\n    ASSERT (0 <= fd);\n    ASSERT (close (fd) == 0);\n  }\n\n  /* Check for ., .., intermediate // handling, and for error cases.  */\n  {\n    char *result1 = canonicalize_file_name (BASE \"//./..//\" BASE \"/tra\");\n    char *result2 = canonicalize_filename_mode (BASE \"//./..//\" BASE \"/tra\",\n                                                CAN_EXISTING);\n    ASSERT (result1 != NULL);\n    ASSERT (result2 != NULL);\n    ASSERT (strcmp (result1, result2) == 0);\n    ASSERT (strstr (result1, \"/\" BASE \"/tra\")\n            == result1 + strlen (result1) - strlen (\"/\" BASE \"/tra\"));\n    free (result1);\n    free (result2);\n    errno = 0;\n    result1 = canonicalize_file_name (\"\");\n    ASSERT (result1 == NULL);\n    ASSERT (errno == ENOENT);\n    errno = 0;\n    result2 = canonicalize_filename_mode (\"\", CAN_EXISTING);\n    ASSERT (result2 == NULL);\n    ASSERT (errno == ENOENT);\n    errno = 0;\n    result1 = canonicalize_file_name (null_ptr ());\n    ASSERT (result1 == NULL);\n    ASSERT (errno == EINVAL);\n    errno = 0;\n    result2 = canonicalize_filename_mode (NULL, CAN_EXISTING);\n    ASSERT (result2 == NULL);\n    ASSERT (errno == EINVAL);\n    result2 = canonicalize_filename_mode (\".\", CAN_MISSING | CAN_ALL_BUT_LAST);\n    ASSERT (result2 == NULL);\n    ASSERT (errno == EINVAL);\n  }\n\n  /* Check that a non-directory with trailing slash yields NULL.  */\n  {\n    char *result1;\n    char *result2;\n    errno = 0;\n    result1 = canonicalize_file_name (BASE \"/tra/\");\n    ASSERT (result1 == NULL);\n    ASSERT (errno == ENOTDIR);\n    errno = 0;\n    result2 = canonicalize_filename_mode (BASE \"/tra/\", CAN_EXISTING);\n    ASSERT (result2 == NULL);\n    ASSERT (errno == ENOTDIR);\n  }\n\n  /* Check that a missing directory yields NULL.  */\n  {\n    char *result1;\n    char *result2;\n    errno = 0;\n    result1 = canonicalize_file_name (BASE \"/zzz/..\");\n    ASSERT (result1 == NULL);\n    ASSERT (errno == ENOENT);\n    errno = 0;\n    result2 = canonicalize_filename_mode (BASE \"/zzz/..\", CAN_EXISTING);\n    ASSERT (result2 == NULL);\n    ASSERT (errno == ENOENT);\n  }\n\n  /* From here on out, tests involve symlinks.  */\n  if (symlink (BASE \"/ket\", \"ise\") != 0)\n    {\n      ASSERT (remove (BASE \"/tra\") == 0);\n      ASSERT (rmdir (BASE) == 0);\n      fputs (\"skipping test: symlinks not supported on this file system\\n\",\n             stderr);\n      return 77;\n    }\n  ASSERT (symlink (\"bef\", BASE \"/plo\") == 0);\n  ASSERT (symlink (\"tra\", BASE \"/huk\") == 0);\n  ASSERT (symlink (\"lum\", BASE \"/bef\") == 0);\n  ASSERT (symlink (\"wum\", BASE \"/ouk\") == 0);\n  ASSERT (symlink (\"../ise\", BASE \"/ket\") == 0);\n  ASSERT (mkdir (BASE \"/lum\", 0700) == 0);\n  ASSERT (symlink (\"s\", BASE \"/p\") == 0);\n  ASSERT (symlink (\"d\", BASE \"/s\") == 0);\n  ASSERT (mkdir (BASE \"/d\", 0700) == 0);\n  ASSERT (close (creat (BASE \"/d/2\", 0600)) == 0);\n  ASSERT (symlink (\"../s/2\", BASE \"/d/1\") == 0);\n  ASSERT (symlink (\"//.//../..\", BASE \"/droot\") == 0);\n\n  /* Check that symbolic links are not resolved, with CAN_NOLINKS.  */\n  {\n    char *result1 = canonicalize_filename_mode (BASE \"/huk\", CAN_NOLINKS);\n    ASSERT (result1 != NULL);\n    ASSERT (strcmp (result1 + strlen (result1) - strlen (\"/\" BASE \"/huk\"),\n                    \"/\" BASE \"/huk\") == 0);\n    free (result1);\n  }\n\n  /* Check that the symbolic link to a file can be resolved.  */\n  {\n    char *result1 = canonicalize_file_name (BASE \"/huk\");\n    char *result2 = canonicalize_file_name (BASE \"/tra\");\n    char *result3 = canonicalize_filename_mode (BASE \"/huk\", CAN_EXISTING);\n    ASSERT (result1 != NULL);\n    ASSERT (result2 != NULL);\n    ASSERT (result3 != NULL);\n    ASSERT (strcmp (result1, result2) == 0);\n    ASSERT (strcmp (result2, result3) == 0);\n    ASSERT (strcmp (result1 + strlen (result1) - strlen (\"/\" BASE \"/tra\"),\n                    \"/\" BASE \"/tra\") == 0);\n    free (result1);\n    free (result2);\n    free (result3);\n  }\n\n  /* Check that the symbolic link to a directory can be resolved.  */\n  {\n    char *result1 = canonicalize_file_name (BASE \"/plo\");\n    char *result2 = canonicalize_file_name (BASE \"/bef\");\n    char *result3 = canonicalize_file_name (BASE \"/lum\");\n    char *result4 = canonicalize_filename_mode (BASE \"/plo\", CAN_EXISTING);\n    ASSERT (result1 != NULL);\n    ASSERT (result2 != NULL);\n    ASSERT (result3 != NULL);\n    ASSERT (result4 != NULL);\n    ASSERT (strcmp (result1, result2) == 0);\n    ASSERT (strcmp (result2, result3) == 0);\n    ASSERT (strcmp (result3, result4) == 0);\n    ASSERT (strcmp (result1 + strlen (result1) - strlen (\"/\" BASE \"/lum\"),\n                    \"/\" BASE \"/lum\") == 0);\n    free (result1);\n    free (result2);\n    free (result3);\n    free (result4);\n  }\n\n  /* Check that a symbolic link to a nonexistent file yields NULL.  */\n  {\n    char *result1;\n    char *result2;\n    errno = 0;\n    result1 = canonicalize_file_name (BASE \"/ouk\");\n    ASSERT (result1 == NULL);\n    ASSERT (errno == ENOENT);\n    errno = 0;\n    result2 = canonicalize_filename_mode (BASE \"/ouk\", CAN_EXISTING);\n    ASSERT (result2 == NULL);\n    ASSERT (errno == ENOENT);\n  }\n\n  /* Check that a non-directory symlink with trailing slash yields NULL.  */\n  {\n    char *result1;\n    char *result2;\n    errno = 0;\n    result1 = canonicalize_file_name (BASE \"/huk/\");\n    ASSERT (result1 == NULL);\n    ASSERT (errno == ENOTDIR);\n    errno = 0;\n    result2 = canonicalize_filename_mode (BASE \"/huk/\", CAN_EXISTING);\n    ASSERT (result2 == NULL);\n    ASSERT (errno == ENOTDIR);\n  }\n\n  /* Check that a missing directory via symlink yields NULL.  */\n  {\n    char *result1;\n    char *result2;\n    errno = 0;\n    result1 = canonicalize_file_name (BASE \"/ouk/..\");\n    ASSERT (result1 == NULL);\n    ASSERT (errno == ENOENT);\n    errno = 0;\n    result2 = canonicalize_filename_mode (BASE \"/ouk/..\", CAN_EXISTING);\n    ASSERT (result2 == NULL);\n    ASSERT (errno == ENOENT);\n  }\n\n  /* Check that a loop of symbolic links is detected.  */\n  {\n    char *result1;\n    char *result2;\n    errno = 0;\n    result1 = canonicalize_file_name (\"ise\");\n    ASSERT (result1 == NULL);\n    ASSERT (errno == ELOOP);\n    errno = 0;\n    result2 = canonicalize_filename_mode (\"ise\", CAN_EXISTING);\n    ASSERT (result2 == NULL);\n    ASSERT (errno == ELOOP);\n  }\n\n  /* Check that alternate modes can resolve missing basenames.  */\n  {\n    char *result1 = canonicalize_filename_mode (BASE \"/zzz\", CAN_ALL_BUT_LAST);\n    char *result2 = canonicalize_filename_mode (BASE \"/zzz\", CAN_MISSING);\n    char *result3 = canonicalize_filename_mode (BASE \"/zzz/\", CAN_ALL_BUT_LAST);\n    char *result4 = canonicalize_filename_mode (BASE \"/zzz/\", CAN_MISSING);\n    ASSERT (result1 != NULL);\n    ASSERT (result2 != NULL);\n    ASSERT (result3 != NULL);\n    ASSERT (result4 != NULL);\n    ASSERT (strcmp (result1, result2) == 0);\n    ASSERT (strcmp (result2, result3) == 0);\n    ASSERT (strcmp (result3, result4) == 0);\n    ASSERT (strcmp (result1 + strlen (result1) - strlen (\"/\" BASE \"/zzz\"),\n                    \"/\" BASE \"/zzz\") == 0);\n    free (result1);\n    free (result2);\n    free (result3);\n    free (result4);\n  }\n\n  /* Check that alternate modes can resolve broken symlink basenames.  */\n  {\n    char *result1 = canonicalize_filename_mode (BASE \"/ouk\", CAN_ALL_BUT_LAST);\n    char *result2 = canonicalize_filename_mode (BASE \"/ouk\", CAN_MISSING);\n    char *result3 = canonicalize_filename_mode (BASE \"/ouk/\", CAN_ALL_BUT_LAST);\n    char *result4 = canonicalize_filename_mode (BASE \"/ouk/\", CAN_MISSING);\n    ASSERT (result1 != NULL);\n    ASSERT (result2 != NULL);\n    ASSERT (result3 != NULL);\n    ASSERT (result4 != NULL);\n    ASSERT (strcmp (result1, result2) == 0);\n    ASSERT (strcmp (result2, result3) == 0);\n    ASSERT (strcmp (result3, result4) == 0);\n    ASSERT (strcmp (result1 + strlen (result1) - strlen (\"/\" BASE \"/wum\"),\n                    \"/\" BASE \"/wum\") == 0);\n    free (result1);\n    free (result2);\n    free (result3);\n    free (result4);\n  }\n\n  /* Check that alternate modes can handle missing dirnames.  */\n  {\n    char *result1 = canonicalize_filename_mode (\"t-can.zzz/zzz\", CAN_ALL_BUT_LAST);\n    char *result2 = canonicalize_filename_mode (\"t-can.zzz/zzz\", CAN_MISSING);\n    ASSERT (result1 == NULL);\n    ASSERT (result2 != NULL);\n    ASSERT (strcmp (result2 + strlen (result2) - 14, \"/t-can.zzz/zzz\") == 0);\n    free (result2);\n  }\n\n  /* Ensure that the following is resolved properly.\n     Before 2007-09-27, it would mistakenly report a loop.  */\n  {\n    char *result1 = canonicalize_filename_mode (BASE, CAN_EXISTING);\n    char *result2 = canonicalize_filename_mode (BASE \"/p/1\", CAN_EXISTING);\n    ASSERT (result1 != NULL);\n    ASSERT (result2 != NULL);\n    ASSERT (strcmp (result2 + strlen (result1), \"/d/2\") == 0);\n    free (result1);\n    free (result2);\n  }\n\n  /* Check that leading // is honored correctly.  */\n  {\n    struct stat st1;\n    struct stat st2;\n    char *result1 = canonicalize_file_name (\"//.\");\n    char *result2 = canonicalize_filename_mode (\"//.\", CAN_EXISTING);\n    char *result3 = canonicalize_file_name (BASE \"/droot\");\n    char *result4 = canonicalize_filename_mode (BASE \"/droot\", CAN_EXISTING);\n    ASSERT (result1);\n    ASSERT (result2);\n    ASSERT (result3);\n    ASSERT (result4);\n    ASSERT (stat (\"/\", &st1) == 0);\n    ASSERT (stat (\"//\", &st2) == 0);\n    if (SAME_INODE (st1, st2))\n      {\n        ASSERT (strcmp (result1, \"/\") == 0);\n        ASSERT (strcmp (result2, \"/\") == 0);\n        ASSERT (strcmp (result3, \"/\") == 0);\n        ASSERT (strcmp (result4, \"/\") == 0);\n      }\n    else\n      {\n        ASSERT (strcmp (result1, \"//\") == 0);\n        ASSERT (strcmp (result2, \"//\") == 0);\n        ASSERT (strcmp (result3, \"//\") == 0);\n        ASSERT (strcmp (result4, \"//\") == 0);\n      }\n    free (result1);\n    free (result2);\n    free (result3);\n    free (result4);\n  }\n\n  /* Cleanup.  */\n  ASSERT (remove (BASE \"/droot\") == 0);\n  ASSERT (remove (BASE \"/d/1\") == 0);\n  ASSERT (remove (BASE \"/d/2\") == 0);\n  ASSERT (remove (BASE \"/d\") == 0);\n  ASSERT (remove (BASE \"/s\") == 0);\n  ASSERT (remove (BASE \"/p\") == 0);\n  ASSERT (remove (BASE \"/plo\") == 0);\n  ASSERT (remove (BASE \"/huk\") == 0);\n  ASSERT (remove (BASE \"/bef\") == 0);\n  ASSERT (remove (BASE \"/ouk\") == 0);\n  ASSERT (remove (BASE \"/ket\") == 0);\n  ASSERT (remove (BASE \"/lum\") == 0);\n  ASSERT (remove (BASE \"/tra\") == 0);\n  ASSERT (remove (BASE) == 0);\n  ASSERT (remove (\"ise\") == 0);\n\n  return 0;\n}",
      "lines": 317,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-chdir.c": {
    "main": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        32,
        1
      ],
      "content": "int\nmain (void)\n{\n  ASSERT (chdir (\"/\") == 0);\n\n  return 0;\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-cloexec.c": {
    "is_inheritable": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "static int\nis_inheritable (int fd)\n{\n#if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n  /* On native Windows, the initial state of unassigned standard file\n     descriptors is that they are open but point to an\n     INVALID_HANDLE_VALUE, and there is no fcntl.  */\n  HANDLE h = (HANDLE) _get_osfhandle (fd);\n  DWORD flags;\n  if (h == INVALID_HANDLE_VALUE || GetHandleInformation (h, &flags) == 0)\n    return 0;\n  return (flags & HANDLE_FLAG_INHERIT) != 0;\n#else\n# ifndef F_GETFD\n#  error Please port fcntl to your platform\n# endif\n  int i = fcntl (fd, F_GETFD);\n  return 0 <= i && (i & FD_CLOEXEC) == 0;\n#endif\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "zero": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        61,
        36
      ],
      "content": "static int zero (void) { return 0; }",
      "lines": 1,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "is_mode": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "static int\nis_mode (int fd, int mode)\n{\n  int value = setmode (fd, O_BINARY);\n  setmode (fd, value);\n  return mode == value;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        143,
        1
      ],
      "content": "int\nmain (void)\n{\n  const char *file = \"test-cloexec.tmp\";\n  int fd = creat (file, 0600);\n  int fd2;\n  int bad_fd = getdtablesize ();\n\n  /* Assume std descriptors were provided by invoker.  */\n  ASSERT (STDERR_FILENO < fd);\n  ASSERT (is_inheritable (fd));\n\n  /* Normal use of set_cloexec_flag.  */\n  ASSERT (set_cloexec_flag (fd, true) == 0);\n#if !((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__)\n  ASSERT (!is_inheritable (fd));\n#endif\n  ASSERT (set_cloexec_flag (fd, false) == 0);\n  ASSERT (is_inheritable (fd));\n\n  /* Normal use of dup_cloexec.  */\n  fd2 = dup_cloexec (fd);\n  ASSERT (fd < fd2);\n  ASSERT (!is_inheritable (fd2));\n  ASSERT (close (fd) == 0);\n  ASSERT (dup_cloexec (fd2) == fd);\n  ASSERT (!is_inheritable (fd));\n  ASSERT (close (fd2) == 0);\n\n  /* On systems that distinguish between text and binary mode,\n     dup_cloexec reuses the mode of the source.  */\n  setmode (fd, O_BINARY);\n  ASSERT (is_mode (fd, O_BINARY));\n  fd2 = dup_cloexec (fd);\n  ASSERT (fd < fd2);\n  ASSERT (is_mode (fd2, O_BINARY));\n  ASSERT (close (fd2) == 0);\n  setmode (fd, O_TEXT);\n  ASSERT (is_mode (fd, O_TEXT));\n  fd2 = dup_cloexec (fd);\n  ASSERT (fd < fd2);\n  ASSERT (is_mode (fd2, O_TEXT));\n  ASSERT (close (fd2) == 0);\n\n  /* Test error handling.  */\n  errno = 0;\n  ASSERT (set_cloexec_flag (-1, false) == -1);\n  ASSERT (errno == EBADF);\n  errno = 0;\n  ASSERT (set_cloexec_flag (bad_fd, false) == -1);\n  ASSERT (errno == EBADF);\n  errno = 0;\n  ASSERT (set_cloexec_flag (fd2, false) == -1);\n  ASSERT (errno == EBADF);\n  errno = 0;\n  ASSERT (dup_cloexec (-1) == -1);\n  ASSERT (errno == EBADF);\n  errno = 0;\n  ASSERT (dup_cloexec (bad_fd) == -1);\n  ASSERT (errno == EBADF);\n  errno = 0;\n  ASSERT (dup_cloexec (fd2) == -1);\n  ASSERT (errno == EBADF);\n\n  /* Clean up.  */\n  ASSERT (close (fd) == 0);\n  ASSERT (unlink (file) == 0);\n\n  return 0;\n}",
      "lines": 70,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-close.c": {
    "main": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "int\nmain (void)\n{\n  /* Test behaviour for invalid file descriptors.  */\n  {\n    errno = 0;\n    ASSERT (close (-1) == -1);\n    ASSERT (errno == EBADF);\n  }\n  {\n    close (99);\n    errno = 0;\n    ASSERT (close (99) == -1);\n    ASSERT (errno == EBADF);\n  }\n\n  return 0;\n}",
      "lines": 18,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-closein.c": {
    "main": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  char buf[7];\n  atexit (close_stdin);\n  program_name = argv[0];\n\n  /* close_stdin currently relies on ftell, but mingw ftell is\n     unreliable on text mode input.  */\n  SET_BINARY (0);\n\n  if (argc > 2)\n    close (0);\n\n  if (argc > 1)\n    ignore_value (fread (buf, 1, 6, stdin));\n  return 0;\n}",
      "lines": 18,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-connect.c": {
    "main": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "int\nmain (void)\n{\n  (void) gl_sockets_startup (SOCKETS_1_1);\n\n  /* Test behaviour for invalid file descriptors.  */\n  {\n    struct sockaddr_in addr;\n\n    addr.sin_family = AF_INET;\n    inet_pton (AF_INET, \"127.0.0.1\", &addr.sin_addr);\n    addr.sin_port = htons (80);\n    {\n      errno = 0;\n      ASSERT (connect (-1, (const struct sockaddr *) &addr, sizeof (addr))\n              == -1);\n      ASSERT (errno == EBADF);\n    }\n    {\n      close (99);\n      errno = 0;\n      ASSERT (connect (99, (const struct sockaddr *) &addr, sizeof (addr))\n              == -1);\n      ASSERT (errno == EBADF);\n    }\n  }\n\n  return 0;\n}",
      "lines": 29,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-ctype.c": {
    "main": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        26,
        1
      ],
      "content": "int\nmain (void)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-dirent-safer.c": {
    "main": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        95,
        1
      ],
      "content": "int\nmain (void)\n{\n  int i;\n  DIR *dp;\n  /* The dirent-safer module works without the use of fdopendir (which\n     would also pull in fchdir and openat); but if those modules were\n     also used, we ensure that they are safe.  In particular, the\n     gnulib version of fdopendir is unable to guarantee that\n     dirfd(fdopendir(fd))==fd, but we can at least guarantee that if\n     they are not equal, the fd returned by dirfd is safe.  */\n#if HAVE_FDOPENDIR || GNULIB_TEST_FDOPENDIR\n  int dfd;\n#endif\n\n  /* We close fd 2 later, so save it in fd 10.  */\n  if (dup2 (STDERR_FILENO, BACKUP_STDERR_FILENO) != BACKUP_STDERR_FILENO\n      || (myerr = fdopen (BACKUP_STDERR_FILENO, \"w\")) == NULL)\n    return 2;\n\n#if HAVE_FDOPENDIR || GNULIB_TEST_FDOPENDIR\n  dfd = open (\".\", O_RDONLY);\n  ASSERT (STDERR_FILENO < dfd);\n#endif\n\n  /* Four iterations, with progressively more standard descriptors\n     closed.  */\n  for (i = -1; i <= STDERR_FILENO; i++)\n    {\n      if (0 <= i)\n        ASSERT (close (i) == 0);\n      dp = opendir (\".\");\n      ASSERT (dp);\n      ASSERT (dirfd (dp) == -1 || STDERR_FILENO < dirfd (dp));\n      ASSERT (closedir (dp) == 0);\n\n#if HAVE_FDOPENDIR || GNULIB_TEST_FDOPENDIR\n      {\n        int fd = dup_safer (dfd);\n        ASSERT (STDERR_FILENO < fd);\n        dp = fdopendir (fd);\n        ASSERT (dp);\n        ASSERT (dirfd (dp) == -1 || STDERR_FILENO < dirfd (dp));\n        ASSERT (closedir (dp) == 0);\n        errno = 0;\n        ASSERT (close (fd) == -1);\n        ASSERT (errno == EBADF);\n      }\n#endif\n    }\n\n#if HAVE_FDOPENDIR || GNULIB_TEST_FDOPENDIR\n  ASSERT (close (dfd) == 0);\n#endif\n\n  return 0;\n}",
      "lines": 57,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-dirent.c": {
    "main": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        31,
        1
      ],
      "content": "int\nmain (void)\n{\n  return d.d_name[0] + i;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-dirname.c": {
    "main": {
      "start_point": [
        130,
        0
      ],
      "end_point": [
        192,
        1
      ],
      "content": "int\nmain (void)\n{\n  struct test *t;\n  bool ok = true;\n\n  for (t = tests; t->name; t++)\n    {\n      char *dir = dir_name (t->name);\n      int dirlen = dir_len (t->name);\n      char *last = last_component (t->name);\n      char *base = base_name (t->name);\n      int baselen = base_len (base);\n      char *stripped = strdup (t->name);\n      bool modified = strip_trailing_slashes (stripped);\n      bool absolute = IS_ABSOLUTE_FILE_NAME (t->name);\n      if (! (strcmp (dir, t->dir) == 0\n             && (dirlen == strlen (dir)\n                 || (dirlen + 1 == strlen (dir) && dir[dirlen] == '.'))))\n        {\n          ok = false;\n          printf (\"dir_name '%s': got '%s' len %d,\"\n                  \" expected '%s' len %lu\\n\",\n                  t->name, dir, dirlen,\n                  t->dir, (unsigned long) strlen (t->dir));\n        }\n      if (strcmp (last, t->last))\n        {\n          ok = false;\n          printf (\"last_component '%s': got '%s', expected '%s'\\n\",\n                  t->name, last, t->last);\n        }\n      if (! (strcmp (base, t->base) == 0\n             && (baselen == strlen (base)\n                 || (baselen + 1 == strlen (base)\n                     && ISSLASH (base[baselen])))))\n        {\n          ok = false;\n          printf (\"base_name '%s': got '%s' len %d,\"\n                  \" expected '%s' len %lu\\n\",\n                  t->name, base, baselen,\n                  t->base, (unsigned long) strlen (t->base));\n        }\n      if (strcmp (stripped, t->stripped) || modified != t->modified)\n        {\n          ok = false;\n          printf (\"strip_trailing_slashes '%s': got %s %s, expected %s %s\\n\",\n                  t->name, stripped, modified ? \"changed\" : \"unchanged\",\n                  t->stripped, t->modified ? \"changed\" : \"unchanged\");\n        }\n      if (t->absolute != absolute)\n        {\n          ok = false;\n          printf (\"'%s': got %s, expected %s\\n\", t->name,\n                  absolute ? \"absolute\" : \"relative\",\n                  t->absolute ? \"absolute\" : \"relative\");\n        }\n      free (dir);\n      free (base);\n      free (stripped);\n    }\n  return ok ? 0 : 1;\n}",
      "lines": 63,
      "depth": 17,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-dup-safer.c": {
    "zero": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        41,
        36
      ],
      "content": "static int zero (void) { return 0; }",
      "lines": 1,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "is_open": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        69,
        1
      ],
      "content": "static bool\nis_open (int fd)\n{\n#if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n  /* On native Windows, the initial state of unassigned standard file\n     descriptors is that they are open but point to an\n     INVALID_HANDLE_VALUE, and there is no fcntl.  */\n  return (HANDLE) _get_osfhandle (fd) != INVALID_HANDLE_VALUE;\n#else\n# ifndef F_GETFL\n#  error Please port fcntl to your platform\n# endif\n  return 0 <= fcntl (fd, F_GETFL);\n#endif\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "is_inheritable": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        91,
        1
      ],
      "content": "static bool\nis_inheritable (int fd)\n{\n#if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n  /* On native Windows, the initial state of unassigned standard file\n     descriptors is that they are open but point to an\n     INVALID_HANDLE_VALUE, and there is no fcntl.  */\n  HANDLE h = (HANDLE) _get_osfhandle (fd);\n  DWORD flags;\n  if (h == INVALID_HANDLE_VALUE || GetHandleInformation (h, &flags) == 0)\n    return 0;\n  return (flags & HANDLE_FLAG_INHERIT) != 0;\n#else\n# ifndef F_GETFD\n#  error Please port fcntl to your platform\n# endif\n  int i = fcntl (fd, F_GETFD);\n  return 0 <= i && (i & FD_CLOEXEC) == 0;\n#endif\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "is_mode": {
      "start_point": [
        95,
        0
      ],
      "end_point": [
        101,
        1
      ],
      "content": "static bool\nis_mode (int fd, int mode)\n{\n  int value = setmode (fd, O_BINARY);\n  setmode (fd, value);\n  return mode == value;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "main": {
      "start_point": [
        105,
        0
      ],
      "end_point": [
        175,
        1
      ],
      "content": "int\nmain (void)\n{\n  int i;\n  int fd;\n  int bad_fd = getdtablesize ();\n\n  /* We close fd 2 later, so save it in fd 10.  */\n  if (dup2 (STDERR_FILENO, BACKUP_STDERR_FILENO) != BACKUP_STDERR_FILENO\n      || (myerr = fdopen (BACKUP_STDERR_FILENO, \"w\")) == NULL)\n    return 2;\n\n  /* Create file for later checks.  */\n  fd = creat (witness, 0600);\n  ASSERT (STDERR_FILENO < fd);\n\n  /* Four iterations, with progressively more standard descriptors\n     closed.  */\n  for (i = -1; i <= STDERR_FILENO; i++)\n    {\n      if (0 <= i)\n        ASSERT (close (i) == 0);\n\n      /* Detect errors.  */\n      errno = 0;\n      ASSERT (dup (-1) == -1);\n      ASSERT (errno == EBADF);\n      errno = 0;\n      ASSERT (dup (bad_fd) == -1);\n      ASSERT (errno == EBADF);\n      close (fd + 1);\n      errno = 0;\n      ASSERT (dup (fd + 1) == -1);\n      ASSERT (errno == EBADF);\n\n      /* Preserve text vs. binary.  */\n      setmode (fd, O_BINARY);\n      ASSERT (dup (fd) == fd + 1);\n      ASSERT (is_open (fd + 1));\n      ASSERT (is_inheritable (fd + 1));\n      ASSERT (is_mode (fd + 1, O_BINARY));\n\n      ASSERT (close (fd + 1) == 0);\n      setmode (fd, O_TEXT);\n      ASSERT (dup (fd) == fd + 1);\n      ASSERT (is_open (fd + 1));\n      ASSERT (is_inheritable (fd + 1));\n      ASSERT (is_mode (fd + 1, O_TEXT));\n\n      /* Create cloexec copy.  */\n      ASSERT (close (fd + 1) == 0);\n      ASSERT (fd_safer_flag (dup_cloexec (fd), O_CLOEXEC) == fd + 1);\n      ASSERT (set_cloexec_flag (fd + 1, true) == 0);\n      ASSERT (is_open (fd + 1));\n      ASSERT (!is_inheritable (fd + 1));\n      ASSERT (close (fd) == 0);\n\n      /* dup always creates inheritable copies.  Also, check that\n         earliest slot past std fds is used.  */\n      ASSERT (dup (fd + 1) == fd);\n      ASSERT (is_open (fd));\n      ASSERT (is_inheritable (fd));\n      ASSERT (close (fd + 1) == 0);\n    }\n\n  /* Cleanup.  */\n  ASSERT (close (fd) == 0);\n  ASSERT (unlink (witness) == 0);\n\n  return 0;\n}",
      "lines": 71,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-dup.c": {
    "main": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "int\nmain (void)\n{\n  /* Test behaviour for invalid file descriptors.  */\n  {\n    errno = 0;\n    ASSERT (dup (-1) == -1);\n    ASSERT (errno == EBADF);\n  }\n  {\n    close (99);\n    errno = 0;\n    ASSERT (dup (99) == -1);\n    ASSERT (errno == EBADF);\n  }\n\n  return 0;\n}",
      "lines": 18,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-dup2.c": {
    "is_open": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        63,
        1
      ],
      "content": "static int\nis_open (int fd)\n{\n#if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n  /* On native Windows, the initial state of unassigned standard file\n     descriptors is that they are open but point to an\n     INVALID_HANDLE_VALUE, and there is no fcntl.  */\n  return (HANDLE) _get_osfhandle (fd) != INVALID_HANDLE_VALUE;\n#else\n# ifndef F_GETFL\n#  error Please port fcntl to your platform\n# endif\n  return 0 <= fcntl (fd, F_GETFL);\n#endif\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "is_inheritable": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "static int\nis_inheritable (int fd)\n{\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n  /* On native Windows, the initial state of unassigned standard file\n     descriptors is that they are open but point to an\n     INVALID_HANDLE_VALUE, and there is no fcntl.  */\n  HANDLE h = (HANDLE) _get_osfhandle (fd);\n  DWORD flags;\n  if (h == INVALID_HANDLE_VALUE || GetHandleInformation (h, &flags) == 0)\n    return 0;\n  return (flags & HANDLE_FLAG_INHERIT) != 0;\n# else\n#  ifndef F_GETFD\n#   error Please port fcntl to your platform\n#  endif\n  int i = fcntl (fd, F_GETFD);\n  return 0 <= i && (i & FD_CLOEXEC) == 0;\n# endif\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "zero": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        91,
        36
      ],
      "content": "static int zero (void) { return 0; }",
      "lines": 1,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "is_mode": {
      "start_point": [
        96,
        0
      ],
      "end_point": [
        102,
        1
      ],
      "content": "static int\nis_mode (int fd, int mode)\n{\n  int value = setmode (fd, O_BINARY);\n  setmode (fd, value);\n  return mode == value;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        104,
        0
      ],
      "end_point": [
        217,
        1
      ],
      "content": "int\nmain (void)\n{\n  const char *file = \"test-dup2.tmp\";\n  char buffer[1];\n  int bad_fd = getdtablesize ();\n  int fd = open (file, O_CREAT | O_TRUNC | O_RDWR, 0600);\n\n  /* Assume std descriptors were provided by invoker.  */\n  ASSERT (STDERR_FILENO < fd);\n  ASSERT (is_open (fd));\n  /* Ignore any other fd's leaked into this process.  */\n  close (fd + 1);\n  close (fd + 2);\n  ASSERT (!is_open (fd + 1));\n  ASSERT (!is_open (fd + 2));\n\n  /* Assigning to self must be a no-op.  */\n  ASSERT (dup2 (fd, fd) == fd);\n  ASSERT (is_open (fd));\n\n  /* The source must be valid.  */\n  errno = 0;\n  ASSERT (dup2 (-1, fd) == -1);\n  ASSERT (errno == EBADF);\n  close (99);\n  errno = 0;\n  ASSERT (dup2 (99, fd) == -1);\n  ASSERT (errno == EBADF);\n  errno = 0;\n  ASSERT (dup2 (AT_FDCWD, fd) == -1);\n  ASSERT (errno == EBADF);\n  ASSERT (is_open (fd));\n\n  /* If the source is not open, then the destination is unaffected.  */\n  errno = 0;\n  ASSERT (dup2 (fd + 1, fd + 1) == -1);\n  ASSERT (errno == EBADF);\n  ASSERT (!is_open (fd + 1));\n  errno = 0;\n  ASSERT (dup2 (fd + 1, fd) == -1);\n  ASSERT (errno == EBADF);\n  ASSERT (is_open (fd));\n\n  /* The destination must be valid.  */\n  errno = 0;\n  ASSERT (dup2 (fd, -2) == -1);\n  ASSERT (errno == EBADF);\n  if (bad_fd > 256)\n    {\n      ASSERT (dup2 (fd, 255) == 255);\n      ASSERT (dup2 (fd, 256) == 256);\n      ASSERT (close (255) == 0);\n      ASSERT (close (256) == 0);\n    }\n  ASSERT (dup2 (fd, bad_fd - 1) == bad_fd - 1);\n  ASSERT (close (bad_fd - 1) == 0);\n  errno = 0;\n  ASSERT (dup2 (fd, bad_fd) == -1);\n  ASSERT (errno == EBADF);\n\n  /* Using dup2 can skip fds.  */\n  ASSERT (dup2 (fd, fd + 2) == fd + 2);\n  ASSERT (is_open (fd));\n  ASSERT (!is_open (fd + 1));\n  ASSERT (is_open (fd + 2));\n\n  /* Verify that dup2 closes the previous occupant of a fd.  */\n  ASSERT (open (\"/dev/null\", O_WRONLY, 0600) == fd + 1);\n  ASSERT (dup2 (fd + 1, fd) == fd);\n  ASSERT (close (fd + 1) == 0);\n  ASSERT (write (fd, \"1\", 1) == 1);\n  ASSERT (dup2 (fd + 2, fd) == fd);\n  ASSERT (lseek (fd, 0, SEEK_END) == 0);\n  ASSERT (write (fd + 2, \"2\", 1) == 1);\n  ASSERT (lseek (fd, 0, SEEK_SET) == 0);\n  ASSERT (read (fd, buffer, 1) == 1);\n  ASSERT (*buffer == '2');\n\n#if GNULIB_TEST_CLOEXEC\n  /* Any new fd created by dup2 must not be cloexec.  */\n  ASSERT (close (fd + 2) == 0);\n  ASSERT (dup_cloexec (fd) == fd + 1);\n  ASSERT (!is_inheritable (fd + 1));\n  ASSERT (dup2 (fd + 1, fd + 1) == fd + 1);\n  ASSERT (!is_inheritable (fd + 1));\n  ASSERT (dup2 (fd + 1, fd + 2) == fd + 2);\n  ASSERT (!is_inheritable (fd + 1));\n  ASSERT (is_inheritable (fd + 2));\n  errno = 0;\n  ASSERT (dup2 (fd + 1, -1) == -1);\n  ASSERT (errno == EBADF);\n  ASSERT (!is_inheritable (fd + 1));\n#endif\n\n  /* On systems that distinguish between text and binary mode, dup2\n     reuses the mode of the source.  */\n  setmode (fd, O_BINARY);\n  ASSERT (is_mode (fd, O_BINARY));\n  ASSERT (dup2 (fd, fd + 1) == fd + 1);\n  ASSERT (is_mode (fd + 1, O_BINARY));\n  setmode (fd, O_TEXT);\n  ASSERT (is_mode (fd, O_TEXT));\n  ASSERT (dup2 (fd, fd + 1) == fd + 1);\n  ASSERT (is_mode (fd + 1, O_TEXT));\n\n  /* Clean up.  */\n  ASSERT (close (fd + 2) == 0);\n  ASSERT (close (fd + 1) == 0);\n  ASSERT (close (fd) == 0);\n  ASSERT (unlink (file) == 0);\n\n  return 0;\n}",
      "lines": 114,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-environ.c": {
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "int\nmain ()\n{\n  /* The environment variables that are set even in the weirdest situations\n     are HOME and PATH.\n     POSIX says that HOME is initialized by the system, and that PATH may be\n     unset.  But in practice it's more frequent to see HOME unset and PATH\n     set.  So we test the presence of PATH.  */\n  char **remaining_variables = environ;\n  char *string;\n\n  for (; (string = *remaining_variables) != NULL; remaining_variables++)\n    {\n      if (strncmp (string, \"PATH=\", 5) == 0)\n        /* Found the PATH environment variable.  */\n        return 0;\n    }\n  /* Failed to find the PATH environment variable.  */\n  return 1;\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-errno.c": {
    "main": {
      "start_point": [
        107,
        0
      ],
      "end_point": [
        118,
        1
      ],
      "content": "int\nmain ()\n{\n  /* Verify that errno can be assigned.  */\n  errno = EOVERFLOW;\n\n  /* snprintf() callers want to distinguish EINVAL and EOVERFLOW.  */\n  if (errno == EINVAL)\n    return 1;\n\n  return 0;\n}",
      "lines": 12,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-faccessat.c": {
    "main": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "int\nmain (void)\n{\n  /* Test behaviour for invalid file descriptors.  */\n  {\n    errno = 0;\n    ASSERT (faccessat (-1, \"foo\", F_OK, 0) == -1);\n    ASSERT (errno == EBADF);\n  }\n  {\n    close (99);\n    errno = 0;\n    ASSERT (faccessat (99, \"foo\", F_OK, 0) == -1);\n    ASSERT (errno == EBADF);\n  }\n\n  return 0;\n}",
      "lines": 18,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-fchdir.c": {
    "main": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        109,
        1
      ],
      "content": "int\nmain (void)\n{\n  char *cwd;\n  int fd;\n  int i;\n\n  cwd = getcwd (NULL, 0);\n  ASSERT (cwd);\n\n  fd = open (\".\", O_RDONLY);\n  ASSERT (0 <= fd);\n\n  /* Test behaviour for invalid file descriptors.  */\n  {\n    errno = 0;\n    ASSERT (fchdir (-1) == -1);\n    ASSERT (errno == EBADF);\n  }\n  {\n    close (99);\n    errno = 0;\n    ASSERT (fchdir (99) == -1);\n    ASSERT (errno == EBADF);\n  }\n\n  /* Check for other failure cases.  */\n  {\n    int bad_fd = open (\"/dev/null\", O_RDONLY);\n    ASSERT (0 <= bad_fd);\n    errno = 0;\n    ASSERT (fchdir (bad_fd) == -1);\n    ASSERT (errno == ENOTDIR);\n    ASSERT (close (bad_fd) == 0);\n  }\n\n  /* Repeat test twice, once in '.' and once in '..'.  */\n  for (i = 0; i < 2; i++)\n    {\n      ASSERT (chdir (&\"..\"[1 - i]) == 0);\n      ASSERT (fchdir (fd) == 0);\n      {\n        size_t len = strlen (cwd) + 1;\n        char *new_dir = malloc (len);\n        ASSERT (new_dir);\n        ASSERT (getcwd (new_dir, len) == new_dir);\n        ASSERT (strcmp (cwd, new_dir) == 0);\n        free (new_dir);\n      }\n\n      /* For second iteration, use a cloned fd, to ensure that dup\n         remembers whether an fd was associated with a directory.  */\n      if (!i)\n        {\n          int new_fd = dup (fd);\n          ASSERT (0 <= new_fd);\n          ASSERT (close (fd) == 0);\n          ASSERT (dup2 (new_fd, fd) == fd);\n          ASSERT (close (new_fd) == 0);\n          ASSERT (dup_cloexec (fd) == new_fd);\n          ASSERT (dup2 (new_fd, fd) == fd);\n          ASSERT (close (new_fd) == 0);\n          ASSERT (fcntl (fd, F_DUPFD_CLOEXEC, new_fd) == new_fd);\n          ASSERT (close (fd) == 0);\n          ASSERT (fcntl (new_fd, F_DUPFD, fd) == fd);\n          ASSERT (close (new_fd) == 0);\n#if GNULIB_TEST_DUP3\n          ASSERT (dup3 (fd, new_fd, 0) == new_fd);\n          ASSERT (dup3 (new_fd, fd, 0) == fd);\n          ASSERT (close (new_fd) == 0);\n#endif\n        }\n    }\n\n  free (cwd);\n  return 0;\n}",
      "lines": 77,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-fcntl-h.c": {
    "main": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        129,
        1
      ],
      "content": "int\nmain (void)\n{\n  /* Ensure no overlap in SEEK_*. */\n  switch (0)\n    {\n    case SEEK_CUR:\n    case SEEK_END:\n    case SEEK_SET:\n      ;\n    }\n\n  /* Ensure no dangerous overlap in non-zero gnulib-defined replacements.  */\n  switch (O_RDONLY)\n    {\n      /* Access modes */\n    case O_RDONLY:\n    case O_WRONLY:\n    case O_RDWR:\n#if O_EXEC && O_EXEC != O_RDONLY\n    case O_EXEC:\n#endif\n#if O_SEARCH && O_EXEC != O_SEARCH && O_SEARCH != O_RDONLY\n    case O_SEARCH:\n#endif\n      i = ! (~O_ACCMODE & (O_RDONLY | O_WRONLY | O_RDWR | O_EXEC | O_SEARCH));\n      break;\n\n      /* Everyone should have these */\n    case O_CREAT:\n    case O_EXCL:\n    case O_TRUNC:\n    case O_APPEND:\n      break;\n\n      /* These might be 0 or O_RDONLY, only test non-zero versions.  */\n#if O_CLOEXEC\n    case O_CLOEXEC:\n#endif\n#if O_DIRECT\n    case O_DIRECT:\n#endif\n#if O_DIRECTORY\n    case O_DIRECTORY:\n#endif\n#if O_DSYNC\n    case O_DSYNC:\n#endif\n#if O_IGNORE_CTTY\n    case O_IGNORE_CTTY:\n#endif\n#if O_NOATIME\n    case O_NOATIME:\n#endif\n#if O_NONBLOCK\n    case O_NONBLOCK:\n#endif\n#if O_NOCTTY\n    case O_NOCTTY:\n#endif\n#if O_NOFOLLOW\n    case O_NOFOLLOW:\n#endif\n#if O_NOLINK\n    case O_NOLINK:\n#endif\n#if O_NOLINKS\n    case O_NOLINKS:\n#endif\n#if O_NOTRANS\n    case O_NOTRANS:\n#endif\n#if O_RSYNC && O_RSYNC != O_DSYNC\n    case O_RSYNC:\n#endif\n#if O_SYNC && O_SYNC != O_DSYNC && O_SYNC != O_RSYNC\n    case O_SYNC:\n#endif\n#if O_TTY_INIT\n    case O_TTY_INIT:\n#endif\n#if O_BINARY\n    case O_BINARY:\n#endif\n#if O_TEXT\n    case O_TEXT:\n#endif\n      ;\n    }\n\n  return !i;\n}",
      "lines": 92,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-fcntl-safer.c": {
    "main": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "int\nmain (void)\n{\n  return test_open (open, true);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-fcntl.c": {
    "zero": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        45,
        36
      ],
      "content": "static int zero (void) { return 0; }",
      "lines": 1,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "is_open": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        63,
        1
      ],
      "content": "static bool\nis_open (int fd)\n{\n#if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n  /* On native Windows, the initial state of unassigned standard file\n     descriptors is that they are open but point to an\n     INVALID_HANDLE_VALUE, and there is no fcntl.  */\n  return (HANDLE) _get_osfhandle (fd) != INVALID_HANDLE_VALUE;\n#else\n# ifndef F_GETFL\n#  error Please port fcntl to your platform\n# endif\n  return 0 <= fcntl (fd, F_GETFL);\n#endif\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "is_inheritable": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "static bool\nis_inheritable (int fd)\n{\n#if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n  /* On native Windows, the initial state of unassigned standard file\n     descriptors is that they are open but point to an\n     INVALID_HANDLE_VALUE, and there is no fcntl.  */\n  HANDLE h = (HANDLE) _get_osfhandle (fd);\n  DWORD flags;\n  if (h == INVALID_HANDLE_VALUE || GetHandleInformation (h, &flags) == 0)\n    return false;\n  return (flags & HANDLE_FLAG_INHERIT) != 0;\n#else\n# ifndef F_GETFD\n#  error Please port fcntl to your platform\n# endif\n  int i = fcntl (fd, F_GETFD);\n  return 0 <= i && (i & FD_CLOEXEC) == 0;\n#endif\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "is_mode": {
      "start_point": [
        89,
        0
      ],
      "end_point": [
        95,
        1
      ],
      "content": "static bool\nis_mode (int fd, int mode)\n{\n  int value = setmode (fd, O_BINARY);\n  setmode (fd, value);\n  return mode == value;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "func1": {
      "start_point": [
        110,
        0
      ],
      "end_point": [
        125,
        1
      ],
      "content": "static int\nfunc1 (int a, ...)\n{\n  va_list arg;\n  int i;\n  va_start (arg, a);\n  if (a < 4)\n    i = va_arg (arg, int);\n  else\n    {\n      struct dummy_struct *s = va_arg (arg, struct dummy_struct *);\n      i = s->value;\n    }\n  va_end (arg);\n  return i;\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "func2": {
      "start_point": [
        126,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "static int\nfunc2 (int a, ...)\n{\n  va_list arg;\n  void *p;\n  va_start (arg, a);\n  p = va_arg (arg, void *);\n  va_end (arg);\n  return func1 (a, p);\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "check_flags": {
      "start_point": [
        139,
        0
      ],
      "end_point": [
        206,
        1
      ],
      "content": "static void\ncheck_flags (void)\n{\n  switch (0)\n    {\n    case F_DUPFD:\n#if F_DUPFD\n#endif\n\n    case F_DUPFD_CLOEXEC:\n#if F_DUPFD_CLOEXEC\n#endif\n\n    case F_GETFD:\n#if F_GETFD\n#endif\n\n#ifdef F_SETFD\n    case F_SETFD:\n# if F_SETFD\n# endif\n#endif\n\n#ifdef F_GETFL\n    case F_GETFL:\n# if F_GETFL\n# endif\n#endif\n\n#ifdef F_SETFL\n    case F_SETFL:\n# if F_SETFL\n# endif\n#endif\n\n#ifdef F_GETOWN\n    case F_GETOWN:\n# if F_GETOWN\n# endif\n#endif\n\n#ifdef F_SETOWN\n    case F_SETOWN:\n# if F_SETOWN\n# endif\n#endif\n\n#ifdef F_GETLK\n    case F_GETLK:\n# if F_GETLK\n# endif\n#endif\n\n#ifdef F_SETLK\n    case F_SETLK:\n# if F_SETLK\n# endif\n#endif\n\n#ifdef F_SETLKW\n    case F_SETLKW:\n# if F_SETLKW\n# endif\n#endif\n\n      ;\n    }\n}",
      "lines": 68,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        208,
        0
      ],
      "end_point": [
        408,
        1
      ],
      "content": "int\nmain (void)\n{\n  const char *file = \"test-fcntl.tmp\";\n  int fd;\n  int bad_fd = getdtablesize ();\n\n  /* Sanity check that rpl_fcntl is likely to work.  */\n  ASSERT (func2 (1, 2) == 2);\n  ASSERT (func2 (2, -2) == -2);\n  ASSERT (func2 (3, 0x80000000) == 0x80000000);\n  {\n    struct dummy_struct s = { 0L, 4 };\n    ASSERT (func2 (4, &s) == 4);\n  }\n  check_flags ();\n\n  /* Assume std descriptors were provided by invoker, and ignore fds\n     that might have been inherited.  */\n  fd = creat (file, 0600);\n  ASSERT (STDERR_FILENO < fd);\n  close (fd + 1);\n  close (fd + 2);\n\n  /* For F_DUPFD*, the source must be valid.  */\n  errno = 0;\n  ASSERT (fcntl (-1, F_DUPFD, 0) == -1);\n  ASSERT (errno == EBADF);\n  errno = 0;\n  ASSERT (fcntl (fd + 1, F_DUPFD, 0) == -1);\n  ASSERT (errno == EBADF);\n  errno = 0;\n  ASSERT (fcntl (bad_fd, F_DUPFD, 0) == -1);\n  ASSERT (errno == EBADF);\n  errno = 0;\n  ASSERT (fcntl (-1, F_DUPFD_CLOEXEC, 0) == -1);\n  ASSERT (errno == EBADF);\n  errno = 0;\n  ASSERT (fcntl (fd + 1, F_DUPFD_CLOEXEC, 0) == -1);\n  ASSERT (errno == EBADF);\n  errno = 0;\n  ASSERT (fcntl (bad_fd, F_DUPFD_CLOEXEC, 0) == -1);\n  ASSERT (errno == EBADF);\n\n  /* For F_DUPFD*, the destination must be valid.  */\n  errno = 0;\n  ASSERT (fcntl (fd, F_DUPFD, -1) == -1);\n  ASSERT (errno == EINVAL);\n  errno = 0;\n  ASSERT (fcntl (fd, F_DUPFD, bad_fd) == -1);\n  ASSERT (errno == EINVAL);\n  errno = 0;\n  ASSERT (fcntl (fd, F_DUPFD_CLOEXEC, -1) == -1);\n  ASSERT (errno == EINVAL);\n  errno = 0;\n  ASSERT (fcntl (fd, F_DUPFD_CLOEXEC, bad_fd) == -1);\n  ASSERT (errno == EINVAL);\n\n  /* For F_DUPFD*, check for correct inheritance, as well as\n     preservation of text vs. binary.  */\n  setmode (fd, O_BINARY);\n  ASSERT (is_open (fd));\n  ASSERT (!is_open (fd + 1));\n  ASSERT (!is_open (fd + 2));\n  ASSERT (is_inheritable (fd));\n  ASSERT (is_mode (fd, O_BINARY));\n\n  ASSERT (fcntl (fd, F_DUPFD, fd) == fd + 1);\n  ASSERT (is_open (fd));\n  ASSERT (is_open (fd + 1));\n  ASSERT (!is_open (fd + 2));\n  ASSERT (is_inheritable (fd + 1));\n  ASSERT (is_mode (fd, O_BINARY));\n  ASSERT (is_mode (fd + 1, O_BINARY));\n  ASSERT (close (fd + 1) == 0);\n\n  ASSERT (fcntl (fd, F_DUPFD_CLOEXEC, fd + 2) == fd + 2);\n  ASSERT (is_open (fd));\n  ASSERT (!is_open (fd + 1));\n  ASSERT (is_open (fd + 2));\n  ASSERT (is_inheritable (fd));\n  ASSERT (!is_inheritable (fd + 2));\n  ASSERT (is_mode (fd, O_BINARY));\n  ASSERT (is_mode (fd + 2, O_BINARY));\n  ASSERT (close (fd) == 0);\n\n  setmode (fd + 2, O_TEXT);\n  ASSERT (fcntl (fd + 2, F_DUPFD, fd + 1) == fd + 1);\n  ASSERT (!is_open (fd));\n  ASSERT (is_open (fd + 1));\n  ASSERT (is_open (fd + 2));\n  ASSERT (is_inheritable (fd + 1));\n  ASSERT (!is_inheritable (fd + 2));\n  ASSERT (is_mode (fd + 1, O_TEXT));\n  ASSERT (is_mode (fd + 2, O_TEXT));\n  ASSERT (close (fd + 1) == 0);\n\n  ASSERT (fcntl (fd + 2, F_DUPFD_CLOEXEC, 0) == fd);\n  ASSERT (is_open (fd));\n  ASSERT (!is_open (fd + 1));\n  ASSERT (is_open (fd + 2));\n  ASSERT (!is_inheritable (fd));\n  ASSERT (!is_inheritable (fd + 2));\n  ASSERT (is_mode (fd, O_TEXT));\n  ASSERT (is_mode (fd + 2, O_TEXT));\n  ASSERT (close (fd + 2) == 0);\n\n  /* Test F_GETFD on invalid file descriptors.  */\n  errno = 0;\n  ASSERT (fcntl (-1, F_GETFD) == -1);\n  ASSERT (errno == EBADF);\n  errno = 0;\n  ASSERT (fcntl (fd + 1, F_GETFD) == -1);\n  ASSERT (errno == EBADF);\n  errno = 0;\n  ASSERT (fcntl (bad_fd, F_GETFD) == -1);\n  ASSERT (errno == EBADF);\n\n  /* Test F_GETFD, the FD_CLOEXEC bit.  */\n  {\n    int result = fcntl (fd, F_GETFD);\n    ASSERT (0 <= result);\n    ASSERT ((result & FD_CLOEXEC) == FD_CLOEXEC);\n    ASSERT (dup (fd) == fd + 1);\n    result = fcntl (fd + 1, F_GETFD);\n    ASSERT (0 <= result);\n    ASSERT ((result & FD_CLOEXEC) == 0);\n    ASSERT (close (fd + 1) == 0);\n  }\n\n#ifdef F_SETFD\n  /* Test F_SETFD on invalid file descriptors.  */\n  errno = 0;\n  ASSERT (fcntl (-1, F_SETFD, 0) == -1);\n  ASSERT (errno == EBADF);\n  errno = 0;\n  ASSERT (fcntl (fd + 1, F_SETFD, 0) == -1);\n  ASSERT (errno == EBADF);\n  errno = 0;\n  ASSERT (fcntl (bad_fd, F_SETFD, 0) == -1);\n  ASSERT (errno == EBADF);\n#endif\n\n#ifdef F_GETFL\n  /* Test F_GETFL on invalid file descriptors.  */\n  errno = 0;\n  ASSERT (fcntl (-1, F_GETFL) == -1);\n  ASSERT (errno == EBADF);\n  errno = 0;\n  ASSERT (fcntl (fd + 1, F_GETFL) == -1);\n  ASSERT (errno == EBADF);\n  errno = 0;\n  ASSERT (fcntl (bad_fd, F_GETFL) == -1);\n  ASSERT (errno == EBADF);\n#endif\n\n#ifdef F_SETFL\n  /* Test F_SETFL on invalid file descriptors.  */\n  errno = 0;\n  ASSERT (fcntl (-1, F_SETFL, 0) == -1);\n  ASSERT (errno == EBADF);\n  errno = 0;\n  ASSERT (fcntl (fd + 1, F_SETFL, 0) == -1);\n  ASSERT (errno == EBADF);\n  errno = 0;\n  ASSERT (fcntl (bad_fd, F_SETFL, 0) == -1);\n  ASSERT (errno == EBADF);\n#endif\n\n#ifdef F_GETOWN\n  /* Test F_GETOWN on invalid file descriptors.  */\n  errno = 0;\n  ASSERT (fcntl (-1, F_GETOWN) == -1);\n  ASSERT (errno == EBADF);\n  errno = 0;\n  ASSERT (fcntl (fd + 1, F_GETOWN) == -1);\n  ASSERT (errno == EBADF);\n  errno = 0;\n  ASSERT (fcntl (bad_fd, F_GETOWN) == -1);\n  ASSERT (errno == EBADF);\n#endif\n\n#ifdef F_SETOWN\n  /* Test F_SETFL on invalid file descriptors.  */\n  errno = 0;\n  ASSERT (fcntl (-1, F_SETOWN, 0) == -1);\n  ASSERT (errno == EBADF);\n  errno = 0;\n  ASSERT (fcntl (fd + 1, F_SETOWN, 0) == -1);\n  ASSERT (errno == EBADF);\n  errno = 0;\n  ASSERT (fcntl (bad_fd, F_SETOWN, 0) == -1);\n  ASSERT (errno == EBADF);\n#endif\n\n  /* Cleanup.  */\n  ASSERT (close (fd) == 0);\n  ASSERT (unlink (file) == 0);\n\n  return 0;\n}",
      "lines": 201,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-fdopen.c": {
    "main": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "int\nmain (void)\n{\n  /* Test behavior on failure.  POSIX makes it hard to check for\n     failure, since the behavior is not well-defined on invalid file\n     descriptors, so try fdopen 1000 times and if that's not enough to\n     fail due to EMFILE, so be it.  */\n\n  int i;\n  for (i = 0; i < 1000; i++)\n    {\n      errno = 0;\n      if (! fdopen (STDOUT_FILENO, \"w\"))\n        {\n          ASSERT (errno != 0);\n          break;\n        }\n    }\n\n  return 0;\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-fdopendir.c": {
    "main": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        82,
        1
      ],
      "content": "int\nmain (int argc _GL_UNUSED, char *argv[])\n{\n  DIR *d;\n  int fd;\n\n  set_program_name (argv[0]);\n\n  /* A non-directory cannot be turned into a directory stream.  */\n  fd = open (\"test-fdopendir.tmp\", O_RDONLY | O_CREAT, 0600);\n  ASSERT (0 <= fd);\n  errno = 0;\n  ASSERT (fdopendir (fd) == NULL);\n  ASSERT (errno == ENOTDIR);\n  ASSERT (close (fd) == 0);\n  ASSERT (unlink (\"test-fdopendir.tmp\") == 0);\n\n  /* A bad fd cannot be turned into a stream.  */\n  {\n    errno = 0;\n    ASSERT (fdopendir (-1) == NULL);\n    ASSERT (errno == EBADF);\n  }\n  {\n    close (99);\n    errno = 0;\n    ASSERT (fdopendir (99) == NULL);\n    ASSERT (errno == EBADF);\n  }\n\n  /* This should work.  */\n  fd = open (\".\", O_RDONLY);\n  ASSERT (0 <= fd);\n  d = fdopendir (fd);\n  ASSERT (d);\n  /* fdopendir should not close fd.  */\n  ASSERT (dup2 (fd, fd) == fd);\n\n  /* Don't test dirfd here.  dirfd (d) must return fd on current POSIX\n     platforms, but on pre-2008 platforms or on non-POSIX platforms\n     dirfd (fd) might return some other descriptor, or -1, and gnulib\n     does not work around this porting problem.  */\n\n  ASSERT (closedir (d) == 0);\n  /* Now we can guarantee that fd must be closed.  */\n  errno = 0;\n  ASSERT (dup2 (fd, fd) == -1);\n  ASSERT (errno == EBADF);\n\n  return 0;\n}",
      "lines": 51,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-fflush.c": {
    "main": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        190,
        1
      ],
      "content": "int\nmain (void)\n{\n  FILE *f;\n  char buffer[10];\n  int fd;\n\n  /* Create test file.  */\n  f = fopen (\"test-fflush.txt\", \"w\");\n  if (!f || fwrite (\"1234567890ABCDEFG\", 1, 17, f) != 17 || fclose (f) != 0)\n    {\n      fputs (\"Failed to create sample file.\\n\", stderr);\n      unlink (\"test-fflush.txt\");\n      return 1;\n    }\n\n  /* Test fflush.  */\n  f = fopen (\"test-fflush.txt\", \"r\");\n  ASSERT (f != NULL);\n  fd = fileno (f);\n  if (!f || 0 > fd || fread (buffer, 1, 5, f) != 5)\n    {\n      fputs (\"Failed initial read of sample file.\\n\", stderr);\n      if (f)\n        fclose (f);\n      unlink (\"test-fflush.txt\");\n      return 1;\n    }\n  /* For deterministic results, ensure f read a bigger buffer.\n     This is not the case on BeOS, nor on uClibc.  */\n#if !(defined __BEOS__ || defined __UCLIBC__)\n  if (lseek (fd, 0, SEEK_CUR) == 5)\n    {\n      fputs (\"Sample file was not buffered after fread.\\n\", stderr);\n      fclose (f);\n      unlink (\"test-fflush.txt\");\n      return 1;\n    }\n#endif\n  /* POSIX requires fflush-fseek to set file offset of fd.  */\n  if (fflush (f) != 0 || fseeko (f, 0, SEEK_CUR) != 0)\n    {\n      fputs (\"Failed to flush-fseek sample file.\\n\", stderr);\n      fclose (f);\n      unlink (\"test-fflush.txt\");\n      return 1;\n    }\n  /* Check that offset is correct.  */\n  if (lseek (fd, 0, SEEK_CUR) != 5)\n    {\n      fprintf (stderr, \"File offset is wrong after fseek: %ld.\\n\",\n               (long) lseek (fd, 0, SEEK_CUR));\n      fclose (f);\n      unlink (\"test-fflush.txt\");\n      return 1;\n    }\n  if (ftell (f) != 5)\n    {\n      fprintf (stderr, \"ftell result is wrong after fseek: %ld.\\n\",\n               (long) ftell (f));\n      fclose (f);\n      unlink (\"test-fflush.txt\");\n      return 1;\n    }\n  /* Check that file reading resumes at correct location.  */\n  if (fgetc (f) != '6')\n    {\n      fputs (\"Failed to read next byte after fseek.\\n\", stderr);\n      fclose (f);\n      unlink (\"test-fflush.txt\");\n      return 1;\n    }\n  /* For deterministic results, ensure f read a bigger buffer.  */\n  if (lseek (fd, 0, SEEK_CUR) == 6)\n    {\n      fputs (\"Sample file was not buffered after fgetc.\\n\", stderr);\n      fclose (f);\n      unlink (\"test-fflush.txt\");\n      return 1;\n    }\n  /* POSIX requires fflush-fseeko to set file offset of fd.  */\n  if (fflush (f) != 0 || fseeko (f, 0, SEEK_CUR) != 0)\n    {\n      fputs (\"Failed to flush-fseeko sample file.\\n\", stderr);\n      fclose (f);\n      unlink (\"test-fflush.txt\");\n      return 1;\n    }\n  /* Check that offset is correct.  */\n  if (lseek (fd, 0, SEEK_CUR) != 6)\n    {\n      fprintf (stderr, \"File offset is wrong after fseeko: %ld.\\n\",\n               (long) lseek (fd, 0, SEEK_CUR));\n      fclose (f);\n      unlink (\"test-fflush.txt\");\n      return 1;\n    }\n  if (ftell (f) != 6)\n    {\n      fprintf (stderr, \"ftell result is wrong after fseeko: %ld.\\n\",\n               (long) ftell (f));\n      fclose (f);\n      unlink (\"test-fflush.txt\");\n      return 1;\n    }\n  /* Check that file reading resumes at correct location.  */\n  if (fgetc (f) != '7')\n    {\n      fputs (\"Failed to read next byte after fseeko.\\n\", stderr);\n      fclose (f);\n      unlink (\"test-fflush.txt\");\n      return 1;\n    }\n  fclose (f);\n\n  /* Test that fflush() sets errno if someone else closes the stream\n     fd behind the back of stdio.  */\n  {\n    FILE *fp = fopen (\"test-fflush.txt\", \"w\");\n    ASSERT (fp != NULL);\n    fputc ('x', fp);\n    ASSERT (close (fileno (fp)) == 0);\n    errno = 0;\n    ASSERT (fflush (fp) == EOF);\n    ASSERT (errno == EBADF);\n    fclose (fp);\n  }\n\n  /* Test that fflush() sets errno if the stream was constructed with\n     an invalid file descriptor.  */\n  {\n    FILE *fp = fdopen (-1, \"w\");\n    if (fp != NULL)\n      {\n        fputc ('x', fp);\n        errno = 0;\n        ASSERT (fflush (fp) == EOF);\n        ASSERT (errno == EBADF);\n      }\n  }\n  {\n    FILE *fp;\n    close (99);\n    fp = fdopen (99, \"w\");\n    if (fp != NULL)\n      {\n        fputc ('x', fp);\n        errno = 0;\n        ASSERT (fflush (fp) == EOF);\n        ASSERT (errno == EBADF);\n      }\n  }\n\n  /* Clean up.  */\n  unlink (\"test-fflush.txt\");\n\n  return 0;\n}",
      "lines": 158,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-fflush2.c": {
    "main": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  int c;\n\n  /* Avoid the well-known bugs of fflush() on streams in O_TEXT mode\n     on native Windows platforms.  */\n  SET_BINARY (0);\n\n  if (argc > 1)\n    switch (argv[1][0])\n      {\n      case '1':\n        /* Check fflush after a backup ungetc() call.  This is case 1a in\n           terms of\n           <http://lists.gnu.org/archive/html/bug-gnulib/2008-03/msg00131.html>,\n           according to the Austin Group's resolution on 2009-01-08.  */\n\n        c = fgetc (stdin);\n        ASSERT (c == '#');\n\n        c = fgetc (stdin);\n        ASSERT (c == '!');\n\n        /* Here the file-position indicator must be 2.  */\n\n        c = ungetc ('!', stdin);\n        ASSERT (c == '!');\n\n        fflush (stdin);\n\n        /* Here the file-position indicator must be 1.  */\n\n        c = fgetc (stdin);\n        ASSERT (c == '!');\n\n        c = fgetc (stdin);\n        ASSERT (c == '/');\n\n        return 0;\n\n      case '2':\n        /* Check fflush after a non-backup ungetc() call.  This is case 2a in\n           terms of\n           <http://lists.gnu.org/archive/html/bug-gnulib/2008-03/msg00131.html>,\n           according to the Austin Group's resolution on 2009-01-08.  */\n        /* Check that fflush after a non-backup ungetc() call discards the\n           ungetc buffer.  This is mandated by POSIX\n           <http://www.opengroup.org/susv3/functions/ungetc.html>:\n             \"The value of the file-position indicator for the stream after\n              reading or discarding all pushed-back bytes shall be the same\n              as it was before the bytes were pushed back.\"\n           <http://www.opengroup.org/austin/aardvark/latest/xshbug3.txt>\n             \"[After fflush(),] the file offset of the underlying open file\n              description shall be set to the file position of the stream, and\n              any characters pushed back onto the stream by ungetc() or\n              ungetwc() that have not subsequently been read from the stream\n              shall be discarded.\"  */\n\n        c = fgetc (stdin);\n        ASSERT (c == '#');\n\n        c = fgetc (stdin);\n        ASSERT (c == '!');\n\n        /* Here the file-position indicator must be 2.  */\n\n        c = ungetc ('@', stdin);\n        ASSERT (c == '@');\n\n        fflush (stdin);\n\n        /* Here the file-position indicator must be 1.  */\n\n        c = fgetc (stdin);\n        ASSERT (c == '!');\n\n        c = fgetc (stdin);\n        ASSERT (c == '/');\n\n        return 0;\n      }\n\n  return 1;\n}",
      "lines": 85,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-fgetc.c": {
    "main": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        96,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  const char *filename = \"test-fgetc.txt\";\n\n  /* We don't have an fgetc() function that installs an invalid parameter\n     handler so far.  So install that handler here, explicitly.  */\n#if HAVE_MSVC_INVALID_PARAMETER_HANDLER \\\n    && MSVC_INVALID_PARAMETER_HANDLING == DEFAULT_HANDLING\n  gl_msvc_inval_ensure_handler ();\n#endif\n\n  /* Prepare a file.  */\n  {\n    const char text[] = \"hello world\";\n    int fd = open (filename, O_RDWR | O_CREAT | O_TRUNC, 0600);\n    ASSERT (fd >= 0);\n    ASSERT (write (fd, text, sizeof (text)) == sizeof (text));\n    ASSERT (close (fd) == 0);\n  }\n\n  /* Test that fgetc() sets errno if someone else closes the stream\n     fd behind the back of stdio.  */\n  {\n    FILE *fp = fopen (filename, \"r\");\n    ASSERT (fp != NULL);\n    ASSERT (close (fileno (fp)) == 0);\n    errno = 0;\n    ASSERT (fgetc (fp) == EOF);\n    ASSERT (errno == EBADF);\n    ASSERT (ferror (fp));\n    fclose (fp);\n  }\n\n  /* Test that fgetc() sets errno if the stream was constructed with\n     an invalid file descriptor.  */\n  {\n    FILE *fp = fdopen (-1, \"r\");\n    if (fp != NULL)\n      {\n        errno = 0;\n        ASSERT (fgetc (fp) == EOF);\n        ASSERT (errno == EBADF);\n        ASSERT (ferror (fp));\n        fclose (fp);\n      }\n  }\n  {\n    FILE *fp;\n    close (99);\n    fp = fdopen (99, \"r\");\n    if (fp != NULL)\n      {\n        errno = 0;\n        ASSERT (fgetc (fp) == EOF);\n        ASSERT (errno == EBADF);\n        ASSERT (ferror (fp));\n        fclose (fp);\n      }\n  }\n\n  /* Clean up.  */\n  unlink (filename);\n\n  return 0;\n}",
      "lines": 66,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-float.c": {
    "pow2f": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "static float\npow2f (int n)\n{\n  int k = n;\n  volatile float x = 1;\n  volatile float y = 2;\n  /* Invariant: 2^n == x * y^k.  */\n  if (k < 0)\n    {\n      y = 0.5f;\n      k = - k;\n    }\n  while (k > 0)\n    {\n      if (k != 2 * (k / 2))\n        {\n          x = x * y;\n          k = k - 1;\n        }\n      if (k == 0)\n        break;\n      y = y * y;\n      k = k / 2;\n    }\n  /* Now k == 0, hence x == 2^n.  */\n  return x;\n}",
      "lines": 27,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "float"
      ]
    },
    "pow2d": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "static double\npow2d (int n)\n{\n  int k = n;\n  volatile double x = 1;\n  volatile double y = 2;\n  /* Invariant: 2^n == x * y^k.  */\n  if (k < 0)\n    {\n      y = 0.5;\n      k = - k;\n    }\n  while (k > 0)\n    {\n      if (k != 2 * (k / 2))\n        {\n          x = x * y;\n          k = k - 1;\n        }\n      if (k == 0)\n        break;\n      y = y * y;\n      k = k / 2;\n    }\n  /* Now k == 0, hence x == 2^n.  */\n  return x;\n}",
      "lines": 27,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "pow2l": {
      "start_point": [
        89,
        0
      ],
      "end_point": [
        115,
        1
      ],
      "content": "static long double\npow2l (int n)\n{\n  int k = n;\n  volatile long double x = 1;\n  volatile long double y = 2;\n  /* Invariant: 2^n == x * y^k.  */\n  if (k < 0)\n    {\n      y = 0.5L;\n      k = - k;\n    }\n  while (k > 0)\n    {\n      if (k != 2 * (k / 2))\n        {\n          x = x * y;\n          k = k - 1;\n        }\n      if (k == 0)\n        break;\n      y = y * y;\n      k = k / 2;\n    }\n  /* Now k == 0, hence x == 2^n.  */\n  return x;\n}",
      "lines": 27,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "long double",
        "long",
        "double"
      ]
    },
    "test_float": {
      "start_point": [
        127,
        0
      ],
      "end_point": [
        194,
        1
      ],
      "content": "static void\ntest_float (void)\n{\n  /* Check that the value of FLT_MIN_EXP is well parenthesized.  */\n  ASSERT ((FLT_MIN_EXP % 101111) == (FLT_MIN_EXP) % 101111);\n\n  /* Check that the value of DBL_MIN_10_EXP is well parenthesized.  */\n  ASSERT ((FLT_MIN_10_EXP % 101111) == (FLT_MIN_10_EXP) % 101111);\n\n  /* Check that 'float' is as specified in IEEE 754.  */\n  ASSERT (FLT_MANT_DIG == 24);\n  ASSERT (FLT_MIN_EXP == -125);\n  ASSERT (FLT_MAX_EXP == 128);\n\n  /* Check the value of FLT_MIN_10_EXP.  */\n  ASSERT (FLT_MIN_10_EXP == - (int) (- (FLT_MIN_EXP - 1) * 0.30103));\n\n  /* Check the value of FLT_DIG.  */\n  ASSERT (FLT_DIG == (int) ((FLT_MANT_DIG - 1) * 0.30103));\n\n  /* Check the value of FLT_MIN_10_EXP.  */\n  ASSERT (FLT_MIN_10_EXP == - (int) (- (FLT_MIN_EXP - 1) * 0.30103));\n\n  /* Check the value of FLT_MAX_10_EXP.  */\n  ASSERT (FLT_MAX_10_EXP == (int) (FLT_MAX_EXP * 0.30103));\n\n  /* Check the value of FLT_MAX.  */\n  {\n    volatile float m = FLT_MAX;\n    int n;\n\n    ASSERT (m + m > m);\n    for (n = 0; n <= 2 * FLT_MANT_DIG; n++)\n      {\n        volatile float pow2_n = pow2f (n); /* 2^n */\n        volatile float x = m + (m / pow2_n);\n        if (x > m)\n          ASSERT (x + x == x);\n        else\n          ASSERT (!(x + x == x));\n      }\n  }\n\n  /* Check the value of FLT_MIN.  */\n  {\n    volatile float m = FLT_MIN;\n    volatile float x = pow2f (FLT_MIN_EXP - 1);\n    ASSERT (m == x);\n  }\n\n  /* Check the value of FLT_EPSILON.  */\n  {\n    volatile float e = FLT_EPSILON;\n    volatile float me;\n    int n;\n\n    me = 1.0f + e;\n    ASSERT (me > 1.0f);\n    ASSERT (me - 1.0f == e);\n    for (n = 0; n <= 2 * FLT_MANT_DIG; n++)\n      {\n        volatile float half_n = pow2f (- n); /* 2^-n */\n        volatile float x = me - half_n;\n        if (x < me)\n          ASSERT (x <= 1.0f);\n      }\n  }\n}",
      "lines": 68,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_double": {
      "start_point": [
        206,
        0
      ],
      "end_point": [
        273,
        1
      ],
      "content": "static void\ntest_double (void)\n{\n  /* Check that the value of DBL_MIN_EXP is well parenthesized.  */\n  ASSERT ((DBL_MIN_EXP % 101111) == (DBL_MIN_EXP) % 101111);\n\n  /* Check that the value of DBL_MIN_10_EXP is well parenthesized.  */\n  ASSERT ((DBL_MIN_10_EXP % 101111) == (DBL_MIN_10_EXP) % 101111);\n\n  /* Check that 'double' is as specified in IEEE 754.  */\n  ASSERT (DBL_MANT_DIG == 53);\n  ASSERT (DBL_MIN_EXP == -1021);\n  ASSERT (DBL_MAX_EXP == 1024);\n\n  /* Check the value of DBL_MIN_10_EXP.  */\n  ASSERT (DBL_MIN_10_EXP == - (int) (- (DBL_MIN_EXP - 1) * 0.30103));\n\n  /* Check the value of DBL_DIG.  */\n  ASSERT (DBL_DIG == (int) ((DBL_MANT_DIG - 1) * 0.30103));\n\n  /* Check the value of DBL_MIN_10_EXP.  */\n  ASSERT (DBL_MIN_10_EXP == - (int) (- (DBL_MIN_EXP - 1) * 0.30103));\n\n  /* Check the value of DBL_MAX_10_EXP.  */\n  ASSERT (DBL_MAX_10_EXP == (int) (DBL_MAX_EXP * 0.30103));\n\n  /* Check the value of DBL_MAX.  */\n  {\n    volatile double m = DBL_MAX;\n    int n;\n\n    ASSERT (m + m > m);\n    for (n = 0; n <= 2 * DBL_MANT_DIG; n++)\n      {\n        volatile double pow2_n = pow2d (n); /* 2^n */\n        volatile double x = m + (m / pow2_n);\n        if (x > m)\n          ASSERT (x + x == x);\n        else\n          ASSERT (!(x + x == x));\n      }\n  }\n\n  /* Check the value of DBL_MIN.  */\n  {\n    volatile double m = DBL_MIN;\n    volatile double x = pow2d (DBL_MIN_EXP - 1);\n    ASSERT (m == x);\n  }\n\n  /* Check the value of DBL_EPSILON.  */\n  {\n    volatile double e = DBL_EPSILON;\n    volatile double me;\n    int n;\n\n    me = 1.0 + e;\n    ASSERT (me > 1.0);\n    ASSERT (me - 1.0 == e);\n    for (n = 0; n <= 2 * DBL_MANT_DIG; n++)\n      {\n        volatile double half_n = pow2d (- n); /* 2^-n */\n        volatile double x = me - half_n;\n        if (x < me)\n          ASSERT (x <= 1.0);\n      }\n  }\n}",
      "lines": 68,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_long_double": {
      "start_point": [
        289,
        0
      ],
      "end_point": [
        353,
        1
      ],
      "content": "static void\ntest_long_double (void)\n{\n  /* Check that the value of LDBL_MIN_EXP is well parenthesized.  */\n  ASSERT ((LDBL_MIN_EXP % 101111) == (LDBL_MIN_EXP) % 101111);\n\n  /* Check that the value of LDBL_MIN_10_EXP is well parenthesized.  */\n  ASSERT ((LDBL_MIN_10_EXP % 101111) == (LDBL_MIN_10_EXP) % 101111);\n\n  /* Check that 'long double' is at least as wide as 'double'.  */\n  ASSERT (LDBL_MANT_DIG >= DBL_MANT_DIG);\n  ASSERT (LDBL_MIN_EXP - LDBL_MANT_DIG <= DBL_MIN_EXP - DBL_MANT_DIG);\n  ASSERT (LDBL_MAX_EXP >= DBL_MAX_EXP);\n\n  /* Check the value of LDBL_DIG.  */\n  ASSERT (LDBL_DIG == (int)((LDBL_MANT_DIG - 1) * 0.30103));\n\n  /* Check the value of LDBL_MIN_10_EXP.  */\n  ASSERT (LDBL_MIN_10_EXP == - (int) (- (LDBL_MIN_EXP - 1) * 0.30103));\n\n  /* Check the value of LDBL_MAX_10_EXP.  */\n  ASSERT (LDBL_MAX_10_EXP == (int) (LDBL_MAX_EXP * 0.30103));\n\n  /* Check the value of LDBL_MAX.  */\n  {\n    volatile long double m = LDBL_MAX;\n    int n;\n\n    ASSERT (m + m > m);\n    for (n = 0; n <= 2 * LDBL_MANT_DIG; n++)\n      {\n        volatile long double pow2_n = pow2l (n); /* 2^n */\n        volatile long double x = m + (m / pow2_n);\n        if (x > m)\n          ASSERT (x + x == x);\n        else\n          ASSERT (!(x + x == x));\n      }\n  }\n\n  /* Check the value of LDBL_MIN.  */\n  {\n    volatile long double m = LDBL_MIN;\n    volatile long double x = pow2l (LDBL_MIN_EXP - 1);\n    ASSERT (m == x);\n  }\n\n  /* Check the value of LDBL_EPSILON.  */\n  {\n    volatile long double e = LDBL_EPSILON;\n    volatile long double me;\n    int n;\n\n    me = 1.0L + e;\n    ASSERT (me > 1.0L);\n    ASSERT (me - 1.0L == e);\n    for (n = 0; n <= 2 * LDBL_MANT_DIG; n++)\n      {\n        volatile long double half_n = pow2l (- n); /* 2^-n */\n        volatile long double x = me - half_n;\n        if (x < me)\n          ASSERT (x <= 1.0L);\n      }\n  }\n}",
      "lines": 65,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": [
      {
        "start_point": [
          355,
          0
        ],
        "end_point": [
          372,
          1
        ],
        "content": "int\nmain ()\n{\n  test_float ();\n  test_double ();\n\n  {\n    DECL_LONG_DOUBLE_ROUNDING\n\n    BEGIN_LONG_DOUBLE_ROUNDING ();\n\n    test_long_double ();\n\n    END_LONG_DOUBLE_ROUNDING ();\n  }\n\n  return 0;\n}",
        "lines": 18,
        "depth": 7,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          376,
          0
        ],
        "end_point": [
          381,
          1
        ],
        "content": "int\nmain ()\n{\n  fprintf (stderr, \"Skipping test: FLT_RADIX is not 2.\\n\");\n  return 77;\n}",
        "lines": 6,
        "depth": 7,
        "decorators": [
          "int"
        ]
      }
    ]
  },
  "findutils/findutils-4.6.0/tests/test-fnmatch.c": {
    "main": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "int\nmain ()\n{\n  int res;\n\n  ASSERT (res = fnmatch (\"\", \"\", 0) == 0);\n\n  ASSERT (res = fnmatch (\"*\", \"\", 0) == 0);\n  ASSERT (res = fnmatch (\"*\", \"foo\", 0) == 0);\n  ASSERT (res = fnmatch (\"*\", \"bar\", 0) == 0);\n  ASSERT (res = fnmatch (\"*\", \"*\", 0) == 0);\n  ASSERT (res = fnmatch (\"**\", \"f\", 0) == 0);\n  ASSERT (res = fnmatch (\"**\", \"foo.txt\", 0) == 0);\n  ASSERT (res = fnmatch (\"*.*\", \"foo.txt\", 0) == 0);\n\n  ASSERT (res = fnmatch (\"foo*.txt\", \"foobar.txt\", 0) == 0);\n\n  ASSERT (res = fnmatch (\"foo.txt\", \"foo.txt\", 0) == 0);\n  ASSERT (res = fnmatch (\"foo\\\\.txt\", \"foo.txt\", 0) == 0);\n  ASSERT (res = fnmatch (\"foo\\\\.txt\", \"foo.txt\", FNM_NOESCAPE) == FNM_NOMATCH);\n\n  /* Verify that an unmatched [ is treated as a literal, as POSIX\n     requires.  This test ensures that glibc Bugzilla bug #12378 stays\n     fixed.\n   */\n  ASSERT (res = fnmatch (\"[/b\", \"[/b\", 0) == 0);\n\n  return 0;\n}",
      "lines": 29,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-fopen-safer.c": {
    "main": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        30,
        1
      ],
      "content": "int\nmain (void)\n{\n  return test_fopen ();\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-fopen.c": {
    "main": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        33,
        1
      ],
      "content": "int\nmain (void)\n{\n  return test_fopen ();\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-fopen.h": {
    "test_fopen": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "static int\ntest_fopen (void)\n{\n  FILE *f;\n  /* Remove anything from prior partial run.  */\n  unlink (BASE \"file\");\n\n  /* Read requires existing file.  */\n  errno = 0;\n  ASSERT (fopen (BASE \"file\", \"r\") == NULL);\n  ASSERT (errno == ENOENT);\n\n  /* Write can create a file.  */\n  f = fopen (BASE \"file\", \"w\");\n  ASSERT (f);\n  ASSERT (fclose (f) == 0);\n\n  /* Trailing slash is invalid on non-directory.  */\n  errno = 0;\n  ASSERT (fopen (BASE \"file/\", \"r\") == NULL);\n  ASSERT (errno == ENOTDIR || errno == EISDIR || errno == EINVAL);\n\n  /* Cannot create a directory.  */\n  errno = 0;\n  ASSERT (fopen (\"nonexist.ent/\", \"w\") == NULL);\n  ASSERT (errno == ENOTDIR || errno == EISDIR || errno == ENOENT\n          || errno == EINVAL);\n\n  /* Directories cannot be opened for writing.  */\n  errno = 0;\n  ASSERT (fopen (\".\", \"w\") == NULL);\n  ASSERT (errno == EISDIR || errno == EINVAL || errno == EACCES);\n\n  /* /dev/null must exist, and be writable.  */\n  f = fopen (\"/dev/null\", \"r\");\n  ASSERT (f);\n  ASSERT (fclose (f) == 0);\n  f = fopen (\"/dev/null\", \"w\");\n  ASSERT (f);\n  ASSERT (fclose (f) == 0);\n\n  /* Cleanup.  */\n  ASSERT (unlink (BASE \"file\") == 0);\n\n  return 0;\n}",
      "lines": 46,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-fpending.c": {
    "main": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "int\nmain (void)\n{\n  ASSERT (__fpending (stdout) == 0);\n\n  fputs (\"foo\", stdout);\n  ASSERT (__fpending (stdout) == 3);\n\n  fflush (stdout);\n  ASSERT (__fpending (stdout) == 0);\n\n  exit (0);\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-fpurge.c": {
    "main": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        133,
        1
      ],
      "content": "int\nmain (void)\n{\n  int check_filepos;\n\n  for (check_filepos = 0; check_filepos <= 1; check_filepos++)\n    {\n      FILE *fp;\n\n      /* Create a file with some contents.  */\n      fp = fopen (TESTFILE, \"w\");\n      if (fp == NULL)\n        goto skip;\n      if (fwrite (\"foobarsh\", 1, 8, fp) < 8)\n        goto skip;\n      if (fclose (fp))\n        goto skip;\n\n      /* The file's contents is now \"foobarsh\".  */\n\n      /* Open it in read-write mode.  */\n      fp = fopen (TESTFILE, \"r+\");\n      if (fp == NULL)\n        goto skip;\n      if (fseek (fp, 3, SEEK_CUR))\n        goto skip;\n      if (fwrite (\"g\", 1, 1, fp) < 1)\n        goto skip;\n      if (fflush (fp))\n        goto skip;\n      if (fwrite (\"bz\", 1, 2, fp) < 2)\n        goto skip;\n      /* Discard pending write.  */\n      ASSERT (fpurge (fp) == 0);\n      /* Verify that when discarding pending output, the file position is set\n         back to where it was before the write calls.  */\n      if (check_filepos)\n        ASSERT (ftell (fp) == 4);\n      ASSERT (fclose (fp) == 0);\n\n      /* Open it in read-only mode.  */\n      fp = fopen (TESTFILE, \"r\");\n      if (fp == NULL)\n        goto skip;\n      /* Verify that the pending writes before the fpurge were really\n         discarded.  */\n      {\n        char buf[8];\n        if (fread (buf, 1, 7, fp) < 7)\n          goto skip;\n        ASSERT (memcmp (buf, \"foogars\", 7) == 0);\n      }\n      /* Discard the buffered 'h'.  */\n      if (check_filepos)\n        ASSERT (ftell (fp) == 7);\n      ASSERT (fpurge (fp) == 0);\n      /* Verify that when discarding pending input, the file position is\n         advanced to match the end of the previously read input.  */\n      if (check_filepos)\n        ASSERT (ftell (fp) == 8);\n      ASSERT (getc (fp) == EOF);\n      ASSERT (fclose (fp) == 0);\n\n      /* The file's contents is now \"foogarsh\".  */\n\n      /* Ensure that purging a read does not corrupt subsequent writes.  */\n      fp = fopen (TESTFILE, \"r+\");\n      if (fp == NULL)\n        goto skip;\n      if (fseek (fp, -1, SEEK_END))\n        goto skip;\n      ASSERT (getc (fp) == 'h');\n      ASSERT (getc (fp) == EOF);\n      if (check_filepos)\n        ASSERT (ftell (fp) == 8);\n      ASSERT (fpurge (fp) == 0);\n      if (check_filepos)\n        ASSERT (ftell (fp) == 8);\n      ASSERT (putc ('!', fp) == '!');\n      if (check_filepos)\n        ASSERT (ftell (fp) == 9);\n      ASSERT (fclose (fp) == 0);\n      fp = fopen (TESTFILE, \"r\");\n      if (fp == NULL)\n        goto skip;\n      {\n        char buf[10];\n        ASSERT (fread (buf, 1, 10, fp) == 9);\n        ASSERT (memcmp (buf, \"foogarsh!\", 9) == 0);\n      }\n      ASSERT (fclose (fp) == 0);\n\n      /* The file's contents is now \"foogarsh!\".  */\n    }\n\n  remove (TESTFILE);\n  return 0;\n\n skip:\n  fprintf (stderr, \"Skipping test: prerequisite file operations failed.\\n\");\n  remove (TESTFILE);\n  return 77;\n}",
      "lines": 103,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-fputc.c": {
    "main": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  const char *filename = \"test-fputc.txt\";\n\n  /* We don't have an fputc() function that installs an invalid parameter\n     handler so far.  So install that handler here, explicitly.  */\n#if HAVE_MSVC_INVALID_PARAMETER_HANDLER \\\n    && MSVC_INVALID_PARAMETER_HANDLING == DEFAULT_HANDLING\n  gl_msvc_inval_ensure_handler ();\n#endif\n\n  /* Test that fputc() on an unbuffered stream sets errno if someone else\n     closes the stream fd behind the back of stdio.  */\n  {\n    FILE *fp = fopen (filename, \"w\");\n    ASSERT (fp != NULL);\n    setvbuf (fp, NULL, _IONBF, 0);\n    ASSERT (close (fileno (fp)) == 0);\n    errno = 0;\n    ASSERT (fputc ('x', fp) == EOF);\n    ASSERT (errno == EBADF);\n    ASSERT (ferror (fp));\n    fclose (fp);\n  }\n\n  /* Test that fputc() on an unbuffered stream sets errno if the stream\n     was constructed with an invalid file descriptor.  */\n  {\n    FILE *fp = fdopen (-1, \"w\");\n    if (fp != NULL)\n      {\n        setvbuf (fp, NULL, _IONBF, 0);\n        errno = 0;\n        ASSERT (fputc ('x', fp) == EOF);\n        ASSERT (errno == EBADF);\n        ASSERT (ferror (fp));\n        fclose (fp);\n      }\n  }\n  {\n    FILE *fp;\n    close (99);\n    fp = fdopen (99, \"w\");\n    if (fp != NULL)\n      {\n        setvbuf (fp, NULL, _IONBF, 0);\n        errno = 0;\n        ASSERT (fputc ('x', fp) == EOF);\n        ASSERT (errno == EBADF);\n        ASSERT (ferror (fp));\n        fclose (fp);\n      }\n  }\n\n  /* Clean up.  */\n  unlink (filename);\n\n  return 0;\n}",
      "lines": 60,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-fread.c": {
    "main": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        99,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  const char *filename = \"test-fread.txt\";\n\n  /* We don't have an fread() function that installs an invalid parameter\n     handler so far.  So install that handler here, explicitly.  */\n#if HAVE_MSVC_INVALID_PARAMETER_HANDLER \\\n    && MSVC_INVALID_PARAMETER_HANDLING == DEFAULT_HANDLING\n  gl_msvc_inval_ensure_handler ();\n#endif\n\n  /* Prepare a file.  */\n  {\n    const char text[] = \"hello world\";\n    int fd = open (filename, O_RDWR | O_CREAT | O_TRUNC, 0600);\n    ASSERT (fd >= 0);\n    ASSERT (write (fd, text, sizeof (text)) == sizeof (text));\n    ASSERT (close (fd) == 0);\n  }\n\n  /* Test that fread() sets errno if someone else closes the stream\n     fd behind the back of stdio.  */\n  {\n    FILE *fp = fopen (filename, \"r\");\n    char buf[5];\n    ASSERT (fp != NULL);\n    ASSERT (close (fileno (fp)) == 0);\n    errno = 0;\n    ASSERT (fread (buf, 1, sizeof (buf), fp) == 0);\n    ASSERT (errno == EBADF);\n    ASSERT (ferror (fp));\n    fclose (fp);\n  }\n\n  /* Test that fread() sets errno if the stream was constructed with\n     an invalid file descriptor.  */\n  {\n    FILE *fp = fdopen (-1, \"r\");\n    if (fp != NULL)\n      {\n        char buf[1];\n        errno = 0;\n        ASSERT (fread (buf, 1, 1, fp) == 0);\n        ASSERT (errno == EBADF);\n        ASSERT (ferror (fp));\n        fclose (fp);\n      }\n  }\n  {\n    FILE *fp;\n    close (99);\n    fp = fdopen (99, \"r\");\n    if (fp != NULL)\n      {\n        char buf[1];\n        errno = 0;\n        ASSERT (fread (buf, 1, 1, fp) == 0);\n        ASSERT (errno == EBADF);\n        ASSERT (ferror (fp));\n        fclose (fp);\n      }\n  }\n\n  /* Clean up.  */\n  unlink (filename);\n\n  return 0;\n}",
      "lines": 69,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-freadahead.c": {
    "main": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  int nbytes = atoi (argv[1]);\n  if (nbytes > 0)\n    {\n      void *buf = malloc (nbytes);\n      ASSERT (fread (buf, 1, nbytes, stdin) == nbytes);\n    }\n\n  if (nbytes == 0)\n    ASSERT (freadahead (stdin) == 0);\n  else\n    {\n      if (lseek (0, 0, SEEK_CUR) == nbytes)\n        /* An unbuffered stdio, such as BeOS or on uClibc compiled without\n           __STDIO_BUFFERS.  */\n        ASSERT (freadahead (stdin) == 0);\n      else\n        {\n          /* Normal buffered stdio.  */\n          size_t buffered;\n          int c, c2;\n\n          ASSERT (freadahead (stdin) != 0);\n          buffered = freadahead (stdin);\n\n          c = fgetc (stdin);\n          ASSERT (freadahead (stdin) == buffered - 1);\n          ungetc (c, stdin);\n          ASSERT (freadahead (stdin) == buffered);\n          c2 = fgetc (stdin);\n          ASSERT (c2 == c);\n          ASSERT (freadahead (stdin) == buffered - 1);\n\n          c = '@';\n          ungetc (c, stdin);\n          ASSERT (freadahead (stdin) == buffered);\n          c2 = fgetc (stdin);\n          ASSERT (c2 == c);\n          ASSERT (freadahead (stdin) == buffered - 1);\n        }\n    }\n\n  return 0;\n}",
      "lines": 46,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-freading.c": {
    "main": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        129,
        1
      ],
      "content": "int\nmain (void)\n{\n  FILE *fp;\n\n  /* Create a file with some contents.  Write-only file is never reading.  */\n  fp = fopen (TESTFILE, \"w\");\n  ASSERT (fp);\n  ASSERT (!freading (fp));\n  ASSERT (fwrite (\"foobarsh\", 1, 8, fp) == 8);\n  ASSERT (!freading (fp));\n  ASSERT (fclose (fp) == 0);\n\n  /* Open it in read-only mode.  Read-only file is always reading.  */\n  fp = fopen (TESTFILE, \"r\");\n  ASSERT (fp);\n  ASSERT (freading (fp));\n  ASSERT (fgetc (fp) == 'f');\n  ASSERT (freading (fp));\n  ASSERT (fseek (fp, 2, SEEK_CUR) == 0);\n  ASSERT (freading (fp));\n  ASSERT (fgetc (fp) == 'b');\n  ASSERT (freading (fp));\n  fflush (fp);\n  ASSERT (freading (fp));\n  ASSERT (fgetc (fp) == 'a');\n  ASSERT (freading (fp));\n  ASSERT (fseek (fp, 0, SEEK_END) == 0);\n  ASSERT (freading (fp));\n  ASSERT (fclose (fp) == 0);\n\n  /* Open it in read-write mode.  POSIX requires a reposition (fseek,\n     fsetpos, rewind) or EOF when transitioning from read to write;\n     freading is only deterministic after input or output, but this\n     test case should be portable even on open, after reposition, and\n     at EOF.  */\n  /* First a scenario with only fgetc, fseek, fputc.  */\n  fp = fopen (TESTFILE, \"r+\");\n  ASSERT (fp);\n  ASSERT (!freading (fp));\n  ASSERT (fgetc (fp) == 'f');\n  ASSERT (freading (fp));\n  ASSERT (fseek (fp, 2, SEEK_CUR) ==  0);\n  /* freading (fp) is undefined here, but fwriting (fp) is false.  */\n  ASSERT (fgetc (fp) == 'b');\n  ASSERT (freading (fp));\n  /* This fseek call is necessary when switching from reading to writing.\n     See the description of fopen(), ISO C 99 7.19.5.3.(6).  */\n  ASSERT (fseek (fp, 0, SEEK_CUR) == 0);\n  /* freading (fp) is undefined here, but fwriting (fp) is false.  */\n  ASSERT (fputc ('x', fp) == 'x');\n  ASSERT (!freading (fp));\n  ASSERT (fseek (fp, 0, SEEK_END) == 0);\n  /* freading (fp) is undefined here, because on some implementations (e.g.\n     glibc) fseek causes a buffer to be read.\n     fwriting (fp) is undefined as well.  */\n  ASSERT (fclose (fp) == 0);\n\n  /* Open it in read-write mode.  POSIX requires a reposition (fseek,\n     fsetpos, rewind) or EOF when transitioning from read to write;\n     freading is only deterministic after input or output, but this\n     test case should be portable even on open, after reposition, and\n     at EOF.  */\n  /* Here a scenario that includes fflush.  */\n  fp = fopen (TESTFILE, \"r+\");\n  ASSERT (fp);\n  ASSERT (!freading (fp));\n  ASSERT (fgetc (fp) == 'f');\n  ASSERT (freading (fp));\n  ASSERT (fseek (fp, 2, SEEK_CUR) == 0);\n  /* freading (fp) is undefined here, but fwriting (fp) is false.  */\n  ASSERT (fgetc (fp) == 'b');\n  ASSERT (freading (fp));\n  fflush (fp);\n  /* freading (fp) is undefined here, but fwriting (fp) is false.  */\n  ASSERT (fgetc (fp) == 'x');\n  ASSERT (freading (fp));\n  /* This fseek call is necessary when switching from reading to writing.\n     See the description of fopen(), ISO C 99 7.19.5.3.(6).  */\n  ASSERT (fseek (fp, 0, SEEK_CUR) == 0);\n  /* freading (fp) is undefined here, but fwriting (fp) is false.  */\n  ASSERT (fputc ('z', fp) == 'z');\n  ASSERT (!freading (fp));\n  ASSERT (fseek (fp, 0, SEEK_END) == 0);\n  /* freading (fp) is undefined here, because on some implementations (e.g.\n     glibc) fseek causes a buffer to be read.\n     fwriting (fp) is undefined as well.  */\n  ASSERT (fclose (fp) == 0);\n\n  /* Open it in append mode.  Write-only file is never reading.  */\n  fp = fopen (TESTFILE, \"a\");\n  ASSERT (fp);\n  ASSERT (!freading (fp));\n  ASSERT (fwrite (\"bla\", 1, 3, fp) == 3);\n  ASSERT (!freading (fp));\n  ASSERT (fclose (fp) == 0);\n  ASSERT (remove (TESTFILE) == 0);\n  return 0;\n}",
      "lines": 99,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-fseek.c": {
    "main": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        69,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  /* Assume stdin is non-empty, seekable, and starts with '#!/bin/sh'\n     iff argc > 1.  */\n  int expected = argc > 1 ? 0 : -1;\n  ASSERT (fseek (stdin, 0, SEEK_CUR) == expected);\n  if (argc > 1)\n    {\n      /* Test that fseek discards previously read ungetc data.  */\n      int ch = fgetc (stdin);\n      ASSERT (ch == '#');\n      ASSERT (ungetc (ch, stdin) == ch);\n      ASSERT (fseek (stdin, 2, SEEK_SET) == 0);\n      ch = fgetc (stdin);\n      ASSERT (ch == '/');\n      if (2 < argc)\n        {\n          if (FUNC_UNGETC_BROKEN)\n            {\n              fputs (\"Skipping test: ungetc cannot handle arbitrary bytes\\n\",\n                     stderr);\n              return 77;\n            }\n          /* Test that fseek discards random ungetc data.  */\n          ASSERT (ungetc (ch ^ 0xff, stdin) == (ch ^ 0xff));\n        }\n      ASSERT (fseek (stdin, 0, SEEK_END) == 0);\n      ASSERT (fgetc (stdin) == EOF);\n      /* Test that fseek resets end-of-file marker.  */\n      ASSERT (feof (stdin));\n      ASSERT (fseek (stdin, 0, SEEK_END) == 0);\n      ASSERT (!feof (stdin));\n    }\n  return 0;\n}",
      "lines": 36,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-fseeko.c": {
    "main": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        73,
        1
      ],
      "content": "int\nmain (int argc, char **argv _GL_UNUSED)\n{\n  /* Assume stdin is non-empty, seekable, and starts with '#!/bin/sh'\n     iff argc > 1.  */\n  int expected = argc > 1 ? 0 : -1;\n  /* Exit with success only if fseek/fseeko agree.  */\n  int r1 = fseeko (stdin, 0, SEEK_CUR);\n  int r2 = fseek (stdin, 0, SEEK_CUR);\n  ASSERT (r1 == r2 && r1 == expected);\n  if (argc > 1)\n    {\n      /* Test that fseek discards previously read ungetc data.  */\n      int ch = fgetc (stdin);\n      ASSERT (ch == '#');\n      ASSERT (ungetc (ch, stdin) == ch);\n      ASSERT (fseeko (stdin, 2, SEEK_SET) == 0);\n      ch = fgetc (stdin);\n      ASSERT (ch == '/');\n      if (2 < argc)\n        {\n          if (FUNC_UNGETC_BROKEN)\n            {\n              fputs (\"Skipping test: ungetc cannot handle arbitrary bytes\\n\",\n                     stderr);\n              return 77;\n            }\n          /* Test that fseek discards random ungetc data.  */\n          ASSERT (ungetc (ch ^ 0xff, stdin) == (ch ^ 0xff));\n        }\n      ASSERT (fseeko (stdin, 0, SEEK_END) == 0);\n      ASSERT (fgetc (stdin) == EOF);\n      /* Test that fseek resets end-of-file marker.  */\n      ASSERT (feof (stdin));\n      ASSERT (fseeko (stdin, 0, SEEK_END) == 0);\n      ASSERT (!feof (stdin));\n    }\n  return 0;\n}",
      "lines": 39,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-fseeko3.c": {
    "main": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  int do_initial_ftell = atoi (argv[1]);\n  const char *filename = argv[2];\n  FILE *fp = fopen (filename, \"r\");\n  ASSERT (fp != NULL);\n\n  if (do_initial_ftell)\n    {\n      off_t pos = ftell (fp);\n      ASSERT (pos == 0);\n    }\n\n  ASSERT (fseeko (fp, 0, SEEK_END) == 0);\n\n  {\n    off_t pos = ftell (fp);\n    ASSERT (pos > 0);\n  }\n\n  ASSERT (fclose (fp) == 0);\n\n  return 0;\n}",
      "lines": 25,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-fseeko4.c": {
    "main": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  const char *filename = argv[1];\n\n  /* Test that fseeko() sets errno if someone else closes the stream\n     fd behind the back of stdio.  */\n  {\n    FILE *fp = fopen (filename, \"r\");\n    ASSERT (fp != NULL);\n    setvbuf (fp, NULL, _IONBF, 0);\n    ASSERT (ftell (fp) == 0);\n    ASSERT (fseeko (fp, 0, SEEK_END) == 0);\n    ASSERT (ftell (fp) > 0);\n    ASSERT (close (fileno (fp)) == 0);\n    errno = 0;\n    ASSERT (fseeko (fp, 0, SEEK_SET) == -1);\n    ASSERT (errno == EBADF);\n    fclose (fp);\n  }\n\n  /* Test that fseeko() sets errno if the stream was constructed with\n     an invalid file descriptor.  */\n  {\n    FILE *fp = fdopen (-1, \"w\");\n    if (fp != NULL)\n      {\n        errno = 0;\n        ASSERT (fseeko (fp, 0, SEEK_END) == -1);\n        ASSERT (errno == EBADF);\n        fclose (fp);\n      }\n  }\n  {\n    FILE *fp;\n    close (99);\n    fp = fdopen (99, \"w\");\n    if (fp != NULL)\n      {\n        errno = 0;\n        ASSERT (fseeko (fp, 0, SEEK_END) == -1);\n        ASSERT (errno == EBADF);\n        fclose (fp);\n      }\n  }\n\n  return 0;\n}",
      "lines": 48,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-fstat.c": {
    "main": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  /* Test behaviour for invalid file descriptors.  */\n  {\n    struct stat statbuf;\n\n    errno = 0;\n    ASSERT (fstat (-1, &statbuf) == -1);\n    ASSERT (errno == EBADF);\n  }\n  {\n    struct stat statbuf;\n\n    close (99);\n    errno = 0;\n    ASSERT (fstat (99, &statbuf) == -1);\n    ASSERT (errno == EBADF);\n  }\n\n  return 0;\n}",
      "lines": 22,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-fstatat.c": {
    "do_stat": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "static int\ndo_stat (char const *name, struct stat *st)\n{\n#ifdef TEST_STATAT\n  return statat (dfd, name, st);\n#else\n  return fstatat (dfd, name, st, 0);\n#endif\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "do_lstat": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "static int\ndo_lstat (char const *name, struct stat *st)\n{\n#ifdef TEST_STATAT\n  return lstatat (dfd, name, st);\n#else\n  return fstatat (dfd, name, st, AT_SYMLINK_NOFOLLOW);\n#endif\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        110,
        1
      ],
      "content": "int\nmain (int argc _GL_UNUSED, char *argv[])\n{\n  int result;\n\n  set_program_name (argv[0]);\n\n  /* Remove any leftovers from a previous partial run.  */\n  ignore_value (system (\"rm -rf \" BASE \"*\"));\n\n  /* Test behaviour for invalid file descriptors.  */\n  {\n    struct stat statbuf;\n\n    errno = 0;\n    ASSERT (fstatat (-1, \"foo\", &statbuf, 0) == -1);\n    ASSERT (errno == EBADF);\n  }\n  {\n    struct stat statbuf;\n\n    close (99);\n    errno = 0;\n    ASSERT (fstatat (99, \"foo\", &statbuf, 0) == -1);\n    ASSERT (errno == EBADF);\n  }\n\n  result = test_stat_func (do_stat, false);\n  ASSERT (test_lstat_func (do_lstat, false) == result);\n  dfd = open (\".\", O_RDONLY);\n  ASSERT (0 <= dfd);\n  ASSERT (test_stat_func (do_stat, false) == result);\n  ASSERT (test_lstat_func (do_lstat, false) == result);\n  ASSERT (close (dfd) == 0);\n\n  /* FIXME - add additional tests of dfd not at current directory.  */\n\n  if (result == 77)\n    fputs (\"skipping test: symlinks not supported on this file system\\n\",\n           stderr);\n  return result;\n}",
      "lines": 42,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-ftell.c": {
    "main": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        106,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  int ch;\n  /* Assume stdin is seekable iff argc > 1.  */\n  if (argc == 1)\n    {\n      ASSERT (ftell (stdin) == -1);\n      return 0;\n    }\n\n  /* mingw ftell is unreliable on text mode input.  */\n  SET_BINARY (0);\n\n  /* Simple tests.  */\n  ASSERT (ftell (stdin) == 0);\n\n  ch = fgetc (stdin);\n  ASSERT (ch == '#');\n  ASSERT (ftell (stdin) == 1);\n\n  /* Test ftell after ungetc of read input.  */\n  ch = ungetc ('#', stdin);\n  ASSERT (ch == '#');\n  ASSERT (ftell (stdin) == 0);\n\n  ch = fgetc (stdin);\n  ASSERT (ch == '#');\n  ASSERT (ftell (stdin) == 1);\n\n  /* Test ftell after fseek.  */\n  ASSERT (fseek (stdin, 2, SEEK_SET) == 0);\n  ASSERT (ftell (stdin) == 2);\n\n  /* Test ftell after random ungetc.  */\n  ch = fgetc (stdin);\n  ASSERT (ch == '/');\n  ch = ungetc ('@', stdin);\n  ASSERT (ch == '@');\n  ASSERT (ftell (stdin) == 2);\n\n  ch = fgetc (stdin);\n  ASSERT (ch == '@');\n  ASSERT (ftell (stdin) == 3);\n\n  if (2 < argc)\n    {\n      if (FUNC_UNGETC_BROKEN)\n        {\n          fputs (\"Skipping test: ungetc cannot handle arbitrary bytes\\n\",\n                 stderr);\n          return 77;\n        }\n      /* Test ftell after ungetc without read.  */\n      ASSERT (fseek (stdin, 0, SEEK_CUR) == 0);\n      ASSERT (ftell (stdin) == 3);\n\n      ch = ungetc ('~', stdin);\n      ASSERT (ch == '~');\n      ASSERT (ftell (stdin) == 2);\n    }\n\n#if !defined __MINT__ /* FreeMiNT has problems seeking past end of file */\n  /* Test ftell beyond end of file.  */\n  ASSERT (fseek (stdin, 0, SEEK_END) == 0);\n  ch = ftell (stdin);\n  ASSERT (fseek (stdin, 10, SEEK_END) == 0);\n  ASSERT (ftell (stdin) == ch + 10);\n#endif\n\n  return 0;\n}",
      "lines": 72,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-ftell3.c": {
    "main": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "int\nmain (void)\n{\n  FILE *fp;\n\n  /* Create a file with some contents.  */\n  fp = fopen (TESTFILE, \"w\");\n  if (fp == NULL)\n    goto skip;\n  if (fwrite (\"foogarsh\", 1, 8, fp) < 8)\n    goto skip;\n  if (fclose (fp))\n    goto skip;\n\n  /* The file's contents is now \"foogarsh\".  */\n\n  /* Try writing after reading to EOF.  */\n  fp = fopen (TESTFILE, \"r+\");\n  if (fp == NULL)\n    goto skip;\n  if (fseek (fp, -1, SEEK_END))\n    goto skip;\n  ASSERT (getc (fp) == 'h');\n  ASSERT (getc (fp) == EOF);\n  ASSERT (ftell (fp) == 8);\n  ASSERT (ftell (fp) == 8);\n  ASSERT (putc ('!', fp) == '!');\n  ASSERT (ftell (fp) == 9);\n  ASSERT (fclose (fp) == 0);\n  fp = fopen (TESTFILE, \"r\");\n  if (fp == NULL)\n    goto skip;\n  {\n    char buf[10];\n    ASSERT (fread (buf, 1, 10, fp) == 9);\n    ASSERT (memcmp (buf, \"foogarsh!\", 9) == 0);\n  }\n  ASSERT (fclose (fp) == 0);\n\n  /* The file's contents is now \"foogarsh!\".  */\n\n  remove (TESTFILE);\n  return 0;\n\n skip:\n  fprintf (stderr, \"Skipping test: prerequisite file operations failed.\\n\");\n  remove (TESTFILE);\n  return 77;\n}",
      "lines": 49,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-ftello.c": {
    "main": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        117,
        1
      ],
      "content": "int\nmain (int argc, char **argv _GL_UNUSED)\n{\n  int ch;\n  /* Assume stdin is seekable iff argc > 1.  */\n  if (argc == 1)\n    {\n      ASSERT (ftell (stdin) == -1);\n      ASSERT (ftello (stdin) == -1);\n      return 0;\n    }\n\n  /* mingw ftell is unreliable on text mode input.  */\n  SET_BINARY (0);\n\n  /* Simple tests.  For each test, make sure ftell and ftello agree.  */\n  ASSERT (ftell (stdin) == 0);\n  ASSERT (ftello (stdin) == 0);\n\n  ch = fgetc (stdin);\n  ASSERT (ch == '#');\n  ASSERT (ftell (stdin) == 1);\n  ASSERT (ftello (stdin) == 1);\n\n  /* Test ftell after ungetc of read input.  */\n  ch = ungetc ('#', stdin);\n  ASSERT (ch == '#');\n  ASSERT (ftell (stdin) == 0);\n  ASSERT (ftello (stdin) == 0);\n\n  ch = fgetc (stdin);\n  ASSERT (ch == '#');\n  ASSERT (ftell (stdin) == 1);\n  ASSERT (ftello (stdin) == 1);\n\n  /* Test ftell after fseek.  */\n  ASSERT (fseek (stdin, 2, SEEK_SET) == 0);\n  ASSERT (ftell (stdin) == 2);\n  ASSERT (ftello (stdin) == 2);\n\n  /* Test ftell after random ungetc.  */\n  ch = fgetc (stdin);\n  ASSERT (ch == '/');\n  ch = ungetc ('@', stdin);\n  ASSERT (ch == '@');\n  ASSERT (ftell (stdin) == 2);\n  ASSERT (ftello (stdin) == 2);\n\n  ch = fgetc (stdin);\n  ASSERT (ch == '@');\n  ASSERT (ftell (stdin) == 3);\n  ASSERT (ftello (stdin) == 3);\n\n  if (2 < argc)\n    {\n      if (FUNC_UNGETC_BROKEN)\n        {\n          fputs (\"Skipping test: ungetc cannot handle arbitrary bytes\\n\",\n                 stderr);\n          return 77;\n        }\n      /* Test ftell after ungetc without read.  */\n      ASSERT (fseek (stdin, 0, SEEK_CUR) == 0);\n      ASSERT (ftell (stdin) == 3);\n      ASSERT (ftello (stdin) == 3);\n\n      ch = ungetc ('~', stdin);\n      ASSERT (ch == '~');\n      ASSERT (ftell (stdin) == 2);\n      ASSERT (ftello (stdin) == 2);\n    }\n\n#if !defined __MINT__ /* FreeMiNT has problems seeking past end of file */\n  /* Test ftell beyond end of file.  */\n  ASSERT (fseek (stdin, 0, SEEK_END) == 0);\n  ch = ftello (stdin);\n  ASSERT (fseek (stdin, 10, SEEK_END) == 0);\n  ASSERT (ftell (stdin) == ch + 10);\n  ASSERT (ftello (stdin) == ch + 10);\n#endif\n\n  return 0;\n}",
      "lines": 83,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-ftello3.c": {
    "main": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "int\nmain (void)\n{\n  FILE *fp;\n\n  /* Create a file with some contents.  */\n  fp = fopen (TESTFILE, \"w\");\n  if (fp == NULL)\n    goto skip;\n  if (fwrite (\"foogarsh\", 1, 8, fp) < 8)\n    goto skip;\n  if (fclose (fp))\n    goto skip;\n\n  /* The file's contents is now \"foogarsh\".  */\n\n  /* Try writing after reading to EOF.  */\n  fp = fopen (TESTFILE, \"r+\");\n  if (fp == NULL)\n    goto skip;\n  if (fseek (fp, -1, SEEK_END))\n    goto skip;\n  ASSERT (getc (fp) == 'h');\n  ASSERT (getc (fp) == EOF);\n  ASSERT (ftello (fp) == 8);\n  ASSERT (ftello (fp) == 8);\n  ASSERT (putc ('!', fp) == '!');\n  ASSERT (ftello (fp) == 9);\n  ASSERT (fclose (fp) == 0);\n  fp = fopen (TESTFILE, \"r\");\n  if (fp == NULL)\n    goto skip;\n  {\n    char buf[10];\n    ASSERT (fread (buf, 1, 10, fp) == 9);\n    ASSERT (memcmp (buf, \"foogarsh!\", 9) == 0);\n  }\n  ASSERT (fclose (fp) == 0);\n\n  /* The file's contents is now \"foogarsh!\".  */\n\n  remove (TESTFILE);\n  return 0;\n\n skip:\n  fprintf (stderr, \"Skipping test: prerequisite file operations failed.\\n\");\n  remove (TESTFILE);\n  return 77;\n}",
      "lines": 49,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-ftello4.c": {
    "main": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        69,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  const char *filename = argv[1];\n\n  /* Test that ftello() sets errno if someone else closes the stream\n     fd behind the back of stdio.  */\n  {\n    FILE *fp = fopen (filename, \"r\");\n    ASSERT (fp != NULL);\n    setvbuf (fp, NULL, _IONBF, 0);\n    ASSERT (close (fileno (fp)) == 0);\n    errno = 0;\n    ASSERT (ftello (fp) == (off_t)-1);\n    ASSERT (errno == EBADF);\n    fclose (fp);\n  }\n\n  /* Test that ftello() sets errno if the stream was constructed with\n     an invalid file descriptor.  */\n  {\n    FILE *fp = fdopen (-1, \"w\");\n    if (fp != NULL)\n      {\n        errno = 0;\n        ASSERT (ftello (fp) == (off_t)-1);\n        ASSERT (errno == EBADF);\n        fclose (fp);\n      }\n  }\n  {\n    FILE *fp;\n    close (99);\n    fp = fdopen (99, \"w\");\n    if (fp != NULL)\n      {\n        errno = 0;\n        ASSERT (ftello (fp) == (off_t)-1);\n        ASSERT (errno == EBADF);\n        fclose (fp);\n      }\n  }\n\n  return 0;\n}",
      "lines": 45,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-ftruncate.c": {
    "main": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  const char *filename = argv[1];\n\n  /* Test behaviour for invalid file descriptors.  */\n  {\n    errno = 0;\n    ASSERT (ftruncate (-1, 0) == -1);\n    ASSERT (errno == EBADF);\n  }\n  {\n    close (99);\n    errno = 0;\n    ASSERT (ftruncate (99, 0) == -1);\n    ASSERT (errno == EBADF);\n  }\n\n  /* Test behaviour for read-only file descriptors.  */\n  {\n    int fd = open (filename, O_RDONLY);\n    ASSERT (fd >= 0);\n    errno = 0;\n    ASSERT (ftruncate (fd, 0) == -1);\n    ASSERT (errno == EBADF || errno == EINVAL\n            || errno == EACCES /* seen on mingw */\n           );\n    close (fd);\n  }\n\n  return 0;\n}",
      "lines": 32,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-fwrite.c": {
    "main": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  const char *filename = \"test-fwrite.txt\";\n\n  /* We don't have an fwrite() function that installs an invalid parameter\n     handler so far.  So install that handler here, explicitly.  */\n#if HAVE_MSVC_INVALID_PARAMETER_HANDLER \\\n    && MSVC_INVALID_PARAMETER_HANDLING == DEFAULT_HANDLING\n  gl_msvc_inval_ensure_handler ();\n#endif\n\n  /* Test that fwrite() on an unbuffered stream sets errno if someone else\n     closes the stream fd behind the back of stdio.  */\n  {\n    FILE *fp = fopen (filename, \"w\");\n    char buf[5] = \"world\";\n    ASSERT (fp != NULL);\n    setvbuf (fp, NULL, _IONBF, 0);\n    ASSERT (close (fileno (fp)) == 0);\n    errno = 0;\n    ASSERT (fwrite (buf, 1, sizeof (buf), fp) == 0);\n    ASSERT (errno == EBADF);\n    ASSERT (ferror (fp));\n    fclose (fp);\n  }\n\n  /* Test that fwrite() on an unbuffered stream sets errno if the stream\n     was constructed with an invalid file descriptor.  */\n  {\n    FILE *fp = fdopen (-1, \"w\");\n    if (fp != NULL)\n      {\n        char buf[5] = \"world\";\n        setvbuf (fp, NULL, _IONBF, 0);\n        errno = 0;\n        ASSERT (fwrite (buf, 1, sizeof (buf), fp) == 0);\n        ASSERT (errno == EBADF);\n        ASSERT (ferror (fp));\n        fclose (fp);\n      }\n  }\n  {\n    FILE *fp;\n    close (99);\n    fp = fdopen (99, \"w\");\n    if (fp != NULL)\n      {\n        char buf[5] = \"world\";\n        setvbuf (fp, NULL, _IONBF, 0);\n        errno = 0;\n        ASSERT (fwrite (buf, 1, sizeof (buf), fp) == 0);\n        ASSERT (errno == EBADF);\n        ASSERT (ferror (fp));\n        fclose (fp);\n      }\n  }\n\n  /* Clean up.  */\n  unlink (filename);\n\n  return 0;\n}",
      "lines": 63,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-getcwd-lgpl.c": {
    "main": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        101,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  char *pwd1;\n  char *pwd2;\n  /* If the user provides an argument, attempt to chdir there first.  */\n  if (1 < argc)\n    {\n      if (chdir (argv[1]) == 0)\n        printf (\"changed to directory %s\\n\", argv[1]);\n    }\n\n  pwd1 = getcwd (NULL, 0);\n  ASSERT (pwd1 && *pwd1);\n  if (1 < argc)\n    printf (\"cwd=%s\\n\", pwd1);\n\n  /* Make sure the result is usable.  */\n  ASSERT (chdir (pwd1) == 0);\n  ASSERT (chdir (\".//./.\") == 0);\n\n  /* Make sure that result is normalized.  */\n  pwd2 = getcwd (NULL, 0);\n  ASSERT (pwd2);\n  ASSERT (strcmp (pwd1, pwd2) == 0);\n  free (pwd2);\n  {\n    size_t len = strlen (pwd1);\n    ssize_t i = len - 10;\n    if (i < 1)\n      i = 1;\n    pwd2 = getcwd (NULL, len + 1);\n    ASSERT (pwd2);\n    free (pwd2);\n    pwd2 = malloc (len + 2);\n    for ( ; i <= len; i++)\n      {\n        char *tmp;\n        errno = 0;\n        ASSERT (getcwd (pwd2, i) == NULL);\n        ASSERT (errno == ERANGE);\n        /* Allow either glibc or BSD behavior, since POSIX allows both.  */\n        errno = 0;\n        tmp = getcwd (NULL, i);\n        if (tmp)\n          {\n            ASSERT (strcmp (pwd1, tmp) == 0);\n            free (tmp);\n          }\n        else\n          {\n            ASSERT (errno == ERANGE);\n          }\n      }\n    ASSERT (getcwd (pwd2, len + 1) == pwd2);\n    pwd2[len] = '/';\n    pwd2[len + 1] = '\\0';\n  }\n  ASSERT (strstr (pwd2, \"/./\") == NULL);\n  ASSERT (strstr (pwd2, \"/../\") == NULL);\n  ASSERT (strstr (pwd2 + 1 + (pwd2[1] == '/'), \"//\") == NULL);\n\n  /* Validate a POSIX requirement on size.  */\n  errno = 0;\n  ASSERT (getcwd(pwd2, 0) == NULL);\n  ASSERT (errno == EINVAL);\n\n  free (pwd1);\n  free (pwd2);\n\n  return 0;\n}",
      "lines": 72,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-getcwd.c": {
    "test_abort_bug": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        110,
        1
      ],
      "content": "static int\ntest_abort_bug (void)\n{\n  char *cwd;\n  size_t initial_cwd_len;\n  int fail = 0;\n\n  /* The bug is triggered when PATH_MAX < getpagesize (), so skip\n     this relatively expensive and invasive test if that's not true.  */\n#ifdef PATH_MAX\n  int bug_possible = PATH_MAX < getpagesize ();\n#else\n  int bug_possible = 0;\n#endif\n  if (! bug_possible)\n    return 0;\n\n  cwd = getcwd (NULL, 0);\n  if (cwd == NULL)\n    return 2;\n\n  initial_cwd_len = strlen (cwd);\n  free (cwd);\n\n  if (HAVE_OPENAT_SUPPORT)\n    {\n      static char const dir_name[] = \"confdir-14B---\";\n      size_t desired_depth = ((TARGET_LEN - 1 - initial_cwd_len)\n                              / sizeof dir_name);\n      size_t d;\n      for (d = 0; d < desired_depth; d++)\n        {\n          if (mkdir (dir_name, S_IRWXU) < 0 || chdir (dir_name) < 0)\n            {\n              if (! (errno == ERANGE || errno == ENAMETOOLONG\n                     || errno == ENOENT))\n                fail = 3; /* Unable to construct deep hierarchy.  */\n              break;\n            }\n        }\n\n      /* If libc has the bug in question, this invocation of getcwd\n         results in a failed assertion.  */\n      cwd = getcwd (NULL, 0);\n      if (cwd == NULL)\n        fail = 4; /* getcwd didn't assert, but it failed for a long name\n                     where the answer could have been learned.  */\n      free (cwd);\n\n      /* Call rmdir first, in case the above chdir failed.  */\n      rmdir (dir_name);\n      while (0 < d--)\n        {\n          if (chdir (\"..\") < 0)\n            {\n              fail = 5;\n              break;\n            }\n          rmdir (dir_name);\n        }\n    }\n\n  return fail;\n}",
      "lines": 64,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "test_long_name": {
      "start_point": [
        124,
        0
      ],
      "end_point": [
        245,
        1
      ],
      "content": "static int\ntest_long_name (void)\n{\n#ifndef PATH_MAX\n  /* The Hurd doesn't define this, so getcwd can't exhibit the bug --\n     at least not on a local file system.  And if we were to start worrying\n     about remote file systems, we'd have to enable the wrapper function\n     all of the time, just to be safe.  That's not worth the cost.  */\n  return 0;\n#elif ((INT_MAX / (DIR_NAME_SIZE / DOTDOTSLASH_LEN + 1) \\\n        - DIR_NAME_SIZE - BUF_SLOP) \\\n       <= PATH_MAX)\n  /* FIXME: Assuming there's a system for which this is true,\n     this should be done in a compile test.  */\n  return 0;\n#else\n  char buf[PATH_MAX * (DIR_NAME_SIZE / DOTDOTSLASH_LEN + 1)\n           + DIR_NAME_SIZE + BUF_SLOP];\n  char *cwd = getcwd (buf, PATH_MAX);\n  size_t initial_cwd_len;\n  size_t cwd_len;\n  int fail = 0;\n  size_t n_chdirs = 0;\n\n  if (cwd == NULL)\n    return 1;\n\n  cwd_len = initial_cwd_len = strlen (cwd);\n\n  while (1)\n    {\n# ifdef HAVE_GETCWD_SHORTER\n      /* On OS/X <= 10.9 for example, we're restricted to shorter paths\n         as lstat() doesn't support more than PATH_MAX.  */\n      size_t dotdot_max = PATH_MAX * 2;\n# else\n      size_t dotdot_max = PATH_MAX * (DIR_NAME_SIZE / DOTDOTSLASH_LEN);\n# endif\n      char *c = NULL;\n\n      cwd_len += DIR_NAME_SIZE;\n      /* If mkdir or chdir fails, it could be that this system cannot create\n         any file with an absolute name longer than PATH_MAX, such as cygwin.\n         If so, leave fail as 0, because the current working directory can't\n         be too long for getcwd if it can't even be created.  For other\n         errors, be pessimistic and consider that as a failure, too.  */\n      if (mkdir (DIR_NAME, S_IRWXU) < 0 || chdir (DIR_NAME) < 0)\n        {\n          if (! (errno == ERANGE || errno == ENAMETOOLONG || errno == ENOENT))\n            fail = 2;\n          break;\n        }\n\n      if (PATH_MAX <= cwd_len && cwd_len < PATH_MAX + DIR_NAME_SIZE)\n        {\n          c = getcwd (buf, PATH_MAX);\n          if (!c && errno == ENOENT)\n            {\n              fail = 3;\n              break;\n            }\n          if (c)\n            {\n              fail = 4;\n              break;\n            }\n          if (! (errno == ERANGE || errno == ENAMETOOLONG))\n            {\n              fail = 5;\n              break;\n            }\n        }\n\n      if (dotdot_max <= cwd_len - initial_cwd_len)\n        {\n          if (dotdot_max + DIR_NAME_SIZE < cwd_len - initial_cwd_len)\n            break;\n          c = getcwd (buf, cwd_len + 1);\n          if (!c)\n            {\n              if (! (errno == ERANGE || errno == ENOENT\n                     || errno == ENAMETOOLONG))\n                {\n                  fail = 6;\n                  break;\n                }\n              if (HAVE_OPENAT_SUPPORT || errno == ERANGE || errno == ENOENT)\n                {\n                  fail = 7;\n                  break;\n                }\n            }\n        }\n\n      if (c && strlen (c) != cwd_len)\n        {\n          fail = 8;\n          break;\n        }\n      ++n_chdirs;\n    }\n\n  /* Leaving behind such a deep directory is not polite.\n     So clean up here, right away, even though the driving\n     shell script would also clean up.  */\n  {\n    size_t i;\n\n    /* Try rmdir first, in case the chdir failed.  */\n    rmdir (DIR_NAME);\n    for (i = 0; i <= n_chdirs; i++)\n      {\n        if (chdir (\"..\") < 0)\n          break;\n        if (rmdir (DIR_NAME) != 0)\n          break;\n      }\n  }\n\n  return fail;\n#endif\n}",
      "lines": 122,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        247,
        0
      ],
      "end_point": [
        251,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  return test_abort_bug () * 10 + test_long_name ();\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-getdelim.c": {
    "main": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "int\nmain (void)\n{\n  FILE *f;\n  char *line;\n  size_t len;\n  ssize_t result;\n\n  /* Create test file.  */\n  f = fopen (\"test-getdelim.txt\", \"wb\");\n  if (!f || fwrite (\"anAnbcnd\\0f\", 1, 10, f) != 10 || fclose (f) != 0)\n    {\n      fputs (\"Failed to create sample file.\\n\", stderr);\n      remove (\"test-getdelim.txt\");\n      return 1;\n    }\n  f = fopen (\"test-getdelim.txt\", \"rb\");\n  if (!f)\n    {\n      fputs (\"Failed to reopen sample file.\\n\", stderr);\n      remove (\"test-getdelim.txt\");\n      return 1;\n    }\n\n  /* Test initial allocation, which must include trailing NUL.  */\n  line = NULL;\n  len = 0;\n  result = getdelim (&line, &len, 'n', f);\n  ASSERT (result == 2);\n  ASSERT (strcmp (line, \"an\") == 0);\n  ASSERT (2 < len);\n  free (line);\n\n  /* Test initial allocation again, with line = NULL and len != 0.  */\n  line = NULL;\n  len = (size_t)(~0) / 4;\n  result = getdelim (&line, &len, 'n', f);\n  ASSERT (result == 2);\n  ASSERT (strcmp (line, \"An\") == 0);\n  ASSERT (2 < len);\n  free (line);\n\n  /* Test growth of buffer.  */\n  line = malloc (1);\n  len = 1;\n  result = getdelim (&line, &len, 'n', f);\n  ASSERT (result == 3);\n  ASSERT (strcmp (line, \"bcn\") == 0);\n  ASSERT (3 < len);\n\n  /* Test embedded NULs and EOF behavior.  */\n  result = getdelim (&line, &len, 'n', f);\n  ASSERT (result == 3);\n  ASSERT (memcmp (line, \"d\\0f\", 4) == 0);\n  ASSERT (3 < len);\n\n  result = getdelim (&line, &len, 'n', f);\n  ASSERT (result == -1);\n\n  free (line);\n  fclose (f);\n  remove (\"test-getdelim.txt\");\n  return 0;\n}",
      "lines": 64,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-getdtablesize.c": {
    "main": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        35,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  ASSERT (getdtablesize () >= 3);\n  ASSERT (dup2 (0, getdtablesize() - 1) == getdtablesize () - 1);\n  ASSERT (dup2 (0, getdtablesize()) == -1);\n\n  return 0;\n}",
      "lines": 9,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-getgroups.c": {
    "main": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "int\nmain (int argc, char **argv _GL_UNUSED)\n{\n  int result;\n  gid_t *groups;\n\n  errno = 0;\n  result = getgroups (0, NULL);\n  if (result == -1 && errno == ENOSYS)\n    {\n      fputs (\"skipping test: no support for groups\\n\", stderr);\n      return 77;\n    }\n  ASSERT (0 <= result);\n  ASSERT (result + 1 < SIZE_MAX / sizeof *groups);\n  groups = malloc ((result + 1) * sizeof *groups);\n  ASSERT (groups);\n  groups[result] = -1;\n  /* Check for EINVAL handling.  Not all processes have supplemental\n     groups, and getgroups does not have to return the effective gid,\n     so a result of 0 is reasonable.  Also, we can't test for EINVAL\n     if result is 1, because of how getgroups treats 0.  */\n  if (1 < result)\n    {\n      errno = 0;\n      ASSERT (getgroups (result - 1, groups) == -1);\n      ASSERT (errno == EINVAL);\n    }\n  ASSERT (getgroups (result, groups) == result);\n  ASSERT (getgroups (result + 1, groups) == result);\n  ASSERT (groups[result] == -1);\n  errno = 0;\n  ASSERT (getgroups (-1, NULL) == -1);\n  ASSERT (errno == EINVAL);\n\n  /* The automated unit test, with no arguments, ends here.  However,\n     for debugging purposes, you can pass a command-line argument to\n     list the returned groups.  */\n  if (1 < argc)\n    {\n      int i;\n      for (i = 0; i < result; i++)\n        printf (\"%d\\n\", (int) groups[i]);\n    }\n  return 0;\n}",
      "lines": 46,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-gethostname.c": {
    "main": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "int\nmain (int argc, char *argv[] _GL_UNUSED)\n{\n  char buf[HOST_NAME_MAX];\n  int rc;\n\n  if (strlen (NOHOSTNAME) >= HOST_NAME_MAX)\n    {\n      printf (\"HOST_NAME_MAX impossibly small?! %d\\n\", HOST_NAME_MAX);\n      return 2;\n    }\n\n  strcpy (buf, NOHOSTNAME);\n\n  rc = gethostname (buf, sizeof (buf));\n\n  if (rc != 0)\n    {\n      printf (\"gethostname failed, rc %d errno %d\\n\", rc, errno);\n      return 1;\n    }\n\n  if (strcmp (buf, NOHOSTNAME) == 0)\n    {\n      printf (\"gethostname left buffer untouched.\\n\");\n      return 1;\n    }\n\n  if (argc > 1)\n    printf (\"hostname: %s\\n\", buf);\n\n  return 0;\n}",
      "lines": 33,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-getline.c": {
    "main": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "int\nmain (void)\n{\n  FILE *f;\n  char *line;\n  size_t len;\n  ssize_t result;\n\n  /* Create test file.  */\n  f = fopen (\"test-getline.txt\", \"wb\");\n  if (!f || fwrite (\"a\\nA\\nbc\\nd\\0f\", 1, 10, f) != 10 || fclose (f) != 0)\n    {\n      fputs (\"Failed to create sample file.\\n\", stderr);\n      remove (\"test-getline.txt\");\n      return 1;\n    }\n  f = fopen (\"test-getline.txt\", \"rb\");\n  if (!f)\n    {\n      fputs (\"Failed to reopen sample file.\\n\", stderr);\n      remove (\"test-getline.txt\");\n      return 1;\n    }\n\n  /* Test initial allocation, which must include trailing NUL.  */\n  line = NULL;\n  len = 0;\n  result = getline (&line, &len, f);\n  ASSERT (result == 2);\n  ASSERT (strcmp (line, \"a\\n\") == 0);\n  ASSERT (2 < len);\n  free (line);\n\n  /* Test initial allocation again, with line = NULL and len != 0.  */\n  line = NULL;\n  len = (size_t)(~0) / 4;\n  result = getline (&line, &len, f);\n  ASSERT (result == 2);\n  ASSERT (strcmp (line, \"A\\n\") == 0);\n  ASSERT (2 < len);\n  free (line);\n\n  /* Test growth of buffer, must not leak.  */\n  line = malloc (1);\n  len = 0;\n  result = getline (&line, &len, f);\n  ASSERT (result == 3);\n  ASSERT (strcmp (line, \"bc\\n\") == 0);\n  ASSERT (3 < len);\n\n  /* Test embedded NULs and EOF behavior.  */\n  result = getline (&line, &len, f);\n  ASSERT (result == 3);\n  ASSERT (memcmp (line, \"d\\0f\", 4) == 0);\n  ASSERT (3 < len);\n\n  result = getline (&line, &len, f);\n  ASSERT (result == -1);\n\n  free (line);\n  fclose (f);\n  remove (\"test-getline.txt\");\n  return 0;\n}",
      "lines": 64,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-getopt.c": {
    "main": {
      "start_point": [
        64,
        0
      ],
      "end_point": [
        98,
        1
      ],
      "content": "int\nmain (void)\n{\n   /* This test validates that stderr is used correctly, so move the\n      original into fd 10.  */\n  if (dup2 (STDERR_FILENO, BACKUP_STDERR_FILENO) != BACKUP_STDERR_FILENO\n      || (myerr = fdopen (BACKUP_STDERR_FILENO, \"w\")) == NULL)\n    return 2;\n\n  ASSERT (freopen (\"test-getopt.tmp\", \"w\", stderr) == stderr);\n\n  /* These default values are required by POSIX.  */\n  ASSERT (optind == 1);\n  ASSERT (opterr != 0);\n\n  setenv (\"POSIXLY_CORRECT\", \"1\", 1);\n  test_getopt ();\n\n#if GNULIB_TEST_GETOPT_GNU\n  test_getopt_long_posix ();\n#endif\n\n  unsetenv (\"POSIXLY_CORRECT\");\n  test_getopt ();\n\n#if GNULIB_TEST_GETOPT_GNU\n  test_getopt_long ();\n  test_getopt_long_only ();\n#endif\n\n  ASSERT (fclose (stderr) == 0);\n  ASSERT (remove (\"test-getopt.tmp\") == 0);\n\n  return 0;\n}",
      "lines": 35,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-getopt.h": {
    "getopt_loop": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "static void\ngetopt_loop (int argc, const char **argv,\n             const char *options,\n             int *a_seen, int *b_seen,\n             const char **p_value, const char **q_value,\n             int *non_options_count, const char **non_options,\n             int *unrecognized, bool *message_issued)\n{\n  int c;\n  int pos = ftell (stderr);\n\n  while ((c = getopt (argc, (char **) argv, options)) != -1)\n    {\n      switch (c)\n        {\n        case 'a':\n          (*a_seen)++;\n          break;\n        case 'b':\n          (*b_seen)++;\n          break;\n        case 'p':\n          *p_value = optarg;\n          break;\n        case 'q':\n          *q_value = optarg;\n          break;\n        case '\\1':\n          /* Must only happen with option '-' at the beginning.  */\n          ASSERT (options[0] == '-');\n          non_options[(*non_options_count)++] = optarg;\n          break;\n        case ':':\n          /* Must only happen with option ':' at the beginning.  */\n          ASSERT (options[0] == ':'\n                  || ((options[0] == '-' || options[0] == '+')\n                      && options[1] == ':'));\n          /* fall through */\n        case '?':\n          *unrecognized = optopt;\n          break;\n        default:\n          *unrecognized = c;\n          break;\n        }\n    }\n\n  *message_issued = pos < ftell (stderr);\n}",
      "lines": 49,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_getopt": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        1390,
        1
      ],
      "content": "static void\ntest_getopt (void)\n{\n  int start;\n  bool posixly = !!getenv (\"POSIXLY_CORRECT\");\n  /* See comment in getopt.c:\n     glibc gets a LSB-compliant getopt.\n     Standalone applications get a POSIX-compliant getopt.  */\n#if defined __GETOPT_PREFIX || !(__GLIBC__ >= 2 || defined __MINGW32__)\n  /* Using getopt from gnulib or from a non-glibc system.  */\n  posixly = true;\n#endif\n\n  /* Test processing of boolean options.  */\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[10];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 1;\n      getopt_loop (argc, argv, \"ab\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 2);\n      ASSERT (!output);\n    }\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[10];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-b\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 1;\n      getopt_loop (argc, argv, \"ab\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 1);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 3);\n      ASSERT (!output);\n    }\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[10];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-ba\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 1;\n      getopt_loop (argc, argv, \"ab\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 1);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 2);\n      ASSERT (!output);\n    }\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[10];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-ab\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 1;\n      getopt_loop (argc, argv, \"ab\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      ASSERT (a_seen == 2);\n      ASSERT (b_seen == 1);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 3);\n      ASSERT (!output);\n    }\n\n  /* Test processing of options with arguments.  */\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[10];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-pfoo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 1;\n      getopt_loop (argc, argv, \"p:q:\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"foo\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 2);\n      ASSERT (!output);\n    }\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[10];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 1;\n      getopt_loop (argc, argv, \"p:q:\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"foo\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 3);\n      ASSERT (!output);\n    }\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[10];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-ab\";\n      argv[argc++] = \"-q\";\n      argv[argc++] = \"baz\";\n      argv[argc++] = \"-pfoo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 1;\n      getopt_loop (argc, argv, \"abp:q:\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 1);\n      ASSERT (p_value != NULL && strcmp (p_value, \"foo\") == 0);\n      ASSERT (q_value != NULL && strcmp (q_value, \"baz\") == 0);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 5);\n      ASSERT (!output);\n    }\n\n#if GNULIB_TEST_GETOPT_GNU\n  /* Test processing of options with optional arguments.  */\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[10];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-pfoo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 1;\n      getopt_loop (argc, argv, \"p::q::\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"foo\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 2);\n      ASSERT (!output);\n    }\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[10];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 1;\n      getopt_loop (argc, argv, \"p::q::\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 2);\n      ASSERT (!output);\n    }\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[10];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 1;\n      getopt_loop (argc, argv, \"abp::q::\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 3);\n      ASSERT (!output);\n    }\n#endif /* GNULIB_TEST_GETOPT_GNU */\n\n  /* Check that invalid options are recognized; and that both opterr\n     and leading ':' can silence output.  */\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[10];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"-x\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 42;\n      getopt_loop (argc, argv, \"abp:q:\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"foo\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 'x');\n      ASSERT (optind == 5);\n      ASSERT (output);\n    }\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[10];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"-x\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 0;\n      getopt_loop (argc, argv, \"abp:q:\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"foo\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 'x');\n      ASSERT (optind == 5);\n      ASSERT (!output);\n    }\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[10];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"-x\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 1;\n      getopt_loop (argc, argv, \":abp:q:\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"foo\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 'x');\n      ASSERT (optind == 5);\n      ASSERT (!output);\n    }\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[10];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"-:\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 42;\n      getopt_loop (argc, argv, \"abp:q:\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"foo\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == ':');\n      ASSERT (optind == 5);\n      ASSERT (output);\n    }\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[10];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"-:\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 0;\n      getopt_loop (argc, argv, \"abp:q:\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"foo\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == ':');\n      ASSERT (optind == 5);\n      ASSERT (!output);\n    }\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[10];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"-:\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 1;\n      getopt_loop (argc, argv, \":abp:q:\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"foo\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == ':');\n      ASSERT (optind == 5);\n      ASSERT (!output);\n    }\n\n  /* Check for missing argument behavior.  */\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[10];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-ap\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 1;\n      getopt_loop (argc, argv, \"abp:q:\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 'p');\n      ASSERT (optind == 2);\n      ASSERT (output);\n    }\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[10];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-ap\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 0;\n      getopt_loop (argc, argv, \"abp:q:\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 'p');\n      ASSERT (optind == 2);\n      ASSERT (!output);\n    }\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[10];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-ap\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 1;\n      getopt_loop (argc, argv, \":abp:q:\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 'p');\n      ASSERT (optind == 2);\n      ASSERT (!output);\n    }\n\n  /* Check that by default, non-options arguments are moved to the end.  */\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[10];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"donald\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"billy\";\n      argv[argc++] = \"duck\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 1;\n      getopt_loop (argc, argv, \"abp:q:\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      if (posixly)\n        {\n          ASSERT (strcmp (argv[0], \"program\") == 0);\n          ASSERT (strcmp (argv[1], \"donald\") == 0);\n          ASSERT (strcmp (argv[2], \"-p\") == 0);\n          ASSERT (strcmp (argv[3], \"billy\") == 0);\n          ASSERT (strcmp (argv[4], \"duck\") == 0);\n          ASSERT (strcmp (argv[5], \"-a\") == 0);\n          ASSERT (strcmp (argv[6], \"bar\") == 0);\n          ASSERT (argv[7] == NULL);\n          ASSERT (a_seen == 0);\n          ASSERT (b_seen == 0);\n          ASSERT (p_value == NULL);\n          ASSERT (q_value == NULL);\n          ASSERT (non_options_count == 0);\n          ASSERT (unrecognized == 0);\n          ASSERT (optind == 1);\n          ASSERT (!output);\n        }\n      else\n        {\n          ASSERT (strcmp (argv[0], \"program\") == 0);\n          ASSERT (strcmp (argv[1], \"-p\") == 0);\n          ASSERT (strcmp (argv[2], \"billy\") == 0);\n          ASSERT (strcmp (argv[3], \"-a\") == 0);\n          ASSERT (strcmp (argv[4], \"donald\") == 0);\n          ASSERT (strcmp (argv[5], \"duck\") == 0);\n          ASSERT (strcmp (argv[6], \"bar\") == 0);\n          ASSERT (argv[7] == NULL);\n          ASSERT (a_seen == 1);\n          ASSERT (b_seen == 0);\n          ASSERT (p_value != NULL && strcmp (p_value, \"billy\") == 0);\n          ASSERT (q_value == NULL);\n          ASSERT (non_options_count == 0);\n          ASSERT (unrecognized == 0);\n          ASSERT (optind == 4);\n          ASSERT (!output);\n        }\n    }\n\n  /* Check that '--' ends the argument processing.  */\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[20];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"donald\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"billy\";\n      argv[argc++] = \"duck\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"--\";\n      argv[argc++] = \"-b\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"-q\";\n      argv[argc++] = \"johnny\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 1;\n      getopt_loop (argc, argv, \"abp:q:\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      if (posixly)\n        {\n          ASSERT (strcmp (argv[0], \"program\") == 0);\n          ASSERT (strcmp (argv[1], \"donald\") == 0);\n          ASSERT (strcmp (argv[2], \"-p\") == 0);\n          ASSERT (strcmp (argv[3], \"billy\") == 0);\n          ASSERT (strcmp (argv[4], \"duck\") == 0);\n          ASSERT (strcmp (argv[5], \"-a\") == 0);\n          ASSERT (strcmp (argv[6], \"--\") == 0);\n          ASSERT (strcmp (argv[7], \"-b\") == 0);\n          ASSERT (strcmp (argv[8], \"foo\") == 0);\n          ASSERT (strcmp (argv[9], \"-q\") == 0);\n          ASSERT (strcmp (argv[10], \"johnny\") == 0);\n          ASSERT (strcmp (argv[11], \"bar\") == 0);\n          ASSERT (argv[12] == NULL);\n          ASSERT (a_seen == 0);\n          ASSERT (b_seen == 0);\n          ASSERT (p_value == NULL);\n          ASSERT (q_value == NULL);\n          ASSERT (non_options_count == 0);\n          ASSERT (unrecognized == 0);\n          ASSERT (optind == 1);\n          ASSERT (!output);\n        }\n      else\n        {\n          ASSERT (strcmp (argv[0], \"program\") == 0);\n          ASSERT (strcmp (argv[1], \"-p\") == 0);\n          ASSERT (strcmp (argv[2], \"billy\") == 0);\n          ASSERT (strcmp (argv[3], \"-a\") == 0);\n          ASSERT (strcmp (argv[4], \"--\") == 0);\n          ASSERT (strcmp (argv[5], \"donald\") == 0);\n          ASSERT (strcmp (argv[6], \"duck\") == 0);\n          ASSERT (strcmp (argv[7], \"-b\") == 0);\n          ASSERT (strcmp (argv[8], \"foo\") == 0);\n          ASSERT (strcmp (argv[9], \"-q\") == 0);\n          ASSERT (strcmp (argv[10], \"johnny\") == 0);\n          ASSERT (strcmp (argv[11], \"bar\") == 0);\n          ASSERT (argv[12] == NULL);\n          ASSERT (a_seen == 1);\n          ASSERT (b_seen == 0);\n          ASSERT (p_value != NULL && strcmp (p_value, \"billy\") == 0);\n          ASSERT (q_value == NULL);\n          ASSERT (non_options_count == 0);\n          ASSERT (unrecognized == 0);\n          ASSERT (optind == 5);\n          ASSERT (!output);\n        }\n    }\n\n#if GNULIB_TEST_GETOPT_GNU\n  /* Check that the '-' flag causes non-options to be returned in order.  */\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[10];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"donald\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"billy\";\n      argv[argc++] = \"duck\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 1;\n      getopt_loop (argc, argv, \"-abp:q:\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      ASSERT (strcmp (argv[0], \"program\") == 0);\n      ASSERT (strcmp (argv[1], \"donald\") == 0);\n      ASSERT (strcmp (argv[2], \"-p\") == 0);\n      ASSERT (strcmp (argv[3], \"billy\") == 0);\n      ASSERT (strcmp (argv[4], \"duck\") == 0);\n      ASSERT (strcmp (argv[5], \"-a\") == 0);\n      ASSERT (strcmp (argv[6], \"bar\") == 0);\n      ASSERT (argv[7] == NULL);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"billy\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 3);\n      ASSERT (strcmp (non_options[0], \"donald\") == 0);\n      ASSERT (strcmp (non_options[1], \"duck\") == 0);\n      ASSERT (strcmp (non_options[2], \"bar\") == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 7);\n      ASSERT (!output);\n    }\n\n  /* Check that '--' ends the argument processing.  */\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[20];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"donald\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"billy\";\n      argv[argc++] = \"duck\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"--\";\n      argv[argc++] = \"-b\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"-q\";\n      argv[argc++] = \"johnny\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 1;\n      getopt_loop (argc, argv, \"-abp:q:\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      ASSERT (strcmp (argv[0], \"program\") == 0);\n      ASSERT (strcmp (argv[1], \"donald\") == 0);\n      ASSERT (strcmp (argv[2], \"-p\") == 0);\n      ASSERT (strcmp (argv[3], \"billy\") == 0);\n      ASSERT (strcmp (argv[4], \"duck\") == 0);\n      ASSERT (strcmp (argv[5], \"-a\") == 0);\n      ASSERT (strcmp (argv[6], \"--\") == 0);\n      ASSERT (strcmp (argv[7], \"-b\") == 0);\n      ASSERT (strcmp (argv[8], \"foo\") == 0);\n      ASSERT (strcmp (argv[9], \"-q\") == 0);\n      ASSERT (strcmp (argv[10], \"johnny\") == 0);\n      ASSERT (strcmp (argv[11], \"bar\") == 0);\n      ASSERT (argv[12] == NULL);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"billy\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (!output);\n      if (non_options_count == 2)\n        {\n          /* glibc behaviour.  */\n          ASSERT (non_options_count == 2);\n          ASSERT (strcmp (non_options[0], \"donald\") == 0);\n          ASSERT (strcmp (non_options[1], \"duck\") == 0);\n          ASSERT (unrecognized == 0);\n          ASSERT (optind == 7);\n        }\n      else\n        {\n          /* Another valid behaviour.  */\n          ASSERT (non_options_count == 7);\n          ASSERT (strcmp (non_options[0], \"donald\") == 0);\n          ASSERT (strcmp (non_options[1], \"duck\") == 0);\n          ASSERT (strcmp (non_options[2], \"-b\") == 0);\n          ASSERT (strcmp (non_options[3], \"foo\") == 0);\n          ASSERT (strcmp (non_options[4], \"-q\") == 0);\n          ASSERT (strcmp (non_options[5], \"johnny\") == 0);\n          ASSERT (strcmp (non_options[6], \"bar\") == 0);\n          ASSERT (unrecognized == 0);\n          ASSERT (optind == 12);\n        }\n    }\n\n  /* Check that the '-' flag has to come first.  */\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[10];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"donald\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"billy\";\n      argv[argc++] = \"duck\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 1;\n      getopt_loop (argc, argv, \"abp:q:-\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      if (posixly)\n        {\n          ASSERT (strcmp (argv[0], \"program\") == 0);\n          ASSERT (strcmp (argv[1], \"donald\") == 0);\n          ASSERT (strcmp (argv[2], \"-p\") == 0);\n          ASSERT (strcmp (argv[3], \"billy\") == 0);\n          ASSERT (strcmp (argv[4], \"duck\") == 0);\n          ASSERT (strcmp (argv[5], \"-a\") == 0);\n          ASSERT (strcmp (argv[6], \"bar\") == 0);\n          ASSERT (argv[7] == NULL);\n          ASSERT (a_seen == 0);\n          ASSERT (b_seen == 0);\n          ASSERT (p_value == NULL);\n          ASSERT (q_value == NULL);\n          ASSERT (non_options_count == 0);\n          ASSERT (unrecognized == 0);\n          ASSERT (optind == 1);\n          ASSERT (!output);\n        }\n      else\n        {\n          ASSERT (strcmp (argv[0], \"program\") == 0);\n          ASSERT (strcmp (argv[1], \"-p\") == 0);\n          ASSERT (strcmp (argv[2], \"billy\") == 0);\n          ASSERT (strcmp (argv[3], \"-a\") == 0);\n          ASSERT (strcmp (argv[4], \"donald\") == 0);\n          ASSERT (strcmp (argv[5], \"duck\") == 0);\n          ASSERT (strcmp (argv[6], \"bar\") == 0);\n          ASSERT (argv[7] == NULL);\n          ASSERT (a_seen == 1);\n          ASSERT (b_seen == 0);\n          ASSERT (p_value != NULL && strcmp (p_value, \"billy\") == 0);\n          ASSERT (q_value == NULL);\n          ASSERT (non_options_count == 0);\n          ASSERT (unrecognized == 0);\n          ASSERT (optind == 4);\n          ASSERT (!output);\n        }\n    }\n\n  /* Check that the '+' flag causes the first non-option to terminate the\n     loop.  */\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[10];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"donald\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"billy\";\n      argv[argc++] = \"duck\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 1;\n      getopt_loop (argc, argv, \"+abp:q:\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      ASSERT (strcmp (argv[0], \"program\") == 0);\n      ASSERT (strcmp (argv[1], \"donald\") == 0);\n      ASSERT (strcmp (argv[2], \"-p\") == 0);\n      ASSERT (strcmp (argv[3], \"billy\") == 0);\n      ASSERT (strcmp (argv[4], \"duck\") == 0);\n      ASSERT (strcmp (argv[5], \"-a\") == 0);\n      ASSERT (strcmp (argv[6], \"bar\") == 0);\n      ASSERT (argv[7] == NULL);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 1);\n      ASSERT (!output);\n    }\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[10];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-+\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_loop (argc, argv, \"+abp:q:\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == '+');\n      ASSERT (optind == 2);\n      ASSERT (output);\n    }\n\n  /* Check that '--' ends the argument processing.  */\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[20];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"donald\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"billy\";\n      argv[argc++] = \"duck\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"--\";\n      argv[argc++] = \"-b\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"-q\";\n      argv[argc++] = \"johnny\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 1;\n      getopt_loop (argc, argv, \"+abp:q:\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      ASSERT (strcmp (argv[0], \"program\") == 0);\n      ASSERT (strcmp (argv[1], \"donald\") == 0);\n      ASSERT (strcmp (argv[2], \"-p\") == 0);\n      ASSERT (strcmp (argv[3], \"billy\") == 0);\n      ASSERT (strcmp (argv[4], \"duck\") == 0);\n      ASSERT (strcmp (argv[5], \"-a\") == 0);\n      ASSERT (strcmp (argv[6], \"--\") == 0);\n      ASSERT (strcmp (argv[7], \"-b\") == 0);\n      ASSERT (strcmp (argv[8], \"foo\") == 0);\n      ASSERT (strcmp (argv[9], \"-q\") == 0);\n      ASSERT (strcmp (argv[10], \"johnny\") == 0);\n      ASSERT (strcmp (argv[11], \"bar\") == 0);\n      ASSERT (argv[12] == NULL);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 1);\n      ASSERT (!output);\n    }\n#endif /* GNULIB_TEST_GETOPT_GNU */\n\n  /* Check that the '+' flag has to come first.  */\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[10];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"donald\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"billy\";\n      argv[argc++] = \"duck\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 1;\n      getopt_loop (argc, argv, \"abp:q:+\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      if (posixly)\n        {\n          ASSERT (strcmp (argv[0], \"program\") == 0);\n          ASSERT (strcmp (argv[1], \"donald\") == 0);\n          ASSERT (strcmp (argv[2], \"-p\") == 0);\n          ASSERT (strcmp (argv[3], \"billy\") == 0);\n          ASSERT (strcmp (argv[4], \"duck\") == 0);\n          ASSERT (strcmp (argv[5], \"-a\") == 0);\n          ASSERT (strcmp (argv[6], \"bar\") == 0);\n          ASSERT (argv[7] == NULL);\n          ASSERT (a_seen == 0);\n          ASSERT (b_seen == 0);\n          ASSERT (p_value == NULL);\n          ASSERT (q_value == NULL);\n          ASSERT (non_options_count == 0);\n          ASSERT (unrecognized == 0);\n          ASSERT (optind == 1);\n          ASSERT (!output);\n        }\n      else\n        {\n          ASSERT (strcmp (argv[0], \"program\") == 0);\n          ASSERT (strcmp (argv[1], \"-p\") == 0);\n          ASSERT (strcmp (argv[2], \"billy\") == 0);\n          ASSERT (strcmp (argv[3], \"-a\") == 0);\n          ASSERT (strcmp (argv[4], \"donald\") == 0);\n          ASSERT (strcmp (argv[5], \"duck\") == 0);\n          ASSERT (strcmp (argv[6], \"bar\") == 0);\n          ASSERT (argv[7] == NULL);\n          ASSERT (a_seen == 1);\n          ASSERT (b_seen == 0);\n          ASSERT (p_value != NULL && strcmp (p_value, \"billy\") == 0);\n          ASSERT (q_value == NULL);\n          ASSERT (non_options_count == 0);\n          ASSERT (unrecognized == 0);\n          ASSERT (optind == 4);\n          ASSERT (!output);\n        }\n    }\n\n#if GNULIB_TEST_GETOPT_GNU\n  /* If GNU extensions are supported, require compliance with POSIX\n     interpretation on leading '+' behavior.\n     http://austingroupbugs.net/view.php?id=191  */\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[10];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"donald\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"billy\";\n      argv[argc++] = \"duck\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 1;\n      getopt_loop (argc, argv, \"+:abp:q:\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      ASSERT (strcmp (argv[0], \"program\") == 0);\n      ASSERT (strcmp (argv[1], \"donald\") == 0);\n      ASSERT (strcmp (argv[2], \"-p\") == 0);\n      ASSERT (strcmp (argv[3], \"billy\") == 0);\n      ASSERT (strcmp (argv[4], \"duck\") == 0);\n      ASSERT (strcmp (argv[5], \"-a\") == 0);\n      ASSERT (strcmp (argv[6], \"bar\") == 0);\n      ASSERT (argv[7] == NULL);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 1);\n      ASSERT (!output);\n    }\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[10];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-p\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_loop (argc, argv, \"+:abp:q:\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 'p');\n      ASSERT (optind == 2);\n      ASSERT (!output);\n    }\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int a_seen = 0;\n      int b_seen = 0;\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      bool output;\n      int argc = 0;\n      const char *argv[10];\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-b\";\n      argv[argc++] = \"-p\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_loop (argc, argv, \"+:abp:q:\",\n                   &a_seen, &b_seen, &p_value, &q_value,\n                   &non_options_count, non_options, &unrecognized, &output);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 1);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 'p');\n      ASSERT (optind == 3);\n      ASSERT (!output);\n    }\n\n  /* Check that 'W' does not dump core:\n     http://sourceware.org/bugzilla/show_bug.cgi?id=12922\n     Technically, POSIX says the presence of ';' in the opt-string\n     gives unspecified behavior, so we only test this when GNU compliance\n     is desired.  */\n  for (start = OPTIND_MIN; start <= 1; start++)\n    {\n      int argc = 0;\n      const char *argv[10];\n      int pos = ftell (stderr);\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-W\";\n      argv[argc++] = \"dummy\";\n      argv[argc] = NULL;\n      optind = start;\n      opterr = 1;\n      ASSERT (getopt (argc, (char **) argv, \"W;\") == 'W');\n      ASSERT (ftell (stderr) == pos);\n      ASSERT (optind == 2);\n    }\n#endif /* GNULIB_TEST_GETOPT_GNU */\n}",
      "lines": 1310,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-getopt_long.h": {
    "getopt_long_loop": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        98,
        1
      ],
      "content": "static void\ngetopt_long_loop (int argc, const char **argv,\n                  const char *options, const struct option *long_options,\n                  const char **p_value, const char **q_value,\n                  int *non_options_count, const char **non_options,\n                  int *unrecognized)\n{\n  int option_index = -1;\n  int c;\n\n  opterr = 0;\n  q_seen = 0;\n  while ((c = getopt_long (argc, (char **) argv, options, long_options,\n                           &option_index))\n         != -1)\n    {\n      switch (c)\n        {\n        case 0:\n          /* An option with a non-NULL flag pointer was processed.  */\n          if (q_seen)\n            *q_value = optarg;\n          break;\n        case 'a':\n          a_seen++;\n          break;\n        case 'b':\n          b_seen = 1;\n          break;\n        case 'p':\n          *p_value = optarg;\n          break;\n        case 'q':\n          *q_value = optarg;\n          break;\n        case '\\1':\n          /* Must only happen with option '-' at the beginning.  */\n          ASSERT (options[0] == '-');\n          non_options[(*non_options_count)++] = optarg;\n          break;\n        case ':':\n          /* Must only happen with option ':' at the beginning.  */\n          ASSERT (options[0] == ':'\n                  || ((options[0] == '-' || options[0] == '+')\n                      && options[1] == ':'));\n          /* fall through */\n        case '?':\n          *unrecognized = optopt;\n          break;\n        default:\n          *unrecognized = c;\n          break;\n        }\n    }\n}",
      "lines": 55,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "do_getopt_long": {
      "start_point": [
        103,
        0
      ],
      "end_point": [
        108,
        1
      ],
      "content": "static int\ndo_getopt_long (int argc, const char **argv, const char *shortopts,\n                const struct option *longopts, int *longind)\n{\n  return getopt_long (argc, (char **) argv, shortopts, longopts, longind);\n}",
      "lines": 6,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "test_getopt_long": {
      "start_point": [
        110,
        0
      ],
      "end_point": [
        1812,
        1
      ],
      "content": "static void\ntest_getopt_long (void)\n{\n  int start;\n\n  /* Test disambiguation of options.  */\n  {\n    int argc = 0;\n    const char *argv[10];\n    int option_index;\n    int c;\n\n    argv[argc++] = \"program\";\n    argv[argc++] = \"--x\";\n    argv[argc] = NULL;\n    optind = 1;\n    opterr = 0;\n    c = do_getopt_long (argc, argv, \"ab\", long_options_required, &option_index);\n    ASSERT (c == '?');\n    ASSERT (optopt == 0);\n  }\n  {\n    int argc = 0;\n    const char *argv[10];\n    int option_index;\n    int c;\n\n    argv[argc++] = \"program\";\n    argv[argc++] = \"--xt\";\n    argv[argc] = NULL;\n    optind = 1;\n    opterr = 0;\n    c = do_getopt_long (argc, argv, \"ab\", long_options_required, &option_index);\n    ASSERT (c == '?');\n    ASSERT (optopt == 0);\n  }\n  {\n    int argc = 0;\n    const char *argv[10];\n    int option_index;\n    int c;\n\n    argv[argc++] = \"program\";\n    argv[argc++] = \"--xtr\";\n    argv[argc] = NULL;\n    optind = 1;\n    opterr = 0;\n    c = do_getopt_long (argc, argv, \"ab\", long_options_required, &option_index);\n    ASSERT (c == '?');\n    ASSERT (optopt == 0);\n  }\n  {\n    int argc = 0;\n    const char *argv[10];\n    int option_index;\n    int c;\n\n    argv[argc++] = \"program\";\n    argv[argc++] = \"--xtra\";\n    argv[argc] = NULL;\n    optind = 1;\n    opterr = 0;\n    c = do_getopt_long (argc, argv, \"ab\", long_options_required, &option_index);\n    ASSERT (c == 1001);\n  }\n  {\n    int argc = 0;\n    const char *argv[10];\n    int option_index;\n    int c;\n\n    argv[argc++] = \"program\";\n    argv[argc++] = \"--xtre\";\n    argv[argc] = NULL;\n    optind = 1;\n    opterr = 0;\n    c = do_getopt_long (argc, argv, \"ab\", long_options_required, &option_index);\n    ASSERT (c == '?');\n    ASSERT (optopt == 0);\n  }\n  {\n    int argc = 0;\n    const char *argv[10];\n    int option_index;\n    int c;\n\n    argv[argc++] = \"program\";\n    argv[argc++] = \"--xtrem\";\n    argv[argc] = NULL;\n    optind = 1;\n    opterr = 0;\n    c = do_getopt_long (argc, argv, \"ab\", long_options_required, &option_index);\n    ASSERT (c == '?');\n    ASSERT (optopt == 0);\n  }\n  {\n    int argc = 0;\n    const char *argv[10];\n    int option_index;\n    int c;\n\n    argv[argc++] = \"program\";\n    argv[argc++] = \"--xtreme\";\n    argv[argc] = NULL;\n    optind = 1;\n    opterr = 0;\n    c = do_getopt_long (argc, argv, \"ab\", long_options_required, &option_index);\n    ASSERT (c == 1002);\n  }\n  {\n    int argc = 0;\n    const char *argv[10];\n    int option_index;\n    int c;\n\n    argv[argc++] = \"program\";\n    argv[argc++] = \"--xtremel\";\n    argv[argc] = NULL;\n    optind = 1;\n    opterr = 0;\n    c = do_getopt_long (argc, argv, \"ab\", long_options_required, &option_index);\n    ASSERT (c == 1003);\n  }\n  {\n    int argc = 0;\n    const char *argv[10];\n    int option_index;\n    int c;\n\n    argv[argc++] = \"program\";\n    argv[argc++] = \"--xtremely\";\n    argv[argc] = NULL;\n    optind = 1;\n    opterr = 0;\n    c = do_getopt_long (argc, argv, \"ab\", long_options_required, &option_index);\n    ASSERT (c == 1003);\n  }\n\n  /* Check that -W handles unknown options.  */\n  {\n    int argc = 0;\n    const char *argv[10];\n    int option_index;\n    int c;\n\n    argv[argc++] = \"program\";\n    argv[argc++] = \"-W\";\n    argv[argc] = NULL;\n    optind = 1;\n    opterr = 0;\n    c = do_getopt_long (argc, argv, \"W;\", long_options_required, &option_index);\n    ASSERT (c == '?');\n    ASSERT (optopt == 'W');\n  }\n  {\n    int argc = 0;\n    const char *argv[10];\n    int option_index;\n    int c;\n\n    argv[argc++] = \"program\";\n    argv[argc++] = \"-Wunknown\";\n    argv[argc] = NULL;\n    optind = 1;\n    opterr = 0;\n    c = do_getopt_long (argc, argv, \"W;\", long_options_required, &option_index);\n    /* glibc and BSD behave differently here, but for now, we allow\n       both behaviors since W support is not frequently used.  */\n    if (c == '?')\n      {\n        ASSERT (optopt == 0);\n        ASSERT (optarg == NULL);\n      }\n    else\n      {\n        ASSERT (c == 'W');\n        ASSERT (strcmp (optarg, \"unknown\") == 0);\n      }\n  }\n  {\n    int argc = 0;\n    const char *argv[10];\n    int option_index;\n    int c;\n\n    argv[argc++] = \"program\";\n    argv[argc++] = \"-W\";\n    argv[argc++] = \"unknown\";\n    argv[argc] = NULL;\n    optind = 1;\n    opterr = 0;\n    c = do_getopt_long (argc, argv, \"W;\", long_options_required, &option_index);\n    /* glibc and BSD behave differently here, but for now, we allow\n       both behaviors since W support is not frequently used.  */\n    if (c == '?')\n      {\n        ASSERT (optopt == 0);\n        ASSERT (optarg == NULL);\n      }\n    else\n      {\n        ASSERT (c == 'W');\n        ASSERT (strcmp (optarg, \"unknown\") == 0);\n      }\n  }\n\n  /* Test that 'W' does not dump core:\n     http://sourceware.org/bugzilla/show_bug.cgi?id=12922  */\n  {\n    int argc = 0;\n    const char *argv[10];\n    int option_index;\n    int c;\n\n    argv[argc++] = \"program\";\n    argv[argc++] = \"-W\";\n    argv[argc++] = \"dummy\";\n    argv[argc] = NULL;\n    optind = 1;\n    opterr = 0;\n    c = do_getopt_long (argc, argv, \"W;\", NULL, &option_index);\n    ASSERT (c == 'W');\n    ASSERT (optind == 2);\n  }\n\n  /* Test processing of boolean short options.  */\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"ab\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 2);\n    }\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-b\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"ab\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 1);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 3);\n    }\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-ba\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"ab\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 1);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 2);\n    }\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-ab\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"ab\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 2);\n      ASSERT (b_seen == 1);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 3);\n    }\n\n  /* Test processing of boolean long options.  */\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"--alpha\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"ab\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 2);\n    }\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"--beta\";\n      argv[argc++] = \"--alpha\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"ab\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 1);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 3);\n    }\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"--alpha\";\n      argv[argc++] = \"--beta\";\n      argv[argc++] = \"--alpha\";\n      argv[argc++] = \"--beta\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"ab\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 2);\n      ASSERT (b_seen == 1);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 5);\n    }\n\n  /* Test processing of boolean long options via -W.  */\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-Walpha\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"abW;\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 2);\n    }\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-W\";\n      argv[argc++] = \"beta\";\n      argv[argc++] = \"-W\";\n      argv[argc++] = \"alpha\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"aW;b\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 1);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 5);\n    }\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-Walpha\";\n      argv[argc++] = \"-Wbeta\";\n      argv[argc++] = \"-Walpha\";\n      argv[argc++] = \"-Wbeta\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"W;ab\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 2);\n      ASSERT (b_seen == 1);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 5);\n    }\n\n  /* Test processing of short options with arguments.  */\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-pfoo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"p:q:\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"foo\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 2);\n    }\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"p:q:\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"foo\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 3);\n    }\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-ab\";\n      argv[argc++] = \"-q\";\n      argv[argc++] = \"baz\";\n      argv[argc++] = \"-pfoo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"abp:q:\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 1);\n      ASSERT (p_value != NULL && strcmp (p_value, \"foo\") == 0);\n      ASSERT (q_value != NULL && strcmp (q_value, \"baz\") == 0);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 5);\n    }\n\n  /* Test processing of long options with arguments.  */\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"--p=foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"p:q:\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"foo\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 2);\n    }\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"--p\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"p:q:\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"foo\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 3);\n    }\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-ab\";\n      argv[argc++] = \"--q\";\n      argv[argc++] = \"baz\";\n      argv[argc++] = \"--p=foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"abp:q:\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 1);\n      ASSERT (p_value != NULL && strcmp (p_value, \"foo\") == 0);\n      ASSERT (q_value != NULL && strcmp (q_value, \"baz\") == 0);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 5);\n    }\n\n  /* Test processing of long options with arguments via -W.  */\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-Wp=foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"p:q:W;\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"foo\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 2);\n    }\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-W\";\n      argv[argc++] = \"p\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"p:W;q:\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"foo\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 4);\n    }\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-ab\";\n      argv[argc++] = \"-Wq\";\n      argv[argc++] = \"baz\";\n      argv[argc++] = \"-W\";\n      argv[argc++] = \"p=foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"W;abp:q:\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 1);\n      ASSERT (p_value != NULL && strcmp (p_value, \"foo\") == 0);\n      ASSERT (q_value != NULL && strcmp (q_value, \"baz\") == 0);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 6);\n    }\n\n  /* Test processing of short options with optional arguments.  */\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-pfoo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"p::q::\", long_options_optional,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"foo\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 2);\n    }\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"p::q::\", long_options_optional,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 2);\n    }\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"abp::q::\", long_options_optional,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 3);\n    }\n\n  /* Test processing of long options with optional arguments.  */\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"--p=foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"p::q::\", long_options_optional,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"foo\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 2);\n    }\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"--p\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"p::q::\", long_options_optional,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 2);\n    }\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"--p=\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"p::q::\", long_options_optional,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && *p_value == '\\0');\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 2);\n    }\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"--p\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"abp::q::\", long_options_optional,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 3);\n    }\n\n  /* Test processing of long options with optional arguments via -W.  */\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-Wp=foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"p::q::W;\", long_options_optional,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"foo\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 2);\n    }\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-Wp\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"p::q::W;\", long_options_optional,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 2);\n    }\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-Wp=\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"W;p::q::\", long_options_optional,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && *p_value == '\\0');\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 2);\n    }\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-W\";\n      argv[argc++] = \"p=\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"W;p::q::\", long_options_optional,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && *p_value == '\\0');\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 3);\n    }\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-W\";\n      argv[argc++] = \"p\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"W;abp::q::\", long_options_optional,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 0);\n      /* ASSERT (p_value == NULL); */\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 4);\n    }\n\n  /* Check that invalid options are recognized.  */\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"-x\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"abp:q:\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"foo\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 'x');\n      ASSERT (optind == 5);\n    }\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"-:\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"abp:q:\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"foo\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == ':');\n      ASSERT (optind == 5);\n    }\n\n  /* Check that unexpected arguments are recognized.  */\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"--a=\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"abp:q:\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"foo\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 'a');\n      ASSERT (optind == 4);\n    }\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"--b=\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"abp:q:\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"foo\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      /* When flag is non-zero, glibc sets optopt anyway, but BSD\n         leaves optopt unchanged.  */\n      ASSERT (unrecognized == 1 || unrecognized == 0);\n      ASSERT (optind == 4);\n    }\n\n  /* Check that by default, non-options arguments are moved to the end.  */\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"donald\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"billy\";\n      argv[argc++] = \"duck\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"abp:q:\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (strcmp (argv[0], \"program\") == 0);\n      ASSERT (strcmp (argv[1], \"-p\") == 0);\n      ASSERT (strcmp (argv[2], \"billy\") == 0);\n      ASSERT (strcmp (argv[3], \"-a\") == 0);\n      ASSERT (strcmp (argv[4], \"donald\") == 0);\n      ASSERT (strcmp (argv[5], \"duck\") == 0);\n      ASSERT (strcmp (argv[6], \"bar\") == 0);\n      ASSERT (argv[7] == NULL);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"billy\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 4);\n    }\n\n  /* Check that '--' ends the argument processing.  */\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[20];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"donald\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"billy\";\n      argv[argc++] = \"duck\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"--\";\n      argv[argc++] = \"-b\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"-q\";\n      argv[argc++] = \"johnny\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"abp:q:\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (strcmp (argv[0], \"program\") == 0);\n      ASSERT (strcmp (argv[1], \"-p\") == 0);\n      ASSERT (strcmp (argv[2], \"billy\") == 0);\n      ASSERT (strcmp (argv[3], \"-a\") == 0);\n      ASSERT (strcmp (argv[4], \"--\") == 0);\n      ASSERT (strcmp (argv[5], \"donald\") == 0);\n      ASSERT (strcmp (argv[6], \"duck\") == 0);\n      ASSERT (strcmp (argv[7], \"-b\") == 0);\n      ASSERT (strcmp (argv[8], \"foo\") == 0);\n      ASSERT (strcmp (argv[9], \"-q\") == 0);\n      ASSERT (strcmp (argv[10], \"johnny\") == 0);\n      ASSERT (strcmp (argv[11], \"bar\") == 0);\n      ASSERT (argv[12] == NULL);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"billy\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 5);\n    }\n\n  /* Check that the '-' flag causes non-options to be returned in order.  */\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"donald\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"billy\";\n      argv[argc++] = \"duck\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"-abp:q:\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (strcmp (argv[0], \"program\") == 0);\n      ASSERT (strcmp (argv[1], \"donald\") == 0);\n      ASSERT (strcmp (argv[2], \"-p\") == 0);\n      ASSERT (strcmp (argv[3], \"billy\") == 0);\n      ASSERT (strcmp (argv[4], \"duck\") == 0);\n      ASSERT (strcmp (argv[5], \"-a\") == 0);\n      ASSERT (strcmp (argv[6], \"bar\") == 0);\n      ASSERT (argv[7] == NULL);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"billy\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 3);\n      ASSERT (strcmp (non_options[0], \"donald\") == 0);\n      ASSERT (strcmp (non_options[1], \"duck\") == 0);\n      ASSERT (strcmp (non_options[2], \"bar\") == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 7);\n    }\n\n  /* Check that '--' ends the argument processing.  */\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[20];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"donald\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"billy\";\n      argv[argc++] = \"duck\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"--\";\n      argv[argc++] = \"-b\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"-q\";\n      argv[argc++] = \"johnny\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"-abp:q:\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (strcmp (argv[0], \"program\") == 0);\n      ASSERT (strcmp (argv[1], \"donald\") == 0);\n      ASSERT (strcmp (argv[2], \"-p\") == 0);\n      ASSERT (strcmp (argv[3], \"billy\") == 0);\n      ASSERT (strcmp (argv[4], \"duck\") == 0);\n      ASSERT (strcmp (argv[5], \"-a\") == 0);\n      ASSERT (strcmp (argv[6], \"--\") == 0);\n      ASSERT (strcmp (argv[7], \"-b\") == 0);\n      ASSERT (strcmp (argv[8], \"foo\") == 0);\n      ASSERT (strcmp (argv[9], \"-q\") == 0);\n      ASSERT (strcmp (argv[10], \"johnny\") == 0);\n      ASSERT (strcmp (argv[11], \"bar\") == 0);\n      ASSERT (argv[12] == NULL);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"billy\") == 0);\n      ASSERT (q_value == NULL);\n      if (non_options_count == 2)\n      {\n        /* glibc behaviour.  */\n        ASSERT (non_options_count == 2);\n        ASSERT (strcmp (non_options[0], \"donald\") == 0);\n        ASSERT (strcmp (non_options[1], \"duck\") == 0);\n        ASSERT (unrecognized == 0);\n        ASSERT (optind == 7);\n      }\n      else\n      {\n        /* Another valid behaviour.  */\n        ASSERT (non_options_count == 7);\n        ASSERT (strcmp (non_options[0], \"donald\") == 0);\n        ASSERT (strcmp (non_options[1], \"duck\") == 0);\n        ASSERT (strcmp (non_options[2], \"-b\") == 0);\n        ASSERT (strcmp (non_options[3], \"foo\") == 0);\n        ASSERT (strcmp (non_options[4], \"-q\") == 0);\n        ASSERT (strcmp (non_options[5], \"johnny\") == 0);\n        ASSERT (strcmp (non_options[6], \"bar\") == 0);\n        ASSERT (unrecognized == 0);\n        ASSERT (optind == 12);\n      }\n    }\n\n  /* Check that the '-' flag has to come first.  */\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"donald\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"billy\";\n      argv[argc++] = \"duck\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"abp:q:-\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (strcmp (argv[0], \"program\") == 0);\n      ASSERT (strcmp (argv[1], \"-p\") == 0);\n      ASSERT (strcmp (argv[2], \"billy\") == 0);\n      ASSERT (strcmp (argv[3], \"-a\") == 0);\n      ASSERT (strcmp (argv[4], \"donald\") == 0);\n      ASSERT (strcmp (argv[5], \"duck\") == 0);\n      ASSERT (strcmp (argv[6], \"bar\") == 0);\n      ASSERT (argv[7] == NULL);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"billy\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 4);\n    }\n\n  /* Check that the '+' flag causes the first non-option to terminate the\n     loop.  */\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"donald\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"billy\";\n      argv[argc++] = \"duck\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"+abp:q:\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (strcmp (argv[0], \"program\") == 0);\n      ASSERT (strcmp (argv[1], \"donald\") == 0);\n      ASSERT (strcmp (argv[2], \"-p\") == 0);\n      ASSERT (strcmp (argv[3], \"billy\") == 0);\n      ASSERT (strcmp (argv[4], \"duck\") == 0);\n      ASSERT (strcmp (argv[5], \"-a\") == 0);\n      ASSERT (strcmp (argv[6], \"bar\") == 0);\n      ASSERT (argv[7] == NULL);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 1);\n    }\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-+\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"+abp:q:\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == '+');\n      ASSERT (optind == 2);\n    }\n\n  /* Check that '--' ends the argument processing.  */\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[20];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"donald\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"billy\";\n      argv[argc++] = \"duck\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"--\";\n      argv[argc++] = \"-b\";\n      argv[argc++] = \"foo\";\n      argv[argc++] = \"-q\";\n      argv[argc++] = \"johnny\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"+abp:q:\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (strcmp (argv[0], \"program\") == 0);\n      ASSERT (strcmp (argv[1], \"donald\") == 0);\n      ASSERT (strcmp (argv[2], \"-p\") == 0);\n      ASSERT (strcmp (argv[3], \"billy\") == 0);\n      ASSERT (strcmp (argv[4], \"duck\") == 0);\n      ASSERT (strcmp (argv[5], \"-a\") == 0);\n      ASSERT (strcmp (argv[6], \"--\") == 0);\n      ASSERT (strcmp (argv[7], \"-b\") == 0);\n      ASSERT (strcmp (argv[8], \"foo\") == 0);\n      ASSERT (strcmp (argv[9], \"-q\") == 0);\n      ASSERT (strcmp (argv[10], \"johnny\") == 0);\n      ASSERT (strcmp (argv[11], \"bar\") == 0);\n      ASSERT (argv[12] == NULL);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 1);\n    }\n\n  /* Check that the '+' flag has to come first.  */\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"donald\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"billy\";\n      argv[argc++] = \"duck\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"abp:q:+\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (strcmp (argv[0], \"program\") == 0);\n      ASSERT (strcmp (argv[1], \"-p\") == 0);\n      ASSERT (strcmp (argv[2], \"billy\") == 0);\n      ASSERT (strcmp (argv[3], \"-a\") == 0);\n      ASSERT (strcmp (argv[4], \"donald\") == 0);\n      ASSERT (strcmp (argv[5], \"duck\") == 0);\n      ASSERT (strcmp (argv[6], \"bar\") == 0);\n      ASSERT (argv[7] == NULL);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value != NULL && strcmp (p_value, \"billy\") == 0);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 4);\n    }\n}",
      "lines": 1703,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_getopt_long_posix": {
      "start_point": [
        1818,
        0
      ],
      "end_point": [
        1926,
        1
      ],
      "content": "static void\ntest_getopt_long_posix (void)\n{\n  int start;\n\n  /* Check that POSIXLY_CORRECT stops parsing the same as leading '+'.  */\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"donald\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"billy\";\n      argv[argc++] = \"duck\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"bar\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"abp:q:\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (strcmp (argv[0], \"program\") == 0);\n      ASSERT (strcmp (argv[1], \"donald\") == 0);\n      ASSERT (strcmp (argv[2], \"-p\") == 0);\n      ASSERT (strcmp (argv[3], \"billy\") == 0);\n      ASSERT (strcmp (argv[4], \"duck\") == 0);\n      ASSERT (strcmp (argv[5], \"-a\") == 0);\n      ASSERT (strcmp (argv[6], \"bar\") == 0);\n      ASSERT (argv[7] == NULL);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 1);\n    }\n\n  /* Check that POSIXLY_CORRECT doesn't change optional arguments.  */\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-p\";\n      argv[argc++] = \"billy\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"p::\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 0);\n      ASSERT (b_seen == 0);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 2);\n    }\n\n  /* Check that leading - still sees options after non-options.  */\n  for (start = 0; start <= 1; start++)\n    {\n      const char *p_value = NULL;\n      const char *q_value = NULL;\n      int non_options_count = 0;\n      const char *non_options[10];\n      int unrecognized = 0;\n      int argc = 0;\n      const char *argv[10];\n      a_seen = 0;\n      b_seen = 0;\n\n      argv[argc++] = \"program\";\n      argv[argc++] = \"-a\";\n      argv[argc++] = \"billy\";\n      argv[argc++] = \"-b\";\n      argv[argc] = NULL;\n      optind = start;\n      getopt_long_loop (argc, argv, \"-ab\", long_options_required,\n                        &p_value, &q_value,\n                        &non_options_count, non_options, &unrecognized);\n      ASSERT (a_seen == 1);\n      ASSERT (b_seen == 1);\n      ASSERT (p_value == NULL);\n      ASSERT (q_value == NULL);\n      ASSERT (non_options_count == 1);\n      ASSERT (strcmp (non_options[0], \"billy\") == 0);\n      ASSERT (unrecognized == 0);\n      ASSERT (optind == 4);\n    }\n}",
      "lines": 109,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "do_getopt_long_only": {
      "start_point": [
        1931,
        0
      ],
      "end_point": [
        1936,
        1
      ],
      "content": "static int\ndo_getopt_long_only (int argc, const char **argv, const char *shortopts,\n                     const struct option *longopts, int *longind)\n{\n  return getopt_long_only (argc, (char **) argv, shortopts, longopts, longind);\n}",
      "lines": 6,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "test_getopt_long_only": {
      "start_point": [
        1938,
        0
      ],
      "end_point": [
        2143,
        1
      ],
      "content": "static void\ntest_getopt_long_only (void)\n{\n  /* Test disambiguation of options.  */\n  {\n    int argc = 0;\n    const char *argv[10];\n    int option_index;\n    int c;\n\n    argv[argc++] = \"program\";\n    argv[argc++] = \"-x\";\n    argv[argc] = NULL;\n    optind = 1;\n    opterr = 0;\n    c = do_getopt_long_only (argc, argv, \"ab\", long_options_required,\n                             &option_index);\n    ASSERT (c == '?');\n    ASSERT (optopt == 0);\n  }\n  {\n    int argc = 0;\n    const char *argv[10];\n    int option_index;\n    int c;\n\n    argv[argc++] = \"program\";\n    argv[argc++] = \"-x\";\n    argv[argc] = NULL;\n    optind = 1;\n    opterr = 0;\n    c = do_getopt_long_only (argc, argv, \"abx\", long_options_required,\n                             &option_index);\n    ASSERT (c == 'x');\n    ASSERT (optopt == 0);\n  }\n  {\n    int argc = 0;\n    const char *argv[10];\n    int option_index;\n    int c;\n\n    argv[argc++] = \"program\";\n    argv[argc++] = \"--x\";\n    argv[argc] = NULL;\n    optind = 1;\n    opterr = 0;\n    c = do_getopt_long_only (argc, argv, \"abx\", long_options_required,\n                             &option_index);\n    ASSERT (c == '?');\n    ASSERT (optopt == 0);\n  }\n  {\n    int argc = 0;\n    const char *argv[10];\n    int option_index;\n    int c;\n\n    argv[argc++] = \"program\";\n    argv[argc++] = \"-b\";\n    argv[argc] = NULL;\n    optind = 1;\n    opterr = 0;\n    b_seen = 0;\n    c = do_getopt_long_only (argc, argv, \"abx\", long_options_required,\n                             &option_index);\n    ASSERT (c == 'b');\n    ASSERT (b_seen == 0);\n  }\n  {\n    int argc = 0;\n    const char *argv[10];\n    int option_index;\n    int c;\n\n    argv[argc++] = \"program\";\n    argv[argc++] = \"--b\";\n    argv[argc] = NULL;\n    optind = 1;\n    opterr = 0;\n    b_seen = 0;\n    c = do_getopt_long_only (argc, argv, \"abx\", long_options_required,\n                             &option_index);\n    ASSERT (c == 0);\n    ASSERT (b_seen == 1);\n  }\n  {\n    int argc = 0;\n    const char *argv[10];\n    int option_index;\n    int c;\n\n    argv[argc++] = \"program\";\n    argv[argc++] = \"-xt\";\n    argv[argc] = NULL;\n    optind = 1;\n    opterr = 0;\n    c = do_getopt_long_only (argc, argv, \"ab\", long_options_required,\n                             &option_index);\n    ASSERT (c == '?');\n    ASSERT (optopt == 0);\n  }\n  {\n    int argc = 0;\n    const char *argv[10];\n    int option_index;\n    int c;\n\n    argv[argc++] = \"program\";\n    argv[argc++] = \"-xt\";\n    argv[argc] = NULL;\n    optind = 1;\n    opterr = 0;\n    c = do_getopt_long_only (argc, argv, \"abx\", long_options_required,\n                             &option_index);\n    ASSERT (c == '?');\n    ASSERT (optopt == 0);\n  }\n  {\n    int argc = 0;\n    const char *argv[10];\n    int option_index;\n    int c;\n\n    argv[argc++] = \"program\";\n    argv[argc++] = \"-xtra\";\n    argv[argc] = NULL;\n    optind = 1;\n    opterr = 0;\n    c = do_getopt_long_only (argc, argv, \"ab\", long_options_required,\n                             &option_index);\n    ASSERT (c == 1001);\n  }\n  {\n    int argc = 0;\n    const char *argv[10];\n    int option_index;\n    int c;\n\n    argv[argc++] = \"program\";\n    argv[argc++] = \"-xtreme\";\n    argv[argc] = NULL;\n    optind = 1;\n    opterr = 0;\n    c = do_getopt_long_only (argc, argv, \"abx:\", long_options_required,\n                             &option_index);\n    ASSERT (c == 1002);\n  }\n  {\n    int argc = 0;\n    const char *argv[10];\n    int option_index;\n    int c;\n\n    argv[argc++] = \"program\";\n    argv[argc++] = \"-xtremel\";\n    argv[argc] = NULL;\n    optind = 1;\n    opterr = 0;\n    c = do_getopt_long_only (argc, argv, \"ab\", long_options_required,\n                             &option_index);\n    /* glibc getopt_long_only is intentionally different from\n       getopt_long when handling a prefix that is common to two\n       spellings, when both spellings have the same option directives.\n       BSD getopt_long_only treats both cases the same.  */\n    ASSERT (c == 1003 || c == '?');\n    ASSERT (optind == 2);\n  }\n  {\n    int argc = 0;\n    const char *argv[10];\n    int option_index;\n    int c;\n\n    argv[argc++] = \"program\";\n    argv[argc++] = \"-xtremel\";\n    argv[argc] = NULL;\n    optind = 1;\n    opterr = 0;\n    c = do_getopt_long_only (argc, argv, \"abx::\", long_options_required,\n                             &option_index);\n    /* glibc getopt_long_only is intentionally different from\n       getopt_long when handling a prefix that is common to two\n       spellings, when both spellings have the same option directives.\n       BSD getopt_long_only treats both cases the same.  */\n    ASSERT (c == 1003 || c == '?');\n    ASSERT (optind == 2);\n    ASSERT (optarg == NULL);\n  }\n  {\n    int argc = 0;\n    const char *argv[10];\n    int option_index;\n    int c;\n\n    argv[argc++] = \"program\";\n    argv[argc++] = \"-xtras\";\n    argv[argc] = NULL;\n    optind = 1;\n    opterr = 0;\n    c = do_getopt_long_only (argc, argv, \"abx::\", long_options_required,\n                             &option_index);\n    ASSERT (c == 'x');\n    ASSERT (strcmp (optarg, \"tras\") == 0);\n  }\n}",
      "lines": 206,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-gettimeofday.c": {
    "main": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        46,
        1
      ],
      "content": "int\nmain (void)\n{\n  time_t t = 0;\n  struct tm *lt;\n  struct tm saved_lt;\n  struct timeval tv;\n  lt = localtime (&t);\n  saved_lt = *lt;\n  gettimeofday (&tv, NULL);\n  if (memcmp (lt, &saved_lt, sizeof (struct tm)) != 0)\n    {\n      fprintf (stderr, \"gettimeofday still clobbers the localtime buffer!\\n\");\n      return 1;\n    }\n  return 0;\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-hash.c": {
    "hash_compare_strings": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        39,
        1
      ],
      "content": "static bool\nhash_compare_strings (void const *x, void const *y)\n{\n  ASSERT (x != y);\n  return STREQ (x, y) ? true : false;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "hash_freer": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "static void\nhash_freer (void *x)\n{\n  free (x);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "insert_new": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "static void\ninsert_new (Hash_table *ht, const void *ent)\n{\n  void *e = hash_insert (ht, ent);\n  ASSERT (e == ent);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "walk": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "static bool\nwalk (void *ent, void *data)\n{\n  char *str = ent;\n  unsigned int *map = data;\n  switch (*str)\n    {\n    case 'a': *map |= 1; return true;\n    case 'b': *map |= 2; return true;\n    case 'c': *map |= 4; return true;\n    }\n  *map |= 8;\n  return false;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "get_seed": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "static int\nget_seed (char const *str, unsigned int *seed)\n{\n  size_t len = strlen (str);\n  if (len == 0 || strspn (str, \"0123456789\") != len || 10 < len)\n    return 1;\n\n  *seed = atoi (str);\n  return 0;\n}",
      "lines": 10,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        80,
        0
      ],
      "end_point": [
        262,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  unsigned int i;\n  unsigned int k;\n  unsigned int table_size[] = {1, 2, 3, 4, 5, 23, 53};\n  Hash_table *ht;\n  Hash_tuning tuning;\n\n  hash_reset_tuning (&tuning);\n  tuning.shrink_threshold = 0.3;\n  tuning.shrink_factor = 0.707;\n  tuning.growth_threshold = 1.5;\n  tuning.growth_factor = 2.0;\n  tuning.is_n_buckets = true;\n\n  if (1 < argc)\n    {\n      unsigned int seed;\n      if (get_seed (argv[1], &seed) != 0)\n        {\n          fprintf (stderr, \"invalid seed: %s\\n\", argv[1]);\n          exit (EXIT_FAILURE);\n        }\n\n      srand (seed);\n    }\n\n  for (i = 0; i < ARRAY_CARDINALITY (table_size); i++)\n    {\n      size_t sz = table_size[i];\n      ht = hash_initialize (sz, NULL, hash_pjw, hash_compare_strings, NULL);\n      ASSERT (ht);\n      insert_new (ht, \"a\");\n      {\n        char *str1 = strdup (\"a\");\n        char *str2;\n        ASSERT (str1);\n        str2 = hash_insert (ht, str1);\n        ASSERT (str1 != str2);\n        ASSERT (STREQ (str1, str2));\n        free (str1);\n      }\n      insert_new (ht, \"b\");\n      insert_new (ht, \"c\");\n      i = 0;\n      ASSERT (hash_do_for_each (ht, walk, &i) == 3);\n      ASSERT (i == 7);\n      {\n        void *buf[5] = { NULL };\n        ASSERT (hash_get_entries (ht, NULL, 0) == 0);\n        ASSERT (hash_get_entries (ht, buf, 5) == 3);\n        ASSERT (STREQ (buf[0], \"a\") || STREQ (buf[0], \"b\") || STREQ (buf[0], \"c\"));\n      }\n      ASSERT (hash_delete (ht, \"a\"));\n      ASSERT (hash_delete (ht, \"a\") == NULL);\n      ASSERT (hash_delete (ht, \"b\"));\n      ASSERT (hash_delete (ht, \"c\"));\n\n      ASSERT (hash_rehash (ht, 47));\n      ASSERT (hash_rehash (ht, 467));\n\n      /* Free an empty table. */\n      hash_clear (ht);\n      hash_free (ht);\n\n      ht = hash_initialize (sz, NULL, hash_pjw, hash_compare_strings, NULL);\n      ASSERT (ht);\n\n      insert_new (ht, \"z\");\n      insert_new (ht, \"y\");\n      insert_new (ht, \"x\");\n      insert_new (ht, \"w\");\n      insert_new (ht, \"v\");\n      insert_new (ht, \"u\");\n\n      hash_clear (ht);\n      ASSERT (hash_get_n_entries (ht) == 0);\n      hash_free (ht);\n\n      /* Test pointer hashing.  */\n      ht = hash_initialize (sz, NULL, NULL, NULL, NULL);\n      ASSERT (ht);\n      {\n        char *str = strdup (\"a\");\n        ASSERT (str);\n        insert_new (ht, \"a\");\n        insert_new (ht, str);\n        ASSERT (hash_lookup (ht, str) == str);\n        free (str);\n      }\n      hash_free (ht);\n    }\n\n  hash_reset_tuning (&tuning);\n  tuning.shrink_threshold = 0.3;\n  tuning.shrink_factor = 0.707;\n  tuning.growth_threshold = 1.5;\n  tuning.growth_factor = 2.0;\n  tuning.is_n_buckets = true;\n  /* Invalid tuning.  */\n  ht = hash_initialize (4651, &tuning, hash_pjw, hash_compare_strings,\n                        hash_freer);\n  ASSERT (!ht);\n\n  /* Alternate tuning.  */\n  tuning.growth_threshold = 0.89;\n\n  /* Run with default tuning, then with custom tuning settings.  */\n  for (k = 0; k < 2; k++)\n    {\n      Hash_tuning const *tune = (k == 0 ? NULL : &tuning);\n      /* Now, each entry is malloc'd.  */\n      ht = hash_initialize (4651, tune, hash_pjw,\n                            hash_compare_strings, hash_freer);\n      ASSERT (ht);\n      for (i = 0; i < 10000; i++)\n        {\n          unsigned int op = rand () % 10;\n          switch (op)\n            {\n            case 0:\n            case 1:\n            case 2:\n            case 3:\n            case 4:\n            case 5:\n              {\n                char buf[50];\n                char const *p = uinttostr (i, buf);\n                char *p_dup = strdup (p);\n                ASSERT (p_dup);\n                insert_new (ht, p_dup);\n              }\n              break;\n\n            case 6:\n              {\n                size_t n = hash_get_n_entries (ht);\n                ASSERT (hash_rehash (ht, n + rand () % 20));\n              }\n              break;\n\n            case 7:\n              {\n                size_t n = hash_get_n_entries (ht);\n                size_t delta = rand () % 20;\n                if (delta < n)\n                  ASSERT (hash_rehash (ht, n - delta));\n              }\n              break;\n\n            case 8:\n            case 9:\n              {\n                /* Delete a random entry.  */\n                size_t n = hash_get_n_entries (ht);\n                if (n)\n                  {\n                    size_t kk = rand () % n;\n                    void const *p;\n                    void *v;\n                    for (p = hash_get_first (ht); kk;\n                         --kk, p = hash_get_next (ht, p))\n                      {\n                        /* empty */\n                      }\n                    ASSERT (p);\n                    v = hash_delete (ht, p);\n                    ASSERT (v);\n                    free (v);\n                  }\n                break;\n              }\n            }\n          ASSERT (hash_table_ok (ht));\n        }\n\n      hash_free (ht);\n    }\n\n  return 0;\n}",
      "lines": 183,
      "depth": 20,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-i-ring.c": {
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "int\nmain (void)\n{\n  int o;\n  I_ring ir;\n  i_ring_init (&ir, -1);\n  o = i_ring_push (&ir, 1);\n  ASSERT (o == -1);\n  o = i_ring_push (&ir, 2);\n  ASSERT (o == -1);\n  o = i_ring_push (&ir, 3);\n  ASSERT (o == -1);\n  o = i_ring_push (&ir, 4);\n  ASSERT (o == -1);\n  o = i_ring_push (&ir, 5);\n  ASSERT (o == 1);\n  o = i_ring_push (&ir, 6);\n  ASSERT (o == 2);\n  o = i_ring_push (&ir, 7);\n  ASSERT (o == 3);\n\n  o = i_ring_pop (&ir);\n  ASSERT (o == 7);\n  o = i_ring_pop (&ir);\n  ASSERT (o == 6);\n  o = i_ring_pop (&ir);\n  ASSERT (o == 5);\n  o = i_ring_pop (&ir);\n  ASSERT (o == 4);\n  ASSERT (i_ring_empty (&ir));\n\n  o = i_ring_push (&ir, 8);\n  ASSERT (o == -1);\n  o = i_ring_pop (&ir);\n  ASSERT (o == 8);\n  ASSERT (i_ring_empty (&ir));\n\n  return 0;\n}",
      "lines": 39,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-ignore-value.c": {
    "doChar": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "static char\ndoChar (void)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "char"
      ]
    },
    "doInt": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "static int\ndoInt (void)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "doOff": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "static off_t\ndoOff (void)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "off_t"
      ]
    },
    "doPtr": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "static void *\ndoPtr (void)\n{\n  return NULL;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void",
        "*\ndoPtr (void)",
        "*"
      ]
    },
    "doStruct": {
      "start_point": [
        64,
        0
      ],
      "end_point": [
        69,
        1
      ],
      "content": "static struct s\ndoStruct (void)\n{\n  static struct s s1;\n  return s1;\n}",
      "lines": 6,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "struct s",
        "struct",
        "s"
      ]
    },
    "main": {
      "start_point": [
        71,
        0
      ],
      "end_point": [
        83,
        1
      ],
      "content": "int\nmain (void)\n{\n  /* If this test can compile with -Werror and the same warnings as\n     the rest of the project, then we are properly silencing warnings\n     about ignored return values.  */\n  ignore_value (doChar ());\n  ignore_value (doInt ());\n  ignore_value (doOff ());\n  ignore_value (doPtr ());\n  ignore_value (doStruct ());\n  return 0;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-inet_pton.c": {
    "main": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "int\nmain (void)\n{\n#if defined AF_INET /* HAVE_IPV4 */\n  {\n    /* This machine was for a long time known as\n       ma2s2.mathematik.uni-karlsruhe.de.  */\n    const char printable[] = \"129.13.115.2\";\n    struct in_addr internal;\n    int ret;\n\n    ret = inet_pton (AF_INET, printable, &internal);\n    ASSERT (ret == 1);\n    /* Verify that internal is filled in network byte order.  */\n    ASSERT (((unsigned char *) &internal)[0] == 0x81);\n    ASSERT (((unsigned char *) &internal)[1] == 0x0D);\n    ASSERT (((unsigned char *) &internal)[2] == 0x73);\n    ASSERT (((unsigned char *) &internal)[3] == 0x02);\n# ifdef WORDS_BIGENDIAN\n    ASSERT (internal.s_addr == 0x810D7302);\n# else\n    ASSERT (internal.s_addr == 0x02730D81);\n# endif\n  }\n#endif\n\n  return 0;\n}",
      "lines": 28,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-intprops.c": {
    "main": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        382,
        1
      ],
      "content": "int\nmain (void)\n{\n  /* Use VERIFY for tests that must be integer constant expressions,\n     ASSERT otherwise.  */\n\n  /* TYPE_IS_INTEGER.  */\n  ASSERT (TYPE_IS_INTEGER (bool));\n  ASSERT (TYPE_IS_INTEGER (char));\n  ASSERT (TYPE_IS_INTEGER (signed char));\n  ASSERT (TYPE_IS_INTEGER (unsigned char));\n  ASSERT (TYPE_IS_INTEGER (short int));\n  ASSERT (TYPE_IS_INTEGER (unsigned short int));\n  ASSERT (TYPE_IS_INTEGER (int));\n  ASSERT (TYPE_IS_INTEGER (unsigned int));\n  ASSERT (TYPE_IS_INTEGER (long int));\n  ASSERT (TYPE_IS_INTEGER (unsigned long int));\n  ASSERT (TYPE_IS_INTEGER (intmax_t));\n  ASSERT (TYPE_IS_INTEGER (uintmax_t));\n  ASSERT (! TYPE_IS_INTEGER (float));\n  ASSERT (! TYPE_IS_INTEGER (double));\n  ASSERT (! TYPE_IS_INTEGER (long double));\n\n  /* TYPE_SIGNED.  */\n  /* VERIFY (! TYPE_SIGNED (bool)); // not guaranteed by gnulib substitute */\n  VERIFY (TYPE_SIGNED (signed char));\n  VERIFY (! TYPE_SIGNED (unsigned char));\n  VERIFY (TYPE_SIGNED (short int));\n  VERIFY (! TYPE_SIGNED (unsigned short int));\n  VERIFY (TYPE_SIGNED (int));\n  VERIFY (! TYPE_SIGNED (unsigned int));\n  VERIFY (TYPE_SIGNED (long int));\n  VERIFY (! TYPE_SIGNED (unsigned long int));\n  VERIFY (TYPE_SIGNED (intmax_t));\n  VERIFY (! TYPE_SIGNED (uintmax_t));\n  ASSERT (TYPE_SIGNED (float));\n  ASSERT (TYPE_SIGNED (double));\n  ASSERT (TYPE_SIGNED (long double));\n\n  /* Integer representation.  */\n  VERIFY (INT_MIN + INT_MAX < 0\n          ? (TYPE_TWOS_COMPLEMENT (int)\n             && ! TYPE_ONES_COMPLEMENT (int) && ! TYPE_SIGNED_MAGNITUDE (int))\n          : (! TYPE_TWOS_COMPLEMENT (int)\n             && (TYPE_ONES_COMPLEMENT (int) || TYPE_SIGNED_MAGNITUDE (int))));\n\n  /* TYPE_MINIMUM, TYPE_MAXIMUM.  */\n  VERIFY (TYPE_MINIMUM (char) == CHAR_MIN);\n  VERIFY (TYPE_MAXIMUM (char) == CHAR_MAX);\n  VERIFY (TYPE_MINIMUM (unsigned char) == 0);\n  VERIFY (TYPE_MAXIMUM (unsigned char) == UCHAR_MAX);\n  VERIFY (TYPE_MINIMUM (signed char) == SCHAR_MIN);\n  VERIFY (TYPE_MAXIMUM (signed char) == SCHAR_MAX);\n  VERIFY (TYPE_MINIMUM (short int) == SHRT_MIN);\n  VERIFY (TYPE_MAXIMUM (short int) == SHRT_MAX);\n  VERIFY (TYPE_MINIMUM (unsigned short int) == 0);\n  VERIFY (TYPE_MAXIMUM (unsigned short int) == USHRT_MAX);\n  VERIFY (TYPE_MINIMUM (int) == INT_MIN);\n  VERIFY (TYPE_MAXIMUM (int) == INT_MAX);\n  VERIFY (TYPE_MINIMUM (unsigned int) == 0);\n  VERIFY (TYPE_MAXIMUM (unsigned int) == UINT_MAX);\n  VERIFY (TYPE_MINIMUM (long int) == LONG_MIN);\n  VERIFY (TYPE_MAXIMUM (long int) == LONG_MAX);\n  VERIFY (TYPE_MINIMUM (unsigned long int) == 0);\n  VERIFY (TYPE_MAXIMUM (unsigned long int) == ULONG_MAX);\n  VERIFY (TYPE_MINIMUM (intmax_t) == INTMAX_MIN);\n  VERIFY (TYPE_MAXIMUM (intmax_t) == INTMAX_MAX);\n  VERIFY (TYPE_MINIMUM (uintmax_t) == 0);\n  VERIFY (TYPE_MAXIMUM (uintmax_t) == UINTMAX_MAX);\n\n  /* INT_BITS_STRLEN_BOUND.  */\n  VERIFY (INT_BITS_STRLEN_BOUND (1) == 1);\n  VERIFY (INT_BITS_STRLEN_BOUND (2620) == 789);\n\n  /* INT_STRLEN_BOUND, INT_BUFSIZE_BOUND.  */\n  #ifdef INT32_MAX /* POSIX guarantees int32_t; this ports to non-POSIX.  */\n  VERIFY (INT_STRLEN_BOUND (int32_t) == sizeof (\"-2147483648\") - 1);\n  VERIFY (INT_BUFSIZE_BOUND (int32_t) == sizeof (\"-2147483648\"));\n  #endif\n  #ifdef INT64_MAX\n  VERIFY (INT_STRLEN_BOUND (int64_t) == sizeof (\"-9223372036854775808\") - 1);\n  VERIFY (INT_BUFSIZE_BOUND (int64_t) == sizeof (\"-9223372036854775808\"));\n  #endif\n\n  /* All the INT_<op>_RANGE_OVERFLOW tests are equally valid as\n     INT_<op>_OVERFLOW tests, so define macros to do both.  OP is the\n     operation, OPNAME its symbolic name, A and B its operands, T the\n     result type, V the overflow flag, and VRES the result if V and if\n     two's complement.  CHECK_BINOP is for most binary operatinos,\n     CHECK_SBINOP for binary +, -, * when the result type is signed,\n     and CHECK_UNOP for unary operations.  */\n  #define CHECK_BINOP(op, opname, a, b, t, v, vres)                       \\\n    VERIFY (INT_##opname##_RANGE_OVERFLOW (a, b, TYPE_MINIMUM (t),        \\\n                                           TYPE_MAXIMUM (t))              \\\n            == (v));                                                      \\\n    VERIFY (INT_##opname##_OVERFLOW (a, b) == (v))\n  #define CHECK_SBINOP(op, opname, a, b, t, v, vres)                      \\\n    CHECK_BINOP(op, opname, a, b, t, v, vres);                            \\\n    {                                                                     \\\n      t result;                                                           \\\n      ASSERT (INT_##opname##_WRAPV (a, b, &result) == (v));               \\\n      ASSERT (result == ((v) ? (vres) : ((a) op (b)))                     \\\n              || ((v) && !TYPE_TWOS_COMPLEMENT (t)));                     \\\n    }\n  #define CHECK_UNOP(op, opname, a, t, v)                                 \\\n    VERIFY (INT_##opname##_RANGE_OVERFLOW (a, TYPE_MINIMUM (t),           \\\n                                           TYPE_MAXIMUM (t))              \\\n            == (v));                                                      \\\n    VERIFY (INT_##opname##_OVERFLOW (a) == (v))\n\n  /* INT_<op>_RANGE_OVERFLOW, INT_<op>_OVERFLOW.  */\n  VERIFY (INT_ADD_RANGE_OVERFLOW (INT_MAX, 1, INT_MIN, INT_MAX));\n  VERIFY (INT_ADD_OVERFLOW (INT_MAX, 1));\n\n  CHECK_SBINOP (+, ADD, INT_MAX, 1, int, true, INT_MIN);\n  CHECK_SBINOP (+, ADD, INT_MAX, -1, int, false, INT_MAX - 1);\n  CHECK_SBINOP (+, ADD, INT_MIN, 1, int, false, INT_MIN + 1);\n  CHECK_SBINOP (+, ADD, INT_MIN, -1, int, true, INT_MAX);\n  CHECK_BINOP (+, ADD, UINT_MAX, 1u, unsigned int, true, 0u);\n  CHECK_BINOP (+, ADD, 0u, 1u, unsigned int, false, 1u);\n\n  CHECK_SBINOP (-, SUBTRACT, INT_MAX, 1, int, false, INT_MAX - 1);\n  CHECK_SBINOP (-, SUBTRACT, INT_MAX, -1, int, true, INT_MIN);\n  CHECK_SBINOP (-, SUBTRACT, INT_MIN, 1, int, true, INT_MAX);\n  CHECK_SBINOP (-, SUBTRACT, INT_MIN, -1, int, false, INT_MIN - -1);\n  CHECK_BINOP (-, SUBTRACT, UINT_MAX, 1u, unsigned int, false, UINT_MAX - 1u);\n  CHECK_BINOP (-, SUBTRACT, 0u, 1u, unsigned int, true, 0u - 1u);\n\n  CHECK_UNOP (-, NEGATE, INT_MIN, int, TYPE_TWOS_COMPLEMENT (int));\n  CHECK_UNOP (-, NEGATE, 0, int, false);\n  CHECK_UNOP (-, NEGATE, INT_MAX, int, false);\n  CHECK_UNOP (-, NEGATE, 0u, unsigned int, false);\n  CHECK_UNOP (-, NEGATE, 1u, unsigned int, true);\n  CHECK_UNOP (-, NEGATE, UINT_MAX, unsigned int, true);\n\n  CHECK_SBINOP (*, MULTIPLY, INT_MAX, INT_MAX, int, true, 1);\n  CHECK_SBINOP (*, MULTIPLY, INT_MAX, INT_MIN, int, true, INT_MIN);\n  CHECK_SBINOP (*, MULTIPLY, INT_MIN, INT_MAX, int, true, INT_MIN);\n  CHECK_SBINOP (*, MULTIPLY, INT_MIN, INT_MIN, int, true, 0);\n  CHECK_SBINOP (*, MULTIPLY, -1, INT_MIN, int,\n                INT_NEGATE_OVERFLOW (INT_MIN), INT_MIN);\n  CHECK_SBINOP (*, MULTIPLY, LONG_MIN / INT_MAX, (long int) INT_MAX,\n                long int, false, LONG_MIN - LONG_MIN % INT_MAX);\n\n  CHECK_BINOP (/, DIVIDE, INT_MIN, -1, int,\n               INT_NEGATE_OVERFLOW (INT_MIN), INT_MIN);\n  CHECK_BINOP (/, DIVIDE, INT_MAX, 1, int, false, INT_MAX);\n  CHECK_BINOP (/, DIVIDE, (unsigned int) INT_MIN, -1u, unsigned int,\n               false, INT_MIN / -1u);\n\n  CHECK_BINOP (%, REMAINDER, INT_MIN, -1, int, INT_NEGATE_OVERFLOW (INT_MIN), 0);\n  CHECK_BINOP (%, REMAINDER, INT_MAX, 1, int, false, 0);\n  CHECK_BINOP (%, REMAINDER, (unsigned int) INT_MIN, -1u, unsigned int,\n               false, INT_MIN % -1u);\n\n  CHECK_BINOP (<<, LEFT_SHIFT, UINT_MAX, 1, unsigned int, true, UINT_MAX << 1);\n  CHECK_BINOP (<<, LEFT_SHIFT, UINT_MAX / 2 + 1, 1, unsigned int, true,\n               (UINT_MAX / 2 + 1) << 1);\n  CHECK_BINOP (<<, LEFT_SHIFT, UINT_MAX / 2, 1, unsigned int, false,\n               (UINT_MAX / 2) << 1);\n\n  /* INT_<op>_OVERFLOW and INT_<op>_WRAPV with mixed types.  */\n  #define CHECK_SUM(a, b, t, v, vres)                                     \\\n    CHECK_SUM1(a, b, t, v, vres);                                         \\\n    CHECK_SUM1(b, a, t, v, vres)\n  #define CHECK_SSUM(a, b, t, v, vres)                                    \\\n    CHECK_SSUM1(a, b, t, v, vres);                                        \\\n    CHECK_SSUM1(b, a, t, v, vres)\n  #define CHECK_SUM1(a, b, t, v, vres)                                    \\\n    VERIFY (INT_ADD_OVERFLOW (a, b) == (v))\n  #define CHECK_SSUM1(a, b, t, v, vres)                                   \\\n    CHECK_SUM1(a, b, t, v, vres);                                         \\\n    {                                                                     \\\n      t result;                                                           \\\n      ASSERT (INT_ADD_WRAPV (a, b, &result) == (v));                      \\\n      ASSERT (result == ((v) ? (vres) : ((a) + (b)))                      \\\n              || ((v) && !TYPE_TWOS_COMPLEMENT (t)));                     \\\n    }\n  CHECK_SSUM (-1, LONG_MIN, long int, true, LONG_MAX);\n  CHECK_SUM (-1, UINT_MAX, unsigned int, false, DONTCARE);\n  CHECK_SSUM (-1L, INT_MIN, long int, INT_MIN == LONG_MIN,\n              INT_MIN == LONG_MIN ? INT_MAX : DONTCARE);\n  CHECK_SUM (0u, -1, unsigned int, true, 0u + -1);\n  CHECK_SUM (0u, 0, unsigned int, false, DONTCARE);\n  CHECK_SUM (0u, 1, unsigned int, false, DONTCARE);\n  CHECK_SSUM (1, LONG_MAX, long int, true, LONG_MIN);\n  CHECK_SUM (1, UINT_MAX, unsigned int, true, 0u);\n  CHECK_SSUM (1L, INT_MAX, long int, INT_MAX == LONG_MAX,\n              INT_MAX == LONG_MAX ? INT_MIN : DONTCARE);\n  CHECK_SUM (1u, INT_MAX, unsigned int, INT_MAX == UINT_MAX, 1u + INT_MAX);\n  CHECK_SUM (1u, INT_MIN, unsigned int, true, 1u + INT_MIN);\n  {\n    long int result;\n    ASSERT (INT_ADD_WRAPV (1, INT_MAX, &result) == (INT_MAX == LONG_MAX));\n    ASSERT (INT_ADD_WRAPV (-1, INT_MIN, &result) == (INT_MIN == LONG_MIN));\n  }\n\n  #define CHECK_DIFFERENCE(a, b, t, v, vres)                              \\\n    VERIFY (INT_SUBTRACT_OVERFLOW (a, b) == (v))\n  #define CHECK_SDIFFERENCE(a, b, t, v, vres)                             \\\n    CHECK_DIFFERENCE(a, b, t, v, vres);                                   \\\n    {                                                                     \\\n      t result;                                                           \\\n      ASSERT (INT_SUBTRACT_WRAPV (a, b, &result) == (v));                 \\\n      ASSERT (result == ((v) ? (vres) : ((a) - (b)))                      \\\n              || ((v) && !TYPE_TWOS_COMPLEMENT (t)));                     \\\n    }\n  CHECK_DIFFERENCE (INT_MAX, 1u, unsigned int, UINT_MAX < INT_MAX - 1,\n                    INT_MAX - 1u);\n  CHECK_DIFFERENCE (UINT_MAX, 1, unsigned int, false, UINT_MAX - 1);\n  CHECK_DIFFERENCE (0u, -1, unsigned int, false, 0u - -1);\n  CHECK_DIFFERENCE (UINT_MAX, -1, unsigned int, true, UINT_MAX - -1);\n  CHECK_DIFFERENCE (INT_MIN, 1u, unsigned int, true, INT_MIN - 1u);\n  CHECK_DIFFERENCE (-1, 0u, unsigned int, true, -1 - 0u);\n  CHECK_SDIFFERENCE (-1, INT_MIN, int, false, -1 - INT_MIN);\n  CHECK_SDIFFERENCE (-1, INT_MAX, int, false, -1 - INT_MAX);\n  CHECK_SDIFFERENCE (0, INT_MIN, int, INT_MIN < -INT_MAX, INT_MIN);\n  CHECK_SDIFFERENCE (0, INT_MAX, int, false, 0 - INT_MAX);\n  {\n    long int result;\n    ASSERT (INT_SUBTRACT_WRAPV (INT_MAX, -1, &result) == (INT_MAX == LONG_MAX));\n    ASSERT (INT_SUBTRACT_WRAPV (INT_MIN, 1, &result) == (INT_MAX == LONG_MAX));\n  }\n\n  #define CHECK_PRODUCT(a, b, t, v, vres)                                 \\\n    CHECK_PRODUCT1(a, b, t, v, vres);                                     \\\n    CHECK_PRODUCT1(b, a, t, v, vres)\n  #define CHECK_SPRODUCT(a, b, t, v, vres)                                \\\n    CHECK_SPRODUCT1(a, b, t, v, vres);                                    \\\n    CHECK_SPRODUCT1(b, a, t, v, vres)\n  #define CHECK_PRODUCT1(a, b, t, v, vres)                                \\\n    VERIFY (INT_MULTIPLY_OVERFLOW (a, b) == (v))\n  #define CHECK_SPRODUCT1(a, b, t, v, vres)                               \\\n    CHECK_PRODUCT1(a, b, t, v, vres);                                     \\\n    {                                                                     \\\n      t result;                                                           \\\n      ASSERT (INT_MULTIPLY_WRAPV (a, b, &result) == (v));                 \\\n      ASSERT (result == ((v) ? (vres) : ((a) * (b)))                      \\\n              || ((v) && !TYPE_TWOS_COMPLEMENT (t)));                     \\\n    }\n  CHECK_PRODUCT (-1, 1u, unsigned int, true, -1 * 1u);\n  CHECK_SPRODUCT (-1, INT_MIN, int, INT_NEGATE_OVERFLOW (INT_MIN), INT_MIN);\n  CHECK_PRODUCT (-1, UINT_MAX, unsigned int, true, -1 * UINT_MAX);\n  CHECK_SPRODUCT (-32768, LONG_MAX / -32768 - 1, long int, true, LONG_MIN);\n  CHECK_SPRODUCT (-12345, LONG_MAX / -12345, long int, false, DONTCARE);\n  CHECK_SPRODUCT (0, -1, int, false, DONTCARE);\n  CHECK_SPRODUCT (0, 0, int, false, DONTCARE);\n  CHECK_PRODUCT (0, 0u, unsigned int, false, DONTCARE);\n  CHECK_SPRODUCT (0, 1, int, false, DONTCARE);\n  CHECK_SPRODUCT (0, INT_MAX, int, false, DONTCARE);\n  CHECK_SPRODUCT (0, INT_MIN, int, false, DONTCARE);\n  CHECK_PRODUCT (0, UINT_MAX, unsigned int, false, DONTCARE);\n  CHECK_PRODUCT (0u, -1, unsigned int, false, DONTCARE);\n  CHECK_PRODUCT (0u, 0, unsigned int, false, DONTCARE);\n  CHECK_PRODUCT (0u, 0u, unsigned int, false, DONTCARE);\n  CHECK_PRODUCT (0u, 1, unsigned int, false, DONTCARE);\n  CHECK_PRODUCT (0u, INT_MAX, unsigned int, false, DONTCARE);\n  CHECK_PRODUCT (0u, INT_MIN, unsigned int, false, DONTCARE);\n  CHECK_PRODUCT (0u, UINT_MAX, unsigned int, false, DONTCARE);\n  CHECK_SPRODUCT (1, INT_MAX, int, false, DONTCARE);\n  CHECK_SPRODUCT (1, INT_MIN, int, false, DONTCARE);\n  CHECK_PRODUCT (1, UINT_MAX, unsigned int, false, DONTCARE);\n  CHECK_PRODUCT (1u, INT_MIN, unsigned int, true, 1u * INT_MIN);\n  CHECK_PRODUCT (1u, INT_MAX, unsigned int, UINT_MAX < INT_MAX, 1u * INT_MAX);\n  CHECK_PRODUCT (INT_MAX, UINT_MAX, unsigned int, true, INT_MAX * UINT_MAX);\n  CHECK_PRODUCT (INT_MAX, ULONG_MAX, unsigned long int, true,\n                 INT_MAX * ULONG_MAX);\n  CHECK_SPRODUCT (INT_MIN, LONG_MAX / INT_MIN - 1, long int, true, LONG_MIN);\n  CHECK_SPRODUCT (INT_MIN, LONG_MAX / INT_MIN, long int, false, DONTCARE);\n  CHECK_PRODUCT (INT_MIN, UINT_MAX, unsigned int, true, INT_MIN * UINT_MAX);\n  CHECK_PRODUCT (INT_MIN, ULONG_MAX, unsigned long int, true,\n                 INT_MIN * ULONG_MAX);\n  {\n    long int result;\n    ASSERT (INT_MULTIPLY_WRAPV (INT_MAX, INT_MAX, &result)\n            == (LONG_MAX / INT_MAX < INT_MAX));\n    ASSERT (INT_MULTIPLY_WRAPV (INT_MAX, INT_MAX, &result)\n            || result == INT_MAX * (long int) INT_MAX);\n    ASSERT (INT_MULTIPLY_WRAPV (INT_MIN, INT_MIN, &result)\n            || result == INT_MIN * (long int) INT_MIN);\n  }\n\n# ifdef LLONG_MAX\n  {\n    long long int result;\n    ASSERT (INT_MULTIPLY_WRAPV (LONG_MAX, LONG_MAX, &result)\n            == (LLONG_MAX / LONG_MAX < LONG_MAX));\n    ASSERT (INT_MULTIPLY_WRAPV (LONG_MAX, LONG_MAX, &result)\n            || result == LONG_MAX * (long long int) LONG_MAX);\n    ASSERT (INT_MULTIPLY_WRAPV (LONG_MIN, LONG_MIN, &result)\n            || result == LONG_MIN * (long long int) LONG_MIN);\n  }\n# endif\n\n  #define CHECK_QUOTIENT(a, b, v) VERIFY (INT_DIVIDE_OVERFLOW (a, b) == (v))\n\n  CHECK_QUOTIENT (INT_MIN, -1L,\n                  TYPE_TWOS_COMPLEMENT (long int) && INT_MIN == LONG_MIN);\n  CHECK_QUOTIENT (INT_MIN, UINT_MAX, false);\n  CHECK_QUOTIENT (INTMAX_MIN, UINTMAX_MAX, false);\n  CHECK_QUOTIENT (INTMAX_MIN, UINT_MAX, false);\n  CHECK_QUOTIENT (-11, 10u, true);\n  CHECK_QUOTIENT (-10, 10u, true);\n  CHECK_QUOTIENT (-9, 10u, false);\n  CHECK_QUOTIENT (11u, -10, true);\n  CHECK_QUOTIENT (10u, -10, true);\n  CHECK_QUOTIENT (9u, -10, false);\n\n  #define CHECK_REMAINDER(a, b, v) VERIFY (INT_REMAINDER_OVERFLOW (a, b) == (v))\n\n  CHECK_REMAINDER (INT_MIN, -1L,\n                   TYPE_TWOS_COMPLEMENT (long int) && INT_MIN == LONG_MIN);\n  CHECK_REMAINDER (-1, UINT_MAX, true);\n  CHECK_REMAINDER ((intmax_t) -1, UINTMAX_MAX, true);\n  CHECK_REMAINDER (INTMAX_MIN, UINT_MAX,\n                   (INTMAX_MAX < UINT_MAX\n                    && - (unsigned int) INTMAX_MIN % UINT_MAX != 0));\n  CHECK_REMAINDER (INT_MIN, ULONG_MAX, INT_MIN % ULONG_MAX != 1);\n  CHECK_REMAINDER (1u, -1, false);\n  CHECK_REMAINDER (37*39u, -39, false);\n  CHECK_REMAINDER (37*39u + 1, -39, true);\n  CHECK_REMAINDER (37*39u - 1, -39, true);\n  CHECK_REMAINDER (LONG_MAX, -INT_MAX, false);\n\n  return 0;\n}",
      "lines": 326,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-inttostr.c": {
    "main": {
      "start_point": [
        68,
        0
      ],
      "end_point": [
        91,
        1
      ],
      "content": "int\nmain (void)\n{\n  size_t b_size = 2;\n  char *b = malloc (b_size);\n  ASSERT (b);\n\n  /* Ideally we would rely on the snprintf-posix module, in which case\n     this guard would not be required, but due to limitations in gnulib's\n     implementation (see modules/snprintf-posix), we cannot.  */\n  if (snprintf (b, b_size, \"%ju\", (uintmax_t) 3) == 1\n      && b[0] == '3' && b[1] == '\\0')\n    {\n      CK (int,          inttostr);\n      CK (unsigned int, uinttostr);\n      CK (off_t,        offtostr);\n      CK (uintmax_t,    umaxtostr);\n      CK (intmax_t,     imaxtostr);\n      return 0;\n    }\n\n  /* snprintf doesn't accept %ju; skip this test.  */\n  return 77;\n}",
      "lines": 24,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-inttypes.c": {
    "main": {
      "start_point": [
        113,
        0
      ],
      "end_point": [
        117,
        1
      ],
      "content": "int\nmain (void)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-ioctl.c": {
    "main": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "int\nmain (void)\n{\n#ifdef FIONREAD\n  /* Test behaviour for invalid file descriptors.  */\n  {\n    int value;\n    errno = 0;\n    ASSERT (ioctl (-1, FIONREAD, &value) == -1);\n    ASSERT (errno == EBADF);\n  }\n  {\n    int value;\n    close (99);\n    errno = 0;\n    ASSERT (ioctl (99, FIONREAD, &value) == -1);\n    ASSERT (errno == EBADF);\n  }\n#endif\n\n  return 0;\n}",
      "lines": 22,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-isblank.c": {
    "main": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  unsigned int c;\n\n  /* Verify the property in the \"C\" locale.\n     POSIX specifies in\n       <http://www.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap07.html>\n     that\n       - in all locales, the blank characters include the <space> and <tab>\n         characters,\n       - in the \"POSIX\" locale (which is usually the same as the \"C\" locale),\n         the blank characters include only the ASCII <space> and <tab>\n         characters.  */\n  for (c = 0; c <= UCHAR_MAX; c++)\n    ASSERT (!isblank (c) == !(c == ' ' || c == '\\t'));\n  ASSERT (!isblank (EOF));\n\n  return 0;\n}",
      "lines": 20,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-isfinite.c": {
    "test_isfinitef": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        80,
        1
      ],
      "content": "static void\ntest_isfinitef ()\n{\n  /* Zero. */\n  ASSERT (isfinite (0.0f));\n  /* Subnormal values. */\n  ASSERT (isfinite (FLT_MIN / 2));\n  ASSERT (isfinite (-FLT_MIN / 2));\n  /* Finite values.  */\n  ASSERT (isfinite (3.141f));\n  ASSERT (isfinite (3.141e30f));\n  ASSERT (isfinite (3.141e-30f));\n  ASSERT (isfinite (-2.718f));\n  ASSERT (isfinite (-2.718e30f));\n  ASSERT (isfinite (-2.718e-30f));\n  /* Infinite values.  */\n  ASSERT (!isfinite (Infinityf ()));\n  ASSERT (!isfinite (- Infinityf ()));\n  /* Quiet NaN.  */\n  ASSERT (!isfinite (zerof / zerof));\n#if defined FLT_EXPBIT0_WORD && defined FLT_EXPBIT0_BIT\n  /* Signalling NaN.  */\n  {\n    #define NWORDS \\\n      ((sizeof (float) + sizeof (unsigned int) - 1) / sizeof (unsigned int))\n    typedef union { float value; unsigned int word[NWORDS]; } memory_float;\n    memory_float m;\n    m.value = zerof / zerof;\n# if FLT_EXPBIT0_BIT > 0\n    m.word[FLT_EXPBIT0_WORD] ^= (unsigned int) 1 << (FLT_EXPBIT0_BIT - 1);\n# else\n    m.word[FLT_EXPBIT0_WORD + (FLT_EXPBIT0_WORD < NWORDS / 2 ? 1 : - 1)]\n      ^= (unsigned int) 1 << (sizeof (unsigned int) * CHAR_BIT - 1);\n# endif\n    if (FLT_EXPBIT0_WORD < NWORDS / 2)\n      m.word[FLT_EXPBIT0_WORD + 1] |= (unsigned int) 1 << FLT_EXPBIT0_BIT;\n    else\n      m.word[0] |= (unsigned int) 1;\n    ASSERT (!isfinite (m.value));\n    #undef NWORDS\n  }\n#endif\n}",
      "lines": 43,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_isfinited": {
      "start_point": [
        82,
        0
      ],
      "end_point": [
        122,
        1
      ],
      "content": "static void\ntest_isfinited ()\n{\n  /* Zero. */\n  ASSERT (isfinite (0.0));\n  /* Subnormal values. */\n  ASSERT (isfinite (DBL_MIN / 2));\n  ASSERT (isfinite (-DBL_MIN / 2));\n  /* Finite values. */\n  ASSERT (isfinite (3.141));\n  ASSERT (isfinite (3.141e30));\n  ASSERT (isfinite (3.141e-30));\n  ASSERT (isfinite (-2.718));\n  ASSERT (isfinite (-2.718e30));\n  ASSERT (isfinite (-2.718e-30));\n  /* Infinite values.  */\n  ASSERT (!isfinite (Infinityd ()));\n  ASSERT (!isfinite (- Infinityd ()));\n  /* Quiet NaN.  */\n  ASSERT (!isfinite (zerod / zerod));\n#if defined DBL_EXPBIT0_WORD && defined DBL_EXPBIT0_BIT\n  /* Signalling NaN.  */\n  {\n    #define NWORDS \\\n      ((sizeof (double) + sizeof (unsigned int) - 1) / sizeof (unsigned int))\n    typedef union { double value; unsigned int word[NWORDS]; } memory_double;\n    memory_double m;\n    m.value = zerod / zerod;\n# if DBL_EXPBIT0_BIT > 0\n    m.word[DBL_EXPBIT0_WORD] ^= (unsigned int) 1 << (DBL_EXPBIT0_BIT - 1);\n# else\n    m.word[DBL_EXPBIT0_WORD + (DBL_EXPBIT0_WORD < NWORDS / 2 ? 1 : - 1)]\n      ^= (unsigned int) 1 << (sizeof (unsigned int) * CHAR_BIT - 1);\n# endif\n    m.word[DBL_EXPBIT0_WORD + (DBL_EXPBIT0_WORD < NWORDS / 2 ? 1 : - 1)]\n      |= (unsigned int) 1 << DBL_EXPBIT0_BIT;\n    ASSERT (!isfinite (m.value));\n    #undef NWORDS\n  }\n#endif\n}",
      "lines": 41,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_isfinitel": {
      "start_point": [
        124,
        0
      ],
      "end_point": [
        230,
        1
      ],
      "content": "static void\ntest_isfinitel ()\n{\n  #define NWORDS \\\n    ((sizeof (long double) + sizeof (unsigned int) - 1) / sizeof (unsigned int))\n  typedef union { unsigned int word[NWORDS]; long double value; }\n          memory_long_double;\n\n  /* Zero. */\n  ASSERT (isfinite (0.0L));\n  /* Subnormal values. */\n  ASSERT (isfinite (LDBL_MIN / 2));\n  ASSERT (isfinite (-LDBL_MIN / 2));\n  /* Finite values. */\n  ASSERT (isfinite (3.141L));\n  ASSERT (isfinite (3.141e30L));\n  ASSERT (isfinite (3.141e-30L));\n  ASSERT (isfinite (-2.718L));\n  ASSERT (isfinite (-2.718e30L));\n  ASSERT (isfinite (-2.718e-30L));\n  /* Infinite values.  */\n  ASSERT (!isfinite (Infinityl ()));\n  ASSERT (!isfinite (- Infinityl ()));\n  /* Quiet NaN.  */\n  ASSERT (!isfinite (zerol / zerol));\n\n#if defined LDBL_EXPBIT0_WORD && defined LDBL_EXPBIT0_BIT\n  /* A bit pattern that is different from a Quiet NaN.  With a bit of luck,\n     it's a Signalling NaN.  */\n  {\n#if defined __powerpc__ && LDBL_MANT_DIG == 106\n    /* This is PowerPC \"double double\", a pair of two doubles.  Inf and Nan are\n       represented as the corresponding 64-bit IEEE values in the first double;\n       the second is ignored.  Manipulate only the first double.  */\n    #undef NWORDS\n    #define NWORDS \\\n      ((sizeof (double) + sizeof (unsigned int) - 1) / sizeof (unsigned int))\n#endif\n\n    memory_long_double m;\n    m.value = zerol / zerol;\n# if LDBL_EXPBIT0_BIT > 0\n    m.word[LDBL_EXPBIT0_WORD] ^= (unsigned int) 1 << (LDBL_EXPBIT0_BIT - 1);\n# else\n    m.word[LDBL_EXPBIT0_WORD + (LDBL_EXPBIT0_WORD < NWORDS / 2 ? 1 : - 1)]\n      ^= (unsigned int) 1 << (sizeof (unsigned int) * CHAR_BIT - 1);\n# endif\n    m.word[LDBL_EXPBIT0_WORD + (LDBL_EXPBIT0_WORD < NWORDS / 2 ? 1 : - 1)]\n      |= (unsigned int) 1 << LDBL_EXPBIT0_BIT;\n    ASSERT (!isfinite (m.value));\n  }\n#endif\n\n#if ((defined __ia64 && LDBL_MANT_DIG == 64) || (defined __x86_64__ || defined __amd64__) || (defined __i386 || defined __i386__ || defined _I386 || defined _M_IX86 || defined _X86_)) && !HAVE_SAME_LONG_DOUBLE_AS_DOUBLE\n/* Representation of an 80-bit 'long double' as an initializer for a sequence\n   of 'unsigned int' words.  */\n# ifdef WORDS_BIGENDIAN\n#  define LDBL80_WORDS(exponent,manthi,mantlo) \\\n     { ((unsigned int) (exponent) << 16) | ((unsigned int) (manthi) >> 16), \\\n       ((unsigned int) (manthi) << 16) | ((unsigned int) (mantlo) >> 16),   \\\n       (unsigned int) (mantlo) << 16                                        \\\n     }\n# else\n#  define LDBL80_WORDS(exponent,manthi,mantlo) \\\n     { mantlo, manthi, exponent }\n# endif\n  { /* Quiet NaN.  */\n    static memory_long_double x =\n      { LDBL80_WORDS (0xFFFF, 0xC3333333, 0x00000000) };\n    ASSERT (!isfinite (x.value));\n  }\n  {\n    /* Signalling NaN.  */\n    static memory_long_double x =\n      { LDBL80_WORDS (0xFFFF, 0x83333333, 0x00000000) };\n    ASSERT (!isfinite (x.value));\n  }\n  /* isfinite should return something for noncanonical values.  */\n  { /* Pseudo-NaN.  */\n    static memory_long_double x =\n      { LDBL80_WORDS (0xFFFF, 0x40000001, 0x00000000) };\n    ASSERT (isfinite (x.value) || !isfinite (x.value));\n  }\n  { /* Pseudo-Infinity.  */\n    static memory_long_double x =\n      { LDBL80_WORDS (0xFFFF, 0x00000000, 0x00000000) };\n    ASSERT (isfinite (x.value) || !isfinite (x.value));\n  }\n  { /* Pseudo-Zero.  */\n    static memory_long_double x =\n      { LDBL80_WORDS (0x4004, 0x00000000, 0x00000000) };\n    ASSERT (isfinite (x.value) || !isfinite (x.value));\n  }\n  { /* Unnormalized number.  */\n    static memory_long_double x =\n      { LDBL80_WORDS (0x4000, 0x63333333, 0x00000000) };\n    ASSERT (isfinite (x.value) || !isfinite (x.value));\n  }\n  { /* Pseudo-Denormal.  */\n    static memory_long_double x =\n      { LDBL80_WORDS (0x0000, 0x83333333, 0x00000000) };\n    ASSERT (isfinite (x.value) || !isfinite (x.value));\n  }\n#endif\n\n  #undef NWORDS\n}",
      "lines": 107,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        232,
        0
      ],
      "end_point": [
        239,
        1
      ],
      "content": "int\nmain ()\n{\n  test_isfinitef ();\n  test_isfinited ();\n  test_isfinitel ();\n  return 0;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-isinf.c": {
    "test_isinff": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        82,
        1
      ],
      "content": "static void\ntest_isinff ()\n{\n  /* Zero. */\n  ASSERT (!isinf (0.0f));\n  /* Subnormal values. */\n  ASSERT (!isinf (FLT_MIN / 2));\n  ASSERT (!isinf (-FLT_MIN / 2));\n  /* Finite values.  */\n  ASSERT (!isinf (3.141f));\n  ASSERT (!isinf (3.141e30f));\n  ASSERT (!isinf (3.141e-30f));\n  ASSERT (!isinf (-2.718f));\n  ASSERT (!isinf (-2.718e30f));\n  ASSERT (!isinf (-2.718e-30f));\n  ASSERT (!isinf (FLT_MAX));\n  ASSERT (!isinf (-FLT_MAX));\n  /* Infinite values.  */\n  ASSERT (isinf (Infinityf ()));\n  ASSERT (isinf (- Infinityf ()));\n  /* Quiet NaN.  */\n  ASSERT (!isinf (zerof / zerof));\n#if defined FLT_EXPBIT0_WORD && defined FLT_EXPBIT0_BIT\n  /* Signalling NaN.  */\n  {\n    #define NWORDS \\\n      ((sizeof (float) + sizeof (unsigned int) - 1) / sizeof (unsigned int))\n    typedef union { float value; unsigned int word[NWORDS]; } memory_float;\n    memory_float m;\n    m.value = zerof / zerof;\n# if FLT_EXPBIT0_BIT > 0\n    m.word[FLT_EXPBIT0_WORD] ^= (unsigned int) 1 << (FLT_EXPBIT0_BIT - 1);\n# else\n    m.word[FLT_EXPBIT0_WORD + (FLT_EXPBIT0_WORD < NWORDS / 2 ? 1 : - 1)]\n      ^= (unsigned int) 1 << (sizeof (unsigned int) * CHAR_BIT - 1);\n# endif\n    if (FLT_EXPBIT0_WORD < NWORDS / 2)\n      m.word[FLT_EXPBIT0_WORD + 1] |= (unsigned int) 1 << FLT_EXPBIT0_BIT;\n    else\n      m.word[0] |= (unsigned int) 1;\n    ASSERT (!isinf (m.value));\n    #undef NWORDS\n  }\n#endif\n}",
      "lines": 45,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_isinfd": {
      "start_point": [
        84,
        0
      ],
      "end_point": [
        126,
        1
      ],
      "content": "static void\ntest_isinfd ()\n{\n  /* Zero. */\n  ASSERT (!isinf (0.0));\n  /* Subnormal values. */\n  ASSERT (!isinf (DBL_MIN / 2));\n  ASSERT (!isinf (-DBL_MIN / 2));\n  /* Finite values. */\n  ASSERT (!isinf (3.141));\n  ASSERT (!isinf (3.141e30));\n  ASSERT (!isinf (3.141e-30));\n  ASSERT (!isinf (-2.718));\n  ASSERT (!isinf (-2.718e30));\n  ASSERT (!isinf (-2.718e-30));\n  ASSERT (!isinf (DBL_MAX));\n  ASSERT (!isinf (-DBL_MAX));\n  /* Infinite values.  */\n  ASSERT (isinf (Infinityd ()));\n  ASSERT (isinf (- Infinityd ()));\n  /* Quiet NaN.  */\n  ASSERT (!isinf (zerod / zerod));\n#if defined DBL_EXPBIT0_WORD && defined DBL_EXPBIT0_BIT\n  /* Signalling NaN.  */\n  {\n    #define NWORDS \\\n      ((sizeof (double) + sizeof (unsigned int) - 1) / sizeof (unsigned int))\n    typedef union { double value; unsigned int word[NWORDS]; } memory_double;\n    memory_double m;\n    m.value = zerod / zerod;\n# if DBL_EXPBIT0_BIT > 0\n    m.word[DBL_EXPBIT0_WORD] ^= (unsigned int) 1 << (DBL_EXPBIT0_BIT - 1);\n# else\n    m.word[DBL_EXPBIT0_WORD + (DBL_EXPBIT0_WORD < NWORDS / 2 ? 1 : - 1)]\n      ^= (unsigned int) 1 << (sizeof (unsigned int) * CHAR_BIT - 1);\n# endif\n    m.word[DBL_EXPBIT0_WORD + (DBL_EXPBIT0_WORD < NWORDS / 2 ? 1 : - 1)]\n      |= (unsigned int) 1 << DBL_EXPBIT0_BIT;\n    ASSERT (!isinf (m.value));\n    #undef NWORDS\n  }\n#endif\n}",
      "lines": 43,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_isinfl": {
      "start_point": [
        128,
        0
      ],
      "end_point": [
        236,
        1
      ],
      "content": "static void\ntest_isinfl ()\n{\n  #define NWORDS \\\n    ((sizeof (long double) + sizeof (unsigned int) - 1) / sizeof (unsigned int))\n  typedef union { unsigned int word[NWORDS]; long double value; }\n          memory_long_double;\n\n  /* Zero. */\n  ASSERT (!isinf (0.0L));\n  /* Subnormal values. */\n  ASSERT (!isinf (LDBL_MIN / 2));\n  ASSERT (!isinf (-LDBL_MIN / 2));\n  /* Finite values. */\n  ASSERT (!isinf (3.141L));\n  ASSERT (!isinf (3.141e30L));\n  ASSERT (!isinf (3.141e-30L));\n  ASSERT (!isinf (-2.718L));\n  ASSERT (!isinf (-2.718e30L));\n  ASSERT (!isinf (-2.718e-30L));\n  ASSERT (!isinf (LDBL_MAX));\n  ASSERT (!isinf (-LDBL_MAX));\n  /* Infinite values.  */\n  ASSERT (isinf (Infinityl ()));\n  ASSERT (isinf (- Infinityl ()));\n  /* Quiet NaN.  */\n  ASSERT (!isinf (zerol / zerol));\n\n#if defined LDBL_EXPBIT0_WORD && defined LDBL_EXPBIT0_BIT\n  /* A bit pattern that is different from a Quiet NaN.  With a bit of luck,\n     it's a Signalling NaN.  */\n  {\n#if defined __powerpc__ && LDBL_MANT_DIG == 106\n    /* This is PowerPC \"double double\", a pair of two doubles.  Inf and Nan are\n       represented as the corresponding 64-bit IEEE values in the first double;\n       the second is ignored.  Manipulate only the first double.  */\n    #undef NWORDS\n    #define NWORDS \\\n      ((sizeof (double) + sizeof (unsigned int) - 1) / sizeof (unsigned int))\n#endif\n\n    memory_long_double m;\n    m.value = zerol / zerol;\n# if LDBL_EXPBIT0_BIT > 0\n    m.word[LDBL_EXPBIT0_WORD] ^= (unsigned int) 1 << (LDBL_EXPBIT0_BIT - 1);\n# else\n    m.word[LDBL_EXPBIT0_WORD + (LDBL_EXPBIT0_WORD < NWORDS / 2 ? 1 : - 1)]\n      ^= (unsigned int) 1 << (sizeof (unsigned int) * CHAR_BIT - 1);\n# endif\n    m.word[LDBL_EXPBIT0_WORD + (LDBL_EXPBIT0_WORD < NWORDS / 2 ? 1 : - 1)]\n      |= (unsigned int) 1 << LDBL_EXPBIT0_BIT;\n    ASSERT (!isinf (m.value));\n  }\n#endif\n\n#if ((defined __ia64 && LDBL_MANT_DIG == 64) || (defined __x86_64__ || defined __amd64__) || (defined __i386 || defined __i386__ || defined _I386 || defined _M_IX86 || defined _X86_)) && !HAVE_SAME_LONG_DOUBLE_AS_DOUBLE\n/* Representation of an 80-bit 'long double' as an initializer for a sequence\n   of 'unsigned int' words.  */\n# ifdef WORDS_BIGENDIAN\n#  define LDBL80_WORDS(exponent,manthi,mantlo) \\\n     { ((unsigned int) (exponent) << 16) | ((unsigned int) (manthi) >> 16), \\\n       ((unsigned int) (manthi) << 16) | ((unsigned int) (mantlo) >> 16),   \\\n       (unsigned int) (mantlo) << 16                                        \\\n     }\n# else\n#  define LDBL80_WORDS(exponent,manthi,mantlo) \\\n     { mantlo, manthi, exponent }\n# endif\n  { /* Quiet NaN.  */\n    static memory_long_double x =\n      { LDBL80_WORDS (0xFFFF, 0xC3333333, 0x00000000) };\n    ASSERT (!isinf (x.value));\n  }\n  {\n    /* Signalling NaN.  */\n    static memory_long_double x =\n      { LDBL80_WORDS (0xFFFF, 0x83333333, 0x00000000) };\n    ASSERT (!isinf (x.value));\n  }\n  /* isinf should return something for noncanonical values.  */\n  { /* Pseudo-NaN.  */\n    static memory_long_double x =\n      { LDBL80_WORDS (0xFFFF, 0x40000001, 0x00000000) };\n    ASSERT (isinf (x.value) || !isinf (x.value));\n  }\n  { /* Pseudo-Infinity.  */\n    static memory_long_double x =\n      { LDBL80_WORDS (0xFFFF, 0x00000000, 0x00000000) };\n    ASSERT (isinf (x.value) || !isinf (x.value));\n  }\n  { /* Pseudo-Zero.  */\n    static memory_long_double x =\n      { LDBL80_WORDS (0x4004, 0x00000000, 0x00000000) };\n    ASSERT (isinf (x.value) || !isinf (x.value));\n  }\n  { /* Unnormalized number.  */\n    static memory_long_double x =\n      { LDBL80_WORDS (0x4000, 0x63333333, 0x00000000) };\n    ASSERT (isinf (x.value) || !isinf (x.value));\n  }\n  { /* Pseudo-Denormal.  */\n    static memory_long_double x =\n      { LDBL80_WORDS (0x0000, 0x83333333, 0x00000000) };\n    ASSERT (isinf (x.value) || !isinf (x.value));\n  }\n#endif\n\n  #undef NWORDS\n}",
      "lines": 109,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        238,
        0
      ],
      "end_point": [
        245,
        1
      ],
      "content": "int\nmain ()\n{\n  test_isinff ();\n  test_isinfd ();\n  test_isinfl ();\n  return 0;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-isnand-nolibm.c": {},
  "findutils/findutils-4.6.0/tests/test-isnand.h": {
    "main": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "int\nmain ()\n{\n  /* Finite values.  */\n  ASSERT (!isnand (3.141));\n  ASSERT (!isnand (3.141e30));\n  ASSERT (!isnand (3.141e-30));\n  ASSERT (!isnand (-2.718));\n  ASSERT (!isnand (-2.718e30));\n  ASSERT (!isnand (-2.718e-30));\n  ASSERT (!isnand (0.0));\n  ASSERT (!isnand (minus_zerod));\n  /* Infinite values.  */\n  ASSERT (!isnand (Infinityd ()));\n  ASSERT (!isnand (- Infinityd ()));\n  /* Quiet NaN.  */\n  ASSERT (isnand (NaNd ()));\n#if defined DBL_EXPBIT0_WORD && defined DBL_EXPBIT0_BIT\n  /* Signalling NaN.  */\n  {\n    #define NWORDS \\\n      ((sizeof (double) + sizeof (unsigned int) - 1) / sizeof (unsigned int))\n    typedef union { double value; unsigned int word[NWORDS]; } memory_double;\n    memory_double m;\n    m.value = NaNd ();\n# if DBL_EXPBIT0_BIT > 0\n    m.word[DBL_EXPBIT0_WORD] ^= (unsigned int) 1 << (DBL_EXPBIT0_BIT - 1);\n# else\n    m.word[DBL_EXPBIT0_WORD + (DBL_EXPBIT0_WORD < NWORDS / 2 ? 1 : - 1)]\n      ^= (unsigned int) 1 << (sizeof (unsigned int) * CHAR_BIT - 1);\n# endif\n    m.word[DBL_EXPBIT0_WORD + (DBL_EXPBIT0_WORD < NWORDS / 2 ? 1 : - 1)]\n      |= (unsigned int) 1 << DBL_EXPBIT0_BIT;\n    ASSERT (isnand (m.value));\n  }\n#endif\n  return 0;\n}",
      "lines": 38,
      "depth": 16,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-isnanf-nolibm.c": {},
  "findutils/findutils-4.6.0/tests/test-isnanf.h": {
    "main": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "int\nmain ()\n{\n  /* Finite values.  */\n  ASSERT (!isnanf (3.141f));\n  ASSERT (!isnanf (3.141e30f));\n  ASSERT (!isnanf (3.141e-30f));\n  ASSERT (!isnanf (-2.718f));\n  ASSERT (!isnanf (-2.718e30f));\n  ASSERT (!isnanf (-2.718e-30f));\n  ASSERT (!isnanf (0.0f));\n  ASSERT (!isnanf (minus_zerof));\n  /* Infinite values.  */\n  ASSERT (!isnanf (Infinityf ()));\n  ASSERT (!isnanf (- Infinityf ()));\n  /* Quiet NaN.  */\n  ASSERT (isnanf (NaNf ()));\n#if defined FLT_EXPBIT0_WORD && defined FLT_EXPBIT0_BIT\n  /* Signalling NaN.  */\n  {\n    #define NWORDS \\\n      ((sizeof (float) + sizeof (unsigned int) - 1) / sizeof (unsigned int))\n    typedef union { float value; unsigned int word[NWORDS]; } memory_float;\n    memory_float m;\n    m.value = NaNf ();\n# if FLT_EXPBIT0_BIT > 0\n    m.word[FLT_EXPBIT0_WORD] ^= (unsigned int) 1 << (FLT_EXPBIT0_BIT - 1);\n# else\n    m.word[FLT_EXPBIT0_WORD + (FLT_EXPBIT0_WORD < NWORDS / 2 ? 1 : - 1)]\n      ^= (unsigned int) 1 << (sizeof (unsigned int) * CHAR_BIT - 1);\n# endif\n    if (FLT_EXPBIT0_WORD < NWORDS / 2)\n      m.word[FLT_EXPBIT0_WORD + 1] |= (unsigned int) 1 << FLT_EXPBIT0_BIT;\n    else\n      m.word[0] |= (unsigned int) 1;\n    ASSERT (isnanf (m.value));\n  }\n#endif\n  return 0;\n}",
      "lines": 40,
      "depth": 16,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-isnanl-nolibm.c": {},
  "findutils/findutils-4.6.0/tests/test-isnanl.h": {
    "main": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        129,
        1
      ],
      "content": "int\nmain ()\n{\n  #define NWORDS \\\n    ((sizeof (long double) + sizeof (unsigned int) - 1) / sizeof (unsigned int))\n  typedef union { unsigned int word[NWORDS]; long double value; }\n          memory_long_double;\n\n  /* Finite values.  */\n  ASSERT (!isnanl (3.141L));\n  ASSERT (!isnanl (3.141e30L));\n  ASSERT (!isnanl (3.141e-30L));\n  ASSERT (!isnanl (-2.718L));\n  ASSERT (!isnanl (-2.718e30L));\n  ASSERT (!isnanl (-2.718e-30L));\n  ASSERT (!isnanl (0.0L));\n  ASSERT (!isnanl (minus_zerol));\n  /* Infinite values.  */\n  ASSERT (!isnanl (Infinityl ()));\n  ASSERT (!isnanl (- Infinityl ()));\n  /* Quiet NaN.  */\n  ASSERT (isnanl (NaNl ()));\n\n#if defined LDBL_EXPBIT0_WORD && defined LDBL_EXPBIT0_BIT\n  /* A bit pattern that is different from a Quiet NaN.  With a bit of luck,\n     it's a Signalling NaN.  */\n  {\n#if defined __powerpc__ && LDBL_MANT_DIG == 106\n    /* This is PowerPC \"double double\", a pair of two doubles.  Inf and Nan are\n       represented as the corresponding 64-bit IEEE values in the first double;\n       the second is ignored.  Manipulate only the first double.  */\n    #undef NWORDS\n    #define NWORDS \\\n      ((sizeof (double) + sizeof (unsigned int) - 1) / sizeof (unsigned int))\n#endif\n\n    memory_long_double m;\n    m.value = NaNl ();\n# if LDBL_EXPBIT0_BIT > 0\n    m.word[LDBL_EXPBIT0_WORD] ^= (unsigned int) 1 << (LDBL_EXPBIT0_BIT - 1);\n# else\n    m.word[LDBL_EXPBIT0_WORD + (LDBL_EXPBIT0_WORD < NWORDS / 2 ? 1 : - 1)]\n      ^= (unsigned int) 1 << (sizeof (unsigned int) * CHAR_BIT - 1);\n# endif\n    m.word[LDBL_EXPBIT0_WORD + (LDBL_EXPBIT0_WORD < NWORDS / 2 ? 1 : - 1)]\n      |= (unsigned int) 1 << LDBL_EXPBIT0_BIT;\n    ASSERT (isnanl (m.value));\n  }\n#endif\n\n#if ((defined __ia64 && LDBL_MANT_DIG == 64) || (defined __x86_64__ || defined __amd64__) || (defined __i386 || defined __i386__ || defined _I386 || defined _M_IX86 || defined _X86_)) && !HAVE_SAME_LONG_DOUBLE_AS_DOUBLE\n/* Representation of an 80-bit 'long double' as an initializer for a sequence\n   of 'unsigned int' words.  */\n# ifdef WORDS_BIGENDIAN\n#  define LDBL80_WORDS(exponent,manthi,mantlo) \\\n     { ((unsigned int) (exponent) << 16) | ((unsigned int) (manthi) >> 16), \\\n       ((unsigned int) (manthi) << 16) | ((unsigned int) (mantlo) >> 16),   \\\n       (unsigned int) (mantlo) << 16                                        \\\n     }\n# else\n#  define LDBL80_WORDS(exponent,manthi,mantlo) \\\n     { mantlo, manthi, exponent }\n# endif\n  { /* Quiet NaN.  */\n    static memory_long_double x =\n      { LDBL80_WORDS (0xFFFF, 0xC3333333, 0x00000000) };\n    ASSERT (isnanl (x.value));\n  }\n  {\n    /* Signalling NaN.  */\n    static memory_long_double x =\n      { LDBL80_WORDS (0xFFFF, 0x83333333, 0x00000000) };\n    ASSERT (isnanl (x.value));\n  }\n  /* isnanl should return something for noncanonical values.  */\n  { /* Pseudo-NaN.  */\n    static memory_long_double x =\n      { LDBL80_WORDS (0xFFFF, 0x40000001, 0x00000000) };\n    ASSERT (isnanl (x.value) || !isnanl (x.value));\n  }\n  { /* Pseudo-Infinity.  */\n    static memory_long_double x =\n      { LDBL80_WORDS (0xFFFF, 0x00000000, 0x00000000) };\n    ASSERT (isnanl (x.value) || !isnanl (x.value));\n  }\n  { /* Pseudo-Zero.  */\n    static memory_long_double x =\n      { LDBL80_WORDS (0x4004, 0x00000000, 0x00000000) };\n    ASSERT (isnanl (x.value) || !isnanl (x.value));\n  }\n  { /* Unnormalized number.  */\n    static memory_long_double x =\n      { LDBL80_WORDS (0x4000, 0x63333333, 0x00000000) };\n    ASSERT (isnanl (x.value) || !isnanl (x.value));\n  }\n  { /* Pseudo-Denormal.  */\n    static memory_long_double x =\n      { LDBL80_WORDS (0x0000, 0x83333333, 0x00000000) };\n    ASSERT (isnanl (x.value) || !isnanl (x.value));\n  }\n#endif\n\n  return 0;\n}",
      "lines": 104,
      "depth": 16,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-iswblank.c": {
    "main": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        34,
        1
      ],
      "content": "int\nmain (void)\n{\n  /* Check that the function exist as a function or as a macro.  */\n  (void) iswblank (0);\n  /* Check that the isw* functions map WEOF to 0.  */\n  ASSERT (!iswblank (e));\n\n  return 0;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-langinfo.c": {
    "main": {
      "start_point": [
        87,
        0
      ],
      "end_point": [
        91,
        1
      ],
      "content": "int\nmain (void)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-listen.c": {
    "main": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "int\nmain (void)\n{\n  (void) gl_sockets_startup (SOCKETS_1_1);\n\n  /* Test behaviour for invalid file descriptors.  */\n  {\n    errno = 0;\n    ASSERT (listen (-1, 1) == -1);\n    ASSERT (errno == EBADF);\n  }\n  {\n    close (99);\n    errno = 0;\n    ASSERT (listen (99 ,1) == -1);\n    ASSERT (errno == EBADF);\n  }\n\n  return 0;\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-locale.c": {
    "main": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "int\nmain ()\n{\n#if HAVE_NEWLOCALE\n  /* Check that the locale_t type and the LC_GLOBAL_LOCALE macro are defined.  */\n  locale_t b = LC_GLOBAL_LOCALE;\n  (void) b;\n#endif\n\n  /* Check that 'struct lconv' has the ISO C and POSIX specified members.  */\n  ls += sizeof (*l.decimal_point);\n  ls += sizeof (*l.thousands_sep);\n  ls += sizeof (*l.grouping);\n  ls += sizeof (*l.mon_decimal_point);\n  ls += sizeof (*l.mon_thousands_sep);\n  ls += sizeof (*l.mon_grouping);\n  ls += sizeof (*l.positive_sign);\n  ls += sizeof (*l.negative_sign);\n  ls += sizeof (*l.currency_symbol);\n  ls += sizeof (l.frac_digits);\n  ls += sizeof (l.p_cs_precedes);\n  ls += sizeof (l.p_sign_posn);\n  ls += sizeof (l.p_sep_by_space);\n  ls += sizeof (l.n_cs_precedes);\n  ls += sizeof (l.n_sign_posn);\n  ls += sizeof (l.n_sep_by_space);\n  ls += sizeof (*l.int_curr_symbol);\n  ls += sizeof (l.int_frac_digits);\n  ls += sizeof (l.int_p_cs_precedes);\n  ls += sizeof (l.int_p_sign_posn);\n  ls += sizeof (l.int_p_sep_by_space);\n  ls += sizeof (l.int_n_cs_precedes);\n  ls += sizeof (l.int_n_sign_posn);\n  ls += sizeof (l.int_n_sep_by_space);\n\n  return 0;\n}",
      "lines": 37,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-localeconv.c": {
    "main": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "int\nmain ()\n{\n  /* Test localeconv() result in the \"C\" locale.  */\n  {\n    struct lconv *l = localeconv ();\n\n    ASSERT (STREQ (l->decimal_point, \".\"));\n    ASSERT (STREQ (l->thousands_sep, \"\"));\n#if !(defined __FreeBSD__ || defined __sun)\n    ASSERT (STREQ (l->grouping, \"\"));\n#endif\n\n    ASSERT (STREQ (l->mon_decimal_point, \"\"));\n    ASSERT (STREQ (l->mon_thousands_sep, \"\"));\n#if !(defined __FreeBSD__ || defined __sun)\n    ASSERT (STREQ (l->mon_grouping, \"\"));\n#endif\n    ASSERT (STREQ (l->positive_sign, \"\"));\n    ASSERT (STREQ (l->negative_sign, \"\"));\n\n    ASSERT (STREQ (l->currency_symbol, \"\"));\n    ASSERT (l->frac_digits == CHAR_MAX);\n    ASSERT (l->p_cs_precedes == CHAR_MAX);\n    ASSERT (l->p_sign_posn == CHAR_MAX);\n    ASSERT (l->p_sep_by_space == CHAR_MAX);\n    ASSERT (l->n_cs_precedes == CHAR_MAX);\n    ASSERT (l->n_sign_posn == CHAR_MAX);\n    ASSERT (l->n_sep_by_space == CHAR_MAX);\n\n    ASSERT (STREQ (l->int_curr_symbol, \"\"));\n    ASSERT (l->int_frac_digits == CHAR_MAX);\n    ASSERT (l->int_p_cs_precedes == CHAR_MAX);\n    ASSERT (l->int_p_sign_posn == CHAR_MAX);\n    ASSERT (l->int_p_sep_by_space == CHAR_MAX);\n    ASSERT (l->int_n_cs_precedes == CHAR_MAX);\n    ASSERT (l->int_n_sign_posn == CHAR_MAX);\n    ASSERT (l->int_n_sep_by_space == CHAR_MAX);\n  }\n\n  return 0;\n}",
      "lines": 42,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-localename.c": {
    "test_locale_name": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        219,
        1
      ],
      "content": "static void\ntest_locale_name (void)\n{\n  const char *name;\n\n  /* Check that gl_locale_name returns non-NULL.  */\n  ASSERT (gl_locale_name (LC_MESSAGES, \"LC_MESSAGES\") != NULL);\n\n  /* Get into a defined state,  */\n  setlocale (LC_ALL, \"en_US.UTF-8\");\n#if HAVE_NEWLOCALE\n  uselocale (LC_GLOBAL_LOCALE);\n#endif\n\n  /* Check that when all environment variables are unset,\n     gl_locale_name returns the default locale.  */\n  unsetenv (\"LC_ALL\");\n  unsetenv (\"LC_CTYPE\");\n  unsetenv (\"LC_MESSAGES\");\n  unsetenv (\"LC_NUMERIC\");\n  unsetenv (\"LANG\");\n  setlocale (LC_ALL, \"\");\n  ASSERT (strcmp (gl_locale_name (LC_MESSAGES, \"LC_MESSAGES\"),\n                  gl_locale_name_default ()) == 0);\n  ASSERT (strcmp (gl_locale_name (LC_NUMERIC, \"LC_NUMERIC\"),\n                  gl_locale_name_default ()) == 0);\n\n  /* Check that an empty environment variable is treated like an unset\n     environment variable.  */\n\n  setenv (\"LC_ALL\", \"\", 1);\n  unsetenv (\"LC_CTYPE\");\n  unsetenv (\"LC_MESSAGES\");\n  unsetenv (\"LANG\");\n  setlocale (LC_ALL, \"\");\n  ASSERT (strcmp (gl_locale_name (LC_MESSAGES, \"LC_MESSAGES\"),\n                  gl_locale_name_default ()) == 0);\n\n  unsetenv (\"LC_ALL\");\n  setenv (\"LC_CTYPE\", \"\", 1);\n  unsetenv (\"LC_MESSAGES\");\n  unsetenv (\"LANG\");\n  setlocale (LC_ALL, \"\");\n  ASSERT (strcmp (gl_locale_name (LC_MESSAGES, \"LC_MESSAGES\"),\n                  gl_locale_name_default ()) == 0);\n\n  unsetenv (\"LC_ALL\");\n  unsetenv (\"LC_CTYPE\");\n  setenv (\"LC_MESSAGES\", \"\", 1);\n  unsetenv (\"LANG\");\n  setlocale (LC_ALL, \"\");\n  ASSERT (strcmp (gl_locale_name (LC_MESSAGES, \"LC_MESSAGES\"),\n                  gl_locale_name_default ()) == 0);\n\n  unsetenv (\"LC_ALL\");\n  unsetenv (\"LC_CTYPE\");\n  unsetenv (\"LC_MESSAGES\");\n  setenv (\"LANG\", \"\", 1);\n  setlocale (LC_ALL, \"\");\n  ASSERT (strcmp (gl_locale_name (LC_MESSAGES, \"LC_MESSAGES\"),\n                  gl_locale_name_default ()) == 0);\n\n  /* Check that LC_ALL overrides the others, and LANG is overridden by the\n     others.  */\n\n  setenv (\"LC_ALL\", \"C\", 1);\n  unsetenv (\"LC_CTYPE\");\n  unsetenv (\"LC_MESSAGES\");\n  unsetenv (\"LANG\");\n  setlocale (LC_ALL, \"\");\n  ASSERT (strcmp (gl_locale_name (LC_MESSAGES, \"LC_MESSAGES\"), \"C\") == 0);\n\n  unsetenv (\"LC_ALL\");\n  setenv (\"LC_CTYPE\", \"C\", 1);\n  setenv (\"LC_MESSAGES\", \"C\", 1);\n  unsetenv (\"LANG\");\n  setlocale (LC_ALL, \"\");\n  ASSERT (strcmp (gl_locale_name (LC_MESSAGES, \"LC_MESSAGES\"), \"C\") == 0);\n\n  unsetenv (\"LC_ALL\");\n  unsetenv (\"LC_CTYPE\");\n  unsetenv (\"LC_MESSAGES\");\n  setenv (\"LANG\", \"C\", 1);\n  setlocale (LC_ALL, \"\");\n  ASSERT (strcmp (gl_locale_name (LC_MESSAGES, \"LC_MESSAGES\"), \"C\") == 0);\n\n  /* Check mixed situations.  */\n\n  unsetenv (\"LC_ALL\");\n  unsetenv (\"LC_CTYPE\");\n  setenv (\"LC_MESSAGES\", \"fr_FR.UTF-8\", 1);\n  setenv (\"LANG\", \"de_DE.UTF-8\", 1);\n  if (setlocale (LC_ALL, \"\") != NULL)\n    {\n      name = gl_locale_name (LC_CTYPE, \"LC_CTYPE\");\n      ASSERT (strcmp (name, \"de_DE.UTF-8\") == 0);\n      name = gl_locale_name (LC_MESSAGES, \"LC_MESSAGES\");\n      ASSERT (strcmp (name, \"fr_FR.UTF-8\") == 0);\n    }\n\n  unsetenv (\"LC_ALL\");\n  unsetenv (\"LC_CTYPE\");\n  setenv (\"LC_MESSAGES\", \"fr_FR.UTF-8\", 1);\n  unsetenv (\"LANG\");\n  if (setlocale (LC_ALL, \"\") != NULL)\n    {\n      name = gl_locale_name (LC_CTYPE, \"LC_CTYPE\");\n      ASSERT (strcmp (name, gl_locale_name_default ()) == 0);\n      name = gl_locale_name (LC_MESSAGES, \"LC_MESSAGES\");\n      ASSERT (strcmp (name, \"fr_FR.UTF-8\") == 0);\n    }\n\n#if HAVE_NEWLOCALE\n  /* Check that gl_locale_name considers the thread locale.  */\n  {\n    locale_t locale = newlocale (LC_ALL_MASK, \"fr_FR.UTF-8\", NULL);\n    if (locale != NULL)\n      {\n        uselocale (locale);\n        name = gl_locale_name (LC_CTYPE, \"LC_CTYPE\");\n        ASSERT (strcmp (name, \"fr_FR.UTF-8\") == 0);\n        name = gl_locale_name (LC_MESSAGES, \"LC_MESSAGES\");\n        ASSERT (strcmp (name, \"fr_FR.UTF-8\") == 0);\n      }\n  }\n\n  /* Check that gl_locale_name distinguishes different categories of the\n     thread locale, and that the name is the right one for each.  */\n  {\n    unsigned int i;\n\n    for (i = 0; i < SIZEOF (categories); i++)\n      {\n        int category_mask = categories[i].mask;\n        locale_t locale = newlocale (LC_ALL_MASK, \"fr_FR.UTF-8\", NULL);\n        if (locale != NULL)\n          {\n            locale = newlocale (category_mask, \"de_DE.UTF-8\", locale);\n            if (locale != NULL)\n              {\n                unsigned int j;\n\n                uselocale (locale);\n                for (j = 0; j < SIZEOF (categories); j++)\n                  {\n                    const char *name_j =\n                      gl_locale_name (categories[j].cat, categories[j].string);\n                    if (j == i)\n                      ASSERT (strcmp (name_j, \"de_DE.UTF-8\") == 0);\n                    else\n                      ASSERT (strcmp (name_j, \"fr_FR.UTF-8\") == 0);\n                  }\n              }\n          }\n      }\n  }\n#endif\n}",
      "lines": 158,
      "depth": 21,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_locale_name_thread": {
      "start_point": [
        222,
        0
      ],
      "end_point": [
        463,
        1
      ],
      "content": "static void\ntest_locale_name_thread (void)\n{\n  /* Get into a defined state,  */\n  setlocale (LC_ALL, \"en_US.UTF-8\");\n\n#if HAVE_NEWLOCALE\n  /* Check that gl_locale_name_thread returns NULL when no thread locale is\n     set.  */\n  uselocale (LC_GLOBAL_LOCALE);\n  ASSERT (gl_locale_name_thread (LC_CTYPE, \"LC_CTYPE\") == NULL);\n  ASSERT (gl_locale_name_thread (LC_MESSAGES, \"LC_MESSAGES\") == NULL);\n\n  /* Check that gl_locale_name_thread considers the thread locale.  */\n  {\n    locale_t locale = newlocale (LC_ALL_MASK, \"fr_FR.UTF-8\", NULL);\n    if (locale != NULL)\n      {\n        const char *name;\n\n        uselocale (locale);\n        name = gl_locale_name_thread (LC_CTYPE, \"LC_CTYPE\");\n        ASSERT (strcmp (name, \"fr_FR.UTF-8\") == 0);\n        name = gl_locale_name_thread (LC_MESSAGES, \"LC_MESSAGES\");\n        ASSERT (strcmp (name, \"fr_FR.UTF-8\") == 0);\n      }\n  }\n\n  /* Check that gl_locale_name_thread distinguishes different categories of the\n     thread locale, and that the name is the right one for each.  */\n  {\n    unsigned int i;\n\n    for (i = 0; i < SIZEOF (categories); i++)\n      {\n        int category_mask = categories[i].mask;\n        locale_t locale = newlocale (LC_ALL_MASK, \"fr_FR.UTF-8\", NULL);\n        if (locale != NULL)\n          {\n            locale = newlocale (category_mask, \"de_DE.UTF-8\", locale);\n            if (locale != NULL)\n              {\n                unsigned int j;\n\n                uselocale (locale);\n                for (j = 0; j < SIZEOF (categories); j++)\n                  {\n                    const char *name_j =\n                      gl_locale_name_thread (categories[j].cat,\n                                             categories[j].string);\n                    if (j == i)\n                      ASSERT (strcmp (name_j, \"de_DE.UTF-8\") == 0);\n                    else\n                      ASSERT (strcmp (name_j, \"fr_FR.UTF-8\") == 0);\n                  }\n              }\n          }\n      }\n  }\n\n  /* Check that gl_locale_name_thread returns a string that is allocated with\n     indefinite extent.  */\n  {\n    /* Try many locale names in turn, in order to defeat possible caches.  */\n    static const char * const choices[] =\n      {\n        \"C\",\n        \"POSIX\",\n        \"af_ZA\",\n        \"af_ZA.UTF-8\",\n        \"am_ET\",\n        \"am_ET.UTF-8\",\n        \"be_BY\",\n        \"be_BY.UTF-8\",\n        \"bg_BG\",\n        \"bg_BG.UTF-8\",\n        \"ca_ES\",\n        \"ca_ES.UTF-8\",\n        \"cs_CZ\",\n        \"cs_CZ.UTF-8\",\n        \"da_DK\",\n        \"da_DK.UTF-8\",\n        \"de_AT\",\n        \"de_AT.UTF-8\",\n        \"de_CH\",\n        \"de_CH.UTF-8\",\n        \"de_DE\",\n        \"de_DE.UTF-8\",\n        \"el_GR\",\n        \"el_GR.UTF-8\",\n        \"en_AU\",\n        \"en_AU.UTF-8\",\n        \"en_CA\",\n        \"en_CA.UTF-8\",\n        \"en_GB\",\n        \"en_GB.UTF-8\",\n        \"en_IE\",\n        \"en_IE.UTF-8\",\n        \"en_NZ\",\n        \"en_NZ.UTF-8\",\n        \"en_US\",\n        \"en_US.UTF-8\",\n        \"es_ES\",\n        \"es_ES.UTF-8\",\n        \"et_EE\",\n        \"et_EE.UTF-8\",\n        \"eu_ES\",\n        \"eu_ES.UTF-8\",\n        \"fi_FI\",\n        \"fi_FI.UTF-8\",\n        \"fr_BE\",\n        \"fr_BE.UTF-8\",\n        \"fr_CA\",\n        \"fr_CA.UTF-8\",\n        \"fr_CH\",\n        \"fr_CH.UTF-8\",\n        \"fr_FR\",\n        \"fr_FR.UTF-8\",\n        \"he_IL\",\n        \"he_IL.UTF-8\",\n        \"hr_HR\",\n        \"hr_HR.UTF-8\",\n        \"hu_HU\",\n        \"hu_HU.UTF-8\",\n        \"hy_AM\",\n        \"is_IS\",\n        \"is_IS.UTF-8\",\n        \"it_CH\",\n        \"it_CH.UTF-8\",\n        \"it_IT\",\n        \"it_IT.UTF-8\",\n        \"ja_JP.UTF-8\",\n        \"kk_KZ\",\n        \"kk_KZ.UTF-8\",\n        \"ko_KR.UTF-8\",\n        \"lt_LT\",\n        \"lt_LT.UTF-8\",\n        \"nl_BE\",\n        \"nl_BE.UTF-8\",\n        \"nl_NL\",\n        \"nl_NL.UTF-8\",\n        \"no_NO\",\n        \"no_NO.UTF-8\",\n        \"pl_PL\",\n        \"pl_PL.UTF-8\",\n        \"pt_BR\",\n        \"pt_BR.UTF-8\",\n        \"pt_PT\",\n        \"pt_PT.UTF-8\",\n        \"ro_RO\",\n        \"ro_RO.UTF-8\",\n        \"ru_RU\",\n        \"ru_RU.UTF-8\",\n        \"sk_SK\",\n        \"sk_SK.UTF-8\",\n        \"sl_SI\",\n        \"sl_SI.UTF-8\",\n        \"sv_SE\",\n        \"sv_SE.UTF-8\",\n        \"tr_TR\",\n        \"tr_TR.UTF-8\",\n        \"uk_UA\",\n        \"uk_UA.UTF-8\",\n        \"zh_CN\",\n        \"zh_CN.UTF-8\",\n        \"zh_HK\",\n        \"zh_HK.UTF-8\",\n        \"zh_TW\",\n        \"zh_TW.UTF-8\"\n      };\n    /* Remember which locales are available.  */\n    unsigned char /* bool */ available[SIZEOF (choices)];\n    /* Array of remembered results of gl_locale_name_thread.  */\n    const char *unsaved_names[SIZEOF (choices)][SIZEOF (categories)];\n    /* Array of remembered results of gl_locale_name_thread, stored in safe\n       memory.  */\n    char *saved_names[SIZEOF (choices)][SIZEOF (categories)];\n    unsigned int j;\n\n    for (j = 0; j < SIZEOF (choices); j++)\n      {\n        locale_t locale = newlocale (LC_ALL_MASK, choices[j], NULL);\n        available[j] = (locale != NULL);\n        if (locale != NULL)\n          {\n            unsigned int i;\n\n            uselocale (locale);\n            for (i = 0; i < SIZEOF (categories); i++)\n              {\n                unsaved_names[j][i] = gl_locale_name_thread (categories[i].cat, categories[i].string);\n                saved_names[j][i] = strdup (unsaved_names[j][i]);\n              }\n            uselocale (LC_GLOBAL_LOCALE);\n            freelocale (locale);\n          }\n      }\n    /* Verify the unsaved_names are still valid.  */\n    for (j = 0; j < SIZEOF (choices); j++)\n      if (available[j])\n        {\n          unsigned int i;\n\n          for (i = 0; i < SIZEOF (categories); i++)\n            ASSERT (strcmp (unsaved_names[j][i], saved_names[j][i]) == 0);\n        }\n    /* Allocate many locales, without freeing them.  This is an attempt at\n       overwriting as much of the previously allocated memory as possible.  */\n    for (j = SIZEOF (choices); j > 0; )\n      {\n        j--;\n        if (available[j])\n          {\n            locale_t locale = newlocale (LC_ALL_MASK, choices[j], NULL);\n            unsigned int i;\n\n            ASSERT (locale != NULL);\n            uselocale (locale);\n            for (i = 0; i < SIZEOF (categories); i++)\n              {\n                const char *name = gl_locale_name_thread (categories[i].cat, categories[i].string);\n                ASSERT (strcmp (unsaved_names[j][i], name) == 0);\n              }\n            uselocale (LC_GLOBAL_LOCALE);\n          }\n      }\n    /* Verify the unsaved_names are still valid.  */\n    for (j = 0; j < SIZEOF (choices); j++)\n      if (available[j])\n        {\n          unsigned int i;\n\n          for (i = 0; i < SIZEOF (categories); i++)\n            ASSERT (strcmp (unsaved_names[j][i], saved_names[j][i]) == 0);\n        }\n  }\n#else\n  /* Check that gl_locale_name_thread always returns NULL.  */\n  ASSERT (gl_locale_name_thread (LC_CTYPE, \"LC_CTYPE\") == NULL);\n  ASSERT (gl_locale_name_thread (LC_MESSAGES, \"LC_MESSAGES\") == NULL);\n#endif\n}",
      "lines": 242,
      "depth": 21,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_locale_name_posix": {
      "start_point": [
        466,
        0
      ],
      "end_point": [
        595,
        1
      ],
      "content": "static void\ntest_locale_name_posix (void)\n{\n  const char *name;\n\n  /* Get into a defined state,  */\n  setlocale (LC_ALL, \"en_US.UTF-8\");\n#if HAVE_NEWLOCALE\n  uselocale (LC_GLOBAL_LOCALE);\n#endif\n\n  /* Check that when all environment variables are unset,\n     gl_locale_name_posix returns either NULL or the default locale.  */\n  unsetenv (\"LC_ALL\");\n  unsetenv (\"LC_CTYPE\");\n  unsetenv (\"LC_MESSAGES\");\n  unsetenv (\"LC_NUMERIC\");\n  unsetenv (\"LANG\");\n  setlocale (LC_ALL, \"\");\n  name = gl_locale_name_posix (LC_MESSAGES, \"LC_MESSAGES\");\n  ASSERT (name == NULL || strcmp (name, gl_locale_name_default ()) == 0);\n  name = gl_locale_name_posix (LC_NUMERIC, \"LC_NUMERIC\");\n  ASSERT (name == NULL || strcmp (name, gl_locale_name_default ()) == 0);\n\n  /* Check that an empty environment variable is treated like an unset\n     environment variable.  */\n\n  setenv (\"LC_ALL\", \"\", 1);\n  unsetenv (\"LC_CTYPE\");\n  unsetenv (\"LC_MESSAGES\");\n  unsetenv (\"LANG\");\n  setlocale (LC_ALL, \"\");\n  name = gl_locale_name_posix (LC_MESSAGES, \"LC_MESSAGES\");\n  ASSERT (name == NULL || strcmp (name, gl_locale_name_default ()) == 0);\n\n  unsetenv (\"LC_ALL\");\n  setenv (\"LC_CTYPE\", \"\", 1);\n  unsetenv (\"LC_MESSAGES\");\n  unsetenv (\"LANG\");\n  setlocale (LC_ALL, \"\");\n  name = gl_locale_name_posix (LC_MESSAGES, \"LC_MESSAGES\");\n  ASSERT (name == NULL || strcmp (name, gl_locale_name_default ()) == 0);\n\n  unsetenv (\"LC_ALL\");\n  unsetenv (\"LC_CTYPE\");\n  setenv (\"LC_MESSAGES\", \"\", 1);\n  unsetenv (\"LANG\");\n  setlocale (LC_ALL, \"\");\n  name = gl_locale_name_posix (LC_MESSAGES, \"LC_MESSAGES\");\n  ASSERT (name == NULL || strcmp (name, gl_locale_name_default ()) == 0);\n\n  unsetenv (\"LC_ALL\");\n  unsetenv (\"LC_CTYPE\");\n  unsetenv (\"LC_MESSAGES\");\n  setenv (\"LANG\", \"\", 1);\n  setlocale (LC_ALL, \"\");\n  name = gl_locale_name_posix (LC_MESSAGES, \"LC_MESSAGES\");\n  ASSERT (name == NULL || strcmp (name, gl_locale_name_default ()) == 0);\n\n  /* Check that LC_ALL overrides the others, and LANG is overridden by the\n     others.  */\n\n  setenv (\"LC_ALL\", \"C\", 1);\n  unsetenv (\"LC_CTYPE\");\n  unsetenv (\"LC_MESSAGES\");\n  unsetenv (\"LANG\");\n  setlocale (LC_ALL, \"\");\n  name = gl_locale_name_posix (LC_MESSAGES, \"LC_MESSAGES\");\n  ASSERT (strcmp (name, \"C\") == 0);\n\n  unsetenv (\"LC_ALL\");\n  setenv (\"LC_CTYPE\", \"C\", 1);\n  setenv (\"LC_MESSAGES\", \"C\", 1);\n  unsetenv (\"LANG\");\n  setlocale (LC_ALL, \"\");\n  name = gl_locale_name_posix (LC_MESSAGES, \"LC_MESSAGES\");\n  ASSERT (strcmp (name, \"C\") == 0);\n\n  unsetenv (\"LC_ALL\");\n  unsetenv (\"LC_CTYPE\");\n  unsetenv (\"LC_MESSAGES\");\n  setenv (\"LANG\", \"C\", 1);\n  setlocale (LC_ALL, \"\");\n  name = gl_locale_name_posix (LC_MESSAGES, \"LC_MESSAGES\");\n  ASSERT (strcmp (name, \"C\") == 0);\n\n  /* Check mixed situations.  */\n\n  unsetenv (\"LC_ALL\");\n  unsetenv (\"LC_CTYPE\");\n  setenv (\"LC_MESSAGES\", \"fr_FR.UTF-8\", 1);\n  setenv (\"LANG\", \"de_DE.UTF-8\", 1);\n  if (setlocale (LC_ALL, \"\") != NULL)\n    {\n      name = gl_locale_name_posix (LC_CTYPE, \"LC_CTYPE\");\n      ASSERT (strcmp (name, \"de_DE.UTF-8\") == 0);\n      name = gl_locale_name_posix (LC_MESSAGES, \"LC_MESSAGES\");\n      ASSERT (strcmp (name, \"fr_FR.UTF-8\") == 0);\n    }\n\n  unsetenv (\"LC_ALL\");\n  unsetenv (\"LC_CTYPE\");\n  setenv (\"LC_MESSAGES\", \"fr_FR.UTF-8\", 1);\n  unsetenv (\"LANG\");\n  if (setlocale (LC_ALL, \"\") != NULL)\n    {\n      name = gl_locale_name_posix (LC_CTYPE, \"LC_CTYPE\");\n      ASSERT (name == NULL || strcmp (name, gl_locale_name_default ()) == 0);\n      name = gl_locale_name_posix (LC_MESSAGES, \"LC_MESSAGES\");\n      ASSERT (strcmp (name, \"fr_FR.UTF-8\") == 0);\n    }\n\n#if HAVE_NEWLOCALE\n  /* Check that gl_locale_name_posix ignores the thread locale.  */\n  {\n    locale_t locale = newlocale (LC_ALL_MASK, \"fr_FR.UTF-8\", NULL);\n    if (locale != NULL)\n      {\n        unsetenv (\"LC_ALL\");\n        unsetenv (\"LC_CTYPE\");\n        unsetenv (\"LC_MESSAGES\");\n        setenv (\"LANG\", \"C\", 1);\n        setlocale (LC_ALL, \"\");\n        uselocale (locale);\n        name = gl_locale_name_posix (LC_MESSAGES, \"LC_MESSAGES\");\n        ASSERT (strcmp (name, \"C\") == 0);\n      }\n  }\n#endif\n}",
      "lines": 130,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_locale_name_environ": {
      "start_point": [
        598,
        0
      ],
      "end_point": [
        707,
        1
      ],
      "content": "static void\ntest_locale_name_environ (void)\n{\n  const char *name;\n\n  /* Get into a defined state,  */\n  setlocale (LC_ALL, \"en_US.UTF-8\");\n#if HAVE_NEWLOCALE\n  uselocale (LC_GLOBAL_LOCALE);\n#endif\n\n  /* Check that when all environment variables are unset,\n     gl_locale_name_environ returns NULL.  */\n  unsetenv (\"LC_ALL\");\n  unsetenv (\"LC_CTYPE\");\n  unsetenv (\"LC_MESSAGES\");\n  unsetenv (\"LC_NUMERIC\");\n  unsetenv (\"LANG\");\n  ASSERT (gl_locale_name_environ (LC_MESSAGES, \"LC_MESSAGES\") == NULL);\n  ASSERT (gl_locale_name_environ (LC_NUMERIC, \"LC_NUMERIC\") == NULL);\n\n  /* Check that an empty environment variable is treated like an unset\n     environment variable.  */\n\n  setenv (\"LC_ALL\", \"\", 1);\n  unsetenv (\"LC_CTYPE\");\n  unsetenv (\"LC_MESSAGES\");\n  unsetenv (\"LANG\");\n  ASSERT (gl_locale_name_environ (LC_MESSAGES, \"LC_MESSAGES\") == NULL);\n\n  unsetenv (\"LC_ALL\");\n  setenv (\"LC_CTYPE\", \"\", 1);\n  unsetenv (\"LC_MESSAGES\");\n  unsetenv (\"LANG\");\n  ASSERT (gl_locale_name_environ (LC_MESSAGES, \"LC_MESSAGES\") == NULL);\n\n  unsetenv (\"LC_ALL\");\n  unsetenv (\"LC_CTYPE\");\n  setenv (\"LC_MESSAGES\", \"\", 1);\n  unsetenv (\"LANG\");\n  ASSERT (gl_locale_name_environ (LC_MESSAGES, \"LC_MESSAGES\") == NULL);\n\n  unsetenv (\"LC_ALL\");\n  unsetenv (\"LC_CTYPE\");\n  unsetenv (\"LC_MESSAGES\");\n  setenv (\"LANG\", \"\", 1);\n  ASSERT (gl_locale_name_environ (LC_MESSAGES, \"LC_MESSAGES\") == NULL);\n\n  /* Check that LC_ALL overrides the others, and LANG is overridden by the\n     others.  */\n\n  setenv (\"LC_ALL\", \"C\", 1);\n  unsetenv (\"LC_CTYPE\");\n  unsetenv (\"LC_MESSAGES\");\n  unsetenv (\"LANG\");\n  name = gl_locale_name_environ (LC_MESSAGES, \"LC_MESSAGES\");\n  ASSERT (strcmp (name, \"C\") == 0);\n\n  unsetenv (\"LC_ALL\");\n  setenv (\"LC_CTYPE\", \"C\", 1);\n  setenv (\"LC_MESSAGES\", \"C\", 1);\n  unsetenv (\"LANG\");\n  name = gl_locale_name_environ (LC_MESSAGES, \"LC_MESSAGES\");\n  ASSERT (strcmp (name, \"C\") == 0);\n\n  unsetenv (\"LC_ALL\");\n  unsetenv (\"LC_CTYPE\");\n  unsetenv (\"LC_MESSAGES\");\n  setenv (\"LANG\", \"C\", 1);\n  name = gl_locale_name_environ (LC_MESSAGES, \"LC_MESSAGES\");\n  ASSERT (strcmp (name, \"C\") == 0);\n\n  /* Check mixed situations.  */\n\n  unsetenv (\"LC_ALL\");\n  unsetenv (\"LC_CTYPE\");\n  setenv (\"LC_MESSAGES\", \"fr_FR.UTF-8\", 1);\n  setenv (\"LANG\", \"de_DE.UTF-8\", 1);\n  name = gl_locale_name_environ (LC_CTYPE, \"LC_CTYPE\");\n  ASSERT (strcmp (name, \"de_DE.UTF-8\") == 0);\n  name = gl_locale_name_environ (LC_MESSAGES, \"LC_MESSAGES\");\n  ASSERT (strcmp (name, \"fr_FR.UTF-8\") == 0);\n\n  unsetenv (\"LC_ALL\");\n  unsetenv (\"LC_CTYPE\");\n  setenv (\"LC_MESSAGES\", \"fr_FR.UTF-8\", 1);\n  unsetenv (\"LANG\");\n  name = gl_locale_name_environ (LC_CTYPE, \"LC_CTYPE\");\n  ASSERT (name == NULL);\n  name = gl_locale_name_environ (LC_MESSAGES, \"LC_MESSAGES\");\n  ASSERT (strcmp (name, \"fr_FR.UTF-8\") == 0);\n\n#if HAVE_NEWLOCALE\n  /* Check that gl_locale_name_environ ignores the thread locale.  */\n  {\n    locale_t locale = newlocale (LC_ALL_MASK, \"fr_FR.UTF-8\", NULL);\n    if (locale != NULL)\n      {\n        unsetenv (\"LC_ALL\");\n        unsetenv (\"LC_CTYPE\");\n        unsetenv (\"LC_MESSAGES\");\n        setenv (\"LANG\", \"C\", 1);\n        setlocale (LC_ALL, \"\");\n        uselocale (locale);\n        name = gl_locale_name_environ (LC_MESSAGES, \"LC_MESSAGES\");\n        ASSERT (strcmp (name, \"C\") == 0);\n      }\n  }\n#endif\n}",
      "lines": 110,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_locale_name_default": {
      "start_point": [
        710,
        0
      ],
      "end_point": [
        734,
        1
      ],
      "content": "static void\ntest_locale_name_default (void)\n{\n  const char *name = gl_locale_name_default ();\n\n  ASSERT (name != NULL);\n\n  /* Only Mac OS X and Windows have a facility for the user to set the default\n     locale.  */\n#if !((defined __APPLE__ && defined __MACH__) || (defined _WIN32 || defined __WIN32__ || defined __CYGWIN__))\n  ASSERT (strcmp (name, \"C\") == 0);\n#endif\n\n#if HAVE_NEWLOCALE\n  /* Check that gl_locale_name_default ignores the thread locale.  */\n  {\n    locale_t locale = newlocale (LC_ALL_MASK, \"fr_FR.UTF-8\", NULL);\n    if (locale != NULL)\n      {\n        uselocale (locale);\n        ASSERT (strcmp (gl_locale_name_default (), name) == 0);\n      }\n  }\n#endif\n}",
      "lines": 25,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        736,
        0
      ],
      "end_point": [
        746,
        1
      ],
      "content": "int\nmain ()\n{\n  test_locale_name ();\n  test_locale_name_thread ();\n  test_locale_name_posix ();\n  test_locale_name_environ ();\n  test_locale_name_default ();\n\n  return 0;\n}",
      "lines": 11,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-lock.c": {
    "random_account": {
      "start_point": [
        109,
        0
      ],
      "end_point": [
        113,
        1
      ],
      "content": "static int\nrandom_account (void)\n{\n  return ((unsigned int) rand () >> 3) % ACCOUNT_COUNT;\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "check_accounts": {
      "start_point": [
        115,
        0
      ],
      "end_point": [
        125,
        1
      ],
      "content": "static void\ncheck_accounts (void)\n{\n  int i, sum;\n\n  sum = 0;\n  for (i = 0; i < ACCOUNT_COUNT; i++)\n    sum += account[i];\n  if (sum != ACCOUNT_COUNT * 1000)\n    abort ();\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "lock_mutator_thread": {
      "start_point": [
        136,
        0
      ],
      "end_point": [
        170,
        1
      ],
      "content": "static void *\nlock_mutator_thread (void *arg)\n{\n  int repeat;\n\n  for (repeat = REPEAT_COUNT; repeat > 0; repeat--)\n    {\n      int i1, i2, value;\n\n      dbgprintf (\"Mutator %p before lock\\n\", gl_thread_self_pointer ());\n      gl_lock_lock (my_lock);\n      dbgprintf (\"Mutator %p after  lock\\n\", gl_thread_self_pointer ());\n\n      i1 = random_account ();\n      i2 = random_account ();\n      value = ((unsigned int) rand () >> 3) % 10;\n      account[i1] += value;\n      account[i2] -= value;\n\n      dbgprintf (\"Mutator %p before unlock\\n\", gl_thread_self_pointer ());\n      gl_lock_unlock (my_lock);\n      dbgprintf (\"Mutator %p after  unlock\\n\", gl_thread_self_pointer ());\n\n      dbgprintf (\"Mutator %p before check lock\\n\", gl_thread_self_pointer ());\n      gl_lock_lock (my_lock);\n      check_accounts ();\n      gl_lock_unlock (my_lock);\n      dbgprintf (\"Mutator %p after  check unlock\\n\", gl_thread_self_pointer ());\n\n      yield ();\n    }\n\n  dbgprintf (\"Mutator %p dying.\\n\", gl_thread_self_pointer ());\n  return NULL;\n}",
      "lines": 35,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nlock_mutator_thread (void *arg)",
        "*"
      ]
    },
    "lock_checker_thread": {
      "start_point": [
        174,
        0
      ],
      "end_point": [
        190,
        1
      ],
      "content": "static void *\nlock_checker_thread (void *arg)\n{\n  while (!lock_checker_done)\n    {\n      dbgprintf (\"Checker %p before check lock\\n\", gl_thread_self_pointer ());\n      gl_lock_lock (my_lock);\n      check_accounts ();\n      gl_lock_unlock (my_lock);\n      dbgprintf (\"Checker %p after  check unlock\\n\", gl_thread_self_pointer ());\n\n      yield ();\n    }\n\n  dbgprintf (\"Checker %p dying.\\n\", gl_thread_self_pointer ());\n  return NULL;\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nlock_checker_thread (void *arg)",
        "*"
      ]
    },
    "test_lock": {
      "start_point": [
        192,
        0
      ],
      "end_point": [
        215,
        1
      ],
      "content": "static void\ntest_lock (void)\n{\n  int i;\n  gl_thread_t checkerthread;\n  gl_thread_t threads[THREAD_COUNT];\n\n  /* Initialization.  */\n  for (i = 0; i < ACCOUNT_COUNT; i++)\n    account[i] = 1000;\n  lock_checker_done = 0;\n\n  /* Spawn the threads.  */\n  checkerthread = gl_thread_create (lock_checker_thread, NULL);\n  for (i = 0; i < THREAD_COUNT; i++)\n    threads[i] = gl_thread_create (lock_mutator_thread, NULL);\n\n  /* Wait for the threads to terminate.  */\n  for (i = 0; i < THREAD_COUNT; i++)\n    gl_thread_join (threads[i], NULL);\n  lock_checker_done = 1;\n  gl_thread_join (checkerthread, NULL);\n  check_accounts ();\n}",
      "lines": 24,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "rwlock_mutator_thread": {
      "start_point": [
        226,
        0
      ],
      "end_point": [
        254,
        1
      ],
      "content": "static void *\nrwlock_mutator_thread (void *arg)\n{\n  int repeat;\n\n  for (repeat = REPEAT_COUNT; repeat > 0; repeat--)\n    {\n      int i1, i2, value;\n\n      dbgprintf (\"Mutator %p before wrlock\\n\", gl_thread_self_pointer ());\n      gl_rwlock_wrlock (my_rwlock);\n      dbgprintf (\"Mutator %p after  wrlock\\n\", gl_thread_self_pointer ());\n\n      i1 = random_account ();\n      i2 = random_account ();\n      value = ((unsigned int) rand () >> 3) % 10;\n      account[i1] += value;\n      account[i2] -= value;\n\n      dbgprintf (\"Mutator %p before unlock\\n\", gl_thread_self_pointer ());\n      gl_rwlock_unlock (my_rwlock);\n      dbgprintf (\"Mutator %p after  unlock\\n\", gl_thread_self_pointer ());\n\n      yield ();\n    }\n\n  dbgprintf (\"Mutator %p dying.\\n\", gl_thread_self_pointer ());\n  return NULL;\n}",
      "lines": 29,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nrwlock_mutator_thread (void *arg)",
        "*"
      ]
    },
    "rwlock_checker_thread": {
      "start_point": [
        258,
        0
      ],
      "end_point": [
        274,
        1
      ],
      "content": "static void *\nrwlock_checker_thread (void *arg)\n{\n  while (!rwlock_checker_done)\n    {\n      dbgprintf (\"Checker %p before check rdlock\\n\", gl_thread_self_pointer ());\n      gl_rwlock_rdlock (my_rwlock);\n      check_accounts ();\n      gl_rwlock_unlock (my_rwlock);\n      dbgprintf (\"Checker %p after  check unlock\\n\", gl_thread_self_pointer ());\n\n      yield ();\n    }\n\n  dbgprintf (\"Checker %p dying.\\n\", gl_thread_self_pointer ());\n  return NULL;\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nrwlock_checker_thread (void *arg)",
        "*"
      ]
    },
    "test_rwlock": {
      "start_point": [
        276,
        0
      ],
      "end_point": [
        301,
        1
      ],
      "content": "static void\ntest_rwlock (void)\n{\n  int i;\n  gl_thread_t checkerthreads[THREAD_COUNT];\n  gl_thread_t threads[THREAD_COUNT];\n\n  /* Initialization.  */\n  for (i = 0; i < ACCOUNT_COUNT; i++)\n    account[i] = 1000;\n  rwlock_checker_done = 0;\n\n  /* Spawn the threads.  */\n  for (i = 0; i < THREAD_COUNT; i++)\n    checkerthreads[i] = gl_thread_create (rwlock_checker_thread, NULL);\n  for (i = 0; i < THREAD_COUNT; i++)\n    threads[i] = gl_thread_create (rwlock_mutator_thread, NULL);\n\n  /* Wait for the threads to terminate.  */\n  for (i = 0; i < THREAD_COUNT; i++)\n    gl_thread_join (threads[i], NULL);\n  rwlock_checker_done = 1;\n  for (i = 0; i < THREAD_COUNT; i++)\n    gl_thread_join (checkerthreads[i], NULL);\n  check_accounts ();\n}",
      "lines": 26,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "recshuffle": {
      "start_point": [
        312,
        0
      ],
      "end_point": [
        334,
        1
      ],
      "content": "static void\nrecshuffle (void)\n{\n  int i1, i2, value;\n\n  dbgprintf (\"Mutator %p before lock\\n\", gl_thread_self_pointer ());\n  gl_recursive_lock_lock (my_reclock);\n  dbgprintf (\"Mutator %p after  lock\\n\", gl_thread_self_pointer ());\n\n  i1 = random_account ();\n  i2 = random_account ();\n  value = ((unsigned int) rand () >> 3) % 10;\n  account[i1] += value;\n  account[i2] -= value;\n\n  /* Recursive with probability 0.5.  */\n  if (((unsigned int) rand () >> 3) % 2)\n    recshuffle ();\n\n  dbgprintf (\"Mutator %p before unlock\\n\", gl_thread_self_pointer ());\n  gl_recursive_lock_unlock (my_reclock);\n  dbgprintf (\"Mutator %p after  unlock\\n\", gl_thread_self_pointer ());\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "reclock_mutator_thread": {
      "start_point": [
        336,
        0
      ],
      "end_point": [
        356,
        1
      ],
      "content": "static void *\nreclock_mutator_thread (void *arg)\n{\n  int repeat;\n\n  for (repeat = REPEAT_COUNT; repeat > 0; repeat--)\n    {\n      recshuffle ();\n\n      dbgprintf (\"Mutator %p before check lock\\n\", gl_thread_self_pointer ());\n      gl_recursive_lock_lock (my_reclock);\n      check_accounts ();\n      gl_recursive_lock_unlock (my_reclock);\n      dbgprintf (\"Mutator %p after  check unlock\\n\", gl_thread_self_pointer ());\n\n      yield ();\n    }\n\n  dbgprintf (\"Mutator %p dying.\\n\", gl_thread_self_pointer ());\n  return NULL;\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nreclock_mutator_thread (void *arg)",
        "*"
      ]
    },
    "reclock_checker_thread": {
      "start_point": [
        360,
        0
      ],
      "end_point": [
        376,
        1
      ],
      "content": "static void *\nreclock_checker_thread (void *arg)\n{\n  while (!reclock_checker_done)\n    {\n      dbgprintf (\"Checker %p before check lock\\n\", gl_thread_self_pointer ());\n      gl_recursive_lock_lock (my_reclock);\n      check_accounts ();\n      gl_recursive_lock_unlock (my_reclock);\n      dbgprintf (\"Checker %p after  check unlock\\n\", gl_thread_self_pointer ());\n\n      yield ();\n    }\n\n  dbgprintf (\"Checker %p dying.\\n\", gl_thread_self_pointer ());\n  return NULL;\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nreclock_checker_thread (void *arg)",
        "*"
      ]
    },
    "test_recursive_lock": {
      "start_point": [
        378,
        0
      ],
      "end_point": [
        401,
        1
      ],
      "content": "static void\ntest_recursive_lock (void)\n{\n  int i;\n  gl_thread_t checkerthread;\n  gl_thread_t threads[THREAD_COUNT];\n\n  /* Initialization.  */\n  for (i = 0; i < ACCOUNT_COUNT; i++)\n    account[i] = 1000;\n  reclock_checker_done = 0;\n\n  /* Spawn the threads.  */\n  checkerthread = gl_thread_create (reclock_checker_thread, NULL);\n  for (i = 0; i < THREAD_COUNT; i++)\n    threads[i] = gl_thread_create (reclock_mutator_thread, NULL);\n\n  /* Wait for the threads to terminate.  */\n  for (i = 0; i < THREAD_COUNT; i++)\n    gl_thread_join (threads[i], NULL);\n  reclock_checker_done = 1;\n  gl_thread_join (checkerthread, NULL);\n  check_accounts ();\n}",
      "lines": 24,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "once_execute": {
      "start_point": [
        421,
        0
      ],
      "end_point": [
        427,
        1
      ],
      "content": "static void\nonce_execute (void)\n{\n  gl_lock_lock (performed_lock);\n  performed++;\n  gl_lock_unlock (performed_lock);\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "once_contender_thread": {
      "start_point": [
        429,
        0
      ],
      "end_point": [
        465,
        1
      ],
      "content": "static void *\nonce_contender_thread (void *arg)\n{\n  int id = (int) (long) arg;\n  int repeat;\n\n  for (repeat = 0; repeat <= REPEAT_COUNT; repeat++)\n    {\n      /* Tell the main thread that we're ready.  */\n      gl_lock_lock (ready_lock[id]);\n      ready[id] = 1;\n      gl_lock_unlock (ready_lock[id]);\n\n      if (repeat == REPEAT_COUNT)\n        break;\n\n      dbgprintf (\"Contender %p waiting for signal for round %d\\n\",\n                 gl_thread_self_pointer (), repeat);\n#if ENABLE_LOCKING\n      /* Wait for the signal to go.  */\n      gl_rwlock_rdlock (fire_signal[repeat]);\n      /* And don't hinder the others (if the scheduler is unfair).  */\n      gl_rwlock_unlock (fire_signal[repeat]);\n#else\n      /* Wait for the signal to go.  */\n      while (fire_signal_state <= repeat)\n        yield ();\n#endif\n      dbgprintf (\"Contender %p got the     signal for round %d\\n\",\n                 gl_thread_self_pointer (), repeat);\n\n      /* Contend for execution.  */\n      gl_once (once_control, once_execute);\n    }\n\n  return NULL;\n}",
      "lines": 37,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nonce_contender_thread (void *arg)",
        "*"
      ]
    },
    "test_once": {
      "start_point": [
        467,
        0
      ],
      "end_point": [
        550,
        1
      ],
      "content": "static void\ntest_once (void)\n{\n  int i, repeat;\n  gl_thread_t threads[THREAD_COUNT];\n\n  /* Initialize all variables.  */\n  for (i = 0; i < THREAD_COUNT; i++)\n    {\n      ready[i] = 0;\n      gl_lock_init (ready_lock[i]);\n    }\n#if ENABLE_LOCKING\n  for (i = 0; i < REPEAT_COUNT; i++)\n    gl_rwlock_init (fire_signal[i]);\n#else\n  fire_signal_state = 0;\n#endif\n\n  /* Block all fire_signals.  */\n  for (i = REPEAT_COUNT-1; i >= 0; i--)\n    gl_rwlock_wrlock (fire_signal[i]);\n\n  /* Spawn the threads.  */\n  for (i = 0; i < THREAD_COUNT; i++)\n    threads[i] = gl_thread_create (once_contender_thread, (void *) (long) i);\n\n  for (repeat = 0; repeat <= REPEAT_COUNT; repeat++)\n    {\n      /* Wait until every thread is ready.  */\n      dbgprintf (\"Main thread before synchronizing for round %d\\n\", repeat);\n      for (;;)\n        {\n          int ready_count = 0;\n          for (i = 0; i < THREAD_COUNT; i++)\n            {\n              gl_lock_lock (ready_lock[i]);\n              ready_count += ready[i];\n              gl_lock_unlock (ready_lock[i]);\n            }\n          if (ready_count == THREAD_COUNT)\n            break;\n          yield ();\n        }\n      dbgprintf (\"Main thread after  synchronizing for round %d\\n\", repeat);\n\n      if (repeat > 0)\n        {\n          /* Check that exactly one thread executed the once_execute()\n             function.  */\n          if (performed != 1)\n            abort ();\n        }\n\n      if (repeat == REPEAT_COUNT)\n        break;\n\n      /* Preparation for the next round: Initialize once_control.  */\n      memcpy (&once_control, &fresh_once, sizeof (gl_once_t));\n\n      /* Preparation for the next round: Reset the performed counter.  */\n      performed = 0;\n\n      /* Preparation for the next round: Reset the ready flags.  */\n      for (i = 0; i < THREAD_COUNT; i++)\n        {\n          gl_lock_lock (ready_lock[i]);\n          ready[i] = 0;\n          gl_lock_unlock (ready_lock[i]);\n        }\n\n      /* Signal all threads simultaneously.  */\n      dbgprintf (\"Main thread giving signal for round %d\\n\", repeat);\n#if ENABLE_LOCKING\n      gl_rwlock_unlock (fire_signal[repeat]);\n#else\n      fire_signal_state = repeat + 1;\n#endif\n    }\n\n  /* Wait for the threads to terminate.  */\n  for (i = 0; i < THREAD_COUNT; i++)\n    gl_thread_join (threads[i], NULL);\n}",
      "lines": 84,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": [
      {
        "start_point": [
          555,
          0
        ],
        "end_point": [
          585,
          1
        ],
        "content": "int\nmain ()\n{\n#if TEST_PTH_THREADS\n  if (!pth_init ())\n    abort ();\n#endif\n\n#if DO_TEST_LOCK\n  printf (\"Starting test_lock ...\"); fflush (stdout);\n  test_lock ();\n  printf (\" OK\\n\"); fflush (stdout);\n#endif\n#if DO_TEST_RWLOCK\n  printf (\"Starting test_rwlock ...\"); fflush (stdout);\n  test_rwlock ();\n  printf (\" OK\\n\"); fflush (stdout);\n#endif\n#if DO_TEST_RECURSIVE_LOCK\n  printf (\"Starting test_recursive_lock ...\"); fflush (stdout);\n  test_recursive_lock ();\n  printf (\" OK\\n\"); fflush (stdout);\n#endif\n#if DO_TEST_ONCE\n  printf (\"Starting test_once ...\"); fflush (stdout);\n  test_once ();\n  printf (\" OK\\n\"); fflush (stdout);\n#endif\n\n  return 0;\n}",
        "lines": 31,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          593,
          0
        ],
        "end_point": [
          598,
          1
        ],
        "content": "int\nmain ()\n{\n  fputs (\"Skipping test: multithreading not enabled\\n\", stderr);\n  return 77;\n}",
        "lines": 6,
        "depth": 7,
        "decorators": [
          "int"
        ]
      }
    ]
  },
  "findutils/findutils-4.6.0/tests/test-lseek.c": {
    "main": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        108,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  if (argc != 2)\n    return 2;\n  switch (*argv[1])\n    {\n    case '0': /* regular files */\n      ASSERT (lseek (0, (off_t)2, SEEK_SET) == 2);\n      ASSERT (lseek (0, (off_t)-4, SEEK_CUR) == -1);\n      ASSERT (errno == EINVAL);\n      errno = 0;\n#if ! defined __BEOS__\n      /* POSIX says that the last lseek call, when failing, does not change\n         the current offset.  But BeOS sets it to 0.  */\n      ASSERT (lseek (0, (off_t)0, SEEK_CUR) == 2);\n#endif\n#if 0 /* leads to SIGSYS on IRIX 6.5 */\n      ASSERT (lseek (0, (off_t)0, (SEEK_SET | SEEK_CUR | SEEK_END) + 1) == -1);\n      ASSERT (errno == EINVAL);\n#endif\n      ASSERT (lseek (1, (off_t)2, SEEK_SET) == 2);\n      errno = 0;\n      ASSERT (lseek (1, (off_t)-4, SEEK_CUR) == -1);\n      ASSERT (errno == EINVAL);\n      errno = 0;\n#if ! defined __BEOS__\n      /* POSIX says that the last lseek call, when failing, does not change\n         the current offset.  But BeOS sets it to 0.  */\n      ASSERT (lseek (1, (off_t)0, SEEK_CUR) == 2);\n#endif\n#if 0 /* leads to SIGSYS on IRIX 6.5 */\n      ASSERT (lseek (1, (off_t)0, (SEEK_SET | SEEK_CUR | SEEK_END) + 1) == -1);\n      ASSERT (errno == EINVAL);\n#endif\n      break;\n\n    case '1': /* pipes */\n      errno = 0;\n      ASSERT (lseek (0, (off_t)0, SEEK_CUR) == -1);\n      ASSERT (errno == ESPIPE);\n      errno = 0;\n      ASSERT (lseek (1, (off_t)0, SEEK_CUR) == -1);\n      ASSERT (errno == ESPIPE);\n      break;\n\n    case '2': /* closed */\n      /* Explicitly close file descriptors 0 and 1.  The <&- and >&- in the\n         invoking shell are not enough on HP-UX.  */\n      close (0);\n      close (1);\n\n      errno = 0;\n      ASSERT (lseek (0, (off_t)0, SEEK_CUR) == -1);\n      ASSERT (errno == EBADF);\n\n      errno = 0;\n      ASSERT (lseek (1, (off_t)0, SEEK_CUR) == -1);\n      ASSERT (errno == EBADF);\n\n      /* Test behaviour for invalid file descriptors.  */\n      errno = 0;\n      ASSERT (lseek (-1, (off_t)0, SEEK_CUR) == -1);\n      ASSERT (errno == EBADF);\n\n      close (99);\n      errno = 0;\n      ASSERT (lseek (99, (off_t)0, SEEK_CUR) == -1);\n      ASSERT (errno == EBADF);\n\n      break;\n\n    default:\n      return 1;\n    }\n  return 0;\n}",
      "lines": 77,
      "depth": 16,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-lstat.c": {
    "do_lstat": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "static int\ndo_lstat (char const *name, struct stat *st)\n{\n  return lstat (name, st);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "int\nmain (void)\n{\n  /* Remove any leftovers from a previous partial run.  */\n  ignore_value (system (\"rm -rf \" BASE \"*\"));\n\n  return test_lstat_func (do_lstat, true);\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-lstat.h": {
    "test_lstat_func": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        115,
        1
      ],
      "content": "static int\ntest_lstat_func (int (*func) (char const *, struct stat *), bool print)\n{\n  struct stat st1;\n  struct stat st2;\n\n  /* Test for common directories.  */\n  ASSERT (func (\".\", &st1) == 0);\n  ASSERT (func (\"./\", &st2) == 0);\n  ASSERT (SAME_INODE (st1, st2));\n  ASSERT (S_ISDIR (st1.st_mode));\n  ASSERT (S_ISDIR (st2.st_mode));\n  ASSERT (func (\"/\", &st1) == 0);\n  ASSERT (func (\"///\", &st2) == 0);\n  ASSERT (SAME_INODE (st1, st2));\n  ASSERT (S_ISDIR (st1.st_mode));\n  ASSERT (S_ISDIR (st2.st_mode));\n  ASSERT (func (\"..\", &st1) == 0);\n  ASSERT (S_ISDIR (st1.st_mode));\n\n  /* Test for error conditions.  */\n  errno = 0;\n  ASSERT (func (\"\", &st1) == -1);\n  ASSERT (errno == ENOENT);\n  errno = 0;\n  ASSERT (func (\"nosuch\", &st1) == -1);\n  ASSERT (errno == ENOENT);\n  errno = 0;\n  ASSERT (func (\"nosuch/\", &st1) == -1);\n  ASSERT (errno == ENOENT);\n\n  ASSERT (close (creat (BASE \"file\", 0600)) == 0);\n  ASSERT (func (BASE \"file\", &st1) == 0);\n  ASSERT (S_ISREG (st1.st_mode));\n  errno = 0;\n  ASSERT (func (BASE \"file/\", &st1) == -1);\n  ASSERT (errno == ENOTDIR);\n\n  /* Now for some symlink tests, where supported.  We set up:\n     link1 -> directory\n     link2 -> file\n     link3 -> dangling\n     link4 -> loop\n     then test behavior both with and without trailing slash.\n  */\n  if (symlink (\".\", BASE \"link1\") != 0)\n    {\n      ASSERT (unlink (BASE \"file\") == 0);\n      if (print)\n        fputs (\"skipping test: symlinks not supported on this file system\\n\",\n               stderr);\n      return 77;\n    }\n  ASSERT (symlink (BASE \"file\", BASE \"link2\") == 0);\n  ASSERT (symlink (BASE \"nosuch\", BASE \"link3\") == 0);\n  ASSERT (symlink (BASE \"link4\", BASE \"link4\") == 0);\n\n  ASSERT (func (BASE \"link1\", &st1) == 0);\n  ASSERT (S_ISLNK (st1.st_mode));\n  ASSERT (func (BASE \"link1/\", &st1) == 0);\n  ASSERT (stat (BASE \"link1\", &st2) == 0);\n  ASSERT (S_ISDIR (st1.st_mode));\n  ASSERT (S_ISDIR (st2.st_mode));\n  ASSERT (SAME_INODE (st1, st2));\n\n  ASSERT (func (BASE \"link2\", &st1) == 0);\n  ASSERT (S_ISLNK (st1.st_mode));\n  errno = 0;\n  ASSERT (func (BASE \"link2/\", &st1) == -1);\n  ASSERT (errno == ENOTDIR);\n\n  ASSERT (func (BASE \"link3\", &st1) == 0);\n  ASSERT (S_ISLNK (st1.st_mode));\n  errno = 0;\n  ASSERT (func (BASE \"link3/\", &st1) == -1);\n  ASSERT (errno == ENOENT);\n\n  ASSERT (func (BASE \"link4\", &st1) == 0);\n  ASSERT (S_ISLNK (st1.st_mode));\n  errno = 0;\n  ASSERT (func (BASE \"link4/\", &st1) == -1);\n  ASSERT (errno == ELOOP);\n\n  /* Cleanup.  */\n  ASSERT (unlink (BASE \"file\") == 0);\n  ASSERT (unlink (BASE \"link1\") == 0);\n  ASSERT (unlink (BASE \"link2\") == 0);\n  ASSERT (unlink (BASE \"link3\") == 0);\n  ASSERT (unlink (BASE \"link4\") == 0);\n\n  return 0;\n}",
      "lines": 92,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-malloc-gnu.c": {
    "main": {
      "start_point": [
        20,
        0
      ],
      "end_point": [
        28,
        1
      ],
      "content": "int\nmain ()\n{\n  /* Check that malloc (0) is not a NULL pointer.  */\n  if (malloc (0) == NULL)\n    return 1;\n\n  return 0;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-malloca.c": {
    "do_allocation": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        30,
        1
      ],
      "content": "static void\ndo_allocation (int n)\n{\n  void *ptr = malloca (n);\n  freea (ptr);\n  safe_alloca (n);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "int\nmain ()\n{\n  int i;\n\n  /* This slows down malloc a lot.  */\n  unsetenv (\"MALLOC_PERTURB_\");\n\n  /* Repeat a lot of times, to make sure there's no memory leak.  */\n  for (i = 0; i < 50000; i++)\n    {\n      /* Try various values.\n         n = 0 gave a crash on Alpha with gcc-2.5.8.\n         Some versions of Mac OS X have a stack size limit of 512 KB.  */\n      func (34);\n      func (134);\n      func (399);\n      func (510823);\n      func (129321);\n      func (0);\n      func (4070);\n      func (4095);\n      func (1);\n      func (16582);\n    }\n\n  return 0;\n}",
      "lines": 28,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-math.c": {
    "numeric_equalf": {
      "start_point": [
        64,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "static int\nnumeric_equalf (float x, float y)\n{\n  return x == y;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "numeric_equald": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        73,
        1
      ],
      "content": "static int\nnumeric_equald (double x, double y)\n{\n  return x == y;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "numeric_equall": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "static int\nnumeric_equall (long double x, long double y)\n{\n  return x == y;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        80,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "int\nmain (void)\n{\n  double d = NAN;\n  double zero = 0.0;\n  ASSERT (!numeric_equald (d, d));\n\n  d = HUGE_VAL;\n  ASSERT (numeric_equald (d, 1.0 / zero));\n\n  ASSERT (numeric_equalf (HUGE_VALF, HUGE_VALF + HUGE_VALF));\n\n  ASSERT (numeric_equald (HUGE_VAL, HUGE_VAL + HUGE_VAL));\n\n  ASSERT (numeric_equall (HUGE_VALL, HUGE_VALL + HUGE_VALL));\n\n  /* Check the value of FP_ILOGB0.  */\n  ASSERT (FP_ILOGB0 == INT_MIN || FP_ILOGB0 == - INT_MAX);\n\n  /* Check the value of FP_ILOGBNAN.  */\n  ASSERT (FP_ILOGBNAN == INT_MIN || FP_ILOGBNAN == INT_MAX);\n\n  return 0;\n}",
      "lines": 24,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-mbrtowc-w32.c": {
    "test_one_locale": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        699,
        1
      ],
      "content": "static int\ntest_one_locale (const char *name, int codepage)\n{\n  mbstate_t state;\n  wchar_t wc;\n  size_t ret;\n\n# if 1\n  /* Portable code to set the locale.  */\n  {\n    char name_with_codepage[1024];\n\n    sprintf (name_with_codepage, \"%s.%d\", name, codepage);\n\n    /* Set the locale.  */\n    if (setlocale (LC_ALL, name_with_codepage) == NULL)\n      return 77;\n  }\n# else\n  /* Hacky way to set a locale.codepage combination that setlocale() refuses\n     to set.  */\n  {\n    /* Codepage of the current locale, set with setlocale().\n       Not necessarily the same as GetACP().  */\n    extern __declspec(dllimport) unsigned int __lc_codepage;\n\n    /* Set the locale.  */\n    if (setlocale (LC_ALL, name) == NULL)\n      return 77;\n\n    /* Clobber the codepage and MB_CUR_MAX, both set by setlocale().  */\n    __lc_codepage = codepage;\n    switch (codepage)\n      {\n      case 1252:\n      case 1256:\n        MB_CUR_MAX = 1;\n        break;\n      case 932:\n      case 950:\n      case 936:\n        MB_CUR_MAX = 2;\n        break;\n      case 54936:\n      case 65001:\n        MB_CUR_MAX = 4;\n        break;\n      }\n\n    /* Test whether the codepage is really available.  */\n    memset (&state, '\\0', sizeof (mbstate_t));\n    if (mbrtowc (&wc, \" \", 1, &state) == (size_t)(-1))\n      return 77;\n  }\n# endif\n\n  /* Test zero-length input.  */\n  {\n    memset (&state, '\\0', sizeof (mbstate_t));\n    wc = (wchar_t) 0xBADFACE;\n    ret = mbrtowc (&wc, \"x\", 0, &state);\n    /* gnulib's implementation returns (size_t)(-2).\n       The AIX 5.1 implementation returns (size_t)(-1).\n       glibc's implementation returns 0.  */\n    ASSERT (ret == (size_t)(-2) || ret == (size_t)(-1) || ret == 0);\n    ASSERT (mbsinit (&state));\n  }\n\n  /* Test NUL byte input.  */\n  {\n    memset (&state, '\\0', sizeof (mbstate_t));\n    wc = (wchar_t) 0xBADFACE;\n    ret = mbrtowc (&wc, \"\", 1, &state);\n    ASSERT (ret == 0);\n    ASSERT (wc == 0);\n    ASSERT (mbsinit (&state));\n    ret = mbrtowc (NULL, \"\", 1, &state);\n    ASSERT (ret == 0);\n    ASSERT (mbsinit (&state));\n  }\n\n  /* Test single-byte input.  */\n  {\n    int c;\n    char buf[1];\n\n    memset (&state, '\\0', sizeof (mbstate_t));\n    for (c = 0; c < 0x100; c++)\n      switch (c)\n        {\n        case '\\t': case '\\v': case '\\f':\n        case ' ': case '!': case '\"': case '#': case '%':\n        case '&': case '\\'': case '(': case ')': case '*':\n        case '+': case ',': case '-': case '.': case '/':\n        case '0': case '1': case '2': case '3': case '4':\n        case '5': case '6': case '7': case '8': case '9':\n        case ':': case ';': case '<': case '=': case '>':\n        case '?':\n        case 'A': case 'B': case 'C': case 'D': case 'E':\n        case 'F': case 'G': case 'H': case 'I': case 'J':\n        case 'K': case 'L': case 'M': case 'N': case 'O':\n        case 'P': case 'Q': case 'R': case 'S': case 'T':\n        case 'U': case 'V': case 'W': case 'X': case 'Y':\n        case 'Z':\n        case '[': case '\\\\': case ']': case '^': case '_':\n        case 'a': case 'b': case 'c': case 'd': case 'e':\n        case 'f': case 'g': case 'h': case 'i': case 'j':\n        case 'k': case 'l': case 'm': case 'n': case 'o':\n        case 'p': case 'q': case 'r': case 's': case 't':\n        case 'u': case 'v': case 'w': case 'x': case 'y':\n        case 'z': case '{': case '|': case '}': case '~':\n          /* c is in the ISO C \"basic character set\".  */\n          buf[0] = c;\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, buf, 1, &state);\n          ASSERT (ret == 1);\n          ASSERT (wc == c);\n          ASSERT (mbsinit (&state));\n          ret = mbrtowc (NULL, buf, 1, &state);\n          ASSERT (ret == 1);\n          ASSERT (mbsinit (&state));\n          break;\n        }\n  }\n\n  /* Test special calling convention, passing a NULL pointer.  */\n  {\n    memset (&state, '\\0', sizeof (mbstate_t));\n    wc = (wchar_t) 0xBADFACE;\n    ret = mbrtowc (&wc, NULL, 5, &state);\n    ASSERT (ret == 0);\n    ASSERT (wc == (wchar_t) 0xBADFACE);\n    ASSERT (mbsinit (&state));\n  }\n\n  switch (codepage)\n    {\n    case 1252:\n      /* Locale encoding is CP1252, an extension of ISO-8859-1.  */\n      {\n        char input[] = \"B\\374\\337er\"; /* \"B\u00c3\u00bc\u00c3\u009fer\" */\n        memset (&state, '\\0', sizeof (mbstate_t));\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input, 1, &state);\n        ASSERT (ret == 1);\n        ASSERT (wc == 'B');\n        ASSERT (mbsinit (&state));\n        input[0] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 1, 1, &state);\n        ASSERT (ret == 1);\n        ASSERT (wctob (wc) == (unsigned char) '\\374');\n        ASSERT (wc == 0x00FC);\n        ASSERT (mbsinit (&state));\n        input[1] = '\\0';\n\n        /* Test support of NULL first argument.  */\n        ret = mbrtowc (NULL, input + 2, 3, &state);\n        ASSERT (ret == 1);\n        ASSERT (mbsinit (&state));\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 2, 3, &state);\n        ASSERT (ret == 1);\n        ASSERT (wctob (wc) == (unsigned char) '\\337');\n        ASSERT (wc == 0x00DF);\n        ASSERT (mbsinit (&state));\n        input[2] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 3, 2, &state);\n        ASSERT (ret == 1);\n        ASSERT (wc == 'e');\n        ASSERT (mbsinit (&state));\n        input[3] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 4, 1, &state);\n        ASSERT (ret == 1);\n        ASSERT (wc == 'r');\n        ASSERT (mbsinit (&state));\n      }\n      return 0;\n\n    case 1256:\n      /* Locale encoding is CP1256, not the same as ISO-8859-6.  */\n      {\n        char input[] = \"x\\302\\341\\346y\"; /* \"x\u00d8\u00a2\u00d9\u0084\u00d9\u0088y\" */\n        memset (&state, '\\0', sizeof (mbstate_t));\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input, 1, &state);\n        ASSERT (ret == 1);\n        ASSERT (wc == 'x');\n        ASSERT (mbsinit (&state));\n        input[0] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 1, 1, &state);\n        ASSERT (ret == 1);\n        ASSERT (wctob (wc) == (unsigned char) '\\302');\n        ASSERT (wc == 0x0622);\n        ASSERT (mbsinit (&state));\n        input[1] = '\\0';\n\n        /* Test support of NULL first argument.  */\n        ret = mbrtowc (NULL, input + 2, 3, &state);\n        ASSERT (ret == 1);\n        ASSERT (mbsinit (&state));\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 2, 3, &state);\n        ASSERT (ret == 1);\n        ASSERT (wctob (wc) == (unsigned char) '\\341');\n        ASSERT (wc == 0x0644);\n        ASSERT (mbsinit (&state));\n        input[2] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 3, 2, &state);\n        ASSERT (ret == 1);\n        ASSERT (wctob (wc) == (unsigned char) '\\346');\n        ASSERT (wc == 0x0648);\n        ASSERT (mbsinit (&state));\n        input[3] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 4, 1, &state);\n        ASSERT (ret == 1);\n        ASSERT (wc == 'y');\n        ASSERT (mbsinit (&state));\n      }\n      return 0;\n\n    case 932:\n      /* Locale encoding is CP932, similar to Shift_JIS.  */\n      {\n        char input[] = \"<\\223\\372\\226\\173\\214\\352>\"; /* \"<\u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e>\" */\n        memset (&state, '\\0', sizeof (mbstate_t));\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input, 1, &state);\n        ASSERT (ret == 1);\n        ASSERT (wc == '<');\n        ASSERT (mbsinit (&state));\n        input[0] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 1, 2, &state);\n        ASSERT (ret == 2);\n        ASSERT (wctob (wc) == EOF);\n        ASSERT (wc == 0x65E5);\n        ASSERT (mbsinit (&state));\n        input[1] = '\\0';\n        input[2] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 3, 1, &state);\n        ASSERT (ret == (size_t)(-2));\n        ASSERT (wc == (wchar_t) 0xBADFACE);\n        ASSERT (!mbsinit (&state));\n        input[3] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 4, 4, &state);\n        ASSERT (ret == 1);\n        ASSERT (wctob (wc) == EOF);\n        ASSERT (wc == 0x672C);\n        ASSERT (mbsinit (&state));\n        input[4] = '\\0';\n\n        /* Test support of NULL first argument.  */\n        ret = mbrtowc (NULL, input + 5, 3, &state);\n        ASSERT (ret == 2);\n        ASSERT (mbsinit (&state));\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 5, 3, &state);\n        ASSERT (ret == 2);\n        ASSERT (wctob (wc) == EOF);\n        ASSERT (wc == 0x8A9E);\n        ASSERT (mbsinit (&state));\n        input[5] = '\\0';\n        input[6] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 7, 1, &state);\n        ASSERT (ret == 1);\n        ASSERT (wc == '>');\n        ASSERT (mbsinit (&state));\n\n        /* Test some invalid input.  */\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\377\", 1, &state); /* 0xFF */\n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\225\\377\", 2, &state); /* 0x95 0xFF */\n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n      }\n      return 0;\n\n    case 950:\n      /* Locale encoding is CP950, similar to Big5.  */\n      {\n        char input[] = \"<\\244\\351\\245\\273\\273\\171>\"; /* \"<\u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e>\" */\n        memset (&state, '\\0', sizeof (mbstate_t));\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input, 1, &state);\n        ASSERT (ret == 1);\n        ASSERT (wc == '<');\n        ASSERT (mbsinit (&state));\n        input[0] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 1, 2, &state);\n        ASSERT (ret == 2);\n        ASSERT (wctob (wc) == EOF);\n        ASSERT (wc == 0x65E5);\n        ASSERT (mbsinit (&state));\n        input[1] = '\\0';\n        input[2] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 3, 1, &state);\n        ASSERT (ret == (size_t)(-2));\n        ASSERT (wc == (wchar_t) 0xBADFACE);\n        ASSERT (!mbsinit (&state));\n        input[3] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 4, 4, &state);\n        ASSERT (ret == 1);\n        ASSERT (wctob (wc) == EOF);\n        ASSERT (wc == 0x672C);\n        ASSERT (mbsinit (&state));\n        input[4] = '\\0';\n\n        /* Test support of NULL first argument.  */\n        ret = mbrtowc (NULL, input + 5, 3, &state);\n        ASSERT (ret == 2);\n        ASSERT (mbsinit (&state));\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 5, 3, &state);\n        ASSERT (ret == 2);\n        ASSERT (wctob (wc) == EOF);\n        ASSERT (wc == 0x8A9E);\n        ASSERT (mbsinit (&state));\n        input[5] = '\\0';\n        input[6] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 7, 1, &state);\n        ASSERT (ret == 1);\n        ASSERT (wc == '>');\n        ASSERT (mbsinit (&state));\n\n        /* Test some invalid input.  */\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\377\", 1, &state); /* 0xFF */\n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\225\\377\", 2, &state); /* 0x95 0xFF */\n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n      }\n      return 0;\n\n    case 936:\n      /* Locale encoding is CP936 = GBK, an extension of GB2312.  */\n      {\n        char input[] = \"<\\310\\325\\261\\276\\325\\132>\"; /* \"<\u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e>\" */\n        memset (&state, '\\0', sizeof (mbstate_t));\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input, 1, &state);\n        ASSERT (ret == 1);\n        ASSERT (wc == '<');\n        ASSERT (mbsinit (&state));\n        input[0] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 1, 2, &state);\n        ASSERT (ret == 2);\n        ASSERT (wctob (wc) == EOF);\n        ASSERT (wc == 0x65E5);\n        ASSERT (mbsinit (&state));\n        input[1] = '\\0';\n        input[2] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 3, 1, &state);\n        ASSERT (ret == (size_t)(-2));\n        ASSERT (wc == (wchar_t) 0xBADFACE);\n        ASSERT (!mbsinit (&state));\n        input[3] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 4, 4, &state);\n        ASSERT (ret == 1);\n        ASSERT (wctob (wc) == EOF);\n        ASSERT (wc == 0x672C);\n        ASSERT (mbsinit (&state));\n        input[4] = '\\0';\n\n        /* Test support of NULL first argument.  */\n        ret = mbrtowc (NULL, input + 5, 3, &state);\n        ASSERT (ret == 2);\n        ASSERT (mbsinit (&state));\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 5, 3, &state);\n        ASSERT (ret == 2);\n        ASSERT (wctob (wc) == EOF);\n        ASSERT (wc == 0x8A9E);\n        ASSERT (mbsinit (&state));\n        input[5] = '\\0';\n        input[6] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 7, 1, &state);\n        ASSERT (ret == 1);\n        ASSERT (wc == '>');\n        ASSERT (mbsinit (&state));\n\n        /* Test some invalid input.  */\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\377\", 1, &state); /* 0xFF */\n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\225\\377\", 2, &state); /* 0x95 0xFF */\n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n      }\n      return 0;\n\n    case 54936:\n      /* Locale encoding is CP54936 = GB18030.  */\n      {\n        char input[] = \"B\\250\\271\\201\\060\\211\\070er\"; /* \"B\u00c3\u00bc\u00c3\u009fer\" */\n        memset (&state, '\\0', sizeof (mbstate_t));\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input, 1, &state);\n        ASSERT (ret == 1);\n        ASSERT (wc == 'B');\n        ASSERT (mbsinit (&state));\n        input[0] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 1, 1, &state);\n        ASSERT (ret == (size_t)(-2));\n        ASSERT (wc == (wchar_t) 0xBADFACE);\n        ASSERT (!mbsinit (&state));\n        input[1] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 2, 7, &state);\n        ASSERT (ret == 1);\n        ASSERT (wctob (wc) == EOF);\n        ASSERT (wc == 0x00FC);\n        ASSERT (mbsinit (&state));\n        input[2] = '\\0';\n\n        /* Test support of NULL first argument.  */\n        ret = mbrtowc (NULL, input + 3, 6, &state);\n        ASSERT (ret == 4);\n        ASSERT (mbsinit (&state));\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 3, 6, &state);\n        ASSERT (ret == 4);\n        ASSERT (wctob (wc) == EOF);\n        ASSERT (wc == 0x00DF);\n        ASSERT (mbsinit (&state));\n        input[3] = '\\0';\n        input[4] = '\\0';\n        input[5] = '\\0';\n        input[6] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 7, 2, &state);\n        ASSERT (ret == 1);\n        ASSERT (wc == 'e');\n        ASSERT (mbsinit (&state));\n        input[5] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 8, 1, &state);\n        ASSERT (ret == 1);\n        ASSERT (wc == 'r');\n        ASSERT (mbsinit (&state));\n\n        /* Test some invalid input.  */\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\377\", 1, &state); /* 0xFF */\n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\225\\377\", 2, &state); /* 0x95 0xFF */\n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\201\\045\", 2, &state); /* 0x81 0x25 */\n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\201\\060\\377\", 3, &state); /* 0x81 0x30 0xFF */\n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\201\\060\\377\\064\", 4, &state); /* 0x81 0x30 0xFF 0x34 */\n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\201\\060\\211\\072\", 4, &state); /* 0x81 0x30 0x89 0x3A */\n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n      }\n      return 0;\n\n    case 65001:\n      /* Locale encoding is CP65001 = UTF-8.  */\n      {\n        char input[] = \"B\\303\\274\\303\\237er\"; /* \"B\u00c3\u00bc\u00c3\u009fer\" */\n        memset (&state, '\\0', sizeof (mbstate_t));\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input, 1, &state);\n        ASSERT (ret == 1);\n        ASSERT (wc == 'B');\n        ASSERT (mbsinit (&state));\n        input[0] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 1, 1, &state);\n        ASSERT (ret == (size_t)(-2));\n        ASSERT (wc == (wchar_t) 0xBADFACE);\n        ASSERT (!mbsinit (&state));\n        input[1] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 2, 5, &state);\n        ASSERT (ret == 1);\n        ASSERT (wctob (wc) == EOF);\n        ASSERT (wc == 0x00FC);\n        ASSERT (mbsinit (&state));\n        input[2] = '\\0';\n\n        /* Test support of NULL first argument.  */\n        ret = mbrtowc (NULL, input + 3, 4, &state);\n        ASSERT (ret == 2);\n        ASSERT (mbsinit (&state));\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 3, 4, &state);\n        ASSERT (ret == 2);\n        ASSERT (wctob (wc) == EOF);\n        ASSERT (wc == 0x00DF);\n        ASSERT (mbsinit (&state));\n        input[3] = '\\0';\n        input[4] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 5, 2, &state);\n        ASSERT (ret == 1);\n        ASSERT (wc == 'e');\n        ASSERT (mbsinit (&state));\n        input[5] = '\\0';\n\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, input + 6, 1, &state);\n        ASSERT (ret == 1);\n        ASSERT (wc == 'r');\n        ASSERT (mbsinit (&state));\n\n        /* Test some invalid input.  */\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\377\", 1, &state); /* 0xFF */\n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\303\\300\", 2, &state); /* 0xC3 0xC0 */\n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\343\\300\", 2, &state); /* 0xE3 0xC0 */\n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\343\\300\\200\", 3, &state); /* 0xE3 0xC0 0x80 */\n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\343\\200\\300\", 3, &state); /* 0xE3 0x80 0xC0 */\n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\363\\300\", 2, &state); /* 0xF3 0xC0 */\n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\363\\300\\200\\200\", 4, &state); /* 0xF3 0xC0 0x80 0x80 */\n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\363\\200\\300\", 3, &state); /* 0xF3 0x80 0xC0 */\n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\363\\200\\300\\200\", 4, &state); /* 0xF3 0x80 0xC0 0x80 */\n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n\n        memset (&state, '\\0', sizeof (mbstate_t));\n        wc = (wchar_t) 0xBADFACE;\n        ret = mbrtowc (&wc, \"\\363\\200\\200\\300\", 4, &state); /* 0xF3 0x80 0x80 0xC0 */\n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n      }\n      return 0;\n\n    default:\n      return 1;\n    }\n}",
      "lines": 670,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": [
      {
        "start_point": [
          701,
          0
        ],
        "end_point": [
          723,
          1
        ],
        "content": "int\nmain (int argc, char *argv[])\n{\n  int codepage = atoi (argv[argc - 1]);\n  int result;\n  int i;\n\n  result = 77;\n  for (i = 1; i < argc - 1; i++)\n    {\n      int ret = test_one_locale (argv[i], codepage);\n\n      if (ret != 77)\n        result = ret;\n    }\n\n  if (result == 77)\n    {\n      fprintf (stderr, \"Skipping test: found no locale with codepage %d\\n\",\n               codepage);\n    }\n  return result;\n}",
        "lines": 23,
        "depth": 10,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          727,
          0
        ],
        "end_point": [
          732,
          1
        ],
        "content": "int\nmain (int argc, char *argv[])\n{\n  fputs (\"Skipping test: not a native Windows system\\n\", stderr);\n  return 77;\n}",
        "lines": 6,
        "depth": 7,
        "decorators": [
          "int"
        ]
      }
    ]
  },
  "findutils/findutils-4.6.0/tests/test-mbrtowc.c": {
    "main": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        339,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  mbstate_t state;\n  wchar_t wc;\n  size_t ret;\n\n  /* configure should already have checked that the locale is supported.  */\n  if (setlocale (LC_ALL, \"\") == NULL)\n    return 1;\n\n  /* Test zero-length input.  */\n  {\n    memset (&state, '\\0', sizeof (mbstate_t));\n    wc = (wchar_t) 0xBADFACE;\n    ret = mbrtowc (&wc, \"x\", 0, &state);\n    ASSERT (ret == (size_t)(-2));\n    ASSERT (mbsinit (&state));\n  }\n\n  /* Test NUL byte input.  */\n  {\n    memset (&state, '\\0', sizeof (mbstate_t));\n    wc = (wchar_t) 0xBADFACE;\n    ret = mbrtowc (&wc, \"\", 1, &state);\n    ASSERT (ret == 0);\n    ASSERT (wc == 0);\n    ASSERT (mbsinit (&state));\n    ret = mbrtowc (NULL, \"\", 1, &state);\n    ASSERT (ret == 0);\n    ASSERT (mbsinit (&state));\n  }\n\n  /* Test single-byte input.  */\n  {\n    int c;\n    char buf[1];\n\n    memset (&state, '\\0', sizeof (mbstate_t));\n    for (c = 0; c < 0x100; c++)\n      switch (c)\n        {\n        case '\\t': case '\\v': case '\\f':\n        case ' ': case '!': case '\"': case '#': case '%':\n        case '&': case '\\'': case '(': case ')': case '*':\n        case '+': case ',': case '-': case '.': case '/':\n        case '0': case '1': case '2': case '3': case '4':\n        case '5': case '6': case '7': case '8': case '9':\n        case ':': case ';': case '<': case '=': case '>':\n        case '?':\n        case 'A': case 'B': case 'C': case 'D': case 'E':\n        case 'F': case 'G': case 'H': case 'I': case 'J':\n        case 'K': case 'L': case 'M': case 'N': case 'O':\n        case 'P': case 'Q': case 'R': case 'S': case 'T':\n        case 'U': case 'V': case 'W': case 'X': case 'Y':\n        case 'Z':\n        case '[': case '\\\\': case ']': case '^': case '_':\n        case 'a': case 'b': case 'c': case 'd': case 'e':\n        case 'f': case 'g': case 'h': case 'i': case 'j':\n        case 'k': case 'l': case 'm': case 'n': case 'o':\n        case 'p': case 'q': case 'r': case 's': case 't':\n        case 'u': case 'v': case 'w': case 'x': case 'y':\n        case 'z': case '{': case '|': case '}': case '~':\n          /* c is in the ISO C \"basic character set\".  */\n          buf[0] = c;\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, buf, 1, &state);\n          ASSERT (ret == 1);\n          ASSERT (wc == c);\n          ASSERT (mbsinit (&state));\n          ret = mbrtowc (NULL, buf, 1, &state);\n          ASSERT (ret == 1);\n          ASSERT (mbsinit (&state));\n          break;\n        }\n  }\n\n  /* Test special calling convention, passing a NULL pointer.  */\n  {\n    memset (&state, '\\0', sizeof (mbstate_t));\n    wc = (wchar_t) 0xBADFACE;\n    ret = mbrtowc (&wc, NULL, 5, &state);\n    ASSERT (ret == 0);\n    ASSERT (wc == (wchar_t) 0xBADFACE);\n    ASSERT (mbsinit (&state));\n  }\n\n  if (argc > 1)\n    switch (argv[1][0])\n      {\n      case '1':\n        /* Locale encoding is ISO-8859-1 or ISO-8859-15.  */\n        {\n          char input[] = \"B\\374\\337er\"; /* \"B\u00c3\u00bc\u00c3\u009fer\" */\n          memset (&state, '\\0', sizeof (mbstate_t));\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input, 1, &state);\n          ASSERT (ret == 1);\n          ASSERT (wc == 'B');\n          ASSERT (mbsinit (&state));\n          input[0] = '\\0';\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input + 1, 1, &state);\n          ASSERT (ret == 1);\n          ASSERT (wctob (wc) == (unsigned char) '\\374');\n          ASSERT (mbsinit (&state));\n          input[1] = '\\0';\n\n          /* Test support of NULL first argument.  */\n          ret = mbrtowc (NULL, input + 2, 3, &state);\n          ASSERT (ret == 1);\n          ASSERT (mbsinit (&state));\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input + 2, 3, &state);\n          ASSERT (ret == 1);\n          ASSERT (wctob (wc) == (unsigned char) '\\337');\n          ASSERT (mbsinit (&state));\n          input[2] = '\\0';\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input + 3, 2, &state);\n          ASSERT (ret == 1);\n          ASSERT (wc == 'e');\n          ASSERT (mbsinit (&state));\n          input[3] = '\\0';\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input + 4, 1, &state);\n          ASSERT (ret == 1);\n          ASSERT (wc == 'r');\n          ASSERT (mbsinit (&state));\n        }\n        return 0;\n\n      case '2':\n        /* Locale encoding is UTF-8.  */\n        {\n          char input[] = \"B\\303\\274\\303\\237er\"; /* \"B\u00c3\u00bc\u00c3\u009fer\" */\n          memset (&state, '\\0', sizeof (mbstate_t));\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input, 1, &state);\n          ASSERT (ret == 1);\n          ASSERT (wc == 'B');\n          ASSERT (mbsinit (&state));\n          input[0] = '\\0';\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input + 1, 1, &state);\n          ASSERT (ret == (size_t)(-2));\n          ASSERT (wc == (wchar_t) 0xBADFACE);\n          ASSERT (!mbsinit (&state));\n          input[1] = '\\0';\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input + 2, 5, &state);\n          ASSERT (ret == 1);\n          ASSERT (wctob (wc) == EOF);\n          ASSERT (mbsinit (&state));\n          input[2] = '\\0';\n\n          /* Test support of NULL first argument.  */\n          ret = mbrtowc (NULL, input + 3, 4, &state);\n          ASSERT (ret == 2);\n          ASSERT (mbsinit (&state));\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input + 3, 4, &state);\n          ASSERT (ret == 2);\n          ASSERT (wctob (wc) == EOF);\n          ASSERT (mbsinit (&state));\n          input[3] = '\\0';\n          input[4] = '\\0';\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input + 5, 2, &state);\n          ASSERT (ret == 1);\n          ASSERT (wc == 'e');\n          ASSERT (mbsinit (&state));\n          input[5] = '\\0';\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input + 6, 1, &state);\n          ASSERT (ret == 1);\n          ASSERT (wc == 'r');\n          ASSERT (mbsinit (&state));\n        }\n        return 0;\n\n      case '3':\n        /* Locale encoding is EUC-JP.  */\n        {\n          char input[] = \"<\\306\\374\\313\\334\\270\\354>\"; /* \"<\u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e>\" */\n          memset (&state, '\\0', sizeof (mbstate_t));\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input, 1, &state);\n          ASSERT (ret == 1);\n          ASSERT (wc == '<');\n          ASSERT (mbsinit (&state));\n          input[0] = '\\0';\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input + 1, 2, &state);\n          ASSERT (ret == 2);\n          ASSERT (wctob (wc) == EOF);\n          ASSERT (mbsinit (&state));\n          input[1] = '\\0';\n          input[2] = '\\0';\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input + 3, 1, &state);\n          ASSERT (ret == (size_t)(-2));\n          ASSERT (wc == (wchar_t) 0xBADFACE);\n          ASSERT (!mbsinit (&state));\n          input[3] = '\\0';\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input + 4, 4, &state);\n          ASSERT (ret == 1);\n          ASSERT (wctob (wc) == EOF);\n          ASSERT (mbsinit (&state));\n          input[4] = '\\0';\n\n          /* Test support of NULL first argument.  */\n          ret = mbrtowc (NULL, input + 5, 3, &state);\n          ASSERT (ret == 2);\n          ASSERT (mbsinit (&state));\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input + 5, 3, &state);\n          ASSERT (ret == 2);\n          ASSERT (wctob (wc) == EOF);\n          ASSERT (mbsinit (&state));\n          input[5] = '\\0';\n          input[6] = '\\0';\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input + 7, 1, &state);\n          ASSERT (ret == 1);\n          ASSERT (wc == '>');\n          ASSERT (mbsinit (&state));\n        }\n        return 0;\n\n      case '4':\n        /* Locale encoding is GB18030.  */\n        {\n          char input[] = \"B\\250\\271\\201\\060\\211\\070er\"; /* \"B\u00c3\u00bc\u00c3\u009fer\" */\n          memset (&state, '\\0', sizeof (mbstate_t));\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input, 1, &state);\n          ASSERT (ret == 1);\n          ASSERT (wc == 'B');\n          ASSERT (mbsinit (&state));\n          input[0] = '\\0';\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input + 1, 1, &state);\n          ASSERT (ret == (size_t)(-2));\n          ASSERT (wc == (wchar_t) 0xBADFACE);\n          ASSERT (!mbsinit (&state));\n          input[1] = '\\0';\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input + 2, 7, &state);\n          ASSERT (ret == 1);\n          ASSERT (wctob (wc) == EOF);\n          ASSERT (mbsinit (&state));\n          input[2] = '\\0';\n\n          /* Test support of NULL first argument.  */\n          ret = mbrtowc (NULL, input + 3, 6, &state);\n          ASSERT (ret == 4);\n          ASSERT (mbsinit (&state));\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input + 3, 6, &state);\n          ASSERT (ret == 4);\n          ASSERT (wctob (wc) == EOF);\n          ASSERT (mbsinit (&state));\n          input[3] = '\\0';\n          input[4] = '\\0';\n          input[5] = '\\0';\n          input[6] = '\\0';\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input + 7, 2, &state);\n          ASSERT (ret == 1);\n          ASSERT (wc == 'e');\n          ASSERT (mbsinit (&state));\n          input[5] = '\\0';\n\n          wc = (wchar_t) 0xBADFACE;\n          ret = mbrtowc (&wc, input + 8, 1, &state);\n          ASSERT (ret == 1);\n          ASSERT (wc == 'r');\n          ASSERT (mbsinit (&state));\n        }\n        return 0;\n      }\n\n  return 1;\n}",
      "lines": 308,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-mbscasestr1.c": {
    "main": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        128,
        1
      ],
      "content": "int\nmain ()\n{\n  /* This test is executed in the C locale.  */\n\n  {\n    const char input[] = \"foo\";\n    const char *result = mbscasestr (input, \"\");\n    ASSERT (result == input);\n  }\n\n  {\n    const char input[] = \"foo\";\n    const char *result = mbscasestr (input, \"O\");\n    ASSERT (result == input + 1);\n  }\n\n  {\n    const char input[] = \"ABC ABCDAB ABCDABCDABDE\";\n    const char *result = mbscasestr (input, \"ABCDaBD\");\n    ASSERT (result == input + 15);\n  }\n\n  {\n    const char input[] = \"ABC ABCDAB ABCDABCDABDE\";\n    const char *result = mbscasestr (input, \"ABCDaBE\");\n    ASSERT (result == NULL);\n  }\n\n  /* Check that a very long haystack is handled quickly if the needle is\n     short and occurs near the beginning.  */\n  {\n    size_t repeat = 10000;\n    size_t m = 1000000;\n    const char *needle =\n      \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaAaaaaaaAAAAaaaaaaa\"\n      \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\";\n    char *haystack = (char *) malloc (m + 1);\n    if (haystack != NULL)\n      {\n        memset (haystack, 'A', m);\n        haystack[0] = 'B';\n        haystack[m] = '\\0';\n\n        for (; repeat > 0; repeat--)\n          {\n            ASSERT (mbscasestr (haystack, needle) == haystack + 1);\n          }\n\n        free (haystack);\n      }\n  }\n\n  /* Check that a very long needle is discarded quickly if the haystack is\n     short.  */\n  {\n    size_t repeat = 10000;\n    size_t m = 1000000;\n    const char *haystack =\n      \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n      \"ABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABAB\";\n    char *needle = (char *) malloc (m + 1);\n    if (needle != NULL)\n      {\n        memset (needle, 'A', m);\n        needle[m] = '\\0';\n\n        for (; repeat > 0; repeat--)\n          {\n            ASSERT (mbscasestr (haystack, needle) == NULL);\n          }\n\n        free (needle);\n      }\n  }\n\n  /* Check that the asymptotic worst-case complexity is not quadratic.  */\n  {\n    size_t m = 1000000;\n    char *haystack = (char *) malloc (2 * m + 2);\n    char *needle = (char *) malloc (m + 2);\n    if (haystack != NULL && needle != NULL)\n      {\n        const char *result;\n\n        memset (haystack, 'A', 2 * m);\n        haystack[2 * m] = 'B';\n        haystack[2 * m + 1] = '\\0';\n\n        memset (needle, 'a', m);\n        needle[m] = 'B';\n        needle[m + 1] = '\\0';\n\n        result = mbscasestr (haystack, needle);\n        ASSERT (result == haystack + m);\n      }\n    free (needle);\n    free (haystack);\n  }\n\n  return 0;\n}",
      "lines": 103,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-mbscasestr2.c": {
    "main": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        140,
        1
      ],
      "content": "int\nmain ()\n{\n  /* configure should already have checked that the locale is supported.  */\n  if (setlocale (LC_ALL, \"\") == NULL)\n    return 1;\n\n  {\n    const char input[] = \"f\\303\\266\\303\\266\";\n    const char *result = mbscasestr (input, \"\");\n    ASSERT (result == input);\n  }\n\n  {\n    const char input[] = \"f\\303\\266\\303\\266\";\n    const char *result = mbscasestr (input, \"\\303\\266\");\n    ASSERT (result == input + 1);\n  }\n\n  {\n    const char input[] = \"f\\303\\266\\303\\266\";\n    const char *result = mbscasestr (input, \"\\266\\303\");\n    ASSERT (result == NULL);\n  }\n\n  {\n    const char input[] = \"\\303\\204BC \\303\\204BCD\\303\\204B \\303\\204BCD\\303\\204BCD\\303\\204BDE\"; /* \"\u00c3\u0084BC \u00c3\u0084BCD\u00c3\u0084B \u00c3\u0084BCD\u00c3\u0084BCD\u00c3\u0084BDE\" */\n    const char *result = mbscasestr (input, \"\\303\\244BCD\\303\\204BD\"); /* \"\u00c3\u00a4BCD\u00c3\u0084BD\" */\n    ASSERT (result == input + 19);\n  }\n\n  {\n    const char input[] = \"\\303\\204BC \\303\\204BCD\\303\\204B \\303\\204BCD\\303\\204BCD\\303\\204BDE\"; /* \"\u00c3\u0084BC \u00c3\u0084BCD\u00c3\u0084B \u00c3\u0084BCD\u00c3\u0084BCD\u00c3\u0084BDE\" */\n    const char *result = mbscasestr (input, \"\\303\\204BCD\\303\\204BE\"); /* \"\u00c3\u0084BCD\u00c3\u0084BE\" */\n    ASSERT (result == NULL);\n  }\n\n  /* Check that a very long haystack is handled quickly if the needle is\n     short and occurs near the beginning.  */\n  {\n    size_t repeat = 10000;\n    size_t m = 1000000;\n    const char *needle =\n      \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n      \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\";\n    char *haystack = (char *) malloc (m + 1);\n    if (haystack != NULL)\n      {\n        memset (haystack, 'a', m);\n        haystack[0] = '\\303'; haystack[1] = '\\204';\n        haystack[m] = '\\0';\n\n        for (; repeat > 0; repeat--)\n          {\n            ASSERT (mbscasestr (haystack, needle) == haystack + 2);\n          }\n\n        free (haystack);\n      }\n  }\n\n  /* Check that a very long needle is discarded quickly if the haystack is\n     short.  */\n  {\n    size_t repeat = 10000;\n    size_t m = 1000000;\n    const char *haystack =\n      \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n      \"A\\303\\207A\\303\\207A\\303\\207A\\303\\207A\\303\\207A\\303\\207A\\303\\207\"\n      \"A\\303\\207A\\303\\207A\\303\\207A\\303\\207A\\303\\207A\\303\\207A\\303\\207\"\n      \"A\\303\\207A\\303\\207A\\303\\207A\\303\\207A\\303\\207A\\303\\207A\\303\\207\"\n      \"A\\303\\207A\\303\\207A\\303\\207A\\303\\207A\\303\\207A\\303\\207A\\303\\207\"\n      \"A\\303\\207A\\303\\207A\\303\\207A\\303\\207A\\303\\207A\\303\\207\";\n    char *needle = (char *) malloc (m + 1);\n    if (needle != NULL)\n      {\n        memset (needle, 'A', m);\n        needle[m] = '\\0';\n\n        for (; repeat > 0; repeat--)\n          {\n            ASSERT (mbscasestr (haystack, needle) == NULL);\n          }\n\n        free (needle);\n      }\n  }\n\n  /* Check that the asymptotic worst-case complexity is not quadratic.  */\n  {\n    size_t m = 1000000;\n    char *haystack = (char *) malloc (2 * m + 3);\n    char *needle = (char *) malloc (m + 3);\n    if (haystack != NULL && needle != NULL)\n      {\n        const char *result;\n\n        memset (haystack, 'A', 2 * m);\n        haystack[2 * m] = '\\303'; haystack[2 * m + 1] = '\\247';\n        haystack[2 * m + 2] = '\\0';\n\n        memset (needle, 'a', m);\n        needle[m] = '\\303'; needle[m + 1] = '\\207';\n        needle[m + 2] = '\\0';\n\n        result = mbscasestr (haystack, needle);\n        ASSERT (result == haystack + m);\n      }\n    free (needle);\n    free (haystack);\n  }\n\n  return 0;\n}",
      "lines": 114,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-mbscasestr3.c": {
    "main": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        81,
        1
      ],
      "content": "int\nmain ()\n{\n  /* configure should already have checked that the locale is supported.  */\n  if (setlocale (LC_ALL, \"\") == NULL)\n    return 1;\n\n  /* Tests with a character < 0x30.  */\n  {\n    const char input[] = \"\\312\\276\\300\\375 \\312\\276\\300\\375 \\312\\276\\300\\375\"; /* \"\u00e7\u00a4\u00ba\u00e4\u00be\u008b \u00e7\u00a4\u00ba\u00e4\u00be\u008b \u00e7\u00a4\u00ba\u00e4\u00be\u008b\" */\n    const char *result = mbscasestr (input, \" \");\n    ASSERT (result == input + 4);\n  }\n\n  {\n    const char input[] = \"\\312\\276\\300\\375\"; /* \"\u00e7\u00a4\u00ba\u00e4\u00be\u008b\" */\n    const char *result = mbscasestr (input, \" \");\n    ASSERT (result == NULL);\n  }\n\n  /* Tests with a character >= 0x30.  */\n  {\n    const char input[] = \"\\272\\305123\\324\\313\\320\\320\\241\\243\"; /* \"\u00e5\u008f\u00b7123\u00e8\u00bf\u0090\u00e8\u00a1\u008c\u00e3\u0080\u0082\" */\n    const char *result = mbscasestr (input, \"2\");\n    ASSERT (result == input + 3);\n  }\n\n  /* The following tests show how mbscasestr() is different from\n     strcasestr().  */\n\n  {\n    const char input[] = \"\\313\\320\\320\\320\"; /* \"\u00e8\u00af\u00b5\u00e8\u00a1\u008c\" */\n    const char *result = mbscasestr (input, \"\\320\\320\"); /* \"\u00e8\u00a1\u008c\" */\n    ASSERT (result == input + 2);\n  }\n\n  {\n    const char input[] = \"\\203\\062\\332\\066123\\324\\313\\320\\320\\241\\243\"; /* \"\u00ec\u0094\u008b123\u00e8\u00bf\u0090\u00e8\u00a1\u008c\u00e3\u0080\u0082\" */\n    const char *result = mbscasestr (input, \"2\");\n    ASSERT (result == input + 5);\n  }\n\n  {\n    const char input[] = \"\\312\\276\\300\\375 \\312\\276\\300\\375 \\312\\276\\300\\375\"; /* \"\u00e7\u00a4\u00ba\u00e4\u00be\u008b \u00e7\u00a4\u00ba\u00e4\u00be\u008b \u00e7\u00a4\u00ba\u00e4\u00be\u008b\" */\n    const char *result = mbscasestr (input, \"\\276\\300\"); /* \"\u00e7\u00ba\u00a0\" */\n    ASSERT (result == NULL);\n  }\n\n  {\n    const char input[] = \"\\312\\276\\300\\375 \\312\\276\\300\\375 \\312\\276\\300\\375\"; /* \"\u00e7\u00a4\u00ba\u00e4\u00be\u008b \u00e7\u00a4\u00ba\u00e4\u00be\u008b \u00e7\u00a4\u00ba\u00e4\u00be\u008b\" */\n    const char *result = mbscasestr (input, \"\\375 \"); /* invalid multibyte sequence */\n    ASSERT (result == NULL);\n  }\n\n  return 0;\n}",
      "lines": 56,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-mbscasestr4.c": {
    "main": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "int\nmain ()\n{\n  /* configure should already have checked that the locale is supported.  */\n  if (setlocale (LC_ALL, \"\") == NULL)\n    return 1;\n\n  {\n    const char input[] = \"GOLD NEEDLE BEATS TIN NEEDLE\";\n    ASSERT (mbscasestr (input, \"Needle\") == input + 5);\n  }\n\n  /* The following tests show how mbscasestr() is different from\n     strcasestr().  */\n\n  {\n    const char input[] = \"s\\303\\266zc\\303\\274k\"; /* s\u00c3\u00b6zc\u00c3\u00bck */\n    ASSERT (mbscasestr (input, \"\\303\\266z\") == input + 1);\n    ASSERT (mbscasestr (input, \"\\303\\266c\") == NULL);\n  }\n\n  /* This test shows how a string of larger size can be found in a string of\n     smaller size.  */\n  {\n    const char input[] = \"*Tbilisi imini*\";\n    ASSERT (mbscasestr (input, \"TB\\304\\260L\\304\\260S\\304\\260 \\304\\260m\\304\\260n\\304\\260\") == input + 1); /* TB\u00c4\u00b0L\u00c4\u00b0S\u00c4\u00b0 \u00c4\u00b0m\u00c4\u00b0n\u00c4\u00b0 */\n  }\n\n  return 0;\n}",
      "lines": 30,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-mbsinit.c": {
    "main": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  static mbstate_t state;\n\n  ASSERT (mbsinit (NULL));\n\n  ASSERT (mbsinit (&state));\n\n  if (argc > 1)\n    {\n      static const char input[1] = \"\\303\";\n      wchar_t wc;\n      size_t ret;\n\n      /* configure should already have checked that the locale is supported.  */\n      if (setlocale (LC_ALL, \"\") == NULL)\n        return 1;\n\n      ret = mbrtowc (&wc, input, 1, &state);\n      ASSERT (ret == (size_t)(-2));\n      ASSERT (!mbsinit (&state));\n    }\n\n  return 0;\n}",
      "lines": 26,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-mbsrtowcs.c": {
    "main": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        292,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  mbstate_t state;\n  wchar_t wc;\n  size_t ret;\n\n  /* configure should already have checked that the locale is supported.  */\n  if (setlocale (LC_ALL, \"\") == NULL)\n    return 1;\n\n  /* Test NUL byte input.  */\n  {\n    const char *src;\n\n    memset (&state, '\\0', sizeof (mbstate_t));\n\n    src = \"\";\n    ret = mbsrtowcs (NULL, &src, 0, &state);\n    ASSERT (ret == 0);\n    ASSERT (mbsinit (&state));\n\n    src = \"\";\n    ret = mbsrtowcs (NULL, &src, 1, &state);\n    ASSERT (ret == 0);\n    ASSERT (mbsinit (&state));\n\n    wc = (wchar_t) 0xBADFACE;\n    src = \"\";\n    ret = mbsrtowcs (&wc, &src, 0, &state);\n    ASSERT (ret == 0);\n    ASSERT (wc == (wchar_t) 0xBADFACE);\n    ASSERT (mbsinit (&state));\n\n    wc = (wchar_t) 0xBADFACE;\n    src = \"\";\n    ret = mbsrtowcs (&wc, &src, 1, &state);\n    ASSERT (ret == 0);\n    ASSERT (wc == 0);\n    ASSERT (mbsinit (&state));\n  }\n\n  if (argc > 1)\n    {\n      int unlimited;\n\n      for (unlimited = 0; unlimited < 2; unlimited++)\n        {\n          #define BUFSIZE 10\n          wchar_t buf[BUFSIZE];\n          const char *src;\n          mbstate_t temp_state;\n\n          {\n            size_t i;\n            for (i = 0; i < BUFSIZE; i++)\n              buf[i] = (wchar_t) 0xBADFACE;\n          }\n\n          switch (argv[1][0])\n            {\n            case '1':\n              /* Locale encoding is ISO-8859-1 or ISO-8859-15.  */\n              {\n                char input[] = \"B\\374\\337er\"; /* \"B\u00c3\u00bc\u00c3\u009fer\" */\n                memset (&state, '\\0', sizeof (mbstate_t));\n\n                wc = (wchar_t) 0xBADFACE;\n                ret = mbrtowc (&wc, input, 1, &state);\n                ASSERT (ret == 1);\n                ASSERT (wc == 'B');\n                ASSERT (mbsinit (&state));\n                input[0] = '\\0';\n\n                wc = (wchar_t) 0xBADFACE;\n                ret = mbrtowc (&wc, input + 1, 1, &state);\n                ASSERT (ret == 1);\n                ASSERT (wctob (wc) == (unsigned char) '\\374');\n                ASSERT (mbsinit (&state));\n                input[1] = '\\0';\n\n                src = input + 2;\n                temp_state = state;\n                ret = mbsrtowcs (NULL, &src, unlimited ? BUFSIZE : 1, &temp_state);\n                ASSERT (ret == 3);\n                ASSERT (src == input + 2);\n                ASSERT (mbsinit (&state));\n\n                src = input + 2;\n                ret = mbsrtowcs (buf, &src, unlimited ? BUFSIZE : 1, &state);\n                ASSERT (ret == (unlimited ? 3 : 1));\n                ASSERT (src == (unlimited ? NULL : input + 3));\n                ASSERT (wctob (buf[0]) == (unsigned char) '\\337');\n                if (unlimited)\n                  {\n                    ASSERT (buf[1] == 'e');\n                    ASSERT (buf[2] == 'r');\n                    ASSERT (buf[3] == 0);\n                    ASSERT (buf[4] == (wchar_t) 0xBADFACE);\n                  }\n                else\n                  ASSERT (buf[1] == (wchar_t) 0xBADFACE);\n                ASSERT (mbsinit (&state));\n              }\n              break;\n\n            case '2':\n              /* Locale encoding is UTF-8.  */\n              {\n                char input[] = \"B\\303\\274\\303\\237er\"; /* \"B\u00c3\u00bc\u00c3\u009fer\" */\n                memset (&state, '\\0', sizeof (mbstate_t));\n\n                wc = (wchar_t) 0xBADFACE;\n                ret = mbrtowc (&wc, input, 1, &state);\n                ASSERT (ret == 1);\n                ASSERT (wc == 'B');\n                ASSERT (mbsinit (&state));\n                input[0] = '\\0';\n\n                wc = (wchar_t) 0xBADFACE;\n                ret = mbrtowc (&wc, input + 1, 1, &state);\n                ASSERT (ret == (size_t)(-2));\n                ASSERT (wc == (wchar_t) 0xBADFACE);\n                ASSERT (!mbsinit (&state));\n                input[1] = '\\0';\n\n                src = input + 2;\n                temp_state = state;\n                ret = mbsrtowcs (NULL, &src, unlimited ? BUFSIZE : 2, &temp_state);\n                ASSERT (ret == 4);\n                ASSERT (src == input + 2);\n                ASSERT (!mbsinit (&state));\n\n                src = input + 2;\n                ret = mbsrtowcs (buf, &src, unlimited ? BUFSIZE : 2, &state);\n                ASSERT (ret == (unlimited ? 4 : 2));\n                ASSERT (src == (unlimited ? NULL : input + 5));\n                ASSERT (wctob (buf[0]) == EOF);\n                ASSERT (wctob (buf[1]) == EOF);\n                if (unlimited)\n                  {\n                    ASSERT (buf[2] == 'e');\n                    ASSERT (buf[3] == 'r');\n                    ASSERT (buf[4] == 0);\n                    ASSERT (buf[5] == (wchar_t) 0xBADFACE);\n                  }\n                else\n                  ASSERT (buf[2] == (wchar_t) 0xBADFACE);\n                ASSERT (mbsinit (&state));\n              }\n              break;\n\n            case '3':\n              /* Locale encoding is EUC-JP.  */\n              {\n                char input[] = \"<\\306\\374\\313\\334\\270\\354>\"; /* \"<\u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e>\" */\n                memset (&state, '\\0', sizeof (mbstate_t));\n\n                wc = (wchar_t) 0xBADFACE;\n                ret = mbrtowc (&wc, input, 1, &state);\n                ASSERT (ret == 1);\n                ASSERT (wc == '<');\n                ASSERT (mbsinit (&state));\n                input[0] = '\\0';\n\n                wc = (wchar_t) 0xBADFACE;\n                ret = mbrtowc (&wc, input + 1, 2, &state);\n                ASSERT (ret == 2);\n                ASSERT (wctob (wc) == EOF);\n                ASSERT (mbsinit (&state));\n                input[1] = '\\0';\n                input[2] = '\\0';\n\n                wc = (wchar_t) 0xBADFACE;\n                ret = mbrtowc (&wc, input + 3, 1, &state);\n                ASSERT (ret == (size_t)(-2));\n                ASSERT (wc == (wchar_t) 0xBADFACE);\n                ASSERT (!mbsinit (&state));\n                input[3] = '\\0';\n\n                src = input + 4;\n                temp_state = state;\n                ret = mbsrtowcs (NULL, &src, unlimited ? BUFSIZE : 2, &temp_state);\n                ASSERT (ret == 3);\n                ASSERT (src == input + 4);\n                ASSERT (!mbsinit (&state));\n\n                src = input + 4;\n                ret = mbsrtowcs (buf, &src, unlimited ? BUFSIZE : 2, &state);\n                ASSERT (ret == (unlimited ? 3 : 2));\n                ASSERT (src == (unlimited ? NULL : input + 7));\n                ASSERT (wctob (buf[0]) == EOF);\n                ASSERT (wctob (buf[1]) == EOF);\n                if (unlimited)\n                  {\n                    ASSERT (buf[2] == '>');\n                    ASSERT (buf[3] == 0);\n                    ASSERT (buf[4] == (wchar_t) 0xBADFACE);\n                  }\n                else\n                  ASSERT (buf[2] == (wchar_t) 0xBADFACE);\n                ASSERT (mbsinit (&state));\n              }\n              break;\n\n            case '4':\n              /* Locale encoding is GB18030.  */\n              {\n                char input[] = \"B\\250\\271\\201\\060\\211\\070er\"; /* \"B\u00c3\u00bc\u00c3\u009fer\" */\n                memset (&state, '\\0', sizeof (mbstate_t));\n\n                wc = (wchar_t) 0xBADFACE;\n                ret = mbrtowc (&wc, input, 1, &state);\n                ASSERT (ret == 1);\n                ASSERT (wc == 'B');\n                ASSERT (mbsinit (&state));\n                input[0] = '\\0';\n\n                wc = (wchar_t) 0xBADFACE;\n                ret = mbrtowc (&wc, input + 1, 1, &state);\n                ASSERT (ret == (size_t)(-2));\n                ASSERT (wc == (wchar_t) 0xBADFACE);\n                ASSERT (!mbsinit (&state));\n                input[1] = '\\0';\n\n                src = input + 2;\n                temp_state = state;\n                ret = mbsrtowcs (NULL, &src, unlimited ? BUFSIZE : 2, &temp_state);\n                ASSERT (ret == 4);\n                ASSERT (src == input + 2);\n                ASSERT (!mbsinit (&state));\n\n                src = input + 2;\n                ret = mbsrtowcs (buf, &src, unlimited ? BUFSIZE : 2, &state);\n                ASSERT (ret == (unlimited ? 4 : 2));\n                ASSERT (src == (unlimited ? NULL : input + 7));\n                ASSERT (wctob (buf[0]) == EOF);\n                ASSERT (wctob (buf[1]) == EOF);\n                if (unlimited)\n                  {\n                    ASSERT (buf[2] == 'e');\n                    ASSERT (buf[3] == 'r');\n                    ASSERT (buf[4] == 0);\n                    ASSERT (buf[5] == (wchar_t) 0xBADFACE);\n                  }\n                else\n                  ASSERT (buf[2] == (wchar_t) 0xBADFACE);\n                ASSERT (mbsinit (&state));\n              }\n              break;\n\n            default:\n              return 1;\n            }\n        }\n\n      return 0;\n    }\n\n  return 1;\n}",
      "lines": 261,
      "depth": 19,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-mbsstr1.c": {
    "main": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        127,
        1
      ],
      "content": "int\nmain ()\n{\n  /* This test is executed in the C locale.  */\n\n  {\n    const char input[] = \"foo\";\n    const char *result = mbsstr (input, \"\");\n    ASSERT (result == input);\n  }\n\n  {\n    const char input[] = \"foo\";\n    const char *result = mbsstr (input, \"o\");\n    ASSERT (result == input + 1);\n  }\n\n  {\n    const char input[] = \"ABC ABCDAB ABCDABCDABDE\";\n    const char *result = mbsstr (input, \"ABCDABD\");\n    ASSERT (result == input + 15);\n  }\n\n  {\n    const char input[] = \"ABC ABCDAB ABCDABCDABDE\";\n    const char *result = mbsstr (input, \"ABCDABE\");\n    ASSERT (result == NULL);\n  }\n\n  /* Check that a very long haystack is handled quickly if the needle is\n     short and occurs near the beginning.  */\n  {\n    size_t repeat = 10000;\n    size_t m = 1000000;\n    const char *needle =\n      \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n      \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\";\n    char *haystack = (char *) malloc (m + 1);\n    if (haystack != NULL)\n      {\n        memset (haystack, 'A', m);\n        haystack[0] = 'B';\n        haystack[m] = '\\0';\n\n        for (; repeat > 0; repeat--)\n          {\n            ASSERT (mbsstr (haystack, needle) == haystack + 1);\n          }\n\n        free (haystack);\n      }\n  }\n\n  /* Check that a very long needle is discarded quickly if the haystack is\n     short.  */\n  {\n    size_t repeat = 10000;\n    size_t m = 1000000;\n    const char *haystack =\n      \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n      \"ABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABAB\";\n    char *needle = (char *) malloc (m + 1);\n    if (needle != NULL)\n      {\n        memset (needle, 'A', m);\n        needle[m] = '\\0';\n\n        for (; repeat > 0; repeat--)\n          {\n            ASSERT (mbsstr (haystack, needle) == NULL);\n          }\n\n        free (needle);\n      }\n  }\n\n  /* Check that the asymptotic worst-case complexity is not quadratic.  */\n  {\n    size_t m = 1000000;\n    char *haystack = (char *) malloc (2 * m + 2);\n    char *needle = (char *) malloc (m + 2);\n    if (haystack != NULL && needle != NULL)\n      {\n        const char *result;\n\n        memset (haystack, 'A', 2 * m);\n        haystack[2 * m] = 'B';\n        haystack[2 * m + 1] = '\\0';\n\n        memset (needle, 'A', m);\n        needle[m] = 'B';\n        needle[m + 1] = '\\0';\n\n        result = mbsstr (haystack, needle);\n        ASSERT (result == haystack + m);\n      }\n    free (needle);\n    free (haystack);\n  }\n\n  return 0;\n}",
      "lines": 102,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-mbsstr2.c": {
    "main": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        140,
        1
      ],
      "content": "int\nmain ()\n{\n  /* configure should already have checked that the locale is supported.  */\n  if (setlocale (LC_ALL, \"\") == NULL)\n    return 1;\n\n  {\n    const char input[] = \"f\\303\\266\\303\\266\";\n    const char *result = mbsstr (input, \"\");\n    ASSERT (result == input);\n  }\n\n  {\n    const char input[] = \"f\\303\\266\\303\\266\";\n    const char *result = mbsstr (input, \"\\303\\266\");\n    ASSERT (result == input + 1);\n  }\n\n  {\n    const char input[] = \"f\\303\\266\\303\\266\";\n    const char *result = mbsstr (input, \"\\266\\303\");\n    ASSERT (result == NULL);\n  }\n\n  {\n    const char input[] = \"\\303\\204BC \\303\\204BCD\\303\\204B \\303\\204BCD\\303\\204BCD\\303\\204BDE\"; /* \"\u00c3\u0084BC \u00c3\u0084BCD\u00c3\u0084B \u00c3\u0084BCD\u00c3\u0084BCD\u00c3\u0084BDE\" */\n    const char *result = mbsstr (input, \"\\303\\204BCD\\303\\204BD\"); /* \"\u00c3\u0084BCD\u00c3\u0084BD\" */\n    ASSERT (result == input + 19);\n  }\n\n  {\n    const char input[] = \"\\303\\204BC \\303\\204BCD\\303\\204B \\303\\204BCD\\303\\204BCD\\303\\204BDE\"; /* \"\u00c3\u0084BC \u00c3\u0084BCD\u00c3\u0084B \u00c3\u0084BCD\u00c3\u0084BCD\u00c3\u0084BDE\" */\n    const char *result = mbsstr (input, \"\\303\\204BCD\\303\\204BE\"); /* \"\u00c3\u0084BCD\u00c3\u0084BE\" */\n    ASSERT (result == NULL);\n  }\n\n  /* Check that a very long haystack is handled quickly if the needle is\n     short and occurs near the beginning.  */\n  {\n    size_t repeat = 10000;\n    size_t m = 1000000;\n    const char *needle =\n      \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n      \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\";\n    char *haystack = (char *) malloc (m + 1);\n    if (haystack != NULL)\n      {\n        memset (haystack, 'A', m);\n        haystack[0] = '\\303'; haystack[1] = '\\204';\n        haystack[m] = '\\0';\n\n        for (; repeat > 0; repeat--)\n          {\n            ASSERT (mbsstr (haystack, needle) == haystack + 2);\n          }\n\n        free (haystack);\n      }\n  }\n\n  /* Check that a very long needle is discarded quickly if the haystack is\n     short.  */\n  {\n    size_t repeat = 10000;\n    size_t m = 1000000;\n    const char *haystack =\n      \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n      \"A\\303\\207A\\303\\207A\\303\\207A\\303\\207A\\303\\207A\\303\\207A\\303\\207\"\n      \"A\\303\\207A\\303\\207A\\303\\207A\\303\\207A\\303\\207A\\303\\207A\\303\\207\"\n      \"A\\303\\207A\\303\\207A\\303\\207A\\303\\207A\\303\\207A\\303\\207A\\303\\207\"\n      \"A\\303\\207A\\303\\207A\\303\\207A\\303\\207A\\303\\207A\\303\\207A\\303\\207\"\n      \"A\\303\\207A\\303\\207A\\303\\207A\\303\\207A\\303\\207A\\303\\207\";\n    char *needle = (char *) malloc (m + 1);\n    if (needle != NULL)\n      {\n        memset (needle, 'A', m);\n        needle[m] = '\\0';\n\n        for (; repeat > 0; repeat--)\n          {\n            ASSERT (mbsstr (haystack, needle) == NULL);\n          }\n\n        free (needle);\n      }\n  }\n\n  /* Check that the asymptotic worst-case complexity is not quadratic.  */\n  {\n    size_t m = 1000000;\n    char *haystack = (char *) malloc (2 * m + 3);\n    char *needle = (char *) malloc (m + 3);\n    if (haystack != NULL && needle != NULL)\n      {\n        const char *result;\n\n        memset (haystack, 'A', 2 * m);\n        haystack[2 * m] = '\\303'; haystack[2 * m + 1] = '\\207';\n        haystack[2 * m + 2] = '\\0';\n\n        memset (needle, 'A', m);\n        needle[m] = '\\303'; needle[m + 1] = '\\207';\n        needle[m + 2] = '\\0';\n\n        result = mbsstr (haystack, needle);\n        ASSERT (result == haystack + m);\n      }\n    free (needle);\n    free (haystack);\n  }\n\n  return 0;\n}",
      "lines": 114,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-mbsstr3.c": {
    "main": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        80,
        1
      ],
      "content": "int\nmain ()\n{\n  /* configure should already have checked that the locale is supported.  */\n  if (setlocale (LC_ALL, \"\") == NULL)\n    return 1;\n\n  /* Tests with a character < 0x30.  */\n  {\n    const char input[] = \"\\312\\276\\300\\375 \\312\\276\\300\\375 \\312\\276\\300\\375\"; /* \"\u00e7\u00a4\u00ba\u00e4\u00be\u008b \u00e7\u00a4\u00ba\u00e4\u00be\u008b \u00e7\u00a4\u00ba\u00e4\u00be\u008b\" */\n    const char *result = mbsstr (input, \" \");\n    ASSERT (result == input + 4);\n  }\n\n  {\n    const char input[] = \"\\312\\276\\300\\375\"; /* \"\u00e7\u00a4\u00ba\u00e4\u00be\u008b\" */\n    const char *result = mbsstr (input, \" \");\n    ASSERT (result == NULL);\n  }\n\n  /* Tests with a character >= 0x30.  */\n  {\n    const char input[] = \"\\272\\305123\\324\\313\\320\\320\\241\\243\"; /* \"\u00e5\u008f\u00b7123\u00e8\u00bf\u0090\u00e8\u00a1\u008c\u00e3\u0080\u0082\" */\n    const char *result = mbsstr (input, \"2\");\n    ASSERT (result == input + 3);\n  }\n\n  /* The following tests show how mbsstr() is different from strstr().  */\n\n  {\n    const char input[] = \"\\313\\320\\320\\320\"; /* \"\u00e8\u00af\u00b5\u00e8\u00a1\u008c\" */\n    const char *result = mbsstr (input, \"\\320\\320\"); /* \"\u00e8\u00a1\u008c\" */\n    ASSERT (result == input + 2);\n  }\n\n  {\n    const char input[] = \"\\203\\062\\332\\066123\\324\\313\\320\\320\\241\\243\"; /* \"\u00ec\u0094\u008b123\u00e8\u00bf\u0090\u00e8\u00a1\u008c\u00e3\u0080\u0082\" */\n    const char *result = mbsstr (input, \"2\");\n    ASSERT (result == input + 5);\n  }\n\n  {\n    const char input[] = \"\\312\\276\\300\\375 \\312\\276\\300\\375 \\312\\276\\300\\375\"; /* \"\u00e7\u00a4\u00ba\u00e4\u00be\u008b \u00e7\u00a4\u00ba\u00e4\u00be\u008b \u00e7\u00a4\u00ba\u00e4\u00be\u008b\" */\n    const char *result = mbsstr (input, \"\\276\\300\"); /* \"\u00e7\u00ba\u00a0\" */\n    ASSERT (result == NULL);\n  }\n\n  {\n    const char input[] = \"\\312\\276\\300\\375 \\312\\276\\300\\375 \\312\\276\\300\\375\"; /* \"\u00e7\u00a4\u00ba\u00e4\u00be\u008b \u00e7\u00a4\u00ba\u00e4\u00be\u008b \u00e7\u00a4\u00ba\u00e4\u00be\u008b\" */\n    const char *result = mbsstr (input, \"\\375 \"); /* invalid multibyte sequence */\n    ASSERT (result == NULL);\n  }\n\n  return 0;\n}",
      "lines": 55,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-memchr.c": {
    "main": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        131,
        1
      ],
      "content": "int\nmain (void)\n{\n  size_t n = 0x100000;\n  char *input = malloc (n);\n  ASSERT (input);\n\n  input[0] = 'a';\n  input[1] = 'b';\n  memset (input + 2, 'c', 1024);\n  memset (input + 1026, 'd', n - 1028);\n  input[n - 2] = 'e';\n  input[n - 1] = 'a';\n\n  /* Basic behavior tests.  */\n  ASSERT (MEMCHR (input, 'a', n) == input);\n\n  ASSERT (MEMCHR (input, 'a', 0) == NULL);\n  ASSERT (MEMCHR (zerosize_ptr (), 'a', 0) == NULL);\n\n  ASSERT (MEMCHR (input, 'b', n) == input + 1);\n  ASSERT (MEMCHR (input, 'c', n) == input + 2);\n  ASSERT (MEMCHR (input, 'd', n) == input + 1026);\n\n  ASSERT (MEMCHR (input + 1, 'a', n - 1) == input + n - 1);\n  ASSERT (MEMCHR (input + 1, 'e', n - 1) == input + n - 2);\n  ASSERT (MEMCHR (input + 1, 0x789abc00 | 'e', n - 1) == input + n - 2);\n\n  ASSERT (MEMCHR (input, 'f', n) == NULL);\n  ASSERT (MEMCHR (input, '\\0', n) == NULL);\n\n  /* Check that a very long haystack is handled quickly if the byte is\n     found near the beginning.  */\n  {\n    size_t repeat = 10000;\n    for (; repeat > 0; repeat--)\n      {\n        ASSERT (MEMCHR (input, 'c', n) == input + 2);\n      }\n  }\n\n  /* Alignment tests.  */\n  {\n    int i, j;\n    for (i = 0; i < 32; i++)\n      {\n        for (j = 0; j < 256; j++)\n          input[i + j] = j;\n        for (j = 0; j < 256; j++)\n          {\n            ASSERT (MEMCHR (input + i, j, 256) == input + i + j);\n          }\n      }\n  }\n\n  /* Check that memchr() does not read past the first occurrence of the\n     byte being searched.  See the Austin Group's clarification\n     <http://www.opengroup.org/austin/docs/austin_454.txt>.\n     Test both '\\0' and something else, since some implementations\n     special-case searching for NUL.\n  */\n  {\n    char *page_boundary = (char *) zerosize_ptr ();\n    /* Too small, and we miss cache line boundary tests; too large,\n       and the test takes cubically longer to complete.  */\n    int limit = 257;\n\n    if (page_boundary != NULL)\n      {\n        for (n = 1; n <= limit; n++)\n          {\n            char *mem = page_boundary - n;\n            memset (mem, 'X', n);\n            ASSERT (MEMCHR (mem, 'U', n) == NULL);\n            ASSERT (MEMCHR (mem, 0, n) == NULL);\n\n            {\n              size_t i;\n              size_t k;\n\n              for (i = 0; i < n; i++)\n                {\n                  mem[i] = 'U';\n                  for (k = i + 1; k < n + limit; k++)\n                    ASSERT (MEMCHR (mem, 'U', k) == mem + i);\n                  mem[i] = 0;\n                  for (k = i + 1; k < n + limit; k++)\n                    ASSERT (MEMCHR (mem, 0, k) == mem + i);\n                  mem[i] = 'X';\n                }\n            }\n          }\n      }\n  }\n\n  free (input);\n\n  return 0;\n}",
      "lines": 99,
      "depth": 19,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-memrchr.c": {
    "main": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "int\nmain (void)\n{\n  size_t n = 0x100000;\n  char *input = malloc (n);\n  ASSERT (input);\n\n  input[n - 1] = 'a';\n  input[n - 2] = 'b';\n  memset (input + n - 1026, 'c', 1024);\n  memset (input + 2, 'd', n - 1028);\n  input[1] = 'e';\n  input[0] = 'a';\n\n  /* Basic behavior tests.  */\n  ASSERT (MEMRCHR (input, 'a', n) == input + n - 1);\n\n  ASSERT (MEMRCHR (input, 'a', 0) == NULL);\n  ASSERT (MEMRCHR (zerosize_ptr (), 'a', 0) == NULL);\n\n  ASSERT (MEMRCHR (input, 'b', n) == input + n - 2);\n  ASSERT (MEMRCHR (input, 'c', n) == input + n - 3);\n  ASSERT (MEMRCHR (input, 'd', n) == input + n - 1027);\n\n  ASSERT (MEMRCHR (input, 'a', n - 1) == input);\n  ASSERT (MEMRCHR (input, 'e', n - 1) == input + 1);\n\n  ASSERT (MEMRCHR (input, 'f', n) == NULL);\n  ASSERT (MEMRCHR (input, '\\0', n) == NULL);\n\n  /* Check that a very long haystack is handled quickly if the byte is\n     found near the end.  */\n  {\n    size_t repeat = 10000;\n    for (; repeat > 0; repeat--)\n      {\n        ASSERT (MEMRCHR (input, 'c', n) == input + n - 3);\n      }\n  }\n\n  /* Alignment tests.  */\n  {\n    int i, j;\n    for (i = 0; i < 32; i++)\n      {\n        for (j = 0; j < 256; j++)\n          input[i + j] = j;\n        for (j = 0; j < 256; j++)\n          {\n            ASSERT (MEMRCHR (input + i, j, 256) == input + i + j);\n          }\n      }\n  }\n\n  free (input);\n\n  return 0;\n}",
      "lines": 58,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-modf.c": {
    "main": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "int\nmain ()\n{\n  /* A particular positive value.  */\n  x = 5.972406760;\n  y = modf (x, &z);\n  ASSERT (y >= 0.972406759 && y <= 0.972406761);\n  ASSERT (z == 5.0);\n\n  /* A particular negative value.  */\n  x = -5.972406760;\n  y = modf (x, &z);\n  ASSERT (y >= -0.972406761 && y <= -0.972406759);\n  ASSERT (z == -5.0);\n\n  test_function ();\n\n  return 0;\n}",
      "lines": 19,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-modf.h": {
    "test_function": {
      "start_point": [
        16,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "static void\ntest_function (void)\n{\n  int i;\n  const DOUBLE TWO_MANT_DIG =\n    /* Assume MANT_DIG <= 5 * 31.\n       Use the identity\n         n = floor(n/5) + floor((n+1)/5) + ... + floor((n+4)/5).  */\n    (DOUBLE) (1U << ((MANT_DIG - 1) / 5))\n    * (DOUBLE) (1U << ((MANT_DIG - 1 + 1) / 5))\n    * (DOUBLE) (1U << ((MANT_DIG - 1 + 2) / 5))\n    * (DOUBLE) (1U << ((MANT_DIG - 1 + 3) / 5))\n    * (DOUBLE) (1U << ((MANT_DIG - 1 + 4) / 5));\n\n  /* Randomized tests.  */\n  for (i = 0; i < SIZEOF (RANDOM); i++)\n    {\n      DOUBLE x = RANDOM[i]; /* 0.0 <= x < 1.0 */\n      DOUBLE y;\n      DOUBLE z;\n\n      y = MODF (x, &z);\n      ASSERT (z == L_(0.0));\n      ASSERT (y == x);\n\n      y = MODF (- x, &z);\n      ASSERT (z == L_(0.0));\n      ASSERT (y == - x);\n\n      y = MODF (L_(1.0) + x, &z);\n      ASSERT (z == L_(1.0));\n      y -= x;\n      ASSERT (y >= - L_(1.0) / TWO_MANT_DIG);\n      ASSERT (y <= L_(1.0) / TWO_MANT_DIG);\n\n      y = MODF (- L_(1.0) - x, &z);\n      ASSERT (z == - L_(1.0));\n      y -= - x;\n      ASSERT (y >= - L_(1.0) / TWO_MANT_DIG);\n      ASSERT (y <= L_(1.0) / TWO_MANT_DIG);\n    }\n}",
      "lines": 42,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-nanosleep.c": {
    "handle_alarm": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "static void\nhandle_alarm (int sig)\n{\n  if (sig != SIGALRM)\n    _exit (1);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        82,
        1
      ],
      "content": "int\nmain (void)\n{\n  struct timespec ts;\n\n  ts.tv_sec = 1000;\n  ts.tv_nsec = -1;\n  errno = 0;\n  ASSERT (nanosleep (&ts, NULL) == -1);\n  ASSERT (errno == EINVAL);\n  ts.tv_nsec = 1000000000;\n  errno = 0;\n  ASSERT (nanosleep (&ts, NULL) == -1);\n  ASSERT (errno == EINVAL);\n\n  ts.tv_sec = 0;\n  ts.tv_nsec = 1;\n  ASSERT (nanosleep (&ts, &ts) == 0);\n  /* Remaining time is only defined on EINTR failure; but on success,\n     it is typically either 0 or unchanged from input.  At any rate,\n     it shouldn't be randomly changed to unrelated values.  */\n  ASSERT (ts.tv_sec == 0);\n  ASSERT (ts.tv_nsec == 0 || ts.tv_nsec == 1);\n  ts.tv_nsec = 0;\n  ASSERT (nanosleep (&ts, NULL) == 0);\n\n#if HAVE_DECL_ALARM\n  {\n    const time_t pentecost = 50 * 24 * 60 * 60; /* 50 days.  */\n    signal (SIGALRM, handle_alarm);\n    alarm (1);\n    ts.tv_sec = pentecost;\n    ts.tv_nsec = 999999999;\n    errno = 0;\n    ASSERT (nanosleep (&ts, &ts) == -1);\n    ASSERT (errno == EINTR);\n    ASSERT (pentecost - 10 < ts.tv_sec && ts.tv_sec <= pentecost);\n    ASSERT (0 <= ts.tv_nsec && ts.tv_nsec <= 999999999);\n  }\n#endif\n\n  return 0;\n}",
      "lines": 43,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-netinet_in.c": {
    "main": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        26,
        1
      ],
      "content": "int\nmain (void)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-nl_langinfo.c": {
    "main": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        125,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  int pass = atoi (argv[1]);\n  /* pass    locale\n      0        C\n      1        traditional French locale\n      2        French UTF-8 locale\n   */\n\n  setlocale (LC_ALL, \"\");\n\n  /* nl_langinfo items of the LC_CTYPE category */\n  ASSERT (strlen (nl_langinfo (CODESET)) > 0);\n  if (pass == 2)\n    {\n      const char *codeset = nl_langinfo (CODESET);\n      ASSERT (c_strcasecmp (codeset, \"UTF-8\") == 0 || c_strcasecmp (codeset, \"UTF8\") == 0);\n    }\n  /* nl_langinfo items of the LC_NUMERIC category */\n  ASSERT (strlen (nl_langinfo (RADIXCHAR)) > 0);\n  ASSERT (strlen (nl_langinfo (THOUSEP)) >= 0);\n  /* nl_langinfo items of the LC_TIME category */\n  ASSERT (strlen (nl_langinfo (D_T_FMT)) > 0);\n  ASSERT (strlen (nl_langinfo (D_FMT)) > 0);\n  ASSERT (strlen (nl_langinfo (T_FMT)) > 0);\n  ASSERT (strlen (nl_langinfo (T_FMT_AMPM)) >= (pass == 0 ? 1 : 0));\n  ASSERT (strlen (nl_langinfo (AM_STR)) >= (pass == 0 ? 1 : 0));\n  ASSERT (strlen (nl_langinfo (PM_STR)) >= (pass == 0 ? 1 : 0));\n  ASSERT (strlen (nl_langinfo (DAY_1)) > 0);\n  ASSERT (strlen (nl_langinfo (DAY_2)) > 0);\n  ASSERT (strlen (nl_langinfo (DAY_3)) > 0);\n  ASSERT (strlen (nl_langinfo (DAY_4)) > 0);\n  ASSERT (strlen (nl_langinfo (DAY_5)) > 0);\n  ASSERT (strlen (nl_langinfo (DAY_6)) > 0);\n  ASSERT (strlen (nl_langinfo (DAY_7)) > 0);\n  ASSERT (strlen (nl_langinfo (ABDAY_1)) > 0);\n  ASSERT (strlen (nl_langinfo (ABDAY_2)) > 0);\n  ASSERT (strlen (nl_langinfo (ABDAY_3)) > 0);\n  ASSERT (strlen (nl_langinfo (ABDAY_4)) > 0);\n  ASSERT (strlen (nl_langinfo (ABDAY_5)) > 0);\n  ASSERT (strlen (nl_langinfo (ABDAY_6)) > 0);\n  ASSERT (strlen (nl_langinfo (ABDAY_7)) > 0);\n  ASSERT (strlen (nl_langinfo (MON_1)) > 0);\n  ASSERT (strlen (nl_langinfo (MON_2)) > 0);\n  ASSERT (strlen (nl_langinfo (MON_3)) > 0);\n  ASSERT (strlen (nl_langinfo (MON_4)) > 0);\n  ASSERT (strlen (nl_langinfo (MON_5)) > 0);\n  ASSERT (strlen (nl_langinfo (MON_6)) > 0);\n  ASSERT (strlen (nl_langinfo (MON_7)) > 0);\n  ASSERT (strlen (nl_langinfo (MON_8)) > 0);\n  ASSERT (strlen (nl_langinfo (MON_9)) > 0);\n  ASSERT (strlen (nl_langinfo (MON_10)) > 0);\n  ASSERT (strlen (nl_langinfo (MON_11)) > 0);\n  ASSERT (strlen (nl_langinfo (MON_12)) > 0);\n  ASSERT (strlen (nl_langinfo (ABMON_1)) > 0);\n  ASSERT (strlen (nl_langinfo (ABMON_2)) > 0);\n  ASSERT (strlen (nl_langinfo (ABMON_3)) > 0);\n  ASSERT (strlen (nl_langinfo (ABMON_4)) > 0);\n  ASSERT (strlen (nl_langinfo (ABMON_5)) > 0);\n  ASSERT (strlen (nl_langinfo (ABMON_6)) > 0);\n  ASSERT (strlen (nl_langinfo (ABMON_7)) > 0);\n  ASSERT (strlen (nl_langinfo (ABMON_8)) > 0);\n  ASSERT (strlen (nl_langinfo (ABMON_9)) > 0);\n  ASSERT (strlen (nl_langinfo (ABMON_10)) > 0);\n  ASSERT (strlen (nl_langinfo (ABMON_11)) > 0);\n  ASSERT (strlen (nl_langinfo (ABMON_12)) > 0);\n  ASSERT (strlen (nl_langinfo (ERA)) >= 0);\n  ASSERT (strlen (nl_langinfo (ERA_D_FMT)) >= 0);\n  ASSERT (strlen (nl_langinfo (ERA_D_T_FMT)) >= 0);\n  ASSERT (strlen (nl_langinfo (ERA_T_FMT)) >= 0);\n  ASSERT (nl_langinfo (ALT_DIGITS) != NULL);\n  /* nl_langinfo items of the LC_MONETARY category */\n  {\n    const char *currency = nl_langinfo (CRNCYSTR);\n    ASSERT (strlen (currency) >= 0);\n#if !defined __NetBSD__\n    if (pass > 0)\n      ASSERT (strlen (currency) >= 1);\n#endif\n  }\n  /* nl_langinfo items of the LC_MESSAGES category */\n  ASSERT (strlen (nl_langinfo (YESEXPR)) > 0);\n  ASSERT (strlen (nl_langinfo (NOEXPR)) > 0);\n\n  return 0;\n}",
      "lines": 87,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-open.c": {
    "main": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "int\nmain (void)\n{\n  return test_open (open, true);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-open.h": {
    "test_open": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "static ALWAYS_INLINE int\ntest_open (int (*func) (char const *, int, ...), bool print)\n{\n  int fd;\n  /* Remove anything from prior partial run.  */\n  unlink (BASE \"file\");\n\n  /* Cannot create directory.  */\n  errno = 0;\n  ASSERT (func (\"nonexist.ent/\", O_CREAT | O_RDONLY, 0600) == -1);\n  ASSERT (errno == ENOTDIR || errno == EISDIR || errno == ENOENT\n          || errno == EINVAL);\n\n  /* Create a regular file.  */\n  fd = func (BASE \"file\", O_CREAT | O_RDONLY, 0600);\n  ASSERT (0 <= fd);\n  ASSERT (close (fd) == 0);\n\n  /* Trailing slash handling.  */\n  errno = 0;\n  ASSERT (func (BASE \"file/\", O_RDONLY) == -1);\n  ASSERT (errno == ENOTDIR || errno == EISDIR || errno == EINVAL);\n\n  /* Directories cannot be opened for writing.  */\n  errno = 0;\n  ASSERT (func (\".\", O_WRONLY) == -1);\n  ASSERT (errno == EISDIR || errno == EACCES);\n\n  /* /dev/null must exist, and be writable.  */\n  fd = func (\"/dev/null\", O_RDONLY);\n  ASSERT (0 <= fd);\n  {\n    char c;\n    ASSERT (read (fd, &c, 1) == 0);\n  }\n  ASSERT (close (fd) == 0);\n  fd = func (\"/dev/null\", O_WRONLY);\n  ASSERT (0 <= fd);\n  ASSERT (write (fd, \"c\", 1) == 1);\n  ASSERT (close (fd) == 0);\n\n  /* Although O_NONBLOCK on regular files can be ignored, it must not\n     cause a failure.  */\n  fd = func (BASE \"file\", O_NONBLOCK | O_RDONLY);\n  ASSERT (0 <= fd);\n  ASSERT (close (fd) == 0);\n\n  /* Symlink handling, where supported.  */\n  if (symlink (BASE \"file\", BASE \"link\") != 0)\n    {\n      ASSERT (unlink (BASE \"file\") == 0);\n      if (print)\n        fputs (\"skipping test: symlinks not supported on this file system\\n\",\n               stderr);\n      return 77;\n    }\n  errno = 0;\n  ASSERT (func (BASE \"link/\", O_RDONLY) == -1);\n  ASSERT (errno == ENOTDIR);\n  fd = func (BASE \"link\", O_RDONLY);\n  ASSERT (0 <= fd);\n  ASSERT (close (fd) == 0);\n\n  /* Cleanup.  */\n  ASSERT (unlink (BASE \"file\") == 0);\n  ASSERT (unlink (BASE \"link\") == 0);\n\n  return 0;\n}",
      "lines": 69,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "ALWAYS_INLINE",
        "int",
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-openat-safer.c": {
    "main": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        120,
        1
      ],
      "content": "int\nmain (void)\n{\n  int i;\n  int j;\n  int dfd;\n  int fd;\n  char buf[2];\n\n  /* We close fd 2 later, so save it in fd 10.  */\n  if (dup2 (STDERR_FILENO, BACKUP_STDERR_FILENO) != BACKUP_STDERR_FILENO\n      || (myerr = fdopen (BACKUP_STDERR_FILENO, \"w\")) == NULL)\n    return 2;\n\n  /* Create handle for future use.  */\n  dfd = openat (AT_FDCWD, \".\", O_RDONLY);\n  ASSERT (STDERR_FILENO < dfd);\n\n  /* Create file for later checks.  */\n  remove (witness);\n  fd = openat (dfd, witness, O_WRONLY | O_CREAT | O_EXCL, 0600);\n  ASSERT (STDERR_FILENO < fd);\n  ASSERT (write (fd, \"hi\", 2) == 2);\n  ASSERT (close (fd) == 0);\n\n  /* Four iterations, with progressively more standard descriptors\n     closed.  */\n  for (i = -1; i <= STDERR_FILENO; i++)\n    {\n      ASSERT (fchdir (dfd) == 0);\n      if (0 <= i)\n        ASSERT (close (i) == 0);\n\n      /* Execute once in \".\", once in \"..\".  */\n      for (j = 0; j <= 1; j++)\n        {\n          if (j)\n            ASSERT (chdir (\"..\") == 0);\n\n          /* Check for error detection.  */\n          errno = 0;\n          ASSERT (openat (AT_FDCWD, \"\", O_RDONLY) == -1);\n          ASSERT (errno == ENOENT);\n          errno = 0;\n          ASSERT (openat (dfd, \"\", O_RDONLY) == -1);\n          ASSERT (errno == ENOENT);\n          errno = 0;\n          ASSERT (openat (-1, \".\", O_RDONLY) == -1);\n          ASSERT (errno == EBADF);\n\n          /* Check for trailing slash and /dev/null handling.  */\n          errno = 0;\n          ASSERT (openat (dfd, \"nonexist.ent/\", O_CREAT | O_RDONLY,\n                          S_IRUSR | S_IWUSR) == -1);\n          ASSERT (errno == ENOTDIR || errno == EISDIR || errno == ENOENT\n                  || errno == EINVAL);\n          errno = 0;\n          ASSERT (openat (dfd, witness \"/\", O_RDONLY) == -1);\n          ASSERT (errno == ENOTDIR || errno == EISDIR || errno == EINVAL);\n          /* Using a bad directory is okay for absolute paths.  */\n          fd = openat (-1, \"/dev/null\", O_WRONLY);\n          ASSERT (STDERR_FILENO < fd);\n          /* Using a non-directory is wrong for relative paths.  */\n          errno = 0;\n          ASSERT (openat (fd, \".\", O_RDONLY) == -1);\n          ASSERT (errno == EBADF || errno == ENOTDIR);\n          ASSERT (close (fd) == 0);\n\n          /* Check for our witness file.  */\n          fd = openat (dfd, witness, O_RDONLY | O_NOFOLLOW);\n          ASSERT (STDERR_FILENO < fd);\n          ASSERT (read (fd, buf, 2) == 2);\n          ASSERT (buf[0] == 'h' && buf[1] == 'i');\n          ASSERT (close (fd) == 0);\n        }\n    }\n  ASSERT (fchdir (dfd) == 0);\n  ASSERT (unlink (witness) == 0);\n  ASSERT (close (dfd) == 0);\n\n  return 0;\n}",
      "lines": 82,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-openat.c": {
    "do_open": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "static int\ndo_open (char const *name, int flags, ...)\n{\n  if (flags & O_CREAT)\n    {\n      mode_t mode = 0;\n      va_list arg;\n      va_start (arg, flags);\n\n      /* We have to use PROMOTED_MODE_T instead of mode_t, otherwise GCC 4\n         creates crashing code when 'mode_t' is smaller than 'int'.  */\n      mode = va_arg (arg, PROMOTED_MODE_T);\n\n      va_end (arg);\n      return openat (dfd, name, flags, mode);\n    }\n  return openat (dfd, name, flags);\n}",
      "lines": 18,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        101,
        1
      ],
      "content": "int\nmain (int argc _GL_UNUSED, char *argv[])\n{\n  int result;\n\n  set_program_name (argv[0]);\n\n  /* Test behaviour for invalid file descriptors.  */\n  {\n    errno = 0;\n    ASSERT (openat (-1, \"foo\", O_RDONLY) == -1);\n    ASSERT (errno == EBADF);\n  }\n  {\n    close (99);\n    errno = 0;\n    ASSERT (openat (99, \"foo\", O_RDONLY) == -1);\n    ASSERT (errno == EBADF);\n  }\n\n  /* Basic checks.  */\n  result = test_open (do_open, false);\n  dfd = open (\".\", O_RDONLY);\n  ASSERT (0 <= dfd);\n  ASSERT (test_open (do_open, false) == result);\n  ASSERT (close (dfd) == 0);\n\n  /* Check that even when *-safer modules are in use, plain openat can\n     land in fd 0.  Do this test last, since it is destructive to\n     stdin.  */\n  ASSERT (close (STDIN_FILENO) == 0);\n  ASSERT (openat (AT_FDCWD, \".\", O_RDONLY) == STDIN_FILENO);\n  {\n    dfd = open (\".\", O_RDONLY);\n    ASSERT (STDIN_FILENO < dfd);\n    ASSERT (chdir (\"..\") == 0);\n    ASSERT (close (STDIN_FILENO) == 0);\n    ASSERT (openat (dfd, \".\", O_RDONLY) == STDIN_FILENO);\n    ASSERT (close (dfd) == 0);\n  }\n  return result;\n}",
      "lines": 42,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-parse-datetime.c": {
    "tm_diff": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        91,
        1
      ],
      "content": "static long int\ntm_diff (struct tm const *a, struct tm const *b)\n{\n  /* Compute intervening leap days correctly even if year is negative.\n     Take care to avoid int overflow in leap day calculations.  */\n  int a4 = SHR (a->tm_year, 2) + SHR (TM_YEAR_BASE, 2) - ! (a->tm_year & 3);\n  int b4 = SHR (b->tm_year, 2) + SHR (TM_YEAR_BASE, 2) - ! (b->tm_year & 3);\n  int a100 = a4 / 25 - (a4 % 25 < 0);\n  int b100 = b4 / 25 - (b4 % 25 < 0);\n  int a400 = SHR (a100, 2);\n  int b400 = SHR (b100, 2);\n  int intervening_leap_days = (a4 - b4) - (a100 - b100) + (a400 - b400);\n  long int ayear = a->tm_year;\n  long int years = ayear - b->tm_year;\n  long int days = (365 * years + intervening_leap_days\n                   + (a->tm_yday - b->tm_yday));\n  return (60 * (60 * (24 * days + (a->tm_hour - b->tm_hour))\n                + (a->tm_min - b->tm_min))\n          + (a->tm_sec - b->tm_sec));\n}",
      "lines": 20,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "long int",
        "long",
        "int"
      ]
    },
    "gmt_offset": {
      "start_point": [
        94,
        0
      ],
      "end_point": [
        109,
        1
      ],
      "content": "static long\ngmt_offset (time_t s)\n{\n  long gmtoff;\n\n#if !HAVE_TM_GMTOFF\n  struct tm tm_local = *localtime (&s);\n  struct tm tm_gmt   = *gmtime (&s);\n\n  gmtoff = tm_diff (&tm_local, &tm_gmt);\n#else\n  gmtoff = localtime (&s)->tm_gmtoff;\n#endif\n\n  return gmtoff;\n}",
      "lines": 16,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "long",
        "long"
      ]
    },
    "main": {
      "start_point": [
        111,
        0
      ],
      "end_point": [
        438,
        1
      ],
      "content": "int\nmain (int argc _GL_UNUSED, char **argv)\n{\n  struct timespec result;\n  struct timespec result2;\n  struct timespec expected;\n  struct timespec now;\n  const char *p;\n  int i;\n  long gmtoff;\n  time_t ref_time = 1304250918;\n\n  set_program_name (argv[0]);\n\n  /* Set the time zone to US Eastern time with the 2012 rules.  This\n     should disable any leap second support.  Otherwise, there will be\n     a problem with glibc on sites that default to leap seconds; see\n     <http://bugs.gnu.org/12206>.  */\n  setenv (\"TZ\", \"EST5EDT,M3.2.0,M11.1.0\", 1);\n\n  gmtoff = gmt_offset (ref_time);\n\n\n  /* ISO 8601 extended date and time of day representation,\n     'T' separator, local time zone */\n  p = \"2011-05-01T11:55:18\";\n  expected.tv_sec = ref_time - gmtoff;\n  expected.tv_nsec = 0;\n  ASSERT (parse_datetime (&result, p, 0));\n  LOG (p, expected, result);\n  ASSERT (expected.tv_sec == result.tv_sec\n          && expected.tv_nsec == result.tv_nsec);\n\n  /* ISO 8601 extended date and time of day representation,\n     ' ' separator, local time zone */\n  p = \"2011-05-01 11:55:18\";\n  expected.tv_sec = ref_time - gmtoff;\n  expected.tv_nsec = 0;\n  ASSERT (parse_datetime (&result, p, 0));\n  LOG (p, expected, result);\n  ASSERT (expected.tv_sec == result.tv_sec\n          && expected.tv_nsec == result.tv_nsec);\n\n\n  /* ISO 8601, extended date and time of day representation,\n     'T' separator, UTC */\n  p = \"2011-05-01T11:55:18Z\";\n  expected.tv_sec = ref_time;\n  expected.tv_nsec = 0;\n  ASSERT (parse_datetime (&result, p, 0));\n  LOG (p, expected, result);\n  ASSERT (expected.tv_sec == result.tv_sec\n          && expected.tv_nsec == result.tv_nsec);\n\n  /* ISO 8601, extended date and time of day representation,\n     ' ' separator, UTC */\n  p = \"2011-05-01 11:55:18Z\";\n  expected.tv_sec = ref_time;\n  expected.tv_nsec = 0;\n  ASSERT (parse_datetime (&result, p, 0));\n  LOG (p, expected, result);\n  ASSERT (expected.tv_sec == result.tv_sec\n          && expected.tv_nsec == result.tv_nsec);\n\n\n  /* ISO 8601 extended date and time of day representation,\n     'T' separator, w/UTC offset */\n  p = \"2011-05-01T11:55:18-07:00\";\n  expected.tv_sec = 1304276118;\n  expected.tv_nsec = 0;\n  ASSERT (parse_datetime (&result, p, 0));\n  LOG (p, expected, result);\n  ASSERT (expected.tv_sec == result.tv_sec\n          && expected.tv_nsec == result.tv_nsec);\n\n  /* ISO 8601 extended date and time of day representation,\n     ' ' separator, w/UTC offset */\n  p = \"2011-05-01 11:55:18-07:00\";\n  expected.tv_sec = 1304276118;\n  expected.tv_nsec = 0;\n  ASSERT (parse_datetime (&result, p, 0));\n  LOG (p, expected, result);\n  ASSERT (expected.tv_sec == result.tv_sec\n          && expected.tv_nsec == result.tv_nsec);\n\n\n  /* ISO 8601 extended date and time of day representation,\n     'T' separator, w/hour only UTC offset */\n  p = \"2011-05-01T11:55:18-07\";\n  expected.tv_sec = 1304276118;\n  expected.tv_nsec = 0;\n  ASSERT (parse_datetime (&result, p, 0));\n  LOG (p, expected, result);\n  ASSERT (expected.tv_sec == result.tv_sec\n          && expected.tv_nsec == result.tv_nsec);\n\n  /* ISO 8601 extended date and time of day representation,\n     ' ' separator, w/hour only UTC offset */\n  p = \"2011-05-01 11:55:18-07\";\n  expected.tv_sec = 1304276118;\n  expected.tv_nsec = 0;\n  ASSERT (parse_datetime (&result, p, 0));\n  LOG (p, expected, result);\n  ASSERT (expected.tv_sec == result.tv_sec\n          && expected.tv_nsec == result.tv_nsec);\n\n\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"now\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  ASSERT (now.tv_sec == result.tv_sec && now.tv_nsec == result.tv_nsec);\n\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"tomorrow\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  ASSERT (now.tv_sec + 24 * 60 * 60 == result.tv_sec\n          && now.tv_nsec == result.tv_nsec);\n\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"yesterday\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  ASSERT (now.tv_sec - 24 * 60 * 60 == result.tv_sec\n          && now.tv_nsec == result.tv_nsec);\n\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"4 hours\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  ASSERT (now.tv_sec + 4 * 60 * 60 == result.tv_sec\n          && now.tv_nsec == result.tv_nsec);\n\n  /* test if timezone is not being ignored for day offset */\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"UTC+400 +24 hours\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  p = \"UTC+400 +1 day\";\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n\n  /* test if several time zones formats are handled same way */\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"UTC+14:00\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  p = \"UTC+14\";\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n  p = \"UTC+1400\";\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"UTC-14:00\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  p = \"UTC-14\";\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n  p = \"UTC-1400\";\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"UTC+0:15\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  p = \"UTC+0015\";\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"UTC-1:30\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  p = \"UTC-130\";\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n\n\n  /* TZ out of range should cause parse_datetime failure */\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"UTC+25:00\";\n  ASSERT (!parse_datetime (&result, p, &now));\n\n        /* Check for several invalid countable dayshifts */\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"UTC+4:00 +40 yesterday\";\n  ASSERT (!parse_datetime (&result, p, &now));\n  p = \"UTC+4:00 next yesterday\";\n  ASSERT (!parse_datetime (&result, p, &now));\n  p = \"UTC+4:00 tomorrow ago\";\n  ASSERT (!parse_datetime (&result, p, &now));\n  p = \"UTC+4:00 tomorrow hence\";\n  ASSERT (!parse_datetime (&result, p, &now));\n  p = \"UTC+4:00 40 now ago\";\n  ASSERT (!parse_datetime (&result, p, &now));\n  p = \"UTC+4:00 last tomorrow\";\n  ASSERT (!parse_datetime (&result, p, &now));\n  p = \"UTC+4:00 -4 today\";\n  ASSERT (!parse_datetime (&result, p, &now));\n\n  /* And check correct usage of dayshifts */\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"UTC+400 tomorrow\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  p = \"UTC+400 +1 day\";\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n  p = \"UTC+400 1 day hence\";\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"UTC+400 yesterday\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  p = \"UTC+400 1 day ago\";\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n  now.tv_sec = 4711;\n  now.tv_nsec = 1267;\n  p = \"UTC+400 now\";\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  p = \"UTC+400 +0 minutes\"; /* silly, but simple \"UTC+400\" is different*/\n  ASSERT (parse_datetime (&result2, p, &now));\n  LOG (p, now, result2);\n  ASSERT (result.tv_sec == result2.tv_sec\n          && result.tv_nsec == result2.tv_nsec);\n\n  /* Check that some \"next Monday\", \"last Wednesday\", etc. are correct.  */\n  setenv (\"TZ\", \"UTC0\", 1);\n  for (i = 0; day_table[i]; i++)\n    {\n      unsigned int thur2 = 7 * 24 * 3600; /* 2nd thursday */\n      char tmp[32];\n      sprintf (tmp, \"NEXT %s\", day_table[i]);\n      now.tv_sec = thur2 + 4711;\n      now.tv_nsec = 1267;\n      ASSERT (parse_datetime (&result, tmp, &now));\n      LOG (tmp, now, result);\n      ASSERT (result.tv_nsec == 0);\n      ASSERT (result.tv_sec == thur2 + (i == 4 ? 7 : (i + 3) % 7) * 24 * 3600);\n\n      sprintf (tmp, \"LAST %s\", day_table[i]);\n      now.tv_sec = thur2 + 4711;\n      now.tv_nsec = 1267;\n      ASSERT (parse_datetime (&result, tmp, &now));\n      LOG (tmp, now, result);\n      ASSERT (result.tv_nsec == 0);\n      ASSERT (result.tv_sec == thur2 + ((i + 3) % 7 - 7) * 24 * 3600);\n    }\n\n  p = \"THURSDAY UTC+00\";  /* The epoch was on Thursday.  */\n  now.tv_sec = 0;\n  now.tv_nsec = 0;\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  ASSERT (result.tv_sec == now.tv_sec\n          && result.tv_nsec == now.tv_nsec);\n\n  p = \"FRIDAY UTC+00\";\n  now.tv_sec = 0;\n  now.tv_nsec = 0;\n  ASSERT (parse_datetime (&result, p, &now));\n  LOG (p, now, result);\n  ASSERT (result.tv_sec == 24 * 3600\n          && result.tv_nsec == now.tv_nsec);\n\n  /* Exercise a sign-extension bug.  Before July 2012, an input\n     starting with a high-bit-set byte would be treated like \"0\".  */\n  ASSERT ( ! parse_datetime (&result, \"\\xb0\", &now));\n\n  /* Exercise TZ=\"\" parsing code.  */\n  /* These two would infloop or segfault before Feb 2014.  */\n  ASSERT ( ! parse_datetime (&result, \"TZ=\\\"\\\"\\\"\", &now));\n  ASSERT ( ! parse_datetime (&result, \"TZ=\\\"\\\" \\\"\", &now));\n  /* Exercise invalid patterns.  */\n  ASSERT ( ! parse_datetime (&result, \"TZ=\\\"\", &now));\n  ASSERT ( ! parse_datetime (&result, \"TZ=\\\"\\\\\\\"\", &now));\n  ASSERT ( ! parse_datetime (&result, \"TZ=\\\"\\\\n\", &now));\n  ASSERT ( ! parse_datetime (&result, \"TZ=\\\"\\\\n\\\"\", &now));\n  /* Exercise valid patterns.  */\n  ASSERT (   parse_datetime (&result, \"TZ=\\\"\\\"\", &now));\n  ASSERT (   parse_datetime (&result, \"TZ=\\\"\\\" \", &now));\n  ASSERT (   parse_datetime (&result, \" TZ=\\\"\\\"\", &now));\n  ASSERT (   parse_datetime (&result, \"TZ=\\\"\\\\\\\\\\\"\", &now));\n  ASSERT (   parse_datetime (&result, \"TZ=\\\"\\\\\\\"\\\"\", &now));\n\n  return 0;\n}",
      "lines": 328,
      "depth": 17,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-pathmax.c": {
    "main": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        31,
        1
      ],
      "content": "int\nmain (void)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-perror.c": {
    "main": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        35,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  const char *prefix = (argc > 1 ? argv[1] : NULL);\n\n  errno = EACCES;    perror (prefix);\n  errno = ETIMEDOUT; perror (prefix);\n  errno = EOVERFLOW; perror (prefix);\n\n  return 0;\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-perror2.c": {
    "main": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "int\nmain (void)\n{\n  /* We change fd 2 later, so save it in fd 10.  */\n  if (dup2 (STDERR_FILENO, BACKUP_STDERR_FILENO) != BACKUP_STDERR_FILENO\n      || (myerr = fdopen (BACKUP_STDERR_FILENO, \"w\")) == NULL)\n    return 2;\n\n  ASSERT (freopen (BASE \".tmp\", \"w+\", stderr) == stderr);\n\n  /* Test that perror does not clobber strerror buffer.  */\n  {\n    const char *msg1;\n    const char *msg2;\n    const char *msg3;\n    const char *msg4;\n    char *str1;\n    char *str2;\n    char *str3;\n    char *str4;\n\n    msg1 = strerror (ENOENT);\n    ASSERT (msg1);\n    str1 = strdup (msg1);\n    ASSERT (str1);\n\n    msg2 = strerror (ERANGE);\n    ASSERT (msg2);\n    str2 = strdup (msg2);\n    ASSERT (str2);\n\n    msg3 = strerror (-4);\n    ASSERT (msg3);\n    str3 = strdup (msg3);\n    ASSERT (str3);\n\n    msg4 = strerror (1729576);\n    ASSERT (msg4);\n    str4 = strdup (msg4);\n    ASSERT (str4);\n\n    errno = EACCES;\n    perror (\"\");\n    errno = -5;\n    perror (\"\");\n    ASSERT (!ferror (stderr));\n    ASSERT (msg1 == msg2 || msg1 == msg4 || STREQ (msg1, str1));\n    ASSERT (msg2 == msg4 || STREQ (msg2, str2));\n    ASSERT (msg3 == msg4 || STREQ (msg3, str3));\n    ASSERT (STREQ (msg4, str4));\n\n    free (str1);\n    free (str2);\n    free (str3);\n    free (str4);\n  }\n\n  /* Test that perror uses the same message as strerror.  */\n  {\n    int errs[] = { EACCES, 0, -3, };\n    int i;\n    for (i = 0; i < SIZEOF (errs); i++)\n      {\n        char buf[256];\n        char *err = strerror (errs[i]);\n\n        ASSERT (err);\n        ASSERT (strlen (err) < sizeof buf);\n        rewind (stderr);\n        ASSERT (ftruncate (fileno (stderr), 0) == 0);\n        errno = errs[i];\n        perror (NULL);\n        ASSERT (!ferror (stderr));\n        rewind (stderr);\n        ASSERT (fgets (buf, sizeof buf, stderr) == buf);\n        ASSERT (strstr (buf, err));\n      }\n  }\n\n  /* Test that perror reports write failure.  */\n  {\n    ASSERT (freopen (BASE \".tmp\", \"r\", stderr) == stderr);\n    ASSERT (setvbuf (stderr, NULL, _IONBF, BUFSIZ) == 0);\n    errno = -1;\n    ASSERT (!ferror (stderr));\n    perror (NULL);\n#if 0\n    /* Commented out until cygwin behaves:\n       http://sourceware.org/ml/newlib/2011/msg00228.html */\n    ASSERT (errno > 0);\n    /* Commented out until glibc behaves:\n       http://sourceware.org/bugzilla/show_bug.cgi?id=12792 */\n    ASSERT (ferror (stderr));\n#endif\n  }\n\n  ASSERT (fclose (stderr) == 0);\n  ASSERT (remove (BASE \".tmp\") == 0);\n\n  return 0;\n}",
      "lines": 101,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-pipe.c": {
    "is_open": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "static bool\nis_open (int fd)\n{\n#if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n  /* On native Windows, the initial state of unassigned standard file\n     descriptors is that they are open but point to an\n     INVALID_HANDLE_VALUE, and there is no fcntl.  */\n  return (HANDLE) _get_osfhandle (fd) != INVALID_HANDLE_VALUE;\n#else\n# ifndef F_GETFL\n#  error Please port fcntl to your platform\n# endif\n  return 0 <= fcntl (fd, F_GETFL);\n#endif\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "is_cloexec": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "static bool\nis_cloexec (int fd)\n{\n#if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n  HANDLE h = (HANDLE) _get_osfhandle (fd);\n  DWORD flags;\n  ASSERT (GetHandleInformation (h, &flags));\n  return (flags & HANDLE_FLAG_INHERIT) == 0;\n#else\n  int flags;\n  ASSERT ((flags = fcntl (fd, F_GETFD)) >= 0);\n  return (flags & FD_CLOEXEC) != 0;\n#endif\n}",
      "lines": 14,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "is_nonblocking": {
      "start_point": [
        71,
        0
      ],
      "end_point": [
        82,
        1
      ],
      "content": "static bool\nis_nonblocking (int fd)\n{\n#if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n  /* We don't use the non-blocking mode for sockets here.  */\n  return 0;\n#else\n  int flags;\n  ASSERT ((flags = fcntl (fd, F_GETFL)) >= 0);\n  return (flags & O_NONBLOCK) != 0;\n#endif\n}",
      "lines": 12,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "main": {
      "start_point": [
        84,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "int\nmain ()\n{\n  int fd[2];\n\n  fd[0] = -1;\n  fd[1] = -1;\n  ASSERT (pipe (fd) >= 0);\n  ASSERT (fd[0] >= 0);\n  ASSERT (fd[1] >= 0);\n  ASSERT (fd[0] != fd[1]);\n  ASSERT (is_open (fd[0]));\n  ASSERT (is_open (fd[1]));\n  ASSERT (!is_cloexec (fd[0]));\n  ASSERT (!is_cloexec (fd[1]));\n  ASSERT (!is_nonblocking (fd[0]));\n  ASSERT (!is_nonblocking (fd[1]));\n\n  return 0;\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-priv-set.c": {
    "main": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        87,
        1
      ],
      "content": "int\nmain (void)\n{\n#if HAVE_GETPPRIV && HAVE_PRIV_H\n    priv_set_t *set;\n\n    ASSERT (set = priv_allocset ());\n    ASSERT (getppriv (PRIV_EFFECTIVE, set) == 0);\n    ASSERT (priv_ismember (set, PRIV_PROC_EXEC) == 1);\n\n    /* Do a series of removes and restores making sure that the results are\n       consistent with our ismember function and solaris' priv_ismember.  */\n    ASSERT (priv_set_ismember (PRIV_PROC_EXEC) == 1);\n        ASSERT (getppriv (PRIV_EFFECTIVE, set) == 0);\n        ASSERT (priv_ismember (set, PRIV_PROC_EXEC) == 1);\n    ASSERT (priv_set_restore (PRIV_PROC_EXEC) == -1);\n        ASSERT (errno == EINVAL);\n    ASSERT (priv_set_ismember (PRIV_PROC_EXEC) == 1);\n        ASSERT (getppriv (PRIV_EFFECTIVE, set) == 0);\n        ASSERT (priv_ismember (set, PRIV_PROC_EXEC) == 1);\n    ASSERT (priv_set_remove (PRIV_PROC_EXEC) == 0);\n    ASSERT (priv_set_ismember (PRIV_PROC_EXEC) == 0);\n        ASSERT (getppriv (PRIV_EFFECTIVE, set) == 0);\n        ASSERT (priv_ismember (set, PRIV_PROC_EXEC) == 0);\n    ASSERT (priv_set_remove (PRIV_PROC_EXEC) == -1);\n        ASSERT (errno == EINVAL);\n    ASSERT (priv_set_ismember (PRIV_PROC_EXEC) == 0);\n        ASSERT (getppriv (PRIV_EFFECTIVE, set) == 0);\n        ASSERT (priv_ismember (set, PRIV_PROC_EXEC) == 0);\n    ASSERT (priv_set_restore (PRIV_PROC_EXEC) == 0);\n    ASSERT (priv_set_ismember (PRIV_PROC_EXEC) == 1);\n        ASSERT (getppriv (PRIV_EFFECTIVE, set) == 0);\n        ASSERT (priv_ismember (set, PRIV_PROC_EXEC) == 1);\n    ASSERT (priv_set_restore (PRIV_PROC_EXEC) == -1);\n        ASSERT (errno == EINVAL);\n    ASSERT (priv_set_ismember (PRIV_PROC_EXEC) == 1);\n        ASSERT (getppriv (PRIV_EFFECTIVE, set) == 0);\n        ASSERT (priv_ismember (set, PRIV_PROC_EXEC) == 1);\n\n    /* Test the priv_set_linkdir wrappers.  */\n    ASSERT (getppriv (PRIV_EFFECTIVE, set) == 0);\n    if (priv_ismember (set, PRIV_SYS_LINKDIR))\n      {\n        ASSERT (priv_set_restore_linkdir () == -1);\n            ASSERT (errno == EINVAL);\n        ASSERT (priv_set_remove_linkdir () == 0);\n        ASSERT (priv_set_remove_linkdir () == -1);\n            ASSERT (errno == EINVAL);\n        ASSERT (priv_set_restore_linkdir () == 0);\n      }\n#else\n    ASSERT (priv_set_restore_linkdir () == -1);\n    ASSERT (priv_set_remove_linkdir () == -1);\n#endif\n\n    return 0;\n}",
      "lines": 57,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-quotearg-simple.c": {
    "main": {
      "start_point": [
        247,
        0
      ],
      "end_point": [
        358,
        1
      ],
      "content": "int\nmain (int argc _GL_UNUSED, char *argv[])\n{\n  int i;\n  bool ascii_only = MB_CUR_MAX == 1 && !isprint ((unsigned char) LQ[0]);\n\n  set_program_name (argv[0]);\n\n  /* This part of the program is hard-wired to the C locale since it\n     does not call setlocale.  However, according to POSIX, the use of\n     8-bit bytes in a character context in the C locale gives\n     unspecified results (that is, the C locale charset is allowed to\n     be unibyte with 8-bit bytes rejected [ASCII], unibyte with 8-bit\n     bytes being characters [often ISO-8859-1], or multibyte [often\n     UTF-8]).  We assume that the latter two cases will be\n     indistinguishable in this test - that is, the LQ and RQ sequences\n     will pass through unchanged in either type of charset.  So when\n     testing for quoting of str7, use the ascii_only flag to decide\n     what to expect for the 8-bit data being quoted.  */\n  ASSERT (!isprint ('\\033'));\n  for (i = literal_quoting_style; i <= clocale_quoting_style; i++)\n    {\n      set_quoting_style (NULL, (enum quoting_style) i);\n      if (!(i == locale_quoting_style || i == clocale_quoting_style)\n          || (strcmp (locale_charset (), \"ASCII\") == 0\n              || strcmp (locale_charset (), \"ANSI_X3.4-1968\") == 0))\n        {\n          compare_strings (use_quotearg_buffer, &results_g[i].group1,\n                           ascii_only);\n          compare_strings (use_quotearg, &results_g[i].group2,\n                           ascii_only);\n          if (i == c_quoting_style)\n            compare_strings (use_quote_double_quotes, &results_g[i].group2,\n                             ascii_only);\n          compare_strings (use_quotearg_colon, &results_g[i].group3,\n                           ascii_only);\n        }\n    }\n\n  set_quoting_style (NULL, literal_quoting_style);\n  ASSERT (set_quoting_flags (NULL, QA_ELIDE_NULL_BYTES) == 0);\n  compare_strings (use_quotearg_buffer, &flag_results[0].group1, ascii_only);\n  compare_strings (use_quotearg, &flag_results[0].group2, ascii_only);\n  compare_strings (use_quotearg_colon, &flag_results[0].group3, ascii_only);\n\n  set_quoting_style (NULL, c_quoting_style);\n  ASSERT (set_quoting_flags (NULL, QA_ELIDE_OUTER_QUOTES)\n          == QA_ELIDE_NULL_BYTES);\n  compare_strings (use_quotearg_buffer, &flag_results[1].group1, ascii_only);\n  compare_strings (use_quotearg, &flag_results[1].group2, ascii_only);\n  compare_strings (use_quote_double_quotes, &flag_results[1].group2,\n                   ascii_only);\n  compare_strings (use_quotearg_colon, &flag_results[1].group3, ascii_only);\n\n  ASSERT (set_quoting_flags (NULL, QA_SPLIT_TRIGRAPHS)\n          == QA_ELIDE_OUTER_QUOTES);\n  compare_strings (use_quotearg_buffer, &flag_results[2].group1, ascii_only);\n  compare_strings (use_quotearg, &flag_results[2].group2, ascii_only);\n  compare_strings (use_quote_double_quotes, &flag_results[2].group2,\n                   ascii_only);\n  compare_strings (use_quotearg_colon, &flag_results[2].group3, ascii_only);\n\n  ASSERT (set_quoting_flags (NULL, 0) == QA_SPLIT_TRIGRAPHS);\n\n  for (i = 0; i < sizeof custom_quotes / sizeof *custom_quotes; ++i)\n    {\n      set_custom_quoting (NULL,\n                          custom_quotes[i][0], custom_quotes[i][1]);\n      compare_strings (use_quotearg_buffer, &custom_results[i].group1,\n                       ascii_only);\n      compare_strings (use_quotearg, &custom_results[i].group2, ascii_only);\n      compare_strings (use_quotearg_colon, &custom_results[i].group3,\n                       ascii_only);\n    }\n\n  {\n    /* Trigger the bug whereby quotearg_buffer would read beyond the NUL\n       that defines the end of the string being quoted.  Use an input\n       string whose NUL is the last byte before an unreadable page.  */\n    char *z = zerosize_ptr ();\n\n    if (z)\n      {\n        size_t q_len = 1024;\n        char *q = malloc (q_len + 1);\n        char buf[10];\n        memset (q, 'Q', q_len);\n        q[q_len] = 0;\n\n        /* Z points to the boundary between a readable/writable page\n           and one that is neither readable nor writable.  Position\n           our string so its NUL is at the end of the writable one.  */\n        char const *str = \"____\";\n        size_t s_len = strlen (str);\n        z -= s_len + 1;\n        memcpy (z, str, s_len + 1);\n\n        set_custom_quoting (NULL, q, q);\n        /* Whether this actually triggers a SEGV depends on the\n           implementation of memcmp: whether it compares only byte-at-\n           a-time, and from left to right (no SEGV) or some other way.  */\n        size_t n = quotearg_buffer (buf, sizeof buf, z, SIZE_MAX, NULL);\n        ASSERT (n == s_len + 2 * q_len);\n        ASSERT (memcmp (buf, q, sizeof buf) == 0);\n        free (q);\n      }\n  }\n\n  quotearg_free ();\n\n  return 0;\n}",
      "lines": 112,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-quotearg.h": {
    "compare": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "static void\ncompare (char const *a, size_t la, char const *b, size_t lb)\n{\n  ASSERT (la == lb);\n  ASSERT (memcmp (a, b, la) == 0);\n  ASSERT (b[lb] == '\\0');\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "compare_strings": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "static void\ncompare_strings (char *(func) (char const *, size_t *),\n                 struct result_strings *results, bool ascii_only)\n{\n  size_t len;\n  char *p;\n\n  len = 0;\n  p = func (inputs.str1, &len);\n  compare (results->str1, strlen (results->str1), p, len);\n\n  len = inputs.len2;\n  p = func (inputs.str2, &len);\n  compare (results->str2, results->len2, p, len);\n\n  len = SIZE_MAX;\n  p = func (inputs.str3, &len);\n  compare (results->str3, strlen (results->str3), p, len);\n\n  len = strlen (inputs.str4);\n  p = func (inputs.str4, &len);\n  compare (results->str4, strlen (results->str4), p, len);\n\n  len = SIZE_MAX;\n  p = func (inputs.str5, &len);\n  compare (results->str5, strlen (results->str5), p, len);\n\n  len = strlen (inputs.str6);\n  p = func (inputs.str6, &len);\n  compare (results->str6, strlen (results->str6), p, len);\n\n  len = strlen (inputs.str7a);\n  p = func (inputs.str7a, &len);\n  if (ascii_only)\n    compare (results->str7a, strlen (results->str7a), p, len);\n  else\n    compare (results->str7b, strlen (results->str7b), p, len);\n}",
      "lines": 38,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "use_quotearg_buffer": {
      "start_point": [
        95,
        0
      ],
      "end_point": [
        105,
        1
      ],
      "content": "static char *\nuse_quotearg_buffer (const char *str, size_t *len)\n{\n  static char buf[100];\n  size_t size;\n  memset (buf, 0xa5, 100);\n  size = quotearg_buffer (buf, 100, str, *len, NULL);\n  *len = size;\n  ASSERT ((unsigned char) buf[size + 1] == 0xa5);\n  return buf;\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nuse_quotearg_buffer (const char *str, size_t *len)",
        "*"
      ]
    },
    "use_quotearg": {
      "start_point": [
        107,
        0
      ],
      "end_point": [
        113,
        1
      ],
      "content": "static char *\nuse_quotearg (const char *str, size_t *len)\n{\n  char *p = *len == SIZE_MAX ? quotearg (str) : quotearg_mem (str, *len);\n  *len = strlen (p);\n  return p;\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nuse_quotearg (const char *str, size_t *len)",
        "*"
      ]
    },
    "use_quote_double_quotes": {
      "start_point": [
        115,
        0
      ],
      "end_point": [
        122,
        1
      ],
      "content": "static char *\nuse_quote_double_quotes (const char *str, size_t *len)\n{\n  char *p = *len == SIZE_MAX ? quotearg_char (str, '\"')\n                               : quotearg_char_mem (str, *len, '\"');\n  *len = strlen (p);\n  return p;\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nuse_quote_double_quotes (const char *str, size_t *len)",
        "*"
      ]
    },
    "use_quotearg_colon": {
      "start_point": [
        124,
        0
      ],
      "end_point": [
        131,
        1
      ],
      "content": "static char *\nuse_quotearg_colon (const char *str, size_t *len)\n{\n  char *p = (*len == SIZE_MAX ? quotearg_colon (str)\n             : quotearg_colon_mem (str, *len));\n  *len = strlen (p);\n  return p;\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nuse_quotearg_colon (const char *str, size_t *len)",
        "*"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-raise.c": {
    "handler": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        34,
        1
      ],
      "content": "static _Noreturn void\nhandler (int sig)\n{\n  exit (0);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "_Noreturn",
        "void",
        "void"
      ]
    },
    "main": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "int\nmain (void)\n{\n  /* Test behaviour for invalid argument.  */\n  ASSERT (raise (-1) != 0);\n\n  /* Test behaviour for SIGINT.  */\n  ASSERT (signal (SIGINT, handler) != SIG_ERR);\n\n  raise (SIGINT);\n\n  /* We should not get here, because the handler takes away the control.  */\n  exit (1);\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-read.c": {
    "main": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "int\nmain (void)\n{\n  const char *filename = \"test-read.tmp\";\n  int fd;\n\n  /* Create a file with a simple contents.  */\n  fd = open (filename, O_CREAT | O_WRONLY, 0600);\n  ASSERT (fd >= 0);\n  ASSERT (write (fd, \"Hello World\", 11) == 11);\n  ASSERT (close (fd) == 0);\n\n  /* Read from the middle of the file.  */\n  fd = open (filename, O_RDONLY);\n  ASSERT (fd >= 0);\n  ASSERT (lseek (fd, 6, SEEK_SET) == 6);\n  {\n    char buf[10];\n    ssize_t ret = read (fd, buf, 10);\n    ASSERT (ret == 5);\n    ASSERT (memcmp (buf, \"World\", 5) == 0);\n  }\n  ASSERT (close (fd) == 0);\n\n  /* Test behaviour for invalid file descriptors.  */\n  {\n    char byte;\n    errno = 0;\n    ASSERT (read (-1, &byte, 1) == -1);\n    ASSERT (errno == EBADF);\n  }\n  {\n    char byte;\n    close (99);\n    errno = 0;\n    ASSERT (read (99, &byte, 1) == -1);\n    ASSERT (errno == EBADF);\n  }\n\n  /* Clean up.  */\n  unlink (filename);\n\n  return 0;\n}",
      "lines": 44,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-readlink.c": {
    "main": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "int\nmain (void)\n{\n  /* Remove any leftovers from a previous partial run.  */\n  ignore_value (system (\"rm -rf \" BASE \"*\"));\n\n  return test_readlink (readlink, true);\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-readlink.h": {
    "test_readlink": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        118,
        1
      ],
      "content": "static int\ntest_readlink (ssize_t (*func) (char const *, char *, size_t), bool print)\n{\n  char buf[80];\n\n  /* Sanity checks of failures.  Mingw lacks symlink, but readlink can\n     still distinguish between various errors.  */\n  memset (buf, 0xff, sizeof buf);\n  errno = 0;\n  ASSERT (func (\"no_such\", buf, sizeof buf) == -1);\n  ASSERT (errno == ENOENT);\n  errno = 0;\n  ASSERT (func (\"no_such/\", buf, sizeof buf) == -1);\n  ASSERT (errno == ENOENT);\n  errno = 0;\n  ASSERT (func (\"\", buf, sizeof buf) == -1);\n  ASSERT (errno == ENOENT || errno == EINVAL);\n  errno = 0;\n  ASSERT (func (\".\", buf, sizeof buf) == -1);\n  ASSERT (errno == EINVAL);\n  errno = 0;\n  ASSERT (func (\"./\", buf, sizeof buf) == -1);\n  ASSERT (errno == EINVAL);\n  ASSERT (close (creat (BASE \"file\", 0600)) == 0);\n  errno = 0;\n  ASSERT (func (BASE \"file\", buf, sizeof buf) == -1);\n  ASSERT (errno == EINVAL);\n  errno = 0;\n  ASSERT (func (BASE \"file/\", buf, sizeof buf) == -1);\n  ASSERT (errno == ENOTDIR || errno == EINVAL); /* AIX yields EINVAL */\n\n  /* Now test actual symlinks.  */\n  if (symlink (BASE \"dir\", BASE \"link\"))\n    {\n      ASSERT (unlink (BASE \"file\") == 0);\n      if (print)\n        fputs (\"skipping test: symlinks not supported on this file system\\n\",\n               stderr);\n      return 77;\n    }\n  ASSERT (mkdir (BASE \"dir\", 0700) == 0);\n  errno = 0;\n  ASSERT (func (BASE \"link/\", buf, sizeof buf) == -1);\n  ASSERT (errno == EINVAL);\n  ASSERT (symlink (BASE \"link\", BASE \"link2\") == 0);\n  errno = 0;\n  ASSERT (func (BASE \"link2/\", buf, sizeof buf) == -1);\n  ASSERT (errno == EINVAL);\n  ASSERT (unlink (BASE \"link2\") == 0);\n  ASSERT (symlink (BASE \"file\", BASE \"link2\") == 0);\n  errno = 0;\n  ASSERT (func (BASE \"link2/\", buf, sizeof buf) == -1);\n  ASSERT (errno == ENOTDIR || errno == EINVAL); /* AIX yields EINVAL */\n  ASSERT (unlink (BASE \"file\") == 0);\n  ASSERT (unlink (BASE \"link2\") == 0);\n  {\n    /* Up till now, no readlink has been successful, so buf should be\n       unchanged.  */\n    int i;\n    for (i = 0; i < sizeof buf; i++)\n      ASSERT (buf[i] == (char) 0xff);\n  }\n  {\n    size_t len = strlen (BASE \"dir\");\n    /* When passing too small of a buffer, expect the truncated\n       length, or an ERANGE failure.  However, a size of 0 is not\n       portable enough to test.  */\n    ssize_t result;\n    errno = 0;\n    result = readlink (BASE \"link\", buf, 1);\n    if (result == -1)\n      {\n        ASSERT (errno == ERANGE);\n        ASSERT (buf[0] == (char) 0xff);\n      }\n    else\n      {\n        ASSERT (result == 1);\n        ASSERT (buf[0] == BASE[0]);\n      }\n    ASSERT (buf[1] == (char) 0xff);\n    ASSERT (func (BASE \"link\", buf, len) == len);\n    ASSERT (strncmp (buf, BASE \"dir\", len) == 0);\n    ASSERT (buf[len] == (char) 0xff);\n    ASSERT (func (BASE \"link\", buf, sizeof buf) == len);\n    ASSERT (strncmp (buf, BASE \"dir\", len) == 0);\n    /* POSIX says rest of buf is unspecified; but in practice, it is\n       either left alone, or NUL-terminated.  */\n    ASSERT (buf[len] == '\\0' || buf[len] == (char) 0xff);\n  }\n  ASSERT (rmdir (BASE \"dir\") == 0);\n  ASSERT (unlink (BASE \"link\") == 0);\n\n  return 0;\n}",
      "lines": 95,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-readlinkat.c": {
    "do_readlink": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "static ssize_t\ndo_readlink (char const *name, char *buf, size_t len)\n{\n  return readlinkat (dfd, name, buf, len);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "ssize_t"
      ]
    },
    "main": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        120,
        1
      ],
      "content": "int\nmain (void)\n{\n  char buf[80];\n  int result;\n\n  /* Remove any leftovers from a previous partial run.  */\n  ignore_value (system (\"rm -rf \" BASE \"*\"));\n\n  /* Test behaviour for invalid file descriptors.  */\n  {\n    errno = 0;\n    ASSERT (readlinkat (-1, \"foo\", buf, sizeof buf) == -1);\n    ASSERT (errno == EBADF);\n  }\n  {\n    close (99);\n    errno = 0;\n    ASSERT (readlinkat (99, \"foo\", buf, sizeof buf) == -1);\n    ASSERT (errno == EBADF);\n  }\n\n  /* Perform same checks as counterpart functions.  */\n  result = test_readlink (do_readlink, false);\n  dfd = openat (AT_FDCWD, \".\", O_RDONLY);\n  ASSERT (0 <= dfd);\n  ASSERT (test_readlink (do_readlink, false) == result);\n\n  /* Now perform some cross-directory checks.  Skip everything else on\n     mingw.  */\n  if (HAVE_SYMLINK)\n    {\n      const char *contents = \"don't matter!\";\n      ssize_t exp = strlen (contents);\n\n      /* Create link while cwd is '.', then read it in '..'.  */\n      ASSERT (symlinkat (contents, AT_FDCWD, BASE \"link\") == 0);\n      errno = 0;\n      ASSERT (symlinkat (contents, dfd, BASE \"link\") == -1);\n      ASSERT (errno == EEXIST);\n      ASSERT (chdir (\"..\") == 0);\n      errno = 0;\n      ASSERT (readlinkat (AT_FDCWD, BASE \"link\", buf, sizeof buf) == -1);\n      ASSERT (errno == ENOENT);\n      ASSERT (readlinkat (dfd, BASE \"link\", buf, sizeof buf) == exp);\n      ASSERT (strncmp (contents, buf, exp) == 0);\n      ASSERT (unlinkat (dfd, BASE \"link\", 0) == 0);\n\n      /* Create link while cwd is '..', then read it in '.'.  */\n      ASSERT (symlinkat (contents, dfd, BASE \"link\") == 0);\n      ASSERT (fchdir (dfd) == 0);\n      errno = 0;\n      ASSERT (symlinkat (contents, AT_FDCWD, BASE \"link\") == -1);\n      ASSERT (errno == EEXIST);\n      buf[0] = '\\0';\n      ASSERT (readlinkat (AT_FDCWD, BASE \"link\", buf, sizeof buf) == exp);\n      ASSERT (strncmp (contents, buf, exp) == 0);\n      buf[0] = '\\0';\n      ASSERT (readlinkat (dfd, BASE \"link\", buf, sizeof buf) == exp);\n      ASSERT (strncmp (contents, buf, exp) == 0);\n      ASSERT (unlink (BASE \"link\") == 0);\n    }\n\n  ASSERT (close (dfd) == 0);\n  if (result == 77)\n    fputs (\"skipping test: symlinks not supported on this file system\\n\",\n           stderr);\n  return result;\n}",
      "lines": 69,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-realloc-gnu.c": {
    "main": {
      "start_point": [
        20,
        0
      ],
      "end_point": [
        28,
        1
      ],
      "content": "int\nmain ()\n{\n  /* Check that realloc (NULL, 0) is not a NULL pointer.  */\n  if (realloc (NULL, 0) == NULL)\n    return 1;\n\n  return 0;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-regex.c": {
    "main": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        202,
        1
      ],
      "content": "int\nmain (void)\n{\n  int result = 0;\n  static struct re_pattern_buffer regex;\n  unsigned char folded_chars[UCHAR_MAX + 1];\n  int i;\n  const char *s;\n  struct re_registers regs;\n\n#if HAVE_DECL_ALARM\n  /* Some builds of glibc go into an infinite loop on this test.  */\n  int alarm_value = 2;\n  signal (SIGALRM, SIG_DFL);\n  alarm (alarm_value);\n#endif\n  if (setlocale (LC_ALL, \"en_US.UTF-8\"))\n    {\n      {\n        /* http://sourceware.org/ml/libc-hacker/2006-09/msg00008.html\n           This test needs valgrind to catch the bug on Debian\n           GNU/Linux 3.1 x86, but it might catch the bug better\n           on other platforms and it shouldn't hurt to try the\n           test here.  */\n        static char const pat[] = \"insert into\";\n        static char const data[] =\n          \"\\xFF\\0\\x12\\xA2\\xAA\\xC4\\xB1,K\\x12\\xC4\\xB1*\\xACK\";\n        re_set_syntax (RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE\n                       | RE_ICASE);\n        memset (&regex, 0, sizeof regex);\n        s = re_compile_pattern (pat, sizeof pat - 1, &regex);\n        if (s)\n          result |= 1;\n        else if (re_search (&regex, data, sizeof data - 1,\n                            0, sizeof data - 1, &regs)\n                 != -1)\n          result |= 1;\n      }\n\n      /* Check whether it's really a UTF-8 locale.\n         On mingw, the setlocale call succeeds but returns\n         \"English_United States.1252\", with locale_charset() returning\n         \"CP1252\".  */\n      if (strcmp (locale_charset (), \"UTF-8\") == 0)\n        {\n          /* This test is from glibc bug 15078.\n             The test case is from Andreas Schwab in\n             <http://www.sourceware.org/ml/libc-alpha/2013-01/msg00967.html>.\n          */\n          static char const pat[] = \"[^x]x\";\n          static char const data[] =\n            /* <U1000><U103B><U103D><U1014><U103A><U102F><U1015><U103A> */\n            \"\\xe1\\x80\\x80\"\n            \"\\xe1\\x80\\xbb\"\n            \"\\xe1\\x80\\xbd\"\n            \"\\xe1\\x80\\x94\"\n            \"\\xe1\\x80\\xba\"\n            \"\\xe1\\x80\\xaf\"\n            \"\\xe1\\x80\\x95\"\n            \"\\xe1\\x80\\xba\"\n            \"x\";\n          re_set_syntax (0);\n          memset (&regex, 0, sizeof regex);\n          s = re_compile_pattern (pat, sizeof pat - 1, &regex);\n          if (s)\n            result |= 1;\n          else\n            {\n              i = re_search (&regex, data, sizeof data - 1,\n                             0, sizeof data - 1, 0);\n              if (i != 0 && i != 21)\n                result |= 1;\n            }\n        }\n\n      if (! setlocale (LC_ALL, \"C\"))\n        return 1;\n    }\n\n  /* This test is from glibc bug 3957, reported by Andrew Mackey.  */\n  re_set_syntax (RE_SYNTAX_EGREP | RE_HAT_LISTS_NOT_NEWLINE);\n  memset (&regex, 0, sizeof regex);\n  s = re_compile_pattern (\"a[^x]b\", 6, &regex);\n  if (s)\n    result |= 2;\n  /* This should fail, but succeeds for glibc-2.5.  */\n  else if (re_search (&regex, \"a\\nb\", 3, 0, 3, &regs) != -1)\n    result |= 2;\n\n  /* This regular expression is from Spencer ere test number 75\n     in grep-2.3.  */\n  re_set_syntax (RE_SYNTAX_POSIX_EGREP);\n  memset (&regex, 0, sizeof regex);\n  for (i = 0; i <= UCHAR_MAX; i++)\n    folded_chars[i] = i;\n  regex.translate = folded_chars;\n  s = re_compile_pattern (\"a[[:@:>@:]]b\\n\", 11, &regex);\n  /* This should fail with _Invalid character class name_ error.  */\n  if (!s)\n    result |= 4;\n\n  /* Ensure that [b-a] is diagnosed as invalid, when\n     using RE_NO_EMPTY_RANGES. */\n  re_set_syntax (RE_SYNTAX_POSIX_EGREP | RE_NO_EMPTY_RANGES);\n  memset (&regex, 0, sizeof regex);\n  s = re_compile_pattern (\"a[b-a]\", 6, &regex);\n  if (s == 0)\n    result |= 8;\n\n  /* This should succeed, but does not for glibc-2.1.3.  */\n  memset (&regex, 0, sizeof regex);\n  s = re_compile_pattern (\"{1\", 2, &regex);\n  if (s)\n    result |= 8;\n\n  /* The following example is derived from a problem report\n     against gawk from Jorge Stolfi <stolfi@ic.unicamp.br>.  */\n  memset (&regex, 0, sizeof regex);\n  s = re_compile_pattern (\"[an\\371]*n\", 7, &regex);\n  if (s)\n    result |= 8;\n  /* This should match, but does not for glibc-2.2.1.  */\n  else if (re_match (&regex, \"an\", 2, 0, &regs) != 2)\n    result |= 8;\n\n  memset (&regex, 0, sizeof regex);\n  s = re_compile_pattern (\"x\", 1, &regex);\n  if (s)\n    result |= 8;\n  /* glibc-2.2.93 does not work with a negative RANGE argument.  */\n  else if (re_search (&regex, \"wxy\", 3, 2, -2, &regs) != 1)\n    result |= 8;\n\n  /* The version of regex.c in older versions of gnulib\n     ignored RE_ICASE.  Detect that problem too.  */\n  re_set_syntax (RE_SYNTAX_EMACS | RE_ICASE);\n  memset (&regex, 0, sizeof regex);\n  s = re_compile_pattern (\"x\", 1, &regex);\n  if (s)\n    result |= 16;\n  else if (re_search (&regex, \"WXY\", 3, 0, 3, &regs) < 0)\n    result |= 16;\n\n  /* Catch a bug reported by Vin Shelton in\n     http://lists.gnu.org/archive/html/bug-coreutils/2007-06/msg00089.html\n     */\n  re_set_syntax (RE_SYNTAX_POSIX_BASIC\n                 & ~RE_CONTEXT_INVALID_DUP\n                 & ~RE_NO_EMPTY_RANGES);\n  memset (&regex, 0, sizeof regex);\n  s = re_compile_pattern (\"[[:alnum:]_-]\\\\\\\\+$\", 16, &regex);\n  if (s)\n    result |= 32;\n\n  /* REG_STARTEND was added to glibc on 2004-01-15.\n     Reject older versions.  */\n  if (! REG_STARTEND)\n    result |= 64;\n\n#if 0\n  /* It would be nice to reject hosts whose regoff_t values are too\n     narrow (including glibc on hosts with 64-bit ptrdiff_t and\n     32-bit int), but we should wait until glibc implements this\n     feature.  Otherwise, support for equivalence classes and\n     multibyte collation symbols would always be broken except\n     when compiling --without-included-regex.   */\n  if (sizeof (regoff_t) < sizeof (ptrdiff_t)\n      || sizeof (regoff_t) < sizeof (ssize_t))\n    result |= 64;\n#endif\n\n  return result;\n}",
      "lines": 173,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-rmdir.c": {
    "main": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        46,
        1
      ],
      "content": "int\nmain (void)\n{\n  /* Remove any leftovers from a previous partial run.  */\n  ignore_value (system (\"rm -rf \" BASE \"*\"));\n\n  return test_rmdir_func (rmdir, true);\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-rmdir.h": {
    "test_rmdir_func": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        101,
        1
      ],
      "content": "static int\ntest_rmdir_func (int (*func) (char const *name), bool print)\n{\n  /* Setup.  */\n  ASSERT (mkdir (BASE \"dir\", 0700) == 0);\n  ASSERT (close (creat (BASE \"dir/file\", 0600)) == 0);\n\n  /* Basic error conditions.  */\n  errno = 0;\n  ASSERT (func (\"\") == -1);\n  ASSERT (errno == ENOENT);\n  errno = 0;\n  ASSERT (func (BASE \"nosuch\") == -1);\n  ASSERT (errno == ENOENT);\n  errno = 0;\n  ASSERT (func (BASE \"nosuch/\") == -1);\n  ASSERT (errno == ENOENT);\n  errno = 0;\n  ASSERT (func (\".\") == -1);\n  ASSERT (errno == EINVAL || errno == EBUSY);\n  /* Resulting errno after \"..\" or \"/\" is too varied to test; it is\n     reasonable to see any of EINVAL, EBUSY, EEXIST, ENOTEMPTY,\n     EACCES, EPERM.  */\n  ASSERT (func (\"..\") == -1);\n  ASSERT (func (\"/\") == -1);\n  ASSERT (func (\"///\") == -1);\n  errno = 0;\n  ASSERT (func (BASE \"dir/file/\") == -1);\n  ASSERT (errno == ENOTDIR);\n\n  /* Non-empty directory.  */\n  errno = 0;\n  ASSERT (func (BASE \"dir\") == -1);\n  ASSERT (errno == EEXIST || errno == ENOTEMPTY);\n\n  /* Non-directory.  */\n  errno = 0;\n  ASSERT (func (BASE \"dir/file\") == -1);\n  ASSERT (errno == ENOTDIR);\n\n  /* Empty directory.  */\n  ASSERT (unlink (BASE \"dir/file\") == 0);\n  errno = 0;\n  ASSERT (func (BASE \"dir/.//\") == -1);\n  ASSERT (errno == EINVAL || errno == EBUSY || errno == EEXIST\n          || errno == ENOTEMPTY);\n  ASSERT (func (BASE \"dir\") == 0);\n\n  /* Test symlink behavior.  Specifying trailing slash should remove\n     referent directory (POSIX), or cause ENOTDIR failure (Linux), but\n     not touch symlink.  We prefer the Linux behavior for its\n     intuitiveness (especially compared to rmdir(\"symlink-to-file/\")),\n     but not enough to penalize POSIX systems with an rpl_rmdir.  */\n  if (symlink (BASE \"dir\", BASE \"link\") != 0)\n    {\n      if (print)\n        fputs (\"skipping test: symlinks not supported on this file system\\n\",\n               stderr);\n      return 77;\n    }\n  ASSERT (mkdir (BASE \"dir\", 0700) == 0);\n  errno = 0;\n  if (func (BASE \"link/\") == 0)\n    {\n      struct stat st;\n      errno = 0;\n      ASSERT (stat (BASE \"link\", &st) == -1);\n      ASSERT (errno == ENOENT);\n    }\n  else\n    {\n      ASSERT (errno == ENOTDIR);\n      ASSERT (func (BASE \"dir\") == 0);\n    }\n  ASSERT (unlink (BASE \"link\") == 0);\n\n  return 0;\n}",
      "lines": 78,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-select-fd.c": {
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  if (argc == 4)\n    {\n      char mode = argv[1][0];\n\n      if (mode == 'r' || mode == 'w')\n        {\n          int fd = atoi (argv[2]);\n\n          if (fd >= 0)\n            {\n              const char *result_file_name = argv[3];\n              FILE *result_file = fopen (result_file_name, \"wb\");\n\n              if (result_file != NULL)\n                {\n                  fd_set fds;\n                  struct timeval timeout;\n                  int ret;\n\n                  FD_ZERO (&fds);\n                  FD_SET (fd, &fds);\n                  timeout.tv_sec = 0;\n                  timeout.tv_usec = 10000;\n                  ret = (mode == 'r'\n                         ? select (fd + 1, &fds, NULL, NULL, &timeout)\n                         : select (fd + 1, NULL, &fds, NULL, &timeout));\n                  if (ret < 0)\n                    {\n                      perror (\"select failed\");\n                      exit (1);\n                    }\n                  if ((ret == 0) != ! FD_ISSET (fd, &fds))\n                    {\n                      fprintf (stderr, \"incorrect return value\\n\");\n                      exit (1);\n                    }\n                  fprintf (result_file, \"%d\\n\", ret);\n                  exit (0);\n                }\n            }\n        }\n    }\n  fprintf (stderr, \"Usage: test-select-fd mode fd result-file-name\\n\");\n  exit (1);\n}",
      "lines": 48,
      "depth": 18,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-select-stdin.c": {
    "main": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        82,
        1
      ],
      "content": "int\nmain (void)\n{\n  printf (\"Applying select() from standard input. Press Ctrl-C to abort.\\n\");\n  for (;;)\n    {\n      struct timeval before;\n      struct timeval after;\n      unsigned long spent_usec;\n      fd_set readfds;\n      struct timeval timeout;\n      int ret;\n\n      gettimeofday (&before, NULL);\n\n      FD_ZERO (&readfds);\n      FD_SET (0, &readfds);\n      timeout.tv_sec = 0;\n      timeout.tv_usec = 500000;\n      ret = select (1, &readfds, NULL, NULL, &timeout);\n\n      gettimeofday (&after, NULL);\n      spent_usec = (after.tv_sec - before.tv_sec) * 1000000\n                   + after.tv_usec - before.tv_usec;\n\n      if (ret < 0)\n        {\n          perror (\"select failed\");\n          exit (1);\n        }\n      if ((ret == 0) != ! FD_ISSET (0, &readfds))\n        {\n          fprintf (stderr, \"incorrect return value\\n\");\n          exit (1);\n        }\n      if (ret == 0)\n        {\n          if (spent_usec < 250000)\n            {\n              fprintf (stderr, \"returned too early\\n\");\n              exit (1);\n            }\n          /* Timeout */\n          printf (\".\");\n          ASSERT (fflush (stdout) == 0);\n        }\n      else\n        {\n          char c;\n\n          printf (\"Input available! Trying to read 1 byte...\\n\");\n          ASSERT (read (0, &c, 1) == 1);\n        }\n    }\n}",
      "lines": 55,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-select.c": {
    "main": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        33,
        1
      ],
      "content": "int\nmain (void)\n{\n  return test_function (select);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-select.h": {
    "failed": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "static void\nfailed (const char *reason)\n{\n  if (++failures > 1)\n    printf (\"  \");\n  printf (\"failed (%s)\\n\", reason);\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        73,
        1
      ],
      "content": "static int\ntest (void (*fn) (select_fn), select_fn my_select, const char *msg)\n{\n  failures = 0;\n  printf (\"%s... \", msg);\n  fflush (stdout);\n  fn (my_select);\n\n  if (!failures)\n    printf (\"passed\\n\");\n\n  return failures;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "open_server_socket": {
      "start_point": [
        78,
        0
      ],
      "end_point": [
        106,
        1
      ],
      "content": "static int\nopen_server_socket (void)\n{\n  int s, x;\n  struct sockaddr_in ia;\n\n  s = socket (AF_INET, SOCK_STREAM, 0);\n\n  x = 1;\n  setsockopt (s, SOL_SOCKET, SO_REUSEPORT, &x, sizeof (x));\n\n  memset (&ia, 0, sizeof (ia));\n  ia.sin_family = AF_INET;\n  inet_pton (AF_INET, \"127.0.0.1\", &ia.sin_addr);\n  ia.sin_port = htons (TEST_PORT);\n  if (bind (s, (struct sockaddr *) &ia, sizeof (ia)) < 0)\n    {\n      perror (\"bind\");\n      exit (77);\n    }\n\n  if (listen (s, 1) < 0)\n    {\n      perror (\"listen\");\n      exit (77);\n    }\n\n  return s;\n}",
      "lines": 29,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "connect_to_socket": {
      "start_point": [
        108,
        0
      ],
      "end_point": [
        143,
        1
      ],
      "content": "static int\nconnect_to_socket (bool blocking)\n{\n  int s;\n  struct sockaddr_in ia;\n\n  s = socket (AF_INET, SOCK_STREAM, 0);\n\n  memset (&ia, 0, sizeof (ia));\n  ia.sin_family = AF_INET;\n  inet_pton (AF_INET, \"127.0.0.1\", &ia.sin_addr);\n  ia.sin_port = htons (TEST_PORT);\n\n  if (!blocking)\n    {\n#ifdef WINDOWS_NATIVE\n      unsigned long iMode = 1;\n      ioctl (s, FIONBIO, (char *) &iMode);\n\n#elif defined F_GETFL\n      int oldflags = fcntl (s, F_GETFL, NULL);\n\n      if (!(oldflags & O_NONBLOCK))\n        fcntl (s, F_SETFL, oldflags | O_NONBLOCK);\n#endif\n    }\n\n  if (connect (s, (struct sockaddr *) &ia, sizeof (ia)) < 0\n      && (blocking || errno != EINPROGRESS))\n    {\n      perror (\"connect\");\n      exit (77);\n    }\n\n  return s;\n}",
      "lines": 36,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "do_select": {
      "start_point": [
        158,
        0
      ],
      "end_point": [
        190,
        1
      ],
      "content": "static int\ndo_select (int fd, int ev, struct timeval *timeout, select_fn my_select)\n{\n  fd_set rfds, wfds, xfds;\n  int r, rev;\n\n  FD_ZERO (&rfds);\n  FD_ZERO (&wfds);\n  FD_ZERO (&xfds);\n  if (ev & SEL_IN)\n    FD_SET (fd, &rfds);\n  if (ev & SEL_OUT)\n    FD_SET (fd, &wfds);\n  if (ev & SEL_EXC)\n    FD_SET (fd, &xfds);\n  r = my_select (fd + 1, &rfds, &wfds, &xfds, timeout);\n  if (r < 0)\n    return r;\n\n  rev = 0;\n  if (FD_ISSET (fd, &rfds))\n    rev |= SEL_IN;\n  if (FD_ISSET (fd, &wfds))\n    rev |= SEL_OUT;\n  if (FD_ISSET (fd, &xfds))\n    rev |= SEL_EXC;\n  if (rev && r == 0)\n    failed (\"select returned 0\");\n  if (rev & ~ev)\n    failed (\"select returned unrequested events\");\n\n  return rev;\n}",
      "lines": 33,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "do_select_nowait": {
      "start_point": [
        192,
        0
      ],
      "end_point": [
        199,
        1
      ],
      "content": "static int\ndo_select_nowait (int fd, int ev, select_fn my_select)\n{\n  struct timeval tv0;\n  tv0.tv_sec = 0;\n  tv0.tv_usec = 0;\n  return do_select (fd, ev, &tv0, my_select);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "do_select_wait": {
      "start_point": [
        201,
        0
      ],
      "end_point": [
        205,
        1
      ],
      "content": "static int\ndo_select_wait (int fd, int ev, select_fn my_select)\n{\n  return do_select (fd, ev, NULL, my_select);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "test_tty": {
      "start_point": [
        211,
        0
      ],
      "end_point": [
        225,
        1
      ],
      "content": "static void\ntest_tty (select_fn my_select)\n{\n  if (do_select_nowait (0, SEL_IN, my_select) != 0)\n    failed (\"can read\");\n  if (do_select_nowait (0, SEL_OUT, my_select) == 0)\n    failed (\"cannot write\");\n\n  if (do_select_wait (0, SEL_IN, my_select) == 0)\n    failed (\"return with infinite timeout\");\n\n  getchar ();\n  if (do_select_nowait (0, SEL_IN, my_select) != 0)\n    failed (\"can read after getc\");\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "do_select_bad_nfd_nowait": {
      "start_point": [
        229,
        0
      ],
      "end_point": [
        237,
        1
      ],
      "content": "static int\ndo_select_bad_nfd_nowait (int nfd, select_fn my_select)\n{\n  struct timeval tv0;\n  tv0.tv_sec = 0;\n  tv0.tv_usec = 0;\n  errno = 0;\n  return my_select (nfd, NULL, NULL, NULL, &tv0);\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "test_bad_nfd": {
      "start_point": [
        239,
        0
      ],
      "end_point": [
        250,
        1
      ],
      "content": "static void\ntest_bad_nfd (select_fn my_select)\n{\n  if (do_select_bad_nfd_nowait (-1, my_select) != -1 || errno != EINVAL)\n    failed (\"invalid errno after negative nfds\");\n  /* Can't test FD_SETSIZE + 1 for EINVAL, since some systems allow\n     dynamically larger set size by redefining FD_SETSIZE anywhere up\n     to the actual maximum fd.  */\n  /* if (do_select_bad_nfd_nowait (FD_SETSIZE + 1, my_select) != -1 */\n  /*     || errno != EINVAL) */\n  /*   failed (\"invalid errno after bogus nfds\"); */\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "do_select_bad_fd": {
      "start_point": [
        254,
        0
      ],
      "end_point": [
        273,
        1
      ],
      "content": "static int\ndo_select_bad_fd (int fd, int ev, struct timeval *timeout, select_fn my_select)\n{\n  fd_set rfds, wfds, xfds;\n\n  FD_ZERO (&rfds);\n  FD_ZERO (&wfds);\n  FD_ZERO (&xfds);\n  if (ev & SEL_IN)\n    FD_SET (fd, &rfds);\n  if (ev & SEL_OUT)\n    FD_SET (fd, &wfds);\n  if (ev & SEL_EXC)\n    FD_SET (fd, &xfds);\n  errno = 0;\n  return my_select (fd + 1, &rfds, &wfds, &xfds, timeout);\n  /* In this case, when fd is invalid, on some platforms, the bit for fd\n     is left alone in the fd_set, whereas on other platforms it is cleared.\n     So, don't check the bit for fd here.  */\n}",
      "lines": 20,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "do_select_bad_fd_nowait": {
      "start_point": [
        275,
        0
      ],
      "end_point": [
        282,
        1
      ],
      "content": "static int\ndo_select_bad_fd_nowait (int fd, int ev, select_fn my_select)\n{\n  struct timeval tv0;\n  tv0.tv_sec = 0;\n  tv0.tv_usec = 0;\n  return do_select_bad_fd (fd, ev, &tv0, my_select);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "test_bad_fd": {
      "start_point": [
        284,
        0
      ],
      "end_point": [
        308,
        1
      ],
      "content": "static void\ntest_bad_fd (select_fn my_select)\n{\n  /* This tests fails on OSF/1 and native Windows, even with fd = 16.  */\n#if !(defined __osf__ || defined WINDOWS_NATIVE)\n  int fd;\n\n  /* On Linux, Mac OS X, *BSD, values of fd like 99 or 399 are discarded\n     by the kernel early and therefore do *not* lead to EBADF, as required\n     by POSIX.  */\n# if defined __linux__ || (defined __APPLE__ && defined __MACH__) || defined __FreeBSD__ || defined __OpenBSD__ || defined __NetBSD__\n  fd = 16;\n# else\n  fd = 99;\n# endif\n  close (fd);\n\n  if (do_select_bad_fd_nowait (fd, SEL_IN, my_select) == 0 || errno != EBADF)\n    failed (\"invalid fd among rfds\");\n  if (do_select_bad_fd_nowait (fd, SEL_OUT, my_select) == 0 || errno != EBADF)\n    failed (\"invalid fd among wfds\");\n  if (do_select_bad_fd_nowait (fd, SEL_EXC, my_select) == 0 || errno != EBADF)\n    failed (\"invalid fd among xfds\");\n#endif\n}",
      "lines": 25,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_connect_first": {
      "start_point": [
        313,
        0
      ],
      "end_point": [
        337,
        1
      ],
      "content": "static void\ntest_connect_first (select_fn my_select)\n{\n  int s = open_server_socket ();\n  struct sockaddr_in ia;\n  socklen_t addrlen;\n\n  int c1, c2;\n\n  if (do_select_nowait (s, SEL_IN | SEL_EXC, my_select) != 0)\n    failed (\"can read, socket not connected\");\n\n  c1 = connect_to_socket (false);\n\n  if (do_select_wait (s, SEL_IN | SEL_EXC, my_select) != SEL_IN)\n    failed (\"expecting readability on passive socket\");\n  if (do_select_nowait (s, SEL_IN | SEL_EXC, my_select) != SEL_IN)\n    failed (\"expecting readability on passive socket\");\n\n  addrlen = sizeof (ia);\n  c2 = accept (s, (struct sockaddr *) &ia, &addrlen);\n  ASSERT (close (s) == 0);\n  ASSERT (close (c1) == 0);\n  ASSERT (close (c2) == 0);\n}",
      "lines": 25,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_accept_first": {
      "start_point": [
        342,
        0
      ],
      "end_point": [
        382,
        1
      ],
      "content": "static void\ntest_accept_first (select_fn my_select)\n{\n#ifndef WINDOWS_NATIVE\n  int s = open_server_socket ();\n  struct sockaddr_in ia;\n  socklen_t addrlen;\n  char buf[3];\n  int c, pid;\n\n  pid = fork ();\n  if (pid < 0)\n    return;\n\n  if (pid == 0)\n    {\n      addrlen = sizeof (ia);\n      c = accept (s, (struct sockaddr *) &ia, &addrlen);\n      ASSERT (close (s) == 0);\n      ASSERT (write (c, \"foo\", 3) == 3);\n      ASSERT (read (c, buf, 3) == 3);\n      shutdown (c, SHUT_RD);\n      ASSERT (close (c) == 0);\n      exit (0);\n    }\n  else\n    {\n      ASSERT (close (s) == 0);\n      c = connect_to_socket (true);\n      if (do_select_nowait (c, SEL_OUT, my_select) != SEL_OUT)\n        failed (\"cannot write after blocking connect\");\n      ASSERT (write (c, \"foo\", 3) == 3);\n      wait (&pid);\n      if (do_select_wait (c, SEL_IN, my_select) != SEL_IN)\n        failed (\"cannot read data left in the socket by closed process\");\n      ASSERT (read (c, buf, 3) == 3);\n      ASSERT (write (c, \"foo\", 3) == 3);\n      (void) close (c); /* may fail with errno = ECONNRESET */\n    }\n#endif\n}",
      "lines": 41,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_pair": {
      "start_point": [
        387,
        0
      ],
      "end_point": [
        403,
        1
      ],
      "content": "static void\ntest_pair (int rd, int wd, select_fn my_select)\n{\n  char buf[3];\n  if (do_select_wait (wd, SEL_IN | SEL_OUT | SEL_EXC, my_select) != SEL_OUT)\n    failed (\"expecting writability before writing\");\n  if (do_select_nowait (wd, SEL_IN | SEL_OUT | SEL_EXC, my_select) != SEL_OUT)\n    failed (\"expecting writability before writing\");\n\n  ASSERT (write (wd, \"foo\", 3) == 3);\n  if (do_select_wait (rd, SEL_IN, my_select) != SEL_IN)\n    failed (\"expecting readability after writing\");\n  if (do_select_nowait (rd, SEL_IN, my_select) != SEL_IN)\n    failed (\"expecting readability after writing\");\n\n  ASSERT (read (rd, buf, 3) == 3);\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_socket_pair": {
      "start_point": [
        408,
        0
      ],
      "end_point": [
        424,
        1
      ],
      "content": "static void\ntest_socket_pair (select_fn my_select)\n{\n  struct sockaddr_in ia;\n\n  socklen_t addrlen = sizeof (ia);\n  int s = open_server_socket ();\n  int c1 = connect_to_socket (false);\n  int c2 = accept (s, (struct sockaddr *) &ia, &addrlen);\n\n  ASSERT (close (s) == 0);\n\n  test_pair (c1, c2, my_select);\n  ASSERT (close (c1) == 0);\n  ASSERT (write (c2, \"foo\", 3) == 3);\n  (void) close (c2); /* may fail with errno = ECONNRESET */\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_pipe": {
      "start_point": [
        429,
        0
      ],
      "end_point": [
        438,
        1
      ],
      "content": "static void\ntest_pipe (select_fn my_select)\n{\n  int fd[2];\n\n  ASSERT (pipe (fd) == 0);\n  test_pair (fd[0], fd[1], my_select);\n  ASSERT (close (fd[0]) == 0);\n  ASSERT (close (fd[1]) == 0);\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_function": {
      "start_point": [
        443,
        0
      ],
      "end_point": [
        461,
        1
      ],
      "content": "static int\ntest_function (select_fn my_select)\n{\n  int result = 0;\n\n#ifdef INTERACTIVE\n  printf (\"Please press Enter\\n\");\n  test (test_tty, \"TTY\", my_select);\n#endif\n\n  result += test (test_bad_nfd, my_select, \"Invalid nfd test\");\n  result += test (test_bad_fd, my_select, \"Invalid fd test\");\n  result += test (test_connect_first, my_select, \"Unconnected socket test\");\n  result += test (test_socket_pair, my_select, \"Connected sockets test\");\n  result += test (test_accept_first, my_select, \"General socket test with fork\");\n  result += test (test_pipe, my_select, \"Pipe test\");\n\n  return result;\n}",
      "lines": 19,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-setenv.c": {
    "main": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "int\nmain (void)\n{\n  /* Test overwriting.  */\n  ASSERT (setenv (\"a\", \"==\", -1) == 0);\n  ASSERT (setenv (\"a\", \"2\", 0) == 0);\n  ASSERT (strcmp (getenv (\"a\"), \"==\") == 0);\n\n  /* Required to fail with EINVAL.  */\n  errno = 0;\n  ASSERT (setenv (\"\", \"\", 1) == -1);\n  ASSERT (errno == EINVAL);\n  errno = 0;\n  ASSERT (setenv (\"a=b\", \"\", 0) == -1);\n  ASSERT (errno == EINVAL);\n#if 0\n  /* glibc and gnulib's implementation guarantee this, but POSIX no\n     longer requires it: http://austingroupbugs.net/view.php?id=185  */\n  errno = 0;\n  ASSERT (setenv (NULL, \"\", 0) == -1);\n  ASSERT (errno == EINVAL);\n#endif\n\n  return 0;\n}",
      "lines": 25,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-setlocale1.c": {
    "main": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  char *name1;\n  char *name2;\n\n  /* Try to set the locale by implicitly looking at the LC_ALL environment\n     variable.\n     configure should already have checked that the locale is supported.  */\n  if (setlocale (LC_ALL, \"\") == NULL)\n    return 1;\n\n  name1 = strdup (setlocale (LC_ALL, NULL));\n\n  /* Reset the locale.  */\n  if (setlocale (LC_ALL, \"C\") == NULL)\n    return 1;\n\n  /* Try to set the locale by explicitly looking at the LC_ALL environment\n     variable.\n     configure should already have checked that the locale is supported.  */\n  if (setlocale (LC_ALL, getenv (\"LC_ALL\")) == NULL)\n    return 1;\n\n  name2 = strdup (setlocale (LC_ALL, NULL));\n\n  /* Test that the two results are the same.  */\n  ASSERT (strcmp (name1, name2) == 0);\n\n  return 0;\n}",
      "lines": 31,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-setlocale2.c": {
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "int\nmain ()\n{\n  /* Try to set the locale by implicitly looking at the LC_ALL environment\n     variable.  */\n  if (setlocale (LC_ALL, \"\") != NULL)\n    /* It was successful.  Check whether LC_CTYPE is non-trivial.  */\n    if (strcmp (setlocale (LC_CTYPE, NULL), \"C\") == 0)\n      {\n        fprintf (stderr, \"setlocale did not fail for implicit %s\\n\",\n                 getenv (\"LC_ALL\"));\n        return 1;\n      }\n\n  /* Reset the locale.  */\n  if (setlocale (LC_ALL, \"C\") == NULL)\n    return 1;\n\n  /* Try to set the locale by explicitly looking at the LC_ALL environment\n     variable.  */\n  if (setlocale (LC_ALL, getenv (\"LC_ALL\")) != NULL)\n    /* It was successful.  Check whether LC_CTYPE is non-trivial.  */\n    if (strcmp (setlocale (LC_CTYPE, NULL), \"C\") == 0)\n      {\n        fprintf (stderr, \"setlocale did not fail for explicit %s\\n\",\n                 getenv (\"LC_ALL\"));\n        return 1;\n      }\n\n  return 0;\n}",
      "lines": 31,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-setsockopt.c": {
    "main": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "int\nmain (void)\n{\n  (void) gl_sockets_startup (SOCKETS_1_1);\n\n  /* Test behaviour for invalid file descriptors.  */\n  {\n    int value = 1;\n\n    errno = 0;\n    ASSERT (setsockopt (-1, SOL_SOCKET, SO_REUSEADDR, &value, sizeof (value))\n            == -1);\n    ASSERT (errno == EBADF);\n  }\n  {\n    int value = 1;\n\n    close (99);\n    errno = 0;\n    ASSERT (setsockopt (99, SOL_SOCKET, SO_REUSEADDR, &value, sizeof (value))\n            == -1);\n    ASSERT (errno == EBADF);\n  }\n\n  return 0;\n}",
      "lines": 26,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-sigaction.c": {
    "handler": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "static void\nhandler (int sig)\n{\n  static int entry_count;\n  struct sigaction sa;\n  ASSERT (sig == SIGABRT);\n  ASSERT (sigaction (SIGABRT, NULL, &sa) == 0);\n  ASSERT ((sa.sa_flags & SA_SIGINFO) == 0);\n  switch (entry_count++)\n    {\n    case 0:\n      ASSERT ((sa.sa_flags & SA_RESETHAND) == 0);\n      ASSERT (sa.sa_handler == handler);\n      break;\n    case 1:\n      /* This assertion fails on glibc-2.3.6 systems with LinuxThreads,\n         when this program is linked with -lpthread, due to the sigaction()\n         override in libpthread.so.  */\n#if !(defined __GLIBC__ || defined __UCLIBC__)\n      ASSERT (sa.sa_handler == SIG_DFL);\n#endif\n      break;\n    default:\n      ASSERT (0);\n    }\n}",
      "lines": 26,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        88,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "int\nmain (void)\n{\n  struct sigaction sa;\n  struct sigaction old_sa;\n  sa.sa_handler = handler;\n\n  sa.sa_flags = 0;\n  ASSERT (sigemptyset (&sa.sa_mask) == 0);\n  ASSERT (sigaction (SIGABRT, &sa, NULL) == 0);\n  ASSERT (raise (SIGABRT) == 0);\n\n  sa.sa_flags = SA_RESETHAND | SA_NODEFER;\n  ASSERT (sigaction (SIGABRT, &sa, &old_sa) == 0);\n  ASSERT ((old_sa.sa_flags & MASK_SA_FLAGS) == 0);\n  ASSERT (old_sa.sa_handler == handler);\n  ASSERT (raise (SIGABRT) == 0);\n\n  sa.sa_handler = SIG_DFL;\n  ASSERT (sigaction (SIGABRT, &sa, &old_sa) == 0);\n  ASSERT ((old_sa.sa_flags & SA_SIGINFO) == 0);\n#if !(defined __GLIBC__ || defined __UCLIBC__) /* see above */\n  ASSERT (old_sa.sa_handler == SIG_DFL);\n#endif\n\n  sa.sa_handler = SIG_IGN;\n  ASSERT (sigaction (SIGABRT, &sa, NULL) == 0);\n  ASSERT (raise (SIGABRT) == 0);\n  ASSERT (sigaction (SIGABRT, NULL, &old_sa) == 0);\n  ASSERT (old_sa.sa_handler == SIG_IGN);\n  ASSERT (raise (SIGABRT) == 0);\n\n  return 0;\n}",
      "lines": 34,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-signal-h.c": {
    "main": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        128,
        1
      ],
      "content": "int\nmain (void)\n{\n  switch (0)\n    {\n      /* The following are guaranteed by C.  */\n    case 0:\n    case SIGABRT:\n    case SIGFPE:\n    case SIGILL:\n    case SIGINT:\n    case SIGSEGV:\n    case SIGTERM:\n      /* The following is guaranteed by gnulib.  */\n#if GNULIB_SIGPIPE || defined SIGPIPE\n    case SIGPIPE:\n#endif\n      /* Ensure no conflict with other standardized names.  */\n#ifdef SIGALRM\n    case SIGALRM:\n#endif\n      /* On Haiku, SIGBUS is mistakenly equal to SIGSEGV.  */\n#if defined SIGBUS && SIGBUS != SIGSEGV\n    case SIGBUS:\n#endif\n#ifdef SIGCHLD\n    case SIGCHLD:\n#endif\n#ifdef SIGCONT\n    case SIGCONT:\n#endif\n#ifdef SIGHUP\n    case SIGHUP:\n#endif\n#ifdef SIGKILL\n    case SIGKILL:\n#endif\n#ifdef SIGQUIT\n    case SIGQUIT:\n#endif\n#ifdef SIGSTOP\n    case SIGSTOP:\n#endif\n#ifdef SIGTSTP\n    case SIGTSTP:\n#endif\n#ifdef SIGTTIN\n    case SIGTTIN:\n#endif\n#ifdef SIGTTOU\n    case SIGTTOU:\n#endif\n#ifdef SIGUSR1\n    case SIGUSR1:\n#endif\n#ifdef SIGUSR2\n    case SIGUSR2:\n#endif\n#ifdef SIGSYS\n    case SIGSYS:\n#endif\n#ifdef SIGTRAP\n    case SIGTRAP:\n#endif\n#ifdef SIGURG\n    case SIGURG:\n#endif\n#ifdef SIGVTALRM\n    case SIGVTALRM:\n#endif\n#ifdef SIGXCPU\n    case SIGXCPU:\n#endif\n#ifdef SIGXFSZ\n    case SIGXFSZ:\n#endif\n      /* SIGRTMIN and SIGRTMAX need not be compile-time constants.  */\n#if 0\n# ifdef SIGRTMIN\n    case SIGRTMIN:\n# endif\n# ifdef SIGRTMAX\n    case SIGRTMAX:\n# endif\n#endif\n      ;\n    }\n  return s.a + s.b + s.c + s.e;\n}",
      "lines": 89,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-sigprocmask.c": {
    "sigint_handler": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "static void\nsigint_handler (int sig)\n{\n  sigint_occurred++;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": [
      {
        "start_point": [
          42,
          0
        ],
        "end_point": [
          87,
          1
        ],
        "content": "int\nmain (int argc, char *argv[])\n{\n  sigset_t set;\n  pid_t pid = getpid ();\n  char command[80];\n\n  if (sizeof (int) < sizeof pid && 0x7fffffff < pid)\n    {\n      fputs (\"Skipping test: pid too large\\n\", stderr);\n      return 77;\n    }\n\n  signal (SIGINT, sigint_handler);\n\n  sigemptyset (&set);\n  sigaddset (&set, SIGINT);\n\n  /* Check error handling.  */\n  ASSERT (sigprocmask (1729, &set, NULL) == -1);\n  ASSERT (errno == EINVAL);\n\n  /* Block SIGINT.  */\n  ASSERT (sigprocmask (SIG_BLOCK, &set, NULL) == 0);\n\n  /* Request a SIGINT signal from outside.  */\n  sprintf (command, \"sh -c 'sleep 1; kill -%d %d' &\", SIGINT, (int) pid);\n  ASSERT (system (command) == 0);\n\n  /* Wait.  */\n  sleep (2);\n\n  /* The signal should not have arrived yet, because it is blocked.  */\n  ASSERT (sigint_occurred == 0);\n\n  /* Unblock SIGINT.  */\n  ASSERT (sigprocmask (SIG_UNBLOCK, &set, NULL) == 0);\n\n  /* The signal should have arrived now, because POSIX says\n       \"If there are any pending unblocked signals after the call to\n        sigprocmask(), at least one of those signals shall be delivered\n        before the call to sigprocmask() returns.\"  */\n  ASSERT (sigint_occurred == 1);\n\n  return 0;\n}",
        "lines": 46,
        "depth": 10,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          94,
          0
        ],
        "end_point": [
          99,
          1
        ],
        "content": "int\nmain ()\n{\n  fputs (\"Skipping test: native Windows platform\\n\", stderr);\n  return 77;\n}",
        "lines": 6,
        "depth": 7,
        "decorators": [
          "int"
        ]
      }
    ]
  },
  "findutils/findutils-4.6.0/tests/test-sleep.c": {
    "handle_alarm": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        35,
        1
      ],
      "content": "static void\nhandle_alarm (int sig)\n{\n  if (sig != SIGALRM)\n    _exit (1);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "int\nmain (void)\n{\n  ASSERT (sleep (1) <= 1);\n\n  ASSERT (sleep (0) == 0);\n\n#if HAVE_DECL_ALARM\n  {\n    const unsigned int pentecost = 50 * 24 * 60 * 60; /* 50 days.  */\n    unsigned int remaining;\n    signal (SIGALRM, handle_alarm);\n    alarm (1);\n    remaining = sleep (pentecost);\n    ASSERT (pentecost - 10 < remaining && remaining <= pentecost);\n  }\n#endif\n\n  return 0;\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-snprintf.c": {
    "main": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  char buf[8];\n  int size;\n  int retval;\n\n  retval = snprintf (NULL, 0, \"%d\", 12345);\n  ASSERT (retval == 5);\n\n  for (size = 0; size <= 8; size++)\n    {\n      memcpy (buf, \"DEADBEEF\", 8);\n      retval = snprintf (buf, size, \"%d\", 12345);\n      ASSERT (retval == 5);\n      if (size < 6)\n        {\n          if (size > 0)\n            {\n              ASSERT (memcmp (buf, \"12345\", size - 1) == 0);\n              ASSERT (buf[size - 1] == '\\0' || buf[size - 1] == '0' + size);\n            }\n#if !CHECK_SNPRINTF_POSIX\n          if (size > 0)\n#endif\n            ASSERT (memcmp (buf + size, &\"DEADBEEF\"[size], 8 - size) == 0);\n        }\n      else\n        {\n          ASSERT (memcmp (buf, \"12345\\0EF\", 8) == 0);\n        }\n    }\n\n  /* Test the support of the POSIX/XSI format strings with positions.  */\n  {\n    char result[100];\n    retval = snprintf (result, sizeof (result), \"%2$d %1$d\", 33, 55);\n    ASSERT (strcmp (result, \"55 33\") == 0);\n    ASSERT (retval == strlen (result));\n  }\n\n  return 0;\n}",
      "lines": 43,
      "depth": 16,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-sockets.c": {
    "main": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "int\nmain (void)\n{\n  int err;\n\n  err = gl_sockets_startup (SOCKETS_1_1);\n  if (err != 0)\n    {\n      printf (\"wsastartup failed %d\\n\", err);\n      return 1;\n    }\n\n  err = gl_sockets_cleanup ();\n  if (err != 0)\n    {\n      printf (\"wsacleanup failed %d\\n\", err);\n      return 1;\n    }\n\n  (void) gl_fd_to_handle (0);\n\n  return 0;\n}",
      "lines": 23,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-stat-time.c": {
    "force_unlink": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        41,
        1
      ],
      "content": "static int\nforce_unlink (const char *filename)\n{\n  /* This chmod is necessary on mingw, where unlink() of a read-only file\n     fails with EPERM.  */\n  chmod (filename, 0600);\n  return unlink (filename);\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cleanup": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "static void\ncleanup (int sig)\n{\n  /* Remove temporary files.  */\n  force_unlink (\"t-stt-stamp1\");\n  force_unlink (\"t-stt-testfile\");\n  force_unlink (\"t-stt-stamp2\");\n  force_unlink (\"t-stt-renamed\");\n  force_unlink (\"t-stt-stamp3\");\n\n  if (sig != 0)\n    _exit (1);\n}",
      "lines": 13,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "open_file": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "static int\nopen_file (const char *filename, int flags)\n{\n  int fd = open (filename, flags | O_WRONLY, 0500);\n  if (fd >= 0)\n    {\n      close (fd);\n      return 1;\n    }\n  else\n    {\n      return 0;\n    }\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "create_file": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "static void\ncreate_file (const char *filename)\n{\n  ASSERT (open_file (filename, O_CREAT | O_EXCL));\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "do_stat": {
      "start_point": [
        78,
        0
      ],
      "end_point": [
        82,
        1
      ],
      "content": "static void\ndo_stat (const char *filename, struct stat *p)\n{\n  ASSERT (stat (filename, p) == 0);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "prepare_test": {
      "start_point": [
        84,
        0
      ],
      "end_point": [
        109,
        1
      ],
      "content": "static void\nprepare_test (struct stat *statinfo, struct timespec *modtimes)\n{\n  int i;\n\n  create_file (\"t-stt-stamp1\");\n  nap ();\n  create_file (\"t-stt-testfile\");\n  nap ();\n  create_file (\"t-stt-stamp2\");\n  nap ();\n  ASSERT (chmod (\"t-stt-testfile\", 0400) == 0);\n  nap ();\n  create_file (\"t-stt-stamp3\");\n\n  do_stat (\"t-stt-stamp1\",  &statinfo[0]);\n  do_stat (\"t-stt-testfile\", &statinfo[1]);\n  do_stat (\"t-stt-stamp2\",  &statinfo[2]);\n  do_stat (\"t-stt-stamp3\",  &statinfo[3]);\n\n  /* Now use our access functions. */\n  for (i = 0; i < NFILES; ++i)\n    {\n      modtimes[i] = get_stat_mtime (&statinfo[i]);\n    }\n}",
      "lines": 26,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_mtime": {
      "start_point": [
        111,
        0
      ],
      "end_point": [
        145,
        1
      ],
      "content": "static void\ntest_mtime (const struct stat *statinfo, struct timespec *modtimes)\n{\n  int i;\n\n  /* Use the struct stat fields directly. */\n  /* mtime(stamp1) < mtime(stamp2) */\n  ASSERT (statinfo[0].st_mtime < statinfo[2].st_mtime\n          || (statinfo[0].st_mtime == statinfo[2].st_mtime\n              && (get_stat_mtime_ns (&statinfo[0])\n                  < get_stat_mtime_ns (&statinfo[2]))));\n  /* mtime(stamp2) < mtime(stamp3) */\n  ASSERT (statinfo[2].st_mtime < statinfo[3].st_mtime\n          || (statinfo[2].st_mtime == statinfo[3].st_mtime\n              && (get_stat_mtime_ns (&statinfo[2])\n                  < get_stat_mtime_ns (&statinfo[3]))));\n\n  /* Now check the result of the access functions. */\n  /* mtime(stamp1) < mtime(stamp2) */\n  ASSERT (modtimes[0].tv_sec < modtimes[2].tv_sec\n          || (modtimes[0].tv_sec == modtimes[2].tv_sec\n              && modtimes[0].tv_nsec < modtimes[2].tv_nsec));\n  /* mtime(stamp2) < mtime(stamp3) */\n  ASSERT (modtimes[2].tv_sec < modtimes[3].tv_sec\n          || (modtimes[2].tv_sec == modtimes[3].tv_sec\n              && modtimes[2].tv_nsec < modtimes[3].tv_nsec));\n\n  /* verify equivalence */\n  for (i = 0; i < NFILES; ++i)\n    {\n      struct timespec ts;\n      ts = get_stat_mtime (&statinfo[i]);\n      ASSERT (ts.tv_sec == statinfo[i].st_mtime);\n    }\n}",
      "lines": 35,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_ctime": {
      "start_point": [
        154,
        0
      ],
      "end_point": [
        167,
        1
      ],
      "content": "static void\ntest_ctime (const struct stat *statinfo)\n{\n  /* On some buggy NFS clients, mtime and ctime are disproportionately\n     skewed from one another.  Skip this test in that case.  */\n  if (statinfo[0].st_mtime != statinfo[0].st_ctime)\n    return;\n\n  /* mtime(stamp2) < ctime(renamed) */\n  ASSERT (statinfo[2].st_mtime < statinfo[1].st_ctime\n          || (statinfo[2].st_mtime == statinfo[1].st_ctime\n              && (get_stat_mtime_ns (&statinfo[2])\n                  < get_stat_ctime_ns (&statinfo[1]))));\n}",
      "lines": 14,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_birthtime": {
      "start_point": [
        170,
        0
      ],
      "end_point": [
        193,
        1
      ],
      "content": "static void\ntest_birthtime (const struct stat *statinfo,\n                const struct timespec *modtimes,\n                struct timespec *birthtimes)\n{\n  int i;\n\n  /* Collect the birth times.  */\n  for (i = 0; i < NFILES; ++i)\n    {\n      birthtimes[i] = get_stat_birthtime (&statinfo[i]);\n      if (birthtimes[i].tv_nsec < 0)\n        return;\n    }\n\n  /* mtime(stamp1) < birthtime(renamed) */\n  ASSERT (modtimes[0].tv_sec < birthtimes[1].tv_sec\n          || (modtimes[0].tv_sec == birthtimes[1].tv_sec\n              && modtimes[0].tv_nsec < birthtimes[1].tv_nsec));\n  /* birthtime(renamed) < mtime(stamp2) */\n  ASSERT (birthtimes[1].tv_sec < modtimes[2].tv_sec\n          || (birthtimes[1].tv_sec == modtimes[2].tv_sec\n              && birthtimes[1].tv_nsec < modtimes[2].tv_nsec));\n}",
      "lines": 24,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        195,
        0
      ],
      "end_point": [
        223,
        1
      ],
      "content": "int\nmain (void)\n{\n  struct stat statinfo[NFILES];\n  struct timespec modtimes[NFILES];\n  struct timespec birthtimes[NFILES];\n\n#ifdef SIGHUP\n  signal (SIGHUP, cleanup);\n#endif\n#ifdef SIGINT\n  signal (SIGINT, cleanup);\n#endif\n#ifdef SIGQUIT\n  signal (SIGQUIT, cleanup);\n#endif\n#ifdef SIGTERM\n  signal (SIGTERM, cleanup);\n#endif\n\n  cleanup (0);\n  prepare_test (statinfo, modtimes);\n  test_mtime (statinfo, modtimes);\n  test_ctime (statinfo);\n  test_birthtime (statinfo, modtimes, birthtimes);\n\n  cleanup (0);\n  return 0;\n}",
      "lines": 29,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-stat.c": {
    "do_stat": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "static int\ndo_stat (char const *name, struct stat *st)\n{\n  return stat (name, st);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "int\nmain (void)\n{\n  return test_stat_func (do_stat, true);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-stat.h": {
    "test_stat_func": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        99,
        1
      ],
      "content": "static int\ntest_stat_func (int (*func) (char const *, struct stat *), bool print)\n{\n  struct stat st1;\n  struct stat st2;\n  char *cwd = getcwd (NULL, 0);\n\n  ASSERT (cwd);\n  ASSERT (func (\".\", &st1) == 0);\n  ASSERT (func (\"./\", &st2) == 0);\n  ASSERT (SAME_INODE (st1, st2));\n  ASSERT (func (cwd, &st2) == 0);\n  ASSERT (SAME_INODE (st1, st2));\n  ASSERT (func (\"/\", &st1) == 0);\n  ASSERT (func (\"///\", &st2) == 0);\n  ASSERT (SAME_INODE (st1, st2));\n\n  errno = 0;\n  ASSERT (func (\"\", &st1) == -1);\n  ASSERT (errno == ENOENT);\n  errno = 0;\n  ASSERT (func (\"nosuch\", &st1) == -1);\n  ASSERT (errno == ENOENT);\n  errno = 0;\n  ASSERT (func (\"nosuch/\", &st1) == -1);\n  ASSERT (errno == ENOENT);\n\n  ASSERT (close (creat (BASE \"file\", 0600)) == 0);\n  ASSERT (func (BASE \"file\", &st1) == 0);\n  errno = 0;\n  ASSERT (func (BASE \"file/\", &st1) == -1);\n  ASSERT (errno == ENOTDIR);\n\n  /* Now for some symlink tests, where supported.  We set up:\n     link1 -> directory\n     link2 -> file\n     link3 -> dangling\n     link4 -> loop\n     then test behavior with trailing slash.\n  */\n  if (symlink (\".\", BASE \"link1\") != 0)\n    {\n      ASSERT (unlink (BASE \"file\") == 0);\n      if (print)\n        fputs (\"skipping test: symlinks not supported on this file system\\n\",\n               stderr);\n      return 77;\n    }\n  ASSERT (symlink (BASE \"file\", BASE \"link2\") == 0);\n  ASSERT (symlink (BASE \"nosuch\", BASE \"link3\") == 0);\n  ASSERT (symlink (BASE \"link4\", BASE \"link4\") == 0);\n\n  ASSERT (func (BASE \"link1/\", &st1) == 0);\n  ASSERT (S_ISDIR (st1.st_mode));\n\n  errno = 0;\n  ASSERT (func (BASE \"link2/\", &st1) == -1);\n  ASSERT (errno == ENOTDIR);\n\n  errno = 0;\n  ASSERT (func (BASE \"link3/\", &st1) == -1);\n  ASSERT (errno == ENOENT);\n\n  errno = 0;\n  ASSERT (func (BASE \"link4/\", &st1) == -1);\n  ASSERT (errno == ELOOP);\n\n  /* Cleanup.  */\n  ASSERT (unlink (BASE \"file\") == 0);\n  ASSERT (unlink (BASE \"link1\") == 0);\n  ASSERT (unlink (BASE \"link2\") == 0);\n  ASSERT (unlink (BASE \"link3\") == 0);\n  ASSERT (unlink (BASE \"link4\") == 0);\n\n  return 0;\n}",
      "lines": 76,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-statat.c": {},
  "findutils/findutils-4.6.0/tests/test-stdalign.c": {
    "main": {
      "start_point": [
        79,
        0
      ],
      "end_point": [
        115,
        1
      ],
      "content": "int\nmain ()\n{\n#if defined __SUNPRO_C\n  /* Avoid a test failure due to Sun Studio Developer Bug Report #2125432.  */\n  fputs (\"Skipping test: known Sun C compiler bug\\n\", stderr);\n  return 77;\n#else\n  CHECK_ALIGNED (static_char_alignas);\n  CHECK_ALIGNED (static_char_Alignas);\n  CHECK_ALIGNED (static_short_alignas);\n  CHECK_ALIGNED (static_short_Alignas);\n  CHECK_ALIGNED (static_int_alignas);\n  CHECK_ALIGNED (static_int_Alignas);\n  CHECK_ALIGNED (static_long_alignas);\n  CHECK_ALIGNED (static_long_Alignas);\n# ifdef INT64_MAX\n  CHECK_ALIGNED (static_int64_t_alignas);\n  CHECK_ALIGNED (static_int64_t_Alignas);\n# endif\n  CHECK_ALIGNED (static_float_alignas);\n  CHECK_ALIGNED (static_float_Alignas);\n  CHECK_ALIGNED (static_double_alignas);\n  CHECK_ALIGNED (static_double_Alignas);\n  /* CHECK_ALIGNED (static_longdouble_alignas); */\n  /* CHECK_ALIGNED (static_longdouble_Alignas); */\n  CHECK_ALIGNED (static_struct1_alignas);\n  CHECK_ALIGNED (static_struct1_Alignas);\n  CHECK_ALIGNED (static_struct2_alignas);\n  CHECK_ALIGNED (static_struct2_Alignas);\n  CHECK_ALIGNED (static_struct3_alignas);\n  CHECK_ALIGNED (static_struct3_Alignas);\n  CHECK_ALIGNED (static_struct4_alignas);\n  CHECK_ALIGNED (static_struct4_Alignas);\n  return 0;\n#endif\n}",
      "lines": 37,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-stdbool.c": {
    "main": {
      "start_point": [
        89,
        0
      ],
      "end_point": [
        117,
        1
      ],
      "content": "int\nmain ()\n{\n  int error = 0;\n\n#if HAVE_STDBOOL_H || 3 <= __GNUC__ /* See above.  */\n# ifdef ADDRESS_CHECK_OKAY /* Avoid gcc warning.  */\n  /* A cast from a variable's address to bool is valid in expressions.  */\n  {\n    bool e1 = &s;\n    if (!e1)\n      error = 1;\n  }\n# endif\n#endif\n\n  /* Catch a bug in IBM AIX xlc compiler version 6.0.0.0\n     reported by James Lemley on 2005-10-05; see\n     http://lists.gnu.org/archive/html/bug-coreutils/2005-10/msg00086.html\n     This is a runtime test, since a corresponding compile-time\n     test would rely on initializer extensions.  */\n  {\n    char digs[] = \"0123456789\";\n    if (&(digs + 5)[-2 + (bool) 1] != &digs[4])\n      error = 1;\n  }\n\n  return error;\n}",
      "lines": 29,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-stddef.c": {
    "main": {
      "start_point": [
        68,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "int\nmain (void)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-stdint.c": {
    "main": {
      "start_point": [
        354,
        0
      ],
      "end_point": [
        358,
        1
      ],
      "content": "int\nmain (void)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-stdio.c": {
    "main": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        42,
        1
      ],
      "content": "int\nmain (void)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-stdlib.c": {
    "main": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "int\nmain (void)\n{\n  if (test_sys_wait_macros ())\n    return 1;\n\n  return exitcode;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-strcasestr.c": {
    "main": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        254,
        1
      ],
      "content": "int\nmain ()\n{\n#if HAVE_DECL_ALARM\n  /* Declare failure if test takes too long, by using default abort\n     caused by SIGALRM.  All known platforms that lack alarm also lack\n     strcasestr, and the replacement strcasestr is known to not take too\n     long.  */\n  int alarm_value = 50;\n  signal (SIGALRM, SIG_DFL);\n  alarm (alarm_value);\n#endif\n\n  {\n    const char input[] = \"foo\";\n    const char *result = strcasestr (input, \"\");\n    ASSERT (result == input);\n  }\n\n  {\n    const char input[] = \"foo\";\n    const char *result = strcasestr (input, \"O\");\n    ASSERT (result == input + 1);\n  }\n\n  {\n    const char input[] = \"ABC ABCDAB ABCDABCDABDE\";\n    const char *result = strcasestr (input, \"ABCDaBD\");\n    ASSERT (result == input + 15);\n  }\n\n  {\n    const char input[] = \"ABC ABCDAB ABCDABCDABDE\";\n    const char *result = strcasestr (input, \"ABCDaBE\");\n    ASSERT (result == NULL);\n  }\n\n  {\n    const char input[] = \"ABC ABCDAB ABCDABCDABDE\";\n    const char *result = strcasestr (input, \"ABCDaBCD\");\n    ASSERT (result == input + 11);\n  }\n\n  /* Check that a long periodic needle does not cause false positives.  */\n  {\n    const char input[] = (\"F_BD_CE_BD_EF_BF_BD_EF_BF_BD_EF_BF_BD_EF_BF_BD\"\n                          \"_C3_88_20_EF_BF_BD_EF_BF_BD_EF_BF_BD\"\n                          \"_C3_A7_20_EF_BF_BD\");\n    const char need[] = \"_EF_BF_BD_EF_BF_BD_EF_BF_BD_EF_BF_BD_EF_BF_BD\";\n    const char *result = strcasestr (input, need);\n    ASSERT (result == NULL);\n  }\n  {\n    const char input[] = (\"F_BD_CE_BD_EF_BF_BD_EF_BF_BD_EF_BF_BD_EF_BF_BD\"\n                          \"_C3_88_20_EF_BF_BD_EF_BF_BD_EF_BF_BD\"\n                          \"_C3_A7_20_EF_BF_BD_DA_B5_C2_A6_20\"\n                          \"_EF_BF_BD_EF_BF_BD_EF_BF_BD_EF_BF_BD_EF_BF_BD\");\n    const char need[] = \"_EF_BF_BD_EF_BF_BD_EF_BF_BD_EF_BF_BD_EF_BF_BD\";\n    const char *result = strcasestr (input, need);\n    ASSERT (result == input + 115);\n  }\n\n  /* Check that a very long haystack is handled quickly if the needle is\n     short and occurs near the beginning.  */\n  {\n    size_t repeat = 10000;\n    size_t m = 1000000;\n    const char *needle =\n      \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaAaaaaaaAAAAaaaaaaa\"\n      \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\";\n    char *haystack = (char *) malloc (m + 1);\n    if (haystack != NULL)\n      {\n        memset (haystack, 'A', m);\n        haystack[0] = 'B';\n        haystack[m] = '\\0';\n\n        for (; repeat > 0; repeat--)\n          {\n            ASSERT (strcasestr (haystack, needle) == haystack + 1);\n          }\n\n        free (haystack);\n      }\n  }\n\n  /* Check that a very long needle is discarded quickly if the haystack is\n     short.  */\n  {\n    size_t repeat = 10000;\n    size_t m = 1000000;\n    const char *haystack =\n      \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n      \"ABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABAB\";\n    char *needle = (char *) malloc (m + 1);\n    if (needle != NULL)\n      {\n        memset (needle, 'A', m);\n        needle[m] = '\\0';\n\n        for (; repeat > 0; repeat--)\n          {\n            ASSERT (strcasestr (haystack, needle) == NULL);\n          }\n\n        free (needle);\n      }\n  }\n\n  /* Check that the asymptotic worst-case complexity is not quadratic.  */\n  {\n    size_t m = 1000000;\n    char *haystack = (char *) malloc (2 * m + 2);\n    char *needle = (char *) malloc (m + 2);\n    if (haystack != NULL && needle != NULL)\n      {\n        const char *result;\n\n        memset (haystack, 'A', 2 * m);\n        haystack[2 * m] = 'B';\n        haystack[2 * m + 1] = '\\0';\n\n        memset (needle, 'a', m);\n        needle[m] = 'B';\n        needle[m + 1] = '\\0';\n\n        result = strcasestr (haystack, needle);\n        ASSERT (result == haystack + m);\n      }\n    free (needle);\n    free (haystack);\n  }\n\n  {\n    /* Ensure that with a barely periodic \"short\" needle, strcasestr's\n       search does not mistakenly skip just past the match point.\n       This use of strcasestr would mistakenly return NULL before\n       gnulib v0.0-4927.  */\n    const char *haystack =\n      \"\\n\"\n      \"with_build_libsubdir\\n\"\n      \"with_local_prefix\\n\"\n      \"with_gxx_include_dir\\n\"\n      \"with_cpp_install_dir\\n\"\n      \"enable_generated_files_in_srcdir\\n\"\n      \"with_gnu_ld\\n\"\n      \"with_ld\\n\"\n      \"with_demangler_in_ld\\n\"\n      \"with_gnu_as\\n\"\n      \"with_as\\n\"\n      \"enable_largefile\\n\"\n      \"enable_werror_always\\n\"\n      \"enable_checking\\n\"\n      \"enable_coverage\\n\"\n      \"enable_gather_detailed_mem_stats\\n\"\n      \"enable_build_with_cxx\\n\"\n      \"with_stabs\\n\"\n      \"enable_multilib\\n\"\n      \"enable___cxa_atexit\\n\"\n      \"enable_decimal_float\\n\"\n      \"enable_fixed_point\\n\"\n      \"enable_threads\\n\"\n      \"enable_tls\\n\"\n      \"enable_objc_gc\\n\"\n      \"with_dwarf2\\n\"\n      \"enable_shared\\n\"\n      \"with_build_sysroot\\n\"\n      \"with_sysroot\\n\"\n      \"with_specs\\n\"\n      \"with_pkgversion\\n\"\n      \"with_bugurl\\n\"\n      \"enable_languages\\n\"\n      \"with_multilib_list\\n\";\n    const char *needle = \"\\n\"\n      \"with_GNU_ld\\n\";\n    const char* p = strcasestr (haystack, needle);\n    ASSERT (p - haystack == 114);\n  }\n\n  {\n    /* Same bug, shorter trigger.  */\n    const char *haystack = \"..wi.D.\";\n    const char *needle = \".d.\";\n    const char* p = strcasestr (haystack, needle);\n    ASSERT (p - haystack == 4);\n  }\n\n  {\n    /* Like the above, but trigger the flaw in two_way_long_needle\n       by using a needle of length LONG_NEEDLE_THRESHOLD (32) or greater.\n       Rather than trying to find the right alignment manually, I've\n       arbitrarily chosen the following needle and template for the\n       haystack, and ensure that for each placement of the needle in\n       that haystack, strcasestr finds it.  */\n    const char *needle = \"\\nwith_gnu_ld-extend-to-len-32-b\\n\";\n    const char *h =\n      \"\\n\"\n      \"with_build_libsubdir\\n\"\n      \"with_local_prefix\\n\"\n      \"with_gxx_include_dir\\n\"\n      \"with_cpp_install_dir\\n\"\n      \"with_e_\\n\"\n      \"..............................\\n\"\n      \"with_FGHIJKLMNOPQRSTUVWXYZ\\n\"\n      \"with_567890123456789\\n\"\n      \"with_multilib_list\\n\";\n    size_t h_len = strlen (h);\n    char *haystack = malloc (h_len + 1);\n    size_t i;\n    ASSERT (haystack);\n    for (i = 0; i < h_len - strlen (needle); i++)\n      {\n        const char *p;\n        memcpy (haystack, h, h_len + 1);\n        memcpy (haystack + i, needle, strlen (needle) + 1);\n        p = strcasestr (haystack, needle);\n        ASSERT (p);\n        ASSERT (p - haystack == i);\n      }\n  }\n\n  return 0;\n}",
      "lines": 224,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-strerror.c": {
    "main": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "int\nmain (void)\n{\n  char *str;\n\n  errno = 0;\n  str = strerror (EACCES);\n  ASSERT (str);\n  ASSERT (*str);\n  ASSERT (errno == 0);\n\n  errno = 0;\n  str = strerror (ETIMEDOUT);\n  ASSERT (str);\n  ASSERT (*str);\n  ASSERT (errno == 0);\n\n  errno = 0;\n  str = strerror (EOVERFLOW);\n  ASSERT (str);\n  ASSERT (*str);\n  ASSERT (errno == 0);\n\n  /* POSIX requires strerror (0) to succeed.  Reject use of \"Unknown\n     error\", but allow \"Success\", \"No error\", or even Solaris' \"Error\n     0\" which are distinct patterns from true out-of-range strings.\n     http://austingroupbugs.net/view.php?id=382  */\n  errno = 0;\n  str = strerror (0);\n  ASSERT (str);\n  ASSERT (*str);\n  ASSERT (errno == 0);\n  ASSERT (strstr (str, \"nknown\") == NULL);\n  ASSERT (strstr (str, \"ndefined\") == NULL);\n\n  /* POSIX requires strerror to produce a non-NULL result for all\n     inputs; as an extension, we also guarantee a non-empty result.\n     Reporting EINVAL is optional.  */\n  errno = 0;\n  str = strerror (-3);\n  ASSERT (str);\n  ASSERT (*str);\n  ASSERT (errno == 0 || errno == EINVAL);\n\n  return 0;\n}",
      "lines": 46,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-strerror_r.c": {
    "main": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        180,
        1
      ],
      "content": "int\nmain (void)\n{\n  char buf[100];\n  int ret;\n\n  /* Test results with valid errnum and enough room.  */\n\n  errno = 0;\n  buf[0] = '\\0';\n  ASSERT (strerror_r (EACCES, buf, sizeof buf) == 0);\n  ASSERT (buf[0] != '\\0');\n  ASSERT (errno == 0);\n  ASSERT (strlen (buf) < sizeof buf);\n\n  errno = 0;\n  buf[0] = '\\0';\n  ASSERT (strerror_r (ETIMEDOUT, buf, sizeof buf) == 0);\n  ASSERT (buf[0] != '\\0');\n  ASSERT (errno == 0);\n  ASSERT (strlen (buf) < sizeof buf);\n\n  errno = 0;\n  buf[0] = '\\0';\n  ASSERT (strerror_r (EOVERFLOW, buf, sizeof buf) == 0);\n  ASSERT (buf[0] != '\\0');\n  ASSERT (errno == 0);\n  ASSERT (strlen (buf) < sizeof buf);\n\n  /* POSIX requires strerror (0) to succeed.  Reject use of \"Unknown\n     error\", but allow \"Success\", \"No error\", or even Solaris' \"Error\n     0\" which are distinct patterns from true out-of-range strings.\n     http://austingroupbugs.net/view.php?id=382  */\n  errno = 0;\n  buf[0] = '\\0';\n  ret = strerror_r (0, buf, sizeof buf);\n  ASSERT (ret == 0);\n  ASSERT (buf[0]);\n  ASSERT (errno == 0);\n  ASSERT (strstr (buf, \"nknown\") == NULL);\n  ASSERT (strstr (buf, \"ndefined\") == NULL);\n\n  /* Test results with out-of-range errnum and enough room.  POSIX\n     allows an empty string on success, and allows an unchanged buf on\n     error, but these are not useful, so we guarantee contents.  */\n  errno = 0;\n  buf[0] = '^';\n  ret = strerror_r (-3, buf, sizeof buf);\n  ASSERT (ret == 0 || ret == EINVAL);\n  ASSERT (buf[0] != '^');\n  ASSERT (*buf);\n  ASSERT (errno == 0);\n  ASSERT (strlen (buf) < sizeof buf);\n\n  /* Test results with a too small buffer.  POSIX requires an error;\n     only ERANGE for 0 and valid errors, and a choice of ERANGE or\n     EINVAL for out-of-range values.  On error, POSIX permits buf to\n     be empty, unchanged, or unterminated, but these are not useful,\n     so we guarantee NUL-terminated truncated contents for all but\n     size 0.  http://austingroupbugs.net/view.php?id=398.  Also ensure\n     that no out-of-bounds writes occur.  */\n  {\n    int errs[] = { EACCES, 0, -3, };\n    int j;\n\n    buf[sizeof buf - 1] = '\\0';\n    for (j = 0; j < SIZEOF (errs); j++)\n      {\n        int err = errs[j];\n        char buf2[sizeof buf] = \"\";\n        size_t len;\n        size_t i;\n\n        strerror_r (err, buf2, sizeof buf2);\n        len = strlen (buf2);\n        ASSERT (len < sizeof buf);\n\n        for (i = 0; i <= len; i++)\n          {\n            memset (buf, '^', sizeof buf - 1);\n            errno = 0;\n            ret = strerror_r (err, buf, i);\n            ASSERT (errno == 0);\n            if (err < 0)\n              ASSERT (ret == ERANGE || ret == EINVAL);\n            else\n              ASSERT (ret == ERANGE);\n            if (i)\n              {\n                ASSERT (strncmp (buf, buf2, i - 1) == 0);\n                ASSERT (buf[i - 1] == '\\0');\n              }\n            ASSERT (strspn (buf + i, \"^\") == sizeof buf - 1 - i);\n          }\n\n        strcpy (buf, \"BADFACE\");\n        errno = 0;\n        ret = strerror_r (err, buf, len + 1);\n        ASSERT (ret != ERANGE);\n        ASSERT (errno == 0);\n        ASSERT (strcmp (buf, buf2) == 0);\n      }\n  }\n\n#if GNULIB_STRERROR\n  /* Test that strerror_r does not clobber strerror buffer.  On some\n     platforms, this test can only succeed if gnulib also replaces\n     strerror.  */\n  {\n    const char *msg1;\n    const char *msg2;\n    const char *msg3;\n    const char *msg4;\n    char *str1;\n    char *str2;\n    char *str3;\n    char *str4;\n\n    msg1 = strerror (ENOENT);\n    ASSERT (msg1);\n    str1 = strdup (msg1);\n    ASSERT (str1);\n\n    msg2 = strerror (ERANGE);\n    ASSERT (msg2);\n    str2 = strdup (msg2);\n    ASSERT (str2);\n\n    msg3 = strerror (-4);\n    ASSERT (msg3);\n    str3 = strdup (msg3);\n    ASSERT (str3);\n\n    msg4 = strerror (1729576);\n    ASSERT (msg4);\n    str4 = strdup (msg4);\n    ASSERT (str4);\n\n    strerror_r (EACCES, buf, sizeof buf);\n    strerror_r (-5, buf, sizeof buf);\n    ASSERT (msg1 == msg2 || msg1 == msg4 || STREQ (msg1, str1));\n    ASSERT (msg2 == msg4 || STREQ (msg2, str2));\n    ASSERT (msg3 == msg4 || STREQ (msg3, str3));\n    ASSERT (STREQ (msg4, str4));\n\n    free (str1);\n    free (str2);\n    free (str3);\n    free (str4);\n  }\n#endif\n\n  return 0;\n}",
      "lines": 154,
      "depth": 17,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-strftime.c": {
    "posixtm_test": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "static int\nposixtm_test (void)\n{\n  int fail = 0;\n  unsigned int i;\n\n  for (i = 0; T[i].fmt; i++)\n    {\n      char buf[1000];\n      time_t t = T[i].in;\n      struct tm *tm = gmtime (&t);\n      size_t n;\n\n      ASSERT (tm);\n\n      n = nstrftime (buf, sizeof buf, T[i].fmt, tm, 0, T[i].in_ns);\n      if (n == 0)\n        {\n          fail = 1;\n          printf (\"nstrftime failed with format %s\\n\", T[i].fmt);\n        }\n\n      if (! STREQ (buf, T[i].exp))\n        {\n          fail = 1;\n          printf (\"%s: result mismatch: got %s, expected %s\\n\",\n                  T[i].fmt, buf, T[i].exp);\n        }\n    }\n\n  return fail;\n}",
      "lines": 32,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "tzalloc_test": {
      "start_point": [
        136,
        0
      ],
      "end_point": [
        195,
        1
      ],
      "content": "static int\ntzalloc_test (void)\n{\n  int fail = 0;\n  int i;\n\n  for (i = 0; LT[i].tza; i++)\n    {\n      struct tzalloc_test *tza = LT[i].tza;\n      long lt = LT[i].t;\n      timezone_t tz = tza->tz;\n      char const *setting;\n      static char const format[] = \"%Y-%m-%d %H:%M:%S %z (%Z)\";\n      char buf[1000];\n      struct tm tm;\n      size_t n;\n\n      if (!tz && tza->setting)\n        {\n          tz = tzalloc (tza->setting);\n          if (!tz)\n            {\n              fail = 1;\n              printf (\"%s: tzalloc: %s\\n\", TZ[i].setting, strerror (errno));\n              continue;\n            }\n          tza->tz = tz;\n        }\n\n      setting = tza->setting ? tza->setting : \"UTC\";\n\n      if (!localtime_rz (tz, &LT[i].t, &tm))\n        {\n          fail = 1;\n          printf (\"%s: %ld: localtime_rz: %s\\n\", setting, lt,\n                  strerror (errno));\n          continue;\n        }\n\n      n = nstrftime (buf, sizeof buf, format, &tm, tz, 0);\n      if (n == 0)\n        {\n          fail = 1;\n          printf (\"%s: %ld: nstrftime failed\\n\", setting, lt);\n          continue;\n        }\n\n      if (! (STREQ (buf, LT[i].exp)\n             || (!tz && n == strlen (LT[i].exp)\n                 && memcmp (buf, LT[i].exp, n - sizeof \"(GMT)\" + 1) == 0\n                 && STREQ (buf + n - sizeof \"(GMT)\" + 1, \"(GMT)\"))))\n        {\n          fail = 1;\n          printf (\"%s: expected \\\"%s\\\", got \\\"%s\\\"\\n\",\n                  setting, LT[i].exp, buf);\n        }\n    }\n\n  return fail;\n}",
      "lines": 60,
      "depth": 20,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        197,
        0
      ],
      "end_point": [
        204,
        1
      ],
      "content": "int\nmain (void)\n{\n  int fail = 0;\n  fail |= posixtm_test ();\n  fail |= tzalloc_test ();\n  return fail;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-string.c": {
    "main": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        32,
        1
      ],
      "content": "int\nmain (void)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-strings.c": {
    "main": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        26,
        1
      ],
      "content": "int\nmain ()\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 4,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-strnlen.c": {
    "main": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "int\nmain (void)\n{\n  size_t i;\n  char *page_boundary = (char *) zerosize_ptr ();\n  if (!page_boundary)\n    {\n      page_boundary = malloc (0x1000);\n      ASSERT (page_boundary);\n      page_boundary += 0x1000;\n    }\n\n  /* Basic behavior tests.  */\n  ASSERT (strnlen (\"a\", 0) == 0);\n  ASSERT (strnlen (\"a\", 1) == 1);\n  ASSERT (strnlen (\"a\", 2) == 1);\n  ASSERT (strnlen (\"\", 0x100000) == 0);\n\n  /* Memory fence and alignment testing.  */\n  for (i = 0; i < 512; i++)\n    {\n      char *start = page_boundary - i;\n      size_t j = i;\n      memset (start, 'x', i);\n      do\n        {\n          if (i != j)\n            {\n              start[j] = 0;\n              ASSERT (strnlen (start, i + j) == j);\n            }\n          ASSERT (strnlen (start, i) == j);\n          ASSERT (strnlen (start, j) == j);\n        }\n      while (j--);\n    }\n\n  return 0;\n}",
      "lines": 39,
      "depth": 16,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-strstr.c": {
    "main": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        278,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n#if HAVE_DECL_ALARM\n  /* Declare failure if test takes too long, by using default abort\n     caused by SIGALRM.  All known platforms that lack alarm also have\n     a quadratic strstr, and the replacement strstr is known to not\n     take too long.  */\n  int alarm_value = 50;\n  signal (SIGALRM, SIG_DFL);\n  alarm (alarm_value);\n#endif\n\n  {\n    const char input[] = \"foo\";\n    const char *result = strstr (input, \"\");\n    ASSERT (result == input);\n  }\n\n  {\n    const char input[] = \"foo\";\n    const char *result = strstr (input, \"o\");\n    ASSERT (result == input + 1);\n  }\n\n  {\n    /* On some platforms, the memchr() functions reads past the first\n       occurrence of the byte to be searched, leading to an out-of-bounds\n       read access for strstr().\n       See <http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=521737>.\n       This is a bug in memchr(), see the Austin Group's clarification\n       <http://www.opengroup.org/austin/docs/austin_454.txt>.  */\n    const char *fix = \"aBaaaaaaaaaaax\";\n    char *page_boundary = (char *) zerosize_ptr ();\n    size_t len = strlen (fix) + 1;\n    char *input = page_boundary ? page_boundary - len : malloc (len);\n    const char *result;\n\n    strcpy (input, fix);\n    result = strstr (input, \"B1x\");\n    ASSERT (result == NULL);\n    if (!page_boundary)\n      free (input);\n  }\n\n  {\n    const char input[] = \"ABC ABCDAB ABCDABCDABDE\";\n    const char *result = strstr (input, \"ABCDABD\");\n    ASSERT (result == input + 15);\n  }\n\n  {\n    const char input[] = \"ABC ABCDAB ABCDABCDABDE\";\n    const char *result = strstr (input, \"ABCDABE\");\n    ASSERT (result == NULL);\n  }\n\n  {\n    const char input[] = \"ABC ABCDAB ABCDABCDABDE\";\n    const char *result = strstr (input, \"ABCDABCD\");\n    ASSERT (result == input + 11);\n  }\n\n  /* Check that a long periodic needle does not cause false positives.  */\n  {\n    const char input[] = \"F_BD_CE_BD_EF_BF_BD_EF_BF_BD_EF_BF_BD_EF_BF_BD\"\n                         \"_C3_88_20_EF_BF_BD_EF_BF_BD_EF_BF_BD\"\n                         \"_C3_A7_20_EF_BF_BD\";\n    const char need[] = \"_EF_BF_BD_EF_BF_BD_EF_BF_BD_EF_BF_BD_EF_BF_BD\";\n    const char *result = strstr (input, need);\n    ASSERT (result == NULL);\n  }\n  {\n    const char input[] = \"F_BD_CE_BD_EF_BF_BD_EF_BF_BD_EF_BF_BD_EF_BF_BD\"\n                         \"_C3_88_20_EF_BF_BD_EF_BF_BD_EF_BF_BD\"\n                         \"_C3_A7_20_EF_BF_BD_DA_B5_C2_A6_20\"\n                         \"_EF_BF_BD_EF_BF_BD_EF_BF_BD_EF_BF_BD_EF_BF_BD\";\n    const char need[] = \"_EF_BF_BD_EF_BF_BD_EF_BF_BD_EF_BF_BD_EF_BF_BD\";\n    const char *result = strstr (input, need);\n    ASSERT (result == input + 115);\n  }\n\n  /* Check that a very long haystack is handled quickly if the needle is\n     short and occurs near the beginning.  */\n  {\n    size_t repeat = 10000;\n    size_t m = 1000000;\n    const char *needle =\n      \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n      \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\";\n    char *haystack = (char *) malloc (m + 1);\n    if (haystack != NULL)\n      {\n        memset (haystack, 'A', m);\n        haystack[0] = 'B';\n        haystack[m] = '\\0';\n\n        for (; repeat > 0; repeat--)\n          {\n            ASSERT (strstr (haystack, needle) == haystack + 1);\n          }\n\n        free (haystack);\n      }\n  }\n\n  /* Check that a very long needle is discarded quickly if the haystack is\n     short.  */\n  {\n    size_t repeat = 10000;\n    size_t m = 1000000;\n    const char *haystack =\n      \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n      \"ABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABAB\";\n    char *needle = (char *) malloc (m + 1);\n    if (needle != NULL)\n      {\n        memset (needle, 'A', m);\n        needle[m] = '\\0';\n\n        for (; repeat > 0; repeat--)\n          {\n            ASSERT (strstr (haystack, needle) == NULL);\n          }\n\n        free (needle);\n      }\n  }\n\n  /* Check that the asymptotic worst-case complexity is not quadratic.  */\n  {\n    size_t m = 1000000;\n    char *haystack = (char *) malloc (2 * m + 2);\n    char *needle = (char *) malloc (m + 2);\n    if (haystack != NULL && needle != NULL)\n      {\n        const char *result;\n\n        memset (haystack, 'A', 2 * m);\n        haystack[2 * m] = 'B';\n        haystack[2 * m + 1] = '\\0';\n\n        memset (needle, 'A', m);\n        needle[m] = 'B';\n        needle[m + 1] = '\\0';\n\n        result = strstr (haystack, needle);\n        ASSERT (result == haystack + m);\n      }\n    free (needle);\n    free (haystack);\n  }\n\n  /* Sublinear speed is only possible in memmem; strstr must examine\n     every character of haystack to find its length.  */\n\n\n  {\n    /* Ensure that with a barely periodic \"short\" needle, strstr's\n       search does not mistakenly skip just past the match point.\n       This use of strstr would mistakenly return NULL before\n       gnulib v0.0-4927.  */\n    const char *haystack =\n      \"\\n\"\n      \"with_build_libsubdir\\n\"\n      \"with_local_prefix\\n\"\n      \"with_gxx_include_dir\\n\"\n      \"with_cpp_install_dir\\n\"\n      \"enable_generated_files_in_srcdir\\n\"\n      \"with_gnu_ld\\n\"\n      \"with_ld\\n\"\n      \"with_demangler_in_ld\\n\"\n      \"with_gnu_as\\n\"\n      \"with_as\\n\"\n      \"enable_largefile\\n\"\n      \"enable_werror_always\\n\"\n      \"enable_checking\\n\"\n      \"enable_coverage\\n\"\n      \"enable_gather_detailed_mem_stats\\n\"\n      \"enable_build_with_cxx\\n\"\n      \"with_stabs\\n\"\n      \"enable_multilib\\n\"\n      \"enable___cxa_atexit\\n\"\n      \"enable_decimal_float\\n\"\n      \"enable_fixed_point\\n\"\n      \"enable_threads\\n\"\n      \"enable_tls\\n\"\n      \"enable_objc_gc\\n\"\n      \"with_dwarf2\\n\"\n      \"enable_shared\\n\"\n      \"with_build_sysroot\\n\"\n      \"with_sysroot\\n\"\n      \"with_specs\\n\"\n      \"with_pkgversion\\n\"\n      \"with_bugurl\\n\"\n      \"enable_languages\\n\"\n      \"with_multilib_list\\n\";\n    const char *needle = \"\\n\"\n      \"with_gnu_ld\\n\";\n    const char* p = strstr (haystack, needle);\n    ASSERT (p - haystack == 114);\n  }\n\n  {\n    /* Same bug, shorter trigger.  */\n    const char *haystack = \"..wi.d.\";\n    const char *needle = \".d.\";\n    const char* p = strstr (haystack, needle);\n    ASSERT (p - haystack == 4);\n  }\n\n  {\n    /* Like the above, but trigger the flaw in two_way_long_needle\n       by using a needle of length LONG_NEEDLE_THRESHOLD (32) or greater.\n       Rather than trying to find the right alignment manually, I've\n       arbitrarily chosen the following needle and template for the\n       haystack, and ensure that for each placement of the needle in\n       that haystack, strstr finds it.  */\n    const char *needle = \"\\nwith_gnu_ld-extend-to-len-32-b\\n\";\n    const char *h =\n      \"\\n\"\n      \"with_build_libsubdir\\n\"\n      \"with_local_prefix\\n\"\n      \"with_gxx_include_dir\\n\"\n      \"with_cpp_install_dir\\n\"\n      \"with_e_\\n\"\n      \"..............................\\n\"\n      \"with_FGHIJKLMNOPQRSTUVWXYZ\\n\"\n      \"with_567890123456789\\n\"\n      \"with_multilib_list\\n\";\n    size_t h_len = strlen (h);\n    char *haystack = malloc (h_len + 1);\n    size_t i;\n    ASSERT (haystack);\n    for (i = 0; i < h_len - strlen (needle); i++)\n      {\n        const char *p;\n        memcpy (haystack, h, h_len + 1);\n        memcpy (haystack + i, needle, strlen (needle) + 1);\n        p = strstr (haystack, needle);\n        ASSERT (p);\n        ASSERT (p - haystack == i);\n      }\n    free (haystack);\n  }\n\n  return 0;\n}",
      "lines": 248,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-strtoull.c": {
    "main": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        179,
        1
      ],
      "content": "int\nmain (void)\n{\n  /* Subject sequence empty or invalid.  */\n  {\n    const char input[] = \"\";\n    char *ptr;\n    unsigned long long result;\n    errno = 0;\n    result = strtoull (input, &ptr, 10);\n    ASSERT (result == 0);\n    ASSERT (ptr == input);\n    ASSERT (errno == 0 || errno == EINVAL);\n  }\n  {\n    const char input[] = \" \";\n    char *ptr;\n    unsigned long long result;\n    errno = 0;\n    result = strtoull (input, &ptr, 10);\n    ASSERT (result == 0);\n    ASSERT (ptr == input);\n    ASSERT (errno == 0 || errno == EINVAL);\n  }\n  {\n    const char input[] = \" +\";\n    char *ptr;\n    unsigned long long result;\n    errno = 0;\n    result = strtoull (input, &ptr, 10);\n    ASSERT (result == 0);\n    ASSERT (ptr == input);\n    ASSERT (errno == 0 || errno == EINVAL);\n  }\n  {\n    const char input[] = \" -\";\n    char *ptr;\n    unsigned long long result;\n    errno = 0;\n    result = strtoull (input, &ptr, 10);\n    ASSERT (result == 0);\n    ASSERT (ptr == input);\n    ASSERT (errno == 0 || errno == EINVAL);\n  }\n\n  /* Simple integer values.  */\n  {\n    const char input[] = \"0\";\n    char *ptr;\n    unsigned long long result;\n    errno = 0;\n    result = strtoull (input, &ptr, 10);\n    ASSERT (result == 0);\n    ASSERT (ptr == input + 1);\n    ASSERT (errno == 0);\n  }\n  {\n    const char input[] = \"+0\";\n    char *ptr;\n    unsigned long long result;\n    errno = 0;\n    result = strtoull (input, &ptr, 10);\n    ASSERT (result == 0);\n    ASSERT (ptr == input + 2);\n    ASSERT (errno == 0);\n  }\n  {\n    const char input[] = \"-0\";\n    char *ptr;\n    unsigned long long result;\n    errno = 0;\n    result = strtoull (input, &ptr, 10);\n    ASSERT (result == 0);\n    ASSERT (ptr == input + 2);\n    ASSERT (errno == 0);\n  }\n  {\n    const char input[] = \"23\";\n    char *ptr;\n    unsigned long long result;\n    errno = 0;\n    result = strtoull (input, &ptr, 10);\n    ASSERT (result == 23);\n    ASSERT (ptr == input + 2);\n    ASSERT (errno == 0);\n  }\n  {\n    const char input[] = \" 23\";\n    char *ptr;\n    unsigned long long result;\n    errno = 0;\n    result = strtoull (input, &ptr, 10);\n    ASSERT (result == 23);\n    ASSERT (ptr == input + 3);\n    ASSERT (errno == 0);\n  }\n  {\n    const char input[] = \"+23\";\n    char *ptr;\n    unsigned long long result;\n    errno = 0;\n    result = strtoull (input, &ptr, 10);\n    ASSERT (result == 23);\n    ASSERT (ptr == input + 3);\n    ASSERT (errno == 0);\n  }\n  {\n    const char input[] = \"-23\";\n    char *ptr;\n    unsigned long long result;\n    errno = 0;\n    result = strtoull (input, &ptr, 10);\n    ASSERT (result == - 23ULL);\n    ASSERT (ptr == input + 3);\n    ASSERT (errno == 0);\n  }\n\n  /* Large integer values.  */\n  {\n    const char input[] = \"2147483647\";\n    char *ptr;\n    unsigned long long result;\n    errno = 0;\n    result = strtoull (input, &ptr, 10);\n    ASSERT (result == 2147483647);\n    ASSERT (ptr == input + 10);\n    ASSERT (errno == 0);\n  }\n  {\n    const char input[] = \"-2147483648\";\n    char *ptr;\n    unsigned long long result;\n    errno = 0;\n    result = strtoull (input, &ptr, 10);\n    ASSERT (result == - 2147483648ULL);\n    ASSERT (ptr == input + 11);\n    ASSERT (errno == 0);\n  }\n  {\n    const char input[] = \"4294967295\";\n    char *ptr;\n    unsigned long long result;\n    errno = 0;\n    result = strtoull (input, &ptr, 10);\n    ASSERT (result == 4294967295U);\n    ASSERT (ptr == input + 10);\n    ASSERT (errno == 0);\n  }\n\n  return 0;\n}",
      "lines": 151,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-strtoumax.c": {
    "main": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        179,
        1
      ],
      "content": "int\nmain (void)\n{\n  /* Subject sequence empty or invalid.  */\n  {\n    const char input[] = \"\";\n    char *ptr;\n    uintmax_t result;\n    errno = 0;\n    result = strtoumax (input, &ptr, 10);\n    ASSERT (result == 0);\n    ASSERT (ptr == input);\n    ASSERT (errno == 0 || errno == EINVAL);\n  }\n  {\n    const char input[] = \" \";\n    char *ptr;\n    uintmax_t result;\n    errno = 0;\n    result = strtoumax (input, &ptr, 10);\n    ASSERT (result == 0);\n    ASSERT (ptr == input);\n    ASSERT (errno == 0 || errno == EINVAL);\n  }\n  {\n    const char input[] = \" +\";\n    char *ptr;\n    uintmax_t result;\n    errno = 0;\n    result = strtoumax (input, &ptr, 10);\n    ASSERT (result == 0);\n    ASSERT (ptr == input);\n    ASSERT (errno == 0 || errno == EINVAL);\n  }\n  {\n    const char input[] = \" -\";\n    char *ptr;\n    uintmax_t result;\n    errno = 0;\n    result = strtoumax (input, &ptr, 10);\n    ASSERT (result == 0);\n    ASSERT (ptr == input);\n    ASSERT (errno == 0 || errno == EINVAL);\n  }\n\n  /* Simple integer values.  */\n  {\n    const char input[] = \"0\";\n    char *ptr;\n    uintmax_t result;\n    errno = 0;\n    result = strtoumax (input, &ptr, 10);\n    ASSERT (result == 0);\n    ASSERT (ptr == input + 1);\n    ASSERT (errno == 0);\n  }\n  {\n    const char input[] = \"+0\";\n    char *ptr;\n    uintmax_t result;\n    errno = 0;\n    result = strtoumax (input, &ptr, 10);\n    ASSERT (result == 0);\n    ASSERT (ptr == input + 2);\n    ASSERT (errno == 0);\n  }\n  {\n    const char input[] = \"-0\";\n    char *ptr;\n    uintmax_t result;\n    errno = 0;\n    result = strtoumax (input, &ptr, 10);\n    ASSERT (result == 0);\n    ASSERT (ptr == input + 2);\n    ASSERT (errno == 0);\n  }\n  {\n    const char input[] = \"23\";\n    char *ptr;\n    uintmax_t result;\n    errno = 0;\n    result = strtoumax (input, &ptr, 10);\n    ASSERT (result == 23);\n    ASSERT (ptr == input + 2);\n    ASSERT (errno == 0);\n  }\n  {\n    const char input[] = \" 23\";\n    char *ptr;\n    uintmax_t result;\n    errno = 0;\n    result = strtoumax (input, &ptr, 10);\n    ASSERT (result == 23);\n    ASSERT (ptr == input + 3);\n    ASSERT (errno == 0);\n  }\n  {\n    const char input[] = \"+23\";\n    char *ptr;\n    uintmax_t result;\n    errno = 0;\n    result = strtoumax (input, &ptr, 10);\n    ASSERT (result == 23);\n    ASSERT (ptr == input + 3);\n    ASSERT (errno == 0);\n  }\n  {\n    const char input[] = \"-23\";\n    char *ptr;\n    uintmax_t result;\n    errno = 0;\n    result = strtoumax (input, &ptr, 10);\n    ASSERT (result == - (uintmax_t) 23);\n    ASSERT (ptr == input + 3);\n    ASSERT (errno == 0);\n  }\n\n  /* Large integer values.  */\n  {\n    const char input[] = \"2147483647\";\n    char *ptr;\n    uintmax_t result;\n    errno = 0;\n    result = strtoumax (input, &ptr, 10);\n    ASSERT (result == 2147483647);\n    ASSERT (ptr == input + 10);\n    ASSERT (errno == 0);\n  }\n  {\n    const char input[] = \"-2147483648\";\n    char *ptr;\n    uintmax_t result;\n    errno = 0;\n    result = strtoumax (input, &ptr, 10);\n    ASSERT (result == - (uintmax_t) 2147483648U);\n    ASSERT (ptr == input + 11);\n    ASSERT (errno == 0);\n  }\n  {\n    const char input[] = \"4294967295\";\n    char *ptr;\n    uintmax_t result;\n    errno = 0;\n    result = strtoumax (input, &ptr, 10);\n    ASSERT (result == 4294967295U);\n    ASSERT (ptr == input + 10);\n    ASSERT (errno == 0);\n  }\n\n  return 0;\n}",
      "lines": 151,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-symlink.c": {
    "main": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        46,
        1
      ],
      "content": "int\nmain (void)\n{\n  /* Remove any leftovers from a previous partial run.  */\n  ignore_value (system (\"rm -rf \" BASE \"*\"));\n\n  return test_symlink (symlink, true);\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-symlink.h": {
    "test_symlink": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "static int\ntest_symlink (int (*func) (char const *, char const *), bool print)\n{\n  if (func (\"nowhere\", BASE \"link1\"))\n    {\n      if (print)\n        fputs (\"skipping test: symlinks not supported on this file system\\n\",\n               stderr);\n      return 77;\n    }\n\n  /* Some systems allow the creation of 0-length symlinks as a synonym\n     for \".\"; but most reject it.  */\n  {\n    int status;\n    errno = 0;\n    status = func (\"\", BASE \"link2\");\n    if (status == -1)\n      ASSERT (errno == ENOENT || errno == EINVAL);\n    else\n      {\n        ASSERT (status == 0);\n        ASSERT (unlink (BASE \"link2\") == 0);\n      }\n  }\n\n  /* Sanity checks of failures.  */\n  errno = 0;\n  ASSERT (func (\"nowhere\", \"\") == -1);\n  ASSERT (errno == ENOENT);\n  errno = 0;\n  ASSERT (func (\"nowhere\", \".\") == -1);\n  ASSERT (errno == EEXIST || errno == EINVAL);\n  errno = 0;\n  ASSERT (func (\"somewhere\", BASE \"link1\") == -1);\n  ASSERT (errno == EEXIST);\n  errno = 0;\n  ASSERT (func (\"nowhere\", BASE \"link2/\") == -1);\n  ASSERT (errno == ENOTDIR || errno == ENOENT);\n  ASSERT (mkdir (BASE \"dir\", 0700) == 0);\n  errno = 0;\n  ASSERT (func (\"nowhere\", BASE \"dir\") == -1);\n  ASSERT (errno == EEXIST);\n  errno = 0;\n  ASSERT (func (\"nowhere\", BASE \"dir/\") == -1);\n  ASSERT (errno == EEXIST || errno == EINVAL);\n  ASSERT (close (creat (BASE \"file\", 0600)) == 0);\n  errno = 0;\n  ASSERT (func (\"nowhere\", BASE \"file\") == -1);\n  ASSERT (errno == EEXIST);\n  errno = 0;\n  ASSERT (func (\"nowhere\", BASE \"file/\") == -1);\n  ASSERT (errno == EEXIST || errno == ENOTDIR || errno == ENOENT);\n\n  /* Trailing slash must always be rejected.  */\n  ASSERT (unlink (BASE \"link1\") == 0);\n  ASSERT (func (BASE \"link2\", BASE \"link1\") == 0);\n  errno = 0;\n  ASSERT (func (BASE \"nowhere\", BASE \"link1/\") == -1);\n  ASSERT (errno == EEXIST || errno == ENOTDIR || errno == ENOENT);\n  errno = 0;\n  ASSERT (unlink (BASE \"link2\") == -1);\n  ASSERT (errno == ENOENT);\n\n  /* Cleanup.  */\n  ASSERT (rmdir (BASE \"dir\") == 0);\n  ASSERT (unlink (BASE \"file\") == 0);\n  ASSERT (unlink (BASE \"link1\") == 0);\n\n  return 0;\n}",
      "lines": 71,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-symlinkat.c": {
    "do_symlink": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "static int\ndo_symlink (char const *contents, char const *name)\n{\n  return symlinkat (contents, dfd, name);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        88,
        1
      ],
      "content": "int\nmain (void)\n{\n  int result;\n\n  /* Remove any leftovers from a previous partial run.  */\n  ignore_value (system (\"rm -rf \" BASE \"*\"));\n\n  /* Test behaviour for invalid file descriptors.  */\n  {\n    errno = 0;\n    ASSERT (symlinkat (\"foo\", -1, \"bar\") == -1);\n    ASSERT (errno == EBADF\n            || errno == ENOSYS /* seen on mingw */\n           );\n  }\n  {\n    close (99);\n    errno = 0;\n    ASSERT (symlinkat (\"foo\", 99, \"bar\") == -1);\n    ASSERT (errno == EBADF\n            || errno == ENOSYS /* seen on mingw */\n           );\n  }\n\n  /* Perform same checks as counterpart functions.  */\n  result = test_symlink (do_symlink, false);\n  dfd = openat (AT_FDCWD, \".\", O_RDONLY);\n  ASSERT (0 <= dfd);\n  ASSERT (test_symlink (do_symlink, false) == result);\n\n  ASSERT (close (dfd) == 0);\n  if (result == 77)\n    fputs (\"skipping test: symlinks not supported on this file system\\n\",\n           stderr);\n  return result;\n}",
      "lines": 37,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-sys_ioctl.c": {
    "main": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        26,
        1
      ],
      "content": "int\nmain (void)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-sys_select.c": {
    "main": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "int\nmain (void)\n{\n  /* Check that FD_ZERO can be used.  This should not yield a warning\n     such as \"warning: implicit declaration of function 'memset'\".  */\n  fd_set fds;\n  FD_ZERO (&fds);\n\n  return 0;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-sys_socket.c": {
    "main": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "int\nmain (void)\n{\n  struct sockaddr_storage x;\n  sa_family_t i;\n\n  /* Check some errno values.  */\n  switch (ENOTSOCK)\n    {\n    case ENOTSOCK:\n    case EADDRINUSE:\n    case ENETRESET:\n    case ECONNABORTED:\n    case ECONNRESET:\n    case ENOTCONN:\n    case ESHUTDOWN:\n      break;\n    }\n\n  x.ss_family = 42;\n  i = 42;\n  msg.msg_iov = &io;\n\n  return (x.ss_family - i + msg.msg_namelen + msg.msg_iov->iov_len\n          + msg.msg_iovlen);\n}",
      "lines": 26,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-sys_stat.c": {
    "main": {
      "start_point": [
        335,
        0
      ],
      "end_point": [
        339,
        1
      ],
      "content": "int\nmain (void)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-sys_time.c": {
    "main": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        33,
        1
      ],
      "content": "int\nmain (void)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-sys_types.c": {
    "main": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        33,
        1
      ],
      "content": "int\nmain (void)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-sys_uio.c": {
    "main": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        31,
        1
      ],
      "content": "int\nmain (void)\n{\n  return a + b + !!c.iov_base + c.iov_len;\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-sys_utsname.c": {
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "int\nmain ()\n{\n  struct utsname buf;\n\n  strcpy (buf.sysname, \"Linux\");\n  strcpy (buf.nodename, \"hobbybox\");\n  strcpy (buf.release, \"3.141.592\");\n  strcpy (buf.version, \"GENERIC\");\n  strcpy (buf.machine, \"i586\");\n\n  return 0;\n}",
      "lines": 13,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-sys_wait.c": {
    "main": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        46,
        1
      ],
      "content": "int\nmain (void)\n{\n  if (test_sys_wait_macros ())\n    return 1;\n\n#if 0\n  switch (WCONTINUED)\n    {\n  /* Gnulib doesn't guarantee these, yet.  */\n    case WCONTINUED:\n    case WEXITED:\n    case WNOWAIT:\n    case WSTOPPED:\n      break;\n    }\n#endif\n\n  return a ? 1 : 0;\n}",
      "lines": 20,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-sys_wait.h": {
    "test_sys_wait_macros": {
      "start_point": [
        18,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "static int\ntest_sys_wait_macros (void)\n{\n  /* Check subset of <sys/wait.h> macros that must be visible here.\n     Note that some of these macros are only portable when operating\n     on an lvalue.  */\n  int i;\n  for (i = 0; i < 0x8000; i = (i ? i << 1 : 1))\n    {\n      /* POSIX requires that for all valid process statuses, that\n         exactly one of these three macros is true.  But not all\n         possible 16-bit values map to valid process status.\n         Traditionally, 8 of the bits are for WIFEXITED, 7 of the bits\n         to tell between WIFSIGNALED and WIFSTOPPED, and either 0x80\n         or 0x8000 to flag that core was also dumped.  Since we don't\n         know which byte is WIFEXITED, we skip the both possible bits\n         that can signal core dump.  */\n      if (i == 0x80)\n        continue;\n      if (!!WIFSIGNALED (i) + !!WIFEXITED (i) + !!WIFSTOPPED (i) != 1)\n        return 1;\n    }\n  i = WEXITSTATUS (i) + WSTOPSIG (i) + WTERMSIG (i);\n\n  switch (i)\n    {\n#if 0\n  /* Gnulib doesn't guarantee these, yet.  */\n    case WNOHANG:\n    case WUNTRACED:\n#endif\n      break;\n    }\n  return 0;\n}",
      "lines": 35,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-thread_create.c": {
    "worker_thread_func": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        39,
        1
      ],
      "content": "static void *\nworker_thread_func (void *arg)\n{\n  work_done = 1;\n  return &dummy;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nworker_thread_func (void *arg)",
        "*"
      ]
    },
    "main": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "int\nmain ()\n{\n  main_thread_before = gl_thread_self ();\n\n  if (glthread_create (&worker_thread, worker_thread_func, NULL) == 0)\n    {\n      void *ret;\n\n      /* Check that gl_thread_self () has the same value before than after the\n         first call to gl_thread_create ().  */\n      main_thread_after = gl_thread_self ();\n      ASSERT (memcmp (&main_thread_before, &main_thread_after,\n                      sizeof (gl_thread_t))\n              == 0);\n\n      gl_thread_join (worker_thread, &ret);\n\n      /* Check the return value of the thread.  */\n      ASSERT (ret == &dummy);\n\n      /* Check that worker_thread_func () has finished executing.  */\n      ASSERT (work_done);\n\n      return 0;\n    }\n  else\n    {\n#if USE_POSIX_THREADS || USE_SOLARIS_THREADS || USE_PTH_THREADS || USE_WINDOWS_THREADS\n      fputs (\"glthread_create failed\\n\", stderr);\n      return 1;\n#else\n      fputs (\"Skipping test: multithreading not enabled\\n\", stderr);\n      return 77;\n#endif\n    }\n}",
      "lines": 37,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-thread_self.c": {
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        33,
        1
      ],
      "content": "int\nmain ()\n{\n  /* Check that gl_thread_self () can be used with just $(LIBTHREAD), not\n     $(LIBMULTITHREAD), i.e. in libraries that are multithread-safe but don't\n     create threads themselves.  */\n  main_thread = gl_thread_self ();\n\n  return 0;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-time.c": {
    "main": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "int\nmain (void)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-timespec.c": {
    "valid": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "static bool\nvalid (struct timespec a)\n{\n  return 0 <= a.tv_nsec && a.tv_nsec < TIMESPEC_RESOLUTION;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "sign": {
      "start_point": [
        64,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "static int\nsign (int i)\n{\n  return i < 0 ? -1 : 0 < i;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cmp": {
      "start_point": [
        70,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "static int\ncmp (struct timespec a, struct timespec b)\n{\n  return sign (timespec_cmp (a, b));\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "eq": {
      "start_point": [
        76,
        0
      ],
      "end_point": [
        80,
        1
      ],
      "content": "static bool\neq (struct timespec a, struct timespec b)\n{\n  return timespec_cmp (a, b) == 0;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "extremal": {
      "start_point": [
        82,
        0
      ],
      "end_point": [
        88,
        1
      ],
      "content": "static bool\nextremal (struct timespec a)\n{\n  return ((a.tv_sec == TYPE_MINIMUM (time_t) && a.tv_nsec == 0)\n\t  || (a.tv_sec == TYPE_MAXIMUM (time_t)\n\t      && a.tv_nsec == TIMESPEC_RESOLUTION - 1));\n}",
      "lines": 7,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "main": {
      "start_point": [
        90,
        0
      ],
      "end_point": [
        166,
        1
      ],
      "content": "int\nmain (void)\n{\n  int i, j, k;\n  struct timespec test[nprototypes + 1];\n  int ntests;\n  int computed_resolution = 1;\n  struct timespec prevroundtrip;\n\n  test[0] = make_timespec (TYPE_MINIMUM (time_t), -1);\n  ntests = 1;\n  for (i = 0; i < nprototypes; i++)\n    {\n      int s = prototype[i].s;\n      if (TYPE_SIGNED (time_t) || 0 <= s)\n\t{\n\t  time_t t = (s <= INT_MIN + 1 ? s - INT_MIN + TYPE_MINIMUM (time_t)\n\t\t      : INT_MAX - 1 <= s ? s - INT_MAX + TYPE_MAXIMUM (time_t)\n\t\t      : s);\n\t  test[ntests++] = make_timespec (t, prototype[i].ns);\n\t}\n    }\n\n  for (i = 0; i < LOG10_TIMESPEC_RESOLUTION; i++)\n    computed_resolution *= 10;\n  ASSERT (computed_resolution == TIMESPEC_RESOLUTION);\n\n  for (i = 0; i < ntests; i++)\n    {\n      struct timespec a = test[i];\n\n      struct timespec roundtrip = dtotimespec (timespectod (a));\n      if (i != 0)\n        ASSERT (cmp (prevroundtrip, roundtrip) <= 0);\n      prevroundtrip = roundtrip;\n\n      ASSERT (sign (timespec_sign (a)) == cmp (a, make_timespec (0, 0)));\n\n      if (valid (a))\n\tfor (j = 0; j < ntests; j++)\n\t  {\n\t    struct timespec b = test[j];\n\t    if (valid (b))\n\t      {\n\t\tstruct timespec sum = timespec_add (a, b);\n\t\tstruct timespec diff = timespec_sub (a, b);\n\t\tstruct timespec rdiff = timespec_sub (b, a);\n\t\tASSERT (cmp (a, b) == sign (i - j));\n\t\tASSERT (eq (sum, timespec_add (b, a)));\n\t\tif (! extremal (sum))\n\t\t  {\n\t\t    ASSERT (eq (a, timespec_sub (sum, b)));\n\t\t    ASSERT (eq (b, timespec_sub (sum, a)));\n\n\t\t    for (k = 0; k < ntests; k++)\n\t\t      {\n\t\t\tstruct timespec c = test[k];\n\t\t\tif (valid (c))\n\t\t\t  {\n\t\t\t    struct timespec sumbc = timespec_add (b, c);\n\t\t\t    if (! extremal (sumbc))\n\t\t\t      ASSERT (eq (timespec_add (a, sumbc),\n\t\t\t\t\t  timespec_add (sum, c)));\n\t\t\t  }\n\t\t      }\n\t\t  }\n\t\tif (! extremal (diff))\n\t\t  ASSERT (eq (a, timespec_add (diff, b)));\n\t\tif (! extremal (rdiff))\n\t\t  ASSERT (eq (b, timespec_add (rdiff, a)));\n\n\t      }\n\t  }\n    }\n\n  return 0;\n}",
      "lines": 77,
      "depth": 24,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-trunc1.c": {
    "main": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "int\nmain ()\n{\n  /* Zero.  */\n  ASSERT (trunc (0.0) == 0.0);\n  ASSERT (trunc (minus_zerod) == 0.0);\n  /* Positive numbers.  */\n  ASSERT (trunc (0.3) == 0.0);\n  ASSERT (trunc (0.7) == 0.0);\n  ASSERT (trunc (1.0) == 1.0);\n  ASSERT (trunc (1.5) == 1.0);\n  ASSERT (trunc (1.999) == 1.0);\n  ASSERT (trunc (2.0) == 2.0);\n  ASSERT (trunc (65535.999) == 65535.0);\n  ASSERT (trunc (65536.0) == 65536.0);\n  ASSERT (trunc (2.341e31) == 2.341e31);\n  /* Negative numbers.  */\n  ASSERT (trunc (-0.3) == 0.0);\n  ASSERT (trunc (-0.7) == 0.0);\n  ASSERT (trunc (-1.0) == -1.0);\n  ASSERT (trunc (-1.5) == -1.0);\n  ASSERT (trunc (-1.999) == -1.0);\n  ASSERT (trunc (-2.0) == -2.0);\n  ASSERT (trunc (-65535.999) == -65535.0);\n  ASSERT (trunc (-65536.0) == -65536.0);\n  ASSERT (trunc (-2.341e31) == -2.341e31);\n  /* Infinite numbers.  */\n  ASSERT (trunc (Infinityd ()) == Infinityd ());\n  ASSERT (trunc (- Infinityd ()) == - Infinityd ());\n  /* NaNs.  */\n  ASSERT (isnand (trunc (NaNd ())));\n\n  return 0;\n}",
      "lines": 34,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-trunc2.c": {
    "trunc_reference": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        108,
        1
      ],
      "content": "DOUBLE\ntrunc_reference (DOUBLE x)\n{\n  /* The use of 'volatile' guarantees that excess precision bits are dropped\n     at each addition step and before the following comparison at the caller's\n     site.  It is necessary on x86 systems where double-floats are not IEEE\n     compliant by default, to avoid that the results become platform and compiler\n     option dependent.  'volatile' is a portable alternative to gcc's\n     -ffloat-store option.  */\n  volatile DOUBLE y = x;\n  volatile DOUBLE z = y;\n\n  if (z > L_(0.0))\n    {\n      /* For 0 < x < 1, return +0.0 even if the current rounding mode is\n         FE_DOWNWARD.  */\n      if (z < L_(1.0))\n        z = L_(0.0);\n      /* Avoid rounding errors for values near 2^k, where k >= MANT_DIG-1.  */\n      else if (z < TWO_MANT_DIG)\n        {\n          /* Round to the next integer (nearest or up or down, doesn't matter).  */\n          z += TWO_MANT_DIG;\n          z -= TWO_MANT_DIG;\n          /* Enforce rounding down.  */\n          if (z > y)\n            z -= L_(1.0);\n        }\n    }\n  else if (z < L_(0.0))\n    {\n      /* For -1 < x < 0, return -0.0 regardless of the current rounding\n         mode.  */\n      if (z > L_(-1.0))\n        z = MINUS_ZERO;\n      /* Avoid rounding errors for values near -2^k, where k >= MANT_DIG-1.  */\n      else if (z > - TWO_MANT_DIG)\n        {\n          /* Round to the next integer (nearest or up or down, doesn't matter).  */\n          z -= TWO_MANT_DIG;\n          z += TWO_MANT_DIG;\n          /* Enforce rounding up.  */\n          if (z < y)\n            z += L_(1.0);\n        }\n    }\n  return z;\n}",
      "lines": 48,
      "depth": 14,
      "decorators": [
        "DOUBLE"
      ]
    },
    "equal": {
      "start_point": [
        112,
        0
      ],
      "end_point": [
        116,
        1
      ],
      "content": "static int\nequal (DOUBLE x, DOUBLE y)\n{\n  return (isnand (x) ? isnand (y) : x == y);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "correct_result_p": {
      "start_point": [
        119,
        0
      ],
      "end_point": [
        130,
        1
      ],
      "content": "static bool\ncorrect_result_p (DOUBLE x, DOUBLE result)\n{\n  return\n    (x >= 0\n     ? (x < 1 ? result == L_(0.0) :\n        x - 1 < x ? result <= x && result >= x - 1 && x - result < 1 :\n        equal (result, x))\n     : (x > -1 ? result == L_(0.0) :\n        x + 1 > x ? result >= x && result <= x + 1 && result - x < 1 :\n        equal (result, x)));\n}",
      "lines": 12,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "check": {
      "start_point": [
        133,
        0
      ],
      "end_point": [
        153,
        1
      ],
      "content": "static int\ncheck (double x)\n{\n  /* If the reference implementation is incorrect, bail out immediately.  */\n  double reference = trunc_reference (x);\n  ASSERT (correct_result_p (x, reference));\n  /* If the actual implementation is wrong, return an error code.  */\n  {\n    double result = trunc (x);\n    if (correct_result_p (x, result))\n      return 0;\n    else\n      {\n#if GNULIB_TEST_FPRINTF_POSIX\n        fprintf (stderr, \"trunc %g(%a) = %g(%a) or %g(%a)?\\n\",\n                 x, x, reference, reference, result, result);\n#endif\n        return 1;\n      }\n  }\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        158,
        0
      ],
      "end_point": [
        177,
        1
      ],
      "content": "int\nmain ()\n{\n  unsigned int highbits;\n  unsigned int lowbits;\n  int error = 0;\n  for (highbits = 0; highbits < (1 << NUM_HIGHBITS); highbits++)\n    for (lowbits = 0; lowbits < (1 << NUM_LOWBITS); lowbits++)\n      {\n        /* Combine highbits and lowbits into a floating-point number,\n           sign-extending the lowbits to 32-NUM_HIGHBITS bits.  */\n        union { double f; uint64_t i; } janus;\n        janus.i = ((uint64_t) highbits << (64 - NUM_HIGHBITS))\n                  | ((uint64_t) ((int64_t) ((uint64_t) lowbits << (64 - NUM_LOWBITS))\n                                 >> (64 - NUM_LOWBITS - NUM_HIGHBITS))\n                     >> NUM_HIGHBITS);\n        error |= check (janus.f);\n      }\n  return (error ? 1 : 0);\n}",
      "lines": 20,
      "depth": 19,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-uname.c": {
    "main": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        63,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  struct utsname buf;\n\n  memset (&buf, '?', sizeof (buf));\n\n  ASSERT (uname (&buf) >= 0);\n\n  /* Verify that every field's value is NUL terminated.  */\n  ASSERT (strlen (buf.sysname) < sizeof (buf.sysname));\n  ASSERT (strlen (buf.nodename) < sizeof (buf.nodename));\n  ASSERT (strlen (buf.release) < sizeof (buf.release));\n  ASSERT (strlen (buf.version) < sizeof (buf.version));\n  ASSERT (strlen (buf.machine) < sizeof (buf.machine));\n\n  if (argc > 1)\n    {\n      /* Show the result.  */\n\n      printf (\"uname -n = nodename       = %s\\n\", buf.nodename);\n      printf (\"uname -s = sysname        = %s\\n\", buf.sysname);\n      printf (\"uname -r = release        = %s\\n\", buf.release);\n      printf (\"uname -v = version        = %s\\n\", buf.version);\n      printf (\"uname -m = machine or cpu = %s\\n\", buf.machine);\n    }\n\n  return 0;\n}",
      "lines": 29,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-unistd.c": {
    "main": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "int\nmain (void)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-unlink.c": {
    "main": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "int\nmain (void)\n{\n  /* Remove any leftovers from a previous partial run.  */\n  ignore_value (system (\"rm -rf \" BASE \"*\"));\n\n  return test_unlink_func (unlink, true);\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-unlink.h": {
    "test_unlink_func": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "static int\ntest_unlink_func (int (*func) (char const *name), bool print)\n{\n  /* Setup.  */\n  ASSERT (mkdir (BASE \"dir\", 0700) == 0);\n  ASSERT (close (creat (BASE \"dir/file\", 0600)) == 0);\n\n  /* Basic error conditions.  */\n  errno = 0;\n  ASSERT (func (\"\") == -1);\n  ASSERT (errno == ENOENT);\n  errno = 0;\n  ASSERT (func (BASE \"nosuch\") == -1);\n  ASSERT (errno == ENOENT);\n  errno = 0;\n  ASSERT (func (BASE \"nosuch/\") == -1);\n  ASSERT (errno == ENOENT);\n  /* Resulting errno after directories is rather varied across\n     implementations (EPERM, EINVAL, EACCES, EBUSY, EISDIR, ENOTSUP);\n     however, we must be careful to not attempt unlink on a directory\n     unless we know it must fail.  */\n  if (cannot_unlink_dir ())\n    {\n      ASSERT (func (\".\") == -1);\n      ASSERT (func (\"..\") == -1);\n      ASSERT (func (\"/\") == -1);\n      ASSERT (func (BASE \"dir\") == -1);\n      ASSERT (mkdir (BASE \"dir1\", 0700) == 0);\n      ASSERT (func (BASE \"dir1\") == -1);\n      ASSERT (rmdir (BASE \"dir1\") == 0);\n    }\n  errno = 0;\n  ASSERT (func (BASE \"dir/file/\") == -1);\n  ASSERT (errno == ENOTDIR);\n\n  /* Test symlink behavior.  Specifying trailing slash will attempt\n     unlink of a directory, so only attempt it if we know it must\n     fail.  */\n  if (symlink (BASE \"dir\", BASE \"link\") != 0)\n    {\n      ASSERT (func (BASE \"dir/file\") == 0);\n      ASSERT (rmdir (BASE \"dir\") == 0);\n      if (print)\n        fputs (\"skipping test: symlinks not supported on this file system\\n\",\n               stderr);\n      return 77;\n    }\n  if (cannot_unlink_dir ())\n    ASSERT (func (BASE \"link/\") == -1);\n  ASSERT (func (BASE \"link\") == 0);\n  ASSERT (symlink (BASE \"dir/file\", BASE \"link\") == 0);\n  errno = 0;\n  ASSERT (func (BASE \"link/\") == -1);\n  ASSERT (errno == ENOTDIR);\n  /* Order here proves unlink of a symlink does not follow through to\n     the file.  */\n  ASSERT (func (BASE \"link\") == 0);\n  ASSERT (func (BASE \"dir/file\") == 0);\n  ASSERT (rmdir (BASE \"dir\") == 0);\n\n  return 0;\n}",
      "lines": 62,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-unlinkat.c": {
    "rmdirat": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "static int\nrmdirat (char const *name)\n{\n  return unlinkat (dfd, name, AT_REMOVEDIR);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "unlinker": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "static int\nunlinker (char const *name)\n{\n  return unlinkat (dfd, name, 0);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        97,
        1
      ],
      "content": "int\nmain (int argc _GL_UNUSED, char *argv[])\n{\n  /* FIXME: Add tests of fd other than \".\".  */\n  int result1;\n  int result2;\n\n  set_program_name (argv[0]);\n\n  /* Remove any leftovers from a previous partial run.  */\n  ignore_value (system (\"rm -rf \" BASE \"*\"));\n\n  /* Test behaviour for invalid file descriptors.  */\n  {\n    errno = 0;\n    ASSERT (unlinkat (-1, \"foo\", 0) == -1);\n    ASSERT (errno == EBADF);\n  }\n  {\n    close (99);\n    errno = 0;\n    ASSERT (unlinkat (99, \"foo\", 0) == -1);\n    ASSERT (errno == EBADF);\n  }\n\n  result1 = test_rmdir_func (rmdirat, false);\n  result2 = test_unlink_func (unlinker, false);\n  ASSERT (result1 == result2);\n  dfd = open (\".\", O_RDONLY);\n  ASSERT (0 <= dfd);\n  result2 = test_rmdir_func (rmdirat, false);\n  ASSERT (result1 == result2);\n  result2 = test_unlink_func (unlinker, false);\n  ASSERT (result1 == result2);\n  ASSERT (close (dfd) == 0);\n  if (result1 == 77)\n    fputs (\"skipping test: symlinks not supported on this file system\\n\",\n           stderr);\n  return result1;\n}",
      "lines": 40,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-unsetenv.c": {
    "main": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "int\nmain (void)\n{\n  char entry[] = \"b=2\";\n\n  /* Test removal when multiple entries present.  */\n  ASSERT (putenv ((char *) \"a=1\") == 0);\n  ASSERT (putenv (entry) == 0);\n  entry[0] = 'a'; /* Unspecified what getenv(\"a\") would be at this point.  */\n  ASSERT (unsetenv (\"a\") == 0); /* Both entries will be removed.  */\n  ASSERT (getenv (\"a\") == NULL);\n  ASSERT (unsetenv (\"a\") == 0);\n\n  /* Required to fail with EINVAL.  */\n  errno = 0;\n  ASSERT (unsetenv (\"\") == -1);\n  ASSERT (errno == EINVAL);\n  errno = 0;\n  ASSERT (unsetenv (\"a=b\") == -1);\n  ASSERT (errno == EINVAL);\n#if 0\n  /* glibc and gnulib's implementation guarantee this, but POSIX no\n     longer requires it: http://austingroupbugs.net/view.php?id=185  */\n  errno = 0;\n  ASSERT (unsetenv (NULL) == -1);\n  ASSERT (errno == EINVAL);\n#endif\n\n  return 0;\n}",
      "lines": 30,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-vasnprintf.c": {
    "test_function": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "static void\ntest_function (char * (*my_asnprintf) (char *, size_t *, const char *, ...))\n{\n  char buf[8];\n  int size;\n\n  for (size = 0; size <= 8; size++)\n    {\n      size_t length = size;\n      char *result = my_asnprintf (NULL, &length, \"%d\", 12345);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, \"12345\") == 0);\n      ASSERT (length == 5);\n      free (result);\n    }\n\n  for (size = 0; size <= 8; size++)\n    {\n      size_t length;\n      char *result;\n\n      memcpy (buf, \"DEADBEEF\", 8);\n      length = size;\n      result = my_asnprintf (buf, &length, \"%d\", 12345);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, \"12345\") == 0);\n      ASSERT (length == 5);\n      if (size < 6)\n        ASSERT (result != buf);\n      ASSERT (memcmp (buf + size, &\"DEADBEEF\"[size], 8 - size) == 0);\n      if (result != buf)\n        free (result);\n    }\n}",
      "lines": 34,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "my_asnprintf": {
      "start_point": [
        63,
        0
      ],
      "end_point": [
        73,
        1
      ],
      "content": "static char *\nmy_asnprintf (char *resultbuf, size_t *lengthp, const char *format, ...)\n{\n  va_list args;\n  char *ret;\n\n  va_start (args, format);\n  ret = vasnprintf (resultbuf, lengthp, format, args);\n  va_end (args);\n  return ret;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nmy_asnprintf (char *resultbuf, size_t *lengthp, const char *format, ...)",
        "*"
      ]
    },
    "test_vasnprintf": {
      "start_point": [
        75,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "static void\ntest_vasnprintf ()\n{\n  test_function (my_asnprintf);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_asnprintf": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "static void\ntest_asnprintf ()\n{\n  test_function (asnprintf);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        87,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  test_vasnprintf ();\n  test_asnprintf ();\n  return 0;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-verify.c": {
    "function": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "static int\nfunction (int n)\n{\n#if EXP_FAIL == 3\n  verify (n >= 0);                  /* should give ERROR: non-constant expression */\n#endif\n  verify (c == 2);                  /* should be ok */\n#if EXP_FAIL == 4\n  verify (1 + 1 == 3);              /* should give ERROR */\n#endif\n  verify (1 == 1); verify (1 == 1); /* should be ok */\n\n  if (n)\n    return ((void) verify_expr (1 == 1, 1), verify_expr (1 == 1, 8)); /* should be ok */\n#if EXP_FAIL == 5\n  return verify_expr (1 == 2, 5); /* should give ERROR */\n#endif\n  return 0;\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        64,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "int\nmain (void)\n{\n  return !(function (0) == 0 && function (1) == 8);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-version-etc.c": {
    "main": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        32,
        1
      ],
      "content": "int\nmain (int argc _GL_UNUSED, char **argv)\n{\n  set_program_name (argv[0]);\n  version_etc (stdout, \"test-version-etc\", \"dummy\", \"0\", AUTHORS,\n               (const char *) NULL);\n  return 0;\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-wchar.c": {
    "main": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "int\nmain (void)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-wcrtomb-w32.c": {
    "test_one_locale": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        296,
        1
      ],
      "content": "static int\ntest_one_locale (const char *name, int codepage)\n{\n  char buf[64];\n  size_t ret;\n\n# if 1\n  /* Portable code to set the locale.  */\n  {\n    char name_with_codepage[1024];\n\n    sprintf (name_with_codepage, \"%s.%d\", name, codepage);\n\n    /* Set the locale.  */\n    if (setlocale (LC_ALL, name_with_codepage) == NULL)\n      return 77;\n  }\n# else\n  /* Hacky way to set a locale.codepage combination that setlocale() refuses\n     to set.  */\n  {\n    /* Codepage of the current locale, set with setlocale().\n       Not necessarily the same as GetACP().  */\n    extern __declspec(dllimport) unsigned int __lc_codepage;\n\n    /* Set the locale.  */\n    if (setlocale (LC_ALL, name) == NULL)\n      return 77;\n\n    /* Clobber the codepage and MB_CUR_MAX, both set by setlocale().  */\n    __lc_codepage = codepage;\n    switch (codepage)\n      {\n      case 1252:\n      case 1256:\n        MB_CUR_MAX = 1;\n        break;\n      case 932:\n      case 950:\n      case 936:\n        MB_CUR_MAX = 2;\n        break;\n      case 54936:\n      case 65001:\n        MB_CUR_MAX = 4;\n        break;\n      }\n\n    /* Test whether the codepage is really available.  */\n    {\n      mbstate_t state;\n      wchar_t wc;\n\n      memset (&state, '\\0', sizeof (mbstate_t));\n      if (mbrtowc (&wc, \" \", 1, &state) == (size_t)(-1))\n        return 77;\n    }\n  }\n# endif\n\n  /* Test NUL character.  */\n  {\n    buf[0] = 'x';\n    ret = wcrtomb (buf, 0, NULL);\n    ASSERT (ret == 1);\n    ASSERT (buf[0] == '\\0');\n  }\n\n  /* Test single bytes.  */\n  {\n    int c;\n\n    for (c = 0; c < 0x100; c++)\n      switch (c)\n        {\n        case '\\t': case '\\v': case '\\f':\n        case ' ': case '!': case '\"': case '#': case '%':\n        case '&': case '\\'': case '(': case ')': case '*':\n        case '+': case ',': case '-': case '.': case '/':\n        case '0': case '1': case '2': case '3': case '4':\n        case '5': case '6': case '7': case '8': case '9':\n        case ':': case ';': case '<': case '=': case '>':\n        case '?':\n        case 'A': case 'B': case 'C': case 'D': case 'E':\n        case 'F': case 'G': case 'H': case 'I': case 'J':\n        case 'K': case 'L': case 'M': case 'N': case 'O':\n        case 'P': case 'Q': case 'R': case 'S': case 'T':\n        case 'U': case 'V': case 'W': case 'X': case 'Y':\n        case 'Z':\n        case '[': case '\\\\': case ']': case '^': case '_':\n        case 'a': case 'b': case 'c': case 'd': case 'e':\n        case 'f': case 'g': case 'h': case 'i': case 'j':\n        case 'k': case 'l': case 'm': case 'n': case 'o':\n        case 'p': case 'q': case 'r': case 's': case 't':\n        case 'u': case 'v': case 'w': case 'x': case 'y':\n        case 'z': case '{': case '|': case '}': case '~':\n          /* c is in the ISO C \"basic character set\".  */\n          ret = wcrtomb (buf, btowc (c), NULL);\n          ASSERT (ret == 1);\n          ASSERT (buf[0] == (char) c);\n          break;\n        }\n  }\n\n  /* Test special calling convention, passing a NULL pointer.  */\n  {\n    ret = wcrtomb (NULL, '\\0', NULL);\n    ASSERT (ret == 1);\n    ret = wcrtomb (NULL, btowc ('x'), NULL);\n    ASSERT (ret == 1);\n  }\n\n  switch (codepage)\n    {\n    case 1252:\n      /* Locale encoding is CP1252, an extension of ISO-8859-1.  */\n      {\n        /* Convert \"B\\374\\337er\": \"B\u00c3\u00bc\u00c3\u009fer\" */\n        memset (buf, 'x', 8);\n        ret = wcrtomb (buf, 0x00FC, NULL);\n        ASSERT (ret == 1);\n        ASSERT (memcmp (buf, \"\\374\", 1) == 0);\n        ASSERT (buf[1] == 'x');\n\n        memset (buf, 'x', 8);\n        ret = wcrtomb (buf, 0x00DF, NULL);\n        ASSERT (ret == 1);\n        ASSERT (memcmp (buf, \"\\337\", 1) == 0);\n        ASSERT (buf[1] == 'x');\n      }\n      return 0;\n\n    case 1256:\n      /* Locale encoding is CP1256, not the same as ISO-8859-6.  */\n      {\n        /* Convert \"x\\302\\341\\346y\": \"x\u00d8\u00a2\u00d9\u0084\u00d9\u0088y\" */\n        memset (buf, 'x', 8);\n        ret = wcrtomb (buf, 0x0622, NULL);\n        ASSERT (ret == 1);\n        ASSERT (memcmp (buf, \"\\302\", 1) == 0);\n        ASSERT (buf[1] == 'x');\n\n        memset (buf, 'x', 8);\n        ret = wcrtomb (buf, 0x0644, NULL);\n        ASSERT (ret == 1);\n        ASSERT (memcmp (buf, \"\\341\", 1) == 0);\n        ASSERT (buf[1] == 'x');\n\n        memset (buf, 'x', 8);\n        ret = wcrtomb (buf, 0x0648, NULL);\n        ASSERT (ret == 1);\n        ASSERT (memcmp (buf, \"\\346\", 1) == 0);\n        ASSERT (buf[1] == 'x');\n      }\n      return 0;\n\n    case 932:\n      /* Locale encoding is CP932, similar to Shift_JIS.  */\n      {\n        /* Convert \"<\\223\\372\\226\\173\\214\\352>\": \"<\u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e>\" */\n        memset (buf, 'x', 8);\n        ret = wcrtomb (buf, 0x65E5, NULL);\n        ASSERT (ret == 2);\n        ASSERT (memcmp (buf, \"\\223\\372\", 2) == 0);\n        ASSERT (buf[2] == 'x');\n\n        memset (buf, 'x', 8);\n        ret = wcrtomb (buf, 0x672C, NULL);\n        ASSERT (ret == 2);\n        ASSERT (memcmp (buf, \"\\226\\173\", 2) == 0);\n        ASSERT (buf[2] == 'x');\n\n        memset (buf, 'x', 8);\n        ret = wcrtomb (buf, 0x8A9E, NULL);\n        ASSERT (ret == 2);\n        ASSERT (memcmp (buf, \"\\214\\352\", 2) == 0);\n        ASSERT (buf[2] == 'x');\n      }\n      return 0;\n\n    case 950:\n      /* Locale encoding is CP950, similar to Big5.  */\n      {\n        /* Convert \"<\\244\\351\\245\\273\\273\\171>\": \"<\u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e>\" */\n        memset (buf, 'x', 8);\n        ret = wcrtomb (buf, 0x65E5, NULL);\n        ASSERT (ret == 2);\n        ASSERT (memcmp (buf, \"\\244\\351\", 2) == 0);\n        ASSERT (buf[2] == 'x');\n\n        memset (buf, 'x', 8);\n        ret = wcrtomb (buf, 0x672C, NULL);\n        ASSERT (ret == 2);\n        ASSERT (memcmp (buf, \"\\245\\273\", 2) == 0);\n        ASSERT (buf[2] == 'x');\n\n        memset (buf, 'x', 8);\n        ret = wcrtomb (buf, 0x8A9E, NULL);\n        ASSERT (ret == 2);\n        ASSERT (memcmp (buf, \"\\273\\171\", 2) == 0);\n        ASSERT (buf[2] == 'x');\n      }\n      return 0;\n\n    case 936:\n      /* Locale encoding is CP936 = GBK, an extension of GB2312.  */\n      {\n        /* Convert \"<\\310\\325\\261\\276\\325\\132>\": \"<\u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e>\" */\n        memset (buf, 'x', 8);\n        ret = wcrtomb (buf, 0x65E5, NULL);\n        ASSERT (ret == 2);\n        ASSERT (memcmp (buf, \"\\310\\325\", 2) == 0);\n        ASSERT (buf[2] == 'x');\n\n        memset (buf, 'x', 8);\n        ret = wcrtomb (buf, 0x672C, NULL);\n        ASSERT (ret == 2);\n        ASSERT (memcmp (buf, \"\\261\\276\", 2) == 0);\n        ASSERT (buf[2] == 'x');\n\n        memset (buf, 'x', 8);\n        ret = wcrtomb (buf, 0x8A9E, NULL);\n        ASSERT (ret == 2);\n        ASSERT (memcmp (buf, \"\\325\\132\", 2) == 0);\n        ASSERT (buf[2] == 'x');\n      }\n      return 0;\n\n    case 54936:\n      /* Locale encoding is CP54936 = GB18030.  */\n      {\n        /* Convert \"B\\250\\271\\201\\060\\211\\070er\": \"B\u00c3\u00bc\u00c3\u009fer\" */\n        memset (buf, 'x', 8);\n        ret = wcrtomb (buf, 0x00FC, NULL);\n        ASSERT (ret == 2);\n        ASSERT (memcmp (buf, \"\\250\\271\", 2) == 0);\n        ASSERT (buf[2] == 'x');\n\n        memset (buf, 'x', 8);\n        ret = wcrtomb (buf, 0x00DF, NULL);\n        ASSERT (ret == 4);\n        ASSERT (memcmp (buf, \"\\201\\060\\211\\070\", 4) == 0);\n        ASSERT (buf[4] == 'x');\n      }\n      return 0;\n\n    case 65001:\n      /* Locale encoding is CP65001 = UTF-8.  */\n      {\n        /* Convert \"B\\303\\274\\303\\237er\": \"B\u00c3\u00bc\u00c3\u009fer\" */\n        memset (buf, 'x', 8);\n        ret = wcrtomb (buf, 0x00FC, NULL);\n        ASSERT (ret == 2);\n        ASSERT (memcmp (buf, \"\\303\\274\", 2) == 0);\n        ASSERT (buf[2] == 'x');\n\n        memset (buf, 'x', 8);\n        ret = wcrtomb (buf, 0x00DF, NULL);\n        ASSERT (ret == 2);\n        ASSERT (memcmp (buf, \"\\303\\237\", 2) == 0);\n        ASSERT (buf[2] == 'x');\n      }\n      return 0;\n\n    default:\n      return 1;\n    }\n}",
      "lines": 268,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": [
      {
        "start_point": [
          298,
          0
        ],
        "end_point": [
          320,
          1
        ],
        "content": "int\nmain (int argc, char *argv[])\n{\n  int codepage = atoi (argv[argc - 1]);\n  int result;\n  int i;\n\n  result = 77;\n  for (i = 1; i < argc - 1; i++)\n    {\n      int ret = test_one_locale (argv[i], codepage);\n\n      if (ret != 77)\n        result = ret;\n    }\n\n  if (result == 77)\n    {\n      fprintf (stderr, \"Skipping test: found no locale with codepage %d\\n\",\n               codepage);\n    }\n  return result;\n}",
        "lines": 23,
        "depth": 10,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          324,
          0
        ],
        "end_point": [
          329,
          1
        ],
        "content": "int\nmain (int argc, char *argv[])\n{\n  fputs (\"Skipping test: not a native Windows system\\n\", stderr);\n  return 77;\n}",
        "lines": 6,
        "depth": 7,
        "decorators": [
          "int"
        ]
      }
    ]
  },
  "findutils/findutils-4.6.0/tests/test-wcrtomb.c": {
    "check_character": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "static void\ncheck_character (const char *s, size_t n)\n{\n  wchar_t wc;\n  char buf[64];\n  int iret;\n  size_t ret;\n\n  wc = (wchar_t) 0xBADFACE;\n  iret = mbtowc (&wc, s, n);\n  ASSERT (iret == n);\n\n  ret = wcrtomb (buf, wc, NULL);\n  ASSERT (ret == n);\n  ASSERT (memcmp (buf, s, n) == 0);\n\n  /* Test special calling convention, passing a NULL pointer.  */\n  ret = wcrtomb (NULL, wc, NULL);\n  ASSERT (ret == 1);\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        161,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  char buf[64];\n  size_t ret;\n\n  /* configure should already have checked that the locale is supported.  */\n  if (setlocale (LC_ALL, \"\") == NULL)\n    return 1;\n\n  /* Test NUL character.  */\n  {\n    buf[0] = 'x';\n    ret = wcrtomb (buf, 0, NULL);\n    ASSERT (ret == 1);\n    ASSERT (buf[0] == '\\0');\n  }\n\n  /* Test single bytes.  */\n  {\n    int c;\n\n    for (c = 0; c < 0x100; c++)\n      switch (c)\n        {\n        case '\\t': case '\\v': case '\\f':\n        case ' ': case '!': case '\"': case '#': case '%':\n        case '&': case '\\'': case '(': case ')': case '*':\n        case '+': case ',': case '-': case '.': case '/':\n        case '0': case '1': case '2': case '3': case '4':\n        case '5': case '6': case '7': case '8': case '9':\n        case ':': case ';': case '<': case '=': case '>':\n        case '?':\n        case 'A': case 'B': case 'C': case 'D': case 'E':\n        case 'F': case 'G': case 'H': case 'I': case 'J':\n        case 'K': case 'L': case 'M': case 'N': case 'O':\n        case 'P': case 'Q': case 'R': case 'S': case 'T':\n        case 'U': case 'V': case 'W': case 'X': case 'Y':\n        case 'Z':\n        case '[': case '\\\\': case ']': case '^': case '_':\n        case 'a': case 'b': case 'c': case 'd': case 'e':\n        case 'f': case 'g': case 'h': case 'i': case 'j':\n        case 'k': case 'l': case 'm': case 'n': case 'o':\n        case 'p': case 'q': case 'r': case 's': case 't':\n        case 'u': case 'v': case 'w': case 'x': case 'y':\n        case 'z': case '{': case '|': case '}': case '~':\n          /* c is in the ISO C \"basic character set\".  */\n          ret = wcrtomb (buf, btowc (c), NULL);\n          ASSERT (ret == 1);\n          ASSERT (buf[0] == (char) c);\n          break;\n        }\n  }\n\n  /* Test special calling convention, passing a NULL pointer.  */\n  {\n    ret = wcrtomb (NULL, '\\0', NULL);\n    ASSERT (ret == 1);\n    ret = wcrtomb (NULL, btowc ('x'), NULL);\n    ASSERT (ret == 1);\n  }\n\n  if (argc > 1)\n    switch (argv[1][0])\n      {\n      case '1':\n        /* Locale encoding is ISO-8859-1 or ISO-8859-15.  */\n        {\n          const char input[] = \"B\\374\\337er\"; /* \"B\u00c3\u00bc\u00c3\u009fer\" */\n\n          check_character (input + 1, 1);\n          check_character (input + 2, 1);\n        }\n        return 0;\n\n      case '2':\n        /* Locale encoding is UTF-8.  */\n        {\n          const char input[] = \"B\\303\\274\\303\\237er\"; /* \"B\u00c3\u00bc\u00c3\u009fer\" */\n\n          check_character (input + 1, 2);\n          check_character (input + 3, 2);\n        }\n        return 0;\n\n      case '3':\n        /* Locale encoding is EUC-JP.  */\n        {\n          const char input[] = \"<\\306\\374\\313\\334\\270\\354>\"; /* \"<\u00e6\u0097\u00a5\u00e6\u009c\u00ac\u00e8\u00aa\u009e>\" */\n\n          check_character (input + 1, 2);\n          check_character (input + 3, 2);\n          check_character (input + 5, 2);\n        }\n        return 0;\n\n      case '4':\n        /* Locale encoding is GB18030.  */\n        {\n          const char input[] = \"B\\250\\271\\201\\060\\211\\070er\"; /* \"B\u00c3\u00bc\u00c3\u009fer\" */\n\n          check_character (input + 1, 2);\n          check_character (input + 3, 4);\n        }\n        return 0;\n      }\n\n  return 1;\n}",
      "lines": 109,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-wctype-h.c": {
    "main": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        73,
        1
      ],
      "content": "int\nmain (void)\n{\n  /* Check that the isw* functions exist as functions or as macros.  */\n  (void) iswalnum (0);\n  (void) iswalpha (0);\n  (void) iswcntrl (0);\n  (void) iswdigit (0);\n  (void) iswgraph (0);\n  (void) iswlower (0);\n  (void) iswprint (0);\n  (void) iswpunct (0);\n  (void) iswspace (0);\n  (void) iswupper (0);\n  (void) iswxdigit (0);\n\n  /* Check that the isw* functions map WEOF to 0.  */\n  ASSERT (!iswalnum (e));\n  ASSERT (!iswalpha (e));\n  ASSERT (!iswcntrl (e));\n  ASSERT (!iswdigit (e));\n  ASSERT (!iswgraph (e));\n  ASSERT (!iswlower (e));\n  ASSERT (!iswprint (e));\n  ASSERT (!iswpunct (e));\n  ASSERT (!iswspace (e));\n  ASSERT (!iswupper (e));\n  ASSERT (!iswxdigit (e));\n\n  /* Check that the tow* functions exist as functions or as macros.  */\n  (void) towlower (0);\n  (void) towupper (0);\n\n  /* Check that the tow* functions map WEOF to WEOF.  */\n  ASSERT (towlower (e) == e);\n  ASSERT (towupper (e) == e);\n\n  return 0;\n}",
      "lines": 39,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-wcwidth.c": {
    "main": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        80,
        1
      ],
      "content": "int\nmain ()\n{\n  wchar_t wc;\n\n  /* Test width of ASCII characters.  */\n  for (wc = 0x20; wc < 0x7F; wc++)\n    ASSERT (wcwidth (wc) == 1);\n\n  /* Switch to an UTF-8 locale.  */\n  if (setlocale (LC_ALL, \"fr_FR.UTF-8\") != NULL\n      /* Check whether it's really an UTF-8 locale.\n         On OpenBSD 4.0, the setlocale call succeeds only for the LC_CTYPE\n         category and therefore returns \"C/fr_FR.UTF-8/C/C/C/C\", but the\n         LC_CTYPE category is effectively set to an ASCII LC_CTYPE category;\n         in particular, locale_charset() returns \"ASCII\".  */\n      && strcmp (locale_charset (), \"UTF-8\") == 0)\n    {\n      /* Test width of ASCII characters.  */\n      for (wc = 0x20; wc < 0x7F; wc++)\n        ASSERT (wcwidth (wc) == 1);\n\n      /* Test width of some non-spacing characters.  */\n      ASSERT (wcwidth (0x0301) == 0);\n      ASSERT (wcwidth (0x05B0) == 0);\n\n      /* Test width of some format control characters.  */\n      ASSERT (wcwidth (0x200E) <= 0);\n      ASSERT (wcwidth (0x2060) <= 0);\n#if 0  /* wchar_t may be only 16 bits.  */\n      ASSERT (wcwidth (0xE0001) <= 0);\n      ASSERT (wcwidth (0xE0044) <= 0);\n#endif\n\n      /* Test width of some zero width characters.  */\n      ASSERT (wcwidth (0x200B) == 0);\n      ASSERT (wcwidth (0xFEFF) <= 0);\n\n      /* Test width of some CJK characters.  */\n      ASSERT (wcwidth (0x3000) == 2);\n      ASSERT (wcwidth (0xB250) == 2);\n      ASSERT (wcwidth (0xFF1A) == 2);\n#if 0  /* wchar_t may be only 16 bits.  */\n      ASSERT (wcwidth (0x20369) == 2);\n      ASSERT (wcwidth (0x2F876) == 2);\n#endif\n    }\n\n  return 0;\n}",
      "lines": 50,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-xalloc-die.c": {
    "main": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        29,
        1
      ],
      "content": "int\nmain (int argc _GL_UNUSED, char **argv)\n{\n  set_program_name (argv[0]);\n  xalloc_die ();\n  return 0;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-xstrtol.c": {
    "print_no_progname": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "static void\nprint_no_progname (void)\n{\n}",
      "lines": 4,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  strtol_error s_err;\n  int i;\n\n  program_name = argv[0];\n  error_print_progname = print_no_progname;\n\n  for (i = 1; i < argc; i++)\n    {\n      char *p;\n      __strtol_t val;\n\n      s_err = __xstrtol (argv[i], &p, 0, &val, \"bckMw0\");\n      if (s_err == LONGINT_OK)\n        {\n          printf (\"%s->%\" __spec \" (%s)\\n\", argv[i], val, p);\n        }\n      else\n        {\n          xstrtol_fatal (s_err, -2, 'X', NULL, argv[i]);\n        }\n    }\n  exit (0);\n}",
      "lines": 26,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/test-xstrtoul.c": {},
  "findutils/findutils-4.6.0/tests/test-xstrtoumax.c": {},
  "findutils/findutils-4.6.0/tests/test-yesno.c": {
    "main": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  int i = 1;\n  program_name = argv[0];\n\n  /* yesno recommends that all clients use close_stdin in main.  */\n  atexit (close_stdin);\n  /* But on mingw, close_stdin leaves stdin's file descriptor at the expected\n     position (i.e. where this program left off reading) only if its mode has\n     been set to O_BINARY.  If it has been set to O_TEXT, and the file\n     descriptor is seekable, and stdin is buffered, the MSVCRT runtime ends up\n     setting the file descriptor's position to the expected position _minus_\n     the number of LFs not preceded by CR that were read between the expected\n     position and the last filled buffer end position.  (I.e. the repositioning\n     from the end-of-buffer to the expected position does not work if the input\n     file contains end-of-line markers in Unix convention.)  */\n  SET_BINARY (0);\n\n  if (1 < argc)\n    i = atoi (argv[1]);\n  if (!i)\n    {\n      i = 1;\n      close (0);\n    }\n  while (i--)\n    puts (yesno () ? \"Y\" : \"N\");\n  return 0;\n}",
      "lines": 30,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/timespec-add.c": {
    "timespec_add": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "struct timespec\ntimespec_add (struct timespec a, struct timespec b)\n{\n  time_t rs = a.tv_sec;\n  time_t bs = b.tv_sec;\n  int ns = a.tv_nsec + b.tv_nsec;\n  int nsd = ns - TIMESPEC_RESOLUTION;\n  int rns = ns;\n  time_t tmin = TYPE_MINIMUM (time_t);\n  time_t tmax = TYPE_MAXIMUM (time_t);\n\n  if (0 <= nsd)\n    {\n      rns = nsd;\n      if (bs < tmax)\n        bs++;\n      else if (rs < 0)\n        rs++;\n      else\n        goto high_overflow;\n    }\n\n  /* INT_ADD_WRAPV is not appropriate since time_t might be unsigned.\n     In theory time_t might be narrower than int, so plain\n     INT_ADD_OVERFLOW does not suffice.  */\n  if (! INT_ADD_OVERFLOW (rs, bs) && tmin <= rs + bs && rs + bs <= tmax)\n    rs += bs;\n  else\n    {\n      if (rs < 0)\n        {\n          rs = tmin;\n          rns = 0;\n        }\n      else\n        {\n        high_overflow:\n          rs = tmax;\n          rns = TIMESPEC_RESOLUTION - 1;\n        }\n    }\n\n  return make_timespec (rs, rns);\n}",
      "lines": 44,
      "depth": 10,
      "decorators": [
        "struct timespec",
        "struct",
        "timespec"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/timespec-sub.c": {
    "timespec_sub": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "struct timespec\ntimespec_sub (struct timespec a, struct timespec b)\n{\n  time_t rs = a.tv_sec;\n  time_t bs = b.tv_sec;\n  int ns = a.tv_nsec - b.tv_nsec;\n  int rns = ns;\n  time_t tmin = TYPE_MINIMUM (time_t);\n  time_t tmax = TYPE_MAXIMUM (time_t);\n\n  if (ns < 0)\n    {\n      rns = ns + TIMESPEC_RESOLUTION;\n      if (bs < tmax)\n        bs++;\n      else if (- TYPE_SIGNED (time_t) < rs)\n        rs--;\n      else\n        goto low_overflow;\n    }\n\n  /* INT_SUBTRACT_WRAPV is not appropriate since time_t might be unsigned.\n     In theory time_t might be narrower than int, so plain\n     INT_SUBTRACT_OVERFLOW does not suffice.  */\n  if (! INT_SUBTRACT_OVERFLOW (rs, bs) && tmin <= rs - bs && rs - bs <= tmax)\n    rs -= bs;\n  else\n    {\n      if (rs < 0)\n        {\n        low_overflow:\n          rs = tmin;\n          rns = 0;\n        }\n      else\n        {\n          rs = tmax;\n          rns = TIMESPEC_RESOLUTION - 1;\n        }\n    }\n\n  return make_timespec (rs, rns);\n}",
      "lines": 43,
      "depth": 12,
      "decorators": [
        "struct timespec",
        "struct",
        "timespec"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/uinttostr.c": {},
  "findutils/findutils-4.6.0/tests/umaxtostr.c": {},
  "findutils/findutils-4.6.0/tests/unlinkdir.c": {
    "cannot_unlink_dir": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "bool\ncannot_unlink_dir (void)\n{\n  static bool initialized;\n  static bool cannot;\n\n  if (! initialized)\n    {\n# if defined PRIV_SYS_LINKDIR\n      /* We might be able to unlink directories if we cannot\n         determine our privileges, or if we have the\n         PRIV_SYS_LINKDIR privilege.  */\n      cannot = (priv_set_ismember (PRIV_SYS_LINKDIR) == 0);\n# else\n      /* In traditional Unix, only root can unlink directories.  */\n      cannot = (geteuid () != ROOT_UID);\n# endif\n      initialized = true;\n    }\n\n  return cannot;\n}",
      "lines": 22,
      "depth": 13,
      "decorators": [
        "bool"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/unlinkdir.h": {},
  "findutils/findutils-4.6.0/tests/w32sock.h": {
    "set_winsock_errno": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "static inline void\nset_winsock_errno (void)\n{\n  int err = WSAGetLastError ();\n\n  /* Map some WSAE* errors to the runtime library's error codes.  */\n  switch (err)\n    {\n    case WSA_INVALID_HANDLE:\n      errno = EBADF;\n      break;\n    case WSA_NOT_ENOUGH_MEMORY:\n      errno = ENOMEM;\n      break;\n    case WSA_INVALID_PARAMETER:\n      errno = EINVAL;\n      break;\n    case WSAENAMETOOLONG:\n      errno = ENAMETOOLONG;\n      break;\n    case WSAENOTEMPTY:\n      errno = ENOTEMPTY;\n      break;\n    case WSAEWOULDBLOCK:\n      errno = EWOULDBLOCK;\n      break;\n    case WSAEINPROGRESS:\n      errno = EINPROGRESS;\n      break;\n    case WSAEALREADY:\n      errno = EALREADY;\n      break;\n    case WSAENOTSOCK:\n      errno = ENOTSOCK;\n      break;\n    case WSAEDESTADDRREQ:\n      errno = EDESTADDRREQ;\n      break;\n    case WSAEMSGSIZE:\n      errno = EMSGSIZE;\n      break;\n    case WSAEPROTOTYPE:\n      errno = EPROTOTYPE;\n      break;\n    case WSAENOPROTOOPT:\n      errno = ENOPROTOOPT;\n      break;\n    case WSAEPROTONOSUPPORT:\n      errno = EPROTONOSUPPORT;\n      break;\n    case WSAEOPNOTSUPP:\n      errno = EOPNOTSUPP;\n      break;\n    case WSAEAFNOSUPPORT:\n      errno = EAFNOSUPPORT;\n      break;\n    case WSAEADDRINUSE:\n      errno = EADDRINUSE;\n      break;\n    case WSAEADDRNOTAVAIL:\n      errno = EADDRNOTAVAIL;\n      break;\n    case WSAENETDOWN:\n      errno = ENETDOWN;\n      break;\n    case WSAENETUNREACH:\n      errno = ENETUNREACH;\n      break;\n    case WSAENETRESET:\n      errno = ENETRESET;\n      break;\n    case WSAECONNABORTED:\n      errno = ECONNABORTED;\n      break;\n    case WSAECONNRESET:\n      errno = ECONNRESET;\n      break;\n    case WSAENOBUFS:\n      errno = ENOBUFS;\n      break;\n    case WSAEISCONN:\n      errno = EISCONN;\n      break;\n    case WSAENOTCONN:\n      errno = ENOTCONN;\n      break;\n    case WSAETIMEDOUT:\n      errno = ETIMEDOUT;\n      break;\n    case WSAECONNREFUSED:\n      errno = ECONNREFUSED;\n      break;\n    case WSAELOOP:\n      errno = ELOOP;\n      break;\n    case WSAEHOSTUNREACH:\n      errno = EHOSTUNREACH;\n      break;\n    default:\n      errno = (err > 10000 && err < 10025) ? err - 10000 : err;\n      break;\n    }\n}",
      "lines": 103,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/wctob.c": {
    "wctob": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "int\nwctob (wint_t wc)\n{\n  char buf[64];\n\n  if (!(MB_CUR_MAX <= sizeof (buf)))\n    abort ();\n  /* Handle the case where WEOF is a value that does not fit in a wchar_t.  */\n  if (wc == (wchar_t)wc)\n    if (wctomb (buf, (wchar_t)wc) == 1)\n      return (unsigned char) buf[0];\n  return EOF;\n}",
      "lines": 13,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/wctomb-impl.h": {
    "wctomb": {
      "start_point": [
        17,
        0
      ],
      "end_point": [
        33,
        1
      ],
      "content": "int\nwctomb (char *s, wchar_t wc)\n{\n  if (s == NULL)\n    return 0;\n  else\n    {\n      mbstate_t state;\n      size_t result;\n\n      memset (&state, 0, sizeof (mbstate_t));\n      result = wcrtomb (s, wc, &state);\n      if (result == (size_t)-1)\n        return -1;\n      return result;\n    }\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/wctomb.c": {},
  "findutils/findutils-4.6.0/tests/zerosize-ptr.h": {
    "zerosize_ptr": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "static void *\nzerosize_ptr (void)\n{\n/* Use mmap and mprotect when they exist.  Don't test HAVE_MMAP, because it is\n   not defined on HP-UX 11 (since it does not support MAP_FIXED).  */\n#if HAVE_SYS_MMAN_H && HAVE_MPROTECT\n# if HAVE_MAP_ANONYMOUS\n  const int flags = MAP_ANONYMOUS | MAP_PRIVATE;\n  const int fd = -1;\n# else /* !HAVE_MAP_ANONYMOUS */\n  const int flags = MAP_FILE | MAP_PRIVATE;\n  int fd = open (\"/dev/zero\", O_RDONLY, 0666);\n  if (fd >= 0)\n# endif\n    {\n      int pagesize = getpagesize ();\n      char *two_pages =\n        (char *) mmap (NULL, 2 * pagesize, PROT_READ | PROT_WRITE,\n                       flags, fd, 0);\n      if (two_pages != (char *)(-1)\n          && mprotect (two_pages + pagesize, pagesize, PROT_NONE) == 0)\n        return two_pages + pagesize;\n    }\n#endif\n  return NULL;\n}",
      "lines": 26,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nzerosize_ptr (void)",
        "*"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/glthread/thread.c": {
    "do_init_self_key": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        63,
        1
      ],
      "content": "static void\ndo_init_self_key (void)\n{\n  self_key = TlsAlloc ();\n  /* If this fails, we're hosed.  */\n  if (self_key == (DWORD)-1)\n    abort ();\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "init_self_key": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "static void\ninit_self_key (void)\n{\n  gl_once_define(static, once)\n  gl_once (once, do_init_self_key);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "get_current_thread_handle": {
      "start_point": [
        88,
        0
      ],
      "end_point": [
        100,
        1
      ],
      "content": "static HANDLE\nget_current_thread_handle (void)\n{\n  HANDLE this_handle;\n\n  /* GetCurrentThread() returns a pseudo-handle, i.e. only a symbolic\n     identifier, not a real handle.  */\n  if (!DuplicateHandle (GetCurrentProcess (), GetCurrentThread (),\n                        GetCurrentProcess (), &this_handle,\n                        0, FALSE, DUPLICATE_SAME_ACCESS))\n    abort ();\n  return this_handle;\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "HANDLE"
      ]
    },
    "gl_thread_self_func": {
      "start_point": [
        102,
        0
      ],
      "end_point": [
        132,
        1
      ],
      "content": "gl_thread_t\ngl_thread_self_func (void)\n{\n  gl_thread_t thread;\n\n  if (self_key == (DWORD)-1)\n    init_self_key ();\n  thread = TlsGetValue (self_key);\n  if (thread == NULL)\n    {\n      /* This happens only in threads that have not been created through\n         glthread_create(), such as the main thread.  */\n      for (;;)\n        {\n          thread =\n            (struct gl_thread_struct *)\n            malloc (sizeof (struct gl_thread_struct));\n          if (thread != NULL)\n            break;\n          /* Memory allocation failed.  There is not much we can do.  Have to\n             busy-loop, waiting for the availability of memory.  */\n          Sleep (1);\n        }\n\n      thread->handle = get_current_thread_handle ();\n      InitializeCriticalSection (&thread->handle_lock);\n      thread->result = NULL; /* just to be deterministic */\n      TlsSetValue (self_key, thread);\n    }\n  return thread;\n}",
      "lines": 31,
      "depth": 15,
      "decorators": [
        "gl_thread_t"
      ]
    },
    "wrapper_func": {
      "start_point": [
        136,
        0
      ],
      "end_point": [
        156,
        1
      ],
      "content": "static unsigned int WINAPI\nwrapper_func (void *varg)\n{\n  struct gl_thread_struct *thread = (struct gl_thread_struct *)varg;\n\n  EnterCriticalSection (&thread->handle_lock);\n  /* Create a new handle for the thread only if the parent thread did not yet\n     fill in the handle.  */\n  if (thread->handle == NULL)\n    thread->handle = get_current_thread_handle ();\n  LeaveCriticalSection (&thread->handle_lock);\n\n  if (self_key == (DWORD)-1)\n    init_self_key ();\n  TlsSetValue (self_key, thread);\n\n  /* Run the thread.  Store the exit value if the thread was not terminated\n     otherwise.  */\n  thread->result = thread->func (thread->arg);\n  return 0;\n}",
      "lines": 21,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "unsigned int",
        "unsigned",
        "int",
        "WINAPI",
        "WINAPI"
      ]
    },
    "glthread_create_func": {
      "start_point": [
        158,
        0
      ],
      "end_point": [
        196,
        1
      ],
      "content": "int\nglthread_create_func (gl_thread_t *threadp, void * (*func) (void *), void *arg)\n{\n  struct gl_thread_struct *thread =\n    (struct gl_thread_struct *) malloc (sizeof (struct gl_thread_struct));\n  if (thread == NULL)\n    return ENOMEM;\n  thread->handle = NULL;\n  InitializeCriticalSection (&thread->handle_lock);\n  thread->result = NULL; /* just to be deterministic */\n  thread->func = func;\n  thread->arg = arg;\n\n  {\n    unsigned int thread_id;\n    HANDLE thread_handle;\n\n    thread_handle = (HANDLE)\n      _beginthreadex (NULL, 100000, wrapper_func, thread, 0, &thread_id);\n      /* calls CreateThread with the same arguments */\n    if (thread_handle == NULL)\n      {\n        DeleteCriticalSection (&thread->handle_lock);\n        free (thread);\n        return EAGAIN;\n      }\n\n    EnterCriticalSection (&thread->handle_lock);\n    if (thread->handle == NULL)\n      thread->handle = thread_handle;\n    else\n      /* thread->handle was already set by the thread itself.  */\n      CloseHandle (thread_handle);\n    LeaveCriticalSection (&thread->handle_lock);\n\n    *threadp = thread;\n    return 0;\n  }\n}",
      "lines": 39,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "glthread_join_func": {
      "start_point": [
        198,
        0
      ],
      "end_point": [
        218,
        1
      ],
      "content": "int\nglthread_join_func (gl_thread_t thread, void **retvalp)\n{\n  if (thread == NULL)\n    return EINVAL;\n\n  if (thread == gl_thread_self ())\n    return EDEADLK;\n\n  if (WaitForSingleObject (thread->handle, INFINITE) == WAIT_FAILED)\n    return EINVAL;\n\n  if (retvalp != NULL)\n    *retvalp = thread->result;\n\n  DeleteCriticalSection (&thread->handle_lock);\n  CloseHandle (thread->handle);\n  free (thread);\n\n  return 0;\n}",
      "lines": 21,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "gl_thread_exit_func": {
      "start_point": [
        220,
        0
      ],
      "end_point": [
        227,
        1
      ],
      "content": "int\ngl_thread_exit_func (void *retval)\n{\n  gl_thread_t thread = gl_thread_self ();\n  thread->result = retval;\n  _endthreadex (0); /* calls ExitThread (0) */\n  abort ();\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/glthread/thread.h": {
    "gl_thread_create": {
      "start_point": [
        376,
        0
      ],
      "end_point": [
        386,
        1
      ],
      "content": "_GLTHREAD_THREAD_INLINE gl_thread_t\ngl_thread_create (void *(*func) (void *arg), void *arg)\n{\n  gl_thread_t thread;\n  int ret;\n\n  ret = glthread_create (&thread, func, arg);\n  if (ret != 0)\n    abort ();\n  return thread;\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "_GLTHREAD_THREAD_INLINE",
        "gl_thread_t",
        "gl_thread_t"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/glthread/yield.h": {},
  "findutils/findutils-4.6.0/tests/uniwidth/test-uc_width.c": {
    "main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "int\nmain ()\n{\n  ucs4_t uc;\n\n  /* Test width of ASCII characters.  */\n  for (uc = 0x0020; uc < 0x007F; uc++)\n    ASSERT (uc_width (uc, \"ISO-8859-2\") == 1);\n\n  /* Test width of some non-spacing characters.  */\n  ASSERT (uc_width (0x0301, \"UTF-8\") == 0);\n  ASSERT (uc_width (0x05B0, \"UTF-8\") == 0);\n\n  /* Test width of some format control characters.  */\n  ASSERT (uc_width (0x200E, \"UTF-8\") == 0);\n  ASSERT (uc_width (0x2060, \"UTF-8\") == 0);\n  ASSERT (uc_width (0xE0001, \"UTF-8\") == 0);\n  ASSERT (uc_width (0xE0044, \"UTF-8\") == 0);\n\n  /* Test width of some zero width characters.  */\n  ASSERT (uc_width (0x200B, \"UTF-8\") == 0);\n  ASSERT (uc_width (0xFEFF, \"UTF-8\") == 0);\n\n  /* Test width of some CJK characters.  */\n  ASSERT (uc_width (0x3000, \"UTF-8\") == 2);\n  ASSERT (uc_width (0xB250, \"UTF-8\") == 2);\n  ASSERT (uc_width (0xFF1A, \"UTF-8\") == 2);\n  ASSERT (uc_width (0x20369, \"UTF-8\") == 2);\n  ASSERT (uc_width (0x2F876, \"UTF-8\") == 2);\n\n  return 0;\n}",
      "lines": 32,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/tests/uniwidth/test-uc_width2.c": {
    "finish_interval": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "static void\nfinish_interval (void)\n{\n  if (current_width != 0)\n    {\n      if (current_start == current_end)\n        printf (\"%04X\\t\\t%c\\n\", (unsigned) current_start, current_width);\n      else\n        printf (\"%04X..%04X\\t%c\\n\", (unsigned) current_start,\n                (unsigned) current_end, current_width);\n      current_width = 0;\n    }\n}",
      "lines": 13,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "add_to_interval": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "static void\nadd_to_interval (ucs4_t uc, char width)\n{\n  if (current_width == width && uc == current_end + 1)\n    current_end = uc;\n  else\n    {\n      finish_interval ();\n      current_width = width;\n      current_start = current_end = uc;\n    }\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "int\nmain ()\n{\n  ucs4_t uc;\n\n  for (uc = 0; uc < 0x110000; uc++)\n    {\n      int w1 = uc_width (uc, \"UTF-8\");\n      int w2 = uc_width (uc, \"GBK\");\n      char width =\n        (w1 == 0 && w2 == 0 ? '0' :\n         w1 == 1 && w2 == 1 ? '1' :\n         w1 == 1 && w2 == 2 ? 'A' :\n         w1 == 2 && w2 == 2 ? '2' :\n         0);\n      if (width == 0)\n        {\n          /* uc must be a control character.  */\n          ASSERT (w1 < 0 && w2 < 0);\n        }\n      else\n        add_to_interval (uc, width);\n    }\n  finish_interval ();\n\n  return 0;\n}",
      "lines": 27,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "findutils/findutils-4.6.0/xargs/xargs.c": {
    "get_char_oct_or_hex_escape": {
      "start_point": [
        234,
        0
      ],
      "end_point": [
        298,
        1
      ],
      "content": "static char\nget_char_oct_or_hex_escape (const char *s)\n{\n  const char * p;\n  int base = 8;\n  unsigned long val;\n  char *endp;\n\n  assert ('\\\\' == s[0]);\n\n  if ('x' == s[1])\n    {\n      /* hex */\n      p = s+2;\n      base = 16;\n    }\n  else if (isdigit ((unsigned char) s[1]))\n    {\n      /* octal */\n      p = s+1;\n      base = 8;\n    }\n  else\n    {\n      p = NULL;\t\t\t/* Silence compiler warning. */\n      error (EXIT_FAILURE, 0,\n\t     _(\"Invalid escape sequence %s in input delimiter specification.\"),\n\t     s);\n    }\n  errno = 0;\n  endp = NULL;\n  val = strtoul (p, &endp, base);\n\n  /* This if condition is carefully constructed to do\n   * the right thing if UCHAR_MAX has the same\n   * value as ULONG_MAX.   IF UCHAR_MAX==ULONG_MAX,\n   * then val can never be greater than UCHAR_MAX.\n   */\n  if ((ULONG_MAX == val && ERANGE == errno)\n      || (val > UCHAR_MAX))\n    {\n      if (16 == base)\n\t{\n\t  error (EXIT_FAILURE, 0,\n\t\t _(\"Invalid escape sequence %s in input delimiter specification; character values must not exceed %lx.\"),\n\t\t s, (unsigned long)UCHAR_MAX);\n\t}\n      else\n\t{\n\t  error (EXIT_FAILURE, 0,\n\t\t _(\"Invalid escape sequence %s in input delimiter specification; character values must not exceed %lo.\"),\n\t\t s, (unsigned long)UCHAR_MAX);\n\t}\n    }\n\n  /* check for trailing garbage */\n  if (0 != *endp)\n    {\n      error (EXIT_FAILURE, 0,\n\t     _(\"Invalid escape sequence %s in input delimiter specification; trailing characters %s not recognised.\"),\n\t     s, endp);\n    }\n\n  return (char) val;\n}",
      "lines": 65,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "char"
      ]
    },
    "get_input_delimiter": {
      "start_point": [
        301,
        0
      ],
      "end_point": [
        344,
        1
      ],
      "content": "static char\nget_input_delimiter (const char *s)\n{\n  if (1 == strlen (s))\n    {\n      return s[0];\n    }\n  else\n    {\n      if ('\\\\' == s[0])\n\t{\n\t  /* an escape code */\n\t  switch (s[1])\n\t    {\n\t    case 'a':\n\t      return '\\a';\n\t    case 'b':\n\t      return '\\b';\n\t    case 'f':\n\t      return '\\f';\n\t    case 'n':\n\t      return '\\n';\n\t    case 'r':\n\t      return '\\r';\n\t    case 't':\n\t      return'\\t';\n\t    case 'v':\n\t      return '\\v';\n\t    case '\\\\':\n\t      return '\\\\';\n\t    default:\n\t      return get_char_oct_or_hex_escape (s);\n\t    }\n\t}\n      else\n\t{\n\t  error (EXIT_FAILURE, 0,\n\t\t _(\"Invalid input delimiter specification %s: the delimiter must be either a single character or an escape sequence starting with \\\\.\"),\n\t\t s);\n\t  /*NOTREACHED*/\n\t  return 0;\n\t}\n    }\n}",
      "lines": 44,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "char"
      ]
    },
    "noop": {
      "start_point": [
        346,
        0
      ],
      "end_point": [
        350,
        1
      ],
      "content": "static void\nnoop (void)\n{\n  /* does nothing. */\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "fail_due_to_env_size": {
      "start_point": [
        352,
        0
      ],
      "end_point": [
        356,
        1
      ],
      "content": "static void\nfail_due_to_env_size (void)\n{\n  error (EXIT_FAILURE, 0, _(\"environment is too large for exec\"));\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "smaller_of": {
      "start_point": [
        358,
        0
      ],
      "end_point": [
        365,
        1
      ],
      "content": "static size_t\nsmaller_of (size_t a, size_t b)\n{\n  if (a < b)\n    return a;\n  else\n    return b;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "fopen_cloexec_for_read_only": {
      "start_point": [
        368,
        0
      ],
      "end_point": [
        387,
        1
      ],
      "content": "static FILE* fopen_cloexec_for_read_only (const char *file_name)\n{\n  int fd = open_cloexec (file_name, O_RDONLY);\n  if (fd < 0)\n    {\n      return NULL;\n    }\n  else\n    {\n      FILE *result = fdopen (fd, \"r\");\n      if (!result)\n\t{\n\t  int saved_errno = errno;\n\t  close (fd);\n\t  errno = saved_errno;\n\t  return NULL;\n\t}\n      return result;\n    }\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "FILE",
        "* fopen_cloexec_for_read_only (const char *file_name)",
        "*"
      ]
    },
    "main": {
      "start_point": [
        390,
        0
      ],
      "end_point": [
        829,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  int optc, option_index;\n  int show_limits = 0;\t\t\t/* --show-limits */\n  int always_run_command = 1;\n  const char *input_file = \"-\"; /* \"-\" is stdin */\n  char default_cmd[] = \"echo\";\n  char *default_arglist[1];\n  int (*read_args) (void) = read_line;\n  void (*act_on_init_result)(void) = noop;\n  enum BC_INIT_STATUS bcstatus;\n  enum { XARGS_POSIX_HEADROOM = 2048u };\n  struct sigaction sigact;\n\n  if (argv[0])\n    set_program_name (argv[0]);\n  else\n    set_program_name (\"xargs\");\n\n  remember_non_cloexec_fds ();\n  parent = getpid ();\n  original_exit_value = EXIT_SUCCESS;\n\n#ifdef HAVE_SETLOCALE\n  setlocale (LC_ALL, \"\");\n#endif\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  if (atexit (close_stdin) || atexit (wait_for_proc_all))\n    {\n      error (EXIT_FAILURE, errno, _(\"The atexit library function failed\"));\n    }\n\n  /* xargs is required by POSIX to allow 2048 bytes of headroom\n   * for extra environment variables (that perhaps the utliity might\n   * want to set before execing something else).\n   */\n  bcstatus = bc_init_controlinfo (&bc_ctl, XARGS_POSIX_HEADROOM);\n\n  /* The bc_init_controlinfo call may have determined that the\n   * environment is too big.  In that case, we will fail with\n   * an error message after processing the command-line options,\n   * as \"xargs --help\" should still work even if the environment is\n   * too big.\n   *\n   * Some of the argument processing depends on the contents of\n   * bc_ctl, which will be in an undefined state if bc_init_controlinfo ()\n   * failed.\n   */\n  if (BC_INIT_ENV_TOO_BIG == bcstatus)\n    {\n      act_on_init_result = fail_due_to_env_size;\n    }\n  else if (BC_INIT_CANNOT_ACCOMODATE_HEADROOM == bcstatus)\n    {\n      /* All POSIX systems are required to support ARG_MAX of at least\n       * 4096.  For everything to work the total of (command line +\n       * headroom + environment) must fit into this.  POSIX requires\n       * that we use a headroom of 2048 bytes.  The user is in control\n       * of the size of the environment.\n       *\n       * In general if bc_init_controlinfo () returns\n       * BC_INIT_CANNOT_ACCOMODATE_HEADROOM, its caller can try again\n       * with a smaller headroom.  However, in the case of xargs, this\n       * would not be POSIX-compliant.\n       */\n      act_on_init_result = fail_due_to_env_size;\n    }\n  else\n    {\n      /* IEEE Std 1003.1, 2003 specifies that the combined argument and\n       * environment list shall not exceed {ARG_MAX}-2048 bytes.  It also\n       * specifies that it shall be at least LINE_MAX.\n       */\n      long val;\n#ifdef _SC_ARG_MAX\n      val = sysconf (_SC_ARG_MAX);\n      if (val > 0)\n\t{\n\t  assert (val > XARGS_POSIX_HEADROOM);\n\t  /* Note that val can in fact be greater than ARG_MAX\n\t   * and bc_ctl.arg_max can also be greater than ARG_MAX.\n\t   */\n\t  bc_ctl.arg_max = smaller_of (bc_ctl.arg_max,\n\t\t\t\t       (size_t)val-XARGS_POSIX_HEADROOM);\n\t}\n      else\n\t{\n# if defined ARG_MAX\n\t  assert (ARG_MAX > XARGS_POSIX_HEADROOM);\n\t  bc_ctl.arg_max = smaller_of (bc_ctl.arg_max,\n\t\t\t\t       (ARG_MAX - XARGS_POSIX_HEADROOM));\n# endif\n\t}\n#else\n      /* No _SC_ARG_MAX */\n      assert (ARG_MAX > XARGS_POSIX_HEADROOM);\n      bc_ctl.arg_max = smaller_of (bc_ctl.arg_max,\n\t\t\t\t   (ARG_MAX - XARGS_POSIX_HEADROOM));\n#endif\n\n\n#ifdef LINE_MAX\n      /* This assertion ensures that this xargs implementation\n       * conforms to the POSIX requirement that the default command\n       * line length shall be at least LINE_MAX.\n       */\n      assert (bc_ctl.arg_max >= LINE_MAX);\n#endif\n\n      bc_ctl.exec_callback = xargs_do_exec;\n\n      /* Start with a reasonable default size, though this can be\n       * adjusted via the -s option.\n       */\n      bc_use_sensible_arg_max (&bc_ctl);\n    }\n\n  while ((optc = getopt_long (argc, argv, \"+0a:E:e::i::I:l::L:n:prs:txP:d:\",\n\t\t\t      longopts, &option_index)) != -1)\n    {\n      switch (optc)\n\t{\n\tcase '0':\n\t  read_args = read_string;\n\t  input_delimiter = '\\0';\n\t  break;\n\n\tcase 'd':\n\t  read_args = read_string;\n\t  input_delimiter = get_input_delimiter (optarg);\n\t  break;\n\n\tcase 'E':\t\t/* POSIX */\n\tcase 'e':\t\t/* deprecated */\n\t  if (optarg && (strlen (optarg) > 0))\n\t    eof_str = optarg;\n\t  else\n\t    eof_str = 0;\n\t  break;\n\n\tcase 'h':\n\t  usage (stdout);\n\t  return 0;\n\n\tcase 'I':\t\t/* POSIX */\n\tcase 'i':\t\t/* deprecated */\n\t  if (optarg)\n\t    bc_ctl.replace_pat = optarg;\n\t  else\n\t    bc_ctl.replace_pat = \"{}\";\n\t  /* -i excludes -n -l.  */\n\t  bc_ctl.args_per_exec = 0;\n\t  bc_ctl.lines_per_exec = 0;\n\t  break;\n\n\tcase 'L':\t\t/* POSIX */\n\t  bc_ctl.lines_per_exec = parse_num (optarg, 'L', 1L, -1L, 1);\n\t  /* -L excludes -i -n.  */\n\t  bc_ctl.args_per_exec = 0;\n\t  bc_ctl.replace_pat = NULL;\n\t  break;\n\n\tcase 'l':\t\t/* deprecated */\n\t  if (optarg)\n\t    bc_ctl.lines_per_exec = parse_num (optarg, 'l', 1L, -1L, 1);\n\t  else\n\t    bc_ctl.lines_per_exec = 1;\n\t  /* -l excludes -i -n.  */\n\t  bc_ctl.args_per_exec = 0;\n\t  bc_ctl.replace_pat = NULL;\n\t  break;\n\n\tcase 'n':\n\t  bc_ctl.args_per_exec = parse_num (optarg, 'n', 1L, -1L, 1);\n\t  /* -n excludes -i -l.  */\n\t  bc_ctl.lines_per_exec = 0;\n\t  if (bc_ctl.args_per_exec == 1 && bc_ctl.replace_pat)\n\t    /* ignore -n1 in '-i -n1' */\n\t    bc_ctl.args_per_exec = 0;\n\t  else\n\t    bc_ctl.replace_pat = NULL;\n\t  break;\n\n\t  /* The POSIX standard specifies that it is not an error\n\t   * for the -s option to specify a size that the implementation\n\t   * cannot support - in that case, the relevant limit is used.\n\t   */\n\tcase 's':\n\t  {\n\t    size_t arg_size;\n\t    act_on_init_result ();\n\t    arg_size = parse_num (optarg, 's', 1L,\n\t\t\t\t  bc_ctl.posix_arg_size_max, 0);\n\t    if (arg_size > bc_ctl.posix_arg_size_max)\n\t      {\n\t\terror (0, 0,\n\t\t       _(\"warning: value %ld for -s option is too large, \"\n\t\t\t \"using %ld instead\"),\n\t\t       (long) arg_size, (long) bc_ctl.posix_arg_size_max);\n\t\targ_size = bc_ctl.posix_arg_size_max;\n\t      }\n\t    bc_ctl.arg_max = arg_size;\n\t  }\n\t  break;\n\n\tcase 'S':\n\t  show_limits = true;\n\t  break;\n\n\tcase 't':\n\t  print_command = true;\n\t  break;\n\n\tcase 'x':\n\t  bc_ctl.exit_if_size_exceeded = true;\n\t  break;\n\n\tcase 'p':\n\t  query_before_executing = true;\n\t  print_command = true;\n\t  break;\n\n\tcase 'r':\n\t  always_run_command = 0;\n\t  break;\n\n\tcase 'P':\n\t  /* Allow only up to MAX_PROC_MAX child processes. */\n\t  proc_max = parse_num (optarg, 'P', 0L, MAX_PROC_MAX, 1);\n\t  break;\n\n        case 'a':\n          input_file = optarg;\n          break;\n\n\tcase 'v':\n\t  display_findutils_version (\"xargs\");\n\t  return 0;\n\n\tcase PROCESS_SLOT_VAR:\n\t  if (strchr (optarg, '='))\n\t    {\n\t      error (EXIT_FAILURE, 0,\n\t\t     _(\"option --%s may not be set to a value which includes `='\"),\n\t\t     longopts[option_index].name);\n\t    }\n\t  slot_var_name = optarg;\n\t  if (0 != unsetenv (slot_var_name))\n\t    {\n\t      /* This is a fatal error, otherwise some child process\n\t\t may not be able to guarantee that no two children\n\t\t have the same value for this variable; see\n\t\t set_slot_var.\n\t      */\n\t      error (EXIT_FAILURE, errno,\n\t\t     _(\"failed to unset environment variable %s\"),\n\t\t     slot_var_name);\n\t    }\n\t  break;\n\n\tdefault:\n\t  usage (stderr);\n\t  return 1;\n\t}\n    }\n\n  if (eof_str && (read_args == read_string))\n    {\n      error (0, 0,\n\t     _(\"warning: the -E option has no effect if -0 or -d is used.\\n\"));\n    }\n\n  /* If we had deferred failing due to problems in bc_init_controlinfo (),\n   * do it now.\n   *\n   * We issue this error message after processing command line\n   * arguments so that it is possible to use \"xargs --help\" even if\n   * the environment is too large.\n   */\n  act_on_init_result ();\n  assert (BC_INIT_OK == bcstatus);\n\n#ifdef SIGUSR1\n#ifdef SIGUSR2\n  /* Accept signals to increase or decrease the number of running\n     child processes.  Do this as early as possible after setting\n     proc_max.  */\n  sigact.sa_handler = increment_proc_max;\n  sigemptyset(&sigact.sa_mask);\n  sigact.sa_flags = 0;\n  if (0 != sigaction (SIGUSR1, &sigact, (struct sigaction *)NULL))\n\t  error (0, errno, _(\"Cannot set SIGUSR1 signal handler\"));\n\n  sigact.sa_handler = decrement_proc_max;\n  sigemptyset(&sigact.sa_mask);\n  sigact.sa_flags = 0;\n  if (0 != sigaction (SIGUSR2, &sigact, (struct sigaction *)NULL))\n\t  error (0, errno, _(\"Cannot set SIGUSR2 signal handler\"));\n#endif /* SIGUSR2 */\n#endif /* SIGUSR1 */\n\n\n  if (0 == strcmp (input_file, \"-\"))\n    {\n      input_stream = stdin;\n    }\n  else\n    {\n      keep_stdin = 1;\t\t/* see prep_child_for_exec () */\n      input_stream = fopen_cloexec_for_read_only (input_file);\n      if (NULL == input_stream)\n\t{\n\t  error (EXIT_FAILURE, errno,\n\t\t _(\"Cannot open input file %s\"),\n\t\t quotearg_n_style (0, locale_quoting_style, input_file));\n\t}\n    }\n\n  if (bc_ctl.replace_pat || bc_ctl.lines_per_exec)\n    bc_ctl.exit_if_size_exceeded = true;\n\n  if (optind == argc)\n    {\n      optind = 0;\n      argc = 1;\n      default_arglist[0] = default_cmd;\n      argv = default_arglist;\n    }\n\n  if (show_limits)\n    {\n      fprintf (stderr,\n\t      _(\"Your environment variables take up %\" PRIuMAX \" bytes\\n\"),\n\t      (uintmax_t)bc_size_of_environment ());\n      fprintf (stderr,\n\t      _(\"POSIX upper limit on argument length (this system): %\" PRIuMAX \"\\n\"),\n\t      (uintmax_t)bc_ctl.posix_arg_size_max);\n      fprintf (stderr,\n\t      _(\"POSIX smallest allowable upper limit on argument length (all systems): %\" PRIuMAX \"\\n\"),\n\t      (uintmax_t)bc_ctl.posix_arg_size_min);\n      fprintf (stderr,\n\t      _(\"Maximum length of command we could actually use: %\" PRIuMAX \"\\n\"),\n\t      (uintmax_t)(bc_ctl.posix_arg_size_max - bc_size_of_environment ()));\n      fprintf (stderr,\n\t      _(\"Size of command buffer we are actually using: %\" PRIuMAX \"\\n\"),\n\t      (uintmax_t)bc_ctl.arg_max);\n      fprintf (stderr,\n\t      _(\"Maximum parallelism (--max-procs must be no greater): %\" PRIuMAX \"\\n\"),\n\t      (uintmax_t)MAX_PROC_MAX);\n\n      if (isatty (STDIN_FILENO))\n\t{\n\t  fprintf (stderr,\n\t\t  _(\"\\n\"\n\t\t    \"Execution of xargs will continue now, and it will \"\n\t\t    \"try to read its input and run commands; if this is \"\n\t\t    \"not what you wanted to happen, please type the \"\n\t\t    \"end-of-file keystroke.\\n\"));\n\t  if (always_run_command)\n\t    {\n\t      fprintf (stderr,\n\t\t      _(\"Warning: %s will be run at least once.  \"\n\t\t\t\"If you do not want that to happen, then press \"\n\t\t\t\"the interrupt keystroke.\\n\"),\n\t\t      argv[optind]);\n\t    }\n\t}\n    }\n\n  linebuf = xmalloc (bc_ctl.arg_max + 1);\n  bc_state.argbuf = xmalloc (bc_ctl.arg_max + 1);\n\n  /* Make sure to listen for the kids.  */\n  signal (SIGCHLD, SIG_DFL);\n\n  if (!bc_ctl.replace_pat)\n    {\n      for (; optind < argc; optind++)\n\tbc_push_arg (&bc_ctl, &bc_state,\n\t\t     argv[optind], strlen (argv[optind]) + 1,\n\t\t     NULL, 0,\n\t\t     initial_args);\n      initial_args = false;\n      bc_ctl.initial_argc = bc_state.cmd_argc;\n      bc_state.cmd_initial_argv_chars = bc_state.cmd_argv_chars;\n      bc_ctl.initial_argc = bc_state.cmd_argc;\n      /*fprintf (stderr, \"setting initial_argc=%d\\n\", bc_state.cmd_initial_argc);*/\n\n      while ((*read_args) () != -1)\n\tif (bc_ctl.lines_per_exec && lineno >= bc_ctl.lines_per_exec)\n\t  {\n\t    bc_do_exec (&bc_ctl, &bc_state);\n\t    lineno = 0;\n\t  }\n\n      /* SYSV xargs seems to do at least one exec, even if the\n         input is empty.  */\n      if (bc_state.cmd_argc != bc_ctl.initial_argc\n\t  || (always_run_command && procs_executed==0))\n\tbc_do_exec (&bc_ctl, &bc_state);\n\n    }\n  else\n    {\n      int i, args;\n      size_t *arglen = xmalloc (sizeof (size_t) * argc);\n\n      for (i = optind; i < argc; i++)\n\targlen[i] = strlen (argv[i]);\n      bc_ctl.rplen = strlen (bc_ctl.replace_pat);\n      while ((args = (*read_args) ()) != -1)\n\t{\n\t  size_t len = (size_t) args;\n\t  /* Don't do insert on the command name.  */\n\t  bc_clear_args (&bc_ctl, &bc_state);\n\t  bc_state.cmd_argv_chars = 0; /* begin at start of buffer */\n\n\t  bc_push_arg (&bc_ctl, &bc_state,\n\t\t       argv[optind], arglen[optind] + 1,\n\t\t       NULL, 0,\n\t\t       initial_args);\n\t  len--;\n\t  initial_args = false;\n\n\t  for (i = optind + 1; i < argc; i++)\n\t    bc_do_insert (&bc_ctl, &bc_state,\n\t\t\t  argv[i], arglen[i],\n\t\t\t  NULL, 0,\n\t\t\t  linebuf, len,\n\t\t\t  initial_args);\n\t  bc_do_exec (&bc_ctl, &bc_state);\n\t}\n    }\n\n  original_exit_value = child_error;\n  return child_error;\n}",
      "lines": 440,
      "depth": 18,
      "decorators": [
        "int"
      ]
    },
    "read_line": {
      "start_point": [
        839,
        0
      ],
      "end_point": [
        1012,
        1
      ],
      "content": "static int\nread_line (void)\n{\n/* States for read_line. */\n  enum read_line_state\n    {\n      NORM = 0,\n      SPACE = 1,\n      QUOTE = 2,\n      BACKSLASH = 3\n    };\n  static bool eof = false;\n  /* Start out in mode SPACE to always strip leading spaces (even with -i).  */\n  enum read_line_state state = SPACE; /* The type of character we last read.  */\n  int prevc;\t\t\t/* The previous value of c.  */\n  int quotc = 0;\t\t/* The last quote character read.  */\n  int c = EOF;\n  bool first = true;\t\t/* true if reading first arg on line.  */\n  bool seen_arg = false;      /* true if we have seen any arg (or part of one) yet */\n  int len;\n  char *p = linebuf;\n  /* Including the NUL, the args must not grow past this point.  */\n  char *endbuf = linebuf + bc_ctl.arg_max - bc_state.cmd_initial_argv_chars - 1;\n\n  if (eof)\n    return -1;\n  while (1)\n    {\n      prevc = c;\n      c = getc (input_stream);\n\n      if (c == EOF)\n\t{\n\t  /* COMPAT: SYSV seems to ignore stuff on a line that\n\t     ends without a \\n; we don't.  */\n\t  eof = true;\n\t  if (p == linebuf)\n\t    return -1;\n\t  *p++ = '\\0';\n\t  len = p - linebuf;\n\t  if (state == QUOTE)\n\t    {\n\t      exec_if_possible ();\n\t      error (EXIT_FAILURE, 0, _(\"unmatched %s quote; by default quotes are special to xargs unless you use the -0 option\"),\n\t\t     quotc == '\"' ? _(\"double\") : _(\"single\"));\n\t    }\n\t  if (first && EOF_STR (linebuf))\n\t    return -1;\n\t  if (!bc_ctl.replace_pat)\n\t    bc_push_arg (&bc_ctl, &bc_state,\n\t\t\t linebuf, len,\n\t\t\t NULL, 0,\n\t\t\t initial_args);\n\t  return len;\n\t}\n      switch (state)\n\t{\n\tcase SPACE:\n\t  if (ISSPACE (c))\n\t    continue;\n\t  state = NORM;\n\t  /* aaahhhh....  */\n\n\tcase NORM:\n\t  if (c == '\\n')\n\t    {\n\t      if (!ISBLANK (prevc))\n\t\tlineno++;\t/* For -l.  */\n\t      if (p == linebuf)\n\t\t{\n\t\t  if (seen_arg)\n\t\t    {\n\t\t      /* An empty argument, add it to the list as normal. */\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      /* Blank line.  */\n\t\t      state = SPACE;\n\t\t      continue;\n\t\t    }\n\t\t}\n\t      *p++ = '\\0';\n\t      len = p - linebuf;\n\t      if (EOF_STR (linebuf))\n\t\t{\n\t\t  eof = true;\n\t\t  return first ? -1 : len;\n\t\t}\n\t      if (!bc_ctl.replace_pat)\n\t\tbc_push_arg (&bc_ctl, &bc_state,\n\t\t\t     linebuf, len,\n\t\t\t     NULL, 0,\n\t\t\t     initial_args);\n\t      return len;\n\t    }\n\t  seen_arg = true;\n\n\t  /* POSIX: In the POSIX locale, the separators are <SPC> and\n\t   * <TAB>, but not <FF> or <VT>.\n\t   */\n\t  if (!bc_ctl.replace_pat && ISBLANK (c))\n\t    {\n\t      *p++ = '\\0';\n\t      len = p - linebuf;\n\t      if (EOF_STR (linebuf))\n\t\t{\n\t\t  eof = true;\n\t\t  return first ? -1 : len;\n\t\t}\n\t      bc_push_arg (&bc_ctl, &bc_state,\n\t\t\t   linebuf, len,\n\t\t\t   NULL, 0,\n\t\t\t   initial_args);\n\t      p = linebuf;\n\t      state = SPACE;\n\t      first = false;\n\t      continue;\n\t    }\n\t  switch (c)\n\t    {\n\t    case '\\\\':\n\t      state = BACKSLASH;\n\t      continue;\n\n\t    case '\\'':\n\t    case '\"':\n\t      state = QUOTE;\n\t      quotc = c;\n\t      continue;\n\t    }\n\t  break;\n\n\tcase QUOTE:\n\t  if (c == '\\n')\n\t    {\n\t      exec_if_possible ();\n\t      error (EXIT_FAILURE, 0, _(\"unmatched %s quote; by default quotes are special to xargs unless you use the -0 option\"),\n\t\t     quotc == '\"' ? _(\"double\") : _(\"single\"));\n\t    }\n\t  if (c == quotc)\n\t    {\n\t      state = NORM;\n\t      seen_arg = true; /* Makes a difference for e.g. just '' or \"\" as the first arg on a line */\n\t      continue;\n\t    }\n\t  break;\n\n\tcase BACKSLASH:\n\t  state = NORM;\n\t  break;\n\t}\n\n      if ( (0 == c) && !nullwarning_given )\n\t{\n\t  /* This is just a warning message.  We only issue it once. */\n\t  error (0, 0,\n\t\t _(\"WARNING: a NUL character occurred in the input.  \"\n\t\t   \"It cannot be passed through in the argument list.  \"\n\t\t   \"Did you mean to use the --null option?\"));\n\t  nullwarning_given = 1;\n\t}\n\n#if 1\n      if (p >= endbuf)\n        {\n\t  exec_if_possible ();\n\t  error (EXIT_FAILURE, 0, _(\"argument line too long\"));\n\t}\n      *p++ = c;\n#else\n      append_char_to_buf (&linebuf, &endbuf, &p, c);\n#endif\n    }\n}",
      "lines": 174,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "read_string": {
      "start_point": [
        1027,
        0
      ],
      "end_point": [
        1074,
        1
      ],
      "content": "static int\nread_string (void)\n{\n  static bool eof = false;\n  int len;\n  char *p = linebuf;\n  /* Including the NUL, the args must not grow past this point.  */\n  char *endbuf = linebuf + bc_ctl.arg_max - bc_state.cmd_initial_argv_chars - 1;\n\n  if (eof)\n    return -1;\n  while (1)\n    {\n      int c = getc (input_stream);\n      if (c == EOF)\n\t{\n\t  eof = true;\n\t  if (p == linebuf)\n\t    return -1;\n\t  *p++ = '\\0';\n\t  len = p - linebuf;\n\t  if (!bc_ctl.replace_pat)\n\t    bc_push_arg (&bc_ctl, &bc_state,\n\t\t\t linebuf, len,\n\t\t\t NULL, 0,\n\t\t\t initial_args);\n\t  return len;\n\t}\n      if (c == input_delimiter)\n\t{\n\t  lineno++;\t\t/* For -l.  */\n\t  *p++ = '\\0';\n\t  len = p - linebuf;\n\t  if (!bc_ctl.replace_pat)\n\t    bc_push_arg (&bc_ctl, &bc_state,\n\t\t\t linebuf, len,\n\t\t\t NULL, 0,\n\t\t\t initial_args);\n\t  return len;\n\t}\n      if (p >= endbuf)\n        {\n\t  exec_if_possible ();\n\t  error (EXIT_FAILURE, 0, _(\"argument line too long\"));\n\t}\n      *p++ = c;\n    }\n}",
      "lines": 48,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "print_args": {
      "start_point": [
        1081,
        0
      ],
      "end_point": [
        1120,
        1
      ],
      "content": "static bool\nprint_args (bool ask)\n{\n  size_t i;\n\n  for (i = 0; i < bc_state.cmd_argc - 1; i++)\n    {\n      if (fprintf (stderr, \"%s \", bc_state.cmd_argv[i]) < 0)\n\terror (EXIT_FAILURE, errno, _(\"Failed to write to stderr\"));\n    }\n\n  if (ask)\n    {\n      static FILE *tty_stream;\n      int c, savec;\n\n      if (!tty_stream)\n\t{\n\t  tty_stream = fopen_cloexec_for_read_only (\"/dev/tty\");\n\t  if (!tty_stream)\n\t    error (EXIT_FAILURE, errno,\n\t\t   _(\"failed to open /dev/tty for reading\"));\n\t}\n      fputs (\"?...\", stderr);\n      if (fflush (stderr) != 0)\n\terror (EXIT_FAILURE, errno, _(\"Failed to write to stderr\"));\n\n      c = savec = getc (tty_stream);\n      while (c != EOF && c != '\\n')\n\tc = getc (tty_stream);\n      if (EOF == c)\n\terror (EXIT_FAILURE, errno, _(\"Failed to read from stdin\"));\n      if (savec == 'y' || savec == 'Y')\n\treturn true;\n    }\n  else\n    putc ('\\n', stderr);\n\n  return false;\n}",
      "lines": 40,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "set_slot_var": {
      "start_point": [
        1123,
        0
      ],
      "end_point": [
        1169,
        1
      ],
      "content": "static void\nset_slot_var (unsigned int n)\n{\n  static const char *fmt = \"%u\";\n  int size;\n  char *buf;\n\n\n  /* Determine the length of the buffer we need.\n\n     If the result would be zero-length or have length (not value) >\n     INT_MAX, the assumptions we made about how snprintf behaves (or\n     what UINT_MAX is) are wrong.  Hence we have a design error (not\n     an environmental error).\n  */\n  size = snprintf (NULL, 0u, fmt, n);\n  assert (size > 0);\n\n\n  /* Failures here are undesirable but not fatal, since we can still\n     guarantee that this child does not have a duplicate value of the\n     indicated environment variable set (since the parent unset it on\n     startup).\n  */\n  if (NULL == (buf = malloc (size+1)))\n    {\n      error (0, errno, _(\"unable to allocate memory\"));\n    }\n  else\n    {\n      snprintf (buf, size+1, fmt, n);\n\n      /* If the user doesn't want us to set the variable, there is\n\t nothing to do.  However, we defer the bail-out until this\n\t point in order to get better test coverage.\n      */\n      if (slot_var_name)\n\t{\n\t  if (setenv (slot_var_name, buf, 1) < 0)\n\t    {\n\t      error (0, errno,\n\t\t     _(\"failed to set environment variable %s\"), slot_var_name);\n\t    }\n\t}\n      free (buf);\n    }\n}",
      "lines": 47,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "prep_child_for_exec": {
      "start_point": [
        1175,
        0
      ],
      "end_point": [
        1205,
        1
      ],
      "content": "static void\nprep_child_for_exec (void)\n{\n  complain_about_leaky_fds ();\n\n  /* The parent will call add_proc to allocate a slot.  We do the same in the\n     child to make sure we get the same value.\n\n     We use 0 here in order to avoid generating a data structure that appears\n     to indicate that we (the child) have a child. */\n  unsigned int slot = add_proc (0);\n  set_slot_var (slot);\n\n  if (!keep_stdin)\n    {\n      const char inputfile[] = \"/dev/null\";\n      /* fprintf (stderr, \"attaching stdin to /dev/null\\n\"); */\n\n      close (0);\n      if (open (inputfile, O_RDONLY) < 0)\n\t{\n\t  /* This is not entirely fatal, since\n\t   * executing the child with a closed\n\t   * stdin is almost as good as executing it\n\t   * with its stdin attached to /dev/null.\n\t   */\n\t  error (0, errno, \"%s\",\n\t\t quotearg_n_style (0, locale_quoting_style, inputfile));\n\t}\n    }\n}",
      "lines": 31,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "xargs_do_exec": {
      "start_point": [
        1216,
        0
      ],
      "end_point": [
        1384,
        1
      ],
      "content": "static int\nxargs_do_exec (struct buildcmd_control *ctl, void *usercontext, int argc, char **argv)\n{\n  pid_t child;\n  int fd[2];\n  int buf;\n  size_t r;\n\n  (void) ctl;\n  (void) argc;\n  (void) usercontext;\n\n  if (proc_max)\n    {\n      while (procs_executing >= proc_max)\n        {\n          wait_for_proc (false, 1u);\n        }\n    }\n\n  if (!query_before_executing || print_args (true))\n    {\n      if (!query_before_executing && print_command)\n\tprint_args (false);\n\n      /* Before forking, reap any already-exited child. We do this so\n\t that we don't leave unreaped children around while we build a\n\t new command line.  For example this command will spend most\n\t of its time waiting for sufficient arguments to launch\n\t another command line:\n\n\t seq 1 1000 | fmt | while read x ; do echo $x; sleep 1 ; done |\n\t ./xargs -P 200 -n 20  sh -c 'echo \"$@\"; sleep $((1 + $RANDOM % 5))' sleeper\n      */\n      wait_for_proc (false, 0u);\n\n      if (pipe (fd))\n\terror (EXIT_FAILURE, errno, _(\"could not create pipe before fork\"));\n      fcntl (fd[1], F_SETFD, FD_CLOEXEC);\n\n      /* If we run out of processes, wait for a child to return and\n         try again.  */\n      while ((child = fork ()) < 0 && errno == EAGAIN && procs_executing)\n\twait_for_proc (false, 1u);\n\n      switch (child)\n\t{\n\tcase -1:\n\t  error (EXIT_FAILURE, errno, _(\"cannot fork\"));\n\n\tcase 0:\t\t/* Child.  */\n\t  {\n\t    close (fd[0]);\n\t    child_error = EXIT_SUCCESS;\n\n\t    prep_child_for_exec ();\n\n\t    if (bc_args_exceed_testing_limit (argv))\n\t      errno = E2BIG;\n\t    else\n\t      execvp (argv[0], argv);\n\t    if (errno)\n\t      {\n\t\t/* Write errno value to parent.  We do this even if\n\t\t * the error was not E2BIG, because we need to\n\t\t * distinguish successful execs from unsuccessful\n\t\t * ones.  The reason we need to do this is to know\n\t\t * whether to reap the child here (preventing the\n\t\t * exit status processing in wait_for_proc () from\n\t\t * changing the value of child_error) or leave it\n\t\t * for wait_for_proc () to handle.  We need to have\n\t\t * wait_for_proc () handle the exit values from the\n\t\t * utility if we run it, for POSIX compliance on the\n\t\t * handling of exit values.\n\t\t */\n\t\twrite (fd[1], &errno, sizeof (int));\n\t      }\n\n\t    close (fd[1]);\n\t    if (E2BIG != errno)\n\t      {\n\t\terror (0, errno, \"%s\", argv[0]);\n\t      }\n\t    /* The actual value returned here should be irrelevant,\n\t     * because the parent will test our value of errno.\n\t     */\n\t    _exit (errno == ENOENT ? XARGS_EXIT_COMMAND_NOT_FOUND : XARGS_EXIT_COMMAND_CANNOT_BE_RUN);\n\n\t  /*NOTREACHED*/\n\t  } /* child */\n\n\tdefault:\n\t  {\n\t    /* Parent */\n\t    close (fd[1]);\n\t  }\n\n\t} /* switch (child) */\n      /*fprintf (stderr, \"forked child (bc_state.cmd_argc=%d) -> \", bc_state.cmd_argc);*/\n\n      /* We use safe_read here in order to avoid an error if\n\t SIGUSR[12] is handled during the read system call. */\n      switch (r = safe_read (fd[0], &buf, sizeof (int)))\n\t{\n\tcase SAFE_READ_ERROR:\n\t  {\n\t    close (fd[0]);\n\t    error (0, errno,\n\t\t   _(\"errno-buffer safe_read failed in xargs_do_exec \"\n\t\t     \"(this is probably a bug, please report it)\"));\n\t    break;\n\t  }\n\n\tcase sizeof (int):\n\t  {\n\t    /* Failure */\n\t    int childstatus;\n\n\t    close (fd[0]);\n\n\t    /* we know the child is about to exit, so wait for that.\n\t     * We have to do this so that wait_for_proc () does not\n\t     * change the value of child_error on the basis of the\n\t     * return value -- since in this case we did not launch\n\t     * the utility.\n\t     *\n\t     * We do the wait before deciding if we failed in order to\n\t     * avoid creating a zombie, even briefly.\n\t     */\n\t    waitpid (child, &childstatus, 0);\n\n\n\t    if (E2BIG == buf)\n\t      {\n\t\treturn 0; /* Failure; caller should pass fewer args */\n\t      }\n\t    else if (ENOENT == buf)\n\t      {\n\t\texit (XARGS_EXIT_COMMAND_NOT_FOUND); /* command cannot be found */\n\t      }\n\t    else\n\t      {\n\t\texit (XARGS_EXIT_COMMAND_CANNOT_BE_RUN); /* command cannot be run */\n\t      }\n\t    break;\n\t  }\n\n\tcase 0:\n\t  {\n\t    /* Failed to read data from pipe; the exec must have\n\t     * succeeded.  We call add_proc only in this case,\n\t     * because it increments procs_executing, and we only\n\t     * want to do that if we didn't already wait for the\n\t     * child.\n\t     */\n\t    add_proc (child);\n\t    break;\n\t  }\n\tdefault:\n\t  {\n\t    error (EXIT_FAILURE, errno,\n\t\t   _(\"read returned unexpected value %zu; \"\n\t\t     \"this is probably a bug, please report it\"), r);\n\t  }\n\t} /* switch on bytes read */\n      close (fd[0]);\n    }\n  return 1;\t\t\t/* Success */\n}",
      "lines": 169,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "exec_if_possible": {
      "start_point": [
        1388,
        0
      ],
      "end_point": [
        1395,
        1
      ],
      "content": "static void\nexec_if_possible (void)\n{\n  if (bc_ctl.replace_pat || initial_args ||\n      bc_state.cmd_argc == bc_ctl.initial_argc || bc_ctl.exit_if_size_exceeded)\n    return;\n  bc_do_exec (&bc_ctl, &bc_state);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "add_proc": {
      "start_point": [
        1400,
        0
      ],
      "end_point": [
        1426,
        1
      ],
      "content": "static unsigned int\nadd_proc (pid_t pid)\n{\n  unsigned int i, j;\n\n  /* Find an empty slot.  */\n  for (i = 0; i < pids_alloc && pids[i]; i++)\n    ;\n\n  /* Extend the array if we failed. */\n  if (i == pids_alloc)\n    {\n      pids = x2nrealloc (pids, &pids_alloc, sizeof *pids);\n\n      /* Zero out the new slots. */\n      for (j=i; j<pids_alloc; ++j)\n\tpids[j] = (pid_t)0;\n    }\n  /* Verify that we are not destroying the record of some existing child. */\n  assert (0 == pids[i]);\n\n  /* Remember the child. */\n  pids[i] = pid;\n  procs_executing++;\n  procs_executed = true;\n  return i;\n}",
      "lines": 27,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "unsigned int",
        "unsigned",
        "int"
      ]
    },
    "wait_for_proc": {
      "start_point": [
        1434,
        0
      ],
      "end_point": [
        1532,
        1
      ],
      "content": "static void\nwait_for_proc (bool all, unsigned int minreap)\n{\n  unsigned int reaped = 0;\n\n  while (procs_executing)\n    {\n      unsigned int i;\n      int status;\n      pid_t pid;\n      int wflags = 0;\n\n      if (!all)\n\t{\n\t  if (reaped >= minreap)\n\t    {\n\t      /* We already reaped enough children.  To save system\n\t       * resources, reap any dead children anyway, but do not\n\t       * wait for any currently executing children to exit.\n\n\t       */\n\t      wflags = WNOHANG;\n\t    }\n\t}\n\n      stop_waiting = 0;\n      do\n\t{\n\t  /* Wait for any child.   We used to use wait () here, but it's\n\t   * unlikely that that offers any portability advantage over\n\t   * wait these days.\n\t   */\n\t  while ((pid = waitpid (-1, &status, wflags)) == (pid_t) -1)\n\t    {\n\t      if (errno != EINTR)\n\t\terror (EXIT_FAILURE, errno,\n\t\t       _(\"error waiting for child process\"));\n\n\t      if (stop_waiting && !all)\n\t\t{\n\t\t  /* Receipt of SIGUSR1 gave us an extra slot and we\n\t\t   * don't need to wait for all processes to finish.\n\t\t   * We can stop reaping now, but in any case check for\n\t\t   * further dead children without waiting for another\n\t\t   * to exit.\n\t\t   */\n\t\t  wflags = WNOHANG;\n\t\t}\n\t    }\n\n\t  /* Find the entry in `pids' for the child process\n\t     that exited.  */\n\t  if (pid)\n\t    {\n\t      for (i = 0; i < pids_alloc && pid != pids[i]; i++)\n\t\t;\n\t    }\n\t}\n      while (pid && i == pids_alloc);\t/* A child died that we didn't start? */\n\n      if (!pid)\n\t{\n\t  if (!(wflags & WNOHANG))\n\t    {\n\t      /* Nothing remained to be reaped.  This should not\n\t       * happen, because procs_executing should contain the\n\t       * number of child processes still executing, so the\n\t       * loop should have terminated.\n\t       */\n\t      error (0, 0, _(\"WARNING: Lost track of %lu child processes\"),\n\t\t     procs_executing);\n\t    }\n\t  else\n\t    {\n\t      /* Children are (probably) executing but are not ready\n\t       * to be reaped at the moment.\n\t       */\n\t    }\n\t  break;\n\t}\n\n      /* Remove the child from the list.  */\n      pids[i] = 0;\n      procs_executing--;\n      reaped++;\n\n      if (WEXITSTATUS (status) == CHILD_EXIT_PLEASE_STOP_IMMEDIATELY)\n\terror (XARGS_EXIT_CLIENT_EXIT_255, 0,\n\t       _(\"%s: exited with status 255; aborting\"), bc_state.cmd_argv[0]);\n      if (WIFSTOPPED (status))\n\terror (XARGS_EXIT_CLIENT_FATAL_SIG, 0,\n\t       _(\"%s: stopped by signal %d\"), bc_state.cmd_argv[0], WSTOPSIG (status));\n      if (WIFSIGNALED (status))\n\terror (XARGS_EXIT_CLIENT_FATAL_SIG, 0,\n\t       _(\"%s: terminated by signal %d\"), bc_state.cmd_argv[0], WTERMSIG (status));\n      if (WEXITSTATUS (status) != 0)\n\tchild_error = XARGS_EXIT_CLIENT_EXIT_NONZERO;\n    }\n}",
      "lines": 99,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "wait_for_proc_all": {
      "start_point": [
        1536,
        0
      ],
      "end_point": [
        1569,
        1
      ],
      "content": "static void\nwait_for_proc_all (void)\n{\n  static bool waiting = false;\n\n  /* This function was registered by the original, parent, process.\n   * The child processes must not call exit () to terminate, since this\n   * will mean that their exit status will be inappropriately changed.\n   * Instead the child processes should call _exit ().  If someone\n   * forgets this rule, you may see the following assert () fail.\n   */\n  assert (getpid () == parent);\n\n  if (waiting)\n    return;\n\n  waiting = true;\n  wait_for_proc (true, 0u);\n  waiting = false;\n\n  if (original_exit_value != child_error)\n    {\n      /* wait_for_proc () changed the value of child_error ().  This\n       * function is registered via atexit (), and so may have been\n       * called from exit ().  We now know that the original value\n       * passed to exit () is no longer the exit status we require.\n       * The POSIX standard states that the behaviour if exit () is\n       * called more than once is undefined.  Therefore we now have to\n       * exit with _exit () instead of exit ().\n       */\n      _exit (child_error);\n    }\n\n}",
      "lines": 34,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "increment_proc_max": {
      "start_point": [
        1577,
        0
      ],
      "end_point": [
        1587,
        1
      ],
      "content": "static void\nincrement_proc_max (int ignore)\n{\n        (void) ignore;\n\t/* If user increments from 0 to 1, we'll take it and serialize. */\n\tif (proc_max < MAX_PROC_MAX)\n\t  proc_max++;\n\t/* If we're waiting for a process to die before doing something,\n\t   no need to wait any more. */\n\tstop_waiting = 1;\n}",
      "lines": 11,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "decrement_proc_max": {
      "start_point": [
        1589,
        0
      ],
      "end_point": [
        1595,
        1
      ],
      "content": "static void\ndecrement_proc_max (int ignore)\n{\n        (void) ignore;\n\tif (proc_max > 1)\n\t\tproc_max--;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "parse_num": {
      "start_point": [
        1604,
        0
      ],
      "end_point": [
        1647,
        1
      ],
      "content": "static long\nparse_num (char *str, int option, long int min, long int max, int fatal)\n{\n  char *eptr;\n  long val;\n\n  val = strtol (str, &eptr, 10);\n  if (eptr == str || *eptr)\n    {\n      fprintf (stderr, _(\"%s: invalid number for -%c option\\n\"),\n\t       program_name, option);\n      usage (stderr);\n      exit (EXIT_FAILURE);\n    }\n  else if (val < min)\n    {\n      fprintf (stderr, _(\"%s: value for -%c option should be >= %ld\\n\"),\n\t       program_name, option, min);\n      if (fatal)\n\t{\n\t  usage (stderr);\n\t  exit (EXIT_FAILURE);\n\t}\n      else\n\t{\n\t  val = min;\n\t}\n    }\n  else if (max >= 0 && val > max)\n    {\n      fprintf (stderr, _(\"%s: value for -%c option should be <= %ld\\n\"),\n\t       program_name, option, max);\n      if (fatal)\n\t{\n\t  usage (stderr);\n\t  exit (EXIT_FAILURE);\n\t}\n      else\n\t{\n\t  val = max;\n\t}\n    }\n  return val;\n}",
      "lines": 44,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "long",
        "long"
      ]
    },
    "usage": {
      "start_point": [
        1649,
        0
      ],
      "end_point": [
        1698,
        1
      ],
      "content": "static void\nusage (FILE *stream)\n{\n  fprintf (stream,\n           _(\"Usage: %s [OPTION]... COMMAND [INITIAL-ARGS]...\\n\"),\n           program_name);\n\n#define HTL(t) fputs (t, stream);\n\n  HTL (_(\"Run COMMAND with arguments INITIAL-ARGS and more arguments read from input.\\n\"\n         \"\\n\"));\n  HTL (_(\"Mandatory and optional arguments to long options are also\\n\"\n         \"mandatory or optional for the corresponding short option.\\n\"));\n  HTL (_(\"  -0, --null                   items are separated by a null, not whitespace;\\n\"\n         \"                                 disables quote and backslash processing and\\n\"\n\t \"                                 logical EOF processing\\n\"));\n  HTL (_(\"  -a, --arg-file=FILE          read arguments from FILE, not standard input\\n\"));\n  HTL (_(\"  -d, --delimiter=CHARACTER    items in input stream are separated by CHARACTER,\\n\"\n         \"                                 not by whitespace; disables quote and backslash\\n\"\n         \"                                 processing and logical EOF processing\\n\"));\n  HTL (_(\"  -E END                       set logical EOF string; if END occurs as a line\\n\"\n\t \"                                 of input, the rest of the input is ignored\\n\"\n\t \"                                 (ignored if -0 or -d was specified)\\n\"));\n  HTL (_(\"  -e, --eof[=END]              equivalent to -E END if END is specified;\\n\"\n         \"                                 otherwise, there is no end-of-file string\\n\"));\n  HTL (_(\"  -I R                         same as --replace=R\\n\"));\n  HTL (_(\"  -i, --replace[=R]            replace R in INITIAL-ARGS with names read\\n\"\n         \"                                 from standard input; if R is unspecified,\\n\"\n         \"                                 assume {}\\n\"));\n  HTL (_(\"  -L, --max-lines=MAX-LINES    use at most MAX-LINES non-blank input lines per\\n\"\n         \"                                 command line\\n\"));\n  HTL (_(\"  -l[MAX-LINES]                similar to -L but defaults to at most one non-\\n\"\n         \"                                 blank input line if MAX-LINES is not specified\\n\"));\n  HTL (_(\"  -n, --max-args=MAX-ARGS      use at most MAX-ARGS arguments per command line\\n\"));\n  HTL (_(\"  -P, --max-procs=MAX-PROCS    run at most MAX-PROCS processes at a time\\n\"));\n  HTL (_(\"  -p, --interactive            prompt before running commands\\n\"));\n  HTL (_(\"      --process-slot-var=VAR   set environment variable VAR in child processes\\n\"));\n  HTL (_(\"  -r, --no-run-if-empty        if there are no arguments, then do not run COMMAND;\\n\"\n         \"                                 if this option is not given, COMMAND will be\\n\"\n         \"                                 run at least once\\n\"));\n  HTL (_(\"  -s, --max-chars=MAX-CHARS    limit length of command line to MAX-CHARS\\n\"));\n  HTL (_(\"      --show-limits            show limits on command-line length\\n\"));\n  HTL (_(\"  -t, --verbose                print commands before executing them\\n\"));\n  HTL (_(\"  -x, --exit                   exit if the size (see -s) is exceeded\\n\"));\n\n  HTL (_(\"      --help                   display this help and exit\\n\"));\n  HTL (_(\"      --version                output version information and exit\\n\"));\n  HTL (_(\"\\n\"\n         \"Report bugs to <bug-findutils@gnu.org>.\\n\"));\n}",
      "lines": 50,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  }
}