{
  "gawk/gawk-4.2.1/array.c": {
    "register_array_func": {
      "start_point": [
        63,
        0
      ],
      "end_point": [
        75,
        1
      ],
      "content": "int\nregister_array_func(afunc_t *afunc)\n{\n\tif (afunc && num_array_types < MAX_ATYPE) {\n\t\tif (afunc != str_array_func && ! afunc[AFUNC(atypeof)])\n\t\t\treturn false;\n\t\tarray_types[num_array_types++] = afunc;\n\t\tif (afunc[AFUNC(ainit)])\t/* execute init routine if any */\n\t\t\t(void) (*afunc[AFUNC(ainit)])(NULL, NULL);\n\t\treturn true;\n\t}\n\treturn false;\n}",
      "lines": 13,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "array_init": {
      "start_point": [
        80,
        0
      ],
      "end_point": [
        88,
        1
      ],
      "content": "void\narray_init()\n{\n\t(void) register_array_func(str_array_func);\t/* the default */\n\tif (! do_mpfr) {\n\t\t(void) register_array_func(int_array_func);\n\t\t(void) register_array_func(cint_array_func);\n\t}\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "make_array": {
      "start_point": [
        93,
        0
      ],
      "end_point": [
        104,
        1
      ],
      "content": "NODE *\nmake_array()\n{\n\tNODE *array;\n\tgetnode(array);\n\tmemset(array, '\\0', sizeof(NODE));\n\tarray->type = Node_var_array;\n\tarray->array_funcs = null_array_func;\n\t/* vname, flags, and parent_array not set here */\n\n\treturn array;\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "NODE",
        "*\nmake_array()",
        "*"
      ]
    },
    "null_array": {
      "start_point": [
        109,
        0
      ],
      "end_point": [
        122,
        1
      ],
      "content": "void\nnull_array(NODE *symbol)\n{\n\tsymbol->type = Node_var_array;\n\tsymbol->array_funcs = null_array_func;\n\tsymbol->buckets = NULL;\n\tsymbol->table_size = symbol->array_size = 0;\n\tsymbol->array_capacity = 0;\n\tsymbol->flags = 0;\n\n\tassert(symbol->xarray == NULL);\n\n\t/* vname, parent_array not (re)initialized */\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "null_lookup": {
      "start_point": [
        127,
        0
      ],
      "end_point": [
        150,
        1
      ],
      "content": "static NODE **\nnull_lookup(NODE *symbol, NODE *subs)\n{\n\tint i;\n\tafunc_t *afunc = NULL;\n\n\tassert(symbol->table_size == 0);\n\n\t/*\n\t * Check which array type wants to accept this sub; traverse\n\t * array type list in reverse order.\n\t */\n\tfor (i = num_array_types - 1; i >= 1; i--) {\n\t\tafunc = array_types[i];\n\t\tif (afunc[AFUNC(atypeof)](symbol, subs) != NULL)\n\t\t\tbreak;\n\t}\n\tif (i == 0 || afunc == NULL)\n\t\tafunc = array_types[0];\t/* default is str_array_func */\n\tsymbol->array_funcs = afunc;\n\n\t/* We have the right type of array; install the subscript */\n\treturn symbol->alookup(symbol, subs);\n}",
      "lines": 24,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "NODE",
        "**\nnull_lookup(NODE *symbol, NODE *subs)",
        "*",
        "*\nnull_lookup(NODE *symbol, NODE *subs)",
        "*"
      ]
    },
    "null_length": {
      "start_point": [
        154,
        0
      ],
      "end_point": [
        160,
        1
      ],
      "content": "NODE **\nnull_length(NODE *symbol, NODE *subs ATTRIBUTE_UNUSED)\n{\n\tstatic NODE *tmp;\n\ttmp = symbol;\n\treturn & tmp;\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "NODE",
        "**\nnull_length(NODE *symbol, NODE *subs ATTRIBUTE_UNUSED)",
        "*",
        "*\nnull_length(NODE *symbol, NODE *subs ATTRIBUTE_UNUSED)",
        "*"
      ]
    },
    "null_dump": {
      "start_point": [
        172,
        0
      ],
      "end_point": [
        177,
        1
      ],
      "content": "static NODE **\nnull_dump(NODE *symbol, NODE *subs ATTRIBUTE_UNUSED)\n{\n\tfprintf(output_fp, \"array `%s' is empty\\n\", array_vname(symbol));\n\treturn NULL;\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "NODE",
        "**\nnull_dump(NODE *symbol, NODE *subs ATTRIBUTE_UNUSED)",
        "*",
        "*\nnull_dump(NODE *symbol, NODE *subs ATTRIBUTE_UNUSED)",
        "*"
      ]
    },
    "assoc_copy": {
      "start_point": [
        182,
        0
      ],
      "end_point": [
        192,
        1
      ],
      "content": "NODE *\nassoc_copy(NODE *symbol, NODE *newsymb)\n{\n\tassert(newsymb->vname != NULL);\n\n\tassoc_clear(newsymb);\n\t(void) symbol->acopy(symbol, newsymb);\n\tnewsymb->array_funcs = symbol->array_funcs;\n\tnewsymb->flags = symbol->flags;\n\treturn newsymb;\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "NODE",
        "*\nassoc_copy(NODE *symbol, NODE *newsymb)",
        "*"
      ]
    },
    "assoc_dump": {
      "start_point": [
        197,
        0
      ],
      "end_point": [
        202,
        1
      ],
      "content": "void\nassoc_dump(NODE *symbol, NODE *ndump)\n{\n\tif (symbol->adump)\n\t\t(void) symbol->adump(symbol, ndump);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "make_aname": {
      "start_point": [
        207,
        0
      ],
      "end_point": [
        237,
        1
      ],
      "content": "const char *\nmake_aname(const NODE *symbol)\n{\n\tstatic char *aname = NULL;\n\tstatic size_t alen;\n\tstatic size_t max_alen;\n#define SLEN 256\n\n\tif (symbol->parent_array != NULL) {\n\t\tsize_t slen;\n\n\t\t(void) make_aname(symbol->parent_array);\n\t\tslen = strlen(symbol->vname);\t/* subscript in parent array */\n\t\tif (alen + slen + 4 > max_alen) {\t\t/* sizeof(\"[\\\"\\\"]\") = 4 */\n\t\t\tmax_alen = alen + slen + 4 + SLEN;\n\t\t\terealloc(aname, char *, (max_alen + 1) * sizeof(char *), \"make_aname\");\n\t\t}\n\t\talen += sprintf(aname + alen, \"[\\\"%s\\\"]\", symbol->vname);\n\t} else {\n\t\talen = strlen(symbol->vname);\n\t\tif (aname == NULL) {\n\t\t\tmax_alen = alen + SLEN;\n\t\t\temalloc(aname, char *, (max_alen + 1) * sizeof(char *), \"make_aname\");\n\t\t} else if (alen > max_alen) {\n\t\t\tmax_alen = alen + SLEN;\n\t\t\terealloc(aname, char *, (max_alen + 1) * sizeof(char *), \"make_aname\");\n\t\t}\n\t\tmemcpy(aname, symbol->vname, alen + 1);\n\t}\n\treturn aname;\n}",
      "lines": 31,
      "depth": 15,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nmake_aname(const NODE *symbol)",
        "*"
      ]
    },
    "array_vname": {
      "start_point": [
        249,
        0
      ],
      "end_point": [
        322,
        1
      ],
      "content": "const char *\narray_vname(const NODE *symbol)\n{\n\tstatic char *message = NULL;\n\tstatic size_t msglen = 0;\n\tchar *s;\n\tsize_t len;\n\tint n;\n\tconst NODE *save_symbol = symbol;\n\tconst char *from = _(\"from %s\");\n\tconst char *aname;\n\n\tif (symbol->type != Node_array_ref\n\t\t\t|| symbol->orig_array->type != Node_var_array\n\t) {\n\t\tif (symbol->type != Node_var_array || symbol->parent_array == NULL)\n\t\t\treturn symbol->vname;\n\t\treturn make_aname(symbol);\n\t}\n\n\t/* First, we have to compute the length of the string: */\n\n\tlen = 2; /* \" (\" */\n\tn = 0;\n\twhile (symbol->type == Node_array_ref) {\n\t\tlen += strlen(symbol->vname);\n\t\tn++;\n\t\tsymbol = symbol->prev_array;\n\t}\n\n\t/* Get the (sub)array name */\n\tif (symbol->parent_array == NULL)\n\t\taname = symbol->vname;\n\telse\n\t\taname = make_aname(symbol);\n\tlen += strlen(aname);\n\t/*\n\t * Each node contributes by strlen(from) minus the length\n\t * of \"%s\" in the translation (which is at least 2)\n\t * plus 2 for \", \" or \")\\0\"; this adds up to strlen(from).\n\t */\n\tlen += n * strlen(from);\n\n\t/* (Re)allocate memory: */\n\tif (message == NULL) {\n\t\temalloc(message, char *, len, \"array_vname\");\n\t\tmsglen = len;\n\t} else if (len > msglen) {\n\t\terealloc(message, char *, len, \"array_vname\");\n\t\tmsglen = len;\n\t} /* else\n\t\tcurrent buffer can hold new name */\n\n\t/* We're ready to print: */\n\tsymbol = save_symbol;\n\ts = message;\n\t/*\n\t * Ancient systems have sprintf() returning char *, not int.\n\t * If you have one of those, use sprintf(..); s += strlen(s) instead.\n\t */\n\n\ts += sprintf(s, \"%s (\", symbol->vname);\n\tfor (;;) {\n\t\tsymbol = symbol->prev_array;\n\t\tif (symbol->type != Node_array_ref)\n\t\t\tbreak;\n\t\ts += sprintf(s, from, symbol->vname);\n\t\ts += sprintf(s, \", \");\n\t}\n\ts += sprintf(s, from, aname);\n\tstrcpy(s, \")\");\n\n\treturn message;\n}",
      "lines": 74,
      "depth": 10,
      "decorators": [
        "const",
        "const",
        "char",
        "*\narray_vname(const NODE *symbol)",
        "*"
      ]
    },
    "force_array": {
      "start_point": [
        332,
        0
      ],
      "end_point": [
        371,
        1
      ],
      "content": "NODE *\nforce_array(NODE *symbol, bool canfatal)\n{\n\tNODE *save_symbol = symbol;\n\tbool isparam = false;\n\n\tif (symbol->type == Node_param_list) {\n\t\tsave_symbol = symbol = GET_PARAM(symbol->param_cnt);\n\t\tisparam = true;\n\t\tif (symbol->type == Node_array_ref)\n\t\t\tsymbol = symbol->orig_array;\n\t}\n\n\tswitch (symbol->type) {\n\tcase Node_var_new:\n\t\tsymbol->xarray = NULL;\t/* make sure union is as it should be */\n\t\tnull_array(symbol);\n\t\tsymbol->parent_array = NULL;\t/* main array has no parent */\n\t\t/* fall through */\n\tcase Node_var_array:\n\t\tbreak;\n\n\tcase Node_array_ref:\n\tdefault:\n\t\t/* notably Node_var but catches also e.g. a[1] = \"x\"; a[1][1] = \"y\" */\n\t\tif (canfatal) {\n\t\t\tif (symbol->type == Node_val)\n\t\t\t\tfatal(_(\"attempt to use a scalar value as array\"));\n\t\t\tif (isparam)\n\t\t\t\tfatal(_(\"attempt to use scalar parameter `%s' as an array\"),\n\t\t\t\t\tsave_symbol->vname);\n\t\t\telse\n\t\t\t\tfatal(_(\"attempt to use scalar `%s' as an array\"),\n\t\t\t\t\tsave_symbol->vname);\n\t\t} else\n\t\t\tbreak;\n\t}\n\n\treturn symbol;\n}",
      "lines": 40,
      "depth": 15,
      "decorators": [
        "NODE",
        "*\nforce_array(NODE *symbol, bool canfatal)",
        "*"
      ]
    },
    "set_SUBSEP": {
      "start_point": [
        376,
        0
      ],
      "end_point": [
        382,
        1
      ],
      "content": "void\nset_SUBSEP()\n{\n\tSUBSEP_node->var_value = force_string(SUBSEP_node->var_value);\n\tSUBSEP = SUBSEP_node->var_value->stptr;\n\tSUBSEPlen = SUBSEP_node->var_value->stlen;\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "concat_exp": {
      "start_point": [
        387,
        0
      ],
      "end_point": [
        439,
        1
      ],
      "content": "NODE *\nconcat_exp(int nargs, bool do_subsep)\n{\n\t/* do_subsep is false for Op_concat */\n\tNODE *r;\n\tchar *str;\n\tchar *s;\n\tsize_t len;\n\tsize_t subseplen = 0;\n\tint i;\n\textern NODE **args_array;\n\n\tif (nargs == 1)\n\t\treturn POP_STRING();\n\n\tif (do_subsep)\n\t\tsubseplen = SUBSEPlen;\n\n\tlen = 0;\n\tfor (i = 1; i <= nargs; i++) {\n\t\tr = TOP();\n\t\tif (r->type == Node_var_array) {\n\t\t\twhile (--i > 0)\n\t\t\t\tDEREF(args_array[i]);\t/* avoid memory leak */\n\t\t\tfatal(_(\"attempt to use array `%s' in a scalar context\"), array_vname(r));\n\t\t}\n\t\tr = POP_STRING();\n\t\targs_array[i] = r;\n\t\tlen += r->stlen;\n\t}\n\tlen += (nargs - 1) * subseplen;\n\n\temalloc(str, char *, len + 1, \"concat_exp\");\n\n\tr = args_array[nargs];\n\tmemcpy(str, r->stptr, r->stlen);\n\ts = str + r->stlen;\n\tDEREF(r);\n\tfor (i = nargs - 1; i > 0; i--) {\n\t\tif (subseplen == 1)\n\t\t\t*s++ = *SUBSEP;\n\t\telse if (subseplen > 0) {\n\t\t\tmemcpy(s, SUBSEP, subseplen);\n\t\t\ts += subseplen;\n\t\t}\n\t\tr = args_array[i];\n\t\tmemcpy(s, r->stptr, r->stlen);\n\t\ts += r->stlen;\n\t\tDEREF(r);\n\t}\n\n\treturn make_str_node(str, len, ALREADY_MALLOCED);\n}",
      "lines": 53,
      "depth": 13,
      "decorators": [
        "NODE",
        "*\nconcat_exp(int nargs, bool do_subsep)",
        "*"
      ]
    },
    "adjust_fcall_stack": {
      "start_point": [
        447,
        0
      ],
      "end_point": [
        527,
        1
      ],
      "content": "static void\nadjust_fcall_stack(NODE *symbol, int nsubs)\n{\n\tNODE *func, *r, *n;\n\tNODE **sp;\n\tint pcount;\n\n\t/*\n\t * Solve the nasty problem of disappearing subarray arguments:\n\t *\n\t *  function f(c, d) { delete c; .. use non-existent array d .. }\n\t *  BEGIN { a[0][0] = 1; f(a, a[0]); .. }\n\t *\n\t * The fix is to convert 'd' to a local empty array; This has\n\t * to be done before clearing the parent array to avoid referring to\n\t * already free-ed memory.\n\t *\n\t * Similar situations exist for builtins accepting more than\n\t * one array argument: split, patsplit, asort and asorti. For example:\n\t *\n\t *  BEGIN { a[0][0] = 1; split(\"abc\", a, \"\", a[0]) }\n\t *\n\t * These cases do not involve the function call stack, and are\n\t * handled individually in their respective routines.\n\t */\n\n\tfunc = frame_ptr->func_node;\n\tif (func == NULL)\t/* in main */\n\t\treturn;\n\tpcount = func->param_cnt;\n\tsp = frame_ptr->stack;\n\n\tfor (; pcount > 0; pcount--) {\n\t\tr = *sp++;\n\t\tif (r->type != Node_array_ref\n\t\t\t\t|| r->orig_array->type != Node_var_array)\n\t\t\tcontinue;\n\t\tn = r->orig_array;\n\n\t\t/* Case 1 */\n\t\tif (n == symbol\n\t\t\t&& symbol->parent_array != NULL\n\t\t\t&& nsubs > 0\n\t\t) {\n\t\t\t/*\n\t\t\t * 'symbol' is a subarray, and 'r' is the same subarray:\n\t\t\t *\n\t\t\t *   function f(c, d) { delete c[0]; .. }\n\t\t\t *   BEGIN { a[0][0] = 1; f(a, a[0]); .. }\n\t\t\t *\n\t\t\t * But excludes cases like (nsubs = 0):\n\t\t\t *\n\t\t\t *   function f(c, d) { delete c; ..}\n\t\t\t *   BEGIN { a[0][0] = 1; f(a[0], a[0]); ...}\n\t\t\t */\n\n\t\t\tnull_array(r);\n\t\t\tr->parent_array = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Case 2 */\n\t\tfor (n = n->parent_array; n != NULL; n = n->parent_array) {\n\t\t\tassert(n->type == Node_var_array);\n\t\t\tif (n == symbol) {\n\t\t\t\t/*\n\t\t\t\t * 'r' is a subarray of 'symbol':\n\t\t\t\t *\n\t\t\t\t *    function f(c, d) { delete c; .. use d as array .. }\n\t\t\t\t *    BEGIN { a[0][0] = 1; f(a, a[0]); .. }\n\t\t\t\t *\tOR\n\t\t\t\t *    BEGIN { a[0][0][0][0] = 1; f(a[0], a[0][0][0]); .. }\n\t\t\t\t *\n\t\t\t\t */\n\t\t\t\tnull_array(r);\n\t\t\t\tr->parent_array = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}",
      "lines": 81,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "do_delete": {
      "start_point": [
        537,
        0
      ],
      "end_point": [
        622,
        1
      ],
      "content": "void\ndo_delete(NODE *symbol, int nsubs)\n{\n\tNODE *val, *subs;\n\tint i;\n\n\tassert(symbol->type == Node_var_array);\n\tsubs = val = NULL;\t/* silence the compiler */\n\n\t/*\n\t * The force_string() call is needed to make sure that\n\t * the string subscript is reasonable.  For example, with it:\n\t *\n\t * $ ./gawk --posix 'BEGIN { CONVFMT=\"%ld\"; delete a[1.233]}'\n\t * gawk: cmd. line:1: fatal: `%l' is not permitted in POSIX awk formats\n\t *\n\t * Without it, the code does not fail.\n\t */\n\n#define free_subs(n)    do {                                    \\\n    NODE *s = PEEK(n - 1);                                      \\\n    if (s->type == Node_val) {                                  \\\n        (void) force_string(s);\t/* may have side effects. */    \\\n        DEREF(s);                                               \\\n    }                                                           \\\n} while (--n > 0)\n\n\tif (nsubs == 0) {\n\t\t/* delete array */\n\n\t\tadjust_fcall_stack(symbol, 0);\t/* fix function call stack; See above. */\n\t\tassoc_clear(symbol);\n\t\treturn;\n\t}\n\n\t/* NB: subscripts are in reverse order on stack */\n\n\tfor (i = nsubs; i > 0; i--) {\n\t\tsubs = PEEK(i - 1);\n\t\tif (subs->type != Node_val) {\n\t\t\tfree_subs(i);\n\t\t\tfatal(_(\"attempt to use array `%s' in a scalar context\"), array_vname(subs));\n\t\t}\n\n\t\tval = in_array(symbol, subs);\n\t\tif (val == NULL) {\n\t\t\tif (do_lint) {\n\t\t\t\tsubs = force_string(subs);\n\t\t\t\tlintwarn(_(\"delete: index `%.*s' not in array `%s'\"),\n\t\t\t\t\t(int) subs->stlen, subs->stptr, array_vname(symbol));\n\t\t\t}\n\t\t\t/* avoid memory leak, free all subs */\n\t\t\tfree_subs(i);\n\t\t\treturn;\n\t\t}\n\n\t\tif (i > 1) {\n\t\t\tif (val->type != Node_var_array) {\n\t\t\t\t/* e.g.: a[1] = 1; delete a[1][1] */\n\n\t\t\t\tfree_subs(i);\n\t\t\t\tsubs = force_string(subs);\n\t\t\t\tfatal(_(\"attempt to use scalar `%s[\\\"%.*s\\\"]' as an array\"),\n\t\t\t\t\tarray_vname(symbol),\n\t\t\t\t\t(int) subs->stlen,\n\t\t\t\t\tsubs->stptr);\n\t\t\t}\n\t\t\tsymbol = val;\n\t\t\tDEREF(subs);\n\t\t}\n\t}\n\n\tif (val->type == Node_var_array) {\n\t\tadjust_fcall_stack(val, nsubs);  /* fix function call stack; See above. */\n\t\tassoc_clear(val);\n\t\t/* cleared a sub-array, free Node_var_array */\n\t\tefree(val->vname);\n\t\tfreenode(val);\n\t} else\n\t\tunref(val);\n\n\t(void) assoc_remove(symbol, subs);\n\tDEREF(subs);\n\n#undef free_subs\n}",
      "lines": 86,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "do_delete_loop": {
      "start_point": [
        633,
        0
      ],
      "end_point": [
        652,
        1
      ],
      "content": "void\ndo_delete_loop(NODE *symbol, NODE **lhs)\n{\n\tNODE **list;\n\tNODE akind;\n\n\takind.flags = AINDEX|ADELETE;\t/* need a single index */\n\tlist = symbol->alist(symbol, & akind);\n\n\tif (assoc_empty(symbol))\n\t\treturn;\n\n\tunref(*lhs);\n\t*lhs = list[0];\n\tefree(list);\n\n\t/* blast the array in one shot */\n\tadjust_fcall_stack(symbol, 0);\n\tassoc_clear(symbol);\n}",
      "lines": 20,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "value_info": {
      "start_point": [
        657,
        0
      ],
      "end_point": [
        724,
        1
      ],
      "content": "static void\nvalue_info(NODE *n)\n{\n\n#define PREC_NUM -1\n\n\tif (n == Nnull_string || n == Null_field) {\n\t\tfprintf(output_fp, \"<(null)>\");\n\t\treturn;\n\t}\n\n\tif ((n->flags & (STRING|STRCUR)) != 0) {\n\t\tfprintf(output_fp, \"<\");\n\t\tfprintf(output_fp, \"\\\"%.*s\\\"\", (int) n->stlen, n->stptr);\n\t\tif ((n->flags & (NUMBER|NUMCUR)) != 0) {\n#ifdef HAVE_MPFR\n\t\t\tif (is_mpg_float(n))\n\t\t\t\tfprintf(output_fp, \":%s\",\n\t\t\t\t\tmpg_fmt(\"%.*R*g\", PREC_NUM, ROUND_MODE, n->mpg_numbr));\n\t\t\telse if (is_mpg_integer(n))\n\t\t\t\tfprintf(output_fp, \":%s\", mpg_fmt(\"%Zd\", n->mpg_i));\n\t\t\telse\n#endif\n\t\t\tfprintf(output_fp, \":%.*g\", PREC_NUM, n->numbr);\n\t\t}\n\t\tfprintf(output_fp, \">\");\n\t} else {\n#ifdef HAVE_MPFR\n\t\tif (is_mpg_float(n))\n\t\t\tfprintf(output_fp, \"<%s>\",\n\t\t\t\tmpg_fmt(\"%.*R*g\", PREC_NUM, ROUND_MODE, n->mpg_numbr));\n\t\telse if (is_mpg_integer(n))\n\t\t\tfprintf(output_fp, \"<%s>\", mpg_fmt(\"%Zd\", n->mpg_i));\n\t\telse\n#endif\n\t\tfprintf(output_fp, \"<%.*g>\", PREC_NUM, n->numbr);\n\t}\n\n\tfprintf(output_fp, \":%s\", flags2str(n->flags));\n\n\tif ((n->flags & MALLOC) != 0)\n\t\tfprintf(output_fp, \":%ld\", n->valref);\n\telse\n\t\tfprintf(output_fp, \":\");\n\n\tif ((n->flags & (STRING|STRCUR)) == STRCUR) {\n\t\tsize_t len;\n\n\t\tfprintf(output_fp, \"][\");\n\t\tfprintf(output_fp, \"stfmt=%d, \", n->stfmt);\n\t\t/*\n\t\t * If not STFMT_UNUSED, could be CONVFMT or OFMT if last\n\t\t * used in a print statement. If immutable, could be that it\n\t\t * was originally set as a string, or it's a number that has\n\t\t * an integer value.\n\t\t */\n\t\tlen = fmt_list[n->stfmt]->stlen;\n\t\tfmt_list[n->stfmt]->stptr[len] = '\\0';\n\t\tfprintf(output_fp, \"FMT=\\\"%s\\\"\",\n\t\t\t\t\tn->stfmt == STFMT_UNUSED ? \"<unused>\"\n\t\t\t\t\t: fmt_list[n->stfmt]->stptr);\n#ifdef HAVE_MPFR\n\t\tfprintf(output_fp, \", RNDMODE=\\\"%c\\\"\", n->strndmode);\n#endif\n\t}\n\n#undef PREC_NUM\n}",
      "lines": 68,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "indent": {
      "start_point": [
        727,
        0
      ],
      "end_point": [
        733,
        1
      ],
      "content": "void\nindent(int indent_level)\n{\n\tint i;\n\tfor (i = 0; i < indent_level; i++)\n\t\tfprintf(output_fp, \"%s\", indent_char);\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "assoc_info": {
      "start_point": [
        737,
        0
      ],
      "end_point": [
        765,
        1
      ],
      "content": "void\nassoc_info(NODE *subs, NODE *val, NODE *ndump, const char *aname)\n{\n\tint indent_level = ndump->alevel;\n\n\tindent_level++;\n\tindent(indent_level);\n\tfprintf(output_fp, \"I: [%s:\", aname);\n\tif ((subs->flags & (MPFN|MPZN|INTIND)) == INTIND)\n\t\tfprintf(output_fp, \"<%ld>\", (long) subs->numbr);\n\telse\n\t\tvalue_info(subs);\n\tfprintf(output_fp, \"]\\n\");\n\n\tindent(indent_level);\n\tif (val->type == Node_val) {\n\t\tfprintf(output_fp, \"V: [scalar: \");\n\t\tvalue_info(val);\n\t} else {\n\t\tfprintf(output_fp, \"V: [\");\n\t\tndump->alevel++;\n\t\tndump->adepth--;\n\t\tassoc_dump(val, ndump);\n\t\tndump->adepth++;\n\t\tndump->alevel--;\n\t\tindent(indent_level);\n\t}\n\tfprintf(output_fp, \"]\\n\");\n}",
      "lines": 29,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "do_adump": {
      "start_point": [
        770,
        0
      ],
      "end_point": [
        797,
        1
      ],
      "content": "NODE *\ndo_adump(int nargs)\n{\n\tNODE *symbol, *tmp;\n\tstatic NODE ndump;\n\tlong depth = 0;\n\n\t/*\n\t * depth < 0, no index and value info.\n\t *       = 0, main array index and value info; does not descend into sub-arrays.\n\t *       > 0, descends into 'depth' sub-arrays, and prints index and value info.\n\t */\n\n\tif (nargs == 2) {\n\t\ttmp = POP_NUMBER();\n\t\tdepth = get_number_si(tmp);\n\t\tDEREF(tmp);\n\t}\n\tsymbol = POP_PARAM();\n\tif (symbol->type != Node_var_array)\n\t\tfatal(_(\"adump: first argument not an array\"));\n\n\tndump.type = Node_dump_array;\n\tndump.adepth = depth;\n\tndump.alevel = 0;\n\tassoc_dump(symbol, & ndump);\n\treturn make_number((AWKNUM) 0);\n}",
      "lines": 28,
      "depth": 10,
      "decorators": [
        "NODE",
        "*\ndo_adump(int nargs)",
        "*"
      ]
    },
    "asort_actual": {
      "start_point": [
        802,
        0
      ],
      "end_point": [
        950,
        1
      ],
      "content": "static NODE *\nasort_actual(int nargs, sort_context_t ctxt)\n{\n\tNODE *array, *dest = NULL, *result;\n\tNODE *r, *subs, *s;\n\tNODE **list = NULL, **ptr, **lhs;\n\tunsigned long num_elems, i;\n\tconst char *sort_str;\n\tchar save;\n\n\tif (nargs == 3)  /* 3rd optional arg */\n\t\ts = POP_STRING();\n\telse\n\t\ts = dupnode(Nnull_string);\t/* \"\" => default sorting */\n\n\ts = force_string(s);\n\tsort_str = s->stptr;\n\tsave = s->stptr[s->stlen];\n\ts->stptr[s->stlen] = '\\0';\n\tif (s->stlen == 0) {\t\t/* default sorting */\n\t\tif (ctxt == ASORT)\n\t\t\tsort_str = \"@val_type_asc\";\n\t\telse\n\t\t\tsort_str = \"@ind_str_asc\";\n\t}\n\n\tif (nargs >= 2) {  /* 2nd optional arg */\n\t\tdest = POP_PARAM();\n\t\tif (dest->type != Node_var_array) {\n\t\t\tfatal(ctxt == ASORT ?\n\t\t\t\t_(\"asort: second argument not an array\") :\n\t\t\t\t_(\"asorti: second argument not an array\"));\n\t\t}\n\t}\n\n\tarray = POP_PARAM();\n\tif (array->type != Node_var_array) {\n\t\tfatal(ctxt == ASORT ?\n\t\t\t_(\"asort: first argument not an array\") :\n\t\t\t_(\"asorti: first argument not an array\"));\n\t}\n\n\tif (dest != NULL) {\n\t\tfor (r = dest->parent_array; r != NULL; r = r->parent_array) {\n\t\t\tif (r == array)\n\t\t\t\tfatal(ctxt == ASORT ?\n\t\t\t\t\t_(\"asort: cannot use a subarray of first arg for second arg\") :\n\t\t\t\t\t_(\"asorti: cannot use a subarray of first arg for second arg\"));\n\t\t}\n\t\tfor (r = array->parent_array; r != NULL; r = r->parent_array) {\n\t\t\tif (r == dest)\n\t\t\t\tfatal(ctxt == ASORT ?\n\t\t\t\t\t_(\"asort: cannot use a subarray of second arg for first arg\") :\n\t\t\t\t\t_(\"asorti: cannot use a subarray of second arg for first arg\"));\n\t\t}\n\t}\n\n\t/* sorting happens inside assoc_list */\n\tlist = assoc_list(array, sort_str, ctxt);\n\ts->stptr[s->stlen] = save;\n\tDEREF(s);\n\n\tnum_elems = assoc_length(array);\n\tif (num_elems == 0 || list == NULL) {\n \t\t/* source array is empty */\n \t\tif (dest != NULL && dest != array)\n \t\t\tassoc_clear(dest);\n\t\tif (list != NULL)\n\t\t\tefree(list);\n \t\treturn make_number((AWKNUM) 0);\n \t}\n\n\t/*\n\t * Must not assoc_clear() the source array before constructing\n\t * the output array. assoc_list() does not duplicate array values\n\t * which are needed for asort().\n\t */\n\n\tif (dest != NULL && dest != array) {\n\t\tassoc_clear(dest);\n\t\tresult = dest;\n\t} else {\n\t\t/* use 'result' as a temporary destination array */\n\t\tresult = make_array();\n\t\tresult->vname = array->vname;\n\t\tresult->parent_array = array->parent_array;\n\t}\n\n\tif (ctxt == ASORTI) {\n\t\t/* We want the indices of the source array. */\n\n\t\tfor (i = 1, ptr = list; i <= num_elems; i++, ptr += 2) {\n\t\t\tsubs = make_number(i);\n\t\t\tlhs = assoc_lookup(result, subs);\n\t\t\tunref(*lhs);\n\t\t\t*lhs = *ptr;\n\t\t\tif (result->astore != NULL)\n\t\t\t\t(*result->astore)(result, subs);\n\t\t\tunref(subs);\n\t\t}\n\t} else {\n\t\t/* We want the values of the source array. */\n\n\t\tfor (i = 1, ptr = list; i <= num_elems; i++) {\n\t\t\tsubs = make_number(i);\n\n\t\t\t/* free index node */\n\t\t\tr = *ptr++;\n\t\t\tunref(r);\n\n\t\t\t/* value node */\n\t\t\tr = *ptr++;\n\n\t\t\tif (r->type == Node_val) {\n\t\t\t\tlhs = assoc_lookup(result, subs);\n\t\t\t\tunref(*lhs);\n\t\t\t\t*lhs = dupnode(r);\n\t\t\t} else {\n\t\t\t\tNODE *arr;\n\t\t\t\tarr = make_array();\n\t\t\t\tsubs = force_string(subs);\n\t\t\t\tarr->vname = subs->stptr;\n\t\t\t\tarr->vname[subs->stlen] = '\\0';\n\t\t\t\tsubs->stptr = NULL;\n\t\t\t\tsubs->flags &= ~STRCUR;\n\t\t\t\tarr->parent_array = array; /* actual parent, not the temporary one. */\n\t\t\t\tlhs = assoc_lookup(result, subs);\n\t\t\t\tunref(*lhs);\n\t\t\t\t*lhs = assoc_copy(r, arr);\n\t\t\t}\n\t\t\tif (result->astore != NULL)\n\t\t\t\t(*result->astore)(result, subs);\n\t\t\tunref(subs);\n\t\t}\n\t}\n\n\tefree(list);\n\n\tif (result != dest) {\n\t\t/* dest == NULL or dest == array */\n\t\tassoc_clear(array);\n\t\t*array = *result;\t/* copy result into array */\n\t\tfreenode(result);\n\t} /* else\n\t\tresult == dest\n\t\tdest != NULL and dest != array */\n\n\treturn make_number((AWKNUM) num_elems);\n}",
      "lines": 149,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "NODE",
        "*\nasort_actual(int nargs, sort_context_t ctxt)",
        "*"
      ]
    },
    "do_asort": {
      "start_point": [
        954,
        0
      ],
      "end_point": [
        958,
        1
      ],
      "content": "NODE *\ndo_asort(int nargs)\n{\n\treturn asort_actual(nargs, ASORT);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "NODE",
        "*\ndo_asort(int nargs)",
        "*"
      ]
    },
    "do_asorti": {
      "start_point": [
        962,
        0
      ],
      "end_point": [
        966,
        1
      ],
      "content": "NODE *\ndo_asorti(int nargs)\n{\n\treturn asort_actual(nargs, ASORTI);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "NODE",
        "*\ndo_asorti(int nargs)",
        "*"
      ]
    },
    "cmp_strings": {
      "start_point": [
        975,
        0
      ],
      "end_point": [
        1019,
        1
      ],
      "content": "static int\ncmp_strings(const NODE *n1, const NODE *n2)\n{\n\tchar *s1, *s2;\n\tsize_t len1, len2;\n\tint ret;\n\tsize_t lmin;\n\n\ts1 = n1->stptr;\n\tlen1 = n1->stlen;\n\ts2 =  n2->stptr;\n\tlen2 = n2->stlen;\n\n\tif (len1 == 0)\n\t\treturn len2 == 0 ? 0 : -1;\n\tif (len2 == 0)\n\t\treturn 1;\n\n\t/* len1 > 0 && len2 > 0 */\n\tlmin = len1 < len2 ? len1 : len2;\n\n\tif (IGNORECASE) {\n\t\tconst unsigned char *cp1 = (const unsigned char *) s1;\n\t\tconst unsigned char *cp2 = (const unsigned char *) s2;\n\n\t\tif (gawk_mb_cur_max > 1) {\n\t\t\tret = strncasecmpmbs((const unsigned char *) cp1,\n\t\t\t\t\t     (const unsigned char *) cp2, lmin);\n\t\t} else {\n\t\t\tfor (ret = 0; lmin-- > 0 && ret == 0; cp1++, cp2++)\n\t\t\t\tret = casetable[*cp1] - casetable[*cp2];\n\t\t}\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t\t/*\n\t\t * If case insensitive result is \"they're the same\",\n\t\t * use case sensitive comparison to force distinct order.\n\t\t */\n\t}\n\n\tret = memcmp(s1, s2, lmin);\n\tif (ret != 0 || len1 == len2)\n\t\treturn ret;\n\treturn (len1 < len2) ? -1 : 1;\n}",
      "lines": 45,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "sort_up_index_string": {
      "start_point": [
        1023,
        0
      ],
      "end_point": [
        1032,
        1
      ],
      "content": "static int\nsort_up_index_string(const void *p1, const void *p2)\n{\n\tconst NODE *t1, *t2;\n\n\t/* Array indices are strings */\n\tt1 = *((const NODE *const *) p1);\n\tt2 = *((const NODE *const *) p2);\n\treturn cmp_strings(t1, t2);\n}",
      "lines": 10,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "sort_down_index_string": {
      "start_point": [
        1037,
        0
      ],
      "end_point": [
        1050,
        1
      ],
      "content": "static int\nsort_down_index_string(const void *p1, const void *p2)\n{\n\t/*\n\t * Negation versus transposed arguments:  when all keys are\n\t * distinct, as with array indices here, either method will\n\t * transform an ascending sort into a descending one.  But if\n\t * there are equal keys--such as when IGNORECASE is honored--\n\t * that get disambiguated into a determisitc order, negation\n\t * will reverse those but transposed arguments would retain\n\t * their relative order within the rest of the reversed sort.\n\t */\n\treturn -sort_up_index_string(p1, p2);\n}",
      "lines": 14,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "sort_up_index_number": {
      "start_point": [
        1055,
        0
      ],
      "end_point": [
        1072,
        1
      ],
      "content": "static int\nsort_up_index_number(const void *p1, const void *p2)\n{\n\tconst NODE *t1, *t2;\n\tint ret;\n\n\tt1 = *((const NODE *const *) p1);\n\tt2 = *((const NODE *const *) p2);\n\n\tret = cmp_numbers(t1, t2);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t/* break a tie with the index string itself */\n\tt1 = force_string((NODE *) t1);\n\tt2 = force_string((NODE *) t2);\n\treturn cmp_strings(t1, t2);\n}",
      "lines": 18,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "sort_down_index_number": {
      "start_point": [
        1076,
        0
      ],
      "end_point": [
        1080,
        1
      ],
      "content": "static int\nsort_down_index_number(const void *p1, const void *p2)\n{\n\treturn -sort_up_index_number(p1, p2);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "sort_up_value_string": {
      "start_point": [
        1085,
        0
      ],
      "end_point": [
        1102,
        1
      ],
      "content": "static int\nsort_up_value_string(const void *p1, const void *p2)\n{\n\tconst NODE *t1, *t2;\n\n\tt1 = *((const NODE *const *) p1 + 1);\n\tt2 = *((const NODE *const *) p2 + 1);\n\n\tif (t1->type == Node_var_array) {\n\t\t/* return 0 if t2 is a sub-array too, else return 1 */\n\t\treturn (t2->type != Node_var_array);\n\t}\n\tif (t2->type == Node_var_array)\n\t\treturn -1;\t\t/* t1 (scalar) < t2 (sub-array) */\n\n\t/* t1 and t2 both have string values */\n\treturn cmp_strings(t1, t2);\n}",
      "lines": 18,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "sort_down_value_string": {
      "start_point": [
        1107,
        0
      ],
      "end_point": [
        1111,
        1
      ],
      "content": "static int\nsort_down_value_string(const void *p1, const void *p2)\n{\n\treturn -sort_up_value_string(p1, p2);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "sort_up_value_number": {
      "start_point": [
        1116,
        0
      ],
      "end_point": [
        1143,
        1
      ],
      "content": "static int\nsort_up_value_number(const void *p1, const void *p2)\n{\n\tNODE *t1, *t2;\n\tint ret;\n\n\tt1 = *((NODE *const *) p1 + 1);\n\tt2 = *((NODE *const *) p2 + 1);\n\n\tif (t1->type == Node_var_array) {\n\t\t/* return 0 if t2 is a sub-array too, else return 1 */\n\t\treturn (t2->type != Node_var_array);\n\t}\n\tif (t2->type == Node_var_array)\n\t\treturn -1;\t\t/* t1 (scalar) < t2 (sub-array) */\n\n\tret = cmp_numbers(t1, t2);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t/*\n\t * Use string value to guarantee same sort order on all\n\t * versions of qsort().\n\t */\n\tt1 = force_string(t1);\n\tt2 = force_string(t2);\n\treturn cmp_strings(t1, t2);\n}",
      "lines": 28,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "sort_down_value_number": {
      "start_point": [
        1148,
        0
      ],
      "end_point": [
        1152,
        1
      ],
      "content": "static int\nsort_down_value_number(const void *p1, const void *p2)\n{\n\treturn -sort_up_value_number(p1, p2);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "sort_up_value_type": {
      "start_point": [
        1157,
        0
      ],
      "end_point": [
        1192,
        1
      ],
      "content": "static int\nsort_up_value_type(const void *p1, const void *p2)\n{\n\tNODE *n1, *n2;\n\n\t/* we want to compare the element values */\n\tn1 = *((NODE *const *) p1 + 1);\n\tn2 = *((NODE *const *) p2 + 1);\n\n\t/* 1. Arrays vs. scalar, scalar is less than array */\n\tif (n1->type == Node_var_array) {\n\t\t/* return 0 if n2 is a sub-array too, else return 1 */\n\t\treturn (n2->type != Node_var_array);\n\t}\n\tif (n2->type == Node_var_array) {\n\t\treturn -1;\t\t/* n1 (scalar) < n2 (sub-array) */\n\t}\n\n\t/* two scalars */\n\t(void) fixtype(n1);\n\t(void) fixtype(n2);\n\n\tif ((n1->flags & NUMBER) != 0 && (n2->flags & NUMBER) != 0) {\n\t\treturn cmp_numbers(n1, n2);\n\t}\n\n\t/* 3. All numbers are less than all strings. This is aribitrary. */\n\tif ((n1->flags & NUMBER) != 0 && (n2->flags & STRING) != 0) {\n\t\treturn -1;\n\t} else if ((n1->flags & STRING) != 0 && (n2->flags & NUMBER) != 0) {\n\t\treturn 1;\n\t}\n\n\t/* 4. Two strings */\n\treturn cmp_strings(n1, n2);\n}",
      "lines": 36,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "sort_down_value_type": {
      "start_point": [
        1196,
        0
      ],
      "end_point": [
        1200,
        1
      ],
      "content": "static int\nsort_down_value_type(const void *p1, const void *p2)\n{\n\treturn -sort_up_value_type(p1, p2);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "sort_user_func": {
      "start_point": [
        1204,
        0
      ],
      "end_point": [
        1250,
        1
      ],
      "content": "static int\nsort_user_func(const void *p1, const void *p2)\n{\n\tNODE *idx1, *idx2, *val1, *val2, *r;\n\tint ret;\n\tINSTRUCTION *code;\n\n\tidx1 = *((NODE *const *) p1);\n\tidx2 = *((NODE *const *) p2);\n\tval1 = *((NODE *const *) p1 + 1);\n\tval2 = *((NODE *const *) p2 + 1);\n\n\tcode = TOP()->code_ptr;\t/* comparison function call instructions */\n\n\t/* setup 4 arguments to comp_func() */\n\tUPREF(idx1);\n\tPUSH(idx1);\n\tif (val1->type == Node_val)\n\t\tUPREF(val1);\n\tPUSH(val1);\n\n\tUPREF(idx2);\n\tPUSH(idx2);\n\tif (val2->type == Node_val)\n\t\tUPREF(val2);\n\tPUSH(val2);\n\n\t/* execute the comparison function */\n\t(void) (*interpret)(code);\n\n\t/* return value of the comparison function */\n\tr = POP_NUMBER();\n#ifdef HAVE_MPFR\n\t/*\n\t * mpfr_sgn(mpz_sgn): Returns a positive value if op > 0,\n\t * zero if op = 0, and a negative value if op < 0.\n\t */\n\tif (is_mpg_float(r))\n\t\tret = mpfr_sgn(r->mpg_numbr);\n\telse if (is_mpg_integer(r))\n\t\tret = mpz_sgn(r->mpg_i);\n\telse\n#endif\n\t\tret = (r->numbr < 0.0) ? -1 : (r->numbr > 0.0);\n\tDEREF(r);\n\treturn ret;\n}",
      "lines": 47,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "assoc_list": {
      "start_point": [
        1255,
        0
      ],
      "end_point": [
        1383,
        1
      ],
      "content": "NODE **\nassoc_list(NODE *symbol, const char *sort_str, sort_context_t sort_ctxt)\n{\n\ttypedef int (*qsort_compfunc)(const void *, const void *);\n\n\tstatic const struct qsort_funcs {\n\t\tconst char *name;\n\t\tqsort_compfunc comp_func;\n\t\tassoc_kind_t kind;\n\t} sort_funcs[] = {\n{ \"@ind_str_asc\",\tsort_up_index_string,\tAINDEX|AISTR|AASC },\n{ \"@ind_num_asc\",\tsort_up_index_number,\tAINDEX|AINUM|AASC },\n{ \"@val_str_asc\",\tsort_up_value_string,\tAVALUE|AVSTR|AASC },\n{ \"@val_num_asc\",\tsort_up_value_number,\tAVALUE|AVNUM|AASC },\n{ \"@ind_str_desc\",\tsort_down_index_string,\tAINDEX|AISTR|ADESC },\n{ \"@ind_num_desc\",\tsort_down_index_number,\tAINDEX|AINUM|ADESC },\n{ \"@val_str_desc\",\tsort_down_value_string,\tAVALUE|AVSTR|ADESC },\n{ \"@val_num_desc\",\tsort_down_value_number,\tAVALUE|AVNUM|ADESC },\n{ \"@val_type_asc\",\tsort_up_value_type,\tAVALUE|AASC },\n{ \"@val_type_desc\",\tsort_down_value_type,\tAVALUE|ADESC },\n{ \"@unsorted\",\t\t0,\t\t\tAINDEX },\n};\n\n\t/*\n\t * N.B.: AASC and ADESC are hints to the specific array types.\n\t *\tSee cint_list() in cint_array.c.\n\t */\n\n\tNODE **list;\n\tNODE akind;\n\tunsigned long num_elems, j;\n\tint elem_size, qi;\n\tqsort_compfunc cmp_func = 0;\n\tINSTRUCTION *code = NULL;\n\textern int currule;\n\tint save_rule = 0;\n\tassoc_kind_t assoc_kind = ANONE;\n\n\telem_size = 1;\n\n\tfor (qi = 0, j = sizeof(sort_funcs)/sizeof(sort_funcs[0]); qi < j; qi++) {\n\t\tif (strcmp(sort_funcs[qi].name, sort_str) == 0)\n\t\t\tbreak;\n\t}\n\n\tif (qi < j) {\n\t\tcmp_func = sort_funcs[qi].comp_func;\n\t\tassoc_kind = sort_funcs[qi].kind;\n\n\t\tif (symbol->array_funcs != cint_array_func)\n\t\t\tassoc_kind &= ~(AASC|ADESC);\n\n\t\tif (sort_ctxt != SORTED_IN || (assoc_kind & AVALUE) != 0) {\n\t\t\t/* need index and value pair in the list */\n\n\t\t\tassoc_kind |= (AINDEX|AVALUE);\n\t\t\telem_size = 2;\n\t\t}\n\n\t} else {\t/* unrecognized */\n\t\tNODE *f;\n\t\tconst char *sp;\n\n\t\tfor (sp = sort_str; *sp != '\\0' && ! isspace((unsigned char) *sp); sp++)\n\t\t\tcontinue;\n\n\t\t/* empty string or string with space(s) not valid as function name */\n\t\tif (sp == sort_str || *sp != '\\0')\n\t\t\tfatal(_(\"`%s' is invalid as a function name\"), sort_str);\n\n\t\tf = lookup(sort_str);\n\t\tif (f == NULL || f->type != Node_func)\n\t\t\tfatal(_(\"sort comparison function `%s' is not defined\"), sort_str);\n\n\t\tcmp_func = sort_user_func;\n\n\t\t/* need index and value pair in the list */\n\t\tassoc_kind |= (AVALUE|AINDEX);\n\t\telem_size = 2;\n\n\t\t/* make function call instructions */\n\t\tcode = bcalloc(Op_func_call, 2, 0);\n\t\tcode->func_body = f;\n\t\tcode->func_name = NULL;\t\t/* not needed, func_body already assigned */\n\t\t(code + 1)->expr_count = 4;\t/* function takes 4 arguments */\n\t\tcode->nexti = bcalloc(Op_stop, 1, 0);\n\n\t\t/*\n\t\t * make non-redirected getline, exit, `next' and `nextfile' fatal in\n\t\t * callback function by setting currule in interpret()\n\t\t * to undefined (0).\n\t\t */\n\n\t\tsave_rule = currule;\t/* save current rule */\n\t\tcurrule = 0;\n\n\t\tPUSH_CODE(code);\n\t}\n\n\takind.flags = (unsigned int) assoc_kind;\t/* kludge */\n\tlist = symbol->alist(symbol, & akind);\n\tassoc_kind = (assoc_kind_t) akind.flags;\t/* symbol->alist can modify it */\n\n\t/* check for empty list or unsorted, or list already sorted */\n\tif (list != NULL && cmp_func != NULL && (assoc_kind & (AASC|ADESC)) == 0) {\n\t\tnum_elems = assoc_length(symbol);\n\n\t\tqsort(list, num_elems, elem_size * sizeof(NODE *), cmp_func); /* shazzam! */\n\n\t\tif (sort_ctxt == SORTED_IN && (assoc_kind & (AINDEX|AVALUE)) == (AINDEX|AVALUE)) {\n\t\t\t/* relocate all index nodes to the first half of the list. */\n\t\t\tfor (j = 1; j < num_elems; j++)\n\t\t\t\tlist[j] = list[2 * j];\n\n\t\t\t/* give back extra memory */\n\n\t\t\terealloc(list, NODE **, num_elems * sizeof(NODE *), \"assoc_list\");\n\t\t}\n\t}\n\n\tif (cmp_func == sort_user_func) {\n\t\tcode = POP_CODE();\n\t\tcurrule = save_rule;            /* restore current rule */\n\t\tbcfree(code->nexti);            /* Op_stop */\n\t\tbcfree(code);                   /* Op_func_call */\n\t}\n\n\treturn list;\n}",
      "lines": 129,
      "depth": 14,
      "decorators": [
        "NODE",
        "**\nassoc_list(NODE *symbol, const char *sort_str, sort_context_t sort_ctxt)",
        "*",
        "*\nassoc_list(NODE *symbol, const char *sort_str, sort_context_t sort_ctxt)",
        "*"
      ]
    }
  },
  "gawk/gawk-4.2.1/awk.h": {
    "DEREF": {
      "start_point": [
        1254,
        0
      ],
      "end_point": [
        1260,
        1
      ],
      "content": "static inline void\nDEREF(NODE *r)\n{\n\tassert(r->valref > 0);\n\tif (--r->valref == 0)\n\t\tr_unref(r);\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    },
    "POP_ARRAY": {
      "start_point": [
        1778,
        0
      ],
      "end_point": [
        1784,
        1
      ],
      "content": "static inline NODE *\nPOP_ARRAY()\n{\n\tNODE *t = POP();\n\n\treturn (t->type == Node_var_array) ? t : force_array(t, true);\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "NODE",
        "*\nPOP_ARRAY()",
        "*"
      ]
    },
    "POP_PARAM": {
      "start_point": [
        1788,
        0
      ],
      "end_point": [
        1794,
        1
      ],
      "content": "static inline NODE *\nPOP_PARAM()\n{\n\tNODE *t = POP();\n\n\treturn (t->type == Node_var_array) ? t : force_array(t, false);\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "NODE",
        "*\nPOP_PARAM()",
        "*"
      ]
    },
    "POP_SCALAR": {
      "start_point": [
        1798,
        0
      ],
      "end_point": [
        1807,
        1
      ],
      "content": "static inline NODE *\nPOP_SCALAR()\n{\n\tNODE *t = POP();\n\n\tif (t->type == Node_var_array)\n\t\tfatal(_(\"attempt to use array `%s' in a scalar context\"), array_vname(t));\n\n\treturn t;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "NODE",
        "*\nPOP_SCALAR()",
        "*"
      ]
    },
    "TOP_SCALAR": {
      "start_point": [
        1811,
        0
      ],
      "end_point": [
        1820,
        1
      ],
      "content": "static inline NODE *\nTOP_SCALAR()\n{\n\tNODE *t = TOP();\n\n\tif (t->type == Node_var_array)\n\t\tfatal(_(\"attempt to use array `%s' in a scalar context\"), array_vname(t));\n\n\treturn t;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "NODE",
        "*\nTOP_SCALAR()",
        "*"
      ]
    },
    "in_array": {
      "start_point": [
        1830,
        0
      ],
      "end_point": [
        1838,
        1
      ],
      "content": "static inline NODE *\nin_array(NODE *a, NODE *s)\n{\n\tNODE **ret;\n\n\tret = a->aexists(a, s);\n\n\treturn ret ? *ret : NULL;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "NODE",
        "*\nin_array(NODE *a, NODE *s)",
        "*"
      ]
    },
    "dupnode": {
      "start_point": [
        1845,
        0
      ],
      "end_point": [
        1853,
        1
      ],
      "content": "static inline NODE *\ndupnode(NODE *n)\n{\n\tif ((n->flags & MALLOC) != 0) {\n\t\tn->valref++;\n\t\treturn n;\n\t}\n\treturn r_dupnode(n);\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "NODE",
        "*\ndupnode(NODE *n)",
        "*"
      ]
    },
    "force_string_fmt": {
      "start_point": [
        1868,
        0
      ],
      "end_point": [
        1879,
        1
      ],
      "content": "static inline NODE *\nforce_string_fmt(NODE *s, const char *fmtstr, int fmtidx)\n{\n\tif ((s->flags & STRCUR) != 0\n\t\t&& (s->stfmt == STFMT_UNUSED || (s->stfmt == fmtidx\n#ifdef HAVE_MPFR\n\t\t\t\t\t\t&& s->strndmode == MPFR_round_mode\n#endif\n\t\t\t\t)))\n\t\treturn s;\n\treturn format_val(fmtstr, fmtidx, s);\n}",
      "lines": 12,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "NODE",
        "*\nforce_string_fmt(NODE *s, const char *fmtstr, int fmtidx)",
        "*"
      ]
    },
    "unref": {
      "start_point": [
        1893,
        0
      ],
      "end_point": [
        1898,
        1
      ],
      "content": "static inline void\nunref(NODE *r)\n{\n\tif (r != NULL && --r->valref <= 0)\n\t\tr_unref(r);\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    },
    "force_number": {
      "start_point": [
        1902,
        0
      ],
      "end_point": [
        1906,
        1
      ],
      "content": "static inline NODE *\nforce_number(NODE *n)\n{\n\treturn (n->flags & NUMCUR) != 0 ? n : str2number(n);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "NODE",
        "*\nforce_number(NODE *n)",
        "*"
      ]
    },
    "fixtype": {
      "start_point": [
        1923,
        0
      ],
      "end_point": [
        1932,
        1
      ],
      "content": "static inline NODE *\nfixtype(NODE *n)\n{\n\tassert(n->type == Node_val);\n\tif ((n->flags & (NUMCUR|USER_INPUT)) == USER_INPUT)\n\t\treturn force_number(n);\n\tif ((n->flags & INTIND) != 0)\n\t\treturn force_string(n);\n\treturn n;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "NODE",
        "*\nfixtype(NODE *n)",
        "*"
      ]
    },
    "boolval": {
      "start_point": [
        1941,
        0
      ],
      "end_point": [
        1948,
        1
      ],
      "content": "static inline bool\nboolval(NODE *t)\n{\n\t(void) fixtype(t);\n\tif ((t->flags & NUMBER) != 0)\n\t\treturn ! iszero(t);\n\treturn (t->stlen > 0);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "bool"
      ]
    },
    "emalloc_real": {
      "start_point": [
        1952,
        0
      ],
      "end_point": [
        1966,
        1
      ],
      "content": "static inline void *\nemalloc_real(size_t count, const char *where, const char *var, const char *file, int line)\n{\n\tvoid *ret;\n\n\tif (count == 0)\n\t\tfatal(\"%s:%d: emalloc called with zero bytes\", file, line);\n\n\tret = (void *) malloc(count);\n\tif (ret == NULL)\n\t\tfatal(_(\"%s:%d:%s: %s: can't allocate %ld bytes of memory (%s)\"),\n\t\t\tfile, line, where, var, (long) count, strerror(errno));\n\n\treturn ret;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void",
        "*\nemalloc_real(size_t count, const char *where, const char *var, const char *file, int line)",
        "*"
      ]
    },
    "ezalloc_real": {
      "start_point": [
        1970,
        0
      ],
      "end_point": [
        1984,
        1
      ],
      "content": "static inline void *\nezalloc_real(size_t count, const char *where, const char *var, const char *file, int line)\n{\n\tvoid *ret;\n\n\tif (count == 0)\n\t\tfatal(\"%s:%d: ezalloc called with zero bytes\", file, line);\n\n\tret = (void *) calloc(1, count);\n\tif (ret == NULL)\n\t\tfatal(_(\"%s:%d:%s: %s: can't allocate %ld bytes of memory (%s)\"),\n\t\t\tfile, line, where, var, (long) count, strerror(errno));\n\n\treturn ret;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void",
        "*\nezalloc_real(size_t count, const char *where, const char *var, const char *file, int line)",
        "*"
      ]
    },
    "erealloc_real": {
      "start_point": [
        1988,
        0
      ],
      "end_point": [
        2002,
        1
      ],
      "content": "static inline void *\nerealloc_real(void *ptr, size_t count, const char *where, const char *var, const char *file, int line)\n{\n\tvoid *ret;\n\n\tif (count == 0)\n\t\tfatal(\"%s:%d: erealloc called with zero bytes\", file, line);\n\n\tret = (void *) realloc(ptr, count);\n\tif (ret == NULL)\n\t\tfatal(_(\"%s:%d:%s: %s: can't reallocate %ld bytes of memory (%s)\"),\n\t\t\tfile, line, where, var, (long) count, strerror(errno));\n\n\treturn ret;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void",
        "*\nerealloc_real(void *ptr, size_t count, const char *where, const char *var, const char *file, int line)",
        "*"
      ]
    },
    "make_number_node": {
      "start_point": [
        2006,
        0
      ],
      "end_point": [
        2016,
        1
      ],
      "content": "static inline NODE *\nmake_number_node(unsigned int flags)\n{\n\tNODE *r;\n\tgetnode(r);\n\tmemset(r, 0, sizeof(*r));\n\tr->type = Node_val;\n\tr->valref = 1;\n\tr->flags = (flags|MALLOC|NUMBER|NUMCUR);\n\treturn r;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "NODE",
        "*\nmake_number_node(unsigned int flags)",
        "*"
      ]
    },
    "str_terminate_f": {
      "start_point": [
        2024,
        0
      ],
      "end_point": [
        2029,
        1
      ],
      "content": "static inline void\nstr_terminate_f(NODE *n, char *savep)\n{\n\t*savep = n->stptr[n->stlen];\n\tn->stptr[n->stlen] = '\\0';\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    }
  },
  "gawk/gawk-4.2.1/awkgram.c": {
    "yy_symbol_value_print": {
      "start_point": [
        1288,
        0
      ],
      "end_point": [
        1300,
        1
      ],
      "content": "static void\nyy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)\n{\n  FILE *yyo = yyoutput;\n  YYUSE (yyo);\n  if (!yyvaluep)\n    return;\n# ifdef YYPRINT\n  if (yytype < YYNTOKENS)\n    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);\n# endif\n  YYUSE (yytype);\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yy_symbol_print": {
      "start_point": [
        1307,
        0
      ],
      "end_point": [
        1315,
        1
      ],
      "content": "static void\nyy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)\n{\n  YYFPRINTF (yyoutput, \"%s %s (\",\n             yytype < YYNTOKENS ? \"token\" : \"nterm\", yytname[yytype]);\n\n  yy_symbol_value_print (yyoutput, yytype, yyvaluep);\n  YYFPRINTF (yyoutput, \")\");\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yy_stack_print": {
      "start_point": [
        1322,
        0
      ],
      "end_point": [
        1332,
        1
      ],
      "content": "static void\nyy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)\n{\n  YYFPRINTF (stderr, \"Stack now\");\n  for (; yybottom <= yytop; yybottom++)\n    {\n      int yybot = *yybottom;\n      YYFPRINTF (stderr, \" %d\", yybot);\n    }\n  YYFPRINTF (stderr, \"\\n\");\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yy_reduce_print": {
      "start_point": [
        1345,
        0
      ],
      "end_point": [
        1363,
        1
      ],
      "content": "static void\nyy_reduce_print (yytype_int16 *yyssp, YYSTYPE *yyvsp, int yyrule)\n{\n  unsigned long int yylno = yyrline[yyrule];\n  int yynrhs = yyr2[yyrule];\n  int yyi;\n  YYFPRINTF (stderr, \"Reducing stack by rule %d (line %lu):\\n\",\n             yyrule - 1, yylno);\n  /* The symbols being reduced.  */\n  for (yyi = 0; yyi < yynrhs; yyi++)\n    {\n      YYFPRINTF (stderr, \"   $%d = \", yyi + 1);\n      yy_symbol_print (stderr,\n                       yystos[yyssp[yyi + 1 - yynrhs]],\n                       &(yyvsp[(yyi + 1) - (yynrhs)])\n                                              );\n      YYFPRINTF (stderr, \"\\n\");\n    }\n}",
      "lines": 19,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yystrlen": {
      "start_point": [
        1406,
        0
      ],
      "end_point": [
        1413,
        1
      ],
      "content": "static YYSIZE_T\nyystrlen (const char *yystr)\n{\n  YYSIZE_T yylen;\n  for (yylen = 0; yystr[yylen]; yylen++)\n    continue;\n  return yylen;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "YYSIZE_T"
      ]
    },
    "yystpcpy": {
      "start_point": [
        1423,
        0
      ],
      "end_point": [
        1433,
        1
      ],
      "content": "static char *\nyystpcpy (char *yydest, const char *yysrc)\n{\n  char *yyd = yydest;\n  const char *yys = yysrc;\n\n  while ((*yyd++ = *yys++) != '\\0')\n    continue;\n\n  return yyd - 1;\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nyystpcpy (char *yydest, const char *yysrc)",
        "*"
      ]
    },
    "yytnamerr": {
      "start_point": [
        1445,
        0
      ],
      "end_point": [
        1482,
        1
      ],
      "content": "static YYSIZE_T\nyytnamerr (char *yyres, const char *yystr)\n{\n  if (*yystr == '\"')\n    {\n      YYSIZE_T yyn = 0;\n      char const *yyp = yystr;\n\n      for (;;)\n        switch (*++yyp)\n          {\n          case '\\'':\n          case ',':\n            goto do_not_strip_quotes;\n\n          case '\\\\':\n            if (*++yyp != '\\\\')\n              goto do_not_strip_quotes;\n            /* Fall through.  */\n          default:\n            if (yyres)\n              yyres[yyn] = *yyp;\n            yyn++;\n            break;\n\n          case '\"':\n            if (yyres)\n              yyres[yyn] = '\\0';\n            return yyn;\n          }\n    do_not_strip_quotes: ;\n    }\n\n  if (! yyres)\n    return yystrlen (yystr);\n\n  return yystpcpy (yyres, yystr) - yyres;\n}",
      "lines": 38,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "YYSIZE_T"
      ]
    },
    "yysyntax_error": {
      "start_point": [
        1493,
        0
      ],
      "end_point": [
        1618,
        1
      ],
      "content": "static int\nyysyntax_error (YYSIZE_T *yymsg_alloc, char **yymsg,\n                yytype_int16 *yyssp, int yytoken)\n{\n  YYSIZE_T yysize0 = yytnamerr (YY_NULLPTR, yytname[yytoken]);\n  YYSIZE_T yysize = yysize0;\n  enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };\n  /* Internationalized format string. */\n  const char *yyformat = YY_NULLPTR;\n  /* Arguments of yyformat. */\n  char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];\n  /* Number of reported tokens (one for the \"unexpected\", one per\n     \"expected\"). */\n  int yycount = 0;\n\n  /* There are many possibilities here to consider:\n     - If this state is a consistent state with a default action, then\n       the only way this function was invoked is if the default action\n       is an error action.  In that case, don't check for expected\n       tokens because there are none.\n     - The only way there can be no lookahead present (in yychar) is if\n       this state is a consistent state with a default action.  Thus,\n       detecting the absence of a lookahead is sufficient to determine\n       that there is no unexpected or expected token to report.  In that\n       case, just report a simple \"syntax error\".\n     - Don't assume there isn't a lookahead just because this state is a\n       consistent state with a default action.  There might have been a\n       previous inconsistent state, consistent state with a non-default\n       action, or user semantic action that manipulated yychar.\n     - Of course, the expected token list depends on states to have\n       correct lookahead information, and it depends on the parser not\n       to perform extra reductions after fetching a lookahead from the\n       scanner and before detecting a syntax error.  Thus, state merging\n       (from LALR or IELR) and default reductions corrupt the expected\n       token list.  However, the list is correct for canonical LR with\n       one exception: it will still contain any token that will not be\n       accepted due to an error action in a later state.\n  */\n  if (yytoken != YYEMPTY)\n    {\n      int yyn = yypact[*yyssp];\n      yyarg[yycount++] = yytname[yytoken];\n      if (!yypact_value_is_default (yyn))\n        {\n          /* Start YYX at -YYN if negative to avoid negative indexes in\n             YYCHECK.  In other words, skip the first -YYN actions for\n             this state because they are default actions.  */\n          int yyxbegin = yyn < 0 ? -yyn : 0;\n          /* Stay within bounds of both yycheck and yytname.  */\n          int yychecklim = YYLAST - yyn + 1;\n          int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;\n          int yyx;\n\n          for (yyx = yyxbegin; yyx < yyxend; ++yyx)\n            if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR\n                && !yytable_value_is_error (yytable[yyx + yyn]))\n              {\n                if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)\n                  {\n                    yycount = 1;\n                    yysize = yysize0;\n                    break;\n                  }\n                yyarg[yycount++] = yytname[yyx];\n                {\n                  YYSIZE_T yysize1 = yysize + yytnamerr (YY_NULLPTR, yytname[yyx]);\n                  if (! (yysize <= yysize1\n                         && yysize1 <= YYSTACK_ALLOC_MAXIMUM))\n                    return 2;\n                  yysize = yysize1;\n                }\n              }\n        }\n    }\n\n  switch (yycount)\n    {\n# define YYCASE_(N, S)                      \\\n      case N:                               \\\n        yyformat = S;                       \\\n      break\n      YYCASE_(0, YY_(\"syntax error\"));\n      YYCASE_(1, YY_(\"syntax error, unexpected %s\"));\n      YYCASE_(2, YY_(\"syntax error, unexpected %s, expecting %s\"));\n      YYCASE_(3, YY_(\"syntax error, unexpected %s, expecting %s or %s\"));\n      YYCASE_(4, YY_(\"syntax error, unexpected %s, expecting %s or %s or %s\"));\n      YYCASE_(5, YY_(\"syntax error, unexpected %s, expecting %s or %s or %s or %s\"));\n# undef YYCASE_\n    }\n\n  {\n    YYSIZE_T yysize1 = yysize + yystrlen (yyformat);\n    if (! (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM))\n      return 2;\n    yysize = yysize1;\n  }\n\n  if (*yymsg_alloc < yysize)\n    {\n      *yymsg_alloc = 2 * yysize;\n      if (! (yysize <= *yymsg_alloc\n             && *yymsg_alloc <= YYSTACK_ALLOC_MAXIMUM))\n        *yymsg_alloc = YYSTACK_ALLOC_MAXIMUM;\n      return 1;\n    }\n\n  /* Avoid sprintf, as that infringes on the user's name space.\n     Don't have undefined behavior even if the translation\n     produced a string with the wrong number of \"%s\"s.  */\n  {\n    char *yyp = *yymsg;\n    int yyi = 0;\n    while ((*yyp = *yyformat) != '\\0')\n      if (*yyp == '%' && yyformat[1] == 's' && yyi < yycount)\n        {\n          yyp += yytnamerr (yyp, yyarg[yyi++]);\n          yyformat += 2;\n        }\n      else\n        {\n          yyp++;\n          yyformat++;\n        }\n  }\n  return 0;\n}",
      "lines": 126,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "yydestruct": {
      "start_point": [
        1625,
        0
      ],
      "end_point": [
        1636,
        1
      ],
      "content": "static void\nyydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)\n{\n  YYUSE (yyvaluep);\n  if (!yymsg)\n    yymsg = \"Deleting\";\n  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);\n\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  YYUSE (yytype);\n  YY_IGNORE_MAYBE_UNINITIALIZED_END\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yyparse": {
      "start_point": [
        1654,
        0
      ],
      "end_point": [
        4465,
        1
      ],
      "content": "int\nyyparse (void)\n{\n    int yystate;\n    /* Number of tokens to shift before error messages enabled.  */\n    int yyerrstatus;\n\n    /* The stacks and their tools:\n       'yyss': related to states.\n       'yyvs': related to semantic values.\n\n       Refer to the stacks through separate pointers, to allow yyoverflow\n       to reallocate them elsewhere.  */\n\n    /* The state stack.  */\n    yytype_int16 yyssa[YYINITDEPTH];\n    yytype_int16 *yyss;\n    yytype_int16 *yyssp;\n\n    /* The semantic value stack.  */\n    YYSTYPE yyvsa[YYINITDEPTH];\n    YYSTYPE *yyvs;\n    YYSTYPE *yyvsp;\n\n    YYSIZE_T yystacksize;\n\n  int yyn;\n  int yyresult;\n  /* Lookahead token as an internal (translated) token number.  */\n  int yytoken = 0;\n  /* The variables used to return semantic value and location from the\n     action routines.  */\n  YYSTYPE yyval;\n\n#if YYERROR_VERBOSE\n  /* Buffer for error messages, and its allocated size.  */\n  char yymsgbuf[128];\n  char *yymsg = yymsgbuf;\n  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;\n#endif\n\n#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))\n\n  /* The number of symbols on the RHS of the reduced rule.\n     Keep to zero when no symbol should be popped.  */\n  int yylen = 0;\n\n  yyssp = yyss = yyssa;\n  yyvsp = yyvs = yyvsa;\n  yystacksize = YYINITDEPTH;\n\n  YYDPRINTF ((stderr, \"Starting parse\\n\"));\n\n  yystate = 0;\n  yyerrstatus = 0;\n  yynerrs = 0;\n  yychar = YYEMPTY; /* Cause a token to be read.  */\n  goto yysetstate;\n\n/*------------------------------------------------------------.\n| yynewstate -- Push a new state, which is found in yystate.  |\n`------------------------------------------------------------*/\n yynewstate:\n  /* In all cases, when you get here, the value and location stacks\n     have just been pushed.  So pushing a state here evens the stacks.  */\n  yyssp++;\n\n yysetstate:\n  *yyssp = yystate;\n\n  if (yyss + yystacksize - 1 <= yyssp)\n    {\n      /* Get the current used size of the three stacks, in elements.  */\n      YYSIZE_T yysize = yyssp - yyss + 1;\n\n#ifdef yyoverflow\n      {\n        /* Give user a chance to reallocate the stack.  Use copies of\n           these so that the &'s don't force the real ones into\n           memory.  */\n        YYSTYPE *yyvs1 = yyvs;\n        yytype_int16 *yyss1 = yyss;\n\n        /* Each stack pointer address is followed by the size of the\n           data in use in that stack, in bytes.  This used to be a\n           conditional around just the two extra args, but that might\n           be undefined if yyoverflow is a macro.  */\n        yyoverflow (YY_(\"memory exhausted\"),\n                    &yyss1, yysize * sizeof (*yyssp),\n                    &yyvs1, yysize * sizeof (*yyvsp),\n                    &yystacksize);\n\n        yyss = yyss1;\n        yyvs = yyvs1;\n      }\n#else /* no yyoverflow */\n# ifndef YYSTACK_RELOCATE\n      goto yyexhaustedlab;\n# else\n      /* Extend the stack our own way.  */\n      if (YYMAXDEPTH <= yystacksize)\n        goto yyexhaustedlab;\n      yystacksize *= 2;\n      if (YYMAXDEPTH < yystacksize)\n        yystacksize = YYMAXDEPTH;\n\n      {\n        yytype_int16 *yyss1 = yyss;\n        union yyalloc *yyptr =\n          (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));\n        if (! yyptr)\n          goto yyexhaustedlab;\n        YYSTACK_RELOCATE (yyss_alloc, yyss);\n        YYSTACK_RELOCATE (yyvs_alloc, yyvs);\n#  undef YYSTACK_RELOCATE\n        if (yyss1 != yyssa)\n          YYSTACK_FREE (yyss1);\n      }\n# endif\n#endif /* no yyoverflow */\n\n      yyssp = yyss + yysize - 1;\n      yyvsp = yyvs + yysize - 1;\n\n      YYDPRINTF ((stderr, \"Stack size increased to %lu\\n\",\n                  (unsigned long int) yystacksize));\n\n      if (yyss + yystacksize - 1 <= yyssp)\n        YYABORT;\n    }\n\n  YYDPRINTF ((stderr, \"Entering state %d\\n\", yystate));\n\n  if (yystate == YYFINAL)\n    YYACCEPT;\n\n  goto yybackup;\n\n/*-----------.\n| yybackup.  |\n`-----------*/\nyybackup:\n\n  /* Do appropriate processing given the current state.  Read a\n     lookahead token if we need one and don't already have one.  */\n\n  /* First try to decide what to do without reference to lookahead token.  */\n  yyn = yypact[yystate];\n  if (yypact_value_is_default (yyn))\n    goto yydefault;\n\n  /* Not known => get a lookahead token if don't already have one.  */\n\n  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */\n  if (yychar == YYEMPTY)\n    {\n      YYDPRINTF ((stderr, \"Reading a token: \"));\n      yychar = yylex ();\n    }\n\n  if (yychar <= YYEOF)\n    {\n      yychar = yytoken = YYEOF;\n      YYDPRINTF ((stderr, \"Now at end of input.\\n\"));\n    }\n  else\n    {\n      yytoken = YYTRANSLATE (yychar);\n      YY_SYMBOL_PRINT (\"Next token is\", yytoken, &yylval, &yylloc);\n    }\n\n  /* If the proper action on seeing token YYTOKEN is to reduce or to\n     detect an error, take that action.  */\n  yyn += yytoken;\n  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)\n    goto yydefault;\n  yyn = yytable[yyn];\n  if (yyn <= 0)\n    {\n      if (yytable_value_is_error (yyn))\n        goto yyerrlab;\n      yyn = -yyn;\n      goto yyreduce;\n    }\n\n  /* Count tokens shifted since error; after three, turn off error\n     status.  */\n  if (yyerrstatus)\n    yyerrstatus--;\n\n  /* Shift the lookahead token.  */\n  YY_SYMBOL_PRINT (\"Shifting\", yytoken, &yylval, &yylloc);\n\n  /* Discard the shifted token.  */\n  yychar = YYEMPTY;\n\n  yystate = yyn;\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  *++yyvsp = yylval;\n  YY_IGNORE_MAYBE_UNINITIALIZED_END\n\n  goto yynewstate;\n\n\n/*-----------------------------------------------------------.\n| yydefault -- do the default action for the current state.  |\n`-----------------------------------------------------------*/\nyydefault:\n  yyn = yydefact[yystate];\n  if (yyn == 0)\n    goto yyerrlab;\n  goto yyreduce;\n\n\n/*-----------------------------.\n| yyreduce -- Do a reduction.  |\n`-----------------------------*/\nyyreduce:\n  /* yyn is the number of a rule to reduce with.  */\n  yylen = yyr2[yyn];\n\n  /* If YYLEN is nonzero, implement the default value of the action:\n     '$$ = $1'.\n\n     Otherwise, the following line sets YYVAL to garbage.\n     This behavior is undocumented and Bison\n     users should not rely upon it.  Assigning to YYVAL\n     unconditionally makes the parser a bit smaller, and it avoids a\n     GCC warning that YYVAL may be used uninitialized.  */\n  yyval = yyvsp[1-yylen];\n\n\n  YY_REDUCE_PRINT (yyn);\n  switch (yyn)\n    {\n        case 3:\n#line 218 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\trule = 0;\n\t\tyyerrok;\n\t  }\n#line 1897 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 5:\n#line 224 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\tnext_sourcefile();\n\t  }\n#line 1905 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 6:\n#line 228 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\trule = 0;\n\t\t/*\n\t\t * If errors, give up, don't produce an infinite\n\t\t * stream of syntax error messages.\n\t\t */\n  \t\t/* yyerrok; */\n\t  }\n#line 1918 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 7:\n#line 240 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\t(void) append_rule((yyvsp[-1]), (yyvsp[0]));\n\t\tfirst_rule = false;\n\t  }\n#line 1927 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 8:\n#line 245 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\tif (rule != Rule) {\n\t\t\tmsg(_(\"%s blocks must have an action part\"), ruletab[rule]);\n\t\t\terrcount++;\n\t\t} else if ((yyvsp[-1]) == NULL) {\n\t\t\tmsg(_(\"each rule must have a pattern or an action part\"));\n\t\t\terrcount++;\n\t\t} else\t\t/* pattern rule with non-empty pattern */\n\t\t\t(void) append_rule((yyvsp[-1]), NULL);\n\t  }\n#line 1942 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 9:\n#line 256 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\tin_function = NULL;\n\t\t(void) mk_function((yyvsp[-1]), (yyvsp[0]));\n\t\twant_param_names = DONT_CHECK;\n\t\tyyerrok;\n\t  }\n#line 1953 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 10:\n#line 263 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\twant_source = false;\n\t\tat_seen = false;\n\t\tyyerrok;\n\t  }\n#line 1963 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 11:\n#line 269 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\twant_source = false;\n\t\tat_seen = false;\n\t\tyyerrok;\n\t  }\n#line 1973 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 12:\n#line 278 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\tif (include_source((yyvsp[0])) < 0)\n\t\t\tYYABORT;\n\t\tefree((yyvsp[0])->lextok);\n\t\tbcfree((yyvsp[0]));\n\t\t(yyval) = NULL;\n\t  }\n#line 1985 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 13:\n#line 286 \"awkgram.y\" /* yacc.c:1646  */\n    { (yyval) = NULL; }\n#line 1991 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 14:\n#line 288 \"awkgram.y\" /* yacc.c:1646  */\n    { (yyval) = NULL; }\n#line 1997 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 15:\n#line 293 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\tif (load_library((yyvsp[0])) < 0)\n\t\t\tYYABORT;\n\t\tefree((yyvsp[0])->lextok);\n\t\tbcfree((yyvsp[0]));\n\t\t(yyval) = NULL;\n\t  }\n#line 2009 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 16:\n#line 301 \"awkgram.y\" /* yacc.c:1646  */\n    { (yyval) = NULL; }\n#line 2015 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 17:\n#line 303 \"awkgram.y\" /* yacc.c:1646  */\n    { (yyval) = NULL; }\n#line 2021 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 18:\n#line 308 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\trule = Rule;\n\t\tif (comment != NULL) {\n\t\t\t(yyval) = list_create(comment);\n\t\t\tcomment = NULL;\n\t\t} else\n\t\t\t(yyval) = NULL;\n\t  }\n#line 2034 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 19:\n#line 317 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\trule = Rule;\n\t\tif (comment != NULL) {\n\t\t\t(yyval) = list_prepend((yyvsp[0]), comment);\n\t\t\tcomment = NULL;\n\t\t} else\n\t\t\t(yyval) = (yyvsp[0]);\n\t  }\n#line 2047 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 20:\n#line 327 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\tINSTRUCTION *tp;\n\n\t\tadd_lint((yyvsp[-3]), LINT_assign_in_cond);\n\t\tadd_lint((yyvsp[0]), LINT_assign_in_cond);\n\n\t\ttp = instruction(Op_no_op);\n\t\tlist_prepend((yyvsp[-3]), bcalloc(Op_line_range, !!do_pretty_print + 1, 0));\n\t\t(yyvsp[-3])->nexti->triggered = false;\n\t\t(yyvsp[-3])->nexti->target_jmp = (yyvsp[0])->nexti;\n\n\t\tlist_append((yyvsp[-3]), instruction(Op_cond_pair));\n\t\t(yyvsp[-3])->lasti->line_range = (yyvsp[-3])->nexti;\n\t\t(yyvsp[-3])->lasti->target_jmp = tp;\n\n\t\tlist_append((yyvsp[0]), instruction(Op_cond_pair));\n\t\t(yyvsp[0])->lasti->line_range = (yyvsp[-3])->nexti;\n\t\t(yyvsp[0])->lasti->target_jmp = tp;\n\t\tif (do_pretty_print) {\n\t\t\t((yyvsp[-3])->nexti + 1)->condpair_left = (yyvsp[-3])->lasti;\n\t\t\t((yyvsp[-3])->nexti + 1)->condpair_right = (yyvsp[0])->lasti;\n\t\t}\n\t\tif (comment != NULL) {\n\t\t\t(yyval) = list_append(list_merge(list_prepend((yyvsp[-3]), comment), (yyvsp[0])), tp);\n\t\t\tcomment = NULL;\n\t\t} else\n\t\t\t(yyval) = list_append(list_merge((yyvsp[-3]), (yyvsp[0])), tp);\n\t\trule = Rule;\n\t  }\n#line 2081 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 21:\n#line 357 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\tstatic int begin_seen = 0;\n\n\t\tfunc_first = false;\n\t\tif (do_lint_old && ++begin_seen == 2)\n\t\t\twarning_ln((yyvsp[0])->source_line,\n\t\t\t\t_(\"old awk does not support multiple `BEGIN' or `END' rules\"));\n\n\t\t(yyvsp[0])->in_rule = rule = BEGIN;\n\t\t(yyvsp[0])->source_file = source;\n\t\tcheck_comment();\n\t\t(yyval) = (yyvsp[0]);\n\t  }\n#line 2099 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 22:\n#line 371 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\tstatic int end_seen = 0;\n\n\t\tfunc_first = false;\n\t\tif (do_lint_old && ++end_seen == 2)\n\t\t\twarning_ln((yyvsp[0])->source_line,\n\t\t\t\t_(\"old awk does not support multiple `BEGIN' or `END' rules\"));\n\n\t\t(yyvsp[0])->in_rule = rule = END;\n\t\t(yyvsp[0])->source_file = source;\n\t\tcheck_comment();\n\t\t(yyval) = (yyvsp[0]);\n\t  }\n#line 2117 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 23:\n#line 385 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\tfunc_first = false;\n\t\t(yyvsp[0])->in_rule = rule = BEGINFILE;\n\t\t(yyvsp[0])->source_file = source;\n\t\tcheck_comment();\n\t\t(yyval) = (yyvsp[0]);\n\t  }\n#line 2129 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 24:\n#line 393 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\tfunc_first = false;\n\t\t(yyvsp[0])->in_rule = rule = ENDFILE;\n\t\t(yyvsp[0])->source_file = source;\n\t\tcheck_comment();\n\t\t(yyval) = (yyvsp[0]);\n\t  }\n#line 2141 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 25:\n#line 404 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\tINSTRUCTION *ip;\n\t\tif ((yyvsp[-3]) == NULL)\n\t\t\tip = list_create(instruction(Op_no_op));\n\t\telse\n\t\t\tip = (yyvsp[-3]);\n\t\t(yyval) = ip;\n\t  }\n#line 2154 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 26:\n#line 416 \"awkgram.y\" /* yacc.c:1646  */\n    { (yyval) = (yyvsp[0]); }\n#line 2160 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 27:\n#line 418 \"awkgram.y\" /* yacc.c:1646  */\n    { (yyval) = (yyvsp[0]); }\n#line 2166 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 28:\n#line 420 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\tyyerror(_(\"`%s' is a built-in function, it cannot be redefined\"),\n\t\t\t\t\ttokstart);\n\t\tYYABORT;\n\t  }\n#line 2176 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 29:\n#line 426 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\t(yyval) = (yyvsp[0]);\n\t\tat_seen = false;\n\t  }\n#line 2185 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 32:\n#line 438 \"awkgram.y\" /* yacc.c:1646  */\n    { want_param_names = FUNC_HEADER; }\n#line 2191 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 33:\n#line 439 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\t/*\n\t\t *  treat any comments between BOF and the first function\n\t\t *  definition (with no intervening BEGIN etc block) as\n\t\t *  program comments.  Special kludge: iff there are more\n\t\t *  than one such comments, treat the last as a function\n\t\t *  comment.\n\t\t */\n\t\tif (prior_comment != NULL) {\n\t\t\tcomment_to_save = prior_comment;\n\t\t\tprior_comment = NULL;\n\t\t} else if (comment != NULL) {\n\t\t\tcomment_to_save = comment;\n\t\t\tcomment = NULL;\n\t\t} else\n\t\t\tcomment_to_save = NULL;\n\n\t\tif (comment_to_save != NULL && func_first\n\t\t    && strstr(comment_to_save->memory->stptr, \"\\n\\n\") != NULL)\n\t\t\tsplit_comment();\n\n\t\t/* save any other pre-function comment as function comment  */\n\t\tif (comment_to_save != NULL) {\n\t\t\tfunction_comment = comment_to_save;\n\t\t\tcomment_to_save = NULL;\n\t\t}\n\t\tfunc_first = false;\n\t\t(yyvsp[-6])->source_file = source;\n\t\tif (install_function((yyvsp[-5])->lextok, (yyvsp[-6]), (yyvsp[-2])) < 0)\n\t\t\tYYABORT;\n\t\tin_function = (yyvsp[-5])->lextok;\n\t\t(yyvsp[-5])->lextok = NULL;\n\t\tbcfree((yyvsp[-5]));\n\t\t/* $5 already free'd in install_function */\n\t\t(yyval) = (yyvsp[-6]);\n\t\twant_param_names = FUNC_BODY;\n\t  }\n#line 2233 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 34:\n#line 484 \"awkgram.y\" /* yacc.c:1646  */\n    { want_regexp = true; }\n#line 2239 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 35:\n#line 486 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\t  NODE *n, *exp;\n\t\t  char *re;\n\t\t  size_t len;\n\n\t\t  re = (yyvsp[0])->lextok;\n\t\t  (yyvsp[0])->lextok = NULL;\n\t\t  len = strlen(re);\n\t\t  if (do_lint) {\n\t\t\tif (len == 0)\n\t\t\t\tlintwarn_ln((yyvsp[0])->source_line,\n\t\t\t\t\t_(\"regexp constant `//' looks like a C++ comment, but is not\"));\n\t\t\telse if (re[0] == '*' && re[len-1] == '*')\n\t\t\t\t/* possible C comment */\n\t\t\t\tlintwarn_ln((yyvsp[0])->source_line,\n\t\t\t\t\t_(\"regexp constant `/%s/' looks like a C comment, but is not\"), re);\n\t\t  }\n\n\t\t  exp = make_str_node(re, len, ALREADY_MALLOCED);\n\t\t  n = make_regnode(Node_regex, exp);\n\t\t  if (n == NULL) {\n\t\t\tunref(exp);\n\t\t\tYYABORT;\n\t\t  }\n\t\t  (yyval) = (yyvsp[0]);\n\t\t  (yyval)->opcode = Op_match_rec;\n\t\t  (yyval)->memory = n;\n\t\t}\n#line 2272 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 36:\n#line 518 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\t  char *re;\n\t\t  size_t len;\n\n\t\t  re = (yyvsp[0])->lextok;\n\t\t  (yyvsp[0])->lextok = NULL;\n\t\t  len = strlen(re);\n\n\t\t  (yyval) = (yyvsp[0]);\n\t\t  (yyval)->opcode = Op_push_re;\n\t\t  (yyval)->memory = make_typed_regex(re, len);\n\t\t}\n#line 2289 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 37:\n#line 533 \"awkgram.y\" /* yacc.c:1646  */\n    { bcfree((yyvsp[0])); }\n#line 2295 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 39:\n#line 539 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\tif (prior_comment != NULL) {\n\t\t\t(yyval) = list_create(prior_comment);\n\t\t\tprior_comment = NULL;\n\t\t} else if (comment != NULL) {\n\t\t\t(yyval) = list_create(comment);\n\t\t\tcomment = NULL;\n\t\t} else\n\t\t\t(yyval) = NULL;\n\t  }\n#line 2310 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 40:\n#line 550 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\tif ((yyvsp[0]) == NULL) {\n\t\t\tif (prior_comment != NULL) {\n\t\t\t\t(yyval) = list_append((yyvsp[-1]), prior_comment);\n\t\t\t\tprior_comment = NULL;\n\t\t\t\tif (comment != NULL) {\n\t\t\t\t\t(yyval) = list_append((yyval), comment);\n\t\t\t\t\tcomment = NULL;\n\t\t\t\t}\n\t\t\t} else if (comment != NULL) {\n\t\t\t\t(yyval) = list_append((yyvsp[-1]), comment);\n\t\t\t\tcomment = NULL;\n\t\t\t} else\n\t\t\t\t(yyval) = (yyvsp[-1]);\n\t\t} else {\n\t\t\tadd_lint((yyvsp[0]), LINT_no_effect);\n\t\t\tif ((yyvsp[-1]) == NULL) {\n\t\t\t\tif (prior_comment != NULL) {\n\t\t\t\t\t(yyval) = list_append((yyvsp[0]), prior_comment);\n\t\t\t\t\tprior_comment = NULL;\n\t\t\t\t\tif (comment != NULL) {\n\t\t\t\t\t\t(yyval) = list_append((yyval), comment);\n\t\t\t\t\t\tcomment = NULL;\n\t\t\t\t\t}\n\t\t\t\t} else if (comment != NULL) {\n\t\t\t\t\t(yyval) = list_append((yyvsp[0]), comment);\n\t\t\t\t\tcomment = NULL;\n\t\t\t\t} else\n\t\t\t\t\t(yyval) = (yyvsp[0]);\n\t\t\t} else {\n\t\t\t\tif (prior_comment != NULL) {\n\t\t\t\t\tlist_append((yyvsp[0]), prior_comment);\n\t\t\t\t\tprior_comment = NULL;\n\t\t\t\t\tif (comment != NULL) {\n\t\t\t\t\t\tlist_append((yyvsp[0]), comment);\n\t\t\t\t\t\tcomment = NULL;\n\t\t\t\t\t}\n\t\t\t\t} else if (comment != NULL) {\n\t\t\t\t\tlist_append((yyvsp[0]), comment);\n\t\t\t\t\tcomment = NULL;\n\t\t\t\t}\n\t\t\t\t(yyval) = list_merge((yyvsp[-1]), (yyvsp[0]));\n\t\t\t}\n\t\t}\n\t\tyyerrok;\n\t  }\n#line 2361 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 41:\n#line 597 \"awkgram.y\" /* yacc.c:1646  */\n    {\t(yyval) = NULL; }\n#line 2367 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 44:\n#line 607 \"awkgram.y\" /* yacc.c:1646  */\n    { (yyval) = NULL; }\n#line 2373 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 45:\n#line 609 \"awkgram.y\" /* yacc.c:1646  */\n    { (yyval) = (yyvsp[-1]); }\n#line 2379 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 46:\n#line 611 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\tif (do_pretty_print)\n\t\t\t(yyval) = list_prepend((yyvsp[0]), instruction(Op_exec_count));\n\t\telse\n\t\t\t(yyval) = (yyvsp[0]);\n \t  }\n#line 2390 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 47:\n#line 618 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\tINSTRUCTION *dflt, *curr = NULL, *cexp, *cstmt;\n\t\tINSTRUCTION *ip, *nextc, *tbreak;\n\t\tconst char **case_values = NULL;\n\t\tint maxcount = 128;\n\t\tint case_count = 0;\n\t\tint i;\n\n\t\ttbreak = instruction(Op_no_op);\n\t\tcstmt = list_create(tbreak);\n\t\tcexp = list_create(instruction(Op_pop));\n\t\tdflt = instruction(Op_jmp);\n\t\tdflt->target_jmp = tbreak;\t/* if no case match and no explicit default */\n\n\t\tif ((yyvsp[-2]) != NULL) {\n\t\t\tcurr = (yyvsp[-2])->nexti;\n\t\t\tbcfree((yyvsp[-2]));\t/* Op_list */\n\t\t} /*  else\n\t\t\t\tcurr = NULL; */\n\n\t\tfor (; curr != NULL; curr = nextc) {\n\t\t\tINSTRUCTION *caseexp = curr->case_exp;\n\t\t\tINSTRUCTION *casestmt = curr->case_stmt;\n\n\t\t\tnextc = curr->nexti;\n\t\t\tif (curr->opcode == Op_K_case) {\n\t\t\t\tif (caseexp->opcode == Op_push_i) {\n\t\t\t\t\t/* a constant scalar */\n\t\t\t\t\tchar *caseval;\n\t\t\t\t\tcaseval = force_string(caseexp->memory)->stptr;\n\t\t\t\t\tfor (i = 0; i < case_count; i++) {\n\t\t\t\t\t\tif (strcmp(caseval, case_values[i]) == 0)\n\t\t\t\t\t\t\terror_ln(curr->source_line,\n\t\t\t\t\t\t\t\t_(\"duplicate case values in switch body: %s\"), caseval);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (case_values == NULL)\n\t\t\t\t\t\temalloc(case_values, const char **, sizeof(char *) * maxcount, \"statement\");\n\t\t\t\t\telse if (case_count >= maxcount) {\n\t\t\t\t\t\tmaxcount += 128;\n\t\t\t\t\t\terealloc(case_values, const char **, sizeof(char*) * maxcount, \"statement\");\n\t\t\t\t\t}\n\t\t\t\t\tcase_values[case_count++] = caseval;\n\t\t\t\t} else {\n\t\t\t\t\t/* match a constant regex against switch expression. */\n\t\t\t\t\t(curr + 1)->match_exp = true;\n\t\t\t\t}\n\t\t\t\tcurr->stmt_start = casestmt->nexti;\n\t\t\t\tcurr->stmt_end\t= casestmt->lasti;\n\t\t\t\t(void) list_prepend(cexp, curr);\n\t\t\t\t(void) list_prepend(cexp, caseexp);\n\t\t\t} else {\n\t\t\t\tif (dflt->target_jmp != tbreak)\n\t\t\t\t\terror_ln(curr->source_line,\n\t\t\t\t\t\t_(\"duplicate `default' detected in switch body\"));\n\t\t\t\telse\n\t\t\t\t\tdflt->target_jmp = casestmt->nexti;\n\n\t\t\t\tif (do_pretty_print) {\n\t\t\t\t\tcurr->stmt_start = casestmt->nexti;\n\t\t\t\t\tcurr->stmt_end = casestmt->lasti;\n\t\t\t\t\t(void) list_prepend(cexp, curr);\n\t\t\t\t} else\n\t\t\t\t\tbcfree(curr);\n\t\t\t}\n\n\t\t\tcstmt = list_merge(casestmt, cstmt);\n\t\t}\n\n\t\tif (case_values != NULL)\n\t\t\tefree(case_values);\n\n\t\tip = (yyvsp[-6]);\n\t\tif (do_pretty_print) {\n\t\t\t(void) list_prepend(ip, (yyvsp[-8]));\n\t\t\t(void) list_prepend(ip, instruction(Op_exec_count));\n\t\t\t(yyvsp[-8])->target_break = tbreak;\n\t\t\t((yyvsp[-8]) + 1)->switch_start = cexp->nexti;\n\t\t\t((yyvsp[-8]) + 1)->switch_end = cexp->lasti;\n\t\t}/* else\n\t\t\t\t$1 is NULL */\n\n\t\t(void) list_append(cexp, dflt);\n\t\t(void) list_merge(ip, cexp);\n\t\t(yyval) = list_merge(ip, cstmt);\n\n\t\tbreak_allowed--;\n\t\tfix_break_continue(ip, tbreak, NULL);\n\t  }\n#line 2484 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 48:\n#line 708 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\t/*\n\t\t *    -----------------\n\t\t * tc:\n\t\t *         cond\n\t\t *    -----------------\n\t\t *    [Op_jmp_false tb   ]\n\t\t *    -----------------\n\t\t *         body\n\t\t *    -----------------\n\t\t *    [Op_jmp      tc    ]\n\t\t * tb:[Op_no_op          ]\n\t\t */\n\n\t\tINSTRUCTION *ip, *tbreak, *tcont;\n\n\t\ttbreak = instruction(Op_no_op);\n\t\tadd_lint((yyvsp[-3]), LINT_assign_in_cond);\n\t\ttcont = (yyvsp[-3])->nexti;\n\t\tip = list_append((yyvsp[-3]), instruction(Op_jmp_false));\n\t\tip->lasti->target_jmp = tbreak;\n\n\t\tif (do_pretty_print) {\n\t\t\t(void) list_append(ip, instruction(Op_exec_count));\n\t\t\t(yyvsp[-5])->target_break = tbreak;\n\t\t\t(yyvsp[-5])->target_continue = tcont;\n\t\t\t((yyvsp[-5]) + 1)->while_body = ip->lasti;\n\t\t\t(void) list_prepend(ip, (yyvsp[-5]));\n\t\t}/* else\n\t\t\t\t$1 is NULL */\n\n\t\tif ((yyvsp[0]) != NULL)\n\t\t\t(void) list_merge(ip, (yyvsp[0]));\n\t\t(void) list_append(ip, instruction(Op_jmp));\n\t\tip->lasti->target_jmp = tcont;\n\t\t(yyval) = list_append(ip, tbreak);\n\n\t\tbreak_allowed--;\n\t\tcontinue_allowed--;\n\t\tfix_break_continue(ip, tbreak, tcont);\n\t  }\n#line 2530 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 49:\n#line 750 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\t/*\n\t\t *    -----------------\n\t\t * z:\n\t\t *         body\n\t\t *    -----------------\n\t\t * tc:\n\t\t *         cond\n\t\t *    -----------------\n\t\t *    [Op_jmp_true | z  ]\n\t\t * tb:[Op_no_op         ]\n\t\t */\n\n\t\tINSTRUCTION *ip, *tbreak, *tcont;\n\n\t\ttbreak = instruction(Op_no_op);\n\t\ttcont = (yyvsp[-2])->nexti;\n\t\tadd_lint((yyvsp[-2]), LINT_assign_in_cond);\n\t\tif ((yyvsp[-5]) != NULL)\n\t\t\tip = list_merge((yyvsp[-5]), (yyvsp[-2]));\n\t\telse\n\t\t\tip = list_prepend((yyvsp[-2]), instruction(Op_no_op));\n\t\tif (do_pretty_print)\n\t\t\t(void) list_prepend(ip, instruction(Op_exec_count));\n\t\t(void) list_append(ip, instruction(Op_jmp_true));\n\t\tip->lasti->target_jmp = ip->nexti;\n\t\t(yyval) = list_append(ip, tbreak);\n\n\t\tbreak_allowed--;\n\t\tcontinue_allowed--;\n\t\tfix_break_continue(ip, tbreak, tcont);\n\n\t\tif (do_pretty_print) {\n\t\t\t(yyvsp[-7])->target_break = tbreak;\n\t\t\t(yyvsp[-7])->target_continue = tcont;\n\t\t\t((yyvsp[-7]) + 1)->doloop_cond = tcont;\n\t\t\t(yyval) = list_prepend(ip, (yyvsp[-7]));\n\t\t\tbcfree((yyvsp[-4]));\n\t\t} /* else\n\t\t\t$1 and $4 are NULLs */\n\t  }\n#line 2576 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 50:\n#line 792 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\tINSTRUCTION *ip;\n\t\tchar *var_name = (yyvsp[-5])->lextok;\n\n\t\tif ((yyvsp[0]) != NULL\n\t\t\t\t&& (yyvsp[0])->lasti->opcode == Op_K_delete\n\t\t\t\t&& (yyvsp[0])->lasti->expr_count == 1\n\t\t\t\t&& (yyvsp[0])->nexti->opcode == Op_push\n\t\t\t\t&& ((yyvsp[0])->nexti->memory->type != Node_var || !((yyvsp[0])->nexti->memory->var_update))\n\t\t\t\t&& strcmp((yyvsp[0])->nexti->memory->vname, var_name) == 0\n\t\t) {\n\n\t\t/* Efficiency hack.  Recognize the special case of\n\t\t *\n\t\t * \tfor (iggy in foo)\n\t\t * \t\tdelete foo[iggy]\n\t\t *\n\t\t * and treat it as if it were\n\t\t *\n\t\t * \tdelete foo\n\t\t *\n\t\t * Check that the body is a `delete a[i]' statement,\n\t\t * and that both the loop var and array names match.\n\t\t */\n\t\t\tNODE *arr = NULL;\n\n\t\t\tip = (yyvsp[0])->nexti->nexti;\n\t\t\tif ((yyvsp[-3])->nexti->opcode == Op_push && (yyvsp[-3])->lasti == (yyvsp[-3])->nexti)\n\t\t\t\tarr = (yyvsp[-3])->nexti->memory;\n\t\t\tif (arr != NULL\n\t\t\t\t\t&& ip->opcode == Op_no_op\n\t\t\t\t\t&& ip->nexti->opcode == Op_push_array\n\t\t\t\t\t&& strcmp(ip->nexti->memory->vname, arr->vname) == 0\n\t\t\t\t\t&& ip->nexti->nexti == (yyvsp[0])->lasti\n\t\t\t) {\n\t\t\t\t(void) make_assignable((yyvsp[0])->nexti);\n\t\t\t\t(yyvsp[0])->lasti->opcode = Op_K_delete_loop;\n\t\t\t\t(yyvsp[0])->lasti->expr_count = 0;\n\t\t\t\tif ((yyvsp[-7]) != NULL)\n\t\t\t\t\tbcfree((yyvsp[-7]));\n\t\t\t\tefree(var_name);\n\t\t\t\tbcfree((yyvsp[-5]));\n\t\t\t\tbcfree((yyvsp[-4]));\n\t\t\t\tbcfree((yyvsp[-3]));\n\t\t\t\t(yyval) = (yyvsp[0]);\n\t\t\t} else\n\t\t\t\tgoto regular_loop;\n\t\t} else {\n\t\t\tINSTRUCTION *tbreak, *tcont;\n\n\t\t\t/*    [ Op_push_array a       ]\n\t\t\t *    [ Op_arrayfor_init | ib ]\n\t\t\t * ic:[ Op_arrayfor_incr | ib ]\n\t\t\t *    [ Op_var_assign if any  ]\n\t\t\t *\n\t\t\t *              body\n\t\t\t *\n\t\t\t *    [Op_jmp | ic            ]\n\t\t\t * ib:[Op_arrayfor_final      ]\n\t\t\t */\nregular_loop:\n\t\t\tip = (yyvsp[-3]);\n\t\t\tip->nexti->opcode = Op_push_array;\n\n\t\t\ttbreak = instruction(Op_arrayfor_final);\n\t\t\t(yyvsp[-4])->opcode = Op_arrayfor_incr;\n\t\t\t(yyvsp[-4])->array_var = variable((yyvsp[-5])->source_line, var_name, Node_var);\n\t\t\t(yyvsp[-4])->target_jmp = tbreak;\n\t\t\ttcont = (yyvsp[-4]);\n\t\t\t(yyvsp[-5])->opcode = Op_arrayfor_init;\n\t\t\t(yyvsp[-5])->target_jmp = tbreak;\n\t\t\t(void) list_append(ip, (yyvsp[-5]));\n\n\t\t\tif (do_pretty_print) {\n\t\t\t\t(yyvsp[-7])->opcode = Op_K_arrayfor;\n\t\t\t\t(yyvsp[-7])->target_continue = tcont;\n\t\t\t\t(yyvsp[-7])->target_break = tbreak;\n\t\t\t\t(void) list_append(ip, (yyvsp[-7]));\n\t\t\t} /* else\n\t\t\t\t\t$1 is NULL */\n\n\t\t\t/* add update_FOO instruction if necessary */\n\t\t\tif ((yyvsp[-4])->array_var->type == Node_var && (yyvsp[-4])->array_var->var_update) {\n\t\t\t\t(void) list_append(ip, instruction(Op_var_update));\n\t\t\t\tip->lasti->update_var = (yyvsp[-4])->array_var->var_update;\n\t\t\t}\n\t\t\t(void) list_append(ip, (yyvsp[-4]));\n\n\t\t\t/* add set_FOO instruction if necessary */\n\t\t\tif ((yyvsp[-4])->array_var->type == Node_var && (yyvsp[-4])->array_var->var_assign) {\n\t\t\t\t(void) list_append(ip, instruction(Op_var_assign));\n\t\t\t\tip->lasti->assign_var = (yyvsp[-4])->array_var->var_assign;\n\t\t\t}\n\n\t\t\tif (do_pretty_print) {\n\t\t\t\t(void) list_append(ip, instruction(Op_exec_count));\n\t\t\t\t((yyvsp[-7]) + 1)->forloop_cond = (yyvsp[-4]);\n\t\t\t\t((yyvsp[-7]) + 1)->forloop_body = ip->lasti;\n\t\t\t}\n\n\t\t\tif ((yyvsp[0]) != NULL)\n\t\t\t\t(void) list_merge(ip, (yyvsp[0]));\n\n\t\t\t(void) list_append(ip, instruction(Op_jmp));\n\t\t\tip->lasti->target_jmp = (yyvsp[-4]);\n\t\t\t(yyval) = list_append(ip, tbreak);\n\t\t\tfix_break_continue(ip, tbreak, tcont);\n\t\t}\n\n\t\tbreak_allowed--;\n\t\tcontinue_allowed--;\n\t  }\n#line 2693 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 51:\n#line 905 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\t(yyval) = mk_for_loop((yyvsp[-11]), (yyvsp[-9]), (yyvsp[-6]), (yyvsp[-3]), (yyvsp[0]));\n\n\t\tbreak_allowed--;\n\t\tcontinue_allowed--;\n\t  }\n#line 2704 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 52:\n#line 912 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\t(yyval) = mk_for_loop((yyvsp[-10]), (yyvsp[-8]), (INSTRUCTION *) NULL, (yyvsp[-3]), (yyvsp[0]));\n\n\t\tbreak_allowed--;\n\t\tcontinue_allowed--;\n\t  }\n#line 2715 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 53:\n#line 919 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\tif (do_pretty_print)\n\t\t\t(yyval) = list_prepend((yyvsp[0]), instruction(Op_exec_count));\n\t\telse\n\t\t\t(yyval) = (yyvsp[0]);\n\t\t(yyval) = add_pending_comment((yyval));\n\t  }\n#line 2727 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 54:\n#line 930 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\tif (! break_allowed)\n\t\t\terror_ln((yyvsp[-1])->source_line,\n\t\t\t\t_(\"`break' is not allowed outside a loop or switch\"));\n\t\t(yyvsp[-1])->target_jmp = NULL;\n\t\t(yyval) = list_create((yyvsp[-1]));\n\t\t(yyval) = add_pending_comment((yyval));\n\n\t  }\n#line 2741 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 55:\n#line 940 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\tif (! continue_allowed)\n\t\t\terror_ln((yyvsp[-1])->source_line,\n\t\t\t\t_(\"`continue' is not allowed outside a loop\"));\n\t\t(yyvsp[-1])->target_jmp = NULL;\n\t\t(yyval) = list_create((yyvsp[-1]));\n\t\t(yyval) = add_pending_comment((yyval));\n\n\t  }\n#line 2755 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 56:\n#line 950 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\t/* if inside function (rule = 0), resolve context at run-time */\n\t\tif (rule && rule != Rule)\n\t\t\terror_ln((yyvsp[-1])->source_line,\n\t\t\t\t_(\"`next' used in %s action\"), ruletab[rule]);\n\t\t(yyvsp[-1])->target_jmp = ip_rec;\n\t\t(yyval) = list_create((yyvsp[-1]));\n\t\t(yyval) = add_pending_comment((yyval));\n\t  }\n#line 2769 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 57:\n#line 960 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\t/* if inside function (rule = 0), resolve context at run-time */\n\t\tif (rule == BEGIN || rule == END || rule == ENDFILE)\n\t\t\terror_ln((yyvsp[-1])->source_line,\n\t\t\t\t_(\"`nextfile' used in %s action\"), ruletab[rule]);\n\n\t\t(yyvsp[-1])->target_newfile = ip_newfile;\n\t\t(yyvsp[-1])->target_endfile = ip_endfile;\n\t\t(yyval) = list_create((yyvsp[-1]));\n\t\t(yyval) = add_pending_comment((yyval));\n\t  }\n#line 2785 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 58:\n#line 972 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\t/* Initialize the two possible jump targets, the actual target\n\t\t * is resolved at run-time.\n\t\t */\n\t\t(yyvsp[-2])->target_end = ip_end;\t/* first instruction in end_block */\n\t\t(yyvsp[-2])->target_atexit = ip_atexit;\t/* cleanup and go home */\n\n\t\tif ((yyvsp[-1]) == NULL) {\n\t\t\t(yyval) = list_create((yyvsp[-2]));\n\t\t\t(void) list_prepend((yyval), instruction(Op_push_i));\n\t\t\t(yyval)->nexti->memory = dupnode(Nnull_string);\n\t\t} else\n\t\t\t(yyval) = list_append((yyvsp[-1]), (yyvsp[-2]));\n\t\t(yyval) = add_pending_comment((yyval));\n\t  }\n#line 2805 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 59:\n#line 988 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\tif (! in_function)\n\t\t\tyyerror(_(\"`return' used outside function context\"));\n\t  }\n#line 2814 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 60:\n#line 991 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\tif ((yyvsp[-1]) == NULL) {\n\t\t\t(yyval) = list_create((yyvsp[-3]));\n\t\t\t(void) list_prepend((yyval), instruction(Op_push_i));\n\t\t\t(yyval)->nexti->memory = dupnode(Nnull_string);\n\t\t} else {\n\t\t\tif (do_optimize\n\t\t\t\t&& (yyvsp[-1])->lasti->opcode == Op_func_call\n\t\t\t\t&& strcmp((yyvsp[-1])->lasti->func_name, in_function) == 0\n\t\t\t) {\n\t\t\t\t/* Do tail recursion optimization. Tail\n\t\t\t\t * call without a return value is recognized\n\t\t\t\t * in mk_function().\n\t\t\t\t */\n\t\t\t\t((yyvsp[-1])->lasti + 1)->tail_call = true;\n\t\t\t}\n\n\t\t\t(yyval) = list_append((yyvsp[-1]), (yyvsp[-3]));\n\t\t}\n\t\t(yyval) = add_pending_comment((yyval));\n\t  }\n#line 2840 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 62:\n#line 1024 \"awkgram.y\" /* yacc.c:1646  */\n    { in_print = true; in_parens = 0; }\n#line 2846 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 63:\n#line 1025 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\t/*\n\t\t * Optimization: plain `print' has no expression list, so $3 is null.\n\t\t * If $3 is NULL or is a bytecode list for $0 use Op_K_print_rec,\n\t\t * which is faster for these two cases.\n\t\t */\n\n\t\tif ((yyvsp[-3])->opcode == Op_K_print &&\n\t\t\t((yyvsp[-1]) == NULL\n\t\t\t\t|| ((yyvsp[-1])->lasti->opcode == Op_field_spec\n\t\t\t\t\t&& (yyvsp[-1])->nexti->nexti->nexti == (yyvsp[-1])->lasti\n\t\t\t\t\t&& (yyvsp[-1])->nexti->nexti->opcode == Op_push_i\n\t\t\t\t\t&& (yyvsp[-1])->nexti->nexti->memory->type == Node_val)\n\t\t\t)\n\t\t) {\n\t\t\tstatic bool warned = false;\n\t\t\t/*   -----------------\n\t\t\t *      output_redir\n\t\t\t *    [ redirect exp ]\n\t\t\t *   -----------------\n\t\t\t *     expression_list\n\t\t\t *   ------------------\n\t\t\t *    [Op_K_print_rec | NULL | redir_type | expr_count]\n\t\t\t */\n\n\t\t\tif ((yyvsp[-1]) != NULL) {\n\t\t\t\tNODE *n = (yyvsp[-1])->nexti->nexti->memory;\n\n\t\t\t\tif (! iszero(n))\n\t\t\t\t\tgoto regular_print;\n\n\t\t\t\tbcfree((yyvsp[-1])->lasti);\t\t\t/* Op_field_spec */\n\t\t\t\tunref(n);\t\t\t\t/* Node_val */\n\t\t\t\tbcfree((yyvsp[-1])->nexti->nexti);\t\t/* Op_push_i */\n\t\t\t\tbcfree((yyvsp[-1])->nexti);\t\t\t/* Op_list */\n\t\t\t\tbcfree((yyvsp[-1]));\t\t\t\t/* Op_list */\n\t\t\t} else {\n\t\t\t\tif (do_lint && (rule == BEGIN || rule == END) && ! warned) {\n\t\t\t\t\twarned = true;\n\t\t\t\t\tlintwarn_ln((yyvsp[-3])->source_line,\n\t\t_(\"plain `print' in BEGIN or END rule should probably be `print \\\"\\\"'\"));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t(yyvsp[-3])->expr_count = 0;\n\t\t\t(yyvsp[-3])->opcode = Op_K_print_rec;\n\t\t\tif ((yyvsp[0]) == NULL) {    /* no redircetion */\n\t\t\t\t(yyvsp[-3])->redir_type = redirect_none;\n\t\t\t\t(yyval) = list_create((yyvsp[-3]));\n\t\t\t} else {\n\t\t\t\tINSTRUCTION *ip;\n\t\t\t\tip = (yyvsp[0])->nexti;\n\t\t\t\t(yyvsp[-3])->redir_type = ip->redir_type;\n\t\t\t\t(yyvsp[0])->nexti = ip->nexti;\n\t\t\t\tbcfree(ip);\n\t\t\t\t(yyval) = list_append((yyvsp[0]), (yyvsp[-3]));\n\t\t\t}\n\t\t} else {\n\t\t\t/*   -----------------\n\t\t\t *    [ output_redir    ]\n\t\t\t *    [ redirect exp    ]\n\t\t\t *   -----------------\n\t\t\t *    [ expression_list ]\n\t\t\t *   ------------------\n\t\t\t *    [$1 | NULL | redir_type | expr_count]\n\t\t\t *\n\t\t\t */\nregular_print:\n\t\t\tif ((yyvsp[0]) == NULL) {\t\t/* no redirection */\n\t\t\t\tif ((yyvsp[-1]) == NULL)\t{\t/* printf without arg */\n\t\t\t\t\t(yyvsp[-3])->expr_count = 0;\n\t\t\t\t\t(yyvsp[-3])->redir_type = redirect_none;\n\t\t\t\t\t(yyval) = list_create((yyvsp[-3]));\n\t\t\t\t} else {\n\t\t\t\t\tINSTRUCTION *t = (yyvsp[-1]);\n\t\t\t\t\t(yyvsp[-3])->expr_count = count_expressions(&t, false);\n\t\t\t\t\t(yyvsp[-3])->redir_type = redirect_none;\n\t\t\t\t\t(yyval) = list_append(t, (yyvsp[-3]));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tINSTRUCTION *ip;\n\t\t\t\tip = (yyvsp[0])->nexti;\n\t\t\t\t(yyvsp[-3])->redir_type = ip->redir_type;\n\t\t\t\t(yyvsp[0])->nexti = ip->nexti;\n\t\t\t\tbcfree(ip);\n\t\t\t\tif ((yyvsp[-1]) == NULL) {\n\t\t\t\t\t(yyvsp[-3])->expr_count = 0;\n\t\t\t\t\t(yyval) = list_append((yyvsp[0]), (yyvsp[-3]));\n\t\t\t\t} else {\n\t\t\t\t\tINSTRUCTION *t = (yyvsp[-1]);\n\t\t\t\t\t(yyvsp[-3])->expr_count = count_expressions(&t, false);\n\t\t\t\t\t(yyval) = list_append(list_merge((yyvsp[0]), t), (yyvsp[-3]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t(yyval) = add_pending_comment((yyval));\n\t  }\n#line 2948 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 64:\n#line 1123 \"awkgram.y\" /* yacc.c:1646  */\n    { sub_counter = 0; }\n#line 2954 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 65:\n#line 1124 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\tchar *arr = (yyvsp[-2])->lextok;\n\n\t\t(yyvsp[-2])->opcode = Op_push_array;\n\t\t(yyvsp[-2])->memory = variable((yyvsp[-2])->source_line, arr, Node_var_new);\n\n\t\tif (! do_posix && ! do_traditional) {\n\t\t\tif ((yyvsp[-2])->memory == symbol_table)\n\t\t\t\tfatal(_(\"`delete' is not allowed with SYMTAB\"));\n\t\t\telse if ((yyvsp[-2])->memory == func_table)\n\t\t\t\tfatal(_(\"`delete' is not allowed with FUNCTAB\"));\n\t\t}\n\n\t\tif ((yyvsp[0]) == NULL) {\n\t\t\t/*\n\t\t\t * As of September 2012, POSIX has added support\n\t\t\t * for `delete array'. See:\n\t\t\t * http://austingroupbugs.net/view.php?id=544\n\t\t\t *\n\t\t\t * Thanks to Nathan Weeks for the initiative.\n\t\t\t *\n\t\t\t * Thus we no longer warn or check do_posix.\n\t\t\t * Also, since BWK awk supports it, we don't have to\n\t\t\t * check do_traditional either.\n\t\t\t */\n\t\t\t(yyvsp[-3])->expr_count = 0;\n\t\t\t(yyval) = list_append(list_create((yyvsp[-2])), (yyvsp[-3]));\n\t\t} else {\n\t\t\t(yyvsp[-3])->expr_count = sub_counter;\n\t\t\t(yyval) = list_append(list_append((yyvsp[0]), (yyvsp[-2])), (yyvsp[-3]));\n\t\t}\n\t\t(yyval) = add_pending_comment((yyval));\n\t  }\n#line 2992 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 66:\n#line 1162 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\tstatic bool warned = false;\n\t\tchar *arr = (yyvsp[-1])->lextok;\n\n\t\tif (do_lint && ! warned) {\n\t\t\twarned = true;\n\t\t\tlintwarn_ln((yyvsp[-3])->source_line,\n\t\t\t\t_(\"`delete(array)' is a non-portable tawk extension\"));\n\t\t}\n\t\tif (do_traditional) {\n\t\t\terror_ln((yyvsp[-3])->source_line,\n\t\t\t\t_(\"`delete(array)' is a non-portable tawk extension\"));\n\t\t}\n\t\t(yyvsp[-1])->memory = variable((yyvsp[-1])->source_line, arr, Node_var_new);\n\t\t(yyvsp[-1])->opcode = Op_push_array;\n\t\t(yyvsp[-3])->expr_count = 0;\n\t\t(yyval) = list_append(list_create((yyvsp[-1])), (yyvsp[-3]));\n\n\t\tif (! do_posix && ! do_traditional) {\n\t\t\tif ((yyvsp[-1])->memory == symbol_table)\n\t\t\t\tfatal(_(\"`delete' is not allowed with SYMTAB\"));\n\t\t\telse if ((yyvsp[-1])->memory == func_table)\n\t\t\t\tfatal(_(\"`delete' is not allowed with FUNCTAB\"));\n\t\t}\n\t\t(yyval) = add_pending_comment((yyval));\n\t  }\n#line 3023 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 67:\n#line 1189 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\t(yyval) = optimize_assignment((yyvsp[0]));\n\t\t(yyval) = add_pending_comment((yyval));\n\t  }\n#line 3032 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 68:\n#line 1197 \"awkgram.y\" /* yacc.c:1646  */\n    { (yyval) = NULL; }\n#line 3038 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 69:\n#line 1199 \"awkgram.y\" /* yacc.c:1646  */\n    { (yyval) = (yyvsp[0]); }\n#line 3044 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 70:\n#line 1204 \"awkgram.y\" /* yacc.c:1646  */\n    { (yyval) = NULL; }\n#line 3050 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 71:\n#line 1206 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\tif ((yyvsp[-1]) == NULL)\n\t\t\t(yyval) = list_create((yyvsp[0]));\n\t\telse\n\t\t\t(yyval) = list_prepend((yyvsp[-1]), (yyvsp[0]));\n\t  }\n#line 3061 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 72:\n#line 1213 \"awkgram.y\" /* yacc.c:1646  */\n    { (yyval) = NULL; }\n#line 3067 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 73:\n#line 1218 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\tINSTRUCTION *casestmt = (yyvsp[0]);\n\t\tif ((yyvsp[0]) == NULL)\n\t\t\tcasestmt = list_create(instruction(Op_no_op));\n\t\tif (do_pretty_print)\n\t\t\t(void) list_prepend(casestmt, instruction(Op_exec_count));\n\t\t(yyvsp[-4])->case_exp = (yyvsp[-3]);\n\t\t(yyvsp[-4])->case_stmt = casestmt;\n\t\tbcfree((yyvsp[-2]));\n\t\t(yyval) = (yyvsp[-4]);\n\t  }\n#line 3083 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 74:\n#line 1230 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\tINSTRUCTION *casestmt = (yyvsp[0]);\n\t\tif ((yyvsp[0]) == NULL)\n\t\t\tcasestmt = list_create(instruction(Op_no_op));\n\t\tif (do_pretty_print)\n\t\t\t(void) list_prepend(casestmt, instruction(Op_exec_count));\n\t\tbcfree((yyvsp[-2]));\n\t\t(yyvsp[-3])->case_stmt = casestmt;\n\t\t(yyval) = (yyvsp[-3]);\n\t  }\n#line 3098 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 75:\n#line 1244 \"awkgram.y\" /* yacc.c:1646  */\n    {\t(yyval) = (yyvsp[0]); }\n#line 3104 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 76:\n#line 1246 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\tNODE *n = (yyvsp[0])->memory;\n\t\t(void) force_number(n);\n\t\tnegate_num(n);\n\t\tbcfree((yyvsp[-1]));\n\t\t(yyval) = (yyvsp[0]);\n\t  }\n#line 3116 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 77:\n#line 1254 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\tNODE *n = (yyvsp[0])->lasti->memory;\n\t\tbcfree((yyvsp[-1]));\n\t\tadd_sign_to_num(n, '+');\n\t\t(yyval) = (yyvsp[0]);\n\t  }\n#line 3127 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 78:\n#line 1261 \"awkgram.y\" /* yacc.c:1646  */\n    {\t(yyval) = (yyvsp[0]); }\n#line 3133 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 79:\n#line 1263 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\tif ((yyvsp[0])->memory->type == Node_regex)\n\t\t\t(yyvsp[0])->opcode = Op_push_re;\n\t\telse\n\t\t\t(yyvsp[0])->opcode = Op_push;\n\t\t(yyval) = (yyvsp[0]);\n\t  }\n#line 3145 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 80:\n#line 1271 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\tassert(((yyvsp[0])->memory->flags & REGEX) == REGEX);\n\t\t(yyvsp[0])->opcode = Op_push_re;\n\t\t(yyval) = (yyvsp[0]);\n\t  }\n#line 3155 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 81:\n#line 1280 \"awkgram.y\" /* yacc.c:1646  */\n    { (yyval) = (yyvsp[0]); }\n#line 3161 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 82:\n#line 1282 \"awkgram.y\" /* yacc.c:1646  */\n    { (yyval) = (yyvsp[0]); }\n#line 3167 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 84:\n#line 1292 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\t(yyval) = (yyvsp[-1]);\n\t  }\n#line 3175 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 85:\n#line 1299 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\tin_print = false;\n\t\tin_parens = 0;\n\t\t(yyval) = NULL;\n\t  }\n#line 3185 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 86:\n#line 1304 \"awkgram.y\" /* yacc.c:1646  */\n    { in_print = false; in_parens = 0; }\n#line 3191 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 87:\n#line 1305 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\tif ((yyvsp[-2])->redir_type == redirect_twoway\n\t\t    \t&& (yyvsp[0])->lasti->opcode == Op_K_getline_redir\n\t\t   \t \t&& (yyvsp[0])->lasti->redir_type == redirect_twoway)\n\t\t\tyyerror(_(\"multistage two-way pipelines don't work\"));\n\t\t(yyval) = list_prepend((yyvsp[0]), (yyvsp[-2]));\n\t  }\n#line 3203 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 88:\n#line 1316 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\t(yyval) = mk_condition((yyvsp[-3]), (yyvsp[-5]), (yyvsp[0]), NULL, NULL);\n\t  }\n#line 3211 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 89:\n#line 1321 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\t(yyval) = mk_condition((yyvsp[-6]), (yyvsp[-8]), (yyvsp[-3]), (yyvsp[-2]), (yyvsp[0]));\n\t  }\n#line 3219 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 94:\n#line 1338 \"awkgram.y\" /* yacc.c:1646  */\n    { (yyval) = NULL; }\n#line 3225 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 95:\n#line 1340 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\tbcfree((yyvsp[-1]));\n\t\t(yyval) = (yyvsp[0]);\n\t  }\n#line 3234 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 96:\n#line 1348 \"awkgram.y\" /* yacc.c:1646  */\n    { (yyval) = NULL; }\n#line 3240 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 97:\n#line 1350 \"awkgram.y\" /* yacc.c:1646  */\n    { (yyval) = (yyvsp[0]); }\n#line 3246 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 98:\n#line 1355 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\t(yyvsp[0])->param_count = 0;\n\t\t(yyval) = list_create((yyvsp[0]));\n\t  }\n#line 3255 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 99:\n#line 1360 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\tif ((yyvsp[-2]) != NULL && (yyvsp[0]) != NULL) {\n\t\t\t(yyvsp[0])->param_count =  (yyvsp[-2])->lasti->param_count + 1;\n\t\t\t(yyval) = list_append((yyvsp[-2]), (yyvsp[0]));\n\t\t\tyyerrok;\n\t\t} else\n\t\t\t(yyval) = NULL;\n\t  }\n#line 3268 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 100:\n#line 1369 \"awkgram.y\" /* yacc.c:1646  */\n    { (yyval) = NULL; }\n#line 3274 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 101:\n#line 1371 \"awkgram.y\" /* yacc.c:1646  */\n    { (yyval) = (yyvsp[-1]); }\n#line 3280 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 102:\n#line 1373 \"awkgram.y\" /* yacc.c:1646  */\n    { (yyval) = (yyvsp[-2]); }\n#line 3286 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 103:\n#line 1379 \"awkgram.y\" /* yacc.c:1646  */\n    { (yyval) = NULL; }\n#line 3292 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 104:\n#line 1381 \"awkgram.y\" /* yacc.c:1646  */\n    { (yyval) = (yyvsp[0]); }\n#line 3298 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 105:\n#line 1386 \"awkgram.y\" /* yacc.c:1646  */\n    { (yyval) = NULL; }\n#line 3304 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 106:\n#line 1388 \"awkgram.y\" /* yacc.c:1646  */\n    { (yyval) = (yyvsp[0]); }\n#line 3310 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 107:\n#line 1393 \"awkgram.y\" /* yacc.c:1646  */\n    {\t(yyval) = mk_expression_list(NULL, (yyvsp[0])); }\n#line 3316 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 108:\n#line 1395 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\t(yyval) = mk_expression_list((yyvsp[-2]), (yyvsp[0]));\n\t\tyyerrok;\n\t  }\n#line 3325 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 109:\n#line 1400 \"awkgram.y\" /* yacc.c:1646  */\n    { (yyval) = NULL; }\n#line 3331 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 110:\n#line 1402 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\t/*\n\t\t * Returning the expression list instead of NULL lets\n\t\t * snode get a list of arguments that it can count.\n\t\t */\n\t\t(yyval) = (yyvsp[-1]);\n\t  }\n#line 3343 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 111:\n#line 1410 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\t/* Ditto */\n\t\t(yyval) = mk_expression_list((yyvsp[-2]), (yyvsp[0]));\n\t  }\n#line 3352 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 112:\n#line 1415 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\t/* Ditto */\n\t\t(yyval) = (yyvsp[-2]);\n\t  }\n#line 3361 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 113:\n#line 1423 \"awkgram.y\" /* yacc.c:1646  */\n    { (yyval) = NULL; }\n#line 3367 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 114:\n#line 1425 \"awkgram.y\" /* yacc.c:1646  */\n    { (yyval) = (yyvsp[0]); }\n#line 3373 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 115:\n#line 1430 \"awkgram.y\" /* yacc.c:1646  */\n    {\t(yyval) = mk_expression_list(NULL, (yyvsp[0])); }\n#line 3379 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 116:\n#line 1432 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\t(yyval) = mk_expression_list((yyvsp[-2]), (yyvsp[0]));\n\t\tyyerrok;\n\t  }\n#line 3388 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 117:\n#line 1437 \"awkgram.y\" /* yacc.c:1646  */\n    { (yyval) = NULL; }\n#line 3394 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 118:\n#line 1439 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\t/*\n\t\t * Returning the expression list instead of NULL lets\n\t\t * snode get a list of arguments that it can count.\n\t\t */\n\t\t(yyval) = (yyvsp[-1]);\n\t  }\n#line 3406 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 119:\n#line 1447 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\t/* Ditto */\n\t\t(yyval) = mk_expression_list((yyvsp[-2]), (yyvsp[0]));\n\t  }\n#line 3415 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 120:\n#line 1452 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\t/* Ditto */\n\t\t(yyval) = (yyvsp[-2]);\n\t  }\n#line 3424 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 121:\n#line 1459 \"awkgram.y\" /* yacc.c:1646  */\n    { (yyval) = (yyvsp[0]); }\n#line 3430 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 122:\n#line 1460 \"awkgram.y\" /* yacc.c:1646  */\n    { (yyval) = list_create((yyvsp[0])); }\n#line 3436 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 123:\n#line 1466 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\tif (do_lint && (yyvsp[0])->lasti->opcode == Op_match_rec)\n\t\t\tlintwarn_ln((yyvsp[-1])->source_line,\n\t\t\t\t_(\"regular expression on right of assignment\"));\n\t\t(yyval) = mk_assignment((yyvsp[-2]), (yyvsp[0]), (yyvsp[-1]));\n\t  }\n#line 3447 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 124:\n#line 1473 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\t(yyval) = mk_assignment((yyvsp[-2]), list_create((yyvsp[0])), (yyvsp[-1]));\n\t  }\n#line 3455 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 125:\n#line 1477 \"awkgram.y\" /* yacc.c:1646  */\n    {\t(yyval) = mk_boolean((yyvsp[-2]), (yyvsp[0]), (yyvsp[-1])); }\n#line 3461 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 126:\n#line 1479 \"awkgram.y\" /* yacc.c:1646  */\n    {\t(yyval) = mk_boolean((yyvsp[-2]), (yyvsp[0]), (yyvsp[-1])); }\n#line 3467 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 127:\n#line 1481 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\tif ((yyvsp[-2])->lasti->opcode == Op_match_rec)\n\t\t\twarning_ln((yyvsp[-1])->source_line,\n\t\t\t\t_(\"regular expression on left of `~' or `!~' operator\"));\n\n\t\tassert((yyvsp[0])->opcode == Op_push_re\n\t\t\t&& ((yyvsp[0])->memory->flags & REGEX) != 0);\n\t\t/* RHS is @/.../ */\n\t\t(yyvsp[-1])->memory = (yyvsp[0])->memory;\n\t\tbcfree((yyvsp[0]));\n\t\t(yyval) = list_append((yyvsp[-2]), (yyvsp[-1]));\n\t  }\n#line 3484 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 128:\n#line 1494 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\tif ((yyvsp[-2])->lasti->opcode == Op_match_rec)\n\t\t\twarning_ln((yyvsp[-1])->source_line,\n\t\t\t\t_(\"regular expression on left of `~' or `!~' operator\"));\n\n\t\tif ((yyvsp[0])->lasti == (yyvsp[0])->nexti && (yyvsp[0])->nexti->opcode == Op_match_rec) {\n\t\t\t/* RHS is /.../ */\n\t\t\t(yyvsp[-1])->memory = (yyvsp[0])->nexti->memory;\n\t\t\tbcfree((yyvsp[0])->nexti);\t/* Op_match_rec */\n\t\t\tbcfree((yyvsp[0]));\t\t\t/* Op_list */\n\t\t\t(yyval) = list_append((yyvsp[-2]), (yyvsp[-1]));\n\t\t} else {\n\t\t\t(yyvsp[-1])->memory = make_regnode(Node_dynregex, NULL);\n\t\t\t(yyval) = list_append(list_merge((yyvsp[-2]), (yyvsp[0])), (yyvsp[-1]));\n\t\t}\n\t  }\n#line 3505 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 129:\n#line 1511 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\tif (do_lint_old)\n\t\t\twarning_ln((yyvsp[-1])->source_line,\n\t\t\t\t_(\"old awk does not support the keyword `in' except after `for'\"));\n\t\t(yyvsp[0])->nexti->opcode = Op_push_array;\n\t\t(yyvsp[-1])->opcode = Op_in_array;\n\t\t(yyvsp[-1])->expr_count = 1;\n\t\t(yyval) = list_append(list_merge((yyvsp[-2]), (yyvsp[0])), (yyvsp[-1]));\n\t  }\n#line 3519 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 130:\n#line 1521 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\tif (do_lint && (yyvsp[0])->lasti->opcode == Op_match_rec)\n\t\t\tlintwarn_ln((yyvsp[-1])->source_line,\n\t\t\t\t_(\"regular expression on right of comparison\"));\n\t\t(yyval) = list_append(list_merge((yyvsp[-2]), (yyvsp[0])), (yyvsp[-1]));\n\t  }\n#line 3530 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 131:\n#line 1528 \"awkgram.y\" /* yacc.c:1646  */\n    { (yyval) = mk_condition((yyvsp[-4]), (yyvsp[-3]), (yyvsp[-2]), (yyvsp[-1]), (yyvsp[0])); }\n#line 3536 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 132:\n#line 1530 \"awkgram.y\" /* yacc.c:1646  */\n    { (yyval) = (yyvsp[0]); }\n#line 3542 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 133:\n#line 1535 \"awkgram.y\" /* yacc.c:1646  */\n    { (yyval) = (yyvsp[0]); }\n#line 3548 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 134:\n#line 1537 \"awkgram.y\" /* yacc.c:1646  */\n    { (yyval) = (yyvsp[0]); }\n#line 3554 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 135:\n#line 1539 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\t(yyvsp[0])->opcode = Op_assign_quotient;\n\t\t(yyval) = (yyvsp[0]);\n\t  }\n#line 3563 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 136:\n#line 1547 \"awkgram.y\" /* yacc.c:1646  */\n    { (yyval) = (yyvsp[0]); }\n#line 3569 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 137:\n#line 1549 \"awkgram.y\" /* yacc.c:1646  */\n    { (yyval) = (yyvsp[0]); }\n#line 3575 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 138:\n#line 1554 \"awkgram.y\" /* yacc.c:1646  */\n    { (yyval) = (yyvsp[0]); }\n#line 3581 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 139:\n#line 1556 \"awkgram.y\" /* yacc.c:1646  */\n    { (yyval) = (yyvsp[0]); }\n#line 3587 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 140:\n#line 1561 \"awkgram.y\" /* yacc.c:1646  */\n    { (yyval) = (yyvsp[0]); }\n#line 3593 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 141:\n#line 1563 \"awkgram.y\" /* yacc.c:1646  */\n    { (yyval) = (yyvsp[0]); }\n#line 3599 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 142:\n#line 1565 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\tint count = 2;\n\t\tbool is_simple_var = false;\n\n\t\tif ((yyvsp[-1])->lasti->opcode == Op_concat) {\n\t\t\t/* multiple (> 2) adjacent strings optimization */\n\t\t\tis_simple_var = ((yyvsp[-1])->lasti->concat_flag & CSVAR) != 0;\n\t\t\tcount = (yyvsp[-1])->lasti->expr_count + 1;\n\t\t\t(yyvsp[-1])->lasti->opcode = Op_no_op;\n\t\t} else {\n\t\t\tis_simple_var = ((yyvsp[-1])->nexti->opcode == Op_push\n\t\t\t\t\t&& (yyvsp[-1])->lasti == (yyvsp[-1])->nexti); /* first exp. is a simple\n\t\t\t\t\t                             * variable?; kludge for use\n\t\t\t\t\t                             * in Op_assign_concat.\n\t\t \t\t\t                             */\n\t\t}\n\n\t\tif (do_optimize\n\t\t\t&& (yyvsp[-1])->nexti == (yyvsp[-1])->lasti && (yyvsp[-1])->nexti->opcode == Op_push_i\n\t\t\t&& (yyvsp[0])->nexti == (yyvsp[0])->lasti && (yyvsp[0])->nexti->opcode == Op_push_i\n\t\t) {\n\t\t\tNODE *n1 = (yyvsp[-1])->nexti->memory;\n\t\t\tNODE *n2 = (yyvsp[0])->nexti->memory;\n\t\t\tsize_t nlen;\n\n\t\t\t// 1.5 \"\"   # can't fold this if program mucks with CONVFMT.\n\t\t\t// See test #12 in test/posix.awk.\n\t\t\t// Also can't fold if one or the other is translatable.\n\t\t\tif ((n1->flags & (NUMBER|NUMINT|INTLSTR)) != 0 || (n2->flags & (NUMBER|NUMINT|INTLSTR)) != 0)\n\t\t\t\tgoto plain_concat;\n\n\t\t\tn1 = force_string(n1);\n\t\t\tn2 = force_string(n2);\n\t\t\tnlen = n1->stlen + n2->stlen;\n\t\t\terealloc(n1->stptr, char *, nlen + 1, \"constant fold\");\n\t\t\tmemcpy(n1->stptr + n1->stlen, n2->stptr, n2->stlen);\n\t\t\tn1->stlen = nlen;\n\t\t\tn1->stptr[nlen] = '\\0';\n\t\t\tn1->flags &= ~(NUMCUR|NUMBER|NUMINT);\n\t\t\tn1->flags |= (STRING|STRCUR);\n\t\t\tunref(n2);\n\t\t\tbcfree((yyvsp[0])->nexti);\n\t\t\tbcfree((yyvsp[0]));\n\t\t\t(yyval) = (yyvsp[-1]);\n\t\t} else {\n\tplain_concat:\n\t\t\t(yyval) = list_append(list_merge((yyvsp[-1]), (yyvsp[0])), instruction(Op_concat));\n\t\t\t(yyval)->lasti->concat_flag = (is_simple_var ? CSVAR : 0);\n\t\t\t(yyval)->lasti->expr_count = count;\n\t\t\tif (count > max_args)\n\t\t\t\tmax_args = count;\n\t\t}\n\t  }\n#line 3657 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 144:\n#line 1624 \"awkgram.y\" /* yacc.c:1646  */\n    { (yyval) = mk_binary((yyvsp[-2]), (yyvsp[0]), (yyvsp[-1])); }\n#line 3663 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 145:\n#line 1626 \"awkgram.y\" /* yacc.c:1646  */\n    { (yyval) = mk_binary((yyvsp[-2]), (yyvsp[0]), (yyvsp[-1])); }\n#line 3669 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 146:\n#line 1628 \"awkgram.y\" /* yacc.c:1646  */\n    { (yyval) = mk_binary((yyvsp[-2]), (yyvsp[0]), (yyvsp[-1])); }\n#line 3675 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 147:\n#line 1630 \"awkgram.y\" /* yacc.c:1646  */\n    { (yyval) = mk_binary((yyvsp[-2]), (yyvsp[0]), (yyvsp[-1])); }\n#line 3681 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 148:\n#line 1632 \"awkgram.y\" /* yacc.c:1646  */\n    { (yyval) = mk_binary((yyvsp[-2]), (yyvsp[0]), (yyvsp[-1])); }\n#line 3687 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 149:\n#line 1634 \"awkgram.y\" /* yacc.c:1646  */\n    { (yyval) = mk_binary((yyvsp[-2]), (yyvsp[0]), (yyvsp[-1])); }\n#line 3693 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 150:\n#line 1636 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\t/*\n\t\t * In BEGINFILE/ENDFILE, allow `getline [var] < file'\n\t\t */\n\n\t\tif ((rule == BEGINFILE || rule == ENDFILE) && (yyvsp[0]) == NULL)\n\t\t\terror_ln((yyvsp[-2])->source_line,\n\t\t\t\t _(\"non-redirected `getline' invalid inside `%s' rule\"), ruletab[rule]);\n\t\tif (do_lint && rule == END && (yyvsp[0]) == NULL)\n\t\t\tlintwarn_ln((yyvsp[-2])->source_line,\n\t\t\t\t_(\"non-redirected `getline' undefined inside END action\"));\n\t\t(yyval) = mk_getline((yyvsp[-2]), (yyvsp[-1]), (yyvsp[0]), redirect_input);\n\t  }\n#line 3711 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 151:\n#line 1650 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\t(yyvsp[0])->opcode = Op_postincrement;\n\t\t(yyval) = mk_assignment((yyvsp[-1]), NULL, (yyvsp[0]));\n\t  }\n#line 3720 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 152:\n#line 1655 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\t(yyvsp[0])->opcode = Op_postdecrement;\n\t\t(yyval) = mk_assignment((yyvsp[-1]), NULL, (yyvsp[0]));\n\t  }\n#line 3729 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 153:\n#line 1660 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\tif (do_lint_old) {\n\t\t    warning_ln((yyvsp[-1])->source_line,\n\t\t\t\t_(\"old awk does not support the keyword `in' except after `for'\"));\n\t\t    warning_ln((yyvsp[-1])->source_line,\n\t\t\t\t_(\"old awk does not support multidimensional arrays\"));\n\t\t}\n\t\t(yyvsp[0])->nexti->opcode = Op_push_array;\n\t\t(yyvsp[-1])->opcode = Op_in_array;\n\t\tif ((yyvsp[-3]) == NULL) {\t/* error */\n\t\t\terrcount++;\n\t\t\t(yyvsp[-1])->expr_count = 0;\n\t\t\t(yyval) = list_merge((yyvsp[0]), (yyvsp[-1]));\n\t\t} else {\n\t\t\tINSTRUCTION *t = (yyvsp[-3]);\n\t\t\t(yyvsp[-1])->expr_count = count_expressions(&t, false);\n\t\t\t(yyval) = list_append(list_merge(t, (yyvsp[0])), (yyvsp[-1]));\n\t\t}\n\t  }\n#line 3753 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 154:\n#line 1685 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\t  (yyval) = mk_getline((yyvsp[-1]), (yyvsp[0]), (yyvsp[-3]), (yyvsp[-2])->redir_type);\n\t\t  bcfree((yyvsp[-2]));\n\t\t}\n#line 3762 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 155:\n#line 1691 \"awkgram.y\" /* yacc.c:1646  */\n    { (yyval) = mk_binary((yyvsp[-2]), (yyvsp[0]), (yyvsp[-1])); }\n#line 3768 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 156:\n#line 1693 \"awkgram.y\" /* yacc.c:1646  */\n    { (yyval) = mk_binary((yyvsp[-2]), (yyvsp[0]), (yyvsp[-1])); }\n#line 3774 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 157:\n#line 1695 \"awkgram.y\" /* yacc.c:1646  */\n    { (yyval) = mk_binary((yyvsp[-2]), (yyvsp[0]), (yyvsp[-1])); }\n#line 3780 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 158:\n#line 1697 \"awkgram.y\" /* yacc.c:1646  */\n    { (yyval) = mk_binary((yyvsp[-2]), (yyvsp[0]), (yyvsp[-1])); }\n#line 3786 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 159:\n#line 1699 \"awkgram.y\" /* yacc.c:1646  */\n    { (yyval) = mk_binary((yyvsp[-2]), (yyvsp[0]), (yyvsp[-1])); }\n#line 3792 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 160:\n#line 1701 \"awkgram.y\" /* yacc.c:1646  */\n    { (yyval) = mk_binary((yyvsp[-2]), (yyvsp[0]), (yyvsp[-1])); }\n#line 3798 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 161:\n#line 1706 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\t(yyval) = list_create((yyvsp[0]));\n\t  }\n#line 3806 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 162:\n#line 1710 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\tif ((yyvsp[0])->opcode == Op_match_rec) {\n\t\t\t(yyvsp[0])->opcode = Op_nomatch;\n\t\t\t(yyvsp[-1])->opcode = Op_push_i;\n\t\t\t(yyvsp[-1])->memory = set_profile_text(make_number(0.0), \"0\", 1);\n\t\t\t(yyval) = list_append(list_append(list_create((yyvsp[-1])),\n\t\t\t\t\t\tinstruction(Op_field_spec)), (yyvsp[0]));\n\t\t} else {\n\t\t\tif (do_optimize && (yyvsp[0])->nexti == (yyvsp[0])->lasti\n\t\t\t\t\t&& (yyvsp[0])->nexti->opcode == Op_push_i\n\t\t\t\t\t&& ((yyvsp[0])->nexti->memory->flags & (MPFN|MPZN|INTLSTR)) == 0\n\t\t\t) {\n\t\t\t\tNODE *n = (yyvsp[0])->nexti->memory;\n\t\t\t\tif ((n->flags & STRING) != 0) {\n\t\t\t\t\tn->numbr = (AWKNUM) (n->stlen == 0);\n\t\t\t\t\tn->flags &= ~(STRCUR|STRING);\n\t\t\t\t\tn->flags |= (NUMCUR|NUMBER);\n\t\t\t\t\tefree(n->stptr);\n\t\t\t\t\tn->stptr = NULL;\n\t\t\t\t\tn->stlen = 0;\n\t\t\t\t} else\n\t\t\t\t\tn->numbr = (AWKNUM) (n->numbr == 0.0);\n\t\t\t\tbcfree((yyvsp[-1]));\n\t\t\t\t(yyval) = (yyvsp[0]);\n\t\t\t} else {\n\t\t\t\t(yyvsp[-1])->opcode = Op_not;\n\t\t\t\tadd_lint((yyvsp[0]), LINT_assign_in_cond);\n\t\t\t\t(yyval) = list_append((yyvsp[0]), (yyvsp[-1]));\n\t\t\t}\n\t\t}\n\t   }\n#line 3842 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 163:\n#line 1742 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\tif (do_pretty_print)\n\t\t\t(yyval) = list_append((yyvsp[-1]), bcalloc(Op_parens, 1, sourceline));\n\t\telse\n\t\t\t(yyval) = (yyvsp[-1]);\n\t  }\n#line 3853 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 164:\n#line 1749 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\t(yyval) = snode((yyvsp[-1]), (yyvsp[-3]));\n\t\tif ((yyval) == NULL)\n\t\t\tYYABORT;\n\t  }\n#line 3863 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 165:\n#line 1755 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\t(yyval) = snode((yyvsp[-1]), (yyvsp[-3]));\n\t\tif ((yyval) == NULL)\n\t\t\tYYABORT;\n\t  }\n#line 3873 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 166:\n#line 1761 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\tstatic bool warned = false;\n\n\t\tif (do_lint && ! warned) {\n\t\t\twarned = true;\n\t\t\tlintwarn_ln((yyvsp[0])->source_line,\n\t\t\t\t_(\"call of `length' without parentheses is not portable\"));\n\t\t}\n\t\t(yyval) = snode(NULL, (yyvsp[0]));\n\t\tif ((yyval) == NULL)\n\t\t\tYYABORT;\n\t  }\n#line 3890 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 169:\n#line 1776 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\t(yyvsp[-1])->opcode = Op_preincrement;\n\t\t(yyval) = mk_assignment((yyvsp[0]), NULL, (yyvsp[-1]));\n\t  }\n#line 3899 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 170:\n#line 1781 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\t(yyvsp[-1])->opcode = Op_predecrement;\n\t\t(yyval) = mk_assignment((yyvsp[0]), NULL, (yyvsp[-1]));\n\t  }\n#line 3908 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 171:\n#line 1786 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\t(yyval) = list_create((yyvsp[0]));\n\t  }\n#line 3916 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 172:\n#line 1790 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\t(yyval) = list_create((yyvsp[0]));\n\t  }\n#line 3924 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 173:\n#line 1794 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\tif ((yyvsp[0])->lasti->opcode == Op_push_i\n\t\t\t&& ((yyvsp[0])->lasti->memory->flags & STRING) == 0\n\t\t) {\n\t\t\tNODE *n = (yyvsp[0])->lasti->memory;\n\t\t\t(void) force_number(n);\n\t\t\tnegate_num(n);\n\t\t\t(yyval) = (yyvsp[0]);\n\t\t\tbcfree((yyvsp[-1]));\n\t\t} else {\n\t\t\t(yyvsp[-1])->opcode = Op_unary_minus;\n\t\t\t(yyval) = list_append((yyvsp[0]), (yyvsp[-1]));\n\t\t}\n\t  }\n#line 3943 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 174:\n#line 1809 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\tif ((yyvsp[0])->lasti->opcode == Op_push_i\n\t\t\t&& ((yyvsp[0])->lasti->memory->flags & STRING) == 0\n\t\t\t&& ((yyvsp[0])->lasti->memory->flags & NUMCONSTSTR) != 0) {\n\t\t\tNODE *n = (yyvsp[0])->lasti->memory;\n\t\t\tadd_sign_to_num(n, '+');\n\t\t\t(yyval) = (yyvsp[0]);\n\t\t\tbcfree((yyvsp[-1]));\n\t\t} else {\n\t\t\t/*\n\t\t\t * was: $$ = $2\n\t\t\t * POSIX semantics: force a conversion to numeric type\n\t\t\t */\n\t\t\t(yyvsp[-1])->opcode = Op_unary_plus;\n\t\t\t(yyval) = list_append((yyvsp[0]), (yyvsp[-1]));\n\t\t}\n\t  }\n#line 3965 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 175:\n#line 1830 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\tfunc_use((yyvsp[0])->lasti->func_name, FUNC_USE);\n\t\t(yyval) = (yyvsp[0]);\n\t  }\n#line 3974 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 176:\n#line 1835 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\t/* indirect function call */\n\t\tINSTRUCTION *f, *t;\n\t\tchar *name;\n\t\tNODE *indirect_var;\n\t\tstatic bool warned = false;\n\t\tconst char *msg = _(\"indirect function calls are a gawk extension\");\n\n\t\tif (do_traditional || do_posix)\n\t\t\tyyerror(\"%s\", msg);\n\t\telse if (do_lint && ! warned) {\n\t\t\twarned = true;\n\t\t\tlintwarn(\"%s\", msg);\n\t\t}\n\n\t\tf = (yyvsp[0])->lasti;\n\t\tf->opcode = Op_indirect_func_call;\n\t\tname = estrdup(f->func_name, strlen(f->func_name));\n\t\tif (is_std_var(name))\n\t\t\tyyerror(_(\"can not use special variable `%s' for indirect function call\"), name);\n\t\tindirect_var = variable(f->source_line, name, Node_var_new);\n\t\tt = instruction(Op_push);\n\t\tt->memory = indirect_var;\n\n\t\t/* prepend indirect var instead of appending to arguments (opt_expression_list),\n\t\t * and pop it off in setup_frame (eval.c) (left to right evaluation order); Test case:\n\t\t *\t\tf = \"fun\"\n\t\t *\t\t@f(f=\"real_fun\")\n\t\t */\n\n\t\t(yyval) = list_prepend((yyvsp[0]), t);\n\t\tat_seen = false;\n\t  }\n#line 4012 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 177:\n#line 1872 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\tNODE *n;\n\n\t\tif (! at_seen) {\n\t\t\tn = lookup((yyvsp[-3])->func_name);\n\t\t\tif (n != NULL && n->type != Node_func\n\t\t\t    && n->type != Node_ext_func) {\n\t\t\t\terror_ln((yyvsp[-3])->source_line,\n\t\t\t\t\t_(\"attempt to use non-function `%s' in function call\"),\n\t\t\t\t\t\t(yyvsp[-3])->func_name);\n\t\t\t}\n\t\t}\n\t\tparam_sanity((yyvsp[-1]));\n\t\t(yyvsp[-3])->opcode = Op_func_call;\n\t\t(yyvsp[-3])->func_body = NULL;\n\t\tif ((yyvsp[-1]) == NULL) {\t/* no argument or error */\n\t\t\t((yyvsp[-3]) + 1)->expr_count = 0;\n\t\t\t(yyval) = list_create((yyvsp[-3]));\n\t\t} else {\n\t\t\tINSTRUCTION *t = (yyvsp[-1]);\n\t\t\t((yyvsp[-3]) + 1)->expr_count = count_expressions(&t, true);\n\t\t\t(yyval) = list_append(t, (yyvsp[-3]));\n\t\t}\n\t  }\n#line 4041 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 178:\n#line 1900 \"awkgram.y\" /* yacc.c:1646  */\n    { (yyval) = NULL; }\n#line 4047 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 179:\n#line 1902 \"awkgram.y\" /* yacc.c:1646  */\n    { (yyval) = (yyvsp[0]); }\n#line 4053 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 180:\n#line 1907 \"awkgram.y\" /* yacc.c:1646  */\n    { (yyval) = NULL; }\n#line 4059 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 181:\n#line 1909 \"awkgram.y\" /* yacc.c:1646  */\n    { (yyval) = (yyvsp[-1]); }\n#line 4065 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 182:\n#line 1914 \"awkgram.y\" /* yacc.c:1646  */\n    {\t(yyval) = (yyvsp[0]); }\n#line 4071 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 183:\n#line 1916 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\t(yyval) = list_merge((yyvsp[-1]), (yyvsp[0]));\n\t  }\n#line 4079 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 184:\n#line 1923 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\tINSTRUCTION *ip = (yyvsp[0])->lasti;\n\t\tint count = ip->sub_count;\t/* # of SUBSEP-seperated expressions */\n\t\tif (count > 1) {\n\t\t\t/* change Op_subscript or Op_sub_array to Op_concat */\n\t\t\tip->opcode = Op_concat;\n\t\t\tip->concat_flag = CSUBSEP;\n\t\t\tip->expr_count = count;\n\t\t} else\n\t\t\tip->opcode = Op_no_op;\n\t\tsub_counter++;\t/* count # of dimensions */\n\t\t(yyval) = (yyvsp[0]);\n\t  }\n#line 4097 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 185:\n#line 1940 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\tINSTRUCTION *t = (yyvsp[-1]);\n\t\tif ((yyvsp[-1]) == NULL) {\n\t\t\terror_ln((yyvsp[0])->source_line,\n\t\t\t\t_(\"invalid subscript expression\"));\n\t\t\t/* install Null string as subscript. */\n\t\t\tt = list_create(instruction(Op_push_i));\n\t\t\tt->nexti->memory = dupnode(Nnull_string);\n\t\t\t(yyvsp[0])->sub_count = 1;\n\t\t} else\n\t\t\t(yyvsp[0])->sub_count = count_expressions(&t, false);\n\t\t(yyval) = list_append(t, (yyvsp[0]));\n\t  }\n#line 4115 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 186:\n#line 1957 \"awkgram.y\" /* yacc.c:1646  */\n    {\t(yyval) = (yyvsp[0]); }\n#line 4121 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 187:\n#line 1959 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\t(yyval) = list_merge((yyvsp[-1]), (yyvsp[0]));\n\t  }\n#line 4129 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 188:\n#line 1966 \"awkgram.y\" /* yacc.c:1646  */\n    { (yyval) = (yyvsp[-1]); }\n#line 4135 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 189:\n#line 1971 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\tchar *var_name = (yyvsp[0])->lextok;\n\n\t\t(yyvsp[0])->opcode = Op_push;\n\t\t(yyvsp[0])->memory = variable((yyvsp[0])->source_line, var_name, Node_var_new);\n\t\t(yyval) = list_create((yyvsp[0]));\n\t  }\n#line 4147 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 190:\n#line 1979 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\tchar *arr = (yyvsp[-1])->lextok;\n\t\t(yyvsp[-1])->memory = variable((yyvsp[-1])->source_line, arr, Node_var_new);\n\t\t(yyvsp[-1])->opcode = Op_push_array;\n\t\t(yyval) = list_prepend((yyvsp[0]), (yyvsp[-1]));\n\t  }\n#line 4158 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 191:\n#line 1989 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\tINSTRUCTION *ip = (yyvsp[0])->nexti;\n\t\tif (ip->opcode == Op_push\n\t\t\t&& ip->memory->type == Node_var\n\t\t\t&& ip->memory->var_update\n\t\t) {\n\t\t\t(yyval) = list_prepend((yyvsp[0]), instruction(Op_var_update));\n\t\t\t(yyval)->nexti->update_var = ip->memory->var_update;\n\t\t} else\n\t\t\t(yyval) = (yyvsp[0]);\n\t  }\n#line 4174 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 192:\n#line 2001 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\t(yyval) = list_append((yyvsp[-1]), (yyvsp[-2]));\n\t\tif ((yyvsp[0]) != NULL)\n\t\t\tmk_assignment((yyvsp[-1]), NULL, (yyvsp[0]));\n\t  }\n#line 4184 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 193:\n#line 2010 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\t(yyvsp[0])->opcode = Op_postincrement;\n\t  }\n#line 4192 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 194:\n#line 2014 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\t(yyvsp[0])->opcode = Op_postdecrement;\n\t  }\n#line 4200 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 195:\n#line 2017 \"awkgram.y\" /* yacc.c:1646  */\n    { (yyval) = NULL; }\n#line 4206 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 197:\n#line 2025 \"awkgram.y\" /* yacc.c:1646  */\n    { yyerrok; }\n#line 4212 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 198:\n#line 2029 \"awkgram.y\" /* yacc.c:1646  */\n    { yyerrok; }\n#line 4218 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 201:\n#line 2038 \"awkgram.y\" /* yacc.c:1646  */\n    { yyerrok; }\n#line 4224 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 202:\n#line 2042 \"awkgram.y\" /* yacc.c:1646  */\n    { (yyval) = (yyvsp[0]); yyerrok; }\n#line 4230 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 203:\n#line 2046 \"awkgram.y\" /* yacc.c:1646  */\n    { yyerrok; }\n#line 4236 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n\n#line 4240 \"awkgram.c\" /* yacc.c:1646  */\n      default: break;\n    }\n  /* User semantic actions sometimes alter yychar, and that requires\n     that yytoken be updated with the new translation.  We take the\n     approach of translating immediately before every use of yytoken.\n     One alternative is translating here after every semantic action,\n     but that translation would be missed if the semantic action invokes\n     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or\n     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an\n     incorrect destructor might then be invoked immediately.  In the\n     case of YYERROR or YYBACKUP, subsequent parser actions might lead\n     to an incorrect destructor call or verbose syntax error message\n     before the lookahead is translated.  */\n  YY_SYMBOL_PRINT (\"-> $$ =\", yyr1[yyn], &yyval, &yyloc);\n\n  YYPOPSTACK (yylen);\n  yylen = 0;\n  YY_STACK_PRINT (yyss, yyssp);\n\n  *++yyvsp = yyval;\n\n  /* Now 'shift' the result of the reduction.  Determine what state\n     that goes to, based on the state we popped back to and the rule\n     number reduced by.  */\n\n  yyn = yyr1[yyn];\n\n  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;\n  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)\n    yystate = yytable[yystate];\n  else\n    yystate = yydefgoto[yyn - YYNTOKENS];\n\n  goto yynewstate;\n\n\n/*--------------------------------------.\n| yyerrlab -- here on detecting error.  |\n`--------------------------------------*/\nyyerrlab:\n  /* Make sure we have latest lookahead translation.  See comments at\n     user semantic actions for why this is necessary.  */\n  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);\n\n  /* If not already recovering from an error, report this error.  */\n  if (!yyerrstatus)\n    {\n      ++yynerrs;\n#if ! YYERROR_VERBOSE\n      yyerror (YY_(\"syntax error\"));\n#else\n# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \\\n                                        yyssp, yytoken)\n      {\n        char const *yymsgp = YY_(\"syntax error\");\n        int yysyntax_error_status;\n        yysyntax_error_status = YYSYNTAX_ERROR;\n        if (yysyntax_error_status == 0)\n          yymsgp = yymsg;\n        else if (yysyntax_error_status == 1)\n          {\n            if (yymsg != yymsgbuf)\n              YYSTACK_FREE (yymsg);\n            yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);\n            if (!yymsg)\n              {\n                yymsg = yymsgbuf;\n                yymsg_alloc = sizeof yymsgbuf;\n                yysyntax_error_status = 2;\n              }\n            else\n              {\n                yysyntax_error_status = YYSYNTAX_ERROR;\n                yymsgp = yymsg;\n              }\n          }\n        yyerror (yymsgp);\n        if (yysyntax_error_status == 2)\n          goto yyexhaustedlab;\n      }\n# undef YYSYNTAX_ERROR\n#endif\n    }\n\n\n\n  if (yyerrstatus == 3)\n    {\n      /* If just tried and failed to reuse lookahead token after an\n         error, discard it.  */\n\n      if (yychar <= YYEOF)\n        {\n          /* Return failure if at end of input.  */\n          if (yychar == YYEOF)\n            YYABORT;\n        }\n      else\n        {\n          yydestruct (\"Error: discarding\",\n                      yytoken, &yylval);\n          yychar = YYEMPTY;\n        }\n    }\n\n  /* Else will try to reuse lookahead token after shifting the error\n     token.  */\n  goto yyerrlab1;\n\n\n/*---------------------------------------------------.\n| yyerrorlab -- error raised explicitly by YYERROR.  |\n`---------------------------------------------------*/\nyyerrorlab:\n\n  /* Pacify compilers like GCC when the user code never invokes\n     YYERROR and the label yyerrorlab therefore never appears in user\n     code.  */\n  if (/*CONSTCOND*/ 0)\n     goto yyerrorlab;\n\n  /* Do not reclaim the symbols of the rule whose action triggered\n     this YYERROR.  */\n  YYPOPSTACK (yylen);\n  yylen = 0;\n  YY_STACK_PRINT (yyss, yyssp);\n  yystate = *yyssp;\n  goto yyerrlab1;\n\n\n/*-------------------------------------------------------------.\n| yyerrlab1 -- common code for both syntax error and YYERROR.  |\n`-------------------------------------------------------------*/\nyyerrlab1:\n  yyerrstatus = 3;      /* Each real token shifted decrements this.  */\n\n  for (;;)\n    {\n      yyn = yypact[yystate];\n      if (!yypact_value_is_default (yyn))\n        {\n          yyn += YYTERROR;\n          if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)\n            {\n              yyn = yytable[yyn];\n              if (0 < yyn)\n                break;\n            }\n        }\n\n      /* Pop the current state because it cannot handle the error token.  */\n      if (yyssp == yyss)\n        YYABORT;\n\n\n      yydestruct (\"Error: popping\",\n                  yystos[yystate], yyvsp);\n      YYPOPSTACK (1);\n      yystate = *yyssp;\n      YY_STACK_PRINT (yyss, yyssp);\n    }\n\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  *++yyvsp = yylval;\n  YY_IGNORE_MAYBE_UNINITIALIZED_END\n\n\n  /* Shift the error token.  */\n  YY_SYMBOL_PRINT (\"Shifting\", yystos[yyn], yyvsp, yylsp);\n\n  yystate = yyn;\n  goto yynewstate;\n\n\n/*-------------------------------------.\n| yyacceptlab -- YYACCEPT comes here.  |\n`-------------------------------------*/\nyyacceptlab:\n  yyresult = 0;\n  goto yyreturn;\n\n/*-----------------------------------.\n| yyabortlab -- YYABORT comes here.  |\n`-----------------------------------*/\nyyabortlab:\n  yyresult = 1;\n  goto yyreturn;\n\n#if !defined yyoverflow || YYERROR_VERBOSE\n/*-------------------------------------------------.\n| yyexhaustedlab -- memory exhaustion comes here.  |\n`-------------------------------------------------*/\nyyexhaustedlab:\n  yyerror (YY_(\"memory exhausted\"));\n  yyresult = 2;\n  /* Fall through.  */\n#endif\n\nyyreturn:\n  if (yychar != YYEMPTY)\n    {\n      /* Make sure we have latest lookahead translation.  See comments at\n         user semantic actions for why this is necessary.  */\n      yytoken = YYTRANSLATE (yychar);\n      yydestruct (\"Cleanup: discarding lookahead\",\n                  yytoken, &yylval);\n    }\n  /* Do not reclaim the symbols of the rule whose action triggered\n     this YYABORT or YYACCEPT.  */\n  YYPOPSTACK (yylen);\n  YY_STACK_PRINT (yyss, yyssp);\n  while (yyssp != yyss)\n    {\n      yydestruct (\"Cleanup: popping\",\n                  yystos[*yyssp], yyvsp);\n      YYPOPSTACK (1);\n    }\n#ifndef yyoverflow\n  if (yyss != yyssa)\n    YYSTACK_FREE (yyss);\n#endif\n#if YYERROR_VERBOSE\n  if (yymsg != yymsgbuf)\n    YYSTACK_FREE (yymsg);\n#endif\n  return yyresult;\n}",
      "lines": 2812,
      "depth": 22,
      "decorators": [
        "int"
      ]
    },
    "tokcompare": {
      "start_point": [
        4491,
        0
      ],
      "end_point": [
        4500,
        1
      ],
      "content": "static int\ntokcompare(const void *l, const void *r)\n{\n\tstruct token *lhs, *rhs;\n\n\tlhs = (struct token *) l;\n\trhs = (struct token *) r;\n\n\treturn strcmp(lhs->operator, rhs->operator);\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "getfname": {
      "start_point": [
        4610,
        0
      ],
      "end_point": [
        4622,
        1
      ],
      "content": "const char *\ngetfname(NODE *(*fptr)(int))\n{\n\tint i, j;\n\n\tj = sizeof(tokentab) / sizeof(tokentab[0]);\n\t/* linear search, no other way to do it */\n\tfor (i = 0; i < j; i++)\n\t\tif (tokentab[i].ptr == fptr || tokentab[i].ptr2 == fptr)\n\t\t\treturn tokentab[i].operator;\n\n\treturn NULL;\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "const",
        "const",
        "char",
        "*\ngetfname(NODE *(*fptr)(int))",
        "*"
      ]
    },
    "negate_num": {
      "start_point": [
        4626,
        0
      ],
      "end_point": [
        4665,
        1
      ],
      "content": "void\nnegate_num(NODE *n)\n{\n#ifdef HAVE_MPFR\n\tint tval = 0;\n#endif\n\n\tadd_sign_to_num(n, '-');\n\n\tif (! is_mpg_number(n)) {\n\t\tn->numbr = -n->numbr;\n\t\treturn;\n\t}\n\n#ifdef HAVE_MPFR\n\tif (is_mpg_integer(n)) {\n\t\tif (! iszero(n)) {\n\t\t\tmpz_neg(n->mpg_i, n->mpg_i);\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * 0 --> -0 conversion. Requires turning the MPG integer\n\t\t * into an MPFR float.\n\t\t */\n\n\t\tmpz_clear(n->mpg_i);\t/* release the integer storage */\n\n\t\t/* Convert and fall through. */\n\t\ttval = mpfr_set_d(n->mpg_numbr, 0.0, ROUND_MODE);\n\t\tIEEE_FMT(n->mpg_numbr, tval);\n\t\tn->flags &= ~MPZN;\n\t\tn->flags |= MPFN;\n\t}\n\n\t/* mpfr float case */\n\ttval = mpfr_neg(n->mpg_numbr, n->mpg_numbr, ROUND_MODE);\n\tIEEE_FMT(n->mpg_numbr, tval);\n#endif\n}",
      "lines": 40,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "add_sign_to_num": {
      "start_point": [
        4669,
        0
      ],
      "end_point": [
        4680,
        1
      ],
      "content": "static void\nadd_sign_to_num(NODE *n, char sign)\n{\n\tif ((n->flags & NUMCONSTSTR) != 0) {\n\t\tchar *s;\n\n\t\ts = n->stptr;\n\t\tmemmove(& s[1], & s[0], n->stlen + 1);\n\t\ts[0] = sign;\n\t\tn->stlen++;\n\t}\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "print_included_from": {
      "start_point": [
        4684,
        0
      ],
      "end_point": [
        4713,
        1
      ],
      "content": "static void\nprint_included_from()\n{\n\tint saveline, line;\n\tSRCFILE *s;\n\n\t/* suppress current file name, line # from `.. included from ..' msgs */\n\tsaveline = sourceline;\n\tsourceline = 0;\n\n\tfor (s = sourcefile; s != NULL && s->stype == SRC_INC; ) {\n\t\ts = s->next;\n\t\tif (s == NULL || s->fd <= INVALID_HANDLE)\n\t\t\tcontinue;\n\t\tline = s->srclines;\n\n\t\t/* if last token is NEWLINE, line number is off by 1. */\n\t\tif (s->lasttok == NEWLINE)\n\t\t\tline--;\n\t\tmsg(\"%s %s:%d%c\",\n\t\t\ts->prev == sourcefile ? \"In file included from\"\n\t\t\t\t\t  : \"                 from\",\n\t\t\t(s->stype == SRC_INC ||\n\t\t\t\t s->stype == SRC_FILE) ? s->src : \"cmd. line\",\n\t\t\tline,\n\t\t\ts->stype == SRC_INC ? ',' : ':'\n\t\t);\n\t}\n\tsourceline = saveline;\n}",
      "lines": 30,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "warning_ln": {
      "start_point": [
        4717,
        0
      ],
      "end_point": [
        4730,
        1
      ],
      "content": "static void\nwarning_ln(int line, const char *mesg, ...)\n{\n\tva_list args;\n\tint saveline;\n\n\tsaveline = sourceline;\n\tsourceline = line;\n\tprint_included_from();\n\tva_start(args, mesg);\n\terr(false, _(\"warning: \"), mesg, args);\n\tva_end(args);\n\tsourceline = saveline;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "lintwarn_ln": {
      "start_point": [
        4734,
        0
      ],
      "end_point": [
        4752,
        1
      ],
      "content": "static void\nlintwarn_ln(int line, const char *mesg, ...)\n{\n\tva_list args;\n\tint saveline;\n\n\tsaveline = sourceline;\n\tsourceline = line;\n\tprint_included_from();\n\tva_start(args, mesg);\n\tif (lintfunc == r_fatal)\n\t\terr(true, _(\"fatal: \"), mesg, args);\n\telse\n\t\terr(false, _(\"warning: \"), mesg, args);\n\tva_end(args);\n\tsourceline = saveline;\n\tif (lintfunc == r_fatal)\n\t\tgawk_exit(EXIT_FATAL);\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "error_ln": {
      "start_point": [
        4756,
        0
      ],
      "end_point": [
        4770,
        1
      ],
      "content": "static void\nerror_ln(int line, const char *m, ...)\n{\n\tva_list args;\n\tint saveline;\n\n\tsaveline = sourceline;\n\tsourceline = line;\n\tprint_included_from();\n\terrcount++;\n\tva_start(args, m);\n\terr(false, \"error: \", m, args);\n\tva_end(args);\n\tsourceline = saveline;\n}",
      "lines": 15,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yyerror": {
      "start_point": [
        4774,
        0
      ],
      "end_point": [
        4841,
        1
      ],
      "content": "static void\nyyerror(const char *m, ...)\n{\n\tva_list args;\n\tconst char *mesg = NULL;\n\tchar *bp, *cp;\n\tchar *scan;\n\tchar *buf;\n\tint count;\n\tstatic char end_of_file_line[] = \"(END OF FILE)\";\n\n\tprint_included_from();\n\n\terrcount++;\n\t/* Find the current line in the input file */\n\tif (lexptr && lexeme) {\n\t\tif (thisline == NULL) {\n\t\t\tcp = lexeme;\n\t\t\tif (*cp == '\\n') {\n\t\t\t\tif (cp > lexptr_begin)\n\t\t\t\t\tcp--;\n\t\t\t\tmesg = _(\"unexpected newline or end of string\");\n\t\t\t}\n\t\t\tfor (; cp != lexptr_begin && *cp != '\\n'; --cp)\n\t\t\t\tcontinue;\n\t\t\tif (*cp == '\\n')\n\t\t\t\tcp++;\n\t\t\tthisline = cp;\n\t\t}\n\t\t/* NL isn't guaranteed */\n\t\tbp = lexeme;\n\t\tif (bp < thisline)\n\t\t\tbp = thisline + 1;\n\t\twhile (bp < lexend && *bp && *bp != '\\n')\n\t\t\tbp++;\n\t} else {\n\t\tthisline = end_of_file_line;\n\t\tbp = thisline + strlen(thisline);\n\t}\n\n\tmsg(\"%.*s\", (int) (bp - thisline), thisline);\n\n\tva_start(args, m);\n\tif (mesg == NULL)\n\t\tmesg = m;\n\n\tcount = strlen(mesg) + 1;\n\tif (lexptr != NULL)\n\t\tcount += (lexeme - thisline) + 2;\n\tezalloc(buf, char *, count+1, \"yyerror\");\n\n\tbp = buf;\n\n\tif (lexptr != NULL) {\n\t\tscan = thisline;\n\t\twhile (scan < lexeme)\n\t\t\tif (*scan++ == '\\t')\n\t\t\t\t*bp++ = '\\t';\n\t\t\telse\n\t\t\t\t*bp++ = ' ';\n\t\t*bp++ = '^';\n\t\t*bp++ = ' ';\n\t}\n\tstrcpy(bp, mesg);\n\terr(false, \"\", buf, args);\n\tva_end(args);\n\tefree(buf);\n}",
      "lines": 68,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mk_program": {
      "start_point": [
        4845,
        0
      ],
      "end_point": [
        4966,
        1
      ],
      "content": "static INSTRUCTION *\nmk_program()\n{\n\tINSTRUCTION *cp, *tmp;\n\n#define begin_block         rule_block[BEGIN]\n#define end_block           rule_block[END]\n#define prog_block          rule_block[Rule]\n#define beginfile_block     rule_block[BEGINFILE]\n#define endfile_block       rule_block[ENDFILE]\n\n\tif (end_block == NULL)\n\t\tend_block = list_create(ip_end);\n\telse\n\t\t(void) list_prepend(end_block, ip_end);\n\n\tif (! in_main_context()) {\n\t\tif (begin_block != NULL && prog_block != NULL)\n\t\t\tcp = list_merge(begin_block, prog_block);\n\t\telse\n\t\t\tcp = (begin_block != NULL) ? begin_block : prog_block;\n\n\t\tif (cp != NULL)\n\t\t\t(void) list_merge(cp, end_block);\n\t\telse\n\t\t\tcp = end_block;\n\n\t\t(void) list_append(cp, instruction(Op_stop));\n\t\tgoto out;\n\t}\n\n\tif (endfile_block == NULL)\n\t\tendfile_block = list_create(ip_endfile);\n\telse {\n\t\tip_rec->has_endfile = true;\n\t\t(void) list_prepend(endfile_block, ip_endfile);\n\t}\n\n\tif (beginfile_block == NULL)\n\t\tbeginfile_block = list_create(ip_beginfile);\n\telse\n\t\t(void) list_prepend(beginfile_block, ip_beginfile);\n\n\tif (prog_block == NULL) {\n\t\tif (end_block->nexti == end_block->lasti\n\t\t\t\t&& beginfile_block->nexti == beginfile_block->lasti\n\t\t\t\t&& endfile_block->nexti == endfile_block->lasti\n\t\t) {\n\t\t\t/* no pattern-action and (real) end, beginfile or endfile blocks */\n\t\t\tbcfree(ip_rec);\n\t\t\tbcfree(ip_newfile);\n\t\t\tip_rec = ip_newfile = NULL;\n\n\t\t\tlist_append(beginfile_block, instruction(Op_after_beginfile));\n\t\t\t(void) list_append(endfile_block, instruction(Op_after_endfile));\n\n\t\t\tif (begin_block == NULL)     /* no program at all */\n\t\t\t\tcp = end_block;\n\t\t\telse\n\t\t\t\tcp = list_merge(begin_block, end_block);\n\t\t\tif (program_comment != NULL) {\n\t\t\t\t(void) list_prepend(cp, program_comment);\n\t\t\t}\n\t\t\tif (comment != NULL)\n\t\t\t\t(void) list_append(cp, comment);\n\t\t\t(void) list_append(cp, ip_atexit);\n\t\t\t(void) list_append(cp, instruction(Op_stop));\n\n\t\t\t/* append beginfile_block and endfile_block for sole use\n\t\t\t * in getline without redirection (Op_K_getline).\n\t\t\t */\n\n\t\t\t(void) list_merge(cp, beginfile_block);\n\t\t\t(void) list_merge(cp, endfile_block);\n\n\t\t\tgoto out;\n\n\t\t} else {\n\t\t\t/* install a do-nothing prog block */\n\t\t\tprog_block = list_create(instruction(Op_no_op));\n\t\t}\n\t}\n\n\t(void) list_append(endfile_block, instruction(Op_after_endfile));\n\t(void) list_prepend(prog_block, ip_rec);\n\t(void) list_append(prog_block, instruction(Op_jmp));\n\tprog_block->lasti->target_jmp = ip_rec;\n\n\tlist_append(beginfile_block, instruction(Op_after_beginfile));\n\n\tcp = list_merge(beginfile_block, prog_block);\n\t(void) list_prepend(cp, ip_newfile);\n\t(void) list_merge(cp, endfile_block);\n\t(void) list_merge(cp, end_block);\n\tif (begin_block != NULL)\n\t\tcp = list_merge(begin_block, cp);\n\n\tif (program_comment != NULL) {\n\t\t(void) list_prepend(cp, program_comment);\n\t}\n\tif (comment != NULL) {\n\t\t(void) list_append(cp, comment);\n\t}\n\t(void) list_append(cp, ip_atexit);\n\t(void) list_append(cp, instruction(Op_stop));\n\nout:\n\t/* delete the Op_list, not needed */\n\ttmp = cp->nexti;\n\tbcfree(cp);\n\t/* these variables are not used again but zap them anyway.  */\n\tcomment = NULL;\n\tfunction_comment = NULL;\n\tprogram_comment = NULL;\n\treturn tmp;\n\n#undef begin_block\n#undef end_block\n#undef prog_block\n#undef beginfile_block\n#undef endfile_block\n}",
      "lines": 122,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "INSTRUCTION",
        "*\nmk_program()",
        "*"
      ]
    },
    "parse_program": {
      "start_point": [
        4970,
        0
      ],
      "end_point": [
        5024,
        1
      ],
      "content": "int\nparse_program(INSTRUCTION **pcode)\n{\n\tint ret;\n\n\t/* pre-create non-local jump targets\n\t * ip_end (Op_no_op) -- used as jump target for `exit'\n\t * outside an END block.\n\t */\n\tip_end = instruction(Op_no_op);\n\n\tif (! in_main_context())\n\t\tip_newfile = ip_rec = ip_atexit = ip_beginfile = ip_endfile = NULL;\n\telse {\n\t\tip_endfile = instruction(Op_no_op);\n\t\tmain_beginfile = ip_beginfile = instruction(Op_no_op);\n\t\tip_rec = instruction(Op_get_record); /* target for `next', also ip_newfile */\n\t\tip_newfile = bcalloc(Op_newfile, 2, 0); /* target for `nextfile' */\n\t\tip_newfile->target_jmp = ip_end;\n\t\tip_newfile->target_endfile = ip_endfile;\n\t\t(ip_newfile + 1)->target_get_record = ip_rec;\n\t\tip_rec->target_newfile = ip_newfile;\n\t\tip_atexit = instruction(Op_atexit);\t/* target for `exit' in END block */\n\t}\n\n\tfor (sourcefile = srcfiles->next; sourcefile->stype == SRC_EXTLIB;\n\t\t\tsourcefile = sourcefile->next)\n\t\t;\n\n\tlexeof = false;\n\tlexptr = NULL;\n\tlasttok = 0;\n\tmemset(rule_block, 0, sizeof(ruletab) * sizeof(INSTRUCTION *));\n\terrcount = 0;\n\ttok = tokstart != NULL ? tokstart : tokexpand();\n\n\tret = yyparse();\n\t*pcode = mk_program();\n\n\t/* avoid false source indications */\n\tsource = NULL;\n\tsourceline = 0;\n\tif (ret == 0)\t/* avoid spurious warning if parser aborted with YYABORT */\n\t\tcheck_funcs();\n\n\tif (do_posix && ! check_param_names())\n\t\terrcount++;\n\n\tif (args_array == NULL)\n\t\temalloc(args_array, NODE **, (max_args + 2) * sizeof(NODE *), \"parse_program\");\n\telse\n\t\terealloc(args_array, NODE **, (max_args + 2) * sizeof(NODE *), \"parse_program\");\n\n\treturn (ret || errcount);\n}",
      "lines": 55,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "free_srcfile": {
      "start_point": [
        5028,
        0
      ],
      "end_point": [
        5033,
        1
      ],
      "content": "void\nfree_srcfile(SRCFILE *thisfile)\n{\n\tefree(thisfile->src);\n\tefree(thisfile);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "do_add_srcfile": {
      "start_point": [
        5037,
        0
      ],
      "end_point": [
        5052,
        1
      ],
      "content": "static SRCFILE *\ndo_add_srcfile(enum srctype stype, char *src, char *path, SRCFILE *thisfile)\n{\n\tSRCFILE *s;\n\n\tezalloc(s, SRCFILE *, sizeof(SRCFILE), \"do_add_srcfile\");\n\ts->src = estrdup(src, strlen(src));\n\ts->fullpath = path;\n\ts->stype = stype;\n\ts->fd = INVALID_HANDLE;\n\ts->next = thisfile;\n\ts->prev = thisfile->prev;\n\tthisfile->prev->next = s;\n\tthisfile->prev = s;\n\treturn s;\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "SRCFILE",
        "*\ndo_add_srcfile(enum srctype stype, char *src, char *path, SRCFILE *thisfile)",
        "*"
      ]
    },
    "add_srcfile": {
      "start_point": [
        5058,
        0
      ],
      "end_point": [
        5129,
        1
      ],
      "content": "SRCFILE *\nadd_srcfile(enum srctype stype, char *src, SRCFILE *thisfile, bool *already_included, int *errcode)\n{\n\tSRCFILE *s;\n\tstruct stat sbuf;\n\tchar *path;\n\tint errno_val = 0;\n\n\tif (already_included)\n\t\t*already_included = false;\n\tif (errcode)\n\t\t*errcode = 0;\n\tif (stype == SRC_CMDLINE || stype == SRC_STDIN)\n\t\treturn do_add_srcfile(stype, src, NULL, thisfile);\n\n\tpath = find_source(src, & sbuf, & errno_val, stype == SRC_EXTLIB);\n\tif (path == NULL) {\n\t\tif (errcode) {\n\t\t\t*errcode = errno_val;\n\t\t\treturn NULL;\n\t\t}\n\t\t/* use full messages to ease translation */\n\t\tfatal(stype != SRC_EXTLIB\n\t\t\t? _(\"can't open source file `%s' for reading (%s)\")\n\t\t\t: _(\"can't open shared library `%s' for reading (%s)\"),\n\t\t\t\tsrc,\n\t\t\t\terrno_val ? strerror(errno_val) : _(\"reason unknown\"));\n\t}\n\n\t/* N.B. We do not eliminate duplicate SRC_FILE (-f) programs. */\n\tfor (s = srcfiles->next; s != srcfiles; s = s->next) {\n\t\tif ((s->stype == SRC_FILE || s->stype == SRC_INC || s->stype == SRC_EXTLIB) && files_are_same(path, s)) {\n\t\t\tif (stype == SRC_INC || stype == SRC_EXTLIB) {\n\t\t\t\t/* eliminate duplicates */\n\t\t\t\tif ((stype == SRC_INC) && (s->stype == SRC_FILE))\n\t\t\t\t\tfatal(_(\"can't include `%s' and use it as a program file\"), src);\n\n\t\t\t\tif (do_lint) {\n\t\t\t\t\tint line = sourceline;\n\t\t\t\t\t/* Kludge: the line number may be off for `@include file'.\n\t\t\t\t\t * Since, this function is also used for '-f file' in main.c,\n\t\t\t\t\t * sourceline > 1 check ensures that the call is at\n\t\t\t\t\t * parse time.\n\t\t\t\t\t */\n\t\t\t\t\tif (sourceline > 1 && lasttok == NEWLINE)\n\t\t\t\t\t\tline--;\n\t\t\t\t\tlintwarn_ln(line,\n\t\t\t\t\t\t    stype != SRC_EXTLIB\n\t\t\t\t\t\t      ? _(\"already included source file `%s'\")\n\t\t\t\t\t\t      : _(\"already loaded shared library `%s'\"),\n\t\t\t\t\t\t    src);\n\t\t\t\t}\n\t\t\t\tefree(path);\n\t\t\t\tif (already_included)\n\t\t\t\t\t*already_included = true;\n\t\t\t\treturn NULL;\n\t\t\t} else {\n\t\t\t\t/* duplicates are allowed for -f */\n\t\t\t\tif (s->stype == SRC_INC)\n\t\t\t\t\tfatal(_(\"can't include `%s' and use it as a program file\"), src);\n\t\t\t\t/* no need to scan for further matches, since\n\t\t\t\t * they must be of homogeneous type */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\ts = do_add_srcfile(stype, src, path, thisfile);\n\ts->sbuf = sbuf;\n\ts->mtime = sbuf.st_mtime;\n\treturn s;\n}",
      "lines": 72,
      "depth": 18,
      "decorators": [
        "SRCFILE",
        "*\nadd_srcfile(enum srctype stype, char *src, SRCFILE *thisfile, bool *already_included, int *errcode)",
        "*"
      ]
    },
    "include_source": {
      "start_point": [
        5133,
        0
      ],
      "end_point": [
        5179,
        1
      ],
      "content": "static int\ninclude_source(INSTRUCTION *file)\n{\n\tSRCFILE *s;\n\tchar *src = file->lextok;\n\tint errcode;\n\tbool already_included;\n\n\tif (do_traditional || do_posix) {\n\t\terror_ln(file->source_line, _(\"@include is a gawk extension\"));\n\t\treturn -1;\n\t}\n\n\tif (strlen(src) == 0) {\n\t\tif (do_lint)\n\t\t\tlintwarn_ln(file->source_line, _(\"empty filename after @include\"));\n\t\treturn 0;\n\t}\n\n\ts = add_srcfile(SRC_INC, src, sourcefile, &already_included, &errcode);\n\tif (s == NULL) {\n\t\tif (already_included)\n\t\t\treturn 0;\n\t\terror_ln(file->source_line,\n\t\t\t_(\"can't open source file `%s' for reading (%s)\"),\n\t\t\tsrc, errcode ? strerror(errcode) : _(\"reason unknown\"));\n\t\treturn -1;\n\t}\n\n\t/* save scanner state for the current sourcefile */\n\tsourcefile->srclines = sourceline;\n\tsourcefile->lexptr = lexptr;\n\tsourcefile->lexend = lexend;\n\tsourcefile->lexptr_begin = lexptr_begin;\n\tsourcefile->lexeme = lexeme;\n\tsourcefile->lasttok = lasttok;\n\n\t/* included file becomes the current source */\n\tsourcefile = s;\n\tlexptr = NULL;\n\tsourceline = 0;\n\tsource = NULL;\n\tlasttok = 0;\n\tlexeof = false;\n\teof_warned = false;\n\treturn 0;\n}",
      "lines": 47,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "load_library": {
      "start_point": [
        5183,
        0
      ],
      "end_point": [
        5214,
        1
      ],
      "content": "static int\nload_library(INSTRUCTION *file)\n{\n\tSRCFILE *s;\n\tchar *src = file->lextok;\n\tint errcode;\n\tbool already_included;\n\n\tif (do_traditional || do_posix) {\n\t\terror_ln(file->source_line, _(\"@load is a gawk extension\"));\n\t\treturn -1;\n\t}\n\n\tif (strlen(src) == 0) {\n\t\tif (do_lint)\n\t\t\tlintwarn_ln(file->source_line, _(\"empty filename after @load\"));\n\t\treturn 0;\n\t}\n\n\ts = add_srcfile(SRC_EXTLIB, src, sourcefile, &already_included, &errcode);\n\tif (s == NULL) {\n\t\tif (already_included)\n\t\t\treturn 0;\n\t\terror_ln(file->source_line,\n\t\t\t_(\"can't open shared library `%s' for reading (%s)\"),\n\t\t\tsrc, errcode ? strerror(errcode) : _(\"reason unknown\"));\n\t\treturn -1;\n\t}\n\n\tload_ext(s->fullpath);\n\treturn 0;\n}",
      "lines": 32,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "next_sourcefile": {
      "start_point": [
        5218,
        0
      ],
      "end_point": [
        5278,
        1
      ],
      "content": "static void\nnext_sourcefile()\n{\n\tstatic int (*closefunc)(int fd) = NULL;\n\n\tif (closefunc == NULL) {\n\t\tchar *cp = getenv(\"AWKREADFUNC\");\n\n\t\t/* If necessary, one day, test value for different functions.  */\n\t\tif (cp == NULL)\n\t\t\tclosefunc = close;\n\t\telse\n\t\t\tclosefunc = one_line_close;\n\t}\n\n\t/*\n\t * This won't be true if there's an invalid character in\n\t * the source file or source string (e.g., user typo).\n\t * Previous versions of gawk did not core dump in such a\n\t * case.\n\t *\n\t * assert(lexeof == true);\n\t */\n\n\tlexeof = false;\n\teof_warned = false;\n\tsourcefile->srclines = sourceline;\t/* total no of lines in current file */\n\tif (sourcefile->fd > INVALID_HANDLE) {\n\t\tif (sourcefile->fd != fileno(stdin))  /* safety */\n\t\t\t(*closefunc)(sourcefile->fd);\n\t\tsourcefile->fd = INVALID_HANDLE;\n\t}\n\tif (sourcefile->buf != NULL) {\n\t\tefree(sourcefile->buf);\n\t\tsourcefile->buf = NULL;\n\t\tsourcefile->lexptr_begin = NULL;\n\t}\n\n\twhile ((sourcefile = sourcefile->next) != NULL) {\n\t\tif (sourcefile == srcfiles)\n\t\t\treturn;\n\t\tif (sourcefile->stype != SRC_EXTLIB)\n\t\t\tbreak;\n\t}\n\n\tif (sourcefile->lexptr_begin != NULL) {\n\t\t/* resume reading from already opened file (postponed to process '@include') */\n\t\tlexptr = sourcefile->lexptr;\n\t\tlexend = sourcefile->lexend;\n\t\tlasttok = sourcefile->lasttok;\n\t\tlexptr_begin = sourcefile->lexptr_begin;\n\t\tlexeme = sourcefile->lexeme;\n\t\tsourceline = sourcefile->srclines;\n\t\tsource = sourcefile->src;\n\t} else {\n\t\tlexptr = NULL;\n\t\tsourceline = 0;\n\t\tsource = NULL;\n\t\tlasttok = 0;\n\t}\n}",
      "lines": 61,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "get_src_buf": {
      "start_point": [
        5282,
        0
      ],
      "end_point": [
        5464,
        1
      ],
      "content": "static char *\nget_src_buf()\n{\n\tint n;\n\tchar *scan;\n\tbool newfile;\n\tint savelen;\n\tstruct stat sbuf;\n\n\t/*\n\t * No argument prototype on readfunc on purpose,\n\t * avoids problems with some ancient systems where\n\t * the types of arguments to read() aren't up to date.\n\t */\n\tstatic ssize_t (*readfunc)() = 0;\n\n\tif (readfunc == NULL) {\n\t\tchar *cp = getenv(\"AWKREADFUNC\");\n\n\t\t/* If necessary, one day, test value for different functions.  */\n\t\tif (cp == NULL)\n\t\t\t/*\n\t\t\t * cast is to remove warnings on systems with\n\t\t\t * different return types for read.\n\t\t\t */\n\t\t\treadfunc = ( ssize_t(*)() ) read;\n\t\telse\n\t\t\treadfunc = read_one_line;\n\t}\n\n\tnewfile = false;\n\tif (sourcefile == srcfiles)\n\t\treturn NULL;\n\n\tif (sourcefile->stype == SRC_CMDLINE) {\n\t\tif (sourcefile->bufsize == 0) {\n\t\t\tsourcefile->bufsize = strlen(sourcefile->src);\n\t\t\tlexptr = lexptr_begin = lexeme = sourcefile->src;\n\t\t\tlexend = lexptr + sourcefile->bufsize;\n\t\t\tsourceline = 1;\n\t\t\tif (sourcefile->bufsize == 0) {\n\t\t\t\t/*\n\t\t\t\t * Yet Another Special case:\n\t\t\t\t *\tgawk '' /path/name\n\t\t\t\t * Sigh.\n\t\t\t\t */\n\t\t\t\tstatic bool warned = false;\n\n\t\t\t\tif (do_lint && ! warned) {\n\t\t\t\t\twarned = true;\n\t\t\t\t\tlintwarn(_(\"empty program text on command line\"));\n\t\t\t\t}\n\t\t\t\tlexeof = true;\n\t\t\t}\n\t\t} else if (sourcefile->buf == NULL  && *(lexptr-1) != '\\n') {\n\t\t\t/*\n\t\t\t * The following goop is to ensure that the source\n\t\t\t * ends with a newline and that the entire current\n\t\t\t * line is available for error messages.\n\t\t\t */\n\t\t\tint offset;\n\t\t\tchar *buf;\n\n\t\t\toffset = lexptr - lexeme;\n\t\t\tfor (scan = lexeme; scan > lexptr_begin; scan--)\n\t\t\t\tif (*scan == '\\n') {\n\t\t\t\t\tscan++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tsavelen = lexptr - scan;\n\t\t\temalloc(buf, char *, savelen + 1, \"get_src_buf\");\n\t\t\tmemcpy(buf, scan, savelen);\n\t\t\tthisline = buf;\n\t\t\tlexptr = buf + savelen;\n\t\t\t*lexptr = '\\n';\n\t\t\tlexeme = lexptr - offset;\n\t\t\tlexptr_begin = buf;\n\t\t\tlexend = lexptr + 1;\n\t\t\tsourcefile->buf = buf;\n\t\t} else\n\t\t\tlexeof = true;\n\t\treturn lexptr;\n\t}\n\n\tif (sourcefile->fd <= INVALID_HANDLE) {\n\t\tint fd;\n\t\tint l;\n\n\t\tsource = sourcefile->src;\n\t\tif (source == NULL)\n\t\t\treturn NULL;\n\t\tfd = srcopen(sourcefile);\n\t\tif (fd <= INVALID_HANDLE) {\n\t\t\tchar *in;\n\n\t\t\t/* suppress file name and line no. in error mesg */\n\t\t\tin = source;\n\t\t\tsource = NULL;\n\t\t\terror(_(\"can't open source file `%s' for reading (%s)\"),\n\t\t\t\tin, strerror(errno));\n\t\t\terrcount++;\n\t\t\tlexeof = true;\n\t\t\treturn sourcefile->src;\n\t\t}\n\n\t\tsourcefile->fd = fd;\n\t\tl = optimal_bufsize(fd, &sbuf);\n\t\t/*\n\t\t * Make sure that something silly like\n\t\t * \tAWKBUFSIZE=8 make check\n\t\t * works ok.\n\t\t */\n#define A_DECENT_BUFFER_SIZE\t128\n\t\tif (l < A_DECENT_BUFFER_SIZE)\n\t\t\tl = A_DECENT_BUFFER_SIZE;\n#undef A_DECENT_BUFFER_SIZE\n\t\tsourcefile->bufsize = l;\n\t\tnewfile = true;\n\t\temalloc(sourcefile->buf, char *, sourcefile->bufsize, \"get_src_buf\");\n\t\tlexptr = lexptr_begin = lexeme = sourcefile->buf;\n\t\tsavelen = 0;\n\t\tsourceline = 1;\n\t\tthisline = NULL;\n\t} else {\n\t\t/*\n\t\t * Here, we retain the current source line in the beginning of the buffer.\n\t\t */\n\t\tint offset;\n\t\tfor (scan = lexeme; scan > lexptr_begin; scan--)\n\t\t\tif (*scan == '\\n') {\n\t\t\t\tscan++;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tsavelen = lexptr - scan;\n\t\toffset = lexptr - lexeme;\n\n\t\tif (savelen > 0) {\n\t\t\t/*\n\t\t\t * Need to make sure we have room left for reading new text;\n\t\t\t * grow the buffer (by doubling, an arbitrary choice), if the retained line\n\t\t\t * takes up more than a certain percentage (50%, again an arbitrary figure)\n\t\t\t * of the available space.\n\t\t\t */\n\n\t\t\tif (savelen > sourcefile->bufsize / 2) { /* long line or token  */\n\t\t\t\tsourcefile->bufsize *= 2;\n\t\t\t\terealloc(sourcefile->buf, char *, sourcefile->bufsize, \"get_src_buf\");\n\t\t\t\tscan = sourcefile->buf + (scan - lexptr_begin);\n\t\t\t\tlexptr_begin = sourcefile->buf;\n\t\t\t}\n\n\t\t\tthisline = lexptr_begin;\n\t\t\tmemmove(thisline, scan, savelen);\n\t\t\tlexptr = thisline + savelen;\n\t\t\tlexeme = lexptr - offset;\n\t\t} else {\n\t\t\tsavelen = 0;\n\t\t\tlexptr = lexeme = lexptr_begin;\n\t\t\tthisline = NULL;\n\t\t}\n\t}\n\n\tn = (*readfunc)(sourcefile->fd, lexptr, sourcefile->bufsize - savelen);\n\tif (n == -1) {\n\t\terror(_(\"can't read sourcefile `%s' (%s)\"),\n\t\t\t\tsource, strerror(errno));\n\t\terrcount++;\n\t\tlexeof = true;\n\t} else {\n\t\tlexend = lexptr + n;\n\t\tif (n == 0) {\n\t\t\tstatic bool warned = false;\n\t\t\tif (do_lint && newfile && ! warned) {\n\t\t\t\twarned = true;\n\t\t\t\tsourceline = 0;\n\t\t\t\tlintwarn(_(\"source file `%s' is empty\"), source);\n\t\t\t}\n\t\t\tlexeof = true;\n\t\t}\n\t}\n\treturn sourcefile->buf;\n}",
      "lines": 183,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nget_src_buf()",
        "*"
      ]
    },
    "tokexpand": {
      "start_point": [
        5472,
        0
      ],
      "end_point": [
        5490,
        1
      ],
      "content": "static char *\ntokexpand()\n{\n\tstatic int toksize;\n\tint tokoffset;\n\n\tif (tokstart != NULL) {\n\t\ttokoffset = tok - tokstart;\n\t\ttoksize *= 2;\n\t\terealloc(tokstart, char *, toksize, \"tokexpand\");\n\t\ttok = tokstart + tokoffset;\n\t} else {\n\t\ttoksize = 60;\n\t\temalloc(tokstart, char *, toksize, \"tokexpand\");\n\t\ttok = tokstart;\n\t}\n\ttokend = tokstart + toksize;\n\treturn tok;\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "char",
        "*\ntokexpand()",
        "*"
      ]
    },
    "check_bad_char": {
      "start_point": [
        5500,
        0
      ],
      "end_point": [
        5518,
        1
      ],
      "content": "static void\ncheck_bad_char(int c)\n{\n\t/* allow escapes. needed for autoconf. bleah. */\n\tswitch (c) {\n\tcase '\\a':\n\tcase '\\b':\n\tcase '\\f':\n\tcase '\\n':\n\tcase '\\r':\n\tcase '\\t':\n\t\treturn;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (iscntrl(c) && ! isspace(c))\n\t\tfatal(_(\"PEBKAC error: invalid character '\\\\%03o' in source code\"), c & 0xFF);\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "nextc": {
      "start_point": [
        5522,
        0
      ],
      "end_point": [
        5608,
        1
      ],
      "content": "static int\nnextc(bool check_for_bad)\n{\n\tif (gawk_mb_cur_max > 1) {\nagain:\n#ifdef NO_CONTINUE_SOURCE_STRINGS\n\t\tif (lexeof)\n\t\t\treturn END_FILE;\n#else\n\t\tif (lexeof) {\n\t\t\tif (sourcefile->next == srcfiles)\n\t\t\t\treturn END_FILE;\n\t\t\telse\n\t\t\t\tnext_sourcefile();\n\t\t}\n#endif\n\t\tif (lexptr == NULL || lexptr >= lexend) {\n\t\t\tif (get_src_buf())\n\t\t\t\tgoto again;\n\t\t\treturn END_SRC;\n\t\t}\n\n\t\t/* Update the buffer index.  */\n\t\tcur_ring_idx = (cur_ring_idx == RING_BUFFER_SIZE - 1)? 0 :\n\t\t\tcur_ring_idx + 1;\n\n\t\t/* Did we already check the current character?  */\n\t\tif (cur_char_ring[cur_ring_idx] == 0) {\n\t\t\t/* No, we need to check the next character on the buffer.  */\n\t\t\tint idx, work_ring_idx = cur_ring_idx;\n\t\t\tmbstate_t tmp_state;\n\t\t\tsize_t mbclen;\n\n\t\t\tfor (idx = 0; lexptr + idx < lexend; idx++) {\n\t\t\t\ttmp_state = cur_mbstate;\n\t\t\t\tmbclen = mbrlen(lexptr, idx + 1, &tmp_state);\n\n\t\t\t\tif (mbclen == 1 || mbclen == (size_t)-1 || mbclen == 0) {\n\t\t\t\t\t/* It is a singlebyte character, non-complete multibyte\n\t\t\t\t\t   character or EOF.  We treat it as a singlebyte\n\t\t\t\t\t   character.  */\n\t\t\t\t\tcur_char_ring[work_ring_idx] = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (mbclen == (size_t)-2) {\n\t\t\t\t\t/* It is not a complete multibyte character.  */\n\t\t\t\t\tcur_char_ring[work_ring_idx] = idx + 1;\n\t\t\t\t} else {\n\t\t\t\t\t/* mbclen > 1 */\n\t\t\t\t\tcur_char_ring[work_ring_idx] = mbclen;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\twork_ring_idx = (work_ring_idx == RING_BUFFER_SIZE - 1)?\n\t\t\t\t\t0 : work_ring_idx + 1;\n\t\t\t}\n\t\t\tcur_mbstate = tmp_state;\n\n\t\t\t/* Put a mark on the position on which we write next character.  */\n\t\t\twork_ring_idx = (work_ring_idx == RING_BUFFER_SIZE - 1)?\n\t\t\t\t0 : work_ring_idx + 1;\n\t\t\tcur_char_ring[work_ring_idx] = 0;\n\t\t}\n\t\tif (check_for_bad || *lexptr == '\\0')\n\t\t\tcheck_bad_char(*lexptr);\n\n\t\treturn (int) (unsigned char) *lexptr++;\n\t} else {\n\t\tdo {\n#ifdef NO_CONTINUE_SOURCE_STRINGS\n\t\t\tif (lexeof)\n\t\t\t\treturn END_FILE;\n#else\n\t\t\tif (lexeof) {\n\t\t\t\tif (sourcefile->next == srcfiles)\n\t\t\t\t\treturn END_FILE;\n\t\t\t\telse\n\t\t\t\t\tnext_sourcefile();\n\t\t\t}\n#endif\n\t\t\tif (lexptr && lexptr < lexend) {\n\t\t\t\tif (check_for_bad || *lexptr == '\\0')\n\t\t\t\t\tcheck_bad_char(*lexptr);\n\t\t\t\treturn ((int) (unsigned char) *lexptr++);\n\t\t\t}\n\t\t} while (get_src_buf());\n\t\treturn END_SRC;\n\t}\n}",
      "lines": 87,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "pushback": {
      "start_point": [
        5612,
        0
      ],
      "end_point": [
        5619,
        1
      ],
      "content": "static inline void\npushback(void)\n{\n\tif (gawk_mb_cur_max > 1)\n\t\tcur_ring_idx = (cur_ring_idx == 0)? RING_BUFFER_SIZE - 1 :\n\t\t\tcur_ring_idx - 1;\n\t(! lexeof && lexptr && lexptr > lexptr_begin ? lexptr-- : lexptr);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    },
    "check_comment": {
      "start_point": [
        5623,
        0
      ],
      "end_point": [
        5634,
        1
      ],
      "content": "void\ncheck_comment(void)\n{\n\tif (comment != NULL) {\n\t\tif (first_rule) {\n\t\t\tprogram_comment = comment;\n\t\t} else\n\t\t\tblock_comment = comment;\n\t\tcomment = NULL;\n\t}\n\tfirst_rule = false;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "get_comment": {
      "start_point": [
        5642,
        0
      ],
      "end_point": [
        5705,
        1
      ],
      "content": "int\nget_comment(int flag)\n{\n\tint c;\n\tint sl;\n\ttok = tokstart;\n\ttokadd('#');\n\tsl = sourceline;\n\tchar *p1;\n\tchar *p2;\n\n\twhile (true) {\n\t\twhile ((c = nextc(false)) != '\\n' && c != END_FILE) {\n\t\t\t/* ignore \\r characters */\n\t\t\tif (c != '\\r')\n\t\t\t\ttokadd(c);\n\t\t}\n\t\tif (flag == EOL_COMMENT) {\n\t\t\t/* comment at end of line.  */\n\t\t\tif (c == '\\n')\n\t\t\t\ttokadd(c);\n\t\t\tbreak;\n\t\t}\n\t\tif (c == '\\n') {\n\t\t\ttokadd(c);\n\t\t\tsourceline++;\n\t\t\tdo {\n\t\t\t\tc = nextc(false);\n\t\t\t\tif (c == '\\n') {\n\t\t\t\t\tsourceline++;\n\t\t\t\t\ttokadd(c);\n\t\t\t\t}\n\t\t\t} while (isspace(c) && c != END_FILE);\n\t\t\tif (c == END_FILE)\n\t\t\t\tbreak;\n\t\t\telse if (c != '#') {\n\t\t\t\tpushback();\n\t\t\t\tsourceline--;\n\t\t\t\tbreak;\n\t\t\t} else\n\t\t\t\ttokadd(c);\n\t\t} else\n\t\t\tbreak;\n\t}\n\n\tif (comment != NULL)\n\t\tprior_comment = comment;\n\n\t/* remove any trailing blank lines (consecutive \\n) from comment */\n\tp1 = tok - 1;\n\tp2 = tok - 2;\n\twhile (*p1 == '\\n' && *p2 == '\\n') {\n\t\tp1--;\n\t\tp2--;\n\t\ttok--;\n\t}\n\n\tcomment = bcalloc(Op_comment, 1, sl);\n\tcomment->source_file = source;\n\tcomment->memory = make_str_node(tokstart, tok - tokstart, 0);\n\tcomment->memory->comment_type = flag;\n\n\treturn c;\n}",
      "lines": 64,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "split_comment": {
      "start_point": [
        5709,
        0
      ],
      "end_point": [
        5736,
        1
      ],
      "content": "static void\nsplit_comment(void)\n{\n\tchar *p;\n\tint l;\n\tNODE *n;\n\n\tp = comment_to_save->memory->stptr;\n\tl = comment_to_save->memory->stlen - 3;\n\t/* have at least two comments so split at last blank line (\\n\\n)  */\n\twhile (l >= 0) {\n\t\tif (p[l] == '\\n' && p[l+1] == '\\n') {\n\t\t\tfunction_comment = comment_to_save;\n\t\t\tn = function_comment->memory;\n\t\t\tfunction_comment->memory = make_string(p + l + 2, n->stlen - l - 2);\n\t\t\t/* create program comment  */\n\t\t\tprogram_comment = bcalloc(Op_comment, 1, sourceline);\n\t\t\tprogram_comment->source_file = comment_to_save->source_file;\n\t\t\tp[l + 2] = 0;\n\t\t\tprogram_comment->memory = make_str_node(p, l + 2, 0);\n\t\t\tcomment_to_save = NULL;\n\t\t\tfreenode(n);\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t\tl--;\n\t}\n}",
      "lines": 28,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "allow_newline": {
      "start_point": [
        5740,
        0
      ],
      "end_point": [
        5771,
        1
      ],
      "content": "static void\nallow_newline(void)\n{\n\tint c;\n\n\tfor (;;) {\n\t\tc = nextc(true);\n\t\tif (c == END_FILE) {\n\t\t\tpushback();\n\t\t\tbreak;\n\t\t}\n\t\tif (c == '#') {\n\t\t\tif (do_pretty_print && ! do_profile) {\n\t\t\t/* collect comment byte code iff doing pretty print but not profiling.  */\n\t\t\t\tc = get_comment(EOL_COMMENT);\n\t\t\t} else {\n\t\t\t\twhile ((c = nextc(false)) != '\\n' && c != END_FILE)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (c == END_FILE) {\n\t\t\t\tpushback();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (c == '\\n')\n\t\t\tsourceline++;\n\t\tif (! isspace(c)) {\n\t\t\tpushback();\n\t\t\tbreak;\n\t\t}\n\t}\n}",
      "lines": 32,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "newline_eof": {
      "start_point": [
        5781,
        0
      ],
      "end_point": [
        5798,
        1
      ],
      "content": "static int\nnewline_eof()\n{\n\t/* NB: a newline at end does not start a source line. */\n\tif (lasttok != NEWLINE) {\n                pushback();\n\t\tif (do_lint && ! eof_warned) {\n        \t\tlintwarn(_(\"source file does not end in newline\"));\n\t\t\teof_warned = true;\n\t\t}\n\t\tsourceline++;\n\t\treturn NEWLINE;\n\t}\n\n\tsourceline--;\n\teof_warned = false;\n\treturn LEX_EOF;\n}",
      "lines": 18,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "yylex": [
      {
        "start_point": [
          5804,
          0
        ],
        "end_point": [
          6696,
          1
        ],
        "content": "yylex_ebcdic(void)\n#else\nyylex(void)\n#endif\n{\n\tint c;\n\tbool seen_e = false;\t\t/* These are for numbers */\n\tbool seen_point = false;\n\tbool esc_seen;\t\t/* for literal strings */\n\tint mid;\n\tint base;\n\tstatic bool did_newline = false;\n\tchar *tokkey;\n\tbool inhex = false;\n\tbool intlstr = false;\n\tAWKNUM d;\n\tbool collecting_typed_regexp = false;\n\n#define GET_INSTRUCTION(op) bcalloc(op, 1, sourceline)\n\n#define NEWLINE_EOF newline_eof()\n\n\tyylval = (INSTRUCTION *) NULL;\n\tif (lasttok == SUBSCRIPT) {\n\t\tlasttok = 0;\n\t\treturn SUBSCRIPT;\n\t}\n\n\tif (lasttok == LEX_EOF)\t\t/* error earlier in current source, must give up !! */\n\t\treturn 0;\n\n\tc = nextc(! want_regexp);\n\tif (c == END_SRC)\n\t\treturn 0;\n\tif (c == END_FILE)\n\t\treturn lasttok = NEWLINE_EOF;\n\tpushback();\n\n#if defined __EMX__\n\t/*\n\t * added for OS/2's extproc feature of cmd.exe\n\t * (like #! in BSD sh)\n\t */\n\tif (strncasecmp(lexptr, \"extproc \", 8) == 0) {\n\t\twhile (*lexptr && *lexptr != '\\n')\n\t\t\tlexptr++;\n\t}\n#endif\n\n\tlexeme = lexptr;\n\tthisline = NULL;\n\ncollect_regexp:\n\tif (want_regexp) {\n\t\tint in_brack = 0;\t/* count brackets, [[:alnum:]] allowed */\n\t\tint b_index = -1;\n\t\tint cur_index = 0;\n\n\t\t/*\n\t\t * Here is what's ok with brackets:\n\t\t *\n\t\t * [..[..] []] [^]] [.../...]\n\t\t * [...\\[...] [...\\]...] [...\\/...]\n\t\t *\n\t\t * (Remember that all of the above are inside /.../)\n\t\t *\n\t\t * The code for \\ handles \\[, \\] and \\/.\n\t\t *\n\t\t * Otherwise, track the first open [ position, and if\n\t\t * an embedded ] occurs, allow it to pass through\n\t\t * if it's right after the first [ or after [^.\n\t\t *\n\t\t * Whew!\n\t\t */\n\n\t\twant_regexp = false;\n\t\ttok = tokstart;\n\t\tfor (;;) {\n\t\t\tc = nextc(false);\n\n\t\t\tcur_index = tok - tokstart;\n\t\t\tif (gawk_mb_cur_max == 1 || nextc_is_1stbyte) switch (c) {\n\t\t\tcase '[':\n\t\t\t\tif (nextc(false) == ':' || in_brack == 0) {\n\t\t\t\t\tin_brack++;\n\t\t\t\t\tif (in_brack == 1)\n\t\t\t\t\t\tb_index = tok - tokstart;\n\t\t\t\t}\n\t\t\t\tpushback();\n\t\t\t\tbreak;\n\t\t\tcase ']':\n\t\t\t\tif (in_brack > 0\n\t\t\t\t    && (cur_index == b_index + 1\n\t\t\t\t\t|| (cur_index == b_index + 2 && tok[-1] == '^')))\n\t\t\t\t\t; /* do nothing */\n\t\t\t\telse {\n\t\t\t\t\tin_brack--;\n\t\t\t\t\tif (in_brack == 0)\n\t\t\t\t\t\tb_index = -1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '\\\\':\n\t\t\t\tif ((c = nextc(false)) == END_FILE) {\n\t\t\t\t\tpushback();\n\t\t\t\t\tyyerror(_(\"unterminated regexp ends with `\\\\' at end of file\"));\n\t\t\t\t\tgoto end_regexp; /* kludge */\n\t\t\t\t}\n\t\t\t\tif (c == '\\r')\t/* allow MS-DOS files. bleah */\n\t\t\t\t\tc = nextc(true);\n\t\t\t\tif (c == '\\n') {\n\t\t\t\t\tsourceline++;\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\ttokadd('\\\\');\n\t\t\t\t\ttokadd(c);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '/':\t/* end of the regexp */\n\t\t\t\tif (in_brack > 0)\n\t\t\t\t\tbreak;\nend_regexp:\n\t\t\t\tyylval = GET_INSTRUCTION(Op_token);\n\t\t\t\tyylval->lextok = estrdup(tokstart, tok - tokstart);\n\t\t\t\tif (do_lint) {\n\t\t\t\t\tint peek = nextc(true);\n\n\t\t\t\t\tpushback();\n\t\t\t\t\tif (peek == 'i' || peek == 's') {\n\t\t\t\t\t\tif (source)\n\t\t\t\t\t\t\tlintwarn(\n\t\t\t\t\t\t_(\"%s: %d: tawk regex modifier `/.../%c' doesn't work in gawk\"),\n\t\t\t\t\t\t\t\tsource, sourceline, peek);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tlintwarn(\n\t\t\t\t\t\t_(\"tawk regex modifier `/.../%c' doesn't work in gawk\"),\n\t\t\t\t\t\t\t\tpeek);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (collecting_typed_regexp) {\n\t\t\t\t\tcollecting_typed_regexp = false;\n\t\t\t\t\tlasttok = TYPED_REGEXP;\n\t\t\t\t} else\n\t\t\t\t\tlasttok = REGEXP;\n\n\t\t\t\treturn lasttok;\n\t\t\tcase '\\n':\n\t\t\t\tpushback();\n\t\t\t\tyyerror(_(\"unterminated regexp\"));\n\t\t\t\tgoto end_regexp;\t/* kludge */\n\t\t\tcase END_FILE:\n\t\t\t\tpushback();\n\t\t\t\tyyerror(_(\"unterminated regexp at end of file\"));\n\t\t\t\tgoto end_regexp;\t/* kludge */\n\t\t\t}\n\t\t\ttokadd(c);\n\t\t}\n\t}\nretry:\n\n\t/* skipping \\r is a hack, but windows is just too pervasive. sigh. */\n\twhile ((c = nextc(true)) == ' ' || c == '\\t' || c == '\\r')\n\t\tcontinue;\n\n\tlexeme = lexptr ? lexptr - 1 : lexptr;\n\tthisline = NULL;\n\ttok = tokstart;\n\n\tif (gawk_mb_cur_max == 1 || nextc_is_1stbyte)\n\tswitch (c) {\n\tcase END_SRC:\n\t\treturn 0;\n\n\tcase END_FILE:\n\t\treturn lasttok = NEWLINE_EOF;\n\n\tcase '\\n':\n\t\tsourceline++;\n\t\treturn lasttok = NEWLINE;\n\n\tcase '#':\t\t/* it's a comment */\n\t\tif (do_pretty_print && ! do_profile) {\n\t\t\t/*\n\t\t\t * Collect comment byte code iff doing pretty print\n\t\t\t * but not profiling.\n\t\t\t */\n\t\t\tif (lasttok == NEWLINE || lasttok == 0)\n\t\t\t\tc = get_comment(FULL_COMMENT);\n\t\t\telse\n\t\t\t\tc = get_comment(EOL_COMMENT);\n\n\t\t\tif (c == END_FILE)\n\t\t\t\treturn lasttok = NEWLINE_EOF;\n\t\t} else {\n\t\t\twhile ((c = nextc(false)) != '\\n') {\n\t\t\t\tif (c == END_FILE)\n\t\t\t\t\treturn lasttok = NEWLINE_EOF;\n\t\t\t}\n\t\t}\n\t\tsourceline++;\n\t\treturn lasttok = NEWLINE;\n\n\tcase '@':\n\t\tc = nextc(true);\n\t\tif (c == '/') {\n\t\t\twant_regexp = true;\n\t\t\tcollecting_typed_regexp = true;\n\t\t\tgoto collect_regexp;\n\t\t}\n\t\tpushback();\n\t\tat_seen = true;\n\t\treturn lasttok = '@';\n\n\tcase '\\\\':\n#ifdef RELAXED_CONTINUATION\n\t\t/*\n\t\t * This code purports to allow comments and/or whitespace\n\t\t * after the `\\' at the end of a line used for continuation.\n\t\t * Use it at your own risk. We think it's a bad idea, which\n\t\t * is why it's not on by default.\n\t\t */\n\t\tif (! do_traditional) {\n\t\t\t/* strip trailing white-space and/or comment */\n\t\t\twhile ((c = nextc(true)) == ' ' || c == '\\t' || c == '\\r')\n\t\t\t\tcontinue;\n\t\t\tif (c == '#') {\n\t\t\t\tstatic bool warned = false;\n\n\t\t\t\tif (do_lint && ! warned) {\n\t\t\t\t\twarned = true;\n\t\t\t\t\tlintwarn(\n\t\t_(\"use of `\\\\ #...' line continuation is not portable\"));\n\t\t\t\t}\n\t\t\t\tif (do_pretty_print && ! do_profile)\n\t\t\t\t\tc = get_comment(EOL_COMMENT);\n\t\t\t\telse {\n\t\t\t\t\twhile ((c = nextc(false)) != '\\n')\n\t\t\t\t\t\tif (c == END_FILE)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpushback();\n\t\t}\n#endif /* RELAXED_CONTINUATION */\n\t\tc = nextc(true);\n\t\tif (c == '\\r')\t/* allow MS-DOS files. bleah */\n\t\t\tc = nextc(true);\n\t\tif (c == '\\n') {\n\t\t\tsourceline++;\n\t\t\tgoto retry;\n\t\t} else {\n\t\t\tyyerror(_(\"backslash not last character on line\"));\n\t\t\treturn lasttok = LEX_EOF;\n\t\t}\n\t\tbreak;\n\n\tcase ':':\n\tcase '?':\n\t\tyylval = GET_INSTRUCTION(Op_cond_exp);\n\t\tif (! do_posix)\n\t\t\tallow_newline();\n\t\treturn lasttok = c;\n\n\t\t/*\n\t\t * in_parens is undefined unless we are parsing a print\n\t\t * statement (in_print), but why bother with a check?\n\t\t */\n\tcase ')':\n\t\tin_parens--;\n\t\treturn lasttok = c;\n\n\tcase '(':\n\t\tin_parens++;\n\t\treturn lasttok = c;\n\tcase '$':\n\t\tyylval = GET_INSTRUCTION(Op_field_spec);\n\t\treturn lasttok = c;\n\tcase '{':\n\t\tif (++in_braces == 1)\n\t\t\tfirstline = sourceline;\n\tcase ';':\n\tcase ',':\n\tcase '[':\n\t\t\treturn lasttok = c;\n\tcase ']':\n\t\tc = nextc(true);\n\t\tpushback();\n\t\tif (c == '[') {\n\t\t\tif (do_traditional)\n\t\t\t\tfatal(_(\"multidimensional arrays are a gawk extension\"));\n\t\t\tif (do_lint)\n\t\t\t\tlintwarn(_(\"multidimensional arrays are a gawk extension\"));\n\t\t\tyylval = GET_INSTRUCTION(Op_sub_array);\n\t\t\tlasttok = ']';\n\t\t} else {\n\t\t\tyylval = GET_INSTRUCTION(Op_subscript);\n\t\t\tlasttok = SUBSCRIPT;\t/* end of subscripts */\n\t\t}\n\t\treturn ']';\n\n\tcase '*':\n\t\tif ((c = nextc(true)) == '=') {\n\t\t\tyylval = GET_INSTRUCTION(Op_assign_times);\n\t\t\treturn lasttok = ASSIGNOP;\n\t\t} else if (do_posix) {\n\t\t\tpushback();\n\t\t\tyylval = GET_INSTRUCTION(Op_times);\n\t\t\treturn lasttok = '*';\n\t\t} else if (c == '*') {\n\t\t\t/* make ** and **= aliases for ^ and ^= */\n\t\t\tstatic bool did_warn_op = false, did_warn_assgn = false;\n\n\t\t\tif (nextc(true) == '=') {\n\t\t\t\tif (! did_warn_assgn) {\n\t\t\t\t\tdid_warn_assgn = true;\n\t\t\t\t\tif (do_lint)\n\t\t\t\t\t\tlintwarn(_(\"POSIX does not allow operator `**='\"));\n\t\t\t\t\tif (do_lint_old)\n\t\t\t\t\t\twarning(_(\"old awk does not support operator `**='\"));\n\t\t\t\t}\n\t\t\t\tyylval = GET_INSTRUCTION(Op_assign_exp);\n\t\t\t\treturn ASSIGNOP;\n\t\t\t} else {\n\t\t\t\tpushback();\n\t\t\t\tif (! did_warn_op) {\n\t\t\t\t\tdid_warn_op = true;\n\t\t\t\t\tif (do_lint)\n\t\t\t\t\t\tlintwarn(_(\"POSIX does not allow operator `**'\"));\n\t\t\t\t\tif (do_lint_old)\n\t\t\t\t\t\twarning(_(\"old awk does not support operator `**'\"));\n\t\t\t\t}\n\t\t\t\tyylval = GET_INSTRUCTION(Op_exp);\n\t\t\t\treturn lasttok = '^';\n\t\t\t}\n\t\t}\n\t\tpushback();\n\t\tyylval = GET_INSTRUCTION(Op_times);\n\t\treturn lasttok = '*';\n\n\tcase '/':\n\t\tif (nextc(false) == '=') {\n\t\t\tpushback();\n\t\t\treturn lasttok = SLASH_BEFORE_EQUAL;\n\t\t}\n\t\tpushback();\n\t\tyylval = GET_INSTRUCTION(Op_quotient);\n\t\treturn lasttok = '/';\n\n\tcase '%':\n\t\tif (nextc(true) == '=') {\n\t\t\tyylval = GET_INSTRUCTION(Op_assign_mod);\n\t\t\treturn lasttok = ASSIGNOP;\n\t\t}\n\t\tpushback();\n\t\tyylval = GET_INSTRUCTION(Op_mod);\n\t\treturn lasttok = '%';\n\n\tcase '^':\n\t{\n\t\tstatic bool did_warn_op = false, did_warn_assgn = false;\n\n\t\tif (nextc(true) == '=') {\n\t\t\tif (do_lint_old && ! did_warn_assgn) {\n\t\t\t\tdid_warn_assgn = true;\n\t\t\t\twarning(_(\"operator `^=' is not supported in old awk\"));\n\t\t\t}\n\t\t\tyylval = GET_INSTRUCTION(Op_assign_exp);\n\t\t\treturn lasttok = ASSIGNOP;\n\t\t}\n\t\tpushback();\n\t\tif (do_lint_old && ! did_warn_op) {\n\t\t\tdid_warn_op = true;\n\t\t\twarning(_(\"operator `^' is not supported in old awk\"));\n\t\t}\n\t\tyylval = GET_INSTRUCTION(Op_exp);\n\t\treturn lasttok = '^';\n\t}\n\n\tcase '+':\n\t\tif ((c = nextc(true)) == '=') {\n\t\t\tyylval = GET_INSTRUCTION(Op_assign_plus);\n\t\t\treturn lasttok = ASSIGNOP;\n\t\t}\n\t\tif (c == '+') {\n\t\t\tyylval = GET_INSTRUCTION(Op_symbol);\n\t\t\treturn lasttok = INCREMENT;\n\t\t}\n\t\tpushback();\n\t\tyylval = GET_INSTRUCTION(Op_plus);\n\t\treturn lasttok = '+';\n\n\tcase '!':\n\t\tif ((c = nextc(true)) == '=') {\n\t\t\tyylval = GET_INSTRUCTION(Op_notequal);\n\t\t\treturn lasttok = RELOP;\n\t\t}\n\t\tif (c == '~') {\n\t\t\tyylval = GET_INSTRUCTION(Op_nomatch);\n\t\t\treturn lasttok = MATCHOP;\n\t\t}\n\t\tpushback();\n\t\tyylval = GET_INSTRUCTION(Op_symbol);\n\t\treturn lasttok = '!';\n\n\tcase '<':\n\t\tif (nextc(true) == '=') {\n\t\t\tyylval = GET_INSTRUCTION(Op_leq);\n\t\t\treturn lasttok = RELOP;\n\t\t}\n\t\tyylval = GET_INSTRUCTION(Op_less);\n\t\tpushback();\n\t\treturn lasttok = '<';\n\n\tcase '=':\n\t\tif (nextc(true) == '=') {\n\t\t\tyylval = GET_INSTRUCTION(Op_equal);\n\t\t\treturn lasttok = RELOP;\n\t\t}\n\t\tyylval = GET_INSTRUCTION(Op_assign);\n\t\tpushback();\n\t\treturn lasttok = ASSIGN;\n\n\tcase '>':\n\t\tif ((c = nextc(true)) == '=') {\n\t\t\tyylval = GET_INSTRUCTION(Op_geq);\n\t\t\treturn lasttok = RELOP;\n\t\t} else if (c == '>') {\n\t\t\tyylval = GET_INSTRUCTION(Op_symbol);\n\t\t\tyylval->redir_type = redirect_append;\n\t\t\treturn lasttok = IO_OUT;\n\t\t}\n\t\tpushback();\n\t\tif (in_print && in_parens == 0) {\n\t\t\tyylval = GET_INSTRUCTION(Op_symbol);\n\t\t\tyylval->redir_type = redirect_output;\n\t\t\treturn lasttok = IO_OUT;\n\t\t}\n\t\tyylval = GET_INSTRUCTION(Op_greater);\n\t\treturn lasttok = '>';\n\n\tcase '~':\n\t\tyylval = GET_INSTRUCTION(Op_match);\n\t\treturn lasttok = MATCHOP;\n\n\tcase '}':\n\t\t/*\n\t\t * Added did newline stuff.  Easier than\n\t\t * hacking the grammar.\n\t\t */\n\t\tif (did_newline) {\n\t\t\tdid_newline = false;\n\t\t\tif (--in_braces == 0)\n\t\t\t\tlastline = sourceline;\n\t\t\treturn lasttok = c;\n\t\t}\n\t\tdid_newline = true;\n\t\t--lexptr;\t/* pick up } next time */\n\t\treturn lasttok = NEWLINE;\n\n\tcase '\"':\n\tstring:\n\t\tesc_seen = false;\n\t\t/*\n\t\t * Allow any kind of junk in quoted string,\n\t\t * so pass false to nextc().\n\t\t */\n\t\twhile ((c = nextc(false)) != '\"') {\n\t\t\tif (c == '\\n') {\n\t\t\t\tpushback();\n\t\t\t\tyyerror(_(\"unterminated string\"));\n\t\t\t\treturn lasttok = LEX_EOF;\n\t\t\t}\n\t\t\tif ((gawk_mb_cur_max == 1 || nextc_is_1stbyte) &&\n\t\t\t    c == '\\\\') {\n\t\t\t\tc = nextc(true);\n\t\t\t\tif (c == '\\r')\t/* allow MS-DOS files. bleah */\n\t\t\t\t\tc = nextc(true);\n\t\t\t\tif (c == '\\n') {\n\t\t\t\t\tsourceline++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tesc_seen = true;\n\t\t\t\tif (! want_source || c != '\"')\n\t\t\t\t\ttokadd('\\\\');\n\t\t\t}\n\t\t\tif (c == END_FILE) {\n\t\t\t\tpushback();\n\t\t\t\tyyerror(_(\"unterminated string\"));\n\t\t\t\treturn lasttok = LEX_EOF;\n\t\t\t}\n\t\t\ttokadd(c);\n\t\t}\n\t\tyylval = GET_INSTRUCTION(Op_token);\n\t\tif (want_source) {\n\t\t\tyylval->lextok = estrdup(tokstart, tok - tokstart);\n\t\t\treturn lasttok = FILENAME;\n\t\t}\n\n\t\tyylval->opcode = Op_push_i;\n\t\tyylval->memory = make_str_node(tokstart,\n\t\t\t\t\ttok - tokstart, esc_seen ? SCAN : 0);\n\t\tif (intlstr) {\n\t\t\tyylval->memory->flags |= INTLSTR;\n\t\t\tintlstr = false;\n\t\t\tif (do_intl)\n\t\t\t\tdumpintlstr(yylval->memory->stptr, yylval->memory->stlen);\n\t\t}\n\t\treturn lasttok = YSTRING;\n\n\tcase '-':\n\t\tif ((c = nextc(true)) == '=') {\n\t\t\tyylval = GET_INSTRUCTION(Op_assign_minus);\n\t\t\treturn lasttok = ASSIGNOP;\n\t\t}\n\t\tif (c == '-') {\n\t\t\tyylval = GET_INSTRUCTION(Op_symbol);\n\t\t\treturn lasttok = DECREMENT;\n\t\t}\n\t\tpushback();\n\t\tyylval = GET_INSTRUCTION(Op_minus);\n\t\treturn lasttok = '-';\n\n\tcase '.':\n\t\tc = nextc(true);\n\t\tpushback();\n\t\tif (! isdigit(c))\n\t\t\treturn lasttok = '.';\n\t\telse\n\t\t\tc = '.';\n\t\t/* FALL THROUGH */\n\tcase '0':\n\tcase '1':\n\tcase '2':\n\tcase '3':\n\tcase '4':\n\tcase '5':\n\tcase '6':\n\tcase '7':\n\tcase '8':\n\tcase '9':\n\t\t/* It's a number */\n\t\tfor (;;) {\n\t\t\tbool gotnumber = false;\n\n\t\t\ttokadd(c);\n\t\t\tswitch (c) {\n\t\t\tcase 'x':\n\t\t\tcase 'X':\n\t\t\t\tif (do_traditional)\n\t\t\t\t\tgoto done;\n\t\t\t\tif (tok == tokstart + 2) {\n\t\t\t\t\tint peek = nextc(true);\n\n\t\t\t\t\tif (isxdigit(peek)) {\n\t\t\t\t\t\tinhex = true;\n\t\t\t\t\t\tpushback();\t/* following digit */\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpushback();\t/* x or X */\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '.':\n\t\t\t\t/* period ends exponent part of floating point number */\n\t\t\t\tif (seen_point || seen_e) {\n\t\t\t\t\tgotnumber = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tseen_point = true;\n\t\t\t\tbreak;\n\t\t\tcase 'e':\n\t\t\tcase 'E':\n\t\t\t\tif (inhex)\n\t\t\t\t\tbreak;\n\t\t\t\tif (seen_e) {\n\t\t\t\t\tgotnumber = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tseen_e = true;\n\t\t\t\tif ((c = nextc(true)) == '-' || c == '+') {\n\t\t\t\t\tint c2 = nextc(true);\n\n\t\t\t\t\tif (isdigit(c2)) {\n\t\t\t\t\t\ttokadd(c);\n\t\t\t\t\t\ttokadd(c2);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpushback();\t/* non-digit after + or - */\n\t\t\t\t\t\tpushback();\t/* + or - */\n\t\t\t\t\t\tpushback();\t/* e or E */\n\t\t\t\t\t}\n\t\t\t\t} else if (! isdigit(c)) {\n\t\t\t\t\tpushback();\t/* character after e or E */\n\t\t\t\t\tpushback();\t/* e or E */\n\t\t\t\t} else {\n\t\t\t\t\tpushback();\t/* digit */\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'a':\n\t\t\tcase 'A':\n\t\t\tcase 'b':\n\t\t\tcase 'B':\n\t\t\tcase 'c':\n\t\t\tcase 'C':\n\t\t\tcase 'D':\n\t\t\tcase 'd':\n\t\t\tcase 'f':\n\t\t\tcase 'F':\n\t\t\t\tif (do_traditional || ! inhex)\n\t\t\t\t\tgoto done;\n\t\t\t\t/* fall through */\n\t\t\tcase '0':\n\t\t\tcase '1':\n\t\t\tcase '2':\n\t\t\tcase '3':\n\t\t\tcase '4':\n\t\t\tcase '5':\n\t\t\tcase '6':\n\t\t\tcase '7':\n\t\t\tcase '8':\n\t\t\tcase '9':\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\tdone:\n\t\t\t\tgotnumber = true;\n\t\t\t}\n\t\t\tif (gotnumber)\n\t\t\t\tbreak;\n\t\t\tc = nextc(true);\n\t\t}\n\t\tpushback();\n\n\t\ttokadd('\\0');\n\t\tyylval = GET_INSTRUCTION(Op_push_i);\n\n\t\tbase = 10;\n\t\tif (! do_traditional) {\n\t\t\tbase = get_numbase(tokstart, strlen(tokstart)-1, false);\n\t\t\tif (do_lint) {\n\t\t\t\tif (base == 8)\n\t\t\t\t\tlintwarn(\"numeric constant `%.*s' treated as octal\",\n\t\t\t\t\t\t(int) strlen(tokstart)-1, tokstart);\n\t\t\t\telse if (base == 16)\n\t\t\t\t\tlintwarn(\"numeric constant `%.*s' treated as hexadecimal\",\n\t\t\t\t\t\t(int) strlen(tokstart)-1, tokstart);\n\t\t\t}\n\t\t}\n\n#ifdef HAVE_MPFR\n\t\tif (do_mpfr) {\n\t\t\tNODE *r;\n\n\t\t\tif (! seen_point && ! seen_e) {\n\t\t\t\tr = mpg_integer();\n\t\t\t\tmpg_strtoui(r->mpg_i, tokstart, strlen(tokstart), NULL, base);\n\t\t\t\terrno = 0;\n\t\t\t} else {\n\t\t\t\tint tval;\n\t\t\t\tr = mpg_float();\n\t\t\t\ttval = mpfr_strtofr(r->mpg_numbr, tokstart, NULL, base, ROUND_MODE);\n\t\t\t\terrno = 0;\n\t\t\t\tIEEE_FMT(r->mpg_numbr, tval);\n\t\t\t}\n\t\t\tyylval->memory = set_profile_text(r, tokstart, strlen(tokstart)-1);\n\t\t\treturn lasttok = YNUMBER;\n\t\t}\n#endif\n\t\tif (base != 10)\n\t\t\td = nondec2awknum(tokstart, strlen(tokstart)-1, NULL);\n\t\telse\n\t\t\td = atof(tokstart);\n\t\tyylval->memory = set_profile_text(make_number(d), tokstart, strlen(tokstart) - 1);\n\t\tif (d <= INT32_MAX && d >= INT32_MIN && d == (int32_t) d)\n\t\t\tyylval->memory->flags |= NUMINT;\n\t\treturn lasttok = YNUMBER;\n\n\tcase '&':\n\t\tif ((c = nextc(true)) == '&') {\n\t\t\tyylval = GET_INSTRUCTION(Op_and);\n\t\t\tallow_newline();\n\t\t\treturn lasttok = LEX_AND;\n\t\t}\n\t\tpushback();\n\t\tyylval = GET_INSTRUCTION(Op_symbol);\n\t\treturn lasttok = '&';\n\n\tcase '|':\n\t\tif ((c = nextc(true)) == '|') {\n\t\t\tyylval = GET_INSTRUCTION(Op_or);\n\t\t\tallow_newline();\n\t\t\treturn lasttok = LEX_OR;\n\t\t} else if (! do_traditional && c == '&') {\n\t\t\tyylval = GET_INSTRUCTION(Op_symbol);\n\t\t\tyylval->redir_type = redirect_twoway;\n\t\t\treturn lasttok = (in_print && in_parens == 0 ? IO_OUT : IO_IN);\n\t\t}\n\t\tpushback();\n\t\tif (in_print && in_parens == 0) {\n\t\t\tyylval = GET_INSTRUCTION(Op_symbol);\n\t\t\tyylval->redir_type = redirect_pipe;\n\t\t\treturn lasttok = IO_OUT;\n\t\t} else {\n\t\t\tyylval = GET_INSTRUCTION(Op_symbol);\n\t\t\tyylval->redir_type = redirect_pipein;\n\t\t\treturn lasttok = IO_IN;\n\t\t}\n\t}\n\n\tif (! is_letter(c)) {\n\t\tyyerror(_(\"invalid char '%c' in expression\"), c);\n\t\treturn lasttok = LEX_EOF;\n\t}\n\n\t/*\n\t * Lots of fog here.  Consider:\n\t *\n\t * print \"xyzzy\"$_\"foo\"\n\t *\n\t * Without the check for ` lasttok != '$' ', this is parsed as\n\t *\n\t * print \"xxyzz\" $(_\"foo\")\n\t *\n\t * With the check, it is \"correctly\" parsed as three\n\t * string concatenations.  Sigh.  This seems to be\n\t * \"more correct\", but this is definitely one of those\n\t * occasions where the interactions are funny.\n\t */\n\tif (! do_traditional && c == '_' && lasttok != '$') {\n\t\tif ((c = nextc(true)) == '\"') {\n\t\t\tintlstr = true;\n\t\t\tgoto string;\n\t\t}\n\t\tpushback();\n\t\tc = '_';\n\t}\n\n\t/* it's some type of name-type-thing.  Find its length. */\n\ttok = tokstart;\n\twhile (c != END_FILE && is_identchar(c)) {\n\t\ttokadd(c);\n\t\tc = nextc(true);\n\t}\n\ttokadd('\\0');\n\tpushback();\n\n\t/* See if it is a special token. */\n\tif ((mid = check_special(tokstart)) >= 0) {\n\t\tstatic int warntab[sizeof(tokentab) / sizeof(tokentab[0])];\n\t\tint class = tokentab[mid].class;\n\n\t\tif ((class == LEX_INCLUDE || class == LEX_LOAD || class == LEX_EVAL)\n\t\t\t\t&& lasttok != '@')\n\t\t\tgoto out;\n\n\t\t/* allow parameter names to shadow the names of gawk extension built-ins */\n\t\tif ((tokentab[mid].flags & GAWKX) != 0) {\n\t\t\tNODE *f;\n\n\t\t\tswitch (want_param_names) {\n\t\t\tcase FUNC_HEADER:\n\t\t\t\t/* in header, defining parameter names */\n\t\t\t\tgoto out;\n\t\t\tcase FUNC_BODY:\n\t\t\t\t/* in body, name must be in symbol table for it to be a parameter */\n\t\t\t\tif ((f = lookup(tokstart)) != NULL) {\n\t\t\t\t\tif (f->type == Node_builtin_func)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\telse\n\t\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\t/* else\n\t\t\t\t\tfall through */\n\t\t\tcase DONT_CHECK:\n\t\t\t\t/* regular code */\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tcant_happen();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (do_lint) {\n\t\t\tif ((tokentab[mid].flags & GAWKX) != 0 && (warntab[mid] & GAWKX) == 0) {\n\t\t\t\tlintwarn(_(\"`%s' is a gawk extension\"),\n\t\t\t\t\ttokentab[mid].operator);\n\t\t\t\twarntab[mid] |= GAWKX;\n\t\t\t}\n\t\t\tif ((tokentab[mid].flags & NOT_POSIX) != 0 && (warntab[mid] & NOT_POSIX) == 0) {\n\t\t\t\tlintwarn(_(\"POSIX does not allow `%s'\"),\n\t\t\t\t\ttokentab[mid].operator);\n\t\t\t\twarntab[mid] |= NOT_POSIX;\n\t\t\t}\n\t\t}\n\t\tif (do_lint_old && (tokentab[mid].flags & NOT_OLD) != 0\n\t\t\t\t && (warntab[mid] & NOT_OLD) == 0\n\t\t) {\n\t\t\twarning(_(\"`%s' is not supported in old awk\"),\n\t\t\t\t\ttokentab[mid].operator);\n\t\t\twarntab[mid] |= NOT_OLD;\n\t\t}\n\n\t\tif ((tokentab[mid].flags & BREAK) != 0)\n\t\t\tbreak_allowed++;\n\t\tif ((tokentab[mid].flags & CONTINUE) != 0)\n\t\t\tcontinue_allowed++;\n\n\t\tswitch (class) {\n\t\tcase LEX_INCLUDE:\n\t\tcase LEX_LOAD:\n\t\t\twant_source = true;\n\t\t\tbreak;\n\t\tcase LEX_EVAL:\n\t\t\tif (in_main_context())\n\t\t\t\tgoto out;\n\t\t\temalloc(tokkey, char *, tok - tokstart + 1, \"yylex\");\n\t\t\ttokkey[0] = '@';\n\t\t\tmemcpy(tokkey + 1, tokstart, tok - tokstart);\n\t\t\tyylval = GET_INSTRUCTION(Op_token);\n\t\t\tyylval->lextok = tokkey;\n\t\t\tbreak;\n\n\t\tcase LEX_FUNCTION:\n\t\tcase LEX_BEGIN:\n\t\tcase LEX_END:\n\t\tcase LEX_BEGINFILE:\n\t\tcase LEX_ENDFILE:\n\t\t\tyylval = bcalloc(tokentab[mid].value, 3, sourceline);\n\t\t\tbreak;\n\n\t\tcase LEX_FOR:\n\t\tcase LEX_WHILE:\n\t\tcase LEX_DO:\n\t\tcase LEX_SWITCH:\n\t\t\tif (! do_pretty_print)\n\t\t\t\treturn lasttok = class;\n\t\t\t/* fall through */\n\t\tcase LEX_CASE:\n\t\t\tyylval = bcalloc(tokentab[mid].value, 2, sourceline);\n\t\t\tbreak;\n\n\t\t/*\n\t\t * These must be checked here, due to the LALR nature of the parser,\n\t\t * the rules for continue and break may not be reduced until after\n\t\t * a token that increments the xxx_allowed varibles is seen. Bleah.\n\t\t */\n\t\tcase LEX_CONTINUE:\n\t\t\tif (! continue_allowed) {\n\t\t\t\terror_ln(sourceline,\n\t\t\t\t\t_(\"`continue' is not allowed outside a loop\"));\n\t\t\t\terrcount++;\n\t\t\t}\n\t\t\tgoto make_instruction;\n\n\t\tcase LEX_BREAK:\n\t\t\tif (! break_allowed) {\n\t\t\t\terror_ln(sourceline,\n\t\t\t\t\t_(\"`break' is not allowed outside a loop or switch\"));\n\t\t\t\terrcount++;\n\t\t\t}\n\t\t\tgoto make_instruction;\n\n\t\tdefault:\nmake_instruction:\n\t\t\tyylval = GET_INSTRUCTION(tokentab[mid].value);\n\t\t\tif (class == LEX_BUILTIN || class == LEX_LENGTH)\n\t\t\t\tyylval->builtin_idx = mid;\n\t\t\tbreak;\n\t\t}\n\t\treturn lasttok = class;\n\t}\nout:\n\ttokkey = estrdup(tokstart, tok - tokstart);\n\tif (*lexptr == '(') {\n\t\tyylval = bcalloc(Op_token, 2, sourceline);\n\t\tyylval->lextok = tokkey;\n\t\treturn lasttok = FUNC_CALL;\n\t} else {\n\t\tstatic bool goto_warned = false;\n\n\t\tyylval = GET_INSTRUCTION(Op_token);\n\t\tyylval->lextok = tokkey;\n\n#define SMART_ALECK\t1\n\t\tif (SMART_ALECK && do_lint\n\t\t    && ! goto_warned && strcasecmp(tokkey, \"goto\") == 0) {\n\t\t\tgoto_warned = true;\n\t\t\tlintwarn(_(\"`goto' considered harmful!\\n\"));\n\t\t}\n\t\treturn lasttok = NAME;\n\t}\n\n#undef GET_INSTRUCTION\n#undef NEWLINE_EOF\n}",
        "lines": 893,
        "depth": 23,
        "decorators": [
          "yylex_ebcdic(void)",
          "yylex_ebcdic",
          "(",
          "void",
          "void",
          ")",
          "#else",
          "#else"
        ]
      },
      {
        "start_point": [
          6704,
          0
        ],
        "end_point": [
          6730,
          1
        ],
        "content": "static int\nyylex(void)\n{\n\tstatic char etoa_xlate[256];\n\tstatic int do_etoa_init = 1;\n\tint tok;\n\n\tif (do_etoa_init)\n\t{\n\t\tfor (tok = 0; tok < 256; tok++)\n\t\t\tetoa_xlate[tok] = (char) tok;\n#ifdef HAVE___ETOA_L\n\t\t/* IBM helpfully provides this function.  */\n\t\t__etoa_l(etoa_xlate, sizeof(etoa_xlate));\n#else\n# error \"An EBCDIC-to-ASCII translation function is needed for this system\"\n#endif\n\t\tdo_etoa_init = 0;\n\t}\n\n\ttok = yylex_ebcdic();\n\n\tif (tok >= 0 && tok <= 0xFF)\n\t\ttok = etoa_xlate[tok];\n\n\treturn tok;\n}",
        "lines": 27,
        "depth": 11,
        "decorators": [
          "static",
          "static",
          "int"
        ]
      }
    ],
    "snode": {
      "start_point": [
        6736,
        0
      ],
      "end_point": [
        7015,
        1
      ],
      "content": "static INSTRUCTION *\nsnode(INSTRUCTION *subn, INSTRUCTION *r)\n{\n\tINSTRUCTION *arg;\n\tINSTRUCTION *ip;\n\tNODE *n;\n\tint nexp = 0;\n\tint args_allowed;\n\tint idx = r->builtin_idx;\n\n\tif (subn != NULL) {\n\t\tINSTRUCTION *tp;\n\t\tfor (tp = subn->nexti; tp; tp = tp->nexti) {\n\t\t\ttp = tp->lasti;\n\t\t\tnexp++;\n\t\t}\n\t\tassert(nexp > 0);\n\t}\n\n\t/* check against how many args. are allowed for this builtin */\n\targs_allowed = tokentab[idx].flags & ARGS;\n\tif (args_allowed && (args_allowed & A(nexp)) == 0) {\n\t\tyyerror(_(\"%d is invalid as number of arguments for %s\"),\n\t\t\t\tnexp, tokentab[idx].operator);\n\t\treturn NULL;\n\t}\n\n\t/* special processing for sub, gsub and gensub */\n\n\tif (tokentab[idx].value == Op_sub_builtin) {\n\t\tconst char *operator = tokentab[idx].operator;\n\n\t\tr->sub_flags = 0;\n\n\t\targ = subn->nexti;\t\t/* first arg list */\n\t\t(void) mk_rexp(arg);\n\n\t\tif (strcmp(operator, \"gensub\") != 0) {\n\t\t\t/* sub and gsub */\n\n\t\t\tif (strcmp(operator, \"gsub\") == 0)\n\t\t\t\tr->sub_flags |= GSUB;\n\n\t\t\targ = arg->lasti->nexti;\t/* 2nd arg list */\n\t\t\tif (nexp == 2) {\n\t\t\t\tINSTRUCTION *expr;\n\n\t\t\t\texpr = list_create(instruction(Op_push_i));\n\t\t\t\texpr->nexti->memory = set_profile_text(make_number(0.0), \"0\", 1);\n\t\t\t\t(void) mk_expression_list(subn,\n\t\t\t\t\t\tlist_append(expr, instruction(Op_field_spec)));\n\t\t\t}\n\n\t\t\targ = arg->lasti->nexti; \t/* third arg list */\n\t\t\tip = arg->lasti;\n\t\t\tif (ip->opcode == Op_push_i) {\n\t\t\t\tif (do_lint)\n\t\t\t\t\tlintwarn(_(\"%s: string literal as last arg of substitute has no effect\"),\n\t\t\t\t\t\toperator);\n\t\t\t\tr->sub_flags |=\tLITERAL;\n\t\t\t} else {\n\t\t\t\tif (make_assignable(ip) == NULL)\n\t\t\t\t\tyyerror(_(\"%s third parameter is not a changeable object\"),\n\t\t\t\t\t\toperator);\n\t\t\t\telse\n\t\t\t\t\tip->do_reference = true;\n\t\t\t}\n\n\t\t\tr->expr_count = count_expressions(&subn, false);\n\t\t\tip = subn->lasti;\n\n\t\t\t(void) list_append(subn, r);\n\n\t\t\t/* add after_assign code */\n\t\t\tif (ip->opcode == Op_push_lhs && ip->memory->type == Node_var && ip->memory->var_assign) {\n\t\t\t\t(void) list_append(subn, instruction(Op_var_assign));\n\t\t\t\tsubn->lasti->assign_ctxt = Op_sub_builtin;\n\t\t\t\tsubn->lasti->assign_var = ip->memory->var_assign;\n\t\t\t} else if (ip->opcode == Op_field_spec_lhs) {\n\t\t\t\t(void) list_append(subn, instruction(Op_field_assign));\n\t\t\t\tsubn->lasti->assign_ctxt = Op_sub_builtin;\n\t\t\t\tsubn->lasti->field_assign = (Func_ptr) 0;\n\t\t\t\tip->target_assign = subn->lasti;\n\t\t\t} else if (ip->opcode == Op_subscript_lhs) {\n\t\t\t\t(void) list_append(subn, instruction(Op_subscript_assign));\n\t\t\t\tsubn->lasti->assign_ctxt = Op_sub_builtin;\n\t\t\t}\n\n\t\t\treturn subn;\n\n\t\t} else {\n\t\t\t/* gensub */\n\n\t\t\tr->sub_flags |= GENSUB;\n\t\t\tif (nexp == 3) {\n\t\t\t\tip = instruction(Op_push_i);\n\t\t\t\tip->memory = set_profile_text(make_number(0.0), \"0\", 1);\n\t\t\t\t(void) mk_expression_list(subn,\n\t\t\t\t\t\tlist_append(list_create(ip), instruction(Op_field_spec)));\n\t\t\t}\n\n\t\t\tr->expr_count = count_expressions(&subn, false);\n\t\t\treturn list_append(subn, r);\n\t\t}\n\t}\n\n#ifdef HAVE_MPFR\n\t/* N.B.: If necessary, add special processing for alternate builtin, below */\n\tif (do_mpfr && tokentab[idx].ptr2)\n\t\tr->builtin =  tokentab[idx].ptr2;\n\telse\n#endif\n\t\tr->builtin = tokentab[idx].ptr;\n\n\t/* special case processing for a few builtins */\n\n\tif (r->builtin == do_length) {\n\t\tif (nexp == 0) {\n\t\t    /* no args. Use $0 */\n\n\t\t\tINSTRUCTION *list;\n\t\t\tr->expr_count = 1;\n\t\t\tlist = list_create(r);\n\t\t\t(void) list_prepend(list, instruction(Op_field_spec));\n\t\t\t(void) list_prepend(list, instruction(Op_push_i));\n\t\t\tlist->nexti->memory = set_profile_text(make_number(0.0), \"0\", 1);\n\t\t\treturn list;\n\t\t} else {\n\t\t\targ = subn->nexti;\n\t\t\tif (arg->nexti == arg->lasti && arg->nexti->opcode == Op_push)\n\t\t\t\targ->nexti->opcode = Op_push_arg;\t/* argument may be array */\n \t\t}\n\t} else if (r->builtin == do_isarray || r->builtin == do_typeof) {\n\t\targ = subn->nexti;\n\t\tif (arg->nexti == arg->lasti && arg->nexti->opcode == Op_push)\n\t\t\targ->nexti->opcode = Op_push_arg_untyped;\t/* argument may be untyped */\n#ifdef SUPPLY_INTDIV\n\t} else if (r->builtin == do_intdiv\n#ifdef HAVE_MPFR\n\t\t   || r->builtin == MPF(intdiv)\n#endif\n\t\t\t) {\n\t\targ = subn->nexti->lasti->nexti->lasti->nexti;\t/* 3rd arg list */\n\t\tip = arg->lasti;\n\t\tif (ip->opcode == Op_push)\n\t\t\tip->opcode = Op_push_array;\n#endif /* SUPPLY_INTDIV */\n\t} else if (r->builtin == do_match) {\n\t\tstatic bool warned = false;\n\n\t\targ = subn->nexti->lasti->nexti;\t/* 2nd arg list */\n\t\t(void) mk_rexp(arg);\n\n\t\tif (nexp == 3) {\t/* 3rd argument there */\n\t\t\tif (do_lint && ! warned) {\n\t\t\t\twarned = true;\n\t\t\t\tlintwarn(_(\"match: third argument is a gawk extension\"));\n\t\t\t}\n\t\t\tif (do_traditional) {\n\t\t\t\tyyerror(_(\"match: third argument is a gawk extension\"));\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\targ = arg->lasti->nexti; \t/* third arg list */\n\t\t\tip = arg->lasti;\n\t\t\tif (/*ip == arg->nexti  && */ ip->opcode == Op_push)\n\t\t\t\tip->opcode = Op_push_array;\n\t\t}\n\t} else if (r->builtin == do_split) {\n\t\targ = subn->nexti->lasti->nexti;\t/* 2nd arg list */\n\t\tip = arg->lasti;\n\t\tif (ip->opcode == Op_push)\n\t\t\tip->opcode = Op_push_array;\n\t\tif (nexp == 2) {\n\t\t\tINSTRUCTION *expr;\n\t\t\texpr = list_create(instruction(Op_push));\n\t\t\texpr->nexti->memory = FS_node;\n\t\t\t(void) mk_expression_list(subn, expr);\n\t\t}\n\t\targ = arg->lasti->nexti;\n\t\tn = mk_rexp(arg);\n\t\tif (nexp == 2)\n\t\t\tn->re_flags |= FS_DFLT;\n\t\tif (nexp == 4) {\n\t\t\targ = arg->lasti->nexti;\n\t\t\tip = arg->lasti;\n\t\t\tif (ip->opcode == Op_push)\n\t\t\t\tip->opcode = Op_push_array;\n\t\t}\n\t} else if (r->builtin == do_patsplit) {\n\t\targ = subn->nexti->lasti->nexti;\t/* 2nd arg list */\n\t\tip = arg->lasti;\n\t\tif (ip->opcode == Op_push)\n\t\t\tip->opcode = Op_push_array;\n\t\tif (nexp == 2) {\n\t\t\tINSTRUCTION *expr;\n\t\t\texpr = list_create(instruction(Op_push));\n\t\t\texpr->nexti->memory = FPAT_node;\n\t\t\t(void) mk_expression_list(subn, expr);\n\t\t}\n\t\targ = arg->lasti->nexti;\n\t\tn = mk_rexp(arg);\n\t\tif (nexp == 4) {\n\t\t\targ = arg->lasti->nexti;\n\t\t\tip = arg->lasti;\n\t\t\tif (ip->opcode == Op_push)\n\t\t\t\tip->opcode = Op_push_array;\n\t\t}\n\t} else if (r->builtin == do_close) {\n\t\tstatic bool warned = false;\n\t\tif (nexp == 2) {\n\t\t\tif (do_lint && ! warned) {\n\t\t\t\twarned = true;\n\t\t\t\tlintwarn(_(\"close: second argument is a gawk extension\"));\n\t\t\t}\n\t\t\tif (do_traditional) {\n\t\t\t\tyyerror(_(\"close: second argument is a gawk extension\"));\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t} else if (do_intl\t\t\t\t\t/* --gen-po */\n\t\t\t&& r->builtin == do_dcgettext\t\t/* dcgettext(...) */\n\t\t\t&& subn->nexti->lasti->opcode == Op_push_i\t/* 1st arg is constant */\n\t\t\t&& (subn->nexti->lasti->memory->flags & STRING) != 0) {\t/* it's a string constant */\n\t\t/* ala xgettext, dcgettext(\"some string\" ...) dumps the string */\n\t\tNODE *str = subn->nexti->lasti->memory;\n\n\t\tif ((str->flags & INTLSTR) != 0)\n\t\t\twarning(_(\"use of dcgettext(_\\\"...\\\") is incorrect: remove leading underscore\"));\n\t\t\t/* don't dump it, the lexer already did */\n\t\telse\n\t\t\tdumpintlstr(str->stptr, str->stlen);\n\t} else if (do_intl\t\t\t\t\t/* --gen-po */\n\t\t\t&& r->builtin == do_dcngettext\t\t/* dcngettext(...) */\n\t\t\t&& subn->nexti->lasti->opcode == Op_push_i\t/* 1st arg is constant */\n\t\t\t&& (subn->nexti->lasti->memory->flags & STRING) != 0\t/* it's a string constant */\n\t\t\t&& subn->nexti->lasti->nexti->lasti->opcode == Op_push_i\t/* 2nd arg is constant too */\n\t\t\t&& (subn->nexti->lasti->nexti->lasti->memory->flags & STRING) != 0) {\t/* it's a string constant */\n\t\t/* ala xgettext, dcngettext(\"some string\", \"some plural\" ...) dumps the string */\n\t\tNODE *str1 = subn->nexti->lasti->memory;\n\t\tNODE *str2 = subn->nexti->lasti->nexti->lasti->memory;\n\n\t\tif (((str1->flags | str2->flags) & INTLSTR) != 0)\n\t\t\twarning(_(\"use of dcngettext(_\\\"...\\\") is incorrect: remove leading underscore\"));\n\t\telse\n\t\t\tdumpintlstr2(str1->stptr, str1->stlen, str2->stptr, str2->stlen);\n\t} else if (r->builtin == do_asort || r->builtin == do_asorti) {\n\t\targ = subn->nexti;\t/* 1st arg list */\n\t\tip = arg->lasti;\n\t\tif (ip->opcode == Op_push)\n\t\t\tip->opcode = Op_push_array;\n\t\tif (nexp >= 2) {\n\t\t\targ = ip->nexti;\n\t\t\tip = arg->lasti;\n\t\t\tif (ip->opcode == Op_push)\n\t\t\t\tip->opcode = Op_push_array;\n\t\t}\n\t}\n\telse if (r->builtin == do_index) {\n\t\targ = subn->nexti->lasti->nexti;\t/* 2nd arg list */\n\t\tip = arg->lasti;\n\t\tif (ip->opcode == Op_match_rec)\n\t\t\tfatal(_(\"index: regexp constant as second argument is not allowed\"));\n\t}\n#ifdef ARRAYDEBUG\n\telse if (r->builtin == do_adump) {\n\t\tip = subn->nexti->lasti;\n\t\tif (ip->opcode == Op_push)\n\t\t\tip->opcode = Op_push_array;\n\t}\n#endif\n\n\tif (subn != NULL) {\n\t\tr->expr_count = count_expressions(&subn, false);\n\t\treturn list_append(subn, r);\n\t}\n\n\tr->expr_count = 0;\n\treturn list_create(r);\n}",
      "lines": 280,
      "depth": 22,
      "decorators": [
        "static",
        "static",
        "INSTRUCTION",
        "*\nsnode(INSTRUCTION *subn, INSTRUCTION *r)",
        "*"
      ]
    },
    "parms_shadow": {
      "start_point": [
        7020,
        0
      ],
      "end_point": [
        7059,
        1
      ],
      "content": "static int\nparms_shadow(INSTRUCTION *pc, bool *shadow)\n{\n\tint pcount, i;\n\tbool ret = false;\n\tNODE *func, *fp;\n\tchar *fname;\n\n\tfunc = pc->func_body;\n\tfname = func->vname;\n\tfp = func->fparms;\n\n#if 0\t/* can't happen, already exited if error ? */\n\tif (fname == NULL || func == NULL)\t/* error earlier */\n\t\treturn false;\n#endif\n\n\tpcount = func->param_cnt;\n\n\tif (pcount == 0)\t\t/* no args, no problem */\n\t\treturn 0;\n\n\tsource = pc->source_file;\n\tsourceline = pc->source_line;\n\t/*\n\t * Use warning() and not lintwarn() so that can warn\n\t * about all shadowed parameters.\n\t */\n\tfor (i = 0; i < pcount; i++) {\n\t\tif (lookup(fp[i].param) != NULL) {\n\t\t\twarning(\n\t_(\"function `%s': parameter `%s' shadows global variable\"),\n\t\t\t\t\tfname, fp[i].param);\n\t\t\tret = true;\n\t\t}\n\t}\n\n\t*shadow |= ret;\n\treturn 0;\n}",
      "lines": 40,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "valinfo": {
      "start_point": [
        7063,
        0
      ],
      "end_point": [
        7084,
        1
      ],
      "content": "void\nvalinfo(NODE *n, Func_print print_func, FILE *fp)\n{\n\tif (n == Nnull_string)\n\t\tprint_func(fp, \"uninitialized scalar\\n\");\n\telse if ((n->flags & REGEX) != 0)\n\t\tprint_func(fp, \"@/%.*s/\\n\", n->stlen, n->stptr);\n\telse if ((n->flags & STRING) != 0) {\n\t\tpp_string_fp(print_func, fp, n->stptr, n->stlen, '\"', false);\n\t\tprint_func(fp, \"\\n\");\n\t} else if ((n->flags & NUMBER) != 0) {\n#ifdef HAVE_MPFR\n\t\tif (is_mpg_float(n))\n\t\t\tprint_func(fp, \"%s\\n\", mpg_fmt(\"%.17R*g\", ROUND_MODE, n->mpg_numbr));\n\t\telse if (is_mpg_integer(n))\n\t\t\tprint_func(fp, \"%s\\n\", mpg_fmt(\"%Zd\", n->mpg_i));\n\t\telse\n#endif\n\t\tprint_func(fp, \"%.17g\\n\", n->numbr);\n\t} else\n\t\tprint_func(fp, \"?? flags %s\\n\", flags2str(n->flags));\n}",
      "lines": 22,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "dump_vars": {
      "start_point": [
        7089,
        0
      ],
      "end_point": [
        7110,
        1
      ],
      "content": "void\ndump_vars(const char *fname)\n{\n\tFILE *fp;\n\tNODE **vars;\n\n\tif (fname == NULL)\n\t\tfp = stderr;\n\telse if (strcmp(fname, \"-\") == 0)\n\t\tfp = stdout;\n\telse if ((fp = fopen(fname, \"w\")) == NULL) {\n\t\twarning(_(\"could not open `%s' for writing (%s)\"), fname, strerror(errno));\n\t\twarning(_(\"sending variable list to standard error\"));\n\t\tfp = stderr;\n\t}\n\n\tvars = variable_list();\n\tprint_vars(vars, fprintf, fp);\n\tefree(vars);\n\tif (fp != stdout && fp != stderr && fclose(fp) != 0)\n\t\twarning(_(\"%s: close failed (%s)\"), fname, strerror(errno));\n}",
      "lines": 22,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "dump_funcs": {
      "start_point": [
        7114,
        0
      ],
      "end_point": [
        7121,
        1
      ],
      "content": "void\ndump_funcs()\n{\n\tNODE **funcs;\n\tfuncs = function_list(true);\n\t(void) foreach_func(funcs, (int (*)(INSTRUCTION *, void *)) pp_func, (void *) 0);\n\tefree(funcs);\n}",
      "lines": 8,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "shadow_funcs": {
      "start_point": [
        7126,
        0
      ],
      "end_point": [
        7143,
        1
      ],
      "content": "void\nshadow_funcs()\n{\n\tstatic int calls = 0;\n\tbool shadow = false;\n\tNODE **funcs;\n\n\tif (calls++ != 0)\n\t\tfatal(_(\"shadow_funcs() called twice!\"));\n\n\tfuncs = function_list(true);\n\t(void) foreach_func(funcs, (int (*)(INSTRUCTION *, void *)) parms_shadow, & shadow);\n\tefree(funcs);\n\n\t/* End with fatal if the user requested it.  */\n\tif (shadow && lintfunc == r_fatal)\n\t\tlintwarn(_(\"there were shadowed variables.\"));\n}",
      "lines": 18,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "mk_function": {
      "start_point": [
        7150,
        0
      ],
      "end_point": [
        7205,
        1
      ],
      "content": "static INSTRUCTION *\nmk_function(INSTRUCTION *fi, INSTRUCTION *def)\n{\n\tNODE *thisfunc;\n\n\tthisfunc = fi->func_body;\n\tassert(thisfunc != NULL);\n\n\tif (do_optimize && def->lasti->opcode == Op_pop) {\n\t\t/* tail call which does not return any value. */\n\n\t\tINSTRUCTION *t;\n\n\t\tfor (t = def->nexti; t->nexti != def->lasti; t = t->nexti)\n\t\t\t;\n\t\tif (t->opcode == Op_func_call\n\t\t    && strcmp(t->func_name, thisfunc->vname) == 0)\n\t\t\t(t + 1)->tail_call = true;\n\t}\n\n\t/* add any pre-function comment to start of action for profile.c  */\n\n\tif (function_comment != NULL) {\n\t\tfunction_comment->source_line = 0;\n\t\t(void) list_prepend(def, function_comment);\n\t\tfunction_comment = NULL;\n\t}\n\n\t/* add an implicit return at end;\n\t * also used by 'return' command in debugger\n\t */\n\n\t(void) list_append(def, instruction(Op_push_i));\n\tdef->lasti->memory = dupnode(Nnull_string);\n\t(void) list_append(def, instruction(Op_K_return));\n\n\tif (do_pretty_print)\n\t\t(void) list_prepend(def, instruction(Op_exec_count));\n\n\t/* fi->opcode = Op_func */\n\t(fi + 1)->firsti = def->nexti;\n\t(fi + 1)->lasti = def->lasti;\n\t(fi + 2)->first_line = fi->source_line;\n\t(fi + 2)->last_line = lastline;\n\tfi->nexti = def->nexti;\n\tbcfree(def);\n\n\t(void) list_append(rule_list, fi + 1);\t/* debugging */\n\n\t/* update lint table info */\n\tfunc_use(thisfunc->vname, FUNC_DEFINE);\n\n\t/* remove params from symbol table */\n\tremove_params(thisfunc);\n\treturn fi;\n}",
      "lines": 56,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "INSTRUCTION",
        "*\nmk_function(INSTRUCTION *fi, INSTRUCTION *def)",
        "*"
      ]
    },
    "install_function": {
      "start_point": [
        7213,
        0
      ],
      "end_point": [
        7240,
        1
      ],
      "content": "static int\ninstall_function(char *fname, INSTRUCTION *fi, INSTRUCTION *plist)\n{\n\tNODE *r, *f;\n\tint pcount = 0;\n\n\tr = lookup(fname);\n\tif (r != NULL) {\n\t\terror_ln(fi->source_line, _(\"function name `%s' previously defined\"), fname);\n\t\treturn -1;\n\t}\n\n\tif (plist != NULL)\n\t\tpcount = plist->lasti->param_count + 1;\n\tf = install_symbol(fname, Node_func);\n\tfi->func_body = f;\n\tf->param_cnt = pcount;\n\tf->code_ptr = fi;\n\tf->fparms = NULL;\n\tif (pcount > 0) {\n\t\tchar **pnames;\n\t\tpnames = check_params(fname, pcount, plist);\t/* frees plist */\n\t\tf->fparms = make_params(pnames, pcount);\n\t\tefree(pnames);\n\t\tinstall_params(f);\n\t}\n\treturn 0;\n}",
      "lines": 28,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "check_params": {
      "start_point": [
        7247,
        0
      ],
      "end_point": [
        7289,
        1
      ],
      "content": "static char **\ncheck_params(char *fname, int pcount, INSTRUCTION *list)\n{\n\tINSTRUCTION *p, *np;\n\tint i, j;\n\tchar *name;\n\tchar **pnames;\n\n\tassert(pcount > 0);\n\n\temalloc(pnames, char **, pcount * sizeof(char *), \"check_params\");\n\n\tfor (i = 0, p = list->nexti; p != NULL; i++, p = np) {\n\t\tnp = p->nexti;\n\t\tname = p->lextok;\n\t\tp->lextok = NULL;\n\n\t\tif (strcmp(name, fname) == 0) {\n\t\t\t/* check for function foo(foo) { ... }.  bleah. */\n\t\t\terror_ln(p->source_line,\n\t\t\t\t_(\"function `%s': can't use function name as parameter name\"), fname);\n\t\t} else if (is_std_var(name)) {\n\t\t\terror_ln(p->source_line,\n\t\t\t\t_(\"function `%s': can't use special variable `%s' as a function parameter\"),\n\t\t\t\t\tfname, name);\n\t\t}\n\n\t\t/* check for duplicate parameters */\n\t\tfor (j = 0; j < i; j++) {\n\t\t\tif (strcmp(name, pnames[j]) == 0) {\n\t\t\t\terror_ln(p->source_line,\n\t\t\t\t\t_(\"function `%s': parameter #%d, `%s', duplicates parameter #%d\"),\n\t\t\t\t\tfname, i + 1, name, j + 1);\n\t\t\t}\n\t\t}\n\n\t\tpnames[i] = name;\n\t\tbcfree(p);\n\t}\n\tbcfree(list);\n\n\treturn pnames;\n}",
      "lines": 43,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "char",
        "**\ncheck_params(char *fname, int pcount, INSTRUCTION *list)",
        "*",
        "*\ncheck_params(char *fname, int pcount, INSTRUCTION *list)",
        "*"
      ]
    },
    "func_use": {
      "start_point": [
        7307,
        0
      ],
      "end_point": [
        7337,
        1
      ],
      "content": "static void\nfunc_use(const char *name, enum defref how)\n{\n\tstruct fdesc *fp;\n\tint len;\n\tint ind;\n\n\tlen = strlen(name);\n\tind = hash(name, len, HASHSIZE, NULL);\n\n\tfor (fp = ftable[ind]; fp != NULL; fp = fp->next)\n\t\tif (strcmp(fp->name, name) == 0)\n\t\t\tgoto update_value;\n\n\t/* not in the table, fall through to allocate a new one */\n\n\tezalloc(fp, struct fdesc *, sizeof(struct fdesc), \"func_use\");\n\temalloc(fp->name, char *, len + 1, \"func_use\");\n\tstrcpy(fp->name, name);\n\tfp->next = ftable[ind];\n\tftable[ind] = fp;\n\nupdate_value:\n\tif (how == FUNC_DEFINE)\n\t\tfp->defined++;\n\telse if (how == FUNC_EXT) {\n\t\tfp->defined++;\n\t\tfp->extension++;\n\t} else\n\t\tfp->used++;\n}",
      "lines": 31,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "track_ext_func": {
      "start_point": [
        7341,
        0
      ],
      "end_point": [
        7345,
        1
      ],
      "content": "void\ntrack_ext_func(const char *name)\n{\n\tfunc_use(name, FUNC_EXT);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "check_funcs": {
      "start_point": [
        7349,
        0
      ],
      "end_point": [
        7390,
        1
      ],
      "content": "static void\ncheck_funcs()\n{\n\tstruct fdesc *fp, *next;\n\tint i;\n\n\tif (! in_main_context())\n\t\tgoto free_mem;\n\n\tfor (i = 0; i < HASHSIZE; i++) {\n\t\tfor (fp = ftable[i]; fp != NULL; fp = fp->next) {\n#ifdef REALLYMEAN\n\t\t\t/* making this the default breaks old code. sigh. */\n\t\t\tif (fp->defined == 0 && ! fp->extension) {\n\t\t\t\terror(\n\t\t_(\"function `%s' called but never defined\"), fp->name);\n\t\t\t\terrcount++;\n\t\t\t}\n#else\n\t\t\tif (do_lint && fp->defined == 0 && ! fp->extension)\n\t\t\t\tlintwarn(\n\t\t_(\"function `%s' called but never defined\"), fp->name);\n#endif\n\n\t\t\tif (do_lint && fp->used == 0 && ! fp->extension) {\n\t\t\t\tlintwarn(_(\"function `%s' defined but never called directly\"),\n\t\t\t\t\tfp->name);\n\t\t\t}\n\t\t}\n\t}\n\nfree_mem:\n\t/* now let's free all the memory */\n\tfor (i = 0; i < HASHSIZE; i++) {\n\t\tfor (fp = ftable[i]; fp != NULL; fp = next) {\n\t\t\tnext = fp->next;\n\t\t\tefree(fp->name);\n\t\t\tefree(fp);\n\t\t}\n\t\tftable[i] = NULL;\n\t}\n}",
      "lines": 42,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "param_sanity": {
      "start_point": [
        7394,
        0
      ],
      "end_point": [
        7410,
        1
      ],
      "content": "static void\nparam_sanity(INSTRUCTION *arglist)\n{\n\tINSTRUCTION *argl, *arg;\n\tint i = 1;\n\n\tif (arglist == NULL)\n\t\treturn;\n\tfor (argl = arglist->nexti; argl; ) {\n\t\targ = argl->lasti;\n\t\tif (arg->opcode == Op_match_rec)\n\t\t\twarning_ln(arg->source_line,\n\t\t\t\t_(\"regexp constant for parameter #%d yields boolean value\"), i);\n\t\targl = arg->nexti;\n\t\ti++;\n\t}\n}",
      "lines": 17,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "variable": {
      "start_point": [
        7414,
        0
      ],
      "end_point": [
        7429,
        1
      ],
      "content": "NODE *\nvariable(int location, char *name, NODETYPE type)\n{\n\tNODE *r;\n\n\tif ((r = lookup(name)) != NULL) {\n\t\tif (r->type == Node_func || r->type == Node_ext_func )\n\t\t\terror_ln(location, _(\"function `%s' called with space between name and `(',\\nor used as a variable or an array\"),\n\t\t\t\tr->vname);\n\t} else {\n\t\t/* not found */\n\t\treturn install_symbol(name, type);\n\t}\n\tefree(name);\n\treturn r;\n}",
      "lines": 16,
      "depth": 12,
      "decorators": [
        "NODE",
        "*\nvariable(int location, char *name, NODETYPE type)",
        "*"
      ]
    },
    "make_regnode": {
      "start_point": [
        7433,
        0
      ],
      "end_point": [
        7460,
        1
      ],
      "content": "NODE *\nmake_regnode(int type, NODE *exp)\n{\n\tNODE *n;\n\n\tassert(type == Node_regex || type == Node_dynregex);\n\tgetnode(n);\n\tmemset(n, 0, sizeof(NODE));\n\tn->type = type;\n\tn->re_cnt = 1;\n\n\tif (type == Node_regex) {\n\t\tn->re_reg[0] = make_regexp(exp->stptr, exp->stlen, false, true, false);\n\t\tif (n->re_reg[0] == NULL) {\n\t\t\tfreenode(n);\n\t\t\treturn NULL;\n\t\t}\n\t\tn->re_reg[1] = make_regexp(exp->stptr, exp->stlen, true, true, false);\n\t\tif (n->re_reg[1] == NULL) {\n\t\t\trefree(n->re_reg[0]);\n\t\t\tfreenode(n);\n\t\t\treturn NULL;\n\t\t}\n\t\tn->re_exp = exp;\n\t\tn->re_flags = CONSTANT;\n\t}\n\treturn n;\n}",
      "lines": 28,
      "depth": 12,
      "decorators": [
        "NODE",
        "*\nmake_regnode(int type, NODE *exp)",
        "*"
      ]
    },
    "mk_rexp": {
      "start_point": [
        7465,
        0
      ],
      "end_point": [
        7483,
        1
      ],
      "content": "static NODE *\nmk_rexp(INSTRUCTION *list)\n{\n\tINSTRUCTION *ip;\n\n\tip = list->nexti;\n\tif (ip == list->lasti && ip->opcode == Op_match_rec)\n\t\tip->opcode = Op_push_re;\n\telse if (ip == list->lasti && ip->opcode == Op_push_re)\n\t\t; /* do nothing --- @/.../ */\n\telse {\n\t\tip = instruction(Op_push_re);\n\t\tip->memory = make_regnode(Node_dynregex, NULL);\n\t\tip->nexti = list->lasti->nexti;\n\t\tlist->lasti->nexti = ip;\n\t\tlist->lasti = ip;\n\t}\n\treturn ip->memory;\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "NODE",
        "*\nmk_rexp(INSTRUCTION *list)",
        "*"
      ]
    },
    "isnoeffect": {
      "start_point": [
        7488,
        0
      ],
      "end_point": [
        7527,
        1
      ],
      "content": "static int\nisnoeffect(OPCODE type)\n{\n\tswitch (type) {\n\tcase Op_times:\n\tcase Op_times_i:\n\tcase Op_quotient:\n\tcase Op_quotient_i:\n\tcase Op_mod:\n\tcase Op_mod_i:\n\tcase Op_plus:\n\tcase Op_plus_i:\n\tcase Op_minus:\n\tcase Op_minus_i:\n\tcase Op_subscript:\n\tcase Op_concat:\n\tcase Op_exp:\n\tcase Op_exp_i:\n\tcase Op_unary_minus:\n\tcase Op_field_spec:\n\tcase Op_and_final:\n\tcase Op_or_final:\n\tcase Op_equal:\n\tcase Op_notequal:\n\tcase Op_less:\n\tcase Op_greater:\n\tcase Op_leq:\n\tcase Op_geq:\n\tcase Op_match:\n\tcase Op_nomatch:\n\tcase Op_match_rec:\n\tcase Op_not:\n\tcase Op_in_array:\n\t\treturn true;\n\tdefault:\n\t\tbreak;\t/* keeps gcc -Wall happy */\n\t}\n\n\treturn false;\n}",
      "lines": 40,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "make_assignable": {
      "start_point": [
        7533,
        0
      ],
      "end_point": [
        7550,
        1
      ],
      "content": "static INSTRUCTION *\nmake_assignable(INSTRUCTION *ip)\n{\n\tswitch (ip->opcode) {\n\tcase Op_push:\n\t\tip->opcode = Op_push_lhs;\n\t\treturn ip;\n\tcase Op_field_spec:\n\t\tip->opcode = Op_field_spec_lhs;\n\t\treturn ip;\n\tcase Op_subscript:\n\t\tip->opcode = Op_subscript_lhs;\n\t\treturn ip;\n\tdefault:\n\t\tbreak;\t/* keeps gcc -Wall happy */\n\t}\n\treturn NULL;\n}",
      "lines": 18,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "INSTRUCTION",
        "*\nmake_assignable(INSTRUCTION *ip)",
        "*"
      ]
    },
    "stopme": {
      "start_point": [
        7554,
        0
      ],
      "end_point": [
        7558,
        1
      ],
      "content": "NODE *\nstopme(int nargs ATTRIBUTE_UNUSED)\n{\n\treturn make_number(0.0);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "NODE",
        "*\nstopme(int nargs ATTRIBUTE_UNUSED)",
        "*"
      ]
    },
    "dumpintlstr": {
      "start_point": [
        7562,
        0
      ],
      "end_point": [
        7581,
        1
      ],
      "content": "static void\ndumpintlstr(const char *str, size_t len)\n{\n\tchar *cp;\n\n\t/* See the GNU gettext distribution for details on the file format */\n\n\tif (source != NULL) {\n\t\t/* ala the gettext sources, remove leading `./'s */\n\t\tfor (cp = source; cp[0] == '.' && cp[1] == '/'; cp += 2)\n\t\t\tcontinue;\n\t\tprintf(\"#: %s:%d\\n\", cp, sourceline);\n\t}\n\n\tprintf(\"msgid \");\n\tpp_string_fp(fprintf, stdout, str, len, '\"', true);\n\tputchar('\\n');\n\tprintf(\"msgstr \\\"\\\"\\n\\n\");\n\tfflush(stdout);\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "dumpintlstr2": {
      "start_point": [
        7585,
        0
      ],
      "end_point": [
        7607,
        1
      ],
      "content": "static void\ndumpintlstr2(const char *str1, size_t len1, const char *str2, size_t len2)\n{\n\tchar *cp;\n\n\t/* See the GNU gettext distribution for details on the file format */\n\n\tif (source != NULL) {\n\t\t/* ala the gettext sources, remove leading `./'s */\n\t\tfor (cp = source; cp[0] == '.' && cp[1] == '/'; cp += 2)\n\t\t\tcontinue;\n\t\tprintf(\"#: %s:%d\\n\", cp, sourceline);\n\t}\n\n\tprintf(\"msgid \");\n\tpp_string_fp(fprintf, stdout, str1, len1, '\"', true);\n\tputchar('\\n');\n\tprintf(\"msgid_plural \");\n\tpp_string_fp(fprintf, stdout, str2, len2, '\"', true);\n\tputchar('\\n');\n\tprintf(\"msgstr[0] \\\"\\\"\\nmsgstr[1] \\\"\\\"\\n\\n\");\n\tfflush(stdout);\n}",
      "lines": 23,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mk_binary": {
      "start_point": [
        7611,
        0
      ],
      "end_point": [
        7716,
        1
      ],
      "content": "static INSTRUCTION *\nmk_binary(INSTRUCTION *s1, INSTRUCTION *s2, INSTRUCTION *op)\n{\n\tINSTRUCTION *ip1,*ip2;\n\tAWKNUM res;\n\n\tip2 = s2->nexti;\n\tif (s2->lasti == ip2 && ip2->opcode == Op_push_i) {\n\t/* do any numeric constant folding */\n\t\tip1 = s1->nexti;\n\t\tif (do_optimize\n\t\t\t\t&& ip1 == s1->lasti && ip1->opcode == Op_push_i\n\t\t\t\t&& (ip1->memory->flags & (MPFN|MPZN|STRCUR|STRING)) == 0\n\t\t\t\t&& (ip2->memory->flags & (MPFN|MPZN|STRCUR|STRING)) == 0\n\t\t) {\n\t\t\tNODE *n1 = ip1->memory, *n2 = ip2->memory;\n\t\t\tres = force_number(n1)->numbr;\n\t\t\t(void) force_number(n2);\n\t\t\tswitch (op->opcode) {\n\t\t\tcase Op_times:\n\t\t\t\tres *= n2->numbr;\n\t\t\t\tbreak;\n\t\t\tcase Op_quotient:\n\t\t\t\tif (n2->numbr == 0.0) {\n\t\t\t\t\t/* don't fatalize, allow parsing rest of the input */\n\t\t\t\t\terror_ln(op->source_line, _(\"division by zero attempted\"));\n\t\t\t\t\tgoto regular;\n\t\t\t\t}\n\n\t\t\t\tres /= n2->numbr;\n\t\t\t\tbreak;\n\t\t\tcase Op_mod:\n\t\t\t\tif (n2->numbr == 0.0) {\n\t\t\t\t\t/* don't fatalize, allow parsing rest of the input */\n\t\t\t\t\terror_ln(op->source_line, _(\"division by zero attempted in `%%'\"));\n\t\t\t\t\tgoto regular;\n\t\t\t\t}\n#ifdef HAVE_FMOD\n\t\t\t\tres = fmod(res, n2->numbr);\n#else\t/* ! HAVE_FMOD */\n\t\t\t\t(void) modf(res / n2->numbr, &res);\n\t\t\t\tres = n1->numbr - res * n2->numbr;\n#endif\t/* ! HAVE_FMOD */\n\t\t\t\tbreak;\n\t\t\tcase Op_plus:\n\t\t\t\tres += n2->numbr;\n\t\t\t\tbreak;\n\t\t\tcase Op_minus:\n\t\t\t\tres -= n2->numbr;\n\t\t\t\tbreak;\n\t\t\tcase Op_exp:\n\t\t\t\tres = calc_exp(res, n2->numbr);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgoto regular;\n\t\t\t}\n\n\t\t\top->opcode = Op_push_i;\n\t\t\t// We don't need to call set_profile_text() here since\n\t\t\t// optimizing is disabled when doing pretty printing.\n\t\t\top->memory = make_number(res);\n\t\t\tunref(n1);\n\t\t\tunref(n2);\n\t\t\tbcfree(ip1);\n\t\t\tbcfree(ip2);\n\t\t\tbcfree(s1);\n\t\t\tbcfree(s2);\n\t\t\treturn list_create(op);\n\t\t} else {\n\t\t/* do basic arithmetic optimisation */\n\t\t/* convert (Op_push_i Node_val) + (Op_plus) to (Op_plus_i Node_val) */\n\t\t\tswitch (op->opcode) {\n\t\t\tcase Op_times:\n\t\t\t\top->opcode = Op_times_i;\n\t\t\t\tbreak;\n\t\t\tcase Op_quotient:\n\t\t\t\top->opcode = Op_quotient_i;\n\t\t\t\tbreak;\n\t\t\tcase Op_mod:\n\t\t\t\top->opcode = Op_mod_i;\n\t\t\t\tbreak;\n\t\t\tcase Op_plus:\n\t\t\t\top->opcode = Op_plus_i;\n\t\t\t\tbreak;\n\t\t\tcase Op_minus:\n\t\t\t\top->opcode = Op_minus_i;\n\t\t\t\tbreak;\n\t\t\tcase Op_exp:\n\t\t\t\top->opcode = Op_exp_i;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgoto regular;\n\t\t\t}\n\n\t\t\top->memory = ip2->memory;\n\t\t\tbcfree(ip2);\n\t\t\tbcfree(s2);\t/* Op_list */\n\t\t\treturn list_append(s1, op);\n\t\t}\n\t}\n\nregular:\n\t/* append lists s1, s2 and add `op' bytecode */\n\t(void) list_merge(s1, s2);\n\treturn list_append(s1, op);\n}",
      "lines": 106,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "INSTRUCTION",
        "*\nmk_binary(INSTRUCTION *s1, INSTRUCTION *s2, INSTRUCTION *op)",
        "*"
      ]
    },
    "mk_boolean": {
      "start_point": [
        7720,
        0
      ],
      "end_point": [
        7766,
        1
      ],
      "content": "static INSTRUCTION *\nmk_boolean(INSTRUCTION *left, INSTRUCTION *right, INSTRUCTION *op)\n{\n\tINSTRUCTION *tp;\n\tOPCODE opc, final_opc;\n\n\topc = op->opcode;\t\t/* Op_and or Op_or */\n\tfinal_opc = (opc == Op_or) ? Op_or_final : Op_and_final;\n\n\tadd_lint(right, LINT_assign_in_cond);\n\n\ttp = left->lasti;\n\n\tif (tp->opcode != final_opc) {\t/* x || y */\n\t\tlist_append(right, instruction(final_opc));\n\t\tadd_lint(left, LINT_assign_in_cond);\n\t\t(void) list_append(left, op);\n\t\tleft->lasti->target_jmp = right->lasti;\n\n\t\t/* NB: target_stmt points to previous Op_and(Op_or) in a chain;\n\t\t *     target_stmt only used in the parser (see below).\n\t\t */\n\n\t\tleft->lasti->target_stmt = left->lasti;\n\t\tright->lasti->target_stmt = left->lasti;\n\t} else {\t\t/* optimization for x || y || z || ... */\n\t\tINSTRUCTION *ip;\n\n\t\top->opcode = final_opc;\n\t\t(void) list_append(right, op);\n\t\top->target_stmt = tp;\n\t\ttp->opcode = opc;\n\t\ttp->target_jmp = op;\n\n\t\t/* update jump targets */\n\t\tfor (ip = tp->target_stmt; ; ip = ip->target_stmt) {\n\t\t\tassert(ip->opcode == opc);\n\t\t\tassert(ip->target_jmp == tp);\n\t\t\t/* if (ip->opcode == opc &&  ip->target_jmp == tp) */\n\t\t\tip->target_jmp = op;\n\t\t\tif (ip->target_stmt == ip)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn list_merge(left, right);\n}",
      "lines": 47,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "INSTRUCTION",
        "*\nmk_boolean(INSTRUCTION *left, INSTRUCTION *right, INSTRUCTION *op)",
        "*"
      ]
    },
    "mk_condition": {
      "start_point": [
        7770,
        0
      ],
      "end_point": [
        7835,
        1
      ],
      "content": "static INSTRUCTION *\nmk_condition(INSTRUCTION *cond, INSTRUCTION *ifp, INSTRUCTION *true_branch,\n\t\tINSTRUCTION *elsep, INSTRUCTION *false_branch)\n{\n\t/*\n\t *    ----------------\n\t *       cond\n\t *    ----------------\n\t * t: [Op_jmp_false f ]\n\t *    ----------------\n\t *       true_branch\n\t *\n\t *    ----------------\n\t *    [Op_jmp y]\n\t *    ----------------\n\t * f:\n\t *      false_branch\n\t *    ----------------\n\t * y: [Op_no_op]\n\t *    ----------------\n\t */\n\n\tINSTRUCTION *ip;\n\tbool setup_else_part = true;\n\n\tif (false_branch == NULL) {\n\t\tfalse_branch = list_create(instruction(Op_no_op));\n\t\tif (elsep == NULL) {\t\t/* else { } */\n\t\t\tsetup_else_part = false;\n\t\t}\n\t} else {\n\t\t/* assert(elsep != NULL); */\n\n\t\t/* avoid a series of no_op's: if .. else if .. else if .. */\n\t\tif (false_branch->lasti->opcode != Op_no_op)\n\t\t\t(void) list_append(false_branch, instruction(Op_no_op));\n\t}\n\n\tif (setup_else_part) {\n\t\tif (do_pretty_print) {\n\t\t\t(void) list_prepend(false_branch, elsep);\n\t\t\tfalse_branch->nexti->branch_end = false_branch->lasti;\n\t\t\t(void) list_prepend(false_branch, instruction(Op_exec_count));\n\t\t} else\n\t\t\tbcfree(elsep);\n\t}\n\n\t(void) list_prepend(false_branch, instruction(Op_jmp));\n\tfalse_branch->nexti->target_jmp = false_branch->lasti;\n\n\tadd_lint(cond, LINT_assign_in_cond);\n\tip = list_append(cond, instruction(Op_jmp_false));\n\tip->lasti->target_jmp = false_branch->nexti->nexti;\n\n\tif (do_pretty_print) {\n\t\t(void) list_prepend(ip, ifp);\n\t\t(void) list_append(ip, instruction(Op_exec_count));\n\t\tip->nexti->branch_if = ip->lasti;\n\t\tip->nexti->branch_else = false_branch->nexti;\n\t} else\n\t\tbcfree(ifp);\n\n\tif (true_branch != NULL)\n\t\tlist_merge(ip, true_branch);\n\treturn list_merge(ip, false_branch);\n}",
      "lines": 66,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "INSTRUCTION",
        "*\nmk_condition(INSTRUCTION *cond, INSTRUCTION *ifp, INSTRUCTION *true_branch,\n\t\tINSTRUCTION *elsep, INSTRUCTION *false_branch)",
        "*"
      ]
    },
    "find_line": {
      "start_point": [
        7841,
        0
      ],
      "end_point": [
        7861,
        1
      ],
      "content": "static int\nfind_line(INSTRUCTION *pattern, enum defline what)\n{\n\tINSTRUCTION *ip;\n\tint lineno = 0;\n\n\tfor (ip = pattern->nexti; ip; ip = ip->nexti) {\n\t\tif (what == LAST_LINE) {\n\t\t\tif (ip->source_line > lineno)\n\t\t\t\tlineno = ip->source_line;\n\t\t} else {\t/* FIRST_LINE */\n\t\t\tif (ip->source_line > 0\n\t\t\t\t\t&& (lineno == 0 || ip->source_line < lineno))\n\t\t\t\tlineno = ip->source_line;\n\t\t}\n\t\tif (ip == pattern->lasti)\n\t\t\tbreak;\n\t}\n\tassert(lineno > 0);\n\treturn lineno;\n}",
      "lines": 21,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "append_rule": {
      "start_point": [
        7865,
        0
      ],
      "end_point": [
        7948,
        1
      ],
      "content": "static INSTRUCTION *\nappend_rule(INSTRUCTION *pattern, INSTRUCTION *action)\n{\n\t/*\n\t *    ----------------\n\t *       pattern\n\t *    ----------------\n\t *    [Op_jmp_false f ]\n\t *    ----------------\n\t *       action\n\t *    ----------------\n\t * f: [Op_no_op       ]\n\t *    ----------------\n\t */\n\n\tINSTRUCTION *rp;\n\tINSTRUCTION *tp;\n\tINSTRUCTION *ip;\n\n\tif (rule != Rule) {\n\t\trp = pattern;\n\t\tif (do_pretty_print)\n\t\t\t(void) list_append(action, instruction(Op_no_op));\n\t\t(rp + 1)->firsti = action->nexti;\n\t\t(rp + 1)->lasti = action->lasti;\n\t\t(rp + 2)->first_line = pattern->source_line;\n\t\t(rp + 2)->last_line = lastline;\n\t\tif (block_comment != NULL) {\n\t\t\tip = list_prepend(list_prepend(action, block_comment), rp);\n\t\t\tblock_comment = NULL;\n\t\t} else\n\t\t\tip = list_prepend(action, rp);\n\n\t} else {\n\t\trp = bcalloc(Op_rule, 3, 0);\n\t\trp->in_rule = Rule;\n\t\trp->source_file = source;\n\t\ttp = instruction(Op_no_op);\n\n\t\tif (pattern == NULL) {\n\t\t\t/* assert(action != NULL); */\n\t\t\tif (do_pretty_print)\n\t\t\t\t(void) list_prepend(action, instruction(Op_exec_count));\n\t\t\t(rp + 1)->firsti = action->nexti;\n\t\t\t(rp + 1)->lasti = tp;\n\t\t\t(rp + 2)->first_line = firstline;\n\t\t\t(rp + 2)->last_line = lastline;\n\t\t\trp->source_line = firstline;\n\t\t\tip = list_prepend(list_append(action, tp), rp);\n\t\t} else {\n\t\t\t(void) list_append(pattern, instruction(Op_jmp_false));\n\t\t\tpattern->lasti->target_jmp = tp;\n\t\t\t(rp + 2)->first_line = find_line(pattern, FIRST_LINE);\n\t\t\trp->source_line = (rp + 2)->first_line;\n\t\t\tif (action == NULL) {\n\t\t\t\t(rp + 2)->last_line = find_line(pattern, LAST_LINE);\n\t\t\t\taction = list_create(instruction(Op_K_print_rec));\n\t\t\t\tif (do_pretty_print)\n\t\t\t\t\t(void) list_prepend(action, instruction(Op_exec_count));\n\t\t\t} else\n\t\t\t\t(rp + 2)->last_line = lastline;\n\n\t\t\tif (do_pretty_print) {\n\t\t\t\t(void) list_prepend(pattern, instruction(Op_exec_count));\n\t\t\t\t(void) list_prepend(action, instruction(Op_exec_count));\n\t\t\t}\n \t\t\t(rp + 1)->firsti = action->nexti;\n\t\t\t(rp + 1)->lasti = tp;\n\t\t\tip = list_append(\n\t\t\t\t\tlist_merge(list_prepend(pattern, rp),\n\t\t\t\t\t\taction),\n\t\t\t\t\ttp);\n\t\t}\n\t}\n\n\tlist_append(rule_list, rp + 1);\n\n\tif (rule_block[rule] == NULL)\n\t\trule_block[rule] = ip;\n\telse\n\t\t(void) list_merge(rule_block[rule], ip);\n\n\treturn rule_block[rule];\n}",
      "lines": 84,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "INSTRUCTION",
        "*\nappend_rule(INSTRUCTION *pattern, INSTRUCTION *action)",
        "*"
      ]
    },
    "mk_assignment": {
      "start_point": [
        7952,
        0
      ],
      "end_point": [
        8006,
        1
      ],
      "content": "static INSTRUCTION *\nmk_assignment(INSTRUCTION *lhs, INSTRUCTION *rhs, INSTRUCTION *op)\n{\n\tINSTRUCTION *tp;\n\tINSTRUCTION *ip;\n\n\ttp = lhs->lasti;\n\tswitch (tp->opcode) {\n\tcase Op_field_spec:\n\t\ttp->opcode = Op_field_spec_lhs;\n\t\tbreak;\n\tcase Op_subscript:\n\t\ttp->opcode = Op_subscript_lhs;\n\t\tbreak;\n\tcase Op_push:\n\tcase Op_push_array:\n\t\ttp->opcode = Op_push_lhs;\n\t\tbreak;\n\tcase Op_field_assign:\n\t\tyyerror(_(\"cannot assign a value to the result of a field post-increment expression\"));\n\t\tbreak;\n\tdefault:\n\t\tyyerror(_(\"invalid target of assignment (opcode %s)\"),\n\t\t\t\topcode2str(tp->opcode));\n\t\tbreak;\n\t}\n\n\ttp->do_reference = (op->opcode != Op_assign);\t/* check for uninitialized reference */\n\n\tif (rhs != NULL)\n\t\tip = list_merge(rhs, lhs);\n\telse\n\t\tip = lhs;\n\n\t(void) list_append(ip, op);\n\n\tif (tp->opcode == Op_push_lhs\n\t\t\t&& tp->memory->type == Node_var\n\t\t\t&& tp->memory->var_assign\n\t) {\n\t\ttp->do_reference = false; /* no uninitialized reference checking\n\t\t                           * for a special variable.\n\t\t                           */\n\t\t(void) list_append(ip, instruction(Op_var_assign));\n\t\tip->lasti->assign_var = tp->memory->var_assign;\n\t} else if (tp->opcode == Op_field_spec_lhs) {\n\t\t(void) list_append(ip, instruction(Op_field_assign));\n\t\tip->lasti->field_assign = (Func_ptr) 0;\n\t\ttp->target_assign = ip->lasti;\n\t} else if (tp->opcode == Op_subscript_lhs) {\n\t\t(void) list_append(ip, instruction(Op_subscript_assign));\n\t}\n\n\treturn ip;\n}",
      "lines": 55,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "INSTRUCTION",
        "*\nmk_assignment(INSTRUCTION *lhs, INSTRUCTION *rhs, INSTRUCTION *op)",
        "*"
      ]
    },
    "optimize_assignment": {
      "start_point": [
        8010,
        0
      ],
      "end_point": [
        8163,
        1
      ],
      "content": "static INSTRUCTION *\noptimize_assignment(INSTRUCTION *exp)\n{\n\tINSTRUCTION *i1, *i2, *i3;\n\n\t/*\n\t * Optimize assignment statements array[subs] = x; var = x; $n = x;\n\t * string concatenation of the form s = s t.\n\t *\n\t * 1) Array element assignment array[subs] = x:\n\t *   Replaces Op_push_array + Op_subscript_lhs + Op_assign + Op_pop\n\t *   with single instruction Op_store_sub.\n\t *\t Limitation: 1 dimension and sub is simple var/value.\n\t *\n\t * 2) Simple variable assignment var = x:\n\t *   Replaces Op_push_lhs + Op_assign + Op_pop with Op_store_var.\n\t *\n\t * 3) Field assignment $n = x:\n\t *   Replaces Op_field_spec_lhs + Op_assign + Op_field_assign + Op_pop\n\t *   with Op_store_field.\n\t *\n\t * 4) Optimization for string concatenation:\n\t *   For cases like x = x y, uses realloc to include y in x;\n\t *   also eliminates instructions Op_push_lhs and Op_pop.\n\t */\n\n\t/*\n\t * N.B.: do not append Op_pop instruction to the returned\n\t * instruction list if optimized. None of these\n\t * optimized instructions pushes the r-value of assignment\n\t * onto the runtime stack.\n\t */\n\n\ti2 = NULL;\n\ti1 = exp->lasti;\n\n\tif (   i1->opcode != Op_assign\n\t    && i1->opcode != Op_field_assign)\n\t\treturn list_append(exp, instruction(Op_pop));\n\n\tfor (i2 = exp->nexti; i2 != i1; i2 = i2->nexti) {\n\t\tswitch (i2->opcode) {\n\t\tcase Op_concat:\n\t\t\tif (i2->nexti->opcode == Op_push_lhs    /* l.h.s is a simple variable */\n\t\t\t\t&& (i2->concat_flag & CSVAR) != 0   /* 1st exp in r.h.s is a simple variable;\n\t\t\t\t                                     * see Op_concat in the grammer above.\n\t\t\t\t                                     */\n\t\t\t\t&& i2->nexti->memory == exp->nexti->memory\t /* and the same as in l.h.s */\n\t\t\t\t&& i2->nexti->nexti == i1\n\t\t\t\t&& i1->opcode == Op_assign\n\t\t\t) {\n\t\t\t\t/* s = s ... optimization */\n\n\t\t\t\t/* avoid stuff like x = x (x = y) or x = x gsub(/./, \"b\", x);\n\t\t\t\t * check for l-value reference to this variable in the r.h.s.\n\t\t\t\t * Also, avoid function calls in general to guard against\n\t\t\t\t * global variable assignment.\n\t\t\t\t */\n\n\t\t\t\tfor (i3 = exp->nexti->nexti; i3 != i2; i3 = i3->nexti) {\n\t\t\t\t\tif ((i3->opcode == Op_push_lhs && i3->memory == i2->nexti->memory)\n\t\t\t\t\t\t\t|| i3->opcode == Op_func_call)\n\t\t\t\t\t\treturn list_append(exp, instruction(Op_pop)); /* no optimization */\n\t\t\t\t}\n\n\t\t\t\t/* remove the variable from r.h.s */\n\t\t\t\ti3 = exp->nexti;\n\t\t\t\texp->nexti = i3->nexti;\n\t\t\t\tbcfree(i3);\n\n\t\t\t\tif (--i2->expr_count == 1)\t/* one less expression in Op_concat */\n\t\t\t\t\ti2->opcode = Op_no_op;\n\n\t\t\t\ti3 = i2->nexti;\n\t\t\t\tassert(i3->opcode == Op_push_lhs);\n\t\t\t\ti3->opcode = Op_assign_concat;\t/* change Op_push_lhs to Op_assign_concat */\n\t\t\t\ti3->nexti = NULL;\n\t\t\t\tbcfree(i1);          /* Op_assign */\n\t\t\t\texp->lasti = i3;     /* update Op_list */\n\t\t\t\treturn exp;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase Op_field_spec_lhs:\n\t\t\tif (i2->nexti->opcode == Op_assign\n\t\t\t\t\t&& i2->nexti->nexti == i1\n\t\t\t\t\t&& i1->opcode == Op_field_assign\n\t\t\t) {\n\t\t\t\t/* $n = .. */\n\t\t\t\ti2->opcode = Op_store_field;\n\t\t\t\tbcfree(i2->nexti);  /* Op_assign */\n\t\t\t\ti2->nexti = NULL;\n\t\t\t\tbcfree(i1);          /* Op_field_assign */\n\t\t\t\texp->lasti = i2;    /* update Op_list */\n\t\t\t\treturn exp;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase Op_push_array:\n\t\t\tif (i2->nexti->nexti->opcode == Op_subscript_lhs) {\n\t\t\t\ti3 = i2->nexti->nexti;\n\t\t\t\tif (i3->sub_count == 1\n\t\t\t\t\t\t&& i3->nexti == i1\n\t\t\t\t\t\t&& i1->opcode == Op_assign\n\t\t\t\t) {\n\t\t\t\t\t/* array[sub] = .. */\n\t\t\t\t\ti3->opcode = Op_store_sub;\n\t\t\t\t\ti3->memory = i2->memory;\n\t\t\t\t\ti3->expr_count = 1;  /* sub_count shadows memory,\n                                          * so use expr_count instead.\n\t\t\t\t                          */\n\t\t\t\t\ti3->nexti = NULL;\n\t\t\t\t\ti2->opcode = Op_no_op;\n\t\t\t\t\tbcfree(i1);          /* Op_assign */\n\t\t\t\t\texp->lasti = i3;     /* update Op_list */\n\t\t\t\t\treturn exp;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase Op_push_lhs:\n\t\t\tif (i2->nexti == i1\n\t\t\t\t\t&& i1->opcode == Op_assign\n\t\t\t) {\n\t\t\t\t/* var = .. */\n\t\t\t\ti2->opcode = Op_store_var;\n\t\t\t\ti2->nexti = NULL;\n\t\t\t\tbcfree(i1);          /* Op_assign */\n\t\t\t\texp->lasti = i2;     /* update Op_list */\n\n\t\t\t\ti3 = exp->nexti;\n\t\t\t\tif (i3->opcode == Op_push_i\n\t\t\t\t\t&& (i3->memory->flags & INTLSTR) == 0\n\t\t\t\t\t&& i3->nexti == i2\n\t\t\t\t) {\n\t\t\t\t\t/* constant initializer */\n\t\t\t\t\ti2->initval = i3->memory;\n\t\t\t\t\tbcfree(i3);\n\t\t\t\t\texp->nexti = i2;\n\t\t\t\t} else\n\t\t\t\t\ti2->initval = NULL;\n\n\t\t\t\treturn exp;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* no optimization  */\n\treturn list_append(exp, instruction(Op_pop));\n}",
      "lines": 154,
      "depth": 20,
      "decorators": [
        "static",
        "static",
        "INSTRUCTION",
        "*\noptimize_assignment(INSTRUCTION *exp)",
        "*"
      ]
    },
    "mk_getline": {
      "start_point": [
        8168,
        0
      ],
      "end_point": [
        8228,
        1
      ],
      "content": "static INSTRUCTION *\nmk_getline(INSTRUCTION *op, INSTRUCTION *var, INSTRUCTION *redir, int redirtype)\n{\n\tINSTRUCTION *ip;\n\tINSTRUCTION *tp;\n\tINSTRUCTION *asgn = NULL;\n\n\t/*\n\t *  getline [var] < [file]\n\t *\n\t *  [ file (simp_exp)]\n\t *  [ [ var ] ]\n\t *  [ Op_K_getline_redir|NULL|redir_type|into_var]\n\t *  [ [var_assign] ]\n\t *\n\t */\n\n\tif (redir == NULL) {\n\t\tint sline = op->source_line;\n\t\tbcfree(op);\n\t\top = bcalloc(Op_K_getline, 2, sline);\n\t\t(op + 1)->target_endfile = ip_endfile;\n\t\t(op + 1)->target_beginfile = ip_beginfile;\n\t}\n\n\tif (var != NULL) {\n\t\ttp = make_assignable(var->lasti);\n\t\tassert(tp != NULL);\n\n\t\t/* check if we need after_assign bytecode */\n\t\tif (tp->opcode == Op_push_lhs\n\t\t\t\t&& tp->memory->type == Node_var\n\t\t\t\t&& tp->memory->var_assign\n\t\t) {\n\t\t\tasgn = instruction(Op_var_assign);\n\t\t\tasgn->assign_ctxt = op->opcode;\n\t\t\tasgn->assign_var = tp->memory->var_assign;\n\t\t} else if (tp->opcode == Op_field_spec_lhs) {\n\t\t\tasgn = instruction(Op_field_assign);\n\t\t\tasgn->assign_ctxt = op->opcode;\n\t\t\tasgn->field_assign = (Func_ptr) 0;   /* determined at run time */\n\t\t\ttp->target_assign = asgn;\n\t\t} else if (tp->opcode == Op_subscript_lhs) {\n\t\t\tasgn = instruction(Op_subscript_assign);\n\t\t\tasgn->assign_ctxt = op->opcode;\n\t\t}\n\n\t\tif (redir != NULL) {\n\t\t\tip = list_merge(redir, var);\n\t\t\t(void) list_append(ip, op);\n\t\t} else\n\t\t\tip = list_append(var, op);\n\t} else if (redir != NULL)\n\t\tip = list_append(redir, op);\n\telse\n\t\tip = list_create(op);\n\top->into_var = (var != NULL);\n\top->redir_type = (redir != NULL) ? redirtype : redirect_none;\n\n\treturn (asgn == NULL ? ip : list_append(ip, asgn));\n}",
      "lines": 61,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "INSTRUCTION",
        "*\nmk_getline(INSTRUCTION *op, INSTRUCTION *var, INSTRUCTION *redir, int redirtype)",
        "*"
      ]
    },
    "mk_for_loop": {
      "start_point": [
        8233,
        0
      ],
      "end_point": [
        8306,
        1
      ],
      "content": "static INSTRUCTION *\nmk_for_loop(INSTRUCTION *forp, INSTRUCTION *init, INSTRUCTION *cond,\n\t\t\t\tINSTRUCTION *incr, INSTRUCTION *body)\n{\n\t/*\n\t *   ------------------------\n\t *        init                 (may be NULL)\n\t *   ------------------------\n\t * x:\n\t *        cond                 (Op_no_op if NULL)\n\t *   ------------------------\n\t *    [ Op_jmp_false tb      ]\n\t *   ------------------------\n\t *        body                 (may be NULL)\n\t *   ------------------------\n\t * tc:\n\t *    incr                      (may be NULL)\n\t *    [ Op_jmp x             ]\n\t *   ------------------------\n\t * tb:[ Op_no_op             ]\n\t */\n\n\tINSTRUCTION *ip, *tbreak, *tcont;\n\tINSTRUCTION *jmp;\n\tINSTRUCTION *pp_cond;\n\tINSTRUCTION *ret;\n\n\ttbreak = instruction(Op_no_op);\n\n\tif (cond != NULL) {\n\t\tadd_lint(cond, LINT_assign_in_cond);\n\t\tpp_cond = cond->nexti;\n\t\tip = cond;\n\t\t(void) list_append(ip, instruction(Op_jmp_false));\n\t\tip->lasti->target_jmp = tbreak;\n\t} else {\n\t\tpp_cond = instruction(Op_no_op);\n\t\tip = list_create(pp_cond);\n\t}\n\n\tif (init != NULL)\n\t\tip = list_merge(init, ip);\n\n\tif (do_pretty_print) {\n\t\t(void) list_append(ip, instruction(Op_exec_count));\n\t\t(forp + 1)->forloop_cond = pp_cond;\n\t\t(forp + 1)->forloop_body = ip->lasti;\n\t}\n\n\tif (body != NULL)\n\t\t(void) list_merge(ip, body);\n\n\tjmp = instruction(Op_jmp);\n\tjmp->target_jmp = pp_cond;\n\tif (incr == NULL)\n\t\ttcont = jmp;\n\telse {\n\t\ttcont = incr->nexti;\n\t\t(void) list_merge(ip, incr);\n\t}\n\n\t(void) list_append(ip, jmp);\n\tret = list_append(ip, tbreak);\n\tfix_break_continue(ret, tbreak, tcont);\n\n\tif (do_pretty_print) {\n\t\tforp->target_break = tbreak;\n\t\tforp->target_continue = tcont;\n\t\tret = list_prepend(ret, forp);\n\t} /* else\n\t\t\tforp is NULL */\n\n\treturn ret;\n}",
      "lines": 74,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "INSTRUCTION",
        "*\nmk_for_loop(INSTRUCTION *forp, INSTRUCTION *init, INSTRUCTION *cond,\n\t\t\t\tINSTRUCTION *incr, INSTRUCTION *body)",
        "*"
      ]
    },
    "add_lint": {
      "start_point": [
        8310,
        0
      ],
      "end_point": [
        8362,
        1
      ],
      "content": "static void\nadd_lint(INSTRUCTION *list, LINTTYPE linttype)\n{\n#ifndef NO_LINT\n\tINSTRUCTION *ip;\n\n\tswitch (linttype) {\n\tcase LINT_assign_in_cond:\n\t\tip = list->lasti;\n\t\tif (ip->opcode == Op_var_assign || ip->opcode == Op_field_assign) {\n\t\t\tassert(ip != list->nexti);\n\t\t\tfor (ip = list->nexti; ip->nexti != list->lasti; ip = ip->nexti)\n\t\t\t\t;\n\t\t}\n\n\t\tif (ip->opcode == Op_assign || ip->opcode == Op_assign_concat) {\n\t\t\tlist_append(list, instruction(Op_lint));\n\t\t\tlist->lasti->lint_type = linttype;\n\t\t}\n\t\tbreak;\n\n\tcase LINT_no_effect:\n\t\tif (list->lasti->opcode == Op_pop && list->nexti != list->lasti) {\n\t\t\tint line = 0;\n\n\t\t\t// Get down to the last instruction (FIXME: why?)\n\t\t\tfor (ip = list->nexti; ip->nexti != list->lasti; ip = ip->nexti) {\n\t\t\t\t// along the way track line numbers, we will use the line\n\t\t\t\t// closest to the opcode if that opcode doesn't have one\n\t\t\t\tif (ip->source_line != 0)\n\t\t\t\t\tline = ip->source_line;\n\t\t\t}\n\n\t\t\tif (do_lint) {\t\t/* compile-time warning */\n\t\t\t\tif (isnoeffect(ip->opcode)) {\n\t\t\t\t\tif (ip->source_line != 0)\n\t\t\t\t\t\tline = ip->source_line;\n\t\t\t\t\tlintwarn_ln(line, (\"statement may have no effect\"));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ip->opcode == Op_push) {\t\t/* run-time warning */\n\t\t\t\tlist_append(list, instruction(Op_lint));\n\t\t\t\tlist->lasti->lint_type = linttype;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n#endif\n}",
      "lines": 53,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mk_expression_list": {
      "start_point": [
        8366,
        0
      ],
      "end_point": [
        8401,
        1
      ],
      "content": "static INSTRUCTION *\nmk_expression_list(INSTRUCTION *list, INSTRUCTION *s1)\n{\n\tINSTRUCTION *r;\n\n\t/* we can't just combine all bytecodes, since we need to\n\t * process individual expressions for a few builtins in snode() (-:\n\t */\n\n\t/* -- list of lists     */\n\t/* [Op_list| ... ]------\n\t *                       |\n\t * [Op_list| ... ]   --  |\n\t *  ...               |  |\n\t *  ...       <-------   |\n\t * [Op_list| ... ]   --  |\n\t *  ...               |  |\n\t *  ...               |  |\n\t *  ...       <------- --\n\t */\n\n\tassert(s1 != NULL && s1->opcode == Op_list);\n\tif (list == NULL) {\n\t\tlist = instruction(Op_list);\n\t\tlist->nexti = s1;\n\t\tlist->lasti = s1->lasti;\n\t\treturn list;\n\t}\n\n\t/* append expression to the end of the list */\n\n\tr = list->lasti;\n\tr->nexti = s1;\n\tlist->lasti = s1->lasti;\n\treturn list;\n}",
      "lines": 36,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "INSTRUCTION",
        "*\nmk_expression_list(INSTRUCTION *list, INSTRUCTION *s1)",
        "*"
      ]
    },
    "count_expressions": {
      "start_point": [
        8408,
        0
      ],
      "end_point": [
        8437,
        1
      ],
      "content": "static int\ncount_expressions(INSTRUCTION **list, bool isarg)\n{\n\tINSTRUCTION *expr;\n\tINSTRUCTION *r = NULL;\n\tint count = 0;\n\n\tif (*list == NULL)\t/* error earlier */\n\t\treturn 0;\n\n\tfor (expr = (*list)->nexti; expr; ) {\n\t\tINSTRUCTION *t1, *t2;\n\t\tt1 = expr->nexti;\n\t\tt2 = expr->lasti;\n\t\tif (isarg && t1 == t2 && t1->opcode == Op_push)\n\t\t\tt1->opcode = Op_push_param;\n\t\tif (++count == 1)\n\t\t\tr = expr;\n\t\telse\n\t\t\t(void) list_merge(r, expr);\n\t\texpr = t2->nexti;\n\t}\n\n\tassert(count > 0);\n\tif (! isarg && count > max_args)\n\t\tmax_args = count;\n\tbcfree(*list);\n\t*list = r;\n\treturn count;\n}",
      "lines": 30,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "fix_break_continue": {
      "start_point": [
        8441,
        0
      ],
      "end_point": [
        8465,
        1
      ],
      "content": "static void\nfix_break_continue(INSTRUCTION *list, INSTRUCTION *b_target, INSTRUCTION *c_target)\n{\n\tINSTRUCTION *ip;\n\n\tlist->lasti->nexti = NULL;\t/* just to make sure */\n\n\tfor (ip = list->nexti; ip != NULL; ip = ip->nexti) {\n\t\tswitch (ip->opcode) {\n\t\tcase Op_K_break:\n\t\t\tif (ip->target_jmp == NULL)\n\t\t\t\tip->target_jmp = b_target;\n\t\t\tbreak;\n\n\t\tcase Op_K_continue:\n\t\t\tif (ip->target_jmp == NULL)\n\t\t\t\tip->target_jmp = c_target;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* this is to keep the compiler happy. sheesh. */\n\t\t\tbreak;\n\t\t}\n\t}\n}",
      "lines": 25,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "list_create": {
      "start_point": [
        8467,
        0
      ],
      "end_point": [
        8476,
        1
      ],
      "content": "static inline INSTRUCTION *\nlist_create(INSTRUCTION *x)\n{\n\tINSTRUCTION *l;\n\n\tl = instruction(Op_list);\n\tl->nexti = x;\n\tl->lasti = x;\n\treturn l;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "INSTRUCTION",
        "*\nlist_create(INSTRUCTION *x)",
        "*"
      ]
    },
    "list_append": {
      "start_point": [
        8478,
        0
      ],
      "end_point": [
        8488,
        1
      ],
      "content": "static inline INSTRUCTION *\nlist_append(INSTRUCTION *l, INSTRUCTION *x)\n{\n#ifdef GAWKDEBUG\n\tif (l->opcode != Op_list)\n\t\tcant_happen();\n#endif\n\tl->lasti->nexti = x;\n\tl->lasti = x;\n\treturn l;\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "INSTRUCTION",
        "*\nlist_append(INSTRUCTION *l, INSTRUCTION *x)",
        "*"
      ]
    },
    "list_prepend": {
      "start_point": [
        8490,
        0
      ],
      "end_point": [
        8500,
        1
      ],
      "content": "static inline INSTRUCTION *\nlist_prepend(INSTRUCTION *l, INSTRUCTION *x)\n{\n#ifdef GAWKDEBUG\n\tif (l->opcode != Op_list)\n\t\tcant_happen();\n#endif\n\tx->nexti = l->nexti;\n\tl->nexti = x;\n\treturn l;\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "INSTRUCTION",
        "*\nlist_prepend(INSTRUCTION *l, INSTRUCTION *x)",
        "*"
      ]
    },
    "list_merge": {
      "start_point": [
        8502,
        0
      ],
      "end_point": [
        8515,
        1
      ],
      "content": "static inline INSTRUCTION *\nlist_merge(INSTRUCTION *l1, INSTRUCTION *l2)\n{\n#ifdef GAWKDEBUG\n\tif (l1->opcode != Op_list)\n\t\tcant_happen();\n\tif (l2->opcode != Op_list)\n\t\tcant_happen();\n#endif\n\tl1->lasti->nexti = l2->nexti;\n\tl1->lasti = l2->lasti;\n\tbcfree(l2);\n\treturn l1;\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "INSTRUCTION",
        "*\nlist_merge(INSTRUCTION *l1, INSTRUCTION *l2)",
        "*"
      ]
    },
    "add_pending_comment": {
      "start_point": [
        8519,
        0
      ],
      "end_point": [
        8535,
        1
      ],
      "content": "static inline INSTRUCTION *\nadd_pending_comment(INSTRUCTION *stmt)\n{\n\tINSTRUCTION *ret = stmt;\n\n\tif (prior_comment != NULL) {\n\t\tif (function_comment != prior_comment)\n\t\t\tret = list_append(stmt, prior_comment);\n\t\tprior_comment = NULL;\n\t} else if (comment != NULL && comment->memory->comment_type == EOL_COMMENT) {\n\t\tif (function_comment != comment)\n\t\t\tret = list_append(stmt, comment);\n\t\tcomment = NULL;\n\t}\n\n\treturn ret;\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "INSTRUCTION",
        "*\nadd_pending_comment(INSTRUCTION *stmt)",
        "*"
      ]
    },
    "check_special": {
      "start_point": [
        8539,
        0
      ],
      "end_point": [
        8580,
        1
      ],
      "content": "int\ncheck_special(const char *name)\n{\n\tint low, high, mid;\n\tint i;\n\tint non_standard_flags = 0;\n#ifdef USE_EBCDIC\n\tstatic bool did_sort = false;\n\n\tif (! did_sort) {\n\t\tqsort((void *) tokentab,\n\t\t\t\tsizeof(tokentab) / sizeof(tokentab[0]),\n\t\t\t\tsizeof(tokentab[0]), tokcompare);\n\t\tdid_sort = true;\n\t}\n#endif\n\n\tif (do_traditional)\n\t\tnon_standard_flags |= GAWKX;\n\tif (do_posix)\n\t\tnon_standard_flags |= NOT_POSIX;\n\n\tlow = 0;\n\thigh = (sizeof(tokentab) / sizeof(tokentab[0])) - 1;\n\twhile (low <= high) {\n\t\tmid = (low + high) / 2;\n\t\ti = *name - tokentab[mid].operator[0];\n\t\tif (i == 0)\n\t\t\ti = strcmp(name, tokentab[mid].operator);\n\n\t\tif (i < 0)\t\t/* token < mid */\n\t\t\thigh = mid - 1;\n\t\telse if (i > 0)\t\t/* token > mid */\n\t\t\tlow = mid + 1;\n\t\telse {\n\t\t\tif ((tokentab[mid].flags & non_standard_flags) != 0)\n\t\t\t\treturn -1;\n\t\t\treturn mid;\n\t\t}\n\t}\n\treturn -1;\n}",
      "lines": 42,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "read_one_line": {
      "start_point": [
        8592,
        0
      ],
      "end_point": [
        8611,
        1
      ],
      "content": "static ssize_t\nread_one_line(int fd, void *buffer, size_t count)\n{\n\tchar buf[BUFSIZ];\n\n\t/* Minor potential memory leak here. Too bad. */\n\tif (fp == NULL) {\n\t\tfp = fdopen(fd, \"r\");\n\t\tif (fp == NULL) {\n\t\t\tfprintf(stderr, \"ugh. fdopen: %s\\n\", strerror(errno));\n\t\t\tgawk_exit(EXIT_FAILURE);\n\t\t}\n\t}\n\n\tif (fgets(buf, sizeof buf, fp) == NULL)\n\t\treturn 0;\n\n\tmemcpy(buffer, buf, strlen(buf));\n\treturn strlen(buf);\n}",
      "lines": 20,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "ssize_t"
      ]
    },
    "one_line_close": {
      "start_point": [
        8615,
        0
      ],
      "end_point": [
        8626,
        1
      ],
      "content": "static int\none_line_close(int fd)\n{\n\tint ret;\n\n\tif (fp == NULL || fd != fileno(fp))\n\t\tfatal(\"debugging read/close screwed up!\");\n\n\tret = fclose(fp);\n\tfp = NULL;\n\treturn ret;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "lookup_builtin": {
      "start_point": [
        8631,
        0
      ],
      "end_point": [
        8657,
        1
      ],
      "content": "builtin_func_t\nlookup_builtin(const char *name)\n{\n\tint mid = check_special(name);\n\n\tif (mid == -1)\n\t\treturn NULL;\n\n\tswitch (tokentab[mid].class) {\n\tcase LEX_BUILTIN:\n\tcase LEX_LENGTH:\n\t\tbreak;\n\tdefault:\n\t\treturn NULL;\n\t}\n\n\t/* And another special case... */\n\tif (tokentab[mid].value == Op_sub_builtin)\n\t\treturn (builtin_func_t) do_sub;\n\n#ifdef HAVE_MPFR\n\tif (do_mpfr)\n\t\treturn tokentab[mid].ptr2;\n#endif\n\n\treturn tokentab[mid].ptr;\n}",
      "lines": 27,
      "depth": 8,
      "decorators": [
        "builtin_func_t"
      ]
    },
    "install_builtins": {
      "start_point": [
        8661,
        0
      ],
      "end_point": [
        8682,
        1
      ],
      "content": "void\ninstall_builtins(void)\n{\n\tint i, j;\n\tint flags_that_must_be_clear = DEBUG_USE;\n\n\tif (do_traditional)\n\t\tflags_that_must_be_clear |= GAWKX;\n\n\tif (do_posix)\n\t\tflags_that_must_be_clear |= NOT_POSIX;\n\n\n\tj = sizeof(tokentab) / sizeof(tokentab[0]);\n\tfor (i = 0; i < j; i++) {\n\t\tif (   (tokentab[i].class == LEX_BUILTIN\n\t\t        || tokentab[i].class == LEX_LENGTH)\n\t\t    && (tokentab[i].flags & flags_that_must_be_clear) == 0) {\n\t\t\t(void) install_symbol(tokentab[i].operator, Node_builtin_func);\n\t\t}\n\t}\n}",
      "lines": 22,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "is_alpha": {
      "start_point": [
        8702,
        0
      ],
      "end_point": [
        8723,
        1
      ],
      "content": "bool\nis_alpha(int c)\n{\n#ifdef I_DONT_KNOW_WHAT_IM_DOING\n\treturn isalpha(c);\n#else /* ! I_DONT_KNOW_WHAT_IM_DOING */\n\tswitch (c) {\n\tcase 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n\tcase 'g': case 'h': case 'i': case 'j': case 'k': case 'l':\n\tcase 'm': case 'n': case 'o': case 'p': case 'q': case 'r':\n\tcase 's': case 't': case 'u': case 'v': case 'w': case 'x':\n\tcase 'y': case 'z':\n\tcase 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n\tcase 'G': case 'H': case 'I': case 'J': case 'K': case 'L':\n\tcase 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':\n\tcase 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n\tcase 'Y': case 'Z':\n\t\treturn true;\n\t}\n\treturn false;\n#endif /* ! I_DONT_KNOW_WHAT_IM_DOING */\n}",
      "lines": 22,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    },
    "is_alnum": {
      "start_point": [
        8727,
        0
      ],
      "end_point": [
        8732,
        1
      ],
      "content": "bool\nis_alnum(int c)\n{\n\t/* digit test is good for EBCDIC too. so there. */\n\treturn (is_alpha(c) || ('0' <= c && c <= '9'));\n}",
      "lines": 6,
      "depth": 10,
      "decorators": [
        "bool"
      ]
    },
    "is_letter": {
      "start_point": [
        8741,
        0
      ],
      "end_point": [
        8745,
        1
      ],
      "content": "bool\nis_letter(int c)\n{\n\treturn (is_alpha(c) || c == '_');\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "bool"
      ]
    },
    "is_identchar": {
      "start_point": [
        8749,
        0
      ],
      "end_point": [
        8753,
        1
      ],
      "content": "bool\nis_identchar(int c)\n{\n\treturn (is_alnum(c) || c == '_');\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "bool"
      ]
    },
    "set_profile_text": {
      "start_point": [
        8757,
        0
      ],
      "end_point": [
        8779,
        1
      ],
      "content": "static NODE *\nset_profile_text(NODE *n, const char *str, size_t len)\n{\n\tif (do_pretty_print) {\n\t\t// two extra bytes: one for NUL termination, and another in\n\t\t// case we need to add a leading minus sign in add_sign_to_num\n\t\temalloc(n->stptr, char *, len + 2, \"set_profile_text\");\n\t\tmemcpy(n->stptr, str, len);\n\t\tn->stptr[len] = '\\0';\n\t\tn->stlen = len;\n\t\t// Set STRCUR and n->stfmt for use when profiling\n\t\t// (i.e., actually running the program) so that\n\t\t// force_string() on this item will work ok.\n\t\t// Thanks and a tip of the hatlo to valgrind.\n\t\tn->flags |= (NUMCONSTSTR|STRCUR);\n\t\tn->stfmt = STFMT_UNUSED;\n#ifdef HAVE_MPFR\n\t\tn->strndmode = MPFR_round_mode;\n#endif\n\t}\n\n\treturn n;\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "NODE",
        "*\nset_profile_text(NODE *n, const char *str, size_t len)",
        "*"
      ]
    }
  },
  "gawk/gawk-4.2.1/awkgram.y": {
    "YNUMBER": [
      {
        "start_point": [
          221,
          3
        ],
        "end_point": [
          225,
          4
        ],
        "content": "program nls\n\t| program LEX_EOF\n\t  {\n\t\tnext_sourcefile();\n\t  }",
        "lines": 5,
        "depth": 6,
        "decorators": null
      },
      {
        "start_point": [
          226,
          3
        ],
        "end_point": [
          234,
          4
        ],
        "content": "program error\n\t  {\n\t\trule = 0;\n\t\t/*\n\t\t * If errors, give up, don't produce an infinite\n\t\t * stream of syntax error messages.\n\t\t */\n  \t\t/* yyerrok; */\n\t  }",
        "lines": 9,
        "depth": 5,
        "decorators": null
      },
      {
        "start_point": [
          243,
          3
        ],
        "end_point": [
          253,
          4
        ],
        "content": "pattern statement_term\n\t  {\n\t\tif (rule != Rule) {\n\t\t\tmsg(_(\"%s blocks must have an action part\"), ruletab[rule]);\n\t\t\terrcount++;\n\t\t} else if ($1 == NULL) {\n\t\t\tmsg(_(\"each rule must have a pattern or an action part\"));\n\t\t\terrcount++;\n\t\t} else\t\t/* pattern rule with non-empty pattern */\n\t\t\t(void) append_rule($1, NULL);\n\t  }",
        "lines": 11,
        "depth": 12,
        "decorators": null
      },
      {
        "start_point": [
          254,
          3
        ],
        "end_point": [
          260,
          4
        ],
        "content": "function_prologue action\n\t  {\n\t\tin_function = NULL;\n\t\t(void) mk_function($1, $2);\n\t\twant_param_names = DONT_CHECK;\n\t\tyyerrok;\n\t  }",
        "lines": 7,
        "depth": 8,
        "decorators": null
      },
      {
        "start_point": [
          261,
          7
        ],
        "end_point": [
          266,
          4
        ],
        "content": "LEX_INCLUDE source statement_term\n\t  {\n\t\twant_source = false;\n\t\tat_seen = false;\n\t\tyyerrok;\n\t  }",
        "lines": 6,
        "depth": 5,
        "decorators": null
      },
      {
        "start_point": [
          267,
          7
        ],
        "end_point": [
          272,
          4
        ],
        "content": "LEX_LOAD library statement_term\n\t  {\n\t\twant_source = false;\n\t\tat_seen = false;\n\t\tyyerrok;\n\t  }",
        "lines": 6,
        "depth": 5,
        "decorators": null
      },
      {
        "start_point": [
          284,
          3
        ],
        "end_point": [
          285,
          17
        ],
        "content": "FILENAME error\n\t  { $$ = NULL; }",
        "lines": 2,
        "depth": 4,
        "decorators": null
      },
      {
        "start_point": [
          299,
          3
        ],
        "end_point": [
          300,
          17
        ],
        "content": "FILENAME error\n\t  { $$ = NULL; }",
        "lines": 2,
        "depth": 4,
        "decorators": null
      }
    ],
    "r_brace": [
      {
        "start_point": [
          402,
          30
        ],
        "end_point": [
          410,
          4
        ],
        "content": "opt_semi opt_nls\n\t  {\n\t\tINSTRUCTION *ip;\n\t\tif ($2 == NULL)\n\t\t\tip = list_create(instruction(Op_no_op));\n\t\telse\n\t\t\tip = $2;\n\t\t$$ = ip;\n\t  }",
        "lines": 9,
        "depth": 10,
        "decorators": null
      },
      {
        "start_point": [
          437,
          66
        ],
        "end_point": [
          474,
          4
        ],
        "content": "opt_param_list r_paren opt_nls\n\t  {\n\t\t/*\n\t\t *  treat any comments between BOF and the first function\n\t\t *  definition (with no intervening BEGIN etc block) as\n\t\t *  program comments.  Special kludge: iff there are more\n\t\t *  than one such comments, treat the last as a function\n\t\t *  comment.\n\t\t */\n\t\tif (prior_comment != NULL) {\n\t\t\tcomment_to_save = prior_comment;\n\t\t\tprior_comment = NULL;\n\t\t} else if (comment != NULL) {\n\t\t\tcomment_to_save = comment;\n\t\t\tcomment = NULL;\n\t\t} else\n\t\t\tcomment_to_save = NULL;\n\n\t\tif (comment_to_save != NULL && func_first\n\t\t    && strstr(comment_to_save->memory->stptr, \"\\n\\n\") != NULL)\n\t\t\tsplit_comment();\n\n\t\t/* save any other pre-function comment as function comment  */\n\t\tif (comment_to_save != NULL) {\n\t\t\tfunction_comment = comment_to_save;\n\t\t\tcomment_to_save = NULL;\n\t\t}\n\t\tfunc_first = false;\n\t\t$1->source_file = source;\n\t\tif (install_function($2->lextok, $1, $5) < 0)\n\t\t\tYYABORT;\n\t\tin_function = $2->lextok;\n\t\t$2->lextok = NULL;\n\t\tbcfree($2);\n\t\t/* $5 already free'd in install_function */\n\t\t$$ = $1;\n\t\twant_param_names = FUNC_BODY;\n\t  }",
        "lines": 38,
        "depth": 11,
        "decorators": null
      },
      {
        "start_point": [
          548,
          3
        ],
        "end_point": [
          594,
          4
        ],
        "content": "statements statement\n\t  {\n\t\tif ($2 == NULL) {\n\t\t\tif (prior_comment != NULL) {\n\t\t\t\t$$ = list_append($1, prior_comment);\n\t\t\t\tprior_comment = NULL;\n\t\t\t\tif (comment != NULL) {\n\t\t\t\t\t$$ = list_append($$, comment);\n\t\t\t\t\tcomment = NULL;\n\t\t\t\t}\n\t\t\t} else if (comment != NULL) {\n\t\t\t\t$$ = list_append($1, comment);\n\t\t\t\tcomment = NULL;\n\t\t\t} else\n\t\t\t\t$$ = $1;\n\t\t} else {\n\t\t\tadd_lint($2, LINT_no_effect);\n\t\t\tif ($1 == NULL) {\n\t\t\t\tif (prior_comment != NULL) {\n\t\t\t\t\t$$ = list_append($2, prior_comment);\n\t\t\t\t\tprior_comment = NULL;\n\t\t\t\t\tif (comment != NULL) {\n\t\t\t\t\t\t$$ = list_append($$, comment);\n\t\t\t\t\t\tcomment = NULL;\n\t\t\t\t\t}\n\t\t\t\t} else if (comment != NULL) {\n\t\t\t\t\t$$ = list_append($2, comment);\n\t\t\t\t\tcomment = NULL;\n\t\t\t\t} else\n\t\t\t\t\t$$ = $2;\n\t\t\t} else {\n\t\t\t\tif (prior_comment != NULL) {\n\t\t\t\t\tlist_append($2, prior_comment);\n\t\t\t\t\tprior_comment = NULL;\n\t\t\t\t\tif (comment != NULL) {\n\t\t\t\t\t\tlist_append($2, comment);\n\t\t\t\t\t\tcomment = NULL;\n\t\t\t\t\t}\n\t\t\t\t} else if (comment != NULL) {\n\t\t\t\t\tlist_append($2, comment);\n\t\t\t\t\tcomment = NULL;\n\t\t\t\t}\n\t\t\t\t$$ = list_merge($1, $2);\n\t\t\t}\n\t\t}\n\t\tyyerrok;\n\t  }",
        "lines": 47,
        "depth": 13,
        "decorators": null
      },
      {
        "start_point": [
          595,
          3
        ],
        "end_point": [
          596,
          17
        ],
        "content": "statements error\n\t  {\t$$ = NULL; }",
        "lines": 2,
        "depth": 4,
        "decorators": null
      }
    ],
    "l_brace": {
      "start_point": [
        616,
        46
      ],
      "end_point": [
        705,
        4
      ],
      "content": "case_statements opt_nls r_brace\n\t  {\n\t\tINSTRUCTION *dflt, *curr = NULL, *cexp, *cstmt;\n\t\tINSTRUCTION *ip, *nextc, *tbreak;\n\t\tconst char **case_values = NULL;\n\t\tint maxcount = 128;\n\t\tint case_count = 0;\n\t\tint i;\n\n\t\ttbreak = instruction(Op_no_op);\n\t\tcstmt = list_create(tbreak);\n\t\tcexp = list_create(instruction(Op_pop));\n\t\tdflt = instruction(Op_jmp);\n\t\tdflt->target_jmp = tbreak;\t/* if no case match and no explicit default */\n\n\t\tif ($7 != NULL) {\n\t\t\tcurr = $7->nexti;\n\t\t\tbcfree($7);\t/* Op_list */\n\t\t} /*  else\n\t\t\t\tcurr = NULL; */\n\n\t\tfor (; curr != NULL; curr = nextc) {\n\t\t\tINSTRUCTION *caseexp = curr->case_exp;\n\t\t\tINSTRUCTION *casestmt = curr->case_stmt;\n\n\t\t\tnextc = curr->nexti;\n\t\t\tif (curr->opcode == Op_K_case) {\n\t\t\t\tif (caseexp->opcode == Op_push_i) {\n\t\t\t\t\t/* a constant scalar */\n\t\t\t\t\tchar *caseval;\n\t\t\t\t\tcaseval = force_string(caseexp->memory)->stptr;\n\t\t\t\t\tfor (i = 0; i < case_count; i++) {\n\t\t\t\t\t\tif (strcmp(caseval, case_values[i]) == 0)\n\t\t\t\t\t\t\terror_ln(curr->source_line,\n\t\t\t\t\t\t\t\t_(\"duplicate case values in switch body: %s\"), caseval);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (case_values == NULL)\n\t\t\t\t\t\temalloc(case_values, const char **, sizeof(char *) * maxcount, \"statement\");\n\t\t\t\t\telse if (case_count >= maxcount) {\n\t\t\t\t\t\tmaxcount += 128;\n\t\t\t\t\t\terealloc(case_values, const char **, sizeof(char*) * maxcount, \"statement\");\n\t\t\t\t\t}\n\t\t\t\t\tcase_values[case_count++] = caseval;\n\t\t\t\t} else {\n\t\t\t\t\t/* match a constant regex against switch expression. */\n\t\t\t\t\t(curr + 1)->match_exp = true;\n\t\t\t\t}\n\t\t\t\tcurr->stmt_start = casestmt->nexti;\n\t\t\t\tcurr->stmt_end\t= casestmt->lasti;\n\t\t\t\t(void) list_prepend(cexp, curr);\n\t\t\t\t(void) list_prepend(cexp, caseexp);\n\t\t\t} else {\n\t\t\t\tif (dflt->target_jmp != tbreak)\n\t\t\t\t\terror_ln(curr->source_line,\n\t\t\t\t\t\t_(\"duplicate `default' detected in switch body\"));\n\t\t\t\telse\n\t\t\t\t\tdflt->target_jmp = casestmt->nexti;\n\n\t\t\t\tif (do_pretty_print) {\n\t\t\t\t\tcurr->stmt_start = casestmt->nexti;\n\t\t\t\t\tcurr->stmt_end = casestmt->lasti;\n\t\t\t\t\t(void) list_prepend(cexp, curr);\n\t\t\t\t} else\n\t\t\t\t\tbcfree(curr);\n\t\t\t}\n\n\t\t\tcstmt = list_merge(casestmt, cstmt);\n\t\t}\n\n\t\tif (case_values != NULL)\n\t\t\tefree(case_values);\n\n\t\tip = $3;\n\t\tif (do_pretty_print) {\n\t\t\t(void) list_prepend(ip, $1);\n\t\t\t(void) list_prepend(ip, instruction(Op_exec_count));\n\t\t\t$1->target_break = tbreak;\n\t\t\t($1 + 1)->switch_start = cexp->nexti;\n\t\t\t($1 + 1)->switch_end = cexp->lasti;\n\t\t}/* else\n\t\t\t\t$1 is NULL */\n\n\t\t(void) list_append(cexp, dflt);\n\t\t(void) list_merge(ip, cexp);\n\t\t$$ = list_merge(ip, cstmt);\n\n\t\tbreak_allowed--;\n\t\tfix_break_continue(ip, tbreak, NULL);\n\t  }",
      "lines": 90,
      "depth": 19,
      "decorators": null
    },
    "r_paren": [
      {
        "start_point": [
          706,
          29
        ],
        "end_point": [
          747,
          4
        ],
        "content": "opt_nls statement\n\t  {\n\t\t/*\n\t\t *    -----------------\n\t\t * tc:\n\t\t *         cond\n\t\t *    -----------------\n\t\t *    [Op_jmp_false tb   ]\n\t\t *    -----------------\n\t\t *         body\n\t\t *    -----------------\n\t\t *    [Op_jmp      tc    ]\n\t\t * tb:[Op_no_op          ]\n\t\t */\n\n\t\tINSTRUCTION *ip, *tbreak, *tcont;\n\n\t\ttbreak = instruction(Op_no_op);\n\t\tadd_lint($3, LINT_assign_in_cond);\n\t\ttcont = $3->nexti;\n\t\tip = list_append($3, instruction(Op_jmp_false));\n\t\tip->lasti->target_jmp = tbreak;\n\n\t\tif (do_pretty_print) {\n\t\t\t(void) list_append(ip, instruction(Op_exec_count));\n\t\t\t$1->target_break = tbreak;\n\t\t\t$1->target_continue = tcont;\n\t\t\t($1 + 1)->while_body = ip->lasti;\n\t\t\t(void) list_prepend(ip, $1);\n\t\t}/* else\n\t\t\t\t$1 is NULL */\n\n\t\tif ($6 != NULL)\n\t\t\t(void) list_merge(ip, $6);\n\t\t(void) list_append(ip, instruction(Op_jmp));\n\t\tip->lasti->target_jmp = tcont;\n\t\t$$ = list_append(ip, tbreak);\n\n\t\tbreak_allowed--;\n\t\tcontinue_allowed--;\n\t\tfix_break_continue(ip, tbreak, tcont);\n\t  }",
        "lines": 42,
        "depth": 11,
        "decorators": null
      },
      {
        "start_point": [
          790,
          51
        ],
        "end_point": [
          902,
          4
        ],
        "content": "opt_nls statement\n\t  {\n\t\tINSTRUCTION *ip;\n\t\tchar *var_name = $3->lextok;\n\n\t\tif ($8 != NULL\n\t\t\t\t&& $8->lasti->opcode == Op_K_delete\n\t\t\t\t&& $8->lasti->expr_count == 1\n\t\t\t\t&& $8->nexti->opcode == Op_push\n\t\t\t\t&& ($8->nexti->memory->type != Node_var || !($8->nexti->memory->var_update))\n\t\t\t\t&& strcmp($8->nexti->memory->vname, var_name) == 0\n\t\t) {\n\n\t\t/* Efficiency hack.  Recognize the special case of\n\t\t *\n\t\t * \tfor (iggy in foo)\n\t\t * \t\tdelete foo[iggy]\n\t\t *\n\t\t * and treat it as if it were\n\t\t *\n\t\t * \tdelete foo\n\t\t *\n\t\t * Check that the body is a `delete a[i]' statement,\n\t\t * and that both the loop var and array names match.\n\t\t */\n\t\t\tNODE *arr = NULL;\n\n\t\t\tip = $8->nexti->nexti;\n\t\t\tif ($5->nexti->opcode == Op_push && $5->lasti == $5->nexti)\n\t\t\t\tarr = $5->nexti->memory;\n\t\t\tif (arr != NULL\n\t\t\t\t\t&& ip->opcode == Op_no_op\n\t\t\t\t\t&& ip->nexti->opcode == Op_push_array\n\t\t\t\t\t&& strcmp(ip->nexti->memory->vname, arr->vname) == 0\n\t\t\t\t\t&& ip->nexti->nexti == $8->lasti\n\t\t\t) {\n\t\t\t\t(void) make_assignable($8->nexti);\n\t\t\t\t$8->lasti->opcode = Op_K_delete_loop;\n\t\t\t\t$8->lasti->expr_count = 0;\n\t\t\t\tif ($1 != NULL)\n\t\t\t\t\tbcfree($1);\n\t\t\t\tefree(var_name);\n\t\t\t\tbcfree($3);\n\t\t\t\tbcfree($4);\n\t\t\t\tbcfree($5);\n\t\t\t\t$$ = $8;\n\t\t\t} else\n\t\t\t\tgoto regular_loop;\n\t\t} else {\n\t\t\tINSTRUCTION *tbreak, *tcont;\n\n\t\t\t/*    [ Op_push_array a       ]\n\t\t\t *    [ Op_arrayfor_init | ib ]\n\t\t\t * ic:[ Op_arrayfor_incr | ib ]\n\t\t\t *    [ Op_var_assign if any  ]\n\t\t\t *\n\t\t\t *              body\n\t\t\t *\n\t\t\t *    [Op_jmp | ic            ]\n\t\t\t * ib:[Op_arrayfor_final      ]\n\t\t\t */\nregular_loop:\n\t\t\tip = $5;\n\t\t\tip->nexti->opcode = Op_push_array;\n\n\t\t\ttbreak = instruction(Op_arrayfor_final);\n\t\t\t$4->opcode = Op_arrayfor_incr;\n\t\t\t$4->array_var = variable($3->source_line, var_name, Node_var);\n\t\t\t$4->target_jmp = tbreak;\n\t\t\ttcont = $4;\n\t\t\t$3->opcode = Op_arrayfor_init;\n\t\t\t$3->target_jmp = tbreak;\n\t\t\t(void) list_append(ip, $3);\n\n\t\t\tif (do_pretty_print) {\n\t\t\t\t$1->opcode = Op_K_arrayfor;\n\t\t\t\t$1->target_continue = tcont;\n\t\t\t\t$1->target_break = tbreak;\n\t\t\t\t(void) list_append(ip, $1);\n\t\t\t} /* else\n\t\t\t\t\t$1 is NULL */\n\n\t\t\t/* add update_FOO instruction if necessary */\n\t\t\tif ($4->array_var->type == Node_var && $4->array_var->var_update) {\n\t\t\t\t(void) list_append(ip, instruction(Op_var_update));\n\t\t\t\tip->lasti->update_var = $4->array_var->var_update;\n\t\t\t}\n\t\t\t(void) list_append(ip, $4);\n\n\t\t\t/* add set_FOO instruction if necessary */\n\t\t\tif ($4->array_var->type == Node_var && $4->array_var->var_assign) {\n\t\t\t\t(void) list_append(ip, instruction(Op_var_assign));\n\t\t\t\tip->lasti->assign_var = $4->array_var->var_assign;\n\t\t\t}\n\n\t\t\tif (do_pretty_print) {\n\t\t\t\t(void) list_append(ip, instruction(Op_exec_count));\n\t\t\t\t($1 + 1)->forloop_cond = $4;\n\t\t\t\t($1 + 1)->forloop_body = ip->lasti;\n\t\t\t}\n\n\t\t\tif ($8 != NULL)\n\t\t\t\t(void) list_merge(ip, $8);\n\n\t\t\t(void) list_append(ip, instruction(Op_jmp));\n\t\t\tip->lasti->target_jmp = $4;\n\t\t\t$$ = list_append(ip, tbreak);\n\t\t\tfix_break_continue(ip, tbreak, tcont);\n\t\t}\n\n\t\tbreak_allowed--;\n\t\tcontinue_allowed--;\n\t  }",
        "lines": 113,
        "depth": 15,
        "decorators": null
      },
      {
        "start_point": [
          903,
          85
        ],
        "end_point": [
          909,
          4
        ],
        "content": "opt_nls statement\n\t  {\n\t\t$$ = mk_for_loop($1, $3, $6, $9, $12);\n\n\t\tbreak_allowed--;\n\t\tcontinue_allowed--;\n\t  }",
        "lines": 7,
        "depth": 9,
        "decorators": null
      },
      {
        "start_point": [
          1314,
          26
        ],
        "end_point": [
          1317,
          4
        ],
        "content": "opt_nls statement\n\t  {\n\t\t$$ = mk_condition($3, $1, $6, NULL, NULL);\n\t  }",
        "lines": 4,
        "depth": 8,
        "decorators": null
      },
      {
        "start_point": [
          1658,
          31
        ],
        "end_point": [
          1677,
          4
        ],
        "content": "LEX_IN simple_variable\n\t  {\n\t\tif (do_lint_old) {\n\t\t    warning_ln($4->source_line,\n\t\t\t\t_(\"old awk does not support the keyword `in' except after `for'\"));\n\t\t    warning_ln($4->source_line,\n\t\t\t\t_(\"old awk does not support multidimensional arrays\"));\n\t\t}\n\t\t$5->nexti->opcode = Op_push_array;\n\t\t$4->opcode = Op_in_array;\n\t\tif ($2 == NULL) {\t/* error */\n\t\t\terrcount++;\n\t\t\t$4->expr_count = 0;\n\t\t\t$$ = list_merge($5, $4);\n\t\t} else {\n\t\t\tINSTRUCTION *t = $2;\n\t\t\t$4->expr_count = count_expressions(&t, false);\n\t\t\t$$ = list_append(list_merge(t, $5), $4);\n\t\t}\n\t  }",
        "lines": 20,
        "depth": 11,
        "decorators": null
      },
      {
        "start_point": [
          1683,
          14
        ],
        "end_point": [
          1687,
          3
        ],
        "content": "IO_IN LEX_GETLINE opt_variable\n\t\t{\n\t\t  $$ = mk_getline($3, $4, $1, $2->redir_type);\n\t\t  bcfree($2);\n\t\t}",
        "lines": 5,
        "depth": 8,
        "decorators": null
      },
      {
        "start_point": [
          1740,
          7
        ],
        "end_point": [
          1746,
          4
        ],
        "content": "exp r_paren\n\t  {\n\t\tif (do_pretty_print)\n\t\t\t$$ = list_append($2, bcalloc(Op_parens, 1, sourceline));\n\t\telse\n\t\t\t$$ = $2;\n\t  }",
        "lines": 7,
        "depth": 9,
        "decorators": null
      },
      {
        "start_point": [
          1747,
          19
        ],
        "end_point": [
          1752,
          4
        ],
        "content": "opt_fcall_expression_list r_paren\n\t  {\n\t\t$$ = snode($3, $1);\n\t\tif ($$ == NULL)\n\t\t\tYYABORT;\n\t  }",
        "lines": 6,
        "depth": 6,
        "decorators": null
      },
      {
        "start_point": [
          1753,
          18
        ],
        "end_point": [
          1758,
          4
        ],
        "content": "opt_fcall_expression_list r_paren\n\t  {\n\t\t$$ = snode($3, $1);\n\t\tif ($$ == NULL)\n\t\t\tYYABORT;\n\t  }",
        "lines": 6,
        "depth": 6,
        "decorators": null
      },
      {
        "start_point": [
          1779,
          3
        ],
        "end_point": [
          1783,
          4
        ],
        "content": "DECREMENT variable\n\t  {\n\t\t$1->opcode = Op_predecrement;\n\t\t$$ = mk_assignment($2, NULL, $1);\n\t  }",
        "lines": 5,
        "depth": 7,
        "decorators": null
      },
      {
        "start_point": [
          1870,
          17
        ],
        "end_point": [
          1894,
          4
        ],
        "content": "opt_fcall_expression_list r_paren\n\t  {\n\t\tNODE *n;\n\n\t\tif (! at_seen) {\n\t\t\tn = lookup($1->func_name);\n\t\t\tif (n != NULL && n->type != Node_func\n\t\t\t    && n->type != Node_ext_func) {\n\t\t\t\terror_ln($1->source_line,\n\t\t\t\t\t_(\"attempt to use non-function `%s' in function call\"),\n\t\t\t\t\t\t$1->func_name);\n\t\t\t}\n\t\t}\n\t\tparam_sanity($3);\n\t\t$1->opcode = Op_func_call;\n\t\t$1->func_body = NULL;\n\t\tif ($3 == NULL) {\t/* no argument or error */\n\t\t\t($1 + 1)->expr_count = 0;\n\t\t\t$$ = list_create($1);\n\t\t} else {\n\t\t\tINSTRUCTION *t = $3;\n\t\t\t($1 + 1)->expr_count = count_expressions(&t, true);\n\t\t\t$$ = list_append(t, $1);\n\t\t}\n\t  }",
        "lines": 25,
        "depth": 13,
        "decorators": null
      },
      {
        "start_point": [
          1907,
          3
        ],
        "end_point": [
          1908,
          15
        ],
        "content": "delete_subscript SUBSCRIPT\n\t  { $$ = $1; }",
        "lines": 2,
        "depth": 4,
        "decorators": null
      },
      {
        "start_point": [
          1914,
          3
        ],
        "end_point": [
          1917,
          4
        ],
        "content": "delete_subscript delete_exp_list\n\t  {\n\t\t$$ = list_merge($1, $2);\n\t  }",
        "lines": 4,
        "depth": 6,
        "decorators": null
      },
      {
        "start_point": [
          1957,
          3
        ],
        "end_point": [
          1960,
          4
        ],
        "content": "subscript bracketed_exp_list\n\t  {\n\t\t$$ = list_merge($1, $2);\n\t  }",
        "lines": 4,
        "depth": 6,
        "decorators": null
      },
      {
        "start_point": [
          1977,
          3
        ],
        "end_point": [
          1983,
          4
        ],
        "content": "NAME subscript_list\n\t  {\n\t\tchar *arr = $1->lextok;\n\t\t$1->memory = variable($1->source_line, arr, Node_var_new);\n\t\t$1->opcode = Op_push_array;\n\t\t$$ = list_prepend($2, $1);\n\t  }",
        "lines": 7,
        "depth": 8,
        "decorators": null
      },
      {
        "start_point": [
          1999,
          7
        ],
        "end_point": [
          2004,
          4
        ],
        "content": "non_post_simp_exp opt_incdec\n\t  {\n\t\t$$ = list_append($2, $1);\n\t\tif ($3 != NULL)\n\t\t\tmk_assignment($2, NULL, $3);\n\t  }",
        "lines": 6,
        "depth": 8,
        "decorators": null
      }
    ],
    "LEX_WHILE": {
      "start_point": [
        748,
        42
      ],
      "end_point": [
        789,
        4
      ],
      "content": "exp r_paren opt_nls\n\t  {\n\t\t/*\n\t\t *    -----------------\n\t\t * z:\n\t\t *         body\n\t\t *    -----------------\n\t\t * tc:\n\t\t *         cond\n\t\t *    -----------------\n\t\t *    [Op_jmp_true | z  ]\n\t\t * tb:[Op_no_op         ]\n\t\t */\n\n\t\tINSTRUCTION *ip, *tbreak, *tcont;\n\n\t\ttbreak = instruction(Op_no_op);\n\t\ttcont = $6->nexti;\n\t\tadd_lint($6, LINT_assign_in_cond);\n\t\tif ($3 != NULL)\n\t\t\tip = list_merge($3, $6);\n\t\telse\n\t\t\tip = list_prepend($6, instruction(Op_no_op));\n\t\tif (do_pretty_print)\n\t\t\t(void) list_prepend(ip, instruction(Op_exec_count));\n\t\t(void) list_append(ip, instruction(Op_jmp_true));\n\t\tip->lasti->target_jmp = ip->nexti;\n\t\t$$ = list_append(ip, tbreak);\n\n\t\tbreak_allowed--;\n\t\tcontinue_allowed--;\n\t\tfix_break_continue(ip, tbreak, tcont);\n\n\t\tif (do_pretty_print) {\n\t\t\t$1->target_break = tbreak;\n\t\t\t$1->target_continue = tcont;\n\t\t\t($1 + 1)->doloop_cond = tcont;\n\t\t\t$$ = list_prepend(ip, $1);\n\t\t\tbcfree($4);\n\t\t} /* else\n\t\t\t$1 and $4 are NULLs */\n\t  }",
      "lines": 42,
      "depth": 10,
      "decorators": null
    },
    "opt_simple_stmt": [
      {
        "start_point": [
          910,
          73
        ],
        "end_point": [
          916,
          4
        ],
        "content": "r_paren opt_nls statement\n\t  {\n\t\t$$ = mk_for_loop($1, $3, (INSTRUCTION *) NULL, $8, $11);\n\n\t\tbreak_allowed--;\n\t\tcontinue_allowed--;\n\t  }",
        "lines": 7,
        "depth": 10,
        "decorators": null
      },
      {
        "start_point": [
          938,
          3
        ],
        "end_point": [
          947,
          4
        ],
        "content": "LEX_CONTINUE statement_term\n\t  {\n\t\tif (! continue_allowed)\n\t\t\terror_ln($1->source_line,\n\t\t\t\t_(\"`continue' is not allowed outside a loop\"));\n\t\t$1->target_jmp = NULL;\n\t\t$$ = list_create($1);\n\t\t$$ = add_pending_comment($$);\n\n\t  }",
        "lines": 10,
        "depth": 10,
        "decorators": null
      },
      {
        "start_point": [
          948,
          3
        ],
        "end_point": [
          957,
          4
        ],
        "content": "LEX_NEXT statement_term\n\t  {\n\t\t/* if inside function (rule = 0), resolve context at run-time */\n\t\tif (rule && rule != Rule)\n\t\t\terror_ln($1->source_line,\n\t\t\t\t_(\"`next' used in %s action\"), ruletab[rule]);\n\t\t$1->target_jmp = ip_rec;\n\t\t$$ = list_create($1);\n\t\t$$ = add_pending_comment($$);\n\t  }",
        "lines": 10,
        "depth": 10,
        "decorators": null
      },
      {
        "start_point": [
          958,
          3
        ],
        "end_point": [
          969,
          4
        ],
        "content": "LEX_NEXTFILE statement_term\n\t  {\n\t\t/* if inside function (rule = 0), resolve context at run-time */\n\t\tif (rule == BEGIN || rule == END || rule == ENDFILE)\n\t\t\terror_ln($1->source_line,\n\t\t\t\t_(\"`nextfile' used in %s action\"), ruletab[rule]);\n\n\t\t$1->target_newfile = ip_newfile;\n\t\t$1->target_endfile = ip_endfile;\n\t\t$$ = list_create($1);\n\t\t$$ = add_pending_comment($$);\n\t  }",
        "lines": 12,
        "depth": 10,
        "decorators": null
      },
      {
        "start_point": [
          970,
          3
        ],
        "end_point": [
          985,
          4
        ],
        "content": "LEX_EXIT opt_exp statement_term\n\t  {\n\t\t/* Initialize the two possible jump targets, the actual target\n\t\t * is resolved at run-time.\n\t\t */\n\t\t$1->target_end = ip_end;\t/* first instruction in end_block */\n\t\t$1->target_atexit = ip_atexit;\t/* cleanup and go home */\n\n\t\tif ($2 == NULL) {\n\t\t\t$$ = list_create($1);\n\t\t\t(void) list_prepend($$, instruction(Op_push_i));\n\t\t\t$$->nexti->memory = dupnode(Nnull_string);\n\t\t} else\n\t\t\t$$ = list_append($2, $1);\n\t\t$$ = add_pending_comment($$);\n\t  }",
        "lines": 16,
        "depth": 11,
        "decorators": null
      },
      {
        "start_point": [
          990,
          5
        ],
        "end_point": [
          1010,
          4
        ],
        "content": "opt_exp statement_term {\n\t\tif ($3 == NULL) {\n\t\t\t$$ = list_create($1);\n\t\t\t(void) list_prepend($$, instruction(Op_push_i));\n\t\t\t$$->nexti->memory = dupnode(Nnull_string);\n\t\t} else {\n\t\t\tif (do_optimize\n\t\t\t\t&& $3->lasti->opcode == Op_func_call\n\t\t\t\t&& strcmp($3->lasti->func_name, in_function) == 0\n\t\t\t) {\n\t\t\t\t/* Do tail recursion optimization. Tail\n\t\t\t\t * call without a return value is recognized\n\t\t\t\t * in mk_function().\n\t\t\t\t */\n\t\t\t\t($3->lasti + 1)->tail_call = true;\n\t\t\t}\n\n\t\t\t$$ = list_append($3, $1);\n\t\t}\n\t\t$$ = add_pending_comment($$);\n\t  }",
        "lines": 21,
        "depth": 13,
        "decorators": null
      }
    ],
    "statement_term": [
      {
        "start_point": [
          1023,
          45
        ],
        "end_point": [
          1120,
          4
        ],
        "content": "print_expression_list output_redir\n\t  {\n\t\t/*\n\t\t * Optimization: plain `print' has no expression list, so $3 is null.\n\t\t * If $3 is NULL or is a bytecode list for $0 use Op_K_print_rec,\n\t\t * which is faster for these two cases.\n\t\t */\n\n\t\tif ($1->opcode == Op_K_print &&\n\t\t\t($3 == NULL\n\t\t\t\t|| ($3->lasti->opcode == Op_field_spec\n\t\t\t\t\t&& $3->nexti->nexti->nexti == $3->lasti\n\t\t\t\t\t&& $3->nexti->nexti->opcode == Op_push_i\n\t\t\t\t\t&& $3->nexti->nexti->memory->type == Node_val)\n\t\t\t)\n\t\t) {\n\t\t\tstatic bool warned = false;\n\t\t\t/*   -----------------\n\t\t\t *      output_redir\n\t\t\t *    [ redirect exp ]\n\t\t\t *   -----------------\n\t\t\t *     expression_list\n\t\t\t *   ------------------\n\t\t\t *    [Op_K_print_rec | NULL | redir_type | expr_count]\n\t\t\t */\n\n\t\t\tif ($3 != NULL) {\n\t\t\t\tNODE *n = $3->nexti->nexti->memory;\n\n\t\t\t\tif (! iszero(n))\n\t\t\t\t\tgoto regular_print;\n\n\t\t\t\tbcfree($3->lasti);\t\t\t/* Op_field_spec */\n\t\t\t\tunref(n);\t\t\t\t/* Node_val */\n\t\t\t\tbcfree($3->nexti->nexti);\t\t/* Op_push_i */\n\t\t\t\tbcfree($3->nexti);\t\t\t/* Op_list */\n\t\t\t\tbcfree($3);\t\t\t\t/* Op_list */\n\t\t\t} else {\n\t\t\t\tif (do_lint && (rule == BEGIN || rule == END) && ! warned) {\n\t\t\t\t\twarned = true;\n\t\t\t\t\tlintwarn_ln($1->source_line,\n\t\t_(\"plain `print' in BEGIN or END rule should probably be `print \\\"\\\"'\"));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$1->expr_count = 0;\n\t\t\t$1->opcode = Op_K_print_rec;\n\t\t\tif ($4 == NULL) {    /* no redircetion */\n\t\t\t\t$1->redir_type = redirect_none;\n\t\t\t\t$$ = list_create($1);\n\t\t\t} else {\n\t\t\t\tINSTRUCTION *ip;\n\t\t\t\tip = $4->nexti;\n\t\t\t\t$1->redir_type = ip->redir_type;\n\t\t\t\t$4->nexti = ip->nexti;\n\t\t\t\tbcfree(ip);\n\t\t\t\t$$ = list_append($4, $1);\n\t\t\t}\n\t\t} else {\n\t\t\t/*   -----------------\n\t\t\t *    [ output_redir    ]\n\t\t\t *    [ redirect exp    ]\n\t\t\t *   -----------------\n\t\t\t *    [ expression_list ]\n\t\t\t *   ------------------\n\t\t\t *    [$1 | NULL | redir_type | expr_count]\n\t\t\t *\n\t\t\t */\nregular_print:\n\t\t\tif ($4 == NULL) {\t\t/* no redirection */\n\t\t\t\tif ($3 == NULL)\t{\t/* printf without arg */\n\t\t\t\t\t$1->expr_count = 0;\n\t\t\t\t\t$1->redir_type = redirect_none;\n\t\t\t\t\t$$ = list_create($1);\n\t\t\t\t} else {\n\t\t\t\t\tINSTRUCTION *t = $3;\n\t\t\t\t\t$1->expr_count = count_expressions(&t, false);\n\t\t\t\t\t$1->redir_type = redirect_none;\n\t\t\t\t\t$$ = list_append(t, $1);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tINSTRUCTION *ip;\n\t\t\t\tip = $4->nexti;\n\t\t\t\t$1->redir_type = ip->redir_type;\n\t\t\t\t$4->nexti = ip->nexti;\n\t\t\t\tbcfree(ip);\n\t\t\t\tif ($3 == NULL) {\n\t\t\t\t\t$1->expr_count = 0;\n\t\t\t\t\t$$ = list_append($4, $1);\n\t\t\t\t} else {\n\t\t\t\t\tINSTRUCTION *t = $3;\n\t\t\t\t\t$1->expr_count = count_expressions(&t, false);\n\t\t\t\t\t$$ = list_append(list_merge($4, t), $1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t$$ = add_pending_comment($$);\n\t  }",
        "lines": 98,
        "depth": 16,
        "decorators": null
      },
      {
        "start_point": [
          1122,
          3
        ],
        "end_point": [
          1122,
          39
        ],
        "content": "LEX_DELETE NAME { sub_counter = 0; }",
        "lines": 1,
        "depth": 5,
        "decorators": null
      },
      {
        "start_point": [
          1204,
          3
        ],
        "end_point": [
          1210,
          4
        ],
        "content": "case_statements case_statement\n\t  {\n\t\tif ($1 == NULL)\n\t\t\t$$ = list_create($2);\n\t\telse\n\t\t\t$$ = list_prepend($1, $2);\n\t  }",
        "lines": 7,
        "depth": 8,
        "decorators": null
      },
      {
        "start_point": [
          1211,
          3
        ],
        "end_point": [
          1212,
          17
        ],
        "content": "case_statements error\n\t  { $$ = NULL; }",
        "lines": 2,
        "depth": 4,
        "decorators": null
      }
    ],
    "colon": [
      {
        "start_point": [
          1216,
          29
        ],
        "end_point": [
          1227,
          4
        ],
        "content": "opt_nls statements\n\t  {\n\t\tINSTRUCTION *casestmt = $5;\n\t\tif ($5 == NULL)\n\t\t\tcasestmt = list_create(instruction(Op_no_op));\n\t\tif (do_pretty_print)\n\t\t\t(void) list_prepend(casestmt, instruction(Op_exec_count));\n\t\t$1->case_exp = $2;\n\t\t$1->case_stmt = casestmt;\n\t\tbcfree($3);\n\t\t$$ = $1;\n\t  }",
        "lines": 12,
        "depth": 10,
        "decorators": null
      },
      {
        "start_point": [
          1228,
          21
        ],
        "end_point": [
          1238,
          4
        ],
        "content": "opt_nls statements\n\t  {\n\t\tINSTRUCTION *casestmt = $4;\n\t\tif ($4 == NULL)\n\t\t\tcasestmt = list_create(instruction(Op_no_op));\n\t\tif (do_pretty_print)\n\t\t\t(void) list_prepend(casestmt, instruction(Op_exec_count));\n\t\tbcfree($2);\n\t\t$1->case_stmt = casestmt;\n\t\t$$ = $1;\n\t  }",
        "lines": 11,
        "depth": 10,
        "decorators": null
      },
      {
        "start_point": [
          1290,
          7
        ],
        "end_point": [
          1293,
          4
        ],
        "content": "expression_list r_paren\n\t  {\n\t\t$$ = $2;\n\t  }",
        "lines": 4,
        "depth": 4,
        "decorators": null
      }
    ],
    "statement": [
      {
        "start_point": [
          1319,
          6
        ],
        "end_point": [
          1322,
          4
        ],
        "content": "LEX_ELSE opt_nls statement\n\t  {\n\t\t$$ = mk_condition($3, $1, $6, $7, $9);\n\t  }",
        "lines": 4,
        "depth": 9,
        "decorators": null
      },
      {
        "start_point": [
          1358,
          3
        ],
        "end_point": [
          1366,
          4
        ],
        "content": "param_list comma NAME\n\t  {\n\t\tif ($1 != NULL && $3 != NULL) {\n\t\t\t$3->param_count =  $1->lasti->param_count + 1;\n\t\t\t$$ = list_append($1, $3);\n\t\t\tyyerrok;\n\t\t} else\n\t\t\t$$ = NULL;\n\t  }",
        "lines": 9,
        "depth": 10,
        "decorators": null
      },
      {
        "start_point": [
          1369,
          3
        ],
        "end_point": [
          1370,
          15
        ],
        "content": "param_list error\n\t  { $$ = $1; }",
        "lines": 2,
        "depth": 4,
        "decorators": null
      }
    ],
    "comma": [
      {
        "start_point": [
          1400,
          3
        ],
        "end_point": [
          1407,
          4
        ],
        "content": "expression_list error\n\t  {\n\t\t/*\n\t\t * Returning the expression list instead of NULL lets\n\t\t * snode get a list of arguments that it can count.\n\t\t */\n\t\t$$ = $1;\n\t  }",
        "lines": 8,
        "depth": 4,
        "decorators": null
      },
      {
        "start_point": [
          1430,
          3
        ],
        "end_point": [
          1434,
          4
        ],
        "content": "fcall_expression_list comma fcall_exp\n\t  {\n\t\t$$ = mk_expression_list($1, $3);\n\t\tyyerrok;\n\t  }",
        "lines": 5,
        "depth": 6,
        "decorators": null
      },
      {
        "start_point": [
          1437,
          3
        ],
        "end_point": [
          1444,
          4
        ],
        "content": "fcall_expression_list error\n\t  {\n\t\t/*\n\t\t * Returning the expression list instead of NULL lets\n\t\t * snode get a list of arguments that it can count.\n\t\t */\n\t\t$$ = $1;\n\t  }",
        "lines": 8,
        "depth": 4,
        "decorators": null
      },
      {
        "start_point": [
          1445,
          3
        ],
        "end_point": [
          1449,
          4
        ],
        "content": "fcall_expression_list error fcall_exp\n\t  {\n\t\t/* Ditto */\n\t\t$$ = mk_expression_list($1, $3);\n\t  }",
        "lines": 5,
        "depth": 6,
        "decorators": null
      },
      {
        "start_point": [
          1464,
          12
        ],
        "end_point": [
          1470,
          4
        ],
        "content": "assign_operator exp %prec ASSIGNOP\n\t  {\n\t\tif (do_lint && $3->lasti->opcode == Op_match_rec)\n\t\t\tlintwarn_ln($2->source_line,\n\t\t\t\t_(\"regular expression on right of assignment\"));\n\t\t$$ = mk_assignment($1, $3, $2);\n\t  }",
        "lines": 7,
        "depth": 10,
        "decorators": null
      }
    ],
    "LEX_OR": [
      {
        "start_point": [
          1479,
          3
        ],
        "end_point": [
          1491,
          4
        ],
        "content": "exp MATCHOP typed_regexp\n\t  {\n\t\tif ($1->lasti->opcode == Op_match_rec)\n\t\t\twarning_ln($2->source_line,\n\t\t\t\t_(\"regular expression on left of `~' or `!~' operator\"));\n\n\t\tassert($3->opcode == Op_push_re\n\t\t\t&& ($3->memory->flags & REGEX) != 0);\n\t\t/* RHS is @/.../ */\n\t\t$2->memory = $3->memory;\n\t\tbcfree($3);\n\t\t$$ = list_append($1, $2);\n\t  }",
        "lines": 13,
        "depth": 10,
        "decorators": null
      },
      {
        "start_point": [
          1492,
          3
        ],
        "end_point": [
          1508,
          4
        ],
        "content": "exp MATCHOP exp\n\t  {\n\t\tif ($1->lasti->opcode == Op_match_rec)\n\t\t\twarning_ln($2->source_line,\n\t\t\t\t_(\"regular expression on left of `~' or `!~' operator\"));\n\n\t\tif ($3->lasti == $3->nexti && $3->nexti->opcode == Op_match_rec) {\n\t\t\t/* RHS is /.../ */\n\t\t\t$2->memory = $3->nexti->memory;\n\t\t\tbcfree($3->nexti);\t/* Op_match_rec */\n\t\t\tbcfree($3);\t\t\t/* Op_list */\n\t\t\t$$ = list_append($1, $2);\n\t\t} else {\n\t\t\t$2->memory = make_regnode(Node_dynregex, NULL);\n\t\t\t$$ = list_append(list_merge($1, $3), $2);\n\t\t}\n\t  }",
        "lines": 17,
        "depth": 10,
        "decorators": null
      },
      {
        "start_point": [
          1509,
          3
        ],
        "end_point": [
          1518,
          4
        ],
        "content": "exp LEX_IN simple_variable\n\t  {\n\t\tif (do_lint_old)\n\t\t\twarning_ln($2->source_line,\n\t\t\t\t_(\"old awk does not support the keyword `in' except after `for'\"));\n\t\t$3->nexti->opcode = Op_push_array;\n\t\t$2->opcode = Op_in_array;\n\t\t$2->expr_count = 1;\n\t\t$$ = list_append(list_merge($1, $3), $2);\n\t  }",
        "lines": 10,
        "depth": 10,
        "decorators": null
      }
    ],
    "a_relop": [
      {
        "start_point": [
          1537,
          3
        ],
        "end_point": [
          1541,
          4
        ],
        "content": "SLASH_BEFORE_EQUAL ASSIGN   /* `/=' */\n\t  {\n\t\t$2->opcode = Op_assign_quotient;\n\t\t$$ = $2;\n\t  }",
        "lines": 5,
        "depth": 6,
        "decorators": null
      },
      {
        "start_point": [
          1563,
          3
        ],
        "end_point": [
          1616,
          4
        ],
        "content": "common_exp simp_exp %prec CONCAT_OP\n\t  {\n\t\tint count = 2;\n\t\tbool is_simple_var = false;\n\n\t\tif ($1->lasti->opcode == Op_concat) {\n\t\t\t/* multiple (> 2) adjacent strings optimization */\n\t\t\tis_simple_var = ($1->lasti->concat_flag & CSVAR) != 0;\n\t\t\tcount = $1->lasti->expr_count + 1;\n\t\t\t$1->lasti->opcode = Op_no_op;\n\t\t} else {\n\t\t\tis_simple_var = ($1->nexti->opcode == Op_push\n\t\t\t\t\t&& $1->lasti == $1->nexti); /* first exp. is a simple\n\t\t\t\t\t                             * variable?; kludge for use\n\t\t\t\t\t                             * in Op_assign_concat.\n\t\t \t\t\t                             */\n\t\t}\n\n\t\tif (do_optimize\n\t\t\t&& $1->nexti == $1->lasti && $1->nexti->opcode == Op_push_i\n\t\t\t&& $2->nexti == $2->lasti && $2->nexti->opcode == Op_push_i\n\t\t) {\n\t\t\tNODE *n1 = $1->nexti->memory;\n\t\t\tNODE *n2 = $2->nexti->memory;\n\t\t\tsize_t nlen;\n\n\t\t\t// 1.5 \"\"   # can't fold this if program mucks with CONVFMT.\n\t\t\t// See test #12 in test/posix.awk.\n\t\t\t// Also can't fold if one or the other is translatable.\n\t\t\tif ((n1->flags & (NUMBER|NUMINT|INTLSTR)) != 0 || (n2->flags & (NUMBER|NUMINT|INTLSTR)) != 0)\n\t\t\t\tgoto plain_concat;\n\n\t\t\tn1 = force_string(n1);\n\t\t\tn2 = force_string(n2);\n\t\t\tnlen = n1->stlen + n2->stlen;\n\t\t\terealloc(n1->stptr, char *, nlen + 1, \"constant fold\");\n\t\t\tmemcpy(n1->stptr + n1->stlen, n2->stptr, n2->stlen);\n\t\t\tn1->stlen = nlen;\n\t\t\tn1->stptr[nlen] = '\\0';\n\t\t\tn1->flags &= ~(NUMCUR|NUMBER|NUMINT);\n\t\t\tn1->flags |= (STRING|STRCUR);\n\t\t\tunref(n2);\n\t\t\tbcfree($2->nexti);\n\t\t\tbcfree($2);\n\t\t\t$$ = $1;\n\t\t} else {\n\tplain_concat:\n\t\t\t$$ = list_append(list_merge($1, $2), instruction(Op_concat));\n\t\t\t$$->lasti->concat_flag = (is_simple_var ? CSVAR : 0);\n\t\t\t$$->lasti->expr_count = count;\n\t\t\tif (count > max_args)\n\t\t\t\tmax_args = count;\n\t\t}\n\t  }",
        "lines": 54,
        "depth": 14,
        "decorators": null
      },
      {
        "start_point": [
          1634,
          3
        ],
        "end_point": [
          1647,
          4
        ],
        "content": "LEX_GETLINE opt_variable input_redir\n\t  {\n\t\t/*\n\t\t * In BEGINFILE/ENDFILE, allow `getline [var] < file'\n\t\t */\n\n\t\tif ((rule == BEGINFILE || rule == ENDFILE) && $3 == NULL)\n\t\t\terror_ln($1->source_line,\n\t\t\t\t _(\"non-redirected `getline' invalid inside `%s' rule\"), ruletab[rule]);\n\t\tif (do_lint && rule == END && $3 == NULL)\n\t\t\tlintwarn_ln($1->source_line,\n\t\t\t\t_(\"non-redirected `getline' undefined inside END action\"));\n\t\t$$ = mk_getline($1, $2, $3, redirect_input);\n\t  }",
        "lines": 14,
        "depth": 10,
        "decorators": null
      },
      {
        "start_point": [
          1648,
          3
        ],
        "end_point": [
          1652,
          4
        ],
        "content": "variable INCREMENT\n\t  {\n\t\t$2->opcode = Op_postincrement;\n\t\t$$ = mk_assignment($1, NULL, $2);\n\t  }",
        "lines": 5,
        "depth": 7,
        "decorators": null
      },
      {
        "start_point": [
          1653,
          3
        ],
        "end_point": [
          1657,
          4
        ],
        "content": "variable DECREMENT\n\t  {\n\t\t$2->opcode = Op_postdecrement;\n\t\t$$ = mk_assignment($1, NULL, $2);\n\t  }",
        "lines": 5,
        "depth": 7,
        "decorators": null
      }
    ],
    "tokcompare": {
      "start_point": [
        2071,
        0
      ],
      "end_point": [
        2080,
        1
      ],
      "content": "static int\ntokcompare(const void *l, const void *r)\n{\n\tstruct token *lhs, *rhs;\n\n\tlhs = (struct token *) l;\n\trhs = (struct token *) r;\n\n\treturn strcmp(lhs->operator, rhs->operator);\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "getfname": {
      "start_point": [
        2190,
        0
      ],
      "end_point": [
        2202,
        1
      ],
      "content": "const char *\ngetfname(NODE *(*fptr)(int))\n{\n\tint i, j;\n\n\tj = sizeof(tokentab) / sizeof(tokentab[0]);\n\t/* linear search, no other way to do it */\n\tfor (i = 0; i < j; i++)\n\t\tif (tokentab[i].ptr == fptr || tokentab[i].ptr2 == fptr)\n\t\t\treturn tokentab[i].operator;\n\n\treturn NULL;\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "const",
        "const",
        "char",
        "*\ngetfname(NODE *(*fptr)(int))",
        "*"
      ]
    },
    "negate_num": {
      "start_point": [
        2206,
        0
      ],
      "end_point": [
        2245,
        1
      ],
      "content": "void\nnegate_num(NODE *n)\n{\n#ifdef HAVE_MPFR\n\tint tval = 0;\n#endif\n\n\tadd_sign_to_num(n, '-');\n\n\tif (! is_mpg_number(n)) {\n\t\tn->numbr = -n->numbr;\n\t\treturn;\n\t}\n\n#ifdef HAVE_MPFR\n\tif (is_mpg_integer(n)) {\n\t\tif (! iszero(n)) {\n\t\t\tmpz_neg(n->mpg_i, n->mpg_i);\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * 0 --> -0 conversion. Requires turning the MPG integer\n\t\t * into an MPFR float.\n\t\t */\n\n\t\tmpz_clear(n->mpg_i);\t/* release the integer storage */\n\n\t\t/* Convert and fall through. */\n\t\ttval = mpfr_set_d(n->mpg_numbr, 0.0, ROUND_MODE);\n\t\tIEEE_FMT(n->mpg_numbr, tval);\n\t\tn->flags &= ~MPZN;\n\t\tn->flags |= MPFN;\n\t}\n\n\t/* mpfr float case */\n\ttval = mpfr_neg(n->mpg_numbr, n->mpg_numbr, ROUND_MODE);\n\tIEEE_FMT(n->mpg_numbr, tval);\n#endif\n}",
      "lines": 40,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "add_sign_to_num": {
      "start_point": [
        2249,
        0
      ],
      "end_point": [
        2260,
        1
      ],
      "content": "static void\nadd_sign_to_num(NODE *n, char sign)\n{\n\tif ((n->flags & NUMCONSTSTR) != 0) {\n\t\tchar *s;\n\n\t\ts = n->stptr;\n\t\tmemmove(& s[1], & s[0], n->stlen + 1);\n\t\ts[0] = sign;\n\t\tn->stlen++;\n\t}\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "print_included_from": {
      "start_point": [
        2264,
        0
      ],
      "end_point": [
        2293,
        1
      ],
      "content": "static void\nprint_included_from()\n{\n\tint saveline, line;\n\tSRCFILE *s;\n\n\t/* suppress current file name, line # from `.. included from ..' msgs */\n\tsaveline = sourceline;\n\tsourceline = 0;\n\n\tfor (s = sourcefile; s != NULL && s->stype == SRC_INC; ) {\n\t\ts = s->next;\n\t\tif (s == NULL || s->fd <= INVALID_HANDLE)\n\t\t\tcontinue;\n\t\tline = s->srclines;\n\n\t\t/* if last token is NEWLINE, line number is off by 1. */\n\t\tif (s->lasttok == NEWLINE)\n\t\t\tline--;\n\t\tmsg(\"%s %s:%d%c\",\n\t\t\ts->prev == sourcefile ? \"In file included from\"\n\t\t\t\t\t  : \"                 from\",\n\t\t\t(s->stype == SRC_INC ||\n\t\t\t\t s->stype == SRC_FILE) ? s->src : \"cmd. line\",\n\t\t\tline,\n\t\t\ts->stype == SRC_INC ? ',' : ':'\n\t\t);\n\t}\n\tsourceline = saveline;\n}",
      "lines": 30,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "warning_ln": {
      "start_point": [
        2297,
        0
      ],
      "end_point": [
        2310,
        1
      ],
      "content": "static void\nwarning_ln(int line, const char *mesg, ...)\n{\n\tva_list args;\n\tint saveline;\n\n\tsaveline = sourceline;\n\tsourceline = line;\n\tprint_included_from();\n\tva_start(args, mesg);\n\terr(false, _(\"warning: \"), mesg, args);\n\tva_end(args);\n\tsourceline = saveline;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "lintwarn_ln": {
      "start_point": [
        2314,
        0
      ],
      "end_point": [
        2332,
        1
      ],
      "content": "static void\nlintwarn_ln(int line, const char *mesg, ...)\n{\n\tva_list args;\n\tint saveline;\n\n\tsaveline = sourceline;\n\tsourceline = line;\n\tprint_included_from();\n\tva_start(args, mesg);\n\tif (lintfunc == r_fatal)\n\t\terr(true, _(\"fatal: \"), mesg, args);\n\telse\n\t\terr(false, _(\"warning: \"), mesg, args);\n\tva_end(args);\n\tsourceline = saveline;\n\tif (lintfunc == r_fatal)\n\t\tgawk_exit(EXIT_FATAL);\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "error_ln": {
      "start_point": [
        2336,
        0
      ],
      "end_point": [
        2350,
        1
      ],
      "content": "static void\nerror_ln(int line, const char *m, ...)\n{\n\tva_list args;\n\tint saveline;\n\n\tsaveline = sourceline;\n\tsourceline = line;\n\tprint_included_from();\n\terrcount++;\n\tva_start(args, m);\n\terr(false, \"error: \", m, args);\n\tva_end(args);\n\tsourceline = saveline;\n}",
      "lines": 15,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yyerror": {
      "start_point": [
        2354,
        0
      ],
      "end_point": [
        2421,
        1
      ],
      "content": "static void\nyyerror(const char *m, ...)\n{\n\tva_list args;\n\tconst char *mesg = NULL;\n\tchar *bp, *cp;\n\tchar *scan;\n\tchar *buf;\n\tint count;\n\tstatic char end_of_file_line[] = \"(END OF FILE)\";\n\n\tprint_included_from();\n\n\terrcount++;\n\t/* Find the current line in the input file */\n\tif (lexptr && lexeme) {\n\t\tif (thisline == NULL) {\n\t\t\tcp = lexeme;\n\t\t\tif (*cp == '\\n') {\n\t\t\t\tif (cp > lexptr_begin)\n\t\t\t\t\tcp--;\n\t\t\t\tmesg = _(\"unexpected newline or end of string\");\n\t\t\t}\n\t\t\tfor (; cp != lexptr_begin && *cp != '\\n'; --cp)\n\t\t\t\tcontinue;\n\t\t\tif (*cp == '\\n')\n\t\t\t\tcp++;\n\t\t\tthisline = cp;\n\t\t}\n\t\t/* NL isn't guaranteed */\n\t\tbp = lexeme;\n\t\tif (bp < thisline)\n\t\t\tbp = thisline + 1;\n\t\twhile (bp < lexend && *bp && *bp != '\\n')\n\t\t\tbp++;\n\t} else {\n\t\tthisline = end_of_file_line;\n\t\tbp = thisline + strlen(thisline);\n\t}\n\n\tmsg(\"%.*s\", (int) (bp - thisline), thisline);\n\n\tva_start(args, m);\n\tif (mesg == NULL)\n\t\tmesg = m;\n\n\tcount = strlen(mesg) + 1;\n\tif (lexptr != NULL)\n\t\tcount += (lexeme - thisline) + 2;\n\tezalloc(buf, char *, count+1, \"yyerror\");\n\n\tbp = buf;\n\n\tif (lexptr != NULL) {\n\t\tscan = thisline;\n\t\twhile (scan < lexeme)\n\t\t\tif (*scan++ == '\\t')\n\t\t\t\t*bp++ = '\\t';\n\t\t\telse\n\t\t\t\t*bp++ = ' ';\n\t\t*bp++ = '^';\n\t\t*bp++ = ' ';\n\t}\n\tstrcpy(bp, mesg);\n\terr(false, \"\", buf, args);\n\tva_end(args);\n\tefree(buf);\n}",
      "lines": 68,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mk_program": {
      "start_point": [
        2425,
        0
      ],
      "end_point": [
        2546,
        1
      ],
      "content": "static INSTRUCTION *\nmk_program()\n{\n\tINSTRUCTION *cp, *tmp;\n\n#define begin_block         rule_block[BEGIN]\n#define end_block           rule_block[END]\n#define prog_block          rule_block[Rule]\n#define beginfile_block     rule_block[BEGINFILE]\n#define endfile_block       rule_block[ENDFILE]\n\n\tif (end_block == NULL)\n\t\tend_block = list_create(ip_end);\n\telse\n\t\t(void) list_prepend(end_block, ip_end);\n\n\tif (! in_main_context()) {\n\t\tif (begin_block != NULL && prog_block != NULL)\n\t\t\tcp = list_merge(begin_block, prog_block);\n\t\telse\n\t\t\tcp = (begin_block != NULL) ? begin_block : prog_block;\n\n\t\tif (cp != NULL)\n\t\t\t(void) list_merge(cp, end_block);\n\t\telse\n\t\t\tcp = end_block;\n\n\t\t(void) list_append(cp, instruction(Op_stop));\n\t\tgoto out;\n\t}\n\n\tif (endfile_block == NULL)\n\t\tendfile_block = list_create(ip_endfile);\n\telse {\n\t\tip_rec->has_endfile = true;\n\t\t(void) list_prepend(endfile_block, ip_endfile);\n\t}\n\n\tif (beginfile_block == NULL)\n\t\tbeginfile_block = list_create(ip_beginfile);\n\telse\n\t\t(void) list_prepend(beginfile_block, ip_beginfile);\n\n\tif (prog_block == NULL) {\n\t\tif (end_block->nexti == end_block->lasti\n\t\t\t\t&& beginfile_block->nexti == beginfile_block->lasti\n\t\t\t\t&& endfile_block->nexti == endfile_block->lasti\n\t\t) {\n\t\t\t/* no pattern-action and (real) end, beginfile or endfile blocks */\n\t\t\tbcfree(ip_rec);\n\t\t\tbcfree(ip_newfile);\n\t\t\tip_rec = ip_newfile = NULL;\n\n\t\t\tlist_append(beginfile_block, instruction(Op_after_beginfile));\n\t\t\t(void) list_append(endfile_block, instruction(Op_after_endfile));\n\n\t\t\tif (begin_block == NULL)     /* no program at all */\n\t\t\t\tcp = end_block;\n\t\t\telse\n\t\t\t\tcp = list_merge(begin_block, end_block);\n\t\t\tif (program_comment != NULL) {\n\t\t\t\t(void) list_prepend(cp, program_comment);\n\t\t\t}\n\t\t\tif (comment != NULL)\n\t\t\t\t(void) list_append(cp, comment);\n\t\t\t(void) list_append(cp, ip_atexit);\n\t\t\t(void) list_append(cp, instruction(Op_stop));\n\n\t\t\t/* append beginfile_block and endfile_block for sole use\n\t\t\t * in getline without redirection (Op_K_getline).\n\t\t\t */\n\n\t\t\t(void) list_merge(cp, beginfile_block);\n\t\t\t(void) list_merge(cp, endfile_block);\n\n\t\t\tgoto out;\n\n\t\t} else {\n\t\t\t/* install a do-nothing prog block */\n\t\t\tprog_block = list_create(instruction(Op_no_op));\n\t\t}\n\t}\n\n\t(void) list_append(endfile_block, instruction(Op_after_endfile));\n\t(void) list_prepend(prog_block, ip_rec);\n\t(void) list_append(prog_block, instruction(Op_jmp));\n\tprog_block->lasti->target_jmp = ip_rec;\n\n\tlist_append(beginfile_block, instruction(Op_after_beginfile));\n\n\tcp = list_merge(beginfile_block, prog_block);\n\t(void) list_prepend(cp, ip_newfile);\n\t(void) list_merge(cp, endfile_block);\n\t(void) list_merge(cp, end_block);\n\tif (begin_block != NULL)\n\t\tcp = list_merge(begin_block, cp);\n\n\tif (program_comment != NULL) {\n\t\t(void) list_prepend(cp, program_comment);\n\t}\n\tif (comment != NULL) {\n\t\t(void) list_append(cp, comment);\n\t}\n\t(void) list_append(cp, ip_atexit);\n\t(void) list_append(cp, instruction(Op_stop));\n\nout:\n\t/* delete the Op_list, not needed */\n\ttmp = cp->nexti;\n\tbcfree(cp);\n\t/* these variables are not used again but zap them anyway.  */\n\tcomment = NULL;\n\tfunction_comment = NULL;\n\tprogram_comment = NULL;\n\treturn tmp;\n\n#undef begin_block\n#undef end_block\n#undef prog_block\n#undef beginfile_block\n#undef endfile_block\n}",
      "lines": 122,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "INSTRUCTION",
        "*\nmk_program()",
        "*"
      ]
    },
    "parse_program": {
      "start_point": [
        2550,
        0
      ],
      "end_point": [
        2604,
        1
      ],
      "content": "int\nparse_program(INSTRUCTION **pcode)\n{\n\tint ret;\n\n\t/* pre-create non-local jump targets\n\t * ip_end (Op_no_op) -- used as jump target for `exit'\n\t * outside an END block.\n\t */\n\tip_end = instruction(Op_no_op);\n\n\tif (! in_main_context())\n\t\tip_newfile = ip_rec = ip_atexit = ip_beginfile = ip_endfile = NULL;\n\telse {\n\t\tip_endfile = instruction(Op_no_op);\n\t\tmain_beginfile = ip_beginfile = instruction(Op_no_op);\n\t\tip_rec = instruction(Op_get_record); /* target for `next', also ip_newfile */\n\t\tip_newfile = bcalloc(Op_newfile, 2, 0); /* target for `nextfile' */\n\t\tip_newfile->target_jmp = ip_end;\n\t\tip_newfile->target_endfile = ip_endfile;\n\t\t(ip_newfile + 1)->target_get_record = ip_rec;\n\t\tip_rec->target_newfile = ip_newfile;\n\t\tip_atexit = instruction(Op_atexit);\t/* target for `exit' in END block */\n\t}\n\n\tfor (sourcefile = srcfiles->next; sourcefile->stype == SRC_EXTLIB;\n\t\t\tsourcefile = sourcefile->next)\n\t\t;\n\n\tlexeof = false;\n\tlexptr = NULL;\n\tlasttok = 0;\n\tmemset(rule_block, 0, sizeof(ruletab) * sizeof(INSTRUCTION *));\n\terrcount = 0;\n\ttok = tokstart != NULL ? tokstart : tokexpand();\n\n\tret = yyparse();\n\t*pcode = mk_program();\n\n\t/* avoid false source indications */\n\tsource = NULL;\n\tsourceline = 0;\n\tif (ret == 0)\t/* avoid spurious warning if parser aborted with YYABORT */\n\t\tcheck_funcs();\n\n\tif (do_posix && ! check_param_names())\n\t\terrcount++;\n\n\tif (args_array == NULL)\n\t\temalloc(args_array, NODE **, (max_args + 2) * sizeof(NODE *), \"parse_program\");\n\telse\n\t\terealloc(args_array, NODE **, (max_args + 2) * sizeof(NODE *), \"parse_program\");\n\n\treturn (ret || errcount);\n}",
      "lines": 55,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "free_srcfile": {
      "start_point": [
        2608,
        0
      ],
      "end_point": [
        2613,
        1
      ],
      "content": "void\nfree_srcfile(SRCFILE *thisfile)\n{\n\tefree(thisfile->src);\n\tefree(thisfile);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "do_add_srcfile": {
      "start_point": [
        2617,
        0
      ],
      "end_point": [
        2632,
        1
      ],
      "content": "static SRCFILE *\ndo_add_srcfile(enum srctype stype, char *src, char *path, SRCFILE *thisfile)\n{\n\tSRCFILE *s;\n\n\tezalloc(s, SRCFILE *, sizeof(SRCFILE), \"do_add_srcfile\");\n\ts->src = estrdup(src, strlen(src));\n\ts->fullpath = path;\n\ts->stype = stype;\n\ts->fd = INVALID_HANDLE;\n\ts->next = thisfile;\n\ts->prev = thisfile->prev;\n\tthisfile->prev->next = s;\n\tthisfile->prev = s;\n\treturn s;\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "SRCFILE",
        "*\ndo_add_srcfile(enum srctype stype, char *src, char *path, SRCFILE *thisfile)",
        "*"
      ]
    },
    "add_srcfile": {
      "start_point": [
        2638,
        0
      ],
      "end_point": [
        2709,
        1
      ],
      "content": "SRCFILE *\nadd_srcfile(enum srctype stype, char *src, SRCFILE *thisfile, bool *already_included, int *errcode)\n{\n\tSRCFILE *s;\n\tstruct stat sbuf;\n\tchar *path;\n\tint errno_val = 0;\n\n\tif (already_included)\n\t\t*already_included = false;\n\tif (errcode)\n\t\t*errcode = 0;\n\tif (stype == SRC_CMDLINE || stype == SRC_STDIN)\n\t\treturn do_add_srcfile(stype, src, NULL, thisfile);\n\n\tpath = find_source(src, & sbuf, & errno_val, stype == SRC_EXTLIB);\n\tif (path == NULL) {\n\t\tif (errcode) {\n\t\t\t*errcode = errno_val;\n\t\t\treturn NULL;\n\t\t}\n\t\t/* use full messages to ease translation */\n\t\tfatal(stype != SRC_EXTLIB\n\t\t\t? _(\"can't open source file `%s' for reading (%s)\")\n\t\t\t: _(\"can't open shared library `%s' for reading (%s)\"),\n\t\t\t\tsrc,\n\t\t\t\terrno_val ? strerror(errno_val) : _(\"reason unknown\"));\n\t}\n\n\t/* N.B. We do not eliminate duplicate SRC_FILE (-f) programs. */\n\tfor (s = srcfiles->next; s != srcfiles; s = s->next) {\n\t\tif ((s->stype == SRC_FILE || s->stype == SRC_INC || s->stype == SRC_EXTLIB) && files_are_same(path, s)) {\n\t\t\tif (stype == SRC_INC || stype == SRC_EXTLIB) {\n\t\t\t\t/* eliminate duplicates */\n\t\t\t\tif ((stype == SRC_INC) && (s->stype == SRC_FILE))\n\t\t\t\t\tfatal(_(\"can't include `%s' and use it as a program file\"), src);\n\n\t\t\t\tif (do_lint) {\n\t\t\t\t\tint line = sourceline;\n\t\t\t\t\t/* Kludge: the line number may be off for `@include file'.\n\t\t\t\t\t * Since, this function is also used for '-f file' in main.c,\n\t\t\t\t\t * sourceline > 1 check ensures that the call is at\n\t\t\t\t\t * parse time.\n\t\t\t\t\t */\n\t\t\t\t\tif (sourceline > 1 && lasttok == NEWLINE)\n\t\t\t\t\t\tline--;\n\t\t\t\t\tlintwarn_ln(line,\n\t\t\t\t\t\t    stype != SRC_EXTLIB\n\t\t\t\t\t\t      ? _(\"already included source file `%s'\")\n\t\t\t\t\t\t      : _(\"already loaded shared library `%s'\"),\n\t\t\t\t\t\t    src);\n\t\t\t\t}\n\t\t\t\tefree(path);\n\t\t\t\tif (already_included)\n\t\t\t\t\t*already_included = true;\n\t\t\t\treturn NULL;\n\t\t\t} else {\n\t\t\t\t/* duplicates are allowed for -f */\n\t\t\t\tif (s->stype == SRC_INC)\n\t\t\t\t\tfatal(_(\"can't include `%s' and use it as a program file\"), src);\n\t\t\t\t/* no need to scan for further matches, since\n\t\t\t\t * they must be of homogeneous type */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\ts = do_add_srcfile(stype, src, path, thisfile);\n\ts->sbuf = sbuf;\n\ts->mtime = sbuf.st_mtime;\n\treturn s;\n}",
      "lines": 72,
      "depth": 18,
      "decorators": [
        "SRCFILE",
        "*\nadd_srcfile(enum srctype stype, char *src, SRCFILE *thisfile, bool *already_included, int *errcode)",
        "*"
      ]
    },
    "include_source": {
      "start_point": [
        2713,
        0
      ],
      "end_point": [
        2759,
        1
      ],
      "content": "static int\ninclude_source(INSTRUCTION *file)\n{\n\tSRCFILE *s;\n\tchar *src = file->lextok;\n\tint errcode;\n\tbool already_included;\n\n\tif (do_traditional || do_posix) {\n\t\terror_ln(file->source_line, _(\"@include is a gawk extension\"));\n\t\treturn -1;\n\t}\n\n\tif (strlen(src) == 0) {\n\t\tif (do_lint)\n\t\t\tlintwarn_ln(file->source_line, _(\"empty filename after @include\"));\n\t\treturn 0;\n\t}\n\n\ts = add_srcfile(SRC_INC, src, sourcefile, &already_included, &errcode);\n\tif (s == NULL) {\n\t\tif (already_included)\n\t\t\treturn 0;\n\t\terror_ln(file->source_line,\n\t\t\t_(\"can't open source file `%s' for reading (%s)\"),\n\t\t\tsrc, errcode ? strerror(errcode) : _(\"reason unknown\"));\n\t\treturn -1;\n\t}\n\n\t/* save scanner state for the current sourcefile */\n\tsourcefile->srclines = sourceline;\n\tsourcefile->lexptr = lexptr;\n\tsourcefile->lexend = lexend;\n\tsourcefile->lexptr_begin = lexptr_begin;\n\tsourcefile->lexeme = lexeme;\n\tsourcefile->lasttok = lasttok;\n\n\t/* included file becomes the current source */\n\tsourcefile = s;\n\tlexptr = NULL;\n\tsourceline = 0;\n\tsource = NULL;\n\tlasttok = 0;\n\tlexeof = false;\n\teof_warned = false;\n\treturn 0;\n}",
      "lines": 47,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "load_library": {
      "start_point": [
        2763,
        0
      ],
      "end_point": [
        2794,
        1
      ],
      "content": "static int\nload_library(INSTRUCTION *file)\n{\n\tSRCFILE *s;\n\tchar *src = file->lextok;\n\tint errcode;\n\tbool already_included;\n\n\tif (do_traditional || do_posix) {\n\t\terror_ln(file->source_line, _(\"@load is a gawk extension\"));\n\t\treturn -1;\n\t}\n\n\tif (strlen(src) == 0) {\n\t\tif (do_lint)\n\t\t\tlintwarn_ln(file->source_line, _(\"empty filename after @load\"));\n\t\treturn 0;\n\t}\n\n\ts = add_srcfile(SRC_EXTLIB, src, sourcefile, &already_included, &errcode);\n\tif (s == NULL) {\n\t\tif (already_included)\n\t\t\treturn 0;\n\t\terror_ln(file->source_line,\n\t\t\t_(\"can't open shared library `%s' for reading (%s)\"),\n\t\t\tsrc, errcode ? strerror(errcode) : _(\"reason unknown\"));\n\t\treturn -1;\n\t}\n\n\tload_ext(s->fullpath);\n\treturn 0;\n}",
      "lines": 32,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "next_sourcefile": {
      "start_point": [
        2798,
        0
      ],
      "end_point": [
        2858,
        1
      ],
      "content": "static void\nnext_sourcefile()\n{\n\tstatic int (*closefunc)(int fd) = NULL;\n\n\tif (closefunc == NULL) {\n\t\tchar *cp = getenv(\"AWKREADFUNC\");\n\n\t\t/* If necessary, one day, test value for different functions.  */\n\t\tif (cp == NULL)\n\t\t\tclosefunc = close;\n\t\telse\n\t\t\tclosefunc = one_line_close;\n\t}\n\n\t/*\n\t * This won't be true if there's an invalid character in\n\t * the source file or source string (e.g., user typo).\n\t * Previous versions of gawk did not core dump in such a\n\t * case.\n\t *\n\t * assert(lexeof == true);\n\t */\n\n\tlexeof = false;\n\teof_warned = false;\n\tsourcefile->srclines = sourceline;\t/* total no of lines in current file */\n\tif (sourcefile->fd > INVALID_HANDLE) {\n\t\tif (sourcefile->fd != fileno(stdin))  /* safety */\n\t\t\t(*closefunc)(sourcefile->fd);\n\t\tsourcefile->fd = INVALID_HANDLE;\n\t}\n\tif (sourcefile->buf != NULL) {\n\t\tefree(sourcefile->buf);\n\t\tsourcefile->buf = NULL;\n\t\tsourcefile->lexptr_begin = NULL;\n\t}\n\n\twhile ((sourcefile = sourcefile->next) != NULL) {\n\t\tif (sourcefile == srcfiles)\n\t\t\treturn;\n\t\tif (sourcefile->stype != SRC_EXTLIB)\n\t\t\tbreak;\n\t}\n\n\tif (sourcefile->lexptr_begin != NULL) {\n\t\t/* resume reading from already opened file (postponed to process '@include') */\n\t\tlexptr = sourcefile->lexptr;\n\t\tlexend = sourcefile->lexend;\n\t\tlasttok = sourcefile->lasttok;\n\t\tlexptr_begin = sourcefile->lexptr_begin;\n\t\tlexeme = sourcefile->lexeme;\n\t\tsourceline = sourcefile->srclines;\n\t\tsource = sourcefile->src;\n\t} else {\n\t\tlexptr = NULL;\n\t\tsourceline = 0;\n\t\tsource = NULL;\n\t\tlasttok = 0;\n\t}\n}",
      "lines": 61,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "get_src_buf": {
      "start_point": [
        2862,
        0
      ],
      "end_point": [
        3044,
        1
      ],
      "content": "static char *\nget_src_buf()\n{\n\tint n;\n\tchar *scan;\n\tbool newfile;\n\tint savelen;\n\tstruct stat sbuf;\n\n\t/*\n\t * No argument prototype on readfunc on purpose,\n\t * avoids problems with some ancient systems where\n\t * the types of arguments to read() aren't up to date.\n\t */\n\tstatic ssize_t (*readfunc)() = 0;\n\n\tif (readfunc == NULL) {\n\t\tchar *cp = getenv(\"AWKREADFUNC\");\n\n\t\t/* If necessary, one day, test value for different functions.  */\n\t\tif (cp == NULL)\n\t\t\t/*\n\t\t\t * cast is to remove warnings on systems with\n\t\t\t * different return types for read.\n\t\t\t */\n\t\t\treadfunc = ( ssize_t(*)() ) read;\n\t\telse\n\t\t\treadfunc = read_one_line;\n\t}\n\n\tnewfile = false;\n\tif (sourcefile == srcfiles)\n\t\treturn NULL;\n\n\tif (sourcefile->stype == SRC_CMDLINE) {\n\t\tif (sourcefile->bufsize == 0) {\n\t\t\tsourcefile->bufsize = strlen(sourcefile->src);\n\t\t\tlexptr = lexptr_begin = lexeme = sourcefile->src;\n\t\t\tlexend = lexptr + sourcefile->bufsize;\n\t\t\tsourceline = 1;\n\t\t\tif (sourcefile->bufsize == 0) {\n\t\t\t\t/*\n\t\t\t\t * Yet Another Special case:\n\t\t\t\t *\tgawk '' /path/name\n\t\t\t\t * Sigh.\n\t\t\t\t */\n\t\t\t\tstatic bool warned = false;\n\n\t\t\t\tif (do_lint && ! warned) {\n\t\t\t\t\twarned = true;\n\t\t\t\t\tlintwarn(_(\"empty program text on command line\"));\n\t\t\t\t}\n\t\t\t\tlexeof = true;\n\t\t\t}\n\t\t} else if (sourcefile->buf == NULL  && *(lexptr-1) != '\\n') {\n\t\t\t/*\n\t\t\t * The following goop is to ensure that the source\n\t\t\t * ends with a newline and that the entire current\n\t\t\t * line is available for error messages.\n\t\t\t */\n\t\t\tint offset;\n\t\t\tchar *buf;\n\n\t\t\toffset = lexptr - lexeme;\n\t\t\tfor (scan = lexeme; scan > lexptr_begin; scan--)\n\t\t\t\tif (*scan == '\\n') {\n\t\t\t\t\tscan++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tsavelen = lexptr - scan;\n\t\t\temalloc(buf, char *, savelen + 1, \"get_src_buf\");\n\t\t\tmemcpy(buf, scan, savelen);\n\t\t\tthisline = buf;\n\t\t\tlexptr = buf + savelen;\n\t\t\t*lexptr = '\\n';\n\t\t\tlexeme = lexptr - offset;\n\t\t\tlexptr_begin = buf;\n\t\t\tlexend = lexptr + 1;\n\t\t\tsourcefile->buf = buf;\n\t\t} else\n\t\t\tlexeof = true;\n\t\treturn lexptr;\n\t}\n\n\tif (sourcefile->fd <= INVALID_HANDLE) {\n\t\tint fd;\n\t\tint l;\n\n\t\tsource = sourcefile->src;\n\t\tif (source == NULL)\n\t\t\treturn NULL;\n\t\tfd = srcopen(sourcefile);\n\t\tif (fd <= INVALID_HANDLE) {\n\t\t\tchar *in;\n\n\t\t\t/* suppress file name and line no. in error mesg */\n\t\t\tin = source;\n\t\t\tsource = NULL;\n\t\t\terror(_(\"can't open source file `%s' for reading (%s)\"),\n\t\t\t\tin, strerror(errno));\n\t\t\terrcount++;\n\t\t\tlexeof = true;\n\t\t\treturn sourcefile->src;\n\t\t}\n\n\t\tsourcefile->fd = fd;\n\t\tl = optimal_bufsize(fd, &sbuf);\n\t\t/*\n\t\t * Make sure that something silly like\n\t\t * \tAWKBUFSIZE=8 make check\n\t\t * works ok.\n\t\t */\n#define A_DECENT_BUFFER_SIZE\t128\n\t\tif (l < A_DECENT_BUFFER_SIZE)\n\t\t\tl = A_DECENT_BUFFER_SIZE;\n#undef A_DECENT_BUFFER_SIZE\n\t\tsourcefile->bufsize = l;\n\t\tnewfile = true;\n\t\temalloc(sourcefile->buf, char *, sourcefile->bufsize, \"get_src_buf\");\n\t\tlexptr = lexptr_begin = lexeme = sourcefile->buf;\n\t\tsavelen = 0;\n\t\tsourceline = 1;\n\t\tthisline = NULL;\n\t} else {\n\t\t/*\n\t\t * Here, we retain the current source line in the beginning of the buffer.\n\t\t */\n\t\tint offset;\n\t\tfor (scan = lexeme; scan > lexptr_begin; scan--)\n\t\t\tif (*scan == '\\n') {\n\t\t\t\tscan++;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tsavelen = lexptr - scan;\n\t\toffset = lexptr - lexeme;\n\n\t\tif (savelen > 0) {\n\t\t\t/*\n\t\t\t * Need to make sure we have room left for reading new text;\n\t\t\t * grow the buffer (by doubling, an arbitrary choice), if the retained line\n\t\t\t * takes up more than a certain percentage (50%, again an arbitrary figure)\n\t\t\t * of the available space.\n\t\t\t */\n\n\t\t\tif (savelen > sourcefile->bufsize / 2) { /* long line or token  */\n\t\t\t\tsourcefile->bufsize *= 2;\n\t\t\t\terealloc(sourcefile->buf, char *, sourcefile->bufsize, \"get_src_buf\");\n\t\t\t\tscan = sourcefile->buf + (scan - lexptr_begin);\n\t\t\t\tlexptr_begin = sourcefile->buf;\n\t\t\t}\n\n\t\t\tthisline = lexptr_begin;\n\t\t\tmemmove(thisline, scan, savelen);\n\t\t\tlexptr = thisline + savelen;\n\t\t\tlexeme = lexptr - offset;\n\t\t} else {\n\t\t\tsavelen = 0;\n\t\t\tlexptr = lexeme = lexptr_begin;\n\t\t\tthisline = NULL;\n\t\t}\n\t}\n\n\tn = (*readfunc)(sourcefile->fd, lexptr, sourcefile->bufsize - savelen);\n\tif (n == -1) {\n\t\terror(_(\"can't read sourcefile `%s' (%s)\"),\n\t\t\t\tsource, strerror(errno));\n\t\terrcount++;\n\t\tlexeof = true;\n\t} else {\n\t\tlexend = lexptr + n;\n\t\tif (n == 0) {\n\t\t\tstatic bool warned = false;\n\t\t\tif (do_lint && newfile && ! warned) {\n\t\t\t\twarned = true;\n\t\t\t\tsourceline = 0;\n\t\t\t\tlintwarn(_(\"source file `%s' is empty\"), source);\n\t\t\t}\n\t\t\tlexeof = true;\n\t\t}\n\t}\n\treturn sourcefile->buf;\n}",
      "lines": 183,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nget_src_buf()",
        "*"
      ]
    },
    "tokexpand": {
      "start_point": [
        3052,
        0
      ],
      "end_point": [
        3070,
        1
      ],
      "content": "static char *\ntokexpand()\n{\n\tstatic int toksize;\n\tint tokoffset;\n\n\tif (tokstart != NULL) {\n\t\ttokoffset = tok - tokstart;\n\t\ttoksize *= 2;\n\t\terealloc(tokstart, char *, toksize, \"tokexpand\");\n\t\ttok = tokstart + tokoffset;\n\t} else {\n\t\ttoksize = 60;\n\t\temalloc(tokstart, char *, toksize, \"tokexpand\");\n\t\ttok = tokstart;\n\t}\n\ttokend = tokstart + toksize;\n\treturn tok;\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "char",
        "*\ntokexpand()",
        "*"
      ]
    },
    "check_bad_char": {
      "start_point": [
        3080,
        0
      ],
      "end_point": [
        3098,
        1
      ],
      "content": "static void\ncheck_bad_char(int c)\n{\n\t/* allow escapes. needed for autoconf. bleah. */\n\tswitch (c) {\n\tcase '\\a':\n\tcase '\\b':\n\tcase '\\f':\n\tcase '\\n':\n\tcase '\\r':\n\tcase '\\t':\n\t\treturn;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (iscntrl(c) && ! isspace(c))\n\t\tfatal(_(\"PEBKAC error: invalid character '\\\\%03o' in source code\"), c & 0xFF);\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "nextc": {
      "start_point": [
        3102,
        0
      ],
      "end_point": [
        3188,
        1
      ],
      "content": "static int\nnextc(bool check_for_bad)\n{\n\tif (gawk_mb_cur_max > 1) {\nagain:\n#ifdef NO_CONTINUE_SOURCE_STRINGS\n\t\tif (lexeof)\n\t\t\treturn END_FILE;\n#else\n\t\tif (lexeof) {\n\t\t\tif (sourcefile->next == srcfiles)\n\t\t\t\treturn END_FILE;\n\t\t\telse\n\t\t\t\tnext_sourcefile();\n\t\t}\n#endif\n\t\tif (lexptr == NULL || lexptr >= lexend) {\n\t\t\tif (get_src_buf())\n\t\t\t\tgoto again;\n\t\t\treturn END_SRC;\n\t\t}\n\n\t\t/* Update the buffer index.  */\n\t\tcur_ring_idx = (cur_ring_idx == RING_BUFFER_SIZE - 1)? 0 :\n\t\t\tcur_ring_idx + 1;\n\n\t\t/* Did we already check the current character?  */\n\t\tif (cur_char_ring[cur_ring_idx] == 0) {\n\t\t\t/* No, we need to check the next character on the buffer.  */\n\t\t\tint idx, work_ring_idx = cur_ring_idx;\n\t\t\tmbstate_t tmp_state;\n\t\t\tsize_t mbclen;\n\n\t\t\tfor (idx = 0; lexptr + idx < lexend; idx++) {\n\t\t\t\ttmp_state = cur_mbstate;\n\t\t\t\tmbclen = mbrlen(lexptr, idx + 1, &tmp_state);\n\n\t\t\t\tif (mbclen == 1 || mbclen == (size_t)-1 || mbclen == 0) {\n\t\t\t\t\t/* It is a singlebyte character, non-complete multibyte\n\t\t\t\t\t   character or EOF.  We treat it as a singlebyte\n\t\t\t\t\t   character.  */\n\t\t\t\t\tcur_char_ring[work_ring_idx] = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (mbclen == (size_t)-2) {\n\t\t\t\t\t/* It is not a complete multibyte character.  */\n\t\t\t\t\tcur_char_ring[work_ring_idx] = idx + 1;\n\t\t\t\t} else {\n\t\t\t\t\t/* mbclen > 1 */\n\t\t\t\t\tcur_char_ring[work_ring_idx] = mbclen;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\twork_ring_idx = (work_ring_idx == RING_BUFFER_SIZE - 1)?\n\t\t\t\t\t0 : work_ring_idx + 1;\n\t\t\t}\n\t\t\tcur_mbstate = tmp_state;\n\n\t\t\t/* Put a mark on the position on which we write next character.  */\n\t\t\twork_ring_idx = (work_ring_idx == RING_BUFFER_SIZE - 1)?\n\t\t\t\t0 : work_ring_idx + 1;\n\t\t\tcur_char_ring[work_ring_idx] = 0;\n\t\t}\n\t\tif (check_for_bad || *lexptr == '\\0')\n\t\t\tcheck_bad_char(*lexptr);\n\n\t\treturn (int) (unsigned char) *lexptr++;\n\t} else {\n\t\tdo {\n#ifdef NO_CONTINUE_SOURCE_STRINGS\n\t\t\tif (lexeof)\n\t\t\t\treturn END_FILE;\n#else\n\t\t\tif (lexeof) {\n\t\t\t\tif (sourcefile->next == srcfiles)\n\t\t\t\t\treturn END_FILE;\n\t\t\t\telse\n\t\t\t\t\tnext_sourcefile();\n\t\t\t}\n#endif\n\t\t\tif (lexptr && lexptr < lexend) {\n\t\t\t\tif (check_for_bad || *lexptr == '\\0')\n\t\t\t\t\tcheck_bad_char(*lexptr);\n\t\t\t\treturn ((int) (unsigned char) *lexptr++);\n\t\t\t}\n\t\t} while (get_src_buf());\n\t\treturn END_SRC;\n\t}\n}",
      "lines": 87,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "pushback": {
      "start_point": [
        3192,
        0
      ],
      "end_point": [
        3199,
        1
      ],
      "content": "static inline void\npushback(void)\n{\n\tif (gawk_mb_cur_max > 1)\n\t\tcur_ring_idx = (cur_ring_idx == 0)? RING_BUFFER_SIZE - 1 :\n\t\t\tcur_ring_idx - 1;\n\t(! lexeof && lexptr && lexptr > lexptr_begin ? lexptr-- : lexptr);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    },
    "check_comment": {
      "start_point": [
        3203,
        0
      ],
      "end_point": [
        3214,
        1
      ],
      "content": "void\ncheck_comment(void)\n{\n\tif (comment != NULL) {\n\t\tif (first_rule) {\n\t\t\tprogram_comment = comment;\n\t\t} else\n\t\t\tblock_comment = comment;\n\t\tcomment = NULL;\n\t}\n\tfirst_rule = false;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "get_comment": {
      "start_point": [
        3222,
        0
      ],
      "end_point": [
        3285,
        1
      ],
      "content": "int\nget_comment(int flag)\n{\n\tint c;\n\tint sl;\n\ttok = tokstart;\n\ttokadd('#');\n\tsl = sourceline;\n\tchar *p1;\n\tchar *p2;\n\n\twhile (true) {\n\t\twhile ((c = nextc(false)) != '\\n' && c != END_FILE) {\n\t\t\t/* ignore \\r characters */\n\t\t\tif (c != '\\r')\n\t\t\t\ttokadd(c);\n\t\t}\n\t\tif (flag == EOL_COMMENT) {\n\t\t\t/* comment at end of line.  */\n\t\t\tif (c == '\\n')\n\t\t\t\ttokadd(c);\n\t\t\tbreak;\n\t\t}\n\t\tif (c == '\\n') {\n\t\t\ttokadd(c);\n\t\t\tsourceline++;\n\t\t\tdo {\n\t\t\t\tc = nextc(false);\n\t\t\t\tif (c == '\\n') {\n\t\t\t\t\tsourceline++;\n\t\t\t\t\ttokadd(c);\n\t\t\t\t}\n\t\t\t} while (isspace(c) && c != END_FILE);\n\t\t\tif (c == END_FILE)\n\t\t\t\tbreak;\n\t\t\telse if (c != '#') {\n\t\t\t\tpushback();\n\t\t\t\tsourceline--;\n\t\t\t\tbreak;\n\t\t\t} else\n\t\t\t\ttokadd(c);\n\t\t} else\n\t\t\tbreak;\n\t}\n\n\tif (comment != NULL)\n\t\tprior_comment = comment;\n\n\t/* remove any trailing blank lines (consecutive \\n) from comment */\n\tp1 = tok - 1;\n\tp2 = tok - 2;\n\twhile (*p1 == '\\n' && *p2 == '\\n') {\n\t\tp1--;\n\t\tp2--;\n\t\ttok--;\n\t}\n\n\tcomment = bcalloc(Op_comment, 1, sl);\n\tcomment->source_file = source;\n\tcomment->memory = make_str_node(tokstart, tok - tokstart, 0);\n\tcomment->memory->comment_type = flag;\n\n\treturn c;\n}",
      "lines": 64,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "split_comment": {
      "start_point": [
        3289,
        0
      ],
      "end_point": [
        3316,
        1
      ],
      "content": "static void\nsplit_comment(void)\n{\n\tchar *p;\n\tint l;\n\tNODE *n;\n\n\tp = comment_to_save->memory->stptr;\n\tl = comment_to_save->memory->stlen - 3;\n\t/* have at least two comments so split at last blank line (\\n\\n)  */\n\twhile (l >= 0) {\n\t\tif (p[l] == '\\n' && p[l+1] == '\\n') {\n\t\t\tfunction_comment = comment_to_save;\n\t\t\tn = function_comment->memory;\n\t\t\tfunction_comment->memory = make_string(p + l + 2, n->stlen - l - 2);\n\t\t\t/* create program comment  */\n\t\t\tprogram_comment = bcalloc(Op_comment, 1, sourceline);\n\t\t\tprogram_comment->source_file = comment_to_save->source_file;\n\t\t\tp[l + 2] = 0;\n\t\t\tprogram_comment->memory = make_str_node(p, l + 2, 0);\n\t\t\tcomment_to_save = NULL;\n\t\t\tfreenode(n);\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t\tl--;\n\t}\n}",
      "lines": 28,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "allow_newline": {
      "start_point": [
        3320,
        0
      ],
      "end_point": [
        3351,
        1
      ],
      "content": "static void\nallow_newline(void)\n{\n\tint c;\n\n\tfor (;;) {\n\t\tc = nextc(true);\n\t\tif (c == END_FILE) {\n\t\t\tpushback();\n\t\t\tbreak;\n\t\t}\n\t\tif (c == '#') {\n\t\t\tif (do_pretty_print && ! do_profile) {\n\t\t\t/* collect comment byte code iff doing pretty print but not profiling.  */\n\t\t\t\tc = get_comment(EOL_COMMENT);\n\t\t\t} else {\n\t\t\t\twhile ((c = nextc(false)) != '\\n' && c != END_FILE)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (c == END_FILE) {\n\t\t\t\tpushback();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (c == '\\n')\n\t\t\tsourceline++;\n\t\tif (! isspace(c)) {\n\t\t\tpushback();\n\t\t\tbreak;\n\t\t}\n\t}\n}",
      "lines": 32,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "newline_eof": {
      "start_point": [
        3361,
        0
      ],
      "end_point": [
        3378,
        1
      ],
      "content": "static int\nnewline_eof()\n{\n\t/* NB: a newline at end does not start a source line. */\n\tif (lasttok != NEWLINE) {\n                pushback();\n\t\tif (do_lint && ! eof_warned) {\n        \t\tlintwarn(_(\"source file does not end in newline\"));\n\t\t\teof_warned = true;\n\t\t}\n\t\tsourceline++;\n\t\treturn NEWLINE;\n\t}\n\n\tsourceline--;\n\teof_warned = false;\n\treturn LEX_EOF;\n}",
      "lines": 18,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "yylex": [
      {
        "start_point": [
          3384,
          0
        ],
        "end_point": [
          4276,
          1
        ],
        "content": "yylex_ebcdic(void)\n#else\nyylex(void)\n#endif\n{\n\tint c;\n\tbool seen_e = false;\t\t/* These are for numbers */\n\tbool seen_point = false;\n\tbool esc_seen;\t\t/* for literal strings */\n\tint mid;\n\tint base;\n\tstatic bool did_newline = false;\n\tchar *tokkey;\n\tbool inhex = false;\n\tbool intlstr = false;\n\tAWKNUM d;\n\tbool collecting_typed_regexp = false;\n\n#define GET_INSTRUCTION(op) bcalloc(op, 1, sourceline)\n\n#define NEWLINE_EOF newline_eof()\n\n\tyylval = (INSTRUCTION *) NULL;\n\tif (lasttok == SUBSCRIPT) {\n\t\tlasttok = 0;\n\t\treturn SUBSCRIPT;\n\t}\n\n\tif (lasttok == LEX_EOF)\t\t/* error earlier in current source, must give up !! */\n\t\treturn 0;\n\n\tc = nextc(! want_regexp);\n\tif (c == END_SRC)\n\t\treturn 0;\n\tif (c == END_FILE)\n\t\treturn lasttok = NEWLINE_EOF;\n\tpushback();\n\n#if defined __EMX__\n\t/*\n\t * added for OS/2's extproc feature of cmd.exe\n\t * (like #! in BSD sh)\n\t */\n\tif (strncasecmp(lexptr, \"extproc \", 8) == 0) {\n\t\twhile (*lexptr && *lexptr != '\\n')\n\t\t\tlexptr++;\n\t}\n#endif\n\n\tlexeme = lexptr;\n\tthisline = NULL;\n\ncollect_regexp:\n\tif (want_regexp) {\n\t\tint in_brack = 0;\t/* count brackets, [[:alnum:]] allowed */\n\t\tint b_index = -1;\n\t\tint cur_index = 0;\n\n\t\t/*\n\t\t * Here is what's ok with brackets:\n\t\t *\n\t\t * [..[..] []] [^]] [.../...]\n\t\t * [...\\[...] [...\\]...] [...\\/...]\n\t\t *\n\t\t * (Remember that all of the above are inside /.../)\n\t\t *\n\t\t * The code for \\ handles \\[, \\] and \\/.\n\t\t *\n\t\t * Otherwise, track the first open [ position, and if\n\t\t * an embedded ] occurs, allow it to pass through\n\t\t * if it's right after the first [ or after [^.\n\t\t *\n\t\t * Whew!\n\t\t */\n\n\t\twant_regexp = false;\n\t\ttok = tokstart;\n\t\tfor (;;) {\n\t\t\tc = nextc(false);\n\n\t\t\tcur_index = tok - tokstart;\n\t\t\tif (gawk_mb_cur_max == 1 || nextc_is_1stbyte) switch (c) {\n\t\t\tcase '[':\n\t\t\t\tif (nextc(false) == ':' || in_brack == 0) {\n\t\t\t\t\tin_brack++;\n\t\t\t\t\tif (in_brack == 1)\n\t\t\t\t\t\tb_index = tok - tokstart;\n\t\t\t\t}\n\t\t\t\tpushback();\n\t\t\t\tbreak;\n\t\t\tcase ']':\n\t\t\t\tif (in_brack > 0\n\t\t\t\t    && (cur_index == b_index + 1\n\t\t\t\t\t|| (cur_index == b_index + 2 && tok[-1] == '^')))\n\t\t\t\t\t; /* do nothing */\n\t\t\t\telse {\n\t\t\t\t\tin_brack--;\n\t\t\t\t\tif (in_brack == 0)\n\t\t\t\t\t\tb_index = -1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '\\\\':\n\t\t\t\tif ((c = nextc(false)) == END_FILE) {\n\t\t\t\t\tpushback();\n\t\t\t\t\tyyerror(_(\"unterminated regexp ends with `\\\\' at end of file\"));\n\t\t\t\t\tgoto end_regexp; /* kludge */\n\t\t\t\t}\n\t\t\t\tif (c == '\\r')\t/* allow MS-DOS files. bleah */\n\t\t\t\t\tc = nextc(true);\n\t\t\t\tif (c == '\\n') {\n\t\t\t\t\tsourceline++;\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\ttokadd('\\\\');\n\t\t\t\t\ttokadd(c);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '/':\t/* end of the regexp */\n\t\t\t\tif (in_brack > 0)\n\t\t\t\t\tbreak;\nend_regexp:\n\t\t\t\tyylval = GET_INSTRUCTION(Op_token);\n\t\t\t\tyylval->lextok = estrdup(tokstart, tok - tokstart);\n\t\t\t\tif (do_lint) {\n\t\t\t\t\tint peek = nextc(true);\n\n\t\t\t\t\tpushback();\n\t\t\t\t\tif (peek == 'i' || peek == 's') {\n\t\t\t\t\t\tif (source)\n\t\t\t\t\t\t\tlintwarn(\n\t\t\t\t\t\t_(\"%s: %d: tawk regex modifier `/.../%c' doesn't work in gawk\"),\n\t\t\t\t\t\t\t\tsource, sourceline, peek);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tlintwarn(\n\t\t\t\t\t\t_(\"tawk regex modifier `/.../%c' doesn't work in gawk\"),\n\t\t\t\t\t\t\t\tpeek);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (collecting_typed_regexp) {\n\t\t\t\t\tcollecting_typed_regexp = false;\n\t\t\t\t\tlasttok = TYPED_REGEXP;\n\t\t\t\t} else\n\t\t\t\t\tlasttok = REGEXP;\n\n\t\t\t\treturn lasttok;\n\t\t\tcase '\\n':\n\t\t\t\tpushback();\n\t\t\t\tyyerror(_(\"unterminated regexp\"));\n\t\t\t\tgoto end_regexp;\t/* kludge */\n\t\t\tcase END_FILE:\n\t\t\t\tpushback();\n\t\t\t\tyyerror(_(\"unterminated regexp at end of file\"));\n\t\t\t\tgoto end_regexp;\t/* kludge */\n\t\t\t}\n\t\t\ttokadd(c);\n\t\t}\n\t}\nretry:\n\n\t/* skipping \\r is a hack, but windows is just too pervasive. sigh. */\n\twhile ((c = nextc(true)) == ' ' || c == '\\t' || c == '\\r')\n\t\tcontinue;\n\n\tlexeme = lexptr ? lexptr - 1 : lexptr;\n\tthisline = NULL;\n\ttok = tokstart;\n\n\tif (gawk_mb_cur_max == 1 || nextc_is_1stbyte)\n\tswitch (c) {\n\tcase END_SRC:\n\t\treturn 0;\n\n\tcase END_FILE:\n\t\treturn lasttok = NEWLINE_EOF;\n\n\tcase '\\n':\n\t\tsourceline++;\n\t\treturn lasttok = NEWLINE;\n\n\tcase '#':\t\t/* it's a comment */\n\t\tif (do_pretty_print && ! do_profile) {\n\t\t\t/*\n\t\t\t * Collect comment byte code iff doing pretty print\n\t\t\t * but not profiling.\n\t\t\t */\n\t\t\tif (lasttok == NEWLINE || lasttok == 0)\n\t\t\t\tc = get_comment(FULL_COMMENT);\n\t\t\telse\n\t\t\t\tc = get_comment(EOL_COMMENT);\n\n\t\t\tif (c == END_FILE)\n\t\t\t\treturn lasttok = NEWLINE_EOF;\n\t\t} else {\n\t\t\twhile ((c = nextc(false)) != '\\n') {\n\t\t\t\tif (c == END_FILE)\n\t\t\t\t\treturn lasttok = NEWLINE_EOF;\n\t\t\t}\n\t\t}\n\t\tsourceline++;\n\t\treturn lasttok = NEWLINE;\n\n\tcase '@':\n\t\tc = nextc(true);\n\t\tif (c == '/') {\n\t\t\twant_regexp = true;\n\t\t\tcollecting_typed_regexp = true;\n\t\t\tgoto collect_regexp;\n\t\t}\n\t\tpushback();\n\t\tat_seen = true;\n\t\treturn lasttok = '@';\n\n\tcase '\\\\':\n#ifdef RELAXED_CONTINUATION\n\t\t/*\n\t\t * This code purports to allow comments and/or whitespace\n\t\t * after the `\\' at the end of a line used for continuation.\n\t\t * Use it at your own risk. We think it's a bad idea, which\n\t\t * is why it's not on by default.\n\t\t */\n\t\tif (! do_traditional) {\n\t\t\t/* strip trailing white-space and/or comment */\n\t\t\twhile ((c = nextc(true)) == ' ' || c == '\\t' || c == '\\r')\n\t\t\t\tcontinue;\n\t\t\tif (c == '#') {\n\t\t\t\tstatic bool warned = false;\n\n\t\t\t\tif (do_lint && ! warned) {\n\t\t\t\t\twarned = true;\n\t\t\t\t\tlintwarn(\n\t\t_(\"use of `\\\\ #...' line continuation is not portable\"));\n\t\t\t\t}\n\t\t\t\tif (do_pretty_print && ! do_profile)\n\t\t\t\t\tc = get_comment(EOL_COMMENT);\n\t\t\t\telse {\n\t\t\t\t\twhile ((c = nextc(false)) != '\\n')\n\t\t\t\t\t\tif (c == END_FILE)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpushback();\n\t\t}\n#endif /* RELAXED_CONTINUATION */\n\t\tc = nextc(true);\n\t\tif (c == '\\r')\t/* allow MS-DOS files. bleah */\n\t\t\tc = nextc(true);\n\t\tif (c == '\\n') {\n\t\t\tsourceline++;\n\t\t\tgoto retry;\n\t\t} else {\n\t\t\tyyerror(_(\"backslash not last character on line\"));\n\t\t\treturn lasttok = LEX_EOF;\n\t\t}\n\t\tbreak;\n\n\tcase ':':\n\tcase '?':\n\t\tyylval = GET_INSTRUCTION(Op_cond_exp);\n\t\tif (! do_posix)\n\t\t\tallow_newline();\n\t\treturn lasttok = c;\n\n\t\t/*\n\t\t * in_parens is undefined unless we are parsing a print\n\t\t * statement (in_print), but why bother with a check?\n\t\t */\n\tcase ')':\n\t\tin_parens--;\n\t\treturn lasttok = c;\n\n\tcase '(':\n\t\tin_parens++;\n\t\treturn lasttok = c;\n\tcase '$':\n\t\tyylval = GET_INSTRUCTION(Op_field_spec);\n\t\treturn lasttok = c;\n\tcase '{':\n\t\tif (++in_braces == 1)\n\t\t\tfirstline = sourceline;\n\tcase ';':\n\tcase ',':\n\tcase '[':\n\t\t\treturn lasttok = c;\n\tcase ']':\n\t\tc = nextc(true);\n\t\tpushback();\n\t\tif (c == '[') {\n\t\t\tif (do_traditional)\n\t\t\t\tfatal(_(\"multidimensional arrays are a gawk extension\"));\n\t\t\tif (do_lint)\n\t\t\t\tlintwarn(_(\"multidimensional arrays are a gawk extension\"));\n\t\t\tyylval = GET_INSTRUCTION(Op_sub_array);\n\t\t\tlasttok = ']';\n\t\t} else {\n\t\t\tyylval = GET_INSTRUCTION(Op_subscript);\n\t\t\tlasttok = SUBSCRIPT;\t/* end of subscripts */\n\t\t}\n\t\treturn ']';\n\n\tcase '*':\n\t\tif ((c = nextc(true)) == '=') {\n\t\t\tyylval = GET_INSTRUCTION(Op_assign_times);\n\t\t\treturn lasttok = ASSIGNOP;\n\t\t} else if (do_posix) {\n\t\t\tpushback();\n\t\t\tyylval = GET_INSTRUCTION(Op_times);\n\t\t\treturn lasttok = '*';\n\t\t} else if (c == '*') {\n\t\t\t/* make ** and **= aliases for ^ and ^= */\n\t\t\tstatic bool did_warn_op = false, did_warn_assgn = false;\n\n\t\t\tif (nextc(true) == '=') {\n\t\t\t\tif (! did_warn_assgn) {\n\t\t\t\t\tdid_warn_assgn = true;\n\t\t\t\t\tif (do_lint)\n\t\t\t\t\t\tlintwarn(_(\"POSIX does not allow operator `**='\"));\n\t\t\t\t\tif (do_lint_old)\n\t\t\t\t\t\twarning(_(\"old awk does not support operator `**='\"));\n\t\t\t\t}\n\t\t\t\tyylval = GET_INSTRUCTION(Op_assign_exp);\n\t\t\t\treturn ASSIGNOP;\n\t\t\t} else {\n\t\t\t\tpushback();\n\t\t\t\tif (! did_warn_op) {\n\t\t\t\t\tdid_warn_op = true;\n\t\t\t\t\tif (do_lint)\n\t\t\t\t\t\tlintwarn(_(\"POSIX does not allow operator `**'\"));\n\t\t\t\t\tif (do_lint_old)\n\t\t\t\t\t\twarning(_(\"old awk does not support operator `**'\"));\n\t\t\t\t}\n\t\t\t\tyylval = GET_INSTRUCTION(Op_exp);\n\t\t\t\treturn lasttok = '^';\n\t\t\t}\n\t\t}\n\t\tpushback();\n\t\tyylval = GET_INSTRUCTION(Op_times);\n\t\treturn lasttok = '*';\n\n\tcase '/':\n\t\tif (nextc(false) == '=') {\n\t\t\tpushback();\n\t\t\treturn lasttok = SLASH_BEFORE_EQUAL;\n\t\t}\n\t\tpushback();\n\t\tyylval = GET_INSTRUCTION(Op_quotient);\n\t\treturn lasttok = '/';\n\n\tcase '%':\n\t\tif (nextc(true) == '=') {\n\t\t\tyylval = GET_INSTRUCTION(Op_assign_mod);\n\t\t\treturn lasttok = ASSIGNOP;\n\t\t}\n\t\tpushback();\n\t\tyylval = GET_INSTRUCTION(Op_mod);\n\t\treturn lasttok = '%';\n\n\tcase '^':\n\t{\n\t\tstatic bool did_warn_op = false, did_warn_assgn = false;\n\n\t\tif (nextc(true) == '=') {\n\t\t\tif (do_lint_old && ! did_warn_assgn) {\n\t\t\t\tdid_warn_assgn = true;\n\t\t\t\twarning(_(\"operator `^=' is not supported in old awk\"));\n\t\t\t}\n\t\t\tyylval = GET_INSTRUCTION(Op_assign_exp);\n\t\t\treturn lasttok = ASSIGNOP;\n\t\t}\n\t\tpushback();\n\t\tif (do_lint_old && ! did_warn_op) {\n\t\t\tdid_warn_op = true;\n\t\t\twarning(_(\"operator `^' is not supported in old awk\"));\n\t\t}\n\t\tyylval = GET_INSTRUCTION(Op_exp);\n\t\treturn lasttok = '^';\n\t}\n\n\tcase '+':\n\t\tif ((c = nextc(true)) == '=') {\n\t\t\tyylval = GET_INSTRUCTION(Op_assign_plus);\n\t\t\treturn lasttok = ASSIGNOP;\n\t\t}\n\t\tif (c == '+') {\n\t\t\tyylval = GET_INSTRUCTION(Op_symbol);\n\t\t\treturn lasttok = INCREMENT;\n\t\t}\n\t\tpushback();\n\t\tyylval = GET_INSTRUCTION(Op_plus);\n\t\treturn lasttok = '+';\n\n\tcase '!':\n\t\tif ((c = nextc(true)) == '=') {\n\t\t\tyylval = GET_INSTRUCTION(Op_notequal);\n\t\t\treturn lasttok = RELOP;\n\t\t}\n\t\tif (c == '~') {\n\t\t\tyylval = GET_INSTRUCTION(Op_nomatch);\n\t\t\treturn lasttok = MATCHOP;\n\t\t}\n\t\tpushback();\n\t\tyylval = GET_INSTRUCTION(Op_symbol);\n\t\treturn lasttok = '!';\n\n\tcase '<':\n\t\tif (nextc(true) == '=') {\n\t\t\tyylval = GET_INSTRUCTION(Op_leq);\n\t\t\treturn lasttok = RELOP;\n\t\t}\n\t\tyylval = GET_INSTRUCTION(Op_less);\n\t\tpushback();\n\t\treturn lasttok = '<';\n\n\tcase '=':\n\t\tif (nextc(true) == '=') {\n\t\t\tyylval = GET_INSTRUCTION(Op_equal);\n\t\t\treturn lasttok = RELOP;\n\t\t}\n\t\tyylval = GET_INSTRUCTION(Op_assign);\n\t\tpushback();\n\t\treturn lasttok = ASSIGN;\n\n\tcase '>':\n\t\tif ((c = nextc(true)) == '=') {\n\t\t\tyylval = GET_INSTRUCTION(Op_geq);\n\t\t\treturn lasttok = RELOP;\n\t\t} else if (c == '>') {\n\t\t\tyylval = GET_INSTRUCTION(Op_symbol);\n\t\t\tyylval->redir_type = redirect_append;\n\t\t\treturn lasttok = IO_OUT;\n\t\t}\n\t\tpushback();\n\t\tif (in_print && in_parens == 0) {\n\t\t\tyylval = GET_INSTRUCTION(Op_symbol);\n\t\t\tyylval->redir_type = redirect_output;\n\t\t\treturn lasttok = IO_OUT;\n\t\t}\n\t\tyylval = GET_INSTRUCTION(Op_greater);\n\t\treturn lasttok = '>';\n\n\tcase '~':\n\t\tyylval = GET_INSTRUCTION(Op_match);\n\t\treturn lasttok = MATCHOP;\n\n\tcase '}':\n\t\t/*\n\t\t * Added did newline stuff.  Easier than\n\t\t * hacking the grammar.\n\t\t */\n\t\tif (did_newline) {\n\t\t\tdid_newline = false;\n\t\t\tif (--in_braces == 0)\n\t\t\t\tlastline = sourceline;\n\t\t\treturn lasttok = c;\n\t\t}\n\t\tdid_newline = true;\n\t\t--lexptr;\t/* pick up } next time */\n\t\treturn lasttok = NEWLINE;\n\n\tcase '\"':\n\tstring:\n\t\tesc_seen = false;\n\t\t/*\n\t\t * Allow any kind of junk in quoted string,\n\t\t * so pass false to nextc().\n\t\t */\n\t\twhile ((c = nextc(false)) != '\"') {\n\t\t\tif (c == '\\n') {\n\t\t\t\tpushback();\n\t\t\t\tyyerror(_(\"unterminated string\"));\n\t\t\t\treturn lasttok = LEX_EOF;\n\t\t\t}\n\t\t\tif ((gawk_mb_cur_max == 1 || nextc_is_1stbyte) &&\n\t\t\t    c == '\\\\') {\n\t\t\t\tc = nextc(true);\n\t\t\t\tif (c == '\\r')\t/* allow MS-DOS files. bleah */\n\t\t\t\t\tc = nextc(true);\n\t\t\t\tif (c == '\\n') {\n\t\t\t\t\tsourceline++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tesc_seen = true;\n\t\t\t\tif (! want_source || c != '\"')\n\t\t\t\t\ttokadd('\\\\');\n\t\t\t}\n\t\t\tif (c == END_FILE) {\n\t\t\t\tpushback();\n\t\t\t\tyyerror(_(\"unterminated string\"));\n\t\t\t\treturn lasttok = LEX_EOF;\n\t\t\t}\n\t\t\ttokadd(c);\n\t\t}\n\t\tyylval = GET_INSTRUCTION(Op_token);\n\t\tif (want_source) {\n\t\t\tyylval->lextok = estrdup(tokstart, tok - tokstart);\n\t\t\treturn lasttok = FILENAME;\n\t\t}\n\n\t\tyylval->opcode = Op_push_i;\n\t\tyylval->memory = make_str_node(tokstart,\n\t\t\t\t\ttok - tokstart, esc_seen ? SCAN : 0);\n\t\tif (intlstr) {\n\t\t\tyylval->memory->flags |= INTLSTR;\n\t\t\tintlstr = false;\n\t\t\tif (do_intl)\n\t\t\t\tdumpintlstr(yylval->memory->stptr, yylval->memory->stlen);\n\t\t}\n\t\treturn lasttok = YSTRING;\n\n\tcase '-':\n\t\tif ((c = nextc(true)) == '=') {\n\t\t\tyylval = GET_INSTRUCTION(Op_assign_minus);\n\t\t\treturn lasttok = ASSIGNOP;\n\t\t}\n\t\tif (c == '-') {\n\t\t\tyylval = GET_INSTRUCTION(Op_symbol);\n\t\t\treturn lasttok = DECREMENT;\n\t\t}\n\t\tpushback();\n\t\tyylval = GET_INSTRUCTION(Op_minus);\n\t\treturn lasttok = '-';\n\n\tcase '.':\n\t\tc = nextc(true);\n\t\tpushback();\n\t\tif (! isdigit(c))\n\t\t\treturn lasttok = '.';\n\t\telse\n\t\t\tc = '.';\n\t\t/* FALL THROUGH */\n\tcase '0':\n\tcase '1':\n\tcase '2':\n\tcase '3':\n\tcase '4':\n\tcase '5':\n\tcase '6':\n\tcase '7':\n\tcase '8':\n\tcase '9':\n\t\t/* It's a number */\n\t\tfor (;;) {\n\t\t\tbool gotnumber = false;\n\n\t\t\ttokadd(c);\n\t\t\tswitch (c) {\n\t\t\tcase 'x':\n\t\t\tcase 'X':\n\t\t\t\tif (do_traditional)\n\t\t\t\t\tgoto done;\n\t\t\t\tif (tok == tokstart + 2) {\n\t\t\t\t\tint peek = nextc(true);\n\n\t\t\t\t\tif (isxdigit(peek)) {\n\t\t\t\t\t\tinhex = true;\n\t\t\t\t\t\tpushback();\t/* following digit */\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpushback();\t/* x or X */\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '.':\n\t\t\t\t/* period ends exponent part of floating point number */\n\t\t\t\tif (seen_point || seen_e) {\n\t\t\t\t\tgotnumber = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tseen_point = true;\n\t\t\t\tbreak;\n\t\t\tcase 'e':\n\t\t\tcase 'E':\n\t\t\t\tif (inhex)\n\t\t\t\t\tbreak;\n\t\t\t\tif (seen_e) {\n\t\t\t\t\tgotnumber = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tseen_e = true;\n\t\t\t\tif ((c = nextc(true)) == '-' || c == '+') {\n\t\t\t\t\tint c2 = nextc(true);\n\n\t\t\t\t\tif (isdigit(c2)) {\n\t\t\t\t\t\ttokadd(c);\n\t\t\t\t\t\ttokadd(c2);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpushback();\t/* non-digit after + or - */\n\t\t\t\t\t\tpushback();\t/* + or - */\n\t\t\t\t\t\tpushback();\t/* e or E */\n\t\t\t\t\t}\n\t\t\t\t} else if (! isdigit(c)) {\n\t\t\t\t\tpushback();\t/* character after e or E */\n\t\t\t\t\tpushback();\t/* e or E */\n\t\t\t\t} else {\n\t\t\t\t\tpushback();\t/* digit */\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'a':\n\t\t\tcase 'A':\n\t\t\tcase 'b':\n\t\t\tcase 'B':\n\t\t\tcase 'c':\n\t\t\tcase 'C':\n\t\t\tcase 'D':\n\t\t\tcase 'd':\n\t\t\tcase 'f':\n\t\t\tcase 'F':\n\t\t\t\tif (do_traditional || ! inhex)\n\t\t\t\t\tgoto done;\n\t\t\t\t/* fall through */\n\t\t\tcase '0':\n\t\t\tcase '1':\n\t\t\tcase '2':\n\t\t\tcase '3':\n\t\t\tcase '4':\n\t\t\tcase '5':\n\t\t\tcase '6':\n\t\t\tcase '7':\n\t\t\tcase '8':\n\t\t\tcase '9':\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\tdone:\n\t\t\t\tgotnumber = true;\n\t\t\t}\n\t\t\tif (gotnumber)\n\t\t\t\tbreak;\n\t\t\tc = nextc(true);\n\t\t}\n\t\tpushback();\n\n\t\ttokadd('\\0');\n\t\tyylval = GET_INSTRUCTION(Op_push_i);\n\n\t\tbase = 10;\n\t\tif (! do_traditional) {\n\t\t\tbase = get_numbase(tokstart, strlen(tokstart)-1, false);\n\t\t\tif (do_lint) {\n\t\t\t\tif (base == 8)\n\t\t\t\t\tlintwarn(\"numeric constant `%.*s' treated as octal\",\n\t\t\t\t\t\t(int) strlen(tokstart)-1, tokstart);\n\t\t\t\telse if (base == 16)\n\t\t\t\t\tlintwarn(\"numeric constant `%.*s' treated as hexadecimal\",\n\t\t\t\t\t\t(int) strlen(tokstart)-1, tokstart);\n\t\t\t}\n\t\t}\n\n#ifdef HAVE_MPFR\n\t\tif (do_mpfr) {\n\t\t\tNODE *r;\n\n\t\t\tif (! seen_point && ! seen_e) {\n\t\t\t\tr = mpg_integer();\n\t\t\t\tmpg_strtoui(r->mpg_i, tokstart, strlen(tokstart), NULL, base);\n\t\t\t\terrno = 0;\n\t\t\t} else {\n\t\t\t\tint tval;\n\t\t\t\tr = mpg_float();\n\t\t\t\ttval = mpfr_strtofr(r->mpg_numbr, tokstart, NULL, base, ROUND_MODE);\n\t\t\t\terrno = 0;\n\t\t\t\tIEEE_FMT(r->mpg_numbr, tval);\n\t\t\t}\n\t\t\tyylval->memory = set_profile_text(r, tokstart, strlen(tokstart)-1);\n\t\t\treturn lasttok = YNUMBER;\n\t\t}\n#endif\n\t\tif (base != 10)\n\t\t\td = nondec2awknum(tokstart, strlen(tokstart)-1, NULL);\n\t\telse\n\t\t\td = atof(tokstart);\n\t\tyylval->memory = set_profile_text(make_number(d), tokstart, strlen(tokstart) - 1);\n\t\tif (d <= INT32_MAX && d >= INT32_MIN && d == (int32_t) d)\n\t\t\tyylval->memory->flags |= NUMINT;\n\t\treturn lasttok = YNUMBER;\n\n\tcase '&':\n\t\tif ((c = nextc(true)) == '&') {\n\t\t\tyylval = GET_INSTRUCTION(Op_and);\n\t\t\tallow_newline();\n\t\t\treturn lasttok = LEX_AND;\n\t\t}\n\t\tpushback();\n\t\tyylval = GET_INSTRUCTION(Op_symbol);\n\t\treturn lasttok = '&';\n\n\tcase '|':\n\t\tif ((c = nextc(true)) == '|') {\n\t\t\tyylval = GET_INSTRUCTION(Op_or);\n\t\t\tallow_newline();\n\t\t\treturn lasttok = LEX_OR;\n\t\t} else if (! do_traditional && c == '&') {\n\t\t\tyylval = GET_INSTRUCTION(Op_symbol);\n\t\t\tyylval->redir_type = redirect_twoway;\n\t\t\treturn lasttok = (in_print && in_parens == 0 ? IO_OUT : IO_IN);\n\t\t}\n\t\tpushback();\n\t\tif (in_print && in_parens == 0) {\n\t\t\tyylval = GET_INSTRUCTION(Op_symbol);\n\t\t\tyylval->redir_type = redirect_pipe;\n\t\t\treturn lasttok = IO_OUT;\n\t\t} else {\n\t\t\tyylval = GET_INSTRUCTION(Op_symbol);\n\t\t\tyylval->redir_type = redirect_pipein;\n\t\t\treturn lasttok = IO_IN;\n\t\t}\n\t}\n\n\tif (! is_letter(c)) {\n\t\tyyerror(_(\"invalid char '%c' in expression\"), c);\n\t\treturn lasttok = LEX_EOF;\n\t}\n\n\t/*\n\t * Lots of fog here.  Consider:\n\t *\n\t * print \"xyzzy\"$_\"foo\"\n\t *\n\t * Without the check for ` lasttok != '$' ', this is parsed as\n\t *\n\t * print \"xxyzz\" $(_\"foo\")\n\t *\n\t * With the check, it is \"correctly\" parsed as three\n\t * string concatenations.  Sigh.  This seems to be\n\t * \"more correct\", but this is definitely one of those\n\t * occasions where the interactions are funny.\n\t */\n\tif (! do_traditional && c == '_' && lasttok != '$') {\n\t\tif ((c = nextc(true)) == '\"') {\n\t\t\tintlstr = true;\n\t\t\tgoto string;\n\t\t}\n\t\tpushback();\n\t\tc = '_';\n\t}\n\n\t/* it's some type of name-type-thing.  Find its length. */\n\ttok = tokstart;\n\twhile (c != END_FILE && is_identchar(c)) {\n\t\ttokadd(c);\n\t\tc = nextc(true);\n\t}\n\ttokadd('\\0');\n\tpushback();\n\n\t/* See if it is a special token. */\n\tif ((mid = check_special(tokstart)) >= 0) {\n\t\tstatic int warntab[sizeof(tokentab) / sizeof(tokentab[0])];\n\t\tint class = tokentab[mid].class;\n\n\t\tif ((class == LEX_INCLUDE || class == LEX_LOAD || class == LEX_EVAL)\n\t\t\t\t&& lasttok != '@')\n\t\t\tgoto out;\n\n\t\t/* allow parameter names to shadow the names of gawk extension built-ins */\n\t\tif ((tokentab[mid].flags & GAWKX) != 0) {\n\t\t\tNODE *f;\n\n\t\t\tswitch (want_param_names) {\n\t\t\tcase FUNC_HEADER:\n\t\t\t\t/* in header, defining parameter names */\n\t\t\t\tgoto out;\n\t\t\tcase FUNC_BODY:\n\t\t\t\t/* in body, name must be in symbol table for it to be a parameter */\n\t\t\t\tif ((f = lookup(tokstart)) != NULL) {\n\t\t\t\t\tif (f->type == Node_builtin_func)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\telse\n\t\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\t/* else\n\t\t\t\t\tfall through */\n\t\t\tcase DONT_CHECK:\n\t\t\t\t/* regular code */\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tcant_happen();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (do_lint) {\n\t\t\tif ((tokentab[mid].flags & GAWKX) != 0 && (warntab[mid] & GAWKX) == 0) {\n\t\t\t\tlintwarn(_(\"`%s' is a gawk extension\"),\n\t\t\t\t\ttokentab[mid].operator);\n\t\t\t\twarntab[mid] |= GAWKX;\n\t\t\t}\n\t\t\tif ((tokentab[mid].flags & NOT_POSIX) != 0 && (warntab[mid] & NOT_POSIX) == 0) {\n\t\t\t\tlintwarn(_(\"POSIX does not allow `%s'\"),\n\t\t\t\t\ttokentab[mid].operator);\n\t\t\t\twarntab[mid] |= NOT_POSIX;\n\t\t\t}\n\t\t}\n\t\tif (do_lint_old && (tokentab[mid].flags & NOT_OLD) != 0\n\t\t\t\t && (warntab[mid] & NOT_OLD) == 0\n\t\t) {\n\t\t\twarning(_(\"`%s' is not supported in old awk\"),\n\t\t\t\t\ttokentab[mid].operator);\n\t\t\twarntab[mid] |= NOT_OLD;\n\t\t}\n\n\t\tif ((tokentab[mid].flags & BREAK) != 0)\n\t\t\tbreak_allowed++;\n\t\tif ((tokentab[mid].flags & CONTINUE) != 0)\n\t\t\tcontinue_allowed++;\n\n\t\tswitch (class) {\n\t\tcase LEX_INCLUDE:\n\t\tcase LEX_LOAD:\n\t\t\twant_source = true;\n\t\t\tbreak;\n\t\tcase LEX_EVAL:\n\t\t\tif (in_main_context())\n\t\t\t\tgoto out;\n\t\t\temalloc(tokkey, char *, tok - tokstart + 1, \"yylex\");\n\t\t\ttokkey[0] = '@';\n\t\t\tmemcpy(tokkey + 1, tokstart, tok - tokstart);\n\t\t\tyylval = GET_INSTRUCTION(Op_token);\n\t\t\tyylval->lextok = tokkey;\n\t\t\tbreak;\n\n\t\tcase LEX_FUNCTION:\n\t\tcase LEX_BEGIN:\n\t\tcase LEX_END:\n\t\tcase LEX_BEGINFILE:\n\t\tcase LEX_ENDFILE:\n\t\t\tyylval = bcalloc(tokentab[mid].value, 3, sourceline);\n\t\t\tbreak;\n\n\t\tcase LEX_FOR:\n\t\tcase LEX_WHILE:\n\t\tcase LEX_DO:\n\t\tcase LEX_SWITCH:\n\t\t\tif (! do_pretty_print)\n\t\t\t\treturn lasttok = class;\n\t\t\t/* fall through */\n\t\tcase LEX_CASE:\n\t\t\tyylval = bcalloc(tokentab[mid].value, 2, sourceline);\n\t\t\tbreak;\n\n\t\t/*\n\t\t * These must be checked here, due to the LALR nature of the parser,\n\t\t * the rules for continue and break may not be reduced until after\n\t\t * a token that increments the xxx_allowed varibles is seen. Bleah.\n\t\t */\n\t\tcase LEX_CONTINUE:\n\t\t\tif (! continue_allowed) {\n\t\t\t\terror_ln(sourceline,\n\t\t\t\t\t_(\"`continue' is not allowed outside a loop\"));\n\t\t\t\terrcount++;\n\t\t\t}\n\t\t\tgoto make_instruction;\n\n\t\tcase LEX_BREAK:\n\t\t\tif (! break_allowed) {\n\t\t\t\terror_ln(sourceline,\n\t\t\t\t\t_(\"`break' is not allowed outside a loop or switch\"));\n\t\t\t\terrcount++;\n\t\t\t}\n\t\t\tgoto make_instruction;\n\n\t\tdefault:\nmake_instruction:\n\t\t\tyylval = GET_INSTRUCTION(tokentab[mid].value);\n\t\t\tif (class == LEX_BUILTIN || class == LEX_LENGTH)\n\t\t\t\tyylval->builtin_idx = mid;\n\t\t\tbreak;\n\t\t}\n\t\treturn lasttok = class;\n\t}\nout:\n\ttokkey = estrdup(tokstart, tok - tokstart);\n\tif (*lexptr == '(') {\n\t\tyylval = bcalloc(Op_token, 2, sourceline);\n\t\tyylval->lextok = tokkey;\n\t\treturn lasttok = FUNC_CALL;\n\t} else {\n\t\tstatic bool goto_warned = false;\n\n\t\tyylval = GET_INSTRUCTION(Op_token);\n\t\tyylval->lextok = tokkey;\n\n#define SMART_ALECK\t1\n\t\tif (SMART_ALECK && do_lint\n\t\t    && ! goto_warned && strcasecmp(tokkey, \"goto\") == 0) {\n\t\t\tgoto_warned = true;\n\t\t\tlintwarn(_(\"`goto' considered harmful!\\n\"));\n\t\t}\n\t\treturn lasttok = NAME;\n\t}\n\n#undef GET_INSTRUCTION\n#undef NEWLINE_EOF\n}",
        "lines": 893,
        "depth": 23,
        "decorators": [
          "yylex_ebcdic(void)",
          "yylex_ebcdic",
          "(",
          "void",
          "void",
          ")",
          "#else",
          "#else"
        ]
      },
      {
        "start_point": [
          4284,
          0
        ],
        "end_point": [
          4310,
          1
        ],
        "content": "static int\nyylex(void)\n{\n\tstatic char etoa_xlate[256];\n\tstatic int do_etoa_init = 1;\n\tint tok;\n\n\tif (do_etoa_init)\n\t{\n\t\tfor (tok = 0; tok < 256; tok++)\n\t\t\tetoa_xlate[tok] = (char) tok;\n#ifdef HAVE___ETOA_L\n\t\t/* IBM helpfully provides this function.  */\n\t\t__etoa_l(etoa_xlate, sizeof(etoa_xlate));\n#else\n# error \"An EBCDIC-to-ASCII translation function is needed for this system\"\n#endif\n\t\tdo_etoa_init = 0;\n\t}\n\n\ttok = yylex_ebcdic();\n\n\tif (tok >= 0 && tok <= 0xFF)\n\t\ttok = etoa_xlate[tok];\n\n\treturn tok;\n}",
        "lines": 27,
        "depth": 11,
        "decorators": [
          "static",
          "static",
          "int"
        ]
      }
    ],
    "snode": {
      "start_point": [
        4316,
        0
      ],
      "end_point": [
        4595,
        1
      ],
      "content": "static INSTRUCTION *\nsnode(INSTRUCTION *subn, INSTRUCTION *r)\n{\n\tINSTRUCTION *arg;\n\tINSTRUCTION *ip;\n\tNODE *n;\n\tint nexp = 0;\n\tint args_allowed;\n\tint idx = r->builtin_idx;\n\n\tif (subn != NULL) {\n\t\tINSTRUCTION *tp;\n\t\tfor (tp = subn->nexti; tp; tp = tp->nexti) {\n\t\t\ttp = tp->lasti;\n\t\t\tnexp++;\n\t\t}\n\t\tassert(nexp > 0);\n\t}\n\n\t/* check against how many args. are allowed for this builtin */\n\targs_allowed = tokentab[idx].flags & ARGS;\n\tif (args_allowed && (args_allowed & A(nexp)) == 0) {\n\t\tyyerror(_(\"%d is invalid as number of arguments for %s\"),\n\t\t\t\tnexp, tokentab[idx].operator);\n\t\treturn NULL;\n\t}\n\n\t/* special processing for sub, gsub and gensub */\n\n\tif (tokentab[idx].value == Op_sub_builtin) {\n\t\tconst char *operator = tokentab[idx].operator;\n\n\t\tr->sub_flags = 0;\n\n\t\targ = subn->nexti;\t\t/* first arg list */\n\t\t(void) mk_rexp(arg);\n\n\t\tif (strcmp(operator, \"gensub\") != 0) {\n\t\t\t/* sub and gsub */\n\n\t\t\tif (strcmp(operator, \"gsub\") == 0)\n\t\t\t\tr->sub_flags |= GSUB;\n\n\t\t\targ = arg->lasti->nexti;\t/* 2nd arg list */\n\t\t\tif (nexp == 2) {\n\t\t\t\tINSTRUCTION *expr;\n\n\t\t\t\texpr = list_create(instruction(Op_push_i));\n\t\t\t\texpr->nexti->memory = set_profile_text(make_number(0.0), \"0\", 1);\n\t\t\t\t(void) mk_expression_list(subn,\n\t\t\t\t\t\tlist_append(expr, instruction(Op_field_spec)));\n\t\t\t}\n\n\t\t\targ = arg->lasti->nexti; \t/* third arg list */\n\t\t\tip = arg->lasti;\n\t\t\tif (ip->opcode == Op_push_i) {\n\t\t\t\tif (do_lint)\n\t\t\t\t\tlintwarn(_(\"%s: string literal as last arg of substitute has no effect\"),\n\t\t\t\t\t\toperator);\n\t\t\t\tr->sub_flags |=\tLITERAL;\n\t\t\t} else {\n\t\t\t\tif (make_assignable(ip) == NULL)\n\t\t\t\t\tyyerror(_(\"%s third parameter is not a changeable object\"),\n\t\t\t\t\t\toperator);\n\t\t\t\telse\n\t\t\t\t\tip->do_reference = true;\n\t\t\t}\n\n\t\t\tr->expr_count = count_expressions(&subn, false);\n\t\t\tip = subn->lasti;\n\n\t\t\t(void) list_append(subn, r);\n\n\t\t\t/* add after_assign code */\n\t\t\tif (ip->opcode == Op_push_lhs && ip->memory->type == Node_var && ip->memory->var_assign) {\n\t\t\t\t(void) list_append(subn, instruction(Op_var_assign));\n\t\t\t\tsubn->lasti->assign_ctxt = Op_sub_builtin;\n\t\t\t\tsubn->lasti->assign_var = ip->memory->var_assign;\n\t\t\t} else if (ip->opcode == Op_field_spec_lhs) {\n\t\t\t\t(void) list_append(subn, instruction(Op_field_assign));\n\t\t\t\tsubn->lasti->assign_ctxt = Op_sub_builtin;\n\t\t\t\tsubn->lasti->field_assign = (Func_ptr) 0;\n\t\t\t\tip->target_assign = subn->lasti;\n\t\t\t} else if (ip->opcode == Op_subscript_lhs) {\n\t\t\t\t(void) list_append(subn, instruction(Op_subscript_assign));\n\t\t\t\tsubn->lasti->assign_ctxt = Op_sub_builtin;\n\t\t\t}\n\n\t\t\treturn subn;\n\n\t\t} else {\n\t\t\t/* gensub */\n\n\t\t\tr->sub_flags |= GENSUB;\n\t\t\tif (nexp == 3) {\n\t\t\t\tip = instruction(Op_push_i);\n\t\t\t\tip->memory = set_profile_text(make_number(0.0), \"0\", 1);\n\t\t\t\t(void) mk_expression_list(subn,\n\t\t\t\t\t\tlist_append(list_create(ip), instruction(Op_field_spec)));\n\t\t\t}\n\n\t\t\tr->expr_count = count_expressions(&subn, false);\n\t\t\treturn list_append(subn, r);\n\t\t}\n\t}\n\n#ifdef HAVE_MPFR\n\t/* N.B.: If necessary, add special processing for alternate builtin, below */\n\tif (do_mpfr && tokentab[idx].ptr2)\n\t\tr->builtin =  tokentab[idx].ptr2;\n\telse\n#endif\n\t\tr->builtin = tokentab[idx].ptr;\n\n\t/* special case processing for a few builtins */\n\n\tif (r->builtin == do_length) {\n\t\tif (nexp == 0) {\n\t\t    /* no args. Use $0 */\n\n\t\t\tINSTRUCTION *list;\n\t\t\tr->expr_count = 1;\n\t\t\tlist = list_create(r);\n\t\t\t(void) list_prepend(list, instruction(Op_field_spec));\n\t\t\t(void) list_prepend(list, instruction(Op_push_i));\n\t\t\tlist->nexti->memory = set_profile_text(make_number(0.0), \"0\", 1);\n\t\t\treturn list;\n\t\t} else {\n\t\t\targ = subn->nexti;\n\t\t\tif (arg->nexti == arg->lasti && arg->nexti->opcode == Op_push)\n\t\t\t\targ->nexti->opcode = Op_push_arg;\t/* argument may be array */\n \t\t}\n\t} else if (r->builtin == do_isarray || r->builtin == do_typeof) {\n\t\targ = subn->nexti;\n\t\tif (arg->nexti == arg->lasti && arg->nexti->opcode == Op_push)\n\t\t\targ->nexti->opcode = Op_push_arg_untyped;\t/* argument may be untyped */\n#ifdef SUPPLY_INTDIV\n\t} else if (r->builtin == do_intdiv\n#ifdef HAVE_MPFR\n\t\t   || r->builtin == MPF(intdiv)\n#endif\n\t\t\t) {\n\t\targ = subn->nexti->lasti->nexti->lasti->nexti;\t/* 3rd arg list */\n\t\tip = arg->lasti;\n\t\tif (ip->opcode == Op_push)\n\t\t\tip->opcode = Op_push_array;\n#endif /* SUPPLY_INTDIV */\n\t} else if (r->builtin == do_match) {\n\t\tstatic bool warned = false;\n\n\t\targ = subn->nexti->lasti->nexti;\t/* 2nd arg list */\n\t\t(void) mk_rexp(arg);\n\n\t\tif (nexp == 3) {\t/* 3rd argument there */\n\t\t\tif (do_lint && ! warned) {\n\t\t\t\twarned = true;\n\t\t\t\tlintwarn(_(\"match: third argument is a gawk extension\"));\n\t\t\t}\n\t\t\tif (do_traditional) {\n\t\t\t\tyyerror(_(\"match: third argument is a gawk extension\"));\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\targ = arg->lasti->nexti; \t/* third arg list */\n\t\t\tip = arg->lasti;\n\t\t\tif (/*ip == arg->nexti  && */ ip->opcode == Op_push)\n\t\t\t\tip->opcode = Op_push_array;\n\t\t}\n\t} else if (r->builtin == do_split) {\n\t\targ = subn->nexti->lasti->nexti;\t/* 2nd arg list */\n\t\tip = arg->lasti;\n\t\tif (ip->opcode == Op_push)\n\t\t\tip->opcode = Op_push_array;\n\t\tif (nexp == 2) {\n\t\t\tINSTRUCTION *expr;\n\t\t\texpr = list_create(instruction(Op_push));\n\t\t\texpr->nexti->memory = FS_node;\n\t\t\t(void) mk_expression_list(subn, expr);\n\t\t}\n\t\targ = arg->lasti->nexti;\n\t\tn = mk_rexp(arg);\n\t\tif (nexp == 2)\n\t\t\tn->re_flags |= FS_DFLT;\n\t\tif (nexp == 4) {\n\t\t\targ = arg->lasti->nexti;\n\t\t\tip = arg->lasti;\n\t\t\tif (ip->opcode == Op_push)\n\t\t\t\tip->opcode = Op_push_array;\n\t\t}\n\t} else if (r->builtin == do_patsplit) {\n\t\targ = subn->nexti->lasti->nexti;\t/* 2nd arg list */\n\t\tip = arg->lasti;\n\t\tif (ip->opcode == Op_push)\n\t\t\tip->opcode = Op_push_array;\n\t\tif (nexp == 2) {\n\t\t\tINSTRUCTION *expr;\n\t\t\texpr = list_create(instruction(Op_push));\n\t\t\texpr->nexti->memory = FPAT_node;\n\t\t\t(void) mk_expression_list(subn, expr);\n\t\t}\n\t\targ = arg->lasti->nexti;\n\t\tn = mk_rexp(arg);\n\t\tif (nexp == 4) {\n\t\t\targ = arg->lasti->nexti;\n\t\t\tip = arg->lasti;\n\t\t\tif (ip->opcode == Op_push)\n\t\t\t\tip->opcode = Op_push_array;\n\t\t}\n\t} else if (r->builtin == do_close) {\n\t\tstatic bool warned = false;\n\t\tif (nexp == 2) {\n\t\t\tif (do_lint && ! warned) {\n\t\t\t\twarned = true;\n\t\t\t\tlintwarn(_(\"close: second argument is a gawk extension\"));\n\t\t\t}\n\t\t\tif (do_traditional) {\n\t\t\t\tyyerror(_(\"close: second argument is a gawk extension\"));\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t} else if (do_intl\t\t\t\t\t/* --gen-po */\n\t\t\t&& r->builtin == do_dcgettext\t\t/* dcgettext(...) */\n\t\t\t&& subn->nexti->lasti->opcode == Op_push_i\t/* 1st arg is constant */\n\t\t\t&& (subn->nexti->lasti->memory->flags & STRING) != 0) {\t/* it's a string constant */\n\t\t/* ala xgettext, dcgettext(\"some string\" ...) dumps the string */\n\t\tNODE *str = subn->nexti->lasti->memory;\n\n\t\tif ((str->flags & INTLSTR) != 0)\n\t\t\twarning(_(\"use of dcgettext(_\\\"...\\\") is incorrect: remove leading underscore\"));\n\t\t\t/* don't dump it, the lexer already did */\n\t\telse\n\t\t\tdumpintlstr(str->stptr, str->stlen);\n\t} else if (do_intl\t\t\t\t\t/* --gen-po */\n\t\t\t&& r->builtin == do_dcngettext\t\t/* dcngettext(...) */\n\t\t\t&& subn->nexti->lasti->opcode == Op_push_i\t/* 1st arg is constant */\n\t\t\t&& (subn->nexti->lasti->memory->flags & STRING) != 0\t/* it's a string constant */\n\t\t\t&& subn->nexti->lasti->nexti->lasti->opcode == Op_push_i\t/* 2nd arg is constant too */\n\t\t\t&& (subn->nexti->lasti->nexti->lasti->memory->flags & STRING) != 0) {\t/* it's a string constant */\n\t\t/* ala xgettext, dcngettext(\"some string\", \"some plural\" ...) dumps the string */\n\t\tNODE *str1 = subn->nexti->lasti->memory;\n\t\tNODE *str2 = subn->nexti->lasti->nexti->lasti->memory;\n\n\t\tif (((str1->flags | str2->flags) & INTLSTR) != 0)\n\t\t\twarning(_(\"use of dcngettext(_\\\"...\\\") is incorrect: remove leading underscore\"));\n\t\telse\n\t\t\tdumpintlstr2(str1->stptr, str1->stlen, str2->stptr, str2->stlen);\n\t} else if (r->builtin == do_asort || r->builtin == do_asorti) {\n\t\targ = subn->nexti;\t/* 1st arg list */\n\t\tip = arg->lasti;\n\t\tif (ip->opcode == Op_push)\n\t\t\tip->opcode = Op_push_array;\n\t\tif (nexp >= 2) {\n\t\t\targ = ip->nexti;\n\t\t\tip = arg->lasti;\n\t\t\tif (ip->opcode == Op_push)\n\t\t\t\tip->opcode = Op_push_array;\n\t\t}\n\t}\n\telse if (r->builtin == do_index) {\n\t\targ = subn->nexti->lasti->nexti;\t/* 2nd arg list */\n\t\tip = arg->lasti;\n\t\tif (ip->opcode == Op_match_rec)\n\t\t\tfatal(_(\"index: regexp constant as second argument is not allowed\"));\n\t}\n#ifdef ARRAYDEBUG\n\telse if (r->builtin == do_adump) {\n\t\tip = subn->nexti->lasti;\n\t\tif (ip->opcode == Op_push)\n\t\t\tip->opcode = Op_push_array;\n\t}\n#endif\n\n\tif (subn != NULL) {\n\t\tr->expr_count = count_expressions(&subn, false);\n\t\treturn list_append(subn, r);\n\t}\n\n\tr->expr_count = 0;\n\treturn list_create(r);\n}",
      "lines": 280,
      "depth": 22,
      "decorators": [
        "static",
        "static",
        "INSTRUCTION",
        "*\nsnode(INSTRUCTION *subn, INSTRUCTION *r)",
        "*"
      ]
    },
    "parms_shadow": {
      "start_point": [
        4600,
        0
      ],
      "end_point": [
        4639,
        1
      ],
      "content": "static int\nparms_shadow(INSTRUCTION *pc, bool *shadow)\n{\n\tint pcount, i;\n\tbool ret = false;\n\tNODE *func, *fp;\n\tchar *fname;\n\n\tfunc = pc->func_body;\n\tfname = func->vname;\n\tfp = func->fparms;\n\n#if 0\t/* can't happen, already exited if error ? */\n\tif (fname == NULL || func == NULL)\t/* error earlier */\n\t\treturn false;\n#endif\n\n\tpcount = func->param_cnt;\n\n\tif (pcount == 0)\t\t/* no args, no problem */\n\t\treturn 0;\n\n\tsource = pc->source_file;\n\tsourceline = pc->source_line;\n\t/*\n\t * Use warning() and not lintwarn() so that can warn\n\t * about all shadowed parameters.\n\t */\n\tfor (i = 0; i < pcount; i++) {\n\t\tif (lookup(fp[i].param) != NULL) {\n\t\t\twarning(\n\t_(\"function `%s': parameter `%s' shadows global variable\"),\n\t\t\t\t\tfname, fp[i].param);\n\t\t\tret = true;\n\t\t}\n\t}\n\n\t*shadow |= ret;\n\treturn 0;\n}",
      "lines": 40,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "valinfo": {
      "start_point": [
        4643,
        0
      ],
      "end_point": [
        4664,
        1
      ],
      "content": "void\nvalinfo(NODE *n, Func_print print_func, FILE *fp)\n{\n\tif (n == Nnull_string)\n\t\tprint_func(fp, \"uninitialized scalar\\n\");\n\telse if ((n->flags & REGEX) != 0)\n\t\tprint_func(fp, \"@/%.*s/\\n\", n->stlen, n->stptr);\n\telse if ((n->flags & STRING) != 0) {\n\t\tpp_string_fp(print_func, fp, n->stptr, n->stlen, '\"', false);\n\t\tprint_func(fp, \"\\n\");\n\t} else if ((n->flags & NUMBER) != 0) {\n#ifdef HAVE_MPFR\n\t\tif (is_mpg_float(n))\n\t\t\tprint_func(fp, \"%s\\n\", mpg_fmt(\"%.17R*g\", ROUND_MODE, n->mpg_numbr));\n\t\telse if (is_mpg_integer(n))\n\t\t\tprint_func(fp, \"%s\\n\", mpg_fmt(\"%Zd\", n->mpg_i));\n\t\telse\n#endif\n\t\tprint_func(fp, \"%.17g\\n\", n->numbr);\n\t} else\n\t\tprint_func(fp, \"?? flags %s\\n\", flags2str(n->flags));\n}",
      "lines": 22,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "dump_vars": {
      "start_point": [
        4669,
        0
      ],
      "end_point": [
        4690,
        1
      ],
      "content": "void\ndump_vars(const char *fname)\n{\n\tFILE *fp;\n\tNODE **vars;\n\n\tif (fname == NULL)\n\t\tfp = stderr;\n\telse if (strcmp(fname, \"-\") == 0)\n\t\tfp = stdout;\n\telse if ((fp = fopen(fname, \"w\")) == NULL) {\n\t\twarning(_(\"could not open `%s' for writing (%s)\"), fname, strerror(errno));\n\t\twarning(_(\"sending variable list to standard error\"));\n\t\tfp = stderr;\n\t}\n\n\tvars = variable_list();\n\tprint_vars(vars, fprintf, fp);\n\tefree(vars);\n\tif (fp != stdout && fp != stderr && fclose(fp) != 0)\n\t\twarning(_(\"%s: close failed (%s)\"), fname, strerror(errno));\n}",
      "lines": 22,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "dump_funcs": {
      "start_point": [
        4694,
        0
      ],
      "end_point": [
        4701,
        1
      ],
      "content": "void\ndump_funcs()\n{\n\tNODE **funcs;\n\tfuncs = function_list(true);\n\t(void) foreach_func(funcs, (int (*)(INSTRUCTION *, void *)) pp_func, (void *) 0);\n\tefree(funcs);\n}",
      "lines": 8,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "shadow_funcs": {
      "start_point": [
        4706,
        0
      ],
      "end_point": [
        4723,
        1
      ],
      "content": "void\nshadow_funcs()\n{\n\tstatic int calls = 0;\n\tbool shadow = false;\n\tNODE **funcs;\n\n\tif (calls++ != 0)\n\t\tfatal(_(\"shadow_funcs() called twice!\"));\n\n\tfuncs = function_list(true);\n\t(void) foreach_func(funcs, (int (*)(INSTRUCTION *, void *)) parms_shadow, & shadow);\n\tefree(funcs);\n\n\t/* End with fatal if the user requested it.  */\n\tif (shadow && lintfunc == r_fatal)\n\t\tlintwarn(_(\"there were shadowed variables.\"));\n}",
      "lines": 18,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "mk_function": {
      "start_point": [
        4730,
        0
      ],
      "end_point": [
        4785,
        1
      ],
      "content": "static INSTRUCTION *\nmk_function(INSTRUCTION *fi, INSTRUCTION *def)\n{\n\tNODE *thisfunc;\n\n\tthisfunc = fi->func_body;\n\tassert(thisfunc != NULL);\n\n\tif (do_optimize && def->lasti->opcode == Op_pop) {\n\t\t/* tail call which does not return any value. */\n\n\t\tINSTRUCTION *t;\n\n\t\tfor (t = def->nexti; t->nexti != def->lasti; t = t->nexti)\n\t\t\t;\n\t\tif (t->opcode == Op_func_call\n\t\t    && strcmp(t->func_name, thisfunc->vname) == 0)\n\t\t\t(t + 1)->tail_call = true;\n\t}\n\n\t/* add any pre-function comment to start of action for profile.c  */\n\n\tif (function_comment != NULL) {\n\t\tfunction_comment->source_line = 0;\n\t\t(void) list_prepend(def, function_comment);\n\t\tfunction_comment = NULL;\n\t}\n\n\t/* add an implicit return at end;\n\t * also used by 'return' command in debugger\n\t */\n\n\t(void) list_append(def, instruction(Op_push_i));\n\tdef->lasti->memory = dupnode(Nnull_string);\n\t(void) list_append(def, instruction(Op_K_return));\n\n\tif (do_pretty_print)\n\t\t(void) list_prepend(def, instruction(Op_exec_count));\n\n\t/* fi->opcode = Op_func */\n\t(fi + 1)->firsti = def->nexti;\n\t(fi + 1)->lasti = def->lasti;\n\t(fi + 2)->first_line = fi->source_line;\n\t(fi + 2)->last_line = lastline;\n\tfi->nexti = def->nexti;\n\tbcfree(def);\n\n\t(void) list_append(rule_list, fi + 1);\t/* debugging */\n\n\t/* update lint table info */\n\tfunc_use(thisfunc->vname, FUNC_DEFINE);\n\n\t/* remove params from symbol table */\n\tremove_params(thisfunc);\n\treturn fi;\n}",
      "lines": 56,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "INSTRUCTION",
        "*\nmk_function(INSTRUCTION *fi, INSTRUCTION *def)",
        "*"
      ]
    },
    "install_function": {
      "start_point": [
        4793,
        0
      ],
      "end_point": [
        4820,
        1
      ],
      "content": "static int\ninstall_function(char *fname, INSTRUCTION *fi, INSTRUCTION *plist)\n{\n\tNODE *r, *f;\n\tint pcount = 0;\n\n\tr = lookup(fname);\n\tif (r != NULL) {\n\t\terror_ln(fi->source_line, _(\"function name `%s' previously defined\"), fname);\n\t\treturn -1;\n\t}\n\n\tif (plist != NULL)\n\t\tpcount = plist->lasti->param_count + 1;\n\tf = install_symbol(fname, Node_func);\n\tfi->func_body = f;\n\tf->param_cnt = pcount;\n\tf->code_ptr = fi;\n\tf->fparms = NULL;\n\tif (pcount > 0) {\n\t\tchar **pnames;\n\t\tpnames = check_params(fname, pcount, plist);\t/* frees plist */\n\t\tf->fparms = make_params(pnames, pcount);\n\t\tefree(pnames);\n\t\tinstall_params(f);\n\t}\n\treturn 0;\n}",
      "lines": 28,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "check_params": {
      "start_point": [
        4827,
        0
      ],
      "end_point": [
        4869,
        1
      ],
      "content": "static char **\ncheck_params(char *fname, int pcount, INSTRUCTION *list)\n{\n\tINSTRUCTION *p, *np;\n\tint i, j;\n\tchar *name;\n\tchar **pnames;\n\n\tassert(pcount > 0);\n\n\temalloc(pnames, char **, pcount * sizeof(char *), \"check_params\");\n\n\tfor (i = 0, p = list->nexti; p != NULL; i++, p = np) {\n\t\tnp = p->nexti;\n\t\tname = p->lextok;\n\t\tp->lextok = NULL;\n\n\t\tif (strcmp(name, fname) == 0) {\n\t\t\t/* check for function foo(foo) { ... }.  bleah. */\n\t\t\terror_ln(p->source_line,\n\t\t\t\t_(\"function `%s': can't use function name as parameter name\"), fname);\n\t\t} else if (is_std_var(name)) {\n\t\t\terror_ln(p->source_line,\n\t\t\t\t_(\"function `%s': can't use special variable `%s' as a function parameter\"),\n\t\t\t\t\tfname, name);\n\t\t}\n\n\t\t/* check for duplicate parameters */\n\t\tfor (j = 0; j < i; j++) {\n\t\t\tif (strcmp(name, pnames[j]) == 0) {\n\t\t\t\terror_ln(p->source_line,\n\t\t\t\t\t_(\"function `%s': parameter #%d, `%s', duplicates parameter #%d\"),\n\t\t\t\t\tfname, i + 1, name, j + 1);\n\t\t\t}\n\t\t}\n\n\t\tpnames[i] = name;\n\t\tbcfree(p);\n\t}\n\tbcfree(list);\n\n\treturn pnames;\n}",
      "lines": 43,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "char",
        "**\ncheck_params(char *fname, int pcount, INSTRUCTION *list)",
        "*",
        "*\ncheck_params(char *fname, int pcount, INSTRUCTION *list)",
        "*"
      ]
    },
    "func_use": {
      "start_point": [
        4887,
        0
      ],
      "end_point": [
        4917,
        1
      ],
      "content": "static void\nfunc_use(const char *name, enum defref how)\n{\n\tstruct fdesc *fp;\n\tint len;\n\tint ind;\n\n\tlen = strlen(name);\n\tind = hash(name, len, HASHSIZE, NULL);\n\n\tfor (fp = ftable[ind]; fp != NULL; fp = fp->next)\n\t\tif (strcmp(fp->name, name) == 0)\n\t\t\tgoto update_value;\n\n\t/* not in the table, fall through to allocate a new one */\n\n\tezalloc(fp, struct fdesc *, sizeof(struct fdesc), \"func_use\");\n\temalloc(fp->name, char *, len + 1, \"func_use\");\n\tstrcpy(fp->name, name);\n\tfp->next = ftable[ind];\n\tftable[ind] = fp;\n\nupdate_value:\n\tif (how == FUNC_DEFINE)\n\t\tfp->defined++;\n\telse if (how == FUNC_EXT) {\n\t\tfp->defined++;\n\t\tfp->extension++;\n\t} else\n\t\tfp->used++;\n}",
      "lines": 31,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "track_ext_func": {
      "start_point": [
        4921,
        0
      ],
      "end_point": [
        4925,
        1
      ],
      "content": "void\ntrack_ext_func(const char *name)\n{\n\tfunc_use(name, FUNC_EXT);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "check_funcs": {
      "start_point": [
        4929,
        0
      ],
      "end_point": [
        4970,
        1
      ],
      "content": "static void\ncheck_funcs()\n{\n\tstruct fdesc *fp, *next;\n\tint i;\n\n\tif (! in_main_context())\n\t\tgoto free_mem;\n\n\tfor (i = 0; i < HASHSIZE; i++) {\n\t\tfor (fp = ftable[i]; fp != NULL; fp = fp->next) {\n#ifdef REALLYMEAN\n\t\t\t/* making this the default breaks old code. sigh. */\n\t\t\tif (fp->defined == 0 && ! fp->extension) {\n\t\t\t\terror(\n\t\t_(\"function `%s' called but never defined\"), fp->name);\n\t\t\t\terrcount++;\n\t\t\t}\n#else\n\t\t\tif (do_lint && fp->defined == 0 && ! fp->extension)\n\t\t\t\tlintwarn(\n\t\t_(\"function `%s' called but never defined\"), fp->name);\n#endif\n\n\t\t\tif (do_lint && fp->used == 0 && ! fp->extension) {\n\t\t\t\tlintwarn(_(\"function `%s' defined but never called directly\"),\n\t\t\t\t\tfp->name);\n\t\t\t}\n\t\t}\n\t}\n\nfree_mem:\n\t/* now let's free all the memory */\n\tfor (i = 0; i < HASHSIZE; i++) {\n\t\tfor (fp = ftable[i]; fp != NULL; fp = next) {\n\t\t\tnext = fp->next;\n\t\t\tefree(fp->name);\n\t\t\tefree(fp);\n\t\t}\n\t\tftable[i] = NULL;\n\t}\n}",
      "lines": 42,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "param_sanity": {
      "start_point": [
        4974,
        0
      ],
      "end_point": [
        4990,
        1
      ],
      "content": "static void\nparam_sanity(INSTRUCTION *arglist)\n{\n\tINSTRUCTION *argl, *arg;\n\tint i = 1;\n\n\tif (arglist == NULL)\n\t\treturn;\n\tfor (argl = arglist->nexti; argl; ) {\n\t\targ = argl->lasti;\n\t\tif (arg->opcode == Op_match_rec)\n\t\t\twarning_ln(arg->source_line,\n\t\t\t\t_(\"regexp constant for parameter #%d yields boolean value\"), i);\n\t\targl = arg->nexti;\n\t\ti++;\n\t}\n}",
      "lines": 17,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "variable": {
      "start_point": [
        4994,
        0
      ],
      "end_point": [
        5009,
        1
      ],
      "content": "NODE *\nvariable(int location, char *name, NODETYPE type)\n{\n\tNODE *r;\n\n\tif ((r = lookup(name)) != NULL) {\n\t\tif (r->type == Node_func || r->type == Node_ext_func )\n\t\t\terror_ln(location, _(\"function `%s' called with space between name and `(',\\nor used as a variable or an array\"),\n\t\t\t\tr->vname);\n\t} else {\n\t\t/* not found */\n\t\treturn install_symbol(name, type);\n\t}\n\tefree(name);\n\treturn r;\n}",
      "lines": 16,
      "depth": 12,
      "decorators": [
        "NODE",
        "*\nvariable(int location, char *name, NODETYPE type)",
        "*"
      ]
    },
    "make_regnode": {
      "start_point": [
        5013,
        0
      ],
      "end_point": [
        5040,
        1
      ],
      "content": "NODE *\nmake_regnode(int type, NODE *exp)\n{\n\tNODE *n;\n\n\tassert(type == Node_regex || type == Node_dynregex);\n\tgetnode(n);\n\tmemset(n, 0, sizeof(NODE));\n\tn->type = type;\n\tn->re_cnt = 1;\n\n\tif (type == Node_regex) {\n\t\tn->re_reg[0] = make_regexp(exp->stptr, exp->stlen, false, true, false);\n\t\tif (n->re_reg[0] == NULL) {\n\t\t\tfreenode(n);\n\t\t\treturn NULL;\n\t\t}\n\t\tn->re_reg[1] = make_regexp(exp->stptr, exp->stlen, true, true, false);\n\t\tif (n->re_reg[1] == NULL) {\n\t\t\trefree(n->re_reg[0]);\n\t\t\tfreenode(n);\n\t\t\treturn NULL;\n\t\t}\n\t\tn->re_exp = exp;\n\t\tn->re_flags = CONSTANT;\n\t}\n\treturn n;\n}",
      "lines": 28,
      "depth": 12,
      "decorators": [
        "NODE",
        "*\nmake_regnode(int type, NODE *exp)",
        "*"
      ]
    },
    "mk_rexp": {
      "start_point": [
        5045,
        0
      ],
      "end_point": [
        5063,
        1
      ],
      "content": "static NODE *\nmk_rexp(INSTRUCTION *list)\n{\n\tINSTRUCTION *ip;\n\n\tip = list->nexti;\n\tif (ip == list->lasti && ip->opcode == Op_match_rec)\n\t\tip->opcode = Op_push_re;\n\telse if (ip == list->lasti && ip->opcode == Op_push_re)\n\t\t; /* do nothing --- @/.../ */\n\telse {\n\t\tip = instruction(Op_push_re);\n\t\tip->memory = make_regnode(Node_dynregex, NULL);\n\t\tip->nexti = list->lasti->nexti;\n\t\tlist->lasti->nexti = ip;\n\t\tlist->lasti = ip;\n\t}\n\treturn ip->memory;\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "NODE",
        "*\nmk_rexp(INSTRUCTION *list)",
        "*"
      ]
    },
    "isnoeffect": {
      "start_point": [
        5068,
        0
      ],
      "end_point": [
        5107,
        1
      ],
      "content": "static int\nisnoeffect(OPCODE type)\n{\n\tswitch (type) {\n\tcase Op_times:\n\tcase Op_times_i:\n\tcase Op_quotient:\n\tcase Op_quotient_i:\n\tcase Op_mod:\n\tcase Op_mod_i:\n\tcase Op_plus:\n\tcase Op_plus_i:\n\tcase Op_minus:\n\tcase Op_minus_i:\n\tcase Op_subscript:\n\tcase Op_concat:\n\tcase Op_exp:\n\tcase Op_exp_i:\n\tcase Op_unary_minus:\n\tcase Op_field_spec:\n\tcase Op_and_final:\n\tcase Op_or_final:\n\tcase Op_equal:\n\tcase Op_notequal:\n\tcase Op_less:\n\tcase Op_greater:\n\tcase Op_leq:\n\tcase Op_geq:\n\tcase Op_match:\n\tcase Op_nomatch:\n\tcase Op_match_rec:\n\tcase Op_not:\n\tcase Op_in_array:\n\t\treturn true;\n\tdefault:\n\t\tbreak;\t/* keeps gcc -Wall happy */\n\t}\n\n\treturn false;\n}",
      "lines": 40,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "make_assignable": {
      "start_point": [
        5113,
        0
      ],
      "end_point": [
        5130,
        1
      ],
      "content": "static INSTRUCTION *\nmake_assignable(INSTRUCTION *ip)\n{\n\tswitch (ip->opcode) {\n\tcase Op_push:\n\t\tip->opcode = Op_push_lhs;\n\t\treturn ip;\n\tcase Op_field_spec:\n\t\tip->opcode = Op_field_spec_lhs;\n\t\treturn ip;\n\tcase Op_subscript:\n\t\tip->opcode = Op_subscript_lhs;\n\t\treturn ip;\n\tdefault:\n\t\tbreak;\t/* keeps gcc -Wall happy */\n\t}\n\treturn NULL;\n}",
      "lines": 18,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "INSTRUCTION",
        "*\nmake_assignable(INSTRUCTION *ip)",
        "*"
      ]
    },
    "stopme": {
      "start_point": [
        5134,
        0
      ],
      "end_point": [
        5138,
        1
      ],
      "content": "NODE *\nstopme(int nargs ATTRIBUTE_UNUSED)\n{\n\treturn make_number(0.0);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "NODE",
        "*\nstopme(int nargs ATTRIBUTE_UNUSED)",
        "*"
      ]
    },
    "dumpintlstr": {
      "start_point": [
        5142,
        0
      ],
      "end_point": [
        5161,
        1
      ],
      "content": "static void\ndumpintlstr(const char *str, size_t len)\n{\n\tchar *cp;\n\n\t/* See the GNU gettext distribution for details on the file format */\n\n\tif (source != NULL) {\n\t\t/* ala the gettext sources, remove leading `./'s */\n\t\tfor (cp = source; cp[0] == '.' && cp[1] == '/'; cp += 2)\n\t\t\tcontinue;\n\t\tprintf(\"#: %s:%d\\n\", cp, sourceline);\n\t}\n\n\tprintf(\"msgid \");\n\tpp_string_fp(fprintf, stdout, str, len, '\"', true);\n\tputchar('\\n');\n\tprintf(\"msgstr \\\"\\\"\\n\\n\");\n\tfflush(stdout);\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "dumpintlstr2": {
      "start_point": [
        5165,
        0
      ],
      "end_point": [
        5187,
        1
      ],
      "content": "static void\ndumpintlstr2(const char *str1, size_t len1, const char *str2, size_t len2)\n{\n\tchar *cp;\n\n\t/* See the GNU gettext distribution for details on the file format */\n\n\tif (source != NULL) {\n\t\t/* ala the gettext sources, remove leading `./'s */\n\t\tfor (cp = source; cp[0] == '.' && cp[1] == '/'; cp += 2)\n\t\t\tcontinue;\n\t\tprintf(\"#: %s:%d\\n\", cp, sourceline);\n\t}\n\n\tprintf(\"msgid \");\n\tpp_string_fp(fprintf, stdout, str1, len1, '\"', true);\n\tputchar('\\n');\n\tprintf(\"msgid_plural \");\n\tpp_string_fp(fprintf, stdout, str2, len2, '\"', true);\n\tputchar('\\n');\n\tprintf(\"msgstr[0] \\\"\\\"\\nmsgstr[1] \\\"\\\"\\n\\n\");\n\tfflush(stdout);\n}",
      "lines": 23,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mk_binary": {
      "start_point": [
        5191,
        0
      ],
      "end_point": [
        5296,
        1
      ],
      "content": "static INSTRUCTION *\nmk_binary(INSTRUCTION *s1, INSTRUCTION *s2, INSTRUCTION *op)\n{\n\tINSTRUCTION *ip1,*ip2;\n\tAWKNUM res;\n\n\tip2 = s2->nexti;\n\tif (s2->lasti == ip2 && ip2->opcode == Op_push_i) {\n\t/* do any numeric constant folding */\n\t\tip1 = s1->nexti;\n\t\tif (do_optimize\n\t\t\t\t&& ip1 == s1->lasti && ip1->opcode == Op_push_i\n\t\t\t\t&& (ip1->memory->flags & (MPFN|MPZN|STRCUR|STRING)) == 0\n\t\t\t\t&& (ip2->memory->flags & (MPFN|MPZN|STRCUR|STRING)) == 0\n\t\t) {\n\t\t\tNODE *n1 = ip1->memory, *n2 = ip2->memory;\n\t\t\tres = force_number(n1)->numbr;\n\t\t\t(void) force_number(n2);\n\t\t\tswitch (op->opcode) {\n\t\t\tcase Op_times:\n\t\t\t\tres *= n2->numbr;\n\t\t\t\tbreak;\n\t\t\tcase Op_quotient:\n\t\t\t\tif (n2->numbr == 0.0) {\n\t\t\t\t\t/* don't fatalize, allow parsing rest of the input */\n\t\t\t\t\terror_ln(op->source_line, _(\"division by zero attempted\"));\n\t\t\t\t\tgoto regular;\n\t\t\t\t}\n\n\t\t\t\tres /= n2->numbr;\n\t\t\t\tbreak;\n\t\t\tcase Op_mod:\n\t\t\t\tif (n2->numbr == 0.0) {\n\t\t\t\t\t/* don't fatalize, allow parsing rest of the input */\n\t\t\t\t\terror_ln(op->source_line, _(\"division by zero attempted in `%%'\"));\n\t\t\t\t\tgoto regular;\n\t\t\t\t}\n#ifdef HAVE_FMOD\n\t\t\t\tres = fmod(res, n2->numbr);\n#else\t/* ! HAVE_FMOD */\n\t\t\t\t(void) modf(res / n2->numbr, &res);\n\t\t\t\tres = n1->numbr - res * n2->numbr;\n#endif\t/* ! HAVE_FMOD */\n\t\t\t\tbreak;\n\t\t\tcase Op_plus:\n\t\t\t\tres += n2->numbr;\n\t\t\t\tbreak;\n\t\t\tcase Op_minus:\n\t\t\t\tres -= n2->numbr;\n\t\t\t\tbreak;\n\t\t\tcase Op_exp:\n\t\t\t\tres = calc_exp(res, n2->numbr);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgoto regular;\n\t\t\t}\n\n\t\t\top->opcode = Op_push_i;\n\t\t\t// We don't need to call set_profile_text() here since\n\t\t\t// optimizing is disabled when doing pretty printing.\n\t\t\top->memory = make_number(res);\n\t\t\tunref(n1);\n\t\t\tunref(n2);\n\t\t\tbcfree(ip1);\n\t\t\tbcfree(ip2);\n\t\t\tbcfree(s1);\n\t\t\tbcfree(s2);\n\t\t\treturn list_create(op);\n\t\t} else {\n\t\t/* do basic arithmetic optimisation */\n\t\t/* convert (Op_push_i Node_val) + (Op_plus) to (Op_plus_i Node_val) */\n\t\t\tswitch (op->opcode) {\n\t\t\tcase Op_times:\n\t\t\t\top->opcode = Op_times_i;\n\t\t\t\tbreak;\n\t\t\tcase Op_quotient:\n\t\t\t\top->opcode = Op_quotient_i;\n\t\t\t\tbreak;\n\t\t\tcase Op_mod:\n\t\t\t\top->opcode = Op_mod_i;\n\t\t\t\tbreak;\n\t\t\tcase Op_plus:\n\t\t\t\top->opcode = Op_plus_i;\n\t\t\t\tbreak;\n\t\t\tcase Op_minus:\n\t\t\t\top->opcode = Op_minus_i;\n\t\t\t\tbreak;\n\t\t\tcase Op_exp:\n\t\t\t\top->opcode = Op_exp_i;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgoto regular;\n\t\t\t}\n\n\t\t\top->memory = ip2->memory;\n\t\t\tbcfree(ip2);\n\t\t\tbcfree(s2);\t/* Op_list */\n\t\t\treturn list_append(s1, op);\n\t\t}\n\t}\n\nregular:\n\t/* append lists s1, s2 and add `op' bytecode */\n\t(void) list_merge(s1, s2);\n\treturn list_append(s1, op);\n}",
      "lines": 106,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "INSTRUCTION",
        "*\nmk_binary(INSTRUCTION *s1, INSTRUCTION *s2, INSTRUCTION *op)",
        "*"
      ]
    },
    "mk_boolean": {
      "start_point": [
        5300,
        0
      ],
      "end_point": [
        5346,
        1
      ],
      "content": "static INSTRUCTION *\nmk_boolean(INSTRUCTION *left, INSTRUCTION *right, INSTRUCTION *op)\n{\n\tINSTRUCTION *tp;\n\tOPCODE opc, final_opc;\n\n\topc = op->opcode;\t\t/* Op_and or Op_or */\n\tfinal_opc = (opc == Op_or) ? Op_or_final : Op_and_final;\n\n\tadd_lint(right, LINT_assign_in_cond);\n\n\ttp = left->lasti;\n\n\tif (tp->opcode != final_opc) {\t/* x || y */\n\t\tlist_append(right, instruction(final_opc));\n\t\tadd_lint(left, LINT_assign_in_cond);\n\t\t(void) list_append(left, op);\n\t\tleft->lasti->target_jmp = right->lasti;\n\n\t\t/* NB: target_stmt points to previous Op_and(Op_or) in a chain;\n\t\t *     target_stmt only used in the parser (see below).\n\t\t */\n\n\t\tleft->lasti->target_stmt = left->lasti;\n\t\tright->lasti->target_stmt = left->lasti;\n\t} else {\t\t/* optimization for x || y || z || ... */\n\t\tINSTRUCTION *ip;\n\n\t\top->opcode = final_opc;\n\t\t(void) list_append(right, op);\n\t\top->target_stmt = tp;\n\t\ttp->opcode = opc;\n\t\ttp->target_jmp = op;\n\n\t\t/* update jump targets */\n\t\tfor (ip = tp->target_stmt; ; ip = ip->target_stmt) {\n\t\t\tassert(ip->opcode == opc);\n\t\t\tassert(ip->target_jmp == tp);\n\t\t\t/* if (ip->opcode == opc &&  ip->target_jmp == tp) */\n\t\t\tip->target_jmp = op;\n\t\t\tif (ip->target_stmt == ip)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn list_merge(left, right);\n}",
      "lines": 47,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "INSTRUCTION",
        "*\nmk_boolean(INSTRUCTION *left, INSTRUCTION *right, INSTRUCTION *op)",
        "*"
      ]
    },
    "mk_condition": {
      "start_point": [
        5350,
        0
      ],
      "end_point": [
        5415,
        1
      ],
      "content": "static INSTRUCTION *\nmk_condition(INSTRUCTION *cond, INSTRUCTION *ifp, INSTRUCTION *true_branch,\n\t\tINSTRUCTION *elsep, INSTRUCTION *false_branch)\n{\n\t/*\n\t *    ----------------\n\t *       cond\n\t *    ----------------\n\t * t: [Op_jmp_false f ]\n\t *    ----------------\n\t *       true_branch\n\t *\n\t *    ----------------\n\t *    [Op_jmp y]\n\t *    ----------------\n\t * f:\n\t *      false_branch\n\t *    ----------------\n\t * y: [Op_no_op]\n\t *    ----------------\n\t */\n\n\tINSTRUCTION *ip;\n\tbool setup_else_part = true;\n\n\tif (false_branch == NULL) {\n\t\tfalse_branch = list_create(instruction(Op_no_op));\n\t\tif (elsep == NULL) {\t\t/* else { } */\n\t\t\tsetup_else_part = false;\n\t\t}\n\t} else {\n\t\t/* assert(elsep != NULL); */\n\n\t\t/* avoid a series of no_op's: if .. else if .. else if .. */\n\t\tif (false_branch->lasti->opcode != Op_no_op)\n\t\t\t(void) list_append(false_branch, instruction(Op_no_op));\n\t}\n\n\tif (setup_else_part) {\n\t\tif (do_pretty_print) {\n\t\t\t(void) list_prepend(false_branch, elsep);\n\t\t\tfalse_branch->nexti->branch_end = false_branch->lasti;\n\t\t\t(void) list_prepend(false_branch, instruction(Op_exec_count));\n\t\t} else\n\t\t\tbcfree(elsep);\n\t}\n\n\t(void) list_prepend(false_branch, instruction(Op_jmp));\n\tfalse_branch->nexti->target_jmp = false_branch->lasti;\n\n\tadd_lint(cond, LINT_assign_in_cond);\n\tip = list_append(cond, instruction(Op_jmp_false));\n\tip->lasti->target_jmp = false_branch->nexti->nexti;\n\n\tif (do_pretty_print) {\n\t\t(void) list_prepend(ip, ifp);\n\t\t(void) list_append(ip, instruction(Op_exec_count));\n\t\tip->nexti->branch_if = ip->lasti;\n\t\tip->nexti->branch_else = false_branch->nexti;\n\t} else\n\t\tbcfree(ifp);\n\n\tif (true_branch != NULL)\n\t\tlist_merge(ip, true_branch);\n\treturn list_merge(ip, false_branch);\n}",
      "lines": 66,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "INSTRUCTION",
        "*\nmk_condition(INSTRUCTION *cond, INSTRUCTION *ifp, INSTRUCTION *true_branch,\n\t\tINSTRUCTION *elsep, INSTRUCTION *false_branch)",
        "*"
      ]
    },
    "find_line": {
      "start_point": [
        5421,
        0
      ],
      "end_point": [
        5441,
        1
      ],
      "content": "static int\nfind_line(INSTRUCTION *pattern, enum defline what)\n{\n\tINSTRUCTION *ip;\n\tint lineno = 0;\n\n\tfor (ip = pattern->nexti; ip; ip = ip->nexti) {\n\t\tif (what == LAST_LINE) {\n\t\t\tif (ip->source_line > lineno)\n\t\t\t\tlineno = ip->source_line;\n\t\t} else {\t/* FIRST_LINE */\n\t\t\tif (ip->source_line > 0\n\t\t\t\t\t&& (lineno == 0 || ip->source_line < lineno))\n\t\t\t\tlineno = ip->source_line;\n\t\t}\n\t\tif (ip == pattern->lasti)\n\t\t\tbreak;\n\t}\n\tassert(lineno > 0);\n\treturn lineno;\n}",
      "lines": 21,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "append_rule": {
      "start_point": [
        5445,
        0
      ],
      "end_point": [
        5528,
        1
      ],
      "content": "static INSTRUCTION *\nappend_rule(INSTRUCTION *pattern, INSTRUCTION *action)\n{\n\t/*\n\t *    ----------------\n\t *       pattern\n\t *    ----------------\n\t *    [Op_jmp_false f ]\n\t *    ----------------\n\t *       action\n\t *    ----------------\n\t * f: [Op_no_op       ]\n\t *    ----------------\n\t */\n\n\tINSTRUCTION *rp;\n\tINSTRUCTION *tp;\n\tINSTRUCTION *ip;\n\n\tif (rule != Rule) {\n\t\trp = pattern;\n\t\tif (do_pretty_print)\n\t\t\t(void) list_append(action, instruction(Op_no_op));\n\t\t(rp + 1)->firsti = action->nexti;\n\t\t(rp + 1)->lasti = action->lasti;\n\t\t(rp + 2)->first_line = pattern->source_line;\n\t\t(rp + 2)->last_line = lastline;\n\t\tif (block_comment != NULL) {\n\t\t\tip = list_prepend(list_prepend(action, block_comment), rp);\n\t\t\tblock_comment = NULL;\n\t\t} else\n\t\t\tip = list_prepend(action, rp);\n\n\t} else {\n\t\trp = bcalloc(Op_rule, 3, 0);\n\t\trp->in_rule = Rule;\n\t\trp->source_file = source;\n\t\ttp = instruction(Op_no_op);\n\n\t\tif (pattern == NULL) {\n\t\t\t/* assert(action != NULL); */\n\t\t\tif (do_pretty_print)\n\t\t\t\t(void) list_prepend(action, instruction(Op_exec_count));\n\t\t\t(rp + 1)->firsti = action->nexti;\n\t\t\t(rp + 1)->lasti = tp;\n\t\t\t(rp + 2)->first_line = firstline;\n\t\t\t(rp + 2)->last_line = lastline;\n\t\t\trp->source_line = firstline;\n\t\t\tip = list_prepend(list_append(action, tp), rp);\n\t\t} else {\n\t\t\t(void) list_append(pattern, instruction(Op_jmp_false));\n\t\t\tpattern->lasti->target_jmp = tp;\n\t\t\t(rp + 2)->first_line = find_line(pattern, FIRST_LINE);\n\t\t\trp->source_line = (rp + 2)->first_line;\n\t\t\tif (action == NULL) {\n\t\t\t\t(rp + 2)->last_line = find_line(pattern, LAST_LINE);\n\t\t\t\taction = list_create(instruction(Op_K_print_rec));\n\t\t\t\tif (do_pretty_print)\n\t\t\t\t\t(void) list_prepend(action, instruction(Op_exec_count));\n\t\t\t} else\n\t\t\t\t(rp + 2)->last_line = lastline;\n\n\t\t\tif (do_pretty_print) {\n\t\t\t\t(void) list_prepend(pattern, instruction(Op_exec_count));\n\t\t\t\t(void) list_prepend(action, instruction(Op_exec_count));\n\t\t\t}\n \t\t\t(rp + 1)->firsti = action->nexti;\n\t\t\t(rp + 1)->lasti = tp;\n\t\t\tip = list_append(\n\t\t\t\t\tlist_merge(list_prepend(pattern, rp),\n\t\t\t\t\t\taction),\n\t\t\t\t\ttp);\n\t\t}\n\t}\n\n\tlist_append(rule_list, rp + 1);\n\n\tif (rule_block[rule] == NULL)\n\t\trule_block[rule] = ip;\n\telse\n\t\t(void) list_merge(rule_block[rule], ip);\n\n\treturn rule_block[rule];\n}",
      "lines": 84,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "INSTRUCTION",
        "*\nappend_rule(INSTRUCTION *pattern, INSTRUCTION *action)",
        "*"
      ]
    },
    "mk_assignment": {
      "start_point": [
        5532,
        0
      ],
      "end_point": [
        5586,
        1
      ],
      "content": "static INSTRUCTION *\nmk_assignment(INSTRUCTION *lhs, INSTRUCTION *rhs, INSTRUCTION *op)\n{\n\tINSTRUCTION *tp;\n\tINSTRUCTION *ip;\n\n\ttp = lhs->lasti;\n\tswitch (tp->opcode) {\n\tcase Op_field_spec:\n\t\ttp->opcode = Op_field_spec_lhs;\n\t\tbreak;\n\tcase Op_subscript:\n\t\ttp->opcode = Op_subscript_lhs;\n\t\tbreak;\n\tcase Op_push:\n\tcase Op_push_array:\n\t\ttp->opcode = Op_push_lhs;\n\t\tbreak;\n\tcase Op_field_assign:\n\t\tyyerror(_(\"cannot assign a value to the result of a field post-increment expression\"));\n\t\tbreak;\n\tdefault:\n\t\tyyerror(_(\"invalid target of assignment (opcode %s)\"),\n\t\t\t\topcode2str(tp->opcode));\n\t\tbreak;\n\t}\n\n\ttp->do_reference = (op->opcode != Op_assign);\t/* check for uninitialized reference */\n\n\tif (rhs != NULL)\n\t\tip = list_merge(rhs, lhs);\n\telse\n\t\tip = lhs;\n\n\t(void) list_append(ip, op);\n\n\tif (tp->opcode == Op_push_lhs\n\t\t\t&& tp->memory->type == Node_var\n\t\t\t&& tp->memory->var_assign\n\t) {\n\t\ttp->do_reference = false; /* no uninitialized reference checking\n\t\t                           * for a special variable.\n\t\t                           */\n\t\t(void) list_append(ip, instruction(Op_var_assign));\n\t\tip->lasti->assign_var = tp->memory->var_assign;\n\t} else if (tp->opcode == Op_field_spec_lhs) {\n\t\t(void) list_append(ip, instruction(Op_field_assign));\n\t\tip->lasti->field_assign = (Func_ptr) 0;\n\t\ttp->target_assign = ip->lasti;\n\t} else if (tp->opcode == Op_subscript_lhs) {\n\t\t(void) list_append(ip, instruction(Op_subscript_assign));\n\t}\n\n\treturn ip;\n}",
      "lines": 55,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "INSTRUCTION",
        "*\nmk_assignment(INSTRUCTION *lhs, INSTRUCTION *rhs, INSTRUCTION *op)",
        "*"
      ]
    },
    "optimize_assignment": {
      "start_point": [
        5590,
        0
      ],
      "end_point": [
        5743,
        1
      ],
      "content": "static INSTRUCTION *\noptimize_assignment(INSTRUCTION *exp)\n{\n\tINSTRUCTION *i1, *i2, *i3;\n\n\t/*\n\t * Optimize assignment statements array[subs] = x; var = x; $n = x;\n\t * string concatenation of the form s = s t.\n\t *\n\t * 1) Array element assignment array[subs] = x:\n\t *   Replaces Op_push_array + Op_subscript_lhs + Op_assign + Op_pop\n\t *   with single instruction Op_store_sub.\n\t *\t Limitation: 1 dimension and sub is simple var/value.\n\t *\n\t * 2) Simple variable assignment var = x:\n\t *   Replaces Op_push_lhs + Op_assign + Op_pop with Op_store_var.\n\t *\n\t * 3) Field assignment $n = x:\n\t *   Replaces Op_field_spec_lhs + Op_assign + Op_field_assign + Op_pop\n\t *   with Op_store_field.\n\t *\n\t * 4) Optimization for string concatenation:\n\t *   For cases like x = x y, uses realloc to include y in x;\n\t *   also eliminates instructions Op_push_lhs and Op_pop.\n\t */\n\n\t/*\n\t * N.B.: do not append Op_pop instruction to the returned\n\t * instruction list if optimized. None of these\n\t * optimized instructions pushes the r-value of assignment\n\t * onto the runtime stack.\n\t */\n\n\ti2 = NULL;\n\ti1 = exp->lasti;\n\n\tif (   i1->opcode != Op_assign\n\t    && i1->opcode != Op_field_assign)\n\t\treturn list_append(exp, instruction(Op_pop));\n\n\tfor (i2 = exp->nexti; i2 != i1; i2 = i2->nexti) {\n\t\tswitch (i2->opcode) {\n\t\tcase Op_concat:\n\t\t\tif (i2->nexti->opcode == Op_push_lhs    /* l.h.s is a simple variable */\n\t\t\t\t&& (i2->concat_flag & CSVAR) != 0   /* 1st exp in r.h.s is a simple variable;\n\t\t\t\t                                     * see Op_concat in the grammer above.\n\t\t\t\t                                     */\n\t\t\t\t&& i2->nexti->memory == exp->nexti->memory\t /* and the same as in l.h.s */\n\t\t\t\t&& i2->nexti->nexti == i1\n\t\t\t\t&& i1->opcode == Op_assign\n\t\t\t) {\n\t\t\t\t/* s = s ... optimization */\n\n\t\t\t\t/* avoid stuff like x = x (x = y) or x = x gsub(/./, \"b\", x);\n\t\t\t\t * check for l-value reference to this variable in the r.h.s.\n\t\t\t\t * Also, avoid function calls in general to guard against\n\t\t\t\t * global variable assignment.\n\t\t\t\t */\n\n\t\t\t\tfor (i3 = exp->nexti->nexti; i3 != i2; i3 = i3->nexti) {\n\t\t\t\t\tif ((i3->opcode == Op_push_lhs && i3->memory == i2->nexti->memory)\n\t\t\t\t\t\t\t|| i3->opcode == Op_func_call)\n\t\t\t\t\t\treturn list_append(exp, instruction(Op_pop)); /* no optimization */\n\t\t\t\t}\n\n\t\t\t\t/* remove the variable from r.h.s */\n\t\t\t\ti3 = exp->nexti;\n\t\t\t\texp->nexti = i3->nexti;\n\t\t\t\tbcfree(i3);\n\n\t\t\t\tif (--i2->expr_count == 1)\t/* one less expression in Op_concat */\n\t\t\t\t\ti2->opcode = Op_no_op;\n\n\t\t\t\ti3 = i2->nexti;\n\t\t\t\tassert(i3->opcode == Op_push_lhs);\n\t\t\t\ti3->opcode = Op_assign_concat;\t/* change Op_push_lhs to Op_assign_concat */\n\t\t\t\ti3->nexti = NULL;\n\t\t\t\tbcfree(i1);          /* Op_assign */\n\t\t\t\texp->lasti = i3;     /* update Op_list */\n\t\t\t\treturn exp;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase Op_field_spec_lhs:\n\t\t\tif (i2->nexti->opcode == Op_assign\n\t\t\t\t\t&& i2->nexti->nexti == i1\n\t\t\t\t\t&& i1->opcode == Op_field_assign\n\t\t\t) {\n\t\t\t\t/* $n = .. */\n\t\t\t\ti2->opcode = Op_store_field;\n\t\t\t\tbcfree(i2->nexti);  /* Op_assign */\n\t\t\t\ti2->nexti = NULL;\n\t\t\t\tbcfree(i1);          /* Op_field_assign */\n\t\t\t\texp->lasti = i2;    /* update Op_list */\n\t\t\t\treturn exp;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase Op_push_array:\n\t\t\tif (i2->nexti->nexti->opcode == Op_subscript_lhs) {\n\t\t\t\ti3 = i2->nexti->nexti;\n\t\t\t\tif (i3->sub_count == 1\n\t\t\t\t\t\t&& i3->nexti == i1\n\t\t\t\t\t\t&& i1->opcode == Op_assign\n\t\t\t\t) {\n\t\t\t\t\t/* array[sub] = .. */\n\t\t\t\t\ti3->opcode = Op_store_sub;\n\t\t\t\t\ti3->memory = i2->memory;\n\t\t\t\t\ti3->expr_count = 1;  /* sub_count shadows memory,\n                                          * so use expr_count instead.\n\t\t\t\t                          */\n\t\t\t\t\ti3->nexti = NULL;\n\t\t\t\t\ti2->opcode = Op_no_op;\n\t\t\t\t\tbcfree(i1);          /* Op_assign */\n\t\t\t\t\texp->lasti = i3;     /* update Op_list */\n\t\t\t\t\treturn exp;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase Op_push_lhs:\n\t\t\tif (i2->nexti == i1\n\t\t\t\t\t&& i1->opcode == Op_assign\n\t\t\t) {\n\t\t\t\t/* var = .. */\n\t\t\t\ti2->opcode = Op_store_var;\n\t\t\t\ti2->nexti = NULL;\n\t\t\t\tbcfree(i1);          /* Op_assign */\n\t\t\t\texp->lasti = i2;     /* update Op_list */\n\n\t\t\t\ti3 = exp->nexti;\n\t\t\t\tif (i3->opcode == Op_push_i\n\t\t\t\t\t&& (i3->memory->flags & INTLSTR) == 0\n\t\t\t\t\t&& i3->nexti == i2\n\t\t\t\t) {\n\t\t\t\t\t/* constant initializer */\n\t\t\t\t\ti2->initval = i3->memory;\n\t\t\t\t\tbcfree(i3);\n\t\t\t\t\texp->nexti = i2;\n\t\t\t\t} else\n\t\t\t\t\ti2->initval = NULL;\n\n\t\t\t\treturn exp;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* no optimization  */\n\treturn list_append(exp, instruction(Op_pop));\n}",
      "lines": 154,
      "depth": 20,
      "decorators": [
        "static",
        "static",
        "INSTRUCTION",
        "*\noptimize_assignment(INSTRUCTION *exp)",
        "*"
      ]
    },
    "mk_getline": {
      "start_point": [
        5748,
        0
      ],
      "end_point": [
        5808,
        1
      ],
      "content": "static INSTRUCTION *\nmk_getline(INSTRUCTION *op, INSTRUCTION *var, INSTRUCTION *redir, int redirtype)\n{\n\tINSTRUCTION *ip;\n\tINSTRUCTION *tp;\n\tINSTRUCTION *asgn = NULL;\n\n\t/*\n\t *  getline [var] < [file]\n\t *\n\t *  [ file (simp_exp)]\n\t *  [ [ var ] ]\n\t *  [ Op_K_getline_redir|NULL|redir_type|into_var]\n\t *  [ [var_assign] ]\n\t *\n\t */\n\n\tif (redir == NULL) {\n\t\tint sline = op->source_line;\n\t\tbcfree(op);\n\t\top = bcalloc(Op_K_getline, 2, sline);\n\t\t(op + 1)->target_endfile = ip_endfile;\n\t\t(op + 1)->target_beginfile = ip_beginfile;\n\t}\n\n\tif (var != NULL) {\n\t\ttp = make_assignable(var->lasti);\n\t\tassert(tp != NULL);\n\n\t\t/* check if we need after_assign bytecode */\n\t\tif (tp->opcode == Op_push_lhs\n\t\t\t\t&& tp->memory->type == Node_var\n\t\t\t\t&& tp->memory->var_assign\n\t\t) {\n\t\t\tasgn = instruction(Op_var_assign);\n\t\t\tasgn->assign_ctxt = op->opcode;\n\t\t\tasgn->assign_var = tp->memory->var_assign;\n\t\t} else if (tp->opcode == Op_field_spec_lhs) {\n\t\t\tasgn = instruction(Op_field_assign);\n\t\t\tasgn->assign_ctxt = op->opcode;\n\t\t\tasgn->field_assign = (Func_ptr) 0;   /* determined at run time */\n\t\t\ttp->target_assign = asgn;\n\t\t} else if (tp->opcode == Op_subscript_lhs) {\n\t\t\tasgn = instruction(Op_subscript_assign);\n\t\t\tasgn->assign_ctxt = op->opcode;\n\t\t}\n\n\t\tif (redir != NULL) {\n\t\t\tip = list_merge(redir, var);\n\t\t\t(void) list_append(ip, op);\n\t\t} else\n\t\t\tip = list_append(var, op);\n\t} else if (redir != NULL)\n\t\tip = list_append(redir, op);\n\telse\n\t\tip = list_create(op);\n\top->into_var = (var != NULL);\n\top->redir_type = (redir != NULL) ? redirtype : redirect_none;\n\n\treturn (asgn == NULL ? ip : list_append(ip, asgn));\n}",
      "lines": 61,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "INSTRUCTION",
        "*\nmk_getline(INSTRUCTION *op, INSTRUCTION *var, INSTRUCTION *redir, int redirtype)",
        "*"
      ]
    },
    "mk_for_loop": {
      "start_point": [
        5813,
        0
      ],
      "end_point": [
        5886,
        1
      ],
      "content": "static INSTRUCTION *\nmk_for_loop(INSTRUCTION *forp, INSTRUCTION *init, INSTRUCTION *cond,\n\t\t\t\tINSTRUCTION *incr, INSTRUCTION *body)\n{\n\t/*\n\t *   ------------------------\n\t *        init                 (may be NULL)\n\t *   ------------------------\n\t * x:\n\t *        cond                 (Op_no_op if NULL)\n\t *   ------------------------\n\t *    [ Op_jmp_false tb      ]\n\t *   ------------------------\n\t *        body                 (may be NULL)\n\t *   ------------------------\n\t * tc:\n\t *    incr                      (may be NULL)\n\t *    [ Op_jmp x             ]\n\t *   ------------------------\n\t * tb:[ Op_no_op             ]\n\t */\n\n\tINSTRUCTION *ip, *tbreak, *tcont;\n\tINSTRUCTION *jmp;\n\tINSTRUCTION *pp_cond;\n\tINSTRUCTION *ret;\n\n\ttbreak = instruction(Op_no_op);\n\n\tif (cond != NULL) {\n\t\tadd_lint(cond, LINT_assign_in_cond);\n\t\tpp_cond = cond->nexti;\n\t\tip = cond;\n\t\t(void) list_append(ip, instruction(Op_jmp_false));\n\t\tip->lasti->target_jmp = tbreak;\n\t} else {\n\t\tpp_cond = instruction(Op_no_op);\n\t\tip = list_create(pp_cond);\n\t}\n\n\tif (init != NULL)\n\t\tip = list_merge(init, ip);\n\n\tif (do_pretty_print) {\n\t\t(void) list_append(ip, instruction(Op_exec_count));\n\t\t(forp + 1)->forloop_cond = pp_cond;\n\t\t(forp + 1)->forloop_body = ip->lasti;\n\t}\n\n\tif (body != NULL)\n\t\t(void) list_merge(ip, body);\n\n\tjmp = instruction(Op_jmp);\n\tjmp->target_jmp = pp_cond;\n\tif (incr == NULL)\n\t\ttcont = jmp;\n\telse {\n\t\ttcont = incr->nexti;\n\t\t(void) list_merge(ip, incr);\n\t}\n\n\t(void) list_append(ip, jmp);\n\tret = list_append(ip, tbreak);\n\tfix_break_continue(ret, tbreak, tcont);\n\n\tif (do_pretty_print) {\n\t\tforp->target_break = tbreak;\n\t\tforp->target_continue = tcont;\n\t\tret = list_prepend(ret, forp);\n\t} /* else\n\t\t\tforp is NULL */\n\n\treturn ret;\n}",
      "lines": 74,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "INSTRUCTION",
        "*\nmk_for_loop(INSTRUCTION *forp, INSTRUCTION *init, INSTRUCTION *cond,\n\t\t\t\tINSTRUCTION *incr, INSTRUCTION *body)",
        "*"
      ]
    },
    "add_lint": {
      "start_point": [
        5890,
        0
      ],
      "end_point": [
        5942,
        1
      ],
      "content": "static void\nadd_lint(INSTRUCTION *list, LINTTYPE linttype)\n{\n#ifndef NO_LINT\n\tINSTRUCTION *ip;\n\n\tswitch (linttype) {\n\tcase LINT_assign_in_cond:\n\t\tip = list->lasti;\n\t\tif (ip->opcode == Op_var_assign || ip->opcode == Op_field_assign) {\n\t\t\tassert(ip != list->nexti);\n\t\t\tfor (ip = list->nexti; ip->nexti != list->lasti; ip = ip->nexti)\n\t\t\t\t;\n\t\t}\n\n\t\tif (ip->opcode == Op_assign || ip->opcode == Op_assign_concat) {\n\t\t\tlist_append(list, instruction(Op_lint));\n\t\t\tlist->lasti->lint_type = linttype;\n\t\t}\n\t\tbreak;\n\n\tcase LINT_no_effect:\n\t\tif (list->lasti->opcode == Op_pop && list->nexti != list->lasti) {\n\t\t\tint line = 0;\n\n\t\t\t// Get down to the last instruction (FIXME: why?)\n\t\t\tfor (ip = list->nexti; ip->nexti != list->lasti; ip = ip->nexti) {\n\t\t\t\t// along the way track line numbers, we will use the line\n\t\t\t\t// closest to the opcode if that opcode doesn't have one\n\t\t\t\tif (ip->source_line != 0)\n\t\t\t\t\tline = ip->source_line;\n\t\t\t}\n\n\t\t\tif (do_lint) {\t\t/* compile-time warning */\n\t\t\t\tif (isnoeffect(ip->opcode)) {\n\t\t\t\t\tif (ip->source_line != 0)\n\t\t\t\t\t\tline = ip->source_line;\n\t\t\t\t\tlintwarn_ln(line, (\"statement may have no effect\"));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ip->opcode == Op_push) {\t\t/* run-time warning */\n\t\t\t\tlist_append(list, instruction(Op_lint));\n\t\t\t\tlist->lasti->lint_type = linttype;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n#endif\n}",
      "lines": 53,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mk_expression_list": {
      "start_point": [
        5946,
        0
      ],
      "end_point": [
        5981,
        1
      ],
      "content": "static INSTRUCTION *\nmk_expression_list(INSTRUCTION *list, INSTRUCTION *s1)\n{\n\tINSTRUCTION *r;\n\n\t/* we can't just combine all bytecodes, since we need to\n\t * process individual expressions for a few builtins in snode() (-:\n\t */\n\n\t/* -- list of lists     */\n\t/* [Op_list| ... ]------\n\t *                       |\n\t * [Op_list| ... ]   --  |\n\t *  ...               |  |\n\t *  ...       <-------   |\n\t * [Op_list| ... ]   --  |\n\t *  ...               |  |\n\t *  ...               |  |\n\t *  ...       <------- --\n\t */\n\n\tassert(s1 != NULL && s1->opcode == Op_list);\n\tif (list == NULL) {\n\t\tlist = instruction(Op_list);\n\t\tlist->nexti = s1;\n\t\tlist->lasti = s1->lasti;\n\t\treturn list;\n\t}\n\n\t/* append expression to the end of the list */\n\n\tr = list->lasti;\n\tr->nexti = s1;\n\tlist->lasti = s1->lasti;\n\treturn list;\n}",
      "lines": 36,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "INSTRUCTION",
        "*\nmk_expression_list(INSTRUCTION *list, INSTRUCTION *s1)",
        "*"
      ]
    },
    "count_expressions": {
      "start_point": [
        5988,
        0
      ],
      "end_point": [
        6017,
        1
      ],
      "content": "static int\ncount_expressions(INSTRUCTION **list, bool isarg)\n{\n\tINSTRUCTION *expr;\n\tINSTRUCTION *r = NULL;\n\tint count = 0;\n\n\tif (*list == NULL)\t/* error earlier */\n\t\treturn 0;\n\n\tfor (expr = (*list)->nexti; expr; ) {\n\t\tINSTRUCTION *t1, *t2;\n\t\tt1 = expr->nexti;\n\t\tt2 = expr->lasti;\n\t\tif (isarg && t1 == t2 && t1->opcode == Op_push)\n\t\t\tt1->opcode = Op_push_param;\n\t\tif (++count == 1)\n\t\t\tr = expr;\n\t\telse\n\t\t\t(void) list_merge(r, expr);\n\t\texpr = t2->nexti;\n\t}\n\n\tassert(count > 0);\n\tif (! isarg && count > max_args)\n\t\tmax_args = count;\n\tbcfree(*list);\n\t*list = r;\n\treturn count;\n}",
      "lines": 30,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "fix_break_continue": {
      "start_point": [
        6021,
        0
      ],
      "end_point": [
        6045,
        1
      ],
      "content": "static void\nfix_break_continue(INSTRUCTION *list, INSTRUCTION *b_target, INSTRUCTION *c_target)\n{\n\tINSTRUCTION *ip;\n\n\tlist->lasti->nexti = NULL;\t/* just to make sure */\n\n\tfor (ip = list->nexti; ip != NULL; ip = ip->nexti) {\n\t\tswitch (ip->opcode) {\n\t\tcase Op_K_break:\n\t\t\tif (ip->target_jmp == NULL)\n\t\t\t\tip->target_jmp = b_target;\n\t\t\tbreak;\n\n\t\tcase Op_K_continue:\n\t\t\tif (ip->target_jmp == NULL)\n\t\t\t\tip->target_jmp = c_target;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* this is to keep the compiler happy. sheesh. */\n\t\t\tbreak;\n\t\t}\n\t}\n}",
      "lines": 25,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "list_create": {
      "start_point": [
        6047,
        0
      ],
      "end_point": [
        6056,
        1
      ],
      "content": "static inline INSTRUCTION *\nlist_create(INSTRUCTION *x)\n{\n\tINSTRUCTION *l;\n\n\tl = instruction(Op_list);\n\tl->nexti = x;\n\tl->lasti = x;\n\treturn l;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "INSTRUCTION",
        "*\nlist_create(INSTRUCTION *x)",
        "*"
      ]
    },
    "list_append": {
      "start_point": [
        6058,
        0
      ],
      "end_point": [
        6068,
        1
      ],
      "content": "static inline INSTRUCTION *\nlist_append(INSTRUCTION *l, INSTRUCTION *x)\n{\n#ifdef GAWKDEBUG\n\tif (l->opcode != Op_list)\n\t\tcant_happen();\n#endif\n\tl->lasti->nexti = x;\n\tl->lasti = x;\n\treturn l;\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "INSTRUCTION",
        "*\nlist_append(INSTRUCTION *l, INSTRUCTION *x)",
        "*"
      ]
    },
    "list_prepend": {
      "start_point": [
        6070,
        0
      ],
      "end_point": [
        6080,
        1
      ],
      "content": "static inline INSTRUCTION *\nlist_prepend(INSTRUCTION *l, INSTRUCTION *x)\n{\n#ifdef GAWKDEBUG\n\tif (l->opcode != Op_list)\n\t\tcant_happen();\n#endif\n\tx->nexti = l->nexti;\n\tl->nexti = x;\n\treturn l;\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "INSTRUCTION",
        "*\nlist_prepend(INSTRUCTION *l, INSTRUCTION *x)",
        "*"
      ]
    },
    "list_merge": {
      "start_point": [
        6082,
        0
      ],
      "end_point": [
        6095,
        1
      ],
      "content": "static inline INSTRUCTION *\nlist_merge(INSTRUCTION *l1, INSTRUCTION *l2)\n{\n#ifdef GAWKDEBUG\n\tif (l1->opcode != Op_list)\n\t\tcant_happen();\n\tif (l2->opcode != Op_list)\n\t\tcant_happen();\n#endif\n\tl1->lasti->nexti = l2->nexti;\n\tl1->lasti = l2->lasti;\n\tbcfree(l2);\n\treturn l1;\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "INSTRUCTION",
        "*\nlist_merge(INSTRUCTION *l1, INSTRUCTION *l2)",
        "*"
      ]
    },
    "add_pending_comment": {
      "start_point": [
        6099,
        0
      ],
      "end_point": [
        6115,
        1
      ],
      "content": "static inline INSTRUCTION *\nadd_pending_comment(INSTRUCTION *stmt)\n{\n\tINSTRUCTION *ret = stmt;\n\n\tif (prior_comment != NULL) {\n\t\tif (function_comment != prior_comment)\n\t\t\tret = list_append(stmt, prior_comment);\n\t\tprior_comment = NULL;\n\t} else if (comment != NULL && comment->memory->comment_type == EOL_COMMENT) {\n\t\tif (function_comment != comment)\n\t\t\tret = list_append(stmt, comment);\n\t\tcomment = NULL;\n\t}\n\n\treturn ret;\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "INSTRUCTION",
        "*\nadd_pending_comment(INSTRUCTION *stmt)",
        "*"
      ]
    },
    "check_special": {
      "start_point": [
        6119,
        0
      ],
      "end_point": [
        6160,
        1
      ],
      "content": "int\ncheck_special(const char *name)\n{\n\tint low, high, mid;\n\tint i;\n\tint non_standard_flags = 0;\n#ifdef USE_EBCDIC\n\tstatic bool did_sort = false;\n\n\tif (! did_sort) {\n\t\tqsort((void *) tokentab,\n\t\t\t\tsizeof(tokentab) / sizeof(tokentab[0]),\n\t\t\t\tsizeof(tokentab[0]), tokcompare);\n\t\tdid_sort = true;\n\t}\n#endif\n\n\tif (do_traditional)\n\t\tnon_standard_flags |= GAWKX;\n\tif (do_posix)\n\t\tnon_standard_flags |= NOT_POSIX;\n\n\tlow = 0;\n\thigh = (sizeof(tokentab) / sizeof(tokentab[0])) - 1;\n\twhile (low <= high) {\n\t\tmid = (low + high) / 2;\n\t\ti = *name - tokentab[mid].operator[0];\n\t\tif (i == 0)\n\t\t\ti = strcmp(name, tokentab[mid].operator);\n\n\t\tif (i < 0)\t\t/* token < mid */\n\t\t\thigh = mid - 1;\n\t\telse if (i > 0)\t\t/* token > mid */\n\t\t\tlow = mid + 1;\n\t\telse {\n\t\t\tif ((tokentab[mid].flags & non_standard_flags) != 0)\n\t\t\t\treturn -1;\n\t\t\treturn mid;\n\t\t}\n\t}\n\treturn -1;\n}",
      "lines": 42,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "read_one_line": {
      "start_point": [
        6172,
        0
      ],
      "end_point": [
        6191,
        1
      ],
      "content": "static ssize_t\nread_one_line(int fd, void *buffer, size_t count)\n{\n\tchar buf[BUFSIZ];\n\n\t/* Minor potential memory leak here. Too bad. */\n\tif (fp == NULL) {\n\t\tfp = fdopen(fd, \"r\");\n\t\tif (fp == NULL) {\n\t\t\tfprintf(stderr, \"ugh. fdopen: %s\\n\", strerror(errno));\n\t\t\tgawk_exit(EXIT_FAILURE);\n\t\t}\n\t}\n\n\tif (fgets(buf, sizeof buf, fp) == NULL)\n\t\treturn 0;\n\n\tmemcpy(buffer, buf, strlen(buf));\n\treturn strlen(buf);\n}",
      "lines": 20,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "ssize_t"
      ]
    },
    "one_line_close": {
      "start_point": [
        6195,
        0
      ],
      "end_point": [
        6206,
        1
      ],
      "content": "static int\none_line_close(int fd)\n{\n\tint ret;\n\n\tif (fp == NULL || fd != fileno(fp))\n\t\tfatal(\"debugging read/close screwed up!\");\n\n\tret = fclose(fp);\n\tfp = NULL;\n\treturn ret;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "lookup_builtin": {
      "start_point": [
        6211,
        0
      ],
      "end_point": [
        6237,
        1
      ],
      "content": "builtin_func_t\nlookup_builtin(const char *name)\n{\n\tint mid = check_special(name);\n\n\tif (mid == -1)\n\t\treturn NULL;\n\n\tswitch (tokentab[mid].class) {\n\tcase LEX_BUILTIN:\n\tcase LEX_LENGTH:\n\t\tbreak;\n\tdefault:\n\t\treturn NULL;\n\t}\n\n\t/* And another special case... */\n\tif (tokentab[mid].value == Op_sub_builtin)\n\t\treturn (builtin_func_t) do_sub;\n\n#ifdef HAVE_MPFR\n\tif (do_mpfr)\n\t\treturn tokentab[mid].ptr2;\n#endif\n\n\treturn tokentab[mid].ptr;\n}",
      "lines": 27,
      "depth": 8,
      "decorators": [
        "builtin_func_t"
      ]
    },
    "install_builtins": {
      "start_point": [
        6241,
        0
      ],
      "end_point": [
        6262,
        1
      ],
      "content": "void\ninstall_builtins(void)\n{\n\tint i, j;\n\tint flags_that_must_be_clear = DEBUG_USE;\n\n\tif (do_traditional)\n\t\tflags_that_must_be_clear |= GAWKX;\n\n\tif (do_posix)\n\t\tflags_that_must_be_clear |= NOT_POSIX;\n\n\n\tj = sizeof(tokentab) / sizeof(tokentab[0]);\n\tfor (i = 0; i < j; i++) {\n\t\tif (   (tokentab[i].class == LEX_BUILTIN\n\t\t        || tokentab[i].class == LEX_LENGTH)\n\t\t    && (tokentab[i].flags & flags_that_must_be_clear) == 0) {\n\t\t\t(void) install_symbol(tokentab[i].operator, Node_builtin_func);\n\t\t}\n\t}\n}",
      "lines": 22,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "is_alpha": {
      "start_point": [
        6282,
        0
      ],
      "end_point": [
        6303,
        1
      ],
      "content": "bool\nis_alpha(int c)\n{\n#ifdef I_DONT_KNOW_WHAT_IM_DOING\n\treturn isalpha(c);\n#else /* ! I_DONT_KNOW_WHAT_IM_DOING */\n\tswitch (c) {\n\tcase 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n\tcase 'g': case 'h': case 'i': case 'j': case 'k': case 'l':\n\tcase 'm': case 'n': case 'o': case 'p': case 'q': case 'r':\n\tcase 's': case 't': case 'u': case 'v': case 'w': case 'x':\n\tcase 'y': case 'z':\n\tcase 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n\tcase 'G': case 'H': case 'I': case 'J': case 'K': case 'L':\n\tcase 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':\n\tcase 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n\tcase 'Y': case 'Z':\n\t\treturn true;\n\t}\n\treturn false;\n#endif /* ! I_DONT_KNOW_WHAT_IM_DOING */\n}",
      "lines": 22,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    },
    "is_alnum": {
      "start_point": [
        6307,
        0
      ],
      "end_point": [
        6312,
        1
      ],
      "content": "bool\nis_alnum(int c)\n{\n\t/* digit test is good for EBCDIC too. so there. */\n\treturn (is_alpha(c) || ('0' <= c && c <= '9'));\n}",
      "lines": 6,
      "depth": 10,
      "decorators": [
        "bool"
      ]
    },
    "is_letter": {
      "start_point": [
        6321,
        0
      ],
      "end_point": [
        6325,
        1
      ],
      "content": "bool\nis_letter(int c)\n{\n\treturn (is_alpha(c) || c == '_');\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "bool"
      ]
    },
    "is_identchar": {
      "start_point": [
        6329,
        0
      ],
      "end_point": [
        6333,
        1
      ],
      "content": "bool\nis_identchar(int c)\n{\n\treturn (is_alnum(c) || c == '_');\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "bool"
      ]
    },
    "set_profile_text": {
      "start_point": [
        6337,
        0
      ],
      "end_point": [
        6359,
        1
      ],
      "content": "static NODE *\nset_profile_text(NODE *n, const char *str, size_t len)\n{\n\tif (do_pretty_print) {\n\t\t// two extra bytes: one for NUL termination, and another in\n\t\t// case we need to add a leading minus sign in add_sign_to_num\n\t\temalloc(n->stptr, char *, len + 2, \"set_profile_text\");\n\t\tmemcpy(n->stptr, str, len);\n\t\tn->stptr[len] = '\\0';\n\t\tn->stlen = len;\n\t\t// Set STRCUR and n->stfmt for use when profiling\n\t\t// (i.e., actually running the program) so that\n\t\t// force_string() on this item will work ok.\n\t\t// Thanks and a tip of the hatlo to valgrind.\n\t\tn->flags |= (NUMCONSTSTR|STRCUR);\n\t\tn->stfmt = STFMT_UNUSED;\n#ifdef HAVE_MPFR\n\t\tn->strndmode = MPFR_round_mode;\n#endif\n\t}\n\n\treturn n;\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "NODE",
        "*\nset_profile_text(NODE *n, const char *str, size_t len)",
        "*"
      ]
    }
  },
  "gawk/gawk-4.2.1/builtin.c": {
    "efwrite": {
      "start_point": [
        99,
        0
      ],
      "end_point": [
        149,
        1
      ],
      "content": "static void\nefwrite(const void *ptr,\n\tsize_t size,\n\tsize_t count,\n\tFILE *fp,\n\tconst char *from,\n\tstruct redirect *rp,\n\tbool flush)\n{\n\terrno = 0;\n\tif (rp != NULL) {\n\t\tif (rp->output.gawk_fwrite(ptr, size, count, fp, rp->output.opaque) != count)\n\t\t\tgoto wrerror;\n\t} else if (fwrite(ptr, size, count, fp) != count)\n\t\tgoto wrerror;\n\tif (flush\n\t  && ((fp == stdout && output_is_tty)\n\t      || (rp != NULL && (rp->flag & RED_NOBUF) != 0))) {\n\t\tif (rp != NULL) {\n\t\t\trp->output.gawk_fflush(fp, rp->output.opaque);\n\t\t\tif (rp->output.gawk_ferror(fp, rp->output.opaque))\n\t\t\t\tgoto wrerror;\n\t\t} else {\n\t\t\tfflush(fp);\n\t\t\tif (ferror(fp))\n\t\t\t\tgoto wrerror;\n\t\t}\n\t}\n\treturn;\n\nwrerror:\n#ifdef __MINGW32__\n\tif (errno == 0 || errno == EINVAL)\n\t\tw32_maybe_set_errno();\n#endif\n\t/* for stdout, die with a real SIGPIPE, like other awks */\n\tif (fp == stdout && errno == EPIPE)\n\t\tdie_via_sigpipe();\n\n\t/* otherwise die verbosely */\n\tif ((rp != NULL) ? is_non_fatal_redirect(rp->value, strlen(rp->value)) : is_non_fatal_std(fp))\n\t\tupdate_ERRNO_int(errno);\n\telse\n\t\tfatal(_(\"%s to \\\"%s\\\" failed (%s)\"), from,\n\t\t\trp != NULL\n\t\t\t\t? rp->value\n\t\t\t\t: fp == stdout\n\t\t\t\t\t? _(\"standard output\")\n\t\t\t\t\t: _(\"standard error\"),\n\t\t\terrno ? strerror(errno) : _(\"reason unknown\"));\n}",
      "lines": 51,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "do_exp": {
      "start_point": [
        153,
        0
      ],
      "end_point": [
        169,
        1
      ],
      "content": "NODE *\ndo_exp(int nargs)\n{\n\tNODE *tmp;\n\tdouble d, res;\n\n\ttmp = POP_SCALAR();\n\tif (do_lint && (fixtype(tmp)->flags & NUMBER) == 0)\n\t\tlintwarn(_(\"exp: received non-numeric argument\"));\n\td = force_number(tmp)->numbr;\n\tDEREF(tmp);\n\terrno = 0;\n\tres = exp(d);\n\tif (errno == ERANGE)\n\t\twarning(_(\"exp: argument %g is out of range\"), d);\n\treturn make_number((AWKNUM) res);\n}",
      "lines": 17,
      "depth": 12,
      "decorators": [
        "NODE",
        "*\ndo_exp(int nargs)",
        "*"
      ]
    },
    "stdfile": {
      "start_point": [
        179,
        0
      ],
      "end_point": [
        190,
        1
      ],
      "content": "static FILE *\nstdfile(const char *name, size_t len)\n{\n\tif (len == 11) {\n\t\tif (strncmp(name, \"/dev/stderr\", 11) == 0)\n\t\t\treturn stderr;\n\t\telse if (strncmp(name, \"/dev/stdout\", 11) == 0)\n\t\t\treturn stdout;\n\t}\n\n\treturn NULL;\n}",
      "lines": 12,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "FILE",
        "*\nstdfile(const char *name, size_t len)",
        "*"
      ]
    },
    "do_fflush": {
      "start_point": [
        194,
        0
      ],
      "end_point": [
        273,
        1
      ],
      "content": "NODE *\ndo_fflush(int nargs)\n{\n\tstruct redirect *rp;\n\tNODE *tmp;\n\tFILE *fp;\n\tint status = 0;\n\tconst char *file;\n\tint len;\n\n\t/*\n\t * November, 2012.\n\t * It turns out that circa 2002, when BWK\n\t * added fflush() and fflush(\"\") to his awk, he made both of\n\t * them flush everything.\n\t *\n\t * Now, with our inside agent getting ready to try to get fflush()\n\t * standardized in POSIX, we are going to make our awk consistent\n\t * with his.  This should not really affect anyone, as flushing\n\t * everything also flushes stdout.\n\t *\n\t * So. Once upon a time:\n\t * \tfflush()\t--- flush stdout\n\t * \tfflush(\"\")\t--- flush everything\n\t * Now, both calls flush everything.\n\t */\n\n\t/* fflush() */\n\tif (nargs == 0) {\n\t\tstatus = flush_io();\t// ERRNO updated\n\t\treturn make_number((AWKNUM) status);\n\t}\n\n\ttmp = POP_STRING();\n\tfile = tmp->stptr;\n\tlen = tmp->stlen;\n\n\t/* fflush(\"\") */\n\tif (tmp->stlen == 0) {\n\t\tstatus = flush_io();\t// ERRNO updated\n\t\tDEREF(tmp);\n\t\treturn make_number((AWKNUM) status);\n\t}\n\n\t/* fflush(\"/some/path\") */\n\trp = getredirect(tmp->stptr, tmp->stlen);\n\tstatus = -1;\n\tif (rp != NULL) {\n\t\tif ((rp->flag & (RED_WRITE|RED_APPEND)) == 0) {\n\t\t\tif ((rp->flag & RED_PIPE) != 0)\n\t\t\t\twarning(_(\"fflush: cannot flush: pipe `%.*s' opened for reading, not writing\"),\n\t\t\t\t\tlen, file);\n\t\t\telse\n\t\t\t\twarning(_(\"fflush: cannot flush: file `%.*s' opened for reading, not writing\"),\n\t\t\t\t\tlen, file);\n\t\t\tDEREF(tmp);\n\t\t\treturn make_number((AWKNUM) status);\n\t\t}\n\t\tfp = rp->output.fp;\n\t\tif (fp != NULL) {\n\t\t\tstatus = rp->output.gawk_fflush(fp, rp->output.opaque);\n\n\t\t\tif (status != 0) {\n\t\t\t\tif (! is_non_fatal_redirect(tmp->stptr, tmp->stlen))\n\t\t\t\t\tfatal(_(\"fflush: cannot flush file `%.*s': %s\"),\n\t\t\t\t\t\tlen, file, strerror(errno));\n\t\t\t\tupdate_ERRNO_int(errno);\n\t\t\t}\n\t\t} else if ((rp->flag & RED_TWOWAY) != 0)\n\t\t\t\twarning(_(\"fflush: cannot flush: two-way pipe `%.*s' has closed write end\"),\n\t\t\t\t\tlen, file);\n\t} else if ((fp = stdfile(tmp->stptr, tmp->stlen)) != NULL) {\n\t\tstatus = (non_fatal_flush_std_file(fp) == false);\n\t} else {\n\t\tstatus = -1;\n\t\twarning(_(\"fflush: `%.*s' is not an open file, pipe or co-process\"), len, file);\n\t}\n\tDEREF(tmp);\n\treturn make_number((AWKNUM) status);\n}",
      "lines": 80,
      "depth": 16,
      "decorators": [
        "NODE",
        "*\ndo_fflush(int nargs)",
        "*"
      ]
    },
    "strncasecmpmbs": {
      "start_point": [
        277,
        0
      ],
      "end_point": [
        318,
        1
      ],
      "content": "int\nstrncasecmpmbs(const unsigned char *s1, const unsigned char *s2, size_t n)\n{\n\tsize_t i1, i2, mbclen1, mbclen2, gap;\n\twchar_t wc1, wc2;\n\tmbstate_t mbs1, mbs2;\n\n\tmemset(& mbs1, 0, sizeof(mbs1));\n\tmemset(& mbs2, 0, sizeof(mbs2));\n\n\tfor (i1 = i2 = 0 ; i1 < n && i2 < n ;i1 += mbclen1, i2 += mbclen2) {\n\t\tif (is_valid_character(s1[i1])) {\n\t\t\tmbclen1 = 1;\n\t\t\twc1 = btowc_cache(s1[i1]);\n\t\t} else {\n\t\t\tmbclen1 = mbrtowc(& wc1, (const char *)s1 + i1,\n\t\t\t\t\t  n - i1, & mbs1);\n\t\t\tif (mbclen1 == (size_t) -1 || mbclen1 == (size_t) -2 || mbclen1 == 0) {\n\t\t\t\t/* We treat it as a singlebyte character. */\n\t\t\t\tmbclen1 = 1;\n\t\t\t\twc1 = btowc_cache(s1[i1]);\n\t\t\t}\n\t\t}\n\t\tif (is_valid_character(s2[i2])) {\n\t\t\tmbclen2 = 1;\n\t\t\twc2 = btowc_cache(s2[i2]);\n\t\t} else {\n\t\t\tmbclen2 = mbrtowc(& wc2, (const char *)s2 + i2,\n\t\t\t\t\t  n - i2, & mbs2);\n\t\t\tif (mbclen2 == (size_t) -1 || mbclen2 == (size_t) -2 || mbclen2 == 0) {\n\t\t\t\t/* We treat it as a singlebyte character. */\n\t\t\t\tmbclen2 = 1;\n\t\t\t\twc2 = btowc_cache(s2[i2]);\n\t\t\t}\n\t\t}\n\t\tif ((gap = towlower(wc1) - towlower(wc2)) != 0)\n\t\t\t/* s1 and s2 are not equivalent. */\n\t\t\treturn gap;\n\t}\n\t/* s1 and s2 are equivalent. */\n\treturn 0;\n}",
      "lines": 42,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "index_multibyte_buffer": {
      "start_point": [
        326,
        0
      ],
      "end_point": [
        353,
        1
      ],
      "content": "static void\nindex_multibyte_buffer(char* src, char* dest, int len)\n{\n\tint idx, prev_idx;\n\tmbstate_t mbs, prevs;\n\n\tmemset(& prevs, 0, sizeof(mbstate_t));\n\tfor (idx = prev_idx = 0 ; idx < len ; idx++) {\n\t\tsize_t mbclen;\n\t\tmbs = prevs;\n\t\tmbclen = mbrlen(src + prev_idx, idx - prev_idx + 1, & mbs);\n\t\tif (mbclen == (size_t) -1 || mbclen == 1 || mbclen == 0) {\n\t\t\t/* singlebyte character.  */\n\t\t\tmbclen = 1;\n\t\t\tprev_idx = idx + 1;\n\t\t} else if (mbclen == (size_t) -2) {\n\t\t\t/* a part of a multibyte character.  */\n\t\t\tmbclen = idx - prev_idx + 1;\n\t\t} else if (mbclen > 1) {\n\t\t\t/* the end of a multibyte character.  */\n\t\t\tprev_idx = idx + 1;\n\t\t\tprevs = mbs;\n\t\t} else {\n\t\t\t/* Can't reach.  */\n\t\t}\n\t\tdest[idx] = mbclen;\n    }\n}",
      "lines": 28,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "do_index": {
      "start_point": [
        357,
        0
      ],
      "end_point": [
        467,
        1
      ],
      "content": "NODE *\ndo_index(int nargs)\n{\n\tNODE *s1, *s2;\n\tconst char *p1, *p2;\n\tsize_t l1, l2;\n\tlong ret;\n\tbool do_single_byte = false;\n\tmbstate_t mbs1, mbs2;\n\n\tif (gawk_mb_cur_max > 1) {\n\t\tmemset(& mbs1, 0, sizeof(mbstate_t));\n\t\tmemset(& mbs2, 0, sizeof(mbstate_t));\n\t}\n\n\tPOP_TWO_SCALARS(s1, s2);\n\n\tif (do_lint) {\n\t\tif ((fixtype(s1)->flags & STRING) == 0)\n\t\t\tlintwarn(_(\"index: received non-string first argument\"));\n\t\tif ((fixtype(s2)->flags & STRING) == 0)\n\t\t\tlintwarn(_(\"index: received non-string second argument\"));\n\t}\n\n\ts1 = force_string(s1);\n\ts2 = force_string(s2);\n\n\tp1 = s1->stptr;\n\tp2 = s2->stptr;\n\tl1 = s1->stlen;\n\tl2 = s2->stlen;\n\tret = 0;\n\n\t/*\n\t * Icky special case, index(foo, \"\") should return 1,\n\t * since both bwk awk and mawk do, and since match(\"foo\", \"\")\n\t * returns 1. This makes index(\"\", \"\") work, too, fwiw.\n\t */\n\tif (l2 == 0) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\tif (gawk_mb_cur_max > 1) {\n\t\ts1 = force_wstring(s1);\n\t\ts2 = force_wstring(s2);\n\t\t/*\n\t\t * If we don't have valid wide character strings, use\n\t\t * the real bytes.\n\t\t */\n\t\tdo_single_byte = ((s1->wstlen == 0 && s1->stlen > 0)\n\t\t\t\t\t|| (s2->wstlen == 0 && s2->stlen > 0));\n\t}\n\n\t/* IGNORECASE will already be false if posix */\n\tif (IGNORECASE) {\n\t\twhile (l1 > 0) {\n\t\t\tif (l2 > l1)\n\t\t\t\tbreak;\n\t\t\tif (! do_single_byte && gawk_mb_cur_max > 1) {\n\t\t\t\tconst wchar_t *pos;\n\n\t\t\t\tpos = wcasestrstr(s1->wstptr, s1->wstlen, s2->wstptr, s2->wstlen);\n\t\t\t\tif (pos == NULL)\n\t\t\t\t\tret = 0;\n\t\t\t\telse\n\t\t\t\t\tret = pos - s1->wstptr + 1;\t/* 1-based */\n\t\t\t\tgoto out;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * Could use tolower(*p1) == tolower(*p2) here.\n\t\t\t\t * See discussion in eval.c as to why not.\n\t\t\t\t */\n\t\t\t\tif (casetable[(unsigned char)*p1] == casetable[(unsigned char)*p2]\n\t\t\t\t    && (l2 == 1 || strncasecmp(p1, p2, l2) == 0)) {\n\t\t\t\t\tret = 1 + s1->stlen - l1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tl1--;\n\t\t\t\tp1++;\n\t\t\t}\n\t\t}\n\t} else {\n\t\twhile (l1 > 0) {\n\t\t\tif (l2 > l1)\n\t\t\t\tbreak;\n\t\t\tif (*p1 == *p2\n\t\t\t    && (l2 == 1 || (l2 > 0 && memcmp(p1, p2, l2) == 0))) {\n\t\t\t\tret = 1 + s1->stlen - l1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (! do_single_byte && gawk_mb_cur_max > 1) {\n\t\t\t\tconst wchar_t *pos;\n\n\t\t\t\tpos = wstrstr(s1->wstptr, s1->wstlen, s2->wstptr, s2->wstlen);\n\t\t\t\tif (pos == NULL)\n\t\t\t\t\tret = 0;\n\t\t\t\telse\n\t\t\t\t\tret = pos - s1->wstptr + 1;\t/* 1-based */\n\t\t\t\tgoto out;\n\t\t\t} else {\n\t\t\t\tl1--;\n\t\t\t\tp1++;\n\t\t\t}\n\t\t}\n\t}\nout:\n\tDEREF(s1);\n\tDEREF(s2);\n\treturn make_number((AWKNUM) ret);\n}",
      "lines": 111,
      "depth": 17,
      "decorators": [
        "NODE",
        "*\ndo_index(int nargs)",
        "*"
      ]
    },
    "double_to_int": {
      "start_point": [
        471,
        0
      ],
      "end_point": [
        479,
        1
      ],
      "content": "double\ndouble_to_int(double d)\n{\n\tif (d >= 0)\n\t\td = floor(d);\n\telse\n\t\td = ceil(d);\n\treturn d;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "double"
      ]
    },
    "do_int": {
      "start_point": [
        483,
        0
      ],
      "end_point": [
        496,
        1
      ],
      "content": "NODE *\ndo_int(int nargs)\n{\n\tNODE *tmp;\n\tdouble d;\n\n\ttmp = POP_SCALAR();\n\tif (do_lint && (fixtype(tmp)->flags & NUMBER) == 0)\n\t\tlintwarn(_(\"int: received non-numeric argument\"));\n\td = force_number(tmp)->numbr;\n\td = double_to_int(d);\n\tDEREF(tmp);\n\treturn make_number((AWKNUM) d);\n}",
      "lines": 14,
      "depth": 12,
      "decorators": [
        "NODE",
        "*\ndo_int(int nargs)",
        "*"
      ]
    },
    "do_isarray": {
      "start_point": [
        500,
        0
      ],
      "end_point": [
        514,
        1
      ],
      "content": "NODE *\ndo_isarray(int nargs)\n{\n\tNODE *tmp;\n\tint ret = 1;\n\n\ttmp = POP();\n\tif (tmp->type != Node_var_array) {\n\t\tret = 0;\n\t\t// could be Node_var_new\n\t\tif (tmp->type == Node_val)\n\t\t\tDEREF(tmp);\n\t}\n\treturn make_number((AWKNUM) ret);\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "NODE",
        "*\ndo_isarray(int nargs)",
        "*"
      ]
    },
    "do_length": {
      "start_point": [
        518,
        0
      ],
      "end_point": [
        569,
        1
      ],
      "content": "NODE *\ndo_length(int nargs)\n{\n\tNODE *tmp;\n\tsize_t len;\n\n\ttmp = POP();\n\tif (tmp->type == Node_var_array) {\n\t\tstatic bool warned = false;\n\t\tunsigned long size;\n\n\t\tif (do_posix)\n\t\t\tfatal(_(\"length: received array argument\"));\n   \t\tif (do_lint && ! warned) {\n\t\t\twarned = true;\n\t\t\tlintwarn(_(\"`length(array)' is a gawk extension\"));\n\t\t}\n\n\t\t/*\n\t\t * Support for deferred loading of array elements requires that\n\t\t * we use the array length interface even though it isn't\n\t\t * necessary for the built-in array types.\n\t\t *\n\t\t * 1/2015: The deferred arrays are gone, but this is probably\n\t\t * still a good idea.\n\t\t */\n\n\t\tsize = assoc_length(tmp);\n\t\treturn make_number(size);\n\t}\n\n\tassert(tmp->type == Node_val);\n\n\tif (do_lint && (fixtype(tmp)->flags & STRING) == 0)\n\t\tlintwarn(_(\"length: received non-string argument\"));\n\ttmp = force_string(tmp);\n\n\tif (gawk_mb_cur_max > 1) {\n\t\ttmp = force_wstring(tmp);\n\t\tlen = tmp->wstlen;\n\t\t/*\n\t\t * If the bytes don't make a valid wide character\n\t\t * string, fall back to the bytes themselves.\n\t\t */\n\t\t if (len == 0 && tmp->stlen > 0)\n\t\t\t len = tmp->stlen;\n\t} else\n\t\tlen = tmp->stlen;\n\n\tDEREF(tmp);\n\treturn make_number((AWKNUM) len);\n}",
      "lines": 52,
      "depth": 13,
      "decorators": [
        "NODE",
        "*\ndo_length(int nargs)",
        "*"
      ]
    },
    "do_log": {
      "start_point": [
        573,
        0
      ],
      "end_point": [
        588,
        1
      ],
      "content": "NODE *\ndo_log(int nargs)\n{\n\tNODE *tmp;\n\tdouble d, arg;\n\n\ttmp = POP_SCALAR();\n\tif (do_lint && (fixtype(tmp)->flags & NUMBER) == 0)\n\t\tlintwarn(_(\"log: received non-numeric argument\"));\n\targ = force_number(tmp)->numbr;\n\tif (arg < 0.0)\n\t\twarning(_(\"log: received negative argument %g\"), arg);\n\td = log(arg);\n\tDEREF(tmp);\n\treturn make_number((AWKNUM) d);\n}",
      "lines": 16,
      "depth": 12,
      "decorators": [
        "NODE",
        "*\ndo_log(int nargs)",
        "*"
      ]
    },
    "mpz2mpfr": {
      "start_point": [
        600,
        0
      ],
      "end_point": [
        624,
        1
      ],
      "content": "static mpfr_ptr\nmpz2mpfr(mpz_ptr zi)\n{\n\tsize_t prec;\n\tstatic mpfr_t mpfrval;\n\tstatic bool inited = false;\n\tint tval;\n\n\t/* estimate minimum precision for exact conversion */\n\tprec = mpz_sizeinbase(zi, 2);\t/* most significant 1 bit position starting at 1 */\n\tprec -= (size_t) mpz_scan1(zi, 0);\t/* least significant 1 bit index starting at 0 */\n\tif (prec < MPFR_PREC_MIN)\n\t\tprec = MPFR_PREC_MIN;\n\telse if (prec > MPFR_PREC_MAX)\n\t\tprec = MPFR_PREC_MAX;\n\n\tif (! inited) {\n\t\tmpfr_init2(mpfrval, prec);\n\t\tinited = true;\n\t} else\n\t\tmpfr_set_prec(mpfrval, prec);\n\ttval = mpfr_set_z(mpfrval, zi, ROUND_MODE);\n\tIEEE_FMT(mpfrval, tval);\n\treturn mpfrval;\n}",
      "lines": 25,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "mpfr_ptr"
      ]
    },
    "format_tree": {
      "start_point": [
        637,
        0
      ],
      "end_point": [
        1618,
        1
      ],
      "content": "NODE *\nformat_tree(\n\tconst char *fmt_string,\n\tsize_t n0,\n\tNODE **the_args,\n\tlong num_args)\n{\n/* copy 'l' bytes from 's' to 'obufout' checking for space in the process */\n/* difference of pointers should be of ptrdiff_t type, but let us be kind */\n#define bchunk(s, l) if (l) { \\\n\twhile ((l) > ofre) { \\\n\t\tsize_t olen = obufout - obuf; \\\n\t\terealloc(obuf, char *, osiz * 2, \"format_tree\"); \\\n\t\tofre += osiz; \\\n\t\tosiz *= 2; \\\n\t\tobufout = obuf + olen; \\\n\t} \\\n\tmemcpy(obufout, s, (size_t) (l)); \\\n\tobufout += (l); \\\n\tofre -= (l); \\\n}\n\n/* copy one byte from 's' to 'obufout' checking for space in the process */\n#define bchunk_one(s) { \\\n\tif (ofre < 1) { \\\n\t\tsize_t olen = obufout - obuf; \\\n\t\terealloc(obuf, char *, osiz * 2, \"format_tree\"); \\\n\t\tofre += osiz; \\\n\t\tosiz *= 2; \\\n\t\tobufout = obuf + olen; \\\n\t} \\\n\t*obufout++ = *s; \\\n\t--ofre; \\\n}\n\n/* Is there space for something L big in the buffer? */\n#define chksize(l)  if ((l) >= ofre) { \\\n\tsize_t olen = obufout - obuf; \\\n\tsize_t delta = osiz+l-ofre; \\\n\terealloc(obuf, char *, osiz + delta, \"format_tree\"); \\\n\tobufout = obuf + olen; \\\n\tofre += delta; \\\n\tosiz += delta; \\\n}\n\n\tsize_t cur_arg = 0;\n\tNODE *r = NULL;\n\tint i, nc;\n\tbool toofew = false;\n\tchar *obuf, *obufout;\n\tsize_t osiz, ofre, olen_final;\n\tconst char *chbuf;\n\tconst char *s0, *s1;\n\tint cs1;\n\tNODE *arg;\n\tlong fw, prec, argnum;\n\tbool used_dollar;\n\tbool lj, alt, big_flag, bigbig_flag, small_flag, have_prec, need_format;\n\tlong *cur = NULL;\n\tuintmax_t uval;\n\tbool sgn;\n\tint base;\n\t/*\n\t * Although this is an array, the elements serve two different\n\t * purposes. The first element is the general buffer meant\n\t * to hold the entire result string.  The second one is a\n\t * temporary buffer for large floating point values. They\n\t * could just as easily be separate variables, and the\n\t * code might arguably be clearer.\n\t */\n\tstruct {\n\t\tchar *buf;\n\t\tsize_t bufsize;\n\t\tchar stackbuf[30];\n\t} cpbufs[2];\n#define cpbuf\tcpbufs[0].buf\n\tchar *cend = &cpbufs[0].stackbuf[sizeof(cpbufs[0].stackbuf)];\n\tchar *cp;\n\tconst char *fill;\n\tAWKNUM tmpval = 0.0;\n\tchar signchar = '\\0';\n\tsize_t len;\n\tbool zero_flag = false;\n\tbool quote_flag = false;\n\tint ii, jj;\n\tchar *chp;\n\tsize_t copy_count, char_count;\n#ifdef HAVE_MPFR\n\tmpz_ptr zi;\n\tmpfr_ptr mf;\n#endif\n\tenum { MP_NONE = 0, MP_INT_WITH_PREC = 1, MP_INT_WITHOUT_PREC, MP_FLOAT } fmt_type;\n\n\tstatic const char sp[] = \" \";\n\tstatic const char zero_string[] = \"0\";\n\tstatic const char lchbuf[] = \"0123456789abcdef\";\n\tstatic const char Uchbuf[] = \"0123456789ABCDEF\";\n\n#define INITIAL_OUT_SIZE\t512\n\temalloc(obuf, char *, INITIAL_OUT_SIZE, \"format_tree\");\n\tobufout = obuf;\n\tosiz = INITIAL_OUT_SIZE;\n\tofre = osiz - 1;\n\n\tcur_arg = 1;\n\n\t{\n\t\tsize_t k;\n\t\tfor (k = 0; k < sizeof(cpbufs)/sizeof(cpbufs[0]); k++) {\n\t\t\tcpbufs[k].bufsize = sizeof(cpbufs[k].stackbuf);\n\t\t\tcpbufs[k].buf = cpbufs[k].stackbuf;\n\t\t}\n\t}\n\n\t/*\n\t * The point of this goop is to grow the buffer\n\t * holding the converted number, so that large\n\t * values don't overflow a fixed length buffer.\n\t */\n#define PREPEND(CH) do {\t\\\n\tif (cp == cpbufs[0].buf) {\t\\\n\t\tchar *prev = cpbufs[0].buf;\t\\\n\t\temalloc(cpbufs[0].buf, char *, 2*cpbufs[0].bufsize, \\\n\t\t \t\"format_tree\");\t\\\n\t\tmemcpy((cp = cpbufs[0].buf+cpbufs[0].bufsize), prev,\t\\\n\t\t       cpbufs[0].bufsize);\t\\\n\t\tcpbufs[0].bufsize *= 2;\t\\\n\t\tif (prev != cpbufs[0].stackbuf)\t\\\n\t\t\tefree(prev);\t\\\n\t\tcend = cpbufs[0].buf+cpbufs[0].bufsize;\t\\\n\t}\t\\\n\t*--cp = (CH);\t\\\n} while(0)\n\n\t/*\n\t * Check first for use of `count$'.\n\t * If plain argument retrieval was used earlier, choke.\n\t *\tOtherwise, return the requested argument.\n\t * If not `count$' now, but it was used earlier, choke.\n\t * If this format is more than total number of args, choke.\n\t * Otherwise, return the current argument.\n\t */\n#define parse_next_arg() { \\\n\tif (argnum > 0) { \\\n\t\tif (cur_arg > 1) { \\\n\t\t\tmsg(_(\"fatal: must use `count$' on all formats or none\")); \\\n\t\t\tgoto out; \\\n\t\t} \\\n\t\targ = the_args[argnum]; \\\n\t} else if (used_dollar) { \\\n\t\tmsg(_(\"fatal: must use `count$' on all formats or none\")); \\\n\t\targ = 0; /* shutup the compiler */ \\\n\t\tgoto out; \\\n\t} else if (cur_arg >= num_args) { \\\n\t\targ = 0; /* shutup the compiler */ \\\n\t\ttoofew = true; \\\n\t\tbreak; \\\n\t} else { \\\n\t\targ = the_args[cur_arg]; \\\n\t\tcur_arg++; \\\n\t} \\\n}\n\n\tneed_format = false;\n\tused_dollar = false;\n\n\ts0 = s1 = fmt_string;\n\twhile (n0-- > 0) {\n\t\tif (*s1 != '%') {\n\t\t\ts1++;\n\t\t\tcontinue;\n\t\t}\n\t\tneed_format = true;\n\t\tbchunk(s0, s1 - s0);\n\t\ts0 = s1;\n\t\tcur = &fw;\n\t\tfw = 0;\n\t\tprec = 0;\n\t\tbase = 0;\n\t\targnum = 0;\n\t\tbase = 0;\n\t\thave_prec = false;\n\t\tsignchar = '\\0';\n\t\tzero_flag = false;\n\t\tquote_flag = false;\n#ifdef HAVE_MPFR\n\t\tmf = NULL;\n\t\tzi = NULL;\n#endif\n\t\tfmt_type = MP_NONE;\n\n\t\tlj = alt = big_flag = bigbig_flag = small_flag = false;\n\t\tfill = sp;\n\t\tcp = cend;\n\t\tchbuf = lchbuf;\n\t\ts1++;\n\nretry:\n\t\tif (n0-- == 0)\t/* ran out early! */\n\t\t\tbreak;\n\n\t\tswitch (cs1 = *s1++) {\n\t\tcase (-1):\t/* dummy case to allow for checking */\ncheck_pos:\n\t\t\tif (cur != &fw)\n\t\t\t\tbreak;\t\t/* reject as a valid format */\n\t\t\tgoto retry;\n\t\tcase '%':\n\t\t\tneed_format = false;\n\t\t\t/*\n\t\t\t * 29 Oct. 2002:\n\t\t\t * The C99 standard pages 274 and 279 seem to imply that\n\t\t\t * since there's no arg converted, the field width doesn't\n\t\t\t * apply.  The code already was that way, but this\n\t\t\t * comment documents it, at least in the code.\n\t\t\t */\n\t\t\tif (do_lint) {\n\t\t\t\tconst char *msg = NULL;\n\n\t\t\t\tif (fw && ! have_prec)\n\t\t\t\t\tmsg = _(\"field width is ignored for `%%' specifier\");\n\t\t\t\telse if (fw == 0 && have_prec)\n\t\t\t\t\tmsg = _(\"precision is ignored for `%%' specifier\");\n\t\t\t\telse if (fw && have_prec)\n\t\t\t\t\tmsg = _(\"field width and precision are ignored for `%%' specifier\");\n\n\t\t\t\tif (msg != NULL)\n\t\t\t\t\tlintwarn(\"%s\", msg);\n\t\t\t}\n\t\t\tbchunk_one(\"%\");\n\t\t\ts0 = s1;\n\t\t\tbreak;\n\n\t\tcase '0':\n\t\t\t/*\n\t\t\t * Only turn on zero_flag if we haven't seen\n\t\t\t * the field width or precision yet.  Otherwise,\n\t\t\t * screws up floating point formatting.\n\t\t\t */\n\t\t\tif (cur == & fw)\n\t\t\t\tzero_flag = true;\n\t\t\tif (lj)\n\t\t\t\tgoto retry;\n\t\t\t/* FALL through */\n\t\tcase '1':\n\t\tcase '2':\n\t\tcase '3':\n\t\tcase '4':\n\t\tcase '5':\n\t\tcase '6':\n\t\tcase '7':\n\t\tcase '8':\n\t\tcase '9':\n\t\t\tif (cur == NULL)\n\t\t\t\tbreak;\n\t\t\tif (prec >= 0)\n\t\t\t\t*cur = cs1 - '0';\n\t\t\t/*\n\t\t\t * with a negative precision *cur is already set\n\t\t\t * to -1, so it will remain negative, but we have\n\t\t\t * to \"eat\" precision digits in any case\n\t\t\t */\n\t\t\twhile (n0 > 0 && *s1 >= '0' && *s1 <= '9') {\n\t\t\t\t--n0;\n\t\t\t\t*cur = *cur * 10 + *s1++ - '0';\n\t\t\t}\n\t\t\tif (prec < 0) \t/* negative precision is discarded */\n\t\t\t\thave_prec = false;\n\t\t\tif (cur == &prec)\n\t\t\t\tcur = NULL;\n\t\t\tif (n0 == 0)\t/* badly formatted control string */\n\t\t\t\tcontinue;\n\t\t\tgoto retry;\n\t\tcase '$':\n\t\t\tif (do_traditional) {\n\t\t\t\tmsg(_(\"fatal: `$' is not permitted in awk formats\"));\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (cur == &fw) {\n\t\t\t\targnum = fw;\n\t\t\t\tfw = 0;\n\t\t\t\tused_dollar = true;\n\t\t\t\tif (argnum <= 0) {\n\t\t\t\t\tmsg(_(\"fatal: arg count with `$' must be > 0\"));\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tif (argnum >= num_args) {\n\t\t\t\t\tmsg(_(\"fatal: arg count %ld greater than total number of supplied arguments\"), argnum);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmsg(_(\"fatal: `$' not permitted after period in format\"));\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tgoto retry;\n\t\tcase '*':\n\t\t\tif (cur == NULL)\n\t\t\t\tbreak;\n\t\t\tif (! do_traditional && used_dollar && ! isdigit((unsigned char) *s1)) {\n\t\t\t\tfatal(_(\"fatal: must use `count$' on all formats or none\"));\n\t\t\t\tbreak;\t/* silence warnings */\n\t\t\t} else if (! do_traditional && isdigit((unsigned char) *s1)) {\n\t\t\t\tint val = 0;\n\n\t\t\t\tfor (; n0 > 0 && *s1 && isdigit((unsigned char) *s1); s1++, n0--) {\n\t\t\t\t\tval *= 10;\n\t\t\t\t\tval += *s1 - '0';\n\t\t\t\t}\n\t\t\t\tif (*s1 != '$') {\n\t\t\t\t\tmsg(_(\"fatal: no `$' supplied for positional field width or precision\"));\n\t\t\t\t\tgoto out;\n\t\t\t\t} else {\n\t\t\t\t\ts1++;\n\t\t\t\t\tn0--;\n\t\t\t\t}\n\t\t\t\tif (val >= num_args) {\n\t\t\t\t\ttoofew = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\targ = the_args[val];\n\t\t\t} else {\n\t\t\t\tparse_next_arg();\n\t\t\t}\n\t\t\t(void) force_number(arg);\n\t\t\t*cur = get_number_si(arg);\n\t\t\tif (*cur < 0 && cur == &fw) {\n\t\t\t\t*cur = -*cur;\n\t\t\t\tlj = true;\n\t\t\t}\n\t\t\tif (cur == &prec) {\n\t\t\t\tif (*cur >= 0)\n\t\t\t\t\thave_prec = true;\n\t\t\t\telse\n\t\t\t\t\thave_prec = false;\n\t\t\t\tcur = NULL;\n\t\t\t}\n\t\t\tgoto retry;\n\t\tcase ' ':\t\t/* print ' ' or '-' */\n\t\t\t\t\t/* 'space' flag is ignored */\n\t\t\t\t\t/* if '+' already present  */\n\t\t\tif (signchar != false)\n\t\t\t\tgoto check_pos;\n\t\t\t/* FALL THROUGH */\n\t\tcase '+':\t\t/* print '+' or '-' */\n\t\t\tsignchar = cs1;\n\t\t\tgoto check_pos;\n\t\tcase '-':\n\t\t\tif (prec < 0)\n\t\t\t\tbreak;\n\t\t\tif (cur == &prec) {\n\t\t\t\tprec = -1;\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\tfill = sp;      /* if left justified then other */\n\t\t\tlj = true;\t/* filling is ignored */\n\t\t\tgoto check_pos;\n\t\tcase '.':\n\t\t\tif (cur != &fw)\n\t\t\t\tbreak;\n\t\t\tcur = &prec;\n\t\t\thave_prec = true;\n\t\t\tgoto retry;\n\t\tcase '#':\n\t\t\talt = true;\n\t\t\tgoto check_pos;\n\t\tcase '\\'':\n#if defined(HAVE_LOCALE_H)\n\t\t\tquote_flag = true;\n\t\t\tgoto check_pos;\n#else\n\t\t\tgoto retry;\n#endif\n\t\tcase 'l':\n\t\t\tif (big_flag)\n\t\t\t\tbreak;\n\t\t\telse {\n\t\t\t\tstatic bool warned = false;\n\n\t\t\t\tif (do_lint && ! warned) {\n\t\t\t\t\tlintwarn(_(\"`l' is meaningless in awk formats; ignored\"));\n\t\t\t\t\twarned = true;\n\t\t\t\t}\n\t\t\t\tif (do_posix) {\n\t\t\t\t\tmsg(_(\"fatal: `l' is not permitted in POSIX awk formats\"));\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbig_flag = true;\n\t\t\tgoto retry;\n\t\tcase 'L':\n\t\t\tif (bigbig_flag)\n\t\t\t\tbreak;\n\t\t\telse {\n\t\t\t\tstatic bool warned = false;\n\n\t\t\t\tif (do_lint && ! warned) {\n\t\t\t\t\tlintwarn(_(\"`L' is meaningless in awk formats; ignored\"));\n\t\t\t\t\twarned = true;\n\t\t\t\t}\n\t\t\t\tif (do_posix) {\n\t\t\t\t\tmsg(_(\"fatal: `L' is not permitted in POSIX awk formats\"));\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbigbig_flag = true;\n\t\t\tgoto retry;\n\t\tcase 'h':\n\t\t\tif (small_flag)\n\t\t\t\tbreak;\n\t\t\telse {\n\t\t\t\tstatic bool warned = false;\n\n\t\t\t\tif (do_lint && ! warned) {\n\t\t\t\t\tlintwarn(_(\"`h' is meaningless in awk formats; ignored\"));\n\t\t\t\t\twarned = true;\n\t\t\t\t}\n\t\t\t\tif (do_posix) {\n\t\t\t\t\tmsg(_(\"fatal: `h' is not permitted in POSIX awk formats\"));\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsmall_flag = true;\n\t\t\tgoto retry;\n\t\tcase 'c':\n\t\t\tneed_format = false;\n\t\t\tparse_next_arg();\n\t\t\t/* user input that looks numeric is numeric */\n\t\t\tfixtype(arg);\n\t\t\tif ((arg->flags & NUMBER) != 0) {\n\t\t\t\tuval = get_number_uj(arg);\n\t\t\t\tif (gawk_mb_cur_max > 1) {\n\t\t\t\t\tchar buf[100];\n\t\t\t\t\twchar_t wc;\n\t\t\t\t\tmbstate_t mbs;\n\t\t\t\t\tsize_t count;\n\n\t\t\t\t\tmemset(& mbs, 0, sizeof(mbs));\n\n\t\t\t\t\t/* handle systems with too small wchar_t */\n\t\t\t\t\tif (sizeof(wchar_t) < 4 && uval > 0xffff) {\n\t\t\t\t\t\tif (do_lint)\n\t\t\t\t\t\t\tlintwarn(\n\t\t\t\t\t\t_(\"[s]printf: value %g is too big for %%c format\"),\n\t\t\t\t\t\t\t\t\targ->numbr);\n\n\t\t\t\t\t\tgoto out0;\n\t\t\t\t\t}\n\n\t\t\t\t\twc = uval;\n\n\t\t\t\t\tcount = wcrtomb(buf, wc, & mbs);\n\t\t\t\t\tif (count == 0\n\t\t\t\t\t    || count == (size_t) -1) {\n\t\t\t\t\t\tif (do_lint)\n\t\t\t\t\t\t\tlintwarn(\n\t\t\t\t\t\t_(\"[s]printf: value %g is not a valid wide character\"),\n\t\t\t\t\t\t\t\t\targ->numbr);\n\n\t\t\t\t\t\tgoto out0;\n\t\t\t\t\t}\n\n\t\t\t\t\tmemcpy(cpbuf, buf, count);\n\t\t\t\t\tprec = count;\n\t\t\t\t\tcp = cpbuf;\n\t\t\t\t\tgoto pr_tail;\n\t\t\t\t}\nout0:\n\t\t\t\t;\n\t\t\t\t/* else,\n\t\t\t\t\tfall through */\n\n\t\t\t\tcpbuf[0] = uval;\n\t\t\t\tprec = 1;\n\t\t\t\tcp = cpbuf;\n\t\t\t\tgoto pr_tail;\n\t\t\t}\n\t\t\t/*\n\t\t\t * As per POSIX, only output first character of a\n\t\t\t * string value.  Thus, we ignore any provided\n\t\t\t * precision, forcing it to 1.  (Didn't this\n\t\t\t * used to work? 6/2003.)\n\t\t\t */\n\t\t\tcp = arg->stptr;\n\t\t\tprec = 1;\n\t\t\t/*\n\t\t\t * First character can be multiple bytes if\n\t\t\t * it's a multibyte character. Grr.\n\t\t\t */\n\t\t\tif (gawk_mb_cur_max > 1) {\n\t\t\t\tmbstate_t state;\n\t\t\t\tsize_t count;\n\n\t\t\t\tmemset(& state, 0, sizeof(state));\n\t\t\t\tcount = mbrlen(cp, arg->stlen, & state);\n\t\t\t\tif (count != (size_t) -1 && count != (size_t) -2 && count > 0) {\n\t\t\t\t\tprec = count;\n\t\t\t\t\t/* may need to increase fw so that padding happens, see pr_tail code */\n\t\t\t\t\tif (fw > 0)\n\t\t\t\t\t\tfw += count - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tgoto pr_tail;\n\t\tcase 's':\n\t\t\tneed_format = false;\n\t\t\tparse_next_arg();\n\t\t\targ = force_string(arg);\n\t\t\tif (fw == 0 && ! have_prec)\n\t\t\t\tprec = arg->stlen;\n\t\t\telse {\n\t\t\t\tchar_count = mbc_char_count(arg->stptr, arg->stlen);\n\t\t\t\tif (! have_prec || prec > char_count)\n\t\t\t\t\tprec = char_count;\n\t\t\t}\n\t\t\tcp = arg->stptr;\n\t\t\tgoto pr_tail;\n\t\tcase 'd':\n\t\tcase 'i':\n\t\t\tneed_format = false;\n\t\t\tparse_next_arg();\n\t\t\t(void) force_number(arg);\n#ifdef HAVE_MPFR\n\t\t\tif (is_mpg_float(arg))\n\t\t\t\tgoto mpf0;\n\t\t\telse if (is_mpg_integer(arg))\n\t\t\t\tgoto mpz0;\n\t\t\telse\n#endif\n\t\t\ttmpval = arg->numbr;\n\n\t\t\t/*\n\t\t\t * Check for Nan or Inf.\n\t\t\t */\n\t\t\tif (isnan(tmpval) || isinf(tmpval))\n\t\t\t\tgoto out_of_range;\n\t\t\telse\n\t\t\t\ttmpval = double_to_int(tmpval);\n\n\t\t\t/*\n\t\t\t * ``The result of converting a zero value with a\n\t\t\t * precision of zero is no characters.''\n\t\t\t */\n\t\t\tif (have_prec && prec == 0 && tmpval == 0)\n\t\t\t\tgoto pr_tail;\n\n\t\t\tif (tmpval < 0) {\n\t\t\t\ttmpval = -tmpval;\n\t\t\t\tsgn = true;\n\t\t\t} else {\n\t\t\t\tif (tmpval == -0.0)\n\t\t\t\t\t/* avoid printing -0 */\n\t\t\t\t\ttmpval = 0.0;\n\t\t\t\tsgn = false;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Use snprintf return value to tell if there\n\t\t\t * is enough room in the buffer or not.\n\t\t\t */\n\t\t\twhile ((i = snprintf(cpbufs[1].buf,\n\t\t\t\t\t     cpbufs[1].bufsize, \"%.0f\",\n\t\t\t\t\t     tmpval)) >=\n\t\t\t       cpbufs[1].bufsize) {\n\t\t\t\tif (cpbufs[1].buf == cpbufs[1].stackbuf)\n\t\t\t\t\tcpbufs[1].buf = NULL;\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tcpbufs[1].bufsize += ((i > cpbufs[1].bufsize) ?\n\t\t\t\t\t\t\t      i : cpbufs[1].bufsize);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tcpbufs[1].bufsize *= 2;\n\t\t\t\tassert(cpbufs[1].bufsize > 0);\n\t\t\t\terealloc(cpbufs[1].buf, char *,\n\t\t\t\t\t cpbufs[1].bufsize, \"format_tree\");\n\t\t\t}\n\t\t\tif (i < 1)\n\t\t\t\tgoto out_of_range;\n#if defined(HAVE_LOCALE_H)\n\t\t\tquote_flag = (quote_flag && loc.thousands_sep[0] != 0);\n#endif\n\t\t\tchp = &cpbufs[1].buf[i-1];\n\t\t\tii = jj = 0;\n\t\t\tdo {\n\t\t\t\tPREPEND(*chp);\n\t\t\t\tchp--; i--;\n#if defined(HAVE_LOCALE_H)\n\t\t\t\tif (quote_flag && loc.grouping[ii] && ++jj == loc.grouping[ii]) {\n\t\t\t\t\tif (i) {\t/* only add if more digits coming */\n\t\t\t\t\t\tint k;\n\t\t\t\t\t\tconst char *ts = loc.thousands_sep;\n\n\t\t\t\t\t\tfor (k = strlen(ts) - 1; k >= 0; k--) {\n\t\t\t\t\t\t\tPREPEND(ts[k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (loc.grouping[ii+1] == 0)\n\t\t\t\t\t\tjj = 0;\t\t/* keep using current val in loc.grouping[ii] */\n\t\t\t\t\telse if (loc.grouping[ii+1] == CHAR_MAX)\n\t\t\t\t\t\tquote_flag = false;\n\t\t\t\t\telse {\n\t\t\t\t\t\tii++;\n\t\t\t\t\t\tjj = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n#endif\n\t\t\t} while (i > 0);\n\n\t\t\t/* add more output digits to match the precision */\n\t\t\tif (have_prec) {\n\t\t\t\twhile (cend - cp < prec)\n\t\t\t\t\tPREPEND('0');\n\t\t\t}\n\n\t\t\tif (sgn)\n\t\t\t\tPREPEND('-');\n\t\t\telse if (signchar)\n\t\t\t\tPREPEND(signchar);\n\t\t\t/*\n\t\t\t * When to fill with zeroes is of course not simple.\n\t\t\t * First: No zero fill if left-justifying.\n\t\t\t * Next: There seem to be two cases:\n\t\t\t * \tA '0' without a precision, e.g. %06d\n\t\t\t * \tA precision with no field width, e.g. %.10d\n\t\t\t * Any other case, we don't want to fill with zeroes.\n\t\t\t */\n\t\t\tif (! lj\n\t\t\t    && ((zero_flag && ! have_prec)\n\t\t\t\t || (fw == 0 && have_prec)))\n\t\t\t\tfill = zero_string;\n\t\t\tif (prec > fw)\n\t\t\t\tfw = prec;\n\t\t\tprec = cend - cp;\n\t\t\tif (fw > prec && ! lj && fill != sp\n\t\t\t    && (*cp == '-' || signchar)) {\n\t\t\t\tbchunk_one(cp);\n\t\t\t\tcp++;\n\t\t\t\tprec--;\n\t\t\t\tfw--;\n\t\t\t}\n\t\t\tgoto pr_tail;\n\t\tcase 'X':\n\t\t\tchbuf = Uchbuf;\t/* FALL THROUGH */\n\t\tcase 'x':\n\t\t\tbase += 6;\t/* FALL THROUGH */\n\t\tcase 'u':\n\t\t\tbase += 2;\t/* FALL THROUGH */\n\t\tcase 'o':\n\t\t\tbase += 8;\n\t\t\tneed_format = false;\n\t\t\tparse_next_arg();\n\t\t\t(void) force_number(arg);\n#ifdef HAVE_MPFR\n\t\t\tif (is_mpg_integer(arg)) {\nmpz0:\n\t\t\t\tzi = arg->mpg_i;\n\n\t\t\t\tif (cs1 != 'd' && cs1 != 'i') {\n\t\t\t\t\tif (mpz_sgn(zi) <= 0) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Negative value or 0 requires special handling.\n\t\t\t\t\t\t * Unlike MPFR, GMP does not allow conversion\n\t\t\t\t\t\t * to (u)intmax_t. So we first convert GMP type to\n\t\t\t\t\t\t * a MPFR type.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tmf = mpz2mpfr(zi);\n\t\t\t\t\t\tgoto mpf1;\n\t\t\t\t\t}\n\t\t\t\t\tsignchar = '\\0';\t/* Don't print '+' */\n\t\t\t\t}\n\n\t\t\t\t/* See comments above about when to fill with zeros */\n\t\t\t\tzero_flag = (! lj\n\t\t\t\t\t\t    && ((zero_flag && ! have_prec)\n\t\t\t\t\t\t\t || (fw == 0 && have_prec)));\n\n \t\t\t\tfmt_type = have_prec ? MP_INT_WITH_PREC : MP_INT_WITHOUT_PREC;\n\t\t\t\tgoto fmt0;\n\n\t\t\t} else if (is_mpg_float(arg)) {\nmpf0:\n\t\t\t\tmf = arg->mpg_numbr;\n\t\t\t\tif (! mpfr_number_p(mf)) {\n\t\t\t\t\t/* inf or NaN */\n\t\t\t\t\tcs1 = 'g';\n\t\t\t\t\tfmt_type = MP_FLOAT;\n\t\t\t\t\tgoto fmt1;\n\t\t\t\t}\n\n\t\t\t\tif (cs1 != 'd' && cs1 != 'i') {\nmpf1:\n\t\t\t\t\t/*\n\t\t\t\t\t * The output of printf(\"%#.0x\", 0) is 0 instead of 0x, hence <= in\n\t\t\t\t\t * the comparison below.\n\t\t\t\t\t */\n\t\t\t\t\tif (mpfr_sgn(mf) <= 0) {\n\t\t\t\t\t\tif (! mpfr_fits_intmax_p(mf, ROUND_MODE)) {\n\t\t\t\t\t\t\t/* -ve number is too large */\n\t\t\t\t\t\t\tcs1 = 'g';\n\t\t\t\t\t\t\tfmt_type = MP_FLOAT;\n\t\t\t\t\t\t\tgoto fmt1;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttmpval = uval = (uintmax_t) mpfr_get_sj(mf, ROUND_MODE);\n\t\t\t\t\t\tif (! alt && have_prec && prec == 0 && tmpval == 0)\n\t\t\t\t\t\t\tgoto pr_tail;\t/* printf(\"%.0x\", 0) is no characters */\n\t\t\t\t\t\tgoto int0;\n\t\t\t\t\t}\n\t\t\t\t\tsignchar = '\\0';\t/* Don't print '+' */\n\t\t\t\t}\n\n\t\t\t\t/* See comments above about when to fill with zeros */\n\t\t\t\tzero_flag = (! lj\n\t\t\t\t\t\t    && ((zero_flag && ! have_prec)\n\t\t\t\t\t\t\t || (fw == 0 && have_prec)));\n\n\t\t\t\t(void) mpfr_get_z(mpzval, mf, MPFR_RNDZ);\t/* convert to GMP integer */\n \t\t\t\tfmt_type = have_prec ? MP_INT_WITH_PREC : MP_INT_WITHOUT_PREC;\n\t\t\t\tzi = mpzval;\n\t\t\t\tgoto fmt0;\n\t\t\t} else\n#endif\n\t\t\t\ttmpval = arg->numbr;\n\n\t\t\t/*\n\t\t\t * ``The result of converting a zero value with a\n\t\t\t * precision of zero is no characters.''\n\t\t\t *\n\t\t\t * If I remember the ANSI C standard, though,\n\t\t\t * it says that for octal conversions\n\t\t\t * the precision is artificially increased\n\t\t\t * to add an extra 0 if # is supplied.\n\t\t\t * Indeed, in C,\n\t\t\t * \tprintf(\"%#.0o\\n\", 0);\n\t\t\t * prints a single 0.\n\t\t\t */\n\t\t\tif (! alt && have_prec && prec == 0 && tmpval == 0)\n\t\t\t\tgoto pr_tail;\n\n\t\t\tif (tmpval < 0) {\n\t\t\t\tuval = (uintmax_t) (intmax_t) tmpval;\n\t\t\t\tif ((AWKNUM)(intmax_t)uval != double_to_int(tmpval))\n\t\t\t\t\tgoto out_of_range;\n\t\t\t} else {\n\t\t\t\tuval = (uintmax_t) tmpval;\n\t\t\t\tif ((AWKNUM)uval != double_to_int(tmpval))\n\t\t\t\t\tgoto out_of_range;\n\t\t\t}\n#ifdef HAVE_MPFR\n\tint0:\n#endif\n#if defined(HAVE_LOCALE_H)\n\t\t\tquote_flag = (quote_flag && loc.thousands_sep[0] != 0);\n#endif\n\t\t\t/*\n\t\t\t * When to fill with zeroes is of course not simple.\n\t\t\t * First: No zero fill if left-justifying.\n\t\t\t * Next: There seem to be two cases:\n\t\t\t * \tA '0' without a precision, e.g. %06d\n\t\t\t * \tA precision with no field width, e.g. %.10d\n\t\t\t * Any other case, we don't want to fill with zeroes.\n\t\t\t */\n\t\t\tif (! lj\n\t\t\t    && ((zero_flag && ! have_prec)\n\t\t\t\t || (fw == 0 && have_prec)))\n\t\t\t\tfill = zero_string;\n\t\t\tii = jj = 0;\n\t\t\tdo {\n\t\t\t\tPREPEND(chbuf[uval % base]);\n\t\t\t\tuval /= base;\n#if defined(HAVE_LOCALE_H)\n\t\t\t\tif (base == 10 && quote_flag && loc.grouping[ii] && ++jj == loc.grouping[ii]) {\n\t\t\t\t\tif (uval) {\t/* only add if more digits coming */\n\t\t\t\t\t\tint k;\n\t\t\t\t\t\tconst char *ts = loc.thousands_sep;\n\n\t\t\t\t\t\tfor (k = strlen(ts) - 1; k >= 0; k--) {\n\t\t\t\t\t\t\tPREPEND(ts[k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (loc.grouping[ii+1] == 0)\n\t\t\t\t\t\tjj = 0;     /* keep using current val in loc.grouping[ii] */\n\t\t\t\t\telse if (loc.grouping[ii+1] == CHAR_MAX)\n\t\t\t\t\t\tquote_flag = false;\n\t\t\t\t\telse {\n\t\t\t\t\t\tii++;\n\t\t\t\t\t\tjj = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n#endif\n\t\t\t} while (uval > 0);\n\n\t\t\t/* add more output digits to match the precision */\n\t\t\tif (have_prec) {\n\t\t\t\twhile (cend - cp < prec)\n\t\t\t\t\tPREPEND('0');\n\t\t\t}\n\n\t\t\tif (alt && tmpval != 0) {\n\t\t\t\tif (base == 16) {\n\t\t\t\t\tPREPEND(cs1);\n\t\t\t\t\tPREPEND('0');\n\t\t\t\t\tif (fill != sp) {\n\t\t\t\t\t\tbchunk(cp, 2);\n\t\t\t\t\t\tcp += 2;\n\t\t\t\t\t\tfw -= 2;\n\t\t\t\t\t}\n\t\t\t\t} else if (base == 8)\n\t\t\t\t\tPREPEND('0');\n\t\t\t}\n\t\t\tbase = 0;\n\t\t\tif (prec > fw)\n\t\t\t\tfw = prec;\n\t\t\tprec = cend - cp;\n\tpr_tail:\n\t\t\tif (! lj) {\n\t\t\t\twhile (fw > prec) {\n\t\t\t    \t\tbchunk_one(fill);\n\t\t\t\t\tfw--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcopy_count = prec;\n\t\t\tif (fw == 0 && ! have_prec)\n\t\t\t\t;\n\t\t\telse if (gawk_mb_cur_max > 1) {\n\t\t\t\tif (cs1 == 's') {\n\t\t\t\t\tassert(cp == arg->stptr || cp == cpbuf);\n\t\t\t\t\tcopy_count = mbc_byte_count(arg->stptr, prec);\n\t\t\t\t}\n\t\t\t\t/* prec was set by code for %c */\n\t\t\t\t/* else\n\t\t\t\t\tcopy_count = prec; */\n\t\t\t}\n\t\t\tbchunk(cp, copy_count);\n\t\t\twhile (fw > prec) {\n\t\t\t\tbchunk_one(fill);\n\t\t\t\tfw--;\n\t\t\t}\n\t\t\ts0 = s1;\n\t\t\tbreak;\n\n     out_of_range:\n\t\t\t/* out of range - emergency use of %g format */\n\t\t\tif (do_lint)\n\t\t\t\tlintwarn(_(\"[s]printf: value %g is out of range for `%%%c' format\"),\n\t\t\t\t\t\t\t(double) tmpval, cs1);\n\t\t\tcs1 = 'g';\n\t\t\tgoto fmt1;\n\n\t\tcase 'F':\n#if ! defined(PRINTF_HAS_F_FORMAT) || PRINTF_HAS_F_FORMAT != 1\n\t\t\tcs1 = 'f';\n\t\t\t/* FALL THROUGH */\n#endif\n\t\tcase 'g':\n\t\tcase 'G':\n\t\tcase 'e':\n\t\tcase 'f':\n\t\tcase 'E':\n\t\t\tneed_format = false;\n\t\t\tparse_next_arg();\n\t\t\t(void) force_number(arg);\n\n\t\t\tif (! is_mpg_number(arg))\n\t\t\t\ttmpval = arg->numbr;\n#ifdef HAVE_MPFR\n\t\t\telse if (is_mpg_float(arg)) {\n\t\t\t\tmf = arg->mpg_numbr;\n\t\t\t\tfmt_type = MP_FLOAT;\n\t\t\t} else {\n\t\t\t\t/* arbitrary-precision integer, convert to MPFR float */\n\t\t\t\tassert(mf == NULL);\n\t\t\t\tmf = mpz2mpfr(arg->mpg_i);\n\t\t\t\tfmt_type = MP_FLOAT;\n\t\t\t}\n#endif\n     fmt1:\n\t\t\tif (! have_prec)\n\t\t\t\tprec = DEFAULT_G_PRECISION;\n#ifdef HAVE_MPFR\n     fmt0:\n#endif\n\t\t\tchksize(fw + prec + 11);\t/* 11 == slop */\n\t\t\tcp = cpbuf;\n\t\t\t*cp++ = '%';\n\t\t\tif (lj)\n\t\t\t\t*cp++ = '-';\n\t\t\tif (signchar)\n\t\t\t\t*cp++ = signchar;\n\t\t\tif (alt)\n\t\t\t\t*cp++ = '#';\n\t\t\tif (zero_flag)\n\t\t\t\t*cp++ = '0';\n\t\t\tif (quote_flag)\n\t\t\t\t*cp++ = '\\'';\n\n#if defined(LC_NUMERIC)\n\t\t\tif (quote_flag && ! use_lc_numeric)\n\t\t\t\tsetlocale(LC_NUMERIC, \"\");\n#endif\n\n\t\t\tswitch (fmt_type) {\n#ifdef HAVE_MPFR\n\t\t\tcase MP_INT_WITH_PREC:\n\t\t\t\tsprintf(cp, \"*.*Z%c\", cs1);\n\t\t\t\twhile ((nc = mpfr_snprintf(obufout, ofre, cpbuf,\n\t\t\t\t\t     (int) fw, (int) prec, zi)) >= ofre)\n\t\t\t\t\tchksize(nc)\n\t\t\t\tbreak;\n\t\t\tcase MP_INT_WITHOUT_PREC:\n\t\t\t\tsprintf(cp, \"*Z%c\", cs1);\n\t\t\t\twhile ((nc = mpfr_snprintf(obufout, ofre, cpbuf,\n\t\t\t\t\t     (int) fw, zi)) >= ofre)\n\t\t\t\t\tchksize(nc)\n\t\t\t\tbreak;\n\t\t\tcase MP_FLOAT:\n\t\t\t\tsprintf(cp, \"*.*R*%c\", cs1);\n\t\t\t\twhile ((nc = mpfr_snprintf(obufout, ofre, cpbuf,\n\t\t\t\t\t     (int) fw, (int) prec, ROUND_MODE, mf)) >= ofre)\n\t\t\t\t\tchksize(nc)\n\t\t\t\tbreak;\n#endif\n\t\t\tdefault:\n\t\t\t\tsprintf(cp, \"*.*%c\", cs1);\n\t\t\t\twhile ((nc = snprintf(obufout, ofre, cpbuf,\n\t\t\t\t\t     (int) fw, (int) prec,\n\t\t\t\t\t     (double) tmpval)) >= ofre)\n\t\t\t\t\tchksize(nc)\n\t\t\t}\n\n#if defined(LC_NUMERIC)\n\t\t\tif (quote_flag && ! use_lc_numeric)\n\t\t\t\tsetlocale(LC_NUMERIC, \"C\");\n#endif\n\n\t\t\tlen = strlen(obufout);\n\t\t\tofre -= len;\n\t\t\tobufout += len;\n\t\t\ts0 = s1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (do_lint && is_alpha(cs1))\n\t\t\t\tlintwarn(_(\"ignoring unknown format specifier character `%c': no argument converted\"), cs1);\n\t\t\tbreak;\n\t\t}\n\t\tif (toofew) {\n\t\t\tmsg(\"%s\\n\\t`%s'\\n\\t%*s%s\",\n\t\t\t      _(\"fatal: not enough arguments to satisfy format string\"),\n\t\t\t      fmt_string, (int) (s1 - fmt_string - 1), \"\",\n\t\t\t      _(\"^ ran out for this one\"));\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (do_lint) {\n\t\tif (need_format)\n\t\t\tlintwarn(\n\t\t\t_(\"[s]printf: format specifier does not have control letter\"));\n\t\tif (cur_arg < num_args)\n\t\t\tlintwarn(\n\t\t\t_(\"too many arguments supplied for format string\"));\n\t}\n\tbchunk(s0, s1 - s0);\n\tolen_final = obufout - obuf;\n\tif (ofre > 0)\n\t\terealloc(obuf, char *, olen_final + 1, \"format_tree\");\n\tr = make_str_node(obuf, olen_final, ALREADY_MALLOCED);\n\tobuf = NULL;\nout:\n\t{\n\t\tsize_t k;\n\t\tsize_t count = sizeof(cpbufs)/sizeof(cpbufs[0]);\n\t\tfor (k = 0; k < count; k++) {\n\t\t\tif (cpbufs[k].buf != cpbufs[k].stackbuf)\n\t\t\t\tefree(cpbufs[k].buf);\n\t\t}\n\t\tif (obuf != NULL)\n\t\t\tefree(obuf);\n\t}\n\n\tif (r == NULL)\n\t\tgawk_exit(EXIT_FATAL);\n\treturn r;\n}",
      "lines": 982,
      "depth": 22,
      "decorators": [
        "NODE",
        "*\nformat_tree(\n\tconst char *fmt_string,\n\tsize_t n0,\n\tNODE **the_args,\n\tlong num_args)",
        "*"
      ]
    },
    "printf_common": {
      "start_point": [
        1623,
        0
      ],
      "end_point": [
        1644,
        1
      ],
      "content": "static NODE *\nprintf_common(int nargs)\n{\n\tint i;\n\tNODE *r, *tmp;\n\n\tassert(nargs > 0 && nargs <= max_args);\n\tfor (i = 1; i <= nargs; i++) {\n\t\ttmp = args_array[nargs - i] = POP();\n\t\tif (tmp->type == Node_var_array) {\n\t\t\twhile (--i > 0)\n\t\t\t\tDEREF(args_array[nargs - i]);\n\t\t\tfatal(_(\"attempt to use array `%s' in a scalar context\"), array_vname(tmp));\n\t\t}\n\t}\n\n\targs_array[0] = force_string(args_array[0]);\n\tr = format_tree(args_array[0]->stptr, args_array[0]->stlen, args_array, nargs);\n\tfor (i = 0; i < nargs; i++)\n\t\tDEREF(args_array[i]);\n\treturn r;\n}",
      "lines": 22,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "NODE",
        "*\nprintf_common(int nargs)",
        "*"
      ]
    },
    "do_sprintf": {
      "start_point": [
        1648,
        0
      ],
      "end_point": [
        1660,
        1
      ],
      "content": "NODE *\ndo_sprintf(int nargs)\n{\n\tNODE *r;\n\n\tif (nargs == 0)\n\t\tfatal(_(\"sprintf: no arguments\"));\n\n\tr = printf_common(nargs);\n\tif (r == NULL)\n\t\tgawk_exit(EXIT_FATAL);\n\treturn r;\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "NODE",
        "*\ndo_sprintf(int nargs)",
        "*"
      ]
    },
    "do_printf": {
      "start_point": [
        1665,
        0
      ],
      "end_point": [
        1732,
        1
      ],
      "content": "void\ndo_printf(int nargs, int redirtype)\n{\n\tFILE *fp = NULL;\n\tNODE *tmp;\n\tstruct redirect *rp = NULL;\n\tint errflg = 0;\n\tNODE *redir_exp = NULL;\n\n\tif (nargs == 0) {\n\t\tif (do_traditional) {\n\t\t\tif (do_lint)\n\t\t\t\tlintwarn(_(\"printf: no arguments\"));\n\t\t\tif (redirtype != 0) {\n\t\t\t\tredir_exp = TOP();\n\t\t\t\tif (redir_exp->type != Node_val)\n\t\t\t\t\tfatal(_(\"attempt to use array `%s' in a scalar context\"), array_vname(redir_exp));\n\t\t\t\trp = redirect(redir_exp, redirtype, & errflg, true);\n\t\t\t\tDEREF(redir_exp);\n\t\t\t\tdecr_sp();\n\t\t\t}\n\t\t\treturn;\t/* bwk accepts it silently */\n\t\t}\n\t\tfatal(_(\"printf: no arguments\"));\n\t}\n\n\tif (redirtype != 0) {\n\t\tredir_exp = PEEK(nargs);\n\t\tif (redir_exp->type != Node_val)\n\t\t\tfatal(_(\"attempt to use array `%s' in a scalar context\"), array_vname(redir_exp));\n\t\trp = redirect(redir_exp, redirtype, & errflg, true);\n\t\tif (rp != NULL) {\n\t\t\tif ((rp->flag & RED_TWOWAY) != 0 && rp->output.fp == NULL) {\n\t\t\t\tif (is_non_fatal_redirect(redir_exp->stptr, redir_exp->stlen)) {\n\t\t\t\t\tupdate_ERRNO_int(EBADF);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t(void) close_rp(rp, CLOSE_ALL);\n\t\t\t\tfatal(_(\"printf: attempt to write to closed write end of two-way pipe\"));\n\t\t\t}\n\t\t\tfp = rp->output.fp;\n\t\t}\n\t\telse if (errflg) {\n\t\t\tupdate_ERRNO_int(errflg);\n\t\t\treturn;\n\t\t}\n\t} else if (do_debug)\t/* only the debugger can change the default output */\n\t\tfp = output_fp;\n\telse\n\t\tfp = stdout;\n\n\ttmp = printf_common(nargs);\n\tif (redir_exp != NULL) {\n\t\tDEREF(redir_exp);\n\t\tdecr_sp();\n\t}\n\tif (tmp != NULL) {\n\t\tif (fp == NULL) {\n\t\t\tDEREF(tmp);\n\t\t\treturn;\n\t\t}\n\t\tefwrite(tmp->stptr, sizeof(char), tmp->stlen, fp, \"printf\", rp, true);\n\t\tif (rp != NULL && (rp->flag & RED_TWOWAY) != 0)\n\t\t\trp->output.gawk_fflush(rp->output.fp, rp->output.opaque);\n\t\tDEREF(tmp);\n\t} else\n\t\tgawk_exit(EXIT_FATAL);\n}",
      "lines": 68,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "do_sqrt": {
      "start_point": [
        1736,
        0
      ],
      "end_point": [
        1750,
        1
      ],
      "content": "NODE *\ndo_sqrt(int nargs)\n{\n\tNODE *tmp;\n\tdouble arg;\n\n\ttmp = POP_SCALAR();\n\tif (do_lint && (fixtype(tmp)->flags & NUMBER) == 0)\n\t\tlintwarn(_(\"sqrt: received non-numeric argument\"));\n\targ = (double) force_number(tmp)->numbr;\n\tDEREF(tmp);\n\tif (arg < 0.0)\n\t\twarning(_(\"sqrt: called with negative argument %g\"), arg);\n\treturn make_number((AWKNUM) sqrt(arg));\n}",
      "lines": 15,
      "depth": 12,
      "decorators": [
        "NODE",
        "*\ndo_sqrt(int nargs)",
        "*"
      ]
    },
    "do_substr": {
      "start_point": [
        1754,
        0
      ],
      "end_point": [
        1899,
        1
      ],
      "content": "NODE *\ndo_substr(int nargs)\n{\n\tNODE *t1;\n\tNODE *r;\n\tsize_t indx;\n\tsize_t length = 0;\n\tdouble d_index = 0, d_length = 0;\n\tsize_t src_len;\n\n\tif (nargs == 3) {\n\t\tt1 = POP_NUMBER();\n\t\td_length = get_number_d(t1);\n\t\tDEREF(t1);\n\t}\n\n\tt1 = POP_NUMBER();\n\td_index = get_number_d(t1);\n\tDEREF(t1);\n\n\tt1 = POP_STRING();\n\n\tif (nargs == 3) {\n\t\tif (! (d_length >= 1)) {\n\t\t\tif (do_lint == DO_LINT_ALL)\n\t\t\t\tlintwarn(_(\"substr: length %g is not >= 1\"), d_length);\n\t\t\telse if (do_lint == DO_LINT_INVALID && ! (d_length >= 0))\n\t\t\t\tlintwarn(_(\"substr: length %g is not >= 0\"), d_length);\n\t\t\tDEREF(t1);\n\t\t\t/*\n\t\t\t * Return explicit null string instead of doing\n\t\t\t * dupnode(Nnull_string) so that if the result\n\t\t\t * is checked with the combination of length()\n\t\t\t * and lint, no error is reported about using\n\t\t\t * an uninitialized value. Same thing later, too.\n\t\t\t */\n\t\t\treturn make_string(\"\", 0);\n\t\t}\n\t\tif (do_lint) {\n\t\t\tif (double_to_int(d_length) != d_length)\n\t\t\t\tlintwarn(\n\t\t\t_(\"substr: non-integer length %g will be truncated\"),\n\t\t\t\t\td_length);\n\n\t\t\tif (d_length > SIZE_MAX)\n\t\t\t\tlintwarn(\n\t\t\t_(\"substr: length %g too big for string indexing, truncating to %g\"),\n\t\t\t\t\td_length, (double) SIZE_MAX);\n\t\t}\n\t\tif (d_length < SIZE_MAX)\n\t\t\tlength = d_length;\n\t\telse\n\t\t\tlength = SIZE_MAX;\n\t}\n\n\t/* the weird `! (foo)' tests help catch NaN values. */\n\tif (! (d_index >= 1)) {\n\t\tif (do_lint)\n\t\t\tlintwarn(_(\"substr: start index %g is invalid, using 1\"),\n\t\t\t\t d_index);\n\t\td_index = 1;\n\t}\n\tif (do_lint && double_to_int(d_index) != d_index)\n\t\tlintwarn(_(\"substr: non-integer start index %g will be truncated\"),\n\t\t\t d_index);\n\n\t/* awk indices are from 1, C's are from 0 */\n\tif (d_index <= SIZE_MAX)\n\t\tindx = d_index - 1;\n\telse\n\t\tindx = SIZE_MAX;\n\n\tif (nargs == 2) {\t/* third arg. missing */\n\t\t/* use remainder of string */\n\t\tlength = t1->stlen - indx;\t/* default to bytes */\n\t\tif (gawk_mb_cur_max > 1) {\n\t\t\tt1 = force_wstring(t1);\n\t\t\tif (t1->wstlen > 0)\t/* use length of wide char string if we have one */\n\t\t\t\tlength = t1->wstlen - indx;\n\t\t}\n\t\td_length = length;\t/* set here in case used in diagnostics, below */\n\t}\n\n\tif (t1->stlen == 0) {\n\t\t/* substr(\"\", 1, 0) produces a warning only if LINT_ALL */\n\t\tif (do_lint && (do_lint == DO_LINT_ALL || ((indx | length) != 0)))\n\t\t\tlintwarn(_(\"substr: source string is zero length\"));\n\t\tDEREF(t1);\n\t\treturn make_string(\"\", 0);\n\t}\n\n\t/* get total len of input string, for following checks */\n\tif (gawk_mb_cur_max > 1) {\n\t\tt1 = force_wstring(t1);\n\t\tsrc_len = t1->wstlen;\n\t} else\n\t\tsrc_len = t1->stlen;\n\n\tif (indx >= src_len) {\n\t\tif (do_lint)\n\t\t\tlintwarn(_(\"substr: start index %g is past end of string\"),\n\t\t\t\td_index);\n\t\tDEREF(t1);\n\t\treturn make_string(\"\", 0);\n\t}\n\tif (length > src_len - indx) {\n\t\tif (do_lint)\n\t\t\tlintwarn(\n\t_(\"substr: length %g at start index %g exceeds length of first argument (%lu)\"),\n\t\t\td_length, d_index, (unsigned long int) src_len);\n\t\tlength = src_len - indx;\n\t}\n\n\t/* force_wstring() already called */\n\tif (gawk_mb_cur_max == 1 || t1->wstlen == t1->stlen)\n\t\t/* single byte case */\n\t\tr = make_string(t1->stptr + indx, length);\n\telse {\n\t\t/* multibyte case, more work */\n\t\tsize_t result;\n\t\twchar_t *wp;\n\t\tmbstate_t mbs;\n\t\tchar *substr, *cp;\n\n\t\t/*\n\t\t * Convert the wide chars in t1->wstptr back into m.b. chars.\n\t\t * This is pretty grotty, but it's the most straightforward\n\t\t * way to do things.\n\t\t */\n\t\tmemset(& mbs, 0, sizeof(mbs));\n\t\temalloc(substr, char *, (length * gawk_mb_cur_max) + 1, \"do_substr\");\n\t\twp = t1->wstptr + indx;\n\t\tfor (cp = substr; length > 0; length--) {\n\t\t\tresult = wcrtomb(cp, *wp, & mbs);\n\t\t\tif (result == (size_t) -1)\t/* what to do? break seems best */\n\t\t\t\tbreak;\n\t\t\tcp += result;\n\t\t\twp++;\n\t\t}\n\t\t*cp = '\\0';\n\t\tr = make_str_node(substr, cp - substr, ALREADY_MALLOCED);\n\t}\n\n\tDEREF(t1);\n\treturn r;\n}",
      "lines": 146,
      "depth": 15,
      "decorators": [
        "NODE",
        "*\ndo_substr(int nargs)",
        "*"
      ]
    },
    "do_strftime": {
      "start_point": [
        1903,
        0
      ],
      "end_point": [
        2035,
        1
      ],
      "content": "NODE *\ndo_strftime(int nargs)\n{\n\tNODE *t1, *t2, *t3, *ret;\n\tstruct tm *tm;\n\ttime_t fclock;\n\tdouble clock_val;\n\tchar *bufp;\n\tsize_t buflen, bufsize;\n\tchar buf[BUFSIZ];\n\tconst char *format;\n\tint formatlen;\n\tbool do_gmt;\n\tNODE *val = NULL;\n\tNODE *sub = NULL;\n\tchar save = '\\0';\t// initialize to avoid compiler warnings\n\tstatic const time_t time_t_min = TYPE_MINIMUM(time_t);\n\tstatic const time_t time_t_max = TYPE_MAXIMUM(time_t);\n\n\t/* set defaults first */\n\tformat = def_strftime_format;\t/* traditional date format */\n\tformatlen = strlen(format);\n\t(void) time(& fclock);\t/* current time of day */\n\tdo_gmt = false;\n\n\tif (PROCINFO_node != NULL) {\n\t\tsub = make_string(\"strftime\", 8);\n\t\tval = in_array(PROCINFO_node, sub);\n\t\tunref(sub);\n\n\t\tif (val != NULL) {\n\t\t\tif (do_lint && (fixtype(val)->flags & STRING) == 0)\n\t\t\t\tlintwarn(_(\"strftime: format value in PROCINFO[\\\"strftime\\\"] has numeric type\"));\n\t\t\tval = force_string(val);\n\t\t\tformat = val->stptr;\n\t\t\tformatlen = val->stlen;\n\t\t}\n\t}\n\n\tt1 = t2 = t3 = NULL;\n\tif (nargs > 0) {\t/* have args */\n\t\tNODE *tmp;\n\n\t\tif (nargs == 3) {\n\t\t\tt3 = POP_SCALAR();\n\t\t\tdo_gmt = boolval(t3);\n\t\t\tDEREF(t3);\n\t\t}\n\n\t\tif (nargs >= 2) {\n\t\t\tt2 = POP_SCALAR();\n\t\t\tif (do_lint && (fixtype(t2)->flags & NUMBER) == 0)\n\t\t\t\tlintwarn(_(\"strftime: received non-numeric second argument\"));\n\t\t\t(void) force_number(t2);\n\t\t\tclock_val = get_number_d(t2);\n\t\t\tfclock = (time_t) clock_val;\n\t\t\t/*\n\t\t\t * Protect against negative value being assigned\n\t\t\t * to unsigned time_t.\n\t\t\t */\n\t\t\tif (clock_val < 0 && fclock > 0) {\n\t\t\t\tif (do_lint)\n\t\t\t\t\tlintwarn(_(\"strftime: second argument less than 0 or too big for time_t\"));\n\t\t\t\treturn make_string(\"\", 0);\n\t\t\t}\n\n\t\t\t/* And check that the value is in range */\n\t\t\tif (clock_val < time_t_min || clock_val > time_t_max) {\n\t\t\t\tif (do_lint)\n\t\t\t\t\tlintwarn(_(\"strftime: second argument out of range for time_t\"));\n\t\t\t\treturn make_string(\"\", 0);\n\t\t\t}\n\n\t\t\tDEREF(t2);\n\t\t}\n\n\t\ttmp = POP_SCALAR();\n\t\tif (do_lint && (fixtype(tmp)->flags & STRING) == 0)\n\t\t\tlintwarn(_(\"strftime: received non-string first argument\"));\n\n\t\tt1 = force_string(tmp);\n\t\tformat = t1->stptr;\n\t\tformatlen = t1->stlen;\n\t\tif (formatlen == 0) {\n\t\t\tif (do_lint)\n\t\t\t\tlintwarn(_(\"strftime: received empty format string\"));\n\t\t\tDEREF(t1);\n\t\t\treturn make_string(\"\", 0);\n\t\t}\n\t\tstr_terminate(t1, save);\n\t}\n\n\tif (do_gmt)\n\t\ttm = gmtime(& fclock);\n\telse\n\t\ttm = localtime(& fclock);\n\n\tif (tm == NULL) {\n\t\tret = make_string(\"\", 0);\n\t\tgoto done;\n\t}\n\n\tbufp = buf;\n\tbufsize = sizeof(buf);\n\tfor (;;) {\n\t\t*bufp = '\\0';\n\t\tbuflen = strftime(bufp, bufsize, format, tm);\n\t\t/*\n\t\t * buflen can be zero EITHER because there's not enough\n\t\t * room in the string, or because the control command\n\t\t * goes to the empty string. Make a reasonable guess that\n\t\t * if the buffer is 1024 times bigger than the length of the\n\t\t * format string, it's not failing for lack of room.\n\t\t * Thanks to Paul Eggert for pointing out this issue.\n\t\t */\n\t\tif (buflen > 0 || bufsize >= 1024 * formatlen)\n\t\t\tbreak;\n\t\tbufsize *= 2;\n\t\tif (bufp == buf)\n\t\t\temalloc(bufp, char *, bufsize, \"do_strftime\");\n\t\telse\n\t\t\terealloc(bufp, char *, bufsize, \"do_strftime\");\n\t}\n\tret = make_string(bufp, buflen);\n\tif (bufp != buf)\n\t\tefree(bufp);\ndone:\n\tif (t1) {\n\t\tstr_restore(t1, save);\n\t\tDEREF(t1);\n\t}\n\treturn ret;\n}",
      "lines": 133,
      "depth": 16,
      "decorators": [
        "NODE",
        "*\ndo_strftime(int nargs)",
        "*"
      ]
    },
    "do_systime": {
      "start_point": [
        2039,
        0
      ],
      "end_point": [
        2046,
        1
      ],
      "content": "NODE *\ndo_systime(int nargs ATTRIBUTE_UNUSED)\n{\n\ttime_t lclock;\n\n\t(void) time(& lclock);\n\treturn make_number((AWKNUM) lclock);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "NODE",
        "*\ndo_systime(int nargs ATTRIBUTE_UNUSED)",
        "*"
      ]
    },
    "mktime_tz": {
      "start_point": [
        2050,
        0
      ],
      "end_point": [
        2074,
        1
      ],
      "content": "static time_t\nmktime_tz(struct tm *tm, const char *tzreq)\n{\n\ttime_t ret;\n\tchar *tz = getenv(\"TZ\");\n\n\tif (tz)\n\t\ttz = estrdup(tz, strlen(tz));\n\tif (setenv(\"TZ\", tzreq, 1) < 0) {\n\t\twarning(_(\"setenv(TZ, %s) failed (%s)\"), tzreq, strerror(errno));\n\t\treturn -1;\n\t}\n\ttzset();\n\tret = mktime(tm);\n\tif (tz) {\n\t\tif (setenv(\"TZ\", tz, 1) < 0)\n\t\t\tfatal(_(\"setenv(TZ, %s) restoration failed (%s)\"), tz, strerror(errno));\n\t\tfree(tz);\n\t} else {\n\t\tif (unsetenv(\"TZ\") < 0)\n\t\t\tfatal(_(\"unsetenv(TZ) failed (%s)\"), strerror(errno));\n\t}\n\ttzset();\n\treturn ret;\n}",
      "lines": 25,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "time_t"
      ]
    },
    "do_mktime": {
      "start_point": [
        2078,
        0
      ],
      "end_point": [
        2138,
        1
      ],
      "content": "NODE *\ndo_mktime(int nargs)\n{\n\tNODE *t1, *t2;\n\tstruct tm then;\n\tlong year;\n\tint month, day, hour, minute, second, count;\n\tint dst = -1; /* default is unknown */\n\ttime_t then_stamp;\n\tchar save;\n\tbool do_gmt;\n\n\tif (nargs == 2) {\n\t\tt2 = POP_SCALAR();\n\t\tdo_gmt = boolval(t2);\n\t\tDEREF(t2);\n\t}\n\telse\n\t\tdo_gmt = false;\n\tt1 = POP_SCALAR();\n\tif (do_lint && (fixtype(t1)->flags & STRING) == 0)\n\t\tlintwarn(_(\"mktime: received non-string argument\"));\n\tt1 = force_string(t1);\n\n\tsave = t1->stptr[t1->stlen];\n\tt1->stptr[t1->stlen] = '\\0';\n\n\tcount = sscanf(t1->stptr, \"%ld %d %d %d %d %d %d\",\n\t\t        & year, & month, & day,\n\t\t\t& hour, & minute, & second,\n\t\t        & dst);\n\n\tif (   do_lint /* Ready? Set! Go: */\n\t    && (   (second < 0 || second > 60)\n\t\t|| (minute < 0 || minute > 59)\n\t\t|| (hour < 0 || hour > 23) /* FIXME ISO 8601 allows 24 ? */\n\t\t|| (day < 1 || day > 31)\n\t\t|| (month < 1 || month > 12) ))\n\t\t\tlintwarn(_(\"mktime: at least one of the values is out of the default range\"));\n\n\tt1->stptr[t1->stlen] = save;\n\tDEREF(t1);\n\n\tif (count < 6\n\t    || month == INT_MIN\n\t    || year < INT_MIN + 1900\n\t    || year - 1900 > INT_MAX)\n\t\treturn make_number((AWKNUM) -1);\n\n\tmemset(& then, '\\0', sizeof(then));\n\tthen.tm_sec = second;\n\tthen.tm_min = minute;\n\tthen.tm_hour = hour;\n\tthen.tm_mday = day;\n\tthen.tm_mon = month - 1;\n\tthen.tm_year = year - 1900;\n\tthen.tm_isdst = dst;\n\n\tthen_stamp = (do_gmt ? mktime_tz(& then, \"UTC+0\") : mktime(& then));\n\treturn make_number((AWKNUM) then_stamp);\n}",
      "lines": 61,
      "depth": 14,
      "decorators": [
        "NODE",
        "*\ndo_mktime(int nargs)",
        "*"
      ]
    },
    "do_system": {
      "start_point": [
        2142,
        0
      ],
      "end_point": [
        2198,
        1
      ],
      "content": "NODE *\ndo_system(int nargs)\n{\n\tNODE *tmp;\n\tAWKNUM ret = 0;\t\t/* floating point on purpose, compat Unix awk */\n\tchar *cmd;\n\tchar save;\n\tint status;\n\n\tif (do_sandbox)\n\t\tfatal(_(\"'system' function not allowed in sandbox mode\"));\n\n\t(void) flush_io();     /* so output is synchronous with gawk's */\n\ttmp = POP_SCALAR();\n\tif (do_lint && (fixtype(tmp)->flags & STRING) == 0)\n\t\tlintwarn(_(\"system: received non-string argument\"));\n\tcmd = force_string(tmp)->stptr;\n\n\tif (cmd && *cmd) {\n\t\t/* insure arg to system is zero-terminated */\n\t\tsave = cmd[tmp->stlen];\n\t\tcmd[tmp->stlen] = '\\0';\n\n\t\tos_restore_mode(fileno(stdin));\n\t\tset_sigpipe_to_default();\n\n\t\tstatus = system(cmd);\n\t\t/*\n\t\t * 3/2016. What to do with ret? It's never simple.\n\t\t * POSIX says to use the full return value. BWK awk\n\t\t * divides the result by 256.  That normally gives the\n\t\t * exit status but gives a weird result for death-by-signal.\n\t\t * So we compromise as follows:\n\t\t */\n\t\tret = status;\n\t\tif (status != -1) {\n\t\t\tif (do_posix)\n\t\t\t\t;\t/* leave it alone, full 16 bits */\n\t\t\telse if (do_traditional)\n#ifdef __MINGW32__\n\t\t\t\tret = (((unsigned)status) & ~0xC0000000);\n#else\n\t\t\t\tret = (status / 256.0);\n#endif\n\t\t\telse\n\t\t\t\tret = sanitize_exit_status(status);\n\t\t}\n\n\t\tif ((BINMODE & BINMODE_INPUT) != 0)\n\t\t\tos_setbinmode(fileno(stdin), O_BINARY);\n\t\tignore_sigpipe();\n\n\t\tcmd[tmp->stlen] = save;\n\t}\n\tDEREF(tmp);\n\treturn make_number((AWKNUM) ret);\n}",
      "lines": 57,
      "depth": 16,
      "decorators": [
        "NODE",
        "*\ndo_system(int nargs)",
        "*"
      ]
    },
    "do_print": {
      "start_point": [
        2202,
        0
      ],
      "end_point": [
        2275,
        1
      ],
      "content": "void\ndo_print(int nargs, int redirtype)\n{\n\tstruct redirect *rp = NULL;\n\tint errflg = 0;\n\tFILE *fp = NULL;\n\tint i;\n\tNODE *redir_exp = NULL;\n\tNODE *tmp = NULL;\n\n\tassert(nargs <= max_args);\n\n\tif (redirtype != 0) {\n\t\tredir_exp = PEEK(nargs);\n\t\tif (redir_exp->type != Node_val)\n\t\t\tfatal(_(\"attempt to use array `%s' in a scalar context\"), array_vname(redir_exp));\n\t\trp = redirect(redir_exp, redirtype, & errflg, true);\n\t\tif (rp != NULL) {\n\t\t\tif ((rp->flag & RED_TWOWAY) != 0 && rp->output.fp == NULL) {\n\t\t\t\tif (is_non_fatal_redirect(redir_exp->stptr, redir_exp->stlen)) {\n\t\t\t\t\tupdate_ERRNO_int(EBADF);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t(void) close_rp(rp, CLOSE_ALL);\n\t\t\t\tfatal(_(\"print: attempt to write to closed write end of two-way pipe\"));\n\t\t\t}\n\t\t\tfp = rp->output.fp;\n\t\t}\n\t\telse if (errflg) {\n\t\t\tupdate_ERRNO_int(errflg);\n\t\t\treturn;\n\t\t}\n\t} else if (do_debug)\t/* only the debugger can change the default output */\n\t\tfp = output_fp;\n\telse\n\t\tfp = stdout;\n\n\tfor (i = 1; i <= nargs; i++) {\n\t\ttmp = args_array[i] = POP();\n\t\tif (tmp->type == Node_var_array) {\n\t\t\twhile (--i > 0)\n\t\t\t\tDEREF(args_array[i]);\n\t\t\tfatal(_(\"attempt to use array `%s' in a scalar context\"), array_vname(tmp));\n\t\t}\n\t\t// Let force_string_ofmt handle checking if things\n\t\t// are already valid.\n\t\targs_array[i] = force_string_ofmt(tmp);\n\t}\n\n\tif (redir_exp != NULL) {\n\t\tDEREF(redir_exp);\n\t\tdecr_sp();\n\t}\n\n\tif (fp == NULL) {\n\t\tfor (i = nargs; i > 0; i--)\n\t\t\tDEREF(args_array[i]);\n\t\treturn;\n\t}\n\n\tfor (i = nargs; i > 0; i--) {\n\t\tefwrite(args_array[i]->stptr, sizeof(char), args_array[i]->stlen, fp, \"print\", rp, false);\n\t\tDEREF(args_array[i]);\n\t\tif (i != 1 && OFSlen > 0)\n\t\t\tefwrite(OFS, sizeof(char), (size_t) OFSlen,\n\t\t\t\tfp, \"print\", rp, false);\n\n\t}\n\tif (ORSlen > 0)\n\t\tefwrite(ORS, sizeof(char), (size_t) ORSlen, fp, \"print\", rp, true);\n\n\tif (rp != NULL && (rp->flag & RED_TWOWAY) != 0)\n\t\trp->output.gawk_fflush(rp->output.fp, rp->output.opaque);\n}",
      "lines": 74,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "do_print_rec": {
      "start_point": [
        2279,
        0
      ],
      "end_point": [
        2331,
        1
      ],
      "content": "void\ndo_print_rec(int nargs, int redirtype)\n{\n\tFILE *fp = NULL;\n\tNODE *f0;\n\tstruct redirect *rp = NULL;\n\tint errflg = 0;\n\tNODE *redir_exp = NULL;\n\n\tassert(nargs == 0);\n\tif (redirtype != 0) {\n\t\tredir_exp = TOP();\n\t\trp = redirect(redir_exp, redirtype, & errflg, true);\n\t\tif (rp != NULL) {\n\t\t\tif ((rp->flag & RED_TWOWAY) != 0 && rp->output.fp == NULL) {\n\t\t\t\tif (is_non_fatal_redirect(redir_exp->stptr, redir_exp->stlen)) {\n\t\t\t\t\tupdate_ERRNO_int(EBADF);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t(void) close_rp(rp, CLOSE_ALL);\n\t\t\t\tfatal(_(\"print: attempt to write to closed write end of two-way pipe\"));\n\t\t\t}\n\t\t\tfp = rp->output.fp;\n\t\t}\n\t\tDEREF(redir_exp);\n\t\tdecr_sp();\n\t} else\n\t\tfp = output_fp;\n\n\tif (errflg) {\n\t\tupdate_ERRNO_int(errflg);\n\t\treturn;\n\t}\n\n\tif (fp == NULL)\n\t\treturn;\n\n\tif (! field0_valid)\n\t\t(void) get_field(0L, NULL);\t/* rebuild record */\n\n\tf0 = fields_arr[0];\n\n\tif (do_lint && (f0->flags & NULL_FIELD) != 0)\n\t\tlintwarn(_(\"reference to uninitialized field `$%d'\"), 0);\n\n\tefwrite(f0->stptr, sizeof(char), f0->stlen, fp, \"print\", rp, false);\n\n\tif (ORSlen > 0)\n\t\tefwrite(ORS, sizeof(char), (size_t) ORSlen, fp, \"print\", rp, true);\n\n\tif (rp != NULL && (rp->flag & RED_TWOWAY) != 0)\n\t\trp->output.gawk_fflush(rp->output.fp, rp->output.opaque);\n}",
      "lines": 53,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "is_wupper": {
      "start_point": [
        2336,
        0
      ],
      "end_point": [
        2340,
        1
      ],
      "content": "static int\nis_wupper(wchar_t c)\n{\n\treturn iswupper(c);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "is_wlower": {
      "start_point": [
        2344,
        0
      ],
      "end_point": [
        2348,
        1
      ],
      "content": "static int\nis_wlower(wchar_t c)\n{\n\treturn iswlower(c);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "to_wlower": {
      "start_point": [
        2352,
        0
      ],
      "end_point": [
        2356,
        1
      ],
      "content": "static int\nto_wlower(wchar_t c)\n{\n\treturn towlower(c);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "to_wupper": {
      "start_point": [
        2360,
        0
      ],
      "end_point": [
        2364,
        1
      ],
      "content": "static int\nto_wupper(wchar_t c)\n{\n\treturn towupper(c);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "wide_change_case": {
      "start_point": [
        2368,
        0
      ],
      "end_point": [
        2380,
        1
      ],
      "content": "static void\nwide_change_case(wchar_t *wstr,\n\t\t\tsize_t wlen,\n\t\t\tint (*is_x)(wchar_t c),\n\t\t\tint (*to_y)(wchar_t c))\n{\n\tsize_t i;\n\twchar_t *wcp;\n\n\tfor (i = 0, wcp = wstr; i < wlen; i++, wcp++)\n\t\tif (is_x(*wcp))\n\t\t\t*wcp = to_y(*wcp);\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "wide_toupper": {
      "start_point": [
        2384,
        0
      ],
      "end_point": [
        2388,
        1
      ],
      "content": "static void\nwide_toupper(wchar_t *wstr, size_t wlen)\n{\n\twide_change_case(wstr, wlen, is_wlower, to_wupper);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "wide_tolower": {
      "start_point": [
        2392,
        0
      ],
      "end_point": [
        2396,
        1
      ],
      "content": "static void\nwide_tolower(wchar_t *wstr, size_t wlen)\n{\n\twide_change_case(wstr, wlen, is_wupper, to_wlower);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "do_tolower": {
      "start_point": [
        2400,
        0
      ],
      "end_point": [
        2427,
        1
      ],
      "content": "NODE *\ndo_tolower(int nargs)\n{\n\tNODE *t1, *t2;\n\n\tt1 = POP_SCALAR();\n\tif (do_lint && (fixtype(t1)->flags & STRING) == 0)\n\t\tlintwarn(_(\"tolower: received non-string argument\"));\n\tt1 = force_string(t1);\n\tt2 = make_string(t1->stptr, t1->stlen);\n\n\tif (gawk_mb_cur_max == 1) {\n\t\tunsigned char *cp, *cp2;\n\n\t\tfor (cp = (unsigned char *)t2->stptr,\n\t\t     cp2 = (unsigned char *)(t2->stptr + t2->stlen);\n\t\t\tcp < cp2; cp++)\n\t\t\tif (isupper(*cp))\n\t\t\t\t*cp = tolower(*cp);\n\t} else {\n\t\tforce_wstring(t2);\n\t\twide_tolower(t2->wstptr, t2->wstlen);\n\t\twstr2str(t2);\n\t}\n\n\tDEREF(t1);\n\treturn t2;\n}",
      "lines": 28,
      "depth": 12,
      "decorators": [
        "NODE",
        "*\ndo_tolower(int nargs)",
        "*"
      ]
    },
    "do_toupper": {
      "start_point": [
        2431,
        0
      ],
      "end_point": [
        2458,
        1
      ],
      "content": "NODE *\ndo_toupper(int nargs)\n{\n\tNODE *t1, *t2;\n\n\tt1 = POP_SCALAR();\n\tif (do_lint && (fixtype(t1)->flags & STRING) == 0)\n\t\tlintwarn(_(\"toupper: received non-string argument\"));\n\tt1 = force_string(t1);\n\tt2 = make_string(t1->stptr, t1->stlen);\n\n\tif (gawk_mb_cur_max == 1) {\n\t\tunsigned char *cp, *cp2;\n\n\t\tfor (cp = (unsigned char *)t2->stptr,\n\t\t     cp2 = (unsigned char *)(t2->stptr + t2->stlen);\n\t\t\tcp < cp2; cp++)\n\t\t\tif (islower(*cp))\n\t\t\t\t*cp = toupper(*cp);\n\t} else {\n\t\tforce_wstring(t2);\n\t\twide_toupper(t2->wstptr, t2->wstlen);\n\t\twstr2str(t2);\n\t}\n\n\tDEREF(t1);\n\treturn t2;\n}",
      "lines": 28,
      "depth": 12,
      "decorators": [
        "NODE",
        "*\ndo_toupper(int nargs)",
        "*"
      ]
    },
    "do_atan2": {
      "start_point": [
        2462,
        0
      ],
      "end_point": [
        2480,
        1
      ],
      "content": "NODE *\ndo_atan2(int nargs)\n{\n\tNODE *t1, *t2;\n\tdouble d1, d2;\n\n\tPOP_TWO_SCALARS(t1, t2);\n\tif (do_lint) {\n\t\tif ((fixtype(t1)->flags & NUMBER) == 0)\n\t\t\tlintwarn(_(\"atan2: received non-numeric first argument\"));\n\t\tif ((fixtype(t2)->flags & NUMBER) == 0)\n\t\t\tlintwarn(_(\"atan2: received non-numeric second argument\"));\n\t}\n\td1 = force_number(t1)->numbr;\n\td2 = force_number(t2)->numbr;\n\tDEREF(t1);\n\tDEREF(t2);\n\treturn make_number((AWKNUM) atan2(d1, d2));\n}",
      "lines": 19,
      "depth": 13,
      "decorators": [
        "NODE",
        "*\ndo_atan2(int nargs)",
        "*"
      ]
    },
    "do_sin": {
      "start_point": [
        2484,
        0
      ],
      "end_point": [
        2496,
        1
      ],
      "content": "NODE *\ndo_sin(int nargs)\n{\n\tNODE *tmp;\n\tdouble d;\n\n\ttmp = POP_SCALAR();\n\tif (do_lint && (fixtype(tmp)->flags & NUMBER) == 0)\n\t\tlintwarn(_(\"sin: received non-numeric argument\"));\n\td = sin((double) force_number(tmp)->numbr);\n\tDEREF(tmp);\n\treturn make_number((AWKNUM) d);\n}",
      "lines": 13,
      "depth": 12,
      "decorators": [
        "NODE",
        "*\ndo_sin(int nargs)",
        "*"
      ]
    },
    "do_cos": {
      "start_point": [
        2500,
        0
      ],
      "end_point": [
        2512,
        1
      ],
      "content": "NODE *\ndo_cos(int nargs)\n{\n\tNODE *tmp;\n\tdouble d;\n\n\ttmp = POP_SCALAR();\n\tif (do_lint && (fixtype(tmp)->flags & NUMBER) == 0)\n\t\tlintwarn(_(\"cos: received non-numeric argument\"));\n\td = cos((double) force_number(tmp)->numbr);\n\tDEREF(tmp);\n\treturn make_number((AWKNUM) d);\n}",
      "lines": 13,
      "depth": 12,
      "decorators": [
        "NODE",
        "*\ndo_cos(int nargs)",
        "*"
      ]
    },
    "do_rand": {
      "start_point": [
        2523,
        0
      ],
      "end_point": [
        2599,
        1
      ],
      "content": "NODE *\ndo_rand(int nargs ATTRIBUTE_UNUSED)\n{\n\tdouble tmprand;\n#define RAND_DIVISOR ((double)GAWK_RANDOM_MAX+1.0)\n\tif (firstrand) {\n\t\t(void) initstate((unsigned) 1, state, SIZEOF_STATE);\n\t\t/* don't need to srandom(1), initstate() does it for us. */\n\t\tfirstrand = false;\n\t\tsetstate(state);\n\t}\n\t/*\n\t * Per historical practice and POSIX, return value N is\n\t *\n\t * \t0 <= n < 1\n\t */\n \t/*\n\t * Date: Wed, 28 Aug 2013 17:52:46 -0700\n\t * From: Bob Jewett <jewett@bill.scs.agilent.com>\n\t *\n \t * Call random() twice to fill in more bits in the value\n \t * of the double.  Also, there is a bug in random() such\n \t * that when the values of successive values are combined\n \t * like (rand1*rand2)^2, (rand3*rand4)^2,  ...  the\n \t * resulting time series is not white noise.  The\n \t * following also seems to fix that bug.\n \t *\n \t * The add/subtract 0.5 keeps small bits from filling\n \t * below 2^-53 in the double, not that anyone should be\n \t * looking down there.\n\t *\n\t * Date: Wed, 25 Sep 2013 10:45:38 -0600 (MDT)\n\t * From: \"Nelson H. F. Beebe\" <beebe@math.utah.edu>\n\t * (4) The code is typical of many published fragments for converting\n\t *     from integer to floating-point, and I discuss the serious pitfalls\n\t *     in my book, because it leads to platform-dependent behavior at the\n\t *     end points of the interval [0,1]\n\t *\n\t * (5) the documentation in the gawk info node says\n\t *\n\t *     `rand()'\n\t * \t Return a random number.  The values of `rand()' are uniformly\n\t * \t distributed between zero and one.  The value could be zero but is\n\t * \t never one.(1)\n\t *\n\t *     The division by RAND_DIVISOR may not guarantee that 1.0 is never\n\t *     returned: the programmer forgot the platform-dependent issue of\n\t *     rounding.\n\t *\n\t * For points 4 and 5, the safe way is a loop:\n\t *\n\t *         double\n\t * \t   rand(void)\t\t// return value in [0.0, 1.0)\n\t *         {\n\t * \t    value = internal_rand();\n\t *\n\t * \t    while (value == 1.0)\n\t *                 value = internal_rand();\n\t *\n\t * \t    return (value);\n\t *         }\n \t */\n\n\tdo {\n\t\tlong d1, d2;\n\t\t/*\n\t\t * Do the calls in predictable order to avoid\n\t\t * compiler differences in order of evaluation.\n\t\t */\n\t\td1 = random();\n\t\td2 = random();\n\t \ttmprand = 0.5 + ( (d1/RAND_DIVISOR + d2) / RAND_DIVISOR );\n\t\ttmprand -= 0.5;\n\t} while (tmprand == 1.0);\n\n \treturn make_number((AWKNUM) tmprand);\n}",
      "lines": 77,
      "depth": 13,
      "decorators": [
        "NODE",
        "*\ndo_rand(int nargs ATTRIBUTE_UNUSED)",
        "*"
      ]
    },
    "do_srand": {
      "start_point": [
        2603,
        0
      ],
      "end_point": [
        2627,
        1
      ],
      "content": "NODE *\ndo_srand(int nargs)\n{\n\tNODE *tmp;\n\tstatic long save_seed = 1;\n\tlong ret = save_seed;\t/* SVR4 awk srand returns previous seed */\n\n\tif (firstrand) {\n\t\t(void) initstate((unsigned) 1, state, SIZEOF_STATE);\n\t\t/* don't need to srandom(1), we're changing the seed below */\n\t\tfirstrand = false;\n\t\t(void) setstate(state);\n\t}\n\n\tif (nargs == 0)\n\t\tsrandom((unsigned int) (save_seed = (long) time((time_t *) 0)));\n\telse {\n\t\ttmp = POP_SCALAR();\n\t\tif (do_lint && (fixtype(tmp)->flags & NUMBER) == 0)\n\t\t\tlintwarn(_(\"srand: received non-numeric argument\"));\n\t\tsrandom((unsigned int) (save_seed = (long) force_number(tmp)->numbr));\n\t\tDEREF(tmp);\n\t}\n\treturn make_number((AWKNUM) ret);\n}",
      "lines": 25,
      "depth": 16,
      "decorators": [
        "NODE",
        "*\ndo_srand(int nargs)",
        "*"
      ]
    },
    "do_match": {
      "start_point": [
        2634,
        0
      ],
      "end_point": [
        2766,
        1
      ],
      "content": "NODE *\ndo_match(int nargs)\n{\n\tNODE *tre, *t1, *dest, *it;\n\tint rstart, len, ii;\n\tint rlength;\n\tRegexp *rp;\n\tregoff_t s;\n\tchar *start;\n\tchar *buf = NULL;\n\tchar buff[100];\n\tsize_t amt, oldamt = 0, ilen, slen;\n\tchar *subsepstr;\n\tsize_t subseplen;\n\n\tdest = NULL;\n\tif (nargs == 3) {\t/* 3rd optional arg for the subpatterns */\n\t\tdest = POP_PARAM();\n\t\tif (dest->type != Node_var_array)\n\t\t\tfatal(_(\"match: third argument is not an array\"));\n\t\tassoc_clear(dest);\n\t}\n\ttre = POP();\n\trp = re_update(tre);\n\tt1 = POP_STRING();\n\n\trstart = research(rp, t1->stptr, 0, t1->stlen, RE_NEED_START);\n\tif (rstart >= 0) {\t/* match succeded */\n\t\tsize_t *wc_indices = NULL;\n\n\t\trlength = REEND(rp, t1->stptr) - RESTART(rp, t1->stptr);\t/* byte length */\n\t\tif (rlength > 0 && gawk_mb_cur_max > 1) {\n\t\t\tt1 = str2wstr(t1, & wc_indices);\n\t\t\trlength = wc_indices[rstart + rlength - 1] - wc_indices[rstart] + 1;\n\t\t\trstart = wc_indices[rstart];\n\t\t}\n\n\t\trstart++;\t/* now it's 1-based indexing */\n\n\t\t/* Build the array only if the caller wants the optional subpatterns */\n\t\tif (dest != NULL) {\n\t\t\tsubsepstr = SUBSEP_node->var_value->stptr;\n\t\t\tsubseplen = SUBSEP_node->var_value->stlen;\n\n\t\t\tfor (ii = 0; ii < NUMSUBPATS(rp, t1->stptr); ii++) {\n\t\t\t\t/*\n\t\t\t\t * Loop over all the subpats; some of them may have\n\t\t\t\t * matched even if all of them did not.\n\t\t\t\t */\n\t\t\t\tif ((s = SUBPATSTART(rp, t1->stptr, ii)) != -1) {\n\t\t\t\t\tsize_t subpat_start;\n\t\t\t\t\tsize_t subpat_len;\n\t\t\t\t\tNODE **lhs;\n\t\t\t\t\tNODE *sub;\n\n\t\t\t\t\tstart = t1->stptr + s;\n\t\t\t\t\tsubpat_start = s;\n\t\t\t\t\tsubpat_len = len = SUBPATEND(rp, t1->stptr, ii) - s;\n\t\t\t\t\tif (len > 0 && gawk_mb_cur_max > 1) {\n\t\t\t\t\t\tsubpat_start = wc_indices[s];\n\t\t\t\t\t\tsubpat_len = wc_indices[s + len - 1] - subpat_start + 1;\n\t\t\t\t\t}\n\n\t\t\t\t\tit = make_string(start, len);\n\t\t\t\t\tit->flags |= USER_INPUT;\n\n\t\t\t\t\tsub = make_number((AWKNUM) (ii));\n\t\t\t\t\tlhs = assoc_lookup(dest, sub);\n\t\t\t\t\tunref(*lhs);\n\t\t\t\t\t*lhs = it;\n\t\t\t\t\t/* execute post-assignment routine if any */\n\t\t\t\t\tif (dest->astore != NULL)\n\t\t\t\t\t\t(*dest->astore)(dest, sub);\n\t\t\t\t\tunref(sub);\n\n\t\t\t\t\tsprintf(buff, \"%d\", ii);\n\t\t\t\t\tilen = strlen(buff);\n\t\t\t\t\tamt = ilen + subseplen + strlen(\"length\") + 1;\n\n\t\t\t\t\tif (oldamt == 0) {\n\t\t\t\t\t\temalloc(buf, char *, amt, \"do_match\");\n\t\t\t\t\t} else if (amt > oldamt) {\n\t\t\t\t\t\terealloc(buf, char *, amt, \"do_match\");\n\t\t\t\t\t}\n\t\t\t\t\toldamt = amt;\n\t\t\t\t\tmemcpy(buf, buff, ilen);\n\t\t\t\t\tmemcpy(buf + ilen, subsepstr, subseplen);\n\t\t\t\t\tmemcpy(buf + ilen + subseplen, \"start\", 6);\n\n\t\t\t\t\tslen = ilen + subseplen + 5;\n\n\t\t\t\t\tit = make_number((AWKNUM) subpat_start + 1);\n\t\t\t\t\tsub = make_string(buf, slen);\n\t\t\t\t\tlhs = assoc_lookup(dest, sub);\n\t\t\t\t\tunref(*lhs);\n\t\t\t\t\t*lhs = it;\n\t\t\t\t\tif (dest->astore != NULL)\n\t\t\t\t\t\t(*dest->astore)(dest, sub);\n\t\t\t\t\tunref(sub);\n\n\t\t\t\t\tmemcpy(buf, buff, ilen);\n\t\t\t\t\tmemcpy(buf + ilen, subsepstr, subseplen);\n\t\t\t\t\tmemcpy(buf + ilen + subseplen, \"length\", 7);\n\n\t\t\t\t\tslen = ilen + subseplen + 6;\n\n\t\t\t\t\tit = make_number((AWKNUM) subpat_len);\n\t\t\t\t\tsub = make_string(buf, slen);\n\t\t\t\t\tlhs = assoc_lookup(dest, sub);\n\t\t\t\t\tunref(*lhs);\n\t\t\t\t\t*lhs = it;\n\t\t\t\t\tif (dest->astore != NULL)\n\t\t\t\t\t\t(*dest->astore)(dest, sub);\n\t\t\t\t\tunref(sub);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tefree(buf);\n\t\t}\n\t\tif (wc_indices != NULL)\n\t\t\tefree(wc_indices);\n\t} else {\t\t/* match failed */\n\t\trstart = 0;\n\t\trlength = -1;\n\t}\n\n\tDEREF(t1);\n\tunref(RSTART_node->var_value);\n\tRSTART_node->var_value = make_number((AWKNUM) rstart);\n\tunref(RLENGTH_node->var_value);\n\tRLENGTH_node->var_value = make_number((AWKNUM) rlength);\n\treturn make_number((AWKNUM) rstart);\n}",
      "lines": 133,
      "depth": 20,
      "decorators": [
        "NODE",
        "*\ndo_match(int nargs)",
        "*"
      ]
    },
    "do_sub": {
      "start_point": [
        2866,
        0
      ],
      "end_point": [
        3219,
        1
      ],
      "content": "NODE *\ndo_sub(int nargs, unsigned int flags)\n{\n\tchar *scan;\n\tchar *bp, *cp;\n\tchar *buf = NULL;\n\tsize_t buflen;\n\tchar *matchend;\n\tsize_t len;\n\tchar *matchstart;\n\tchar *text;\n\tsize_t textlen = 0;\n\tchar *repl;\n\tchar *replend;\n\tsize_t repllen;\n\tint sofar;\n\tint ampersands;\n\tint matches = 0;\n\tRegexp *rp;\n\tNODE *rep_node;\t\t/* replacement text */\n\tNODE *target;\t\t/* string to make sub. in; $0 if none given */\n\tNODE *tmp;\n\tNODE **lhs = NULL;\n\tlong how_many = 1;\t/* one substitution for sub, also gensub default */\n\tbool global;\n\tlong current;\n\tbool lastmatchnonzero;\n\tchar *mb_indices = NULL;\n\n\tif ((flags & GENSUB) != 0) {\n\t\tdouble d;\n\t\tNODE *glob_flag;\n\n\t\ttmp = PEEK(3);\n\t\trp = re_update(tmp);\n\n\t\ttarget = POP_STRING();\t/* original string */\n\n\t\tglob_flag = POP_SCALAR();\t/* value of global flag */\n\t\tif (   (glob_flag->flags & STRING) != 0\n\t\t    && glob_flag->stlen > 0\n\t\t    && (glob_flag->stptr[0] == 'g' || glob_flag->stptr[0] == 'G'))\n\t\t\thow_many = -1;\n\t\telse {\n\t\t\t(void) force_number(glob_flag);\n\t\t\td = get_number_d(glob_flag);\n\t\t\tif (d < 1)\n\t\t\t\thow_many = 1;\n\t\t\telse if (d < LONG_MAX)\n\t\t\t\thow_many = d;\n\t\t\telse\n\t\t\t\thow_many = LONG_MAX;\n\t\t\tif (d <= 0) {\n\t\t\t\t(void) force_string(glob_flag);\n\t\t\t\twarning(_(\"gensub: third argument `%.*s' treated as 1\"),\n\t\t\t\t\t\t(int) glob_flag->stlen,\n\t\t\t\t\t\tglob_flag->stptr);\n\t\t\t}\n\t\t}\n\t\tDEREF(glob_flag);\n\t} else {\n\t\t/* take care of regexp early, in case re_update is fatal */\n\n\t\ttmp = PEEK(2);\n\t\trp = re_update(tmp);\n\n\t\tif ((flags & GSUB) != 0)\n\t\t\thow_many = -1;\n\n\t\t/* original string */\n\n\t\tif ((flags & LITERAL) != 0)\n\t\t\ttarget = POP_STRING();\n\t\telse {\n\t\t\tlhs = POP_ADDRESS();\n\t\t\ttarget = force_string(*lhs);\n\t\t}\n\t}\n\n\tglobal = (how_many == -1);\n\n\trep_node = POP_STRING();\t/* replacement text */\n\tdecr_sp();\t\t/* regexp, already updated above */\n\n\t/* do the search early to avoid work on non-match */\n\tif (research(rp, target->stptr, 0, target->stlen, RE_NEED_START) == -1 ||\n\t\t\tRESTART(rp, target->stptr) > target->stlen)\n\t\tgoto done;\n\n\ttarget->flags |= STRING;\n\n\ttext = target->stptr;\n\ttextlen = target->stlen;\n\n\trepl = rep_node->stptr;\n\treplend = repl + rep_node->stlen;\n\trepllen = replend - repl;\n\n\tampersands = 0;\n\n\t/*\n\t * Some systems' malloc() can't handle being called with an\n\t * argument of zero.  Thus we have to have some special case\n\t * code to check for `repllen == 0'.  This can occur for\n\t * something like:\n\t * \tsub(/foo/, \"\", mystring)\n\t * for example.\n\t */\n\tif (gawk_mb_cur_max > 1 && repllen > 0) {\n\t\temalloc(mb_indices, char *, repllen * sizeof(char), \"do_sub\");\n\t\tindex_multibyte_buffer(repl, mb_indices, repllen);\n\t}\n\n\t/* compute length of replacement string, number of ampersands */\n\tfor (scan = repl; scan < replend; scan++) {\n\t\tif ((gawk_mb_cur_max == 1 || (repllen > 0 && mb_indices[scan - repl] == 1))\n\t\t    && (*scan == '&')) {\n\t\t\trepllen--;\n\t\t\tampersands++;\n\t\t} else if (*scan == '\\\\') {\n\t\t\tif ((flags & GENSUB) != 0) {\t/* gensub, behave sanely */\n\t\t\t\tif (isdigit((unsigned char) scan[1])) {\n\t\t\t\t\tampersands++;\n\t\t\t\t\tscan++;\n\t\t\t\t} else {\t/* \\q for any q --> q */\n\t\t\t\t\trepllen--;\n\t\t\t\t\tscan++;\n\t\t\t\t}\n\t\t\t} else if (do_posix) {\n\t\t\t\t/* \\& --> &, \\\\ --> \\ */\n\t\t\t\tif (scan[1] == '&' || scan[1] == '\\\\') {\n\t\t\t\t\trepllen--;\n\t\t\t\t\tscan++;\n\t\t\t\t} /* else\n\t\t\t\t\tleave alone, it goes into the output */\n\t\t\t} else {\n\t\t\t\t/* gawk default behavior since 1996 */\n\t\t\t\tif (strncmp(scan, \"\\\\\\\\\\\\&\", 4) == 0\n\t\t\t\t    || strncmp(scan, \"\\\\\\\\\\\\\\\\\", 4) == 0) {\t/* 2016: fixed */\n\t\t\t\t\t/* \\\\\\& --> \\& */\n\t\t\t\t\t/* \\\\\\\\ --> \\\\ */\n\t\t\t\t\trepllen -= 2;\n\t\t\t\t\tscan += 3;\n\t\t\t\t} else if (strncmp(scan, \"\\\\\\\\&\", 3) == 0) {\n\t\t\t\t\t/* \\\\& --> \\<string> */\n\t\t\t\t\tampersands++;\n\t\t\t\t\trepllen--;\n\t\t\t\t\tscan += 2;\n\t\t\t\t} else if (scan[1] == '&') {\n\t\t\t\t\t/* \\& --> & */\n\t\t\t\t\trepllen--;\n\t\t\t\t\tscan++;\n\t\t\t\t} /* else\n\t\t\t\t\tleave alone, it goes into the output */\n\t\t\t}\n\t\t}\n\t}\n\n\tlastmatchnonzero = false;\n\n\t/* guesstimate how much room to allocate; +1 forces > 0 */\n\tbuflen = textlen + (ampersands + 1) * repllen + 1;\n\temalloc(buf, char *, buflen + 1, \"do_sub\");\n\tbuf[buflen] = '\\0';\n\n\tbp = buf;\n\tfor (current = 1;; current++) {\n\t\tmatches++;\n\t\tmatchstart = target->stptr + RESTART(rp, target->stptr);\n\t\tmatchend = target->stptr + REEND(rp, target->stptr);\n\n\t\t/*\n\t\t * create the result, copying in parts of the original\n\t\t * string. note that length of replacement string can\n\t\t * vary since ampersand is actual text of regexp match.\n\t\t */\n\n\t\t/*\n\t\t * add 1 to len to handle \"empty\" case where\n\t\t * matchend == matchstart and we force a match on a single\n\t\t * char.  Use 'matchend - text' instead of 'matchstart - text'\n\t\t * because we may not actually make any substitution depending\n\t\t * on the 'global' and 'how_many' values.\n\t\t */\n\t\tlen = matchend - text + repllen\n\t\t      + ampersands * (matchend - matchstart) + 1;\n\t\tsofar = bp - buf;\n\t\twhile (buflen < (sofar + len + 1)) {\n\t\t\tbuflen *= 2;\n\t\t\terealloc(buf, char *, buflen, \"sub_common\");\n\t\t\tbp = buf + sofar;\n\t\t}\n\t\tfor (scan = text; scan < matchstart; scan++)\n\t\t\t*bp++ = *scan;\n\t\tif (global || current == how_many) {\n\t\t\t/*\n\t\t\t * If the current match matched the null string,\n\t\t\t * and the last match didn't and did a replacement,\n\t\t\t * and the match of the null string is at the front of\n\t\t\t * the text (meaning right after end of the previous\n\t\t\t * replacement), then skip this one.\n\t\t\t */\n\t\t\tif (matchstart == matchend\n\t\t\t    && lastmatchnonzero\n\t\t\t    && matchstart == text) {\n\t\t\t\tlastmatchnonzero = false;\n\t\t\t\tmatches--;\n\t\t\t\tgoto empty;\n\t\t\t}\n\t\t\t/*\n\t\t\t * If replacing all occurrences, or this is the\n\t\t\t * match we want, copy in the replacement text,\n\t\t\t * making substitutions as we go.\n\t\t\t */\n\t\t\tfor (scan = repl; scan < replend; scan++)\n\t\t\t\tif (*scan == '&'\n\t\t\t\t\t/*\n\t\t\t\t\t * Don't test repllen here. A simple \"&\" could\n\t\t\t\t\t * end up with repllen == 0.\n\t\t\t\t\t */\n\t\t\t\t\t&& (gawk_mb_cur_max == 1\n\t\t\t\t\t\t|| mb_indices[scan - repl] == 1)\n\t\t\t\t) {\n\t\t\t\t\t\tfor (cp = matchstart; cp < matchend; cp++)\n\t\t\t\t\t\t\t\t*bp++ = *cp;\n\t\t\t\t} else if (*scan == '\\\\'\n\t\t\t\t\t&& (gawk_mb_cur_max == 1\n\t\t\t\t\t\t|| (repllen > 0 && mb_indices[scan - repl] == 1))\n\t\t\t\t) {\n\t\t\t\t\tif (flags & GENSUB) {\t/* gensub, behave sanely */\n\t\t\t\t\t\tif (isdigit((unsigned char) scan[1])) {\n\t\t\t\t\t\t\tint dig = scan[1] - '0';\n\t\t\t\t\t\t\tif (dig < NUMSUBPATS(rp, target->stptr) && SUBPATSTART(rp, tp->stptr, dig) != -1) {\n\t\t\t\t\t\t\t\tchar *start, *end;\n\n\t\t\t\t\t\t\t\tstart = target->stptr\n\t\t\t\t\t\t\t\t      + SUBPATSTART(rp, target->stptr, dig);\n\t\t\t\t\t\t\t\tend = target->stptr\n\t\t\t\t\t\t\t\t      + SUBPATEND(rp, target->stptr, dig);\n\n\t\t\t\t\t\t\t\tfor (cp = start; cp < end; cp++)\n\t\t\t\t\t\t\t\t\t*bp++ = *cp;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tscan++;\n\t\t\t\t\t\t} else\t/* \\q for any q --> q */\n\t\t\t\t\t\t\t*bp++ = *++scan;\n\t\t\t\t\t} else if (do_posix) {\n\t\t\t\t\t\t/* \\& --> &, \\\\ --> \\ */\n\t\t\t\t\t\tif (scan[1] == '&' || scan[1] == '\\\\')\n\t\t\t\t\t\t\tscan++;\n\t\t\t\t\t\t*bp++ = *scan;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* gawk default behavior since 1996 */\n\t\t\t\t\t\tif (strncmp(scan, \"\\\\\\\\\\\\&\", 4) == 0\n\t\t\t\t\t\t    || strncmp(scan, \"\\\\\\\\\\\\\\\\\", 4) == 0) {\t/* 2016: fixed */\n\t\t\t\t\t\t\t/* \\\\\\& --> \\& */\n\t\t\t\t\t\t\t/* \\\\\\\\ --> \\\\ */\n\t\t\t\t\t\t\t*bp++ = '\\\\';\n\t\t\t\t\t\t\t*bp++ = scan[3];\n\t\t\t\t\t\t\tscan += 3;\n\t\t\t\t\t\t} else if (strncmp(scan, \"\\\\\\\\&\", 3) == 0) {\n\t\t\t\t\t\t\t/* \\\\& --> \\<string> */\n\t\t\t\t\t\t\t*bp++ = '\\\\';\n\t\t\t\t\t\t\tfor (cp = matchstart; cp < matchend; cp++)\n\t\t\t\t\t\t\t\t*bp++ = *cp;\n\t\t\t\t\t\t\tscan += 2;\n\t\t\t\t\t\t} else if (scan[1] == '&') {\n\t\t\t\t\t\t\t/* \\& --> & */\n\t\t\t\t\t\t\t*bp++ = '&';\n\t\t\t\t\t\t\tscan++;\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t*bp++ = *scan;\n\t\t\t\t\t}\n\t\t\t\t} else\n\t\t\t\t\t*bp++ = *scan;\n\t\t\tif (matchstart != matchend)\n\t\t\t\tlastmatchnonzero = true;\n\t\t} else {\n\t\t\t/*\n\t\t\t * don't want this match, skip over it by copying\n\t\t\t * in current text.\n\t\t\t */\n\t\t\tfor (cp = matchstart; cp < matchend; cp++)\n\t\t\t\t*bp++ = *cp;\n\t\t}\n\tempty:\n\t\t/* catch the case of gsub(//, \"blah\", whatever), i.e. empty regexp */\n\t\tif (matchstart == matchend && matchend < text + textlen) {\n\t\t\t*bp++ = *matchend;\n\t\t\tmatchend++;\n\t\t}\n\t\ttextlen = text + textlen - matchend;\n\t\ttext = matchend;\n\n#if 0\n\t\tif (bp - buf > sofar + len)\n\t\t\tfprintf(stderr, \"debug: len = %zu, but used %ld\\n\", len, (long)((bp - buf) - (long)sofar));\n#endif\n\n\t\tif ((current >= how_many && ! global)\n\t\t    || ((long) textlen <= 0 && matchstart == matchend)\n\t\t    || research(rp, target->stptr, text - target->stptr, textlen, RE_NEED_START) == -1)\n\t\t\tbreak;\n\n\t}\n\tsofar = bp - buf;\n\tif (buflen < (sofar + textlen + 1)) {\n\t\tbuflen = sofar + textlen + 1;\n\t\terealloc(buf, char *, buflen, \"do_sub\");\n\t\tbp = buf + sofar;\n\t}\n\t/*\n\t * Note that text == matchend, since that assignment is made before\n\t * exiting the 'for' loop above. Thus we copy in the rest of the\n\t * original string.\n\t */\n\tfor (scan = text; scan < text + textlen; scan++)\n\t\t*bp++ = *scan;\n\t*bp = '\\0';\n\ttextlen = bp - buf;\n\n\tif (mb_indices != NULL)\n\t\tefree(mb_indices);\n\ndone:\n\tDEREF(rep_node);\n\n\tif ((matches == 0 || (flags & LITERAL) != 0) && buf != NULL) {\n\t\tefree(buf);\n\t\tbuf = NULL;\n\t}\n\n\tif (flags & GENSUB) {\n\t\tif (matches > 0) {\n\t\t\t/* return the result string */\n\t\t\tDEREF(target);\n\t\t\tassert(buf != NULL);\n\t\t\treturn make_str_node(buf, textlen, ALREADY_MALLOCED);\n\t\t}\n\n\t\t/* return the original string */\n\t\treturn target;\n\t}\n\n\t/* For a string literal, must not change the original string. */\n\tif ((flags & LITERAL) != 0)\n\t\tDEREF(target);\n\telse if (matches > 0) {\n\t\tunref(*lhs);\n\t\t*lhs = make_str_node(buf, textlen, ALREADY_MALLOCED);\n\t}\n\n\treturn make_number((AWKNUM) matches);\n}",
      "lines": 354,
      "depth": 23,
      "decorators": [
        "NODE",
        "*\ndo_sub(int nargs, unsigned int flags)",
        "*"
      ]
    },
    "call_sub": {
      "start_point": [
        3223,
        0
      ],
      "end_point": [
        3301,
        1
      ],
      "content": "NODE *\ncall_sub(const char *name, int nargs)\n{\n\tunsigned int flags = 0;\n\tNODE *regex, *replace, *glob_flag;\n\tNODE **lhs, *rhs;\n\tNODE *zero = make_number(0.0);\n\tNODE *result;\n\n\tif (name[0] == 'g') {\n\t\tif (name[1] == 'e')\n\t\t\tflags = GENSUB;\n\t\telse\n\t\t\tflags = GSUB;\n\t}\n\n\tif (flags == 0 || flags == GSUB) {\n\t\t/* sub or gsub */\n\t\tif (nargs != 2)\n\t\t\tfatal(_(\"%s: can be called indirectly only with two arguments\"), name);\n\n\t\treplace = POP_STRING();\n\t\tregex = POP();\t/* the regex */\n\t\t/*\n\t\t * push regex\n\t\t * push replace\n\t\t * push $0\n\t\t */\n\t\tif ((regex->flags & REGEX) != 0)\n\t\t\tregex = regex->typed_re;\n\t\telse\n\t\t\tregex = make_regnode(Node_regex, regex);\n\t\tPUSH(regex);\n\t\tPUSH(replace);\n\t\tlhs = r_get_field(zero, (Func_ptr *) 0, true);\n\t\tnargs++;\n\t\tPUSH_ADDRESS(lhs);\n\t} else {\n\t\t/* gensub */\n\t\tif (nargs == 4)\n\t\t\trhs = POP();\n\t\telse\n\t\t\trhs = NULL;\n\t\tglob_flag = POP_STRING();\n\t\treplace = POP_STRING();\n\t\tregex = POP();\t/* the regex */\n\t\t/*\n\t\t * push regex\n\t\t * push replace\n\t\t * push glob_flag\n\t\t * if (nargs = 3) {\n\t\t *\t push $0\n\t\t *\t nargs++\n\t\t * }\n\t\t */\n\t\tif ((regex->flags & REGEX) != 0)\n\t\t\tregex = regex->typed_re;\n\t\telse\n\t\t\tregex = make_regnode(Node_regex, regex);\n\t\tPUSH(regex);\n\t\tPUSH(replace);\n\t\tPUSH(glob_flag);\n\t\tif (rhs == NULL) {\n\t\t\tlhs = r_get_field(zero, (Func_ptr *) 0, true);\n\t\t\trhs = *lhs;\n\t\t\tUPREF(rhs);\n\t\t\tPUSH(rhs);\n\t\t\tnargs++;\n\t\t}\n\t\telse\n\t\t\tPUSH(rhs);\n\t}\n\n\tunref(zero);\n\tresult = do_sub(nargs, flags);\n\tif (flags != GENSUB)\n\t\treset_record();\n\treturn result;\n}",
      "lines": 79,
      "depth": 14,
      "decorators": [
        "NODE",
        "*\ncall_sub(const char *name, int nargs)",
        "*"
      ]
    },
    "call_match": {
      "start_point": [
        3305,
        0
      ],
      "end_point": [
        3330,
        1
      ],
      "content": "NODE *\ncall_match(int nargs)\n{\n\tNODE *regex, *text, *array;\n\tNODE *result;\n\n\tregex = text = array = NULL;\n\tif (nargs == 3)\n\t\tarray = POP();\n\tregex = POP();\n\n\t/* Don't need to pop the string just to push it back ... */\n\n\tif ((regex->flags & REGEX) != 0)\n\t\tregex = regex->typed_re;\n\telse\n\t\tregex = make_regnode(Node_regex, regex);\n\n\tPUSH(regex);\n\n\tif (array)\n\t\tPUSH(array);\n\n\tresult = do_match(nargs);\n\treturn result;\n}",
      "lines": 26,
      "depth": 9,
      "decorators": [
        "NODE",
        "*\ncall_match(int nargs)",
        "*"
      ]
    },
    "call_split_func": {
      "start_point": [
        3334,
        0
      ],
      "end_point": [
        3373,
        1
      ],
      "content": "NODE *\ncall_split_func(const char *name, int nargs)\n{\n\tNODE *regex, *seps;\n\tNODE *result;\n\n\tregex = seps = NULL;\n\tif (nargs < 2)\n\t\tfatal(_(\"indirect call to %s requires at least two arguments\"),\n\t\t\t\tname);\n\n\tif (nargs == 4)\n\t\tseps = POP();\n\n\tif (nargs >= 3) {\n\t\tregex = POP_STRING();\n\t\tif ((regex->flags & REGEX) != 0)\n\t\t\tregex = regex->typed_re;\n\t\telse\n\t\t\tregex = make_regnode(Node_regex, regex);\n\t} else {\n\t\tif (name[0] == 's') {\n\t\t\tregex = make_regnode(Node_regex, FS_node->var_value);\n\t\t\tregex->re_flags |= FS_DFLT;\n\t\t} else\n\t\t\tregex = make_regnode(Node_regex, FPAT_node->var_value);\n\t\tnargs++;\n\t}\n\n\t/* Don't need to pop the string or the data array */\n\n\tPUSH(regex);\n\n\tif (seps)\n\t\tPUSH(seps);\n\n\tresult = (name[0] == 's') ? do_split(nargs) : do_patsplit(nargs);\n\n\treturn result;\n}",
      "lines": 40,
      "depth": 12,
      "decorators": [
        "NODE",
        "*\ncall_split_func(const char *name, int nargs)",
        "*"
      ]
    },
    "make_integer": {
      "start_point": [
        3377,
        0
      ],
      "end_point": [
        3383,
        1
      ],
      "content": "static NODE *\nmake_integer(uintmax_t n)\n{\n\tn = adjust_uint(n);\n\n\treturn make_number((AWKNUM) n);\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "NODE",
        "*\nmake_integer(uintmax_t n)",
        "*"
      ]
    },
    "do_lshift": {
      "start_point": [
        3387,
        0
      ],
      "end_point": [
        3422,
        1
      ],
      "content": "NODE *\ndo_lshift(int nargs)\n{\n\tNODE *s1, *s2;\n\tuintmax_t uval, ushift, res;\n\tAWKNUM val, shift;\n\n\tPOP_TWO_SCALARS(s1, s2);\n\tif (do_lint) {\n\t\tif ((fixtype(s1)->flags & NUMBER) == 0)\n\t\t\tlintwarn(_(\"lshift: received non-numeric first argument\"));\n\t\tif ((fixtype(s2)->flags & NUMBER) == 0)\n\t\t\tlintwarn(_(\"lshift: received non-numeric second argument\"));\n\t}\n\n\tval = force_number(s1)->numbr;\n\tshift = force_number(s2)->numbr;\n\tif (val < 0 || shift < 0)\n\t\tfatal(_(\"lshift(%f, %f): negative values are not allowed\"), val, shift);\n\n\tif (do_lint) {\n\t\tif (double_to_int(val) != val || double_to_int(shift) != shift)\n\t\t\tlintwarn(_(\"lshift(%f, %f): fractional values will be truncated\"), val, shift);\n\t\tif (shift >= sizeof(uintmax_t) * CHAR_BIT)\n\t\t\tlintwarn(_(\"lshift(%f, %f): too large shift value will give strange results\"), val, shift);\n\t}\n\n\tDEREF(s1);\n\tDEREF(s2);\n\n\tuval = (uintmax_t) val;\n\tushift = (uintmax_t) shift;\n\n\tres = uval << ushift;\n\treturn make_integer(res);\n}",
      "lines": 36,
      "depth": 13,
      "decorators": [
        "NODE",
        "*\ndo_lshift(int nargs)",
        "*"
      ]
    },
    "do_rshift": {
      "start_point": [
        3426,
        0
      ],
      "end_point": [
        3461,
        1
      ],
      "content": "NODE *\ndo_rshift(int nargs)\n{\n\tNODE *s1, *s2;\n\tuintmax_t uval, ushift, res;\n\tAWKNUM val, shift;\n\n\tPOP_TWO_SCALARS(s1, s2);\n\tif (do_lint) {\n\t\tif ((fixtype(s1)->flags & NUMBER) == 0)\n\t\t\tlintwarn(_(\"rshift: received non-numeric first argument\"));\n\t\tif ((fixtype(s2)->flags & NUMBER) == 0)\n\t\t\tlintwarn(_(\"rshift: received non-numeric second argument\"));\n\t}\n\n\tval = force_number(s1)->numbr;\n\tshift = force_number(s2)->numbr;\n\tif (val < 0 || shift < 0)\n\t\tfatal(_(\"rshift(%f, %f): negative values are not allowed\"), val, shift);\n\n\tif (do_lint) {\n\t\tif (double_to_int(val) != val || double_to_int(shift) != shift)\n\t\t\tlintwarn(_(\"rshift(%f, %f): fractional values will be truncated\"), val, shift);\n\t\tif (shift >= sizeof(uintmax_t) * CHAR_BIT)\n\t\t\tlintwarn(_(\"rshift(%f, %f): too large shift value will give strange results\"), val, shift);\n\t}\n\n\tDEREF(s1);\n\tDEREF(s2);\n\n\tuval = (uintmax_t) val;\n\tushift = (uintmax_t) shift;\n\n\tres = uval >> ushift;\n\treturn make_integer(res);\n}",
      "lines": 36,
      "depth": 13,
      "decorators": [
        "NODE",
        "*\ndo_rshift(int nargs)",
        "*"
      ]
    },
    "do_and": {
      "start_point": [
        3465,
        0
      ],
      "end_point": [
        3493,
        1
      ],
      "content": "NODE *\ndo_and(int nargs)\n{\n\tNODE *s1;\n\tuintmax_t res, uval;\n\tAWKNUM val;\n\tint i;\n\n\tres = ~0;\t/* start off with all ones */\n\tif (nargs < 2)\n\t\tfatal(_(\"and: called with less than two arguments\"));\n\n\tfor (i = 1; nargs > 0; nargs--, i++) {\n\t\ts1 = POP_SCALAR();\n\t\tif (do_lint && (fixtype(s1)->flags & NUMBER) == 0)\n\t\t\tlintwarn(_(\"and: argument %d is non-numeric\"), i);\n\n\t\tval = force_number(s1)->numbr;\n\t\tif (val < 0)\n\t\t\tfatal(_(\"and: argument %d negative value %g is not allowed\"), i, val);\n\n\t\tuval = (uintmax_t) val;\n\t\tres &= uval;\n\n\t\tDEREF(s1);\n\t}\n\n\treturn make_integer(res);\n}",
      "lines": 29,
      "depth": 14,
      "decorators": [
        "NODE",
        "*\ndo_and(int nargs)",
        "*"
      ]
    },
    "do_or": {
      "start_point": [
        3497,
        0
      ],
      "end_point": [
        3525,
        1
      ],
      "content": "NODE *\ndo_or(int nargs)\n{\n\tNODE *s1;\n\tuintmax_t res, uval;\n\tAWKNUM val;\n\tint i;\n\n\tres = 0;\n\tif (nargs < 2)\n\t\tfatal(_(\"or: called with less than two arguments\"));\n\n\tfor (i = 1; nargs > 0; nargs--, i++) {\n\t\ts1 = POP_SCALAR();\n\t\tif (do_lint && (fixtype(s1)->flags & NUMBER) == 0)\n\t\t\tlintwarn(_(\"or: argument %d is non-numeric\"), i);\n\n\t\tval = force_number(s1)->numbr;\n\t\tif (val < 0)\n\t\t\tfatal(_(\"or: argument %d negative value %g is not allowed\"), i, val);\n\n\t\tuval = (uintmax_t) val;\n\t\tres |= uval;\n\n\t\tDEREF(s1);\n\t}\n\n\treturn make_integer(res);\n}",
      "lines": 29,
      "depth": 14,
      "decorators": [
        "NODE",
        "*\ndo_or(int nargs)",
        "*"
      ]
    },
    "do_xor": {
      "start_point": [
        3529,
        0
      ],
      "end_point": [
        3560,
        1
      ],
      "content": "NODE *\ndo_xor(int nargs)\n{\n\tNODE *s1;\n\tuintmax_t res, uval;\n\tAWKNUM val;\n\tint i;\n\n\tif (nargs < 2)\n\t\tfatal(_(\"xor: called with less than two arguments\"));\n\n\tres = 0;\t/* silence compiler warning */\n\tfor (i = 1; nargs > 0; nargs--, i++) {\n\t\ts1 = POP_SCALAR();\n\t\tif (do_lint && (fixtype(s1)->flags & NUMBER) == 0)\n\t\t\tlintwarn(_(\"xor: argument %d is non-numeric\"), i);\n\n\t\tval = force_number(s1)->numbr;\n\t\tif (val < 0)\n\t\t\tfatal(_(\"xor: argument %d negative value %g is not allowed\"), i, val);\n\n\t\tuval = (uintmax_t) val;\n\t\tif (i == 1)\n\t\t\tres = uval;\n\t\telse\n\t\t\tres ^= uval;\n\n\t\tDEREF(s1);\n\t}\n\n\treturn make_integer(res);\n}",
      "lines": 32,
      "depth": 14,
      "decorators": [
        "NODE",
        "*\ndo_xor(int nargs)",
        "*"
      ]
    },
    "do_compl": {
      "start_point": [
        3564,
        0
      ],
      "end_point": [
        3586,
        1
      ],
      "content": "NODE *\ndo_compl(int nargs)\n{\n\tNODE *tmp;\n\tdouble d;\n\tuintmax_t uval;\n\n\ttmp = POP_SCALAR();\n\tif (do_lint && (fixtype(tmp)->flags & NUMBER) == 0)\n\t\tlintwarn(_(\"compl: received non-numeric argument\"));\n\td = force_number(tmp)->numbr;\n\tDEREF(tmp);\n\n\tif (d < 0)\n\t\tfatal(_(\"compl(%f): negative value is not allowed\"), d);\n\n\tif (do_lint && double_to_int(d) != d)\n\t\tlintwarn(_(\"compl(%f): fractional value will be truncated\"), d);\n\n\tuval = (uintmax_t) d;\n\tuval = ~ uval;\n\treturn make_integer(uval);\n}",
      "lines": 23,
      "depth": 12,
      "decorators": [
        "NODE",
        "*\ndo_compl(int nargs)",
        "*"
      ]
    },
    "do_strtonum": {
      "start_point": [
        3590,
        0
      ],
      "end_point": [
        3606,
        1
      ],
      "content": "NODE *\ndo_strtonum(int nargs)\n{\n\tNODE *tmp;\n\tAWKNUM d;\n\n\ttmp = fixtype(POP_SCALAR());\n\tif ((tmp->flags & NUMBER) != 0)\n\t\td = (AWKNUM) tmp->numbr;\n\telse if (get_numbase(tmp->stptr, tmp->stlen, use_lc_numeric) != 10)\n\t\td = nondec2awknum(tmp->stptr, tmp->stlen, NULL);\n\telse\n\t\td = (AWKNUM) force_number(tmp)->numbr;\n\n\tDEREF(tmp);\n\treturn make_number((AWKNUM) d);\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "NODE",
        "*\ndo_strtonum(int nargs)",
        "*"
      ]
    },
    "nondec2awknum": {
      "start_point": [
        3616,
        0
      ],
      "end_point": [
        3699,
        1
      ],
      "content": "AWKNUM\nnondec2awknum(char *str, size_t len, char **endptr)\n{\n\tAWKNUM retval = 0.0;\n\tchar save;\n\tshort val;\n\tchar *start = str;\n\n\tif (len >= 2 && *str == '0' && (str[1] == 'x' || str[1] == 'X')) {\n\t\t/*\n\t\t * User called strtonum(\"0x\") or some such,\n\t\t * so just quit early.\n\t\t */\n\t\tif (len <= 2) {\n\t\t\tif (endptr)\n\t\t\t\t*endptr = start;\n\t\t\treturn (AWKNUM) 0.0;\n\t\t}\n\n\t\tfor (str += 2, len -= 2; len > 0; len--, str++) {\n\t\t\tswitch (*str) {\n\t\t\tcase '0':\n\t\t\tcase '1':\n\t\t\tcase '2':\n\t\t\tcase '3':\n\t\t\tcase '4':\n\t\t\tcase '5':\n\t\t\tcase '6':\n\t\t\tcase '7':\n\t\t\tcase '8':\n\t\t\tcase '9':\n\t\t\t\tval = *str - '0';\n\t\t\t\tbreak;\n\t\t\tcase 'a':\n\t\t\tcase 'b':\n\t\t\tcase 'c':\n\t\t\tcase 'd':\n\t\t\tcase 'e':\n\t\t\tcase 'f':\n\t\t\t\tval = *str - 'a' + 10;\n\t\t\t\tbreak;\n\t\t\tcase 'A':\n\t\t\tcase 'B':\n\t\t\tcase 'C':\n\t\t\tcase 'D':\n\t\t\tcase 'E':\n\t\t\tcase 'F':\n\t\t\t\tval = *str - 'A' + 10;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (endptr)\n\t\t\t\t\t*endptr = str;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tretval = (retval * 16) + val;\n\t\t}\n\t\tif (endptr)\n\t\t\t*endptr = str;\n\t} else if (len >= 1 && *str == '0') {\n\t\tfor (; len > 0; len--) {\n\t\t\tif (! isdigit((unsigned char) *str)) {\n\t\t\t\tif (endptr)\n\t\t\t\t\t*endptr = str;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\telse if (*str == '8' || *str == '9') {\n\t\t\t\tstr = start;\n\t\t\t\tgoto decimal;\n\t\t\t}\n\t\t\tretval = (retval * 8) + (*str - '0');\n\t\t\tstr++;\n\t\t}\n\t\tif (endptr)\n\t\t\t*endptr = str;\n\t} else {\ndecimal:\n\t\tsave = str[len];\n\t\tstr[len] = '\\0';\n\t\tretval = strtod(str, endptr);\n\t\tstr[len] = save;\n\t}\ndone:\n\treturn retval;\n}",
      "lines": 84,
      "depth": 16,
      "decorators": [
        "AWKNUM"
      ]
    },
    "localecategory_from_argument": {
      "start_point": [
        3705,
        0
      ],
      "end_point": [
        3770,
        1
      ],
      "content": "static int\nlocalecategory_from_argument(NODE *t)\n{\n\tstatic const struct category_table {\n\t\tint val;\n\t\tconst char *name;\n\t} cat_tab[] = {\n#ifdef LC_ALL\n\t\t{ LC_ALL,\t\"LC_ALL\" },\n#endif /* LC_ALL */\n#ifdef LC_COLLATE\n\t\t{ LC_COLLATE,\t\"LC_COLLATE\" },\n#endif /* LC_COLLATE */\n#ifdef LC_CTYPE\n\t\t{ LC_CTYPE,\t\"LC_CTYPE\" },\n#endif /* LC_CTYPE */\n#ifdef LC_MESSAGES\n\t\t{ LC_MESSAGES,\t\"LC_MESSAGES\" },\n#endif /* LC_MESSAGES */\n#ifdef LC_MONETARY\n\t\t{ LC_MONETARY,\t\"LC_MONETARY\" },\n#endif /* LC_MONETARY */\n#ifdef LC_NUMERIC\n\t\t{ LC_NUMERIC,\t\"LC_NUMERIC\" },\n#endif /* LC_NUMERIC */\n#ifdef LC_RESPONSE\n\t\t{ LC_RESPONSE,\t\"LC_RESPONSE\" },\n#endif /* LC_RESPONSE */\n#ifdef LC_TIME\n\t\t{ LC_TIME,\t\"LC_TIME\" },\n#endif /* LC_TIME */\n\t};\n\n\tif (t != NULL) {\n\t\tint low, high, i, mid;\n\t\tchar *category;\n\t\tint lc_cat = -1;\n\n\t\tchar save = t->stptr[t->stlen];\n\t\tt->stptr[t->stlen] = '\\0';\n\t\tcategory = t->stptr;\n\n\t\t/* binary search the table */\n\t\tlow = 0;\n\t\thigh = (sizeof(cat_tab) / sizeof(cat_tab[0])) - 1;\n\t\twhile (low <= high) {\n\t\t\tmid = (low + high) / 2;\n\t\t\ti = strcmp(category, cat_tab[mid].name);\n\n\t\t\tif (i < 0)\t\t/* category < mid */\n\t\t\t\thigh = mid - 1;\n\t\t\telse if (i > 0)\t\t/* category > mid */\n\t\t\t\tlow = mid + 1;\n\t\t\telse {\n\t\t\t\tlc_cat = cat_tab[mid].val;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tt->stptr[t->stlen] = save;\n\t\tif (lc_cat == -1)\t/* not there */\n\t\t\tfatal(_(\"dcgettext: `%s' is not a valid locale category\"), category);\n\n\t\treturn lc_cat;\n\t} else\n\t\treturn LC_MESSAGES;\n}",
      "lines": 66,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "do_dcgettext": {
      "start_point": [
        3783,
        0
      ],
      "end_point": [
        3837,
        1
      ],
      "content": "NODE *\ndo_dcgettext(int nargs)\n{\n\tNODE *tmp, *t1, *t2 = NULL;\n\tchar *string;\n\tchar *the_result;\n\tsize_t reslen;\n#if ENABLE_NLS && defined(LC_MESSAGES) && HAVE_DCGETTEXT\n\tint lc_cat;\n\tchar *domain;\n\tchar save1 = '\\0', save2 = '\\0';\n\n\tif (nargs == 3) {\t/* third argument */\n\t\ttmp = POP_STRING();\n\t\tlc_cat = localecategory_from_argument(tmp);\n\t\tDEREF(tmp);\n\t} else\n\t\tlc_cat = LC_MESSAGES;\n\n\tif (nargs >= 2) {  /* second argument */\n\t\tt2 = POP_STRING();\n\t\tdomain = t2->stptr;\n\t\tstr_terminate(t2, save2);\n\t} else\n\t\tdomain = TEXTDOMAIN;\n#else\n\tif (nargs == 3) {\n\t\ttmp = POP_STRING();\n\t\tDEREF(tmp);\n\t}\n\tif (nargs >= 2) {\n\t\tt2 = POP_STRING();\n\t\tDEREF(t2);\n\t}\n#endif\n\n\tt1 = POP_STRING();\t/* first argument */\n\tstring = t1->stptr;\n\n#if ENABLE_NLS && defined(LC_MESSAGES) && HAVE_DCGETTEXT\n\tstr_terminate(t1, save1);\n\tthe_result = dcgettext(domain, string, lc_cat);\n\tstr_restore(t1, save1);\n\tif (t2 != NULL) {\n\t\tstr_restore(t2, save2);\n\t\tDEREF(t2);\n\t}\n\treslen = strlen(the_result);\n#else\n\tthe_result = string;\n\treslen = t1->stlen;\n#endif\n\tDEREF(t1);\n\treturn make_string(the_result, reslen);\n}",
      "lines": 55,
      "depth": 11,
      "decorators": [
        "NODE",
        "*\ndo_dcgettext(int nargs)",
        "*"
      ]
    },
    "do_dcngettext": {
      "start_point": [
        3840,
        0
      ],
      "end_point": [
        3917,
        1
      ],
      "content": "NODE *\ndo_dcngettext(int nargs)\n{\n\tNODE *tmp, *t1, *t2, *t3;\n\tchar *string1, *string2;\n\tunsigned long number;\n\tAWKNUM d;\n\tchar *the_result;\n\tsize_t reslen;\n\n#if ENABLE_NLS && defined(LC_MESSAGES) && HAVE_DCGETTEXT\n\tint lc_cat;\n\tchar *domain;\n\tchar save = '\\0', save1 = '\\0', save2 = '\\0';\n\tbool saved_end = false;\n\n\tif (nargs == 5) {\t/* fifth argument */\n\t\ttmp = POP_STRING();\n\t\tlc_cat = localecategory_from_argument(tmp);\n\t\tDEREF(tmp);\n\t} else\n\t\tlc_cat = LC_MESSAGES;\n\n\tt3 = NULL;\n\tif (nargs >= 4) {\t/* fourth argument */\n\t\tt3 = POP_STRING();\n\t\tdomain = t3->stptr;\n\t\tsave = domain[t3->stlen];\n\t\tdomain[t3->stlen] = '\\0';\n\t\tsaved_end = true;\n\t} else\n\t\tdomain = TEXTDOMAIN;\n#else\n\tif (nargs == 5) {\n\t\ttmp = POP_STRING();\n\t\tDEREF(tmp);\n\t}\n\tif (nargs >= 4) {\n\t\tt3 = POP_STRING();\n\t\tDEREF(t3);\n\t}\n#endif\n\n\tt2 = POP_NUMBER();\t/* third argument */\n\td = get_number_d(t2);\n\tDEREF(t2);\n\n\tnumber = (unsigned long) double_to_int(d);\n\tt2 = POP_STRING();\t/* second argument */\n\tstring2 = t2->stptr;\n\tt1 = POP_STRING();\t/* first argument */\n\tstring1 = t1->stptr;\n\n#if ENABLE_NLS && defined(LC_MESSAGES) && HAVE_DCGETTEXT\n\n\tstr_terminate(t1, save1);\n\tstr_terminate(t2, save2);\n\tthe_result = dcngettext(domain, string1, string2, number, lc_cat);\n\treslen = strlen(the_result);\n\tstr_restore(t1, save1);\n\tstr_restore(t2, save2);\n\tif (saved_end)\n\t\tdomain[t3->stlen] = save;\n\tif (t3 != NULL)\n\t\tDEREF(t3);\n#else\n\tif (number == 1) {\n\t\tthe_result = string1;\n\t\treslen = t1->stlen;\n\t} else {\n\t\tthe_result = string2;\n\t\treslen = t2->stlen;\n\t}\n#endif\n\tDEREF(t1);\n\tDEREF(t2);\n\treturn make_string(the_result, reslen);\n}",
      "lines": 78,
      "depth": 11,
      "decorators": [
        "NODE",
        "*\ndo_dcngettext(int nargs)",
        "*"
      ]
    },
    "do_bindtextdomain": {
      "start_point": [
        3930,
        0
      ],
      "end_point": [
        3968,
        1
      ],
      "content": "NODE *\ndo_bindtextdomain(int nargs)\n{\n\tNODE *t1, *t2;\n\tconst char *directory, *domain;\n\tconst char *the_result;\n\n\tt1 = t2 = NULL;\n\t/* set defaults */\n\tdirectory = NULL;\n\tdomain = TEXTDOMAIN;\n\tchar save = '\\0', save1 = '\\0';\n\n\tif (nargs == 2) {\t/* second argument */\n\t\tt2 = POP_STRING();\n\t\tdomain = (const char *) t2->stptr;\n\t\tsave = t2->stptr[t2->stlen];\n\t\tt2->stptr[t2->stlen] = '\\0';\n\t}\n\n\t/* first argument */\n\tt1 = POP_STRING();\n\tif (t1->stlen > 0) {\n\t\tdirectory = (const char *) t1->stptr;\n\t\tstr_terminate(t1, save1);\n\t}\n\n\tthe_result = bindtextdomain(domain, directory);\n\tif (directory)\n\t\tstr_restore(t1, save1);\n\n\tDEREF(t1);\n\tif (t2 != NULL) {\n\t\tt2->stptr[t2->stlen] = save;\n\t\tDEREF(t2);\n\t}\n\n\treturn make_string(the_result, strlen(the_result));\n}",
      "lines": 39,
      "depth": 10,
      "decorators": [
        "NODE",
        "*\ndo_bindtextdomain(int nargs)",
        "*"
      ]
    },
    "do_intdiv": {
      "start_point": [
        3981,
        0
      ],
      "end_point": [
        4038,
        1
      ],
      "content": "NODE *\ndo_intdiv(int nargs)\n{\n\tNODE *numerator, *denominator, *result;\n\tdouble num, denom, quotient, remainder;\n\tNODE *sub, **lhs;\n\n\tresult = POP_PARAM();\n\tif (result->type != Node_var_array)\n\t\tfatal(_(\"intdiv: third argument is not an array\"));\n\tassoc_clear(result);\n\n\tdenominator = POP_SCALAR();\n\tnumerator = POP_SCALAR();\n\n\tif (do_lint) {\n\t\tif ((fixtype(numerator)->flags & NUMBER) == 0)\n\t\t\tlintwarn(_(\"intdiv: received non-numeric first argument\"));\n\t\tif ((fixtype(denominator)->flags & NUMBER) == 0)\n\t\t\tlintwarn(_(\"intdiv: received non-numeric second argument\"));\n\t}\n\n\t(void) force_number(numerator);\n\t(void) force_number(denominator);\n\tnum = double_to_int(get_number_d(numerator));\n\tdenom = double_to_int(get_number_d(denominator));\n\n\tif (denom == 0.0)\n\t\tfatal(_(\"intdiv: division by zero attempted\"));\n\n\tquotient = double_to_int(num / denom);\n\t/*\n\t * FIXME: This code is duplicated, factor it out to a\n\t * separate function.\n\t */\n#ifdef HAVE_FMOD\n\tremainder = fmod(num, denom);\n#else\t/* ! HAVE_FMOD */\n\t(void) modf(num / denom, & remainder);\n\tremainder = num - remainder * denom;\n#endif\t/* ! HAVE_FMOD */\n\tremainder = double_to_int(remainder);\n\n\tsub = make_string(\"quotient\", 8);\n\tlhs = assoc_lookup(result, sub);\n\tunref(*lhs);\n\t*lhs = make_number((AWKNUM) quotient);\n\n\tsub = make_string(\"remainder\", 9);\n\tlhs = assoc_lookup(result, sub);\n\tunref(*lhs);\n\t*lhs = make_number((AWKNUM) remainder);\n\n\tDEREF(denominator);\n\tDEREF(numerator);\n\n\treturn make_number((AWKNUM) 0.0);\n}",
      "lines": 58,
      "depth": 13,
      "decorators": [
        "NODE",
        "*\ndo_intdiv(int nargs)",
        "*"
      ]
    },
    "do_typeof": {
      "start_point": [
        4043,
        0
      ],
      "end_point": [
        4106,
        1
      ],
      "content": "NODE *\ndo_typeof(int nargs)\n{\n\tNODE *arg;\n\tchar *res = NULL;\n\tbool deref = true;\n\n\targ = POP();\n\tswitch (arg->type) {\n\tcase Node_var_array:\n\t\t/* Node_var_array is never UPREF'ed */\n\t\tres = \"array\";\n\t\tderef = false;\n\t\tbreak;\n\tcase Node_val:\n\t\tswitch (fixtype(arg)->flags & (STRING|NUMBER|USER_INPUT|REGEX)) {\n\t\tcase NUMBER:\n\t\t\tres = \"number\";\n\t\t\tbreak;\n\t\tcase NUMBER|USER_INPUT:\n\t\t\tres = \"strnum\";\n\t\t\tbreak;\n\t\tcase REGEX:\n\t\t\tres = \"regexp\";\n\t\t\tbreak;\n\t\tcase STRING:\n\t\t\tres = \"string\";\n\t\t\t// fall through\n\t\tcase NUMBER|STRING:\n\t\t\tif (arg == Nnull_string || (arg->flags & NULL_FIELD) != 0) {\n\t\t\t\tres = \"unassigned\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* fall through */\n\t\tdefault:\n\t\t\tif (res == NULL) {\n\t\t\t\twarning(_(\"typeof detected invalid flags combination `%s'; please file a bug report.\"), flags2str(arg->flags));\n\t\t\t\tres = \"unknown\";\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase Node_var_new:\n\t\tres = \"untyped\";\n\t\tderef = false;\n\t\tbreak;\n\tcase Node_var:\n\t\t/*\n\t\t * Note: this doesn't happen because the function calling code\n\t\t * in interpret.h pushes Node_var->var_value.\n\t\t */\n\t\tfatal(_(\"typeof: invalid argument type `%s'\"),\n\t\t\t\tnodetype2str(arg->type));\n\t\tbreak;\n\tdefault:\n\t\tfatal(_(\"typeof: unknown argument type `%s'\"),\n\t\t\t\tnodetype2str(arg->type));\n\t\tbreak;\n\t}\n\n\tif (deref)\n\t\tDEREF(arg);\n\treturn make_string(res, strlen(res));\n}",
      "lines": 64,
      "depth": 17,
      "decorators": [
        "NODE",
        "*\ndo_typeof(int nargs)",
        "*"
      ]
    },
    "mbc_byte_count": {
      "start_point": [
        4110,
        0
      ],
      "end_point": [
        4133,
        1
      ],
      "content": "static size_t\nmbc_byte_count(const char *ptr, size_t numchars)\n{\n\tmbstate_t cur_state;\n\tsize_t sum = 0;\n\tint mb_len;\n\n\tmemset(& cur_state, 0, sizeof(cur_state));\n\n\tassert(gawk_mb_cur_max > 1);\n\tmb_len = mbrlen(ptr, numchars * gawk_mb_cur_max, &cur_state);\n\tif (mb_len <= 0)\n\t\treturn numchars;\t/* no valid m.b. char */\n\n\tfor (; numchars > 0; numchars--) {\n\t\tmb_len = mbrlen(ptr, numchars * gawk_mb_cur_max, &cur_state);\n\t\tif (mb_len <= 0)\n\t\t\tbreak;\n\t\tsum += mb_len;\n\t\tptr += mb_len;\n\t}\n\n\treturn sum;\n}",
      "lines": 24,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "mbc_char_count": {
      "start_point": [
        4137,
        0
      ],
      "end_point": [
        4163,
        1
      ],
      "content": "static size_t\nmbc_char_count(const char *ptr, size_t numbytes)\n{\n\tmbstate_t cur_state;\n\tsize_t sum = 0;\n\tint mb_len;\n\n\tif (gawk_mb_cur_max == 1)\n\t\treturn numbytes;\n\n\tmemset(& cur_state, 0, sizeof(cur_state));\n\n\tmb_len = mbrlen(ptr, numbytes, &cur_state);\n\tif (mb_len <= 0)\n\t\treturn numbytes;\t/* no valid m.b. char */\n\n\twhile (numbytes > 0) {\n\t\tmb_len = mbrlen(ptr, numbytes, &cur_state);\n\t\tif (mb_len <= 0)\n\t\t\tbreak;\n\t\tsum++;\n\t\tptr += mb_len;\n\t\tnumbytes -= mb_len;\n\t}\n\n\treturn sum;\n}",
      "lines": 27,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "sanitize_exit_status": {
      "start_point": [
        4167,
        0
      ],
      "end_point": [
        4184,
        1
      ],
      "content": "int sanitize_exit_status(int status)\n{\n\tint ret = 0;\n\n\tif (WIFEXITED(status))\n\t\tret = WEXITSTATUS(status); /* normal exit */\n\telse if (WIFSIGNALED(status)) {\n\t\tbool coredumped = false;\n#ifdef WCOREDUMP\n\t\tcoredumped = WCOREDUMP(status);\n#endif\n\t\t/* use 256 since exit values are 8 bits */\n\t\tret = WTERMSIG(status) + (coredumped ? 512 : 256);\n\t} else\n\t\tret = 0;\t/* shouldn't get here */\n\n\treturn ret;\n}",
      "lines": 18,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "gawk/gawk-4.2.1/cint_array.c": {
    "cint_array_init": {
      "start_point": [
        148,
        0
      ],
      "end_point": [
        166,
        1
      ],
      "content": "static NODE **\ncint_array_init(NODE *symbol ATTRIBUTE_UNUSED, NODE *subs ATTRIBUTE_UNUSED)\n{\n\tif (symbol == NULL) {\n\t\tlong newval;\n\t\tsize_t nelems = (sizeof(power_two_table) / sizeof(power_two_table[0]));\n\n\t\t/* check relevant environment variables */\n\t\tif ((newval = getenv_long(\"NHAT\")) > 1 && newval < INT32_BIT)\n\t\t\tNHAT = newval;\n\t\t/* don't allow overflow off the end of the table */\n\t\tif (NHAT >= nelems)\n\t\t\tNHAT = nelems - 2;\n\t\tTHRESHOLD = power_two_table[NHAT + 1];\n\t} else\n\t\tnull_array(symbol);\n\n\treturn & success_node;\n}",
      "lines": 19,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "NODE",
        "**\ncint_array_init(NODE *symbol ATTRIBUTE_UNUSED, NODE *subs ATTRIBUTE_UNUSED)",
        "*",
        "*\ncint_array_init(NODE *symbol ATTRIBUTE_UNUSED, NODE *subs ATTRIBUTE_UNUSED)",
        "*"
      ]
    },
    "is_uinteger": {
      "start_point": [
        171,
        0
      ],
      "end_point": [
        177,
        1
      ],
      "content": "NODE **\nis_uinteger(NODE *symbol, NODE *subs)\n{\n\tif (is_integer(symbol, subs) != NULL && subs->numbr >= 0)\n\t\treturn & success_node;\n\treturn NULL;\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "NODE",
        "**\nis_uinteger(NODE *symbol, NODE *subs)",
        "*",
        "*\nis_uinteger(NODE *symbol, NODE *subs)",
        "*"
      ]
    },
    "cint_lookup": {
      "start_point": [
        182,
        0
      ],
      "end_point": [
        264,
        1
      ],
      "content": "static NODE **\ncint_lookup(NODE *symbol, NODE *subs)\n{\n\tNODE **lhs;\n\tlong k;\n\tint h1 = -1, m, li;\n\tNODE *tn, *xn;\n\tlong cint_size, capacity;\n\n\tk = -1;\n\tif (ISUINT(symbol, subs)) {\n\t\tk = subs->numbr;\t/* k >= 0 */\n\t\th1 = cint_hash(k);\t/* h1 >= NHAT */\n\t\tif ((lhs = cint_find(symbol, k, h1)) != NULL)\n\t\t\treturn lhs;\n\t}\n\txn = symbol->xarray;\n\tif (xn != NULL && (lhs = xn->aexists(xn, subs)) != NULL)\n\t\treturn lhs;\n\n\t/* It's not there, install it */\n\n\tif (k < 0)\n\t\tgoto xinstall;\n\n\tm = h1 - 1;\t/* m >= (NHAT- 1) */\n\n\t/* Estimate capacity upper bound.\n\t * capacity upper bound = current capacity + leaf array size.\n\t */\n\tli = m > NHAT ? m : NHAT;\n\twhile (li >= NHAT) {\n\t\t/* leaf-array of a HAT */\n\t\tli = (li + 1) / 2;\n\t}\n\tcapacity = symbol->array_capacity + power_two_table[li];\n\n\tcint_size = (xn == NULL) ? symbol->table_size\n\t\t\t\t: (symbol->table_size - xn->table_size);\n\tassert(cint_size >= 0);\n\tif ((capacity - cint_size) > THRESHOLD)\n\t\tgoto xinstall;\n\n\tif (symbol->nodes == NULL) {\n\t\tsymbol->array_capacity = 0;\n\t\tassert(symbol->table_size == 0);\n\n\t\t/* nodes[0] .. nodes[NHAT- 1] not used */\n\t\tezalloc(symbol->nodes, NODE **, INT32_BIT * sizeof(NODE *), \"cint_lookup\");\n\t}\n\n\tsymbol->table_size++;\t/* one more element in array */\n\n\ttn = symbol->nodes[h1];\n\tif (tn == NULL) {\n\t\ttn = make_node(Node_array_tree);\n\t\tsymbol->nodes[h1] = tn;\n\t}\n\n\tif (m < NHAT)\n\t\treturn tree_lookup(symbol, tn, k, NHAT, 0);\n\treturn tree_lookup(symbol, tn, k, m, power_two_table[m]);\n\nxinstall:\n\n\tsymbol->table_size++;\n\tif (xn == NULL) {\n\t\txn = symbol->xarray = make_array();\n\t\txn->vname = symbol->vname;\t/* shallow copy */\n\n\t\t/*\n\t\t * Avoid using assoc_lookup(xn, subs) which may lead\n\t\t * to infinite recursion.\n\t\t */\n\n\t\tif (is_integer(xn, subs))\n\t\t\txn->array_funcs = int_array_func;\n\t\telse\n\t\t\txn->array_funcs = str_array_func;\n\t\txn->flags |= XARRAY;\n\t}\n\treturn xn->alookup(xn, subs);\n}",
      "lines": 83,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "NODE",
        "**\ncint_lookup(NODE *symbol, NODE *subs)",
        "*",
        "*\ncint_lookup(NODE *symbol, NODE *subs)",
        "*"
      ]
    },
    "cint_exists": {
      "start_point": [
        269,
        0
      ],
      "end_point": [
        283,
        1
      ],
      "content": "static NODE **\ncint_exists(NODE *symbol, NODE *subs)\n{\n\tNODE *xn;\n\n\tif (ISUINT(symbol, subs)) {\n\t\tlong k = subs->numbr;\n\t\tNODE **lhs;\n\t\tif ((lhs = cint_find(symbol, k, cint_hash(k))) != NULL)\n\t\t\treturn lhs;\n\t}\n\tif ((xn = symbol->xarray) == NULL)\n\t\treturn NULL;\n\treturn xn->aexists(xn, subs);\n}",
      "lines": 15,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "NODE",
        "**\ncint_exists(NODE *symbol, NODE *subs)",
        "*",
        "*\ncint_exists(NODE *symbol, NODE *subs)",
        "*"
      ]
    },
    "cint_clear": {
      "start_point": [
        288,
        0
      ],
      "end_point": [
        314,
        1
      ],
      "content": "static NODE **\ncint_clear(NODE *symbol, NODE *subs ATTRIBUTE_UNUSED)\n{\n\tsize_t i;\n\tNODE *tn;\n\n\tassert(symbol->nodes != NULL);\n\n\tif (symbol->xarray != NULL) {\n\t\tNODE *xn = symbol->xarray;\n\t\tassoc_clear(xn);\n\t\tfreenode(xn);\n\t\tsymbol->xarray = NULL;\n\t}\n\n\tfor (i = NHAT; i < INT32_BIT; i++) {\n\t\ttn = symbol->nodes[i];\n\t\tif (tn != NULL) {\n\t\t\ttree_clear(tn);\n\t\t\tfreenode(tn);\n\t\t}\n\t}\n\n\tefree(symbol->nodes);\n\tsymbol->ainit(symbol, NULL);\t/* re-initialize symbol */\n\treturn NULL;\n}",
      "lines": 27,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "NODE",
        "**\ncint_clear(NODE *symbol, NODE *subs ATTRIBUTE_UNUSED)",
        "*",
        "*\ncint_clear(NODE *symbol, NODE *subs ATTRIBUTE_UNUSED)",
        "*"
      ]
    },
    "cint_remove": {
      "start_point": [
        319,
        0
      ],
      "end_point": [
        374,
        1
      ],
      "content": "static NODE **\ncint_remove(NODE *symbol, NODE *subs)\n{\n\tlong k;\n\tint h1;\n\tNODE *tn, *xn = symbol->xarray;\n\n\tif (symbol->table_size == 0)\n\t\treturn NULL;\n\n\tif (! ISUINT(symbol, subs))\n\t\tgoto xremove;\n\n\tassert(symbol->nodes != NULL);\n\n\tk = subs->numbr;\n\th1 = cint_hash(k);\n\ttn = symbol->nodes[h1];\n\tif (tn == NULL || ! tree_remove(symbol, tn, k))\n\t\tgoto xremove;\n\n\tif (tn->table_size == 0) {\n\t\tfreenode(tn);\n\t\tsymbol->nodes[h1] = NULL;\n\t}\n\n\tsymbol->table_size--;\n\n\tif (xn == NULL && symbol->table_size == 0) {\n\t\tefree(symbol->nodes);\n\t\tsymbol->ainit(symbol, NULL);\t/* re-initialize array 'symbol' */\n\t} else if(xn != NULL && symbol->table_size == xn->table_size) {\n\t\t/* promote xn to symbol */\n\n\t\txn->flags &= ~XARRAY;\n\t\txn->parent_array = symbol->parent_array;\n\t\tefree(symbol->nodes);\n\t\t*symbol = *xn;\n\t\tfreenode(xn);\n\t}\n\n\treturn & success_node;\n\nxremove:\n\txn = symbol->xarray;\n\tif (xn == NULL || xn->aremove(xn, subs) == NULL)\n\t\treturn NULL;\n\tif (xn->table_size == 0) {\n\t\tfreenode(xn);\n\t\tsymbol->xarray = NULL;\n\t}\n\tsymbol->table_size--;\n\tassert(symbol->table_size > 0);\n\n\treturn & success_node;\n}",
      "lines": 56,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "NODE",
        "**\ncint_remove(NODE *symbol, NODE *subs)",
        "*",
        "*\ncint_remove(NODE *symbol, NODE *subs)",
        "*"
      ]
    },
    "cint_copy": {
      "start_point": [
        379,
        0
      ],
      "end_point": [
        414,
        1
      ],
      "content": "static NODE **\ncint_copy(NODE *symbol, NODE *newsymb)\n{\n\tNODE **old, **new;\n\tsize_t i;\n\n\tassert(symbol->nodes != NULL);\n\n\t/* allocate new table */\n\tezalloc(new, NODE **, INT32_BIT * sizeof(NODE *), \"cint_copy\");\n\n\told = symbol->nodes;\n\tfor (i = NHAT; i < INT32_BIT; i++) {\n\t\tif (old[i] == NULL)\n\t\t\tcontinue;\n\t\tnew[i] = make_node(Node_array_tree);\n\t\ttree_copy(newsymb, old[i], new[i]);\n\t}\n\n\tif (symbol->xarray != NULL) {\n\t\tNODE *xn, *n;\n\t\txn = symbol->xarray;\n\t\tn = make_array();\n\t\tn->vname = newsymb->vname;\n\t\t(void) xn->acopy(xn, n);\n\t\tnewsymb->xarray = n;\n\t} else\n\t\tnewsymb->xarray = NULL;\n\n\tnewsymb->nodes = new;\n\tnewsymb->table_size = symbol->table_size;\n\tnewsymb->array_capacity = symbol->array_capacity;\n\tnewsymb->flags = symbol->flags;\n\n\treturn NULL;\n}",
      "lines": 36,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "NODE",
        "**\ncint_copy(NODE *symbol, NODE *newsymb)",
        "*",
        "*\ncint_copy(NODE *symbol, NODE *newsymb)",
        "*"
      ]
    },
    "cint_list": {
      "start_point": [
        419,
        0
      ],
      "end_point": [
        471,
        1
      ],
      "content": "static NODE**\ncint_list(NODE *symbol, NODE *t)\n{\n\tNODE **list = NULL;\n\tNODE *tn, *xn;\n\tunsigned long k = 0, num_elems, list_size;\n\tsize_t j, ja, jd;\n\tint elem_size = 1;\n\tassoc_kind_t assoc_kind;\n\n\tnum_elems = symbol->table_size;\n\tif (num_elems == 0)\n\t\treturn NULL;\n\tassoc_kind = (assoc_kind_t) t->flags;\n\tif ((assoc_kind & (AINDEX|AVALUE|ADELETE)) == (AINDEX|ADELETE))\n\t\tnum_elems = 1;\n\n\tif ((assoc_kind & (AINDEX|AVALUE)) == (AINDEX|AVALUE))\n\t\telem_size = 2;\n\tlist_size = num_elems * elem_size;\n\n\tif (symbol->xarray != NULL) {\n\t\txn = symbol->xarray;\n\t\tlist = xn->alist(xn, t);\n\t\tassert(list != NULL);\n\t\tassoc_kind &= ~(AASC|ADESC);\n\t\tt->flags = (unsigned int) assoc_kind;\n\t\tif (num_elems == 1 || num_elems == xn->table_size)\n\t\t\treturn list;\n\t\terealloc(list, NODE **, list_size * sizeof(NODE *), \"cint_list\");\n\t\tk = elem_size * xn->table_size;\n\t} else\n\t\temalloc(list, NODE **, list_size * sizeof(NODE *), \"cint_list\");\n\n\tif ((assoc_kind & AINUM) == 0) {\n\t\t/* not sorting by \"index num\" */\n\t\tassoc_kind &= ~(AASC|ADESC);\n\t\tt->flags = (unsigned int) assoc_kind;\n\t}\n\n\t/* populate it with index in ascending or descending order */\n\n\tfor (ja = NHAT, jd = INT32_BIT - 1; ja < INT32_BIT && jd >= NHAT; ) {\n\t\tj = (assoc_kind & ADESC) != 0 ? jd-- : ja++;\n\t\ttn = symbol->nodes[j];\n\t\tif (tn == NULL)\n\t\t\tcontinue;\n\t\tk += tree_list(tn, list + k, assoc_kind);\n\t\tif (k >= list_size)\n\t\t\treturn list;\n\t}\n\treturn list;\n}",
      "lines": 53,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "NODE",
        "**\ncint_list(NODE *symbol, NODE *t)",
        "*",
        "*\ncint_list(NODE *symbol, NODE *t)",
        "*"
      ]
    },
    "cint_dump": {
      "start_point": [
        476,
        0
      ],
      "end_point": [
        562,
        1
      ],
      "content": "static NODE **\ncint_dump(NODE *symbol, NODE *ndump)\n{\n\tNODE *tn, *xn = NULL;\n\tint indent_level;\n\tsize_t i;\n\tlong cint_size = 0, xsize = 0;\n\tAWKNUM kb = 0;\n\textern AWKNUM int_kilobytes(NODE *symbol);\n\textern AWKNUM str_kilobytes(NODE *symbol);\n\n\tindent_level = ndump->alevel;\n\n\tif (symbol->xarray != NULL) {\n\t\txn = symbol->xarray;\n\t\txsize = xn->table_size;\n\t}\n\tcint_size = symbol->table_size - xsize;\n\n\tif ((symbol->flags & XARRAY) == 0)\n\t\tfprintf(output_fp, \"%s `%s'\\n\",\n\t\t\t(symbol->parent_array == NULL) ? \"array\" : \"sub-array\",\n\t\t\tarray_vname(symbol));\n\tindent_level++;\n\tindent(indent_level);\n\tfprintf(output_fp, \"array_func: cint_array_func\\n\");\n\tif (symbol->flags != 0) {\n\t\tindent(indent_level);\n\t\tfprintf(output_fp, \"flags: %s\\n\", flags2str(symbol->flags));\n\t}\n\tindent(indent_level);\n\tfprintf(output_fp, \"NHAT: %d\\n\", NHAT);\n\tindent(indent_level);\n\tfprintf(output_fp, \"THRESHOLD: %ld\\n\", THRESHOLD);\n\tindent(indent_level);\n\tfprintf(output_fp, \"table_size: %ld (total), %ld (cint), %ld (int + str)\\n\",\n\t\t\t\tsymbol->table_size, cint_size, xsize);\n\tindent(indent_level);\n\tfprintf(output_fp, \"array_capacity: %lu\\n\", (unsigned long) symbol->array_capacity);\n\tindent(indent_level);\n\tfprintf(output_fp, \"Load Factor: %.2g\\n\", (AWKNUM) cint_size / symbol->array_capacity);\n\n\tfor (i = NHAT; i < INT32_BIT; i++) {\n\t\ttn = symbol->nodes[i];\n\t\tif (tn == NULL)\n\t\t\tcontinue;\n\t\t/* Node_array_tree  + HAT */\n\t\tkb += (sizeof(NODE) + tree_kilobytes(tn)) / 1024.0;\n\t}\n\tkb += (INT32_BIT * sizeof(NODE *)) / 1024.0;\t/* symbol->nodes */\n\tkb += (symbol->array_capacity * sizeof(NODE *)) / 1024.0;\t/* value nodes in Node_array_leaf(s) */\n\tif (xn != NULL) {\n\t\tif (xn->array_funcs == int_array_func)\n\t\t\tkb += int_kilobytes(xn);\n\t\telse\n\t\t\tkb += str_kilobytes(xn);\n\t}\n\n\tindent(indent_level);\n\tfprintf(output_fp, \"memory: %.2g kB (total)\\n\", kb);\n\n\t/* dump elements */\n\n\tif (ndump->adepth >= 0) {\n\t\tconst char *aname;\n\n\t\tfprintf(output_fp, \"\\n\");\n\t\taname = make_aname(symbol);\n\t\tfor (i = NHAT; i < INT32_BIT; i++) {\n\t\t\ttn = symbol->nodes[i];\n\t\t\tif (tn != NULL)\n\t\t\t\ttree_info(tn, ndump, aname);\n\t\t}\n\t}\n\n\tif (xn != NULL) {\n\t\tfprintf(output_fp, \"\\n\");\n\t\txn->adump(xn, ndump);\n\t}\n\n#ifdef ARRAYDEBUG\n\tif (ndump->adepth < -999)\n\t\tcint_print(symbol);\n#endif\n\n\treturn NULL;\n}",
      "lines": 87,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "NODE",
        "**\ncint_dump(NODE *symbol, NODE *ndump)",
        "*",
        "*\ncint_dump(NODE *symbol, NODE *ndump)",
        "*"
      ]
    },
    "cint_hash": {
      "start_point": [
        567,
        0
      ],
      "end_point": [
        620,
        1
      ],
      "content": "static inline int\ncint_hash(long k)\n{\n\tuint32_t num, r, shift;\n\n\tassert(k >= 0);\n\tif (k == 0)\n\t\treturn NHAT;\n\tnum = k;\n\n\t/* Find the Floor(log base 2 of 32-bit integer) */\n\n\t/*\n\t * Warren Jr., Henry S. (2002). Hacker's Delight.\n\t * Addison Wesley. pp. pp. 215. ISBN 978-0201914658.\n\t *\n\t *\tr = 0;\n\t *\tif (num >= 1<<16) { num >>= 16;\tr += 16; }\n\t *\tif (num >= 1<< 8) { num >>=  8;\tr +=  8; }\n\t *\tif (num >= 1<< 4) { num >>=  4;\tr +=  4; }\n\t *\tif (num >= 1<< 2) { num >>=  2;\tr +=  2; }\n\t *\tif (num >= 1<< 1) {\t\tr +=  1; }\n\t */\n\n\n\t/*\n\t * Slightly different code copied from:\n\t *\n\t * http://www-graphics.stanford.edu/~seander/bithacks.html\n\t * Bit Twiddling Hacks\n\t * By Sean Eron Anderson\n\t * seander@cs.stanford.edu\n\t * Individually, the code snippets here are in the public domain\n\t * (unless otherwise noted) --- feel free to use them however you please.\n\t * The aggregate collection and descriptions are (C) 1997-2005\n\t * Sean Eron Anderson. The code and descriptions are distributed in the\n\t * hope that they will be useful, but WITHOUT ANY WARRANTY and without\n\t * even the implied warranty of merchantability or fitness for a particular\n\t * purpose.\n\t *\n\t */\n\n\tr = (num > 0xFFFF) << 4; num >>= r;\n\tshift = (num > 0xFF) << 3; num >>= shift; r |= shift;\n\tshift = (num > 0x0F) << 2; num >>= shift; r |= shift;\n\tshift = (num > 0x03) << 1; num >>= shift; r |= shift;\n\tr |= (num >> 1);\n\n\t/* We use a single HAT for 0 <= num < 2^NHAT */\n\tif (r < NHAT)\n\t\treturn NHAT;\n\n\treturn (1 + r);\n}",
      "lines": 54,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "cint_find": {
      "start_point": [
        625,
        0
      ],
      "end_point": [
        633,
        1
      ],
      "content": "static inline NODE **\ncint_find(NODE *symbol, long k, int h1)\n{\n\tNODE *tn;\n\n\tif (symbol->nodes == NULL || (tn = symbol->nodes[h1]) == NULL)\n\t\treturn NULL;\n\treturn tree_exists(tn, k);\n}",
      "lines": 9,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "NODE",
        "**\ncint_find(NODE *symbol, long k, int h1)",
        "*",
        "*\ncint_find(NODE *symbol, long k, int h1)",
        "*"
      ]
    },
    "cint_print": {
      "start_point": [
        640,
        0
      ],
      "end_point": [
        654,
        1
      ],
      "content": "static void\ncint_print(NODE *symbol)\n{\n\tNODE *tn;\n\tsize_t i;\n\n\tfprintf(output_fp, \"I[%4lu:%-4lu]\\n\", (unsigned long) INT32_BIT,\n\t\t\t\t(unsigned long) symbol->table_size);\n\tfor (i = NHAT; i < INT32_BIT; i++) {\n\t\ttn = symbol->nodes[i];\n\t\tif (tn == NULL)\n\t\t\tcontinue;\n\t\ttree_print(tn, i, 1);\n\t}\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "make_node": {
      "start_point": [
        708,
        0
      ],
      "end_point": [
        716,
        1
      ],
      "content": "static inline NODE *\nmake_node(NODETYPE type)\n{\n\tNODE *n;\n\tgetnode(n);\n\tmemset(n, '\\0', sizeof(NODE));\n\tn->type = type;\n\treturn n;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "NODE",
        "*\nmake_node(NODETYPE type)",
        "*"
      ]
    },
    "tree_lookup": {
      "start_point": [
        721,
        0
      ],
      "end_point": [
        780,
        1
      ],
      "content": "static NODE **\ntree_lookup(NODE *symbol, NODE *tree, long k, int m, long base)\n{\n\tNODE **lhs;\n\tNODE *tn;\n\tint i, n;\n\tsize_t size;\n\tlong num = k;\n\n\t/*\n\t * HAT size (size of Top & Leaf array) = 2^n\n\t * where n = Floor ((m + 1)/2). For an odd value of m,\n\t * only the first half of the HAT is needed.\n\t */\n\n\tn = (m + 1) / 2;\n\n\tif (tree->table_size == 0) {\n\t\tsize_t actual_size;\n\t\tNODE **table;\n\n\t\tassert(tree->nodes == NULL);\n\n\t\t/* initialize top-level array */\n\t\tsize = actual_size = power_two_table[n];\n\t\ttree->array_base = base;\n\t\ttree->array_size = size;\n\t\ttree->table_size = 0;\t/* # of elements in the array */\n\t\tif (n > m/2) {\n\t\t\t/* only first half of the array used */\n\t\t\tactual_size /= 2;\n\t\t\ttree->flags |= HALFHAT;\n\t\t}\n\t\tezalloc(table, NODE **, actual_size * sizeof(NODE *), \"tree_lookup\");\n\t\ttree->nodes = table;\n\t} else\n\t\tsize = tree->array_size;\n\n\tnum -= tree->array_base;\n\ti = num / size;\t/* top-level array index */\n\tassert(i >= 0);\n\n\tif ((lhs = tree_find(tree, k, i)) != NULL)\n\t\treturn lhs;\n\n\t/* It's not there, install it */\n\n\ttree->table_size++;\n\tbase += (size * i);\n\ttn = tree->nodes[i];\n\tif (n > NHAT) {\n\t\tif (tn == NULL)\n\t\t\ttn = tree->nodes[i] = make_node(Node_array_tree);\n\t\treturn tree_lookup(symbol, tn, k, n, base);\n\t} else {\n\t\tif (tn == NULL)\n\t\t\ttn = tree->nodes[i] = make_node(Node_array_leaf);\n\t\treturn leaf_lookup(symbol, tn, k, size, base);\n\t}\n}",
      "lines": 60,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "NODE",
        "**\ntree_lookup(NODE *symbol, NODE *tree, long k, int m, long base)",
        "*",
        "*\ntree_lookup(NODE *symbol, NODE *tree, long k, int m, long base)",
        "*"
      ]
    },
    "tree_exists": {
      "start_point": [
        785,
        0
      ],
      "end_point": [
        799,
        1
      ],
      "content": "static NODE **\ntree_exists(NODE *tree, long k)\n{\n\tint i;\n\tNODE *tn;\n\n\ti = (k - tree->array_base) / tree->array_size;\n\tassert(i >= 0);\n\ttn = tree->nodes[i];\n\tif (tn == NULL)\n\t\treturn NULL;\n\tif (tn->type == Node_array_tree)\n\t\treturn tree_exists(tn, k);\n\treturn leaf_exists(tn, k);\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "NODE",
        "**\ntree_exists(NODE *tree, long k)",
        "*",
        "*\ntree_exists(NODE *tree, long k)",
        "*"
      ]
    },
    "tree_clear": {
      "start_point": [
        803,
        0
      ],
      "end_point": [
        827,
        1
      ],
      "content": "static void\ntree_clear(NODE *tree)\n{\n\tNODE *tn;\n\tsize_t\tj, hsize;\n\n\thsize = tree->array_size;\n\tif ((tree->flags & HALFHAT) != 0)\n\t\thsize /= 2;\n\n\tfor (j = 0; j < hsize; j++) {\n\t\ttn = tree->nodes[j];\n\t\tif (tn == NULL)\n\t\t\tcontinue;\n\t\tif (tn->type == Node_array_tree)\n\t\t\ttree_clear(tn);\n\t\telse\n\t\t\tleaf_clear(tn);\n\t\tfreenode(tn);\n\t}\n\n\tefree(tree->nodes);\n\tmemset(tree, '\\0', sizeof(NODE));\n\ttree->type = Node_array_tree;\n}",
      "lines": 25,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "tree_remove": {
      "start_point": [
        832,
        0
      ],
      "end_point": [
        863,
        1
      ],
      "content": "static int\ntree_remove(NODE *symbol, NODE *tree, long k)\n{\n\tint i;\n\tNODE *tn;\n\n\ti = (k - tree->array_base) / tree->array_size;\n\tassert(i >= 0);\n\ttn = tree->nodes[i];\n\tif (tn == NULL)\n\t\treturn false;\n\n\tif (tn->type == Node_array_tree\n\t\t\t&& ! tree_remove(symbol, tn, k))\n\t\treturn false;\n\telse if (tn->type == Node_array_leaf\n\t\t\t&& ! leaf_remove(symbol, tn, k))\n\t\treturn false;\n\n\tif (tn->table_size == 0) {\n\t\tfreenode(tn);\n\t\ttree->nodes[i] = NULL;\n\t}\n\n\t/* one less item in array */\n\tif (--tree->table_size == 0) {\n\t\tefree(tree->nodes);\n\t\tmemset(tree, '\\0', sizeof(NODE));\n\t\ttree->type = Node_array_tree;\n\t}\n\treturn true;\n}",
      "lines": 32,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "tree_find": {
      "start_point": [
        868,
        0
      ],
      "end_point": [
        881,
        1
      ],
      "content": "static inline NODE **\ntree_find(NODE *tree, long k, int i)\n{\n\tNODE *tn;\n\n\tassert(tree->nodes != NULL);\n\ttn = tree->nodes[i];\n\tif (tn != NULL) {\n\t\tif (tn->type == Node_array_tree)\n\t\t\treturn tree_exists(tn, k);\n\t\treturn leaf_exists(tn, k);\n\t}\n\treturn NULL;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "NODE",
        "**\ntree_find(NODE *tree, long k, int i)",
        "*",
        "*\ntree_find(NODE *tree, long k, int i)",
        "*"
      ]
    },
    "tree_list": {
      "start_point": [
        886,
        0
      ],
      "end_point": [
        912,
        1
      ],
      "content": "static long\ntree_list(NODE *tree, NODE **list, assoc_kind_t assoc_kind)\n{\n\tNODE *tn;\n\tsize_t j, cj, hsize;\n\tlong k = 0;\n\n\tassert(list != NULL);\n\n\thsize = tree->array_size;\n\tif ((tree->flags & HALFHAT) != 0)\n\t\thsize /= 2;\n\n\tfor (j = 0; j < hsize; j++) {\n\t\tcj = (assoc_kind & ADESC) != 0 ? (hsize - 1 - j) : j;\n\t\ttn = tree->nodes[cj];\n\t\tif (tn == NULL)\n\t\t\tcontinue;\n\t\tif (tn->type == Node_array_tree)\n\t\t\tk += tree_list(tn, list + k, assoc_kind);\n\t\telse\n\t\t\tk += leaf_list(tn, list + k, assoc_kind);\n\t\tif ((assoc_kind & ADELETE) != 0 && k >= 1)\n\t\t\treturn k;\n\t}\n\treturn k;\n}",
      "lines": 27,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "long",
        "long"
      ]
    },
    "tree_copy": {
      "start_point": [
        917,
        0
      ],
      "end_point": [
        946,
        1
      ],
      "content": "static void\ntree_copy(NODE *newsymb, NODE *tree, NODE *newtree)\n{\n\tNODE **old, **new;\n\tsize_t j, hsize;\n\n\thsize = tree->array_size;\n\tif ((tree->flags & HALFHAT) != 0)\n\t\thsize /= 2;\n\n\tezalloc(new, NODE **, hsize * sizeof(NODE *), \"tree_copy\");\n\tnewtree->nodes = new;\n\tnewtree->array_base = tree->array_base;\n\tnewtree->array_size = tree->array_size;\n\tnewtree->table_size = tree->table_size;\n\tnewtree->flags = tree->flags;\n\n\told = tree->nodes;\n\tfor (j = 0; j < hsize; j++) {\n\t\tif (old[j] == NULL)\n\t\t\tcontinue;\n\t\tif (old[j]->type == Node_array_tree) {\n\t\t\tnew[j] = make_node(Node_array_tree);\n\t\t\ttree_copy(newsymb, old[j], new[j]);\n\t\t} else {\n\t\t\tnew[j] = make_node(Node_array_leaf);\n\t\t\tleaf_copy(newsymb, old[j], new[j]);\n\t\t}\n\t}\n}",
      "lines": 30,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "tree_info": {
      "start_point": [
        951,
        0
      ],
      "end_point": [
        970,
        1
      ],
      "content": "static void\ntree_info(NODE *tree, NODE *ndump, const char *aname)\n{\n\tNODE *tn;\n\tsize_t j, hsize;\n\n\thsize = tree->array_size;\n\tif ((tree->flags & HALFHAT) != 0)\n\t\thsize /= 2;\n\n\tfor (j = 0; j < hsize; j++) {\n\t\ttn = tree->nodes[j];\n\t\tif (tn == NULL)\n\t\t\tcontinue;\n\t\tif (tn->type == Node_array_tree)\n\t\t\ttree_info(tn, ndump, aname);\n\t\telse\n\t\t\tleaf_info(tn, ndump, aname);\n\t}\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "tree_kilobytes": {
      "start_point": [
        975,
        0
      ],
      "end_point": [
        995,
        1
      ],
      "content": "static size_t\ntree_kilobytes(NODE *tree)\n{\n\tNODE *tn;\n\tsize_t j, hsize;\n\tsize_t sz = 0;\n\n\thsize = tree->array_size;\n\tif ((tree->flags & HALFHAT) != 0)\n\t\thsize /= 2;\n\tfor (j = 0; j < hsize; j++) {\n\t\ttn = tree->nodes[j];\n\t\tif (tn == NULL)\n\t\t\tcontinue;\n\t\tsz += sizeof(NODE);\t/* Node_array_tree or Node_array_leaf */\n\t\tif (tn->type == Node_array_tree)\n\t\t\tsz += tree_kilobytes(tn);\n\t}\n\tsz += hsize * sizeof(NODE *);\t/* tree->nodes */\n\treturn sz;\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "tree_print": {
      "start_point": [
        1001,
        0
      ],
      "end_point": [
        1026,
        1
      ],
      "content": "static void\ntree_print(NODE *tree, size_t bi, int indent_level)\n{\n\tNODE *tn;\n\tsize_t j, hsize;\n\n\tindent(indent_level);\n\n\thsize = tree->array_size;\n\tif ((tree->flags & HALFHAT) != 0)\n\t\thsize /= 2;\n\tfprintf(output_fp, \"%4lu:%s[%4lu:%-4lu]\\n\",\n\t\t\t(unsigned long) bi,\n\t\t\t(tree->flags & HALFHAT) != 0 ? \"HH\" : \"H\",\n\t\t\t(unsigned long) hsize, (unsigned long) tree->table_size);\n\n\tfor (j = 0; j < hsize; j++) {\n\t\ttn = tree->nodes[j];\n\t\tif (tn == NULL)\n\t\t\tcontinue;\n\t\tif (tn->type == Node_array_tree)\n\t\t\ttree_print(tn, j, indent_level + 1);\n\t\telse\n\t\t\tleaf_print(tn, j, indent_level + 1);\n\t}\n}",
      "lines": 26,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "leaf_lookup": {
      "start_point": [
        1036,
        0
      ],
      "end_point": [
        1055,
        1
      ],
      "content": "static inline NODE **\nleaf_lookup(NODE *symbol, NODE *array, long k, long size, long base)\n{\n\tNODE **lhs;\n\n\tif (array->nodes == NULL) {\n\t\tarray->table_size = 0;\t/* sanity */\n\t\tarray->array_size = size;\n\t\tarray->array_base = base;\n\t\tezalloc(array->nodes, NODE **, size * sizeof(NODE *), \"leaf_lookup\");\n\t\tsymbol->array_capacity += size;\n\t}\n\n\tlhs = array->nodes + (k - base); /* leaf element */\n\tif (*lhs == NULL) {\n\t\tarray->table_size++;\t/* one more element in leaf array */\n\t\t*lhs = dupnode(Nnull_string);\n\t}\n\treturn lhs;\n}",
      "lines": 20,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "NODE",
        "**\nleaf_lookup(NODE *symbol, NODE *array, long k, long size, long base)",
        "*",
        "*\nleaf_lookup(NODE *symbol, NODE *array, long k, long size, long base)",
        "*"
      ]
    },
    "leaf_exists": {
      "start_point": [
        1060,
        0
      ],
      "end_point": [
        1066,
        1
      ],
      "content": "static inline NODE **\nleaf_exists(NODE *array, long k)\n{\n\tNODE **lhs;\n\tlhs = array->nodes + (k - array->array_base);\n\treturn (*lhs != NULL) ? lhs : NULL;\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "NODE",
        "**\nleaf_exists(NODE *array, long k)",
        "*",
        "*\nleaf_exists(NODE *array, long k)",
        "*"
      ]
    },
    "leaf_clear": {
      "start_point": [
        1071,
        0
      ],
      "end_point": [
        1091,
        1
      ],
      "content": "static void\nleaf_clear(NODE *array)\n{\n\tlong i, size = array->array_size;\n\tNODE *r;\n\n\tfor (i = 0; i < size; i++) {\n\t\tr = array->nodes[i];\n\t\tif (r == NULL)\n\t\t\tcontinue;\n\t\tif (r->type == Node_var_array) {\n\t\t\tassoc_clear(r);\t\t/* recursively clear all sub-arrays */\n\t\t\tefree(r->vname);\n\t\t\tfreenode(r);\n\t\t} else\n\t\t\tunref(r);\n\t}\n\tefree(array->nodes);\n\tarray->nodes = NULL;\n\tarray->array_size = array->table_size = 0;\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "leaf_remove": {
      "start_point": [
        1096,
        0
      ],
      "end_point": [
        1112,
        1
      ],
      "content": "static int\nleaf_remove(NODE *symbol, NODE *array, long k)\n{\n\tNODE **lhs;\n\n\tlhs = array->nodes + (k - array->array_base);\n\tif (*lhs == NULL)\n\t\treturn false;\n\t*lhs = NULL;\n\tif (--array->table_size == 0) {\n\t\tefree(array->nodes);\n\t\tarray->nodes = NULL;\n\t\tsymbol->array_capacity -= array->array_size;\n\t\tarray->array_size = 0;\t/* sanity */\n\t}\n\treturn true;\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "leaf_copy": {
      "start_point": [
        1117,
        0
      ],
      "end_point": [
        1145,
        1
      ],
      "content": "static void\nleaf_copy(NODE *newsymb, NODE *array, NODE *newarray)\n{\n\tNODE **old, **new;\n\tlong size, i;\n\n\tsize = array->array_size;\n\tezalloc(new, NODE **, size * sizeof(NODE *), \"leaf_copy\");\n\tnewarray->nodes = new;\n\tnewarray->array_size = size;\n\tnewarray->array_base = array->array_base;\n\tnewarray->flags = array->flags;\n\tnewarray->table_size = array->table_size;\n\n\told = array->nodes;\n\tfor (i = 0; i < size; i++) {\n\t\tif (old[i] == NULL)\n\t\t\tcontinue;\n\t\tif (old[i]->type == Node_val)\n\t\t\tnew[i] = dupnode(old[i]);\n\t\telse {\n\t\t\tNODE *r;\n\t\t\tr = make_array();\n\t\t\tr->vname = estrdup(old[i]->vname, strlen(old[i]->vname));\n\t\t\tr->parent_array = newsymb;\n\t\t\tnew[i] = assoc_copy(old[i], r);\n\t\t}\n\t}\n}",
      "lines": 29,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "leaf_list": {
      "start_point": [
        1150,
        0
      ],
      "end_point": [
        1192,
        1
      ],
      "content": "static long\nleaf_list(NODE *array, NODE **list, assoc_kind_t assoc_kind)\n{\n\tNODE *r, *subs;\n\tlong num, i, ci, k = 0;\n\tlong size = array->array_size;\n\tstatic char buf[100];\n\n\tfor (i = 0; i < size; i++) {\n\t\tci = (assoc_kind & ADESC) != 0 ? (size - 1 - i) : i;\n\t\tr = array->nodes[ci];\n\t\tif (r == NULL)\n\t\t\tcontinue;\n\n\t\t/* index */\n\t\tnum = array->array_base + ci;\n\t\tif ((assoc_kind & AISTR) != 0) {\n\t\t\tsprintf(buf, \"%ld\", num);\n\t\t\tsubs = make_string(buf, strlen(buf));\n\t\t\tsubs->numbr = num;\n\t\t\tsubs->flags |= (NUMCUR|NUMINT);\n\t\t} else {\n\t\t\tsubs = make_number((AWKNUM) num);\n\t\t\tsubs->flags |= (INTIND|NUMINT);\n\t\t}\n\t\tlist[k++] = subs;\n\n\t\t/* value */\n\t\tif ((assoc_kind & AVALUE) != 0) {\n\t\t\tif (r->type == Node_val) {\n\t\t\t\tif ((assoc_kind & AVNUM) != 0)\n\t\t\t\t\t(void) force_number(r);\n\t\t\t\telse if ((assoc_kind & AVSTR) != 0)\n\t\t\t\t\tr = force_string(r);\n\t\t\t}\n\t\t\tlist[k++] = r;\n\t\t}\n\t\tif ((assoc_kind & ADELETE) != 0 && k >= 1)\n\t\t\treturn k;\n\t}\n\n\treturn k;\n}",
      "lines": 43,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "long",
        "long"
      ]
    },
    "leaf_info": {
      "start_point": [
        1197,
        0
      ],
      "end_point": [
        1215,
        1
      ],
      "content": "static void\nleaf_info(NODE *array, NODE *ndump, const char *aname)\n{\n\tNODE *subs, *val;\n\tsize_t i, size;\n\n\tsize = array->array_size;\n\n\tsubs = make_number((AWKNUM) 0.0);\n\tsubs->flags |= (INTIND|NUMINT);\n\tfor (i = 0; i < size; i++) {\n\t\tval = array->nodes[i];\n\t\tif (val == NULL)\n\t\t\tcontinue;\n\t\tsubs->numbr = array->array_base + i;\n\t\tassoc_info(subs, val, ndump, aname);\n\t}\n\tunref(subs);\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "leaf_print": {
      "start_point": [
        1222,
        0
      ],
      "end_point": [
        1230,
        1
      ],
      "content": "static void\nleaf_print(NODE *array, size_t bi, int indent_level)\n{\n\tindent(indent_level);\n\tfprintf(output_fp, \"%4lu:L[%4lu:%-4lu]\\n\",\n\t\t\t(unsigned long) bi,\n\t\t\t(unsigned long) array->array_size,\n\t\t\t(unsigned long) array->table_size);\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "gawk/gawk-4.2.1/cmd.h": {},
  "gawk/gawk-4.2.1/command.c": {
    "yy_symbol_value_print": {
      "start_point": [
        927,
        0
      ],
      "end_point": [
        939,
        1
      ],
      "content": "static void\nyy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)\n{\n  FILE *yyo = yyoutput;\n  YYUSE (yyo);\n  if (!yyvaluep)\n    return;\n# ifdef YYPRINT\n  if (yytype < YYNTOKENS)\n    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);\n# endif\n  YYUSE (yytype);\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yy_symbol_print": {
      "start_point": [
        946,
        0
      ],
      "end_point": [
        954,
        1
      ],
      "content": "static void\nyy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)\n{\n  YYFPRINTF (yyoutput, \"%s %s (\",\n             yytype < YYNTOKENS ? \"token\" : \"nterm\", yytname[yytype]);\n\n  yy_symbol_value_print (yyoutput, yytype, yyvaluep);\n  YYFPRINTF (yyoutput, \")\");\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yy_stack_print": {
      "start_point": [
        961,
        0
      ],
      "end_point": [
        971,
        1
      ],
      "content": "static void\nyy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)\n{\n  YYFPRINTF (stderr, \"Stack now\");\n  for (; yybottom <= yytop; yybottom++)\n    {\n      int yybot = *yybottom;\n      YYFPRINTF (stderr, \" %d\", yybot);\n    }\n  YYFPRINTF (stderr, \"\\n\");\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yy_reduce_print": {
      "start_point": [
        984,
        0
      ],
      "end_point": [
        1002,
        1
      ],
      "content": "static void\nyy_reduce_print (yytype_int16 *yyssp, YYSTYPE *yyvsp, int yyrule)\n{\n  unsigned long int yylno = yyrline[yyrule];\n  int yynrhs = yyr2[yyrule];\n  int yyi;\n  YYFPRINTF (stderr, \"Reducing stack by rule %d (line %lu):\\n\",\n             yyrule - 1, yylno);\n  /* The symbols being reduced.  */\n  for (yyi = 0; yyi < yynrhs; yyi++)\n    {\n      YYFPRINTF (stderr, \"   $%d = \", yyi + 1);\n      yy_symbol_print (stderr,\n                       yystos[yyssp[yyi + 1 - yynrhs]],\n                       &(yyvsp[(yyi + 1) - (yynrhs)])\n                                              );\n      YYFPRINTF (stderr, \"\\n\");\n    }\n}",
      "lines": 19,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yystrlen": {
      "start_point": [
        1045,
        0
      ],
      "end_point": [
        1052,
        1
      ],
      "content": "static YYSIZE_T\nyystrlen (const char *yystr)\n{\n  YYSIZE_T yylen;\n  for (yylen = 0; yystr[yylen]; yylen++)\n    continue;\n  return yylen;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "YYSIZE_T"
      ]
    },
    "yystpcpy": {
      "start_point": [
        1062,
        0
      ],
      "end_point": [
        1072,
        1
      ],
      "content": "static char *\nyystpcpy (char *yydest, const char *yysrc)\n{\n  char *yyd = yydest;\n  const char *yys = yysrc;\n\n  while ((*yyd++ = *yys++) != '\\0')\n    continue;\n\n  return yyd - 1;\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nyystpcpy (char *yydest, const char *yysrc)",
        "*"
      ]
    },
    "yytnamerr": {
      "start_point": [
        1084,
        0
      ],
      "end_point": [
        1121,
        1
      ],
      "content": "static YYSIZE_T\nyytnamerr (char *yyres, const char *yystr)\n{\n  if (*yystr == '\"')\n    {\n      YYSIZE_T yyn = 0;\n      char const *yyp = yystr;\n\n      for (;;)\n        switch (*++yyp)\n          {\n          case '\\'':\n          case ',':\n            goto do_not_strip_quotes;\n\n          case '\\\\':\n            if (*++yyp != '\\\\')\n              goto do_not_strip_quotes;\n            /* Fall through.  */\n          default:\n            if (yyres)\n              yyres[yyn] = *yyp;\n            yyn++;\n            break;\n\n          case '\"':\n            if (yyres)\n              yyres[yyn] = '\\0';\n            return yyn;\n          }\n    do_not_strip_quotes: ;\n    }\n\n  if (! yyres)\n    return yystrlen (yystr);\n\n  return yystpcpy (yyres, yystr) - yyres;\n}",
      "lines": 38,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "YYSIZE_T"
      ]
    },
    "yysyntax_error": {
      "start_point": [
        1132,
        0
      ],
      "end_point": [
        1257,
        1
      ],
      "content": "static int\nyysyntax_error (YYSIZE_T *yymsg_alloc, char **yymsg,\n                yytype_int16 *yyssp, int yytoken)\n{\n  YYSIZE_T yysize0 = yytnamerr (YY_NULLPTR, yytname[yytoken]);\n  YYSIZE_T yysize = yysize0;\n  enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };\n  /* Internationalized format string. */\n  const char *yyformat = YY_NULLPTR;\n  /* Arguments of yyformat. */\n  char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];\n  /* Number of reported tokens (one for the \"unexpected\", one per\n     \"expected\"). */\n  int yycount = 0;\n\n  /* There are many possibilities here to consider:\n     - If this state is a consistent state with a default action, then\n       the only way this function was invoked is if the default action\n       is an error action.  In that case, don't check for expected\n       tokens because there are none.\n     - The only way there can be no lookahead present (in yychar) is if\n       this state is a consistent state with a default action.  Thus,\n       detecting the absence of a lookahead is sufficient to determine\n       that there is no unexpected or expected token to report.  In that\n       case, just report a simple \"syntax error\".\n     - Don't assume there isn't a lookahead just because this state is a\n       consistent state with a default action.  There might have been a\n       previous inconsistent state, consistent state with a non-default\n       action, or user semantic action that manipulated yychar.\n     - Of course, the expected token list depends on states to have\n       correct lookahead information, and it depends on the parser not\n       to perform extra reductions after fetching a lookahead from the\n       scanner and before detecting a syntax error.  Thus, state merging\n       (from LALR or IELR) and default reductions corrupt the expected\n       token list.  However, the list is correct for canonical LR with\n       one exception: it will still contain any token that will not be\n       accepted due to an error action in a later state.\n  */\n  if (yytoken != YYEMPTY)\n    {\n      int yyn = yypact[*yyssp];\n      yyarg[yycount++] = yytname[yytoken];\n      if (!yypact_value_is_default (yyn))\n        {\n          /* Start YYX at -YYN if negative to avoid negative indexes in\n             YYCHECK.  In other words, skip the first -YYN actions for\n             this state because they are default actions.  */\n          int yyxbegin = yyn < 0 ? -yyn : 0;\n          /* Stay within bounds of both yycheck and yytname.  */\n          int yychecklim = YYLAST - yyn + 1;\n          int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;\n          int yyx;\n\n          for (yyx = yyxbegin; yyx < yyxend; ++yyx)\n            if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR\n                && !yytable_value_is_error (yytable[yyx + yyn]))\n              {\n                if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)\n                  {\n                    yycount = 1;\n                    yysize = yysize0;\n                    break;\n                  }\n                yyarg[yycount++] = yytname[yyx];\n                {\n                  YYSIZE_T yysize1 = yysize + yytnamerr (YY_NULLPTR, yytname[yyx]);\n                  if (! (yysize <= yysize1\n                         && yysize1 <= YYSTACK_ALLOC_MAXIMUM))\n                    return 2;\n                  yysize = yysize1;\n                }\n              }\n        }\n    }\n\n  switch (yycount)\n    {\n# define YYCASE_(N, S)                      \\\n      case N:                               \\\n        yyformat = S;                       \\\n      break\n      YYCASE_(0, YY_(\"syntax error\"));\n      YYCASE_(1, YY_(\"syntax error, unexpected %s\"));\n      YYCASE_(2, YY_(\"syntax error, unexpected %s, expecting %s\"));\n      YYCASE_(3, YY_(\"syntax error, unexpected %s, expecting %s or %s\"));\n      YYCASE_(4, YY_(\"syntax error, unexpected %s, expecting %s or %s or %s\"));\n      YYCASE_(5, YY_(\"syntax error, unexpected %s, expecting %s or %s or %s or %s\"));\n# undef YYCASE_\n    }\n\n  {\n    YYSIZE_T yysize1 = yysize + yystrlen (yyformat);\n    if (! (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM))\n      return 2;\n    yysize = yysize1;\n  }\n\n  if (*yymsg_alloc < yysize)\n    {\n      *yymsg_alloc = 2 * yysize;\n      if (! (yysize <= *yymsg_alloc\n             && *yymsg_alloc <= YYSTACK_ALLOC_MAXIMUM))\n        *yymsg_alloc = YYSTACK_ALLOC_MAXIMUM;\n      return 1;\n    }\n\n  /* Avoid sprintf, as that infringes on the user's name space.\n     Don't have undefined behavior even if the translation\n     produced a string with the wrong number of \"%s\"s.  */\n  {\n    char *yyp = *yymsg;\n    int yyi = 0;\n    while ((*yyp = *yyformat) != '\\0')\n      if (*yyp == '%' && yyformat[1] == 's' && yyi < yycount)\n        {\n          yyp += yytnamerr (yyp, yyarg[yyi++]);\n          yyformat += 2;\n        }\n      else\n        {\n          yyp++;\n          yyformat++;\n        }\n  }\n  return 0;\n}",
      "lines": 126,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "yydestruct": {
      "start_point": [
        1264,
        0
      ],
      "end_point": [
        1275,
        1
      ],
      "content": "static void\nyydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)\n{\n  YYUSE (yyvaluep);\n  if (!yymsg)\n    yymsg = \"Deleting\";\n  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);\n\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  YYUSE (yytype);\n  YY_IGNORE_MAYBE_UNINITIALIZED_END\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yyparse": {
      "start_point": [
        1293,
        0
      ],
      "end_point": [
        2495,
        1
      ],
      "content": "int\nyyparse (void)\n{\n    int yystate;\n    /* Number of tokens to shift before error messages enabled.  */\n    int yyerrstatus;\n\n    /* The stacks and their tools:\n       'yyss': related to states.\n       'yyvs': related to semantic values.\n\n       Refer to the stacks through separate pointers, to allow yyoverflow\n       to reallocate them elsewhere.  */\n\n    /* The state stack.  */\n    yytype_int16 yyssa[YYINITDEPTH];\n    yytype_int16 *yyss;\n    yytype_int16 *yyssp;\n\n    /* The semantic value stack.  */\n    YYSTYPE yyvsa[YYINITDEPTH];\n    YYSTYPE *yyvs;\n    YYSTYPE *yyvsp;\n\n    YYSIZE_T yystacksize;\n\n  int yyn;\n  int yyresult;\n  /* Lookahead token as an internal (translated) token number.  */\n  int yytoken = 0;\n  /* The variables used to return semantic value and location from the\n     action routines.  */\n  YYSTYPE yyval;\n\n#if YYERROR_VERBOSE\n  /* Buffer for error messages, and its allocated size.  */\n  char yymsgbuf[128];\n  char *yymsg = yymsgbuf;\n  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;\n#endif\n\n#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))\n\n  /* The number of symbols on the RHS of the reduced rule.\n     Keep to zero when no symbol should be popped.  */\n  int yylen = 0;\n\n  yyssp = yyss = yyssa;\n  yyvsp = yyvs = yyvsa;\n  yystacksize = YYINITDEPTH;\n\n  YYDPRINTF ((stderr, \"Starting parse\\n\"));\n\n  yystate = 0;\n  yyerrstatus = 0;\n  yynerrs = 0;\n  yychar = YYEMPTY; /* Cause a token to be read.  */\n  goto yysetstate;\n\n/*------------------------------------------------------------.\n| yynewstate -- Push a new state, which is found in yystate.  |\n`------------------------------------------------------------*/\n yynewstate:\n  /* In all cases, when you get here, the value and location stacks\n     have just been pushed.  So pushing a state here evens the stacks.  */\n  yyssp++;\n\n yysetstate:\n  *yyssp = yystate;\n\n  if (yyss + yystacksize - 1 <= yyssp)\n    {\n      /* Get the current used size of the three stacks, in elements.  */\n      YYSIZE_T yysize = yyssp - yyss + 1;\n\n#ifdef yyoverflow\n      {\n        /* Give user a chance to reallocate the stack.  Use copies of\n           these so that the &'s don't force the real ones into\n           memory.  */\n        YYSTYPE *yyvs1 = yyvs;\n        yytype_int16 *yyss1 = yyss;\n\n        /* Each stack pointer address is followed by the size of the\n           data in use in that stack, in bytes.  This used to be a\n           conditional around just the two extra args, but that might\n           be undefined if yyoverflow is a macro.  */\n        yyoverflow (YY_(\"memory exhausted\"),\n                    &yyss1, yysize * sizeof (*yyssp),\n                    &yyvs1, yysize * sizeof (*yyvsp),\n                    &yystacksize);\n\n        yyss = yyss1;\n        yyvs = yyvs1;\n      }\n#else /* no yyoverflow */\n# ifndef YYSTACK_RELOCATE\n      goto yyexhaustedlab;\n# else\n      /* Extend the stack our own way.  */\n      if (YYMAXDEPTH <= yystacksize)\n        goto yyexhaustedlab;\n      yystacksize *= 2;\n      if (YYMAXDEPTH < yystacksize)\n        yystacksize = YYMAXDEPTH;\n\n      {\n        yytype_int16 *yyss1 = yyss;\n        union yyalloc *yyptr =\n          (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));\n        if (! yyptr)\n          goto yyexhaustedlab;\n        YYSTACK_RELOCATE (yyss_alloc, yyss);\n        YYSTACK_RELOCATE (yyvs_alloc, yyvs);\n#  undef YYSTACK_RELOCATE\n        if (yyss1 != yyssa)\n          YYSTACK_FREE (yyss1);\n      }\n# endif\n#endif /* no yyoverflow */\n\n      yyssp = yyss + yysize - 1;\n      yyvsp = yyvs + yysize - 1;\n\n      YYDPRINTF ((stderr, \"Stack size increased to %lu\\n\",\n                  (unsigned long int) yystacksize));\n\n      if (yyss + yystacksize - 1 <= yyssp)\n        YYABORT;\n    }\n\n  YYDPRINTF ((stderr, \"Entering state %d\\n\", yystate));\n\n  if (yystate == YYFINAL)\n    YYACCEPT;\n\n  goto yybackup;\n\n/*-----------.\n| yybackup.  |\n`-----------*/\nyybackup:\n\n  /* Do appropriate processing given the current state.  Read a\n     lookahead token if we need one and don't already have one.  */\n\n  /* First try to decide what to do without reference to lookahead token.  */\n  yyn = yypact[yystate];\n  if (yypact_value_is_default (yyn))\n    goto yydefault;\n\n  /* Not known => get a lookahead token if don't already have one.  */\n\n  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */\n  if (yychar == YYEMPTY)\n    {\n      YYDPRINTF ((stderr, \"Reading a token: \"));\n      yychar = yylex ();\n    }\n\n  if (yychar <= YYEOF)\n    {\n      yychar = yytoken = YYEOF;\n      YYDPRINTF ((stderr, \"Now at end of input.\\n\"));\n    }\n  else\n    {\n      yytoken = YYTRANSLATE (yychar);\n      YY_SYMBOL_PRINT (\"Next token is\", yytoken, &yylval, &yylloc);\n    }\n\n  /* If the proper action on seeing token YYTOKEN is to reduce or to\n     detect an error, take that action.  */\n  yyn += yytoken;\n  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)\n    goto yydefault;\n  yyn = yytable[yyn];\n  if (yyn <= 0)\n    {\n      if (yytable_value_is_error (yyn))\n        goto yyerrlab;\n      yyn = -yyn;\n      goto yyreduce;\n    }\n\n  /* Count tokens shifted since error; after three, turn off error\n     status.  */\n  if (yyerrstatus)\n    yyerrstatus--;\n\n  /* Shift the lookahead token.  */\n  YY_SYMBOL_PRINT (\"Shifting\", yytoken, &yylval, &yylloc);\n\n  /* Discard the shifted token.  */\n  yychar = YYEMPTY;\n\n  yystate = yyn;\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  *++yyvsp = yylval;\n  YY_IGNORE_MAYBE_UNINITIALIZED_END\n\n  goto yynewstate;\n\n\n/*-----------------------------------------------------------.\n| yydefault -- do the default action for the current state.  |\n`-----------------------------------------------------------*/\nyydefault:\n  yyn = yydefact[yystate];\n  if (yyn == 0)\n    goto yyerrlab;\n  goto yyreduce;\n\n\n/*-----------------------------.\n| yyreduce -- Do a reduction.  |\n`-----------------------------*/\nyyreduce:\n  /* yyn is the number of a rule to reduce with.  */\n  yylen = yyr2[yyn];\n\n  /* If YYLEN is nonzero, implement the default value of the action:\n     '$$ = $1'.\n\n     Otherwise, the following line sets YYVAL to garbage.\n     This behavior is undocumented and Bison\n     users should not rely upon it.  Assigning to YYVAL\n     unconditionally makes the parser a bit smaller, and it avoids a\n     GCC warning that YYVAL may be used uninitialized.  */\n  yyval = yyvsp[1-yylen];\n\n\n  YY_REDUCE_PRINT (yyn);\n  switch (yyn)\n    {\n        case 3:\n#line 111 \"command.y\" /* yacc.c:1646  */\n    {\n\t\tcmd_idx = -1;\n\t\twant_nodeval = false;\n\t\tif (lexptr_begin != NULL) {\n\t\t\tif (input_from_tty && lexptr_begin[0] != '\\0')\n\t\t\t\tadd_history(lexptr_begin);\n\t\t\tefree(lexptr_begin);\n\t\t\tlexptr_begin = NULL;\n\t\t}\n\t\tif (arg_list != NULL) {\n\t\t\tfree_cmdarg(arg_list);\n\t\t\targ_list = NULL;\n\t\t}\n\t  }\n#line 1546 \"command.c\" /* yacc.c:1646  */\n    break;\n\n  case 5:\n#line 130 \"command.y\" /* yacc.c:1646  */\n    {\n\t\tif (errcount == 0 && cmd_idx >= 0) {\n\t\t\tFunc_cmd cmdfunc;\n\t\t\tbool terminate = false;\n\t\t\tCMDARG *args;\n\t\t\tint ctype = 0;\n\n\t\t\tctype = cmdtab[cmd_idx].type;\n\n\t\t\t/* a blank line repeats previous command\n\t\t\t * (list, next, nexti, step, stepi and continue without arguments).\n\t\t\t * save the index in the command table; used in yylex\n\t\t\t */\n\t\t\tif ((ctype == D_list\n\t\t\t\t\t|| ctype == D_next\n\t\t\t\t\t|| ctype == D_step\n\t\t\t\t\t|| ctype == D_nexti\n\t\t\t\t\t|| ctype == D_stepi\n\t\t\t\t\t|| ctype == D_continue)\n\t\t\t\t&& arg_list == NULL\n\t\t\t\t&& ! in_commands\n\t\t\t\t&& input_from_tty\n\t\t\t)\n\t\t\t\trepeat_idx = cmd_idx;\n\t\t\telse\n\t\t\t\trepeat_idx = -1;\n\n\t\t\t/* call the command handler; reset the globals arg_list, cmd_idx,\n\t\t\t * since this handler could invoke yyparse again.\n\t\t\t * call do_commands for the list of commands in `commands';\n\t\t\t * arg_list isn't freed on return.\n\t\t\t */\n\n\t\t\tcmdfunc = cmdtab[cmd_idx].cf_ptr;\n\t\t\tif (in_commands)\n\t\t\t\tcmdfunc = do_commands;\n\t\t\tcmd_idx = -1;\n\t\t\twant_nodeval = false;\n\n\t\t\targs = arg_list;\n\t\t\targ_list = NULL;\n\n\t\t\tterminate = (*cmdfunc)(args, ctype);\n\t\t\tif (! in_commands || ctype == D_commands)\n\t\t\t\tfree_cmdarg(args);\n\t\t\tif (terminate)\n\t\t\t\tYYACCEPT;\n\t\t}\n\t  }\n#line 1600 \"command.c\" /* yacc.c:1646  */\n    break;\n\n  case 6:\n#line 180 \"command.y\" /* yacc.c:1646  */\n    {\n\t\tyyerrok;\n\t  }\n#line 1608 \"command.c\" /* yacc.c:1646  */\n    break;\n\n  case 22:\n#line 214 \"command.y\" /* yacc.c:1646  */\n    { want_nodeval = true; }\n#line 1614 \"command.c\" /* yacc.c:1646  */\n    break;\n\n  case 23:\n#line 219 \"command.y\" /* yacc.c:1646  */\n    {\n\t\tif (errcount == 0) {\n\t\t\t/* don't free arg_list;\tpassed on to statement_list\n\t\t\t * non-terminal (empty rule action). See below.\n\t\t\t */\n\t\t\tif (input_from_tty) {\n\t\t\t\tdbg_prompt = eval_prompt;\n\t\t\t\tfprintf(out_fp,\n\t\t_(\"Type (g)awk statement(s). End with the command \\\"end\\\"\\n\"));\n\t\t\t\trl_inhibit_completion = 1;\n\t\t\t}\n\t\t\tcmd_idx = -1;\n\t\t\tin_eval = true;\n\t\t}\n\t  }\n#line 1634 \"command.c\" /* yacc.c:1646  */\n    break;\n\n  case 24:\n#line 238 \"command.y\" /* yacc.c:1646  */\n    {\n\t\t(yyval) = append_statement(arg_list, (char *) start_EVAL);\n\t\tif (read_a_line == read_commands_string)\t/* unserializing 'eval' in 'commands' */\n\t\t\t(yyval)->a_string[0] = '\\0';\n\t\tfree_cmdarg(arg_list);\n\t\targ_list = NULL;\n\t  }\n#line 1646 \"command.c\" /* yacc.c:1646  */\n    break;\n\n  case 25:\n#line 245 \"command.y\" /* yacc.c:1646  */\n    { (yyval) = append_statement((yyvsp[-1]), lexptr_begin); }\n#line 1652 \"command.c\" /* yacc.c:1646  */\n    break;\n\n  case 26:\n#line 246 \"command.y\" /* yacc.c:1646  */\n    {\n\t\t(yyval) = (yyvsp[-1]);\n\t  }\n#line 1660 \"command.c\" /* yacc.c:1646  */\n    break;\n\n  case 27:\n#line 253 \"command.y\" /* yacc.c:1646  */\n    {\n\t\targ_list = append_statement((yyvsp[-1]), (char *) end_EVAL);\n\t\tif (read_a_line == read_commands_string) {\t/* unserializing 'eval' in 'commands' */\n\t\t\tchar *str = arg_list->a_string;\n\t\t\tsize_t len = strlen(str);\n\t\t\tassert(len > 2 && str[len - 2] == '}');\n\t\t\tstr[len - 2] = '\\0';\n\t\t}\n\t\tif (input_from_tty) {\n\t\t\tdbg_prompt = in_commands ? commands_prompt : dgawk_prompt;\n\t\t\trl_inhibit_completion = 0;\n\t\t}\n\t\tcmd_idx = find_command(\"eval\", 4);\n\t\tin_eval = false;\n\t  }\n#line 1680 \"command.c\" /* yacc.c:1646  */\n    break;\n\n  case 28:\n#line 269 \"command.y\" /* yacc.c:1646  */\n    {\n\t\tNODE *n;\n\t\tCMDARG *arg;\n\t\tn = (yyvsp[0])->a_node;\n\t\targ = append_statement(NULL, (char *) start_EVAL);\n\t\t(void) append_statement(arg, n->stptr);\n\t\t(void) append_statement(arg, (char *) end_EVAL);\n\t\tfree_cmdarg(arg_list);\n\t\targ_list = arg;\n\t  }\n#line 1695 \"command.c\" /* yacc.c:1646  */\n    break;\n\n  case 34:\n#line 288 \"command.y\" /* yacc.c:1646  */\n    {\n\t\tif (cmdtab[cmd_idx].class == D_FRAME\n\t\t\t\t&& (yyvsp[0]) != NULL && (yyvsp[0])->a_int < 0)\n\t\t\tyyerror(_(\"invalid frame number: %d\"), (yyvsp[0])->a_int);\n\t  }\n#line 1705 \"command.c\" /* yacc.c:1646  */\n    break;\n\n  case 35:\n#line 294 \"command.y\" /* yacc.c:1646  */\n    {\n\t\tint idx = find_argument((yyvsp[0]));\n\t\tif (idx < 0)\n\t\t\tyyerror(_(\"info: invalid option - \\\"%s\\\"\"), (yyvsp[0])->a_string);\n\t\telse {\n\t\t\tefree((yyvsp[0])->a_string);\n\t\t\t(yyvsp[0])->a_string = NULL;\n\t\t\t(yyvsp[0])->type = D_argument;\n\t\t\t(yyvsp[0])->a_argument = argtab[idx].value;\n\t\t}\n\t  }\n#line 1721 \"command.c\" /* yacc.c:1646  */\n    break;\n\n  case 38:\n#line 307 \"command.y\" /* yacc.c:1646  */\n    { want_nodeval = true; }\n#line 1727 \"command.c\" /* yacc.c:1646  */\n    break;\n\n  case 40:\n#line 308 \"command.y\" /* yacc.c:1646  */\n    { want_nodeval = true; }\n#line 1733 \"command.c\" /* yacc.c:1646  */\n    break;\n\n  case 46:\n#line 313 \"command.y\" /* yacc.c:1646  */\n    { want_nodeval = true; }\n#line 1739 \"command.c\" /* yacc.c:1646  */\n    break;\n\n  case 49:\n#line 315 \"command.y\" /* yacc.c:1646  */\n    { want_nodeval = true; }\n#line 1745 \"command.c\" /* yacc.c:1646  */\n    break;\n\n  case 51:\n#line 316 \"command.y\" /* yacc.c:1646  */\n    { want_nodeval = true; }\n#line 1751 \"command.c\" /* yacc.c:1646  */\n    break;\n\n  case 53:\n#line 317 \"command.y\" /* yacc.c:1646  */\n    { want_nodeval = true; }\n#line 1757 \"command.c\" /* yacc.c:1646  */\n    break;\n\n  case 57:\n#line 321 \"command.y\" /* yacc.c:1646  */\n    {\n\t\tif (in_cmd_src((yyvsp[0])->a_string))\n\t\t\tyyerror(_(\"source \\\"%s\\\": already sourced.\"), (yyvsp[0])->a_string);\n\t  }\n#line 1766 \"command.c\" /* yacc.c:1646  */\n    break;\n\n  case 58:\n#line 326 \"command.y\" /* yacc.c:1646  */\n    {\n\t\tif (! input_from_tty)\n\t\t\tyyerror(_(\"save \\\"%s\\\": command not permitted.\"), (yyvsp[0])->a_string);\n\t  }\n#line 1775 \"command.c\" /* yacc.c:1646  */\n    break;\n\n  case 59:\n#line 331 \"command.y\" /* yacc.c:1646  */\n    {\n\t\tint type = 0;\n\t\tint num;\n\n\t\tif ((yyvsp[0]) != NULL)\n\t\t\tnum = (yyvsp[0])->a_int;\n\n\t\tif (errcount != 0)\n\t\t\t;\n\t\telse if (in_commands)\n\t\t\tyyerror(_(\"Can't use command `commands' for breakpoint/watchpoint commands\"));\n\t\telse if ((yyvsp[0]) == NULL &&  ! (type = has_break_or_watch_point(&num, true)))\n\t\t\tyyerror(_(\"no breakpoint/watchpoint has been set yet\"));\n\t\telse if ((yyvsp[0]) != NULL && ! (type = has_break_or_watch_point(&num, false)))\n\t\t\tyyerror(_(\"invalid breakpoint/watchpoint number\"));\n\t\tif (type) {\n\t\t\tin_commands = true;\n\t\t\tif (input_from_tty) {\n\t\t\t\tdbg_prompt = commands_prompt;\n\t\t\t\tfprintf(out_fp, _(\"Type commands for when %s %d is hit, one per line.\\n\"),\n\t\t\t\t\t\t\t\t(type == D_break) ? \"breakpoint\" : \"watchpoint\", num);\n\t\t\t\tfprintf(out_fp, _(\"End with the command \\\"end\\\"\\n\"));\n\t\t\t}\n\t\t}\n\t  }\n#line 1805 \"command.c\" /* yacc.c:1646  */\n    break;\n\n  case 60:\n#line 357 \"command.y\" /* yacc.c:1646  */\n    {\n\t\tif (! in_commands)\n\t\t\tyyerror(_(\"`end' valid only in command `commands' or `eval'\"));\n\t\telse {\n\t\t\tif (input_from_tty)\n\t\t\t\tdbg_prompt = dgawk_prompt;\n\t\t\tin_commands = false;\n\t\t}\n\t  }\n#line 1819 \"command.c\" /* yacc.c:1646  */\n    break;\n\n  case 61:\n#line 367 \"command.y\" /* yacc.c:1646  */\n    {\n\t\tif (! in_commands)\n\t\t\tyyerror(_(\"`silent' valid only in command `commands'\"));\n\t  }\n#line 1828 \"command.c\" /* yacc.c:1646  */\n    break;\n\n  case 62:\n#line 372 \"command.y\" /* yacc.c:1646  */\n    {\n\t\tint idx = find_argument((yyvsp[0]));\n\t\tif (idx < 0)\n\t\t\tyyerror(_(\"trace: invalid option - \\\"%s\\\"\"), (yyvsp[0])->a_string);\n\t\telse {\n\t\t\tefree((yyvsp[0])->a_string);\n\t\t\t(yyvsp[0])->a_string = NULL;\n\t\t\t(yyvsp[0])->type = D_argument;\n\t\t\t(yyvsp[0])->a_argument = argtab[idx].value;\n\t\t}\n\t  }\n#line 1844 \"command.c\" /* yacc.c:1646  */\n    break;\n\n  case 63:\n#line 383 \"command.y\" /* yacc.c:1646  */\n    { want_nodeval = true; }\n#line 1850 \"command.c\" /* yacc.c:1646  */\n    break;\n\n  case 64:\n#line 384 \"command.y\" /* yacc.c:1646  */\n    {\n\t\tint type;\n\t\tint num = (yyvsp[-2])->a_int;\n\t\ttype = has_break_or_watch_point(&num, false);\n\t\tif (! type)\n\t\t\tyyerror(_(\"condition: invalid breakpoint/watchpoint number\"));\n\t  }\n#line 1862 \"command.c\" /* yacc.c:1646  */\n    break;\n\n  case 65:\n#line 392 \"command.y\" /* yacc.c:1646  */\n    {\n\t\tif (in_commands) {\n\t\t\t/* Prepend command 'eval' to argument list */\n\t\t\tCMDARG *arg;\n\t\t\targ = mk_cmdarg(D_string);\n\t\t\targ->a_string = estrdup(\"eval\", 4);\n\t\t\targ->next = arg_list;\n\t\t\targ_list = arg;\n\t\t}\n\t  }\n#line 1877 \"command.c\" /* yacc.c:1646  */\n    break;\n\n  case 66:\n#line 406 \"command.y\" /* yacc.c:1646  */\n    {\n\t\tif ((yyvsp[0]) != NULL) {\n\t\t\tNODE *n = (yyvsp[0])->a_node;\n\t\t\t(yyvsp[0])->type = D_string;\n\t\t\t(yyvsp[0])->a_string = n->stptr;\n\t\t\tfreenode(n);\n\t\t}\n\t\t(yyval) = (yyvsp[0]);\n\t  }\n#line 1891 \"command.c\" /* yacc.c:1646  */\n    break;\n\n  case 68:\n#line 420 \"command.y\" /* yacc.c:1646  */\n    {\t(yyval) = NULL; }\n#line 1897 \"command.c\" /* yacc.c:1646  */\n    break;\n\n  case 69:\n#line 425 \"command.y\" /* yacc.c:1646  */\n    { (yyval) = NULL; }\n#line 1903 \"command.c\" /* yacc.c:1646  */\n    break;\n\n  case 74:\n#line 434 \"command.y\" /* yacc.c:1646  */\n    { (yyval) = NULL; }\n#line 1909 \"command.c\" /* yacc.c:1646  */\n    break;\n\n  case 75:\n#line 439 \"command.y\" /* yacc.c:1646  */\n    { (yyval) = NULL; }\n#line 1915 \"command.c\" /* yacc.c:1646  */\n    break;\n\n  case 77:\n#line 442 \"command.y\" /* yacc.c:1646  */\n    { (yyval) = NULL; }\n#line 1921 \"command.c\" /* yacc.c:1646  */\n    break;\n\n  case 78:\n#line 447 \"command.y\" /* yacc.c:1646  */\n    {\n\t\tNODE *n;\n\t\tn = (yyvsp[0])->a_node;\n\t\tif ((n->flags & STRING) == 0)\n\t\t\tyyerror(_(\"argument not a string\"));\n\t  }\n#line 1932 \"command.c\" /* yacc.c:1646  */\n    break;\n\n  case 79:\n#line 457 \"command.y\" /* yacc.c:1646  */\n    { (yyval) = NULL; }\n#line 1938 \"command.c\" /* yacc.c:1646  */\n    break;\n\n  case 80:\n#line 459 \"command.y\" /* yacc.c:1646  */\n    {\n\t\tif (find_option((yyvsp[0])->a_string) < 0)\n\t\t\tyyerror(_(\"option: invalid parameter - \\\"%s\\\"\"), (yyvsp[0])->a_string);\n \t  }\n#line 1947 \"command.c\" /* yacc.c:1646  */\n    break;\n\n  case 81:\n#line 464 \"command.y\" /* yacc.c:1646  */\n    {\n\t\tif (find_option((yyvsp[-2])->a_string) < 0)\n\t\t\tyyerror(_(\"option: invalid parameter - \\\"%s\\\"\"), (yyvsp[-2])->a_string);\n \t  }\n#line 1956 \"command.c\" /* yacc.c:1646  */\n    break;\n\n  case 82:\n#line 472 \"command.y\" /* yacc.c:1646  */\n    {\n\t\tNODE *n;\n\t\tn = lookup((yyvsp[0])->a_string);\n\t\tif (n == NULL || n->type != Node_func)\n\t\t\tyyerror(_(\"no such function - \\\"%s\\\"\"), (yyvsp[0])->a_string);\n\t\telse {\n\t\t\t(yyvsp[0])->type = D_func;\n\t\t\tefree((yyvsp[0])->a_string);\n\t\t\t(yyvsp[0])->a_string = NULL;\n\t\t\t(yyvsp[0])->a_node = n;\n\t\t}\n\t  }\n#line 1973 \"command.c\" /* yacc.c:1646  */\n    break;\n\n  case 83:\n#line 488 \"command.y\" /* yacc.c:1646  */\n    { (yyval) = NULL; }\n#line 1979 \"command.c\" /* yacc.c:1646  */\n    break;\n\n  case 88:\n#line 497 \"command.y\" /* yacc.c:1646  */\n    { (yyval) = NULL; }\n#line 1985 \"command.c\" /* yacc.c:1646  */\n    break;\n\n  case 89:\n#line 498 \"command.y\" /* yacc.c:1646  */\n    { want_nodeval = true; }\n#line 1991 \"command.c\" /* yacc.c:1646  */\n    break;\n\n  case 92:\n#line 500 \"command.y\" /* yacc.c:1646  */\n    { want_nodeval = true; }\n#line 1997 \"command.c\" /* yacc.c:1646  */\n    break;\n\n  case 95:\n#line 506 \"command.y\" /* yacc.c:1646  */\n    { (yyval) = NULL; }\n#line 2003 \"command.c\" /* yacc.c:1646  */\n    break;\n\n  case 97:\n#line 512 \"command.y\" /* yacc.c:1646  */\n    { (yyval) = NULL; }\n#line 2009 \"command.c\" /* yacc.c:1646  */\n    break;\n\n  case 99:\n#line 518 \"command.y\" /* yacc.c:1646  */\n    { (yyval) = NULL; }\n#line 2015 \"command.c\" /* yacc.c:1646  */\n    break;\n\n  case 104:\n#line 530 \"command.y\" /* yacc.c:1646  */\n    {\n\t\tint idx = find_argument((yyvsp[-1]));\n\t\tif (idx < 0)\n\t\t\tyyerror(_(\"enable: invalid option - \\\"%s\\\"\"), (yyvsp[-1])->a_string);\n\t\telse {\n\t\t\tefree((yyvsp[-1])->a_string);\n\t\t\t(yyvsp[-1])->a_string = NULL;\n\t\t\t(yyvsp[-1])->type = D_argument;\n\t\t\t(yyvsp[-1])->a_argument = argtab[idx].value;\n\t\t}\n\t  }\n#line 2031 \"command.c\" /* yacc.c:1646  */\n    break;\n\n  case 106:\n#line 546 \"command.y\" /* yacc.c:1646  */\n    {\n\t\t(yyvsp[0])->type = D_array;\t/* dump all items */\n\t\t(yyvsp[0])->a_count = 0;\n\t  }\n#line 2040 \"command.c\" /* yacc.c:1646  */\n    break;\n\n  case 107:\n#line 551 \"command.y\" /* yacc.c:1646  */\n    {\n\t\t(yyvsp[-1])->type = D_array;\n\t\t(yyvsp[-1])->a_count = num_dim;\n\t  }\n#line 2049 \"command.c\" /* yacc.c:1646  */\n    break;\n\n  case 117:\n#line 577 \"command.y\" /* yacc.c:1646  */\n    { (yyval) = NULL; }\n#line 2055 \"command.c\" /* yacc.c:1646  */\n    break;\n\n  case 118:\n#line 579 \"command.y\" /* yacc.c:1646  */\n    { (yyval) = NULL; }\n#line 2061 \"command.c\" /* yacc.c:1646  */\n    break;\n\n  case 119:\n#line 581 \"command.y\" /* yacc.c:1646  */\n    {\n\t\tCMDARG *a;\n\t\ta = mk_cmdarg(D_int);\n\t\ta->a_int = -1;\n\t\tappend_cmdarg(a);\n\t  }\n#line 2072 \"command.c\" /* yacc.c:1646  */\n    break;\n\n  case 126:\n#line 597 \"command.y\" /* yacc.c:1646  */\n    {\n\t\tif ((yyvsp[-2])->a_int > (yyvsp[0])->a_int)\n\t\t\tyyerror(_(\"invalid range specification: %d - %d\"),\n\t\t\t\t(yyvsp[-2])->a_int, (yyvsp[0])->a_int);\n\t\telse\n\t\t\t(yyvsp[-2])->type = D_range;\n\t\t(yyval) = (yyvsp[-2]);\n\t  }\n#line 2085 \"command.c\" /* yacc.c:1646  */\n    break;\n\n  case 127:\n#line 609 \"command.y\" /* yacc.c:1646  */\n    { (yyval) = NULL; }\n#line 2091 \"command.c\" /* yacc.c:1646  */\n    break;\n\n  case 134:\n#line 623 \"command.y\" /* yacc.c:1646  */\n    { (yyval) = (yyvsp[0]); }\n#line 2097 \"command.c\" /* yacc.c:1646  */\n    break;\n\n  case 135:\n#line 625 \"command.y\" /* yacc.c:1646  */\n    { (yyval) = (yyvsp[-2]); }\n#line 2103 \"command.c\" /* yacc.c:1646  */\n    break;\n\n  case 137:\n#line 631 \"command.y\" /* yacc.c:1646  */\n    {\n\t\tCMDARG *a;\n\t\tNODE *subs;\n\t\tint count = 0;\n\n\t\tfor (a = (yyvsp[-1]); a != NULL; a = a->next)\n\t\t\tcount++;\n\t\tsubs = concat_args((yyvsp[-1]), count);\n\t\tfree_cmdarg((yyvsp[-1])->next);\n\t\t(yyvsp[-1])->next = NULL;\n\t\t(yyvsp[-1])->type = D_node;\n\t\t(yyvsp[-1])->a_node = subs;\n\t\t(yyval) = (yyvsp[-1]);\n\t  }\n#line 2122 \"command.c\" /* yacc.c:1646  */\n    break;\n\n  case 139:\n#line 650 \"command.y\" /* yacc.c:1646  */\n    { (yyval) = (yyvsp[0]); num_dim = 1; }\n#line 2128 \"command.c\" /* yacc.c:1646  */\n    break;\n\n  case 140:\n#line 652 \"command.y\" /* yacc.c:1646  */\n    {\t(yyval) = (yyvsp[-1]); num_dim++; }\n#line 2134 \"command.c\" /* yacc.c:1646  */\n    break;\n\n  case 142:\n#line 658 \"command.y\" /* yacc.c:1646  */\n    {\n\t\tNODE *n = (yyvsp[0])->a_node;\n\t\tif ((n->flags & NUMBER) == 0)\n\t\t\tyyerror(_(\"non-numeric value for field number\"));\n\t\telse\n\t\t\t(yyvsp[0])->type = D_field;\n\t\t(yyval) = (yyvsp[0]);\n\t  }\n#line 2147 \"command.c\" /* yacc.c:1646  */\n    break;\n\n  case 143:\n#line 667 \"command.y\" /* yacc.c:1646  */\n    {\n\t\t/* a_string is array name, a_count is dimension count */\n\t\t(yyvsp[-1])->type = D_subscript;\n\t\t(yyvsp[-1])->a_count = num_dim;\n\t\t(yyval) = (yyvsp[-1]);\n\t  }\n#line 2158 \"command.c\" /* yacc.c:1646  */\n    break;\n\n  case 144:\n#line 677 \"command.y\" /* yacc.c:1646  */\n    { (yyval) = (yyvsp[0]); }\n#line 2164 \"command.c\" /* yacc.c:1646  */\n    break;\n\n  case 145:\n#line 679 \"command.y\" /* yacc.c:1646  */\n    {\n\t\tNODE *n = (yyvsp[0])->a_node;\n\t\tif ((n->flags & NUMBER) == 0)\n\t\t\tyyerror(_(\"non-numeric value found, numeric expected\"));\n\t\t(yyval) = (yyvsp[0]);\n\t  }\n#line 2175 \"command.c\" /* yacc.c:1646  */\n    break;\n\n  case 146:\n#line 686 \"command.y\" /* yacc.c:1646  */\n    {\n\t\tNODE *n = (yyvsp[0])->a_node;\n\t\tif ((n->flags & NUMBER) == 0)\n\t\t\tyyerror(_(\"non-numeric value found, numeric expected\"));\n\t\telse\n\t\t\tnegate_num(n);\n\t\t(yyval) = (yyvsp[0]);\n\t  }\n#line 2188 \"command.c\" /* yacc.c:1646  */\n    break;\n\n  case 147:\n#line 698 \"command.y\" /* yacc.c:1646  */\n    { (yyval) = NULL; }\n#line 2194 \"command.c\" /* yacc.c:1646  */\n    break;\n\n  case 148:\n#line 700 \"command.y\" /* yacc.c:1646  */\n    { (yyval) = (yyvsp[0]); }\n#line 2200 \"command.c\" /* yacc.c:1646  */\n    break;\n\n  case 149:\n#line 705 \"command.y\" /* yacc.c:1646  */\n    { (yyval) = NULL; }\n#line 2206 \"command.c\" /* yacc.c:1646  */\n    break;\n\n  case 150:\n#line 707 \"command.y\" /* yacc.c:1646  */\n    { (yyval) = (yyvsp[0]); }\n#line 2212 \"command.c\" /* yacc.c:1646  */\n    break;\n\n  case 151:\n#line 712 \"command.y\" /* yacc.c:1646  */\n    {\n\t\tif ((yyvsp[0])->a_int == 0)\n\t\t\tyyerror(_(\"non-zero integer value\"));\n\t\t(yyval) = (yyvsp[0]);\n\t  }\n#line 2222 \"command.c\" /* yacc.c:1646  */\n    break;\n\n  case 152:\n#line 718 \"command.y\" /* yacc.c:1646  */\n    {\n\t\tif ((yyvsp[0])->a_int == 0)\n\t\t\tyyerror(_(\"non-zero integer value\"));\n\t\t(yyval) = (yyvsp[0]);\n\t  }\n#line 2232 \"command.c\" /* yacc.c:1646  */\n    break;\n\n  case 153:\n#line 727 \"command.y\" /* yacc.c:1646  */\n    { (yyval) = (yyvsp[0]); }\n#line 2238 \"command.c\" /* yacc.c:1646  */\n    break;\n\n  case 154:\n#line 729 \"command.y\" /* yacc.c:1646  */\n    { (yyval) = (yyvsp[0]); }\n#line 2244 \"command.c\" /* yacc.c:1646  */\n    break;\n\n  case 155:\n#line 731 \"command.y\" /* yacc.c:1646  */\n    {\n\t\t(yyvsp[0])->a_int = - (yyvsp[0])->a_int;\n\t\t(yyval) = (yyvsp[0]);\n\t  }\n#line 2253 \"command.c\" /* yacc.c:1646  */\n    break;\n\n  case 156:\n#line 739 \"command.y\" /* yacc.c:1646  */\n    {\n\t\tif (lexptr_begin != NULL) {\n\t\t\tif (input_from_tty && lexptr_begin[0] != '\\0')\n\t\t\t\tadd_history(lexptr_begin);\n\t\t\tefree(lexptr_begin);\n\t\t\tlexptr_begin = NULL;\n\t\t}\n\t  }\n#line 2266 \"command.c\" /* yacc.c:1646  */\n    break;\n\n\n#line 2270 \"command.c\" /* yacc.c:1646  */\n      default: break;\n    }\n  /* User semantic actions sometimes alter yychar, and that requires\n     that yytoken be updated with the new translation.  We take the\n     approach of translating immediately before every use of yytoken.\n     One alternative is translating here after every semantic action,\n     but that translation would be missed if the semantic action invokes\n     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or\n     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an\n     incorrect destructor might then be invoked immediately.  In the\n     case of YYERROR or YYBACKUP, subsequent parser actions might lead\n     to an incorrect destructor call or verbose syntax error message\n     before the lookahead is translated.  */\n  YY_SYMBOL_PRINT (\"-> $$ =\", yyr1[yyn], &yyval, &yyloc);\n\n  YYPOPSTACK (yylen);\n  yylen = 0;\n  YY_STACK_PRINT (yyss, yyssp);\n\n  *++yyvsp = yyval;\n\n  /* Now 'shift' the result of the reduction.  Determine what state\n     that goes to, based on the state we popped back to and the rule\n     number reduced by.  */\n\n  yyn = yyr1[yyn];\n\n  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;\n  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)\n    yystate = yytable[yystate];\n  else\n    yystate = yydefgoto[yyn - YYNTOKENS];\n\n  goto yynewstate;\n\n\n/*--------------------------------------.\n| yyerrlab -- here on detecting error.  |\n`--------------------------------------*/\nyyerrlab:\n  /* Make sure we have latest lookahead translation.  See comments at\n     user semantic actions for why this is necessary.  */\n  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);\n\n  /* If not already recovering from an error, report this error.  */\n  if (!yyerrstatus)\n    {\n      ++yynerrs;\n#if ! YYERROR_VERBOSE\n      yyerror (YY_(\"syntax error\"));\n#else\n# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \\\n                                        yyssp, yytoken)\n      {\n        char const *yymsgp = YY_(\"syntax error\");\n        int yysyntax_error_status;\n        yysyntax_error_status = YYSYNTAX_ERROR;\n        if (yysyntax_error_status == 0)\n          yymsgp = yymsg;\n        else if (yysyntax_error_status == 1)\n          {\n            if (yymsg != yymsgbuf)\n              YYSTACK_FREE (yymsg);\n            yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);\n            if (!yymsg)\n              {\n                yymsg = yymsgbuf;\n                yymsg_alloc = sizeof yymsgbuf;\n                yysyntax_error_status = 2;\n              }\n            else\n              {\n                yysyntax_error_status = YYSYNTAX_ERROR;\n                yymsgp = yymsg;\n              }\n          }\n        yyerror (yymsgp);\n        if (yysyntax_error_status == 2)\n          goto yyexhaustedlab;\n      }\n# undef YYSYNTAX_ERROR\n#endif\n    }\n\n\n\n  if (yyerrstatus == 3)\n    {\n      /* If just tried and failed to reuse lookahead token after an\n         error, discard it.  */\n\n      if (yychar <= YYEOF)\n        {\n          /* Return failure if at end of input.  */\n          if (yychar == YYEOF)\n            YYABORT;\n        }\n      else\n        {\n          yydestruct (\"Error: discarding\",\n                      yytoken, &yylval);\n          yychar = YYEMPTY;\n        }\n    }\n\n  /* Else will try to reuse lookahead token after shifting the error\n     token.  */\n  goto yyerrlab1;\n\n\n/*---------------------------------------------------.\n| yyerrorlab -- error raised explicitly by YYERROR.  |\n`---------------------------------------------------*/\nyyerrorlab:\n\n  /* Pacify compilers like GCC when the user code never invokes\n     YYERROR and the label yyerrorlab therefore never appears in user\n     code.  */\n  if (/*CONSTCOND*/ 0)\n     goto yyerrorlab;\n\n  /* Do not reclaim the symbols of the rule whose action triggered\n     this YYERROR.  */\n  YYPOPSTACK (yylen);\n  yylen = 0;\n  YY_STACK_PRINT (yyss, yyssp);\n  yystate = *yyssp;\n  goto yyerrlab1;\n\n\n/*-------------------------------------------------------------.\n| yyerrlab1 -- common code for both syntax error and YYERROR.  |\n`-------------------------------------------------------------*/\nyyerrlab1:\n  yyerrstatus = 3;      /* Each real token shifted decrements this.  */\n\n  for (;;)\n    {\n      yyn = yypact[yystate];\n      if (!yypact_value_is_default (yyn))\n        {\n          yyn += YYTERROR;\n          if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)\n            {\n              yyn = yytable[yyn];\n              if (0 < yyn)\n                break;\n            }\n        }\n\n      /* Pop the current state because it cannot handle the error token.  */\n      if (yyssp == yyss)\n        YYABORT;\n\n\n      yydestruct (\"Error: popping\",\n                  yystos[yystate], yyvsp);\n      YYPOPSTACK (1);\n      yystate = *yyssp;\n      YY_STACK_PRINT (yyss, yyssp);\n    }\n\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  *++yyvsp = yylval;\n  YY_IGNORE_MAYBE_UNINITIALIZED_END\n\n\n  /* Shift the error token.  */\n  YY_SYMBOL_PRINT (\"Shifting\", yystos[yyn], yyvsp, yylsp);\n\n  yystate = yyn;\n  goto yynewstate;\n\n\n/*-------------------------------------.\n| yyacceptlab -- YYACCEPT comes here.  |\n`-------------------------------------*/\nyyacceptlab:\n  yyresult = 0;\n  goto yyreturn;\n\n/*-----------------------------------.\n| yyabortlab -- YYABORT comes here.  |\n`-----------------------------------*/\nyyabortlab:\n  yyresult = 1;\n  goto yyreturn;\n\n#if !defined yyoverflow || YYERROR_VERBOSE\n/*-------------------------------------------------.\n| yyexhaustedlab -- memory exhaustion comes here.  |\n`-------------------------------------------------*/\nyyexhaustedlab:\n  yyerror (YY_(\"memory exhausted\"));\n  yyresult = 2;\n  /* Fall through.  */\n#endif\n\nyyreturn:\n  if (yychar != YYEMPTY)\n    {\n      /* Make sure we have latest lookahead translation.  See comments at\n         user semantic actions for why this is necessary.  */\n      yytoken = YYTRANSLATE (yychar);\n      yydestruct (\"Cleanup: discarding lookahead\",\n                  yytoken, &yylval);\n    }\n  /* Do not reclaim the symbols of the rule whose action triggered\n     this YYABORT or YYACCEPT.  */\n  YYPOPSTACK (yylen);\n  YY_STACK_PRINT (yyss, yyssp);\n  while (yyssp != yyss)\n    {\n      yydestruct (\"Cleanup: popping\",\n                  yystos[*yyssp], yyvsp);\n      YYPOPSTACK (1);\n    }\n#ifndef yyoverflow\n  if (yyss != yyssa)\n    YYSTACK_FREE (yyss);\n#endif\n#if YYERROR_VERBOSE\n  if (yymsg != yymsgbuf)\n    YYSTACK_FREE (yymsg);\n#endif\n  return yyresult;\n}",
      "lines": 1203,
      "depth": 20,
      "decorators": [
        "int"
      ]
    },
    "append_statement": {
      "start_point": [
        2502,
        0
      ],
      "end_point": [
        2560,
        1
      ],
      "content": "static CMDARG *\nappend_statement(CMDARG *stmt_list, char *stmt)\n{\n\tCMDARG *a, *arg;\n\tchar *s;\n\tint len, slen, ssize;\n\n#define EVALSIZE\t512\n\n\tif (stmt == start_EVAL) {\n\t\tlen = sizeof(start_EVAL);\n\t\tfor (a = stmt_list; a != NULL; a = a->next)\n\t\t\tlen += strlen(a->a_string) + 1;\t/* 1 for ',' */\n\t\tlen += EVALSIZE;\n\n\t\temalloc(s, char *, (len + 1) * sizeof(char), \"append_statement\");\n\t\targ = mk_cmdarg(D_string);\n\t\targ->a_string = s;\n\t\targ->a_count = len;\t/* kludge */\n\n\t\tslen = sizeof(\"function @eval(\") - 1;\n\t\tmemcpy(s, start_EVAL, slen);\n\n\t\tfor (a = stmt_list; a != NULL; a = a->next) {\n\t\t\tlen = strlen(a->a_string);\n\t\t\tmemcpy(s + slen, a->a_string, len);\n\t\t\tslen += len;\n\t\t\tif (a->next != NULL)\n\t\t\t\ts[slen++] = ',';\n\t\t}\n\t\ts[slen++] = ')';\n\t\ts[slen++] = '{';\n\t\ts[slen] = '\\0';\n\t\treturn arg;\n\t}\n\n\tlen = strlen(stmt) + 1;\t/* 1 for newline */\n\ts = stmt_list->a_string;\n\tslen = strlen(s);\n\tssize = stmt_list->a_count;\n\tif (len > ssize - slen) {\n\t\tssize = slen + len + EVALSIZE;\n\t\terealloc(s, char *, (ssize + 1) * sizeof(char), \"append_statement\");\n\t\tstmt_list->a_string = s;\n\t\tstmt_list->a_count = ssize;\n\t}\n\tmemcpy(s + slen, stmt, len);\n\tslen += len;\n\tif (slen >= 2 && s[slen - 2] != '\\n') {\n\t\ts[slen - 1] = '\\n';\n\t\ts[slen] = '\\0';\n\t}\n\n\tif (stmt == end_EVAL)\n\t\terealloc(stmt_list->a_string, char *, slen + 1, \"append_statement\");\n\treturn stmt_list;\n\n#undef EVALSIZE\n}",
      "lines": 59,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "CMDARG",
        "*\nappend_statement(CMDARG *stmt_list, char *stmt)",
        "*"
      ]
    },
    "get_command": {
      "start_point": [
        2679,
        0
      ],
      "end_point": [
        2688,
        1
      ],
      "content": "Func_cmd\nget_command(int ctype)\n{\n\tint i;\n\tfor (i = 0; cmdtab[i].name != NULL; i++) {\n\t\tif (cmdtab[i].type == ctype)\n\t\t\treturn cmdtab[i].cf_ptr;\n\t}\n\treturn (Func_cmd) 0;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "Func_cmd"
      ]
    },
    "get_command_name": {
      "start_point": [
        2692,
        0
      ],
      "end_point": [
        2701,
        1
      ],
      "content": "const char *\nget_command_name(int ctype)\n{\n\tint i;\n\tfor (i = 0; cmdtab[i].name != NULL; i++) {\n\t\tif (cmdtab[i].type == ctype)\n\t\t\treturn cmdtab[i].name;\n\t}\n\treturn NULL;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nget_command_name(int ctype)",
        "*"
      ]
    },
    "mk_cmdarg": {
      "start_point": [
        2705,
        0
      ],
      "end_point": [
        2712,
        1
      ],
      "content": "static CMDARG *\nmk_cmdarg(enum argtype type)\n{\n\tCMDARG *arg;\n\tezalloc(arg, CMDARG *, sizeof(CMDARG), \"mk_cmdarg\");\n\targ->type = type;\n\treturn arg;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "CMDARG",
        "*\nmk_cmdarg(enum argtype type)",
        "*"
      ]
    },
    "append_cmdarg": {
      "start_point": [
        2716,
        0
      ],
      "end_point": [
        2726,
        1
      ],
      "content": "static void\nappend_cmdarg(CMDARG *arg)\n{\n\tstatic CMDARG *savetail;\n\n\tif (arg_list == NULL)\n\t\targ_list = arg;\n\telse\n\t\tsavetail->next = arg;\n\tsavetail = arg;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "free_cmdarg": {
      "start_point": [
        2730,
        0
      ],
      "end_point": [
        2755,
        1
      ],
      "content": "void\nfree_cmdarg(CMDARG *list)\n{\n\tCMDARG *arg, *nexta;\n\n\tfor (arg = list; arg != NULL; arg = nexta) {\n\t\tnexta = arg->next;\n\n\t\tswitch (arg->type) {\n\t\tcase D_variable:\n\t\tcase D_subscript:\n\t\tcase D_array:\n\t\tcase D_string:\n\t\t\tif (arg->a_string != NULL)\n\t\t\t\tefree(arg->a_string);\n\t\t\tbreak;\n\t\tcase D_node:\n\t\tcase D_field:\n\t\t\tunref(arg->a_node);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tefree(arg);\n\t}\n}",
      "lines": 26,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "yyerror": {
      "start_point": [
        2759,
        0
      ],
      "end_point": [
        2770,
        1
      ],
      "content": "static void\nyyerror(const char *mesg, ...)\n{\n\tva_list args;\n\tva_start(args, mesg);\n\tfprintf(out_fp, _(\"error: \"));\n\tvfprintf(out_fp, mesg, args);\n\tfprintf(out_fp, \"\\n\");\n\tva_end(args);\n\terrcount++;\n\trepeat_idx = -1;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yylex": [
      {
        "start_point": [
          2777,
          0
        ],
        "end_point": [
          3054,
          1
        ],
        "content": "yylex_ebcdic(void)\n#else\nyylex(void)\n#endif\n{\n\tstatic char *lexptr = NULL;\n\tstatic char *lexend;\n\tint c;\n\tchar *tokstart;\n\tsize_t toklen;\n\n\tyylval = (CMDARG *) NULL;\n\n\tif (errcount > 0 && lexptr_begin == NULL) {\n\t\t/* fake a new line */\n\t\terrcount = 0;\n\t\treturn '\\n';\n\t}\n\n\tif (lexptr_begin == NULL) {\nagain:\n\t\tlexptr_begin = read_a_line(dbg_prompt);\n\t\tif (lexptr_begin == NULL) {\t/* EOF or error */\n\t\t\tif (get_eof_status() == EXIT_FATAL)\n\t\t\t\texit(EXIT_FATAL);\n\t\t\tif (get_eof_status() == EXIT_FAILURE) {\n\t\t\t\tstatic int seen_eof = 0;\n\n\t\t\t\t/* force a quit, and let do_quit (in debug.c) exit */\n\t\t\t\tif (! seen_eof) {\n\t\t\t\t\tif (errno != 0)\t{\n\t\t\t\t\t\tfprintf(stderr, _(\"can't read command (%s)\\n\"), strerror(errno));\n\t\t\t\t\t\texit_val = EXIT_FAILURE;\n\t\t\t\t\t} /* else\n\t\t\t\t\t\texit_val = EXIT_SUCCESS; */\n\n\t\t\t\t\tseen_eof = 1;\n\t\t\t\t\treturn '\\n';\t/* end current command if any */\n\t\t\t\t} else if (seen_eof++ == 1) {\n\t\t\t\t\tcmd_idx = find_command(\"quit\", 4);\n\t\t\t\t\treturn D_QUIT;\t/* 'quit' token */\n\t\t\t\t} else\n\t\t\t\t\treturn '\\n';\t/* end command 'quit' */\n\t\t\t}\n\t\t\tif (errno != 0)\n\t\t\t\td_error(_(\"can't read command (%s)\"), strerror(errno));\n\t\t\tif (pop_cmd_src() == 0)\n\t\t\t\tgoto again;\n\t\t\texit(EXIT_FATAL);\t/* shouldn't happen */\n\t\t}\n\n\t\tif (! in_commands && ! in_eval\t/* history expansion off in 'commands' and 'eval' */\n\t\t\t\t&& input_from_tty\n\t\t)\n\t\t\thistory_expand_line(&lexptr_begin);\n\n\t\tlexptr = lexptr_begin;\n\t\tlexend = lexptr + strlen(lexptr);\n\t\tif (*lexptr == '\\0'\t\t/* blank line */\n\t\t\t\t&& repeat_idx >= 0\n\t\t\t\t&& input_from_tty\n\t\t\t\t&& ! in_eval\n\t\t) {\n#ifdef HAVE_LIBREADLINE\n\t\t\tHIST_ENTRY *h;\n\t\t\th = previous_history();\n\t\t\tif (h != NULL)\n\t\t\t\tadd_history(h->line);\n#endif\n\t\t\tcmd_idx = repeat_idx;\n\t\t\treturn cmdtab[cmd_idx].class;\t/* repeat last command */\n\t\t}\n\t\trepeat_idx = -1;\n\t}\n\n\tc = *lexptr;\n\n\twhile (c == ' ' || c == '\\t')\n\t\tc = *++lexptr;\n\n\tif (! input_from_tty && c == '#')\n\t\treturn '\\n';\n\n\ttokstart = lexptr;\n\tif (lexptr >= lexend)\n\t\treturn '\\n';\n\n\tif (cmd_idx < 0) {\t/* need a command */\n\t\tif (c == '?' && tokstart[1] == '\\0'\t&& ! in_eval) {\n\t\t\tlexptr++;\n\t\t\tcmd_idx = find_command(\"help\", 4);\n\t\t\treturn D_HELP;\n\t\t}\n\n\t\twhile (c != '\\0' && c != ' ' && c != '\\t') {\n\t\t\tif (! is_alpha(c) && ! in_eval) {\n\t\t\t\tyyerror(_(\"invalid character in command\"));\n\t\t\t\treturn '\\n';\n\t\t\t}\n\t\t\tc = *++lexptr;\n\t\t}\n\n\t\ttoklen = lexptr - tokstart;\n\n\t\tif (in_eval) {\n\t\t\tif (toklen == 3\n\t\t\t\t\t&& tokstart[3] == '\\0'\n\t\t\t\t\t&& tokstart[0] == 'e'\n\t\t\t\t\t&& tokstart[1] == 'n'\n\t\t\t\t\t&& tokstart[2] == 'd'\n\t\t\t) {\n\t\t\t\tcmd_idx = find_command(tokstart, toklen);\n\t\t\t\treturn D_END;\n\t\t\t}\n\t\t\tlexptr = lexend;\n\t\t\treturn D_STATEMENT;\n\t\t}\n\n\t\tcmd_idx = find_command(tokstart, toklen);\n\t\tif (cmd_idx >= 0) {\n\t\t\tif (in_commands && cmdtab[cmd_idx].type != D_eval) {\n\t\t\t\t/* add the actual command string (lexptr_begin) to\n\t\t\t\t * arg_list; command string for 'eval' prepended to the arg_list\n\t\t\t\t * in the grammer above (see eval_cmd non-terminal).\n\t\t\t\t */\n\t\t\t\tCMDARG *arg;\n\t\t\t\targ = mk_cmdarg(D_string);\n\t\t\t\targ->a_string = estrdup(lexptr_begin, lexend - lexptr_begin);\n\t\t\t\tappend_cmdarg(arg);\n\t\t\t}\n\t\t\treturn cmdtab[cmd_idx].class;\n\t\t} else {\n\t\t\tyyerror(_(\"unknown command - \\\"%.*s\\\", try help\"), toklen, tokstart);\n\t\t\treturn '\\n';\n\t\t}\n\t}\n\n\tc = *lexptr;\n\n\tif (cmdtab[cmd_idx].type == D_option) {\n\t\tif (c == '=')\n\t\t\treturn *lexptr++;\n\t} else if (c == '-' || c == '+' || c == ':' || c == '|')\n\t\treturn *lexptr++;\n\n\tif (c == '\"') {\n\t\tchar *str, *p;\n\t\tint flags = ALREADY_MALLOCED;\n\t\tbool esc_seen = false;\n\n\t\ttoklen = lexend - lexptr;\n\t\temalloc(str, char *, toklen + 1, \"yylex\");\n\t\tp = str;\n\n\t\twhile ((c = *++lexptr) != '\"') {\n\t\t\tif (lexptr == lexend) {\nerr:\n\t\t\t\tefree(str);\n\t\t\t\tyyerror(_(\"unterminated string\"));\n\t\t\t\treturn '\\n';\n\t\t\t}\n\t\t\tif (c == '\\\\') {\n\t\t\t\tc = *++lexptr;\n\t\t\t\tesc_seen = true;\n\t\t\t\tif (want_nodeval || c != '\"')\n\t\t\t\t\t*p++ = '\\\\';\n\t\t\t}\n\t\t\tif (lexptr == lexend)\n\t\t\t\tgoto err;\n\t\t\t*p++ = c;\n\t\t}\n\t\tlexptr++;\n\t\t*p = '\\0';\n\n\t\tif (! want_nodeval) {\n\t\t\tyylval = mk_cmdarg(D_string);\n\t\t\tyylval->a_string = str;\n\t\t\tappend_cmdarg(yylval);\n\t\t\treturn D_STRING;\n\t\t} else {\t/* awk string */\n\t\t\tif (esc_seen)\n\t\t\t\tflags |= SCAN;\n\t\t\tyylval = mk_cmdarg(D_node);\n\t\t\tyylval->a_node = make_str_node(str, p - str, flags);\n\t\t\tappend_cmdarg(yylval);\n\t\t\treturn D_NODE;\n\t\t}\n\t}\n\n\tif (! want_nodeval) {\n\t\twhile ((c = *++lexptr) != '\\0' && c != ':' && c != '-'\n\t\t\t\t\t&& c != ' ' && c != '\\t' && c != '=')\n\t\t\t;\n\n\t\t/* Is it an integer? */\n\t\tif (isdigit((unsigned char) tokstart[0]) && cmdtab[cmd_idx].type != D_option) {\n\t\t\tchar *end;\n\t\t\tlong l;\n\n\t\t\terrno = 0;\n\t\t\tl = strtol(tokstart, &end, 0);\n\t\t\tif (errno != 0) {\n\t\t\t\tyyerror(_(\"%s\"), strerror(errno));\n\t\t\t\terrno = 0;\n\t\t\t\treturn '\\n';\n\t\t\t}\n\n\t\t\tif (lexptr == end) {\n\t\t\t\tyylval = mk_cmdarg(D_int);\n\t\t\t\tyylval->a_int = l;\n\t\t\t\tappend_cmdarg(yylval);\n\t\t\t\treturn D_INT;\n\t\t\t}\n\t\t}\n\n\t\t/* Must be string */\n\t\tyylval = mk_cmdarg(D_string);\n\t\tyylval->a_string = estrdup(tokstart, lexptr - tokstart);\n\t\tappend_cmdarg(yylval);\n\t\treturn D_STRING;\n\t}\n\n\t/* look for awk number */\n\n\tif (isdigit((unsigned char) tokstart[0])) {\n\t\tNODE *r = NULL;\n\n\t\terrno = 0;\n#ifdef HAVE_MPFR\n\t\tif (do_mpfr) {\n\t\t\tint tval;\n\t\t\tr = mpg_float();\n\t\t\ttval = mpfr_strtofr(r->mpg_numbr, tokstart, & lexptr, 0, ROUND_MODE);\n\t\t\tIEEE_FMT(r->mpg_numbr, tval);\n\t\t\tif (mpfr_integer_p(r->mpg_numbr)) {\n\t\t\t\t/* integral value, convert to a GMP type. */\n\t\t\t\tNODE *tmp = r;\n\t\t\t\tr = mpg_integer();\n\t\t\t\tmpfr_get_z(r->mpg_i, tmp->mpg_numbr, MPFR_RNDZ);\n\t\t\t\tunref(tmp);\n\t\t\t}\n\t\t} else\n#endif\n\t\t\tr = make_number(strtod(tokstart, & lexptr));\n\n\t\tif (errno != 0) {\n\t\t\tyyerror(strerror(errno));\n\t\t\tunref(r);\n\t\t\terrno = 0;\n\t\t\treturn '\\n';\n\t\t}\n\t\tyylval = mk_cmdarg(D_node);\n\t\tyylval->a_node = r;\n\t\tappend_cmdarg(yylval);\n\t\treturn D_NODE;\n\t}\n\n\tc = *lexptr;\n\tif (c == '$' || c == '@'\n\t\t\t|| c == '[' || c == ']'\n\t\t\t|| c == ',' || c == '=')\n\t\treturn *lexptr++;\n\n\tif (! is_letter(c)) {\n\t\tyyerror(_(\"invalid character\"));\n\t\treturn '\\n';\n\t}\n\n\twhile (is_identchar(c))\n\t\tc = *++lexptr;\n\ttoklen = lexptr - tokstart;\n\n\t/* awk variable */\n\tyylval = mk_cmdarg(D_variable);\n\tyylval->a_string = estrdup(tokstart, toklen);\n\tappend_cmdarg(yylval);\n\treturn D_VARIABLE;\n}",
        "lines": 278,
        "depth": 19,
        "decorators": [
          "yylex_ebcdic(void)",
          "yylex_ebcdic",
          "(",
          "void",
          "void",
          ")",
          "#else",
          "#else"
        ]
      },
      {
        "start_point": [
          3060,
          0
        ],
        "end_point": [
          3086,
          1
        ],
        "content": "static int\nyylex(void)\n{\n\tstatic char etoa_xlate[256];\n\tstatic int do_etoa_init = 1;\n\tint tok;\n\n\tif (do_etoa_init)\n\t{\n\t\tfor (tok = 0; tok < 256; tok++)\n\t\t\tetoa_xlate[tok] = (char) tok;\n#ifdef HAVE___ETOA_L\n\t\t/* IBM helpfully provides this function.  */\n\t\t__etoa_l(etoa_xlate, sizeof(etoa_xlate));\n#else\n# error \"An EBCDIC-to-ASCII translation function is needed for this system\"\n#endif\n\t\tdo_etoa_init = 0;\n\t}\n\n\ttok = yylex_ebcdic();\n\n\tif (tok >= 0 && tok <= 0xFF)\n\t\ttok = etoa_xlate[tok];\n\n\treturn tok;\n}",
        "lines": 27,
        "depth": 11,
        "decorators": [
          "static",
          "static",
          "int"
        ]
      }
    ],
    "find_argument": {
      "start_point": [
        3091,
        0
      ],
      "end_point": [
        3110,
        1
      ],
      "content": "static int\nfind_argument(CMDARG *arg)\n{\n\t/* non-number argument */\n\tint idx;\n\tchar *name, *p;\n\tsize_t len;\n\tassert(cmd_idx >= 0);\n\tname = arg->a_string;\n\tlen = strlen(name);\n\tfor (idx = 0; (p = (char *) argtab[idx].name) != NULL; idx++) {\n\t\tif (cmdtab[cmd_idx].type == argtab[idx].cmd\n\t\t\t\t&& *p == *name\n\t\t\t\t&& strlen(p) == len\n\t\t\t\t&& strncmp(p, name, len) == 0\n\t\t)\n\t\t\treturn idx;\n\t}\n\treturn -1;\t/* invalid option */\n}",
      "lines": 20,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "concat_args": {
      "start_point": [
        3114,
        0
      ],
      "end_point": [
        3159,
        1
      ],
      "content": "static NODE *\nconcat_args(CMDARG *arg, int count)\n{\n\tNODE *n;\n\tNODE **tmp;\n\tchar *str, *subsep, *p;\n\tlong len, subseplen;\n\tint i;\n\n\tif (count == 1) {\n\t\tn = force_string(arg->a_node);\n\t\treturn dupnode(n);\n\t}\n\n\temalloc(tmp, NODE **, count * sizeof(NODE *), \"concat_args\");\n\tsubseplen = SUBSEP_node->var_value->stlen;\n\tsubsep = SUBSEP_node->var_value->stptr;\n\tlen = -subseplen;\n\n\tfor (i = 0; i < count; i++) {\n\t\tn = force_string(arg->a_node);\n\t\tlen += n->stlen + subseplen;\n\t\ttmp[i] = n;\n\t\targ = arg->next;\n\t}\n\n\temalloc(str, char *, len + 1, \"concat_args\");\n\tn = tmp[0];\n\tmemcpy(str, n->stptr, n->stlen);\n\tp = str + n->stlen;\n\tfor (i = 1; i < count; i++) {\n\t\tif (subseplen == 1)\n\t\t\t*p++ = *subsep;\n\t\telse if (subseplen > 0) {\n\t\t\tmemcpy(p, subsep, subseplen);\n\t\t\tp += subseplen;\n\t\t}\n\n\t\tn = tmp[i];\n\t\tmemcpy(p, n->stptr, n->stlen);\n\t\tp += n->stlen;\n\t}\n\tstr[len] = '\\0';\n\tefree(tmp);\n\treturn make_str_node(str, len, ALREADY_MALLOCED);\n}",
      "lines": 46,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "NODE",
        "*\nconcat_args(CMDARG *arg, int count)",
        "*"
      ]
    },
    "find_command": {
      "start_point": [
        3165,
        0
      ],
      "end_point": [
        3220,
        1
      ],
      "content": "static int\nfind_command(const char *token, size_t toklen)\n{\n\tchar *name, *abrv;\n\tint i, k;\n\tbool try_exact = true;\n\tint abrv_match = -1;\n\tint partial_match = -1;\n\n#if 'a' == 0x81 /* it's EBCDIC */\n\t/* make sure all lower case characters in token (sorting\n\t * isn't the solution in this case)\n\t */\n\tfor (i = 0; i < toklen; i++) {\n\t\tif (token[i] != tolower(token[i]))\n\t\t\treturn -1;\n\t}\n#endif\n\n\tk = sizeof(cmdtab)/sizeof(cmdtab[0]) - 1;\n\tfor (i = 0; i < k; i++) {\n\t\tname = (char *) cmdtab[i].name;\n\t\tif (try_exact && *token == *name\n\t\t\t\t&& toklen == strlen(name)\n\t\t\t\t&& strncmp(name, token, toklen) == 0\n\t\t)\n\t\t\treturn i;\n\n\t\tif (*name > *token || i == (k - 1))\n\t\t\ttry_exact = false;\n\n\t\tif (abrv_match < 0) {\n\t\t\tabrv = cmdtab[i].abbrvn;\n\t\t\tif (abrv[0] == token[0]) {\n\t\t\t\tif (toklen == 1 && ! abrv[1])\n\t\t\t\t\tabrv_match = i;\n\t\t\t\telse if (toklen == 2 && abrv[1] == token[1])\n\t\t\t\t\tabrv_match = i;\n\t\t\t}\n\t\t}\n\t\tif (! try_exact && abrv_match >= 0)\n\t\t\treturn abrv_match;\n\t\tif (partial_match < 0) {\n\t\t\tif (*token == *name\n\t\t\t\t\t&& toklen < strlen(name)\n\t\t\t\t\t&& strncmp(name, token, toklen) == 0\n\t\t\t) {\n\t\t\t\tif ((i == k - 1 || strncmp(cmdtab[i + 1].name, token, toklen) != 0)\n\t\t\t\t\t&& (i == 0 || strncmp(cmdtab[i - 1].name, token, toklen) != 0)\n\t\t\t\t)\n\t\t\t\t\tpartial_match = i;\n\t\t\t}\n\t\t}\n\t}\n\treturn partial_match;\n}",
      "lines": 56,
      "depth": 20,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "do_help": {
      "start_point": [
        3224,
        0
      ],
      "end_point": [
        3249,
        1
      ],
      "content": "int\ndo_help(CMDARG *arg, int cmd)\n{\n\tint i;\n\tif (arg == NULL) {\n\t\tinitialize_pager(out_fp);\n\t\tif (setjmp(pager_quit_tag) == 0) {\n\t\t\tfor (i = 0; cmdtab[i].name != NULL; i++) {\n\t\t\t\tgprintf(out_fp, \"%s:\\n\", cmdtab[i].name);\n\t\t\t\tgprintf(out_fp, \"\\t%s\\n\", _(cmdtab[i].help_txt));\n\t\t\t}\n\t\t}\n\t} else if (arg->type == D_string) {\n\t\tchar *name;\n\t\tname = arg->a_string;\n\t\ti = find_command(name, strlen(name));\n\t\tif (i >= 0) {\n\t\t\tfprintf(out_fp, \"%s\\n\", cmdtab[i].help_txt);\n\t\t\tif (strcmp(cmdtab[i].name, \"option\") == 0)\n\t\t\t\toption_help();\n\t\t} else\n\t\t\tfprintf(out_fp, _(\"undefined command: %s\\n\"), name);\n\t}\n\n\treturn false;\n}",
      "lines": 26,
      "depth": 16,
      "decorators": [
        "int"
      ]
    },
    "next_word": {
      "start_point": [
        3258,
        0
      ],
      "end_point": [
        3278,
        1
      ],
      "content": "static char *\nnext_word(char *p, int len, char **endp)\n{\n\tchar *q;\n\tint i;\n\n\tif (p == NULL || len <= 0)\n\t\treturn NULL;\n\tfor (i = 0; i < len; i++, p++)\n\t\tif (*p != ' ' && *p != '\\t')\n\t\t\tbreak;\n\tif (i == len)\n\t\treturn NULL;\n\tif (endp != NULL) {\n\t\tfor (i++, q = p + 1; i < len; i++, q++)\n\t\t\tif (*q == ' ' || *q == '\\t')\n\t\t\t\tbreak;\n\t\t*endp = q;\n\t}\n\treturn p;\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nnext_word(char *p, int len, char **endp)",
        "*"
      ]
    },
    "command_completion": {
      "start_point": [
        3290,
        0
      ],
      "end_point": [
        3339,
        1
      ],
      "content": "char **\ncommand_completion(const char *text, int start, int end)\n{\n\tchar *cmdtok, *e;\n\tint idx;\n\tint len;\n\n\trl_attempted_completion_over = true;\t/* no default filename completion please */\n\n\tthis_cmd = D_illegal;\n\tlen = start;\n\tif ((cmdtok = next_word(rl_line_buffer, len, &e)) == NULL)\t/* no first word yet */\n\t\treturn  rl_completion_matches(text, command_generator);\n\tlen -= (e - rl_line_buffer);\n\n\tidx = find_command(cmdtok, e - cmdtok);\n\tif (idx < 0)\n\t\treturn NULL;\n\tthis_cmd = cmdtab[idx].type;\n\n\tif (! next_word(e, len, NULL)) {\n\t\tswitch (this_cmd) {\n\t\tcase D_break:\n\t\tcase D_list:\n\t\tcase D_until:\n\t\tcase D_tbreak:\n\t\tcase D_clear:\n\t\t\treturn rl_completion_matches(text, srcfile_generator);\n\t\tcase D_info:\n\t\tcase D_enable:\n\t\tcase D_trace:\n\t\tcase D_help:\n\t\t\treturn rl_completion_matches(text, argument_generator);\n\t\tcase D_option:\n\t\t\treturn rl_completion_matches(text, option_generator);\n\t\tcase D_print:\n\t\tcase D_printf:\n\t\tcase D_set:\n\t\tcase D_display:\n\t\tcase D_watch:\n\t\t\treturn rl_completion_matches(text, variable_generator);\n\t\tdefault:\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (this_cmd == D_print || this_cmd == D_printf)\n\t\treturn rl_completion_matches(text, variable_generator);\n\treturn NULL;\n}",
      "lines": 50,
      "depth": 11,
      "decorators": [
        "char",
        "**\ncommand_completion(const char *text, int start, int end)",
        "*",
        "*\ncommand_completion(const char *text, int start, int end)",
        "*"
      ]
    },
    "command_generator": {
      "start_point": [
        3343,
        0
      ],
      "end_point": [
        3360,
        1
      ],
      "content": "static char *\ncommand_generator(const char *text, int state)\n{\n\tstatic size_t textlen;\n\tstatic int idx = 0;\n\tchar *name;\n\n\tif (! state) {\t/* first time */\n\t\ttextlen = strlen(text);\n\t\tidx = 0;\n\t}\n\twhile ((name = (char *) cmdtab[idx].name) != NULL) {\n\t\tidx++;\n\t\tif (strncmp(name, text, textlen) == 0)\n\t\t\treturn estrdup(name, strlen(name));\n\t}\n\treturn NULL;\n}",
      "lines": 18,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "char",
        "*\ncommand_generator(const char *text, int state)",
        "*"
      ]
    },
    "srcfile_generator": {
      "start_point": [
        3364,
        0
      ],
      "end_point": [
        3387,
        1
      ],
      "content": "static char *\nsrcfile_generator(const char *text, int state)\n{\n\tstatic size_t textlen;\n\tstatic SRCFILE *s;\n\tchar *name;\n\textern SRCFILE *srcfiles;\n\n\tif (! state) {\t/* first time */\n\t\ttextlen = strlen(text);\n\t\ts = srcfiles->next;\n\t}\n\twhile (s != srcfiles) {\n\t\tif (s->stype != SRC_FILE && s->stype != SRC_INC) {\n\t\t\ts = s->next;\n\t\t\tcontinue;\n\t\t}\n\t\tname = s->src;\n\t\ts = s->next;\n\t\tif (strncmp(name, text, textlen) == 0)\n\t\t\treturn estrdup(name, strlen(name));\n\t}\n\treturn NULL;\n}",
      "lines": 24,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nsrcfile_generator(const char *text, int state)",
        "*"
      ]
    },
    "argument_generator": {
      "start_point": [
        3391,
        0
      ],
      "end_point": [
        3417,
        1
      ],
      "content": "static char *\nargument_generator(const char *text, int state)\n{\n\tstatic size_t textlen;\n\tstatic int idx;\n\tconst char *name;\n\n\tif (! state) {\t/* first time */\n\t\ttextlen = strlen(text);\n\t\tidx = 0;\n\t}\n\n\tif (this_cmd == D_help) {\n\t\twhile ((name = cmdtab[idx++].name) != NULL) {\n\t\t\tif (strncmp(name, text, textlen) == 0)\n\t\t\t\treturn estrdup(name, strlen(name));\n\t\t}\n\t} else {\n\t\twhile ((name = argtab[idx].name) != NULL) {\n\t\t\tif (this_cmd != argtab[idx++].cmd)\n\t\t\t\tcontinue;\n\t\t\tif (strncmp(name, text, textlen) == 0)\n\t\t\t\treturn estrdup(name, strlen(name));\n\t\t}\n\t}\n\treturn NULL;\n}",
      "lines": 27,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nargument_generator(const char *text, int state)",
        "*"
      ]
    },
    "variable_generator": {
      "start_point": [
        3421,
        0
      ],
      "end_point": [
        3460,
        1
      ],
      "content": "static char *\nvariable_generator(const char *text, int state)\n{\n\tstatic size_t textlen;\n\tstatic int idx = 0;\n\tstatic NODE *func = NULL;\n\tstatic NODE **vars = NULL;\n\tconst char *name;\n\tNODE *r;\n\n\tif (! state) {\t/* first time */\n\t\ttextlen = strlen(text);\n\t\tif (vars != NULL)\n\t\t\tefree(vars);\n\t\tvars = variable_list();\n\t\tidx = 0;\n\t\tfunc = get_function();  /* function in current context */\n\t}\n\n\t/* function params */\n\twhile (func != NULL) {\n\t\tif (idx >= func->param_cnt) {\n\t\t\tfunc = NULL;\t/* don't try to match params again */\n\t\t\tidx = 0;\n\t\t\tbreak;\n\t\t}\n\t\tname = func->fparms[idx++].param;\n\t\tif (strncmp(name, text, textlen) == 0)\n\t\t\treturn estrdup(name, strlen(name));\n\t}\n\n\t/* globals */\n\twhile ((r = vars[idx++]) != NULL) {\n\t\tname = r->vname;\n\t\tif (strncmp(name, text, textlen) == 0)\n\t\t\treturn estrdup(name, strlen(name));\n\t}\n\n\treturn NULL;\n}",
      "lines": 40,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nvariable_generator(const char *text, int state)",
        "*"
      ]
    },
    "history_expand_line": {
      "start_point": [
        3464,
        0
      ],
      "end_point": [
        3480,
        1
      ],
      "content": "static void\nhistory_expand_line(char **line)\n{\n\tint ret;\n\tchar *expansion;\n\n\tif (! *line || input_fd != 0 || ! input_from_tty)\n\t\treturn;\n\tusing_history();\n\tret = history_expand(*line, &expansion);\n\tif (ret < 0 || ret == 2)\n\t\tefree(expansion);\n\telse {\n\t\tefree(*line);\n\t\t*line = expansion;\n\t}\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "gawk/gawk-4.2.1/command.y": {
    "D_DELETE": [
      {
        "start_point": [
          94,
          55
        ],
        "end_point": [
          123,
          4
        ],
        "content": "D_DISABLE D_DOWN\n%token D_ENABLE D_FINISH D_FRAME D_HELP D_IGNORE D_INFO D_LIST\n%token D_NEXT D_NEXTI D_PRINT D_PRINTF D_QUIT D_RETURN D_RUN D_SET\n%token D_STEP D_STEPI D_TBREAK D_UP D_UNTIL\n%token D_DISPLAY D_UNDISPLAY D_WATCH D_UNWATCH\n%token D_DUMP D_TRACE\n%token D_INT D_STRING D_NODE D_VARIABLE\n%token D_OPTION D_COMMANDS D_END D_SILENT D_SOURCE\n%token D_SAVE D_EVAL D_CONDITION\n%token D_STATEMENT\n\n%%\n\ninput\n\t: /* empty */\n\t| input line\n\t  {\n\t\tcmd_idx = -1;\n\t\twant_nodeval = false;\n\t\tif (lexptr_begin != NULL) {\n\t\t\tif (input_from_tty && lexptr_begin[0] != '\\0')\n\t\t\t\tadd_history(lexptr_begin);\n\t\t\tefree(lexptr_begin);\n\t\t\tlexptr_begin = NULL;\n\t\t}\n\t\tif (arg_list != NULL) {\n\t\t\tfree_cmdarg(arg_list);\n\t\t\targ_list = NULL;\n\t\t}\n\t  }",
        "lines": 30,
        "depth": 10,
        "decorators": null
      },
      {
        "start_point": [
          178,
          3
        ],
        "end_point": [
          181,
          4
        ],
        "content": "error nls\n\t  {\n\t\tyyerrok;\n\t  }",
        "lines": 4,
        "depth": 4,
        "decorators": null
      },
      {
        "start_point": [
          217,
          10
        ],
        "end_point": [
          232,
          4
        ],
        "content": "set_want_nodeval opt_param_list nls\n\t  {\n\t\tif (errcount == 0) {\n\t\t\t/* don't free arg_list;\tpassed on to statement_list\n\t\t\t * non-terminal (empty rule action). See below.\n\t\t\t */\n\t\t\tif (input_from_tty) {\n\t\t\t\tdbg_prompt = eval_prompt;\n\t\t\t\tfprintf(out_fp,\n\t\t_(\"Type (g)awk statement(s). End with the command \\\"end\\\"\\n\"));\n\t\t\t\trl_inhibit_completion = 1;\n\t\t\t}\n\t\t\tcmd_idx = -1;\n\t\t\tin_eval = true;\n\t\t}\n\t  }",
        "lines": 16,
        "depth": 13,
        "decorators": null
      },
      {
        "start_point": [
          244,
          3
        ],
        "end_point": [
          244,
          74
        ],
        "content": "statement_list D_STATEMENT { $$ = append_statement($1, lexptr_begin); }",
        "lines": 1,
        "depth": 7,
        "decorators": null
      },
      {
        "start_point": [
          251,
          17
        ],
        "end_point": [
          266,
          4
        ],
        "content": "statement_list D_END\n\t  {\n\t\targ_list = append_statement($2, (char *) end_EVAL);\n\t\tif (read_a_line == read_commands_string) {\t/* unserializing 'eval' in 'commands' */\n\t\t\tchar *str = arg_list->a_string;\n\t\t\tsize_t len = strlen(str);\n\t\t\tassert(len > 2 && str[len - 2] == '}');\n\t\t\tstr[len - 2] = '\\0';\n\t\t}\n\t\tif (input_from_tty) {\n\t\t\tdbg_prompt = in_commands ? commands_prompt : dgawk_prompt;\n\t\t\trl_inhibit_completion = 0;\n\t\t}\n\t\tcmd_idx = find_command(\"eval\", 4);\n\t\tin_eval = false;\n\t  }",
        "lines": 16,
        "depth": 12,
        "decorators": null
      },
      {
        "start_point": [
          267,
          3
        ],
        "end_point": [
          277,
          4
        ],
        "content": "D_EVAL set_want_nodeval string_node\n\t  {\n\t\tNODE *n;\n\t\tCMDARG *arg;\n\t\tn = $3->a_node;\n\t\targ = append_statement(NULL, (char *) start_EVAL);\n\t\t(void) append_statement(arg, n->stptr);\n\t\t(void) append_statement(arg, (char *) end_EVAL);\n\t\tfree_cmdarg(arg_list);\n\t\targ_list = arg;\n\t  }",
        "lines": 11,
        "depth": 10,
        "decorators": null
      },
      {
        "start_point": [
          292,
          3
        ],
        "end_point": [
          303,
          4
        ],
        "content": "D_INFO D_STRING\n\t  {\n\t\tint idx = find_argument($2);\n\t\tif (idx < 0)\n\t\t\tyyerror(_(\"info: invalid option - \\\"%s\\\"\"), $2->a_string);\n\t\telse {\n\t\t\tefree($2->a_string);\n\t\t\t$2->a_string = NULL;\n\t\t\t$2->type = D_argument;\n\t\t\t$2->a_argument = argtab[idx].value;\n\t\t}\n\t  }",
        "lines": 12,
        "depth": 10,
        "decorators": null
      }
    ],
    "plus_integer": [
      {
        "start_point": [
          316,
          36
        ],
        "end_point": [
          323,
          4
        ],
        "content": "variable condition_exp\n\t| d_cmd opt_integer_list\n\t| D_DUMP opt_string\n\t| D_SOURCE D_STRING\n\t  {\n\t\tif (in_cmd_src($2->a_string))\n\t\t\tyyerror(_(\"source \\\"%s\\\": already sourced.\"), $2->a_string);\n\t  }",
        "lines": 8,
        "depth": 10,
        "decorators": null
      },
      {
        "start_point": [
          324,
          3
        ],
        "end_point": [
          328,
          4
        ],
        "content": "D_SAVE D_STRING\n\t  {\n\t\tif (! input_from_tty)\n\t\t\tyyerror(_(\"save \\\"%s\\\": command not permitted.\"), $2->a_string);\n\t  }",
        "lines": 5,
        "depth": 10,
        "decorators": null
      },
      {
        "start_point": [
          329,
          3
        ],
        "end_point": [
          354,
          4
        ],
        "content": "D_COMMANDS commands_arg\n\t  {\n\t\tint type = 0;\n\t\tint num;\n\n\t\tif ($2 != NULL)\n\t\t\tnum = $2->a_int;\n\n\t\tif (errcount != 0)\n\t\t\t;\n\t\telse if (in_commands)\n\t\t\tyyerror(_(\"Can't use command `commands' for breakpoint/watchpoint commands\"));\n\t\telse if ($2 == NULL &&  ! (type = has_break_or_watch_point(&num, true)))\n\t\t\tyyerror(_(\"no breakpoint/watchpoint has been set yet\"));\n\t\telse if ($2 != NULL && ! (type = has_break_or_watch_point(&num, false)))\n\t\t\tyyerror(_(\"invalid breakpoint/watchpoint number\"));\n\t\tif (type) {\n\t\t\tin_commands = true;\n\t\t\tif (input_from_tty) {\n\t\t\t\tdbg_prompt = commands_prompt;\n\t\t\t\tfprintf(out_fp, _(\"Type commands for when %s %d is hit, one per line.\\n\"),\n\t\t\t\t\t\t\t\t(type == D_break) ? \"breakpoint\" : \"watchpoint\", num);\n\t\t\t\tfprintf(out_fp, _(\"End with the command \\\"end\\\"\\n\"));\n\t\t\t}\n\t\t}\n\t  }",
        "lines": 26,
        "depth": 15,
        "decorators": null
      },
      {
        "start_point": [
          370,
          3
        ],
        "end_point": [
          381,
          4
        ],
        "content": "D_TRACE D_STRING\n\t  {\n\t\tint idx = find_argument($2);\n\t\tif (idx < 0)\n\t\t\tyyerror(_(\"trace: invalid option - \\\"%s\\\"\"), $2->a_string);\n\t\telse {\n\t\t\tefree($2->a_string);\n\t\t\t$2->a_string = NULL;\n\t\t\t$2->type = D_argument;\n\t\t\t$2->a_argument = argtab[idx].value;\n\t\t}\n\t  }",
        "lines": 12,
        "depth": 10,
        "decorators": null
      },
      {
        "start_point": [
          382,
          3
        ],
        "end_point": [
          382,
          52
        ],
        "content": "D_CONDITION plus_integer { want_nodeval = true; }",
        "lines": 1,
        "depth": 5,
        "decorators": null
      },
      {
        "start_point": [
          549,
          7
        ],
        "end_point": [
          553,
          4
        ],
        "content": "D_VARIABLE subscript_list /* dump sub-array items*/\n\t  {\n\t\t$2->type = D_array;\n\t\t$2->a_count = num_dim;\n\t  }",
        "lines": 5,
        "depth": 6,
        "decorators": null
      }
    ],
    "error": [
      {
        "start_point": [
          650,
          3
        ],
        "end_point": [
          651,
          26
        ],
        "content": "subscript_list subscript\n\t  {\t$$ = $1; num_dim++; }",
        "lines": 2,
        "depth": 5,
        "decorators": null
      },
      {
        "start_point": [
          665,
          3
        ],
        "end_point": [
          671,
          4
        ],
        "content": "D_VARIABLE subscript_list\n\t  {\n\t\t/* a_string is array name, a_count is dimension count */\n\t\t$1->type = D_subscript;\n\t\t$1->a_count = num_dim;\n\t\t$$ = $1;\n\t  }",
        "lines": 7,
        "depth": 6,
        "decorators": null
      }
    ],
    "append_statement": {
      "start_point": [
        753,
        0
      ],
      "end_point": [
        811,
        1
      ],
      "content": "static CMDARG *\nappend_statement(CMDARG *stmt_list, char *stmt)\n{\n\tCMDARG *a, *arg;\n\tchar *s;\n\tint len, slen, ssize;\n\n#define EVALSIZE\t512\n\n\tif (stmt == start_EVAL) {\n\t\tlen = sizeof(start_EVAL);\n\t\tfor (a = stmt_list; a != NULL; a = a->next)\n\t\t\tlen += strlen(a->a_string) + 1;\t/* 1 for ',' */\n\t\tlen += EVALSIZE;\n\n\t\temalloc(s, char *, (len + 1) * sizeof(char), \"append_statement\");\n\t\targ = mk_cmdarg(D_string);\n\t\targ->a_string = s;\n\t\targ->a_count = len;\t/* kludge */\n\n\t\tslen = sizeof(\"function @eval(\") - 1;\n\t\tmemcpy(s, start_EVAL, slen);\n\n\t\tfor (a = stmt_list; a != NULL; a = a->next) {\n\t\t\tlen = strlen(a->a_string);\n\t\t\tmemcpy(s + slen, a->a_string, len);\n\t\t\tslen += len;\n\t\t\tif (a->next != NULL)\n\t\t\t\ts[slen++] = ',';\n\t\t}\n\t\ts[slen++] = ')';\n\t\ts[slen++] = '{';\n\t\ts[slen] = '\\0';\n\t\treturn arg;\n\t}\n\n\tlen = strlen(stmt) + 1;\t/* 1 for newline */\n\ts = stmt_list->a_string;\n\tslen = strlen(s);\n\tssize = stmt_list->a_count;\n\tif (len > ssize - slen) {\n\t\tssize = slen + len + EVALSIZE;\n\t\terealloc(s, char *, (ssize + 1) * sizeof(char), \"append_statement\");\n\t\tstmt_list->a_string = s;\n\t\tstmt_list->a_count = ssize;\n\t}\n\tmemcpy(s + slen, stmt, len);\n\tslen += len;\n\tif (slen >= 2 && s[slen - 2] != '\\n') {\n\t\ts[slen - 1] = '\\n';\n\t\ts[slen] = '\\0';\n\t}\n\n\tif (stmt == end_EVAL)\n\t\terealloc(stmt_list->a_string, char *, slen + 1, \"append_statement\");\n\treturn stmt_list;\n\n#undef EVALSIZE\n}",
      "lines": 59,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "CMDARG",
        "*\nappend_statement(CMDARG *stmt_list, char *stmt)",
        "*"
      ]
    },
    "get_command": {
      "start_point": [
        930,
        0
      ],
      "end_point": [
        939,
        1
      ],
      "content": "Func_cmd\nget_command(int ctype)\n{\n\tint i;\n\tfor (i = 0; cmdtab[i].name != NULL; i++) {\n\t\tif (cmdtab[i].type == ctype)\n\t\t\treturn cmdtab[i].cf_ptr;\n\t}\n\treturn (Func_cmd) 0;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "Func_cmd"
      ]
    },
    "get_command_name": {
      "start_point": [
        943,
        0
      ],
      "end_point": [
        952,
        1
      ],
      "content": "const char *\nget_command_name(int ctype)\n{\n\tint i;\n\tfor (i = 0; cmdtab[i].name != NULL; i++) {\n\t\tif (cmdtab[i].type == ctype)\n\t\t\treturn cmdtab[i].name;\n\t}\n\treturn NULL;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nget_command_name(int ctype)",
        "*"
      ]
    },
    "mk_cmdarg": {
      "start_point": [
        956,
        0
      ],
      "end_point": [
        963,
        1
      ],
      "content": "static CMDARG *\nmk_cmdarg(enum argtype type)\n{\n\tCMDARG *arg;\n\tezalloc(arg, CMDARG *, sizeof(CMDARG), \"mk_cmdarg\");\n\targ->type = type;\n\treturn arg;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "CMDARG",
        "*\nmk_cmdarg(enum argtype type)",
        "*"
      ]
    },
    "append_cmdarg": {
      "start_point": [
        967,
        0
      ],
      "end_point": [
        977,
        1
      ],
      "content": "static void\nappend_cmdarg(CMDARG *arg)\n{\n\tstatic CMDARG *savetail;\n\n\tif (arg_list == NULL)\n\t\targ_list = arg;\n\telse\n\t\tsavetail->next = arg;\n\tsavetail = arg;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "free_cmdarg": {
      "start_point": [
        981,
        0
      ],
      "end_point": [
        1006,
        1
      ],
      "content": "void\nfree_cmdarg(CMDARG *list)\n{\n\tCMDARG *arg, *nexta;\n\n\tfor (arg = list; arg != NULL; arg = nexta) {\n\t\tnexta = arg->next;\n\n\t\tswitch (arg->type) {\n\t\tcase D_variable:\n\t\tcase D_subscript:\n\t\tcase D_array:\n\t\tcase D_string:\n\t\t\tif (arg->a_string != NULL)\n\t\t\t\tefree(arg->a_string);\n\t\t\tbreak;\n\t\tcase D_node:\n\t\tcase D_field:\n\t\t\tunref(arg->a_node);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tefree(arg);\n\t}\n}",
      "lines": 26,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "yyerror": {
      "start_point": [
        1010,
        0
      ],
      "end_point": [
        1021,
        1
      ],
      "content": "static void\nyyerror(const char *mesg, ...)\n{\n\tva_list args;\n\tva_start(args, mesg);\n\tfprintf(out_fp, _(\"error: \"));\n\tvfprintf(out_fp, mesg, args);\n\tfprintf(out_fp, \"\\n\");\n\tva_end(args);\n\terrcount++;\n\trepeat_idx = -1;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yylex": [
      {
        "start_point": [
          1028,
          0
        ],
        "end_point": [
          1305,
          1
        ],
        "content": "yylex_ebcdic(void)\n#else\nyylex(void)\n#endif\n{\n\tstatic char *lexptr = NULL;\n\tstatic char *lexend;\n\tint c;\n\tchar *tokstart;\n\tsize_t toklen;\n\n\tyylval = (CMDARG *) NULL;\n\n\tif (errcount > 0 && lexptr_begin == NULL) {\n\t\t/* fake a new line */\n\t\terrcount = 0;\n\t\treturn '\\n';\n\t}\n\n\tif (lexptr_begin == NULL) {\nagain:\n\t\tlexptr_begin = read_a_line(dbg_prompt);\n\t\tif (lexptr_begin == NULL) {\t/* EOF or error */\n\t\t\tif (get_eof_status() == EXIT_FATAL)\n\t\t\t\texit(EXIT_FATAL);\n\t\t\tif (get_eof_status() == EXIT_FAILURE) {\n\t\t\t\tstatic int seen_eof = 0;\n\n\t\t\t\t/* force a quit, and let do_quit (in debug.c) exit */\n\t\t\t\tif (! seen_eof) {\n\t\t\t\t\tif (errno != 0)\t{\n\t\t\t\t\t\tfprintf(stderr, _(\"can't read command (%s)\\n\"), strerror(errno));\n\t\t\t\t\t\texit_val = EXIT_FAILURE;\n\t\t\t\t\t} /* else\n\t\t\t\t\t\texit_val = EXIT_SUCCESS; */\n\n\t\t\t\t\tseen_eof = 1;\n\t\t\t\t\treturn '\\n';\t/* end current command if any */\n\t\t\t\t} else if (seen_eof++ == 1) {\n\t\t\t\t\tcmd_idx = find_command(\"quit\", 4);\n\t\t\t\t\treturn D_QUIT;\t/* 'quit' token */\n\t\t\t\t} else\n\t\t\t\t\treturn '\\n';\t/* end command 'quit' */\n\t\t\t}\n\t\t\tif (errno != 0)\n\t\t\t\td_error(_(\"can't read command (%s)\"), strerror(errno));\n\t\t\tif (pop_cmd_src() == 0)\n\t\t\t\tgoto again;\n\t\t\texit(EXIT_FATAL);\t/* shouldn't happen */\n\t\t}\n\n\t\tif (! in_commands && ! in_eval\t/* history expansion off in 'commands' and 'eval' */\n\t\t\t\t&& input_from_tty\n\t\t)\n\t\t\thistory_expand_line(&lexptr_begin);\n\n\t\tlexptr = lexptr_begin;\n\t\tlexend = lexptr + strlen(lexptr);\n\t\tif (*lexptr == '\\0'\t\t/* blank line */\n\t\t\t\t&& repeat_idx >= 0\n\t\t\t\t&& input_from_tty\n\t\t\t\t&& ! in_eval\n\t\t) {\n#ifdef HAVE_LIBREADLINE\n\t\t\tHIST_ENTRY *h;\n\t\t\th = previous_history();\n\t\t\tif (h != NULL)\n\t\t\t\tadd_history(h->line);\n#endif\n\t\t\tcmd_idx = repeat_idx;\n\t\t\treturn cmdtab[cmd_idx].class;\t/* repeat last command */\n\t\t}\n\t\trepeat_idx = -1;\n\t}\n\n\tc = *lexptr;\n\n\twhile (c == ' ' || c == '\\t')\n\t\tc = *++lexptr;\n\n\tif (! input_from_tty && c == '#')\n\t\treturn '\\n';\n\n\ttokstart = lexptr;\n\tif (lexptr >= lexend)\n\t\treturn '\\n';\n\n\tif (cmd_idx < 0) {\t/* need a command */\n\t\tif (c == '?' && tokstart[1] == '\\0'\t&& ! in_eval) {\n\t\t\tlexptr++;\n\t\t\tcmd_idx = find_command(\"help\", 4);\n\t\t\treturn D_HELP;\n\t\t}\n\n\t\twhile (c != '\\0' && c != ' ' && c != '\\t') {\n\t\t\tif (! is_alpha(c) && ! in_eval) {\n\t\t\t\tyyerror(_(\"invalid character in command\"));\n\t\t\t\treturn '\\n';\n\t\t\t}\n\t\t\tc = *++lexptr;\n\t\t}\n\n\t\ttoklen = lexptr - tokstart;\n\n\t\tif (in_eval) {\n\t\t\tif (toklen == 3\n\t\t\t\t\t&& tokstart[3] == '\\0'\n\t\t\t\t\t&& tokstart[0] == 'e'\n\t\t\t\t\t&& tokstart[1] == 'n'\n\t\t\t\t\t&& tokstart[2] == 'd'\n\t\t\t) {\n\t\t\t\tcmd_idx = find_command(tokstart, toklen);\n\t\t\t\treturn D_END;\n\t\t\t}\n\t\t\tlexptr = lexend;\n\t\t\treturn D_STATEMENT;\n\t\t}\n\n\t\tcmd_idx = find_command(tokstart, toklen);\n\t\tif (cmd_idx >= 0) {\n\t\t\tif (in_commands && cmdtab[cmd_idx].type != D_eval) {\n\t\t\t\t/* add the actual command string (lexptr_begin) to\n\t\t\t\t * arg_list; command string for 'eval' prepended to the arg_list\n\t\t\t\t * in the grammer above (see eval_cmd non-terminal).\n\t\t\t\t */\n\t\t\t\tCMDARG *arg;\n\t\t\t\targ = mk_cmdarg(D_string);\n\t\t\t\targ->a_string = estrdup(lexptr_begin, lexend - lexptr_begin);\n\t\t\t\tappend_cmdarg(arg);\n\t\t\t}\n\t\t\treturn cmdtab[cmd_idx].class;\n\t\t} else {\n\t\t\tyyerror(_(\"unknown command - \\\"%.*s\\\", try help\"), toklen, tokstart);\n\t\t\treturn '\\n';\n\t\t}\n\t}\n\n\tc = *lexptr;\n\n\tif (cmdtab[cmd_idx].type == D_option) {\n\t\tif (c == '=')\n\t\t\treturn *lexptr++;\n\t} else if (c == '-' || c == '+' || c == ':' || c == '|')\n\t\treturn *lexptr++;\n\n\tif (c == '\"') {\n\t\tchar *str, *p;\n\t\tint flags = ALREADY_MALLOCED;\n\t\tbool esc_seen = false;\n\n\t\ttoklen = lexend - lexptr;\n\t\temalloc(str, char *, toklen + 1, \"yylex\");\n\t\tp = str;\n\n\t\twhile ((c = *++lexptr) != '\"') {\n\t\t\tif (lexptr == lexend) {\nerr:\n\t\t\t\tefree(str);\n\t\t\t\tyyerror(_(\"unterminated string\"));\n\t\t\t\treturn '\\n';\n\t\t\t}\n\t\t\tif (c == '\\\\') {\n\t\t\t\tc = *++lexptr;\n\t\t\t\tesc_seen = true;\n\t\t\t\tif (want_nodeval || c != '\"')\n\t\t\t\t\t*p++ = '\\\\';\n\t\t\t}\n\t\t\tif (lexptr == lexend)\n\t\t\t\tgoto err;\n\t\t\t*p++ = c;\n\t\t}\n\t\tlexptr++;\n\t\t*p = '\\0';\n\n\t\tif (! want_nodeval) {\n\t\t\tyylval = mk_cmdarg(D_string);\n\t\t\tyylval->a_string = str;\n\t\t\tappend_cmdarg(yylval);\n\t\t\treturn D_STRING;\n\t\t} else {\t/* awk string */\n\t\t\tif (esc_seen)\n\t\t\t\tflags |= SCAN;\n\t\t\tyylval = mk_cmdarg(D_node);\n\t\t\tyylval->a_node = make_str_node(str, p - str, flags);\n\t\t\tappend_cmdarg(yylval);\n\t\t\treturn D_NODE;\n\t\t}\n\t}\n\n\tif (! want_nodeval) {\n\t\twhile ((c = *++lexptr) != '\\0' && c != ':' && c != '-'\n\t\t\t\t\t&& c != ' ' && c != '\\t' && c != '=')\n\t\t\t;\n\n\t\t/* Is it an integer? */\n\t\tif (isdigit((unsigned char) tokstart[0]) && cmdtab[cmd_idx].type != D_option) {\n\t\t\tchar *end;\n\t\t\tlong l;\n\n\t\t\terrno = 0;\n\t\t\tl = strtol(tokstart, &end, 0);\n\t\t\tif (errno != 0) {\n\t\t\t\tyyerror(_(\"%s\"), strerror(errno));\n\t\t\t\terrno = 0;\n\t\t\t\treturn '\\n';\n\t\t\t}\n\n\t\t\tif (lexptr == end) {\n\t\t\t\tyylval = mk_cmdarg(D_int);\n\t\t\t\tyylval->a_int = l;\n\t\t\t\tappend_cmdarg(yylval);\n\t\t\t\treturn D_INT;\n\t\t\t}\n\t\t}\n\n\t\t/* Must be string */\n\t\tyylval = mk_cmdarg(D_string);\n\t\tyylval->a_string = estrdup(tokstart, lexptr - tokstart);\n\t\tappend_cmdarg(yylval);\n\t\treturn D_STRING;\n\t}\n\n\t/* look for awk number */\n\n\tif (isdigit((unsigned char) tokstart[0])) {\n\t\tNODE *r = NULL;\n\n\t\terrno = 0;\n#ifdef HAVE_MPFR\n\t\tif (do_mpfr) {\n\t\t\tint tval;\n\t\t\tr = mpg_float();\n\t\t\ttval = mpfr_strtofr(r->mpg_numbr, tokstart, & lexptr, 0, ROUND_MODE);\n\t\t\tIEEE_FMT(r->mpg_numbr, tval);\n\t\t\tif (mpfr_integer_p(r->mpg_numbr)) {\n\t\t\t\t/* integral value, convert to a GMP type. */\n\t\t\t\tNODE *tmp = r;\n\t\t\t\tr = mpg_integer();\n\t\t\t\tmpfr_get_z(r->mpg_i, tmp->mpg_numbr, MPFR_RNDZ);\n\t\t\t\tunref(tmp);\n\t\t\t}\n\t\t} else\n#endif\n\t\t\tr = make_number(strtod(tokstart, & lexptr));\n\n\t\tif (errno != 0) {\n\t\t\tyyerror(strerror(errno));\n\t\t\tunref(r);\n\t\t\terrno = 0;\n\t\t\treturn '\\n';\n\t\t}\n\t\tyylval = mk_cmdarg(D_node);\n\t\tyylval->a_node = r;\n\t\tappend_cmdarg(yylval);\n\t\treturn D_NODE;\n\t}\n\n\tc = *lexptr;\n\tif (c == '$' || c == '@'\n\t\t\t|| c == '[' || c == ']'\n\t\t\t|| c == ',' || c == '=')\n\t\treturn *lexptr++;\n\n\tif (! is_letter(c)) {\n\t\tyyerror(_(\"invalid character\"));\n\t\treturn '\\n';\n\t}\n\n\twhile (is_identchar(c))\n\t\tc = *++lexptr;\n\ttoklen = lexptr - tokstart;\n\n\t/* awk variable */\n\tyylval = mk_cmdarg(D_variable);\n\tyylval->a_string = estrdup(tokstart, toklen);\n\tappend_cmdarg(yylval);\n\treturn D_VARIABLE;\n}",
        "lines": 278,
        "depth": 19,
        "decorators": [
          "yylex_ebcdic(void)",
          "yylex_ebcdic",
          "(",
          "void",
          "void",
          ")",
          "#else",
          "#else"
        ]
      },
      {
        "start_point": [
          1311,
          0
        ],
        "end_point": [
          1337,
          1
        ],
        "content": "static int\nyylex(void)\n{\n\tstatic char etoa_xlate[256];\n\tstatic int do_etoa_init = 1;\n\tint tok;\n\n\tif (do_etoa_init)\n\t{\n\t\tfor (tok = 0; tok < 256; tok++)\n\t\t\tetoa_xlate[tok] = (char) tok;\n#ifdef HAVE___ETOA_L\n\t\t/* IBM helpfully provides this function.  */\n\t\t__etoa_l(etoa_xlate, sizeof(etoa_xlate));\n#else\n# error \"An EBCDIC-to-ASCII translation function is needed for this system\"\n#endif\n\t\tdo_etoa_init = 0;\n\t}\n\n\ttok = yylex_ebcdic();\n\n\tif (tok >= 0 && tok <= 0xFF)\n\t\ttok = etoa_xlate[tok];\n\n\treturn tok;\n}",
        "lines": 27,
        "depth": 11,
        "decorators": [
          "static",
          "static",
          "int"
        ]
      }
    ],
    "find_argument": {
      "start_point": [
        1342,
        0
      ],
      "end_point": [
        1361,
        1
      ],
      "content": "static int\nfind_argument(CMDARG *arg)\n{\n\t/* non-number argument */\n\tint idx;\n\tchar *name, *p;\n\tsize_t len;\n\tassert(cmd_idx >= 0);\n\tname = arg->a_string;\n\tlen = strlen(name);\n\tfor (idx = 0; (p = (char *) argtab[idx].name) != NULL; idx++) {\n\t\tif (cmdtab[cmd_idx].type == argtab[idx].cmd\n\t\t\t\t&& *p == *name\n\t\t\t\t&& strlen(p) == len\n\t\t\t\t&& strncmp(p, name, len) == 0\n\t\t)\n\t\t\treturn idx;\n\t}\n\treturn -1;\t/* invalid option */\n}",
      "lines": 20,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "concat_args": {
      "start_point": [
        1365,
        0
      ],
      "end_point": [
        1410,
        1
      ],
      "content": "static NODE *\nconcat_args(CMDARG *arg, int count)\n{\n\tNODE *n;\n\tNODE **tmp;\n\tchar *str, *subsep, *p;\n\tlong len, subseplen;\n\tint i;\n\n\tif (count == 1) {\n\t\tn = force_string(arg->a_node);\n\t\treturn dupnode(n);\n\t}\n\n\temalloc(tmp, NODE **, count * sizeof(NODE *), \"concat_args\");\n\tsubseplen = SUBSEP_node->var_value->stlen;\n\tsubsep = SUBSEP_node->var_value->stptr;\n\tlen = -subseplen;\n\n\tfor (i = 0; i < count; i++) {\n\t\tn = force_string(arg->a_node);\n\t\tlen += n->stlen + subseplen;\n\t\ttmp[i] = n;\n\t\targ = arg->next;\n\t}\n\n\temalloc(str, char *, len + 1, \"concat_args\");\n\tn = tmp[0];\n\tmemcpy(str, n->stptr, n->stlen);\n\tp = str + n->stlen;\n\tfor (i = 1; i < count; i++) {\n\t\tif (subseplen == 1)\n\t\t\t*p++ = *subsep;\n\t\telse if (subseplen > 0) {\n\t\t\tmemcpy(p, subsep, subseplen);\n\t\t\tp += subseplen;\n\t\t}\n\n\t\tn = tmp[i];\n\t\tmemcpy(p, n->stptr, n->stlen);\n\t\tp += n->stlen;\n\t}\n\tstr[len] = '\\0';\n\tefree(tmp);\n\treturn make_str_node(str, len, ALREADY_MALLOCED);\n}",
      "lines": 46,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "NODE",
        "*\nconcat_args(CMDARG *arg, int count)",
        "*"
      ]
    },
    "find_command": {
      "start_point": [
        1416,
        0
      ],
      "end_point": [
        1471,
        1
      ],
      "content": "static int\nfind_command(const char *token, size_t toklen)\n{\n\tchar *name, *abrv;\n\tint i, k;\n\tbool try_exact = true;\n\tint abrv_match = -1;\n\tint partial_match = -1;\n\n#if 'a' == 0x81 /* it's EBCDIC */\n\t/* make sure all lower case characters in token (sorting\n\t * isn't the solution in this case)\n\t */\n\tfor (i = 0; i < toklen; i++) {\n\t\tif (token[i] != tolower(token[i]))\n\t\t\treturn -1;\n\t}\n#endif\n\n\tk = sizeof(cmdtab)/sizeof(cmdtab[0]) - 1;\n\tfor (i = 0; i < k; i++) {\n\t\tname = (char *) cmdtab[i].name;\n\t\tif (try_exact && *token == *name\n\t\t\t\t&& toklen == strlen(name)\n\t\t\t\t&& strncmp(name, token, toklen) == 0\n\t\t)\n\t\t\treturn i;\n\n\t\tif (*name > *token || i == (k - 1))\n\t\t\ttry_exact = false;\n\n\t\tif (abrv_match < 0) {\n\t\t\tabrv = cmdtab[i].abbrvn;\n\t\t\tif (abrv[0] == token[0]) {\n\t\t\t\tif (toklen == 1 && ! abrv[1])\n\t\t\t\t\tabrv_match = i;\n\t\t\t\telse if (toklen == 2 && abrv[1] == token[1])\n\t\t\t\t\tabrv_match = i;\n\t\t\t}\n\t\t}\n\t\tif (! try_exact && abrv_match >= 0)\n\t\t\treturn abrv_match;\n\t\tif (partial_match < 0) {\n\t\t\tif (*token == *name\n\t\t\t\t\t&& toklen < strlen(name)\n\t\t\t\t\t&& strncmp(name, token, toklen) == 0\n\t\t\t) {\n\t\t\t\tif ((i == k - 1 || strncmp(cmdtab[i + 1].name, token, toklen) != 0)\n\t\t\t\t\t&& (i == 0 || strncmp(cmdtab[i - 1].name, token, toklen) != 0)\n\t\t\t\t)\n\t\t\t\t\tpartial_match = i;\n\t\t\t}\n\t\t}\n\t}\n\treturn partial_match;\n}",
      "lines": 56,
      "depth": 20,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "do_help": {
      "start_point": [
        1475,
        0
      ],
      "end_point": [
        1500,
        1
      ],
      "content": "int\ndo_help(CMDARG *arg, int cmd)\n{\n\tint i;\n\tif (arg == NULL) {\n\t\tinitialize_pager(out_fp);\n\t\tif (setjmp(pager_quit_tag) == 0) {\n\t\t\tfor (i = 0; cmdtab[i].name != NULL; i++) {\n\t\t\t\tgprintf(out_fp, \"%s:\\n\", cmdtab[i].name);\n\t\t\t\tgprintf(out_fp, \"\\t%s\\n\", _(cmdtab[i].help_txt));\n\t\t\t}\n\t\t}\n\t} else if (arg->type == D_string) {\n\t\tchar *name;\n\t\tname = arg->a_string;\n\t\ti = find_command(name, strlen(name));\n\t\tif (i >= 0) {\n\t\t\tfprintf(out_fp, \"%s\\n\", cmdtab[i].help_txt);\n\t\t\tif (strcmp(cmdtab[i].name, \"option\") == 0)\n\t\t\t\toption_help();\n\t\t} else\n\t\t\tfprintf(out_fp, _(\"undefined command: %s\\n\"), name);\n\t}\n\n\treturn false;\n}",
      "lines": 26,
      "depth": 16,
      "decorators": [
        "int"
      ]
    },
    "next_word": {
      "start_point": [
        1509,
        0
      ],
      "end_point": [
        1529,
        1
      ],
      "content": "static char *\nnext_word(char *p, int len, char **endp)\n{\n\tchar *q;\n\tint i;\n\n\tif (p == NULL || len <= 0)\n\t\treturn NULL;\n\tfor (i = 0; i < len; i++, p++)\n\t\tif (*p != ' ' && *p != '\\t')\n\t\t\tbreak;\n\tif (i == len)\n\t\treturn NULL;\n\tif (endp != NULL) {\n\t\tfor (i++, q = p + 1; i < len; i++, q++)\n\t\t\tif (*q == ' ' || *q == '\\t')\n\t\t\t\tbreak;\n\t\t*endp = q;\n\t}\n\treturn p;\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nnext_word(char *p, int len, char **endp)",
        "*"
      ]
    },
    "command_completion": {
      "start_point": [
        1541,
        0
      ],
      "end_point": [
        1590,
        1
      ],
      "content": "char **\ncommand_completion(const char *text, int start, int end)\n{\n\tchar *cmdtok, *e;\n\tint idx;\n\tint len;\n\n\trl_attempted_completion_over = true;\t/* no default filename completion please */\n\n\tthis_cmd = D_illegal;\n\tlen = start;\n\tif ((cmdtok = next_word(rl_line_buffer, len, &e)) == NULL)\t/* no first word yet */\n\t\treturn  rl_completion_matches(text, command_generator);\n\tlen -= (e - rl_line_buffer);\n\n\tidx = find_command(cmdtok, e - cmdtok);\n\tif (idx < 0)\n\t\treturn NULL;\n\tthis_cmd = cmdtab[idx].type;\n\n\tif (! next_word(e, len, NULL)) {\n\t\tswitch (this_cmd) {\n\t\tcase D_break:\n\t\tcase D_list:\n\t\tcase D_until:\n\t\tcase D_tbreak:\n\t\tcase D_clear:\n\t\t\treturn rl_completion_matches(text, srcfile_generator);\n\t\tcase D_info:\n\t\tcase D_enable:\n\t\tcase D_trace:\n\t\tcase D_help:\n\t\t\treturn rl_completion_matches(text, argument_generator);\n\t\tcase D_option:\n\t\t\treturn rl_completion_matches(text, option_generator);\n\t\tcase D_print:\n\t\tcase D_printf:\n\t\tcase D_set:\n\t\tcase D_display:\n\t\tcase D_watch:\n\t\t\treturn rl_completion_matches(text, variable_generator);\n\t\tdefault:\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (this_cmd == D_print || this_cmd == D_printf)\n\t\treturn rl_completion_matches(text, variable_generator);\n\treturn NULL;\n}",
      "lines": 50,
      "depth": 11,
      "decorators": [
        "char",
        "**\ncommand_completion(const char *text, int start, int end)",
        "*",
        "*\ncommand_completion(const char *text, int start, int end)",
        "*"
      ]
    },
    "command_generator": {
      "start_point": [
        1594,
        0
      ],
      "end_point": [
        1611,
        1
      ],
      "content": "static char *\ncommand_generator(const char *text, int state)\n{\n\tstatic size_t textlen;\n\tstatic int idx = 0;\n\tchar *name;\n\n\tif (! state) {\t/* first time */\n\t\ttextlen = strlen(text);\n\t\tidx = 0;\n\t}\n\twhile ((name = (char *) cmdtab[idx].name) != NULL) {\n\t\tidx++;\n\t\tif (strncmp(name, text, textlen) == 0)\n\t\t\treturn estrdup(name, strlen(name));\n\t}\n\treturn NULL;\n}",
      "lines": 18,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "char",
        "*\ncommand_generator(const char *text, int state)",
        "*"
      ]
    },
    "srcfile_generator": {
      "start_point": [
        1615,
        0
      ],
      "end_point": [
        1638,
        1
      ],
      "content": "static char *\nsrcfile_generator(const char *text, int state)\n{\n\tstatic size_t textlen;\n\tstatic SRCFILE *s;\n\tchar *name;\n\textern SRCFILE *srcfiles;\n\n\tif (! state) {\t/* first time */\n\t\ttextlen = strlen(text);\n\t\ts = srcfiles->next;\n\t}\n\twhile (s != srcfiles) {\n\t\tif (s->stype != SRC_FILE && s->stype != SRC_INC) {\n\t\t\ts = s->next;\n\t\t\tcontinue;\n\t\t}\n\t\tname = s->src;\n\t\ts = s->next;\n\t\tif (strncmp(name, text, textlen) == 0)\n\t\t\treturn estrdup(name, strlen(name));\n\t}\n\treturn NULL;\n}",
      "lines": 24,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nsrcfile_generator(const char *text, int state)",
        "*"
      ]
    },
    "argument_generator": {
      "start_point": [
        1642,
        0
      ],
      "end_point": [
        1668,
        1
      ],
      "content": "static char *\nargument_generator(const char *text, int state)\n{\n\tstatic size_t textlen;\n\tstatic int idx;\n\tconst char *name;\n\n\tif (! state) {\t/* first time */\n\t\ttextlen = strlen(text);\n\t\tidx = 0;\n\t}\n\n\tif (this_cmd == D_help) {\n\t\twhile ((name = cmdtab[idx++].name) != NULL) {\n\t\t\tif (strncmp(name, text, textlen) == 0)\n\t\t\t\treturn estrdup(name, strlen(name));\n\t\t}\n\t} else {\n\t\twhile ((name = argtab[idx].name) != NULL) {\n\t\t\tif (this_cmd != argtab[idx++].cmd)\n\t\t\t\tcontinue;\n\t\t\tif (strncmp(name, text, textlen) == 0)\n\t\t\t\treturn estrdup(name, strlen(name));\n\t\t}\n\t}\n\treturn NULL;\n}",
      "lines": 27,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nargument_generator(const char *text, int state)",
        "*"
      ]
    },
    "variable_generator": {
      "start_point": [
        1672,
        0
      ],
      "end_point": [
        1711,
        1
      ],
      "content": "static char *\nvariable_generator(const char *text, int state)\n{\n\tstatic size_t textlen;\n\tstatic int idx = 0;\n\tstatic NODE *func = NULL;\n\tstatic NODE **vars = NULL;\n\tconst char *name;\n\tNODE *r;\n\n\tif (! state) {\t/* first time */\n\t\ttextlen = strlen(text);\n\t\tif (vars != NULL)\n\t\t\tefree(vars);\n\t\tvars = variable_list();\n\t\tidx = 0;\n\t\tfunc = get_function();  /* function in current context */\n\t}\n\n\t/* function params */\n\twhile (func != NULL) {\n\t\tif (idx >= func->param_cnt) {\n\t\t\tfunc = NULL;\t/* don't try to match params again */\n\t\t\tidx = 0;\n\t\t\tbreak;\n\t\t}\n\t\tname = func->fparms[idx++].param;\n\t\tif (strncmp(name, text, textlen) == 0)\n\t\t\treturn estrdup(name, strlen(name));\n\t}\n\n\t/* globals */\n\twhile ((r = vars[idx++]) != NULL) {\n\t\tname = r->vname;\n\t\tif (strncmp(name, text, textlen) == 0)\n\t\t\treturn estrdup(name, strlen(name));\n\t}\n\n\treturn NULL;\n}",
      "lines": 40,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nvariable_generator(const char *text, int state)",
        "*"
      ]
    },
    "history_expand_line": {
      "start_point": [
        1715,
        0
      ],
      "end_point": [
        1731,
        1
      ],
      "content": "static void\nhistory_expand_line(char **line)\n{\n\tint ret;\n\tchar *expansion;\n\n\tif (! *line || input_fd != 0 || ! input_from_tty)\n\t\treturn;\n\tusing_history();\n\tret = history_expand(*line, &expansion);\n\tif (ret < 0 || ret == 2)\n\t\tefree(expansion);\n\telse {\n\t\tefree(*line);\n\t\t*line = expansion;\n\t}\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "gawk/gawk-4.2.1/custom.h": {},
  "gawk/gawk-4.2.1/debug.c": {
    "g_readline": {
      "start_point": [
        355,
        0
      ],
      "end_point": [
        390,
        1
      ],
      "content": "static char *\ng_readline(const char *prompt)\n{\n\tchar *line;\n\tsize_t line_size = 100;\n\tstatic char buf[2];\n\tchar *p, *end;\n\tint n;\n\n\tif (input_from_tty && prompt && *prompt)\n\t\tfprintf(out_fp, \"%s\", prompt);\n\n\temalloc(line, char *, line_size + 1, \"g_readline\");\n\tp = line;\n\tend = line + line_size;\n\twhile ((n = read(input_fd, buf, 1)) > 0) {\n\t\tif (buf[0] == '\\n') {\n\t\t\tif (p > line && p[-1] == '\\r')\n\t\t\t\tp--;\n\t\t\tbreak;\n\t\t}\n\t\tif (p == end) {\n\t\t\terealloc(line, char *, 2 * line_size + 1, \"g_readline\");\n\t\t\tp = line + line_size;\n\t\t\tline_size *= 2;\n\t\t\tend = line + line_size;\n\t\t}\n\t\t*p++ = buf[0];\n\t}\n\tif (n == -1 || (n == 0 && p == line)) {\n\t\tefree(line);\n\t\treturn NULL;\n\t}\n\t*p = '\\0';\n\treturn line;\n}",
      "lines": 36,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "char",
        "*\ng_readline(const char *prompt)",
        "*"
      ]
    },
    "d_error": {
      "start_point": [
        395,
        0
      ],
      "end_point": [
        404,
        1
      ],
      "content": "void\nd_error(const char *mesg, ...)\n{\n\tva_list args;\n\tva_start(args, mesg);\n\tfprintf(out_fp, _(\"error: \"));\n\tvfprintf(out_fp, mesg, args);\n\tfprintf(out_fp, \"\\n\");\n\tva_end(args);\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "find_lines": {
      "start_point": [
        408,
        0
      ],
      "end_point": [
        466,
        1
      ],
      "content": "static int\nfind_lines(SRCFILE *s)\n{\n\tchar *buf, *p, *end;\n\tint n;\n\tint ofs = 0;\n\tint *pos;\n\tint pos_size;\n\tint maxlen = 0;\n\tint numlines = 0;\n\tchar lastchar = '\\0';\n\n\temalloc(buf, char *, s->bufsize, \"find_lines\");\n\tpos_size = s->srclines;\n\temalloc(s->line_offset, int *, (pos_size + 2) * sizeof(int), \"find_lines\");\n\tpos = s->line_offset;\n\tpos[0] = 0;\n\n\twhile ((n = read(s->fd, buf, s->bufsize)) > 0) {\n\t\tend = buf + n;\n\t\tlastchar = buf[n - 1];\n\t\tp = buf;\n\t\twhile (p < end) {\n\t\t\tif (*p++ == '\\n') {\n\t\t\t\tif (++numlines > pos_size) {\n\t\t\t\t\terealloc(s->line_offset, int *, (2 * pos_size + 2) * sizeof(int), \"find_lines\");\n\t\t\t\t\tpos = s->line_offset + pos_size;\n\t\t\t\t\tpos_size *= 2;\n\t\t\t\t}\n\t\t\t\t*++pos = ofs + (p - buf);\n\t\t\t\tif ((pos[0] - pos[-1]) > maxlen)\n\t\t\t\t\tmaxlen = pos[0] - pos[-1];\t/* length including NEWLINE */\n\t\t\t}\n\t\t}\n\t\tofs += n;\n\t}\n\tefree(buf);\n\n\tif (n == -1) {\n\t\td_error(_(\"can't read source file `%s' (%s)\"),\n\t\t\t\t\ts->src, strerror(errno));\n\t\treturn -1;\n\t}\n\tif (ofs <= 0) {\n\t\tfprintf(out_fp, _(\"source file `%s' is empty.\\n\"), s->src);\n\t\treturn -1;\n\t}\n\n\tif (lastchar != '\\n') {\n\t\t/* fake a NEWLINE at end */\n\t\t*++pos = ofs + 1;\n\t\tnumlines++;\n\t\tif ((pos[0] - pos[-1]) > maxlen)\n\t\t\tmaxlen = pos[0] - pos[-1];\n\t}\n\ts->maxlen = maxlen;\n\ts->srclines = numlines;\n\treturn 0;\n}",
      "lines": 59,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "source_find": {
      "start_point": [
        470,
        0
      ],
      "end_point": [
        506,
        1
      ],
      "content": "static SRCFILE *\nsource_find(char *src)\n{\n\tSRCFILE *s;\n\tstruct stat sbuf;\n\tchar *path;\n\tint errno_val = 0;\n\n\tif (src == NULL || *src == '\\0') {\n\t\td_error(_(\"no current source file.\"));\n\t\treturn NULL;\n\t}\n\n\tif (cur_srcfile->src == src)  /* strcmp(cur_srcfile->src, src) == 0 */\n\t\treturn cur_srcfile;\n\n\tfor (s = srcfiles->next; s != srcfiles; s = s->next) {\n\t\tif ((s->stype == SRC_FILE || s->stype == SRC_INC)\n\t\t\t\t&& strcmp(s->src, src) == 0)\n\t\t\treturn s;\n\t}\n\n\tpath = find_source(src, & sbuf, & errno_val, false);\n\tif (path != NULL) {\n\t\tfor (s = srcfiles->next; s != srcfiles; s = s->next) {\n\t\t\tif ((s->stype == SRC_FILE || s->stype == SRC_INC)\n\t\t\t    \t\t&& files_are_same(path, s)) {\n\t\t\t\tefree(path);\n\t\t\t\treturn s;\n\t\t\t}\n\t\t}\n\t\tefree(path);\n\t}\n\n\td_error(_(\"cannot find source file named `%s' (%s)\"), src, strerror(errno_val));\n\treturn NULL;\n}",
      "lines": 37,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "SRCFILE",
        "*\nsource_find(char *src)",
        "*"
      ]
    },
    "print_lines": {
      "start_point": [
        510,
        0
      ],
      "end_point": [
        638,
        1
      ],
      "content": "static int\nprint_lines(char *src, int start_line, int nlines)\n{\n\tSRCFILE *s;\n\tint *pos;\n\tint i;\n\tstruct stat sbuf;\n\n\ts = source_find(src);\n\tif (s == NULL)\n\t\treturn -1;\n\tif (s->fd <= INVALID_HANDLE && (s->fd = srcopen(s)) <= INVALID_HANDLE) {\n\t\td_error(_(\"can't open source file `%s' for reading (%s)\"),\n\t\t\t\tsrc, strerror(errno));\n\t\treturn -1;\n\t}\n\n\tif (fstat(s->fd, &sbuf) == 0 && s->mtime < sbuf.st_mtime) {\n\t\tfprintf(out_fp, _(\"WARNING: source file `%s' modified since program compilation.\\n\"),\n\t\t\t\tsrc);\n\t\tefree(s->line_offset);\n\t\ts->line_offset = NULL;\n\t\ts->mtime = sbuf.st_mtime;\n\n\t\t/* reopen source file */\n\t\tclose(s->fd);\n\t\ts->fd = INVALID_HANDLE;\n\t\tif ((s->fd = srcopen(s)) <= INVALID_HANDLE) {\n\t\t\td_error(_(\"can't open source file `%s' for reading (%s)\"),\n\t\t\t\t\tsrc, strerror(errno));\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* set binary mode so that byte offset calculations will be right */\n\tos_setbinmode(s->fd, O_BINARY);\n\n\tif (s->line_offset == NULL && find_lines(s) != 0)\n\t\treturn -1;\n  \tif (start_line < 1 || start_line > s->srclines) {\n\t\td_error(_(\"line number %d out of range; `%s' has %d lines\"),\n\t\t\t\t\tstart_line, src, s->srclines);\n\t\treturn -1;\n\t}\n\n\tassert(nlines > 0);\n\tif ((start_line + nlines - 1) > s->srclines)\n\t\tnlines = s->srclines - start_line + 1;\n\n\tpos = s->line_offset;\n\tif (lseek(s->fd, (off_t) pos[start_line - 1], SEEK_SET) < 0) {\n\t\td_error(\"%s: %s\", src, strerror(errno));\n\t\treturn -1;\n\t}\n\n\tif (linebuf == NULL) {\n\t\temalloc(linebuf, char *, s->maxlen + 20, \"print_lines\"); /* 19 for line # */\n\t\tlinebuf_len = s->maxlen;\n\t} else if (linebuf_len < s->maxlen) {\n\t\terealloc(linebuf, char *, s->maxlen + 20, \"print_lines\");\n\t\tlinebuf_len = s->maxlen;\n\t}\n\n\tfor (i = start_line; i < start_line + nlines; i++) {\n\t\tint supposed_len, len;\n\t\tchar *p;\n\n\t\tsprintf(linebuf, \"%-8d\", i);\n\n\t\t/* mark the line about to be executed with =>; nlines > 1\n\t \t * condition makes sure that we are in list command\n\t\t */\n\t\tif (nlines > 1) {\n\t\t\tBREAKPOINT *b;\n\t\t\tbool has_bpt = false;\n\t\t\tfor (b = breakpoints.prev; b != &breakpoints; b = b->prev) {\n\t\t\t\tif (src == b->src && i == b->bpi->source_line) {\n\t\t\t\t\thas_bpt = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (prog_running && src == source && i == sourceline) {\n\t\t\t\tif (has_bpt)\n\t\t\t\t\tsprintf(linebuf, \"%-4d:b=>\", i);\n\t\t\t\telse\n\t\t\t\t\tsprintf(linebuf, \"%-4d  =>\", i);\n\t\t\t} else if (has_bpt)\n\t\t\t\tsprintf(linebuf, \"%-4d:b  \", i);\n\t\t}\n\n\t\tp = linebuf + strlen(linebuf);\n\t\tsupposed_len = pos[i] - pos[i - 1];\n\t\tlen = read(s->fd, p, supposed_len);\n\t\tswitch (len) {\n\t\tcase -1:\n\t\t\td_error(_(\"can't read source file `%s' (%s)\"),\n\t\t\t\t\t\tsrc, strerror(errno));\n\t\t\treturn -1;\n\n\t\tcase 0:\n\t\t\td_error(_(\"unexpected eof while reading file `%s', line %d\"),\n\t\t\t\t\t\tsrc, i);\n\t\t\treturn -1;\n\n\t\tdefault:\n\t\t\tif (i == s->srclines && p[len - 1] != '\\n')\n\t\t\t\tp[len++] = '\\n';\n#if 0\n\t\t\tif (len != supposed_len || p[len - 1] != '\\n') {\n\t\t\t\td_error(_(\"source file `%s' modified since start of program execution\"),\n\t\t\t\t\t\tsrc);\n\t\t\t\treturn -1;\n\t\t\t}\n#endif\n\t\t\tlen += (p - linebuf);\n\t\t\tif (fwrite(linebuf, sizeof(char), len, out_fp) != len)\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (cur_srcfile != s) {\n\t\tif (cur_srcfile->fd != INVALID_HANDLE) {\n\t\t\tclose(cur_srcfile->fd);\n\t\t\tcur_srcfile->fd = INVALID_HANDLE;\n\t\t}\n\t\tcur_srcfile = s;\n\t}\n\treturn (i - 1);\t\t/* no of lines printed */\n}",
      "lines": 129,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "do_list": {
      "start_point": [
        642,
        0
      ],
      "end_point": [
        717,
        1
      ],
      "content": "int\ndo_list(CMDARG *arg, int cmd ATTRIBUTE_UNUSED)\n{\n\tlong line_first, line_last;\n\tlong count = list_size;\n\tINSTRUCTION *rp;\n\tchar *src = cur_srcfile->src;\n\n\tline_first = last_printed_line + 1;\t\t/* default or no arg */\n\tif (arg == NULL)\t/* list or list + */\n\t\tgoto list;\n\n\tswitch (arg->type) {\n\tcase D_int:\t\t/* list n or list - */\n\t\tif (arg->a_int < 0) {\t\t/* list - */\n\t\t\tline_first = last_printed_line - last_print_count - list_size + 1;\n\t\t\tif (line_first < 1) {\n\t\t\t\tif (last_printed_line != last_print_count)\n\t\t\t\t\tline_first = 1;\n\t\t\t\telse\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t} else {\nline:\n\t\t\tline_first = arg->a_int - list_size / 2;\n\t\t\tif (line_first < 1)\n\t\t\t\tline_first = 1;\n\t\t}\n\t\tbreak;\n\n\tcase D_range:\t/* list m-n */\nrange:\n\t\tline_first = arg->a_int;\n\t\targ = arg->next;\n\t\tassert(arg != NULL);\n\t\tassert(arg->type == D_int);\n\t\tcount = arg->a_int - line_first + 1;\n\t\tbreak;\n\n\tcase D_string:\n\t\tsrc = arg->a_string;\n\t\tif (arg->next != NULL) {\n\t\t\targ = arg->next;\n\t\t\tif (arg->type == D_int)\t/* list file:n */\n\t\t\t\tgoto line;\n\t\t\telse if (arg->type == D_range)\t/* list file:m-n */\n\t\t\t\tgoto range;\n\t\t\telse if (arg->type == D_func)\t/* list file:function */\n\t\t\t\tgoto func;\n\t\t\telse\n\t\t\t\tline_first = 1;\n\t\t} else\n\t\t\tline_first = 1;\n\t\tbreak;\n\n\tcase D_func:\t/* list function */\nfunc:\n\t\trp = arg->a_node->code_ptr;\n\t\tsrc = rp->source_file;\n\t\tline_first = rp->source_line - list_size / 2;\n\t\tif (line_first < 1)\n\t\t\tline_first = 1;\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n \t}\n\nlist:\n\tline_last = print_lines(src, line_first, count);\n\tif (line_last != -1) {\n\t\tlast_printed_line = line_last;\n\t\tlast_print_count = line_last - line_first + 1;\n\t}\n\treturn false;\n}",
      "lines": 76,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "do_info": {
      "start_point": [
        721,
        0
      ],
      "end_point": [
        936,
        1
      ],
      "content": "int\ndo_info(CMDARG *arg, int cmd ATTRIBUTE_UNUSED)\n{\n\tNODE **table;\n\n\tif (arg == NULL || arg->type != D_argument)\n\t\treturn false;\n\n\tswitch (arg->a_argument) {\n\tcase A_SOURCE:\n\t\tfprintf(out_fp, _(\"Current source file: %s\\n\"), cur_srcfile->src);\n\t\tfprintf(out_fp, _(\"Number of lines: %d\\n\"), cur_srcfile->srclines);\n\t\tbreak;\n\n\tcase A_SOURCES:\n\t{\n\t\tSRCFILE *s;\n\t\tfor (s = srcfiles->next; s != srcfiles; s = s->next) {\n\t\t\tfprintf(out_fp, _(\"Source file (lines): %s (%d)\\n\"),\n\t\t\t\t\t(s->stype == SRC_FILE || s->stype == SRC_INC) ? s->src\n\t\t\t \t\t                                      : \"cmd. line\",\n\t\t\t\t\ts->srclines);\n\t\t}\n\t}\n\t\tbreak;\n\n\tcase A_BREAK:\n\t\tinitialize_pager(out_fp);\n\t\tif (setjmp(pager_quit_tag) == 0) {\n\t\t\tBREAKPOINT *b;\n\t\t\tstruct commands_item *c;\n\n\t\t\tgprintf(out_fp, _(\"Number  Disp  Enabled  Location\\n\\n\"));\n\t\t\tfor (b = breakpoints.prev; b != &breakpoints; b = b->prev) {\n\t\t\t\tchar *disp = \"keep\";\n\t\t\t\tif ((b->flags & BP_ENABLE_ONCE) != 0)\n\t\t\t\t\tdisp = \"dis\";\n\t\t\t\telse if ((b->flags & BP_TEMP) != 0)\n\t\t\t\t\tdisp = \"del\";\n\t\t\t\tgprintf(out_fp, \"%-6d  %-4.4s  %-7.7s  file %s, line #%d\\n\",\n\t\t\t\t\t\tb->number, disp, (b->flags & BP_ENABLE) != 0 ? \"yes\" : \"no\",\n\t\t\t\t\t \tb->src,\tb->bpi->source_line);\n\t\t\t\tif (b->hit_count > 0)\n\t\t\t\t\tgprintf(out_fp, _(\"\\tno of hits = %ld\\n\"), b->hit_count);\n\t\t\t\tif ((b->flags & BP_IGNORE) != 0)\n\t\t\t\t\tgprintf(out_fp, _(\"\\tignore next %ld hit(s)\\n\"), b->ignore_count);\n\t\t\t\tif (b->cndn.code != NULL)\n\t\t\t\t\tgprintf(out_fp, _(\"\\tstop condition: %s\\n\"), b->cndn.expr);\n\t\t\t\tif (b->commands.next != &b->commands)\n\t\t\t\t\tgprintf(out_fp, _(\"\\tcommands:\\n\"));\n\t\t\t\tfor (c = b->commands.next; c != &b->commands; c = c->next) {\n\t\t\t\t\tgprintf(out_fp, \"\\t%s\\n\", c->cmd_string);\n\t\t\t\t\tif (c->cmd == D_eval) {\n\t\t\t\t\t\tchar *start, *end;\n\t\t\t\t\t\tCMDARG *a = c->arg;\n\t\t\t\t\t\tstart = strchr(a->a_string, '{');\n\t\t\t\t\t\tend = strrchr(a->a_string, '}');\n\t\t\t\t\t\tif (start == NULL || end == NULL)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tstart++;\n\t\t\t\t\t\t*end = '\\0';\n\t\t\t\t\t\tgprintf(out_fp, \"%s\", start);\t/* FIXME: translate ? */\n\t\t\t\t\t\t*end = '}';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase A_FRAME:\n\t\tCHECK_PROG_RUNNING();\n\t\tfprintf(out_fp, _(\"Current frame: \"));\n\t\tprint_numbered_frame(cur_frame);\n\t\tif (cur_frame < fcall_count) {\n\t\t\tfprintf(out_fp, _(\"Called by frame: \"));\n\t\t\tprint_numbered_frame(cur_frame + 1);\n\t\t}\n\t\tif (cur_frame > 0) {\n\t\t\tfprintf(out_fp, _(\"Caller of frame: \"));\n\t\t\tprint_numbered_frame(cur_frame - 1);\n\t\t}\n\t\tbreak;\n\n\tcase A_ARGS:\n\tcase A_LOCALS:\n\t{\n\t\tNODE *f, *func;\n\t\tINSTRUCTION *pc;\n\t\tint arg_count, pcount;\n\t\tint i, from, to;\n\n\t\tCHECK_PROG_RUNNING();\n\t\tf = find_frame(cur_frame);\n\t\tfunc = f->func_node;\n\t\tif (func == NULL) {\n\t\t\t/* print ARGV ? */\n\t\t\tfprintf(out_fp, _(\"None in main().\\n\"));\n\t\t\treturn false;\n\t\t}\n\n\t\tpcount = func->param_cnt;              /* # of defined params */\n\n\t\tpc = (INSTRUCTION *) f->reti;          /* Op_func_call instruction */\n\t\targ_count = (pc + 1)->expr_count;      /* # of arguments supplied */\n\n\t\tif (arg_count > pcount)                /* extra args */\n\t\t\targ_count = pcount;\n\t\tif (arg->a_argument == A_ARGS) {\n\t\t\tfrom = 0;\n\t\t\tto = arg_count - 1;\n\t\t} else {\n\t\t\tfrom = arg_count;\n\t\t\tto = pcount - 1;\n\t\t}\n\n\t\tfor (i = from; i <= to; i++) {\n\t\t\tNODE *r;\n\t\t\tr = f->stack[i];\n\t\t\tif (r->type == Node_array_ref)\n\t\t\t\tr = r->orig_array;\n\t\t\tfprintf(out_fp, \"%s = \", func->fparms[i].param);\n\t\t\tprint_symbol(r, true);\n\t\t}\n\t\tif (to < from)\n\t\t\tfprintf(out_fp, \"%s\",\n\t\t\t\targ->a_argument == A_ARGS ?\n\t\t\t\t\t_(\"No arguments.\\n\") :\n\t\t\t\t\t_(\"No locals.\\n\"));\n\t}\n\t\tbreak;\n\n\tcase A_VARIABLES:\n\t\ttable = variable_list();\n\t\tinitialize_pager(out_fp);\n\t\tif (setjmp(pager_quit_tag) == 0) {\n\t\t\tgprintf(out_fp, _(\"All defined variables:\\n\\n\"));\n\t\t\tprint_vars(table, gprintf, out_fp);\n\t\t}\n\t\tefree(table);\n\t\tbreak;\n\n\tcase A_FUNCTIONS:\n\t\ttable = function_list(true);\n\t\tinitialize_pager(out_fp);\n\t\tif (setjmp(pager_quit_tag) == 0) {\n\t\t\tgprintf(out_fp, _(\"All defined functions:\\n\\n\"));\n\t\t\tpf_data.print_func = gprintf;\n\t\t\tpf_data.fp = out_fp;\n\t\t\tpf_data.defn = true;\n\t\t\t(void) foreach_func(table,\n\t\t\t            (int (*)(INSTRUCTION *, void *)) print_function,\n\t\t\t            &pf_data);\n\t\t}\n\t\tefree(table);\n\t\tbreak;\n\n\tcase A_DISPLAY:\n\tcase A_WATCH:\n\t\tinitialize_pager(out_fp);\n\t\tif (setjmp(pager_quit_tag) == 0) {\n\t\t\tstruct list_item *d, *list;\n\n\t\t\tif (arg->a_argument == A_DISPLAY) {\n\t\t\t\tlist = &display_list;\n\t\t\t\tgprintf(out_fp, _(\"Auto-display variables:\\n\\n\"));\n\t\t\t} else {\n\t\t\t\tlist = &watch_list;\n\t\t\t\tgprintf(out_fp, _(\"Watch variables:\\n\\n\"));\n\t\t\t}\n\t\t\tfor (d = list->prev; d != list; d = d->prev) {\n\t\t\t\tint i;\n\t\t\t\tstruct commands_item *c;\n\t\t\t\tNODE *symbol = d->symbol;\n\n\t\t\t\tif (IS_SUBSCRIPT(d)) {\n\t\t\t\t\tgprintf(out_fp, \"%d:\\t%s\",  d->number, d->sname);\n\t\t\t\t\tfor (i = 0; i < d->num_subs; i++) {\n\t\t\t\t\t\tNODE *sub;\n\t\t\t\t\t\tsub = d->subs[i];\n\t\t\t\t\t\tgprintf(out_fp, \"[\\\"%.*s\\\"]\", (int) sub->stlen, sub->stptr);\n\t\t\t\t\t}\n\t\t\t\t\tgprintf(out_fp, \"\\n\");\n\t\t\t\t} else if (IS_FIELD(d))\n\t\t\t\t\tgprintf(out_fp, \"%d:\\t$%ld\\n\", d->number, get_number_si(symbol));\n\t\t\t\telse\n\t\t\t\t\tgprintf(out_fp, \"%d:\\t%s\\n\", d->number, d->sname);\n\t\t\t\tif (d->cndn.code != NULL)\n\t\t\t\t\tgprintf(out_fp, _(\"\\tstop condition: %s\\n\"), d->cndn.expr);\n\t\t\t\tif (d->commands.next != &d->commands)\n\t\t\t\t\tgprintf(out_fp, _(\"\\tcommands:\\n\"));\n\t\t\t\tfor (c = d->commands.next; c != &d->commands; c = c->next) {\n\t\t\t\t\tgprintf(out_fp, \"\\t%s\\n\", c->cmd_string);\n\t\t\t\t\tif (c->cmd == D_eval) {\n\t\t\t\t\t\tchar *start, *end;\n\t\t\t\t\t\tCMDARG *a = c->arg;\n\t\t\t\t\t\tstart = strchr(a->a_string, '{');\n\t\t\t\t\t\tend = strrchr(a->a_string, '}');\n\t\t\t\t\t\tif (start == NULL || end == NULL)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tstart++;\n\t\t\t\t\t\t*end = '\\0';\n\t\t\t\t\t\tgprintf(out_fp, \"%s\", start);\t/* FIXME: translate ? */\n\t\t\t\t\t\t*end = '}';\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn false;\n}",
      "lines": 216,
      "depth": 19,
      "decorators": [
        "int"
      ]
    },
    "print_symbol": {
      "start_point": [
        940,
        0
      ],
      "end_point": [
        961,
        1
      ],
      "content": "static void\nprint_symbol(NODE *r, bool isparam)\n{\n\tswitch (r->type) {\n\tcase Node_var_new:\n\t\tfprintf(out_fp, \"untyped variable\\n\");\n\t\tbreak;\n\tcase Node_var:\n\t\tif (! isparam && r->var_update)\n\t\t\tr->var_update();\n\t\tvalinfo(r->var_value, fprintf, out_fp);\n\t\tbreak;\n\tcase Node_var_array:\n\t\tfprintf(out_fp, \"array, %ld elements\\n\", assoc_length(r));\n\t\tbreak;\n\tcase Node_func:\n\t\tfprintf(out_fp, \"`function'\\n\");\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}",
      "lines": 22,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "find_frame": {
      "start_point": [
        965,
        0
      ],
      "end_point": [
        976,
        1
      ],
      "content": "static NODE *\nfind_frame(long num)\n{\n\tassert(num >= 0);\n\tif (num == 0)\n\t\treturn frame_ptr;\n\n\tassert(prog_running == true);\n\tassert(num <= fcall_count);\n\tassert(fcall_list[num] != NULL);\n\treturn fcall_list[num];\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "NODE",
        "*\nfind_frame(long num)",
        "*"
      ]
    },
    "find_param": {
      "start_point": [
        980,
        0
      ],
      "end_point": [
        1012,
        1
      ],
      "content": "static NODE *\nfind_param(const char *name, long num, char **pname)\n{\n\tNODE *r = NULL;\n\tNODE *f;\n\tchar *fparam;\n\n\tif (pname)\n\t\t*pname = NULL;\n\n\tif (num < 0 || num > fcall_count || name == NULL)\n\t\treturn NULL;\n\tf = find_frame(num);\n\tif (f->func_node != NULL) {\t\t/* in function */\n\t\tNODE *func;\n\t\tint i, pcount;\n\n\t\tfunc = f->func_node;\n\t\tpcount = func->param_cnt;\n\t\tfor (i = 0; i < pcount; i++) {\n\t\t\tfparam = func->fparms[i].param;\n\t\t\tif (strcmp(name, fparam) == 0) {\n\t\t\t\tr = f->stack[i];\n\t\t\t\tif (r->type == Node_array_ref)\n\t\t\t\t\tr = r->orig_array;\n\t\t\t\tif (pname)\n\t\t\t\t\t*pname = fparam;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn r;\n}",
      "lines": 33,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "NODE",
        "*\nfind_param(const char *name, long num, char **pname)",
        "*"
      ]
    },
    "find_symbol": {
      "start_point": [
        1016,
        0
      ],
      "end_point": [
        1030,
        1
      ],
      "content": "static\nNODE *find_symbol(const char *name, char **pname)\n{\n\tNODE *r = NULL;\n\n\tif (pname)\n\t\t*pname = NULL;\n\tif (prog_running)\n\t\tr = find_param(name, cur_frame, pname);\n\tif (r == NULL)\n\t\tr = lookup(name);\n\tif (r == NULL)\n\t\tfprintf(out_fp, _(\"no symbol `%s' in current context\\n\"), name);\n\treturn r;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "NODE",
        "*find_symbol(const char *name, char **pname)",
        "*"
      ]
    },
    "find_array": {
      "start_point": [
        1034,
        0
      ],
      "end_point": [
        1044,
        1
      ],
      "content": "static NODE *\nfind_array(const char *name)\n{\n\tNODE *r;\n\tr = find_symbol(name, NULL);\n\tif (r != NULL && r->type != Node_var_array) {\n\t\tfprintf(out_fp, _(\"`%s' is not an array\\n\"), name);\n\t\treturn NULL;\n\t}\n\treturn r;\n}",
      "lines": 11,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "NODE",
        "*\nfind_array(const char *name)",
        "*"
      ]
    },
    "print_field": {
      "start_point": [
        1048,
        0
      ],
      "end_point": [
        1059,
        1
      ],
      "content": "static void\nprint_field(long field_num)\n{\n\tNODE **lhs;\n\tlhs = get_field(field_num, NULL);\n\tif (*lhs == Null_field || *lhs == Nnull_string)\n\t\tfprintf(out_fp, _(\"$%ld = uninitialized field\\n\"), field_num);\n\telse {\n\t\tfprintf(out_fp, \"$%ld = \", field_num);\n\t\tvalinfo(*lhs, fprintf, out_fp);\n\t}\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "print_array": {
      "start_point": [
        1063,
        0
      ],
      "end_point": [
        1106,
        1
      ],
      "content": "static int\nprint_array(volatile NODE *arr, char *arr_name)\n{\n\tNODE *subs;\n\tNODE **list;\n\tint i;\n\tsize_t num_elems = 0;\n\tvolatile NODE *r;\n\tvolatile int ret = 0;\n\tvolatile jmp_buf pager_quit_tag_stack;\n\n\tif (assoc_empty((NODE *) arr)) {\n\t\tgprintf(out_fp, _(\"array `%s' is empty\\n\"), arr_name);\n\t\treturn 0;\n\t}\n\n\tnum_elems = assoc_length((NODE *) arr);\n\n\t/* sort indices, sub_arrays are also sorted! */\n\tlist = assoc_list((NODE *) arr, \"@ind_str_asc\", SORTED_IN);\n\n\tPUSH_BINDING(pager_quit_tag_stack, pager_quit_tag, pager_quit_tag_valid);\n\tif (setjmp(pager_quit_tag) == 0) {\n\t\tfor (i = 0; ret == 0 && i < num_elems; i++) {\n\t\t\tsubs = list[i];\n\t\t\tr = *assoc_lookup((NODE *) arr, subs);\n\t\t\tif (r->type == Node_var_array)\n\t\t\t\tret = print_array(r, r->vname);\n\t\t\telse {\n\t\t\t\tgprintf(out_fp, \"%s[\\\"%.*s\\\"] = \", arr_name, (int) subs->stlen, subs->stptr);\n\t\t\t\tvalinfo((NODE *) r, gprintf, out_fp);\n\t\t\t}\n\t\t}\n\t} else\n\t\tret = 1;\n\n\tPOP_BINDING(pager_quit_tag_stack, pager_quit_tag, pager_quit_tag_valid);\n\n\tfor (i = 0; i < num_elems; i++)\n\t\tunref(list[i]);\n\tefree(list);\n\n\treturn ret;\n}",
      "lines": 44,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "print_subscript": {
      "start_point": [
        1110,
        0
      ],
      "end_point": [
        1131,
        1
      ],
      "content": "static void\nprint_subscript(NODE *arr, char *arr_name, CMDARG *a, int count)\n{\n\tNODE *r, *subs;\n\n\tsubs = a->a_node;\n\tr = in_array(arr, subs);\n\tif (r == NULL)\n\t\tfprintf(out_fp, _(\"[\\\"%.*s\\\"] not in array `%s'\\n\"), (int) subs->stlen, subs->stptr, arr_name);\n\telse if (r->type == Node_var_array) {\n\t\tif (count > 1)\n\t\t\tprint_subscript(r, r->vname, a->next, count - 1);\n\t\telse {\n\t\t\t/* print # of elements in array */\n\t\t\tfprintf(out_fp, \"%s = \", r->vname);\n\t\t\tprint_symbol(r, false);\n\t\t}\n\t} else {\n\t\tfprintf(out_fp, \"%s[\\\"%.*s\\\"] = \", arr_name, (int) subs->stlen, subs->stptr);\n\t\tvalinfo(r, fprintf, out_fp);\n\t}\n}",
      "lines": 22,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "do_print_var": {
      "start_point": [
        1135,
        0
      ],
      "end_point": [
        1199,
        1
      ],
      "content": "int\ndo_print_var(CMDARG *arg, int cmd ATTRIBUTE_UNUSED)\n{\n\tNODE *r;\n\tCMDARG *a;\n\tchar *name, *pname;\n\n\tfor (a = arg; a != NULL; a = a->next) {\n\t\tswitch (a->type) {\n\t\tcase D_variable:\n\t\t\tname = a->a_string;\n\t\t\tif ((r = find_symbol(name, &pname)) != NULL) {\n\t\t\t\tfprintf(out_fp, \"%s = \", name);\n\t\t\t\tprint_symbol(r, (pname != NULL));\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase D_subscript:\n\t\t\tassert(a->a_count > 0);\n\t\t\tname = a->a_string;\n\t\t\tr = find_array(name);\n\t\t\tif (r != NULL)\n\t\t\t\tprint_subscript(r, name, a->next, a->a_count);\n\t\t\tbreak;\n\n\t\tcase D_array:\n\t\t\tname = a->a_string;\n\t\t\tif ((r = find_array(name)) != NULL) {\n\t\t\t\tint count = a->a_count;\n\t\t\t\tfor (; count > 0; count--) {\n\t\t\t\t\tNODE *value, *subs;\n\t\t\t\t\ta = a->next;\n\t\t\t\t\tsubs = a->a_node;\n\t\t\t\t\tvalue = in_array(r, subs);\n\t\t\t\t\tif (value == NULL) {\n\t\t\t\t\t\tfprintf(out_fp, _(\"[\\\"%.*s\\\"] not in array `%s'\\n\"),\n\t\t\t\t\t\t\t\t\t(int) subs->stlen, subs->stptr, name);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (value->type != Node_var_array) {\n\t\t\t\t\t\tfprintf(out_fp, _(\"`%s[\\\"%.*s\\\"]' is not an array\\n\"),\n\t\t\t\t\t\t\t\t\tname, (int) subs->stlen, subs->stptr);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr = value;\n\t\t\t\t\t\tname = r->vname;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (count == 0) {\n\t\t\t\t\tinitialize_pager(out_fp);\n\t\t\t\t\tprint_array((volatile NODE *) r, name);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase D_field:\n\t\t\tprint_field(get_number_si(a->a_node));\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* notably D_node, subscript for invalid array name; skip */\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn false;\n}",
      "lines": 65,
      "depth": 21,
      "decorators": [
        "int"
      ]
    },
    "do_set_var": {
      "start_point": [
        1203,
        0
      ],
      "end_point": [
        1314,
        1
      ],
      "content": "int\ndo_set_var(CMDARG *arg, int cmd ATTRIBUTE_UNUSED)\n{\n\tNODE *r, *val;\n\tNODE **lhs;\n\tchar *name, *pname;\n\n\tswitch (arg->type) {\n\tcase D_variable:\n\t\tname = arg->a_string;\n\t\targ = arg->next;\n\t\tval = arg->a_node;\n\n\t\tif ((r = find_symbol(name, &pname)) == NULL)\n\t\t\tbreak;\n\n\t\tswitch (r->type) {\n\t\tcase Node_var_new:\n\t\t\tr->type = Node_var;\n\t\t\tr->var_value = dupnode(Nnull_string);\n\t\t\t/* fall through */\n\t\tcase Node_var:\n\t\t\tlhs = &r->var_value;\n\t\t\tunref(*lhs);\n\t\t\t*lhs = dupnode(val);\n\t\t\tif (pname == NULL && r->var_assign != NULL)\n\t\t\t\tr->var_assign();\n\t\t\tfprintf(out_fp, \"%s = \", name);\n\t\t\tprint_symbol(r, (pname != NULL));\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\td_error(_(\"`%s' is not a scalar variable\"), name);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase D_subscript:\n\t{\n\t\tNODE *subs, *value;\n\t\tint count = arg->a_count;\n\n\t\tassert(count > 0);\n\t\tname = arg->a_string;\n\t\tr = find_array(name);\n\t\tif (r == NULL)\n\t\t\tbreak;\n\t\tfor (; count > 0; count--) {\n\t\t\targ = arg->next;\n\t\t\tsubs = arg->a_node;\n\t\t\tvalue = in_array(r, subs);\n\n\t\t\tif (count == 1) {\n\t\t\t\tif (value != NULL && value->type == Node_var_array)\n\t\t\t\t\td_error(_(\"attempt to use array `%s[\\\"%.*s\\\"]' in a scalar context\"),\n\t\t\t\t\t\t\t\tname, (int) subs->stlen, subs->stptr);\n\t\t\t\telse {\n\t\t\t\t\targ = arg->next;\n\t\t\t\t\tval = arg->a_node;\n\t\t\t\t\tlhs = assoc_lookup(r, subs);\n\t\t\t\t\tunref(*lhs);\n\t\t\t\t\t*lhs = dupnode(val);\n\t\t\t\t\tfprintf(out_fp, \"%s[\\\"%.*s\\\"] = \", name, (int) subs->stlen, subs->stptr);\n\t\t\t\t\tvalinfo(*lhs, fprintf, out_fp);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (value == NULL) {\n\t\t\t\t\tNODE *array;\n\t\t\t\t\tarray = make_array();\n\t\t\t\t\tarray->vname = estrdup(subs->stptr, subs->stlen);\n\t\t\t\t\tarray->parent_array = r;\n\t\t\t\t\tlhs = assoc_lookup(r, subs);\n\t\t\t\t\tunref(*lhs);\n\t\t\t\t\t*lhs = array;\n\t\t\t\t\tr = array;\n\t\t\t\t} else if (value->type != Node_var_array) {\n\t\t\t\t\td_error(_(\"attempt to use scalar `%s[\\\"%.*s\\\"]' as array\"),\n\t\t\t\t\t\t\tname, (int) subs->stlen, subs->stptr);\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tr = value;\n\t\t\t\t\tname = r->vname;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\tbreak;\n\n\tcase D_field:\n\t{\n\t\tlong field_num;\n\t\tFunc_ptr assign = NULL;\n\n\t\tfield_num = get_number_si(arg->a_node);\n\t\tassert(field_num >= 0);\n\t\targ = arg->next;\n\t\tval = arg->a_node;\n\t\tlhs = get_field(field_num, &assign);\n\t\tif (assign)\n\t\t\t/* call assign to copy fields before unref frees $0 */\n\t\t\tassign();\n\t\tunref(*lhs);\n\t\t*lhs = dupnode(val);\n\t\tprint_field(field_num);\n\t}\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\treturn false;\n}",
      "lines": 112,
      "depth": 20,
      "decorators": [
        "int"
      ]
    },
    "find_item": {
      "start_point": [
        1318,
        0
      ],
      "end_point": [
        1330,
        1
      ],
      "content": "static struct list_item *\nfind_item(struct list_item *list, long num)\n{\n\tstruct list_item *d;\n\n\tif (num <= 0)\n\t\treturn NULL;\n\tfor (d = list->next; d != list; d = d->next) {\n\t\tif (d->number == num)\n\t\t\treturn d;\n\t}\n\treturn NULL;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "struct list_item",
        "struct",
        "list_item",
        "*\nfind_item(struct list_item *list, long num)",
        "*"
      ]
    },
    "delete_item": {
      "start_point": [
        1334,
        0
      ],
      "end_point": [
        1365,
        1
      ],
      "content": "static void\ndelete_item(struct list_item *d)\n{\n\tstruct commands_item *c;\n\tint i;\n\n\tif (IS_SUBSCRIPT(d)) {\n\t\tfor (i = 0; i < d->num_subs; i++)\n\t\t\tunref(d->subs[i]);\n\t\tefree(d->subs);\n\t} else if (IS_FIELD(d))\n\t\tunref(d->symbol);\n\n\tif ((d->flags & CUR_IS_ARRAY) == 0)\n\t\tunref(d->cur_value);\n\tif ((d->flags & OLD_IS_ARRAY) == 0)\n\t\tunref(d->old_value);\n\n\t/* delete commands */\n\tfor (c = d->commands.next; c != &d->commands; c = c->next) {\n\t\tc = c->prev;\n\t\tdelete_commands_item(c->next);\n\t}\n\n\tfree_context(d->cndn.ctxt, false);\n\tif (d->cndn.expr != NULL)\n\t\tefree(d->cndn.expr);\n\n\td->next->prev = d->prev;\n\td->prev->next = d->next;\n\tefree(d);\n}",
      "lines": 32,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "add_item": {
      "start_point": [
        1369,
        0
      ],
      "end_point": [
        1404,
        1
      ],
      "content": "static struct list_item *\nadd_item(struct list_item *list, int type, NODE *symbol, char *pname)\n{\n\tstruct list_item *d;\n\n\tezalloc(d, struct list_item *, sizeof(struct list_item), \"add_item\");\n\td->commands.next = d->commands.prev = &d->commands;\n\n\td->number = ++list->number;\n\td->sname = symbol->vname;\n\tif (pname != NULL) {\t/* function param */\n\t\td->sname = pname;\n\t\td->flags |= PARAM;\n\t\td->fcall_count = fcall_count - cur_frame;\n\t}\n\n\tif (type == D_field) {\n\t\t/* field number */\n\t\td->symbol = symbol;\n\t\td->flags |= FIELD_NUM;\n\t} else if (type == D_subscript) {\n\t\t/* subscript */\n\t\td->symbol = symbol;\n\t\td->flags |= SUBSCRIPT;\n\t} else {\n\t\t/* array or variable */\n\t\td->symbol = symbol;\n\t}\n\n\t/* add to list */\n\td->next = list->next;\n\td->prev = list;\n\tlist->next = d;\n\td->next->prev = d;\n\treturn d;\n}",
      "lines": 36,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "struct list_item",
        "struct",
        "list_item",
        "*\nadd_item(struct list_item *list, int type, NODE *symbol, char *pname)",
        "*"
      ]
    },
    "do_add_item": {
      "start_point": [
        1408,
        0
      ],
      "end_point": [
        1468,
        1
      ],
      "content": "static struct list_item *\ndo_add_item(struct list_item *list, CMDARG *arg)\n{\n\tNODE *symbol = NULL;\n\tchar *name, *pname = NULL;\n\tstruct list_item *item = NULL;\n\n\tswitch (arg->type) {\n\tcase D_subscript:\n\tcase D_variable:\n\t\tname = arg->a_string;\n\t\tif ((symbol = find_symbol(name, &pname)) == NULL)\n\t\t\treturn NULL;\n\t\tif (symbol->type == Node_func) {\n\t\t\td_error(_(\"`%s' is a function\"), name);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (arg->type == D_subscript && symbol->type != Node_var_array) {\n\t\t\td_error(_(\"`%s' is not an array\\n\"), name);\n\t\t\treturn NULL;\n\t\t}\n\n\t\titem = add_item(list, arg->type, symbol, pname);\n\t\tif (item != NULL && arg->type == D_subscript) {\n\t\t\tNODE **subs;\n\t\t\tint count = arg->a_count;\n\t\t\tint i;\n\n\t\t\tassert(count > 0);\n\t\t\temalloc(subs, NODE **, count * sizeof(NODE *), \"do_add_item\");\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\targ = arg->next;\n\t\t\t\tsubs[i] = dupnode(arg->a_node);\n\t\t\t\tsubs[i] = force_string(subs[i]);\n\t\t\t}\n\t\t\titem->subs = subs;\n\t\t\titem->num_subs = count;\n\t\t}\n\t\tbreak;\n\n\tcase D_field:\n\t\tsymbol = dupnode(arg->a_node);\n\t\titem = add_item(list, D_field, symbol, NULL);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\t/* watch condition if any */\n\tif (list == &watch_list) {\n\t\targ = arg->next;\n\t\tif (item != NULL && arg != NULL) {\n\t\t\tif (parse_condition(D_watch, item->number, arg->a_string) == 0)\n\t\t\t\targ->a_string = NULL;\t/* don't let free_cmdarg free it */\n\t\t\telse\n\t\t\t\tfprintf(out_fp, _(\"watchpoint %d is unconditional\\n\"), item->number);\n\t\t}\n\t}\n\treturn item;\n}",
      "lines": 61,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "struct list_item",
        "struct",
        "list_item",
        "*\ndo_add_item(struct list_item *list, CMDARG *arg)",
        "*"
      ]
    },
    "do_delete_item": {
      "start_point": [
        1472,
        0
      ],
      "end_point": [
        1507,
        1
      ],
      "content": "static void\ndo_delete_item(struct list_item *list, CMDARG *arg)\n{\n\tif (arg == NULL) {\n\t\twhile (list->next != list)\n\t\t\tdelete_item(list->next);\n\t}\n\n\tfor (; arg != NULL; arg = arg->next) {\n\t\tstruct list_item *d;\n\t\tif (arg->type == D_range) {\n\t\t\tlong i, j;\n\n\t\t\ti = arg->a_int;\n\t\t\targ = arg->next;\n\t\t\tj = arg->a_int;\n\t\t\tif (j > list->number)\n\t\t\t\tj = list->number;\n\t\t\tfor (; i <= j; i++) {\n\t\t\t\tif ((d = find_item(list, i)) != NULL)\n\t\t\t\t\tdelete_item(d);\n\t\t\t}\n\t\t} else {\n\t\t\tif ((d = find_item(list, arg->a_int)) == NULL) {\n\t\t\t\t/* split into two for easier message translation */\n\t\t\t\tif (list == &display_list)\n\t\t\t\t\td_error(_(\"No display item numbered %ld\"),\n\t\t\t\t\t\targ->a_int);\n\t\t\t\telse\n\t\t\t\t\td_error(_(\"No watch item numbered %ld\"),\n\t\t\t\t\t\targ->a_int);\n\t\t\t} else\n\t\t\t\tdelete_item(d);\n\t\t}\n\t}\n}",
      "lines": 36,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "display": {
      "start_point": [
        1511,
        0
      ],
      "end_point": [
        1552,
        1
      ],
      "content": "static void\ndisplay(struct list_item *d)\n{\n\tNODE *symbol;\n\n\tsymbol = d->symbol;\n\tif (IS_PARAM(d)\t&& (d->fcall_count != (fcall_count - cur_frame)))\n\t\treturn;\n\n\tif (IS_SUBSCRIPT(d)) {\n\t\tNODE *sub, *r;\n\t\tint i = 0, count = d->num_subs;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tsub = d->subs[i];\n\t\t\tr = in_array(symbol, sub);\n\t\t\tif (r == NULL) {\n\t\t\t\tfprintf(out_fp, _(\"%d: [\\\"%.*s\\\"] not in array `%s'\\n\"),\n\t\t\t\t\t\t\td->number, (int) sub->stlen, sub->stptr, d->sname);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (r->type == Node_var_array) {\n\t\t\t\tsymbol = r;\n\t\t\t\tif (i == count - 1)\t/* it's a sub-array */\n\t\t\t\t\tgoto print_sym;\t\t/* print # of elements in sub-array */\n\t\t\t} else {\n\t\t\t\tif (i != count - 1)\n\t\t\t\t\treturn;\t\t/* FIXME msg and delete item ? */\n\t\t\t\tfprintf(out_fp, \"%d: %s[\\\"%.*s\\\"] = \", d->number,\n\t\t\t\t\t\t\td->sname, (int) sub->stlen, sub->stptr);\n\t\t\t\tvalinfo(r, fprintf, out_fp);\n\t\t\t}\n\t\t}\n\t} else if (IS_FIELD(d)) {\n\t\tNODE *r = d->symbol;\n\t\tfprintf(out_fp, \"%d: \", d->number);\n\t\tprint_field(get_number_si(r));\n\t} else {\nprint_sym:\n\t\tfprintf(out_fp, \"%d: %s = \", d->number, d->sname);\n\t\tprint_symbol(symbol, IS_PARAM(d));\n\t}\n}",
      "lines": 42,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "do_display": {
      "start_point": [
        1557,
        0
      ],
      "end_point": [
        1573,
        1
      ],
      "content": "int\ndo_display(CMDARG *arg, int cmd ATTRIBUTE_UNUSED)\n{\n\tstruct list_item *d;\n\n\tif (arg == NULL) {\n\t\t/* display all items */\n\t\tfor (d = display_list.prev; d != &display_list; d = d->prev)\n\t\t\tdisplay(d);\n\t\treturn false;\n\t}\n\n\tif ((d = do_add_item(&display_list, arg)) != NULL)\n\t\tdisplay(d);\n\n\treturn false;\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "do_undisplay": {
      "start_point": [
        1577,
        0
      ],
      "end_point": [
        1582,
        1
      ],
      "content": "int\ndo_undisplay(CMDARG *arg, int cmd ATTRIBUTE_UNUSED)\n{\n\tdo_delete_item(&display_list, arg);\n\treturn false;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "condition_triggered": {
      "start_point": [
        1586,
        0
      ],
      "end_point": [
        1606,
        1
      ],
      "content": "static int\ncondition_triggered(struct condition *cndn)\n{\n\tNODE *r;\n\tint di;\n\n\tassert(cndn != NULL);\n\tif (cndn->code == NULL)\n\t\treturn true;\n\n\tpush_context(cndn->ctxt);\n\tr = execute_code((volatile INSTRUCTION *) cndn->code);\n\tpop_context();  /* switch to prev context */\n\tif (r == NULL)      /* fatal error */\n\t\treturn false;   /* not triggered */\n\n\tforce_number(r);\n\tdi = ! iszero(r);\n\tDEREF(r);\n\treturn di;\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "find_subscript": {
      "start_point": [
        1609,
        0
      ],
      "end_point": [
        1630,
        1
      ],
      "content": "static int\nfind_subscript(struct list_item *item, NODE **ptr)\n{\n\tNODE *symbol = item->symbol;\n\tNODE *sub, *r;\n\tint i = 0, count = item->num_subs;\n\n\tr = *ptr = NULL;\n\tfor (i = 0; i < count; i++) {\n\t\tsub = item->subs[i];\n\t\tr = in_array(symbol, sub);\n\t\tif (r == NULL)\n\t\t\treturn 0;\n\t\tif (r->type == Node_var_array)\n\t\t\tsymbol = r;\n\t\telse if (i < count - 1)\n\t\t\treturn -1;\n\t}\n\tif (r != NULL)\n\t\t*ptr = r;\n\treturn 0;\n}",
      "lines": 22,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cmp_val": {
      "start_point": [
        1634,
        0
      ],
      "end_point": [
        1673,
        1
      ],
      "content": "static int\ncmp_val(struct list_item *w, NODE *old, NODE *new)\n{\n\t\t/*\n\t\t *\tcase    old     new     result\n\t\t *\t------------------------------\n\t\t *\t1:      NULL    ARRAY   true\n\t\t *\t2:      NULL    SCALAR  true\n\t\t *\t3:      NULL    NULL    false\n\t\t *\t4:      SCALAR  SCALAR  cmp_node\n\t\t *\t5:      SCALAR  ARRAY   true\n\t\t *\t6:      SCALAR  NULL    true\n\t\t *\t7:      ARRAY   SCALAR  true\n\t\t *\t8:      ARRAY   ARRAY   compare size\n\t\t *\t9:      ARRAY   NULL    true\n\t\t */\n\n\tif (WATCHING_ARRAY(w)) {\n\t\tlong size = 0;\n\t\tif (! new)\t\t/* 9 */\n\t\t\treturn true;\n\t\tif (new->type == Node_val)\t/* 7 */\n\t\t\treturn true;\n\t\t/* new->type == Node_var_array */\t/* 8 */\n\t\tsize = assoc_length(new);\n\t\tif (w->cur_size == size)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\tif (! old && ! new)\t/* 3 */\n\t\treturn false;\n\tif ((! old && new)\t/* 1, 2 */\n\t\t\t|| (old && ! new))\t/* 6 */\n\t\treturn true;\n\n\tif (new->type == Node_var_array)\t/* 5 */\n\t\treturn true;\n\treturn cmp_nodes(old, new, true);\t/* 4 */\n}",
      "lines": 40,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "watchpoint_triggered": {
      "start_point": [
        1679,
        0
      ],
      "end_point": [
        1754,
        1
      ],
      "content": "static int\nwatchpoint_triggered(struct list_item *w)\n{\n\tNODE *symbol;\n\tNODE *t1, *t2;\n\n\tsymbol = w->symbol;\n\tif (IS_PARAM(w) && (w->fcall_count != (fcall_count - cur_frame)))\n\t\treturn 0; /* parameter with same name in a different function */\n\tif (! condition_triggered(&w->cndn))\n\t\treturn 0;\n\n\tt1 = w->cur_value;\n\tt2 = (NODE *) 0;\n\tif (IS_SUBSCRIPT(w))\n\t\t(void) find_subscript(w, &t2);\n\telse if (IS_FIELD(w)) {\n\t\tlong field_num;\n\t\tfield_num = get_number_si(w->symbol);\n\t\tt2 = *get_field(field_num, NULL);\n\t} else {\n\t\tswitch (symbol->type) {\n\t\tcase Node_var:\n\t\t\tt2 = symbol->var_value;\n\t\t\tbreak;\n\t\tcase Node_var_array:\n\t\t\tt2 = symbol;\n\t\t\tbreak;\n\t\tcase Node_var_new:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcant_happen();\n\t\t}\n\t}\n\n\tif (! cmp_val(w, t1, t2))\n\t\treturn 0;\n\n\t/* update old and current values */\n\n\tif ((w->flags & OLD_IS_ARRAY) == 0)\n\t\tunref(w->old_value);\n\tw->flags &= ~OLD_IS_ARRAY;\n\tif (WATCHING_ARRAY(w)) {\t/* 7, 8, 9 */\n\t\tw->old_size = w->cur_size;\n\t\tw->flags |= OLD_IS_ARRAY;\n\t\tif (! t2) {\n\t\t\tw->flags &= ~CUR_IS_ARRAY;\n\t\t\tw->cur_value = 0;\n\t\t} else if (t2->type == Node_val) {\n\t\t\tw->flags &= ~CUR_IS_ARRAY;\n\t\t\tw->cur_value = dupnode(t2);\n\t\t} else\n\t\t\tw->cur_size = (t2->type == Node_var_array) ? assoc_length(t2) : 0;\n\t} else if (! t1) { /* 1, 2 */\n\t\tw->old_value = 0;\n\t\t/* new != NULL */\n\t\tif (t2->type == Node_val)\n\t\t\tw->cur_value = dupnode(t2);\n\t\telse {\n\t\t\tw->flags |= CUR_IS_ARRAY;\n\t\t\tw->cur_size = (t2->type == Node_var_array) ? assoc_length(t2) : 0;\n\t\t}\n\t} else /* if (t1->type == Node_val) */ {\t/* 4, 5, 6 */\n\t\tw->old_value = w->cur_value;\n\t\tif (! t2)\n\t\t\tw->cur_value = 0;\n\t\telse if (t2->type == Node_var_array) {\n\t\t\tw->flags |= CUR_IS_ARRAY;\n\t\t\tw->cur_size = assoc_length(t2);\n\t\t} else\n\t\t\tw->cur_value = dupnode(t2);\n\t}\n\n\treturn w->number;\n}",
      "lines": 76,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "initialize_watch_item": {
      "start_point": [
        1758,
        0
      ],
      "end_point": [
        1798,
        1
      ],
      "content": "static int\ninitialize_watch_item(struct list_item *w)\n{\n\tNODE *t, *r;\n\tNODE *symbol = w->symbol;\n\n\tif (IS_SUBSCRIPT(w)) {\n\t\tif (find_subscript(w, &r) == -1) {\n\t\t\td_error(_(\"attempt to use scalar value as array\"));\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (r == NULL)\n\t\t\tw->cur_value = (NODE *) 0;\n\t\telse if (r->type == Node_var_array) { /* it's a sub-array */\n\t\t\tw->flags |= CUR_IS_ARRAY;\n\t\t\tw->cur_size = assoc_length(r);\n\t\t} else\n\t\t\tw->cur_value = dupnode(r);\n\t} else if (IS_FIELD(w)) {\n\t\tlong field_num;\n\t\tt = w->symbol;\n\t\tfield_num = get_number_si(t);\n\t\tr = *get_field(field_num, NULL);\n\t\tw->cur_value = dupnode(r);\n\t} else {\n\t\tif (symbol->type == Node_var_new)\n\t\t\tw->cur_value = (NODE *) 0;\n\t\telse if (symbol->type == Node_var) {\n\t\t\tr = symbol->var_value;\n\t\t\tw->cur_value = dupnode(r);\n\t\t} else if (symbol->type == Node_var_array) {\n\t\t\tw->flags |= CUR_IS_ARRAY;\n\t\t\tw->cur_size = assoc_length(symbol);\n\t\t} else if (symbol->type == Node_val && (symbol->flags & REGEX) != 0) {\n\t\t\tw->cur_value = dupnode(symbol);\n\t\t} /* else\n\t\t\tcan't happen */\n\t}\n\treturn 0;\n}",
      "lines": 41,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "do_watch": {
      "start_point": [
        1802,
        0
      ],
      "end_point": [
        1835,
        1
      ],
      "content": "int\ndo_watch(CMDARG *arg, int cmd ATTRIBUTE_UNUSED)\n{\n\tstruct list_item *w;\n\tNODE *symbol, *sub;\n\tint i;\n\n\tw = do_add_item(&watch_list, arg);\n\tif (w == NULL)\n\t\treturn false;\n\n\tif (initialize_watch_item(w) == -1) {\n\t\tdelete_item(w);\n\t\treturn false;\n\t}\n\n\tfprintf(out_fp, \"Watchpoint %d: \", w->number);\n\tsymbol = w->symbol;\n\n\t/* FIXME: common code also in print_watch_item */\n\tif (IS_SUBSCRIPT(w)) {\n\t\tfprintf(out_fp, \"%s\", w->sname);\n\t\tfor (i = 0; i < w->num_subs; i++) {\n\t\t\tsub = w->subs[i];\n\t\t\tfprintf(out_fp, \"[\\\"%.*s\\\"]\", (int) sub->stlen, sub->stptr);\n\t\t}\n\t\tfprintf(out_fp, \"\\n\");\n\t} else if (IS_FIELD(w))\n\t\tfprintf(out_fp, \"$%ld\\n\", get_number_si(symbol));\n\telse\n\t\tfprintf(out_fp, \"%s\\n\", w->sname);\n\n\treturn false;\n}",
      "lines": 34,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "do_unwatch": {
      "start_point": [
        1839,
        0
      ],
      "end_point": [
        1844,
        1
      ],
      "content": "int\ndo_unwatch(CMDARG *arg, int cmd ATTRIBUTE_UNUSED)\n{\n\tdo_delete_item(&watch_list, arg);\n\treturn false;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "frame_popped": {
      "start_point": [
        1848,
        0
      ],
      "end_point": [
        1874,
        1
      ],
      "content": "void\nframe_popped()\n{\n\tstruct list_item *item;\n\n\t/* delete all out of scope watchpoints */\n\tfor (item = watch_list.next; item != &watch_list; item = item->next) {\n\t\tif (IS_PARAM(item) && (item->fcall_count > fcall_count)) {\n\t\t\tfprintf(out_fp,\n\t\t\t\t_(\"Watchpoint %d deleted because parameter is out of scope.\\n\"),\n\t\t\t\titem->number);\n\t\t\titem = item->prev;\n\t\t\tdelete_item(item->next);\n\t\t}\n\t}\n\n\t/* delete all out of scope display items */\n\tfor (item = display_list.next; item != &display_list; item = item->next) {\n\t\tif (IS_PARAM(item) && (item->fcall_count > fcall_count)) {\n\t\t\tfprintf(out_fp,\n\t\t\t\t_(\"Display %d deleted because parameter is out of scope.\\n\"),\n\t\t\t\titem->number);\n\t\t\titem = item->prev;\n\t\t\tdelete_item(item->next);\n\t\t}\n\t}\n}",
      "lines": 27,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "print_function": {
      "start_point": [
        1880,
        0
      ],
      "end_point": [
        1904,
        1
      ],
      "content": "static int\nprint_function(INSTRUCTION *pc, void *x)\n{\n\tNODE *func;\n\tint i, pcount;\n\tstruct pf_data *data = (struct pf_data *) x;\n\tint defn = data->defn;\n\tFunc_print print_func = data->print_func;\n\tFILE *fp = data->fp;\n\n\tfunc = pc->func_body;\n\tpcount = func->param_cnt;\n\n\tprint_func(fp, \"%s(\", func->vname);\n\tfor (i = 0; i < pcount; i++) {\n\t\tprint_func(fp, \"%s\", func->fparms[i].param);\n\t\tif (i < pcount - 1)\n\t\t\tprint_func(fp, \", \");\n\t}\n\tprint_func(fp, \")\");\n\tif (defn)\n\t\tprint_func(fp, _(\" in file `%s', line %d\\n\"),\n\t\t\t\tpc->source_file, pc->source_line);\n\treturn 0;\n}",
      "lines": 25,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "print_frame": {
      "start_point": [
        1911,
        0
      ],
      "end_point": [
        1923,
        1
      ],
      "content": "static void\nprint_frame(NODE *func, char *src, int srcline)\n{\n\tif (func == NULL)\n\t\tfprintf(out_fp, \"main()\");\n\telse {\n\t\tpf_data.print_func = fprintf;\n\t\tpf_data.fp = out_fp;\n\t\tpf_data.defn = false;\n\t\t(void) print_function(func->code_ptr, &pf_data);\n\t}\n\tfprintf(out_fp, _(\" at `%s':%d\"), src, srcline);\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "print_numbered_frame": {
      "start_point": [
        1927,
        0
      ],
      "end_point": [
        1943,
        1
      ],
      "content": "static void\nprint_numbered_frame(long num)\n{\n\tNODE *f;\n\n\tassert(prog_running == true);\n\tf = find_frame(num);\n\tif (num == 0) {\n\t\tfprintf(out_fp, \"#%ld\\t \", num);\n\t\tprint_frame(f->func_node, source, sourceline);\n\t} else {\n\t\tfprintf(out_fp, _(\"#%ld\\tin \"), num);\n\t\tprint_frame(f->func_node, f->vname,\n\t\t\t((INSTRUCTION *) find_frame(num - 1)->reti)->source_line);\n\t}\n\tfprintf(out_fp, \"\\n\");\n}",
      "lines": 17,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "do_backtrace": {
      "start_point": [
        1947,
        0
      ],
      "end_point": [
        1977,
        1
      ],
      "content": "int\ndo_backtrace(CMDARG *arg, int cmd ATTRIBUTE_UNUSED)\n{\n\tlong cur = 0;\n\tlong last = fcall_count;\n\n\tCHECK_PROG_RUNNING();\n\tif (arg != NULL && arg->type == D_int) {\n\t\tlong count = arg->a_int;\n\n\t\t/* frame_ptr (frame #0),  fcall_list[1, 2, ... fcall_count] => total count */\n\t\tif (count >= 0) {\n\t\t\t/* toward outermost frame #fcall_count */\n\t\t\tlast = count - 1;\n\t\t\tif (last > fcall_count)\n\t\t\t\t last = fcall_count;\n\t\t} else {\n\t\t\t/* toward innermost frame #0 */\n\t\t\tcur = 1 + fcall_count + count;\n\t\t\tif (cur < 0)\n\t\t\t\tcur = 0;\n\t\t}\n\t}\n\n\tfor (; cur <= last; cur++) {\n\t\tprint_numbered_frame(cur);\n\t}\n\tif (cur <= fcall_count)\n\t\tfprintf(out_fp, _(\"More stack frames follow ...\\n\"));\n\treturn false;\n}",
      "lines": 31,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "print_cur_frame_and_sourceline": {
      "start_point": [
        1983,
        0
      ],
      "end_point": [
        2008,
        1
      ],
      "content": "static void\nprint_cur_frame_and_sourceline()\n{\n\tNODE *f;\n\tint srcline;\n\tchar *src;\n\n\tassert(prog_running == true);\n\tf = find_frame(cur_frame);\n\tif (cur_frame == 0) {\n\t\tsrc = source;\n\t\tsrcline = sourceline;\n\t} else {\n\t\tf = find_frame(cur_frame);\n\t\tsrc = f->vname;\n\t\tsrcline = ((INSTRUCTION *) find_frame(cur_frame - 1)->reti)->source_line;\n\t}\n\n\tfprintf(out_fp, (cur_frame > 0 ? _(\"#%ld\\tin \") : \"#%ld\\t \"), cur_frame);\n\tprint_frame(f->func_node, src, srcline);\n\tfprintf(out_fp, \"\\n\");\n\tprint_lines(src, srcline, 1);\n\tlast_printed_line = srcline - list_size / 2;\n\tif (last_printed_line < 0)\n\t\tlast_printed_line = 0;\n}",
      "lines": 26,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "do_frame": {
      "start_point": [
        2012,
        0
      ],
      "end_point": [
        2025,
        1
      ],
      "content": "int\ndo_frame(CMDARG *arg, int cmd ATTRIBUTE_UNUSED)\n{\n\tCHECK_PROG_RUNNING();\n\tif (arg && arg->type == D_int) {\n\t\tif (arg->a_int < 0 || arg->a_int > fcall_count) {\n\t\t\td_error(_(\"invalid frame number\"));\n\t\t\treturn false;\n\t\t}\n\t\tcur_frame = arg->a_int;\n\t}\n\tprint_cur_frame_and_sourceline();\n\treturn false;\n}",
      "lines": 14,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "do_up": {
      "start_point": [
        2029,
        0
      ],
      "end_point": [
        2043,
        1
      ],
      "content": "int\ndo_up(CMDARG *arg, int cmd ATTRIBUTE_UNUSED)\n{\n\tCHECK_PROG_RUNNING();\n\tif (arg != NULL && arg->type == D_int)\n\t\tcur_frame += arg->a_int;\n\telse\n\t\tcur_frame++;\n\tif (cur_frame < 0)\n\t\tcur_frame = 0;\n\telse if (cur_frame > fcall_count)\n\t\tcur_frame = fcall_count;\n\tprint_cur_frame_and_sourceline();\n\treturn false;\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "do_down": {
      "start_point": [
        2047,
        0
      ],
      "end_point": [
        2061,
        1
      ],
      "content": "int\ndo_down(CMDARG *arg, int cmd ATTRIBUTE_UNUSED)\n{\n\tCHECK_PROG_RUNNING();\n\tif (arg != NULL && arg->type == D_int)\n\t\tcur_frame -= arg->a_int;\n\telse\n\t\tcur_frame--;\n\tif (cur_frame < 0)\n\t\tcur_frame = 0;\n\telse if (cur_frame > fcall_count)\n\t\tcur_frame = fcall_count;\n\tprint_cur_frame_and_sourceline();\n\treturn false;\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "find_rule": {
      "start_point": [
        2067,
        0
      ],
      "end_point": [
        2091,
        1
      ],
      "content": "static INSTRUCTION *\nfind_rule(char *src, long lineno)\n{\n\tINSTRUCTION *rp;\n\n\t/*\n\t * FIXME: The check for zero and code that goes with it\n\t * are probably fragile.  A break with no arguments can\n\t * cause this in certain cases. Try to review how this works.\n\t */\n\tif (lineno == 0) {\n\t\tfor (rp = rule_list->nexti; rp != NULL; rp = rp->nexti) {\n\t\t\tif ((rp - 1)->source_file == src && (rp - 1)->source_line > 0)\n\t\t\t\treturn (rp - 1);\n\t\t}\n\t} else {\n\t\tfor (rp = rule_list->nexti; rp != NULL; rp = rp->nexti) {\n\t\t\tif ((rp - 1)->source_file == src\n\t\t\t\t\t&& lineno >= (rp + 1)->first_line\n\t\t\t\t\t&& lineno <= (rp + 1)->last_line)\n\t\t\t\treturn (rp - 1);\n\t\t}\n\t}\n\treturn NULL;\n}",
      "lines": 25,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "INSTRUCTION",
        "*\nfind_rule(char *src, long lineno)",
        "*"
      ]
    },
    "mk_breakpoint": {
      "start_point": [
        2097,
        0
      ],
      "end_point": [
        2124,
        1
      ],
      "content": "static INSTRUCTION *\nmk_breakpoint(char *src, int srcline)\n{\n\tINSTRUCTION *bp;\n\tBREAKPOINT *b;\n\n\tbp = bcalloc(Op_breakpoint, 1, srcline);\n\temalloc(b, BREAKPOINT *, sizeof(BREAKPOINT), \"mk_breakpoint\");\n\tmemset(&b->cndn, 0, sizeof(struct condition));\n\tb->commands.next = b->commands.prev = &b->commands;\n\tb->silent = false;\n\n\n\tb->number = ++watch_list.number;\t/* breakpoints and watchpoints use same counter */\n\tb->ignore_count = 0;\n\tb->hit_count = 0;\n\tb->flags = BP_ENABLE;\n\tb->src = src;\n\tbp->break_pt = b;\n\tb->bpi = bp;\n\n\t/* prepend to list */\n\tb->next = breakpoints.next;\n\tb->prev = &breakpoints;\n\tbreakpoints.next = b;\n\tb->next->prev = b;\n\treturn bp;\n}",
      "lines": 28,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "INSTRUCTION",
        "*\nmk_breakpoint(char *src, int srcline)",
        "*"
      ]
    },
    "delete_breakpoint": {
      "start_point": [
        2130,
        0
      ],
      "end_point": [
        2159,
        1
      ],
      "content": "static void\ndelete_breakpoint(BREAKPOINT *b)\n{\n\tINSTRUCTION *pc = b->bpi;\n\tstruct commands_item *c;\n\n\t/* N.B.: easiest thing to do is to turn Op_breakpoint into a no-op;\n\t * deleteing the instruction is not that simple,\n\t * since could have reference to it somewhere else (e.g. cur_pc).\n\t */\n\n\tpc->opcode = Op_no_op;\n\tpc->source_line = 0;\n\tpc->break_pt = NULL;\n\n\t/* delete commands */\n\tfor (c = b->commands.next; c != &b->commands; c = c->next) {\n\t\tc = c->prev;\n\t\tdelete_commands_item(c->next);\n\t}\n\n\tfree_context(b->cndn.ctxt, false);\n\tif (b->cndn.expr != NULL)\n\t\tefree(b->cndn.expr);\n\n\t/* remove from list */\n\tb->next->prev = b->prev;\n\tb->prev->next = b->next;\n\tefree(b);\n}",
      "lines": 30,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "find_breakpoint": {
      "start_point": [
        2163,
        0
      ],
      "end_point": [
        2176,
        1
      ],
      "content": "static BREAKPOINT *\nfind_breakpoint(long num)\n{\n\tBREAKPOINT *b;\n\n\tif (num <= 0)\n\t\treturn NULL;\n\n\tfor (b = breakpoints.next; b != &breakpoints; b = b->next) {\n\t\tif (b->number == num)\n\t\t\treturn b;\n\t}\n\treturn NULL;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "BREAKPOINT",
        "*\nfind_breakpoint(long num)",
        "*"
      ]
    },
    "add_breakpoint": {
      "start_point": [
        2180,
        0
      ],
      "end_point": [
        2242,
        1
      ],
      "content": "static BREAKPOINT *\nadd_breakpoint(INSTRUCTION *prevp, INSTRUCTION *ip, char *src, bool silent)\n{\n\tBREAKPOINT *b;\n\tINSTRUCTION *bp;\n\tint lineno = ip->source_line;\n\n\t/* add new breakpoint instruction at the end of\n\t * already set breakpoints at this line number.\n\t */\n\n\twhile (ip->opcode == Op_breakpoint && ip->source_line == lineno) {\n\t\tif (! silent) {\n\t\t\tb = ip->break_pt;\n\t\t\t/*\n\t\t\t * This is more verbose that it might otherwise be,\n\t\t\t * in order to provide easily translatable strings.\n\t\t\t */\n\t\t\tif ((b->flags & BP_ENABLE) != 0) {\n\t\t\t\tif ((b->flags & BP_IGNORE) != 0)\n\t\t\t\t\tfprintf(out_fp,\n\t\t\t_(\"Note: breakpoint %d (enabled, ignore next %ld hits), also set at %s:%d\"),\n\t\t\t\t\t\tb->number,\n\t\t\t\t\t\tb->ignore_count,\n\t\t\t\t\t\tb->src,\n\t\t\t\t\t\tlineno);\n\t\t\t\telse\n\t\t\t\t\tfprintf(out_fp,\n\t\t\t_(\"Note: breakpoint %d (enabled), also set at %s:%d\"),\n\t\t\t\t\t\tb->number,\n\t\t\t\t\t\tb->src,\n\t\t\t\t\t\tlineno);\n\t\t\t} else {\n\t\t\t\tif ((b->flags & BP_IGNORE) != 0)\n\t\t\t\t\tfprintf(out_fp,\n\t\t\t_(\"Note: breakpoint %d (disabled, ignore next %ld hits), also set at %s:%d\"),\n\t\t\t\t\t\tb->number,\n\t\t\t\t\t\tb->ignore_count,\n\t\t\t\t\t\tb->src,\n\t\t\t\t\t\tlineno);\n\t\t\t\telse\n\t\t\t\t\tfprintf(out_fp,\n\t\t\t_(\"Note: breakpoint %d (disabled), also set at %s:%d\"),\n\t\t\t\t\t\tb->number,\n\t\t\t\t\t\tb->src,\n\t\t\t\t\t\tlineno);\n\t\t\t}\n\t\t}\n\t\tprevp = ip;\n\t\tip = ip->nexti;\n\t}\n\n\tassert(ip->source_line == lineno);\n\n\tbp = mk_breakpoint(src, lineno);\n\tprevp->nexti = bp;\n\tbp->nexti = ip;\n\tb = bp->break_pt;\n\tif (! silent)\n\t\tfprintf(out_fp, _(\"Breakpoint %d set at file `%s', line %d\\n\"),\n\t\t\t\t\t\tb->number, src, lineno);\n\treturn b;\n}",
      "lines": 63,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "BREAKPOINT",
        "*\nadd_breakpoint(INSTRUCTION *prevp, INSTRUCTION *ip, char *src, bool silent)",
        "*"
      ]
    },
    "set_breakpoint_at": {
      "start_point": [
        2246,
        0
      ],
      "end_point": [
        2275,
        1
      ],
      "content": "static BREAKPOINT *\nset_breakpoint_at(INSTRUCTION *rp, int lineno, bool silent)\n{\n\tINSTRUCTION *ip, *prevp;\n\n\tfor (prevp = rp, ip = rp->nexti; ip; prevp = ip, ip = ip->nexti) {\n\t\tif (ip->opcode == Op_K_case) {\n\t\t\tINSTRUCTION *i1, *i2;\n\n\t\t\t/* Special case: the code line numbers for a switch do not form\n\t\t\t * a monotonically increasing sequence. Check if the line # is between\n\t\t\t * the first and last statements of the case block before continuing\n\t\t\t * the search.\n\t\t\t */\n\t\t\tfor (i2 = ip->stmt_start, i1 = i2->nexti; i2 != ip->stmt_end;\n\t\t\t\t\t\t\t\ti2 = i1, i1 = i1->nexti) {\n\t\t\t\tif (i1->source_line >= lineno)\n\t\t\t\t\treturn add_breakpoint(i2, i1, rp->source_file, silent);\n\t\t\t\tif (i1 == ip->stmt_end)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (ip->source_line >= lineno)\n\t\t\treturn add_breakpoint(prevp, ip, rp->source_file, silent);\n\t\tif (ip == (rp + 1)->lasti)\n\t\t\tbreak;\n\t}\n\treturn NULL;\n}",
      "lines": 30,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "BREAKPOINT",
        "*\nset_breakpoint_at(INSTRUCTION *rp, int lineno, bool silent)",
        "*"
      ]
    },
    "set_breakpoint_next": {
      "start_point": [
        2279,
        0
      ],
      "end_point": [
        2296,
        1
      ],
      "content": "static BREAKPOINT *\nset_breakpoint_next(INSTRUCTION *rp, INSTRUCTION *ip)\n{\n\tINSTRUCTION *prevp;\n\n\tif (ip == (rp + 1)->lasti)\n\t\treturn NULL;\n\tprevp = ip;\n\tif (ip->opcode != Op_breakpoint)\n\t\tip = ip->nexti;\n\tfor (; ip; prevp = ip, ip = ip->nexti) {\n\t\tif (ip->source_line > 0)\n\t\t\treturn add_breakpoint(prevp, ip, rp->source_file, false);\n\t\tif (ip == (rp + 1)->lasti)\n\t\t\tbreak;\n\t}\n\treturn NULL;\n}",
      "lines": 18,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "BREAKPOINT",
        "*\nset_breakpoint_next(INSTRUCTION *rp, INSTRUCTION *ip)",
        "*"
      ]
    },
    "set_breakpoint": {
      "start_point": [
        2300,
        0
      ],
      "end_point": [
        2408,
        1
      ],
      "content": "static int\nset_breakpoint(CMDARG *arg, bool temporary)\n{\n\tint lineno;\n\tBREAKPOINT *b = NULL;\n\tINSTRUCTION *rp, *ip;\n\tNODE *func;\n\tSRCFILE *s = cur_srcfile;\n\tchar *src = cur_srcfile->src;\n\n\tif (arg == NULL) {\n/*\n* (From GDB Documentation):\n*\n* When called without any arguments, break sets a breakpoint at the next instruction\n* to be executed in the selected stack frame (see section Examining the Stack).\n* In any selected frame but the innermost, this makes your program stop as soon\n* as control returns to that frame. This is similar to the effect of a finish command\n* in the frame inside the selected frame--except that finish does not leave an\n* active breakpoint. If you use break without an argument in the innermost frame,\n* GDB stops the next time it reaches the current location; this may be useful\n* inside loops.\n* GDB normally ignores breakpoints when it resumes execution, until at least\n* one instruction has been executed. If it did not do this,\n* you would be unable to proceed past a breakpoint without first disabling the\n* breakpoint. This rule applies whether or not the breakpoint already existed\n* when your program stopped.\n*/\n\t\tCHECK_PROG_RUNNING();\n\t\tif (cur_frame == 0) {\n\t\t\tsrc = source;\n\t\t\tip = cur_pc;\n\t\t} else {\n\t\t\tNODE *f;\n\t\t\tf = find_frame(cur_frame);\n\t\t\tsrc = f->vname;\n\t\t\tip = (INSTRUCTION *) find_frame(cur_frame - 1)->reti;  /* Op_func_call */\n\t\t}\n\t\trp = find_rule(src, ip->source_line);\n\t\tassert(rp != NULL);\n\t\tif ((b = set_breakpoint_next(rp, ip)) == NULL)\n\t\t\tfprintf(out_fp, _(\"Can't set breakpoint in file `%s'\\n\"), src);\n\t\telse {\n\t\t\tif (cur_frame == 0) {\t/* stop next time */\n\t\t\t\tb->flags |= BP_IGNORE;\n\t\t\t\tb->ignore_count = 1;\n\t\t\t}\n\t\t\tif (temporary)\n\t\t\t\tb->flags |= BP_TEMP;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/* arg != NULL */\n\n\tswitch (arg->type) {\n\tcase D_string:\t/* break filename:lineno|function */\n\t\ts = source_find(arg->a_string);\n\t\targ = arg->next;\n\t\tif (s == NULL || arg == NULL\n\t\t\t\t|| (arg->type != D_int && arg->type != D_func))\n\t\t\treturn false;\n\t\tsrc = s->src;\n\t\tif (arg->type == D_func) /* break filename:function */\n\t\t\tgoto func;\n\t\telse\n\t\t\t/* fall through */\n\tcase D_int:\t\t/* break lineno */\n\t\tlineno = (int) arg->a_int;\n\t\tif (lineno <= 0 || lineno > s->srclines)\n\t\t\td_error(_(\"line number %d in file `%s' out of range\"), lineno, src);\n\t\telse {\n\t\t\trp = find_rule(src, lineno);\n\t\t\tif (rp == NULL)\n\t\t\t\tfprintf(out_fp, _(\"Can't find rule!!!\\n\"));\n\t\t\tif (rp == NULL || (b = set_breakpoint_at(rp, lineno, false)) == NULL)\n\t\t\t\tfprintf(out_fp, _(\"Can't set breakpoint at `%s':%d\\n\"),\n\t\t\t\t\t\tsrc, lineno);\n\t\t\tif (b != NULL && temporary)\n\t\t\t\tb->flags |= BP_TEMP;\n\t\t}\n\t\tbreak;\n\n\tcase D_func:\t/* break function */\nfunc:\n\t\tfunc = arg->a_node;\n\t\trp = func->code_ptr;\n\t\tif ((b = set_breakpoint_at(rp, rp->source_line, false)) == NULL)\n\t\t\tfprintf(out_fp, _(\"Can't set breakpoint in function `%s'\\n\"),\n\t\t\t\t\t\tfunc->vname);\n\t\telse if (temporary)\n\t\t\tb->flags |= BP_TEMP;\n\t\tlineno = b->bpi->source_line;\n\t\tbreak;\n\n\tdefault:\n\t\treturn false;\n\t}\n\t/* condition if any */\n\targ = arg->next;\n\tif (b != NULL && arg != NULL) {\n\t\tif (parse_condition(D_break, b->number, arg->a_string) == 0)\n\t\t\targ->a_string = NULL;\t/* don't let free_cmdarg free it */\n\t\telse\n\t\t\tfprintf(out_fp, _(\"breakpoint %d set at file `%s', line %d is unconditional\\n\"),\n\t\t\t\t\t\t\tb->number, src, lineno);\n\t}\n\treturn false;\n}",
      "lines": 109,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "breakpoint_triggered": {
      "start_point": [
        2413,
        0
      ],
      "end_point": [
        2433,
        1
      ],
      "content": "static int\nbreakpoint_triggered(BREAKPOINT *b)\n{\n\tif ((b->flags & BP_ENABLE) == 0)\n\t\treturn 0;\n\tif ((b->flags & BP_IGNORE) != 0) {\n\t\tif (--b->ignore_count <= 0)\n\t\t\tb->flags &= ~BP_IGNORE;\n\t\treturn 0;\n\t}\n\n\tif (! condition_triggered(&b->cndn))\n\t\treturn 0;\n\n\tb->hit_count++;\n\tif ((b->flags & BP_ENABLE_ONCE) != 0) {\n\t\tb->flags &= ~BP_ENABLE_ONCE;\n\t\tb->flags &= ~BP_ENABLE;\n\t}\n\treturn b->number;\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "do_breakpoint": {
      "start_point": [
        2437,
        0
      ],
      "end_point": [
        2441,
        1
      ],
      "content": "int\ndo_breakpoint(CMDARG *arg, int cmd ATTRIBUTE_UNUSED)\n{\n\treturn set_breakpoint(arg, false);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "do_tmp_breakpoint": {
      "start_point": [
        2445,
        0
      ],
      "end_point": [
        2449,
        1
      ],
      "content": "int\ndo_tmp_breakpoint(CMDARG *arg, int cmd ATTRIBUTE_UNUSED)\n{\n\treturn set_breakpoint(arg, true);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "do_clear": {
      "start_point": [
        2453,
        0
      ],
      "end_point": [
        2547,
        1
      ],
      "content": "int\ndo_clear(CMDARG *arg, int cmd ATTRIBUTE_UNUSED)\n{\n\tint lineno;\n\tBREAKPOINT *b;\n\tINSTRUCTION *rp, *ip;\n\tNODE *func;\n\tSRCFILE *s = cur_srcfile;\n\tchar *src = cur_srcfile->src;\n\tint bp_found = 0;\n\n\tif (arg == NULL) {\t/* clear */\n\t\tCHECK_PROG_RUNNING();\n\t\tif (cur_frame == 0) {\n\t\t\tlineno = sourceline;\n\t\t\tsrc = source;\n\t\t} else {\n\t\t\tNODE *f;\n\t\t\tf = find_frame(cur_frame);\n\t\t\tsrc = f->vname;\n\t\t\tlineno = ((INSTRUCTION *) find_frame(cur_frame - 1)->reti)->source_line;\n\t\t}\n\t\tgoto delete_bp;\n\t}\n\n\tswitch (arg->type) {\n\tcase D_string:\t/* clear filename:lineno|function */\n\t\ts = source_find(arg->a_string);\n\t\targ = arg->next;\n\t\tif (s == NULL || arg == NULL ||\n\t\t\t\t(arg->type != D_int && arg->type != D_func))\n\t\t\treturn false;\n\t\tsrc = s->src;\n\t\tif (arg->type == D_func)\n\t\t\tgoto func;\n\t\t/* else\n\t\t\tfall through */\n\tcase D_int:\t/* clear lineno */\n\t\tlineno = (int) arg->a_int;\n\t\tif (lineno <= 0 || lineno > s->srclines) {\n\t\t\td_error(_(\"line number %d in file `%s' out of range\"), lineno, src);\n\t\t\treturn false;\n\t\t}\n\t\tbreak;\n\n\tcase D_func:\t/* clear function */\nfunc:\n\t\tfunc = arg->a_node;\n\t\trp = func->code_ptr;\n\t\tfor (ip = rp->nexti; ip; ip = ip->nexti) {\n\t\t\tif (ip->source_line <= 0)\n\t\t\t\tcontinue;\n\t\t\tif (ip->opcode != Op_breakpoint)\n\t\t\t\tbreak;\n\t\t\tb = ip->break_pt;\n\t\t\tif (++bp_found == 1)\n\t\t\t\tfprintf(out_fp, _(\"Deleted breakpoint %d\"), b->number);\n\t\t\telse\n\t\t\t\tfprintf(out_fp, \", %d\", b->number);\n\t\t\tdelete_breakpoint(b);\n\t\t}\n\t\tif (bp_found == 0)\n\t\t\tfprintf(out_fp, _(\"No breakpoint(s) at entry to function `%s'\\n\"),\n\t\t\t\t\tfunc->vname);\n\t\telse\n\t\t\tfprintf(out_fp, \"\\n\");\n\t\t/* fall through */\n\tdefault:\n\t\treturn false;\n\t}\n\ndelete_bp:\n\trp = find_rule(src, lineno);\n\tif (rp != NULL) {\n\t\tfor (ip = rp->nexti; ip; ip = ip->nexti) {\n\t\t\tif (ip->opcode == Op_breakpoint\t&& ip->source_line == lineno) {\n\t\t\t\tb = ip->break_pt;\n\t\t\t\tif (++bp_found == 1)\n\t\t\t\t\tfprintf(out_fp, _(\"Deleted breakpoint %d\"), b->number);\n\t\t\t\telse\n\t\t\t\t\tfprintf(out_fp, \", %d\", b->number);\n\t\t\t\tdelete_breakpoint(b);\n\t\t\t}\n\t\t\tif (ip == (rp + 1)->lasti)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (bp_found == 0)\n\t\tfprintf(out_fp, _(\"No breakpoint at file `%s', line #%d\\n\"),\n\t\t\t\t\tsrc, (int) lineno);\n\telse\n\t\tfprintf(out_fp, \"\\n\");\n\treturn false;\n}",
      "lines": 95,
      "depth": 16,
      "decorators": [
        "int"
      ]
    },
    "enable_breakpoint": {
      "start_point": [
        2551,
        0
      ],
      "end_point": [
        2558,
        1
      ],
      "content": "static inline void\nenable_breakpoint(BREAKPOINT *b, short disp)\n{\n\tb->flags &= ~(BP_ENABLE_ONCE|BP_TEMP);\n\tb->flags |= BP_ENABLE;\n\tif (disp)\n\t\tb->flags |= disp;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    },
    "do_enable_breakpoint": {
      "start_point": [
        2562,
        0
      ],
      "end_point": [
        2603,
        1
      ],
      "content": "int\ndo_enable_breakpoint(CMDARG *arg, int cmd ATTRIBUTE_UNUSED)\n{\n\tBREAKPOINT *b;\n\tshort disp = 0;\n\n\tif (arg != NULL && arg->type == D_argument) {\n\t\tif (arg->a_argument == A_DEL)\t/* del */\n\t\t\tdisp = BP_TEMP;\n\t\telse\t\t\t\t\t\t/* once */\n\t\t\tdisp = BP_ENABLE_ONCE;\n\t\targ = arg->next;\n\t}\n\n\tif (arg == NULL) {\t/* enable [once|del] */\n\t\tfor (b = breakpoints.next; b != &breakpoints; b = b->next)\n\t\t\tenable_breakpoint(b, disp);\n\t}\n\n\tfor (; arg != NULL; arg = arg->next) {\n\t\tif (arg->type == D_range) {\n\t\t\tlong i, j;\n\n\t\t\ti = arg->a_int;\n\t\t\targ = arg->next;\n\t\t\tj = arg->a_int;\n\t\t\tif (j > breakpoints.number)\n\t\t\t\tj = breakpoints.number;\n\t\t\tfor (; i <= j; i++) {\n\t\t\t\tif ((b = find_breakpoint(i)) != NULL)\n\t\t\t\t\tenable_breakpoint(b, disp);\n\t\t\t}\n\t\t} else {\n\t\t\tassert(arg->type == D_int);\n\t\t\tif ((b = find_breakpoint(arg->a_int)) == NULL)\n\t\t\t\td_error(_(\"invalid breakpoint number\"));\n\t\t\telse\n\t\t\t\tenable_breakpoint(b, disp);\n\t\t}\n\t}\n\treturn false;\n}",
      "lines": 42,
      "depth": 16,
      "decorators": [
        "int"
      ]
    },
    "do_delete_breakpoint": {
      "start_point": [
        2607,
        0
      ],
      "end_point": [
        2644,
        1
      ],
      "content": "int\ndo_delete_breakpoint(CMDARG *arg, int cmd ATTRIBUTE_UNUSED)\n{\n\tif (arg == NULL) {\n\t\tbool delete_all = true;\n\t\tdelete_all = prompt_yes_no(\n\t\t\t\t\t_(\"Delete all breakpoints? (y or n) \"),\n\t\t\t\t\t_(\"y\")[0], true, out_fp);\n\n\t\tif (delete_all) {\n\t\t\twhile (breakpoints.next != &breakpoints)\n\t\t\t\tdelete_breakpoint(breakpoints.next);\n\t\t}\n\t}\n\n\tfor (; arg != NULL; arg = arg->next) {\n\t\tBREAKPOINT *b;\n\t\tif (arg->type == D_range) {\n\t\t\tlong i, j;\n\n\t\t\ti = arg->a_int;\n\t\t\targ = arg->next;\n\t\t\tj = arg->a_int;\n\t\t\tif (j > breakpoints.number)\n\t\t\t\tj = breakpoints.number;\n\t\t\tfor (; i <= j; i++) {\n\t\t\t\tif ((b = find_breakpoint(i)) != NULL)\n\t\t\t\t\tdelete_breakpoint(b);\n\t\t\t}\n\t\t} else {\n\t\t\tif ((b = find_breakpoint(arg->a_int)) == NULL)\n\t\t\t\td_error(_(\"invalid breakpoint number\"));\n\t\t\telse\n\t\t\t\tdelete_breakpoint(b);\n\t\t}\n\t}\n\treturn false;\n}",
      "lines": 38,
      "depth": 16,
      "decorators": [
        "int"
      ]
    },
    "do_ignore_breakpoint": {
      "start_point": [
        2648,
        0
      ],
      "end_point": [
        2672,
        1
      ],
      "content": "int\ndo_ignore_breakpoint(CMDARG *arg, int cmd ATTRIBUTE_UNUSED)\n{\n\tBREAKPOINT *b;\n\n\tif (arg == NULL || arg->type != D_int\n\t\t\t|| arg->next == NULL || arg->next->type != D_int)\n\t\treturn false;\n\n\tif ((b = find_breakpoint(arg->a_int)) == NULL)\n\t\td_error(_(\"invalid breakpoint number\"));\n\telse {\n\t\tb->ignore_count = arg->next->a_int;\n\t\tif (b->ignore_count > 0) {\n\t\t\tb->flags |= BP_IGNORE;\n\t\t\tfprintf(out_fp, _(\"Will ignore next %ld crossing(s) of breakpoint %d.\\n\"),\n\t\t\t\t\tb->ignore_count, b->number);\n\t\t} else {\n\t\t\tb->flags &= ~BP_IGNORE;\n \t\t\tfprintf(out_fp, _(\"Will stop next time breakpoint %d is reached.\\n\"),\n\t\t\t\t\tb->number);\n\t\t}\n\t}\n\treturn false;\n}",
      "lines": 25,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "do_disable_breakpoint": {
      "start_point": [
        2676,
        0
      ],
      "end_point": [
        2707,
        1
      ],
      "content": "int\ndo_disable_breakpoint(CMDARG *arg, int cmd ATTRIBUTE_UNUSED)\n{\n\tBREAKPOINT *b;\n\n\tif (arg == NULL) {\n\t\t/* disable all */\n\t\tfor (b = breakpoints.next; b != &breakpoints; b = b->next)\n\t\t\tb->flags &= ~BP_ENABLE;\n\t}\n\n\tfor (; arg != NULL; arg = arg->next) {\n\t\tif (arg->type == D_range) {\n\t\t\tlong i, j;\n\n\t\t\ti = arg->a_int;\n\t\t\targ = arg->next;\n\t\t\tj = arg->a_int;\n\t\t\tif (j > breakpoints.number)\n\t\t\t\tj = breakpoints.number;\n\t\t\tfor (; i <= j; i++)\n\t\t\t\tif ((b = find_breakpoint(i)) != NULL)\n\t\t\t\t\tb->flags &= ~BP_ENABLE;\n\t\t} else {\n\t\t\tif ((b = find_breakpoint(arg->a_int)) == NULL)\n\t\t\t\td_error(_(\"invalid breakpoint number\"));\n\t\t\telse\n\t\t\t\tb->flags &= ~BP_ENABLE;\n\t\t}\n\t}\n\treturn false;\n}",
      "lines": 32,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "get_function": {
      "start_point": [
        2713,
        0
      ],
      "end_point": [
        2722,
        1
      ],
      "content": "NODE *\nget_function()\n{\n\tNODE *func;\n\n\tif (! prog_running)\n\t\treturn NULL;\n\tfunc = find_frame(cur_frame)->func_node;\n\treturn func;\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "NODE",
        "*\nget_function()",
        "*"
      ]
    },
    "initialize_readline": {
      "start_point": [
        2726,
        0
      ],
      "end_point": [
        2741,
        1
      ],
      "content": "static void\ninitialize_readline()\n{\n\t/* tell readline which stream to use for output,\n\t * default input stream is stdin.\n\t */\n\trl_outstream = out_fp;\n\n\t/* allow conditional parsing of the ~/.inputrc file. */\n\trl_readline_name = \"gawk\";\n\n\t/* our completion function. */\n\trl_attempted_completion_function = command_completion;\n\n\tread_a_line = readline;\n}",
      "lines": 16,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "init_debug": {
      "start_point": [
        2749,
        0
      ],
      "end_point": [
        2753,
        1
      ],
      "content": "void\ninit_debug()\n{\n\tregister_exec_hook(debug_pre_execute, debug_post_execute);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "debug_prog": {
      "start_point": [
        2758,
        0
      ],
      "end_point": [
        2837,
        1
      ],
      "content": "int\ndebug_prog(INSTRUCTION *pc)\n{\n\tchar *run;\n\n\tinput_fd = fileno(stdin);\n\tout_fp = stdout;\n\tif (os_isatty(input_fd))\n\t\tinput_from_tty = true;\n\tif (input_fd == 0 && input_from_tty)\n\t\tinitialize_readline();\n\n\tif (! read_a_line)\n\t\tread_a_line = g_readline;\n\n\tpush_cmd_src(input_fd, input_from_tty, read_a_line, 0, 0, EXIT_FATAL);\n\n\tsetbuf(out_fp, (char *) NULL);\n\tfor (cur_srcfile = srcfiles->prev; cur_srcfile != srcfiles;\n\t\t\tcur_srcfile = cur_srcfile->prev) {\n\t\tif (cur_srcfile->stype == SRC_FILE\n\t\t\t|| cur_srcfile->stype == SRC_INC)\n\t\t\tbreak;\n\t}\n\n\tif (cur_srcfile == srcfiles) {\n\t\tfprintf(out_fp, _(\"Can only debug programs provided with the `-f' option.\\n\"));\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tdgawk_prompt = estrdup(DEFAULT_PROMPT, strlen(DEFAULT_PROMPT));\n\tdbg_prompt = dgawk_prompt;\n\n\tmemset(&stop, 0, sizeof(stop));\n\tstop.command = D_illegal;\n\n\tif ((run = getenv(\"DGAWK_RESTART\")) != NULL) {\n\t\t/* We are restarting; restore state (breakpoints, history etc.)\n\t\t * passed as environment variables and optionally execute the run command.\n\t\t */\n\t\tunserialize_list(BREAK);\n\t\tunserialize_list(WATCH);\n\t\tunserialize_list(DISPLAY);\n\t\tunserialize_list(HISTORY);\n\t\tunserialize_list(OPTION);\n\t\tunsetenv(\"DGAWK_RESTART\");\n\t\tfprintf(out_fp, \"Restarting ...\\n\");\n\t\tif (strcasecmp(run, \"true\") == 0)\n\t\t\t(void) do_run(NULL, 0);\n\n\t} else if (command_file != NULL) {\n\t\t/* run commands from a file (--debug=file  or -D file) */\n\t\tint fd;\n\t\tfd = open_readfd(command_file);\n\t\tif (fd == INVALID_HANDLE) {\n\t\t\tfprintf(stderr, _(\"can't open source file `%s' for reading (%s)\"),\n\t\t\t\t\t\tcommand_file, strerror(errno));\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\tpush_cmd_src(fd, false, g_readline, close, 0, EXIT_FAILURE);\n\t\tcmd_src->str = estrdup(command_file, strlen(command_file));\n\n\t} else {\n\t\tint fd;\n\n#ifdef HAVE_LIBREADLINE\n\t\t(void) read_history(history_file);\n\t\tsess_history_base = history_length;\n#endif\n\n\t\t/* read saved options */\n\t\tfd = open_readfd(options_file);\n\t\tif (fd > INVALID_HANDLE)\n\t\t\tpush_cmd_src(fd, false, g_readline, close, 0, EXIT_SUCCESS);\n\t}\n\n\t/* start the command interpreter */\n\tread_command();\t/* yyparse */\n\treturn EXIT_SUCCESS;\n}",
      "lines": 80,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "check_watchpoint": {
      "start_point": [
        2844,
        0
      ],
      "end_point": [
        2860,
        1
      ],
      "content": "static int\ncheck_watchpoint()\n{\n\tstruct list_item *w;\n\n\tif (stop.command == D_return)\n\t\treturn false;\n\tfor (w = watch_list.prev; w != &watch_list; w = w->prev) {\n\t\tint wnum = watchpoint_triggered(w);\n\t\tif (wnum > 0) {\n\t\t\tstop.watch_point = wnum;\n\t\t\tstop.print_frame = true;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "check_breakpoint": {
      "start_point": [
        2864,
        0
      ],
      "end_point": [
        2885,
        1
      ],
      "content": "static int\ncheck_breakpoint(INSTRUCTION **pi)\n{\n\tINSTRUCTION *pc;\n\n\tpc = *pi;\n\tif (stop.command == D_return)\n\t\treturn false;\n\tif (pc->opcode == Op_breakpoint) {\n\t\tint bnum;\n\t\t*pi = pc->nexti;    /* skip past the breakpoint instruction;\n\t\t                     * interpreter doesn't process Op_breakpoint.\n\t\t                     */\n\t\tbnum = breakpoint_triggered(pc->break_pt);\n\t\tif (bnum > 0) {\n\t\t\tstop.break_point = bnum;\n\t\t\tstop.print_frame = true;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}",
      "lines": 22,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "restart": {
      "start_point": [
        2889,
        0
      ],
      "end_point": [
        2915,
        1
      ],
      "content": "static void\nrestart(bool run)\n{\n\t/* save state in the environment after serialization */\n\tserialize_list(BREAK);\n\tserialize_list(WATCH);\n\tserialize_list(DISPLAY);\n\tserialize_list(HISTORY);\n\tserialize_list(OPTION);\n\n\t/* tell the new process to restore state from the environment */\n\tsetenv(\"DGAWK_RESTART\", (run ? \"true\" : \"false\"), 1);\n\n\t/* close all open files */\n\tclose_all();\n\n\t/* start a new process replacing the current process */\n#ifdef __MINGW32__\n\texecvp(d_argv[0], (const char * const *)d_argv);\n#else\n\texecvp(d_argv[0], d_argv);\n#endif\n\n\t/* execvp failed !!! */\n\tfprintf(out_fp, _(\"Failed to restart debugger\"));\n\texit(EXIT_FAILURE);\n}",
      "lines": 27,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "do_run": {
      "start_point": [
        2919,
        0
      ],
      "end_point": [
        2970,
        1
      ],
      "content": "int\ndo_run(CMDARG *arg ATTRIBUTE_UNUSED, int cmd ATTRIBUTE_UNUSED)\n{\n\tif (prog_running) {\n\t\tif (! input_from_tty)\n\t\t\tneed_restart = true;\t/* handled later */\n\t\telse {\n\t\t\tneed_restart = prompt_yes_no(\n\t\t\t         _(\"Program already running. Restart from beginning (y/n)? \"),\n\t\t\t         _(\"y\")[0], false, out_fp);\n\n\t\t\tif (! need_restart) {\n\t\t\t\tfprintf(out_fp, _(\"Program not restarted\\n\"));\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (need_restart) {\n\t\t/* avoid endless cycles of restarting */\n\t\tif (command_file != NULL) {\n\t\t\t/* input_from_tty = false */\n\t\t\tfprintf(stderr, _(\"error: cannot restart, operation not allowed\\n\"));\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\n\t\tif (cmd_src->cmd == D_source) {\n\t\t\t/* input_from_tty = false */\n\t\t\tfprintf(out_fp, _(\"error (%s): cannot restart, ignoring rest of the commands\\n\"), cmd_src->str);\n\t\t\tpop_cmd_src();\n\t\t\treturn false;\n\t\t}\n\n\t\trestart(true);\t/* does not return */\n\t}\n\n\tfprintf(out_fp, _(\"Starting program: \\n\"));\n\n\tprog_running = true;\n\tfatal_tag_valid = 1;\n\tif (setjmp(fatal_tag) == 0)\n\t\t(void) interpret(code_block);\n\n\tfatal_tag_valid = 0;\n\tprog_running = false;\n\tfprintf(out_fp, (! exiting && exit_val != EXIT_SUCCESS)\n\t\t\t\t? _(\"Program exited abnormally with exit value: %d\\n\")\n\t\t\t\t: _(\"Program exited normally with exit value: %d\\n\"),\n\t\t\texit_val);\n\tneed_restart = true;\n\treturn false;\n}",
      "lines": 52,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "do_quit": {
      "start_point": [
        2974,
        0
      ],
      "end_point": [
        3000,
        1
      ],
      "content": "int\ndo_quit(CMDARG *arg ATTRIBUTE_UNUSED, int cmd ATTRIBUTE_UNUSED)\n{\n\tbool terminate = true;\n\tif (prog_running)\n\t\tterminate = prompt_yes_no(\n\t\t            _(\"The program is running. Exit anyway (y/n)? \"),\n\t\t            _(\"y\")[0], true, out_fp);\n\tif (terminate) {\n\t\tclose_all();\n\t\tdo_trace = false; \t/* don't save 'trace on' */\n\n#ifdef HAVE_LIBREADLINE\n\t\tif (do_save_history && input_from_tty) {\n\t\t\tint ret;\n\t\t\tret = write_history(history_file);\n\t\t\tif (ret == 0 && history_length > history_size)\n\t\t\t\t(void) history_truncate_file(history_file, history_size);\n\t\t}\n#endif\n\t\tif (do_save_options && input_from_tty)\n\t\t\tsave_options(options_file);\n\n\t\texit(exit_val);\n\t}\n\treturn false;\n}",
      "lines": 27,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "do_continue": {
      "start_point": [
        3004,
        0
      ],
      "end_point": [
        3028,
        1
      ],
      "content": "int\ndo_continue(CMDARG *arg, int cmd ATTRIBUTE_UNUSED)\n{\n\tBREAKPOINT *b;\n\n\tCHECK_PROG_RUNNING();\n\tif (! arg || arg->type != D_int)\n\t\treturn true;\n\n\t/* arg is breakpoint ignore count if stopped at a breakpoint */\n\tif (! stop.break_point) {\n\t\tfprintf(out_fp, _(\"Not stopped at any breakpoint; argument ignored.\\n\"));\n\t\treturn true;\n\t}\n\tb = find_breakpoint(stop.break_point);\n\tif (b == NULL) {\n\t\td_error(_(\"invalid breakpoint number %d.\"), stop.break_point);\n\t\treturn false;\n\t}\n\tb->flags |= BP_IGNORE;\n\tb->ignore_count = arg->a_int;\n\tfprintf(out_fp, _(\"Will ignore next %ld crossings of breakpoint %d.\\n\"),\n\t\t\t\tb->ignore_count, stop.break_point);\n\treturn true;\n}",
      "lines": 25,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "next_step": {
      "start_point": [
        3032,
        0
      ],
      "end_point": [
        3042,
        1
      ],
      "content": "static int\nnext_step(CMDARG *arg, int cmd)\n{\n\tCHECK_PROG_RUNNING();\n\tif (arg != NULL && arg->type == D_int)\n\t\tstop.repeat_count = arg->a_int;\n\telse\n\t\tstop.repeat_count = 1;\n\tstop.command = cmd;\n\treturn true;\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "check_step": {
      "start_point": [
        3046,
        0
      ],
      "end_point": [
        3068,
        1
      ],
      "content": "static int\ncheck_step(INSTRUCTION **pi)\n{\n\tif (fcall_count != stop.fcall_count) {\n\t\tstop.fcall_count = fcall_count;\n\t\tstop.sourceline = sourceline;\n\t\tstop.source = source;\n\t\tstop.print_frame = true;\n\t\treturn (--stop.repeat_count == 0);\n\t}\n\n\tif (source != stop.source) {\n\t\tstop.source = source;\n\t\tstop.sourceline = sourceline;\n\t\treturn (--stop.repeat_count == 0);\n\t}\n\n\tif (sourceline != stop.sourceline) {\n\t\tstop.sourceline = sourceline;\n\t\treturn (--stop.repeat_count == 0);\n\t}\n\treturn false;\n}",
      "lines": 23,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "do_step": {
      "start_point": [
        3072,
        0
      ],
      "end_point": [
        3084,
        1
      ],
      "content": "int\ndo_step(CMDARG *arg, int cmd)\n{\n\tint ret;\n\tret = next_step(arg, cmd);\n\tif (ret) {\n\t\tstop.fcall_count = fcall_count;\n\t\tstop.source = source;\n\t\tstop.sourceline = sourceline;\n\t\tstop.check_func = check_step;\n\t}\n\treturn ret;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "check_stepi": {
      "start_point": [
        3088,
        0
      ],
      "end_point": [
        3092,
        1
      ],
      "content": "static int\ncheck_stepi(INSTRUCTION **pi)\n{\n\treturn (--stop.repeat_count == 0);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "do_stepi": {
      "start_point": [
        3096,
        0
      ],
      "end_point": [
        3104,
        1
      ],
      "content": "int\ndo_stepi(CMDARG *arg, int cmd)\n{\n\tint ret;\n\tret = next_step(arg, cmd);\n\tif (ret)\n\t\tstop.check_func = check_stepi;\n\treturn ret;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "check_next": {
      "start_point": [
        3109,
        0
      ],
      "end_point": [
        3143,
        1
      ],
      "content": "static int\ncheck_next(INSTRUCTION **pi)\n{\n\t/* make sure not to step inside function calls */\n\n\tif (fcall_count < stop.fcall_count) {\n\t\tstop.fcall_count = fcall_count;\n\t\tstop.sourceline = sourceline;\n\t\tstop.source = source;\n\t\tstop.print_frame = true;\n\t\treturn (--stop.repeat_count == 0);\n\t}\n\n\tif (fcall_count == stop.fcall_count) {\n\t\tif (source != stop.source) {\n\t\t\tstop.source = source;\n\t\t\tstop.sourceline = sourceline;\n\t\t\treturn (--stop.repeat_count == 0);\n\t\t}\n\t\tif (sourceline != stop.sourceline) {\n\t\t\tstop.sourceline = sourceline;\n\t\t\treturn (--stop.repeat_count == 0);\n\t\t}\n\t}\n\n#if 0\n\t/* redundant ? */\n\tif (fcall_count > stop.fcall_count) {\n\t\tstop.source = source;\n\t\tstop.sourceline = sourceline;\n\t}\n#endif\n\n\treturn false;\n}",
      "lines": 35,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "do_next": {
      "start_point": [
        3147,
        0
      ],
      "end_point": [
        3160,
        1
      ],
      "content": "int\ndo_next(CMDARG *arg, int cmd)\n{\n\tint ret;\n\n\tret = next_step(arg, cmd);\n\tif (ret) {\n\t\tstop.source = source;\n\t\tstop.sourceline = sourceline;\n\t\tstop.fcall_count = fcall_count;\n\t\tstop.check_func = check_next;\n\t}\n\treturn ret;\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "check_nexti": {
      "start_point": [
        3164,
        0
      ],
      "end_point": [
        3175,
        1
      ],
      "content": "static int\ncheck_nexti(INSTRUCTION **pi)\n{\n\t/* make sure not to step inside function calls */\n\n\tif (fcall_count < stop.fcall_count) {\n\t\tstop.print_frame = true;\n\t\tstop.fcall_count = fcall_count;\n\t}\n\treturn (fcall_count == stop.fcall_count\n\t\t\t&& --stop.repeat_count == 0);\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "do_nexti": {
      "start_point": [
        3179,
        0
      ],
      "end_point": [
        3190,
        1
      ],
      "content": "int\ndo_nexti(CMDARG *arg, int cmd)\n{\n\tint ret;\n\n\tret = next_step(arg, cmd);\n\tif (ret) {\n\t\tstop.fcall_count = fcall_count;\n\t\tstop.check_func = check_nexti;\n\t}\n\treturn ret;\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "check_finish": {
      "start_point": [
        3194,
        0
      ],
      "end_point": [
        3202,
        1
      ],
      "content": "static int\ncheck_finish(INSTRUCTION **pi)\n{\n\tif (fcall_count == stop.fcall_count) {\n\t\tstop.print_frame = true;\n\t\treturn true;\n\t}\n\treturn false;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "do_finish": {
      "start_point": [
        3206,
        0
      ],
      "end_point": [
        3223,
        1
      ],
      "content": "int\ndo_finish(CMDARG *arg ATTRIBUTE_UNUSED, int cmd)\n{\n\tCHECK_PROG_RUNNING();\n\tif (cur_frame == fcall_count) {\n\t\tfprintf(out_fp,\n\t\t\t_(\"'finish' not meaningful in the outermost frame main()\\n\"));\n\t\treturn false;\n\t}\n\tstop.fcall_count = fcall_count - cur_frame - 1;\n\tassert(stop.fcall_count >= 0);\n\tfprintf(out_fp, _(\"Run till return from \"));\n\tprint_numbered_frame(cur_frame);\n\tstop.check_func = check_finish;\n\tstop.command = cmd;\n\tstop.print_ret = true;\n\treturn true;\n}",
      "lines": 18,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "check_return": {
      "start_point": [
        3227,
        0
      ],
      "end_point": [
        3248,
        1
      ],
      "content": "static int\ncheck_return(INSTRUCTION **pi)\n{\n\tassert(fcall_count >= stop.fcall_count);\n\n\tif (fcall_count == stop.fcall_count) {\n\t\tstop.print_frame = true;\n\t\treturn true;\n\t}\n\n\tif (fcall_count > stop.fcall_count) {\t/* innermost frame just returned */\n\t\t/* force this one to return too */\n\t\tNODE *func;\n\n\t\tfunc = find_frame(cur_frame)->func_node;\n\t\tassert(func != NULL);\n\t\t*pi = (func->code_ptr + 1)->lasti;\n\t\t/* assert((*pi)->opcode == Op_K_return); */\n\t}\n\n\treturn false;\n}",
      "lines": 22,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "do_return": {
      "start_point": [
        3252,
        0
      ],
      "end_point": [
        3279,
        1
      ],
      "content": "int\ndo_return(CMDARG *arg, int cmd)\n{\n\tNODE *func, *n;\n\n\tCHECK_PROG_RUNNING();\n\tfunc = find_frame(cur_frame)->func_node;\n\tif (func == NULL) {\n\t\tfprintf(out_fp, _(\"'return' not meaningful in the outermost frame main()\\n\"));\n\t\treturn false;\n\t}\n\n\tstop.fcall_count = fcall_count - cur_frame - 1;\n\tassert(stop.fcall_count >= 0);\n\tstop.pc = (func->code_ptr + 1)->lasti;\n\tassert(stop.pc->opcode == Op_K_return);\n\tstop.command = cmd;\n\n\tstop.check_func = check_return;\n\n\tif (arg != NULL && arg->type == D_node)\t/* optional return value */\n\t\tn = dupnode(arg->a_node);\n\telse\n\t\tn = dupnode(Nnull_string);\n\tPUSH(n);\n\n\treturn true;\n}",
      "lines": 28,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "check_until": {
      "start_point": [
        3283,
        0
      ],
      "end_point": [
        3298,
        1
      ],
      "content": "int\ncheck_until(INSTRUCTION **pi)\n{\n\tif (fcall_count < stop.fcall_count) { /* current stack frame returned */\n\t\tstop.print_frame = true;\n\t\treturn true;\n\t} else if (fcall_count == stop.fcall_count) {\n\t\tif (stop.pc && *pi == stop.pc)\t\t/* until location */\n\t\t\treturn true;\n\t\tif (stop.sourceline > 0\t\t/* until */\n\t\t\t\t&& source == stop.source\n\t\t\t\t&& sourceline > stop.sourceline)\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
      "lines": 16,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "do_until": {
      "start_point": [
        3302,
        0
      ],
      "end_point": [
        3400,
        1
      ],
      "content": "int\ndo_until(CMDARG *arg, int cmd)\n{\n\tSRCFILE *s = cur_srcfile;\n\tchar *src = cur_srcfile->src;\n\tint lineno;\n\tINSTRUCTION *rp, *ip;\n\tNODE *func;\n\n\tCHECK_PROG_RUNNING();\n\tstop.pc = NULL;\n\tstop.sourceline = 0;\n\n\tif (arg == NULL) {\t/* until without argument */\n\n    /* GDB doc.: continue running until a source line past the current line,\n     * in the current stack frame, is reached. Is used to avoid single\n     * stepping through a loop more than once. ...\n     * This means that when you reach the end of a loop after single\n     * stepping though it, until makes your program continue execution\n     * until it exits the loop. In contrast, a next command at the end\n     * of a loop simply steps back to the beginning of the loop, which\n     * forces you to step through the next iteration.\n     */\n\n\t\tstop.source = source;\n\t\tstop.sourceline = sourceline;\n\t\tstop.fcall_count = fcall_count - cur_frame;\n\t\tstop.check_func = check_until;\n\t\tstop.command = cmd;\n\t\treturn true;\n\t}\n\n    /* GDB: until location - continue running program until\n     * either the specified location is reached, or the\n     * current stack frame returns.\n     */\n\n\tswitch (arg->type) {\n\tcase D_string:\t/* until filename : lineno|function */\n\t\ts = source_find(arg->a_string);\n\t\targ = arg->next;\n\t\tif (s == NULL || arg == NULL\n\t\t\t\t|| (arg->type != D_int && arg->type != D_func))\n\t\t\treturn false;\n\t\tsrc = s->src;\n\t\tif (arg->type == D_func)\n\t\t\tgoto func;\n\t\t/* else\n\t\t\tfall through */\n\tcase D_int:\t/* until lineno */\n\t\tlineno = arg->a_int;\n\t\tif (lineno <= 0 || lineno > s->srclines) {\n\t\t\td_error(_(\"line number %d in file `%s' out of range\"),\n\t\t\t\t\t\tlineno, src);\n\t\t\treturn false;\n\t\t}\n\t\tbreak;\n\n\tcase D_func:\t/* until function */\nfunc:\n\t\tfunc = arg->a_node;\n\t\trp = func->code_ptr;\n\t\tfor (ip = rp->nexti; ip; ip = ip->nexti) {\n\t\t\tif (ip->opcode != Op_breakpoint && ip->source_line > 0) {\n\t\t\t\tstop.pc = ip;\n\t\t\t\tstop.fcall_count = fcall_count - cur_frame;\n\t\t\t\tstop.check_func = check_until;\n\t\t\t\tstop.command = cmd;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tfprintf(out_fp, _(\"Can't find specified location in function `%s'\\n\"),\n\t\t\t\tfunc->vname);\n\t\t/* fall through */\n\tdefault:\n\t\treturn false;\n\t}\n\n\tif ((rp = find_rule(src, lineno)) == NULL) {\n\t\td_error(_(\"invalid source line %d in file `%s'\"), lineno, src);\n\t\treturn false;\n\t}\n\n\tfor (ip = rp->nexti; ip; ip = ip->nexti) {\n\t\tif (ip->opcode != Op_breakpoint && ip->source_line >= lineno) {\n\t\t\tstop.pc = ip;\n\t\t\tstop.fcall_count = fcall_count - cur_frame;\n\t\t\tstop.check_func = check_until;\n\t\t\tstop.command = cmd;\n\t\t\treturn true;\n\t\t}\n\t\tif (ip == (rp + 1)->lasti)\n\t\t\tbreak;\n\t}\n\tfprintf(out_fp, _(\"Can't find specified location %d in file `%s'\\n\"),\n\t\t\t\tlineno, src);\n\treturn false;\n}",
      "lines": 99,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "print_watch_item": {
      "start_point": [
        3404,
        0
      ],
      "end_point": [
        3439,
        1
      ],
      "content": "static void\nprint_watch_item(struct list_item *w)\n{\n\tNODE *symbol, *sub;\n\tint i;\n\n\tsymbol = w->symbol;\n\tif (IS_SUBSCRIPT(w)) {\n\t\tfprintf(out_fp, \"%s\", w->sname);\n\t\tfor (i = 0; i < w->num_subs; i++) {\n\t\t\tsub = w->subs[i];\n\t\t\tfprintf(out_fp, \"[\\\"%.*s\\\"]\", (int) sub->stlen, sub->stptr);\n\t\t}\n\t\tfprintf(out_fp, \"\\n\");\n\t} else if (IS_FIELD(w))\n\t\tfprintf(out_fp, \"$%ld\\n\", get_number_si(symbol));\n\telse\n\t\tfprintf(out_fp, \"%s\\n\", w->sname);\n\n\n#define print_value(X, S, V)                                        \\\nif (X)                                                              \\\n\tfprintf(out_fp, \"array, %ld elements\\n\", w->S);                 \\\nelse if (! w->V)                                                    \\\n\tfprintf(out_fp, IS_SUBSCRIPT(w) ?                               \\\n\t\t\t_(\"element not in array\\n\") : _(\"untyped variable\\n\")); \\\nelse                                                                \\\n\tvalinfo(w->V, fprintf, out_fp);\n\n\tfprintf(out_fp, \"  Old value: \");\n\tprint_value((w->flags & OLD_IS_ARRAY) != 0, old_size, old_value);\n\tfprintf(out_fp, \"  New value: \");\n\tprint_value((w->flags & CUR_IS_ARRAY) != 0, cur_size, cur_value);\n\n#undef print_value\n}",
      "lines": 36,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "next_command": {
      "start_point": [
        3445,
        0
      ],
      "end_point": [
        3528,
        1
      ],
      "content": "static void\nnext_command()\n{\n\tstatic int last_rule = 0;\n\tstruct list_item *d = NULL, *w = NULL;\n\tBREAKPOINT *b = NULL;\n\tSRCFILE *s;\n\n\tif (source == NULL) {\n\t\tstop.command = D_illegal;\n\t\tstop.check_func = NULL;\n\t\treturn;\n\t}\n\n\tif (stop.break_point) {\n\t\tb = find_breakpoint(stop.break_point);\n\t\tassert(b != NULL);\n\t\tif (b->silent)\n\t\t\tgoto no_output;\n\t} else if (stop.watch_point) {\n\t\tw = find_item(&watch_list, stop.watch_point);\n\t\tif (w->silent)\n\t\t\tgoto no_output;\n\t}\n\n\tif (cur_rule != last_rule) {\n\t\tfprintf(out_fp, _(\"Stopping in %s ...\\n\"), ruletab[cur_rule]);\n\t\tlast_rule = cur_rule;\n\t}\n\n\tif (b != NULL)\n\t\tfprintf(out_fp, \"Breakpoint %d, \", b->number);\n\telse if (w != NULL) {\n\t\tfprintf(out_fp, \"Watchpoint %d: \", w->number);\n\t\tprint_watch_item(w);\n\t}\n\n\t/* frame info */\n\tif (stop.print_frame) {\n\t\tprint_frame(frame_ptr->func_node, source, sourceline);\n\t\tfprintf(out_fp, \"\\n\");\n\t\tstop.print_frame = false;\n\t}\n\n\t(void) print_lines(source, sourceline, 1);\n\n\t/* automatic display of variables */\n\tfor (d = display_list.prev; d != &display_list; d = d->prev)\n\t\tdisplay(d);\n\nno_output:\n\t/* update last_printed_line, so that  output of 'list' is\n\t * centered around current sourceline\n\t */\n\n\tlast_printed_line = sourceline - list_size / 2;\n\tif (last_printed_line < 0)\n\t\tlast_printed_line = 0;\n\n\t/* update current source file */\n\ts = source_find(source);\n\tif (cur_srcfile != s) {\n\t\tif (cur_srcfile->fd != INVALID_HANDLE) {\n\t\t\tclose(cur_srcfile->fd);\n\t\t\tcur_srcfile->fd = INVALID_HANDLE;\n\t\t}\n\t\tcur_srcfile = s;\n\t}\n\n\tstop.command = D_illegal;\n\tstop.check_func = NULL;\n\n\tif (b != NULL) {\n\t\tint ret;\n\t\tret = execute_commands(&b->commands);\n\t\tif ((b->flags & BP_TEMP) != 0)\n\t\t\tdelete_breakpoint(b);\n\t\tif (ret)\t/* resume execution */\n\t\t\treturn;\n\t} else if (w != NULL && execute_commands(&w->commands))\n\t\treturn;\n\n\tread_command();\t\t/* zzparse */\n}",
      "lines": 84,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "debug_post_execute": {
      "start_point": [
        3532,
        0
      ],
      "end_point": [
        3581,
        1
      ],
      "content": "static void\ndebug_post_execute(INSTRUCTION *pc)\n{\n\tif (! in_main_context())\n\t\treturn;\n\n\tswitch (pc->opcode) {\n\tcase Op_K_next:\n\tcase Op_K_nextfile:\n\tcase Op_K_exit:\n\t\tif (stop.command == D_finish) {\n\t\t\t/* cancel finish command */\n\t\t\tstop.print_ret = false;\n\t\t\tstop.print_frame = false;\n\t\t\tstop.command = D_illegal;\n\t\t\tstop.check_func = NULL;\n\t\t\tfprintf(out_fp, _(\"'finish' not meaningful with non-local jump '%s'\\n\"),\n\t\t\t\t\t\t\top2str(pc->opcode));\n\t\t} else if (stop.command == D_until) {\n\t\t\t/* cancel until command */\n\t\t\tstop.print_frame = false;\n\t\t\tstop.command = D_illegal;\n\t\t\tstop.check_func = NULL;\n\t\t\tfprintf(out_fp, _(\"'until' not meaningful with non-local jump '%s'\\n\"),\n\t\t\t\t\t\t\top2str(pc->opcode));\n\t\t}\n\t\tbreak;\n\n\tcase Op_K_return:\n\t\tif (stop.command == D_finish\n\t\t\t\t&& fcall_count == stop.fcall_count\n\t\t\t\t&& stop.print_ret\n\t\t) {\n\t\t\tNODE *r;\n\t\t\t/* print the returned value before it disappears. */\n\t\t\tr = TOP();\n\t\t\tfprintf(out_fp, \"Returned value = \");\n\t\t\tvalinfo(r, fprintf, out_fp);\n\t\t\tstop.print_ret = false;\n\t\t}\n\t\tbreak;\n\n\tcase Op_newfile:\n\tcase Op_get_record:\n\t\treturn;\n\n\tdefault:\n\t\tbreak;\n\t}\n}",
      "lines": 50,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "debug_pre_execute": {
      "start_point": [
        3588,
        0
      ],
      "end_point": [
        3685,
        1
      ],
      "content": "static int\ndebug_pre_execute(INSTRUCTION **pi)\n{\n\tstatic bool cant_stop = false;\n\tNODE *m;\n\n\tif (! in_main_context())\n\t\treturn pre_execute_code(pi);\n\n\tcur_pc = *pi;\n\tstop.break_point = 0;\n\tstop.watch_point = 0;\n\tcur_frame = 0;\n\n\tif (do_trace\n\t\t&& cur_pc->opcode != Op_breakpoint\n\t\t&& stop.command != D_return\n\t)\n\t\tprint_instruction(cur_pc, fprintf, out_fp, false);\n\n/* N.B.: For Op_field_spec_lhs must execute instructions upto Op_field_assign\n * as a group before stopping. Otherwise, watch/print of field variables\n * yield surprising results. Ditto for Op_push_lhs for special variables\n * (upto Op_var_assign, the set_FOO routine).\n */\n\n\tswitch (cur_pc->opcode) {\n\tcase Op_field_spec_lhs:\n\t\tcant_stop = true;\n\t\tbreak;\n\n\tcase Op_field_assign:\n\t\tcant_stop = false;\n\t\treturn true; /* may stop at next instruction */\n\n\tcase Op_push_lhs:\n\t\tm = cur_pc->memory;\n\t\tif (m->type == Node_var && m->var_assign)\n\t\t\tcant_stop = true;\n\t\tbreak;\n\n\tcase Op_arrayfor_incr:\t/* can have special var as array variable !!! */\n\t\tm = cur_pc->array_var;\n\t\tif (m->type == Node_var && m->var_assign)\n\t\t\tcant_stop = true;\n\t\tbreak;\n\n\tcase Op_var_assign:\n\t\tcant_stop = false;\n\t\treturn true; /* may stop at next instruction */\n\n\tcase Op_rule:\n\t\tcur_rule = cur_pc->in_rule;\n\t\treturn true;\n\n\tcase Op_func:\n\tcase Op_var_update:\n\t\treturn true;\n\n\tcase Op_breakpoint:\n\t\tbreak;\t/* processed later in check_breakpoint() */\n\n\tdefault:\n\t\tif (cur_pc->source_line <= 0)\n\t\t\treturn true;\n\t\tbreak;\n\t}\n\n\tif (cant_stop)\n\t\treturn true;\n\n\tassert(sourceline > 0);\n\n\t/*\n\t * 11/2015: This used to check breakpoints first, but that could\n\t * produce strange behavior, where a watchpoint doesn't print until\n\t * some time after the data changed.  This reworks things so that\n\t * watchpoints are checked first. It's a bit of a hack, but\n\t * the behavior for the user is more logical.\n\t */\n\tif (check_watchpoint()) {\n\t\tnext_command();\t/* return to debugger interface */\n\t\tif (stop.command == D_return)\n\t\t\t*pi = stop.pc;\t/* jump to this instruction */\n\t\telse if (cur_pc->opcode == Op_breakpoint)\n\t\t\tcur_pc = cur_pc->nexti;    /* skip past the breakpoint instruction */\n\t} else if (check_breakpoint(pi)\n\t\t\t|| (stop.check_func && stop.check_func(pi))) {\n\t\tnext_command();\t/* return to debugger interface */\n\t\tif (stop.command == D_return)\n\t\t\t*pi = stop.pc;\t/* jump to this instruction */\n\t}\n\n\t/* if cur_pc == *pi, interpreter executes cur_pc;\n\t * Otherwise, jumps to instruction *pi.\n\t */\n\treturn (cur_pc == *pi);\n}",
      "lines": 98,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "print_memory": {
      "start_point": [
        3689,
        0
      ],
      "end_point": [
        3736,
        1
      ],
      "content": "static void\nprint_memory(NODE *m, NODE *func, Func_print print_func, FILE *fp)\n{\n\tswitch (m->type) {\n\tcase Node_val:\n\t\tif (m == Nnull_string)\n\t\t\tprint_func(fp, \"Nnull_string\");\n\t\telse if ((m->flags & NUMBER) != 0) {\n#ifdef HAVE_MPFR\n\t\t\tif ((m->flags & MPFN) != 0)\n\t\t\t\tprint_func(fp, \"%s\", mpg_fmt(\"%R*g\", ROUND_MODE, m->mpg_numbr));\n\t\t\telse if ((m->flags & MPZN) != 0)\n\t\t\t\tprint_func(fp, \"%s\", mpg_fmt(\"%Zd\", m->mpg_i));\n\t\t\telse\n#endif\n\t\t\t\tprint_func(fp, \"%g\", m->numbr);\n\t\t} else if ((m->flags & STRING) != 0)\n\t\t\tpp_string_fp(print_func, fp, m->stptr, m->stlen, '\"', false);\n\t\telse if ((m->flags & REGEX) != 0) {\n\t\t\tprint_func(fp, \"@\");\n\t\t\tpp_string_fp(print_func, fp, m->stptr, m->stlen, '/', false);\n\t\t} else\n\t\t\tprint_func(fp, \"-?-\");\n\t\tprint_func(fp, \" [%s]\", flags2str(m->flags));\n\t\tbreak;\n\n\tcase Node_regex:\n\t\tpp_string_fp(print_func, fp, m->re_exp->stptr, m->re_exp->stlen, '/', false);\n\t\tbreak;\n\n\tcase Node_dynregex:\n\t\tbreak;\n\n\tcase Node_param_list:\n\t\tassert(func != NULL);\n\t\tprint_func(fp, \"%s\", func->fparms[m->param_cnt].param);\n\t\tbreak;\n\n\tcase Node_var:\n\tcase Node_var_new:\n\tcase Node_var_array:\n\t\tprint_func(fp, \"%s\", m->vname);\n\t\tbreak;\n\n\tdefault:\n\t\tprint_func(fp, \"?\");  /* can't happen */\n\t}\n}",
      "lines": 48,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "print_instruction": {
      "start_point": [
        3740,
        0
      ],
      "end_point": [
        4055,
        1
      ],
      "content": "static void\nprint_instruction(INSTRUCTION *pc, Func_print print_func, FILE *fp, int in_dump)\n{\n\tint pcount = 0;\n\tstatic NODE *func = NULL;\n\tstatic int noffset = 0;\n\n\tif (noffset == 0) {\n\t\tstatic char buf[50];\n\t\t/* offset for 2nd to last lines in a multi-line output */\n\t\tnoffset = sprintf(buf, \"[      :%p] %-20.20s: \", (void *) pc,\n\t\t\t\topcode2str(pc->opcode));\n\t}\n\n\tif (pc->opcode == Op_func) {\n\t\tfunc = pc->func_body;\n\t\tpcount = func->param_cnt;\n\t\tif (in_dump) {\n\t\t\tint j;\n\t\t\tprint_func(fp, \"\\n\\t# Function: %s (\", func->vname);\n\t\t\tfor (j = 0; j < pcount; j++) {\n\t\t\t\tprint_func(fp, \"%s\", func->fparms[j].param);\n\t\t\t\tif (j < pcount - 1)\n\t\t\t\t\tprint_func(fp, \", \");\n\t\t\t}\n\t\t\tprint_func(fp, \")\\n\\n\");\n\t\t}\n\t} else if (pc->opcode == Op_rule) {\n\t\tif (in_dump)\n\t\t\tprint_func(fp, \"\\n\\t# %s\\n\\n\", ruletab[pc->in_rule]);\n\t}\n\n\tif (pc->opcode == Op_newfile)\n\t\tprint_func(fp, \"\\n\");\n\n\tif (pc->source_line <= 0)\n\t\tprint_func(fp, \"[      :%p] %-20.20s: \", pc, opcode2str(pc->opcode));\n\telse\n\t\tprint_func(fp, \"[%6d:%p] %-20.20s: \",\n\t\t                pc->source_line, pc, opcode2str(pc->opcode));\n\n\tif (prog_running && ! in_dump) {\n\t\t/* find Node_func if in function */\n\t\tfunc = find_frame(0)->func_node;\n\t}\n\n\n\tswitch (pc->opcode) {\n\tcase Op_K_if:\n\t\tprint_func(fp, \"[branch_if = %p] [branch_else = %p] [branch_else->lasti = %p]\\n\",\n\t\t\t\tpc->branch_if, pc->branch_else, pc->branch_else->lasti);\n\t\tbreak;\n\n\tcase Op_K_else:\n\t\tprint_func(fp, \"[branch_end = %p]\\n\", pc->branch_end);\n\t\tbreak;\n\n\tcase Op_K_while:\n\t\tprint_func(fp, \"[while_body = %p] [target_break = %p]\\n\", (pc+1)->while_body, pc->target_break);\n\t\tbreak;\n\n\tcase Op_K_do:\n\t\tprint_func(fp, \"[doloop_cond = %p] [target_break = %p]\\n\", (pc+1)->doloop_cond, pc->target_break);\n\t\tbreak;\n\n\tcase Op_K_for:\n\t\tprint_func(fp, \"[forloop_cond = %p] \", (pc+1)->forloop_cond);\n\t\t/* fall through */\n\tcase Op_K_arrayfor:\n\t\tprint_func(fp, \"[forloop_body = %p] \", (pc+1)->forloop_body);\n\t\tprint_func(fp, \"[target_break = %p] [target_continue = %p]\\n\", pc->target_break, pc->target_continue);\n\t\tbreak;\n\n\tcase Op_K_switch:\n\t\tprint_func(fp, \"[switch_start = %p] [switch_end = %p]\\n\", (pc+1)->switch_start, (pc+1)->switch_end);\n\t\tbreak;\n\n\tcase Op_K_default:\n\t\tprint_func(fp, \"[stmt_start = %p] [stmt_end = %p]\\n\", pc->stmt_start, pc->stmt_end);\n\t\tbreak;\n\n\tcase Op_var_update:\n\t\tprint_func(fp, \"[update_%s()]\\n\", get_spec_varname(pc->update_var));\n\t\tbreak;\n\n\tcase Op_var_assign:\n\t\tprint_func(fp, \"[set_%s()]\", get_spec_varname(pc->assign_var));\n\t\tif (pc->assign_ctxt != 0)\n\t\t\tprint_func(fp, \" [assign_ctxt = %s]\", opcode2str(pc->assign_ctxt));\n\t\tprint_func(fp, \"\\n\");\n\t\tbreak;\n\n\tcase Op_field_assign:\n\t\tprint_func(fp, \"[%s]\\n\", pc->field_assign == reset_record ?\n\t\t\t\t\t\"reset_record()\" : \"invalidate_field0()\");\n\t\tbreak;\n\n\tcase Op_field_spec_lhs:\n\t\tprint_func(fp, \"[target_assign = %p] [do_reference = %s]\\n\",\n\t\t\t\tpc->target_assign, pc->do_reference ? \"true\" : \"false\");\n\t\tbreak;\n\n\tcase Op_func:\n\t\tprint_func(fp, \"[param_cnt = %d] [source_file = %s]\\n\", pcount,\n\t\t\t\tpc->source_file ? pc->source_file : \"cmd. line\");\n\t\tbreak;\n\n\tcase Op_K_getline_redir:\n\t\tprint_func(fp, \"[into_var = %s] [redir_type = \\\"%s\\\"]\\n\",\n\t\t                pc->into_var ? \"true\" : \"false\",\n\t\t                redir2str(pc->redir_type));\n\t\tbreak;\n\n\tcase Op_K_getline:\n\t\tprint_func(fp, \"[into_var = %s]\\n\", pc->into_var ? \"true\" : \"false\");\n\t\tprint_func(fp, \"%*s[target_beginfile = %p] [target_endfile = %p]\\n\",\n\t\t                noffset, \"\",\n\t\t                (pc + 1)->target_beginfile, (pc + 1)->target_endfile);\n\t\tbreak;\n\n\tcase Op_K_print_rec:\n\t\tprint_func(fp, \"[redir_type = \\\"%s\\\"]\\n\", redir2str(pc->redir_type));\n\t\tbreak;\n\n\tcase Op_K_print:\n\tcase Op_K_printf:\n\t\tprint_func(fp, \"[expr_count = %ld] [redir_type = \\\"%s\\\"]\\n\",\n\t\t                pc->expr_count, redir2str(pc->redir_type));\n\t\tbreak;\n\n\tcase Op_indirect_func_call:\n\tcase Op_func_call:\n\t\tprint_func(fp, \"[func_name = %s] [arg_count = %ld]\\n\",\n\t\t                pc->func_name, (pc + 1)->expr_count);\n\t\tbreak;\n\n\tcase Op_K_nextfile:\n\t\tprint_func(fp, \"[target_newfile = %p] [target_endfile = %p]\\n\",\n\t\t                pc->target_newfile, pc->target_endfile);\n\t\tbreak;\n\n\tcase Op_newfile:\n\t\tprint_func(fp, \"[target_jmp = %p] [target_endfile = %p]\\n\",\n\t\t                pc->target_jmp, pc->target_endfile);\n\t\tprint_func(fp, \"%*s[target_get_record = %p]\\n\",\n\t\t                noffset, \"\", (pc + 1)->target_get_record);\n\t\tbreak;\n\n\tcase Op_get_record:\n\t\tprint_func(fp, \"[target_newfile = %p]\\n\", pc->target_newfile);\n\t\tbreak;\n\n\tcase Op_jmp:\n\tcase Op_jmp_false:\n\tcase Op_jmp_true:\n\tcase Op_and:\n\tcase Op_or:\n\tcase Op_K_next:\n\tcase Op_arrayfor_init:\n\tcase Op_K_break:\n\tcase Op_K_continue:\n\t\tprint_func(fp, \"[target_jmp = %p]\\n\", pc->target_jmp);\n\t\tbreak;\n\n\tcase Op_K_exit:\n\t\tprint_func(fp, \"[target_end = %p] [target_atexit = %p]\\n\",\n\t\t\t\t\t\tpc->target_end, pc->target_atexit);\n\t\tbreak;\n\n\tcase Op_K_case:\n\t\tprint_func(fp, \"[target_jmp = %p] [match_exp = %s]\\n\",\n\t\t\t\t\t\tpc->target_jmp,\t(pc + 1)->match_exp ? \"true\" : \"false\");\n\t\tbreak;\n\n\tcase Op_arrayfor_incr:\n\t\tprint_func(fp, \"[array_var = %s] [target_jmp = %p]\\n\",\n\t\t                pc->array_var->type == Node_param_list ?\n\t\t                   func->fparms[pc->array_var->param_cnt].param : pc->array_var->vname,\n\t\t                pc->target_jmp);\n\t\tbreak;\n\n\tcase Op_line_range:\n\t\tprint_func(fp, \"[triggered = %ld] [target_jmp = %p]\\n\",\n\t\t                pc->triggered, pc->target_jmp);\n\t\tbreak;\n\n\tcase Op_cond_pair:\n\t\tprint_func(fp, \"[line_range = %p] [target_jmp = %p]\\n\",\n\t\t                pc->line_range, pc->target_jmp);\n\t\tbreak;\n\n\tcase Op_sub_builtin:\n\t{\n\t\tconst char *fname = \"sub\";\n\t\tstatic const struct flagtab values[] = {\n\t\t\t{ GSUB, \"GSUB\" },\n\t\t\t{ GENSUB, \"GENSUB\" },\n\t\t\t{ LITERAL, \"LITERAL\" },\n\t\t\t{ 0, NULL }\n\t\t};\n\n\t\tif ((pc->sub_flags & GSUB) != 0)\n\t\t\tfname = \"gsub\";\n\t\telse if ((pc->sub_flags & GENSUB) != 0)\n\t\t\tfname = \"gensub\";\n\t\tprint_func(fp, \"%s [arg_count = %ld] [sub_flags = %s]\\n\",\n\t\t\t\tfname, pc->expr_count,\n\t\t\t\tgenflags2str(pc->sub_flags, values));\n\t}\n\t\tbreak;\n\n\tcase Op_builtin:\n\t\tprint_func(fp, \"%s [arg_count = %ld]\\n\", getfname(pc->builtin),\n\t\t\t\t\t\tpc->expr_count);\n\t\tbreak;\n\n\tcase Op_ext_builtin:\n\t\tprint_func(fp, \"%s [arg_count = %ld]\\n\", (pc + 1)->func_name,\n\t\t\t\t\t\tpc->expr_count);\n\t\tbreak;\n\n\tcase Op_subscript:\n\tcase Op_sub_array:\n\t\tprint_func(fp, \"[sub_count = %ld]\\n\", pc->sub_count);\n\t\tbreak;\n\n\tcase Op_store_sub:\n\t\tprint_memory(pc->memory, func, print_func, fp);\n\t\tprint_func(fp, \" [sub_count = %ld]\\n\", pc->expr_count);\n\t\tbreak;\n\n\tcase Op_subscript_lhs:\n\t\tprint_func(fp, \"[sub_count = %ld] [do_reference = %s]\\n\",\n\t\t                pc->sub_count,\n\t\t                pc->do_reference ? \"true\" : \"false\");\n\t\tbreak;\n\n\tcase Op_K_delete:\n\tcase Op_in_array:\n\t\tprint_func(fp, \"[expr_count = %ld]\\n\", pc->expr_count);\n\t\tbreak;\n\n\tcase Op_concat:\n\t\t/* NB: concat_flag CSVAR only used in grammar, don't display it */\n\t\tprint_func(fp, \"[expr_count = %ld] [concat_flag = %s]\\n\",\n\t\t\t\t\t\tpc->expr_count,\n\t\t\t\t\t\t(pc->concat_flag & CSUBSEP) != 0 ? \"CSUBSEP\" : \"0\");\n\t\tbreak;\n\n\tcase Op_rule:\n\t\tprint_func(fp, \"[in_rule = %s] [source_file = %s]\\n\",\n\t\t                ruletab[pc->in_rule],\n\t\t                pc->source_file ? pc->source_file : \"cmd. line\");\n\t\tbreak;\n\n\tcase Op_lint:\n\t{\n\t\tstatic const char *const linttypetab[] = {\n\t\t\t\"LINT_illegal\",\n\t\t\t\"LINT_assign_in_cond\",\n\t\t\t\"LINT_no_effect\"\n\t\t};\n\t\tprint_func(fp, \"[lint_type = %s]\\n\", linttypetab[pc->lint_type]);\n\t}\n\t\tbreak;\n\n\tcase Op_exec_count:\n\t\tprint_func(fp, \"[exec_count = %ld]\\n\", pc->exec_count);\n\t\tbreak;\n\n \tcase Op_store_var:\n\t\tprint_memory(pc->memory, func, print_func, fp);\n\t\tif (pc->initval != NULL) {\n\t\t\tprint_func(fp, \" = \");\n\t\t\tprint_memory(pc->initval, func, print_func, fp);\n\t\t}\n\t\tprint_func(fp, \"\\n\");\n\t\tbreak;\n\n\tcase Op_push_lhs:\n\t\tprint_memory(pc->memory, func, print_func, fp);\n\t\tprint_func(fp, \" [do_reference = %s]\\n\",\n\t\t                pc->do_reference ? \"true\" : \"false\");\n\t\tbreak;\n\n\tcase Op_comment:\n\t\tprint_memory(pc->memory, func, print_func, fp);\n\t\tfprintf(fp, \" [comment_type = %s]\\n\",\n\t\t\tpc->memory->comment_type == EOL_COMMENT ?\n\t\t\t\t\t\t\"EOL\" : \"FULL\");\n\t\tbreak;\n\n\tcase Op_push_i:\n\tcase Op_push:\n\tcase Op_push_arg:\n\tcase Op_push_arg_untyped:\n\tcase Op_push_param:\n\tcase Op_push_array:\n\tcase Op_push_re:\n\tcase Op_match_rec:\n\tcase Op_match:\n\tcase Op_nomatch:\n\tcase Op_plus_i:\n\tcase Op_minus_i:\n\tcase Op_times_i:\n\tcase Op_exp_i:\n\tcase Op_quotient_i:\n\tcase Op_mod_i:\n\tcase Op_assign_concat:\n\t\tprint_memory(pc->memory, func, print_func, fp);\n\t\t/* fall through */\n\tdefault:\n\t\tprint_func(fp, \"\\n\");\n\t\tbreak;\n\t}\n}",
      "lines": 316,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "do_trace_instruction": {
      "start_point": [
        4059,
        0
      ],
      "end_point": [
        4068,
        1
      ],
      "content": "int\ndo_trace_instruction(CMDARG *arg, int cmd ATTRIBUTE_UNUSED)\n{\n\tif (arg != NULL && arg->type == D_argument\n\t\t\t&& arg->a_argument == A_TRACE_ON)\n\t\tdo_trace = true;\n\telse\n\t\tdo_trace = false;\n\treturn false;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "print_code": {
      "start_point": [
        4072,
        0
      ],
      "end_point": [
        4079,
        1
      ],
      "content": "static int\nprint_code(INSTRUCTION *pc, void *x)\n{\n\tstruct pf_data *data = (struct pf_data *) x;\n\tfor (; pc != NULL; pc = pc->nexti)\n\t\tprint_instruction(pc, data->print_func, data->fp, data->defn /* in_dump */);\n\treturn 0;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "do_dump_instructions": {
      "start_point": [
        4083,
        0
      ],
      "end_point": [
        4122,
        1
      ],
      "content": "int\ndo_dump_instructions(CMDARG *arg, int cmd ATTRIBUTE_UNUSED)\n{\n\tFILE *fp;\n  \tNODE **funcs;\n\n\tif (arg != NULL && arg->type == D_string) {\n\t\t/* dump to a file */\n\t\tif ((fp = fopen(arg->a_string, \"w\")) == NULL) {\n\t\t\td_error(_(\"could not open `%s' for writing (%s)\"),\n\t\t\t\t\targ->a_string, strerror(errno));\n\t\t\treturn false;\n\t\t}\n\t\tpf_data.print_func = fprintf;\n\t\tpf_data.fp = fp;\n\t\tpf_data.defn = true;\t/* in_dump = true */\n\t\t(void) print_code(code_block, &pf_data);\n\t\tfuncs = function_list(true);\n\t\t(void) foreach_func(funcs,\n\t\t                     (int (*)(INSTRUCTION *, void *)) print_code,\n\t\t                     &pf_data);\n\t\tefree(funcs);\n\t\tfclose(fp);\n\t\treturn false;\n\t}\n\n\tfuncs = function_list(true);\n\tinitialize_pager(out_fp);\n\tif (setjmp(pager_quit_tag) == 0) {\n\t\tpf_data.print_func = gprintf;\n\t\tpf_data.fp = out_fp;\n\t\tpf_data.defn = true;\t/* in_dump = true */\n\t\t(void) print_code(code_block, &pf_data);\n\t\t(void) foreach_func(funcs,\n\t\t                    (int (*)(INSTRUCTION *, void *)) print_code,\n\t\t                     &pf_data);\n\t}\n\tefree(funcs);\n\treturn false;\n}",
      "lines": 40,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "do_save": {
      "start_point": [
        4126,
        0
      ],
      "end_point": [
        4161,
        1
      ],
      "content": "int\ndo_save(CMDARG *arg, int cmd ATTRIBUTE_UNUSED)\n{\n#if defined(HAVE_LIBREADLINE) && defined(HAVE_HISTORY_LIST)\n\tFILE *fp;\n\tHIST_ENTRY **hist_list;\n\tint i;\n\n\tif ((fp = fopen(arg->a_string, \"w\")) == NULL) {\n\t\td_error(_(\"could not open `%s' for writing (%s)\"),\n\t\t\t\targ->a_string, strerror(errno));\n\t\treturn false;\n\t}\n\n\thist_list = history_list();\n\tif (hist_list && history_length > sess_history_base) {\n\t\tfor (i = sess_history_base; hist_list[i] != NULL; i++) {\n\t\t\tchar *line;\n\t\t\tline = hist_list[i]->line;\n\n\t\t\t/* exclude save commands;\n\t\t\t * N.B.: this test may fail if there is another\n\t\t\t * command with the same first 2 letters.\n\t\t\t */\n\n\t\t\tif (strlen(line) > 1\n\t\t\t    && strncmp(line, \"sa\", 2) == 0)\n\t\t\t\tcontinue;\n\n\t\t\tfprintf(fp, \"%s\\n\", line);\n\t\t}\n\t}\n\tfclose(fp);\n#endif\n\treturn false;\n}",
      "lines": 36,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "do_option": {
      "start_point": [
        4165,
        0
      ],
      "end_point": [
        4200,
        1
      ],
      "content": "int\ndo_option(CMDARG *arg, int cmd ATTRIBUTE_UNUSED)\n{\n\tconst struct dbg_option *opt;\n\tchar *name, *value;\n\n\tif (arg == NULL) {\t/* display all available options and corresponding values */\n\t\tfor (opt = option_list; opt->name; opt++) {\n\t\t\tif (opt->str_val != NULL)\n\t\t\t\tfprintf(out_fp, \"%s = \\\"%s\\\"\\n\", opt->name, *(opt->str_val));\n\t\t\telse\n\t\t\t\tfprintf(out_fp, \"%s = %d\\n\", opt->name, *(opt->num_val));\n\t\t}\n\t\treturn false;\n\t}\n\n\tname = arg->a_string;\n\targ = arg->next;\n\tvalue = arg ? arg->a_string : NULL;\n\n\tfor (opt = option_list; opt->name; opt++) {\t/* linear search */\n\t\tif (strcmp(name, opt->name) == 0)\n\t\t\tbreak;\n\t}\n\tif (! opt->name)\n\t\treturn false;\n\n\tif (value == NULL) {\t/* display current setting */\n\t\tif (opt->str_val != NULL)\n\t\t\tfprintf(out_fp, \"%s = \\\"%s\\\"\\n\", opt->name, *(opt->str_val));\n\t\telse\n\t\t\tfprintf(out_fp, \"%s = %d\\n\", opt->name, *(opt->num_val));\n\t} else\n\t\t(*(opt->assign))(value);\n\treturn false;\n}",
      "lines": 36,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "initialize_pager": {
      "start_point": [
        4207,
        0
      ],
      "end_point": [
        4226,
        1
      ],
      "content": "void\ninitialize_pager(FILE *fp)\n{\n\tif (! os_isatty(fileno(fp)) || ! input_from_tty || input_fd != 0) {\n\t\tscreen_width = INT_MAX;\n\t\tscreen_height = INT_MAX;\n\t} else {\n\t\t/* get the terminal size from readline. */\n\n\t\trl_reset_terminal(NULL); /* N.B.: NULL argument means\n\t\t                          * \"use TERM env variable for terminal name\".\n\t\t                          */\n\t\trl_get_screen_size(&screen_height, &screen_width);\n\t\tif (screen_height <= 1)\n\t\t\tscreen_height = INT_MAX;\n\t\tif (screen_width <= 1)\n\t\t\tscreen_width = INT_MAX;\n\t}\n\tpager_lines_printed = 0;\n}",
      "lines": 20,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "prompt_continue": {
      "start_point": [
        4229,
        0
      ],
      "end_point": [
        4241,
        1
      ],
      "content": "static void\nprompt_continue(FILE *fp)\n{\n\tbool quit_pager = false;\n\n\tif (os_isatty(fileno(fp)) && input_fd == 0)\n\t\tquit_pager = prompt_yes_no(\n\t                _(\"\\t------[Enter] to continue or q [Enter] to quit------\"),\n\t                _(\"q\")[0], false, fp);\n\tif (quit_pager)\n\t\tlongjmp(pager_quit_tag, 1);\n\tpager_lines_printed = 0;\n}",
      "lines": 13,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "gprintf": {
      "start_point": [
        4245,
        0
      ],
      "end_point": [
        4314,
        1
      ],
      "content": "int\ngprintf(FILE *fp, const char *format, ...)\n{\n\tva_list args;\n\tstatic char *buf = NULL;\n\tstatic size_t buflen = 0;\n\tstatic int bl = 0;\n\tchar *p, *q;\n\tint nchar;\n\n#define GPRINTF_BUFSIZ 512\n\tif (buf == NULL) {\n\t\tbuflen = GPRINTF_BUFSIZ;\n\t\temalloc(buf, char *, buflen * sizeof(char), \"gprintf\");\n\t} else if (buflen - bl < GPRINTF_BUFSIZ/2) {\n\t\tbuflen += GPRINTF_BUFSIZ;\n\t\terealloc(buf, char *, buflen * sizeof(char), \"gprintf\");\n\t}\n#undef GPRINTF_BUFSIZ\n\n\twhile (true) {\n\t\tva_start(args, format);\n\t\tnchar = vsnprintf(buf + bl, buflen - bl, format, args);\n\t\tva_end(args);\n\t\tif (nchar == 0)\n\t\t\treturn 0;\n\t\tif (nchar > 0 && nchar < buflen - bl) {\n\t\t\tbl += nchar;\n\t\t\tif (buf[bl-1] != '\\n') /* buffer output until see a newline at end */\n\t\t\t\treturn nchar;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* enlarge buffer, and try again */\n\t\tbuflen *= 2;\n\t\terealloc(buf, char *, buflen * sizeof(char), \"gprintf\");\n\t}\n\n\tbl = 0;\n\tfor (p = buf; (q = strchr(p, '\\n')) != NULL; p = q + 1) {\n\t\tint sz = (int) (q - p);\n\n\t\twhile (sz > 0) {\n\t\t\tint cnt;\n\t\t\tcnt = sz > screen_width ? screen_width : sz;\n\n\t\t\t/* do not print partial line before scrolling */\n\t\t\tif (cnt < sz && (pager_lines_printed == (screen_height - 2)))\n\t\t\t\tprompt_continue(fp);\n\n\t\t\tif (fwrite(p, sizeof(char), cnt, fp) != cnt)\n\t\t\t\treturn -1;\n\t\t\tif (cnt == sz)\n\t\t\t\tbreak;\n\t\t\telse {\n\t\t\t\tif (++pager_lines_printed == (screen_height - 1))\n\t\t\t\t\tprompt_continue(fp);\n\t\t\t\tsz -= screen_width;\n\t\t\t\tassert(sz > 0);\n\t\t\t\tp += cnt;\n\t\t\t}\n\t\t}\n\n\t\tfprintf(fp, \"\\n\");\n\t\tif (++pager_lines_printed == (screen_height - 1))\n\t\t\tprompt_continue(fp);\n\t\tp++;\n\t}\n\treturn nchar;\n}",
      "lines": 70,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "serialize_subscript": {
      "start_point": [
        4317,
        0
      ],
      "end_point": [
        4343,
        1
      ],
      "content": "static int\nserialize_subscript(char *buf, int buflen, struct list_item *item)\n{\n\tint bl, nchar, i;\n\tNODE *sub;\n\n\tnchar = snprintf(buf, buflen, \"%d%c%d%c%s%c%d%c\",\n\t\t\t\titem->number, FSEP, D_subscript, FSEP, item->sname, FSEP,\n\t\t\t\titem->num_subs, FSEP);\n\tif (nchar <= 0)\n\t\treturn 0;\n\telse if (nchar >= buflen)\t/* need larger buffer */\n\t\treturn nchar;\n \tbl = nchar;\n\tfor (i = 0; i < item->num_subs; i++) {\n\t\tsub = item->subs[i];\n\t\tnchar = snprintf(buf + bl, buflen - bl, \"%lu%c%.*s%c\",\n\t\t\t\t\t(unsigned long) sub->stlen, FSEP,\n\t\t\t\t\t(int) sub->stlen, sub->stptr, FSEP);\n\t\tif (nchar <= 0)\n\t\t\treturn 0;\n\t\tbl += nchar;\n\t\tif (bl >= buflen)\t/* need larger buffer */\n\t\t\treturn bl;\n\t}\n\treturn bl;\n}",
      "lines": 27,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "serialize_list": {
      "start_point": [
        4351,
        0
      ],
      "end_point": [
        4587,
        1
      ],
      "content": "static void\nserialize_list(int type)\n{\n\tstatic char *buf = NULL;\n\tstatic int buflen = 0;\n\tint bl;\n\tBREAKPOINT *b = NULL;\n\tstruct list_item *wd = NULL;\n\tHIST_ENTRY **hist_list = NULL;\n\tint hist_index = 0;\n\tstruct dbg_option *opt = NULL;\n\tstruct commands_item *commands = NULL, *c;\n\tint cnum = 0;\n\tstruct condition *cndn = NULL;\n\tvoid *ptr, *end_ptr;\n#ifdef HAVE_LIBREADLINE\n\tHIST_ENTRY *h = NULL;\n#endif\n\n\tswitch (type) {\n\tcase BREAK:\n\t\tend_ptr = (void *) &breakpoints;\n\t\tptr = (void *) breakpoints.prev;\n\t\tbreak;\n\tcase WATCH:\n\t\tend_ptr = (void *) &watch_list;\n\t\tptr = (void *) watch_list.prev;\n\t\tbreak;\n\tcase DISPLAY:\n\t\tend_ptr = (void *) &display_list;\n\t\tptr = (void *) display_list.prev;\n\t\tbreak;\n\tcase HISTORY:\n\t\thist_list = history_list();\n\t\tif (hist_list == NULL) /* empty history list */\n\t\t\treturn;\n\t\tend_ptr = NULL;\n\t\tptr = (void *) hist_list[0];\n\t\tbreak;\n\tcase OPTION:\n\t{\n\t\tint n;\n\t\tn = sizeof(option_list)/sizeof(option_list[0]);\n\t\tend_ptr = (void *) &option_list[n - 1];\n\t\tptr = (void *) option_list;\n\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn;\n\t}\n\n\tif (type != HISTORY && ptr == end_ptr)\t\t/* empty list */\n\t\treturn;\n\n#define SERIALIZE_BUFSIZ 512\n\n\tif (buf == NULL) {\t/* first time */\n\t\tbuflen = SERIALIZE_BUFSIZ;\n\t\temalloc(buf, char *, buflen + 1, \"serialize\");\n\t}\n\tbl = 0;\n\n\twhile (ptr != end_ptr) {\n\t\tint nchar = 0;\n\t\tif (buflen - bl < SERIALIZE_BUFSIZ/2) {\nenlarge_buffer:\n\t\t\tbuflen *= 2;\n\t\t\terealloc(buf, char *, buflen + 1, \"serialize\");\n\t\t}\n\n#undef SERIALIZE_BUFSIZ\n\n\t\t/* field seperator is FSEP ('\\037'), and the record separator is RSEP ('\\036') */\n\n\t\tswitch (type) {\n\t\tcase BREAK:\n\t\t\tb = (BREAKPOINT *) ptr;\n\n\t\t\t/* src source_line flags ignore_count hit_count number;\n\t\t\t * commands and condition processed later in the end switch\n\t\t\t */\n\n\t\t\tnchar = snprintf(buf + bl, buflen - bl,\n\t\t\t                 \"%s%c%d%c%d%c%d%c%d%c%d%c\",\n\t\t\t                 b->src, FSEP, b->bpi->source_line, FSEP, b->flags, FSEP,\n\t\t\t                 (int) b->ignore_count, FSEP,\n\t\t\t                 (int) b->hit_count, FSEP, b->number, FSEP);\n\t\t\tcnum = b->number;\n\t\t\tcommands = &b->commands;\n\t\t\tcndn = &b->cndn;\n\t\t\tbreak;\n\t\tcase DISPLAY:\n\t\tcase WATCH:\n\t\t\twd = (struct list_item *) ptr;\n\n\t\t\t/* subscript    -- number type sname num_subs subs(stlen + stptr) [commands [condition]]\n\t\t\t * variable     -- number type sname [commands [condition]]\n\t\t\t * field        -- number type symbol(numbr) [commands [condition]]\n\t\t\t */\n\n\t\t\tif (IS_PARAM(wd))\t/* exclude parameters */\n\t\t\t\tnchar = 0;\n\t\t\telse if (IS_SUBSCRIPT(wd))\n\t\t\t\tnchar = serialize_subscript(buf + bl, buflen - bl, wd);\n\t\t\telse if (IS_FIELD(wd))\n\t\t\t\tnchar = snprintf(buf + bl, buflen - bl, \"%d%c%d%c%d%c\",\n\t\t\t\t            wd->number, FSEP, D_field, FSEP, (int) get_number_si(wd->symbol), FSEP);\n\t\t\telse\n\t\t\t\tnchar = snprintf(buf + bl, buflen - bl, \"%d%c%d%c%s%c\",\n\t\t\t\t            wd->number, FSEP, D_variable, FSEP, wd->sname, FSEP);\n\t\t\tcnum = wd->number;\n\t\t\tcommands = &wd->commands;\n\t\t\tcndn = &wd->cndn;\n\t\t\tbreak;\n\t\tcase HISTORY:\n#if defined(HAVE_LIBREADLINE) && defined(HAVE_HISTORY_LIST)\n\t\t\th = (HIST_ENTRY *) ptr;\n\t\t\tnchar = strlen(h->line);\n\t\t\tif (nchar >= buflen - bl)\n\t\t\t\tgoto enlarge_buffer;\n\t\t\tstrcpy(buf + bl, h->line);\n#endif\n\t\t\tbreak;\n\t\tcase OPTION:\n\t\t\topt = (struct dbg_option *) ptr;\n\t\t\tif (opt->num_val != NULL)\n\t\t\t\tnchar = snprintf(buf + bl, buflen - bl,\n\t\t\t\t\t\t\t\t\"%s%c%d%c\", opt->name, FSEP, *(opt->num_val), FSEP);\n\t\t\telse\n\t\t\t\tnchar = snprintf(buf + bl, buflen - bl,\n\t\t\t\t\t\t\t\t\"%s%c%s%c\", opt->name, FSEP, *(opt->str_val), FSEP);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (nchar == 0)\t/* skip empty history lines etc.*/\n\t\t\t;\n\t\telse if (nchar > 0 && nchar  < buflen - bl) {\n\t\t\tbl += nchar;\n\t\t\tbuf[bl] = RSEP;\t/* record */\n\t\t\tbuf[++bl] = '\\0';\n\t\t} else\n\t\t\tgoto enlarge_buffer;\n\n\t\tswitch (type) {\n\t\tcase BREAK:\n\t\tcase WATCH:\n\t\t\t/* recreate the `commands' command strings including the `commands'\n\t\t\t * and `end' commands; command seperator is '\\034'.\n\t\t\t * re-parsed in unserialize_list to recover the commands list.\n\t\t\t * Alternatively, one could encode(serialize) each command and it's arguments.\n\t\t\t */\n\n\t\t\tbl--;\t/* undo RSEP from above */\n\n\t\t\t/* compute required room in buffer */\n\t\t\tnchar = 0;\n\t\t\tfor (c = commands->next; c != commands; c = c->next) {\n\t\t\t\tnchar += (strlen(c->cmd_string) + 1);\n\t\t\t\tif (c->cmd == D_eval) {\n\t\t\t\t\tCMDARG *a = c->arg;\n\t\t\t\t\tnchar += (strlen(a->a_string) + 1);\t/* awk statements */\n\t\t\t\t\tnchar += (strlen(\"end\") + 1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (nchar > 0) {\t/* non-empty commands list */\n\t\t\t\tnchar += (strlen(\"commands \") + 20 + strlen(\"end\") + 1); /* 20 for cnum (an int) */\n\t\t\t\tif (nchar > buflen - bl) {\n\t\t\t\t\tbuflen = bl + nchar;\n\t\t\t\t\terealloc(buf, char *, buflen + 3, \"serialize_list\");\n\t\t\t\t}\n\t\t\t\tnchar = sprintf(buf + bl, \"commands %d\", cnum);\n\t\t\t\tbl += nchar;\n\t\t\t\tbuf[bl++] = CSEP;\n\t\t\t\tfor (c = commands->next; c != commands; c = c->next) {\n\t\t\t\t\tnchar = strlen(c->cmd_string);\n\t\t\t\t\tmemcpy(buf + bl, c->cmd_string, nchar);\n\t\t\t\t\tbl += nchar;\n\t\t\t\t\tbuf[bl++] = CSEP;\n\n\t\t\t\t\tif (c->cmd == D_eval) {\n\t\t\t\t\t\tCMDARG *a = c->arg;\n\t\t\t\t\t\tnchar = strlen(a->a_string);\t/* statements */\n\t\t\t\t\t\tmemcpy(buf + bl, a->a_string, nchar);\n\t\t\t\t\t\tbl += nchar;\n\t\t\t\t\t\tbuf[bl++] = CSEP;\n\t\t\t\t\t\tnchar = strlen(\"end\");\t/* end of 'eval' */\n\t\t\t\t\t\tmemcpy(buf + bl, \"end\", nchar);\n\t\t\t\t\t\tbl += nchar;\n\t\t\t\t\t\tbuf[bl++] = CSEP;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnchar = strlen(\"end\");\t/* end of 'commands' */\n\t\t\t\tmemcpy(buf + bl, \"end\", nchar);\n\t\t\t\tbl += nchar;\n\t\t\t}\n\t\t\tbuf[bl++] = FSEP;\t\t/* field */\n\t\t\tbuf[bl++] = RSEP;\t\t/* record */\n\t\t\tbuf[bl] = '\\0';\n\n\t\t\t/* condition expression */\n\t\t\tif (cndn->expr) {\n\t\t\t\tbl--;\t/* undo RSEP from above */\n\t\t\t\tnchar = strlen(cndn->expr);\n\t\t\t\tif (nchar > buflen - bl) {\n\t\t\t\t\tbuflen = bl + nchar;\n\t\t\t\t\terealloc(buf, char *, buflen + 3, \"serialize_list\");\n\t\t\t\t}\n\t\t\t\tmemcpy(buf + bl, cndn->expr, nchar);\n\t\t\t\tbl += nchar;\n\t\t\t\tbuf[bl++] = FSEP;\t\t/* field */\n\t\t\t\tbuf[bl++] = RSEP;\t\t/* record */\n\t\t\t\tbuf[bl] = '\\0';\n\t\t\t}\n\n\t\t\tptr = (type == BREAK) ? (void *) b->prev : (void *) wd->prev;\n\t\t\tbreak;\n\t\tcase DISPLAY:\n\t\t\tptr = (void *) wd->prev;\n\t\t\tbreak;\n\t\tcase HISTORY:\n\t\t\tptr = (void *) hist_list[++hist_index];\n\t\t\tbreak;\n\t\tcase OPTION:\n\t\t\tptr = (void *) (++opt);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (bl > 0)\t/* non-empty list */\n\t\tsetenv(env_variable[type], buf, 1);\n}",
      "lines": 237,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "unserialize_commands": {
      "start_point": [
        4590,
        0
      ],
      "end_point": [
        4601,
        1
      ],
      "content": "static void\nunserialize_commands(char *str, int str_len)\n{\n\tif (str_len <= 0 || str == NULL)\n\t\treturn;\n\tcommands_string = str;\n\tcommands_string_len = str_len;\n\tpush_cmd_src(INVALID_HANDLE, false, read_commands_string, 0, 0, EXIT_FATAL);\n\tline_sep = CSEP;\n\tread_command();\t\t/* forced to return in do_commands */\n\tpop_cmd_src();\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "unserialize_list_item": {
      "start_point": [
        4606,
        0
      ],
      "end_point": [
        4673,
        1
      ],
      "content": "static struct list_item *\nunserialize_list_item(struct list_item *list, char **pstr, int *pstr_len, int field_cnt)\n{\n\tint num, type, i;\n\tstruct list_item *l;\n\tNODE *symbol = NULL;\n\tint sub_cnt = 0, cnt;\n\tNODE **subs = NULL;\n\n\t/* subscript\t-- number type sname num_subs subs [commands [condition]]\n\t * variable\t\t-- number type sname [commands [condition]]\n\t * field\t\t-- number type symbol(numbr) commands [commands [condition]]\n\t */\n\n\tnum = strtol(pstr[0], NULL, 0);\n\ttype = strtol(pstr[1], NULL, 0);\n\n\tif (type == D_field) {\n\t\tint field_num;\n\t\tfield_num = strtol(pstr[2], NULL, 0);\n\t\tsymbol = make_number((AWKNUM) field_num);\n\t\tcnt = 3;\n\t} else {\n\t\tchar *name;\n\t\tname = estrdup(pstr[2], pstr_len[2]);\n\t\tsymbol = find_symbol(name, NULL);\n\t\tefree(name);\n\t\tif (symbol == NULL)\n\t\t\treturn NULL;\n\t\tcnt = 3;\n\t\tif (type == D_subscript) {\n\t\t\tint sub_len;\n\t\t\tsub_cnt = strtol(pstr[3], NULL, 0);\n\t\t\temalloc(subs, NODE **, sub_cnt * sizeof(NODE *), \"unserialize_list_item\");\n\t\t\tcnt++;\n\t\t\tfor (i = 0; i < sub_cnt; i++) {\n\t\t\t\tsub_len = strtol(pstr[cnt], NULL, 0);\n\t\t\t\tsubs[i] = make_string(pstr[cnt + 1], sub_len);\n\t\t\t\tcnt += 2;\n\t\t\t}\n\t\t}\n\t}\n\n\tl = add_item(list, type, symbol, NULL);\n\tif (type == D_subscript) {\n\t\tl->num_subs = sub_cnt;\n\t\tl->subs = subs;\n\t}\n\tl->number = num;\t/* keep same item number across executions */\n\n\tif (list == &watch_list) {\n\t\tinitialize_watch_item(l);\n\t\t/* unserialize watchpoint `commands' */\n\t\tunserialize_commands(pstr[cnt], pstr_len[cnt]);\n\t\tcnt++;\n\t\tif (field_cnt > cnt) {\n\t\t\tchar *expr;\n\t\t\texpr = estrdup(pstr[cnt], pstr_len[cnt]);\n\t\t\tif (parse_condition(D_watch, l->number, expr) != 0)\n\t\t\t\tefree(expr);\n\t\t}\n\t\tif (num > list->number)   /* update list number counter */\n\t\t\tlist->number = num;\n\t} else\n\t\tlist->number = num;\n\n\treturn l;\n}",
      "lines": 68,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "struct list_item",
        "struct",
        "list_item",
        "*\nunserialize_list_item(struct list_item *list, char **pstr, int *pstr_len, int field_cnt)",
        "*"
      ]
    },
    "unserialize_breakpoint": {
      "start_point": [
        4677,
        0
      ],
      "end_point": [
        4721,
        1
      ],
      "content": "static BREAKPOINT *\nunserialize_breakpoint(char **pstr, int *pstr_len, int field_cnt)\n{\n\tchar *src;\n\tint lineno;\n\tBREAKPOINT *b = NULL;\n\tINSTRUCTION *rp;\n\tSRCFILE *s;\n\n\t/* src source_line flags ignore_count hit_count number commands [condition] */\n\n\tsrc = estrdup(pstr[0], pstr_len[0]);\n\ts = source_find(src);\n\tefree(src);\n\tif (s == NULL)\n\t\treturn NULL;\n\tsrc = s->src;\n\tlineno = strtol(pstr[1], NULL, 0);\n\tif (lineno <= 0 || lineno > s->srclines)\n\t\treturn NULL;\n\trp = find_rule(src, lineno);\n\tif (rp == NULL\n\t\t\t||  (b = set_breakpoint_at(rp, lineno, true)) == NULL\n\t)\n\t\treturn NULL;\n\n\tb->flags =  strtol(pstr[2], NULL, 0);\n\tb->ignore_count = strtol(pstr[3], NULL, 0);\n\tb->hit_count = strtol(pstr[4], NULL, 0);\n\tb->number =  strtol(pstr[5], NULL, 0);\t/* same number as previous run */\n\n\tif (field_cnt > 6)\t/* unserialize breakpoint `commands' */\n\t\tunserialize_commands(pstr[6], pstr_len[6]);\n\n\tif (field_cnt > 7) {\t/* condition expression */\n\t\tchar *expr;\n\t\texpr = estrdup(pstr[7], pstr_len[7]);\n\t\tif (parse_condition(D_break, b->number, expr) != 0)\n\t\t\tefree(expr);\n\t}\n\n\tif (b->number > watch_list.number)  /* watch and break has same number counter */\n\t\twatch_list.number = b->number;  /* update counter */\n\treturn b;\n}",
      "lines": 45,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "BREAKPOINT",
        "*\nunserialize_breakpoint(char **pstr, int *pstr_len, int field_cnt)",
        "*"
      ]
    },
    "unserialize_option": {
      "start_point": [
        4725,
        0
      ],
      "end_point": [
        4741,
        1
      ],
      "content": "static struct dbg_option *\nunserialize_option(char **pstr, int *pstr_len, int field_cnt ATTRIBUTE_UNUSED)\n{\n\tconst struct dbg_option *opt;\n\n\tfor (opt = option_list; opt->name; opt++) {\n\t\tif (strncmp(pstr[0], opt->name, pstr_len[0]) == 0) {\n\t\t\tchar *value;\n\n\t\t\tvalue = estrdup(pstr[1], pstr_len[1]);\n\t\t\t(*(opt->assign))(value);\n\t\t\tefree(value);\n\t\t\treturn ((struct dbg_option *) opt);\n\t\t}\n\t}\n\treturn NULL;\n}",
      "lines": 17,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "struct dbg_option",
        "struct",
        "dbg_option",
        "*\nunserialize_option(char **pstr, int *pstr_len, int field_cnt ATTRIBUTE_UNUSED)",
        "*"
      ]
    },
    "unserialize_list": {
      "start_point": [
        4747,
        0
      ],
      "end_point": [
        4811,
        1
      ],
      "content": "static void\nunserialize_list(int type)\n{\n\tchar *val;\n\tchar *p, *q, *r, *s;\n#define MAX_FIELD 30\n\tstatic char *pstr[MAX_FIELD];\n\tstatic int pstr_len[MAX_FIELD];\n\n\tval = getenv(env_variable[type]);\n\tif (val == NULL)\n\t\treturn;\n\n\tfor (p = val; (q = strchr(p, RSEP)) != NULL; p = q + 1) {\n\t\tint field_cnt = 0;\n\t\tif (type == HISTORY) {\n\t\t\t*q = '\\0';\n\t\t\tadd_history(p);\n\t\t\t*q = RSEP;\n\t\t\tcontinue;\n\t\t}\n\n\t\tr = p;\n\t\twhile ((s = strchr(r, FSEP)) != NULL && s < q) {\n\t\t\tpstr[field_cnt] = r;\n\t\t\tpstr_len[field_cnt] = (int) (s - r);\n\t\t\tr = s + 1;\n\t\t\tfield_cnt++;\n\t\t\tif (field_cnt == MAX_FIELD)\n#ifdef GAWKDEBUG\n\t\t\t\tfatal(\"Increase MAX_FIELD and recompile.\\n\");\n#else\n\t\t\t\treturn;\n#endif\n\t\t}\n\n\t\tswitch (type) {\n\t\tcase BREAK:\n\t\t\t(void) unserialize_breakpoint(pstr, pstr_len, field_cnt);\n\t\t\tbreak;\n\t\tcase DISPLAY:\n\t\t\t(void) unserialize_list_item(&display_list, pstr, pstr_len, field_cnt);\n\t\t\tbreak;\n\t\tcase WATCH:\n\t\t\t(void) unserialize_list_item(&watch_list, pstr, pstr_len, field_cnt);\n\t\t\tbreak;\n\t\tcase OPTION:\n\t\t\t(void) unserialize_option(pstr, pstr_len, field_cnt);\n\t\t\tbreak;\n\t\tcase HISTORY:\n\t\t\t/* processed at the beginning of for loop */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n#ifdef HAVE_LIBREADLINE\n\tif (type == HISTORY)\n\t\tsess_history_base = history_length;\n#endif\n\n\tunsetenv(env_variable[type]);\n#undef MAX_FIELD\n}",
      "lines": 65,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "prompt_yes_no": {
      "start_point": [
        4813,
        0
      ],
      "end_point": [
        4828,
        1
      ],
      "content": "static int\nprompt_yes_no(const char *mesg, char res_true, int res_default, FILE *fp)\n{\n\tchar *in_str;\n\tint ret = res_default; /* default */\n\n\tif (input_from_tty) {\n\t\tfprintf(fp, \"%s\", _(mesg));\n\t\tin_str = read_a_line(NULL);\n\t\tif (in_str == NULL)\t/* EOF */\n\t\t\texit(EXIT_FAILURE);\n\t\tret = (*in_str == res_true);\n\t\tefree(in_str);\n\t}\n\treturn ret;\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "has_break_or_watch_point": {
      "start_point": [
        4837,
        0
      ],
      "end_point": [
        4881,
        1
      ],
      "content": "int\nhas_break_or_watch_point(int *pnum, bool any)\n{\n\tBREAKPOINT *b = NULL;\n\tstruct list_item *w = NULL;\n\n\tif (any) {\n\t\tif (breakpoints.next != &breakpoints)\n\t\t\tb = breakpoints.next;\n\t\tif (watch_list.next != &watch_list)\n\t\t\tw = watch_list.next;\n\n\t\tif (! b && ! w)\n\t\t\treturn 0;\n\t\tif (b && ! w) {\n\t\t\t*pnum = b->number;\n\t\t\treturn D_break;\n\t\t}\n\t\tif (w && ! b) {\n\t\t\t*pnum = w->number;\n\t\t\treturn D_watch;\n\t\t}\n\t\tif (w->number > b->number) {\n\t\t\t*pnum = w->number;\n\t\t\treturn D_watch;\n\t\t}\n\t\t*pnum = b->number;\n\t\treturn D_break;\n\t}\n\n\t/* N.B: breakpoints and watchpoints get numbers from a single\n\t * counter/sequencer watch_list.number.\n\t */\n\n\tfor (b = breakpoints.next; b != &breakpoints; b = b->next) {\n\t\tif (b->number == *pnum)\n\t\t\treturn D_break;\n\t}\n\tfor (w = watch_list.next; w != &watch_list; w = w->next) {\n\t\tif (w->number == *pnum)\n\t\t\treturn D_watch;\n\t}\n\n\treturn 0;\n}",
      "lines": 45,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "delete_commands_item": {
      "start_point": [
        4885,
        0
      ],
      "end_point": [
        4893,
        1
      ],
      "content": "static void\ndelete_commands_item(struct commands_item *c)\n{\n\tefree(c->cmd_string);\n\tfree_cmdarg(c->arg);\n\tc->next->prev = c->prev;\n\tc->prev->next = c->next;\n\tefree(c);\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "do_commands": {
      "start_point": [
        4897,
        0
      ],
      "end_point": [
        4963,
        1
      ],
      "content": "int\ndo_commands(CMDARG *arg, int cmd)\n{\n\tstatic BREAKPOINT *b;\n\tstatic struct list_item *w;\n\tstatic struct commands_item *commands;\n\tstruct commands_item *c;\n\n\tif (cmd == D_commands) {\n\t\tint num = -1, type;\n\t\tif (arg == NULL)\n\t\t\ttype = has_break_or_watch_point(&num, true);\n\t\telse {\n\t\t\tnum = arg->a_int;\n\t\t\ttype = has_break_or_watch_point(&num, false);\n\t\t}\n\t\tb = NULL;\n\t\tw = NULL;\n\t\tif (type == D_break)\n\t\t\tb = find_breakpoint(num);\n\t\telse if (type == D_watch)\n\t\t\tw = find_item(&watch_list, num);\n\t\tassert((b != NULL) || (w != NULL));\n\t\tcommands = (b != NULL) ? &b->commands : &w->commands;\n\n\t\t/* delete current commands */\n\t\tfor (c = commands->next; c != commands; c = c->next) {\n\t\t\tc = c->prev;\n\t\t\tdelete_commands_item(c->next);\n\t\t}\n\t\treturn false;\n\n\t} else if (cmd == D_end) {\n\t\tcommands = NULL;\n\t\tif (read_a_line == read_commands_string) /* unserializig commands */\n\t\t\treturn true;\t/* done unserializing, terminate zzparse() */\n\t\treturn false;\n\n\t} else if (cmd == D_silent) {\n\t\tif (b != NULL)\n\t\t\tb->silent = true;\n\t\telse if (w != NULL)\n\t\t\tw->silent = true;\n\t\t/* we also append silent command to the list for use\n\t\t * in `info break(watch)', and to simplify\n\t\t * serialization/unserialization of commands.\n\t\t */\n\t}\n\n\tassert(commands != NULL);\n\n\temalloc(c, struct commands_item *, sizeof(struct commands_item), \"do_commands\");\n\tc->next = NULL;\n\tc->cmd = cmd;\n\n\t/* N.B.: first arg is the command string, see command.y */\n\tc->cmd_string = arg->a_string;\n\tc->arg = arg->next; /* actual arguments to the command */\n\tefree(arg);\n\n\t/* append to the list */\n\tc->prev = commands->prev;\n\tc->next = commands;\n\tcommands->prev = c;\n\tc->prev->next = c;\n\treturn false;\n}",
      "lines": 67,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "execute_commands": {
      "start_point": [
        4970,
        0
      ],
      "end_point": [
        4986,
        1
      ],
      "content": "static int\nexecute_commands(struct commands_item *commands)\n{\n\tstruct commands_item *c;\n\tFunc_cmd cmd_ptr;\n\tbool ret = false;\n\n\tfor (c = commands->next; c != commands; c = c->next) {\n\t\tif (c->cmd == D_silent)\n\t\t\tcontinue;\n\t\tcmd_ptr = get_command(c->cmd);\t\t/* command handler */\n\t\tret = (*cmd_ptr)(c->arg, c->cmd);\n\t\tif (ret)\t/* resume execution (continue, next etc.) */\n\t\t\tbreak;\n\t}\n\treturn ret;\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "do_print_f": {
      "start_point": [
        4990,
        0
      ],
      "end_point": [
        5095,
        1
      ],
      "content": "int\ndo_print_f(CMDARG *arg, int cmd ATTRIBUTE_UNUSED)\n{\n\tint count = 0;\n\tint i;\n\tCMDARG *a;\n\tNODE **tmp;\n\tchar *name;\n\tNODE *r;\n\tvolatile jmp_buf fatal_tag_stack;\n\n\t/* count maximum required size for tmp */\n\tfor (a = arg; a != NULL ; a = a->next)\n\t\tcount++;\n\temalloc(tmp, NODE **, count * sizeof(NODE *), \"do_print_f\");\n\n\tfor (i = 0, a = arg; a != NULL ; i++, a = a->next) {\n\t\tswitch (a->type) {\n\t\tcase D_variable:\n\t\t\tname = a->a_string;\n\t\t\tr = find_symbol(name, NULL);\n\t\t\tif (r == NULL)\n\t\t\t\tgoto done;\n\t\t\tif (r->type == Node_var_new)\n\t\t\t\ttmp[i] = Nnull_string;\n\t\t\telse if (r->type != Node_var) {\n\t\t\t\td_error(_(\"`%s' is not a scalar variable\"), name);\n\t\t\t\tgoto done;\n\t\t\t} else\n\t\t\t\ttmp[i] = r->var_value;\n\t\t\tbreak;\n\t\tcase D_field:\n\t\t{\n\t\t\tlong field_num;\n\t\t\tr = a->a_node;\n\t\t\tfield_num = get_number_si(r);\n\t\t\ttmp[i] = *get_field(field_num, NULL);\n\t\t}\n\t\t\tbreak;\n\t\tcase D_subscript:\n\t\t{\n\t\t\tint cnt = a->a_count;\n\t\t\tname = a->a_string;\n\t\t\tr = find_array(name);\n\t\t\tif (r == NULL)\n\t\t\t\tgoto done;\n\n\t\t\tfor (; cnt > 0; cnt--) {\n\t\t\t\tNODE *value, *subs;\n\t\t\t\ta = a->next;\n\t\t\t\tsubs = a->a_node;\n\t\t\t\tvalue = in_array(r, subs);\n\t\t\t\tif (cnt == 1) {\n\t\t\t\t\tif (value == NULL)\n\t\t\t\t\t\ttmp[i] = Nnull_string;\t\t/* FIXME: goto done ? */\n\t\t\t\t\telse if (value->type == Node_var_array) {\n\t\t\t\t\t\td_error(_(\"attempt to use array `%s[\\\"%.*s\\\"]' in a scalar context\"),\n\t\t\t\t\t\t\t\t\tname, (int) subs->stlen, subs->stptr);\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t} else\n\t\t\t\t\t\ttmp[i] = value;\n\t\t\t\t} else {\n\t\t\t\t\tif (value == NULL) {\n\t\t\t\t\t\td_error(_(\"[\\\"%.*s\\\"] not in array `%s'\"),\n\t\t\t\t\t\t\t\t\t(int) subs->stlen, subs->stptr, name);\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t} else if (value->type != Node_var_array) {\n\t\t\t\t\t\td_error(_(\"attempt to use scalar `%s[\\\"%.*s\\\"]' as array\"),\n\t\t\t\t\t\t\t\t\tname, (int) subs->stlen, subs->stptr);\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr = value;\n\t\t\t\t\t\tname = r->vname;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\tbreak;\n\t\tcase D_node:\n\t\t\ttmp[i] = a->a_node;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\ttmp[0] = force_string(tmp[0]);\n\n\tPUSH_BINDING(fatal_tag_stack, fatal_tag, fatal_tag_valid);\n\tif (setjmp(fatal_tag) == 0)\n\t\tr = format_tree(tmp[0]->stptr, tmp[0]->stlen, tmp, i);\n\telse {\n\t\t/* fatal error, restore exit_val of program */\n\t\texit_val = EXIT_SUCCESS;\n\t\tr = NULL;\n\t}\n\tPOP_BINDING(fatal_tag_stack, fatal_tag, fatal_tag_valid);\n\n\tif (r != NULL) {\n\t\t(void) fwrite(r->stptr, sizeof(char), r->stlen, out_fp);\n\t\tunref(r);\n\t}\ndone:\n\tefree(tmp);\n\treturn false;\n}",
      "lines": 106,
      "depth": 22,
      "decorators": [
        "int"
      ]
    },
    "do_source": {
      "start_point": [
        5099,
        0
      ],
      "end_point": [
        5115,
        1
      ],
      "content": "int\ndo_source(CMDARG *arg, int cmd ATTRIBUTE_UNUSED)\n{\n\tint fd;\n\tchar *file = arg->a_string;\n\n\tfd = open_readfd(file);\n\tif (fd <= INVALID_HANDLE) {\n\t\td_error(_(\"can't open source file `%s' for reading (%s)\"),\n\t\t\t\t\tfile, strerror(errno));\n\t\treturn false;\n\t}\n\n\tpush_cmd_src(fd, false, g_readline, close, D_source, EXIT_SUCCESS);\n\tcmd_src->str = estrdup(file, strlen(file));\n\treturn false;\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "open_readfd": {
      "start_point": [
        5119,
        0
      ],
      "end_point": [
        5133,
        1
      ],
      "content": "static int\nopen_readfd(const char *file)\n{\n\tint fd;\n\n\tfd = open(file, O_RDONLY);\n\tif (fd <= INVALID_HANDLE)\n\t\treturn INVALID_HANDLE;\n\telse if (os_isdir(fd)) {\n\t\t(void) close(fd);\n\t\terrno = EISDIR;\n\t\treturn INVALID_HANDLE;\n\t}\n\treturn fd;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "find_option": {
      "start_point": [
        5137,
        0
      ],
      "end_point": [
        5148,
        1
      ],
      "content": "int\nfind_option(char *name)\n{\n\tconst char *p;\n\tint idx;\n\n\tfor (idx = 0; (p = option_list[idx].name); idx++) {\n\t\tif (strcmp(p, name) == 0)\n\t\t\treturn idx;\n\t}\n\treturn -1;\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "option_help": {
      "start_point": [
        5152,
        0
      ],
      "end_point": [
        5159,
        1
      ],
      "content": "void\noption_help()\n{\n\tconst struct dbg_option *opt;\n\n\tfor (opt = option_list; opt->name; opt++)\n\t\tfprintf(out_fp, \"\\t%-15.15s - %s\\n\", opt->name, _(opt->help_txt));\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "option_generator": {
      "start_point": [
        5165,
        0
      ],
      "end_point": [
        5182,
        1
      ],
      "content": "char *\noption_generator(const char *text, int state)\n{\n\tstatic size_t textlen;\n\tstatic int idx;\n\tconst char *name;\n\n\tif (! state) {\t/* first time */\n\t\ttextlen = strlen(text);\n\t\tidx = 0;\n\t}\n\n\twhile ((name = option_list[idx++].name)) {\n\t\tif (strncmp(name, text, textlen) == 0)\n\t\t\treturn estrdup(name, strlen(name));\n\t}\n\treturn NULL;\n}",
      "lines": 18,
      "depth": 11,
      "decorators": [
        "char",
        "*\noption_generator(const char *text, int state)",
        "*"
      ]
    },
    "set_gawk_output": {
      "start_point": [
        5188,
        0
      ],
      "end_point": [
        5261,
        1
      ],
      "content": "static void\nset_gawk_output(const char *file)\n{\n\tint fd = INVALID_HANDLE;\n\tFILE *fp = NULL;\n\n\tif (output_fp != stdout) {\n\t\tif (output_fp != stderr) {\n\t\t\tfclose(output_fp);\n\t\t\tefree(output_file);\n\t\t}\n\t\toutput_fp = stdout;\n\t\toutput_is_tty = os_isatty(fileno(stdout));\n\t\toutput_file = \"/dev/stdout\";\n\t}\n\n\tif (file == NULL || file[0] == '\\0')\n\t\treturn;\n\n\terrno = 0;\n\tif ((fd = os_devopen(file, O_WRONLY)) != INVALID_HANDLE) {\n\t\tfp = fdopen(fd, \"w\");\n\t\tif (fp == NULL)\n\t\t\tclose(fd);\n\n\t} else if (strncmp(file, \"/dev/\", 5) == 0) {\n\t\tchar *cp = (char *) file + 5;\n\n\t\tif (strcmp(cp, \"stdout\") == 0)\n\t\t\treturn;\n\t\tif (strcmp(cp, \"stderr\") == 0) {\n\t\t\toutput_fp = stderr;\n\t\t\toutput_file = \"/dev/stderr\";\n\t\t\toutput_is_tty = os_isatty(fileno(stderr));\n\t\t\treturn;\n\t\t}\n\n\t\tif (strncmp(cp, \"fd/\", 3) == 0) {\n\t\t\tcp += 3;\n\t\t\tfd = (int) strtoul(cp, NULL, 10);\n\t\t\tif (errno == 0 && fd > INVALID_HANDLE) {\n\t\t\t\tfp = fdopen(fd, \"w\");\n\t\t\t\tif (fp == NULL)\n\t\t\t\t\tfd = INVALID_HANDLE;\n\t\t\t} else\n\t\t\t\tfd = INVALID_HANDLE;\n\t\t} else {\n\t\t\t/* /dev/ttyN, /dev/pts/N, /dev/null etc. */\n\t\t\tfd = open(file, O_WRONLY);\n\t\t}\n\n\t\tif (fd > INVALID_HANDLE && fp == NULL) {\n\t\t\tfp = fdopen(fd, \"w\");\n\t\t\tif (fp == NULL)\n\t\t\t\tclose(fd);\n\t\t}\n\n\t} else {\n\t\t/* regular file */\n\t\tfp = fopen(file, \"w\");\n\t}\n\n\tif (fp != NULL) {\n\t\toutput_fp = fp;\n\t\toutput_file = estrdup(file, strlen(file));\n\t\tsetbuf(fp, (char *) NULL);\n\t\toutput_is_tty = os_isatty(fileno(fp));\n\t} else {\n\t\td_error(_(\"could not open `%s' for writing (%s)\"),\n\t\t\t\t\tfile,\n\t\t\t\t\terrno != 0 ? strerror(errno) : _(\"reason unknown\"));\n\t\tfprintf(out_fp, _(\"sending output to stdout\\n\"));\n\t}\n}",
      "lines": 74,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "set_prompt": {
      "start_point": [
        5265,
        0
      ],
      "end_point": [
        5271,
        1
      ],
      "content": "static void\nset_prompt(const char *value)\n{\n\tefree(dgawk_prompt);\n\tdgawk_prompt = estrdup(value, strlen(value));\n\tdbg_prompt = dgawk_prompt;\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "set_option_flag": {
      "start_point": [
        5275,
        0
      ],
      "end_point": [
        5286,
        1
      ],
      "content": "static int\nset_option_flag(const char *value)\n{\n\tlong n;\n\tif (strcmp(value, \"on\") == 0)\n\t\treturn true;\n\tif (strcmp(value, \"off\") == 0)\n\t\treturn false;\n\terrno = 0;\n\tn = strtol(value, NULL, 0);\n\treturn (errno == 0 && n != 0);\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "set_option_num": {
      "start_point": [
        5290,
        0
      ],
      "end_point": [
        5300,
        1
      ],
      "content": "static void\nset_option_num(int *pnum, const char *value)\n{\n\tlong n;\n\terrno = 0;\n\tn = strtol(value, NULL, 0);\n\tif (errno == 0 && n > 0)\n\t\t*pnum = n;\n\telse\n\t\td_error(_(\"invalid number\"));\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "set_listsize": {
      "start_point": [
        5304,
        0
      ],
      "end_point": [
        5308,
        1
      ],
      "content": "static void\nset_listsize(const char *value)\n{\n\tset_option_num(&list_size, value);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "set_trace": {
      "start_point": [
        5312,
        0
      ],
      "end_point": [
        5316,
        1
      ],
      "content": "static void\nset_trace(const char *value)\n{\n\tdo_trace = set_option_flag(value);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "set_save_history": {
      "start_point": [
        5320,
        0
      ],
      "end_point": [
        5324,
        1
      ],
      "content": "static void\nset_save_history(const char *value)\n{\n\tdo_save_history = set_option_flag(value);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "set_save_options": {
      "start_point": [
        5328,
        0
      ],
      "end_point": [
        5332,
        1
      ],
      "content": "static void\nset_save_options(const char *value)\n{\n\tdo_save_options = set_option_flag(value);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "set_history_size": {
      "start_point": [
        5336,
        0
      ],
      "end_point": [
        5340,
        1
      ],
      "content": "static void\nset_history_size(const char *value)\n{\n\tset_option_num(&history_size, value);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "read_commands_string": {
      "start_point": [
        5348,
        0
      ],
      "end_point": [
        5371,
        1
      ],
      "content": "char *\nread_commands_string(const char *prompt ATTRIBUTE_UNUSED)\n{\n\tchar *p, *end, *line;\n\n\tif (commands_string == NULL)\n\t\treturn NULL;\n\n\tp = (char *) commands_string;\n\tend = (char *) commands_string + commands_string_len;\n\tfor (; p < end; p++) {\n\t\tif (*p == line_sep) {\n\t\t\tline = estrdup(commands_string, p - commands_string);\n\t\t\tcommands_string = p + 1;\n\t\t\tcommands_string_len = end - commands_string;\n\t\t\treturn line;\n\t\t}\n\t}\n\n\tline = estrdup(commands_string, commands_string_len);\n\tcommands_string = NULL;\n\tcommands_string_len = 0;\n\treturn line;\n}",
      "lines": 24,
      "depth": 12,
      "decorators": [
        "char",
        "*\nread_commands_string(const char *prompt ATTRIBUTE_UNUSED)",
        "*"
      ]
    },
    "save_options": {
      "start_point": [
        5375,
        0
      ],
      "end_point": [
        5393,
        1
      ],
      "content": "static void\nsave_options(const char *file)\n{\n\tFILE *fp;\n\tconst struct dbg_option *opt;\n\n\tfp = fopen(file, \"w\");\n\tif (fp == NULL)\n\t\treturn;\n\n\tfor (opt = option_list; opt->name; opt++) {\n\t\tif (opt->str_val != NULL)\n\t\t\tfprintf(fp, \"option %s = \\\"%s\\\"\\n\", opt->name, *(opt->str_val));\n\t\telse\n\t\t\tfprintf(fp, \"option %s = %d\\n\", opt->name, *(opt->num_val));\n\t}\n\tfclose(fp);\n\tchmod(file, 0600);\n}",
      "lines": 19,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "close_all": {
      "start_point": [
        5397,
        0
      ],
      "end_point": [
        5419,
        1
      ],
      "content": "static void\nclose_all()\n{\n\tbool stdio_problem;\n\tstruct command_source *cs;\n\n\t(void) nextfile(& curfile, true);\t/* close input data file */\n\t(void) close_io(& stdio_problem);\n\tif (cur_srcfile->fd != INVALID_HANDLE) {\n\t\tclose(cur_srcfile->fd);\n\t\tcur_srcfile->fd = INVALID_HANDLE;\n\t}\n\tfor (cs = cmd_src; cs != NULL; cs = cs->next) {\n\t\tif (cs->close_func && cs->fd != INVALID_HANDLE) {\n\t\t\tcs->close_func(cs->fd);\n\t\t\tcs->fd = INVALID_HANDLE;\n\t\t}\n\t}\n\n\tclose_extensions();\n\n\tset_gawk_output(NULL);\t/* closes output_fp if not stdout */\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "pre_execute_code": {
      "start_point": [
        5423,
        0
      ],
      "end_point": [
        5453,
        1
      ],
      "content": "static int\npre_execute_code(INSTRUCTION **pi)\n{\n\tINSTRUCTION *ei = *pi;\n\n\tswitch (ei->opcode) {\n\tcase Op_K_exit:\n\tcase Op_K_next:\n\tcase Op_K_nextfile:\n\tcase Op_K_getline:\t/* getline without redirection */\n\t\td_error(_(\"`%s' not allowed in current context;\"\n\t\t\t\t\" statement ignored\"),\n\t\t\t\top2str(ei->opcode));\n\t\t*pi = ei->nexti;\n\t\tbreak;\n\tcase Op_K_return:\n\t\tif (ei->nexti != NULL) {\t/* not an implicit return */\n\t\t\tNODE *r;\n\t\t\td_error(_(\"`return' not allowed in current context;\"\n\t\t\t\t\t\" statement ignored\"));\n\t\t\t/* throw away return value already pushed onto stack */\n\t\t\tr = POP_SCALAR();\n\t\t\tDEREF(r);\n\t\t\t*pi = ei->nexti;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn (ei == *pi);\n}",
      "lines": 31,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "execute_code": {
      "start_point": [
        5457,
        0
      ],
      "end_point": [
        5487,
        1
      ],
      "content": "static NODE *\nexecute_code(volatile INSTRUCTION *code)\n{\n\tvolatile NODE *r = NULL;\n\tvolatile jmp_buf fatal_tag_stack;\n\tlong save_stack_size;\n\tint save_flags = do_flags;\n\n\t/* We use one global stack for all contexts.\n\t * Save # of items in stack; in case of\n\t * a fatal error, pop stack until it has that many items.\n\t */\n\n\tsave_stack_size = (stack_ptr  - stack_bottom) + 1;\n\tdo_flags = false;\n\n\tPUSH_BINDING(fatal_tag_stack, fatal_tag, fatal_tag_valid);\n\tif (setjmp(fatal_tag) == 0) {\n\t\t(void) interpret((INSTRUCTION *) code);\n\t\tr = POP_SCALAR();\n\t} else\t/* fatal error */\n\t\t(void) unwind_stack(save_stack_size);\n\n\tPOP_BINDING(fatal_tag_stack, fatal_tag, fatal_tag_valid);\n\tdo_flags = save_flags;\n\tif (exit_val != EXIT_SUCCESS) {\t/* must be EXIT_FATAL? */\n\t\texit_val = EXIT_SUCCESS;\n\t\treturn NULL;\n\t}\n\treturn (NODE *) r;\n}",
      "lines": 31,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "NODE",
        "*\nexecute_code(volatile INSTRUCTION *code)",
        "*"
      ]
    },
    "do_eval": {
      "start_point": [
        5491,
        0
      ],
      "end_point": [
        5637,
        1
      ],
      "content": "int\ndo_eval(CMDARG *arg, int cmd ATTRIBUTE_UNUSED)\n{\n\tNODE *r, *ret_val;\n\tNODE *f = NULL;\n\tNODE *this_frame = NULL, *this_func = NULL;\n\tNODE **sp;\n\tINSTRUCTION *eval, *code = NULL;\n\tAWK_CONTEXT *ctxt;\n\tint ecount = 0, pcount = 0;\n\tint ret;\n\tint save_flags = do_flags;\n\tSRCFILE *the_source;\n\n\tif (prog_running) {\n\t\tthis_frame = find_frame(0);\n\t\tthis_func = this_frame->func_node;\n\t}\n\n\tinstall_params(this_func);\t/* expose current function parameters to eval */\n\tctxt = new_context();\n\tctxt->install_func = append_symbol;\t/* keep track of newly installed globals */\n\tpush_context(ctxt);\n\tthe_source = add_srcfile(SRC_CMDLINE, arg->a_string, srcfiles, NULL, NULL);\n\tdo_flags = false;\n\tret = parse_program(&code);\n\tdo_flags = save_flags;\n\tremove_params(this_func);\n\tif (ret != 0) {\n\t\tpop_context();\t/* switch to prev context */\n\t\tfree_context(ctxt, false /* keep_globals */);\n\t\treturn false;\n\t}\n\n\tf = lookup(\"@eval\");\n\tassert(f != NULL);\n\tif (this_func == NULL) {\t/* in main */\n\t\t/* do a function call */\n\t\teval = bcalloc(Op_func_call, 2, 0);\n\t\teval->source_file = cur_srcfile->src;\n\t\teval->func_body = f;\n\t\teval->func_name = NULL;\t/* not needed, func_body already assigned */\n\t\t(eval + 1)->expr_count = 0;\n\t\teval->nexti = bcalloc(Op_stop, 1, 0);\n\n\t} else {\n\t\t/* execute as a part of the current function */\n\t\tint i;\n\t\tINSTRUCTION *t;\n\n\t\teval = f->code_ptr;\t/* Op_func */\n\t\teval->source_file = cur_srcfile->src;\n\t\t/* turn implicit Op_K_return into Op_stop */\n\t\tt = (eval + 1)->lasti;\t/* Op_K_return */\n\t\tt->opcode = Op_stop;\n\n\t\t/* add or append eval locals to the current frame stack */\n\t\tecount = f->param_cnt;\t/* eval local count */\n\t\tpcount = this_func->param_cnt;\n\n\t\tif (ecount > 0) {\n\t\t\tif (pcount == 0)\n\t\t\t\temalloc(this_frame->stack, NODE **, ecount * sizeof(NODE *), \"do_eval\");\n\t\t\telse\n\t\t\t\terealloc(this_frame->stack, NODE **, (pcount + ecount) * sizeof(NODE *), \"do_eval\");\n\n\t\t\tsp = this_frame->stack + pcount;\n\t\t\tfor (i = 0; i < ecount; i++) {\n\t\t\t\tNODE *np;\n\n\t\t\t\tnp = f->fparms + i;\n\t\t\t\tnp->param_cnt += pcount;\t/* appending eval locals: fixup param_cnt */\n\n\t\t\t\tgetnode(r);\n\t\t\t\tmemset(r, 0, sizeof(NODE));\n\t\t\t\t*sp++ = r;\n\t\t\t\t/* local variable */\n\t\t\t\tr->type = Node_var_new;\n\t\t\t\tr->vname = np->param;\n\t\t\t}\n\n\t\t\tthis_func->param_cnt += ecount;\n\t\t}\n\t}\n\n#if 0\n\tpf_data.print_func = fprintf;\n\tpf_data.fp = out_fp;\n\tpf_data.defn = false;\t/* in_dump = false */\n\t(void) print_code(f->code_ptr, &pf_data);\n#endif\n\n\tret_val = execute_code((volatile INSTRUCTION *) eval);\n\n\tif (ret_val != NULL)\n\t\tDEREF(ret_val);\t/* throw away return value */\n\t/* else\n\t\tfatal error */\n\n\tif (this_func != NULL && ecount > 0) {\n\t\tint i;\n\n\t\t/* undo frame manipulation from above */\n\n\t\t/* free eval locals */\n\t\tsp = this_frame->stack + pcount;\n\t\tfor (i = ecount; i > 0; i--) {\n\t\t\tr = *sp;\n\t\t\tif (r->type == Node_var)     /* eval local variable */\n\t\t\t\tDEREF(r->var_value);\n\t\t\telse if (r->type == Node_var_array)     /* eval local array */\n\t\t\t\tassoc_clear(r);\n\t\t\tfreenode(r);\n\t\t\t*sp++ = (NODE *) 0;\n\t\t}\n\t\tif (pcount == 0) {\n\t\t\tefree(this_frame->stack);\n\t\t\tthis_frame->stack = NULL;\n\t\t} /* else\n\t\t\t\trestore_frame() will free it */\n\n\t\tthis_func->param_cnt -= ecount;\n\t}\n\n\t/*\n\t * Always destroy symbol \"@eval\", however destroy all newly installed\n\t * globals only if fatal error (execute_code() returing NULL).\n\t */\n\n\tpop_context();\t/* switch to prev context */\n\tfree_context(ctxt, (ret_val != NULL));   /* free all instructions and optionally symbols */\n\n\tif (ret_val != NULL) {\n\t\t/*\n\t\t * Remove @eval from FUNCTAB, so that above code\n\t\t * will work the next time around.\n\t\t */\n\t\tNODE *s = make_string(\"@eval\", 5);\n\n\t\t(void) assoc_remove(func_table, s);\n\t\tunref(s);\n\t}\n\n\tfree_srcfile(the_source);\n\n\treturn false;\n}",
      "lines": 147,
      "depth": 16,
      "decorators": [
        "int"
      ]
    },
    "check_symbol": {
      "start_point": [
        5652,
        0
      ],
      "end_point": [
        5659,
        1
      ],
      "content": "static void\ncheck_symbol(NODE *r)\n{\n\tinvalid_symbol++;\n\td_error(_(\"No symbol `%s' in current context\"), r->vname);\n\t/* install anyway, but keep track of it */\n\tappend_symbol(r);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "parse_condition": {
      "start_point": [
        5663,
        0
      ],
      "end_point": [
        5741,
        1
      ],
      "content": "static int\nparse_condition(int type, int num, char *expr)\n{\n\tINSTRUCTION *code = NULL;\n\tAWK_CONTEXT *ctxt = NULL;\n\tint ret;\n\tBREAKPOINT *b;\n\tstruct list_item *w;\n\tNODE *this_func = NULL;\n\tINSTRUCTION *it, *stop, *rule;\n\tstruct condition *cndn = NULL;\n\tint save_flags = do_flags;\n\n\tif (type == D_break && (b = find_breakpoint(num)) != NULL) {\n\t\tINSTRUCTION *rp;\n\t\tcndn = &b->cndn;\n\t\trp = find_rule(b->src, b->bpi->source_line);\n\t\tif (rp != NULL && rp->opcode == Op_func)\n\t\t\tthis_func = rp->func_body;\n\t} else if (type == D_watch && (w = find_item(&watch_list, num)) != NULL) {\n\t\tcndn = &w->cndn;\n\t\tthis_func = find_frame(cur_frame)->func_node;\n\t}\n\n\tif (cndn == NULL)\n\t\treturn -1;\n\tif (expr == NULL)\n\t\tgoto out;\t/* delete condition */\n\n\tinstall_params(this_func);\n\tctxt = new_context();\n\tinvalid_symbol = 0;\n\tctxt->install_func = check_symbol;\n\tpush_context(ctxt);\n\t(void) add_srcfile(SRC_CMDLINE, expr, srcfiles, NULL, NULL);\n\tdo_flags = false;\n\tret = parse_program(&code);\n\tdo_flags = save_flags;\n\tremove_params(this_func);\n\tpop_context();\n\n\tif (ret != 0 || invalid_symbol) {\n\t\tfree_context(ctxt, false /* keep_globals */);\n\t\treturn -1;\n\t}\n\n\t/* condition expression is parsed as awk pattern without\n\t * any action. The code is then modified to end up with\n\t * a `1.0' on stack when the expression is true, `0.0' otherwise.\n\t */\n\n\tassert(code != NULL);\n\trule = ctxt->rule_list.nexti;\n\tstop = bcalloc(Op_stop, 1, 0);\n\n\tit = rule->firsti;\t/* Op_K_print_rec */\n\tassert(it->opcode == Op_K_print_rec);\n\tit->opcode = Op_push_i;\n\tit->memory = make_number(1.0);\n\tit->nexti = bcalloc(Op_jmp, 1, 0);\n\tit->nexti->target_jmp = stop;\n\tit->nexti->nexti = rule->lasti;\n\n\tit = rule->lasti;\t\t/* Op_no_op, target for Op_jmp_false */\n\tassert(it->opcode == Op_no_op);\n\tit->opcode = Op_push_i;\n\tit->memory = make_number(0.0);\n\tit->nexti = stop;\n\nout:\n\tif (cndn->expr != NULL)\n\t\tefree(cndn->expr);\n\tfree_context(cndn->ctxt, false);\n\tcndn->code = code;\n\tcndn->expr = expr;\n\tcndn->ctxt = ctxt;\n\n\treturn 0;\n}",
      "lines": 79,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "do_condition": {
      "start_point": [
        5745,
        0
      ],
      "end_point": [
        5761,
        1
      ],
      "content": "int\ndo_condition(CMDARG *arg, int cmd ATTRIBUTE_UNUSED)\n{\n\tint type, num;\n\tchar *expr = NULL;\n\n\tnum = arg->a_int;\n\ttype = has_break_or_watch_point(&num, false);\n\tif (! type)\n\t\treturn false;\n\targ = arg->next;\t/* condition expression */\n\tif (arg != NULL)\n\t\texpr = arg->a_string;\n\tif (parse_condition(type, num, expr) == 0 && arg != NULL)\n\t\targ->a_string = NULL;\t/* don't let free_cmdarg free it */\n\treturn false;\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "in_cmd_src": {
      "start_point": [
        5765,
        0
      ],
      "end_point": [
        5774,
        1
      ],
      "content": "int\nin_cmd_src(const char *filename)\n{\n\tstruct command_source *cs;\n\tfor (cs = cmd_src; cs != NULL; cs = cs->next) {\n\t\tif (cs->str != NULL && strcmp(cs->str, filename) == 0)\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
      "lines": 10,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "get_eof_status": {
      "start_point": [
        5776,
        0
      ],
      "end_point": [
        5782,
        1
      ],
      "content": "int\nget_eof_status()\n{\n\tif (cmd_src == NULL)\n\t\treturn EXIT_FATAL;\n\treturn cmd_src->eof_status;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "push_cmd_src": {
      "start_point": [
        5784,
        0
      ],
      "end_point": [
        5813,
        1
      ],
      "content": "void\npush_cmd_src(\n\tint fd,\n\tbool istty,\n\tchar * (*readfunc)(const char *),\n\tint (*closefunc)(int),\n\tint ctype,\n\tint eofstatus)\n{\n\tstruct command_source *cs;\n\temalloc(cs, struct command_source *, sizeof(struct command_source), \"push_cmd_src\");\n\tcs->fd = fd;\n\tcs->is_tty = istty;\n\tcs->read_func = readfunc;\n\tcs->close_func = closefunc;\n\tcs->cmd = ctype;\n\n\t/* eof_status = EXIT_FATAL     - exit with status EXIT_FATAL on EOF or error.\n\t *            = EXIT_FAILURE   - exit status EXIT_FAILURE on error.\n\t *            = EXIT_SUCCESS   - don't exit on EOF or error.\n\t */\n\tcs->eof_status = eofstatus;\n\tcs->str = NULL;\n\tcs->next = cmd_src;\n\tcmd_src = cs;\n\n\tinput_fd = fd;\n\tinput_from_tty = istty;\n\tread_a_line = readfunc;\n}",
      "lines": 30,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "pop_cmd_src": {
      "start_point": [
        5815,
        0
      ],
      "end_point": [
        5835,
        1
      ],
      "content": "int\npop_cmd_src()\n{\n\tstruct command_source *cs;\n\n\tif (cmd_src->next == NULL)\n\t\treturn -1;\n\n\tcs = cmd_src;\n\tcmd_src = cs->next;\n\tif (cs->close_func && cs->fd != INVALID_HANDLE)\n\t\tcs->close_func(cs->fd);\n\tif (cs->str != NULL)\n\t\tefree(cs->str);\n\tefree(cs);\n\n\tinput_fd = cmd_src->fd;\n\tinput_from_tty = cmd_src->is_tty;\n\tread_a_line = cmd_src->read_func;\n\treturn 0;\n}",
      "lines": 21,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "gawk/gawk-4.2.1/eval.c": {
    "load_casetable": {
      "start_point": [
        198,
        0
      ],
      "end_point": [
        226,
        1
      ],
      "content": "void\nload_casetable(void)\n{\n#if defined(LC_CTYPE)\n\tint i;\n\tchar *cp;\n\tstatic bool loaded = false;\n\n\tif (loaded || do_traditional)\n\t\treturn;\n\n\tloaded = true;\n\tcp = setlocale(LC_CTYPE, NULL);\n\n\t/* this is not per standard, but it's pretty safe */\n\tif (cp == NULL || strcmp(cp, \"C\") == 0 || strcmp(cp, \"POSIX\") == 0)\n\t\treturn;\n\n#ifndef USE_EBCDIC\n\t/* use of isalpha is ok here (see is_alpha in awkgram.y) */\n\tfor (i = 0200; i <= 0377; i++) {\n\t\tif (isalpha(i) && islower(i) && i != toupper(i))\n\t\t\tcasetable[i] = toupper(i);\n\t\telse\n\t\t\tcasetable[i] = i;\n\t}\n#endif\n#endif\n}",
      "lines": 29,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "nodetype2str": {
      "start_point": [
        390,
        0
      ],
      "end_point": [
        400,
        1
      ],
      "content": "const char *\nnodetype2str(NODETYPE type)\n{\n\tstatic char buf[40];\n\n\tif (type >= Node_illegal && type <= Node_final)\n\t\treturn nodetypes[(int) type];\n\n\tsprintf(buf, _(\"unknown nodetype %d\"), (int) type);\n\treturn buf;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nnodetype2str(NODETYPE type)",
        "*"
      ]
    },
    "opcode2str": {
      "start_point": [
        404,
        0
      ],
      "end_point": [
        411,
        1
      ],
      "content": "const char *\nopcode2str(OPCODE op)\n{\n\tif (op >= Op_illegal && op < Op_final)\n\t\treturn optypes[(int) op].desc;\n\tfatal(_(\"unknown opcode %d\"), (int) op);\n\treturn NULL;\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nopcode2str(OPCODE op)",
        "*"
      ]
    },
    "op2str": {
      "start_point": [
        413,
        0
      ],
      "end_point": [
        425,
        1
      ],
      "content": "const char *\nop2str(OPCODE op)\n{\n\tif (op >= Op_illegal && op < Op_final) {\n\t\tif (optypes[(int) op].operator != NULL)\n\t\t\treturn optypes[(int) op].operator;\n\t\telse\n\t\t\tfatal(_(\"opcode %s not an operator or keyword\"),\n\t\t\t\t\toptypes[(int) op].desc);\n\t} else\n\t\tfatal(_(\"unknown opcode %d\"), (int) op);\n\treturn NULL;\n}",
      "lines": 13,
      "depth": 13,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nop2str(OPCODE op)",
        "*"
      ]
    },
    "flags2str": {
      "start_point": [
        430,
        0
      ],
      "end_point": [
        457,
        1
      ],
      "content": "const char *\nflags2str(int flagval)\n{\n\tstatic const struct flagtab values[] = {\n\t\t{ MALLOC, \"MALLOC\" },\n\t\t{ STRING, \"STRING\" },\n\t\t{ STRCUR, \"STRCUR\" },\n\t\t{ NUMCUR, \"NUMCUR\" },\n\t\t{ NUMBER, \"NUMBER\" },\n\t\t{ USER_INPUT, \"USER_INPUT\" },\n\t\t{ INTLSTR, \"INTLSTR\" },\n\t\t{ NUMINT, \"NUMINT\" },\n\t\t{ INTIND, \"INTIND\" },\n\t\t{ WSTRCUR, \"WSTRCUR\" },\n\t\t{ MPFN,\t\"MPFN\" },\n\t\t{ MPZN,\t\"MPZN\" },\n\t\t{ NO_EXT_SET, \"NO_EXT_SET\" },\n\t\t{ NULL_FIELD, \"NULL_FIELD\" },\n\t\t{ ARRAYMAXED, \"ARRAYMAXED\" },\n\t\t{ HALFHAT, \"HALFHAT\" },\n\t\t{ XARRAY, \"XARRAY\" },\n\t\t{ NUMCONSTSTR, \"NUMCONSTSTR\" },\n\t\t{ REGEX, \"REGEX\" },\n\t\t{ 0,\tNULL },\n\t};\n\n\treturn genflags2str(flagval, values);\n}",
      "lines": 28,
      "depth": 8,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nflags2str(int flagval)",
        "*"
      ]
    },
    "genflags2str": {
      "start_point": [
        461,
        0
      ],
      "end_point": [
        493,
        1
      ],
      "content": "const char *\ngenflags2str(int flagval, const struct flagtab *tab)\n{\n\tstatic char buffer[BUFSIZ];\n\tchar *sp;\n\tint i, space_left, space_needed;\n\n\tsp = buffer;\n\tspace_left = BUFSIZ;\n\tfor (i = 0; tab[i].name != NULL; i++) {\n\t\tif ((flagval & tab[i].val) != 0) {\n\t\t\t/*\n\t\t\t * note the trick, we want 1 or 0 for whether we need\n\t\t\t * the '|' character.\n\t\t\t */\n\t\t\tspace_needed = (strlen(tab[i].name) + (sp != buffer));\n\t\t\tif (space_left <= space_needed)\n\t\t\t\tfatal(_(\"buffer overflow in genflags2str\"));\n\n\t\t\tif (sp != buffer) {\n\t\t\t\t*sp++ = '|';\n\t\t\t\tspace_left--;\n\t\t\t}\n\t\t\tstrcpy(sp, tab[i].name);\n\t\t\t/* note ordering! */\n\t\t\tspace_left -= strlen(sp);\n\t\t\tsp += strlen(sp);\n\t\t}\n\t}\n\n\t*sp = '\\0';\n\treturn buffer;\n}",
      "lines": 33,
      "depth": 15,
      "decorators": [
        "const",
        "const",
        "char",
        "*\ngenflags2str(int flagval, const struct flagtab *tab)",
        "*"
      ]
    },
    "posix_compare": {
      "start_point": [
        497,
        0
      ],
      "end_point": [
        574,
        1
      ],
      "content": "static int\nposix_compare(NODE *s1, NODE *s2)\n{\n\tint ret = 0;\n\tchar save1, save2;\n\tsize_t l = 0;\n\n\tsave1 = s1->stptr[s1->stlen];\n\ts1->stptr[s1->stlen] = '\\0';\n\n\tsave2 = s2->stptr[s2->stlen];\n\ts2->stptr[s2->stlen] = '\\0';\n\n\tif (gawk_mb_cur_max == 1) {\n\t\tif (strlen(s1->stptr) == s1->stlen && strlen(s2->stptr) == s2->stlen)\n\t\t\tret = strcoll(s1->stptr, s2->stptr);\n\t\telse {\n\t\t\tchar b1[2], b2[2];\n\t\t\tchar *p1, *p2;\n\t\t\tsize_t i;\n\n\t\t\tif (s1->stlen < s2->stlen)\n\t\t\t\tl = s1->stlen;\n\t\t\telse\n\t\t\t\tl = s2->stlen;\n\n\t\t\tb1[1] = b2[1] = '\\0';\n\t\t\tfor (i = ret = 0, p1 = s1->stptr, p2 = s2->stptr;\n\t\t\t     ret == 0 && i < l;\n\t\t\t     p1++, p2++) {\n\t\t\t\tb1[0] = *p1;\n\t\t\t\tb2[0] = *p2;\n\t\t\t\tret = strcoll(b1, b2);\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * Either worked through the strings or ret != 0.\n\t\t * In either case, ret will be the right thing to return.\n\t\t */\n\t}\n#if ! defined(__DJGPP__)\n\telse {\n\t\t/* Similar logic, using wide characters */\n\t\t(void) force_wstring(s1);\n\t\t(void) force_wstring(s2);\n\n\t\tif (wcslen(s1->wstptr) == s1->wstlen && wcslen(s2->wstptr) == s2->wstlen)\n\t\t\tret = wcscoll(s1->wstptr, s2->wstptr);\n\t\telse {\n\t\t\twchar_t b1[2], b2[2];\n\t\t\twchar_t *p1, *p2;\n\t\t\tsize_t i;\n\n\t\t\tif (s1->wstlen < s2->wstlen)\n\t\t\t\tl = s1->wstlen;\n\t\t\telse\n\t\t\t\tl = s2->wstlen;\n\n\t\t\tb1[1] = b2[1] = L'\\0';\n\t\t\tfor (i = ret = 0, p1 = s1->wstptr, p2 = s2->wstptr;\n\t\t\t     ret == 0 && i < l;\n\t\t\t     p1++, p2++) {\n\t\t\t\tb1[0] = *p1;\n\t\t\t\tb2[0] = *p2;\n\t\t\t\tret = wcscoll(b1, b2);\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * Either worked through the strings or ret != 0.\n\t\t * In either case, ret will be the right thing to return.\n\t\t */\n\t}\n#endif\n\n\ts1->stptr[s1->stlen] = save1;\n\ts2->stptr[s2->stlen] = save2;\n\treturn ret;\n}",
      "lines": 78,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cmp_nodes": {
      "start_point": [
        579,
        0
      ],
      "end_point": [
        630,
        1
      ],
      "content": "int\ncmp_nodes(NODE *t1, NODE *t2, bool use_strcmp)\n{\n\tint ret = 0;\n\tsize_t len1, len2;\n\tint l, ldiff;\n\n\tif (t1 == t2)\n\t\treturn 0;\n\n\t(void) fixtype(t1);\n\t(void) fixtype(t2);\n\n\tif ((t1->flags & NUMBER) != 0 && (t2->flags & NUMBER) != 0)\n\t\treturn cmp_numbers(t1, t2);\n\n\t(void) force_string(t1);\n\t(void) force_string(t2);\n\tlen1 = t1->stlen;\n\tlen2 = t2->stlen;\n\tldiff = len1 - len2;\n\tif (len1 == 0 || len2 == 0)\n\t\treturn ldiff;\n\n\tif (do_posix && ! use_strcmp)\n\t\treturn posix_compare(t1, t2);\n\n\tl = (ldiff <= 0 ? len1 : len2);\n\tif (IGNORECASE) {\n\t\tconst unsigned char *cp1 = (const unsigned char *) t1->stptr;\n\t\tconst unsigned char *cp2 = (const unsigned char *) t2->stptr;\n\t\tchar save1 = t1->stptr[t1->stlen];\n\t\tchar save2 = t2->stptr[t2->stlen];\n\n\n\t\tif (gawk_mb_cur_max > 1) {\n\t\t\tt1->stptr[t1->stlen] = t2->stptr[t2->stlen] = '\\0';\n\t\t\tret = strncasecmpmbs((const unsigned char *) cp1,\n\t\t\t\t\t     (const unsigned char *) cp2, l);\n\t\t\tt1->stptr[t1->stlen] = save1;\n\t\t\tt2->stptr[t2->stlen] = save2;\n\t\t} else {\n\t\t\t/* Could use tolower() here; see discussion above. */\n\t\t\tfor (ret = 0; l-- > 0 && ret == 0; cp1++, cp2++)\n\t\t\t\tret = casetable[*cp1] - casetable[*cp2];\n\t\t}\n\t} else\n\t\tret = memcmp(t1->stptr, t2->stptr, l);\n\n\tret = ret == 0 ? ldiff : ret;\n\treturn ret;\n}",
      "lines": 52,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "push_frame": {
      "start_point": [
        634,
        0
      ],
      "end_point": [
        653,
        1
      ],
      "content": "static void\npush_frame(NODE *f)\n{\n\tstatic long max_fcall;\n\n\t/* NB: frame numbering scheme as in GDB. frame_ptr => frame #0. */\n\n\tfcall_count++;\n\tif (fcall_list == NULL) {\n\t\tmax_fcall = 10;\n\t\temalloc(fcall_list, NODE **, (max_fcall + 1) * sizeof(NODE *), \"push_frame\");\n\t} else if (fcall_count == max_fcall) {\n\t\tmax_fcall *= 2;\n\t\terealloc(fcall_list, NODE **, (max_fcall + 1) * sizeof(NODE *), \"push_frame\");\n\t}\n\n\tif (fcall_count > 1)\n\t\tmemmove(fcall_list + 2, fcall_list + 1, (fcall_count - 1) * sizeof(NODE *));\n\tfcall_list[1] = f;\n}",
      "lines": 20,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "pop_frame": {
      "start_point": [
        658,
        0
      ],
      "end_point": [
        667,
        1
      ],
      "content": "static void\npop_frame()\n{\n\tif (fcall_count > 1)\n\t\tmemmove(fcall_list + 1, fcall_list + 2, (fcall_count - 1) * sizeof(NODE *));\n\tfcall_count--;\n\tassert(fcall_count >= 0);\n\tif (do_debug)\n\t\tframe_popped();\n}",
      "lines": 10,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "dump_fcall_stack": {
      "start_point": [
        672,
        0
      ],
      "end_point": [
        696,
        1
      ],
      "content": "void\ndump_fcall_stack(FILE *fp)\n{\n\tNODE *f, *func;\n\tlong i = 0, j, k = 0;\n\n\tif (fcall_count == 0)\n\t\treturn;\n\tfprintf(fp, _(\"\\n\\t# Function Call Stack:\\n\\n\"));\n\n\t/* current frame */\n\tfunc = frame_ptr->func_node;\n\tfor (j = 0; j <= frame_ptr->num_tail_calls; j++)\n\t\tfprintf(fp, \"\\t# %3ld. %s\\n\", k++, func->vname);\n\n\t/* outer frames except main */\n\tfor (i = 1; i < fcall_count; i++) {\n\t\tf = fcall_list[i];\n\t\tfunc = f->func_node;\n\t\tfor (j = 0; j <= f->num_tail_calls; j++)\n\t\t\tfprintf(fp, \"\\t# %3ld. %s\\n\", k++, func->vname);\n\t}\n\n\tfprintf(fp, \"\\t# %3ld. -- main --\\n\", k);\n}",
      "lines": 25,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "set_IGNORECASE": {
      "start_point": [
        701,
        0
      ],
      "end_point": [
        716,
        1
      ],
      "content": "void\nset_IGNORECASE()\n{\n\tstatic bool warned = false;\n\n\tif ((do_lint || do_traditional) && ! warned) {\n\t\twarned = true;\n\t\tlintwarn(_(\"`IGNORECASE' is a gawk extension\"));\n\t}\n\tload_casetable();\n\tif (do_traditional)\n\t\tIGNORECASE = false;\n   \telse\n\t\tIGNORECASE = boolval(IGNORECASE_node->var_value);\n\tset_RS();\t/* set_RS() calls set_FS() if need be, for us */\n}",
      "lines": 16,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "set_BINMODE": {
      "start_point": [
        720,
        0
      ],
      "end_point": [
        791,
        1
      ],
      "content": "void\nset_BINMODE()\n{\n\tstatic bool warned = false;\n\tchar *p;\n\tNODE *v = fixtype(BINMODE_node->var_value);\n\n\tif ((do_lint || do_traditional) && ! warned) {\n\t\twarned = true;\n\t\tlintwarn(_(\"`BINMODE' is a gawk extension\"));\n\t}\n\tif (do_traditional)\n\t\tBINMODE = TEXT_TRANSLATE;\n\telse if ((v->flags & NUMBER) != 0) {\n\t\tBINMODE = get_number_si(v);\n\t\t/* Make sure the value is rational. */\n\t\tif (BINMODE < TEXT_TRANSLATE)\n\t\t\tBINMODE = TEXT_TRANSLATE;\n\t\telse if (BINMODE > BINMODE_BOTH)\n\t\t\tBINMODE = BINMODE_BOTH;\n\t} else if ((v->flags & STRING) != 0) {\n\t\tp = v->stptr;\n\n\t\t/*\n\t\t * Allow only one of the following:\n\t\t * \"0\", \"1\", \"2\", \"3\",\n\t\t * \"r\", \"w\", \"rw\", \"wr\"\n\t\t * ANYTHING ELSE goes to 3. So there.\n\t\t */\n\t\tswitch (v->stlen) {\n\t\tcase 1:\n\t\t\tswitch (p[0]) {\n\t\t\tcase '0':\n\t\t\tcase '1':\n\t\t\tcase '2':\n\t\t\tcase '3':\n\t\t\t\tBINMODE = p[0] - '0';\n\t\t\t\tbreak;\n\t\t\tcase 'r':\n\t\t\t\tBINMODE = BINMODE_INPUT;\n\t\t\t\tbreak;\n\t\t\tcase 'w':\n\t\t\t\tBINMODE = BINMODE_OUTPUT;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tBINMODE = BINMODE_BOTH;\n\t\t\t\tgoto bad_value;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tswitch (p[0]) {\n\t\t\tcase 'r':\n\t\t\t\tBINMODE = BINMODE_BOTH;\n\t\t\t\tif (p[1] != 'w')\n\t\t\t\t\tgoto bad_value;\n\t\t\t\tbreak;\n\t\t\tcase 'w':\n\t\t\t\tBINMODE = BINMODE_BOTH;\n\t\t\t\tif (p[1] != 'r')\n\t\t\t\t\tgoto bad_value;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\tbad_value:\n\t\t\tlintwarn(_(\"BINMODE value `%s' is invalid, treated as 3\"), p);\n\t\t\tbreak;\n\t\t}\n\t} else\n\t\tBINMODE = 3;\t\t/* shouldn't happen */\n}",
      "lines": 72,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "set_OFS": {
      "start_point": [
        795,
        0
      ],
      "end_point": [
        828,
        1
      ],
      "content": "void\nset_OFS()\n{\n\tstatic bool first = true;\n\tsize_t new_ofs_len;\n\n\tif (first)\t/* true when called from init_vars() in main() */\n\t\tfirst = false;\n\telse {\n\t\t/* rebuild $0 using OFS that was current when $0 changed */\n\t\tif (! field0_valid) {\n\t\t\tget_field(UNLIMITED - 1, NULL);\n\t\t\trebuild_record();\n\t\t}\n\t}\n\n\t/*\n\t * Save OFS value for use in building record and in printing.\n\t * Can't just have OFS point into the OFS_node since it's\n\t * already updated when we come into this routine, and we need\n\t * the old value to rebuild the record (see above).\n\t */\n\tOFS_node->var_value = force_string(OFS_node->var_value);\n\tnew_ofs_len = OFS_node->var_value->stlen;\n\n\tif (OFS == NULL)\n\t\temalloc(OFS, char *, new_ofs_len + 1, \"set_OFS\");\n\telse if (OFSlen < new_ofs_len)\n\t\terealloc(OFS, char *, new_ofs_len + 1, \"set_OFS\");\n\n\tmemcpy(OFS, OFS_node->var_value->stptr, OFS_node->var_value->stlen);\n\tOFSlen = new_ofs_len;\n\tOFS[OFSlen] = '\\0';\n}",
      "lines": 34,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "set_ORS": {
      "start_point": [
        832,
        0
      ],
      "end_point": [
        838,
        1
      ],
      "content": "void\nset_ORS()\n{\n\tORS_node->var_value = force_string(ORS_node->var_value);\n\tORS = ORS_node->var_value->stptr;\n\tORSlen = ORS_node->var_value->stlen;\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "fmt_ok": {
      "start_point": [
        846,
        0
      ],
      "end_point": [
        882,
        1
      ],
      "content": "static int\nfmt_ok(NODE *n)\n{\n\tNODE *tmp = force_string(n);\n\tconst char *p = tmp->stptr;\n\n#if ! defined(PRINTF_HAS_F_FORMAT) || PRINTF_HAS_F_FORMAT != 1\n\tstatic const char float_formats[] = \"efgEG\";\n#else\n\tstatic const char float_formats[] = \"efgEFG\";\n#endif\n#if defined(HAVE_LOCALE_H)\n\tstatic const char flags[] = \" +-#'\";\n#else\n\tstatic const char flags[] = \" +-#\";\n#endif\n\n\t// We rely on the caller to zero-terminate n->stptr.\n\n\tif (*p++ != '%')\n\t\treturn 0;\n\twhile (*p && strchr(flags, *p) != NULL)\t/* flags */\n\t\tp++;\n\twhile (*p && isdigit((unsigned char) *p))\t/* width - %*.*g is NOT allowed */\n\t\tp++;\n\tif (*p == '\\0' || (*p != '.' && ! isdigit((unsigned char) *p)))\n\t\treturn 0;\n\tif (*p == '.')\n\t\tp++;\n\twhile (*p && isdigit((unsigned char) *p))\t/* precision */\n\t\tp++;\n\tif (*p == '\\0' || strchr(float_formats, *p) == NULL)\n\t\treturn 0;\n\tif (*++p != '\\0')\n\t\treturn 0;\n\treturn 1;\n}",
      "lines": 37,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "fmt_index": {
      "start_point": [
        886,
        0
      ],
      "end_point": [
        922,
        1
      ],
      "content": "static int\nfmt_index(NODE *n)\n{\n\tint ix = 0;\n\tstatic int fmt_num = 4;\n\tstatic int fmt_hiwater = 0;\n\tchar save;\n\n\tif (fmt_list == NULL)\n\t\temalloc(fmt_list, NODE **, fmt_num*sizeof(*fmt_list), \"fmt_index\");\n\tn = force_string(n);\n\n\tsave = n->stptr[n->stlen];\n\tn->stptr[n->stlen] = '\\0';\n\n\twhile (ix < fmt_hiwater) {\n\t\tif (cmp_nodes(fmt_list[ix], n, true) == 0)\n\t\t\treturn ix;\n\t\tix++;\n\t}\n\n\t/* not found */\n\tif (do_lint && ! fmt_ok(n))\n\t\tlintwarn(_(\"bad `%sFMT' specification `%s'\"),\n\t\t\t    n == CONVFMT_node->var_value ? \"CONV\"\n\t\t\t  : n == OFMT_node->var_value ? \"O\"\n\t\t\t  : \"\", n->stptr);\n\n\tn->stptr[n->stlen] = save;\n\n\tif (fmt_hiwater >= fmt_num) {\n\t\tfmt_num *= 2;\n\t\terealloc(fmt_list, NODE **, fmt_num * sizeof(*fmt_list), \"fmt_index\");\n\t}\n\tfmt_list[fmt_hiwater] = dupnode(n);\n\treturn fmt_hiwater++;\n}",
      "lines": 37,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "set_OFMT": {
      "start_point": [
        926,
        0
      ],
      "end_point": [
        931,
        1
      ],
      "content": "void\nset_OFMT()\n{\n\tOFMTidx = fmt_index(OFMT_node->var_value);\n\tOFMT = fmt_list[OFMTidx]->stptr;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "set_CONVFMT": {
      "start_point": [
        935,
        0
      ],
      "end_point": [
        940,
        1
      ],
      "content": "void\nset_CONVFMT()\n{\n\tCONVFMTidx = fmt_index(CONVFMT_node->var_value);\n\tCONVFMT = fmt_list[CONVFMTidx]->stptr;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "set_LINT": {
      "start_point": [
        944,
        0
      ],
      "end_point": [
        982,
        1
      ],
      "content": "void\nset_LINT()\n{\n#ifndef NO_LINT\n\tint old_lint = do_lint;\n\tNODE *n = fixtype(LINT_node->var_value);\n\n\t/* start with clean defaults */\n\tlintfunc = r_warning;\n\tdo_flags &= ~(DO_LINT_ALL|DO_LINT_INVALID);\n\n\tif ((n->flags & STRING) != 0) {\n\t\tconst char *lintval;\n\t\tsize_t lintlen;\n\n\t\tlintval = n->stptr;\n\t\tlintlen = n->stlen;\n\t\tif (lintlen > 0) {\n\t\t\tif (lintlen == 7 && strncmp(lintval, \"invalid\", 7) == 0)\n\t\t\t\tdo_flags |= DO_LINT_INVALID;\n\t\t\telse {\n\t\t\t\tdo_flags |= DO_LINT_ALL;\n\t\t\t\tif (lintlen == 5 && strncmp(lintval, \"fatal\", 5) == 0)\n\t\t\t\t\tlintfunc = r_fatal;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (! iszero(n))\n\t\t\tdo_flags |= DO_LINT_ALL;\n\t}\n\n\t/* explicitly use warning() here, in case lintfunc == r_fatal */\n\tif (old_lint != do_lint && old_lint && ! do_lint)\n\t\twarning(_(\"turning off `--lint' due to assignment to `LINT'\"));\n\n\t/* inform plug-in api of change */\n\tupdate_ext_api();\n#endif /* ! NO_LINT */\n}",
      "lines": 39,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "set_TEXTDOMAIN": {
      "start_point": [
        986,
        0
      ],
      "end_point": [
        997,
        1
      ],
      "content": "void\nset_TEXTDOMAIN()\n{\n\tNODE *tmp;\n\n\ttmp = TEXTDOMAIN_node->var_value = force_string(TEXTDOMAIN_node->var_value);\n\tTEXTDOMAIN = tmp->stptr;\n\t/*\n\t * Note: don't call textdomain(); this value is for\n\t * the awk program, not for gawk itself.\n\t */\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "update_ERRNO_int": {
      "start_point": [
        1001,
        0
      ],
      "end_point": [
        1014,
        1
      ],
      "content": "void\nupdate_ERRNO_int(int errcode)\n{\n\tchar *cp;\n\n\tupdate_PROCINFO_num(\"errno\", errcode);\n\tif (errcode) {\n\t\tcp = strerror(errcode);\n\t\tcp = gettext(cp);\n\t} else\n\t\tcp = \"\";\n\tunref(ERRNO_node->var_value);\n\tERRNO_node->var_value = make_string(cp, strlen(cp));\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "update_ERRNO_string": {
      "start_point": [
        1018,
        0
      ],
      "end_point": [
        1024,
        1
      ],
      "content": "void\nupdate_ERRNO_string(const char *string)\n{\n\tupdate_PROCINFO_num(\"errno\", 0);\n\tunref(ERRNO_node->var_value);\n\tERRNO_node->var_value = make_string(string, strlen(string));\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "unset_ERRNO": {
      "start_point": [
        1028,
        0
      ],
      "end_point": [
        1034,
        1
      ],
      "content": "void\nunset_ERRNO(void)\n{\n\tupdate_PROCINFO_num(\"errno\", 0);\n\tunref(ERRNO_node->var_value);\n\tERRNO_node->var_value = dupnode(Nnull_string);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "update_NR": {
      "start_point": [
        1038,
        0
      ],
      "end_point": [
        1050,
        1
      ],
      "content": "void\nupdate_NR()\n{\n#ifdef HAVE_MPFR\n\tif (is_mpg_number(NR_node->var_value))\n\t\t(void) mpg_update_var(NR_node);\n\telse\n#endif\n\tif (NR_node->var_value->numbr != NR) {\n\t\tunref(NR_node->var_value);\n\t\tNR_node->var_value = make_number(NR);\n\t}\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "update_NF": {
      "start_point": [
        1054,
        0
      ],
      "end_point": [
        1066,
        1
      ],
      "content": "void\nupdate_NF()\n{\n\tlong l;\n\n\tl = get_number_si(NF_node->var_value);\n\tif (NF == -1 || l != NF) {\n\t\tif (NF == -1)\n\t\t\t(void) get_field(UNLIMITED - 1, NULL); /* parse record */\n\t\tunref(NF_node->var_value);\n\t\tNF_node->var_value = make_number(NF);\n\t}\n}",
      "lines": 13,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "update_FNR": {
      "start_point": [
        1070,
        0
      ],
      "end_point": [
        1082,
        1
      ],
      "content": "void\nupdate_FNR()\n{\n#ifdef HAVE_MPFR\n\tif (is_mpg_number(FNR_node->var_value))\n\t\t(void) mpg_update_var(FNR_node);\n\telse\n#endif\n\tif (FNR_node->var_value->numbr != FNR) {\n\t\tunref(FNR_node->var_value);\n\t\tFNR_node->var_value = make_number(FNR);\n\t}\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "grow_stack": {
      "start_point": [
        1102,
        0
      ],
      "end_point": [
        1110,
        1
      ],
      "content": "STACK_ITEM *\ngrow_stack()\n{\n\tSTACK_SIZE *= 2;\n\terealloc(stack_bottom, STACK_ITEM *, STACK_SIZE * sizeof(STACK_ITEM), \"grow_stack\");\n\tstack_top = stack_bottom + STACK_SIZE - 1;\n\tstack_ptr = stack_bottom + STACK_SIZE / 2;\n\treturn stack_ptr;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "STACK_ITEM",
        "*\ngrow_stack()",
        "*"
      ]
    },
    "r_get_lhs": {
      "start_point": [
        1118,
        0
      ],
      "end_point": [
        1159,
        1
      ],
      "content": "NODE **\nr_get_lhs(NODE *n, bool reference)\n{\n\tbool isparam = false;\n\n\tif (n->type == Node_param_list) {\n\t\tisparam = true;\n\t\tn = GET_PARAM(n->param_cnt);\n\t}\n\n\tswitch (n->type) {\n\tcase Node_var_array:\n\t\tfatal(_(\"attempt to use array `%s' in a scalar context\"),\n\t\t\t\tarray_vname(n));\n\tcase Node_array_ref:\n\t\tif (n->orig_array->type == Node_var_array)\n\t\t\tfatal(_(\"attempt to use array `%s' in a scalar context\"),\n\t\t\t\t\tarray_vname(n));\n\t\tif (n->orig_array->type != Node_var) {\n\t\t\tn->orig_array->type = Node_var;\n\t\t\tn->orig_array->var_value = dupnode(Nnull_string);\n\t\t}\n\t\t/* fall through */\n\tcase Node_var_new:\n\t\tn->type = Node_var;\n\t\tn->var_value = dupnode(Nnull_string);\n\t\tbreak;\n\n\tcase Node_var:\n\t\tbreak;\n\n\tdefault:\n\t\tcant_happen();\n\t}\n\n\tif (do_lint && reference && var_uninitialized(n))\n\t\tlintwarn((isparam ?\n\t\t\t_(\"reference to uninitialized argument `%s'\") :\n\t\t\t_(\"reference to uninitialized variable `%s'\")),\n\t\t\t\tn->vname);\n\treturn & n->var_value;\n}",
      "lines": 42,
      "depth": 13,
      "decorators": [
        "NODE",
        "**\nr_get_lhs(NODE *n, bool reference)",
        "*",
        "*\nr_get_lhs(NODE *n, bool reference)",
        "*"
      ]
    },
    "r_get_field": {
      "start_point": [
        1164,
        0
      ],
      "end_point": [
        1196,
        1
      ],
      "content": "NODE **\nr_get_field(NODE *n, Func_ptr *assign, bool reference)\n{\n\tlong field_num;\n\tNODE **lhs;\n\n\tif (assign)\n\t\t*assign = NULL;\n\tif (do_lint) {\n\t\tif ((fixtype(n)->flags & NUMBER) == 0) {\n\t\t\tlintwarn(_(\"attempt to field reference from non-numeric value\"));\n\t\t\tif (n->stlen == 0)\n\t\t\t\tlintwarn(_(\"attempt to field reference from null string\"));\n\t\t}\n\t}\n\n\t(void) force_number(n);\n\tfield_num = get_number_si(n);\n\n\tif (field_num < 0)\n\t\tfatal(_(\"attempt to access field %ld\"), field_num);\n\n\tif (field_num == 0 && field0_valid) {\t\t/* short circuit */\n\t\tlhs = &fields_arr[0];\n\t\tif (assign)\n\t\t\t*assign = reset_record;\n\t} else\n\t\tlhs = get_field(field_num, assign);\n\tif (do_lint && reference && ((*lhs)->flags & NULL_FIELD) != 0)\n\t\tlintwarn(_(\"reference to uninitialized field `$%ld'\"),\n\t\t\t      field_num);\n\treturn lhs;\n}",
      "lines": 33,
      "depth": 14,
      "decorators": [
        "NODE",
        "**\nr_get_field(NODE *n, Func_ptr *assign, bool reference)",
        "*",
        "*\nr_get_field(NODE *n, Func_ptr *assign, bool reference)",
        "*"
      ]
    },
    "calc_exp_posint": {
      "start_point": [
        1204,
        0
      ],
      "end_point": [
        1216,
        1
      ],
      "content": "static AWKNUM\ncalc_exp_posint(AWKNUM x, long n)\n{\n\tAWKNUM mult = 1;\n\n\twhile (n > 1) {\n\t\tif ((n % 2) == 1)\n\t\t\tmult *= x;\n\t\tx *= x;\n\t\tn /= 2;\n\t}\n\treturn mult * x;\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "AWKNUM"
      ]
    },
    "calc_exp": {
      "start_point": [
        1220,
        0
      ],
      "end_point": [
        1232,
        1
      ],
      "content": "AWKNUM\ncalc_exp(AWKNUM x1, AWKNUM x2)\n{\n\tlong lx;\n\n\tif ((lx = x2) == x2) {\t\t/* integer exponent */\n\t\tif (lx == 0)\n\t\t\treturn 1;\n\t\treturn (lx > 0) ? calc_exp_posint(x1, lx)\n\t\t\t\t: 1.0 / calc_exp_posint(x1, -lx);\n\t}\n\treturn (AWKNUM) pow((double) x1, (double) x2);\n}",
      "lines": 13,
      "depth": 11,
      "decorators": [
        "AWKNUM"
      ]
    },
    "setup_frame": {
      "start_point": [
        1237,
        0
      ],
      "end_point": [
        1379,
        1
      ],
      "content": "static INSTRUCTION *\nsetup_frame(INSTRUCTION *pc)\n{\n\tNODE *r = NULL;\n\tNODE *m, *f, *fp;\n\tNODE **sp = NULL;\n\tint pcount, arg_count, i, j;\n\tbool tail_optimize = false;\n\n\tf = pc->func_body;\n\tpcount = f->param_cnt;\n\tfp = f->fparms;\n\targ_count = (pc + 1)->expr_count;\n\n\t/* tail recursion optimization */\n\ttail_optimize =  ((pc + 1)->tail_call && do_optimize\n\t\t\t\t&& ! do_debug && ! do_profile);\n\n\tif (tail_optimize) {\n\t\t/* free local vars of calling frame */\n\n\t\tNODE *func;\n\t\tint n;\n\n\t\tfunc = frame_ptr->func_node;\n\t\tfor (n = func->param_cnt, sp = frame_ptr->stack; n > 0; n--) {\n\t\t\tr = *sp++;\n\t\t\tif (r->type == Node_var)     /* local variable */\n\t\t\t\tDEREF(r->var_value);\n\t\t\telse if (r->type == Node_var_array)     /* local array */\n\t\t\t\tassoc_clear(r);\n\t\t}\n\t\tsp = frame_ptr->stack;\n\n\t} else if (pcount > 0) {\n\t\tezalloc(sp, NODE **, pcount * sizeof(NODE *), \"setup_frame\");\n\t}\n\n\n\t/* check for extra args */\n\tif (arg_count > pcount) {\n\t\twarning(\n\t\t\t_(\"function `%s' called with more arguments than declared\"),\n       \t\t\tf->vname);\n\t\tdo {\n\t\t\tr = POP();\n\t\t\tif (r->type == Node_val)\n\t\t\t\tDEREF(r);\n\t\t} while (--arg_count > pcount);\n\t}\n\n\tfor (i = 0, j = arg_count - 1; i < pcount; i++, j--) {\n\t\tif (tail_optimize)\n\t\t\tr = sp[i];\n\t\telse {\n\t\t\tgetnode(r);\n\t\t\tmemset(r, 0, sizeof(NODE));\n\t\t\tsp[i] = r;\n\t\t}\n\n\t\tif (i >= arg_count) {\n\t\t\t/* local variable */\n\t\t\tr->type = Node_var_new;\n\t\t\tr->vname = fp[i].param;\n\t\t\tcontinue;\n\t\t}\n\n\t\tm = PEEK(j); /* arguments in reverse order on runtime stack */\n\n\t\tif (m->type == Node_param_list)\n\t\t\tm = GET_PARAM(m->param_cnt);\n\n\t\t/* $0 needs to be passed by value to a function */\n\t\tif (m == fields_arr[0]) {\n\t\t\tDEREF(m);\n\t\t\tm = dupnode(m);\n\t\t}\n\n\t\tswitch (m->type) {\n\t\tcase Node_var_new:\n\t\tcase Node_var_array:\n\t\t\tr->type = Node_array_ref;\n\t\t\tr->orig_array = r->prev_array = m;\n\t\t\tbreak;\n\n\t\tcase Node_array_ref:\n\t\t\tr->type = Node_array_ref;\n\t\t\tr->orig_array = m->orig_array;\n\t\t\tr->prev_array = m;\n\t\t\tbreak;\n\n\t\tcase Node_var:\n\t\t\t/* Untyped (Node_var_new) variable as param became a\n\t\t\t * scalar during evaluation of expression for a\n\t\t\t * subsequent param.\n\t\t\t */\n\t\t\tr->type = Node_var;\n\t\t\tr->var_value = dupnode(Nnull_string);\n\t\t\tbreak;\n\n\t\tcase Node_val:\n\t\t\tr->type = Node_var;\n\t\t\tr->var_value = m;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tcant_happen();\n\t\t}\n\t\tr->vname = fp[i].param;\n\t}\n\n\tstack_adj(-arg_count);\t/* adjust stack pointer */\n\n\tif (tail_optimize) {\n\t\tframe_ptr->num_tail_calls++;\n\t\treturn f->code_ptr;\n\t}\n\n\tif (pc->opcode == Op_indirect_func_call) {\n\t\tr = POP();\t/* indirect var */\n\t\tDEREF(r);\n\t}\n\n\tframe_ptr->vname = source;\t/* save current source */\n\n\tif (do_profile || do_debug)\n\t\tpush_frame(frame_ptr);\n\n\t/* save current frame in stack */\n\tPUSH(frame_ptr);\n\n\t/* setup new frame */\n\tgetnode(frame_ptr);\n\tframe_ptr->type = Node_frame;\n\tframe_ptr->stack = sp;\n\tframe_ptr->prev_frame_size = (stack_ptr - stack_bottom); /* size of the previous stack frame */\n\tframe_ptr->func_node = f;\n\tframe_ptr->num_tail_calls = 0;\n\tframe_ptr->vname = NULL;\n\tframe_ptr->reti = pc; /* on return execute pc->nexti */\n\n\treturn f->code_ptr;\n}",
      "lines": 143,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "INSTRUCTION",
        "*\nsetup_frame(INSTRUCTION *pc)",
        "*"
      ]
    },
    "restore_frame": {
      "start_point": [
        1384,
        0
      ],
      "end_point": [
        1422,
        1
      ],
      "content": "static INSTRUCTION *\nrestore_frame(NODE *fp)\n{\n\tNODE *r;\n\tNODE **sp;\n\tint n;\n\tNODE *func;\n\tINSTRUCTION *ri;\n\n\tfunc = frame_ptr->func_node;\n\tn = func->param_cnt;\n\tsp = frame_ptr->stack;\n\n\tfor (; n > 0; n--) {\n\t\tr = *sp++;\n\t\tif (r->type == Node_var)     /* local variable */\n\t\t\tDEREF(r->var_value);\n\t\telse if (r->type == Node_var_array)     /* local array */\n\t\t\tassoc_clear(r);\n\t\tfreenode(r);\n\t}\n\n\tif (frame_ptr->stack != NULL)\n\t\tefree(frame_ptr->stack);\n\tri = frame_ptr->reti;     /* execution in calling frame\n\t                           * resumes from ri->nexti.\n\t                           */\n\tfreenode(frame_ptr);\n\tif (do_profile || do_debug)\n\t\tpop_frame();\n\n\t/* restore frame */\n\tframe_ptr = fp;\n\t/* restore source */\n\tsource = fp->vname;\n\tfp->vname = NULL;\n\n\treturn ri->nexti;\n}",
      "lines": 39,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "INSTRUCTION",
        "*\nrestore_frame(NODE *fp)",
        "*"
      ]
    },
    "free_arrayfor": {
      "start_point": [
        1427,
        0
      ],
      "end_point": [
        1441,
        1
      ],
      "content": "static inline void\nfree_arrayfor(NODE *r)\n{\n\tif (r->for_list != NULL) {\n\t\tNODE *n;\n\t\tsize_t num_elems = r->for_list_size;\n\t\tNODE **list = r->for_list;\n\t\twhile (num_elems > 0) {\n\t\t\tn = list[--num_elems];\n\t\t\tunref(n);\n\t\t}\n\t\tefree(list);\n\t}\n\tfreenode(r);\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    },
    "unwind_stack": {
      "start_point": [
        1449,
        0
      ],
      "end_point": [
        1502,
        1
      ],
      "content": "INSTRUCTION *\nunwind_stack(long n)\n{\n\tNODE *r;\n\tINSTRUCTION *cp = NULL;\n\tSTACK_ITEM *sp;\n\n\tif (stack_empty())\n\t\treturn NULL;\n\n\tsp = stack_bottom + n;\n\n\tif (stack_ptr < sp)\n\t\treturn NULL;\n\n\twhile ((r = POP()) != NULL) {\n\t\tswitch (r->type) {\n\t\tcase Node_frame:\n\t\t\tcp = restore_frame(r);\n\t\t\tbreak;\n\t\tcase Node_arrayfor:\n\t\t\tfree_arrayfor(r);\n\t\t\tbreak;\n\t\tcase Node_val:\n\t\t\tDEREF(r);\n\t\t\tbreak;\n\t\tcase Node_instruction:\n\t\t\tfreenode(r);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/*\n\t\t\t * Check `exiting' and don't produce an error for\n\t\t\t * cases like:\n\t\t\t *\tfunc     _fn0() { exit }\n\t\t\t *\tBEGIN { ARRAY[_fn0()] }\n\t\t\t */\n\t\t\tif (in_main_context() && ! exiting)\n\t\t\t\tfatal(_(\"unwind_stack: unexpected type `%s'\"),\n\t\t\t\t\t\tnodetype2str(r->type));\n\t\t\t/* else\n\t\t\t\t* Node_var_array,\n\t\t\t\t* Node_param_list,\n\t\t\t\t* Node_var (e.g: trying to use scalar for array)\n\t\t\t\t* Node_regex/Node_dynregex\n\t\t\t\t* ?\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\n\t\tif (stack_ptr < sp)\n\t\t\tbreak;\n\t}\n\treturn cp;\n}",
      "lines": 54,
      "depth": 15,
      "decorators": [
        "INSTRUCTION",
        "*\nunwind_stack(long n)",
        "*"
      ]
    },
    "eval_condition": {
      "start_point": [
        1512,
        0
      ],
      "end_point": [
        1522,
        1
      ],
      "content": "static inline bool\neval_condition(NODE *t)\n{\n\tif (t == node_Boolean[false])\n\t\treturn false;\n\n\tif (t == node_Boolean[true])\n\t\treturn true;\n\n\treturn boolval(t);\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "bool"
      ]
    },
    "cmp_scalars": {
      "start_point": [
        1531,
        0
      ],
      "end_point": [
        1547,
        1
      ],
      "content": "static inline int\ncmp_scalars(scalar_cmp_t comparison_type)\n{\n\tNODE *t1, *t2;\n\tint di;\n\n\tt2 = POP_SCALAR();\n\tt1 = TOP();\n\tif (t1->type == Node_var_array) {\n\t\tDEREF(t2);\n\t\tfatal(_(\"attempt to use array `%s' in a scalar context\"), array_vname(t1));\n\t}\n\tdi = cmp_nodes(t1, t2, comparison_type == SCALAR_EQ_NEQ);\n\tDEREF(t1);\n\tDEREF(t2);\n\treturn di;\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "op_assign": {
      "start_point": [
        1551,
        0
      ],
      "end_point": [
        1612,
        1
      ],
      "content": "static void\nop_assign(OPCODE op)\n{\n\tNODE **lhs;\n\tNODE *t1, *t2;\n\tAWKNUM x = 0.0, x1, x2;\n\n\tlhs = POP_ADDRESS();\n\tt1 = *lhs;\n\tx1 = force_number(t1)->numbr;\n\n\tt2 = TOP_SCALAR();\n\tx2 = force_number(t2)->numbr;\n\tDEREF(t2);\n\n\tswitch (op) {\n\tcase Op_assign_plus:\n\t\tx = x1 + x2;\n\t\tbreak;\n\tcase Op_assign_minus:\n\t\tx = x1 - x2;\n\t\tbreak;\n\tcase Op_assign_times:\n\t\tx = x1 * x2;\n\t\tbreak;\n\tcase Op_assign_quotient:\n\t\tif (x2 == (AWKNUM) 0) {\n\t\t\tdecr_sp();\n\t\t\tfatal(_(\"division by zero attempted in `/='\"));\n\t\t}\n\t\tx = x1 / x2;\n\t\tbreak;\n\tcase Op_assign_mod:\n\t\tif (x2 == (AWKNUM) 0) {\n\t\t\tdecr_sp();\n\t\t\tfatal(_(\"division by zero attempted in `%%='\"));\n\t\t}\n#ifdef HAVE_FMOD\n\t\tx = fmod(x1, x2);\n#else   /* ! HAVE_FMOD */\n\t\t(void) modf(x1 / x2, &x);\n\t\tx = x1 - x2 * x;\n#endif  /* ! HAVE_FMOD */\n\t\tbreak;\n\tcase Op_assign_exp:\n\t\tx = calc_exp((double) x1, (double) x2);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (t1->valref == 1 && t1->flags == (MALLOC|NUMCUR|NUMBER)) {\n\t\t/* optimization */\n\t\tt1->numbr = x;\n\t} else {\n\t\tunref(t1);\n\t\tt1 = *lhs = make_number(x);\n\t}\n\n\tUPREF(t1);\n\tREPLACE(t1);\n}",
      "lines": 62,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "PUSH_CODE": {
      "start_point": [
        1616,
        0
      ],
      "end_point": [
        1624,
        1
      ],
      "content": "void\nPUSH_CODE(INSTRUCTION *cp)\n{\n\tNODE *r;\n\tgetnode(r);\n\tr->type = Node_instruction;\n\tr->code_ptr = cp;\n\tPUSH(r);\n}",
      "lines": 9,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "POP_CODE": {
      "start_point": [
        1628,
        0
      ],
      "end_point": [
        1637,
        1
      ],
      "content": "INSTRUCTION *\nPOP_CODE()\n{\n\tNODE *r;\n\tINSTRUCTION *cp;\n\tr = POP();\n\tcp = r->code_ptr;\n\tfreenode(r);\n\treturn cp;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "INSTRUCTION",
        "*\nPOP_CODE()",
        "*"
      ]
    },
    "push_exec_state": {
      "start_point": [
        1671,
        0
      ],
      "end_point": [
        1683,
        1
      ],
      "content": "static void\npush_exec_state(INSTRUCTION *cp, int rule, char *src, STACK_ITEM *sp)\n{\n\tEXEC_STATE *es;\n\n\temalloc(es, EXEC_STATE *, sizeof(EXEC_STATE), \"push_exec_state\");\n\tes->rule = rule;\n\tes->cptr = cp;\n\tes->stack_size = (sp - stack_bottom) + 1;\n\tes->source = src;\n\tes->next = exec_state_stack.next;\n\texec_state_stack.next = es;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "pop_exec_state": {
      "start_point": [
        1688,
        0
      ],
      "end_point": [
        1707,
        1
      ],
      "content": "static INSTRUCTION *\npop_exec_state(int *rule, char **src, long *sz)\n{\n\tINSTRUCTION *cp;\n\tEXEC_STATE *es;\n\n\tes = exec_state_stack.next;\n\tif (es == NULL)\n\t\treturn NULL;\n\tcp = es->cptr;\n\tif (rule != NULL)\n\t\t*rule = es->rule;\n\tif (src != NULL)\n\t\t*src = (char *) es->source;\n\tif (sz != NULL)\n\t\t*sz = es->stack_size;\n\texec_state_stack.next = es->next;\n\tefree(es);\n\treturn cp;\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "INSTRUCTION",
        "*\npop_exec_state(int *rule, char **src, long *sz)",
        "*"
      ]
    },
    "register_exec_hook": {
      "start_point": [
        1712,
        0
      ],
      "end_point": [
        1745,
        1
      ],
      "content": "int\nregister_exec_hook(Func_pre_exec preh, Func_post_exec posth)\n{\n\tint pos = 0;\n\n\t/*\n\t * multiple post-exec hooks aren't supported. post-exec hook is mainly\n\t * for use by the debugger.\n\t */\n\n\tif (! preh || (post_execute && posth))\n\t\treturn false;\n\n\tif (num_exec_hook == MAX_EXEC_HOOKS)\n\t\treturn false;\n\n\t/*\n\t * Add to the beginning of the array but do not displace the\n\t * debugger hook if it exists.\n\t */\n\tif (num_exec_hook > 0) {\n\t\tpos = !! do_debug;\n\t\tif (num_exec_hook > pos)\n\t\t\tmemmove(pre_execute + pos + 1, pre_execute + pos,\n\t\t\t\t\t(num_exec_hook - pos) * sizeof (preh));\n\t}\n\tpre_execute[pos] = preh;\n\tnum_exec_hook++;\n\n\tif (posth)\n\t\tpost_execute = posth;\n\n\treturn true;\n}",
      "lines": 34,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "init_interpret": {
      "start_point": [
        1759,
        0
      ],
      "end_point": [
        1797,
        1
      ],
      "content": "void\ninit_interpret()\n{\n\tlong newval;\n\n\tif ((newval = getenv_long(\"GAWK_STACKSIZE\")) > 0)\n\t\tSTACK_SIZE = newval;\n\n\temalloc(stack_bottom, STACK_ITEM *, STACK_SIZE * sizeof(STACK_ITEM), \"grow_stack\");\n\tstack_ptr = stack_bottom - 1;\n\tstack_top = stack_bottom + STACK_SIZE - 1;\n\n\t/* initialize frame pointer */\n\tgetnode(frame_ptr);\n\tframe_ptr->type = Node_frame;\n\tframe_ptr->stack = NULL;\n\tframe_ptr->func_node = NULL;\t/* in main */\n\tframe_ptr->num_tail_calls = 0;\n\tframe_ptr->vname = NULL;\n\n\t/* initialize true and false nodes */\n\tnode_Boolean[false] = make_number(0.0);\n\tnode_Boolean[true] = make_number(1.0);\n\tif (! is_mpg_number(node_Boolean[false])) {\n\t\tnode_Boolean[false]->flags |= NUMINT;\n\t\tnode_Boolean[true]->flags |= NUMINT;\n\t}\n\n\t/*\n\t * Select the interpreter routine. The version without\n\t * any exec hook support (r_interpret) is faster by about\n\t * 5%, or more depending on the opcodes.\n\t */\n\n\tif (num_exec_hook > 0)\n\t\tinterpret = h_interpret;\n\telse\n\t\tinterpret = r_interpret;\n}",
      "lines": 39,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "gawk/gawk-4.2.1/ext.c": {
    "load_ext": [
      {
        "start_point": [
          41,
          0
        ],
        "end_point": [
          77,
          1
        ],
        "content": "void\nload_ext(const char *lib_name)\n{\n\tint (*install_func)(const gawk_api_t *const, awk_ext_id_t);\n\tvoid *dl;\n\tint flags = RTLD_LAZY;\n\tint *gpl_compat;\n\n\tif (do_sandbox)\n\t\tfatal(_(\"extensions are not allowed in sandbox mode\"));\n\n\tif (do_traditional || do_posix)\n\t\tfatal(_(\"-l / @load are gawk extensions\"));\n\n\tif (lib_name == NULL)\n\t\tfatal(_(\"load_ext: received NULL lib_name\"));\n\n\tif ((dl = dlopen(lib_name, flags)) == NULL)\n\t\tfatal(_(\"load_ext: cannot open library `%s' (%s)\\n\"), lib_name,\n\t\t      dlerror());\n\n\t/* Per the GNU Coding standards */\n\tgpl_compat = (int *) dlsym(dl, \"plugin_is_GPL_compatible\");\n\tif (gpl_compat == NULL)\n\t\tfatal(_(\"load_ext: library `%s': does not define `plugin_is_GPL_compatible' (%s)\\n\"),\n\t\t\t\tlib_name, dlerror());\n\n\tinstall_func = (int (*)(const gawk_api_t *const, awk_ext_id_t))\n\t\t\t\tdlsym(dl, INIT_FUNC);\n\tif (install_func == NULL)\n\t\tfatal(_(\"load_ext: library `%s': cannot call function `%s' (%s)\\n\"),\n\t\t\t\tlib_name, INIT_FUNC, dlerror());\n\n\tif (install_func(& api_impl, NULL /* ext_id */) == 0)\n\t\twarning(_(\"load_ext: library `%s' initialization routine `%s' failed\\n\"),\n\t\t\t\tlib_name, INIT_FUNC);\n}",
        "lines": 37,
        "depth": 12,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          223,
          0
        ],
        "end_point": [
          227,
          1
        ],
        "content": "void\nload_ext(const char *lib_name)\n{\n\tfatal(_(\"dynamic loading of library not supported\"));\n}",
        "lines": 5,
        "depth": 9,
        "decorators": [
          "void"
        ]
      }
    ],
    "is_valid_identifier": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        96,
        1
      ],
      "content": "static bool\nis_valid_identifier(const char *name)\n{\n\tconst char *sp = name;\n\tint c;\n\n\tif (! is_letter(*sp))\n\t\treturn false;\n\n\tfor (sp++; (c = *sp++) != '\\0';) {\n\t\tif (! is_identchar(c))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "make_builtin": {
      "start_point": [
        100,
        0
      ],
      "end_point": [
        145,
        1
      ],
      "content": "awk_bool_t\nmake_builtin(const awk_ext_func_t *funcinfo)\n{\n\tNODE *symbol, *f;\n\tINSTRUCTION *b;\n\tconst char *name = funcinfo->name;\n\tint count = funcinfo->max_expected_args;\n\n\tif (name == NULL || *name == '\\0')\n\t\tfatal(_(\"make_builtin: missing function name\"));\n\n\tif (! is_valid_identifier(name))\n\t\treturn awk_false;\n\n\tf = lookup(name);\n\n\tif (f != NULL) {\n\t\tif (f->type == Node_func) {\n\t\t\t/* user-defined function */\n\t\t\tfatal(_(\"make_builtin: can't redefine function `%s'\"), name);\n\t\t} else if (f->type == Node_ext_func) {\n\t\t\t/* multiple extension() calls etc. */\n\t\t\tif (do_lint)\n\t\t\t\tlintwarn(_(\"make_builtin: function `%s' already defined\"), name);\n\t\t\treturn awk_false;\n\t\t} else\n\t\t\t/* variable name etc. */\n\t\t\tfatal(_(\"make_builtin: function name `%s' previously defined\"), name);\n\t} else if (check_special(name) >= 0)\n\t\tfatal(_(\"make_builtin: can't use gawk built-in `%s' as function name\"), name);\n\n\tif (count < 0)\n\t\tfatal(_(\"make_builtin: negative argument count for function `%s'\"),\n\t\t\t\tname);\n\n\tb = bcalloc(Op_symbol, 1, 0);\n\tb->extfunc = funcinfo->function;\n\tb->c_function = (awk_ext_func_t *) funcinfo;\n\n\t/* NB: extension sub must return something */\n\n       \tsymbol = install_symbol(estrdup(name, strlen(name)), Node_ext_func);\n\tsymbol->code_ptr = b;\n\ttrack_ext_func(name);\n\treturn awk_true;\n}",
      "lines": 46,
      "depth": 15,
      "decorators": [
        "awk_bool_t"
      ]
    },
    "get_argument": {
      "start_point": [
        149,
        0
      ],
      "end_point": [
        179,
        1
      ],
      "content": "NODE *\nget_argument(int i)\n{\n\tNODE *t;\n\tint arg_count;\n\tINSTRUCTION *pc;\n\n\tpc = TOP()->code_ptr;\t\t/* Op_ext_builtin instruction */\n\targ_count = pc->expr_count;\t/* # of arguments supplied */\n\n\tif (i < 0 || i >= arg_count)\n\t\treturn NULL;\n\n\tt = PEEK(arg_count - i);\n\tif (t->type == Node_param_list)\n\t\tt = GET_PARAM(t->param_cnt);\n\n\tif (t->type == Node_array_ref) {\n\t\tif (t->orig_array->type == Node_var) {\n\t\t\t/* already a scalar, can no longer use it as array */\n\t\t\tt->type = Node_var;\n\t\t\tt->var_value = Nnull_string;\n\t\t\treturn t;\n\t\t}\n\t\treturn t->orig_array; \t/* Node_var_new or Node_var_array */\n\t}\n\tif (t->type == Node_var)\t/* See Case Node_var in setup_frame(), eval.c */\n\t\treturn Nnull_string;\n\t/* Node_var_new, Node_var_array or Node_val */\n\treturn t;\n}",
      "lines": 31,
      "depth": 10,
      "decorators": [
        "NODE",
        "*\nget_argument(int i)",
        "*"
      ]
    },
    "get_actual_argument": {
      "start_point": [
        187,
        0
      ],
      "end_point": [
        217,
        1
      ],
      "content": "NODE *\nget_actual_argument(NODE *t, int i, bool want_array)\n{\n\tchar *fname;\n\tINSTRUCTION *pc;\n\n\tpc = TOP()->code_ptr;\t/* Op_ext_builtin instruction */\n\tfname = (pc + 1)->func_name;\n\n\tif (t->type == Node_var_new) {\n\t\tif (want_array)\n\t\t\treturn force_array(t, false);\n\t\telse {\n\t\t\tt->type = Node_var;\n\t\t\tt->var_value = dupnode(Nnull_string);\n\t\t\treturn t->var_value;\n\t\t}\n\t}\n\n\tif (want_array) {\n\t\tif (t->type != Node_var_array)\n\t\t\tfatal(_(\"function `%s': argument #%d: attempt to use scalar as an array\"),\n\t\t\t\tfname, i + 1);\n\t} else {\n\t\tif (t->type != Node_val)\n\t\t\tfatal(_(\"function `%s': argument #%d: attempt to use array as a scalar\"),\n\t\t\t\tfname, i + 1);\n\t}\n\tassert(t->type == Node_var_array || t->type == Node_val);\n\treturn t;\n}",
      "lines": 31,
      "depth": 12,
      "decorators": [
        "NODE",
        "*\nget_actual_argument(NODE *t, int i, bool want_array)",
        "*"
      ]
    },
    "close_extensions": {
      "start_point": [
        232,
        0
      ],
      "end_point": [
        243,
        1
      ],
      "content": "void\nclose_extensions()\n{\n\tSRCFILE *s;\n\n\tif (srcfiles == NULL)\n\t\treturn;\n\n\tfor (s = srcfiles->next; s != srcfiles; s = s->next)\n\t\tif (s->stype == SRC_EXTLIB && s->fini_func)\n               \t        (*s->fini_func)();\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "gawk/gawk-4.2.1/field.c": {
    "is_blank": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "static int\nis_blank(int c)\n{\n\treturn c == ' ' || c == '\\t';\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "init_fields": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        109,
        1
      ],
      "content": "void\ninit_fields()\n{\n\temalloc(fields_arr, NODE **, sizeof(NODE *), \"init_fields\");\n\n\tgetnode(fields_arr[0]);\n\t*fields_arr[0] = *Nnull_string;\n\tfields_arr[0]->flags |= NULL_FIELD;\n\n\tparse_extent = fields_arr[0]->stptr;\n\tsave_FS = dupnode(FS_node->var_value);\n\n\tgetnode(Null_field);\n\t*Null_field = *Nnull_string;\n\tNull_field->valref = 1;\n\tNull_field->flags = (STRCUR|STRING|NULL_FIELD); /* do not set MALLOC */\n\n\tfield0_valid = true;\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "grow_fields_arr": {
      "start_point": [
        113,
        0
      ],
      "end_point": [
        126,
        1
      ],
      "content": "static void\ngrow_fields_arr(long num)\n{\n\tint t;\n\tNODE *n;\n\n\terealloc(fields_arr, NODE **, (num + 1) * sizeof(NODE *), \"grow_fields_arr\");\n\tfor (t = nf_high_water + 1; t <= num; t++) {\n\t\tgetnode(n);\n\t\t*n = *Null_field;\n\t\tfields_arr[t] = n;\n\t}\n\tnf_high_water = num;\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "set_field": {
      "start_point": [
        131,
        0
      ],
      "end_point": [
        145,
        1
      ],
      "content": "static void\nset_field(long num,\n\tchar *str,\n\tlong len,\n\tNODE *dummy ATTRIBUTE_UNUSED)\t/* just to make interface same as set_element */\n{\n\tNODE *n;\n\n\tif (num > nf_high_water)\n\t\tgrow_fields_arr(num);\n\tn = fields_arr[num];\n\tn->stptr = str;\n\tn->stlen = len;\n\tn->flags = (STRCUR|STRING|USER_INPUT);\t/* do not set MALLOC */\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "rebuild_record": {
      "start_point": [
        150,
        0
      ],
      "end_point": [
        247,
        1
      ],
      "content": "void\nrebuild_record()\n{\n\t/*\n\t * use explicit unsigned longs for lengths, in case\n\t * a size_t isn't big enough.\n\t */\n\tunsigned long tlen;\n\tNODE *tmp;\n\tchar *ops;\n\tchar *cops;\n\tlong i;\n\n\tassert(NF != -1);\n\n\ttlen = 0;\n\tfor (i = NF; i > 0; i--) {\n\t\ttmp = fields_arr[i];\n\t\ttmp = force_string(tmp);\n\t\ttlen += tmp->stlen;\n\t}\n\ttlen += (NF - 1) * OFSlen;\n\tif ((long) tlen < 0)\n\t\ttlen = 0;\n\temalloc(ops, char *, tlen + 1, \"rebuild_record\");\n\tcops = ops;\n\tops[0] = '\\0';\n\tfor (i = 1;  i <= NF; i++) {\n\t\tfree_wstr(fields_arr[i]);\n\t\ttmp = fields_arr[i];\n\t\t/* copy field */\n\t\tif (tmp->stlen == 1)\n\t\t\t*cops++ = tmp->stptr[0];\n\t\telse if (tmp->stlen != 0) {\n\t\t\tmemcpy(cops, tmp->stptr, tmp->stlen);\n\t\t\tcops += tmp->stlen;\n\t\t}\n\t\t/* copy OFS */\n\t\tif (i != NF) {\n\t\t\tif (OFSlen == 1)\n\t\t\t\t*cops++ = *OFS;\n\t\t\telse if (OFSlen != 0) {\n\t\t\t\tmemcpy(cops, OFS, OFSlen);\n\t\t\t\tcops += OFSlen;\n\t\t\t}\n\t\t}\n\t}\n\ttmp = make_str_node(ops, tlen, ALREADY_MALLOCED);\n\n\t/*\n\t * Since we are about to unref fields_arr[0], we want to find\n\t * any fields that still point into it, and have them point\n\t * into the new field zero.  This has to be done intelligently,\n\t * so that unrefing a field doesn't try to unref into the old $0.\n\t */\n\tfor (cops = ops, i = 1; i <= NF; i++) {\n\t\tNODE *r = fields_arr[i];\n\t\t/*\n\t\t * There is no reason to copy malloc'ed fields to point into\n\t\t * the new $0 buffer, although that's how previous versions did\n\t\t * it. It seems faster to leave the malloc'ed fields in place.\n\t\t */\n\t\tif (r->stlen > 0 && (r->flags & MALLOC) == 0) {\n\t\t\tNODE *n;\n\t\t\tgetnode(n);\n\n\t\t\t*n = *r;\n\t\t\tif (r->valref > 1) {\n\t\t\t\t/*\n\t\t\t\t * This can and does happen.  It seems clear that\n\t\t\t\t * we can't leave r's stptr pointing into the\n\t\t\t\t * old $0 buffer that we are about to unref.\n\t\t\t\t */\n\t\t\t\temalloc(r->stptr, char *, r->stlen + 1, \"rebuild_record\");\n\t\t\t\tmemcpy(r->stptr, cops, r->stlen);\n\t\t\t\tr->stptr[r->stlen] = '\\0';\n\t\t\t\tr->flags |= MALLOC;\n\n\t\t\t\tn->valref = 1;\t// reset in the new field to start it off correctly!\n\t\t\t}\n\n\t\t\tn->stptr = cops;\n\t\t\tunref(r);\n\t\t\tfields_arr[i] = n;\n\t\t\tassert((n->flags & WSTRCUR) == 0);\n\t\t}\n\t\tcops += fields_arr[i]->stlen + OFSlen;\n\t}\n\n\tassert((fields_arr[0]->flags & MALLOC) == 0\n\t\t? fields_arr[0]->valref == 1\n\t\t: true);\n\n\tunref(fields_arr[0]);\n\n\tfields_arr[0] = tmp;\n\tfield0_valid = true;\n}",
      "lines": 98,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "set_record": {
      "start_point": [
        259,
        0
      ],
      "end_point": [
        331,
        1
      ],
      "content": "void\nset_record(const char *buf, int cnt, const awk_fieldwidth_info_t *fw)\n{\n\tNODE *n;\n\tstatic char *databuf;\n\tstatic unsigned long databuf_size;\n#define INITIAL_SIZE\t512\n#define MAX_SIZE\t((unsigned long) ~0)\t/* maximally portable ... */\n\n\tpurge_record();\n\n\t/* buffer management: */\n\tif (databuf_size == 0) {\t/* first time */\n\t\tezalloc(databuf, char *, INITIAL_SIZE, \"set_record\");\n\t\tdatabuf_size = INITIAL_SIZE;\n\t}\n\t/*\n\t * Make sure there's enough room. Since we sometimes need\n\t * to place a sentinel at the end, we make sure\n\t * databuf_size is > cnt after allocation.\n\t */\n\tif (cnt >= databuf_size) {\n\t\tdo {\n\t\t\tif (databuf_size > MAX_SIZE/2)\n\t\t\t\tfatal(_(\"input record too large\"));\n\t\t\tdatabuf_size *= 2;\n\t\t} while (cnt >= databuf_size);\n\t\terealloc(databuf, char *, databuf_size, \"set_record\");\n\t\tmemset(databuf, '\\0', databuf_size);\n\t}\n\t/* copy the data */\n\tmemcpy(databuf, buf, cnt);\n\n\t/*\n\t * Add terminating '\\0' so that C library routines\n\t * will know when to stop.\n\t */\n\tdatabuf[cnt] = '\\0';\n\n\t/* manage field 0: */\n\tassert((fields_arr[0]->flags & MALLOC) == 0\n\t\t? fields_arr[0]->valref == 1\n\t\t: true);\n\n\tunref(fields_arr[0]);\n\tgetnode(n);\n\tn->stptr = databuf;\n\tn->stlen = cnt;\n\tn->valref = 1;\n\tn->type = Node_val;\n\tn->stfmt = STFMT_UNUSED;\n#ifdef HAVE_MPFR\n\tn->strndmode = MPFR_round_mode;\n#endif\n\tn->flags = (STRING|STRCUR|USER_INPUT);\t/* do not set MALLOC */\n\tfields_arr[0] = n;\n\tif (fw != api_fw) {\n\t\tif ((api_fw = fw) != NULL) {\n\t\t\tif (! api_parser_override) {\n\t\t\t\tapi_parser_override = true;\n\t\t\t\tparse_field = fw_parse_field;\n\t\t\t\tupdate_PROCINFO_str(\"FS\", \"API\");\n\t\t\t}\n\t\t} else if (api_parser_override) {\n\t\t\tapi_parser_override = false;\n\t\t\tparse_field = normal_parse_field;\n\t\t\tupdate_PROCINFO_str(\"FS\", current_field_sep_str());\n\t\t}\n\t}\n\n#undef INITIAL_SIZE\n#undef MAX_SIZE\n}",
      "lines": 73,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "reset_record": {
      "start_point": [
        335,
        0
      ],
      "end_point": [
        340,
        1
      ],
      "content": "void\nreset_record()\n{\n\tfields_arr[0] = force_string(fields_arr[0]);\n\tpurge_record();\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "purge_record": {
      "start_point": [
        342,
        0
      ],
      "end_point": [
        376,
        1
      ],
      "content": "static void\npurge_record()\n{\n\tint i;\n\n\tNF = -1;\n\tfor (i = 1; i <= parse_high_water; i++) {\n\t\tNODE *n;\n\t\tNODE *r = fields_arr[i];\n\t\tif ((r->flags & MALLOC) == 0 && r->valref > 1) {\n\t\t\t/* This can and does happen. We must copy the string! */\n\t\t\tconst char *save = r->stptr;\n\t\t\temalloc(r->stptr, char *, r->stlen + 1, \"purge_record\");\n\t\t\tmemcpy(r->stptr, save, r->stlen);\n\t\t\tr->stptr[r->stlen] = '\\0';\n\t\t\tr->flags |= MALLOC;\n\t\t}\n\t\tunref(r);\n\t\tgetnode(n);\n\t\t*n = *Null_field;\n\t\tfields_arr[i] = n;\n\t}\n\n\tparse_high_water = 0;\n\t/*\n\t * $0 = $0 should resplit using the current value of FS.\n\t */\n\tif (resave_fs) {\n\t\tresave_fs = false;\n\t\tunref(save_FS);\n\t\tsave_FS = dupnode(FS_node->var_value);\n\t}\n\n\tfield0_valid = true;\n}",
      "lines": 35,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "set_NF": {
      "start_point": [
        380,
        0
      ],
      "end_point": [
        415,
        1
      ],
      "content": "void\nset_NF()\n{\n\tint i;\n\tlong nf;\n\tNODE *n;\n\n\tassert(NF != -1);\n\n\t(void) force_number(NF_node->var_value);\n\tnf = get_number_si(NF_node->var_value);\n\tif (nf < 0)\n\t\tfatal(_(\"NF set to negative value\"));\n\tNF = nf;\n\n\tif (NF > nf_high_water)\n\t\tgrow_fields_arr(NF);\n\tif (parse_high_water < NF) {\n\t\tfor (i = parse_high_water + 1; i >= 0 && i <= NF; i++) {\n\t\t\tunref(fields_arr[i]);\n\t\t\tgetnode(n);\n\t\t\t*n = *Null_field;\n\t\t\tfields_arr[i] = n;\n\t\t}\n\t\tparse_high_water = NF;\n\t} else if (parse_high_water > 0) {\n\t\tfor (i = NF + 1; i >= 0 && i <= parse_high_water; i++) {\n\t\t\tunref(fields_arr[i]);\n\t\t\tgetnode(n);\n\t\t\t*n = *Null_field;\n\t\t\tfields_arr[i] = n;\n\t\t}\n\t\tparse_high_water = NF;\n\t}\n\tfield0_valid = false;\n}",
      "lines": 36,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "re_parse_field": {
      "start_point": [
        424,
        0
      ],
      "end_point": [
        504,
        1
      ],
      "content": "static long\nre_parse_field(long up_to,\t/* parse only up to this field number */\n\tchar **buf,\t/* on input: string to parse; on output: point to start next */\n\tint len,\n\tNODE *fs ATTRIBUTE_UNUSED,\n\tRegexp *rp,\n\tSetfunc set,\t/* routine to set the value of the parsed field */\n\tNODE *n,\n\tNODE *sep_arr,  /* array of field separators (maybe NULL) */\n\tbool in_middle)\n{\n\tchar *scan = *buf;\n\tlong nf = parse_high_water;\n\tchar *field;\n\tchar *end = scan + len;\n\tint regex_flags = RE_NEED_START;\n\tchar *sep;\n\tsize_t mbclen = 0;\n\tmbstate_t mbs;\n\n\tmemset(&mbs, 0, sizeof(mbstate_t));\n\n\tif (in_middle)\n\t\tregex_flags |= RE_NO_BOL;\n\n\tif (up_to == UNLIMITED)\n\t\tnf = 0;\n\tif (len == 0)\n\t\treturn nf;\n\n\tif (RS_is_null && default_FS) {\n\t\tsep = scan;\n\t\twhile (scan < end && (*scan == ' ' || *scan == '\\t' || *scan == '\\n'))\n\t\t\tscan++;\n\t\tif (sep_arr != NULL && sep < scan)\n\t\t\tset_element(nf, sep, (long)(scan - sep), sep_arr);\n\t}\n\n\tif (rp == NULL) /* use FS */\n\t\trp = FS_regexp;\n\n\tfield = scan;\n\twhile (scan < end\n\t       && research(rp, scan, 0, (end - scan), regex_flags) != -1\n\t       && nf < up_to) {\n\t\tregex_flags |= RE_NO_BOL;\n\t\tif (REEND(rp, scan) == RESTART(rp, scan)) {   /* null match */\n\t\t\tif (gawk_mb_cur_max > 1)\t{\n\t\t\t\tmbclen = mbrlen(scan, end-scan, &mbs);\n\t\t\t\tif ((mbclen == 1) || (mbclen == (size_t) -1)\n\t\t\t\t\t|| (mbclen == (size_t) -2) || (mbclen == 0)) {\n\t\t\t\t\t/* We treat it as a singlebyte character.  */\n\t\t\t\t\tmbclen = 1;\n\t\t\t\t}\n\t\t\t\tscan += mbclen;\n\t\t\t} else\n\t\t\t\tscan++;\n\t\t\tif (scan == end) {\n\t\t\t\t(*set)(++nf, field, (long)(scan - field), n);\n\t\t\t\tup_to = nf;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\t(*set)(++nf, field,\n\t\t       (long)(scan + RESTART(rp, scan) - field), n);\n\t\tif (sep_arr != NULL)\n\t    \t\tset_element(nf, scan + RESTART(rp, scan),\n           \t\t\t(long) (REEND(rp, scan) - RESTART(rp, scan)), sep_arr);\n\t\tscan += REEND(rp, scan);\n\t\tfield = scan;\n\t\tif (scan == end)\t/* FS at end of record */\n\t\t\t(*set)(++nf, field, 0L, n);\n\t}\n\tif (nf != up_to && scan < end) {\n\t\t(*set)(++nf, scan, (long)(end - scan), n);\n\t\tscan = end;\n\t}\n\t*buf = scan;\n\treturn nf;\n}",
      "lines": 81,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "long",
        "long"
      ]
    },
    "def_parse_field": {
      "start_point": [
        514,
        0
      ],
      "end_point": [
        584,
        1
      ],
      "content": "static long\ndef_parse_field(long up_to,\t/* parse only up to this field number */\n\tchar **buf,\t/* on input: string to parse; on output: point to start next */\n\tint len,\n\tNODE *fs,\n\tRegexp *rp ATTRIBUTE_UNUSED,\n\tSetfunc set,\t/* routine to set the value of the parsed field */\n\tNODE *n,\n\tNODE *sep_arr,  /* array of field separators (maybe NULL) */\n\tbool in_middle ATTRIBUTE_UNUSED)\n{\n\tchar *scan = *buf;\n\tlong nf = parse_high_water;\n\tchar *field;\n\tchar *end = scan + len;\n\tchar sav;\n\tchar *sep;\n\n\tif (up_to == UNLIMITED)\n\t\tnf = 0;\n\tif (len == 0)\n\t\treturn nf;\n\n\t/*\n\t * Nasty special case. If FS set to \"\", return whole record\n\t * as first field. This is not worth a separate function.\n\t */\n\tif (fs->stlen == 0) {\n\t\t(*set)(++nf, *buf, len, n);\n\t\t*buf += len;\n\t\treturn nf;\n\t}\n\n\t/* before doing anything save the char at *end */\n\tsav = *end;\n\t/* because it will be destroyed now: */\n\n\t*end = ' ';\t/* sentinel character */\n\tsep = scan;\n\tfor (; nf < up_to; scan++) {\n\t\t/*\n\t\t * special case:  fs is single space, strip leading whitespace\n\t\t */\n\t\twhile (scan < end && (*scan == ' ' || *scan == '\\t' || *scan == '\\n'))\n\t\t\tscan++;\n\n\t\tif (sep_arr != NULL && scan > sep)\n\t\t\tset_element(nf, sep, (long) (scan - sep), sep_arr);\n\n\t\tif (scan >= end)\n\t\t\tbreak;\n\n\t\tfield = scan;\n\n\t\twhile (*scan != ' ' && *scan != '\\t' && *scan != '\\n')\n\t\t\tscan++;\n\n\t\t(*set)(++nf, field, (long)(scan - field), n);\n\n\t\tif (scan == end)\n\t\t\tbreak;\n\n\t\tsep = scan;\n\t}\n\n\t/* everything done, restore original char at *end */\n\t*end = sav;\n\n\t*buf = scan;\n\treturn nf;\n}",
      "lines": 71,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "long",
        "long"
      ]
    },
    "null_parse_field": {
      "start_point": [
        592,
        0
      ],
      "end_point": [
        637,
        1
      ],
      "content": "static long\nnull_parse_field(long up_to,\t/* parse only up to this field number */\n\tchar **buf,\t/* on input: string to parse; on output: point to start next */\n\tint len,\n\tNODE *fs ATTRIBUTE_UNUSED,\n\tRegexp *rp ATTRIBUTE_UNUSED,\n\tSetfunc set,\t/* routine to set the value of the parsed field */\n\tNODE *n,\n\tNODE *sep_arr,  /* array of field separators (maybe NULL) */\n\tbool in_middle ATTRIBUTE_UNUSED)\n{\n\tchar *scan = *buf;\n\tlong nf = parse_high_water;\n\tchar *end = scan + len;\n\n\tif (up_to == UNLIMITED)\n\t\tnf = 0;\n\tif (len == 0)\n\t\treturn nf;\n\n\tif (gawk_mb_cur_max > 1) {\n\t\tmbstate_t mbs;\n\t\tmemset(&mbs, 0, sizeof(mbstate_t));\n\t\tfor (; nf < up_to && scan < end;) {\n\t\t\tsize_t mbclen = mbrlen(scan, end-scan, &mbs);\n\t\t\tif ((mbclen == 1) || (mbclen == (size_t) -1)\n\t\t\t\t|| (mbclen == (size_t) -2) || (mbclen == 0)) {\n\t\t\t\t/* We treat it as a singlebyte character.  */\n\t\t\t\tmbclen = 1;\n\t\t\t}\n\t\t\tif (sep_arr != NULL && nf > 0)\n\t\t\t\tset_element(nf, scan, 0L, sep_arr);\n\t\t\t(*set)(++nf, scan, mbclen, n);\n\t\t\tscan += mbclen;\n\t\t}\n\t} else {\n\t\tfor (; nf < up_to && scan < end; scan++) {\n\t\t\tif (sep_arr != NULL && nf > 0)\n\t\t\t\tset_element(nf, scan, 0L, sep_arr);\n\t\t\t(*set)(++nf, scan, 1L, n);\n\t\t}\n\t}\n\n\t*buf = scan;\n\treturn nf;\n}",
      "lines": 46,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "long",
        "long"
      ]
    },
    "sc_parse_field": {
      "start_point": [
        646,
        0
      ],
      "end_point": [
        716,
        1
      ],
      "content": "static long\nsc_parse_field(long up_to,\t/* parse only up to this field number */\n\tchar **buf,\t/* on input: string to parse; on output: point to start next */\n\tint len,\n\tNODE *fs,\n\tRegexp *rp ATTRIBUTE_UNUSED,\n\tSetfunc set,\t/* routine to set the value of the parsed field */\n\tNODE *n,\n\tNODE *sep_arr,  /* array of field separators (maybe NULL) */\n\tbool in_middle ATTRIBUTE_UNUSED)\n{\n\tchar *scan = *buf;\n\tchar fschar;\n\tlong nf = parse_high_water;\n\tchar *field;\n\tchar *end = scan + len;\n\tchar sav;\n\tsize_t mbclen = 0;\n\tmbstate_t mbs;\n\n\tmemset(&mbs, 0, sizeof(mbstate_t));\n\n\tif (up_to == UNLIMITED)\n\t\tnf = 0;\n\tif (len == 0)\n\t\treturn nf;\n\n\tif (RS_is_null && fs->stlen == 0)\n\t\tfschar = '\\n';\n\telse\n\t\tfschar = fs->stptr[0];\n\n\t/* before doing anything save the char at *end */\n\tsav = *end;\n\t/* because it will be destroyed now: */\n\t*end = fschar;\t/* sentinel character */\n\n\tfor (; nf < up_to;) {\n\t\tfield = scan;\n\t\tif (gawk_mb_cur_max > 1) {\n\t\t\twhile (*scan != fschar) {\n\t\t\t\tmbclen = mbrlen(scan, end-scan, &mbs);\n\t\t\t\tif ((mbclen == 1) || (mbclen == (size_t) -1)\n\t\t\t\t\t|| (mbclen == (size_t) -2) || (mbclen == 0)) {\n\t\t\t\t\t/* We treat it as a singlebyte character.  */\n\t\t\t\t\tmbclen = 1;\n\t\t\t\t}\n\t\t\t\tscan += mbclen;\n\t\t\t}\n\t\t} else {\n\t\t\twhile (*scan != fschar)\n\t\t\t\tscan++;\n\t\t}\n\t\t(*set)(++nf, field, (long)(scan - field), n);\n\t\tif (scan == end)\n\t\t\tbreak;\n\t\tif (sep_arr != NULL)\n\t\t\tset_element(nf, scan, 1L, sep_arr);\n\t\tscan++;\n\t\tif (scan == end) {\t/* FS at end of record */\n\t\t\t(*set)(++nf, field, 0L, n);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* everything done, restore original char at *end */\n\t*end = sav;\n\n\t*buf = scan;\n\treturn nf;\n}",
      "lines": 71,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "long",
        "long"
      ]
    },
    "calc_mbslen": {
      "start_point": [
        723,
        0
      ],
      "end_point": [
        741,
        1
      ],
      "content": "static size_t\ncalc_mbslen(char *scan, char *end, size_t len, mbstate_t *mbs)\n{\n\n\tsize_t mbclen;\n\tchar *mbscan = scan;\n\n\twhile (len-- > 0 && mbscan < end) {\n\t\tmbclen = mbrlen(mbscan, end - mbscan, mbs);\n\t\tif (!(mbclen > 0 && mbclen <= (size_t)(end - mbscan)))\n\t\t\t/*\n\t\t\t * We treat it as a singlebyte character. This should\n\t\t\t * catch error codes 0, (size_t) -1, and (size_t) -2.\n\t\t\t */\n\t\t\tmbclen = 1;\n\t\tmbscan += mbclen;\n\t}\n\treturn mbscan - scan;\n}",
      "lines": 19,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "fw_parse_field": {
      "start_point": [
        749,
        0
      ],
      "end_point": [
        811,
        1
      ],
      "content": "static long\nfw_parse_field(long up_to,\t/* parse only up to this field number */\n\tchar **buf,\t/* on input: string to parse; on output: point to start next */\n\tint len,\n\tNODE *fs ATTRIBUTE_UNUSED,\n\tRegexp *rp ATTRIBUTE_UNUSED,\n\tSetfunc set,\t/* routine to set the value of the parsed field */\n\tNODE *n,\n\tNODE *dummy ATTRIBUTE_UNUSED, /* sep_arr not needed here: hence dummy */\n\tbool in_middle ATTRIBUTE_UNUSED)\n{\n\tchar *scan = *buf;\n\tlong nf = parse_high_water;\n\tchar *end = scan + len;\n\tconst awk_fieldwidth_info_t *fw;\n\tmbstate_t mbs;\n\tsize_t skiplen;\n\tsize_t flen;\n\n\tfw = (api_parser_override ? api_fw : FIELDWIDTHS);\n\n\tif (up_to == UNLIMITED)\n\t\tnf = 0;\n\tif (len == 0)\n\t\treturn nf;\n\tif (gawk_mb_cur_max > 1 && fw->use_chars) {\n\t\t/*\n\t\t * Reset the shift state. Arguably, the shift state should\n\t\t * be part of the file state and carried forward at all times,\n\t\t * but nobody has complained so far, so this may not matter\n\t\t * in practice.\n\t\t */\n\t\tmemset(&mbs, 0, sizeof(mbstate_t));\n\t\twhile (nf < up_to && scan < end) {\n\t\t\tif (nf >= fw->nf) {\n\t\t\t\t*buf = end;\n\t\t\t\treturn nf;\n\t\t\t}\n\t\t\tscan += calc_mbslen(scan, end, fw->fields[nf].skip, &mbs);\n\t\t\tflen = calc_mbslen(scan, end, fw->fields[nf].len, &mbs);\n\t\t\t(*set)(++nf, scan, (long) flen, n);\n\t\t\tscan += flen;\n\t\t}\n\t} else {\n\t\twhile (nf < up_to && scan < end) {\n\t\t\tif (nf >= fw->nf) {\n\t\t\t\t*buf = end;\n\t\t\t\treturn nf;\n\t\t\t}\n\t\t\tskiplen = fw->fields[nf].skip;\n\t\t\tif (skiplen > end - scan)\n\t\t\t\tskiplen = end - scan;\n\t\t\tscan += skiplen;\n\t\t\tflen = fw->fields[nf].len;\n\t\t\tif (flen > end - scan)\n\t\t\t\tflen = end - scan;\n\t\t\t(*set)(++nf, scan, (long) flen, n);\n\t\t\tscan += flen;\n\t\t}\n\t}\n\t*buf = scan;\n\treturn nf;\n}",
      "lines": 63,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "long",
        "long"
      ]
    },
    "invalidate_field0": {
      "start_point": [
        815,
        0
      ],
      "end_point": [
        819,
        1
      ],
      "content": "void\ninvalidate_field0()\n{\n\tfield0_valid = false;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "void"
      ]
    },
    "get_field": {
      "start_point": [
        825,
        0
      ],
      "end_point": [
        923,
        1
      ],
      "content": "NODE **\nget_field(long requested, Func_ptr *assign)\n{\n\tbool in_middle = false;\n\t/*\n\t * if requesting whole line but some other field has been altered,\n\t * then the whole line must be rebuilt\n\t */\n\tif (requested == 0) {\n\t\tif (! field0_valid) {\n\t\t\t/* first, parse remainder of input record */\n\t\t\tif (NF == -1) {\n\t\t\t\tNF = (*parse_field)(UNLIMITED - 1, &parse_extent,\n\t\t    \t\t\tfields_arr[0]->stlen -\n\t\t\t\t\t(parse_extent - fields_arr[0]->stptr),\n\t\t    \t\t\tsave_FS, FS_regexp, set_field,\n\t\t\t\t\t(NODE *) NULL,\n\t\t\t\t\t(NODE *) NULL,\n\t\t\t\t\tin_middle);\n\t\t\t\tparse_high_water = NF;\n\t\t\t}\n\t\t\trebuild_record();\n\t\t}\n\t\tif (assign != NULL)\n\t\t\t*assign = reset_record;\n\t\treturn &fields_arr[0];\n\t}\n\n\t/* assert(requested > 0); */\n\n#if 0\n\tif (assign != NULL)\n\t\tfield0_valid = false;\t\t/* $0 needs reconstruction */\n#else\n\t/*\n\t * Keep things uniform. Also, mere intention of assigning something\n\t * to $n should not make $0 invalid. Makes sense to invalidate $0\n\t * after the actual assignment is performed. Not a real issue in\n\t * the interpreter otherwise, but causes problem in the\n\t * debugger when watching or printing fields.\n\t */\n\n\tif (assign != NULL)\n\t\t*assign = invalidate_field0;\t/* $0 needs reconstruction */\n#endif\n\n\tif (requested <= parse_high_water)\t/* already parsed this field */\n\t\treturn &fields_arr[requested];\n\n\tif (NF == -1) {\t/* have not yet parsed to end of record */\n\t\t/*\n\t\t * parse up to requested fields, calling set_field() for each,\n\t\t * saving in parse_extent the point where the parse left off\n\t\t */\n\t\tif (parse_high_water == 0)\t/* starting at the beginning */\n\t\t\tparse_extent = fields_arr[0]->stptr;\n\t\telse\n\t\t\tin_middle = true;\n\t\tparse_high_water = (*parse_field)(requested, &parse_extent,\n\t\t     fields_arr[0]->stlen - (parse_extent - fields_arr[0]->stptr),\n\t\t     save_FS, NULL, set_field, (NODE *) NULL, (NODE *) NULL, in_middle);\n\n\t\t/*\n\t\t * if we reached the end of the record, set NF to the number of\n\t\t * fields so far.  Note that requested might actually refer to\n\t\t * a field that is beyond the end of the record, but we won't\n\t\t * set NF to that value at this point, since this is only a\n\t\t * reference to the field and NF only gets set if the field\n\t\t * is assigned to -- this case is handled below\n\t\t */\n\t\tif (parse_extent == fields_arr[0]->stptr + fields_arr[0]->stlen)\n\t\t\tNF = parse_high_water;\n\t\telse if (parse_field == fpat_parse_field) {\n\t\t\t/* FPAT parsing is weird, isolate the special cases */\n\t\t\tchar *rec_start = fields_arr[0]->stptr;\n\t\t\tchar *rec_end = fields_arr[0]->stptr + fields_arr[0]->stlen;\n\n\t\t\tif (    parse_extent > rec_end\n\t\t\t    || (parse_extent > rec_start && parse_extent < rec_end && requested == UNLIMITED-1))\n\t\t\t\tNF = parse_high_water;\n\t\t\telse if (parse_extent == rec_start) /* could be no match for FPAT */\n\t\t\t\tNF = 0;\n\t\t}\n\t\tif (requested == UNLIMITED - 1)\t/* UNLIMITED-1 means set NF */\n\t\t\trequested = parse_high_water;\n\t}\n\tif (parse_high_water < requested) { /* requested beyond end of record */\n\t\tif (assign != NULL) {\t/* expand record */\n\t\t\tif (requested > nf_high_water)\n\t\t\t\tgrow_fields_arr(requested);\n\n\t\t\tNF = requested;\n\t\t\tparse_high_water = requested;\n\t\t} else\n\t\t\treturn &Null_field;\n\t}\n\n\treturn &fields_arr[requested];\n}",
      "lines": 99,
      "depth": 18,
      "decorators": [
        "NODE",
        "**\nget_field(long requested, Func_ptr *assign)",
        "*",
        "*\nget_field(long requested, Func_ptr *assign)",
        "*"
      ]
    },
    "set_element": {
      "start_point": [
        927,
        0
      ],
      "end_point": [
        943,
        1
      ],
      "content": "static void\nset_element(long num, char *s, long len, NODE *n)\n{\n\tNODE *it;\n\tNODE **lhs;\n\tNODE *sub;\n\n\tit = make_string(s, len);\n\tit->flags |= USER_INPUT;\n\tsub = make_number((AWKNUM) (num));\n\tlhs = assoc_lookup(n, sub);\n\tunref(*lhs);\n\t*lhs = it;\n        if (n->astore != NULL)\n                (*n->astore)(n, sub);\n\tunref(sub);\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "do_split": {
      "start_point": [
        947,
        0
      ],
      "end_point": [
        1040,
        1
      ],
      "content": "NODE *\ndo_split(int nargs)\n{\n\tNODE *src, *arr, *sep, *fs, *tmp, *sep_arr = NULL;\n\tchar *s;\n\tlong (*parseit)(long, char **, int, NODE *,\n\t\t\t Regexp *, Setfunc, NODE *, NODE *, bool);\n\tRegexp *rp = NULL;\n\n\tif (nargs == 4) {\n\t\tstatic bool warned = false;\n\n\t\tif (do_traditional || do_posix) {\n\t\t\tfatal(_(\"split: fourth argument is a gawk extension\"));\n\t\t}\n\t\tsep_arr = POP_PARAM();\n\t\tif (sep_arr->type != Node_var_array)\n\t\t\tfatal(_(\"split: fourth argument is not an array\"));\n\t\tif ((do_lint || do_lint_old) && ! warned) {\n\t\t\twarned = true;\n\t\t\tlintwarn(_(\"split: fourth argument is a gawk extension\"));\n\t\t}\n\t}\n\n\tsep = POP();\n\tarr = POP_PARAM();\n\tif (arr->type != Node_var_array)\n\t\tfatal(_(\"split: second argument is not an array\"));\n\n\tif (sep_arr != NULL) {\n\t\tif (sep_arr == arr)\n\t\t\tfatal(_(\"split: cannot use the same array for second and fourth args\"));\n\n\t\t/* This checks need to be done before clearing any of the arrays */\n\t\tfor (tmp = sep_arr->parent_array; tmp != NULL; tmp = tmp->parent_array)\n\t\t\tif (tmp == arr)\n\t\t\t\tfatal(_(\"split: cannot use a subarray of second arg for fourth arg\"));\n\t\tfor (tmp = arr->parent_array; tmp != NULL; tmp = tmp->parent_array)\n\t\t\tif (tmp == sep_arr)\n\t\t\t\tfatal(_(\"split: cannot use a subarray of fourth arg for second arg\"));\n\t\tassoc_clear(sep_arr);\n\t}\n\tassoc_clear(arr);\n\n\tsrc = TOP_STRING();\n\tif (src->stlen == 0) {\n\t\t/*\n\t\t * Skip the work if first arg is the null string.\n\t\t */\n\t\ttmp = POP_SCALAR();\n\t\tDEREF(tmp);\n\t\treturn make_number((AWKNUM) 0);\n\t}\n\n\tif ((sep->flags & REGEX) != 0)\n\t\tsep = sep->typed_re;\n\n\tif (   (sep->re_flags & FS_DFLT) != 0\n\t    && current_field_sep() == Using_FS\n\t    && ! RS_is_null) {\n\t\tparseit = parse_field;\n\t\tfs = force_string(FS_node->var_value);\n\t\trp = FS_regexp;\n\t} else {\n\t\tfs = sep->re_exp;\n\n\t\tif (fs->stlen == 0) {\n\t\t\tstatic bool warned = false;\n\n\t\t\tparseit = null_parse_field;\n\n\t\t\tif (do_lint && ! warned) {\n\t\t\t\twarned = true;\n\t\t\t\tlintwarn(_(\"split: null string for third arg is a gawk extension\"));\n\t\t\t}\n\t\t} else if (fs->stlen == 1 && (sep->re_flags & CONSTANT) == 0) {\n\t\t\tif (fs->stptr[0] == ' ') {\n\t\t\t\tparseit = def_parse_field;\n\t\t\t} else\n\t\t\t\tparseit = sc_parse_field;\n\t\t} else {\n\t\t\tparseit = re_parse_field;\n\t\t\trp = re_update(sep);\n\t\t}\n\t}\n\n\ts = src->stptr;\n\ttmp = make_number((AWKNUM) (*parseit)(UNLIMITED, &s, (int) src->stlen,\n\t\t\t\t\t     fs, rp, set_element, arr, sep_arr, false));\n\n\tsrc = POP_SCALAR();\t/* really pop off stack */\n\tDEREF(src);\n\treturn tmp;\n}",
      "lines": 94,
      "depth": 15,
      "decorators": [
        "NODE",
        "*\ndo_split(int nargs)",
        "*"
      ]
    },
    "do_patsplit": {
      "start_point": [
        1047,
        0
      ],
      "end_point": [
        1104,
        1
      ],
      "content": "NODE *\ndo_patsplit(int nargs)\n{\n\tNODE *src, *arr, *sep, *fpat, *tmp, *sep_arr = NULL;\n\tchar *s;\n\tRegexp *rp = NULL;\n\n\tif (nargs == 4) {\n\t\tsep_arr = POP_PARAM();\n\t\tif (sep_arr->type != Node_var_array)\n\t\t\tfatal(_(\"patsplit: fourth argument is not an array\"));\n\t}\n\tsep = POP();\n\tarr = POP_PARAM();\n\tif (arr->type != Node_var_array)\n\t\tfatal(_(\"patsplit: second argument is not an array\"));\n\n\tsrc = TOP_STRING();\n\n\tif ((sep->flags & REGEX) != 0)\n\t\tsep = sep->typed_re;\n\n\tfpat = sep->re_exp;\n\tif (fpat->stlen == 0)\n\t\tfatal(_(\"patsplit: third argument must be non-null\"));\n\n\tif (sep_arr != NULL) {\n\t\tif (sep_arr == arr)\n\t\t\tfatal(_(\"patsplit: cannot use the same array for second and fourth args\"));\n\n\t\t/* These checks need to be done before clearing any of the arrays */\n\t\tfor (tmp = sep_arr->parent_array; tmp != NULL; tmp = tmp->parent_array)\n\t\t\tif (tmp == arr)\n\t\t\t\tfatal(_(\"patsplit: cannot use a subarray of second arg for fourth arg\"));\n\t\tfor (tmp = arr->parent_array; tmp != NULL; tmp = tmp->parent_array)\n\t\t\tif (tmp == sep_arr)\n\t\t\t\tfatal(_(\"patsplit: cannot use a subarray of fourth arg for second arg\"));\n\t\tassoc_clear(sep_arr);\n\t}\n\tassoc_clear(arr);\n\n\tif (src->stlen == 0) {\n\t\t/*\n\t\t * Skip the work if first arg is the null string.\n\t\t */\n\t\ttmp =  make_number((AWKNUM) 0);\n\t} else {\n\t\trp = re_update(sep);\n\t\ts = src->stptr;\n\t\ttmp = make_number((AWKNUM) fpat_parse_field(UNLIMITED, &s,\n\t\t\t\t(int) src->stlen, fpat, rp,\n\t\t\t\tset_element, arr, sep_arr, false));\n\t}\n\n\tsrc = POP_SCALAR();\t/* really pop off stack */\n\tDEREF(src);\n\treturn tmp;\n}",
      "lines": 58,
      "depth": 14,
      "decorators": [
        "NODE",
        "*\ndo_patsplit(int nargs)",
        "*"
      ]
    },
    "set_parser": {
      "start_point": [
        1108,
        0
      ],
      "end_point": [
        1116,
        1
      ],
      "content": "static void\nset_parser(parse_field_func_t func)\n{\n\tnormal_parse_field = func;\n\tif (! api_parser_override && parse_field != func) {\n\t\tparse_field = func;\n\t        update_PROCINFO_str(\"FS\", current_field_sep_str());\n\t}\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "set_FIELDWIDTHS": {
      "start_point": [
        1120,
        0
      ],
      "end_point": [
        1225,
        1
      ],
      "content": "void\nset_FIELDWIDTHS()\n{\n\tchar *scan;\n\tchar *end;\n\tint i;\n\tstatic int fw_alloc = 4;\n\tstatic bool warned = false;\n\tbool fatal_error = false;\n\tNODE *tmp;\n\n\tif (do_lint && ! warned) {\n\t\twarned = true;\n\t\tlintwarn(_(\"`FIELDWIDTHS' is a gawk extension\"));\n\t}\n\tif (do_traditional)\t/* quick and dirty, does the trick */\n\t\treturn;\n\n\t/*\n\t * If changing the way fields are split, obey least-surprise\n\t * semantics, and force $0 to be split totally.\n\t */\n\tif (fields_arr != NULL)\n\t\t(void) get_field(UNLIMITED - 1, 0);\n\n\tset_parser(fw_parse_field);\n\ttmp = force_string(FIELDWIDTHS_node->var_value);\n\tscan = tmp->stptr;\n\n\tif (FIELDWIDTHS == NULL) {\n\t\temalloc(FIELDWIDTHS, awk_fieldwidth_info_t *, awk_fieldwidth_info_size(fw_alloc), \"set_FIELDWIDTHS\");\n\t\tFIELDWIDTHS->use_chars = awk_true;\n\t}\n\tFIELDWIDTHS->nf = 0;\n\tfor (i = 0; ; i++) {\n\t\tunsigned long int tmp;\n\t\tif (i >= fw_alloc) {\n\t\t\tfw_alloc *= 2;\n\t\t\terealloc(FIELDWIDTHS, awk_fieldwidth_info_t *, awk_fieldwidth_info_size(fw_alloc), \"set_FIELDWIDTHS\");\n\t\t}\n\t\t/* Ensure that there is no leading `-' sign.  Otherwise,\n\t\t   strtoul would accept it and return a bogus result.  */\n\t\twhile (is_blank(*scan)) {\n\t\t\t++scan;\n\t\t}\n\t\tif (*scan == '-') {\n\t\t\tfatal_error = true;\n\t\t\tbreak;\n\t\t}\n\t\tif (*scan == '\\0')\n\t\t\tbreak;\n\n\t\t// Look for skip value. We allow N:M and N:*.\n\t\t/*\n\t\t * Detect an invalid base-10 integer, a valid value that\n\t\t * is followed by something other than a blank or '\\0',\n\t\t * or a value that is not in the range [1..UINT_MAX].\n\t\t */\n\t\terrno = 0;\n\t\ttmp = strtoul(scan, &end, 10);\n\t\tif (errno == 0 && *end == ':' && (0 < tmp && tmp <= UINT_MAX)) {\n\t\t\tFIELDWIDTHS->fields[i].skip = tmp;\n\t\t\tscan = end + 1;\n\t\t\tif (*scan == '-' || is_blank(*scan)) {\n\t\t\t\tfatal_error = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// try scanning for field width\n\t\t\ttmp = strtoul(scan, &end, 10);\n\t\t}\n\t\telse\n\t\t\tFIELDWIDTHS->fields[i].skip = 0;\n\n\t\tif (errno != 0\n\t\t    \t|| (*end != '\\0' && ! is_blank(*end))\n\t\t\t\t|| !(0 < tmp && tmp <= UINT_MAX)\n\t\t) {\n\t\t\tif (*scan == '*') {\n\t\t\t\tfor (scan++; is_blank(*scan); scan++)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (*scan != '\\0')\n\t\t\t\t\tfatal(_(\"`*' must be the last designator in FIELDWIDTHS\"));\n\n\t\t\t\tFIELDWIDTHS->fields[i].len = UINT_MAX;\n\t\t\t\tFIELDWIDTHS->nf = i+1;\n\t\t\t}\n\t\t\telse\n\t\t\t\tfatal_error = true;\n\t\t\tbreak;\n\t\t}\n\t\tFIELDWIDTHS->fields[i].len = tmp;\n\t\tFIELDWIDTHS->nf = i+1;\n\t\tscan = end;\n\t\t/* Skip past any trailing blanks.  */\n\t\twhile (is_blank(*scan)) {\n\t\t\t++scan;\n\t\t}\n\t\tif (*scan == '\\0')\n\t\t\tbreak;\n\t}\n\n\tif (fatal_error)\n\t\tfatal(_(\"invalid FIELDWIDTHS value, for field %d, near `%s'\"),\n\t\t\t      i + 1, scan);\n}",
      "lines": 106,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "set_FS": {
      "start_point": [
        1229,
        0
      ],
      "end_point": [
        1357,
        1
      ],
      "content": "void\nset_FS()\n{\n\tchar buf[10];\n\tNODE *fs;\n\tstatic NODE *save_fs = NULL;\n\tstatic NODE *save_rs = NULL;\n\tbool remake_re = true;\n\n\t/*\n\t * If changing the way fields are split, obey least-surprise\n\t * semantics, and force $0 to be split totally.\n\t */\n\tif (fields_arr != NULL)\n\t\t(void) get_field(UNLIMITED - 1, 0);\n\n\t/* It's possible that only IGNORECASE changed, or FS = FS */\n\t/*\n\t * This comparison can't use cmp_nodes(), which pays attention\n\t * to IGNORECASE, and that's not what we want.\n\t */\n\tif (save_fs\n\t\t&& FS_node->var_value->stlen == save_fs->stlen\n\t\t&& memcmp(FS_node->var_value->stptr, save_fs->stptr, save_fs->stlen) == 0\n\t\t&& save_rs\n\t\t&& RS_node->var_value->stlen == save_rs->stlen\n\t\t&& memcmp(RS_node->var_value->stptr, save_rs->stptr, save_rs->stlen) == 0) {\n\t\tif (FS_regexp != NULL)\n\t\t\tFS_regexp = (IGNORECASE ? FS_re_no_case : FS_re_yes_case);\n\n\t\t/* FS = FS */\n\t\tif (current_field_sep() == Using_FS) {\n\t\t\treturn;\n\t\t} else {\n\t\t\tremake_re = false;\n\t\t\tgoto choose_fs_function;\n\t\t}\n\t}\n\n\tunref(save_fs);\n\tsave_fs = dupnode(FS_node->var_value);\n\tunref(save_rs);\n\tsave_rs = dupnode(RS_node->var_value);\n\tresave_fs = true;\n\n\t/* If FS_re_no_case assignment is fatal (make_regexp in remake_re)\n\t * FS_regexp will be NULL with a non-null FS_re_yes_case.\n\t * refree() handles null argument; no need for `if (FS_regexp != NULL)' below.\n\t * Please do not remerge.\n\t */\n\trefree(FS_re_yes_case);\n\trefree(FS_re_no_case);\n\tFS_re_yes_case = FS_re_no_case = FS_regexp = NULL;\n\n\nchoose_fs_function:\n\tbuf[0] = '\\0';\n\tdefault_FS = false;\n\tfs = force_string(FS_node->var_value);\n\n\tif (! do_traditional && fs->stlen == 0) {\n\t\tstatic bool warned = false;\n\n\t\tset_parser(null_parse_field);\n\n\t\tif (do_lint && ! warned) {\n\t\t\twarned = true;\n\t\t\tlintwarn(_(\"null string for `FS' is a gawk extension\"));\n\t\t}\n\t} else if (fs->stlen > 1) {\n\t\tif (do_lint_old)\n\t\t\twarning(_(\"old awk does not support regexps as value of `FS'\"));\n\t\tset_parser(re_parse_field);\n\t} else if (RS_is_null) {\n\t\t/* we know that fs->stlen <= 1 */\n\t\tset_parser(sc_parse_field);\n\t\tif (fs->stlen == 1) {\n\t\t\tif (fs->stptr[0] == ' ') {\n\t\t\t\tdefault_FS = true;\n\t\t\t\tstrcpy(buf, \"[ \\t\\n]+\");\n\t\t\t} else if (fs->stptr[0] == '\\\\') {\n\t\t\t\t/* yet another special case */\n\t\t\t\tstrcpy(buf, \"[\\\\\\\\\\n]\");\n\t\t\t} else if (fs->stptr[0] == '\\0') {\n\t\t\t\t/* and yet another special case */\n\t\t\t\tstrcpy(buf, \"[\\\\000\\n]\");\n\t\t\t} else if (fs->stptr[0] != '\\n') {\n\t\t\t\tsprintf(buf, \"[%c\\n]\", fs->stptr[0]);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tset_parser(def_parse_field);\n\n\t\tif (fs->stlen == 1) {\n\t\t\tif (fs->stptr[0] == ' ')\n\t\t\t\tdefault_FS = true;\n\t\t\telse if (fs->stptr[0] == '\\\\')\n\t\t\t\t/* same special case */\n\t\t\t\tstrcpy(buf, \"[\\\\\\\\]\");\n\t\t\telse\n\t\t\t\tset_parser(sc_parse_field);\n\t\t}\n\t}\n\tif (remake_re) {\n\t\trefree(FS_re_yes_case);\n\t\trefree(FS_re_no_case);\n\t\tFS_re_yes_case = FS_re_no_case = FS_regexp = NULL;\n\n\t\tif (buf[0] != '\\0') {\n\t\t\tFS_re_yes_case = make_regexp(buf, strlen(buf), false, true, true);\n\t\t\tFS_re_no_case = make_regexp(buf, strlen(buf), true, true, true);\n\t\t\tFS_regexp = (IGNORECASE ? FS_re_no_case : FS_re_yes_case);\n\t\t\tset_parser(re_parse_field);\n\t\t} else if (parse_field == re_parse_field) {\n\t\t\tFS_re_yes_case = make_regexp(fs->stptr, fs->stlen, false, true, true);\n\t\t\tFS_re_no_case = make_regexp(fs->stptr, fs->stlen, true, true, true);\n\t\t\tFS_regexp = (IGNORECASE ? FS_re_no_case : FS_re_yes_case);\n\t\t} else\n\t\t\tFS_re_yes_case = FS_re_no_case = FS_regexp = NULL;\n\t}\n\n\t/*\n\t * For FS = \"c\", we don't use IGNORECASE. But we must use\n\t * re_parse_field to get the character and the newline as\n\t * field separators.\n\t */\n\tif (fs->stlen == 1 && parse_field == re_parse_field)\n\t\tFS_regexp = FS_re_yes_case;\n}",
      "lines": 129,
      "depth": 19,
      "decorators": [
        "void"
      ]
    },
    "current_field_sep": {
      "start_point": [
        1361,
        0
      ],
      "end_point": [
        1372,
        1
      ],
      "content": "field_sep_type\ncurrent_field_sep()\n{\n\tif (api_parser_override)\n\t\treturn Using_API;\n\telse if (parse_field == fw_parse_field)\n\t\treturn Using_FIELDWIDTHS;\n\telse if (parse_field == fpat_parse_field)\n\t\treturn Using_FPAT;\n\telse\n\t\treturn Using_FS;\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "field_sep_type"
      ]
    },
    "current_field_sep_str": {
      "start_point": [
        1376,
        0
      ],
      "end_point": [
        1387,
        1
      ],
      "content": "const char *\ncurrent_field_sep_str()\n{\n\tif (api_parser_override)\n\t\treturn \"API\";\n\telse if (parse_field == fw_parse_field)\n\t\treturn \"FIELDWIDTHS\";\n\telse if (parse_field == fpat_parse_field)\n\t\treturn \"FPAT\";\n\telse\n\t\treturn \"FS\";\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "const",
        "const",
        "char",
        "*\ncurrent_field_sep_str()",
        "*"
      ]
    },
    "update_PROCINFO_str": {
      "start_point": [
        1391,
        0
      ],
      "end_point": [
        1404,
        1
      ],
      "content": "void\nupdate_PROCINFO_str(const char *subscript, const char *str)\n{\n\tNODE **aptr;\n\tNODE *tmp;\n\n\tif (PROCINFO_node == NULL)\n\t\treturn;\n\ttmp = make_string(subscript, strlen(subscript));\n\taptr = assoc_lookup(PROCINFO_node, tmp);\n\tunref(tmp);\n\tunref(*aptr);\n\t*aptr = make_string(str, strlen(str));\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "update_PROCINFO_num": {
      "start_point": [
        1408,
        0
      ],
      "end_point": [
        1421,
        1
      ],
      "content": "void\nupdate_PROCINFO_num(const char *subscript, AWKNUM val)\n{\n\tNODE **aptr;\n\tNODE *tmp;\n\n\tif (PROCINFO_node == NULL)\n\t\treturn;\n\ttmp = make_string(subscript, strlen(subscript));\n\taptr = assoc_lookup(PROCINFO_node, tmp);\n\tunref(tmp);\n\tunref(*aptr);\n\t*aptr = make_number(val);\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "set_FPAT": {
      "start_point": [
        1425,
        0
      ],
      "end_point": [
        1486,
        1
      ],
      "content": "void\nset_FPAT()\n{\n\tstatic bool warned = false;\n\tstatic NODE *save_fpat = NULL;\n\tbool remake_re = true;\n\tNODE *fpat;\n\n\tif (do_lint && ! warned) {\n\t\twarned = true;\n\t\tlintwarn(_(\"`FPAT' is a gawk extension\"));\n\t}\n\tif (do_traditional)\t/* quick and dirty, does the trick */\n\t\treturn;\n\n\t/*\n\t * If changing the way fields are split, obey least-suprise\n\t * semantics, and force $0 to be split totally.\n\t */\n\tif (fields_arr != NULL)\n\t\t(void) get_field(UNLIMITED - 1, 0);\n\n\t/* It's possible that only IGNORECASE changed, or FPAT = FPAT */\n\t/*\n\t * This comparison can't use cmp_nodes(), which pays attention\n\t * to IGNORECASE, and that's not what we want.\n\t */\n\tif (save_fpat\n\t\t&& FPAT_node->var_value->stlen == save_fpat->stlen\n\t\t&& memcmp(FPAT_node->var_value->stptr, save_fpat->stptr, save_fpat->stlen) == 0) {\n\t\tif (FPAT_regexp != NULL)\n\t\t\tFPAT_regexp = (IGNORECASE ? FPAT_re_no_case : FPAT_re_yes_case);\n\n\t\t/* FPAT = FPAT */\n\t\tif (current_field_sep() == Using_FPAT) {\n\t\t\treturn;\n\t\t} else {\n\t\t\tremake_re = false;\n\t\t\tgoto set_fpat_function;\n\t\t}\n\t}\n\n\tunref(save_fpat);\n\tsave_fpat = dupnode(FPAT_node->var_value);\n\trefree(FPAT_re_yes_case);\n\trefree(FPAT_re_no_case);\n\tFPAT_re_yes_case = FPAT_re_no_case = FPAT_regexp = NULL;\n\nset_fpat_function:\n\tfpat = force_string(FPAT_node->var_value);\n\tset_parser(fpat_parse_field);\n\n\tif (remake_re) {\n\t\trefree(FPAT_re_yes_case);\n\t\trefree(FPAT_re_no_case);\n\t\tFPAT_re_yes_case = FPAT_re_no_case = FPAT_regexp = NULL;\n\n\t\tFPAT_re_yes_case = make_regexp(fpat->stptr, fpat->stlen, false, true, true);\n\t\tFPAT_re_no_case = make_regexp(fpat->stptr, fpat->stlen, true, true, true);\n\t\tFPAT_regexp = (IGNORECASE ? FPAT_re_no_case : FPAT_re_yes_case);\n\t}\n}",
      "lines": 62,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "incr_scan": {
      "start_point": [
        1497,
        0
      ],
      "end_point": [
        1514,
        1
      ],
      "content": "static void\nincr_scan(char **scanp, size_t len, mbstate_t *mbs)\n{\n\tsize_t mbclen = 0;\n\n\tif (gawk_mb_cur_max > 1) {\n\t\tmbclen = mbrlen(*scanp, len, mbs);\n\t\tif (   (mbclen == 1)\n\t\t    || (mbclen == (size_t) -1)\n\t\t    || (mbclen == (size_t) -2)\n\t\t    || (mbclen == 0)) {\n\t\t\t/* We treat it as a singlebyte character.  */\n\t\t\tmbclen = 1;\n\t\t}\n\t\t*scanp += mbclen;\n\t} else\n\t\t(*scanp)++;\n}",
      "lines": 18,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "fpat_parse_field": {
      "start_point": [
        1584,
        0
      ],
      "end_point": [
        1666,
        1
      ],
      "content": "static long\nfpat_parse_field(long up_to,\t/* parse only up to this field number */\n\tchar **buf,\t/* on input: string to parse; on output: point to start next */\n\tint len,\n\tNODE *fs ATTRIBUTE_UNUSED,\n\tRegexp *rp,\n\tSetfunc set,\t/* routine to set the value of the parsed field */\n\tNODE *n,\n\tNODE *sep_arr,  /* array of field separators (may be NULL) */\n\tbool in_middle)\n{\n\tchar *scan = *buf;\n\tlong nf = parse_high_water;\n\tchar *start;\n\tchar *end = scan + len;\n\tint regex_flags = RE_NEED_START;\n\tmbstate_t mbs;\n\tchar* field_start;\n\tbool field_found = false;\n\n\tmemset(&mbs, 0, sizeof(mbstate_t));\n\n\tif (up_to == UNLIMITED)\n\t\tnf = 0;\n\n\tif (len == 0)\n\t\treturn nf;\n\n\tif (rp == NULL) /* use FPAT */\n\t\trp = FPAT_regexp;\n\n\twhile (scan < end && nf < up_to) {  /* still something to parse */\n\n\t\t/* first attempt to match the next field */\n\t\tstart = scan;\n\t\tfield_found = research(rp, scan, 0, (end - scan), regex_flags) != -1;\n\n\t\t/* check for an invalid null field and retry one character away */ \n\t\tif (nf > 0 && field_found && REEND(rp, scan) == 0) { /* invalid null field */\n\t\t\tincrement_scan(& scan, end - scan);\n\t\t\tfield_found = research(rp, scan, 0, (end - scan), regex_flags) != -1;\n\t\t}\n\n\t\t/* store the (sep[n-1],field[n]) pair */\n\t\tif (field_found) {\n\t\t\tfield_start = scan + RESTART(rp, scan);\n\t\t\tif (sep_arr != NULL) { /* store the separator */\n\t\t\t\tif (field_start == start) /* match at front */\n\t\t\t\t\tset_element(nf, start, 0L, sep_arr);\n\t\t\t\telse\n\t\t\t\t\tset_element(nf,\n\t\t\t\t\t\tstart,\n\t\t\t\t\t\t(long) (field_start - start),\n\t\t\t\t\t\tsep_arr);\n\t\t\t}\n\t\t\t/* field is text that matched */\n\t\t\t(*set)(++nf,\n\t\t\t\tfield_start,\n\t\t\t\t(long)(REEND(rp, scan) - RESTART(rp, scan)),\n\t\t\t\tn);\n\t\t\tscan += REEND(rp, scan);\n\n\t\t} else {\n\t\t\t/*\n\t\t\t * No match, store the final extra separator after\n\t\t\t * the last field.\n\t\t\t */\n\t\t\tif (sep_arr != NULL)\n\t\t\t\tset_element(nf, start, (long) (end - start), sep_arr);\n\t\t\tscan = end;\n\t\t}\n\t}\n\n\t/*\n\t * If the last field extends up to the end of the record, generate\n\t * a null trailing separator\n\t */\n\tif (sep_arr != NULL && scan == end && field_found) \n\t\tset_element(nf, scan, 0L, sep_arr);\n\n\t*buf = scan;\n\treturn nf;\n}",
      "lines": 83,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "long",
        "long"
      ]
    }
  },
  "gawk/gawk-4.2.1/floatcomp.c": {
    "count_trailing_zeros": {
      "start_point": [
        75,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "static int\ncount_trailing_zeros(uintmax_t n)\n{\n#if 3 < (__GNUC__ + (4 <= __GNUC_MINOR__)) && UINTMAX_MAX <= ULLONG_MAX\n\treturn __builtin_ctzll(n);\n#else\n\tint i = 0;\n\tfor (; (n & 3) == 0; n >>= 2)\n\t\ti += 2;\n\treturn i + (1 & ~n);\n#endif\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "adjust_uint": {
      "start_point": [
        90,
        0
      ],
      "end_point": [
        112,
        1
      ],
      "content": "uintmax_t\nadjust_uint(uintmax_t n)\n{\n\t/*\n\t * If uintmax_t is so wide that AWKNUM cannot represent all its\n\t * values, strip leading nonzero bits of integers that are so large\n\t * that they cannot be represented exactly as AWKNUMs, so that their\n\t * low order bits are represented exactly, without rounding errors.\n\t * This is more desirable in practice, since it means the user sees\n\t * integers that are the same width as the AWKNUM fractions.\n\t */\n\tint wordbits = CHAR_BIT * sizeof n;\n\tif (AWKNUM_FRACTION_BITS < wordbits) {\n\t\tuintmax_t one = 1;\n\t\tuintmax_t sentinel = one << (wordbits - AWKNUM_FRACTION_BITS);\n\t\tint shift = count_trailing_zeros(n | sentinel);\n\t\tuintmax_t mask = (one << AWKNUM_FRACTION_BITS) - 1;\n\n\t\tn &= mask << shift;\n\t}\n\n\treturn n;\n}",
      "lines": 23,
      "depth": 10,
      "decorators": [
        "uintmax_t"
      ]
    }
  },
  "gawk/gawk-4.2.1/floatmagic.h": {
    "isnan_f": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        37,
        61
      ],
      "content": "static inline int isnan_f  (float       x) { return x != x; }",
      "lines": 1,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "isnan_d": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        38,
        61
      ],
      "content": "static inline int isnan_d  (double      x) { return x != x; }",
      "lines": 1,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "isnan_ld": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        39,
        61
      ],
      "content": "static inline int isnan_ld (long double x) { return x != x; }",
      "lines": 1,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "isinf_f": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        49,
        68
      ],
      "content": "static inline int isinf_f  (float       x) { return isnan (x - x); }",
      "lines": 1,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "isinf_d": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        50,
        68
      ],
      "content": "static inline int isinf_d  (double      x) { return isnan (x - x); }",
      "lines": 1,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "isinf_ld": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        51,
        68
      ],
      "content": "static inline int isinf_ld (long double x) { return isnan (x - x); }",
      "lines": 1,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    }
  },
  "gawk/gawk-4.2.1/gawkapi.c": {
    "api_get_argument": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        114,
        1
      ],
      "content": "static awk_bool_t\napi_get_argument(awk_ext_id_t id, size_t count,\n\t\t\tawk_valtype_t wanted, awk_value_t *result)\n{\n#ifdef DYNAMIC\n\tNODE *arg;\n\n\tif (result == NULL)\n\t\treturn awk_false;\n\n\t(void) id;\n\n\t/* set up default result */\n\tmemset(result, 0, sizeof(*result));\n\tresult->val_type = AWK_UNDEFINED;\n\n\t/*\n\t * Song and dance here.  get_array_argument() and get_scalar_argument()\n\t * will force a change in type of a parameter that is Node_var_new.\n\t *\n\t * Start by looking at the unadulterated argument as it was passed.\n\t */\n\targ = get_argument(count);\n\tif (arg == NULL)\n\t\treturn awk_false;\n\n\t/* if type is undefined */\n\tif (arg->type == Node_var_new) {\n\t\tif (wanted == AWK_UNDEFINED)\n\t\t\treturn true;\n\t\telse if (wanted == AWK_ARRAY) {\n\t\t\tgoto array;\n\t\t} else {\n\t\t\tgoto scalar;\n\t\t}\n\t}\n\n\t/* at this point, we have real type */\n\tif (arg->type == Node_var_array || arg->type == Node_array_ref) {\n\t\tif (wanted != AWK_ARRAY && wanted != AWK_UNDEFINED)\n\t\t\treturn false;\n\t\tgoto array;\n\t} else\n\t\tgoto scalar;\n\narray:\n\t/* get the array here */\n\targ = get_array_argument(arg, count);\n\tif (arg == NULL)\n\t\treturn awk_false;\n\n\treturn node_to_awk_value(arg, result, wanted);\n\nscalar:\n\t/* at this point we have a real type that is not an array */\n\targ = get_scalar_argument(arg, count);\n\tif (arg == NULL)\n\t\treturn awk_false;\n\n\treturn node_to_awk_value(arg, result, wanted);\n#else\n\treturn awk_false;\n#endif\n}",
      "lines": 64,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "awk_bool_t"
      ]
    },
    "api_set_argument": {
      "start_point": [
        118,
        0
      ],
      "end_point": [
        148,
        1
      ],
      "content": "static awk_bool_t\napi_set_argument(awk_ext_id_t id,\n\t\tsize_t count,\n\t\tawk_array_t new_array)\n{\n#ifdef DYNAMIC\n\tNODE *arg;\n\tNODE *array = (NODE *) new_array;\n\n\t(void) id;\n\n\tif (array == NULL || array->type != Node_var_array)\n\t\treturn awk_false;\n\n\tif (   (arg = get_argument(count)) == NULL\n\t    || arg->type != Node_var_new)\n\t\treturn awk_false;\n\n\targ = get_array_argument(arg, count);\n\tif (arg == NULL)\n\t\treturn awk_false;\n\n\tarray->vname = arg->vname;\n\t*arg = *array;\n\tfreenode(array);\n\n\treturn awk_true;\n#else\n\treturn awk_false;\n#endif\n}",
      "lines": 31,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "awk_bool_t"
      ]
    },
    "awk_value_to_node": {
      "start_point": [
        152,
        0
      ],
      "end_point": [
        229,
        1
      ],
      "content": "NODE *\nawk_value_to_node(const awk_value_t *retval)\n{\n\tNODE *ext_ret_val = NULL;\n\tNODE *v;\n\n\tif (retval == NULL)\n\t\tfatal(_(\"awk_value_to_node: received null retval\"));\n\n\tswitch (retval->val_type) {\n\tcase AWK_ARRAY:\n\t\text_ret_val = (NODE *) retval->array_cookie;\n\t\tbreak;\n\tcase AWK_UNDEFINED:\n\t\text_ret_val = dupnode(Nnull_string);\n\t\tbreak;\n\tcase AWK_NUMBER:\n\t\tswitch (retval->num_type) {\n\t\tcase AWK_NUMBER_TYPE_DOUBLE:\n\t\t\text_ret_val = make_number(retval->num_value);\n\t\t\tbreak;\n\t\tcase AWK_NUMBER_TYPE_MPFR:\n#ifdef HAVE_MPFR\n\t\t\tif (! do_mpfr)\n\t\t\t\tfatal(_(\"awk_value_to_node: not in MPFR mode\"));\n\t\t\text_ret_val = make_number_node(MPFN);\n\t\t\tmemcpy(&ext_ret_val->mpg_numbr, retval->num_ptr, sizeof(ext_ret_val->mpg_numbr));\n\t\t\tfreempfr(retval->num_ptr);\n#else\n\t\t\tfatal(_(\"awk_value_to_node: MPFR not supported\"));\n#endif\n\t\t\tbreak;\n\t\tcase AWK_NUMBER_TYPE_MPZ:\n#ifdef HAVE_MPFR\n\t\t\tif (! do_mpfr)\n\t\t\t\tfatal(_(\"awk_value_to_node: not in MPFR mode\"));\n\t\t\text_ret_val = make_number_node(MPZN);\n\t\t\tmemcpy(&ext_ret_val->mpg_i, retval->num_ptr, sizeof(ext_ret_val->mpg_i));\n\t\t\tfreempz(retval->num_ptr);\n#else\n\t\t\tfatal(_(\"awk_value_to_node: MPFR not supported\"));\n#endif\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfatal(_(\"awk_value_to_node: invalid number type `%d'\"), retval->num_type);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase AWK_STRING:\n\t\text_ret_val = make_str_node(retval->str_value.str,\n\t\t\t\tretval->str_value.len, ALREADY_MALLOCED);\n\t\tbreak;\n\tcase AWK_STRNUM:\n\t\text_ret_val = make_str_node(retval->str_value.str,\n\t\t\t\tretval->str_value.len, ALREADY_MALLOCED);\n\t\text_ret_val->flags |= USER_INPUT;\n\t\tbreak;\n\tcase AWK_REGEX:\n\t\text_ret_val = make_typed_regex(retval->str_value.str,\n\t\t\t\tretval->str_value.len);\n\t\tbreak;\n\tcase AWK_SCALAR:\n\t\tv = (NODE *) retval->scalar_cookie;\n\t\tif (v->type != Node_var)\n\t\t\text_ret_val = NULL;\n\t\telse\n\t\t\text_ret_val = dupnode(v->var_value);\n\t\tbreak;\n\tcase AWK_VALUE_COOKIE:\n\t\text_ret_val = dupnode((NODE *)(retval->value_cookie));\n\t\tbreak;\n\tdefault:\t/* any invalid type */\n\t\text_ret_val = NULL;\n\t\tbreak;\n\t}\n\n\treturn ext_ret_val;\n}",
      "lines": 78,
      "depth": 16,
      "decorators": [
        "NODE",
        "*\nawk_value_to_node(const awk_value_t *retval)",
        "*"
      ]
    },
    "api_fatal": {
      "start_point": [
        235,
        0
      ],
      "end_point": [
        245,
        1
      ],
      "content": "static void\napi_fatal(awk_ext_id_t id, const char *format, ...)\n{\n\tva_list args;\n\n\t(void) id;\n\n\tva_start(args, format);\n\terr(true, _(\"fatal: \"), format, args);\n\tva_end(args);\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "api_nonfatal": {
      "start_point": [
        249,
        0
      ],
      "end_point": [
        259,
        1
      ],
      "content": "static void\napi_nonfatal(awk_ext_id_t id, const char *format, ...)\n{\n\tva_list args;\n\n\t(void) id;\n\n\tva_start(args, format);\n\terr(false, _(\"error: \"), format, args);\n\tva_end(args);\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "api_warning": {
      "start_point": [
        263,
        0
      ],
      "end_point": [
        273,
        1
      ],
      "content": "static void\napi_warning(awk_ext_id_t id, const char *format, ...)\n{\n\tva_list args;\n\n\t(void) id;\n\n\tva_start(args, format);\n\terr(false, _(\"warning: \"), format, args);\n\tva_end(args);\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "api_lintwarn": {
      "start_point": [
        277,
        0
      ],
      "end_point": [
        291,
        1
      ],
      "content": "static void\napi_lintwarn(awk_ext_id_t id, const char *format, ...)\n{\n\tva_list args;\n\n\t(void) id;\n\n\tva_start(args, format);\n\tif (lintwarn == r_fatal) {\n\t\terr(true, _(\"fatal: \"), format, args);\n\t} else {\n\t\terr(false, _(\"warning: \"), format, args);\n\t}\n\tva_end(args);\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "api_register_input_parser": {
      "start_point": [
        295,
        0
      ],
      "end_point": [
        304,
        1
      ],
      "content": "static void\napi_register_input_parser(awk_ext_id_t id, awk_input_parser_t *input_parser)\n{\n\t(void) id;\n\n\tif (input_parser == NULL)\n\t\treturn;\n\n\tregister_input_parser(input_parser);\n}",
      "lines": 10,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "api_register_output_wrapper": {
      "start_point": [
        308,
        0
      ],
      "end_point": [
        317,
        1
      ],
      "content": "static void api_register_output_wrapper(awk_ext_id_t id,\n\t\tawk_output_wrapper_t *output_wrapper)\n{\n\t(void) id;\n\n\tif (output_wrapper == NULL)\n\t\treturn;\n\n\tregister_output_wrapper(output_wrapper);\n}",
      "lines": 10,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "api_register_two_way_processor": {
      "start_point": [
        321,
        0
      ],
      "end_point": [
        331,
        1
      ],
      "content": "static void\napi_register_two_way_processor(awk_ext_id_t id,\n\t\tawk_two_way_processor_t *two_way_processor)\n{\n\t(void) id;\n\n\tif (two_way_processor == NULL)\n\t\treturn;\n\n\tregister_two_way_processor(two_way_processor);\n}",
      "lines": 11,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "api_update_ERRNO_int": {
      "start_point": [
        337,
        0
      ],
      "end_point": [
        343,
        1
      ],
      "content": "static void\napi_update_ERRNO_int(awk_ext_id_t id, int errno_val)\n{\n\t(void) id;\n\n\tupdate_ERRNO_int(errno_val);\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "api_update_ERRNO_string": {
      "start_point": [
        347,
        0
      ],
      "end_point": [
        357,
        1
      ],
      "content": "static void\napi_update_ERRNO_string(awk_ext_id_t id,\n\t\t\tconst char *string)\n{\n\t(void) id;\n\n\tif (string == NULL)\n\t\treturn;\n\n\tupdate_ERRNO_string(string);\n}",
      "lines": 11,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "api_unset_ERRNO": {
      "start_point": [
        361,
        0
      ],
      "end_point": [
        367,
        1
      ],
      "content": "static void\napi_unset_ERRNO(awk_ext_id_t id)\n{\n\t(void) id;\n\n\tunset_ERRNO();\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "api_add_ext_func": {
      "start_point": [
        372,
        0
      ],
      "end_point": [
        388,
        1
      ],
      "content": "static awk_bool_t\napi_add_ext_func(awk_ext_id_t id,\n\t\tconst char *namespace,\n\t\tawk_ext_func_t *func)\n{\n\t(void) id;\n\t(void) namespace;\n\n\tif (func == NULL)\n\t\treturn awk_false;\n\n#ifdef DYNAMIC\n\treturn make_builtin(func);\n#else\n\treturn awk_false;\n#endif\n}",
      "lines": 17,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "awk_bool_t"
      ]
    },
    "run_ext_exit_handlers": {
      "start_point": [
        401,
        0
      ],
      "end_point": [
        412,
        1
      ],
      "content": "void\nrun_ext_exit_handlers(int exitval)\n{\n\tstruct ext_exit_handler *p, *next;\n\n\tfor (p = list_head; p != NULL; p = next) {\n\t\tnext = p->next;\n\t\tp->funcp(p->arg0, exitval);\n\t\tfree(p);\n\t}\n\tlist_head = NULL;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "api_awk_atexit": {
      "start_point": [
        416,
        0
      ],
      "end_point": [
        438,
        1
      ],
      "content": "static void\napi_awk_atexit(awk_ext_id_t id,\n\t\tvoid (*funcp)(void *data, int exit_status),\n\t\tvoid *arg0)\n{\n\tstruct ext_exit_handler *p;\n\n\t(void) id;\n\n\tif (funcp == NULL)\n\t\treturn;\n\n\t/* allocate memory */\n\temalloc(p, struct ext_exit_handler *, sizeof(struct ext_exit_handler), \"api_awk_atexit\");\n\n\t/* fill it in */\n\tp->funcp = funcp;\n\tp->arg0 = arg0;\n\n\t/* add to linked list, LIFO order */\n\tp->next = list_head;\n\tlist_head = p;\n}",
      "lines": 23,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "free_api_string_copies": {
      "start_point": [
        447,
        0
      ],
      "end_point": [
        455,
        1
      ],
      "content": "void\nfree_api_string_copies()\n{\n\tsize_t i;\n\n\tfor (i = 0; i < scopy.i; i++)\n\t\tfree(scopy.strings[i]);\n\tscopy.i = 0;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "assign_string": {
      "start_point": [
        459,
        0
      ],
      "end_point": [
        487,
        1
      ],
      "content": "static inline void\nassign_string(NODE *node, awk_value_t *val, awk_valtype_t val_type)\n{\n\tval->val_type = val_type;\n\tif (node->stptr[node->stlen] != '\\0') {\n\t\t/*\n\t\t * This is an unterminated field string, so make a copy.\n\t\t * This should happen only for $n where n > 0 and n < NF.\n\t\t */\n\t\tchar *s;\n\n\t\tassert((node->flags & MALLOC) == 0);\n\t\tif (scopy.i == scopy.size) {\n\t\t\t/* expand list */\n\t\t\tif (scopy.size == 0)\n\t\t\t\tscopy.size = 8;\t/* initial size */\n\t\t\telse\n\t\t\t\tscopy.size *= 2;\n\t\t\terealloc(scopy.strings, char **, scopy.size * sizeof(char *), \"assign_string\");\n\t\t}\n\t\temalloc(s, char *, node->stlen + 1, \"assign_string\");\n\t\tmemcpy(s, node->stptr, node->stlen);\n\t\ts[node->stlen] = '\\0';\n\t\tval->str_value.str = scopy.strings[scopy.i++] = s;\n\t}\n\telse\n\t\tval->str_value.str = node->stptr;\n\tval->str_value.len = node->stlen;\n}",
      "lines": 29,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    },
    "assign_number": {
      "start_point": [
        496,
        0
      ],
      "end_point": [
        523,
        1
      ],
      "content": "static inline void\nassign_number(NODE *node, awk_value_t *val)\n{\n\tval->val_type = AWK_NUMBER;\n\n#ifndef HAVE_MPFR\n\tassign_double(val);\n#else\n\tswitch (node->flags & (MPFN|MPZN)) {\n\tcase 0:\n\t\tassign_double(val);\n\t\tbreak;\n\tcase MPFN:\n\t\tval->num_value = mpfr_get_d(node->mpg_numbr, ROUND_MODE);\n\t\tval->num_type = AWK_NUMBER_TYPE_MPFR;\n\t\tval->num_ptr = &node->mpg_numbr;\n\t\tbreak;\n\tcase MPZN:\n\t\tval->num_value = mpz_get_d(node->mpg_i);\n\t\tval->num_type = AWK_NUMBER_TYPE_MPZ;\n\t\tval->num_ptr = &node->mpg_i;\n\t\tbreak;\n\tdefault:\n\t\tfatal(_(\"node_to_awk_value: detected invalid numeric flags combination `%s'; please file a bug report.\"), flags2str(node->flags));\n\t\tbreak;\n\t}\n#endif\n}",
      "lines": 28,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    },
    "assign_regex": {
      "start_point": [
        528,
        0
      ],
      "end_point": [
        537,
        1
      ],
      "content": "static inline void\nassign_regex(NODE *node, awk_value_t *val)\n{\n\t/* a REGEX node cannot be an unterminated field string */\n\tassert((node->flags & MALLOC) != 0);\n\tassert(node->stptr[node->stlen] == '\\0');\n\tval->str_value.str = node->stptr;\n\tval->str_value.len = node->stlen;\n\tval->val_type = AWK_REGEX;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    },
    "node_to_awk_value": {
      "start_point": [
        541,
        0
      ],
      "end_point": [
        728,
        1
      ],
      "content": "static awk_bool_t\nnode_to_awk_value(NODE *node, awk_value_t *val, awk_valtype_t wanted)\n{\n\tawk_bool_t ret = awk_false;\n\n\tif (node == NULL)\n\t\tfatal(_(\"node_to_awk_value: received null node\"));\n\n\tif (val == NULL)\n\t\tfatal(_(\"node_to_awk_value: received null val\"));\n\n\tswitch (node->type) {\n\tcase Node_var_new:\t/* undefined variable */\n\t\tval->val_type = AWK_UNDEFINED;\n\t\tif (wanted == AWK_UNDEFINED) {\n\t\t\tret = awk_true;\n\t\t}\n\t\tbreak;\n\n\tcase Node_var:\n\t\t/* a scalar value */\n\t\tif (wanted == AWK_SCALAR) {\n\t\t\tval->val_type = AWK_SCALAR;\n\t\t\tval->scalar_cookie = (void *) node;\n\t\t\tret = awk_true;\n\t\t\tbreak;\n\t\t}\n\n\t\tnode = node->var_value;\n\t\t/* FALL THROUGH */\n\tcase Node_val:\n\t\t/* a scalar value */\n\t\tswitch (wanted) {\n\t\tcase AWK_NUMBER:\n\t\t\tif (node->flags & REGEX)\n\t\t\t\tval->val_type = AWK_REGEX;\n\t\t\telse {\n\t\t\t\t(void) force_number(node);\n\t\t\t\tassign_number(node, val);\n\t\t\t\tret = awk_true;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase AWK_STRNUM:\n\t\t\tswitch (fixtype(node)->flags & (STRING|NUMBER|USER_INPUT|REGEX)) {\n\t\t\tcase STRING:\n\t\t\t\tval->val_type = AWK_STRING;\n\t\t\t\tbreak;\n\t\t\tcase NUMBER:\n\t\t\t\t(void) force_string(node);\n\t\t\t\t/* fall through */\n\t\t\tcase NUMBER|USER_INPUT:\n\t\t\t\tassign_string(node, val, AWK_STRNUM);\n\t\t\t\tret = awk_true;\n\t\t\t\tbreak;\n\t\t\tcase REGEX:\n\t\t\t\tval->val_type = AWK_REGEX;\n\t\t\t\tbreak;\n\t\t\tcase NUMBER|STRING:\n\t\t\t\tif (node == Nnull_string) {\n\t\t\t\t\tval->val_type = AWK_UNDEFINED;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/* fall through */\n\t\t\tdefault:\n\t\t\t\twarning(_(\"node_to_awk_value detected invalid flags combination `%s'; please file a bug report.\"), flags2str(node->flags));\n\t\t\t\tval->val_type = AWK_UNDEFINED;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase AWK_STRING:\n\t\t\t(void) force_string(node);\n\t\t\tassign_string(node, val, AWK_STRING);\n\t\t\tret = awk_true;\n\t\t\tbreak;\n\n\t\tcase AWK_REGEX:\n\t\t\tswitch (fixtype(node)->flags & (STRING|NUMBER|USER_INPUT|REGEX)) {\n\t\t\tcase STRING:\n\t\t\t\tval->val_type = AWK_STRING;\n\t\t\t\tbreak;\n\t\t\tcase NUMBER:\n\t\t\t\tval->val_type = AWK_NUMBER;\n\t\t\t\tbreak;\n\t\t\tcase NUMBER|USER_INPUT:\n\t\t\t\tval->val_type = AWK_STRNUM;\n\t\t\t\tbreak;\n\t\t\tcase REGEX:\n\t\t\t\tassign_regex(node, val);\n\t\t\t\tret = awk_true;\n\t\t\t\tbreak;\n\t\t\tcase NUMBER|STRING:\n\t\t\t\tif (node == Nnull_string) {\n\t\t\t\t\tval->val_type = AWK_UNDEFINED;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/* fall through */\n\t\t\tdefault:\n\t\t\t\twarning(_(\"node_to_awk_value detected invalid flags combination `%s'; please file a bug report.\"), flags2str(node->flags));\n\t\t\t\tval->val_type = AWK_UNDEFINED;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase AWK_SCALAR:\n\t\t\tswitch (fixtype(node)->flags & (STRING|NUMBER|USER_INPUT|REGEX)) {\n\t\t\tcase STRING:\n\t\t\t\tval->val_type = AWK_STRING;\n\t\t\t\tbreak;\n\t\t\tcase NUMBER:\n\t\t\t\tval->val_type = AWK_NUMBER;\n\t\t\t\tbreak;\n\t\t\tcase NUMBER|USER_INPUT:\n\t\t\t\tval->val_type = AWK_STRNUM;\n\t\t\t\tbreak;\n\t\t\tcase REGEX:\n\t\t\t\tval->val_type = AWK_REGEX;\n\t\t\t\tbreak;\n\t\t\tcase NUMBER|STRING:\n\t\t\t\tif (node == Nnull_string) {\n\t\t\t\t\tval->val_type = AWK_UNDEFINED;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/* fall through */\n\t\t\tdefault:\n\t\t\t\twarning(_(\"node_to_awk_value detected invalid flags combination `%s'; please file a bug report.\"), flags2str(node->flags));\n\t\t\t\tval->val_type = AWK_UNDEFINED;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase AWK_UNDEFINED:\n\t\t\t/* return true and actual type for request of undefined */\n\t\t\tswitch (fixtype(node)->flags & (STRING|NUMBER|USER_INPUT|REGEX)) {\n\t\t\tcase STRING:\n\t\t\t\tassign_string(node, val, AWK_STRING);\n\t\t\t\tret = awk_true;\n\t\t\t\tbreak;\n\t\t\tcase NUMBER:\n\t\t\t\tassign_number(node, val);\n\t\t\t\tret = awk_true;\n\t\t\t\tbreak;\n\t\t\tcase NUMBER|USER_INPUT:\n\t\t\t\tassign_string(node, val, AWK_STRNUM);\n\t\t\t\tret = awk_true;\n\t\t\t\tbreak;\n\t\t\tcase REGEX:\n\t\t\t\tassign_regex(node, val);\n\t\t\t\tret = awk_true;\n\t\t\t\tbreak;\n\t\t\tcase NUMBER|STRING:\n\t\t\t\tif (node == Nnull_string) {\n\t\t\t\t\tval->val_type = AWK_UNDEFINED;\n\t\t\t\t\tret = awk_true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/* fall through */\n\t\t\tdefault:\n\t\t\t\twarning(_(\"node_to_awk_value detected invalid flags combination `%s'; please file a bug report.\"), flags2str(node->flags));\n\t\t\t\tval->val_type = AWK_UNDEFINED;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase AWK_ARRAY:\n\t\tcase AWK_VALUE_COOKIE:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase Node_var_array:\n\t\tval->val_type = AWK_ARRAY;\n\t\tif (wanted == AWK_ARRAY || wanted == AWK_UNDEFINED) {\n\t\t\tval->array_cookie = node;\n\t\t\tret = awk_true;\n\t\t} else\n\t\t\tret = awk_false;\n\t\tbreak;\n\n\tdefault:\n\t\tval->val_type = AWK_UNDEFINED;\n\t\tret = awk_false;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}",
      "lines": 188,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "awk_bool_t"
      ]
    },
    "api_sym_lookup": {
      "start_point": [
        747,
        0
      ],
      "end_point": [
        767,
        1
      ],
      "content": "static awk_bool_t\napi_sym_lookup(awk_ext_id_t id,\n\t\tconst char *name,\n\t\tawk_valtype_t wanted,\n\t\tawk_value_t *result)\n{\n\tNODE *node;\n\n\tupdate_global_values();\t\t/* make sure stuff like NF, NR, are up to date */\n\n\tif (   name == NULL\n\t    || *name == '\\0'\n\t    || result == NULL\n\t    || (node = lookup(name)) == NULL)\n\t\treturn awk_false;\n\n\tif (is_off_limits_var(name))\t/* a built-in variable */\n\t\tnode->flags |= NO_EXT_SET;\n\n\treturn node_to_awk_value(node, result, wanted);\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "awk_bool_t"
      ]
    },
    "api_sym_lookup_scalar": {
      "start_point": [
        771,
        0
      ],
      "end_point": [
        787,
        1
      ],
      "content": "static awk_bool_t\napi_sym_lookup_scalar(awk_ext_id_t id,\n\t\t\tawk_scalar_t cookie,\n\t\t\tawk_valtype_t wanted,\n\t\t\tawk_value_t *result)\n{\n\tNODE *node = (NODE *) cookie;\n\n\tif (node == NULL\n\t    || result == NULL\n\t    || node->type != Node_var)\n\t\treturn awk_false;\n\n\tupdate_global_values();\t/* make sure stuff like NF, NR, are up to date */\n\n\treturn node_to_awk_value(node, result, wanted);\n}",
      "lines": 17,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "awk_bool_t"
      ]
    },
    "api_sym_update": {
      "start_point": [
        791,
        0
      ],
      "end_point": [
        863,
        1
      ],
      "content": "static awk_bool_t\napi_sym_update(awk_ext_id_t id,\n\t\tconst char *name,\n\t\tawk_value_t *value)\n{\n\tNODE *node;\n\tNODE *array_node;\n\n\tif (   name == NULL\n\t    || *name == '\\0'\n\t    || value == NULL)\n\t\treturn awk_false;\n\n\tswitch (value->val_type) {\n\tcase AWK_NUMBER:\n\tcase AWK_STRNUM:\n\tcase AWK_STRING:\n\tcase AWK_REGEX:\n\tcase AWK_UNDEFINED:\n\tcase AWK_ARRAY:\n\tcase AWK_SCALAR:\n\tcase AWK_VALUE_COOKIE:\n\t\tbreak;\n\n\tdefault:\n\t\t/* fatal(_(\"api_sym_update: invalid value for type of new value (%d)\"), value->val_type); */\n\t\treturn awk_false;\n\t}\n\n\tnode = lookup(name);\n\n\tif (node == NULL) {\n\t\t/* new value to be installed */\n\t\tif (value->val_type == AWK_ARRAY) {\n\t\t\tarray_node = awk_value_to_node(value);\n\t\t\tnode = install_symbol(estrdup((char *) name, strlen(name)),\n\t\t\t\t\tNode_var_array);\n\t\t\tarray_node->vname = node->vname;\n\t\t\t*node = *array_node;\n\t\t\tfreenode(array_node);\n\t\t\tvalue->array_cookie = node;\t/* pass new cookie back to extension */\n\t\t} else {\n\t\t\t/* regular variable */\n\t\t\tnode = install_symbol(estrdup((char *) name, strlen(name)),\n\t\t\t\t\tNode_var);\n\t\t\tnode->var_value = awk_value_to_node(value);\n\t\t}\n\n\t\treturn awk_true;\n\t}\n\n\t/*\n\t * If we get here, then it exists already.  Any valid type is\n\t * OK except for AWK_ARRAY.\n\t */\n\tif (   (node->flags & NO_EXT_SET) != 0\n\t    || is_off_limits_var(name)) {\t/* most built-in vars not allowed */\n\t\tnode->flags |= NO_EXT_SET;\n\t\treturn awk_false;\n\t}\n\n\tif (    value->val_type != AWK_ARRAY\n\t    && (node->type == Node_var || node->type == Node_var_new)) {\n\t\tunref(node->var_value);\n\t\tnode->var_value = awk_value_to_node(value);\n\t\tif (node->type == Node_var_new && value->val_type != AWK_UNDEFINED)\n\t\t\tnode->type = Node_var;\n\n\t\treturn awk_true;\n\t}\n\n\treturn awk_false;\n}",
      "lines": 73,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "awk_bool_t"
      ]
    },
    "api_sym_update_scalar": {
      "start_point": [
        867,
        0
      ],
      "end_point": [
        949,
        1
      ],
      "content": "static awk_bool_t\napi_sym_update_scalar(awk_ext_id_t id,\n\t\t\tawk_scalar_t cookie,\n\t\t\tawk_value_t *value)\n{\n\tNODE *node = (NODE *) cookie;\n\n\tif (value == NULL\n\t    || node == NULL\n\t    || node->type != Node_var\n\t    || (node->flags & NO_EXT_SET) != 0)\n\t\treturn awk_false;\n\n\t/*\n\t * Optimization: if valref is 1, and the new value is a string or\n\t * a number, we can avoid calling unref and then making a new node\n\t * by simply installing the new value.  First, we follow the same\n\t * recipe used by node.c:r_unref to wipe the current values, and then\n\t * we copy the logic from r_make_number or make_str_node to install\n\t * the new value.\n\t */\n\tswitch (value->val_type) {\n\tcase AWK_NUMBER:\n\t\tif (node->var_value->valref == 1 && ! do_mpfr) {\n\t\t\tNODE *r = node->var_value;\n\n\t\t\t/* r_unref: */\n\t\t\tif ((r->flags & (MALLOC|STRCUR)) == (MALLOC|STRCUR))\n\t\t\t\tefree(r->stptr);\n\t\t\tfree_wstr(r);\n\n\t\t\t/* r_make_number: */\n\t\t\tr->numbr = value->num_value;\n\t\t\tr->flags = MALLOC|NUMBER|NUMCUR;\n\t\t\tr->stptr = NULL;\n\t\t\tr->stlen = 0;\n\t\t\treturn awk_true;\n\t\t}\n\t\tbreak;\n\n\tcase AWK_STRING:\n\tcase AWK_STRNUM:\n\t\tif (node->var_value->valref == 1) {\n\t\t\tNODE *r = node->var_value;\n\n\t\t\t/* r_unref: */\n\t\t\tif ((r->flags & (MALLOC|STRCUR)) == (MALLOC|STRCUR))\n\t\t\t\tefree(r->stptr);\n\n\t\t\tmpfr_unset(r);\n\t\t\tfree_wstr(r);\n\n\t\t\t/* make_str_node(s, l, ALREADY_MALLOCED): */\n\t\t\tr->numbr = 0;\n\t\t\tr->flags = (MALLOC|STRING|STRCUR);\n\t\t\tif (value->val_type == AWK_STRNUM)\n\t\t\t\tr->flags |= USER_INPUT;\n\t\t\tr->stfmt = STFMT_UNUSED;\n\t\t\tr->stptr = value->str_value.str;\n\t\t\tr->stlen = value->str_value.len;\n#ifdef HAVE_MPFR\n\t\t\tr->strndmode = MPFR_round_mode;\n#endif\n\t\t\treturn awk_true;\n\t\t}\n\t\tbreak;\n\n\tcase AWK_REGEX:\n\tcase AWK_UNDEFINED:\n\tcase AWK_SCALAR:\n\tcase AWK_VALUE_COOKIE:\n\t\tbreak;\n\n\n\tdefault:\t/* AWK_ARRAY or invalid type */\n\t\treturn awk_false;\n\t}\n\n\t/* do it the hard (slow) way */\n\tunref(node->var_value);\n\tnode->var_value = awk_value_to_node(value);\n\treturn awk_true;\n}",
      "lines": 83,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "awk_bool_t"
      ]
    },
    "valid_subscript_type": {
      "start_point": [
        957,
        0
      ],
      "end_point": [
        972,
        1
      ],
      "content": "static inline bool\nvalid_subscript_type(awk_valtype_t valtype)\n{\n\tswitch (valtype) {\n\tcase AWK_UNDEFINED:\n\tcase AWK_NUMBER:\n\tcase AWK_STRNUM:\n\tcase AWK_STRING:\n\tcase AWK_REGEX:\n\tcase AWK_SCALAR:\n\tcase AWK_VALUE_COOKIE:\n\t\treturn true;\n\tdefault:\t/* AWK_ARRAY or an invalid type */\n\t\treturn false;\n\t}\n}",
      "lines": 16,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "bool"
      ]
    },
    "api_get_array_element": {
      "start_point": [
        981,
        0
      ],
      "end_point": [
        1018,
        1
      ],
      "content": "static awk_bool_t\napi_get_array_element(awk_ext_id_t id,\n\t\tawk_array_t a_cookie,\n\t\tconst awk_value_t *const index,\n\t\tawk_valtype_t wanted,\n\t\tawk_value_t *result)\n{\n\tNODE *array = (NODE *) a_cookie;\n\tNODE *subscript;\n\tNODE **aptr;\n\n\t/* don't check for index len zero, null str is ok as index */\n\tif (   array == NULL\n\t    || array->type != Node_var_array\n\t    || result == NULL\n\t    || index == NULL\n\t    || ! valid_subscript_type(index->val_type))\n\t\treturn awk_false;\n\n\tsubscript = awk_value_to_node(index);\n\n\t/* if it doesn't exist, return false */\n\tif (in_array(array, subscript) == NULL) {\n\t\tunref(subscript);\n\t\treturn awk_false;\n\t}\n\n\taptr = assoc_lookup(array, subscript);\n\n\tif (aptr == NULL) {\t/* can't happen */\n\t\tunref(subscript);\n\t\treturn awk_false;\n\t}\n\n\tunref(subscript);\n\n\treturn node_to_awk_value(*aptr, result, wanted);\n}",
      "lines": 38,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "awk_bool_t"
      ]
    },
    "api_set_array_element": {
      "start_point": [
        1025,
        0
      ],
      "end_point": [
        1058,
        1
      ],
      "content": "static awk_bool_t\napi_set_array_element(awk_ext_id_t id, awk_array_t a_cookie,\n\t\t\t\t\tconst awk_value_t *const index,\n\t\t\t\t\tconst awk_value_t *const value)\n{\n\tNODE *array = (NODE *)a_cookie;\n\tNODE *tmp;\n\tNODE *elem;\n\tNODE **aptr;\n\n\t/* don't check for index len zero, null str is ok as index */\n\tif (   array == NULL\n\t    || array->type != Node_var_array\n\t    || (array->flags & NO_EXT_SET) != 0\n\t    || index == NULL\n\t    || value == NULL\n\t    || ! valid_subscript_type(index->val_type))\n\t\treturn awk_false;\n\n\ttmp = awk_value_to_node(index);\n\taptr = assoc_lookup(array, tmp);\n\tunref(*aptr);\n\telem = *aptr = awk_value_to_node(value);\n\tif (elem->type == Node_var_array) {\n\t\telem->parent_array = array;\n\t\telem->vname = estrdup(index->str_value.str,\n\t\t\t\t\tindex->str_value.len);\n\t}\n\tif (array->astore != NULL)\n\t\t(*array->astore)(array, tmp);\n\tunref(tmp);\n\n\treturn awk_true;\n}",
      "lines": 34,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "awk_bool_t"
      ]
    },
    "remove_element": {
      "start_point": [
        1065,
        0
      ],
      "end_point": [
        1090,
        1
      ],
      "content": "static void\nremove_element(NODE *array, NODE *subscript)\n{\n\tNODE *val;\n\n\tif (array == NULL)\n\t\tfatal(_(\"remove_element: received null array\"));\n\n\tif (subscript == NULL)\n\t\tfatal(_(\"remove_element: received null subscript\"));\n\n\tval = in_array(array, subscript);\n\n\tif (val == NULL)\n\t\treturn;\n\n\tif (val->type == Node_var_array) {\n\t\tassoc_clear(val);\n\t\t/* cleared a sub-array, free Node_var_array */\n\t\tefree(val->vname);\n\t\tfreenode(val);\n\t} else\n\t\tunref(val);\n\n\t(void) assoc_remove(array, subscript);\n}",
      "lines": 26,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "api_del_array_element": {
      "start_point": [
        1097,
        0
      ],
      "end_point": [
        1116,
        1
      ],
      "content": "static awk_bool_t\napi_del_array_element(awk_ext_id_t id,\n\t\tawk_array_t a_cookie, const awk_value_t* const index)\n{\n\tNODE *array, *sub;\n\n\tarray = (NODE *) a_cookie;\n\tif (   array == NULL\n\t    || array->type != Node_var_array\n\t    || (array->flags & NO_EXT_SET) != 0\n\t    || index == NULL\n\t    || ! valid_subscript_type(index->val_type))\n\t\treturn awk_false;\n\n\tsub = awk_value_to_node(index);\n\tremove_element(array, sub);\n\tunref(sub);\n\n\treturn awk_true;\n}",
      "lines": 20,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "awk_bool_t"
      ]
    },
    "api_get_element_count": {
      "start_point": [
        1123,
        0
      ],
      "end_point": [
        1134,
        1
      ],
      "content": "static awk_bool_t\napi_get_element_count(awk_ext_id_t id,\n\t\tawk_array_t a_cookie, size_t *count)\n{\n\tNODE *node = (NODE *) a_cookie;\n\n\tif (count == NULL || node == NULL || node->type != Node_var_array)\n\t\treturn awk_false;\n\n\t*count = node->table_size;\n\treturn awk_true;\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "awk_bool_t"
      ]
    },
    "api_create_array": {
      "start_point": [
        1138,
        0
      ],
      "end_point": [
        1148,
        1
      ],
      "content": "static awk_array_t\napi_create_array(awk_ext_id_t id)\n{\n\tNODE *n;\n\n\tgetnode(n);\n\tmemset(n, 0, sizeof(NODE));\n\tnull_array(n);\n\n\treturn (awk_array_t) n;\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "awk_array_t"
      ]
    },
    "api_clear_array": {
      "start_point": [
        1152,
        0
      ],
      "end_point": [
        1164,
        1
      ],
      "content": "static awk_bool_t\napi_clear_array(awk_ext_id_t id, awk_array_t a_cookie)\n{\n\tNODE *node = (NODE *) a_cookie;\n\n\tif (   node == NULL\n\t    || node->type != Node_var_array\n\t    || (node->flags & NO_EXT_SET) != 0)\n\t\treturn awk_false;\n\n\tassoc_clear(node);\n\treturn awk_true;\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "awk_bool_t"
      ]
    },
    "api_flatten_array_typed": {
      "start_point": [
        1168,
        0
      ],
      "end_point": [
        1216,
        1
      ],
      "content": "static awk_bool_t\napi_flatten_array_typed(awk_ext_id_t id,\n\t\tawk_array_t a_cookie,\n\t\tawk_flat_array_t **data,\n\t\tawk_valtype_t index_type, awk_valtype_t value_type)\n{\n\tNODE **list;\n\tsize_t i, j;\n\tNODE *array = (NODE *) a_cookie;\n\tsize_t alloc_size;\n\n\tif (   array == NULL\n\t    || array->type != Node_var_array\n\t    || array->table_size == 0\n\t    || data == NULL)\n\t\treturn awk_false;\n\n\talloc_size = sizeof(awk_flat_array_t) +\n\t\t\t(array->table_size - 1) * sizeof(awk_element_t);\n\n\tezalloc(*data, awk_flat_array_t *, alloc_size,\n\t\t\t\"api_flatten_array_typed\");\n\n\tlist = assoc_list(array, \"@unsorted\", ASORTI);\n\n\t(*data)->opaque1 = array;\n\t(*data)->opaque2 = list;\n\t(*data)->count = array->table_size;\n\n\tfor (i = j = 0; i < 2 * array->table_size; i += 2, j++) {\n\t\tNODE *index, *value;\n\n\t\tindex = list[i];\n\t\tvalue = list[i + 1]; /* number or string or subarray */\n\n\t\t/* Convert index and value to API types. */\n\t\tif (! node_to_awk_value(index,\n\t\t\t\t& (*data)->elements[j].index, index_type)) {\n\t\t\tfatal(_(\"api_flatten_array_typed: could not convert index %d to %s\\n\"),\n\t\t\t\t\t\t(int) i, valtype2str(index_type));\n\t\t}\n\t\tif (! node_to_awk_value(value,\n\t\t\t\t& (*data)->elements[j].value, value_type)) {\n\t\t\tfatal(_(\"api_flatten_array_typed: could not convert value %d to %s\\n\"),\n\t\t\t\t\t\t(int) i, valtype2str(value_type));\n\t\t}\n\t}\n\treturn awk_true;\n}",
      "lines": 49,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "awk_bool_t"
      ]
    },
    "api_release_flattened_array": {
      "start_point": [
        1224,
        0
      ],
      "end_point": [
        1257,
        1
      ],
      "content": "static awk_bool_t\napi_release_flattened_array(awk_ext_id_t id,\n\t\tawk_array_t a_cookie,\n\t\tawk_flat_array_t *data)\n{\n\tNODE *array = a_cookie;\n\tNODE **list;\n\tsize_t i, j, k;\n\n\tif (   array == NULL\n\t    || array->type != Node_var_array\n\t    || data == NULL\n\t    || array != (NODE *) data->opaque1\n\t    || data->count != array->table_size\n\t    || data->opaque2 == NULL)\n\t\treturn awk_false;\n\n\tlist = (NODE **) data->opaque2;\n\n\t/* free index nodes */\n\tfor (i = j = 0, k = 2 * array->table_size; i < k; i += 2, j++) {\n\t\t/* Delete items flagged for delete. */\n\t\tif (   (data->elements[j].flags & AWK_ELEMENT_DELETE) != 0\n\t\t    && (array->flags & NO_EXT_SET) == 0) {\n\t\t\tremove_element(array, list[i]);\n\t\t}\n\t\tunref(list[i]);\n\t}\n\n\tefree(list);\n\tefree(data);\n\n\treturn awk_true;\n}",
      "lines": 34,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "awk_bool_t"
      ]
    },
    "api_create_value": {
      "start_point": [
        1261,
        0
      ],
      "end_point": [
        1280,
        1
      ],
      "content": "static awk_bool_t\napi_create_value(awk_ext_id_t id, awk_value_t *value,\n\t\tawk_value_cookie_t *result)\n{\n\tif (value == NULL || result == NULL)\n\t\treturn awk_false;\n\n\tswitch (value->val_type) {\n\tcase AWK_NUMBER:\n\tcase AWK_STRNUM:\n\tcase AWK_STRING:\n\tcase AWK_REGEX:\n\t\tbreak;\n\tdefault:\n\t\t/* reject anything other than a simple scalar */\n\t\treturn awk_false;\n\t}\n\n\treturn (awk_bool_t) ((*result = awk_value_to_node(value)) != NULL);\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "awk_bool_t"
      ]
    },
    "api_release_value": {
      "start_point": [
        1284,
        0
      ],
      "end_point": [
        1294,
        1
      ],
      "content": "static awk_bool_t\napi_release_value(awk_ext_id_t id, awk_value_cookie_t value)\n{\n\tNODE *val = (NODE *) value;\n\n\tif (val == NULL)\n\t\treturn awk_false;\n\n\tunref(val);\n\treturn awk_true;\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "awk_bool_t"
      ]
    },
    "api_get_mpfr": {
      "start_point": [
        1298,
        0
      ],
      "end_point": [
        1310,
        1
      ],
      "content": "static void *\napi_get_mpfr(awk_ext_id_t id)\n{\n#ifdef HAVE_MPFR\n\tmpfr_ptr p;\n\tgetmpfr(p);\n\tmpfr_init(p);\n\treturn p;\n#else\n\tfatal(_(\"api_get_mpfr: MPFR not supported\"));\n\treturn NULL;\t// silence compiler warning\n#endif\n}",
      "lines": 13,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void",
        "*\napi_get_mpfr(awk_ext_id_t id)",
        "*"
      ]
    },
    "api_get_mpz": {
      "start_point": [
        1314,
        0
      ],
      "end_point": [
        1326,
        1
      ],
      "content": "static void *\napi_get_mpz(awk_ext_id_t id)\n{\n#ifdef HAVE_MPFR\n\tmpz_ptr p;\n\tgetmpz(p);\n\tmpz_init(p);\n\treturn p;\n#else\n\tfatal(_(\"api_get_mpfr: MPFR not supported\"));\n\treturn NULL;\t// silence compiler warning\n#endif\n}",
      "lines": 13,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void",
        "*\napi_get_mpz(awk_ext_id_t id)",
        "*"
      ]
    },
    "api_get_file": {
      "start_point": [
        1330,
        0
      ],
      "end_point": [
        1419,
        1
      ],
      "content": "static awk_bool_t\napi_get_file(awk_ext_id_t id, const char *name, size_t namelen, const char *filetype,\n\t\tint fd, const awk_input_buf_t **ibufp, const awk_output_buf_t **obufp)\n{\n\tconst struct redirect *f;\n\tint flag;\t/* not used, sigh */\n\tenum redirval redirtype;\n\n\tif (name == NULL || namelen == 0) {\n\t\tif (curfile == NULL) {\n\t\t\tINSTRUCTION *pc;\n\t\t\tint save_rule;\n\t\t\tchar *save_source;\n\n\t\t\tif (nextfile(& curfile, false) <= 0)\n\t\t\t\treturn awk_false;\n\n\t\t\tpc = main_beginfile;\n\t\t\t/* save execution state */\n\t\t\tsave_rule = currule;\n\t\t\tsave_source = source;\n\n\t\t\tfor (;;) {\n\t\t\t\tif (pc == NULL)\n\t\t\t\t\tfatal(_(\"cannot find end of BEGINFILE rule\"));\n\t\t\t\tif (pc->opcode == Op_after_beginfile)\n\t\t\t\t\tbreak;\n\t\t\t\tpc = pc->nexti;\n\t\t\t}\n\t\t\tpc->opcode = Op_stop;\n\t\t        (void) (*interpret)(main_beginfile);\n\t\t\tpc->opcode = Op_after_beginfile;\n\t\t\tafter_beginfile(& curfile);\n\t\t\t/* restore execution state */\n\t\t\tcurrule = save_rule;\n\t\t\tsource = save_source;\n\t\t}\n\t\t*ibufp = &curfile->public;\n\t\t*obufp = NULL;\n\n\t\treturn awk_true;\n\t}\n\n\tredirtype = redirect_none;\n\tswitch (filetype[0]) {\n\tcase '<':\n\t\tif (filetype[1] == '\\0')\n\t\t\tredirtype = redirect_input;\n\t\tbreak;\n\tcase '>':\n\t\tswitch (filetype[1]) {\n\t\tcase '\\0':\n\t\t\tredirtype = redirect_output;\n\t\t\tbreak;\n\t\tcase '>':\n\t\t\tif (filetype[2] == '\\0')\n\t\t\t\tredirtype = redirect_append;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase '|':\n\t\tif (filetype[2] == '\\0') {\n\t\t\tswitch (filetype[1]) {\n\t\t\tcase '>':\n\t\t\t\tredirtype = redirect_pipe;\n\t\t\t\tbreak;\n\t\t\tcase '<':\n\t\t\t\tredirtype = redirect_pipein;\n\t\t\t\tbreak;\n\t\t\tcase '&':\n\t\t\t\tredirtype = redirect_twoway;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (redirtype == redirect_none) {\n\t\twarning(_(\"cannot open unrecognized file type `%s' for `%s'\"),\n\t\t\tfiletype, name);\n\t\treturn awk_false;\n\t}\n\n\tif ((f = redirect_string(name, namelen, 0, redirtype, &flag, fd, false)) == NULL)\n\t\treturn awk_false;\n\n\t*ibufp = f->iop ? & f->iop->public : NULL;\n\t*obufp = f->output.fp ? & f->output : NULL;\n\treturn awk_true;\n}",
      "lines": 90,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "awk_bool_t"
      ]
    },
    "api_register_ext_version": {
      "start_point": [
        1434,
        0
      ],
      "end_point": [
        1448,
        1
      ],
      "content": "static void\napi_register_ext_version(awk_ext_id_t id, const char *version)\n{\n\tstruct version_info *info;\n\n\tif (version == NULL)\n\t\treturn;\n\n\t(void) id;\n\n\temalloc(info, struct version_info *, sizeof(struct version_info), \"register_ext_version\");\n\tinfo->version = version;\n\tinfo->next = vi_head;\n\tvi_head = info;\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "init_ext_api": {
      "start_point": [
        1526,
        0
      ],
      "end_point": [
        1536,
        1
      ],
      "content": "void\ninit_ext_api()\n{\n\t/* force values to 1 / 0 */\n\tapi_impl.do_flags[0] = (do_lint ? 1 : 0);\n\tapi_impl.do_flags[1] = (do_traditional ? 1 : 0);\n\tapi_impl.do_flags[2] = (do_profile ? 1 : 0);\n\tapi_impl.do_flags[3] = (do_sandbox ? 1 : 0);\n\tapi_impl.do_flags[4] = (do_debug ? 1 : 0);\n\tapi_impl.do_flags[5] = (do_mpfr ? 1 : 0);\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "update_ext_api": {
      "start_point": [
        1540,
        0
      ],
      "end_point": [
        1544,
        1
      ],
      "content": "void\nupdate_ext_api()\n{\n\tapi_impl.do_flags[0] = (do_lint ? 1 : 0);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "print_ext_versions": {
      "start_point": [
        1548,
        0
      ],
      "end_point": [
        1555,
        1
      ],
      "content": "extern void\nprint_ext_versions(void)\n{\n\tstruct version_info *p;\n\n\tfor (p = vi_head; p != NULL; p = p->next)\n\t\tprintf(\"%s\\n\", p->version);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "extern",
        "extern",
        "void"
      ]
    },
    "valtype2str": {
      "start_point": [
        1559,
        0
      ],
      "end_point": [
        1582,
        1
      ],
      "content": "static char *\nvaltype2str(awk_valtype_t type)\n{\n\tstatic char buf[100];\n\n\t// Important: keep in same order as in gawkapi.h!\n\tstatic char *values[] = {\n\t\t\"AWK_UNDEFINED\",\n\t\t\"AWK_NUMBER\",\n\t\t\"AWK_STRING\",\n\t\t\"AWK_REGEX\",\n\t\t\"AWK_STRNUM\",\n\t\t\"AWK_ARRAY\",\n\t\t\"AWK_SCALAR\",\n\t\t\"AWK_VALUE_COOKIE\",\n\t};\n\n\tif (AWK_UNDEFINED <= type && type <= AWK_VALUE_COOKIE)\n\t\treturn values[(int) type];\n\n\tsprintf(buf, \"unknown type! (%d)\", (int) type);\n\n\treturn buf;\n}",
      "lines": 24,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nvaltype2str(awk_valtype_t type)",
        "*"
      ]
    }
  },
  "gawk/gawk-4.2.1/gawkapi.h": {
    "r_make_string_type": {
      "start_point": [
        947,
        0
      ],
      "end_point": [
        973,
        1
      ],
      "content": "static inline awk_value_t *\nr_make_string_type(const gawk_api_t *api,\t/* needed for emalloc */\n\t\t   awk_ext_id_t ext_id,\t\t/* ditto */\n\t\t   const char *string,\n\t\t   size_t length,\n\t\t   awk_bool_t duplicate,\n\t\t   awk_value_t *result,\n\t\t   awk_valtype_t val_type)\n{\n\tchar *cp = NULL;\n\n\tmemset(result, 0, sizeof(*result));\n\n\tresult->val_type = val_type;\n\tresult->str_value.len = length;\n\n\tif (duplicate) {\n\t\temalloc(cp, char *, length + 1, \"r_make_string\");\n\t\tmemcpy(cp, string, length);\n\t\tcp[length] = '\\0';\n\t\tresult->str_value.str = cp;\n\t} else {\n\t\tresult->str_value.str = (char *) string;\n\t}\n\n\treturn result;\n}",
      "lines": 27,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "awk_value_t",
        "*\nr_make_string_type(const gawk_api_t *api,\t/* needed for emalloc */\n\t\t   awk_ext_id_t ext_id,\t\t/* ditto */\n\t\t   const char *string,\n\t\t   size_t length,\n\t\t   awk_bool_t duplicate,\n\t\t   awk_value_t *result,\n\t\t   awk_valtype_t val_type)",
        "*"
      ]
    },
    "r_make_string": {
      "start_point": [
        977,
        0
      ],
      "end_point": [
        986,
        1
      ],
      "content": "static inline awk_value_t *\nr_make_string(const gawk_api_t *api,\t/* needed for emalloc */\n\t      awk_ext_id_t ext_id,\t/* ditto */\n\t      const char *string,\n\t      size_t length,\n\t      awk_bool_t duplicate,\n\t      awk_value_t *result)\n{\n\treturn r_make_string_type(api, ext_id, string, length, duplicate, result, AWK_STRING);\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "awk_value_t",
        "*\nr_make_string(const gawk_api_t *api,\t/* needed for emalloc */\n\t      awk_ext_id_t ext_id,\t/* ditto */\n\t      const char *string,\n\t      size_t length,\n\t      awk_bool_t duplicate,\n\t      awk_value_t *result)",
        "*"
      ]
    },
    "make_null_string": {
      "start_point": [
        1004,
        0
      ],
      "end_point": [
        1011,
        1
      ],
      "content": "static inline awk_value_t *\nmake_null_string(awk_value_t *result)\n{\n\tmemset(result, 0, sizeof(*result));\n\tresult->val_type = AWK_UNDEFINED;\n\n\treturn result;\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "awk_value_t",
        "*\nmake_null_string(awk_value_t *result)",
        "*"
      ]
    },
    "make_number": {
      "start_point": [
        1015,
        0
      ],
      "end_point": [
        1022,
        1
      ],
      "content": "static inline awk_value_t *\nmake_number(double num, awk_value_t *result)\n{\n\tresult->val_type = AWK_NUMBER;\n\tresult->num_value = num;\n\tresult->num_type = AWK_NUMBER_TYPE_DOUBLE;\n\treturn result;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "awk_value_t",
        "*\nmake_number(double num, awk_value_t *result)",
        "*"
      ]
    },
    "make_number_mpz": {
      "start_point": [
        1030,
        0
      ],
      "end_point": [
        1037,
        1
      ],
      "content": "static inline awk_value_t *\nmake_number_mpz(void *mpz_ptr, awk_value_t *result)\n{\n\tresult->val_type = AWK_NUMBER;\n\tresult->num_type = AWK_NUMBER_TYPE_MPZ;\n\tresult->num_ptr = mpz_ptr;\n\treturn result;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "awk_value_t",
        "*\nmake_number_mpz(void *mpz_ptr, awk_value_t *result)",
        "*"
      ]
    },
    "make_number_mpfr": {
      "start_point": [
        1045,
        0
      ],
      "end_point": [
        1052,
        1
      ],
      "content": "static inline awk_value_t *\nmake_number_mpfr(void *mpfr_ptr, awk_value_t *result)\n{\n\tresult->val_type = AWK_NUMBER;\n\tresult->num_type = AWK_NUMBER_TYPE_MPFR;\n\tresult->num_ptr = mpfr_ptr;\n\treturn result;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "awk_value_t",
        "*\nmake_number_mpfr(void *mpfr_ptr, awk_value_t *result)",
        "*"
      ]
    },
    "init_my_extension": {
      "start_point": [
        1090,
        0
      ],
      "end_point": [
        1094,
        1
      ],
      "content": "static awk_bool_t\ninit_my_extension(void)\n{\n\t...\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "awk_bool_t"
      ]
    }
  },
  "gawk/gawk-4.2.1/gawkmisc.c": {},
  "gawk/gawk-4.2.1/gettext.h": {
    "pgettext_aux": {
      "start_point": [
        155,
        0
      ],
      "end_point": [
        165,
        1
      ],
      "content": "static const char *\npgettext_aux (const char *domain,\n              const char *msg_ctxt_id, const char *msgid,\n              int category)\n{\n  const char *translation = dcgettext (domain, msg_ctxt_id, category);\n  if (translation == msg_ctxt_id)\n    return msgid;\n  else\n    return translation;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\npgettext_aux (const char *domain,\n              const char *msg_ctxt_id, const char *msgid,\n              int category)",
        "*"
      ]
    },
    "npgettext_aux": {
      "start_point": [
        174,
        0
      ],
      "end_point": [
        186,
        1
      ],
      "content": "static const char *\nnpgettext_aux (const char *domain,\n               const char *msg_ctxt_id, const char *msgid,\n               const char *msgid_plural, unsigned long int n,\n               int category)\n{\n  const char *translation =\n    dcngettext (domain, msg_ctxt_id, msgid_plural, n, category);\n  if (translation == msg_ctxt_id || translation == msgid_plural)\n    return (n == 1 ? msgid : msgid_plural);\n  else\n    return translation;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nnpgettext_aux (const char *domain,\n               const char *msg_ctxt_id, const char *msgid,\n               const char *msgid_plural, unsigned long int n,\n               int category)",
        "*"
      ]
    },
    "dcpgettext_expr": {
      "start_point": [
        218,
        0
      ],
      "end_point": [
        251,
        1
      ],
      "content": "static const char *\ndcpgettext_expr (const char *domain,\n                 const char *msgctxt, const char *msgid,\n                 int category)\n{\n  size_t msgctxt_len = strlen (msgctxt) + 1;\n  size_t msgid_len = strlen (msgid) + 1;\n  const char *translation;\n#if _LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n  char msg_ctxt_id[msgctxt_len + msgid_len];\n#else\n  char buf[1024];\n  char *msg_ctxt_id =\n    (msgctxt_len + msgid_len <= sizeof (buf)\n     ? buf\n     : (char *) malloc (msgctxt_len + msgid_len));\n  if (msg_ctxt_id != NULL)\n#endif\n    {\n      int found_translation;\n      memcpy (msg_ctxt_id, msgctxt, msgctxt_len - 1);\n      msg_ctxt_id[msgctxt_len - 1] = '\\004';\n      memcpy (msg_ctxt_id + msgctxt_len, msgid, msgid_len);\n      translation = dcgettext (domain, msg_ctxt_id, category);\n      found_translation = (translation != msg_ctxt_id);\n#if !_LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n      if (msg_ctxt_id != buf)\n        free (msg_ctxt_id);\n#endif\n      if (found_translation)\n        return translation;\n    }\n  return msgid;\n}",
      "lines": 34,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\ndcpgettext_expr (const char *domain,\n                 const char *msgctxt, const char *msgid,\n                 int category)",
        "*"
      ]
    },
    "dcnpgettext_expr": {
      "start_point": [
        265,
        0
      ],
      "end_point": [
        299,
        1
      ],
      "content": "static const char *\ndcnpgettext_expr (const char *domain,\n                  const char *msgctxt, const char *msgid,\n                  const char *msgid_plural, unsigned long int n,\n                  int category)\n{\n  size_t msgctxt_len = strlen (msgctxt) + 1;\n  size_t msgid_len = strlen (msgid) + 1;\n  const char *translation;\n#if _LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n  char msg_ctxt_id[msgctxt_len + msgid_len];\n#else\n  char buf[1024];\n  char *msg_ctxt_id =\n    (msgctxt_len + msgid_len <= sizeof (buf)\n     ? buf\n     : (char *) malloc (msgctxt_len + msgid_len));\n  if (msg_ctxt_id != NULL)\n#endif\n    {\n      int found_translation;\n      memcpy (msg_ctxt_id, msgctxt, msgctxt_len - 1);\n      msg_ctxt_id[msgctxt_len - 1] = '\\004';\n      memcpy (msg_ctxt_id + msgctxt_len, msgid, msgid_len);\n      translation = dcngettext (domain, msg_ctxt_id, msgid_plural, n, category);\n      found_translation = !(translation == msg_ctxt_id || translation == msgid_plural);\n#if !_LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n      if (msg_ctxt_id != buf)\n        free (msg_ctxt_id);\n#endif\n      if (found_translation)\n        return translation;\n    }\n  return (n == 1 ? msgid : msgid_plural);\n}",
      "lines": 35,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\ndcnpgettext_expr (const char *domain,\n                  const char *msgctxt, const char *msgid,\n                  const char *msgid_plural, unsigned long int n,\n                  int category)",
        "*"
      ]
    }
  },
  "gawk/gawk-4.2.1/interpret.h": {
    "r_interpret": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        1470,
        1
      ],
      "content": "int\nr_interpret(INSTRUCTION *code)\n{\n\tINSTRUCTION *pc;   /* current instruction */\n\tOPCODE op;\t/* current opcode */\n\tNODE *r = NULL;\n\tNODE *m;\n\tINSTRUCTION *ni;\n\tNODE *t1, *t2;\n\tNODE **lhs;\n\tAWKNUM x, x2;\n\tint di;\n\tRegexp *rp;\n\tNODE *set_array = NULL;\t/* array with a post-assignment routine */\n\tNODE *set_idx = NULL;\t/* the index of the array element */\n\n\n/* array subscript */\n#define mk_sub(n)  \t(n == 1 ? POP_SCALAR() : concat_exp(n, true))\n\n#ifdef EXEC_HOOK\n#define JUMPTO(x)\tdo { if (post_execute) post_execute(pc); pc = (x); goto top; } while (false)\n#else\n#define JUMPTO(x)\tdo { pc = (x); goto top; } while (false)\n#endif\n\n\tpc = code;\n\n\t/* N.B.: always use JUMPTO for next instruction, otherwise bad things\n\t * may happen. DO NOT add a real loop (for/while) below to\n\t * replace ' forever {'; this catches failure to use JUMPTO to execute\n\t * next instruction (e.g. continue statement).\n\t */\n\n\t/* loop until hit Op_stop instruction */\n\n\t/* forever {  */\ntop:\n\t\tif (pc->source_line > 0)\n\t\t\tsourceline = pc->source_line;\n\n#ifdef EXEC_HOOK\n\t\tfor (di = 0; di < num_exec_hook; di++) {\n\t\t\tif (! pre_execute[di](& pc))\n\t\t\t\tgoto top;\n\t\t}\n#endif\n\n\t\tswitch ((op = pc->opcode)) {\n\t\tcase Op_rule:\n\t\t\tcurrule = pc->in_rule;   /* for sole use in Op_K_next, Op_K_nextfile, Op_K_getline */\n\t\t\t/* fall through */\n\t\tcase Op_func:\n\t\t\tsource = pc->source_file;\n\t\t\tbreak;\n\n\t\tcase Op_atexit:\n\t\t{\n\t\t\tbool stdio_problem = false;\n\n\t\t\t/* avoid false source indications */\n\t\t\tsource = NULL;\n\t\t\tsourceline = 0;\n\t\t\t(void) nextfile(& curfile, true);\t/* close input data file */\n\t\t\t/*\n\t\t\t * This used to be:\n\t\t\t *\n\t\t\t * if (close_io() != 0 && ! exiting && exit_val == 0)\n\t\t\t *      exit_val = 1;\n\t\t\t *\n\t\t\t * Other awks don't care about problems closing open files\n\t\t\t * and pipes, in that it doesn't affect their exit status.\n\t\t\t * So we no longer do either.\n\t\t\t */\n\t\t\t(void) close_io(& stdio_problem);\n\t\t\t/*\n\t\t\t * However, we do want to exit non-zero if there was a problem\n\t\t\t * with stdout/stderr, so we reinstate a slightly different\n\t\t\t * version of the above:\n\t\t\t */\n\t\t\tif (stdio_problem && ! exiting && exit_val == 0)\n\t\t\t\texit_val = 1;\n\n\t\t\tclose_extensions();\n\t\t}\n\t\t\tbreak;\n\n\t\tcase Op_stop:\n\t\t\treturn 0;\n\n\t\tcase Op_push_i:\n\t\t\tm = pc->memory;\n\t\t\tif (! do_traditional && (m->flags & INTLSTR) != 0) {\n\t\t\t\tchar *orig, *trans, save;\n\n\t\t\t\tsave = m->stptr[m->stlen];\n\t\t\t\tm->stptr[m->stlen] = '\\0';\n\t\t\t\torig = m->stptr;\n\t\t\t\ttrans = dgettext(TEXTDOMAIN, orig);\n\t\t\t\tm->stptr[m->stlen] = save;\n\t\t\t\tm = make_string(trans, strlen(trans));\n\t\t\t} else\n\t\t\t\tUPREF(m);\n\t\t\tPUSH(m);\n\t\t\tbreak;\n\n\t\tcase Op_push:\n\t\tcase Op_push_arg:\n\t\tcase Op_push_arg_untyped:\n\t\t{\n\t\t\tNODE *save_symbol;\n\t\t\tbool isparam = false;\n\n\t\t\tsave_symbol = m = pc->memory;\n\t\t\tif (m->type == Node_param_list) {\n\t\t\t\tisparam = true;\n\t\t\t\tsave_symbol = m = GET_PARAM(m->param_cnt);\n\t\t\t\tif (m->type == Node_array_ref) {\n\t\t\t\t\tif (m->orig_array->type == Node_var) {\n\t\t\t\t\t\t/* gawk 'func f(x) { a = 10; print x; } BEGIN{ f(a) }' */\n\t\t\t\t\t\tgoto uninitialized_scalar;\n\t\t\t\t\t}\n\t\t\t\t\tm = m->orig_array;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tswitch (m->type) {\n\t\t\tcase Node_var:\n\t\t\t\tif (do_lint && var_uninitialized(m))\n\t\t\t\t\tlintwarn(isparam ?\n\t\t\t\t\t\t_(\"reference to uninitialized argument `%s'\") :\n\t\t\t\t\t\t_(\"reference to uninitialized variable `%s'\"),\n\t\t\t\t\t\t\t\tsave_symbol->vname);\n\t\t\t\tm = m->var_value;\n\t\t\t\tUPREF(m);\n\t\t\t\tPUSH(m);\n\t\t\t\tbreak;\n\n\t\t\tcase Node_var_new:\nuninitialized_scalar:\n\t\t\t\tif (op != Op_push_arg_untyped) {\n\t\t\t\t\t/* convert untyped to scalar */\n\t\t\t\t\tm->type = Node_var;\n\t\t\t\t\tm->var_value = dupnode(Nnull_string);\n\t\t\t\t}\n\t\t\t\tif (do_lint)\n\t\t\t\t\tlintwarn(isparam ?\n\t\t\t\t\t\t_(\"reference to uninitialized argument `%s'\") :\n\t\t\t\t\t\t_(\"reference to uninitialized variable `%s'\"),\n\t\t\t\t\t\t\t\tsave_symbol->vname);\n\t\t\t\tif (op != Op_push_arg_untyped)\n\t\t\t\t\tm = dupnode(Nnull_string);\n\t\t\t\tPUSH(m);\n\t\t\t\tbreak;\n\n\t\t\tcase Node_var_array:\n\t\t\t\tif (op == Op_push_arg || op == Op_push_arg_untyped)\n\t\t\t\t\tPUSH(m);\n\t\t\t\telse\n\t\t\t\t\tfatal(_(\"attempt to use array `%s' in a scalar context\"),\n\t\t\t\t\t\t\tarray_vname(save_symbol));\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tcant_happen();\n\t\t\t}\n\t\t}\n\t\t\tbreak;\n\n\t\tcase Op_push_param:\t\t/* function argument */\n\t\t\tm = pc->memory;\n\t\t\tif (m->type == Node_param_list)\n\t\t\t\tm = GET_PARAM(m->param_cnt);\n\t\t\tif (m->type == Node_var) {\n\t\t\t\tm = m->var_value;\n\t\t\t\tUPREF(m);\n\t\t\t\tPUSH(m);\n\t\t \t\tbreak;\n\t\t\t}\n \t\t\t/* else\n\t\t\t\tfall through */\n\t\tcase Op_push_array:\n\t\t\tPUSH(pc->memory);\n\t\t\tbreak;\n\n\t\tcase Op_push_lhs:\n\t\t\tlhs = get_lhs(pc->memory, pc->do_reference);\n\t\t\tPUSH_ADDRESS(lhs);\n\t\t\tbreak;\n\n\t\tcase Op_subscript:\n\t\t\tt2 = mk_sub(pc->sub_count);\n\t\t\tt1 = POP_ARRAY();\n\n\t\t\tif (do_lint && in_array(t1, t2) == NULL) {\n\t\t\t\tt2 = force_string(t2);\n\t\t\t\tlintwarn(_(\"reference to uninitialized element `%s[\\\"%.*s\\\"]'\"),\n\t\t\t\t\tarray_vname(t1), (int) t2->stlen, t2->stptr);\n\t\t\t\tif (t2->stlen == 0)\n\t\t\t\t\tlintwarn(_(\"subscript of array `%s' is null string\"), array_vname(t1));\n\t\t\t}\n\n\t\t\t/* for FUNCTAB, get the name as the element value */\n\t\t\tif (t1 == func_table) {\n\t\t\t\tstatic bool warned = false;\n\n\t\t\t\tif (do_lint && ! warned) {\n\t\t\t\t\twarned = true;\n\t\t\t\t\tlintwarn(_(\"FUNCTAB is a gawk extension\"));\n\t\t\t\t}\n\t\t\t\tr = t2;\n\t\t\t} else {\n\t\t\t\t/* make sure stuff like NF, NR, are up to date */\n\t\t\t\tif (t1 == symbol_table)\n\t\t\t\t\tupdate_global_values();\n\n\t\t\t\tr = *assoc_lookup(t1, t2);\n\t\t\t}\n\t\t\tDEREF(t2);\n\n\t\t\t/* for SYMTAB, step through to the actual variable */\n\t\t\tif (t1 == symbol_table) {\n\t\t\t\tstatic bool warned = false;\n\n\t\t\t\tif (do_lint && ! warned) {\n\t\t\t\t\twarned = true;\n\t\t\t\t\tlintwarn(_(\"SYMTAB is a gawk extension\"));\n\t\t\t\t}\n\t\t\t\tif (r->type == Node_var)\n\t\t\t\t\tr = r->var_value;\n\t\t\t}\n\n\t\t\tif (r->type == Node_val)\n\t\t\t\tUPREF(r);\n\t\t\tPUSH(r);\n\t\t\tbreak;\n\n\t\tcase Op_sub_array:\n\t\t\tt2 = mk_sub(pc->sub_count);\n\t\t\tt1 = POP_ARRAY();\n\t\t\tr = in_array(t1, t2);\n\t\t\tif (r == NULL) {\n\t\t\t\tr = make_array();\n\t\t\t\tr->parent_array = t1;\n\t\t\t\tlhs = assoc_lookup(t1, t2);\n\t\t\t\tunref(*lhs);\n\t\t\t\t*lhs = r;\n\t\t\t\tt2 = force_string(t2);\n\t\t\t\tr->vname = estrdup(t2->stptr, t2->stlen);\t/* the subscript in parent array */\n\n\t\t\t\t/* execute post-assignment routine if any */\n\t\t\t\tif (t1->astore != NULL)\n\t\t\t\t\t(*t1->astore)(t1, t2);\n\t\t\t} else if (r->type != Node_var_array) {\n\t\t\t\tt2 = force_string(t2);\n\t\t\t\tfatal(_(\"attempt to use scalar `%s[\\\"%.*s\\\"]' as an array\"),\n\t\t\t\t\t\tarray_vname(t1), (int) t2->stlen, t2->stptr);\n\t\t\t}\n\n\t\t\tDEREF(t2);\n\t\t\tPUSH(r);\n\t\t\tbreak;\n\n\t\tcase Op_subscript_lhs:\n\t\t\tt2 = mk_sub(pc->sub_count);\n\t\t\tt1 = POP_ARRAY();\n\t\t\tif (do_lint && in_array(t1, t2) == NULL) {\n\t\t\t\tt2 = force_string(t2);\n\t\t\t\tif (pc->do_reference)\n\t\t\t\t\tlintwarn(_(\"reference to uninitialized element `%s[\\\"%.*s\\\"]'\"),\n\t\t\t\t\t\tarray_vname(t1), (int) t2->stlen, t2->stptr);\n\t\t\t\tif (t2->stlen == 0)\n\t\t\t\t\tlintwarn(_(\"subscript of array `%s' is null string\"), array_vname(t1));\n\t\t\t}\n\n\t\t\tlhs = assoc_lookup(t1, t2);\n\t\t\tif ((*lhs)->type == Node_var_array) {\n\t\t\t\tt2 = force_string(t2);\n\t\t\t\tfatal(_(\"attempt to use array `%s[\\\"%.*s\\\"]' in a scalar context\"),\n\t\t\t\t\t\tarray_vname(t1), (int) t2->stlen, t2->stptr);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Changing something in FUNCTAB is not allowed.\n\t\t\t *\n\t\t\t * SYMTAB is a little more messy.  Three kinds of values may\n\t\t\t * be stored in SYMTAB:\n\t\t\t * \t1. Variables that don\"t yet have a value (Node_var_new)\n\t\t\t * \t2. Variables that have a value (Node_var)\n\t\t\t * \t3. Values that awk code stuck into SYMTAB not related to variables (Node_value)\n\t\t\t * For 1, since we are giving it a value, we have to change the type to Node_var.\n\t\t\t * For 1 and 2, we have to step through the Node_var to get to the value.\n\t\t\t * For 3, we just us the value we got from assoc_lookup(), above.\n\t\t\t */\n\t\t\tif (t1 == func_table)\n\t\t\t\tfatal(_(\"cannot assign to elements of FUNCTAB\"));\n\t\t\telse if (   t1 == symbol_table\n\t\t\t\t && (   (*lhs)->type == Node_var\n\t\t\t\t     || (*lhs)->type == Node_var_new)) {\n\t\t\t\tupdate_global_values();\t\t/* make sure stuff like NF, NR, are up to date */\n\t\t\t\t(*lhs)->type = Node_var;\t/* in case was Node_var_new */\n\t\t\t\tlhs = & ((*lhs)->var_value);\t/* extra level of indirection */\n\t\t\t}\n\n\t\t\tassert(set_idx == NULL);\n\n\t\t\tif (t1->astore) {\n\t\t\t\t/* array has post-assignment routine */\n\t\t\t\tset_array = t1;\n\t\t\t\tset_idx = t2;\n\t\t\t} else\n\t\t\t\tDEREF(t2);\n\n\t\t\tPUSH_ADDRESS(lhs);\n\t\t\tbreak;\n\n\t\tcase Op_field_spec:\n\t\t\tt1 = TOP_SCALAR();\n\t\t\tlhs = r_get_field(t1, (Func_ptr *) 0, true);\n\t\t\tdecr_sp();\n\t\t\tDEREF(t1);\n\t\t\tr = *lhs;\n\t\t\tUPREF(r);\n\t\t\tPUSH(r);\n\t\t\tbreak;\n\n\t\tcase Op_field_spec_lhs:\n\t\t\tt1 = TOP_SCALAR();\n\t\t\tlhs = r_get_field(t1, &pc->target_assign->field_assign, pc->do_reference);\n\t\t\tdecr_sp();\n\t\t\tDEREF(t1);\n\t\t\tPUSH_ADDRESS(lhs);\n\t\t\tbreak;\n\n\t\tcase Op_lint:\n\t\t\tif (do_lint) {\n\t\t\t\tswitch (pc->lint_type) {\n\t\t\t\tcase LINT_assign_in_cond:\n\t\t\t\t\tlintwarn(_(\"assignment used in conditional context\"));\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase LINT_no_effect:\n\t\t\t\t\tlintwarn(_(\"statement has no effect\"));\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tcant_happen();\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase Op_K_break:\n\t\tcase Op_K_continue:\n\t\tcase Op_jmp:\n\t\t\tassert(pc->target_jmp != NULL);\n\t\t\tJUMPTO(pc->target_jmp);\n\n\t\tcase Op_jmp_false:\n\t\t\tr = POP_SCALAR();\n\t\t\tdi = eval_condition(r);\n\t\t\tDEREF(r);\n\t\t\tif (! di)\n\t\t\t\tJUMPTO(pc->target_jmp);\n\t\t\tbreak;\n\n\t\tcase Op_jmp_true:\n\t\t\tr = POP_SCALAR();\n\t\t\tdi = eval_condition(r);\n\t\t\tDEREF(r);\n\t\t\tif (di)\n\t\t\t\tJUMPTO(pc->target_jmp);\n\t\t\tbreak;\n\n\t\tcase Op_and:\n\t\tcase Op_or:\n\t\t\tt1 = POP_SCALAR();\n\t\t\tdi = eval_condition(t1);\n\t\t\tDEREF(t1);\n\t\t\tif ((op == Op_and && di) || (op == Op_or && ! di))\n\t\t\t\tbreak;\n\t\t\tr = node_Boolean[di];\n\t\t\tUPREF(r);\n\t\t\tPUSH(r);\n\t\t\tni = pc->target_jmp;\n\t\t\tJUMPTO(ni->nexti);\n\n\t\tcase Op_and_final:\n\t\tcase Op_or_final:\n\t\t\tt1 = TOP_SCALAR();\n\t\t\tr = node_Boolean[eval_condition(t1)];\n\t\t\tDEREF(t1);\n\t\t\tUPREF(r);\n\t\t\tREPLACE(r);\n\t\t\tbreak;\n\n\t\tcase Op_not:\n\t\t\tt1 = TOP_SCALAR();\n\t\t\tr = node_Boolean[! eval_condition(t1)];\n\t\t\tDEREF(t1);\n\t\t\tUPREF(r);\n\t\t\tREPLACE(r);\n\t\t\tbreak;\n\n\t\tcase Op_equal:\n\t\t\tr = node_Boolean[cmp_scalars(SCALAR_EQ_NEQ) == 0];\n\t\t\tUPREF(r);\n\t\t\tREPLACE(r);\n\t\t\tbreak;\n\n\t\tcase Op_notequal:\n\t\t\tr = node_Boolean[cmp_scalars(SCALAR_EQ_NEQ) != 0];\n\t\t\tUPREF(r);\n\t\t\tREPLACE(r);\n\t\t\tbreak;\n\n\t\tcase Op_less:\n\t\t\tr = node_Boolean[cmp_scalars(SCALAR_RELATIONAL) < 0];\n\t\t\tUPREF(r);\n\t\t\tREPLACE(r);\n\t\t\tbreak;\n\n\t\tcase Op_greater:\n\t\t\tr = node_Boolean[cmp_scalars(SCALAR_RELATIONAL) > 0];\n\t\t\tUPREF(r);\n\t\t\tREPLACE(r);\n\t\t\tbreak;\n\n\t\tcase Op_leq:\n\t\t\tr = node_Boolean[cmp_scalars(SCALAR_RELATIONAL) <= 0];\n\t\t\tUPREF(r);\n\t\t\tREPLACE(r);\n\t\t\tbreak;\n\n\t\tcase Op_geq:\n\t\t\tr = node_Boolean[cmp_scalars(SCALAR_RELATIONAL) >= 0];\n\t\t\tUPREF(r);\n\t\t\tREPLACE(r);\n\t\t\tbreak;\n\n\t\tcase Op_plus_i:\n\t\t\tx2 = force_number(pc->memory)->numbr;\n\t\t\tgoto plus;\n\t\tcase Op_plus:\n\t\t\tt2 = POP_NUMBER();\n\t\t\tx2 = t2->numbr;\n\t\t\tDEREF(t2);\nplus:\n\t\t\tt1 = TOP_NUMBER();\n\t\t\tr = make_number(t1->numbr + x2);\n\t\t\tDEREF(t1);\n\t\t\tREPLACE(r);\n\t\t\tbreak;\n\n\t\tcase Op_minus_i:\n\t\t\tx2 = force_number(pc->memory)->numbr;\n\t\t\tgoto minus;\n\t\tcase Op_minus:\n\t\t\tt2 = POP_NUMBER();\n\t\t\tx2 = t2->numbr;\n\t\t\tDEREF(t2);\nminus:\n\t\t\tt1 = TOP_NUMBER();\n\t\t\tr = make_number(t1->numbr - x2);\n\t\t\tDEREF(t1);\n\t\t\tREPLACE(r);\n\t\t\tbreak;\n\n\t\tcase Op_times_i:\n\t\t\tx2 = force_number(pc->memory)->numbr;\n\t\t\tgoto times;\n\t\tcase Op_times:\n\t\t\tt2 = POP_NUMBER();\n\t\t\tx2 = t2->numbr;\n\t\t\tDEREF(t2);\ntimes:\n\t\t\tt1 = TOP_NUMBER();\n\t\t\tr = make_number(t1->numbr * x2);\n\t\t\tDEREF(t1);\n\t\t\tREPLACE(r);\n\t\t\tbreak;\n\n\t\tcase Op_exp_i:\n\t\t\tx2 = force_number(pc->memory)->numbr;\n\t\t\tgoto exp;\n\t\tcase Op_exp:\n\t\t\tt2 = POP_NUMBER();\n\t\t\tx2 = t2->numbr;\n\t\t\tDEREF(t2);\nexp:\n\t\t\tt1 = TOP_NUMBER();\n\t\t\tr = make_number(calc_exp(t1->numbr, x2));\n\t\t\tDEREF(t1);\n\t\t\tREPLACE(r);\n\t\t\tbreak;\n\n\t\tcase Op_quotient_i:\n\t\t\tx2 = force_number(pc->memory)->numbr;\n\t\t\tgoto quotient;\n\t\tcase Op_quotient:\n\t\t\tt2 = POP_NUMBER();\n\t\t\tx2 = t2->numbr;\n\t\t\tDEREF(t2);\nquotient:\n\t\t\tt1 = TOP_NUMBER();\n\t\t\tif (x2 == 0)\n\t\t\t\tfatal(_(\"division by zero attempted\"));\n\t\t\tr = make_number(t1->numbr / x2);\n\t\t\tDEREF(t1);\n\t\t\tREPLACE(r);\n\t\t\tbreak;\n\n\t\tcase Op_mod_i:\n\t\t\tx2 = force_number(pc->memory)->numbr;\n\t\t\tgoto mod;\n\t\tcase Op_mod:\n\t\t\tt2 = POP_NUMBER();\n\t\t\tx2 = t2->numbr;\n\t\t\tDEREF(t2);\nmod:\n\t\t\tt1 = TOP_NUMBER();\n\t\t\tif (x2 == 0)\n\t\t\t\tfatal(_(\"division by zero attempted in `%%'\"));\n#ifdef HAVE_FMOD\n\t\t\tx = fmod(t1->numbr, x2);\n#else\t/* ! HAVE_FMOD */\n\t\t\t(void) modf(t1->numbr / x2, &x);\n\t\t\tx = t1->numbr - x * x2;\n#endif\t/* ! HAVE_FMOD */\n\t\t\tr = make_number(x);\n\n\t\t\tDEREF(t1);\n\t\t\tREPLACE(r);\n\t\t\tbreak;\n\n\t\tcase Op_preincrement:\n\t\tcase Op_predecrement:\n\t\t\tx = op == Op_preincrement ? 1.0 : -1.0;\n\t\t\tlhs = TOP_ADDRESS();\n\t\t\tt1 = *lhs;\n\t\t\tforce_number(t1);\n\t\t\tif (t1->valref == 1 && t1->flags == (MALLOC|NUMCUR|NUMBER)) {\n\t\t\t\t/* optimization */\n\t\t\t\tt1->numbr += x;\n\t\t\t\tr = t1;\n\t\t\t} else {\n\t\t\t\tr = *lhs = make_number(t1->numbr + x);\n\t\t\t\tunref(t1);\n\t\t\t}\n\t\t\tUPREF(r);\n\t\t\tREPLACE(r);\n\t\t\tbreak;\n\n\t\tcase Op_postincrement:\n\t\tcase Op_postdecrement:\n\t\t\tx = op == Op_postincrement ? 1.0 : -1.0;\n\t\t\tlhs = TOP_ADDRESS();\n\t\t\tt1 = *lhs;\n\t\t\tforce_number(t1);\n\t\t\tr = make_number(t1->numbr);\n\t\t\tif (t1->valref == 1 && t1->flags == (MALLOC|NUMCUR|NUMBER)) {\n \t\t\t\t/* optimization */\n\t\t\t\tt1->numbr += x;\n\t\t\t} else {\n\t\t\t\t*lhs = make_number(t1->numbr + x);\n\t\t\t\tunref(t1);\n\t\t\t}\n\t\t\tREPLACE(r);\n\t\t\tbreak;\n\n\t\tcase Op_unary_minus:\n\t\t\tt1 = TOP_NUMBER();\n\t\t\tr = make_number(-t1->numbr);\n\t\t\tDEREF(t1);\n\t\t\tREPLACE(r);\n\t\t\tbreak;\n\n\t\tcase Op_unary_plus:\n\t\t\t// Force argument to be numeric\n\t\t\tt1 = TOP_NUMBER();\n\t\t\tr = make_number(t1->numbr);\n\t\t\tDEREF(t1);\n\t\t\tREPLACE(r);\n\t\t\tbreak;\n\n\t\tcase Op_store_sub:\n\t\t\t/*\n\t\t\t * array[sub] assignment optimization,\n\t\t\t * see awkgram.y (optimize_assignment)\n\t\t\t */\n\t\t\tt1 = force_array(pc->memory, true);\t/* array */\n\t\t\tt2 = mk_sub(pc->expr_count);\t/* subscript */\n \t\t\tlhs = assoc_lookup(t1, t2);\n\t\t\tif ((*lhs)->type == Node_var_array) {\n\t\t\t\tt2 = force_string(t2);\n\t\t\t\tfatal(_(\"attempt to use array `%s[\\\"%.*s\\\"]' in a scalar context\"),\n\t\t\t\t\t\tarray_vname(t1), (int) t2->stlen, t2->stptr);\n\t\t\t}\n\t\t\tDEREF(t2);\n\n\t\t\t/*\n\t\t\t * Changing something in FUNCTAB is not allowed.\n\t\t\t *\n\t\t\t * SYMTAB is a little more messy.  Three kinds of values may\n\t\t\t * be stored in SYMTAB:\n\t\t\t * \t1. Variables that don\"t yet have a value (Node_var_new)\n\t\t\t * \t2. Variables that have a value (Node_var)\n\t\t\t * \t3. Values that awk code stuck into SYMTAB not related to variables (Node_value)\n\t\t\t * For 1, since we are giving it a value, we have to change the type to Node_var.\n\t\t\t * For 1 and 2, we have to step through the Node_var to get to the value.\n\t\t\t * For 3, we just us the value we got from assoc_lookup(), above.\n\t\t\t */\n\t\t\tif (t1 == func_table)\n\t\t\t\tfatal(_(\"cannot assign to elements of FUNCTAB\"));\n\t\t\telse if (   t1 == symbol_table\n\t\t\t\t && (   (*lhs)->type == Node_var\n\t\t\t\t     || (*lhs)->type == Node_var_new)) {\n\t\t\t\t(*lhs)->type = Node_var;\t/* in case was Node_var_new */\n\t\t\t\tlhs = & ((*lhs)->var_value);\t/* extra level of indirection */\n\t\t\t}\n\n\t\t\tunref(*lhs);\n\t\t\tr = POP_SCALAR();\n\t\t\tUNFIELD(*lhs, r);\n\n\t\t\t/* execute post-assignment routine if any */\n\t\t\tif (t1->astore != NULL)\n\t\t\t\t(*t1->astore)(t1, t2);\n\n\t\t\tDEREF(t2);\n\t\t\tbreak;\n\n\t\tcase Op_store_var:\n\t\t\t/*\n\t\t\t * simple variable assignment optimization,\n\t\t\t * see awkgram.y (optimize_assignment)\n\t\t\t */\n\n\t\t\tlhs = get_lhs(pc->memory, false);\n\t\t\tunref(*lhs);\n\t\t\tr = pc->initval;\t/* constant initializer */\n\t\t\tif (r != NULL) {\n\t\t\t\tUPREF(r);\n\t\t\t\t*lhs = r;\n\t\t\t} else {\n\t\t\t\tr = POP_SCALAR();\n\t\t\t\tUNFIELD(*lhs, r);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase Op_store_field:\n\t\t{\n\t\t\t/* field assignment optimization,\n\t\t\t * see awkgram.y (optimize_assignment)\n\t\t\t */\n\n\t\t\tFunc_ptr assign;\n\t\t\tt1 = TOP_SCALAR();\n\t\t\tlhs = r_get_field(t1, & assign, false);\n\t\t\tdecr_sp();\n\t\t\tDEREF(t1);\n\t\t\t/*\n\t\t\t * N.B. We must call assign() before unref, since\n\t\t\t * we may need to copy $n values before freeing the\n\t\t\t * $0 buffer.\n\t\t\t */\n\t\t\tassert(assign != NULL);\n\t\t\tassign();\n\t\t\tunref(*lhs);\n\t\t\tr = POP_SCALAR();\n\t\t\tUNFIELD(*lhs, r);\n\t\t}\n\t\t\tbreak;\n\n\t\tcase Op_assign_concat:\n\t\t\t/* x = x ... string concatenation optimization */\n\t\t\tlhs = get_lhs(pc->memory, false);\n\t\t\tt1 = force_string(*lhs);\n\t\t\tt2 = POP_STRING();\n\n\t\t\tif (t1 != *lhs) {\n\t\t\t\tunref(*lhs);\n\t\t\t\t*lhs = dupnode(t1);\n\t\t\t}\n\n\t\t\tif (t1 != t2 && t1->valref == 1 && (t1->flags & (MALLOC|MPFN|MPZN)) == MALLOC) {\n\t\t\t\tsize_t nlen = t1->stlen + t2->stlen;\n\n\t\t\t\terealloc(t1->stptr, char *, nlen + 1, \"r_interpret\");\n\t\t\t\tmemcpy(t1->stptr + t1->stlen, t2->stptr, t2->stlen);\n\t\t\t\tt1->stlen = nlen;\n\t\t\t\tt1->stptr[nlen] = '\\0';\n\t\t\t\t/* clear flags except WSTRCUR (used below) */\n\t\t\t\tt1->flags &= WSTRCUR;\n\t\t\t\t/* configure as a string as in make_str_node */\n\t\t\t\tt1->flags |= (MALLOC|STRING|STRCUR);\n\t\t\t\tt1->stfmt = STFMT_UNUSED;\n#ifdef HAVE_MPFR\n\t\t\t\tt1->strndmode = MPFR_round_mode;\n#endif\n\n\t\t\t\tif ((t1->flags & WSTRCUR) != 0 && (t2->flags & WSTRCUR) != 0) {\n\t\t\t\t\tsize_t wlen = t1->wstlen + t2->wstlen;\n\n\t\t\t\t\terealloc(t1->wstptr, wchar_t *,\n\t\t\t\t\t\t\tsizeof(wchar_t) * (wlen + 1), \"r_interpret\");\n\t\t\t\t\tmemcpy(t1->wstptr + t1->wstlen, t2->wstptr, t2->wstlen * sizeof(wchar_t));\n\t\t\t\t\tt1->wstlen = wlen;\n\t\t\t\t\tt1->wstptr[wlen] = L'\\0';\n\t\t\t\t} else\n\t\t\t\t\tfree_wstr(*lhs);\n\t\t\t} else {\n\t\t\t\tsize_t nlen = t1->stlen + t2->stlen;\n\t\t\t\tchar *p;\n\n\t\t\t\temalloc(p, char *, nlen + 1, \"r_interpret\");\n\t\t\t\tmemcpy(p, t1->stptr, t1->stlen);\n\t\t\t\tmemcpy(p + t1->stlen, t2->stptr, t2->stlen);\n\t\t\t\t/* N.B. No NUL-termination required, since make_str_node will do it. */\n\t\t\t\tunref(*lhs);\n\t\t\t\tt1 = *lhs = make_str_node(p, nlen, ALREADY_MALLOCED);\n\t\t\t}\n\t\t\tDEREF(t2);\n\t\t\tbreak;\n\n\t\tcase Op_assign:\n\t\t\tlhs = POP_ADDRESS();\n\t\t\tr = TOP_SCALAR();\n\t\t\tunref(*lhs);\n\t\t\tUPREF(r);\n\t\t\tUNFIELD(*lhs, r);\n\t\t\tREPLACE(r);\n\t\t\tbreak;\n\n\t\tcase Op_subscript_assign:\n\t\t\t/* conditionally execute post-assignment routine for an array element */\n\n\t\t\tif (set_idx != NULL) {\n\t\t\t\tdi = true;\n\t\t\t\tif (pc->assign_ctxt == Op_sub_builtin\n\t\t\t\t\t&& (r = TOP())\n\t\t\t\t\t&& get_number_si(r) == 0\t/* no substitution performed */\n\t\t\t\t)\n\t\t\t\t\tdi = false;\n\t\t\t\telse if ((pc->assign_ctxt == Op_K_getline\n\t\t\t\t\t\t|| pc->assign_ctxt == Op_K_getline_redir)\n\t\t\t\t\t&& (r = TOP())\n\t\t\t\t\t&& get_number_si(r) <= 0 \t/* EOF or error */\n\t\t\t\t)\n\t\t\t\t\tdi = false;\n\n\t\t\t\tif (di)\n\t\t\t\t\t(*set_array->astore)(set_array, set_idx);\n\t\t\t\tunref(set_idx);\n\t\t\t\tset_idx = NULL;\n\t\t\t}\n\t\t\tbreak;\n\n\t\t/* numeric assignments */\n\t\tcase Op_assign_plus:\n\t\tcase Op_assign_minus:\n\t\tcase Op_assign_times:\n\t\tcase Op_assign_quotient:\n\t\tcase Op_assign_mod:\n\t\tcase Op_assign_exp:\n\t\t\top_assign(op);\n\t\t\tbreak;\n\n\t\tcase Op_var_update:        /* update value of NR, FNR or NF */\n\t\t\tpc->update_var();\n\t\t\tbreak;\n\n\t\tcase Op_var_assign:\n\t\tcase Op_field_assign:\n\t\t\tr = TOP();\n\t\t\tif (pc->assign_ctxt == Op_sub_builtin\n\t\t\t\t&& get_number_si(r) == 0\t/* top of stack has a number == 0 */\n\t\t\t) {\n\t\t\t\t/* There wasn't any substitutions. If the target is a FIELD,\n\t\t\t\t * this means no field re-splitting or $0 reconstruction.\n\t\t\t\t * Skip the set_FOO routine if the target is a special variable.\n\t\t\t\t */\n\n\t\t\t\tbreak;\n\t\t\t} else if ((pc->assign_ctxt == Op_K_getline\n\t\t\t\t\t|| pc->assign_ctxt == Op_K_getline_redir)\n\t\t\t\t&& get_number_si(r) <= 0 \t/* top of stack has a number <= 0 */\n\t\t\t) {\n\t\t\t\t/* getline returned EOF or error */\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (op == Op_var_assign)\n\t\t\t\tpc->assign_var();\n\t\t\telse\n\t\t\t\tpc->field_assign();\n\t\t\tbreak;\n\n\t\tcase Op_concat:\n\t\t\tr = concat_exp(pc->expr_count, pc->concat_flag & CSUBSEP);\n\t\t\tPUSH(r);\n\t\t\tbreak;\n\n\t\tcase Op_K_case:\n\t\t\tif ((pc + 1)->match_exp) {\n\t\t\t\t/* match a constant regex against switch expression instead of $0. */\n\n\t\t\t\tm = POP();\t/* regex */\n\t\t\t\tt2 = TOP_SCALAR();\t/* switch expression */\n\t\t\t\tt2 = force_string(t2);\n\t\t\t\trp = re_update(m);\n\t\t\t\tdi = (research(rp, t2->stptr, 0, t2->stlen, RE_NO_FLAGS) >= 0);\n\t\t\t} else {\n\t\t\t\tt1 = POP_SCALAR();\t/* case value */\n\t\t\t\tt2 = TOP_SCALAR();\t/* switch expression */\n\t\t\t\tdi = (cmp_nodes(t2, t1, true) == 0);\n\t\t\t\tDEREF(t1);\n\t\t\t}\n\n\t\t\tif (di) {\n\t\t\t\t/* match found */\n\t\t\t\tt2 = POP_SCALAR();\n\t\t\t\tDEREF(t2);\n\t\t\t\tJUMPTO(pc->target_jmp);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase Op_K_delete:\n\t\t\tt1 = POP_ARRAY();\n\t\t\tdo_delete(t1, pc->expr_count);\n\t\t\tstack_adj(-pc->expr_count);\n\t\t\tbreak;\n\n\t\tcase Op_K_delete_loop:\n\t\t\tt1 = POP_ARRAY();\n\t\t\tlhs = POP_ADDRESS();\t/* item */\n\t\t\tdo_delete_loop(t1, lhs);\n\t\t\tbreak;\n\n\t\tcase Op_in_array:\n\t\t\tt1 = POP_ARRAY();\n\t\t\tt2 = mk_sub(pc->expr_count);\n\t\t\tr = node_Boolean[(in_array(t1, t2) != NULL)];\n\t\t\tDEREF(t2);\n\t\t\tUPREF(r);\n\t\t\tPUSH(r);\n\t\t\tbreak;\n\n\t\tcase Op_arrayfor_init:\n\t\t{\n\t\t\tNODE **list = NULL;\n\t\t\tNODE *array, *sort_str;\n\t\t\tsize_t num_elems = 0;\n\t\t\tstatic NODE *sorted_in = NULL;\n\t\t\tconst char *how_to_sort = \"@unsorted\";\n\t\t\tchar save;\n\t\t\tbool saved_end = false;\n\n\t\t\t/* get the array */\n\t\t\tarray = POP_ARRAY();\n\n\t\t\t/* sanity: check if empty */\n\t\t\tnum_elems = assoc_length(array);\n\t\t\tif (num_elems == 0)\n\t\t\t\tgoto arrayfor;\n\n\t\t\tif (sorted_in == NULL)\t\t/* do this once */\n\t\t\t\tsorted_in = make_string(\"sorted_in\", 9);\n\n\t\t\tsort_str = NULL;\n\t\t\t/*\n\t\t\t * If posix, or if there's no PROCINFO[],\n\t\t\t * there's no [\"sorted_in\"], so no sorting\n\t\t\t */\n\t\t\tif (! do_posix && PROCINFO_node != NULL)\n\t\t\t\tsort_str = in_array(PROCINFO_node, sorted_in);\n\n\t\t\tif (sort_str != NULL) {\n\t\t\t\tsort_str = force_string(sort_str);\n\t\t\t\tif (sort_str->stlen > 0) {\n\t\t\t\t\thow_to_sort = sort_str->stptr;\n\t\t\t\t\tstr_terminate(sort_str, save);\n\t\t\t\t\tsaved_end = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlist = assoc_list(array, how_to_sort, SORTED_IN);\n\t\t\tif (saved_end)\n\t\t\t\tstr_restore(sort_str, save);\n\narrayfor:\n\t\t\tgetnode(r);\n\t\t\tr->type = Node_arrayfor;\n\t\t\tr->for_list = list;\n\t\t\tr->for_list_size = num_elems;\t\t/* # of elements in list */\n\t\t\tr->cur_idx = -1;\t\t\t/* current index */\n\t\t\tr->for_array = array;\t\t/* array */\n\t\t\tPUSH(r);\n\n\t\t\tif (num_elems == 0)\n\t\t\t\tJUMPTO(pc->target_jmp);   /* Op_arrayfor_final */\n\t\t}\n\t\t\tbreak;\n\n\t\tcase Op_arrayfor_incr:\n\t\t\tr = TOP();\t/* Node_arrayfor */\n\t\t\tif (++r->cur_idx == r->for_list_size) {\n\t\t\t\tNODE *array;\n\t\t\t\tarray = r->for_array;\t/* actual array */\n\t\t\t\tif (do_lint && array->table_size != r->for_list_size)\n\t\t\t\t\tlintwarn(_(\"for loop: array `%s' changed size from %ld to %ld during loop execution\"),\n\t\t\t\t\t\tarray_vname(array), (long) r->for_list_size, (long) array->table_size);\n\t\t\t\tJUMPTO(pc->target_jmp);\t/* Op_arrayfor_final */\n\t\t\t}\n\n\t\t\tt1 = r->for_list[r->cur_idx];\n\t\t\tlhs = get_lhs(pc->array_var, false);\n\t\t\tunref(*lhs);\n\t\t\t*lhs = dupnode(t1);\n\t\t\tbreak;\n\n\t\tcase Op_arrayfor_final:\n\t\t\tr = POP();\n\t\t\tassert(r->type == Node_arrayfor);\n\t\t\tfree_arrayfor(r);\n\t\t\tbreak;\n\n\t\tcase Op_builtin:\n\t\t\tr = pc->builtin(pc->expr_count);\n\t\t\tPUSH(r);\n\t\t\tbreak;\n\n\t\tcase Op_ext_builtin:\n\t\t{\n\t\t\tsize_t arg_count = pc->expr_count;\n\t\t\tawk_ext_func_t *f = pc[1].c_function;\n\t\t\tsize_t min_req = f->min_required_args;\n\t\t\tsize_t max_expect = f->max_expected_args;\n\t\t\tawk_value_t result;\n\n\t\t\tif (arg_count < min_req)\n\t\t\t\tfatal(_(\"%s: called with %lu arguments, expecting at least %lu\"),\n\t\t\t\t\t\tpc[1].func_name,\n\t\t\t\t\t\t(unsigned long) arg_count,\n\t\t\t\t\t\t(unsigned long) min_req);\n\n\t\t\tif (do_lint && ! f->suppress_lint && arg_count > max_expect)\n\t\t\t\tlintwarn(_(\"%s: called with %lu arguments, expecting no more than %lu\"),\n\t\t\t\t\t\tpc[1].func_name,\n\t\t\t\t\t\t(unsigned long) arg_count,\n\t\t\t\t\t\t(unsigned long) max_expect);\n\n\t\t\tPUSH_CODE(pc);\n\t\t\tr = awk_value_to_node(pc->extfunc(arg_count, & result, f));\n\t\t\t(void) POP_CODE();\n\t\t\twhile (arg_count-- > 0) {\n\t\t\t\tt1 = POP();\n\t\t\t\tif (t1->type == Node_val)\n\t\t\t\t\tDEREF(t1);\n\t\t\t}\n\t\t\tfree_api_string_copies();\n\t\t\tPUSH(r);\n\t\t}\n\t\t\tbreak;\n\n\t\tcase Op_sub_builtin:\t/* sub, gsub and gensub */\n\t\t\tr = do_sub(pc->expr_count, pc->sub_flags);\n\t\t\tPUSH(r);\n\t\t\tbreak;\n\n\t\tcase Op_K_print:\n\t\t\tdo_print(pc->expr_count, pc->redir_type);\n\t\t\tbreak;\n\n\t\tcase Op_K_printf:\n\t\t\tdo_printf(pc->expr_count, pc->redir_type);\n\t\t\tbreak;\n\n\t\tcase Op_K_print_rec:\n\t\t\tdo_print_rec(pc->expr_count, pc->redir_type);\n\t\t\tbreak;\n\n\t\tcase Op_push_re:\n\t\t\tm = pc->memory;\n\t\t\tif (m->type == Node_dynregex) {\n\t\t\t\tr = POP_STRING();\n\t\t\t\tunref(m->re_exp);\n\t\t\t\tm->re_exp = r;\n\t\t\t} else if (m->type == Node_val) {\n\t\t\t\tassert((m->flags & REGEX) != 0);\n\t\t\t\tUPREF(m);\n\t\t\t}\n\t\t\tPUSH(m);\n\t\t\tbreak;\n\n\t\tcase Op_match_rec:\n\t\t\tm = pc->memory;\n\t\t\tt1 = *get_field(0, (Func_ptr *) 0);\nmatch_re:\n\t\t\trp = re_update(m);\n\t\t\tdi = research(rp, t1->stptr, 0, t1->stlen, RE_NO_FLAGS);\n\t\t\tdi = (di == -1) ^ (op != Op_nomatch);\n\t\t\tif (op != Op_match_rec) {\n\t\t\t\tdecr_sp();\n\t\t\t\tDEREF(t1);\n\t\t\t}\n\t\t\tr = node_Boolean[di];\n\t\t\tUPREF(r);\n\t\t\tPUSH(r);\n\t\t\tbreak;\n\n\t\tcase Op_nomatch:\n\t\t\t/* fall through */\n\t\tcase Op_match:\n\t\t\tm = pc->memory;\n\t\t\tt1 = TOP_STRING();\n\t\t\tif (m->type == Node_dynregex) {\n\t\t\t\tunref(m->re_exp);\n\t\t\t\tm->re_exp = t1;\n\t\t\t\tdecr_sp();\n\t\t\t\tt1 = TOP_STRING();\n\t\t\t}\n\t\t\tgoto match_re;\n\t\t\tbreak;\n\n\t\tcase Op_indirect_func_call:\n\t\t{\n\t\t\tNODE *f = NULL;\n\t\t\tint arg_count;\n\t\t\tchar save;\n\n\t\t\targ_count = (pc + 1)->expr_count;\n\t\t\tt1 = PEEK(arg_count);\t/* indirect var */\n\n\t\t\tif (t1->type != Node_val)\t/* @a[1](p) not allowed in grammar */\n\t\t\t\tfatal(_(\"indirect function call requires a simple scalar value\"));\n\n\t\t\tt1 = force_string(t1);\n\t\t\tstr_terminate(t1, save);\n\t\t\tif (t1->stlen > 0) {\n\t\t\t\t/* retrieve function definition node */\n\t\t\t\tf = pc->func_body;\n\t\t\t\tif (f != NULL && strcmp(f->vname, t1->stptr) == 0) {\n\t\t\t\t\t/* indirect var hasn't been reassigned */\n\n\t\t\t\t\tstr_restore(t1, save);\n\t\t\t\t\tni = setup_frame(pc);\n\t\t\t\t\tJUMPTO(ni);\t/* Op_func */\n\t\t\t\t}\n\t\t\t\tf = lookup(t1->stptr);\n\t\t\t}\n\n\t\t\tif (f == NULL) {\n\t\t\t\tfatal(_(\"`%s' is not a function, so it cannot be called indirectly\"),\n\t\t\t\t\t\tt1->stptr);\n\t\t\t} else if (f->type == Node_builtin_func) {\n\t\t\t\tint arg_count = (pc + 1)->expr_count;\n\t\t\t\tbuiltin_func_t the_func = lookup_builtin(t1->stptr);\n\n\t\t\t\tassert(the_func != NULL);\n\n\t\t\t\t/* call it */\n\t\t\t\tif (the_func == (builtin_func_t) do_sub)\n\t\t\t\t\tr = call_sub(t1->stptr, arg_count);\n\t\t\t\telse if (the_func == do_match)\n\t\t\t\t\tr = call_match(arg_count);\n\t\t\t\telse if (the_func == do_split || the_func == do_patsplit)\n\t\t\t\t\tr = call_split_func(t1->stptr, arg_count);\n\t\t\t\telse\n\t\t\t\t\tr = the_func(arg_count);\n\t\t\t\tstr_restore(t1, save);\n\n\t\t\t\tPUSH(r);\n\t\t\t\tbreak;\n\t\t\t} else if (f->type != Node_func) {\n\t\t\t\tstr_restore(t1, save);\n\t\t\t\tif (f->type == Node_ext_func) {\n\t\t\t\t\t/* code copied from below, keep in sync */\n\t\t\t\t\tINSTRUCTION *bc;\n\t\t\t\t\tchar *fname = pc->func_name;\n\t\t\t\t\tint arg_count = (pc + 1)->expr_count;\n\t\t\t\t\tstatic INSTRUCTION npc[2];\n\n\t\t\t\t\tnpc[0] = *pc;\n\n\t\t\t\t\tbc = f->code_ptr;\n\t\t\t\t\tassert(bc->opcode == Op_symbol);\n\t\t\t\t\tnpc[0].opcode = Op_ext_builtin;\t/* self modifying code */\n\t\t\t\t\tnpc[0].extfunc = bc->extfunc;\n\t\t\t\t\tnpc[0].expr_count = arg_count;\t\t/* actual argument count */\n\t\t\t\t\tnpc[1] = pc[1];\n\t\t\t\t\tnpc[1].func_name = fname;\t/* name of the builtin */\n\t\t\t\t\tnpc[1].c_function = bc->c_function;\n\t\t\t\t\tni = npc;\n\t\t\t\t\tJUMPTO(ni);\n\t\t\t\t} else\n\t\t\t\t\tfatal(_(\"function called indirectly through `%s' does not exist\"),\n\t\t\t\t\t\t\tpc->func_name);\n\t\t\t}\n\t\t\tpc->func_body = f;     /* save for next call */\n\t\t\tstr_restore(t1, save);\n\n\t\t\tni = setup_frame(pc);\n\t\t\tJUMPTO(ni);\t/* Op_func */\n\t\t}\n\n\t\tcase Op_func_call:\n\t\t{\n\t\t\tNODE *f;\n\n\t\t\t/* retrieve function definition node */\n\t\t\tf = pc->func_body;\n\t\t\tif (f == NULL) {\n\t\t\t\tf = lookup(pc->func_name);\n\t\t\t\tif (f == NULL || (f->type != Node_func && f->type != Node_ext_func))\n\t\t\t\t\tfatal(_(\"function `%s' not defined\"), pc->func_name);\n\t\t\t\tpc->func_body = f;     /* save for next call */\n\t\t\t}\n\n\t\t\tif (f->type == Node_ext_func) {\n\t\t\t\t/* keep in sync with indirect call code */\n\t\t\t\tINSTRUCTION *bc;\n\t\t\t\tchar *fname = pc->func_name;\n\t\t\t\tint arg_count = (pc + 1)->expr_count;\n\n\t\t\t\tbc = f->code_ptr;\n\t\t\t\tassert(bc->opcode == Op_symbol);\n\t\t\t\tpc->opcode = Op_ext_builtin;\t/* self modifying code */\n\t\t\t\tpc->extfunc = bc->extfunc;\n\t\t\t\tpc->expr_count = arg_count;\t/* actual argument count */\n\t\t\t\t(pc + 1)->func_name = fname;\t/* name of the builtin */\n\t\t\t\t(pc + 1)->c_function = bc->c_function;\t/* min and max args */\n\t\t\t\tni = pc;\n\t\t\t\tJUMPTO(ni);\n\t\t\t}\n\n\t\t\tni = setup_frame(pc);\n\t\t\tJUMPTO(ni);\t/* Op_func */\n\t\t}\n\n\t\tcase Op_K_return:\n\t\t\tm = POP_SCALAR();       /* return value */\n\n\t\t\tni = pop_fcall();\n\n\t\t\t/* put the return value back on stack */\n\t\t\tPUSH(m);\n\n\t\t\tJUMPTO(ni);\n\n\t\tcase Op_K_getline_redir:\n\t\t\tr = do_getline_redir(pc->into_var, pc->redir_type);\n\t\t\tPUSH(r);\n\t\t\tbreak;\n\n\t\tcase Op_K_getline:\t/* no redirection */\n\t\t\tif (! currule || currule == BEGINFILE || currule == ENDFILE)\n\t\t\t\tfatal(_(\"non-redirected `getline' invalid inside `%s' rule\"),\n\t\t\t\t\t\truletab[currule]);\n\n\t\t\tdo {\n\t\t\t\tint ret;\n\t\t\t\tret = nextfile(& curfile, false);\n\t\t\t\tif (ret <= 0)\n\t\t\t\t\tr = do_getline(pc->into_var, curfile);\n\t\t\t\telse {\n\n\t\t\t\t\t/* Save execution state so that we can return to it\n\t\t\t\t\t * from Op_after_beginfile or Op_after_endfile.\n\t\t\t\t\t */\n\n\t\t\t\t\tpush_exec_state(pc, currule, source, stack_ptr);\n\n\t\t\t\t\tif (curfile == NULL)\n\t\t\t\t\t\tJUMPTO((pc + 1)->target_endfile);\n\t\t\t\t\telse\n\t\t\t\t\t\tJUMPTO((pc + 1)->target_beginfile);\n\t\t\t\t}\n\t\t\t} while (r == NULL);\t/* EOF */\n\n\t\t\tPUSH(r);\n\t\t\tbreak;\n\n\t\tcase Op_after_endfile:\n\t\t\t/* Find the execution state to return to */\n\t\t\tni = pop_exec_state(& currule, & source, NULL);\n\n\t\t\tassert(ni->opcode == Op_newfile || ni->opcode == Op_K_getline);\n\t\t\tJUMPTO(ni);\n\n\t\tcase Op_after_beginfile:\n\t\t\tafter_beginfile(& curfile);\n\n\t\t\t/* Find the execution state to return to */\n\t\t\tni = pop_exec_state(& currule, & source, NULL);\n\n\t\t\tassert(ni->opcode == Op_newfile || ni->opcode == Op_K_getline);\n\t\t\tif (ni->opcode == Op_K_getline\n\t\t\t\t\t|| curfile == NULL      /* skipping directory argument */\n\t\t\t)\n\t\t\t\tJUMPTO(ni);\n\n\t\t\tbreak;\t/* read a record, Op_get_record */\n\n\t\tcase Op_newfile:\n\t\t{\n\t\t\tint ret;\n\n\t\t\tret = nextfile(& curfile, false);\n\n\t\t\tif (ret < 0)\t/* end of input */\n\t\t\t\tJUMPTO(pc->target_jmp);\t/* end block or Op_atexit */\n\n\t\t\tif (ret == 0) /* read a record */\n\t\t\t\tJUMPTO((pc + 1)->target_get_record);\n\n\t\t\t/* ret > 0 */\n\t\t\t/* Save execution state for use in Op_after_beginfile or Op_after_endfile. */\n\n\t\t\tpush_exec_state(pc, currule, source, stack_ptr);\n\n\t\t\tif (curfile == NULL)\t/* EOF */\n\t\t\t\tJUMPTO(pc->target_endfile);\n\t\t\t/* else\n\t\t\t\texecute beginfile block */\n\t\t}\n\t\t\tbreak;\n\n\t\tcase Op_get_record:\n\t\t{\n\t\t\tint errcode = 0;\n\n\t\t\tni = pc->target_newfile;\n\t\t\tif (curfile == NULL) {\n\t\t\t\t/* from non-redirected getline, e.g.:\n\t\t\t\t *  {\n\t\t\t\t *\t\twhile (getline > 0) ;\n\t\t\t\t *  }\n\t\t\t\t */\n\n\t\t\t\tni = ni->target_jmp;\t/* end_block or Op_atexit */\n\t\t\t\tJUMPTO(ni);\n\t\t\t}\n\n\t\t\tif (! inrec(curfile, & errcode)) {\n\t\t\t\tif (errcode > 0) {\n\t\t\t\t\tupdate_ERRNO_int(errcode);\n\t\t\t\t\tif (do_traditional || ! pc->has_endfile)\n\t\t\t\t\t\tfatal(_(\"error reading input file `%s': %s\"),\n\t\t\t\t\t\tcurfile->public.name, strerror(errcode));\n\t\t\t\t}\n\n\t\t\t\tJUMPTO(ni);\n\t\t\t} /* else\n\t\t\t\tprog (rule) block */\n\t\t}\n\t\t\tbreak;\n\n\t\tcase Op_K_nextfile:\n\t\t{\n\t\t\tint ret;\n\n\t\t\tif (currule != Rule && currule != BEGINFILE)\n\t\t\t\tfatal(_(\"`nextfile' cannot be called from a `%s' rule\"),\n\t\t\t\t\truletab[currule]);\n\n\t\t\tret = nextfile(& curfile, true);\t/* skip current file */\n\n\t\t\tif (currule == BEGINFILE) {\n\t\t\t\tlong stack_size = 0;\n\n\t\t\t\tni = pop_exec_state(& currule, & source, & stack_size);\n\n\t\t\t\tassert(ni->opcode == Op_K_getline || ni->opcode == Op_newfile);\n\n\t\t\t\t/* pop stack returning to the state of Op_K_getline or Op_newfile. */\n\t\t\t\tunwind_stack(stack_size);\n\n\t\t\t\tif (ret == 0) {\n\t\t\t\t\t/* There was an error opening the file;\n\t\t\t\t\t * don't run ENDFILE block(s).\n\t\t\t\t\t */\n\n\t\t\t\t\tJUMPTO(ni);\n\t\t\t\t} else {\n\t\t\t\t\t/* do run ENDFILE block(s) first. */\n\n\t\t\t\t\t/* Execution state to return to in Op_after_endfile. */\n\t\t\t\t\tpush_exec_state(ni, currule, source, stack_ptr);\n\n\t\t\t\t\tJUMPTO(pc->target_endfile);\n\t\t\t\t}\n\t\t\t} /* else\n\t\t\t\tStart over with the first rule. */\n\n\t\t\t/* empty the run-time stack to avoid memory leak */\n\t\t\tpop_stack();\n\n\t\t\t/* Push an execution state for Op_after_endfile to return to */\n\t\t\tpush_exec_state(pc->target_newfile, currule, source, stack_ptr);\n\n\t\t\tJUMPTO(pc->target_endfile);\n\t\t}\n\t\t\tbreak;\n\n\t\tcase Op_K_exit:\n\t\t\t/* exit not allowed in user-defined comparison functions for \"sorted_in\";\n\t\t\t * This is done so that END blocks aren't executed more than once.\n\t\t\t */\n\t\t\tif (! currule)\n\t\t\t\tfatal(_(\"`exit' cannot be called in the current context\"));\n\n\t\t\texiting = true;\n\t\t\tif ((t1 = POP_NUMBER()) != Nnull_string) {\n\t\t\t\texit_val = (int) get_number_si(t1);\n#ifdef VMS\n\t\t\t\tif (exit_val == 0)\n\t\t\t\t\texit_val = EXIT_SUCCESS;\n\t\t\t\telse if (exit_val == 1)\n\t\t\t\t\texit_val = EXIT_FAILURE;\n\t\t\t\t/* else\n\t\t\t\t\tjust pass anything else on through */\n#endif\n\t\t\t}\n\t\t\tDEREF(t1);\n\n\t\t\tif (currule == BEGINFILE || currule == ENDFILE) {\n\n\t\t\t\t/* Find the rule of the saved execution state (Op_K_getline/Op_newfile).\n\t\t\t\t * This is needed to prevent multiple execution of any END rules:\n\t\t\t\t * \tgawk 'BEGINFILE { exit(1) } \\\n\t\t\t\t *         END { while (getline > 0); }' in1 in2\n\t\t\t\t */\n\n\t\t\t\t(void) pop_exec_state(& currule, & source, NULL);\n\t\t\t}\n\n\t\t\tpop_stack();\t/* empty stack, don't leak memory */\n\n\t\t\t/* Jump to either the first END block instruction\n\t\t\t * or to Op_atexit.\n\t\t\t */\n\n\t\t\tif (currule == END)\n\t\t\t\tni = pc->target_atexit;\n\t\t\telse\n\t\t\t\tni = pc->target_end;\n\t\t\tJUMPTO(ni);\n\n\t\tcase Op_K_next:\n\t\t\tif (currule != Rule)\n\t\t\t\tfatal(_(\"`next' cannot be called from a `%s' rule\"), ruletab[currule]);\n\n\t\t\tpop_stack();\n\t\t\tJUMPTO(pc->target_jmp);\t/* Op_get_record, read next record */\n\n\t\tcase Op_pop:\n\t\t\tr = POP_SCALAR();\n\t\t\tDEREF(r);\n\t\t\tbreak;\n\n\t\tcase Op_line_range:\n\t\t\tif (pc->triggered)\t\t/* evaluate right expression */\n\t\t\t\tJUMPTO(pc->target_jmp);\n\t\t\t/* else\n\t\t\t\tevaluate left expression */\n\t\t\tbreak;\n\n\t\tcase Op_cond_pair:\n\t\t{\n\t\t\tint result;\n\t\t\tINSTRUCTION *ip;\n\n\t\t\tt1 = TOP_SCALAR();   /* from right hand side expression */\n\t\t\tdi = (eval_condition(t1) != 0);\n\t\t\tDEREF(t1);\n\n\t\t\tip = pc->line_range;            /* Op_line_range */\n\n\t\t\tif (! ip->triggered && di) {\n\t\t\t\t/* not already triggered and left expression is true */\n\t\t\t\tdecr_sp();\n\t\t\t\tip->triggered = true;\n\t\t\t\tJUMPTO(ip->target_jmp);\t/* evaluate right expression */\n\t\t\t}\n\n\t\t\tresult = ip->triggered || di;\n\t\t\tip->triggered ^= di;          /* update triggered flag */\n\t\t\tr = node_Boolean[result];      /* final value of condition pair */\n\t\t\tUPREF(r);\n\t\t\tREPLACE(r);\n\t\t\tJUMPTO(pc->target_jmp);\n\t\t}\n\n\t\tcase Op_exec_count:\n\t\t\tif (do_profile)\n\t\t\t\tpc->exec_count++;\n\t\t\tbreak;\n\n\t\tcase Op_no_op:\n\t\tcase Op_K_do:\n\t\tcase Op_K_while:\n\t\tcase Op_K_for:\n\t\tcase Op_K_arrayfor:\n\t\tcase Op_K_switch:\n\t\tcase Op_K_default:\n\t\tcase Op_K_if:\n\t\tcase Op_K_else:\n\t\tcase Op_cond_exp:\n\t\tcase Op_comment:\n\t\tcase Op_parens:\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tfatal(_(\"Sorry, don't know how to interpret `%s'\"), opcode2str(op));\n\t\t}\n\n\t\tJUMPTO(pc->nexti);\n\n/*\t} forever */\n\n\t/* not reached */\n\treturn 0;\n\n#undef mk_sub\n#undef JUMPTO\n}",
      "lines": 1427,
      "depth": 18,
      "decorators": [
        "int"
      ]
    }
  },
  "gawk/gawk-4.2.1/int_array.c": {
    "int_array_init": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "static NODE **\nint_array_init(NODE *symbol, NODE *subs ATTRIBUTE_UNUSED)\n{\n\tif (symbol == NULL) {\t/* first time */\n\t\tlong newval;\n\n\t\t/* check relevant environment variables */\n\t\tif ((newval = getenv_long(\"INT_CHAIN_MAX\")) > 0)\n\t\t\tINT_CHAIN_MAX = newval;\n\t} else\n\t\tnull_array(symbol);\n\n\treturn & success_node;\n}",
      "lines": 14,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "NODE",
        "**\nint_array_init(NODE *symbol, NODE *subs ATTRIBUTE_UNUSED)",
        "*",
        "*\nint_array_init(NODE *symbol, NODE *subs ATTRIBUTE_UNUSED)",
        "*"
      ]
    },
    "standard_integer_string": {
      "start_point": [
        87,
        0
      ],
      "end_point": [
        108,
        1
      ],
      "content": "static bool\nstandard_integer_string(const char *s, size_t len)\n{\n\tconst char *end;\n\n\tif (len == 0)\n\t\treturn false;\n\tif (*s == '0' && len == 1)\n\t\treturn true;\n\tend = s + len;\n\t/* ignore leading minus sign */\n\tif (*s == '-' && ++s == end)\n\t\treturn false;\n\t/* check first char is [1-9] */\n\tif (*s < '1' || *s > '9')\n\t\treturn false;\n\twhile (++s < end) {\n\t\tif (*s < '0' || *s > '9')\n\t\t\treturn false;\n\t}\n\treturn true;\n}",
      "lines": 22,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "is_integer": {
      "start_point": [
        112,
        0
      ],
      "end_point": [
        218,
        1
      ],
      "content": "NODE **\nis_integer(NODE *symbol, NODE *subs)\n{\n#ifndef CHECK_INTEGER_USING_FORCE_NUMBER\n\tlong l;\n#endif\n\tAWKNUM d;\n\n\tif ((subs->flags & NUMINT) != 0)\n\t\t/* quick exit */\n\t\treturn & success_node;\n\n\tif (subs == Nnull_string || do_mpfr)\n\t\treturn NULL;\n\n#ifdef CHECK_INTEGER_USING_FORCE_NUMBER\n\t/*\n\t * This approach is much simpler, because we remove all of the strtol\n\t * logic below. But this may be slower in some usage cases.\n\t */\n\tif ((subs->flags & NUMCUR) == 0) {\n\t\tstr2number(subs);\n\n\t\t/* check again in case force_number set NUMINT */\n\t\tif ((subs->flags & NUMINT) != 0)\n\t\t\treturn & success_node;\n\t}\n#else /* CHECK_INTEGER_USING_FORCE_NUMBER */\n\tif ((subs->flags & NUMCUR) != 0) {\n#endif /* CHECK_INTEGER_USING_FORCE_NUMBER */\n\t\td = subs->numbr;\n\t\tif (d <= INT32_MAX && d >= INT32_MIN && d == (int32_t) d) {\n\t\t\t/*\n\t\t\t * The numeric value is an integer, but we must\n\t\t\t * protect against strings that cannot be generated\n\t\t\t * from sprintf(\"%ld\", <subscript>). This can happen\n\t\t\t * with strnum or string values. We could skip this\n\t\t\t * check for pure NUMBER values, but unfortunately the\n\t\t\t * code does not currently distinguish between NUMBER\n\t\t\t * and strnum values.\n\t\t\t */\n\t\t\tif (   (subs->flags & STRCUR) == 0\n\t\t\t    || standard_integer_string(subs->stptr, subs->stlen)) {\n\t\t\t\tsubs->flags |= NUMINT;\n\t\t\t\treturn & success_node;\n\t\t\t}\n\t\t}\n\t\treturn NULL;\n#ifndef CHECK_INTEGER_USING_FORCE_NUMBER\n\t}\n\n\t/* a[3]=1; print \"3\" in a    -- true\n\t * a[3]=1; print \"+3\" in a   -- false\n\t * a[3]=1; print \"03\" in a   -- false\n\t * a[-3]=1; print \"-3\" in a  -- true\n\t */\n\n\t/* must be a STRING */\n\tchar *cp = subs->stptr, *cpend, *ptr;\n\tchar save;\n\tsize_t len = subs->stlen;\n\n\tif (len == 0 || (! isdigit((unsigned char) *cp) && *cp != '-'))\n\t\treturn NULL;\n\n\tif (len > 1 &&\n\t\t((*cp == '0')\t\t/* \"00\", \"011\" .. */\n\t\t\t|| (*cp == '-' && *(cp + 1) == '0')\t/* \"-0\", \"-011\" .. */\n\t\t)\n\t)\n\t\treturn NULL;\n\tif (len == 1 && *cp != '-') {\t/* single digit */\n\t\tsubs->numbr = (long) (*cp - '0');\n\t\tif ((subs->flags & USER_INPUT) != 0) {\n\t\t\t/* leave USER_INPUT set */\n\t\t\tsubs->flags &= ~STRING;\n\t\t\tsubs->flags |= NUMBER;\n\t\t}\n\t\tsubs->flags |= (NUMCUR|NUMINT);\n\t\treturn & success_node;\n\t}\n\n\tcpend = cp + len;\n\tsave = *cpend;\n\t*cpend = '\\0';\n\n\terrno = 0;\n\tl = strtol(cp, & ptr, 10);\n\t*cpend = save;\n\tif (errno != 0 || ptr != cpend)\n\t\treturn NULL;\n\n\tsubs->numbr = l;\n\tif ((subs->flags & USER_INPUT) != 0) {\n\t\t/* leave USER_INPUT set */\n\t\tsubs->flags &= ~STRING;\n\t\tsubs->flags |= NUMBER;\n\t}\n\tsubs->flags |= NUMCUR;\n\tif (l <= INT32_MAX && l >= INT32_MIN) {\n\t\tsubs->flags |= NUMINT;\n\t\treturn & success_node;\n\t}\n\n\treturn NULL;\n#endif /* CHECK_INTEGER_USING_FORCE_NUMBER */\n}",
      "lines": 107,
      "depth": 16,
      "decorators": [
        "NODE",
        "**\nis_integer(NODE *symbol, NODE *subs)",
        "*",
        "*\nis_integer(NODE *symbol, NODE *subs)",
        "*"
      ]
    },
    "int_lookup": {
      "start_point": [
        226,
        0
      ],
      "end_point": [
        280,
        1
      ],
      "content": "static NODE **\nint_lookup(NODE *symbol, NODE *subs)\n{\n\tuint32_t hash1;\n\tlong k;\n\tunsigned long size;\n\tNODE **lhs;\n\tNODE *xn;\n\n\t/*\n\t * N.B: symbol->table_size is the total # of non-integers (symbol->xarray)\n\t *\tand integer elements. Also, symbol->xarray must have at least one\n\t *\titem in it, and can not exist if there are no integer elements.\n\t * \tIn that case, symbol->xarray is promoted to 'symbol' (See int_remove).\n\t */\n\n\n\tif (! is_integer(symbol, subs)) {\n\t\txn = symbol->xarray;\n\t\tif (xn == NULL) {\n\t\t\txn = symbol->xarray = make_array();\n\t\t\txn->vname = symbol->vname;\t/* shallow copy */\n\t\t\txn->flags |= XARRAY;\n\t\t} else if ((lhs = xn->aexists(xn, subs)) != NULL)\n\t\t\treturn lhs;\n\t\tsymbol->table_size++;\n\t\treturn assoc_lookup(xn, subs);\n\t}\n\n\tk = subs->numbr;\n\tif (symbol->buckets == NULL)\n\t\tgrow_int_table(symbol);\n\n \thash1 = int_hash(k, symbol->array_size);\n\tif ((lhs = int_find(symbol, k, hash1)) != NULL)\n\t\treturn lhs;\n\n\t/* It's not there, install it */\n\n\tsymbol->table_size++;\n\n\t/* first see if we would need to grow the array, before installing */\n\tsize = symbol->table_size;\n\tif ((xn = symbol->xarray) != NULL)\n\t\tsize -= xn->table_size;\n\n\tif ((symbol->flags & ARRAYMAXED) == 0\n\t\t    && (size / symbol->array_size) > INT_CHAIN_MAX) {\n\t\tgrow_int_table(symbol);\n\t\t/* have to recompute hash value for new size */\n\t\thash1 = int_hash(k, symbol->array_size);\n\t}\n\n\treturn int_insert(symbol, k, hash1);\n}",
      "lines": 55,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "NODE",
        "**\nint_lookup(NODE *symbol, NODE *subs)",
        "*",
        "*\nint_lookup(NODE *symbol, NODE *subs)",
        "*"
      ]
    },
    "int_exists": {
      "start_point": [
        288,
        0
      ],
      "end_point": [
        306,
        1
      ],
      "content": "static NODE **\nint_exists(NODE *symbol, NODE *subs)\n{\n\tlong k;\n\tuint32_t hash1;\n\n\tif (! is_integer(symbol, subs)) {\n\t\tNODE *xn = symbol->xarray;\n\t\tif (xn == NULL)\n\t\t\treturn NULL;\n\t\treturn xn->aexists(xn, subs);\n\t}\n\tif (symbol->buckets == NULL)\n\t\treturn NULL;\n\n\tk = subs->numbr;\n\thash1 = int_hash(k, symbol->array_size);\n\treturn int_find(symbol, k, hash1);\n}",
      "lines": 19,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "NODE",
        "**\nint_exists(NODE *symbol, NODE *subs)",
        "*",
        "*\nint_exists(NODE *symbol, NODE *subs)",
        "*"
      ]
    },
    "int_clear": {
      "start_point": [
        310,
        0
      ],
      "end_point": [
        345,
        1
      ],
      "content": "static NODE **\nint_clear(NODE *symbol, NODE *subs ATTRIBUTE_UNUSED)\n{\n\tunsigned long i;\n\tint j;\n\tBUCKET *b, *next;\n\tNODE *r;\n\n\tif (symbol->xarray != NULL) {\n\t\tNODE *xn = symbol->xarray;\n\t\tassoc_clear(xn);\n\t\tfreenode(xn);\n\t\tsymbol->xarray = NULL;\n\t}\n\n\tfor (i = 0; i < symbol->array_size; i++) {\n\t\tfor (b = symbol->buckets[i]; b != NULL;\tb = next) {\n\t\t\tnext = b->ainext;\n\t\t\tfor (j = 0; j < b->aicount; j++) {\n\t\t\t\tr = b->aivalue[j];\n\t\t\t\tif (r->type == Node_var_array) {\n\t\t\t\t\tassoc_clear(r);\t/* recursively clear all sub-arrays */\n\t\t\t\t\tefree(r->vname);\n\t\t\t\t\tfreenode(r);\n\t\t\t\t} else\n\t\t\t\t\tunref(r);\n\t\t\t}\n\t\t\tfreebucket(b);\n\t\t}\n\t\tsymbol->buckets[i] = NULL;\n\t}\n\tif (symbol->buckets != NULL)\n\t\tefree(symbol->buckets);\n\tsymbol->ainit(symbol, NULL);\t/* re-initialize symbol */\n\treturn NULL;\n}",
      "lines": 36,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "NODE",
        "**\nint_clear(NODE *symbol, NODE *subs ATTRIBUTE_UNUSED)",
        "*",
        "*\nint_clear(NODE *symbol, NODE *subs ATTRIBUTE_UNUSED)",
        "*"
      ]
    },
    "int_remove": {
      "start_point": [
        350,
        0
      ],
      "end_point": [
        441,
        1
      ],
      "content": "static NODE **\nint_remove(NODE *symbol, NODE *subs)\n{\n\tuint32_t hash1;\n\tBUCKET *b, *prev = NULL;\n\tlong k;\n\tint i;\n\tNODE *xn = symbol->xarray;\n\n\tif (symbol->table_size == 0 || symbol->buckets == NULL)\n\t\treturn NULL;\n\n\tif (! is_integer(symbol, subs)) {\n\t\tif (xn == NULL || xn->aremove(xn, subs) == NULL)\n\t\t\treturn NULL;\n\t\tif (xn->table_size == 0) {\n\t\t\tfreenode(xn);\n\t\t\tsymbol->xarray = NULL;\n\t\t}\n\t\tsymbol->table_size--;\n\t\tassert(symbol->table_size > 0);\n\t\treturn & success_node;\n\t}\n\n\tk = subs->numbr;\n\thash1 = int_hash(k, symbol->array_size);\n\n\tfor (b = symbol->buckets[hash1]; b != NULL; prev = b, b = b->ainext) {\n\t\tfor (i = 0; i < b->aicount; i++) {\n\t\t\tif (k != b->ainum[i])\n\t\t\t\tcontinue;\n\n\t\t\t/* item found */\n\t\t\tif (i == 0 && b->aicount == 2) {\n\t\t\t\t/* removing the 1st item; move 2nd item from position 1 to 0 */\n\n\t\t\t\tb->ainum[0] = b->ainum[1];\n\t\t\t\tb->aivalue[0] = b->aivalue[1];\n\t\t\t} /* else\n\t\t\t\tremoving the only item or the 2nd item */\n\n\t\t\tgoto removed;\n\t\t}\n\t}\n\n\tif (b == NULL)\t/* item not in array */\n\t\treturn NULL;\n\nremoved:\n\tb->aicount--;\n\n\tif (b->aicount == 0) {\n\t\t/* detach bucket */\n\t\tif (prev != NULL)\n\t\t\tprev->ainext = b->ainext;\n\t\telse\n\t\t\tsymbol->buckets[hash1] = b->ainext;\n\n\t\t/* delete bucket */\n\t\tfreebucket(b);\n\t} else if (b != symbol->buckets[hash1]) {\n\t\tBUCKET *head = symbol->buckets[hash1];\n\n\t\tassert(b->aicount == 1);\n\t\t/* move the last element from head to bucket to make it full. */\n\t\ti = --head->aicount;\t/* head has one less element */\n\t\tb->ainum[1] = head->ainum[i];\n\t\tb->aivalue[1] = head->aivalue[i];\n\t\tb->aicount++;\t/* bucket has one more element */\n\t\tif (i == 0) {\n\t\t\t/* head is now empty; delete head */\n\t\t\tsymbol->buckets[hash1] = head->ainext;\n\t\t\tfreebucket(head);\n\t\t}\n\t} /* else\n\t\tdo nothing */\n\n\tsymbol->table_size--;\n\tif (xn == NULL && symbol->table_size == 0) {\n\t\tefree(symbol->buckets);\n\t\tsymbol->ainit(symbol, NULL);\t/* re-initialize array 'symbol' */\n\t} else if (xn != NULL && symbol->table_size == xn->table_size) {\n\t\t/* promote xn (str_array) to symbol */\n\t\txn->flags &= ~XARRAY;\n\t\txn->parent_array = symbol->parent_array;\n\t\tefree(symbol->buckets);\n\t\t*symbol = *xn;\n\t\tfreenode(xn);\n\t}\n\n\treturn & success_node;\t/* return success */\n}",
      "lines": 92,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "NODE",
        "**\nint_remove(NODE *symbol, NODE *subs)",
        "*",
        "*\nint_remove(NODE *symbol, NODE *subs)",
        "*"
      ]
    },
    "int_copy": {
      "start_point": [
        446,
        0
      ],
      "end_point": [
        514,
        1
      ],
      "content": "static NODE **\nint_copy(NODE *symbol, NODE *newsymb)\n{\n\tBUCKET **old, **new, **pnew;\n\tBUCKET *chain, *newchain;\n\tint j;\n\tunsigned long i, cursize;\n\n\tassert(symbol->buckets != NULL);\n\n\t/* find the current hash size */\n\tcursize = symbol->array_size;\n\n\t/* allocate new table */\n\tezalloc(new, BUCKET **, cursize * sizeof(BUCKET *), \"int_copy\");\n\n\told = symbol->buckets;\n\n\tfor (i = 0; i < cursize; i++) {\n\t\tfor (chain = old[i], pnew = & new[i]; chain != NULL;\n\t\t\t\tchain = chain->ainext\n\t\t) {\n\t\t\tgetbucket(newchain);\n\t\t\tnewchain->aicount = chain->aicount;\n\t\t\tnewchain->ainext = NULL;\n\t\t\tfor (j = 0; j < chain->aicount; j++) {\n\t\t\t\tNODE *oldval;\n\n\t\t\t\t/*\n\t\t\t\t * copy the corresponding key and\n\t\t\t\t * value from the original input list\n\t\t\t\t */\n\t\t\t\tnewchain->ainum[j] = chain->ainum[j];\n\n\t\t\t\toldval = chain->aivalue[j];\n\t\t\t\tif (oldval->type == Node_val)\n\t\t\t\t\tnewchain->aivalue[j] = dupnode(oldval);\n\t\t\t\telse {\n\t\t\t\t\tNODE *r;\n\t\t\t\t\tr = make_array();\n\t\t\t\t\tr->vname = estrdup(oldval->vname, strlen(oldval->vname));\n\t\t\t\t\tr->parent_array = newsymb;\n\t\t\t\t\tnewchain->aivalue[j] = assoc_copy(oldval, r);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t*pnew = newchain;\n\t\t\tnewchain->ainext = NULL;\n\t\t\tpnew = & newchain->ainext;\n\t\t}\n\t}\n\n\tif (symbol->xarray != NULL) {\n\t\tNODE *xn, *n;\n\t\txn = symbol->xarray;\n\t\tn = make_array();\n\t\tn->vname = newsymb->vname;\t/* shallow copy */\n\t\t(void) xn->acopy(xn, n);\n\t\tnewsymb->xarray = n;\n\t} else\n\t\tnewsymb->xarray = NULL;\n\n\tnewsymb->table_size = symbol->table_size;\n\tnewsymb->buckets = new;\n\tnewsymb->array_size = cursize;\n\tnewsymb->flags = symbol->flags;\n\n\treturn NULL;\n}",
      "lines": 69,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "NODE",
        "**\nint_copy(NODE *symbol, NODE *newsymb)",
        "*",
        "*\nint_copy(NODE *symbol, NODE *newsymb)",
        "*"
      ]
    },
    "int_list": {
      "start_point": [
        519,
        0
      ],
      "end_point": [
        590,
        1
      ],
      "content": "static NODE**\nint_list(NODE *symbol, NODE *t)\n{\n\tNODE **list = NULL;\n\tunsigned long num_elems, list_size, i, k = 0;\n\tBUCKET *b;\n\tNODE *r, *subs, *xn;\n\tint j, elem_size = 1;\n\tlong num;\n\tstatic char buf[100];\n\tassoc_kind_t assoc_kind;\n\n\tif (symbol->table_size == 0)\n\t\treturn NULL;\n\n\tassoc_kind = (assoc_kind_t) t->flags;\n\tnum_elems = symbol->table_size;\n\tif ((assoc_kind & (AINDEX|AVALUE|ADELETE)) == (AINDEX|ADELETE))\n\t\tnum_elems = 1;\n\n\tif ((assoc_kind & (AINDEX|AVALUE)) == (AINDEX|AVALUE))\n\t\telem_size = 2;\n\tlist_size = elem_size * num_elems;\n\n\tif (symbol->xarray != NULL) {\n\t\txn = symbol->xarray;\n\t\tlist = xn->alist(xn, t);\n\t\tassert(list != NULL);\n\t\tif (num_elems == 1 || num_elems == xn->table_size)\n\t\t\treturn list;\n\t\terealloc(list, NODE **, list_size * sizeof(NODE *), \"int_list\");\n\t\tk = elem_size * xn->table_size;\n\t} else\n\t\temalloc(list, NODE **, list_size * sizeof(NODE *), \"int_list\");\n\n\t/* populate it */\n\n\tfor (i = 0; i < symbol->array_size; i++) {\n\t\tfor (b = symbol->buckets[i]; b != NULL;\tb = b->ainext) {\n\t\t\tfor (j = 0; j < b->aicount; j++) {\n\t\t\t\t/* index */\n\t\t\t\tnum = b->ainum[j];\n\t\t\t\tif ((assoc_kind & AISTR) != 0) {\n\t\t\t\t\tsprintf(buf, \"%ld\", num);\n\t\t\t\t\tsubs = make_string(buf, strlen(buf));\n\t\t\t\t\tsubs->numbr = num;\n\t\t\t\t\tsubs->flags |= (NUMCUR|NUMINT);\n\t\t\t\t} else {\n\t\t\t\t\tsubs = make_number((AWKNUM) num);\n\t\t\t\t\tsubs->flags |= (INTIND|NUMINT);\n\t\t\t\t}\n\t\t\t\tlist[k++] = subs;\n\n\t\t\t\t/* value */\n\t\t\t\tif ((assoc_kind & AVALUE) != 0) {\n\t\t\t\t\tr = b->aivalue[j];\n\t\t\t\t\tif (r->type == Node_val) {\n\t\t\t\t\t\tif ((assoc_kind & AVNUM) != 0)\n\t\t\t\t\t\t\t(void) force_number(r);\n\t\t\t\t\t\telse if ((assoc_kind & AVSTR) != 0)\n\t\t\t\t\t\t\tr = force_string(r);\n\t\t\t\t\t}\n\t\t\t\t\tlist[k++] = r;\n\t\t\t\t}\n\n\t\t\t\tif (k >= list_size)\n\t\t\t\t\treturn list;\n\t\t\t}\n\t\t}\n\t}\n\treturn list;\n}",
      "lines": 72,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "NODE",
        "**\nint_list(NODE *symbol, NODE *t)",
        "*",
        "*\nint_list(NODE *symbol, NODE *t)",
        "*"
      ]
    },
    "int_kilobytes": {
      "start_point": [
        595,
        0
      ],
      "end_point": [
        614,
        1
      ],
      "content": "AWKNUM\nint_kilobytes(NODE *symbol)\n{\n\tunsigned long i, bucket_cnt = 0;\n\tBUCKET *b;\n\tAWKNUM kb;\n\textern AWKNUM str_kilobytes(NODE *symbol);\n\n\tfor (i = 0; i < symbol->array_size; i++) {\n\t\tfor (b = symbol->buckets[i]; b != NULL; b = b->ainext)\n\t\t\tbucket_cnt++;\n\t}\n\tkb = (((AWKNUM) bucket_cnt) * sizeof (BUCKET) +\n\t\t\t((AWKNUM) symbol->array_size) * sizeof (BUCKET *)) / 1024.0;\n\n\tif (symbol->xarray != NULL)\n\t\tkb += str_kilobytes(symbol->xarray);\n\n\treturn kb;\n}",
      "lines": 20,
      "depth": 15,
      "decorators": [
        "AWKNUM"
      ]
    },
    "int_dump": {
      "start_point": [
        619,
        0
      ],
      "end_point": [
        725,
        1
      ],
      "content": "static NODE **\nint_dump(NODE *symbol, NODE *ndump)\n{\n#define HCNT\t31\n\n\tint indent_level;\n\tBUCKET *b;\n\tNODE *xn = NULL;\n\tunsigned long str_size = 0, int_size = 0;\n\tunsigned long i;\n\tsize_t j, bucket_cnt;\n\tstatic size_t hash_dist[HCNT + 1];\n\n\tindent_level = ndump->alevel;\n\n\tif (symbol->xarray != NULL) {\n\t\txn = symbol->xarray;\n\t\tstr_size = xn->table_size;\n\t}\n\tint_size = symbol->table_size - str_size;\n\n\tif ((symbol->flags & XARRAY) == 0)\n\t\tfprintf(output_fp, \"%s `%s'\\n\",\n\t\t\t\t(symbol->parent_array == NULL) ? \"array\" : \"sub-array\",\n\t\t\t\tarray_vname(symbol));\n\n\tindent_level++;\n\tindent(indent_level);\n\tfprintf(output_fp, \"array_func: int_array_func\\n\");\n\tif (symbol->flags != 0) {\n\t\tindent(indent_level);\n\t\tfprintf(output_fp, \"flags: %s\\n\", flags2str(symbol->flags));\n\t}\n\tindent(indent_level);\n\tfprintf(output_fp, \"INT_CHAIN_MAX: %lu\\n\", (unsigned long) INT_CHAIN_MAX);\n\tindent(indent_level);\n\tfprintf(output_fp, \"array_size: %lu (int)\\n\", (unsigned long) symbol->array_size);\n\tindent(indent_level);\n\tfprintf(output_fp, \"table_size: %lu (total), %lu (int), %lu (str)\\n\",\n\t\t\t(unsigned long) symbol->table_size, int_size, str_size);\n\tindent(indent_level);\n\tfprintf(output_fp, \"Avg # of items per chain (int): %.2g\\n\",\n\t\t\t((AWKNUM) int_size) / symbol->array_size);\n\n\tindent(indent_level);\n\tfprintf(output_fp, \"memory: %.2g kB (total)\\n\", int_kilobytes(symbol));\n\n\t/* hash value distribution */\n\n\tmemset(hash_dist, '\\0', (HCNT + 1) * sizeof(size_t));\n\tfor (i = 0; i < symbol->array_size; i++) {\n\t\tbucket_cnt = 0;\n\t\tfor (b = symbol->buckets[i]; b != NULL;\tb = b->ainext)\n\t\t\tbucket_cnt += b->aicount;\n\t\tif (bucket_cnt >= HCNT)\n\t\t\tbucket_cnt = HCNT;\n\t\thash_dist[bucket_cnt]++;\n\t}\n\n\tindent(indent_level);\n\tfprintf(output_fp, \"Hash distribution:\\n\");\n\tindent_level++;\n\tfor (j = 0; j <= HCNT; j++) {\n\t\tif (hash_dist[j] > 0) {\n\t\t\tindent(indent_level);\n\t\t\tif (j == HCNT)\n\t\t\t\tfprintf(output_fp, \"[>=%lu]:%lu\\n\",\n\t\t\t\t\t(unsigned long) HCNT, (unsigned long) hash_dist[j]);\n\t\t\telse\n\t\t\t\tfprintf(output_fp, \"[%lu]:%lu\\n\",\n\t\t\t\t\t(unsigned long) j, (unsigned long) hash_dist[j]);\n\t\t}\n\t}\n\tindent_level--;\n\n\t/* dump elements */\n\n\tif (ndump->adepth >= 0) {\n\t\tNODE *subs;\n\t\tconst char *aname;\n\n\t\tfprintf(output_fp, \"\\n\");\n\n\t\taname = make_aname(symbol);\n\t\tsubs = make_number((AWKNUM) 0);\n\t\tsubs->flags |= (INTIND|NUMINT);\n\n\t\tfor (i = 0; i < symbol->array_size; i++) {\n\t\t\tfor (b = symbol->buckets[i]; b != NULL; b = b->ainext) {\n\t\t\t\tfor (j = 0; j < b->aicount; j++) {\n\t\t\t\t\tsubs->numbr = b->ainum[j];\n\t\t\t\t\tassoc_info(subs, b->aivalue[j], ndump, aname);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tunref(subs);\n\t}\n\n\tif (xn != NULL)\t{\n\t\tfprintf(output_fp, \"\\n\");\n\t\txn->adump(xn, ndump);\n\t}\n\n\treturn NULL;\n\n#undef HCNT\n}",
      "lines": 107,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "NODE",
        "**\nint_dump(NODE *symbol, NODE *ndump)",
        "*",
        "*\nint_dump(NODE *symbol, NODE *ndump)",
        "*"
      ]
    },
    "int_hash": {
      "start_point": [
        730,
        0
      ],
      "end_point": [
        752,
        1
      ],
      "content": "static uint32_t\nint_hash(uint32_t k, uint32_t hsize)\n{\n\n/*\n * Code snippet copied from:\n *\tHash functions (http://www.azillionmonkeys.com/qed/hash.html).\n *\tCopyright 2004-2008 by Paul Hsieh. Licenced under LGPL 2.1.\n */\n\n\t/* This is the final mixing function used by Paul Hsieh in SuperFastHash. */\n\n\tk ^= k << 3;\n\tk += k >> 5;\n\tk ^= k << 4;\n\tk += k >> 17;\n\tk ^= k << 25;\n\tk += k >> 6;\n\n\tif (k >= hsize)\n\t\tk %= hsize;\n\treturn k;\n}",
      "lines": 23,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "uint32_t"
      ]
    },
    "int_find": {
      "start_point": [
        756,
        0
      ],
      "end_point": [
        770,
        1
      ],
      "content": "static inline NODE **\nint_find(NODE *symbol, long k, uint32_t hash1)\n{\n\tBUCKET *b;\n\tint i;\n\n\tassert(symbol->buckets != NULL);\n\tfor (b = symbol->buckets[hash1]; b != NULL; b = b->ainext) {\n\t\tfor (i = 0; i < b->aicount; i++) {\n\t\t\tif (b->ainum[i] == k)\n\t\t\t\treturn (b->aivalue + i);\n\t\t}\n\t}\n\treturn NULL;\n}",
      "lines": 15,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "NODE",
        "**\nint_find(NODE *symbol, long k, uint32_t hash1)",
        "*",
        "*\nint_find(NODE *symbol, long k, uint32_t hash1)",
        "*"
      ]
    },
    "int_insert": {
      "start_point": [
        775,
        0
      ],
      "end_point": [
        797,
        1
      ],
      "content": "static NODE **\nint_insert(NODE *symbol, long k, uint32_t hash1)\n{\n\tBUCKET *b;\n\tint i;\n\n\tb = symbol->buckets[hash1];\n\n\t/* Only the first bucket in the chain can be partially full, but is never empty. */\n\n\tif (b == NULL || (i = b->aicount) == 2) {\n\t\tgetbucket(b);\n\t\tb->aicount = 0;\n\t\tb->ainext = symbol->buckets[hash1];\n\t\tsymbol->buckets[hash1] = b;\n\t\ti = 0;\n\t}\n\n\tb->ainum[i] = k;\n\tb->aivalue[i] = dupnode(Nnull_string);\n\tb->aicount++;\n\treturn & b->aivalue[i];\n}",
      "lines": 23,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "NODE",
        "**\nint_insert(NODE *symbol, long k, uint32_t hash1)",
        "*",
        "*\nint_insert(NODE *symbol, long k, uint32_t hash1)",
        "*"
      ]
    },
    "grow_int_table": {
      "start_point": [
        802,
        0
      ],
      "end_point": [
        868,
        1
      ],
      "content": "static void\ngrow_int_table(NODE *symbol)\n{\n\tBUCKET **old, **new;\n\tBUCKET *chain, *next;\n\tint i, j;\n\tunsigned long oldsize, newsize, k;\n\n\t/*\n\t * This is an array of primes. We grow the table by an order of\n\t * magnitude each time (not just doubling) so that growing is a\n\t * rare operation. We expect, on average, that it won't happen\n\t * more than twice.  The final size is also chosen to be small\n\t * enough so that MS-DOG mallocs can handle it. When things are\n\t * very large (> 8K), we just double more or less, instead of\n\t * just jumping from 8K to 64K.\n\t */\n\n\tstatic const unsigned long sizes[] = {\n\t\t13, 127, 1021, 8191, 16381, 32749, 65497,\n\t\t131101, 262147, 524309, 1048583, 2097169,\n\t\t4194319, 8388617, 16777259, 33554467,\n\t\t67108879, 134217757, 268435459, 536870923,\n\t\t1073741827\n\t};\n\n\t/* find next biggest hash size */\n\tnewsize = oldsize = symbol->array_size;\n\n\tfor (i = 0, j = sizeof(sizes)/sizeof(sizes[0]); i < j; i++) {\n\t\tif (oldsize < sizes[i]) {\n\t\t\tnewsize = sizes[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (newsize == oldsize) {\t/* table already at max (!) */\n\t\tsymbol->flags |= ARRAYMAXED;\n\t\treturn;\n\t}\n\n\t/* allocate new table */\n\tezalloc(new, BUCKET **, newsize * sizeof(BUCKET *), \"grow_int_table\");\n\n\told = symbol->buckets;\n\tsymbol->buckets = new;\n\tsymbol->array_size = newsize;\n\n\t/* brand new hash table */\n\tif (old == NULL)\n\t\treturn;\t\t/* DO NOT initialize symbol->table_size */\n\n\t/* old hash table there, move stuff to new, free old */\n\t/* note that symbol->table_size does not change if an old array. */\n\n\tfor (k = 0; k < oldsize; k++) {\n\t\tlong num;\n\t\tfor (chain = old[k]; chain != NULL; chain = next) {\n\t\t\tfor (i = 0; i < chain->aicount; i++) {\n\t\t\t\tnum = chain->ainum[i];\n\t\t\t\t*int_insert(symbol, num, int_hash(num, newsize)) = chain->aivalue[i];\n\t\t\t}\n\t\t\tnext = chain->ainext;\n\t\t\tfreebucket(chain);\n\t\t}\n\t}\n\tefree(old);\n}",
      "lines": 67,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "gawk/gawk-4.2.1/io.c": {
    "init_io": {
      "start_point": [
        334,
        0
      ],
      "end_point": [
        360,
        1
      ],
      "content": "void\ninit_io()\n{\n\tlong tmout;\n\n\t/* Only MinGW has a non-trivial implementation of this.  */\n\tinit_sockets();\n\n\t/*\n\t * N.B.: all these hacks are to minimize the effect\n\t * on programs that do not care about timeout.\n\t */\n\n\t/* Parse the env. variable only once */\n\ttmout = getenv_long(\"GAWK_READ_TIMEOUT\");\n\tif (tmout > 0) {\n\t\tread_default_timeout = tmout;\n\t\tread_can_timeout = true;\n\t}\n\n\t/*\n\t * PROCINFO entries for timeout are dynamic;\n\t * We can't be any more specific than this.\n\t */\n\tif (PROCINFO_node != NULL)\n\t\tread_can_timeout = true;\n}",
      "lines": 27,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "binmode": {
      "start_point": [
        366,
        0
      ],
      "end_point": [
        381,
        1
      ],
      "content": "static const char *\nbinmode(const char *mode)\n{\n\tswitch (mode[0]) {\n\tcase 'r':\n\t\tif ((BINMODE & BINMODE_INPUT) != 0)\n\t\t\tmode = \"rb\";\n\t\tbreak;\n\tcase 'w':\n\tcase 'a':\n\t\tif ((BINMODE & BINMODE_OUTPUT) != 0)\n\t\t\tmode = (mode[0] == 'w' ? \"wb\" : \"ab\");\n\t\tbreak;\n\t}\n\treturn mode;\n}",
      "lines": 16,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nbinmode(const char *mode)",
        "*"
      ]
    },
    "after_beginfile": {
      "start_point": [
        397,
        0
      ],
      "end_point": [
        431,
        1
      ],
      "content": "void\nafter_beginfile(IOBUF **curfile)\n{\n\tIOBUF *iop;\n\n\tiop = *curfile;\n\tassert(iop != NULL);\n\n\t/*\n\t * Input parsers could have been changed by BEGINFILE,\n\t * so delay check until now.\n\t */\n\n\tfind_input_parser(iop);\n\n\tif (! iop->valid) {\n\t\tconst char *fname;\n\t\tint errcode;\n\t\tbool valid;\n\n\t\tfname = iop->public.name;\n\t\terrcode = iop->errcode;\n\t\tvalid = iop->valid;\n\t\terrno = 0;\n\t\tupdate_ERRNO_int(errcode);\n\t\tiop_close(iop);\n\t\t*curfile = NULL;\n\t\tif (! valid && errcode == EISDIR && ! do_traditional) {\n\t\t\twarning(_(\"command line argument `%s' is a directory: skipped\"), fname);\n\t\t\treturn;\t\t/* read next file */\n\t\t}\n\t\tfatal(_(\"cannot open file `%s' for reading (%s)\"),\n\t\t\t\tfname, strerror(errcode));\n\t}\n}",
      "lines": 35,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "nextfile": {
      "start_point": [
        439,
        0
      ],
      "end_point": [
        552,
        1
      ],
      "content": "int\nnextfile(IOBUF **curfile, bool skipping)\n{\n\tstatic long i = 1;\n\tstatic bool files = false;\n\tNODE *arg, *tmp;\n\tconst char *fname;\n\tint fd = INVALID_HANDLE;\n\tint errcode = 0;\n\tIOBUF *iop = *curfile;\n\tlong argc;\n\n\tif (skipping) {\t\t\t/* for 'nextfile' call */\n\t\terrcode = 0;\n\t\tif (iop != NULL) {\n\t\t\terrcode = iop->errcode;\n\t\t\t(void) iop_close(iop);\n\t\t}\n\t\t*curfile = NULL;\n\t\treturn (errcode == 0);\n\t}\n\n\tif (iop != NULL) {\n\t\tif (at_eof(iop)) {\n\t\t\tassert(iop->public.fd != INVALID_HANDLE);\n\t\t\t(void) iop_close(iop);\n\t\t\t*curfile = NULL;\n\t\t\treturn 1;\t/* run endfile block */\n\t\t} else\n\t\t\treturn 0;\n\t}\n\n\targc = get_number_si(ARGC_node->var_value);\n\n\tfor (; i < argc; i++) {\n\t\ttmp = make_number((AWKNUM) i);\n\t\t(void) force_string(tmp);\n\t\targ = in_array(ARGV_node, tmp);\n\t\tunref(tmp);\n\t\tif (arg == NULL || arg->stlen == 0)\n\t\t\tcontinue;\n\t\targ = force_string(arg);\n\t\tif (! do_traditional) {\n\t\t\tunref(ARGIND_node->var_value);\n\t\t\tARGIND_node->var_value = make_number((AWKNUM) i);\n\t\t}\n\n\t\tif (! arg_assign(arg->stptr, false)) {\n\t\t\tfiles = true;\n\t\t\tfname = arg->stptr;\n\n\t\t\t/* manage the awk variables: */\n\t\t\tunref(FILENAME_node->var_value);\n\t\t\tFILENAME_node->var_value = dupnode(arg);\n#ifdef HAVE_MPFR\n\t\t\tif (is_mpg_number(FNR_node->var_value))\n\t\t\t\tmpz_set_ui(MFNR, 0);\n#endif\n\t\t\tFNR = 0;\n\n\t\t\t/* IOBUF management: */\n\t\t\terrno = 0;\n\t\t\tfd = devopen(fname, binmode(\"r\"));\n\t\t\tif (fd == INVALID_HANDLE && errno == EMFILE) {\n\t\t\t\tclose_one();\n\t\t\t\tclose_one();\n\t\t\t\tfd = devopen(fname, binmode(\"r\"));\n\t\t\t}\n\t\t\terrcode = errno;\n\t\t\tif (! do_traditional)\n\t\t\t\tupdate_ERRNO_int(errno);\n\t\t\tiop = iop_alloc(fd, fname, errcode);\n\t\t\t*curfile = iop_finish(iop);\n\t\t\tif (iop->public.fd == INVALID_HANDLE)\n\t\t\t\tiop->errcode = errcode;\n\t\t\telse if (iop->valid)\n\t\t\t\tiop->errcode = 0;\n\n\t\t\tif (! do_traditional && iop->errcode != 0)\n\t\t\t\tupdate_ERRNO_int(iop->errcode);\n\n\t\t\treturn ++i;\t/* run beginfile block */\n\t\t}\n\t}\n\n\tif (files == false) {\n\t\tfiles = true;\n\t\t/* no args. -- use stdin */\n\t\t/* FNR is init'ed to 0 */\n\t\terrno = 0;\n\t\tif (! do_traditional)\n\t\t\tupdate_ERRNO_int(errno);\n\n\t\tunref(FILENAME_node->var_value);\n\t\tFILENAME_node->var_value = make_string(\"-\", 1);\n\t\tFILENAME_node->var_value->flags |= USER_INPUT; /* be pedantic */\n\t\tfname = \"-\";\n\t\tiop = iop_alloc(fileno(stdin), fname, 0);\n\t\t*curfile = iop_finish(iop);\n\n\t\tif (iop->public.fd == INVALID_HANDLE) {\n\t\t\terrcode = errno;\n\t\t\terrno = 0;\n\t\t\tupdate_ERRNO_int(errno);\n\t\t\t(void) iop_close(iop);\n\t\t\t*curfile = NULL;\n\t\t\tfatal(_(\"cannot open file `%s' for reading (%s)\"),\n\t\t\t\t\tfname, strerror(errcode));\n\t\t}\n\t\treturn ++i;\t/* run beginfile block */\n\t}\n\n\treturn -1;\t/* end of input, run end block or Op_atexit */\n}",
      "lines": 114,
      "depth": 16,
      "decorators": [
        "int"
      ]
    },
    "set_FNR": {
      "start_point": [
        556,
        0
      ],
      "end_point": [
        567,
        1
      ],
      "content": "void\nset_FNR()\n{\n\tNODE *n = FNR_node->var_value;\n\t(void) force_number(n);\n#ifdef HAVE_MPFR\n\tif (is_mpg_number(n))\n\t\tFNR = mpg_set_var(FNR_node);\n\telse\n#endif\n\tFNR = get_number_si(n);\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "set_NR": {
      "start_point": [
        571,
        0
      ],
      "end_point": [
        582,
        1
      ],
      "content": "void\nset_NR()\n{\n\tNODE *n = NR_node->var_value;\n\t(void) force_number(n);\n#ifdef HAVE_MPFR\n\tif (is_mpg_number(n))\n\t\tNR = mpg_set_var(NR_node);\n\telse\n#endif\n\tNR = get_number_si(n);\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "inrec": {
      "start_point": [
        586,
        0
      ],
      "end_point": [
        613,
        1
      ],
      "content": "bool\ninrec(IOBUF *iop, int *errcode)\n{\n\tchar *begin;\n\tint cnt;\n\tbool retval = true;\n\tconst awk_fieldwidth_info_t *field_width = NULL;\n\n\tif (at_eof(iop) && no_data_left(iop))\n\t\tcnt = EOF;\n\telse if ((iop->flag & IOP_CLOSED) != 0)\n\t\tcnt = EOF;\n\telse\n\t\tcnt = get_a_record(& begin, iop, errcode, & field_width);\n\n\t/* Note that get_a_record may return -2 when I/O would block */\n\tif (cnt < 0) {\n\t\tretval = false;\n\t} else {\n\t\tINCREMENT_REC(NR);\n\t\tINCREMENT_REC(FNR);\n\t\tset_record(begin, cnt, field_width);\n\t\tif (*errcode > 0)\n\t\t\tretval = false;\n\t}\n\n\treturn retval;\n}",
      "lines": 28,
      "depth": 10,
      "decorators": [
        "bool"
      ]
    },
    "remap_std_file": {
      "start_point": [
        617,
        0
      ],
      "end_point": [
        639,
        1
      ],
      "content": "static int\nremap_std_file(int oldfd)\n{\n\tint newfd;\n\tint ret = -1;\n\n\t/*\n\t * Give OS-specific routines in gawkmisc.c a chance to interpret\n\t * \"/dev/null\" as appropriate for their platforms.\n\t */\n\tnewfd = os_devopen(\"/dev/null\", O_RDWR);\n\tif (newfd == INVALID_HANDLE)\n\t\tnewfd = open(\"/dev/null\", O_RDWR);\n\tif (newfd >= 0) {\n\t\t/* if oldfd is open, dup2() will close oldfd for us first. */\n\t\tret = dup2(newfd, oldfd);\n\t\tif (ret == 0)\n\t\t\tclose(newfd);\n\t} else\n\t\tret = 0;\n\n\treturn ret;\n}",
      "lines": 23,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "iop_close": {
      "start_point": [
        643,
        0
      ],
      "end_point": [
        705,
        1
      ],
      "content": "static int\niop_close(IOBUF *iop)\n{\n\tint ret = 0;\n\n\tif (iop == NULL)\n\t\treturn 0;\n\n\terrno = 0;\n\n\tiop->flag &= ~IOP_AT_EOF;\n\tiop->flag |= IOP_CLOSED;\t/* there may be dangling pointers */\n\tiop->dataend = NULL;\n\t/*\n\t * Closing standard files can cause crufty code elsewhere to lose.\n\t * So we remap the standard file to /dev/null.\n\t * Thanks to Jim Meyering for the suggestion.\n\t */\n\tif (iop->public.close_func != NULL)\n\t\tiop->public.close_func(&iop->public);\n\n\tif (iop->public.fd != INVALID_HANDLE) {\n\t\tif (iop->public.fd == fileno(stdin)\n\t\t    || iop->public.fd == fileno(stdout)\n\t\t    || iop->public.fd == fileno(stderr))\n\t\t\tret = remap_std_file(iop->public.fd);\n\t\telse\n\t\t\tret = closemaybesocket(iop->public.fd);\n\t}\n\n\tif (ret == -1)\n\t\twarning(_(\"close of fd %d (`%s') failed (%s)\"), iop->public.fd,\n\t\t\t\tiop->public.name, strerror(errno));\n\t/*\n\t * Be careful -- $0 may still reference the buffer even though\n\t * an explicit close is being done; in the future, maybe we\n\t * can do this a bit better.\n\t */\n\tif (iop->buf) {\n\t\tif ((fields_arr[0]->stptr >= iop->buf)\n\t\t    && (fields_arr[0]->stptr < (iop->buf + iop->size))) {\n\t\t\tNODE *t;\n\n\t\t\tt = make_string(fields_arr[0]->stptr,\n\t\t\t\t\tfields_arr[0]->stlen);\n\t\t\tunref(fields_arr[0]);\n\t\t\tfields_arr[0] = t;\n\t\t\t/*\n\t\t\t * This used to be here:\n\t\t\t *\n\t\t\t * reset_record();\n\t\t\t *\n\t\t\t * Don't do that; reset_record() throws away all fields,\n\t\t\t * saves FS etc.  We just need to make sure memory isn't\n\t\t\t * corrupted and that references to $0 and fields work.\n\t\t\t */\n\t\t}\n\t\tefree(iop->buf);\n\t\tiop->buf = NULL;\n\t}\n\tefree(iop);\n\treturn ret == -1 ? 1 : 0;\n}",
      "lines": 63,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "redflags2str": {
      "start_point": [
        709,
        0
      ],
      "end_point": [
        728,
        1
      ],
      "content": "const char *\nredflags2str(int flags)\n{\n\tstatic const struct flagtab redtab[] = {\n\t\t{ RED_FILE,\t\"RED_FILE\" },\n\t\t{ RED_PIPE,\t\"RED_PIPE\" },\n\t\t{ RED_READ,\t\"RED_READ\" },\n\t\t{ RED_WRITE,\t\"RED_WRITE\" },\n\t\t{ RED_APPEND,\t\"RED_APPEND\" },\n\t\t{ RED_NOBUF,\t\"RED_NOBUF\" },\n\t\t{ RED_EOF,\t\"RED_EOF\" },\n\t\t{ RED_TWOWAY,\t\"RED_TWOWAY\" },\n\t\t{ RED_PTY,\t\"RED_PTY\" },\n\t\t{ RED_SOCKET,\t\"RED_SOCKET\" },\n\t\t{ RED_TCP,\t\"RED_TCP\" },\n\t\t{ 0, NULL }\n\t};\n\n\treturn genflags2str(flags, redtab);\n}",
      "lines": 20,
      "depth": 8,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nredflags2str(int flags)",
        "*"
      ]
    },
    "redirect_string": {
      "start_point": [
        732,
        0
      ],
      "end_point": [
        1073,
        1
      ],
      "content": "struct redirect *\nredirect_string(const char *str, size_t explen, bool not_string,\n\t\tint redirtype, int *errflg, int extfd, bool failure_fatal)\n{\n\tstruct redirect *rp;\n\tint tflag = 0;\n\tint outflag = 0;\n\tconst char *direction = \"to\";\n\tconst char *mode;\n\tint fd;\n\tconst char *what = NULL;\n\tbool new_rp = false;\n#ifdef HAVE_SOCKETS\n\tstruct inet_socket_info isi;\n#endif\n\tstatic struct redirect *save_rp = NULL;\t/* hold onto rp that should\n\t                                         * be freed for reuse\n\t                                         */\n\n\tif (do_sandbox)\n\t\tfatal(_(\"redirection not allowed in sandbox mode\"));\n\n\tswitch (redirtype) {\n\tcase redirect_append:\n\t\ttflag = RED_APPEND;\n\t\t/* FALL THROUGH */\n\tcase redirect_output:\n\t\toutflag = (RED_FILE|RED_WRITE);\n\t\ttflag |= outflag;\n\t\tif (redirtype == redirect_output)\n\t\t\twhat = \">\";\n\t\telse\n\t\t\twhat = \">>\";\n\t\tbreak;\n\tcase redirect_pipe:\n\t\ttflag = (RED_PIPE|RED_WRITE);\n\t\twhat = \"|\";\n\t\tbreak;\n\tcase redirect_pipein:\n\t\ttflag = (RED_PIPE|RED_READ);\n\t\twhat = \"|\";\n\t\tbreak;\n\tcase redirect_input:\n\t\ttflag = (RED_FILE|RED_READ);\n\t\twhat = \"<\";\n\t\tbreak;\n\tcase redirect_twoway:\n\t\ttflag = (RED_READ|RED_WRITE|RED_TWOWAY);\n\t\twhat = \"|&\";\n\t\tbreak;\n\tdefault:\n\t\tcant_happen();\n\t}\n\tif (do_lint && not_string)\n\t\tlintwarn(_(\"expression in `%s' redirection is a number\"),\n\t\t\twhat);\n\n\tif (explen < 1 || str == NULL || *str == '\\0')\n\t\tfatal(_(\"expression for `%s' redirection has null string value\"),\n\t\t\twhat);\n\n\tif (do_lint && (strncmp(str, \"0\", explen) == 0\n\t\t\t|| strncmp(str, \"1\", explen) == 0))\n\t\tlintwarn(_(\"filename `%.*s' for `%s' redirection may be result of logical expression\"),\n\t\t\t\t(int) explen, str, what);\n\n#ifdef HAVE_SOCKETS\n\t/*\n\t * Use /inet4 to force IPv4, /inet6 to force IPv6, and plain\n\t * /inet will be whatever we get back from the system.\n\t */\n\tif (inetfile(str, explen, & isi)) {\n\t\ttflag |= RED_SOCKET;\n\t\tif (isi.protocol == SOCK_STREAM)\n\t\t\ttflag |= RED_TCP;\t/* use shutdown when closing */\n\t}\n#endif /* HAVE_SOCKETS */\n\n\tfor (rp = red_head; rp != NULL; rp = rp->next) {\n#ifndef PIPES_SIMULATED\n\t\t/*\n\t\t * This is an efficiency hack.  We want to\n\t\t * recover the process slot for dead children,\n\t\t * if at all possible.  Messing with signal() for\n\t\t * SIGCLD leads to lots of headaches.  However, if\n\t\t * we've gotten EOF from a child input pipeline, it's\n\t\t * a good bet that the child has died. So recover it.\n\t\t */\n\t\tif ((rp->flag & RED_EOF) != 0 && redirtype == redirect_pipein) {\n\t\t\tif (rp->pid != -1)\n#ifdef __MINGW32__\n\t\t\t\t/* MinGW cannot wait for any process.  */\n\t\t\t\twait_any(rp->pid);\n#else\n\t\t\t\twait_any(0);\n#endif\n\t\t}\n#endif /* PIPES_SIMULATED */\n\n\t\t/* now check for a match */\n\t\tif (strlen(rp->value) == explen\n\t\t    && memcmp(rp->value, str, explen) == 0\n\t\t    && ((rp->flag & ~(RED_NOBUF|RED_EOF|RED_PTY)) == tflag\n\t\t\t|| (outflag != 0\n\t\t\t    && (rp->flag & (RED_FILE|RED_WRITE)) == outflag))) {\n\n\t\t\tint rpflag = (rp->flag & ~(RED_NOBUF|RED_EOF|RED_PTY));\n\t\t\tint newflag = (tflag & ~(RED_NOBUF|RED_EOF|RED_PTY));\n\n\t\t\tif (do_lint && rpflag != newflag)\n\t\t\t\tlintwarn(\n\t\t_(\"unnecessary mixing of `>' and `>>' for file `%.*s'\"),\n\t\t\t\t\t(int) explen, rp->value);\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (rp == NULL) {\n\t\tchar *newstr;\n\t\tnew_rp = true;\n\t\tif (save_rp != NULL) {\n\t\t\trp = save_rp;\n\t\t\tefree(rp->value);\n\t\t} else\n\t\t\temalloc(rp, struct redirect *, sizeof(struct redirect), \"redirect\");\n\t\temalloc(newstr, char *, explen + 1, \"redirect\");\n\t\tmemcpy(newstr, str, explen);\n\t\tnewstr[explen] = '\\0';\n\t\tstr = newstr;\n\t\trp->value = newstr;\n\t\trp->flag = tflag;\n\t\tinit_output_wrapper(& rp->output);\n\t\trp->output.name = str;\n\t\trp->iop = NULL;\n\t\trp->pid = -1;\n\t\trp->status = 0;\n\t} else\n\t\tstr = rp->value;\t/* get \\0 terminated string */\n\tsave_rp = rp;\n\n\twhile (rp->output.fp == NULL && rp->iop == NULL) {\n\t\tif (! new_rp && (rp->flag & RED_EOF) != 0) {\n\t\t\t/*\n\t\t\t * Encountered EOF on file or pipe -- must be cleared\n\t\t\t * by explicit close() before reading more\n\t\t\t */\n\t\t\tsave_rp = NULL;\n\t\t\treturn rp;\n\t\t}\n\t\tmode = NULL;\n\t\terrno = 0;\n\t\tswitch (redirtype) {\n\t\tcase redirect_output:\n\t\t\tmode = binmode(\"w\");\n\t\t\tif ((rp->flag & RED_USED) != 0)\n\t\t\t\tmode = (rp->mode[1] == 'b') ? \"ab\" : \"a\";\n\t\t\tbreak;\n\t\tcase redirect_append:\n\t\t\tmode = binmode(\"a\");\n\t\t\tbreak;\n\t\tcase redirect_pipe:\n\t\t\tif (extfd >= 0) {\n\t\t\t\twarning(_(\"get_file cannot create pipe `%s' with fd %d\"), str, extfd);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\t/* synchronize output before new pipe */\n\t\t\t(void) flush_io();\n\n\t\t\tos_restore_mode(fileno(stdin));\n\t\t\tset_sigpipe_to_default();\n\t\t\t/*\n\t\t\t * Don't check failure_fatal; see input pipe below.\n\t\t\t * Note that the failure happens upon failure to fork,\n\t\t\t * using a non-existant program will still succeed the\n\t\t\t * popen().\n\t\t\t */\n\t\t\tif ((rp->output.fp = popen(str, binmode(\"w\"))) == NULL)\n\t\t\t\tfatal(_(\"can't open pipe `%s' for output (%s)\"),\n\t\t\t\t\t\tstr, strerror(errno));\n\t\t\tignore_sigpipe();\n\n\t\t\t/* set close-on-exec */\n\t\t\tos_close_on_exec(fileno(rp->output.fp), str, \"pipe\", \"to\");\n\t\t\trp->flag |= RED_NOBUF;\n\t\t\tbreak;\n\t\tcase redirect_pipein:\n\t\t\tif (extfd >= 0) {\n\t\t\t\twarning(_(\"get_file cannot create pipe `%s' with fd %d\"), str, extfd);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tdirection = \"from\";\n\t\t\tif (gawk_popen(str, rp) == NULL)\n\t\t\t\tfatal(_(\"can't open pipe `%s' for input (%s)\"),\n\t\t\t\t\tstr, strerror(errno));\n\t\t\tbreak;\n\t\tcase redirect_input:\n\t\t\tdirection = \"from\";\n\t\t\tfd = (extfd >= 0) ? extfd : devopen(str, binmode(\"r\"));\n\t\t\tif (fd == INVALID_HANDLE && errno == EISDIR) {\n\t\t\t\t*errflg = EISDIR;\n\t\t\t\t/* do not free rp, saving it for reuse (save_rp = rp) */\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\trp->iop = iop_alloc(fd, str, errno);\n\t\t\tfind_input_parser(rp->iop);\n\t\t\tiop_finish(rp->iop);\n\t\t\tif (! rp->iop->valid) {\n\t\t\t\tif (! do_traditional && rp->iop->errcode != 0)\n\t\t\t\t\tupdate_ERRNO_int(rp->iop->errcode);\n\t\t\t\tiop_close(rp->iop);\n\t\t\t\trp->iop = NULL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase redirect_twoway:\n#ifndef HAVE_SOCKETS\n\t\t\tif (extfd >= 0) {\n\t\t\t\twarning(_(\"get_file socket creation not supported on this platform for `%s' with fd %d\"), str, extfd);\n\t\t\t\treturn NULL;\n\t\t\t}\n#endif\n\t\t\tdirection = \"to/from\";\n\t\t\tif (! two_way_open(str, rp, extfd)) {\n\t\t\t\tif (! failure_fatal || is_non_fatal_redirect(str, explen)) {\n\t\t\t\t\t*errflg = errno;\n\t\t\t\t\t/* do not free rp, saving it for reuse (save_rp = rp) */\n\t\t\t\t\treturn NULL;\n\t\t\t\t} else\n\t\t\t\t\tfatal(_(\"can't open two way pipe `%s' for input/output (%s)\"),\n\t\t\t\t\t\t\tstr, strerror(errno));\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcant_happen();\n\t\t}\n\n\t\tif (mode != NULL) {\n\t\t\terrno = 0;\n\t\t\trp->output.mode = mode;\n\t\t\tfd = (extfd >= 0) ? extfd : devopen(str, mode);\n\n\t\t\tif (fd > INVALID_HANDLE) {\n\t\t\t\tif (fd == fileno(stdin))\n\t\t\t\t\trp->output.fp = stdin;\n\t\t\t\telse if (fd == fileno(stdout))\n\t\t\t\t\trp->output.fp = stdout;\n\t\t\t\telse if (fd == fileno(stderr))\n\t\t\t\t\trp->output.fp = stderr;\n\t\t\t\telse {\n\t\t\t\t\tconst char *omode = mode;\n#if defined(F_GETFL) && defined(O_APPEND)\n\t\t\t\t\tint fd_flags;\n\n\t\t\t\t\tfd_flags = fcntl(fd, F_GETFL);\n\t\t\t\t\tif (fd_flags != -1 && (fd_flags & O_APPEND) == O_APPEND)\n\t\t\t\t\t\tomode = binmode(\"a\");\n#endif\n\t\t\t\t\tos_close_on_exec(fd, str, \"file\", \"\");\n\t\t\t\t\trp->output.fp = fdopen(fd, (const char *) omode);\n\t\t\t\t\trp->mode = (const char *) mode;\n\t\t\t\t\t/* don't leak file descriptors */\n\t\t\t\t\tif (rp->output.fp == NULL)\n\t\t\t\t\t\tclose(fd);\n\t\t\t\t}\n\t\t\t\tif (rp->output.fp != NULL && os_isatty(fd))\n\t\t\t\t\trp->flag |= RED_NOBUF;\n\n\t\t\t\t/* Move rp to the head of the list. */\n\t\t\t\tif (! new_rp && red_head != rp) {\n\t\t\t\t\tif ((rp->prev->next = rp->next) != NULL)\n\t\t\t\t\t\trp->next->prev = rp->prev;\n\t\t\t\t\tred_head->prev = rp;\n\t\t\t\t\trp->prev = NULL;\n\t\t\t\t\trp->next = red_head;\n\t\t\t\t\tred_head = rp;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfind_output_wrapper(& rp->output);\n\t\t}\n\n\t\tif (rp->output.fp == NULL && rp->iop == NULL) {\n\t\t\t/* too many files open -- close one and try again */\n\t\t\tif (errno == EMFILE || errno == ENFILE)\n\t\t\t\tclose_one();\n#ifdef VMS\n\t\t\t/* Alpha/VMS V7.1+ C RTL is returning these instead\n\t\t\t   of EMFILE (haven't tried other post-V6.2 systems) */\n\t\t\telse if ((errno == EIO || errno == EVMSERR) &&\n                                 (vaxc$errno == SS$_EXQUOTA ||\n                                  vaxc$errno == SS$_EXBYTLM ||\n                                  vaxc$errno == RMS$_ACC ||\n\t\t\t\t  vaxc$errno == RMS$_SYN)) {\n\t\t\t\tclose_one();\n\t\t\t\tclose_one();\n\t\t\t}\n#endif\n\t\t\telse {\n\t\t\t\t/*\n\t\t\t\t * Some other reason for failure.\n\t\t\t\t *\n\t\t\t\t * On redirection of input from a file,\n\t\t\t\t * just return an error, so e.g. getline\n\t\t\t\t * can return -1.  For output to file,\n\t\t\t\t * complain. The shell will complain on\n\t\t\t\t * a bad command to a pipe.\n\t\t\t\t *\n\t\t\t\t * 12/2014: Take nonfatal settings in PROCINFO into account.\n\t\t\t\t */\n\t\t\t\tif (errflg != NULL)\n\t\t\t\t\t*errflg = errno;\n\t\t\t\tif (failure_fatal && ! is_non_fatal_redirect(str, explen) &&\n\t\t\t\t    (redirtype == redirect_output\n\t\t\t\t     || redirtype == redirect_append)) {\n\t\t\t\t\t/* multiple messages make life easier for translators */\n\t\t\t\t\tif (*direction == 'f')\n\t\t\t\t\t\tfatal(_(\"can't redirect from `%s' (%s)\"),\n\t\t\t\t\t    \t\tstr, strerror(errno));\n\t\t\t\t\telse\n\t\t\t\t\t\tfatal(_(\"can't redirect to `%s' (%s)\"),\n\t\t\t\t\t\t\tstr, strerror(errno));\n\t\t\t\t} else {\n\t\t\t\t\t/* do not free rp, saving it for reuse (save_rp = rp) */\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (new_rp) {\n\t\t/*\n\t\t * It opened successfully, hook it into the list.\n\t\t * Maintain the list in most-recently-used first order.\n\t\t */\n\t\tif (red_head != NULL)\n\t\t\tred_head->prev = rp;\n\t\trp->prev = NULL;\n\t\trp->next = red_head;\n\t\tred_head = rp;\n\t}\n\tsave_rp = NULL;\n\treturn rp;\n}",
      "lines": 342,
      "depth": 20,
      "decorators": [
        "struct redirect",
        "struct",
        "redirect",
        "*\nredirect_string(const char *str, size_t explen, bool not_string,\n\t\tint redirtype, int *errflg, int extfd, bool failure_fatal)",
        "*"
      ]
    },
    "redirect": {
      "start_point": [
        1077,
        0
      ],
      "end_point": [
        1085,
        1
      ],
      "content": "struct redirect *\nredirect(NODE *redir_exp, int redirtype, int *errflg, bool failure_fatal)\n{\n\tbool not_string = ((fixtype(redir_exp)->flags & STRING) == 0);\n\n\tredir_exp = force_string(redir_exp);\n\treturn redirect_string(redir_exp->stptr, redir_exp->stlen, not_string,\n\t\t\t\tredirtype, errflg, -1, failure_fatal);\n}",
      "lines": 9,
      "depth": 12,
      "decorators": [
        "struct redirect",
        "struct",
        "redirect",
        "*\nredirect(NODE *redir_exp, int redirtype, int *errflg, bool failure_fatal)",
        "*"
      ]
    },
    "getredirect": {
      "start_point": [
        1089,
        0
      ],
      "end_point": [
        1099,
        1
      ],
      "content": "struct redirect *\ngetredirect(const char *str, int len)\n{\n\tstruct redirect *rp;\n\n\tfor (rp = red_head; rp != NULL; rp = rp->next)\n\t\tif (strlen(rp->value) == len && memcmp(rp->value, str, len) == 0)\n\t\t\treturn rp;\n\n\treturn NULL;\n}",
      "lines": 11,
      "depth": 11,
      "decorators": [
        "struct redirect",
        "struct",
        "redirect",
        "*\ngetredirect(const char *str, int len)",
        "*"
      ]
    },
    "is_non_fatal_std": {
      "start_point": [
        1103,
        0
      ],
      "end_point": [
        1118,
        1
      ],
      "content": "bool\nis_non_fatal_std(FILE *fp)\n{\n\tif (in_PROCINFO(nonfatal, NULL, NULL))\n\t\treturn true;\n\n\t/* yucky logic. sigh. */\n\tif (fp == stdout) {\n\t\treturn (   in_PROCINFO(\"-\", nonfatal, NULL) != NULL\n\t\t        || in_PROCINFO(\"/dev/stdout\", nonfatal, NULL) != NULL);\n\t} else if (fp == stderr) {\n\t\treturn (in_PROCINFO(\"/dev/stderr\", nonfatal, NULL) != NULL);\n\t}\n\n\treturn false;\n}",
      "lines": 16,
      "depth": 12,
      "decorators": [
        "bool"
      ]
    },
    "is_non_fatal_redirect": {
      "start_point": [
        1122,
        0
      ],
      "end_point": [
        1138,
        1
      ],
      "content": "bool\nis_non_fatal_redirect(const char *str, size_t len)\n{\n\tbool ret;\n\tchar save;\n\tchar *s = (char *) str;\n\n\tsave = s[len];\n\ts[len] = '\\0';\n\n\tret = in_PROCINFO(nonfatal, NULL, NULL) != NULL\n\t       || in_PROCINFO(s, nonfatal, NULL) != NULL;\n\n\ts[len] = save;\n\n\treturn ret;\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    },
    "close_one": {
      "start_point": [
        1142,
        0
      ],
      "end_point": [
        1177,
        1
      ],
      "content": "static void\nclose_one()\n{\n\tstruct redirect *rp;\n\tstruct redirect *rplast = NULL;\n\n\tstatic bool warned = false;\n\n\tif (do_lint && ! warned) {\n\t\twarned = true;\n\t\tlintwarn(_(\"reached system limit for open files: starting to multiplex file descriptors\"));\n\t}\n\n\t/* go to end of list first, to pick up least recently used entry */\n\tfor (rp = red_head; rp != NULL; rp = rp->next)\n\t\trplast = rp;\n\t/* now work back up through the list */\n\tfor (rp = rplast; rp != NULL; rp = rp->prev) {\n\t\t/* don't close standard files! */\n\t\tif (rp->output.fp == NULL || rp->output.fp == stderr || rp->output.fp == stdout)\n\t\t\tcontinue;\n\n\t\tif ((rp->flag & (RED_FILE|RED_WRITE)) == (RED_FILE|RED_WRITE)) {\n\t\t\trp->flag |= RED_USED;\n\t\t\terrno = 0;\n\t\t\tif (rp->output.gawk_fclose(rp->output.fp, rp->output.opaque) != 0)\n\t\t\t\twarning(_(\"close of `%s' failed (%s).\"),\n\t\t\t\t\trp->value, strerror(errno));\n\t\t\trp->output.fp = NULL;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (rp == NULL)\n\t\t/* surely this is the only reason ??? */\n\t\tfatal(_(\"too many pipes or input files open\"));\n}",
      "lines": 36,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "do_close": {
      "start_point": [
        1181,
        0
      ],
      "end_point": [
        1248,
        1
      ],
      "content": "NODE *\ndo_close(int nargs)\n{\n\tNODE *tmp, *tmp2;\n\tstruct redirect *rp;\n\ttwo_way_close_type how = CLOSE_ALL;\t/* default */\n\n\tif (nargs == 2) {\n\t\t/* 2nd arg if present: \"to\" or \"from\" for two-way pipe */\n\t\t/* DO NOT use _() on the strings here! */\n\t\tchar save;\n\n\t\ttmp2 = POP_STRING();\n\t\tsave = tmp2->stptr[tmp2->stlen];\n\t\ttmp2->stptr[tmp2->stlen] = '\\0';\n\t\tif (strcasecmp(tmp2->stptr, \"to\") == 0)\n\t\t\thow = CLOSE_TO;\n\t\telse if (strcasecmp(tmp2->stptr, \"from\") == 0)\n\t\t\thow = CLOSE_FROM;\n\t\telse {\n\t\t\tDEREF(tmp2);\n\t\t\tfatal(_(\"close: second argument must be `to' or `from'\"));\n\t\t}\n\t\ttmp2->stptr[tmp2->stlen] = save;\n\t\tDEREF(tmp2);\n\t}\n\n\ttmp = POP_STRING(); \t/* 1st arg: redir to close */\n\n\tfor (rp = red_head; rp != NULL; rp = rp->next) {\n\t\tif (strlen(rp->value) == tmp->stlen\n\t\t    && memcmp(rp->value, tmp->stptr, tmp->stlen) == 0)\n\t\t\tbreak;\n\t}\n\n\tif (rp == NULL) {\t/* no match, return -1 */\n\t\tchar *cp;\n\n\t\tif (do_lint)\n\t\t\tlintwarn(_(\"close: `%.*s' is not an open file, pipe or co-process\"),\n\t\t\t\t(int) tmp->stlen, tmp->stptr);\n\n\t\tif (! do_traditional) {\n\t\t\t/* update ERRNO manually, using errno = ENOENT is a stretch. */\n\t\t\tcp = _(\"close of redirection that was never opened\");\n\t\t\tupdate_ERRNO_string(cp);\n\t\t}\n\n\t\tDEREF(tmp);\n\t\treturn make_number((AWKNUM) -1.0);\n\t}\n\tDEREF(tmp);\n\tfflush(stdout);\t/* synchronize regular output */\n\ttmp = make_number((AWKNUM) close_redir(rp, false, how));\n\trp = NULL;\n\t/*\n\t * POSIX says close() returns 0 on success, non-zero otherwise.\n\t * For POSIX, at this point we just return 0.  Otherwise we\n\t * return the exit status of the process or of pclose(), depending.\n\t * Down in the call tree of close_redir(), we rationalize the\n\t * value like we do for system().\n\t */\n\tif (do_posix) {\n\t\tunref(tmp);\n\t\ttmp = make_number((AWKNUM) 0);\n\t}\n\treturn tmp;\n}",
      "lines": 68,
      "depth": 14,
      "decorators": [
        "NODE",
        "*\ndo_close(int nargs)",
        "*"
      ]
    },
    "close_rp": {
      "start_point": [
        1252,
        0
      ],
      "end_point": [
        1309,
        1
      ],
      "content": "int\nclose_rp(struct redirect *rp, two_way_close_type how)\n{\n\tint status = 0;\n\n\terrno = 0;\n\tif ((rp->flag & RED_TWOWAY) != 0) {\t/* two-way pipe */\n\t\t/* write end: */\n\t\tif ((how == CLOSE_ALL || how == CLOSE_TO) && rp->output.fp != NULL) {\n#ifdef HAVE_SOCKETS\n\t\t\tif ((rp->flag & RED_TCP) != 0)\n\t\t\t\t(void) shutdown(fileno(rp->output.fp), SHUT_WR);\n#endif /* HAVE_SOCKETS */\n\n\t\t\tif ((rp->flag & RED_PTY) != 0) {\n\t\t\t\trp->output.gawk_fwrite(\"\\004\\n\", sizeof(\"\\004\\n\") - 1, 1, rp->output.fp, rp->output.opaque);\n\t\t\t\trp->output.gawk_fflush(rp->output.fp, rp->output.opaque);\n\t\t\t}\n\t\t\tstatus = rp->output.gawk_fclose(rp->output.fp, rp->output.opaque);\n\t\t\trp->output.fp = NULL;\n\t\t}\n\n\t\t/* read end: */\n\t\tif (how == CLOSE_ALL || how == CLOSE_FROM) {\n\t\t\tif ((rp->flag & RED_SOCKET) != 0 && rp->iop != NULL) {\n#ifdef HAVE_SOCKETS\n\t\t\t\tif ((rp->flag & RED_TCP) != 0)\n\t\t\t\t\t(void) shutdown(rp->iop->public.fd, SHUT_RD);\n#endif /* HAVE_SOCKETS */\n\t\t\t\t(void) iop_close(rp->iop);\n\t\t\t} else\n\t\t\t\t/* status already sanitized */\n\t\t\t\tstatus = gawk_pclose(rp);\n\n\t\t\trp->iop = NULL;\n\t\t}\n\t} else if ((rp->flag & (RED_PIPE|RED_WRITE)) == (RED_PIPE|RED_WRITE)) {\n\t\t/* write to pipe */\n\t\tstatus = sanitize_exit_status(pclose(rp->output.fp));\n\t\tif ((BINMODE & BINMODE_INPUT) != 0)\n\t\t\tos_setbinmode(fileno(stdin), O_BINARY);\n\n\t\trp->output.fp = NULL;\n\t} else if (rp->output.fp != NULL) {\t/* write to file */\n\t\tstatus = rp->output.gawk_fclose(rp->output.fp, rp->output.opaque);\n\t\trp->output.fp = NULL;\n\t} else if (rp->iop != NULL) {\t/* read from pipe/file */\n\t\tif ((rp->flag & RED_PIPE) != 0)\t\t/* read from pipe */\n\t\t\tstatus = gawk_pclose(rp);\n\t\t\t/* gawk_pclose sets rp->iop to null */\n\t\telse {\t\t\t\t\t/* read from file */\n\t\t\tstatus = iop_close(rp->iop);\n\t\t\trp->iop = NULL;\n\t\t}\n\t}\n\n\treturn status;\n}",
      "lines": 58,
      "depth": 18,
      "decorators": [
        "int"
      ]
    },
    "close_redir": {
      "start_point": [
        1313,
        0
      ],
      "end_point": [
        1389,
        1
      ],
      "content": "static int\nclose_redir(struct redirect *rp, bool exitwarn, two_way_close_type how)\n{\n\tint status = 0;\n\n\tif (rp == NULL)\n\t\treturn 0;\n\tif (rp->output.fp == stdout || rp->output.fp == stderr)\n\t\tgoto checkwarn;\t\t/* bypass closing, remove from list */\n\n\tif (do_lint && (rp->flag & RED_TWOWAY) == 0 && how != CLOSE_ALL)\n\t\tlintwarn(_(\"close: redirection `%s' not opened with `|&', second argument ignored\"),\n\t\t\t\trp->value);\n\n\tstatus = close_rp(rp, how);\n\n\tif (status != 0) {\n\t\tint save_errno = errno;\n\t\tchar *s = strerror(save_errno);\n\n\t\t/*\n\t\t * BWK's awk, as far back as SVR4 (1989) would check\n\t\t * and warn about the status of close.  However, when\n\t\t * we did this we got too many complaints, so we moved\n\t\t * it to be under lint control.\n\t\t */\n\t\tif (do_lint) {\n\t\t\tif ((rp->flag & RED_PIPE) != 0)\n\t\t\t\tlintwarn(_(\"failure status (%d) on pipe close of `%s' (%s)\"),\n\t\t\t\t\t status, rp->value, s);\n\t\t\telse\n\t\t\t\tlintwarn(_(\"failure status (%d) on file close of `%s' (%s)\"),\n\t\t\t\t\t status, rp->value, s);\n\t\t}\n\n\t\tif (! do_traditional) {\n\t\t\t/* set ERRNO too so that program can get at it */\n\t\t\tupdate_ERRNO_int(save_errno);\n\t\t}\n\t}\n\ncheckwarn:\n\tif (exitwarn) {\n\t\t/*\n\t\t * Don't use lintwarn() here.  If lint warnings are fatal,\n\t\t * doing so prevents us from closing other open redirections.\n\t\t *\n\t\t * Using multiple full messages instead of string parameters\n\t\t * for the types makes message translation easier.\n\t\t */\n\t\tif ((rp->flag & RED_SOCKET) != 0)\n\t\t\twarning(_(\"no explicit close of socket `%s' provided\"),\n\t\t\t\trp->value);\n\t\telse if ((rp->flag & RED_TWOWAY) != 0)\n\t\t\twarning(_(\"no explicit close of co-process `%s' provided\"),\n\t\t\t\trp->value);\n\t\telse if ((rp->flag & RED_PIPE) != 0)\n\t\t\twarning(_(\"no explicit close of pipe `%s' provided\"),\n\t\t\t\trp->value);\n\t\telse\n\t\t\twarning(_(\"no explicit close of file `%s' provided\"),\n\t\t\t\trp->value);\n\t}\n\n\t/* remove it from the list if closing both or both ends have been closed */\n\tif (how == CLOSE_ALL || (rp->iop == NULL && rp->output.fp == NULL)) {\n\t\tif (rp->next != NULL)\n\t\t\trp->next->prev = rp->prev;\n\t\tif (rp->prev != NULL)\n\t\t\trp->prev->next = rp->next;\n\t\telse\n\t\t\tred_head = rp->next;\n\t\tfree_rp(rp);\n\t}\n\n\treturn status;\n}",
      "lines": 77,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "non_fatal_flush_std_file": {
      "start_point": [
        1393,
        0
      ],
      "end_point": [
        1424,
        1
      ],
      "content": "bool\nnon_fatal_flush_std_file(FILE *fp)\n{\n\tint status = fflush(fp);\n\n\tif (status != 0) {\n\t\tbool is_fatal = ! is_non_fatal_std(fp);\n\n\t\tif (is_fatal) {\n#ifdef __MINGW32__\n\t\t\tif (errno == 0 || errno == EINVAL)\n\t\t\t\tw32_maybe_set_errno();\n#endif\n\t\t\tif (errno == EPIPE)\n\t\t\t\tdie_via_sigpipe();\n\t\t\telse\n\t\t\t\tfatal(fp == stdout\n\t\t\t\t\t? _(\"fflush: cannot flush standard output: %s\")\n\t\t\t\t\t: _(\"fflush: cannot flush standard error: %s\"),\n\t\t\t\t\t\tstrerror(errno));\n\t\t} else {\n\t\t\tupdate_ERRNO_int(errno);\n\t\t\twarning(fp == stdout\n\t\t\t\t? _(\"error writing standard output (%s)\")\n\t\t\t\t: _(\"error writing standard error (%s)\"),\n\t\t\t\t\tstrerror(errno));\n\t\t}\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
      "lines": 32,
      "depth": 15,
      "decorators": [
        "bool"
      ]
    },
    "flush_io": {
      "start_point": [
        1428,
        0
      ],
      "end_point": [
        1471,
        1
      ],
      "content": "int\nflush_io()\n{\n\tstruct redirect *rp;\n\tint status = 0;\n\n\terrno = 0;\n\tif (! non_fatal_flush_std_file(stdout))\t// ERRNO updated\n\t\tstatus++;\n\n\terrno = 0;\n\tif (! non_fatal_flush_std_file(stderr))\t// ERRNO updated\n\t\tstatus++;\n\n\n\t// now for all open redirections\n\tfor (rp = red_head; rp != NULL; rp = rp->next) {\n\t\tvoid (*messagefunc)(const char *mesg, ...) = r_fatal;\n\n\t\t/* flush both files and pipes, what the heck */\n\t\tif ((rp->flag & RED_WRITE) != 0 && rp->output.fp != NULL) {\n\t\t\tif (rp->output.gawk_fflush(rp->output.fp, rp->output.opaque) != 0) {\n\t\t\t\tupdate_ERRNO_int(errno);\n\n\t\t\t\tif (is_non_fatal_redirect(rp->value, strlen(rp->value)))\n\t\t\t\t\tmessagefunc = r_warning;\n\n\t\t\t\tif ((rp->flag & RED_PIPE) != 0)\n\t\t\t\t\tmessagefunc(_(\"pipe flush of `%s' failed (%s).\"),\n\t\t\t\t\t\trp->value, strerror(errno));\n\t\t\t\telse if ((rp->flag & RED_TWOWAY) != 0)\n\t\t\t\t\tmessagefunc(_(\"co-process flush of pipe to `%s' failed (%s).\"),\n\t\t\t\t\t\trp->value, strerror(errno));\n\t\t\t\telse\n\t\t\t\t\tmessagefunc(_(\"file flush of `%s' failed (%s).\"),\n\t\t\t\t\t\trp->value, strerror(errno));\n\t\t\t\tstatus++;\n\t\t\t}\n\t\t}\n\t}\n\tif (status != 0)\n\t\tstatus = -1;\t/* canonicalize it */\n\treturn status;\n}",
      "lines": 44,
      "depth": 17,
      "decorators": [
        "int"
      ]
    },
    "close_io": {
      "start_point": [
        1475,
        0
      ],
      "end_point": [
        1521,
        1
      ],
      "content": "int\nclose_io(bool *stdio_problem)\n{\n\tstruct redirect *rp;\n\tstruct redirect *next;\n\tint status = 0;\n\n\terrno = 0;\n\tfor (rp = red_head; rp != NULL; rp = next) {\n\t\tnext = rp->next;\n\t\t/*\n\t\t * close_redir() will print a message if needed.\n\t\t * if do_lint, warn about lack of explicit close\n\t\t */\n\t\tif (close_redir(rp, do_lint, CLOSE_ALL))\n\t\t\tstatus++;\n\t\trp = NULL;\n\t}\n\t/*\n\t * Some of the non-Unix os's have problems doing an fclose()\n\t * on stdout and stderr.  Since we don't really need to close\n\t * them, we just flush them, and do that across the board.\n\t */\n\t*stdio_problem = false;\n\t/* we don't warn about stdout/stderr if EPIPE, but we do error exit */\n\tif (fflush(stdout) != 0) {\n#ifdef __MINGW32__\n\t\tif (errno == 0 || errno == EINVAL)\n\t\t\tw32_maybe_set_errno();\n#endif\n\t\tif (errno != EPIPE)\n\t\t\twarning(_(\"error writing standard output (%s)\"), strerror(errno));\n\t\tstatus++;\n\t\t*stdio_problem = true;\n\t}\n\tif (fflush(stderr) != 0) {\n#ifdef __MINGW32__\n\t\tif (errno == 0 || errno == EINVAL)\n\t\t\tw32_maybe_set_errno();\n#endif\n\t\tif (errno != EPIPE)\n\t\t\twarning(_(\"error writing standard error (%s)\"), strerror(errno));\n\t\tstatus++;\n\t\t*stdio_problem = true;\n\t}\n\treturn status;\n}",
      "lines": 47,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "str2mode": {
      "start_point": [
        1525,
        0
      ],
      "end_point": [
        1560,
        1
      ],
      "content": "static int\nstr2mode(const char *mode)\n{\n\tint ret;\n\tconst char *second = & mode[1];\n\n\tif (*second == 'b')\n\t\tsecond++;\n\n\tswitch(mode[0]) {\n\tcase 'r':\n\t\tret = O_RDONLY;\n\t\tif (*second == '+' || *second == 'w')\n\t\t\tret = O_RDWR;\n\t\tbreak;\n\n\tcase 'w':\n\t\tret = O_WRONLY|O_CREAT|O_TRUNC;\n\t\tif (*second == '+' || *second == 'r')\n\t\t\tret = O_RDWR|O_CREAT|O_TRUNC;\n\t\tbreak;\n\n\tcase 'a':\n\t\tret = O_WRONLY|O_APPEND|O_CREAT;\n\t\tif (*second == '+')\n\t\t\tret = O_RDWR|O_APPEND|O_CREAT;\n\t\tbreak;\n\n\tdefault:\n\t\tret = 0;\t\t/* lint */\n\t\tcant_happen();\n\t}\n\tif (strchr(mode, 'b') != NULL)\n\t\tret |= O_BINARY;\n\treturn ret;\n}",
      "lines": 36,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "socketopen": {
      "start_point": [
        1566,
        0
      ],
      "end_point": [
        1714,
        1
      ],
      "content": "static int\nsocketopen(int family, int type, const char *localpname,\n\tconst char *remotepname, const char *remotehostname, bool *hard_error)\n{\n\tstruct addrinfo *lres, *lres0;\n\tstruct addrinfo lhints;\n\tstruct addrinfo *rres, *rres0;\n\tstruct addrinfo rhints;\n\n\tint lerror, rerror;\n\n\tint socket_fd = INVALID_HANDLE;\n\tint any_remote_host = (strcmp(remotehostname, \"0\") == 0);\n\n\tmemset(& lhints, '\\0', sizeof (lhints));\n\n\tlhints.ai_socktype = type;\n\tlhints.ai_family = family;\n\n\t/*\n         * If only the loopback interface is up and hints.ai_flags has\n\t * AI_ADDRCONFIG, getaddrinfo() will succeed and return all wildcard\n\t * addresses, but only if hints.ai_family == AF_UNSPEC\n\t *\n\t * Do return the wildcard address in case the loopback interface\n\t * is the only one that is up (and\n\t * hints.ai_family == either AF_INET4 or AF_INET6)\n         */\n\tlhints.ai_flags = AI_PASSIVE;\n\tif (lhints.ai_family == AF_UNSPEC)\n\t\tlhints.ai_flags |= AI_ADDRCONFIG;\n\n\tlerror = getaddrinfo(NULL, localpname, & lhints, & lres);\n\tif (lerror) {\n\t\tif (strcmp(localpname, \"0\") != 0) {\n#ifdef HAVE_GAI_STRERROR\n\t\t\twarning(_(\"local port %s invalid in `/inet': %s\"), localpname,\n\t\t\t\t\tgai_strerror(lerror));\n#else\n\t\t\twarning(_(\"local port %s invalid in `/inet'\"), localpname);\n#endif\n\t\t\t*hard_error = true;\n\t\t\treturn INVALID_HANDLE;\n\t\t}\n\t\tlres0 = NULL;\n\t\tlres = & lhints;\n\t} else\n\t\tlres0 = lres;\n\n\twhile (lres != NULL) {\n\t\tmemset (& rhints, '\\0', sizeof (rhints));\n\t\trhints.ai_flags = lhints.ai_flags;\n\t\trhints.ai_socktype = lhints.ai_socktype;\n\t\trhints.ai_family = lhints.ai_family;\n\t\trhints.ai_protocol = lhints.ai_protocol;\n\n\t\trerror = getaddrinfo(any_remote_host ? NULL : remotehostname,\n\t\t\t\tremotepname, & rhints, & rres);\n\t\tif (rerror) {\n\t\t\tif (lres0 != NULL)\n\t\t\t\tfreeaddrinfo(lres0);\n#ifdef HAVE_GAI_STRERROR\n\t\t\twarning(_(\"remote host and port information (%s, %s) invalid: %s\"), remotehostname, remotepname,\n\t\t\t\t\tgai_strerror(rerror));\n#else\n\t\t\twarning(_(\"remote host and port information (%s, %s) invalid\"), remotehostname, remotepname);\n#endif\n\t\t\t*hard_error = true;\n\t\t\treturn INVALID_HANDLE;\n\t\t}\n\t\trres0 = rres;\n\t\tsocket_fd = INVALID_HANDLE;\n\t\twhile (rres != NULL) {\n\t\t\tsocket_fd = socket(rres->ai_family,\n\t\t\t\trres->ai_socktype, rres->ai_protocol);\n\t\t\tif (socket_fd < 0 || socket_fd == INVALID_HANDLE)\n\t\t\t\tgoto nextrres;\n\n\t\t\tif (type == SOCK_STREAM) {\n\t\t\t\tint on = 1;\n#ifdef SO_LINGER\n\t\t\t\tstruct linger linger;\n\t\t\t\tmemset(& linger, '\\0', sizeof(linger));\n#endif\n\t\t\t\tsetsockopt(socket_fd, SOL_SOCKET, SO_REUSEADDR,\n\t\t\t\t\t(char *) & on, sizeof(on));\n#ifdef SO_LINGER\n\t\t\t\tlinger.l_onoff = 1;\n\t\t\t\t/* linger for 30/100 second */\n\t\t\t\tlinger.l_linger = 30;\n\t\t\t\tsetsockopt(socket_fd, SOL_SOCKET, SO_LINGER,\n\t\t\t\t\t(char *) & linger, sizeof(linger));\n#endif\n\t\t\t}\n\t\t\tif (bind(socket_fd, lres->ai_addr, lres->ai_addrlen) != 0)\n\t\t\t\tgoto nextrres;\n\n\t\t\tif (! any_remote_host) { /* not ANY => create a client */\n\t\t\t\tif (connect(socket_fd, rres->ai_addr, rres->ai_addrlen) == 0)\n\t\t\t\t\tbreak;\n\t\t\t} else { /* remote host is ANY => create a server */\n\t\t\t\tif (type == SOCK_STREAM) {\n\t\t\t\t\tint clientsocket_fd = INVALID_HANDLE;\n\n\t\t\t\t\tstruct sockaddr_storage remote_addr;\n\t\t\t\t\tsocklen_t namelen = sizeof(remote_addr);\n\n\t\t\t\t\tif (listen(socket_fd, 1) >= 0\n\t\t\t\t\t    && (clientsocket_fd = accept(socket_fd,\n\t\t\t\t\t\t(struct sockaddr *) & remote_addr,\n\t\t\t\t\t\t& namelen)) >= 0) {\n\t\t\t\t\t\tclosemaybesocket(socket_fd);\n\t\t\t\t\t\tsocket_fd = clientsocket_fd;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else if (type == SOCK_DGRAM) {\n#ifdef MSG_PEEK\n\t\t\t\t\tchar buf[10];\n\t\t\t\t\tstruct sockaddr_storage remote_addr;\n\t\t\t\t\tsocklen_t read_len = sizeof(remote_addr);\n\n\t\t\t\t\tif (recvfrom(socket_fd, buf, 1, MSG_PEEK,\n\t\t\t\t\t\t(struct sockaddr *) & remote_addr,\n\t\t\t\t\t\t\t& read_len) >= 0\n\t\t\t\t\t\t\t&& read_len\n\t\t\t\t\t\t\t&& connect(socket_fd,\n\t\t\t\t\t\t(struct sockaddr *) & remote_addr,\n\t\t\t\t\t\t\t\tread_len) == 0)\n\t\t\t\t\t\t\tbreak;\n#endif\n\t\t\t\t}\n\t\t\t}\n\nnextrres:\n\t\t\tif (socket_fd != INVALID_HANDLE)\n\t\t\t\tclosemaybesocket(socket_fd);\n\t\t\tsocket_fd = INVALID_HANDLE;\n\t\t\trres = rres->ai_next;\n\t\t}\n\t\tfreeaddrinfo(rres0);\n\t\tif (socket_fd != INVALID_HANDLE)\n\t\t\tbreak;\n\t\tlres = lres->ai_next;\n\t}\n\tif (lres0)\n\t\tfreeaddrinfo(lres0);\n\n\treturn socket_fd;\n}",
      "lines": 149,
      "depth": 23,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "devopen_simple": {
      "start_point": [
        1731,
        0
      ],
      "end_point": [
        1784,
        1
      ],
      "content": "int\ndevopen_simple(const char *name, const char *mode, bool try_real_open)\n{\n\tint openfd;\n\tchar *cp;\n\tchar *ptr;\n\tint flag = 0;\n\n\tif (strcmp(name, \"-\") == 0) {\n\t\tif (mode[0] == 'r')\n\t\t\treturn fileno(stdin);\n\t\telse\n\t\t\treturn fileno(stdout);\n\t}\n\n\tflag = str2mode(mode);\n\topenfd = INVALID_HANDLE;\n\n\tif (do_posix)\n\t\tgoto done;\n\n\tif ((openfd = os_devopen(name, flag)) != INVALID_HANDLE) {\n\t\tos_close_on_exec(openfd, name, \"file\", \"\");\n\t\treturn openfd;\n\t}\n\n\tif (strncmp(name, \"/dev/\", 5) == 0) {\n\t\tcp = (char *) name + 5;\n\n\t\tif (strcmp(cp, \"stdin\") == 0 && (flag & O_ACCMODE) == O_RDONLY)\n\t\t\topenfd = fileno(stdin);\n\t\telse if (strcmp(cp, \"stdout\") == 0 && (flag & O_ACCMODE) == O_WRONLY)\n\t\t\topenfd = fileno(stdout);\n\t\telse if (strcmp(cp, \"stderr\") == 0 && (flag & O_ACCMODE) == O_WRONLY)\n\t\t\topenfd = fileno(stderr);\n\t\telse if (do_traditional)\n\t\t\tgoto done;\n\t\telse if (strncmp(cp, \"fd/\", 3) == 0) {\n\t\t\tstruct stat sbuf;\n\n\t\t\tcp += 3;\n\t\t\topenfd = (int) strtoul(cp, & ptr, 10);\n\t\t\tif (openfd <= INVALID_HANDLE || ptr == cp\n\t\t\t    || fstat(openfd, & sbuf) < 0)\n\t\t\t\topenfd = INVALID_HANDLE;\n\t\t}\n\t\t/* do not set close-on-exec for inherited fd's */\n\t}\ndone:\n\tif (try_real_open)\n\t\topenfd = open(name, flag, 0666);\n\n\treturn openfd;\n}",
      "lines": 54,
      "depth": 18,
      "decorators": [
        "int"
      ]
    },
    "devopen": {
      "start_point": [
        1793,
        0
      ],
      "end_point": [
        1905,
        1
      ],
      "content": "int\ndevopen(const char *name, const char *mode)\n{\n\tint openfd;\n\tint flag;\n\tstruct inet_socket_info isi;\n\tint save_errno = 0;\n\n\topenfd = devopen_simple(name, mode, false);\n\tif (openfd != INVALID_HANDLE)\n\t\treturn openfd;\n\n\tflag = str2mode(mode);\n\n\tif (do_traditional) {\n\t\tgoto strictopen;\n\t} else if (inetfile(name, strlen(name), & isi)) {\n#ifdef HAVE_SOCKETS\n#define DEFAULT_RETRIES 20\n\t\tstatic unsigned long def_retries = DEFAULT_RETRIES;\n\t\tstatic bool first_time = true;\n\t\tunsigned long retries = 0;\n\t\tstatic long msleep = 1000;\n\t\tbool hard_error = false;\n\t\tbool non_fatal = is_non_fatal_redirect(name, strlen(name));\n\t\tchar save;\n\t\tchar *cp = (char *) name;\n\n\t\t/* socketopen requires NUL-terminated strings */\n\t\tcp[isi.localport.offset+isi.localport.len] = '\\0';\n\t\tcp[isi.remotehost.offset+isi.remotehost.len] = '\\0';\n\t\tsave = cp[isi.remoteport.offset+isi.remoteport.len];\n\t\tcp[isi.remoteport.offset+isi.remoteport.len] = '\\0';\n\n\t\tif (first_time) {\n\t\t\tchar *cp, *end;\n\t\t\tunsigned long count = 0;\n\t\t\tchar *ms2;\n\n\t\t\tfirst_time = false;\n\t\t\tif ((cp = getenv(\"GAWK_SOCK_RETRIES\")) != NULL) {\n\t\t\t\tcount = strtoul(cp, & end, 10);\n\t\t\t\tif (end != cp && count > 0)\n\t\t\t\t\tdef_retries = count;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Env var is in milliseconds, paramter to usleep()\n\t\t\t * is microseconds, make the conversion. Default is\n\t\t\t * 1 millisecond.\n\t\t\t */\n\t\t\tif ((ms2 = getenv(\"GAWK_MSEC_SLEEP\")) != NULL) {\n\t\t\t\tmsleep = strtol(ms2, & end, 10);\n\t\t\t\tif (end == ms2 || msleep < 0)\n\t\t\t\t\tmsleep = 1000;\n\t\t\t\telse\n\t\t\t\t\tmsleep *= 1000;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * PROCINFO[\"NONFATAL\"] or PROCINFO[name, \"NONFATAL\"] overrrides\n\t\t * GAWK_SOCK_RETRIES.  The explicit code in the program carries\n\t\t * a bigger stick than the environment variable does.\n\t\t */\n\t\tretries = non_fatal ? 1 : def_retries;\n\n\t\terrno = 0;\n\t\tdo {\n\t\t\topenfd = socketopen(isi.family, isi.protocol, name+isi.localport.offset,\n\t\t\t\t\tname+isi.remoteport.offset, name+isi.remotehost.offset,\n\t\t\t\t\t& hard_error);\n\t\t\tretries--;\n\t\t} while (openfd == INVALID_HANDLE && ! hard_error && retries > 0 && usleep(msleep) == 0);\n\t\tsave_errno = errno;\n\n\t\t/* restore original name string */\n\t\tcp[isi.localport.offset+isi.localport.len] = '/';\n\t\tcp[isi.remotehost.offset+isi.remotehost.len] = '/';\n\t\tcp[isi.remoteport.offset+isi.remoteport.len] = save;\n#else /* ! HAVE_SOCKETS */\n\t\tfatal(_(\"TCP/IP communications are not supported\"));\n#endif /* HAVE_SOCKETS */\n\t}\n\nstrictopen:\n\tif (openfd == INVALID_HANDLE) {\n\t\topenfd = open(name, flag, 0666);\n\t\t/*\n\t\t * ENOENT means there is no such name in the filesystem.\n\t\t * Therefore it's ok to propagate up the error from\n\t\t * getaddrinfo() that's in save_errno.\n\t\t */\n\t\tif (openfd == INVALID_HANDLE && errno == ENOENT && save_errno)\n\t\t\terrno = save_errno;\n\t}\n#if defined(__EMX__) || defined(__MINGW32__)\n\tif (openfd == INVALID_HANDLE && errno == EACCES) {\n\t\t/* On OS/2 and Windows directory access via open() is\n\t\t   not permitted.  */\n\t\tstruct stat buf;\n\n\t\tif (! inetfile(name, strlen(name), NULL)\n\t\t    && stat(name, & buf) == 0 && S_ISDIR(buf.st_mode))\n\t\t\terrno = EISDIR;\n\t}\n#endif\n\tif (openfd != INVALID_HANDLE) {\n\t\tif (openfd > fileno(stderr))\n\t\t\tos_close_on_exec(openfd, name, \"file\", \"\");\n\t}\n\n\treturn openfd;\n}",
      "lines": 113,
      "depth": 17,
      "decorators": [
        "int"
      ]
    },
    "set_slave_pty_attributes": {
      "start_point": [
        1936,
        0
      ],
      "end_point": [
        1967,
        1
      ],
      "content": "static void\nset_slave_pty_attributes(int slave)\n{\n\tstruct termios st;\n\n\ttcgetattr(slave, & st);\n\tst.c_iflag &= ~(ISTRIP | IGNCR | INLCR | IXOFF);\n\tst.c_iflag |= (ICRNL | IGNPAR | BRKINT | IXON);\n\tst.c_oflag &= ~OPOST;\n\tst.c_cflag &= ~CSIZE;\n\tst.c_cflag |= CREAD | CS8 | CLOCAL;\n\tst.c_lflag &= ~(ECHO | ECHOE | ECHOK | NOFLSH | TOSTOP);\n\tst.c_lflag |= ISIG;\n\n\t/* Set some control codes to default values */\n#ifdef VINTR\n\tst.c_cc[VINTR] = '\\003';        /* ^c */\n#endif\n#ifdef VQUIT\n\tst.c_cc[VQUIT] = '\\034';        /* ^| */\n#endif\n#ifdef VERASE\n\tst.c_cc[VERASE] = '\\177';       /* ^? */\n#endif\n#ifdef VKILL\n\tst.c_cc[VKILL] = '\\025';        /* ^u */\n#endif\n#ifdef VEOF\n\tst.c_cc[VEOF] = '\\004'; /* ^d */\n#endif\n\ttcsetattr(slave, TCSANOW, & st);\n}",
      "lines": 32,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "wait_any": {
      "start_point": [
        2506,
        0
      ],
      "end_point": [
        2585,
        1
      ],
      "content": "static int\nwait_any(int interesting)\t/* pid of interest, if any */\n{\n\tint pid;\n\tint status = 0;\n\tstruct redirect *redp;\n#ifdef HAVE_SIGPROCMASK\n\tsigset_t set, oldset;\n\n\t/* I have no idea why we are blocking signals during this function... */\n\tsigemptyset(& set);\n\tsigaddset(& set, SIGINT);\n\tsigaddset(& set, SIGHUP);\n\tsigaddset(& set, SIGQUIT);\n\tsigprocmask(SIG_BLOCK, & set, & oldset);\n#else\n\tvoid (*hstat)(int), (*istat)(int), (*qstat)(int);\n\n\tistat = signal(SIGINT, SIG_IGN);\n#endif\n#ifdef __MINGW32__\n\tif (interesting < 0) {\n\t\tstatus = -1;\n\t\tpid = -1;\n\t}\n\telse\n\t\tpid = _cwait(& status, interesting, 0);\n\tif (pid == interesting && pid > 0) {\n\t\tfor (redp = red_head; redp != NULL; redp = redp->next)\n\t\t\tif (interesting == redp->pid) {\n\t\t\t\tredp->pid = -1;\n\t\t\t\tredp->status = status;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n#else /* ! __MINGW32__ */\n#ifndef HAVE_SIGPROCMASK\n\thstat = signal(SIGHUP, SIG_IGN);\n\tqstat = signal(SIGQUIT, SIG_IGN);\n#endif\n\tfor (;;) {\n# if defined(HAVE_WAITPID) && defined(WNOHANG)\n\t\t/*\n\t\t * N.B. If the caller wants status for a specific child process\n\t\t * (i.e. interesting is non-zero), then we must hang until we\n\t\t * get exit status for that child.\n\t\t */\n\t\tif ((pid = waitpid(-1, & status, (interesting ? 0 : WNOHANG))) == 0)\n\t\t\t/* No children have exited */\n\t\t\tbreak;\n# elif defined(HAVE_SYS_WAIT_H)\t/* POSIX compatible sys/wait.h */\n\t\tpid = wait(& status);\n# else\n\t\tpid = wait((union wait *) & status);\n# endif\n\t\tif (interesting && pid == interesting) {\n\t\t\tbreak;\n\t\t} else if (pid != -1) {\n\t\t\tfor (redp = red_head; redp != NULL; redp = redp->next)\n\t\t\t\tif (pid == redp->pid) {\n\t\t\t\t\tredp->pid = -1;\n\t\t\t\t\tredp->status = status;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}\n\t\tif (pid == -1 && errno == ECHILD)\n\t\t\tbreak;\n\t}\n#ifndef HAVE_SIGPROCMASK\n\tsignal(SIGHUP, hstat);\n\tsignal(SIGQUIT, qstat);\n#endif\n#endif /* ! __MINGW32__ */\n#ifndef HAVE_SIGPROCMASK\n\tsignal(SIGINT, istat);\n#else\n\tsigprocmask(SIG_SETMASK, & oldset, NULL);\n#endif\n\treturn status;\n}",
      "lines": 80,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "gawk_popen": [
      {
        "start_point": [
          2589,
          0
        ],
        "end_point": [
          2691,
          1
        ],
        "content": "static IOBUF *\ngawk_popen(const char *cmd, struct redirect *rp)\n{\n\tint p[2];\n\tint pid;\n#if defined(__EMX__) || defined(__MINGW32__)\n\tint save_stdout;\n#ifdef __MINGW32__\n\tchar *qcmd = NULL;\n#endif\n#endif\n\n\t/*\n\t * We used to wait for any children to synchronize input and output,\n\t * but this could cause gawk to hang when it is started in a pipeline\n\t * and thus has a child process feeding it input (shell dependent).\n\t *\n\t * (void) wait_any(0);\t// wait for outstanding processes\n\t */\n\n\tif (pipe(p) < 0)\n\t\tfatal(_(\"cannot open pipe `%s' (%s)\"), cmd, strerror(errno));\n\n#if defined(__EMX__) || defined(__MINGW32__)\n\trp->iop = NULL;\n\tsave_stdout = dup(1); /* save stdout */\n\tif (save_stdout == -1) {\n\t\tclose(p[0]);\n\t\tclose(p[1]);\n\t\treturn NULL;\t/* failed */\n\t}\n\n\tclose(1); /* close stdout */\n\tif (dup(p[1]) != 1) {\n\t\tclose(p[0]);\n\t\tclose(p[1]);\n\t\tfatal(_(\"moving pipe to stdout in child failed (dup: %s)\"),\n\t\t\t\tstrerror(errno));\n\t}\n\n\t/* none of these handles must be inherited by the child process */\n\tclose(p[1]); /* close pipe input */\n\n\tos_close_on_exec(p[0], cmd, \"pipe\", \"from\"); /* pipe output: input of the parent process */\n\tos_close_on_exec(save_stdout, cmd, \"pipe\", \"from\"); /* saved stdout of the parent process */\n\n#ifdef __EMX__\n\tpid = spawnl(P_NOWAIT, \"/bin/sh\", \"sh\", \"-c\", cmd, NULL);\n#else  /* __MINGW32__ */\n\tpid = spawnl(P_NOWAIT, getenv(\"ComSpec\"), \"cmd.exe\", \"/c\",\n\t\t     qcmd = quote_cmd(cmd), NULL);\n\tefree(qcmd);\n#endif\n\n\t/* restore stdout */\n\tclose(1);\n\tif (dup(save_stdout) != 1) {\n\t\tclose(p[0]);\n\t\tfatal(_(\"restoring stdout in parent process failed\\n\"));\n\t}\n\tclose(save_stdout);\n\n#else /* NOT __EMX__, NOT __MINGW32__ */\n\tif ((pid = fork()) == 0) {\n\t\tif (close(1) == -1)\n\t\t\tfatal(_(\"close of stdout in child failed (%s)\"),\n\t\t\t\tstrerror(errno));\n\t\tif (dup(p[1]) != 1)\n\t\t\tfatal(_(\"moving pipe to stdout in child failed (dup: %s)\"), strerror(errno));\n\t\tif (close(p[0]) == -1 || close(p[1]) == -1)\n\t\t\tfatal(_(\"close of pipe failed (%s)\"), strerror(errno));\n\t\tset_sigpipe_to_default();\n\t\texecl(\"/bin/sh\", \"sh\", \"-c\", cmd, NULL);\n\t\t_exit(errno == ENOENT ? 127 : 126);\n\t}\n#endif /* NOT __EMX__, NOT __MINGW32__ */\n\n\tif (pid == -1) {\n\t\tclose(p[0]); close(p[1]);\n\t\tfatal(_(\"cannot create child process for `%s' (fork: %s)\"), cmd, strerror(errno));\n\t}\n\trp->pid = pid;\n#if !defined(__EMX__) && !defined(__MINGW32__)\n\tif (close(p[1]) == -1) {\n\t\tclose(p[0]);\n\t\tfatal(_(\"close of pipe failed (%s)\"), strerror(errno));\n\t}\n#endif\n\tos_close_on_exec(p[0], cmd, \"pipe\", \"from\");\n\tif ((BINMODE & BINMODE_INPUT) != 0)\n\t\tos_setbinmode(p[0], O_BINARY);\n\trp->iop = iop_alloc(p[0], cmd, 0);\n\tfind_input_parser(rp->iop);\n\tiop_finish(rp->iop);\n\tif (! rp->iop->valid) {\n\t\tif (! do_traditional && rp->iop->errcode != 0)\n\t\t\tupdate_ERRNO_int(rp->iop->errcode);\n\t\tiop_close(rp->iop);\n\t\trp->iop = NULL;\n\t}\n\n\treturn rp->iop;\n}",
        "lines": 103,
        "depth": 14,
        "decorators": [
          "static",
          "static",
          "IOBUF",
          "*\ngawk_popen(const char *cmd, struct redirect *rp)",
          "*"
        ]
      },
      {
        "start_point": [
          2719,
          0
        ],
        "end_point": [
          2750,
          1
        ],
        "content": "static IOBUF *\ngawk_popen(const char *cmd, struct redirect *rp)\n{\n\tFILE *current;\n\n\tos_restore_mode(fileno(stdin));\n\tset_sigpipe_to_default();\n\n\tcurrent = popen(cmd, binmode(\"r\"));\n\n\tif ((BINMODE & BINMODE_INPUT) != 0)\n\t\tos_setbinmode(fileno(stdin), O_BINARY);\n\tignore_sigpipe();\n\n\tif (current == NULL)\n\t\treturn NULL;\n\tos_close_on_exec(fileno(current), cmd, \"pipe\", \"from\");\n\trp->iop = iop_alloc(fileno(current), cmd, 0);\n\tfind_input_parser(rp->iop);\n\tiop_finish(rp->iop);\n\tif (! rp->iop->valid) {\n\t\tif (! do_traditional && rp->iop->errcode != 0)\n\t\t\tupdate_ERRNO_int(rp->iop->errcode);\n\t\t(void) pclose(current);\n\t\trp->iop->public.fd = INVALID_HANDLE;\n\t\tiop_close(rp->iop);\n\t\trp->iop = NULL;\n\t\tcurrent = NULL;\n\t}\n\trp->ifp = current;\n\treturn rp->iop;\n}",
        "lines": 32,
        "depth": 11,
        "decorators": [
          "static",
          "static",
          "IOBUF",
          "*\ngawk_popen(const char *cmd, struct redirect *rp)",
          "*"
        ]
      }
    ],
    "gawk_pclose": [
      {
        "start_point": [
          2695,
          0
        ],
        "end_point": [
          2708,
          1
        ],
        "content": "static int\ngawk_pclose(struct redirect *rp)\n{\n\tif (rp->iop != NULL)\n\t\t(void) iop_close(rp->iop);\n\trp->iop = NULL;\n\n\t/* process previously found, return stored status */\n\tif (rp->pid == -1)\n\t\treturn rp->status;\n\trp->status = sanitize_exit_status(wait_any(rp->pid));\n\trp->pid = -1;\n\treturn rp->status;\n}",
        "lines": 14,
        "depth": 10,
        "decorators": [
          "static",
          "static",
          "int"
        ]
      },
      {
        "start_point": [
          2754,
          0
        ],
        "end_point": [
          2767,
          1
        ],
        "content": "static int\ngawk_pclose(struct redirect *rp)\n{\n\tint rval, aval, fd = rp->iop->public.fd;\n\n\tif (rp->iop != NULL) {\n\t\trp->iop->public.fd = dup(fd);\t  /* kludge to allow close() + pclose() */\n\t\trval = iop_close(rp->iop);\n\t}\n\trp->iop = NULL;\n\taval = pclose(rp->ifp);\n\trp->ifp = NULL;\n\treturn (rval < 0 ? rval : aval);\n}",
        "lines": 14,
        "depth": 10,
        "decorators": [
          "static",
          "static",
          "int"
        ]
      }
    ],
    "do_getline_redir": {
      "start_point": [
        2773,
        0
      ],
      "end_point": [
        2843,
        1
      ],
      "content": "NODE *\ndo_getline_redir(int into_variable, enum redirval redirtype)\n{\n\tstruct redirect *rp = NULL;\n\tIOBUF *iop;\n\tint cnt = EOF;\n\tchar *s = NULL;\n\tint errcode;\n\tNODE *redir_exp = NULL;\n\tNODE **lhs = NULL;\n\tint redir_error = 0;\n\tconst awk_fieldwidth_info_t *field_width = NULL;\n\n\tif (into_variable)\n\t\tlhs = POP_ADDRESS();\n\n\tassert(redirtype != redirect_none);\n\tredir_exp = TOP();\n\trp = redirect(redir_exp, redirtype, & redir_error, false);\n\tDEREF(redir_exp);\n\tdecr_sp();\n\tif (rp == NULL) {\n\t\tif (redir_error) { /* failed redirect */\n\t\t\tif (! do_traditional)\n\t\t\t\tupdate_ERRNO_int(redir_error);\n\t\t}\n\t\treturn make_number((AWKNUM) -1.0);\n\t} else if ((rp->flag & RED_TWOWAY) != 0 && rp->iop == NULL) {\n\t\tif (is_non_fatal_redirect(redir_exp->stptr, redir_exp->stlen)) {\n\t\t\tupdate_ERRNO_int(EBADF);\n\t\t\treturn make_number((AWKNUM) -1.0);\n\t\t}\n\t\t(void) close_rp(rp, CLOSE_ALL);\n\t\tfatal(_(\"getline: attempt to read from closed read end of two-way pipe\"));\n\t}\n\tiop = rp->iop;\n\tif (iop == NULL)\t\t/* end of input */\n\t\treturn make_number((AWKNUM) 0.0);\n\n\terrcode = 0;\n\tcnt = get_a_record(& s, iop, & errcode, (lhs ? NULL : & field_width));\n\tif (errcode != 0) {\n\t\tif (! do_traditional && (errcode != -1))\n\t\t\tupdate_ERRNO_int(errcode);\n\t\treturn make_number((AWKNUM) cnt);\n\t}\n\n\tif (cnt == EOF) {\n\t\t/*\n\t\t * Don't do iop_close() here if we are\n\t\t * reading from a pipe; otherwise\n\t\t * gawk_pclose will not be called.\n\t\t */\n\t\tif ((rp->flag & (RED_PIPE|RED_TWOWAY)) == 0) {\n\t\t\t(void) iop_close(iop);\n\t\t\trp->iop = NULL;\n\t\t}\n\t\trp->flag |= RED_EOF;\t/* sticky EOF */\n\t\treturn make_number((AWKNUM) 0.0);\n\t}\n\n\tif (lhs == NULL)\t/* no optional var. */\n\t\tset_record(s, cnt, field_width);\n\telse {\t\t\t/* assignment to variable */\n\t\tunref(*lhs);\n\t\t*lhs = make_string(s, cnt);\n\t\t(*lhs)->flags |= USER_INPUT;\n\t}\n\n\treturn make_number((AWKNUM) 1.0);\n}",
      "lines": 71,
      "depth": 13,
      "decorators": [
        "NODE",
        "*\ndo_getline_redir(int into_variable, enum redirval redirtype)",
        "*"
      ]
    },
    "do_getline": {
      "start_point": [
        2847,
        0
      ],
      "end_point": [
        2886,
        1
      ],
      "content": "NODE *\ndo_getline(int into_variable, IOBUF *iop)\n{\n\tint cnt = EOF;\n\tchar *s = NULL;\n\tint errcode;\n\tconst awk_fieldwidth_info_t *field_width = NULL;\n\n\tif (iop == NULL) {\t/* end of input */\n\t\tif (into_variable)\n\t\t\t(void) POP_ADDRESS();\n\t\treturn make_number((AWKNUM) 0.0);\n\t}\n\n\terrcode = 0;\n\tcnt = get_a_record(& s, iop, & errcode, (into_variable ? NULL : & field_width));\n\tif (errcode != 0) {\n\t\tif (! do_traditional && (errcode != -1))\n\t\t\tupdate_ERRNO_int(errcode);\n\t\tif (into_variable)\n\t\t\t(void) POP_ADDRESS();\n\t\treturn make_number((AWKNUM) cnt);\n\t}\n\n\tif (cnt == EOF)\n\t\treturn NULL;\t/* try next file */\n\tINCREMENT_REC(NR);\n\tINCREMENT_REC(FNR);\n\n\tif (! into_variable)\t/* no optional var. */\n\t\tset_record(s, cnt, field_width);\n\telse {\t\t\t/* assignment to variable */\n\t\tNODE **lhs;\n\t\tlhs = POP_ADDRESS();\n\t\tunref(*lhs);\n\t\t*lhs = make_string(s, cnt);\n\t\t(*lhs)->flags |= USER_INPUT;\n\t}\n\treturn make_number((AWKNUM) 1.0);\n}",
      "lines": 40,
      "depth": 10,
      "decorators": [
        "NODE",
        "*\ndo_getline(int into_variable, IOBUF *iop)",
        "*"
      ]
    },
    "init_awkpath": {
      "start_point": [
        2907,
        0
      ],
      "end_point": [
        2973,
        1
      ],
      "content": "static void\ninit_awkpath(path_info *pi)\n{\n\tchar *path;\n\tchar *start, *end, *p;\n\tint len, i;\n\tint max_path;\t\t/* (# of allocated paths)-1 */\n\n\tpi->max_pathlen = 0;\n\tif ((path = getenv(pi->envname)) == NULL || *path == '\\0')\n\t\tpath = pi->dfltp[0];\n\n\t/* count number of separators */\n\tfor (max_path = 0, p = path; *p; p++)\n\t\tif (*p == envsep)\n\t\t\tmax_path++;\n\n\t// +3 --> 2 for null entries at front and end of path, 1 for NULL end of list\n\tezalloc(pi->awkpath, char **, (max_path + 3) * sizeof(char *), \"init_awkpath\");\n\n\tstart = path;\n\ti = 0;\n\n\tif (*path == envsep) {\t/* null entry at front of path */\n\t\tpi->awkpath[i++] = \".\";\n\t\tpi->max_pathlen = 1;\n\t}\n\n\twhile (*start) {\n\t\tif (*start == envsep) {\n\t\t\tif (start[1] == envsep) {\n\t\t\t\tpi->awkpath[i++] = \".\";\n\t\t\t\tif (pi->max_pathlen == 0)\n\t\t\t\t\tpi->max_pathlen = 1;\n\t\t\t\tstart++;\n\t\t\t} else if (start[1] == '\\0') {\n\t\t\t\tpi->awkpath[i++] = \".\";\n\t\t\t\tif (pi->max_pathlen == 0)\n\t\t\t\t\tpi->max_pathlen = 1;\n\t\t\t\tbreak;\n\t\t\t} else\n\t\t\t\tstart++;\n\t\t} else {\n\t\t\tfor (end = start; *end && *end != envsep; end++)\n\t\t\t\tcontinue;\n\n\t\t\tlen = end - start;\n\t\t\tif (len > 0) {\n\t\t\t\temalloc(p, char *, len + 2, \"init_awkpath\");\n\t\t\t\tmemcpy(p, start, len);\n\n\t\t\t\t/* add directory punctuation if necessary */\n\t\t\t\tif (! isdirpunct(end[-1]))\n\t\t\t\t\tp[len++] = '/';\n\t\t\t\tp[len] = '\\0';\n\t\t\t\tpi->awkpath[i++] = p;\n\t\t\t\tif (len > pi->max_pathlen)\n\t\t\t\t\tpi->max_pathlen = len;\n\n\t\t\t\tstart = end;\n\t\t\t} else\n\t\t\t\tstart++;\n\t\t}\n\t}\n\n\tpi->awkpath[i] = NULL;\n}",
      "lines": 67,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "do_find_source": {
      "start_point": [
        2977,
        0
      ],
      "end_point": [
        3014,
        1
      ],
      "content": "static char *\ndo_find_source(const char *src, struct stat *stb, int *errcode, path_info *pi)\n{\n\tchar *path;\n\tint i;\n\n\tassert(errcode != NULL);\n\n\t/* some kind of path name, no search */\n\tif (ispath(src)) {\n\t\temalloc(path, char *, strlen(src) + 1, \"do_find_source\");\n\t\tstrcpy(path, src);\n\t\tif (stat(path, stb) == 0)\n\t\t\treturn path;\n\t\t*errcode = errno;\n\t\tefree(path);\n\t\treturn NULL;\n\t}\n\n\tif (pi->awkpath == NULL)\n\t\tinit_awkpath(pi);\n\n\temalloc(path, char *, pi->max_pathlen + strlen(src) + 1, \"do_find_source\");\n\tfor (i = 0; pi->awkpath[i] != NULL; i++) {\n\t\tif (strcmp(pi->awkpath[i], \"./\") == 0 || strcmp(pi->awkpath[i], \".\") == 0)\n\t\t\t*path = '\\0';\n\t\telse\n\t\t\tstrcpy(path, pi->awkpath[i]);\n\t\tstrcat(path, src);\n\t\tif (stat(path, stb) == 0)\n\t\t\treturn path;\n\t}\n\n\t/* not found, give up */\n\t*errcode = errno;\n\tefree(path);\n\treturn NULL;\n}",
      "lines": 38,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "char",
        "*\ndo_find_source(const char *src, struct stat *stb, int *errcode, path_info *pi)",
        "*"
      ]
    },
    "find_source": {
      "start_point": [
        3018,
        0
      ],
      "end_point": [
        3093,
        1
      ],
      "content": "char *\nfind_source(const char *src, struct stat *stb, int *errcode, int is_extlib)\n{\n\tchar *path;\n\tpath_info *pi = (is_extlib ? & pi_awklibpath : & pi_awkpath);\n\n\t*errcode = 0;\n\tif (src == NULL || *src == '\\0')\n\t\treturn NULL;\n#ifdef __EMX__\n\tchar os2_src[strlen(src) + 1];\n\n\tif (is_extlib)\n\t\tsrc = os2_fixdllname(os2_src, src, sizeof(os2_src));\n#endif /* __EMX__ */\n\tpath = do_find_source(src, stb, errcode, pi);\n\n\tif (path == NULL && is_extlib) {\n\t\tchar *file_ext;\n\t\tint save_errno;\n\t\tsize_t src_len;\n\t\tsize_t suffix_len;\n\n#define EXTLIB_SUFFIX\t\".\" SHLIBEXT\n\t\tsrc_len = strlen(src);\n\t\tsuffix_len = strlen(EXTLIB_SUFFIX);\n\n\t\t/* check if already has the SUFFIX */\n\t\tif (src_len >= suffix_len && strcmp(& src[src_len - suffix_len], EXTLIB_SUFFIX) == 0)\n\t\t\treturn NULL;\n\n\t\t/* append EXTLIB_SUFFIX and try again */\n\t\tsave_errno = errno;\n\t\temalloc(file_ext, char *, src_len + suffix_len + 1, \"find_source\");\n\t\tsprintf(file_ext, \"%s%s\", src, EXTLIB_SUFFIX);\n\t\tpath = do_find_source(file_ext, stb, errcode, pi);\n\t\tefree(file_ext);\n\t\tif (path == NULL)\n\t\t\terrno = save_errno;\n\t\treturn path;\n#undef EXTLIB_SUFFIX\n\t}\n\n/*\n * Try searching with .awk appended if the platform headers have not specified\n * another suffix.\n */\n#ifndef DEFAULT_FILETYPE\n#define DEFAULT_FILETYPE \".awk\"\n#endif\n\n#ifdef DEFAULT_FILETYPE\n\tif (! do_traditional && path == NULL) {\n\t\tchar *file_awk;\n\t\tint save_errno = errno;\n#ifdef VMS\n\t\tint vms_save = vaxc$errno;\n#endif\n\n\t\t/* append \".awk\" and try again */\n\t\temalloc(file_awk, char *, strlen(src) +\n\t\t\tsizeof(DEFAULT_FILETYPE) + 1, \"find_source\");\n\t\tsprintf(file_awk, \"%s%s\", src, DEFAULT_FILETYPE);\n\t\tpath = do_find_source(file_awk, stb, errcode, pi);\n\t\tefree(file_awk);\n\t\tif (path == NULL) {\n\t\t\terrno = save_errno;\n#ifdef VMS\n\t\t\tvaxc$errno = vms_save;\n#endif\n\t\t}\n\t}\n#endif\t/*DEFAULT_FILETYPE*/\n\n\treturn path;\n}",
      "lines": 76,
      "depth": 14,
      "decorators": [
        "char",
        "*\nfind_source(const char *src, struct stat *stb, int *errcode, int is_extlib)",
        "*"
      ]
    },
    "srcopen": {
      "start_point": [
        3098,
        0
      ],
      "end_point": [
        3113,
        1
      ],
      "content": "int\nsrcopen(SRCFILE *s)\n{\n\tint fd = INVALID_HANDLE;\n\n\tif (s->stype == SRC_STDIN)\n\t\tfd = fileno(stdin);\n\telse if (s->stype == SRC_FILE || s->stype == SRC_INC)\n\t\tfd = devopen(s->fullpath, \"r\");\n\n\t/* set binary mode so that debugger byte offset calculations will be right */\n\tif (fd != INVALID_HANDLE)\n\t\tos_setbinmode(fd, O_BINARY);\n\n\treturn fd;\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "register_input_parser": {
      "start_point": [
        3126,
        0
      ],
      "end_point": [
        3139,
        1
      ],
      "content": "void\nregister_input_parser(awk_input_parser_t *input_parser)\n{\n\tif (input_parser == NULL)\n\t\tfatal(_(\"register_input_parser: received NULL pointer\"));\n\n\tinput_parser->next = NULL;\t/* force it */\n\tif (ip_head == NULL) {\n\t\tip_head = ip_tail = input_parser;\n\t} else {\n\t\tip_tail->next = input_parser;\n\t\tip_tail = ip_tail->next;\n\t}\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "find_input_parser": {
      "start_point": [
        3143,
        0
      ],
      "end_point": [
        3170,
        1
      ],
      "content": "static void\nfind_input_parser(IOBUF *iop)\n{\n\tawk_input_parser_t *ip, *ip2;\n\n\t/* if already associated with an input parser, bail out early */\n\tif (iop->public.get_record != NULL)\n\t\treturn;\n\n\tip = ip2 = NULL;\n\tfor (ip2 = ip_head; ip2 != NULL; ip2 = ip2->next) {\n\t\tif (ip2->can_take_file(& iop->public)) {\n\t\t\tif (ip == NULL)\n\t\t\t\tip = ip2;\t/* found first one */\n\t\t\telse\n\t\t\t\tfatal(_(\"input parser `%s' conflicts with previously installed input parser `%s'\"),\n\t\t\t\t\t\tip2->name, ip->name);\n\t\t}\n\t}\n\n\tif (ip != NULL) {\n\t\tif (! ip->take_control_of(& iop->public))\n\t\t\twarning(_(\"input parser `%s' failed to open `%s'\"),\n\t\t\t\t\tip->name, iop->public.name);\n\t\telse\n\t\t\tiop->valid = true;\n\t}\n}",
      "lines": 28,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "register_output_wrapper": {
      "start_point": [
        3181,
        0
      ],
      "end_point": [
        3194,
        1
      ],
      "content": "void\nregister_output_wrapper(awk_output_wrapper_t *wrapper)\n{\n\tif (wrapper == NULL)\n\t\tfatal(_(\"register_output_wrapper: received NULL pointer\"));\n\n\twrapper->next = NULL;\t/* force it */\n\tif (op_head == NULL) {\n\t\top_head = op_tail = wrapper;\n\t} else {\n\t\top_tail->next = wrapper;\n\t\top_tail = op_tail->next;\n\t}\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "find_output_wrapper": {
      "start_point": [
        3198,
        0
      ],
      "end_point": [
        3228,
        1
      ],
      "content": "static bool\nfind_output_wrapper(awk_output_buf_t *outbuf)\n{\n\tawk_output_wrapper_t *op, *op2;\n\n\t/* if already associated with an output wrapper, bail out early */\n\tif (outbuf->redirected)\n\t\treturn false;\n\n\top = op2 = NULL;\n\tfor (op2 = op_head; op2 != NULL; op2 = op2->next) {\n\t\tif (op2->can_take_file(outbuf)) {\n\t\t\tif (op == NULL)\n\t\t\t\top = op2;\t/* found first one */\n\t\t\telse\n\t\t\t\tfatal(_(\"output wrapper `%s' conflicts with previously installed output wrapper `%s'\"),\n\t\t\t\t\t\top2->name, op->name);\n\t\t}\n\t}\n\n\tif (op != NULL) {\n\t\tif (! op->take_control_of(outbuf)) {\n\t\t\twarning(_(\"output wrapper `%s' failed to open `%s'\"),\n\t\t\t\t\top->name, outbuf->name);\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
      "lines": 31,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "register_two_way_processor": {
      "start_point": [
        3237,
        0
      ],
      "end_point": [
        3250,
        1
      ],
      "content": "void\nregister_two_way_processor(awk_two_way_processor_t *processor)\n{\n\tif (processor == NULL)\n\t\tfatal(_(\"register_output_processor: received NULL pointer\"));\n\n\tprocessor->next = NULL;\t/* force it */\n\tif (tw_head == NULL) {\n\t\ttw_head = tw_tail = processor;\n\t} else {\n\t\ttw_tail->next = processor;\n\t\ttw_tail = tw_tail->next;\n\t}\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "find_two_way_processor": {
      "start_point": [
        3254,
        0
      ],
      "end_point": [
        3288,
        1
      ],
      "content": "static bool\nfind_two_way_processor(const char *name, struct redirect *rp)\n{\n\tawk_two_way_processor_t *tw, *tw2;\n\n\t/* if already associated with i/o, bail out early */\n\tif (   (rp->iop != NULL && rp->iop->public.fd != INVALID_HANDLE)\n\t    || rp->output.fp != NULL)\n\t\treturn false;\n\n\ttw = tw2 = NULL;\n\tfor (tw2 = tw_head; tw2 != NULL; tw2 = tw2->next) {\n\t\tif (tw2->can_take_two_way(name)) {\n\t\t\tif (tw == NULL)\n\t\t\t\ttw = tw2;\t/* found first one */\n\t\t\telse\n\t\t\t\tfatal(_(\"two-way processor `%s' conflicts with previously installed two-way processor `%s'\"),\n\t\t\t\t\t\ttw2->name, tw->name);\n\t\t}\n\t}\n\n\tif (tw != NULL) {\n\t\tif (rp->iop == NULL)\n\t\t\trp->iop = iop_alloc(INVALID_HANDLE, name, 0);\n\t\tif (! tw->take_control_of(name, & rp->iop->public, & rp->output)) {\n\t\t\twarning(_(\"two way processor `%s' failed to open `%s'\"),\n\t\t\t\t\ttw->name, name);\n\t\t\treturn false;\n\t\t}\n\t\tiop_finish(rp->iop);\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
      "lines": 35,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "iop_alloc": {
      "start_point": [
        3333,
        0
      ],
      "end_point": [
        3356,
        1
      ],
      "content": "static IOBUF *\niop_alloc(int fd, const char *name, int errno_val)\n{\n\tIOBUF *iop;\n\n\tezalloc(iop, IOBUF *, sizeof(IOBUF), \"iop_alloc\");\n\n\tiop->public.fd = fd;\n\tiop->public.name = name;\n\tiop->public.read_func = ( ssize_t(*)() ) read;\n\tiop->valid = false;\n\tiop->errcode = errno_val;\n\n\tif (fd != INVALID_HANDLE)\n\t\tfstat(fd, & iop->public.sbuf);\n#if defined(__EMX__) || defined(__MINGW32__)\n\telse if (errno_val == EISDIR) {\n\t\tiop->public.sbuf.st_mode = (_S_IFDIR | _S_IRWXU);\n\t\tiop->public.fd = FAKE_FD_VALUE;\n\t}\n#endif\n\n\treturn iop;\n}",
      "lines": 24,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "IOBUF",
        "*\niop_alloc(int fd, const char *name, int errno_val)",
        "*"
      ]
    },
    "iop_finish": {
      "start_point": [
        3360,
        0
      ],
      "end_point": [
        3413,
        1
      ],
      "content": "static IOBUF *\niop_finish(IOBUF *iop)\n{\n\tbool isdir = false;\n\n\tif (iop->public.fd != INVALID_HANDLE) {\n\t\tif (os_isreadable(& iop->public, & isdir))\n\t\t\tiop->valid = true;\n\t\telse {\n\t\t\tif (isdir)\n\t\t\t\tiop->errcode = EISDIR;\n\t\t\telse {\n\t\t\t\tiop->errcode = EIO;\n\t\t\t\t/*\n\t\t\t\t * Extensions can supply values that are not\n\t\t\t\t * INVALID_HANDLE but that are also not real\n\t\t\t\t * file descriptors. So check the fd before\n\t\t\t\t * trying to close it, which avoids errors\n\t\t\t\t * on some operating systems.\n\t\t\t\t *\n\t\t\t\t * The fcntl call works for Windows, too.\n\t\t\t\t */\n#if defined(F_GETFL)\n\t\t\t\tif (fcntl(iop->public.fd, F_GETFL) >= 0)\n#endif\n\t\t\t\t\t(void) close(iop->public.fd);\n\t\t\t\tiop->public.fd = INVALID_HANDLE;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Don't close directories: after_beginfile(),\n\t\t\t * special cases them.\n\t\t\t */\n\t\t}\n\t}\n\n\tif (! iop->valid || iop->public.fd == INVALID_HANDLE)\n\t\treturn iop;\n\n\tif (os_isatty(iop->public.fd))\n\t\tiop->flag |= IOP_IS_TTY;\n\n\tiop->readsize = iop->size = optimal_bufsize(iop->public.fd, & iop->public.sbuf);\n\tif (do_lint && S_ISREG(iop->public.sbuf.st_mode) && iop->public.sbuf.st_size == 0)\n\t\tlintwarn(_(\"data file `%s' is empty\"), iop->public.name);\n\tiop->errcode = errno = 0;\n\tiop->count = iop->scanoff = 0;\n\temalloc(iop->buf, char *, iop->size += 1, \"iop_finish\");\n\tiop->off = iop->buf;\n\tiop->dataend = NULL;\n\tiop->end = iop->buf + iop->size;\n\tiop->flag |= IOP_AT_START;\n\n\treturn iop;\n}",
      "lines": 54,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "IOBUF",
        "*\niop_finish(IOBUF *iop)",
        "*"
      ]
    },
    "grow_iop_buffer": {
      "start_point": [
        3430,
        0
      ],
      "end_point": [
        3460,
        1
      ],
      "content": "static void\ngrow_iop_buffer(IOBUF *iop)\n{\n\tsize_t valid = iop->dataend - iop->off;\n\tsize_t off = iop->off - iop->buf;\n\tsize_t newsize;\n\n\t/*\n\t * Lop off original extra byte, double the size,\n\t * add it back.\n\t */\n\tnewsize = ((iop->size - 1) * 2) + 1;\n\n\t/* Check for overflow */\n\tif (newsize <= iop->size)\n\t\tfatal(_(\"could not allocate more input memory\"));\n\n\t/* Make sure there's room for a disk block */\n\tif (newsize - valid < iop->readsize)\n\t\tnewsize += iop->readsize + 1;\n\n\t/* Check for overflow, again */\n\tif (newsize <= iop->size)\n\t\tfatal(_(\"could not allocate more input memory\"));\n\n\tiop->size = newsize;\n\terealloc(iop->buf, char *, iop->size, \"grow_iop_buffer\");\n\tiop->off = iop->buf + off;\n\tiop->dataend = iop->off + valid;\n\tiop->end = iop->buf + iop->size;\n}",
      "lines": 31,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "rs1scan": {
      "start_point": [
        3464,
        0
      ],
      "end_point": [
        3594,
        1
      ],
      "content": "static RECVALUE\nrs1scan(IOBUF *iop, struct recmatch *recm, SCANSTATE *state)\n{\n\tchar *bp;\n\tchar rs;\n\tsize_t mbclen = 0;\n\tmbstate_t mbs;\n\n\tmemset(recm, '\\0', sizeof(struct recmatch));\n\trs = RS->stptr[0];\n\t*(iop->dataend) = rs;   /* set sentinel */\n\trecm->start = iop->off; /* beginning of record */\n\n\tbp = iop->off;\n\tif (*state == INDATA)   /* skip over data we've already seen */\n\t\tbp += iop->scanoff;\n\n\t/*\n\t * From: Bruno Haible <bruno@clisp.org>\n\t * To: Aharon Robbins <arnold@skeeve.com>, gnits@gnits.org\n\t * Subject: Re: multibyte locales: any way to find if a character isn't multibyte?\n\t * Date: Mon, 23 Jun 2003 12:20:16 +0200\n\t * Cc: isamu@yamato.ibm.com\n\t *\n\t * Hi,\n\t *\n\t * > Is there any way to make the following query to the current locale?\n\t * >\n\t * > \tGiven an 8-bit value, can this value ever appear as part of\n\t * > \ta multibyte character?\n\t *\n\t * There is no simple answer here. The easiest solution I see is to\n\t * get the current locale's codeset (via locale_charset() which is a\n\t * wrapper around nl_langinfo(CODESET)), and then perform a case-by-case\n\t * treatment of the known multibyte encodings, from GB2312 to EUC-JISX0213;\n\t * for the unibyte encodings, a single btowc() call will tell you.\n\t *\n\t * > This is particularly critical for me for ASCII newline ('\\n').  If I\n\t * > can be guaranteed that it never shows up as part of a multibyte character,\n\t * > I can speed up gawk considerably in mulitbyte locales.\n\t *\n\t * This is much simpler to answer!\n\t * In all ASCII based multibyte encodings used for locales today (this\n\t * excludes EBCDIC based doublebyte encodings from IBM, and also excludes\n\t * ISO-2022-JP which is used for email exchange but not as a locale encoding)\n\t * ALL bytes in the range 0x00..0x2F occur only as a single character, not\n\t * as part of a multibyte character.\n\t *\n\t * So it's safe to assume, but deserves a comment in the source.\n\t *\n\t * Bruno\n\t ***************************************************************\n\t * From: Bruno Haible <bruno@clisp.org>\n\t * To: Aharon Robbins <arnold@skeeve.com>\n\t * Subject: Re: multibyte locales: any way to find if a character isn't multibyte?\n\t * Date: Mon, 23 Jun 2003 14:27:49 +0200\n\t *\n\t * On Monday 23 June 2003 14:11, you wrote:\n\t *\n\t * >       if (rs != '\\n' && MB_CUR_MAX > 1) {\n\t *\n\t * If you assume ASCII, you can even write\n\t *\n\t *         if (rs >= 0x30 && MB_CUR_MAX > 1) {\n\t *\n\t * (this catches also the space character) but if portability to EBCDIC\n\t * systems is desired, your code is fine as is.\n\t *\n\t * Bruno\n\t */\n\t/* Thus, the check for \\n here; big speedup ! */\n\tif (rs != '\\n' && gawk_mb_cur_max > 1) {\n\t\tint len = iop->dataend - bp;\n\t\tint found = 0;\n\n\t\tmemset(& mbs, 0, sizeof(mbstate_t));\n\t\tdo {\n\t\t\tif (*bp == rs)\n\t\t\t\tfound = 1;\n\t\t\tif (is_valid_character(*bp))\n\t\t\t\tmbclen = 1;\n\t\t\telse\n\t\t\t\tmbclen = mbrlen(bp, len, & mbs);\n\t\t\tif (   mbclen == 1\n\t\t\t    || mbclen == (size_t) -1\n\t\t\t    || mbclen == (size_t) -2\n\t\t\t    || mbclen == 0) {\n\t\t\t\t/* We treat it as a single-byte character.  */\n\t\t\t\tmbclen = 1;\n\t\t\t}\n\t\t\tlen -= mbclen;\n\t\t\tbp += mbclen;\n\t\t} while (len > 0 && ! found);\n\n\t\t/* Check that newline found isn't the sentinel. */\n\t\tif (found && (bp - mbclen) < iop->dataend) {\n\t\t\t/*\n\t\t\t * Set len to what we have so far, in case this is\n\t\t\t * all there is.\n\t\t\t */\n\t\t\trecm->len = bp - recm->start - mbclen;\n\t\t\trecm->rt_start = bp - mbclen;\n\t\t\trecm->rt_len = mbclen;\n\t\t\t*state = NOSTATE;\n\t\t\treturn REC_OK;\n\t\t} else {\n\t\t\t/* also set len */\n\t\t\trecm->len = bp - recm->start;\n\t\t\t*state = INDATA;\n\t\t\tiop->scanoff = bp - iop->off;\n\t\t\treturn NOTERM;\n\t\t}\n\t}\n\n\twhile (*bp != rs)\n\t\tbp++;\n\n\t/* set len to what we have so far, in case this is all there is */\n\trecm->len = bp - recm->start;\n\n\tif (bp < iop->dataend) {        /* found it in the buffer */\n\t\trecm->rt_start = bp;\n\t\trecm->rt_len = 1;\n\t\t*state = NOSTATE;\n\t\treturn REC_OK;\n\t} else {\n\t\t*state = INDATA;\n\t\tiop->scanoff = bp - iop->off;\n\t\treturn NOTERM;\n\t}\n}",
      "lines": 131,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "RECVALUE"
      ]
    },
    "rsrescan": {
      "start_point": [
        3598,
        0
      ],
      "end_point": [
        3701,
        1
      ],
      "content": "static RECVALUE\nrsrescan(IOBUF *iop, struct recmatch *recm, SCANSTATE *state)\n{\n\tchar *bp;\n\tsize_t restart = 0, reend = 0;\n\tRegexp *RSre = RS_regexp;\n\tint regex_flags = RE_NEED_START;\n\n\tmemset(recm, '\\0', sizeof(struct recmatch));\n\trecm->start = iop->off;\n\n\tbp = iop->off;\n\tif (*state == INDATA)\n\t\tbp += iop->scanoff;\n\n\tif ((iop->flag & IOP_AT_START) == 0)\n\t\tregex_flags |= RE_NO_BOL;\nagain:\n\t/* case 1, no match */\n\tif (research(RSre, bp, 0, iop->dataend - bp, regex_flags) == -1) {\n\t\t/* set len, in case this all there is. */\n\t\trecm->len = iop->dataend - iop->off;\n\t\treturn NOTERM;\n\t}\n\n\t/* ok, we matched within the buffer, set start and end */\n\trestart = RESTART(RSre, iop->off);\n\treend = REEND(RSre, iop->off);\n\n\t/* case 2, null regex match, grow buffer, try again */\n\tif (restart == reend) {\n\t\t*state = INDATA;\n\t\tiop->scanoff = reend + 1;\n\t\t/*\n\t\t * If still room in buffer, skip over null match\n\t\t * and restart search. Otherwise, return.\n\t\t */\n\t\tif (bp + iop->scanoff < iop->dataend) {\n\t\t\tbp += iop->scanoff;\n\t\t\tgoto again;\n\t\t}\n\t\trecm->len = (bp - iop->off) + restart;\n\t\treturn NOTERM;\n\t}\n\n\t/*\n\t * At this point, we have a non-empty match.\n\t *\n\t * First, fill in rest of data. The rest of the cases return\n\t * a record and terminator.\n\t */\n\trecm->len = restart;\n\trecm->rt_start = bp + restart;\n\trecm->rt_len = reend - restart;\n\t*state = NOSTATE;\n\n\t/*\n\t * 3. Match exactly at end:\n\t *      if re is a simple string match\n\t *              found a simple string match at end, return REC_OK\n\t *      else\n\t *              grow buffer, add more data, try again\n\t *      fi\n\t */\n\tif (iop->off + reend >= iop->dataend) {\n\t\tif (reisstring(RS->stptr, RS->stlen, RSre, iop->off))\n\t\t\treturn REC_OK;\n\t\telse\n\t\t\treturn TERMATEND;\n\t}\n\n\t/*\n\t * 4. Match within xxx bytes of end & maybe islong re:\n\t *      return TERMNEAREND\n\t */\n\n        /*\n         * case 4, match succeeded, but there may be more in\n         * the next input buffer.\n         *\n         * Consider an RS of   xyz(abc)?   where the\n         * exact end of the buffer is   xyza  and the\n         * next two, unread, characters are bc.\n         *\n         * This matches the \"xyz\" and ends up putting the\n         * \"abc\" into the front of the next record. Ooops.\n         *\n         * The re->maybe_long member is true if the\n         * regex contains one of: + * ? |.  This is a very\n         * simple heuristic, but in combination with the\n         * \"end of match within a few bytes of end of buffer\"\n         * check, should keep things reasonable.\n         */\n\n\t/* succession of tests is easier to trace in GDB. */\n\tif (RSre->maybe_long) {\n\t\tchar *matchend = iop->off + reend;\n\n\t\tif (iop->dataend - matchend < RS->stlen)\n\t\t\treturn TERMNEAREND;\n\t}\n\n\treturn REC_OK;\n}",
      "lines": 104,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "RECVALUE"
      ]
    },
    "rsnullscan": {
      "start_point": [
        3705,
        0
      ],
      "end_point": [
        3777,
        1
      ],
      "content": "static RECVALUE\nrsnullscan(IOBUF *iop, struct recmatch *recm, SCANSTATE *state)\n{\n\tchar *bp;\n\n\tif (*state == NOSTATE || *state == INLEADER)\n\t\tmemset(recm, '\\0', sizeof(struct recmatch));\n\n\trecm->start = iop->off;\n\n\tbp = iop->off;\n\tif (*state != NOSTATE)\n\t\tbp += iop->scanoff;\n\n\t/* set sentinel */\n\t*(iop->dataend) = '\\n';\n\n\tif (*state == INTERM)\n\t\tgoto find_longest_terminator;\n\telse if (*state == INDATA)\n\t\tgoto scan_data;\n\t/* else\n\t\tfall into things from beginning,\n\t\teither NOSTATE or INLEADER */\n\n/* skip_leading: */\n\t/* leading newlines are ignored */\n\twhile (*bp == '\\n' && bp < iop->dataend)\n\t\tbp++;\n\n\tif (bp >= iop->dataend) {       /* LOTS of leading newlines, sheesh. */\n\t\t*state = INLEADER;\n\t\tiop->scanoff = bp - iop->off;\n\t\treturn NOTERM;\n\t}\n\n\tiop->off = recm->start = bp;    /* real start of record */\nscan_data:\n\twhile (*bp++ != '\\n')\n\t\tcontinue;\n\n\tif (bp >= iop->dataend) {       /* no full terminator */\n\t\tiop->scanoff = recm->len = bp - iop->off - 1;\n\t\tif (bp == iop->dataend) {\t/* half a terminator */\n\t\t\trecm->rt_start = bp - 1;\n\t\t\trecm->rt_len = 1;\n\t\t}\n\t\t*state = INDATA;\n\t\treturn NOTERM;\n\t}\n\n\t/* found one newline before end of buffer, check next char */\n\tif (*bp != '\\n')\n\t\tgoto scan_data;\n\n\t/* we've now seen at least two newlines */\n\t*state = INTERM;\n\trecm->len = bp - iop->off - 1;\n\trecm->rt_start = bp - 1;\n\nfind_longest_terminator:\n\t/* find as many newlines as we can, to set RT */\n\twhile (*bp == '\\n' && bp < iop->dataend)\n\t\tbp++;\n\n\trecm->rt_len = bp - recm->rt_start;\n\tiop->scanoff = bp - iop->off;\n\n\tif (bp >= iop->dataend)\n\t\treturn TERMATEND;\n\n\treturn REC_OK;\n}",
      "lines": 73,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "RECVALUE"
      ]
    },
    "retryable": {
      "start_point": [
        3781,
        0
      ],
      "end_point": [
        3785,
        1
      ],
      "content": "static inline int\nretryable(IOBUF *iop)\n{\n\treturn PROCINFO_node && in_PROCINFO(iop->public.name, \"RETRY\", NULL);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "errno_io_retry": {
      "start_point": [
        3789,
        0
      ],
      "end_point": [
        3811,
        1
      ],
      "content": "static inline int\nerrno_io_retry(void)\n{\n\tswitch (errno) {\n#ifdef EAGAIN\n\tcase EAGAIN:\n#endif\n#ifdef EWOULDBLOCK\n#if !defined(EAGAIN) || (EWOULDBLOCK != EAGAIN)\n\tcase EWOULDBLOCK:\n#endif\n#endif\n#ifdef EINTR\n\tcase EINTR:\n#endif\n#ifdef ETIMEDOUT\n\tcase ETIMEDOUT:\n#endif\n\t\treturn 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
      "lines": 23,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "get_a_record": {
      "start_point": [
        3820,
        0
      ],
      "end_point": [
        4021,
        1
      ],
      "content": "static int\nget_a_record(char **out,        /* pointer to pointer to data */\n        IOBUF *iop,             /* input IOP */\n        int *errcode,           /* pointer to error variable */\n        const awk_fieldwidth_info_t **field_width)\n\t\t\t\t/* pointer to pointer to field_width info */\n{\n\tstruct recmatch recm;\n\tSCANSTATE state;\n\tRECVALUE ret;\n\tint retval;\n\tNODE *rtval = NULL;\n\tstatic RECVALUE (*lastmatchrec)(IOBUF *iop, struct recmatch *recm, SCANSTATE *state) = NULL;\n\n\tif (at_eof(iop) && no_data_left(iop))\n\t\treturn EOF;\n\n\tif (read_can_timeout)\n\t\tread_timeout = get_read_timeout(iop);\n\n\tif (iop->public.get_record != NULL) {\n\t\tchar *rt_start;\n\t\tsize_t rt_len;\n\t\tint rc = iop->public.get_record(out, &iop->public, errcode,\n\t\t\t\t\t\t&rt_start, &rt_len,\n\t\t\t\t\t\tfield_width);\n\t\tif (rc == EOF)\n\t\t\tiop->flag |= IOP_AT_EOF;\n\t\telse {\n\t\t\tif (rt_len != 0)\n\t\t\t\tset_RT(rt_start, rt_len);\n\t\t\telse\n\t\t\t\tset_RT_to_null();\n\t\t}\n\t\treturn rc;\n\t}\n\n        /* fill initial buffer */\n\tif (has_no_data(iop) || no_data_left(iop)) {\n\t\tiop->count = iop->public.read_func(iop->public.fd, iop->buf, iop->readsize);\n\t\tif (iop->count == 0) {\n\t\t\tiop->flag |= IOP_AT_EOF;\n\t\t\treturn EOF;\n\t\t} else if (iop->count == -1) {\n\t\t\t*errcode = errno;\n\t\t\tif (errno_io_retry() && retryable(iop))\n\t\t\t\treturn -2;\n\t\t\tiop->flag |= IOP_AT_EOF;\n\t\t\treturn EOF;\n\t\t} else {\n\t\t\tiop->dataend = iop->buf + iop->count;\n\t\t\tiop->off = iop->buf;\n\t\t}\n\t}\n\n\t/* loop through file to find a record */\n\tstate = NOSTATE;\n\tfor (;;) {\n\t\tsize_t dataend_off;\n\t\tsize_t room_left;\n\t\tsize_t amt_to_read;\n\n\t\tret = (*matchrec)(iop, & recm, & state);\n\t\tiop->flag &= ~IOP_AT_START;\n\t\t/* found the record, we're done, break the loop */\n\t\tif (ret == REC_OK)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Likely found the record; if there's no more data\n\t\t * to be had (like from a tiny regular file), break the\n\t\t * loop. Otherwise, see if we can read more.\n\t\t */\n\t\tif (ret == TERMNEAREND && buffer_has_all_data(iop))\n\t\t\tbreak;\n\n\t\t/* need to add more data to buffer */\n\t\t/* shift data down in buffer */\n\t\tdataend_off = iop->dataend - iop->off;\n\t\tmemmove(iop->buf, iop->off, dataend_off);\n\t\tiop->off = iop->buf;\n\t\tiop->dataend = iop->buf + dataend_off;\n\n\t\t/* adjust recm contents */\n\t\trecm.start = iop->off;\n\t\tif (recm.rt_start != NULL)\n\t\t\trecm.rt_start = iop->off + recm.len;\n\n\t\t/* read more data, break if EOF */\n#ifndef MIN\n#define MIN(x, y) (x < y ? x : y)\n#endif\n\t\t/* subtract one in read count to leave room for sentinel */\n\t\troom_left = iop->end - iop->dataend - 1;\n\t\tamt_to_read = MIN(iop->readsize, room_left);\n\n\t\tif (amt_to_read < iop->readsize) {\n\t\t\tgrow_iop_buffer(iop);\n\t\t\t/* adjust recm contents */\n\t\t\trecm.start = iop->off;\n\t\t\tif (recm.rt_start != NULL)\n\t\t\t\trecm.rt_start = iop->off + recm.len;\n\n\t\t\t/* recalculate amt_to_read */\n\t\t\troom_left = iop->end - iop->dataend - 1;\n\t\t\tamt_to_read = MIN(iop->readsize, room_left);\n\t\t}\n\t\twhile (amt_to_read + iop->readsize < room_left)\n\t\t\tamt_to_read += iop->readsize;\n\n#ifdef SSIZE_MAX\n\t\t/*\n\t\t * POSIX limits read to SSIZE_MAX. There are (bizarre)\n\t\t * systems where this amount is small.\n\t\t */\n\t\tamt_to_read = MIN(amt_to_read, SSIZE_MAX);\n#endif\n\n\t\tiop->count = iop->public.read_func(iop->public.fd, iop->dataend, amt_to_read);\n\t\tif (iop->count == -1) {\n\t\t\t*errcode = errno;\n\t\t\tif (errno_io_retry() && retryable(iop))\n\t\t\t\treturn -2;\n\t\t\tiop->flag |= IOP_AT_EOF;\n\t\t\tbreak;\n\t\t} else if (iop->count == 0) {\n\t\t\t/*\n\t\t\t * Hit EOF before being certain that we've matched\n\t\t\t * the end of the record. If ret is TERMNEAREND,\n\t\t\t * we need to pull out what we've got in the buffer.\n\t\t\t * Eventually we'll come back here and see the EOF,\n\t\t\t * end the record and set RT to \"\".\n\t\t\t */\n\t\t\tif (ret != TERMNEAREND)\n\t\t\t\tiop->flag |= IOP_AT_EOF;\n\t\t\tbreak;\n\t\t} else\n\t\t\tiop->dataend += iop->count;\n\t}\n\n\t/* set record, RT, return right value */\n\n\t/*\n\t * rtval is not a static pointer to avoid dangling pointer problems\n\t * in case awk code assigns to RT.  A remote possibility, to be sure,\n\t * but Bitter Experience teaches us not to make ``that'll never\n\t * happen'' kinds of assumptions.\n\t */\n\trtval = RT_node->var_value;\n\n\tif (recm.rt_len == 0) {\n\t\tset_RT_to_null();\n\t\tlastmatchrec = NULL;\n\t} else {\n\t\tassert(recm.rt_start != NULL);\n\t\t/*\n\t\t * Optimization. For rs1 case, don't set RT if\n\t\t * character is same as last time.  This knocks a\n\t\t * chunk of time off something simple like\n\t\t *\n\t\t *      gawk '{ print }' /some/big/file\n\t\t *\n\t\t * Similarly, for rsnull case, if length of new RT is\n\t\t * shorter than current RT, just bump length down in RT.\n\t\t *\n\t\t * Make sure that matchrec didn't change since the last\n\t\t * check.  (Ugh, details, details, details.)\n\t\t */\n\t\tif (lastmatchrec == NULL || lastmatchrec != matchrec) {\n\t\t\tlastmatchrec = matchrec;\n\t\t\tset_RT(recm.rt_start, recm.rt_len);\n\t\t} else if (matchrec == rs1scan) {\n\t\t\tif (rtval->stlen != 1 || rtval->stptr[0] != recm.rt_start[0])\n\t\t\t\tset_RT(recm.rt_start, recm.rt_len);\n\t\t\t/* else\n\t\t\t\tleave it alone */\n\t\t} else if (matchrec == rsnullscan) {\n\t\t\tif (rtval->stlen >= recm.rt_len) {\n\t\t\t\trtval->stlen = recm.rt_len;\n\t\t\t\tfree_wstr(rtval);\n\t\t\t} else\n\t\t\t\tset_RT(recm.rt_start, recm.rt_len);\n\t\t} else\n\t\t\tset_RT(recm.rt_start, recm.rt_len);\n\t}\n\n\tif (recm.len == 0) {\n\t\t*out = NULL;\n\t\tretval = 0;\n\t} else {\n\t\tassert(recm.start != NULL);\n\t\t*out = recm.start;\n\t\tretval = recm.len;\n\t}\n\n\tiop->off += recm.len + recm.rt_len;\n\n\tif (recm.len == 0 && recm.rt_len == 0 && at_eof(iop))\n\t\treturn EOF;\n\telse\n\t\treturn retval;\n}",
      "lines": 202,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "set_RS": {
      "start_point": [
        4025,
        0
      ],
      "end_point": [
        4079,
        1
      ],
      "content": "void\nset_RS()\n{\n\tstatic NODE *save_rs = NULL;\n\n\t/*\n\t * Don't use cmp_nodes(), which pays attention to IGNORECASE.\n\t */\n\tif (save_rs\n\t\t&& RS_node->var_value->stlen == save_rs->stlen\n\t\t&& memcmp(RS_node->var_value->stptr, save_rs->stptr, save_rs->stlen) == 0) {\n\t\t/*\n\t\t * It could be that just IGNORECASE changed.  If so,\n\t\t * update the regex and then do the same for FS.\n\t\t * set_IGNORECASE() relies on this routine to call\n\t\t * set_FS().\n\t\t */\n\t\tRS_regexp = RS_re[IGNORECASE];\n\t\tgoto set_FS;\n\t}\n\tunref(save_rs);\n\tsave_rs = dupnode(RS_node->var_value);\n\tRS_is_null = false;\n\tRS = force_string(RS_node->var_value);\n\t/*\n\t * used to be if (RS_regexp != NULL) { refree(..); refree(..); ...; }.\n\t * Please do not remerge the if condition; hinders memory deallocation\n\t * in case of fatal error in make_regexp.\n\t */\n\trefree(RS_re[0]);\t/* NULL argument is ok */\n\trefree(RS_re[1]);\n\tRS_re[0] = RS_re[1] = RS_regexp = NULL;\n\n\tif (RS->stlen == 0) {\n\t\tRS_is_null = true;\n\t\tmatchrec = rsnullscan;\n\t} else if (RS->stlen > 1 && ! do_traditional) {\n\t\tstatic bool warned = false;\n\n\t\tRS_re[0] = make_regexp(RS->stptr, RS->stlen, false, true, true);\n\t\tRS_re[1] = make_regexp(RS->stptr, RS->stlen, true, true, true);\n\t\tRS_regexp = RS_re[IGNORECASE];\n\n\t\tmatchrec = rsrescan;\n\n\t\tif (do_lint && ! warned) {\n\t\t\tlintwarn(_(\"multicharacter value of `RS' is a gawk extension\"));\n\t\t\twarned = true;\n\t\t}\n\t} else\n\t\tmatchrec = rs1scan;\nset_FS:\n\tif (current_field_sep() == Using_FS)\n\t\tset_FS();\n}",
      "lines": 55,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "pty_vs_pipe": {
      "start_point": [
        4088,
        0
      ],
      "end_point": [
        4103,
        1
      ],
      "content": "static bool\npty_vs_pipe(const char *command)\n{\n#ifdef HAVE_TERMIOS_H\n\tNODE *val;\n\n\t/*\n\t * N.B. No need to check for NULL PROCINFO_node, since the\n\t * in_PROCINFO function now checks that for us.\n\t */\n\tval = in_PROCINFO(command, \"pty\", NULL);\n\tif (val)\n\t\treturn boolval(val);\n#endif /* HAVE_TERMIOS_H */\n\treturn false;\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "iopflags2str": {
      "start_point": [
        4107,
        0
      ],
      "end_point": [
        4119,
        1
      ],
      "content": "const char *\niopflags2str(int flag)\n{\n\tstatic const struct flagtab values[] = {\n\t\t{ IOP_IS_TTY, \"IOP_IS_TTY\" },\n\t\t{ IOP_AT_EOF,  \"IOP_AT_EOF\" },\n\t\t{ IOP_CLOSED, \"IOP_CLOSED\" },\n\t\t{ IOP_AT_START,  \"IOP_AT_START\" },\n\t\t{ 0, NULL }\n\t};\n\n\treturn genflags2str(flag, values);\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "const",
        "const",
        "char",
        "*\niopflags2str(int flag)",
        "*"
      ]
    },
    "free_rp": {
      "start_point": [
        4123,
        0
      ],
      "end_point": [
        4128,
        1
      ],
      "content": "static void\nfree_rp(struct redirect *rp)\n{\n\tefree(rp->value);\n\tefree(rp);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "inetfile": {
      "start_point": [
        4132,
        0
      ],
      "end_point": [
        4229,
        1
      ],
      "content": "static bool\ninetfile(const char *str, size_t len, struct inet_socket_info *isi)\n{\n#ifndef HAVE_SOCKETS\n\treturn false;\n#else\n\tconst char *cp = str;\n\tconst char *cpend = str + len;\n\tstruct inet_socket_info buf;\n\n\t/* syntax: /inet/protocol/localport/hostname/remoteport */\n\tif (len < 5 || memcmp(cp, \"/inet\", 5) != 0)\n\t\t/* quick exit */\n\t\treturn false;\n\tif (! isi)\n\t\tisi = & buf;\n\tcp += 5;\n\tif (cpend - cp < 2)\n\t\treturn false;\n\tswitch (*cp) {\n\tcase '/':\n\t\tisi->family = AF_UNSPEC;\n\t\tbreak;\n\tcase '4':\n\t\tif (*++cp != '/')\n\t\t\treturn false;\n\t\tisi->family = AF_INET;\n\t\tbreak;\n\tcase '6':\n\t\tif (*++cp != '/')\n\t\t\treturn false;\n\t\tisi->family = AF_INET6;\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\tcp++;\t/* skip past '/' */\n\n\t/* which protocol? */\n\tif (cpend - cp < 5)\n\t\treturn false;\n\tif (memcmp(cp, \"tcp/\", 4) == 0)\n\t\tisi->protocol = SOCK_STREAM;\n\telse if (memcmp(cp, \"udp/\", 4) == 0)\n\t\tisi->protocol = SOCK_DGRAM;\n\telse\n\t\treturn false;\n\tcp += 4;\n\n\t/* which localport? */\n\tisi->localport.offset = cp-str;\n\twhile (*cp != '/') {\n\t\tif (++cp >= cpend)\n\t\t\treturn false;\n\t}\n\t/*\n\t * Require a port, let them explicitly put 0 if\n\t * they don't care.\n\t */\n\tif ((isi->localport.len = (cp-str)-isi->localport.offset) == 0)\n\t\treturn false;\n\n\t/* which hostname? */\n\tif (cpend - cp < 2)\n\t\treturn false;\n\tcp++;\n\tisi->remotehost.offset = cp-str;\n\twhile (*cp != '/') {\n\t\tif (++cp >= cpend)\n\t\t\treturn false;\n\t}\n\tif ((isi->remotehost.len = (cp-str)-isi->remotehost.offset) == 0)\n\t\treturn false;\n\n\t/* which remoteport? */\n\tif (cpend - cp < 2)\n\t\treturn false;\n\tcp++;\n\t/*\n\t * The remote port ends the special file name.\n\t *\n\t * Here too, require a port, let them explicitly put 0 if\n\t * they don't care.\n\t */\n\tisi->remoteport.offset = cp-str;\n\twhile (*cp != '/' && cp < cpend)\n\t\tcp++;\n\tif (cp != cpend || ((isi->remoteport.len = (cp-str)-isi->remoteport.offset) == 0))\n\t\treturn false;\n\n#ifndef HAVE_GETADDRINFO\n\t/* final check for IPv6: */\n\tif (isi->family == AF_INET6)\n\t\tfatal(_(\"IPv6 communication is not supported\"));\n#endif\n\treturn true;\n#endif /* HAVE_SOCKETS */\n}",
      "lines": 98,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "in_PROCINFO": {
      "start_point": [
        4236,
        0
      ],
      "end_point": [
        4284,
        1
      ],
      "content": "static NODE *\nin_PROCINFO(const char *pidx1, const char *pidx2, NODE **full_idx)\n{\n\tchar *str;\n\tsize_t str_len;\n\tNODE *r, *sub = NULL;\n\tNODE *subsep = SUBSEP_node->var_value;\n\n\tif (PROCINFO_node == NULL || (pidx1 == NULL && pidx2 == NULL))\n\t\treturn NULL;\n\n\t/* full_idx is in+out parameter */\n\n\tif (full_idx)\n\t\tsub = *full_idx;\n\n\tif (pidx1 != NULL && pidx2 == NULL)\n\t\tstr_len = strlen(pidx1);\n\telse if (pidx1 == NULL && pidx2 != NULL)\n\t\tstr_len = strlen(pidx2);\n\telse\n\t\tstr_len = strlen(pidx1) + subsep->stlen\t+ strlen(pidx2);\n\n\tif (sub == NULL) {\n\t\temalloc(str, char *, str_len + 1, \"in_PROCINFO\");\n\t\tsub = make_str_node(str, str_len, ALREADY_MALLOCED);\n\t\tif (full_idx)\n\t\t\t*full_idx = sub;\n\t} else if (str_len != sub->stlen) {\n\t\t/* *full_idx != NULL */\n\n\t\tassert(sub->valref == 1);\n\t\terealloc(sub->stptr, char *, str_len + 1, \"in_PROCINFO\");\n\t\tsub->stlen = str_len;\n\t}\n\n\tif (pidx1 != NULL && pidx2 == NULL)\n\t\tstrcpy(sub->stptr, pidx1);\n\telse if (pidx1 == NULL && pidx2 != NULL)\n\t\tstrcpy(sub->stptr, pidx2);\n\telse\n\t\tsprintf(sub->stptr, \"%s%.*s%s\", pidx1, (int)subsep->stlen,\n\t\t\t\tsubsep->stptr, pidx2);\n\n\tr = in_array(PROCINFO_node, sub);\n\tif (! full_idx)\n\t\tunref(sub);\n\treturn r;\n}",
      "lines": 49,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "NODE",
        "*\nin_PROCINFO(const char *pidx1, const char *pidx2, NODE **full_idx)",
        "*"
      ]
    },
    "get_read_timeout": {
      "start_point": [
        4289,
        0
      ],
      "end_point": [
        4324,
        1
      ],
      "content": "static long\nget_read_timeout(IOBUF *iop)\n{\n\tlong tmout = 0;\n\n\tif (PROCINFO_node != NULL) {\n\t\tconst char *name = iop->public.name;\n\t\tNODE *val = NULL;\n\t\tstatic NODE *full_idx = NULL;\n\t\tstatic const char *last_name = NULL;\n\n\t\t/*\n\t\t * Do not re-construct the full index when last redirection\n\t\t * string is the same as the current; \"efficiency_hack++\".\n\t\t */\n\t\tif (full_idx == NULL || strcmp(name, last_name) != 0) {\n\t\t\tval = in_PROCINFO(name, \"READ_TIMEOUT\", & full_idx);\n\t\t\tif (last_name != NULL)\n\t\t\t\tefree((void *) last_name);\n\t\t\tlast_name = estrdup(name, strlen(name));\n\t\t} else\t/* use cached full index */\n\t\t\tval = in_array(PROCINFO_node, full_idx);\n\n\t\tif (val != NULL) {\n\t\t\t(void) force_number(val);\n\t\t\ttmout = get_number_si(val);\n\t\t}\n\t} else\n\t\ttmout = read_default_timeout;\t/* initialized from env. variable in init_io() */\n\n\t/* overwrite read routine only if an extension has not done so */\n\tif ((iop->public.read_func == ( ssize_t(*)() ) read) && tmout > 0)\n\t\tiop->public.read_func = read_with_timeout;\n\n\treturn tmout;\n}",
      "lines": 36,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "long",
        "long"
      ]
    },
    "read_with_timeout": {
      "start_point": [
        4331,
        0
      ],
      "end_point": [
        4380,
        1
      ],
      "content": "static ssize_t\nread_with_timeout(int fd, char *buf, size_t size)\n{\n#if ! defined(VMS)\n\tfd_set readfds;\n\tstruct timeval tv;\n#ifdef __MINGW32__\n\t/*\n\t * Only sockets can be read with a timeout.  Also, the FD_*\n\t * macros work on SOCKET type, not on int file descriptors.\n\t */\n\tSOCKET s = valid_socket(fd);\n\n\tif (!s)\n\t\treturn read(fd, buf, size);\n#else\n\tint s = fd;\n#endif\n\n\ttv.tv_sec = read_timeout / 1000;\n\ttv.tv_usec = 1000 * (read_timeout - 1000 * tv.tv_sec);\n\n\tFD_ZERO(& readfds);\n\tFD_SET(s, & readfds);\n\n\terrno = 0;\n\t/*\n\t * Note: the 1st arg of 'select' is ignored on MS-Windows, so\n\t * it's not a mistake to pass fd+1 there, although we use\n\t * sockets, not file descriptors.\n\t */\n\tif (select(fd + 1, & readfds, NULL, NULL, & tv) < 0)\n\t\treturn -1;\n\n\tif (FD_ISSET(s, & readfds))\n\t\treturn read(fd, buf, size);\n\t/* else\n\t\ttimed out */\n\n\t/* Set a meaningful errno */\n#ifdef ETIMEDOUT\n\terrno = ETIMEDOUT;\n#else\n\terrno = EAGAIN;\n#endif\n\treturn -1;\n#else  /* VMS */\n\treturn read(fd, buf, size);\n#endif\t/* VMS */\n}",
      "lines": 50,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "ssize_t"
      ]
    },
    "gawk_fwrite": {
      "start_point": [
        4388,
        0
      ],
      "end_point": [
        4394,
        1
      ],
      "content": "static size_t\ngawk_fwrite(const void *buf, size_t size, size_t count, FILE *fp, void *opaque)\n{\n\t(void) opaque;\n\n\treturn fwrite(buf, size, count, fp);\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "gawk_fflush": {
      "start_point": [
        4398,
        0
      ],
      "end_point": [
        4404,
        1
      ],
      "content": "static int\ngawk_fflush(FILE *fp, void *opaque)\n{\n\t(void) opaque;\n\n\treturn fflush(fp);\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "gawk_ferror": {
      "start_point": [
        4408,
        0
      ],
      "end_point": [
        4414,
        1
      ],
      "content": "static int\ngawk_ferror(FILE *fp, void *opaque)\n{\n\t(void) opaque;\n\n\treturn ferror(fp);\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "gawk_fclose": {
      "start_point": [
        4418,
        0
      ],
      "end_point": [
        4433,
        1
      ],
      "content": "static int\ngawk_fclose(FILE *fp, void *opaque)\n{\n\tint result;\n#ifdef __MINGW32__\n\tSOCKET s = valid_socket (fileno(fp));\n#endif\n\t(void) opaque;\n\n\tresult =  fclose(fp);\n#ifdef __MINGW32__\n\tif (s && closesocket(s) == SOCKET_ERROR)\n\t\tresult = -1;\n#endif\n\treturn result;\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "init_output_wrapper": {
      "start_point": [
        4437,
        0
      ],
      "end_point": [
        4449,
        1
      ],
      "content": "static void\ninit_output_wrapper(awk_output_buf_t *outbuf)\n{\n\toutbuf->name = NULL;\n\toutbuf->mode = NULL;\n\toutbuf->fp = NULL;\n\toutbuf->opaque = NULL;\n\toutbuf->redirected = awk_false;\n\toutbuf->gawk_fwrite = gawk_fwrite;\n\toutbuf->gawk_fflush = gawk_fflush;\n\toutbuf->gawk_ferror = gawk_ferror;\n\toutbuf->gawk_fclose = gawk_fclose;\n}",
      "lines": 13,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "gawk/gawk-4.2.1/main.c": {
    "main": {
      "start_point": [
        216,
        0
      ],
      "end_point": [
        539,
        1
      ],
      "content": "int\nmain(int argc, char **argv)\n{\n\tint i;\n\tchar *extra_stack;\n\tint have_srcfile = 0;\n\tSRCFILE *s;\n\tchar *cp;\n#if defined(LOCALEDEBUG)\n\tconst char *initial_locale;\n#endif\n\n\t/* do these checks early */\n\tif (getenv(\"TIDYMEM\") != NULL)\n\t\tdo_flags |= DO_TIDY_MEM;\n\n#ifdef HAVE_MCHECK_H\n#ifdef HAVE_MTRACE\n\tif (do_tidy_mem)\n\t\tmtrace();\n#endif /* HAVE_MTRACE */\n#endif /* HAVE_MCHECK_H */\n\n\tmyname = gawk_name(argv[0]);\n\tos_arg_fixup(&argc, &argv); /* emulate redirection, expand wildcards */\n\n\tif (argc < 2)\n\t\tusage(EXIT_FAILURE, stderr);\n\n\tif ((cp = getenv(\"GAWK_LOCALE_DIR\")) != NULL)\n\t\tlocale_dir = cp;\n\n#if defined(F_GETFL) && defined(O_APPEND)\n\t// 1/2018: This is needed on modern BSD systems so that the\n\t// inplace tests pass. I think it's a bug in those kernels\n\t// but let's just work around it anyway.\n\tint flags = fcntl(fileno(stderr), F_GETFL, NULL);\n\tif (flags >= 0 && (flags & O_APPEND) == 0) {\n\t\tflags |= O_APPEND;\n\t\t(void) fcntl(fileno(stderr), F_SETFL, flags);\n\t}\n#endif\n\n#if defined(LOCALEDEBUG)\n\tinitial_locale = locale;\n#endif\n\tset_locale_stuff();\n\n\t(void) signal(SIGFPE, catchsig);\n#ifdef SIGBUS\n\t(void) signal(SIGBUS, catchsig);\n#endif\n\n\t/*\n\t * Ignore SIGPIPE so that writes to pipes that fail don't\n\t * kill the process but instead return -1 and set errno.\n\t * That lets us print a fatal message instead of dieing suddenly.\n\t *\n\t * Note that this requires ignoring EPIPE when writing and\n\t * flushing stdout/stderr in other parts of the program. E.g.,\n\t *\n\t * \tgawk 'BEGIN { print \"hi\" }' | exit\n\t *\n\t * should not give us \"broken pipe\" messages --- mainly because\n\t * it did not do so in the past and people would complain.\n\t */\n\tignore_sigpipe();\n\n\t(void) sigsegv_install_handler(catchsegv);\n#define STACK_SIZE (16*1024)\n\temalloc(extra_stack, char *, STACK_SIZE, \"main\");\n\t(void) stackoverflow_install_handler(catchstackoverflow, extra_stack, STACK_SIZE);\n#undef STACK_SIZE\n\n\t/* initialize the null string */\n\tNnull_string = make_string(\"\", 0);\n\n\t/* Robustness: check that file descriptors 0, 1, 2 are open */\n\tinit_fds();\n\n\t/* init array handling. */\n\tarray_init();\n\n\t/* init the symbol tables */\n\tinit_symbol_table();\n\n\toutput_fp = stdout;\n\n\t/* initialize global (main) execution context */\n\tpush_context(new_context());\n\n\tparse_args(argc, argv);\n\n#if defined(LOCALEDEBUG)\n\tif (locale != initial_locale)\n\t\tset_locale_stuff();\n#endif\n\n\t/*\n\t * In glibc, MB_CUR_MAX is actually a function.  This value is\n\t * tested *a lot* in many speed-critical places in gawk. Caching\n\t * this value once makes a speed difference.\n\t */\n\tgawk_mb_cur_max = MB_CUR_MAX;\n\n\t/* init the cache for checking bytes if they're characters */\n\tinit_btowc_cache();\n\n\tif (do_nostalgia)\n\t\tnostalgia();\n\n\t/* check for POSIXLY_CORRECT environment variable */\n\tif (! do_posix && getenv(\"POSIXLY_CORRECT\") != NULL) {\n\t\tdo_flags |= DO_POSIX;\n\t\tif (do_lint)\n\t\t\tlintwarn(\n\t_(\"environment variable `POSIXLY_CORRECT' set: turning on `--posix'\"));\n\t}\n\n\tif (do_posix) {\n\t\tuse_lc_numeric = true;\n\t\tif (do_traditional)\t/* both on command line */\n\t\t\twarning(_(\"`--posix' overrides `--traditional'\"));\n\t\telse\n\t\t\tdo_flags |= DO_TRADITIONAL;\n\t\t\t/*\n\t\t\t * POSIX compliance also implies\n\t\t\t * no GNU extensions either.\n\t\t\t */\n\t}\n\n\tif (do_traditional && do_non_decimal_data) {\n\t\tdo_flags &= ~DO_NON_DEC_DATA;\n\t\twarning(_(\"`--posix'/`--traditional' overrides `--non-decimal-data'\"));\n\t}\n\n\tif (do_lint && os_is_setuid())\n\t\twarning(_(\"running %s setuid root may be a security problem\"), myname);\n\n\tif (do_binary) {\n\t\tif (do_posix)\n\t\t\twarning(_(\"`--posix' overrides `--characters-as-bytes'\"));\n\t\telse\n\t\t\tgawk_mb_cur_max = 1;\t/* hands off my data! */\n#if defined(LC_ALL)\n\t\tsetlocale(LC_ALL, \"C\");\n#endif\n\t}\n\n\tif (do_debug)\t/* Need to register the debugger pre-exec hook before any other */\n\t\tinit_debug();\n\n#ifdef HAVE_MPFR\n\t/* Set up MPFR defaults, and register pre-exec hook to process arithmetic opcodes */\n\tif (do_mpfr)\n\t\tinit_mpfr(DEFAULT_PREC, DEFAULT_ROUNDMODE);\n#endif\n\n\t/* load group set */\n\tinit_groupset();\n\n#ifdef HAVE_MPFR\n\tif (do_mpfr) {\n\t\tmpz_init(Nnull_string->mpg_i);\n\t\tNnull_string->flags = (MALLOC|STRCUR|STRING|MPZN|NUMCUR|NUMBER);\n\t} else\n#endif\n\t{\n\t\tNnull_string->numbr = 0.0;\n\t\tNnull_string->flags = (MALLOC|STRCUR|STRING|NUMCUR|NUMBER);\n\t}\n\n\t/*\n\t * Tell the regex routines how they should work.\n\t * Do this before initializing variables, since\n\t * they could want to do a regexp compile.\n\t */\n\tresetup();\n\n\t/* Set up the special variables */\n\tinit_vars();\n\n\t/* Set up the field variables */\n\tinit_fields();\n\n\t/* Now process the pre-assignments */\n\tfor (i = 0; i <= numassigns; i++) {\n\t\tif (preassigns[i].type == PRE_ASSIGN)\n\t\t\t(void) arg_assign(preassigns[i].val, true);\n\t\telse\t/* PRE_ASSIGN_FS */\n\t\t\tcmdline_fs(preassigns[i].val);\n\t\tefree(preassigns[i].val);\n\t}\n\n\tif (preassigns != NULL)\n\t\tefree(preassigns);\n\n\tif ((BINMODE & BINMODE_INPUT) != 0)\n\t\tif (os_setbinmode(fileno(stdin), O_BINARY) == -1)\n\t\t\tfatal(_(\"can't set binary mode on stdin (%s)\"), strerror(errno));\n\tif ((BINMODE & BINMODE_OUTPUT) != 0) {\n\t\tif (os_setbinmode(fileno(stdout), O_BINARY) == -1)\n\t\t\tfatal(_(\"can't set binary mode on stdout (%s)\"), strerror(errno));\n\t\tif (os_setbinmode(fileno(stderr), O_BINARY) == -1)\n\t\t\tfatal(_(\"can't set binary mode on stderr (%s)\"), strerror(errno));\n\t}\n\n#ifdef GAWKDEBUG\n\tsetbuf(stdout, (char *) NULL);\t/* make debugging easier */\n#endif\n\tif (os_isatty(fileno(stdout)))\n\t\toutput_is_tty = true;\n\n\t/* initialize API before loading extension libraries */\n\tinit_ext_api();\n\n\t/* load extension libs */\n        for (s = srcfiles->next; s != srcfiles; s = s->next) {\n                if (s->stype == SRC_EXTLIB)\n\t\t\tload_ext(s->fullpath);\n\t\telse if (s->stype != SRC_INC)\n\t\t\thave_srcfile++;\n        }\n\n\t/* do version check after extensions are loaded to get extension info */\n\tif (do_version)\n\t\tversion();\n\n\t/* No -f or --source options, use next arg */\n\tif (! have_srcfile) {\n\t\tif (optind > argc - 1 || stopped_early) /* no args left or no program */\n\t\t\tusage(EXIT_FAILURE, stderr);\n\t\t(void) add_srcfile(SRC_CMDLINE, argv[optind], srcfiles, NULL, NULL);\n\t\toptind++;\n\t}\n\n\t/* Select the interpreter routine */\n\tinit_interpret();\n\n\tinit_args(optind, argc,\n\t\t\tdo_posix ? argv[0] : myname,\n\t\t\targv);\n\n#if defined(LC_NUMERIC)\n\t/*\n\t * FRAGILE!  CAREFUL!\n\t * Pre-initing the variables with arg_assign() can change the\n\t * locale.  Force it to C before parsing the program.\n\t */\n\tsetlocale(LC_NUMERIC, \"C\");\n#endif\n\t/* Read in the program */\n\tif (parse_program(& code_block) != 0)\n\t\texit(EXIT_FAILURE);\n\n\tif (do_intl)\n\t\texit(EXIT_SUCCESS);\n\n\tinstall_builtins();\n\n\tif (do_lint)\n\t\tshadow_funcs();\n\n\tif (do_lint && code_block->nexti->opcode == Op_atexit)\n\t\tlintwarn(_(\"no program text at all!\"));\n\n\tload_symbols();\n\n\tif (do_profile)\n\t\tinit_profiling_signals();\n\n#if defined(LC_NUMERIC)\n\t/*\n\t * See comment above about using locale's decimal point.\n\t *\n\t * 10/2005:\n\t * Bitter experience teaches us that most people the world over\n\t * use period as the decimal point, not whatever their locale\n\t * uses.  Thus, only use the locale's decimal point if being\n\t * posixly anal-retentive.\n\t *\n\t * 7/2007:\n\t * Be a little bit kinder. Allow the --use-lc-numeric option\n\t * to also use the local decimal point. This avoids the draconian\n\t * strictness of POSIX mode if someone just wants to parse their\n\t * data using the local decimal point.\n\t */\n\tif (use_lc_numeric)\n\t\tsetlocale(LC_NUMERIC, locale);\n#endif\n\n\tinit_io();\n\toutput_fp = stdout;\n\n\tif (do_debug)\n\t\tdebug_prog(code_block);\n\telse if (do_pretty_print && ! do_profile)\n\t\t;\t/* run pretty printer only. */\n\telse\n\t\tinterpret(code_block);\n\n\tif (do_pretty_print) {\n\t\tdump_prog(code_block);\n\t\tdump_funcs();\n\t}\n\n\tif (do_dump_vars)\n\t\tdump_vars(varfile);\n\n#ifdef HAVE_MPFR\n\tif (do_mpfr)\n\t\tcleanup_mpfr();\n#endif\n\n\tif (do_tidy_mem)\n\t\trelease_all_vars();\n\n\t/* keep valgrind happier */\n\tif (extra_stack)\n\t\tefree(extra_stack);\n\n\tfinal_exit(exit_val);\n\treturn exit_val;\t/* to suppress warnings */\n}",
      "lines": 324,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "add_preassign": {
      "start_point": [
        543,
        0
      ],
      "end_point": [
        565,
        1
      ],
      "content": "static void\nadd_preassign(enum assign_type type, char *val)\n{\n\tstatic long alloc_assigns;\t\t/* for how many are allocated */\n\n#define INIT_SRC 4\n\n\t++numassigns;\n\n\tif (preassigns == NULL) {\n\t\temalloc(preassigns, struct pre_assign *,\n\t\t\tINIT_SRC * sizeof(struct pre_assign), \"add_preassign\");\n\t\talloc_assigns = INIT_SRC;\n\t} else if (numassigns >= alloc_assigns) {\n\t\talloc_assigns *= 2;\n\t\terealloc(preassigns, struct pre_assign *,\n\t\t\talloc_assigns * sizeof(struct pre_assign), \"add_preassigns\");\n\t}\n\tpreassigns[numassigns].type = type;\n\tpreassigns[numassigns].val = estrdup(val, strlen(val));\n\n#undef INIT_SRC\n}",
      "lines": 23,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "usage": {
      "start_point": [
        569,
        0
      ],
      "end_point": [
        661,
        1
      ],
      "content": "static void\nusage(int exitval, FILE *fp)\n{\n\t/* Not factoring out common stuff makes it easier to translate. */\n\tfprintf(fp, _(\"Usage: %s [POSIX or GNU style options] -f progfile [--] file ...\\n\"),\n\t\tmyname);\n\tfprintf(fp, _(\"Usage: %s [POSIX or GNU style options] [--] %cprogram%c file ...\\n\"),\n\t\t\tmyname, quote, quote);\n\n\t/* GNU long options info. This is too many options. */\n\n\tfputs(_(\"POSIX options:\\t\\tGNU long options: (standard)\\n\"), fp);\n\tfputs(_(\"\\t-f progfile\\t\\t--file=progfile\\n\"), fp);\n\tfputs(_(\"\\t-F fs\\t\\t\\t--field-separator=fs\\n\"), fp);\n\tfputs(_(\"\\t-v var=val\\t\\t--assign=var=val\\n\"), fp);\n\tfputs(_(\"Short options:\\t\\tGNU long options: (extensions)\\n\"), fp);\n\tfputs(_(\"\\t-b\\t\\t\\t--characters-as-bytes\\n\"), fp);\n\tfputs(_(\"\\t-c\\t\\t\\t--traditional\\n\"), fp);\n\tfputs(_(\"\\t-C\\t\\t\\t--copyright\\n\"), fp);\n\tfputs(_(\"\\t-d[file]\\t\\t--dump-variables[=file]\\n\"), fp);\n\tfputs(_(\"\\t-D[file]\\t\\t--debug[=file]\\n\"), fp);\n\tfputs(_(\"\\t-e 'program-text'\\t--source='program-text'\\n\"), fp);\n\tfputs(_(\"\\t-E file\\t\\t\\t--exec=file\\n\"), fp);\n\tfputs(_(\"\\t-g\\t\\t\\t--gen-pot\\n\"), fp);\n\tfputs(_(\"\\t-h\\t\\t\\t--help\\n\"), fp);\n\tfputs(_(\"\\t-i includefile\\t\\t--include=includefile\\n\"), fp);\n\tfputs(_(\"\\t-l library\\t\\t--load=library\\n\"), fp);\n\t/*\n\t * TRANSLATORS: the \"fatal\" and \"invalid\" here are literal\n\t * values, they should not be translated. Thanks.\n\t */\n\tfputs(_(\"\\t-L[fatal|invalid]\\t--lint[=fatal|invalid]\\n\"), fp);\n\tfputs(_(\"\\t-M\\t\\t\\t--bignum\\n\"), fp);\n\tfputs(_(\"\\t-N\\t\\t\\t--use-lc-numeric\\n\"), fp);\n\tfputs(_(\"\\t-n\\t\\t\\t--non-decimal-data\\n\"), fp);\n\tfputs(_(\"\\t-o[file]\\t\\t--pretty-print[=file]\\n\"), fp);\n\tfputs(_(\"\\t-O\\t\\t\\t--optimize\\n\"), fp);\n\tfputs(_(\"\\t-p[file]\\t\\t--profile[=file]\\n\"), fp);\n\tfputs(_(\"\\t-P\\t\\t\\t--posix\\n\"), fp);\n\tfputs(_(\"\\t-r\\t\\t\\t--re-interval\\n\"), fp);\n\tfputs(_(\"\\t-s\\t\\t\\t--no-optimize\\n\"), fp);\n\tfputs(_(\"\\t-S\\t\\t\\t--sandbox\\n\"), fp);\n\tfputs(_(\"\\t-t\\t\\t\\t--lint-old\\n\"), fp);\n\tfputs(_(\"\\t-V\\t\\t\\t--version\\n\"), fp);\n#ifdef NOSTALGIA\n\tfputs(_(\"\\t-W nostalgia\\t\\t--nostalgia\\n\"), fp);\n#endif\n#ifdef GAWKDEBUG\n\tfputs(_(\"\\t-Y\\t\\t--parsedebug\\n\"), fp);\n#endif\n\n\t/* This is one string to make things easier on translators. */\n\t/* TRANSLATORS: --help output 5 (end)\n\t   TRANSLATORS: the placeholder indicates the bug-reporting address\n\t   for this application.  Please add _another line_ with the\n\t   address for translation bugs.\n\t   no-wrap */\n\tfputs(_(\"\\nTo report bugs, see node `Bugs' in `gawk.info'\\n\\\nwhich is section `Reporting Problems and Bugs' in the\\n\\\nprinted version.  This same information may be found at\\n\\\nhttps://www.gnu.org/software/gawk/manual/html_node/Bugs.html.\\n\\\nPLEASE do NOT try to report bugs by posting in comp.lang.awk.\\n\\n\"), fp);\n\n\t/* ditto */\n\tfputs(_(\"gawk is a pattern scanning and processing language.\\n\\\nBy default it reads standard input and writes standard output.\\n\\n\"), fp);\n\n\t/* ditto */\n\tfputs(_(\"Examples:\\n\\tgawk '{ sum += $1 }; END { print sum }' file\\n\\\n\\tgawk -F: '{ print $1 }' /etc/passwd\\n\"), fp);\n\n\tfflush(fp);\n\n\tif (ferror(fp)) {\n#ifdef __MINGW32__\n\t\tif (errno == 0 || errno == EINVAL)\n\t\t\tw32_maybe_set_errno();\n#endif\n\t\t/* don't warn about stdout/stderr if EPIPE, but do error exit */\n\t\tif (errno == EPIPE)\n\t\t\tdie_via_sigpipe();\n\n\t\tif (fp == stdout)\n\t\t\twarning(_(\"error writing standard output (%s)\"), strerror(errno));\n\t\telse if (fp == stderr)\n\t\t\twarning(_(\"error writing standard error (%s)\"), strerror(errno));\n\n\t\t// some other problem than SIGPIPE\n\t\texit(EXIT_FAILURE);\n\t}\n\n\texit(exitval);\n}",
      "lines": 93,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "copyleft": {
      "start_point": [
        665,
        0
      ],
      "end_point": [
        704,
        1
      ],
      "content": "static void\ncopyleft()\n{\n\tstatic const char blurb_part1[] =\n\t  N_(\"Copyright (C) 1989, 1991-%d Free Software Foundation.\\n\\\n\\n\\\nThis program is free software; you can redistribute it and/or modify\\n\\\nit under the terms of the GNU General Public License as published by\\n\\\nthe Free Software Foundation; either version 3 of the License, or\\n\\\n(at your option) any later version.\\n\\\n\\n\");\n\tstatic const char blurb_part2[] =\n\t  N_(\"This program is distributed in the hope that it will be useful,\\n\\\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\\n\\\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n\\\nGNU General Public License for more details.\\n\\\n\\n\");\n\tstatic const char blurb_part3[] =\n\t  N_(\"You should have received a copy of the GNU General Public License\\n\\\nalong with this program. If not, see http://www.gnu.org/licenses/.\\n\");\n\n\t/* multiple blurbs are needed for some brain dead compilers. */\n\tprintf(_(blurb_part1), UPDATE_YEAR);\t/* Last update year */\n\tfputs(_(blurb_part2), stdout);\n\tfputs(_(blurb_part3), stdout);\n\tfflush(stdout);\n\n\tif (ferror(stdout)) {\n#ifdef __MINGW32__\n\t\tif (errno == 0 || errno == EINVAL)\n\t\t\tw32_maybe_set_errno();\n#endif\n\t\t/* don't warn about stdout if EPIPE, but do error exit */\n\t\tif (errno != EPIPE)\n\t\t\twarning(_(\"error writing standard output (%s)\"), strerror(errno));\n\t\texit(EXIT_FAILURE);\n\t}\n\n\texit(EXIT_SUCCESS);\n}",
      "lines": 40,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "cmdline_fs": {
      "start_point": [
        708,
        0
      ],
      "end_point": [
        731,
        1
      ],
      "content": "static void\ncmdline_fs(char *str)\n{\n\tNODE **tmp;\n\n\ttmp = &FS_node->var_value;\n\tunref(*tmp);\n\t/*\n\t * Only if in full compatibility mode check for the stupid special\n\t * case so -F\\t works as documented in awk book even though the shell\n\t * hands us -Ft.  Bleah!\n\t *\n\t * Thankfully, POSIX didn't propagate this \"feature\".\n\t */\n\tif (str[0] == 't' && str[1] == '\\0') {\n\t\tif (do_lint)\n\t\t\tlintwarn(_(\"-Ft does not set FS to tab in POSIX awk\"));\n\t\tif (do_traditional && ! do_posix)\n\t\t\tstr[0] = '\\t';\n\t}\n\n\t*tmp = make_str_node(str, strlen(str), SCAN); /* do process escapes */\n\tset_FS();\n}",
      "lines": 24,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "init_args": {
      "start_point": [
        735,
        0
      ],
      "end_point": [
        760,
        1
      ],
      "content": "static void\ninit_args(int argc0, int argc, const char *argv0, char **argv)\n{\n\tint i, j;\n\tNODE **aptr;\n\tNODE *tmp;\n\n\tARGV_node = install_symbol(estrdup(\"ARGV\", 4), Node_var_array);\n\ttmp =  make_number(0.0);\n\taptr = assoc_lookup(ARGV_node, tmp);\n\tunref(tmp);\n\tunref(*aptr);\n\t*aptr = make_string(argv0, strlen(argv0));\n\t(*aptr)->flags |= USER_INPUT;\n\tfor (i = argc0, j = 1; i < argc; i++, j++) {\n\t\ttmp = make_number((AWKNUM) j);\n\t\taptr = assoc_lookup(ARGV_node, tmp);\n\t\tunref(tmp);\n\t\tunref(*aptr);\n\t\t*aptr = make_string(argv[i], strlen(argv[i]));\n\t\t(*aptr)->flags |= USER_INPUT;\n\t}\n\n\tARGC_node = install_symbol(estrdup(\"ARGC\", 4), Node_var);\n\tARGC_node->var_value = make_number((AWKNUM) j);\n}",
      "lines": 26,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "init_vars": {
      "start_point": [
        819,
        0
      ],
      "end_point": [
        843,
        1
      ],
      "content": "static void\ninit_vars()\n{\n\tconst struct varinit *vp;\n\tNODE *n;\n\n\tfor (vp = varinit; vp->name != NULL; vp++) {\n\t\tif ((vp->flags & NO_INSTALL) != 0)\n\t\t\tcontinue;\n\t\tn = *(vp->spec) = install_symbol(estrdup(vp->name, strlen(vp->name)), Node_var);\n\t\tif (vp->strval != NULL)\n\t\t\tn->var_value = make_string(vp->strval, strlen(vp->strval));\n\t\telse\n\t\t\tn->var_value = make_number(vp->numval);\n\t\tn->var_assign = (Func_ptr) vp->assign;\n\t\tn->var_update = (Func_ptr) vp->update;\n\t\tif (vp->do_assign)\n\t\t\t(*(vp->assign))();\n\t}\n\n\t/* Load PROCINFO and ENVIRON */\n\tif (! do_traditional)\n\t\tload_procinfo();\n\tload_environ();\n}",
      "lines": 25,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "path_environ": {
      "start_point": [
        847,
        0
      ],
      "end_point": [
        873,
        1
      ],
      "content": "static void\npath_environ(const char *pname, const char *dflt)\n{\n\tconst char *val;\n\tNODE **aptr;\n\tNODE *tmp;\n\n\ttmp = make_string(pname, strlen(pname));\n\t/*\n\t * On VMS, environ[] only holds a subset of what getenv() can\n\t * find, so look AWKPATH up before resorting to default path.\n\t */\n\tval = getenv(pname);\n\tif (val == NULL || *val == '\\0')\n\t\tval = dflt;\n\taptr = assoc_lookup(ENVIRON_node, tmp);\n\t/*\n\t * If original value was the empty string, set it to\n\t * the default value.\n\t */\n\tif ((*aptr)->stlen == 0) {\n\t\tunref(*aptr);\n\t\t*aptr = make_string(val, strlen(val));\n\t}\n\n\tunref(tmp);\n}",
      "lines": 27,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "load_environ": {
      "start_point": [
        877,
        0
      ],
      "end_point": [
        931,
        1
      ],
      "content": "static NODE *\nload_environ()\n{\n#if ! (defined(VMS) && defined(__DECC))\n\textern char **environ;\n#endif\n\tchar *var, *val;\n\tNODE **aptr;\n\tint i;\n\tNODE *tmp;\n\tstatic bool been_here = false;\n\n\tif (been_here)\n\t\treturn ENVIRON_node;\n\n\tbeen_here = true;\n\n\tENVIRON_node = install_symbol(estrdup(\"ENVIRON\", 7), Node_var_array);\n\tfor (i = 0; environ[i] != NULL; i++) {\n\t\tstatic char nullstr[] = \"\";\n\n\t\tvar = environ[i];\n\t\tval = strchr(var, '=');\n\t\tif (val != NULL)\n\t\t\t*val++ = '\\0';\n\t\telse\n\t\t\tval = nullstr;\n\t\ttmp = make_string(var, strlen(var));\n\t\taptr = assoc_lookup(ENVIRON_node, tmp);\n\t\tunref(tmp);\n\t\tunref(*aptr);\n\t\t*aptr = make_string(val, strlen(val));\n\t\t(*aptr)->flags |= USER_INPUT;\n\n\t\t/* restore '=' so that system() gets a valid environment */\n\t\tif (val != nullstr)\n\t\t\t*--val = '=';\n\t}\n\t/*\n\t * Put AWKPATH and AWKLIBPATH into ENVIRON if not already there.\n\t * This allows querying it from within awk programs.\n\t *\n\t * October 2014:\n\t * If their values are \"\", override with the default values;\n\t * since 2.10 AWKPATH used default value if environment's\n\t * value was \"\".\n\t */\n\tpath_environ(\"AWKPATH\", defpath);\n\tpath_environ(\"AWKLIBPATH\", deflibpath);\n\n\t/* set up array functions */\n\tinit_env_array(ENVIRON_node);\n\n\treturn ENVIRON_node;\n}",
      "lines": 55,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "NODE",
        "*\nload_environ()",
        "*"
      ]
    },
    "load_procinfo_argv": {
      "start_point": [
        933,
        0
      ],
      "end_point": [
        958,
        1
      ],
      "content": "static void\nload_procinfo_argv()\n{\n\tNODE *tmp;\n\tNODE **aptr;\n\tNODE *argv_array;\n\tint i;\n\n\ttmp = make_string(\"argv\", 4);\n\taptr = assoc_lookup(PROCINFO_node, tmp);\n\tunref(tmp);\n\tunref(*aptr);\n\tgetnode(argv_array);\n \tmemset(argv_array, '\\0', sizeof(NODE));  /* valgrind wants this */\n\tnull_array(argv_array);\n\t*aptr = argv_array;\n\targv_array->parent_array = PROCINFO_node;\n\targv_array->vname = estrdup(\"argv\", 4);\n\tfor (i = 0; d_argv[i] != NULL; i++) {\n\t\ttmp = make_number(i);\n\t\taptr = assoc_lookup(argv_array, tmp);\n\t\tunref(tmp);\n\t\tunref(*aptr);\n\t\t*aptr = make_string(d_argv[i], strlen(d_argv[i]));\n\t}\n}",
      "lines": 26,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "load_procinfo": {
      "start_point": [
        962,
        0
      ],
      "end_point": [
        1046,
        1
      ],
      "content": "static NODE *\nload_procinfo()\n{\n#if defined (HAVE_GETGROUPS) && defined(NGROUPS_MAX) && NGROUPS_MAX > 0\n\tint i;\n#endif\n#if (defined (HAVE_GETGROUPS) && defined(NGROUPS_MAX) && NGROUPS_MAX > 0) || defined(HAVE_MPFR)\n\tchar name[100];\n#endif\n\tAWKNUM value;\n\tstatic bool been_here = false;\n\n\tif (been_here)\n\t\treturn PROCINFO_node;\n\n\tbeen_here = true;\n\n\tPROCINFO_node = install_symbol(estrdup(\"PROCINFO\", 8), Node_var_array);\n\n\tupdate_PROCINFO_str(\"version\", VERSION);\n\tupdate_PROCINFO_str(\"strftime\", def_strftime_format);\n\n#ifdef HAVE_MPFR\n\tsprintf(name, \"GNU MPFR %s\", mpfr_get_version());\n\tupdate_PROCINFO_str(\"mpfr_version\", name);\n\tsprintf(name, \"GNU MP %s\", gmp_version);\n\tupdate_PROCINFO_str(\"gmp_version\", name);\n\tupdate_PROCINFO_num(\"prec_max\", MPFR_PREC_MAX);\n\tupdate_PROCINFO_num(\"prec_min\", MPFR_PREC_MIN);\n#endif\n\n#ifdef DYNAMIC\n\tupdate_PROCINFO_num(\"api_major\", GAWK_API_MAJOR_VERSION);\n\tupdate_PROCINFO_num(\"api_minor\", GAWK_API_MINOR_VERSION);\n#endif\n\n#ifdef GETPGRP_VOID\n#define getpgrp_arg() /* nothing */\n#else\n#define getpgrp_arg() getpid()\n#endif\n\n\tvalue = getpgrp(getpgrp_arg());\n\tupdate_PROCINFO_num(\"pgrpid\", value);\n\n\t/*\n\t * Could put a lot of this into a table, but then there's\n\t * portability problems declaring all the functions. So just\n\t * do it the slow and stupid way. Sigh.\n\t */\n\n\tvalue = getpid();\n\tupdate_PROCINFO_num(\"pid\", value);\n\n\tvalue = getppid();\n\tupdate_PROCINFO_num(\"ppid\", value);\n\n\tvalue = getuid();\n\tupdate_PROCINFO_num(\"uid\", value);\n\n\tvalue = geteuid();\n\tupdate_PROCINFO_num(\"euid\", value);\n\n\tvalue = getgid();\n\tupdate_PROCINFO_num(\"gid\", value);\n\n\tvalue = getegid();\n\tupdate_PROCINFO_num(\"egid\", value);\n\n\tupdate_PROCINFO_str(\"FS\", current_field_sep_str());\n\n#if defined (HAVE_GETGROUPS) && defined(NGROUPS_MAX) && NGROUPS_MAX > 0\n\tfor (i = 0; i < ngroups; i++) {\n\t\tsprintf(name, \"group%d\", i + 1);\n\t\tvalue = groupset[i];\n\t\tupdate_PROCINFO_num(name, value);\n\t}\n\tif (groupset) {\n\t\tefree(groupset);\n\t\tgroupset = NULL;\n\t}\n#endif\n\tload_procinfo_argv();\n\treturn PROCINFO_node;\n}",
      "lines": 85,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "NODE",
        "*\nload_procinfo()",
        "*"
      ]
    },
    "is_std_var": {
      "start_point": [
        1050,
        0
      ],
      "end_point": [
        1065,
        1
      ],
      "content": "int\nis_std_var(const char *var)\n{\n\tconst struct varinit *vp;\n\n\tfor (vp = varinit; vp->name != NULL; vp++) {\n\t\tif (strcmp(vp->name, var) == 0) {\n\t\t\tif ((do_traditional || do_posix) && (vp->flags & NON_STANDARD) != 0)\n\t\t\t\treturn false;\n\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}",
      "lines": 16,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "is_off_limits_var": {
      "start_point": [
        1072,
        0
      ],
      "end_point": [
        1083,
        1
      ],
      "content": "int\nis_off_limits_var(const char *var)\n{\n\tconst struct varinit *vp;\n\n\tfor (vp = varinit; vp->name != NULL; vp++) {\n\t\tif (strcmp(vp->name, var) == 0)\n\t\t\treturn ((vp->flags & NOT_OFF_LIMITS) == 0);\n\t}\n\n\treturn false;\n}",
      "lines": 12,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "get_spec_varname": {
      "start_point": [
        1089,
        0
      ],
      "end_point": [
        1101,
        1
      ],
      "content": "const char *\nget_spec_varname(Func_ptr fptr)\n{\n\tconst struct varinit *vp;\n\n\tif (! fptr)\n\t\treturn NULL;\n\tfor (vp = varinit; vp->name != NULL; vp++) {\n\t\tif (vp->assign == fptr || vp->update == fptr)\n\t\t\treturn vp->name;\n\t}\n\treturn NULL;\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nget_spec_varname(Func_ptr fptr)",
        "*"
      ]
    },
    "arg_assign": {
      "start_point": [
        1106,
        0
      ],
      "end_point": [
        1211,
        1
      ],
      "content": "int\narg_assign(char *arg, bool initing)\n{\n\tchar *cp, *cp2;\n\tbool badvar;\n\tNODE *var;\n\tNODE *it;\n\tNODE **lhs;\n\tlong save_FNR;\n\n\tif (! initing && disallow_var_assigns)\n\t\treturn false;\t/* --exec */\n\n\tcp = strchr(arg, '=');\n\n\tif (cp == NULL) {\n\t\tif (! initing)\n\t\t\treturn false;\t/* This is file name, not assignment. */\n\n\t\tfprintf(stderr,\n\t\t\t_(\"%s: `%s' argument to `-v' not in `var=value' form\\n\\n\"),\n\t\t\tmyname, arg);\n\t\tusage(EXIT_FAILURE, stderr);\n\t}\n\n\t*cp++ = '\\0';\n\n\t/* avoid false source indications in a fatal message */\n\tsource = NULL;\n\tsourceline = 0;\n\tsave_FNR = FNR;\n\tFNR = 0;\n\n\t/* first check that the variable name has valid syntax */\n\tbadvar = false;\n\tif (! is_letter((unsigned char) arg[0]))\n\t\tbadvar = true;\n\telse\n\t\tfor (cp2 = arg+1; *cp2; cp2++)\n\t\t\tif (! is_identchar((unsigned char) *cp2)) {\n\t\t\t\tbadvar = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\tif (badvar) {\n\t\tif (initing)\n\t\t\tfatal(_(\"`%s' is not a legal variable name\"), arg);\n\n\t\tif (do_lint)\n\t\t\tlintwarn(_(\"`%s' is not a variable name, looking for file `%s=%s'\"),\n\t\t\t\targ, arg, cp);\n\t} else {\n\t\tif (check_special(arg) >= 0)\n\t\t\tfatal(_(\"cannot use gawk builtin `%s' as variable name\"), arg);\n\n\t\tif (! initing) {\n\t\t\tvar = lookup(arg);\n\t\t\tif (var != NULL && var->type == Node_func)\n\t\t\t\tfatal(_(\"cannot use function `%s' as variable name\"), arg);\n\t\t}\n\n\t\t/*\n\t\t * BWK awk expands escapes inside assignments.\n\t\t * This makes sense, so we do it too.\n\t\t */\n\t\tit = make_str_node(cp, strlen(cp), SCAN);\n\t\tit->flags |= USER_INPUT;\n#ifdef LC_NUMERIC\n\t\t/*\n\t\t * See comment above about locale decimal point.\n\t\t */\n\t\tif (do_posix)\n\t\t\tsetlocale(LC_NUMERIC, \"C\");\n#endif /* LC_NUMERIC */\n\t\t(void) force_number(it);\n#ifdef LC_NUMERIC\n\t\tif (do_posix)\n\t\t\tsetlocale(LC_NUMERIC, locale);\n#endif /* LC_NUMERIC */\n\n\t\t/*\n\t\t * since we are restoring the original text of ARGV later,\n\t\t * need to copy the variable name part if we don't want\n\t\t * name like v=abc instead of just v in var->vname\n\t\t */\n\n\t\tcp2 = estrdup(arg, cp - arg);\t/* var name */\n\n\t\tvar = variable(0, cp2, Node_var);\n\t\tif (var == NULL)\t/* error */\n\t\t\tfinal_exit(EXIT_FATAL);\n\t\tif (var->type == Node_var && var->var_update)\n\t\t\tvar->var_update();\n\t\tlhs = get_lhs(var, false);\n\t\tunref(*lhs);\n\t\t*lhs = it;\n\t\t/* check for set_FOO() routine */\n\t\tif (var->type == Node_var && var->var_assign)\n\t\t\tvar->var_assign();\n\t}\n\n\tif (! initing)\n\t\t*--cp = '=';\t/* restore original text of ARGV */\n\tFNR = save_FNR;\n\treturn ! badvar;\n}",
      "lines": 106,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "catchsig": {
      "start_point": [
        1215,
        0
      ],
      "end_point": [
        1234,
        1
      ],
      "content": "static void\ncatchsig(int sig)\n{\n\tif (sig == SIGFPE) {\n\t\tfatal(_(\"floating point exception\"));\n\t} else if (sig == SIGSEGV\n#ifdef SIGBUS\n\t        || sig == SIGBUS\n#endif\n\t) {\n\t\tset_loc(__FILE__, __LINE__);\n\t\tmsg(_(\"fatal error: internal error\"));\n\t\t/* fatal won't abort() if not compiled for debugging */\n\t\t// GLIBC 2.27 doesn't necessarily flush on abort. Sigh.\n\t\tfflush(NULL);\n\t\tabort();\n\t} else\n\t\tcant_happen();\n\t/* NOTREACHED */\n}",
      "lines": 20,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "catchsegv": {
      "start_point": [
        1239,
        0
      ],
      "end_point": [
        1248,
        1
      ],
      "content": "static int\ncatchsegv(void *fault_address, int serious)\n{\n\tset_loc(__FILE__, __LINE__);\n\tmsg(_(\"fatal error: internal error: segfault\"));\n\tfflush(NULL);\n\tabort();\n\t/*NOTREACHED*/\n\treturn 0;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "catchstackoverflow": {
      "start_point": [
        1252,
        0
      ],
      "end_point": [
        1261,
        1
      ],
      "content": "static void\ncatchstackoverflow(int emergency, stackoverflow_context_t scp)\n{\n\tset_loc(__FILE__, __LINE__);\n\tmsg(_(\"fatal error: internal error: stack overflow\"));\n\tfflush(NULL);\n\tabort();\n\t/*NOTREACHED*/\n\treturn;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "nostalgia": {
      "start_point": [
        1266,
        0
      ],
      "end_point": [
        1276,
        1
      ],
      "content": "static void\nnostalgia()\n{\n\t/*\n\t * N.B.: This string is not gettextized, on purpose.\n\t * So there.\n\t */\n\tfprintf(stderr, \"awk: bailing out near line 1\\n\");\n\tfflush(stderr);\n\tabort();\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "version": {
      "start_point": [
        1280,
        0
      ],
      "end_point": [
        1299,
        1
      ],
      "content": "static void\nversion()\n{\n\tprintf(\"%s\", version_string);\n#ifdef DYNAMIC\n\tprintf(\", API: %d.%d\", GAWK_API_MAJOR_VERSION, GAWK_API_MINOR_VERSION);\n#endif\n#ifdef HAVE_MPFR\n\tprintf(\" (GNU MPFR %s, GNU MP %s)\", mpfr_get_version(), gmp_version);\n#endif\n\tprintf(\"\\n\");\n\tprint_ext_versions();\n\n\t/*\n\t * Per GNU coding standards, print copyright info,\n\t * then exit successfully, do nothing else.\n\t */\n\tcopyleft();\n\texit(EXIT_SUCCESS);\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "init_fds": {
      "start_point": [
        1303,
        0
      ],
      "end_point": [
        1327,
        1
      ],
      "content": "static void\ninit_fds()\n{\n\tstruct stat sbuf;\n\tint fd;\n\tint newfd;\n\tchar const *const opposite_mode[] = {\"w\", \"r\", \"r\"};\n\n\t/* maybe no stderr, don't bother with error mesg */\n\tfor (fd = 0; fd <= 2; fd++) {\n\t\tif (fstat(fd, &sbuf) < 0) {\n#if MAKE_A_HEROIC_EFFORT\n\t\t\tif (do_lint)\n\t\t\t\tlintwarn(_(\"no pre-opened fd %d\"), fd);\n#endif\n\t\t\tnewfd = devopen(\"/dev/null\", opposite_mode[fd]);\n\t\t\t/* turn off some compiler warnings \"set but not used\" */\n\t\t\tnewfd += 0;\n#ifdef MAKE_A_HEROIC_EFFORT\n\t\t\tif (do_lint && newfd < 0)\n\t\t\t\tlintwarn(_(\"could not pre-open /dev/null for fd %d\"), fd);\n#endif\n\t\t}\n\t}\n}",
      "lines": 25,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "init_groupset": {
      "start_point": [
        1331,
        0
      ],
      "end_point": [
        1360,
        1
      ],
      "content": "static void\ninit_groupset()\n{\n#if defined(HAVE_GETGROUPS) && defined(NGROUPS_MAX) && NGROUPS_MAX > 0\n#ifdef GETGROUPS_NOT_STANDARD\n\t/* For systems that aren't standards conformant, use old way. */\n\tngroups = NGROUPS_MAX;\n#else\n\t/*\n\t * If called with 0 for both args, return value is\n\t * total number of groups.\n\t */\n\tngroups = getgroups(0, NULL);\n#endif\n\t/* If an error or no groups, just give up and get on with life. */\n\tif (ngroups <= 0)\n\t\treturn;\n\n\t/* fill in groups */\n\temalloc(groupset, GETGROUPS_T *, ngroups * sizeof(GETGROUPS_T), \"init_groupset\");\n\n\tngroups = getgroups(ngroups, groupset);\n\t/* same thing here, give up but keep going */\n\tif (ngroups == -1) {\n\t\tefree(groupset);\n\t\tngroups = 0;\n\t\tgroupset = NULL;\n\t}\n#endif\n}",
      "lines": 30,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "estrdup": {
      "start_point": [
        1364,
        0
      ],
      "end_point": [
        1372,
        1
      ],
      "content": "char *\nestrdup(const char *str, size_t len)\n{\n\tchar *s;\n\temalloc(s, char *, len + 1, \"estrdup\");\n\tmemcpy(s, str, len);\n\ts[len] = '\\0';\n\treturn s;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "char",
        "*\nestrdup(const char *str, size_t len)",
        "*"
      ]
    },
    "init_locale": {
      "start_point": [
        1386,
        0
      ],
      "end_point": [
        1403,
        1
      ],
      "content": "static void\ninit_locale(struct lconv *l)\n{\n\tstruct lconv *t;\n\n\tt = localeconv();\n\t*l = *t;\n\tl->thousands_sep = estrdup(t->thousands_sep, strlen(t->thousands_sep));\n\tl->decimal_point = estrdup(t->decimal_point, strlen(t->decimal_point));\n\tl->grouping = estrdup(t->grouping, strlen(t->grouping));\n\tl->int_curr_symbol = estrdup(t->int_curr_symbol, strlen(t->int_curr_symbol));\n\tl->currency_symbol = estrdup(t->currency_symbol, strlen(t->currency_symbol));\n\tl->mon_decimal_point = estrdup(t->mon_decimal_point, strlen(t->mon_decimal_point));\n\tl->mon_thousands_sep = estrdup(t->mon_thousands_sep, strlen(t->mon_thousands_sep));\n\tl->mon_grouping = estrdup(t->mon_grouping, strlen(t->mon_grouping));\n\tl->positive_sign = estrdup(t->positive_sign, strlen(t->positive_sign));\n\tl->negative_sign = estrdup(t->negative_sign, strlen(t->negative_sign));\n}",
      "lines": 18,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "save_argv": {
      "start_point": [
        1408,
        0
      ],
      "end_point": [
        1417,
        1
      ],
      "content": "static void\nsave_argv(int argc, char **argv)\n{\n\tint i;\n\n\temalloc(d_argv, char **, (argc + 1) * sizeof(char *), \"save_argv\");\n\tfor (i = 0; i < argc; i++)\n\t\td_argv[i] = estrdup(argv[i], strlen(argv[i]));\n\td_argv[argc] = NULL;\n}",
      "lines": 10,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "update_global_values": {
      "start_point": [
        1426,
        0
      ],
      "end_point": [
        1435,
        1
      ],
      "content": "void\nupdate_global_values()\n{\n\tconst struct varinit *vp;\n\n\tfor (vp = varinit; vp->name; vp++) {\n\t\tif (vp->update != NULL)\n\t\t\tvp->update();\n\t}\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "getenv_long": {
      "start_point": [
        1439,
        0
      ],
      "end_point": [
        1450,
        1
      ],
      "content": "long\ngetenv_long(const char *name)\n{\n\tconst char *val;\n\tlong newval;\n\tif ((val = getenv(name)) != NULL && isdigit((unsigned char) *val)) {\n\t\tfor (newval = 0; *val && isdigit((unsigned char) *val); val++)\n\t\t\tnewval = (newval * 10) + *val - '0';\n\t\treturn newval;\n\t}\n\treturn -1;\n}",
      "lines": 12,
      "depth": 12,
      "decorators": [
        "long",
        "long"
      ]
    },
    "parse_args": {
      "start_point": [
        1454,
        0
      ],
      "end_point": [
        1701,
        1
      ],
      "content": "static void\nparse_args(int argc, char **argv)\n{\n\t/*\n\t * The + on the front tells GNU getopt not to rearrange argv.\n\t */\n\tconst char *optlist = \"+F:f:v:W;bcCd::D::e:E:ghi:l:L::nNo::Op::MPrSstVYZ:\";\n\tint old_optind;\n\tint c;\n\tchar *scan;\n\tchar *src;\n\n\t/* we do error messages ourselves on invalid options */\n\topterr = false;\n\n\t/* copy argv before getopt gets to it; used to restart the debugger */\n\tsave_argv(argc, argv);\n\n\t/* option processing. ready, set, go! */\n\tfor (optopt = 0, old_optind = 1;\n\t     (c = getopt_long(argc, argv, optlist, optab, NULL)) != EOF;\n\t     optopt = 0, old_optind = optind) {\n\t\tif (do_posix)\n\t\t\topterr = true;\n\n\t\tswitch (c) {\n\t\tcase 'F':\n\t\t\tadd_preassign(PRE_ASSIGN_FS, optarg);\n\t\t\tbreak;\n\n\t\tcase 'E':\n\t\t\tdisallow_var_assigns = true;\n\t\t\t/* fall through */\n\t\tcase 'f':\n\t\t\t/*\n\t\t\t * Allow multiple -f options.\n\t\t\t * This makes function libraries real easy.\n\t\t\t * Most of the magic is in the scanner.\n\t\t\t *\n\t\t\t * The following is to allow for whitespace at the end\n\t\t\t * of a #! /bin/gawk line in an executable file\n\t\t\t */\n\t\t\tscan = optarg;\n\t\t\tif (argv[optind-1] != optarg)\n\t\t\t\twhile (isspace((unsigned char) *scan))\n\t\t\t\t\tscan++;\n\t\t\tsrc = (*scan == '\\0' ? argv[optind++] : optarg);\n\t\t\t(void) add_srcfile((src && src[0] == '-' && src[1] == '\\0') ?\n\t\t\t\t\tSRC_STDIN : SRC_FILE,\n\t\t\t\t\tsrc, srcfiles, NULL, NULL);\n\n\t\t\tbreak;\n\n\t\tcase 'v':\n\t\t\tadd_preassign(PRE_ASSIGN, optarg);\n\t\t\tbreak;\n\n\t\tcase 'b':\n\t\t\tdo_binary = true;\n\t\t\tbreak;\n\n\t\tcase 'c':\n\t\t\tdo_flags |= DO_TRADITIONAL;\n\t\t\tbreak;\n\n\t\tcase 'C':\n\t\t\tcopyleft();\n\t\t\tbreak;\n\n\t\tcase 'd':\n\t\t\tdo_flags |= DO_DUMP_VARS;\n\t\t\tif (optarg != NULL && optarg[0] != '\\0')\n\t\t\t\tvarfile = optarg;\n\t\t\tbreak;\n\n\t\tcase 'D':\n\t\t\tdo_flags |= DO_DEBUG;\n\t\t\tif (optarg != NULL && optarg[0] != '\\0')\n\t\t\t\tcommand_file = optarg;\n\t\t\tbreak;\n\n\t\tcase 'e':\n\t\t\tif (optarg[0] == '\\0')\n\t\t\t\twarning(_(\"empty argument to `-e/--source' ignored\"));\n\t\t\telse\n\t\t\t\t(void) add_srcfile(SRC_CMDLINE, optarg, srcfiles, NULL, NULL);\n\t\t\tbreak;\n\n\t\tcase 'g':\n\t\t\tdo_flags |= DO_INTL;\n\t\t\tbreak;\n\n\t\tcase 'h':\n\t\t\t/* write usage to stdout, per GNU coding stds */\n\t\t\tusage(EXIT_SUCCESS, stdout);\n\t\t\tbreak;\n\n\t\tcase 'i':\n\t\t\t(void) add_srcfile(SRC_INC, optarg, srcfiles, NULL, NULL);\n\t\t\tbreak;\n\n\t\tcase 'l':\n\t\t\t(void) add_srcfile(SRC_EXTLIB, optarg, srcfiles, NULL, NULL);\n\t\t\tbreak;\n\n#ifndef NO_LINT\n\t\tcase 'L':\n\t\t\tdo_flags |= DO_LINT_ALL;\n\t\t\tif (optarg != NULL) {\n\t\t\t\tif (strcmp(optarg, \"fatal\") == 0)\n\t\t\t\t\tlintfunc = r_fatal;\n\t\t\t\telse if (strcmp(optarg, \"invalid\") == 0) {\n\t\t\t\t\tdo_flags &= ~DO_LINT_ALL;\n\t\t\t\t\tdo_flags |= DO_LINT_INVALID;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 't':\n\t\t\tdo_flags |= DO_LINT_OLD;\n\t\t\tbreak;\n#else\n\t\tcase 'L':\n\t\tcase 't':\n\t\t\tbreak;\n#endif\n\n\t\tcase 'n':\n\t\t\tdo_flags |= DO_NON_DEC_DATA;\n\t\t\tbreak;\n\n\t\tcase 'N':\n\t\t\tuse_lc_numeric = true;\n\t\t\tbreak;\n\n\t\tcase 'O':\n\t\t\tdo_optimize = true;\n\t\t\tbreak;\n\n\t\tcase 'p':\n\t\t\tdo_flags |= DO_PROFILE;\n\t\t\t/* fall through */\n\t\tcase 'o':\n\t\t\tdo_flags |= DO_PRETTY_PRINT;\n\t\t\tif (optarg != NULL)\n\t\t\t\tset_prof_file(optarg);\n\t\t\telse\n\t\t\t\tset_prof_file(DEFAULT_PROFILE);\n\t\t\tbreak;\n\n\t\tcase 'M':\n#ifdef HAVE_MPFR\n\t\t\tdo_flags |= DO_MPFR;\n#else\n\t\t\twarning(_(\"-M ignored: MPFR/GMP support not compiled in\"));\n#endif\n\t\t\tbreak;\n\n\t\tcase 'P':\n\t\t\tdo_flags |= DO_POSIX;\n\t\t\tbreak;\n\n\t\tcase 'r':\n\t\t\tdo_flags |= DO_INTERVALS;\n \t\t\tbreak;\n\n\t\tcase 's':\n\t\t\tdo_optimize = false;\n\t\t\tbreak;\n\n\t\tcase 'S':\n\t\t\tdo_flags |= DO_SANDBOX;\n  \t\t\tbreak;\n\n\t\tcase 'V':\n\t\t\tdo_version = true;\n\t\t\tbreak;\n\n\t\tcase 'W':       /* gawk specific options - now in getopt_long */\n\t\t\tfprintf(stderr, _(\"%s: option `-W %s' unrecognized, ignored\\n\"),\n\t\t\t\targv[0], optarg);\n\t\t\tbreak;\n\n\t\tcase 0:\n\t\t\t/*\n\t\t\t * getopt_long found an option that sets a variable\n\t\t\t * instead of returning a letter. Do nothing, just\n\t\t\t * cycle around for the next one.\n\t\t\t */\n\t\t\tbreak;\n\n\t\tcase 'Y':\n\t\tcase 'Z':\n#if defined(YYDEBUG) || defined(GAWKDEBUG)\n\t\t\tif (c == 'Y') {\n\t\t\t\tyydebug = 2;\n\t\t\t\tbreak;\n\t\t\t}\n#endif\n#if defined(LOCALEDEBUG)\n\t\t\tif (c == 'Z') {\n\t\t\t\tlocale = optarg;\n\t\t\t\tbreak;\n\t\t\t}\n#endif\n\t\t\t/* if not debugging, fall through */\n\t\tcase '?':\n\t\tdefault:\n\t\t\t/*\n\t\t\t * If not posix, an unrecognized option stops argument\n\t\t\t * processing so that it can go into ARGV for the awk\n\t\t\t * program to see. This makes use of ``#! /bin/gawk -f''\n\t\t\t * easier.\n\t\t\t *\n\t\t\t * However, it's never simple. If optopt is set,\n\t\t\t * an option that requires an argument didn't get the\n\t\t\t * argument. We care because if opterr is 0, then\n\t\t\t * getopt_long won't print the error message for us.\n\t\t\t */\n\t\t\tif (! do_posix\n\t\t\t    && (optopt == '\\0' || strchr(optlist, optopt) == NULL)) {\n\t\t\t\t/*\n\t\t\t\t * can't just do optind--. In case of an\n\t\t\t\t * option with >= 2 letters, getopt_long\n\t\t\t\t * won't have incremented optind.\n\t\t\t\t */\n\t\t\t\toptind = old_optind;\n\t\t\t\tstopped_early = true;\n\t\t\t\tgoto out;\n\t\t\t} else if (optopt != '\\0') {\n\t\t\t\t/* Use POSIX required message format */\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t_(\"%s: option requires an argument -- %c\\n\"),\n\t\t\t\t\tmyname, optopt);\n\t\t\t\tusage(EXIT_FAILURE, stderr);\n\t\t\t}\n\t\t\t/* else\n\t\t\t\tlet getopt print error message for us */\n\t\t\tbreak;\n\t\t}\n\t\tif (c == 'E')\t/* --exec ends option processing */\n\t\t\tbreak;\n\t}\nout:\n\tdo_optimize = (do_optimize && ! do_pretty_print);\n\n\treturn;\n}",
      "lines": 248,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "set_locale_stuff": {
      "start_point": [
        1705,
        0
      ],
      "end_point": [
        1742,
        1
      ],
      "content": "static void\nset_locale_stuff(void)\n{\n#if defined(LC_CTYPE)\n\tsetlocale(LC_CTYPE, locale);\n#endif\n#if defined(LC_COLLATE)\n\tsetlocale(LC_COLLATE, locale);\n#endif\n#if defined(LC_MESSAGES)\n\tsetlocale(LC_MESSAGES, locale);\n#endif\n#if defined(LC_NUMERIC) && defined(HAVE_LOCALE_H)\n\t/*\n\t * Force the issue here.  According to POSIX 2001, decimal\n\t * point is used for parsing source code and for command-line\n\t * assignments and the locale value for processing input,\n\t * number to string conversion, and printing output.\n\t *\n\t * 10/2005 --- see below also; we now only use the locale's\n\t * decimal point if do_posix in effect.\n\t *\n\t * 9/2007:\n\t * This is a mess. We need to get the locale's numeric info for\n\t * the thousands separator for the %'d flag.\n\t */\n\tsetlocale(LC_NUMERIC, locale);\n\tinit_locale(& loc);\n\tsetlocale(LC_NUMERIC, \"C\");\n#endif\n#if defined(LC_TIME)\n\tsetlocale(LC_TIME, locale);\n#endif\n\n\t/* These must be done after calling setlocale */\n\t(void) bindtextdomain(PACKAGE, locale_dir);\n\t(void) textdomain(PACKAGE);\n}",
      "lines": 38,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "gawk/gawk-4.2.1/mbsupport.h": {},
  "gawk/gawk-4.2.1/mpfr.c": {
    "init_mpfr": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "void\ninit_mpfr(mpfr_prec_t prec, const char *rmode)\n{\n\tmpfr_set_default_prec(default_prec = prec);\n\tROUND_MODE = get_rnd_mode(rmode[0]);\n\tmpfr_set_default_rounding_mode(ROUND_MODE);\n\tmake_number = mpg_make_number;\n\tstr2number = mpg_force_number;\n\tformat_val = mpg_format_val;\n\tcmp_numbers = mpg_cmp;\n\n\tmpz_init(MNR);\n\tmpz_init(MFNR);\n\tdo_ieee_fmt = false;\n\n\tmpfr_init2(_mpf_t1, PRECISION_MIN);\n\tmpfr_init2(_mpf_t2, PRECISION_MIN);\n\tmpz_init(mpzval);\n\n\tregister_exec_hook(mpg_interpret, 0);\n}",
      "lines": 21,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "cleanup_mpfr": {
      "start_point": [
        98,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "void\ncleanup_mpfr(void)\n{\n\tmpfr_clear(_mpf_t1);\n\tmpfr_clear(_mpf_t2);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "mpg_node": {
      "start_point": [
        107,
        0
      ],
      "end_point": [
        119,
        1
      ],
      "content": "NODE *\nmpg_node(unsigned int flags)\n{\n\tNODE *r = make_number_node(flags);\n\n\tif (flags == MPFN)\n\t\t/* Initialize, set precision to the default precision, and value to NaN */\n\t\tmpfr_init(r->mpg_numbr);\n\telse\n\t\t/* Initialize and set value to 0 */\n\t\tmpz_init(r->mpg_i);\n\treturn r;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "NODE",
        "*\nmpg_node(unsigned int flags)",
        "*"
      ]
    },
    "mpg_make_number": {
      "start_point": [
        126,
        0
      ],
      "end_point": [
        142,
        1
      ],
      "content": "static NODE *\nmpg_make_number(double x)\n{\n\tNODE *r;\n\tdouble ival;\n\n\tif ((ival = double_to_int(x)) != x) {\n\t\tint tval;\n\t\tr = mpg_float();\n\t\ttval = mpfr_set_d(r->mpg_numbr, x, ROUND_MODE);\n\t\tIEEE_FMT(r->mpg_numbr, tval);\n\t} else {\n\t\tr = mpg_integer();\n\t\tmpz_set_d(r->mpg_i, ival);\n\t}\n\treturn r;\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "NODE",
        "*\nmpg_make_number(double x)",
        "*"
      ]
    },
    "mpg_strtoui": {
      "start_point": [
        146,
        0
      ],
      "end_point": [
        209,
        1
      ],
      "content": "int\nmpg_strtoui(mpz_ptr zi, char *str, size_t len, char **end, int base)\n{\n\tchar *s = str;\n\tchar *start;\n\tint ret = -1;\n\n\t/*\n\t * mpz_set_str does not like leading 0x or 0X for hex (or 0 for octal)\n\t * with a non-zero base argument.\n\t*/\n\tif (base == 16 && len >= 2 && *s == '0' && (s[1] == 'x' || s[1] == 'X')) {\n\t\ts += 2; len -= 2;\n\t} else if (base == 8 && len >= 1 && *s == '0') {\n\t\ts++; len--;\n\t}\n\tstart = s;\n\n\twhile (len > 0) {\n\t\tswitch (*s) {\n\t\tcase '0':\n\t\tcase '1':\n\t\tcase '2':\n\t\tcase '3':\n\t\tcase '4':\n\t\tcase '5':\n\t\tcase '6':\n\t\tcase '7':\n\t\t\tbreak;\n\t\tcase '8':\n\t\tcase '9':\n\t\t\tif (base == 8)\n\t\t\t\tgoto done;\n\t\t\tbreak;\n\t\tcase 'a':\n\t\tcase 'b':\n\t\tcase 'c':\n\t\tcase 'd':\n\t\tcase 'e':\n\t\tcase 'f':\n\t\tcase 'A':\n\t\tcase 'B':\n\t\tcase 'C':\n\t\tcase 'D':\n\t\tcase 'E':\n\t\tcase 'F':\n\t\t\tif (base == 16)\n\t\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto done;\n\t\t}\n\t\ts++; len--;\n\t}\ndone:\n\tif (s > start) {\n\t\tchar save = *s;\n\t\t*s = '\\0';\n\t\tret = mpz_set_str(zi, start, base);\n\t\t*s = save;\n\t}\n\tif (end != NULL)\n\t\t*end = s;\n\treturn ret;\n}",
      "lines": 64,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "mpg_maybe_float": {
      "start_point": [
        214,
        0
      ],
      "end_point": [
        244,
        1
      ],
      "content": "static int\nmpg_maybe_float(const char *str, int use_locale)\n{\n\tint dec_point = '.';\n\tconst char *s = str;\n\n#if defined(HAVE_LOCALE_H)\n\t/*\n\t * loc.decimal_point may not have been initialized yet,\n\t * so double check it before using it.\n\t */\n\tif (use_locale && loc.decimal_point != NULL && loc.decimal_point[0] != '\\0')\n\t\tdec_point = loc.decimal_point[0];\t/* XXX --- assumes one char */\n#endif\n\n\tif (strlen(s) >= 3\n\t\t&& (   (   (s[0] == 'i' || s[0] == 'I')\n\t\t\t&& (s[1] == 'n' || s[1] == 'N')\n\t\t\t&& (s[2] == 'f' || s[2] == 'F'))\n\t\t    || (   (s[0] == 'n' || s[0] == 'N')\n\t\t\t&& (s[1] == 'a' || s[1] == 'A')\n\t\t\t&& (s[2] == 'n' || s[2] == 'N'))))\n\t\treturn true;\n\n\tfor (; *s != '\\0'; s++) {\n\t\tif (*s == dec_point || *s == 'e' || *s == 'E')\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
      "lines": 31,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "mpg_zero": {
      "start_point": [
        249,
        0
      ],
      "end_point": [
        261,
        1
      ],
      "content": "static inline void\nmpg_zero(NODE *n)\n{\n\tif (is_mpg_float(n)) {\n\t\tmpfr_clear(n->mpg_numbr);\n\t\tn->flags &= ~MPFN;\n\t}\n\tif (! is_mpg_integer(n)) {\n\t\tmpz_init(n->mpg_i);\t/* this also sets its value to 0 */\n\t\tn->flags |= MPZN;\n\t} else\n\t\tmpz_set_si(n->mpg_i, 0);\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    },
    "force_mpnum": {
      "start_point": [
        266,
        0
      ],
      "end_point": [
        329,
        1
      ],
      "content": "static int\nforce_mpnum(NODE *n, int do_nondec, int use_locale)\n{\n\tchar *cp, *cpend, *ptr, *cp1;\n\tchar save;\n\tint tval, base = 10;\n\n\tif (n->stlen == 0) {\n\t\tmpg_zero(n);\n\t\treturn false;\n\t}\n\n\tcp = n->stptr;\n\tcpend = n->stptr + n->stlen;\n\twhile (cp < cpend && isspace((unsigned char) *cp))\n\t\tcp++;\n\tif (cp == cpend) {\t/* only spaces */\n\t\tmpg_zero(n);\n\t\treturn false;\n\t}\n\n\tsave = *cpend;\n\t*cpend = '\\0';\n\n\tif (*cp == '+' || *cp == '-')\n\t\tcp1 = cp + 1;\n\telse\n\t\tcp1 = cp;\n\n\tif (do_nondec)\n\t\tbase = get_numbase(cp1, cpend - cp1, use_locale);\n\n\tif (! mpg_maybe_float(cp1, use_locale)) {\n\t\tmpg_zero(n);\n\t\terrno = 0;\n\t\tmpg_strtoui(n->mpg_i, cp1, cpend - cp1, & ptr, base);\n\t\tif (*cp == '-')\n\t\t\tmpz_neg(n->mpg_i, n->mpg_i);\n\t\tgoto done;\n\t}\n\n\tif (is_mpg_integer(n)) {\n\t\tmpz_clear(n->mpg_i);\n\t\tn->flags &= ~MPZN;\n\t}\n\n\tif (! is_mpg_float(n)) {\n\t\tmpfr_init(n->mpg_numbr);\n\t\tn->flags |= MPFN;\n\t}\n\n\terrno = 0;\n\ttval = mpfr_strtofr(n->mpg_numbr, cp, & ptr, base, ROUND_MODE);\n\tIEEE_FMT(n->mpg_numbr, tval);\ndone:\n\t/* trailing space is OK for NUMBER */\n\twhile (ptr < cpend && isspace((unsigned char) *ptr))\n\t\tptr++;\n\t*cpend = save;\n\tif (errno == 0 && ptr == cpend)\n\t\treturn true;\n\terrno = 0;\n\treturn false;\n}",
      "lines": 64,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "mpg_force_number": {
      "start_point": [
        333,
        0
      ],
      "end_point": [
        349,
        1
      ],
      "content": "static NODE *\nmpg_force_number(NODE *n)\n{\n\tif ((n->flags & NUMCUR) != 0)\n\t\treturn n;\n\tn->flags |= NUMCUR;\n\n\tif (force_mpnum(n, (do_non_decimal_data && ! do_traditional), true)) {\n\t\tif ((n->flags & USER_INPUT) != 0) {\n\t\t\t/* leave USER_INPUT set to indicate a strnum */\n\t\t\tn->flags &= ~STRING;\n\t\t\tn->flags |= NUMBER;\n\t\t}\n\t} else\n\t\tn->flags &= ~USER_INPUT;\n\treturn n;\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "NODE",
        "*\nmpg_force_number(NODE *n)",
        "*"
      ]
    },
    "mpg_format_val": {
      "start_point": [
        353,
        0
      ],
      "end_point": [
        382,
        1
      ],
      "content": "static NODE *\nmpg_format_val(const char *format, int index, NODE *s)\n{\n\tNODE *dummy[2], *r;\n\tunsigned int oflags;\n\n\t/* create dummy node for a sole use of format_tree */\n\tdummy[1] = s;\n\toflags = s->flags;\n\n\tif (is_mpg_integer(s) || mpfr_integer_p(s->mpg_numbr)) {\n\t\t/* integral value, use %d */\n\t\tr = format_tree(\"%d\", 2, dummy, 2);\n\t\ts->stfmt = STFMT_UNUSED;\n\t} else {\n\t\tr = format_tree(format, fmt_list[index]->stlen, dummy, 2);\n\t\tassert(r != NULL);\n\t\ts->stfmt = index;\n\t}\n\ts->flags = oflags;\n\ts->stlen = r->stlen;\n\tif ((s->flags & (MALLOC|STRCUR)) == (MALLOC|STRCUR))\n\t\tefree(s->stptr);\n\ts->stptr = r->stptr;\n\ts->flags |= STRCUR;\n\ts->strndmode = MPFR_round_mode;\n\tfreenode(r);\t/* Do not unref(r)! We want to keep s->stptr == r->stpr.  */\n\tfree_wstr(s);\n\treturn s;\n}",
      "lines": 30,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "NODE",
        "*\nmpg_format_val(const char *format, int index, NODE *s)",
        "*"
      ]
    },
    "mpg_cmp": {
      "start_point": [
        386,
        0
      ],
      "end_point": [
        417,
        1
      ],
      "content": "int\nmpg_cmp(const NODE *t1, const NODE *t2)\n{\n\t/*\n\t * For the purposes of sorting, NaN is considered greater than\n\t * any other value, and all NaN values are considered equivalent and equal.\n\t */\n\n\tif (is_mpg_float(t1)) {\n\t\tif (is_mpg_float(t2)) {\n\t\t\tif (mpfr_nan_p(t1->mpg_numbr))\n\t\t\t\treturn ! mpfr_nan_p(t2->mpg_numbr);\n\t\t\tif (mpfr_nan_p(t2->mpg_numbr))\n\t\t\t\treturn -1;\n\t\t\treturn mpfr_cmp(t1->mpg_numbr, t2->mpg_numbr);\n\t\t}\n\t\tif (mpfr_nan_p(t1->mpg_numbr))\n\t\t\treturn 1;\n\t\treturn mpfr_cmp_z(t1->mpg_numbr, t2->mpg_i);\n\t} else if (is_mpg_float(t2)) {\n\t\tint ret;\n\t\tif (mpfr_nan_p(t2->mpg_numbr))\n\t\t\treturn -1;\n\t\tret = mpfr_cmp_z(t2->mpg_numbr, t1->mpg_i);\n\t\treturn ret > 0 ? -1 : (ret < 0);\n\t} else if (is_mpg_integer(t1)) {\n\t\treturn mpz_cmp(t1->mpg_i, t2->mpg_i);\n\t}\n\n\t/* t1 and t2 are AWKNUMs */\n\treturn cmp_awknums(t1, t2);\n}",
      "lines": 32,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "mpg_update_var": {
      "start_point": [
        425,
        0
      ],
      "end_point": [
        455,
        1
      ],
      "content": "NODE *\nmpg_update_var(NODE *n)\n{\n\tNODE *val = n->var_value;\n\tlong nr = 0;\n\tmpz_ptr nq = 0;\n\n\tif (n == NR_node) {\n\t\tnr = NR;\n\t\tnq = MNR;\n\t} else if (n == FNR_node) {\n\t\tnr = FNR;\n\t\tnq = MFNR;\n\t} else\n\t\tcant_happen();\n\n\tif (mpz_sgn(nq) == 0) {\n\t\t/* Efficiency hack similar to that for AWKNUM */\n\t\tif (is_mpg_float(val) || mpz_get_si(val->mpg_i) != nr) {\n\t\t\tunref(n->var_value);\n\t\t\tval = n->var_value = mpg_integer();\n\t\t\tmpz_set_si(val->mpg_i, nr);\n\t\t}\n\t} else {\n\t\tunref(n->var_value);\n\t\tval = n->var_value = mpg_integer();\n\t\tmpz_set_si(val->mpg_i, nr);\n\t\tmpz_addmul_ui(val->mpg_i, nq, LONG_MAX);\t/* val->mpg_i += nq * LONG_MAX */\n\t}\n\treturn val;\n}",
      "lines": 31,
      "depth": 12,
      "decorators": [
        "NODE",
        "*\nmpg_update_var(NODE *n)",
        "*"
      ]
    },
    "mpg_set_var": {
      "start_point": [
        459,
        0
      ],
      "end_point": [
        482,
        1
      ],
      "content": "long\nmpg_set_var(NODE *n)\n{\n\tlong nr = 0;\n\tmpz_ptr nq = 0, r;\n\tNODE *val = n->var_value;\n\n\tif (n == NR_node)\n\t\tnq = MNR;\n\telse if (n == FNR_node)\n\t\tnq = MFNR;\n\telse\n\t\tcant_happen();\n\n\tif (is_mpg_integer(val))\n\t\tr = val->mpg_i;\n\telse {\n\t\t/* convert float to integer */\n\t\tmpfr_get_z(mpzval, val->mpg_numbr, MPFR_RNDZ);\n\t\tr = mpzval;\n\t}\n\tnr = mpz_fdiv_q_ui(nq, r, LONG_MAX);\t/* nq (MNR or MFNR) is quotient */\n\treturn nr;\t/* remainder (NR or FNR) */\n}",
      "lines": 24,
      "depth": 9,
      "decorators": [
        "long",
        "long"
      ]
    },
    "set_PREC": [
      {
        "start_point": [
          486,
          0
        ],
        "end_point": [
          553,
          1
        ],
        "content": "void\nset_PREC()\n{\n\tlong prec = 0;\n\tNODE *val;\n\tstatic const struct ieee_fmt {\n\t\tconst char *name;\n\t\tmpfr_prec_t precision;\n\t\tmpfr_exp_t emax;\n\t\tmpfr_exp_t emin;\n\t} ieee_fmts[] = {\n\t\t{ \"half\",\t11,\t16,\t-23\t},\t/* binary16 */\n\t\t{ \"single\",\t24,\t128,\t-148\t},\t/* binary32 */\n\t\t{ \"double\",\t53,\t1024,\t-1073\t},\t/* binary64 */\n\t\t{ \"quad\",\t113,\t16384,\t-16493\t},\t/* binary128 */\n\t\t{ \"oct\",\t237,\t262144,\t-262377\t},\t/* binary256, not in the IEEE 754-2008 standard */\n\n\t\t/*\n \t\t * For any bitwidth = 32 * k ( k >= 4),\n \t\t * precision = 13 + bitwidth - int(4 * log2(bitwidth))\n\t\t * emax = 1 << bitwidth - precision - 1\n\t\t * emin = 4 - emax - precision\n \t\t */\n\t};\n\n\tif (! do_mpfr)\n\t\treturn;\n\n\tval = fixtype(PREC_node->var_value);\n\n\tif ((val->flags & STRING) != 0) {\n\t\tint i, j;\n\n\t\t/* emulate IEEE-754 binary format */\n\n\t\tfor (i = 0, j = sizeof(ieee_fmts)/sizeof(ieee_fmts[0]); i < j; i++) {\n\t\t\tif (strcasecmp(ieee_fmts[i].name, val->stptr) == 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (i < j) {\n\t\t\tprec = ieee_fmts[i].precision;\n\n\t\t\t/*\n\t\t\t * We *DO NOT* change the MPFR exponent range using\n\t\t\t * mpfr_set_{emin, emax} here. See format_ieee() for details.\n\t\t\t */\n\t\t\tmax_exp = ieee_fmts[i].emax;\n\t\t\tmin_exp = ieee_fmts[i].emin;\n\n\t\t\tdo_ieee_fmt = true;\n\t\t}\n\t}\n\n\tif (prec <= 0) {\n\t\tforce_number(val);\n\t\tprec = get_number_si(val);\n\t\tif (prec < MPFR_PREC_MIN || prec > MPFR_PREC_MAX) {\n\t\t\tforce_string(val);\n\t\t\twarning(_(\"PREC value `%.*s' is invalid\"), (int) val->stlen, val->stptr);\n\t\t\tprec = 0;\n\t\t} else\n\t\t\tdo_ieee_fmt = false;\n\t}\n\n\tif (prec > 0)\n\t\tmpfr_set_default_prec(default_prec = prec);\n}",
        "lines": 68,
        "depth": 14,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          1782,
          0
        ],
        "end_point": [
          1786,
          1
        ],
        "content": "void\nset_PREC()\n{\n\t/* dummy function */\n}",
        "lines": 5,
        "depth": 4,
        "decorators": [
          "void"
        ]
      }
    ],
    "get_rnd_mode": {
      "start_point": [
        558,
        0
      ],
      "end_point": [
        583,
        1
      ],
      "content": "static mpfr_rnd_t\nget_rnd_mode(const char rmode)\n{\n\tswitch (rmode) {\n\tcase 'N':\n\tcase 'n':\n\t\treturn MPFR_RNDN;\t/* round to nearest (IEEE-754 roundTiesToEven) */\n\tcase 'Z':\n\tcase 'z':\n\t\treturn MPFR_RNDZ;\t/* round toward zero (IEEE-754 roundTowardZero) */\n\tcase 'U':\n\tcase 'u':\n\t\treturn MPFR_RNDU;\t/* round toward plus infinity (IEEE-754 roundTowardPositive) */\n\tcase 'D':\n\tcase 'd':\n\t\treturn MPFR_RNDD;\t/* round toward minus infinity (IEEE-754 roundTowardNegative) */\n#if defined(MPFR_VERSION_MAJOR) && MPFR_VERSION_MAJOR > 2\n\tcase 'A':\n\tcase 'a':\n\t\treturn MPFR_RNDA;\t/* round away from zero */\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n\treturn -1;\n}",
      "lines": 26,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "mpfr_rnd_t"
      ]
    },
    "set_ROUNDMODE": [
      {
        "start_point": [
          590,
          0
        ],
        "end_point": [
          606,
          1
        ],
        "content": "void\nset_ROUNDMODE()\n{\n\tif (do_mpfr) {\n\t\tmpfr_rnd_t rndm = -1;\n\t\tNODE *n;\n\t\tn = force_string(ROUNDMODE_node->var_value);\n\t\tif (n->stlen == 1)\n\t\t\trndm = get_rnd_mode(n->stptr[0]);\n\t\tif (rndm != -1) {\n\t\t\tmpfr_set_default_rounding_mode(rndm);\n\t\t\tROUND_MODE = rndm;\n\t\t\tMPFR_round_mode = n->stptr[0];\n\t\t} else\n\t\t\twarning(_(\"RNDMODE value `%.*s' is invalid\"), (int) n->stlen, n->stptr);\n\t}\n}",
        "lines": 17,
        "depth": 12,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          1788,
          0
        ],
        "end_point": [
          1792,
          1
        ],
        "content": "void\nset_ROUNDMODE()\n{\n\t/* dummy function */\n}",
        "lines": 5,
        "depth": 4,
        "decorators": [
          "void"
        ]
      }
    ],
    "format_ieee": {
      "start_point": [
        611,
        0
      ],
      "end_point": [
        651,
        1
      ],
      "content": "int\nformat_ieee(mpfr_ptr x, int tval)\n{\n\t/*\n\t * The MPFR doc says that it's our responsibility to make sure all numbers\n\t * including those previously created are in range after we've changed the\n\t * exponent range. Most MPFR operations and functions require\n\t * the input arguments to have exponents within the current exponent range.\n\t * Any argument outside the range results in a MPFR assertion failure\n\t * like this:\n\t *\n\t *   $ gawk -M 'BEGIN { x=1.0e-10000; print x+0; PREC=\"double\"; print x+0}'\n\t *   1e-10000\n\t *   init2.c:52: MPFR assertion failed ....\n\t *\n\t * A \"naive\" approach would be to keep track of the ternary state and\n\t * the rounding mode for each number, and make sure it is in the current\n\t * exponent range (using mpfr_check_range) before using it in an\n\t * operation or function. Instead, we adopt the following strategy.\n\t *\n\t * When gawk starts, the exponent range is the MPFR default\n\t * [MPFR_EMIN_DEFAULT, MPFR_EMAX_DEFAULT]. Any number that gawk\n\t * creates must have exponent in this range (excluding infinities, NaNs and zeros).\n\t * Each MPFR operation or function is performed with this default exponent\n\t * range.\n\t *\n\t * When emulating IEEE-754 format, the exponents are *temporarily* changed,\n\t * mpfr_check_range is called to make sure the number is in the new range,\n\t * and mpfr_subnormalize is used to round following the rules of subnormal\n\t * arithmetic. The exponent range is then *restored* to the original value\n\t * [MPFR_EMIN_DEFAULT, MPFR_EMAX_DEFAULT].\n\t */\n\n\t(void) mpfr_set_emin(min_exp);\n\t(void) mpfr_set_emax(max_exp);\n\ttval = mpfr_check_range(x, tval, ROUND_MODE);\n\ttval = mpfr_subnormalize(x, tval, ROUND_MODE);\n\t(void) mpfr_set_emin(MPFR_EMIN_DEFAULT);\n\t(void) mpfr_set_emax(MPFR_EMAX_DEFAULT);\n\treturn tval;\n}",
      "lines": 41,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "do_mpfr_atan2": {
      "start_point": [
        656,
        0
      ],
      "end_point": [
        685,
        1
      ],
      "content": "NODE *\ndo_mpfr_atan2(int nargs)\n{\n\tNODE *t1, *t2, *res;\n\tmpfr_ptr p1, p2;\n\tint tval;\n\n\tt2 = POP_SCALAR();\n\tt1 = POP_SCALAR();\n\n\tif (do_lint) {\n\t\tif ((fixtype(t1)->flags & NUMBER) == 0)\n\t\t\tlintwarn(_(\"atan2: received non-numeric first argument\"));\n\t\tif ((fixtype(t2)->flags & NUMBER) == 0)\n\t\t\tlintwarn(_(\"atan2: received non-numeric second argument\"));\n\t}\n\tforce_number(t1);\n\tforce_number(t2);\n\n\tp1 = MP_FLOAT(t1);\n\tp2 = MP_FLOAT(t2);\n\tres = mpg_float();\n\t/* See MPFR documentation for handling of special values like +inf as an argument */\n\ttval = mpfr_atan2(res->mpg_numbr, p1, p2, ROUND_MODE);\n\tIEEE_FMT(res->mpg_numbr, tval);\n\n\tDEREF(t1);\n\tDEREF(t2);\n\treturn res;\n}",
      "lines": 30,
      "depth": 13,
      "decorators": [
        "NODE",
        "*\ndo_mpfr_atan2(int nargs)",
        "*"
      ]
    },
    "do_mpfr_func": {
      "start_point": [
        689,
        0
      ],
      "end_point": [
        712,
        1
      ],
      "content": "static inline NODE *\ndo_mpfr_func(const char *name,\n\t\tint (*mpfr_func)(),\t/* putting argument types just gets the compiler confused */\n\t\tint nargs)\n{\n\tNODE *t1, *res;\n\tmpfr_ptr p1;\n\tint tval;\n\tmpfr_prec_t argprec;\n\n\tt1 = POP_SCALAR();\n\tif (do_lint && (fixtype(t1)->flags & NUMBER) == 0)\n\t\tlintwarn(_(\"%s: received non-numeric argument\"), name);\n\n\tforce_number(t1);\n\tp1 = MP_FLOAT(t1);\n\tres = mpg_float();\n\tif ((argprec = mpfr_get_prec(p1)) > default_prec)\n\t\tmpfr_set_prec(res->mpg_numbr, argprec);\t/* needed at least for sqrt() */\n\ttval = mpfr_func(res->mpg_numbr, p1, ROUND_MODE);\n\tIEEE_FMT(res->mpg_numbr, tval);\n\tDEREF(t1);\n\treturn res;\n}",
      "lines": 24,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "NODE",
        "*\ndo_mpfr_func(const char *name,\n\t\tint (*mpfr_func)(),\t/* putting argument types just gets the compiler confused */\n\t\tint nargs)",
        "*"
      ]
    },
    "do_mpfr_sin": {
      "start_point": [
        721,
        0
      ],
      "end_point": [
        725,
        1
      ],
      "content": "NODE *\ndo_mpfr_sin(int nargs)\n{\n\tSPEC_MATH(sin);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "NODE",
        "*\ndo_mpfr_sin(int nargs)",
        "*"
      ]
    },
    "do_mpfr_cos": {
      "start_point": [
        729,
        0
      ],
      "end_point": [
        733,
        1
      ],
      "content": "NODE *\ndo_mpfr_cos(int nargs)\n{\n\tSPEC_MATH(cos);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "NODE",
        "*\ndo_mpfr_cos(int nargs)",
        "*"
      ]
    },
    "do_mpfr_exp": {
      "start_point": [
        737,
        0
      ],
      "end_point": [
        741,
        1
      ],
      "content": "NODE *\ndo_mpfr_exp(int nargs)\n{\n\tSPEC_MATH(exp);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "NODE",
        "*\ndo_mpfr_exp(int nargs)",
        "*"
      ]
    },
    "do_mpfr_log": {
      "start_point": [
        745,
        0
      ],
      "end_point": [
        749,
        1
      ],
      "content": "NODE *\ndo_mpfr_log(int nargs)\n{\n\tSPEC_MATH(log);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "NODE",
        "*\ndo_mpfr_log(int nargs)",
        "*"
      ]
    },
    "do_mpfr_sqrt": {
      "start_point": [
        753,
        0
      ],
      "end_point": [
        757,
        1
      ],
      "content": "NODE *\ndo_mpfr_sqrt(int nargs)\n{\n\tSPEC_MATH(sqrt);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "NODE",
        "*\ndo_mpfr_sqrt(int nargs)",
        "*"
      ]
    },
    "do_mpfr_int": {
      "start_point": [
        761,
        0
      ],
      "end_point": [
        786,
        1
      ],
      "content": "NODE *\ndo_mpfr_int(int nargs)\n{\n\tNODE *tmp, *r;\n\n\ttmp = POP_SCALAR();\n\tif (do_lint && (fixtype(tmp)->flags & NUMBER) == 0)\n\t\tlintwarn(_(\"int: received non-numeric argument\"));\n\tforce_number(tmp);\n\n\tif (is_mpg_integer(tmp)) {\n\t\tr = mpg_integer();\n\t\tmpz_set(r->mpg_i, tmp->mpg_i);\n\t} else {\n\t\tif (! mpfr_number_p(tmp->mpg_numbr)) {\n\t\t\t/* [+-]inf or NaN */\n\t\t\treturn tmp;\n\t\t}\n\n\t\tr = mpg_integer();\n\t\tmpfr_get_z(r->mpg_i, tmp->mpg_numbr, MPFR_RNDZ);\n\t}\n\n\tDEREF(tmp);\n\treturn r;\n}",
      "lines": 26,
      "depth": 12,
      "decorators": [
        "NODE",
        "*\ndo_mpfr_int(int nargs)",
        "*"
      ]
    },
    "do_mpfr_compl": {
      "start_point": [
        790,
        0
      ],
      "end_point": [
        834,
        1
      ],
      "content": "NODE *\ndo_mpfr_compl(int nargs)\n{\n\tNODE *tmp, *r;\n\tmpz_ptr zptr;\n\n\ttmp = POP_SCALAR();\n\tif (do_lint && (fixtype(tmp)->flags & NUMBER) == 0)\n\t\tlintwarn(_(\"compl: received non-numeric argument\"));\n\n\tforce_number(tmp);\n\tif (is_mpg_float(tmp)) {\n\t\tmpfr_ptr p = tmp->mpg_numbr;\n\n\t\tif (! mpfr_number_p(p)) {\n\t\t\t/* [+-]inf or NaN */\n\t\t\treturn tmp;\n\t\t}\n\t\tif (mpfr_sgn(p) < 0)\n\t\t\tfatal(\"%s\",\n\t\t\tmpg_fmt(_(\"compl(%Rg): negative value is not allowed\"), p)\n\t\t\t\t\t);\n\t\tif (do_lint) {\n\t\t\tif (! mpfr_integer_p(p))\n\t\t\t\tlintwarn(\"%s\",\n\t\t\tmpg_fmt(_(\"comp(%Rg): fractional value will be truncated\"), p)\n\t\t\t\t\t);\n\t\t}\n\n\t\tmpfr_get_z(mpzval, p, MPFR_RNDZ);\t/* float to integer conversion */\n\t\tzptr = mpzval;\n\t} else {\n\t\t/* (tmp->flags & MPZN) != 0 */\n\t\tzptr = tmp->mpg_i;\n\t\tif (mpz_sgn(zptr) < 0)\n\t\t\t\tfatal(\"%s\",\n\t\t\tmpg_fmt(_(\"compl(%Zd): negative values are not allowed\"), zptr)\n\t\t\t\t\t);\n\t}\n\n\tr = mpg_integer();\n\tmpz_com(r->mpg_i, zptr);\n\tDEREF(tmp);\n\treturn r;\n}",
      "lines": 45,
      "depth": 16,
      "decorators": [
        "NODE",
        "*\ndo_mpfr_compl(int nargs)",
        "*"
      ]
    },
    "get_intval": {
      "start_point": [
        838,
        0
      ],
      "end_point": [
        891,
        1
      ],
      "content": "static mpz_ptr\nget_intval(NODE *t1, int argnum, const char *op)\n{\n\tmpz_ptr pz;\n\n\tif (do_lint && (fixtype(t1)->flags & NUMBER) == 0)\n\t\tlintwarn(_(\"%s: received non-numeric argument #%d\"), op, argnum);\n\n\t(void) force_number(t1);\n\n\tif (is_mpg_float(t1)) {\n\t\tmpfr_ptr left = t1->mpg_numbr;\n\t\tif (! mpfr_number_p(left)) {\n\t\t\t/* inf or NaN */\n\t\t\tif (do_lint)\n                       \t\tlintwarn(\"%s\",\n\t\tmpg_fmt(_(\"%s: argument #%d has invalid value %Rg, using 0\"),\n                                \top, argnum, left)\n\t\t\t\t);\n\n\t\t\temalloc(pz, mpz_ptr, sizeof (mpz_t), \"get_intval\");\n\t\t\tmpz_init(pz);\n\t\t\treturn pz;\t/* should be freed */\n\t\t}\n\n\t\tif (mpfr_sgn(left) < 0)\n\t\t\tfatal(\"%s\",\n\t\tmpg_fmt(_(\"%s: argument #%d negative value %Rg is not allowed\"),\n\t\t\t\t\top, argnum, left)\n\t\t\t\t);\n\n\t\tif (do_lint) {\n\t\t\tif (! mpfr_integer_p(left))\n\t\t\t\tlintwarn(\"%s\",\n\t\tmpg_fmt(_(\"%s: argument #%d fractional value %Rg will be truncated\"),\n\t\t\t\t\top, argnum, left)\n\t\t\t\t);\n\t\t}\n\n\t\temalloc(pz, mpz_ptr, sizeof (mpz_t), \"get_intval\");\n\t\tmpz_init(pz);\n\t\tmpfr_get_z(pz, left, MPFR_RNDZ);\t/* float to integer conversion */\n\t\treturn pz;\t/* should be freed */\n\t}\n\t/* (t1->flags & MPZN) != 0 */\n\tpz = t1->mpg_i;\n\tif (mpz_sgn(pz) < 0)\n\t\tfatal(\"%s\",\n\tmpg_fmt(_(\"%s: argument #%d negative value %Zd is not allowed\"),\n\t\t\t\t\top, argnum, pz)\n\t\t\t\t);\n\n\treturn pz;\t/* must not be freed */\n}",
      "lines": 54,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "mpz_ptr"
      ]
    },
    "free_intval": {
      "start_point": [
        896,
        0
      ],
      "end_point": [
        903,
        1
      ],
      "content": "static inline void\nfree_intval(NODE *t, mpz_ptr pz)\n{\n\tif ((t->flags & MPZN) == 0) {\n\t\tmpz_clear(pz);\n\t\tefree(pz);\n\t}\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    },
    "do_mpfr_lshift": {
      "start_point": [
        908,
        0
      ],
      "end_point": [
        936,
        1
      ],
      "content": "NODE *\ndo_mpfr_lshift(int nargs)\n{\n\tNODE *t1, *t2, *res;\n\tunsigned long shift;\n\tmpz_ptr pz1, pz2;\n\n\tt2 = POP_SCALAR();\n\tt1 = POP_SCALAR();\n\n\tpz1 = get_intval(t1, 1, \"lshift\");\n\tpz2 = get_intval(t2, 2, \"lshift\");\n\n\t/*\n\t * mpz_get_ui: If op is too big to fit an unsigned long then just\n\t * the least significant bits that do fit are returned.\n\t * The sign of op is ignored, only the absolute value is used.\n\t */\n\n\tshift = mpz_get_ui(pz2);\t/* GMP integer => unsigned long conversion */\n\tres = mpg_integer();\n\tmpz_mul_2exp(res->mpg_i, pz1, shift);\t\t/* res = pz1 * 2^shift */\n\n\tfree_intval(t1, pz1);\n\tfree_intval(t2, pz2);\n\tDEREF(t2);\n\tDEREF(t1);\n\treturn res;\n}",
      "lines": 29,
      "depth": 8,
      "decorators": [
        "NODE",
        "*\ndo_mpfr_lshift(int nargs)",
        "*"
      ]
    },
    "do_mpfr_rshift": {
      "start_point": [
        940,
        0
      ],
      "end_point": [
        963,
        1
      ],
      "content": "NODE *\ndo_mpfr_rshift(int nargs)\n{\n\tNODE *t1, *t2, *res;\n\tunsigned long shift;\n\tmpz_ptr pz1, pz2;\n\n\tt2 = POP_SCALAR();\n\tt1 = POP_SCALAR();\n\n\tpz1 = get_intval(t1, 1, \"rshift\");\n\tpz2 = get_intval(t2, 2, \"rshift\");\n\n\t/* N.B: See do_mpfp_lshift. */\n\tshift = mpz_get_ui(pz2);\t/* GMP integer => unsigned long conversion */\n\tres = mpg_integer();\n\tmpz_fdiv_q_2exp(res->mpg_i, pz1, shift);\t/* res = pz1 / 2^shift, round towards -inf */\n\n\tfree_intval(t1, pz1);\n\tfree_intval(t2, pz2);\n\tDEREF(t2);\n\tDEREF(t1);\n\treturn res;\n}",
      "lines": 24,
      "depth": 8,
      "decorators": [
        "NODE",
        "*\ndo_mpfr_rshift(int nargs)",
        "*"
      ]
    },
    "do_mpfr_and": {
      "start_point": [
        968,
        0
      ],
      "end_point": [
        995,
        1
      ],
      "content": "NODE *\ndo_mpfr_and(int nargs)\n{\n\tNODE *t1, *t2, *res;\n\tmpz_ptr pz1, pz2;\n\tint i;\n\n\tif (nargs < 2)\n\t\tfatal(_(\"and: called with less than two arguments\"));\n\n\tt2 = POP_SCALAR();\n\tpz2 = get_intval(t2, nargs, \"and\");\n\n\tres = mpg_integer();\n\tfor (i = 1; i < nargs; i++) {\n\t\tt1 = POP_SCALAR();\n\t\tpz1 = get_intval(t1, nargs - i, \"and\");\n\t\tmpz_and(res->mpg_i, pz1, pz2);\n\t\tfree_intval(t1, pz1);\n\t\tDEREF(t1);\n\t\tif (i == 1) {\n\t\t\tfree_intval(t2, pz2);\n\t\t\tDEREF(t2);\n\t\t}\n\t\tpz2 = res->mpg_i;\n\t}\n\treturn res;\n}",
      "lines": 28,
      "depth": 10,
      "decorators": [
        "NODE",
        "*\ndo_mpfr_and(int nargs)",
        "*"
      ]
    },
    "do_mpfr_or": {
      "start_point": [
        1000,
        0
      ],
      "end_point": [
        1027,
        1
      ],
      "content": "NODE *\ndo_mpfr_or(int nargs)\n{\n\tNODE *t1, *t2, *res;\n\tmpz_ptr pz1, pz2;\n\tint i;\n\n\tif (nargs < 2)\n\t\tfatal(_(\"or: called with less than two arguments\"));\n\n\tt2 = POP_SCALAR();\n\tpz2 = get_intval(t2, nargs, \"or\");\n\n\tres = mpg_integer();\n\tfor (i = 1; i < nargs; i++) {\n\t\tt1 = POP_SCALAR();\n\t\tpz1 = get_intval(t1, nargs - i, \"or\");\n\t\tmpz_ior(res->mpg_i, pz1, pz2);\n\t\tfree_intval(t1, pz1);\n\t\tDEREF(t1);\n\t\tif (i == 1) {\n\t\t\tfree_intval(t2, pz2);\n\t\t\tDEREF(t2);\n\t\t}\n\t\tpz2 = res->mpg_i;\n\t}\n\treturn res;\n}",
      "lines": 28,
      "depth": 10,
      "decorators": [
        "NODE",
        "*\ndo_mpfr_or(int nargs)",
        "*"
      ]
    },
    "do_mpfr_xor": {
      "start_point": [
        1031,
        0
      ],
      "end_point": [
        1058,
        1
      ],
      "content": "NODE *\ndo_mpfr_xor(int nargs)\n{\n\tNODE *t1, *t2, *res;\n\tmpz_ptr pz1, pz2;\n\tint i;\n\n\tif (nargs < 2)\n\t\tfatal(_(\"xor: called with less than two arguments\"));\n\n\tt2 = POP_SCALAR();\n\tpz2 = get_intval(t2, nargs, \"xor\");\n\n\tres = mpg_integer();\n\tfor (i = 1; i < nargs; i++) {\n\t\tt1 = POP_SCALAR();\n\t\tpz1 = get_intval(t1, nargs - i, \"xor\");\n\t\tmpz_xor(res->mpg_i, pz1, pz2);\n\t\tfree_intval(t1, pz1);\n\t\tDEREF(t1);\n\t\tif (i == 1) {\n\t\t\tfree_intval(t2, pz2);\n\t\t\tDEREF(t2);\n\t\t}\n\t\tpz2 = res->mpg_i;\n\t}\n\treturn res;\n}",
      "lines": 28,
      "depth": 10,
      "decorators": [
        "NODE",
        "*\ndo_mpfr_xor(int nargs)",
        "*"
      ]
    },
    "do_mpfr_strtonum": {
      "start_point": [
        1062,
        0
      ],
      "end_point": [
        1089,
        1
      ],
      "content": "NODE *\ndo_mpfr_strtonum(int nargs)\n{\n\tNODE *tmp, *r;\n\n\ttmp = fixtype(POP_SCALAR());\n\tif ((tmp->flags & NUMBER) == 0) {\n\t\tr = mpg_integer();\t/* will be changed to MPFR float if necessary in force_mpnum() */\n\t\tr->stptr = tmp->stptr;\n\t\tr->stlen = tmp->stlen;\n\t\tforce_mpnum(r, true, use_lc_numeric);\n\t\tr->stptr = NULL;\n\t\tr->stlen = 0;\n\t\tr->wstptr = NULL;\n\t\tr->wstlen = 0;\n\t} else if (is_mpg_float(tmp)) {\n\t\tint tval;\n\t\tr = mpg_float();\n\t\ttval = mpfr_set(r->mpg_numbr, tmp->mpg_numbr, ROUND_MODE);\n\t\tIEEE_FMT(r->mpg_numbr, tval);\n\t} else {\n\t\tr = mpg_integer();\n\t\tmpz_set(r->mpg_i, tmp->mpg_i);\n\t}\n\n\tDEREF(tmp);\n\treturn r;\n}",
      "lines": 28,
      "depth": 11,
      "decorators": [
        "NODE",
        "*\ndo_mpfr_strtonum(int nargs)",
        "*"
      ]
    },
    "do_mpfr_rand": {
      "start_point": [
        1098,
        0
      ],
      "end_point": [
        1126,
        1
      ],
      "content": "NODE *\ndo_mpfr_rand(int nargs ATTRIBUTE_UNUSED)\n{\n\tNODE *res;\n\tint tval;\n\n\tif (firstrand) {\n#if 0\n\t\t/* Choose the default algorithm */\n\t\tgmp_randinit_default(state);\n#endif\n\t\t/*\n\t\t * Choose a specific (Mersenne Twister) algorithm in case the default\n\t\t * changes in the future.\n\t\t */\n\n\t\tgmp_randinit_mt(state);\n\n\t\tmpz_init(seed);\n\t\tmpz_set_ui(seed, 1);\n\t\t/* seed state */\n\t\tgmp_randseed(state, seed);\n\t\tfirstrand = false;\n\t}\n\tres = mpg_float();\n\ttval = mpfr_urandomb(res->mpg_numbr, state);\n\tIEEE_FMT(res->mpg_numbr, tval);\n\treturn res;\n}",
      "lines": 29,
      "depth": 9,
      "decorators": [
        "NODE",
        "*\ndo_mpfr_rand(int nargs ATTRIBUTE_UNUSED)",
        "*"
      ]
    },
    "do_mpfr_srand": {
      "start_point": [
        1131,
        0
      ],
      "end_point": [
        1174,
        1
      ],
      "content": "NODE *\ndo_mpfr_srand(int nargs)\n{\n\tNODE *res;\n\n\tif (firstrand) {\n#if 0\n\t\t/* Choose the default algorithm */\n\t\tgmp_randinit_default(state);\n#endif\n\t\t/*\n\t\t * Choose a specific algorithm (Mersenne Twister) in case default\n\t\t * changes in the future.\n\t\t */\n\n\t\tgmp_randinit_mt(state);\n\n\t\tmpz_init(seed);\n\t\tmpz_set_ui(seed, 1);\n\t\t/* No need to seed state, will change it below */\n\t\tfirstrand = false;\n\t}\n\n\tres = mpg_integer();\n\tmpz_set(res->mpg_i, seed);\t/* previous seed */\n\n\tif (nargs == 0)\n\t\tmpz_set_ui(seed, (unsigned long) time((time_t *) 0));\n\telse {\n\t\tNODE *tmp;\n\t\ttmp = POP_SCALAR();\n\t\tif (do_lint && (fixtype(tmp)->flags & NUMBER) == 0)\n\t\t\tlintwarn(_(\"srand: received non-numeric argument\"));\n\t\tforce_number(tmp);\n\t\tif (is_mpg_float(tmp))\n\t\t\tmpfr_get_z(seed, tmp->mpg_numbr, MPFR_RNDZ);\n\t\telse /* MP integer */\n\t\t\tmpz_set(seed, tmp->mpg_i);\n\t\tDEREF(tmp);\n\t}\n\n\tgmp_randseed(state, seed);\n\treturn res;\n}",
      "lines": 44,
      "depth": 14,
      "decorators": [
        "NODE",
        "*\ndo_mpfr_srand(int nargs)",
        "*"
      ]
    },
    "do_mpfr_intdiv": {
      "start_point": [
        1187,
        0
      ],
      "end_point": [
        1269,
        1
      ],
      "content": "NODE *\ndo_mpfr_intdiv(int nargs)\n{\n\tNODE *numerator, *denominator, *result;\n\tNODE *num, *denom;\n\tNODE *quotient, *remainder;\n\tNODE *sub, **lhs;\n\n\tresult = POP_PARAM();\n\tif (result->type != Node_var_array)\n\t\tfatal(_(\"intdiv: third argument is not an array\"));\n\tassoc_clear(result);\n\n\tdenominator = POP_SCALAR();\n\tnumerator = POP_SCALAR();\n\n\tif (do_lint) {\n\t\tif ((fixtype(numerator)->flags & NUMBER) == 0)\n\t\t\tlintwarn(_(\"intdiv: received non-numeric first argument\"));\n\t\tif ((fixtype(denominator)->flags & NUMBER) == 0)\n\t\t\tlintwarn(_(\"intdiv: received non-numeric second argument\"));\n\t}\n\n\t(void) force_number(numerator);\n\t(void) force_number(denominator);\n\n\t/* convert numerator and denominator to integer */\n\tif (is_mpg_integer(numerator)) {\n\t\tnum = mpg_integer();\n\t\tmpz_set(num->mpg_i, numerator->mpg_i);\n\t} else {\n\t\tif (! mpfr_number_p(numerator->mpg_numbr)) {\n\t\t\t/* [+-]inf or NaN */\n\t\t\tunref(numerator);\n\t\t\tunref(denominator);\n\t\t\treturn make_number((AWKNUM) -1);\n\t\t}\n\n\t\tnum = mpg_integer();\n\t\tmpfr_get_z(num->mpg_i, numerator->mpg_numbr, MPFR_RNDZ);\n\t}\n\n\tif (is_mpg_integer(denominator)) {\n\t\tdenom = mpg_integer();\n\t\tmpz_set(denom->mpg_i, denominator->mpg_i);\n\t} else {\n\t\tif (! mpfr_number_p(denominator->mpg_numbr)) {\n\t\t\t/* [+-]inf or NaN */\n\t\t\tunref(numerator);\n\t\t\tunref(denominator);\n\t\t\tunref(num);\n\t\t\treturn make_number((AWKNUM) -1);\n\t\t}\n\n\t\tdenom = mpg_integer();\n\t\tmpfr_get_z(denom->mpg_i, denominator->mpg_numbr, MPFR_RNDZ);\n\t}\n\n\tif (mpz_sgn(denom->mpg_i) == 0)\n\t\tfatal(_(\"intdiv: division by zero attempted\"));\n\n\tquotient = mpg_integer();\n\tremainder = mpg_integer();\n\n\t/* do the division */\n\tmpz_tdiv_qr(quotient->mpg_i, remainder->mpg_i, num->mpg_i, denom->mpg_i);\n\tunref(num);\n\tunref(denom);\n\tunref(numerator);\n\tunref(denominator);\n\n\tsub = make_string(\"quotient\", 8);\n\tlhs = assoc_lookup(result, sub);\n\tunref(*lhs);\n\t*lhs = quotient;\n\n\tsub = make_string(\"remainder\", 9);\n\tlhs = assoc_lookup(result, sub);\n\tunref(*lhs);\n\t*lhs = remainder;\n\n\treturn make_number((AWKNUM) 0.0);\n}",
      "lines": 83,
      "depth": 13,
      "decorators": [
        "NODE",
        "*\ndo_mpfr_intdiv(int nargs)",
        "*"
      ]
    },
    "mpg_tofloat": {
      "start_point": [
        1278,
        0
      ],
      "end_point": [
        1314,
        1
      ],
      "content": "static inline mpfr_ptr\nmpg_tofloat(mpfr_ptr mf, mpz_ptr mz)\n{\n\tsize_t prec;\n\n\t/*\n\t * When implicitely converting a GMP integer operand to a MPFR float, use\n\t * a precision sufficiently large to hold the converted value exactly.\n\t *\n \t *\t$ ./gawk -M 'BEGIN { print 13 % 2 }'\n \t *\t1\n \t * If the user-specified precision is used to convert the integer 13 to a\n\t * float, one will get:\n \t *\t$ ./gawk -M 'BEGIN { PREC=2; print 13 % 2.0 }'\n \t *\t0\n \t */\n\n\tprec = mpz_sizeinbase(mz, 2);\t/* most significant 1 bit position starting at 1 */\n\tif (prec > PRECISION_MIN) {\n\t\tprec -= (size_t) mpz_scan1(mz, 0);\t/* least significant 1 bit index starting at 0 */\n\t\tif (prec > MPFR_PREC_MAX)\n\t\t\tprec = MPFR_PREC_MAX;\n\t\telse if (prec < PRECISION_MIN)\n\t\t\tprec = PRECISION_MIN;\n\t}\n\telse\n\t\tprec = PRECISION_MIN;\n\t/*\n\t * Always set the precision to avoid hysteresis, since do_mpfr_func\n\t * may copy our precision.\n\t */\n\tif (prec != mpfr_get_prec(mf))\n\t\tmpfr_set_prec(mf, prec);\n\n\tmpfr_set_z(mf, mz, ROUND_MODE);\n\treturn mf;\n}",
      "lines": 37,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "mpfr_ptr"
      ]
    },
    "mpg_add": {
      "start_point": [
        1319,
        0
      ],
      "end_point": [
        1339,
        1
      ],
      "content": "static NODE *\nmpg_add(NODE *t1, NODE *t2)\n{\n\tNODE *r;\n\tint tval;\n\n\tif (is_mpg_integer(t1) && is_mpg_integer(t2)) {\n\t\tr = mpg_integer();\n\t\tmpz_add(r->mpg_i, t1->mpg_i, t2->mpg_i);\n\t} else {\n\t\tr = mpg_float();\n\t\tif (is_mpg_integer(t2))\n\t\t\ttval = mpfr_add_z(r->mpg_numbr, t1->mpg_numbr, t2->mpg_i, ROUND_MODE);\n\t\telse if (is_mpg_integer(t1))\n\t\t\ttval = mpfr_add_z(r->mpg_numbr, t2->mpg_numbr, t1->mpg_i, ROUND_MODE);\n\t\telse\n\t\t\ttval = mpfr_add(r->mpg_numbr, t1->mpg_numbr, t2->mpg_numbr, ROUND_MODE);\n\t\tIEEE_FMT(r->mpg_numbr, tval);\n\t}\n\treturn r;\n}",
      "lines": 21,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "NODE",
        "*\nmpg_add(NODE *t1, NODE *t2)",
        "*"
      ]
    },
    "mpg_sub": {
      "start_point": [
        1343,
        0
      ],
      "end_point": [
        1373,
        1
      ],
      "content": "static NODE *\nmpg_sub(NODE *t1, NODE *t2)\n{\n\tNODE *r;\n\tint tval;\n\n\tif (is_mpg_integer(t1) && is_mpg_integer(t2)) {\n\t\tr = mpg_integer();\n\t\tmpz_sub(r->mpg_i, t1->mpg_i, t2->mpg_i);\n\t} else {\n\t\tr = mpg_float();\n\t\tif (is_mpg_integer(t2))\n\t\t\ttval = mpfr_sub_z(r->mpg_numbr, t1->mpg_numbr, t2->mpg_i, ROUND_MODE);\n\t\telse if (is_mpg_integer(t1)) {\n#if (!defined(MPFR_VERSION) || (MPFR_VERSION < MPFR_VERSION_NUM(3,1,0)))\n\t\t\tNODE *tmp = t1;\n\t\t\tt1 = t2;\n\t\t\tt2 = tmp;\n\t\t\ttval = mpfr_sub_z(r->mpg_numbr, t1->mpg_numbr, t2->mpg_i, ROUND_MODE);\n\t\t\ttval = mpfr_neg(r->mpg_numbr, r->mpg_numbr, ROUND_MODE);\n\t\t\tt2 = t1;\n\t\t\tt1 = tmp;\n#else\n\t\t\ttval = mpfr_z_sub(r->mpg_numbr, t1->mpg_i, t2->mpg_numbr, ROUND_MODE);\n#endif\n\t\t} else\n\t\t\ttval = mpfr_sub(r->mpg_numbr, t1->mpg_numbr, t2->mpg_numbr, ROUND_MODE);\n\t\tIEEE_FMT(r->mpg_numbr, tval);\n\t}\n\treturn r;\n}",
      "lines": 31,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "NODE",
        "*\nmpg_sub(NODE *t1, NODE *t2)",
        "*"
      ]
    },
    "mpg_mul": {
      "start_point": [
        1377,
        0
      ],
      "end_point": [
        1397,
        1
      ],
      "content": "static NODE *\nmpg_mul(NODE *t1, NODE *t2)\n{\n\tNODE *r;\n\tint tval;\n\n\tif (is_mpg_integer(t1) && is_mpg_integer(t2)) {\n\t\tr = mpg_integer();\n\t\tmpz_mul(r->mpg_i, t1->mpg_i, t2->mpg_i);\n\t} else {\n\t\tr = mpg_float();\n\t\tif (is_mpg_integer(t2))\n\t\t\ttval = mpfr_mul_z(r->mpg_numbr, t1->mpg_numbr, t2->mpg_i, ROUND_MODE);\n\t\telse if (is_mpg_integer(t1))\n\t\t\ttval = mpfr_mul_z(r->mpg_numbr, t2->mpg_numbr, t1->mpg_i, ROUND_MODE);\n\t\telse\n\t\t\ttval = mpfr_mul(r->mpg_numbr, t1->mpg_numbr, t2->mpg_numbr, ROUND_MODE);\n\t\tIEEE_FMT(r->mpg_numbr, tval);\n\t}\n\treturn r;\n}",
      "lines": 21,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "NODE",
        "*\nmpg_mul(NODE *t1, NODE *t2)",
        "*"
      ]
    },
    "mpg_pow": {
      "start_point": [
        1402,
        0
      ],
      "end_point": [
        1432,
        1
      ],
      "content": "static NODE *\nmpg_pow(NODE *t1, NODE *t2)\n{\n\tNODE *r;\n\tint tval;\n\n\tif (is_mpg_integer(t1) && is_mpg_integer(t2)) {\n\t\tif (mpz_sgn(t2->mpg_i) >= 0 && mpz_fits_ulong_p(t2->mpg_i)) {\n\t\t\tr = mpg_integer();\n\t\t\tmpz_pow_ui(r->mpg_i, t1->mpg_i, mpz_get_ui(t2->mpg_i));\n\t\t} else {\n\t\t\tmpfr_ptr p1, p2;\n\t\t\tp1 = MP_FLOAT(t1);\n\t\t\tp2 = MP_FLOAT(t2);\n\t\t\tr = mpg_float();\n\t\t\ttval = mpfr_pow(r->mpg_numbr, p1, p2, ROUND_MODE);\n\t\t\tIEEE_FMT(r->mpg_numbr, tval);\n\t\t}\n\t} else {\n\t\tr = mpg_float();\n\t\tif (is_mpg_integer(t2))\n\t\t\ttval = mpfr_pow_z(r->mpg_numbr, t1->mpg_numbr, t2->mpg_i, ROUND_MODE);\n\t\telse {\n\t\t\tmpfr_ptr p1;\n\t\t\tp1 = MP_FLOAT(t1);\n\t\t\ttval = mpfr_pow(r->mpg_numbr, p1, t2->mpg_numbr, ROUND_MODE);\n\t\t}\n\t\tIEEE_FMT(r->mpg_numbr, tval);\n\t}\n\treturn r;\n}",
      "lines": 31,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "NODE",
        "*\nmpg_pow(NODE *t1, NODE *t2)",
        "*"
      ]
    },
    "mpg_div": {
      "start_point": [
        1436,
        0
      ],
      "end_point": [
        1457,
        1
      ],
      "content": "static NODE *\nmpg_div(NODE *t1, NODE *t2)\n{\n\tNODE *r;\n\tint tval;\n\n\tif (is_mpg_integer(t1) && is_mpg_integer(t2)\n\t\t\t&& (mpz_sgn(t2->mpg_i) != 0)\t/* not dividing by 0 */\n\t\t\t&& mpz_divisible_p(t1->mpg_i, t2->mpg_i)\n\t) {\n\t\tr = mpg_integer();\n\t\tmpz_divexact(r->mpg_i, t1->mpg_i, t2->mpg_i);\n\t} else {\n\t\tmpfr_ptr p1, p2;\n\t\tp1 = MP_FLOAT(t1);\n\t\tp2 = MP_FLOAT(t2);\n\t\tr = mpg_float();\n\t\ttval = mpfr_div(r->mpg_numbr, p1, p2, ROUND_MODE);\n\t\tIEEE_FMT(r->mpg_numbr, tval);\n\t}\n\treturn r;\n}",
      "lines": 22,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "NODE",
        "*\nmpg_div(NODE *t1, NODE *t2)",
        "*"
      ]
    },
    "mpg_mod": {
      "start_point": [
        1461,
        0
      ],
      "end_point": [
        1498,
        1
      ],
      "content": "static NODE *\nmpg_mod(NODE *t1, NODE *t2)\n{\n\tNODE *r;\n\tint tval;\n\n\tif (is_mpg_integer(t1) && is_mpg_integer(t2)) {\n\t\t/*\n\t\t * 8/2014: Originally, this was just\n\t\t *\n\t\t * r = mpg_integer();\n\t\t * mpz_mod(r->mpg_i, t1->mpg_i, t2->mpg_i);\n\t\t *\n\t\t * But that gave very strange results with negative numerator:\n\t\t *\n\t\t *\t$ ./gawk -M 'BEGIN { print -15 % 7 }'\n\t\t *\t6\n\t\t *\n\t\t * So instead we use mpz_tdiv_qr() to get the correct result\n\t\t * and just throw away the quotient. We could not find any\n\t\t * reason why mpz_mod() wasn't working correctly.\n\t\t */\n\t\tNODE *dummy_quotient;\n\n\t\tr = mpg_integer();\n\t\tdummy_quotient = mpg_integer();\n\t\tmpz_tdiv_qr(dummy_quotient->mpg_i, r->mpg_i, t1->mpg_i, t2->mpg_i);\n\t\tunref(dummy_quotient);\n\t} else {\n\t\tmpfr_ptr p1, p2;\n\t\tp1 = MP_FLOAT(t1);\n\t\tp2 = MP_FLOAT(t2);\n\t\tr = mpg_float();\n\t\ttval = mpfr_fmod(r->mpg_numbr, p1, p2, ROUND_MODE);\n\t\tIEEE_FMT(r->mpg_numbr, tval);\n\t}\n\treturn r;\n}",
      "lines": 38,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "NODE",
        "*\nmpg_mod(NODE *t1, NODE *t2)",
        "*"
      ]
    },
    "mpg_interpret": {
      "start_point": [
        1505,
        0
      ],
      "end_point": [
        1745,
        1
      ],
      "content": "static int\nmpg_interpret(INSTRUCTION **cp)\n{\n\tINSTRUCTION *pc = *cp;\t/* current instruction */\n\tOPCODE op;\t/* current opcode */\n\tNODE *r = NULL;\n\tNODE *t1, *t2;\n\tNODE **lhs;\n\tint tval;\t/* the ternary value returned by a MPFR function */\n\n\tswitch ((op = pc->opcode)) {\n\tcase Op_plus_i:\n\t\tt2 = force_number(pc->memory);\n\t\tgoto plus;\n\tcase Op_plus:\n\t\tt2 = POP_NUMBER();\nplus:\n\t\tt1 = TOP_NUMBER();\n\t\tr = mpg_add(t1, t2);\n\t\tDEREF(t1);\n\t\tif (op == Op_plus)\n\t\t\tDEREF(t2);\n\t\tREPLACE(r);\n\t\tbreak;\n\n\tcase Op_minus_i:\n\t\tt2 = force_number(pc->memory);\n\t\tgoto minus;\n\tcase Op_minus:\n\t\tt2 = POP_NUMBER();\nminus:\n\t\tt1 = TOP_NUMBER();\n\t\tr = mpg_sub(t1, t2);\n\t\tDEREF(t1);\n\t\tif (op == Op_minus)\n\t\t\tDEREF(t2);\n\t\tREPLACE(r);\n\t\tbreak;\n\n\tcase Op_times_i:\n\t\tt2 = force_number(pc->memory);\n\t\tgoto times;\n\tcase Op_times:\n\t\tt2 = POP_NUMBER();\ntimes:\n\t\tt1 = TOP_NUMBER();\n\t\tr = mpg_mul(t1, t2);\n\t\tDEREF(t1);\n\t\tif (op == Op_times)\n\t\t\tDEREF(t2);\n\t\tREPLACE(r);\n\t\tbreak;\n\n\tcase Op_exp_i:\n\t\tt2 = force_number(pc->memory);\n\t\tgoto exp;\n\tcase Op_exp:\n\t\tt2 = POP_NUMBER();\nexp:\n\t\tt1 = TOP_NUMBER();\n\t\tr = mpg_pow(t1, t2);\n\t\tDEREF(t1);\n\t\tif (op == Op_exp)\n\t\t\tDEREF(t2);\n\t\tREPLACE(r);\n\t\tbreak;\n\n\tcase Op_quotient_i:\n\t\tt2 = force_number(pc->memory);\n\t\tgoto quotient;\n\tcase Op_quotient:\n\t\tt2 = POP_NUMBER();\nquotient:\n\t\tt1 = TOP_NUMBER();\n\t\tr = mpg_div(t1, t2);\n\t\tDEREF(t1);\n\t\tif (op == Op_quotient)\n\t\t\tDEREF(t2);\n\t\tREPLACE(r);\n\t\tbreak;\n\n\tcase Op_mod_i:\n\t\tt2 = force_number(pc->memory);\n\t\tgoto mod;\n\tcase Op_mod:\n\t\tt2 = POP_NUMBER();\nmod:\n\t\tt1 = TOP_NUMBER();\n\t\tr = mpg_mod(t1, t2);\n\t\tDEREF(t1);\n\t\tif (op == Op_mod)\n\t\t\tDEREF(t2);\n\t\tREPLACE(r);\n\t\tbreak;\n\n\tcase Op_preincrement:\n\tcase Op_predecrement:\n\t\tlhs = TOP_ADDRESS();\n\t\tt1 = *lhs;\n\t\tforce_number(t1);\n\n\t\tif (is_mpg_integer(t1)) {\n\t\t\tif (t1->valref == 1 && t1->flags == (MALLOC|MPZN|NUMCUR|NUMBER))\n\t\t\t/* Efficiency hack. Big speed-up (> 30%) in a tight loop */\n\t\t\t\tr = t1;\n\t\t\telse\n\t\t\t\tr = *lhs = mpg_integer();\n\t\t\tif (op == Op_preincrement)\n\t\t\t\tmpz_add_ui(r->mpg_i, t1->mpg_i, 1);\n\t\t\telse\n\t\t\t\tmpz_sub_ui(r->mpg_i, t1->mpg_i, 1);\n\t\t} else {\n\n\t\t\t/*\n\t\t\t * An optimization like the one above is not going to work\n\t\t\t * for a floating-point number. With it,\n\t\t\t *   gawk -M 'BEGIN { PREC=53; i=2^53+0.0; PREC=113; ++i; print i}'\n\t\t \t * will output 2^53 instead of 2^53+1.\n\t\t \t */\n\n\t\t\tr = *lhs = mpg_float();\n\t\t\ttval = mpfr_add_si(r->mpg_numbr, t1->mpg_numbr,\n\t\t\t\t\top == Op_preincrement ? 1 : -1,\n\t\t\t\t\tROUND_MODE);\n\t\t\tIEEE_FMT(r->mpg_numbr, tval);\n\t\t}\n\t\tif (r != t1)\n\t\t\tunref(t1);\n\t\tUPREF(r);\n\t\tREPLACE(r);\n\t\tbreak;\n\n\tcase Op_postincrement:\n\tcase Op_postdecrement:\n\t\tlhs = TOP_ADDRESS();\n\t\tt1 = *lhs;\n\t\tforce_number(t1);\n\n\t\tif (is_mpg_integer(t1)) {\n\t\t\tr = mpg_integer();\n\t\t\tmpz_set(r->mpg_i, t1->mpg_i);\n\t\t\tif (t1->valref == 1 && t1->flags == (MALLOC|MPZN|NUMCUR|NUMBER))\n\t\t\t/* Efficiency hack. Big speed-up (> 30%) in a tight loop */\n\t\t\t\tt2 = t1;\n\t\t\telse\n\t\t\t\tt2 = *lhs = mpg_integer();\n\t\t\tif (op == Op_postincrement)\n\t\t\t\tmpz_add_ui(t2->mpg_i, t1->mpg_i, 1);\n\t\t\telse\n\t\t\t\tmpz_sub_ui(t2->mpg_i, t1->mpg_i, 1);\n\t\t} else {\n\t\t\tr = mpg_float();\n\t\t\ttval = mpfr_set(r->mpg_numbr, t1->mpg_numbr, ROUND_MODE);\n\t\t\tIEEE_FMT(r->mpg_numbr, tval);\n\t\t\tt2 = *lhs = mpg_float();\n\t\t\ttval = mpfr_add_si(t2->mpg_numbr, t1->mpg_numbr,\n\t\t\t\t\top == Op_postincrement ? 1 : -1,\n\t\t\t\t\tROUND_MODE);\n\t\t\tIEEE_FMT(t2->mpg_numbr, tval);\n\t\t}\n\t\tif (t2 != t1)\n\t\t\tunref(t1);\n\t\tREPLACE(r);\n\t\tbreak;\n\n\tcase Op_unary_minus:\n\t\tt1 = TOP_NUMBER();\n\t\tif (is_mpg_float(t1)) {\n\t\t\tr = mpg_float();\n\t\t\ttval = mpfr_neg(r->mpg_numbr, t1->mpg_numbr, ROUND_MODE);\n\t\t\tIEEE_FMT(r->mpg_numbr, tval);\n\t\t} else {\n\t\t\tr = mpg_integer();\n\t\t\tmpz_neg(r->mpg_i, t1->mpg_i);\n\t\t}\n\t\tDEREF(t1);\n\t\tREPLACE(r);\n\t\tbreak;\n\n\tcase Op_unary_plus:\n\t\tt1 = TOP_NUMBER();\n\t\tif (is_mpg_float(t1)) {\n\t\t\tr = mpg_float();\n\t\t\ttval = mpfr_set(r->mpg_numbr, t1->mpg_numbr, ROUND_MODE);\n\t\t\tIEEE_FMT(r->mpg_numbr, tval);\n\t\t} else {\n\t\t\tr = mpg_integer();\n\t\t\tmpz_set(r->mpg_i, t1->mpg_i);\n\t\t}\n\t\tDEREF(t1);\n\t\tREPLACE(r);\n\t\tbreak;\n\n\tcase Op_assign_plus:\n\tcase Op_assign_minus:\n\tcase Op_assign_times:\n\tcase Op_assign_quotient:\n\tcase Op_assign_mod:\n\tcase Op_assign_exp:\n\t\tlhs = POP_ADDRESS();\n\t\tt1 = *lhs;\n\t\tforce_number(t1);\n\t\tt2 = TOP_NUMBER();\n\n\t\tswitch (op) {\n\t\tcase Op_assign_plus:\n\t\t\tr = mpg_add(t1, t2);\n\t\t\tbreak;\n\t\tcase Op_assign_minus:\n\t\t\tr = mpg_sub(t1, t2);\n\t\t\tbreak;\n\t\tcase Op_assign_times:\n\t\t\tr = mpg_mul(t1, t2);\n\t\t\tbreak;\n\t\tcase Op_assign_quotient:\n\t\t\tr = mpg_div(t1, t2);\n\t\t\tbreak;\n\t\tcase Op_assign_mod:\n\t\t\tr = mpg_mod(t1, t2);\n\t\t\tbreak;\n\t\tcase Op_assign_exp:\n\t\t\tr = mpg_pow(t1, t2);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcant_happen();\n\t\t}\n\n\t\tDEREF(t2);\n\t\tunref(*lhs);\n\t\t*lhs = r;\n\t\tUPREF(r);\n\t\tREPLACE(r);\n\t\tbreak;\n\n\tdefault:\n\t\treturn true;\t/* unhandled */\n\t}\n\n\t*cp = pc->nexti;\t/* next instruction to execute */\n\treturn false;\n}",
      "lines": 241,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "mpg_fmt": {
      "start_point": [
        1750,
        0
      ],
      "end_point": [
        1767,
        1
      ],
      "content": "const char *\nmpg_fmt(const char *mesg, ...)\n{\n\tstatic char *tmp = NULL;\n\tint ret;\n\tva_list args;\n\n\tif (tmp != NULL) {\n\t\tmpfr_free_str(tmp);\n\t\ttmp = NULL;\n\t}\n\tva_start(args, mesg);\n\tret = mpfr_vasprintf(& tmp, mesg, args);\n\tva_end(args);\n\tif (ret >= 0 && tmp != NULL)\n\t\treturn tmp;\n\treturn mesg;\n}",
      "lines": 18,
      "depth": 8,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nmpg_fmt(const char *mesg, ...)",
        "*"
      ]
    },
    "mpfr_unset": [
      {
        "start_point": [
          1771,
          0
        ],
        "end_point": [
          1778,
          1
        ],
        "content": "void\nmpfr_unset(NODE *n)\n{\n\tif (is_mpg_float(n))\n\t\tmpfr_clear(n->mpg_numbr);\n\telse if (is_mpg_integer(n))\n\t\tmpz_clear(n->mpg_i);\n}",
        "lines": 8,
        "depth": 9,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          1794,
          0
        ],
        "end_point": [
          1798,
          1
        ],
        "content": "void\nmpfr_unset(NODE *n)\n{\n\t/* dummy function */\n}",
        "lines": 5,
        "depth": 6,
        "decorators": [
          "void"
        ]
      }
    ]
  },
  "gawk/gawk-4.2.1/msg.c": {
    "err": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        109,
        1
      ],
      "content": "void\nerr(bool isfatal, const char *s, const char *emsg, va_list argp)\n{\n\tchar *file;\n\tconst char *me;\n\n\tstatic bool first = true;\n\tstatic bool add_src_info = false;\n\n\tif (first) {\n\t\tfirst = false;\n\t\tadd_src_info = (getenv(\"GAWK_MSG_SRC\") != NULL);\n\t}\n\n\t(void) fflush(output_fp);\n\tme = myname;\n\t(void) fprintf(stderr, \"%s: \", me);\n\n\tif (srcfile != NULL && add_src_info) {\n\t\tfprintf(stderr, \"%s:%d:\", srcfile, srcline);\n\t\tsrcfile = NULL;\n\t}\n\n\tif (sourceline > 0) {\n\t\tif (source != NULL)\n\t\t\t(void) fprintf(stderr, \"%s:\", source);\n\t\telse\n\t\t\t(void) fprintf(stderr, _(\"cmd. line:\"));\n\n\t\t(void) fprintf(stderr, \"%d: \", sourceline);\n\t}\n\n#ifdef HAVE_MPFR\n\tif (FNR_node && is_mpg_number(FNR_node->var_value)) {\n\t\tNODE *val;\n\t\tval = mpg_update_var(FNR_node);\n\t\tassert((val->flags & MPZN) != 0);\n\t\tif (mpz_sgn(val->mpg_i) > 0) {\n\t\t\tint len = FILENAME_node->var_value->stlen;\n\t\t\tfile = FILENAME_node->var_value->stptr;\n\t\t\t(void) putc('(', stderr);\n\t\t\tif (file)\n\t\t\t\t(void) fprintf(stderr, \"FILENAME=%.*s \", len, file);\n\t\t\t(void) mpfr_fprintf(stderr, \"FNR=%Zd) \", val->mpg_i);\n\t\t}\n\t} else\n#endif\n\tif (FNR > 0) {\n\t\tint len = FILENAME_node->var_value->stlen;\n\t\tfile = FILENAME_node->var_value->stptr;\n\t\t(void) putc('(', stderr);\n\t\tif (file)\n\t\t\t(void) fprintf(stderr, \"FILENAME=%.*s \", len, file);\n\t\t(void) fprintf(stderr, \"FNR=%ld) \", FNR);\n\t}\n\n\t(void) fprintf(stderr, \"%s\", s);\n\tvfprintf(stderr, emsg, argp);\n\t(void) fprintf(stderr, \"\\n\");\n\t(void) fflush(stderr);\n\n\tif (isfatal) {\n#ifdef GAWKDEBUG\n\t\t// GLIBC 2.27 doesn't necessarily flush on abort. Sigh.\n\t\tfflush(NULL);\n\t\tabort();\n#endif\n\t\tgawk_exit(EXIT_FATAL);\n\t}\n}",
      "lines": 70,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "msg": {
      "start_point": [
        113,
        0
      ],
      "end_point": [
        120,
        1
      ],
      "content": "void\nmsg(const char *mesg, ...)\n{\n\tva_list args;\n\tva_start(args, mesg);\n\terr(false, \"\", mesg, args);\n\tva_end(args);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "r_warning": {
      "start_point": [
        124,
        0
      ],
      "end_point": [
        131,
        1
      ],
      "content": "void\nr_warning(const char *mesg, ...)\n{\n\tva_list args;\n\tva_start(args, mesg);\n\terr(false, _(\"warning: \"), mesg, args);\n\tva_end(args);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "error": {
      "start_point": [
        133,
        0
      ],
      "end_point": [
        140,
        1
      ],
      "content": "void\nerror(const char *mesg, ...)\n{\n\tva_list args;\n\tva_start(args, mesg);\n\terr(false, _(\"error: \"), mesg, args);\n\tva_end(args);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "set_loc": {
      "start_point": [
        144,
        0
      ],
      "end_point": [
        152,
        1
      ],
      "content": "void\nset_loc(const char *file, int line)\n{\n\tsrcfile = file;\n\tsrcline = line;\n\n\t/* This stupid line keeps some compilers happy: */\n\tfile = srcfile; line = srcline;\n}",
      "lines": 9,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "r_fatal": {
      "start_point": [
        156,
        0
      ],
      "end_point": [
        163,
        1
      ],
      "content": "void\nr_fatal(const char *mesg, ...)\n{\n\tva_list args;\n\tva_start(args, mesg);\n\terr(true, _(\"fatal: \"), mesg, args);\n\tva_end(args);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "gawk_exit": {
      "start_point": [
        167,
        0
      ],
      "end_point": [
        176,
        1
      ],
      "content": "void\ngawk_exit(int status)\n{\n\tif (fatal_tag_valid) {\n\t\texit_val = status;\n\t\tlongjmp(fatal_tag, 1);\n\t}\n\n\tfinal_exit(status);\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "final_exit": {
      "start_point": [
        180,
        0
      ],
      "end_point": [
        190,
        1
      ],
      "content": "void\nfinal_exit(int status)\n{\n\t/* run any extension exit handlers */\n\trun_ext_exit_handlers(status);\n\n\t/* we could close_io() here */\n\tclose_extensions();\n\n\texit(status);\n}",
      "lines": 11,
      "depth": 6,
      "decorators": [
        "void"
      ]
    }
  },
  "gawk/gawk-4.2.1/node.c": {
    "is_hex": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "static bool\nis_hex(const char *str, const char *cpend)\n{\n\t/* on entry, we know the string length is >= 1 */\n\tif (*str == '-' || *str == '+')\n\t\tstr++;\n\n\tif (str + 1 < cpend && str[0] == '0' && (str[1] == 'x' || str[1] == 'X'))\n\t\treturn true;\n\n\treturn false;\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "r_force_number": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        172,
        1
      ],
      "content": "NODE *\nr_force_number(NODE *n)\n{\n\tchar *cp;\n\tchar *cpend;\n\tchar save;\n\tchar *ptr;\n\textern double strtod();\n\n\tif ((n->flags & NUMCUR) != 0)\n\t\treturn n;\n\n\t/*\n\t * We should always set NUMCUR. If USER_INPUT is set and it's a\n\t * numeric string, we clear STRING and enable NUMBER, but if it's not\n\t * numeric, we disable USER_INPUT.\n\t */\n\n\t/* All the conditionals are an attempt to avoid the expensive strtod */\n\n\tn->flags |= NUMCUR;\n\tn->numbr = 0.0;\n\n\t/* Trim leading white space, bailing out if there's nothing else */\n\tfor (cp = n->stptr, cpend = cp + n->stlen;\n\t     cp < cpend && isspace((unsigned char) *cp); cp++)\n\t\tcontinue;\n\n\tif (cp == cpend)\n\t\tgoto badnum;\n\n\t/* At this point, we know the string is not entirely white space */\n\t/* Trim trailing white space */\n\twhile (isspace((unsigned char) cpend[-1]))\n\t\tcpend--;\n\n\t/*\n\t * 2/2007:\n\t * POSIX, by way of severe language lawyering, seems to\n\t * allow things like \"inf\" and \"nan\" to mean something.\n\t * So if do_posix, the user gets what he deserves.\n\t * This also allows hexadecimal floating point. Ugh.\n\t */\n\tif (! do_posix) {\n\t\tif (is_alpha((unsigned char) *cp))\n\t\t\tgoto badnum;\n\t\telse if (cpend == cp+4 && is_ieee_magic_val(cp)) {\n\t\t\tn->numbr = get_ieee_magic_val(cp);\n\t\t\tgoto goodnum;\n\t\t}\n\t\t/* else\n\t\t\tfall through */\n\t}\n\t/* else POSIX, so\n\t\tfall through */\n\n\tif (   (! do_posix\t\t/* not POSIXLY paranoid and */\n\t        && (is_alpha((unsigned char) *cp)\t/* letter, or */\n\t\t\t\t\t/* CANNOT do non-decimal and saw 0x */\n\t\t    || (! do_non_decimal_data && is_hex(cp, cpend))))) {\n\t\tgoto badnum;\n\t}\n\n\tif (cpend - cp == 1) {\t\t/* only one character */\n\t\tif (isdigit((unsigned char) *cp)) {\t/* it's a digit! */\n\t\t\tn->numbr = (AWKNUM)(*cp - '0');\n\t\t\tif (n->stlen == 1)\t\t/* no white space */\n\t\t\t\tn->flags |= NUMINT;\n\t\t\tgoto goodnum;\n\t\t}\n\t\tgoto badnum;\n\t}\n\n\terrno = 0;\n\tif (do_non_decimal_data\t\t/* main.c assures false if do_posix */\n\t\t&& ! do_traditional && get_numbase(cp, cpend - cp, true) != 10) {\n\t\t/* nondec2awknum() saves and restores the byte after the string itself */\n\t\tn->numbr = nondec2awknum(cp, cpend - cp, &ptr);\n\t} else {\n\t\tsave = *cpend;\n\t\t*cpend = '\\0';\n\t\tn->numbr = (AWKNUM) strtod((const char *) cp, &ptr);\n\t\t*cpend = save;\n\t}\n\n\tif (errno == 0) {\n\t\tif (ptr == cpend)\n\t\t\tgoto goodnum;\n\t\t/* else keep the leading numeric value without updating flags */\n\t\t/* fall through to badnum */\n\t} else {\n\t\terrno = 0;\n\t\t/*\n\t\t * N.B. For subnormal values, strtod may return the\n\t\t * floating-point representation while setting errno to ERANGE.\n\t\t * We force the numeric value to 0 in such cases.\n\t\t */\n\t\tn->numbr = 0;\n\t\t/*\n\t\t * Or should we accept it as a NUMBER even though strtod\n\t\t * threw an error?\n\t\t */\n\t\t/* fall through to badnum */\n\t}\nbadnum:\n\tn->flags &= ~USER_INPUT;\n\treturn n;\n\ngoodnum:\n\tif ((n->flags & USER_INPUT) != 0) {\n\t\t/* leave USER_INPUT enabled to indicate that this is a strnum */\n\t\tn->flags &= ~STRING;\n\t\tn->flags |= NUMBER;\n\t}\n\treturn n;\n}",
      "lines": 116,
      "depth": 14,
      "decorators": [
        "NODE",
        "*\nr_force_number(NODE *n)",
        "*"
      ]
    },
    "r_format_val": {
      "start_point": [
        196,
        0
      ],
      "end_point": [
        290,
        1
      ],
      "content": "NODE *\nr_format_val(const char *format, int index, NODE *s)\n{\n\tchar buf[BUFSIZ];\n\tchar *sp = buf;\n\tdouble val;\n\n\t/*\n\t * 2/2007: Simplify our lives here. Instead of worrying about\n\t * whether or not the value will fit into a long just so we\n\t * can use sprintf(\"%ld\", val) on it, always format it ourselves.\n\t * The only thing to worry about is that integral values always\n\t * format as integers. %.0f does that very well.\n\t *\n\t * 6/2008: Would that things were so simple. Always using %.0f\n\t * imposes a notable performance penalty for applications that\n\t * do a lot of conversion of integers to strings. So, we reinstate\n\t * the old code, but use %.0f for integral values that are outside\n\t * the range of a long.  This seems a reasonable compromise.\n\t *\n\t * 12/2009: Use <= and >= in the comparisons with LONG_xxx instead of\n\t * < and > so that things work correctly on systems with 64 bit integers.\n\t */\n\n\t/* not an integral value, or out of range */\n\tif ((val = double_to_int(s->numbr)) != s->numbr\n\t\t\t|| val <= LONG_MIN || val >= LONG_MAX\n\t) {\n\t\t/*\n\t\t * Once upon a time, we just blindly did this:\n\t\t *\tsprintf(sp, format, s->numbr);\n\t\t *\ts->stlen = strlen(sp);\n\t\t *\ts->stfmt = index;\n\t\t * but that's no good if, e.g., OFMT is %s. So we punt,\n\t\t * and just always format the value ourselves.\n\t\t */\n\n\t\tNODE *dummy[2], *r;\n\t\tunsigned int oflags;\n\n\t\t/* create dummy node for a sole use of format_tree */\n\t\tdummy[1] = s;\n\t\toflags = s->flags;\n\n\t\tif (val == s->numbr) {\n\t\t\t/* integral value, but outside range of %ld, use %.0f */\n\t\t\tr = format_tree(\"%.0f\", 4, dummy, 2);\n\t\t\ts->stfmt = STFMT_UNUSED;\n\t\t} else {\n\t\t\tr = format_tree(format, fmt_list[index]->stlen, dummy, 2);\n\t\t\tassert(r != NULL);\n\t\t\ts->stfmt = index;\n\t\t}\n\t\ts->flags = oflags;\n\t\ts->stlen = r->stlen;\n\t\tif ((s->flags & (MALLOC|STRCUR)) == (MALLOC|STRCUR))\n\t\t\tefree(s->stptr);\n\t\ts->stptr = r->stptr;\n#ifdef HAVE_MPFR\n\t\ts->strndmode = MPFR_round_mode;\n#endif\n\t\tfreenode(r);\t/* Do not unref(r)! We want to keep s->stptr == r->stpr.  */\n\n\t\tgoto no_malloc;\n\t} else {\n\t\t/*\n\t\t * integral value; force conversion to long only once.\n\t\t */\n\t\tlong num = (long) val;\n\n\t\tif (num < NVAL && num >= 0) {\n\t\t\tsp = (char *) values[num];\n\t\t\ts->stlen = 1;\n\t\t} else {\n\t\t\t(void) sprintf(sp, \"%ld\", num);\n\t\t\ts->stlen = strlen(sp);\n\t\t}\n\t\ts->stfmt = STFMT_UNUSED;\n\t\tif ((s->flags & INTIND) != 0) {\n\t\t\ts->flags &= ~(INTIND|NUMBER);\n\t\t\ts->flags |= STRING;\n\t\t}\n#ifdef HAVE_MPFR\n\t\ts->strndmode = MPFR_round_mode;\n#endif\n\t}\n\tif ((s->flags & (MALLOC|STRCUR)) == (MALLOC|STRCUR))\n\t\tefree(s->stptr);\n\temalloc(s->stptr, char *, s->stlen + 1, \"format_val\");\n\tmemcpy(s->stptr, sp, s->stlen + 1);\nno_malloc:\n\ts->flags |= STRCUR;\n\tfree_wstr(s);\n\treturn s;\n}",
      "lines": 95,
      "depth": 13,
      "decorators": [
        "NODE",
        "*\nr_format_val(const char *format, int index, NODE *s)",
        "*"
      ]
    },
    "r_dupnode": {
      "start_point": [
        294,
        0
      ],
      "end_point": [
        334,
        1
      ],
      "content": "NODE *\nr_dupnode(NODE *n)\n{\n\tNODE *r;\n\n\tassert(n->type == Node_val);\n\n#ifdef GAWKDEBUG\n\tif ((n->flags & MALLOC) != 0) {\n\t\tn->valref++;\n\t\treturn n;\n\t}\n#endif\n\n\tgetnode(r);\n\t*r = *n;\n\tr->flags |= MALLOC;\n\tr->valref = 1;\n\t/*\n\t * DON'T call free_wstr(r) here!\n\t * r->wstptr still points at n->wstptr's value, and we\n\t * don't want to free it!\n\t */\n\tr->wstptr = NULL;\n\tr->wstlen = 0;\n\n\tif ((n->flags & STRCUR) != 0) {\n\t\temalloc(r->stptr, char *, n->stlen + 1, \"r_dupnode\");\n\t\tmemcpy(r->stptr, n->stptr, n->stlen);\n\t\tr->stptr[n->stlen] = '\\0';\n\t\tif ((n->flags & WSTRCUR) != 0) {\n\t\t\tr->wstlen = n->wstlen;\n\t\t\temalloc(r->wstptr, wchar_t *, sizeof(wchar_t) * (n->wstlen + 1), \"r_dupnode\");\n\t\t\tmemcpy(r->wstptr, n->wstptr, n->wstlen * sizeof(wchar_t));\n\t\t\tr->wstptr[n->wstlen] = L'\\0';\n\t\t\tr->flags |= WSTRCUR;\n\t\t}\n\t}\n\n\treturn r;\n}",
      "lines": 41,
      "depth": 15,
      "decorators": [
        "NODE",
        "*\nr_dupnode(NODE *n)",
        "*"
      ]
    },
    "r_make_number": {
      "start_point": [
        338,
        0
      ],
      "end_point": [
        344,
        1
      ],
      "content": "static NODE *\nr_make_number(double x)\n{\n\tNODE *r = make_number_node(0);\n\tr->numbr = x;\n\treturn r;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "NODE",
        "*\nr_make_number(double x)",
        "*"
      ]
    },
    "cmp_awknums": {
      "start_point": [
        348,
        0
      ],
      "end_point": [
        370,
        1
      ],
      "content": "int\ncmp_awknums(const NODE *t1, const NODE *t2)\n{\n\t/*\n\t * This routine is also used to sort numeric array indices or values.\n\t * For the purposes of sorting, NaN is considered greater than\n\t * any other value, and all NaN values are considered equivalent and equal.\n\t * This isn't in compliance with IEEE standard, but compliance w.r.t. NaN\n\t * comparison at the awk level is a different issue, and needs to be dealt\n\t * with in the interpreter for each opcode seperately.\n\t */\n\n\tif (isnan(t1->numbr))\n\t\treturn ! isnan(t2->numbr);\n\tif (isnan(t2->numbr))\n\t\treturn -1;\n\t/* don't subtract, in case one or both are infinite */\n\tif (t1->numbr == t2->numbr)\n\t\treturn 0;\n\tif (t1->numbr < t2->numbr)\n\t\treturn -1;\n\treturn 1;\n}",
      "lines": 23,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "make_str_node": {
      "start_point": [
        375,
        0
      ],
      "end_point": [
        446,
        1
      ],
      "content": "NODE *\nmake_str_node(const char *s, size_t len, int flags)\n{\n\tNODE *r;\n\tgetnode(r);\n\tr->type = Node_val;\n\tr->numbr = 0;\n\tr->flags = (MALLOC|STRING|STRCUR);\n\tr->valref = 1;\n\tr->stfmt = STFMT_UNUSED;\n#ifdef HAVE_MPFR\n\tr->strndmode = MPFR_round_mode;\n#endif\n\tr->wstptr = NULL;\n\tr->wstlen = 0;\n\n\tif ((flags & ALREADY_MALLOCED) != 0)\n\t\tr->stptr = (char *) s;\n\telse {\n\t\temalloc(r->stptr, char *, len + 1, \"make_str_node\");\n\t\tmemcpy(r->stptr, s, len);\n\t}\n\tr->stptr[len] = '\\0';\n\n\tif ((flags & SCAN) != 0) {\t/* scan for escape sequences */\n\t\tconst char *pf;\n\t\tchar *ptm;\n\t\tint c;\n\t\tconst char *end;\n\t\tmbstate_t cur_state;\n\n\t\tmemset(& cur_state, 0, sizeof(cur_state));\n\n\t\tend = &(r->stptr[len]);\n\t\tfor (pf = ptm = r->stptr; pf < end;) {\n\t\t\t/*\n\t\t\t * Keep multibyte characters together. This avoids\n\t\t\t * problems if a subsequent byte of a multibyte\n\t\t\t * character happens to be a backslash.\n\t\t\t */\n\t\t\tif (gawk_mb_cur_max > 1) {\n\t\t\t\tint mblen = mbrlen(pf, end-pf, &cur_state);\n\n\t\t\t\tif (mblen > 1) {\n\t\t\t\t\tint i;\n\n\t\t\t\t\tfor (i = 0; i < mblen; i++)\n\t\t\t\t\t\t*ptm++ = *pf++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tc = *pf++;\n\t\t\tif (c == '\\\\') {\n\t\t\t\tc = parse_escape(&pf);\n\t\t\t\tif (c < 0) {\n\t\t\t\t\tif (do_lint)\n\t\t\t\t\t\tlintwarn(_(\"backslash at end of string\"));\n\t\t\t\t\tc = '\\\\';\n\t\t\t\t}\n\t\t\t\t*ptm++ = c;\n\t\t\t} else\n\t\t\t\t*ptm++ = c;\n\t\t}\n\t\tlen = ptm - r->stptr;\n\t\terealloc(r->stptr, char *, len + 1, \"make_str_node\");\n\t\tr->stptr[len] = '\\0';\n\t}\n\tr->stlen = len;\n\n\treturn r;\n}",
      "lines": 72,
      "depth": 18,
      "decorators": [
        "NODE",
        "*\nmake_str_node(const char *s, size_t len, int flags)",
        "*"
      ]
    },
    "make_typed_regex": {
      "start_point": [
        450,
        0
      ],
      "end_point": [
        467,
        1
      ],
      "content": "NODE *\nmake_typed_regex(const char *re, size_t len)\n{\n\tNODE *n, *exp, *n2;\n\n\texp = make_str_node(re, len, ALREADY_MALLOCED);\n\tn = make_regnode(Node_regex, exp);\n\tif (n == NULL)\n\t\tfatal(_(\"could not make typed regex\"));\n\n\tn2 = make_string(re, len);\n\tn2->typed_re = n;\n\tn2->numbr = 0;\n\tn2->flags |= NUMCUR|STRCUR|REGEX; \n\tn2->flags &= ~(STRING|NUMBER);\n\n\treturn n2;\n}",
      "lines": 18,
      "depth": 10,
      "decorators": [
        "NODE",
        "*\nmake_typed_regex(const char *re, size_t len)",
        "*"
      ]
    },
    "r_unref": {
      "start_point": [
        472,
        0
      ],
      "end_point": [
        495,
        1
      ],
      "content": "void\nr_unref(NODE *tmp)\n{\n#ifdef GAWKDEBUG\n\tif (tmp == NULL)\n\t\treturn;\n\tif ((tmp->flags & MALLOC) != 0) {\n\t\tif (tmp->valref > 1) {\n\t\t\ttmp->valref--;\n\t\t\treturn;\n\t\t}\n\t\tif ((tmp->flags & STRCUR) != 0)\n\t\t\tefree(tmp->stptr);\n\t}\n#else\n\tif ((tmp->flags & (MALLOC|STRCUR)) == (MALLOC|STRCUR))\n\t\tefree(tmp->stptr);\n#endif\n\n\tmpfr_unset(tmp);\n\n\tfree_wstr(tmp);\n\tfreenode(tmp);\n}",
      "lines": 24,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "parse_escape": {
      "start_point": [
        517,
        0
      ],
      "end_point": [
        630,
        1
      ],
      "content": "int\nparse_escape(const char **string_ptr)\n{\n\tint c = *(*string_ptr)++;\n\tint i;\n\tint count;\n\tint j;\n\tconst char *start;\n\n\tif (do_lint_old) {\n\t\tswitch (c) {\n\t\tcase 'a':\n\t\tcase 'b':\n\t\tcase 'f':\n\t\tcase 'r':\n\t\t\twarning(_(\"old awk does not support the `\\\\%c' escape sequence\"), c);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (c) {\n\tcase 'a':\n\t\treturn '\\a';\n\tcase 'b':\n\t\treturn '\\b';\n\tcase 'f':\n\t\treturn '\\f';\n\tcase 'n':\n\t\treturn '\\n';\n\tcase 'r':\n\t\treturn '\\r';\n\tcase 't':\n\t\treturn '\\t';\n\tcase 'v':\n\t\treturn '\\v';\n\tcase '\\n':\n\t\treturn -2;\n\tcase 0:\n\t\t(*string_ptr)--;\n\t\treturn -1;\n\tcase '0':\n\tcase '1':\n\tcase '2':\n\tcase '3':\n\tcase '4':\n\tcase '5':\n\tcase '6':\n\tcase '7':\n\t\ti = c - '0';\n\t\tcount = 0;\n\t\twhile (++count < 3) {\n\t\t\tif ((c = *(*string_ptr)++) >= '0' && c <= '7') {\n\t\t\t\ti *= 8;\n\t\t\t\ti += c - '0';\n\t\t\t} else {\n\t\t\t\t(*string_ptr)--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn i;\n\tcase 'x':\n\t\tif (do_lint) {\n\t\t\tstatic bool warned = false;\n\n\t\t\tif (! warned) {\n\t\t\t\twarned = true;\n\t\t\t\tlintwarn(_(\"POSIX does not allow `\\\\x' escapes\"));\n\t\t\t}\n\t\t}\n\t\tif (do_posix)\n\t\t\treturn ('x');\n\t\tif (! isxdigit((unsigned char) (*string_ptr)[0])) {\n\t\t\twarning(_(\"no hex digits in `\\\\x' escape sequence\"));\n\t\t\treturn ('x');\n\t\t}\n\t\tstart = *string_ptr;\n\t\tfor (i = j = 0; j < 2; j++) {\n\t\t\t/* do outside test to avoid multiple side effects */\n\t\t\tc = *(*string_ptr)++;\n\t\t\tif (isxdigit(c)) {\n\t\t\t\ti *= 16;\n\t\t\t\tif (isdigit(c))\n\t\t\t\t\ti += c - '0';\n\t\t\t\telse if (isupper(c))\n\t\t\t\t\ti += c - 'A' + 10;\n\t\t\t\telse\n\t\t\t\t\ti += c - 'a' + 10;\n\t\t\t} else {\n\t\t\t\t(*string_ptr)--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (do_lint && j > 2)\n\t\t\tlintwarn(_(\"hex escape \\\\x%.*s of %d characters probably not interpreted the way you expect\"), j, start, j);\n\t\treturn i;\n\tcase '\\\\':\n\tcase '\"':\n\t\treturn c;\n\tdefault:\n\t{\n\t\tstatic bool warned[256];\n\t\tunsigned char uc = (unsigned char) c;\n\n\t\t/* N.B.: use unsigned char here to avoid Latin-1 problems */\n\n\t\tif (! warned[uc]) {\n\t\t\twarned[uc] = true;\n\n\t\t\twarning(_(\"escape sequence `\\\\%c' treated as plain `%c'\"), uc, uc);\n\t\t}\n\t}\n\t\treturn c;\n\t}\n}",
      "lines": 114,
      "depth": 18,
      "decorators": [
        "int"
      ]
    },
    "get_numbase": {
      "start_point": [
        634,
        0
      ],
      "end_point": [
        674,
        1
      ],
      "content": "int\nget_numbase(const char *s, size_t len, bool use_locale)\n{\n\tint dec_point = '.';\n\tconst char *str = s;\n\n#if defined(HAVE_LOCALE_H)\n\t/*\n\t * loc.decimal_point may not have been initialized yet,\n\t * so double check it before using it.\n\t */\n\tif (use_locale && loc.decimal_point != NULL && loc.decimal_point[0] != '\\0')\n\t\tdec_point = loc.decimal_point[0];\t/* XXX --- assumes one char */\n#endif\n\n\tif (len < 2 || str[0] != '0')\n\t\treturn 10;\n\n\t/* leading 0x or 0X */\n\tif (str[1] == 'x' || str[1] == 'X')\n\t\treturn 16;\n\n\t/*\n\t * Numbers with '.', 'e', or 'E' are decimal.\n\t * Have to check so that things like 00.34 are handled right.\n\t *\n\t * These beasts can have trailing whitespace. Deal with that too.\n\t */\n\tfor (; len > 0; len--, str++) {\n\t\tif (*str == 'e' || *str == 'E' || *str == dec_point)\n\t\t\treturn 10;\n\t\telse if (! isdigit((unsigned char) *str))\n\t\t\tbreak;\n\t}\n\n\tif (! isdigit((unsigned char) s[1])\n\t\t\t|| s[1] == '8' || s[1] == '9'\n\t)\n\t\treturn 10;\n\treturn 8;\n}",
      "lines": 41,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "str2wstr": {
      "start_point": [
        678,
        0
      ],
      "end_point": [
        811,
        1
      ],
      "content": "NODE *\nstr2wstr(NODE *n, size_t **ptr)\n{\n\tsize_t i, count, src_count;\n\tchar *sp;\n\tmbstate_t mbs;\n\twchar_t wc, *wsp;\n\tstatic bool warned = false;\n\n\tassert((n->flags & (STRING|STRCUR)) != 0);\n\n\t/*\n\t * Don't convert global null string or global null field\n\t * variables to a wide string. They are both zero-length anyway.\n\t * This also avoids future double-free errors while releasing\n\t * shallow copies, eg. *tmp = *Null_field; free_wstr(tmp);\n\t */\n\tif (n == Nnull_string || n == Null_field)\n\t\treturn n;\n\n\tif ((n->flags & WSTRCUR) != 0) {\n\t\tif (ptr == NULL)\n\t\t\treturn n;\n\t\t/* otherwise\n\t\t\tfall through and recompute to fill in the array */\n\t\tfree_wstr(n);\n\t}\n\n\t/*\n\t * After consideration and consultation, this\n\t * code trades space for time. We allocate\n\t * an array of wchar_t that is n->stlen long.\n\t * This is needed in the worst case anyway, where\n\t * each input byte maps to one wchar_t.  The\n\t * advantage is that we only have to convert the string\n\t * once, instead of twice, once to find out how many\n\t * wide characters, and then again to actually fill in\n\t * the info.  If there's a lot left over, we can\n\t * realloc the wide string down in size.\n\t */\n\n\temalloc(n->wstptr, wchar_t *, sizeof(wchar_t) * (n->stlen + 1), \"str2wstr\");\n\twsp = n->wstptr;\n\n\t/*\n\t * For use by do_match, create and fill in an array.\n\t * For each byte `i' in n->stptr (the original string),\n\t * a[i] is equal to `j', where `j' is the corresponding wchar_t\n\t * in the converted wide string.\n\t *\n\t * Create the array.\n\t */\n\tif (ptr != NULL) {\n\t\tezalloc(*ptr, size_t *, sizeof(size_t) * n->stlen, \"str2wstr\");\n\t}\n\n\tsp = n->stptr;\n\tsrc_count = n->stlen;\n\tmemset(& mbs, 0, sizeof(mbs));\n\tfor (i = 0; src_count > 0; i++) {\n\t\t/*\n\t\t * 9/2010: Check the current byte; if it's a valid character,\n\t\t * then it doesn't start a multibyte sequence. This brings a\n\t\t * big speed up. Thanks to Ulrich Drepper for the tip.\n\t\t * 11/2010: Thanks to Paolo Bonzini for some even faster code.\n\t\t */\n\t\tif (is_valid_character(*sp)) {\n\t\t\tcount = 1;\n\t\t\twc = btowc_cache(*sp);\n\t\t} else\n\t\t\tcount = mbrtowc(& wc, sp, src_count, & mbs);\n\t\tswitch (count) {\n\t\tcase (size_t) -2:\n\t\tcase (size_t) -1:\n\t\t\t/*\n\t\t\t * mbrtowc(3) says the state of mbs becomes undefined\n\t\t\t * after a bad character, so reset it.\n\t\t\t */\n\t\t\tmemset(& mbs, 0, sizeof(mbs));\n\n\t\t\t/* Warn the user something's wrong */\n\t\t\tif (! warned) {\n\t\t\t\twarned = true;\n\t\t\t\twarning(_(\"Invalid multibyte data detected. There may be a mismatch between your data and your locale.\"));\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * 8/2015: If we're using UTF, then instead of just\n\t\t\t * skipping the character, plug in the Unicode\n\t\t\t * replacement character. In most cases this gives\n\t\t\t * us \"better\" results, in that character counts\n\t\t\t * and string lengths tend to make more sense.\n\t\t\t *\n\t\t\t * Otherwise, just skip the bad byte and keep going,\n\t\t\t * so that we get a more-or-less full string, instead of\n\t\t\t * stopping early. This is particularly important\n\t\t\t * for match() where we need to build the indices.\n\t\t\t */\n\t\t\tif (using_utf8()) {\n\t\t\t\tcount = 1;\n\t\t\t\twc = 0xFFFD;\t/* unicode replacement character */\n\t\t\t\tgoto set_wc;\n\t\t\t} else {\n\t\t\t\t/* skip it and keep going */\n\t\t\t\tsp++;\n\t\t\t\tsrc_count--;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 0:\n\t\t\tcount = 1;\n\t\t\t/* fall through */\n\t\tdefault:\n\t\tset_wc:\n\t\t\t*wsp++ = wc;\n\t\t\tsrc_count -= count;\n\t\t\twhile (count--)  {\n\t\t\t\tif (ptr != NULL)\n\t\t\t\t\t(*ptr)[sp - n->stptr] = i;\n\t\t\t\tsp++;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t*wsp = L'\\0';\n\tn->wstlen = wsp - n->wstptr;\n\tn->flags |= WSTRCUR;\n#define ARBITRARY_AMOUNT_TO_GIVE_BACK 100\n\tif (n->stlen - n->wstlen > ARBITRARY_AMOUNT_TO_GIVE_BACK)\n\t\terealloc(n->wstptr, wchar_t *, sizeof(wchar_t) * (n->wstlen + 1), \"str2wstr\");\n\n\treturn n;\n}",
      "lines": 134,
      "depth": 16,
      "decorators": [
        "NODE",
        "*\nstr2wstr(NODE *n, size_t **ptr)",
        "*"
      ]
    },
    "wstr2str": {
      "start_point": [
        815,
        0
      ],
      "end_point": [
        853,
        1
      ],
      "content": "NODE *\nwstr2str(NODE *n)\n{\n\tsize_t result;\n\tsize_t length;\n\twchar_t *wp;\n\tmbstate_t mbs;\n\tchar *newval, *cp;\n\n\tassert(n->valref == 1);\n\tassert((n->flags & WSTRCUR) != 0);\n\n\t/*\n\t * Convert the wide chars in t1->wstptr back into m.b. chars.\n\t * This is pretty grotty, but it's the most straightforward\n\t * way to do things.\n\t */\n\tmemset(& mbs, 0, sizeof(mbs));\n\n\tlength = n->wstlen;\n\temalloc(newval, char *, (length * gawk_mb_cur_max) + 1, \"wstr2str\");\n\n\twp = n->wstptr;\n\tfor (cp = newval; length > 0; length--) {\n\t\tresult = wcrtomb(cp, *wp, & mbs);\n\t\tif (result == (size_t) -1)\t/* what to do? break seems best */\n\t\t\tbreak;\n\t\tcp += result;\n\t\twp++;\n\t}\n\t*cp = '\\0';\n\n\t/* N.B. caller just created n with make_string, so this free is safe */\n\tefree(n->stptr);\n\tn->stptr = newval;\n\tn->stlen = cp - newval;\n\n\treturn n;\n}",
      "lines": 39,
      "depth": 10,
      "decorators": [
        "NODE",
        "*\nwstr2str(NODE *n)",
        "*"
      ]
    },
    "r_free_wstr": {
      "start_point": [
        857,
        0
      ],
      "end_point": [
        869,
        1
      ],
      "content": "void\nr_free_wstr(NODE *n)\n{\n\tassert(n->type == Node_val);\n\n\tif ((n->flags & WSTRCUR) != 0) {\n\t\tassert(n->wstptr != NULL);\n\t\tefree(n->wstptr);\n\t}\n\tn->wstptr = NULL;\n\tn->wstlen = 0;\n\tn->flags &= ~WSTRCUR;\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "dump_wstr": {
      "start_point": [
        871,
        0
      ],
      "end_point": [
        879,
        1
      ],
      "content": "static void __attribute__ ((unused))\ndump_wstr(FILE *fp, const wchar_t *str, size_t len)\n{\n\tif (str == NULL || len == 0)\n\t\treturn;\n\n\tfor (; len--; str++)\n\t\tputwc(*str, fp);\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void",
        "__attribute__ ((unused))",
        "__attribute__",
        "(",
        "(unused)",
        "(",
        "unused",
        ")",
        ")"
      ]
    },
    "wstrstr": {
      "start_point": [
        883,
        0
      ],
      "end_point": [
        904,
        1
      ],
      "content": "const wchar_t *\nwstrstr(const wchar_t *haystack, size_t hs_len,\n\tconst wchar_t *needle, size_t needle_len)\n{\n\tsize_t i;\n\n\tif (haystack == NULL || needle == NULL || needle_len > hs_len)\n\t\treturn NULL;\n\n\tfor (i = 0; i < hs_len; i++) {\n\t\tif (haystack[i] == needle[0]\n\t\t    && i+needle_len-1 < hs_len\n\t\t    && haystack[i+needle_len-1] == needle[needle_len-1]) {\n\t\t\t/* first & last chars match, check string */\n\t\t\tif (memcmp(haystack+i, needle, sizeof(wchar_t) * needle_len) == 0) {\n\t\t\t\treturn haystack + i;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn NULL;\n}",
      "lines": 22,
      "depth": 15,
      "decorators": [
        "const",
        "const",
        "wchar_t",
        "*\nwstrstr(const wchar_t *haystack, size_t hs_len,\n\tconst wchar_t *needle, size_t needle_len)",
        "*"
      ]
    },
    "wcasestrstr": {
      "start_point": [
        908,
        0
      ],
      "end_point": [
        939,
        1
      ],
      "content": "const wchar_t *\nwcasestrstr(const wchar_t *haystack, size_t hs_len,\n\tconst wchar_t *needle, size_t needle_len)\n{\n\tsize_t i, j;\n\n\tif (haystack == NULL || needle == NULL || needle_len > hs_len)\n\t\treturn NULL;\n\n\tfor (i = 0; i < hs_len; i++) {\n\t\tif (towlower(haystack[i]) == towlower(needle[0])\n\t\t    && i+needle_len-1 < hs_len\n\t\t    && towlower(haystack[i+needle_len-1]) == towlower(needle[needle_len-1])) {\n\t\t\t/* first & last chars match, check string */\n\t\t\tconst wchar_t *start;\n\n\t\t\tstart = haystack+i;\n\t\t\tfor (j = 0; j < needle_len; j++, start++) {\n\t\t\t\twchar_t h, n;\n\n\t\t\t\th = towlower(*start);\n\t\t\t\tn = towlower(needle[j]);\n\t\t\t\tif (h != n)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\treturn haystack + i;\n\t\t}\nout:\t;\n\t}\n\n\treturn NULL;\n}",
      "lines": 32,
      "depth": 14,
      "decorators": [
        "const",
        "const",
        "wchar_t",
        "*\nwcasestrstr(const wchar_t *haystack, size_t hs_len,\n\tconst wchar_t *needle, size_t needle_len)",
        "*"
      ]
    },
    "is_ieee_magic_val": {
      "start_point": [
        943,
        0
      ],
      "end_point": [
        957,
        1
      ],
      "content": "static int\nis_ieee_magic_val(const char *val)\n{\n\t/*\n\t * Avoid strncasecmp: it mishandles ASCII bytes in some locales.\n\t * Assume the length is 4, as the caller checks this.\n\t */\n\treturn (   (val[0] == '+' || val[0] == '-')\n\t\t&& (   (   (val[1] == 'i' || val[1] == 'I')\n\t\t\t&& (val[2] == 'n' || val[2] == 'N')\n\t\t\t&& (val[3] == 'f' || val[3] == 'F'))\n\t\t    || (   (val[1] == 'n' || val[1] == 'N')\n\t\t\t&& (val[2] == 'a' || val[2] == 'A')\n\t\t\t&& (val[3] == 'n' || val[3] == 'N'))));\n}",
      "lines": 15,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "get_ieee_magic_val": {
      "start_point": [
        961,
        0
      ],
      "end_point": [
        988,
        1
      ],
      "content": "static AWKNUM\nget_ieee_magic_val(char *val)\n{\n\tstatic bool first = true;\n\tstatic AWKNUM inf;\n\tstatic AWKNUM nan;\n\tchar save;\n\n\tchar *ptr;\n\tsave = val[4];\n\tval[4] = '\\0';\n\tAWKNUM v = strtod(val, &ptr);\n\tval[4] = save;\n\n\tif (val == ptr) { /* Older strtod implementations don't support inf or nan. */\n\t\tif (first) {\n\t\t\tfirst = false;\n\t\t\tnan = sqrt(-1.0);\n\t\t\tinf = -log(0.0);\n\t\t}\n\n\t\tv = ((val[1] == 'i' || val[1] == 'I') ? inf : nan);\n\t\tif (val[0] == '-')\n\t\t\tv = -v;\n\t}\n\n\treturn v;\n}",
      "lines": 28,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "AWKNUM"
      ]
    },
    "init_btowc_cache": {
      "start_point": [
        994,
        0
      ],
      "end_point": [
        1001,
        1
      ],
      "content": "void init_btowc_cache()\n{\n\tint i;\n\n\tfor (i = 0; i < 255; i++) {\n\t\tbtowc_cache[i] = btowc(i);\n\t}\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "more_blocks": {
      "start_point": [
        1019,
        0
      ],
      "end_point": [
        1043,
        1
      ],
      "content": "void *\nmore_blocks(int id)\n{\n\tstruct block_item *freep, *np, *next;\n\tchar *p, *endp;\n\tsize_t size;\n\n\tsize = nextfree[id].size;\n\n\tassert(size >= sizeof(struct block_item));\n\temalloc(freep, struct block_item *, BLOCKCHUNK * size, \"more_blocks\");\n\tp = (char *) freep;\n\tendp = p + BLOCKCHUNK * size;\n\n\tfor (np = freep; ; np = next) {\n\t\tnext = (struct block_item *) (p += size);\n\t\tif (p >= endp) {\n\t\t\tnp->freep = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tnp->freep = next;\n\t}\n\tnextfree[id].freep = freep->freep;\n\treturn freep;\n}",
      "lines": 25,
      "depth": 10,
      "decorators": [
        "void",
        "*\nmore_blocks(int id)",
        "*"
      ]
    }
  },
  "gawk/gawk-4.2.1/nonposix.h": {},
  "gawk/gawk-4.2.1/profile.c": {
    "set_prof_file": {
      "start_point": [
        70,
        0
      ],
      "end_point": [
        101,
        1
      ],
      "content": "void\nset_prof_file(const char *file)\n{\n\tint fd;\n\n\tassert(file != NULL);\n\tfd = devopen_simple(file, \"w\", true);\n\tif (fd == INVALID_HANDLE)\n\t\tprof_fp = NULL;\n\telse if (fd == fileno(stdout))\n\t\tprof_fp = stdout;\n\telse if (fd == fileno(stderr))\n\t\tprof_fp = stderr;\n\telse\n\t\tprof_fp = fdopen(fd, \"w\");\n\n\tif (prof_fp == NULL) {\n\t\t/* don't leak file descriptors */\n\t\tint e = errno;\n\n\t\tif (   fd != INVALID_HANDLE\n\t\t    && fd != fileno(stdout)\n\t\t    && fd != fileno(stderr))\n\t\t\t(void) close(fd);\n\n\t\terrno = e;\n\t\twarning(_(\"could not open `%s' for writing: %s\"),\n\t\t\t\tfile, strerror(errno));\n\t\twarning(_(\"sending profile to standard error\"));\n\t\tprof_fp = stderr;\n\t}\n}",
      "lines": 32,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "init_profiling_signals": {
      "start_point": [
        105,
        0
      ],
      "end_point": [
        119,
        1
      ],
      "content": "void\ninit_profiling_signals()\n{\n#ifdef __DJGPP__\n\tsignal(SIGINT, dump_and_exit);\n\tsignal(SIGQUIT, just_dump);\n#else  /* !__DJGPP__ */\n#ifdef SIGHUP\n\tsignal(SIGHUP, dump_and_exit);\n#endif\n#ifdef SIGUSR1\n\tsignal(SIGUSR1, just_dump);\n#endif\n#endif /* !__DJGPP__ */\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "indent": {
      "start_point": [
        123,
        0
      ],
      "end_point": [
        138,
        1
      ],
      "content": "static void\nindent(long count)\n{\n\tint i;\n\n\tif (do_profile) {\n\t\tif (count == 0)\n\t\t\tfprintf(prof_fp, \"\\t\");\n\t\telse\n\t\t\tfprintf(prof_fp, \"%6ld  \", count);\n\t}\n\n\tassert(indent_level >= 0);\n\tfor (i = 0; i < indent_level; i++)\n\t\tfprintf(prof_fp, \"\\t\");\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "indent_in": {
      "start_point": [
        142,
        0
      ],
      "end_point": [
        147,
        1
      ],
      "content": "static void\nindent_in(void)\n{\n\tassert(indent_level >= 0);\n\tindent_level++;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "indent_out": {
      "start_point": [
        151,
        0
      ],
      "end_point": [
        156,
        1
      ],
      "content": "static void\nindent_out(void)\n{\n\tindent_level--;\n\tassert(indent_level >= 0);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "pp_push": {
      "start_point": [
        160,
        0
      ],
      "end_point": [
        171,
        1
      ],
      "content": "static void\npp_push(int type, char *s, int flag)\n{\n\tNODE *n;\n\tgetnode(n);\n\tn->pp_str = s;\n\tn->pp_len = strlen(s);\n\tn->flags = flag;\n\tn->type = type;\n\tn->pp_next = pp_stack;\n\tpp_stack = n;\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "pp_pop": {
      "start_point": [
        175,
        0
      ],
      "end_point": [
        182,
        1
      ],
      "content": "static NODE *\npp_pop()\n{\n\tNODE *n;\n\tn = pp_stack;\n\tpp_stack = n->pp_next;\n\treturn n;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "NODE",
        "*\npp_pop()",
        "*"
      ]
    },
    "pp_free": {
      "start_point": [
        186,
        0
      ],
      "end_point": [
        192,
        1
      ],
      "content": "static void\npp_free(NODE *n)\n{\n\tif ((n->flags & CAN_FREE) != 0)\n\t\tefree(n->pp_str);\n\tfreenode(n);\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "pprint": {
      "start_point": [
        196,
        0
      ],
      "end_point": [
        1046,
        1
      ],
      "content": "static void\npprint(INSTRUCTION *startp, INSTRUCTION *endp, int flags)\n{\n\tINSTRUCTION *pc;\n\tNODE *t1;\n\tchar *str;\n\tNODE *t2;\n\tINSTRUCTION *ip1;\n\tINSTRUCTION *ip2;\n\tNODE *m;\n\tchar *tmp;\n\tint rule;\n\tstatic int rule_count[MAXRULE];\n\tstatic bool skip_comment = false;\n\n\tfor (pc = startp; pc != endp; pc = pc->nexti) {\n\t\tif (pc->source_line > 0)\n\t\t\tsourceline = pc->source_line;\n\n\t\t/* skip leading EOL comment as it has already been printed  */\n\t\tif (pc->opcode == Op_comment\n\t\t    && pc->memory->comment_type == EOL_COMMENT\n\t\t    && skip_comment) {\n\t\t\tskip_comment = false;\n\t\t\tcontinue;\n\t\t}\n\t\tskip_comment = false;\n\n\t\tswitch (pc->opcode) {\n\t\tcase Op_rule:\n\t\t\t/*\n\t\t\t * Rules are three instructions long.\n\t\t\t * See append_rule in awkgram.y.\n\t\t\t * The first has the Rule Op Code, nexti etc.\n\t\t\t * The second, (pc + 1) has firsti and lasti:\n\t\t\t * \tthe first/last ACTION instructions for this rule.\n\t\t\t * The third has first_line and last_line:\n\t\t\t * \tthe first and last source line numbers.\n\t\t\t */\n\t\t\tsource = pc->source_file;\n\t\t\trule = pc->in_rule;\n\n\t\t\tif (rule != Rule) {\n\t\t\t\t/* Allow for pre-non-rule-block comment  */\n\t\t\t\tif (pc->nexti != (pc +1)->firsti\n\t\t\t\t    && pc->nexti->opcode == Op_comment\n\t\t\t\t    && pc->nexti->memory->comment_type == FULL_COMMENT)\n\t\t\t\t\tprint_comment(pc->nexti, -1);\n\t\t\t\tip1 = (pc + 1)->firsti;\n\t\t\t\tip2 = (pc + 1)->lasti;\n\n\t\t\t\tif (do_profile) {\n\t\t\t\t\tif (! rule_count[rule]++)\n\t\t\t\t\t\tfprintf(prof_fp, _(\"\\t# %s rule(s)\\n\\n\"), ruletab[rule]);\n\t\t\t\t\tindent(0);\n\t\t\t\t}\n\t\t\t\tfprintf(prof_fp, \"%s {\", ruletab[rule]);\n\t\t\t\tend_line(pc);\n\t\t\t\tskip_comment = true;\n\t\t\t} else {\n\t\t\t\tif (do_profile && ! rule_count[rule]++)\n\t\t\t\t\tfprintf(prof_fp, _(\"\\t# Rule(s)\\n\\n\"));\n\t\t\t\tip1 = pc->nexti;\n\t\t\t\tindent(ip1->exec_count);\n\t\t\t\tif (ip1 != (pc + 1)->firsti) {\t\t/* non-empty pattern */\n\t\t\t\t\tpprint(ip1->nexti, (pc + 1)->firsti, NO_PPRINT_FLAGS);\n\t\t\t\t\t/* Allow for case where the \"pattern\" is just a comment  */\n\t\t\t\t\tif (ip1->nexti->nexti->nexti != (pc +1)->firsti\n\t\t\t\t\t    || ip1->nexti->opcode != Op_comment) {\n\t\t\t\t\t\tt1 = pp_pop();\n\t\t\t\t\t\tfprintf(prof_fp, \"%s {\", t1->pp_str);\n\t\t\t\t\t\tpp_free(t1);\n\t\t\t\t\t} else\n\t\t\t\t\t\tfprintf(prof_fp, \"{\");\n\t\t\t\t\tip1 = (pc + 1)->firsti;\n\t\t\t\t\tip2 = (pc + 1)->lasti;\n\n\t\t\t\t\tif (do_profile && ip1->exec_count > 0)\n\t\t\t\t\t\tfprintf(prof_fp, \" # %ld\", ip1->exec_count);\n\n\t\t\t\t\tend_line(ip1);\n\t\t\t\t\tskip_comment = true;\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(prof_fp, \"{\\n\");\n\t\t\t\t\tip1 = (pc + 1)->firsti;\n\t\t\t\t\tip2 = (pc + 1)->lasti;\n\t\t\t\t}\n\t\t\t\tip1 = ip1->nexti;\n\t\t\t}\n\t\t\tindent_in();\n\t\t\tpprint(ip1, ip2, NO_PPRINT_FLAGS);\n\t\t\tindent_out();\n\t\t\tif (do_profile)\n\t\t\t\tindent(0);\n\t\t\tfprintf(prof_fp, \"}\\n\\n\");\n\t\t\tpc = (pc + 1)->lasti;\n\t\t\tbreak;\n\n\t\tcase Op_atexit:\n\t\t\tbreak;\n\n\t\tcase Op_stop:\n\t\t\tmemset(rule_count, 0, MAXRULE * sizeof(int));\n\t\t\tbreak;\n\n\t\tcase Op_push_i:\n\t\t\tm = pc->memory;\n\t\t\tif (m == Nnull_string)\t/* optional return or exit value; don't print 0 or \"\" */\n\t\t\t\tpp_push(pc->opcode, m->stptr, DONT_FREE);\n\t\t\telse if ((m->flags & NUMBER) != 0)\n\t\t\t\tpp_push(pc->opcode, pp_number(m), CAN_FREE);\n\t\t\telse {\n\t\t\t\tstr = pp_string(m->stptr, m->stlen, '\"');\n\t\t\t\tif ((m->flags & INTLSTR) != 0) {\n\t\t\t\t\tchar *tmp = str;\n\t\t\t\t\tstr = pp_group3(\"_\", tmp, \"\");\n\t\t\t\t\tefree(tmp);\n\t\t\t\t}\n\t\t\t\tpp_push(pc->opcode, str, CAN_FREE);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase Op_store_var:\n\t\t\tif (pc->initval != NULL)\n\t\t\t\tpp_push(Op_push_i, pp_node(pc->initval), CAN_FREE);\n\t\t\t/* fall through */\n\t\tcase Op_store_sub:\n\t\tcase Op_assign_concat:\n\t\tcase Op_push_lhs:\n\t\tcase Op_push_param:\n\t\tcase Op_push_array:\n\t\tcase Op_push:\n\t\tcase Op_push_arg:\n\t\tcase Op_push_arg_untyped:\n\t\t\tm = pc->memory;\n\t\t\tswitch (m->type) {\n\t\t\tcase Node_param_list:\n\t\t\t\tpp_push(pc->opcode, func_params[m->param_cnt].param, DONT_FREE);\n\t\t\t\tbreak;\n\n\t\t\tcase Node_var:\n\t\t\tcase Node_var_new:\n\t\t\tcase Node_var_array:\n\t\t\t\tif (m->vname != NULL)\n\t\t\t\t\tpp_push(pc->opcode, m->vname, DONT_FREE);\n \t\t\t\telse\n\t\t\t\t\tfatal(_(\"internal error: %s with null vname\"),\n\t\t\t\t\t\t\tnodetype2str(m->type));\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tcant_happen();\n\t\t\t}\n\n\t\t\tswitch (pc->opcode) {\n\t\t\tcase Op_store_var:\n\t\t\t\tt2 = pp_pop(); /* l.h.s. */\n\t\t\t\tt1 = pp_pop(); /* r.h.s. */\n\t\t\t\tfprintf(prof_fp, \"%s%s%s\", t2->pp_str, op2str(pc->opcode), t1->pp_str);\n\t\t\t\tgoto cleanup;\n\n\t\t\tcase Op_store_sub:\n\t\t\t\tt1 = pp_pop();\t/* array */\n\t\t\t\ttmp = pp_list(pc->expr_count, op2str(Op_subscript), \", \"); /*subscript*/\n\t\t\t\tt2 = pp_pop(); /* r.h.s. */\n\t\t\t\tfprintf(prof_fp, \"%s%s%s%s\", t1->pp_str, tmp,\n\t\t\t\t\t\t\t\t\top2str(pc->opcode), t2->pp_str);\n\t\t\t\tefree(tmp);\n\t\t\t\tgoto cleanup;\n\n\t\t\tcase Op_assign_concat:\n\t\t\t\tt2 = pp_pop(); /* l.h.s. */\n\t\t\t\tt1 = pp_pop();\n\t\t\t\ttmp = pp_group3(t2->pp_str, op2str(Op_concat), t1->pp_str);\n\t\t\t\tfprintf(prof_fp, \"%s%s%s\", t2->pp_str, op2str(Op_assign), tmp);\n\t\t\t\tefree(tmp);\ncleanup:\n\t\t\t\tpp_free(t2);\n\t\t\t\tpp_free(t1);\n\t\t\t\tif ((flags & IN_FOR_HEADER) == 0)\n\t\t\t\t\tpc = end_line(pc);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase Op_sub_array:\n\t\tcase Op_subscript_lhs:\n\t\tcase Op_subscript:\n\t\t\ttmp = pp_list(pc->sub_count, op2str(pc->opcode), \", \");\n\t\t\tt1 = pp_pop();\n\t\t\tstr = pp_group3(t1->pp_str, tmp, \"\");\n\t\t\tefree(tmp);\n\t\t\tpp_free(t1);\n\t\t\tpp_push(pc->opcode, str, CAN_FREE);\n\t\t\tbreak;\n\n\t\tcase Op_and:\n\t\tcase Op_or:\n\t\t\tpprint(pc->nexti, pc->target_jmp, flags);\n\t\t\tt2 = pp_pop();\n\t\t\tt1 = pp_pop();\n\t\t\tparenthesize(pc->opcode, t1, t2);\n\t\t\tstr = pp_group3(t1->pp_str, op2str(pc->opcode), t2->pp_str);\n\t\t\tpp_free(t1);\n\t\t\tpp_free(t2);\n\t\t\tpp_push(pc->opcode, str, CAN_FREE);\n\t\t\tpc = pc->target_jmp;\n\t\t\tbreak;\n\n\t\tcase Op_plus_i:\n\t\tcase Op_minus_i:\n\t\tcase Op_times_i:\n\t\tcase Op_exp_i:\n\t\tcase Op_quotient_i:\n\t\tcase Op_mod_i:\n\t\t\tm = pc->memory;\n\t\t\tt1 = pp_pop();\n\t\t\tif (prec_level(pc->opcode) > prec_level(t1->type)\n\t\t\t\t\t&& is_binary(t1->type))  /* (a - b) * 1 */\n\t\t\t\tpp_parenthesize(t1);\n\t\t\tif ((m->flags & NUMBER) != 0)\n\t\t\t\ttmp = pp_number(m);\n\t\t\telse\n\t\t\t\ttmp = pp_string(m->stptr, m->stlen, '\"');\n\t\t\tstr = pp_group3(t1->pp_str, op2str(pc->opcode), tmp);\n\t\t\tefree(tmp);\n\t\t\tpp_free(t1);\n\t\t\tpp_push(pc->opcode, str, CAN_FREE);\n\t\t\tbreak;\n\n\t\tcase Op_parens:\n\t\t\tt1 = pp_pop();\n\t\t\tstr = pp_group3(\"(\", t1->pp_str, \")\");\n\t\t\tpp_free(t1);\n\t\t\tpp_push(pc->opcode, str, CAN_FREE);\n\t\t\tbreak;\n\n\t\tcase Op_plus:\n\t\tcase Op_minus:\n\t\tcase Op_times:\n\t\tcase Op_exp:\n\t\tcase Op_quotient:\n\t\tcase Op_mod:\n\t\tcase Op_equal:\n\t\tcase Op_notequal:\n\t\tcase Op_less:\n\t\tcase Op_greater:\n\t\tcase Op_leq:\n\t\tcase Op_geq:\n\t\t\tt2 = pp_pop();\n\t\t\tt1 = pp_pop();\n\t\t\tparenthesize(pc->opcode, t1, t2);\n\t\t\tstr = pp_group3(t1->pp_str, op2str(pc->opcode), t2->pp_str);\n\t\t\tpp_free(t1);\n\t\t\tpp_free(t2);\n\t\t\tpp_push(pc->opcode, str, CAN_FREE);\n\t\t\tbreak;\n\n\t\tcase Op_preincrement:\n\t\tcase Op_predecrement:\n\t\tcase Op_postincrement:\n\t\tcase Op_postdecrement:\n\t\t\tt1 = pp_pop();\n\t\t\tif (pc->opcode == Op_preincrement || pc->opcode == Op_predecrement)\n\t\t\t\tstr = pp_group3(op2str(pc->opcode), t1->pp_str, \"\");\n\t\t\telse\n\t\t\t\tstr = pp_group3(t1->pp_str, op2str(pc->opcode), \"\");\n\t\t\tpp_free(t1);\n\t\t\tpp_push(pc->opcode, str, CAN_FREE);\n\t\t\tbreak;\n\n\t\tcase Op_field_spec:\n\t\tcase Op_field_spec_lhs:\n\t\tcase Op_unary_minus:\n\t\tcase Op_unary_plus:\n\t\tcase Op_not:\n\t\t\tt1 = pp_pop();\n\t\t\tif (is_binary(t1->type)\n\t\t\t    || (((OPCODE) t1->type) == pc->opcode\n\t\t\t\t    && (pc->opcode == Op_unary_minus\n\t\t\t\t\t    || pc->opcode == Op_unary_plus)))\n\t\t\t\tpp_parenthesize(t1);\n\n\t\t\t/* optypes table (eval.c) includes space after ! */\n\t\t\tstr = pp_group3(op2str(pc->opcode), t1->pp_str, \"\");\n\t\t\tpp_free(t1);\n\t\t\tpp_push(pc->opcode, str, CAN_FREE);\n\t\t\tbreak;\n\n\t\tcase Op_assign:\n\t\tcase Op_assign_plus:\n\t\tcase Op_assign_minus:\n\t\tcase Op_assign_times:\n\t\tcase Op_assign_quotient:\n\t\tcase Op_assign_mod:\n\t\tcase Op_assign_exp:\n\t\t\tt2 = pp_pop(); /* l.h.s. */\n\t\t\tt1 = pp_pop();\n\t\t\tstr = pp_group3(t2->pp_str, op2str(pc->opcode), t1->pp_str);\n\t\t\tpp_free(t2);\n\t\t\tpp_free(t1);\n\t\t\tpp_push(pc->opcode, str, CAN_FREE);\n\t\t\tbreak;\n\n\t\tcase Op_store_field:\n\t\t\tt1 = pp_pop(); /* field num */\n\t\t\tif (is_binary(t1->type))\n\t\t\t\tpp_parenthesize(t1);\n\t\t\tt2 = pp_pop(); /* r.h.s. */\n\t\t\tfprintf(prof_fp, \"$%s%s%s\", t1->pp_str, op2str(pc->opcode), t2->pp_str);\n\t\t\tpp_free(t2);\n\t\t\tpp_free(t1);\n\t\t\tif ((flags & IN_FOR_HEADER) == 0)\n\t\t\t\tpc = end_line(pc);\n\t\t\tbreak;\n\n\t\tcase Op_concat:\n\t\t\tstr = pp_concat(pc->expr_count);\n\t\t\tpp_push(Op_concat, str, CAN_FREE);\n\t\t\tbreak;\n\n\t\tcase Op_K_delete:\n\t\t{\n\t\t\tchar *array;\n\t\t\tt1 = pp_pop();\n\t\t\tarray = t1->pp_str;\n\t\t\tif (pc->expr_count > 0) {\n\t\t\t\tchar *sub;\n\t\t\t\tsub = pp_list(pc->expr_count, NULL, pc->expr_count > 1 ? \"][\" : \", \");\n\t\t\t\tfprintf(prof_fp, \"%s %s[%s]\", op2str(Op_K_delete), array, sub);\n\t\t\t\tefree(sub);\n\t\t\t} else\n\t\t\t\tfprintf(prof_fp, \"%s %s\", op2str(Op_K_delete), array);\n\t\t\tif ((flags & IN_FOR_HEADER) == 0)\n\t\t\t\tpc = end_line(pc);\n\t\t\tpp_free(t1);\n\t\t}\n\t\t\tbreak;\n\n\t\tcase Op_K_delete_loop:\n\t\t\t/* Efficency hack not in effect because of exec_count instruction */\n\t\t\tcant_happen();\n\t\t\tbreak;\n\n\t\tcase Op_in_array:\n\t\t{\n\t\t\tchar *array, *sub;\n\t\t\tt1 = pp_pop();\n\t\t\tarray = t1->pp_str;\n\t\t\tif (pc->expr_count > 1) {\n\t\t\t\tsub = pp_list(pc->expr_count, \"()\", \", \");\n\t\t\t\tstr = pp_group3(sub, op2str(Op_in_array), array);\n\t\t\t\tefree(sub);\n\t\t\t} else {\n\t\t\t\tt2 = pp_pop();\n\t\t\t\tif (prec_level(t2->type) < prec_level(Op_in_array)) {\n\t\t\t\t\tpp_parenthesize(t2);\n\t\t\t\t}\n\t\t\t\tsub = t2->pp_str;\n\t\t\t\tstr = pp_group3(sub, op2str(Op_in_array), array);\n\t\t\t\tpp_free(t2);\n\t\t\t}\n\t\t\tpp_free(t1);\n\t\t\tpp_push(Op_in_array, str, CAN_FREE);\n\t\t}\n\t\t\tbreak;\n\n\t\tcase Op_var_update:\n\t\tcase Op_var_assign:\n\t\tcase Op_field_assign:\n\t\tcase Op_subscript_assign:\n\t\tcase Op_arrayfor_init:\n\t\tcase Op_arrayfor_incr:\n\t\tcase Op_arrayfor_final:\n\t\tcase Op_newfile:\n\t\tcase Op_get_record:\n\t\tcase Op_lint:\n\t\tcase Op_jmp:\n\t\tcase Op_jmp_false:\n\t\tcase Op_jmp_true:\n\t\tcase Op_no_op:\n\t\tcase Op_and_final:\n\t\tcase Op_or_final:\n\t\tcase Op_cond_pair:\n\t\tcase Op_after_beginfile:\n\t\tcase Op_after_endfile:\n\t\t\tbreak;\n\n\t\tcase Op_sub_builtin:\n\t\t{\n\t\t\tconst char *fname = \"sub\";\n\t\t\tif ((pc->sub_flags & GSUB) != 0)\n\t\t\t\tfname = \"gsub\";\n\t\t\telse if ((pc->sub_flags & GENSUB) != 0)\n\t\t\t\tfname = \"gensub\";\n\t\t\ttmp = pp_list(pc->expr_count, \"()\", \", \");\n\t\t\tstr = pp_group3(fname, tmp, \"\");\n\t\t\tefree(tmp);\n\t\t\tpp_push(Op_sub_builtin, str, CAN_FREE);\n\t\t}\n\t\t\tbreak;\n\n\t\tcase Op_builtin:\n\t\tcase Op_ext_builtin:\n\t\t{\n\t\t\tconst char *fname;\n\t\t\tif (pc->opcode == Op_builtin)\n\t\t\t\tfname = getfname(pc->builtin);\n\t\t\telse\n\t\t\t\tfname = (pc + 1)->func_name;\n\t\t\tif (fname != NULL) {\n\t\t\t\tif (pc->expr_count > 0) {\n\t\t\t\t\ttmp = pp_list(pc->expr_count, \"()\", \", \");\n\t\t\t\t\tstr = pp_group3(fname, tmp, \"\");\n\t\t\t\t\tefree(tmp);\n\t\t\t\t} else\n\t\t\t\t\tstr = pp_group3(fname, \"()\", \"\");\n\t\t\t\tpp_push(Op_builtin, str, CAN_FREE);\n\t\t\t} else\n\t\t\t\tfatal(_(\"internal error: builtin with null fname\"));\n\t\t}\n\t\t\tbreak;\n\n\t\tcase Op_K_print:\n\t\tcase Op_K_printf:\n\t\tcase Op_K_print_rec:\n\t\t\tif (pc->opcode == Op_K_print_rec)\n\t\t\t\ttmp = pp_group3(\" \", op2str(Op_field_spec), \"0\");\n\t\t\telse if (pc->redir_type != 0)\n\t\t\t\ttmp = pp_list(pc->expr_count, \"()\", \", \");\n\t\t\telse {\n\t\t\t\ttmp = pp_list(pc->expr_count, \"  \", \", \");\n\t\t\t\ttmp[strlen(tmp) - 1] = '\\0';\t/* remove trailing space */\n\t\t\t}\n\n\t\t\tif (pc->redir_type != 0) {\n\t\t\t\tt1 = pp_pop();\n\t\t\t\tif (is_binary(t1->type))\n\t\t\t\t\tpp_parenthesize(t1);\n\t\t\t\tfprintf(prof_fp, \"%s%s%s%s\", op2str(pc->opcode),\n\t\t\t\t\t\t\ttmp, redir2str(pc->redir_type), t1->pp_str);\n\t\t\t\tpp_free(t1);\n\t\t\t} else\n\t\t\t\tfprintf(prof_fp, \"%s%s\", op2str(pc->opcode), tmp);\n\t\t\tefree(tmp);\n\t\t\tif ((flags & IN_FOR_HEADER) == 0)\n\t\t\t\tpc = end_line(pc);\n\t\t\tbreak;\n\n\t\tcase Op_push_re:\n\t\t\tif (pc->memory->type != Node_regex && (pc->memory->flags & REGEX) == 0)\n\t\t\t\tbreak;\n\t\t\t/* else\n\t\t\t\tfall through */\n\t\tcase Op_match_rec:\n\t\t{\n\t\t\tif (pc->memory->type == Node_regex) {\n\t\t\t\tNODE *re = pc->memory->re_exp;\n\t\t\t\tstr = pp_string(re->stptr, re->stlen, '/');\n\t\t\t} else {\n\t\t\t\tassert((pc->memory->flags & REGEX) != 0);\n\t\t\t\tstr = pp_typed_regex(pc->memory->stptr, pc->memory->stlen, '/');\n\t\t\t}\n\t\t\tpp_push(pc->opcode, str, CAN_FREE);\n\t\t}\n\t\t\tbreak;\n\n\t\tcase Op_nomatch:\n\t\tcase Op_match:\n\t\t{\n\t\t\tchar *restr, *txt;\n\t\t\tt1 = pp_pop();\n\t\t\tif (is_binary(t1->type))\n\t\t\t\tpp_parenthesize(t1);\n\t\t\ttxt = t1->pp_str;\n\t\t\tm = pc->memory;\n\t\t\tif (m->type == Node_dynregex) {\n\t\t\t\trestr = txt;\n\t\t\t\tt2 = pp_pop();\n\t\t\t\tif (is_binary(t2->type))\n\t\t\t\t\tpp_parenthesize(t2);\n\t\t\t\ttxt = t2->pp_str;\n\t\t\t\tstr = pp_group3(txt, op2str(pc->opcode), restr);\n\t\t\t\tpp_free(t2);\n\t\t\t} else if (m->type == Node_val && (m->flags & REGEX) != 0) {\n\t\t\t\trestr = pp_typed_regex(m->stptr, m->stlen, '/');\n\t\t\t\tstr = pp_group3(txt, op2str(pc->opcode), restr);\n\t\t\t\tefree(restr);\n\t\t\t} else {\n\t\t\t\tNODE *re = m->re_exp;\n\t\t\t\trestr = pp_string(re->stptr, re->stlen, '/');\n\t\t\t\tstr = pp_group3(txt, op2str(pc->opcode), restr);\n\t\t\t\tefree(restr);\n\t\t\t}\n\t\t\tpp_free(t1);\n\t\t\tpp_push(pc->opcode, str, CAN_FREE);\n\t\t}\n\t\t\tbreak;\n\n\t\tcase Op_K_getline:\n\t\tcase Op_K_getline_redir:\n\t\t\tif (pc->into_var) {\n\t\t\t\tt1 = pp_pop();\n\t\t\t\ttmp = pp_group3(op2str(Op_K_getline), \" \", t1->pp_str);\n\t\t\t\tpp_free(t1);\n\t\t\t} else\n\t\t\t\ttmp = pp_group3(op2str(Op_K_getline), \"\", \"\");\n\n\t\t\tif (pc->redir_type != 0) {\n\t\t\t\tint before = (pc->redir_type == redirect_pipein\n\t\t\t\t\t\t\t|| pc->redir_type == redirect_twoway);\n\n\t\t\t\tt2 = pp_pop();\n\t\t\t\tif (is_binary(t2->type))\n\t\t\t\t\tpp_parenthesize(t2);\n\t\t\t\tif (before)\n\t\t\t\t\tstr = pp_group3(t2->pp_str, redir2str(pc->redir_type), tmp);\n\t\t\t\telse\n\t\t\t\t\tstr = pp_group3(tmp, redir2str(pc->redir_type), t2->pp_str);\n\t\t\t\tefree(tmp);\n\t\t\t\tpp_free(t2);\n\t\t\t} else\n\t\t\t\tstr = tmp;\n\t\t\tpp_push(pc->opcode, str, CAN_FREE);\n\t\t\tbreak;\n\n\t\tcase Op_indirect_func_call:\n\t\tcase Op_func_call:\n\t\t{\n\t\t\tchar *fname = pc->func_name;\n\t\t\tchar *pre;\n \t\t\tint pcount;\n\n\t\t\tif (pc->opcode == Op_indirect_func_call)\n\t\t\t\tpre = \"@\";\n\t\t\telse\n\t\t\t\tpre = \"\";\n\t\t\tpcount = (pc + 1)->expr_count;\n\t\t\tif (pcount > 0) {\n\t\t\t\ttmp = pp_list(pcount, \"()\", \", \");\n\t\t\t\tstr = pp_group3(pre, fname, tmp);\n\t\t\t\tefree(tmp);\n\t\t\t} else\n\t\t\t\tstr = pp_group3(pre, fname, \"()\");\n\t\t\tif (pc->opcode == Op_indirect_func_call) {\n\t\t\t\tt1 = pp_pop();\t/* indirect var */\n\t\t\t\tpp_free(t1);\n\t\t\t}\n\t\t\tpp_push(pc->opcode, str, CAN_FREE);\n\t\t}\n\t\t\tbreak;\n\n\t\tcase Op_K_continue:\n\t\tcase Op_K_break:\n\t\tcase Op_K_nextfile:\n\t\tcase Op_K_next:\n\t\t\tfprintf(prof_fp, \"%s\", op2str(pc->opcode));\n\t\t\tpc = end_line(pc);\n\t\t\tbreak;\n\n\t\tcase Op_K_return:\n\t\tcase Op_K_exit:\n\t\t\tt1 = pp_pop();\n\t\t\tif (is_binary(t1->type))\n\t\t\t\tpp_parenthesize(t1);\n\t\t\tif (pc->source_line > 0) {\t/* don't print implicit 'return' at end of function */\n\t\t\t\tfprintf(prof_fp, \"%s %s\", op2str(pc->opcode), t1->pp_str);\n\t\t\t\tpc = end_line(pc);\n\t\t\t}\n\t\t\tpp_free(t1);\n\t\t\tbreak;\n\n\t\tcase Op_pop:\n\t\t\tt1 = pp_pop();\n\t\t\tfprintf(prof_fp, \"%s\", t1->pp_str);\n\t\t\tif ((flags & IN_FOR_HEADER) == 0)\n\t\t\t\tpc = end_line(pc);\n\t\t\tpp_free(t1);\n\t\t\tbreak;\n\n\t\tcase Op_line_range:\n\t\t\tip1 = pc + 1;\n\t\t\tpprint(pc->nexti, ip1->condpair_left, NO_PPRINT_FLAGS);\n\t\t\tpprint(ip1->condpair_left->nexti, ip1->condpair_right, NO_PPRINT_FLAGS);\n\t\t\tt2 = pp_pop();\n\t\t\tt1 = pp_pop();\n\t\t\tstr = pp_group3(t1->pp_str, \", \", t2->pp_str);\n\t\t\tpp_free(t1);\n\t\t\tpp_free(t2);\n\t\t\tpp_push(Op_line_range, str, CAN_FREE);\n\t\t\tpc = ip1->condpair_right;\n\t\t\tbreak;\n\n\t\tcase Op_K_while:\n\t\t\tip1 = pc + 1;\n\t\t\tindent(ip1->while_body->exec_count);\n\t\t\tfprintf(prof_fp, \"%s (\", op2str(pc->opcode));\n\t\t\tpprint(pc->nexti, ip1->while_body, NO_PPRINT_FLAGS);\n\t\t\tt1 = pp_pop();\n\t\t\tfprintf(prof_fp, \"%s) {\", t1->pp_str);\n\t\t\tpp_free(t1);\n\t\t\tip1->while_body = end_line(ip1->while_body);\n\t\t\tindent_in();\n\t\t\tpprint(ip1->while_body->nexti, pc->target_break, NO_PPRINT_FLAGS);\n\t\t\tindent_out();\n\t\t\tindent(SPACEOVER);\n\t\t\tfprintf(prof_fp, \"}\");\n\t\t\tpc = end_line(pc->target_break);\n\t\t\tbreak;\n\n\t\tcase Op_K_do:\n\t\t\tip1 = pc + 1;\n\t\t\tindent(pc->nexti->exec_count);\n\t\t\tfprintf(prof_fp, \"%s {\", op2str(pc->opcode));\n\t\t\tend_line(pc->nexti);\n\t\t\tskip_comment = true;\n\t\t\tindent_in();\n\t\t\tpprint(pc->nexti->nexti, ip1->doloop_cond, NO_PPRINT_FLAGS);\n\t\t\tindent_out();\n\t\t\tpprint(ip1->doloop_cond, pc->target_break, NO_PPRINT_FLAGS);\n\t\t\tindent(SPACEOVER);\n\t\t\tt1 = pp_pop();\n\t\t\tfprintf(prof_fp, \"} %s (%s)\", op2str(Op_K_while), t1->pp_str);\n\t\t\tpp_free(t1);\n\t\t\tend_line(pc->target_break);\n\t\t\tskip_comment = true;\n\t\t\tpc = pc->target_break;\n\t\t\tbreak;\n\n\t\tcase Op_K_for:\n\t\t\tip1 = pc + 1;\n\t\t\tindent(ip1->forloop_body->exec_count);\n\t\t\tfprintf(prof_fp, \"%s (\", op2str(pc->opcode));\n\n\t\t\t/* If empty for looop header, print it a little more nicely. */\n\t\t\tif (   pc->nexti->opcode == Op_no_op\n\t\t\t    && ip1->forloop_cond == pc->nexti\n\t\t\t    && pc->target_continue->opcode == Op_jmp) {\n\t\t\t\tfprintf(prof_fp, \";;\");\n\t\t\t} else {\n\t\t\t\tpprint(pc->nexti, ip1->forloop_cond, IN_FOR_HEADER);\n\t\t\t\tfprintf(prof_fp, \"; \");\n\n\t\t\t\tif (ip1->forloop_cond->opcode == Op_no_op &&\n\t\t\t\t\t\tip1->forloop_cond->nexti == ip1->forloop_body)\n\t\t\t\t\tfprintf(prof_fp, \"; \");\n\t\t\t\telse {\n\t\t\t\t\tpprint(ip1->forloop_cond, ip1->forloop_body, IN_FOR_HEADER);\n\t\t\t\t\tt1 = pp_pop();\n\t\t\t\t\tfprintf(prof_fp, \"%s; \", t1->pp_str);\n\t\t\t\t\tpp_free(t1);\n\t\t\t\t}\n\n\t\t\t\tpprint(pc->target_continue, pc->target_break, IN_FOR_HEADER);\n\t\t\t}\n\t\t\tfprintf(prof_fp, \") {\");\n\t\t\tend_line(ip1->forloop_body);\n\t\t\tskip_comment = true;\n\t\t\tindent_in();\n\t\t\tpprint(ip1->forloop_body->nexti, pc->target_continue, NO_PPRINT_FLAGS);\n\t\t\tindent_out();\n\t\t\tindent(SPACEOVER);\n\t\t\tfprintf(prof_fp, \"}\");\n\t\t\tend_line(pc->target_break);\n\t\t\tskip_comment = true;\n\t\t\tpc = pc->target_break;\n\t\t\tbreak;\n\n\t\tcase Op_K_arrayfor:\n\t\t{\n\t\t\tchar *array;\n\t\t\tconst char *item;\n\n\t\t\tip1 = pc + 1;\n\t\t\tt1 = pp_pop();\n\t\t\tarray = t1->pp_str;\n\t\t\tm = ip1->forloop_cond->array_var;\n\t\t\tif (m->type == Node_param_list)\n\t\t\t\titem = func_params[m->param_cnt].param;\n\t\t\telse\n\t\t\t\titem = m->vname;\n\t\t\tindent(ip1->forloop_body->exec_count);\n\t\t\tfprintf(prof_fp, \"%s (%s%s%s) {\", op2str(Op_K_arrayfor),\n\t\t\t\t\t\titem, op2str(Op_in_array), array);\n\t\t\tend_line(ip1->forloop_body);\n\t\t\tskip_comment = true;\n\t\t\tindent_in();\n\t\t\tpp_free(t1);\n\t\t\tpprint(ip1->forloop_body->nexti, pc->target_break, NO_PPRINT_FLAGS);\n\t\t\tindent_out();\n\t\t\tindent(SPACEOVER);\n\t\t\tfprintf(prof_fp, \"}\");\n\t\t\tend_line(pc->target_break);\n\t\t\tskip_comment = true;\n\t\t\tpc = pc->target_break;\n\t\t}\n\t\t\tbreak;\n\n\t\tcase Op_K_switch:\n\t\t\tip1 = pc + 1;\n\t\t\tfprintf(prof_fp, \"%s (\", op2str(pc->opcode));\n\t\t\tpprint(pc->nexti, ip1->switch_start, NO_PPRINT_FLAGS);\n\t\t\tt1 = pp_pop();\n\t\t\tfprintf(prof_fp, \"%s) {\\n\", t1->pp_str);\n\t\t\tpp_free(t1);\n\t\t\tpprint(ip1->switch_start, ip1->switch_end, NO_PPRINT_FLAGS);\n\t\t\tindent(SPACEOVER);\n\t\t\tfprintf(prof_fp, \"}\\n\");\n\t\t\tpc = pc->target_break;\n\t\t\tbreak;\n\n\t\tcase Op_K_case:\n\t\tcase Op_K_default:\n\t\t\tindent(pc->stmt_start->exec_count);\n\t\t\tif (pc->opcode == Op_K_case) {\n\t\t\t\tt1 = pp_pop();\n\t\t\t\tfprintf(prof_fp, \"%s %s:\", op2str(pc->opcode), t1->pp_str);\n\t\t\t\tpc = end_line(pc);\n\t\t\t\tpp_free(t1);\n\t\t\t} else {\n\t\t\t\tfprintf(prof_fp, \"%s:\", op2str(pc->opcode));\n\t\t\t\tpc = end_line(pc);\n\t\t\t}\n\t\t\tindent_in();\n\t\t\tpprint(pc->stmt_start->nexti, pc->stmt_end->nexti, NO_PPRINT_FLAGS);\n\t\t\tindent_out();\n\t\t\tbreak;\n\n\t\tcase Op_K_if:\n\t\t\tfprintf(prof_fp, \"%s (\", op2str(pc->opcode));\n\t\t\tpprint(pc->nexti, pc->branch_if, NO_PPRINT_FLAGS);\n\t\t\tt1 = pp_pop();\n\t\t\tfprintf(prof_fp, \"%s) {\", t1->pp_str);\n\t\t\tpp_free(t1);\n\n\t\t\tip1 = pc->branch_if;\n\t\t\tif (ip1->exec_count > 0)\n\t\t\t\tfprintf(prof_fp, \" # %ld\", ip1->exec_count);\n\t\t\tip1 = end_line(ip1);\n\t\t\tindent_in();\n\t\t\tpprint(ip1->nexti, pc->branch_else, NO_PPRINT_FLAGS);\n\t\t\tindent_out();\n\t\t\tpc = pc->branch_else;\n\t\t\tif (pc->nexti->opcode == Op_no_op) {\t/* no following else */\n\t\t\t\tindent(SPACEOVER);\n\t\t\t\tfprintf(prof_fp, \"}\");\n\t\t\t\tif (pc->nexti->nexti->opcode != Op_comment\n\t\t\t\t    || pc->nexti->nexti->memory->comment_type == FULL_COMMENT)\n\t\t\t\t\tfprintf(prof_fp, \"\\n\");\n\t\t\t\t/* else\n\t\t\t\t \tIt will be printed at the top. */\n\t\t\t}\n\t\t\t/*\n\t\t\t * See next case; turn off the flag so that the\n\t\t\t * following else is correctly indented.\n\t\t\t */\n\t\t\tflags &= ~IN_ELSE_IF;\n\t\t\tbreak;\n\n\t\tcase Op_K_else:\n\t\t\t/*\n\t\t\t * If possible, chain else-if's together on the\n\t\t\t * same line.\n\t\t\t *\n\t\t\t * See awkgram.y:mk_condition to understand\n\t\t\t * what is being checked here.\n\t\t\t *\n\t\t\t * Op_exec_count follows Op_K_else, check the\n\t\t\t * opcode of the following instruction.\n\t\t\t * Additionally, check that the subsequent if\n\t\t\t * terminates where this else does; in that case\n\t\t\t * it's ok to compact the if to follow the else.\n\t\t\t */\n\n\t\t\tfprintf(prof_fp, \"} %s \", op2str(pc->opcode));\n\t\t\tif (pc->nexti->nexti->opcode == Op_K_if\n\t\t\t    && pc->branch_end == pc->nexti->nexti->branch_else->lasti) {\n\t\t\t\tpprint(pc->nexti, pc->branch_end, IN_ELSE_IF);\n\t\t\t} else {\n\t\t\t\tfprintf(prof_fp, \"{\");\n\t\t\t\tend_line(pc);\n\t\t\t\tskip_comment = true;\n\t\t\t\tindent_in();\n\t\t\t\tpprint(pc->nexti, pc->branch_end, NO_PPRINT_FLAGS);\n\t\t\t\tindent_out();\n\t\t\t\tindent(SPACEOVER);\n\t\t\t\tfprintf(prof_fp, \"}\");\n\t\t\t\tend_line(pc->branch_end);\n\t\t\t\tskip_comment = true;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Don't do end_line() here, we get multiple blank lines after\n\t\t\t * the final else in a chain of else-ifs since they all point\n\t\t\t * to the same branch_end.\n\t\t\t */\n\t\t\tpc = pc->branch_end;\n\t\t\tbreak;\n\n\t\tcase Op_cond_exp:\n\t\t{\n\t\t\tNODE *f, *t, *cond;\n\t\t\tsize_t len;\n\n\t\t\tpprint(pc->nexti, pc->branch_if, NO_PPRINT_FLAGS);\n\t\t\tip1 = pc->branch_if;\n\t\t\tpprint(ip1->nexti, pc->branch_else, NO_PPRINT_FLAGS);\n\t\t\tip1 = pc->branch_else->nexti;\n\n\t\t\tpc = ip1->nexti;\n\t\t\tassert(pc->opcode == Op_cond_exp);\n\t\t\tpprint(pc->nexti, pc->branch_end, NO_PPRINT_FLAGS);\n\n\t\t\tf = pp_pop();\n\t\t\tt = pp_pop();\n\t\t\tcond = pp_pop();\n\n\t\t\tlen =  f->pp_len + t->pp_len + cond->pp_len + 12;\n\t\t\temalloc(str, char *, len, \"pprint\");\n\t\t\tsprintf(str, \"%s ? %s : %s\", cond->pp_str, t->pp_str, f->pp_str);\n\n\t\t\tpp_free(cond);\n\t\t\tpp_free(t);\n\t\t\tpp_free(f);\n\t\t\tpp_push(Op_cond_exp, str, CAN_FREE);\n\t\t\tpc = pc->branch_end;\n\t\t}\n\t\t\tbreak;\n\n\t\tcase Op_exec_count:\n\t\t\tif (flags == NO_PPRINT_FLAGS)\n\t\t\t\tindent(pc->exec_count);\n\t\t\tbreak;\n\n\t\tcase Op_comment:\n\t\t\tprint_comment(pc, 0);\n\t\t\tbreak;\n\n\t\tcase Op_list:\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tcant_happen();\n\t\t}\n\n\t\tif (pc == endp)\n\t\t\tbreak;\n\t}\n}",
      "lines": 851,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "end_line": {
      "start_point": [
        1050,
        0
      ],
      "end_point": [
        1065,
        1
      ],
      "content": "INSTRUCTION *\nend_line(INSTRUCTION *ip)\n{\n\tINSTRUCTION *ret = ip;\n\n\tif (ip->nexti->opcode == Op_comment\n\t    && ip->nexti->memory->comment_type == EOL_COMMENT) {\n\t\tfprintf(prof_fp, \"\\t\");\n\t\tprint_comment(ip->nexti, -1);\n\t\tret = ip->nexti;\n\t}\n\telse\n\t\tfprintf(prof_fp, \"\\n\");\n\n\treturn ret;\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "INSTRUCTION",
        "*\nend_line(INSTRUCTION *ip)",
        "*"
      ]
    },
    "pp_string_fp": {
      "start_point": [
        1074,
        0
      ],
      "end_point": [
        1093,
        1
      ],
      "content": "void\npp_string_fp(Func_print print_func, FILE *fp, const char *in_str,\n\t\tsize_t len, int delim, bool breaklines)\n{\n\tchar *s = pp_string(in_str, len, delim);\n\tint count;\n\tsize_t slen;\n\tconst char *str = (const char *) s;\n#define BREAKPOINT\t70 /* arbitrary */\n\n\tslen = strlen(str);\n\tfor (count = 0; slen > 0; slen--, str++) {\n\t\tprint_func(fp, \"%c\", *str);\n\t\tif (++count >= BREAKPOINT && breaklines) {\n\t\t\tprint_func(fp, \"%c\\n%c\", delim, delim);\n\t\t\tcount = 0;\n\t\t}\n\t}\n\tefree(s);\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "just_dump": {
      "start_point": [
        1098,
        0
      ],
      "end_point": [
        1108,
        1
      ],
      "content": "static void\njust_dump(int signum)\n{\n\textern INSTRUCTION *code_block;\n\n\tdump_prog(code_block);\n\tdump_funcs();\n\tdump_fcall_stack(prof_fp);\n\tfflush(prof_fp);\n\tsignal(signum, just_dump);\t/* for OLD Unix systems ... */\n}",
      "lines": 11,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "dump_and_exit": {
      "start_point": [
        1112,
        0
      ],
      "end_point": [
        1117,
        1
      ],
      "content": "static void\ndump_and_exit(int signum)\n{\n\tjust_dump(signum);\n\tfinal_exit(EXIT_FAILURE);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "print_lib_list": {
      "start_point": [
        1121,
        0
      ],
      "end_point": [
        1138,
        1
      ],
      "content": "static void\nprint_lib_list(FILE *prof_fp)\n{\n\tSRCFILE *s;\n\tstatic bool printed_header = false;\n\n\tfor (s = srcfiles->next; s != srcfiles; s = s->next) {\n\t\tif (s->stype == SRC_EXTLIB) {\n\t\t\tif (! printed_header) {\n\t\t\t\tprinted_header = true;\n\t\t\t\tfprintf(prof_fp, _(\"\\t# Loaded extensions (-l and/or @load)\\n\\n\"));\n\t\t\t}\n\t\t\tfprintf(prof_fp, \"\\t@load \\\"%s\\\"\\n\", s->src);\n\t\t}\n\t}\n\tif (printed_header)\t/* we found some */\n\t\tfprintf(prof_fp, \"\\n\");\n}",
      "lines": 18,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "print_comment": {
      "start_point": [
        1142,
        0
      ],
      "end_point": [
        1163,
        1
      ],
      "content": "static void\nprint_comment(INSTRUCTION* pc, long in)\n{\n\tchar *text;\n\tsize_t count;\n\tbool after_newline = false;\n\n\tcount = pc->memory->stlen;\n\ttext = pc->memory->stptr;\n\n\tif (in >= 0)\n\t\tindent(in);    /* is this correct? Where should comments go?  */\n\tfor (; count > 0; count--, text++) {\n\t\tif (after_newline) {\n\t\t\tindent(in);\n\t\t\tafter_newline = false;\n\t\t}\n\t\tputc(*text, prof_fp);\n\t\tif (*text == '\\n')\n\t\t\tafter_newline = true;\n\t}\n}",
      "lines": 22,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "dump_prog": {
      "start_point": [
        1172,
        0
      ],
      "end_point": [
        1183,
        1
      ],
      "content": "void\ndump_prog(INSTRUCTION *code)\n{\n\ttime_t now;\n\n\t(void) time(& now);\n\t/* \\n on purpose, with \\n in ctime() output */\n\tif (do_profile)\n\t\tfprintf(prof_fp, _(\"\\t# gawk profile, created %s\\n\"), ctime(& now));\n\tprint_lib_list(prof_fp);\n\tpprint(code, NULL, NO_PPRINT_FLAGS);\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "prec_level": {
      "start_point": [
        1187,
        0
      ],
      "end_point": [
        1282,
        1
      ],
      "content": "static int\nprec_level(int type)\n{\n\tswitch (type) {\n\tcase Op_push_lhs:\n\tcase Op_push_param:\n\tcase Op_push_array:\n\tcase Op_push:\n\tcase Op_push_i:\n\tcase Op_push_re:\n\tcase Op_match_rec:\n\tcase Op_subscript:\n\tcase Op_subscript_lhs:\n\tcase Op_func_call:\n\tcase Op_K_delete_loop:\n\tcase Op_builtin:\n\t\treturn 16;\n\n\tcase Op_field_spec:\n\tcase Op_field_spec_lhs:\n\t\treturn 15;\n\n\tcase Op_preincrement:\n\tcase Op_predecrement:\n\tcase Op_postincrement:\n\tcase Op_postdecrement:\n\t\treturn 14;\n\n\tcase Op_exp:\n\tcase Op_exp_i:\n\t\treturn 13;\n\n\tcase Op_unary_minus:\n\tcase Op_unary_plus:\n\tcase Op_not:\n\t\treturn 12;\n\n\tcase Op_times:\n\tcase Op_times_i:\n\tcase Op_quotient:\n\tcase Op_quotient_i:\n\tcase Op_mod:\n\tcase Op_mod_i:\n\t\treturn 11;\n\n\tcase Op_plus:\n\tcase Op_plus_i:\n\tcase Op_minus:\n\tcase Op_minus_i:\n\t\treturn 10;\n\n\tcase Op_concat:\n\tcase Op_assign_concat:\n\t\treturn 9;\n\n\tcase Op_equal:\n\tcase Op_notequal:\n\tcase Op_greater:\n\tcase Op_less:\n\tcase Op_leq:\n\tcase Op_geq:\n\t\treturn 8;\n\n\tcase Op_match:\n\tcase Op_nomatch:\n\t\treturn 7;\n\n\tcase Op_K_getline:\n\tcase Op_K_getline_redir:\n\t\treturn 6;\n\n\tcase Op_in_array:\n\t\treturn 5;\n\n\tcase Op_and:\n\t\treturn 4;\n\n\tcase Op_or:\n\t\treturn 3;\n\n\tcase Op_cond_exp:\n\t\treturn 2;\n\n\tcase Op_assign:\n\tcase Op_assign_times:\n\tcase Op_assign_quotient:\n\tcase Op_assign_mod:\n\tcase Op_assign_plus:\n\tcase Op_assign_minus:\n\tcase Op_assign_exp:\n\t\treturn 1;\n\n\tdefault:\n\t\treturn 0;\n\t}\n}",
      "lines": 96,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "is_scalar": {
      "start_point": [
        1286,
        0
      ],
      "end_point": [
        1314,
        1
      ],
      "content": "static bool\nis_scalar(int type)\n{\n\tswitch (type) {\n\tcase Op_push_lhs:\n\tcase Op_push_param:\n\tcase Op_push_array:\n\tcase Op_push:\n\tcase Op_push_i:\n\tcase Op_push_re:\n\tcase Op_subscript:\n\tcase Op_subscript_lhs:\n\tcase Op_func_call:\n\tcase Op_builtin:\n\tcase Op_field_spec:\n\tcase Op_field_spec_lhs:\n\tcase Op_preincrement:\n\tcase Op_predecrement:\n\tcase Op_postincrement:\n\tcase Op_postdecrement:\n\tcase Op_unary_minus:\n\tcase Op_unary_plus:\n\tcase Op_not:\n\t\treturn true;\n\n\tdefault:\n\t\treturn false;\n\t}\n}",
      "lines": 29,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "is_binary": {
      "start_point": [
        1318,
        0
      ],
      "end_point": [
        1362,
        1
      ],
      "content": "static bool\nis_binary(int type)\n{\n\tswitch (type) {\n\tcase Op_geq:\n\tcase Op_leq:\n\tcase Op_greater:\n\tcase Op_less:\n\tcase Op_notequal:\n\tcase Op_equal:\n\tcase Op_exp:\n\tcase Op_times:\n\tcase Op_quotient:\n\tcase Op_mod:\n\tcase Op_plus:\n\tcase Op_minus:\n\tcase Op_exp_i:\n\tcase Op_times_i:\n\tcase Op_quotient_i:\n\tcase Op_mod_i:\n\tcase Op_plus_i:\n\tcase Op_minus_i:\n\tcase Op_concat:\n\tcase Op_assign_concat:\n\tcase Op_match:\n\tcase Op_nomatch:\n\tcase Op_assign:\n\tcase Op_assign_times:\n\tcase Op_assign_quotient:\n\tcase Op_assign_mod:\n\tcase Op_assign_plus:\n\tcase Op_assign_minus:\n\tcase Op_assign_exp:\n\tcase Op_cond_exp:\n\tcase Op_and:\n\tcase Op_or:\n\tcase Op_in_array:\n\tcase Op_K_getline_redir:\t/* sometimes */\n\tcase Op_K_getline:\n\t\treturn true;\n\n\tdefault:\n\t\treturn false;\n\t}\n}",
      "lines": 45,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "pp_parenthesize": {
      "start_point": [
        1366,
        0
      ],
      "end_point": [
        1385,
        1
      ],
      "content": "static void\npp_parenthesize(NODE *sp)\n{\n\tchar *p = sp->pp_str;\n\tsize_t len = sp->pp_len;\n\n\tif (p[0] == '(')\t// already parenthesized\n\t\treturn;\n\n\temalloc(p, char *, len + 3, \"pp_parenthesize\");\n\t*p = '(';\n\tmemcpy(p + 1, sp->pp_str, len);\n\tp[len + 1] = ')';\n\tp[len + 2] = '\\0';\n\tif ((sp->flags & CAN_FREE) != 0)\n\t\tefree(sp->pp_str);\n\tsp->pp_str = p;\n\tsp->pp_len += 2;\n\tsp->flags |= CAN_FREE;\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "parenthesize": {
      "start_point": [
        1389,
        0
      ],
      "end_point": [
        1400,
        1
      ],
      "content": "static void\nparenthesize(int type, NODE *left, NODE *right)\n{\n\tint rprec = prec_level(right->type);\n\tint lprec = prec_level(left->type);\n\tint prec = prec_level(type);\n\n\tif (lprec < prec)\n\t\tpp_parenthesize(left);\n\tif (rprec < prec)\n\t\tpp_parenthesize(right);\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "pp_string": {
      "start_point": [
        1404,
        0
      ],
      "end_point": [
        1408,
        1
      ],
      "content": "char *\npp_string(const char *in_str, size_t len, int delim)\n{\n\treturn pp_string_or_typed_regex(in_str, len, delim, false);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\npp_string(const char *in_str, size_t len, int delim)",
        "*"
      ]
    },
    "pp_typed_regex": {
      "start_point": [
        1412,
        0
      ],
      "end_point": [
        1416,
        1
      ],
      "content": "static char *\npp_typed_regex(const char *in_str, size_t len, int delim)\n{\n\treturn pp_string_or_typed_regex(in_str, len, delim, true);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "char",
        "*\npp_typed_regex(const char *in_str, size_t len, int delim)",
        "*"
      ]
    },
    "pp_string_or_typed_regex": {
      "start_point": [
        1420,
        0
      ],
      "end_point": [
        1499,
        1
      ],
      "content": "char *\npp_string_or_typed_regex(const char *in_str, size_t len, int delim, bool typed_regex)\n{\n\tstatic char str_escapes[] = \"\\a\\b\\f\\n\\r\\t\\v\\\\\";\n\tstatic char str_printables[] = \"abfnrtv\\\\\";\n\tstatic char re_escapes[] = \"\\a\\b\\f\\n\\r\\t\\v\";\n\tstatic char re_printables[] = \"abfnrtv\";\n\tchar *escapes;\n\tchar *printables;\n\tchar *cp;\n\tint i;\n\tconst unsigned char *str = (const unsigned char *) in_str;\n\tsize_t ofre, osiz;\n\tchar *obuf, *obufout;\n\n\tassert(delim == '\"' || delim == '/');\n\n\tif (delim == '/') {\n\t\tescapes = re_escapes;\n\t\tprintables = re_printables;\n\t} else {\n\t\tescapes = str_escapes;\n\t\tprintables = str_printables;\n\t}\n\n/* make space for something l big in the buffer */\n#define chksize(l)  if ((l) > ofre) { \\\n\t\tlong olen = obufout - obuf; \\\n\t\terealloc(obuf, char *, osiz * 2, \"pp_string\"); \\\n\t\tobufout = obuf + olen; \\\n\t\tofre += osiz; \\\n\t\tosiz *= 2; \\\n\t} ofre -= (l)\n\n\t/* initial size; 3 for delim + terminating null, 1 for @ */\n\tosiz = len + 3 + 1 + (typed_regex == true);\n\temalloc(obuf, char *, osiz, \"pp_string\");\n\tobufout = obuf;\n\tofre = osiz - 1;\n\n\tif (typed_regex)\n\t\t*obufout++ = '@';\n\n\t*obufout++ = delim;\n\tfor (; len > 0; len--, str++) {\n\t\tchksize(2);\t\t/* make space for 2 chars */\n\t\tif (delim != '/' && *str == delim) {\n\t\t\t*obufout++ = '\\\\';\n\t\t\t*obufout++ = delim;\n\t\t} else if (*str == '\\0') {\n\t\t\t*obufout++ = '\\\\';\n\t\t\t*obufout++ = '0';\n\t\t\tchksize(2);\t/* need 2 more chars for this case */\n\t\t\t*obufout++ = '0';\n\t\t\t*obufout++ = '0';\n\t\t} else if ((cp = strchr(escapes, *str)) != NULL) {\n\t\t\ti = cp - escapes;\n\t\t\t*obufout++ = '\\\\';\n\t\t\t*obufout++ = printables[i];\n\t\t/* NB: Deliberate use of lower-case versions. */\n\t\t} else if (isascii(*str) && isprint(*str)) {\n\t\t\t*obufout++ = *str;\n\t\t\tofre += 1;\t/* used 1 less than expected */\n\t\t} else {\n\t\t\tsize_t len;\n\n\t\t\tchksize(8);\t\t/* total available space is 10 */\n\n\t\t\tsprintf(obufout, \"\\\\%03o\", *str & 0xff);\n\t\t\tlen = strlen(obufout);\n\t\t\tofre += (10 - len);\t /* adjust free space count */\n\t\t\tobufout += len;\n\t\t}\n\t}\n\tchksize(2);\n\t*obufout++ = delim;\n\t*obufout = '\\0';\n\treturn obuf;\n#undef chksize\n}",
      "lines": 80,
      "depth": 15,
      "decorators": [
        "char",
        "*\npp_string_or_typed_regex(const char *in_str, size_t len, int delim, bool typed_regex)",
        "*"
      ]
    },
    "pp_number": {
      "start_point": [
        1503,
        0
      ],
      "end_point": [
        1512,
        1
      ],
      "content": "char *\npp_number(NODE *n)\n{\n\tchar *str;\n\n\tassert((n->flags & NUMCONSTSTR) != 0);\n\temalloc(str, char *, n->stlen + 1, \"pp_number\");\n\tstrcpy(str, n->stptr);\n\treturn str;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "char",
        "*\npp_number(NODE *n)",
        "*"
      ]
    },
    "pp_node": {
      "start_point": [
        1516,
        0
      ],
      "end_point": [
        1522,
        1
      ],
      "content": "char *\npp_node(NODE *n)\n{\n\tif ((n->flags & NUMBER) != 0)\n\t\treturn pp_number(n);\n\treturn pp_string(n->stptr, n->stlen, '\"');\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "char",
        "*\npp_node(NODE *n)",
        "*"
      ]
    },
    "pp_list": {
      "start_point": [
        1529,
        0
      ],
      "end_point": [
        1585,
        1
      ],
      "content": "static char *\npp_list(int nargs, const char *paren, const char *delim)\n{\n\tNODE *r;\n \tchar *str, *s;\n\tsize_t len;\n\tsize_t delimlen;\n\tint i;\n\n\tif (pp_args == NULL) {\n\t\tnpp_args = nargs;\n\t\temalloc(pp_args, NODE **, (nargs + 2) * sizeof(NODE *), \"pp_list\");\n\t} else if (nargs > npp_args) {\n\t\tnpp_args = nargs;\n\t\terealloc(pp_args, NODE **, (nargs + 2) * sizeof(NODE *), \"pp_list\");\n\t}\n\n\tdelimlen = strlen(delim);\n\tif (nargs == 0)\n\t\tlen = 2;\n\telse {\n\t\tlen = -delimlen;\n\t\tfor (i = 1; i <= nargs; i++) {\n\t\t\tr = pp_args[i] = pp_pop();\n\t\t\tlen += r->pp_len + delimlen;\n\t\t}\n\t\tif (paren != NULL) {\n\t\t\tassert(strlen(paren) == 2);\n\t\t\tlen += 2;\n\t\t}\n\t}\n\n\temalloc(str, char *, len + 1, \"pp_list\");\n\ts = str;\n\tif (paren != NULL)\n\t\t*s++ = paren[0];\n\tif (nargs > 0) {\n\t\tr = pp_args[nargs];\n\t\tmemcpy(s, r->pp_str, r->pp_len);\n\t\ts += r->pp_len;\n\t\tpp_free(r);\n\t\tfor (i = nargs - 1; i > 0; i--) {\n\t\t\tif (delimlen > 0) {\n\t\t\t\tmemcpy(s, delim, delimlen);\n\t\t\t\ts += delimlen;\n\t\t\t}\n\t\t\tr = pp_args[i];\n\t\t\tmemcpy(s, r->pp_str, r->pp_len);\n\t\t\ts += r->pp_len;\n\t\t\tpp_free(r);\n\t\t}\n\t}\n\tif (paren != NULL)\n\t\t*s++ = paren[1];\n\t*s = '\\0';\n\treturn str;\n}",
      "lines": 57,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "char",
        "*\npp_list(int nargs, const char *paren, const char *delim)",
        "*"
      ]
    },
    "is_unary_minus": {
      "start_point": [
        1589,
        0
      ],
      "end_point": [
        1593,
        1
      ],
      "content": "static bool\nis_unary_minus(const char *str)\n{\n\treturn str[0] == '-' && str[1] != '-';\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "pp_concat": {
      "start_point": [
        1597,
        0
      ],
      "end_point": [
        1684,
        1
      ],
      "content": "static char *\npp_concat(int nargs)\n{\n\tNODE *r;\n \tchar *str, *s;\n\tsize_t len;\n\tstatic const size_t delimlen = 1;\t/* \" \" */\n\tint i;\n\tint pl_l, pl_r;\n\n\tif (pp_args == NULL) {\n\t\tnpp_args = nargs;\n\t\temalloc(pp_args, NODE **, (nargs + 2) * sizeof(NODE *), \"pp_concat\");\n\t} else if (nargs > npp_args) {\n\t\tnpp_args = nargs;\n\t\terealloc(pp_args, NODE **, (nargs + 2) * sizeof(NODE *), \"pp_concat\");\n\t}\n\n\t/*\n\t * items are on the stack in reverse order that they\n\t * will be printed to pop them off backwards.\n\t */\n\n\tlen = -delimlen;\n\tfor (i = nargs; i >= 1; i--) {\n\t\tr = pp_args[i] = pp_pop();\n\t\tlen += r->pp_len + delimlen + 2;\n\t}\n\n\temalloc(str, char *, len + 1, \"pp_concat\");\n\ts = str;\n\n\t/* now copy in */\n\tfor (i = 1; i < nargs; i++) {\n\t\tr = pp_args[i];\n\n\t\tif (r->pp_str[0] != '(') {\n\t\t\tpl_l = prec_level(pp_args[i]->type);\n\t\t\tpl_r = prec_level(pp_args[i+1]->type);\n\n\t\t\tif (i >= 2 && is_unary_minus(r->pp_str)) {\n\t\t\t\t*s++ = '(';\n\t\t\t\tmemcpy(s, r->pp_str, r->pp_len);\n\t\t\t\ts += r->pp_len;\n\t\t\t\t*s++ = ')';\n\t\t\t} else if (is_scalar(pp_args[i]->type) && is_scalar(pp_args[i+1]->type)) {\n\t\t\t\tmemcpy(s, r->pp_str, r->pp_len);\n\t\t\t\ts += r->pp_len;\n\t\t\t} else if (pl_l <= pl_r || is_scalar(pp_args[i+1]->type)) {\n\t\t\t\t*s++ = '(';\n\t\t\t\tmemcpy(s, r->pp_str, r->pp_len);\n\t\t\t\ts += r->pp_len;\n\t\t\t\t*s++ = ')';\n\t\t\t} else {\n\t\t\t\tmemcpy(s, r->pp_str, r->pp_len);\n\t\t\t\ts += r->pp_len;\n\t\t\t}\n\t\t} else {\n\t\t\tmemcpy(s, r->pp_str, r->pp_len);\n\t\t\ts += r->pp_len;\n\t\t}\n\t\tpp_free(r);\n\n\t\tif (i < nargs) {\n\t\t\t*s++ = ' ';\n\t\t}\n\t}\n\n\tpl_l = prec_level(pp_args[nargs-1]->type);\n\tpl_r = prec_level(pp_args[nargs]->type);\n\tr = pp_args[nargs];\n\tif (r->pp_str[0] == '(') {\n\t\tmemcpy(s, r->pp_str, r->pp_len);\n\t\ts += r->pp_len;\n\t} else if (is_unary_minus(r->pp_str) || ((pl_l >= pl_r && ! is_scalar(pp_args[nargs]->type)))) {\n\t\t*s++ = '(';\n\t\tmemcpy(s, r->pp_str, r->pp_len);\n\t\ts += r->pp_len;\n\t\t*s++ = ')';\n\t} else {\n\t\tmemcpy(s, r->pp_str, r->pp_len);\n\t\ts += r->pp_len;\n\t}\n\tpp_free(r);\n\n\t*s = '\\0';\n\treturn str;\n}",
      "lines": 88,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "char",
        "*\npp_concat(int nargs)",
        "*"
      ]
    },
    "pp_group3": {
      "start_point": [
        1688,
        0
      ],
      "end_point": [
        1714,
        1
      ],
      "content": "static char *\npp_group3(const char *s1, const char *s2, const char *s3)\n{\n\tsize_t len1, len2, len3, l;\n\tchar *str, *s;\n\n\tlen1 = strlen(s1);\n\tlen2 = strlen(s2);\n\tlen3 = strlen(s3);\n\tl = len1 + len2 + len3 + 1;\n\temalloc(str, char *, l, \"pp_group3\");\n\ts = str;\n\tif (len1 > 0) {\n\t\tmemcpy(s, s1, len1);\n\t\ts += len1;\n\t}\n\tif (len2 > 0) {\n\t\tmemcpy(s, s2, len2);\n\t\ts += len2;\n\t}\n\tif (len3 > 0) {\n\t\tmemcpy(s, s3, len3);\n\t\ts += len3;\n\t}\n\t*s = '\\0';\n\treturn str;\n}",
      "lines": 27,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "char",
        "*\npp_group3(const char *s1, const char *s2, const char *s3)",
        "*"
      ]
    },
    "pp_func": {
      "start_point": [
        1718,
        0
      ],
      "end_point": [
        1768,
        1
      ],
      "content": "int\npp_func(INSTRUCTION *pc, void *data ATTRIBUTE_UNUSED)\n{\n\tint j;\n\tstatic bool first = true;\n\tNODE *func;\n\tint pcount;\n\tINSTRUCTION *fp;\n\n\tif (first) {\n\t\tfirst = false;\n\t\tif (do_profile)\n\t\t\tfprintf(prof_fp, _(\"\\n\\t# Functions, listed alphabetically\\n\"));\n\t}\n\n\tfp = pc->nexti->nexti;\n\tfunc = pc->func_body;\n\tfprintf(prof_fp, \"\\n\");\n\n\t/* print any function comment */\n\tif (fp->opcode == Op_comment && fp->source_line == 0) {\n\t\tprint_comment(fp, -1);\t/* -1 ==> don't indent */\n\t\tfp = fp->nexti;\n\t}\n\n\tindent(pc->nexti->exec_count);\n\tfprintf(prof_fp, \"%s %s(\", op2str(Op_K_function), func->vname);\n\tpcount = func->param_cnt;\n\tfunc_params = func->fparms;\n\tfor (j = 0; j < pcount; j++) {\n\t\tfprintf(prof_fp, \"%s\", func_params[j].param);\n\t\tif (j < pcount - 1)\n\t\t\tfprintf(prof_fp, \", \");\n\t}\n\tif (fp->opcode == Op_comment\n\t\t&& fp->memory->comment_type == EOL_COMMENT) {\n\t\tfprintf(prof_fp, \")\");\n\t\tfp = end_line(fp);\n\t} else\n\t\tfprintf(prof_fp, \")\\n\");\n\tif (do_profile)\n\t\tindent(0);\n\tfprintf(prof_fp, \"{\\n\");\n\tindent_in();\n\tpprint(fp, NULL, NO_PPRINT_FLAGS);\t/* function body */\n\tindent_out();\n\tif (do_profile)\n\t\tindent(0);\n\tfprintf(prof_fp, \"}\\n\");\n\treturn 0;\n}",
      "lines": 51,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "redir2str": {
      "start_point": [
        1772,
        0
      ],
      "end_point": [
        1788,
        1
      ],
      "content": "const char *\nredir2str(int redirtype)\n{\n\tstatic const char *const redirtab[] = {\n\t\t\"\",\n\t\t\" > \",\t/* redirect_output */\n\t\t\" >> \",\t/* redirect_append */\n\t\t\" | \",\t/* redirect_pipe */\n\t\t\" | \",\t/* redirect_pipein */\n\t\t\" < \",\t/* redirect_input */\n\t\t\" |& \",\t/* redirect_twoway */\n\t};\n\n\tif (redirtype < 0 || redirtype > redirect_twoway)\n\t\tfatal(_(\"redir2str: unknown redirection type %d\"), redirtype);\n\treturn redirtab[redirtype];\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nredir2str(int redirtype)",
        "*"
      ]
    }
  },
  "gawk/gawk-4.2.1/protos.h": {},
  "gawk/gawk-4.2.1/re.c": {
    "make_regexp": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        249,
        1
      ],
      "content": "Regexp *\nmake_regexp(const char *s, size_t len, bool ignorecase, bool dfa, bool canfatal)\n{\n\tstatic char metas[] = \".*+(){}[]|?^$\\\\\";\n\tRegexp *rp;\n\tconst char *rerr;\n\tconst char *src = s;\n\tstatic char *buf = NULL;\n\tstatic size_t buflen;\n\tconst char *end = s + len;\n\tchar *dest;\n\tint c, c2;\n\tstatic bool first = true;\n\tstatic bool no_dfa = false;\n\tint i;\n\tstatic struct dfa* dfaregs[2] = { NULL, NULL };\n\n\t/*\n\t * The number of bytes in the current multibyte character.\n\t * It is 0, when the current character is a singlebyte character.\n\t */\n\tsize_t is_multibyte = 0;\n\tmbstate_t mbs;\n\n\tmemset(&mbs, 0, sizeof(mbstate_t)); /* Initialize.  */\n\n\tif (first) {\n\t\t/* for debugging and testing */\n\t\tno_dfa = (getenv(\"GAWK_NO_DFA\") != NULL);\n\t\t/* don't set first to false here, we do it below */\n\t}\n\n\t/* always check */\n\tcheck_bracket_exp((char *) s, len);\n\n\t/* Handle escaped characters first. */\n\n\t/*\n\t * Build a copy of the string (in buf) with the\n\t * escaped characters translated, and generate the regex\n\t * from that.\n\t */\n\tif (buf == NULL) {\n\t\temalloc(buf, char *, len + 1, \"make_regexp\");\n\t\tbuflen = len;\n\t} else if (len > buflen) {\n\t\terealloc(buf, char *, len + 1, \"make_regexp\");\n\t\tbuflen = len;\n\t}\n\tdest = buf;\n\n\twhile (src < end) {\n\t\tif (gawk_mb_cur_max > 1 && ! is_multibyte) {\n\t\t\t/* The previous byte is a singlebyte character, or last byte\n\t\t\t   of a multibyte character.  We check the next character.  */\n\t\t\tis_multibyte = mbrlen(src, end - src, &mbs);\n\t\t\tif (   is_multibyte == 1\n\t\t\t    || is_multibyte == (size_t) -1\n\t\t\t    || is_multibyte == (size_t) -2\n\t\t\t    || is_multibyte == 0) {\n\t\t\t\t/* We treat it as a single-byte character.  */\n\t\t\t\tis_multibyte = 0;\n\t\t\t}\n\t\t}\n\n\t\t/* We skip multibyte character, since it must not be a special\n\t\t   character.  */\n\t\tif ((gawk_mb_cur_max == 1 || ! is_multibyte) &&\n\t\t    (*src == '\\\\')) {\n\t\t\tc = *++src;\n\t\t\tswitch (c) {\n\t\t\tcase 'a':\n\t\t\tcase 'b':\n\t\t\tcase 'f':\n\t\t\tcase 'n':\n\t\t\tcase 'r':\n\t\t\tcase 't':\n\t\t\tcase 'v':\n\t\t\tcase 'x':\n\t\t\tcase '0':\n\t\t\tcase '1':\n\t\t\tcase '2':\n\t\t\tcase '3':\n\t\t\tcase '4':\n\t\t\tcase '5':\n\t\t\tcase '6':\n\t\t\tcase '7':\n\t\t\t\tc2 = parse_escape(&src);\n\t\t\t\tif (c2 < 0)\n\t\t\t\t\tcant_happen();\n\t\t\t\t/*\n\t\t\t\t * Unix awk treats octal (and hex?) chars\n\t\t\t\t * literally in re's, so escape regexp\n\t\t\t\t * metacharacters.\n\t\t\t\t */\n\t\t\t\tif (do_traditional\n\t\t\t\t    && ! do_posix\n\t\t\t\t    && (isdigit(c) || c == 'x')\n\t\t\t\t    && strchr(\"()|*+?.^$\\\\[]\", c2) != NULL)\n\t\t\t\t\t*dest++ = '\\\\';\n\t\t\t\t*dest++ = (char) c2;\n\t\t\t\tbreak;\n\t\t\tcase '8':\n\t\t\tcase '9':\t/* a\\9b not valid */\n\t\t\t\t*dest++ = c;\n\t\t\t\tsrc++;\n\t\t\t\tbreak;\n\t\t\tcase 'y':\t/* normally \\b */\n\t\t\t\t/* gnu regex op */\n\t\t\t\tif (! do_traditional) {\n\t\t\t\t\t*dest++ = '\\\\';\n\t\t\t\t\t*dest++ = 'b';\n\t\t\t\t\tsrc++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/* else, fall through */\n\t\t\tdefault:\n\t\t\t\t*dest++ = '\\\\';\n\t\t\t\t*dest++ = (char) c;\n\t\t\t\tsrc++;\n\t\t\t\tbreak;\n\t\t\t} /* switch */\n\t\t} else {\n\t\t\tc = *src;\n\t\t\t*dest++ = *src++;\t/* not '\\\\' */\n\t\t}\n\t\tif (gawk_mb_cur_max > 1 && is_multibyte)\n\t\t\tis_multibyte--;\n\t} /* while */\n\n\t*dest = '\\0';\n\tlen = dest - buf;\n\n\tezalloc(rp, Regexp *, sizeof(*rp), \"make_regexp\");\n\trp->pat.allocated = 0;\t/* regex will allocate the buffer */\n\temalloc(rp->pat.fastmap, char *, 256, \"make_regexp\");\n\n\t/*\n\t * Lo these many years ago, had I known what a P.I.T.A. IGNORECASE\n\t * was going to turn out to be, I wouldn't have bothered with it.\n\t *\n\t * In the case where we have a multibyte character set, we have no\n\t * choice but to use RE_ICASE, since the casetable is for single-byte\n\t * character sets only.\n\t *\n\t * On the other hand, if we do have a single-byte character set,\n\t * using the casetable should give  a performance improvement, since\n\t * it's computed only once, not each time a regex is compiled.  We\n\t * also think it's probably better for portability.  See the\n\t * discussion by the definition of casetable[] in eval.c.\n\t */\n\n\tignorecase = !! ignorecase;\t/* force to 1 or 0 */\n\tif (ignorecase) {\n\t\tif (gawk_mb_cur_max > 1) {\n\t\t\tsyn |= RE_ICASE;\n\t\t\trp->pat.translate = NULL;\n\t\t} else {\n\t\t\tsyn &= ~RE_ICASE;\n\t\t\trp->pat.translate = (RE_TRANSLATE_TYPE) casetable;\n\t\t}\n\t} else {\n\t\trp->pat.translate = NULL;\n\t\tsyn &= ~RE_ICASE;\n\t}\n\n\t/* initialize dfas to hold syntax */\n\tif (first) {\n\t\tfirst = false;\n\t\tdfaregs[0] = dfaalloc();\n\t\tdfaregs[1] = dfaalloc();\n\t\tdfasyntax(dfaregs[0], & localeinfo, syn, DFA_ANCHOR);\n\t\tdfasyntax(dfaregs[1], & localeinfo, syn | RE_ICASE, DFA_ANCHOR);\n\t}\n\n\tre_set_syntax(syn);\n\n\tif ((rerr = re_compile_pattern(buf, len, &(rp->pat))) != NULL) {\n\t\trefree(rp);\n\t\tif (! canfatal) {\n\t\t\t/* rerr already gettextized inside regex routines */\n\t\t\terror(\"%s: /%s/\", rerr, buf);\n \t\t\treturn NULL;\n\t\t}\n\t\tfatal(\"%s: /%s/\", rerr, buf);\n\t}\n\n\t/* gack. this must be done *after* re_compile_pattern */\n\trp->pat.newline_anchor = false; /* don't get \\n in middle of string */\n\tif (dfa && ! no_dfa) {\n\t\trp->dfareg = dfaalloc();\n\t\tdfacopysyntax(rp->dfareg, dfaregs[ignorecase]);\n\t\tdfacomp(buf, len, rp->dfareg, true);\n\t} else\n\t\trp->dfareg = NULL;\n\n\t/* Additional flags that help with RS as regexp. */\n\tfor (i = 0; i < len; i++) {\n\t\tif (strchr(metas, buf[i]) != NULL) {\n\t\t\trp->has_meta = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (i = len - 1; i >= 0; i--) {\n\t\tif (strchr(\"*+|?\", buf[i]) != NULL) {\n\t\t\trp->maybe_long = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn rp;\n}",
      "lines": 213,
      "depth": 18,
      "decorators": [
        "Regexp",
        "*\nmake_regexp(const char *s, size_t len, bool ignorecase, bool dfa, bool canfatal)",
        "*"
      ]
    },
    "research": {
      "start_point": [
        253,
        0
      ],
      "end_point": [
        320,
        1
      ],
      "content": "int\nresearch(Regexp *rp, char *str, int start,\n\t size_t len, int flags)\n{\n\tconst char *ret = str;\n\tbool try_backref = false;\n\tint need_start;\n\tint no_bol;\n\tint res;\n\n\tneed_start = ((flags & RE_NEED_START) != 0);\n\tno_bol = ((flags & RE_NO_BOL) != 0);\n\n\tif (no_bol)\n\t\trp->pat.not_bol = 1;\n\n\t/*\n\t * Always do dfa search if can; if it fails, then even if\n\t * need_start is true, we won't bother with the regex search.\n\t *\n\t * The dfa matcher doesn't have a no_bol flag, so don't bother\n\t * trying it in that case.\n\t *\n\t * 7/2008: Skip the dfa matcher if need_start. The dfa matcher\n\t * has bugs in certain multibyte cases and it's too difficult\n\t * to try to special case things.\n\t * 7/2017: Apparently there are some cases where DFA gets\n\t * stuck, even in the C locale, so we use dfa only if not need_start.\n\t *\n\t * Should that issue ever get resolved, note this comment:\n\t *\n\t * 7/2016: The dfa matcher can't handle a case where searching\n\t * starts in the middle of a string, so don't bother trying it\n\t * in that case.\n\t *\tif (rp->dfa && ! no_bol && start == 0) ...\n\t */\n\tif (rp->dfareg != NULL && ! no_bol && ! need_start) {\n\t\tstruct dfa *superset = dfasuperset(rp->dfareg);\n\t\tif (superset)\n\t\t\tret = dfaexec(superset, str+start, str+start+len,\n\t\t\t\t\t\t\ttrue, NULL, NULL);\n\n\t\tif (ret && (! need_start\n\t\t\t\t|| (! superset && dfaisfast(rp->dfareg))))\n\t\t\tret = dfaexec(rp->dfareg, str+start, str+start+len,\n\t\t\t\t\t\ttrue, NULL, &try_backref);\n\t}\n\n\tif (ret) {\n\t\tif (   rp->dfareg == NULL\n\t\t\t|| start != 0\n\t\t\t|| no_bol\n\t\t\t|| need_start\n\t\t\t|| try_backref) {\n\t\t\t/*\n\t\t\t * Passing NULL as last arg speeds up search for cases\n\t\t\t * where we don't need the start/end info.\n\t\t\t */\n\t\t\tres = re_search(&(rp->pat), str, start+len,\n\t\t\t\tstart, len, need_start ? &(rp->regs) : NULL);\n\t\t} else\n\t\t\tres = 1;\n\t} else\n\t\tres = -1;\n\n\trp->pat.not_bol = 0;\n\treturn res;\n}",
      "lines": 68,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "refree": {
      "start_point": [
        324,
        0
      ],
      "end_point": [
        340,
        1
      ],
      "content": "void\nrefree(Regexp *rp)\n{\n\tif (rp == NULL)\n\t\treturn;\n\trp->pat.translate = NULL;\n\tregfree(& rp->pat);\n\tif (rp->regs.start)\n\t\tfree(rp->regs.start);\n\tif (rp->regs.end)\n\t\tfree(rp->regs.end);\n\tif (rp->dfareg != NULL) {\n\t\tdfafree(rp->dfareg);\n\t\tfree(rp->dfareg);\n\t}\n\tefree(rp);\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "dfaerror": {
      "start_point": [
        344,
        0
      ],
      "end_point": [
        349,
        1
      ],
      "content": "void\ndfaerror(const char *s)\n{\n\tfatal(\"%s\", s);\n\texit(EXIT_FATAL);\t/* for DJGPP */\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "re_update": {
      "start_point": [
        353,
        0
      ],
      "end_point": [
        401,
        1
      ],
      "content": "Regexp *\nre_update(NODE *t)\n{\n\tNODE *t1;\n\n\tif (t->type == Node_val && (t->flags & REGEX) != 0)\n\t\treturn t->typed_re->re_reg[IGNORECASE];\n\n\tif ((t->re_flags & CONSTANT) != 0) {\n\t\t/* it's a constant, so just return it as is */\n\t\tassert(t->type == Node_regex);\n\t\treturn t->re_reg[IGNORECASE];\n\t}\n\tt1 = t->re_exp;\n\tif (t->re_text != NULL) {\n\t\t/* if contents haven't changed, just return it */\n\t\tif (cmp_nodes(t->re_text, t1, true) == 0)\n\t\t\treturn t->re_reg[IGNORECASE];\n\t\t/* things changed, fall through to recompile */\n\t\tunref(t->re_text);\n\t}\n\t/* get fresh copy of the text of the regexp */\n\tt->re_text = dupnode(t1);\n\n\t/* text changed */\n\n\t/* free old */\n\tif (t->re_reg[0] != NULL)\n\t\trefree(t->re_reg[0]);\n\tif (t->re_reg[1] != NULL)\n\t\trefree(t->re_reg[1]);\n\tif (t->re_cnt > 0)\n\t\tt->re_cnt++;\n\tif (t->re_cnt > 10)\n\t\tt->re_cnt = 0;\n\tif (t->re_text == NULL) {\n\t\t/* reset regexp text if needed */\n\t\tt1 = t->re_exp;\n\t\tunref(t->re_text);\n\t\tt->re_text = dupnode(t1);\n\t}\n\t/* compile it */\n\tt->re_reg[0] = make_regexp(t->re_text->stptr, t->re_text->stlen,\n\t\t\t\tfalse, t->re_cnt, true);\n\tt->re_reg[1] = make_regexp(t->re_text->stptr, t->re_text->stlen,\n\t\t\t\ttrue, t->re_cnt, true);\n\n\treturn t->re_reg[IGNORECASE];\n}",
      "lines": 49,
      "depth": 11,
      "decorators": [
        "Regexp",
        "*\nre_update(NODE *t)",
        "*"
      ]
    },
    "resetup": {
      "start_point": [
        405,
        0
      ],
      "end_point": [
        434,
        1
      ],
      "content": "void\nresetup()\n{\n\t// init localeinfo for dfa\n\tinit_localeinfo(& localeinfo);\n\n\t/*\n\t * Syntax bits: _that_ is yet another mind trip.  Recreational drugs\n\t * are helpful for recovering from the experience.\n\t *\n\t *\tAharon Robbins <arnold@skeeve.com>\n\t *\tSun, 21 Oct 2007 23:55:33 +0200\n\t */\n\tif (do_posix)\n\t\tsyn = RE_SYNTAX_POSIX_AWK;\t/* strict POSIX re's */\n\telse if (do_traditional)\n\t\tsyn = RE_SYNTAX_AWK;\t\t/* traditional Unix awk re's */\n\telse\n\t\tsyn = RE_SYNTAX_GNU_AWK;\t/* POSIX re's + GNU ops */\n\n\t/*\n\t * Interval expressions are now on by default, as POSIX is\n\t * wide-spread enough that people want it. The do_intervals\n\t * variable remains for use with --traditional.\n\t */\n\tif (do_intervals)\n\t\tsyn |= RE_INTERVALS | RE_INVALID_INTERVAL_ORD | RE_NO_BK_BRACES;\n\n\t(void) re_set_syntax(syn);\n}",
      "lines": 30,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "using_utf8": {
      "start_point": [
        438,
        0
      ],
      "end_point": [
        442,
        1
      ],
      "content": "bool\nusing_utf8(void)\n{\n\treturn localeinfo.using_utf8;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "bool"
      ]
    },
    "reisstring": {
      "start_point": [
        446,
        0
      ],
      "end_point": [
        462,
        1
      ],
      "content": "int\nreisstring(const char *text, size_t len, Regexp *re, const char *buf)\n{\n\tint res;\n\tconst char *matched;\n\n\t/* simple checking for meta characters in re */\n\tif (re->has_meta)\n\t\treturn false;\t/* give up early, can't be string match */\n\n\t/* make accessable to gdb */\n\tmatched = &buf[RESTART(re, buf)];\n\n\tres = (memcmp(text, matched, len) == 0);\n\n\treturn res;\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "reflags2str": {
      "start_point": [
        466,
        0
      ],
      "end_point": [
        502,
        1
      ],
      "content": "const char *\nreflags2str(int flagval)\n{\n\tstatic const struct flagtab values[] = {\n\t\t{ RE_BACKSLASH_ESCAPE_IN_LISTS, \"RE_BACKSLASH_ESCAPE_IN_LISTS\" },\n\t\t{ RE_BK_PLUS_QM, \"RE_BK_PLUS_QM\" },\n\t\t{ RE_CHAR_CLASSES, \"RE_CHAR_CLASSES\" },\n\t\t{ RE_CONTEXT_INDEP_ANCHORS, \"RE_CONTEXT_INDEP_ANCHORS\" },\n\t\t{ RE_CONTEXT_INDEP_OPS, \"RE_CONTEXT_INDEP_OPS\" },\n\t\t{ RE_CONTEXT_INVALID_OPS, \"RE_CONTEXT_INVALID_OPS\" },\n\t\t{ RE_DOT_NEWLINE, \"RE_DOT_NEWLINE\" },\n\t\t{ RE_DOT_NOT_NULL, \"RE_DOT_NOT_NULL\" },\n\t\t{ RE_HAT_LISTS_NOT_NEWLINE, \"RE_HAT_LISTS_NOT_NEWLINE\" },\n\t\t{ RE_INTERVALS, \"RE_INTERVALS\" },\n\t\t{ RE_LIMITED_OPS, \"RE_LIMITED_OPS\" },\n\t\t{ RE_NEWLINE_ALT, \"RE_NEWLINE_ALT\" },\n\t\t{ RE_NO_BK_BRACES, \"RE_NO_BK_BRACES\" },\n\t\t{ RE_NO_BK_PARENS, \"RE_NO_BK_PARENS\" },\n\t\t{ RE_NO_BK_REFS, \"RE_NO_BK_REFS\" },\n\t\t{ RE_NO_BK_VBAR, \"RE_NO_BK_VBAR\" },\n\t\t{ RE_NO_EMPTY_RANGES, \"RE_NO_EMPTY_RANGES\" },\n\t\t{ RE_UNMATCHED_RIGHT_PAREN_ORD, \"RE_UNMATCHED_RIGHT_PAREN_ORD\" },\n\t\t{ RE_NO_POSIX_BACKTRACKING, \"RE_NO_POSIX_BACKTRACKING\" },\n\t\t{ RE_NO_GNU_OPS, \"RE_NO_GNU_OPS\" },\n\t\t{ RE_INVALID_INTERVAL_ORD, \"RE_INVALID_INTERVAL_ORD\" },\n\t\t{ RE_ICASE, \"RE_ICASE\" },\n\t\t{ RE_CARET_ANCHORS_HERE, \"RE_CARET_ANCHORS_HERE\" },\n\t\t{ RE_CONTEXT_INVALID_DUP, \"RE_CONTEXT_INVALID_DUP\" },\n\t\t{ RE_NO_SUB, \"RE_NO_SUB\" },\n\t\t{ 0,\tNULL },\n\t};\n\n\tif (flagval == RE_SYNTAX_EMACS) /* == 0 */\n\t\treturn \"RE_SYNTAX_EMACS\";\n\n\treturn genflags2str(flagval, values);\n}",
      "lines": 37,
      "depth": 8,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nreflags2str(int flagval)",
        "*"
      ]
    },
    "dfawarn": {
      "start_point": [
        509,
        0
      ],
      "end_point": [
        516,
        1
      ],
      "content": "void\ndfawarn(const char *dfa_warning)\n{\n\t/*\n\t * This routine does nothing, since gawk does its own\n\t * (better) check for bad [[:foo:]] syntax.\n\t */\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "check_bracket_exp": {
      "start_point": [
        520,
        0
      ],
      "end_point": [
        620,
        1
      ],
      "content": "static void\ncheck_bracket_exp(char *s, size_t length)\n{\n\tstatic struct reclass {\n\t\tconst char *name;\n\t\tsize_t len;\n\t\tbool warned;\n\t} classes[] = {\n\t\t/*\n\t\t * Ordered by what we hope is frequency,\n\t\t * since it's linear searched.\n\t\t */\n\t\t{ \"[:alpha:]\", 9, false },\n\t\t{ \"[:digit:]\", 9, false },\n\t\t{ \"[:alnum:]\", 9, false },\n\t\t{ \"[:upper:]\", 9, false },\n\t\t{ \"[:lower:]\", 9, false },\n\t\t{ \"[:space:]\", 9, false },\n\t\t{ \"[:xdigit:]\", 10, false },\n\t\t{ \"[:punct:]\", 9, false },\n\t\t{ \"[:print:]\", 9, false },\n\t\t{ \"[:graph:]\", 9, false },\n\t\t{ \"[:cntrl:]\", 9, false },\n\t\t{ \"[:blank:]\", 9, false },\n\t\t{ NULL, 0 }\n\t};\n\tint i;\n\tbool found = false;\n\tchar save;\n\tchar *sp, *sp2, *end;\n\tint len;\n\tint count = 0;\n\n\tif (length == 0)\n\t\treturn;\n\n\tend = s + length;\n\tsave = s[length];\n\ts[length] = '\\0';\n\tsp = s;\n\nagain:\n\tsp = sp2 = memchr(sp, '[', (end - sp));\n\tif (sp == NULL)\n\t\tgoto done;\n\n\tfor (count++, sp++; *sp != '\\0'; sp++) {\n\t\tif (*sp == '[')\n\t\t\tcount++;\n\t\t/*\n\t\t * ] as first char after open [ is skipped\n\t\t * \\] is skipped\n\t\t * [^]] is skipped\n\t\t */\n\t\tif (*sp == ']' && sp > sp2) {\n\t\t\t if (sp[-1] != '['\n\t\t\t     && sp[-1] != '\\\\')\n\t\t\t\t ;\n\t\t\t else if ((sp - sp2) >= 2\n\t\t\t\t  && sp[-1] == '^' && sp[-2] == '[')\n\t\t\t\t ;\n\t\t\t else\n\t\t\t\tcount--;\n\t\t}\n\n\t\tif (count == 0) {\n\t\t\tsp++;\t/* skip past ']' */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (count > 0) {\t/* bad regex, give up */\n\t\tgoto done;\n\t}\n\n\t/* sp2 has start */\n\n\tfor (i = 0; classes[i].name != NULL; i++) {\n\t\tif (classes[i].warned)\n\t\t\tcontinue;\n\t\tlen = classes[i].len;\n\t\tif (   len == (sp - sp2)\n\t\t    && memcmp(sp2, classes[i].name, len) == 0) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (found && ! classes[i].warned) {\n\t\twarning(_(\"regexp component `%.*s' should probably be `[%.*s]'\"),\n\t\t\t\tlen, sp2, len, sp2);\n\t\tclasses[i].warned = true;\n\t}\n\n\tif (sp < end) {\n\t\tfound = false;\n\t\tgoto again;\n\t}\ndone:\n\ts[length] = save;\n}",
      "lines": 101,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "gawk/gawk-4.2.1/replace.c": {},
  "gawk/gawk-4.2.1/str_array.c": {
    "str_array_init": {
      "start_point": [
        103,
        0
      ],
      "end_point": [
        119,
        1
      ],
      "content": "static NODE **\nstr_array_init(NODE *symbol ATTRIBUTE_UNUSED, NODE *subs ATTRIBUTE_UNUSED)\n{\n\tif (symbol == NULL) {\t\t/* first time */\n\t\tlong newval;\n\t\tconst char *val;\n\n\t\t/* check relevant environment variables */\n\t\tif ((newval = getenv_long(\"STR_CHAIN_MAX\")) > 0)\n\t\t\tSTR_CHAIN_MAX = newval;\n\t\tif ((val = getenv(\"AWK_HASH\")) != NULL && strcmp(val, \"gst\") == 0)\n\t\t\thash = gst_hash_string;\n\t} else\n\t\tnull_array(symbol);\n\n\treturn & success_node;\n}",
      "lines": 17,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "NODE",
        "**\nstr_array_init(NODE *symbol ATTRIBUTE_UNUSED, NODE *subs ATTRIBUTE_UNUSED)",
        "*",
        "*\nstr_array_init(NODE *symbol ATTRIBUTE_UNUSED, NODE *subs ATTRIBUTE_UNUSED)",
        "*"
      ]
    },
    "str_lookup": {
      "start_point": [
        131,
        0
      ],
      "end_point": [
        213,
        1
      ],
      "content": "static NODE **\nstr_lookup(NODE *symbol, NODE *subs)\n{\n\tunsigned long hash1;\n\tNODE **lhs;\n\tBUCKET *b;\n\tsize_t code1;\n\n\tsubs = force_string(subs);\n\n\tif (symbol->buckets == NULL)\n\t\tgrow_table(symbol);\n\thash1 = hash(subs->stptr, subs->stlen,\n\t\t\t(unsigned long) symbol->array_size, & code1);\n\tif ((lhs = str_find(symbol, subs, code1, hash1)) != NULL)\n\t\treturn lhs;\n\n\t/* It's not there, install it. */\n\t/* first see if we would need to grow the array, before installing */\n\n\tsymbol->table_size++;\n\tif ((symbol->flags & ARRAYMAXED) == 0\n\t\t\t&& (symbol->table_size / symbol->array_size) > STR_CHAIN_MAX) {\n\t\tgrow_table(symbol);\n\t\t/* have to recompute hash value for new size */\n\t\thash1 = code1 % (unsigned long) symbol->array_size;\n\t}\n\n\n\t/*\n\t * Repeat after me: \"Array indices are always strings.\"\n\t * \"Array indices are always strings.\"\n\t * \"Array indices are always strings.\"\n\t * \"Array indices are always strings.\"\n\t * ....\n\t */\n\t// Special cases:\n\t// 1. The string was generated using CONVFMT.\n\t// 2. The string was from an unassigned variable.\n\t// 3. The string was from an unassigned field.\n\tif (   subs->stfmt != STFMT_UNUSED\n\t    || subs == Nnull_string\n\t    || (subs->flags & NULL_FIELD) != 0) {\n\t\tNODE *tmp;\n\n\t\t/*\n\t\t * Need to freeze this string value --- it must never\n\t\t * change, no matter what happens to the value\n\t\t * that created it or to CONVFMT, etc.; So, get\n\t\t * a private copy.\n\t\t */\n\n\t\ttmp = make_string(subs->stptr, subs->stlen);\n\n\t\t/*\n\t\t* Set the numeric value for the index if it's  available. Useful\n\t\t* for numeric sorting by index.  Do this only if the numeric\n\t\t* value is available, instead of all the time, since doing it\n\t\t* all the time is a big performance hit for something that may\n\t\t* never be used.\n\t\t*/\n\n\t\tif ((subs->flags & (MPFN|MPZN|NUMCUR)) == NUMCUR) {\n\t\t\ttmp->numbr = subs->numbr;\n\t\t\ttmp->flags |= NUMCUR;\n\t\t}\n\t\tsubs = tmp;\n\t} else {\n\t\t/* string value already \"frozen\" */\n\n\t\tsubs = dupnode(subs);\n\t}\n\n\tgetbucket(b);\n\tb->ahnext = symbol->buckets[hash1];\n\tsymbol->buckets[hash1] = b;\n\tb->ahname = subs;\n\tb->ahname_str = subs->stptr;\n\tb->ahname_len = subs->stlen;\n\tb->ahvalue = dupnode(Nnull_string);\n\tb->ahcode = code1;\n\treturn & (b->ahvalue);\n}",
      "lines": 83,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "NODE",
        "**\nstr_lookup(NODE *symbol, NODE *subs)",
        "*",
        "*\nstr_lookup(NODE *symbol, NODE *subs)",
        "*"
      ]
    },
    "str_exists": {
      "start_point": [
        219,
        0
      ],
      "end_point": [
        231,
        1
      ],
      "content": "static NODE **\nstr_exists(NODE *symbol, NODE *subs)\n{\n\tunsigned long hash1;\n\tsize_t code1;\n\n\tif (symbol->table_size == 0)\n\t\treturn NULL;\n\n\tsubs = force_string(subs);\n\thash1 = hash(subs->stptr, subs->stlen, (unsigned long) symbol->array_size, & code1);\n\treturn str_find(symbol, subs, code1, hash1);\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "NODE",
        "**\nstr_exists(NODE *symbol, NODE *subs)",
        "*",
        "*\nstr_exists(NODE *symbol, NODE *subs)",
        "*"
      ]
    },
    "str_clear": {
      "start_point": [
        235,
        0
      ],
      "end_point": [
        262,
        1
      ],
      "content": "static NODE **\nstr_clear(NODE *symbol, NODE *subs ATTRIBUTE_UNUSED)\n{\n\tunsigned long i;\n\tBUCKET *b, *next;\n\tNODE *r;\n\n\tfor (i = 0; i < symbol->array_size; i++) {\n\t\tfor (b = symbol->buckets[i]; b != NULL; b = next) {\n\t\t\tnext = b->ahnext;\n\t\t\tr = b->ahvalue;\n\t\t\tif (r->type == Node_var_array) {\n\t\t\t\tassoc_clear(r);\t/* recursively clear all sub-arrays */\n\t\t\t\tefree(r->vname);\n\t\t\t\tfreenode(r);\n\t\t\t} else\n\t\t\t\tunref(r);\n\t\t\tunref(b->ahname);\n\t\t\tfreebucket(b);\n\t\t}\n\t\tsymbol->buckets[i] = NULL;\n\t}\n\n\tif (symbol->buckets != NULL)\n\t\tefree(symbol->buckets);\n\tsymbol->ainit(symbol, NULL);\t/* re-initialize symbol */\n\treturn NULL;\n}",
      "lines": 28,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "NODE",
        "**\nstr_clear(NODE *symbol, NODE *subs ATTRIBUTE_UNUSED)",
        "*",
        "*\nstr_clear(NODE *symbol, NODE *subs ATTRIBUTE_UNUSED)",
        "*"
      ]
    },
    "str_remove": {
      "start_point": [
        267,
        0
      ],
      "end_point": [
        314,
        1
      ],
      "content": "static NODE **\nstr_remove(NODE *symbol, NODE *subs)\n{\n\tunsigned long hash1;\n\tBUCKET *b, *prev;\n\tNODE *s2;\n\tsize_t s1_len;\n\n\tif (symbol->table_size == 0)\n\t\treturn NULL;\n\n\ts2 = force_string(subs);\n\thash1 = hash(s2->stptr, s2->stlen, (unsigned long) symbol->array_size, NULL);\n\n\tfor (b = symbol->buckets[hash1], prev = NULL; b != NULL;\n\t\t\t\tprev = b, b = b->ahnext) {\n\n\t\t/* Array indexes are strings; compare as such, always! */\n\t\ts1_len = b->ahname_len;\n\n\t\tif (s1_len != s2->stlen)\n\t\t\tcontinue;\n\t\tif (s1_len == 0\t\t/* \"\" is a valid index */\n\t\t\t    || memcmp(b->ahname_str, s2->stptr, s1_len) == 0) {\n\t\t\t/* item found */\n\n\t\t\tunref(b->ahname);\n\t\t\tif (prev != NULL)\n\t\t\t\tprev->ahnext = b->ahnext;\n\t\t\telse\n\t\t\t\tsymbol->buckets[hash1] = b->ahnext;\n\n\t\t\t/* delete bucket */\n\t\t\tfreebucket(b);\n\n\t\t\t/* one less element in array */\n\t\t\tif (--symbol->table_size == 0) {\n\t\t\t\tif (symbol->buckets != NULL)\n\t\t\t\t\tefree(symbol->buckets);\n\t\t\t\tsymbol->ainit(symbol, NULL);\t/* re-initialize symbol */\n\t\t\t}\n\n\t\t\treturn & success_node;\t/* return success */\n\t\t}\n\t}\n\n\treturn NULL;\n}",
      "lines": 48,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "NODE",
        "**\nstr_remove(NODE *symbol, NODE *subs)",
        "*",
        "*\nstr_remove(NODE *symbol, NODE *subs)",
        "*"
      ]
    },
    "str_copy": {
      "start_point": [
        319,
        0
      ],
      "end_point": [
        377,
        1
      ],
      "content": "static NODE **\nstr_copy(NODE *symbol, NODE *newsymb)\n{\n\tBUCKET **old, **new, **pnew;\n\tBUCKET *chain, *newchain;\n\tunsigned long cursize, i;\n\n\tassert(symbol->table_size > 0);\n\n\t/* find the current hash size */\n\tcursize = symbol->array_size;\n\n\t/* allocate new table */\n\tezalloc(new, BUCKET **, cursize * sizeof(BUCKET *), \"str_copy\");\n\n\told = symbol->buckets;\n\n\tfor (i = 0; i < cursize; i++) {\n\t\tfor (chain = old[i], pnew = & new[i]; chain != NULL;\n\t\t\t\tchain = chain->ahnext\n\t\t) {\n\t\t\tNODE *oldval, *newsubs;\n\n\t\t\tgetbucket(newchain);\n\n\t\t\t/*\n\t\t\t * copy the corresponding name and\n\t\t\t * value from the original input list\n\t\t\t */\n\n\t\t\tnewsubs = newchain->ahname = dupnode(chain->ahname);\n\t\t\tnewchain->ahname_str = newsubs->stptr;\n\t\t\tnewchain->ahname_len = newsubs->stlen;\n\n\t\t\toldval = chain->ahvalue;\n\t\t\tif (oldval->type == Node_val)\n\t\t\t\tnewchain->ahvalue = dupnode(oldval);\n\t\t\telse {\n\t\t\t\tNODE *r;\n\n\t\t\t\tr = make_array();\n\t\t\t\tr->vname = estrdup(oldval->vname, strlen(oldval->vname));\n\t\t\t\tr->parent_array = newsymb;\n\t\t\t\tnewchain->ahvalue = assoc_copy(oldval, r);\n\t\t\t}\n\t\t\tnewchain->ahcode = chain->ahcode;\n\n\t\t\t*pnew = newchain;\n\t\t\tnewchain->ahnext = NULL;\n\t\t\tpnew = & newchain->ahnext;\n\t\t}\n\t}\n\n\tnewsymb->table_size = symbol->table_size;\n\tnewsymb->buckets = new;\n\tnewsymb->array_size = cursize;\n\tnewsymb->flags = symbol->flags;\n\treturn NULL;\n}",
      "lines": 59,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "NODE",
        "**\nstr_copy(NODE *symbol, NODE *newsymb)",
        "*",
        "*\nstr_copy(NODE *symbol, NODE *newsymb)",
        "*"
      ]
    },
    "str_list": {
      "start_point": [
        382,
        0
      ],
      "end_point": [
        433,
        1
      ],
      "content": "static NODE**\nstr_list(NODE *symbol, NODE *t)\n{\n\tNODE **list;\n\tNODE *subs, *val;\n\tBUCKET *b;\n\tunsigned long num_elems, list_size, i, k = 0;\n\tint elem_size = 1;\n\tassoc_kind_t assoc_kind;\n\n\tif (symbol->table_size == 0)\n\t\treturn NULL;\n\n\tassoc_kind = (assoc_kind_t) t->flags;\n\tif ((assoc_kind & (AINDEX|AVALUE)) == (AINDEX|AVALUE))\n\t\telem_size = 2;\n\n\t/* allocate space for array */\n\tnum_elems = symbol->table_size;\n\tif ((assoc_kind & (AINDEX|AVALUE|ADELETE)) == (AINDEX|ADELETE))\n\t\tnum_elems = 1;\n\tlist_size =  elem_size * num_elems;\n\n\temalloc(list, NODE **, list_size * sizeof(NODE *), \"str_list\");\n\n\t/* populate it */\n\n\tfor (i = 0; i < symbol->array_size; i++) {\n\t\tfor (b = symbol->buckets[i]; b != NULL;\tb = b->ahnext) {\n\t\t\t/* index */\n\t\t\tsubs = b->ahname;\n\t\t\tif ((assoc_kind & AINUM) != 0)\n\t\t\t\t(void) force_number(subs);\n\t\t\tlist[k++] = dupnode(subs);\n\n\t\t\t/* value */\n\t\t\tif ((assoc_kind & AVALUE) != 0) {\n\t\t\t\tval = b->ahvalue;\n\t\t\t\tif (val->type == Node_val) {\n\t\t\t\t\tif ((assoc_kind & AVNUM) != 0)\n\t\t\t\t\t\t(void) force_number(val);\n\t\t\t\t\telse if ((assoc_kind & AVSTR) != 0)\n\t\t\t\t\t\tval = force_string(val);\n\t\t\t\t}\n\t\t\t\tlist[k++] = val;\n\t\t\t}\n\t\t\tif (k >= list_size)\n\t\t\t\treturn list;\n\t\t}\n\t}\n\treturn list;\n}",
      "lines": 52,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "NODE",
        "**\nstr_list(NODE *symbol, NODE *t)",
        "*",
        "*\nstr_list(NODE *symbol, NODE *t)",
        "*"
      ]
    },
    "str_kilobytes": {
      "start_point": [
        438,
        0
      ],
      "end_point": [
        450,
        1
      ],
      "content": "AWKNUM\nstr_kilobytes(NODE *symbol)\n{\n\tunsigned long bucket_cnt;\n\tAWKNUM kb;\n\n\tbucket_cnt = symbol->table_size;\n\n\t/* This does not include extra memory for indices with stfmt != STFMT_UNUSED */\n\tkb = (((AWKNUM) bucket_cnt) * sizeof (BUCKET) +\n\t\t((AWKNUM) symbol->array_size) * sizeof (BUCKET *)) / 1024.0;\n\treturn kb;\n}",
      "lines": 13,
      "depth": 15,
      "decorators": [
        "AWKNUM"
      ]
    },
    "str_dump": {
      "start_point": [
        455,
        0
      ],
      "end_point": [
        535,
        1
      ],
      "content": "static NODE **\nstr_dump(NODE *symbol, NODE *ndump)\n{\n#define HCNT\t31\n\n\tint indent_level;\n\tunsigned long i, bucket_cnt;\n\tBUCKET *b;\n\tstatic size_t hash_dist[HCNT + 1];\n\n\tindent_level = ndump->alevel;\n\n\tif ((symbol->flags & XARRAY) == 0)\n\t\tfprintf(output_fp, \"%s `%s'\\n\",\n\t\t\t\t(symbol->parent_array == NULL) ? \"array\" : \"sub-array\",\n\t\t\t\tarray_vname(symbol));\n\tindent_level++;\n\tindent(indent_level);\n\tfprintf(output_fp, \"array_func: str_array_func\\n\");\n\tif (symbol->flags != 0) {\n\t\tindent(indent_level);\n\t\tfprintf(output_fp, \"flags: %s\\n\", flags2str(symbol->flags));\n\t}\n\tindent(indent_level);\n\tfprintf(output_fp, \"STR_CHAIN_MAX: %lu\\n\", (unsigned long) STR_CHAIN_MAX);\n\tindent(indent_level);\n\tfprintf(output_fp, \"array_size: %lu\\n\", (unsigned long) symbol->array_size);\n\tindent(indent_level);\n\tfprintf(output_fp, \"table_size: %lu\\n\", (unsigned long) symbol->table_size);\n\tindent(indent_level);\n\tfprintf(output_fp, \"Avg # of items per chain: %.2g\\n\",\n\t\t\t\t((AWKNUM) symbol->table_size) / symbol->array_size);\n\n\tindent(indent_level);\n\tfprintf(output_fp, \"memory: %.2g kB\\n\", str_kilobytes(symbol));\n\n\t/* hash value distribution */\n\n\tmemset(hash_dist, '\\0', (HCNT + 1) * sizeof(size_t));\n\tfor (i = 0; i < symbol->array_size; i++) {\n\t\tbucket_cnt = 0;\n\t\tfor (b = symbol->buckets[i]; b != NULL;\tb = b->ahnext)\n\t\t\tbucket_cnt++;\n\t\tif (bucket_cnt >= HCNT)\n\t\t\tbucket_cnt = HCNT;\n\t\thash_dist[bucket_cnt]++;\n\t}\n\n\tindent(indent_level);\n\tfprintf(output_fp, \"Hash distribution:\\n\");\n\tindent_level++;\n\tfor (i = 0; i <= HCNT; i++) {\n\t\tif (hash_dist[i] > 0) {\n\t\t\tindent(indent_level);\n\t\t\tif (i == HCNT)\n\t\t\t\tfprintf(output_fp, \"[>=%lu]:%lu\\n\",\n\t\t\t\t\t(unsigned long) HCNT, (unsigned long) hash_dist[i]);\n\t\t\telse\n\t\t\t\tfprintf(output_fp, \"[%lu]:%lu\\n\",\n\t\t\t\t\t(unsigned long) i, (unsigned long) hash_dist[i]);\n\t\t}\n\t}\n\tindent_level--;\n\n\t/* dump elements */\n\n\tif (ndump->adepth >= 0) {\n\t\tconst char *aname;\n\n\t\tfprintf(output_fp, \"\\n\");\n\t\taname = make_aname(symbol);\n\t\tfor (i = 0; i < symbol->array_size; i++) {\n\t\t\tfor (b = symbol->buckets[i]; b != NULL;\tb = b->ahnext)\n\t\t\t\tassoc_info(b->ahname, b->ahvalue, ndump, aname);\n\t\t}\n\t}\n\n\treturn NULL;\n\n#undef HCNT\n}",
      "lines": 81,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "NODE",
        "**\nstr_dump(NODE *symbol, NODE *ndump)",
        "*",
        "*\nstr_dump(NODE *symbol, NODE *ndump)",
        "*"
      ]
    },
    "awk_hash": {
      "start_point": [
        540,
        0
      ],
      "end_point": [
        599,
        1
      ],
      "content": "static unsigned long\nawk_hash(const char *s, size_t len, unsigned long hsize, size_t *code)\n{\n\tunsigned long h = 0;\n\tunsigned long htmp;\n\n\t/*\n\t * Ozan Yigit's original sdbm hash, copied from Margo Seltzers\n\t * db package.\n\t *\n\t * This is INCREDIBLY ugly, but fast.  We break the string up into\n\t * 8 byte units.  On the first time through the loop we get the\n\t * \"leftover bytes\" (strlen % 8).  On every other iteration, we\n\t * perform 8 HASHC's so we handle all 8 bytes.  Essentially, this\n\t * saves us 7 cmp & branch instructions.  If this routine is\n\t * heavily used enough, it's worth the ugly coding.\n\t */\n\n\t/*\n\t * Even more speed:\n\t * #define HASHC   h = *s++ + 65599 * h\n\t * Because 65599 = pow(2, 6) + pow(2, 16) - 1 we multiply by shifts\n\t *\n\t * 4/2011: Force the results to 32 bits, to get the same\n\t * result on both 32- and 64-bit systems. This may be a\n\t * bad idea.\n\t */\n#define HASHC   htmp = (h << 6);  \\\n\t\th = *s++ + htmp + (htmp << 10) - h ; \\\n\t\thtmp &= 0xFFFFFFFF; \\\n\t\th &= 0xFFFFFFFF\n\n\th = 0;\n\n\t/* \"Duff's Device\" */\n\tif (len > 0) {\n\t\tsize_t loop = (len + 8 - 1) >> 3;\n\n\t\tswitch (len & (8 - 1)) {\n\t\tcase 0:\n\t\t\tdo {\t/* All fall throughs */\n\t\t\t\tHASHC;\n\t\tcase 7:\t\tHASHC;\n\t\tcase 6:\t\tHASHC;\n\t\tcase 5:\t\tHASHC;\n\t\tcase 4:\t\tHASHC;\n\t\tcase 3:\t\tHASHC;\n\t\tcase 2:\t\tHASHC;\n\t\tcase 1:\t\tHASHC;\n\t\t\t} while (--loop);\n\t\t}\n\t}\n\n\tif (code != NULL)\n\t\t*code = h;\n\n\tif (h >= hsize)\n\t\th %= hsize;\n\treturn h;\n}",
      "lines": 60,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "unsigned long",
        "unsigned",
        "long"
      ]
    },
    "str_find": {
      "start_point": [
        604,
        0
      ],
      "end_point": [
        625,
        1
      ],
      "content": "static inline NODE **\nstr_find(NODE *symbol, NODE *s1, size_t code1, unsigned long hash1)\n{\n\tBUCKET *b;\n\tsize_t s2_len;\n\n\tfor (b = symbol->buckets[hash1]; b != NULL; b = b->ahnext) {\n\t\t/*\n\t\t * This used to use cmp_nodes() here.  That's wrong.\n\t\t * Array indexes are strings; compare as such, always!\n\t \t */\n\t\ts2_len = b->ahname_len;\n\n\t\tif (code1 == b->ahcode\n\t\t\t&& s1->stlen == s2_len\n\t\t\t&& (s2_len == 0\t\t/* \"\" is a valid index */\n\t\t\t\t|| memcmp(s1->stptr, b->ahname_str, s2_len) == 0)\n\t\t)\n\t\t\treturn & (b->ahvalue);\n\t}\n\treturn NULL;\n}",
      "lines": 22,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "NODE",
        "**\nstr_find(NODE *symbol, NODE *s1, size_t code1, unsigned long hash1)",
        "*",
        "*\nstr_find(NODE *symbol, NODE *s1, size_t code1, unsigned long hash1)",
        "*"
      ]
    },
    "grow_table": {
      "start_point": [
        630,
        0
      ],
      "end_point": [
        702,
        1
      ],
      "content": "static void\ngrow_table(NODE *symbol)\n{\n\tBUCKET **old, **new;\n\tBUCKET *chain, *next;\n\tint i, j;\n\tunsigned long oldsize, newsize, k;\n\tunsigned long hash1;\n\n\t/*\n\t * This is an array of primes. We grow the table by an order of\n\t * magnitude each time (not just doubling) so that growing is a\n\t * rare operation. We expect, on average, that it won't happen\n\t * more than twice.  The final size is also chosen to be small\n\t * enough so that MS-DOG mallocs can handle it. When things are\n\t * very large (> 8K), we just double more or less, instead of\n\t * just jumping from 8K to 64K.\n\t */\n\n\tstatic const unsigned long sizes[] = {\n\t\t13, 127, 1021, 8191, 16381, 32749, 65497,\n\t\t131101, 262147, 524309, 1048583, 2097169,\n\t\t4194319, 8388617, 16777259, 33554467,\n\t\t67108879, 134217757, 268435459, 536870923,\n\t\t1073741827\n\t};\n\n\t/* find next biggest hash size */\n\tnewsize = oldsize = symbol->array_size;\n\n\tfor (i = 0, j = sizeof(sizes)/sizeof(sizes[0]); i < j; i++) {\n\t\tif (oldsize < sizes[i]) {\n\t\t\tnewsize = sizes[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (newsize == oldsize) {\t/* table already at max (!) */\n\t\tsymbol->flags |= ARRAYMAXED;\n\t\treturn;\n\t}\n\n\t/* allocate new table */\n\tezalloc(new, BUCKET **, newsize * sizeof(BUCKET *), \"grow_table\");\n\n\told = symbol->buckets;\n\tsymbol->buckets = new;\n\tsymbol->array_size = newsize;\n\n\t/* brand new hash table, set things up and return */\n\tif (old == NULL) {\n\t\tsymbol->table_size = 0;\n\t\treturn;\n\t}\n\n\t/* old hash table there, move stuff to new, free old */\n\n\t/*\n\t * note that symbol->table_size does not change if an old array,\n\t * and is explicitly set to 0 if a new one.\n\t */\n\n\tfor (k = 0; k < oldsize; k++) {\n\t\tfor (chain = old[k]; chain != NULL; chain = next) {\n\t\t\tnext = chain->ahnext;\n\t\t\thash1 = chain->ahcode % newsize;\n\n\t\t\t/* remove from old list, add to new */\n\t\t\tchain->ahnext = new[hash1];\n\t\t\tnew[hash1] = chain;\n\t\t}\n\t}\n\tefree(old);\n}",
      "lines": 73,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "gst_hash_string": {
      "start_point": [
        729,
        0
      ],
      "end_point": [
        750,
        1
      ],
      "content": "static unsigned long\ngst_hash_string(const char *str, size_t len, unsigned long hsize, size_t *code)\n{\n\tunsigned long hashVal = 1497032417;    /* arbitrary value */\n\tunsigned long ret;\n\n\twhile (len--) {\n\t\thashVal += *str++;\n\t\thashVal += (hashVal << 10);\n\t\thashVal ^= (hashVal >> 6);\n\t}\n\n\tret = scramble(hashVal);\n\n\tif (code != NULL)\n\t\t*code = ret;\n\n\tif (ret >= hsize)\n\t\tret %= hsize;\n\n\treturn ret;\n}",
      "lines": 22,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "unsigned long",
        "unsigned",
        "long"
      ]
    },
    "scramble": {
      "start_point": [
        752,
        0
      ],
      "end_point": [
        770,
        1
      ],
      "content": "static unsigned long\nscramble(unsigned long x)\n{\n\tif (sizeof(long) == 4) {\n\t\tint y = ~x;\n\n\t\tx += (y << 10) | (y >> 22);\n\t\tx += (x << 6)  | (x >> 26);\n\t\tx -= (x << 16) | (x >> 16);\n\t} else {\n\t\tx ^= (~x) >> 31;\n\t\tx += (x << 21) | (x >> 11);\n\t\tx += (x << 5) | (x >> 27);\n\t\tx += (x << 27) | (x >> 5);\n\t\tx += (x << 31);\n\t}\n\n\treturn x;\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "unsigned long",
        "unsigned",
        "long"
      ]
    },
    "env_remove": {
      "start_point": [
        774,
        0
      ],
      "end_point": [
        787,
        1
      ],
      "content": "static NODE **\nenv_remove(NODE *symbol, NODE *subs)\n{\n\tNODE **val = str_remove(symbol, subs);\n\tchar save;\n\n\tif (val != NULL) {\n\t\tstr_terminate(subs, save);\n\t\t(void) unsetenv(subs->stptr);\n\t\tstr_restore(subs, save);\n\t}\n\n\treturn val;\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "NODE",
        "**\nenv_remove(NODE *symbol, NODE *subs)",
        "*",
        "*\nenv_remove(NODE *symbol, NODE *subs)",
        "*"
      ]
    },
    "env_clear": {
      "start_point": [
        791,
        0
      ],
      "end_point": [
        803,
        1
      ],
      "content": "static NODE **\nenv_clear(NODE *symbol, NODE *subs)\n{\n\textern char **environ;\n\tNODE **val = str_clear(symbol, subs);\n\n\tenviron = NULL;\t/* ZAP! */\n\n\t/* str_clear zaps the vtable, reset it */\n\tsymbol->array_funcs = env_array_func;\n\n\treturn val;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "NODE",
        "**\nenv_clear(NODE *symbol, NODE *subs)",
        "*",
        "*\nenv_clear(NODE *symbol, NODE *subs)",
        "*"
      ]
    },
    "env_store": {
      "start_point": [
        807,
        0
      ],
      "end_point": [
        822,
        1
      ],
      "content": "static NODE **\nenv_store(NODE *symbol, NODE *subs)\n{\n\tNODE **val = str_exists(symbol, subs);\n\tconst char *newval;\n\n\tassert(val != NULL);\n\n\tnewval = (*val)->stptr;\n\tif (newval == NULL)\n\t\tnewval = \"\";\n\n\t(void) setenv(subs->stptr, newval, 1);\n\n\treturn val;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "NODE",
        "**\nenv_store(NODE *symbol, NODE *subs)",
        "*",
        "*\nenv_store(NODE *symbol, NODE *subs)",
        "*"
      ]
    },
    "init_env_array": {
      "start_point": [
        826,
        0
      ],
      "end_point": [
        834,
        1
      ],
      "content": "void\ninit_env_array(NODE *env_node)\n{\n\t/* If POSIX simply don't reset the vtable and things work as before */\n\tif (do_posix)\n\t\treturn;\n\n\tenv_node->array_funcs = env_array_func;\n}",
      "lines": 9,
      "depth": 6,
      "decorators": [
        "void"
      ]
    }
  },
  "gawk/gawk-4.2.1/symbol.c": {
    "init_symbol_table": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        69,
        1
      ],
      "content": "void\ninit_symbol_table()\n{\n\tgetnode(global_table);\n\tmemset(global_table, '\\0', sizeof(NODE));\n\tnull_array(global_table);\n\n\tgetnode(param_table);\n\tmemset(param_table, '\\0', sizeof(NODE));\n\tnull_array(param_table);\n\n\tinstalling_specials = true;\n\tfunc_table = install_symbol(estrdup(\"FUNCTAB\", 7), Node_var_array);\n\n\tsymbol_table = install_symbol(estrdup(\"SYMTAB\", 6), Node_var_array);\n\tinstalling_specials = false;\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "install_symbol": {
      "start_point": [
        77,
        0
      ],
      "end_point": [
        81,
        1
      ],
      "content": "NODE *\ninstall_symbol(const char *name, NODETYPE type)\n{\n\treturn install(name, NULL, type);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "NODE",
        "*\ninstall_symbol(const char *name, NODETYPE type)",
        "*"
      ]
    },
    "lookup": {
      "start_point": [
        89,
        0
      ],
      "end_point": [
        123,
        1
      ],
      "content": "NODE *\nlookup(const char *name)\n{\n\tNODE *n;\n\tNODE *tmp;\n\tNODE *tables[5];\t/* manual init below, for z/OS */\n\tint i;\n\n\t/* ``It's turtles, all the way down.'' */\n\ttables[0] = param_table;\t/* parameters shadow everything */\n\ttables[1] = global_table;\t/* SYMTAB and FUNCTAB found first, can't be redefined */\n\ttables[2] = func_table;\t\t/* then functions */\n\ttables[3] = symbol_table;\t/* then globals */\n\ttables[4] = NULL;\n\n\ttmp = make_string(name, strlen(name));\n\n\tn = NULL;\n\tfor (i = 0; tables[i] != NULL; i++) {\n\t\tif (tables[i]->table_size == 0)\n\t\t\tcontinue;\n\n\t\tif ((do_posix || do_traditional) && tables[i] == global_table)\n\t\t\tcontinue;\n\n\t\tn = in_array(tables[i], tmp);\n\t\tif (n != NULL)\n\t\t\tbreak;\n\t}\n\n\tunref(tmp);\n\tif (n == NULL || n->type == Node_val)\t/* non-variable in SYMTAB */\n\t\treturn NULL;\n\treturn n;\t/* new place */\n}",
      "lines": 35,
      "depth": 10,
      "decorators": [
        "NODE",
        "*\nlookup(const char *name)",
        "*"
      ]
    },
    "make_params": {
      "start_point": [
        127,
        0
      ],
      "end_point": [
        145,
        1
      ],
      "content": "NODE *\nmake_params(char **pnames, int pcount)\n{\n\tNODE *p, *parms;\n\tint i;\n\n\tif (pcount <= 0 || pnames == NULL)\n\t\treturn NULL;\n\n\tezalloc(parms, NODE *, pcount * sizeof(NODE), \"make_params\");\n\n\tfor (i = 0, p = parms; i < pcount; i++, p++) {\n\t\tp->type = Node_param_list;\n\t\tp->param = pnames[i];\t/* shadows pname and vname */\n\t\tp->param_cnt = i;\n\t}\n\n\treturn parms;\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "NODE",
        "*\nmake_params(char **pnames, int pcount)",
        "*"
      ]
    },
    "install_params": {
      "start_point": [
        149,
        0
      ],
      "end_point": [
        166,
        1
      ],
      "content": "void\ninstall_params(NODE *func)\n{\n\tint i, pcount;\n\tNODE *parms;\n\n\tif (func == NULL)\n\t\treturn;\n\n\tassert(func->type == Node_func);\n\n\tif (   (pcount = func->param_cnt) <= 0\n\t    || (parms = func->fparms) == NULL)\n\t\treturn;\n\n\tfor (i = 0; i < pcount; i++)\n\t\t(void) install(parms[i].param, parms + i, Node_param_list);\n}",
      "lines": 18,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "remove_params": {
      "start_point": [
        173,
        0
      ],
      "end_point": [
        205,
        1
      ],
      "content": "void\nremove_params(NODE *func)\n{\n\tNODE *parms, *p;\n\tint i, pcount;\n\n\tif (func == NULL)\n\t\treturn;\n\n\tassert(func->type == Node_func);\n\n\tif (   (pcount = func->param_cnt) <= 0\n\t    || (parms = func->fparms) == NULL)\n\t\treturn;\n\n\tfor (i = pcount - 1; i >= 0; i--) {\n\t\tNODE *tmp;\n\t\tNODE *tmp2;\n\n\t\tp = parms + i;\n\t\tassert(p->type == Node_param_list);\n\t\ttmp = make_string(p->vname, strlen(p->vname));\n\t\ttmp2 = in_array(param_table, tmp);\n\t\tif (tmp2 != NULL && tmp2->dup_ent != NULL)\n\t\t\ttmp2->dup_ent = tmp2->dup_ent->dup_ent;\n\t\telse\n\t\t\t(void) assoc_remove(param_table, tmp);\n\n\t\tunref(tmp);\n\t}\n\n\tassoc_clear(param_table);\t/* shazzam! */\n}",
      "lines": 33,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "remove_symbol": {
      "start_point": [
        210,
        0
      ],
      "end_point": [
        223,
        1
      ],
      "content": "NODE *\nremove_symbol(NODE *r)\n{\n\tNODE *n = in_array(symbol_table, r);\n\n\tif (n == NULL)\n\t\treturn n;\n\n\tn = dupnode(n);\n\n\t(void) assoc_remove(symbol_table, r);\n\n\treturn n;\n}",
      "lines": 14,
      "depth": 7,
      "decorators": [
        "NODE",
        "*\nremove_symbol(NODE *r)",
        "*"
      ]
    },
    "destroy_symbol": {
      "start_point": [
        231,
        0
      ],
      "end_point": [
        273,
        1
      ],
      "content": "void\ndestroy_symbol(NODE *r)\n{\n\tr = remove_symbol(r);\n\tif (r == NULL)\n\t\treturn;\n\n\tswitch (r->type) {\n\tcase Node_func:\n\t\tif (r->param_cnt > 0) {\n\t\t\tNODE *n;\n\t\t\tint i;\n\t\t\tint pcount = r->param_cnt;\n\n\t\t\t/* function parameters of type Node_param_list */\n\t\t\tfor (i = 0; i < pcount; i++) {\n\t\t\t\tn = r->fparms + i;\n\t\t\t\tefree(n->param);\n\t\t\t}\n\t\t\tefree(r->fparms);\n\t\t}\n\t\tbreak;\n\n\tcase Node_ext_func:\n\t\tbcfree(r->code_ptr);\n\t\tbreak;\n\n\tcase Node_var_array:\n\t\tassoc_clear(r);\n\t\tbreak;\n\n\tcase Node_var:\n\t\tunref(r->var_value);\n\t\tbreak;\n\n\tdefault:\n\t\t/* Node_param_list -- YYABORT */\n\t\tbreak;\t/* use break so that storage is freed */\n\t}\n\n\tefree(r->vname);\n\tfreenode(r);\n}",
      "lines": 43,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "make_symbol": {
      "start_point": [
        278,
        0
      ],
      "end_point": [
        293,
        1
      ],
      "content": "static NODE *\nmake_symbol(const char *name, NODETYPE type)\n{\n\tNODE *r;\n\n\tgetnode(r);\n\tmemset(r, '\\0', sizeof(NODE));\n\tif (type == Node_var_array)\n\t\tnull_array(r);\n\telse if (type == Node_var)\n\t\tr->var_value = dupnode(Nnull_string);\n\tr->vname = (char *) name;\n\tr->type = type;\n\n\treturn r;\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "NODE",
        "*\nmake_symbol(const char *name, NODETYPE type)",
        "*"
      ]
    },
    "install": {
      "start_point": [
        297,
        0
      ],
      "end_point": [
        349,
        1
      ],
      "content": "static NODE *\ninstall(const char *name, NODE *parm, NODETYPE type)\n{\n\tNODE *r;\n\tNODE **aptr;\n\tNODE *table;\n\tNODE *n_name;\n\tNODE *prev;\n\n\tn_name = make_string(name, strlen(name));\n\ttable = symbol_table;\n\n\tif (type == Node_param_list) {\n\t\ttable = param_table;\n\t} else if (   type == Node_func\n\t\t   || type == Node_ext_func\n\t\t   || type == Node_builtin_func) {\n\t\ttable = func_table;\n\t} else if (installing_specials) {\n\t\ttable = global_table;\n\t}\n\n\tif (parm != NULL)\n\t\tr = parm;\n\telse {\n\t\t/* global symbol */\n\t\tr = make_symbol(name, type);\n\t\tif (type == Node_func)\n\t\t\tfunc_count++;\n\t\tif (type != Node_ext_func && type != Node_builtin_func && table != global_table)\n\t\t\tvar_count++;\t/* total, includes Node_func */\n\t}\n\n\tif (type == Node_param_list) {\n\t\tprev = in_array(table, n_name);\n\t\tif (prev == NULL)\n\t\t\tgoto simple;\n\t\tr->dup_ent = prev->dup_ent;\n\t\tprev->dup_ent = r;\n\t} else {\nsimple:\n\t\t/* the simple case */\n\t\taptr = assoc_lookup(table, n_name);\n\t\tunref(*aptr);\n\t\t*aptr = r;\n\t}\n\tunref(n_name);\n\n\tif (install_func)\n\t\t(*install_func)(r);\n\n\treturn r;\n}",
      "lines": 53,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "NODE",
        "*\ninstall(const char *name, NODE *parm, NODETYPE type)",
        "*"
      ]
    },
    "comp_symbol": {
      "start_point": [
        353,
        0
      ],
      "end_point": [
        365,
        1
      ],
      "content": "static int\ncomp_symbol(const void *v1, const void *v2)\n{\n\tconst NODE *const *npp1, *const *npp2;\n\tconst NODE *n1, *n2;\n\n\tnpp1 = (const NODE *const *) v1;\n\tnpp2 = (const NODE *const *) v2;\n\tn1 = *npp1;\n\tn2 = *npp2;\n\n\treturn strcmp(n1->vname, n2->vname);\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "get_symbols": {
      "start_point": [
        372,
        0
      ],
      "end_point": [
        431,
        1
      ],
      "content": "static NODE **\nget_symbols(SYMBOL_TYPE what, bool sort)\n{\n\tint i;\n\tNODE **table;\n\tNODE **list;\n\tNODE *r;\n\tlong count = 0;\n\tlong max;\n\tNODE *the_table;\n\n\t/*\n\t * assoc_list() returns an array with two elements per awk array\n\t * element. Elements i and i+1 in the C array represent the key\n\t * and value of element j in the awk array. Thus the loops use += 2\n\t * to go through the awk array.\n\t */\n\n\tif (what == FUNCTION) {\n\t\tthe_table = func_table;\n\t\tmax = the_table->table_size * 2;\n\n\t\tlist = assoc_list(the_table, \"@unsorted\", ASORTI);\n\t\temalloc(table, NODE **, (func_count + 1) * sizeof(NODE *), \"get_symbols\");\n\n\t\tfor (i = count = 0; i < max; i += 2) {\n\t\t\tr = list[i+1];\n\t\t\tif (r->type == Node_ext_func || r->type == Node_builtin_func)\n\t\t\t\tcontinue;\n\t\t\tassert(r->type == Node_func);\n\t\t\ttable[count++] = r;\n\t\t}\n\t} else {\t/* what == VARIABLE */\n\t\tupdate_global_values();\n\n\t\tthe_table = symbol_table;\n\t\tmax = the_table->table_size * 2;\n\n\t\tlist = assoc_list(the_table, \"@unsorted\", ASORTI);\n\t\t/* add three: one for FUNCTAB, one for SYMTAB, and one for a final NULL */\n\t\temalloc(table, NODE **, (var_count + 1 + 1 + 1) * sizeof(NODE *), \"get_symbols\");\n\n\t\tfor (i = count = 0; i < max; i += 2) {\n\t\t\tr = list[i+1];\n\t\t\tif (r->type == Node_val)\t/* non-variable in SYMTAB */\n\t\t\t\tcontinue;\n\t\t\ttable[count++] = r;\n\t\t}\n\n\t\ttable[count++] = func_table;\n\t\ttable[count++] = symbol_table;\n\t}\n\n\tefree(list);\n\n\tif (sort && count > 1)\n\t\tqsort(table, count, sizeof(NODE *), comp_symbol);\t/* Shazzam! */\n\ttable[count] = NULL; /* null terminate the list */\n\treturn table;\n}",
      "lines": 60,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "NODE",
        "**\nget_symbols(SYMBOL_TYPE what, bool sort)",
        "*",
        "*\nget_symbols(SYMBOL_TYPE what, bool sort)",
        "*"
      ]
    },
    "variable_list": {
      "start_point": [
        436,
        0
      ],
      "end_point": [
        440,
        1
      ],
      "content": "NODE **\nvariable_list()\n{\n\treturn get_symbols(VARIABLE, true);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "NODE",
        "**\nvariable_list()",
        "*",
        "*\nvariable_list()",
        "*"
      ]
    },
    "function_list": {
      "start_point": [
        444,
        0
      ],
      "end_point": [
        448,
        1
      ],
      "content": "NODE **\nfunction_list(bool sort)\n{\n\treturn get_symbols(FUNCTION, sort);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "NODE",
        "**\nfunction_list(bool sort)",
        "*",
        "*\nfunction_list(bool sort)",
        "*"
      ]
    },
    "print_vars": {
      "start_point": [
        452,
        0
      ],
      "end_point": [
        471,
        1
      ],
      "content": "void\nprint_vars(NODE **table, int (*print_func)(FILE *, const char *, ...), FILE *fp)\n{\n\tint i;\n\tNODE *r;\n\n\tassert(table != NULL);\n\n\tfor (i = 0; (r = table[i]) != NULL; i++) {\n\t\tif (r->type == Node_func || r->type == Node_ext_func)\n\t\t\tcontinue;\n\t\tprint_func(fp, \"%s: \", r->vname);\n\t\tif (r->type == Node_var_array)\n\t\t\tprint_func(fp, \"array, %ld elements\\n\", assoc_length(r));\n\t\telse if (r->type == Node_var_new)\n\t\t\tprint_func(fp, \"untyped variable\\n\");\n\t\telse if (r->type == Node_var)\n\t\t\tvalinfo(r->var_value, print_func, fp);\n\t}\n}",
      "lines": 20,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "foreach_func": {
      "start_point": [
        476,
        0
      ],
      "end_point": [
        490,
        1
      ],
      "content": "int\nforeach_func(NODE **table, int (*pfunc)(INSTRUCTION *, void *), void *data)\n{\n\tint i;\n\tNODE *r;\n\tint ret = 0;\n\n\tassert(table != NULL);\n\n\tfor (i = 0; (r = table[i]) != NULL; i++) {\n\t\tif ((ret = pfunc(r->code_ptr, data)) != 0)\n\t\t\tbreak;\n\t}\n\treturn ret;\n}",
      "lines": 15,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "release_all_vars": {
      "start_point": [
        494,
        0
      ],
      "end_point": [
        500,
        1
      ],
      "content": "void\nrelease_all_vars()\n{\n\tassoc_clear(symbol_table);\n\tassoc_clear(func_table);\n\tassoc_clear(global_table);\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "append_symbol": {
      "start_point": [
        507,
        0
      ],
      "end_point": [
        516,
        1
      ],
      "content": "void\nappend_symbol(NODE *r)\n{\n\tNODE *p;\n\n\tgetnode(p);\n\tp->lnode = r;\n\tp->rnode = symbol_list->rnode;\n\tsymbol_list->rnode = p;\n}",
      "lines": 10,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "release_symbols": {
      "start_point": [
        520,
        0
      ],
      "end_point": [
        537,
        1
      ],
      "content": "void\nrelease_symbols(NODE *symlist, int keep_globals)\n{\n\tNODE *p, *next;\n\n\tfor (p = symlist->rnode; p != NULL; p = next) {\n\t\tif (! keep_globals) {\n\t\t\t/*\n\t\t\t * destroys globals, function, and params\n\t\t\t * if still in symbol table\n\t\t\t */\n\t\t\tdestroy_symbol(p->lnode);\n\t\t}\n\t\tnext = p->rnode;\n\t\tfreenode(p);\n\t}\n\tsymlist->rnode = NULL;\n}",
      "lines": 18,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "load_symbols": {
      "start_point": [
        541,
        0
      ],
      "end_point": [
        632,
        1
      ],
      "content": "void\nload_symbols()\n{\n\tNODE *r;\n\tNODE *tmp;\n\tNODE *sym_array;\n\tNODE **aptr;\n\tlong i, j, max;\n\tNODE *user, *extension, *untyped, *scalar, *array, *built_in;\n\tNODE **list;\n\tNODE *tables[4];\n\n\tif (PROCINFO_node == NULL)\n\t\treturn;\n\n\ttables[0] = func_table;\n\ttables[1] = symbol_table;\n\ttables[2] = global_table;\n\ttables[3] = NULL;\n\n\ttmp = make_string(\"identifiers\", 11);\n\taptr = assoc_lookup(PROCINFO_node, tmp);\n\n\tgetnode(sym_array);\n\tmemset(sym_array, '\\0', sizeof(NODE));\t/* PPC Mac OS X wants this */\n\tnull_array(sym_array);\n\n\tunref(tmp);\n\tunref(*aptr);\n\t*aptr = sym_array;\n\n\tsym_array->parent_array = PROCINFO_node;\n\tsym_array->vname = estrdup(\"identifiers\", 11);\n\n\tuser = make_string(\"user\", 4);\n\textension = make_string(\"extension\", 9);\n\tscalar = make_string(\"scalar\", 6);\n\tuntyped = make_string(\"untyped\", 7);\n\tarray = make_string(\"array\", 5);\n\tbuilt_in = make_string(\"builtin\", 7);\n\n\tfor (i = 0; tables[i] != NULL; i++) {\n\t\tlist = assoc_list(tables[i], \"@unsorted\", ASORTI);\n\t\tmax = tables[i]->table_size * 2;\n\t\tif (max == 0)\n\t\t\tcontinue;\n\t\tfor (j = 0; j < max; j += 2) {\n\t\t\tr = list[j+1];\n\t\t\tif (   r->type == Node_ext_func\n\t\t\t    || r->type == Node_func\n\t\t\t    || r->type == Node_builtin_func\n\t\t\t    || r->type == Node_var\n\t\t\t    || r->type == Node_var_array\n\t\t\t    || r->type == Node_var_new) {\n\t\t\t\ttmp = make_string(r->vname, strlen(r->vname));\n\t\t\t\taptr = assoc_lookup(sym_array, tmp);\n\t\t\t\tunref(tmp);\n\t\t\t\tunref(*aptr);\n\t\t\t\tswitch (r->type) {\n\t\t\t\tcase Node_ext_func:\n\t\t\t\t\t*aptr = dupnode(extension);\n\t\t\t\t\tbreak;\n\t\t\t\tcase Node_func:\n\t\t\t\t\t*aptr = dupnode(user);\n\t\t\t\t\tbreak;\n\t\t\t\tcase Node_builtin_func:\n\t\t\t\t\t*aptr = dupnode(built_in);\n\t\t\t\t\tbreak;\n\t\t\t\tcase Node_var:\n\t\t\t\t\t*aptr = dupnode(scalar);\n\t\t\t\t\tbreak;\n\t\t\t\tcase Node_var_array:\n\t\t\t\t\t*aptr = dupnode(array);\n\t\t\t\t\tbreak;\n\t\t\t\tcase Node_var_new:\n\t\t\t\t\t*aptr = dupnode(untyped);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tcant_happen();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tefree(list);\n\t}\n\n\tunref(user);\n\tunref(extension);\n\tunref(scalar);\n\tunref(untyped);\n\tunref(array);\n}",
      "lines": 92,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "check_param_names": {
      "start_point": [
        636,
        0
      ],
      "end_point": [
        696,
        1
      ],
      "content": "bool\ncheck_param_names(void)\n{\n\tint i, j;\n\tNODE **list;\n\tNODE *f;\n\tlong max;\n\tbool result = true;\n\tNODE n;\n\n\tif (func_table->table_size == 0)\n\t\treturn result;\n\n\tmax = func_table->table_size * 2;\n\n\tmemset(& n, 0, sizeof n);\n\tn.type = Node_val;\n\tn.flags = STRING|STRCUR;\n\tn.stfmt = STFMT_UNUSED;\n#ifdef HAVE_MPFR\n\tn.strndmode = MPFR_round_mode;\n#endif\n\n\t/*\n\t * assoc_list() returns an array with two elements per awk array\n\t * element. Elements i and i+1 in the C array represent the key\n\t * and value of element j in the awk array. Thus the loops use += 2\n\t * to go through the awk array.\n\t *\n\t * In this case, the name is in list[i], and the function is\n\t * in list[i+1]. Just what we need.\n\t */\n\n\tlist = assoc_list(func_table, \"@unsorted\", ASORTI);\n\n\tfor (i = 0; i < max; i += 2) {\n\t\tf = list[i+1];\n\t\tif (f->type == Node_builtin_func || f->param_cnt == 0)\n\t\t\tcontinue;\n\n\t\t/* loop over each param in function i */\n\t\tfor (j = 0; j < f->param_cnt; j++) {\n\t\t\t/* compare to function names */\n\n\t\t\t/* use a fake node to avoid malloc/free of make_string */\n\t\t\tn.stptr = f->fparms[j].param;\n\t\t\tn.stlen = strlen(f->fparms[j].param);\n\n\t\t\tif (in_array(func_table, & n)) {\n\t\t\t\terror(\n\t\t\t_(\"function `%s': can't use function `%s' as a parameter name\"),\n\t\t\t\t\tlist[i]->stptr,\n\t\t\t\t\tf->fparms[j].param);\n\t\t\t\tresult = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tefree(list);\n\treturn result;\n}",
      "lines": 61,
      "depth": 15,
      "decorators": [
        "bool"
      ]
    },
    "bcfree": {
      "start_point": [
        714,
        0
      ],
      "end_point": [
        722,
        1
      ],
      "content": "void\nbcfree(INSTRUCTION *cp)\n{\n\tassert(cp->pool_size >= 1 && cp->pool_size <= MAX_INSTRUCTION_ALLOC);\n\n\tcp->opcode = Op_illegal;\n\tcp->nexti = pools->pool[cp->pool_size - 1].free_list;\n\tpools->pool[cp->pool_size - 1].free_list = cp;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "bcalloc": {
      "start_point": [
        726,
        0
      ],
      "end_point": [
        755,
        1
      ],
      "content": "INSTRUCTION *\nbcalloc(OPCODE op, int size, int srcline)\n{\n\tINSTRUCTION *cp;\n\tstruct instruction_mem_pool *pool;\n\n\tassert(size >= 1 && size <= MAX_INSTRUCTION_ALLOC);\n\tpool = &pools->pool[size - 1];\n\n\tif (pool->free_list != NULL) {\n\t\tcp = pool->free_list;\n\t\tpool->free_list = cp->nexti;\n\t} else if (pool->free_space && pool->free_space + size <= & pool->block_list->i[INSTR_CHUNK]) {\n\t\tcp = pool->free_space;\n\t\tpool->free_space += size;\n\t} else {\n\t\tstruct instruction_block *block;\n\t\temalloc(block, struct instruction_block *, sizeof(struct instruction_block), \"bcalloc\");\n\t\tblock->next = pool->block_list;\n\t\tpool->block_list = block;\n\t\tcp = &block->i[0];\n\t\tpool->free_space = &block->i[size];\n\t}\n\n\tmemset(cp, 0, size * sizeof(INSTRUCTION));\n\tcp->pool_size = size;\n\tcp->opcode = op;\n\tcp->source_line = srcline;\n\treturn cp;\n}",
      "lines": 30,
      "depth": 12,
      "decorators": [
        "INSTRUCTION",
        "*\nbcalloc(OPCODE op, int size, int srcline)",
        "*"
      ]
    },
    "new_context": {
      "start_point": [
        759,
        0
      ],
      "end_point": [
        769,
        1
      ],
      "content": "AWK_CONTEXT *\nnew_context()\n{\n\tAWK_CONTEXT *ctxt;\n\n\tezalloc(ctxt, AWK_CONTEXT *, sizeof(AWK_CONTEXT), \"new_context\");\n\tctxt->srcfiles.next = ctxt->srcfiles.prev = & ctxt->srcfiles;\n\tctxt->rule_list.opcode = Op_list;\n\tctxt->rule_list.lasti = & ctxt->rule_list;\n\treturn ctxt;\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "AWK_CONTEXT",
        "*\nnew_context()",
        "*"
      ]
    },
    "set_context": {
      "start_point": [
        773,
        0
      ],
      "end_point": [
        782,
        1
      ],
      "content": "static void\nset_context(AWK_CONTEXT *ctxt)\n{\n\tpools = & ctxt->pools;\n\tsymbol_list = & ctxt->symbols;\n\tsrcfiles = & ctxt->srcfiles;\n\trule_list = & ctxt->rule_list;\n\tinstall_func = ctxt->install_func;\n\tcurr_ctxt = ctxt;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "push_context": {
      "start_point": [
        792,
        0
      ],
      "end_point": [
        805,
        1
      ],
      "content": "void\npush_context(AWK_CONTEXT *ctxt)\n{\n\tctxt->prev = curr_ctxt;\n\t/* save current source and sourceline */\n\tif (curr_ctxt != NULL) {\n\t\tcurr_ctxt->sourceline = sourceline;\n\t\tcurr_ctxt->source = source;\n\t}\n\tsourceline = 0;\n\tsource = NULL;\n\tset_context(ctxt);\n\tctxt_level++;\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "pop_context": {
      "start_point": [
        809,
        0
      ],
      "end_point": [
        823,
        1
      ],
      "content": "void\npop_context()\n{\n\tAWK_CONTEXT *ctxt;\n\n\tassert(curr_ctxt != NULL);\n\tif (curr_ctxt->prev == NULL)\n\t\tfatal(_(\"can not pop main context\"));\n\tctxt = curr_ctxt->prev;\n\t/* restore source and sourceline */\n\tsourceline = ctxt->sourceline;\n\tsource = ctxt->source;\n\tset_context(ctxt);\n\tctxt_level--;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "in_main_context": {
      "start_point": [
        827,
        0
      ],
      "end_point": [
        832,
        1
      ],
      "content": "int\nin_main_context()\n{\n\tassert(ctxt_level > 0);\n\treturn (ctxt_level == 1);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "free_context": {
      "start_point": [
        836,
        0
      ],
      "end_point": [
        865,
        1
      ],
      "content": "void\nfree_context(AWK_CONTEXT *ctxt, bool keep_globals)\n{\n\tSRCFILE *s, *sn;\n\n\tif (ctxt == NULL)\n\t\treturn;\n\n\tassert(curr_ctxt != ctxt);\n\n \t/* free all code including function codes */\n\n\tfree_bcpool(& ctxt->pools);\n\n\t/* free symbols */\n\n\trelease_symbols(& ctxt->symbols, keep_globals);\n\n\t/* free srcfiles */\n\n\tfor (s = & ctxt->srcfiles; s != & ctxt->srcfiles; s = sn) {\n\t\tsn = s->next;\n\t\tif (s->stype != SRC_CMDLINE && s->stype != SRC_STDIN)\n\t\t\tefree(s->fullpath);\n\t\tefree(s->src);\n\t\tefree(s);\n\t}\n\n\tefree(ctxt);\n}",
      "lines": 30,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "free_bc_internal": {
      "start_point": [
        869,
        0
      ],
      "end_point": [
        913,
        1
      ],
      "content": "static void\nfree_bc_internal(INSTRUCTION *cp)\n{\n\tNODE *m;\n\n\tswitch(cp->opcode) {\n\tcase Op_func_call:\n\t\tif (cp->func_name != NULL)\n\t\t\tefree(cp->func_name);\n\t\tbreak;\n\tcase Op_push_re:\n\tcase Op_match_rec:\n\tcase Op_match:\n\tcase Op_nomatch:\n\t\tm = cp->memory;\n\t\tif (m->re_reg[0] != NULL)\n\t\t\trefree(m->re_reg[0]);\n\t\tif (m->re_reg[1] != NULL)\n\t\t\trefree(m->re_reg[1]);\n\t\tif (m->re_exp != NULL)\n\t\t\tunref(m->re_exp);\n\t\tif (m->re_text != NULL)\n\t\t\tunref(m->re_text);\n\t\tfreenode(m);\n\t\tbreak;\n\tcase Op_token:\n\t\t/* token lost during error recovery in yyparse */\n\t\tif (cp->lextok != NULL)\n\t\t\tefree(cp->lextok);\n\t\tbreak;\n\tcase Op_push_i:\n\t\tm = cp->memory;\n\t\tunref(m);\n\t\tbreak;\n\tcase Op_store_var:\n\t\tm = cp->initval;\n\t\tif (m != NULL)\n\t\t\tunref(m);\n\t\tbreak;\n\tcase Op_illegal:\n\t\tcant_happen();\n\tdefault:\n\t\tbreak;\n\t}\n}",
      "lines": 45,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "free_bc_mempool": {
      "start_point": [
        917,
        0
      ],
      "end_point": [
        935,
        1
      ],
      "content": "static void\nfree_bc_mempool(struct instruction_mem_pool *pool, int size)\n{\n\tbool first = true;\n\tstruct instruction_block *block, *next;\n\n\tfor (block = pool->block_list; block; block = next) {\n\t\tINSTRUCTION *cp, *end;\n\n\t\tend = (first ? pool->free_space : & block->i[INSTR_CHUNK]);\n\t\tfor (cp = & block->i[0]; cp + size <= end; cp += size) {\n\t\t\tif (cp->opcode != Op_illegal)\n\t\t\t\tfree_bc_internal(cp);\n\t\t}\n\t\tnext = block->next;\n\t\tefree(block);\n\t\tfirst = false;\n\t}\n}",
      "lines": 19,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "free_bcpool": {
      "start_point": [
        940,
        0
      ],
      "end_point": [
        947,
        1
      ],
      "content": "static void\nfree_bcpool(INSTRUCTION_POOL *pl)\n{\n\tint i;\n\n\tfor (i = 0; i < MAX_INSTRUCTION_ALLOC; i++)\n\t\tfree_bc_mempool(& pl->pool[i], i + 1);\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "gawk/gawk-4.2.1/version.c": {},
  "gawk/gawk-4.2.1/awklib/eg/lib/grcat.c": {
    "main": [
      {
        "start_point": [
          20,
          0
        ],
        "end_point": [
          20,
          24
        ],
        "content": "int main() { return 0; }",
        "lines": 1,
        "depth": 4,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          25,
          0
        ],
        "end_point": [
          47,
          1
        ],
        "content": "int\nmain(int argc, char **argv)\n{\n    struct group *g;\n    int i;\n\n    while ((g = getgrent()) != NULL) {\n#ifdef HAVE_STRUCT_GROUP_GR_PASSWD\n        printf(\"%s:%s:%ld:\", g->gr_name, g->gr_passwd,\n                                     (long) g->gr_gid);\n#else\n        printf(\"%s:*:%ld:\", g->gr_name, (long) g->gr_gid);\n#endif\n        for (i = 0; g->gr_mem[i] != NULL; i++) {\n            printf(\"%s\", g->gr_mem[i]);\n            if (g->gr_mem[i+1] != NULL)\n                putchar(',');\n        }\n        putchar('\\n');\n    }\n    endgrent();\n    return 0;\n}",
        "lines": 23,
        "depth": 13,
        "decorators": [
          "int"
        ]
      }
    ]
  },
  "gawk/gawk-4.2.1/awklib/eg/lib/pwcat.c": {
    "main": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "int\nmain(int argc, char **argv)\n{\n    struct passwd *p;\n\n    while ((p = getpwent()) != NULL)\n#ifdef HAVE_STRUCT_PASSWD_PW_PASSWD\n        printf(\"%s:%s:%ld:%ld:%s:%s:%s\\n\",\n            p->pw_name, p->pw_passwd, (long) p->pw_uid,\n            (long) p->pw_gid, p->pw_gecos, p->pw_dir, p->pw_shell);\n#else\n        printf(\"%s:*:%ld:%ld:%s:%s\\n\",\n            p->pw_name, (long) p->pw_uid,\n            (long) p->pw_gid, p->pw_dir, p->pw_shell);\n#endif\n\n    endpwent();\n    return 0;\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "gawk/gawk-4.2.1/extension/ext_custom.h": {},
  "gawk/gawk-4.2.1/extension/filefuncs.c": {
    "get_inode": {
      "start_point": [
        124,
        0
      ],
      "end_point": [
        142,
        1
      ],
      "content": "static long long\nget_inode(const char *fname)\n{\n\tHANDLE fh;\n\tBY_HANDLE_FILE_INFORMATION info;\n\n\tfh = CreateFile(fname, 0, 0, NULL, OPEN_EXISTING,\n\t\t\tFILE_FLAG_BACKUP_SEMANTICS, NULL);\n\tif (fh == INVALID_HANDLE_VALUE)\n\t\treturn 0;\n\tif (GetFileInformationByHandle(fh, &info)) {\n\t\tlong long inode = info.nFileIndexHigh;\n\n\t\tinode <<= 32;\n\t\tinode += info.nFileIndexLow;\n\t\treturn inode;\n\t}\n\treturn 0;\n}",
      "lines": 19,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "long long",
        "long",
        "long"
      ]
    },
    "do_chdir": {
      "start_point": [
        155,
        0
      ],
      "end_point": [
        170,
        1
      ],
      "content": "static awk_value_t *\ndo_chdir(int nargs, awk_value_t *result, struct awk_ext_func *unused)\n{\n\tawk_value_t newdir;\n\tint ret = -1;\n\n\tassert(result != NULL);\n\n\tif (get_argument(0, AWK_STRING, & newdir)) {\n\t\tret = chdir(newdir.str_value.str);\n\t\tif (ret < 0)\n\t\t\tupdate_ERRNO_int(errno);\n\t}\n\n\treturn make_number(ret, result);\n}",
      "lines": 16,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "awk_value_t",
        "*\ndo_chdir(int nargs, awk_value_t *result, struct awk_ext_func *unused)",
        "*"
      ]
    },
    "format_mode": {
      "start_point": [
        174,
        0
      ],
      "end_point": [
        251,
        1
      ],
      "content": "static char *\nformat_mode(unsigned long fmode)\n{\n\tstatic char outbuf[12];\n\tstatic struct ftype_map {\n\t\tunsigned int mask;\n\t\tint charval;\n\t} ftype_map[] = {\n\t\t{ S_IFREG, '-' },\t/* redundant */\n\t\t{ S_IFBLK, 'b' },\n\t\t{ S_IFCHR, 'c' },\n\t\t{ S_IFDIR, 'd' },\n#ifdef S_IFSOCK\n\t\t{ S_IFSOCK, 's' },\n#endif\n#ifdef S_IFIFO\n\t\t{ S_IFIFO, 'p' },\n#endif\n#ifdef S_IFLNK\n\t\t{ S_IFLNK, 'l' },\n#endif\n#ifdef S_IFDOOR\t/* Solaris weirdness */\n\t\t{ S_IFDOOR, 'D' },\n#endif /* S_IFDOOR */\n\t};\n\tstatic struct mode_map {\n\t\tunsigned int mask;\n\t\tint rep;\n\t} map[] = {\n\t\t{ S_IRUSR, 'r' }, { S_IWUSR, 'w' }, { S_IXUSR, 'x' },\n\t\t{ S_IRGRP, 'r' }, { S_IWGRP, 'w' }, { S_IXGRP, 'x' },\n\t\t{ S_IROTH, 'r' }, { S_IWOTH, 'w' }, { S_IXOTH, 'x' },\n\t};\n\tstatic struct setuid_map {\n\t\tunsigned int mask;\n\t\tint index;\n\t\tint small_rep;\n\t\tint big_rep;\n\t} setuid_map[] = {\n\t\t{ S_ISUID, 3, 's', 'S' }, /* setuid bit */\n\t\t{ S_ISGID, 6, 's', 'l' }, /* setgid without execute == locking */\n\t\t{ S_ISVTX, 9, 't', 'T' }, /* the so-called \"sticky\" bit */\n\t};\n\tint i, j, k;\n\n\tstrcpy(outbuf, \"----------\");\n\n\t/* first, get the file type */\n\ti = 0;\n\tfor (j = 0, k = sizeof(ftype_map)/sizeof(ftype_map[0]); j < k; j++) {\n\t\tif ((fmode & S_IFMT) == ftype_map[j].mask) {\n\t\t\toutbuf[i] = ftype_map[j].charval;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* now the permissions */\n\tfor (j = 0, k = sizeof(map)/sizeof(map[0]); j < k; j++) {\n\t\ti++;\n\t\tif ((fmode & map[j].mask) != 0)\n\t\t\toutbuf[i] = map[j].rep;\n\t}\n\n\ti++;\n\toutbuf[i] = '\\0';\n\n\t/* tweaks for the setuid / setgid / sticky bits */\n\tfor (j = 0, k = sizeof(setuid_map)/sizeof(setuid_map[0]); j < k; j++) {\n\t\tif (fmode & setuid_map[j].mask) {\n\t\t\tif (outbuf[setuid_map[j].index] == 'x')\n\t\t\t\toutbuf[setuid_map[j].index] = setuid_map[j].small_rep;\n\t\t\telse\n\t\t\t\toutbuf[setuid_map[j].index] = setuid_map[j].big_rep;\n\t\t}\n\t}\n\n\treturn outbuf;\n}",
      "lines": 78,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nformat_mode(unsigned long fmode)",
        "*"
      ]
    },
    "read_symlink": {
      "start_point": [
        268,
        0
      ],
      "end_point": [
        307,
        1
      ],
      "content": "static char *\nread_symlink(const char *fname, size_t bufsize, ssize_t *linksize)\n{\n\tif (bufsize)\n\t\tbufsize += 2;\n\telse\n\t\tbufsize = BUFSIZ * 2;\n\n\t/* Make sure that bufsize >= 2 and within range */\n\tif (bufsize > MAXSIZE || bufsize < 2)\n\t\tbufsize = MAXSIZE;\n\n\twhile (1) {\n\t\tchar *buf;\n\n\t\temalloc(buf, char *, bufsize, \"read_symlink\");\n\t\tif ((*linksize = readlink(fname, buf, bufsize)) < 0) {\n\t\t\t/* On AIX 5L v5.3 and HP-UX 11i v2 04/09, readlink\n\t\t\t   returns -1 with errno == ERANGE if the buffer is\n\t\t\t   too small.  */\n\t\t\tif (errno != ERANGE) {\n\t\t\t\tgawk_free(buf);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t\t/* N.B. This test is safe because bufsize must be >= 2 */\n\t\telse if ((size_t)*linksize <= bufsize-2) {\n\t\t\tbuf[*linksize] = '\\0';\n\t\t\treturn buf;\n\t\t}\n\t\tgawk_free(buf);\n\t\tif (bufsize <= MAXSIZE/2)\n\t\t\tbufsize *= 2;\n\t\telse if (bufsize < MAXSIZE)\n\t\t\tbufsize = MAXSIZE;\n\t\telse\n\t\t\treturn NULL;\n\t}\n\treturn NULL;\n}",
      "lines": 40,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nread_symlink(const char *fname, size_t bufsize, ssize_t *linksize)",
        "*"
      ]
    },
    "device_blocksize": {
      "start_point": [
        312,
        0
      ],
      "end_point": [
        332,
        1
      ],
      "content": "static int\ndevice_blocksize()\n{\n\t/* some of this derived from GNULIB stat-size.h */\n#if defined(DEV_BSIZE)\n\t/* <sys/param.h>, most systems */\n\treturn DEV_BSIZE;\n#elif defined(S_BLKSIZE)\n\t/* <sys/stat.h>, BSD systems */\n\treturn S_BLKSIZE;\n#elif defined hpux || defined __hpux__ || defined __hpux\n\treturn 1024;\n#elif defined _AIX && defined _I386\n\t/* AIX PS/2 counts st_blocks in 4K units.  */\n\treturn 4 * 1024;\n#elif defined __MINGW32__\n\treturn 1024;\n#else\n\treturn 512;\n#endif\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "array_set": {
      "start_point": [
        336,
        0
      ],
      "end_point": [
        345,
        1
      ],
      "content": "static void\narray_set(awk_array_t array, const char *sub, awk_value_t *value)\n{\n\tawk_value_t index;\n\n\tset_array_element(array,\n\t\t\tmake_const_string(sub, strlen(sub), & index),\n\t\t\tvalue);\n\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "array_set_numeric": {
      "start_point": [
        349,
        0
      ],
      "end_point": [
        355,
        1
      ],
      "content": "static void\narray_set_numeric(awk_array_t array, const char *sub, double num)\n{\n\tawk_value_t tmp;\n\n\tarray_set(array, sub, make_number(num, & tmp));\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "fill_stat_array": {
      "start_point": [
        359,
        0
      ],
      "end_point": [
        456,
        1
      ],
      "content": "static int\nfill_stat_array(const char *name, awk_array_t array, struct stat *sbuf)\n{\n\tchar *pmode;\t/* printable mode */\n\tconst char *type = \"unknown\";\n\tawk_value_t tmp;\n\tstatic struct ftype_map {\n\t\tunsigned int mask;\n\t\tconst char *type;\n\t} ftype_map[] = {\n\t\t{ S_IFREG, \"file\" },\n\t\t{ S_IFBLK, \"blockdev\" },\n\t\t{ S_IFCHR, \"chardev\" },\n\t\t{ S_IFDIR, \"directory\" },\n#ifdef S_IFSOCK\n\t\t{ S_IFSOCK, \"socket\" },\n#endif\n#ifdef S_IFIFO\n\t\t{ S_IFIFO, \"fifo\" },\n#endif\n#ifdef S_IFLNK\n\t\t{ S_IFLNK, \"symlink\" },\n#endif\n#ifdef S_IFDOOR\t/* Solaris weirdness */\n\t\t{ S_IFDOOR, \"door\" },\n#endif /* S_IFDOOR */\n\t};\n\tint j, k;\n\n\t/* empty out the array */\n\tclear_array(array);\n\n\t/* fill in the array */\n\tarray_set(array, \"name\", make_const_string(name, strlen(name), & tmp));\n\tarray_set_numeric(array, \"dev\", sbuf->st_dev);\n#ifdef __MINGW32__\n\tarray_set_numeric(array, \"ino\", (double)get_inode (name));\n#else\n\tarray_set_numeric(array, \"ino\", sbuf->st_ino);\n#endif\n\tarray_set_numeric(array, \"mode\", sbuf->st_mode);\n\tarray_set_numeric(array, \"nlink\", sbuf->st_nlink);\n\tarray_set_numeric(array, \"uid\", sbuf->st_uid);\n\tarray_set_numeric(array, \"gid\", sbuf->st_gid);\n\tarray_set_numeric(array, \"size\", sbuf->st_size);\n#ifdef __MINGW32__\n\tarray_set_numeric(array, \"blocks\", (sbuf->st_size + 4095) / 4096);\n#else\n\tarray_set_numeric(array, \"blocks\", sbuf->st_blocks);\n#endif\n\tarray_set_numeric(array, \"atime\", sbuf->st_atime);\n\tarray_set_numeric(array, \"mtime\", sbuf->st_mtime);\n\tarray_set_numeric(array, \"ctime\", sbuf->st_ctime);\n\n\t/* for block and character devices, add rdev, major and minor numbers */\n\tif (S_ISBLK(sbuf->st_mode) || S_ISCHR(sbuf->st_mode)) {\n\t\tarray_set_numeric(array, \"rdev\", sbuf->st_rdev);\n\t\tarray_set_numeric(array, \"major\", major(sbuf->st_rdev));\n\t\tarray_set_numeric(array, \"minor\", minor(sbuf->st_rdev));\n\t}\n\n#ifdef HAVE_STRUCT_STAT_ST_BLKSIZE\n\tarray_set_numeric(array, \"blksize\", sbuf->st_blksize);\n#elif defined(__MINGW32__)\n\tarray_set_numeric(array, \"blksize\", 4096);\n#endif /* HAVE_STRUCT_STAT_ST_BLKSIZE */\n\n\t/* the size of a block for st_blocks */\n\tarray_set_numeric(array, \"devbsize\", device_blocksize());\n\n\tpmode = format_mode(sbuf->st_mode);\n\tarray_set(array, \"pmode\", make_const_string(pmode, strlen(pmode), & tmp));\n\n\t/* for symbolic links, add a linkval field */\n\tif (S_ISLNK(sbuf->st_mode)) {\n\t\tchar *buf;\n\t\tssize_t linksize;\n\n\t\tif ((buf = read_symlink(name, sbuf->st_size,\n\t\t\t\t\t& linksize)) != NULL)\n\t\t\tarray_set(array, \"linkval\", make_malloced_string(buf, linksize, & tmp));\n\t\telse\n\t\t\twarning(ext_id, _(\"stat: unable to read symbolic link `%s'\"), name);\n\t}\n\n\t/* add a type field */\n\ttype = \"unknown\";\t/* shouldn't happen */\n\tfor (j = 0, k = sizeof(ftype_map)/sizeof(ftype_map[0]); j < k; j++) {\n\t\tif ((sbuf->st_mode & S_IFMT) == ftype_map[j].mask) {\n\t\t\ttype = ftype_map[j].type;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tarray_set(array, \"type\", make_const_string(type, strlen(type), & tmp));\n\n\treturn 0;\n}",
      "lines": 98,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "do_stat": {
      "start_point": [
        460,
        0
      ],
      "end_point": [
        499,
        1
      ],
      "content": "static awk_value_t *\ndo_stat(int nargs, awk_value_t *result, struct awk_ext_func *unused)\n{\n\tawk_value_t file_param, array_param;\n\tchar *name;\n\tawk_array_t array;\n\tint ret;\n\tstruct stat sbuf;\n\tint (*statfunc)(const char *path, struct stat *sbuf) = lstat;\t/* default */\n\n\tassert(result != NULL);\n\n\t/* file is first arg, array to hold results is second */\n\tif (   ! get_argument(0, AWK_STRING, & file_param)\n\t    || ! get_argument(1, AWK_ARRAY, & array_param)) {\n\t\twarning(ext_id, _(\"stat: bad parameters\"));\n\t\treturn make_number(-1, result);\n\t}\n\n\tif (nargs == 3) {\n\t\tstatfunc = stat;\n\t}\n\n\tname = file_param.str_value.str;\n\tarray = array_param.array_cookie;\n\n\t/* always empty out the array */\n\tclear_array(array);\n\n\t/* stat the file; if error, set ERRNO and return */\n\tret = statfunc(name, & sbuf);\n\tif (ret < 0) {\n\t\tupdate_ERRNO_int(errno);\n\t\treturn make_number(ret, result);\n\t}\n\n\tret = fill_stat_array(name, array, & sbuf);\n\n\treturn make_number(ret, result);\n}",
      "lines": 40,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "awk_value_t",
        "*\ndo_stat(int nargs, awk_value_t *result, struct awk_ext_func *unused)",
        "*"
      ]
    },
    "do_statvfs": {
      "start_point": [
        505,
        0
      ],
      "end_point": [
        552,
        1
      ],
      "content": "static awk_value_t *\ndo_statvfs(int nargs, awk_value_t *result, struct awk_ext_func *unused)\n{\n\tawk_value_t file_param, array_param;\n\tchar *name;\n\tawk_array_t array;\n\tint ret;\n\tstruct statvfs vfsbuf;\n\n\tassert(result != NULL);\n\n\t/* file is first arg, array to hold results is second */\n\tif (   ! get_argument(0, AWK_STRING, & file_param)\n\t    || ! get_argument(1, AWK_ARRAY, & array_param)) {\n\t\twarning(ext_id, _(\"stat: bad parameters\"));\n\t\treturn make_number(-1, result);\n\t}\n\n\tname = file_param.str_value.str;\n\tarray = array_param.array_cookie;\n\n\t/* always empty out the array */\n\tclear_array(array);\n\n\t/* stat the file; if error, set ERRNO and return */\n\tret = statvfs(name, & vfsbuf);\n\tif (ret < 0) {\n\t\tupdate_ERRNO_int(errno);\n\t\treturn make_number(ret, result);\n\t}\n\n\tarray_set_numeric(array, \"bsize\", vfsbuf.f_bsize);\t/* filesystem block size */\n\tarray_set_numeric(array, \"frsize\", vfsbuf.f_frsize);\t/* fragment size */\n\tarray_set_numeric(array, \"blocks\", vfsbuf.f_blocks);\t/* size of fs in f_frsize units */\n\tarray_set_numeric(array, \"bfree\", vfsbuf.f_bfree);\t/* # free blocks */\n\tarray_set_numeric(array, \"bavail\", vfsbuf.f_bavail);\t/* # free blocks for unprivileged users */\n\tarray_set_numeric(array, \"files\", vfsbuf.f_files);\t/* # inodes */\n\tarray_set_numeric(array, \"ffree\", vfsbuf.f_ffree);\t/* # free inodes */\n\tarray_set_numeric(array, \"favail\", vfsbuf.f_favail);\t/* # free inodes for unprivileged users */\n#ifndef _AIX\n\tarray_set_numeric(array, \"fsid\", vfsbuf.f_fsid);\t/* filesystem ID */\n#endif\n\tarray_set_numeric(array, \"flag\", vfsbuf.f_flag);\t/* mount flags */\n\tarray_set_numeric(array, \"namemax\", vfsbuf.f_namemax);\t/* maximum filename length */\n\n\n\treturn make_number(ret, result);\n}",
      "lines": 48,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "awk_value_t",
        "*\ndo_statvfs(int nargs, awk_value_t *result, struct awk_ext_func *unused)",
        "*"
      ]
    },
    "init_filefuncs": {
      "start_point": [
        557,
        0
      ],
      "end_point": [
        590,
        1
      ],
      "content": "static awk_bool_t\ninit_filefuncs(void)\n{\n\tint errors = 0;\n\tint i;\n\tawk_value_t value;\n\n#ifndef __MINGW32__\n\t/* at least right now, only FTS needs initializing */\n\tstatic struct flagtab {\n\t\tconst char *name;\n\t\tint value;\n\t} opentab[] = {\n#define ENTRY(x)\t{ #x, x }\n\t\tENTRY(FTS_COMFOLLOW),\n\t\tENTRY(FTS_LOGICAL),\n\t\tENTRY(FTS_NOCHDIR),\n\t\tENTRY(FTS_PHYSICAL),\n\t\tENTRY(FTS_SEEDOT),\n\t\tENTRY(FTS_XDEV),\n\t\t{ NULL, 0 }\n\t};\n\n\tfor (i = 0; opentab[i].name != NULL; i++) {\n\t\t(void) make_number(opentab[i].value, & value);\n\t\tif (! sym_update(opentab[i].name, & value)) {\n\t\t\twarning(ext_id, _(\"fts init: could not create variable %s\"),\n\t\t\t\t\topentab[i].name);\n\t\t\terrors++;\n\t\t}\n\t}\n#endif\n\treturn errors == 0;\n}",
      "lines": 34,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "awk_bool_t"
      ]
    },
    "do_fts": [
      {
        "start_point": [
          601,
          0
        ],
        "end_point": [
          607,
          1
        ],
        "content": "static awk_value_t *\ndo_fts(int nargs, awk_value_t *result, struct awk_ext_func *unused)\n{\n\tfatal(ext_id, _(\"fts is not supported on this system\"));\n\n\treturn NULL;\t/* for the compiler */\n}",
        "lines": 7,
        "depth": 9,
        "decorators": [
          "static",
          "static",
          "awk_value_t",
          "*\ndo_fts(int nargs, awk_value_t *result, struct awk_ext_func *unused)",
          "*"
        ]
      },
      {
        "start_point": [
          816,
          0
        ],
        "end_point": [
          911,
          1
        ],
        "content": "static awk_value_t *\ndo_fts(int nargs, awk_value_t *result, struct awk_ext_func *unused)\n{\n\tawk_value_t pathlist, flagval, dest;\n\tawk_flat_array_t *path_array = NULL;\n\tchar **pathvector = NULL;\n\tFTS *hierarchy;\n\tint flags;\n\tsize_t i, count;\n\tint ret = -1;\n\tstatic const int mask = (\n\t\t  FTS_COMFOLLOW | FTS_LOGICAL | FTS_NOCHDIR | FTS_PHYSICAL\n\t\t| FTS_SEEDOT | FTS_XDEV);\n\n\tassert(result != NULL);\n\tfts_errors = 0;\t\t/* ensure a fresh start */\n\n\tif (nargs > 3)\n\t\tlintwarn(ext_id, _(\"fts: called with incorrect number of arguments, expecting 3\"));\n\n\tif (! get_argument(0, AWK_ARRAY, & pathlist)) {\n\t\twarning(ext_id, _(\"fts: bad first parameter\"));\n\t\tupdate_ERRNO_int(EINVAL);\n\t\tgoto out;\n\t}\n\n\tif (! get_argument(1, AWK_NUMBER, & flagval)) {\n\t\twarning(ext_id, _(\"fts: bad second parameter\"));\n\t\tupdate_ERRNO_int(EINVAL);\n\t\tgoto out;\n\t}\n\n\tif (! get_argument(2, AWK_ARRAY, & dest)) {\n\t\twarning(ext_id, _(\"fts: bad third parameter\"));\n\t\tupdate_ERRNO_int(EINVAL);\n\t\tgoto out;\n\t}\n\n\t/* flatten pathlist */\n\tif (! flatten_array(pathlist.array_cookie, & path_array)) {\n\t\twarning(ext_id, _(\"fts: could not flatten array\\n\"));\n\t\tgoto out;\n\t}\n\n\t/* check the flags first, before the array flattening */\n\n\t/* get flags */\n\tflags = flagval.num_value;\n\n\t/* enforce physical or logical but not both, and not no_stat */\n\tif ((flags & (FTS_PHYSICAL|FTS_LOGICAL)) == 0\n\t    || (flags & (FTS_PHYSICAL|FTS_LOGICAL)) == (FTS_PHYSICAL|FTS_LOGICAL)) {\n\t\tupdate_ERRNO_int(EINVAL);\n\t\tgoto out;\n\t}\n\tif ((flags & FTS_NOSTAT) != 0) {\n\t\tflags &= ~FTS_NOSTAT;\n\t\tif (do_lint)\n\t\t\tlintwarn(ext_id, _(\"fts: ignoring sneaky FTS_NOSTAT flag. nyah, nyah, nyah.\"));\n\t}\n\tflags &= mask;\t/* turn off anything else */\n\n\t/* make pathvector */\n\tcount = path_array->count + 1;\n\tezalloc(pathvector, char **, count * sizeof(char *), \"do_fts\");\n\n\t/* fill it in */\n\tcount--;\t/* ignore final NULL at end of vector */\n\tfor (i = 0; i < count; i++)\n\t\tpathvector[i] = path_array->elements[i].value.str_value.str;\n\n\n\t/* clear dest array */\n\tif (! clear_array(dest.array_cookie)) {\n\t\twarning(ext_id, _(\"fts: clear_array() failed\\n\"));\n\t\tgoto out;\n\t}\n\n\t/* let's do it! */\n\tif ((hierarchy = fts_open(pathvector, flags, NULL)) != NULL) {\n\t\tprocess(hierarchy, dest.array_cookie, (flags & FTS_SEEDOT) != 0);\n\t\tfts_close(hierarchy);\n\n\t\tif (fts_errors == 0)\n\t\t\tret = 0;\n\t} else\n\t\tupdate_ERRNO_int(errno);\n\nout:\n\tif (pathvector != NULL)\n\t\tgawk_free(pathvector);\n\tif (path_array != NULL)\n\t\t(void) release_flattened_array(pathlist.array_cookie, path_array);\n\n\treturn make_number(ret, result);\n}",
        "lines": 96,
        "depth": 12,
        "decorators": [
          "static",
          "static",
          "awk_value_t",
          "*\ndo_fts(int nargs, awk_value_t *result, struct awk_ext_func *unused)",
          "*"
        ]
      }
    ],
    "fill_stat_element": {
      "start_point": [
        615,
        0
      ],
      "end_point": [
        635,
        1
      ],
      "content": "static void\nfill_stat_element(awk_array_t element_array, const char *name, struct stat *sbuf)\n{\n\tawk_value_t index, value;\n\tawk_array_t stat_array;\n\n\tstat_array = create_array();\n\tif (stat_array == NULL) {\n\t\twarning(ext_id, _(\"fill_stat_element: could not create array\"));\n\t\tfts_errors++;\n\t\treturn;\n\t}\n\tfill_stat_array(name, stat_array, sbuf);\n\t(void) make_const_string(\"stat\", 4, & index);\n\tvalue.val_type = AWK_ARRAY;\n\tvalue.array_cookie = stat_array;\n\tif (! set_array_element(element_array, & index, & value)) {\n\t\twarning(ext_id, _(\"fill_stat_element: could not set element\"));\n\t\tfts_errors++;\n\t}\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "fill_path_element": {
      "start_point": [
        639,
        0
      ],
      "end_point": [
        650,
        1
      ],
      "content": "static void\nfill_path_element(awk_array_t element_array, const char *path)\n{\n\tawk_value_t index, value;\n\n\t(void) make_const_string(\"path\", 4, & index);\n\t(void) make_const_string(path, strlen(path), & value);\n\tif (! set_array_element(element_array, & index, & value)) {\n\t\twarning(ext_id, _(\"fill_path_element: could not set element\"));\n\t\tfts_errors++;\n\t}\n}",
      "lines": 12,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "fill_error_element": {
      "start_point": [
        654,
        0
      ],
      "end_point": [
        666,
        1
      ],
      "content": "static void\nfill_error_element(awk_array_t element_array, const int errcode)\n{\n\tawk_value_t index, value;\n\tconst char *err = strerror(errcode);\n\n\t(void) make_const_string(\"error\", 5, & index);\n\t(void) make_const_string(err, strlen(err), & value);\n\tif (! set_array_element(element_array, & index, & value)) {\n\t\twarning(ext_id, _(\"fill_error_element: could not set element\"));\n\t\tfts_errors++;\n\t}\n}",
      "lines": 13,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "fill_default_elements": {
      "start_point": [
        670,
        0
      ],
      "end_point": [
        687,
        1
      ],
      "content": "static void\nfill_default_elements(awk_array_t element_array, const FTSENT *const fentry, awk_bool_t bad_ret)\n{\n\t/* full path */\n\tfill_path_element(element_array, fentry->fts_path);\n\n\t/* stat info */\n\tif (! bad_ret) {\n\t\tfill_stat_element(element_array,\n\t\t\t\tfentry->fts_name,\n\t\t\t\tfentry->fts_statp);\n\t}\n\n\t/* error info */\n\tif (bad_ret || fentry->fts_errno != 0) {\n\t\tfill_error_element(element_array, fentry->fts_errno);\n\t}\n}",
      "lines": 18,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "process": {
      "start_point": [
        691,
        0
      ],
      "end_point": [
        806,
        1
      ],
      "content": "static void\nprocess(FTS *hierarchy, awk_array_t destarray, int seedot)\n{\n\tFTSENT *fentry;\n\tawk_value_t index, value;\n\tawk_array_t element_array, newdir_array, dot_array;\n\tawk_bool_t bad_ret = awk_false;\n\n\t/* path is full path,  pathlen is length thereof */\n\t/* name is name in directory, namelen is length thereof */\n\twhile ((fentry = fts_read(hierarchy)) != NULL) {\n\t\tbad_ret = awk_false;\n\n\t\tswitch (fentry->fts_info) {\n\t\tcase FTS_D:\n\t\t\t/* directory */\n\t\t\t/* create array to hold entries */\n\t\t\tnewdir_array = create_array();\n\t\t\tif (newdir_array == NULL) {\n\t\t\t\twarning(ext_id, _(\"fts-process: could not create array\"));\n\t\t\t\tfts_errors++;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* store new directory in its parent directory */\n\t\t\t(void) make_const_string(fentry->fts_name, fentry->fts_namelen, & index);\n\t\t\tvalue.val_type = AWK_ARRAY;\n\t\t\tvalue.array_cookie = newdir_array;\n\t\t\tif (! set_array_element(destarray, & index, & value)) {\n\t\t\t\twarning(ext_id, _(\"fts-process: could not set element\"));\n\t\t\t\tfts_errors++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnewdir_array = value.array_cookie;\n\n\t\t\t/* push current directory */\n\t\t\tstack_push(destarray);\n\n\t\t\t/* new directory becomes current */\n\t\t\tdestarray = newdir_array;\n\t\t\tbreak;\n\n\t\tcase FTS_DNR:\n\t\tcase FTS_DC:\n\t\tcase FTS_ERR:\n\t\tcase FTS_NS:\n\t\t\t/* error */\n\t\t\tbad_ret = awk_true;\n\t\t\t/* fall through */\n\n\t\tcase FTS_NSOK:\n\t\tcase FTS_SL:\n\t\tcase FTS_SLNONE:\n\t\tcase FTS_F:\n\t\tcase FTS_DOT:\n\t\t\t/* if see dot, skip \".\" */\n\t\t\tif (seedot && strcmp(fentry->fts_name, \".\") == 0)\n\t\t\t\tbreak;\n\n\t\t\t/*\n\t\t\t * File case.\n\t\t\t * destarray is the directory we're reading.\n\t\t\t * step 1: create new empty array\n\t\t\t */\n\t\t\telement_array = create_array();\n\t\t\tif (element_array == NULL) {\n\t\t\t\twarning(ext_id, _(\"fts-process: could not create array\"));\n\t\t\t\tfts_errors++;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* step 2: add element array to parent array */\n\t\t\t(void) make_const_string(fentry->fts_name, fentry->fts_namelen, & index);\n\t\t\tvalue.val_type = AWK_ARRAY;\n\t\t\tvalue.array_cookie = element_array;\n\t\t\tif (! set_array_element(destarray, & index, & value)) {\n\t\t\t\twarning(ext_id, _(\"fts-process: could not set element\"));\n\t\t\t\tfts_errors++;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* step 3: fill in path, stat, error elements */\n\t\t\tfill_default_elements(element_array, fentry, bad_ret);\n\t\t\tbreak;\n\n\t\tcase FTS_DP:\n\t\t\t/* create \".\" subarray */\n\t\t\tdot_array = create_array();\n\n\t\t\t/* add it to parent */\n\t\t\t(void) make_const_string(\".\", 1, & index);\n\t\t\tvalue.val_type = AWK_ARRAY;\n\t\t\tvalue.array_cookie = dot_array;\n\t\t\tif (! set_array_element(destarray, & index, & value)) {\n\t\t\t\twarning(ext_id, _(\"fts-process: could not set element\"));\n\t\t\t\tfts_errors++;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* fill it in with path, stat, error elements */\n\t\t\tfill_default_elements(dot_array, fentry, bad_ret);\n\n\t\t\t/* now pop the parent directory off the stack */\n\t\t\tif (! stack_empty()) {\n\t\t\t\t/* pop stack */\n\t\t\t\tdestarray = stack_pop();\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase FTS_DEFAULT:\n\t\t\t/* nothing to do */\n\t\t\tbreak;\n\t\t}\n\t}\n}",
      "lines": 116,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "gawk/gawk-4.2.1/extension/fnmatch.c": {
    "do_fnmatch": {
      "start_point": [
        103,
        0
      ],
      "end_point": [
        145,
        1
      ],
      "content": "static awk_value_t *\ndo_fnmatch(int nargs, awk_value_t *result, struct awk_ext_func *unused)\n{\n#ifdef HAVE_FNMATCH_H\n\tstatic int flags_mask =\n\t\tFNM_CASEFOLD    | FNM_FILE_NAME |\n\t\tFNM_LEADING_DIR | FNM_NOESCAPE |\n\t\tFNM_PATHNAME    | FNM_PERIOD ;\n#endif\n\tawk_value_t pattern, string, flags;\n\tint int_flags, retval;\n\n\tmake_number(-1.0, result);\t/* default return */\n\n#ifdef HAVE_FNMATCH\n\tif (! get_argument(0, AWK_STRING, & pattern)) {\n\t\twarning(ext_id, _(\"fnmatch: could not get first argument\"));\n\t\tgoto out;\n\t}\n\n\tif (! get_argument(1, AWK_STRING, & string)) {\n\t\twarning(ext_id, _(\"fnmatch: could not get second argument\"));\n\t\tgoto out;\n\t}\n\n\tif (! get_argument(2, AWK_NUMBER, & flags)) {\n\t\twarning(ext_id, _(\"fnmatch: could not get third argument\"));\n\t\tgoto out;\n\t}\n\n\tint_flags = flags.num_value;\n\tint_flags &= flags_mask;\n\n\tretval = fnmatch(pattern.str_value.str,\n\t\t\tstring.str_value.str, int_flags);\n\tmake_number((double) retval, result);\n\nout:\n#else\n\tfatal(ext_id, _(\"fnmatch is not implemented on this system\\n\"));\n#endif\n\treturn result;\n}",
      "lines": 43,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "awk_value_t",
        "*\ndo_fnmatch(int nargs, awk_value_t *result, struct awk_ext_func *unused)",
        "*"
      ]
    },
    "init_fnmatch": {
      "start_point": [
        164,
        0
      ],
      "end_point": [
        200,
        1
      ],
      "content": "static awk_bool_t\ninit_fnmatch(void)\n{\n\tint errors = 0;\n#ifdef HAVE_FNMATCH\n\tawk_value_t index, value, the_array;\n\tawk_array_t new_array;\n\tint i;\n\n\tif (! sym_update(\"FNM_NOMATCH\", make_number(FNM_NOMATCH, & value))) {\n\t\twarning(ext_id, _(\"fnmatch init: could not add FNM_NOMATCH variable\"));\n\t\terrors++;\n\t}\n\n\tnew_array = create_array();\n\tfor (i = 0; flagtable[i].name != NULL; i++) {\n\t\t(void) make_const_string(flagtable[i].name,\n\t\t\t\tstrlen(flagtable[i].name), & index);\n\t\t(void) make_number(flagtable[i].value, & value);\n\t\tif (! set_array_element(new_array, & index, & value)) {\n\t\t\twarning(ext_id, _(\"fnmatch init: could not set array element %s\"),\n\t\t\t\t\tflagtable[i].name);\n\t\t\terrors++;\n\t\t}\n\t}\n\n\tthe_array.val_type = AWK_ARRAY;\n\tthe_array.array_cookie = new_array;\n\n\tif (! sym_update(\"FNM\", & the_array)) {\n\t\twarning(ext_id, _(\"fnmatch init: could not install FNM array\"));\n\t\terrors++;\n\t}\n\n#endif\n\treturn errors == 0;\n}",
      "lines": 37,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "awk_bool_t"
      ]
    }
  },
  "gawk/gawk-4.2.1/extension/fork.c": {
    "array_set_numeric": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "static void\narray_set_numeric(awk_array_t array, const char *sub, double num)\n{\n\tawk_value_t index, value;\n\n\tset_array_element(array,\n\t\tmake_const_string(sub, strlen(sub), & index),\n\t\tmake_number(num, & value));\n\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "do_fork": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        100,
        1
      ],
      "content": "static awk_value_t *\ndo_fork(int nargs, awk_value_t *result, struct awk_ext_func *unused)\n{\n\tint ret = -1;\n\n\tassert(result != NULL);\n\n\tret = fork();\n\n\tif (ret < 0)\n\t\tupdate_ERRNO_int(errno);\n\telse if (ret == 0) {\n\t\t/* update PROCINFO in the child, if the array exists */\n\t\tawk_value_t procinfo;\n\n\t\tif (sym_lookup(\"PROCINFO\", AWK_ARRAY, & procinfo)) {\n\t\t\tif (procinfo.val_type != AWK_ARRAY) {\n\t\t\t\tif (do_lint)\n\t\t\t\t\tlintwarn(ext_id, _(\"fork: PROCINFO is not an array!\"));\n\t\t\t} else {\n\t\t\t\tarray_set_numeric(procinfo.array_cookie, \"pid\", getpid());\n\t\t\t\tarray_set_numeric(procinfo.array_cookie, \"ppid\", getppid());\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Set the return value */\n\treturn make_number(ret, result);\n}",
      "lines": 29,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "awk_value_t",
        "*\ndo_fork(int nargs, awk_value_t *result, struct awk_ext_func *unused)",
        "*"
      ]
    },
    "do_waitpid": {
      "start_point": [
        104,
        0
      ],
      "end_point": [
        122,
        1
      ],
      "content": "static awk_value_t *\ndo_waitpid(int nargs, awk_value_t *result, struct awk_ext_func *unused)\n{\n\tawk_value_t pid;\n\tint ret = -1;\n\tint options = 0;\n\n\tassert(result != NULL);\n\n\tif (get_argument(0, AWK_NUMBER, &pid)) {\n\t\toptions = WNOHANG|WUNTRACED;\n\t\tret = waitpid(pid.num_value, NULL, options);\n\t\tif (ret < 0)\n\t\t\tupdate_ERRNO_int(errno);\n\t}\n\n\t/* Set the return value */\n\treturn make_number(ret, result);\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "awk_value_t",
        "*\ndo_waitpid(int nargs, awk_value_t *result, struct awk_ext_func *unused)",
        "*"
      ]
    },
    "do_wait": {
      "start_point": [
        127,
        0
      ],
      "end_point": [
        140,
        1
      ],
      "content": "static awk_value_t *\ndo_wait(int nargs, awk_value_t *result, struct awk_ext_func *unused)\n{\n\tint ret;\n\n\tassert(result != NULL);\n\n\tret = wait(NULL);\n\tif (ret < 0)\n\t\tupdate_ERRNO_int(errno);\n\n\t/* Set the return value */\n\treturn make_number(ret, result);\n}",
      "lines": 14,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "awk_value_t",
        "*\ndo_wait(int nargs, awk_value_t *result, struct awk_ext_func *unused)",
        "*"
      ]
    }
  },
  "gawk/gawk-4.2.1/extension/gawkdirfd.h": {
    "dirfd": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "int\ndirfd (DIR *dir_p)\n{\n  int fd = DIR_TO_FD (dir_p);\n  if (fd == -1)\n    errno = ENOTSUP;\n  return fd;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "gawk/gawk-4.2.1/extension/gawkfts.c": {
    "MAX": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        80,
        1
      ],
      "content": "static int MAX(int x, int y)\n{\n\tif (x > y)\n\t\treturn x;\n\n\treturn y;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "fts_open": {
      "start_point": [
        145,
        0
      ],
      "end_point": [
        259,
        1
      ],
      "content": "FTS *\nfts_open(char * const *argv, int options,\n    int (*compar)(const FTSENT **, const FTSENT **))\n{\n\tFTS *sp;\n\tFTSENT *p, *root;\n\tsize_t nitems;\n\tFTSENT *parent, *tmp = NULL;\t/* pacify gcc */\n\tsize_t len;\n\n\t_DIAGASSERT(argv != NULL);\n\n\t/* Options check. */\n\tif (options & ~FTS_OPTIONMASK) {\n\t\terrno = EINVAL;\n\t\treturn (NULL);\n\t}\n\n\t/* Allocate/initialize the stream */\n\tif ((sp = calloc(1, (unsigned int)sizeof(FTS))) == NULL)\n\t\treturn (NULL);\n\tsp->fts_compar = compar;\n\tsp->fts_options = options;\n\n\t/* Logical walks turn on NOCHDIR; symbolic links are too hard. */\n\tif (ISSET(FTS_LOGICAL))\n\t\tSET(FTS_NOCHDIR);\n\n\t/*\n\t * Start out with 1K of path space, and enough, in any case,\n\t * to hold the user's paths.\n\t */\n\tif (fts_palloc(sp, MAX(fts_maxarglen(argv), MAXPATHLEN)))\n\t\tgoto mem1;\n\n\t/* Allocate/initialize root's parent. */\n\tif ((parent = fts_alloc(sp, \"\", 0)) == NULL)\n\t\tgoto mem2;\n\tparent->fts_level = FTS_ROOTPARENTLEVEL;\n\n\t/* Allocate/initialize root(s). */\n\tfor (root = NULL, nitems = 0; *argv; ++argv, ++nitems) {\n\t\t/* Don't allow zero-length paths. */\n\t\tif ((len = strlen(*argv)) == 0) {\n\t\t\terrno = ENOENT;\n\t\t\tgoto mem3;\n\t\t}\n\n\t\tif ((p = fts_alloc(sp, *argv, len)) == NULL)\n\t\t\tgoto mem3;\n\t\tp->fts_level = FTS_ROOTLEVEL;\n\t\tp->fts_parent = parent;\n\t\tp->fts_accpath = p->fts_name;\n\t\tp->fts_info = fts_stat(sp, p, ISSET(FTS_COMFOLLOW));\n\n\t\t/* Command-line \".\" and \"..\" are real directories. */\n\t\tif (p->fts_info == FTS_DOT)\n\t\t\tp->fts_info = FTS_D;\n\n\t\t/*\n\t\t * If comparison routine supplied, traverse in sorted\n\t\t * order; otherwise traverse in the order specified.\n\t\t */\n\t\tif (compar) {\n\t\t\tp->fts_link = root;\n\t\t\troot = p;\n\t\t} else {\n\t\t\tp->fts_link = NULL;\n\t\t\tif (root == NULL)\n\t\t\t\ttmp = root = p;\n\t\t\telse {\n\t\t\t\ttmp->fts_link = p;\n\t\t\t\ttmp = p;\n\t\t\t}\n\t\t}\n\t}\n\tif (compar && nitems > 1)\n\t\troot = fts_sort(sp, root, nitems);\n\n\t/*\n\t * Allocate a dummy pointer and make fts_read think that we've just\n\t * finished the node before the root(s); set p->fts_info to FTS_INIT\n\t * so that everything about the \"current\" node is ignored.\n\t */\n\tif ((sp->fts_cur = fts_alloc(sp, \"\", 0)) == NULL)\n\t\tgoto mem3;\n\tsp->fts_cur->fts_link = root;\n\tsp->fts_cur->fts_info = FTS_INIT;\n\n\t/*\n\t * If using chdir(2), grab a file descriptor pointing to dot to insure\n\t * that we can get back here; this could be avoided for some paths,\n\t * but almost certainly not worth the effort.  Slashes, symbolic links,\n\t * and \"..\" are all fairly nasty problems.  Note, if we can't get the\n\t * descriptor we run anyway, just more slowly.\n\t */\n#ifndef O_CLOEXEC\n#define O_CLOEXEC 0\n#endif\n\tif (!ISSET(FTS_NOCHDIR)) {\n\t\tif ((sp->fts_rfd = open(\".\", O_RDONLY | O_CLOEXEC, 0)) == -1)\n\t\t\tSET(FTS_NOCHDIR);\n\t}\n\n\tif (nitems == 0)\n\t\tfts_free(parent);\n\n\treturn (sp);\n\nmem3:\tfts_lfree(root);\n\tfts_free(parent);\nmem2:\tfree(sp->fts_path);\nmem1:\tfree(sp);\n\treturn (NULL);\n}",
      "lines": 115,
      "depth": 13,
      "decorators": [
        "FTS",
        "*\nfts_open(char * const *argv, int options,\n    int (*compar)(const FTSENT **, const FTSENT **))",
        "*"
      ]
    },
    "fts_load": {
      "start_point": [
        261,
        0
      ],
      "end_point": [
        286,
        1
      ],
      "content": "static void\nfts_load(FTS *sp, FTSENT *p)\n{\n\tsize_t len;\n\tchar *cp;\n\n\t_DIAGASSERT(sp != NULL);\n\t_DIAGASSERT(p != NULL);\n\n\t/*\n\t * Load the stream structure for the next traversal.  Since we don't\n\t * actually enter the directory until after the preorder visit, set\n\t * the fts_accpath field specially so the chdir gets done to the right\n\t * place and the user can access the first node.  From fts_open it's\n\t * known that the path will fit.\n\t */\n\tlen = p->fts_pathlen = p->fts_namelen;\n\tmemmove(sp->fts_path, p->fts_name, len + 1);\n\tif ((cp = strrchr(p->fts_name, '/')) && (cp != p->fts_name || cp[1])) {\n\t\tlen = strlen(++cp);\n\t\tmemmove(p->fts_name, cp, len + 1);\n\t\tp->fts_namelen = ftsent_namelen_truncate(len);\n\t}\n\tp->fts_accpath = p->fts_path = sp->fts_path;\n\tsp->fts_dev = p->fts_dev;\n}",
      "lines": 26,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "fts_close": {
      "start_point": [
        288,
        0
      ],
      "end_point": [
        334,
        1
      ],
      "content": "int\nfts_close(FTS *sp)\n{\n\tFTSENT *freep, *p;\n\tint saved_errno = 0;\n\n\t_DIAGASSERT(sp != NULL);\n\n\t/*\n\t * This still works if we haven't read anything -- the dummy structure\n\t * points to the root list, so we step through to the end of the root\n\t * list which has a valid parent pointer.\n\t */\n\tif (sp->fts_cur) {\n\t\tif (sp->fts_cur->fts_flags & FTS_SYMFOLLOW)\n\t\t\t(void)close(sp->fts_cur->fts_symfd);\n\t\tfor (p = sp->fts_cur; p->fts_level >= FTS_ROOTLEVEL;) {\n\t\t\tfreep = p;\n\t\t\tp = p->fts_link ? p->fts_link : p->fts_parent;\n\t\t\tfts_free(freep);\n\t\t}\n\t\tfts_free(p);\n\t}\n\n\t/* Free up child linked list, sort array, path buffer. */\n\tif (sp->fts_child)\n\t\tfts_lfree(sp->fts_child);\n\tif (sp->fts_array)\n\t\tfree(sp->fts_array);\n\tfree(sp->fts_path);\n\n\t/* Return to original directory, save errno if necessary. */\n\tif (!ISSET(FTS_NOCHDIR)) {\n\t\tif (fchdir(sp->fts_rfd) == -1)\n\t\t\tsaved_errno = errno;\n\t\t(void)close(sp->fts_rfd);\n\t}\n\n\t/* Free up the stream pointer. */\n\tfree(sp);\n\tif (saved_errno) {\n\t\terrno = saved_errno;\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
      "lines": 47,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "fts_read": {
      "start_point": [
        361,
        0
      ],
      "end_point": [
        547,
        1
      ],
      "content": "FTSENT *\nfts_read(FTS *sp)\n{\n\tFTSENT *p, *tmp;\n\tint instr;\n\tchar *t;\n\tint saved_errno;\n\n\t_DIAGASSERT(sp != NULL);\n\n\t/* If finished or unrecoverable error, return NULL. */\n\tif (sp->fts_cur == NULL || ISSET(FTS_STOP))\n\t\treturn (NULL);\n\n\t/* Set current node pointer. */\n\tp = sp->fts_cur;\n\n\t/* Save and zero out user instructions. */\n\tinstr = p->fts_instr;\n\tp->fts_instr = FTS_NOINSTR;\n\n\t/* Any type of file may be re-visited; re-stat and re-turn. */\n\tif (instr == FTS_AGAIN) {\n\t\tp->fts_info = fts_stat(sp, p, 0);\n\t\treturn (p);\n\t}\n\n\t/*\n\t * Following a symlink -- SLNONE test allows application to see\n\t * SLNONE and recover.  If indirecting through a symlink, have\n\t * keep a pointer to current location.  If unable to get that\n\t * pointer, follow fails.\n\t */\n\tif (instr == FTS_FOLLOW &&\n\t    (p->fts_info == FTS_SL || p->fts_info == FTS_SLNONE)) {\n\t\tp->fts_info = fts_stat(sp, p, 1);\n\t\tif (p->fts_info == FTS_D && !ISSET(FTS_NOCHDIR)) {\n\t\t\tif ((p->fts_symfd = open(\".\", O_RDONLY | O_CLOEXEC, 0))\n\t\t\t    == -1) {\n\t\t\t\tp->fts_errno = errno;\n\t\t\t\tp->fts_info = FTS_ERR;\n\t\t\t} else\n\t\t\t\tp->fts_flags |= FTS_SYMFOLLOW;\n\t\t}\n\t\treturn (p);\n\t}\n\n\t/* Directory in pre-order. */\n\tif (p->fts_info == FTS_D) {\n\t\t/* If skipped or crossed mount point, do post-order visit. */\n\t\tif (instr == FTS_SKIP ||\n\t\t    (ISSET(FTS_XDEV) && p->fts_dev != sp->fts_dev)) {\n\t\t\tif (p->fts_flags & FTS_SYMFOLLOW)\n\t\t\t\t(void)close(p->fts_symfd);\n\t\t\tif (sp->fts_child) {\n\t\t\t\tfts_lfree(sp->fts_child);\n\t\t\t\tsp->fts_child = NULL;\n\t\t\t}\n\t\t\tp->fts_info = FTS_DP;\n\t\t\treturn (p);\n\t\t}\n\n\t\t/* Rebuild if only read the names and now traversing. */\n\t\tif (sp->fts_child && ISSET(FTS_NAMEONLY)) {\n\t\t\tCLR(FTS_NAMEONLY);\n\t\t\tfts_lfree(sp->fts_child);\n\t\t\tsp->fts_child = NULL;\n\t\t}\n\n\t\t/*\n\t\t * Cd to the subdirectory.\n\t\t *\n\t\t * If have already read and now fail to chdir, whack the list\n\t\t * to make the names come out right, and set the parent errno\n\t\t * so the application will eventually get an error condition.\n\t\t * Set the FTS_DONTCHDIR flag so that when we logically change\n\t\t * directories back to the parent we don't do a chdir.\n\t\t *\n\t\t * If haven't read do so.  If the read fails, fts_build sets\n\t\t * FTS_STOP or the fts_info field of the node.\n\t\t */\n\t\tif (sp->fts_child) {\n\t\t\tif (fts_safe_changedir(sp, p, -1, p->fts_accpath)) {\n\t\t\t\tp->fts_errno = errno;\n\t\t\t\tp->fts_flags |= FTS_DONTCHDIR;\n\t\t\t\tfor (p = sp->fts_child; p; p = p->fts_link)\n\t\t\t\t\tp->fts_accpath =\n\t\t\t\t\t    p->fts_parent->fts_accpath;\n\t\t\t}\n\t\t} else if ((sp->fts_child = fts_build(sp, BREAD)) == NULL) {\n\t\t\tif (ISSET(FTS_STOP))\n\t\t\t\treturn (NULL);\n\t\t\treturn (p);\n\t\t}\n\t\tp = sp->fts_child;\n\t\tsp->fts_child = NULL;\n\t\tgoto name;\n\t}\n\n\t/* Move to the next node on this level. */\nnext:\ttmp = p;\n\tif ((p = p->fts_link) != NULL) {\n\t\tfts_free(tmp);\n\n\t\t/*\n\t\t * If reached the top, return to the original directory, and\n\t\t * load the paths for the next root.\n\t\t */\n\t\tif (p->fts_level == FTS_ROOTLEVEL) {\n\t\t\tif (FCHDIR(sp, sp->fts_rfd)) {\n\t\t\t\tSET(FTS_STOP);\n\t\t\t\treturn (NULL);\n\t\t\t}\n\t\t\tfts_load(sp, p);\n\t\t\treturn (sp->fts_cur = p);\n\t\t}\n\n\t\t/*\n\t\t * User may have called fts_set on the node.  If skipped,\n\t\t * ignore.  If followed, get a file descriptor so we can\n\t\t * get back if necessary.\n\t\t */\n\t\tif (p->fts_instr == FTS_SKIP)\n\t\t\tgoto next;\n\t\tif (p->fts_instr == FTS_FOLLOW) {\n\t\t\tp->fts_info = fts_stat(sp, p, 1);\n\t\t\tif (p->fts_info == FTS_D && !ISSET(FTS_NOCHDIR)) {\n\t\t\t\tif ((p->fts_symfd =\n\t\t\t\t    open(\".\", O_RDONLY | O_CLOEXEC, 0)) == -1) {\n\t\t\t\t\tp->fts_errno = errno;\n\t\t\t\t\tp->fts_info = FTS_ERR;\n\t\t\t\t} else\n\t\t\t\t\tp->fts_flags |= FTS_SYMFOLLOW;\n\t\t\t}\n\t\t\tp->fts_instr = FTS_NOINSTR;\n\t\t}\n\nname:\t\tt = sp->fts_path + NAPPEND(p->fts_parent);\n\t\t*t++ = '/';\n\t\tmemmove(t, p->fts_name, (size_t)(p->fts_namelen + 1));\n\t\treturn (sp->fts_cur = p);\n\t}\n\n\t/* Move up to the parent node. */\n\tp = tmp->fts_parent;\n\tfts_free(tmp);\n\n\tif (p->fts_level == FTS_ROOTPARENTLEVEL) {\n\t\t/*\n\t\t * Done; free everything up and set errno to 0 so the user\n\t\t * can distinguish between error and EOF.\n\t\t */\n\t\tfts_free(p);\n\t\terrno = 0;\n\t\treturn (sp->fts_cur = NULL);\n\t}\n\n\t/* Nul terminate the pathname. */\n\tsp->fts_path[p->fts_pathlen] = '\\0';\n\n\t/*\n\t * Return to the parent directory.  If at a root node or came through\n\t * a symlink, go back through the file descriptor.  Otherwise, cd up\n\t * one directory.\n\t */\n\tif (p->fts_level == FTS_ROOTLEVEL) {\n\t\tif (FCHDIR(sp, sp->fts_rfd)) {\n\t\t\tSET(FTS_STOP);\n\t\t\treturn (NULL);\n\t\t}\n\t} else if (p->fts_flags & FTS_SYMFOLLOW) {\n\t\tif (FCHDIR(sp, p->fts_symfd)) {\n\t\t\tsaved_errno = errno;\n\t\t\t(void)close(p->fts_symfd);\n\t\t\terrno = saved_errno;\n\t\t\tSET(FTS_STOP);\n\t\t\treturn (NULL);\n\t\t}\n\t\t(void)close(p->fts_symfd);\n\t} else if (!(p->fts_flags & FTS_DONTCHDIR) &&\n\t    fts_safe_changedir(sp, p->fts_parent, -1, \"..\")) {\n\t\tSET(FTS_STOP);\n\t\treturn (NULL);\n\t}\n\tp->fts_info = p->fts_errno ? FTS_ERR : FTS_DP;\n\treturn (sp->fts_cur = p);\n}",
      "lines": 187,
      "depth": 17,
      "decorators": [
        "FTSENT",
        "*\nfts_read(FTS *sp)",
        "*"
      ]
    },
    "fts_set": {
      "start_point": [
        556,
        0
      ],
      "end_point": [
        570,
        1
      ],
      "content": "int\nfts_set(FTS *sp, FTSENT *p, int instr)\n{\n\t(void) sp;\t/* silence warnings */\n\t_DIAGASSERT(sp != NULL);\n\t_DIAGASSERT(p != NULL);\n\n\tif (instr && instr != FTS_AGAIN && instr != FTS_FOLLOW &&\n\t    instr != FTS_NOINSTR && instr != FTS_SKIP) {\n\t\terrno = EINVAL;\n\t\treturn (1);\n\t}\n\tp->fts_instr = instr;\n\treturn (0);\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "fts_children": {
      "start_point": [
        572,
        0
      ],
      "end_point": [
        640,
        1
      ],
      "content": "FTSENT *\nfts_children(FTS *sp, int instr)\n{\n\tFTSENT *p;\n\tint fd;\n\n\t_DIAGASSERT(sp != NULL);\n\n\tif (instr && instr != FTS_NAMEONLY) {\n\t\terrno = EINVAL;\n\t\treturn (NULL);\n\t}\n\n\t/* Set current node pointer. */\n\tp = sp->fts_cur;\n\n\t/*\n\t * Errno set to 0 so user can distinguish empty directory from\n\t * an error.\n\t */\n\terrno = 0;\n\n\t/* Fatal errors stop here. */\n\tif (ISSET(FTS_STOP))\n\t\treturn (NULL);\n\n\t/* Return logical hierarchy of user's arguments. */\n\tif (p->fts_info == FTS_INIT)\n\t\treturn (p->fts_link);\n\n\t/*\n\t * If not a directory being visited in pre-order, stop here.  Could\n\t * allow FTS_DNR, assuming the user has fixed the problem, but the\n\t * same effect is available with FTS_AGAIN.\n\t */\n\tif (p->fts_info != FTS_D /* && p->fts_info != FTS_DNR */)\n\t\treturn (NULL);\n\n\t/* Free up any previous child list. */\n\tif (sp->fts_child)\n\t\tfts_lfree(sp->fts_child);\n\n\tif (instr == FTS_NAMEONLY) {\n\t\tSET(FTS_NAMEONLY);\n\t\tinstr = BNAMES;\n\t} else\n\t\tinstr = BCHILD;\n\n\t/*\n\t * If using chdir on a relative path and called BEFORE fts_read does\n\t * its chdir to the root of a traversal, we can lose -- we need to\n\t * chdir into the subdirectory, and we don't know where the current\n\t * directory is, so we can't get back so that the upcoming chdir by\n\t * fts_read will work.\n\t */\n\tif (p->fts_level != FTS_ROOTLEVEL || p->fts_accpath[0] == '/' ||\n\t    ISSET(FTS_NOCHDIR))\n\t\treturn (sp->fts_child = fts_build(sp, instr));\n\n\tif ((fd = open(\".\", O_RDONLY, 0)) == -1)\n\t\treturn (sp->fts_child = NULL);\n\tsp->fts_child = fts_build(sp, instr);\n\tif (fchdir(fd)) {\n\t\t(void)close(fd);\n\t\treturn (NULL);\n\t}\n\t(void)close(fd);\n\treturn (sp->fts_child);\n}",
      "lines": 69,
      "depth": 11,
      "decorators": [
        "FTSENT",
        "*\nfts_children(FTS *sp, int instr)",
        "*"
      ]
    },
    "fts_build": {
      "start_point": [
        656,
        0
      ],
      "end_point": [
        934,
        1
      ],
      "content": "static FTSENT *\nfts_build(FTS *sp, int type)\n{\n\tstruct dirent *dp;\n\tFTSENT *p, *head;\n\tsize_t nitems;\n\tFTSENT *cur, *tail;\n\tDIR *dirp;\n\tvoid *oldaddr;\n\tsize_t dnamlen;\n\tint cderrno, descend, level, nlinks, saved_errno, nostat, doadjust;\n\tsize_t len, maxlen;\n#ifdef FTS_WHITEOUT\n\tint oflag;\n#endif\n\tchar *cp = NULL;\t/* pacify gcc */\n\n\t_DIAGASSERT(sp != NULL);\n\n\t/* Set current node pointer. */\n\tcur = sp->fts_cur;\n\n\t/*\n\t * Open the directory for reading.  If this fails, we're done.\n\t * If being called from fts_read, set the fts_info field.\n\t */\n#if 0 /* def FTS_WHITEOUT */\n\tif (ISSET(FTS_WHITEOUT))\n\t\toflag = DTF_NODUP|DTF_REWIND;\n\telse\n\t\toflag = DTF_HIDEW|DTF_NODUP|DTF_REWIND;\n#else\n#define\t__opendir2(path, flag) opendir(path)\n#endif\n\tif ((dirp = __opendir2(cur->fts_accpath, oflag)) == NULL) {\n\t\tif (type == BREAD) {\n\t\t\tcur->fts_info = FTS_DNR;\n\t\t\tcur->fts_errno = errno;\n\t\t}\n\t\treturn (NULL);\n\t}\n\n\t/*\n\t * Nlinks is the number of possible entries of type directory in the\n\t * directory if we're cheating on stat calls, 0 if we're not doing\n\t * any stat calls at all, -1 if we're doing stats on everything.\n\t */\n\tif (type == BNAMES) {\n\t\tnlinks = 0;\n\t\tnostat = 1;\n\t} else if (ISSET(FTS_NOSTAT) && ISSET(FTS_PHYSICAL)) {\n\t\tnlinks = cur->fts_nlink - (ISSET(FTS_SEEDOT) ? 0 : 2);\n\t\tnostat = 1;\n\t} else {\n\t\tnlinks = -1;\n\t\tnostat = 0;\n\t}\n\n#ifdef notdef\n\t(void)printf(\"nlinks == %d (cur: %d)\\n\", nlinks, cur->fts_nlink);\n\t(void)printf(\"NOSTAT %d PHYSICAL %d SEEDOT %d\\n\",\n\t    ISSET(FTS_NOSTAT), ISSET(FTS_PHYSICAL), ISSET(FTS_SEEDOT));\n#endif\n\t/*\n\t * If we're going to need to stat anything or we want to descend\n\t * and stay in the directory, chdir.  If this fails we keep going,\n\t * but set a flag so we don't chdir after the post-order visit.\n\t * We won't be able to stat anything, but we can still return the\n\t * names themselves.  Note, that since fts_read won't be able to\n\t * chdir into the directory, it will have to return different path\n\t * names than before, i.e. \"a/b\" instead of \"b\".  Since the node\n\t * has already been visited in pre-order, have to wait until the\n\t * post-order visit to return the error.  There is a special case\n\t * here, if there was nothing to stat then it's not an error to\n\t * not be able to stat.  This is all fairly nasty.  If a program\n\t * needed sorted entries or stat information, they had better be\n\t * checking FTS_NS on the returned nodes.\n\t */\n\tcderrno = 0;\n\tif (nlinks || type == BREAD) {\n\t\tif (fts_safe_changedir(sp, cur, dirfd(dirp), NULL)) {\n\t\t\tif (nlinks && type == BREAD)\n\t\t\t\tcur->fts_errno = errno;\n\t\t\tcur->fts_flags |= FTS_DONTCHDIR;\n\t\t\tdescend = 0;\n\t\t\tcderrno = errno;\n\t\t} else\n\t\t\tdescend = 1;\n\t} else\n\t\tdescend = 0;\n\n\t/*\n\t * Figure out the max file name length that can be stored in the\n\t * current path -- the inner loop allocates more path as necessary.\n\t * We really wouldn't have to do the maxlen calculations here, we\n\t * could do them in fts_read before returning the path, but it's a\n\t * lot easier here since the length is part of the dirent structure.\n\t *\n\t * If not changing directories set a pointer so that can just append\n\t * each new name into the path.\n\t */\n\tlen = NAPPEND(cur);\n\tif (ISSET(FTS_NOCHDIR)) {\n\t\tcp = sp->fts_path + len;\n\t\t*cp++ = '/';\n\t}\n\tlen++;\n\tmaxlen = sp->fts_pathlen - len;\n\n#if defined(__FTS_COMPAT_LEVEL)\n\tif (cur->fts_level == SHRT_MAX) {\n\t\t(void)closedir(dirp);\n\t\tcur->fts_info = FTS_ERR;\n\t\tSET(FTS_STOP);\n\t\terrno = ENAMETOOLONG;\n\t\treturn (NULL);\n\t}\n#endif\n\n\tlevel = cur->fts_level + 1;\n\n\t/* Read the directory, attaching each entry to the `link' pointer. */\n\tdoadjust = 0;\n\tfor (head = tail = NULL, nitems = 0; (dp = readdir(dirp)) != NULL;) {\n\n\t\tif (!ISSET(FTS_SEEDOT) && ISDOT(dp->d_name))\n\t\t\tcontinue;\n\n#if defined(HAVE_STRUCT_DIRENT_D_NAMLEN)\n\t\tdnamlen = dp->d_namlen;\n#else\n\t\tdnamlen = strlen(dp->d_name);\n#endif\n\t\tif ((p = fts_alloc(sp, dp->d_name, dnamlen)) == NULL)\n\t\t\tgoto mem1;\n\t\tif (dnamlen >= maxlen) {\t/* include space for NUL */\n\t\t\toldaddr = sp->fts_path;\n\t\t\tif (fts_palloc(sp, dnamlen + len + 1)) {\n\t\t\t\t/*\n\t\t\t\t * No more memory for path or structures.  Save\n\t\t\t\t * errno, free up the current structure and the\n\t\t\t\t * structures already allocated.\n\t\t\t\t */\nmem1:\t\t\t\tsaved_errno = errno;\n\t\t\t\tif (p)\n\t\t\t\t\tfts_free(p);\n\t\t\t\tfts_lfree(head);\n\t\t\t\t(void)closedir(dirp);\n\t\t\t\terrno = saved_errno;\n\t\t\t\tcur->fts_info = FTS_ERR;\n\t\t\t\tSET(FTS_STOP);\n\t\t\t\treturn (NULL);\n\t\t\t}\n\t\t\t/* Did realloc() change the pointer? */\n\t\t\tif (oldaddr != sp->fts_path) {\n\t\t\t\tdoadjust = 1;\n\t\t\t\tif (ISSET(FTS_NOCHDIR))\n\t\t\t\t\tcp = sp->fts_path + len;\n\t\t\t}\n\t\t\tmaxlen = sp->fts_pathlen - len;\n\t\t}\n\n#if defined(__FTS_COMPAT_LENGTH)\n\t\tif (len + dnamlen >= USHRT_MAX) {\n\t\t\t/*\n\t\t\t * In an FTSENT, fts_pathlen is an unsigned short\n\t\t\t * so it is possible to wraparound here.\n\t\t\t * If we do, free up the current structure and the\n\t\t\t * structures already allocated, then error out\n\t\t\t * with ENAMETOOLONG.\n\t\t\t */\n\t\t\tfts_free(p);\n\t\t\tfts_lfree(head);\n\t\t\t(void)closedir(dirp);\n\t\t\tcur->fts_info = FTS_ERR;\n\t\t\tSET(FTS_STOP);\n\t\t\terrno = ENAMETOOLONG;\n\t\t\treturn (NULL);\n\t\t}\n#endif\n\t\tp->fts_level = level;\n\t\tp->fts_pathlen = ftsent_pathlen_truncate(len + dnamlen);\n\t\tp->fts_parent = sp->fts_cur;\n\n#ifdef FTS_WHITEOUT\n\t\tif (dp->d_type == DT_WHT)\n\t\t\tp->fts_flags |= FTS_ISW;\n#endif\n\n\t\tif (cderrno) {\n\t\t\tif (nlinks) {\n\t\t\t\tp->fts_info = FTS_NS;\n\t\t\t\tp->fts_errno = cderrno;\n\t\t\t} else\n\t\t\t\tp->fts_info = FTS_NSOK;\n\t\t\tp->fts_accpath = cur->fts_accpath;\n\t\t} else if (nlinks == 0\n#ifdef DT_DIR\n\t\t    || (nostat &&\n\t\t    dp->d_type != DT_DIR && dp->d_type != DT_UNKNOWN)\n#endif\n\t\t    ) {\n\t\t\tp->fts_accpath =\n\t\t\t    ISSET(FTS_NOCHDIR) ? p->fts_path : p->fts_name;\n\t\t\tp->fts_info = FTS_NSOK;\n\t\t} else {\n\t\t\t/* Build a file name for fts_stat to stat. */\n\t\t\tif (ISSET(FTS_NOCHDIR)) {\n\t\t\t\tp->fts_accpath = p->fts_path;\n\t\t\t\tmemmove(cp, p->fts_name,\n\t\t\t\t        (size_t)(p->fts_namelen + 1));\n\t\t\t} else\n\t\t\t\tp->fts_accpath = p->fts_name;\n\t\t\t/* Stat it. */\n\t\t\tp->fts_info = fts_stat(sp, p, 0);\n\n\t\t\t/* Decrement link count if applicable. */\n\t\t\tif (nlinks > 0 && (p->fts_info == FTS_D ||\n\t\t\t    p->fts_info == FTS_DC || p->fts_info == FTS_DOT))\n\t\t\t\t--nlinks;\n\t\t}\n\n\t\t/* We walk in directory order so \"ls -f\" doesn't get upset. */\n\t\tp->fts_link = NULL;\n\t\tif (head == NULL)\n\t\t\thead = tail = p;\n\t\telse {\n\t\t\ttail->fts_link = p;\n\t\t\ttail = p;\n\t\t}\n\t\t++nitems;\n\t}\n\t(void)closedir(dirp);\n\n\t/*\n\t * If had to realloc the path, adjust the addresses for the rest\n\t * of the tree.\n\t */\n\tif (doadjust)\n\t\tfts_padjust(sp, head);\n\n\t/*\n\t * If not changing directories, reset the path back to original\n\t * state.\n\t */\n\tif (ISSET(FTS_NOCHDIR)) {\n\t\tif (len == sp->fts_pathlen || nitems == 0)\n\t\t\t--cp;\n\t\t*cp = '\\0';\n\t}\n\n\t/*\n\t * If descended after called from fts_children or after called from\n\t * fts_read and nothing found, get back.  At the root level we use\n\t * the saved fd; if one of fts_open()'s arguments is a relative path\n\t * to an empty directory, we wind up here with no other way back.  If\n\t * can't get back, we're done.\n\t */\n\tif (descend && (type == BCHILD || !nitems) &&\n\t    (cur->fts_level == FTS_ROOTLEVEL ?\n\t    FCHDIR(sp, sp->fts_rfd) :\n\t    fts_safe_changedir(sp, cur->fts_parent, -1, \"..\"))) {\n\t\tcur->fts_info = FTS_ERR;\n\t\tSET(FTS_STOP);\n\t\treturn (NULL);\n\t}\n\n\t/* If didn't find anything, return NULL. */\n\tif (!nitems) {\n\t\tif (type == BREAD)\n\t\t\tcur->fts_info = FTS_DP;\n\t\treturn (NULL);\n\t}\n\n\t/* Sort the entries. */\n\tif (sp->fts_compar && nitems > 1)\n\t\thead = fts_sort(sp, head, nitems);\n\treturn (head);\n}",
      "lines": 279,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "FTSENT",
        "*\nfts_build(FTS *sp, int type)",
        "*"
      ]
    },
    "fts_stat": {
      "start_point": [
        936,
        0
      ],
      "end_point": [
        1017,
        1
      ],
      "content": "static unsigned short\nfts_stat(FTS *sp, FTSENT *p, int follow)\n{\n\tFTSENT *t;\n\tdev_t dev;\n\tino_t ino;\n\tstruct stat *sbp, sb;\n\tint saved_errno;\n\n\t_DIAGASSERT(sp != NULL);\n\t_DIAGASSERT(p != NULL);\n\n\t/* If user needs stat info, stat buffer already allocated. */\n\tsbp = ISSET(FTS_NOSTAT) ? &sb : p->fts_statp;\n\n#ifdef FTS_WHITEOUT\n\t/* check for whiteout */\n\tif (p->fts_flags & FTS_ISW) {\n\t\tif (sbp != &sb) {\n\t\t\tmemset(sbp, '\\0', sizeof (*sbp));\n\t\t\tsbp->st_mode = S_IFWHT;\n\t\t}\n\t\treturn (FTS_W);\n\t}\n#endif\n\n\t/*\n\t * If doing a logical walk, or application requested FTS_FOLLOW, do\n\t * a stat(2).  If that fails, check for a non-existent symlink.  If\n\t * fail, set the errno from the stat call.\n\t */\n\tif (ISSET(FTS_LOGICAL) || follow) {\n\t\tif (stat(p->fts_accpath, sbp)) {\n\t\t\tsaved_errno = errno;\n\t\t\tif (!lstat(p->fts_accpath, sbp)) {\n\t\t\t\terrno = 0;\n\t\t\t\treturn (FTS_SLNONE);\n\t\t\t}\n\t\t\tp->fts_errno = saved_errno;\n\t\t\tgoto err;\n\t\t}\n\t} else if (lstat(p->fts_accpath, sbp)) {\n\t\tp->fts_errno = errno;\nerr:\t\tmemset(sbp, 0, sizeof(*sbp));\n\t\treturn (FTS_NS);\n\t}\n\n\tif (S_ISDIR(sbp->st_mode)) {\n\t\t/*\n\t\t * Set the device/inode.  Used to find cycles and check for\n\t\t * crossing mount points.  Also remember the link count, used\n\t\t * in fts_build to limit the number of stat calls.  It is\n\t\t * understood that these fields are only referenced if fts_info\n\t\t * is set to FTS_D.\n\t\t */\n\t\tdev = p->fts_dev = sbp->st_dev;\n\t\tino = p->fts_ino = sbp->st_ino;\n\t\tp->fts_nlink = sbp->st_nlink;\n\n\t\tif (ISDOT(p->fts_name))\n\t\t\treturn (FTS_DOT);\n\n\t\t/*\n\t\t * Cycle detection is done by brute force when the directory\n\t\t * is first encountered.  If the tree gets deep enough or the\n\t\t * number of symbolic links to directories is high enough,\n\t\t * something faster might be worthwhile.\n\t\t */\n\t\tfor (t = p->fts_parent;\n\t\t    t->fts_level >= FTS_ROOTLEVEL; t = t->fts_parent)\n\t\t\tif (ino == t->fts_ino && dev == t->fts_dev) {\n\t\t\t\tp->fts_cycle = t;\n\t\t\t\treturn (FTS_DC);\n\t\t\t}\n\t\treturn (FTS_D);\n\t}\n\tif (S_ISLNK(sbp->st_mode))\n\t\treturn (FTS_SL);\n\tif (S_ISREG(sbp->st_mode))\n\t\treturn (FTS_F);\n\treturn (FTS_DEFAULT);\n}",
      "lines": 82,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "unsigned short",
        "unsigned",
        "short"
      ]
    },
    "fts_sort": {
      "start_point": [
        1019,
        0
      ],
      "end_point": [
        1051,
        1
      ],
      "content": "static FTSENT *\nfts_sort(FTS *sp, FTSENT *head, size_t nitems)\n{\n\tFTSENT **ap, *p;\n\n\t_DIAGASSERT(sp != NULL);\n\t_DIAGASSERT(head != NULL);\n\n\t/*\n\t * Construct an array of pointers to the structures and call qsort(3).\n\t * Reassemble the array in the order returned by qsort.  If unable to\n\t * sort for memory reasons, return the directory entries in their\n\t * current order.  Allocate enough space for the current needs plus\n\t * 40 so don't realloc one entry at a time.\n\t */\n\tif (nitems > sp->fts_nitems) {\n\t\tFTSENT **new;\n\n\t\tnew = realloc(sp->fts_array, sizeof(FTSENT *) * (nitems + 40));\n\t\tif (new == 0)\n\t\t\treturn (head);\n\t\tsp->fts_array = new;\n\t\tsp->fts_nitems = fts_nitems_truncate(nitems + 40);\n\t}\n\tfor (ap = sp->fts_array, p = head; p; p = p->fts_link)\n\t\t*ap++ = p;\n\tqsort((void *)sp->fts_array, nitems, sizeof(FTSENT *),\n\t\t(int (*)(const void *, const void *))sp->fts_compar);\n\tfor (head = *(ap = sp->fts_array); --nitems; ++ap)\n\t\tap[0]->fts_link = ap[1];\n\tap[0]->fts_link = NULL;\n\treturn (head);\n}",
      "lines": 33,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "FTSENT",
        "*\nfts_sort(FTS *sp, FTSENT *head, size_t nitems)",
        "*"
      ]
    },
    "fts_alloc": {
      "start_point": [
        1053,
        0
      ],
      "end_point": [
        1107,
        1
      ],
      "content": "static FTSENT *\nfts_alloc(FTS *sp, const char *name, size_t namelen)\n{\n\tFTSENT *p;\n#if defined(FTS_ALLOC_ALIGNED)\n\tsize_t len;\n#endif\n\n\t_DIAGASSERT(sp != NULL);\n\t_DIAGASSERT(name != NULL);\n\n#if defined(FTS_ALLOC_ALIGNED)\n\t/*\n\t * The file name is a variable length array and no stat structure is\n\t * necessary if the user has set the nostat bit.  Allocate the FTSENT\n\t * structure, the file name and the stat structure in one chunk, but\n\t * be careful that the stat structure is reasonably aligned.  Since the\n\t * fts_name field is declared to be of size 1, the fts_name pointer is\n\t * namelen + 2 before the first possible address of the stat structure.\n\t */\n\tlen = sizeof(FTSENT) + namelen;\n\tif (!ISSET(FTS_NOSTAT))\n\t\tlen += sizeof(*(p->fts_statp)) + ALIGNBYTES;\n\tif ((p = malloc(len)) == NULL)\n\t\treturn (NULL);\n\n\tif (!ISSET(FTS_NOSTAT))\n\t\tp->fts_statp = (struct stat *)ALIGN(\n\t\t    (unsigned long)(p->fts_name + namelen + 2));\n#else\n\tif ((p = malloc(sizeof(FTSENT) + namelen)) == NULL)\n\t\treturn (NULL);\n\n\tif (!ISSET(FTS_NOSTAT))\n\t\tif ((p->fts_statp = malloc(sizeof(*(p->fts_statp)))) == NULL) {\n\t\t\tfree(p);\n\t\t\treturn (NULL);\n\t\t}\n#endif\n\n        if (ISSET(FTS_NOSTAT))\n                p->fts_statp = NULL;\n\n\t/* Copy the name plus the trailing NULL. */\n\tmemmove(p->fts_name, name, namelen + 1);\n\n\tp->fts_namelen = ftsent_namelen_truncate(namelen);\n\tp->fts_path = sp->fts_path;\n\tp->fts_errno = 0;\n\tp->fts_flags = 0;\n\tp->fts_instr = FTS_NOINSTR;\n\tp->fts_number = 0;\n\tp->fts_pointer = NULL;\n\treturn (p);\n}",
      "lines": 55,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "FTSENT",
        "*\nfts_alloc(FTS *sp, const char *name, size_t namelen)",
        "*"
      ]
    },
    "fts_free": {
      "start_point": [
        1109,
        0
      ],
      "end_point": [
        1117,
        1
      ],
      "content": "static void\nfts_free(FTSENT *p)\n{\n#if !defined(FTS_ALLOC_ALIGNED)\n\tif (p->fts_statp)\n\t\tfree(p->fts_statp);\n#endif\n\tfree(p);\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "fts_lfree": {
      "start_point": [
        1119,
        0
      ],
      "end_point": [
        1131,
        1
      ],
      "content": "static void\nfts_lfree(FTSENT *head)\n{\n\tFTSENT *p;\n\n\t/* XXX: head may be NULL ? */\n\n\t/* Free a linked list of structures. */\n\twhile ((p = head) != NULL) {\n\t\thead = head->fts_link;\n\t\tfts_free(p);\n\t}\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "fts_pow2": {
      "start_point": [
        1133,
        0
      ],
      "end_point": [
        1151,
        1
      ],
      "content": "static size_t\nfts_pow2(size_t x)\n{\n\n\tx--;\n\tx |= x>>1;\n\tx |= x>>2;\n\tx |= x>>4;\n\tx |= x>>8;\n\tx |= x>>16;\n#if LONG_BIT > 32\n\tx |= x>>32;\n#endif\n#if LONG_BIT > 64\n\tx |= x>>64;\n#endif\n\tx++;\n\treturn (x);\n}",
      "lines": 19,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "fts_palloc": {
      "start_point": [
        1159,
        0
      ],
      "end_point": [
        1180,
        1
      ],
      "content": "static int\nfts_palloc(FTS *sp, size_t size)\n{\n\tchar *new;\n\n\t_DIAGASSERT(sp != NULL);\n\n#ifdef __FTS_COMPAT_LENGTH\n\t/* Protect against fts_pathlen overflow. */\n\tif (size > USHRT_MAX + 1) {\n\t\terrno = ENAMETOOLONG;\n\t\treturn (1);\n\t}\n#endif\n\tsize = fts_pow2(size);\n\tnew = realloc(sp->fts_path, size);\n\tif (new == 0)\n\t\treturn (1);\n\tsp->fts_path = new;\n\tsp->fts_pathlen = fts_pathlen_truncate(size);\n\treturn (0);\n}",
      "lines": 22,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "fts_padjust": {
      "start_point": [
        1186,
        0
      ],
      "end_point": [
        1212,
        1
      ],
      "content": "static void\nfts_padjust(FTS *sp, FTSENT *head)\n{\n\tFTSENT *p;\n\tchar *addr;\n\n\t_DIAGASSERT(sp != NULL);\n\n#define\tADJUST(p) do {\t\t\t\t\t\t\t\\\n\tif ((p)->fts_accpath != (p)->fts_name)\t\t\t\t\\\n\t\t(p)->fts_accpath =\t\t\t\t\t\\\n\t\t    addr + ((p)->fts_accpath - (p)->fts_path);\t\t\\\n\t(p)->fts_path = addr;\t\t\t\t\t\t\\\n} while (/*CONSTCOND*/0)\n\n\taddr = sp->fts_path;\n\n\t/* Adjust the current set of children. */\n\tfor (p = sp->fts_child; p; p = p->fts_link)\n\t\tADJUST(p);\n\n\t/* Adjust the rest of the tree, including the current level. */\n\tfor (p = head; p->fts_level >= FTS_ROOTLEVEL;) {\n\t\tADJUST(p);\n\t\tp = p->fts_link ? p->fts_link : p->fts_parent;\n\t}\n}",
      "lines": 27,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "fts_maxarglen": {
      "start_point": [
        1214,
        0
      ],
      "end_point": [
        1225,
        1
      ],
      "content": "static size_t\nfts_maxarglen(char * const *argv)\n{\n\tsize_t len, max;\n\n\t_DIAGASSERT(argv != NULL);\n\n\tfor (max = 0; *argv; ++argv)\n\t\tif ((len = strlen(*argv)) > max)\n\t\t\tmax = len;\n\treturn (max + 1);\n}",
      "lines": 12,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "fts_safe_changedir": {
      "start_point": [
        1232,
        0
      ],
      "end_point": [
        1261,
        1
      ],
      "content": "static int\nfts_safe_changedir(const FTS *sp, const FTSENT *p, int fd, const char *path)\n{\n\tint oldfd = fd, ret = -1;\n\tstruct stat sb;\n\n\tif (ISSET(FTS_NOCHDIR))\n\t\treturn 0;\n\n\tif (oldfd < 0 && (path == NULL || (fd = open(path, O_RDONLY)) == -1))\n\t\treturn -1;\n\n\tif (fstat(fd, &sb) == -1)\n\t\tgoto bail;\n\n\tif (sb.st_ino != p->fts_ino || sb.st_dev != p->fts_dev) {\n\t\terrno = ENOENT;\n\t\tgoto bail;\n\t}\n\n\tret = fchdir(fd);\n\nbail:\n\tif (oldfd < 0) {\n\t\tint save_errno = errno;\n\t\t(void)close(fd);\n\t\terrno = save_errno;\n\t}\n\treturn ret;\n}",
      "lines": 30,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "gawk/gawk-4.2.1/extension/gawkfts.h": {},
  "gawk/gawk-4.2.1/extension/inplace.c": {
    "mkstemp": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "int\nmkstemp (char *template)\n{\n  char *tmp_fname = _mktemp (template);\n\n  if (tmp_fname)\n    return _open (tmp_fname, O_RDWR | O_CREAT | O_EXCL, S_IREAD | S_IWRITE);\n  return -1;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "at_exit": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        101,
        1
      ],
      "content": "static void\nat_exit(void *data, int exit_status)\n{\n\t(void) data;\t\t/* silence warnings */\n\t(void) exit_status;\t/* silence warnings */\n\tif (state.tname) {\n\t\tunlink(state.tname);\n\t\tgawk_free(state.tname);\n\t\tstate.tname = NULL;\n\t}\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "invalid_filename": {
      "start_point": [
        110,
        0
      ],
      "end_point": [
        115,
        1
      ],
      "content": "static int\ninvalid_filename(const awk_string_t *filename)\n{\n\treturn filename->len == 0 ||\n\t\t(filename->len == 1 && *filename->str == '-');\n}",
      "lines": 6,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "do_inplace_begin": {
      "start_point": [
        119,
        0
      ],
      "end_point": [
        198,
        1
      ],
      "content": "static awk_value_t *\ndo_inplace_begin(int nargs, awk_value_t *result, struct awk_ext_func *unused)\n{\n\tawk_value_t filename;\n\tstruct stat sbuf;\n\tint fd;\n\n\tassert(result != NULL);\n\tfflush(stdout);\n\n\tif (state.tname)\n\t\tfatal(ext_id, _(\"inplace_begin: in-place editing already active\"));\n\n\tif (nargs != 2)\n\t\tfatal(ext_id, _(\"inplace_begin: expects 2 arguments but called with %d\"), nargs);\n\n\tif (! get_argument(0, AWK_STRING, &filename))\n\t\tfatal(ext_id, _(\"inplace_begin: cannot retrieve 1st argument as a string filename\"));\n\n\t/*\n\t * N.B. In the current implementation, the 2nd suffix arg is not used\n\t * in this function.  It is used only in the inplace_end function.\n\t */\n\n\tif (invalid_filename(&filename.str_value)) {\n\t\twarning(ext_id, _(\"inplace_begin: disabling in-place editing for invalid FILENAME `%s'\"),\n\t\t\tfilename.str_value.str);\n\t\tunset_ERRNO();\n\t\treturn make_number(-1, result);\n\t}\n\n\tif (stat(filename.str_value.str, & sbuf) < 0) {\n\t\twarning(ext_id, _(\"inplace_begin: Cannot stat `%s' (%s)\"),\n\t\t\tfilename.str_value.str, strerror(errno));\n\t\tupdate_ERRNO_int(errno);\n\t\treturn make_number(-1, result);\n\t}\n\n\tif (! S_ISREG(sbuf.st_mode)) {\n\t\twarning(ext_id, _(\"inplace_begin: `%s' is not a regular file\"),\n\t\t\tfilename.str_value.str);\n\t\tunset_ERRNO();\n\t\treturn make_number(-1, result);\n\t}\n\n\t/* create a temporary file to which to redirect stdout */\n\temalloc(state.tname, char *, filename.str_value.len+14, \"do_inplace_begin\");\n\tsprintf(state.tname, \"%s.gawk.XXXXXX\", filename.str_value.str);\n\n\tif ((fd = mkstemp(state.tname)) < 0)\n\t\tfatal(ext_id, _(\"inplace_begin: mkstemp(`%s') failed (%s)\"),\n\t\t\tstate.tname, strerror(errno));\n\n\t/* N.B. chown/chmod should be more portable than fchown/fchmod */\n\tif (chown(state.tname, sbuf.st_uid, sbuf.st_gid) < 0) {\n\t\t/* jumping through hoops to silence gcc and clang. :-( */\n\t\tint junk;\n\t\tjunk = chown(state.tname, -1, sbuf.st_gid);\n\t\t++junk;\n\t}\n\n\tif (chmod(state.tname, sbuf.st_mode) < 0)\n\t\tfatal(ext_id, _(\"inplace_begin: chmod failed (%s)\"),\n\t\t\tstrerror(errno));\n\n\tfflush(stdout);\n\t/* N.B. fgetpos fails when stdout is a tty */\n\tstate.posrc = fgetpos(stdout, &state.pos);\n\tif ((state.default_stdout = dup(STDOUT_FILENO)) < 0)\n\t\tfatal(ext_id, _(\"inplace_begin: dup(stdout) failed (%s)\"),\n\t\t\tstrerror(errno));\n\tif (dup2(fd, STDOUT_FILENO) < 0)\n\t\tfatal(ext_id, _(\"inplace_begin: dup2(%d, stdout) failed (%s)\"),\n\t\t\tfd, strerror(errno));\n\tif (close(fd) < 0)\n\t\tfatal(ext_id, _(\"inplace_begin: close(%d) failed (%s)\"),\n\t\t\tfd, strerror(errno));\n\trewind(stdout);\n\treturn make_number(0, result);\n}",
      "lines": 80,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "awk_value_t",
        "*\ndo_inplace_begin(int nargs, awk_value_t *result, struct awk_ext_func *unused)",
        "*"
      ]
    },
    "do_inplace_end": {
      "start_point": [
        202,
        0
      ],
      "end_point": [
        261,
        1
      ],
      "content": "static awk_value_t *\ndo_inplace_end(int nargs, awk_value_t *result, struct awk_ext_func *unused)\n{\n\tawk_value_t filename, suffix;\n\n\tassert(result != NULL);\n\n\tif (nargs != 2)\n\t\tfatal(ext_id, _(\"inplace_end: expects 2 arguments but called with %d\"), nargs);\n\n\tif (! get_argument(0, AWK_STRING, &filename))\n\t\tfatal(ext_id, _(\"inplace_end: cannot retrieve 1st argument as a string filename\"));\n\n\tif (! get_argument(1, AWK_STRING, &suffix))\n\t\tsuffix.str_value.str = NULL;\n\n\tif (! state.tname) {\n\t\tif (! invalid_filename(&filename.str_value))\n\t\t\twarning(ext_id, _(\"inplace_end: in-place editing not active\"));\n\t\treturn make_number(0, result);\n\t}\n\n\tfflush(stdout);\n\tif (dup2(state.default_stdout, STDOUT_FILENO) < 0)\n\t\tfatal(ext_id, _(\"inplace_end: dup2(%d, stdout) failed (%s)\"),\n\t\t\tstate.default_stdout, strerror(errno));\n\tif (close(state.default_stdout) < 0)\n\t\tfatal(ext_id, _(\"inplace_end: close(%d) failed (%s)\"),\n\t\t\tstate.default_stdout, strerror(errno));\n\tstate.default_stdout = -1;\n\tif (state.posrc == 0 && fsetpos(stdout, &state.pos) < 0)\n\t\tfatal(ext_id, _(\"inplace_end: fsetpos(stdout) failed (%s)\"),\n\t\t\tstrerror(errno));\n\n\tif (suffix.str_value.str && suffix.str_value.str[0]) {\n\t\t/* backup requested */\n\t\tchar *bakname;\n\n\t\temalloc(bakname, char *, filename.str_value.len+suffix.str_value.len+1,\n\t\t\t\"do_inplace_end\");\n\t\tsprintf(bakname, \"%s%s\",\n\t\t\tfilename.str_value.str, suffix.str_value.str);\n\t\tunlink(bakname); /* if backup file exists already, remove it */\n\t\tif (link(filename.str_value.str, bakname) < 0)\n\t\t\tfatal(ext_id, _(\"inplace_end: link(`%s', `%s') failed (%s)\"),\n\t\t\t\tfilename.str_value.str, bakname, strerror(errno));\n\t\tgawk_free(bakname);\n\t}\n\n#ifdef __MINGW32__\n\tunlink(filename.str_value.str);\n#endif\n\n\tif (rename(state.tname, filename.str_value.str) < 0)\n\t\tfatal(ext_id, _(\"inplace_end: rename(`%s', `%s') failed (%s)\"),\n\t\t\tstate.tname, filename.str_value.str, strerror(errno));\n\tgawk_free(state.tname);\n\tstate.tname = NULL;\n\treturn make_number(0, result);\n}",
      "lines": 60,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "awk_value_t",
        "*\ndo_inplace_end(int nargs, awk_value_t *result, struct awk_ext_func *unused)",
        "*"
      ]
    },
    "init_inplace": {
      "start_point": [
        268,
        0
      ],
      "end_point": [
        272,
        1
      ],
      "content": "static awk_bool_t init_inplace(void)\n{\n\tawk_atexit(at_exit, NULL);\n\treturn awk_true;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "awk_bool_t"
      ]
    }
  },
  "gawk/gawk-4.2.1/extension/intdiv.c": {
    "double_to_int": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        46,
        1
      ],
      "content": "static double\ndouble_to_int(double d)\n{\n\tif (d >= 0)\n\t\td = floor(d);\n\telse\n\t\td = ceil(d);\n\treturn d;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "array_set_number": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "static void\narray_set_number(awk_array_t array, const char *sub, size_t sublen, double num)\n{\n\tawk_value_t index, tmp;\n\n\tset_array_element(array, make_const_string(sub, sublen, & index), make_number(num, & tmp));\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mpz_conv": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        82,
        1
      ],
      "content": "static mpz_ptr\nmpz_conv(const awk_value_t *arg, mpz_ptr tmp)\n{\n\tswitch (arg->num_type) {\n\tcase AWK_NUMBER_TYPE_MPZ:\n\t\treturn arg->num_ptr;\n\tcase AWK_NUMBER_TYPE_MPFR:\n\t\tif (! mpfr_number_p(arg->num_ptr))\n\t\t\treturn NULL;\n\t\tmpz_init(tmp);\n\t\tmpfr_get_z(tmp, arg->num_ptr, MPFR_RNDZ);\n\t\treturn tmp;\n\tcase AWK_NUMBER_TYPE_DOUBLE:\t/* can this happen? */\n\t\tmpz_init(tmp);\n\t\tmpz_set_d(tmp, double_to_int(arg->num_value));\n\t\treturn tmp;\n\tdefault:\t/* should never happen */\n\t\tfatal(ext_id, _(\"intdiv: invalid numeric type `%d'\"), arg->num_type);\n\t\treturn NULL;\n\t}\n}",
      "lines": 21,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "mpz_ptr"
      ]
    },
    "array_set_mpz": {
      "start_point": [
        86,
        0
      ],
      "end_point": [
        92,
        1
      ],
      "content": "static void\narray_set_mpz(awk_array_t array, const char *sub, size_t sublen, mpz_ptr num)\n{\n\tawk_value_t index, tmp;\n\n\tset_array_element(array, make_const_string(sub, sublen, & index), make_number_mpz(num, & tmp));\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "gawk/gawk-4.2.1/extension/ordchr.c": {
    "do_ord": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "static awk_value_t *\ndo_ord(int nargs, awk_value_t *result, struct awk_ext_func *unused)\n{\n\tawk_value_t str;\n\tdouble ret = -1;\n\n\tassert(result != NULL);\n\n\tif (get_argument(0, AWK_STRING, & str)) {\n\t\tret = str.str_value.str[0];\n\t} else if (do_lint)\n\t\tlintwarn(ext_id, _(\"ord: called with inappropriate argument(s)\"));\n\n\t/* Set the return value */\n\treturn make_number(ret, result);\n}",
      "lines": 16,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "awk_value_t",
        "*\ndo_ord(int nargs, awk_value_t *result, struct awk_ext_func *unused)",
        "*"
      ]
    },
    "do_chr": {
      "start_point": [
        78,
        0
      ],
      "end_point": [
        101,
        1
      ],
      "content": "static awk_value_t *\ndo_chr(int nargs, awk_value_t *result, struct awk_ext_func *unused)\n{\n\tawk_value_t num;\n\tunsigned int ret = 0;\n\tdouble val = 0.0;\n\tchar str[2];\n\n\tstr[0] = str[1] = '\\0';\n\n\tassert(result != NULL);\n\n\tif (get_argument(0, AWK_NUMBER, & num)) {\n\t\tval = num.num_value;\n\t\tret = val;\t/* convert to int */\n\t\tret &= 0xff;\n\t\tstr[0] = ret;\n\t\tstr[1] = '\\0';\n\t} else if (do_lint)\n\t\tlintwarn(ext_id, _(\"chr: called with inappropriate argument(s)\"));\n\n\t/* Set the return value */\n\treturn make_const_string(str, 1, result);\n}",
      "lines": 24,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "awk_value_t",
        "*\ndo_chr(int nargs, awk_value_t *result, struct awk_ext_func *unused)",
        "*"
      ]
    }
  },
  "gawk/gawk-4.2.1/extension/readdir.c": {
    "ftype": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        136,
        1
      ],
      "content": "static const char *\nftype(struct dirent *entry, const char *dirname)\n{\n#ifdef DT_BLK\n\t(void) dirname;\t\t/* silence warnings */\n\tswitch (entry->d_type) {\n\tcase DT_BLK:\treturn \"b\";\n\tcase DT_CHR:\treturn \"c\";\n\tcase DT_DIR:\treturn \"d\";\n\tcase DT_FIFO:\treturn \"p\";\n\tcase DT_LNK:\treturn \"l\";\n\tcase DT_REG:\treturn \"f\";\n\tcase DT_SOCK:\treturn \"s\";\n\tdefault:\n\tcase DT_UNKNOWN: return \"u\";\n\t}\n#else\n\tchar fname[PATH_MAX];\n\tstruct stat sbuf;\n\n\tstrcpy(fname, dirname);\n\tstrcat(fname, \"/\");\n\tstrcat(fname, entry->d_name);\n\tif (stat(fname, &sbuf) == 0) {\n\t\tif (S_ISBLK(sbuf.st_mode))\n\t\t\treturn \"b\";\n\t\tif (S_ISCHR(sbuf.st_mode))\n\t\t\treturn \"c\";\n\t\tif (S_ISDIR(sbuf.st_mode))\n\t\t\treturn \"d\";\n\t\tif (S_ISFIFO(sbuf.st_mode))\n\t\t\treturn \"p\";\n\t\tif (S_ISREG(sbuf.st_mode))\n\t\t\treturn \"f\";\n#ifdef S_ISLNK\n\t\tif (S_ISLNK(sbuf.st_mode))\n\t\t\treturn \"l\";\n#endif\n#ifdef S_ISSOCK\n\t\tif (S_ISSOCK(sbuf.st_mode))\n\t\t\treturn \"s\";\n#endif\n\t}\n\treturn \"u\";\n#endif\n}",
      "lines": 46,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nftype(struct dirent *entry, const char *dirname)",
        "*"
      ]
    },
    "get_inode": {
      "start_point": [
        140,
        0
      ],
      "end_point": [
        165,
        1
      ],
      "content": "static long long\nget_inode(struct dirent *entry, const char *dirname)\n{\n#ifdef __MINGW32__\n\tchar fname[PATH_MAX];\n\tHANDLE fh;\n\tBY_HANDLE_FILE_INFORMATION info;\n\n\tsprintf(fname, \"%s\\\\%s\", dirname, entry->d_name);\n\tfh = CreateFile(fname, 0, 0, NULL, OPEN_EXISTING,\n\t\t\tFILE_FLAG_BACKUP_SEMANTICS, NULL);\n\tif (fh == INVALID_HANDLE_VALUE)\n\t\treturn 0;\n\tif (GetFileInformationByHandle(fh, &info)) {\n\t\tlong long inode = info.nFileIndexHigh;\n\n\t\tinode <<= 32;\n\t\tinode += info.nFileIndexLow;\n\t\treturn inode;\n\t}\n\treturn 0;\n#else\n\t(void) dirname;\t\t/* silence warnings */\n\treturn entry->d_ino;\n#endif\n}",
      "lines": 26,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "long long",
        "long",
        "long"
      ]
    },
    "dir_get_record": {
      "start_point": [
        169,
        0
      ],
      "end_point": [
        218,
        1
      ],
      "content": "static int\ndir_get_record(char **out, awk_input_buf_t *iobuf, int *errcode,\n\t\tchar **rt_start, size_t *rt_len,\n\t\tconst awk_fieldwidth_info_t **unused)\n{\n\tDIR *dp;\n\tstruct dirent *dirent;\n\tint len;\n\topen_directory_t *the_dir;\n\tconst char *ftstr;\n\tunsigned long long ino;\n\n\t/*\n\t * The caller sets *errcode to 0, so we should set it only if an\n\t * error occurs.\n\t */\n\n\tif (out == NULL || iobuf == NULL || iobuf->opaque == NULL)\n\t\treturn EOF;\n\n\tthe_dir = (open_directory_t *) iobuf->opaque;\n\tdp = the_dir->dp;\n\n\t/*\n\t * Initialize errno, since readdir does not set it to zero on EOF.\n\t */\n\terrno = 0;\n\tdirent = readdir(dp);\n\tif (dirent == NULL) {\n\t\t*errcode = errno;\t/* in case there was an error */\n\t\treturn EOF;\n\t}\n\n\tino = get_inode(dirent, iobuf->name);\n\n#if __MINGW32__\n\tlen = sprintf(the_dir->buf, \"%I64u/%s\", ino, dirent->d_name);\n#else\n\tlen = sprintf(the_dir->buf, \"%llu/%s\", ino, dirent->d_name);\n#endif\n\n\tftstr = ftype(dirent, iobuf->name);\n\tlen += sprintf(the_dir->buf + len, \"/%s\", ftstr);\n\n\t*out = the_dir->buf;\n\n\t*rt_start = NULL;\n\t*rt_len = 0;\t/* set RT to \"\" */\n\treturn len;\n}",
      "lines": 50,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "dir_close": {
      "start_point": [
        222,
        0
      ],
      "end_point": [
        237,
        1
      ],
      "content": "static void\ndir_close(awk_input_buf_t *iobuf)\n{\n\topen_directory_t *the_dir;\n\n\tif (iobuf == NULL || iobuf->opaque == NULL)\n\t\treturn;\n\n\tthe_dir = (open_directory_t *) iobuf->opaque;\n\n\tclosedir(the_dir->dp);\n\tgawk_free(the_dir->buf);\n\tgawk_free(the_dir);\n\n\tiobuf->fd = -1;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "dir_can_take_file": {
      "start_point": [
        241,
        0
      ],
      "end_point": [
        248,
        1
      ],
      "content": "static awk_bool_t\ndir_can_take_file(const awk_input_buf_t *iobuf)\n{\n\tif (iobuf == NULL)\n\t\treturn awk_false;\n\n\treturn (iobuf->fd != INVALID_HANDLE && S_ISDIR(iobuf->sbuf.st_mode));\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "awk_bool_t"
      ]
    },
    "dir_take_control_of": {
      "start_point": [
        256,
        0
      ],
      "end_point": [
        288,
        1
      ],
      "content": "static awk_bool_t\ndir_take_control_of(awk_input_buf_t *iobuf)\n{\n\tDIR *dp;\n\topen_directory_t *the_dir;\n\tsize_t size;\n\n\terrno = 0;\n#ifdef HAVE_FDOPENDIR\n\tdp = fdopendir(iobuf->fd);\n#else\n\tdp = opendir(iobuf->name);\n\tif (dp != NULL)\n\t\tiobuf->fd = dirfd(dp);\n#endif\n\tif (dp == NULL) {\n\t\twarning(ext_id, _(\"dir_take_control_of: opendir/fdopendir failed: %s\"),\n\t\t\t\tstrerror(errno));\n\t\tupdate_ERRNO_int(errno);\n\t\treturn awk_false;\n\t}\n\n\temalloc(the_dir, open_directory_t *, sizeof(open_directory_t), \"dir_take_control_of\");\n\tthe_dir->dp = dp;\n\tsize = sizeof(struct dirent) + 21 /* max digits in inode */ + 2 /* slashes */;\n\temalloc(the_dir->buf, char *, size, \"dir_take_control_of\");\n\n\tiobuf->opaque = the_dir;\n\tiobuf->get_record = dir_get_record;\n\tiobuf->close_func = dir_close;\n\n\treturn awk_true;\n}",
      "lines": 33,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "awk_bool_t"
      ]
    },
    "init_readdir": {
      "start_point": [
        308,
        0
      ],
      "end_point": [
        317,
        1
      ],
      "content": "static awk_bool_t\ninit_readdir()\n{\n\tregister_input_parser(& readdir_parser);\n#ifdef TEST_DUPLICATE\n\tregister_input_parser(& readdir_parser2);\n#endif\n\n\treturn awk_true;\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "awk_bool_t"
      ]
    }
  },
  "gawk/gawk-4.2.1/extension/readdir_test.c": {
    "ftype": {
      "start_point": [
        96,
        0
      ],
      "end_point": [
        141,
        1
      ],
      "content": "static const char *\nftype(struct dirent *entry, const char *dirname)\n{\n#ifdef DT_BLK\n\t(void) dirname;\t\t/* silence warnings */\n\tswitch (entry->d_type) {\n\tcase DT_BLK:\treturn \"b\";\n\tcase DT_CHR:\treturn \"c\";\n\tcase DT_DIR:\treturn \"d\";\n\tcase DT_FIFO:\treturn \"p\";\n\tcase DT_LNK:\treturn \"l\";\n\tcase DT_REG:\treturn \"f\";\n\tcase DT_SOCK:\treturn \"s\";\n\tdefault:\n\tcase DT_UNKNOWN: return \"u\";\n\t}\n#else\n\tchar fname[PATH_MAX];\n\tstruct stat sbuf;\n\n\tstrcpy(fname, dirname);\n\tstrcat(fname, \"/\");\n\tstrcat(fname, entry->d_name);\n\tif (stat(fname, &sbuf) == 0) {\n\t\tif (S_ISBLK(sbuf.st_mode))\n\t\t\treturn \"b\";\n\t\tif (S_ISCHR(sbuf.st_mode))\n\t\t\treturn \"c\";\n\t\tif (S_ISDIR(sbuf.st_mode))\n\t\t\treturn \"d\";\n\t\tif (S_ISFIFO(sbuf.st_mode))\n\t\t\treturn \"p\";\n\t\tif (S_ISREG(sbuf.st_mode))\n\t\t\treturn \"f\";\n#ifdef S_ISLNK\n\t\tif (S_ISLNK(sbuf.st_mode))\n\t\t\treturn \"l\";\n#endif\n#ifdef S_ISSOCK\n\t\tif (S_ISSOCK(sbuf.st_mode))\n\t\t\treturn \"s\";\n#endif\n\t}\n\treturn \"u\";\n#endif\n}",
      "lines": 46,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nftype(struct dirent *entry, const char *dirname)",
        "*"
      ]
    },
    "get_inode": {
      "start_point": [
        145,
        0
      ],
      "end_point": [
        170,
        1
      ],
      "content": "static long long\nget_inode(struct dirent *entry, const char *dirname)\n{\n#ifdef __MINGW32__\n\tchar fname[PATH_MAX];\n\tHANDLE fh;\n\tBY_HANDLE_FILE_INFORMATION info;\n\n\tsprintf(fname, \"%s\\\\%s\", dirname, entry->d_name);\n\tfh = CreateFile(fname, 0, 0, NULL, OPEN_EXISTING,\n\t\t\tFILE_FLAG_BACKUP_SEMANTICS, NULL);\n\tif (fh == INVALID_HANDLE_VALUE)\n\t\treturn 0;\n\tif (GetFileInformationByHandle(fh, &info)) {\n\t\tlong long inode = info.nFileIndexHigh;\n\n\t\tinode <<= 32;\n\t\tinode += info.nFileIndexLow;\n\t\treturn inode;\n\t}\n\treturn 0;\n#else\n\t(void) dirname;\t\t/* silence warnings */\n\treturn entry->d_ino;\n#endif\n}",
      "lines": 26,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "long long",
        "long",
        "long"
      ]
    },
    "dir_get_record": {
      "start_point": [
        174,
        0
      ],
      "end_point": [
        229,
        1
      ],
      "content": "static int\ndir_get_record(char **out, awk_input_buf_t *iobuf, int *errcode,\n\t\tchar **rt_start, size_t *rt_len,\n\t\tconst awk_fieldwidth_info_t **field_width)\n{\n\tDIR *dp;\n\tstruct dirent *dirent;\n\tint len, flen;\n\topen_directory_t *the_dir;\n\tconst char *ftstr;\n\tunsigned long long ino;\n\n\t/*\n\t * The caller sets *errcode to 0, so we should set it only if an\n\t * error occurs.\n\t */\n\n\tif (out == NULL || iobuf == NULL || iobuf->opaque == NULL)\n\t\treturn EOF;\n\n\tthe_dir = (open_directory_t *) iobuf->opaque;\n\tdp = the_dir->dp;\n\n\t/*\n\t * Initialize errno, since readdir does not set it to zero on EOF.\n\t */\n\terrno = 0;\n\tdirent = readdir(dp);\n\tif (dirent == NULL) {\n\t\t*errcode = errno;\t/* in case there was an error */\n\t\treturn EOF;\n\t}\n\n\tino = get_inode(dirent, iobuf->name);\n\n#if __MINGW32__\n\tlen = sprintf(the_dir->buf, \"%I64u\", ino);\n#else\n\tlen = sprintf(the_dir->buf, \"%llu\", ino);\n#endif\n\tthe_dir->fw.fields[0].len = len;\n\tlen += (flen = sprintf(the_dir->buf + len, \"/%s\", dirent->d_name));\n\tthe_dir->fw.fields[1].len = flen-1;\n\n\tftstr = ftype(dirent, iobuf->name);\n\tlen += (flen = sprintf(the_dir->buf + len, \"/%s\", ftstr));\n\tthe_dir->fw.fields[2].len = flen-1;\n\n\t*out = the_dir->buf;\n\n\t*rt_start = NULL;\n\t*rt_len = 0;\t/* set RT to \"\" */\n\tif (field_width)\n\t\t*field_width = & the_dir->fw;\n\treturn len;\n}",
      "lines": 56,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "dir_close": {
      "start_point": [
        233,
        0
      ],
      "end_point": [
        248,
        1
      ],
      "content": "static void\ndir_close(awk_input_buf_t *iobuf)\n{\n\topen_directory_t *the_dir;\n\n\tif (iobuf == NULL || iobuf->opaque == NULL)\n\t\treturn;\n\n\tthe_dir = (open_directory_t *) iobuf->opaque;\n\n\tclosedir(the_dir->dp);\n\tgawk_free(the_dir->buf);\n\tgawk_free(the_dir);\n\n\tiobuf->fd = -1;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "dir_can_take_file": {
      "start_point": [
        252,
        0
      ],
      "end_point": [
        259,
        1
      ],
      "content": "static awk_bool_t\ndir_can_take_file(const awk_input_buf_t *iobuf)\n{\n\tif (iobuf == NULL)\n\t\treturn awk_false;\n\n\treturn (iobuf->fd != INVALID_HANDLE && S_ISDIR(iobuf->sbuf.st_mode));\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "awk_bool_t"
      ]
    },
    "dir_take_control_of": {
      "start_point": [
        267,
        0
      ],
      "end_point": [
        305,
        1
      ],
      "content": "static awk_bool_t\ndir_take_control_of(awk_input_buf_t *iobuf)\n{\n\tDIR *dp;\n\topen_directory_t *the_dir;\n\tsize_t size;\n\n\terrno = 0;\n#ifdef HAVE_FDOPENDIR\n\tdp = fdopendir(iobuf->fd);\n#else\n\tdp = opendir(iobuf->name);\n\tif (dp != NULL)\n\t\tiobuf->fd = dirfd(dp);\n#endif\n\tif (dp == NULL) {\n\t\twarning(ext_id, _(\"dir_take_control_of: opendir/fdopendir failed: %s\"),\n\t\t\t\tstrerror(errno));\n\t\tupdate_ERRNO_int(errno);\n\t\treturn awk_false;\n\t}\n\n\temalloc(the_dir, open_directory_t *, sizeof(open_directory_t), \"dir_take_control_of\");\n\tthe_dir->dp = dp;\n\t/* pre-populate the field_width struct with constant values: */\n\tthe_dir->fw.use_chars = awk_false;\n\tthe_dir->fw.nf = 3;\n\tthe_dir->fw.fields[0].skip = 0;\t/* no leading space */\n\tthe_dir->fw.fields[1].skip = 1;\t/* single '/' separator */\n\tthe_dir->fw.fields[2].skip = 1;\t/* single '/' separator */\n\tsize = sizeof(struct dirent) + 21 /* max digits in inode */ + 2 /* slashes */;\n\temalloc(the_dir->buf, char *, size, \"dir_take_control_of\");\n\n\tiobuf->opaque = the_dir;\n\tiobuf->get_record = dir_get_record;\n\tiobuf->close_func = dir_close;\n\n\treturn awk_true;\n}",
      "lines": 39,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "awk_bool_t"
      ]
    },
    "init_readdir": {
      "start_point": [
        325,
        0
      ],
      "end_point": [
        334,
        1
      ],
      "content": "static awk_bool_t\ninit_readdir()\n{\n\tregister_input_parser(& readdir_parser);\n#ifdef TEST_DUPLICATE\n\tregister_input_parser(& readdir_parser2);\n#endif\n\n\treturn awk_true;\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "awk_bool_t"
      ]
    }
  },
  "gawk/gawk-4.2.1/extension/readfile.c": {
    "read_file_to_buffer": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        92,
        1
      ],
      "content": "static char *\nread_file_to_buffer(int fd, const struct stat *sbuf)\n{\n\tchar *text;\n\n\tif ((sbuf->st_mode & S_IFMT) != S_IFREG) {\n\t\terrno = EINVAL;\n\t\tupdate_ERRNO_int(errno);\n\t\treturn NULL;\n\t}\n\n\temalloc(text, char *, sbuf->st_size + 1, \"do_readfile\");\n\n\tif (read(fd, text, sbuf->st_size) != sbuf->st_size) {\n\t\tupdate_ERRNO_int(errno);\n\t\tgawk_free(text);\n\t\treturn NULL;\n\t}\n\ttext[sbuf->st_size] = '\\0';\n\treturn text;\n}",
      "lines": 21,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nread_file_to_buffer(int fd, const struct stat *sbuf)",
        "*"
      ]
    },
    "do_readfile": {
      "start_point": [
        96,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "static awk_value_t *\ndo_readfile(int nargs, awk_value_t *result, struct awk_ext_func *unused)\n{\n\tawk_value_t filename;\n\tint ret;\n\tstruct stat sbuf;\n\tchar *text;\n\tint fd;\n\n\tassert(result != NULL);\n\tmake_null_string(result);\t/* default return value */\n\n\tunset_ERRNO();\n\n\tif (get_argument(0, AWK_STRING, &filename)) {\n\t\tret = stat(filename.str_value.str, & sbuf);\n\t\tif (ret < 0) {\n\t\t\tupdate_ERRNO_int(errno);\n\t\t\tgoto done;\n\t\t}\n\n\t\tif ((fd = open(filename.str_value.str, O_RDONLY|O_BINARY)) < 0) {\n\t\t\tupdate_ERRNO_int(errno);\n\t\t\tgoto done;\n\t\t}\n\n\t\ttext = read_file_to_buffer(fd, & sbuf);\n\t\tif (text == NULL)\n\t\t\tgoto done;\t/* ERRNO already updated */\n\n\t\tclose(fd);\n\t\tmake_malloced_string(text, sbuf.st_size, result);\n\t\tgoto done;\n\t} else if (do_lint)\n\t\tlintwarn(ext_id, _(\"readfile: called with wrong kind of argument\"));\n\ndone:\n\t/* Set the return value */\n\treturn result;\n}",
      "lines": 40,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "awk_value_t",
        "*\ndo_readfile(int nargs, awk_value_t *result, struct awk_ext_func *unused)",
        "*"
      ]
    },
    "readfile_get_record": {
      "start_point": [
        139,
        0
      ],
      "end_point": [
        179,
        1
      ],
      "content": "static int\nreadfile_get_record(char **out, awk_input_buf_t *iobuf, int *errcode,\n\t\t\tchar **rt_start, size_t *rt_len,\n\t\t\tconst awk_fieldwidth_info_t **unused)\n{\n\tchar *text;\n\n\t/*\n\t * The caller sets *errcode to 0, so we should set it only if an\n\t * error occurs.\n\t */\n\n\tif (out == NULL || iobuf == NULL)\n\t\treturn EOF;\n\n\tif (iobuf->opaque != NULL) {\n\t\t/*\n\t\t * Already read the whole file,\n\t\t * free up stuff and return EOF\n\t\t */\n\t\tgawk_free(iobuf->opaque);\n\t\tiobuf->opaque = NULL;\n\t\treturn EOF;\n\t}\n\n\t/* read file */\n\ttext = read_file_to_buffer(iobuf->fd, & iobuf->sbuf);\n\tif (text == NULL)\n\t\treturn EOF;\n\n\t/* set up the iobuf for next time */\n\tiobuf->opaque = text;\n\n\t/* set return values */\n\t*rt_start = NULL;\n\t*rt_len = 0;\n\t*out = text;\n\n\t/* return count */\n\treturn iobuf->sbuf.st_size;\n}",
      "lines": 41,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "readfile_can_take_file": {
      "start_point": [
        183,
        0
      ],
      "end_point": [
        206,
        1
      ],
      "content": "static awk_bool_t\nreadfile_can_take_file(const awk_input_buf_t *iobuf)\n{\n\tawk_value_t array, index, value;\n\n\tif (iobuf == NULL)\n\t\treturn awk_false;\n\n\t/*\n\t * This could fail if PROCINFO isn't referenced from\n\t * the awk program. It's not a \"can't happen\" error.\n\t */\n\tif (! sym_lookup(\"PROCINFO\", AWK_ARRAY, & array)) {\n\t\treturn awk_false;\n\t}\n\n\t(void) make_const_string(\"readfile\", 8, & index);\n\n\tif (! get_array_element(array.array_cookie, & index, AWK_UNDEFINED, & value)) {\n\t\treturn awk_false;\n\t}\n\n\treturn awk_true;\n}",
      "lines": 24,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "awk_bool_t"
      ]
    },
    "readfile_take_control_of": {
      "start_point": [
        210,
        0
      ],
      "end_point": [
        218,
        1
      ],
      "content": "static awk_bool_t\nreadfile_take_control_of(awk_input_buf_t *iobuf)\n{\n\tif (iobuf == NULL)\n\t\treturn awk_false;\n\n\tiobuf->get_record = readfile_get_record;\n\treturn awk_true;\n}",
      "lines": 9,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "awk_bool_t"
      ]
    },
    "init_readfile": {
      "start_point": [
        229,
        0
      ],
      "end_point": [
        235,
        1
      ],
      "content": "static awk_bool_t\ninit_readfile()\n{\n\tregister_input_parser(& readfile_parser);\n\n\treturn awk_true;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "awk_bool_t"
      ]
    }
  },
  "gawk/gawk-4.2.1/extension/revoutput.c": {
    "rev_fwrite": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "static size_t\nrev_fwrite(const void *buf, size_t size, size_t count, FILE *fp, void *opaque)\n{\n\tconst char *cp = buf;\n\tint nbytes = size * count;\n\n\t(void) opaque;\n\n\tfor (; nbytes >= 1; nbytes--)\n\t\tputc(cp[nbytes-1], fp);\n\n\treturn (size * count);\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "revoutput_can_take_file": {
      "start_point": [
        75,
        0
      ],
      "end_point": [
        87,
        1
      ],
      "content": "static awk_bool_t\nrevoutput_can_take_file(const awk_output_buf_t *outbuf)\n{\n\tawk_value_t value;\n\n\tif (outbuf == NULL)\n\t\treturn awk_false;\n\n\tif (! sym_lookup(\"REVOUT\", AWK_NUMBER, & value))\n\t\treturn awk_false;\n\n\treturn (value.num_value != 0);\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "awk_bool_t"
      ]
    },
    "revoutput_take_control_of": {
      "start_point": [
        95,
        0
      ],
      "end_point": [
        104,
        1
      ],
      "content": "static awk_bool_t\nrevoutput_take_control_of(awk_output_buf_t *outbuf)\n{\n\tif (outbuf == NULL)\n\t\treturn awk_false;\n\n\toutbuf->gawk_fwrite = rev_fwrite;\n\toutbuf->redirected = awk_true;\n\treturn awk_true;\n}",
      "lines": 10,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "awk_bool_t"
      ]
    },
    "init_revoutput": {
      "start_point": [
        115,
        0
      ],
      "end_point": [
        133,
        1
      ],
      "content": "static awk_bool_t\ninit_revoutput()\n{\n\tawk_value_t value;\n\n\tregister_output_wrapper(& output_wrapper);\n\n\tif (! sym_lookup(\"REVOUT\", AWK_SCALAR, & value)) {\n\t\t/* only install it if not there, e.g. -v REVOUT=1 */\n\t\tmake_number(0.0, & value);\t/* init to false */\n\t\tif (! sym_update(\"REVOUT\", & value)) {\n\t\t\twarning(ext_id, _(\"revoutput: could not initialize REVOUT variable\"));\n\n\t\t\treturn awk_false;\n\t\t}\n\t}\n\n\treturn awk_true;\n}",
      "lines": 19,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "awk_bool_t"
      ]
    }
  },
  "gawk/gawk-4.2.1/extension/revtwoway.c": {
    "gawk_getdtablesize": {
      "start_point": [
        68,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "static inline int\ngawk_getdtablesize()\n{\n\t/*\n\t * Algorithm for the GNULIB folks:\n\t *\n\t * Set up a bitmap of 2048 elements.\n\t * Initialize it to zero.\n\t * In a loop, do\n\t * \tfd = open(\"/dev/null\", O_RDONLY)\n\t * \tset the bit corresponding to fd in the bit map\n\t * until it fails.\n\t * Get the highest value that succeeded and increment it by one\n\t * --> that is how many descriptors we have.\n\t * Loop over the bitmap to close all the file descriptors we opened.\n\t *\n\t * Do all this upon the first call and return static values upon\n\t * subsequent calls.\n\t */\n\n\t/* In the meantime, this is good enough for us: */\n\treturn 1024;\n}",
      "lines": 23,
      "depth": 4,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "close_two_proc_data": {
      "start_point": [
        115,
        0
      ],
      "end_point": [
        125,
        1
      ],
      "content": "static void\nclose_two_proc_data(two_way_proc_data_t *proc_data)\n{\n\tif (proc_data->in_use > 1) {\n\t\tproc_data->in_use--;\n\t\treturn;\n\t}\n\n\tgawk_free(proc_data->data);\n\tgawk_free(proc_data);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "rev2way_get_record": {
      "start_point": [
        133,
        0
      ],
      "end_point": [
        169,
        1
      ],
      "content": "static int\nrev2way_get_record(char **out, awk_input_buf_t *iobuf, int *errcode,\n\t\tchar **rt_start, size_t *rt_len,\n\t\tconst awk_fieldwidth_info_t **unused)\n{\n\tint len = 0;\t/* for now */\n\ttwo_way_proc_data_t *proc_data;\n\n\t/*\n\t * The caller sets *errcode to 0, so we should set it only if an\n\t * error occurs.\n\t */\n\n\t(void) errcode;\t\t/* silence warnings */\n\tif (out == NULL || iobuf == NULL || iobuf->opaque == NULL)\n\t\treturn EOF;\n\n\tproc_data = (two_way_proc_data_t *) iobuf->opaque;\n\tif (proc_data->len == 0)\n\t\treturn 0;\n\n\t*out = proc_data->data;\n\n\tlen = proc_data->len;\n\tproc_data->len = 0;\n\n\t*rt_len = 0;\t/* default: set RT to \"\" */\n\tif (proc_data->data[len-1] == '\\n') {\n\t\twhile (proc_data->data[len-1] == '\\n') {\n\t\t\tlen--;\n\t\t\t(*rt_len)++;\n\t\t}\n\t\t*rt_start = proc_data->data + len;\n\t}\n\n\treturn len;\n}",
      "lines": 37,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rev2way_close": {
      "start_point": [
        173,
        0
      ],
      "end_point": [
        185,
        1
      ],
      "content": "static void\nrev2way_close(awk_input_buf_t *iobuf)\n{\n\ttwo_way_proc_data_t *proc_data;\n\n\tif (iobuf == NULL || iobuf->opaque == NULL)\n\t\treturn;\n\n\tproc_data = (two_way_proc_data_t *) iobuf->opaque;\n\tclose_two_proc_data(proc_data);\n\n\tiobuf->fd = INVALID_HANDLE;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "rev2way_fwrite": {
      "start_point": [
        194,
        0
      ],
      "end_point": [
        226,
        1
      ],
      "content": "static size_t\nrev2way_fwrite(const void *buf, size_t size, size_t count, FILE *fp, void *opaque)\n{\n\ttwo_way_proc_data_t *proc_data;\n\tsize_t amount, char_count;\n\tchar *src, *dest;\n\n\t(void) fp;\t/* silence warnings */\n\tif (opaque == NULL)\n\t\treturn 0;\t/* error */\n\n\tproc_data = (two_way_proc_data_t *) opaque;\n\tamount = size * count;\n\n\t/* do the dance */\n\tif (amount > proc_data->size || proc_data->len > 0) {\n\t\tif (proc_data->data == NULL)\n\t\t\temalloc(proc_data->data, char *,  amount, \"rev2way_fwrite\");\n\t\telse\n\t\t\terealloc(proc_data->data, char *, proc_data->size + amount, \"rev2way_fwrite\");\n\t\tproc_data->size += amount;\n\t}\n\n\tsrc = (char *) buf + amount -1;\n\tdest = proc_data->data + proc_data->len;\n\tfor (char_count = amount; char_count > 0; char_count--) {\n\t\t/* copy in backwards */\n\t\t*dest++ = *src--;\n\t}\n\tproc_data->len += amount;\n\n\treturn amount;\n}",
      "lines": 33,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "rev2way_fflush": {
      "start_point": [
        230,
        0
      ],
      "end_point": [
        237,
        1
      ],
      "content": "static int\nrev2way_fflush(FILE *fp, void *opaque)\n{\n\t(void) fp;\n\t(void) opaque;\n\n\treturn 0;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rev2way_ferror": {
      "start_point": [
        241,
        0
      ],
      "end_point": [
        248,
        1
      ],
      "content": "static int\nrev2way_ferror(FILE *fp, void *opaque)\n{\n\t(void) fp;\n\t(void) opaque;\n\n\treturn 0;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rev2way_fclose": {
      "start_point": [
        252,
        0
      ],
      "end_point": [
        266,
        1
      ],
      "content": "static int\nrev2way_fclose(FILE *fp, void *opaque)\n{\n\ttwo_way_proc_data_t *proc_data;\n\n\tif (opaque == NULL)\n\t\treturn EOF;\t/* error */\n\n\t(void) fp;\n\n\tproc_data = (two_way_proc_data_t *) opaque;\n\tclose_two_proc_data(proc_data);\n\n\treturn 0;\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "revtwoway_can_take_two_way": {
      "start_point": [
        271,
        0
      ],
      "end_point": [
        275,
        1
      ],
      "content": "static awk_bool_t\nrevtwoway_can_take_two_way(const char *name)\n{\n\treturn (name != NULL && strcmp(name, \"/magic/mirror\") == 0);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "awk_bool_t"
      ]
    },
    "revtwoway_take_control_of": {
      "start_point": [
        283,
        0
      ],
      "end_point": [
        317,
        1
      ],
      "content": "static awk_bool_t\nrevtwoway_take_control_of(const char *name, awk_input_buf_t *inbuf, awk_output_buf_t *outbuf)\n{\n\ttwo_way_proc_data_t *proc_data;\n\n\t(void) name;\t/* silence warnings */\n\tif (inbuf == NULL || outbuf == NULL)\n\t\treturn awk_false;\n\n\temalloc(proc_data, two_way_proc_data_t *, sizeof(two_way_proc_data_t), \"revtwoway_take_control_of\");\n\tproc_data->in_use = 2;\n\tproc_data->size = 0;\n\tproc_data->len = 0;\n\tproc_data->data = NULL;\n\n\tif (max_fds + 1 == 0)\t/* wrapped. ha! */\n\t\tmax_fds = getdtablesize();\n\n\t/* input side: */\n\tinbuf->get_record = rev2way_get_record;\n\tinbuf->close_func = rev2way_close;\n\tinbuf->fd = max_fds;\n\tinbuf->opaque = proc_data;\n\n\t/* output side: */\n\toutbuf->fp = (FILE *) max_fds++;\n\toutbuf->opaque = proc_data;\n\toutbuf->gawk_fwrite = rev2way_fwrite;\n\toutbuf->gawk_fflush = rev2way_fflush;\n\toutbuf->gawk_ferror = rev2way_ferror;\n\toutbuf->gawk_fclose = rev2way_fclose;\n\toutbuf->redirected = awk_true;\n\n\treturn awk_true;\n}",
      "lines": 35,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "awk_bool_t"
      ]
    },
    "init_revtwoway": {
      "start_point": [
        328,
        0
      ],
      "end_point": [
        336,
        1
      ],
      "content": "static awk_bool_t\ninit_revtwoway()\n{\n\tregister_two_way_processor(& two_way_processor);\n\n\tmax_fds = getdtablesize();\n\n\treturn awk_true;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "awk_bool_t"
      ]
    }
  },
  "gawk/gawk-4.2.1/extension/rwarray.c": {
    "do_writea": {
      "start_point": [
        102,
        0
      ],
      "end_point": [
        158,
        1
      ],
      "content": "static awk_value_t *\ndo_writea(int nargs, awk_value_t *result, struct awk_ext_func *unused)\n{\n\tawk_value_t filename, array;\n\tFILE *fp = NULL;\n\tuint32_t major = MAJOR;\n\tuint32_t minor = MINOR;\n\n\tassert(result != NULL);\n\tmake_number(0.0, result);\n\n\tif (nargs < 2)\n\t\tgoto out;\n\n\t/* filename is first arg, array to dump is second */\n\tif (! get_argument(0, AWK_STRING, & filename)) {\n\t\tfprintf(stderr, _(\"do_writea: argument 0 is not a string\\n\"));\n\t\terrno = EINVAL;\n\t\tgoto done1;\n\t}\n\n\tif (! get_argument(1, AWK_ARRAY, & array)) {\n\t\tfprintf(stderr, _(\"do_writea: argument 1 is not an array\\n\"));\n\t\terrno = EINVAL;\n\t\tgoto done1;\n\t}\n\n\t/* open the file, if error, set ERRNO and return */\n\tfp = fopen(filename.str_value.str, \"wb\");\n\tif (fp == NULL)\n\t\tgoto done1;\n\n\tif (fwrite(MAGIC, 1, strlen(MAGIC), fp) != strlen(MAGIC))\n\t\tgoto done1;\n\n\tmajor = htonl(major);\n\tif (fwrite(& major, 1, sizeof(major), fp) != sizeof(major))\n\t\tgoto done1;\n\n\tminor = htonl(minor);\n\tif (fwrite(& minor, 1, sizeof(minor), fp) != sizeof(minor))\n\t\tgoto done1;\n\n\tif (write_array(fp, array.array_cookie)) {\n\t\tmake_number(1.0, result);\n\t\tgoto done0;\n\t}\n\ndone1:\n\tupdate_ERRNO_int(errno);\n\tunlink(filename.str_value.str);\n\ndone0:\n\tfclose(fp);\nout:\n\treturn result;\n}",
      "lines": 57,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "awk_value_t",
        "*\ndo_writea(int nargs, awk_value_t *result, struct awk_ext_func *unused)",
        "*"
      ]
    },
    "write_array": {
      "start_point": [
        163,
        0
      ],
      "end_point": [
        192,
        1
      ],
      "content": "static awk_bool_t\nwrite_array(FILE *fp, awk_array_t array)\n{\n\tuint32_t i;\n\tuint32_t count;\n\tawk_flat_array_t *flat_array;\n\n\tif (! flatten_array(array, & flat_array)) {\n\t\tfprintf(stderr, _(\"write_array: could not flatten array\\n\"));\n\t\treturn awk_false;\n\t}\n\n\tcount = htonl(flat_array->count);\n\tif (fwrite(& count, 1, sizeof(count), fp) != sizeof(count))\n\t\treturn awk_false;\n\n\tfor (i = 0; i < flat_array->count; i++) {\n\t\tif (! write_elem(fp, & flat_array->elements[i])) {\n\t\t\t(void) release_flattened_array(array, flat_array);\n\t\t\treturn awk_false;\n\t\t}\n\t}\n\n\tif (! release_flattened_array(array, flat_array)) {\n\t\tfprintf(stderr, _(\"write_array: could not release flattened array\\n\"));\n\t\treturn awk_false;\n\t}\n\n\treturn awk_true;\n}",
      "lines": 30,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "awk_bool_t"
      ]
    },
    "write_elem": {
      "start_point": [
        196,
        0
      ],
      "end_point": [
        214,
        1
      ],
      "content": "static awk_bool_t\nwrite_elem(FILE *fp, awk_element_t *element)\n{\n\tuint32_t indexval_len;\n\tssize_t write_count;\n\n\tindexval_len = htonl(element->index.str_value.len);\n\tif (fwrite(& indexval_len, 1, sizeof(indexval_len), fp) != sizeof(indexval_len))\n\t\treturn awk_false;\n\n\tif (element->index.str_value.len > 0) {\n\t\twrite_count = fwrite(element->index.str_value.str,\n\t\t\t\t1, element->index.str_value.len, fp);\n\t\tif (write_count != (ssize_t) element->index.str_value.len)\n\t\t\treturn awk_false;\n\t}\n\n\treturn write_value(fp, & element->value);\n}",
      "lines": 19,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "awk_bool_t"
      ]
    },
    "write_value": {
      "start_point": [
        218,
        0
      ],
      "end_point": [
        270,
        1
      ],
      "content": "static awk_bool_t\nwrite_value(FILE *fp, awk_value_t *val)\n{\n\tuint32_t code, len;\n\n\tif (val->val_type == AWK_ARRAY) {\n\t\tcode = htonl(2);\n\t\tif (fwrite(& code, 1, sizeof(code), fp) != sizeof(code))\n\t\t\treturn awk_false;\n\t\treturn write_array(fp, val->array_cookie);\n\t}\n\n\tif (val->val_type == AWK_NUMBER) {\n\t\tcode = htonl(1);\n\t\tif (fwrite(& code, 1, sizeof(code), fp) != sizeof(code))\n\t\t\treturn awk_false;\n\n\t\tif (fwrite(& val->num_value, 1, sizeof(val->num_value), fp) != sizeof(val->num_value))\n\t\t\treturn awk_false;\n\t} else {\n\t\tswitch (val->val_type) {\n\t\tcase AWK_STRING:\n\t\t\tcode = htonl(0);\n\t\t\tbreak;\n\t\tcase AWK_STRNUM:\n\t\t\tcode = htonl(4);\n\t\t\tbreak;\n\t\tcase AWK_REGEX:\n\t\t\tcode = htonl(3);\n\t\t\tbreak;\n\t\tcase AWK_UNDEFINED:\n\t\t\tcode = htonl(5);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* XXX can this happen? */\n\t\t\tcode = htonl(0);\n\t\t\twarning(ext_id, _(\"array value has unknown type %d\"), val->val_type);\n\t\t\tbreak;\n\t\t}\n\t\tif (fwrite(& code, 1, sizeof(code), fp) != sizeof(code))\n\t\t\treturn awk_false;\n\n\t\tlen = htonl(val->str_value.len);\n\t\tif (fwrite(& len, 1, sizeof(len), fp) != sizeof(len))\n\t\t\treturn awk_false;\n\n\t\tif (fwrite(val->str_value.str, 1, val->str_value.len, fp)\n\t\t\t\t!= (ssize_t) val->str_value.len)\n\t\t\treturn awk_false;\n\t}\n\n\treturn awk_true;\n}",
      "lines": 53,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "awk_bool_t"
      ]
    },
    "do_reada": {
      "start_point": [
        274,
        0
      ],
      "end_point": [
        357,
        1
      ],
      "content": "static awk_value_t *\ndo_reada(int nargs, awk_value_t *result, struct awk_ext_func *unused)\n{\n\tawk_value_t filename, array;\n\tFILE *fp = NULL;\n\tuint32_t major;\n\tuint32_t minor;\n\tchar magic_buf[30];\n\n\tassert(result != NULL);\n\tmake_number(0.0, result);\n\n\tif (nargs < 2)\n\t\tgoto out;\n\n\t/* directory is first arg, array to read is second */\n\tif (! get_argument(0, AWK_STRING, & filename)) {\n\t\tfprintf(stderr, _(\"do_reada: argument 0 is not a string\\n\"));\n\t\terrno = EINVAL;\n\t\tgoto done1;\n\t}\n\n\tif (! get_argument(1, AWK_ARRAY, & array)) {\n\t\tfprintf(stderr, _(\"do_reada: argument 1 is not an array\\n\"));\n\t\terrno = EINVAL;\n\t\tgoto done1;\n\t}\n\n\tfp = fopen(filename.str_value.str, \"rb\");\n\tif (fp == NULL)\n\t\tgoto done1;\n\n\tmemset(magic_buf, '\\0', sizeof(magic_buf));\n\tif (fread(magic_buf, 1, strlen(MAGIC), fp) != strlen(MAGIC)) {\n\t\terrno = EBADF;\n\t\tgoto done1;\n\t}\n\n\tif (strcmp(magic_buf, MAGIC) != 0) {\n\t\terrno = EBADF;\n\t\tgoto done1;\n\t}\n\n\tif (fread(& major, 1, sizeof(major), fp) != sizeof(major)) {\n\t\terrno = EBADF;\n\t\tgoto done1;\n\t}\n\tmajor = ntohl(major);\n\n\tif (major != MAJOR) {\n\t\terrno = EBADF;\n\t\tgoto done1;\n\t}\n\n\tif (fread(& minor, 1, sizeof(minor), fp) != sizeof(minor)) {\n\t\t/* read() sets errno */\n\t\tgoto done1;\n\t}\n\n\tminor = ntohl(minor);\n\tif (minor != MINOR) {\n\t\terrno = EBADF;\n\t\tgoto done1;\n\t}\n\n\tif (! clear_array(array.array_cookie)) {\n\t\terrno = ENOMEM;\n\t\tfprintf(stderr, _(\"do_reada: clear_array failed\\n\"));\n\t\tgoto done1;\n\t}\n\n\tif (read_array(fp, array.array_cookie)) {\n\t\tmake_number(1.0, result);\n\t\tgoto done0;\n\t}\n\ndone1:\n\tupdate_ERRNO_int(errno);\ndone0:\n\tif (fp != NULL)\n\t\tfclose(fp);\nout:\n\treturn result;\n}",
      "lines": 84,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "awk_value_t",
        "*\ndo_reada(int nargs, awk_value_t *result, struct awk_ext_func *unused)",
        "*"
      ]
    },
    "read_array": {
      "start_point": [
        362,
        0
      ],
      "end_point": [
        389,
        1
      ],
      "content": "static awk_bool_t\nread_array(FILE *fp, awk_array_t array)\n{\n\tuint32_t i;\n\tuint32_t count;\n\tawk_element_t new_elem;\n\n\tif (fread(& count, 1, sizeof(count), fp) != sizeof(count))\n\t\treturn awk_false;\n\n\tcount = ntohl(count);\n\n\tfor (i = 0; i < count; i++) {\n\t\tif (read_elem(fp, & new_elem)) {\n\t\t\t/* add to array */\n\t\t\tif (! set_array_element_by_elem(array, & new_elem)) {\n\t\t\t\tfprintf(stderr, _(\"read_array: set_array_element failed\\n\"));\n\t\t\t\treturn awk_false;\n\t\t\t}\n\t\t} else\n\t\t\tbreak;\n\t}\n\n\tif (i != count)\n\t\treturn awk_false;\n\n\treturn awk_true;\n}",
      "lines": 28,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "awk_bool_t"
      ]
    },
    "read_elem": {
      "start_point": [
        393,
        0
      ],
      "end_point": [
        436,
        1
      ],
      "content": "static awk_bool_t\nread_elem(FILE *fp, awk_element_t *element)\n{\n\tuint32_t index_len;\n\tstatic char *buffer;\n\tstatic uint32_t buflen;\n\tssize_t ret;\n\n\tif ((ret = fread(& index_len, 1, sizeof(index_len), fp)) != sizeof(index_len)) {\n\t\treturn awk_false;\n\t}\n\tindex_len = ntohl(index_len);\n\n\tmemset(element, 0, sizeof(*element));\n\n\tif (index_len > 0) {\n\t\tif (buffer == NULL) {\n\t\t\t/* allocate buffer */\n\t\t\temalloc(buffer, char *, index_len, \"read_elem\");\n\t\t\tbuflen = index_len;\n\t\t} else if (buflen < index_len) {\n\t\t\t/* reallocate buffer */\n\t\t\tchar *cp = gawk_realloc(buffer, index_len);\n\n\t\t\tif (cp == NULL)\n\t\t\t\treturn awk_false;\n\n\t\t\tbuffer = cp;\n\t\t\tbuflen = index_len;\n\t\t}\n\n\t\tif (fread(buffer, 1, index_len, fp) != (ssize_t) index_len) {\n\t\t\treturn awk_false;\n\t\t}\n\t\tmake_const_string(buffer, index_len, & element->index);\n\t} else {\n\t\tmake_null_string(& element->index);\n\t}\n\n\tif (! read_value(fp, & element->value))\n\t\treturn awk_false;\n\n\treturn awk_true;\n}",
      "lines": 44,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "awk_bool_t"
      ]
    },
    "read_value": {
      "start_point": [
        440,
        0
      ],
      "end_point": [
        503,
        1
      ],
      "content": "static awk_bool_t\nread_value(FILE *fp, awk_value_t *value)\n{\n\tuint32_t code, len;\n\n\tif (fread(& code, 1, sizeof(code), fp) != sizeof(code))\n\t\treturn awk_false;\n\n\tcode = ntohl(code);\n\n\tif (code == 2) {\n\t\tawk_array_t array = create_array();\n\n\t\tif (! read_array(fp, array))\n\t\t\treturn awk_false;\n\n\t\t/* hook into value */\n\t\tvalue->val_type = AWK_ARRAY;\n\t\tvalue->array_cookie = array;\n\t} else if (code == 1) {\n\t\tdouble d;\n\n\t\tif (fread(& d, 1, sizeof(d), fp) != sizeof(d))\n\t\t\treturn awk_false;\n\n\t\t/* hook into value */\n\t\tvalue->val_type = AWK_NUMBER;\n\t\tvalue->num_value = d;\n\t} else {\n\t\tif (fread(& len, 1, sizeof(len), fp) != sizeof(len)) {\n\t\t\treturn awk_false;\n\t\t}\n\t\tlen = ntohl(len);\n\t\tswitch (code) {\n\t\tcase 0:\n\t\t\tvalue->val_type = AWK_STRING;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tvalue->val_type = AWK_REGEX;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tvalue->val_type = AWK_STRNUM;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tvalue->val_type = AWK_UNDEFINED;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* this cannot happen! */\n\t\t\twarning(ext_id, _(\"treating recovered value with unknown type code %d as a string\"), code);\n\t\t\tvalue->val_type = AWK_STRING;\n\t\t\tbreak;\n\t\t}\n\t\tvalue->str_value.len = len;\n\t\tvalue->str_value.str = gawk_malloc(len + 1);\n\n\t\tif (fread(value->str_value.str, 1, len, fp) != (ssize_t) len) {\n\t\t\tgawk_free(value->str_value.str);\n\t\t\treturn awk_false;\n\t\t}\n\t\tvalue->str_value.str[len] = '\\0';\n\t}\n\n\treturn awk_true;\n}",
      "lines": 64,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "awk_bool_t"
      ]
    }
  },
  "gawk/gawk-4.2.1/extension/rwarray0.c": {
    "do_writea": {
      "start_point": [
        96,
        0
      ],
      "end_point": [
        152,
        1
      ],
      "content": "static awk_value_t *\ndo_writea(int nargs, awk_value_t *result, struct awk_ext_func *unused)\n{\n\tawk_value_t filename, array;\n\tint fd = -1;\n\tuint32_t major = MAJOR;\n\tuint32_t minor = MINOR;\n\n\tassert(result != NULL);\n\tmake_number(0.0, result);\n\n\tif (nargs < 2)\n\t\tgoto out;\n\n\t/* directory is first arg, array to dump is second */\n\tif (! get_argument(0, AWK_STRING, & filename)) {\n\t\tfprintf(stderr, _(\"do_writea: argument 0 is not a string\\n\"));\n\t\terrno = EINVAL;\n\t\tgoto done1;\n\t}\n\n\tif (! get_argument(1, AWK_ARRAY, & array)) {\n\t\tfprintf(stderr, _(\"do_writea: argument 1 is not an array\\n\"));\n\t\terrno = EINVAL;\n\t\tgoto done1;\n\t}\n\n\t/* open the file, if error, set ERRNO and return */\n\tfd = creat(filename.str_value.str, 0600);\n\tif (fd < 0)\n\t\tgoto done1;\n\n\tif (write(fd, MAGIC, strlen(MAGIC)) != strlen(MAGIC))\n\t\tgoto done1;\n\n\tmajor = htonl(major);\n\tif (write(fd, & major, sizeof(major)) != sizeof(major))\n\t\tgoto done1;\n\n\tminor = htonl(minor);\n\tif (write(fd, & minor, sizeof(minor)) != sizeof(minor))\n\t\tgoto done1;\n\n\tif (write_array(fd, array.array_cookie)) {\n\t\tmake_number(1.0, result);\n\t\tgoto done0;\n\t}\n\ndone1:\n\tupdate_ERRNO_int(errno);\n\tunlink(filename.str_value.str);\n\ndone0:\n\tclose(fd);\nout:\n\treturn result;\n}",
      "lines": 57,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "awk_value_t",
        "*\ndo_writea(int nargs, awk_value_t *result, struct awk_ext_func *unused)",
        "*"
      ]
    },
    "write_array": {
      "start_point": [
        157,
        0
      ],
      "end_point": [
        184,
        1
      ],
      "content": "static awk_bool_t\nwrite_array(int fd, awk_array_t array)\n{\n\tuint32_t i;\n\tuint32_t count;\n\tawk_flat_array_t *flat_array;\n\n\tif (! flatten_array(array, & flat_array)) {\n\t\tfprintf(stderr, _(\"write_array: could not flatten array\\n\"));\n\t\treturn awk_false;\n\t}\n\n\tcount = htonl(flat_array->count);\n\tif (write(fd, & count, sizeof(count)) != sizeof(count))\n\t\treturn awk_false;\n\n\tfor (i = 0; i < flat_array->count; i++) {\n\t\tif (! write_elem(fd, & flat_array->elements[i]))\n\t\t\treturn awk_false;\n\t}\n\n\tif (! release_flattened_array(array, flat_array)) {\n\t\tfprintf(stderr, _(\"write_array: could not release flattened array\\n\"));\n\t\treturn awk_false;\n\t}\n\n\treturn awk_true;\n}",
      "lines": 28,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "awk_bool_t"
      ]
    },
    "write_elem": {
      "start_point": [
        188,
        0
      ],
      "end_point": [
        206,
        1
      ],
      "content": "static awk_bool_t\nwrite_elem(int fd, awk_element_t *element)\n{\n\tuint32_t indexval_len;\n\tssize_t write_count;\n\n\tindexval_len = htonl(element->index.str_value.len);\n\tif (write(fd, & indexval_len, sizeof(indexval_len)) != sizeof(indexval_len))\n\t\treturn awk_false;\n\n\tif (element->index.str_value.len > 0) {\n\t\twrite_count = write(fd, element->index.str_value.str,\n\t\t\t\telement->index.str_value.len);\n\t\tif (write_count != (ssize_t) element->index.str_value.len)\n\t\t\treturn awk_false;\n\t}\n\n\treturn write_value(fd, & element->value);\n}",
      "lines": 19,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "awk_bool_t"
      ]
    },
    "write_value": {
      "start_point": [
        210,
        0
      ],
      "end_point": [
        244,
        1
      ],
      "content": "static awk_bool_t\nwrite_value(int fd, awk_value_t *val)\n{\n\tuint32_t code, len;\n\n\tif (val->val_type == AWK_ARRAY) {\n\t\tcode = htonl(2);\n\t\tif (write(fd, & code, sizeof(code)) != sizeof(code))\n\t\t\treturn awk_false;\n\t\treturn write_array(fd, val->array_cookie);\n\t}\n\n\tif (val->val_type == AWK_NUMBER) {\n\t\tcode = htonl(1);\n\t\tif (write(fd, & code, sizeof(code)) != sizeof(code))\n\t\t\treturn awk_false;\n\n\t\tif (write(fd, & val->num_value, sizeof(val->num_value)) != sizeof(val->num_value))\n\t\t\treturn awk_false;\n\t} else {\n\t\tcode = 0;\n\t\tif (write(fd, & code, sizeof(code)) != sizeof(code))\n\t\t\treturn awk_false;\n\n\t\tlen = htonl(val->str_value.len);\n\t\tif (write(fd, & len, sizeof(len)) != sizeof(len))\n\t\t\treturn awk_false;\n\n\t\tif (write(fd, val->str_value.str, val->str_value.len)\n\t\t\t\t!= (ssize_t) val->str_value.len)\n\t\t\treturn awk_false;\n\t}\n\n\treturn awk_true;\n}",
      "lines": 35,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "awk_bool_t"
      ]
    },
    "do_reada": {
      "start_point": [
        248,
        0
      ],
      "end_point": [
        330,
        1
      ],
      "content": "static awk_value_t *\ndo_reada(int nargs, awk_value_t *result, struct awk_ext_func *unused)\n{\n\tawk_value_t filename, array;\n\tint fd = -1;\n\tuint32_t major;\n\tuint32_t minor;\n\tchar magic_buf[30];\n\n\tassert(result != NULL);\n\tmake_number(0.0, result);\n\n\tif (nargs < 2)\n\t\tgoto out;\n\n\t/* directory is first arg, array to read is second */\n\tif (! get_argument(0, AWK_STRING, & filename)) {\n\t\tfprintf(stderr, _(\"do_reada: argument 0 is not a string\\n\"));\n\t\terrno = EINVAL;\n\t\tgoto done1;\n\t}\n\n\tif (! get_argument(1, AWK_ARRAY, & array)) {\n\t\tfprintf(stderr, _(\"do_reada: argument 1 is not an array\\n\"));\n\t\terrno = EINVAL;\n\t\tgoto done1;\n\t}\n\n\tfd = open(filename.str_value.str, O_RDONLY);\n\tif (fd < 0)\n\t\tgoto done1;\n\n\tmemset(magic_buf, '\\0', sizeof(magic_buf));\n\tif (read(fd, magic_buf, strlen(MAGIC)) != strlen(MAGIC)) {\n\t\terrno = EBADF;\n\t\tgoto done1;\n\t}\n\n\tif (strcmp(magic_buf, MAGIC) != 0) {\n\t\terrno = EBADF;\n\t\tgoto done1;\n\t}\n\n\tif (read(fd, & major, sizeof(major)) != sizeof(major)) {\n\t\terrno = EBADF;\n\t\tgoto done1;\n\t}\n\tmajor = ntohl(major);\n\n\tif (major != MAJOR) {\n\t\terrno = EBADF;\n\t\tgoto done1;\n\t}\n\n\tif (read(fd, & minor, sizeof(minor)) != sizeof(minor)) {\n\t\t/* read() sets errno */\n\t\tgoto done1;\n\t}\n\n\tminor = ntohl(minor);\n\tif (minor != MINOR) {\n\t\terrno = EBADF;\n\t\tgoto done1;\n\t}\n\n\tif (! clear_array(array.array_cookie)) {\n\t\terrno = ENOMEM;\n\t\tfprintf(stderr, _(\"do_reada: clear_array failed\\n\"));\n\t\tgoto done1;\n\t}\n\n\tif (read_array(fd, array.array_cookie)) {\n\t\tmake_number(1.0, result);\n\t\tgoto done0;\n\t}\n\ndone1:\n\tupdate_ERRNO_int(errno);\ndone0:\n\tclose(fd);\nout:\n\treturn result;\n}",
      "lines": 83,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "awk_value_t",
        "*\ndo_reada(int nargs, awk_value_t *result, struct awk_ext_func *unused)",
        "*"
      ]
    },
    "read_array": {
      "start_point": [
        335,
        0
      ],
      "end_point": [
        362,
        1
      ],
      "content": "static awk_bool_t\nread_array(int fd, awk_array_t array)\n{\n\tuint32_t i;\n\tuint32_t count;\n\tawk_element_t new_elem;\n\n\tif (read(fd, & count, sizeof(count)) != sizeof(count)) {\n\t\treturn awk_false;\n\t}\n\tcount = ntohl(count);\n\n\tfor (i = 0; i < count; i++) {\n\t\tif (read_elem(fd, & new_elem)) {\n\t\t\t/* add to array */\n\t\t\tif (! set_array_element_by_elem(array, & new_elem)) {\n\t\t\t\tfprintf(stderr, _(\"read_array: set_array_element failed\\n\"));\n\t\t\t\treturn awk_false;\n\t\t\t}\n\t\t} else\n\t\t\tbreak;\n\t}\n\n\tif (i != count)\n\t\treturn awk_false;\n\n\treturn awk_true;\n}",
      "lines": 28,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "awk_bool_t"
      ]
    },
    "read_elem": {
      "start_point": [
        366,
        0
      ],
      "end_point": [
        409,
        1
      ],
      "content": "static awk_bool_t\nread_elem(int fd, awk_element_t *element)\n{\n\tuint32_t index_len;\n\tstatic char *buffer;\n\tstatic uint32_t buflen;\n\tssize_t ret;\n\n\tif ((ret = read(fd, & index_len, sizeof(index_len))) != sizeof(index_len)) {\n\t\treturn awk_false;\n\t}\n\tindex_len = ntohl(index_len);\n\n\tmemset(element, 0, sizeof(*element));\n\n\tif (index_len > 0) {\n\t\tif (buffer == NULL) {\n\t\t\t// allocate buffer\n\t\t\temalloc(buffer, char *, index_len, \"read_elem\");\n\t\t\tbuflen = index_len;\n\t\t} else if (buflen < index_len) {\n\t\t\t// reallocate buffer\n\t\t\tchar *cp = realloc(buffer, index_len);\n\n\t\t\tif (cp == NULL)\n\t\t\t\treturn awk_false;\n\n\t\t\tbuffer = cp;\n\t\t\tbuflen = index_len;\n\t\t}\n\n\t\tif (read(fd, buffer, index_len) != (ssize_t) index_len) {\n\t\t\treturn awk_false;\n\t\t}\n\t\tmake_const_string(buffer, index_len, & element->index);\n\t} else {\n\t\tmake_null_string(& element->index);\n\t}\n\n\tif (! read_value(fd, & element->value))\n\t\treturn awk_false;\n\n\treturn awk_true;\n}",
      "lines": 44,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "awk_bool_t"
      ]
    },
    "read_value": {
      "start_point": [
        413,
        0
      ],
      "end_point": [
        458,
        1
      ],
      "content": "static awk_bool_t\nread_value(int fd, awk_value_t *value)\n{\n\tuint32_t code, len;\n\n\tif (read(fd, & code, sizeof(code)) != sizeof(code))\n\t\treturn awk_false;\n\n\tcode = ntohl(code);\n\n\tif (code == 2) {\n\t\tawk_array_t array = create_array();\n\n\t\tif (read_array(fd, array) != 0)\n\t\t\treturn awk_false;\n\n\t\t/* hook into value */\n\t\tvalue->val_type = AWK_ARRAY;\n\t\tvalue->array_cookie = array;\n\t} else if (code == 1) {\n\t\tdouble d;\n\n\t\tif (read(fd, & d, sizeof(d)) != sizeof(d))\n\t\t\treturn awk_false;\n\n\t\t/* hook into value */\n\t\tvalue->val_type = AWK_NUMBER;\n\t\tvalue->num_value = d;\n\t} else {\n\t\tif (read(fd, & len, sizeof(len)) != sizeof(len)) {\n\t\t\treturn awk_false;\n\t\t}\n\t\tlen = ntohl(len);\n\t\tvalue->val_type = AWK_STRING;\n\t\tvalue->str_value.len = len;\n\t\tvalue->str_value.str = malloc(len + 1);\n\n\t\tif (read(fd, value->str_value.str, len) != (ssize_t) len) {\n\t\t\tfree(value->str_value.str);\n\t\t\treturn awk_false;\n\t\t}\n\t\tvalue->str_value.str[len] = '\\0';\n\t}\n\n\treturn awk_true;\n}",
      "lines": 46,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "awk_bool_t"
      ]
    }
  },
  "gawk/gawk-4.2.1/extension/stack.c": {
    "stack_empty": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        41,
        1
      ],
      "content": "int\nstack_empty()\n{\n\treturn index < 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    },
    "stack_top": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "void *\nstack_top()\n{\n\tif (stack_empty() || stack == NULL)\n\t\treturn NULL;\n\n\treturn stack[index];\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void",
        "*\nstack_top()",
        "*"
      ]
    },
    "stack_pop": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        63,
        1
      ],
      "content": "void *\nstack_pop()\n{\n\tif (stack_empty() || stack == NULL)\n\t\treturn NULL;\n\n\treturn stack[index--];\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void",
        "*\nstack_pop()",
        "*"
      ]
    },
    "stack_push": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "int stack_push(void *object)\n{\n\tvoid **new_stack;\n\tsize_t new_size = 2 * size;\n\n\tif (stack == NULL) {\n\t\tstack = (void **) malloc(INITIAL_STACK * sizeof(void *));\n\t\tif (stack == NULL)\n\t\t\treturn 0;\n\t\tsize = INITIAL_STACK;\n\t} else if (index + 1 >= size) {\n\t\tif (new_size < size)\n\t\t\treturn 0;\n\t\tnew_stack = realloc(stack, new_size * sizeof(void *));\n\t\tif (new_stack == NULL)\n\t\t\treturn 0;\n\t\tsize = new_size;\n\t\tstack = new_stack;\n\t}\n\n\tstack[++index] = object;\n\treturn 1;\n}",
      "lines": 23,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "gawk/gawk-4.2.1/extension/stack.h": {},
  "gawk/gawk-4.2.1/extension/testext.c": {
    "getuid": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "unsigned int\ngetuid (void)\n{\n  /* See pc/getid.c.  */\n  return 0;\n}",
      "lines": 6,
      "depth": 5,
      "decorators": [
        "unsigned int",
        "unsigned",
        "int"
      ]
    },
    "valrep2str": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        95,
        1
      ],
      "content": "static const char *\nvalrep2str(const awk_value_t *value)\n{\n\tstatic char buf[BUFSIZ];\n\tint size = BUFSIZ - 3;\n\n\tswitch (value->val_type) {\n\tcase AWK_UNDEFINED:\n\t\tstrcpy(buf, \"<undefined>\");\n\t\tbreak;\n\tcase AWK_ARRAY:\n\t\tstrcpy(buf, \"<array>\");\n\t\tbreak;\n\tcase AWK_SCALAR:\n\t\tstrcpy(buf, \"<scalar>\");\n\t\tbreak;\n\tcase AWK_VALUE_COOKIE:\n\t\tstrcpy(buf, \"<value-cookie>\");\n\t\tbreak;\n\tcase AWK_REGEX:\n\tcase AWK_STRNUM:\n\tcase AWK_STRING:\n\t\tif (value->str_value.len < size)\n\t\t\tsize = value->str_value.len;\n\t\tsprintf(buf, \"\\\"%.*s\\\"\",\n\t\t\t\tsize,\n\t\t\t\tvalue->str_value.str);\n\t\tbreak;\n\tcase AWK_NUMBER:\n\t\tsprintf(buf, \"%g\", value->num_value);\n\t\tbreak;\n\t}\n\treturn buf;\n}",
      "lines": 34,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nvalrep2str(const awk_value_t *value)",
        "*"
      ]
    },
    "dump_array_and_delete": {
      "start_point": [
        119,
        0
      ],
      "end_point": [
        196,
        1
      ],
      "content": "static awk_value_t *\ndump_array_and_delete(int nargs, awk_value_t *result, struct awk_ext_func *unused)\n{\n\tawk_value_t value, value2, value3;\n\tawk_flat_array_t *flat_array;\n\tsize_t count;\n\tchar *name;\n\tint i;\n\n\tassert(result != NULL);\n\tmake_number(0.0, result);\n\n\tif (nargs != 2) {\n\t\tprintf(\"dump_array_and_delete: nargs not right (%d should be 2)\\n\", nargs);\n\t\tgoto out;\n\t}\n\n\t/* get argument named array as flat array and print it */\n\tif (get_argument(0, AWK_STRING, & value)) {\n\t\tname = value.str_value.str;\n\t\tif (sym_lookup(name, AWK_ARRAY, & value2))\n\t\t\tprintf(\"dump_array_and_delete: sym_lookup of %s passed\\n\", name);\n\t\telse {\n\t\t\tprintf(\"dump_array_and_delete: sym_lookup of %s failed\\n\", name);\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tprintf(\"dump_array_and_delete: get_argument(0) failed\\n\");\n\t\tgoto out;\n\t}\n\n\tif (! get_element_count(value2.array_cookie, & count)) {\n\t\tprintf(\"dump_array_and_delete: get_element_count failed\\n\");\n\t\tgoto out;\n\t}\n\n\tprintf(\"dump_array_and_delete: incoming size is %lu\\n\", (unsigned long) count);\n\n\tif (! flatten_array(value2.array_cookie, & flat_array)) {\n\t\tprintf(\"dump_array_and_delete: could not flatten array\\n\");\n\t\tgoto out;\n\t}\n\n\tif (flat_array->count != count) {\n\t\tprintf(\"dump_array_and_delete: flat_array->count (%lu) != count (%lu)\\n\",\n\t\t\t\t(unsigned long) flat_array->count,\n\t\t\t\t(unsigned long) count);\n\t\tgoto out;\n\t}\n\n\tif (! get_argument(1, AWK_STRING, & value3)) {\n\t\tprintf(\"dump_array_and_delete: get_argument(1) failed\\n\");\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < flat_array->count; i++) {\n\t\tprintf(\"\\t%s[\\\"%.*s\\\"] = %s\\n\",\n\t\t\tname,\n\t\t\t(int) flat_array->elements[i].index.str_value.len,\n\t\t\tflat_array->elements[i].index.str_value.str,\n\t\t\tvalrep2str(& flat_array->elements[i].value));\n\n\t\tif (strcmp(value3.str_value.str, flat_array->elements[i].index.str_value.str) == 0) {\n\t\t\tflat_array->elements[i].flags |= AWK_ELEMENT_DELETE;\n\t\t\tprintf(\"dump_array_and_delete: marking element \\\"%s\\\" for deletion\\n\",\n\t\t\t\tflat_array->elements[i].index.str_value.str);\n\t\t}\n\t}\n\n\tif (! release_flattened_array(value2.array_cookie, flat_array)) {\n\t\tprintf(\"dump_array_and_delete: could not release flattened array\\n\");\n\t\tgoto out;\n\t}\n\n\tmake_number(1.0, result);\nout:\n\treturn result;\n}",
      "lines": 78,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "awk_value_t",
        "*\ndump_array_and_delete(int nargs, awk_value_t *result, struct awk_ext_func *unused)",
        "*"
      ]
    },
    "try_modify_environ": {
      "start_point": [
        213,
        0
      ],
      "end_point": [
        291,
        1
      ],
      "content": "static awk_value_t *\ntry_modify_environ(int nargs, awk_value_t *result, struct awk_ext_func *unused)\n{\n\tawk_value_t value, index, newvalue;\n\tawk_flat_array_t *flat_array;\n\tawk_array_t environ_array;\n\tsize_t count;\n\tint i;\n\n\tassert(result != NULL);\n\tmake_number(0.0, result);\n\n\tif (nargs != 0) {\n\t\tprintf(\"try_modify_environ: nargs not right (%d should be 0)\\n\", nargs);\n\t\tgoto out;\n\t}\n\n\t/* get ENVIRON array */\n\tif (sym_lookup(\"ENVIRON\", AWK_ARRAY, & value))\n\t\tprintf(\"try_modify_environ: sym_lookup of ENVIRON passed\\n\");\n\telse {\n\t\tprintf(\"try_modify_environ: sym_lookup of ENVIRON failed\\n\");\n\t\tgoto out;\n\t}\n\n\tenviron_array = value.array_cookie;\n\tif (! get_element_count(environ_array, & count)) {\n\t\tprintf(\"try_modify_environ: get_element_count failed\\n\");\n\t\tgoto out;\n\t}\n\n\t/* setting an array element should fail */\n\t(void) make_const_string(\"testext2\", 8, & index);\n\t(void) make_const_string(\"a value\", 7, & value);\n\tif (set_array_element(environ_array, & index, & newvalue)) {\n\t\tprintf(\"try_modify_environ: set_array_element of ENVIRON passed\\n\");\n\t} else {\n\t\tprintf(\"try_modify_environ: set_array_element of ENVIRON failed\\n\");\n\t\tgawk_free(index.str_value.str);\n\t\tgawk_free(value.str_value.str);\n\t}\n\n\tif (! flatten_array(environ_array, & flat_array)) {\n\t\tprintf(\"try_modify_environ: could not flatten array\\n\");\n\t\tgoto out;\n\t}\n\n\tif (flat_array->count != count) {\n\t\tprintf(\"try_modify_environ: flat_array->count (%lu) != count (%lu)\\n\",\n\t\t\t\t(unsigned long) flat_array->count,\n\t\t\t\t(unsigned long) count);\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < flat_array->count; i++) {\n\t\t/* don't print */\n\t/*\n\t\tprintf(\"\\t%s[\\\"%.*s\\\"] = %s\\n\",\n\t\t\tname,\n\t\t\t(int) flat_array->elements[i].index.str_value.len,\n\t\t\tflat_array->elements[i].index.str_value.str,\n\t\t\tvalrep2str(& flat_array->elements[i].value));\n\t*/\n\t\tif (strcmp(\"testext\", flat_array->elements[i].index.str_value.str) == 0) {\n\t\t\tflat_array->elements[i].flags |= AWK_ELEMENT_DELETE;\n\t\t\tprintf(\"try_modify_environ: marking element \\\"%s\\\" for deletion\\n\",\n\t\t\t\tflat_array->elements[i].index.str_value.str);\n\t\t}\n\t}\n\n\tif (! release_flattened_array(environ_array, flat_array)) {\n\t\tprintf(\"try_modify_environ: could not release flattened array\\n\");\n\t\tgoto out;\n\t}\n\n\tmake_number(1.0, result);\nout:\n\treturn result;\n}",
      "lines": 79,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "awk_value_t",
        "*\ntry_modify_environ(int nargs, awk_value_t *result, struct awk_ext_func *unused)",
        "*"
      ]
    },
    "var_test": {
      "start_point": [
        302,
        0
      ],
      "end_point": [
        359,
        1
      ],
      "content": "static awk_value_t *\nvar_test(int nargs, awk_value_t *result, struct awk_ext_func *unused)\n{\n\tawk_value_t value, value2;\n\tawk_value_t *valp;\n\n\tassert(result != NULL);\n\tmake_number(0.0, result);\n\n\tif (nargs != 1) {\n\t\tprintf(\"var_test: nargs not right (%d should be 1)\\n\", nargs);\n\t\tgoto out;\n\t}\n\n\t/* look up PROCINFO - should succeed fail */\n\tif (sym_lookup(\"PROCINFO\", AWK_ARRAY, & value))\n\t\tprintf(\"var_test: sym_lookup of PROCINFO passed - got a value!\\n\");\n\telse\n\t\tprintf(\"var_test: sym_lookup of PROCINFO failed - did not get a value\\n\");\n\n\t/* look up a reserved variable - should pass */\n\tif (sym_lookup(\"ARGC\", AWK_NUMBER, & value))\n\t\tprintf(\"var_test: sym_lookup of ARGC passed - got a value!\\n\");\n\telse\n\t\tprintf(\"var_test: sym_lookup of ARGC failed - did not get a value\\n\");\n\n\t/* now try to set it - should fail */\n\tvalue.num_value++;\n\tif (sym_update(\"ARGC\", & value))\n\t\tprintf(\"var_test: sym_update of ARGC passed and should not have!\\n\");\n\telse\n\t\tprintf(\"var_test: sym_update of ARGC failed - correctly\\n\");\n\n\t/* look up variable whose name is passed in, should pass */\n\tif (get_argument(0, AWK_STRING, & value)) {\n\t\tif (sym_lookup(value.str_value.str, AWK_STRING, & value2)) {\n\t\t\t/* change the value, should be reflected in awk script */\n\t\t\tvalp = make_number(42.0, & value2);\n\n\t\t\tif (sym_update(value.str_value.str, valp)) {\n\t\t\t\tprintf(\"var_test: sym_update(\\\"%s\\\") succeeded\\n\", value.str_value.str);\n\t\t\t} else {\n\t\t\t\tprintf(\"var_test: sym_update(\\\"%s\\\") failed\\n\", value.str_value.str);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\tprintf(\"var_test: sym_lookup(\\\"%s\\\") failed\\n\", value.str_value.str);\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tprintf(\"var_test: get_argument() failed\\n\");\n\t\tgoto out;\n\t}\n\n\tmake_number(1.0, result);\nout:\n\treturn result;\n}",
      "lines": 58,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "awk_value_t",
        "*\nvar_test(int nargs, awk_value_t *result, struct awk_ext_func *unused)",
        "*"
      ]
    },
    "test_errno": {
      "start_point": [
        369,
        0
      ],
      "end_point": [
        385,
        1
      ],
      "content": "static awk_value_t *\ntest_errno(int nargs, awk_value_t *result, struct awk_ext_func *unused)\n{\n\tassert(result != NULL);\n\tmake_number(0.0, result);\n\n\tif (nargs != 0) {\n\t\tprintf(\"test_errno: nargs not right (%d should be 0)\\n\", nargs);\n\t\tgoto out;\n\t}\n\n\tupdate_ERRNO_int(ECHILD);\n\n\tmake_number(1.0, result);\nout:\n\treturn result;\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "awk_value_t",
        "*\ntest_errno(int nargs, awk_value_t *result, struct awk_ext_func *unused)",
        "*"
      ]
    },
    "test_deferred": {
      "start_point": [
        398,
        0
      ],
      "end_point": [
        463,
        1
      ],
      "content": "static awk_value_t *\ntest_deferred(int nargs, awk_value_t *result, struct awk_ext_func *unused)\n{\n\tawk_value_t arr;\n\tawk_value_t index, value;\n\tconst struct nval {\n\t\tconst char *name;\n\t\tdouble val;\n\t} seed[] = {\n\t\t{ \"fubar\", 9.0, },\n\t\t{ \"rumpus\", -5.0, },\n\t};\n\tstruct nval sysval[] = {\n\t\t{ \"uid\", getuid(), },\n\t\t{ \"api_major\", GAWK_API_MAJOR_VERSION, },\n\t};\n\tsize_t i;\n\n\tassert(result != NULL);\n\tmake_number(0.0, result);\n\n\tif (nargs != 0) {\n\t\tprintf(\"test_deferred: nargs not right (%d should be 0)\\n\", nargs);\n\t\tgoto out;\n\t}\n\n\tif (! sym_lookup(\"PROCINFO\", AWK_ARRAY, & arr)) {\n\t\tprintf(\"test_deferred: %d: sym_lookup failed\\n\", __LINE__);\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < sizeof(seed)/sizeof(seed[0]); i++) {\n\t\tmake_const_string(seed[i].name, strlen(seed[i].name), & index);\n\t\tmake_number(seed[i].val, & value);\n\t\tif (! set_array_element(arr.array_cookie, & index, & value)) {\n\t\t\tprintf(\"test_deferred: %d: set_array_element(%s) failed\\n\", __LINE__, seed[i].name);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* test that it still contains the values we loaded */\n\tfor (i = 0; i < sizeof(seed)/sizeof(seed[0]); i++) {\n\t\tmake_const_string(seed[i].name, strlen(seed[i].name), & index);\n\t\tmake_null_string(& value);\n\t\tif (! get_array_element(arr.array_cookie, &index, AWK_NUMBER, & value)) {\n\t\t\tprintf(\"test_deferred: %d: get_array_element(%s) failed\\n\", __LINE__, seed[i].name);\n\t\t\tgoto out;\n\t\t}\n\t\tprintf(\"%s = %g\\n\", seed[i].name, value.num_value);\n\t}\n\n\t/* check a few automatically-supplied values */\n\tfor (i = 0; i < sizeof(sysval)/sizeof(sysval[0]); i++) {\n\t\tmake_const_string(sysval[i].name, strlen(sysval[i].name), & index);\n\t\tmake_null_string(& value);\n\t\tif (! get_array_element(arr.array_cookie, &index, AWK_NUMBER, & value)) {\n\t\t\tprintf(\"test_deferred: %d: get_array_element(%s) failed\\n\", __LINE__, sysval[i].name);\n\t\t\tgoto out;\n\t\t}\n\t\tprintf(\"%s matches %d\\n\", sysval[i].name, (value.num_value == sysval[i].val));\n\t}\n\n\tmake_number(1.0, result);\nout:\n\treturn result;\n}",
      "lines": 66,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "awk_value_t",
        "*\ntest_deferred(int nargs, awk_value_t *result, struct awk_ext_func *unused)",
        "*"
      ]
    },
    "test_array_size": {
      "start_point": [
        477,
        0
      ],
      "end_point": [
        514,
        1
      ],
      "content": "static awk_value_t *\ntest_array_size(int nargs, awk_value_t *result, struct awk_ext_func *unused)\n{\n\tawk_value_t value;\n\tsize_t count = 0;\n\n\tassert(result != NULL);\n\tmake_number(0.0, result);\n\n\tif (nargs != 1) {\n\t\tprintf(\"test_array_size: nargs not right (%d should be 1)\\n\", nargs);\n\t\tgoto out;\n\t}\n\n\t/* get element count and print it; should match length(array) from awk script */\n\tif (! get_argument(0, AWK_ARRAY, & value)) {\n\t\tprintf(\"test_array_size: get_argument failed\\n\");\n\t\tgoto out;\n\t}\n\n\tif (! get_element_count(value.array_cookie, & count)) {\n\t\tprintf(\"test_array_size: get_element_count failed\\n\");\n\t\tgoto out;\n\t}\n\n\tprintf(\"test_array_size: incoming size is %lu\\n\", (unsigned long) count);\n\n\t/* clear array - length(array) should then go to zero in script */\n\tif (! clear_array(value.array_cookie)) {\n\t\tprintf(\"test_array_size: clear_array failed\\n\");\n\t\tgoto out;\n\t}\n\n\tmake_number(1.0, result);\n\nout:\n\treturn result;\n}",
      "lines": 38,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "awk_value_t",
        "*\ntest_array_size(int nargs, awk_value_t *result, struct awk_ext_func *unused)",
        "*"
      ]
    },
    "test_array_elem": {
      "start_point": [
        541,
        0
      ],
      "end_point": [
        609,
        1
      ],
      "content": "static awk_value_t *\ntest_array_elem(int nargs, awk_value_t *result, struct awk_ext_func *unused)\n{\n\tawk_value_t array, index, index2, value;\n\n\tmake_number(0.0, result);\t/* default return until full success */\n\n\tassert(result != NULL);\n\n\tif (nargs != 2) {\n\t\tprintf(\"test_array_elem: nargs not right (%d should be 2)\\n\", nargs);\n\t\tgoto out;\n\t}\n\n\t/* look up an array element and print the value */\n\tif (! get_argument(0, AWK_ARRAY, & array)) {\n\t\tprintf(\"test_array_elem: get_argument 0 (array) failed\\n\");\n\t\tgoto out;\n\t}\n\tif (! get_argument(1, AWK_STRING, & index)) {\n\t\tprintf(\"test_array_elem: get_argument 1 (index) failed\\n\");\n\t\tgoto out;\n\t}\n\t(void) make_const_string(index.str_value.str, index.str_value.len, & index2);\n\tif (! get_array_element(array.array_cookie, & index2, AWK_UNDEFINED, & value)) {\n\t\tprintf(\"test_array_elem: get_array_element failed\\n\");\n\t\tgoto out;\n\t}\n\tprintf(\"test_array_elem: a[\\\"%.*s\\\"] = %s\\n\",\n\t\t\t(int) index.str_value.len,\n\t\t\tindex.str_value.str,\n\t\t\tvalrep2str(& value));\n\n\t/* change the element - \"3\" */\n\t(void) make_number(42.0, & value);\n\t(void) make_const_string(index.str_value.str, index.str_value.len, & index2);\n\tif (! set_array_element(array.array_cookie, & index2, & value)) {\n\t\tprintf(\"test_array_elem: set_array_element failed\\n\");\n\t\tgoto out;\n\t}\n\n\t/* delete another element - \"5\" */\n\t(void) make_const_string(\"5\", 1, & index);\n\tif (! del_array_element(array.array_cookie, & index)) {\n\t\tprintf(\"test_array_elem: del_array_element failed\\n\");\n\t\tgoto out;\n\t}\n\n\t/* add a new element - \"7\" */\n\t(void) make_const_string(\"7\", 1, & index);\n\t(void) make_const_string(\"seven\", 5, & value);\n\tif (! set_array_element(array.array_cookie, & index, & value)) {\n\t\tprintf(\"test_array_elem: set_array_element failed\\n\");\n\t\tgoto out;\n\t}\n\n\t/* add a subarray */\n\t(void) make_const_string(\"subarray\", 8, & index);\n\tfill_in_array(& value);\n\tif (! set_array_element(array.array_cookie, & index, & value)) {\n\t\tprintf(\"test_array_elem: set_array_element (subarray) failed\\n\");\n\t\tgoto out;\n\t}\n\n\t/* change and deletion should be reflected in awk script */\n\tmake_number(1.0, result);\nout:\n\treturn result;\n}",
      "lines": 69,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "awk_value_t",
        "*\ntest_array_elem(int nargs, awk_value_t *result, struct awk_ext_func *unused)",
        "*"
      ]
    },
    "test_array_param": {
      "start_point": [
        629,
        0
      ],
      "end_point": [
        658,
        1
      ],
      "content": "static awk_value_t *\ntest_array_param(int nargs, awk_value_t *result, struct awk_ext_func *unused)\n{\n\tawk_value_t new_array;\n\tawk_value_t arg0;\n\n\t(void) nargs;\t\t/* silence warnings */\n\tmake_number(0.0, result);\n\n\tif (! get_argument(0, AWK_UNDEFINED, & arg0)) {\n\t\tprintf(\"test_array_param: could not get argument\\n\");\n\t\tgoto out;\n\t}\n\n\tif (arg0.val_type != AWK_UNDEFINED) {\n\t\tprintf(\"test_array_param: argument is not undefined (%d)\\n\",\n\t\t\t\targ0.val_type);\n\t\tgoto out;\n\t}\n\n\tfill_in_array(& new_array);\n\tif (! set_argument(0, new_array.array_cookie)) {\n\t\tprintf(\"test_array_param: could not change type of argument\\n\");\n\t\tgoto out;\n\t}\n\n\tmake_number(1.0, result);\nout:\n\treturn result;\t/* for now */\n}",
      "lines": 30,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "awk_value_t",
        "*\ntest_array_param(int nargs, awk_value_t *result, struct awk_ext_func *unused)",
        "*"
      ]
    },
    "print_do_lint": {
      "start_point": [
        672,
        0
      ],
      "end_point": [
        689,
        1
      ],
      "content": "static awk_value_t *\nprint_do_lint(int nargs, awk_value_t *result, struct awk_ext_func *unused)\n{\n\tassert(result != NULL);\n\tmake_number(0.0, result);\n\n\tif (nargs != 0) {\n\t\tprintf(\"print_do_lint: nargs not right (%d should be 0)\\n\", nargs);\n\t\tgoto out;\n\t}\n\n\tprintf(\"print_do_lint: lint = %d\\n\", do_lint);\n\n\tmake_number(1.0, result);\n\nout:\n\treturn result;\n}",
      "lines": 18,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "awk_value_t",
        "*\nprint_do_lint(int nargs, awk_value_t *result, struct awk_ext_func *unused)",
        "*"
      ]
    },
    "test_scalar": {
      "start_point": [
        708,
        0
      ],
      "end_point": [
        745,
        1
      ],
      "content": "static awk_value_t *\ntest_scalar(int nargs, awk_value_t *result, struct awk_ext_func *unused)\n{\n\tawk_value_t new_value, new_value2;\n\tawk_value_t the_scalar;\n\n\t(void) nargs;\t\t/* silence warnings */\n\tmake_number(0.0, result);\n\n\tif (! sym_lookup(\"the_scalar\", AWK_SCALAR, & the_scalar)) {\n\t\tprintf(\"test_scalar: could not get scalar cookie\\n\");\n\t\tgoto out;\n\t}\n\n\tif (! get_argument(0, AWK_UNDEFINED, & new_value)) {\n\t\tprintf(\"test_scalar: could not get argument\\n\");\n\t\tgoto out;\n\t} else if (new_value.val_type != AWK_STRING && new_value.val_type != AWK_NUMBER) {\n\t\tprintf(\"test_scalar: argument is not a scalar\\n\");\n\t\tgoto out;\n\t}\n\n\tif (new_value.val_type == AWK_STRING) {\n\t\tmake_const_string(new_value.str_value.str, new_value.str_value.len, & new_value2);\n\t} else {\n\t\tnew_value2 = new_value;\n\t}\n\n\tif (! sym_update_scalar(the_scalar.scalar_cookie, & new_value2)) {\n\t\tprintf(\"test_scalar: could not update new_value2!\\n\");\n\t\tgoto out;\n\t}\n\n\tmake_number(1.0, result);\n\nout:\n\treturn result;\n}",
      "lines": 38,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "awk_value_t",
        "*\ntest_scalar(int nargs, awk_value_t *result, struct awk_ext_func *unused)",
        "*"
      ]
    },
    "test_scalar_reserved": {
      "start_point": [
        755,
        0
      ],
      "end_point": [
        785,
        1
      ],
      "content": "static awk_value_t *\ntest_scalar_reserved(int nargs, awk_value_t *result, struct awk_ext_func *unused)\n{\n\tawk_value_t new_value;\n\tawk_value_t the_scalar;\n\n\t(void) nargs;\t\t/* silence warnings */\n\tmake_number(0.0, result);\n\n\t/* look up a reserved variable - should pass */\n\tif (sym_lookup(\"ARGC\", AWK_SCALAR, & the_scalar)) {\n\t\tprintf(\"test_scalar_reserved: sym_lookup of ARGC passed - got a value!\\n\");\n\t} else {\n\t\tprintf(\"test_scalar_reserved: sym_lookup of ARGC failed - did not get a value\\n\");\n\t\tgoto out;\n\t}\n\n\t/* updating it should fail */\n\tmake_number(42.0, & new_value);\n\tif (! sym_update_scalar(the_scalar.scalar_cookie, & new_value)) {\n\t\tprintf(\"test_scalar_reserved: could not update new_value2 for ARGC - pass\\n\");\n\t} else {\n\t\tprintf(\"test_scalar_reserved: was able to update new_value2 for ARGC - fail\\n\");\n\t\tgoto out;\n\t}\n\n\tmake_number(1.0, result);\n\nout:\n\treturn result;\n}",
      "lines": 31,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "awk_value_t",
        "*\ntest_scalar_reserved(int nargs, awk_value_t *result, struct awk_ext_func *unused)",
        "*"
      ]
    },
    "test_indirect_vars": {
      "start_point": [
        808,
        0
      ],
      "end_point": [
        833,
        1
      ],
      "content": "static awk_value_t *\ntest_indirect_vars(int nargs, awk_value_t *result, struct awk_ext_func *unused)\n{\n\tawk_value_t value;\n\tchar *name = \"NR\";\n\n\t(void) nargs;\t\t/* silence warnings */\n\tassert(result != NULL);\n\tmake_number(0.0, result);\n\n\t/* system(\"rm testexttmp.txt\") */\n\t(void) unlink(\"testexttmp.txt\");\n\n\tif (sym_lookup(name, AWK_NUMBER, & value))\n\t\tprintf(\"test_indirect_var: sym_lookup of %s passed\\n\", name);\n\telse {\n\t\tprintf(\"test_indirect_var: sym_lookup of %s failed\\n\", name);\n\t\tgoto out;\n\t}\n\n\tprintf(\"test_indirect_var: value of NR is %g\\n\", value.num_value);\n\n\tmake_number(1.0, result);\nout:\n\treturn result;\n}",
      "lines": 26,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "awk_value_t",
        "*\ntest_indirect_vars(int nargs, awk_value_t *result, struct awk_ext_func *unused)",
        "*"
      ]
    },
    "test_get_file": {
      "start_point": [
        856,
        0
      ],
      "end_point": [
        890,
        1
      ],
      "content": "static awk_value_t *\ntest_get_file(int nargs, awk_value_t *result, struct awk_ext_func *unused)\n{\n\tawk_value_t filename, alias;\n\tint fd;\n\tconst awk_input_buf_t *ibuf;\n\tconst awk_output_buf_t *obuf;\n\n\tif (nargs != 2) {\n\t\tprintf(\"%s: nargs not right (%d should be 2)\\n\", \"test_get_file\", nargs);\n\t\treturn make_number(-1.0, result);\n\t}\n\n\tif (! get_argument(0, AWK_STRING, & filename)) {\n\t\tprintf(\"%s: cannot get first arg\\n\", \"test_get_file\");\n\t\treturn make_number(-1.0, result);\n\t}\n\tif (! get_argument(1, AWK_STRING, & alias)) {\n\t\tprintf(\"%s: cannot get second arg\\n\", \"test_get_file\");\n\t\treturn make_number(-1.0, result);\n\t}\n\tif ((fd = open(filename.str_value.str, O_RDONLY)) < 0) {\n\t\tprintf(\"%s: open(%s) failed\\n\", \"test_get_file\", filename.str_value.str);\n\t\treturn make_number(-1.0, result);\n\t}\n\tif (! get_file(alias.str_value.str, strlen(alias.str_value.str), \"<\", fd, &ibuf, &obuf)) {\n\t\tprintf(\"%s: get_file(%s) failed\\n\", \"test_get_file\", alias.str_value.str);\n\t\treturn make_number(-1.0, result);\n\t}\n\tif (! ibuf || ibuf->fd != fd) {\n\t\tprintf(\"%s: get_file(%s) returned fd %d instead of %d\\n\", \"test_get_file\", alias.str_value.str, ibuf ? ibuf->fd : -1, fd);\n\t\treturn make_number(-1.0, result);\n\t}\n\treturn make_number(0.0, result);\n}",
      "lines": 35,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "awk_value_t",
        "*\ntest_get_file(int nargs, awk_value_t *result, struct awk_ext_func *unused)",
        "*"
      ]
    },
    "do_get_file": {
      "start_point": [
        894,
        0
      ],
      "end_point": [
        951,
        1
      ],
      "content": "static awk_value_t *\ndo_get_file(int nargs, awk_value_t *result, struct awk_ext_func *unused)\n{\n\tawk_value_t filename, filetype, fd, res;\n\tconst awk_input_buf_t *ibuf;\n\tconst awk_output_buf_t *obuf;\n\n\tif (nargs != 4) {\n\t\tprintf(\"%s: nargs not right (%d should be 4)\\n\", \"get_file\", nargs);\n\t\treturn make_number(-1.0, result);\n\t}\n\n\tif (! get_argument(0, AWK_STRING, & filename)) {\n\t\tprintf(\"%s: cannot get first arg\\n\", \"get_file\");\n\t\treturn make_number(-1.0, result);\n\t}\n\tif (! get_argument(1, AWK_STRING, & filetype)) {\n\t\tprintf(\"%s: cannot get second arg\\n\", \"get_file\");\n\t\treturn make_number(-1.0, result);\n\t}\n\tif (! get_argument(2, AWK_NUMBER, & fd)) {\n\t\tprintf(\"%s: cannot get third arg\\n\", \"get_file\");\n\t\treturn make_number(-1.0, result);\n\t}\n\tif (! get_argument(3, AWK_ARRAY, & res)) {\n\t\tprintf(\"%s: cannot get fourth arg\\n\", \"get_file\");\n\t\treturn make_number(-1.0, result);\n\t}\n\tclear_array(res.array_cookie);\n\n\tif (! get_file(filename.str_value.str, strlen(filename.str_value.str), filetype.str_value.str, fd.num_value, &ibuf, &obuf)) {\n\t\tprintf(\"%s: get_file(%s, %s, %d) failed\\n\", \"get_file\", filename.str_value.str, filetype.str_value.str, (int)(fd.num_value));\n\t\treturn make_number(0.0, result);\n\t}\n\n\tif (ibuf) {\n\t\tawk_value_t idx, val;\n\t\tset_array_element(res.array_cookie,\n\t\t\t\t  make_const_string(\"input\", 5, & idx),\n\t\t\t\t  make_number(ibuf->fd, & val));\n\t\tif (ibuf->name)\n\t\t\tset_array_element(res.array_cookie,\n\t\t\t\t\t  make_const_string(\"input_name\", 10, & idx),\n\t\t\t\t\t  make_const_string(ibuf->name, strlen(ibuf->name), & val));\n\t}\n\tif (obuf) {\n\t\tawk_value_t idx, val;\n\t\tset_array_element(res.array_cookie,\n\t\t\t\t  make_const_string(\"output\", 6, & idx),\n\t\t\t\t  make_number(obuf->fp ? fileno(obuf->fp) : -1,\n\t\t\t\t  \t      & val));\n\t\tif (obuf->name)\n\t\t\tset_array_element(res.array_cookie,\n\t\t\t\t\t  make_const_string(\"output_name\", 11, & idx),\n\t\t\t\t\t  make_const_string(obuf->name, strlen(obuf->name), & val));\n\t}\n\treturn make_number(1.0, result);\n}",
      "lines": 58,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "awk_value_t",
        "*\ndo_get_file(int nargs, awk_value_t *result, struct awk_ext_func *unused)",
        "*"
      ]
    },
    "fill_in_array": {
      "start_point": [
        955,
        0
      ],
      "end_point": [
        979,
        1
      ],
      "content": "static void\nfill_in_array(awk_value_t *new_array)\n{\n\tawk_array_t a_cookie;\n\tawk_value_t index, value;\n\n\ta_cookie = create_array();\n\n\t(void) make_const_string(\"hello\", 5, & index);\n\t(void) make_const_string(\"world\", 5, & value);\n\tif (! set_array_element(a_cookie, & index, & value)) {\n\t\tprintf(\"fill_in_array:%d: set_array_element failed\\n\", __LINE__);\n\t\treturn;\n\t}\n\n\t(void) make_const_string(\"answer\", 6, & index);\n\t(void) make_number(42.0, & value);\n\tif (! set_array_element(a_cookie, & index, & value)) {\n\t\tprintf(\"fill_in_array:%d: set_array_element failed\\n\", __LINE__);\n\t\treturn;\n\t}\n\n\tnew_array->val_type = AWK_ARRAY;\n\tnew_array->array_cookie = a_cookie;\n}",
      "lines": 25,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "create_new_array": {
      "start_point": [
        983,
        0
      ],
      "end_point": [
        991,
        1
      ],
      "content": "static void\ncreate_new_array()\n{\n\tawk_value_t value;\n\n\tfill_in_array(& value);\n\tif (! sym_update(\"new_array\", & value))\n\t\tprintf(\"create_new_array: sym_update(\\\"new_array\\\") failed!\\n\");\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "at_exit0": {
      "start_point": [
        995,
        0
      ],
      "end_point": [
        1003,
        1
      ],
      "content": "static void at_exit0(void *data, int exit_status)\n{\n\tprintf(\"at_exit0 called (should be third):\");\n\tif (data)\n\t\tprintf(\" data = %p,\", data);\n\telse\n\t\tprintf(\" data = NULL,\");\n\tprintf(\" exit_status = %d\\n\", exit_status);\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "at_exit1": {
      "start_point": [
        1008,
        0
      ],
      "end_point": [
        1022,
        1
      ],
      "content": "static void at_exit1(void *data, int exit_status)\n{\n\tint *data_p = (int *) data;\n\n\tprintf(\"at_exit1 called (should be second):\");\n\tif (data) {\n\t\tif (data == & data_for_1)\n\t\t\tprintf(\" (data is & data_for_1),\");\n\t\telse\n\t\t\tprintf(\" (data is NOT & data_for_1),\");\n\t\tprintf(\" data value = %#x,\", *data_p);\n\t} else\n\t\tprintf(\" data = NULL,\");\n\tprintf(\" exit_status = %d\\n\", exit_status);\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "at_exit2": {
      "start_point": [
        1026,
        0
      ],
      "end_point": [
        1034,
        1
      ],
      "content": "static void at_exit2(void *data, int exit_status)\n{\n\tprintf(\"at_exit2 called (should be first):\");\n\tif (data)\n\t\tprintf(\" data = %p,\", data);\n\telse\n\t\tprintf(\" data = NULL,\");\n\tprintf(\" exit_status = %d\\n\", exit_status);\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "init_testext": {
      "start_point": [
        1055,
        0
      ],
      "end_point": [
        1095,
        1
      ],
      "content": "static awk_bool_t init_testext(void)\n{\n\tawk_value_t value;\n\tstatic const char message[] = \"hello, world\";\t/* of course */\n\tstatic const char message2[] = \"i am a scalar\";\n\n\t/* This is used by the getfile test */\n\tif (sym_lookup(\"TESTEXT_QUIET\", AWK_NUMBER, & value))\n\t\treturn awk_true;\n\n\t/* add at_exit functions */\n\tawk_atexit(at_exit0, NULL);\n\tawk_atexit(at_exit1, & data_for_1);\n\tawk_atexit(at_exit2, NULL);\n\n/*\nBEGIN {\n\tprintf(\"answer_num = %g\\n\", answer_num);\n\tprintf(\"message_string = %s\\n\", message_string);\n\tfor (i in new_array)\n\t\tprintf(\"new_array[\\\"%s\\\"] = \\\"%s\\\"\\n\", i, new_array[i])\n\tprint \"\"\n}\n*/\n\n\t/* install some variables */\n\tif (! sym_update(\"answer_num\", make_number(42, & value)))\n\t\tprintf(\"testext: sym_update(\\\"answer_num\\\") failed!\\n\");\n\n\tif (! sym_update(\"message_string\",\n\t\t\tmake_const_string(message, strlen(message), & value)))\n\t\tprintf(\"testext: sym_update(\\\"answer_num\\\") failed!\\n\");\n\n\tif (! sym_update(\"the_scalar\",\n\t\t\tmake_const_string(message2, strlen(message2), & value)))\n\t\tprintf(\"testext: sym_update(\\\"the_scalar\\\") failed!\\n\");\n\n\tcreate_new_array();\n\n\treturn awk_true;\n}",
      "lines": 41,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "awk_bool_t"
      ]
    }
  },
  "gawk/gawk-4.2.1/extension/time.c": {
    "vms_fake_nanosleep": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        69,
        1
      ],
      "content": "static int\nvms_fake_nanosleep(struct timespec *rqdly, struct timespec *rmdly)\n{\n\tint result;\n\tstruct timespec mtime1, mtime2;\n\n\tresult = nanosleep(rqdly, &mtime1);\n\tif (result == 0)\n\t\treturn 0;\n\n\t/* On IA64 it returns 100 nanoseconds early with an error */\n\tif ((mtime1.tv_sec == 0) && (mtime1.tv_nsec <= 100)) {\n\t\tmtime1.tv_nsec += 100;\n\t\tresult = nanosleep(&mtime1, &mtime2);\n\t\tif (result == 0)\n\t\t\treturn 0;\n\t\tif ((mtime2.tv_sec == 0) && (mtime2.tv_nsec <= 100)) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn result;\n}",
      "lines": 22,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "do_gettimeofday": {
      "start_point": [
        104,
        0
      ],
      "end_point": [
        144,
        1
      ],
      "content": "static awk_value_t *\ndo_gettimeofday(int nargs, awk_value_t *result, struct awk_ext_func *unused)\n{\n\tdouble curtime;\n\n\tassert(result != NULL);\n\n#if defined(HAVE_GETTIMEOFDAY)\n\t{\n\t\tstruct timeval tv;\n\t\tgettimeofday(&tv,NULL);\n\t\tcurtime = tv.tv_sec+(tv.tv_usec/1000000.0);\n\t}\n#elif defined(HAVE_GETSYSTEMTIMEASFILETIME)\n\t/* based on perl win32/win32.c:win32_gettimeofday() implementation */\n\t{\n\t\tunion {\n\t\t\tunsigned __int64 ft_i64;\n\t\t\tFILETIME ft_val;\n\t\t} ft;\n\n\t\t/* # of 100-nanosecond intervals since January 1, 1601 (UTC) */\n\t\tGetSystemTimeAsFileTime(&ft.ft_val);\n#ifdef __GNUC__\n#define Const64(x) x##LL\n#else\n#define Const64(x) x##i64\n#endif\n/* Number of 100 nanosecond units from 1/1/1601 to 1/1/1970 */\n#define EPOCH_BIAS  Const64(116444736000000000)\n\t\tcurtime = (ft.ft_i64 - EPOCH_BIAS)/10000000.0;\n#undef Const64\n\t}\n#else\n\t/* no way to retrieve system time on this platform */\n\tcurtime = -1;\n\tupdate_ERRNO_string(_(\"gettimeofday: not supported on this platform\"));\n#endif\n\n\treturn make_number(curtime, result);\n}",
      "lines": 41,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "awk_value_t",
        "*\ndo_gettimeofday(int nargs, awk_value_t *result, struct awk_ext_func *unused)",
        "*"
      ]
    },
    "do_sleep": {
      "start_point": [
        151,
        0
      ],
      "end_point": [
        205,
        1
      ],
      "content": "static awk_value_t *\ndo_sleep(int nargs, awk_value_t *result, struct awk_ext_func *unused)\n{\n\tawk_value_t num;\n\tdouble secs;\n\tint rc;\n\n\tassert(result != NULL);\n\n\tif (! get_argument(0, AWK_NUMBER, &num)) {\n\t\tupdate_ERRNO_string(_(\"sleep: missing required numeric argument\"));\n\t\treturn make_number(-1, result);\n\t}\n\tsecs = num.num_value;\n\n\tif (secs < 0) {\n\t\tupdate_ERRNO_string(_(\"sleep: argument is negative\"));\n\t\treturn make_number(-1, result);\n\t}\n\n#if defined(HAVE_NANOSLEEP)\n\t{\n\t\tstruct timespec req;\n\n\t\treq.tv_sec = secs;\n\t\treq.tv_nsec = (secs-(double)req.tv_sec)*1000000000.0;\n\t\tif ((rc = nanosleep(&req,NULL)) < 0)\n\t\t\t/* probably interrupted */\n\t\t\tupdate_ERRNO_int(errno);\n\t}\n#elif defined(HAVE_SELECT)\n\t{\n\t\tstruct timeval timeout;\n\n\t\ttimeout.tv_sec = secs;\n\t\ttimeout.tv_usec = (secs-(double)timeout.tv_sec)*1000000.0;\n\t\tif ((rc = select(0,NULL,NULL,NULL,&timeout)) < 0)\n\t\t\t/* probably interrupted */\n\t\t\tupdate_ERRNO_int(errno);\n\t}\n#elif defined(HAVE_GETSYSTEMTIMEASFILETIME)\n\t{\n\t\tDWORD milliseconds = secs * 1000;\n\n\t\tSleep (milliseconds);\n\t\trc = 0;\n\t}\n#else\n\t/* no way to sleep on this platform */\n\trc = -1;\n\tupdate_ERRNO_string(_(\"sleep: not supported on this platform\"));\n#endif\n\n\treturn make_number(rc, result);\n}",
      "lines": 55,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "awk_value_t",
        "*\ndo_sleep(int nargs, awk_value_t *result, struct awk_ext_func *unused)",
        "*"
      ]
    }
  },
  "gawk/gawk-4.2.1/missing_d/fnmatch.c": {},
  "gawk/gawk-4.2.1/missing_d/fnmatch.h": {},
  "gawk/gawk-4.2.1/missing_d/gawkbool.h": {},
  "gawk/gawk-4.2.1/missing_d/getaddrinfo.c": {
    "freeaddrinfo": {
      "start_point": [
        19,
        0
      ],
      "end_point": [
        25,
        1
      ],
      "content": "void\nfreeaddrinfo(struct addrinfo *res)\n{\n\tif (res->ai_addr != NULL)\n\t\tfree(res->ai_addr);\n\tfree(res);\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "getaddrinfo": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        111,
        1
      ],
      "content": "int\ngetaddrinfo(const char *hostname, const char *portname,\n\tstruct addrinfo *hints, struct addrinfo **res)\n{\n\tstruct addrinfo *out;\n\tif (res == NULL)\n\t\treturn EINVAL;\n\n\tout = (struct addrinfo *) calloc(1, sizeof(*out));\n\tif (out == NULL) {\n\t\t*res = NULL;\n\t\treturn ENOMEM;\n\t}\n\n\tout->ai_addr = (struct sockaddr *) malloc(sizeof(struct sockaddr_in));\n\tif (out->ai_addr == NULL) {\n\t\tfree(out);\n\t\t*res = NULL;\n\t\treturn ENOMEM;\n\t}\n\n\tout->ai_socktype = SOCK_STREAM;\n\tif (hints != NULL) {\n\t\tif (hints->ai_socktype)\n\t\t\tout->ai_socktype = hints->ai_socktype;\n\t\tif (hints->ai_protocol)\n\t\t\tout->ai_protocol = hints->ai_protocol;\n\t}\n\n\tif (out->ai_protocol == 0) {\n\t\tswitch (out->ai_socktype) {\n\t\tcase SOCK_STREAM:\n\t\t\tout->ai_protocol = IPPROTO_TCP;\n\t\t\tbreak;\n\t\tcase SOCK_DGRAM:\n\t\t\tout->ai_protocol = IPPROTO_UDP;\n\t\t\tbreak;\n\t\tcase SOCK_RAW:\n\t\t\tout->ai_protocol = IPPROTO_RAW;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tout->ai_addrlen = sizeof(struct sockaddr_in);\n\tmemset(out->ai_addr, '\\0', sizeof(struct sockaddr_in));\n\n\tif (hostname != NULL) {\n\t\tstruct hostent *he;\n\t\the = gethostbyname(hostname);\n\t\tif (he != NULL && he->h_addr_list != NULL) {\n\t\t\t((struct sockaddr_in *)out->ai_addr)->sin_addr.s_addr\n\t\t\t\t= ((struct in_addr *)he->h_addr_list[0])->s_addr;\n\t\t} else {\n\t\t\tfreeaddrinfo(out);\n\t\t\treturn EADDRNOTAVAIL;\n\t\t}\n\t} else {\n\t\tif (!(out->ai_flags & AI_PASSIVE))\n\t\t\t((struct sockaddr_in *)out->ai_addr)->sin_addr.s_addr\n\t\t\t\t\t\t\t= htonl(INADDR_ANY);\n\t}\n\t((struct sockaddr_in *)out->ai_addr)->sin_family = AF_INET;\n\tout->ai_family = AF_INET;\n\n\tif (portname != NULL && *portname) {\n\t\tlong portnum;\n\t\tchar *end;\n\t\tportnum = strtol(portname, &end, 10);\n\t\tif (*end == '\\0' && portnum > 0 && portnum < 65536) {\n\t\t\t((struct sockaddr_in *)out->ai_addr)->sin_port\n\t\t\t\t\t\t\t= htons(portnum);\n\t\t} else {\n\t\t\tstruct servent *se;\n\t\t\tse = getservbyname(portname, NULL);\n\t\t\tif (se != NULL) {\n\t\t\t\t((struct sockaddr_in *)out->ai_addr)->sin_port\n\t\t\t\t\t\t\t= se->s_port;\n\t\t\t}\n\t\t}\n\t}\n\n\t*res = out;\n\n\treturn 0;\n}",
      "lines": 85,
      "depth": 16,
      "decorators": [
        "int"
      ]
    },
    "gai_strerror": {
      "start_point": [
        113,
        0
      ],
      "end_point": [
        117,
        1
      ],
      "content": "const char *\ngai_strerror(int errcode)\n{\n\treturn strerror(errcode);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "const",
        "const",
        "char",
        "*\ngai_strerror(int errcode)",
        "*"
      ]
    }
  },
  "gawk/gawk-4.2.1/missing_d/getaddrinfo.h": {},
  "gawk/gawk-4.2.1/missing_d/memcmp.c": {},
  "gawk/gawk-4.2.1/missing_d/memcpy.c": {},
  "gawk/gawk-4.2.1/missing_d/memmove.c": {},
  "gawk/gawk-4.2.1/missing_d/memset.c": {},
  "gawk/gawk-4.2.1/missing_d/mktime.c": {},
  "gawk/gawk-4.2.1/missing_d/setenv.c": {
    "setenv": {
      "start_point": [
        87,
        0
      ],
      "end_point": [
        134,
        1
      ],
      "content": "int\nsetenv(const char *name, const char *value, int rewrite)\n{\n\textern char **environ;\n\tstatic int alloced;\t\t\t/*%< if allocated space before */\n\tchar *c;\n\tint l_value, offset;\n\n\tif (*value == '=')\t\t\t/*%< no `=' in value */\n\t\t++value;\n\tl_value = strlen(value);\n\tif ((c = findenv(name, &offset))) {\t/*%< find if already exists */\n\t\tif (!rewrite)\n\t\t\treturn (0);\n\t\tif (strlen(c) >= l_value) {\t/*%< old larger; copy over */\n\t\t\twhile (*c++ = *value++);\n\t\t\treturn (0);\n\t\t}\n\t} else {\t\t\t\t\t/*%< create new slot */\n\t\tint cnt;\n\t\tchar **p;\n\n\t\tfor (p = environ, cnt = 0; *p; ++p, ++cnt);\n\t\tif (alloced) {\t\t\t/*%< just increase size */\n\t\t\tenviron = (char **)realloc((char *)environ,\n\t\t\t    (size_t)(sizeof(char *) * (cnt + 2)));\n\t\t\tif (!environ)\n\t\t\t\treturn (-1);\n\t\t}\n\t\telse {\t\t\t\t/*%< get new space */\n\t\t\talloced = 1;\t\t/*%< copy old entries into it */\n\t\t\tp = malloc((size_t)(sizeof(char *) * (cnt + 2)));\n\t\t\tif (!p)\n\t\t\t\treturn (-1);\n\t\t\tmemcpy(p, environ, cnt * sizeof(char *));\n\t\t\tenviron = p;\n\t\t}\n\t\tenviron[cnt + 1] = NULL;\n\t\toffset = cnt;\n\t}\n\tfor (c = (char *)name; *c && *c != '='; ++c);\t/*%< no `=' in name */\n\tif (!(environ[offset] =\t\t\t/*%< name + `=' + value */\n\t    malloc((size_t)((int)(c - name) + l_value + 2))))\n\t\treturn (-1);\n\tfor (c = environ[offset]; (*c = *name++) && *c != '='; ++c);\n\tfor (*c++ = '='; *c++ = *value++;);\n\treturn (0);\n}",
      "lines": 48,
      "depth": 19,
      "decorators": [
        "int"
      ]
    },
    "unsetenv": {
      "start_point": [
        140,
        0
      ],
      "end_point": [
        157,
        1
      ],
      "content": "int\nunsetenv(const char *name)\n{\n\tchar **p;\n\tint offset;\n\n\tif (strchr(name, '=') != NULL) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\twhile (findenv(name, &offset))\t/*%< if set multiple times */\n\t\tfor (p = &environ[offset];; ++p)\n\t\t\tif (!(*p = *(p + 1)))\n\t\t\t\tbreak;\n\n\treturn 0;\n}",
      "lines": 18,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "findenv": {
      "start_point": [
        168,
        0
      ],
      "end_point": [
        186,
        1
      ],
      "content": "static char *\nfindenv(const char *name, int *offset)\n{\n\tconst char *np;\n\tchar **p, *c;\n\tint len;\n\n\tif (name == NULL || environ == NULL)\n\t\treturn (NULL);\n\tfor (np = name; *np && *np != '='; ++np)\n\t\tcontinue;\n\tlen = np - name;\n\tfor (p = environ; (c = *p) != NULL; ++p)\n\t\tif (strncmp(c, name, len) == 0 && c[len] == '=') {\n\t\t\t*offset = p - environ;\n\t\t\treturn (c + len + 1);\n\t\t}\n\treturn (NULL);\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nfindenv(const char *name, int *offset)",
        "*"
      ]
    }
  },
  "gawk/gawk-4.2.1/missing_d/snprintf.c": {
    "close_safe_f": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "static void close_safe_f()\n{\n\tif (safe_f != NULL) {\n\t\tfclose(safe_f);\n\t\tsafe_f = NULL;\n\t}\n\tif (tmpfilename != NULL) {\n\t\tunlink(tmpfilename);\n\t\tfree(tmpfilename);\n\t\ttmpfilename = NULL;\n\t}\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "safe_tmpfile": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "static FILE *\nsafe_tmpfile (void)\n{\n\tstatic bool first = true;\n\tstatic const char template[] = \"snprintfXXXXXX\";\n\tint fd;\n\tstatic char *tmpdir = NULL;\n\tstatic int len = 0;\n\n\tif (first) {\n\t\tfirst = false;\n\t\t/*\n\t\t * First try Unix stanadard env var, then Windows var,\n\t\t * then fall back to /tmp.\n\t\t */\n\t\tif ((tmpdir = getenv(\"TMPDIR\")) != NULL && *tmpdir != '\\0')\n\t\t\t;\t/* got it */\n\t\telse if ((tmpdir = getenv(\"TEMP\")) != NULL && *tmpdir != '\\0')\n\t\t\t;\t/* got it */\n\t\telse\n\t\t\ttmpdir = \"/tmp\";\n\n\t\tlen = strlen(tmpdir) + 1 + strlen(template) + 1;\n#ifdef HAVE_ATEXIT\n\t\tatexit(close_safe_f);\n#endif /* HAVE_ATEXIT */\n\t}\n\n\tif ((tmpfilename = (char *) malloc(len)) == NULL)\n\t\treturn NULL;\n\telse\n\t\tsprintf(tmpfilename, \"%s/%s\", tmpdir, template);\n\n\tif ((fd = mkstemp (tmpfilename)) < 0)\n\t\treturn NULL;\n\n#if ! defined(__DJGPP__) && ! defined(MSDOS) && ! defined(_MSC_VER) \\\n\t&& ! defined(_WIN32) && ! defined(__CRTRSXNT__) && ! defined(__EMX__) \\\n\t&& ! defined(__MINGW32__) && ! defined(__WIN32__)\n\t/* If not MS or OS/2, unlink after opening. */\n\tunlink (tmpfilename);\n\tfree(tmpfilename);\n\ttmpfilename = NULL;\n#endif\n\n\tif ((safe_f = fdopen (fd, \"w+b\")) == NULL) {\n\t\tclose (fd);\n\t\treturn NULL;\n\t}\n\t/* setvbuf(f,NULL,_IOFBF,4*BUFSIZ); */\n\treturn safe_f;\n}",
      "lines": 52,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "FILE",
        "*\nsafe_tmpfile (void)",
        "*"
      ]
    },
    "vsnprintf": {
      "start_point": [
        116,
        0
      ],
      "end_point": [
        173,
        1
      ],
      "content": "int\nvsnprintf (char *restrict buf, size_t len,\n\t\tconst char *restrict fmt, va_list args)\n{\n\tint actual;\n\tint nread;\n\tsize_t cnt = 0;\n#ifndef SNPRINTF_REENTRANT\n\tstatic\n#endif\n\tFILE *fp;\n\n\tif ((buf == NULL) || (len < 1))\n\t\treturn -1;\n\n\tbuf[0] = '\\0';\t/* in case the caller does not check the return code! */\n\n#ifdef SNPRINTF_REENTRANT\n\tif ((fp = safe_tmpfile ()) == NULL)\n\t\treturn -1;\n#else\n\tif ((fp == NULL) && ((fp = safe_tmpfile ()) == NULL))\n\t\treturn -1;\n\trewind (fp);\n#endif\n\tactual = vfprintf (fp, fmt, args);\n\trewind (fp);\n\tif (actual < 0) {\n#ifdef SNPRINTF_REENTRANT\n\t\tfclose (fp);\n\t\tif (tmpfilename != NULL) {\n\t\t\tunlink(tmpfilename);\n\t\t\tfree(tmpfilename);\n\t\t\ttmpfilename = NULL;\n\t\t}\n#endif\n\t\treturn -1;\n\t}\n\telse if ((size_t) actual < len)\n\t\tlen = actual;\n\telse\n\t\t--len;\n\twhile (cnt < len && (nread = fread (buf + cnt, 1, len - cnt, fp)) > 0)\n\t\tcnt += nread;\n\tbuf[cnt] = '\\0';\n#ifdef SNPRINTF_REENTRANT\n\tfclose (fp);\n\tif (tmpfilename != NULL) {\n\t\tunlink(tmpfilename);\n\t\tfree(tmpfilename);\n\t\ttmpfilename = NULL;\n\t}\n#endif\n\tif (cnt < len)\n\t\treturn -1;\n\n\treturn actual;\n}",
      "lines": 58,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "snprintf": {
      "start_point": [
        175,
        0
      ],
      "end_point": [
        185,
        1
      ],
      "content": "int\nsnprintf (char *restrict buf, size_t len, const char *restrict fmt, ...)\n{\n\tint rv;\n\tva_list args;\n\n\tva_start (args, fmt);\n\trv = vsnprintf (buf, len, fmt, args);\n\tva_end (args);\n\treturn rv;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "gawk/gawk-4.2.1/missing_d/strchr.c": {},
  "gawk/gawk-4.2.1/missing_d/strcoll.c": {
    "strcoll": {
      "start_point": [
        2,
        0
      ],
      "end_point": [
        6,
        1
      ],
      "content": "int\nstrcoll(const char *s1, const char *s2)\n{\n\treturn strcmp(s1, s2);\t/* nyah, nyah, so there */\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "gawk/gawk-4.2.1/missing_d/strerror.c": {},
  "gawk/gawk-4.2.1/missing_d/strftime.c": {
    "strftime": {
      "start_point": [
        534,
        6
      ],
      "end_point": [
        1455,
        1
      ],
      "content": "ut_argument_spec\n      LOCALE_PARAM_DECL\n{\n#if defined _LIBC && defined USE_IN_EXTENDED_LOCALE_MODEL\n  struct locale_data *const current = loc->__locales[LC_TIME];\n#endif\n\n  int hour12 = tp->tm_hour;\n#ifdef _NL_CURRENT\n  /* We cannot make the following values variables since we must delay\n     the evaluation of these values until really needed since some\n     expressions might not be valid in every situation.  The `struct tm'\n     might be generated by a strptime() call that initialized\n     only a few elements.  Dereference the pointers only if the format\n     requires this.  Then it is ok to fail if the pointers are invalid.  */\n# define a_wkday \\\n  ((const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(ABDAY_1) + tp->tm_wday))\n# define f_wkday \\\n  ((const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(DAY_1) + tp->tm_wday))\n# define a_month \\\n  ((const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(ABMON_1) + tp->tm_mon))\n# define f_month \\\n  ((const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(MON_1) + tp->tm_mon))\n# define ampm \\\n  ((const CHAR_T *) _NL_CURRENT (LC_TIME, tp->tm_hour > 11\t\t      \\\n\t\t\t\t ? NLW(PM_STR) : NLW(AM_STR)))\n\n# define aw_len STRLEN (a_wkday)\n# define am_len STRLEN (a_month)\n# define ap_len STRLEN (ampm)\n#else\n# if !HAVE_STRFTIME\n#  define f_wkday (weekday_name[tp->tm_wday])\n#  define f_month (month_name[tp->tm_mon])\n#  define a_wkday f_wkday\n#  define a_month f_month\n#  define ampm (L_(\"AMPM\") + 2 * (tp->tm_hour > 11))\n\n  size_t aw_len = 3;\n  size_t am_len = 3;\n  size_t ap_len = 2;\n# endif\n#endif\n  const char *zone;\n  size_t i = 0;\n  CHAR_T *p = s;\n  const CHAR_T *f;\n#if DO_MULTIBYTE && !defined COMPILE_WIDE\n  const char *format_end = NULL;\n#endif\n\n  zone = NULL;\n#if HAVE_TM_ZONE\n  /* The POSIX test suite assumes that setting\n     the environment variable TZ to a new value before calling strftime()\n     will influence the result (the %Z format) even if the information in\n     TP is computed with a totally different time zone.\n     This is bogus: though POSIX allows bad behavior like this,\n     POSIX does not require it.  Do the right thing instead.  */\n  zone = (const char *) tp->tm_zone;\n#endif\n#if HAVE_TZNAME\n  if (ut)\n    {\n      if (! (zone && *zone))\n\tzone = \"GMT\";\n    }\n  else\n    {\n      /* POSIX.1 requires that local time zone information is used as\n\t though strftime called tzset.  */\n# if HAVE_TZSET\n      tzset ();\n# endif\n    }\n#endif\n\n  if (hour12 > 12)\n    hour12 -= 12;\n  else\n    if (hour12 == 0)\n      hour12 = 12;\n\n  for (f = format; *f != '\\0'; ++f)\n    {\n      int pad = 0;\t\t/* Padding for number ('-', '_', or 0).  */\n      int modifier;\t\t/* Field modifier ('E', 'O', or 0).  */\n      int digits;\t\t/* Max digits for numeric format.  */\n      int number_value; \t/* Numeric value to be printed.  */\n      int negative_number;\t/* 1 if the number is negative.  */\n      const CHAR_T *subfmt;\n      CHAR_T *bufp;\n      CHAR_T buf[1 + (sizeof (int) < sizeof (time_t)\n\t\t      ? INT_STRLEN_BOUND (time_t)\n\t\t      : INT_STRLEN_BOUND (int))];\n      int width = -1;\n      int to_lowcase = 0;\n      int to_uppcase = 0;\n      int change_case = 0;\n      int format_char;\n\n#if DO_MULTIBYTE && !defined COMPILE_WIDE\n      switch (*f)\n\t{\n\tcase L_('%'):\n\t  break;\n\n\tcase L_('\\b'): case L_('\\t'): case L_('\\n'):\n\tcase L_('\\v'): case L_('\\f'): case L_('\\r'):\n\tcase L_(' '): case L_('!'): case L_('\"'): case L_('#'): case L_('&'):\n\tcase L_('\\''): case L_('('): case L_(')'): case L_('*'): case L_('+'):\n\tcase L_(','): case L_('-'): case L_('.'): case L_('/'): case L_('0'):\n\tcase L_('1'): case L_('2'): case L_('3'): case L_('4'): case L_('5'):\n\tcase L_('6'): case L_('7'): case L_('8'): case L_('9'): case L_(':'):\n\tcase L_(';'): case L_('<'): case L_('='): case L_('>'): case L_('?'):\n\tcase L_('A'): case L_('B'): case L_('C'): case L_('D'): case L_('E'):\n\tcase L_('F'): case L_('G'): case L_('H'): case L_('I'): case L_('J'):\n\tcase L_('K'): case L_('L'): case L_('M'): case L_('N'): case L_('O'):\n\tcase L_('P'): case L_('Q'): case L_('R'): case L_('S'): case L_('T'):\n\tcase L_('U'): case L_('V'): case L_('W'): case L_('X'): case L_('Y'):\n\tcase L_('Z'): case L_('['): case L_('\\\\'): case L_(']'): case L_('^'):\n\tcase L_('_'): case L_('a'): case L_('b'): case L_('c'): case L_('d'):\n\tcase L_('e'): case L_('f'): case L_('g'): case L_('h'): case L_('i'):\n\tcase L_('j'): case L_('k'): case L_('l'): case L_('m'): case L_('n'):\n\tcase L_('o'): case L_('p'): case L_('q'): case L_('r'): case L_('s'):\n\tcase L_('t'): case L_('u'): case L_('v'): case L_('w'): case L_('x'):\n\tcase L_('y'): case L_('z'): case L_('{'): case L_('|'): case L_('}'):\n\tcase L_('~'):\n\t  /* The C Standard requires these 98 characters (plus '%') to\n\t     be in the basic execution character set.  None of these\n\t     characters can start a multibyte sequence, so they need\n\t     not be analyzed further.  */\n\t  add (1, *p = *f);\n\t  continue;\n\n\tdefault:\n\t  /* Copy this multibyte sequence until we reach its end, find\n\t     an error, or come back to the initial shift state.  */\n\t  {\n\t    mbstate_t mbstate = mbstate_zero;\n\t    size_t len = 0;\n\t    size_t fsize;\n\n\t    if (! format_end)\n\t      format_end = f + strlen (f) + 1;\n\t    fsize = format_end - f;\n\n\t    do\n\t      {\n\t\tsize_t bytes = mbrlen (f + len, fsize - len, &mbstate);\n\n\t\tif (bytes == 0)\n\t\t  break;\n\n\t\tif (bytes == (size_t) -2)\n\t\t  {\n\t\t    len += strlen (f + len);\n\t\t    break;\n\t\t  }\n\n\t\tif (bytes == (size_t) -1)\n\t\t  {\n\t\t    len++;\n\t\t    break;\n\t\t  }\n\n\t\tlen += bytes;\n\t      }\n\t    while (! mbsinit (&mbstate));\n\n\t    cpy (len, f);\n\t    f += len - 1;\n\t    continue;\n\t  }\n\t}\n\n#else /* ! DO_MULTIBYTE */\n\n      /* Either multibyte encodings are not supported, they are\n\t safe for formats, so any non-'%' byte can be copied through,\n\t or this is the wide character version.  */\n      if (*f != L_('%'))\n\t{\n\t  add (1, *p = *f);\n\t  continue;\n\t}\n\n#endif /* ! DO_MULTIBYTE */\n\n      /* Check for flags that can modify a format.  */\n      while (1)\n\t{\n\t  switch (*++f)\n\t    {\n\t      /* This influences the number formats.  */\n\t    case L_('_'):\n\t    case L_('-'):\n\t    case L_('0'):\n\t      pad = *f;\n\t      continue;\n\n\t      /* This changes textual output.  */\n\t    case L_('^'):\n\t      to_uppcase = 1;\n\t      continue;\n\t    case L_('#'):\n\t      change_case = 1;\n\t      continue;\n\n\t    default:\n\t      break;\n\t    }\n\t  break;\n\t}\n\n      /* As a GNU extension we allow to specify the field width.  */\n      if (ISDIGIT (*f))\n\t{\n\t  width = 0;\n\t  do\n\t    {\n\t      if (width > INT_MAX / 10\n\t\t  || (width == INT_MAX / 10 && *f - L_('0') > INT_MAX % 10))\n\t\t/* Avoid overflow.  */\n\t\twidth = INT_MAX;\n\t      else\n\t\t{\n\t\t  width *= 10;\n\t\t  width += *f - L_('0');\n\t\t}\n\t      ++f;\n\t    }\n\t  while (ISDIGIT (*f));\n\t}\n\n      /* Check for modifiers.  */\n      switch (*f)\n\t{\n\tcase L_('E'):\n\tcase L_('O'):\n\t  modifier = *f++;\n\t  break;\n\n\tdefault:\n\t  modifier = 0;\n\t  break;\n\t}\n\n      /* Now do the specified format.  */\n      format_char = *f;\n      switch (format_char)\n\t{\n#define DO_NUMBER(d, v) \\\n\t  digits = d > width ? d : width;\t\t\t\t      \\\n\t  number_value = v; goto do_number\n#define DO_NUMBER_SPACEPAD(d, v) \\\n\t  digits = d > width ? d : width;\t\t\t\t      \\\n\t  number_value = v; goto do_number_spacepad\n\n\tcase L_('%'):\n\t  if (modifier != 0)\n\t    goto bad_format;\n\t  add (1, *p = *f);\n\t  break;\n\n\tcase L_('a'):\n\t  if (modifier != 0)\n\t    goto bad_format;\n\t  if (change_case)\n\t    {\n\t      to_uppcase = 1;\n\t      to_lowcase = 0;\n\t    }\n#if defined _NL_CURRENT || !HAVE_STRFTIME\n\t  cpy (aw_len, a_wkday);\n\t  break;\n#else\n\t  goto underlying_strftime;\n#endif\n\n\tcase 'A':\n\t  if (modifier != 0)\n\t    goto bad_format;\n\t  if (change_case)\n\t    {\n\t      to_uppcase = 1;\n\t      to_lowcase = 0;\n\t    }\n#if defined _NL_CURRENT || !HAVE_STRFTIME\n\t  cpy (STRLEN (f_wkday), f_wkday);\n\t  break;\n#else\n\t  goto underlying_strftime;\n#endif\n\n\tcase L_('b'):\n\tcase L_('h'):\n\t  if (change_case)\n\t    {\n\t      to_uppcase = 1;\n\t      to_lowcase = 0;\n\t    }\n\t  if (modifier != 0)\n\t    goto bad_format;\n#if defined _NL_CURRENT || !HAVE_STRFTIME\n\t  cpy (am_len, a_month);\n\t  break;\n#else\n\t  goto underlying_strftime;\n#endif\n\n\tcase L_('B'):\n\t  if (modifier != 0)\n\t    goto bad_format;\n\t  if (change_case)\n\t    {\n\t      to_uppcase = 1;\n\t      to_lowcase = 0;\n\t    }\n#if defined _NL_CURRENT || !HAVE_STRFTIME\n\t  cpy (STRLEN (f_month), f_month);\n\t  break;\n#else\n\t  goto underlying_strftime;\n#endif\n\n\tcase L_('c'):\n\t  if (modifier == L_('O'))\n\t    goto bad_format;\n#ifdef _NL_CURRENT\n\t  if (! (modifier == 'E'\n\t\t && (*(subfmt =\n\t\t       (const CHAR_T *) _NL_CURRENT (LC_TIME,\n\t\t\t\t\t\t     NLW(ERA_D_T_FMT)))\n\t\t     != '\\0')))\n\t    subfmt = (const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(D_T_FMT));\n#else\n# if HAVE_STRFTIME\n\t  goto underlying_strftime;\n# else\n\t  subfmt = L_(\"%a %b %e %H:%M:%S %Y\");\n# endif\n#endif\n\n\tsubformat:\n\t  {\n\t    CHAR_T *old_start = p;\n\t    size_t len = my_strftime (NULL, (size_t) -1, subfmt,\n\t\t\t\t      tp ut_argument LOCALE_ARG);\n\t    add (len, my_strftime (p, maxsize - i, subfmt,\n\t\t\t\t   tp ut_argument LOCALE_ARG));\n\n\t    if (to_uppcase)\n\t      while (old_start < p)\n\t\t{\n\t\t  *old_start = TOUPPER ((UCHAR_T) *old_start, loc);\n\t\t  ++old_start;\n\t\t}\n\t  }\n\t  break;\n\n#if HAVE_STRFTIME && ! (defined _NL_CURRENT && HAVE_STRUCT_ERA_ENTRY)\n\tunderlying_strftime:\n\t  {\n\t    /* The relevant information is available only via the\n\t       underlying strftime implementation, so use that.  */\n\t    char ufmt[4];\n\t    char *u = ufmt;\n\t    char ubuf[1024]; /* enough for any single format in practice */\n\t    size_t len;\n\t    /* Make sure we're calling the actual underlying strftime.\n\t       In some cases, config.h contains something like\n\t       \"#define strftime rpl_strftime\".  */\n# ifdef strftime\n#  undef strftime\n\t    size_t strftime ();\n# endif\n\n\t    *u++ = '%';\n\t    if (modifier != 0)\n\t      *u++ = modifier;\n\t    *u++ = format_char;\n\t    *u = '\\0';\n\t    len = strftime (ubuf, sizeof ubuf, ufmt, tp);\n\t    if (len == 0 && ubuf[0] != '\\0')\n\t      return 0;\n\t    cpy (len, ubuf);\n\t  }\n\t  break;\n#endif\n\n\tcase L_('C'):\n\t  if (modifier == L_('O'))\n\t    goto bad_format;\n\t  if (modifier == L_('E'))\n\t    {\n#if HAVE_STRUCT_ERA_ENTRY\n\t      struct era_entry *era = _nl_get_era_entry (tp HELPER_LOCALE_ARG);\n\t      if (era)\n\t\t{\n# ifdef COMPILE_WIDE\n\t\t  size_t len = __wcslen (era->era_wname);\n\t\t  cpy (len, era->era_wname);\n# else\n\t\t  size_t len = strlen (era->era_name);\n\t\t  cpy (len, era->era_name);\n# endif\n\t\t  break;\n\t\t}\n#else\n# if HAVE_STRFTIME\n\t      goto underlying_strftime;\n# endif\n#endif\n\t    }\n\n\t  {\n\t    int year = tp->tm_year + TM_YEAR_BASE;\n\t    DO_NUMBER (1, year / 100 - (year % 100 < 0));\n\t  }\n\n\tcase L_('x'):\n\t  if (modifier == L_('O'))\n\t    goto bad_format;\n#ifdef _NL_CURRENT\n\t  if (! (modifier == L_('E')\n\t\t && (*(subfmt =\n\t\t       (const CHAR_T *)_NL_CURRENT (LC_TIME, NLW(ERA_D_FMT)))\n\t\t     != L_('\\0'))))\n\t    subfmt = (const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(D_FMT));\n\t  goto subformat;\n#else\n# if HAVE_STRFTIME\n\t  goto underlying_strftime;\n# else\n\t  /* Fall through.  */\n# endif\n#endif\n\tcase L_('D'):\n\t  if (modifier != 0)\n\t    goto bad_format;\n\t  subfmt = L_(\"%m/%d/%y\");\n\t  goto subformat;\n\n\tcase L_('d'):\n\t  if (modifier == L_('E'))\n\t    goto bad_format;\n\n\t  DO_NUMBER (2, tp->tm_mday);\n\n\tcase L_('e'):\n\t  if (modifier == L_('E'))\n\t    goto bad_format;\n\n\t  DO_NUMBER_SPACEPAD (2, tp->tm_mday);\n\n\t  /* All numeric formats set DIGITS and NUMBER_VALUE and then\n\t     jump to one of these two labels.  */\n\n\tdo_number_spacepad:\n\t  /* Force `_' flag unless overwritten by `0' flag.  */\n\t  if (pad != L_('0'))\n\t    pad = L_('_');\n\n\tdo_number:\n\t  /* Format the number according to the MODIFIER flag.  */\n\n\t  if (modifier == L_('O') && 0 <= number_value)\n\t    {\n#ifdef _NL_CURRENT\n\t      /* Get the locale specific alternate representation of\n\t\t the number NUMBER_VALUE.  If none exist NULL is returned.  */\n\t      const CHAR_T *cp = nl_get_alt_digit (number_value\n\t\t\t\t\t\t   HELPER_LOCALE_ARG);\n\n\t      if (cp != NULL)\n\t\t{\n\t\t  size_t digitlen = STRLEN (cp);\n\t\t  if (digitlen != 0)\n\t\t    {\n\t\t      cpy (digitlen, cp);\n\t\t      break;\n\t\t    }\n\t\t}\n#else\n# if HAVE_STRFTIME\n\t      goto underlying_strftime;\n# endif\n#endif\n\t    }\n\t  {\n\t    unsigned int u = number_value;\n\n\t    bufp = buf + sizeof (buf) / sizeof (buf[0]);\n\t    negative_number = number_value < 0;\n\n\t    if (negative_number)\n\t      u = -u;\n\n\t    do\n\t      *--bufp = u % 10 + L_('0');\n\t    while ((u /= 10) != 0);\n  \t  }\n\n\tdo_number_sign_and_padding:\n\t  if (negative_number)\n\t    *--bufp = L_('-');\n\n\t  if (pad != L_('-'))\n\t    {\n\t      int padding = digits - (buf + (sizeof (buf) / sizeof (buf[0]))\n\t\t\t\t      - bufp);\n\n\t      if (padding > 0)\n\t\t{\n\t\t  if (pad == L_('_'))\n\t\t    {\n\t\t      if ((size_t) padding >= maxsize - i)\n\t\t\treturn 0;\n\n\t\t      if (p)\n\t\t\tmemset_space (p, padding);\n\t\t      i += padding;\n\t\t      width = width > padding ? width - padding : 0;\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      if ((size_t) digits >= maxsize - i)\n\t\t\treturn 0;\n\n\t\t      if (negative_number)\n\t\t\t{\n\t\t\t  ++bufp;\n\n\t\t\t  if (p)\n\t\t\t    *p++ = L_('-');\n\t\t\t  ++i;\n\t\t\t}\n\n\t\t      if (p)\n\t\t\tmemset_zero (p, padding);\n\t\t      i += padding;\n\t\t      width = 0;\n\t\t    }\n\t\t}\n\t    }\n\n\t  cpy (buf + sizeof (buf) / sizeof (buf[0]) - bufp, bufp);\n\t  break;\n\n\tcase L_('F'):\n\t  if (modifier != 0)\n\t    goto bad_format;\n\t  subfmt = L_(\"%Y-%m-%d\");\n\t  goto subformat;\n\n\tcase L_('H'):\n\t  if (modifier == L_('E'))\n\t    goto bad_format;\n\n\t  DO_NUMBER (2, tp->tm_hour);\n\n\tcase L_('I'):\n\t  if (modifier == L_('E'))\n\t    goto bad_format;\n\n\t  DO_NUMBER (2, hour12);\n\n\tcase L_('k'):\t\t/* GNU extension.  */\n\t  if (modifier == L_('E'))\n\t    goto bad_format;\n\n\t  DO_NUMBER_SPACEPAD (2, tp->tm_hour);\n\n\tcase L_('l'):\t\t/* GNU extension.  */\n\t  if (modifier == L_('E'))\n\t    goto bad_format;\n\n\t  DO_NUMBER_SPACEPAD (2, hour12);\n\n\tcase L_('j'):\n\t  if (modifier == L_('E'))\n\t    goto bad_format;\n\n\t  DO_NUMBER (3, 1 + tp->tm_yday);\n\n\tcase L_('M'):\n\t  if (modifier == L_('E'))\n\t    goto bad_format;\n\n\t  DO_NUMBER (2, tp->tm_min);\n\n\tcase L_('m'):\n\t  if (modifier == L_('E'))\n\t    goto bad_format;\n\n\t  DO_NUMBER (2, tp->tm_mon + 1);\n\n\tcase L_('n'):\n\t  add (1, *p = L_('\\n'));\n\t  break;\n\n\tcase L_('P'):\n\t  to_lowcase = 1;\n#if !defined _NL_CURRENT && HAVE_STRFTIME\n\t  format_char = L_('p');\n#endif\n\t  /* FALLTHROUGH */\n\n\tcase L_('p'):\n\t  if (change_case)\n\t    {\n\t      to_uppcase = 0;\n\t      to_lowcase = 1;\n\t    }\n#if defined _NL_CURRENT || !HAVE_STRFTIME\n\t  cpy (ap_len, ampm);\n\t  break;\n#else\n\t  goto underlying_strftime;\n#endif\n\n\tcase L_('R'):\n\t  subfmt = L_(\"%H:%M\");\n\t  goto subformat;\n\n\tcase L_('r'):\n#ifdef _NL_CURRENT\n\t  if (*(subfmt = (const CHAR_T *) _NL_CURRENT (LC_TIME,\n\t\t\t\t\t\t       NLW(T_FMT_AMPM)))\n\t      == L_('\\0'))\n#endif\n\t    subfmt = L_(\"%I:%M:%S %p\");\n\t  goto subformat;\n\n\tcase L_('S'):\n\t  if (modifier == L_('E'))\n\t    goto bad_format;\n\n\t  DO_NUMBER (2, tp->tm_sec);\n\n\tcase L_('s'):\t\t/* GNU extension.  */\n  \t  {\n\t    struct tm ltm;\n\t    time_t t;\n\n\t    ltm = *tp;\n\t    t = mktime (&ltm);\n\n\t    /* Generate string value for T using time_t arithmetic;\n\t       this works even if sizeof (long) < sizeof (time_t).  */\n\n\t    bufp = buf + sizeof (buf) / sizeof (buf[0]);\n#ifndef TIME_T_UNSIGNED\n\t    negative_number = t < 0;\n#endif\n\n\t    do\n\t      {\n\t\tint d = t % 10;\n\t\tt /= 10;\n\n#ifndef TIME_T_UNSIGNED\n\t\tif (negative_number)\n\t\t  {\n\t\t    d = -d;\n\n\t\t    /* Adjust if division truncates to minus infinity.  */\n\t\t    if (0 < -1 % 10 && d < 0)\n\t\t      {\n\t\t\tt++;\n\t\t\td += 10;\n\t\t      }\n\t\t  }\n#endif\n\n\t\t*--bufp = d + L_('0');\n\t      }\n\t    while (t != 0);\n\n\t    digits = 1;\n\t    goto do_number_sign_and_padding;\n\t  }\n\n\tcase L_('X'):\n\t  if (modifier == L_('O'))\n\t    goto bad_format;\n#ifdef _NL_CURRENT\n\t  if (! (modifier == L_('E')\n\t\t && (*(subfmt =\n\t\t       (const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(ERA_T_FMT)))\n\t\t     != L_('\\0'))))\n\t    subfmt = (const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(T_FMT));\n\t  goto subformat;\n#else\n# if HAVE_STRFTIME\n\t  goto underlying_strftime;\n# else\n\t  /* Fall through.  */\n# endif\n#endif\n\tcase L_('T'):\n\t  subfmt = L_(\"%H:%M:%S\");\n\t  goto subformat;\n\n\tcase L_('t'):\n\t  add (1, *p = L_('\\t'));\n\t  break;\n\n\tcase L_('u'):\n\t  DO_NUMBER (1, (tp->tm_wday - 1 + 7) % 7 + 1);\n\n\tcase L_('U'):\n\t  if (modifier == L_('E'))\n\t    goto bad_format;\n\n\t  DO_NUMBER (2, (tp->tm_yday - tp->tm_wday + 7) / 7);\n\n\tcase L_('V'):\n\tcase L_('g'):\n\tcase L_('G'):\n\t  if (modifier == L_('E'))\n\t    goto bad_format;\n\t  {\n\t    int year = tp->tm_year + TM_YEAR_BASE;\n\t    int days = iso_week_days (tp->tm_yday, tp->tm_wday);\n\n\t    if (days < 0)\n\t      {\n\t\t/* This ISO week belongs to the previous year.  */\n\t\tyear--;\n\t\tdays = iso_week_days (tp->tm_yday + (365 + __isleap (year)),\n\t\t\t\t      tp->tm_wday);\n\t      }\n\t    else\n\t      {\n\t\tint d = iso_week_days (tp->tm_yday - (365 + __isleap (year)),\n\t\t\t\t       tp->tm_wday);\n\t\tif (0 <= d)\n\t\t  {\n\t\t    /* This ISO week belongs to the next year.  */\n\t\t    year++;\n\t\t    days = d;\n\t\t  }\n\t      }\n\n\t    switch (*f)\n\t      {\n\t      case L_('g'):\n\t\tDO_NUMBER (2, (year % 100 + 100) % 100);\n\n\t      case L_('G'):\n\t\tDO_NUMBER (1, year);\n\n\t      default:\n\t\tDO_NUMBER (2, days / 7 + 1);\n\t      }\n\t  }\n\n\tcase L_('W'):\n\t  if (modifier == L_('E'))\n\t    goto bad_format;\n\n\t  DO_NUMBER (2, (tp->tm_yday - (tp->tm_wday - 1 + 7) % 7 + 7) / 7);\n\n\tcase L_('w'):\n\t  if (modifier == L_('E'))\n\t    goto bad_format;\n\n\t  DO_NUMBER (1, tp->tm_wday);\n\n\tcase L_('Y'):\n\t  if (modifier == 'E')\n\t    {\n#if HAVE_STRUCT_ERA_ENTRY\n\t      struct era_entry *era = _nl_get_era_entry (tp HELPER_LOCALE_ARG);\n\t      if (era)\n\t\t{\n# ifdef COMPILE_WIDE\n\t\t  subfmt = era->era_wformat;\n# else\n\t\t  subfmt = era->era_format;\n# endif\n\t\t  goto subformat;\n\t\t}\n#else\n# if HAVE_STRFTIME\n\t      goto underlying_strftime;\n# endif\n#endif\n\t    }\n\t  if (modifier == L_('O'))\n\t    goto bad_format;\n\t  else\n\t    DO_NUMBER (1, tp->tm_year + TM_YEAR_BASE);\n\n\tcase L_('y'):\n\t  if (modifier == L_('E'))\n\t    {\n#if HAVE_STRUCT_ERA_ENTRY\n\t      struct era_entry *era = _nl_get_era_entry (tp HELPER_LOCALE_ARG);\n\t      if (era)\n\t\t{\n\t\t  int delta = tp->tm_year - era->start_date[0];\n\t\t  DO_NUMBER (1, (era->offset\n\t\t\t\t + delta * era->absolute_direction));\n\t\t}\n#else\n# if HAVE_STRFTIME\n\t      goto underlying_strftime;\n# endif\n#endif\n\t    }\n\t  DO_NUMBER (2, (tp->tm_year % 100 + 100) % 100);\n\n\tcase L_('Z'):\n\t  if (change_case)\n\t    {\n\t      to_uppcase = 0;\n\t      to_lowcase = 1;\n\t    }\n\n#if HAVE_TZNAME\n\t  /* The tzset() call might have changed the value.  */\n\t  if (!(zone && *zone) && tp->tm_isdst >= 0)\n\t    zone = tzname[tp->tm_isdst];\n#endif\n\t  if (! zone)\n\t    zone = \"\";\n\n#ifdef COMPILE_WIDE\n\t  {\n\t    /* The zone string is always given in multibyte form.  We have\n\t       to transform it first.  */\n\t    wchar_t *wczone;\n\t    size_t len;\n\t    widen (zone, wczone, len);\n\t    cpy (len, wczone);\n\t  }\n#else\n\t  cpy (strlen (zone), zone);\n#endif\n\t  break;\n\n\tcase L_('z'):\n\t  if (tp->tm_isdst < 0)\n\t    break;\n\n\t  {\n\t    int diff;\n#if HAVE_TM_GMTOFF\n\t    diff = tp->tm_gmtoff;\n#else\n\t    if (ut)\n\t      diff = 0;\n\t    else\n\t      {\n\t\tstruct tm gtm;\n\t\tstruct tm ltm;\n\t\ttime_t lt;\n\n\t\tltm = *tp;\n\t\tlt = mktime (&ltm);\n\n\t\tif (lt == (time_t) -1)\n\t\t  {\n\t\t    /* mktime returns -1 for errors, but -1 is also a\n\t\t       valid time_t value.  Check whether an error really\n\t\t       occurred.  */\n\t\t    struct tm tm;\n\n\t\t    if (! my_strftime_localtime_r (&lt, &tm)\n\t\t\t|| ((ltm.tm_sec ^ tm.tm_sec)\n\t\t\t    | (ltm.tm_min ^ tm.tm_min)\n\t\t\t    | (ltm.tm_hour ^ tm.tm_hour)\n\t\t\t    | (ltm.tm_mday ^ tm.tm_mday)\n\t\t\t    | (ltm.tm_mon ^ tm.tm_mon)\n\t\t\t    | (ltm.tm_year ^ tm.tm_year)))\n\t\t      break;\n\t\t  }\n\n\t\tif (! my_strftime_gmtime_r (&lt, &gtm))\n\t\t  break;\n\n\t\tdiff = tm_diff (&ltm, &gtm);\n\t      }\n#endif\n\n\t    if (diff < 0)\n\t      {\n\t\tadd (1, *p = L_('-'));\n\t\tdiff = -diff;\n\t      }\n\t    else\n\t      add (1, *p = L_('+'));\n\n\t    diff /= 60;\n\t    DO_NUMBER (4, (diff / 60) * 100 + diff % 60);\n\t  }\n\n\tcase L_('\\0'):\t\t/* GNU extension: % at end of format.  */\n\t    --f;\n\t    /* Fall through.  */\n\tdefault:\n\t  /* Unknown format; output the format, including the '%',\n\t     since this is most likely the right thing to do if a\n\t     multibyte string has been misparsed.  */\n\tbad_format:\n\t  {\n\t    int flen;\n\t    for (flen = 1; f[1 - flen] != L_('%'); flen++)\n\t      continue;\n\t    cpy (flen, &f[1 - flen]);\n\t  }\n\t  break;\n\t}\n    }\n\n  if (p && maxsize != 0)\n    *p = L_('\\0');\n  return i;\n}",
      "lines": 922,
      "depth": 28,
      "decorators": [
        "ut_argument_spec",
        "LOCALE_PARAM_DECL",
        "{\n#if defined _LIBC && defined USE_IN_EXTENDED_LOCALE_MODEL\n  struct locale_data *const current = loc->__locales[LC_TIME];\n#endif\n\n  int hour12 = tp->tm_hour;\n#ifdef _NL_CURRENT\n  /* We cannot make the following values variables since we must delay\n     the evaluation of these values until really needed since some\n     expressions might not be valid in every situation.  The `struct tm'\n     might be generated by a strptime() call that initialized\n     only a few elements.  Dereference the pointers only if the format\n     requires this.  Then it is ok to fail if the pointers are invalid.  */\n# define a_wkday \\\n  ((const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(ABDAY_1) + tp->tm_wday))\n# define f_wkday \\\n  ((const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(DAY_1) + tp->tm_wday))\n# define a_month \\\n  ((const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(ABMON_1) + tp->tm_mon))\n# define f_month \\\n  ((const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(MON_1) + tp->tm_mon))\n# define ampm \\\n  ((const CHAR_T *) _NL_CURRENT (LC_TIME, tp->tm_hour > 11\t\t      \\\n\t\t\t\t ? NLW(PM_STR) : NLW(AM_STR)))\n\n# define aw_len STRLEN (a_wkday)\n# define am_len STRLEN (a_month)\n# define ap_len STRLEN (ampm)\n#else\n# if !HAVE_STRFTIME\n#  define f_wkday (weekday_name[tp->tm_wday])\n#  define f_month (month_name[tp->tm_mon])\n#  define a_wkday f_wkday\n#  define a_month f_month\n#  define ampm (L_(\"AMPM\") + 2 * (tp->tm_hour > 11))\n\n  size_t aw_len = 3;\n  size_t am_len = 3;\n  size_t ap_len = 2;\n# endif\n#endif\n  const char *zone;\n  size_t i = 0;\n  CHAR_T *p = s;\n  const CHAR_T *f;\n#if DO_MULTIBYTE && !defined COMPILE_WIDE\n  const char *format_end = NULL;\n#endif\n\n  zone = NULL;\n#if HAVE_TM_ZONE\n  /* The POSIX test suite assumes that setting\n     the environment variable TZ to a new value before calling strftime()\n     will influence the result (the %Z format) even if the information in\n     TP is computed with a totally different time zone.\n     This is bogus: though POSIX allows bad behavior like this,\n     POSIX does not require it.  Do the right thing instead.  */\n  zone = (const char *) tp->tm_zone;\n#endif\n#if HAVE_TZNAME\n  if (ut)\n    {\n      if (! (zone && *zone))\n\tzone = \"GMT\";\n    }\n  else\n    {\n      /* POSIX.1 requires that local time zone information is used as\n\t though strftime called tzset.  */\n# if HAVE_TZSET\n      tzset ();\n# endif\n    }\n#endif\n\n  if (hour12 > 12)\n    hour12 -= 12;\n  else\n    if (hour12 == 0)\n      hour12 = 12;\n\n  for (f = format; *f != '\\0'; ++f)\n    {\n      int pad = 0;\t\t/* Padding for number ('-', '_', or 0).  */\n      int modifier;\t\t/* Field modifier ('E', 'O', or 0).  */\n      int digits;\t\t/* Max digits for numeric format.  */\n      int number_value; \t/* Numeric value to be printed.  */\n      int negative_number;\t/* 1 if the number is negative.  */\n      const CHAR_T *subfmt;\n      CHAR_T *bufp;\n      CHAR_T buf[1 + (sizeof (int) < sizeof (time_t)\n\t\t      ? INT_STRLEN_BOUND (time_t)\n\t\t      : INT_STRLEN_BOUND (int))];\n      int width = -1;\n      int to_lowcase = 0;\n      int to_uppcase = 0;\n      int change_case = 0;\n      int format_char;\n\n#if DO_MULTIBYTE && !defined COMPILE_WIDE\n      switch (*f)\n\t{\n\tcase L_('%'):\n\t  break;\n\n\tcase L_('\\b'): case L_('\\t'): case L_('\\n'):\n\tcase L_('\\v'): case L_('\\f'): case L_('\\r'):\n\tcase L_(' '): case L_('!'): case L_('\"'): case L_('#'): case L_('&'):\n\tcase L_('\\''): case L_('('): case L_(')'): case L_('*'): case L_('+'):\n\tcase L_(','): case L_('-'): case L_('.'): case L_('/'): case L_('0'):\n\tcase L_('1'): case L_('2'): case L_('3'): case L_('4'): case L_('5'):\n\tcase L_('6'): case L_('7'): case L_('8'): case L_('9'): case L_(':'):\n\tcase L_(';'): case L_('<'): case L_('='): case L_('>'): case L_('?'):\n\tcase L_('A'): case L_('B'): case L_('C'): case L_('D'): case L_('E'):\n\tcase L_('F'): case L_('G'): case L_('H'): case L_('I'): case L_('J'):\n\tcase L_('K'): case L_('L'): case L_('M'): case L_('N'): case L_('O'):\n\tcase L_('P'): case L_('Q'): case L_('R'): case L_('S'): case L_('T'):\n\tcase L_('U'): case L_('V'): case L_('W'): case L_('X'): case L_('Y'):\n\tcase L_('Z'): case L_('['): case L_('\\\\'): case L_(']'): case L_('^'):\n\tcase L_('_'): case L_('a'): case L_('b'): case L_('c'): case L_('d'):\n\tcase L_('e'): case L_('f'): case L_('g'): case L_('h'): case L_('i'):\n\tcase L_('j'): case L_('k'): case L_('l'): case L_('m'): case L_('n'):\n\tcase L_('o'): case L_('p'): case L_('q'): case L_('r'): case L_('s'):\n\tcase L_('t'): case L_('u'): case L_('v'): case L_('w'): case L_('x'):\n\tcase L_('y'): case L_('z'): case L_('{'): case L_('|'): case L_('}'):\n\tcase L_('~'):\n\t  /* The C Standard requires these 98 characters (plus '%') to\n\t     be in the basic execution character set.  None of these\n\t     characters can start a multibyte sequence, so they need\n\t     not be analyzed further.  */\n\t  add (1, *p = *f);\n\t  continue;\n\n\tdefault:\n\t  /* Copy this multibyte sequence until we reach its end, find\n\t     an error, or come back to the initial shift state.  */\n\t  {\n\t    mbstate_t mbstate = mbstate_zero;\n\t    size_t len = 0;\n\t    size_t fsize;\n\n\t    if (! format_end)\n\t      format_end = f + strlen (f) + 1;\n\t    fsize = format_end - f;\n\n\t    do\n\t      {\n\t\tsize_t bytes = mbrlen (f + len, fsize - len, &mbstate);\n\n\t\tif (bytes == 0)\n\t\t  break;\n\n\t\tif (bytes == (size_t) -2)\n\t\t  {\n\t\t    len += strlen (f + len);\n\t\t    break;\n\t\t  }\n\n\t\tif (bytes == (size_t) -1)\n\t\t  {\n\t\t    len++;\n\t\t    break;\n\t\t  }\n\n\t\tlen += bytes;\n\t      }\n\t    while (! mbsinit (&mbstate));\n\n\t    cpy (len, f);\n\t    f += len - 1;\n\t    continue;\n\t  }\n\t}\n\n#else /* ! DO_MULTIBYTE */\n\n      /* Either multibyte encodings are not supported, they are\n\t safe for formats, so any non-'%' byte can be copied through,\n\t or this is the wide character version.  */\n      if (*f != L_('%'))\n\t{\n\t  add (1, *p = *f);\n\t  continue;\n\t}\n\n#endif /* ! DO_MULTIBYTE */\n\n      /* Check for flags that can modify a format.  */\n      while (1)\n\t{\n\t  switch (*++f)\n\t    {\n\t      /* This influences the number formats.  */\n\t    case L_('_'):\n\t    case L_('-'):\n\t    case L_('0'):\n\t      pad = *f;\n\t      continue;\n\n\t      /* This changes textual output.  */\n\t    case L_('^'):\n\t      to_uppcase = 1;\n\t      continue;\n\t    case L_('#'):\n\t      change_case = 1;\n\t      continue;\n\n\t    default:\n\t      break;\n\t    }\n\t  break;\n\t}\n\n      /* As a GNU extension we allow to specify the field width.  */\n      if (ISDIGIT (*f))\n\t{\n\t  width = 0;\n\t  do\n\t    {\n\t      if (width > INT_MAX / 10\n\t\t  || (width == INT_MAX / 10 && *f - L_('0') > INT_MAX % 10))\n\t\t/* Avoid overflow.  */\n\t\twidth = INT_MAX;\n\t      else\n\t\t{\n\t\t  width *= 10;\n\t\t  width += *f - L_('0');\n\t\t}\n\t      ++f;\n\t    }\n\t  while (ISDIGIT (*f));\n\t}\n\n      /* Check for modifiers.  */\n      switch (*f)\n\t{\n\tcase L_('E'):\n\tcase L_('O'):\n\t  modifier = *f++;\n\t  break;\n\n\tdefault:\n\t  modifier = 0;\n\t  break;\n\t}\n\n      /* Now do the specified format.  */\n      format_char = *f;\n      switch (format_char)\n\t{\n#define DO_NUMBER(d, v) \\\n\t  digits = d > width ? d : width;\t\t\t\t      \\\n\t  number_value = v; goto do_number\n#define DO_NUMBER_SPACEPAD(d, v) \\\n\t  digits = d > width ? d : width;\t\t\t\t      \\\n\t  number_value = v; goto do_number_spacepad\n\n\tcase L_('%'):\n\t  if (modifier != 0)\n\t    goto bad_format;\n\t  add (1, *p = *f);\n\t  break;\n\n\tcase L_('a'):\n\t  if (modifier != 0)\n\t    goto bad_format;\n\t  if (change_case)\n\t    {\n\t      to_uppcase = 1;\n\t      to_lowcase = 0;\n\t    }\n#if defined _NL_CURRENT || !HAVE_STRFTIME\n\t  cpy (aw_len, a_wkday);\n\t  break;\n#else\n\t  goto underlying_strftime;\n#endif\n\n\tcase 'A':\n\t  if (modifier != 0)\n\t    goto bad_format;\n\t  if (change_case)\n\t    {\n\t      to_uppcase = 1;\n\t      to_lowcase = 0;\n\t    }\n#if defined _NL_CURRENT || !HAVE_STRFTIME\n\t  cpy (STRLEN (f_wkday), f_wkday);\n\t  break;\n#else\n\t  goto underlying_strftime;\n#endif\n\n\tcase L_('b'):\n\tcase L_('h'):\n\t  if (change_case)\n\t    {\n\t      to_uppcase = 1;\n\t      to_lowcase = 0;\n\t    }\n\t  if (modifier != 0)\n\t    goto bad_format;\n#if defined _NL_CURRENT || !HAVE_STRFTIME\n\t  cpy (am_len, a_month);\n\t  break;\n#else\n\t  goto underlying_strftime;\n#endif\n\n\tcase L_('B'):\n\t  if (modifier != 0)\n\t    goto bad_format;\n\t  if (change_case)\n\t    {\n\t      to_uppcase = 1;\n\t      to_lowcase = 0;\n\t    }\n#if defined _NL_CURRENT || !HAVE_STRFTIME\n\t  cpy (STRLEN (f_month), f_month);\n\t  break;\n#else\n\t  goto underlying_strftime;\n#endif\n\n\tcase L_('c'):\n\t  if (modifier == L_('O'))\n\t    goto bad_format;\n#ifdef _NL_CURRENT\n\t  if (! (modifier == 'E'\n\t\t && (*(subfmt =\n\t\t       (const CHAR_T *) _NL_CURRENT (LC_TIME,\n\t\t\t\t\t\t     NLW(ERA_D_T_FMT)))\n\t\t     != '\\0')))\n\t    subfmt = (const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(D_T_FMT));\n#else\n# if HAVE_STRFTIME\n\t  goto underlying_strftime;\n# else\n\t  subfmt = L_(\"%a %b %e %H:%M:%S %Y\");\n# endif\n#endif\n\n\tsubformat:\n\t  {\n\t    CHAR_T *old_start = p;\n\t    size_t len = my_strftime (NULL, (size_t) -1, subfmt,\n\t\t\t\t      tp ut_argument LOCALE_ARG);\n\t    add (len, my_strftime (p, maxsize - i, subfmt,\n\t\t\t\t   tp ut_argument LOCALE_ARG));\n\n\t    if (to_uppcase)\n\t      while (old_start < p)\n\t\t{\n\t\t  *old_start = TOUPPER ((UCHAR_T) *old_start, loc);\n\t\t  ++old_start;\n\t\t}\n\t  }\n\t  break;\n\n#if HAVE_STRFTIME && ! (defined _NL_CURRENT && HAVE_STRUCT_ERA_ENTRY)\n\tunderlying_strftime:\n\t  {\n\t    /* The relevant information is available only via the\n\t       underlying strftime implementation, so use that.  */\n\t    char ufmt[4];\n\t    char *u = ufmt;\n\t    char ubuf[1024]; /* enough for any single format in practice */\n\t    size_t len;\n\t    /* Make sure we're calling the actual underlying strftime.\n\t       In some cases, config.h contains something like\n\t       \"#define strftime rpl_strftime\".  */\n# ifdef strftime\n#  undef strftime\n\t    size_t strftime ();\n# endif\n\n\t    *u++ = '%';\n\t    if (modifier != 0)\n\t      *u++ = modifier;\n\t    *u++ = format_char;\n\t    *u = '\\0';\n\t    len = strftime (ubuf, sizeof ubuf, ufmt, tp);\n\t    if (len == 0 && ubuf[0] != '\\0')\n\t      return 0;\n\t    cpy (len, ubuf);\n\t  }\n\t  break;\n#endif\n\n\tcase L_('C'):\n\t  if (modifier == L_('O'))\n\t    goto bad_format;\n\t  if (modifier == L_('E'))\n\t    {\n#if HAVE_STRUCT_ERA_ENTRY\n\t      struct era_entry *era = _nl_get_era_entry (tp HELPER_LOCALE_ARG);\n\t      if (era)\n\t\t{\n# ifdef COMPILE_WIDE\n\t\t  size_t len = __wcslen (era->era_wname);\n\t\t  cpy (len, era->era_wname);\n# else\n\t\t  size_t len = strlen (era->era_name);\n\t\t  cpy (len, era->era_name);\n# endif\n\t\t  break;\n\t\t}\n#else\n# if HAVE_STRFTIME\n\t      goto underlying_strftime;\n# endif\n#endif\n\t    }\n\n\t  {\n\t    int year = tp->tm_year + TM_YEAR_BASE;\n\t    DO_NUMBER (1, year / 100 - (year % 100 < 0));\n\t  }\n\n\tcase L_('x'):\n\t  if (modifier == L_('O'))\n\t    goto bad_format;\n#ifdef _NL_CURRENT\n\t  if (! (modifier == L_('E')\n\t\t && (*(subfmt =\n\t\t       (const CHAR_T *)_NL_CURRENT (LC_TIME, NLW(ERA_D_FMT)))\n\t\t     != L_('\\0'))))\n\t    subfmt = (const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(D_FMT));\n\t  goto subformat;\n#else\n# if HAVE_STRFTIME\n\t  goto underlying_strftime;\n# else\n\t  /* Fall through.  */\n# endif\n#endif\n\tcase L_('D'):\n\t  if (modifier != 0)\n\t    goto bad_format;\n\t  subfmt = L_(\"%m/%d/%y\");\n\t  goto subformat;\n\n\tcase L_('d'):\n\t  if (modifier == L_('E'))\n\t    goto bad_format;\n\n\t  DO_NUMBER (2, tp->tm_mday);\n\n\tcase L_('e'):\n\t  if (modifier == L_('E'))\n\t    goto bad_format;\n\n\t  DO_NUMBER_SPACEPAD (2, tp->tm_mday);\n\n\t  /* All numeric formats set DIGITS and NUMBER_VALUE and then\n\t     jump to one of these two labels.  */\n\n\tdo_number_spacepad:\n\t  /* Force `_' flag unless overwritten by `0' flag.  */\n\t  if (pad != L_('0'))\n\t    pad = L_('_');\n\n\tdo_number:\n\t  /* Format the number according to the MODIFIER flag.  */\n\n\t  if (modifier == L_('O') && 0 <= number_value)\n\t    {\n#ifdef _NL_CURRENT\n\t      /* Get the locale specific alternate representation of\n\t\t the number NUMBER_VALUE.  If none exist NULL is returned.  */\n\t      const CHAR_T *cp = nl_get_alt_digit (number_value\n\t\t\t\t\t\t   HELPER_LOCALE_ARG);\n\n\t      if (cp != NULL)\n\t\t{\n\t\t  size_t digitlen = STRLEN (cp);\n\t\t  if (digitlen != 0)\n\t\t    {\n\t\t      cpy (digitlen, cp);\n\t\t      break;\n\t\t    }\n\t\t}\n#else\n# if HAVE_STRFTIME\n\t      goto underlying_strftime;\n# endif\n#endif\n\t    }\n\t  {\n\t    unsigned int u = number_value;\n\n\t    bufp = buf + sizeof (buf) / sizeof (buf[0]);\n\t    negative_number = number_value < 0;\n\n\t    if (negative_number)\n\t      u = -u;\n\n\t    do\n\t      *--bufp = u % 10 + L_('0');\n\t    while ((u /= 10) != 0);\n  \t  }\n\n\tdo_number_sign_and_padding:\n\t  if (negative_number)\n\t    *--bufp = L_('-');\n\n\t  if (pad != L_('-'))\n\t    {\n\t      int padding = digits - (buf + (sizeof (buf) / sizeof (buf[0]))\n\t\t\t\t      - bufp);\n\n\t      if (padding > 0)\n\t\t{\n\t\t  if (pad == L_('_'))\n\t\t    {\n\t\t      if ((size_t) padding >= maxsize - i)\n\t\t\treturn 0;\n\n\t\t      if (p)\n\t\t\tmemset_space (p, padding);\n\t\t      i += padding;\n\t\t      width = width > padding ? width - padding : 0;\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      if ((size_t) digits >= maxsize - i)\n\t\t\treturn 0;\n\n\t\t      if (negative_number)\n\t\t\t{\n\t\t\t  ++bufp;\n\n\t\t\t  if (p)\n\t\t\t    *p++ = L_('-');\n\t\t\t  ++i;\n\t\t\t}\n\n\t\t      if (p)\n\t\t\tmemset_zero (p, padding);\n\t\t      i += padding;\n\t\t      width = 0;\n\t\t    }\n\t\t}\n\t    }\n\n\t  cpy (buf + sizeof (buf) / sizeof (buf[0]) - bufp, bufp);\n\t  break;\n\n\tcase L_('F'):\n\t  if (modifier != 0)\n\t    goto bad_format;\n\t  subfmt = L_(\"%Y-%m-%d\");\n\t  goto subformat;\n\n\tcase L_('H'):\n\t  if (modifier == L_('E'))\n\t    goto bad_format;\n\n\t  DO_NUMBER (2, tp->tm_hour);\n\n\tcase L_('I'):\n\t  if (modifier == L_('E'))\n\t    goto bad_format;\n\n\t  DO_NUMBER (2, hour12);\n\n\tcase L_('k'):\t\t/* GNU extension.  */\n\t  if (modifier == L_('E'))\n\t    goto bad_format;\n\n\t  DO_NUMBER_SPACEPAD (2, tp->tm_hour);\n\n\tcase L_('l'):\t\t/* GNU extension.  */\n\t  if (modifier == L_('E'))\n\t    goto bad_format;\n\n\t  DO_NUMBER_SPACEPAD (2, hour12);\n\n\tcase L_('j'):\n\t  if (modifier == L_('E'))\n\t    goto bad_format;\n\n\t  DO_NUMBER (3, 1 + tp->tm_yday);\n\n\tcase L_('M'):\n\t  if (modifier == L_('E'))\n\t    goto bad_format;\n\n\t  DO_NUMBER (2, tp->tm_min);\n\n\tcase L_('m'):\n\t  if (modifier == L_('E'))\n\t    goto bad_format;\n\n\t  DO_NUMBER (2, tp->tm_mon + 1);\n\n\tcase L_('n'):\n\t  add (1, *p = L_('\\n'));\n\t  break;\n\n\tcase L_('P'):\n\t  to_lowcase = 1;\n#if !defined _NL_CURRENT && HAVE_STRFTIME\n\t  format_char = L_('p');\n#endif\n\t  /* FALLTHROUGH */\n\n\tcase L_('p'):\n\t  if (change_case)\n\t    {\n\t      to_uppcase = 0;\n\t      to_lowcase = 1;\n\t    }\n#if defined _NL_CURRENT || !HAVE_STRFTIME\n\t  cpy (ap_len, ampm);\n\t  break;\n#else\n\t  goto underlying_strftime;\n#endif\n\n\tcase L_('R'):\n\t  subfmt = L_(\"%H:%M\");\n\t  goto subformat;\n\n\tcase L_('r'):\n#ifdef _NL_CURRENT\n\t  if (*(subfmt = (const CHAR_T *) _NL_CURRENT (LC_TIME,\n\t\t\t\t\t\t       NLW(T_FMT_AMPM)))\n\t      == L_('\\0'))\n#endif\n\t    subfmt = L_(\"%I:%M:%S %p\");\n\t  goto subformat;\n\n\tcase L_('S'):\n\t  if (modifier == L_('E'))\n\t    goto bad_format;\n\n\t  DO_NUMBER (2, tp->tm_sec);\n\n\tcase L_('s'):\t\t/* GNU extension.  */\n  \t  {\n\t    struct tm ltm;\n\t    time_t t;\n\n\t    ltm = *tp;\n\t    t = mktime (&ltm);\n\n\t    /* Generate string value for T using time_t arithmetic;\n\t       this works even if sizeof (long) < sizeof (time_t).  */\n\n\t    bufp = buf + sizeof (buf) / sizeof (buf[0]);\n#ifndef TIME_T_UNSIGNED\n\t    negative_number = t < 0;\n#endif\n\n\t    do\n\t      {\n\t\tint d = t % 10;\n\t\tt /= 10;\n\n#ifndef TIME_T_UNSIGNED\n\t\tif (negative_number)\n\t\t  {\n\t\t    d = -d;\n\n\t\t    /* Adjust if division truncates to minus infinity.  */\n\t\t    if (0 < -1 % 10 && d < 0)\n\t\t      {\n\t\t\tt++;\n\t\t\td += 10;\n\t\t      }\n\t\t  }\n#endif\n\n\t\t*--bufp = d + L_('0');\n\t      }\n\t    while (t != 0);\n\n\t    digits = 1;\n\t    goto do_number_sign_and_padding;\n\t  }\n\n\tcase L_('X'):\n\t  if (modifier == L_('O'))\n\t    goto bad_format;\n#ifdef _NL_CURRENT\n\t  if (! (modifier == L_('E')\n\t\t && (*(subfmt =\n\t\t       (const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(ERA_T_FMT)))\n\t\t     != L_('\\0'))))\n\t    subfmt = (const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(T_FMT));\n\t  goto subformat;\n#else\n# if HAVE_STRFTIME\n\t  goto underlying_strftime;\n# else\n\t  /* Fall through.  */\n# endif\n#endif\n\tcase L_('T'):\n\t  subfmt = L_(\"%H:%M:%S\");\n\t  goto subformat;\n\n\tcase L_('t'):\n\t  add (1, *p = L_('\\t'));\n\t  break;\n\n\tcase L_('u'):\n\t  DO_NUMBER (1, (tp->tm_wday - 1 + 7) % 7 + 1);\n\n\tcase L_('U'):\n\t  if (modifier == L_('E'))\n\t    goto bad_format;\n\n\t  DO_NUMBER (2, (tp->tm_yday - tp->tm_wday + 7) / 7);\n\n\tcase L_('V'):\n\tcase L_('g'):\n\tcase L_('G'):\n\t  if (modifier == L_('E'))\n\t    goto bad_format;\n\t  {\n\t    int year = tp->tm_year + TM_YEAR_BASE;\n\t    int days = iso_week_days (tp->tm_yday, tp->tm_wday);\n\n\t    if (days < 0)\n\t      {\n\t\t/* This ISO week belongs to the previous year.  */\n\t\tyear--;\n\t\tdays = iso_week_days (tp->tm_yday + (365 + __isleap (year)),\n\t\t\t\t      tp->tm_wday);\n\t      }\n\t    else\n\t      {\n\t\tint d = iso_week_days (tp->tm_yday - (365 + __isleap (year)),\n\t\t\t\t       tp->tm_wday);\n\t\tif (0 <= d)\n\t\t  {\n\t\t    /* This ISO week belongs to the next year.  */\n\t\t    year++;\n\t\t    days = d;\n\t\t  }\n\t      }\n\n\t    switch (*f)\n\t      {\n\t      case L_('g'):\n\t\tDO_NUMBER (2, (year % 100 + 100) % 100);\n\n\t      case L_('G'):\n\t\tDO_NUMBER (1, year);\n\n\t      default:\n\t\tDO_NUMBER (2, days / 7 + 1);\n\t      }\n\t  }\n\n\tcase L_('W'):\n\t  if (modifier == L_('E'))\n\t    goto bad_format;\n\n\t  DO_NUMBER (2, (tp->tm_yday - (tp->tm_wday - 1 + 7) % 7 + 7) / 7);\n\n\tcase L_('w'):\n\t  if (modifier == L_('E'))\n\t    goto bad_format;\n\n\t  DO_NUMBER (1, tp->tm_wday);\n\n\tcase L_('Y'):\n\t  if (modifier == 'E')\n\t    {\n#if HAVE_STRUCT_ERA_ENTRY\n\t      struct era_entry *era = _nl_get_era_entry (tp HELPER_LOCALE_ARG);\n\t      if (era)\n\t\t{\n# ifdef COMPILE_WIDE\n\t\t  subfmt = era->era_wformat;\n# else\n\t\t  subfmt = era->era_format;\n# endif\n\t\t  goto subformat;\n\t\t}\n#else\n# if HAVE_STRFTIME\n\t      goto underlying_strftime;\n# endif\n#endif\n\t    }\n\t  if (modifier == L_('O'))\n\t    goto bad_format;\n\t  else\n\t    DO_NUMBER (1, tp->tm_year + TM_YEAR_BASE);\n\n\tcase L_('y'):\n\t  if (modifier == L_('E'))\n\t    {\n#if HAVE_STRUCT_ERA_ENTRY\n\t      struct era_entry *era = _nl_get_era_entry (tp HELPER_LOCALE_ARG);\n\t      if (era)\n\t\t{\n\t\t  int delta = tp->tm_year - era->start_date[0];\n\t\t  DO_NUMBER (1, (era->offset\n\t\t\t\t + delta * era->absolute_direction));\n\t\t}\n#else\n# if HAVE_STRFTIME\n\t      goto underlying_strftime;\n# endif\n#endif\n\t    }\n\t  DO_NUMBER (2, (tp->tm_year % 100 + 100) % 100);\n\n\tcase L_('Z'):\n\t  if (change_case)\n\t    {\n\t      to_uppcase = 0;\n\t      to_lowcase = 1;\n\t    }\n\n#if HAVE_TZNAME\n\t  /* The tzset() call might have changed the value.  */\n\t  if (!(zone && *zone) && tp->tm_isdst >= 0)\n\t    zone = tzname[tp->tm_isdst];\n#endif\n\t  if (! zone)\n\t    zone = \"\";\n\n#ifdef COMPILE_WIDE\n\t  {\n\t    /* The zone string is always given in multibyte form.  We have\n\t       to transform it first.  */\n\t    wchar_t *wczone;\n\t    size_t len;\n\t    widen (zone, wczone, len);\n\t    cpy (len, wczone);\n\t  }\n#else\n\t  cpy (strlen (zone), zone);\n#endif\n\t  break;\n\n\tcase L_('z'):\n\t  if (tp->tm_isdst < 0)\n\t    break;\n\n\t  {\n\t    int diff;\n#if HAVE_TM_GMTOFF\n\t    diff = tp->tm_gmtoff;\n#else\n\t    if (ut)\n\t      diff = 0;\n\t    else\n\t      {\n\t\tstruct tm gtm;\n\t\tstruct tm ltm;\n\t\ttime_t lt;\n\n\t\tltm = *tp;\n\t\tlt = mktime (&ltm);\n\n\t\tif (lt == (time_t) -1)\n\t\t  {\n\t\t    /* mktime returns -1 for errors, but -1 is also a\n\t\t       valid time_t value.  Check whether an error really\n\t\t       occurred.  */\n\t\t    struct tm tm;\n\n\t\t    if (! my_strftime_localtime_r (&lt, &tm)\n\t\t\t|| ((ltm.tm_sec ^ tm.tm_sec)\n\t\t\t    | (ltm.tm_min ^ tm.tm_min)\n\t\t\t    | (ltm.tm_hour ^ tm.tm_hour)\n\t\t\t    | (ltm.tm_mday ^ tm.tm_mday)\n\t\t\t    | (ltm.tm_mon ^ tm.tm_mon)\n\t\t\t    | (ltm.tm_year ^ tm.tm_year)))\n\t\t      break;\n\t\t  }\n\n\t\tif (! my_strftime_gmtime_r (&lt, &gtm))\n\t\t  break;\n\n\t\tdiff = tm_diff (&ltm, &gtm);\n\t      }\n#endif\n\n\t    if (diff < 0)\n\t      {\n\t\tadd (1, *p = L_('-'));\n\t\tdiff = -diff;\n\t      }\n\t    else\n\t      add (1, *p = L_('+'));\n\n\t    diff /= 60;\n\t    DO_NUMBER (4, (diff / 60) * 100 + diff % 60);\n\t  }\n\n\tcase L_('\\0'):\t\t/* GNU extension: % at end of format.  */\n\t    --f;\n\t    /* Fall through.  */\n\tdefault:\n\t  /* Unknown format; output the format, including the '%',\n\t     since this is most likely the right thing to do if a\n\t     multibyte string has been misparsed.  */\n\tbad_format:\n\t  {\n\t    int flen;\n\t    for (flen = 1; f[1 - flen] != L_('%'); flen++)\n\t      continue;\n\t    cpy (flen, &f[1 - flen]);\n\t  }\n\t  break;\n\t}\n    }\n\n  if (p && maxsize != 0)\n    *p = L_('\\0');\n  return i;\n}",
        "{",
        "#if defined _LIBC && defined USE_IN_EXTENDED_LOCALE_MODEL\n  struct locale_data *const current = loc->__locales[LC_TIME];\n#endif",
        "#if",
        "defined _LIBC && defined USE_IN_EXTENDED_LOCALE_MODEL",
        "defined _LIBC",
        "defined",
        "_LIBC",
        "&&",
        "defined USE_IN_EXTENDED_LOCALE_MODEL",
        "defined",
        "USE_IN_EXTENDED_LOCALE_MODEL",
        "\n",
        "struct locale_data *const current = loc->__locales[LC_TIME];",
        "struct locale_data",
        "struct",
        "locale_data",
        "*const current = loc->__locales[LC_TIME]",
        "*const current",
        "*",
        "const",
        "const",
        "current",
        "=",
        "loc->__locales[LC_TIME]",
        "loc->__locales",
        "loc",
        "->",
        "__locales",
        "[",
        "LC_TIME",
        "]",
        ";",
        "#endif",
        "int hour12 = tp->tm_hour;",
        "int",
        "hour12 = tp->tm_hour",
        "hour12",
        "=",
        "tp->tm_hour",
        "tp",
        "->",
        "tm_hour",
        ";",
        "#ifdef _NL_CURRENT\n  /* We cannot make the following values variables since we must delay\n     the evaluation of these values until really needed since some\n     expressions might not be valid in every situation.  The `struct tm'\n     might be generated by a strptime() call that initialized\n     only a few elements.  Dereference the pointers only if the format\n     requires this.  Then it is ok to fail if the pointers are invalid.  */\n# define a_wkday \\\n  ((const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(ABDAY_1) + tp->tm_wday))\n# define f_wkday \\\n  ((const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(DAY_1) + tp->tm_wday))\n# define a_month \\\n  ((const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(ABMON_1) + tp->tm_mon))\n# define f_month \\\n  ((const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(MON_1) + tp->tm_mon))\n# define ampm \\\n  ((const CHAR_T *) _NL_CURRENT (LC_TIME, tp->tm_hour > 11\t\t      \\\n\t\t\t\t ? NLW(PM_STR) : NLW(AM_STR)))\n\n# define aw_len STRLEN (a_wkday)\n# define am_len STRLEN (a_month)\n# define ap_len STRLEN (ampm)\n#else\n# if !HAVE_STRFTIME\n#  define f_wkday (weekday_name[tp->tm_wday])\n#  define f_month (month_name[tp->tm_mon])\n#  define a_wkday f_wkday\n#  define a_month f_month\n#  define ampm (L_(\"AMPM\") + 2 * (tp->tm_hour > 11))\n\n  size_t aw_len = 3;\n  size_t am_len = 3;\n  size_t ap_len = 2;\n# endif\n#endif",
        "#ifdef",
        "_NL_CURRENT",
        "/* We cannot make the following values variables since we must delay\n     the evaluation of these values until really needed since some\n     expressions might not be valid in every situation.  The `struct tm'\n     might be generated by a strptime() call that initialized\n     only a few elements.  Dereference the pointers only if the format\n     requires this.  Then it is ok to fail if the pointers are invalid.  */",
        "# define a_wkday \\\n  ((const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(ABDAY_1) + tp->tm_wday))\n",
        "# define",
        "a_wkday",
        " \\\n  ((const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(ABDAY_1) + tp->tm_wday))",
        "\n",
        "# define f_wkday \\\n  ((const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(DAY_1) + tp->tm_wday))\n",
        "# define",
        "f_wkday",
        " \\\n  ((const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(DAY_1) + tp->tm_wday))",
        "\n",
        "# define a_month \\\n  ((const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(ABMON_1) + tp->tm_mon))\n",
        "# define",
        "a_month",
        " \\\n  ((const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(ABMON_1) + tp->tm_mon))",
        "\n",
        "# define f_month \\\n  ((const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(MON_1) + tp->tm_mon))\n",
        "# define",
        "f_month",
        " \\\n  ((const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(MON_1) + tp->tm_mon))",
        "\n",
        "# define ampm \\\n  ((const CHAR_T *) _NL_CURRENT (LC_TIME, tp->tm_hour > 11\t\t      \\\n\t\t\t\t ? NLW(PM_STR) : NLW(AM_STR)))\n\n",
        "# define",
        "ampm",
        " \\\n  ((const CHAR_T *) _NL_CURRENT (LC_TIME, tp->tm_hour > 11\t\t      \\\n\t\t\t\t ? NLW(PM_STR) : NLW(AM_STR)))",
        "\n\n",
        "# define aw_len STRLEN (a_wkday)\n",
        "# define",
        "aw_len",
        " STRLEN (a_wkday)",
        "\n",
        "# define am_len STRLEN (a_month)\n",
        "# define",
        "am_len",
        " STRLEN (a_month)",
        "\n",
        "# define ap_len STRLEN (ampm)\n",
        "# define",
        "ap_len",
        " STRLEN (ampm)",
        "\n",
        "#else\n# if !HAVE_STRFTIME\n#  define f_wkday (weekday_name[tp->tm_wday])\n#  define f_month (month_name[tp->tm_mon])\n#  define a_wkday f_wkday\n#  define a_month f_month\n#  define ampm (L_(\"AMPM\") + 2 * (tp->tm_hour > 11))\n\n  size_t aw_len = 3;\n  size_t am_len = 3;\n  size_t ap_len = 2;\n# endif",
        "#else",
        "# if !HAVE_STRFTIME\n#  define f_wkday (weekday_name[tp->tm_wday])\n#  define f_month (month_name[tp->tm_mon])\n#  define a_wkday f_wkday\n#  define a_month f_month\n#  define ampm (L_(\"AMPM\") + 2 * (tp->tm_hour > 11))\n\n  size_t aw_len = 3;\n  size_t am_len = 3;\n  size_t ap_len = 2;\n# endif",
        "# if",
        "!HAVE_STRFTIME",
        "!",
        "HAVE_STRFTIME",
        "\n",
        "#  define f_wkday (weekday_name[tp->tm_wday])\n",
        "#  define",
        "f_wkday",
        " (weekday_name[tp->tm_wday])",
        "\n",
        "#  define f_month (month_name[tp->tm_mon])\n",
        "#  define",
        "f_month",
        " (month_name[tp->tm_mon])",
        "\n",
        "#  define a_wkday f_wkday\n",
        "#  define",
        "a_wkday",
        " f_wkday",
        "\n",
        "#  define a_month f_month\n",
        "#  define",
        "a_month",
        " f_month",
        "\n",
        "#  define ampm (L_(\"AMPM\") + 2 * (tp->tm_hour > 11))\n\n",
        "#  define",
        "ampm",
        " (L_(\"AMPM\") + 2 * (tp->tm_hour > 11))",
        "\n\n",
        "size_t aw_len = 3;",
        "size_t",
        "aw_len = 3",
        "aw_len",
        "=",
        "3",
        ";",
        "size_t am_len = 3;",
        "size_t",
        "am_len = 3",
        "am_len",
        "=",
        "3",
        ";",
        "size_t ap_len = 2;",
        "size_t",
        "ap_len = 2",
        "ap_len",
        "=",
        "2",
        ";",
        "# endif",
        "#endif",
        "const char *zone;",
        "const",
        "const",
        "char",
        "*zone",
        "*",
        "zone",
        ";",
        "size_t i = 0;",
        "size_t",
        "i = 0",
        "i",
        "=",
        "0",
        ";",
        "CHAR_T *p = s;",
        "CHAR_T",
        "*p = s",
        "*p",
        "*",
        "p",
        "=",
        "s",
        ";",
        "const CHAR_T *f;",
        "const",
        "const",
        "CHAR_T",
        "*f",
        "*",
        "f",
        ";",
        "#if DO_MULTIBYTE && !defined COMPILE_WIDE\n  const char *format_end = NULL;\n#endif",
        "#if",
        "DO_MULTIBYTE && !defined COMPILE_WIDE",
        "DO_MULTIBYTE",
        "&&",
        "!defined COMPILE_WIDE",
        "!",
        "defined COMPILE_WIDE",
        "defined",
        "COMPILE_WIDE",
        "\n",
        "const char *format_end = NULL;",
        "const",
        "const",
        "char",
        "*format_end = NULL",
        "*format_end",
        "*",
        "format_end",
        "=",
        "NULL",
        ";",
        "#endif",
        "zone = NULL;",
        "zone = NULL",
        "zone",
        "=",
        "NULL",
        ";",
        "#if HAVE_TM_ZONE\n  /* The POSIX test suite assumes that setting\n     the environment variable TZ to a new value before calling strftime()\n     will influence the result (the %Z format) even if the information in\n     TP is computed with a totally different time zone.\n     This is bogus: though POSIX allows bad behavior like this,\n     POSIX does not require it.  Do the right thing instead.  */\n  zone = (const char *) tp->tm_zone;\n#endif",
        "#if",
        "HAVE_TM_ZONE",
        "\n",
        "/* The POSIX test suite assumes that setting\n     the environment variable TZ to a new value before calling strftime()\n     will influence the result (the %Z format) even if the information in\n     TP is computed with a totally different time zone.\n     This is bogus: though POSIX allows bad behavior like this,\n     POSIX does not require it.  Do the right thing instead.  */",
        "zone = (const char *) tp->tm_zone;",
        "zone = (const char *) tp->tm_zone",
        "zone",
        "=",
        "(const char *) tp->tm_zone",
        "(",
        "const char *",
        "const",
        "const",
        "char",
        "*",
        "*",
        ")",
        "tp->tm_zone",
        "tp",
        "->",
        "tm_zone",
        ";",
        "#endif",
        "#if HAVE_TZNAME\n  if (ut)\n    {\n      if (! (zone && *zone))\n\tzone = \"GMT\";\n    }\n  else\n    {\n      /* POSIX.1 requires that local time zone information is used as\n\t though strftime called tzset.  */\n# if HAVE_TZSET\n      tzset ();\n# endif\n    }\n#endif",
        "#if",
        "HAVE_TZNAME",
        "\n",
        "if (ut)\n    {\n      if (! (zone && *zone))\n\tzone = \"GMT\";\n    }\n  else\n    {\n      /* POSIX.1 requires that local time zone information is used as\n\t though strftime called tzset.  */\n# if HAVE_TZSET\n      tzset ();\n# endif\n    }",
        "if",
        "(ut)",
        "(",
        "ut",
        ")",
        "{\n      if (! (zone && *zone))\n\tzone = \"GMT\";\n    }",
        "{",
        "if (! (zone && *zone))\n\tzone = \"GMT\";",
        "if",
        "(! (zone && *zone))",
        "(",
        "! (zone && *zone)",
        "!",
        "(zone && *zone)",
        "(",
        "zone && *zone",
        "zone",
        "&&",
        "*zone",
        "*",
        "zone",
        ")",
        ")",
        "zone = \"GMT\";",
        "zone = \"GMT\"",
        "zone",
        "=",
        "\"GMT\"",
        "\"",
        "\"",
        ";",
        "}",
        "else",
        "{\n      /* POSIX.1 requires that local time zone information is used as\n\t though strftime called tzset.  */\n# if HAVE_TZSET\n      tzset ();\n# endif\n    }",
        "{",
        "/* POSIX.1 requires that local time zone information is used as\n\t though strftime called tzset.  */",
        "# if HAVE_TZSET\n      tzset ();\n# endif",
        "# if",
        "HAVE_TZSET",
        "\n",
        "tzset ();",
        "tzset ()",
        "tzset",
        "()",
        "(",
        ")",
        ";",
        "# endif",
        "}",
        "#endif",
        "if (hour12 > 12)\n    hour12 -= 12;\n  else\n    if (hour12 == 0)\n      hour12 = 12;",
        "if",
        "(hour12 > 12)",
        "(",
        "hour12 > 12",
        "hour12",
        ">",
        "12",
        ")",
        "hour12 -= 12;",
        "hour12 -= 12",
        "hour12",
        "-=",
        "12",
        ";",
        "else",
        "if (hour12 == 0)\n      hour12 = 12;",
        "if",
        "(hour12 == 0)",
        "(",
        "hour12 == 0",
        "hour12",
        "==",
        "0",
        ")",
        "hour12 = 12;",
        "hour12 = 12",
        "hour12",
        "=",
        "12",
        ";",
        "for (f = format; *f != '\\0'; ++f)\n    {\n      int pad = 0;\t\t/* Padding for number ('-', '_', or 0).  */\n      int modifier;\t\t/* Field modifier ('E', 'O', or 0).  */\n      int digits;\t\t/* Max digits for numeric format.  */\n      int number_value; \t/* Numeric value to be printed.  */\n      int negative_number;\t/* 1 if the number is negative.  */\n      const CHAR_T *subfmt;\n      CHAR_T *bufp;\n      CHAR_T buf[1 + (sizeof (int) < sizeof (time_t)\n\t\t      ? INT_STRLEN_BOUND (time_t)\n\t\t      : INT_STRLEN_BOUND (int))];\n      int width = -1;\n      int to_lowcase = 0;\n      int to_uppcase = 0;\n      int change_case = 0;\n      int format_char;\n\n#if DO_MULTIBYTE && !defined COMPILE_WIDE\n      switch (*f)\n\t{\n\tcase L_('%'):\n\t  break;\n\n\tcase L_('\\b'): case L_('\\t'): case L_('\\n'):\n\tcase L_('\\v'): case L_('\\f'): case L_('\\r'):\n\tcase L_(' '): case L_('!'): case L_('\"'): case L_('#'): case L_('&'):\n\tcase L_('\\''): case L_('('): case L_(')'): case L_('*'): case L_('+'):\n\tcase L_(','): case L_('-'): case L_('.'): case L_('/'): case L_('0'):\n\tcase L_('1'): case L_('2'): case L_('3'): case L_('4'): case L_('5'):\n\tcase L_('6'): case L_('7'): case L_('8'): case L_('9'): case L_(':'):\n\tcase L_(';'): case L_('<'): case L_('='): case L_('>'): case L_('?'):\n\tcase L_('A'): case L_('B'): case L_('C'): case L_('D'): case L_('E'):\n\tcase L_('F'): case L_('G'): case L_('H'): case L_('I'): case L_('J'):\n\tcase L_('K'): case L_('L'): case L_('M'): case L_('N'): case L_('O'):\n\tcase L_('P'): case L_('Q'): case L_('R'): case L_('S'): case L_('T'):\n\tcase L_('U'): case L_('V'): case L_('W'): case L_('X'): case L_('Y'):\n\tcase L_('Z'): case L_('['): case L_('\\\\'): case L_(']'): case L_('^'):\n\tcase L_('_'): case L_('a'): case L_('b'): case L_('c'): case L_('d'):\n\tcase L_('e'): case L_('f'): case L_('g'): case L_('h'): case L_('i'):\n\tcase L_('j'): case L_('k'): case L_('l'): case L_('m'): case L_('n'):\n\tcase L_('o'): case L_('p'): case L_('q'): case L_('r'): case L_('s'):\n\tcase L_('t'): case L_('u'): case L_('v'): case L_('w'): case L_('x'):\n\tcase L_('y'): case L_('z'): case L_('{'): case L_('|'): case L_('}'):\n\tcase L_('~'):\n\t  /* The C Standard requires these 98 characters (plus '%') to\n\t     be in the basic execution character set.  None of these\n\t     characters can start a multibyte sequence, so they need\n\t     not be analyzed further.  */\n\t  add (1, *p = *f);\n\t  continue;\n\n\tdefault:\n\t  /* Copy this multibyte sequence until we reach its end, find\n\t     an error, or come back to the initial shift state.  */\n\t  {\n\t    mbstate_t mbstate = mbstate_zero;\n\t    size_t len = 0;\n\t    size_t fsize;\n\n\t    if (! format_end)\n\t      format_end = f + strlen (f) + 1;\n\t    fsize = format_end - f;\n\n\t    do\n\t      {\n\t\tsize_t bytes = mbrlen (f + len, fsize - len, &mbstate);\n\n\t\tif (bytes == 0)\n\t\t  break;\n\n\t\tif (bytes == (size_t) -2)\n\t\t  {\n\t\t    len += strlen (f + len);\n\t\t    break;\n\t\t  }\n\n\t\tif (bytes == (size_t) -1)\n\t\t  {\n\t\t    len++;\n\t\t    break;\n\t\t  }\n\n\t\tlen += bytes;\n\t      }\n\t    while (! mbsinit (&mbstate));\n\n\t    cpy (len, f);\n\t    f += len - 1;\n\t    continue;\n\t  }\n\t}\n\n#else /* ! DO_MULTIBYTE */\n\n      /* Either multibyte encodings are not supported, they are\n\t safe for formats, so any non-'%' byte can be copied through,\n\t or this is the wide character version.  */\n      if (*f != L_('%'))\n\t{\n\t  add (1, *p = *f);\n\t  continue;\n\t}\n\n#endif /* ! DO_MULTIBYTE */\n\n      /* Check for flags that can modify a format.  */\n      while (1)\n\t{\n\t  switch (*++f)\n\t    {\n\t      /* This influences the number formats.  */\n\t    case L_('_'):\n\t    case L_('-'):\n\t    case L_('0'):\n\t      pad = *f;\n\t      continue;\n\n\t      /* This changes textual output.  */\n\t    case L_('^'):\n\t      to_uppcase = 1;\n\t      continue;\n\t    case L_('#'):\n\t      change_case = 1;\n\t      continue;\n\n\t    default:\n\t      break;\n\t    }\n\t  break;\n\t}\n\n      /* As a GNU extension we allow to specify the field width.  */\n      if (ISDIGIT (*f))\n\t{\n\t  width = 0;\n\t  do\n\t    {\n\t      if (width > INT_MAX / 10\n\t\t  || (width == INT_MAX / 10 && *f - L_('0') > INT_MAX % 10))\n\t\t/* Avoid overflow.  */\n\t\twidth = INT_MAX;\n\t      else\n\t\t{\n\t\t  width *= 10;\n\t\t  width += *f - L_('0');\n\t\t}\n\t      ++f;\n\t    }\n\t  while (ISDIGIT (*f));\n\t}\n\n      /* Check for modifiers.  */\n      switch (*f)\n\t{\n\tcase L_('E'):\n\tcase L_('O'):\n\t  modifier = *f++;\n\t  break;\n\n\tdefault:\n\t  modifier = 0;\n\t  break;\n\t}\n\n      /* Now do the specified format.  */\n      format_char = *f;\n      switch (format_char)\n\t{\n#define DO_NUMBER(d, v) \\\n\t  digits = d > width ? d : width;\t\t\t\t      \\\n\t  number_value = v; goto do_number\n#define DO_NUMBER_SPACEPAD(d, v) \\\n\t  digits = d > width ? d : width;\t\t\t\t      \\\n\t  number_value = v; goto do_number_spacepad\n\n\tcase L_('%'):\n\t  if (modifier != 0)\n\t    goto bad_format;\n\t  add (1, *p = *f);\n\t  break;\n\n\tcase L_('a'):\n\t  if (modifier != 0)\n\t    goto bad_format;\n\t  if (change_case)\n\t    {\n\t      to_uppcase = 1;\n\t      to_lowcase = 0;\n\t    }\n#if defined _NL_CURRENT || !HAVE_STRFTIME\n\t  cpy (aw_len, a_wkday);\n\t  break;\n#else\n\t  goto underlying_strftime;\n#endif\n\n\tcase 'A':\n\t  if (modifier != 0)\n\t    goto bad_format;\n\t  if (change_case)\n\t    {\n\t      to_uppcase = 1;\n\t      to_lowcase = 0;\n\t    }\n#if defined _NL_CURRENT || !HAVE_STRFTIME\n\t  cpy (STRLEN (f_wkday), f_wkday);\n\t  break;\n#else\n\t  goto underlying_strftime;\n#endif\n\n\tcase L_('b'):\n\tcase L_('h'):\n\t  if (change_case)\n\t    {\n\t      to_uppcase = 1;\n\t      to_lowcase = 0;\n\t    }\n\t  if (modifier != 0)\n\t    goto bad_format;\n#if defined _NL_CURRENT || !HAVE_STRFTIME\n\t  cpy (am_len, a_month);\n\t  break;\n#else\n\t  goto underlying_strftime;\n#endif\n\n\tcase L_('B'):\n\t  if (modifier != 0)\n\t    goto bad_format;\n\t  if (change_case)\n\t    {\n\t      to_uppcase = 1;\n\t      to_lowcase = 0;\n\t    }\n#if defined _NL_CURRENT || !HAVE_STRFTIME\n\t  cpy (STRLEN (f_month), f_month);\n\t  break;\n#else\n\t  goto underlying_strftime;\n#endif\n\n\tcase L_('c'):\n\t  if (modifier == L_('O'))\n\t    goto bad_format;\n#ifdef _NL_CURRENT\n\t  if (! (modifier == 'E'\n\t\t && (*(subfmt =\n\t\t       (const CHAR_T *) _NL_CURRENT (LC_TIME,\n\t\t\t\t\t\t     NLW(ERA_D_T_FMT)))\n\t\t     != '\\0')))\n\t    subfmt = (const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(D_T_FMT));\n#else\n# if HAVE_STRFTIME\n\t  goto underlying_strftime;\n# else\n\t  subfmt = L_(\"%a %b %e %H:%M:%S %Y\");\n# endif\n#endif\n\n\tsubformat:\n\t  {\n\t    CHAR_T *old_start = p;\n\t    size_t len = my_strftime (NULL, (size_t) -1, subfmt,\n\t\t\t\t      tp ut_argument LOCALE_ARG);\n\t    add (len, my_strftime (p, maxsize - i, subfmt,\n\t\t\t\t   tp ut_argument LOCALE_ARG));\n\n\t    if (to_uppcase)\n\t      while (old_start < p)\n\t\t{\n\t\t  *old_start = TOUPPER ((UCHAR_T) *old_start, loc);\n\t\t  ++old_start;\n\t\t}\n\t  }\n\t  break;\n\n#if HAVE_STRFTIME && ! (defined _NL_CURRENT && HAVE_STRUCT_ERA_ENTRY)\n\tunderlying_strftime:\n\t  {\n\t    /* The relevant information is available only via the\n\t       underlying strftime implementation, so use that.  */\n\t    char ufmt[4];\n\t    char *u = ufmt;\n\t    char ubuf[1024]; /* enough for any single format in practice */\n\t    size_t len;\n\t    /* Make sure we're calling the actual underlying strftime.\n\t       In some cases, config.h contains something like\n\t       \"#define strftime rpl_strftime\".  */\n# ifdef strftime\n#  undef strftime\n\t    size_t strftime ();\n# endif\n\n\t    *u++ = '%';\n\t    if (modifier != 0)\n\t      *u++ = modifier;\n\t    *u++ = format_char;\n\t    *u = '\\0';\n\t    len = strftime (ubuf, sizeof ubuf, ufmt, tp);\n\t    if (len == 0 && ubuf[0] != '\\0')\n\t      return 0;\n\t    cpy (len, ubuf);\n\t  }\n\t  break;\n#endif\n\n\tcase L_('C'):\n\t  if (modifier == L_('O'))\n\t    goto bad_format;\n\t  if (modifier == L_('E'))\n\t    {\n#if HAVE_STRUCT_ERA_ENTRY\n\t      struct era_entry *era = _nl_get_era_entry (tp HELPER_LOCALE_ARG);\n\t      if (era)\n\t\t{\n# ifdef COMPILE_WIDE\n\t\t  size_t len = __wcslen (era->era_wname);\n\t\t  cpy (len, era->era_wname);\n# else\n\t\t  size_t len = strlen (era->era_name);\n\t\t  cpy (len, era->era_name);\n# endif\n\t\t  break;\n\t\t}\n#else\n# if HAVE_STRFTIME\n\t      goto underlying_strftime;\n# endif\n#endif\n\t    }\n\n\t  {\n\t    int year = tp->tm_year + TM_YEAR_BASE;\n\t    DO_NUMBER (1, year / 100 - (year % 100 < 0));\n\t  }\n\n\tcase L_('x'):\n\t  if (modifier == L_('O'))\n\t    goto bad_format;\n#ifdef _NL_CURRENT\n\t  if (! (modifier == L_('E')\n\t\t && (*(subfmt =\n\t\t       (const CHAR_T *)_NL_CURRENT (LC_TIME, NLW(ERA_D_FMT)))\n\t\t     != L_('\\0'))))\n\t    subfmt = (const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(D_FMT));\n\t  goto subformat;\n#else\n# if HAVE_STRFTIME\n\t  goto underlying_strftime;\n# else\n\t  /* Fall through.  */\n# endif\n#endif\n\tcase L_('D'):\n\t  if (modifier != 0)\n\t    goto bad_format;\n\t  subfmt = L_(\"%m/%d/%y\");\n\t  goto subformat;\n\n\tcase L_('d'):\n\t  if (modifier == L_('E'))\n\t    goto bad_format;\n\n\t  DO_NUMBER (2, tp->tm_mday);\n\n\tcase L_('e'):\n\t  if (modifier == L_('E'))\n\t    goto bad_format;\n\n\t  DO_NUMBER_SPACEPAD (2, tp->tm_mday);\n\n\t  /* All numeric formats set DIGITS and NUMBER_VALUE and then\n\t     jump to one of these two labels.  */\n\n\tdo_number_spacepad:\n\t  /* Force `_' flag unless overwritten by `0' flag.  */\n\t  if (pad != L_('0'))\n\t    pad = L_('_');\n\n\tdo_number:\n\t  /* Format the number according to the MODIFIER flag.  */\n\n\t  if (modifier == L_('O') && 0 <= number_value)\n\t    {\n#ifdef _NL_CURRENT\n\t      /* Get the locale specific alternate representation of\n\t\t the number NUMBER_VALUE.  If none exist NULL is returned.  */\n\t      const CHAR_T *cp = nl_get_alt_digit (number_value\n\t\t\t\t\t\t   HELPER_LOCALE_ARG);\n\n\t      if (cp != NULL)\n\t\t{\n\t\t  size_t digitlen = STRLEN (cp);\n\t\t  if (digitlen != 0)\n\t\t    {\n\t\t      cpy (digitlen, cp);\n\t\t      break;\n\t\t    }\n\t\t}\n#else\n# if HAVE_STRFTIME\n\t      goto underlying_strftime;\n# endif\n#endif\n\t    }\n\t  {\n\t    unsigned int u = number_value;\n\n\t    bufp = buf + sizeof (buf) / sizeof (buf[0]);\n\t    negative_number = number_value < 0;\n\n\t    if (negative_number)\n\t      u = -u;\n\n\t    do\n\t      *--bufp = u % 10 + L_('0');\n\t    while ((u /= 10) != 0);\n  \t  }\n\n\tdo_number_sign_and_padding:\n\t  if (negative_number)\n\t    *--bufp = L_('-');\n\n\t  if (pad != L_('-'))\n\t    {\n\t      int padding = digits - (buf + (sizeof (buf) / sizeof (buf[0]))\n\t\t\t\t      - bufp);\n\n\t      if (padding > 0)\n\t\t{\n\t\t  if (pad == L_('_'))\n\t\t    {\n\t\t      if ((size_t) padding >= maxsize - i)\n\t\t\treturn 0;\n\n\t\t      if (p)\n\t\t\tmemset_space (p, padding);\n\t\t      i += padding;\n\t\t      width = width > padding ? width - padding : 0;\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      if ((size_t) digits >= maxsize - i)\n\t\t\treturn 0;\n\n\t\t      if (negative_number)\n\t\t\t{\n\t\t\t  ++bufp;\n\n\t\t\t  if (p)\n\t\t\t    *p++ = L_('-');\n\t\t\t  ++i;\n\t\t\t}\n\n\t\t      if (p)\n\t\t\tmemset_zero (p, padding);\n\t\t      i += padding;\n\t\t      width = 0;\n\t\t    }\n\t\t}\n\t    }\n\n\t  cpy (buf + sizeof (buf) / sizeof (buf[0]) - bufp, bufp);\n\t  break;\n\n\tcase L_('F'):\n\t  if (modifier != 0)\n\t    goto bad_format;\n\t  subfmt = L_(\"%Y-%m-%d\");\n\t  goto subformat;\n\n\tcase L_('H'):\n\t  if (modifier == L_('E'))\n\t    goto bad_format;\n\n\t  DO_NUMBER (2, tp->tm_hour);\n\n\tcase L_('I'):\n\t  if (modifier == L_('E'))\n\t    goto bad_format;\n\n\t  DO_NUMBER (2, hour12);\n\n\tcase L_('k'):\t\t/* GNU extension.  */\n\t  if (modifier == L_('E'))\n\t    goto bad_format;\n\n\t  DO_NUMBER_SPACEPAD (2, tp->tm_hour);\n\n\tcase L_('l'):\t\t/* GNU extension.  */\n\t  if (modifier == L_('E'))\n\t    goto bad_format;\n\n\t  DO_NUMBER_SPACEPAD (2, hour12);\n\n\tcase L_('j'):\n\t  if (modifier == L_('E'))\n\t    goto bad_format;\n\n\t  DO_NUMBER (3, 1 + tp->tm_yday);\n\n\tcase L_('M'):\n\t  if (modifier == L_('E'))\n\t    goto bad_format;\n\n\t  DO_NUMBER (2, tp->tm_min);\n\n\tcase L_('m'):\n\t  if (modifier == L_('E'))\n\t    goto bad_format;\n\n\t  DO_NUMBER (2, tp->tm_mon + 1);\n\n\tcase L_('n'):\n\t  add (1, *p = L_('\\n'));\n\t  break;\n\n\tcase L_('P'):\n\t  to_lowcase = 1;\n#if !defined _NL_CURRENT && HAVE_STRFTIME\n\t  format_char = L_('p');\n#endif\n\t  /* FALLTHROUGH */\n\n\tcase L_('p'):\n\t  if (change_case)\n\t    {\n\t      to_uppcase = 0;\n\t      to_lowcase = 1;\n\t    }\n#if defined _NL_CURRENT || !HAVE_STRFTIME\n\t  cpy (ap_len, ampm);\n\t  break;\n#else\n\t  goto underlying_strftime;\n#endif\n\n\tcase L_('R'):\n\t  subfmt = L_(\"%H:%M\");\n\t  goto subformat;\n\n\tcase L_('r'):\n#ifdef _NL_CURRENT\n\t  if (*(subfmt = (const CHAR_T *) _NL_CURRENT (LC_TIME,\n\t\t\t\t\t\t       NLW(T_FMT_AMPM)))\n\t      == L_('\\0'))\n#endif\n\t    subfmt = L_(\"%I:%M:%S %p\");\n\t  goto subformat;\n\n\tcase L_('S'):\n\t  if (modifier == L_('E'))\n\t    goto bad_format;\n\n\t  DO_NUMBER (2, tp->tm_sec);\n\n\tcase L_('s'):\t\t/* GNU extension.  */\n  \t  {\n\t    struct tm ltm;\n\t    time_t t;\n\n\t    ltm = *tp;\n\t    t = mktime (&ltm);\n\n\t    /* Generate string value for T using time_t arithmetic;\n\t       this works even if sizeof (long) < sizeof (time_t).  */\n\n\t    bufp = buf + sizeof (buf) / sizeof (buf[0]);\n#ifndef TIME_T_UNSIGNED\n\t    negative_number = t < 0;\n#endif\n\n\t    do\n\t      {\n\t\tint d = t % 10;\n\t\tt /= 10;\n\n#ifndef TIME_T_UNSIGNED\n\t\tif (negative_number)\n\t\t  {\n\t\t    d = -d;\n\n\t\t    /* Adjust if division truncates to minus infinity.  */\n\t\t    if (0 < -1 % 10 && d < 0)\n\t\t      {\n\t\t\tt++;\n\t\t\td += 10;\n\t\t      }\n\t\t  }\n#endif\n\n\t\t*--bufp = d + L_('0');\n\t      }\n\t    while (t != 0);\n\n\t    digits = 1;\n\t    goto do_number_sign_and_padding;\n\t  }\n\n\tcase L_('X'):\n\t  if (modifier == L_('O'))\n\t    goto bad_format;\n#ifdef _NL_CURRENT\n\t  if (! (modifier == L_('E')\n\t\t && (*(subfmt =\n\t\t       (const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(ERA_T_FMT)))\n\t\t     != L_('\\0'))))\n\t    subfmt = (const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(T_FMT));\n\t  goto subformat;\n#else\n# if HAVE_STRFTIME\n\t  goto underlying_strftime;\n# else\n\t  /* Fall through.  */\n# endif\n#endif\n\tcase L_('T'):\n\t  subfmt = L_(\"%H:%M:%S\");\n\t  goto subformat;\n\n\tcase L_('t'):\n\t  add (1, *p = L_('\\t'));\n\t  break;\n\n\tcase L_('u'):\n\t  DO_NUMBER (1, (tp->tm_wday - 1 + 7) % 7 + 1);\n\n\tcase L_('U'):\n\t  if (modifier == L_('E'))\n\t    goto bad_format;\n\n\t  DO_NUMBER (2, (tp->tm_yday - tp->tm_wday + 7) / 7);\n\n\tcase L_('V'):\n\tcase L_('g'):\n\tcase L_('G'):\n\t  if (modifier == L_('E'))\n\t    goto bad_format;\n\t  {\n\t    int year = tp->tm_year + TM_YEAR_BASE;\n\t    int days = iso_week_days (tp->tm_yday, tp->tm_wday);\n\n\t    if (days < 0)\n\t      {\n\t\t/* This ISO week belongs to the previous year.  */\n\t\tyear--;\n\t\tdays = iso_week_days (tp->tm_yday + (365 + __isleap (year)),\n\t\t\t\t      tp->tm_wday);\n\t      }\n\t    else\n\t      {\n\t\tint d = iso_week_days (tp->tm_yday - (365 + __isleap (year)),\n\t\t\t\t       tp->tm_wday);\n\t\tif (0 <= d)\n\t\t  {\n\t\t    /* This ISO week belongs to the next year.  */\n\t\t    year++;\n\t\t    days = d;\n\t\t  }\n\t      }\n\n\t    switch (*f)\n\t      {\n\t      case L_('g'):\n\t\tDO_NUMBER (2, (year % 100 + 100) % 100);\n\n\t      case L_('G'):\n\t\tDO_NUMBER (1, year);\n\n\t      default:\n\t\tDO_NUMBER (2, days / 7 + 1);\n\t      }\n\t  }\n\n\tcase L_('W'):\n\t  if (modifier == L_('E'))\n\t    goto bad_format;\n\n\t  DO_NUMBER (2, (tp->tm_yday - (tp->tm_wday - 1 + 7) % 7 + 7) / 7);\n\n\tcase L_('w'):\n\t  if (modifier == L_('E'))\n\t    goto bad_format;\n\n\t  DO_NUMBER (1, tp->tm_wday);\n\n\tcase L_('Y'):\n\t  if (modifier == 'E')\n\t    {\n#if HAVE_STRUCT_ERA_ENTRY\n\t      struct era_entry *era = _nl_get_era_entry (tp HELPER_LOCALE_ARG);\n\t      if (era)\n\t\t{\n# ifdef COMPILE_WIDE\n\t\t  subfmt = era->era_wformat;\n# else\n\t\t  subfmt = era->era_format;\n# endif\n\t\t  goto subformat;\n\t\t}\n#else\n# if HAVE_STRFTIME\n\t      goto underlying_strftime;\n# endif\n#endif\n\t    }\n\t  if (modifier == L_('O'))\n\t    goto bad_format;\n\t  else\n\t    DO_NUMBER (1, tp->tm_year + TM_YEAR_BASE);\n\n\tcase L_('y'):\n\t  if (modifier == L_('E'))\n\t    {\n#if HAVE_STRUCT_ERA_ENTRY\n\t      struct era_entry *era = _nl_get_era_entry (tp HELPER_LOCALE_ARG);\n\t      if (era)\n\t\t{\n\t\t  int delta = tp->tm_year - era->start_date[0];\n\t\t  DO_NUMBER (1, (era->offset\n\t\t\t\t + delta * era->absolute_direction));\n\t\t}\n#else\n# if HAVE_STRFTIME\n\t      goto underlying_strftime;\n# endif\n#endif\n\t    }\n\t  DO_NUMBER (2, (tp->tm_year % 100 + 100) % 100);\n\n\tcase L_('Z'):\n\t  if (change_case)\n\t    {\n\t      to_uppcase = 0;\n\t      to_lowcase = 1;\n\t    }\n\n#if HAVE_TZNAME\n\t  /* The tzset() call might have changed the value.  */\n\t  if (!(zone && *zone) && tp->tm_isdst >= 0)\n\t    zone = tzname[tp->tm_isdst];\n#endif\n\t  if (! zone)\n\t    zone = \"\";\n\n#ifdef COMPILE_WIDE\n\t  {\n\t    /* The zone string is always given in multibyte form.  We have\n\t       to transform it first.  */\n\t    wchar_t *wczone;\n\t    size_t len;\n\t    widen (zone, wczone, len);\n\t    cpy (len, wczone);\n\t  }\n#else\n\t  cpy (strlen (zone), zone);\n#endif\n\t  break;\n\n\tcase L_('z'):\n\t  if (tp->tm_isdst < 0)\n\t    break;\n\n\t  {\n\t    int diff;\n#if HAVE_TM_GMTOFF\n\t    diff = tp->tm_gmtoff;\n#else\n\t    if (ut)\n\t      diff = 0;\n\t    else\n\t      {\n\t\tstruct tm gtm;\n\t\tstruct tm ltm;\n\t\ttime_t lt;\n\n\t\tltm = *tp;\n\t\tlt = mktime (&ltm);\n\n\t\tif (lt == (time_t) -1)\n\t\t  {\n\t\t    /* mktime returns -1 for errors, but -1 is also a\n\t\t       valid time_t value.  Check whether an error really\n\t\t       occurred.  */\n\t\t    struct tm tm;\n\n\t\t    if (! my_strftime_localtime_r (&lt, &tm)\n\t\t\t|| ((ltm.tm_sec ^ tm.tm_sec)\n\t\t\t    | (ltm.tm_min ^ tm.tm_min)\n\t\t\t    | (ltm.tm_hour ^ tm.tm_hour)\n\t\t\t    | (ltm.tm_mday ^ tm.tm_mday)\n\t\t\t    | (ltm.tm_mon ^ tm.tm_mon)\n\t\t\t    | (ltm.tm_year ^ tm.tm_year)))\n\t\t      break;\n\t\t  }\n\n\t\tif (! my_strftime_gmtime_r (&lt, &gtm))\n\t\t  break;\n\n\t\tdiff = tm_diff (&ltm, &gtm);\n\t      }\n#endif\n\n\t    if (diff < 0)\n\t      {\n\t\tadd (1, *p = L_('-'));\n\t\tdiff = -diff;\n\t      }\n\t    else\n\t      add (1, *p = L_('+'));\n\n\t    diff /= 60;\n\t    DO_NUMBER (4, (diff / 60) * 100 + diff % 60);\n\t  }\n\n\tcase L_('\\0'):\t\t/* GNU extension: % at end of format.  */\n\t    --f;\n\t    /* Fall through.  */\n\tdefault:\n\t  /* Unknown format; output the format, including the '%',\n\t     since this is most likely the right thing to do if a\n\t     multibyte string has been misparsed.  */\n\tbad_format:\n\t  {\n\t    int flen;\n\t    for (flen = 1; f[1 - flen] != L_('%'); flen++)\n\t      continue;\n\t    cpy (flen, &f[1 - flen]);\n\t  }\n\t  break;\n\t}\n    }",
        "for",
        "(",
        "f = format",
        "f",
        "=",
        "format",
        ";",
        "*f != '\\0'",
        "*f",
        "*",
        "f",
        "!=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ";",
        "++f",
        "++",
        "f",
        ")",
        "{\n      int pad = 0;\t\t/* Padding for number ('-', '_', or 0).  */\n      int modifier;\t\t/* Field modifier ('E', 'O', or 0).  */\n      int digits;\t\t/* Max digits for numeric format.  */\n      int number_value; \t/* Numeric value to be printed.  */\n      int negative_number;\t/* 1 if the number is negative.  */\n      const CHAR_T *subfmt;\n      CHAR_T *bufp;\n      CHAR_T buf[1 + (sizeof (int) < sizeof (time_t)\n\t\t      ? INT_STRLEN_BOUND (time_t)\n\t\t      : INT_STRLEN_BOUND (int))];\n      int width = -1;\n      int to_lowcase = 0;\n      int to_uppcase = 0;\n      int change_case = 0;\n      int format_char;\n\n#if DO_MULTIBYTE && !defined COMPILE_WIDE\n      switch (*f)\n\t{\n\tcase L_('%'):\n\t  break;\n\n\tcase L_('\\b'): case L_('\\t'): case L_('\\n'):\n\tcase L_('\\v'): case L_('\\f'): case L_('\\r'):\n\tcase L_(' '): case L_('!'): case L_('\"'): case L_('#'): case L_('&'):\n\tcase L_('\\''): case L_('('): case L_(')'): case L_('*'): case L_('+'):\n\tcase L_(','): case L_('-'): case L_('.'): case L_('/'): case L_('0'):\n\tcase L_('1'): case L_('2'): case L_('3'): case L_('4'): case L_('5'):\n\tcase L_('6'): case L_('7'): case L_('8'): case L_('9'): case L_(':'):\n\tcase L_(';'): case L_('<'): case L_('='): case L_('>'): case L_('?'):\n\tcase L_('A'): case L_('B'): case L_('C'): case L_('D'): case L_('E'):\n\tcase L_('F'): case L_('G'): case L_('H'): case L_('I'): case L_('J'):\n\tcase L_('K'): case L_('L'): case L_('M'): case L_('N'): case L_('O'):\n\tcase L_('P'): case L_('Q'): case L_('R'): case L_('S'): case L_('T'):\n\tcase L_('U'): case L_('V'): case L_('W'): case L_('X'): case L_('Y'):\n\tcase L_('Z'): case L_('['): case L_('\\\\'): case L_(']'): case L_('^'):\n\tcase L_('_'): case L_('a'): case L_('b'): case L_('c'): case L_('d'):\n\tcase L_('e'): case L_('f'): case L_('g'): case L_('h'): case L_('i'):\n\tcase L_('j'): case L_('k'): case L_('l'): case L_('m'): case L_('n'):\n\tcase L_('o'): case L_('p'): case L_('q'): case L_('r'): case L_('s'):\n\tcase L_('t'): case L_('u'): case L_('v'): case L_('w'): case L_('x'):\n\tcase L_('y'): case L_('z'): case L_('{'): case L_('|'): case L_('}'):\n\tcase L_('~'):\n\t  /* The C Standard requires these 98 characters (plus '%') to\n\t     be in the basic execution character set.  None of these\n\t     characters can start a multibyte sequence, so they need\n\t     not be analyzed further.  */\n\t  add (1, *p = *f);\n\t  continue;\n\n\tdefault:\n\t  /* Copy this multibyte sequence until we reach its end, find\n\t     an error, or come back to the initial shift state.  */\n\t  {\n\t    mbstate_t mbstate = mbstate_zero;\n\t    size_t len = 0;\n\t    size_t fsize;\n\n\t    if (! format_end)\n\t      format_end = f + strlen (f) + 1;\n\t    fsize = format_end - f;\n\n\t    do\n\t      {\n\t\tsize_t bytes = mbrlen (f + len, fsize - len, &mbstate);\n\n\t\tif (bytes == 0)\n\t\t  break;\n\n\t\tif (bytes == (size_t) -2)\n\t\t  {\n\t\t    len += strlen (f + len);\n\t\t    break;\n\t\t  }\n\n\t\tif (bytes == (size_t) -1)\n\t\t  {\n\t\t    len++;\n\t\t    break;\n\t\t  }\n\n\t\tlen += bytes;\n\t      }\n\t    while (! mbsinit (&mbstate));\n\n\t    cpy (len, f);\n\t    f += len - 1;\n\t    continue;\n\t  }\n\t}\n\n#else /* ! DO_MULTIBYTE */\n\n      /* Either multibyte encodings are not supported, they are\n\t safe for formats, so any non-'%' byte can be copied through,\n\t or this is the wide character version.  */\n      if (*f != L_('%'))\n\t{\n\t  add (1, *p = *f);\n\t  continue;\n\t}\n\n#endif /* ! DO_MULTIBYTE */\n\n      /* Check for flags that can modify a format.  */\n      while (1)\n\t{\n\t  switch (*++f)\n\t    {\n\t      /* This influences the number formats.  */\n\t    case L_('_'):\n\t    case L_('-'):\n\t    case L_('0'):\n\t      pad = *f;\n\t      continue;\n\n\t      /* This changes textual output.  */\n\t    case L_('^'):\n\t      to_uppcase = 1;\n\t      continue;\n\t    case L_('#'):\n\t      change_case = 1;\n\t      continue;\n\n\t    default:\n\t      break;\n\t    }\n\t  break;\n\t}\n\n      /* As a GNU extension we allow to specify the field width.  */\n      if (ISDIGIT (*f))\n\t{\n\t  width = 0;\n\t  do\n\t    {\n\t      if (width > INT_MAX / 10\n\t\t  || (width == INT_MAX / 10 && *f - L_('0') > INT_MAX % 10))\n\t\t/* Avoid overflow.  */\n\t\twidth = INT_MAX;\n\t      else\n\t\t{\n\t\t  width *= 10;\n\t\t  width += *f - L_('0');\n\t\t}\n\t      ++f;\n\t    }\n\t  while (ISDIGIT (*f));\n\t}\n\n      /* Check for modifiers.  */\n      switch (*f)\n\t{\n\tcase L_('E'):\n\tcase L_('O'):\n\t  modifier = *f++;\n\t  break;\n\n\tdefault:\n\t  modifier = 0;\n\t  break;\n\t}\n\n      /* Now do the specified format.  */\n      format_char = *f;\n      switch (format_char)\n\t{\n#define DO_NUMBER(d, v) \\\n\t  digits = d > width ? d : width;\t\t\t\t      \\\n\t  number_value = v; goto do_number\n#define DO_NUMBER_SPACEPAD(d, v) \\\n\t  digits = d > width ? d : width;\t\t\t\t      \\\n\t  number_value = v; goto do_number_spacepad\n\n\tcase L_('%'):\n\t  if (modifier != 0)\n\t    goto bad_format;\n\t  add (1, *p = *f);\n\t  break;\n\n\tcase L_('a'):\n\t  if (modifier != 0)\n\t    goto bad_format;\n\t  if (change_case)\n\t    {\n\t      to_uppcase = 1;\n\t      to_lowcase = 0;\n\t    }\n#if defined _NL_CURRENT || !HAVE_STRFTIME\n\t  cpy (aw_len, a_wkday);\n\t  break;\n#else\n\t  goto underlying_strftime;\n#endif\n\n\tcase 'A':\n\t  if (modifier != 0)\n\t    goto bad_format;\n\t  if (change_case)\n\t    {\n\t      to_uppcase = 1;\n\t      to_lowcase = 0;\n\t    }\n#if defined _NL_CURRENT || !HAVE_STRFTIME\n\t  cpy (STRLEN (f_wkday), f_wkday);\n\t  break;\n#else\n\t  goto underlying_strftime;\n#endif\n\n\tcase L_('b'):\n\tcase L_('h'):\n\t  if (change_case)\n\t    {\n\t      to_uppcase = 1;\n\t      to_lowcase = 0;\n\t    }\n\t  if (modifier != 0)\n\t    goto bad_format;\n#if defined _NL_CURRENT || !HAVE_STRFTIME\n\t  cpy (am_len, a_month);\n\t  break;\n#else\n\t  goto underlying_strftime;\n#endif\n\n\tcase L_('B'):\n\t  if (modifier != 0)\n\t    goto bad_format;\n\t  if (change_case)\n\t    {\n\t      to_uppcase = 1;\n\t      to_lowcase = 0;\n\t    }\n#if defined _NL_CURRENT || !HAVE_STRFTIME\n\t  cpy (STRLEN (f_month), f_month);\n\t  break;\n#else\n\t  goto underlying_strftime;\n#endif\n\n\tcase L_('c'):\n\t  if (modifier == L_('O'))\n\t    goto bad_format;\n#ifdef _NL_CURRENT\n\t  if (! (modifier == 'E'\n\t\t && (*(subfmt =\n\t\t       (const CHAR_T *) _NL_CURRENT (LC_TIME,\n\t\t\t\t\t\t     NLW(ERA_D_T_FMT)))\n\t\t     != '\\0')))\n\t    subfmt = (const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(D_T_FMT));\n#else\n# if HAVE_STRFTIME\n\t  goto underlying_strftime;\n# else\n\t  subfmt = L_(\"%a %b %e %H:%M:%S %Y\");\n# endif\n#endif\n\n\tsubformat:\n\t  {\n\t    CHAR_T *old_start = p;\n\t    size_t len = my_strftime (NULL, (size_t) -1, subfmt,\n\t\t\t\t      tp ut_argument LOCALE_ARG);\n\t    add (len, my_strftime (p, maxsize - i, subfmt,\n\t\t\t\t   tp ut_argument LOCALE_ARG));\n\n\t    if (to_uppcase)\n\t      while (old_start < p)\n\t\t{\n\t\t  *old_start = TOUPPER ((UCHAR_T) *old_start, loc);\n\t\t  ++old_start;\n\t\t}\n\t  }\n\t  break;\n\n#if HAVE_STRFTIME && ! (defined _NL_CURRENT && HAVE_STRUCT_ERA_ENTRY)\n\tunderlying_strftime:\n\t  {\n\t    /* The relevant information is available only via the\n\t       underlying strftime implementation, so use that.  */\n\t    char ufmt[4];\n\t    char *u = ufmt;\n\t    char ubuf[1024]; /* enough for any single format in practice */\n\t    size_t len;\n\t    /* Make sure we're calling the actual underlying strftime.\n\t       In some cases, config.h contains something like\n\t       \"#define strftime rpl_strftime\".  */\n# ifdef strftime\n#  undef strftime\n\t    size_t strftime ();\n# endif\n\n\t    *u++ = '%';\n\t    if (modifier != 0)\n\t      *u++ = modifier;\n\t    *u++ = format_char;\n\t    *u = '\\0';\n\t    len = strftime (ubuf, sizeof ubuf, ufmt, tp);\n\t    if (len == 0 && ubuf[0] != '\\0')\n\t      return 0;\n\t    cpy (len, ubuf);\n\t  }\n\t  break;\n#endif\n\n\tcase L_('C'):\n\t  if (modifier == L_('O'))\n\t    goto bad_format;\n\t  if (modifier == L_('E'))\n\t    {\n#if HAVE_STRUCT_ERA_ENTRY\n\t      struct era_entry *era = _nl_get_era_entry (tp HELPER_LOCALE_ARG);\n\t      if (era)\n\t\t{\n# ifdef COMPILE_WIDE\n\t\t  size_t len = __wcslen (era->era_wname);\n\t\t  cpy (len, era->era_wname);\n# else\n\t\t  size_t len = strlen (era->era_name);\n\t\t  cpy (len, era->era_name);\n# endif\n\t\t  break;\n\t\t}\n#else\n# if HAVE_STRFTIME\n\t      goto underlying_strftime;\n# endif\n#endif\n\t    }\n\n\t  {\n\t    int year = tp->tm_year + TM_YEAR_BASE;\n\t    DO_NUMBER (1, year / 100 - (year % 100 < 0));\n\t  }\n\n\tcase L_('x'):\n\t  if (modifier == L_('O'))\n\t    goto bad_format;\n#ifdef _NL_CURRENT\n\t  if (! (modifier == L_('E')\n\t\t && (*(subfmt =\n\t\t       (const CHAR_T *)_NL_CURRENT (LC_TIME, NLW(ERA_D_FMT)))\n\t\t     != L_('\\0'))))\n\t    subfmt = (const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(D_FMT));\n\t  goto subformat;\n#else\n# if HAVE_STRFTIME\n\t  goto underlying_strftime;\n# else\n\t  /* Fall through.  */\n# endif\n#endif\n\tcase L_('D'):\n\t  if (modifier != 0)\n\t    goto bad_format;\n\t  subfmt = L_(\"%m/%d/%y\");\n\t  goto subformat;\n\n\tcase L_('d'):\n\t  if (modifier == L_('E'))\n\t    goto bad_format;\n\n\t  DO_NUMBER (2, tp->tm_mday);\n\n\tcase L_('e'):\n\t  if (modifier == L_('E'))\n\t    goto bad_format;\n\n\t  DO_NUMBER_SPACEPAD (2, tp->tm_mday);\n\n\t  /* All numeric formats set DIGITS and NUMBER_VALUE and then\n\t     jump to one of these two labels.  */\n\n\tdo_number_spacepad:\n\t  /* Force `_' flag unless overwritten by `0' flag.  */\n\t  if (pad != L_('0'))\n\t    pad = L_('_');\n\n\tdo_number:\n\t  /* Format the number according to the MODIFIER flag.  */\n\n\t  if (modifier == L_('O') && 0 <= number_value)\n\t    {\n#ifdef _NL_CURRENT\n\t      /* Get the locale specific alternate representation of\n\t\t the number NUMBER_VALUE.  If none exist NULL is returned.  */\n\t      const CHAR_T *cp = nl_get_alt_digit (number_value\n\t\t\t\t\t\t   HELPER_LOCALE_ARG);\n\n\t      if (cp != NULL)\n\t\t{\n\t\t  size_t digitlen = STRLEN (cp);\n\t\t  if (digitlen != 0)\n\t\t    {\n\t\t      cpy (digitlen, cp);\n\t\t      break;\n\t\t    }\n\t\t}\n#else\n# if HAVE_STRFTIME\n\t      goto underlying_strftime;\n# endif\n#endif\n\t    }\n\t  {\n\t    unsigned int u = number_value;\n\n\t    bufp = buf + sizeof (buf) / sizeof (buf[0]);\n\t    negative_number = number_value < 0;\n\n\t    if (negative_number)\n\t      u = -u;\n\n\t    do\n\t      *--bufp = u % 10 + L_('0');\n\t    while ((u /= 10) != 0);\n  \t  }\n\n\tdo_number_sign_and_padding:\n\t  if (negative_number)\n\t    *--bufp = L_('-');\n\n\t  if (pad != L_('-'))\n\t    {\n\t      int padding = digits - (buf + (sizeof (buf) / sizeof (buf[0]))\n\t\t\t\t      - bufp);\n\n\t      if (padding > 0)\n\t\t{\n\t\t  if (pad == L_('_'))\n\t\t    {\n\t\t      if ((size_t) padding >= maxsize - i)\n\t\t\treturn 0;\n\n\t\t      if (p)\n\t\t\tmemset_space (p, padding);\n\t\t      i += padding;\n\t\t      width = width > padding ? width - padding : 0;\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      if ((size_t) digits >= maxsize - i)\n\t\t\treturn 0;\n\n\t\t      if (negative_number)\n\t\t\t{\n\t\t\t  ++bufp;\n\n\t\t\t  if (p)\n\t\t\t    *p++ = L_('-');\n\t\t\t  ++i;\n\t\t\t}\n\n\t\t      if (p)\n\t\t\tmemset_zero (p, padding);\n\t\t      i += padding;\n\t\t      width = 0;\n\t\t    }\n\t\t}\n\t    }\n\n\t  cpy (buf + sizeof (buf) / sizeof (buf[0]) - bufp, bufp);\n\t  break;\n\n\tcase L_('F'):\n\t  if (modifier != 0)\n\t    goto bad_format;\n\t  subfmt = L_(\"%Y-%m-%d\");\n\t  goto subformat;\n\n\tcase L_('H'):\n\t  if (modifier == L_('E'))\n\t    goto bad_format;\n\n\t  DO_NUMBER (2, tp->tm_hour);\n\n\tcase L_('I'):\n\t  if (modifier == L_('E'))\n\t    goto bad_format;\n\n\t  DO_NUMBER (2, hour12);\n\n\tcase L_('k'):\t\t/* GNU extension.  */\n\t  if (modifier == L_('E'))\n\t    goto bad_format;\n\n\t  DO_NUMBER_SPACEPAD (2, tp->tm_hour);\n\n\tcase L_('l'):\t\t/* GNU extension.  */\n\t  if (modifier == L_('E'))\n\t    goto bad_format;\n\n\t  DO_NUMBER_SPACEPAD (2, hour12);\n\n\tcase L_('j'):\n\t  if (modifier == L_('E'))\n\t    goto bad_format;\n\n\t  DO_NUMBER (3, 1 + tp->tm_yday);\n\n\tcase L_('M'):\n\t  if (modifier == L_('E'))\n\t    goto bad_format;\n\n\t  DO_NUMBER (2, tp->tm_min);\n\n\tcase L_('m'):\n\t  if (modifier == L_('E'))\n\t    goto bad_format;\n\n\t  DO_NUMBER (2, tp->tm_mon + 1);\n\n\tcase L_('n'):\n\t  add (1, *p = L_('\\n'));\n\t  break;\n\n\tcase L_('P'):\n\t  to_lowcase = 1;\n#if !defined _NL_CURRENT && HAVE_STRFTIME\n\t  format_char = L_('p');\n#endif\n\t  /* FALLTHROUGH */\n\n\tcase L_('p'):\n\t  if (change_case)\n\t    {\n\t      to_uppcase = 0;\n\t      to_lowcase = 1;\n\t    }\n#if defined _NL_CURRENT || !HAVE_STRFTIME\n\t  cpy (ap_len, ampm);\n\t  break;\n#else\n\t  goto underlying_strftime;\n#endif\n\n\tcase L_('R'):\n\t  subfmt = L_(\"%H:%M\");\n\t  goto subformat;\n\n\tcase L_('r'):\n#ifdef _NL_CURRENT\n\t  if (*(subfmt = (const CHAR_T *) _NL_CURRENT (LC_TIME,\n\t\t\t\t\t\t       NLW(T_FMT_AMPM)))\n\t      == L_('\\0'))\n#endif\n\t    subfmt = L_(\"%I:%M:%S %p\");\n\t  goto subformat;\n\n\tcase L_('S'):\n\t  if (modifier == L_('E'))\n\t    goto bad_format;\n\n\t  DO_NUMBER (2, tp->tm_sec);\n\n\tcase L_('s'):\t\t/* GNU extension.  */\n  \t  {\n\t    struct tm ltm;\n\t    time_t t;\n\n\t    ltm = *tp;\n\t    t = mktime (&ltm);\n\n\t    /* Generate string value for T using time_t arithmetic;\n\t       this works even if sizeof (long) < sizeof (time_t).  */\n\n\t    bufp = buf + sizeof (buf) / sizeof (buf[0]);\n#ifndef TIME_T_UNSIGNED\n\t    negative_number = t < 0;\n#endif\n\n\t    do\n\t      {\n\t\tint d = t % 10;\n\t\tt /= 10;\n\n#ifndef TIME_T_UNSIGNED\n\t\tif (negative_number)\n\t\t  {\n\t\t    d = -d;\n\n\t\t    /* Adjust if division truncates to minus infinity.  */\n\t\t    if (0 < -1 % 10 && d < 0)\n\t\t      {\n\t\t\tt++;\n\t\t\td += 10;\n\t\t      }\n\t\t  }\n#endif\n\n\t\t*--bufp = d + L_('0');\n\t      }\n\t    while (t != 0);\n\n\t    digits = 1;\n\t    goto do_number_sign_and_padding;\n\t  }\n\n\tcase L_('X'):\n\t  if (modifier == L_('O'))\n\t    goto bad_format;\n#ifdef _NL_CURRENT\n\t  if (! (modifier == L_('E')\n\t\t && (*(subfmt =\n\t\t       (const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(ERA_T_FMT)))\n\t\t     != L_('\\0'))))\n\t    subfmt = (const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(T_FMT));\n\t  goto subformat;\n#else\n# if HAVE_STRFTIME\n\t  goto underlying_strftime;\n# else\n\t  /* Fall through.  */\n# endif\n#endif\n\tcase L_('T'):\n\t  subfmt = L_(\"%H:%M:%S\");\n\t  goto subformat;\n\n\tcase L_('t'):\n\t  add (1, *p = L_('\\t'));\n\t  break;\n\n\tcase L_('u'):\n\t  DO_NUMBER (1, (tp->tm_wday - 1 + 7) % 7 + 1);\n\n\tcase L_('U'):\n\t  if (modifier == L_('E'))\n\t    goto bad_format;\n\n\t  DO_NUMBER (2, (tp->tm_yday - tp->tm_wday + 7) / 7);\n\n\tcase L_('V'):\n\tcase L_('g'):\n\tcase L_('G'):\n\t  if (modifier == L_('E'))\n\t    goto bad_format;\n\t  {\n\t    int year = tp->tm_year + TM_YEAR_BASE;\n\t    int days = iso_week_days (tp->tm_yday, tp->tm_wday);\n\n\t    if (days < 0)\n\t      {\n\t\t/* This ISO week belongs to the previous year.  */\n\t\tyear--;\n\t\tdays = iso_week_days (tp->tm_yday + (365 + __isleap (year)),\n\t\t\t\t      tp->tm_wday);\n\t      }\n\t    else\n\t      {\n\t\tint d = iso_week_days (tp->tm_yday - (365 + __isleap (year)),\n\t\t\t\t       tp->tm_wday);\n\t\tif (0 <= d)\n\t\t  {\n\t\t    /* This ISO week belongs to the next year.  */\n\t\t    year++;\n\t\t    days = d;\n\t\t  }\n\t      }\n\n\t    switch (*f)\n\t      {\n\t      case L_('g'):\n\t\tDO_NUMBER (2, (year % 100 + 100) % 100);\n\n\t      case L_('G'):\n\t\tDO_NUMBER (1, year);\n\n\t      default:\n\t\tDO_NUMBER (2, days / 7 + 1);\n\t      }\n\t  }\n\n\tcase L_('W'):\n\t  if (modifier == L_('E'))\n\t    goto bad_format;\n\n\t  DO_NUMBER (2, (tp->tm_yday - (tp->tm_wday - 1 + 7) % 7 + 7) / 7);\n\n\tcase L_('w'):\n\t  if (modifier == L_('E'))\n\t    goto bad_format;\n\n\t  DO_NUMBER (1, tp->tm_wday);\n\n\tcase L_('Y'):\n\t  if (modifier == 'E')\n\t    {\n#if HAVE_STRUCT_ERA_ENTRY\n\t      struct era_entry *era = _nl_get_era_entry (tp HELPER_LOCALE_ARG);\n\t      if (era)\n\t\t{\n# ifdef COMPILE_WIDE\n\t\t  subfmt = era->era_wformat;\n# else\n\t\t  subfmt = era->era_format;\n# endif\n\t\t  goto subformat;\n\t\t}\n#else\n# if HAVE_STRFTIME\n\t      goto underlying_strftime;\n# endif\n#endif\n\t    }\n\t  if (modifier == L_('O'))\n\t    goto bad_format;\n\t  else\n\t    DO_NUMBER (1, tp->tm_year + TM_YEAR_BASE);\n\n\tcase L_('y'):\n\t  if (modifier == L_('E'))\n\t    {\n#if HAVE_STRUCT_ERA_ENTRY\n\t      struct era_entry *era = _nl_get_era_entry (tp HELPER_LOCALE_ARG);\n\t      if (era)\n\t\t{\n\t\t  int delta = tp->tm_year - era->start_date[0];\n\t\t  DO_NUMBER (1, (era->offset\n\t\t\t\t + delta * era->absolute_direction));\n\t\t}\n#else\n# if HAVE_STRFTIME\n\t      goto underlying_strftime;\n# endif\n#endif\n\t    }\n\t  DO_NUMBER (2, (tp->tm_year % 100 + 100) % 100);\n\n\tcase L_('Z'):\n\t  if (change_case)\n\t    {\n\t      to_uppcase = 0;\n\t      to_lowcase = 1;\n\t    }\n\n#if HAVE_TZNAME\n\t  /* The tzset() call might have changed the value.  */\n\t  if (!(zone && *zone) && tp->tm_isdst >= 0)\n\t    zone = tzname[tp->tm_isdst];\n#endif\n\t  if (! zone)\n\t    zone = \"\";\n\n#ifdef COMPILE_WIDE\n\t  {\n\t    /* The zone string is always given in multibyte form.  We have\n\t       to transform it first.  */\n\t    wchar_t *wczone;\n\t    size_t len;\n\t    widen (zone, wczone, len);\n\t    cpy (len, wczone);\n\t  }\n#else\n\t  cpy (strlen (zone), zone);\n#endif\n\t  break;\n\n\tcase L_('z'):\n\t  if (tp->tm_isdst < 0)\n\t    break;\n\n\t  {\n\t    int diff;\n#if HAVE_TM_GMTOFF\n\t    diff = tp->tm_gmtoff;\n#else\n\t    if (ut)\n\t      diff = 0;\n\t    else\n\t      {\n\t\tstruct tm gtm;\n\t\tstruct tm ltm;\n\t\ttime_t lt;\n\n\t\tltm = *tp;\n\t\tlt = mktime (&ltm);\n\n\t\tif (lt == (time_t) -1)\n\t\t  {\n\t\t    /* mktime returns -1 for errors, but -1 is also a\n\t\t       valid time_t value.  Check whether an error really\n\t\t       occurred.  */\n\t\t    struct tm tm;\n\n\t\t    if (! my_strftime_localtime_r (&lt, &tm)\n\t\t\t|| ((ltm.tm_sec ^ tm.tm_sec)\n\t\t\t    | (ltm.tm_min ^ tm.tm_min)\n\t\t\t    | (ltm.tm_hour ^ tm.tm_hour)\n\t\t\t    | (ltm.tm_mday ^ tm.tm_mday)\n\t\t\t    | (ltm.tm_mon ^ tm.tm_mon)\n\t\t\t    | (ltm.tm_year ^ tm.tm_year)))\n\t\t      break;\n\t\t  }\n\n\t\tif (! my_strftime_gmtime_r (&lt, &gtm))\n\t\t  break;\n\n\t\tdiff = tm_diff (&ltm, &gtm);\n\t      }\n#endif\n\n\t    if (diff < 0)\n\t      {\n\t\tadd (1, *p = L_('-'));\n\t\tdiff = -diff;\n\t      }\n\t    else\n\t      add (1, *p = L_('+'));\n\n\t    diff /= 60;\n\t    DO_NUMBER (4, (diff / 60) * 100 + diff % 60);\n\t  }\n\n\tcase L_('\\0'):\t\t/* GNU extension: % at end of format.  */\n\t    --f;\n\t    /* Fall through.  */\n\tdefault:\n\t  /* Unknown format; output the format, including the '%',\n\t     since this is most likely the right thing to do if a\n\t     multibyte string has been misparsed.  */\n\tbad_format:\n\t  {\n\t    int flen;\n\t    for (flen = 1; f[1 - flen] != L_('%'); flen++)\n\t      continue;\n\t    cpy (flen, &f[1 - flen]);\n\t  }\n\t  break;\n\t}\n    }",
        "{",
        "int pad = 0;",
        "int",
        "pad = 0",
        "pad",
        "=",
        "0",
        ";",
        "/* Padding for number ('-', '_', or 0).  */",
        "int modifier;",
        "int",
        "modifier",
        ";",
        "/* Field modifier ('E', 'O', or 0).  */",
        "int digits;",
        "int",
        "digits",
        ";",
        "/* Max digits for numeric format.  */",
        "int number_value;",
        "int",
        "number_value",
        ";",
        "/* Numeric value to be printed.  */",
        "int negative_number;",
        "int",
        "negative_number",
        ";",
        "/* 1 if the number is negative.  */",
        "const CHAR_T *subfmt;",
        "const",
        "const",
        "CHAR_T",
        "*subfmt",
        "*",
        "subfmt",
        ";",
        "CHAR_T *bufp;",
        "CHAR_T",
        "*bufp",
        "*",
        "bufp",
        ";",
        "CHAR_T buf[1 + (sizeof (int) < sizeof (time_t)\n\t\t      ? INT_STRLEN_BOUND (time_t)\n\t\t      : INT_STRLEN_BOUND (int))];",
        "CHAR_T",
        "buf[1 + (sizeof (int) < sizeof (time_t)\n\t\t      ? INT_STRLEN_BOUND (time_t)\n\t\t      : INT_STRLEN_BOUND (int))]",
        "buf",
        "[",
        "1 + (sizeof (int) < sizeof (time_t)\n\t\t      ? INT_STRLEN_BOUND (time_t)\n\t\t      : INT_STRLEN_BOUND (int))",
        "1",
        "+",
        "(sizeof (int) < sizeof (time_t)\n\t\t      ? INT_STRLEN_BOUND (time_t)\n\t\t      : INT_STRLEN_BOUND (int))",
        "(",
        "sizeof (int) < sizeof (time_t)\n\t\t      ? INT_STRLEN_BOUND (time_t)\n\t\t      : INT_STRLEN_BOUND (int)",
        "sizeof (int) < sizeof (time_t)",
        "sizeof (int)",
        "sizeof",
        "(",
        "int",
        "int",
        ")",
        "<",
        "sizeof (time_t)",
        "sizeof",
        "(time_t)",
        "(",
        "time_t",
        ")",
        "?",
        "INT_STRLEN_BOUND (time_t)",
        "INT_STRLEN_BOUND",
        "(time_t)",
        "(",
        "time_t",
        ")",
        ":",
        "INT_STRLEN_BOUND (int)",
        "INT_STRLEN_BOUND",
        "(int)",
        "(",
        "int",
        ")",
        ")",
        "]",
        ";",
        "int width = -1;",
        "int",
        "width = -1",
        "width",
        "=",
        "-1",
        ";",
        "int to_lowcase = 0;",
        "int",
        "to_lowcase = 0",
        "to_lowcase",
        "=",
        "0",
        ";",
        "int to_uppcase = 0;",
        "int",
        "to_uppcase = 0",
        "to_uppcase",
        "=",
        "0",
        ";",
        "int change_case = 0;",
        "int",
        "change_case = 0",
        "change_case",
        "=",
        "0",
        ";",
        "int format_char;",
        "int",
        "format_char",
        ";",
        "#if DO_MULTIBYTE && !defined COMPILE_WIDE\n      switch (*f)\n\t{\n\tcase L_('%'):\n\t  break;\n\n\tcase L_('\\b'): case L_('\\t'): case L_('\\n'):\n\tcase L_('\\v'): case L_('\\f'): case L_('\\r'):\n\tcase L_(' '): case L_('!'): case L_('\"'): case L_('#'): case L_('&'):\n\tcase L_('\\''): case L_('('): case L_(')'): case L_('*'): case L_('+'):\n\tcase L_(','): case L_('-'): case L_('.'): case L_('/'): case L_('0'):\n\tcase L_('1'): case L_('2'): case L_('3'): case L_('4'): case L_('5'):\n\tcase L_('6'): case L_('7'): case L_('8'): case L_('9'): case L_(':'):\n\tcase L_(';'): case L_('<'): case L_('='): case L_('>'): case L_('?'):\n\tcase L_('A'): case L_('B'): case L_('C'): case L_('D'): case L_('E'):\n\tcase L_('F'): case L_('G'): case L_('H'): case L_('I'): case L_('J'):\n\tcase L_('K'): case L_('L'): case L_('M'): case L_('N'): case L_('O'):\n\tcase L_('P'): case L_('Q'): case L_('R'): case L_('S'): case L_('T'):\n\tcase L_('U'): case L_('V'): case L_('W'): case L_('X'): case L_('Y'):\n\tcase L_('Z'): case L_('['): case L_('\\\\'): case L_(']'): case L_('^'):\n\tcase L_('_'): case L_('a'): case L_('b'): case L_('c'): case L_('d'):\n\tcase L_('e'): case L_('f'): case L_('g'): case L_('h'): case L_('i'):\n\tcase L_('j'): case L_('k'): case L_('l'): case L_('m'): case L_('n'):\n\tcase L_('o'): case L_('p'): case L_('q'): case L_('r'): case L_('s'):\n\tcase L_('t'): case L_('u'): case L_('v'): case L_('w'): case L_('x'):\n\tcase L_('y'): case L_('z'): case L_('{'): case L_('|'): case L_('}'):\n\tcase L_('~'):\n\t  /* The C Standard requires these 98 characters (plus '%') to\n\t     be in the basic execution character set.  None of these\n\t     characters can start a multibyte sequence, so they need\n\t     not be analyzed further.  */\n\t  add (1, *p = *f);\n\t  continue;\n\n\tdefault:\n\t  /* Copy this multibyte sequence until we reach its end, find\n\t     an error, or come back to the initial shift state.  */\n\t  {\n\t    mbstate_t mbstate = mbstate_zero;\n\t    size_t len = 0;\n\t    size_t fsize;\n\n\t    if (! format_end)\n\t      format_end = f + strlen (f) + 1;\n\t    fsize = format_end - f;\n\n\t    do\n\t      {\n\t\tsize_t bytes = mbrlen (f + len, fsize - len, &mbstate);\n\n\t\tif (bytes == 0)\n\t\t  break;\n\n\t\tif (bytes == (size_t) -2)\n\t\t  {\n\t\t    len += strlen (f + len);\n\t\t    break;\n\t\t  }\n\n\t\tif (bytes == (size_t) -1)\n\t\t  {\n\t\t    len++;\n\t\t    break;\n\t\t  }\n\n\t\tlen += bytes;\n\t      }\n\t    while (! mbsinit (&mbstate));\n\n\t    cpy (len, f);\n\t    f += len - 1;\n\t    continue;\n\t  }\n\t}\n\n#else /* ! DO_MULTIBYTE */\n\n      /* Either multibyte encodings are not supported, they are\n\t safe for formats, so any non-'%' byte can be copied through,\n\t or this is the wide character version.  */\n      if (*f != L_('%'))\n\t{\n\t  add (1, *p = *f);\n\t  continue;\n\t}\n\n#endif",
        "#if",
        "DO_MULTIBYTE && !defined COMPILE_WIDE",
        "DO_MULTIBYTE",
        "&&",
        "!defined COMPILE_WIDE",
        "!",
        "defined COMPILE_WIDE",
        "defined",
        "COMPILE_WIDE",
        "\n",
        "switch (*f)\n\t{\n\tcase L_('%'):\n\t  break;\n\n\tcase L_('\\b'): case L_('\\t'): case L_('\\n'):\n\tcase L_('\\v'): case L_('\\f'): case L_('\\r'):\n\tcase L_(' '): case L_('!'): case L_('\"'): case L_('#'): case L_('&'):\n\tcase L_('\\''): case L_('('): case L_(')'): case L_('*'): case L_('+'):\n\tcase L_(','): case L_('-'): case L_('.'): case L_('/'): case L_('0'):\n\tcase L_('1'): case L_('2'): case L_('3'): case L_('4'): case L_('5'):\n\tcase L_('6'): case L_('7'): case L_('8'): case L_('9'): case L_(':'):\n\tcase L_(';'): case L_('<'): case L_('='): case L_('>'): case L_('?'):\n\tcase L_('A'): case L_('B'): case L_('C'): case L_('D'): case L_('E'):\n\tcase L_('F'): case L_('G'): case L_('H'): case L_('I'): case L_('J'):\n\tcase L_('K'): case L_('L'): case L_('M'): case L_('N'): case L_('O'):\n\tcase L_('P'): case L_('Q'): case L_('R'): case L_('S'): case L_('T'):\n\tcase L_('U'): case L_('V'): case L_('W'): case L_('X'): case L_('Y'):\n\tcase L_('Z'): case L_('['): case L_('\\\\'): case L_(']'): case L_('^'):\n\tcase L_('_'): case L_('a'): case L_('b'): case L_('c'): case L_('d'):\n\tcase L_('e'): case L_('f'): case L_('g'): case L_('h'): case L_('i'):\n\tcase L_('j'): case L_('k'): case L_('l'): case L_('m'): case L_('n'):\n\tcase L_('o'): case L_('p'): case L_('q'): case L_('r'): case L_('s'):\n\tcase L_('t'): case L_('u'): case L_('v'): case L_('w'): case L_('x'):\n\tcase L_('y'): case L_('z'): case L_('{'): case L_('|'): case L_('}'):\n\tcase L_('~'):\n\t  /* The C Standard requires these 98 characters (plus '%') to\n\t     be in the basic execution character set.  None of these\n\t     characters can start a multibyte sequence, so they need\n\t     not be analyzed further.  */\n\t  add (1, *p = *f);\n\t  continue;\n\n\tdefault:\n\t  /* Copy this multibyte sequence until we reach its end, find\n\t     an error, or come back to the initial shift state.  */\n\t  {\n\t    mbstate_t mbstate = mbstate_zero;\n\t    size_t len = 0;\n\t    size_t fsize;\n\n\t    if (! format_end)\n\t      format_end = f + strlen (f) + 1;\n\t    fsize = format_end - f;\n\n\t    do\n\t      {\n\t\tsize_t bytes = mbrlen (f + len, fsize - len, &mbstate);\n\n\t\tif (bytes == 0)\n\t\t  break;\n\n\t\tif (bytes == (size_t) -2)\n\t\t  {\n\t\t    len += strlen (f + len);\n\t\t    break;\n\t\t  }\n\n\t\tif (bytes == (size_t) -1)\n\t\t  {\n\t\t    len++;\n\t\t    break;\n\t\t  }\n\n\t\tlen += bytes;\n\t      }\n\t    while (! mbsinit (&mbstate));\n\n\t    cpy (len, f);\n\t    f += len - 1;\n\t    continue;\n\t  }\n\t}",
        "switch",
        "(*f)",
        "(",
        "*f",
        "*",
        "f",
        ")",
        "{\n\tcase L_('%'):\n\t  break;\n\n\tcase L_('\\b'): case L_('\\t'): case L_('\\n'):\n\tcase L_('\\v'): case L_('\\f'): case L_('\\r'):\n\tcase L_(' '): case L_('!'): case L_('\"'): case L_('#'): case L_('&'):\n\tcase L_('\\''): case L_('('): case L_(')'): case L_('*'): case L_('+'):\n\tcase L_(','): case L_('-'): case L_('.'): case L_('/'): case L_('0'):\n\tcase L_('1'): case L_('2'): case L_('3'): case L_('4'): case L_('5'):\n\tcase L_('6'): case L_('7'): case L_('8'): case L_('9'): case L_(':'):\n\tcase L_(';'): case L_('<'): case L_('='): case L_('>'): case L_('?'):\n\tcase L_('A'): case L_('B'): case L_('C'): case L_('D'): case L_('E'):\n\tcase L_('F'): case L_('G'): case L_('H'): case L_('I'): case L_('J'):\n\tcase L_('K'): case L_('L'): case L_('M'): case L_('N'): case L_('O'):\n\tcase L_('P'): case L_('Q'): case L_('R'): case L_('S'): case L_('T'):\n\tcase L_('U'): case L_('V'): case L_('W'): case L_('X'): case L_('Y'):\n\tcase L_('Z'): case L_('['): case L_('\\\\'): case L_(']'): case L_('^'):\n\tcase L_('_'): case L_('a'): case L_('b'): case L_('c'): case L_('d'):\n\tcase L_('e'): case L_('f'): case L_('g'): case L_('h'): case L_('i'):\n\tcase L_('j'): case L_('k'): case L_('l'): case L_('m'): case L_('n'):\n\tcase L_('o'): case L_('p'): case L_('q'): case L_('r'): case L_('s'):\n\tcase L_('t'): case L_('u'): case L_('v'): case L_('w'): case L_('x'):\n\tcase L_('y'): case L_('z'): case L_('{'): case L_('|'): case L_('}'):\n\tcase L_('~'):\n\t  /* The C Standard requires these 98 characters (plus '%') to\n\t     be in the basic execution character set.  None of these\n\t     characters can start a multibyte sequence, so they need\n\t     not be analyzed further.  */\n\t  add (1, *p = *f);\n\t  continue;\n\n\tdefault:\n\t  /* Copy this multibyte sequence until we reach its end, find\n\t     an error, or come back to the initial shift state.  */\n\t  {\n\t    mbstate_t mbstate = mbstate_zero;\n\t    size_t len = 0;\n\t    size_t fsize;\n\n\t    if (! format_end)\n\t      format_end = f + strlen (f) + 1;\n\t    fsize = format_end - f;\n\n\t    do\n\t      {\n\t\tsize_t bytes = mbrlen (f + len, fsize - len, &mbstate);\n\n\t\tif (bytes == 0)\n\t\t  break;\n\n\t\tif (bytes == (size_t) -2)\n\t\t  {\n\t\t    len += strlen (f + len);\n\t\t    break;\n\t\t  }\n\n\t\tif (bytes == (size_t) -1)\n\t\t  {\n\t\t    len++;\n\t\t    break;\n\t\t  }\n\n\t\tlen += bytes;\n\t      }\n\t    while (! mbsinit (&mbstate));\n\n\t    cpy (len, f);\n\t    f += len - 1;\n\t    continue;\n\t  }\n\t}",
        "{",
        "case L_('%'):\n\t  break;",
        "case",
        "L_('%')",
        "L_",
        "('%')",
        "(",
        "'%'",
        "'",
        "'",
        ")",
        ":",
        "break;",
        "break",
        ";",
        "case L_('\\b'):",
        "case",
        "L_('\\b')",
        "L_",
        "('\\b')",
        "(",
        "'\\b'",
        "'",
        "\\b",
        "'",
        ")",
        ":",
        "case L_('\\t'):",
        "case",
        "L_('\\t')",
        "L_",
        "('\\t')",
        "(",
        "'\\t'",
        "'",
        "\\t",
        "'",
        ")",
        ":",
        "case L_('\\n'):",
        "case",
        "L_('\\n')",
        "L_",
        "('\\n')",
        "(",
        "'\\n'",
        "'",
        "\\n",
        "'",
        ")",
        ":",
        "case L_('\\v'):",
        "case",
        "L_('\\v')",
        "L_",
        "('\\v')",
        "(",
        "'\\v'",
        "'",
        "\\v",
        "'",
        ")",
        ":",
        "case L_('\\f'):",
        "case",
        "L_('\\f')",
        "L_",
        "('\\f')",
        "(",
        "'\\f'",
        "'",
        "\\f",
        "'",
        ")",
        ":",
        "case L_('\\r'):",
        "case",
        "L_('\\r')",
        "L_",
        "('\\r')",
        "(",
        "'\\r'",
        "'",
        "\\r",
        "'",
        ")",
        ":",
        "case L_(' '):",
        "case",
        "L_(' ')",
        "L_",
        "(' ')",
        "(",
        "' '",
        "'",
        "'",
        ")",
        ":",
        "case L_('!'):",
        "case",
        "L_('!')",
        "L_",
        "('!')",
        "(",
        "'!'",
        "'",
        "'",
        ")",
        ":",
        "case L_('\"'):",
        "case",
        "L_('\"')",
        "L_",
        "('\"')",
        "(",
        "'\"'",
        "'",
        "'",
        ")",
        ":",
        "case L_('#'):",
        "case",
        "L_('#')",
        "L_",
        "('#')",
        "(",
        "'#'",
        "'",
        "'",
        ")",
        ":",
        "case L_('&'):",
        "case",
        "L_('&')",
        "L_",
        "('&')",
        "(",
        "'&'",
        "'",
        "'",
        ")",
        ":",
        "case L_('\\''):",
        "case",
        "L_('\\'')",
        "L_",
        "('\\'')",
        "(",
        "'\\''",
        "'",
        "\\'",
        "'",
        ")",
        ":",
        "case L_('('):",
        "case",
        "L_('(')",
        "L_",
        "('(')",
        "(",
        "'('",
        "'",
        "'",
        ")",
        ":",
        "case L_(')'):",
        "case",
        "L_(')')",
        "L_",
        "(')')",
        "(",
        "')'",
        "'",
        "'",
        ")",
        ":",
        "case L_('*'):",
        "case",
        "L_('*')",
        "L_",
        "('*')",
        "(",
        "'*'",
        "'",
        "'",
        ")",
        ":",
        "case L_('+'):",
        "case",
        "L_('+')",
        "L_",
        "('+')",
        "(",
        "'+'",
        "'",
        "'",
        ")",
        ":",
        "case L_(','):",
        "case",
        "L_(',')",
        "L_",
        "(',')",
        "(",
        "','",
        "'",
        "'",
        ")",
        ":",
        "case L_('-'):",
        "case",
        "L_('-')",
        "L_",
        "('-')",
        "(",
        "'-'",
        "'",
        "'",
        ")",
        ":",
        "case L_('.'):",
        "case",
        "L_('.')",
        "L_",
        "('.')",
        "(",
        "'.'",
        "'",
        "'",
        ")",
        ":",
        "case L_('/'):",
        "case",
        "L_('/')",
        "L_",
        "('/')",
        "(",
        "'/'",
        "'",
        "'",
        ")",
        ":",
        "case L_('0'):",
        "case",
        "L_('0')",
        "L_",
        "('0')",
        "(",
        "'0'",
        "'",
        "'",
        ")",
        ":",
        "case L_('1'):",
        "case",
        "L_('1')",
        "L_",
        "('1')",
        "(",
        "'1'",
        "'",
        "'",
        ")",
        ":",
        "case L_('2'):",
        "case",
        "L_('2')",
        "L_",
        "('2')",
        "(",
        "'2'",
        "'",
        "'",
        ")",
        ":",
        "case L_('3'):",
        "case",
        "L_('3')",
        "L_",
        "('3')",
        "(",
        "'3'",
        "'",
        "'",
        ")",
        ":",
        "case L_('4'):",
        "case",
        "L_('4')",
        "L_",
        "('4')",
        "(",
        "'4'",
        "'",
        "'",
        ")",
        ":",
        "case L_('5'):",
        "case",
        "L_('5')",
        "L_",
        "('5')",
        "(",
        "'5'",
        "'",
        "'",
        ")",
        ":",
        "case L_('6'):",
        "case",
        "L_('6')",
        "L_",
        "('6')",
        "(",
        "'6'",
        "'",
        "'",
        ")",
        ":",
        "case L_('7'):",
        "case",
        "L_('7')",
        "L_",
        "('7')",
        "(",
        "'7'",
        "'",
        "'",
        ")",
        ":",
        "case L_('8'):",
        "case",
        "L_('8')",
        "L_",
        "('8')",
        "(",
        "'8'",
        "'",
        "'",
        ")",
        ":",
        "case L_('9'):",
        "case",
        "L_('9')",
        "L_",
        "('9')",
        "(",
        "'9'",
        "'",
        "'",
        ")",
        ":",
        "case L_(':'):",
        "case",
        "L_(':')",
        "L_",
        "(':')",
        "(",
        "':'",
        "'",
        "'",
        ")",
        ":",
        "case L_(';'):",
        "case",
        "L_(';')",
        "L_",
        "(';')",
        "(",
        "';'",
        "'",
        "'",
        ")",
        ":",
        "case L_('<'):",
        "case",
        "L_('<')",
        "L_",
        "('<')",
        "(",
        "'<'",
        "'",
        "'",
        ")",
        ":",
        "case L_('='):",
        "case",
        "L_('=')",
        "L_",
        "('=')",
        "(",
        "'='",
        "'",
        "'",
        ")",
        ":",
        "case L_('>'):",
        "case",
        "L_('>')",
        "L_",
        "('>')",
        "(",
        "'>'",
        "'",
        "'",
        ")",
        ":",
        "case L_('?'):",
        "case",
        "L_('?')",
        "L_",
        "('?')",
        "(",
        "'?'",
        "'",
        "'",
        ")",
        ":",
        "case L_('A'):",
        "case",
        "L_('A')",
        "L_",
        "('A')",
        "(",
        "'A'",
        "'",
        "'",
        ")",
        ":",
        "case L_('B'):",
        "case",
        "L_('B')",
        "L_",
        "('B')",
        "(",
        "'B'",
        "'",
        "'",
        ")",
        ":",
        "case L_('C'):",
        "case",
        "L_('C')",
        "L_",
        "('C')",
        "(",
        "'C'",
        "'",
        "'",
        ")",
        ":",
        "case L_('D'):",
        "case",
        "L_('D')",
        "L_",
        "('D')",
        "(",
        "'D'",
        "'",
        "'",
        ")",
        ":",
        "case L_('E'):",
        "case",
        "L_('E')",
        "L_",
        "('E')",
        "(",
        "'E'",
        "'",
        "'",
        ")",
        ":",
        "case L_('F'):",
        "case",
        "L_('F')",
        "L_",
        "('F')",
        "(",
        "'F'",
        "'",
        "'",
        ")",
        ":",
        "case L_('G'):",
        "case",
        "L_('G')",
        "L_",
        "('G')",
        "(",
        "'G'",
        "'",
        "'",
        ")",
        ":",
        "case L_('H'):",
        "case",
        "L_('H')",
        "L_",
        "('H')",
        "(",
        "'H'",
        "'",
        "'",
        ")",
        ":",
        "case L_('I'):",
        "case",
        "L_('I')",
        "L_",
        "('I')",
        "(",
        "'I'",
        "'",
        "'",
        ")",
        ":",
        "case L_('J'):",
        "case",
        "L_('J')",
        "L_",
        "('J')",
        "(",
        "'J'",
        "'",
        "'",
        ")",
        ":",
        "case L_('K'):",
        "case",
        "L_('K')",
        "L_",
        "('K')",
        "(",
        "'K'",
        "'",
        "'",
        ")",
        ":",
        "case L_('L'):",
        "case",
        "L_('L')",
        "L_",
        "('L')",
        "(",
        "'L'",
        "'",
        "'",
        ")",
        ":",
        "case L_('M'):",
        "case",
        "L_('M')",
        "L_",
        "('M')",
        "(",
        "'M'",
        "'",
        "'",
        ")",
        ":",
        "case L_('N'):",
        "case",
        "L_('N')",
        "L_",
        "('N')",
        "(",
        "'N'",
        "'",
        "'",
        ")",
        ":",
        "case L_('O'):",
        "case",
        "L_('O')",
        "L_",
        "('O')",
        "(",
        "'O'",
        "'",
        "'",
        ")",
        ":",
        "case L_('P'):",
        "case",
        "L_('P')",
        "L_",
        "('P')",
        "(",
        "'P'",
        "'",
        "'",
        ")",
        ":",
        "case L_('Q'):",
        "case",
        "L_('Q')",
        "L_",
        "('Q')",
        "(",
        "'Q'",
        "'",
        "'",
        ")",
        ":",
        "case L_('R'):",
        "case",
        "L_('R')",
        "L_",
        "('R')",
        "(",
        "'R'",
        "'",
        "'",
        ")",
        ":",
        "case L_('S'):",
        "case",
        "L_('S')",
        "L_",
        "('S')",
        "(",
        "'S'",
        "'",
        "'",
        ")",
        ":",
        "case L_('T'):",
        "case",
        "L_('T')",
        "L_",
        "('T')",
        "(",
        "'T'",
        "'",
        "'",
        ")",
        ":",
        "case L_('U'):",
        "case",
        "L_('U')",
        "L_",
        "('U')",
        "(",
        "'U'",
        "'",
        "'",
        ")",
        ":",
        "case L_('V'):",
        "case",
        "L_('V')",
        "L_",
        "('V')",
        "(",
        "'V'",
        "'",
        "'",
        ")",
        ":",
        "case L_('W'):",
        "case",
        "L_('W')",
        "L_",
        "('W')",
        "(",
        "'W'",
        "'",
        "'",
        ")",
        ":",
        "case L_('X'):",
        "case",
        "L_('X')",
        "L_",
        "('X')",
        "(",
        "'X'",
        "'",
        "'",
        ")",
        ":",
        "case L_('Y'):",
        "case",
        "L_('Y')",
        "L_",
        "('Y')",
        "(",
        "'Y'",
        "'",
        "'",
        ")",
        ":",
        "case L_('Z'):",
        "case",
        "L_('Z')",
        "L_",
        "('Z')",
        "(",
        "'Z'",
        "'",
        "'",
        ")",
        ":",
        "case L_('['):",
        "case",
        "L_('[')",
        "L_",
        "('[')",
        "(",
        "'['",
        "'",
        "'",
        ")",
        ":",
        "case L_('\\\\'):",
        "case",
        "L_('\\\\')",
        "L_",
        "('\\\\')",
        "(",
        "'\\\\'",
        "'",
        "\\\\",
        "'",
        ")",
        ":",
        "case L_(']'):",
        "case",
        "L_(']')",
        "L_",
        "(']')",
        "(",
        "']'",
        "'",
        "'",
        ")",
        ":",
        "case L_('^'):",
        "case",
        "L_('^')",
        "L_",
        "('^')",
        "(",
        "'^'",
        "'",
        "'",
        ")",
        ":",
        "case L_('_'):",
        "case",
        "L_('_')",
        "L_",
        "('_')",
        "(",
        "'_'",
        "'",
        "'",
        ")",
        ":",
        "case L_('a'):",
        "case",
        "L_('a')",
        "L_",
        "('a')",
        "(",
        "'a'",
        "'",
        "'",
        ")",
        ":",
        "case L_('b'):",
        "case",
        "L_('b')",
        "L_",
        "('b')",
        "(",
        "'b'",
        "'",
        "'",
        ")",
        ":",
        "case L_('c'):",
        "case",
        "L_('c')",
        "L_",
        "('c')",
        "(",
        "'c'",
        "'",
        "'",
        ")",
        ":",
        "case L_('d'):",
        "case",
        "L_('d')",
        "L_",
        "('d')",
        "(",
        "'d'",
        "'",
        "'",
        ")",
        ":",
        "case L_('e'):",
        "case",
        "L_('e')",
        "L_",
        "('e')",
        "(",
        "'e'",
        "'",
        "'",
        ")",
        ":",
        "case L_('f'):",
        "case",
        "L_('f')",
        "L_",
        "('f')",
        "(",
        "'f'",
        "'",
        "'",
        ")",
        ":",
        "case L_('g'):",
        "case",
        "L_('g')",
        "L_",
        "('g')",
        "(",
        "'g'",
        "'",
        "'",
        ")",
        ":",
        "case L_('h'):",
        "case",
        "L_('h')",
        "L_",
        "('h')",
        "(",
        "'h'",
        "'",
        "'",
        ")",
        ":",
        "case L_('i'):",
        "case",
        "L_('i')",
        "L_",
        "('i')",
        "(",
        "'i'",
        "'",
        "'",
        ")",
        ":",
        "case L_('j'):",
        "case",
        "L_('j')",
        "L_",
        "('j')",
        "(",
        "'j'",
        "'",
        "'",
        ")",
        ":",
        "case L_('k'):",
        "case",
        "L_('k')",
        "L_",
        "('k')",
        "(",
        "'k'",
        "'",
        "'",
        ")",
        ":",
        "case L_('l'):",
        "case",
        "L_('l')",
        "L_",
        "('l')",
        "(",
        "'l'",
        "'",
        "'",
        ")",
        ":",
        "case L_('m'):",
        "case",
        "L_('m')",
        "L_",
        "('m')",
        "(",
        "'m'",
        "'",
        "'",
        ")",
        ":",
        "case L_('n'):",
        "case",
        "L_('n')",
        "L_",
        "('n')",
        "(",
        "'n'",
        "'",
        "'",
        ")",
        ":",
        "case L_('o'):",
        "case",
        "L_('o')",
        "L_",
        "('o')",
        "(",
        "'o'",
        "'",
        "'",
        ")",
        ":",
        "case L_('p'):",
        "case",
        "L_('p')",
        "L_",
        "('p')",
        "(",
        "'p'",
        "'",
        "'",
        ")",
        ":",
        "case L_('q'):",
        "case",
        "L_('q')",
        "L_",
        "('q')",
        "(",
        "'q'",
        "'",
        "'",
        ")",
        ":",
        "case L_('r'):",
        "case",
        "L_('r')",
        "L_",
        "('r')",
        "(",
        "'r'",
        "'",
        "'",
        ")",
        ":",
        "case L_('s'):",
        "case",
        "L_('s')",
        "L_",
        "('s')",
        "(",
        "'s'",
        "'",
        "'",
        ")",
        ":",
        "case L_('t'):",
        "case",
        "L_('t')",
        "L_",
        "('t')",
        "(",
        "'t'",
        "'",
        "'",
        ")",
        ":",
        "case L_('u'):",
        "case",
        "L_('u')",
        "L_",
        "('u')",
        "(",
        "'u'",
        "'",
        "'",
        ")",
        ":",
        "case L_('v'):",
        "case",
        "L_('v')",
        "L_",
        "('v')",
        "(",
        "'v'",
        "'",
        "'",
        ")",
        ":",
        "case L_('w'):",
        "case",
        "L_('w')",
        "L_",
        "('w')",
        "(",
        "'w'",
        "'",
        "'",
        ")",
        ":",
        "case L_('x'):",
        "case",
        "L_('x')",
        "L_",
        "('x')",
        "(",
        "'x'",
        "'",
        "'",
        ")",
        ":",
        "case L_('y'):",
        "case",
        "L_('y')",
        "L_",
        "('y')",
        "(",
        "'y'",
        "'",
        "'",
        ")",
        ":",
        "case L_('z'):",
        "case",
        "L_('z')",
        "L_",
        "('z')",
        "(",
        "'z'",
        "'",
        "'",
        ")",
        ":",
        "case L_('{'):",
        "case",
        "L_('{')",
        "L_",
        "('{')",
        "(",
        "'{'",
        "'",
        "'",
        ")",
        ":",
        "case L_('|'):",
        "case",
        "L_('|')",
        "L_",
        "('|')",
        "(",
        "'|'",
        "'",
        "'",
        ")",
        ":",
        "case L_('}'):",
        "case",
        "L_('}')",
        "L_",
        "('}')",
        "(",
        "'}'",
        "'",
        "'",
        ")",
        ":",
        "case L_('~'):\n\t  /* The C Standard requires these 98 characters (plus '%') to\n\t     be in the basic execution character set.  None of these\n\t     characters can start a multibyte sequence, so they need\n\t     not be analyzed further.  */\n\t  add (1, *p = *f);\n\t  continue;",
        "case",
        "L_('~')",
        "L_",
        "('~')",
        "(",
        "'~'",
        "'",
        "'",
        ")",
        ":",
        "/* The C Standard requires these 98 characters (plus '%') to\n\t     be in the basic execution character set.  None of these\n\t     characters can start a multibyte sequence, so they need\n\t     not be analyzed further.  */",
        "add (1, *p = *f);",
        "add (1, *p = *f)",
        "add",
        "(1, *p = *f)",
        "(",
        "1",
        ",",
        "*p = *f",
        "*p",
        "*",
        "p",
        "=",
        "*f",
        "*",
        "f",
        ")",
        ";",
        "continue;",
        "continue",
        ";",
        "default:\n\t  /* Copy this multibyte sequence until we reach its end, find\n\t     an error, or come back to the initial shift state.  */\n\t  {\n\t    mbstate_t mbstate = mbstate_zero;\n\t    size_t len = 0;\n\t    size_t fsize;\n\n\t    if (! format_end)\n\t      format_end = f + strlen (f) + 1;\n\t    fsize = format_end - f;\n\n\t    do\n\t      {\n\t\tsize_t bytes = mbrlen (f + len, fsize - len, &mbstate);\n\n\t\tif (bytes == 0)\n\t\t  break;\n\n\t\tif (bytes == (size_t) -2)\n\t\t  {\n\t\t    len += strlen (f + len);\n\t\t    break;\n\t\t  }\n\n\t\tif (bytes == (size_t) -1)\n\t\t  {\n\t\t    len++;\n\t\t    break;\n\t\t  }\n\n\t\tlen += bytes;\n\t      }\n\t    while (! mbsinit (&mbstate));\n\n\t    cpy (len, f);\n\t    f += len - 1;\n\t    continue;\n\t  }",
        "default",
        ":",
        "/* Copy this multibyte sequence until we reach its end, find\n\t     an error, or come back to the initial shift state.  */",
        "{\n\t    mbstate_t mbstate = mbstate_zero;\n\t    size_t len = 0;\n\t    size_t fsize;\n\n\t    if (! format_end)\n\t      format_end = f + strlen (f) + 1;\n\t    fsize = format_end - f;\n\n\t    do\n\t      {\n\t\tsize_t bytes = mbrlen (f + len, fsize - len, &mbstate);\n\n\t\tif (bytes == 0)\n\t\t  break;\n\n\t\tif (bytes == (size_t) -2)\n\t\t  {\n\t\t    len += strlen (f + len);\n\t\t    break;\n\t\t  }\n\n\t\tif (bytes == (size_t) -1)\n\t\t  {\n\t\t    len++;\n\t\t    break;\n\t\t  }\n\n\t\tlen += bytes;\n\t      }\n\t    while (! mbsinit (&mbstate));\n\n\t    cpy (len, f);\n\t    f += len - 1;\n\t    continue;\n\t  }",
        "{",
        "mbstate_t mbstate = mbstate_zero;",
        "mbstate_t",
        "mbstate = mbstate_zero",
        "mbstate",
        "=",
        "mbstate_zero",
        ";",
        "size_t len = 0;",
        "size_t",
        "len = 0",
        "len",
        "=",
        "0",
        ";",
        "size_t fsize;",
        "size_t",
        "fsize",
        ";",
        "if (! format_end)\n\t      format_end = f + strlen (f) + 1;",
        "if",
        "(! format_end)",
        "(",
        "! format_end",
        "!",
        "format_end",
        ")",
        "format_end = f + strlen (f) + 1;",
        "format_end = f + strlen (f) + 1",
        "format_end",
        "=",
        "f + strlen (f) + 1",
        "f + strlen (f)",
        "f",
        "+",
        "strlen (f)",
        "strlen",
        "(f)",
        "(",
        "f",
        ")",
        "+",
        "1",
        ";",
        "fsize = format_end - f;",
        "fsize = format_end - f",
        "fsize",
        "=",
        "format_end - f",
        "format_end",
        "-",
        "f",
        ";",
        "do\n\t      {\n\t\tsize_t bytes = mbrlen (f + len, fsize - len, &mbstate);\n\n\t\tif (bytes == 0)\n\t\t  break;\n\n\t\tif (bytes == (size_t) -2)\n\t\t  {\n\t\t    len += strlen (f + len);\n\t\t    break;\n\t\t  }\n\n\t\tif (bytes == (size_t) -1)\n\t\t  {\n\t\t    len++;\n\t\t    break;\n\t\t  }\n\n\t\tlen += bytes;\n\t      }\n\t    while (! mbsinit (&mbstate));",
        "do",
        "{\n\t\tsize_t bytes = mbrlen (f + len, fsize - len, &mbstate);\n\n\t\tif (bytes == 0)\n\t\t  break;\n\n\t\tif (bytes == (size_t) -2)\n\t\t  {\n\t\t    len += strlen (f + len);\n\t\t    break;\n\t\t  }\n\n\t\tif (bytes == (size_t) -1)\n\t\t  {\n\t\t    len++;\n\t\t    break;\n\t\t  }\n\n\t\tlen += bytes;\n\t      }",
        "{",
        "size_t bytes = mbrlen (f + len, fsize - len, &mbstate);",
        "size_t",
        "bytes = mbrlen (f + len, fsize - len, &mbstate)",
        "bytes",
        "=",
        "mbrlen (f + len, fsize - len, &mbstate)",
        "mbrlen",
        "(f + len, fsize - len, &mbstate)",
        "(",
        "f + len",
        "f",
        "+",
        "len",
        ",",
        "fsize - len",
        "fsize",
        "-",
        "len",
        ",",
        "&mbstate",
        "&",
        "mbstate",
        ")",
        ";",
        "if (bytes == 0)\n\t\t  break;",
        "if",
        "(bytes == 0)",
        "(",
        "bytes == 0",
        "bytes",
        "==",
        "0",
        ")",
        "break;",
        "break",
        ";",
        "if (bytes == (size_t) -2)\n\t\t  {\n\t\t    len += strlen (f + len);\n\t\t    break;\n\t\t  }",
        "if",
        "(bytes == (size_t) -2)",
        "(",
        "bytes == (size_t) -2",
        "bytes",
        "==",
        "(size_t) -2",
        "(",
        "size_t",
        "size_t",
        ")",
        "-2",
        ")",
        "{\n\t\t    len += strlen (f + len);\n\t\t    break;\n\t\t  }",
        "{",
        "len += strlen (f + len);",
        "len += strlen (f + len)",
        "len",
        "+=",
        "strlen (f + len)",
        "strlen",
        "(f + len)",
        "(",
        "f + len",
        "f",
        "+",
        "len",
        ")",
        ";",
        "break;",
        "break",
        ";",
        "}",
        "if (bytes == (size_t) -1)\n\t\t  {\n\t\t    len++;\n\t\t    break;\n\t\t  }",
        "if",
        "(bytes == (size_t) -1)",
        "(",
        "bytes == (size_t) -1",
        "bytes",
        "==",
        "(size_t) -1",
        "(",
        "size_t",
        "size_t",
        ")",
        "-1",
        ")",
        "{\n\t\t    len++;\n\t\t    break;\n\t\t  }",
        "{",
        "len++;",
        "len++",
        "len",
        "++",
        ";",
        "break;",
        "break",
        ";",
        "}",
        "len += bytes;",
        "len += bytes",
        "len",
        "+=",
        "bytes",
        ";",
        "}",
        "while",
        "(! mbsinit (&mbstate))",
        "(",
        "! mbsinit (&mbstate)",
        "!",
        "mbsinit (&mbstate)",
        "mbsinit",
        "(&mbstate)",
        "(",
        "&mbstate",
        "&",
        "mbstate",
        ")",
        ")",
        ";",
        "cpy (len, f);",
        "cpy (len, f)",
        "cpy",
        "(len, f)",
        "(",
        "len",
        ",",
        "f",
        ")",
        ";",
        "f += len - 1;",
        "f += len - 1",
        "f",
        "+=",
        "len - 1",
        "len",
        "-",
        "1",
        ";",
        "continue;",
        "continue",
        ";",
        "}",
        "}",
        "#else /* ! DO_MULTIBYTE */\n\n      /* Either multibyte encodings are not supported, they are\n\t safe for formats, so any non-'%' byte can be copied through,\n\t or this is the wide character version.  */\n      if (*f != L_('%'))\n\t{\n\t  add (1, *p = *f);\n\t  continue;\n\t}",
        "#else",
        "/* ! DO_MULTIBYTE */",
        "/* Either multibyte encodings are not supported, they are\n\t safe for formats, so any non-'%' byte can be copied through,\n\t or this is the wide character version.  */",
        "if (*f != L_('%'))\n\t{\n\t  add (1, *p = *f);\n\t  continue;\n\t}",
        "if",
        "(*f != L_('%'))",
        "(",
        "*f != L_('%')",
        "*f",
        "*",
        "f",
        "!=",
        "L_('%')",
        "L_",
        "('%')",
        "(",
        "'%'",
        "'",
        "'",
        ")",
        ")",
        "{\n\t  add (1, *p = *f);\n\t  continue;\n\t}",
        "{",
        "add (1, *p = *f);",
        "add (1, *p = *f)",
        "add",
        "(1, *p = *f)",
        "(",
        "1",
        ",",
        "*p = *f",
        "*p",
        "*",
        "p",
        "=",
        "*f",
        "*",
        "f",
        ")",
        ";",
        "continue;",
        "continue",
        ";",
        "}",
        "#endif",
        "/* ! DO_MULTIBYTE */",
        "/* Check for flags that can modify a format.  */",
        "while (1)\n\t{\n\t  switch (*++f)\n\t    {\n\t      /* This influences the number formats.  */\n\t    case L_('_'):\n\t    case L_('-'):\n\t    case L_('0'):\n\t      pad = *f;\n\t      continue;\n\n\t      /* This changes textual output.  */\n\t    case L_('^'):\n\t      to_uppcase = 1;\n\t      continue;\n\t    case L_('#'):\n\t      change_case = 1;\n\t      continue;\n\n\t    default:\n\t      break;\n\t    }\n\t  break;\n\t}",
        "while",
        "(1)",
        "(",
        "1",
        ")",
        "{\n\t  switch (*++f)\n\t    {\n\t      /* This influences the number formats.  */\n\t    case L_('_'):\n\t    case L_('-'):\n\t    case L_('0'):\n\t      pad = *f;\n\t      continue;\n\n\t      /* This changes textual output.  */\n\t    case L_('^'):\n\t      to_uppcase = 1;\n\t      continue;\n\t    case L_('#'):\n\t      change_case = 1;\n\t      continue;\n\n\t    default:\n\t      break;\n\t    }\n\t  break;\n\t}",
        "{",
        "switch (*++f)\n\t    {\n\t      /* This influences the number formats.  */\n\t    case L_('_'):\n\t    case L_('-'):\n\t    case L_('0'):\n\t      pad = *f;\n\t      continue;\n\n\t      /* This changes textual output.  */\n\t    case L_('^'):\n\t      to_uppcase = 1;\n\t      continue;\n\t    case L_('#'):\n\t      change_case = 1;\n\t      continue;\n\n\t    default:\n\t      break;\n\t    }",
        "switch",
        "(*++f)",
        "(",
        "*++f",
        "*",
        "++f",
        "++",
        "f",
        ")",
        "{\n\t      /* This influences the number formats.  */\n\t    case L_('_'):\n\t    case L_('-'):\n\t    case L_('0'):\n\t      pad = *f;\n\t      continue;\n\n\t      /* This changes textual output.  */\n\t    case L_('^'):\n\t      to_uppcase = 1;\n\t      continue;\n\t    case L_('#'):\n\t      change_case = 1;\n\t      continue;\n\n\t    default:\n\t      break;\n\t    }",
        "{",
        "/* This influences the number formats.  */",
        "case L_('_'):",
        "case",
        "L_('_')",
        "L_",
        "('_')",
        "(",
        "'_'",
        "'",
        "'",
        ")",
        ":",
        "case L_('-'):",
        "case",
        "L_('-')",
        "L_",
        "('-')",
        "(",
        "'-'",
        "'",
        "'",
        ")",
        ":",
        "case L_('0'):\n\t      pad = *f;\n\t      continue;",
        "case",
        "L_('0')",
        "L_",
        "('0')",
        "(",
        "'0'",
        "'",
        "'",
        ")",
        ":",
        "pad = *f;",
        "pad = *f",
        "pad",
        "=",
        "*f",
        "*",
        "f",
        ";",
        "continue;",
        "continue",
        ";",
        "/* This changes textual output.  */",
        "case L_('^'):\n\t      to_uppcase = 1;\n\t      continue;",
        "case",
        "L_('^')",
        "L_",
        "('^')",
        "(",
        "'^'",
        "'",
        "'",
        ")",
        ":",
        "to_uppcase = 1;",
        "to_uppcase = 1",
        "to_uppcase",
        "=",
        "1",
        ";",
        "continue;",
        "continue",
        ";",
        "case L_('#'):\n\t      change_case = 1;\n\t      continue;",
        "case",
        "L_('#')",
        "L_",
        "('#')",
        "(",
        "'#'",
        "'",
        "'",
        ")",
        ":",
        "change_case = 1;",
        "change_case = 1",
        "change_case",
        "=",
        "1",
        ";",
        "continue;",
        "continue",
        ";",
        "default:\n\t      break;",
        "default",
        ":",
        "break;",
        "break",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "}",
        "/* As a GNU extension we allow to specify the field width.  */",
        "if (ISDIGIT (*f))\n\t{\n\t  width = 0;\n\t  do\n\t    {\n\t      if (width > INT_MAX / 10\n\t\t  || (width == INT_MAX / 10 && *f - L_('0') > INT_MAX % 10))\n\t\t/* Avoid overflow.  */\n\t\twidth = INT_MAX;\n\t      else\n\t\t{\n\t\t  width *= 10;\n\t\t  width += *f - L_('0');\n\t\t}\n\t      ++f;\n\t    }\n\t  while (ISDIGIT (*f));\n\t}",
        "if",
        "(ISDIGIT (*f))",
        "(",
        "ISDIGIT (*f)",
        "ISDIGIT",
        "(*f)",
        "(",
        "*f",
        "*",
        "f",
        ")",
        ")",
        "{\n\t  width = 0;\n\t  do\n\t    {\n\t      if (width > INT_MAX / 10\n\t\t  || (width == INT_MAX / 10 && *f - L_('0') > INT_MAX % 10))\n\t\t/* Avoid overflow.  */\n\t\twidth = INT_MAX;\n\t      else\n\t\t{\n\t\t  width *= 10;\n\t\t  width += *f - L_('0');\n\t\t}\n\t      ++f;\n\t    }\n\t  while (ISDIGIT (*f));\n\t}",
        "{",
        "width = 0;",
        "width = 0",
        "width",
        "=",
        "0",
        ";",
        "do\n\t    {\n\t      if (width > INT_MAX / 10\n\t\t  || (width == INT_MAX / 10 && *f - L_('0') > INT_MAX % 10))\n\t\t/* Avoid overflow.  */\n\t\twidth = INT_MAX;\n\t      else\n\t\t{\n\t\t  width *= 10;\n\t\t  width += *f - L_('0');\n\t\t}\n\t      ++f;\n\t    }\n\t  while (ISDIGIT (*f));",
        "do",
        "{\n\t      if (width > INT_MAX / 10\n\t\t  || (width == INT_MAX / 10 && *f - L_('0') > INT_MAX % 10))\n\t\t/* Avoid overflow.  */\n\t\twidth = INT_MAX;\n\t      else\n\t\t{\n\t\t  width *= 10;\n\t\t  width += *f - L_('0');\n\t\t}\n\t      ++f;\n\t    }",
        "{",
        "if (width > INT_MAX / 10\n\t\t  || (width == INT_MAX / 10 && *f - L_('0') > INT_MAX % 10))\n\t\t/* Avoid overflow.  */\n\t\twidth = INT_MAX;\n\t      else\n\t\t{\n\t\t  width *= 10;\n\t\t  width += *f - L_('0');\n\t\t}",
        "if",
        "(width > INT_MAX / 10\n\t\t  || (width == INT_MAX / 10 && *f - L_('0') > INT_MAX % 10))",
        "(",
        "width > INT_MAX / 10\n\t\t  || (width == INT_MAX / 10 && *f - L_('0') > INT_MAX % 10)",
        "width > INT_MAX / 10",
        "width",
        ">",
        "INT_MAX / 10",
        "INT_MAX",
        "/",
        "10",
        "||",
        "(width == INT_MAX / 10 && *f - L_('0') > INT_MAX % 10)",
        "(",
        "width == INT_MAX / 10 && *f - L_('0') > INT_MAX % 10",
        "width == INT_MAX / 10",
        "width",
        "==",
        "INT_MAX / 10",
        "INT_MAX",
        "/",
        "10",
        "&&",
        "*f - L_('0') > INT_MAX % 10",
        "*f - L_('0')",
        "*f",
        "*",
        "f",
        "-",
        "L_('0')",
        "L_",
        "('0')",
        "(",
        "'0'",
        "'",
        "'",
        ")",
        ">",
        "INT_MAX % 10",
        "INT_MAX",
        "%",
        "10",
        ")",
        ")",
        "/* Avoid overflow.  */",
        "width = INT_MAX;",
        "width = INT_MAX",
        "width",
        "=",
        "INT_MAX",
        ";",
        "else",
        "{\n\t\t  width *= 10;\n\t\t  width += *f - L_('0');\n\t\t}",
        "{",
        "width *= 10;",
        "width *= 10",
        "width",
        "*=",
        "10",
        ";",
        "width += *f - L_('0');",
        "width += *f - L_('0')",
        "width",
        "+=",
        "*f - L_('0')",
        "*f",
        "*",
        "f",
        "-",
        "L_('0')",
        "L_",
        "('0')",
        "(",
        "'0'",
        "'",
        "'",
        ")",
        ";",
        "}",
        "++f;",
        "++f",
        "++",
        "f",
        ";",
        "}",
        "while",
        "(ISDIGIT (*f))",
        "(",
        "ISDIGIT (*f)",
        "ISDIGIT",
        "(*f)",
        "(",
        "*f",
        "*",
        "f",
        ")",
        ")",
        ";",
        "}",
        "/* Check for modifiers.  */",
        "switch (*f)\n\t{\n\tcase L_('E'):\n\tcase L_('O'):\n\t  modifier = *f++;\n\t  break;\n\n\tdefault:\n\t  modifier = 0;\n\t  break;\n\t}",
        "switch",
        "(*f)",
        "(",
        "*f",
        "*",
        "f",
        ")",
        "{\n\tcase L_('E'):\n\tcase L_('O'):\n\t  modifier = *f++;\n\t  break;\n\n\tdefault:\n\t  modifier = 0;\n\t  break;\n\t}",
        "{",
        "case L_('E'):",
        "case",
        "L_('E')",
        "L_",
        "('E')",
        "(",
        "'E'",
        "'",
        "'",
        ")",
        ":",
        "case L_('O'):\n\t  modifier = *f++;\n\t  break;",
        "case",
        "L_('O')",
        "L_",
        "('O')",
        "(",
        "'O'",
        "'",
        "'",
        ")",
        ":",
        "modifier = *f++;",
        "modifier = *f++",
        "modifier",
        "=",
        "*f++",
        "*",
        "f++",
        "f",
        "++",
        ";",
        "break;",
        "break",
        ";",
        "default:\n\t  modifier = 0;\n\t  break;",
        "default",
        ":",
        "modifier = 0;",
        "modifier = 0",
        "modifier",
        "=",
        "0",
        ";",
        "break;",
        "break",
        ";",
        "}",
        "/* Now do the specified format.  */",
        "format_char = *f;",
        "format_char = *f",
        "format_char",
        "=",
        "*f",
        "*",
        "f",
        ";",
        "switch (format_char)\n\t{\n#define DO_NUMBER(d, v) \\\n\t  digits = d > width ? d : width;\t\t\t\t      \\\n\t  number_value = v; goto do_number\n#define DO_NUMBER_SPACEPAD(d, v) \\\n\t  digits = d > width ? d : width;\t\t\t\t      \\\n\t  number_value = v; goto do_number_spacepad\n\n\tcase L_('%'):\n\t  if (modifier != 0)\n\t    goto bad_format;\n\t  add (1, *p = *f);\n\t  break;\n\n\tcase L_('a'):\n\t  if (modifier != 0)\n\t    goto bad_format;\n\t  if (change_case)\n\t    {\n\t      to_uppcase = 1;\n\t      to_lowcase = 0;\n\t    }\n#if defined _NL_CURRENT || !HAVE_STRFTIME\n\t  cpy (aw_len, a_wkday);\n\t  break;\n#else\n\t  goto underlying_strftime;\n#endif\n\n\tcase 'A':\n\t  if (modifier != 0)\n\t    goto bad_format;\n\t  if (change_case)\n\t    {\n\t      to_uppcase = 1;\n\t      to_lowcase = 0;\n\t    }\n#if defined _NL_CURRENT || !HAVE_STRFTIME\n\t  cpy (STRLEN (f_wkday), f_wkday);\n\t  break;\n#else\n\t  goto underlying_strftime;\n#endif\n\n\tcase L_('b'):\n\tcase L_('h'):\n\t  if (change_case)\n\t    {\n\t      to_uppcase = 1;\n\t      to_lowcase = 0;\n\t    }\n\t  if (modifier != 0)\n\t    goto bad_format;\n#if defined _NL_CURRENT || !HAVE_STRFTIME\n\t  cpy (am_len, a_month);\n\t  break;\n#else\n\t  goto underlying_strftime;\n#endif\n\n\tcase L_('B'):\n\t  if (modifier != 0)\n\t    goto bad_format;\n\t  if (change_case)\n\t    {\n\t      to_uppcase = 1;\n\t      to_lowcase = 0;\n\t    }\n#if defined _NL_CURRENT || !HAVE_STRFTIME\n\t  cpy (STRLEN (f_month), f_month);\n\t  break;\n#else\n\t  goto underlying_strftime;\n#endif\n\n\tcase L_('c'):\n\t  if (modifier == L_('O'))\n\t    goto bad_format;\n#ifdef _NL_CURRENT\n\t  if (! (modifier == 'E'\n\t\t && (*(subfmt =\n\t\t       (const CHAR_T *) _NL_CURRENT (LC_TIME,\n\t\t\t\t\t\t     NLW(ERA_D_T_FMT)))\n\t\t     != '\\0')))\n\t    subfmt = (const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(D_T_FMT));\n#else\n# if HAVE_STRFTIME\n\t  goto underlying_strftime;\n# else\n\t  subfmt = L_(\"%a %b %e %H:%M:%S %Y\");\n# endif\n#endif\n\n\tsubformat:\n\t  {\n\t    CHAR_T *old_start = p;\n\t    size_t len = my_strftime (NULL, (size_t) -1, subfmt,\n\t\t\t\t      tp ut_argument LOCALE_ARG);\n\t    add (len, my_strftime (p, maxsize - i, subfmt,\n\t\t\t\t   tp ut_argument LOCALE_ARG));\n\n\t    if (to_uppcase)\n\t      while (old_start < p)\n\t\t{\n\t\t  *old_start = TOUPPER ((UCHAR_T) *old_start, loc);\n\t\t  ++old_start;\n\t\t}\n\t  }\n\t  break;\n\n#if HAVE_STRFTIME && ! (defined _NL_CURRENT && HAVE_STRUCT_ERA_ENTRY)\n\tunderlying_strftime:\n\t  {\n\t    /* The relevant information is available only via the\n\t       underlying strftime implementation, so use that.  */\n\t    char ufmt[4];\n\t    char *u = ufmt;\n\t    char ubuf[1024]; /* enough for any single format in practice */\n\t    size_t len;\n\t    /* Make sure we're calling the actual underlying strftime.\n\t       In some cases, config.h contains something like\n\t       \"#define strftime rpl_strftime\".  */\n# ifdef strftime\n#  undef strftime\n\t    size_t strftime ();\n# endif\n\n\t    *u++ = '%';\n\t    if (modifier != 0)\n\t      *u++ = modifier;\n\t    *u++ = format_char;\n\t    *u = '\\0';\n\t    len = strftime (ubuf, sizeof ubuf, ufmt, tp);\n\t    if (len == 0 && ubuf[0] != '\\0')\n\t      return 0;\n\t    cpy (len, ubuf);\n\t  }\n\t  break;\n#endif\n\n\tcase L_('C'):\n\t  if (modifier == L_('O'))\n\t    goto bad_format;\n\t  if (modifier == L_('E'))\n\t    {\n#if HAVE_STRUCT_ERA_ENTRY\n\t      struct era_entry *era = _nl_get_era_entry (tp HELPER_LOCALE_ARG);\n\t      if (era)\n\t\t{\n# ifdef COMPILE_WIDE\n\t\t  size_t len = __wcslen (era->era_wname);\n\t\t  cpy (len, era->era_wname);\n# else\n\t\t  size_t len = strlen (era->era_name);\n\t\t  cpy (len, era->era_name);\n# endif\n\t\t  break;\n\t\t}\n#else\n# if HAVE_STRFTIME\n\t      goto underlying_strftime;\n# endif\n#endif\n\t    }\n\n\t  {\n\t    int year = tp->tm_year + TM_YEAR_BASE;\n\t    DO_NUMBER (1, year / 100 - (year % 100 < 0));\n\t  }\n\n\tcase L_('x'):\n\t  if (modifier == L_('O'))\n\t    goto bad_format;\n#ifdef _NL_CURRENT\n\t  if (! (modifier == L_('E')\n\t\t && (*(subfmt =\n\t\t       (const CHAR_T *)_NL_CURRENT (LC_TIME, NLW(ERA_D_FMT)))\n\t\t     != L_('\\0'))))\n\t    subfmt = (const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(D_FMT));\n\t  goto subformat;\n#else\n# if HAVE_STRFTIME\n\t  goto underlying_strftime;\n# else\n\t  /* Fall through.  */\n# endif\n#endif\n\tcase L_('D'):\n\t  if (modifier != 0)\n\t    goto bad_format;\n\t  subfmt = L_(\"%m/%d/%y\");\n\t  goto subformat;\n\n\tcase L_('d'):\n\t  if (modifier == L_('E'))\n\t    goto bad_format;\n\n\t  DO_NUMBER (2, tp->tm_mday);\n\n\tcase L_('e'):\n\t  if (modifier == L_('E'))\n\t    goto bad_format;\n\n\t  DO_NUMBER_SPACEPAD (2, tp->tm_mday);\n\n\t  /* All numeric formats set DIGITS and NUMBER_VALUE and then\n\t     jump to one of these two labels.  */\n\n\tdo_number_spacepad:\n\t  /* Force `_' flag unless overwritten by `0' flag.  */\n\t  if (pad != L_('0'))\n\t    pad = L_('_');\n\n\tdo_number:\n\t  /* Format the number according to the MODIFIER flag.  */\n\n\t  if (modifier == L_('O') && 0 <= number_value)\n\t    {\n#ifdef _NL_CURRENT\n\t      /* Get the locale specific alternate representation of\n\t\t the number NUMBER_VALUE.  If none exist NULL is returned.  */\n\t      const CHAR_T *cp = nl_get_alt_digit (number_value\n\t\t\t\t\t\t   HELPER_LOCALE_ARG);\n\n\t      if (cp != NULL)\n\t\t{\n\t\t  size_t digitlen = STRLEN (cp);\n\t\t  if (digitlen != 0)\n\t\t    {\n\t\t      cpy (digitlen, cp);\n\t\t      break;\n\t\t    }\n\t\t}\n#else\n# if HAVE_STRFTIME\n\t      goto underlying_strftime;\n# endif\n#endif\n\t    }\n\t  {\n\t    unsigned int u = number_value;\n\n\t    bufp = buf + sizeof (buf) / sizeof (buf[0]);\n\t    negative_number = number_value < 0;\n\n\t    if (negative_number)\n\t      u = -u;\n\n\t    do\n\t      *--bufp = u % 10 + L_('0');\n\t    while ((u /= 10) != 0);\n  \t  }\n\n\tdo_number_sign_and_padding:\n\t  if (negative_number)\n\t    *--bufp = L_('-');\n\n\t  if (pad != L_('-'))\n\t    {\n\t      int padding = digits - (buf + (sizeof (buf) / sizeof (buf[0]))\n\t\t\t\t      - bufp);\n\n\t      if (padding > 0)\n\t\t{\n\t\t  if (pad == L_('_'))\n\t\t    {\n\t\t      if ((size_t) padding >= maxsize - i)\n\t\t\treturn 0;\n\n\t\t      if (p)\n\t\t\tmemset_space (p, padding);\n\t\t      i += padding;\n\t\t      width = width > padding ? width - padding : 0;\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      if ((size_t) digits >= maxsize - i)\n\t\t\treturn 0;\n\n\t\t      if (negative_number)\n\t\t\t{\n\t\t\t  ++bufp;\n\n\t\t\t  if (p)\n\t\t\t    *p++ = L_('-');\n\t\t\t  ++i;\n\t\t\t}\n\n\t\t      if (p)\n\t\t\tmemset_zero (p, padding);\n\t\t      i += padding;\n\t\t      width = 0;\n\t\t    }\n\t\t}\n\t    }\n\n\t  cpy (buf + sizeof (buf) / sizeof (buf[0]) - bufp, bufp);\n\t  break;\n\n\tcase L_('F'):\n\t  if (modifier != 0)\n\t    goto bad_format;\n\t  subfmt = L_(\"%Y-%m-%d\");\n\t  goto subformat;\n\n\tcase L_('H'):\n\t  if (modifier == L_('E'))\n\t    goto bad_format;\n\n\t  DO_NUMBER (2, tp->tm_hour);\n\n\tcase L_('I'):\n\t  if (modifier == L_('E'))\n\t    goto bad_format;\n\n\t  DO_NUMBER (2, hour12);\n\n\tcase L_('k'):\t\t/* GNU extension.  */\n\t  if (modifier == L_('E'))\n\t    goto bad_format;\n\n\t  DO_NUMBER_SPACEPAD (2, tp->tm_hour);\n\n\tcase L_('l'):\t\t/* GNU extension.  */\n\t  if (modifier == L_('E'))\n\t    goto bad_format;\n\n\t  DO_NUMBER_SPACEPAD (2, hour12);\n\n\tcase L_('j'):\n\t  if (modifier == L_('E'))\n\t    goto bad_format;\n\n\t  DO_NUMBER (3, 1 + tp->tm_yday);\n\n\tcase L_('M'):\n\t  if (modifier == L_('E'))\n\t    goto bad_format;\n\n\t  DO_NUMBER (2, tp->tm_min);\n\n\tcase L_('m'):\n\t  if (modifier == L_('E'))\n\t    goto bad_format;\n\n\t  DO_NUMBER (2, tp->tm_mon + 1);\n\n\tcase L_('n'):\n\t  add (1, *p = L_('\\n'));\n\t  break;\n\n\tcase L_('P'):\n\t  to_lowcase = 1;\n#if !defined _NL_CURRENT && HAVE_STRFTIME\n\t  format_char = L_('p');\n#endif\n\t  /* FALLTHROUGH */\n\n\tcase L_('p'):\n\t  if (change_case)\n\t    {\n\t      to_uppcase = 0;\n\t      to_lowcase = 1;\n\t    }\n#if defined _NL_CURRENT || !HAVE_STRFTIME\n\t  cpy (ap_len, ampm);\n\t  break;\n#else\n\t  goto underlying_strftime;\n#endif\n\n\tcase L_('R'):\n\t  subfmt = L_(\"%H:%M\");\n\t  goto subformat;\n\n\tcase L_('r'):\n#ifdef _NL_CURRENT\n\t  if (*(subfmt = (const CHAR_T *) _NL_CURRENT (LC_TIME,\n\t\t\t\t\t\t       NLW(T_FMT_AMPM)))\n\t      == L_('\\0'))\n#endif\n\t    subfmt = L_(\"%I:%M:%S %p\");\n\t  goto subformat;\n\n\tcase L_('S'):\n\t  if (modifier == L_('E'))\n\t    goto bad_format;\n\n\t  DO_NUMBER (2, tp->tm_sec);\n\n\tcase L_('s'):\t\t/* GNU extension.  */\n  \t  {\n\t    struct tm ltm;\n\t    time_t t;\n\n\t    ltm = *tp;\n\t    t = mktime (&ltm);\n\n\t    /* Generate string value for T using time_t arithmetic;\n\t       this works even if sizeof (long) < sizeof (time_t).  */\n\n\t    bufp = buf + sizeof (buf) / sizeof (buf[0]);\n#ifndef TIME_T_UNSIGNED\n\t    negative_number = t < 0;\n#endif\n\n\t    do\n\t      {\n\t\tint d = t % 10;\n\t\tt /= 10;\n\n#ifndef TIME_T_UNSIGNED\n\t\tif (negative_number)\n\t\t  {\n\t\t    d = -d;\n\n\t\t    /* Adjust if division truncates to minus infinity.  */\n\t\t    if (0 < -1 % 10 && d < 0)\n\t\t      {\n\t\t\tt++;\n\t\t\td += 10;\n\t\t      }\n\t\t  }\n#endif\n\n\t\t*--bufp = d + L_('0');\n\t      }\n\t    while (t != 0);\n\n\t    digits = 1;\n\t    goto do_number_sign_and_padding;\n\t  }\n\n\tcase L_('X'):\n\t  if (modifier == L_('O'))\n\t    goto bad_format;\n#ifdef _NL_CURRENT\n\t  if (! (modifier == L_('E')\n\t\t && (*(subfmt =\n\t\t       (const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(ERA_T_FMT)))\n\t\t     != L_('\\0'))))\n\t    subfmt = (const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(T_FMT));\n\t  goto subformat;\n#else\n# if HAVE_STRFTIME\n\t  goto underlying_strftime;\n# else\n\t  /* Fall through.  */\n# endif\n#endif\n\tcase L_('T'):\n\t  subfmt = L_(\"%H:%M:%S\");\n\t  goto subformat;\n\n\tcase L_('t'):\n\t  add (1, *p = L_('\\t'));\n\t  break;\n\n\tcase L_('u'):\n\t  DO_NUMBER (1, (tp->tm_wday - 1 + 7) % 7 + 1);\n\n\tcase L_('U'):\n\t  if (modifier == L_('E'))\n\t    goto bad_format;\n\n\t  DO_NUMBER (2, (tp->tm_yday - tp->tm_wday + 7) / 7);\n\n\tcase L_('V'):\n\tcase L_('g'):\n\tcase L_('G'):\n\t  if (modifier == L_('E'))\n\t    goto bad_format;\n\t  {\n\t    int year = tp->tm_year + TM_YEAR_BASE;\n\t    int days = iso_week_days (tp->tm_yday, tp->tm_wday);\n\n\t    if (days < 0)\n\t      {\n\t\t/* This ISO week belongs to the previous year.  */\n\t\tyear--;\n\t\tdays = iso_week_days (tp->tm_yday + (365 + __isleap (year)),\n\t\t\t\t      tp->tm_wday);\n\t      }\n\t    else\n\t      {\n\t\tint d = iso_week_days (tp->tm_yday - (365 + __isleap (year)),\n\t\t\t\t       tp->tm_wday);\n\t\tif (0 <= d)\n\t\t  {\n\t\t    /* This ISO week belongs to the next year.  */\n\t\t    year++;\n\t\t    days = d;\n\t\t  }\n\t      }\n\n\t    switch (*f)\n\t      {\n\t      case L_('g'):\n\t\tDO_NUMBER (2, (year % 100 + 100) % 100);\n\n\t      case L_('G'):\n\t\tDO_NUMBER (1, year);\n\n\t      default:\n\t\tDO_NUMBER (2, days / 7 + 1);\n\t      }\n\t  }\n\n\tcase L_('W'):\n\t  if (modifier == L_('E'))\n\t    goto bad_format;\n\n\t  DO_NUMBER (2, (tp->tm_yday - (tp->tm_wday - 1 + 7) % 7 + 7) / 7);\n\n\tcase L_('w'):\n\t  if (modifier == L_('E'))\n\t    goto bad_format;\n\n\t  DO_NUMBER (1, tp->tm_wday);\n\n\tcase L_('Y'):\n\t  if (modifier == 'E')\n\t    {\n#if HAVE_STRUCT_ERA_ENTRY\n\t      struct era_entry *era = _nl_get_era_entry (tp HELPER_LOCALE_ARG);\n\t      if (era)\n\t\t{\n# ifdef COMPILE_WIDE\n\t\t  subfmt = era->era_wformat;\n# else\n\t\t  subfmt = era->era_format;\n# endif\n\t\t  goto subformat;\n\t\t}\n#else\n# if HAVE_STRFTIME\n\t      goto underlying_strftime;\n# endif\n#endif\n\t    }\n\t  if (modifier == L_('O'))\n\t    goto bad_format;\n\t  else\n\t    DO_NUMBER (1, tp->tm_year + TM_YEAR_BASE);\n\n\tcase L_('y'):\n\t  if (modifier == L_('E'))\n\t    {\n#if HAVE_STRUCT_ERA_ENTRY\n\t      struct era_entry *era = _nl_get_era_entry (tp HELPER_LOCALE_ARG);\n\t      if (era)\n\t\t{\n\t\t  int delta = tp->tm_year - era->start_date[0];\n\t\t  DO_NUMBER (1, (era->offset\n\t\t\t\t + delta * era->absolute_direction));\n\t\t}\n#else\n# if HAVE_STRFTIME\n\t      goto underlying_strftime;\n# endif\n#endif\n\t    }\n\t  DO_NUMBER (2, (tp->tm_year % 100 + 100) % 100);\n\n\tcase L_('Z'):\n\t  if (change_case)\n\t    {\n\t      to_uppcase = 0;\n\t      to_lowcase = 1;\n\t    }\n\n#if HAVE_TZNAME\n\t  /* The tzset() call might have changed the value.  */\n\t  if (!(zone && *zone) && tp->tm_isdst >= 0)\n\t    zone = tzname[tp->tm_isdst];\n#endif\n\t  if (! zone)\n\t    zone = \"\";\n\n#ifdef COMPILE_WIDE\n\t  {\n\t    /* The zone string is always given in multibyte form.  We have\n\t       to transform it first.  */\n\t    wchar_t *wczone;\n\t    size_t len;\n\t    widen (zone, wczone, len);\n\t    cpy (len, wczone);\n\t  }\n#else\n\t  cpy (strlen (zone), zone);\n#endif\n\t  break;\n\n\tcase L_('z'):\n\t  if (tp->tm_isdst < 0)\n\t    break;\n\n\t  {\n\t    int diff;\n#if HAVE_TM_GMTOFF\n\t    diff = tp->tm_gmtoff;\n#else\n\t    if (ut)\n\t      diff = 0;\n\t    else\n\t      {\n\t\tstruct tm gtm;\n\t\tstruct tm ltm;\n\t\ttime_t lt;\n\n\t\tltm = *tp;\n\t\tlt = mktime (&ltm);\n\n\t\tif (lt == (time_t) -1)\n\t\t  {\n\t\t    /* mktime returns -1 for errors, but -1 is also a\n\t\t       valid time_t value.  Check whether an error really\n\t\t       occurred.  */\n\t\t    struct tm tm;\n\n\t\t    if (! my_strftime_localtime_r (&lt, &tm)\n\t\t\t|| ((ltm.tm_sec ^ tm.tm_sec)\n\t\t\t    | (ltm.tm_min ^ tm.tm_min)\n\t\t\t    | (ltm.tm_hour ^ tm.tm_hour)\n\t\t\t    | (ltm.tm_mday ^ tm.tm_mday)\n\t\t\t    | (ltm.tm_mon ^ tm.tm_mon)\n\t\t\t    | (ltm.tm_year ^ tm.tm_year)))\n\t\t      break;\n\t\t  }\n\n\t\tif (! my_strftime_gmtime_r (&lt, &gtm))\n\t\t  break;\n\n\t\tdiff = tm_diff (&ltm, &gtm);\n\t      }\n#endif\n\n\t    if (diff < 0)\n\t      {\n\t\tadd (1, *p = L_('-'));\n\t\tdiff = -diff;\n\t      }\n\t    else\n\t      add (1, *p = L_('+'));\n\n\t    diff /= 60;\n\t    DO_NUMBER (4, (diff / 60) * 100 + diff % 60);\n\t  }\n\n\tcase L_('\\0'):\t\t/* GNU extension: % at end of format.  */\n\t    --f;\n\t    /* Fall through.  */\n\tdefault:\n\t  /* Unknown format; output the format, including the '%',\n\t     since this is most likely the right thing to do if a\n\t     multibyte string has been misparsed.  */\n\tbad_format:\n\t  {\n\t    int flen;\n\t    for (flen = 1; f[1 - flen] != L_('%'); flen++)\n\t      continue;\n\t    cpy (flen, &f[1 - flen]);\n\t  }\n\t  break;\n\t}",
        "switch",
        "(format_char)",
        "(",
        "format_char",
        ")",
        "{\n#define DO_NUMBER(d, v) \\\n\t  digits = d > width ? d : width;\t\t\t\t      \\\n\t  number_value = v; goto do_number\n#define DO_NUMBER_SPACEPAD(d, v) \\\n\t  digits = d > width ? d : width;\t\t\t\t      \\\n\t  number_value = v; goto do_number_spacepad\n\n\tcase L_('%'):\n\t  if (modifier != 0)\n\t    goto bad_format;\n\t  add (1, *p = *f);\n\t  break;\n\n\tcase L_('a'):\n\t  if (modifier != 0)\n\t    goto bad_format;\n\t  if (change_case)\n\t    {\n\t      to_uppcase = 1;\n\t      to_lowcase = 0;\n\t    }\n#if defined _NL_CURRENT || !HAVE_STRFTIME\n\t  cpy (aw_len, a_wkday);\n\t  break;\n#else\n\t  goto underlying_strftime;\n#endif\n\n\tcase 'A':\n\t  if (modifier != 0)\n\t    goto bad_format;\n\t  if (change_case)\n\t    {\n\t      to_uppcase = 1;\n\t      to_lowcase = 0;\n\t    }\n#if defined _NL_CURRENT || !HAVE_STRFTIME\n\t  cpy (STRLEN (f_wkday), f_wkday);\n\t  break;\n#else\n\t  goto underlying_strftime;\n#endif\n\n\tcase L_('b'):\n\tcase L_('h'):\n\t  if (change_case)\n\t    {\n\t      to_uppcase = 1;\n\t      to_lowcase = 0;\n\t    }\n\t  if (modifier != 0)\n\t    goto bad_format;\n#if defined _NL_CURRENT || !HAVE_STRFTIME\n\t  cpy (am_len, a_month);\n\t  break;\n#else\n\t  goto underlying_strftime;\n#endif\n\n\tcase L_('B'):\n\t  if (modifier != 0)\n\t    goto bad_format;\n\t  if (change_case)\n\t    {\n\t      to_uppcase = 1;\n\t      to_lowcase = 0;\n\t    }\n#if defined _NL_CURRENT || !HAVE_STRFTIME\n\t  cpy (STRLEN (f_month), f_month);\n\t  break;\n#else\n\t  goto underlying_strftime;\n#endif\n\n\tcase L_('c'):\n\t  if (modifier == L_('O'))\n\t    goto bad_format;\n#ifdef _NL_CURRENT\n\t  if (! (modifier == 'E'\n\t\t && (*(subfmt =\n\t\t       (const CHAR_T *) _NL_CURRENT (LC_TIME,\n\t\t\t\t\t\t     NLW(ERA_D_T_FMT)))\n\t\t     != '\\0')))\n\t    subfmt = (const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(D_T_FMT));\n#else\n# if HAVE_STRFTIME\n\t  goto underlying_strftime;\n# else\n\t  subfmt = L_(\"%a %b %e %H:%M:%S %Y\");\n# endif\n#endif\n\n\tsubformat:\n\t  {\n\t    CHAR_T *old_start = p;\n\t    size_t len = my_strftime (NULL, (size_t) -1, subfmt,\n\t\t\t\t      tp ut_argument LOCALE_ARG);\n\t    add (len, my_strftime (p, maxsize - i, subfmt,\n\t\t\t\t   tp ut_argument LOCALE_ARG));\n\n\t    if (to_uppcase)\n\t      while (old_start < p)\n\t\t{\n\t\t  *old_start = TOUPPER ((UCHAR_T) *old_start, loc);\n\t\t  ++old_start;\n\t\t}\n\t  }\n\t  break;\n\n#if HAVE_STRFTIME && ! (defined _NL_CURRENT && HAVE_STRUCT_ERA_ENTRY)\n\tunderlying_strftime:\n\t  {\n\t    /* The relevant information is available only via the\n\t       underlying strftime implementation, so use that.  */\n\t    char ufmt[4];\n\t    char *u = ufmt;\n\t    char ubuf[1024]; /* enough for any single format in practice */\n\t    size_t len;\n\t    /* Make sure we're calling the actual underlying strftime.\n\t       In some cases, config.h contains something like\n\t       \"#define strftime rpl_strftime\".  */\n# ifdef strftime\n#  undef strftime\n\t    size_t strftime ();\n# endif\n\n\t    *u++ = '%';\n\t    if (modifier != 0)\n\t      *u++ = modifier;\n\t    *u++ = format_char;\n\t    *u = '\\0';\n\t    len = strftime (ubuf, sizeof ubuf, ufmt, tp);\n\t    if (len == 0 && ubuf[0] != '\\0')\n\t      return 0;\n\t    cpy (len, ubuf);\n\t  }\n\t  break;\n#endif\n\n\tcase L_('C'):\n\t  if (modifier == L_('O'))\n\t    goto bad_format;\n\t  if (modifier == L_('E'))\n\t    {\n#if HAVE_STRUCT_ERA_ENTRY\n\t      struct era_entry *era = _nl_get_era_entry (tp HELPER_LOCALE_ARG);\n\t      if (era)\n\t\t{\n# ifdef COMPILE_WIDE\n\t\t  size_t len = __wcslen (era->era_wname);\n\t\t  cpy (len, era->era_wname);\n# else\n\t\t  size_t len = strlen (era->era_name);\n\t\t  cpy (len, era->era_name);\n# endif\n\t\t  break;\n\t\t}\n#else\n# if HAVE_STRFTIME\n\t      goto underlying_strftime;\n# endif\n#endif\n\t    }\n\n\t  {\n\t    int year = tp->tm_year + TM_YEAR_BASE;\n\t    DO_NUMBER (1, year / 100 - (year % 100 < 0));\n\t  }\n\n\tcase L_('x'):\n\t  if (modifier == L_('O'))\n\t    goto bad_format;\n#ifdef _NL_CURRENT\n\t  if (! (modifier == L_('E')\n\t\t && (*(subfmt =\n\t\t       (const CHAR_T *)_NL_CURRENT (LC_TIME, NLW(ERA_D_FMT)))\n\t\t     != L_('\\0'))))\n\t    subfmt = (const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(D_FMT));\n\t  goto subformat;\n#else\n# if HAVE_STRFTIME\n\t  goto underlying_strftime;\n# else\n\t  /* Fall through.  */\n# endif\n#endif\n\tcase L_('D'):\n\t  if (modifier != 0)\n\t    goto bad_format;\n\t  subfmt = L_(\"%m/%d/%y\");\n\t  goto subformat;\n\n\tcase L_('d'):\n\t  if (modifier == L_('E'))\n\t    goto bad_format;\n\n\t  DO_NUMBER (2, tp->tm_mday);\n\n\tcase L_('e'):\n\t  if (modifier == L_('E'))\n\t    goto bad_format;\n\n\t  DO_NUMBER_SPACEPAD (2, tp->tm_mday);\n\n\t  /* All numeric formats set DIGITS and NUMBER_VALUE and then\n\t     jump to one of these two labels.  */\n\n\tdo_number_spacepad:\n\t  /* Force `_' flag unless overwritten by `0' flag.  */\n\t  if (pad != L_('0'))\n\t    pad = L_('_');\n\n\tdo_number:\n\t  /* Format the number according to the MODIFIER flag.  */\n\n\t  if (modifier == L_('O') && 0 <= number_value)\n\t    {\n#ifdef _NL_CURRENT\n\t      /* Get the locale specific alternate representation of\n\t\t the number NUMBER_VALUE.  If none exist NULL is returned.  */\n\t      const CHAR_T *cp = nl_get_alt_digit (number_value\n\t\t\t\t\t\t   HELPER_LOCALE_ARG);\n\n\t      if (cp != NULL)\n\t\t{\n\t\t  size_t digitlen = STRLEN (cp);\n\t\t  if (digitlen != 0)\n\t\t    {\n\t\t      cpy (digitlen, cp);\n\t\t      break;\n\t\t    }\n\t\t}\n#else\n# if HAVE_STRFTIME\n\t      goto underlying_strftime;\n# endif\n#endif\n\t    }\n\t  {\n\t    unsigned int u = number_value;\n\n\t    bufp = buf + sizeof (buf) / sizeof (buf[0]);\n\t    negative_number = number_value < 0;\n\n\t    if (negative_number)\n\t      u = -u;\n\n\t    do\n\t      *--bufp = u % 10 + L_('0');\n\t    while ((u /= 10) != 0);\n  \t  }\n\n\tdo_number_sign_and_padding:\n\t  if (negative_number)\n\t    *--bufp = L_('-');\n\n\t  if (pad != L_('-'))\n\t    {\n\t      int padding = digits - (buf + (sizeof (buf) / sizeof (buf[0]))\n\t\t\t\t      - bufp);\n\n\t      if (padding > 0)\n\t\t{\n\t\t  if (pad == L_('_'))\n\t\t    {\n\t\t      if ((size_t) padding >= maxsize - i)\n\t\t\treturn 0;\n\n\t\t      if (p)\n\t\t\tmemset_space (p, padding);\n\t\t      i += padding;\n\t\t      width = width > padding ? width - padding : 0;\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      if ((size_t) digits >= maxsize - i)\n\t\t\treturn 0;\n\n\t\t      if (negative_number)\n\t\t\t{\n\t\t\t  ++bufp;\n\n\t\t\t  if (p)\n\t\t\t    *p++ = L_('-');\n\t\t\t  ++i;\n\t\t\t}\n\n\t\t      if (p)\n\t\t\tmemset_zero (p, padding);\n\t\t      i += padding;\n\t\t      width = 0;\n\t\t    }\n\t\t}\n\t    }\n\n\t  cpy (buf + sizeof (buf) / sizeof (buf[0]) - bufp, bufp);\n\t  break;\n\n\tcase L_('F'):\n\t  if (modifier != 0)\n\t    goto bad_format;\n\t  subfmt = L_(\"%Y-%m-%d\");\n\t  goto subformat;\n\n\tcase L_('H'):\n\t  if (modifier == L_('E'))\n\t    goto bad_format;\n\n\t  DO_NUMBER (2, tp->tm_hour);\n\n\tcase L_('I'):\n\t  if (modifier == L_('E'))\n\t    goto bad_format;\n\n\t  DO_NUMBER (2, hour12);\n\n\tcase L_('k'):\t\t/* GNU extension.  */\n\t  if (modifier == L_('E'))\n\t    goto bad_format;\n\n\t  DO_NUMBER_SPACEPAD (2, tp->tm_hour);\n\n\tcase L_('l'):\t\t/* GNU extension.  */\n\t  if (modifier == L_('E'))\n\t    goto bad_format;\n\n\t  DO_NUMBER_SPACEPAD (2, hour12);\n\n\tcase L_('j'):\n\t  if (modifier == L_('E'))\n\t    goto bad_format;\n\n\t  DO_NUMBER (3, 1 + tp->tm_yday);\n\n\tcase L_('M'):\n\t  if (modifier == L_('E'))\n\t    goto bad_format;\n\n\t  DO_NUMBER (2, tp->tm_min);\n\n\tcase L_('m'):\n\t  if (modifier == L_('E'))\n\t    goto bad_format;\n\n\t  DO_NUMBER (2, tp->tm_mon + 1);\n\n\tcase L_('n'):\n\t  add (1, *p = L_('\\n'));\n\t  break;\n\n\tcase L_('P'):\n\t  to_lowcase = 1;\n#if !defined _NL_CURRENT && HAVE_STRFTIME\n\t  format_char = L_('p');\n#endif\n\t  /* FALLTHROUGH */\n\n\tcase L_('p'):\n\t  if (change_case)\n\t    {\n\t      to_uppcase = 0;\n\t      to_lowcase = 1;\n\t    }\n#if defined _NL_CURRENT || !HAVE_STRFTIME\n\t  cpy (ap_len, ampm);\n\t  break;\n#else\n\t  goto underlying_strftime;\n#endif\n\n\tcase L_('R'):\n\t  subfmt = L_(\"%H:%M\");\n\t  goto subformat;\n\n\tcase L_('r'):\n#ifdef _NL_CURRENT\n\t  if (*(subfmt = (const CHAR_T *) _NL_CURRENT (LC_TIME,\n\t\t\t\t\t\t       NLW(T_FMT_AMPM)))\n\t      == L_('\\0'))\n#endif\n\t    subfmt = L_(\"%I:%M:%S %p\");\n\t  goto subformat;\n\n\tcase L_('S'):\n\t  if (modifier == L_('E'))\n\t    goto bad_format;\n\n\t  DO_NUMBER (2, tp->tm_sec);\n\n\tcase L_('s'):\t\t/* GNU extension.  */\n  \t  {\n\t    struct tm ltm;\n\t    time_t t;\n\n\t    ltm = *tp;\n\t    t = mktime (&ltm);\n\n\t    /* Generate string value for T using time_t arithmetic;\n\t       this works even if sizeof (long) < sizeof (time_t).  */\n\n\t    bufp = buf + sizeof (buf) / sizeof (buf[0]);\n#ifndef TIME_T_UNSIGNED\n\t    negative_number = t < 0;\n#endif\n\n\t    do\n\t      {\n\t\tint d = t % 10;\n\t\tt /= 10;\n\n#ifndef TIME_T_UNSIGNED\n\t\tif (negative_number)\n\t\t  {\n\t\t    d = -d;\n\n\t\t    /* Adjust if division truncates to minus infinity.  */\n\t\t    if (0 < -1 % 10 && d < 0)\n\t\t      {\n\t\t\tt++;\n\t\t\td += 10;\n\t\t      }\n\t\t  }\n#endif\n\n\t\t*--bufp = d + L_('0');\n\t      }\n\t    while (t != 0);\n\n\t    digits = 1;\n\t    goto do_number_sign_and_padding;\n\t  }\n\n\tcase L_('X'):\n\t  if (modifier == L_('O'))\n\t    goto bad_format;\n#ifdef _NL_CURRENT\n\t  if (! (modifier == L_('E')\n\t\t && (*(subfmt =\n\t\t       (const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(ERA_T_FMT)))\n\t\t     != L_('\\0'))))\n\t    subfmt = (const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(T_FMT));\n\t  goto subformat;\n#else\n# if HAVE_STRFTIME\n\t  goto underlying_strftime;\n# else\n\t  /* Fall through.  */\n# endif\n#endif\n\tcase L_('T'):\n\t  subfmt = L_(\"%H:%M:%S\");\n\t  goto subformat;\n\n\tcase L_('t'):\n\t  add (1, *p = L_('\\t'));\n\t  break;\n\n\tcase L_('u'):\n\t  DO_NUMBER (1, (tp->tm_wday - 1 + 7) % 7 + 1);\n\n\tcase L_('U'):\n\t  if (modifier == L_('E'))\n\t    goto bad_format;\n\n\t  DO_NUMBER (2, (tp->tm_yday - tp->tm_wday + 7) / 7);\n\n\tcase L_('V'):\n\tcase L_('g'):\n\tcase L_('G'):\n\t  if (modifier == L_('E'))\n\t    goto bad_format;\n\t  {\n\t    int year = tp->tm_year + TM_YEAR_BASE;\n\t    int days = iso_week_days (tp->tm_yday, tp->tm_wday);\n\n\t    if (days < 0)\n\t      {\n\t\t/* This ISO week belongs to the previous year.  */\n\t\tyear--;\n\t\tdays = iso_week_days (tp->tm_yday + (365 + __isleap (year)),\n\t\t\t\t      tp->tm_wday);\n\t      }\n\t    else\n\t      {\n\t\tint d = iso_week_days (tp->tm_yday - (365 + __isleap (year)),\n\t\t\t\t       tp->tm_wday);\n\t\tif (0 <= d)\n\t\t  {\n\t\t    /* This ISO week belongs to the next year.  */\n\t\t    year++;\n\t\t    days = d;\n\t\t  }\n\t      }\n\n\t    switch (*f)\n\t      {\n\t      case L_('g'):\n\t\tDO_NUMBER (2, (year % 100 + 100) % 100);\n\n\t      case L_('G'):\n\t\tDO_NUMBER (1, year);\n\n\t      default:\n\t\tDO_NUMBER (2, days / 7 + 1);\n\t      }\n\t  }\n\n\tcase L_('W'):\n\t  if (modifier == L_('E'))\n\t    goto bad_format;\n\n\t  DO_NUMBER (2, (tp->tm_yday - (tp->tm_wday - 1 + 7) % 7 + 7) / 7);\n\n\tcase L_('w'):\n\t  if (modifier == L_('E'))\n\t    goto bad_format;\n\n\t  DO_NUMBER (1, tp->tm_wday);\n\n\tcase L_('Y'):\n\t  if (modifier == 'E')\n\t    {\n#if HAVE_STRUCT_ERA_ENTRY\n\t      struct era_entry *era = _nl_get_era_entry (tp HELPER_LOCALE_ARG);\n\t      if (era)\n\t\t{\n# ifdef COMPILE_WIDE\n\t\t  subfmt = era->era_wformat;\n# else\n\t\t  subfmt = era->era_format;\n# endif\n\t\t  goto subformat;\n\t\t}\n#else\n# if HAVE_STRFTIME\n\t      goto underlying_strftime;\n# endif\n#endif\n\t    }\n\t  if (modifier == L_('O'))\n\t    goto bad_format;\n\t  else\n\t    DO_NUMBER (1, tp->tm_year + TM_YEAR_BASE);\n\n\tcase L_('y'):\n\t  if (modifier == L_('E'))\n\t    {\n#if HAVE_STRUCT_ERA_ENTRY\n\t      struct era_entry *era = _nl_get_era_entry (tp HELPER_LOCALE_ARG);\n\t      if (era)\n\t\t{\n\t\t  int delta = tp->tm_year - era->start_date[0];\n\t\t  DO_NUMBER (1, (era->offset\n\t\t\t\t + delta * era->absolute_direction));\n\t\t}\n#else\n# if HAVE_STRFTIME\n\t      goto underlying_strftime;\n# endif\n#endif\n\t    }\n\t  DO_NUMBER (2, (tp->tm_year % 100 + 100) % 100);\n\n\tcase L_('Z'):\n\t  if (change_case)\n\t    {\n\t      to_uppcase = 0;\n\t      to_lowcase = 1;\n\t    }\n\n#if HAVE_TZNAME\n\t  /* The tzset() call might have changed the value.  */\n\t  if (!(zone && *zone) && tp->tm_isdst >= 0)\n\t    zone = tzname[tp->tm_isdst];\n#endif\n\t  if (! zone)\n\t    zone = \"\";\n\n#ifdef COMPILE_WIDE\n\t  {\n\t    /* The zone string is always given in multibyte form.  We have\n\t       to transform it first.  */\n\t    wchar_t *wczone;\n\t    size_t len;\n\t    widen (zone, wczone, len);\n\t    cpy (len, wczone);\n\t  }\n#else\n\t  cpy (strlen (zone), zone);\n#endif\n\t  break;\n\n\tcase L_('z'):\n\t  if (tp->tm_isdst < 0)\n\t    break;\n\n\t  {\n\t    int diff;\n#if HAVE_TM_GMTOFF\n\t    diff = tp->tm_gmtoff;\n#else\n\t    if (ut)\n\t      diff = 0;\n\t    else\n\t      {\n\t\tstruct tm gtm;\n\t\tstruct tm ltm;\n\t\ttime_t lt;\n\n\t\tltm = *tp;\n\t\tlt = mktime (&ltm);\n\n\t\tif (lt == (time_t) -1)\n\t\t  {\n\t\t    /* mktime returns -1 for errors, but -1 is also a\n\t\t       valid time_t value.  Check whether an error really\n\t\t       occurred.  */\n\t\t    struct tm tm;\n\n\t\t    if (! my_strftime_localtime_r (&lt, &tm)\n\t\t\t|| ((ltm.tm_sec ^ tm.tm_sec)\n\t\t\t    | (ltm.tm_min ^ tm.tm_min)\n\t\t\t    | (ltm.tm_hour ^ tm.tm_hour)\n\t\t\t    | (ltm.tm_mday ^ tm.tm_mday)\n\t\t\t    | (ltm.tm_mon ^ tm.tm_mon)\n\t\t\t    | (ltm.tm_year ^ tm.tm_year)))\n\t\t      break;\n\t\t  }\n\n\t\tif (! my_strftime_gmtime_r (&lt, &gtm))\n\t\t  break;\n\n\t\tdiff = tm_diff (&ltm, &gtm);\n\t      }\n#endif\n\n\t    if (diff < 0)\n\t      {\n\t\tadd (1, *p = L_('-'));\n\t\tdiff = -diff;\n\t      }\n\t    else\n\t      add (1, *p = L_('+'));\n\n\t    diff /= 60;\n\t    DO_NUMBER (4, (diff / 60) * 100 + diff % 60);\n\t  }\n\n\tcase L_('\\0'):\t\t/* GNU extension: % at end of format.  */\n\t    --f;\n\t    /* Fall through.  */\n\tdefault:\n\t  /* Unknown format; output the format, including the '%',\n\t     since this is most likely the right thing to do if a\n\t     multibyte string has been misparsed.  */\n\tbad_format:\n\t  {\n\t    int flen;\n\t    for (flen = 1; f[1 - flen] != L_('%'); flen++)\n\t      continue;\n\t    cpy (flen, &f[1 - flen]);\n\t  }\n\t  break;\n\t}",
        "{",
        "#define DO_NUMBER(d, v) \\\n\t  digits = d > width ? d : width;\t\t\t\t      \\\n\t  number_value = v; goto do_number\n",
        "#define",
        "DO_NUMBER",
        "(d, v)",
        "(",
        "d",
        ",",
        "v",
        ")",
        " \\\n\t  digits = d > width ? d : width;\t\t\t\t      \\\n\t  number_value = v; goto do_number",
        "\n",
        "#define DO_NUMBER_SPACEPAD(d, v) \\\n\t  digits = d > width ? d : width;\t\t\t\t      \\\n\t  number_value = v; goto do_number_spacepad\n\n",
        "#define",
        "DO_NUMBER_SPACEPAD",
        "(d, v)",
        "(",
        "d",
        ",",
        "v",
        ")",
        " \\\n\t  digits = d > width ? d : width;\t\t\t\t      \\\n\t  number_value = v; goto do_number_spacepad",
        "\n\n",
        "case L_('%'):\n\t  if (modifier != 0)\n\t    goto bad_format;\n\t  add (1, *p = *f);\n\t  break;",
        "case",
        "L_('%')",
        "L_",
        "('%')",
        "(",
        "'%'",
        "'",
        "'",
        ")",
        ":",
        "if (modifier != 0)\n\t    goto bad_format;",
        "if",
        "(modifier != 0)",
        "(",
        "modifier != 0",
        "modifier",
        "!=",
        "0",
        ")",
        "goto bad_format;",
        "goto",
        "bad_format",
        ";",
        "add (1, *p = *f);",
        "add (1, *p = *f)",
        "add",
        "(1, *p = *f)",
        "(",
        "1",
        ",",
        "*p = *f",
        "*p",
        "*",
        "p",
        "=",
        "*f",
        "*",
        "f",
        ")",
        ";",
        "break;",
        "break",
        ";",
        "case L_('a'):\n\t  if (modifier != 0)\n\t    goto bad_format;\n\t  if (change_case)\n\t    {\n\t      to_uppcase = 1;\n\t      to_lowcase = 0;\n\t    }",
        "case",
        "L_('a')",
        "L_",
        "('a')",
        "(",
        "'a'",
        "'",
        "'",
        ")",
        ":",
        "if (modifier != 0)\n\t    goto bad_format;",
        "if",
        "(modifier != 0)",
        "(",
        "modifier != 0",
        "modifier",
        "!=",
        "0",
        ")",
        "goto bad_format;",
        "goto",
        "bad_format",
        ";",
        "if (change_case)\n\t    {\n\t      to_uppcase = 1;\n\t      to_lowcase = 0;\n\t    }",
        "if",
        "(change_case)",
        "(",
        "change_case",
        ")",
        "{\n\t      to_uppcase = 1;\n\t      to_lowcase = 0;\n\t    }",
        "{",
        "to_uppcase = 1;",
        "to_uppcase = 1",
        "to_uppcase",
        "=",
        "1",
        ";",
        "to_lowcase = 0;",
        "to_lowcase = 0",
        "to_lowcase",
        "=",
        "0",
        ";",
        "}",
        "#if defined _NL_CURRENT || !HAVE_STRFTIME\n\t  cpy (aw_len, a_wkday);\n\t  break;\n#else\n\t  goto underlying_strftime;\n#endif",
        "#if",
        "defined _NL_CURRENT || !HAVE_STRFTIME",
        "defined _NL_CURRENT",
        "defined",
        "_NL_CURRENT",
        "||",
        "!HAVE_STRFTIME",
        "!",
        "HAVE_STRFTIME",
        "\n",
        "cpy (aw_len, a_wkday);",
        "cpy (aw_len, a_wkday)",
        "cpy",
        "(aw_len, a_wkday)",
        "(",
        "aw_len",
        ",",
        "a_wkday",
        ")",
        ";",
        "break;",
        "break",
        ";",
        "#else\n\t  goto underlying_strftime;",
        "#else",
        "goto underlying_strftime;",
        "goto",
        "underlying_strftime",
        ";",
        "#endif",
        "case 'A':\n\t  if (modifier != 0)\n\t    goto bad_format;\n\t  if (change_case)\n\t    {\n\t      to_uppcase = 1;\n\t      to_lowcase = 0;\n\t    }",
        "case",
        "'A'",
        "'",
        "'",
        ":",
        "if (modifier != 0)\n\t    goto bad_format;",
        "if",
        "(modifier != 0)",
        "(",
        "modifier != 0",
        "modifier",
        "!=",
        "0",
        ")",
        "goto bad_format;",
        "goto",
        "bad_format",
        ";",
        "if (change_case)\n\t    {\n\t      to_uppcase = 1;\n\t      to_lowcase = 0;\n\t    }",
        "if",
        "(change_case)",
        "(",
        "change_case",
        ")",
        "{\n\t      to_uppcase = 1;\n\t      to_lowcase = 0;\n\t    }",
        "{",
        "to_uppcase = 1;",
        "to_uppcase = 1",
        "to_uppcase",
        "=",
        "1",
        ";",
        "to_lowcase = 0;",
        "to_lowcase = 0",
        "to_lowcase",
        "=",
        "0",
        ";",
        "}",
        "#if defined _NL_CURRENT || !HAVE_STRFTIME\n\t  cpy (STRLEN (f_wkday), f_wkday);\n\t  break;\n#else\n\t  goto underlying_strftime;\n#endif",
        "#if",
        "defined _NL_CURRENT || !HAVE_STRFTIME",
        "defined _NL_CURRENT",
        "defined",
        "_NL_CURRENT",
        "||",
        "!HAVE_STRFTIME",
        "!",
        "HAVE_STRFTIME",
        "\n",
        "cpy (STRLEN (f_wkday), f_wkday);",
        "cpy (STRLEN (f_wkday), f_wkday)",
        "cpy",
        "(STRLEN (f_wkday), f_wkday)",
        "(",
        "STRLEN (f_wkday)",
        "STRLEN",
        "(f_wkday)",
        "(",
        "f_wkday",
        ")",
        ",",
        "f_wkday",
        ")",
        ";",
        "break;",
        "break",
        ";",
        "#else\n\t  goto underlying_strftime;",
        "#else",
        "goto underlying_strftime;",
        "goto",
        "underlying_strftime",
        ";",
        "#endif",
        "case L_('b'):",
        "case",
        "L_('b')",
        "L_",
        "('b')",
        "(",
        "'b'",
        "'",
        "'",
        ")",
        ":",
        "case L_('h'):\n\t  if (change_case)\n\t    {\n\t      to_uppcase = 1;\n\t      to_lowcase = 0;\n\t    }\n\t  if (modifier != 0)\n\t    goto bad_format;",
        "case",
        "L_('h')",
        "L_",
        "('h')",
        "(",
        "'h'",
        "'",
        "'",
        ")",
        ":",
        "if (change_case)\n\t    {\n\t      to_uppcase = 1;\n\t      to_lowcase = 0;\n\t    }",
        "if",
        "(change_case)",
        "(",
        "change_case",
        ")",
        "{\n\t      to_uppcase = 1;\n\t      to_lowcase = 0;\n\t    }",
        "{",
        "to_uppcase = 1;",
        "to_uppcase = 1",
        "to_uppcase",
        "=",
        "1",
        ";",
        "to_lowcase = 0;",
        "to_lowcase = 0",
        "to_lowcase",
        "=",
        "0",
        ";",
        "}",
        "if (modifier != 0)\n\t    goto bad_format;",
        "if",
        "(modifier != 0)",
        "(",
        "modifier != 0",
        "modifier",
        "!=",
        "0",
        ")",
        "goto bad_format;",
        "goto",
        "bad_format",
        ";",
        "#if defined _NL_CURRENT || !HAVE_STRFTIME\n\t  cpy (am_len, a_month);\n\t  break;\n#else\n\t  goto underlying_strftime;\n#endif",
        "#if",
        "defined _NL_CURRENT || !HAVE_STRFTIME",
        "defined _NL_CURRENT",
        "defined",
        "_NL_CURRENT",
        "||",
        "!HAVE_STRFTIME",
        "!",
        "HAVE_STRFTIME",
        "\n",
        "cpy (am_len, a_month);",
        "cpy (am_len, a_month)",
        "cpy",
        "(am_len, a_month)",
        "(",
        "am_len",
        ",",
        "a_month",
        ")",
        ";",
        "break;",
        "break",
        ";",
        "#else\n\t  goto underlying_strftime;",
        "#else",
        "goto underlying_strftime;",
        "goto",
        "underlying_strftime",
        ";",
        "#endif",
        "case L_('B'):\n\t  if (modifier != 0)\n\t    goto bad_format;\n\t  if (change_case)\n\t    {\n\t      to_uppcase = 1;\n\t      to_lowcase = 0;\n\t    }",
        "case",
        "L_('B')",
        "L_",
        "('B')",
        "(",
        "'B'",
        "'",
        "'",
        ")",
        ":",
        "if (modifier != 0)\n\t    goto bad_format;",
        "if",
        "(modifier != 0)",
        "(",
        "modifier != 0",
        "modifier",
        "!=",
        "0",
        ")",
        "goto bad_format;",
        "goto",
        "bad_format",
        ";",
        "if (change_case)\n\t    {\n\t      to_uppcase = 1;\n\t      to_lowcase = 0;\n\t    }",
        "if",
        "(change_case)",
        "(",
        "change_case",
        ")",
        "{\n\t      to_uppcase = 1;\n\t      to_lowcase = 0;\n\t    }",
        "{",
        "to_uppcase = 1;",
        "to_uppcase = 1",
        "to_uppcase",
        "=",
        "1",
        ";",
        "to_lowcase = 0;",
        "to_lowcase = 0",
        "to_lowcase",
        "=",
        "0",
        ";",
        "}",
        "#if defined _NL_CURRENT || !HAVE_STRFTIME\n\t  cpy (STRLEN (f_month), f_month);\n\t  break;\n#else\n\t  goto underlying_strftime;\n#endif",
        "#if",
        "defined _NL_CURRENT || !HAVE_STRFTIME",
        "defined _NL_CURRENT",
        "defined",
        "_NL_CURRENT",
        "||",
        "!HAVE_STRFTIME",
        "!",
        "HAVE_STRFTIME",
        "\n",
        "cpy (STRLEN (f_month), f_month);",
        "cpy (STRLEN (f_month), f_month)",
        "cpy",
        "(STRLEN (f_month), f_month)",
        "(",
        "STRLEN (f_month)",
        "STRLEN",
        "(f_month)",
        "(",
        "f_month",
        ")",
        ",",
        "f_month",
        ")",
        ";",
        "break;",
        "break",
        ";",
        "#else\n\t  goto underlying_strftime;",
        "#else",
        "goto underlying_strftime;",
        "goto",
        "underlying_strftime",
        ";",
        "#endif",
        "case L_('c'):\n\t  if (modifier == L_('O'))\n\t    goto bad_format;",
        "case",
        "L_('c')",
        "L_",
        "('c')",
        "(",
        "'c'",
        "'",
        "'",
        ")",
        ":",
        "if (modifier == L_('O'))\n\t    goto bad_format;",
        "if",
        "(modifier == L_('O'))",
        "(",
        "modifier == L_('O')",
        "modifier",
        "==",
        "L_('O')",
        "L_",
        "('O')",
        "(",
        "'O'",
        "'",
        "'",
        ")",
        ")",
        "goto bad_format;",
        "goto",
        "bad_format",
        ";",
        "#ifdef _NL_CURRENT\n\t  if (! (modifier == 'E'\n\t\t && (*(subfmt =\n\t\t       (const CHAR_T *) _NL_CURRENT (LC_TIME,\n\t\t\t\t\t\t     NLW(ERA_D_T_FMT)))\n\t\t     != '\\0')))\n\t    subfmt = (const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(D_T_FMT));\n#else\n# if HAVE_STRFTIME\n\t  goto underlying_strftime;\n# else\n\t  subfmt = L_(\"%a %b %e %H:%M:%S %Y\");\n# endif\n#endif",
        "#ifdef",
        "_NL_CURRENT",
        "if (! (modifier == 'E'\n\t\t && (*(subfmt =\n\t\t       (const CHAR_T *) _NL_CURRENT (LC_TIME,\n\t\t\t\t\t\t     NLW(ERA_D_T_FMT)))\n\t\t     != '\\0')))\n\t    subfmt = (const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(D_T_FMT));",
        "if",
        "(! (modifier == 'E'\n\t\t && (*(subfmt =\n\t\t       (const CHAR_T *) _NL_CURRENT (LC_TIME,\n\t\t\t\t\t\t     NLW(ERA_D_T_FMT)))\n\t\t     != '\\0')))",
        "(",
        "! (modifier == 'E'\n\t\t && (*(subfmt =\n\t\t       (const CHAR_T *) _NL_CURRENT (LC_TIME,\n\t\t\t\t\t\t     NLW(ERA_D_T_FMT)))\n\t\t     != '\\0'))",
        "!",
        "(modifier == 'E'\n\t\t && (*(subfmt =\n\t\t       (const CHAR_T *) _NL_CURRENT (LC_TIME,\n\t\t\t\t\t\t     NLW(ERA_D_T_FMT)))\n\t\t     != '\\0'))",
        "(",
        "modifier == 'E'\n\t\t && (*(subfmt =\n\t\t       (const CHAR_T *) _NL_CURRENT (LC_TIME,\n\t\t\t\t\t\t     NLW(ERA_D_T_FMT)))\n\t\t     != '\\0')",
        "modifier == 'E'",
        "modifier",
        "==",
        "'E'",
        "'",
        "'",
        "&&",
        "(*(subfmt =\n\t\t       (const CHAR_T *) _NL_CURRENT (LC_TIME,\n\t\t\t\t\t\t     NLW(ERA_D_T_FMT)))\n\t\t     != '\\0')",
        "(",
        "*(subfmt =\n\t\t       (const CHAR_T *) _NL_CURRENT (LC_TIME,\n\t\t\t\t\t\t     NLW(ERA_D_T_FMT)))\n\t\t     != '\\0'",
        "*(subfmt =\n\t\t       (const CHAR_T *) _NL_CURRENT (LC_TIME,\n\t\t\t\t\t\t     NLW(ERA_D_T_FMT)))",
        "*",
        "(subfmt =\n\t\t       (const CHAR_T *) _NL_CURRENT (LC_TIME,\n\t\t\t\t\t\t     NLW(ERA_D_T_FMT)))",
        "(",
        "subfmt =\n\t\t       (const CHAR_T *) _NL_CURRENT (LC_TIME,\n\t\t\t\t\t\t     NLW(ERA_D_T_FMT))",
        "subfmt",
        "=",
        "(const CHAR_T *) _NL_CURRENT (LC_TIME,\n\t\t\t\t\t\t     NLW(ERA_D_T_FMT))",
        "(",
        "const CHAR_T *",
        "const",
        "const",
        "CHAR_T",
        "*",
        "*",
        ")",
        "_NL_CURRENT (LC_TIME,\n\t\t\t\t\t\t     NLW(ERA_D_T_FMT))",
        "_NL_CURRENT",
        "(LC_TIME,\n\t\t\t\t\t\t     NLW(ERA_D_T_FMT))",
        "(",
        "LC_TIME",
        ",",
        "NLW(ERA_D_T_FMT)",
        "NLW",
        "(ERA_D_T_FMT)",
        "(",
        "ERA_D_T_FMT",
        ")",
        ")",
        ")",
        "!=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ")",
        ")",
        ")",
        "subfmt = (const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(D_T_FMT));",
        "subfmt = (const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(D_T_FMT))",
        "subfmt",
        "=",
        "(const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(D_T_FMT))",
        "(",
        "const CHAR_T *",
        "const",
        "const",
        "CHAR_T",
        "*",
        "*",
        ")",
        "_NL_CURRENT (LC_TIME, NLW(D_T_FMT))",
        "_NL_CURRENT",
        "(LC_TIME, NLW(D_T_FMT))",
        "(",
        "LC_TIME",
        ",",
        "NLW(D_T_FMT)",
        "NLW",
        "(D_T_FMT)",
        "(",
        "D_T_FMT",
        ")",
        ")",
        ";",
        "#else\n# if HAVE_STRFTIME\n\t  goto underlying_strftime;\n# else\n\t  subfmt = L_(\"%a %b %e %H:%M:%S %Y\");\n# endif",
        "#else",
        "# if HAVE_STRFTIME\n\t  goto underlying_strftime;\n# else\n\t  subfmt = L_(\"%a %b %e %H:%M:%S %Y\");\n# endif",
        "# if",
        "HAVE_STRFTIME",
        "\n",
        "goto underlying_strftime;",
        "goto",
        "underlying_strftime",
        ";",
        "# else\n\t  subfmt = L_(\"%a %b %e %H:%M:%S %Y\");",
        "# else",
        "subfmt = L_(\"%a %b %e %H:%M:%S %Y\");",
        "subfmt = L_(\"%a %b %e %H:%M:%S %Y\")",
        "subfmt",
        "=",
        "L_(\"%a %b %e %H:%M:%S %Y\")",
        "L_",
        "(\"%a %b %e %H:%M:%S %Y\")",
        "(",
        "\"%a %b %e %H:%M:%S %Y\"",
        "\"",
        "\"",
        ")",
        ";",
        "# endif",
        "#endif",
        "subformat:\n\t  {\n\t    CHAR_T *old_start = p;\n\t    size_t len = my_strftime (NULL, (size_t) -1, subfmt,\n\t\t\t\t      tp ut_argument LOCALE_ARG);\n\t    add (len, my_strftime (p, maxsize - i, subfmt,\n\t\t\t\t   tp ut_argument LOCALE_ARG));\n\n\t    if (to_uppcase)\n\t      while (old_start < p)\n\t\t{\n\t\t  *old_start = TOUPPER ((UCHAR_T) *old_start, loc);\n\t\t  ++old_start;\n\t\t}\n\t  }",
        "subformat",
        ":",
        "{\n\t    CHAR_T *old_start = p;\n\t    size_t len = my_strftime (NULL, (size_t) -1, subfmt,\n\t\t\t\t      tp ut_argument LOCALE_ARG);\n\t    add (len, my_strftime (p, maxsize - i, subfmt,\n\t\t\t\t   tp ut_argument LOCALE_ARG));\n\n\t    if (to_uppcase)\n\t      while (old_start < p)\n\t\t{\n\t\t  *old_start = TOUPPER ((UCHAR_T) *old_start, loc);\n\t\t  ++old_start;\n\t\t}\n\t  }",
        "{",
        "CHAR_T *old_start = p;",
        "CHAR_T",
        "*old_start = p",
        "*old_start",
        "*",
        "old_start",
        "=",
        "p",
        ";",
        "size_t len = my_strftime (NULL, (size_t) -1, subfmt,\n\t\t\t\t      tp ut_argument LOCALE_ARG);",
        "size_t",
        "len = my_strftime (NULL, (size_t) -1, subfmt,\n\t\t\t\t      tp ut_argument LOCALE_ARG)",
        "len",
        "=",
        "my_strftime (NULL, (size_t) -1, subfmt,\n\t\t\t\t      tp ut_argument LOCALE_ARG)",
        "my_strftime",
        "(NULL, (size_t) -1, subfmt,\n\t\t\t\t      tp ut_argument LOCALE_ARG)",
        "(",
        "NULL",
        ",",
        "(size_t) -1",
        "(",
        "size_t",
        "size_t",
        ")",
        "-1",
        ",",
        "subfmt",
        ",",
        "tp ut_argument",
        "tp",
        "ut_argument",
        "LOCALE_ARG",
        ")",
        ";",
        "add (len, my_strftime (p, maxsize - i, subfmt,\n\t\t\t\t   tp ut_argument LOCALE_ARG));",
        "add (len, my_strftime (p, maxsize - i, subfmt,\n\t\t\t\t   tp ut_argument LOCALE_ARG))",
        "add",
        "(len, my_strftime (p, maxsize - i, subfmt,\n\t\t\t\t   tp ut_argument LOCALE_ARG))",
        "(",
        "len",
        ",",
        "my_strftime (p, maxsize - i, subfmt,\n\t\t\t\t   tp ut_argument LOCALE_ARG)",
        "my_strftime",
        "(p, maxsize - i, subfmt,\n\t\t\t\t   tp ut_argument LOCALE_ARG)",
        "(",
        "p",
        ",",
        "maxsize - i",
        "maxsize",
        "-",
        "i",
        ",",
        "subfmt",
        ",",
        "tp ut_argument",
        "tp",
        "ut_argument",
        "LOCALE_ARG",
        ")",
        ")",
        ";",
        "if (to_uppcase)\n\t      while (old_start < p)\n\t\t{\n\t\t  *old_start = TOUPPER ((UCHAR_T) *old_start, loc);\n\t\t  ++old_start;\n\t\t}",
        "if",
        "(to_uppcase)",
        "(",
        "to_uppcase",
        ")",
        "while (old_start < p)\n\t\t{\n\t\t  *old_start = TOUPPER ((UCHAR_T) *old_start, loc);\n\t\t  ++old_start;\n\t\t}",
        "while",
        "(old_start < p)",
        "(",
        "old_start < p",
        "old_start",
        "<",
        "p",
        ")",
        "{\n\t\t  *old_start = TOUPPER ((UCHAR_T) *old_start, loc);\n\t\t  ++old_start;\n\t\t}",
        "{",
        "*old_start = TOUPPER ((UCHAR_T) *old_start, loc);",
        "*old_start = TOUPPER ((UCHAR_T) *old_start, loc)",
        "*old_start",
        "*",
        "old_start",
        "=",
        "TOUPPER ((UCHAR_T) *old_start, loc)",
        "TOUPPER",
        "((UCHAR_T) *old_start, loc)",
        "(",
        "(UCHAR_T) *old_start",
        "(UCHAR_T)",
        "(",
        "UCHAR_T",
        ")",
        "*",
        "old_start",
        ",",
        "loc",
        ")",
        ";",
        "++old_start;",
        "++old_start",
        "++",
        "old_start",
        ";",
        "}",
        "}",
        "break;",
        "break",
        ";",
        "#if HAVE_STRFTIME && ! (defined _NL_CURRENT && HAVE_STRUCT_ERA_ENTRY)\n\tunderlying_strftime:\n\t  {\n\t    /* The relevant information is available only via the\n\t       underlying strftime implementation, so use that.  */\n\t    char ufmt[4];\n\t    char *u = ufmt;\n\t    char ubuf[1024]; /* enough for any single format in practice */\n\t    size_t len;\n\t    /* Make sure we're calling the actual underlying strftime.\n\t       In some cases, config.h contains something like\n\t       \"#define strftime rpl_strftime\".  */\n# ifdef strftime\n#  undef strftime\n\t    size_t strftime ();\n# endif\n\n\t    *u++ = '%';\n\t    if (modifier != 0)\n\t      *u++ = modifier;\n\t    *u++ = format_char;\n\t    *u = '\\0';\n\t    len = strftime (ubuf, sizeof ubuf, ufmt, tp);\n\t    if (len == 0 && ubuf[0] != '\\0')\n\t      return 0;\n\t    cpy (len, ubuf);\n\t  }\n\t  break;\n#endif",
        "#if",
        "HAVE_STRFTIME && ! (defined _NL_CURRENT && HAVE_STRUCT_ERA_ENTRY)",
        "HAVE_STRFTIME",
        "&&",
        "! (defined _NL_CURRENT && HAVE_STRUCT_ERA_ENTRY)",
        "!",
        "(defined _NL_CURRENT && HAVE_STRUCT_ERA_ENTRY)",
        "(",
        "defined _NL_CURRENT && HAVE_STRUCT_ERA_ENTRY",
        "defined _NL_CURRENT",
        "defined",
        "_NL_CURRENT",
        "&&",
        "HAVE_STRUCT_ERA_ENTRY",
        ")",
        "\n",
        "underlying_strftime:\n\t  {\n\t    /* The relevant information is available only via the\n\t       underlying strftime implementation, so use that.  */\n\t    char ufmt[4];\n\t    char *u = ufmt;\n\t    char ubuf[1024]; /* enough for any single format in practice */\n\t    size_t len;\n\t    /* Make sure we're calling the actual underlying strftime.\n\t       In some cases, config.h contains something like\n\t       \"#define strftime rpl_strftime\".  */\n# ifdef strftime\n#  undef strftime\n\t    size_t strftime ();\n# endif\n\n\t    *u++ = '%';\n\t    if (modifier != 0)\n\t      *u++ = modifier;\n\t    *u++ = format_char;\n\t    *u = '\\0';\n\t    len = strftime (ubuf, sizeof ubuf, ufmt, tp);\n\t    if (len == 0 && ubuf[0] != '\\0')\n\t      return 0;\n\t    cpy (len, ubuf);\n\t  }",
        "underlying_strftime",
        ":",
        "{\n\t    /* The relevant information is available only via the\n\t       underlying strftime implementation, so use that.  */\n\t    char ufmt[4];\n\t    char *u = ufmt;\n\t    char ubuf[1024]; /* enough for any single format in practice */\n\t    size_t len;\n\t    /* Make sure we're calling the actual underlying strftime.\n\t       In some cases, config.h contains something like\n\t       \"#define strftime rpl_strftime\".  */\n# ifdef strftime\n#  undef strftime\n\t    size_t strftime ();\n# endif\n\n\t    *u++ = '%';\n\t    if (modifier != 0)\n\t      *u++ = modifier;\n\t    *u++ = format_char;\n\t    *u = '\\0';\n\t    len = strftime (ubuf, sizeof ubuf, ufmt, tp);\n\t    if (len == 0 && ubuf[0] != '\\0')\n\t      return 0;\n\t    cpy (len, ubuf);\n\t  }",
        "{",
        "/* The relevant information is available only via the\n\t       underlying strftime implementation, so use that.  */",
        "char ufmt[4];",
        "char",
        "ufmt[4]",
        "ufmt",
        "[",
        "4",
        "]",
        ";",
        "char *u = ufmt;",
        "char",
        "*u = ufmt",
        "*u",
        "*",
        "u",
        "=",
        "ufmt",
        ";",
        "char ubuf[1024];",
        "char",
        "ubuf[1024]",
        "ubuf",
        "[",
        "1024",
        "]",
        ";",
        "/* enough for any single format in practice */",
        "size_t len;",
        "size_t",
        "len",
        ";",
        "/* Make sure we're calling the actual underlying strftime.\n\t       In some cases, config.h contains something like\n\t       \"#define strftime rpl_strftime\".  */",
        "# ifdef strftime\n#  undef strftime\n\t    size_t strftime ();\n# endif",
        "# ifdef",
        "strftime",
        "#  undef strftime\n",
        "#  undef",
        " strftime",
        "\n",
        "size_t strftime ();",
        "size_t"
      ]
    }
  },
  "gawk/gawk-4.2.1/missing_d/strncasecmp.c": {},
  "gawk/gawk-4.2.1/missing_d/strtod.c": {},
  "gawk/gawk-4.2.1/missing_d/strtoul.c": {
    "main": {
      "start_point": [
        180,
        0
      ],
      "end_point": [
        219,
        1
      ],
      "content": "int main(void)\n{\n\tchar *endptr;\n\tunsigned long res1, res2;\n\n\tres1 = strtoul(\"0xdeadBeeF\", & endptr, 0),\n\tres2 = mystrtoul(\"0xdeadBeeF\", & endptr, 0),\nprintf(\"(real,my)strtoul(\\\"0xdeadBeeF\\\", & endptr, 0) is %lu, %lu *endptr = %d\\n\",\n\t\tres1, res2, *endptr);\n\n\tres1 = strtoul(\"0101101\", & endptr, 2),\n\tres2 = mystrtoul(\"0101101\", & endptr, 2),\nprintf(\"(real,my)strtoul(\\\"0101101\\\", & endptr, 2) is %lu, %lu *endptr = %d\\n\",\n\t\tres1, res2, *endptr);\n\n\tres1 = strtoul(\"01011012\", & endptr, 2),\n\tres2 = mystrtoul(\"01011012\", & endptr, 2),\nprintf(\"(real,my)strtoul(\\\"01011012\\\", & endptr, 2) is %lu, %lu *endptr = %d\\n\",\n\t\tres1, res2, *endptr);\n\n\tres1 = strtoul(\"  +42a\", & endptr, 0),\n\tres2 = mystrtoul(\"  +42a\", & endptr, 0),\nprintf(\"(real,my)strtoul(\\\"  +42a\\\", & endptr, 0) is %lu, %lu *endptr = %d\\n\",\n\t\tres1, res2, *endptr);\n\n\tres1 = strtoul(\"0377\", & endptr, 0),\n\tres2 = mystrtoul(\"0377\", & endptr, 0),\nprintf(\"(real,my)strtoul(\\\"0377\\\", & endptr, 0) is %lu, %lu *endptr = %d\\n\",\n\t\tres1, res2, *endptr);\n\n\tres1 = strtoul(\"Z\", & endptr, 36),\n\tres2 = mystrtoul(\"Z\", & endptr, 36),\nprintf(\"(real,my)strtoul(\\\"Z\\\", & endptr, 36) is %lu, %lu *endptr = %d\\n\",\n\t\tres1, res2, *endptr);\n\n\tres1 = strtoul(\"qZ*\", & endptr, 36),\n\tres2 = mystrtoul(\"qZ*\", & endptr, 36),\nprintf(\"(real,my)strtoul(\\\"qZ*\\\", & endptr, 36) is %lu, %lu *endptr = %d\\n\",\n\t\tres1, res2, *endptr);\n}",
      "lines": 40,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "gawk/gawk-4.2.1/missing_d/system.c": {},
  "gawk/gawk-4.2.1/missing_d/tzset.c": {
    "tzset": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "void\ntzset()\n{\n\tstruct timeval tp;\n\tstruct timezone tz;\n\n\t(void) gettimeofday(&tp, &tz);\n\t(void) strcpy(tz1, timezone(tz.tz_minuteswest, 0));\n\t(void) strcpy(tz2, timezone(tz.tz_minuteswest, 1));\n\tdaylight = tz.tz_dsttime;\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "gawk/gawk-4.2.1/missing_d/usleep.c": {
    "usleep": {
      "start_point": [
        7,
        0
      ],
      "end_point": [
        16,
        1
      ],
      "content": "int\nusleep(unsigned int usec)\n{\n\tunsigned int seconds = usec / 1000000;\n\n\t/* Round up: */\n\tseconds += (usec % 1000000 > 0);\t/* 1 or 0 */\n\n\treturn sleep(seconds);\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "gawk/gawk-4.2.1/missing_d/wcmisc.c": {
    "is_blank": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        41,
        1
      ],
      "content": "static int is_blank (int c)\n{\n   return (c == ' ' || c == '\\t');\n}",
      "lines": 4,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "wctype": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "wctype_t wctype(const char *name)\n{\n\tint i;\n\n\tfor (i = 1; classes[i] != NULL; i++)\n\t\tif (strcmp(name, classes[i]) == 0)\n\t\t\treturn i;\n\n\treturn 0;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "wctype_t"
      ]
    },
    "iswctype": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        80,
        1
      ],
      "content": "int iswctype(wint_t wc, wctype_t desc)\n{\n\tint j = sizeof(classes) / sizeof(classes[0]);\n\n\tif (desc >= j || desc == 0)\n\t\treturn 0;\n\n\tswitch (desc) {\n\tcase 1:\t\treturn isalnum(wc);\n\tcase 2:\t\treturn isalpha(wc);\n\tcase 3:\t\treturn is_blank(wc);\n\tcase 4:\t\treturn iscntrl(wc);\n\tcase 5:\t\treturn isdigit(wc);\n\tcase 6:\t\treturn isgraph(wc);\n\tcase 7:\t\treturn islower(wc);\n\tcase 8:\t\treturn isprint(wc);\n\tcase 9:\t\treturn ispunct(wc);\n\tcase 10:\treturn isspace(wc);\n\tcase 11:\treturn isupper(wc);\n\tcase 12:\treturn isxdigit(wc);\n\tdefault:\treturn 0;\n\t}\n}",
      "lines": 23,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "wcscoll": {
      "start_point": [
        84,
        0
      ],
      "end_point": [
        96,
        1
      ],
      "content": "int wcscoll(const wchar_t *ws1, const wchar_t *ws2)\n{\n\tsize_t i;\n\n\tfor (i = 0; ws1[i] != 0 && ws2[i] != 0; i++) {\n\t\tif (ws1[i] < ws2[i])\n\t\t\treturn -1;\n\t\telse if (ws1[i] > ws2[i])\n\t\t\treturn 1;\n\t}\n\n\treturn (ws1[i] - ws2[i]);\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "gawk/gawk-4.2.1/pc/config.h": {},
  "gawk/gawk-4.2.1/pc/dlfcn.h": {},
  "gawk/gawk-4.2.1/pc/getid.c": {
    "getuid": {
      "start_point": [
        4,
        0
      ],
      "end_point": [
        7,
        1
      ],
      "content": "unsigned int getuid (void)\n{\n  return (0);                   /* root! */\n}",
      "lines": 4,
      "depth": 5,
      "decorators": [
        "unsigned int",
        "unsigned",
        "int"
      ]
    },
    "geteuid": {
      "start_point": [
        9,
        0
      ],
      "end_point": [
        12,
        1
      ],
      "content": "unsigned int geteuid (void)\n{\n  return (0);\n}",
      "lines": 4,
      "depth": 5,
      "decorators": [
        "unsigned int",
        "unsigned",
        "int"
      ]
    },
    "getgid": {
      "start_point": [
        14,
        0
      ],
      "end_point": [
        17,
        1
      ],
      "content": "unsigned int getgid (void)\n{\n  return (0);\n}",
      "lines": 4,
      "depth": 5,
      "decorators": [
        "unsigned int",
        "unsigned",
        "int"
      ]
    },
    "getegid": {
      "start_point": [
        19,
        0
      ],
      "end_point": [
        22,
        1
      ],
      "content": "unsigned int getegid (void)\n{\n  return (0);\n}",
      "lines": 4,
      "depth": 5,
      "decorators": [
        "unsigned int",
        "unsigned",
        "int"
      ]
    },
    "getpgrp": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        29,
        1
      ],
      "content": "int getpgrp(void)\n{\n  return (0);\n}",
      "lines": 4,
      "depth": 5,
      "decorators": [
        "int"
      ]
    },
    "getppid": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        35,
        1
      ],
      "content": "int getppid(void)\n{\n  return (0);\n}",
      "lines": 4,
      "depth": 5,
      "decorators": [
        "int"
      ]
    }
  },
  "gawk/gawk-4.2.1/pc/in.h": {},
  "gawk/gawk-4.2.1/pc/popen.c": {
    "unixshell": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "static int\nunixshell(char *p)\n{\n  static char *shell[] = {\"sh\", \"bash\", \"csh\", \"tcsh\", \"sh32\", \"sh16\", \"ksh\", NULL};\n  char **shellp = shell, *s, *q;\n\n  if (p == NULL) return (0);\n  s = p = strdup(p);\n  if ((q = strrchr(p, '\\\\')) != NULL)\n    p = q + 1;\n  if ((q = strrchr(p, '/')) != NULL)\n    p = q + 1;\n  if ((q = strchr(p, '.')) != NULL)\n    *q = '\\0';\n  strlwr(p);\n  do {\n    if (strcmp(*shellp, p) == 0) break;\n  } while (*++shellp);\n  free(s);\n  return(*shellp ? 1 : 0);\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "slashify": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "static char *\nslashify(char *p, char *s)\n{\n  if (unixshell(s))\n    while (s = strchr(p, '\\\\')) *s = '/';\n  else\n    while (s = strchr(p, '/')) *s = '\\\\';\n  return(p);\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nslashify(char *p, char *s)",
        "*"
      ]
    },
    "scriptify": {
      "start_point": [
        68,
        0
      ],
      "end_point": [
        108,
        1
      ],
      "content": "static char *\nscriptify(const char *command)\n{\n  FILE *fp;\n  char *cmd, *name, *s, *p;\n  int i;\n\n  if((name = tempnam(\".\", \"pip\")) == NULL) return(NULL);\n  p = getenv(\"COMSPEC\"); s = getenv(\"SHELL\");\n  cmd = malloc(strlen(name) + (s ? strlen(s) : 0) + 9); *cmd = '\\0';\n  if (s) {\n    slashify(strcpy(cmd, s), p);\n    p = s;\n  }\n  slashify(name, p);\n  if (! (i = unixshell(p))) {\n    char *p = (char *) realloc(name, strlen(name) + 5);\n    if (p == NULL) {\n\tfree(cmd);\n\treturn NULL;\n    }\n    name = p;\n    strcat(name, \".bat\");\n  }\n  if (s) sprintf(cmd + strlen(cmd), \" %cc \", unixshell(s) ? '-' : '/');\n  strcpy(p = cmd + strlen(cmd), name); free(name);\n\n  if ((fp = fopen(p, i ? \"wb\" : \"w\")) != NULL) {\n    if (! i) fputs(\"@echo off\\n\", fp);\n    i = strlen(command);\n    if ((fwrite(command, 1, i, fp) < i) || (fputc('\\n', fp) == EOF)) {\n      free(cmd);\n      cmd = NULL;\n    }\n  } else {\n    free(cmd);\n    cmd = NULL;\n  }\n  if (fp) fclose(fp);\n  return(cmd);\n}",
      "lines": 41,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nscriptify(const char *command)",
        "*"
      ]
    },
    "unlink_and_free": {
      "start_point": [
        110,
        0
      ],
      "end_point": [
        120,
        1
      ],
      "content": "static void\nunlink_and_free(char *cmd)\n{\n  char *s;\n\n  if (s = strrchr(cmd, ' '))\n    s++;\n  else\n    s = cmd;\n  unlink(s); free(cmd);\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "os_system": {
      "start_point": [
        123,
        0
      ],
      "end_point": [
        132,
        1
      ],
      "content": "int\nos_system(const char *cmd)\n{\n  char *cmdexe = getenv(\"ComSpec\");\n  char *cmd1 = quote_cmd(cmd);\n  int i = spawnl(P_WAIT, cmdexe, \"cmd.exe\", \"/c\", cmd1, NULL);\n\n  free(cmd1);\n  return(i);\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "kill": {
      "start_point": [
        135,
        0
      ],
      "end_point": [
        177,
        1
      ],
      "content": "int\nkill (int pid, int sig)\n{\n  HANDLE ph;\n  int retval = 0;\n\n  /* We only support SIGKILL.  */\n  if (sig != SIGKILL)\n    {\n      errno = ENOSYS;\n      return -1;\n    }\n\n  ph = OpenProcess(PROCESS_TERMINATE, FALSE, pid);\n  if (ph)\n    {\n      BOOL status = TerminateProcess(ph, -1);\n\n      if (!status)\n\t{\n\t  errno = EPERM;\n\t  retval = -1;\n\t}\n    }\n  else\n    {\n      /* If we cannot open the process, it means we eaither aren't\n\t allowed to (e.g., a process of another user), or such a\n\t process doesn't exist.  */\n      switch (GetLastError ())\n\t{\n\t  case ERROR_ACCESS_DENIED:\n\t    errno = EPERM;\n\t    break;\n\t  default:\n\t    errno = ESRCH;\n\t    break;\n\t}\n      retval = -1;\n    }\n  CloseHandle (ph);\n  return retval;\n}",
      "lines": 43,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "quote_cmd": {
      "start_point": [
        179,
        0
      ],
      "end_point": [
        192,
        1
      ],
      "content": "char *\nquote_cmd(const char *cmd)\n{\n  char *quoted;\n\n  /* The command will be invoked via cmd.exe, whose behavior wrt\n     quoted commands is to remove the first and the last quote\n     characters, and leave the rest (including any quote characters\n     inside the outer pair) intact.  */\n  quoted = malloc(strlen (cmd) + 2 + 1);\n  sprintf(quoted, \"\\\"%s\\\"\", cmd);\n\n  return quoted;\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "char",
        "*\nquote_cmd(const char *cmd)",
        "*"
      ]
    },
    "os_popen": {
      "start_point": [
        200,
        0
      ],
      "end_point": [
        251,
        1
      ],
      "content": "FILE *\nos_popen(const char *command, const char *mode )\n{\n    FILE *current;\n    char *name;\n    int cur;\n    char curmode[4];\n\n    if (*mode != 'r' && *mode != 'w')\n      return NULL;\n    strncpy(curmode, mode, 3); curmode[3] = '\\0';\n\n#if defined(__MINGW32__)\n    current = popen(command, mode);\n    cur = fileno(current);\n    strcpy(pipes[cur].pmode, curmode);\n    return(current);\n#endif\n\n    /*\n    ** get a name to use.\n    */\n    if((name = tempnam(\".\",\"pip\"))==NULL)\n        return NULL;\n    /*\n    ** If we're reading, just call system to get a file filled with\n    ** output.\n    */\n    if (*curmode == 'r') {\n        FILE *fp;\n        if ((cur = dup(fileno(stdout))) == -1)\n\t    return NULL;\n\t*curmode = 'w';\n        if ((current = freopen(name, curmode, stdout)) == NULL)\n\t    return NULL;\n        os_system(command);\n        if (dup2(cur, fileno(stdout)) == -1)\n\t    return NULL;\n\tclose(cur);\n\t*curmode = 'r';\n        if ((current = fopen(name, curmode)) == NULL)\n            return NULL;\n    } else {\n        if ((current = fopen(name, curmode)) == NULL)\n            return NULL;\n    }\n    cur = fileno(current);\n    pipes[cur].name = name;\n    strcpy(pipes[cur].pmode, curmode);\n    pipes[cur].command = strdup(command);\n    return current;\n}",
      "lines": 52,
      "depth": 14,
      "decorators": [
        "FILE",
        "*\nos_popen(const char *command, const char *mode )",
        "*"
      ]
    },
    "os_pclose": {
      "start_point": [
        253,
        0
      ],
      "end_point": [
        304,
        1
      ],
      "content": "int\nos_pclose( FILE * current)\n{\n    int cur = fileno(current);\n    int fd, rval;\n\n#if defined(__MINGW32__)\n    rval = pclose(current);\n    *pipes[cur].pmode = '\\0';\n    return rval;\n#endif\n\n    /*\n    ** check for an open file.\n    */\n    switch (*pipes[cur].pmode) {\n    case 'r':\n        /*\n        ** input pipes are just files we're done with.\n        */\n        rval = fclose(current);\n        unlink(pipes[cur].name);\n\tbreak;\n    case 'w':\n        /*\n        ** output pipes are temporary files we have\n        ** to cram down the throats of programs.\n        */\n        fclose(current);\n\trval = -1;\n\tif ((fd = dup(fileno(stdin))) != -1) {\n\t  char *mode = pipes[cur].pmode; *mode = 'r';\n\t  if (current = freopen(pipes[cur].name, mode, stdin)) {\n\t    rval = os_system(pipes[cur].command);\n\t    fclose(current);\n\t    if (dup2(fd, fileno(stdin)) == -1) rval = -1;\n\t    close(fd);\n\t  }\n\t}\n        unlink(pipes[cur].name);\n\tbreak;\n    default:\n      return -1;\n    }\n    /*\n    ** clean up current pipe.\n    */\n    *pipes[cur].pmode = '\\0';\n    free(pipes[cur].name);\n    free(pipes[cur].command);\n    return rval;\n}",
      "lines": 52,
      "depth": 17,
      "decorators": [
        "int"
      ]
    }
  },
  "gawk/gawk-4.2.1/pc/popen.h": {},
  "gawk/gawk-4.2.1/pc/socket.h": {},
  "gawk/gawk-4.2.1/posix/gawkmisc.c": {
    "gawk_name": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        46,
        1
      ],
      "content": "char *\ngawk_name(const char *filespec)\n{\n\tchar *p;\n\n\t/* \"path/name\" -> \"name\" */\n\tp = strrchr(filespec, '/');\n\treturn (p == NULL ? (char *) filespec : p + 1);\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "char",
        "*\ngawk_name(const char *filespec)",
        "*"
      ]
    },
    "os_arg_fixup": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "void\nos_arg_fixup(int *argcp, char ***argvp)\n{\n\t/* no-op */\n\treturn;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "os_devopen": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "int\nos_devopen(const char *name, int flag)\n{\n\t/* no-op */\n\treturn INVALID_HANDLE;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "optimal_bufsize": {
      "start_point": [
        90,
        0
      ],
      "end_point": [
        142,
        1
      ],
      "content": "size_t\noptimal_bufsize(int fd, struct stat *stb)\n{\n\tchar *val;\n\tstatic size_t env_val = 0;\n\tstatic bool first = true;\n\tstatic bool exact = false;\n\n\t/* force all members to zero in case OS doesn't use all of them. */\n\tmemset(stb, '\\0', sizeof(struct stat));\n\n\t/* always stat, in case stb is used by higher level code. */\n\tif (fstat(fd, stb) == -1)\n\t\tfatal(\"can't stat fd %d (%s)\", fd, strerror(errno));\n\n\tif (first) {\n\t\tfirst = false;\n\n\t\tif ((val = getenv(\"AWKBUFSIZE\")) != NULL) {\n\t\t\tif (strcmp(val, \"exact\") == 0)\n\t\t\t\texact = true;\n\t\t\telse if (isdigit((unsigned char) *val)) {\n\t\t\t\tfor (; *val && isdigit((unsigned char) *val); val++)\n\t\t\t\t\tenv_val = (env_val * 10) + *val - '0';\n\n\t\t\t\treturn env_val;\n\t\t\t}\n\t\t}\n\t} else if (! exact && env_val > 0)\n\t\treturn env_val;\n\t/* else\n\t  \tfall through */\n\n\t/*\n\t * System V.n, n < 4, doesn't have the file system block size in the\n\t * stat structure. So we have to make some sort of reasonable\n\t * guess. We use stdio's BUFSIZ, since that is what it was\n\t * meant for in the first place.\n\t */\n#ifdef HAVE_STRUCT_STAT_ST_BLKSIZE\n#define DEFBLKSIZE\t(stb->st_blksize > 0 ? stb->st_blksize : BUFSIZ)\n#else\n#define DEFBLKSIZE\tBUFSIZ\n#endif\n\n\tif (S_ISREG(stb->st_mode)\t\t/* regular file */\n\t    && 0 < stb->st_size\t\t\t/* non-zero size */\n\t    && (stb->st_size < DEFBLKSIZE\t/* small file */\n\t\t|| exact))\t\t\t/* or debugging */\n\t\treturn stb->st_size;\t\t/* use file size */\n\n\treturn DEFBLKSIZE;\n}",
      "lines": 53,
      "depth": 17,
      "decorators": [
        "size_t"
      ]
    },
    "ispath": {
      "start_point": [
        146,
        0
      ],
      "end_point": [
        150,
        1
      ],
      "content": "int\nispath(const char *file)\n{\n\treturn (strchr(file, '/') != NULL);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "isdirpunct": {
      "start_point": [
        154,
        0
      ],
      "end_point": [
        158,
        1
      ],
      "content": "int\nisdirpunct(int c)\n{\n\treturn (c == '/');\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "os_close_on_exec": {
      "start_point": [
        162,
        0
      ],
      "end_point": [
        190,
        1
      ],
      "content": "void\nos_close_on_exec(int fd, const char *name, const char *what, const char *dir)\n{\n\tint curflags = 0;\n\n\tif (fd <= 2)\t/* sanity */\n\t\treturn;\n\n\t/*\n\t * Per POSIX, use Read/Modify/Write - get the flags,\n\t * add FD_CLOEXEC, set the flags back.\n\t */\n\n\tif ((curflags = fcntl(fd, F_GETFD)) < 0) {\n\t\twarning(_(\"%s %s `%s': could not get fd flags: (fcntl F_GETFD: %s)\"),\n\t\t\twhat, dir, name, strerror(errno));\n\t\treturn;\n\t}\n\n#ifndef FD_CLOEXEC\n#define FD_CLOEXEC\t1\n#endif\n\n\tcurflags |= FD_CLOEXEC;\n\n\tif (fcntl(fd, F_SETFD, curflags) < 0)\n\t\twarning(_(\"%s %s `%s': could not set close-on-exec: (fcntl F_SETFD: %s)\"),\n\t\t\twhat, dir, name, strerror(errno));\n}",
      "lines": 29,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "os_isdir": {
      "start_point": [
        198,
        0
      ],
      "end_point": [
        204,
        1
      ],
      "content": "int\nos_isdir(int fd)\n{\n\tstruct stat sbuf;\n\n\treturn (fstat(fd, &sbuf) == 0 && S_ISDIR(sbuf.st_mode));\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "os_isreadable": {
      "start_point": [
        208,
        0
      ],
      "end_point": [
        232,
        1
      ],
      "content": "int\nos_isreadable(const awk_input_buf_t *iobuf, bool *isdir)\n{\n\t*isdir = false;\n\n\tif (iobuf->fd == INVALID_HANDLE)\n\t\treturn false;\n\n\tswitch (iobuf->sbuf.st_mode & S_IFMT) {\n\tcase S_IFREG:\n\tcase S_IFCHR:\t/* ttys, /dev/null, .. */\n#ifdef S_IFSOCK\n\tcase S_IFSOCK:\n#endif\n#ifdef S_IFIFO\n\tcase S_IFIFO:\n#endif\n\t\treturn true;\n\tcase S_IFDIR:\n\t\t*isdir = true;\n\t\t/* fall through */\n\tdefault:\n\t\treturn false;\n\t}\n}",
      "lines": 25,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "os_is_setuid": {
      "start_point": [
        236,
        0
      ],
      "end_point": [
        245,
        1
      ],
      "content": "int\nos_is_setuid()\n{\n\tlong uid, euid;\n\n\tuid = getuid();\n\teuid = geteuid();\n\n\treturn (euid == 0 && euid != uid);\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "os_setbinmode": {
      "start_point": [
        249,
        0
      ],
      "end_point": [
        256,
        1
      ],
      "content": "int\nos_setbinmode(int fd, int mode)\n{\n#ifdef __CYGWIN__\n\tsetmode (fd, mode);\n#endif\n\treturn 0;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "os_restore_mode": {
      "start_point": [
        260,
        0
      ],
      "end_point": [
        265,
        1
      ],
      "content": "void\nos_restore_mode(int fd)\n{\n\t/* no-op */\n\treturn;\n}",
      "lines": 6,
      "depth": 5,
      "decorators": [
        "void"
      ]
    },
    "os_isatty": {
      "start_point": [
        269,
        0
      ],
      "end_point": [
        273,
        1
      ],
      "content": "int\nos_isatty(int fd)\n{\n\treturn isatty(fd);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "files_are_same": {
      "start_point": [
        277,
        0
      ],
      "end_point": [
        285,
        1
      ],
      "content": "int\nfiles_are_same(char *path, SRCFILE *src)\n{\n\tstruct stat st;\n\n\treturn (stat(path, & st) == 0\n\t\t&& st.st_dev == src->sbuf.st_dev\n\t\t&& st.st_ino == src->sbuf.st_ino);\n}",
      "lines": 9,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "init_sockets": {
      "start_point": [
        287,
        0
      ],
      "end_point": [
        290,
        1
      ],
      "content": "void\ninit_sockets(void)\n{\n}",
      "lines": 4,
      "depth": 5,
      "decorators": [
        "void"
      ]
    }
  },
  "gawk/gawk-4.2.1/support/dfa.c": {
    "streq": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "static bool\nstreq (char const *a, char const *b)\n{\n  return strcmp (a, b) == 0;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "isasciidigit": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "static bool\nisasciidigit (char c)\n{\n  return '0' <= c && c <= '9';\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "is_blank": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        95,
        1
      ],
      "content": "static int\nis_blank (int c)\n{\n   return (c == ' ' || c == '\\t');\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "to_uchar": {
      "start_point": [
        148,
        0
      ],
      "end_point": [
        152,
        1
      ],
      "content": "static unsigned char\nto_uchar (char ch)\n{\n  return ch;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "unsigned char",
        "unsigned",
        "char"
      ]
    },
    "newline_constraint": {
      "start_point": [
        189,
        0
      ],
      "end_point": [
        193,
        1
      ],
      "content": "static int\nnewline_constraint (int constraint)\n{\n  return (constraint >> 6) & 7;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "letter_constraint": {
      "start_point": [
        194,
        0
      ],
      "end_point": [
        198,
        1
      ],
      "content": "static int\nletter_constraint (int constraint)\n{\n  return (constraint >> 3) & 7;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "other_constraint": {
      "start_point": [
        199,
        0
      ],
      "end_point": [
        203,
        1
      ],
      "content": "static int\nother_constraint (int constraint)\n{\n  return constraint & 7;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "succeeds_in_context": {
      "start_point": [
        205,
        0
      ],
      "end_point": [
        212,
        1
      ],
      "content": "static bool\nsucceeds_in_context (int constraint, int prev, int curr)\n{\n  return !! (((curr & CTX_NONE      ? other_constraint (constraint) : 0) \\\n              | (curr & CTX_LETTER  ? letter_constraint (constraint) : 0) \\\n              | (curr & CTX_NEWLINE ? newline_constraint (constraint) : 0)) \\\n             & prev);\n}",
      "lines": 8,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "prev_newline_dependent": {
      "start_point": [
        215,
        0
      ],
      "end_point": [
        219,
        1
      ],
      "content": "static bool\nprev_newline_dependent (int constraint)\n{\n  return ((constraint ^ constraint >> 2) & 0111) != 0;\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "prev_letter_dependent": {
      "start_point": [
        220,
        0
      ],
      "end_point": [
        224,
        1
      ],
      "content": "static bool\nprev_letter_dependent (int constraint)\n{\n  return ((constraint ^ constraint >> 1) & 0111) != 0;\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "accepting": {
      "start_point": [
        603,
        0
      ],
      "end_point": [
        607,
        1
      ],
      "content": "static bool\naccepting (state_num s, struct dfa const *r)\n{\n  return r->states[s].constraint != 0;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "accepts_in_context": {
      "start_point": [
        610,
        0
      ],
      "end_point": [
        614,
        1
      ],
      "content": "static bool\naccepts_in_context (int prev, int curr, state_num state, struct dfa const *dfa)\n{\n  return succeeds_in_context (dfa->states[state].constraint, prev, curr);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "mbs_to_wchar": {
      "start_point": [
        635,
        0
      ],
      "end_point": [
        655,
        1
      ],
      "content": "static size_t\nmbs_to_wchar (wint_t *pwc, char const *s, size_t n, struct dfa *d)\n{\n  unsigned char uc = s[0];\n  wint_t wc = d->localeinfo.sbctowc[uc];\n\n  if (wc == WEOF)\n    {\n      wchar_t wch;\n      size_t nbytes = mbrtowc (&wch, s, n, &d->mbs);\n      if (0 < nbytes && nbytes < (size_t) -2)\n        {\n          *pwc = wch;\n          return nbytes;\n        }\n      memset (&d->mbs, 0, sizeof d->mbs);\n    }\n\n  *pwc = wc;\n  return 1;\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "prtok": {
      "start_point": [
        659,
        0
      ],
      "end_point": [
        731,
        1
      ],
      "content": "static void\nprtok (token t)\n{\n  if (t < 0)\n    fprintf (stderr, \"END\");\n  else if (t < NOTCHAR)\n    {\n      unsigned int ch = t;\n      fprintf (stderr, \"0x%02x\", ch);\n    }\n  else\n    {\n      char const *s;\n      switch (t)\n        {\n        case EMPTY:\n          s = \"EMPTY\";\n          break;\n        case BACKREF:\n          s = \"BACKREF\";\n          break;\n        case BEGLINE:\n          s = \"BEGLINE\";\n          break;\n        case ENDLINE:\n          s = \"ENDLINE\";\n          break;\n        case BEGWORD:\n          s = \"BEGWORD\";\n          break;\n        case ENDWORD:\n          s = \"ENDWORD\";\n          break;\n        case LIMWORD:\n          s = \"LIMWORD\";\n          break;\n        case NOTLIMWORD:\n          s = \"NOTLIMWORD\";\n          break;\n        case QMARK:\n          s = \"QMARK\";\n          break;\n        case STAR:\n          s = \"STAR\";\n          break;\n        case PLUS:\n          s = \"PLUS\";\n          break;\n        case CAT:\n          s = \"CAT\";\n          break;\n        case OR:\n          s = \"OR\";\n          break;\n        case LPAREN:\n          s = \"LPAREN\";\n          break;\n        case RPAREN:\n          s = \"RPAREN\";\n          break;\n        case ANYCHAR:\n          s = \"ANYCHAR\";\n          break;\n        case MBCSET:\n          s = \"MBCSET\";\n          break;\n        default:\n          s = \"CSET\";\n          break;\n        }\n      fprintf (stderr, \"%s\", s);\n    }\n}",
      "lines": 73,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "tstbit": {
      "start_point": [
        736,
        0
      ],
      "end_point": [
        740,
        1
      ],
      "content": "static bool\ntstbit (unsigned int b, charclass const *c)\n{\n  return c->w[b / CHARCLASS_WORD_BITS] >> b % CHARCLASS_WORD_BITS & 1;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "setbit": {
      "start_point": [
        742,
        0
      ],
      "end_point": [
        747,
        1
      ],
      "content": "static void\nsetbit (unsigned int b, charclass *c)\n{\n  charclass_word one = 1;\n  c->w[b / CHARCLASS_WORD_BITS] |= one << b % CHARCLASS_WORD_BITS;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "clrbit": {
      "start_point": [
        749,
        0
      ],
      "end_point": [
        754,
        1
      ],
      "content": "static void\nclrbit (unsigned int b, charclass *c)\n{\n  charclass_word one = 1;\n  c->w[b / CHARCLASS_WORD_BITS] &= ~(one << b % CHARCLASS_WORD_BITS);\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "zeroset": {
      "start_point": [
        756,
        0
      ],
      "end_point": [
        760,
        1
      ],
      "content": "static void\nzeroset (charclass *s)\n{\n  memset (s, 0, sizeof *s);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "fillset": {
      "start_point": [
        762,
        0
      ],
      "end_point": [
        767,
        1
      ],
      "content": "static void\nfillset (charclass *s)\n{\n  for (int i = 0; i < CHARCLASS_WORDS; i++)\n    s->w[i] = CHARCLASS_WORD_MASK;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "notset": {
      "start_point": [
        769,
        0
      ],
      "end_point": [
        774,
        1
      ],
      "content": "static void\nnotset (charclass *s)\n{\n  for (int i = 0; i < CHARCLASS_WORDS; ++i)\n    s->w[i] = CHARCLASS_WORD_MASK & ~s->w[i];\n}",
      "lines": 6,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "equal": {
      "start_point": [
        776,
        0
      ],
      "end_point": [
        783,
        1
      ],
      "content": "static bool\nequal (charclass const *s1, charclass const *s2)\n{\n  charclass_word w = 0;\n  for (int i = 0; i < CHARCLASS_WORDS; i++)\n    w |= s1->w[i] ^ s2->w[i];\n  return w == 0;\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "emptyset": {
      "start_point": [
        785,
        0
      ],
      "end_point": [
        792,
        1
      ],
      "content": "static bool\nemptyset (charclass const *s)\n{\n  charclass_word w = 0;\n  for (int i = 0; i < CHARCLASS_WORDS; i++)\n    w |= s->w[i];\n  return w == 0;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "xpalloc": {
      "start_point": [
        810,
        0
      ],
      "end_point": [
        852,
        1
      ],
      "content": "static void *\nxpalloc (void *pa, ptrdiff_t *nitems, ptrdiff_t nitems_incr_min,\n\t ptrdiff_t nitems_max, ptrdiff_t item_size)\n{\n  ptrdiff_t n0 = *nitems;\n\n  /* The approximate size to use for initial small allocation\n     requests.  This is the largest \"small\" request for the GNU C\n     library malloc.  */\n  enum { DEFAULT_MXFAST = 64 * sizeof (size_t) / 4 };\n\n  /* If the array is tiny, grow it to about (but no greater than)\n     DEFAULT_MXFAST bytes.  Otherwise, grow it by about 50%.\n     Adjust the growth according to three constraints: NITEMS_INCR_MIN,\n     NITEMS_MAX, and what the C language can represent safely.  */\n\n  ptrdiff_t n, nbytes;\n  if (INT_ADD_WRAPV (n0, n0 >> 1, &n))\n    n = PTRDIFF_MAX;\n  if (0 <= nitems_max && nitems_max < n)\n    n = nitems_max;\n\n  ptrdiff_t adjusted_nbytes\n    = ((INT_MULTIPLY_WRAPV (n, item_size, &nbytes) || SIZE_MAX < nbytes)\n       ? MIN (PTRDIFF_MAX, SIZE_MAX)\n       : nbytes < DEFAULT_MXFAST ? DEFAULT_MXFAST : 0);\n  if (adjusted_nbytes)\n    {\n      n = adjusted_nbytes / item_size;\n      nbytes = adjusted_nbytes - adjusted_nbytes % item_size;\n    }\n\n  if (! pa)\n    *nitems = 0;\n  if (n - n0 < nitems_incr_min\n      && (INT_ADD_WRAPV (n0, nitems_incr_min, &n)\n\t  || (0 <= nitems_max && nitems_max < n)\n\t  || INT_MULTIPLY_WRAPV (n, item_size, &nbytes)))\n    xalloc_die ();\n  pa = xrealloc (pa, nbytes);\n  *nitems = n;\n  return pa;\n}",
      "lines": 43,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nxpalloc (void *pa, ptrdiff_t *nitems, ptrdiff_t nitems_incr_min,\n\t ptrdiff_t nitems_max, ptrdiff_t item_size)",
        "*"
      ]
    },
    "maybe_realloc": {
      "start_point": [
        863,
        0
      ],
      "end_point": [
        870,
        1
      ],
      "content": "static void *\nmaybe_realloc (void *pa, ptrdiff_t i, ptrdiff_t *nitems,\n               ptrdiff_t nitems_max, ptrdiff_t item_size)\n{\n  if (i < *nitems)\n    return pa;\n  return xpalloc (pa, nitems, 1, nitems_max, item_size);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nmaybe_realloc (void *pa, ptrdiff_t i, ptrdiff_t *nitems,\n               ptrdiff_t nitems_max, ptrdiff_t item_size)",
        "*"
      ]
    },
    "charclass_index": {
      "start_point": [
        873,
        0
      ],
      "end_point": [
        886,
        1
      ],
      "content": "static ptrdiff_t\ncharclass_index (struct dfa *d, charclass *s)\n{\n  ptrdiff_t i;\n\n  for (i = 0; i < d->cindex; ++i)\n    if (equal (s, &d->charclasses[i]))\n      return i;\n  d->charclasses = maybe_realloc (d->charclasses, d->cindex, &d->calloc,\n                                  TOKEN_MAX - CSET, sizeof *d->charclasses);\n  ++d->cindex;\n  d->charclasses[i] = *s;\n  return i;\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "ptrdiff_t"
      ]
    },
    "unibyte_word_constituent": {
      "start_point": [
        888,
        0
      ],
      "end_point": [
        892,
        1
      ],
      "content": "static bool\nunibyte_word_constituent (struct dfa const *dfa, unsigned char c)\n{\n  return dfa->localeinfo.sbctowc[c] != WEOF && (isalnum (c) || (c) == '_');\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "char_context": {
      "start_point": [
        894,
        0
      ],
      "end_point": [
        902,
        1
      ],
      "content": "static int\nchar_context (struct dfa const *dfa, unsigned char c)\n{\n  if (c == dfa->syntax.eolbyte && !dfa->syntax.anchor)\n    return CTX_NEWLINE;\n  if (unibyte_word_constituent (dfa, c))\n    return CTX_LETTER;\n  return CTX_NONE;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "dfacopysyntax": {
      "start_point": [
        907,
        0
      ],
      "end_point": [
        919,
        1
      ],
      "content": "void\ndfacopysyntax (struct dfa *to, const struct dfa *from)\n{\n  to->dfaexec = from->dfaexec;\n  to->simple_locale = from->simple_locale;\n  to->localeinfo = from->localeinfo;\n\n  to->fast = from->fast;\n\n  to->canychar = from->canychar;\n  to->lex.cur_mb_len = from->lex.cur_mb_len;\n  to->syntax = from->syntax;\n}",
      "lines": 13,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "setbit_wc": {
      "start_point": [
        926,
        0
      ],
      "end_point": [
        935,
        1
      ],
      "content": "static bool\nsetbit_wc (wint_t wc, charclass *c)\n{\n  int b = wctob (wc);\n  if (b < 0)\n    return false;\n\n  setbit (b, c);\n  return true;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "setbit_case_fold_c": {
      "start_point": [
        939,
        0
      ],
      "end_point": [
        946,
        1
      ],
      "content": "static void\nsetbit_case_fold_c (int b, charclass *c)\n{\n  int ub = toupper (b);\n  for (int i = 0; i < NOTCHAR; i++)\n    if (toupper (i) == ub)\n      setbit (i, c);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "using_simple_locale": {
      "start_point": [
        950,
        0
      ],
      "end_point": [
        978,
        1
      ],
      "content": "static bool\nusing_simple_locale (bool multibyte)\n{\n  /* The native character set is known to be compatible with\n     the C locale.  The following test isn't perfect, but it's good\n     enough in practice, as only ASCII and EBCDIC are in common use\n     and this test correctly accepts ASCII and rejects EBCDIC.  */\n  enum { native_c_charset =\n    ('\\b' == 8 && '\\t' == 9 && '\\n' == 10 && '\\v' == 11 && '\\f' == 12\n     && '\\r' == 13 && ' ' == 32 && '!' == 33 && '\"' == 34 && '#' == 35\n     && '%' == 37 && '&' == 38 && '\\'' == 39 && '(' == 40 && ')' == 41\n     && '*' == 42 && '+' == 43 && ',' == 44 && '-' == 45 && '.' == 46\n     && '/' == 47 && '0' == 48 && '9' == 57 && ':' == 58 && ';' == 59\n     && '<' == 60 && '=' == 61 && '>' == 62 && '?' == 63 && 'A' == 65\n     && 'Z' == 90 && '[' == 91 && '\\\\' == 92 && ']' == 93 && '^' == 94\n     && '_' == 95 && 'a' == 97 && 'z' == 122 && '{' == 123 && '|' == 124\n     && '}' == 125 && '~' == 126)\n  };\n\n  if (!native_c_charset || multibyte)\n    return false;\n  else\n    {\n      /* Treat C and POSIX locales as being compatible.  Also, treat\n         errors as compatible, as these are invariably from stubs.  */\n      char const *loc = setlocale (LC_ALL, NULL);\n      return !loc || streq (loc, \"C\") || streq (loc, \"POSIX\");\n    }\n}",
      "lines": 29,
      "depth": 50,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "fetch_wc": {
      "start_point": [
        986,
        0
      ],
      "end_point": [
        996,
        1
      ],
      "content": "static int\nfetch_wc (struct dfa *dfa)\n{\n  size_t nbytes = mbs_to_wchar (&dfa->lex.wctok, dfa->lex.ptr, dfa->lex.left,\n                                dfa);\n  dfa->lex.cur_mb_len = nbytes;\n  int c = nbytes == 1 ? to_uchar (dfa->lex.ptr[0]) : EOF;\n  dfa->lex.ptr += nbytes;\n  dfa->lex.left -= nbytes;\n  return c;\n}",
      "lines": 11,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "bracket_fetch_wc": {
      "start_point": [
        1000,
        0
      ],
      "end_point": [
        1006,
        1
      ],
      "content": "static int\nbracket_fetch_wc (struct dfa *dfa)\n{\n  if (! dfa->lex.left)\n    dfaerror (_(\"unbalanced [\"));\n  return fetch_wc (dfa);\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "_GL_ATTRIBUTE_PURE": [
      {
        "start_point": [
          1037,
          0
        ],
        "end_point": [
          1044,
          1
        ],
        "content": "static const struct dfa_ctype *_GL_ATTRIBUTE_PURE\nfind_pred (const char *str)\n{\n  for (unsigned int i = 0; prednames[i].name; ++i)\n    if (streq (str, prednames[i].name))\n      return &prednames[i];\n  return NULL;\n}",
        "lines": 8,
        "depth": 10,
        "decorators": [
          "static",
          "static",
          "const",
          "const",
          "struct dfa_ctype",
          "struct",
          "dfa_ctype",
          "*_GL_ATTRIBUTE_PURE\nfind_pred (const char *str)",
          "*"
        ]
      },
      {
        "start_point": [
          1904,
          0
        ],
        "end_point": [
          1922,
          1
        ],
        "content": "static size_t _GL_ATTRIBUTE_PURE\nnsubtoks (struct dfa const *dfa, size_t tindex)\n{\n  switch (dfa->tokens[tindex - 1])\n    {\n    default:\n      return 1;\n    case QMARK:\n    case STAR:\n    case PLUS:\n      return 1 + nsubtoks (dfa, tindex - 1);\n    case CAT:\n    case OR:\n      {\n        size_t ntoks1 = nsubtoks (dfa, tindex - 1);\n        return 1 + ntoks1 + nsubtoks (dfa, tindex - 1 - ntoks1);\n      }\n    }\n}",
        "lines": 19,
        "depth": 13,
        "decorators": [
          "static",
          "static",
          "size_t"
        ]
      }
    ],
    "parse_bracket_exp": {
      "start_point": [
        1048,
        0
      ],
      "end_point": [
        1271,
        1
      ],
      "content": "static token\nparse_bracket_exp (struct dfa *dfa)\n{\n  /* This is a bracket expression that dfaexec is known to\n     process correctly.  */\n  bool known_bracket_exp = true;\n\n  /* Used to warn about [:space:].\n     Bit 0 = first character is a colon.\n     Bit 1 = last character is a colon.\n     Bit 2 = includes any other character but a colon.\n     Bit 3 = includes ranges, char/equiv classes or collation elements.  */\n  int colon_warning_state;\n\n  dfa->lex.brack.nchars = 0;\n  charclass ccl;\n  zeroset (&ccl);\n  int c = bracket_fetch_wc (dfa);\n  bool invert = c == '^';\n  if (invert)\n    {\n      c = bracket_fetch_wc (dfa);\n      known_bracket_exp = dfa->simple_locale;\n    }\n  wint_t wc = dfa->lex.wctok;\n  int c1;\n  wint_t wc1;\n  colon_warning_state = (c == ':');\n  do\n    {\n      c1 = NOTCHAR;\t/* Mark c1 as not initialized.  */\n      colon_warning_state &= ~2;\n\n      /* Note that if we're looking at some other [:...:] construct,\n         we just treat it as a bunch of ordinary characters.  We can do\n         this because we assume regex has checked for syntax errors before\n         dfa is ever called.  */\n      if (c == '[')\n        {\n          c1 = bracket_fetch_wc (dfa);\n          wc1 = dfa->lex.wctok;\n\n          if ((c1 == ':' && (dfa->syntax.syntax_bits & RE_CHAR_CLASSES))\n              || c1 == '.' || c1 == '=')\n            {\n              enum { MAX_BRACKET_STRING_LEN = 32 };\n              char str[MAX_BRACKET_STRING_LEN + 1];\n              size_t len = 0;\n              for (;;)\n                {\n                  c = bracket_fetch_wc (dfa);\n                  if (dfa->lex.left == 0\n                      || (c == c1 && dfa->lex.ptr[0] == ']'))\n                    break;\n                  if (len < MAX_BRACKET_STRING_LEN)\n                    str[len++] = c;\n                  else\n                    /* This is in any case an invalid class name.  */\n                    str[0] = '\\0';\n                }\n              str[len] = '\\0';\n\n              /* Fetch bracket.  */\n              c = bracket_fetch_wc (dfa);\n              wc = dfa->lex.wctok;\n              if (c1 == ':')\n                /* Build character class.  POSIX allows character\n                   classes to match multicharacter collating elements,\n                   but the regex code does not support that, so do not\n                   worry about that possibility.  */\n                {\n                  char const *class\n                    = (dfa->syntax.case_fold && (streq (str, \"upper\")\n                                                 || streq (str, \"lower\"))\n                       ? \"alpha\" : str);\n                  const struct dfa_ctype *pred = find_pred (class);\n                  if (!pred)\n                    dfaerror (_(\"invalid character class\"));\n\n                  if (dfa->localeinfo.multibyte && !pred->single_byte_only)\n                    known_bracket_exp = false;\n                  else\n                    for (int c2 = 0; c2 < NOTCHAR; ++c2)\n                      if (pred->func (c2))\n                        setbit (c2, &ccl);\n                }\n              else\n                known_bracket_exp = false;\n\n              colon_warning_state |= 8;\n\n              /* Fetch new lookahead character.  */\n              c1 = bracket_fetch_wc (dfa);\n              wc1 = dfa->lex.wctok;\n              continue;\n            }\n\n          /* We treat '[' as a normal character here.  c/c1/wc/wc1\n             are already set up.  */\n        }\n\n      if (c == '\\\\'\n          && (dfa->syntax.syntax_bits & RE_BACKSLASH_ESCAPE_IN_LISTS))\n        {\n          c = bracket_fetch_wc (dfa);\n          wc = dfa->lex.wctok;\n        }\n\n      if (c1 == NOTCHAR)\n        {\n          c1 = bracket_fetch_wc (dfa);\n          wc1 = dfa->lex.wctok;\n        }\n\n      if (c1 == '-')\n        /* build range characters.  */\n        {\n          int c2 = bracket_fetch_wc (dfa);\n          wint_t wc2 = dfa->lex.wctok;\n\n          /* A bracket expression like [a-[.aa.]] matches an unknown set.\n             Treat it like [-a[.aa.]] while parsing it, and\n             remember that the set is unknown.  */\n          if (c2 == '[' && dfa->lex.ptr[0] == '.')\n            {\n              known_bracket_exp = false;\n              c2 = ']';\n            }\n\n          if (c2 == ']')\n            {\n              /* In the case [x-], the - is an ordinary hyphen,\n                 which is left in c1, the lookahead character.  */\n              dfa->lex.ptr -= dfa->lex.cur_mb_len;\n              dfa->lex.left += dfa->lex.cur_mb_len;\n            }\n          else\n            {\n              if (c2 == '\\\\' && (dfa->syntax.syntax_bits\n                                 & RE_BACKSLASH_ESCAPE_IN_LISTS))\n                {\n                  c2 = bracket_fetch_wc (dfa);\n                  wc2 = dfa->lex.wctok;\n                }\n\n              colon_warning_state |= 8;\n              c1 = bracket_fetch_wc (dfa);\n              wc1 = dfa->lex.wctok;\n\n              /* Treat [x-y] as a range if x != y.  */\n              if (wc != wc2 || wc == WEOF)\n                {\n                  if (dfa->simple_locale\n                      || (isasciidigit (c) & isasciidigit (c2)))\n                    {\n                      for (int ci = c; ci <= c2; ci++)\n                        if (dfa->syntax.case_fold && isalpha (ci))\n                          setbit_case_fold_c (ci, &ccl);\n                        else\n                          setbit (ci, &ccl);\n                    }\n                  else\n                    known_bracket_exp = false;\n\n                  continue;\n                }\n            }\n        }\n\n      colon_warning_state |= (c == ':') ? 2 : 4;\n\n      if (!dfa->localeinfo.multibyte)\n        {\n          if (dfa->syntax.case_fold && isalpha (c))\n            setbit_case_fold_c (c, &ccl);\n          else\n            setbit (c, &ccl);\n          continue;\n        }\n\n      if (wc == WEOF)\n        known_bracket_exp = false;\n      else\n        {\n          wchar_t folded[CASE_FOLDED_BUFSIZE + 1];\n          unsigned int n = (dfa->syntax.case_fold\n                            ? case_folded_counterparts (wc, folded + 1) + 1\n                            : 1);\n          folded[0] = wc;\n          for (unsigned int i = 0; i < n; i++)\n            if (!setbit_wc (folded[i], &ccl))\n              {\n                dfa->lex.brack.chars\n                  = maybe_realloc (dfa->lex.brack.chars, dfa->lex.brack.nchars,\n                                   &dfa->lex.brack.nchars_alloc, -1,\n                                   sizeof *dfa->lex.brack.chars);\n                dfa->lex.brack.chars[dfa->lex.brack.nchars++] = folded[i];\n              }\n        }\n    }\n  while ((wc = wc1, (c = c1) != ']'));\n\n  if (colon_warning_state == 7)\n    dfawarn (_(\"character class syntax is [[:space:]], not [:space:]\"));\n\n  if (! known_bracket_exp)\n    return BACKREF;\n\n  if (dfa->localeinfo.multibyte && (invert || dfa->lex.brack.nchars != 0))\n    {\n      dfa->lex.brack.invert = invert;\n      dfa->lex.brack.cset = emptyset (&ccl) ? -1 : charclass_index (dfa, &ccl);\n      return MBCSET;\n    }\n\n  if (invert)\n    {\n      notset (&ccl);\n      if (dfa->syntax.syntax_bits & RE_HAT_LISTS_NOT_NEWLINE)\n        clrbit ('\\n', &ccl);\n    }\n\n  return CSET + charclass_index (dfa, &ccl);\n}",
      "lines": 224,
      "depth": 21,
      "decorators": [
        "static",
        "static",
        "token"
      ]
    },
    "push_lex_state": {
      "start_point": [
        1279,
        0
      ],
      "end_point": [
        1286,
        1
      ],
      "content": "static void\npush_lex_state (struct dfa *dfa, struct lexptr *ls, char const *s)\n{\n  ls->ptr = dfa->lex.ptr;\n  ls->left = dfa->lex.left;\n  dfa->lex.ptr = s;\n  dfa->lex.left = strlen (s);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "pop_lex_state": {
      "start_point": [
        1288,
        0
      ],
      "end_point": [
        1293,
        1
      ],
      "content": "static void\npop_lex_state (struct dfa *dfa, struct lexptr const *ls)\n{\n  dfa->lex.ptr = ls->ptr;\n  dfa->lex.left = ls->left;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "lex": {
      "start_point": [
        1295,
        0
      ],
      "end_point": [
        1640,
        1
      ],
      "content": "static token\nlex (struct dfa *dfa)\n{\n  bool backslash = false;\n\n  /* Basic plan: We fetch a character.  If it's a backslash,\n     we set the backslash flag and go through the loop again.\n     On the plus side, this avoids having a duplicate of the\n     main switch inside the backslash case.  On the minus side,\n     it means that just about every case begins with\n     \"if (backslash) ...\".  */\n  for (int i = 0; i < 2; ++i)\n    {\n      if (! dfa->lex.left)\n        return dfa->lex.lasttok = END;\n      int c = fetch_wc (dfa);\n\n      switch (c)\n        {\n        case '\\\\':\n          if (backslash)\n            goto normal_char;\n          if (dfa->lex.left == 0)\n            dfaerror (_(\"unfinished \\\\ escape\"));\n          backslash = true;\n          break;\n\n        case '^':\n          if (backslash)\n            goto normal_char;\n          if (dfa->syntax.syntax_bits & RE_CONTEXT_INDEP_ANCHORS\n              || dfa->lex.lasttok == END || dfa->lex.lasttok == LPAREN\n              || dfa->lex.lasttok == OR)\n            return dfa->lex.lasttok = BEGLINE;\n          goto normal_char;\n\n        case '$':\n          if (backslash)\n            goto normal_char;\n          if (dfa->syntax.syntax_bits & RE_CONTEXT_INDEP_ANCHORS\n              || dfa->lex.left == 0\n              || ((dfa->lex.left\n                   > !(dfa->syntax.syntax_bits & RE_NO_BK_PARENS))\n                  && (dfa->lex.ptr[!(dfa->syntax.syntax_bits & RE_NO_BK_PARENS)\n                                   & (dfa->lex.ptr[0] == '\\\\')]\n                      == ')'))\n              || ((dfa->lex.left\n                   > !(dfa->syntax.syntax_bits & RE_NO_BK_VBAR))\n                  && (dfa->lex.ptr[!(dfa->syntax.syntax_bits & RE_NO_BK_VBAR)\n                                   & (dfa->lex.ptr[0] == '\\\\')]\n                      == '|'))\n              || ((dfa->syntax.syntax_bits & RE_NEWLINE_ALT)\n                  && dfa->lex.left > 0 && dfa->lex.ptr[0] == '\\n'))\n            return dfa->lex.lasttok = ENDLINE;\n          goto normal_char;\n\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n          if (backslash && !(dfa->syntax.syntax_bits & RE_NO_BK_REFS))\n            {\n              dfa->lex.laststart = false;\n              return dfa->lex.lasttok = BACKREF;\n            }\n          goto normal_char;\n\n        case '`':\n          if (backslash && !(dfa->syntax.syntax_bits & RE_NO_GNU_OPS))\n            {\n              /* FIXME: should be beginning of string */\n              return dfa->lex.lasttok = BEGLINE;\n            }\n          goto normal_char;\n\n        case '\\'':\n          if (backslash && !(dfa->syntax.syntax_bits & RE_NO_GNU_OPS))\n            {\n              /* FIXME: should be end of string */\n              return dfa->lex.lasttok = ENDLINE;\n            }\n          goto normal_char;\n\n        case '<':\n          if (backslash && !(dfa->syntax.syntax_bits & RE_NO_GNU_OPS))\n            return dfa->lex.lasttok = BEGWORD;\n          goto normal_char;\n\n        case '>':\n          if (backslash && !(dfa->syntax.syntax_bits & RE_NO_GNU_OPS))\n            return dfa->lex.lasttok = ENDWORD;\n          goto normal_char;\n\n        case 'b':\n          if (backslash && !(dfa->syntax.syntax_bits & RE_NO_GNU_OPS))\n            return dfa->lex.lasttok = LIMWORD;\n          goto normal_char;\n\n        case 'B':\n          if (backslash && !(dfa->syntax.syntax_bits & RE_NO_GNU_OPS))\n            return dfa->lex.lasttok = NOTLIMWORD;\n          goto normal_char;\n\n        case '?':\n          if (dfa->syntax.syntax_bits & RE_LIMITED_OPS)\n            goto normal_char;\n          if (backslash != ((dfa->syntax.syntax_bits & RE_BK_PLUS_QM) != 0))\n            goto normal_char;\n          if (!(dfa->syntax.syntax_bits & RE_CONTEXT_INDEP_OPS)\n              && dfa->lex.laststart)\n            goto normal_char;\n          return dfa->lex.lasttok = QMARK;\n\n        case '*':\n          if (backslash)\n            goto normal_char;\n          if (!(dfa->syntax.syntax_bits & RE_CONTEXT_INDEP_OPS)\n              && dfa->lex.laststart)\n            goto normal_char;\n          return dfa->lex.lasttok = STAR;\n\n        case '+':\n          if (dfa->syntax.syntax_bits & RE_LIMITED_OPS)\n            goto normal_char;\n          if (backslash != ((dfa->syntax.syntax_bits & RE_BK_PLUS_QM) != 0))\n            goto normal_char;\n          if (!(dfa->syntax.syntax_bits & RE_CONTEXT_INDEP_OPS)\n              && dfa->lex.laststart)\n            goto normal_char;\n          return dfa->lex.lasttok = PLUS;\n\n        case '{':\n          if (!(dfa->syntax.syntax_bits & RE_INTERVALS))\n            goto normal_char;\n          if (backslash != ((dfa->syntax.syntax_bits & RE_NO_BK_BRACES) == 0))\n            goto normal_char;\n          if (!(dfa->syntax.syntax_bits & RE_CONTEXT_INDEP_OPS)\n              && dfa->lex.laststart)\n            goto normal_char;\n\n          /* Cases:\n             {M} - exact count\n             {M,} - minimum count, maximum is infinity\n             {,N} - 0 through N\n             {,} - 0 to infinity (same as '*')\n             {M,N} - M through N */\n          {\n            char const *p = dfa->lex.ptr;\n            char const *lim = p + dfa->lex.left;\n            dfa->lex.minrep = dfa->lex.maxrep = -1;\n            for (; p != lim && isasciidigit (*p); p++)\n              dfa->lex.minrep = (dfa->lex.minrep < 0\n                                 ? *p - '0'\n                                 : MIN (RE_DUP_MAX + 1,\n                                        dfa->lex.minrep * 10 + *p - '0'));\n            if (p != lim)\n              {\n                if (*p != ',')\n                  dfa->lex.maxrep = dfa->lex.minrep;\n                else\n                  {\n                    if (dfa->lex.minrep < 0)\n                      dfa->lex.minrep = 0;\n                    while (++p != lim && isasciidigit (*p))\n                      dfa->lex.maxrep\n                        = (dfa->lex.maxrep < 0\n                           ? *p - '0'\n                           : MIN (RE_DUP_MAX + 1,\n                                  dfa->lex.maxrep * 10 + *p - '0'));\n                  }\n              }\n            if (! ((! backslash || (p != lim && *p++ == '\\\\'))\n                   && p != lim && *p++ == '}'\n                   && 0 <= dfa->lex.minrep\n                   && (dfa->lex.maxrep < 0\n                       || dfa->lex.minrep <= dfa->lex.maxrep)))\n              {\n                if (dfa->syntax.syntax_bits & RE_INVALID_INTERVAL_ORD)\n                  goto normal_char;\n                dfaerror (_(\"invalid content of \\\\{\\\\}\"));\n              }\n            if (RE_DUP_MAX < dfa->lex.maxrep)\n              dfaerror (_(\"regular expression too big\"));\n            dfa->lex.ptr = p;\n            dfa->lex.left = lim - p;\n          }\n          dfa->lex.laststart = false;\n          return dfa->lex.lasttok = REPMN;\n\n        case '|':\n          if (dfa->syntax.syntax_bits & RE_LIMITED_OPS)\n            goto normal_char;\n          if (backslash != ((dfa->syntax.syntax_bits & RE_NO_BK_VBAR) == 0))\n            goto normal_char;\n          dfa->lex.laststart = true;\n          return dfa->lex.lasttok = OR;\n\n        case '\\n':\n          if (dfa->syntax.syntax_bits & RE_LIMITED_OPS\n              || backslash || !(dfa->syntax.syntax_bits & RE_NEWLINE_ALT))\n            goto normal_char;\n          dfa->lex.laststart = true;\n          return dfa->lex.lasttok = OR;\n\n        case '(':\n          if (backslash != ((dfa->syntax.syntax_bits & RE_NO_BK_PARENS) == 0))\n            goto normal_char;\n          dfa->lex.parens++;\n          dfa->lex.laststart = true;\n          return dfa->lex.lasttok = LPAREN;\n\n        case ')':\n          if (backslash != ((dfa->syntax.syntax_bits & RE_NO_BK_PARENS) == 0))\n            goto normal_char;\n          if (dfa->lex.parens == 0\n              && dfa->syntax.syntax_bits & RE_UNMATCHED_RIGHT_PAREN_ORD)\n            goto normal_char;\n          dfa->lex.parens--;\n          dfa->lex.laststart = false;\n          return dfa->lex.lasttok = RPAREN;\n\n        case '.':\n          if (backslash)\n            goto normal_char;\n          if (dfa->canychar == (size_t) -1)\n            {\n              charclass ccl;\n              fillset (&ccl);\n              if (!(dfa->syntax.syntax_bits & RE_DOT_NEWLINE))\n                clrbit ('\\n', &ccl);\n              if (dfa->syntax.syntax_bits & RE_DOT_NOT_NULL)\n                clrbit ('\\0', &ccl);\n              if (dfa->localeinfo.multibyte)\n                for (int c2 = 0; c2 < NOTCHAR; c2++)\n                  if (dfa->localeinfo.sbctowc[c2] == WEOF)\n                    clrbit (c2, &ccl);\n              dfa->canychar = charclass_index (dfa, &ccl);\n            }\n          dfa->lex.laststart = false;\n          return dfa->lex.lasttok = (dfa->localeinfo.multibyte\n                                     ? ANYCHAR\n                                     : CSET + dfa->canychar);\n\n        case 's':\n        case 'S':\n          if (!backslash || (dfa->syntax.syntax_bits & RE_NO_GNU_OPS))\n            goto normal_char;\n          if (!dfa->localeinfo.multibyte)\n            {\n              charclass ccl;\n              zeroset (&ccl);\n              for (int c2 = 0; c2 < NOTCHAR; ++c2)\n                if (isspace (c2))\n                  setbit (c2, &ccl);\n              if (c == 'S')\n                notset (&ccl);\n              dfa->lex.laststart = false;\n              return dfa->lex.lasttok = CSET + charclass_index (dfa, &ccl);\n            }\n\n          /* FIXME: see if optimizing this, as is done with ANYCHAR and\n             add_utf8_anychar, makes sense.  */\n\n          /* \\s and \\S are documented to be equivalent to [[:space:]] and\n             [^[:space:]] respectively, so tell the lexer to process those\n             strings, each minus its \"already processed\" '['.  */\n          {\n            struct lexptr ls;\n            push_lex_state (dfa, &ls, &\"^[:space:]]\"[c == 's']);\n            dfa->lex.lasttok = parse_bracket_exp (dfa);\n            pop_lex_state (dfa, &ls);\n          }\n\n          dfa->lex.laststart = false;\n          return dfa->lex.lasttok;\n\n        case 'w':\n        case 'W':\n          if (!backslash || (dfa->syntax.syntax_bits & RE_NO_GNU_OPS))\n            goto normal_char;\n\n          if (!dfa->localeinfo.multibyte)\n            {\n              charclass ccl;\n              zeroset (&ccl);\n              for (int c2 = 0; c2 < NOTCHAR; ++c2)\n                if (dfa->syntax.sbit[c2] == CTX_LETTER)\n                  setbit (c2, &ccl);\n              if (c == 'W')\n                notset (&ccl);\n              dfa->lex.laststart = false;\n              return dfa->lex.lasttok = CSET + charclass_index (dfa, &ccl);\n            }\n\n          /* FIXME: see if optimizing this, as is done with ANYCHAR and\n             add_utf8_anychar, makes sense.  */\n\n          /* \\w and \\W are documented to be equivalent to [_[:alnum:]] and\n             [^_[:alnum:]] respectively, so tell the lexer to process those\n             strings, each minus its \"already processed\" '['.  */\n          {\n            struct lexptr ls;\n            push_lex_state (dfa, &ls, &\"^_[:alnum:]]\"[c == 'w']);\n            dfa->lex.lasttok = parse_bracket_exp (dfa);\n            pop_lex_state (dfa, &ls);\n          }\n\n          dfa->lex.laststart = false;\n          return dfa->lex.lasttok;\n\n        case '[':\n          if (backslash)\n            goto normal_char;\n          dfa->lex.laststart = false;\n          return dfa->lex.lasttok = parse_bracket_exp (dfa);\n\n        default:\n        normal_char:\n          dfa->lex.laststart = false;\n          /* For multibyte character sets, folding is done in atom.  Always\n             return WCHAR.  */\n          if (dfa->localeinfo.multibyte)\n            return dfa->lex.lasttok = WCHAR;\n\n          if (dfa->syntax.case_fold && isalpha (c))\n            {\n              charclass ccl;\n              zeroset (&ccl);\n              setbit_case_fold_c (c, &ccl);\n              return dfa->lex.lasttok = CSET + charclass_index (dfa, &ccl);\n            }\n\n          return dfa->lex.lasttok = c;\n        }\n    }\n\n  /* The above loop should consume at most a backslash\n     and some other character.  */\n  abort ();\n  return END;                   /* keeps pedantic compilers happy.  */\n}",
      "lines": 346,
      "depth": 25,
      "decorators": [
        "static",
        "static",
        "token"
      ]
    },
    "addtok_mb": {
      "start_point": [
        1642,
        0
      ],
      "end_point": [
        1681,
        1
      ],
      "content": "static void\naddtok_mb (struct dfa *dfa, token t, char mbprop)\n{\n  if (dfa->talloc == dfa->tindex)\n    {\n      dfa->tokens = x2nrealloc (dfa->tokens, &dfa->talloc,\n                                sizeof *dfa->tokens);\n      if (dfa->localeinfo.multibyte)\n        dfa->multibyte_prop = xnrealloc (dfa->multibyte_prop, dfa->talloc,\n                                         sizeof *dfa->multibyte_prop);\n    }\n  if (dfa->localeinfo.multibyte)\n    dfa->multibyte_prop[dfa->tindex] = mbprop;\n  dfa->tokens[dfa->tindex++] = t;\n\n  switch (t)\n    {\n    case QMARK:\n    case STAR:\n    case PLUS:\n      break;\n\n    case CAT:\n    case OR:\n      dfa->parse.depth--;\n      break;\n\n    case BACKREF:\n      dfa->fast = false;\n      FALLTHROUGH;\n    default:\n      dfa->nleaves++;\n      FALLTHROUGH;\n    case EMPTY:\n      dfa->parse.depth++;\n      break;\n    }\n  if (dfa->parse.depth > dfa->depth)\n    dfa->depth = dfa->parse.depth;\n}",
      "lines": 40,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "addtok": {
      "start_point": [
        1687,
        0
      ],
      "end_point": [
        1718,
        1
      ],
      "content": "static void\naddtok (struct dfa *dfa, token t)\n{\n  if (dfa->localeinfo.multibyte && t == MBCSET)\n    {\n      bool need_or = false;\n\n      /* Extract wide characters into alternations for better performance.\n         This does not require UTF-8.  */\n      for (ptrdiff_t i = 0; i < dfa->lex.brack.nchars; i++)\n        {\n          addtok_wc (dfa, dfa->lex.brack.chars[i]);\n          if (need_or)\n            addtok (dfa, OR);\n          need_or = true;\n        }\n      dfa->lex.brack.nchars = 0;\n\n      /* Wide characters have been handled above, so it is possible\n         that the set is empty now.  Do nothing in that case.  */\n      if (dfa->lex.brack.cset != -1)\n        {\n          addtok (dfa, CSET + dfa->lex.brack.cset);\n          if (need_or)\n            addtok (dfa, OR);\n        }\n    }\n  else\n    {\n      addtok_mb (dfa, t, 3);\n    }\n}",
      "lines": 32,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "addtok_wc": {
      "start_point": [
        1726,
        0
      ],
      "end_point": [
        1749,
        1
      ],
      "content": "static void\naddtok_wc (struct dfa *dfa, wint_t wc)\n{\n  unsigned char buf[MB_LEN_MAX];\n  mbstate_t s = { 0 };\n  size_t stored_bytes = wcrtomb ((char *) buf, wc, &s);\n\n  if (stored_bytes != (size_t) -1)\n    dfa->lex.cur_mb_len = stored_bytes;\n  else\n    {\n      /* This is merely stop-gap.  buf[0] is undefined, yet skipping\n         the addtok_mb call altogether can corrupt the heap.  */\n      dfa->lex.cur_mb_len = 1;\n      buf[0] = 0;\n    }\n\n  addtok_mb (dfa, buf[0], dfa->lex.cur_mb_len == 1 ? 3 : 1);\n  for (int i = 1; i < dfa->lex.cur_mb_len; i++)\n    {\n      addtok_mb (dfa, buf[i], i == dfa->lex.cur_mb_len - 1 ? 2 : 0);\n      addtok (dfa, CAT);\n    }\n}",
      "lines": 24,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "add_utf8_anychar": {
      "start_point": [
        1751,
        0
      ],
      "end_point": [
        1806,
        1
      ],
      "content": "static void\nadd_utf8_anychar (struct dfa *dfa)\n{\n  static charclass const utf8_classes[5] = {\n    /* 80-bf: non-leading bytes.  */\n    CHARCLASS_INIT (0, 0, 0, 0, 0xffffffff, 0xffffffff, 0, 0),\n\n    /* 00-7f: 1-byte sequence.  */\n    CHARCLASS_INIT (0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0, 0, 0, 0),\n\n    /* c2-df: 2-byte sequence.  */\n    CHARCLASS_INIT (0, 0, 0, 0, 0, 0, 0xfffffffc, 0),\n\n    /* e0-ef: 3-byte sequence.  */\n    CHARCLASS_INIT (0, 0, 0, 0, 0, 0, 0, 0xffff),\n\n    /* f0-f7: 4-byte sequence.  */\n    CHARCLASS_INIT (0, 0, 0, 0, 0, 0, 0, 0xff0000)\n  };\n  const unsigned int n = sizeof (utf8_classes) / sizeof (utf8_classes[0]);\n\n  /* Define the five character classes that are needed below.  */\n  if (dfa->utf8_anychar_classes[0] == 0)\n    for (unsigned int i = 0; i < n; i++)\n      {\n        charclass c = utf8_classes[i];\n        if (i == 1)\n          {\n            if (!(dfa->syntax.syntax_bits & RE_DOT_NEWLINE))\n              clrbit ('\\n', &c);\n            if (dfa->syntax.syntax_bits & RE_DOT_NOT_NULL)\n              clrbit ('\\0', &c);\n          }\n        dfa->utf8_anychar_classes[i] = CSET + charclass_index (dfa, &c);\n      }\n\n  /* A valid UTF-8 character is\n\n     ([0x00-0x7f]\n     |[0xc2-0xdf][0x80-0xbf]\n     |[0xe0-0xef[0x80-0xbf][0x80-0xbf]\n     |[0xf0-f7][0x80-0xbf][0x80-0xbf][0x80-0xbf])\n\n     which I'll write more concisely \"B|CA|DAA|EAAA\".  Factor the [0x00-0x7f]\n     and you get \"B|(C|(D|EA)A)A\".  And since the token buffer is in reverse\n     Polish notation, you get \"B C D E A CAT OR A CAT OR A CAT OR\".  */\n  unsigned int i;\n  for (i = 1; i < n; i++)\n    addtok (dfa, dfa->utf8_anychar_classes[i]);\n  while (--i > 1)\n    {\n      addtok (dfa, dfa->utf8_anychar_classes[0]);\n      addtok (dfa, CAT);\n      addtok (dfa, OR);\n    }\n}",
      "lines": 56,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "atom": {
      "start_point": [
        1843,
        0
      ],
      "end_point": [
        1901,
        1
      ],
      "content": "static void\natom (struct dfa *dfa)\n{\n  if (dfa->parse.tok == WCHAR)\n    {\n      if (dfa->lex.wctok == WEOF)\n        addtok (dfa, BACKREF);\n      else\n        {\n          addtok_wc (dfa, dfa->lex.wctok);\n\n          if (dfa->syntax.case_fold)\n            {\n              wchar_t folded[CASE_FOLDED_BUFSIZE];\n              unsigned int n = case_folded_counterparts (dfa->lex.wctok,\n                                                         folded);\n              for (unsigned int i = 0; i < n; i++)\n                {\n                  addtok_wc (dfa, folded[i]);\n                  addtok (dfa, OR);\n                }\n            }\n        }\n\n      dfa->parse.tok = lex (dfa);\n    }\n  else if (dfa->parse.tok == ANYCHAR && dfa->localeinfo.using_utf8)\n    {\n      /* For UTF-8 expand the period to a series of CSETs that define a valid\n         UTF-8 character.  This avoids using the slow multibyte path.  I'm\n         pretty sure it would be both profitable and correct to do it for\n         any encoding; however, the optimization must be done manually as\n         it is done above in add_utf8_anychar.  So, let's start with\n         UTF-8: it is the most used, and the structure of the encoding\n         makes the correctness more obvious.  */\n      add_utf8_anychar (dfa);\n      dfa->parse.tok = lex (dfa);\n    }\n  else if ((0 <= dfa->parse.tok && dfa->parse.tok < NOTCHAR)\n           || dfa->parse.tok >= CSET || dfa->parse.tok == BACKREF\n           || dfa->parse.tok == BEGLINE || dfa->parse.tok == ENDLINE\n           || dfa->parse.tok == BEGWORD || dfa->parse.tok == ANYCHAR\n           || dfa->parse.tok == MBCSET || dfa->parse.tok == ENDWORD\n           || dfa->parse.tok == LIMWORD || dfa->parse.tok == NOTLIMWORD)\n    {\n      addtok (dfa, dfa->parse.tok);\n      dfa->parse.tok = lex (dfa);\n    }\n  else if (dfa->parse.tok == LPAREN)\n    {\n      dfa->parse.tok = lex (dfa);\n      regexp (dfa);\n      if (dfa->parse.tok != RPAREN)\n        dfaerror (_(\"unbalanced (\"));\n      dfa->parse.tok = lex (dfa);\n    }\n  else\n    addtok (dfa, EMPTY);\n}",
      "lines": 59,
      "depth": 22,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "copytoks": {
      "start_point": [
        1925,
        0
      ],
      "end_point": [
        1935,
        1
      ],
      "content": "static void\ncopytoks (struct dfa *dfa, size_t tindex, size_t ntokens)\n{\n  if (dfa->localeinfo.multibyte)\n    for (size_t i = 0; i < ntokens; ++i)\n      addtok_mb (dfa, dfa->tokens[tindex + i],\n                 dfa->multibyte_prop[tindex + i]);\n  else\n    for (size_t i = 0; i < ntokens; ++i)\n      addtok_mb (dfa, dfa->tokens[tindex + i], 3);\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "closure": {
      "start_point": [
        1937,
        0
      ],
      "end_point": [
        1976,
        1
      ],
      "content": "static void\nclosure (struct dfa *dfa)\n{\n  atom (dfa);\n  while (dfa->parse.tok == QMARK || dfa->parse.tok == STAR\n         || dfa->parse.tok == PLUS || dfa->parse.tok == REPMN)\n    if (dfa->parse.tok == REPMN && (dfa->lex.minrep || dfa->lex.maxrep))\n      {\n        size_t ntokens = nsubtoks (dfa, dfa->tindex);\n        size_t tindex = dfa->tindex - ntokens;\n        if (dfa->lex.maxrep < 0)\n          addtok (dfa, PLUS);\n        if (dfa->lex.minrep == 0)\n          addtok (dfa, QMARK);\n        int i;\n        for (i = 1; i < dfa->lex.minrep; i++)\n          {\n            copytoks (dfa, tindex, ntokens);\n            addtok (dfa, CAT);\n          }\n        for (; i < dfa->lex.maxrep; i++)\n          {\n            copytoks (dfa, tindex, ntokens);\n            addtok (dfa, QMARK);\n            addtok (dfa, CAT);\n          }\n        dfa->parse.tok = lex (dfa);\n      }\n    else if (dfa->parse.tok == REPMN)\n      {\n        dfa->tindex -= nsubtoks (dfa, dfa->tindex);\n        dfa->parse.tok = lex (dfa);\n        closure (dfa);\n      }\n    else\n      {\n        addtok (dfa, dfa->parse.tok);\n        dfa->parse.tok = lex (dfa);\n      }\n}",
      "lines": 40,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "branch": {
      "start_point": [
        1978,
        0
      ],
      "end_point": [
        1988,
        1
      ],
      "content": "static void\nbranch (struct dfa* dfa)\n{\n  closure (dfa);\n  while (dfa->parse.tok != RPAREN && dfa->parse.tok != OR\n         && dfa->parse.tok >= 0)\n    {\n      closure (dfa);\n      addtok (dfa, CAT);\n    }\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "regexp": {
      "start_point": [
        1990,
        0
      ],
      "end_point": [
        2000,
        1
      ],
      "content": "static void\nregexp (struct dfa *dfa)\n{\n  branch (dfa);\n  while (dfa->parse.tok == OR)\n    {\n      dfa->parse.tok = lex (dfa);\n      branch (dfa);\n      addtok (dfa, OR);\n    }\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "dfaparse": {
      "start_point": [
        2005,
        0
      ],
      "end_point": [
        2031,
        1
      ],
      "content": "static void\ndfaparse (char const *s, size_t len, struct dfa *d)\n{\n  d->lex.ptr = s;\n  d->lex.left = len;\n  d->lex.lasttok = END;\n  d->lex.laststart = true;\n\n  if (!d->syntax.syntax_bits_set)\n    dfaerror (_(\"no syntax specified\"));\n\n  d->parse.tok = lex (d);\n  d->parse.depth = d->depth;\n\n  regexp (d);\n\n  if (d->parse.tok != END)\n    dfaerror (_(\"unbalanced )\"));\n\n  addtok (d, END - d->nregexps);\n  addtok (d, CAT);\n\n  if (d->nregexps)\n    addtok (d, OR);\n\n  ++d->nregexps;\n}",
      "lines": 27,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "copy": {
      "start_point": [
        2036,
        0
      ],
      "end_point": [
        2048,
        1
      ],
      "content": "static void\ncopy (position_set const *src, position_set *dst)\n{\n  if (dst->alloc < src->nelem)\n    {\n      free (dst->elems);\n      dst->elems = xpalloc (NULL, &dst->alloc, src->nelem - dst->alloc, -1,\n                            sizeof *dst->elems);\n    }\n  dst->nelem = src->nelem;\n  if (src->nelem != 0)\n    memcpy (dst->elems, src->elems, src->nelem * sizeof *dst->elems);\n}",
      "lines": 13,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "alloc_position_set": {
      "start_point": [
        2050,
        0
      ],
      "end_point": [
        2056,
        1
      ],
      "content": "static void\nalloc_position_set (position_set *s, size_t size)\n{\n  s->elems = xnmalloc (size, sizeof *s->elems);\n  s->alloc = size;\n  s->nelem = 0;\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "insert": {
      "start_point": [
        2062,
        0
      ],
      "end_point": [
        2086,
        1
      ],
      "content": "static void\ninsert (position p, position_set *s)\n{\n  ptrdiff_t count = s->nelem;\n  ptrdiff_t lo = 0, hi = count;\n  while (lo < hi)\n    {\n      ptrdiff_t mid = (lo + hi) >> 1;\n      if (s->elems[mid].index > p.index)\n        lo = mid + 1;\n      else if (s->elems[mid].index == p.index)\n        {\n          s->elems[mid].constraint |= p.constraint;\n          return;\n        }\n      else\n        hi = mid;\n    }\n\n  s->elems = maybe_realloc (s->elems, count, &s->alloc, -1, sizeof *s->elems);\n  for (ptrdiff_t i = count; i > lo; i--)\n    s->elems[i] = s->elems[i - 1];\n  s->elems[lo] = p;\n  ++s->nelem;\n}",
      "lines": 25,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "merge_constrained": {
      "start_point": [
        2091,
        0
      ],
      "end_point": [
        2124,
        1
      ],
      "content": "static void\nmerge_constrained (position_set const *s1, position_set const *s2,\n                   unsigned int c2, position_set *m)\n{\n  ptrdiff_t i = 0, j = 0;\n\n  if (m->alloc - s1->nelem < s2->nelem)\n    {\n      free (m->elems);\n      m->alloc = s1->nelem;\n      m->elems = xpalloc (NULL, &m->alloc, s2->nelem, -1, sizeof *m->elems);\n    }\n  m->nelem = 0;\n  while (i < s1->nelem || j < s2->nelem)\n    if (! (j < s2->nelem)\n        || (i < s1->nelem && s1->elems[i].index >= s2->elems[j].index))\n      {\n        unsigned int c = ((i < s1->nelem && j < s2->nelem\n                           && s1->elems[i].index == s2->elems[j].index)\n                          ? s2->elems[j++].constraint & c2\n                          : 0);\n        m->elems[m->nelem].index = s1->elems[i].index;\n        m->elems[m->nelem++].constraint = s1->elems[i++].constraint | c;\n      }\n    else\n      {\n        if (s2->elems[j].constraint & c2)\n          {\n            m->elems[m->nelem].index = s2->elems[j].index;\n            m->elems[m->nelem++].constraint = s2->elems[j].constraint & c2;\n          }\n        j++;\n      }\n}",
      "lines": 34,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "merge": {
      "start_point": [
        2128,
        0
      ],
      "end_point": [
        2132,
        1
      ],
      "content": "static void\nmerge (position_set const *s1, position_set const *s2, position_set *m)\n{\n  merge_constrained (s1, s2, -1, m);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "delete": {
      "start_point": [
        2136,
        0
      ],
      "end_point": [
        2159,
        1
      ],
      "content": "static unsigned int\ndelete (size_t del, position_set *s)\n{\n  size_t count = s->nelem;\n  size_t lo = 0, hi = count;\n  while (lo < hi)\n    {\n      size_t mid = (lo + hi) >> 1;\n      if (s->elems[mid].index > del)\n        lo = mid + 1;\n      else if (s->elems[mid].index == del)\n        {\n          unsigned int c = s->elems[mid].constraint;\n          size_t i;\n          for (i = mid; i + 1 < count; i++)\n            s->elems[i] = s->elems[i + 1];\n          s->nelem = i;\n          return c;\n        }\n      else\n        hi = mid;\n    }\n  return 0;\n}",
      "lines": 24,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "unsigned int",
        "unsigned",
        "int"
      ]
    },
    "replace": {
      "start_point": [
        2162,
        0
      ],
      "end_point": [
        2173,
        1
      ],
      "content": "static void\nreplace (position_set *dst, size_t del, position_set *add,\n         unsigned int constraint, position_set *tmp)\n{\n  unsigned int c = delete (del, dst) & constraint;\n\n  if (c)\n    {\n      copy (dst, tmp);\n      merge_constrained (tmp, add, c, dst);\n    }\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "state_index": {
      "start_point": [
        2178,
        0
      ],
      "end_point": [
        2257,
        1
      ],
      "content": "static state_num\nstate_index (struct dfa *d, position_set const *s, int context)\n{\n  size_t hash = 0;\n  int constraint = 0;\n  state_num i;\n  token first_end = 0;\n\n  for (i = 0; i < s->nelem; ++i)\n    hash ^= s->elems[i].index + s->elems[i].constraint;\n\n  /* Try to find a state that exactly matches the proposed one.  */\n  for (i = 0; i < d->sindex; ++i)\n    {\n      if (hash != d->states[i].hash || s->nelem != d->states[i].elems.nelem\n          || context != d->states[i].context)\n        continue;\n      state_num j;\n      for (j = 0; j < s->nelem; ++j)\n        if (s->elems[j].constraint != d->states[i].elems.elems[j].constraint\n            || s->elems[j].index != d->states[i].elems.elems[j].index)\n          break;\n      if (j == s->nelem)\n        return i;\n    }\n\n#ifdef DEBUG\n  fprintf (stderr, \"new state %zd\\n nextpos:\", i);\n  for (state_num j = 0; j < s->nelem; j++)\n    {\n      fprintf (stderr, \" %zu:\", s->elems[j].index);\n      prtok (d->tokens[s->elems[j].index]);\n    }\n  fprintf (stderr, \"\\n context:\");\n  if (context ^ CTX_ANY)\n    {\n      if (context & CTX_NONE)\n        fprintf (stderr, \" CTX_NONE\");\n      if (context & CTX_LETTER)\n        fprintf (stderr, \" CTX_LETTER\");\n      if (context & CTX_NEWLINE)\n        fprintf (stderr, \" CTX_NEWLINE\");\n    }\n  else\n    fprintf (stderr, \" CTX_ANY\");\n  fprintf (stderr, \"\\n\");\n#endif\n\n  for (state_num j = 0; j < s->nelem; j++)\n    {\n      int c = s->elems[j].constraint;\n      if (d->tokens[s->elems[j].index] < 0)\n        {\n          if (succeeds_in_context (c, context, CTX_ANY))\n            constraint |= c;\n          if (!first_end)\n            first_end = d->tokens[s->elems[j].index];\n        }\n      else if (d->tokens[s->elems[j].index] == BACKREF)\n        constraint = NO_CONSTRAINT;\n    }\n\n\n  /* Create a new state.  */\n  d->states = maybe_realloc (d->states, d->sindex, &d->salloc, -1,\n                             sizeof *d->states);\n  d->states[i].hash = hash;\n  alloc_position_set (&d->states[i].elems, s->nelem);\n  copy (s, &d->states[i].elems);\n  d->states[i].context = context;\n  d->states[i].constraint = constraint;\n  d->states[i].first_end = first_end;\n  d->states[i].mbps.nelem = 0;\n  d->states[i].mbps.elems = NULL;\n  d->states[i].mb_trindex = -1;\n\n  ++d->sindex;\n\n  return i;\n}",
      "lines": 80,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "state_num"
      ]
    },
    "epsclosure": {
      "start_point": [
        2264,
        0
      ],
      "end_point": [
        2309,
        1
      ],
      "content": "static void\nepsclosure (position_set *initial, struct dfa const *d)\n{\n  position_set tmp;\n  alloc_position_set (&tmp, d->nleaves);\n  for (size_t i = 0; i < d->tindex; ++i)\n    if (d->follows[i].nelem > 0 && d->tokens[i] >= NOTCHAR\n        && d->tokens[i] != BACKREF && d->tokens[i] != ANYCHAR\n        && d->tokens[i] != MBCSET && d->tokens[i] < CSET)\n      {\n        unsigned int constraint;\n        switch (d->tokens[i])\n          {\n          case BEGLINE:\n            constraint = BEGLINE_CONSTRAINT;\n            break;\n          case ENDLINE:\n            constraint = ENDLINE_CONSTRAINT;\n            break;\n          case BEGWORD:\n            constraint = BEGWORD_CONSTRAINT;\n            break;\n          case ENDWORD:\n            constraint = ENDWORD_CONSTRAINT;\n            break;\n          case LIMWORD:\n            constraint = LIMWORD_CONSTRAINT;\n            break;\n          case NOTLIMWORD:\n            constraint = NOTLIMWORD_CONSTRAINT;\n            break;\n          default:\n            constraint = NO_CONSTRAINT;\n            break;\n          }\n\n        delete (i, &d->follows[i]);\n\n        for (size_t j = 0; j < d->tindex; j++)\n          if (i != j && d->follows[j].nelem > 0)\n            replace (&d->follows[j], i, &d->follows[i], constraint, &tmp);\n\n        replace (initial, i, &d->follows[i], constraint, &tmp);\n      }\n  free (tmp.elems);\n}",
      "lines": 46,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "charclass_context": {
      "start_point": [
        2314,
        0
      ],
      "end_point": [
        2330,
        1
      ],
      "content": "static int\ncharclass_context (struct dfa const *dfa, charclass const *c)\n{\n  int context = 0;\n\n  for (unsigned int j = 0; j < CHARCLASS_WORDS; ++j)\n    {\n      if (c->w[j] & dfa->syntax.newline.w[j])\n        context |= CTX_NEWLINE;\n      if (c->w[j] & dfa->syntax.letters.w[j])\n        context |= CTX_LETTER;\n      if (c->w[j] & ~(dfa->syntax.letters.w[j] | dfa->syntax.newline.w[j]))\n        context |= CTX_NONE;\n    }\n\n  return context;\n}",
      "lines": 17,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "state_separate_contexts": {
      "start_point": [
        2338,
        0
      ],
      "end_point": [
        2352,
        1
      ],
      "content": "static int _GL_ATTRIBUTE_PURE\nstate_separate_contexts (position_set const *s)\n{\n  int separate_contexts = 0;\n\n  for (size_t j = 0; j < s->nelem; j++)\n    {\n      if (prev_newline_dependent (s->elems[j].constraint))\n        separate_contexts |= CTX_NEWLINE;\n      if (prev_letter_dependent (s->elems[j].constraint))\n        separate_contexts |= CTX_LETTER;\n    }\n\n  return separate_contexts;\n}",
      "lines": 15,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "dfaanalyze": {
      "start_point": [
        2407,
        0
      ],
      "end_point": [
        2615,
        1
      ],
      "content": "static void\ndfaanalyze (struct dfa *d, bool searchflag)\n{\n  /* Array allocated to hold position sets.  */\n  position *posalloc = xnmalloc (d->nleaves, 2 * sizeof *posalloc);\n  /* Firstpos and lastpos elements.  */\n  position *firstpos = posalloc + d->nleaves;\n  position *lastpos = firstpos + d->nleaves;\n\n  /* Stack for element counts and nullable flags.  */\n  struct\n  {\n    /* Whether the entry is nullable.  */\n    bool nullable;\n\n    /* Counts of firstpos and lastpos sets.  */\n    size_t nfirstpos;\n    size_t nlastpos;\n  } *stkalloc = xnmalloc (d->depth, sizeof *stkalloc), *stk = stkalloc;\n\n  position_set merged;          /* Result of merging sets.  */\n\n#ifdef DEBUG\n  fprintf (stderr, \"dfaanalyze:\\n\");\n  for (size_t i = 0; i < d->tindex; ++i)\n    {\n      fprintf (stderr, \" %zu:\", i);\n      prtok (d->tokens[i]);\n    }\n  putc ('\\n', stderr);\n#endif\n\n  d->searchflag = searchflag;\n  alloc_position_set (&merged, d->nleaves);\n  d->follows = xcalloc (d->tindex, sizeof *d->follows);\n\n  for (size_t i = 0; i < d->tindex; ++i)\n    {\n      switch (d->tokens[i])\n        {\n        case EMPTY:\n          /* The empty set is nullable.  */\n          stk->nullable = true;\n\n          /* The firstpos and lastpos of the empty leaf are both empty.  */\n          stk->nfirstpos = stk->nlastpos = 0;\n          stk++;\n          break;\n\n        case STAR:\n        case PLUS:\n          /* Every element in the firstpos of the argument is in the follow\n             of every element in the lastpos.  */\n          {\n            position_set tmp;\n            tmp.nelem = stk[-1].nfirstpos;\n            tmp.elems = firstpos;\n            position *pos = lastpos;\n            for (size_t j = 0; j < stk[-1].nlastpos; j++)\n              {\n                merge (&tmp, &d->follows[pos[j].index], &merged);\n                copy (&merged, &d->follows[pos[j].index]);\n              }\n          }\n          FALLTHROUGH;\n        case QMARK:\n          /* A QMARK or STAR node is automatically nullable.  */\n          if (d->tokens[i] != PLUS)\n            stk[-1].nullable = true;\n          break;\n\n        case CAT:\n          /* Every element in the firstpos of the second argument is in the\n             follow of every element in the lastpos of the first argument.  */\n          {\n            position_set tmp;\n            tmp.nelem = stk[-1].nfirstpos;\n            tmp.elems = firstpos;\n            position *pos = lastpos + stk[-1].nlastpos;\n            for (size_t j = 0; j < stk[-2].nlastpos; j++)\n              {\n                merge (&tmp, &d->follows[pos[j].index], &merged);\n                copy (&merged, &d->follows[pos[j].index]);\n              }\n          }\n\n          /* The firstpos of a CAT node is the firstpos of the first argument,\n             union that of the second argument if the first is nullable.  */\n          if (stk[-2].nullable)\n            stk[-2].nfirstpos += stk[-1].nfirstpos;\n          else\n            firstpos += stk[-1].nfirstpos;\n\n          /* The lastpos of a CAT node is the lastpos of the second argument,\n             union that of the first argument if the second is nullable.  */\n          if (stk[-1].nullable)\n            stk[-2].nlastpos += stk[-1].nlastpos;\n          else\n            {\n              position *pos = lastpos + stk[-2].nlastpos;\n              for (size_t j = stk[-1].nlastpos; j-- > 0;)\n                pos[j] = lastpos[j];\n              lastpos += stk[-2].nlastpos;\n              stk[-2].nlastpos = stk[-1].nlastpos;\n            }\n\n          /* A CAT node is nullable if both arguments are nullable.  */\n          stk[-2].nullable &= stk[-1].nullable;\n          stk--;\n          break;\n\n        case OR:\n          /* The firstpos is the union of the firstpos of each argument.  */\n          stk[-2].nfirstpos += stk[-1].nfirstpos;\n\n          /* The lastpos is the union of the lastpos of each argument.  */\n          stk[-2].nlastpos += stk[-1].nlastpos;\n\n          /* An OR node is nullable if either argument is nullable.  */\n          stk[-2].nullable |= stk[-1].nullable;\n          stk--;\n          break;\n\n        default:\n          /* Anything else is a nonempty position.  (Note that special\n             constructs like \\< are treated as nonempty strings here;\n             an \"epsilon closure\" effectively makes them nullable later.\n             Backreferences have to get a real position so we can detect\n             transitions on them later.  But they are nullable.  */\n          stk->nullable = d->tokens[i] == BACKREF;\n\n          /* This position is in its own firstpos and lastpos.  */\n          stk->nfirstpos = stk->nlastpos = 1;\n          stk++;\n\n          --firstpos, --lastpos;\n          firstpos->index = lastpos->index = i;\n          firstpos->constraint = lastpos->constraint = NO_CONSTRAINT;\n\n          break;\n        }\n#ifdef DEBUG\n      /* ... balance the above nonsyntactic #ifdef goo...  */\n      fprintf (stderr, \"node %zu:\", i);\n      prtok (d->tokens[i]);\n      putc ('\\n', stderr);\n      fprintf (stderr,\n               stk[-1].nullable ? \" nullable: yes\\n\" : \" nullable: no\\n\");\n      fprintf (stderr, \" firstpos:\");\n      for (size_t j = stk[-1].nfirstpos; j-- > 0;)\n        {\n          fprintf (stderr, \" %zu:\", firstpos[j].index);\n          prtok (d->tokens[firstpos[j].index]);\n        }\n      fprintf (stderr, \"\\n lastpos:\");\n      for (size_t j = stk[-1].nlastpos; j-- > 0;)\n        {\n          fprintf (stderr, \" %zu:\", lastpos[j].index);\n          prtok (d->tokens[lastpos[j].index]);\n        }\n      putc ('\\n', stderr);\n#endif\n    }\n\n#ifdef DEBUG\n  for (size_t i = 0; i < d->tindex; ++i)\n    if (d->tokens[i] < NOTCHAR || d->tokens[i] == BACKREF\n        || d->tokens[i] == ANYCHAR || d->tokens[i] == MBCSET\n        || d->tokens[i] >= CSET)\n      {\n        fprintf (stderr, \"follows(%zu:\", i);\n        prtok (d->tokens[i]);\n        fprintf (stderr, \"):\");\n        for (size_t j = d->follows[i].nelem; j-- > 0;)\n          {\n            fprintf (stderr, \" %zu:\", d->follows[i].elems[j].index);\n            prtok (d->tokens[d->follows[i].elems[j].index]);\n          }\n        putc ('\\n', stderr);\n      }\n#endif\n\n  /* Get the epsilon closure of the firstpos of the regexp.  The result will\n     be the set of positions of state 0.  */\n  merged.nelem = 0;\n  for (size_t i = 0; i < stk[-1].nfirstpos; ++i)\n    insert (firstpos[i], &merged);\n\n  /* For each follow set that is the follow set of a real position, replace\n     it with its epsilon closure.  */\n  epsclosure (&merged, d);\n\n  /* Context wanted by some position.  */\n  int separate_contexts = state_separate_contexts (&merged);\n\n  /* Build the initial state.  */\n  if (separate_contexts & CTX_NEWLINE)\n    state_index (d, &merged, CTX_NEWLINE);\n  d->initstate_notbol = d->min_trcount\n    = state_index (d, &merged, separate_contexts ^ CTX_ANY);\n  if (separate_contexts & CTX_LETTER)\n    d->min_trcount = state_index (d, &merged, CTX_LETTER);\n  d->min_trcount++;\n  d->trcount = 0;\n\n  free (posalloc);\n  free (stkalloc);\n  free (merged.elems);\n}",
      "lines": 209,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "realloc_trans_if_necessary": {
      "start_point": [
        2618,
        0
      ],
      "end_point": [
        2650,
        1
      ],
      "content": "static void\nrealloc_trans_if_necessary (struct dfa *d)\n{\n  state_num oldalloc = d->tralloc;\n  if (oldalloc < d->sindex)\n    {\n      state_num **realtrans = d->trans ? d->trans - 2 : NULL;\n      ptrdiff_t newalloc1 = realtrans ? d->tralloc + 2 : 0;\n      realtrans = xpalloc (realtrans, &newalloc1, d->sindex - oldalloc,\n                           -1, sizeof *realtrans);\n      realtrans[0] = realtrans[1] = NULL;\n      d->trans = realtrans + 2;\n      ptrdiff_t newalloc = d->tralloc = newalloc1 - 2;\n      d->fails = xnrealloc (d->fails, newalloc, sizeof *d->fails);\n      d->success = xnrealloc (d->success, newalloc, sizeof *d->success);\n      d->newlines = xnrealloc (d->newlines, newalloc, sizeof *d->newlines);\n      if (d->localeinfo.multibyte)\n        {\n          realtrans = d->mb_trans ? d->mb_trans - 2 : NULL;\n          realtrans = xnrealloc (realtrans, newalloc1, sizeof *realtrans);\n          if (oldalloc == 0)\n            realtrans[0] = realtrans[1] = NULL;\n          d->mb_trans = realtrans + 2;\n        }\n      for (; oldalloc < newalloc; oldalloc++)\n        {\n          d->trans[oldalloc] = NULL;\n          d->fails[oldalloc] = NULL;\n          if (d->localeinfo.multibyte)\n            d->mb_trans[oldalloc] = NULL;\n        }\n    }\n}",
      "lines": 33,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "build_state": {
      "start_point": [
        2685,
        0
      ],
      "end_point": [
        2968,
        1
      ],
      "content": "static state_num\nbuild_state (state_num s, struct dfa *d, unsigned char uc)\n{\n  position_set follows;         /* Union of the follows of the group.  */\n  position_set tmp;             /* Temporary space for merging sets.  */\n  state_num state;              /* New state.  */\n  state_num state_newline;      /* New state on a newline transition.  */\n  state_num state_letter;       /* New state on a letter transition.  */\n\n#ifdef DEBUG\n  fprintf (stderr, \"build state %td\\n\", s);\n#endif\n\n  /* A pointer to the new transition table, and the table itself.  */\n  state_num **ptrans = (accepting (s, d) ? d->fails : d->trans) + s;\n  state_num *trans = *ptrans;\n\n  if (!trans)\n    {\n      /* MAX_TRCOUNT is an arbitrary upper limit on the number of\n         transition tables that can exist at once, other than for\n         initial states.  Often-used transition tables are quickly\n         rebuilt, whereas rarely-used ones are cleared away.  */\n      if (MAX_TRCOUNT <= d->trcount)\n        {\n          for (state_num i = d->min_trcount; i < d->tralloc; i++)\n            {\n              free (d->trans[i]);\n              free (d->fails[i]);\n              d->trans[i] = d->fails[i] = NULL;\n            }\n          d->trcount = 0;\n        }\n\n      d->trcount++;\n      *ptrans = trans = xmalloc (NOTCHAR * sizeof *trans);\n\n      /* Fill transition table with a default value which means that the\n         transited state has not been calculated yet.  */\n      for (int i = 0; i < NOTCHAR; i++)\n        trans[i] = -2;\n    }\n\n  /* Set up the success bits for this state.  */\n  d->success[s] = 0;\n  if (accepts_in_context (d->states[s].context, CTX_NEWLINE, s, d))\n    d->success[s] |= CTX_NEWLINE;\n  if (accepts_in_context (d->states[s].context, CTX_LETTER, s, d))\n    d->success[s] |= CTX_LETTER;\n  if (accepts_in_context (d->states[s].context, CTX_NONE, s, d))\n    d->success[s] |= CTX_NONE;\n\n  /* Positions that match the input char.  */\n  leaf_set group;\n  group.elems = xnmalloc (d->nleaves, sizeof *group.elems);\n  group.nelem = 0;\n\n  /* The group's label.  */\n  charclass label;\n  fillset (&label);\n\n  for (size_t i = 0; i < d->states[s].elems.nelem; ++i)\n    {\n      charclass matches;            /* Set of matching characters.  */\n      position pos = d->states[s].elems.elems[i];\n      bool matched = false;\n      if (d->tokens[pos.index] >= 0 && d->tokens[pos.index] < NOTCHAR)\n        {\n          zeroset (&matches);\n          setbit (d->tokens[pos.index], &matches);\n          if (d->tokens[pos.index] == uc)\n            matched = true;\n        }\n      else if (d->tokens[pos.index] >= CSET)\n        {\n          matches = d->charclasses[d->tokens[pos.index] - CSET];\n          if (tstbit (uc, &matches))\n            matched = true;\n        }\n      else if (d->tokens[pos.index] == ANYCHAR)\n        {\n          matches = d->charclasses[d->canychar];\n          if (tstbit (uc, &matches))\n            matched = true;\n\n          /* ANYCHAR must match with a single character, so we must put\n             it to D->states[s].mbps which contains the positions which\n             can match with a single character not a byte.  If all\n             positions which has ANYCHAR does not depend on context of\n             next character, we put the follows instead of it to\n             D->states[s].mbps to optimize.  */\n          if (succeeds_in_context (pos.constraint, d->states[s].context,\n                                   CTX_NONE))\n            {\n              if (d->states[s].mbps.nelem == 0)\n                alloc_position_set (&d->states[s].mbps,\n                                    d->follows[pos.index].nelem);\n              for (size_t j = 0; j < d->follows[pos.index].nelem; j++)\n                insert (d->follows[pos.index].elems[j], &d->states[s].mbps);\n            }\n        }\n      else\n        continue;\n\n      /* Some characters may need to be eliminated from matches because\n         they fail in the current context.  */\n      if (pos.constraint != NO_CONSTRAINT)\n        {\n          if (!succeeds_in_context (pos.constraint,\n                                    d->states[s].context, CTX_NEWLINE))\n            for (size_t j = 0; j < CHARCLASS_WORDS; ++j)\n              matches.w[j] &= ~d->syntax.newline.w[j];\n          if (!succeeds_in_context (pos.constraint,\n                                    d->states[s].context, CTX_LETTER))\n            for (size_t j = 0; j < CHARCLASS_WORDS; ++j)\n              matches.w[j] &= ~d->syntax.letters.w[j];\n          if (!succeeds_in_context (pos.constraint,\n                                    d->states[s].context, CTX_NONE))\n            for (size_t j = 0; j < CHARCLASS_WORDS; ++j)\n              matches.w[j] &= d->syntax.letters.w[j] | d->syntax.newline.w[j];\n\n          /* If there are no characters left, there's no point in going on.  */\n          if (emptyset (&matches))\n            continue;\n\n          /* If we have reset the bit that made us declare \"matched\", reset\n             that indicator, too.  This is required to avoid an infinite loop\n             with this command: echo cx | LC_ALL=C grep -E 'c\\b[x ]'  */\n          if (!tstbit (uc, &matches))\n            matched = false;\n        }\n\n#ifdef DEBUG\n      fprintf (stderr, \" nextpos %zu:\", pos.index);\n      prtok (d->tokens[pos.index]);\n      fprintf (stderr, \" of\");\n      for (size_t j = 0; j < NOTCHAR; j++)\n        if (tstbit (j, &matches))\n          fprintf (stderr, \" 0x%02zx\", j);\n      fprintf (stderr, \"\\n\");\n#endif\n\n      if (matched)\n        {\n          for (size_t k = 0; k < CHARCLASS_WORDS; ++k)\n            label.w[k] &= matches.w[k];\n          group.elems[group.nelem++] = pos.index;\n        }\n      else\n        {\n          for (size_t k = 0; k < CHARCLASS_WORDS; ++k)\n            label.w[k] &= ~matches.w[k];\n        }\n    }\n\n  alloc_position_set (&follows, d->nleaves);\n  alloc_position_set (&tmp, d->nleaves);\n\n  if (group.nelem > 0)\n    {\n      follows.nelem = 0;\n\n      /* Find the union of the follows of the positions of the group.\n         This is a hideously inefficient loop.  Fix it someday.  */\n      for (size_t j = 0; j < group.nelem; ++j)\n        for (size_t k = 0; k < d->follows[group.elems[j]].nelem; ++k)\n          insert (d->follows[group.elems[j]].elems[k], &follows);\n\n      /* If we are building a searching matcher, throw in the positions\n         of state 0 as well, if possible.  */\n      if (d->searchflag)\n        {\n          /* If a token in follows.elems is not 1st byte of a multibyte\n             character, or the states of follows must accept the bytes\n             which are not 1st byte of the multibyte character.\n             Then, if a state of follows encounters a byte, it must not be\n             a 1st byte of a multibyte character nor a single byte character.\n             In this case, do not add state[0].follows to next state, because\n             state[0] must accept 1st-byte.\n\n             For example, suppose <sb a> is a certain single byte character,\n             <mb A> is a certain multibyte character, and the codepoint of\n             <sb a> equals the 2nd byte of the codepoint of <mb A>.  When\n             state[0] accepts <sb a>, state[i] transits to state[i+1] by\n             accepting the 1st byte of <mb A>, and state[i+1] accepts the\n             2nd byte of <mb A>, if state[i+1] encounters the codepoint of\n             <sb a>, it must not be <sb a> but the 2nd byte of <mb A>, so do\n             not add state[0].  */\n\n          bool mergeit = !d->localeinfo.multibyte;\n          if (!mergeit)\n            {\n              mergeit = true;\n              for (size_t j = 0; mergeit && j < follows.nelem; j++)\n                mergeit &= d->multibyte_prop[follows.elems[j].index];\n            }\n          if (mergeit)\n            {\n              merge (&d->states[0].elems, &follows, &tmp);\n              copy (&tmp, &follows);\n            }\n        }\n\n      /* Find out if the new state will want any context information,\n         by calculating possible contexts that the group can match,\n         and separate contexts that the new state wants to know.  */\n      int possible_contexts = charclass_context (d, &label);\n      int separate_contexts = state_separate_contexts (&follows);\n\n      /* Find the state(s) corresponding to the union of the follows.  */\n      if (possible_contexts & ~separate_contexts)\n        state = state_index (d, &follows, separate_contexts ^ CTX_ANY);\n      else\n        state = -1;\n      if (separate_contexts & possible_contexts & CTX_NEWLINE)\n        state_newline = state_index (d, &follows, CTX_NEWLINE);\n      else\n        state_newline = state;\n      if (separate_contexts & possible_contexts & CTX_LETTER)\n        state_letter = state_index (d, &follows, CTX_LETTER);\n      else\n        state_letter = state;\n\n      /* Reallocate now, to reallocate any newline transition properly.  */\n      realloc_trans_if_necessary (d);\n    }\n\n  /* If we are a searching matcher, the default transition is to a state\n     containing the positions of state 0, otherwise the default transition\n     is to fail miserably.  */\n  else if (d->searchflag)\n    {\n      state_newline = 0;\n      state_letter = d->min_trcount - 1;\n      state = d->initstate_notbol;\n    }\n  else\n    {\n      state_newline = -1;\n      state_letter = -1;\n      state = -1;\n    }\n\n  /* Set the transitions for each character in the label.  */\n  for (size_t i = 0; i < NOTCHAR; i++)\n    if (tstbit (i, &label))\n      switch (d->syntax.sbit[i])\n        {\n        case CTX_NEWLINE:\n          trans[i] = state_newline;\n          break;\n        case CTX_LETTER:\n          trans[i] = state_letter;\n          break;\n        default:\n          trans[i] = state;\n          break;\n        }\n\n#ifdef DEBUG\n  fprintf (stderr, \"trans table %td\", s);\n  for (size_t i = 0; i < NOTCHAR; ++i)\n    {\n      if (!(i & 0xf))\n        fprintf (stderr, \"\\n\");\n      fprintf (stderr, \" %2td\", trans[i]);\n    }\n  fprintf (stderr, \"\\n\");\n#endif\n\n  free (group.elems);\n  free (follows.elems);\n  free (tmp.elems);\n\n  /* Keep the newline transition in a special place so we can use it as\n     a sentinel.  */\n  if (tstbit (d->syntax.eolbyte, &label))\n    {\n      d->newlines[s] = trans[d->syntax.eolbyte];\n      trans[d->syntax.eolbyte] = -1;\n    }\n\n  return trans[uc];\n}",
      "lines": 284,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "state_num"
      ]
    },
    "transit_state_singlebyte": {
      "start_point": [
        2976,
        0
      ],
      "end_point": [
        3001,
        1
      ],
      "content": "static state_num\ntransit_state_singlebyte (struct dfa *d, state_num s, unsigned char const **pp)\n{\n  state_num *t;\n\n  if (d->trans[s])\n    t = d->trans[s];\n  else if (d->fails[s])\n    t = d->fails[s];\n  else\n    {\n      build_state (s, d, **pp);\n      if (d->trans[s])\n        t = d->trans[s];\n      else\n        {\n          t = d->fails[s];\n          assert (t);\n        }\n    }\n\n  if (t[**pp] == -2)\n    build_state (s, d, **pp);\n\n  return t[*(*pp)++];\n}",
      "lines": 26,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "state_num"
      ]
    },
    "transit_state": {
      "start_point": [
        3006,
        0
      ],
      "end_point": [
        3075,
        1
      ],
      "content": "static state_num\ntransit_state (struct dfa *d, state_num s, unsigned char const **pp,\n               unsigned char const *end)\n{\n  wint_t wc;\n\n  int mbclen = mbs_to_wchar (&wc, (char const *) *pp, end - *pp, d);\n\n  /* This state has some operators which can match a multibyte character.  */\n  d->mb_follows.nelem = 0;\n\n  /* Calculate the state which can be reached from the state 's' by\n     consuming 'mbclen' single bytes from the buffer.  */\n  state_num s1 = s;\n  int mbci;\n  for (mbci = 0; mbci < mbclen && (mbci == 0 || d->min_trcount <= s); mbci++)\n    s = transit_state_singlebyte (d, s, pp);\n  *pp += mbclen - mbci;\n\n  if (wc == WEOF)\n    {\n      /* It is an invalid character, so ANYCHAR is not accepted.  */\n      return s;\n    }\n\n  /* If all positions which have ANYCHAR do not depend on the context\n     of the next character, calculate the next state with\n     pre-calculated follows and cache the result.  */\n  if (d->states[s1].mb_trindex < 0)\n    {\n      if (MAX_TRCOUNT <= d->mb_trcount)\n        {\n          state_num s3;\n          for (s3 = -1; s3 < d->tralloc; s3++)\n            {\n              free (d->mb_trans[s3]);\n              d->mb_trans[s3] = NULL;\n            }\n\n          for (state_num i = 0; i < d->sindex; i++)\n            d->states[i].mb_trindex = -1;\n          d->mb_trcount = 0;\n        }\n      d->states[s1].mb_trindex = d->mb_trcount++;\n    }\n\n  if (! d->mb_trans[s])\n    {\n      enum { TRANSPTR_SIZE = sizeof *d->mb_trans[s] };\n      enum { TRANSALLOC_SIZE = MAX_TRCOUNT * TRANSPTR_SIZE };\n      d->mb_trans[s] = xmalloc (TRANSALLOC_SIZE);\n      for (int i = 0; i < MAX_TRCOUNT; i++)\n        d->mb_trans[s][i] = -1;\n    }\n  else if (d->mb_trans[s][d->states[s1].mb_trindex] >= 0)\n    return d->mb_trans[s][d->states[s1].mb_trindex];\n\n  if (s == -1)\n    copy (&d->states[s1].mbps, &d->mb_follows);\n  else\n    merge (&d->states[s1].mbps, &d->states[s].elems, &d->mb_follows);\n\n  int separate_contexts = state_separate_contexts (&d->mb_follows);\n  state_num s2 = state_index (d, &d->mb_follows, separate_contexts ^ CTX_ANY);\n  realloc_trans_if_necessary (d);\n\n  d->mb_trans[s][d->states[s1].mb_trindex] = s2;\n\n  return s2;\n}",
      "lines": 70,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "state_num"
      ]
    },
    "skip_remains_mb": {
      "start_point": [
        3092,
        0
      ],
      "end_point": [
        3105,
        1
      ],
      "content": "static unsigned char const *\nskip_remains_mb (struct dfa *d, unsigned char const *p,\n                 unsigned char const *mbp, char const *end)\n{\n  if (d->syntax.never_trail[*p])\n    return p;\n  while (mbp < p)\n    {\n      wint_t wc;\n      mbp += mbs_to_wchar (&wc, (char const *) mbp,\n                           end - (char const *) mbp, d);\n    }\n  return mbp;\n}",
      "lines": 14,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "unsigned char",
        "unsigned",
        "char",
        "const",
        "const",
        "*\nskip_remains_mb (struct dfa *d, unsigned char const *p,\n                 unsigned char const *mbp, char const *end)",
        "*"
      ]
    },
    "dfaexec_main": {
      "start_point": [
        3127,
        0
      ],
      "end_point": [
        3305,
        1
      ],
      "content": "static inline char *\ndfaexec_main (struct dfa *d, char const *begin, char *end, bool allow_nl,\n              size_t *count, bool multibyte)\n{\n  if (MAX_TRCOUNT <= d->sindex)\n    {\n      for (state_num s = d->min_trcount; s < d->sindex; s++)\n        {\n          free (d->states[s].elems.elems);\n          free (d->states[s].mbps.elems);\n        }\n      d->sindex = d->min_trcount;\n\n      if (d->trans)\n        {\n          for (state_num s = 0; s < d->tralloc; s++)\n            {\n              free (d->trans[s]);\n              free (d->fails[s]);\n              d->trans[s] = d->fails[s] = NULL;\n            }\n          d->trcount = 0;\n        }\n\n      if (d->localeinfo.multibyte && d->mb_trans)\n        {\n          for (state_num s = -1; s < d->tralloc; s++)\n            {\n              free (d->mb_trans[s]);\n              d->mb_trans[s] = NULL;\n            }\n          for (state_num s = 0; s < d->min_trcount; s++)\n            d->states[s].mb_trindex = -1;\n          d->mb_trcount = 0;\n        }\n    }\n\n  if (!d->tralloc)\n    realloc_trans_if_necessary (d);\n\n  /* Current state.  */\n  state_num s = 0, s1 = 0;\n\n  /* Current input character.  */\n  unsigned char const *p = (unsigned char const *) begin;\n  unsigned char const *mbp = p;\n\n  /* Copy of d->trans so it can be optimized into a register.  */\n  state_num **trans = d->trans;\n  unsigned char eol = d->syntax.eolbyte;  /* Likewise for eolbyte.  */\n  unsigned char saved_end = *(unsigned char *) end;\n  *end = eol;\n\n  if (multibyte)\n    {\n      memset (&d->mbs, 0, sizeof d->mbs);\n      if (d->mb_follows.alloc == 0)\n        alloc_position_set (&d->mb_follows, d->nleaves);\n    }\n\n  size_t nlcount = 0;\n  for (;;)\n    {\n      state_num *t;\n      while ((t = trans[s]) != NULL)\n        {\n          if (s < d->min_trcount)\n            {\n              if (!multibyte || d->states[s].mbps.nelem == 0)\n                {\n                  while (t[*p] == s)\n                    p++;\n                }\n              if (multibyte)\n                p = mbp = skip_remains_mb (d, p, mbp, end);\n            }\n\n          if (multibyte)\n            {\n              s1 = s;\n\n              if (d->states[s].mbps.nelem == 0\n                  || d->localeinfo.sbctowc[*p] != WEOF || (char *) p >= end)\n                {\n                  /* If an input character does not match ANYCHAR, do it\n                     like a single-byte character.  */\n                  s = t[*p++];\n                }\n              else\n                {\n                  s = transit_state (d, s, &p, (unsigned char *) end);\n                  mbp = p;\n                  trans = d->trans;\n                }\n            }\n          else\n            {\n              s1 = t[*p++];\n              t = trans[s1];\n              if (! t)\n                {\n                  state_num tmp = s;\n                  s = s1;\n                  s1 = tmp;     /* swap */\n                  break;\n                }\n              if (s < d->min_trcount)\n                {\n                  while (t[*p] == s1)\n                    p++;\n                }\n              s = t[*p++];\n            }\n        }\n\n      if (s < 0)\n        {\n          if (s == -2)\n            {\n              s = build_state (s1, d, p[-1]);\n              trans = d->trans;\n            }\n          else if ((char *) p <= end && p[-1] == eol && 0 <= d->newlines[s1])\n            {\n              /* The previous character was a newline.  Count it, and skip\n                 checking of multibyte character boundary until here.  */\n              nlcount++;\n              mbp = p;\n\n              s = (allow_nl ? d->newlines[s1]\n                   : d->syntax.sbit[eol] == CTX_NEWLINE ? 0\n                   : d->syntax.sbit[eol] == CTX_LETTER ? d->min_trcount - 1\n                   : d->initstate_notbol);\n            }\n          else\n            {\n              p = NULL;\n              goto done;\n            }\n        }\n      else if (d->fails[s])\n        {\n          if ((d->success[s] & d->syntax.sbit[*p])\n              || ((char *) p == end\n                  && accepts_in_context (d->states[s].context, CTX_NEWLINE, s,\n                                         d)))\n            goto done;\n\n          if (multibyte && s < d->min_trcount)\n            p = mbp = skip_remains_mb (d, p, mbp, end);\n\n          s1 = s;\n          if (!multibyte || d->states[s].mbps.nelem == 0\n              || d->localeinfo.sbctowc[*p] != WEOF || (char *) p >= end)\n            {\n              /* If a input character does not match ANYCHAR, do it\n                 like a single-byte character.  */\n              s = d->fails[s][*p++];\n            }\n          else\n            {\n              s = transit_state (d, s, &p, (unsigned char *) end);\n              mbp = p;\n              trans = d->trans;\n            }\n        }\n      else\n        {\n          build_state (s, d, p[0]);\n          trans = d->trans;\n        }\n    }\n\n done:\n  if (count)\n    *count += nlcount;\n  *end = saved_end;\n  return (char *) p;\n}",
      "lines": 179,
      "depth": 20,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "char",
        "*\ndfaexec_main (struct dfa *d, char const *begin, char *end, bool allow_nl,\n              size_t *count, bool multibyte)",
        "*"
      ]
    },
    "dfaexec_mb": {
      "start_point": [
        3310,
        0
      ],
      "end_point": [
        3315,
        1
      ],
      "content": "static char *\ndfaexec_mb (struct dfa *d, char const *begin, char *end,\n            bool allow_nl, size_t *count, bool *backref)\n{\n  return dfaexec_main (d, begin, end, allow_nl, count, true);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "char",
        "*\ndfaexec_mb (struct dfa *d, char const *begin, char *end,\n            bool allow_nl, size_t *count, bool *backref)",
        "*"
      ]
    },
    "dfaexec_sb": {
      "start_point": [
        3317,
        0
      ],
      "end_point": [
        3322,
        1
      ],
      "content": "static char *\ndfaexec_sb (struct dfa *d, char const *begin, char *end,\n            bool allow_nl, size_t *count, bool *backref)\n{\n  return dfaexec_main (d, begin, end, allow_nl, count, false);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "char",
        "*\ndfaexec_sb (struct dfa *d, char const *begin, char *end,\n            bool allow_nl, size_t *count, bool *backref)",
        "*"
      ]
    },
    "dfaexec_noop": {
      "start_point": [
        3326,
        0
      ],
      "end_point": [
        3332,
        1
      ],
      "content": "static char *\ndfaexec_noop (struct dfa *d, char const *begin, char *end,\n              bool allow_nl, size_t *count, bool *backref)\n{\n  *backref = true;\n  return (char *) begin;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "char",
        "*\ndfaexec_noop (struct dfa *d, char const *begin, char *end,\n              bool allow_nl, size_t *count, bool *backref)",
        "*"
      ]
    },
    "dfaexec": {
      "start_point": [
        3338,
        0
      ],
      "end_point": [
        3343,
        1
      ],
      "content": "char *\ndfaexec (struct dfa *d, char const *begin, char *end,\n         bool allow_nl, size_t *count, bool *backref)\n{\n  return d->dfaexec (d, begin, end, allow_nl, count, backref);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "char",
        "*\ndfaexec (struct dfa *d, char const *begin, char *end,\n         bool allow_nl, size_t *count, bool *backref)",
        "*"
      ]
    },
    "dfasuperset": {
      "start_point": [
        3345,
        0
      ],
      "end_point": [
        3349,
        1
      ],
      "content": "struct dfa *\ndfasuperset (struct dfa const *d)\n{\n  return d->superset;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "struct dfa",
        "struct",
        "dfa",
        "*\ndfasuperset (struct dfa const *d)",
        "*"
      ]
    },
    "dfaisfast": {
      "start_point": [
        3351,
        0
      ],
      "end_point": [
        3355,
        1
      ],
      "content": "bool\ndfaisfast (struct dfa const *d)\n{\n  return d->fast;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "bool"
      ]
    },
    "free_mbdata": {
      "start_point": [
        3357,
        0
      ],
      "end_point": [
        3371,
        1
      ],
      "content": "static void\nfree_mbdata (struct dfa *d)\n{\n  free (d->multibyte_prop);\n  free (d->lex.brack.chars);\n  free (d->mb_follows.elems);\n\n  if (d->mb_trans)\n    {\n      state_num s;\n      for (s = -1; s < d->tralloc; s++)\n        free (d->mb_trans[s]);\n      free (d->mb_trans - 2);\n    }\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "dfa_supported": {
      "start_point": [
        3374,
        0
      ],
      "end_point": [
        3394,
        1
      ],
      "content": "static bool _GL_ATTRIBUTE_PURE\ndfa_supported (struct dfa const *d)\n{\n  for (size_t i = 0; i < d->tindex; i++)\n    {\n      switch (d->tokens[i])\n        {\n        case BEGWORD:\n        case ENDWORD:\n        case LIMWORD:\n        case NOTLIMWORD:\n          if (!d->localeinfo.multibyte)\n            continue;\n          FALLTHROUGH;\n        case BACKREF:\n        case MBCSET:\n          return false;\n        }\n    }\n  return true;\n}",
      "lines": 21,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "bool",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "dfaoptimize": {
      "start_point": [
        3396,
        0
      ],
      "end_point": [
        3433,
        1
      ],
      "content": "static void\ndfaoptimize (struct dfa *d)\n{\n  if (!d->localeinfo.using_utf8)\n    return;\n\n  bool have_backref = false;\n  for (size_t i = 0; i < d->tindex; ++i)\n    {\n      switch (d->tokens[i])\n        {\n        case ANYCHAR:\n          /* Lowered.  */\n          abort ();\n        case BACKREF:\n          have_backref = true;\n          break;\n        case MBCSET:\n          /* Requires multi-byte algorithm.  */\n          return;\n        default:\n          break;\n        }\n    }\n\n  if (!have_backref && d->superset)\n    {\n      /* The superset DFA is not likely to be much faster, so remove it.  */\n      dfafree (d->superset);\n      free (d->superset);\n      d->superset = NULL;\n    }\n\n  free_mbdata (d);\n  d->localeinfo.multibyte = false;\n  d->dfaexec = dfaexec_sb;\n  d->fast = true;\n}",
      "lines": 38,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "dfassbuild": {
      "start_point": [
        3435,
        0
      ],
      "end_point": [
        3514,
        1
      ],
      "content": "static void\ndfassbuild (struct dfa *d)\n{\n  struct dfa *sup = dfaalloc ();\n\n  *sup = *d;\n  sup->localeinfo.multibyte = false;\n  sup->dfaexec = dfaexec_sb;\n  sup->multibyte_prop = NULL;\n  sup->superset = NULL;\n  sup->states = NULL;\n  sup->sindex = 0;\n  sup->follows = NULL;\n  sup->tralloc = 0;\n  sup->trans = NULL;\n  sup->fails = NULL;\n  sup->success = NULL;\n  sup->newlines = NULL;\n\n  sup->charclasses = xnmalloc (sup->calloc, sizeof *sup->charclasses);\n  if (d->cindex)\n    {\n      memcpy (sup->charclasses, d->charclasses,\n              d->cindex * sizeof *sup->charclasses);\n    }\n\n  sup->tokens = xnmalloc (d->tindex, 2 * sizeof *sup->tokens);\n  sup->talloc = d->tindex * 2;\n\n  bool have_achar = false;\n  bool have_nchar = false;\n  size_t j;\n  for (size_t i = j = 0; i < d->tindex; i++)\n    {\n      switch (d->tokens[i])\n        {\n        case ANYCHAR:\n        case MBCSET:\n        case BACKREF:\n          {\n            charclass ccl;\n            fillset (&ccl);\n            sup->tokens[j++] = CSET + charclass_index (sup, &ccl);\n            sup->tokens[j++] = STAR;\n            if (d->tokens[i + 1] == QMARK || d->tokens[i + 1] == STAR\n                || d->tokens[i + 1] == PLUS)\n              i++;\n            have_achar = true;\n          }\n          break;\n        case BEGWORD:\n        case ENDWORD:\n        case LIMWORD:\n        case NOTLIMWORD:\n          if (d->localeinfo.multibyte)\n            {\n              /* These constraints aren't supported in a multibyte locale.\n                 Ignore them in the superset DFA.  */\n              sup->tokens[j++] = EMPTY;\n              break;\n            }\n          FALLTHROUGH;\n        default:\n          sup->tokens[j++] = d->tokens[i];\n          if ((0 <= d->tokens[i] && d->tokens[i] < NOTCHAR)\n              || d->tokens[i] >= CSET)\n            have_nchar = true;\n          break;\n        }\n    }\n  sup->tindex = j;\n\n  if (have_nchar && (have_achar || d->localeinfo.multibyte))\n    d->superset = sup;\n  else\n    {\n      dfafree (sup);\n      free (sup);\n    }\n}",
      "lines": 80,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "dfacomp": {
      "start_point": [
        3517,
        0
      ],
      "end_point": [
        3538,
        1
      ],
      "content": "void\ndfacomp (char const *s, size_t len, struct dfa *d, bool searchflag)\n{\n  dfaparse (s, len, d);\n  dfassbuild (d);\n\n  if (dfa_supported (d))\n    {\n      dfaoptimize (d);\n      dfaanalyze (d, searchflag);\n    }\n  else\n    {\n      d->dfaexec = dfaexec_noop;\n    }\n\n  if (d->superset)\n    {\n      d->fast = true;\n      dfaanalyze (d->superset, searchflag);\n    }\n}",
      "lines": 22,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "dfafree": {
      "start_point": [
        3541,
        0
      ],
      "end_point": [
        3580,
        1
      ],
      "content": "void\ndfafree (struct dfa *d)\n{\n  free (d->charclasses);\n  free (d->tokens);\n\n  if (d->localeinfo.multibyte)\n    free_mbdata (d);\n\n  for (size_t i = 0; i < d->sindex; ++i)\n    {\n      free (d->states[i].elems.elems);\n      free (d->states[i].mbps.elems);\n    }\n  free (d->states);\n\n  if (d->follows)\n    {\n      for (size_t i = 0; i < d->tindex; ++i)\n        free (d->follows[i].elems);\n      free (d->follows);\n    }\n\n  if (d->trans)\n    {\n      for (size_t i = 0; i < d->tralloc; ++i)\n        {\n          free (d->trans[i]);\n          free (d->fails[i]);\n        }\n\n      free (d->trans - 2);\n      free (d->fails);\n      free (d->newlines);\n      free (d->success);\n    }\n\n  if (d->superset)\n    dfafree (d->superset);\n}",
      "lines": 40,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "icatalloc": {
      "start_point": [
        3664,
        0
      ],
      "end_point": [
        3674,
        1
      ],
      "content": "static char *\nicatalloc (char *old, char const *new)\n{\n  size_t newsize = strlen (new);\n  if (newsize == 0)\n    return old;\n  size_t oldsize = strlen (old);\n  char *result = xrealloc (old, oldsize + newsize + 1);\n  memcpy (result + oldsize, new, newsize + 1);\n  return result;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nicatalloc (char *old, char const *new)",
        "*"
      ]
    },
    "freelist": {
      "start_point": [
        3676,
        0
      ],
      "end_point": [
        3681,
        1
      ],
      "content": "static void\nfreelist (char **cpp)\n{\n  while (*cpp)\n    free (*cpp++);\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "enlist": {
      "start_point": [
        3683,
        0
      ],
      "end_point": [
        3713,
        1
      ],
      "content": "static char **\nenlist (char **cpp, char *new, size_t len)\n{\n  new = memcpy (xmalloc (len + 1), new, len);\n  new[len] = '\\0';\n  /* Is there already something in the list that's new (or longer)?  */\n  size_t i;\n  for (i = 0; cpp[i] != NULL; ++i)\n    if (strstr (cpp[i], new) != NULL)\n      {\n        free (new);\n        return cpp;\n      }\n  /* Eliminate any obsoleted strings.  */\n  for (size_t j = 0; cpp[j] != NULL; )\n    if (strstr (new, cpp[j]) == NULL)\n      ++j;\n    else\n      {\n        free (cpp[j]);\n        if (--i == j)\n          break;\n        cpp[j] = cpp[i];\n        cpp[i] = NULL;\n      }\n  /* Add the new string.  */\n  cpp = xnrealloc (cpp, i + 2, sizeof *cpp);\n  cpp[i] = new;\n  cpp[i + 1] = NULL;\n  return cpp;\n}",
      "lines": 31,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "char",
        "**\nenlist (char **cpp, char *new, size_t len)",
        "*",
        "*\nenlist (char **cpp, char *new, size_t len)",
        "*"
      ]
    },
    "comsubs": {
      "start_point": [
        3717,
        0
      ],
      "end_point": [
        3739,
        1
      ],
      "content": "static char **\ncomsubs (char *left, char const *right)\n{\n  char **cpp = xzalloc (sizeof *cpp);\n\n  for (char *lcp = left; *lcp != '\\0'; lcp++)\n    {\n      size_t len = 0;\n      char *rcp = strchr (right, *lcp);\n      while (rcp != NULL)\n        {\n          size_t i;\n          for (i = 1; lcp[i] != '\\0' && lcp[i] == rcp[i]; ++i)\n            continue;\n          if (i > len)\n            len = i;\n          rcp = strchr (rcp + 1, *lcp);\n        }\n      if (len != 0)\n        cpp = enlist (cpp, lcp, len);\n    }\n  return cpp;\n}",
      "lines": 23,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "char",
        "**\ncomsubs (char *left, char const *right)",
        "*",
        "*\ncomsubs (char *left, char const *right)",
        "*"
      ]
    },
    "addlists": {
      "start_point": [
        3741,
        0
      ],
      "end_point": [
        3747,
        1
      ],
      "content": "static char **\naddlists (char **old, char **new)\n{\n  for (; *new; new++)\n    old = enlist (old, *new, strlen (*new));\n  return old;\n}",
      "lines": 7,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "char",
        "**\naddlists (char **old, char **new)",
        "*",
        "*\naddlists (char **old, char **new)",
        "*"
      ]
    },
    "inboth": {
      "start_point": [
        3751,
        0
      ],
      "end_point": [
        3767,
        1
      ],
      "content": "static char **\ninboth (char **left, char **right)\n{\n  char **both = xzalloc (sizeof *both);\n\n  for (size_t lnum = 0; left[lnum] != NULL; ++lnum)\n    {\n      for (size_t rnum = 0; right[rnum] != NULL; ++rnum)\n        {\n          char **temp = comsubs (left[lnum], right[rnum]);\n          both = addlists (both, temp);\n          freelist (temp);\n          free (temp);\n        }\n    }\n  return both;\n}",
      "lines": 17,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "char",
        "**\ninboth (char **left, char **right)",
        "*",
        "*\ninboth (char **left, char **right)",
        "*"
      ]
    },
    "allocmust": {
      "start_point": [
        3782,
        0
      ],
      "end_point": [
        3794,
        1
      ],
      "content": "static must *\nallocmust (must *mp, size_t size)\n{\n  must *new_mp = xmalloc (sizeof *new_mp);\n  new_mp->in = xzalloc (sizeof *new_mp->in);\n  new_mp->left = xzalloc (size);\n  new_mp->right = xzalloc (size);\n  new_mp->is = xzalloc (size);\n  new_mp->begline = false;\n  new_mp->endline = false;\n  new_mp->prev = mp;\n  return new_mp;\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "must",
        "*\nallocmust (must *mp, size_t size)",
        "*"
      ]
    },
    "resetmust": {
      "start_point": [
        3796,
        0
      ],
      "end_point": [
        3804,
        1
      ],
      "content": "static void\nresetmust (must *mp)\n{\n  freelist (mp->in);\n  mp->in[0] = NULL;\n  mp->left[0] = mp->right[0] = mp->is[0] = '\\0';\n  mp->begline = false;\n  mp->endline = false;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "freemust": {
      "start_point": [
        3806,
        0
      ],
      "end_point": [
        3815,
        1
      ],
      "content": "static void\nfreemust (must *mp)\n{\n  freelist (mp->in);\n  free (mp->in);\n  free (mp->left);\n  free (mp->right);\n  free (mp->is);\n  free (mp);\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "dfamust": {
      "start_point": [
        3817,
        0
      ],
      "end_point": [
        4052,
        1
      ],
      "content": "struct dfamust *\ndfamust (struct dfa const *d)\n{\n  must *mp = NULL;\n  char const *result = \"\";\n  bool exact = false;\n  bool begline = false;\n  bool endline = false;\n  bool need_begline = false;\n  bool need_endline = false;\n  bool case_fold_unibyte = d->syntax.case_fold && MB_CUR_MAX == 1;\n\n  for (size_t ri = 0; ri < d->tindex; ++ri)\n    {\n      token t = d->tokens[ri];\n      switch (t)\n        {\n        case BEGLINE:\n          mp = allocmust (mp, 2);\n          mp->begline = true;\n          need_begline = true;\n          break;\n        case ENDLINE:\n          mp = allocmust (mp, 2);\n          mp->endline = true;\n          need_endline = true;\n          break;\n        case LPAREN:\n        case RPAREN:\n          assert (!\"neither LPAREN nor RPAREN may appear here\");\n\n        case EMPTY:\n        case BEGWORD:\n        case ENDWORD:\n        case LIMWORD:\n        case NOTLIMWORD:\n        case BACKREF:\n        case ANYCHAR:\n        case MBCSET:\n          mp = allocmust (mp, 2);\n          break;\n\n        case STAR:\n        case QMARK:\n          resetmust (mp);\n          break;\n\n        case OR:\n          {\n            char **new;\n            must *rmp = mp;\n            must *lmp = mp = mp->prev;\n            size_t j, ln, rn, n;\n\n            /* Guaranteed to be.  Unlikely, but ...  */\n            if (streq (lmp->is, rmp->is))\n              {\n                lmp->begline &= rmp->begline;\n                lmp->endline &= rmp->endline;\n              }\n            else\n              {\n                lmp->is[0] = '\\0';\n                lmp->begline = false;\n                lmp->endline = false;\n              }\n            /* Left side--easy */\n            size_t i = 0;\n            while (lmp->left[i] != '\\0' && lmp->left[i] == rmp->left[i])\n              ++i;\n            lmp->left[i] = '\\0';\n            /* Right side */\n            ln = strlen (lmp->right);\n            rn = strlen (rmp->right);\n            n = ln;\n            if (n > rn)\n              n = rn;\n            for (i = 0; i < n; ++i)\n              if (lmp->right[ln - i - 1] != rmp->right[rn - i - 1])\n                break;\n            for (j = 0; j < i; ++j)\n              lmp->right[j] = lmp->right[(ln - i) + j];\n            lmp->right[j] = '\\0';\n            new = inboth (lmp->in, rmp->in);\n            freelist (lmp->in);\n            free (lmp->in);\n            lmp->in = new;\n            freemust (rmp);\n          }\n          break;\n\n        case PLUS:\n          mp->is[0] = '\\0';\n          break;\n\n        case END:\n          assert (!mp->prev);\n          for (size_t i = 0; mp->in[i] != NULL; ++i)\n            if (strlen (mp->in[i]) > strlen (result))\n              result = mp->in[i];\n          if (streq (result, mp->is))\n            {\n              if ((!need_begline || mp->begline) && (!need_endline\n                                                     || mp->endline))\n                exact = true;\n              begline = mp->begline;\n              endline = mp->endline;\n            }\n          goto done;\n\n        case CAT:\n          {\n            must *rmp = mp;\n            must *lmp = mp = mp->prev;\n\n            /* In.  Everything in left, plus everything in\n               right, plus concatenation of\n               left's right and right's left.  */\n            lmp->in = addlists (lmp->in, rmp->in);\n            if (lmp->right[0] != '\\0' && rmp->left[0] != '\\0')\n              {\n                size_t lrlen = strlen (lmp->right);\n                size_t rllen = strlen (rmp->left);\n                char *tp = xmalloc (lrlen + rllen);\n                memcpy (tp, lmp->right, lrlen);\n                memcpy (tp + lrlen, rmp->left, rllen);\n                lmp->in = enlist (lmp->in, tp, lrlen + rllen);\n                free (tp);\n              }\n            /* Left-hand */\n            if (lmp->is[0] != '\\0')\n              lmp->left = icatalloc (lmp->left, rmp->left);\n            /* Right-hand */\n            if (rmp->is[0] == '\\0')\n              lmp->right[0] = '\\0';\n            lmp->right = icatalloc (lmp->right, rmp->right);\n            /* Guaranteed to be */\n            if ((lmp->is[0] != '\\0' || lmp->begline)\n                && (rmp->is[0] != '\\0' || rmp->endline))\n              {\n                lmp->is = icatalloc (lmp->is, rmp->is);\n                lmp->endline = rmp->endline;\n              }\n            else\n              {\n                lmp->is[0] = '\\0';\n                lmp->begline = false;\n                lmp->endline = false;\n              }\n            freemust (rmp);\n          }\n          break;\n\n        case '\\0':\n          /* Not on *my* shift.  */\n          goto done;\n\n        default:\n          if (CSET <= t)\n            {\n              /* If T is a singleton, or if case-folding in a unibyte\n                 locale and T's members all case-fold to the same char,\n                 convert T to one of its members.  Otherwise, do\n                 nothing further with T.  */\n              charclass *ccl = &d->charclasses[t - CSET];\n              int j;\n              for (j = 0; j < NOTCHAR; j++)\n                if (tstbit (j, ccl))\n                  break;\n              if (! (j < NOTCHAR))\n                {\n                  mp = allocmust (mp, 2);\n                  break;\n                }\n              t = j;\n              while (++j < NOTCHAR)\n                if (tstbit (j, ccl)\n                    && ! (case_fold_unibyte\n                          && toupper (j) == toupper (t)))\n                  break;\n              if (j < NOTCHAR)\n                {\n                  mp = allocmust (mp, 2);\n                  break;\n                }\n            }\n\n          size_t rj = ri + 2;\n          if (d->tokens[ri + 1] == CAT)\n            {\n              for (; rj < d->tindex - 1; rj += 2)\n                {\n                  if ((rj != ri && (d->tokens[rj] <= 0\n                                    || NOTCHAR <= d->tokens[rj]))\n                      || d->tokens[rj + 1] != CAT)\n                    break;\n                }\n            }\n          mp = allocmust (mp, ((rj - ri) >> 1) + 1);\n          mp->is[0] = mp->left[0] = mp->right[0]\n            = case_fold_unibyte ? toupper (t) : t;\n\n          size_t i;\n          for (i = 1; ri + 2 < rj; i++)\n            {\n              ri += 2;\n              t = d->tokens[ri];\n              mp->is[i] = mp->left[i] = mp->right[i]\n                = case_fold_unibyte ? toupper (t) : t;\n            }\n          mp->is[i] = mp->left[i] = mp->right[i] = '\\0';\n          mp->in = enlist (mp->in, mp->is, i);\n          break;\n        }\n    }\n done:;\n\n  struct dfamust *dm = NULL;\n  if (*result)\n    {\n      dm = xmalloc (sizeof *dm);\n      dm->exact = exact;\n      dm->begline = begline;\n      dm->endline = endline;\n      dm->must = xstrdup (result);\n    }\n\n  while (mp)\n    {\n      must *prev = mp->prev;\n      freemust (mp);\n      mp = prev;\n    }\n\n  return dm;\n}",
      "lines": 236,
      "depth": 22,
      "decorators": [
        "struct dfamust",
        "struct",
        "dfamust",
        "*\ndfamust (struct dfa const *d)",
        "*"
      ]
    },
    "dfamustfree": {
      "start_point": [
        4054,
        0
      ],
      "end_point": [
        4059,
        1
      ],
      "content": "void\ndfamustfree (struct dfamust *dm)\n{\n  free (dm->must);\n  free (dm);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "dfaalloc": {
      "start_point": [
        4061,
        0
      ],
      "end_point": [
        4065,
        1
      ],
      "content": "struct dfa *\ndfaalloc (void)\n{\n  return xzalloc (sizeof (struct dfa));\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "struct dfa",
        "struct",
        "dfa",
        "*\ndfaalloc (void)",
        "*"
      ]
    },
    "dfasyntax": {
      "start_point": [
        4068,
        0
      ],
      "end_point": [
        4108,
        1
      ],
      "content": "void\ndfasyntax (struct dfa *dfa, struct localeinfo const *linfo,\n           reg_syntax_t bits, int dfaopts)\n{\n  memset (dfa, 0, offsetof (struct dfa, dfaexec));\n  dfa->dfaexec = linfo->multibyte ? dfaexec_mb : dfaexec_sb;\n  dfa->simple_locale = using_simple_locale (linfo->multibyte);\n  dfa->localeinfo = *linfo;\n\n  dfa->fast = !dfa->localeinfo.multibyte;\n\n  dfa->canychar = -1;\n  dfa->lex.cur_mb_len = 1;\n  dfa->syntax.syntax_bits_set = true;\n  dfa->syntax.case_fold = (bits & RE_ICASE) != 0;\n  dfa->syntax.anchor = (dfaopts & DFA_ANCHOR) != 0;\n  dfa->syntax.eolbyte = dfaopts & DFA_EOL_NUL ? '\\0' : '\\n';\n  dfa->syntax.syntax_bits = bits;\n\n  for (int i = CHAR_MIN; i <= CHAR_MAX; ++i)\n    {\n      unsigned char uc = i;\n\n      dfa->syntax.sbit[uc] = char_context (dfa, uc);\n      switch (dfa->syntax.sbit[uc])\n        {\n        case CTX_LETTER:\n          setbit (uc, &dfa->syntax.letters);\n          break;\n        case CTX_NEWLINE:\n          setbit (uc, &dfa->syntax.newline);\n          break;\n        }\n\n      /* POSIX requires that the five bytes in \"\\n\\r./\" (including the\n         terminating NUL) cannot occur inside a multibyte character.  */\n      dfa->syntax.never_trail[uc] = (dfa->localeinfo.using_utf8\n                                     ? (uc & 0xc0) != 0x80\n                                     : strchr (\"\\n\\r./\", uc) != NULL);\n    }\n}",
      "lines": 41,
      "depth": 14,
      "decorators": [
        "void"
      ]
    }
  },
  "gawk/gawk-4.2.1/support/dfa.h": {},
  "gawk/gawk-4.2.1/support/getopt.c": {
    "exchange": {
      "start_point": [
        198,
        0
      ],
      "end_point": [
        275,
        1
      ],
      "content": "static void\nexchange (char **argv, struct _getopt_data *d)\n{\n  int bottom = d->__first_nonopt;\n  int middle = d->__last_nonopt;\n  int top = d->optind;\n  char *tem;\n\n  /* Exchange the shorter segment with the far end of the longer segment.\n     That puts the shorter segment into the right place.\n     It leaves the longer segment in the right place overall,\n     but it consists of two parts that need to be swapped next.  */\n\n#if defined _LIBC && defined USE_NONOPTION_FLAGS\n  /* First make sure the handling of the `__getopt_nonoption_flags'\n     string can work normally.  Our top argument must be in the range\n     of the string.  */\n  if (d->__nonoption_flags_len > 0 && top >= d->__nonoption_flags_max_len)\n    {\n      /* We must extend the array.  The user plays games with us and\n\t presents new arguments.  */\n      char *new_str = malloc (top + 1);\n      if (new_str == NULL)\n\td->__nonoption_flags_len = d->__nonoption_flags_max_len = 0;\n      else\n\t{\n\t  memset (__mempcpy (new_str, __getopt_nonoption_flags,\n\t\t\t     d->__nonoption_flags_max_len),\n\t\t  '\\0', top + 1 - d->__nonoption_flags_max_len);\n\t  d->__nonoption_flags_max_len = top + 1;\n\t  __getopt_nonoption_flags = new_str;\n\t}\n    }\n#endif\n\n  while (top > middle && middle > bottom)\n    {\n      if (top - middle > middle - bottom)\n\t{\n\t  /* Bottom segment is the short one.  */\n\t  int len = middle - bottom;\n\t  int i;\n\n\t  /* Swap it with the top part of the top segment.  */\n\t  for (i = 0; i < len; i++)\n\t    {\n\t      tem = argv[bottom + i];\n\t      argv[bottom + i] = argv[top - (middle - bottom) + i];\n\t      argv[top - (middle - bottom) + i] = tem;\n\t      SWAP_FLAGS (bottom + i, top - (middle - bottom) + i);\n\t    }\n\t  /* Exclude the moved bottom segment from further swapping.  */\n\t  top -= len;\n\t}\n      else\n\t{\n\t  /* Top segment is the short one.  */\n\t  int len = top - middle;\n\t  int i;\n\n\t  /* Swap it with the bottom part of the bottom segment.  */\n\t  for (i = 0; i < len; i++)\n\t    {\n\t      tem = argv[bottom + i];\n\t      argv[bottom + i] = argv[middle + i];\n\t      argv[middle + i] = tem;\n\t      SWAP_FLAGS (bottom + i, middle + i);\n\t    }\n\t  /* Exclude the moved top segment from further swapping.  */\n\t  bottom += len;\n\t}\n    }\n\n  /* Update records for the slots the non-options now occupy.  */\n\n  d->__first_nonopt += (d->optind - d->__last_nonopt);\n  d->__last_nonopt = d->optind;\n}",
      "lines": 78,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "_getopt_initialize": {
      "start_point": [
        279,
        0
      ],
      "end_point": [
        341,
        1
      ],
      "content": "static const char *\n_getopt_initialize (int argc, char *const *argv, const char *optstring,\n\t\t    struct _getopt_data *d, int posixly_correct)\n{\n  /* Start processing options with ARGV-element 1 (since ARGV-element 0\n     is the program name); the sequence of previously skipped\n     non-option ARGV-elements is empty.  */\n\n  d->__first_nonopt = d->__last_nonopt = d->optind;\n\n  d->__nextchar = NULL;\n\n  d->__posixly_correct = posixly_correct | !!getenv (\"POSIXLY_CORRECT\");\n\n  /* Determine how to handle the ordering of options and nonoptions.  */\n\n  if (optstring[0] == '-')\n    {\n      d->__ordering = RETURN_IN_ORDER;\n      ++optstring;\n    }\n  else if (optstring[0] == '+')\n    {\n      d->__ordering = REQUIRE_ORDER;\n      ++optstring;\n    }\n  else if (d->__posixly_correct)\n    d->__ordering = REQUIRE_ORDER;\n  else\n    d->__ordering = PERMUTE;\n\n#if defined _LIBC && defined USE_NONOPTION_FLAGS\n  if (!d->__posixly_correct\n      && argc == __libc_argc && argv == __libc_argv)\n    {\n      if (d->__nonoption_flags_max_len == 0)\n\t{\n\t  if (__getopt_nonoption_flags == NULL\n\t      || __getopt_nonoption_flags[0] == '\\0')\n\t    d->__nonoption_flags_max_len = -1;\n\t  else\n\t    {\n\t      const char *orig_str = __getopt_nonoption_flags;\n\t      int len = d->__nonoption_flags_max_len = strlen (orig_str);\n\t      if (d->__nonoption_flags_max_len < argc)\n\t\td->__nonoption_flags_max_len = argc;\n\t      __getopt_nonoption_flags =\n\t\t(char *) malloc (d->__nonoption_flags_max_len);\n\t      if (__getopt_nonoption_flags == NULL)\n\t\td->__nonoption_flags_max_len = -1;\n\t      else\n\t\tmemset (__mempcpy (__getopt_nonoption_flags, orig_str, len),\n\t\t\t'\\0', d->__nonoption_flags_max_len - len);\n\t    }\n\t}\n      d->__nonoption_flags_len = d->__nonoption_flags_max_len;\n    }\n  else\n    d->__nonoption_flags_len = 0;\n#endif\n\n  return optstring;\n}",
      "lines": 63,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\n_getopt_initialize (int argc, char *const *argv, const char *optstring,\n\t\t    struct _getopt_data *d, int posixly_correct)",
        "*"
      ]
    },
    "_getopt_internal_r": {
      "start_point": [
        399,
        0
      ],
      "end_point": [
        1180,
        1
      ],
      "content": "int\n_getopt_internal_r (int argc, char *const *argv, const char *optstring,\n\t\t    const struct option *longopts, int *longind,\n\t\t    int long_only, struct _getopt_data *d, int posixly_correct)\n{\n  int print_errors = d->opterr;\n\n  if (argc < 1)\n    return -1;\n\n  d->optarg = NULL;\n\n  if (d->optind == 0 || !d->__initialized)\n    {\n      if (d->optind == 0)\n\td->optind = 1;\t/* Don't scan ARGV[0], the program name.  */\n      optstring = _getopt_initialize (argc, argv, optstring, d,\n\t\t\t\t      posixly_correct);\n      d->__initialized = 1;\n    }\n  else if (optstring[0] == '-' || optstring[0] == '+')\n    optstring++;\n  if (optstring[0] == ':')\n    print_errors = 0;\n\n  /* Test whether ARGV[optind] points to a non-option argument.\n     Either it does not have option syntax, or there is an environment flag\n     from the shell indicating it is not an option.  The later information\n     is only used when the used in the GNU libc.  */\n#if defined _LIBC && defined USE_NONOPTION_FLAGS\n# define NONOPTION_P (argv[d->optind][0] != '-' || argv[d->optind][1] == '\\0' \\\n\t\t      || (d->optind < d->__nonoption_flags_len\t\t      \\\n\t\t\t  && __getopt_nonoption_flags[d->optind] == '1'))\n#else\n# define NONOPTION_P (argv[d->optind][0] != '-' || argv[d->optind][1] == '\\0')\n#endif\n\n  if (d->__nextchar == NULL || *d->__nextchar == '\\0')\n    {\n      /* Advance to the next ARGV-element.  */\n\n      /* Give FIRST_NONOPT & LAST_NONOPT rational values if OPTIND has been\n\t moved back by the user (who may also have changed the arguments).  */\n      if (d->__last_nonopt > d->optind)\n\td->__last_nonopt = d->optind;\n      if (d->__first_nonopt > d->optind)\n\td->__first_nonopt = d->optind;\n\n      if (d->__ordering == PERMUTE)\n\t{\n\t  /* If we have just processed some options following some non-options,\n\t     exchange them so that the options come first.  */\n\n\t  if (d->__first_nonopt != d->__last_nonopt\n\t      && d->__last_nonopt != d->optind)\n\t    exchange ((char **) argv, d);\n\t  else if (d->__last_nonopt != d->optind)\n\t    d->__first_nonopt = d->optind;\n\n\t  /* Skip any additional non-options\n\t     and extend the range of non-options previously skipped.  */\n\n\t  while (d->optind < argc && NONOPTION_P)\n\t    d->optind++;\n\t  d->__last_nonopt = d->optind;\n\t}\n\n      /* The special ARGV-element `--' means premature end of options.\n\t Skip it like a null option,\n\t then exchange with previous non-options as if it were an option,\n\t then skip everything else like a non-option.  */\n\n      if (d->optind != argc && !strcmp (argv[d->optind], \"--\"))\n\t{\n\t  d->optind++;\n\n\t  if (d->__first_nonopt != d->__last_nonopt\n\t      && d->__last_nonopt != d->optind)\n\t    exchange ((char **) argv, d);\n\t  else if (d->__first_nonopt == d->__last_nonopt)\n\t    d->__first_nonopt = d->optind;\n\t  d->__last_nonopt = argc;\n\n\t  d->optind = argc;\n\t}\n\n      /* If we have done all the ARGV-elements, stop the scan\n\t and back over any non-options that we skipped and permuted.  */\n\n      if (d->optind == argc)\n\t{\n\t  /* Set the next-arg-index to point at the non-options\n\t     that we previously skipped, so the caller will digest them.  */\n\t  if (d->__first_nonopt != d->__last_nonopt)\n\t    d->optind = d->__first_nonopt;\n\t  return -1;\n\t}\n\n      /* If we have come to a non-option and did not permute it,\n\t either stop the scan or describe it to the caller and pass it by.  */\n\n      if (NONOPTION_P)\n\t{\n\t  if (d->__ordering == REQUIRE_ORDER)\n\t    return -1;\n\t  d->optarg = argv[d->optind++];\n\t  return 1;\n\t}\n\n      /* We have found another option-ARGV-element.\n\t Skip the initial punctuation.  */\n\n      d->__nextchar = (argv[d->optind] + 1\n\t\t  + (longopts != NULL && argv[d->optind][1] == '-'));\n    }\n\n  /* Decode the current option-ARGV-element.  */\n\n  /* Check whether the ARGV-element is a long option.\n\n     If long_only and the ARGV-element has the form \"-f\", where f is\n     a valid short option, don't consider it an abbreviated form of\n     a long option that starts with f.  Otherwise there would be no\n     way to give the -f short option.\n\n     On the other hand, if there's a long option \"fubar\" and\n     the ARGV-element is \"-fu\", do consider that an abbreviation of\n     the long option, just like \"--fu\", and not \"-f\" with arg \"u\".\n\n     This distinction seems to be the most useful approach.  */\n\n  if (longopts != NULL\n      && (argv[d->optind][1] == '-'\n\t  || (long_only && (argv[d->optind][2]\n\t\t\t    || !strchr (optstring, argv[d->optind][1])))))\n    {\n      char *nameend;\n      unsigned int namelen;\n      const struct option *p;\n      const struct option *pfound = NULL;\n      struct option_list\n      {\n\tconst struct option *p;\n\tstruct option_list *next;\n\tint needs_free;\n      } *ambig_list = NULL;\n      int exact = 0;\n      int indfound = -1;\n      int option_index;\n\n      for (nameend = d->__nextchar; *nameend && *nameend != '='; nameend++)\n\t/* Do nothing.  */ ;\n      namelen = nameend - d->__nextchar;\n\n      /* Test all long options for either exact match\n\t or abbreviated matches.  */\n      for (p = longopts, option_index = 0; p->name; p++, option_index++)\n\tif (!strncmp (p->name, d->__nextchar, namelen))\n\t  {\n\t    if (namelen == (unsigned int) strlen (p->name))\n\t      {\n\t\t/* Exact match found.  */\n\t\tpfound = p;\n\t\tindfound = option_index;\n\t\texact = 1;\n\t\tbreak;\n\t      }\n\t    else if (pfound == NULL)\n\t      {\n\t\t/* First nonexact match found.  */\n\t\tpfound = p;\n\t\tindfound = option_index;\n\t      }\n\t    else if (long_only\n\t\t     || pfound->has_arg != p->has_arg\n\t\t     || pfound->flag != p->flag\n\t\t     || pfound->val != p->val)\n\t      {\n\t\t/* Second or later nonexact match found.  */\n\t\tstruct option_list *newp = malloc (sizeof (*newp));\n\t\tnewp->p = p;\n\t\tnewp->needs_free = 1;\n\t\tnewp->next = ambig_list;\n\t\tambig_list = newp;\n\t      }\n\t  }\n\n      if (ambig_list != NULL && !exact)\n\t{\n\t  if (print_errors)\n\t    {\n\t      struct option_list first;\n\t      first.p = pfound;\n\t      first.next = ambig_list;\n\t      first.needs_free = 0;\n\t      ambig_list = &first;\n\n#if defined _LIBC\n\t      char *buf = NULL;\n\t      size_t buflen = 0;\n\n\t      FILE *fp = __open_memstream (&buf, &buflen);\n\t      if (fp != NULL)\n\t\t{\n\t\t  fprintf (fp,\n\t\t\t   _(\"%s: option '%s' is ambiguous; possibilities:\"),\n\t\t\t   argv[0], argv[d->optind]);\n\n\t\t  do\n\t\t    {\n\t\t      fprintf (fp, \" '--%s'\", ambig_list->p->name);\n\t\t      ambig_list = ambig_list->next;\n\t\t    }\n\t\t  while (ambig_list != NULL);\n\n\t\t  fputc_unlocked ('\\n', fp);\n\n\t\t  if (__glibc_likely (fclose (fp) != EOF))\n\t\t    {\n\t\t      _IO_flockfile (stderr);\n\n\t\t      int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n\t\t      ((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;\n\n\t\t      __fxprintf (NULL, \"%s\", buf);\n\n\t\t      ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n\t\t      _IO_funlockfile (stderr);\n\n\t\t      free (buf);\n\t\t    }\n\t\t}\n#else\n\t      fprintf (stderr,\n\t\t       _(\"%s: option '%s' is ambiguous; possibilities:\"),\n\t\t       argv[0], argv[d->optind]);\n\t      do\n\t\t{\n\t\t  struct option_list *tmp_next;\n\n\t\t  fprintf (stderr, \" '--%s'\", ambig_list->p->name);\n\t\t  tmp_next = ambig_list->next;\n\t\t  if (ambig_list->needs_free)\n\t\t    free(ambig_list);\n\t\t  ambig_list = tmp_next;\n\t\t}\n\t      while (ambig_list != NULL);\n\n\t      fputc ('\\n', stderr);\n#endif\n\t    }\n\t  d->__nextchar += strlen (d->__nextchar);\n\t  d->optind++;\n\t  d->optopt = 0;\n\t  return '?';\n\t}\n\n      if (pfound != NULL)\n\t{\n\t  option_index = indfound;\n\t  d->optind++;\n\t  if (*nameend)\n\t    {\n\t      /* Don't test has_arg with >, because some C compilers don't\n\t\t allow it to be used on enums.  */\n\t      if (pfound->has_arg)\n\t\td->optarg = nameend + 1;\n\t      else\n\t\t{\n\t\t  if (print_errors)\n\t\t    {\n#if defined _LIBC\n\t\t      char *buf;\n\t\t      int n;\n#endif\n\n\t\t      if (argv[d->optind - 1][1] == '-')\n\t\t\t{\n\t\t\t  /* --option */\n#if defined _LIBC\n\t\t\t  n = __asprintf (&buf, _(\"\\\n%s: option '--%s' doesn't allow an argument\\n\"),\n\t\t\t\t\t  argv[0], pfound->name);\n#else\n\t\t\t  fprintf (stderr, _(\"\\\n%s: option '--%s' doesn't allow an argument\\n\"),\n\t\t\t\t   argv[0], pfound->name);\n#endif\n\t\t\t}\n\t\t      else\n\t\t\t{\n\t\t\t  /* +option or -option */\n#if defined _LIBC\n\t\t\t  n = __asprintf (&buf, _(\"\\\n%s: option '%c%s' doesn't allow an argument\\n\"),\n\t\t\t\t\t  argv[0], argv[d->optind - 1][0],\n\t\t\t\t\t  pfound->name);\n#else\n\t\t\t  fprintf (stderr, _(\"\\\n%s: option '%c%s' doesn't allow an argument\\n\"),\n\t\t\t\t   argv[0], argv[d->optind - 1][0],\n\t\t\t\t   pfound->name);\n#endif\n\t\t\t}\n\n#if defined _LIBC\n\t\t      if (n >= 0)\n\t\t\t{\n\t\t\t  _IO_flockfile (stderr);\n\n\t\t\t  int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n\t\t\t  ((_IO_FILE *) stderr)->_flags2\n\t\t\t    |= _IO_FLAGS2_NOTCANCEL;\n\n\t\t\t  __fxprintf (NULL, \"%s\", buf);\n\n\t\t\t  ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n\t\t\t  _IO_funlockfile (stderr);\n\n\t\t\t  free (buf);\n\t\t\t}\n#endif\n\t\t    }\n\n\t\t  d->__nextchar += strlen (d->__nextchar);\n\n\t\t  d->optopt = pfound->val;\n\t\t  return '?';\n\t\t}\n\t    }\n\t  else if (pfound->has_arg == 1)\n\t    {\n\t      if (d->optind < argc)\n\t\td->optarg = argv[d->optind++];\n\t      else\n\t\t{\n\t\t  if (print_errors)\n\t\t    {\n#if defined _LIBC\n\t\t      char *buf;\n\n\t\t      if (__asprintf (&buf, _(\"\\\n%s: option '--%s' requires an argument\\n\"),\n\t\t\t\t      argv[0], pfound->name) >= 0)\n\t\t\t{\n\t\t\t  _IO_flockfile (stderr);\n\n\t\t\t  int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n\t\t\t  ((_IO_FILE *) stderr)->_flags2\n\t\t\t    |= _IO_FLAGS2_NOTCANCEL;\n\n\t\t\t  __fxprintf (NULL, \"%s\", buf);\n\n\t\t\t  ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n\t\t\t  _IO_funlockfile (stderr);\n\n\t\t\t  free (buf);\n\t\t\t}\n#else\n\t\t      fprintf (stderr,\n\t\t\t       _(\"%s: option '--%s' requires an argument\\n\"),\n\t\t\t       argv[0], pfound->name);\n#endif\n\t\t    }\n\t\t  d->__nextchar += strlen (d->__nextchar);\n\t\t  d->optopt = pfound->val;\n\t\t  return optstring[0] == ':' ? ':' : '?';\n\t\t}\n\t    }\n\t  d->__nextchar += strlen (d->__nextchar);\n\t  if (longind != NULL)\n\t    *longind = option_index;\n\t  if (pfound->flag)\n\t    {\n\t      *(pfound->flag) = pfound->val;\n\t      return 0;\n\t    }\n\t  return pfound->val;\n\t}\n\n      /* Can't find it as a long option.  If this is not getopt_long_only,\n\t or the option starts with '--' or is not a valid short\n\t option, then it's an error.\n\t Otherwise interpret it as a short option.  */\n      if (!long_only || argv[d->optind][1] == '-'\n\t  || strchr (optstring, *d->__nextchar) == NULL)\n\t{\n\t  if (print_errors)\n\t    {\n#if defined _LIBC\n\t      char *buf;\n\t      int n;\n#endif\n\n\t      if (argv[d->optind][1] == '-')\n\t\t{\n\t\t  /* --option */\n#if defined _LIBC\n\t\t  n = __asprintf (&buf, _(\"%s: unrecognized option '--%s'\\n\"),\n\t\t\t\t  argv[0], d->__nextchar);\n#else\n\t\t  fprintf (stderr, _(\"%s: unrecognized option '--%s'\\n\"),\n\t\t\t   argv[0], d->__nextchar);\n#endif\n\t\t}\n\t      else\n\t\t{\n\t\t  /* +option or -option */\n#if defined _LIBC\n\t\t  n = __asprintf (&buf, _(\"%s: unrecognized option '%c%s'\\n\"),\n\t\t\t\t  argv[0], argv[d->optind][0], d->__nextchar);\n#else\n\t\t  fprintf (stderr, _(\"%s: unrecognized option '%c%s'\\n\"),\n\t\t\t   argv[0], argv[d->optind][0], d->__nextchar);\n#endif\n\t\t}\n\n#if defined _LIBC\n\t      if (n >= 0)\n\t\t{\n\t\t  _IO_flockfile (stderr);\n\n\t\t  int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n\t\t  ((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;\n\n\t\t  __fxprintf (NULL, \"%s\", buf);\n\n\t\t  ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n\t\t  _IO_funlockfile (stderr);\n\n\t\t  free (buf);\n\t\t}\n#endif\n\t    }\n\t  d->__nextchar = (char *) \"\";\n\t  d->optind++;\n\t  d->optopt = 0;\n\t  return '?';\n\t}\n    }\n\n  /* Look at and handle the next short option-character.  */\n\n  {\n    char c = *d->__nextchar++;\n    char *temp = strchr (optstring, c);\n\n    /* Increment `optind' when we start to process its last character.  */\n    if (*d->__nextchar == '\\0')\n      ++d->optind;\n\n    if (temp == NULL || c == ':' || c == ';')\n      {\n\tif (print_errors)\n\t  {\n#if defined _LIBC\n\t    char *buf;\n\t    int n;\n#endif\n\n#if defined _LIBC\n\t    n = __asprintf (&buf, _(\"%s: invalid option -- '%c'\\n\"),\n\t\t\t    argv[0], c);\n#else\n\t    fprintf (stderr, _(\"%s: invalid option -- '%c'\\n\"), argv[0], c);\n#endif\n\n#if defined _LIBC\n\t    if (n >= 0)\n\t      {\n\t\t_IO_flockfile (stderr);\n\n\t\tint old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n\t\t((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;\n\n\t\t__fxprintf (NULL, \"%s\", buf);\n\n\t\t((_IO_FILE *) stderr)->_flags2 = old_flags2;\n\t\t_IO_funlockfile (stderr);\n\n\t\tfree (buf);\n\t      }\n#endif\n\t  }\n\td->optopt = c;\n\treturn '?';\n      }\n    /* Convenience. Treat POSIX -W foo same as long option --foo */\n    if (temp[0] == 'W' && temp[1] == ';')\n      {\n\tchar *nameend;\n\tconst struct option *p;\n\tconst struct option *pfound = NULL;\n\tint exact = 0;\n\tint ambig = 0;\n\tint indfound = 0;\n\tint option_index;\n\n\tif (longopts == NULL)\n\t  goto no_longs;\n\n\t/* This is an option that requires an argument.  */\n\tif (*d->__nextchar != '\\0')\n\t  {\n\t    d->optarg = d->__nextchar;\n\t    /* If we end this ARGV-element by taking the rest as an arg,\n\t       we must advance to the next element now.  */\n\t    d->optind++;\n\t  }\n\telse if (d->optind == argc)\n\t  {\n\t    if (print_errors)\n\t      {\n#if defined _LIBC\n\t\tchar *buf;\n\n\t\tif (__asprintf (&buf,\n\t\t\t\t_(\"%s: option requires an argument -- '%c'\\n\"),\n\t\t\t\targv[0], c) >= 0)\n\t\t  {\n\t\t    _IO_flockfile (stderr);\n\n\t\t    int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n\t\t    ((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;\n\n\t\t    __fxprintf (NULL, \"%s\", buf);\n\n\t\t    ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n\t\t    _IO_funlockfile (stderr);\n\n\t\t    free (buf);\n\t\t  }\n#else\n\t\tfprintf (stderr,\n\t\t\t _(\"%s: option requires an argument -- '%c'\\n\"),\n\t\t\t argv[0], c);\n#endif\n\t      }\n\t    d->optopt = c;\n\t    if (optstring[0] == ':')\n\t      c = ':';\n\t    else\n\t      c = '?';\n\t    return c;\n\t  }\n\telse\n\t  /* We already incremented `d->optind' once;\n\t     increment it again when taking next ARGV-elt as argument.  */\n\t  d->optarg = argv[d->optind++];\n\n\t/* optarg is now the argument, see if it's in the\n\t   table of longopts.  */\n\n\tfor (d->__nextchar = nameend = d->optarg; *nameend && *nameend != '=';\n\t     nameend++)\n\t  /* Do nothing.  */ ;\n\n\t/* Test all long options for either exact match\n\t   or abbreviated matches.  */\n\tfor (p = longopts, option_index = 0; p->name; p++, option_index++)\n\t  if (!strncmp (p->name, d->__nextchar, nameend - d->__nextchar))\n\t    {\n\t      if ((unsigned int) (nameend - d->__nextchar) == strlen (p->name))\n\t\t{\n\t\t  /* Exact match found.  */\n\t\t  pfound = p;\n\t\t  indfound = option_index;\n\t\t  exact = 1;\n\t\t  break;\n\t\t}\n\t      else if (pfound == NULL)\n\t\t{\n\t\t  /* First nonexact match found.  */\n\t\t  pfound = p;\n\t\t  indfound = option_index;\n\t\t}\n\t      else if (long_only\n\t\t       || pfound->has_arg != p->has_arg\n\t\t       || pfound->flag != p->flag\n\t\t       || pfound->val != p->val)\n\t\t/* Second or later nonexact match found.  */\n\t\tambig = 1;\n\t    }\n\tif (ambig && !exact)\n\t  {\n\t    if (print_errors)\n\t      {\n#if defined _LIBC\n\t\tchar *buf;\n\n\t\tif (__asprintf (&buf, _(\"%s: option '-W %s' is ambiguous\\n\"),\n\t\t\t\targv[0], d->optarg) >= 0)\n\t\t  {\n\t\t    _IO_flockfile (stderr);\n\n\t\t    int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n\t\t    ((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;\n\n\t\t    __fxprintf (NULL, \"%s\", buf);\n\n\t\t    ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n\t\t    _IO_funlockfile (stderr);\n\n\t\t    free (buf);\n\t\t  }\n#else\n\t\tfprintf (stderr, _(\"%s: option '-W %s' is ambiguous\\n\"),\n\t\t\t argv[0], d->optarg);\n#endif\n\t      }\n\t    d->__nextchar += strlen (d->__nextchar);\n\t    d->optind++;\n\t    return '?';\n\t  }\n\tif (pfound != NULL)\n\t  {\n\t    option_index = indfound;\n\t    if (*nameend)\n\t      {\n\t\t/* Don't test has_arg with >, because some C compilers don't\n\t\t   allow it to be used on enums.  */\n\t\tif (pfound->has_arg)\n\t\t  d->optarg = nameend + 1;\n\t\telse\n\t\t  {\n\t\t    if (print_errors)\n\t\t      {\n#if defined _LIBC\n\t\t\tchar *buf;\n\n\t\t\tif (__asprintf (&buf, _(\"\\\n%s: option '-W %s' doesn't allow an argument\\n\"),\n\t\t\t\t\targv[0], pfound->name) >= 0)\n\t\t\t  {\n\t\t\t    _IO_flockfile (stderr);\n\n\t\t\t    int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n\t\t\t    ((_IO_FILE *) stderr)->_flags2\n\t\t\t      |= _IO_FLAGS2_NOTCANCEL;\n\n\t\t\t    __fxprintf (NULL, \"%s\", buf);\n\n\t\t\t    ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n\t\t\t    _IO_funlockfile (stderr);\n\n\t\t\t    free (buf);\n\t\t\t  }\n#else\n\t\t\tfprintf (stderr, _(\"\\\n%s: option '-W %s' doesn't allow an argument\\n\"),\n\t\t\t\t argv[0], pfound->name);\n#endif\n\t\t      }\n\n\t\t    d->__nextchar += strlen (d->__nextchar);\n\t\t    return '?';\n\t\t  }\n\t      }\n\t    else if (pfound->has_arg == 1)\n\t      {\n\t\tif (d->optind < argc)\n\t\t  d->optarg = argv[d->optind++];\n\t\telse\n\t\t  {\n\t\t    if (print_errors)\n\t\t      {\n#if defined _LIBC\n\t\t\tchar *buf;\n\n\t\t\tif (__asprintf (&buf, _(\"\\\n%s: option '-W %s' requires an argument\\n\"),\n\t\t\t\t\targv[0], pfound->name) >= 0)\n\t\t\t  {\n\t\t\t    _IO_flockfile (stderr);\n\n\t\t\t    int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n\t\t\t    ((_IO_FILE *) stderr)->_flags2\n\t\t\t      |= _IO_FLAGS2_NOTCANCEL;\n\n\t\t\t    __fxprintf (NULL, \"%s\", buf);\n\n\t\t\t    ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n\t\t\t    _IO_funlockfile (stderr);\n\n\t\t\t    free (buf);\n\t\t\t  }\n#else\n\t\t\tfprintf (stderr, _(\"\\\n%s: option '-W %s' requires an argument\\n\"),\n\t\t\t\t argv[0], pfound->name);\n#endif\n\t\t      }\n\t\t    d->__nextchar += strlen (d->__nextchar);\n\t\t    return optstring[0] == ':' ? ':' : '?';\n\t\t  }\n\t      }\n\t    else\n\t      d->optarg = NULL;\n\t    d->__nextchar += strlen (d->__nextchar);\n\t    if (longind != NULL)\n\t      *longind = option_index;\n\t    if (pfound->flag)\n\t      {\n\t\t*(pfound->flag) = pfound->val;\n\t\treturn 0;\n\t      }\n\t    return pfound->val;\n\t  }\n\n      no_longs:\n\td->__nextchar = NULL;\n\treturn 'W';\t/* Let the application handle it.   */\n      }\n    if (temp[1] == ':')\n      {\n\tif (temp[2] == ':')\n\t  {\n\t    /* This is an option that accepts an argument optionally.  */\n\t    if (*d->__nextchar != '\\0')\n\t      {\n\t\td->optarg = d->__nextchar;\n\t\td->optind++;\n\t      }\n\t    else\n\t      d->optarg = NULL;\n\t    d->__nextchar = NULL;\n\t  }\n\telse\n\t  {\n\t    /* This is an option that requires an argument.  */\n\t    if (*d->__nextchar != '\\0')\n\t      {\n\t\td->optarg = d->__nextchar;\n\t\t/* If we end this ARGV-element by taking the rest as an arg,\n\t\t   we must advance to the next element now.  */\n\t\td->optind++;\n\t      }\n\t    else if (d->optind == argc)\n\t      {\n\t\tif (print_errors)\n\t\t  {\n#if defined _LIBC\n\t\t    char *buf;\n\n\t\t    if (__asprintf (&buf, _(\"\\\n%s: option requires an argument -- '%c'\\n\"),\n\t\t\t\t    argv[0], c) >= 0)\n\t\t      {\n\t\t\t_IO_flockfile (stderr);\n\n\t\t\tint old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n\t\t\t((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;\n\n\t\t\t__fxprintf (NULL, \"%s\", buf);\n\n\t\t\t((_IO_FILE *) stderr)->_flags2 = old_flags2;\n\t\t\t_IO_funlockfile (stderr);\n\n\t\t\tfree (buf);\n\t\t      }\n#else\n\t\t    fprintf (stderr,\n\t\t\t     _(\"%s: option requires an argument -- '%c'\\n\"),\n\t\t\t     argv[0], c);\n#endif\n\t\t  }\n\t\td->optopt = c;\n\t\tif (optstring[0] == ':')\n\t\t  c = ':';\n\t\telse\n\t\t  c = '?';\n\t      }\n\t    else\n\t      /* We already incremented `optind' once;\n\t\t increment it again when taking next ARGV-elt as argument.  */\n\t      d->optarg = argv[d->optind++];\n\t    d->__nextchar = NULL;\n\t  }\n      }\n    return c;\n  }\n}",
      "lines": 782,
      "depth": 25,
      "decorators": [
        "int"
      ]
    },
    "_getopt_internal": {
      "start_point": [
        1182,
        0
      ],
      "end_point": [
        1201,
        1
      ],
      "content": "int\n_getopt_internal (int argc, char *const *argv, const char *optstring,\n\t\t  const struct option *longopts, int *longind, int long_only,\n\t\t  int posixly_correct)\n{\n  int result;\n\n  getopt_data.optind = optind;\n  getopt_data.opterr = opterr;\n\n  result = _getopt_internal_r (argc, argv, optstring, longopts,\n\t\t\t       longind, long_only, &getopt_data,\n\t\t\t       posixly_correct);\n\n  optind = getopt_data.optind;\n  optarg = getopt_data.optarg;\n  optopt = getopt_data.optopt;\n\n  return result;\n}",
      "lines": 20,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "getopt": {
      "start_point": [
        1203,
        0
      ],
      "end_point": [
        1210,
        1
      ],
      "content": "int\ngetopt (int argc, char *const *argv, const char *optstring)\n{\n  return _getopt_internal (argc, argv, optstring,\n\t\t\t   (const struct option *) 0,\n\t\t\t   (int *) 0,\n\t\t\t   0, 0);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "__posix_getopt": {
      "start_point": [
        1213,
        0
      ],
      "end_point": [
        1220,
        1
      ],
      "content": "int\n__posix_getopt (int argc, char *const *argv, const char *optstring)\n{\n  return _getopt_internal (argc, argv, optstring,\n\t\t\t   (const struct option *) 0,\n\t\t\t   (int *) 0,\n\t\t\t   0, 1);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "main": {
      "start_point": [
        1230,
        0
      ],
      "end_point": [
        1291,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  int c;\n  int digit_optind = 0;\n\n  while (1)\n    {\n      int this_option_optind = optind ? optind : 1;\n\n      c = getopt (argc, argv, \"abc:d:0123456789\");\n      if (c == -1)\n\tbreak;\n\n      switch (c)\n\t{\n\tcase '0':\n\tcase '1':\n\tcase '2':\n\tcase '3':\n\tcase '4':\n\tcase '5':\n\tcase '6':\n\tcase '7':\n\tcase '8':\n\tcase '9':\n\t  if (digit_optind != 0 && digit_optind != this_option_optind)\n\t    printf (\"digits occur in two different argv-elements.\\n\");\n\t  digit_optind = this_option_optind;\n\t  printf (\"option %c\\n\", c);\n\t  break;\n\n\tcase 'a':\n\t  printf (\"option a\\n\");\n\t  break;\n\n\tcase 'b':\n\t  printf (\"option b\\n\");\n\t  break;\n\n\tcase 'c':\n\t  printf (\"option c with value '%s'\\n\", optarg);\n\t  break;\n\n\tcase '?':\n\t  break;\n\n\tdefault:\n\t  printf (\"?? getopt returned character code 0%o ??\\n\", c);\n\t}\n    }\n\n  if (optind < argc)\n    {\n      printf (\"non-option ARGV-elements: \");\n      while (optind < argc)\n\tprintf (\"%s \", argv[optind++]);\n      printf (\"\\n\");\n    }\n\n  exit (0);\n}",
      "lines": 62,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "gawk/gawk-4.2.1/support/getopt.h": {},
  "gawk/gawk-4.2.1/support/getopt1.c": {
    "getopt_long": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "int\ngetopt_long (int argc, char *const *argv, const char *options,\n\t     const struct option *long_options, int *opt_index)\n{\n  return _getopt_internal (argc, argv, options, long_options, opt_index, 0, 0);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "_getopt_long_r": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "int\n_getopt_long_r (int argc, char *const *argv, const char *options,\n\t\tconst struct option *long_options, int *opt_index,\n\t\tstruct _getopt_data *d)\n{\n  return _getopt_internal_r (argc, argv, options, long_options, opt_index,\n\t\t\t     0, d, 0);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "getopt_long_only": {
      "start_point": [
        86,
        0
      ],
      "end_point": [
        91,
        1
      ],
      "content": "int\ngetopt_long_only (int argc, char *const *argv, const char *options,\n\t\t  const struct option *long_options, int *opt_index)\n{\n  return _getopt_internal (argc, argv, options, long_options, opt_index, 1, 0);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "_getopt_long_only_r": {
      "start_point": [
        93,
        0
      ],
      "end_point": [
        100,
        1
      ],
      "content": "int\n_getopt_long_only_r (int argc, char *const *argv, const char *options,\n\t\t     const struct option *long_options, int *opt_index,\n\t\t     struct _getopt_data *d)\n{\n  return _getopt_internal_r (argc, argv, options, long_options, opt_index,\n\t\t\t     1, d, 0);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "main": {
      "start_point": [
        108,
        0
      ],
      "end_point": [
        192,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  int c;\n  int digit_optind = 0;\n\n  while (1)\n    {\n      int this_option_optind = optind ? optind : 1;\n      int option_index = 0;\n      static struct option long_options[] =\n      {\n\t{\"add\", 1, 0, 0},\n\t{\"append\", 0, 0, 0},\n\t{\"delete\", 1, 0, 0},\n\t{\"verbose\", 0, 0, 0},\n\t{\"create\", 0, 0, 0},\n\t{\"file\", 1, 0, 0},\n\t{0, 0, 0, 0}\n      };\n\n      c = getopt_long (argc, argv, \"abc:d:0123456789\",\n\t\t       long_options, &option_index);\n      if (c == -1)\n\tbreak;\n\n      switch (c)\n\t{\n\tcase 0:\n\t  printf (\"option %s\", long_options[option_index].name);\n\t  if (optarg)\n\t    printf (\" with arg %s\", optarg);\n\t  printf (\"\\n\");\n\t  break;\n\n\tcase '0':\n\tcase '1':\n\tcase '2':\n\tcase '3':\n\tcase '4':\n\tcase '5':\n\tcase '6':\n\tcase '7':\n\tcase '8':\n\tcase '9':\n\t  if (digit_optind != 0 && digit_optind != this_option_optind)\n\t    printf (\"digits occur in two different argv-elements.\\n\");\n\t  digit_optind = this_option_optind;\n\t  printf (\"option %c\\n\", c);\n\t  break;\n\n\tcase 'a':\n\t  printf (\"option a\\n\");\n\t  break;\n\n\tcase 'b':\n\t  printf (\"option b\\n\");\n\t  break;\n\n\tcase 'c':\n\t  printf (\"option c with value `%s'\\n\", optarg);\n\t  break;\n\n\tcase 'd':\n\t  printf (\"option d with value `%s'\\n\", optarg);\n\t  break;\n\n\tcase '?':\n\t  break;\n\n\tdefault:\n\t  printf (\"?? getopt returned character code 0%o ??\\n\", c);\n\t}\n    }\n\n  if (optind < argc)\n    {\n      printf (\"non-option ARGV-elements: \");\n      while (optind < argc)\n\tprintf (\"%s \", argv[optind++]);\n      printf (\"\\n\");\n    }\n\n  exit (0);\n}",
      "lines": 85,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "gawk/gawk-4.2.1/support/getopt_int.h": {},
  "gawk/gawk-4.2.1/support/intprops.h": {},
  "gawk/gawk-4.2.1/support/localeinfo.c": {
    "is_using_utf8": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "static bool\nis_using_utf8 (void)\n{\n  wchar_t wc;\n  mbstate_t mbs = {0};\n  return mbrtowc (&wc, \"\\xc4\\x80\", 2, &mbs) == 2 && wc == 0x100;\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "init_localeinfo": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "void\ninit_localeinfo (struct localeinfo *localeinfo)\n{\n  int i;\n\n  localeinfo->multibyte = MB_CUR_MAX > 1;\n  localeinfo->using_utf8 = is_using_utf8 ();\n\n  for (i = CHAR_MIN; i <= CHAR_MAX; i++)\n    {\n      char c = i;\n      unsigned char uc = i;\n      mbstate_t s = {0};\n      wchar_t wc;\n      size_t len = mbrtowc (&wc, &c, 1, &s);\n      localeinfo->sbclen[uc] = len <= 1 ? 1 : - (int) - len;\n      localeinfo->sbctowc[uc] = len <= 1 ? wc : WEOF;\n    }\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "case_folded_counterparts": {
      "start_point": [
        98,
        0
      ],
      "end_point": [
        116,
        1
      ],
      "content": "int\ncase_folded_counterparts (wint_t c, wchar_t folded[CASE_FOLDED_BUFSIZE])\n{\n  int i;\n  int n = 0;\n  wint_t uc = towupper (c);\n  wint_t lc = towlower (uc);\n  if (uc != c)\n    folded[n++] = uc;\n  if (lc != uc && lc != c && towupper (lc) == uc)\n    folded[n++] = lc;\n  for (i = 0; i < sizeof lonesome_lower / sizeof *lonesome_lower; i++)\n    {\n      wint_t li = lonesome_lower[i];\n      if (li != lc && li != uc && li != c && towupper (li) == uc)\n        folded[n++] = li;\n    }\n  return n;\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "gawk/gawk-4.2.1/support/localeinfo.h": {},
  "gawk/gawk-4.2.1/support/random.c": {
    "srandomdev": {
      "start_point": [
        351,
        0
      ],
      "end_point": [
        383,
        1
      ],
      "content": "void\nsrandomdev()\n{\n\tint fd, done;\n\tsize_t len;\n\n\tif (rand_type == TYPE_0)\n\t\tlen = sizeof state[0];\n\telse\n\t\tlen = rand_deg * sizeof state[0];\n\n\tdone = 0;\n\tfd = open(\"/dev/random\", O_RDONLY, 0);\n\tif (fd >= 0) {\n\t\tif (read(fd, (void *) state, len) == (ssize_t) len)\n\t\t\tdone = 1;\n\t\tclose(fd);\n\t}\n\n\tif (!done) {\n\t\tstruct timeval tv;\n\t\tunsigned long junk;\n\n\t\tgettimeofday(&tv, NULL);\n\t\tsrandom((getpid() << 16) ^ tv.tv_sec ^ tv.tv_usec ^ junk);\n\t\treturn;\n\t}\n\n\tif (rand_type != TYPE_0) {\n\t\tfptr = &state[rand_sep];\n\t\trptr = &state[0];\n\t}\n}",
      "lines": 33,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "random_old": {
      "start_point": [
        530,
        0
      ],
      "end_point": [
        557,
        1
      ],
      "content": "static long\nrandom_old()\n{\n\tuint32_t i;\n\tuint32_t *f, *r;\n\n\tif (rand_type == TYPE_0) {\n\t\ti = state[0];\n\t\tstate[0] = i = (good_rand(i)) & 0x7fffffff;\n\t} else {\n\t\t/*\n\t\t * Use local variables rather than static variables for speed.\n\t\t */\n\t\tf = fptr; r = rptr;\n\t\t*f += *r;\n\t\ti = (*f >> 1) & 0x7fffffff;\t/* chucking least random bit */\n\t\tif (++f >= end_ptr) {\n\t\t\tf = state;\n\t\t\t++r;\n\t\t}\n\t\telse if (++r >= end_ptr) {\n\t\t\tr = state;\n\t\t}\n\n\t\tfptr = f; rptr = r;\n\t}\n\treturn((long)i);\n}",
      "lines": 28,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "long",
        "long"
      ]
    },
    "random": {
      "start_point": [
        559,
        0
      ],
      "end_point": [
        641,
        1
      ],
      "content": "long\nrandom()\n{\n\t/*\n\t * This function is a wrapper to the original random(), now renamed\n\t * random_old(), to interpose a shuffle buffer to dramatically extend\n\t * the generator period at nearly zero additional execution cost,\n\t * and an additional storage cost set by the size of the\n\t * shuffle buffer (default: 512 longs, or 2K or 4K bytes).\n\t * The algorithm was first described in\n\t *\n\t *     Carter Bays and S. D. Durham\n\t *     Improving a Poor Random Number Generator\n\t *     ACM Transactions on Mathematical Software (TOMS) 2(1) 59--64 (March 1976)\n\t *     http://dx.doi.org/10.1145/355666.355670\n\t * \n\t * and later revisited in\n\t * \n\t *     Carter Bays\n\t *     C364. Improving a random number generator: a comparison between two shuffling methods\n\t *     Journal of Statistical Computation and Simulation 36(1) 57--59 (May 1990)\n\t *     http://dx.doi.org/10.1080/00949659008811264\n\t *\n\t * The second paper is critically important because it\n\t * emphasizes how an apparently trivial change to the final\n\t * element selection can destroy the period-lengthening\n\t * feature of the original shuffle algorithm.\n\t * \n\t * Here is a table of the increase in period size for a\n\t * shuffle generator using 32-bit and 64-bit unsigned integer\n\t * linear congruential generators, which are known to have\n\t * significant correlations, and are thus inadvisable for\n\t * serious work with random numbers:\n\t *\n\t * hocd128> for (n = 32; n < 4096; n *= 2) \\\n\t *              printf(\"%7d\\t%12.3.4e\\t%12.3.4e\\n\",\n\t *              n, \\\n\t *              sqrt(PI * gamma(n + 1)/(2**32 - 1)) / (2**32 - 1), \\\\\n\t *              sqrt(PI * gamma(n + 1)/(2**64 - 1)) / (2**64 - 1))\n\t * \n\t *      32    3.230e+03       1.148e-11\n\t *      64    2.243e+30       7.969e+15\n\t *     128    3.910e+93       1.389e+79\n\t *     256   1.844e+239      6.552e+224\n\t *     512   1.174e+569      4.172e+554\n\t *    1024  4.635e+1305     1.647e+1291\n\t *    2048  8.144e+2932     2.893e+2918\n\t *\n\t * A generator giving one result per nanosecond would produce\n\t * about 3.16e16 random numbers per year, so even for\n\t * massively parallel operations with, say, one million CPU\n\t * cores, it could not produce more than 10**23 values per\n\t * year.  The main benefit of an enormous period is that it\n\t * makes long-range correlations vanishingly unlikely, even\n\t * when starting seeds are similar (e.g., seeds of 0, 1, 2,\n\t * ...), and therefore makes possible families of generators\n\t * (needed in parallel computations) where the probability of\n\t * sequence overlap between family members is essentially\n\t * zero.\n\t */\n\n\tint k;\n\tlong r;\n\tstatic long s = 0xcafefeedL;\n\n\tif (shuffle_init) {\t/* first time, or seed changed by srand() */\n\t\tfor (k = 0; k < SHUFFLE_MAX; k++)\n\t\t\tshuffle_buffer[k] = random_old();\n\n\t\ts = random_old();\n\t\tshuffle_init = 0;\n\t}\n\n\tr = random_old();\n\tk = s & SHUFFLE_MASK;\t\t/* random index into shuffle_buffer[] */\n\n\tassert(0L <= k && k < SHUFFLE_MAX);\n\n\ts = shuffle_buffer[k];\n\tshuffle_buffer[k] = r;\n\n\treturn (s);\n}",
      "lines": 83,
      "depth": 10,
      "decorators": [
        "long",
        "long"
      ]
    }
  },
  "gawk/gawk-4.2.1/support/random.h": {},
  "gawk/gawk-4.2.1/support/regcomp.c": {
    "btowc": {
      "start_point": [
        218,
        0
      ],
      "end_point": [
        231,
        1
      ],
      "content": "wchar_t\nbtowc (int c)\n{\n   wchar_t wtmp[2];\n   char tmp[2];\n   mbstate_t mbs;\n\n   memset(& mbs, 0, sizeof(mbs));\n   tmp[0] = c;\n   tmp[1] = 0;\n\n   mbrtowc (wtmp, tmp, 1, & mbs);\n   return wtmp[0];\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "wchar_t"
      ]
    },
    "re_compile_pattern": {
      "start_point": [
        241,
        0
      ],
      "end_point": [
        260,
        1
      ],
      "content": "const char *\nre_compile_pattern (const char *pattern, size_t length,\n\t\t    struct re_pattern_buffer *bufp)\n{\n  reg_errcode_t ret;\n\n  /* And GNU code determines whether or not to get register information\n     by passing null for the REGS argument to re_match, etc., not by\n     setting no_sub, unless RE_NO_SUB is set.  */\n  bufp->no_sub = !!(re_syntax_options & RE_NO_SUB);\n\n  /* Match anchors at newline.  */\n  bufp->newline_anchor = 1;\n\n  ret = re_compile_internal (bufp, pattern, length, re_syntax_options);\n\n  if (!ret)\n    return NULL;\n  return gettext (__re_error_msgid + __re_error_msgid_idx[(int) ret]);\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nre_compile_pattern (const char *pattern, size_t length,\n\t\t    struct re_pattern_buffer *bufp)",
        "*"
      ]
    },
    "re_set_syntax": {
      "start_point": [
        280,
        0
      ],
      "end_point": [
        287,
        1
      ],
      "content": "reg_syntax_t\nre_set_syntax (reg_syntax_t syntax)\n{\n  reg_syntax_t ret = re_syntax_options;\n\n  re_syntax_options = syntax;\n  return ret;\n}",
      "lines": 8,
      "depth": 5,
      "decorators": [
        "reg_syntax_t"
      ]
    },
    "re_compile_fastmap": {
      "start_point": [
        292,
        0
      ],
      "end_point": [
        308,
        1
      ],
      "content": "int\nre_compile_fastmap (struct re_pattern_buffer *bufp)\n{\n  re_dfa_t *dfa = (re_dfa_t *) bufp->buffer;\n  char *fastmap = bufp->fastmap;\n\n  memset (fastmap, '\\0', sizeof (char) * SBC_MAX);\n  re_compile_fastmap_iter (bufp, dfa->init_state, fastmap);\n  if (dfa->init_state != dfa->init_state_word)\n    re_compile_fastmap_iter (bufp, dfa->init_state_word, fastmap);\n  if (dfa->init_state != dfa->init_state_nl)\n    re_compile_fastmap_iter (bufp, dfa->init_state_nl, fastmap);\n  if (dfa->init_state != dfa->init_state_begbuf)\n    re_compile_fastmap_iter (bufp, dfa->init_state_begbuf, fastmap);\n  bufp->fastmap_accurate = 1;\n  return 0;\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "re_set_fastmap": {
      "start_point": [
        313,
        0
      ],
      "end_point": [
        320,
        1
      ],
      "content": "static inline void\n__attribute__ ((always_inline))\nre_set_fastmap (char *fastmap, bool icase, int ch)\n{\n  fastmap[ch] = 1;\n  if (icase)\n    fastmap[tolower (ch)] = 1;\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void",
        "__attribute__ ((always_inline))",
        "__attribute__",
        "(",
        "(always_inline)",
        "(",
        "always_inline",
        ")",
        ")"
      ]
    },
    "re_compile_fastmap_iter": {
      "start_point": [
        325,
        0
      ],
      "end_point": [
        453,
        1
      ],
      "content": "static void\nre_compile_fastmap_iter (regex_t *bufp, const re_dfastate_t *init_state,\n\t\t\t char *fastmap)\n{\n  re_dfa_t *dfa = (re_dfa_t *) bufp->buffer;\n  int node_cnt;\n  int icase = (dfa->mb_cur_max == 1 && (bufp->syntax & RE_ICASE));\n  for (node_cnt = 0; node_cnt < init_state->nodes.nelem; ++node_cnt)\n    {\n      int node = init_state->nodes.elems[node_cnt];\n      re_token_type_t type = dfa->nodes[node].type;\n\n      if (type == CHARACTER)\n\t{\n\t  re_set_fastmap (fastmap, icase, dfa->nodes[node].opr.c);\n#ifdef RE_ENABLE_I18N\n\t  if ((bufp->syntax & RE_ICASE) && dfa->mb_cur_max > 1)\n\t    {\n\t      unsigned char buf[MB_LEN_MAX];\n\t      unsigned char *p;\n\t      wchar_t wc;\n\t      mbstate_t state;\n\n\t      p = buf;\n\t      *p++ = dfa->nodes[node].opr.c;\n\t      while (++node < dfa->nodes_len\n\t\t     &&\tdfa->nodes[node].type == CHARACTER\n\t\t     && dfa->nodes[node].mb_partial)\n\t\t*p++ = dfa->nodes[node].opr.c;\n\t      memset (&state, '\\0', sizeof (state));\n\t      if (__mbrtowc (&wc, (const char *) buf, p - buf,\n\t\t\t     &state) == p - buf\n\t\t  && (__wcrtomb ((char *) buf, towlower (wc), &state)\n\t\t      != (size_t) -1))\n\t\tre_set_fastmap (fastmap, 0, buf[0]);\n\t    }\n#endif\n\t}\n      else if (type == SIMPLE_BRACKET)\n\t{\n\t  int i, ch;\n\t  for (i = 0, ch = 0; i < BITSET_WORDS; ++i)\n\t    {\n\t      int j;\n\t      bitset_word_t w = dfa->nodes[node].opr.sbcset[i];\n\t      for (j = 0; j < BITSET_WORD_BITS; ++j, ++ch)\n\t\tif (w & ((bitset_word_t) 1 << j))\n\t\t  re_set_fastmap (fastmap, icase, ch);\n\t    }\n\t}\n#ifdef RE_ENABLE_I18N\n      else if (type == COMPLEX_BRACKET)\n\t{\n\t  re_charset_t *cset = dfa->nodes[node].opr.mbcset;\n\t  int i;\n\n# ifdef _LIBC\n\t  /* See if we have to try all bytes which start multiple collation\n\t     elements.\n\t     e.g. In da_DK, we want to catch 'a' since \"aa\" is a valid\n\t\t  collation element, and don't catch 'b' since 'b' is\n\t\t  the only collation element which starts from 'b' (and\n\t\t  it is caught by SIMPLE_BRACKET).  */\n\t      if (_NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_NRULES) != 0\n\t\t  && (cset->ncoll_syms || cset->nranges))\n\t\t{\n\t\t  const int32_t *table = (const int32_t *)\n\t\t    _NL_CURRENT (LC_COLLATE, _NL_COLLATE_TABLEMB);\n\t\t  for (i = 0; i < SBC_MAX; ++i)\n\t\t    if (table[i] < 0)\n\t\t      re_set_fastmap (fastmap, icase, i);\n\t\t}\n# endif /* _LIBC */\n\n\t  /* See if we have to start the match at all multibyte characters,\n\t     i.e. where we would not find an invalid sequence.  This only\n\t     applies to multibyte character sets; for single byte character\n\t     sets, the SIMPLE_BRACKET again suffices.  */\n\t  if (dfa->mb_cur_max > 1\n\t      && (cset->nchar_classes || cset->non_match || cset->nranges\n# ifdef _LIBC\n\t\t  || cset->nequiv_classes\n# endif /* _LIBC */\n\t\t ))\n\t    {\n\t      unsigned char c = 0;\n\t      do\n\t\t{\n\t\t  mbstate_t mbs;\n\t\t  memset (&mbs, 0, sizeof (mbs));\n\t\t  if (__mbrtowc (NULL, (char *) &c, 1, &mbs) == (size_t) -2)\n\t\t    re_set_fastmap (fastmap, false, (int) c);\n\t\t}\n\t      while (++c != 0);\n\t    }\n\n\t  else\n\t    {\n\t      /* ... Else catch all bytes which can start the mbchars.  */\n\t      for (i = 0; i < cset->nmbchars; ++i)\n\t\t{\n\t\t  char buf[256];\n\t\t  mbstate_t state;\n\t\t  memset (&state, '\\0', sizeof (state));\n\t\t  if (__wcrtomb (buf, cset->mbchars[i], &state) != (size_t) -1)\n\t\t    re_set_fastmap (fastmap, icase, *(unsigned char *) buf);\n\t\t  if ((bufp->syntax & RE_ICASE) && dfa->mb_cur_max > 1)\n\t\t    {\n\t\t      if (__wcrtomb (buf, towlower (cset->mbchars[i]), &state)\n\t\t\t  != (size_t) -1)\n\t\t\tre_set_fastmap (fastmap, false, *(unsigned char *) buf);\n\t\t    }\n\t\t}\n\t    }\n\t}\n#endif /* RE_ENABLE_I18N */\n      else if (type == OP_PERIOD\n#ifdef RE_ENABLE_I18N\n\t       || type == OP_UTF8_PERIOD\n#endif /* RE_ENABLE_I18N */\n\t       || type == END_OF_RE)\n\t{\n\t  memset (fastmap, '\\1', sizeof (char) * SBC_MAX);\n\t  if (type == END_OF_RE)\n\t    bufp->can_be_null = 1;\n\t  return;\n\t}\n    }\n}",
      "lines": 129,
      "depth": 23,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "regcomp": {
      "start_point": [
        491,
        0
      ],
      "end_point": [
        542,
        1
      ],
      "content": "int\nregcomp (regex_t *__restrict preg, const char *__restrict pattern, int cflags)\n{\n  reg_errcode_t ret;\n  reg_syntax_t syntax = ((cflags & REG_EXTENDED) ? RE_SYNTAX_POSIX_EXTENDED\n\t\t\t : RE_SYNTAX_POSIX_BASIC);\n\n  preg->buffer = NULL;\n  preg->allocated = 0;\n  preg->used = 0;\n\n  /* Try to allocate space for the fastmap.  */\n  preg->fastmap = re_malloc (char, SBC_MAX);\n  if (BE (preg->fastmap == NULL, 0))\n    return REG_ESPACE;\n\n  syntax |= (cflags & REG_ICASE) ? RE_ICASE : 0;\n\n  /* If REG_NEWLINE is set, newlines are treated differently.  */\n  if (cflags & REG_NEWLINE)\n    { /* REG_NEWLINE implies neither . nor [^...] match newline.  */\n      syntax &= ~RE_DOT_NEWLINE;\n      syntax |= RE_HAT_LISTS_NOT_NEWLINE;\n      /* It also changes the matching behavior.  */\n      preg->newline_anchor = 1;\n    }\n  else\n    preg->newline_anchor = 0;\n  preg->no_sub = !!(cflags & REG_NOSUB);\n  preg->translate = NULL;\n\n  ret = re_compile_internal (preg, pattern, strlen (pattern), syntax);\n\n  /* POSIX doesn't distinguish between an unmatched open-group and an\n     unmatched close-group: both are REG_EPAREN.  */\n  if (ret == REG_ERPAREN)\n    ret = REG_EPAREN;\n\n  /* We have already checked preg->fastmap != NULL.  */\n  if (BE (ret == REG_NOERROR, 1))\n    /* Compute the fastmap now, since regexec cannot modify the pattern\n       buffer.  This function never fails in this implementation.  */\n    (void) re_compile_fastmap (preg);\n  else\n    {\n      /* Some error occurred while compiling the expression.  */\n      re_free (preg->fastmap);\n      preg->fastmap = NULL;\n    }\n\n  return (int) ret;\n}",
      "lines": 52,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "regerror": {
      "start_point": [
        551,
        0
      ],
      "end_point": [
        587,
        1
      ],
      "content": "size_t\nregerror (int errcode, const regex_t *__restrict preg, char *__restrict errbuf,\n\t  size_t errbuf_size)\n{\n  const char *msg;\n  size_t msg_size;\n\n  if (BE (errcode < 0\n\t  || errcode >= (int) (sizeof (__re_error_msgid_idx)\n\t\t\t       / sizeof (__re_error_msgid_idx[0])), 0))\n    /* Only error codes returned by the rest of the code should be passed\n       to this routine.  If we are given anything else, or if other regex\n       code generates an invalid error code, then the program has a bug.\n       Dump core so we can fix it.  */\n    abort ();\n\n  msg = gettext (__re_error_msgid + __re_error_msgid_idx[errcode]);\n\n  msg_size = strlen (msg) + 1; /* Includes the null.  */\n\n  if (BE (errbuf_size != 0, 1))\n    {\n      if (BE (msg_size > errbuf_size, 0))\n\t{\n#if defined HAVE_MEMPCPY || defined _LIBC\n\t  *((char *) __mempcpy (errbuf, msg, errbuf_size - 1)) = '\\0';\n#else\n\t  memcpy (errbuf, msg, errbuf_size - 1);\n\t  errbuf[errbuf_size - 1] = 0;\n#endif\n\t}\n      else\n\tmemcpy (errbuf, msg, msg_size);\n    }\n\n  return msg_size;\n}",
      "lines": 37,
      "depth": 16,
      "decorators": [
        "size_t"
      ]
    },
    "free_dfa_content": {
      "start_point": [
        609,
        0
      ],
      "end_point": [
        654,
        1
      ],
      "content": "static void\nfree_dfa_content (re_dfa_t *dfa)\n{\n  int i, j;\n\n  if (dfa->nodes)\n    for (i = 0; i < dfa->nodes_len; ++i)\n      free_token (dfa->nodes + i);\n  re_free (dfa->nexts);\n  for (i = 0; i < dfa->nodes_len; ++i)\n    {\n      if (dfa->eclosures != NULL)\n\tre_node_set_free (dfa->eclosures + i);\n      if (dfa->inveclosures != NULL)\n\tre_node_set_free (dfa->inveclosures + i);\n      if (dfa->edests != NULL)\n\tre_node_set_free (dfa->edests + i);\n    }\n  re_free (dfa->edests);\n  re_free (dfa->eclosures);\n  re_free (dfa->inveclosures);\n  re_free (dfa->nodes);\n\n  if (dfa->state_table)\n    for (i = 0; i <= dfa->state_hash_mask; ++i)\n      {\n\tstruct re_state_table_entry *entry = dfa->state_table + i;\n\tfor (j = 0; j < entry->num; ++j)\n\t  {\n\t    re_dfastate_t *state = entry->array[j];\n\t    free_state (state);\n\t  }\n\tre_free (entry->array);\n      }\n  re_free (dfa->state_table);\n#ifdef RE_ENABLE_I18N\n  if (dfa->sb_char != utf8_sb_map)\n    re_free (dfa->sb_char);\n#endif\n  re_free (dfa->subexp_map);\n#ifdef DEBUG\n  re_free (dfa->re_str);\n#endif\n\n  re_free (dfa);\n}",
      "lines": 46,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "regfree": {
      "start_point": [
        659,
        0
      ],
      "end_point": [
        673,
        1
      ],
      "content": "void\nregfree (regex_t *preg)\n{\n  re_dfa_t *dfa = (re_dfa_t *) preg->buffer;\n  if (BE (dfa != NULL, 1))\n    free_dfa_content (dfa);\n  preg->buffer = NULL;\n  preg->allocated = 0;\n\n  re_free (preg->fastmap);\n  preg->fastmap = NULL;\n\n  re_free (preg->translate);\n  preg->translate = NULL;\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "re_comp": {
      "start_point": [
        692,
        0
      ],
      "end_point": [
        736,
        1
      ],
      "content": "weak_function\n# endif\nre_comp (const char *s)\n{\n  reg_errcode_t ret;\n  char *fastmap;\n\n  if (!s)\n    {\n      if (!re_comp_buf.buffer)\n\treturn gettext (\"No previous regular expression\");\n      return 0;\n    }\n\n  if (re_comp_buf.buffer)\n    {\n      fastmap = re_comp_buf.fastmap;\n      re_comp_buf.fastmap = NULL;\n      __regfree (&re_comp_buf);\n      memset (&re_comp_buf, '\\0', sizeof (re_comp_buf));\n      re_comp_buf.fastmap = fastmap;\n    }\n\n  if (re_comp_buf.fastmap == NULL)\n    {\n      re_comp_buf.fastmap = (char *) re_malloc (SBC_MAX);\n      if (re_comp_buf.fastmap == NULL)\n\treturn (char *) gettext (__re_error_msgid\n\t\t\t\t + __re_error_msgid_idx[(int) REG_ESPACE]);\n    }\n\n  /* Since 're_exec' always passes NULL for the 'regs' argument, we\n     don't need to initialize the pattern buffer fields which affect it.  */\n\n  /* Match anchors at newlines.  */\n  re_comp_buf.newline_anchor = 1;\n\n  ret = re_compile_internal (&re_comp_buf, s, strlen (s), re_syntax_options);\n\n  if (!ret)\n    return NULL;\n\n  /* Yes, we're discarding `const' here if !HAVE_LIBINTL.  */\n  return (char *) gettext (__re_error_msgid + __re_error_msgid_idx[(int) ret]);\n}",
      "lines": 45,
      "depth": 14,
      "decorators": [
        "weak_function",
        "# endif",
        "# endif"
      ]
    },
    "free_mem": {
      "start_point": [
        739,
        0
      ],
      "end_point": [
        742,
        1
      ],
      "content": "libc_freeres_fn (free_mem)\n{\n  __regfree (&re_comp_buf);\n}",
      "lines": 4,
      "depth": 7,
      "decorators": null
    },
    "re_compile_internal": {
      "start_point": [
        751,
        0
      ],
      "end_point": [
        845,
        1
      ],
      "content": "static reg_errcode_t\nre_compile_internal (regex_t *preg, const char * pattern, size_t length,\n\t\t     reg_syntax_t syntax)\n{\n  reg_errcode_t err = REG_NOERROR;\n  re_dfa_t *dfa;\n  re_string_t regexp;\n\n  /* Initialize the pattern buffer.  */\n  preg->fastmap_accurate = 0;\n  preg->syntax = syntax;\n  preg->not_bol = preg->not_eol = 0;\n  preg->used = 0;\n  preg->re_nsub = 0;\n  preg->can_be_null = 0;\n  preg->regs_allocated = REGS_UNALLOCATED;\n\n  /* Initialize the dfa.  */\n  dfa = (re_dfa_t *) preg->buffer;\n  if (BE (preg->allocated < sizeof (re_dfa_t), 0))\n    {\n      /* If zero allocated, but buffer is non-null, try to realloc\n\t enough space.  This loses if buffer's address is bogus, but\n\t that is the user's responsibility.  If ->buffer is NULL this\n\t is a simple allocation.  */\n      dfa = re_realloc (preg->buffer, re_dfa_t, 1);\n      if (dfa == NULL)\n\treturn REG_ESPACE;\n      preg->allocated = sizeof (re_dfa_t);\n      preg->buffer = (unsigned char *) dfa;\n    }\n  preg->used = sizeof (re_dfa_t);\n\n  err = init_dfa (dfa, length);\n  if (BE (err != REG_NOERROR, 0))\n    {\n      free_dfa_content (dfa);\n      preg->buffer = NULL;\n      preg->allocated = 0;\n      return err;\n    }\n#ifdef DEBUG\n  /* Note: length+1 will not overflow since it is checked in init_dfa.  */\n  dfa->re_str = re_malloc (char, length + 1);\n  strncpy (dfa->re_str, pattern, length + 1);\n#endif\n\n  __libc_lock_init (dfa->lock);\n\n  err = re_string_construct (&regexp, pattern, length, preg->translate,\n\t\t\t     (syntax & RE_ICASE) != 0, dfa);\n  if (BE (err != REG_NOERROR, 0))\n    {\n    re_compile_internal_free_return:\n      free_workarea_compile (preg);\n      re_string_destruct (&regexp);\n      free_dfa_content (dfa);\n      preg->buffer = NULL;\n      preg->allocated = 0;\n      return err;\n    }\n\n  /* Parse the regular expression, and build a structure tree.  */\n  preg->re_nsub = 0;\n  dfa->str_tree = parse (&regexp, preg, syntax, &err);\n  if (BE (dfa->str_tree == NULL, 0))\n    goto re_compile_internal_free_return;\n\n  /* Analyze the tree and create the nfa.  */\n  err = analyze (preg);\n  if (BE (err != REG_NOERROR, 0))\n    goto re_compile_internal_free_return;\n\n#ifdef RE_ENABLE_I18N\n  /* If possible, do searching in single byte encoding to speed things up.  */\n  if (dfa->is_utf8 && !(syntax & RE_ICASE) && preg->translate == NULL)\n    optimize_utf8 (dfa);\n#endif\n\n  /* Then create the initial state of the dfa.  */\n  err = create_initial_state (dfa);\n\n  /* Release work areas.  */\n  free_workarea_compile (preg);\n  re_string_destruct (&regexp);\n\n  if (BE (err != REG_NOERROR, 0))\n    {\n      free_dfa_content (dfa);\n      preg->buffer = NULL;\n      preg->allocated = 0;\n    }\n\n  return err;\n}",
      "lines": 95,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "init_dfa": {
      "start_point": [
        850,
        0
      ],
      "end_point": [
        955,
        1
      ],
      "content": "static reg_errcode_t\ninit_dfa (re_dfa_t *dfa, size_t pat_len)\n{\n  unsigned int table_size;\n#ifndef _LIBC\n  char *codeset_name;\n#endif\n\n  memset (dfa, '\\0', sizeof (re_dfa_t));\n\n  /* Force allocation of str_tree_storage the first time.  */\n  dfa->str_tree_storage_idx = BIN_TREE_STORAGE_SIZE;\n\n  /* Avoid overflows.  */\n  if (pat_len == SIZE_MAX)\n    return REG_ESPACE;\n\n  dfa->nodes_alloc = pat_len + 1;\n  dfa->nodes = re_malloc (re_token_t, dfa->nodes_alloc);\n\n  /*  table_size = 2 ^ ceil(log pat_len) */\n  for (table_size = 1; ; table_size <<= 1)\n    if (table_size > pat_len)\n      break;\n\n  dfa->state_table = calloc (sizeof (struct re_state_table_entry), table_size);\n  dfa->state_hash_mask = table_size - 1;\n\n  dfa->mb_cur_max = MB_CUR_MAX;\n#ifdef _LIBC\n  if (dfa->mb_cur_max == 6\n      && strcmp (_NL_CURRENT (LC_CTYPE, _NL_CTYPE_CODESET_NAME), \"UTF-8\") == 0)\n    dfa->is_utf8 = 1;\n  dfa->map_notascii = (_NL_CURRENT_WORD (LC_CTYPE, _NL_CTYPE_MAP_TO_NONASCII)\n\t\t       != 0);\n#else\n# ifdef HAVE_LANGINFO_CODESET\n  codeset_name = nl_langinfo (CODESET);\n# else\n  codeset_name = getenv (\"LC_ALL\");\n  if (codeset_name == NULL || codeset_name[0] == '\\0')\n    codeset_name = getenv (\"LC_CTYPE\");\n  if (codeset_name == NULL || codeset_name[0] == '\\0')\n    codeset_name = getenv (\"LANG\");\n  if (codeset_name == NULL)\n    codeset_name = \"\";\n  else if (strchr (codeset_name, '.') !=  NULL)\n    codeset_name = strchr (codeset_name, '.') + 1;\n# endif\n\n  if (strcasecmp (codeset_name, \"UTF-8\") == 0\n      || strcasecmp (codeset_name, \"UTF8\") == 0)\n    dfa->is_utf8 = 1;\n\n  /* We check exhaustively in the loop below if this charset is a\n     superset of ASCII.  */\n  dfa->map_notascii = 0;\n#endif\n\n#ifdef RE_ENABLE_I18N\n  if (dfa->mb_cur_max > 1)\n    {\n      if (dfa->is_utf8)\n        {\n#if !defined(__GNUC__) || __GNUC__ < 3\n\t  static short utf8_sb_map_inited = 0;\n\n\t  if (! utf8_sb_map_inited)\n\t    {\n\t\tint i;\n\n\t  \tutf8_sb_map_inited = 0;\n\t\tfor (i = 0; i <= 0x80 / BITSET_WORD_BITS - 1; i++)\n\t\t  utf8_sb_map[i] = BITSET_WORD_MAX;\n\t    }\n#endif\n\t  dfa->sb_char = (re_bitset_ptr_t) utf8_sb_map;\n\t}\n      else\n\t{\n\t  int i, j, ch;\n\n\t  dfa->sb_char = (re_bitset_ptr_t) calloc (sizeof (bitset_t), 1);\n\t  if (BE (dfa->sb_char == NULL, 0))\n\t    return REG_ESPACE;\n\n\t  /* Set the bits corresponding to single byte chars.  */\n\t  for (i = 0, ch = 0; i < BITSET_WORDS; ++i)\n\t    for (j = 0; j < BITSET_WORD_BITS; ++j, ++ch)\n\t      {\n\t\twint_t wch = __btowc (ch);\n\t\tif (wch != WEOF)\n\t\t  dfa->sb_char[i] |= (bitset_word_t) 1 << j;\n# ifndef _LIBC\n\t\tif (isascii (ch) && wch != ch)\n\t\t  dfa->map_notascii = 1;\n# endif\n\t      }\n\t}\n    }\n#endif\n\n  if (BE (dfa->nodes == NULL || dfa->state_table == NULL, 0))\n    return REG_ESPACE;\n  return REG_NOERROR;\n}",
      "lines": 106,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "init_word_char": {
      "start_point": [
        961,
        0
      ],
      "end_point": [
        1008,
        1
      ],
      "content": "static void\ninit_word_char (re_dfa_t *dfa)\n{\n  dfa->word_ops_used = 1;\n  int i = 0;\n  int ch = 0;\n#ifndef GAWK\n  if (BE (dfa->map_notascii == 0, 1))\n    {\n      /* Avoid uint32_t and uint64_t as some non-GCC platforms lack\n\t them, an issue when this code is used in Gnulib.  */\n      bitset_word_t bits0 = 0x00000000;\n      bitset_word_t bits1 = 0x03ff0000;\n      bitset_word_t bits2 = 0x87fffffe;\n      bitset_word_t bits3 = 0x07fffffe;\n      if (BITSET_WORD_BITS == 64)\n\t{\n\t  /* Pacify gcc -Woverflow on 32-bit platformns.  */\n\t  dfa->word_char[0] = bits1 << 31 << 1 | bits0;\n\t  dfa->word_char[1] = bits3 << 31 << 1 | bits2;\n\t  i = 2;\n\t}\n      else if (BITSET_WORD_BITS == 32)\n\t{\n\t  dfa->word_char[0] = bits0;\n\t  dfa->word_char[1] = bits1;\n\t  dfa->word_char[2] = bits2;\n\t  dfa->word_char[3] = bits3;\n\t  i = 4;\n\t}\n      else\n        goto general_case;\n      ch = 128;\n\n      if (BE (dfa->is_utf8, 1))\n\t{\n\t  memset (&dfa->word_char[i], '\\0', (SBC_MAX - ch) / 8);\n\t  return;\n\t}\n    }\n\n general_case:\n#endif\n  for (; i < BITSET_WORDS; ++i)\n    for (int j = 0; j < BITSET_WORD_BITS; ++j, ++ch)\n      if (isalnum (ch) || ch == '_')\n\tdfa->word_char[i] |= (bitset_word_t) 1 << j;\n}",
      "lines": 48,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "free_workarea_compile": {
      "start_point": [
        1012,
        0
      ],
      "end_point": [
        1027,
        1
      ],
      "content": "static void\nfree_workarea_compile (regex_t *preg)\n{\n  re_dfa_t *dfa = (re_dfa_t *) preg->buffer;\n  bin_tree_storage_t *storage, *next;\n  for (storage = dfa->str_tree_storage; storage; storage = next)\n    {\n      next = storage->next;\n      re_free (storage);\n    }\n  dfa->str_tree_storage = NULL;\n  dfa->str_tree_storage_idx = BIN_TREE_STORAGE_SIZE;\n  dfa->str_tree = NULL;\n  re_free (dfa->org_indices);\n  dfa->org_indices = NULL;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "create_initial_state": {
      "start_point": [
        1031,
        0
      ],
      "end_point": [
        1110,
        1
      ],
      "content": "static reg_errcode_t\ncreate_initial_state (re_dfa_t *dfa)\n{\n  int first, i;\n  reg_errcode_t err;\n  re_node_set init_nodes;\n\n  /* Initial states have the epsilon closure of the node which is\n     the first node of the regular expression.  */\n  first = dfa->str_tree->first->node_idx;\n  dfa->init_node = first;\n  err = re_node_set_init_copy (&init_nodes, dfa->eclosures + first);\n  if (BE (err != REG_NOERROR, 0))\n    return err;\n\n  /* The back-references which are in initial states can epsilon transit,\n     since in this case all of the subexpressions can be null.\n     Then we add epsilon closures of the nodes which are the next nodes of\n     the back-references.  */\n  if (dfa->nbackref > 0)\n    for (i = 0; i < init_nodes.nelem; ++i)\n      {\n\tint node_idx = init_nodes.elems[i];\n\tre_token_type_t type = dfa->nodes[node_idx].type;\n\n\tint clexp_idx;\n\tif (type != OP_BACK_REF)\n\t  continue;\n\tfor (clexp_idx = 0; clexp_idx < init_nodes.nelem; ++clexp_idx)\n\t  {\n\t    re_token_t *clexp_node;\n\t    clexp_node = dfa->nodes + init_nodes.elems[clexp_idx];\n\t    if (clexp_node->type == OP_CLOSE_SUBEXP\n\t\t&& clexp_node->opr.idx == dfa->nodes[node_idx].opr.idx)\n\t      break;\n\t  }\n\tif (clexp_idx == init_nodes.nelem)\n\t  continue;\n\n\tif (type == OP_BACK_REF)\n\t  {\n\t    int dest_idx = dfa->edests[node_idx].elems[0];\n\t    if (!re_node_set_contains (&init_nodes, dest_idx))\n\t      {\n\t\treg_errcode_t err = re_node_set_merge (&init_nodes,\n\t\t\t\t\t\t       dfa->eclosures\n\t\t\t\t\t\t       + dest_idx);\n\t\tif (err != REG_NOERROR)\n\t\t  return err;\n\t\ti = 0;\n\t      }\n\t  }\n      }\n\n  /* It must be the first time to invoke acquire_state.  */\n  dfa->init_state = re_acquire_state_context (&err, dfa, &init_nodes, 0);\n  /* We don't check ERR here, since the initial state must not be NULL.  */\n  if (BE (dfa->init_state == NULL, 0))\n    return err;\n  if (dfa->init_state->has_constraint)\n    {\n      dfa->init_state_word = re_acquire_state_context (&err, dfa, &init_nodes,\n\t\t\t\t\t\t       CONTEXT_WORD);\n      dfa->init_state_nl = re_acquire_state_context (&err, dfa, &init_nodes,\n\t\t\t\t\t\t     CONTEXT_NEWLINE);\n      dfa->init_state_begbuf = re_acquire_state_context (&err, dfa,\n\t\t\t\t\t\t\t &init_nodes,\n\t\t\t\t\t\t\t CONTEXT_NEWLINE\n\t\t\t\t\t\t\t | CONTEXT_BEGBUF);\n      if (BE (dfa->init_state_word == NULL || dfa->init_state_nl == NULL\n\t      || dfa->init_state_begbuf == NULL, 0))\n\treturn err;\n    }\n  else\n    dfa->init_state_word = dfa->init_state_nl\n      = dfa->init_state_begbuf = dfa->init_state;\n\n  re_node_set_free (&init_nodes);\n  return REG_NOERROR;\n}",
      "lines": 80,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "optimize_utf8": {
      "start_point": [
        1117,
        0
      ],
      "end_point": [
        1181,
        1
      ],
      "content": "static void\noptimize_utf8 (re_dfa_t *dfa)\n{\n  int node, i, mb_chars = 0, has_period = 0;\n\n  for (node = 0; node < dfa->nodes_len; ++node)\n    switch (dfa->nodes[node].type)\n      {\n      case CHARACTER:\n\tif (dfa->nodes[node].opr.c >= 0x80)\n\t  mb_chars = 1;\n\tbreak;\n      case ANCHOR:\n\tswitch (dfa->nodes[node].opr.ctx_type)\n\t  {\n\t  case LINE_FIRST:\n\t  case LINE_LAST:\n\t  case BUF_FIRST:\n\t  case BUF_LAST:\n\t    break;\n\t  default:\n\t    /* Word anchors etc. cannot be handled.  It's okay to test\n\t       opr.ctx_type since constraints (for all DFA nodes) are\n\t       created by ORing one or more opr.ctx_type values.  */\n\t    return;\n\t  }\n\tbreak;\n      case OP_PERIOD:\n\thas_period = 1;\n\tbreak;\n      case OP_BACK_REF:\n      case OP_ALT:\n      case END_OF_RE:\n      case OP_DUP_ASTERISK:\n      case OP_OPEN_SUBEXP:\n      case OP_CLOSE_SUBEXP:\n\tbreak;\n      case COMPLEX_BRACKET:\n\treturn;\n      case SIMPLE_BRACKET:\n\t/* Just double check.  The non-ASCII range starts at 0x80.  */\n\tassert (0x80 % BITSET_WORD_BITS == 0);\n\tfor (i = 0x80 / BITSET_WORD_BITS; i < BITSET_WORDS; ++i)\n\t  if (dfa->nodes[node].opr.sbcset[i])\n\t    return;\n\tbreak;\n      default:\n\tabort ();\n      }\n\n  if (mb_chars || has_period)\n    for (node = 0; node < dfa->nodes_len; ++node)\n      {\n\tif (dfa->nodes[node].type == CHARACTER\n\t    && dfa->nodes[node].opr.c >= 0x80)\n\t  dfa->nodes[node].mb_partial = 0;\n\telse if (dfa->nodes[node].type == OP_PERIOD)\n\t  dfa->nodes[node].type = OP_UTF8_PERIOD;\n      }\n\n  /* The search can be in single byte locale.  */\n  dfa->mb_cur_max = 1;\n  dfa->is_utf8 = 0;\n  dfa->has_mb_node = dfa->nbackref > 0 || has_period;\n}",
      "lines": 65,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "analyze": {
      "start_point": [
        1187,
        0
      ],
      "end_point": [
        1250,
        1
      ],
      "content": "static reg_errcode_t\nanalyze (regex_t *preg)\n{\n  re_dfa_t *dfa = (re_dfa_t *) preg->buffer;\n  reg_errcode_t ret;\n\n  /* Allocate arrays.  */\n  dfa->nexts = re_malloc (int, dfa->nodes_alloc);\n  dfa->org_indices = re_malloc (int, dfa->nodes_alloc);\n  dfa->edests = re_malloc (re_node_set, dfa->nodes_alloc);\n  dfa->eclosures = re_malloc (re_node_set, dfa->nodes_alloc);\n  if (BE (dfa->nexts == NULL || dfa->org_indices == NULL || dfa->edests == NULL\n\t  || dfa->eclosures == NULL, 0))\n    return REG_ESPACE;\n\n  /* some malloc()-checkers don't like zero allocations */\n  if (preg->re_nsub > 0)\n    dfa->subexp_map = re_malloc (int, preg->re_nsub);\n  else\n    dfa->subexp_map = NULL;\n\n  if (dfa->subexp_map != NULL)\n    {\n      int i;\n      for (i = 0; i < preg->re_nsub; i++)\n\tdfa->subexp_map[i] = i;\n      preorder (dfa->str_tree, optimize_subexps, dfa);\n      for (i = 0; i < preg->re_nsub; i++)\n\tif (dfa->subexp_map[i] != i)\n\t  break;\n      if (i == preg->re_nsub)\n\t{\n\t  re_free (dfa->subexp_map);\n\t  dfa->subexp_map = NULL;\n\t}\n    }\n\n  ret = postorder (dfa->str_tree, lower_subexps, preg);\n  if (BE (ret != REG_NOERROR, 0))\n    return ret;\n  ret = postorder (dfa->str_tree, calc_first, dfa);\n  if (BE (ret != REG_NOERROR, 0))\n    return ret;\n  preorder (dfa->str_tree, calc_next, dfa);\n  ret = preorder (dfa->str_tree, link_nfa_nodes, dfa);\n  if (BE (ret != REG_NOERROR, 0))\n    return ret;\n  ret = calc_eclosure (dfa);\n  if (BE (ret != REG_NOERROR, 0))\n    return ret;\n\n  /* We only need this during the prune_impossible_nodes pass in regexec.c;\n     skip it if p_i_n will not run, as calc_inveclosure can be quadratic.  */\n  if ((!preg->no_sub && preg->re_nsub > 0 && dfa->has_plural_match)\n      || dfa->nbackref)\n    {\n      dfa->inveclosures = re_malloc (re_node_set, dfa->nodes_len);\n      if (BE (dfa->inveclosures == NULL, 0))\n\treturn REG_ESPACE;\n      ret = calc_inveclosure (dfa);\n    }\n\n  return ret;\n}",
      "lines": 64,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "postorder": {
      "start_point": [
        1255,
        0
      ],
      "end_point": [
        1285,
        1
      ],
      "content": "static reg_errcode_t\npostorder (bin_tree_t *root, reg_errcode_t (fn (void *, bin_tree_t *)),\n\t   void *extra)\n{\n  bin_tree_t *node, *prev;\n\n  for (node = root; ; )\n    {\n      /* Descend down the tree, preferably to the left (or to the right\n\t if that's the only child).  */\n      while (node->left || node->right)\n\tif (node->left)\n\t  node = node->left;\n\telse\n\t  node = node->right;\n\n      do\n\t{\n\t  reg_errcode_t err = fn (extra, node);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return err;\n\t  if (node->parent == NULL)\n\t    return REG_NOERROR;\n\t  prev = node;\n\t  node = node->parent;\n\t}\n      /* Go up while we have a node that is reached from the right.  */\n      while (node->right == prev || node->right == NULL);\n      node = node->right;\n    }\n}",
      "lines": 31,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "preorder": {
      "start_point": [
        1287,
        0
      ],
      "end_point": [
        1315,
        1
      ],
      "content": "static reg_errcode_t\npreorder (bin_tree_t *root, reg_errcode_t (fn (void *, bin_tree_t *)),\n\t  void *extra)\n{\n  bin_tree_t *node;\n\n  for (node = root; ; )\n    {\n      reg_errcode_t err = fn (extra, node);\n      if (BE (err != REG_NOERROR, 0))\n\treturn err;\n\n      /* Go to the left node, or up and to the right.  */\n      if (node->left)\n\tnode = node->left;\n      else\n\t{\n\t  bin_tree_t *prev = NULL;\n\t  while (node->right == prev || node->right == NULL)\n\t    {\n\t      prev = node;\n\t      node = node->parent;\n\t      if (!node)\n\t\treturn REG_NOERROR;\n\t    }\n\t  node = node->right;\n\t}\n    }\n}",
      "lines": 29,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "optimize_subexps": {
      "start_point": [
        1320,
        0
      ],
      "end_point": [
        1347,
        1
      ],
      "content": "static reg_errcode_t\noptimize_subexps (void *extra, bin_tree_t *node)\n{\n  re_dfa_t *dfa = (re_dfa_t *) extra;\n\n  if (node->token.type == OP_BACK_REF && dfa->subexp_map)\n    {\n      int idx = node->token.opr.idx;\n      node->token.opr.idx = dfa->subexp_map[idx];\n      dfa->used_bkref_map |= 1 << node->token.opr.idx;\n    }\n\n  else if (node->token.type == SUBEXP\n\t   && node->left && node->left->token.type == SUBEXP)\n    {\n      int other_idx = node->left->token.opr.idx;\n\n      node->left = node->left->left;\n      if (node->left)\n\tnode->left->parent = node;\n\n      dfa->subexp_map[other_idx] = dfa->subexp_map[node->token.opr.idx];\n      if (other_idx < BITSET_WORD_BITS)\n\t  dfa->used_bkref_map &= ~((bitset_word_t) 1 << other_idx);\n    }\n\n  return REG_NOERROR;\n}",
      "lines": 28,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "lower_subexps": {
      "start_point": [
        1351,
        0
      ],
      "end_point": [
        1371,
        1
      ],
      "content": "static reg_errcode_t\nlower_subexps (void *extra, bin_tree_t *node)\n{\n  regex_t *preg = (regex_t *) extra;\n  reg_errcode_t err = REG_NOERROR;\n\n  if (node->left && node->left->token.type == SUBEXP)\n    {\n      node->left = lower_subexp (&err, preg, node->left);\n      if (node->left)\n\tnode->left->parent = node;\n    }\n  if (node->right && node->right->token.type == SUBEXP)\n    {\n      node->right = lower_subexp (&err, preg, node->right);\n      if (node->right)\n\tnode->right->parent = node;\n    }\n\n  return err;\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "lower_subexp": {
      "start_point": [
        1373,
        0
      ],
      "end_point": [
        1406,
        1
      ],
      "content": "static bin_tree_t *\nlower_subexp (reg_errcode_t *err, regex_t *preg, bin_tree_t *node)\n{\n  re_dfa_t *dfa = (re_dfa_t *) preg->buffer;\n  bin_tree_t *body = node->left;\n  bin_tree_t *op, *cls, *tree1, *tree;\n\n  if (preg->no_sub\n      /* We do not optimize empty subexpressions, because otherwise we may\n\t have bad CONCAT nodes with NULL children.  This is obviously not\n\t very common, so we do not lose much.  An example that triggers\n\t this case is the sed \"script\" /\\(\\)/x.  */\n      && node->left != NULL\n      && (node->token.opr.idx >= BITSET_WORD_BITS\n\t  || !(dfa->used_bkref_map\n\t       & ((bitset_word_t) 1 << node->token.opr.idx))))\n    return node->left;\n\n  /* Convert the SUBEXP node to the concatenation of an\n     OP_OPEN_SUBEXP, the contents, and an OP_CLOSE_SUBEXP.  */\n  op = create_tree (dfa, NULL, NULL, OP_OPEN_SUBEXP);\n  cls = create_tree (dfa, NULL, NULL, OP_CLOSE_SUBEXP);\n  tree1 = body ? create_tree (dfa, body, cls, CONCAT) : cls;\n  tree = create_tree (dfa, op, tree1, CONCAT);\n  if (BE (tree == NULL || tree1 == NULL || op == NULL || cls == NULL, 0))\n    {\n      *err = REG_ESPACE;\n      return NULL;\n    }\n\n  op->token.opr.idx = cls->token.opr.idx = node->token.opr.idx;\n  op->token.opt_subexp = cls->token.opt_subexp = node->token.opt_subexp;\n  return tree;\n}",
      "lines": 34,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\nlower_subexp (reg_errcode_t *err, regex_t *preg, bin_tree_t *node)",
        "*"
      ]
    },
    "calc_first": {
      "start_point": [
        1410,
        0
      ],
      "end_point": [
        1429,
        1
      ],
      "content": "static reg_errcode_t\ncalc_first (void *extra, bin_tree_t *node)\n{\n  re_dfa_t *dfa = (re_dfa_t *) extra;\n  if (node->token.type == CONCAT)\n    {\n      node->first = node->left->first;\n      node->node_idx = node->left->node_idx;\n    }\n  else\n    {\n      node->first = node;\n      node->node_idx = re_dfa_add_node (dfa, node->token);\n      if (BE (node->node_idx == -1, 0))\n\treturn REG_ESPACE;\n      if (node->token.type == ANCHOR)\n\tdfa->nodes[node->node_idx].constraint = node->token.opr.ctx_type;\n    }\n  return REG_NOERROR;\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "calc_next": {
      "start_point": [
        1432,
        0
      ],
      "end_point": [
        1452,
        1
      ],
      "content": "static reg_errcode_t\ncalc_next (void *extra, bin_tree_t *node)\n{\n  switch (node->token.type)\n    {\n    case OP_DUP_ASTERISK:\n      node->left->next = node;\n      break;\n    case CONCAT:\n      node->left->next = node->right->first;\n      node->right->next = node->next;\n      break;\n    default:\n      if (node->left)\n\tnode->left->next = node->next;\n      if (node->right)\n\tnode->right->next = node->next;\n      break;\n    }\n  return REG_NOERROR;\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "link_nfa_nodes": {
      "start_point": [
        1455,
        0
      ],
      "end_point": [
        1509,
        1
      ],
      "content": "static reg_errcode_t\nlink_nfa_nodes (void *extra, bin_tree_t *node)\n{\n  re_dfa_t *dfa = (re_dfa_t *) extra;\n  int idx = node->node_idx;\n  reg_errcode_t err = REG_NOERROR;\n\n  switch (node->token.type)\n    {\n    case CONCAT:\n      break;\n\n    case END_OF_RE:\n      assert (node->next == NULL);\n      break;\n\n    case OP_DUP_ASTERISK:\n    case OP_ALT:\n      {\n\tint left, right;\n\tdfa->has_plural_match = 1;\n\tif (node->left != NULL)\n\t  left = node->left->first->node_idx;\n\telse\n\t  left = node->next->node_idx;\n\tif (node->right != NULL)\n\t  right = node->right->first->node_idx;\n\telse\n\t  right = node->next->node_idx;\n\tassert (left > -1);\n\tassert (right > -1);\n\terr = re_node_set_init_2 (dfa->edests + idx, left, right);\n      }\n      break;\n\n    case ANCHOR:\n    case OP_OPEN_SUBEXP:\n    case OP_CLOSE_SUBEXP:\n      err = re_node_set_init_1 (dfa->edests + idx, node->next->node_idx);\n      break;\n\n    case OP_BACK_REF:\n      dfa->nexts[idx] = node->next->node_idx;\n      if (node->token.type == OP_BACK_REF)\n\terr = re_node_set_init_1 (dfa->edests + idx, dfa->nexts[idx]);\n      break;\n\n    default:\n      assert (!IS_EPSILON_NODE (node->token.type));\n      dfa->nexts[idx] = node->next->node_idx;\n      break;\n    }\n\n  return err;\n}",
      "lines": 55,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "duplicate_node_closure": {
      "start_point": [
        1515,
        0
      ],
      "end_point": [
        1616,
        1
      ],
      "content": "static reg_errcode_t\nduplicate_node_closure (re_dfa_t *dfa, int top_org_node, int top_clone_node,\n\t\t\tint root_node, unsigned int init_constraint)\n{\n  int org_node, clone_node, ret;\n  unsigned int constraint = init_constraint;\n  for (org_node = top_org_node, clone_node = top_clone_node;;)\n    {\n      int org_dest, clone_dest;\n      if (dfa->nodes[org_node].type == OP_BACK_REF)\n\t{\n\t  /* If the back reference epsilon-transit, its destination must\n\t     also have the constraint.  Then duplicate the epsilon closure\n\t     of the destination of the back reference, and store it in\n\t     edests of the back reference.  */\n\t  org_dest = dfa->nexts[org_node];\n\t  re_node_set_empty (dfa->edests + clone_node);\n\t  clone_dest = duplicate_node (dfa, org_dest, constraint);\n\t  if (BE (clone_dest == -1, 0))\n\t    return REG_ESPACE;\n\t  dfa->nexts[clone_node] = dfa->nexts[org_node];\n\t  ret = re_node_set_insert (dfa->edests + clone_node, clone_dest);\n\t  if (BE (ret < 0, 0))\n\t    return REG_ESPACE;\n\t}\n      else if (dfa->edests[org_node].nelem == 0)\n\t{\n\t  /* In case of the node can't epsilon-transit, don't duplicate the\n\t     destination and store the original destination as the\n\t     destination of the node.  */\n\t  dfa->nexts[clone_node] = dfa->nexts[org_node];\n\t  break;\n\t}\n      else if (dfa->edests[org_node].nelem == 1)\n\t{\n\t  /* In case of the node can epsilon-transit, and it has only one\n\t     destination.  */\n\t  org_dest = dfa->edests[org_node].elems[0];\n\t  re_node_set_empty (dfa->edests + clone_node);\n\t  /* If the node is root_node itself, it means the epsilon closure\n\t     has a loop.   Then tie it to the destination of the root_node.  */\n\t  if (org_node == root_node && clone_node != org_node)\n\t    {\n\t      ret = re_node_set_insert (dfa->edests + clone_node, org_dest);\n\t      if (BE (ret < 0, 0))\n\t\treturn REG_ESPACE;\n\t      break;\n\t    }\n\t  /* In case the node has another constraint, append it.  */\n\t  constraint |= dfa->nodes[org_node].constraint;\n\t  clone_dest = duplicate_node (dfa, org_dest, constraint);\n\t  if (BE (clone_dest == -1, 0))\n\t    return REG_ESPACE;\n\t  ret = re_node_set_insert (dfa->edests + clone_node, clone_dest);\n\t  if (BE (ret < 0, 0))\n\t    return REG_ESPACE;\n\t}\n      else /* dfa->edests[org_node].nelem == 2 */\n\t{\n\t  /* In case of the node can epsilon-transit, and it has two\n\t     destinations. In the bin_tree_t and DFA, that's '|' and '*'.   */\n\t  org_dest = dfa->edests[org_node].elems[0];\n\t  re_node_set_empty (dfa->edests + clone_node);\n\t  /* Search for a duplicated node which satisfies the constraint.  */\n\t  clone_dest = search_duplicated_node (dfa, org_dest, constraint);\n\t  if (clone_dest == -1)\n\t    {\n\t      /* There is no such duplicated node, create a new one.  */\n\t      reg_errcode_t err;\n\t      clone_dest = duplicate_node (dfa, org_dest, constraint);\n\t      if (BE (clone_dest == -1, 0))\n\t\treturn REG_ESPACE;\n\t      ret = re_node_set_insert (dfa->edests + clone_node, clone_dest);\n\t      if (BE (ret < 0, 0))\n\t\treturn REG_ESPACE;\n\t      err = duplicate_node_closure (dfa, org_dest, clone_dest,\n\t\t\t\t\t    root_node, constraint);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\treturn err;\n\t    }\n\t  else\n\t    {\n\t      /* There is a duplicated node which satisfies the constraint,\n\t\t use it to avoid infinite loop.  */\n\t      ret = re_node_set_insert (dfa->edests + clone_node, clone_dest);\n\t      if (BE (ret < 0, 0))\n\t\treturn REG_ESPACE;\n\t    }\n\n\t  org_dest = dfa->edests[org_node].elems[1];\n\t  clone_dest = duplicate_node (dfa, org_dest, constraint);\n\t  if (BE (clone_dest == -1, 0))\n\t    return REG_ESPACE;\n\t  ret = re_node_set_insert (dfa->edests + clone_node, clone_dest);\n\t  if (BE (ret < 0, 0))\n\t    return REG_ESPACE;\n\t}\n      org_node = org_dest;\n      clone_node = clone_dest;\n    }\n  return REG_NOERROR;\n}",
      "lines": 102,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "search_duplicated_node": {
      "start_point": [
        1621,
        0
      ],
      "end_point": [
        1633,
        1
      ],
      "content": "static int\nsearch_duplicated_node (const re_dfa_t *dfa, int org_node,\n\t\t\tunsigned int constraint)\n{\n  int idx;\n  for (idx = dfa->nodes_len - 1; dfa->nodes[idx].duplicated && idx > 0; --idx)\n    {\n      if (org_node == dfa->org_indices[idx]\n\t  && constraint == dfa->nodes[idx].constraint)\n\treturn idx; /* Found.  */\n    }\n  return -1; /* Not found.  */\n}",
      "lines": 13,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "duplicate_node": {
      "start_point": [
        1639,
        0
      ],
      "end_point": [
        1653,
        1
      ],
      "content": "static int\nduplicate_node (re_dfa_t *dfa, int org_idx, unsigned int constraint)\n{\n  int dup_idx = re_dfa_add_node (dfa, dfa->nodes[org_idx]);\n  if (BE (dup_idx != -1, 1))\n    {\n      dfa->nodes[dup_idx].constraint = constraint;\n      dfa->nodes[dup_idx].constraint |= dfa->nodes[org_idx].constraint;\n      dfa->nodes[dup_idx].duplicated = 1;\n\n      /* Store the index of the original node.  */\n      dfa->org_indices[dup_idx] = org_idx;\n    }\n  return dup_idx;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "calc_inveclosure": {
      "start_point": [
        1655,
        0
      ],
      "end_point": [
        1674,
        1
      ],
      "content": "static reg_errcode_t\ncalc_inveclosure (re_dfa_t *dfa)\n{\n  int src, idx, ret;\n  for (idx = 0; idx < dfa->nodes_len; ++idx)\n    re_node_set_init_empty (dfa->inveclosures + idx);\n\n  for (src = 0; src < dfa->nodes_len; ++src)\n    {\n      int *elems = dfa->eclosures[src].elems;\n      for (idx = 0; idx < dfa->eclosures[src].nelem; ++idx)\n\t{\n\t  ret = re_node_set_insert_last (dfa->inveclosures + elems[idx], src);\n\t  if (BE (ret == -1, 0))\n\t    return REG_ESPACE;\n\t}\n    }\n\n  return REG_NOERROR;\n}",
      "lines": 20,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "calc_eclosure": {
      "start_point": [
        1678,
        0
      ],
      "end_point": [
        1718,
        1
      ],
      "content": "static reg_errcode_t\ncalc_eclosure (re_dfa_t *dfa)\n{\n  int node_idx, incomplete;\n#ifdef DEBUG\n  assert (dfa->nodes_len > 0);\n#endif\n  incomplete = 0;\n  /* For each nodes, calculate epsilon closure.  */\n  for (node_idx = 0; ; ++node_idx)\n    {\n      reg_errcode_t err;\n      re_node_set eclosure_elem;\n      if (node_idx == dfa->nodes_len)\n\t{\n\t  if (!incomplete)\n\t    break;\n\t  incomplete = 0;\n\t  node_idx = 0;\n\t}\n\n#ifdef DEBUG\n      assert (dfa->eclosures[node_idx].nelem != -1);\n#endif\n\n      /* If we have already calculated, skip it.  */\n      if (dfa->eclosures[node_idx].nelem != 0)\n\tcontinue;\n      /* Calculate epsilon closure of 'node_idx'.  */\n      err = calc_eclosure_iter (&eclosure_elem, dfa, node_idx, 1);\n      if (BE (err != REG_NOERROR, 0))\n\treturn err;\n\n      if (dfa->eclosures[node_idx].nelem == 0)\n\t{\n\t  incomplete = 1;\n\t  re_node_set_free (&eclosure_elem);\n\t}\n    }\n  return REG_NOERROR;\n}",
      "lines": 41,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "calc_eclosure_iter": {
      "start_point": [
        1722,
        0
      ],
      "end_point": [
        1796,
        1
      ],
      "content": "static reg_errcode_t\ncalc_eclosure_iter (re_node_set *new_set, re_dfa_t *dfa, int node, int root)\n{\n  reg_errcode_t err;\n  int i;\n  re_node_set eclosure;\n  int ret;\n  int incomplete = 0;\n  err = re_node_set_alloc (&eclosure, dfa->edests[node].nelem + 1);\n  if (BE (err != REG_NOERROR, 0))\n    return err;\n\n  /* This indicates that we are calculating this node now.\n     We reference this value to avoid infinite loop.  */\n  dfa->eclosures[node].nelem = -1;\n\n  /* If the current node has constraints, duplicate all nodes\n     since they must inherit the constraints.  */\n  if (dfa->nodes[node].constraint\n      && dfa->edests[node].nelem\n      && !dfa->nodes[dfa->edests[node].elems[0]].duplicated)\n    {\n      err = duplicate_node_closure (dfa, node, node, node,\n\t\t\t\t    dfa->nodes[node].constraint);\n      if (BE (err != REG_NOERROR, 0))\n\treturn err;\n    }\n\n  /* Expand each epsilon destination nodes.  */\n  if (IS_EPSILON_NODE(dfa->nodes[node].type))\n    for (i = 0; i < dfa->edests[node].nelem; ++i)\n      {\n\tre_node_set eclosure_elem;\n\tint edest = dfa->edests[node].elems[i];\n\t/* If calculating the epsilon closure of `edest' is in progress,\n\t   return intermediate result.  */\n\tif (dfa->eclosures[edest].nelem == -1)\n\t  {\n\t    incomplete = 1;\n\t    continue;\n\t  }\n\t/* If we haven't calculated the epsilon closure of `edest' yet,\n\t   calculate now. Otherwise use calculated epsilon closure.  */\n\tif (dfa->eclosures[edest].nelem == 0)\n\t  {\n\t    err = calc_eclosure_iter (&eclosure_elem, dfa, edest, 0);\n\t    if (BE (err != REG_NOERROR, 0))\n\t      return err;\n\t  }\n\telse\n\t  eclosure_elem = dfa->eclosures[edest];\n\t/* Merge the epsilon closure of 'edest'.  */\n\terr = re_node_set_merge (&eclosure, &eclosure_elem);\n\tif (BE (err != REG_NOERROR, 0))\n\t  return err;\n\t/* If the epsilon closure of 'edest' is incomplete,\n\t   the epsilon closure of this node is also incomplete.  */\n\tif (dfa->eclosures[edest].nelem == 0)\n\t  {\n\t    incomplete = 1;\n\t    re_node_set_free (&eclosure_elem);\n\t  }\n      }\n\n  /* An epsilon closure includes itself.  */\n  ret = re_node_set_insert (&eclosure, node);\n  if (BE (ret < 0, 0))\n    return REG_ESPACE;\n  if (incomplete && !root)\n    dfa->eclosures[node].nelem = 0;\n  else\n    dfa->eclosures[node] = eclosure;\n  *new_set = eclosure;\n  return REG_NOERROR;\n}",
      "lines": 75,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "fetch_token": {
      "start_point": [
        1803,
        0
      ],
      "end_point": [
        1807,
        1
      ],
      "content": "static void\nfetch_token (re_token_t *result, re_string_t *input, reg_syntax_t syntax)\n{\n  re_string_skip_bytes (input, peek_token (result, input, syntax));\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "peek_token": {
      "start_point": [
        1812,
        0
      ],
      "end_point": [
        2045,
        1
      ],
      "content": "static int\npeek_token (re_token_t *token, re_string_t *input, reg_syntax_t syntax)\n{\n  unsigned char c;\n\n  if (re_string_eoi (input))\n    {\n      token->type = END_OF_RE;\n      return 0;\n    }\n\n  c = re_string_peek_byte (input, 0);\n  token->opr.c = c;\n\n  token->word_char = 0;\n#ifdef RE_ENABLE_I18N\n  token->mb_partial = 0;\n  if (input->mb_cur_max > 1 &&\n      !re_string_first_byte (input, re_string_cur_idx (input)))\n    {\n      token->type = CHARACTER;\n      token->mb_partial = 1;\n      return 1;\n    }\n#endif\n  if (c == '\\\\')\n    {\n      unsigned char c2;\n      if (re_string_cur_idx (input) + 1 >= re_string_length (input))\n\t{\n\t  token->type = BACK_SLASH;\n\t  return 1;\n\t}\n\n      c2 = re_string_peek_byte_case (input, 1);\n      token->opr.c = c2;\n      token->type = CHARACTER;\n#ifdef RE_ENABLE_I18N\n      if (input->mb_cur_max > 1)\n\t{\n\t  wint_t wc = re_string_wchar_at (input,\n\t\t\t\t\t  re_string_cur_idx (input) + 1);\n\t  token->word_char = IS_WIDE_WORD_CHAR (wc) != 0;\n\t}\n      else\n#endif\n\ttoken->word_char = IS_WORD_CHAR (c2) != 0;\n\n      switch (c2)\n\t{\n\tcase '|':\n\t  if (!(syntax & RE_LIMITED_OPS) && !(syntax & RE_NO_BK_VBAR))\n\t    token->type = OP_ALT;\n\t  break;\n\tcase '1': case '2': case '3': case '4': case '5':\n\tcase '6': case '7': case '8': case '9':\n\t  if (!(syntax & RE_NO_BK_REFS))\n\t    {\n\t      token->type = OP_BACK_REF;\n\t      token->opr.idx = c2 - '1';\n\t    }\n\t  break;\n\tcase '<':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    {\n\t      token->type = ANCHOR;\n\t      token->opr.ctx_type = WORD_FIRST;\n\t    }\n\t  break;\n\tcase '>':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    {\n\t      token->type = ANCHOR;\n\t      token->opr.ctx_type = WORD_LAST;\n\t    }\n\t  break;\n\tcase 'b':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    {\n\t      token->type = ANCHOR;\n\t      token->opr.ctx_type = WORD_DELIM;\n\t    }\n\t  break;\n\tcase 'B':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    {\n\t      token->type = ANCHOR;\n\t      token->opr.ctx_type = NOT_WORD_DELIM;\n\t    }\n\t  break;\n\tcase 'w':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    token->type = OP_WORD;\n\t  break;\n\tcase 'W':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    token->type = OP_NOTWORD;\n\t  break;\n\tcase 's':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    token->type = OP_SPACE;\n\t  break;\n\tcase 'S':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    token->type = OP_NOTSPACE;\n\t  break;\n\tcase '`':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    {\n\t      token->type = ANCHOR;\n\t      token->opr.ctx_type = BUF_FIRST;\n\t    }\n\t  break;\n\tcase '\\'':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    {\n\t      token->type = ANCHOR;\n\t      token->opr.ctx_type = BUF_LAST;\n\t    }\n\t  break;\n\tcase '(':\n\t  if (!(syntax & RE_NO_BK_PARENS))\n\t    token->type = OP_OPEN_SUBEXP;\n\t  break;\n\tcase ')':\n\t  if (!(syntax & RE_NO_BK_PARENS))\n\t    token->type = OP_CLOSE_SUBEXP;\n\t  break;\n\tcase '+':\n\t  if (!(syntax & RE_LIMITED_OPS) && (syntax & RE_BK_PLUS_QM))\n\t    token->type = OP_DUP_PLUS;\n\t  break;\n\tcase '?':\n\t  if (!(syntax & RE_LIMITED_OPS) && (syntax & RE_BK_PLUS_QM))\n\t    token->type = OP_DUP_QUESTION;\n\t  break;\n\tcase '{':\n\t  if ((syntax & RE_INTERVALS) && (!(syntax & RE_NO_BK_BRACES)))\n\t    token->type = OP_OPEN_DUP_NUM;\n\t  break;\n\tcase '}':\n\t  if ((syntax & RE_INTERVALS) && (!(syntax & RE_NO_BK_BRACES)))\n\t    token->type = OP_CLOSE_DUP_NUM;\n\t  break;\n\tdefault:\n\t  break;\n\t}\n      return 2;\n    }\n\n  token->type = CHARACTER;\n#ifdef RE_ENABLE_I18N\n  if (input->mb_cur_max > 1)\n    {\n      wint_t wc = re_string_wchar_at (input, re_string_cur_idx (input));\n      token->word_char = IS_WIDE_WORD_CHAR (wc) != 0;\n    }\n  else\n#endif\n    token->word_char = IS_WORD_CHAR (token->opr.c);\n\n  switch (c)\n    {\n    case '\\n':\n      if (syntax & RE_NEWLINE_ALT)\n\ttoken->type = OP_ALT;\n      break;\n    case '|':\n      if (!(syntax & RE_LIMITED_OPS) && (syntax & RE_NO_BK_VBAR))\n\ttoken->type = OP_ALT;\n      break;\n    case '*':\n      token->type = OP_DUP_ASTERISK;\n      break;\n    case '+':\n      if (!(syntax & RE_LIMITED_OPS) && !(syntax & RE_BK_PLUS_QM))\n\ttoken->type = OP_DUP_PLUS;\n      break;\n    case '?':\n      if (!(syntax & RE_LIMITED_OPS) && !(syntax & RE_BK_PLUS_QM))\n\ttoken->type = OP_DUP_QUESTION;\n      break;\n    case '{':\n      if ((syntax & RE_INTERVALS) && (syntax & RE_NO_BK_BRACES))\n\ttoken->type = OP_OPEN_DUP_NUM;\n      break;\n    case '}':\n      if ((syntax & RE_INTERVALS) && (syntax & RE_NO_BK_BRACES))\n\ttoken->type = OP_CLOSE_DUP_NUM;\n      break;\n    case '(':\n      if (syntax & RE_NO_BK_PARENS)\n\ttoken->type = OP_OPEN_SUBEXP;\n      break;\n    case ')':\n      if (syntax & RE_NO_BK_PARENS)\n\ttoken->type = OP_CLOSE_SUBEXP;\n      break;\n    case '[':\n      token->type = OP_OPEN_BRACKET;\n      break;\n    case '.':\n      token->type = OP_PERIOD;\n      break;\n    case '^':\n      if (!(syntax & (RE_CONTEXT_INDEP_ANCHORS | RE_CARET_ANCHORS_HERE)) &&\n\t  re_string_cur_idx (input) != 0)\n\t{\n\t  char prev = re_string_peek_byte (input, -1);\n\t  if (!(syntax & RE_NEWLINE_ALT) || prev != '\\n')\n\t    break;\n\t}\n      token->type = ANCHOR;\n      token->opr.ctx_type = LINE_FIRST;\n      break;\n    case '$':\n      if (!(syntax & RE_CONTEXT_INDEP_ANCHORS) &&\n\t  re_string_cur_idx (input) + 1 != re_string_length (input))\n\t{\n\t  re_token_t next;\n\t  re_string_skip_bytes (input, 1);\n\t  peek_token (&next, input, syntax);\n\t  re_string_skip_bytes (input, -1);\n\t  if (next.type != OP_ALT && next.type != OP_CLOSE_SUBEXP)\n\t    break;\n\t}\n      token->type = ANCHOR;\n      token->opr.ctx_type = LINE_LAST;\n      break;\n    default:\n      break;\n    }\n  return 1;\n}",
      "lines": 234,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "peek_token_bracket": {
      "start_point": [
        2050,
        0
      ],
      "end_point": [
        2130,
        1
      ],
      "content": "static int\npeek_token_bracket (re_token_t *token, re_string_t *input, reg_syntax_t syntax)\n{\n  unsigned char c;\n  if (re_string_eoi (input))\n    {\n      token->type = END_OF_RE;\n      return 0;\n    }\n  c = re_string_peek_byte (input, 0);\n  token->opr.c = c;\n\n#ifdef RE_ENABLE_I18N\n  if (input->mb_cur_max > 1 &&\n      !re_string_first_byte (input, re_string_cur_idx (input)))\n    {\n      token->type = CHARACTER;\n      return 1;\n    }\n#endif /* RE_ENABLE_I18N */\n\n  if (c == '\\\\' && (syntax & RE_BACKSLASH_ESCAPE_IN_LISTS)\n      && re_string_cur_idx (input) + 1 < re_string_length (input))\n    {\n      /* In this case, '\\' escape a character.  */\n      unsigned char c2;\n      re_string_skip_bytes (input, 1);\n      c2 = re_string_peek_byte (input, 0);\n      token->opr.c = c2;\n      token->type = CHARACTER;\n      return 1;\n    }\n  if (c == '[') /* '[' is a special char in a bracket exps.  */\n    {\n      unsigned char c2;\n      int token_len;\n      if (re_string_cur_idx (input) + 1 < re_string_length (input))\n\tc2 = re_string_peek_byte (input, 1);\n      else\n\tc2 = 0;\n      token->opr.c = c2;\n      token_len = 2;\n      switch (c2)\n\t{\n\tcase '.':\n\t  token->type = OP_OPEN_COLL_ELEM;\n\t  break;\n\tcase '=':\n\t  token->type = OP_OPEN_EQUIV_CLASS;\n\t  break;\n\tcase ':':\n\t  if (syntax & RE_CHAR_CLASSES)\n\t    {\n\t      token->type = OP_OPEN_CHAR_CLASS;\n\t      break;\n\t    }\n\t  /* else fall through.  */\n\tdefault:\n\t  token->type = CHARACTER;\n\t  token->opr.c = c;\n\t  token_len = 1;\n\t  break;\n\t}\n      return token_len;\n    }\n  switch (c)\n    {\n    case '-':\n      token->type = OP_CHARSET_RANGE;\n      break;\n    case ']':\n      token->type = OP_CLOSE_BRACKET;\n      break;\n    case '^':\n      token->type = OP_NON_MATCH_LIST;\n      break;\n    default:\n      token->type = CHARACTER;\n    }\n  return 1;\n}",
      "lines": 81,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "parse": {
      "start_point": [
        2146,
        0
      ],
      "end_point": [
        2169,
        1
      ],
      "content": "static bin_tree_t *\nparse (re_string_t *regexp, regex_t *preg, reg_syntax_t syntax,\n       reg_errcode_t *err)\n{\n  re_dfa_t *dfa = (re_dfa_t *) preg->buffer;\n  bin_tree_t *tree, *eor, *root;\n  re_token_t current_token;\n  dfa->syntax = syntax;\n  fetch_token (&current_token, regexp, syntax | RE_CARET_ANCHORS_HERE);\n  tree = parse_reg_exp (regexp, preg, &current_token, syntax, 0, err);\n  if (BE (*err != REG_NOERROR && tree == NULL, 0))\n    return NULL;\n  eor = create_tree (dfa, NULL, NULL, END_OF_RE);\n  if (tree != NULL)\n    root = create_tree (dfa, tree, eor, CONCAT);\n  else\n    root = eor;\n  if (BE (eor == NULL || root == NULL, 0))\n    {\n      *err = REG_ESPACE;\n      return NULL;\n    }\n  return root;\n}",
      "lines": 24,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\nparse (re_string_t *regexp, regex_t *preg, reg_syntax_t syntax,\n       reg_errcode_t *err)",
        "*"
      ]
    },
    "parse_reg_exp": {
      "start_point": [
        2180,
        0
      ],
      "end_point": [
        2218,
        1
      ],
      "content": "static bin_tree_t *\nparse_reg_exp (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t       reg_syntax_t syntax, int nest, reg_errcode_t *err)\n{\n  re_dfa_t *dfa = (re_dfa_t *) preg->buffer;\n  bin_tree_t *tree, *branch = NULL;\n  bitset_word_t initial_bkref_map = dfa->completed_bkref_map;\n  tree = parse_branch (regexp, preg, token, syntax, nest, err);\n  if (BE (*err != REG_NOERROR && tree == NULL, 0))\n    return NULL;\n\n  while (token->type == OP_ALT)\n    {\n      fetch_token (token, regexp, syntax | RE_CARET_ANCHORS_HERE);\n      if (token->type != OP_ALT && token->type != END_OF_RE\n\t  && (nest == 0 || token->type != OP_CLOSE_SUBEXP))\n\t{\n\t  bitset_word_t accumulated_bkref_map = dfa->completed_bkref_map;\n\t  dfa->completed_bkref_map = initial_bkref_map;\n\t  branch = parse_branch (regexp, preg, token, syntax, nest, err);\n\t  if (BE (*err != REG_NOERROR && branch == NULL, 0))\n\t    {\n\t      if (tree != NULL)\n\t\tpostorder (tree, free_tree, NULL);\n\t      return NULL;\n\t    }\n\t  dfa->completed_bkref_map |= accumulated_bkref_map;\n\t}\n      else\n\tbranch = NULL;\n      tree = create_tree (dfa, tree, branch, OP_ALT);\n      if (BE (tree == NULL, 0))\n\t{\n\t  *err = REG_ESPACE;\n\t  return NULL;\n\t}\n    }\n  return tree;\n}",
      "lines": 39,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\nparse_reg_exp (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t       reg_syntax_t syntax, int nest, reg_errcode_t *err)",
        "*"
      ]
    },
    "parse_branch": {
      "start_point": [
        2229,
        0
      ],
      "end_point": [
        2266,
        1
      ],
      "content": "static bin_tree_t *\nparse_branch (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t      reg_syntax_t syntax, int nest, reg_errcode_t *err)\n{\n  bin_tree_t *tree, *exp;\n  re_dfa_t *dfa = (re_dfa_t *) preg->buffer;\n  tree = parse_expression (regexp, preg, token, syntax, nest, err);\n  if (BE (*err != REG_NOERROR && tree == NULL, 0))\n    return NULL;\n\n  while (token->type != OP_ALT && token->type != END_OF_RE\n\t && (nest == 0 || token->type != OP_CLOSE_SUBEXP))\n    {\n      exp = parse_expression (regexp, preg, token, syntax, nest, err);\n      if (BE (*err != REG_NOERROR && exp == NULL, 0))\n\t{\n\t  if (tree != NULL)\n\t    postorder (tree, free_tree, NULL);\n\t  return NULL;\n\t}\n      if (tree != NULL && exp != NULL)\n\t{\n\t  bin_tree_t *newtree = create_tree (dfa, tree, exp, CONCAT);\n\t  if (newtree == NULL)\n\t    {\n\t      postorder (exp, free_tree, NULL);\n\t      postorder (tree, free_tree, NULL);\n\t      *err = REG_ESPACE;\n\t      return NULL;\n\t    }\n\t  tree = newtree;\n\t}\n      else if (tree == NULL)\n\ttree = exp;\n      /* Otherwise exp == NULL, we don't need to create new tree.  */\n    }\n  return tree;\n}",
      "lines": 38,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\nparse_branch (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t      reg_syntax_t syntax, int nest, reg_errcode_t *err)",
        "*"
      ]
    },
    "parse_expression": {
      "start_point": [
        2274,
        0
      ],
      "end_point": [
        2488,
        1
      ],
      "content": "static bin_tree_t *\nparse_expression (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t\t  reg_syntax_t syntax, int nest, reg_errcode_t *err)\n{\n  re_dfa_t *dfa = (re_dfa_t *) preg->buffer;\n  bin_tree_t *tree;\n  switch (token->type)\n    {\n    case CHARACTER:\n      tree = create_token_tree (dfa, NULL, NULL, token);\n      if (BE (tree == NULL, 0))\n\t{\n\t  *err = REG_ESPACE;\n\t  return NULL;\n\t}\n#ifdef RE_ENABLE_I18N\n      if (dfa->mb_cur_max > 1)\n\t{\n\t  while (!re_string_eoi (regexp)\n\t\t && !re_string_first_byte (regexp, re_string_cur_idx (regexp)))\n\t    {\n\t      bin_tree_t *mbc_remain;\n\t      fetch_token (token, regexp, syntax);\n\t      mbc_remain = create_token_tree (dfa, NULL, NULL, token);\n\t      tree = create_tree (dfa, tree, mbc_remain, CONCAT);\n\t      if (BE (mbc_remain == NULL || tree == NULL, 0))\n\t\t{\n\t\t  *err = REG_ESPACE;\n\t\t  return NULL;\n\t\t}\n\t    }\n\t}\n#endif\n      break;\n    case OP_OPEN_SUBEXP:\n      tree = parse_sub_exp (regexp, preg, token, syntax, nest + 1, err);\n      if (BE (*err != REG_NOERROR && tree == NULL, 0))\n\treturn NULL;\n      break;\n    case OP_OPEN_BRACKET:\n      tree = parse_bracket_exp (regexp, dfa, token, syntax, err);\n      if (BE (*err != REG_NOERROR && tree == NULL, 0))\n\treturn NULL;\n      break;\n    case OP_BACK_REF:\n      if (!BE (dfa->completed_bkref_map & (1 << token->opr.idx), 1))\n\t{\n\t  *err = REG_ESUBREG;\n\t  return NULL;\n\t}\n      dfa->used_bkref_map |= 1 << token->opr.idx;\n      tree = create_token_tree (dfa, NULL, NULL, token);\n      if (BE (tree == NULL, 0))\n\t{\n\t  *err = REG_ESPACE;\n\t  return NULL;\n\t}\n      ++dfa->nbackref;\n      dfa->has_mb_node = 1;\n      break;\n    case OP_OPEN_DUP_NUM:\n      if (syntax & RE_CONTEXT_INVALID_DUP)\n\t{\n\t  *err = REG_BADRPT;\n\t  return NULL;\n\t}\n      /* FALLTHROUGH */\n    case OP_DUP_ASTERISK:\n    case OP_DUP_PLUS:\n    case OP_DUP_QUESTION:\n      if (syntax & RE_CONTEXT_INVALID_OPS)\n\t{\n\t  *err = REG_BADRPT;\n\t  return NULL;\n\t}\n      else if (syntax & RE_CONTEXT_INDEP_OPS)\n\t{\n\t  fetch_token (token, regexp, syntax);\n\t  return parse_expression (regexp, preg, token, syntax, nest, err);\n\t}\n      /* else fall through  */\n    case OP_CLOSE_SUBEXP:\n      if ((token->type == OP_CLOSE_SUBEXP) &&\n\t  !(syntax & RE_UNMATCHED_RIGHT_PAREN_ORD))\n\t{\n\t  *err = REG_ERPAREN;\n\t  return NULL;\n\t}\n      /* else fall through  */\n    case OP_CLOSE_DUP_NUM:\n      /* We treat it as a normal character.  */\n\n      /* Then we can these characters as normal characters.  */\n      token->type = CHARACTER;\n      /* mb_partial and word_char bits should be initialized already\n\t by peek_token.  */\n      tree = create_token_tree (dfa, NULL, NULL, token);\n      if (BE (tree == NULL, 0))\n\t{\n\t  *err = REG_ESPACE;\n\t  return NULL;\n\t}\n      break;\n    case ANCHOR:\n      if ((token->opr.ctx_type\n\t   & (WORD_DELIM | NOT_WORD_DELIM | WORD_FIRST | WORD_LAST))\n\t  && dfa->word_ops_used == 0)\n\tinit_word_char (dfa);\n      if (token->opr.ctx_type == WORD_DELIM\n\t  || token->opr.ctx_type == NOT_WORD_DELIM)\n\t{\n\t  bin_tree_t *tree_first, *tree_last;\n\t  if (token->opr.ctx_type == WORD_DELIM)\n\t    {\n\t      token->opr.ctx_type = WORD_FIRST;\n\t      tree_first = create_token_tree (dfa, NULL, NULL, token);\n\t      token->opr.ctx_type = WORD_LAST;\n\t    }\n\t  else\n\t    {\n\t      token->opr.ctx_type = INSIDE_WORD;\n\t      tree_first = create_token_tree (dfa, NULL, NULL, token);\n\t      token->opr.ctx_type = INSIDE_NOTWORD;\n\t    }\n\t  tree_last = create_token_tree (dfa, NULL, NULL, token);\n\t  tree = create_tree (dfa, tree_first, tree_last, OP_ALT);\n\t  if (BE (tree_first == NULL || tree_last == NULL || tree == NULL, 0))\n\t    {\n\t      *err = REG_ESPACE;\n\t      return NULL;\n\t    }\n\t}\n      else\n\t{\n\t  tree = create_token_tree (dfa, NULL, NULL, token);\n\t  if (BE (tree == NULL, 0))\n\t    {\n\t      *err = REG_ESPACE;\n\t      return NULL;\n\t    }\n\t}\n      /* We must return here, since ANCHORs can't be followed\n\t by repetition operators.\n\t eg. RE\"^*\" is invalid or \"<ANCHOR(^)><CHAR(*)>\",\n\t     it must not be \"<ANCHOR(^)><REPEAT(*)>\".  */\n      fetch_token (token, regexp, syntax);\n      return tree;\n    case OP_PERIOD:\n      tree = create_token_tree (dfa, NULL, NULL, token);\n      if (BE (tree == NULL, 0))\n\t{\n\t  *err = REG_ESPACE;\n\t  return NULL;\n\t}\n      if (dfa->mb_cur_max > 1)\n\tdfa->has_mb_node = 1;\n      break;\n    case OP_WORD:\n    case OP_NOTWORD:\n      tree = build_charclass_op (dfa, regexp->trans,\n\t\t\t\t \"alnum\",\n\t\t\t\t \"_\",\n\t\t\t\t token->type == OP_NOTWORD, err);\n      if (BE (*err != REG_NOERROR && tree == NULL, 0))\n\treturn NULL;\n      break;\n    case OP_SPACE:\n    case OP_NOTSPACE:\n      tree = build_charclass_op (dfa, regexp->trans,\n\t\t\t\t \"space\",\n\t\t\t\t \"\",\n\t\t\t\t token->type == OP_NOTSPACE, err);\n      if (BE (*err != REG_NOERROR && tree == NULL, 0))\n\treturn NULL;\n      break;\n    case OP_ALT:\n    case END_OF_RE:\n      return NULL;\n    case BACK_SLASH:\n      *err = REG_EESCAPE;\n      return NULL;\n    default:\n      /* Must not happen?  */\n#ifdef DEBUG\n      assert (0);\n#endif\n      return NULL;\n    }\n  fetch_token (token, regexp, syntax);\n\n  while (token->type == OP_DUP_ASTERISK || token->type == OP_DUP_PLUS\n\t || token->type == OP_DUP_QUESTION || token->type == OP_OPEN_DUP_NUM)\n    {\n      bin_tree_t *dup_tree = parse_dup_op (tree, regexp, dfa, token, syntax, err);\n      if (BE (*err != REG_NOERROR && dup_tree == NULL, 0))\n\t{\n\t  if (tree != NULL)\n\t    postorder (tree, free_tree, NULL);\n\t  return NULL;\n\t}\n      tree = dup_tree;\n      /* In BRE consecutive duplications are not allowed.  */\n      if ((syntax & RE_CONTEXT_INVALID_DUP)\n\t  && (token->type == OP_DUP_ASTERISK\n\t      || token->type == OP_OPEN_DUP_NUM))\n\t{\n\t  if (tree != NULL)\n\t    postorder (tree, free_tree, NULL);\n\t  *err = REG_BADRPT;\n\t  return NULL;\n\t}\n    }\n\n  return tree;\n}",
      "lines": 215,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\nparse_expression (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t\t  reg_syntax_t syntax, int nest, reg_errcode_t *err)",
        "*"
      ]
    },
    "parse_sub_exp": {
      "start_point": [
        2497,
        0
      ],
      "end_point": [
        2535,
        1
      ],
      "content": "static bin_tree_t *\nparse_sub_exp (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t       reg_syntax_t syntax, int nest, reg_errcode_t *err)\n{\n  re_dfa_t *dfa = (re_dfa_t *) preg->buffer;\n  bin_tree_t *tree;\n  size_t cur_nsub;\n  cur_nsub = preg->re_nsub++;\n\n  fetch_token (token, regexp, syntax | RE_CARET_ANCHORS_HERE);\n\n  /* The subexpression may be a null string.  */\n  if (token->type == OP_CLOSE_SUBEXP)\n    tree = NULL;\n  else\n    {\n      tree = parse_reg_exp (regexp, preg, token, syntax, nest, err);\n      if (BE (*err == REG_NOERROR && token->type != OP_CLOSE_SUBEXP, 0))\n\t{\n\t  if (tree != NULL)\n\t    postorder (tree, free_tree, NULL);\n\t  *err = REG_EPAREN;\n\t}\n      if (BE (*err != REG_NOERROR, 0))\n\treturn NULL;\n    }\n\n  if (cur_nsub <= '9' - '1')\n    dfa->completed_bkref_map |= 1 << cur_nsub;\n\n  tree = create_tree (dfa, tree, NULL, SUBEXP);\n  if (BE (tree == NULL, 0))\n    {\n      *err = REG_ESPACE;\n      return NULL;\n    }\n  tree->token.opr.idx = cur_nsub;\n  return tree;\n}",
      "lines": 39,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\nparse_sub_exp (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t       reg_syntax_t syntax, int nest, reg_errcode_t *err)",
        "*"
      ]
    },
    "parse_dup_op": {
      "start_point": [
        2539,
        0
      ],
      "end_point": [
        2667,
        1
      ],
      "content": "static bin_tree_t *\nparse_dup_op (bin_tree_t *elem, re_string_t *regexp, re_dfa_t *dfa,\n\t      re_token_t *token, reg_syntax_t syntax, reg_errcode_t *err)\n{\n  bin_tree_t *tree = NULL, *old_tree = NULL;\n  int i, start, end, start_idx = re_string_cur_idx (regexp);\n  re_token_t start_token = *token;\n\n  if (token->type == OP_OPEN_DUP_NUM)\n    {\n      end = 0;\n      start = fetch_number (regexp, token, syntax);\n      if (start == -1)\n\t{\n\t  if (token->type == CHARACTER && token->opr.c == ',')\n\t    start = 0; /* We treat \"{,m}\" as \"{0,m}\".  */\n\t  else\n\t    {\n\t      *err = REG_BADBR; /* <re>{} is invalid.  */\n\t      return NULL;\n\t    }\n\t}\n      if (BE (start != -2, 1))\n\t{\n\t  /* We treat \"{n}\" as \"{n,n}\".  */\n\t  end = ((token->type == OP_CLOSE_DUP_NUM) ? start\n\t\t : ((token->type == CHARACTER && token->opr.c == ',')\n\t\t    ? fetch_number (regexp, token, syntax) : -2));\n\t}\n      if (BE (start == -2 || end == -2, 0))\n\t{\n\t  /* Invalid sequence.  */\n\t  if (BE (!(syntax & RE_INVALID_INTERVAL_ORD), 0))\n\t    {\n\t      if (token->type == END_OF_RE)\n\t\t*err = REG_EBRACE;\n\t      else\n\t\t*err = REG_BADBR;\n\n\t      return NULL;\n\t    }\n\n\t  /* If the syntax bit is set, rollback.  */\n\t  re_string_set_index (regexp, start_idx);\n\t  *token = start_token;\n\t  token->type = CHARACTER;\n\t  /* mb_partial and word_char bits should be already initialized by\n\t     peek_token.  */\n\t  return elem;\n\t}\n\n      if (BE ((end != -1 && start > end) || token->type != OP_CLOSE_DUP_NUM, 0))\n\t{\n\t  /* First number greater than second.  */\n\t  *err = REG_BADBR;\n\t  return NULL;\n\t}\n    }\n  else\n    {\n      start = (token->type == OP_DUP_PLUS) ? 1 : 0;\n      end = (token->type == OP_DUP_QUESTION) ? 1 : -1;\n    }\n\n  fetch_token (token, regexp, syntax);\n\n  if (BE (elem == NULL, 0))\n    return NULL;\n  if (BE (start == 0 && end == 0, 0))\n    {\n      postorder (elem, free_tree, NULL);\n      return NULL;\n    }\n\n  /* Extract \"<re>{n,m}\" to \"<re><re>...<re><re>{0,<m-n>}\".  */\n  if (BE (start > 0, 0))\n    {\n      tree = elem;\n      for (i = 2; i <= start; ++i)\n\t{\n\t  elem = duplicate_tree (elem, dfa);\n\t  tree = create_tree (dfa, tree, elem, CONCAT);\n\t  if (BE (elem == NULL || tree == NULL, 0))\n\t    goto parse_dup_op_espace;\n\t}\n\n      if (start == end)\n\treturn tree;\n\n      /* Duplicate ELEM before it is marked optional.  */\n      elem = duplicate_tree (elem, dfa);\n      if (BE (elem == NULL, 0))\n        goto parse_dup_op_espace;\n      old_tree = tree;\n    }\n  else\n    old_tree = NULL;\n\n  if (elem->token.type == SUBEXP)\n    postorder (elem, mark_opt_subexp, (void *) (long) elem->token.opr.idx);\n\n  tree = create_tree (dfa, elem, NULL, (end == -1 ? OP_DUP_ASTERISK : OP_ALT));\n  if (BE (tree == NULL, 0))\n    goto parse_dup_op_espace;\n\n  /* This loop is actually executed only when end != -1,\n     to rewrite <re>{0,n} as (<re>(<re>...<re>?)?)?...  We have\n     already created the start+1-th copy.  */\n  for (i = start + 2; i <= end; ++i)\n    {\n      elem = duplicate_tree (elem, dfa);\n      tree = create_tree (dfa, tree, elem, CONCAT);\n      if (BE (elem == NULL || tree == NULL, 0))\n\tgoto parse_dup_op_espace;\n\n      tree = create_tree (dfa, tree, NULL, OP_ALT);\n      if (BE (tree == NULL, 0))\n\tgoto parse_dup_op_espace;\n    }\n\n  if (old_tree)\n    tree = create_tree (dfa, old_tree, tree, CONCAT);\n\n  return tree;\n\n parse_dup_op_espace:\n  *err = REG_ESPACE;\n  return NULL;\n}",
      "lines": 129,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\nparse_dup_op (bin_tree_t *elem, re_string_t *regexp, re_dfa_t *dfa,\n\t      re_token_t *token, reg_syntax_t syntax, reg_errcode_t *err)",
        "*"
      ]
    },
    "parse_bracket_exp": {
      "start_point": [
        2838,
        0
      ],
      "end_point": [
        3380,
        1
      ],
      "content": "static bin_tree_t *\nparse_bracket_exp (re_string_t *regexp, re_dfa_t *dfa, re_token_t *token,\n\t\t   reg_syntax_t syntax, reg_errcode_t *err)\n{\n#ifdef _LIBC\n  const unsigned char *collseqmb;\n  const char *collseqwc;\n  uint32_t nrules;\n  int32_t table_size;\n  const int32_t *symb_table;\n  const unsigned char *extra;\n\n  /* Local function for parse_bracket_exp used in _LIBC environment.\n     Seek the collating symbol entry corresponding to NAME.\n     Return the index of the symbol in the SYMB_TABLE,\n     or -1 if not found.  */\n\n  auto inline int32_t\n  __attribute__ ((always_inline))\n  seek_collating_symbol_entry (const unsigned char *name, size_t name_len)\n    {\n      int32_t elem;\n\n      for (elem = 0; elem < table_size; elem++)\n\tif (symb_table[2 * elem] != 0)\n\t  {\n\t    int32_t idx = symb_table[2 * elem + 1];\n\t    /* Skip the name of collating element name.  */\n\t    idx += 1 + extra[idx];\n\t    if (/* Compare the length of the name.  */\n\t\tname_len == extra[idx]\n\t\t/* Compare the name.  */\n\t\t&& memcmp (name, &extra[idx + 1], name_len) == 0)\n\t      /* Yep, this is the entry.  */\n\t      return elem;\n\t  }\n      return -1;\n    }\n\n  /* Local function for parse_bracket_exp used in _LIBC environment.\n     Look up the collation sequence value of BR_ELEM.\n     Return the value if succeeded, UINT_MAX otherwise.  */\n\n  auto inline unsigned int\n  __attribute__ ((always_inline))\n  lookup_collation_sequence_value (bracket_elem_t *br_elem)\n    {\n      if (br_elem->type == SB_CHAR)\n\t{\n\t  /*\n\t  if (MB_CUR_MAX == 1)\n\t  */\n\t  if (nrules == 0)\n\t    return collseqmb[br_elem->opr.ch];\n\t  else\n\t    {\n\t      wint_t wc = __btowc (br_elem->opr.ch);\n\t      return __collseq_table_lookup (collseqwc, wc);\n\t    }\n\t}\n      else if (br_elem->type == MB_CHAR)\n\t{\n\t  if (nrules != 0)\n\t    return __collseq_table_lookup (collseqwc, br_elem->opr.wch);\n\t}\n      else if (br_elem->type == COLL_SYM)\n\t{\n\t  size_t sym_name_len = strlen ((char *) br_elem->opr.name);\n\t  if (nrules != 0)\n\t    {\n\t      int32_t elem, idx;\n\t      elem = seek_collating_symbol_entry (br_elem->opr.name,\n\t\t\t\t\t\t  sym_name_len);\n\t      if (elem != -1)\n\t\t{\n\t\t  /* We found the entry.  */\n\t\t  idx = symb_table[2 * elem + 1];\n\t\t  /* Skip the name of collating element name.  */\n\t\t  idx += 1 + extra[idx];\n\t\t  /* Skip the byte sequence of the collating element.  */\n\t\t  idx += 1 + extra[idx];\n\t\t  /* Adjust for the alignment.  */\n\t\t  idx = (idx + 3) & ~3;\n\t\t  /* Skip the multibyte collation sequence value.  */\n\t\t  idx += sizeof (unsigned int);\n\t\t  /* Skip the wide char sequence of the collating element.  */\n\t\t  idx += sizeof (unsigned int) *\n\t\t    (1 + *(unsigned int *) (extra + idx));\n\t\t  /* Return the collation sequence value.  */\n\t\t  return *(unsigned int *) (extra + idx);\n\t\t}\n\t      else if (sym_name_len == 1)\n\t\t{\n\t\t  /* No valid character.  Match it as a single byte\n\t\t     character.  */\n\t\t  return collseqmb[br_elem->opr.name[0]];\n\t\t}\n\t    }\n\t  else if (sym_name_len == 1)\n\t    return collseqmb[br_elem->opr.name[0]];\n\t}\n      return UINT_MAX;\n    }\n\n  /* Local function for parse_bracket_exp used in _LIBC environment.\n     Build the range expression which starts from START_ELEM, and ends\n     at END_ELEM.  The result are written to MBCSET and SBCSET.\n     RANGE_ALLOC is the allocated size of mbcset->range_starts, and\n     mbcset->range_ends, is a pointer argument since we may\n     update it.  */\n\n  auto inline reg_errcode_t\n  __attribute__ ((always_inline))\n  build_range_exp (bitset_t sbcset, re_charset_t *mbcset, int *range_alloc,\n\t\t   bracket_elem_t *start_elem, bracket_elem_t *end_elem)\n    {\n      unsigned int ch;\n      uint32_t start_collseq;\n      uint32_t end_collseq;\n\n      /* Equivalence Classes and Character Classes can't be a range\n\t start/end.  */\n      if (BE (start_elem->type == EQUIV_CLASS || start_elem->type == CHAR_CLASS\n\t      || end_elem->type == EQUIV_CLASS || end_elem->type == CHAR_CLASS,\n\t      0))\n\treturn REG_ERANGE;\n\n      start_collseq = lookup_collation_sequence_value (start_elem);\n      end_collseq = lookup_collation_sequence_value (end_elem);\n      /* Check start/end collation sequence values.  */\n      if (BE (start_collseq == UINT_MAX || end_collseq == UINT_MAX, 0))\n\treturn REG_ECOLLATE;\n      if (BE ((syntax & RE_NO_EMPTY_RANGES) && start_collseq > end_collseq, 0))\n\treturn REG_ERANGE;\n\n      /* Got valid collation sequence values, add them as a new entry.\n\t However, if we have no collation elements, and the character set\n\t is single byte, the single byte character set that we\n\t build below suffices. */\n      if (nrules > 0 || dfa->mb_cur_max > 1)\n\t{\n\t  /* Check the space of the arrays.  */\n\t  if (BE (*range_alloc == mbcset->nranges, 0))\n\t    {\n\t      /* There is not enough space, need realloc.  */\n\t      uint32_t *new_array_start;\n\t      uint32_t *new_array_end;\n\t      int new_nranges;\n\n\t      /* +1 in case of mbcset->nranges is 0.  */\n\t      new_nranges = 2 * mbcset->nranges + 1;\n\t      new_array_start = re_realloc (mbcset->range_starts, uint32_t,\n\t\t\t\t\t    new_nranges);\n\t      new_array_end = re_realloc (mbcset->range_ends, uint32_t,\n\t\t\t\t\t  new_nranges);\n\n\t      if (BE (new_array_start == NULL || new_array_end == NULL, 0))\n\t\treturn REG_ESPACE;\n\n\t      mbcset->range_starts = new_array_start;\n\t      mbcset->range_ends = new_array_end;\n\t      *range_alloc = new_nranges;\n\t    }\n\n\t  mbcset->range_starts[mbcset->nranges] = start_collseq;\n\t  mbcset->range_ends[mbcset->nranges++] = end_collseq;\n\t}\n\n      /* Build the table for single byte characters.  */\n      for (ch = 0; ch < SBC_MAX; ch++)\n\t{\n\t  uint32_t ch_collseq;\n\t  /*\n\t  if (MB_CUR_MAX == 1)\n\t  */\n\t  if (nrules == 0)\n\t    ch_collseq = collseqmb[ch];\n\t  else\n\t    ch_collseq = __collseq_table_lookup (collseqwc, __btowc (ch));\n\t  if (start_collseq <= ch_collseq && ch_collseq <= end_collseq)\n\t    bitset_set (sbcset, ch);\n\t}\n      return REG_NOERROR;\n    }\n\n  /* Local function for parse_bracket_exp used in _LIBC environment.\n     Build the collating element which is represented by NAME.\n     The result are written to MBCSET and SBCSET.\n     COLL_SYM_ALLOC is the allocated size of mbcset->coll_sym, is a\n     pointer argument since we may update it.  */\n\n  auto inline reg_errcode_t\n  __attribute__ ((always_inline))\n  build_collating_symbol (bitset_t sbcset, re_charset_t *mbcset,\n\t\t\t  int *coll_sym_alloc, const unsigned char *name)\n    {\n      int32_t elem, idx;\n      size_t name_len = strlen ((const char *) name);\n      if (nrules != 0)\n\t{\n\t  elem = seek_collating_symbol_entry (name, name_len);\n\t  if (elem != -1)\n\t    {\n\t      /* We found the entry.  */\n\t      idx = symb_table[2 * elem + 1];\n\t      /* Skip the name of collating element name.  */\n\t      idx += 1 + extra[idx];\n\t    }\n\t  else if (name_len == 1)\n\t    {\n\t      /* No valid character, treat it as a normal\n\t\t character.  */\n\t      bitset_set (sbcset, name[0]);\n\t      return REG_NOERROR;\n\t    }\n\t  else\n\t    return REG_ECOLLATE;\n\n\t  /* Got valid collation sequence, add it as a new entry.  */\n\t  /* Check the space of the arrays.  */\n\t  if (BE (*coll_sym_alloc == mbcset->ncoll_syms, 0))\n\t    {\n\t      /* Not enough, realloc it.  */\n\t      /* +1 in case of mbcset->ncoll_syms is 0.  */\n\t      int new_coll_sym_alloc = 2 * mbcset->ncoll_syms + 1;\n\t      /* Use realloc since mbcset->coll_syms is NULL\n\t\t if *alloc == 0.  */\n\t      int32_t *new_coll_syms = re_realloc (mbcset->coll_syms, int32_t,\n\t\t\t\t\t\t   new_coll_sym_alloc);\n\t      if (BE (new_coll_syms == NULL, 0))\n\t\treturn REG_ESPACE;\n\t      mbcset->coll_syms = new_coll_syms;\n\t      *coll_sym_alloc = new_coll_sym_alloc;\n\t    }\n\t  mbcset->coll_syms[mbcset->ncoll_syms++] = idx;\n\t  return REG_NOERROR;\n\t}\n      else\n\t{\n\t  if (BE (name_len != 1, 0))\n\t    return REG_ECOLLATE;\n\t  else\n\t    {\n\t      bitset_set (sbcset, name[0]);\n\t      return REG_NOERROR;\n\t    }\n\t}\n    }\n#endif\n\n  re_token_t br_token;\n  re_bitset_ptr_t sbcset;\n#ifdef RE_ENABLE_I18N\n  re_charset_t *mbcset;\n  int coll_sym_alloc = 0, range_alloc = 0, mbchar_alloc = 0;\n  int equiv_class_alloc = 0, char_class_alloc = 0;\n#endif /* not RE_ENABLE_I18N */\n  int non_match = 0;\n  bin_tree_t *work_tree;\n  int token_len;\n  int first_round = 1;\n#ifdef _LIBC\n  collseqmb = (const unsigned char *)\n    _NL_CURRENT (LC_COLLATE, _NL_COLLATE_COLLSEQMB);\n  nrules = _NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_NRULES);\n  if (nrules)\n    {\n      /*\n      if (MB_CUR_MAX > 1)\n      */\n      collseqwc = _NL_CURRENT (LC_COLLATE, _NL_COLLATE_COLLSEQWC);\n      table_size = _NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_SYMB_HASH_SIZEMB);\n      symb_table = (const int32_t *) _NL_CURRENT (LC_COLLATE,\n\t\t\t\t\t\t  _NL_COLLATE_SYMB_TABLEMB);\n      extra = (const unsigned char *) _NL_CURRENT (LC_COLLATE,\n\t\t\t\t\t\t   _NL_COLLATE_SYMB_EXTRAMB);\n    }\n#endif\n  sbcset = (re_bitset_ptr_t) calloc (sizeof (bitset_t), 1);\n#ifdef RE_ENABLE_I18N\n  mbcset = (re_charset_t *) calloc (sizeof (re_charset_t), 1);\n#endif /* RE_ENABLE_I18N */\n#ifdef RE_ENABLE_I18N\n  if (BE (sbcset == NULL || mbcset == NULL, 0))\n#else\n  if (BE (sbcset == NULL, 0))\n#endif /* RE_ENABLE_I18N */\n    {\n      re_free (sbcset);\n#ifdef RE_ENABLE_I18N\n      re_free (mbcset);\n#endif\n      *err = REG_ESPACE;\n      return NULL;\n    }\n\n  token_len = peek_token_bracket (token, regexp, syntax);\n  if (BE (token->type == END_OF_RE, 0))\n    {\n      *err = REG_BADPAT;\n      goto parse_bracket_exp_free_return;\n    }\n  if (token->type == OP_NON_MATCH_LIST)\n    {\n#ifdef RE_ENABLE_I18N\n      mbcset->non_match = 1;\n#endif /* not RE_ENABLE_I18N */\n      non_match = 1;\n      if (syntax & RE_HAT_LISTS_NOT_NEWLINE)\n\tbitset_set (sbcset, '\\n');\n      re_string_skip_bytes (regexp, token_len); /* Skip a token.  */\n      token_len = peek_token_bracket (token, regexp, syntax);\n      if (BE (token->type == END_OF_RE, 0))\n\t{\n\t  *err = REG_BADPAT;\n\t  goto parse_bracket_exp_free_return;\n\t}\n    }\n\n  /* We treat the first ']' as a normal character.  */\n  if (token->type == OP_CLOSE_BRACKET)\n    token->type = CHARACTER;\n\n  while (1)\n    {\n      bracket_elem_t start_elem, end_elem;\n      unsigned char start_name_buf[BRACKET_NAME_BUF_SIZE];\n      unsigned char end_name_buf[BRACKET_NAME_BUF_SIZE];\n      reg_errcode_t ret;\n      int token_len2 = 0, is_range_exp = 0;\n      re_token_t token2;\n\n      start_elem.opr.name = start_name_buf;\n      start_elem.type = COLL_SYM;\n      ret = parse_bracket_element (&start_elem, regexp, token, token_len, dfa,\n\t\t\t\t   syntax, first_round);\n      if (BE (ret != REG_NOERROR, 0))\n\t{\n\t  *err = ret;\n\t  goto parse_bracket_exp_free_return;\n\t}\n      first_round = 0;\n\n      /* Get information about the next token.  We need it in any case.  */\n      token_len = peek_token_bracket (token, regexp, syntax);\n\n      /* Do not check for ranges if we know they are not allowed.  */\n      if (start_elem.type != CHAR_CLASS && start_elem.type != EQUIV_CLASS)\n\t{\n\t  if (BE (token->type == END_OF_RE, 0))\n\t    {\n\t      *err = REG_EBRACK;\n\t      goto parse_bracket_exp_free_return;\n\t    }\n\t  if (token->type == OP_CHARSET_RANGE)\n\t    {\n\t      re_string_skip_bytes (regexp, token_len); /* Skip '-'.  */\n\t      token_len2 = peek_token_bracket (&token2, regexp, syntax);\n\t      if (BE (token2.type == END_OF_RE, 0))\n\t\t{\n\t\t  *err = REG_EBRACK;\n\t\t  goto parse_bracket_exp_free_return;\n\t\t}\n\t      if (token2.type == OP_CLOSE_BRACKET)\n\t\t{\n\t\t  /* We treat the last '-' as a normal character.  */\n\t\t  re_string_skip_bytes (regexp, -token_len);\n\t\t  token->type = CHARACTER;\n\t\t}\n\t      else\n\t\tis_range_exp = 1;\n\t    }\n\t}\n\n      if (is_range_exp == 1)\n\t{\n\t  end_elem.opr.name = end_name_buf;\n\t  end_elem.type = COLL_SYM;\n\t  ret = parse_bracket_element (&end_elem, regexp, &token2, token_len2,\n\t\t\t\t       dfa, syntax, 1);\n\t  if (BE (ret != REG_NOERROR, 0))\n\t    {\n\t      *err = ret;\n\t      goto parse_bracket_exp_free_return;\n\t    }\n\n\t  token_len = peek_token_bracket (token, regexp, syntax);\n\n#ifdef _LIBC\n\t  *err = build_range_exp (syntax, sbcset, mbcset, &range_alloc,\n\t\t\t\t  &start_elem, &end_elem);\n#else\n# ifdef RE_ENABLE_I18N\n\t  *err = build_range_exp (syntax, sbcset,\n\t\t\t\t  dfa->mb_cur_max > 1 ? mbcset : NULL,\n\t\t\t\t  &range_alloc, &start_elem, &end_elem);\n# else\n\t  *err = build_range_exp (syntax, sbcset, &start_elem, &end_elem);\n# endif\n#endif /* RE_ENABLE_I18N */\n\t  if (BE (*err != REG_NOERROR, 0))\n\t    goto parse_bracket_exp_free_return;\n\t}\n      else\n\t{\n\t  switch (start_elem.type)\n\t    {\n\t    case SB_CHAR:\n\t      bitset_set (sbcset, start_elem.opr.ch);\n\t      break;\n#ifdef RE_ENABLE_I18N\n\t    case MB_CHAR:\n\t      /* Check whether the array has enough space.  */\n\t      if (BE (mbchar_alloc == mbcset->nmbchars, 0))\n\t\t{\n\t\t  wchar_t *new_mbchars;\n\t\t  /* Not enough, realloc it.  */\n\t\t  /* +1 in case of mbcset->nmbchars is 0.  */\n\t\t  mbchar_alloc = 2 * mbcset->nmbchars + 1;\n\t\t  /* Use realloc since array is NULL if *alloc == 0.  */\n\t\t  new_mbchars = re_realloc (mbcset->mbchars, wchar_t,\n\t\t\t\t\t    mbchar_alloc);\n\t\t  if (BE (new_mbchars == NULL, 0))\n\t\t    goto parse_bracket_exp_espace;\n\t\t  mbcset->mbchars = new_mbchars;\n\t\t}\n\t      mbcset->mbchars[mbcset->nmbchars++] = start_elem.opr.wch;\n\t      break;\n#endif /* RE_ENABLE_I18N */\n\t    case EQUIV_CLASS:\n\t      *err = build_equiv_class (sbcset,\n#ifdef RE_ENABLE_I18N\n\t\t\t\t\tmbcset, &equiv_class_alloc,\n#endif /* RE_ENABLE_I18N */\n\t\t\t\t\tstart_elem.opr.name);\n\t      if (BE (*err != REG_NOERROR, 0))\n\t\tgoto parse_bracket_exp_free_return;\n\t      break;\n\t    case COLL_SYM:\n\t      *err = build_collating_symbol (sbcset,\n#ifdef RE_ENABLE_I18N\n\t\t\t\t\t     mbcset, &coll_sym_alloc,\n#endif /* RE_ENABLE_I18N */\n\t\t\t\t\t     start_elem.opr.name);\n\t      if (BE (*err != REG_NOERROR, 0))\n\t\tgoto parse_bracket_exp_free_return;\n\t      break;\n\t    case CHAR_CLASS:\n\t      *err = build_charclass (regexp->trans, sbcset,\n#ifdef RE_ENABLE_I18N\n\t\t\t\t      mbcset, &char_class_alloc,\n#endif /* RE_ENABLE_I18N */\n\t\t\t\t      (const char *) start_elem.opr.name, syntax);\n\t      if (BE (*err != REG_NOERROR, 0))\n\t       goto parse_bracket_exp_free_return;\n\t      break;\n\t    default:\n\t      assert (0);\n\t      break;\n\t    }\n\t}\n      if (BE (token->type == END_OF_RE, 0))\n\t{\n\t  *err = REG_EBRACK;\n\t  goto parse_bracket_exp_free_return;\n\t}\n      if (token->type == OP_CLOSE_BRACKET)\n\tbreak;\n    }\n\n  re_string_skip_bytes (regexp, token_len); /* Skip a token.  */\n\n  /* If it is non-matching list.  */\n  if (non_match)\n    bitset_not (sbcset);\n\n#ifdef RE_ENABLE_I18N\n  /* Ensure only single byte characters are set.  */\n  if (dfa->mb_cur_max > 1)\n    bitset_mask (sbcset, dfa->sb_char);\n\n  if (mbcset->nmbchars || mbcset->ncoll_syms || mbcset->nequiv_classes\n      || mbcset->nranges || (dfa->mb_cur_max > 1 && (mbcset->nchar_classes\n\t\t\t\t\t\t     || mbcset->non_match)))\n    {\n      bin_tree_t *mbc_tree;\n      int sbc_idx;\n      /* Build a tree for complex bracket.  */\n      dfa->has_mb_node = 1;\n      br_token.type = COMPLEX_BRACKET;\n      br_token.opr.mbcset = mbcset;\n      mbc_tree = create_token_tree (dfa, NULL, NULL, &br_token);\n      if (BE (mbc_tree == NULL, 0))\n\tgoto parse_bracket_exp_espace;\n      for (sbc_idx = 0; sbc_idx < BITSET_WORDS; ++sbc_idx)\n\tif (sbcset[sbc_idx])\n\t  break;\n      /* If there are no bits set in sbcset, there is no point\n\t of having both SIMPLE_BRACKET and COMPLEX_BRACKET.  */\n      if (sbc_idx < BITSET_WORDS)\n\t{\n\t  /* Build a tree for simple bracket.  */\n\t  br_token.type = SIMPLE_BRACKET;\n\t  br_token.opr.sbcset = sbcset;\n\t  work_tree = create_token_tree (dfa, NULL, NULL, &br_token);\n\t  if (BE (work_tree == NULL, 0))\n\t    goto parse_bracket_exp_espace;\n\n\t  /* Then join them by ALT node.  */\n\t  work_tree = create_tree (dfa, work_tree, mbc_tree, OP_ALT);\n\t  if (BE (work_tree == NULL, 0))\n\t    goto parse_bracket_exp_espace;\n\t}\n      else\n\t{\n\t  re_free (sbcset);\n\t  work_tree = mbc_tree;\n\t}\n    }\n  else\n#endif /* not RE_ENABLE_I18N */\n    {\n#ifdef RE_ENABLE_I18N\n      free_charset (mbcset);\n#endif\n      /* Build a tree for simple bracket.  */\n      br_token.type = SIMPLE_BRACKET;\n      br_token.opr.sbcset = sbcset;\n      work_tree = create_token_tree (dfa, NULL, NULL, &br_token);\n      if (BE (work_tree == NULL, 0))\n\tgoto parse_bracket_exp_espace;\n    }\n  return work_tree;\n\n parse_bracket_exp_espace:\n  *err = REG_ESPACE;\n parse_bracket_exp_free_return:\n  re_free (sbcset);\n#ifdef RE_ENABLE_I18N\n  free_charset (mbcset);\n#endif /* RE_ENABLE_I18N */\n  return NULL;\n}",
      "lines": 543,
      "depth": 25,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\nparse_bracket_exp (re_string_t *regexp, re_dfa_t *dfa, re_token_t *token,\n\t\t   reg_syntax_t syntax, reg_errcode_t *err)",
        "*"
      ]
    },
    "seek_collating_symbol_entry": {
      "start_point": [
        2855,
        2
      ],
      "end_point": [
        2875,
        5
      ],
      "content": "auto inline int32_t\n  __attribute__ ((always_inline))\n  seek_collating_symbol_entry (const unsigned char *name, size_t name_len)\n    {\n      int32_t elem;\n\n      for (elem = 0; elem < table_size; elem++)\n\tif (symb_table[2 * elem] != 0)\n\t  {\n\t    int32_t idx = symb_table[2 * elem + 1];\n\t    /* Skip the name of collating element name.  */\n\t    idx += 1 + extra[idx];\n\t    if (/* Compare the length of the name.  */\n\t\tname_len == extra[idx]\n\t\t/* Compare the name.  */\n\t\t&& memcmp (name, &extra[idx + 1], name_len) == 0)\n\t      /* Yep, this is the entry.  */\n\t      return elem;\n\t  }\n      return -1;\n    }",
      "lines": 21,
      "depth": 15,
      "decorators": [
        "auto",
        "auto",
        "inline",
        "inline",
        "int32_t",
        "__attribute__ ((always_inline))",
        "__attribute__",
        "(",
        "(always_inline)",
        "(",
        "always_inline",
        ")",
        ")"
      ]
    },
    "lookup_collation_sequence_value": {
      "start_point": [
        2881,
        2
      ],
      "end_point": [
        2940,
        5
      ],
      "content": "auto inline unsigned int\n  __attribute__ ((always_inline))\n  lookup_collation_sequence_value (bracket_elem_t *br_elem)\n    {\n      if (br_elem->type == SB_CHAR)\n\t{\n\t  /*\n\t  if (MB_CUR_MAX == 1)\n\t  */\n\t  if (nrules == 0)\n\t    return collseqmb[br_elem->opr.ch];\n\t  else\n\t    {\n\t      wint_t wc = __btowc (br_elem->opr.ch);\n\t      return __collseq_table_lookup (collseqwc, wc);\n\t    }\n\t}\n      else if (br_elem->type == MB_CHAR)\n\t{\n\t  if (nrules != 0)\n\t    return __collseq_table_lookup (collseqwc, br_elem->opr.wch);\n\t}\n      else if (br_elem->type == COLL_SYM)\n\t{\n\t  size_t sym_name_len = strlen ((char *) br_elem->opr.name);\n\t  if (nrules != 0)\n\t    {\n\t      int32_t elem, idx;\n\t      elem = seek_collating_symbol_entry (br_elem->opr.name,\n\t\t\t\t\t\t  sym_name_len);\n\t      if (elem != -1)\n\t\t{\n\t\t  /* We found the entry.  */\n\t\t  idx = symb_table[2 * elem + 1];\n\t\t  /* Skip the name of collating element name.  */\n\t\t  idx += 1 + extra[idx];\n\t\t  /* Skip the byte sequence of the collating element.  */\n\t\t  idx += 1 + extra[idx];\n\t\t  /* Adjust for the alignment.  */\n\t\t  idx = (idx + 3) & ~3;\n\t\t  /* Skip the multibyte collation sequence value.  */\n\t\t  idx += sizeof (unsigned int);\n\t\t  /* Skip the wide char sequence of the collating element.  */\n\t\t  idx += sizeof (unsigned int) *\n\t\t    (1 + *(unsigned int *) (extra + idx));\n\t\t  /* Return the collation sequence value.  */\n\t\t  return *(unsigned int *) (extra + idx);\n\t\t}\n\t      else if (sym_name_len == 1)\n\t\t{\n\t\t  /* No valid character.  Match it as a single byte\n\t\t     character.  */\n\t\t  return collseqmb[br_elem->opr.name[0]];\n\t\t}\n\t    }\n\t  else if (sym_name_len == 1)\n\t    return collseqmb[br_elem->opr.name[0]];\n\t}\n      return UINT_MAX;\n    }",
      "lines": 60,
      "depth": 22,
      "decorators": [
        "auto",
        "auto",
        "inline",
        "inline",
        "unsigned int",
        "unsigned",
        "int",
        "__attribute__ ((always_inline))",
        "__attribute__",
        "(",
        "(always_inline)",
        "(",
        "always_inline",
        ")",
        ")"
      ]
    },
    "build_range_exp": {
      "start_point": [
        2949,
        2
      ],
      "end_point": [
        3021,
        5
      ],
      "content": "auto inline reg_errcode_t\n  __attribute__ ((always_inline))\n  build_range_exp (bitset_t sbcset, re_charset_t *mbcset, int *range_alloc,\n\t\t   bracket_elem_t *start_elem, bracket_elem_t *end_elem)\n    {\n      unsigned int ch;\n      uint32_t start_collseq;\n      uint32_t end_collseq;\n\n      /* Equivalence Classes and Character Classes can't be a range\n\t start/end.  */\n      if (BE (start_elem->type == EQUIV_CLASS || start_elem->type == CHAR_CLASS\n\t      || end_elem->type == EQUIV_CLASS || end_elem->type == CHAR_CLASS,\n\t      0))\n\treturn REG_ERANGE;\n\n      start_collseq = lookup_collation_sequence_value (start_elem);\n      end_collseq = lookup_collation_sequence_value (end_elem);\n      /* Check start/end collation sequence values.  */\n      if (BE (start_collseq == UINT_MAX || end_collseq == UINT_MAX, 0))\n\treturn REG_ECOLLATE;\n      if (BE ((syntax & RE_NO_EMPTY_RANGES) && start_collseq > end_collseq, 0))\n\treturn REG_ERANGE;\n\n      /* Got valid collation sequence values, add them as a new entry.\n\t However, if we have no collation elements, and the character set\n\t is single byte, the single byte character set that we\n\t build below suffices. */\n      if (nrules > 0 || dfa->mb_cur_max > 1)\n\t{\n\t  /* Check the space of the arrays.  */\n\t  if (BE (*range_alloc == mbcset->nranges, 0))\n\t    {\n\t      /* There is not enough space, need realloc.  */\n\t      uint32_t *new_array_start;\n\t      uint32_t *new_array_end;\n\t      int new_nranges;\n\n\t      /* +1 in case of mbcset->nranges is 0.  */\n\t      new_nranges = 2 * mbcset->nranges + 1;\n\t      new_array_start = re_realloc (mbcset->range_starts, uint32_t,\n\t\t\t\t\t    new_nranges);\n\t      new_array_end = re_realloc (mbcset->range_ends, uint32_t,\n\t\t\t\t\t  new_nranges);\n\n\t      if (BE (new_array_start == NULL || new_array_end == NULL, 0))\n\t\treturn REG_ESPACE;\n\n\t      mbcset->range_starts = new_array_start;\n\t      mbcset->range_ends = new_array_end;\n\t      *range_alloc = new_nranges;\n\t    }\n\n\t  mbcset->range_starts[mbcset->nranges] = start_collseq;\n\t  mbcset->range_ends[mbcset->nranges++] = end_collseq;\n\t}\n\n      /* Build the table for single byte characters.  */\n      for (ch = 0; ch < SBC_MAX; ch++)\n\t{\n\t  uint32_t ch_collseq;\n\t  /*\n\t  if (MB_CUR_MAX == 1)\n\t  */\n\t  if (nrules == 0)\n\t    ch_collseq = collseqmb[ch];\n\t  else\n\t    ch_collseq = __collseq_table_lookup (collseqwc, __btowc (ch));\n\t  if (start_collseq <= ch_collseq && ch_collseq <= end_collseq)\n\t    bitset_set (sbcset, ch);\n\t}\n      return REG_NOERROR;\n    }",
      "lines": 73,
      "depth": 13,
      "decorators": [
        "auto",
        "auto",
        "inline",
        "inline",
        "reg_errcode_t",
        "__attribute__ ((always_inline))",
        "__attribute__",
        "(",
        "(always_inline)",
        "(",
        "always_inline",
        ")",
        ")"
      ]
    },
    "build_collating_symbol": {
      "start_point": [
        3029,
        2
      ],
      "end_point": [
        3085,
        5
      ],
      "content": "auto inline reg_errcode_t\n  __attribute__ ((always_inline))\n  build_collating_symbol (bitset_t sbcset, re_charset_t *mbcset,\n\t\t\t  int *coll_sym_alloc, const unsigned char *name)\n    {\n      int32_t elem, idx;\n      size_t name_len = strlen ((const char *) name);\n      if (nrules != 0)\n\t{\n\t  elem = seek_collating_symbol_entry (name, name_len);\n\t  if (elem != -1)\n\t    {\n\t      /* We found the entry.  */\n\t      idx = symb_table[2 * elem + 1];\n\t      /* Skip the name of collating element name.  */\n\t      idx += 1 + extra[idx];\n\t    }\n\t  else if (name_len == 1)\n\t    {\n\t      /* No valid character, treat it as a normal\n\t\t character.  */\n\t      bitset_set (sbcset, name[0]);\n\t      return REG_NOERROR;\n\t    }\n\t  else\n\t    return REG_ECOLLATE;\n\n\t  /* Got valid collation sequence, add it as a new entry.  */\n\t  /* Check the space of the arrays.  */\n\t  if (BE (*coll_sym_alloc == mbcset->ncoll_syms, 0))\n\t    {\n\t      /* Not enough, realloc it.  */\n\t      /* +1 in case of mbcset->ncoll_syms is 0.  */\n\t      int new_coll_sym_alloc = 2 * mbcset->ncoll_syms + 1;\n\t      /* Use realloc since mbcset->coll_syms is NULL\n\t\t if *alloc == 0.  */\n\t      int32_t *new_coll_syms = re_realloc (mbcset->coll_syms, int32_t,\n\t\t\t\t\t\t   new_coll_sym_alloc);\n\t      if (BE (new_coll_syms == NULL, 0))\n\t\treturn REG_ESPACE;\n\t      mbcset->coll_syms = new_coll_syms;\n\t      *coll_sym_alloc = new_coll_sym_alloc;\n\t    }\n\t  mbcset->coll_syms[mbcset->ncoll_syms++] = idx;\n\t  return REG_NOERROR;\n\t}\n      else\n\t{\n\t  if (BE (name_len != 1, 0))\n\t    return REG_ECOLLATE;\n\t  else\n\t    {\n\t      bitset_set (sbcset, name[0]);\n\t      return REG_NOERROR;\n\t    }\n\t}\n    }",
      "lines": 57,
      "depth": 12,
      "decorators": [
        "auto",
        "auto",
        "inline",
        "inline",
        "reg_errcode_t",
        "__attribute__ ((always_inline))",
        "__attribute__",
        "(",
        "(always_inline)",
        "(",
        "always_inline",
        ")",
        ")"
      ]
    },
    "parse_bracket_element": {
      "start_point": [
        3384,
        0
      ],
      "end_point": [
        3418,
        1
      ],
      "content": "static reg_errcode_t\nparse_bracket_element (bracket_elem_t *elem, re_string_t *regexp,\n\t\t       re_token_t *token, int token_len, re_dfa_t *dfa,\n\t\t       reg_syntax_t syntax, int accept_hyphen)\n{\n#ifdef RE_ENABLE_I18N\n  int cur_char_size;\n  cur_char_size = re_string_char_size_at (regexp, re_string_cur_idx (regexp));\n  if (cur_char_size > 1)\n    {\n      elem->type = MB_CHAR;\n      elem->opr.wch = re_string_wchar_at (regexp, re_string_cur_idx (regexp));\n      re_string_skip_bytes (regexp, cur_char_size);\n      return REG_NOERROR;\n    }\n#endif /* RE_ENABLE_I18N */\n  re_string_skip_bytes (regexp, token_len); /* Skip a token.  */\n  if (token->type == OP_OPEN_COLL_ELEM || token->type == OP_OPEN_CHAR_CLASS\n      || token->type == OP_OPEN_EQUIV_CLASS)\n    return parse_bracket_symbol (elem, regexp, token);\n  if (BE (token->type == OP_CHARSET_RANGE, 0) && !accept_hyphen)\n    {\n      /* A '-' must only appear as anything but a range indicator before\n\t the closing bracket.  Everything else is an error.  */\n      re_token_t token2;\n      (void) peek_token_bracket (&token2, regexp, syntax);\n      if (token2.type != OP_CLOSE_BRACKET)\n\t/* The actual error value is not standardized since this whole\n\t   case is undefined.  But ERANGE makes good sense.  */\n\treturn REG_ERANGE;\n    }\n  elem->type = SB_CHAR;\n  elem->opr.ch = token->opr.c;\n  return REG_NOERROR;\n}",
      "lines": 35,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "parse_bracket_symbol": {
      "start_point": [
        3424,
        0
      ],
      "end_point": [
        3463,
        1
      ],
      "content": "static reg_errcode_t\nparse_bracket_symbol (bracket_elem_t *elem, re_string_t *regexp,\n\t\t      re_token_t *token)\n{\n  unsigned char ch, delim = token->opr.c;\n  int i = 0;\n  if (re_string_eoi(regexp))\n    return REG_EBRACK;\n  for (;; ++i)\n    {\n      if (i >= BRACKET_NAME_BUF_SIZE)\n\treturn REG_EBRACK;\n      if (token->type == OP_OPEN_CHAR_CLASS)\n\tch = re_string_fetch_byte_case (regexp);\n      else\n\tch = re_string_fetch_byte (regexp);\n      if (re_string_eoi(regexp))\n\treturn REG_EBRACK;\n      if (ch == delim && re_string_peek_byte (regexp, 0) == ']')\n\tbreak;\n      elem->opr.name[i] = ch;\n    }\n  re_string_skip_bytes (regexp, 1);\n  elem->opr.name[i] = '\\0';\n  switch (token->type)\n    {\n    case OP_OPEN_COLL_ELEM:\n      elem->type = COLL_SYM;\n      break;\n    case OP_OPEN_EQUIV_CLASS:\n      elem->type = EQUIV_CLASS;\n      break;\n    case OP_OPEN_CHAR_CLASS:\n      elem->type = CHAR_CLASS;\n      break;\n    default:\n      break;\n    }\n  return REG_NOERROR;\n}",
      "lines": 40,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "build_charclass_op": {
      "start_point": [
        3652,
        0
      ],
      "end_point": [
        3766,
        1
      ],
      "content": "static bin_tree_t *\nbuild_charclass_op (re_dfa_t *dfa, RE_TRANSLATE_TYPE trans,\n\t\t    const char *class_name,\n\t\t    const char *extra, int non_match,\n\t\t    reg_errcode_t *err)\n{\n  re_bitset_ptr_t sbcset;\n#ifdef RE_ENABLE_I18N\n  re_charset_t *mbcset;\n  int alloc = 0;\n#endif /* not RE_ENABLE_I18N */\n  reg_errcode_t ret;\n  re_token_t br_token;\n  bin_tree_t *tree;\n\n  sbcset = (re_bitset_ptr_t) calloc (sizeof (bitset_t), 1);\n#ifdef RE_ENABLE_I18N\n  mbcset = (re_charset_t *) calloc (sizeof (re_charset_t), 1);\n#endif /* RE_ENABLE_I18N */\n\n#ifdef RE_ENABLE_I18N\n  if (BE (sbcset == NULL || mbcset == NULL, 0))\n#else /* not RE_ENABLE_I18N */\n  if (BE (sbcset == NULL, 0))\n#endif /* not RE_ENABLE_I18N */\n    {\n      /* if one is not NULL, free it to avoid leaks */\n      if (sbcset != NULL)\n         free(sbcset);\n#ifdef RE_ENABLE_I18N\n      if (mbcset != NULL)\n         free(mbcset);\n#endif\n      *err = REG_ESPACE;\n      return NULL;\n    }\n\n  if (non_match)\n    {\n#ifdef RE_ENABLE_I18N\n      mbcset->non_match = 1;\n#endif /* not RE_ENABLE_I18N */\n    }\n\n  /* We don't care the syntax in this case.  */\n  ret = build_charclass (trans, sbcset,\n#ifdef RE_ENABLE_I18N\n\t\t\t mbcset, &alloc,\n#endif /* RE_ENABLE_I18N */\n\t\t\t class_name, 0);\n\n  if (BE (ret != REG_NOERROR, 0))\n    {\n      re_free (sbcset);\n#ifdef RE_ENABLE_I18N\n      free_charset (mbcset);\n#endif /* RE_ENABLE_I18N */\n      *err = ret;\n      return NULL;\n    }\n  /* \\w match '_' also.  */\n  for (; *extra; extra++)\n    bitset_set (sbcset, *extra);\n\n  /* If it is non-matching list.  */\n  if (non_match)\n    bitset_not (sbcset);\n\n#ifdef RE_ENABLE_I18N\n  /* Ensure only single byte characters are set.  */\n  if (dfa->mb_cur_max > 1)\n    bitset_mask (sbcset, dfa->sb_char);\n#endif\n\n  /* Build a tree for simple bracket.  */\n  memset(& br_token, 0, sizeof(br_token));\t/* silence \"not initialized\" errors froms static checkers */\n  br_token.type = SIMPLE_BRACKET;\n  br_token.opr.sbcset = sbcset;\n  tree = create_token_tree (dfa, NULL, NULL, &br_token);\n  if (BE (tree == NULL, 0))\n    goto build_word_op_espace;\n\n#ifdef RE_ENABLE_I18N\n  if (dfa->mb_cur_max > 1)\n    {\n      bin_tree_t *mbc_tree;\n      /* Build a tree for complex bracket.  */\n      br_token.type = COMPLEX_BRACKET;\n      br_token.opr.mbcset = mbcset;\n      dfa->has_mb_node = 1;\n      mbc_tree = create_token_tree (dfa, NULL, NULL, &br_token);\n      if (BE (mbc_tree == NULL, 0))\n\tgoto build_word_op_espace;\n      /* Then join them by ALT node.  */\n      tree = create_tree (dfa, tree, mbc_tree, OP_ALT);\n      if (BE (mbc_tree != NULL, 1))\n\treturn tree;\n    }\n  else\n    {\n      free_charset (mbcset);\n      return tree;\n    }\n#else /* not RE_ENABLE_I18N */\n  return tree;\n#endif /* not RE_ENABLE_I18N */\n\n build_word_op_espace:\n  re_free (sbcset);\n#ifdef RE_ENABLE_I18N\n  free_charset (mbcset);\n#endif /* RE_ENABLE_I18N */\n  *err = REG_ESPACE;\n  return NULL;\n}",
      "lines": 115,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\nbuild_charclass_op (re_dfa_t *dfa, RE_TRANSLATE_TYPE trans,\n\t\t    const char *class_name,\n\t\t    const char *extra, int non_match,\n\t\t    reg_errcode_t *err)",
        "*"
      ]
    },
    "fetch_number": {
      "start_point": [
        3773,
        0
      ],
      "end_point": [
        3791,
        1
      ],
      "content": "static int\nfetch_number (re_string_t *input, re_token_t *token, reg_syntax_t syntax)\n{\n  int num = -1;\n  unsigned char c;\n  while (1)\n    {\n      fetch_token (token, input, syntax);\n      c = token->opr.c;\n      if (BE (token->type == END_OF_RE, 0))\n\treturn -2;\n      if (token->type == OP_CLOSE_DUP_NUM || c == ',')\n\tbreak;\n      num = ((token->type != CHARACTER || c < '0' || '9' < c || num == -2)\n\t     ? -2 : ((num == -1) ? c - '0' : num * 10 + c - '0'));\n      num = (num > RE_DUP_MAX) ? -2 : num;\n    }\n  return num;\n}",
      "lines": 19,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "free_charset": {
      "start_point": [
        3794,
        0
      ],
      "end_point": [
        3806,
        1
      ],
      "content": "static void\nfree_charset (re_charset_t *cset)\n{\n  re_free (cset->mbchars);\n# ifdef _LIBC\n  re_free (cset->coll_syms);\n  re_free (cset->equiv_classes);\n  re_free (cset->range_starts);\n  re_free (cset->range_ends);\n# endif\n  re_free (cset->char_classes);\n  re_free (cset);\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "create_tree": {
      "start_point": [
        3813,
        0
      ],
      "end_point": [
        3821,
        1
      ],
      "content": "static bin_tree_t *\ncreate_tree (re_dfa_t *dfa, bin_tree_t *left, bin_tree_t *right,\n\t     re_token_type_t type)\n{\n  re_token_t t;\n  memset(& t, 0, sizeof(t));\t/* silence \"not initialized\" errors froms static checkers */\n  t.type = type;\n  return create_token_tree (dfa, left, right, &t);\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\ncreate_tree (re_dfa_t *dfa, bin_tree_t *left, bin_tree_t *right,\n\t     re_token_type_t type)",
        "*"
      ]
    },
    "create_token_tree": {
      "start_point": [
        3823,
        0
      ],
      "end_point": [
        3855,
        1
      ],
      "content": "static bin_tree_t *\ncreate_token_tree (re_dfa_t *dfa, bin_tree_t *left, bin_tree_t *right,\n\t\t   const re_token_t *token)\n{\n  bin_tree_t *tree;\n  if (BE (dfa->str_tree_storage_idx == BIN_TREE_STORAGE_SIZE, 0))\n    {\n      bin_tree_storage_t *storage = re_malloc (bin_tree_storage_t, 1);\n\n      if (storage == NULL)\n\treturn NULL;\n      storage->next = dfa->str_tree_storage;\n      dfa->str_tree_storage = storage;\n      dfa->str_tree_storage_idx = 0;\n    }\n  tree = &dfa->str_tree_storage->data[dfa->str_tree_storage_idx++];\n\n  tree->parent = NULL;\n  tree->left = left;\n  tree->right = right;\n  tree->token = *token;\n  tree->token.duplicated = 0;\n  tree->token.opt_subexp = 0;\n  tree->first = NULL;\n  tree->next = NULL;\n  tree->node_idx = -1;\n\n  if (left != NULL)\n    left->parent = tree;\n  if (right != NULL)\n    right->parent = tree;\n  return tree;\n}",
      "lines": 33,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\ncreate_token_tree (re_dfa_t *dfa, bin_tree_t *left, bin_tree_t *right,\n\t\t   const re_token_t *token)",
        "*"
      ]
    },
    "mark_opt_subexp": {
      "start_point": [
        3860,
        0
      ],
      "end_point": [
        3868,
        1
      ],
      "content": "static reg_errcode_t\nmark_opt_subexp (void *extra, bin_tree_t *node)\n{\n  int idx = (int) (long) extra;\n  if (node->token.type == SUBEXP && node->token.opr.idx == idx)\n    node->token.opt_subexp = 1;\n\n  return REG_NOERROR;\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "free_token": {
      "start_point": [
        3872,
        0
      ],
      "end_point": [
        3882,
        1
      ],
      "content": "static void\nfree_token (re_token_t *node)\n{\n#ifdef RE_ENABLE_I18N\n  if (node->type == COMPLEX_BRACKET && node->duplicated == 0)\n    free_charset (node->opr.mbcset);\n  else\n#endif /* RE_ENABLE_I18N */\n    if (node->type == SIMPLE_BRACKET && node->duplicated == 0)\n      re_free (node->opr.sbcset);\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "free_tree": {
      "start_point": [
        3887,
        0
      ],
      "end_point": [
        3892,
        1
      ],
      "content": "static reg_errcode_t\nfree_tree (void *extra, bin_tree_t *node)\n{\n  free_token (&node->token);\n  return REG_NOERROR;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "duplicate_tree": {
      "start_point": [
        3900,
        0
      ],
      "end_point": [
        3938,
        1
      ],
      "content": "static bin_tree_t *\nduplicate_tree (const bin_tree_t *root, re_dfa_t *dfa)\n{\n  const bin_tree_t *node;\n  bin_tree_t *dup_root;\n  bin_tree_t **p_new = &dup_root, *dup_node = root->parent;\n\n  for (node = root; ; )\n    {\n      /* Create a new tree and link it back to the current parent.  */\n      *p_new = create_token_tree (dfa, NULL, NULL, &node->token);\n      if (*p_new == NULL)\n\treturn NULL;\n      (*p_new)->parent = dup_node;\n      (*p_new)->token.duplicated = 1;\n      dup_node = *p_new;\n\n      /* Go to the left node, or up and to the right.  */\n      if (node->left)\n\t{\n\t  node = node->left;\n\t  p_new = &dup_node->left;\n\t}\n      else\n\t{\n\t  const bin_tree_t *prev = NULL;\n\t  while (node->right == prev || node->right == NULL)\n\t    {\n\t      prev = node;\n\t      node = node->parent;\n\t      dup_node = dup_node->parent;\n\t      if (!node)\n\t\treturn dup_root;\n\t    }\n\t  node = node->right;\n\t  p_new = &dup_node->right;\n\t}\n    }\n}",
      "lines": 39,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\nduplicate_tree (const bin_tree_t *root, re_dfa_t *dfa)",
        "*"
      ]
    }
  },
  "gawk/gawk-4.2.1/support/regex.c": {},
  "gawk/gawk-4.2.1/support/regex.h": {},
  "gawk/gawk-4.2.1/support/regexec.c": {
    "MIN": {
      "start_point": [
        180,
        0
      ],
      "end_point": [
        184,
        1
      ],
      "content": "static int\nMIN(size_t a, size_t b)\n{\n\treturn (a < b ? a : b);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "regexec": {
      "start_point": [
        203,
        0
      ],
      "end_point": [
        233,
        1
      ],
      "content": "int\nregexec (const regex_t *__restrict preg, const char *__restrict string,\n\t size_t nmatch, regmatch_t pmatch[], int eflags)\n{\n  reg_errcode_t err;\n  int start, length;\n\n  if (eflags & ~(REG_NOTBOL | REG_NOTEOL | REG_STARTEND))\n    return REG_BADPAT;\n\n  if (eflags & REG_STARTEND)\n    {\n      start = pmatch[0].rm_so;\n      length = pmatch[0].rm_eo;\n    }\n  else\n    {\n      start = 0;\n      length = strlen (string);\n    }\n\n  __libc_lock_lock (dfa->lock);\n  if (preg->no_sub)\n    err = re_search_internal (preg, string, length, start, length - start,\n\t\t\t      length, 0, NULL, eflags);\n  else\n    err = re_search_internal (preg, string, length, start, length - start,\n\t\t\t      length, nmatch, pmatch, eflags);\n  __libc_lock_unlock (dfa->lock);\n  return err != REG_NOERROR;\n}",
      "lines": 31,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "__compat_regexec": {
      "start_point": [
        244,
        0
      ],
      "end_point": [
        252,
        1
      ],
      "content": "int\nattribute_compat_text_section\n__compat_regexec (const regex_t *__restrict preg,\n\t\t  const char *__restrict string, size_t nmatch,\n\t\t  regmatch_t pmatch[], int eflags)\n{\n  return regexec (preg, string, nmatch, pmatch,\n\t\t  eflags & (REG_NOTBOL | REG_NOTEOL));\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "int",
        "attribute_compat_text_section",
        "attribute_compat_text_section"
      ]
    },
    "re_match": {
      "start_point": [
        286,
        0
      ],
      "end_point": [
        291,
        1
      ],
      "content": "int\nre_match (struct re_pattern_buffer *bufp, const char *string, int length,\n\t  int start, struct re_registers *regs)\n{\n  return re_search_stub (bufp, string, length, start, 0, length, regs, 1);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "re_search": {
      "start_point": [
        296,
        0
      ],
      "end_point": [
        301,
        1
      ],
      "content": "int\nre_search (struct re_pattern_buffer *bufp, const char *string, int length,\n\t   int start, int range, struct re_registers *regs)\n{\n  return re_search_stub (bufp, string, length, start, range, length, regs, 0);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "re_match_2": {
      "start_point": [
        306,
        0
      ],
      "end_point": [
        313,
        1
      ],
      "content": "int\nre_match_2 (struct re_pattern_buffer *bufp, const char *string1, int length1,\n\t    const char *string2, int length2, int start,\n\t    struct re_registers *regs, int stop)\n{\n  return re_search_2_stub (bufp, string1, length1, string2, length2,\n\t\t\t   start, 0, regs, stop, 1);\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "re_search_2": {
      "start_point": [
        318,
        0
      ],
      "end_point": [
        325,
        1
      ],
      "content": "int\nre_search_2 (struct re_pattern_buffer *bufp, const char *string1, int length1,\n\t     const char *string2, int length2, int start, int range,\n\t     struct re_registers *regs, int stop)\n{\n  return re_search_2_stub (bufp, string1, length1, string2, length2,\n\t\t\t   start, range, regs, stop, 0);\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "re_search_2_stub": {
      "start_point": [
        330,
        0
      ],
      "end_point": [
        368,
        1
      ],
      "content": "static int\nre_search_2_stub (struct re_pattern_buffer *bufp, const char *string1,\n\t\t  int length1, const char *string2, int length2, int start,\n\t\t  int range, struct re_registers *regs,\n\t\t  int stop, int ret_len)\n{\n  const char *str;\n  int rval;\n  int len = length1 + length2;\n  char *s = NULL;\n\n  if (BE (length1 < 0 || length2 < 0 || stop < 0 || len < length1, 0))\n    return -2;\n\n  /* Concatenate the strings.  */\n  if (length2 > 0)\n    if (length1 > 0)\n      {\n\ts = re_malloc (char, len);\n\n\tif (BE (s == NULL, 0))\n\t  return -2;\n#ifdef _LIBC\n\tmemcpy (__mempcpy (s, string1, length1), string2, length2);\n#else\n\tmemcpy (s, string1, length1);\n\tmemcpy (s + length1, string2, length2);\n#endif\n\tstr = s;\n      }\n    else\n      str = string2;\n  else\n    str = string1;\n\n  rval = re_search_stub (bufp, str, len, start, range, stop, regs, ret_len);\n  re_free (s);\n  return rval;\n}",
      "lines": 39,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "re_search_stub": {
      "start_point": [
        375,
        0
      ],
      "end_point": [
        459,
        1
      ],
      "content": "static int\nre_search_stub (struct re_pattern_buffer *bufp, const char *string, int length,\n\t\tint start, int range, int stop, struct re_registers *regs,\n\t\tint ret_len)\n{\n  reg_errcode_t result;\n  regmatch_t *pmatch;\n  int nregs, rval;\n  int eflags = 0;\n\n  /* Check for out-of-range.  */\n  if (BE (start < 0 || start > length, 0))\n    return -1;\n  if (BE (start + range > length, 0))\n    range = length - start;\n  else if (BE (start + range < 0, 0))\n    range = -start;\n\n  __libc_lock_lock (dfa->lock);\n\n  eflags |= (bufp->not_bol) ? REG_NOTBOL : 0;\n  eflags |= (bufp->not_eol) ? REG_NOTEOL : 0;\n\n  /* Compile fastmap if we haven't yet.  */\n  if (range > 0 && bufp->fastmap != NULL && !bufp->fastmap_accurate)\n    re_compile_fastmap (bufp);\n\n  if (BE (bufp->no_sub, 0))\n    regs = NULL;\n\n  /* We need at least 1 register.  */\n  if (regs == NULL)\n    nregs = 1;\n  else if (BE (bufp->regs_allocated == REGS_FIXED &&\n\t       regs->num_regs < bufp->re_nsub + 1, 0))\n    {\n      nregs = regs->num_regs;\n      if (BE (nregs < 1, 0))\n\t{\n\t  /* Nothing can be copied to regs.  */\n\t  regs = NULL;\n\t  nregs = 1;\n\t}\n    }\n  else\n    nregs = bufp->re_nsub + 1;\n  pmatch = re_malloc (regmatch_t, nregs);\n  if (BE (pmatch == NULL, 0))\n    {\n      rval = -2;\n      goto out;\n    }\n\n  result = re_search_internal (bufp, string, length, start, range, stop,\n\t\t\t       nregs, pmatch, eflags);\n\n  rval = 0;\n\n  /* I hope we needn't fill ther regs with -1's when no match was found.  */\n  if (result != REG_NOERROR)\n    rval = -1;\n  else if (regs != NULL)\n    {\n      /* If caller wants register contents data back, copy them.  */\n      bufp->regs_allocated = re_copy_regs (regs, pmatch, nregs,\n\t\t\t\t\t   bufp->regs_allocated);\n      if (BE (bufp->regs_allocated == REGS_UNALLOCATED, 0))\n\trval = -2;\n    }\n\n  if (BE (rval == 0, 1))\n    {\n      if (ret_len)\n\t{\n\t  assert (pmatch[0].rm_so == start);\n\t  rval = pmatch[0].rm_eo - start;\n\t}\n      else\n\trval = pmatch[0].rm_so;\n    }\n  re_free (pmatch);\n out:\n  __libc_lock_unlock (dfa->lock);\n  return rval;\n}",
      "lines": 85,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "re_copy_regs": {
      "start_point": [
        461,
        0
      ],
      "end_point": [
        524,
        1
      ],
      "content": "static unsigned\nre_copy_regs (struct re_registers *regs, regmatch_t *pmatch, int nregs,\n\t      int regs_allocated)\n{\n  int rval = REGS_REALLOCATE;\n  int i;\n  int need_regs = nregs + 1;\n  /* We need one extra element beyond `num_regs' for the `-1' marker GNU code\n     uses.  */\n\n  /* Have the register data arrays been allocated?  */\n  if (regs_allocated == REGS_UNALLOCATED)\n    { /* No.  So allocate them with malloc.  */\n      regs->start = re_malloc (regoff_t, need_regs);\n      if (BE (regs->start == NULL, 0))\n\treturn REGS_UNALLOCATED;\n      regs->end = re_malloc (regoff_t, need_regs);\n      if (BE (regs->end == NULL, 0))\n\t{\n\t  re_free (regs->start);\n\t  return REGS_UNALLOCATED;\n\t}\n      regs->num_regs = need_regs;\n    }\n  else if (regs_allocated == REGS_REALLOCATE)\n    { /* Yes.  If we need more elements than were already\n\t allocated, reallocate them.  If we need fewer, just\n\t leave it alone.  */\n      if (BE (need_regs > regs->num_regs, 0))\n\t{\n\t  regoff_t *new_start = re_realloc (regs->start, regoff_t, need_regs);\n\t  regoff_t *new_end;\n\t  if (BE (new_start == NULL, 0))\n\t    return REGS_UNALLOCATED;\n\t  new_end = re_realloc (regs->end, regoff_t, need_regs);\n\t  if (BE (new_end == NULL, 0))\n\t    {\n\t      re_free (new_start);\n\t      return REGS_UNALLOCATED;\n\t    }\n\t  regs->start = new_start;\n\t  regs->end = new_end;\n\t  regs->num_regs = need_regs;\n\t}\n    }\n  else\n    {\n      assert (regs_allocated == REGS_FIXED);\n      /* This function may not be called with REGS_FIXED and nregs too big.  */\n      assert (regs->num_regs >= nregs);\n      rval = REGS_FIXED;\n    }\n\n  /* Copy the regs.  */\n  for (i = 0; i < nregs; ++i)\n    {\n      regs->start[i] = pmatch[i].rm_so;\n      regs->end[i] = pmatch[i].rm_eo;\n    }\n  for ( ; i < regs->num_regs; ++i)\n    regs->start[i] = regs->end[i] = -1;\n\n  return rval;\n}",
      "lines": 64,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "unsigned",
        "unsigned"
      ]
    },
    "re_set_registers": {
      "start_point": [
        539,
        0
      ],
      "end_point": [
        556,
        1
      ],
      "content": "void\nre_set_registers (struct re_pattern_buffer *bufp, struct re_registers *regs,\n\t\t  unsigned num_regs, regoff_t *starts, regoff_t *ends)\n{\n  if (num_regs)\n    {\n      bufp->regs_allocated = REGS_REALLOCATE;\n      regs->num_regs = num_regs;\n      regs->start = starts;\n      regs->end = ends;\n    }\n  else\n    {\n      bufp->regs_allocated = REGS_UNALLOCATED;\n      regs->num_regs = 0;\n      regs->start = regs->end = (regoff_t *) 0;\n    }\n}",
      "lines": 18,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "re_exec": {
      "start_point": [
        567,
        0
      ],
      "end_point": [
        572,
        1
      ],
      "content": "weak_function\n# endif\nre_exec (const char *s)\n{\n  return 0 == regexec (&re_comp_buf, s, 0, NULL, 0);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "weak_function",
        "# endif",
        "# endif"
      ]
    },
    "re_search_internal": {
      "start_point": [
        586,
        0
      ],
      "end_point": [
        908,
        1
      ],
      "content": "static reg_errcode_t\n__attribute_warn_unused_result__\nre_search_internal (const regex_t *preg, const char *string, int length,\n\t\t    int start, int range, int stop, size_t nmatch,\n\t\t    regmatch_t pmatch[], int eflags)\n{\n  reg_errcode_t err;\n  const re_dfa_t *dfa = (const re_dfa_t *) preg->buffer;\n  int left_lim, right_lim, incr;\n  int fl_longest_match, match_first, match_kind, match_last = -1;\n  int extra_nmatch;\n  int sb, ch;\n#if defined _LIBC || (defined __STDC_VERSION__ && __STDC_VERSION__ >= 199901L)\n  re_match_context_t mctx = { .dfa = dfa };\n#else\n  re_match_context_t mctx;\n#endif\n  char *fastmap = (preg->fastmap != NULL && preg->fastmap_accurate\n\t\t   && range && !preg->can_be_null) ? preg->fastmap : NULL;\n  RE_TRANSLATE_TYPE t = preg->translate;\n\n#if !(defined _LIBC || (defined __STDC_VERSION__ && __STDC_VERSION__ >= 199901L))\n  memset (&mctx, '\\0', sizeof (re_match_context_t));\n  mctx.dfa = dfa;\n#endif\n\n  extra_nmatch = (nmatch > preg->re_nsub) ? nmatch - (preg->re_nsub + 1) : 0;\n  nmatch -= extra_nmatch;\n\n  /* Check if the DFA haven't been compiled.  */\n  if (BE (preg->used == 0 || dfa == NULL || dfa->init_state == NULL\n\t  || dfa->init_state_word == NULL || dfa->init_state_nl == NULL\n\t  || dfa->init_state_begbuf == NULL, 0))\n    return REG_NOMATCH;\n\n#ifdef DEBUG\n  /* We assume front-end functions already check them.  */\n  assert (start + range >= 0 && start + range <= length);\n#endif\n\n  /* If initial states with non-begbuf contexts have no elements,\n     the regex must be anchored.  If preg->newline_anchor is set,\n     we'll never use init_state_nl, so do not check it.  */\n  if (dfa->init_state->nodes.nelem == 0\n      && dfa->init_state_word->nodes.nelem == 0\n      && (dfa->init_state_nl->nodes.nelem == 0\n\t  || !preg->newline_anchor))\n    {\n      if (start != 0 && start + range != 0)\n\treturn REG_NOMATCH;\n      start = range = 0;\n    }\n\n  /* We must check the longest matching, if nmatch > 0.  */\n  fl_longest_match = (nmatch != 0 || dfa->nbackref);\n\n  err = re_string_allocate (&mctx.input, string, length, dfa->nodes_len + 1,\n\t\t\t    preg->translate, (preg->syntax & RE_ICASE) != 0,\n\t\t\t    dfa);\n  if (BE (err != REG_NOERROR, 0))\n    goto free_return;\n  mctx.input.stop = stop;\n  mctx.input.raw_stop = stop;\n  mctx.input.newline_anchor = preg->newline_anchor;\n\n  err = match_ctx_init (&mctx, eflags, dfa->nbackref * 2);\n  if (BE (err != REG_NOERROR, 0))\n    goto free_return;\n\n  /* We will log all the DFA states through which the dfa pass,\n     if nmatch > 1, or this dfa has \"multibyte node\", which is a\n     back-reference or a node which can accept multibyte character or\n     multi character collating element.  */\n  if (nmatch > 1 || dfa->has_mb_node)\n    {\n      /* Avoid overflow.  */\n      if (BE (SIZE_MAX / sizeof (re_dfastate_t *) <= mctx.input.bufs_len, 0))\n\t{\n\t  err = REG_ESPACE;\n\t  goto free_return;\n\t}\n\n      mctx.state_log = re_malloc (re_dfastate_t *, mctx.input.bufs_len + 1);\n      if (BE (mctx.state_log == NULL, 0))\n\t{\n\t  err = REG_ESPACE;\n\t  goto free_return;\n\t}\n    }\n  else\n    mctx.state_log = NULL;\n\n  match_first = start;\n  mctx.input.tip_context = (eflags & REG_NOTBOL) ? CONTEXT_BEGBUF\n\t\t\t   : CONTEXT_NEWLINE | CONTEXT_BEGBUF;\n\n  /* Check incrementally whether of not the input string match.  */\n  incr = (range < 0) ? -1 : 1;\n  left_lim = (range < 0) ? start + range : start;\n  right_lim = (range < 0) ? start : start + range;\n  sb = dfa->mb_cur_max == 1;\n  match_kind =\n    (fastmap\n     ? ((sb || !(preg->syntax & RE_ICASE || t) ? 4 : 0)\n\t| (range >= 0 ? 2 : 0)\n\t| (t != NULL ? 1 : 0))\n     : 8);\n\n  for (;; match_first += incr)\n    {\n      err = REG_NOMATCH;\n      if (match_first < left_lim || right_lim < match_first)\n\tgoto free_return;\n\n      /* Advance as rapidly as possible through the string, until we\n\t find a plausible place to start matching.  This may be done\n\t with varying efficiency, so there are various possibilities:\n\t only the most common of them are specialized, in order to\n\t save on code size.  We use a switch statement for speed.  */\n      switch (match_kind)\n\t{\n\tcase 8:\n\t  /* No fastmap.  */\n\t  break;\n\n\tcase 7:\n\t  /* Fastmap with single-byte translation, match forward.  */\n\t  while (BE (match_first < right_lim, 1)\n\t\t && !fastmap[t[(unsigned char) string[match_first]]])\n\t    ++match_first;\n\t  goto forward_match_found_start_or_reached_end;\n\n\tcase 6:\n\t  /* Fastmap without translation, match forward.  */\n\t  while (BE (match_first < right_lim, 1)\n\t\t && !fastmap[(unsigned char) string[match_first]])\n\t    ++match_first;\n\n\tforward_match_found_start_or_reached_end:\n\t  if (BE (match_first == right_lim, 0))\n\t    {\n\t      ch = match_first >= length\n\t\t       ? 0 : (unsigned char) string[match_first];\n\t      if (!fastmap[t ? t[ch] : ch])\n\t\tgoto free_return;\n\t    }\n\t  break;\n\n\tcase 4:\n\tcase 5:\n\t  /* Fastmap without multi-byte translation, match backwards.  */\n\t  while (match_first >= left_lim)\n\t    {\n\t      ch = match_first >= length\n\t\t       ? 0 : (unsigned char) string[match_first];\n\t      if (fastmap[t ? t[ch] : ch])\n\t\tbreak;\n\t      --match_first;\n\t    }\n\t  if (match_first < left_lim)\n\t    goto free_return;\n\t  break;\n\n\tdefault:\n\t  /* In this case, we can't determine easily the current byte,\n\t     since it might be a component byte of a multibyte\n\t     character.  Then we use the constructed buffer instead.  */\n\t  for (;;)\n\t    {\n\t      /* If MATCH_FIRST is out of the valid range, reconstruct the\n\t\t buffers.  */\n\t      unsigned int offset = match_first - mctx.input.raw_mbs_idx;\n\t      if (BE (offset >= (unsigned int) mctx.input.valid_raw_len, 0))\n\t\t{\n\t\t  err = re_string_reconstruct (&mctx.input, match_first,\n\t\t\t\t\t       eflags);\n\t\t  if (BE (err != REG_NOERROR, 0))\n\t\t    goto free_return;\n\n\t\t  offset = match_first - mctx.input.raw_mbs_idx;\n\t\t}\n\t      /* If MATCH_FIRST is out of the buffer, leave it as '\\0'.\n\t\t Note that MATCH_FIRST must not be smaller than 0.  */\n\t      ch = (match_first >= length\n\t\t    ? 0 : re_string_byte_at (&mctx.input, offset));\n\t      if (fastmap[ch])\n\t\tbreak;\n\t      match_first += incr;\n\t      if (match_first < left_lim || match_first > right_lim)\n\t\t{\n\t\t  err = REG_NOMATCH;\n\t\t  goto free_return;\n\t\t}\n\t    }\n\t  break;\n\t}\n\n      /* Reconstruct the buffers so that the matcher can assume that\n\t the matching starts from the beginning of the buffer.  */\n      err = re_string_reconstruct (&mctx.input, match_first, eflags);\n      if (BE (err != REG_NOERROR, 0))\n\tgoto free_return;\n\n#ifdef RE_ENABLE_I18N\n     /* Don't consider this char as a possible match start if it part,\n\tyet isn't the head, of a multibyte character.  */\n      if (!sb && !re_string_first_byte (&mctx.input, 0))\n\tcontinue;\n#endif\n\n      /* It seems to be appropriate one, then use the matcher.  */\n      /* We assume that the matching starts from 0.  */\n      mctx.state_log_top = mctx.nbkref_ents = mctx.max_mb_elem_len = 0;\n      match_last = check_matching (&mctx, fl_longest_match,\n\t\t\t\t   range >= 0 ? &match_first : NULL);\n      if (match_last != -1)\n\t{\n\t  if (BE (match_last == -2, 0))\n\t    {\n\t      err = REG_ESPACE;\n\t      goto free_return;\n\t    }\n\t  else\n\t    {\n\t      mctx.match_last = match_last;\n\t      if ((!preg->no_sub && nmatch > 1) || dfa->nbackref)\n\t\t{\n\t\t  re_dfastate_t *pstate = mctx.state_log[match_last];\n\t\t  mctx.last_node = check_halt_state_context (&mctx, pstate,\n\t\t\t\t\t\t\t     match_last);\n\t\t}\n\t      if ((!preg->no_sub && nmatch > 1 && dfa->has_plural_match)\n\t\t  || dfa->nbackref)\n\t\t{\n\t\t  err = prune_impossible_nodes (&mctx);\n\t\t  if (err == REG_NOERROR)\n\t\t    break;\n\t\t  if (BE (err != REG_NOMATCH, 0))\n\t\t    goto free_return;\n\t\t  match_last = -1;\n\t\t}\n\t      else\n\t\tbreak; /* We found a match.  */\n\t    }\n\t}\n\n      match_ctx_clean (&mctx);\n    }\n\n#ifdef DEBUG\n  assert (match_last != -1);\n  assert (err == REG_NOERROR);\n#endif\n\n  /* Set pmatch[] if we need.  */\n  if (nmatch > 0)\n    {\n      int reg_idx;\n\n      /* Initialize registers.  */\n      for (reg_idx = 1; reg_idx < nmatch; ++reg_idx)\n\tpmatch[reg_idx].rm_so = pmatch[reg_idx].rm_eo = -1;\n\n      /* Set the points where matching start/end.  */\n      pmatch[0].rm_so = 0;\n      pmatch[0].rm_eo = mctx.match_last;\n\n      if (!preg->no_sub && nmatch > 1)\n\t{\n\t  err = set_regs (preg, &mctx, nmatch, pmatch,\n\t\t\t  dfa->has_plural_match && dfa->nbackref > 0);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    goto free_return;\n\t}\n\n      /* At last, add the offset to each register, since we slid\n\t the buffers so that we could assume that the matching starts\n\t from 0.  */\n      for (reg_idx = 0; reg_idx < nmatch; ++reg_idx)\n\tif (pmatch[reg_idx].rm_so != -1)\n\t  {\n#ifdef RE_ENABLE_I18N\n\t    if (BE (mctx.input.offsets_needed != 0, 0))\n\t      {\n\t\tpmatch[reg_idx].rm_so =\n\t\t  (pmatch[reg_idx].rm_so == mctx.input.valid_len\n\t\t   ? mctx.input.valid_raw_len\n\t\t   : mctx.input.offsets[pmatch[reg_idx].rm_so]);\n\t\tpmatch[reg_idx].rm_eo =\n\t\t  (pmatch[reg_idx].rm_eo == mctx.input.valid_len\n\t\t   ? mctx.input.valid_raw_len\n\t\t   : mctx.input.offsets[pmatch[reg_idx].rm_eo]);\n\t      }\n#else\n\t    assert (mctx.input.offsets_needed == 0);\n#endif\n\t    pmatch[reg_idx].rm_so += match_first;\n\t    pmatch[reg_idx].rm_eo += match_first;\n\t  }\n      for (reg_idx = 0; reg_idx < extra_nmatch; ++reg_idx)\n\t{\n\t  pmatch[nmatch + reg_idx].rm_so = -1;\n\t  pmatch[nmatch + reg_idx].rm_eo = -1;\n\t}\n\n      if (dfa->subexp_map)\n\tfor (reg_idx = 0; reg_idx + 1 < nmatch; reg_idx++)\n\t  if (dfa->subexp_map[reg_idx] != reg_idx)\n\t    {\n\t      pmatch[reg_idx + 1].rm_so\n\t\t= pmatch[dfa->subexp_map[reg_idx] + 1].rm_so;\n\t      pmatch[reg_idx + 1].rm_eo\n\t\t= pmatch[dfa->subexp_map[reg_idx] + 1].rm_eo;\n\t    }\n    }\n\n free_return:\n  re_free (mctx.state_log);\n  if (dfa->nbackref)\n    match_ctx_free (&mctx);\n  re_string_destruct (&mctx.input);\n  return err;\n}",
      "lines": 323,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "__attribute_warn_unused_result__",
        "__attribute_warn_unused_result__"
      ]
    },
    "prune_impossible_nodes": {
      "start_point": [
        910,
        0
      ],
      "end_point": [
        1000,
        1
      ],
      "content": "static reg_errcode_t\n__attribute_warn_unused_result__\nprune_impossible_nodes (re_match_context_t *mctx)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  int halt_node, match_last;\n  reg_errcode_t ret;\n  re_dfastate_t **sifted_states;\n  re_dfastate_t **lim_states = NULL;\n  re_sift_context_t sctx;\n#ifdef DEBUG\n  assert (mctx->state_log != NULL);\n#endif\n  match_last = mctx->match_last;\n  halt_node = mctx->last_node;\n\n  /* Avoid overflow.  */\n  if (BE (SIZE_MAX / sizeof (re_dfastate_t *) <= match_last, 0))\n    return REG_ESPACE;\n\n  sifted_states = re_malloc (re_dfastate_t *, match_last + 1);\n  if (BE (sifted_states == NULL, 0))\n    {\n      ret = REG_ESPACE;\n      goto free_return;\n    }\n  if (dfa->nbackref)\n    {\n      lim_states = re_malloc (re_dfastate_t *, match_last + 1);\n      if (BE (lim_states == NULL, 0))\n\t{\n\t  ret = REG_ESPACE;\n\t  goto free_return;\n\t}\n      while (1)\n\t{\n\t  memset (lim_states, '\\0',\n\t\t  sizeof (re_dfastate_t *) * (match_last + 1));\n\t  sift_ctx_init (&sctx, sifted_states, lim_states, halt_node,\n\t\t\t match_last);\n\t  ret = sift_states_backward (mctx, &sctx);\n\t  re_node_set_free (&sctx.limits);\n\t  if (BE (ret != REG_NOERROR, 0))\n\t      goto free_return;\n\t  if (sifted_states[0] != NULL || lim_states[0] != NULL)\n\t    break;\n\t  do\n\t    {\n\t      --match_last;\n\t      if (match_last < 0)\n\t\t{\n\t\t  ret = REG_NOMATCH;\n\t\t  goto free_return;\n\t\t}\n\t    } while (mctx->state_log[match_last] == NULL\n\t\t     || !mctx->state_log[match_last]->halt);\n\t  halt_node = check_halt_state_context (mctx,\n\t\t\t\t\t\tmctx->state_log[match_last],\n\t\t\t\t\t\tmatch_last);\n\t}\n      ret = merge_state_array (dfa, sifted_states, lim_states,\n\t\t\t       match_last + 1);\n      re_free (lim_states);\n      lim_states = NULL;\n      if (BE (ret != REG_NOERROR, 0))\n\tgoto free_return;\n    }\n  else\n    {\n      sift_ctx_init (&sctx, sifted_states, lim_states, halt_node, match_last);\n      ret = sift_states_backward (mctx, &sctx);\n      re_node_set_free (&sctx.limits);\n      if (BE (ret != REG_NOERROR, 0))\n\tgoto free_return;\n      if (sifted_states[0] == NULL)\n\t{\n\t  ret = REG_NOMATCH;\n\t  goto free_return;\n\t}\n    }\n  re_free (mctx->state_log);\n  mctx->state_log = sifted_states;\n  sifted_states = NULL;\n  mctx->last_node = halt_node;\n  mctx->match_last = match_last;\n  ret = REG_NOERROR;\n free_return:\n  re_free (sifted_states);\n  re_free (lim_states);\n  return ret;\n}",
      "lines": 91,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "__attribute_warn_unused_result__",
        "__attribute_warn_unused_result__"
      ]
    },
    "check_matching": {
      "start_point": [
        1048,
        0
      ],
      "end_point": [
        1177,
        1
      ],
      "content": "static int\n__attribute_warn_unused_result__\ncheck_matching (re_match_context_t *mctx, int fl_longest_match,\n\t\tint *p_match_first)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  reg_errcode_t err;\n  int match = 0;\n  int match_last = -1;\n  int cur_str_idx = re_string_cur_idx (&mctx->input);\n  re_dfastate_t *cur_state;\n  int at_init_state = p_match_first != NULL;\n  int next_start_idx = cur_str_idx;\n\n  err = REG_NOERROR;\n  cur_state = acquire_init_state_context (&err, mctx, cur_str_idx);\n  /* An initial state must not be NULL (invalid).  */\n  if (BE (cur_state == NULL, 0))\n    {\n      assert (err == REG_ESPACE);\n      return -2;\n    }\n\n  if (mctx->state_log != NULL)\n    {\n      mctx->state_log[cur_str_idx] = cur_state;\n\n      /* Check OP_OPEN_SUBEXP in the initial state in case that we use them\n\t later.  E.g. Processing back references.  */\n      if (BE (dfa->nbackref, 0))\n\t{\n\t  at_init_state = 0;\n\t  err = check_subexp_matching_top (mctx, &cur_state->nodes, 0);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return err;\n\n\t  if (cur_state->has_backref)\n\t    {\n\t      err = transit_state_bkref (mctx, &cur_state->nodes);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\treturn err;\n\t    }\n\t}\n    }\n\n  /* If the RE accepts NULL string.  */\n  if (BE (cur_state->halt, 0))\n    {\n      if (!cur_state->has_constraint\n\t  || check_halt_state_context (mctx, cur_state, cur_str_idx))\n\t{\n\t  if (!fl_longest_match)\n\t    return cur_str_idx;\n\t  else\n\t    {\n\t      match_last = cur_str_idx;\n\t      match = 1;\n\t    }\n\t}\n    }\n\n  while (!re_string_eoi (&mctx->input))\n    {\n      re_dfastate_t *old_state = cur_state;\n      int next_char_idx = re_string_cur_idx (&mctx->input) + 1;\n\n      if ((BE (next_char_idx >= mctx->input.bufs_len, 0)\n\t   && mctx->input.bufs_len < mctx->input.len)\n\t  || (BE (next_char_idx >= mctx->input.valid_len, 0)\n\t      && mctx->input.valid_len < mctx->input.len))\n\t{\n\t  err = extend_buffers (mctx, next_char_idx + 1);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    {\n\t      assert (err == REG_ESPACE);\n\t      return -2;\n\t    }\n\t}\n\n      cur_state = transit_state (&err, mctx, cur_state);\n      if (mctx->state_log != NULL)\n\tcur_state = merge_state_with_log (&err, mctx, cur_state);\n\n      if (cur_state == NULL)\n\t{\n\t  /* Reached the invalid state or an error.  Try to recover a valid\n\t     state using the state log, if available and if we have not\n\t     already found a valid (even if not the longest) match.  */\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return -2;\n\n\t  if (mctx->state_log == NULL\n\t      || (match && !fl_longest_match)\n\t      || (cur_state = find_recover_state (&err, mctx)) == NULL)\n\t    break;\n\t}\n\n      if (BE (at_init_state, 0))\n\t{\n\t  if (old_state == cur_state)\n\t    next_start_idx = next_char_idx;\n\t  else\n\t    at_init_state = 0;\n\t}\n\n      if (cur_state->halt)\n\t{\n\t  /* Reached a halt state.\n\t     Check the halt state can satisfy the current context.  */\n\t  if (!cur_state->has_constraint\n\t      || check_halt_state_context (mctx, cur_state,\n\t\t\t\t\t   re_string_cur_idx (&mctx->input)))\n\t    {\n\t      /* We found an appropriate halt state.  */\n\t      match_last = re_string_cur_idx (&mctx->input);\n\t      match = 1;\n\n\t      /* We found a match, do not modify match_first below.  */\n\t      p_match_first = NULL;\n\t      if (!fl_longest_match)\n\t\tbreak;\n\t    }\n\t}\n    }\n\n  if (p_match_first)\n    *p_match_first += next_start_idx;\n\n  return match_last;\n}",
      "lines": 130,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int",
        "__attribute_warn_unused_result__",
        "__attribute_warn_unused_result__"
      ]
    },
    "check_halt_node_context": {
      "start_point": [
        1181,
        0
      ],
      "end_point": [
        1193,
        1
      ],
      "content": "static int\ncheck_halt_node_context (const re_dfa_t *dfa, int node, unsigned int context)\n{\n  re_token_type_t type = dfa->nodes[node].type;\n  unsigned int constraint = dfa->nodes[node].constraint;\n  if (type != END_OF_RE)\n    return 0;\n  if (!constraint)\n    return 1;\n  if (NOT_SATISFY_NEXT_CONSTRAINT (constraint, context))\n    return 0;\n  return 1;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "check_halt_state_context": {
      "start_point": [
        1199,
        0
      ],
      "end_point": [
        1213,
        1
      ],
      "content": "static int\ncheck_halt_state_context (const re_match_context_t *mctx,\n\t\t\t  const re_dfastate_t *state, int idx)\n{\n  int i;\n  unsigned int context;\n#ifdef DEBUG\n  assert (state->halt);\n#endif\n  context = re_string_context_at (&mctx->input, idx, mctx->eflags);\n  for (i = 0; i < state->nodes.nelem; ++i)\n    if (check_halt_node_context (mctx->dfa, state->nodes.elems[i], context))\n      return state->nodes.elems[i];\n  return 0;\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "proceed_next_node": {
      "start_point": [
        1220,
        0
      ],
      "end_point": [
        1317,
        1
      ],
      "content": "static int\nproceed_next_node (const re_match_context_t *mctx, int nregs, regmatch_t *regs,\n\t\t   int *pidx, int node, re_node_set *eps_via_nodes,\n\t\t   struct re_fail_stack_t *fs)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  int i, err;\n  if (IS_EPSILON_NODE (dfa->nodes[node].type))\n    {\n      re_node_set *cur_nodes = &mctx->state_log[*pidx]->nodes;\n      re_node_set *edests = &dfa->edests[node];\n      int dest_node;\n      err = re_node_set_insert (eps_via_nodes, node);\n      if (BE (err < 0, 0))\n\treturn -2;\n      /* Pick up a valid destination, or return -1 if none is found.  */\n      for (dest_node = -1, i = 0; i < edests->nelem; ++i)\n\t{\n\t  int candidate = edests->elems[i];\n\t  if (!re_node_set_contains (cur_nodes, candidate))\n\t    continue;\n\t  if (dest_node == -1)\n\t    dest_node = candidate;\n\n\t  else\n\t    {\n\t      /* In order to avoid infinite loop like \"(a*)*\", return the second\n\t\t epsilon-transition if the first was already considered.  */\n\t      if (re_node_set_contains (eps_via_nodes, dest_node))\n\t\treturn candidate;\n\n\t      /* Otherwise, push the second epsilon-transition on the fail stack.  */\n\t      else if (fs != NULL\n\t\t       && push_fail_stack (fs, *pidx, candidate, nregs, regs,\n\t\t\t\t\t   eps_via_nodes))\n\t\treturn -2;\n\n\t      /* We know we are going to exit.  */\n\t      break;\n\t    }\n\t}\n      return dest_node;\n    }\n  else\n    {\n      int naccepted = 0;\n      re_token_type_t type = dfa->nodes[node].type;\n\n#ifdef RE_ENABLE_I18N\n      if (dfa->nodes[node].accept_mb)\n\tnaccepted = check_node_accept_bytes (dfa, node, &mctx->input, *pidx);\n      else\n#endif /* RE_ENABLE_I18N */\n      if (type == OP_BACK_REF)\n\t{\n\t  int subexp_idx = dfa->nodes[node].opr.idx + 1;\n\t  naccepted = regs[subexp_idx].rm_eo - regs[subexp_idx].rm_so;\n\t  if (fs != NULL)\n\t    {\n\t      if (regs[subexp_idx].rm_so == -1 || regs[subexp_idx].rm_eo == -1)\n\t\treturn -1;\n\t      else if (naccepted)\n\t\t{\n\t\t  char *buf = (char *) re_string_get_buffer (&mctx->input);\n\t\t  if (memcmp (buf + regs[subexp_idx].rm_so, buf + *pidx,\n\t\t\t      naccepted) != 0)\n\t\t    return -1;\n\t\t}\n\t    }\n\n\t  if (naccepted == 0)\n\t    {\n\t      int dest_node;\n\t      err = re_node_set_insert (eps_via_nodes, node);\n\t      if (BE (err < 0, 0))\n\t\treturn -2;\n\t      dest_node = dfa->edests[node].elems[0];\n\t      if (re_node_set_contains (&mctx->state_log[*pidx]->nodes,\n\t\t\t\t\tdest_node))\n\t\treturn dest_node;\n\t    }\n\t}\n\n      if (naccepted != 0\n\t  || check_node_accept (mctx, dfa->nodes + node, *pidx))\n\t{\n\t  int dest_node = dfa->nexts[node];\n\t  *pidx = (naccepted == 0) ? *pidx + 1 : *pidx + naccepted;\n\t  if (fs && (*pidx > mctx->match_last || mctx->state_log[*pidx] == NULL\n\t\t     || !re_node_set_contains (&mctx->state_log[*pidx]->nodes,\n\t\t\t\t\t       dest_node)))\n\t    return -1;\n\t  re_node_set_empty (eps_via_nodes);\n\t  return dest_node;\n\t}\n    }\n  return -1;\n}",
      "lines": 98,
      "depth": 20,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "push_fail_stack": {
      "start_point": [
        1319,
        0
      ],
      "end_point": [
        1344,
        1
      ],
      "content": "static reg_errcode_t\n__attribute_warn_unused_result__\npush_fail_stack (struct re_fail_stack_t *fs, int str_idx, int dest_node,\n\t\t int nregs, regmatch_t *regs, re_node_set *eps_via_nodes)\n{\n  reg_errcode_t err;\n  int num = fs->num++;\n  if (fs->num == fs->alloc)\n    {\n      struct re_fail_stack_ent_t *new_array;\n      new_array = re_realloc (fs->stack, struct re_fail_stack_ent_t,\n                              fs->alloc * 2);\n      if (new_array == NULL)\n\treturn REG_ESPACE;\n      fs->alloc *= 2;\n      fs->stack = new_array;\n    }\n  fs->stack[num].idx = str_idx;\n  fs->stack[num].node = dest_node;\n  fs->stack[num].regs = re_malloc (regmatch_t, nregs);\n  if (fs->stack[num].regs == NULL)\n    return REG_ESPACE;\n  memcpy (fs->stack[num].regs, regs, sizeof (regmatch_t) * nregs);\n  err = re_node_set_init_copy (&fs->stack[num].eps_via_nodes, eps_via_nodes);\n  return err;\n}",
      "lines": 26,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "__attribute_warn_unused_result__",
        "__attribute_warn_unused_result__"
      ]
    },
    "pop_fail_stack": {
      "start_point": [
        1346,
        0
      ],
      "end_point": [
        1358,
        1
      ],
      "content": "static int\npop_fail_stack (struct re_fail_stack_t *fs, int *pidx, int nregs,\n\t\tregmatch_t *regs, re_node_set *eps_via_nodes)\n{\n  int num = --fs->num;\n  assert (num >= 0);\n  *pidx = fs->stack[num].idx;\n  memcpy (regs, fs->stack[num].regs, sizeof (regmatch_t) * nregs);\n  re_node_set_free (eps_via_nodes);\n  re_free (fs->stack[num].regs);\n  *eps_via_nodes = fs->stack[num].eps_via_nodes;\n  return fs->stack[num].node;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "__attribute_warn_unused_result__": [
      {
        "start_point": [
          1365,
          0
        ],
        "end_point": [
          1472,
          1
        ],
        "content": "static reg_errcode_t\n__attribute_warn_unused_result__\nset_regs (const regex_t *preg, const re_match_context_t *mctx, size_t nmatch,\n\t  regmatch_t *pmatch, int fl_backtrack)\n{\n  const re_dfa_t *dfa = (const re_dfa_t *) preg->buffer;\n  int idx, cur_node;\n  re_node_set eps_via_nodes;\n  struct re_fail_stack_t *fs;\n  struct re_fail_stack_t fs_body = { 0, 2, NULL };\n  regmatch_t *prev_idx_match;\n  int prev_idx_match_malloced = 0;\n\n#ifdef DEBUG\n  assert (nmatch > 1);\n  assert (mctx->state_log != NULL);\n#endif\n  if (fl_backtrack)\n    {\n      fs = &fs_body;\n      fs->stack = re_malloc (struct re_fail_stack_ent_t, fs->alloc);\n      if (fs->stack == NULL)\n\treturn REG_ESPACE;\n    }\n  else\n    fs = NULL;\n\n  cur_node = dfa->init_node;\n  re_node_set_init_empty (&eps_via_nodes);\n\n#ifdef HAVE_ALLOCA\n  if (__libc_use_alloca (nmatch * sizeof (regmatch_t)))\n    prev_idx_match = (regmatch_t *) alloca (nmatch * sizeof (regmatch_t));\n  else\n#endif\n    {\n      prev_idx_match = re_malloc (regmatch_t, nmatch);\n      if (prev_idx_match == NULL)\n\t{\n\t  free_fail_stack_return (fs);\n\t  return REG_ESPACE;\n\t}\n      prev_idx_match_malloced = 1;\n    }\n  memcpy (prev_idx_match, pmatch, sizeof (regmatch_t) * nmatch);\n\n  for (idx = pmatch[0].rm_so; idx <= pmatch[0].rm_eo ;)\n    {\n      update_regs (dfa, pmatch, prev_idx_match, cur_node, idx, nmatch);\n\n      if (idx == pmatch[0].rm_eo && cur_node == mctx->last_node)\n\t{\n\t  int reg_idx;\n\t  if (fs)\n\t    {\n\t      for (reg_idx = 0; reg_idx < nmatch; ++reg_idx)\n\t\tif (pmatch[reg_idx].rm_so > -1 && pmatch[reg_idx].rm_eo == -1)\n\t\t  break;\n\t      if (reg_idx == nmatch)\n\t\t{\n\t\t  re_node_set_free (&eps_via_nodes);\n\t\t  if (prev_idx_match_malloced)\n\t\t    re_free (prev_idx_match);\n\t\t  return free_fail_stack_return (fs);\n\t\t}\n\t      cur_node = pop_fail_stack (fs, &idx, nmatch, pmatch,\n\t\t\t\t\t &eps_via_nodes);\n\t    }\n\t  else\n\t    {\n\t      re_node_set_free (&eps_via_nodes);\n\t      if (prev_idx_match_malloced)\n\t\tre_free (prev_idx_match);\n\t      return REG_NOERROR;\n\t    }\n\t}\n\n      /* Proceed to next node.  */\n      cur_node = proceed_next_node (mctx, nmatch, pmatch, &idx, cur_node,\n\t\t\t\t    &eps_via_nodes, fs);\n\n      if (BE (cur_node < 0, 0))\n\t{\n\t  if (BE (cur_node == -2, 0))\n\t    {\n\t      re_node_set_free (&eps_via_nodes);\n\t      if (prev_idx_match_malloced)\n\t\tre_free (prev_idx_match);\n\t      free_fail_stack_return (fs);\n\t      return REG_ESPACE;\n\t    }\n\t  if (fs)\n\t    cur_node = pop_fail_stack (fs, &idx, nmatch, pmatch,\n\t\t\t\t       &eps_via_nodes);\n\t  else\n\t    {\n\t      re_node_set_free (&eps_via_nodes);\n\t      if (prev_idx_match_malloced)\n\t\tre_free (prev_idx_match);\n\t      return REG_NOMATCH;\n\t    }\n\t}\n    }\n  re_node_set_free (&eps_via_nodes);\n  if (prev_idx_match_malloced)\n    re_free (prev_idx_match);\n  return free_fail_stack_return (fs);\n}",
        "lines": 108,
        "depth": 16,
        "decorators": [
          "static",
          "static",
          "reg_errcode_t"
        ]
      },
      {
        "start_point": [
          2635,
          0
        ],
        "end_point": [
          2776,
          1
        ],
        "content": "static reg_errcode_t\n__attribute_warn_unused_result__\nget_subexp (re_match_context_t *mctx, int bkref_node, int bkref_str_idx)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  int subexp_num, sub_top_idx;\n  const char *buf = (const char *) re_string_get_buffer (&mctx->input);\n  /* Return if we have already checked BKREF_NODE at BKREF_STR_IDX.  */\n  int cache_idx = search_cur_bkref_entry (mctx, bkref_str_idx);\n  if (cache_idx != -1)\n    {\n      const struct re_backref_cache_entry *entry\n\t= mctx->bkref_ents + cache_idx;\n      do\n\tif (entry->node == bkref_node)\n\t  return REG_NOERROR; /* We already checked it.  */\n      while (entry++->more);\n    }\n\n  subexp_num = dfa->nodes[bkref_node].opr.idx;\n\n  /* For each sub expression  */\n  for (sub_top_idx = 0; sub_top_idx < mctx->nsub_tops; ++sub_top_idx)\n    {\n      reg_errcode_t err;\n      re_sub_match_top_t *sub_top = mctx->sub_tops[sub_top_idx];\n      re_sub_match_last_t *sub_last;\n      int sub_last_idx, sl_str, bkref_str_off;\n\n      if (dfa->nodes[sub_top->node].opr.idx != subexp_num)\n\tcontinue; /* It isn't related.  */\n\n      sl_str = sub_top->str_idx;\n      bkref_str_off = bkref_str_idx;\n      /* At first, check the last node of sub expressions we already\n\t evaluated.  */\n      for (sub_last_idx = 0; sub_last_idx < sub_top->nlasts; ++sub_last_idx)\n\t{\n\t  int sl_str_diff;\n\t  sub_last = sub_top->lasts[sub_last_idx];\n\t  sl_str_diff = sub_last->str_idx - sl_str;\n\t  /* The matched string by the sub expression match with the substring\n\t     at the back reference?  */\n\t  if (sl_str_diff > 0)\n\t    {\n\t      if (BE (bkref_str_off + sl_str_diff > mctx->input.valid_len, 0))\n\t\t{\n\t\t  /* Not enough chars for a successful match.  */\n\t\t  if (bkref_str_off + sl_str_diff > mctx->input.len)\n\t\t    break;\n\n\t\t  err = clean_state_log_if_needed (mctx,\n\t\t\t\t\t\t   bkref_str_off\n\t\t\t\t\t\t   + sl_str_diff);\n\t\t  if (BE (err != REG_NOERROR, 0))\n\t\t    return err;\n\t\t  buf = (const char *) re_string_get_buffer (&mctx->input);\n\t\t}\n\t      if (memcmp (buf + bkref_str_off, buf + sl_str, sl_str_diff) != 0)\n\t\t/* We don't need to search this sub expression any more.  */\n\t\tbreak;\n\t    }\n\t  bkref_str_off += sl_str_diff;\n\t  sl_str += sl_str_diff;\n\t  err = get_subexp_sub (mctx, sub_top, sub_last, bkref_node,\n\t\t\t\tbkref_str_idx);\n\n\t  /* Reload buf, since the preceding call might have reallocated\n\t     the buffer.  */\n\t  buf = (const char *) re_string_get_buffer (&mctx->input);\n\n\t  if (err == REG_NOMATCH)\n\t    continue;\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return err;\n\t}\n\n      if (sub_last_idx < sub_top->nlasts)\n\tcontinue;\n      if (sub_last_idx > 0)\n\t++sl_str;\n      /* Then, search for the other last nodes of the sub expression.  */\n      for (; sl_str <= bkref_str_idx; ++sl_str)\n\t{\n\t  int cls_node, sl_str_off;\n\t  const re_node_set *nodes;\n\t  sl_str_off = sl_str - sub_top->str_idx;\n\t  /* The matched string by the sub expression match with the substring\n\t     at the back reference?  */\n\t  if (sl_str_off > 0)\n\t    {\n\t      if (BE (bkref_str_off >= mctx->input.valid_len, 0))\n\t\t{\n\t\t  /* If we are at the end of the input, we cannot match.  */\n\t\t  if (bkref_str_off >= mctx->input.len)\n\t\t    break;\n\n\t\t  err = extend_buffers (mctx, bkref_str_off + 1);\n\t\t  if (BE (err != REG_NOERROR, 0))\n\t\t    return err;\n\n\t\t  buf = (const char *) re_string_get_buffer (&mctx->input);\n\t\t}\n\t      if (buf [bkref_str_off++] != buf[sl_str - 1])\n\t\tbreak; /* We don't need to search this sub expression\n\t\t\t  any more.  */\n\t    }\n\t  if (mctx->state_log[sl_str] == NULL)\n\t    continue;\n\t  /* Does this state have a ')' of the sub expression?  */\n\t  nodes = &mctx->state_log[sl_str]->nodes;\n\t  cls_node = find_subexp_node (dfa, nodes, subexp_num,\n\t\t\t\t       OP_CLOSE_SUBEXP);\n\t  if (cls_node == -1)\n\t    continue; /* No.  */\n\t  if (sub_top->path == NULL)\n\t    {\n\t      sub_top->path = calloc (sizeof (state_array_t),\n\t\t\t\t      sl_str - sub_top->str_idx + 1);\n\t      if (sub_top->path == NULL)\n\t\treturn REG_ESPACE;\n\t    }\n\t  /* Can the OP_OPEN_SUBEXP node arrive the OP_CLOSE_SUBEXP node\n\t     in the current context?  */\n\t  err = check_arrival (mctx, sub_top->path, sub_top->node,\n\t\t\t       sub_top->str_idx, cls_node, sl_str,\n\t\t\t       OP_CLOSE_SUBEXP);\n\t  if (err == REG_NOMATCH)\n\t      continue;\n\t  if (BE (err != REG_NOERROR, 0))\n\t      return err;\n\t  sub_last = match_ctx_add_sublast (sub_top, cls_node, sl_str);\n\t  if (BE (sub_last == NULL, 0))\n\t    return REG_ESPACE;\n\t  err = get_subexp_sub (mctx, sub_top, sub_last, bkref_node,\n\t\t\t\tbkref_str_idx);\n\t  if (err == REG_NOMATCH)\n\t    continue;\n\t}\n    }\n  return REG_NOERROR;\n}",
        "lines": 142,
        "depth": 18,
        "decorators": [
          "static",
          "static",
          "reg_errcode_t"
        ]
      }
    ],
    "free_fail_stack_return": {
      "start_point": [
        1474,
        0
      ],
      "end_point": [
        1488,
        1
      ],
      "content": "static reg_errcode_t\nfree_fail_stack_return (struct re_fail_stack_t *fs)\n{\n  if (fs)\n    {\n      int fs_idx;\n      for (fs_idx = 0; fs_idx < fs->num; ++fs_idx)\n\t{\n\t  re_node_set_free (&fs->stack[fs_idx].eps_via_nodes);\n\t  re_free (fs->stack[fs_idx].regs);\n\t}\n      re_free (fs->stack);\n    }\n  return REG_NOERROR;\n}",
      "lines": 15,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "update_regs": {
      "start_point": [
        1490,
        0
      ],
      "end_point": [
        1536,
        1
      ],
      "content": "static void\nupdate_regs (const re_dfa_t *dfa, regmatch_t *pmatch,\n\t     regmatch_t *prev_idx_match, int cur_node, int cur_idx, int nmatch)\n{\n  int type = dfa->nodes[cur_node].type;\n  if (type == OP_OPEN_SUBEXP)\n    {\n      int reg_num = dfa->nodes[cur_node].opr.idx + 1;\n\n      /* We are at the first node of this sub expression.  */\n      if (reg_num < nmatch)\n\t{\n\t  pmatch[reg_num].rm_so = cur_idx;\n\t  pmatch[reg_num].rm_eo = -1;\n\t}\n    }\n  else if (type == OP_CLOSE_SUBEXP)\n    {\n      int reg_num = dfa->nodes[cur_node].opr.idx + 1;\n      if (reg_num < nmatch)\n\t{\n\t  /* We are at the last node of this sub expression.  */\n\t  if (pmatch[reg_num].rm_so < cur_idx)\n\t    {\n\t      pmatch[reg_num].rm_eo = cur_idx;\n\t      /* This is a non-empty match or we are not inside an optional\n\t\t subexpression.  Accept this right away.  */\n\t      memcpy (prev_idx_match, pmatch, sizeof (regmatch_t) * nmatch);\n\t    }\n\t  else\n\t    {\n\t      if (dfa->nodes[cur_node].opt_subexp\n\t\t  && prev_idx_match[reg_num].rm_so != -1)\n\t\t/* We transited through an empty match for an optional\n\t\t   subexpression, like (a?)*, and this is not the subexp's\n\t\t   first match.  Copy back the old content of the registers\n\t\t   so that matches of an inner subexpression are undone as\n\t\t   well, like in ((a?))*.  */\n\t\tmemcpy (pmatch, prev_idx_match, sizeof (regmatch_t) * nmatch);\n\t      else\n\t\t/* We completed a subexpression, but it may be part of\n\t\t   an optional one, so do not update PREV_IDX_MATCH.  */\n\t\tpmatch[reg_num].rm_eo = cur_idx;\n\t    }\n\t}\n    }\n}",
      "lines": 47,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "sift_states_backward": {
      "start_point": [
        1561,
        0
      ],
      "end_point": [
        1616,
        1
      ],
      "content": "static reg_errcode_t\nsift_states_backward (const re_match_context_t *mctx, re_sift_context_t *sctx)\n{\n  reg_errcode_t err;\n  int null_cnt = 0;\n  int str_idx = sctx->last_str_idx;\n  re_node_set cur_dest;\n\n#ifdef DEBUG\n  assert (mctx->state_log != NULL && mctx->state_log[str_idx] != NULL);\n#endif\n\n  /* Build sifted state_log[str_idx].  It has the nodes which can epsilon\n     transit to the last_node and the last_node itself.  */\n  err = re_node_set_init_1 (&cur_dest, sctx->last_node);\n  if (BE (err != REG_NOERROR, 0))\n    return err;\n  err = update_cur_sifted_state (mctx, sctx, str_idx, &cur_dest);\n  if (BE (err != REG_NOERROR, 0))\n    goto free_return;\n\n  /* Then check each states in the state_log.  */\n  while (str_idx > 0)\n    {\n      /* Update counters.  */\n      null_cnt = (sctx->sifted_states[str_idx] == NULL) ? null_cnt + 1 : 0;\n      if (null_cnt > mctx->max_mb_elem_len)\n\t{\n\t  memset (sctx->sifted_states, '\\0',\n\t\t  sizeof (re_dfastate_t *) * str_idx);\n\t  re_node_set_free (&cur_dest);\n\t  return REG_NOERROR;\n\t}\n      re_node_set_empty (&cur_dest);\n      --str_idx;\n\n      if (mctx->state_log[str_idx])\n\t{\n\t  err = build_sifted_states (mctx, sctx, str_idx, &cur_dest);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    goto free_return;\n\t}\n\n      /* Add all the nodes which satisfy the following conditions:\n\t - It can epsilon transit to a node in CUR_DEST.\n\t - It is in CUR_SRC.\n\t And update state_log.  */\n      err = update_cur_sifted_state (mctx, sctx, str_idx, &cur_dest);\n      if (BE (err != REG_NOERROR, 0))\n\tgoto free_return;\n    }\n  err = REG_NOERROR;\n free_return:\n  re_node_set_free (&cur_dest);\n  return err;\n}",
      "lines": 56,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "build_sifted_states": {
      "start_point": [
        1618,
        0
      ],
      "end_point": [
        1676,
        1
      ],
      "content": "static reg_errcode_t\n__attribute_warn_unused_result__\nbuild_sifted_states (const re_match_context_t *mctx, re_sift_context_t *sctx,\n\t\t     int str_idx, re_node_set *cur_dest)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  const re_node_set *cur_src = &mctx->state_log[str_idx]->non_eps_nodes;\n  int i;\n\n  /* Then build the next sifted state.\n     We build the next sifted state on `cur_dest', and update\n     `sifted_states[str_idx]' with `cur_dest'.\n     Note:\n     `cur_dest' is the sifted state from `state_log[str_idx + 1]'.\n     `cur_src' points the node_set of the old `state_log[str_idx]'\n     (with the epsilon nodes pre-filtered out).  */\n  for (i = 0; i < cur_src->nelem; i++)\n    {\n      int prev_node = cur_src->elems[i];\n      int naccepted = 0;\n      int ret;\n\n#ifdef DEBUG\n      re_token_type_t type = dfa->nodes[prev_node].type;\n      assert (!IS_EPSILON_NODE (type));\n#endif\n#ifdef RE_ENABLE_I18N\n      /* If the node may accept `multi byte'.  */\n      if (dfa->nodes[prev_node].accept_mb)\n\tnaccepted = sift_states_iter_mb (mctx, sctx, prev_node,\n\t\t\t\t\t str_idx, sctx->last_str_idx);\n#endif /* RE_ENABLE_I18N */\n\n      /* We don't check backreferences here.\n\t See update_cur_sifted_state().  */\n      if (!naccepted\n\t  && check_node_accept (mctx, dfa->nodes + prev_node, str_idx)\n\t  && STATE_NODE_CONTAINS (sctx->sifted_states[str_idx + 1],\n\t\t\t\t  dfa->nexts[prev_node]))\n\tnaccepted = 1;\n\n      if (naccepted == 0)\n\tcontinue;\n\n      if (sctx->limits.nelem)\n\t{\n\t  int to_idx = str_idx + naccepted;\n\t  if (check_dst_limits (mctx, &sctx->limits,\n\t\t\t\tdfa->nexts[prev_node], to_idx,\n\t\t\t\tprev_node, str_idx))\n\t    continue;\n\t}\n      ret = re_node_set_insert (cur_dest, prev_node);\n      if (BE (ret == -1, 0))\n\treturn REG_ESPACE;\n    }\n\n  return REG_NOERROR;\n}",
      "lines": 59,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "__attribute_warn_unused_result__",
        "__attribute_warn_unused_result__"
      ]
    },
    "clean_state_log_if_needed": {
      "start_point": [
        1680,
        0
      ],
      "end_point": [
        1703,
        1
      ],
      "content": "static reg_errcode_t\nclean_state_log_if_needed (re_match_context_t *mctx, int next_state_log_idx)\n{\n  int top = mctx->state_log_top;\n\n  if ((next_state_log_idx >= mctx->input.bufs_len\n       && mctx->input.bufs_len < mctx->input.len)\n      || (next_state_log_idx >= mctx->input.valid_len\n\t  && mctx->input.valid_len < mctx->input.len))\n    {\n      reg_errcode_t err;\n      err = extend_buffers (mctx, next_state_log_idx + 1);\n      if (BE (err != REG_NOERROR, 0))\n\treturn err;\n    }\n\n  if (top < next_state_log_idx)\n    {\n      memset (mctx->state_log + top + 1, '\\0',\n\t      sizeof (re_dfastate_t *) * (next_state_log_idx - top));\n      mctx->state_log_top = next_state_log_idx;\n    }\n  return REG_NOERROR;\n}",
      "lines": 24,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "merge_state_array": {
      "start_point": [
        1705,
        0
      ],
      "end_point": [
        1729,
        1
      ],
      "content": "static reg_errcode_t\nmerge_state_array (const re_dfa_t *dfa, re_dfastate_t **dst,\n\t\t   re_dfastate_t **src, int num)\n{\n  int st_idx;\n  reg_errcode_t err;\n  for (st_idx = 0; st_idx < num; ++st_idx)\n    {\n      if (dst[st_idx] == NULL)\n\tdst[st_idx] = src[st_idx];\n      else if (src[st_idx] != NULL)\n\t{\n\t  re_node_set merged_set;\n\t  err = re_node_set_init_union (&merged_set, &dst[st_idx]->nodes,\n\t\t\t\t\t&src[st_idx]->nodes);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return err;\n\t  dst[st_idx] = re_acquire_state (&err, dfa, &merged_set);\n\t  re_node_set_free (&merged_set);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return err;\n\t}\n    }\n  return REG_NOERROR;\n}",
      "lines": 25,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "update_cur_sifted_state": {
      "start_point": [
        1731,
        0
      ],
      "end_point": [
        1776,
        1
      ],
      "content": "static reg_errcode_t\nupdate_cur_sifted_state (const re_match_context_t *mctx,\n\t\t\t re_sift_context_t *sctx, int str_idx,\n\t\t\t re_node_set *dest_nodes)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  reg_errcode_t err = REG_NOERROR;\n  const re_node_set *candidates;\n  candidates = ((mctx->state_log[str_idx] == NULL) ? NULL\n\t\t: &mctx->state_log[str_idx]->nodes);\n\n  if (dest_nodes->nelem == 0)\n    sctx->sifted_states[str_idx] = NULL;\n  else\n    {\n      if (candidates)\n\t{\n\t  /* At first, add the nodes which can epsilon transit to a node in\n\t     DEST_NODE.  */\n\t  err = add_epsilon_src_nodes (dfa, dest_nodes, candidates);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return err;\n\n\t  /* Then, check the limitations in the current sift_context.  */\n\t  if (sctx->limits.nelem)\n\t    {\n\t      err = check_subexp_limits (dfa, dest_nodes, candidates, &sctx->limits,\n\t\t\t\t\t mctx->bkref_ents, str_idx);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\treturn err;\n\t    }\n\t}\n\n      sctx->sifted_states[str_idx] = re_acquire_state (&err, dfa, dest_nodes);\n      if (BE (err != REG_NOERROR, 0))\n\treturn err;\n    }\n\n  if (candidates && mctx->state_log[str_idx]->has_backref)\n    {\n      err = sift_states_bkref (mctx, sctx, str_idx, candidates);\n      if (BE (err != REG_NOERROR, 0))\n\treturn err;\n    }\n  return REG_NOERROR;\n}",
      "lines": 46,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "add_epsilon_src_nodes": {
      "start_point": [
        1778,
        0
      ],
      "end_point": [
        1805,
        1
      ],
      "content": "static reg_errcode_t\n__attribute_warn_unused_result__\nadd_epsilon_src_nodes (const re_dfa_t *dfa, re_node_set *dest_nodes,\n\t\t       const re_node_set *candidates)\n{\n  reg_errcode_t err = REG_NOERROR;\n  int i;\n\n  re_dfastate_t *state = re_acquire_state (&err, dfa, dest_nodes);\n  if (BE (err != REG_NOERROR, 0))\n    return err;\n\n  if (!state->inveclosure.alloc)\n    {\n      err = re_node_set_alloc (&state->inveclosure, dest_nodes->nelem);\n      if (BE (err != REG_NOERROR, 0))\n\treturn REG_ESPACE;\n      for (i = 0; i < dest_nodes->nelem; i++)\n\t{\n\t  err = re_node_set_merge (&state->inveclosure,\n\t\t\t\t   dfa->inveclosures + dest_nodes->elems[i]);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return REG_ESPACE;\n\t}\n    }\n  return re_node_set_add_intersect (dest_nodes, candidates,\n\t\t\t\t    &state->inveclosure);\n}",
      "lines": 28,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "__attribute_warn_unused_result__",
        "__attribute_warn_unused_result__"
      ]
    },
    "sub_epsilon_src_nodes": {
      "start_point": [
        1807,
        0
      ],
      "end_point": [
        1853,
        1
      ],
      "content": "static reg_errcode_t\nsub_epsilon_src_nodes (const re_dfa_t *dfa, int node, re_node_set *dest_nodes,\n\t\t       const re_node_set *candidates)\n{\n    int ecl_idx;\n    reg_errcode_t err;\n    re_node_set *inv_eclosure = dfa->inveclosures + node;\n    re_node_set except_nodes;\n    re_node_set_init_empty (&except_nodes);\n    for (ecl_idx = 0; ecl_idx < inv_eclosure->nelem; ++ecl_idx)\n      {\n\tint cur_node = inv_eclosure->elems[ecl_idx];\n\tif (cur_node == node)\n\t  continue;\n\tif (IS_EPSILON_NODE (dfa->nodes[cur_node].type))\n\t  {\n\t    int edst1 = dfa->edests[cur_node].elems[0];\n\t    int edst2 = ((dfa->edests[cur_node].nelem > 1)\n\t\t\t ? dfa->edests[cur_node].elems[1] : -1);\n\t    if ((!re_node_set_contains (inv_eclosure, edst1)\n\t\t && re_node_set_contains (dest_nodes, edst1))\n\t\t|| (edst2 > 0\n\t\t    && !re_node_set_contains (inv_eclosure, edst2)\n\t\t    && re_node_set_contains (dest_nodes, edst2)))\n\t      {\n\t\terr = re_node_set_add_intersect (&except_nodes, candidates,\n\t\t\t\t\t\t dfa->inveclosures + cur_node);\n\t\tif (BE (err != REG_NOERROR, 0))\n\t\t  {\n\t\t    re_node_set_free (&except_nodes);\n\t\t    return err;\n\t\t  }\n\t      }\n\t  }\n      }\n    for (ecl_idx = 0; ecl_idx < inv_eclosure->nelem; ++ecl_idx)\n      {\n\tint cur_node = inv_eclosure->elems[ecl_idx];\n\tif (!re_node_set_contains (&except_nodes, cur_node))\n\t  {\n\t    int idx = re_node_set_contains (dest_nodes, cur_node) - 1;\n\t    re_node_set_remove_at (dest_nodes, idx);\n\t  }\n      }\n    re_node_set_free (&except_nodes);\n    return REG_NOERROR;\n}",
      "lines": 47,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "check_dst_limits": {
      "start_point": [
        1855,
        0
      ],
      "end_point": [
        1888,
        1
      ],
      "content": "static int\ncheck_dst_limits (const re_match_context_t *mctx, re_node_set *limits,\n\t\t  int dst_node, int dst_idx, int src_node, int src_idx)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  int lim_idx, src_pos, dst_pos;\n\n  int dst_bkref_idx = search_cur_bkref_entry (mctx, dst_idx);\n  int src_bkref_idx = search_cur_bkref_entry (mctx, src_idx);\n  for (lim_idx = 0; lim_idx < limits->nelem; ++lim_idx)\n    {\n      int subexp_idx;\n      struct re_backref_cache_entry *ent;\n      ent = mctx->bkref_ents + limits->elems[lim_idx];\n      subexp_idx = dfa->nodes[ent->node].opr.idx;\n\n      dst_pos = check_dst_limits_calc_pos (mctx, limits->elems[lim_idx],\n\t\t\t\t\t   subexp_idx, dst_node, dst_idx,\n\t\t\t\t\t   dst_bkref_idx);\n      src_pos = check_dst_limits_calc_pos (mctx, limits->elems[lim_idx],\n\t\t\t\t\t   subexp_idx, src_node, src_idx,\n\t\t\t\t\t   src_bkref_idx);\n\n      /* In case of:\n\t <src> <dst> ( <subexp> )\n\t ( <subexp> ) <src> <dst>\n\t ( <subexp1> <src> <subexp2> <dst> <subexp3> )  */\n      if (src_pos == dst_pos)\n\tcontinue; /* This is unrelated limitation.  */\n      else\n\treturn 1;\n    }\n  return 0;\n}",
      "lines": 34,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "check_dst_limits_calc_pos_1": {
      "start_point": [
        1890,
        0
      ],
      "end_point": [
        1968,
        1
      ],
      "content": "static int\ncheck_dst_limits_calc_pos_1 (const re_match_context_t *mctx, int boundaries,\n\t\t\t     int subexp_idx, int from_node, int bkref_idx)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  const re_node_set *eclosures = dfa->eclosures + from_node;\n  int node_idx;\n\n  /* Else, we are on the boundary: examine the nodes on the epsilon\n     closure.  */\n  for (node_idx = 0; node_idx < eclosures->nelem; ++node_idx)\n    {\n      int node = eclosures->elems[node_idx];\n      switch (dfa->nodes[node].type)\n\t{\n\tcase OP_BACK_REF:\n\t  if (bkref_idx != -1)\n\t    {\n\t      struct re_backref_cache_entry *ent = mctx->bkref_ents + bkref_idx;\n\t      do\n\t\t{\n\t\t  int dst, cpos;\n\n\t\t  if (ent->node != node)\n\t\t    continue;\n\n\t\t  if (subexp_idx < BITSET_WORD_BITS\n\t\t      && !(ent->eps_reachable_subexps_map\n\t\t\t   & ((bitset_word_t) 1 << subexp_idx)))\n\t\t    continue;\n\n\t\t  /* Recurse trying to reach the OP_OPEN_SUBEXP and\n\t\t     OP_CLOSE_SUBEXP cases below.  But, if the\n\t\t     destination node is the same node as the source\n\t\t     node, don't recurse because it would cause an\n\t\t     infinite loop: a regex that exhibits this behavior\n\t\t     is ()\\1*\\1*  */\n\t\t  dst = dfa->edests[node].elems[0];\n\t\t  if (dst == from_node)\n\t\t    {\n\t\t      if (boundaries & 1)\n\t\t\treturn -1;\n\t\t      else /* if (boundaries & 2) */\n\t\t\treturn 0;\n\t\t    }\n\n\t\t  cpos =\n\t\t    check_dst_limits_calc_pos_1 (mctx, boundaries, subexp_idx,\n\t\t\t\t\t\t dst, bkref_idx);\n\t\t  if (cpos == -1 /* && (boundaries & 1) */)\n\t\t    return -1;\n\t\t  if (cpos == 0 && (boundaries & 2))\n\t\t    return 0;\n\n\t\t  if (subexp_idx < BITSET_WORD_BITS)\n\t\t    ent->eps_reachable_subexps_map\n\t\t      &= ~((bitset_word_t) 1 << subexp_idx);\n\t\t}\n\t      while (ent++->more);\n\t    }\n\t  break;\n\n\tcase OP_OPEN_SUBEXP:\n\t  if ((boundaries & 1) && subexp_idx == dfa->nodes[node].opr.idx)\n\t    return -1;\n\t  break;\n\n\tcase OP_CLOSE_SUBEXP:\n\t  if ((boundaries & 2) && subexp_idx == dfa->nodes[node].opr.idx)\n\t    return 0;\n\t  break;\n\n\tdefault:\n\t    break;\n\t}\n    }\n\n  return (boundaries & 2) ? 1 : 0;\n}",
      "lines": 79,
      "depth": 22,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "check_dst_limits_calc_pos": {
      "start_point": [
        1970,
        0
      ],
      "end_point": [
        1994,
        1
      ],
      "content": "static int\ncheck_dst_limits_calc_pos (const re_match_context_t *mctx, int limit,\n\t\t\t   int subexp_idx, int from_node, int str_idx,\n\t\t\t   int bkref_idx)\n{\n  struct re_backref_cache_entry *lim = mctx->bkref_ents + limit;\n  int boundaries;\n\n  /* If we are outside the range of the subexpression, return -1 or 1.  */\n  if (str_idx < lim->subexp_from)\n    return -1;\n\n  if (lim->subexp_to < str_idx)\n    return 1;\n\n  /* If we are within the subexpression, return 0.  */\n  boundaries = (str_idx == lim->subexp_from);\n  boundaries |= (str_idx == lim->subexp_to) << 1;\n  if (boundaries == 0)\n    return 0;\n\n  /* Else, examine epsilon closure.  */\n  return check_dst_limits_calc_pos_1 (mctx, boundaries, subexp_idx,\n\t\t\t\t      from_node, bkref_idx);\n}",
      "lines": 25,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "check_subexp_limits": {
      "start_point": [
        1999,
        0
      ],
      "end_point": [
        2084,
        1
      ],
      "content": "static reg_errcode_t\ncheck_subexp_limits (const re_dfa_t *dfa, re_node_set *dest_nodes,\n\t\t     const re_node_set *candidates, re_node_set *limits,\n\t\t     struct re_backref_cache_entry *bkref_ents, int str_idx)\n{\n  reg_errcode_t err;\n  int node_idx, lim_idx;\n\n  for (lim_idx = 0; lim_idx < limits->nelem; ++lim_idx)\n    {\n      int subexp_idx;\n      struct re_backref_cache_entry *ent;\n      ent = bkref_ents + limits->elems[lim_idx];\n\n      if (str_idx <= ent->subexp_from || ent->str_idx < str_idx)\n\tcontinue; /* This is unrelated limitation.  */\n\n      subexp_idx = dfa->nodes[ent->node].opr.idx;\n      if (ent->subexp_to == str_idx)\n\t{\n\t  int ops_node = -1;\n\t  int cls_node = -1;\n\t  for (node_idx = 0; node_idx < dest_nodes->nelem; ++node_idx)\n\t    {\n\t      int node = dest_nodes->elems[node_idx];\n\t      re_token_type_t type = dfa->nodes[node].type;\n\t      if (type == OP_OPEN_SUBEXP\n\t\t  && subexp_idx == dfa->nodes[node].opr.idx)\n\t\tops_node = node;\n\t      else if (type == OP_CLOSE_SUBEXP\n\t\t       && subexp_idx == dfa->nodes[node].opr.idx)\n\t\tcls_node = node;\n\t    }\n\n\t  /* Check the limitation of the open subexpression.  */\n\t  /* Note that (ent->subexp_to = str_idx != ent->subexp_from).  */\n\t  if (ops_node >= 0)\n\t    {\n\t      err = sub_epsilon_src_nodes (dfa, ops_node, dest_nodes,\n\t\t\t\t\t   candidates);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\treturn err;\n\t    }\n\n\t  /* Check the limitation of the close subexpression.  */\n\t  if (cls_node >= 0)\n\t    for (node_idx = 0; node_idx < dest_nodes->nelem; ++node_idx)\n\t      {\n\t\tint node = dest_nodes->elems[node_idx];\n\t\tif (!re_node_set_contains (dfa->inveclosures + node,\n\t\t\t\t\t   cls_node)\n\t\t    && !re_node_set_contains (dfa->eclosures + node,\n\t\t\t\t\t      cls_node))\n\t\t  {\n\t\t    /* It is against this limitation.\n\t\t       Remove it form the current sifted state.  */\n\t\t    err = sub_epsilon_src_nodes (dfa, node, dest_nodes,\n\t\t\t\t\t\t candidates);\n\t\t    if (BE (err != REG_NOERROR, 0))\n\t\t      return err;\n\t\t    --node_idx;\n\t\t  }\n\t      }\n\t}\n      else /* (ent->subexp_to != str_idx)  */\n\t{\n\t  for (node_idx = 0; node_idx < dest_nodes->nelem; ++node_idx)\n\t    {\n\t      int node = dest_nodes->elems[node_idx];\n\t      re_token_type_t type = dfa->nodes[node].type;\n\t      if (type == OP_CLOSE_SUBEXP || type == OP_OPEN_SUBEXP)\n\t\t{\n\t\t  if (subexp_idx != dfa->nodes[node].opr.idx)\n\t\t    continue;\n\t\t  /* It is against this limitation.\n\t\t     Remove it form the current sifted state.  */\n\t\t  err = sub_epsilon_src_nodes (dfa, node, dest_nodes,\n\t\t\t\t\t       candidates);\n\t\t  if (BE (err != REG_NOERROR, 0))\n\t\t    return err;\n\t\t}\n\t    }\n\t}\n    }\n  return REG_NOERROR;\n}",
      "lines": 86,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "sift_states_bkref": {
      "start_point": [
        2086,
        0
      ],
      "end_point": [
        2182,
        1
      ],
      "content": "static reg_errcode_t\n__attribute_warn_unused_result__\nsift_states_bkref (const re_match_context_t *mctx, re_sift_context_t *sctx,\n\t\t   int str_idx, const re_node_set *candidates)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  reg_errcode_t err;\n  int node_idx, node;\n  re_sift_context_t local_sctx;\n  int first_idx = search_cur_bkref_entry (mctx, str_idx);\n\n  if (first_idx == -1)\n    return REG_NOERROR;\n\n  local_sctx.sifted_states = NULL; /* Mark that it hasn't been initialized.  */\n\n  for (node_idx = 0; node_idx < candidates->nelem; ++node_idx)\n    {\n      int enabled_idx;\n      re_token_type_t type;\n      struct re_backref_cache_entry *entry;\n      node = candidates->elems[node_idx];\n      type = dfa->nodes[node].type;\n      /* Avoid infinite loop for the REs like \"()\\1+\".  */\n      if (node == sctx->last_node && str_idx == sctx->last_str_idx)\n\tcontinue;\n      if (type != OP_BACK_REF)\n\tcontinue;\n\n      entry = mctx->bkref_ents + first_idx;\n      enabled_idx = first_idx;\n      do\n\t{\n\t  int subexp_len;\n\t  int to_idx;\n\t  int dst_node;\n\t  int ret;\n\t  re_dfastate_t *cur_state;\n\n\t  if (entry->node != node)\n\t    continue;\n\t  subexp_len = entry->subexp_to - entry->subexp_from;\n\t  to_idx = str_idx + subexp_len;\n\t  dst_node = (subexp_len ? dfa->nexts[node]\n\t\t      : dfa->edests[node].elems[0]);\n\n\t  if (to_idx > sctx->last_str_idx\n\t      || sctx->sifted_states[to_idx] == NULL\n\t      || !STATE_NODE_CONTAINS (sctx->sifted_states[to_idx], dst_node)\n\t      || check_dst_limits (mctx, &sctx->limits, node,\n\t\t\t\t   str_idx, dst_node, to_idx))\n\t    continue;\n\n\t  if (local_sctx.sifted_states == NULL)\n\t    {\n\t      local_sctx = *sctx;\n\t      err = re_node_set_init_copy (&local_sctx.limits, &sctx->limits);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\tgoto free_return;\n\t    }\n\t  local_sctx.last_node = node;\n\t  local_sctx.last_str_idx = str_idx;\n\t  ret = re_node_set_insert (&local_sctx.limits, enabled_idx);\n\t  if (BE (ret < 0, 0))\n\t    {\n\t      err = REG_ESPACE;\n\t      goto free_return;\n\t    }\n\t  cur_state = local_sctx.sifted_states[str_idx];\n\t  err = sift_states_backward (mctx, &local_sctx);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    goto free_return;\n\t  if (sctx->limited_states != NULL)\n\t    {\n\t      err = merge_state_array (dfa, sctx->limited_states,\n\t\t\t\t       local_sctx.sifted_states,\n\t\t\t\t       str_idx + 1);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\tgoto free_return;\n\t    }\n\t  local_sctx.sifted_states[str_idx] = cur_state;\n\t  re_node_set_remove (&local_sctx.limits, enabled_idx);\n\n\t  /* mctx->bkref_ents may have changed, reload the pointer.  */\n\t  entry = mctx->bkref_ents + enabled_idx;\n\t}\n      while (enabled_idx++, entry++->more);\n    }\n  err = REG_NOERROR;\n free_return:\n  if (local_sctx.sifted_states != NULL)\n    {\n      re_node_set_free (&local_sctx.limits);\n    }\n\n  return err;\n}",
      "lines": 97,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "__attribute_warn_unused_result__",
        "__attribute_warn_unused_result__"
      ]
    },
    "sift_states_iter_mb": {
      "start_point": [
        2186,
        0
      ],
      "end_point": [
        2204,
        1
      ],
      "content": "static int\nsift_states_iter_mb (const re_match_context_t *mctx, re_sift_context_t *sctx,\n\t\t     int node_idx, int str_idx, int max_str_idx)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  int naccepted;\n  /* Check the node can accept `multi byte'.  */\n  naccepted = check_node_accept_bytes (dfa, node_idx, &mctx->input, str_idx);\n  if (naccepted > 0 && str_idx + naccepted <= max_str_idx &&\n      !STATE_NODE_CONTAINS (sctx->sifted_states[str_idx + naccepted],\n\t\t\t    dfa->nexts[node_idx]))\n    /* The node can't accept the `multi byte', or the\n       destination was already thrown away, then the node\n       could't accept the current input `multi byte'.   */\n    naccepted = 0;\n  /* Otherwise, it is sure that the node could accept\n     `naccepted' bytes input.  */\n  return naccepted;\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "transit_state": {
      "start_point": [
        2215,
        0
      ],
      "end_point": [
        2270,
        1
      ],
      "content": "static re_dfastate_t *\n__attribute_warn_unused_result__\ntransit_state (reg_errcode_t *err, re_match_context_t *mctx,\n\t       re_dfastate_t *state)\n{\n  re_dfastate_t **trtable;\n  unsigned char ch;\n\n#ifdef RE_ENABLE_I18N\n  /* If the current state can accept multibyte.  */\n  if (BE (state->accept_mb, 0))\n    {\n      *err = transit_state_mb (mctx, state);\n      if (BE (*err != REG_NOERROR, 0))\n\treturn NULL;\n    }\n#endif /* RE_ENABLE_I18N */\n\n  /* Then decide the next state with the single byte.  */\n#if 0\n  if (0)\n    /* don't use transition table  */\n    return transit_state_sb (err, mctx, state);\n#endif\n\n  /* Use transition table  */\n  ch = re_string_fetch_byte (&mctx->input);\n  for (;;)\n    {\n      trtable = state->trtable;\n      if (BE (trtable != NULL, 1))\n\treturn trtable[ch];\n\n      trtable = state->word_trtable;\n      if (BE (trtable != NULL, 1))\n\t{\n\t  unsigned int context;\n\t  context\n\t    = re_string_context_at (&mctx->input,\n\t\t\t\t    re_string_cur_idx (&mctx->input) - 1,\n\t\t\t\t    mctx->eflags);\n\t  if (IS_WORD_CONTEXT (context))\n\t    return trtable[ch + SBC_MAX];\n\t  else\n\t    return trtable[ch];\n\t}\n\n      if (!build_trtable (mctx->dfa, state))\n\t{\n\t  *err = REG_ESPACE;\n\t  return NULL;\n\t}\n\n      /* Retry, we now have a transition table.  */\n    }\n}",
      "lines": 56,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "re_dfastate_t",
        "*\n__attribute_warn_unused_result__\ntransit_state (reg_errcode_t *err, re_match_context_t *mctx,\n\t       re_dfastate_t *state)",
        "*",
        "__attribute_warn_unused_result__",
        "__attribute_warn_unused_result__"
      ]
    },
    "merge_state_with_log": {
      "start_point": [
        2273,
        0
      ],
      "end_point": [
        2346,
        1
      ],
      "content": "re_dfastate_t *\nmerge_state_with_log (reg_errcode_t *err, re_match_context_t *mctx,\n\t\t      re_dfastate_t *next_state)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  int cur_idx = re_string_cur_idx (&mctx->input);\n\n  if (cur_idx > mctx->state_log_top)\n    {\n      mctx->state_log[cur_idx] = next_state;\n      mctx->state_log_top = cur_idx;\n    }\n  else if (mctx->state_log[cur_idx] == 0)\n    {\n      mctx->state_log[cur_idx] = next_state;\n    }\n  else\n    {\n      re_dfastate_t *pstate;\n      unsigned int context;\n      re_node_set next_nodes, *log_nodes, *table_nodes = NULL;\n      /* If (state_log[cur_idx] != 0), it implies that cur_idx is\n\t the destination of a multibyte char/collating element/\n\t back reference.  Then the next state is the union set of\n\t these destinations and the results of the transition table.  */\n      pstate = mctx->state_log[cur_idx];\n      log_nodes = pstate->entrance_nodes;\n      if (next_state != NULL)\n\t{\n\t  table_nodes = next_state->entrance_nodes;\n\t  *err = re_node_set_init_union (&next_nodes, table_nodes,\n\t\t\t\t\t     log_nodes);\n\t  if (BE (*err != REG_NOERROR, 0))\n\t    return NULL;\n\t}\n      else\n\tnext_nodes = *log_nodes;\n      /* Note: We already add the nodes of the initial state,\n\t then we don't need to add them here.  */\n\n      context = re_string_context_at (&mctx->input,\n\t\t\t\t      re_string_cur_idx (&mctx->input) - 1,\n\t\t\t\t      mctx->eflags);\n      next_state = mctx->state_log[cur_idx]\n\t= re_acquire_state_context (err, dfa, &next_nodes, context);\n      /* We don't need to check errors here, since the return value of\n\t this function is next_state and ERR is already set.  */\n\n      if (table_nodes != NULL)\n\tre_node_set_free (&next_nodes);\n    }\n\n  if (BE (dfa->nbackref, 0) && next_state != NULL)\n    {\n      /* Check OP_OPEN_SUBEXP in the current state in case that we use them\n\t later.  We must check them here, since the back references in the\n\t next state might use them.  */\n      *err = check_subexp_matching_top (mctx, &next_state->nodes,\n\t\t\t\t\tcur_idx);\n      if (BE (*err != REG_NOERROR, 0))\n\treturn NULL;\n\n      /* If the next state has back references.  */\n      if (next_state->has_backref)\n\t{\n\t  *err = transit_state_bkref (mctx, &next_state->nodes);\n\t  if (BE (*err != REG_NOERROR, 0))\n\t    return NULL;\n\t  next_state = mctx->state_log[cur_idx];\n\t}\n    }\n\n  return next_state;\n}",
      "lines": 74,
      "depth": 15,
      "decorators": [
        "re_dfastate_t",
        "*\nmerge_state_with_log (reg_errcode_t *err, re_match_context_t *mctx,\n\t\t      re_dfastate_t *next_state)",
        "*"
      ]
    },
    "find_recover_state": {
      "start_point": [
        2351,
        0
      ],
      "end_point": [
        2372,
        1
      ],
      "content": "re_dfastate_t *\nfind_recover_state (reg_errcode_t *err, re_match_context_t *mctx)\n{\n  re_dfastate_t *cur_state;\n  do\n    {\n      int max = mctx->state_log_top;\n      int cur_str_idx = re_string_cur_idx (&mctx->input);\n\n      do\n\t{\n\t  if (++cur_str_idx > max)\n\t    return NULL;\n\t  re_string_skip_bytes (&mctx->input, 1);\n\t}\n      while (mctx->state_log[cur_str_idx] == NULL);\n\n      cur_state = merge_state_with_log (err, mctx, NULL);\n    }\n  while (*err == REG_NOERROR && cur_state == NULL);\n  return cur_state;\n}",
      "lines": 22,
      "depth": 12,
      "decorators": [
        "re_dfastate_t",
        "*\nfind_recover_state (reg_errcode_t *err, re_match_context_t *mctx)",
        "*"
      ]
    },
    "check_subexp_matching_top": {
      "start_point": [
        2381,
        0
      ],
      "end_point": [
        2408,
        1
      ],
      "content": "static reg_errcode_t\ncheck_subexp_matching_top (re_match_context_t *mctx, re_node_set *cur_nodes,\n\t\t\t   int str_idx)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  int node_idx;\n  reg_errcode_t err;\n\n  /* TODO: This isn't efficient.\n\t   Because there might be more than one nodes whose types are\n\t   OP_OPEN_SUBEXP and whose index is SUBEXP_IDX, we must check all\n\t   nodes.\n\t   E.g. RE: (a){2}  */\n  for (node_idx = 0; node_idx < cur_nodes->nelem; ++node_idx)\n    {\n      int node = cur_nodes->elems[node_idx];\n      if (dfa->nodes[node].type == OP_OPEN_SUBEXP\n\t  && dfa->nodes[node].opr.idx < BITSET_WORD_BITS\n\t  && (dfa->used_bkref_map\n\t      & ((bitset_word_t) 1 << dfa->nodes[node].opr.idx)))\n\t{\n\t  err = match_ctx_add_subtop (mctx, node, str_idx);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return err;\n\t}\n    }\n  return REG_NOERROR;\n}",
      "lines": 28,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "transit_state_sb": {
      "start_point": [
        2414,
        0
      ],
      "end_point": [
        2449,
        1
      ],
      "content": "static re_dfastate_t *\ntransit_state_sb (reg_errcode_t *err, re_match_context_t *mctx,\n\t\t  re_dfastate_t *state)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  re_node_set next_nodes;\n  re_dfastate_t *next_state;\n  int node_cnt, cur_str_idx = re_string_cur_idx (&mctx->input);\n  unsigned int context;\n\n  *err = re_node_set_alloc (&next_nodes, state->nodes.nelem + 1);\n  if (BE (*err != REG_NOERROR, 0))\n    return NULL;\n  for (node_cnt = 0; node_cnt < state->nodes.nelem; ++node_cnt)\n    {\n      int cur_node = state->nodes.elems[node_cnt];\n      if (check_node_accept (mctx, dfa->nodes + cur_node, cur_str_idx))\n\t{\n\t  *err = re_node_set_merge (&next_nodes,\n\t\t\t\t    dfa->eclosures + dfa->nexts[cur_node]);\n\t  if (BE (*err != REG_NOERROR, 0))\n\t    {\n\t      re_node_set_free (&next_nodes);\n\t      return NULL;\n\t    }\n\t}\n    }\n  context = re_string_context_at (&mctx->input, cur_str_idx, mctx->eflags);\n  next_state = re_acquire_state_context (err, dfa, &next_nodes, context);\n  /* We don't need to check errors here, since the return value of\n     this function is next_state and ERR is already set.  */\n\n  re_node_set_free (&next_nodes);\n  re_string_skip_bytes (&mctx->input, 1);\n  return next_state;\n}",
      "lines": 36,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "re_dfastate_t",
        "*\ntransit_state_sb (reg_errcode_t *err, re_match_context_t *mctx,\n\t\t  re_dfastate_t *state)",
        "*"
      ]
    },
    "transit_state_mb": {
      "start_point": [
        2453,
        0
      ],
      "end_point": [
        2519,
        1
      ],
      "content": "static reg_errcode_t\ntransit_state_mb (re_match_context_t *mctx, re_dfastate_t *pstate)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  reg_errcode_t err;\n  int i;\n\n  for (i = 0; i < pstate->nodes.nelem; ++i)\n    {\n      re_node_set dest_nodes, *new_nodes;\n      int cur_node_idx = pstate->nodes.elems[i];\n      int naccepted, dest_idx;\n      unsigned int context;\n      re_dfastate_t *dest_state;\n\n      if (!dfa->nodes[cur_node_idx].accept_mb)\n\tcontinue;\n\n      if (dfa->nodes[cur_node_idx].constraint)\n\t{\n\t  context = re_string_context_at (&mctx->input,\n\t\t\t\t\t  re_string_cur_idx (&mctx->input),\n\t\t\t\t\t  mctx->eflags);\n\t  if (NOT_SATISFY_NEXT_CONSTRAINT (dfa->nodes[cur_node_idx].constraint,\n\t\t\t\t\t   context))\n\t    continue;\n\t}\n\n      /* How many bytes the node can accept?  */\n      naccepted = check_node_accept_bytes (dfa, cur_node_idx, &mctx->input,\n\t\t\t\t\t   re_string_cur_idx (&mctx->input));\n      if (naccepted == 0)\n\tcontinue;\n\n      /* The node can accepts `naccepted' bytes.  */\n      dest_idx = re_string_cur_idx (&mctx->input) + naccepted;\n      mctx->max_mb_elem_len = ((mctx->max_mb_elem_len < naccepted) ? naccepted\n\t\t\t       : mctx->max_mb_elem_len);\n      err = clean_state_log_if_needed (mctx, dest_idx);\n      if (BE (err != REG_NOERROR, 0))\n\treturn err;\n#ifdef DEBUG\n      assert (dfa->nexts[cur_node_idx] != -1);\n#endif\n      new_nodes = dfa->eclosures + dfa->nexts[cur_node_idx];\n\n      dest_state = mctx->state_log[dest_idx];\n      if (dest_state == NULL)\n\tdest_nodes = *new_nodes;\n      else\n\t{\n\t  err = re_node_set_init_union (&dest_nodes,\n\t\t\t\t\tdest_state->entrance_nodes, new_nodes);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return err;\n\t}\n      context = re_string_context_at (&mctx->input, dest_idx - 1,\n\t\t\t\t      mctx->eflags);\n      mctx->state_log[dest_idx]\n\t= re_acquire_state_context (&err, dfa, &dest_nodes, context);\n      if (dest_state != NULL)\n\tre_node_set_free (&dest_nodes);\n      if (BE (mctx->state_log[dest_idx] == NULL && err != REG_NOERROR, 0))\n\treturn err;\n    }\n  return REG_NOERROR;\n}",
      "lines": 67,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "transit_state_bkref": {
      "start_point": [
        2522,
        0
      ],
      "end_point": [
        2627,
        1
      ],
      "content": "static reg_errcode_t\ntransit_state_bkref (re_match_context_t *mctx, const re_node_set *nodes)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  reg_errcode_t err;\n  int i;\n  int cur_str_idx = re_string_cur_idx (&mctx->input);\n\n  for (i = 0; i < nodes->nelem; ++i)\n    {\n      int dest_str_idx, prev_nelem, bkc_idx;\n      int node_idx = nodes->elems[i];\n      unsigned int context;\n      const re_token_t *node = dfa->nodes + node_idx;\n      re_node_set *new_dest_nodes;\n\n      /* Check whether `node' is a backreference or not.  */\n      if (node->type != OP_BACK_REF)\n\tcontinue;\n\n      if (node->constraint)\n\t{\n\t  context = re_string_context_at (&mctx->input, cur_str_idx,\n\t\t\t\t\t  mctx->eflags);\n\t  if (NOT_SATISFY_NEXT_CONSTRAINT (node->constraint, context))\n\t    continue;\n\t}\n\n      /* `node' is a backreference.\n\t Check the substring which the substring matched.  */\n      bkc_idx = mctx->nbkref_ents;\n      err = get_subexp (mctx, node_idx, cur_str_idx);\n      if (BE (err != REG_NOERROR, 0))\n\tgoto free_return;\n\n      /* And add the epsilon closures (which is `new_dest_nodes') of\n\t the backreference to appropriate state_log.  */\n#ifdef DEBUG\n      assert (dfa->nexts[node_idx] != -1);\n#endif\n      for (; bkc_idx < mctx->nbkref_ents; ++bkc_idx)\n\t{\n\t  int subexp_len;\n\t  re_dfastate_t *dest_state;\n\t  struct re_backref_cache_entry *bkref_ent;\n\t  bkref_ent = mctx->bkref_ents + bkc_idx;\n\t  if (bkref_ent->node != node_idx || bkref_ent->str_idx != cur_str_idx)\n\t    continue;\n\t  subexp_len = bkref_ent->subexp_to - bkref_ent->subexp_from;\n\t  new_dest_nodes = (subexp_len == 0\n\t\t\t    ? dfa->eclosures + dfa->edests[node_idx].elems[0]\n\t\t\t    : dfa->eclosures + dfa->nexts[node_idx]);\n\t  dest_str_idx = (cur_str_idx + bkref_ent->subexp_to\n\t\t\t  - bkref_ent->subexp_from);\n\t  context = re_string_context_at (&mctx->input, dest_str_idx - 1,\n\t\t\t\t\t  mctx->eflags);\n\t  dest_state = mctx->state_log[dest_str_idx];\n\t  prev_nelem = ((mctx->state_log[cur_str_idx] == NULL) ? 0\n\t\t\t: mctx->state_log[cur_str_idx]->nodes.nelem);\n\t  /* Add `new_dest_node' to state_log.  */\n\t  if (dest_state == NULL)\n\t    {\n\t      mctx->state_log[dest_str_idx]\n\t\t= re_acquire_state_context (&err, dfa, new_dest_nodes,\n\t\t\t\t\t    context);\n\t      if (BE (mctx->state_log[dest_str_idx] == NULL\n\t\t      && err != REG_NOERROR, 0))\n\t\tgoto free_return;\n\t    }\n\t  else\n\t    {\n\t      re_node_set dest_nodes;\n\t      err = re_node_set_init_union (&dest_nodes,\n\t\t\t\t\t    dest_state->entrance_nodes,\n\t\t\t\t\t    new_dest_nodes);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\t{\n\t\t  re_node_set_free (&dest_nodes);\n\t\t  goto free_return;\n\t\t}\n\t      mctx->state_log[dest_str_idx]\n\t\t= re_acquire_state_context (&err, dfa, &dest_nodes, context);\n\t      re_node_set_free (&dest_nodes);\n\t      if (BE (mctx->state_log[dest_str_idx] == NULL\n\t\t      && err != REG_NOERROR, 0))\n\t\tgoto free_return;\n\t    }\n\t  /* We need to check recursively if the backreference can epsilon\n\t     transit.  */\n\t  if (subexp_len == 0\n\t      && mctx->state_log[cur_str_idx]->nodes.nelem > prev_nelem)\n\t    {\n\t      err = check_subexp_matching_top (mctx, new_dest_nodes,\n\t\t\t\t\t       cur_str_idx);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\tgoto free_return;\n\t      err = transit_state_bkref (mctx, new_dest_nodes);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\tgoto free_return;\n\t    }\n\t}\n    }\n  err = REG_NOERROR;\n free_return:\n  return err;\n}",
      "lines": 106,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "get_subexp_sub": {
      "start_point": [
        2784,
        0
      ],
      "end_point": [
        2802,
        1
      ],
      "content": "static reg_errcode_t\nget_subexp_sub (re_match_context_t *mctx, const re_sub_match_top_t *sub_top,\n\t\tre_sub_match_last_t *sub_last, int bkref_node, int bkref_str)\n{\n  reg_errcode_t err;\n  int to_idx;\n  /* Can the subexpression arrive the back reference?  */\n  err = check_arrival (mctx, &sub_last->path, sub_last->node,\n\t\t       sub_last->str_idx, bkref_node, bkref_str,\n\t\t       OP_OPEN_SUBEXP);\n  if (err != REG_NOERROR)\n    return err;\n  err = match_ctx_add_entry (mctx, bkref_node, bkref_str, sub_top->str_idx,\n\t\t\t     sub_last->str_idx);\n  if (BE (err != REG_NOERROR, 0))\n    return err;\n  to_idx = bkref_str + sub_last->str_idx - sub_top->str_idx;\n  return clean_state_log_if_needed (mctx, to_idx);\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "find_subexp_node": {
      "start_point": [
        2812,
        0
      ],
      "end_point": [
        2826,
        1
      ],
      "content": "static int\nfind_subexp_node (const re_dfa_t *dfa, const re_node_set *nodes,\n\t\t  int subexp_idx, int type)\n{\n  int cls_idx;\n  for (cls_idx = 0; cls_idx < nodes->nelem; ++cls_idx)\n    {\n      int cls_node = nodes->elems[cls_idx];\n      const re_token_t *node = dfa->nodes + cls_node;\n      if (node->type == type\n\t  && node->opr.idx == subexp_idx)\n\treturn cls_node;\n    }\n  return -1;\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "check_arrival": {
      "start_point": [
        2833,
        0
      ],
      "end_point": [
        2984,
        1
      ],
      "content": "static reg_errcode_t\n__attribute_warn_unused_result__\ncheck_arrival (re_match_context_t *mctx, state_array_t *path, int top_node,\n\t       int top_str, int last_node, int last_str, int type)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  reg_errcode_t err = REG_NOERROR;\n  int subexp_num, backup_cur_idx, str_idx, null_cnt;\n  re_dfastate_t *cur_state = NULL;\n  re_node_set *cur_nodes, next_nodes;\n  re_dfastate_t **backup_state_log;\n  unsigned int context;\n\n  subexp_num = dfa->nodes[top_node].opr.idx;\n  /* Extend the buffer if we need.  */\n  if (BE (path->alloc < last_str + mctx->max_mb_elem_len + 1, 0))\n    {\n      re_dfastate_t **new_array;\n      int old_alloc = path->alloc;\n      path->alloc += last_str + mctx->max_mb_elem_len + 1;\n      new_array = re_realloc (path->array, re_dfastate_t *, path->alloc);\n      if (BE (new_array == NULL, 0))\n\t{\n\t  path->alloc = old_alloc;\n\t  return REG_ESPACE;\n\t}\n      path->array = new_array;\n      memset (new_array + old_alloc, '\\0',\n\t      sizeof (re_dfastate_t *) * (path->alloc - old_alloc));\n    }\n\n  str_idx = path->next_idx ? path->next_idx : top_str;\n\n  /* Temporary modify MCTX.  */\n  backup_state_log = mctx->state_log;\n  backup_cur_idx = mctx->input.cur_idx;\n  mctx->state_log = path->array;\n  mctx->input.cur_idx = str_idx;\n\n  /* Setup initial node set.  */\n  context = re_string_context_at (&mctx->input, str_idx - 1, mctx->eflags);\n  if (str_idx == top_str)\n    {\n      err = re_node_set_init_1 (&next_nodes, top_node);\n      if (BE (err != REG_NOERROR, 0))\n\treturn err;\n      err = check_arrival_expand_ecl (dfa, &next_nodes, subexp_num, type);\n      if (BE (err != REG_NOERROR, 0))\n\t{\n\t  re_node_set_free (&next_nodes);\n\t  return err;\n\t}\n    }\n  else\n    {\n      cur_state = mctx->state_log[str_idx];\n      if (cur_state && cur_state->has_backref)\n\t{\n\t  err = re_node_set_init_copy (&next_nodes, &cur_state->nodes);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return err;\n\t}\n      else\n\tre_node_set_init_empty (&next_nodes);\n    }\n  if (str_idx == top_str || (cur_state && cur_state->has_backref))\n    {\n      if (next_nodes.nelem)\n\t{\n\t  err = expand_bkref_cache (mctx, &next_nodes, str_idx,\n\t\t\t\t    subexp_num, type);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    {\n\t      re_node_set_free (&next_nodes);\n\t      return err;\n\t    }\n\t}\n      cur_state = re_acquire_state_context (&err, dfa, &next_nodes, context);\n      if (BE (cur_state == NULL && err != REG_NOERROR, 0))\n\t{\n\t  re_node_set_free (&next_nodes);\n\t  return err;\n\t}\n      mctx->state_log[str_idx] = cur_state;\n    }\n\n  for (null_cnt = 0; str_idx < last_str && null_cnt <= mctx->max_mb_elem_len;)\n    {\n      re_node_set_empty (&next_nodes);\n      if (mctx->state_log[str_idx + 1])\n\t{\n\t  err = re_node_set_merge (&next_nodes,\n\t\t\t\t   &mctx->state_log[str_idx + 1]->nodes);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    {\n\t      re_node_set_free (&next_nodes);\n\t      return err;\n\t    }\n\t}\n      if (cur_state)\n\t{\n\t  err = check_arrival_add_next_nodes (mctx, str_idx,\n\t\t\t\t\t      &cur_state->non_eps_nodes,\n\t\t\t\t\t      &next_nodes);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    {\n\t      re_node_set_free (&next_nodes);\n\t      return err;\n\t    }\n\t}\n      ++str_idx;\n      if (next_nodes.nelem)\n\t{\n\t  err = check_arrival_expand_ecl (dfa, &next_nodes, subexp_num, type);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    {\n\t      re_node_set_free (&next_nodes);\n\t      return err;\n\t    }\n\t  err = expand_bkref_cache (mctx, &next_nodes, str_idx,\n\t\t\t\t    subexp_num, type);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    {\n\t      re_node_set_free (&next_nodes);\n\t      return err;\n\t    }\n\t}\n      context = re_string_context_at (&mctx->input, str_idx - 1, mctx->eflags);\n      cur_state = re_acquire_state_context (&err, dfa, &next_nodes, context);\n      if (BE (cur_state == NULL && err != REG_NOERROR, 0))\n\t{\n\t  re_node_set_free (&next_nodes);\n\t  return err;\n\t}\n      mctx->state_log[str_idx] = cur_state;\n      null_cnt = cur_state == NULL ? null_cnt + 1 : 0;\n    }\n  re_node_set_free (&next_nodes);\n  cur_nodes = (mctx->state_log[last_str] == NULL ? NULL\n\t       : &mctx->state_log[last_str]->nodes);\n  path->next_idx = str_idx;\n\n  /* Fix MCTX.  */\n  mctx->state_log = backup_state_log;\n  mctx->input.cur_idx = backup_cur_idx;\n\n  /* Then check the current node set has the node LAST_NODE.  */\n  if (cur_nodes != NULL && re_node_set_contains (cur_nodes, last_node))\n    return REG_NOERROR;\n\n  return REG_NOMATCH;\n}",
      "lines": 152,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "__attribute_warn_unused_result__",
        "__attribute_warn_unused_result__"
      ]
    },
    "check_arrival_add_next_nodes": {
      "start_point": [
        2994,
        0
      ],
      "end_point": [
        3067,
        1
      ],
      "content": "static reg_errcode_t\n__attribute_warn_unused_result__\ncheck_arrival_add_next_nodes (re_match_context_t *mctx, int str_idx,\n\t\t\t      re_node_set *cur_nodes, re_node_set *next_nodes)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  int result;\n  int cur_idx;\n#ifdef RE_ENABLE_I18N\n  reg_errcode_t err = REG_NOERROR;\n#endif\n  re_node_set union_set;\n  re_node_set_init_empty (&union_set);\n  for (cur_idx = 0; cur_idx < cur_nodes->nelem; ++cur_idx)\n    {\n      int naccepted = 0;\n      int cur_node = cur_nodes->elems[cur_idx];\n#ifdef DEBUG\n      re_token_type_t type = dfa->nodes[cur_node].type;\n      assert (!IS_EPSILON_NODE (type));\n#endif\n#ifdef RE_ENABLE_I18N\n      /* If the node may accept `multi byte'.  */\n      if (dfa->nodes[cur_node].accept_mb)\n\t{\n\t  naccepted = check_node_accept_bytes (dfa, cur_node, &mctx->input,\n\t\t\t\t\t       str_idx);\n\t  if (naccepted > 1)\n\t    {\n\t      re_dfastate_t *dest_state;\n\t      int next_node = dfa->nexts[cur_node];\n\t      int next_idx = str_idx + naccepted;\n\t      dest_state = mctx->state_log[next_idx];\n\t      re_node_set_empty (&union_set);\n\t      if (dest_state)\n\t\t{\n\t\t  err = re_node_set_merge (&union_set, &dest_state->nodes);\n\t\t  if (BE (err != REG_NOERROR, 0))\n\t\t    {\n\t\t      re_node_set_free (&union_set);\n\t\t      return err;\n\t\t    }\n\t\t}\n\t      result = re_node_set_insert (&union_set, next_node);\n\t      if (BE (result < 0, 0))\n\t\t{\n\t\t  re_node_set_free (&union_set);\n\t\t  return REG_ESPACE;\n\t\t}\n\t      mctx->state_log[next_idx] = re_acquire_state (&err, dfa,\n\t\t\t\t\t\t\t    &union_set);\n\t      if (BE (mctx->state_log[next_idx] == NULL\n\t\t      && err != REG_NOERROR, 0))\n\t\t{\n\t\t  re_node_set_free (&union_set);\n\t\t  return err;\n\t\t}\n\t    }\n\t}\n#endif /* RE_ENABLE_I18N */\n      if (naccepted\n\t  || check_node_accept (mctx, dfa->nodes + cur_node, str_idx))\n\t{\n\t  result = re_node_set_insert (next_nodes, dfa->nexts[cur_node]);\n\t  if (BE (result < 0, 0))\n\t    {\n\t      re_node_set_free (&union_set);\n\t      return REG_ESPACE;\n\t    }\n\t}\n    }\n  re_node_set_free (&union_set);\n  return REG_NOERROR;\n}",
      "lines": 74,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "__attribute_warn_unused_result__",
        "__attribute_warn_unused_result__"
      ]
    },
    "check_arrival_expand_ecl": {
      "start_point": [
        3075,
        0
      ],
      "end_point": [
        3121,
        1
      ],
      "content": "static reg_errcode_t\ncheck_arrival_expand_ecl (const re_dfa_t *dfa, re_node_set *cur_nodes,\n\t\t\t  int ex_subexp, int type)\n{\n  reg_errcode_t err;\n  int idx, outside_node;\n  re_node_set new_nodes;\n#ifdef DEBUG\n  assert (cur_nodes->nelem);\n#endif\n  err = re_node_set_alloc (&new_nodes, cur_nodes->nelem);\n  if (BE (err != REG_NOERROR, 0))\n    return err;\n  /* Create a new node set NEW_NODES with the nodes which are epsilon\n     closures of the node in CUR_NODES.  */\n\n  for (idx = 0; idx < cur_nodes->nelem; ++idx)\n    {\n      int cur_node = cur_nodes->elems[idx];\n      const re_node_set *eclosure = dfa->eclosures + cur_node;\n      outside_node = find_subexp_node (dfa, eclosure, ex_subexp, type);\n      if (outside_node == -1)\n\t{\n\t  /* There are no problematic nodes, just merge them.  */\n\t  err = re_node_set_merge (&new_nodes, eclosure);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    {\n\t      re_node_set_free (&new_nodes);\n\t      return err;\n\t    }\n\t}\n      else\n\t{\n\t  /* There are problematic nodes, re-calculate incrementally.  */\n\t  err = check_arrival_expand_ecl_sub (dfa, &new_nodes, cur_node,\n\t\t\t\t\t      ex_subexp, type);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    {\n\t      re_node_set_free (&new_nodes);\n\t      return err;\n\t    }\n\t}\n    }\n  re_node_set_free (cur_nodes);\n  *cur_nodes = new_nodes;\n  return REG_NOERROR;\n}",
      "lines": 47,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "check_arrival_expand_ecl_sub": {
      "start_point": [
        3127,
        0
      ],
      "end_point": [
        3164,
        1
      ],
      "content": "static reg_errcode_t\n__attribute_warn_unused_result__\ncheck_arrival_expand_ecl_sub (const re_dfa_t *dfa, re_node_set *dst_nodes,\n\t\t\t      int target, int ex_subexp, int type)\n{\n  int cur_node;\n  for (cur_node = target; !re_node_set_contains (dst_nodes, cur_node);)\n    {\n      int err;\n\n      if (dfa->nodes[cur_node].type == type\n\t  && dfa->nodes[cur_node].opr.idx == ex_subexp)\n\t{\n\t  if (type == OP_CLOSE_SUBEXP)\n\t    {\n\t      err = re_node_set_insert (dst_nodes, cur_node);\n\t      if (BE (err == -1, 0))\n\t\treturn REG_ESPACE;\n\t    }\n\t  break;\n\t}\n      err = re_node_set_insert (dst_nodes, cur_node);\n      if (BE (err == -1, 0))\n\treturn REG_ESPACE;\n      if (dfa->edests[cur_node].nelem == 0)\n\tbreak;\n      if (dfa->edests[cur_node].nelem == 2)\n\t{\n\t  err = check_arrival_expand_ecl_sub (dfa, dst_nodes,\n\t\t\t\t\t      dfa->edests[cur_node].elems[1],\n\t\t\t\t\t      ex_subexp, type);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return err;\n\t}\n      cur_node = dfa->edests[cur_node].elems[0];\n    }\n  return REG_NOERROR;\n}",
      "lines": 38,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "__attribute_warn_unused_result__",
        "__attribute_warn_unused_result__"
      ]
    },
    "expand_bkref_cache": {
      "start_point": [
        3171,
        0
      ],
      "end_point": [
        3255,
        1
      ],
      "content": "static reg_errcode_t\n__attribute_warn_unused_result__\nexpand_bkref_cache (re_match_context_t *mctx, re_node_set *cur_nodes,\n\t\t    int cur_str, int subexp_num, int type)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  reg_errcode_t err;\n  int cache_idx_start = search_cur_bkref_entry (mctx, cur_str);\n  struct re_backref_cache_entry *ent;\n\n  if (cache_idx_start == -1)\n    return REG_NOERROR;\n\n restart:\n  ent = mctx->bkref_ents + cache_idx_start;\n  do\n    {\n      int to_idx, next_node;\n\n      /* Is this entry ENT is appropriate?  */\n      if (!re_node_set_contains (cur_nodes, ent->node))\n\tcontinue; /* No.  */\n\n      to_idx = cur_str + ent->subexp_to - ent->subexp_from;\n      /* Calculate the destination of the back reference, and append it\n\t to MCTX->STATE_LOG.  */\n      if (to_idx == cur_str)\n\t{\n\t  /* The backreference did epsilon transit, we must re-check all the\n\t     node in the current state.  */\n\t  re_node_set new_dests;\n\t  reg_errcode_t err2, err3;\n\t  next_node = dfa->edests[ent->node].elems[0];\n\t  if (re_node_set_contains (cur_nodes, next_node))\n\t    continue;\n\t  err = re_node_set_init_1 (&new_dests, next_node);\n\t  err2 = check_arrival_expand_ecl (dfa, &new_dests, subexp_num, type);\n\t  err3 = re_node_set_merge (cur_nodes, &new_dests);\n\t  re_node_set_free (&new_dests);\n\t  if (BE (err != REG_NOERROR || err2 != REG_NOERROR\n\t\t  || err3 != REG_NOERROR, 0))\n\t    {\n\t      err = (err != REG_NOERROR ? err\n\t\t     : (err2 != REG_NOERROR ? err2 : err3));\n\t      return err;\n\t    }\n\t  /* TODO: It is still inefficient...  */\n\t  goto restart;\n\t}\n      else\n\t{\n\t  re_node_set union_set;\n\t  next_node = dfa->nexts[ent->node];\n\t  if (mctx->state_log[to_idx])\n\t    {\n\t      int ret;\n\t      if (re_node_set_contains (&mctx->state_log[to_idx]->nodes,\n\t\t\t\t\tnext_node))\n\t\tcontinue;\n\t      err = re_node_set_init_copy (&union_set,\n\t\t\t\t\t   &mctx->state_log[to_idx]->nodes);\n\t      ret = re_node_set_insert (&union_set, next_node);\n\t      if (BE (err != REG_NOERROR || ret < 0, 0))\n\t\t{\n\t\t  re_node_set_free (&union_set);\n\t\t  err = err != REG_NOERROR ? err : REG_ESPACE;\n\t\t  return err;\n\t\t}\n\t    }\n\t  else\n\t    {\n\t      err = re_node_set_init_1 (&union_set, next_node);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\treturn err;\n\t    }\n\t  mctx->state_log[to_idx] = re_acquire_state (&err, dfa, &union_set);\n\t  re_node_set_free (&union_set);\n\t  if (BE (mctx->state_log[to_idx] == NULL\n\t\t  && err != REG_NOERROR, 0))\n\t    return err;\n\t}\n    }\n  while (ent++->more);\n  return REG_NOERROR;\n}",
      "lines": 85,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "__attribute_warn_unused_result__",
        "__attribute_warn_unused_result__"
      ]
    },
    "build_trtable": {
      "start_point": [
        3260,
        0
      ],
      "end_point": [
        3492,
        1
      ],
      "content": "static int\nbuild_trtable (const re_dfa_t *dfa, re_dfastate_t *state)\n{\n  reg_errcode_t err;\n  int i, j, ch, need_word_trtable = 0;\n  bitset_word_t elem, mask;\n  bool dests_node_malloced = false;\n  bool dest_states_malloced = false;\n  int ndests; /* Number of the destination states from `state'.  */\n  re_dfastate_t **trtable;\n  re_dfastate_t **dest_states = NULL, **dest_states_word, **dest_states_nl;\n  re_node_set follows, *dests_node;\n  bitset_t *dests_ch;\n  bitset_t acceptable;\n\n  struct dests_alloc\n  {\n    re_node_set dests_node[SBC_MAX];\n    bitset_t dests_ch[SBC_MAX];\n  } *dests_alloc;\n\n  /* We build DFA states which corresponds to the destination nodes\n     from `state'.  `dests_node[i]' represents the nodes which i-th\n     destination state contains, and `dests_ch[i]' represents the\n     characters which i-th destination state accepts.  */\n#ifdef HAVE_ALLOCA\n  if (__libc_use_alloca (sizeof (struct dests_alloc)))\n    dests_alloc = (struct dests_alloc *) alloca (sizeof (struct dests_alloc));\n  else\n#endif\n    {\n      dests_alloc = re_malloc (struct dests_alloc, 1);\n      if (BE (dests_alloc == NULL, 0))\n\treturn 0;\n      dests_node_malloced = true;\n    }\n  dests_node = dests_alloc->dests_node;\n  dests_ch = dests_alloc->dests_ch;\n\n  /* Initialize transiton table.  */\n  state->word_trtable = state->trtable = NULL;\n\n  /* At first, group all nodes belonging to `state' into several\n     destinations.  */\n  ndests = group_nodes_into_DFAstates (dfa, state, dests_node, dests_ch);\n  if (BE (ndests <= 0, 0))\n    {\n      if (dests_node_malloced)\n\tre_free (dests_alloc);\n      /* Return 0 in case of an error, 1 otherwise.  */\n      if (ndests == 0)\n\t{\n\t  state->trtable = (re_dfastate_t **)\n\t    calloc (sizeof (re_dfastate_t *), SBC_MAX);\n\t  if (BE (state->trtable == NULL, 0))\n\t    return 0;\n\t  return 1;\n\t}\n      return 0;\n    }\n\n  err = re_node_set_alloc (&follows, ndests + 1);\n  if (BE (err != REG_NOERROR, 0))\n    goto out_free;\n\n  /* Avoid arithmetic overflow in size calculation.  */\n  if (BE ((((SIZE_MAX - (sizeof (re_node_set) + sizeof (bitset_t)) * SBC_MAX)\n\t    / (3 * sizeof (re_dfastate_t *)))\n\t   < ndests),\n\t  0))\n    goto out_free;\n\n#ifdef HAVE_ALLOCA\n  if (__libc_use_alloca ((sizeof (re_node_set) + sizeof (bitset_t)) * SBC_MAX\n\t\t\t + ndests * 3 * sizeof (re_dfastate_t *)))\n    dest_states = (re_dfastate_t **)\n      alloca (ndests * 3 * sizeof (re_dfastate_t *));\n  else\n#endif\n    {\n      dest_states =\n\tre_malloc (re_dfastate_t *, ndests * 3);\n      if (BE (dest_states == NULL, 0))\n\t{\nout_free:\n\t  if (dest_states_malloced)\n\t    re_free (dest_states);\n\t  re_node_set_free (&follows);\n\t  for (i = 0; i < ndests; ++i)\n\t    re_node_set_free (dests_node + i);\n\t  if (dests_node_malloced)\n\t    re_free (dests_alloc);\n\t  return 0;\n\t}\n      dest_states_malloced = true;\n    }\n  dest_states_word = dest_states + ndests;\n  dest_states_nl = dest_states_word + ndests;\n  bitset_empty (acceptable);\n\n  /* Then build the states for all destinations.  */\n  for (i = 0; i < ndests; ++i)\n    {\n      int next_node;\n      re_node_set_empty (&follows);\n      /* Merge the follows of this destination states.  */\n      for (j = 0; j < dests_node[i].nelem; ++j)\n\t{\n\t  next_node = dfa->nexts[dests_node[i].elems[j]];\n\t  if (next_node != -1)\n\t    {\n\t      err = re_node_set_merge (&follows, dfa->eclosures + next_node);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\tgoto out_free;\n\t    }\n\t}\n      dest_states[i] = re_acquire_state_context (&err, dfa, &follows, 0);\n      if (BE (dest_states[i] == NULL && err != REG_NOERROR, 0))\n\tgoto out_free;\n      /* If the new state has context constraint,\n\t build appropriate states for these contexts.  */\n      if (dest_states[i]->has_constraint)\n\t{\n\t  dest_states_word[i] = re_acquire_state_context (&err, dfa, &follows,\n\t\t\t\t\t\t\t  CONTEXT_WORD);\n\t  if (BE (dest_states_word[i] == NULL && err != REG_NOERROR, 0))\n\t    goto out_free;\n\n\t  if (dest_states[i] != dest_states_word[i] && dfa->mb_cur_max > 1)\n\t    need_word_trtable = 1;\n\n\t  dest_states_nl[i] = re_acquire_state_context (&err, dfa, &follows,\n\t\t\t\t\t\t\tCONTEXT_NEWLINE);\n\t  if (BE (dest_states_nl[i] == NULL && err != REG_NOERROR, 0))\n\t    goto out_free;\n \t}\n      else\n\t{\n\t  dest_states_word[i] = dest_states[i];\n\t  dest_states_nl[i] = dest_states[i];\n\t}\n      bitset_merge (acceptable, dests_ch[i]);\n    }\n\n  if (!BE (need_word_trtable, 0))\n    {\n      /* We don't care about whether the following character is a word\n\t character, or we are in a single-byte character set so we can\n\t discern by looking at the character code: allocate a\n\t 256-entry transition table.  */\n      trtable = state->trtable =\n\t(re_dfastate_t **) calloc (sizeof (re_dfastate_t *), SBC_MAX);\n      if (BE (trtable == NULL, 0))\n\tgoto out_free;\n\n      /* For all characters ch...:  */\n      for (i = 0; i < BITSET_WORDS; ++i)\n\tfor (ch = i * BITSET_WORD_BITS, elem = acceptable[i], mask = 1;\n\t     elem;\n\t     mask <<= 1, elem >>= 1, ++ch)\n\t  if (BE (elem & 1, 0))\n\t    {\n\t      /* There must be exactly one destination which accepts\n\t\t character ch.  See group_nodes_into_DFAstates.  */\n\t      for (j = 0; (dests_ch[j][i] & mask) == 0; ++j)\n\t\t;\n\n\t      /* j-th destination accepts the word character ch.  */\n\t      if (dfa->word_char[i] & mask)\n\t\ttrtable[ch] = dest_states_word[j];\n\t      else\n\t\ttrtable[ch] = dest_states[j];\n\t    }\n    }\n  else\n    {\n      /* We care about whether the following character is a word\n\t character, and we are in a multi-byte character set: discern\n\t by looking at the character code: build two 256-entry\n\t transition tables, one starting at trtable[0] and one\n\t starting at trtable[SBC_MAX].  */\n      trtable = state->word_trtable =\n\t(re_dfastate_t **) calloc (sizeof (re_dfastate_t *), 2 * SBC_MAX);\n      if (BE (trtable == NULL, 0))\n\tgoto out_free;\n\n      /* For all characters ch...:  */\n      for (i = 0; i < BITSET_WORDS; ++i)\n\tfor (ch = i * BITSET_WORD_BITS, elem = acceptable[i], mask = 1;\n\t     elem;\n\t     mask <<= 1, elem >>= 1, ++ch)\n\t  if (BE (elem & 1, 0))\n\t    {\n\t      /* There must be exactly one destination which accepts\n\t\t character ch.  See group_nodes_into_DFAstates.  */\n\t      for (j = 0; (dests_ch[j][i] & mask) == 0; ++j)\n\t\t;\n\n\t      /* j-th destination accepts the word character ch.  */\n\t      trtable[ch] = dest_states[j];\n\t      trtable[ch + SBC_MAX] = dest_states_word[j];\n\t    }\n    }\n\n  /* new line */\n  if (bitset_contain (acceptable, NEWLINE_CHAR))\n    {\n      /* The current state accepts newline character.  */\n      for (j = 0; j < ndests; ++j)\n\tif (bitset_contain (dests_ch[j], NEWLINE_CHAR))\n\t  {\n\t    /* k-th destination accepts newline character.  */\n\t    trtable[NEWLINE_CHAR] = dest_states_nl[j];\n\t    if (need_word_trtable)\n\t      trtable[NEWLINE_CHAR + SBC_MAX] = dest_states_nl[j];\n\t    /* There must be only one destination which accepts\n\t       newline.  See group_nodes_into_DFAstates.  */\n\t    break;\n\t  }\n    }\n\n  if (dest_states_malloced)\n    re_free (dest_states);\n\n  re_node_set_free (&follows);\n  for (i = 0; i < ndests; ++i)\n    re_node_set_free (dests_node + i);\n\n  if (dests_node_malloced)\n    re_free (dests_alloc);\n\n  return 1;\n}",
      "lines": 233,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "group_nodes_into_DFAstates": {
      "start_point": [
        3499,
        0
      ],
      "end_point": [
        3677,
        1
      ],
      "content": "static int\ngroup_nodes_into_DFAstates (const re_dfa_t *dfa, const re_dfastate_t *state,\n\t\t\t    re_node_set *dests_node, bitset_t *dests_ch)\n{\n  reg_errcode_t err;\n  int result;\n  int i, j, k;\n  int ndests; /* Number of the destinations from `state'.  */\n  bitset_t accepts; /* Characters a node can accept.  */\n  const re_node_set *cur_nodes = &state->nodes;\n  bitset_empty (accepts);\n  ndests = 0;\n\n  /* For all the nodes belonging to `state',  */\n  for (i = 0; i < cur_nodes->nelem; ++i)\n    {\n      re_token_t *node = &dfa->nodes[cur_nodes->elems[i]];\n      re_token_type_t type = node->type;\n      unsigned int constraint = node->constraint;\n\n      /* Enumerate all single byte character this node can accept.  */\n      if (type == CHARACTER)\n\tbitset_set (accepts, node->opr.c);\n      else if (type == SIMPLE_BRACKET)\n\t{\n\t  bitset_merge (accepts, node->opr.sbcset);\n\t}\n      else if (type == OP_PERIOD)\n\t{\n#ifdef RE_ENABLE_I18N\n\t  if (dfa->mb_cur_max > 1)\n\t    bitset_merge (accepts, dfa->sb_char);\n\t  else\n#endif\n\t    bitset_set_all (accepts);\n\t  if (!(dfa->syntax & RE_DOT_NEWLINE))\n\t    bitset_clear (accepts, '\\n');\n\t  if (dfa->syntax & RE_DOT_NOT_NULL)\n\t    bitset_clear (accepts, '\\0');\n\t}\n#ifdef RE_ENABLE_I18N\n      else if (type == OP_UTF8_PERIOD)\n\t{\n\t  memset (accepts, '\\xff', sizeof (bitset_t) / 2);\n\t  if (!(dfa->syntax & RE_DOT_NEWLINE))\n\t    bitset_clear (accepts, '\\n');\n\t  if (dfa->syntax & RE_DOT_NOT_NULL)\n\t    bitset_clear (accepts, '\\0');\n\t}\n#endif\n      else\n\tcontinue;\n\n      /* Check the `accepts' and sift the characters which are not\n\t match it the context.  */\n      if (constraint)\n\t{\n\t  if (constraint & NEXT_NEWLINE_CONSTRAINT)\n\t    {\n\t      bool accepts_newline = bitset_contain (accepts, NEWLINE_CHAR);\n\t      bitset_empty (accepts);\n\t      if (accepts_newline)\n\t\tbitset_set (accepts, NEWLINE_CHAR);\n\t      else\n\t\tcontinue;\n\t    }\n\t  if (constraint & NEXT_ENDBUF_CONSTRAINT)\n\t    {\n\t      bitset_empty (accepts);\n\t      continue;\n\t    }\n\n\t  if (constraint & NEXT_WORD_CONSTRAINT)\n\t    {\n\t      bitset_word_t any_set = 0;\n\t      if (type == CHARACTER && !node->word_char)\n\t\t{\n\t\t  bitset_empty (accepts);\n\t\t  continue;\n\t\t}\n#ifdef RE_ENABLE_I18N\n\t      if (dfa->mb_cur_max > 1)\n\t\tfor (j = 0; j < BITSET_WORDS; ++j)\n\t\t  any_set |= (accepts[j] &= (dfa->word_char[j] | ~dfa->sb_char[j]));\n\t      else\n#endif\n\t\tfor (j = 0; j < BITSET_WORDS; ++j)\n\t\t  any_set |= (accepts[j] &= dfa->word_char[j]);\n\t      if (!any_set)\n\t\tcontinue;\n\t    }\n\t  if (constraint & NEXT_NOTWORD_CONSTRAINT)\n\t    {\n\t      bitset_word_t any_set = 0;\n\t      if (type == CHARACTER && node->word_char)\n\t\t{\n\t\t  bitset_empty (accepts);\n\t\t  continue;\n\t\t}\n#ifdef RE_ENABLE_I18N\n\t      if (dfa->mb_cur_max > 1)\n\t\tfor (j = 0; j < BITSET_WORDS; ++j)\n\t\t  any_set |= (accepts[j] &= ~(dfa->word_char[j] & dfa->sb_char[j]));\n\t      else\n#endif\n\t\tfor (j = 0; j < BITSET_WORDS; ++j)\n\t\t  any_set |= (accepts[j] &= ~dfa->word_char[j]);\n\t      if (!any_set)\n\t\tcontinue;\n\t    }\n\t}\n\n      /* Then divide `accepts' into DFA states, or create a new\n\t state.  Above, we make sure that accepts is not empty.  */\n      for (j = 0; j < ndests; ++j)\n\t{\n\t  bitset_t intersec; /* Intersection sets, see below.  */\n\t  bitset_t remains;\n\t  /* Flags, see below.  */\n\t  bitset_word_t has_intersec, not_subset, not_consumed;\n\n\t  /* Optimization, skip if this state doesn't accept the character.  */\n\t  if (type == CHARACTER && !bitset_contain (dests_ch[j], node->opr.c))\n\t    continue;\n\n\t  /* Enumerate the intersection set of this state and `accepts'.  */\n\t  has_intersec = 0;\n\t  for (k = 0; k < BITSET_WORDS; ++k)\n\t    has_intersec |= intersec[k] = accepts[k] & dests_ch[j][k];\n\t  /* And skip if the intersection set is empty.  */\n\t  if (!has_intersec)\n\t    continue;\n\n\t  /* Then check if this state is a subset of `accepts'.  */\n\t  not_subset = not_consumed = 0;\n\t  for (k = 0; k < BITSET_WORDS; ++k)\n\t    {\n\t      not_subset |= remains[k] = ~accepts[k] & dests_ch[j][k];\n\t      not_consumed |= accepts[k] = accepts[k] & ~dests_ch[j][k];\n\t    }\n\n\t  /* If this state isn't a subset of `accepts', create a\n\t     new group state, which has the `remains'. */\n\t  if (not_subset)\n\t    {\n\t      bitset_copy (dests_ch[ndests], remains);\n\t      bitset_copy (dests_ch[j], intersec);\n\t      err = re_node_set_init_copy (dests_node + ndests, &dests_node[j]);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\tgoto error_return;\n\t      ++ndests;\n\t    }\n\n\t  /* Put the position in the current group. */\n\t  result = re_node_set_insert (&dests_node[j], cur_nodes->elems[i]);\n\t  if (BE (result < 0, 0))\n\t    goto error_return;\n\n\t  /* If all characters are consumed, go to next node. */\n\t  if (!not_consumed)\n\t    break;\n\t}\n      /* Some characters remain, create a new group. */\n      if (j == ndests)\n\t{\n\t  bitset_copy (dests_ch[ndests], accepts);\n\t  err = re_node_set_init_1 (dests_node + ndests, cur_nodes->elems[i]);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    goto error_return;\n\t  ++ndests;\n\t  bitset_empty (accepts);\n\t}\n    }\n  return ndests;\n error_return:\n  for (j = 0; j < ndests; ++j)\n    re_node_set_free (dests_node + j);\n  return -1;\n}",
      "lines": 179,
      "depth": 21,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "check_node_accept_bytes": {
      "start_point": [
        3692,
        0
      ],
      "end_point": [
        3920,
        1
      ],
      "content": "static int\ncheck_node_accept_bytes (const re_dfa_t *dfa, int node_idx,\n\t\t\t const re_string_t *input, int str_idx)\n{\n  const re_token_t *node = dfa->nodes + node_idx;\n  int char_len, elem_len;\n  int i;\n  wint_t wc;\n\n  if (BE (node->type == OP_UTF8_PERIOD, 0))\n    {\n      unsigned char c = re_string_byte_at (input, str_idx), d;\n      if (BE (c < 0xc2, 1))\n\treturn 0;\n\n      if (str_idx + 2 > input->len)\n\treturn 0;\n\n      d = re_string_byte_at (input, str_idx + 1);\n      if (c < 0xe0)\n\treturn (d < 0x80 || d > 0xbf) ? 0 : 2;\n      else if (c < 0xf0)\n\t{\n\t  char_len = 3;\n\t  if (c == 0xe0 && d < 0xa0)\n\t    return 0;\n\t}\n      else if (c < 0xf8)\n\t{\n\t  char_len = 4;\n\t  if (c == 0xf0 && d < 0x90)\n\t    return 0;\n\t}\n      else if (c < 0xfc)\n\t{\n\t  char_len = 5;\n\t  if (c == 0xf8 && d < 0x88)\n\t    return 0;\n\t}\n      else if (c < 0xfe)\n\t{\n\t  char_len = 6;\n\t  if (c == 0xfc && d < 0x84)\n\t    return 0;\n\t}\n      else\n\treturn 0;\n\n      if (str_idx + char_len > input->len)\n\treturn 0;\n\n      for (i = 1; i < char_len; ++i)\n\t{\n\t  d = re_string_byte_at (input, str_idx + i);\n\t  if (d < 0x80 || d > 0xbf)\n\t    return 0;\n\t}\n      return char_len;\n    }\n\n  char_len = re_string_char_size_at (input, str_idx);\n  if (node->type == OP_PERIOD)\n    {\n      if (char_len <= 1)\n\treturn 0;\n      /* FIXME: I don't think this if is needed, as both '\\n'\n\t and '\\0' are char_len == 1.  */\n      /* '.' accepts any one character except the following two cases.  */\n      if ((!(dfa->syntax & RE_DOT_NEWLINE) &&\n\t   re_string_byte_at (input, str_idx) == '\\n') ||\n\t  ((dfa->syntax & RE_DOT_NOT_NULL) &&\n\t   re_string_byte_at (input, str_idx) == '\\0'))\n\treturn 0;\n      return char_len;\n    }\n\n  elem_len = re_string_elem_size_at (input, str_idx);\n  wc = __btowc(*(input->mbs+str_idx));\n  if (((elem_len <= 1 && char_len <= 1) || char_len == 0) && (wc != WEOF && wc < SBC_MAX))\n    return 0;\n\n  if (node->type == COMPLEX_BRACKET)\n    {\n      const re_charset_t *cset = node->opr.mbcset;\n# ifdef _LIBC\n      const unsigned char *pin\n\t= ((const unsigned char *) re_string_get_buffer (input) + str_idx);\n      int j;\n      uint32_t nrules;\n# endif /* _LIBC */\n      int match_len = 0;\n      wchar_t wc = ((cset->nranges || cset->nchar_classes || cset->nmbchars)\n\t\t    ? re_string_wchar_at (input, str_idx) : 0);\n\n      /* match with multibyte character?  */\n      for (i = 0; i < cset->nmbchars; ++i)\n\tif (wc == cset->mbchars[i])\n\t  {\n\t    match_len = char_len;\n\t    goto check_node_accept_bytes_match;\n\t  }\n      /* match with character_class?  */\n      for (i = 0; i < cset->nchar_classes; ++i)\n\t{\n\t  wctype_t wt = cset->char_classes[i];\n\t  if (__iswctype (wc, wt))\n\t    {\n\t      match_len = char_len;\n\t      goto check_node_accept_bytes_match;\n\t    }\n\t}\n\n# ifdef _LIBC\n      nrules = _NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_NRULES);\n      if (nrules != 0)\n\t{\n\t  unsigned int in_collseq = 0;\n\t  const int32_t *table, *indirect;\n\t  const unsigned char *weights, *extra;\n\t  const char *collseqwc;\n\n\t  /* match with collating_symbol?  */\n\t  if (cset->ncoll_syms)\n\t    extra = (const unsigned char *)\n\t      _NL_CURRENT (LC_COLLATE, _NL_COLLATE_SYMB_EXTRAMB);\n\t  for (i = 0; i < cset->ncoll_syms; ++i)\n\t    {\n\t      const unsigned char *coll_sym = extra + cset->coll_syms[i];\n\t      /* Compare the length of input collating element and\n\t\t the length of current collating element.  */\n\t      if (*coll_sym != elem_len)\n\t\tcontinue;\n\t      /* Compare each bytes.  */\n\t      for (j = 0; j < *coll_sym; j++)\n\t\tif (pin[j] != coll_sym[1 + j])\n\t\t  break;\n\t      if (j == *coll_sym)\n\t\t{\n\t\t  /* Match if every bytes is equal.  */\n\t\t  match_len = j;\n\t\t  goto check_node_accept_bytes_match;\n\t\t}\n\t    }\n\n\t  if (cset->nranges)\n\t    {\n\t      if (elem_len <= char_len)\n\t\t{\n\t\t  collseqwc = _NL_CURRENT (LC_COLLATE, _NL_COLLATE_COLLSEQWC);\n\t\t  in_collseq = __collseq_table_lookup (collseqwc, wc);\n\t\t}\n\t      else\n\t\tin_collseq = find_collation_sequence_value (pin, elem_len);\n\t    }\n\t  /* match with range expression?  */\n\t  for (i = 0; i < cset->nranges; ++i)\n\t    if (cset->range_starts[i] <= in_collseq\n\t\t&& in_collseq <= cset->range_ends[i])\n\t      {\n\t\tmatch_len = elem_len;\n\t\tgoto check_node_accept_bytes_match;\n\t      }\n\n\t  /* match with equivalence_class?  */\n\t  if (cset->nequiv_classes)\n\t    {\n\t      const unsigned char *cp = pin;\n\t      table = (const int32_t *)\n\t\t_NL_CURRENT (LC_COLLATE, _NL_COLLATE_TABLEMB);\n\t      weights = (const unsigned char *)\n\t\t_NL_CURRENT (LC_COLLATE, _NL_COLLATE_WEIGHTMB);\n\t      extra = (const unsigned char *)\n\t\t_NL_CURRENT (LC_COLLATE, _NL_COLLATE_EXTRAMB);\n\t      indirect = (const int32_t *)\n\t\t_NL_CURRENT (LC_COLLATE, _NL_COLLATE_INDIRECTMB);\n\t      int32_t idx = findidx (table, indirect, extra, &cp, elem_len);\n\t      if (idx > 0)\n\t\tfor (i = 0; i < cset->nequiv_classes; ++i)\n\t\t  {\n\t\t    int32_t equiv_class_idx = cset->equiv_classes[i];\n\t\t    size_t weight_len = weights[idx & 0xffffff];\n\t\t    if (weight_len == weights[equiv_class_idx & 0xffffff]\n\t\t\t&& (idx >> 24) == (equiv_class_idx >> 24))\n\t\t      {\n\t\t\tint cnt = 0;\n\n\t\t\tidx &= 0xffffff;\n\t\t\tequiv_class_idx &= 0xffffff;\n\n\t\t\twhile (cnt <= weight_len\n\t\t\t       && (weights[equiv_class_idx + 1 + cnt]\n\t\t\t\t   == weights[idx + 1 + cnt]))\n\t\t\t  ++cnt;\n\t\t\tif (cnt > weight_len)\n\t\t\t  {\n\t\t\t    match_len = elem_len;\n\t\t\t    goto check_node_accept_bytes_match;\n\t\t\t  }\n\t\t      }\n\t\t  }\n\t    }\n\t}\n      else\n# endif /* _LIBC */\n\t{\n\t  /* match with range expression?  */\n\t  for (i = 0; i < cset->nranges; ++i)\n\t    {\n              if (cset->range_starts[i] <= wc\n                  && wc <= cset->range_ends[i])\n\t\t{\n\t\t  match_len = char_len;\n\t\t  goto check_node_accept_bytes_match;\n\t\t}\n\t    }\n\t}\n    check_node_accept_bytes_match:\n      if (!cset->non_match)\n\treturn match_len;\n      else\n\t{\n\t  if (match_len > 0)\n\t    return 0;\n\t  else\n\t    return (elem_len > char_len) ? elem_len : char_len;\n\t}\n    }\n  return 0;\n}",
      "lines": 229,
      "depth": 23,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "find_collation_sequence_value": {
      "start_point": [
        3923,
        0
      ],
      "end_point": [
        3978,
        1
      ],
      "content": "static unsigned int\nfind_collation_sequence_value (const unsigned char *mbs, size_t mbs_len)\n{\n  uint32_t nrules = _NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_NRULES);\n  if (nrules == 0)\n    {\n      if (mbs_len == 1)\n\t{\n\t  /* No valid character.  Match it as a single byte character.  */\n\t  const unsigned char *collseq = (const unsigned char *)\n\t    _NL_CURRENT (LC_COLLATE, _NL_COLLATE_COLLSEQMB);\n\t  return collseq[mbs[0]];\n\t}\n      return UINT_MAX;\n    }\n  else\n    {\n      int32_t idx;\n      const unsigned char *extra = (const unsigned char *)\n\t_NL_CURRENT (LC_COLLATE, _NL_COLLATE_SYMB_EXTRAMB);\n      int32_t extrasize = (const unsigned char *)\n\t_NL_CURRENT (LC_COLLATE, _NL_COLLATE_SYMB_EXTRAMB + 1) - extra;\n\n      for (idx = 0; idx < extrasize;)\n\t{\n\t  int mbs_cnt, found = 0;\n\t  int32_t elem_mbs_len;\n\t  /* Skip the name of collating element name.  */\n\t  idx = idx + extra[idx] + 1;\n\t  elem_mbs_len = extra[idx++];\n\t  if (mbs_len == elem_mbs_len)\n\t    {\n\t      for (mbs_cnt = 0; mbs_cnt < elem_mbs_len; ++mbs_cnt)\n\t\tif (extra[idx + mbs_cnt] != mbs[mbs_cnt])\n\t\t  break;\n\t      if (mbs_cnt == elem_mbs_len)\n\t\t/* Found the entry.  */\n\t\tfound = 1;\n\t    }\n\t  /* Skip the byte sequence of the collating element.  */\n\t  idx += elem_mbs_len;\n\t  /* Adjust for the alignment.  */\n\t  idx = (idx + 3) & ~3;\n\t  /* Skip the collation sequence value.  */\n\t  idx += sizeof (uint32_t);\n\t  /* Skip the wide char sequence of the collating element.  */\n\t  idx = idx + sizeof (uint32_t) * (*(int32_t *) (extra + idx) + 1);\n\t  /* If we found the entry, return the sequence value.  */\n\t  if (found)\n\t    return *(uint32_t *) (extra + idx);\n\t  /* Skip the collation sequence value.  */\n\t  idx += sizeof (uint32_t);\n\t}\n      return UINT_MAX;\n    }\n}",
      "lines": 56,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "unsigned int",
        "unsigned",
        "int"
      ]
    },
    "check_node_accept": {
      "start_point": [
        3985,
        0
      ],
      "end_point": [
        4030,
        1
      ],
      "content": "static int\ncheck_node_accept (const re_match_context_t *mctx, const re_token_t *node,\n\t\t   int idx)\n{\n  unsigned char ch;\n  ch = re_string_byte_at (&mctx->input, idx);\n  switch (node->type)\n    {\n    case CHARACTER:\n      if (node->opr.c != ch)\n\treturn 0;\n      break;\n\n    case SIMPLE_BRACKET:\n      if (!bitset_contain (node->opr.sbcset, ch))\n\treturn 0;\n      break;\n\n#ifdef RE_ENABLE_I18N\n    case OP_UTF8_PERIOD:\n      if (ch >= 0x80)\n\treturn 0;\n      /* FALLTHROUGH */\n#endif\n    case OP_PERIOD:\n      if ((ch == '\\n' && !(mctx->dfa->syntax & RE_DOT_NEWLINE))\n\t  || (ch == '\\0' && (mctx->dfa->syntax & RE_DOT_NOT_NULL)))\n\treturn 0;\n      break;\n\n    default:\n      return 0;\n    }\n\n  if (node->constraint)\n    {\n      /* The node has constraints.  Check whether the current context\n\t satisfies the constraints.  */\n      unsigned int context = re_string_context_at (&mctx->input, idx,\n\t\t\t\t\t\t   mctx->eflags);\n      if (NOT_SATISFY_NEXT_CONSTRAINT (node->constraint, context))\n\treturn 0;\n    }\n\n  return 1;\n}",
      "lines": 46,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "extend_buffers": {
      "start_point": [
        4034,
        0
      ],
      "end_point": [
        4092,
        1
      ],
      "content": "static reg_errcode_t\n__attribute_warn_unused_result__\nextend_buffers (re_match_context_t *mctx, int min_len)\n{\n  reg_errcode_t ret;\n  re_string_t *pstr = &mctx->input;\n\n  /* Avoid overflow.  */\n  if (BE (INT_MAX / 2 / sizeof (re_dfastate_t *) <= pstr->bufs_len, 0))\n    return REG_ESPACE;\n\n  /* Double the lengthes of the buffers, but allocate at least MIN_LEN.  */\n  ret = re_string_realloc_buffers (pstr,\n\t\t\t\t   MAX (min_len,\n\t\t\t\t\tMIN (pstr->len, pstr->bufs_len * 2)));\n  if (BE (ret != REG_NOERROR, 0))\n    return ret;\n\n  if (mctx->state_log != NULL)\n    {\n      /* And double the length of state_log.  */\n      /* XXX We have no indication of the size of this buffer.  If this\n\t allocation fail we have no indication that the state_log array\n\t does not have the right size.  */\n      re_dfastate_t **new_array = re_realloc (mctx->state_log, re_dfastate_t *,\n\t\t\t\t\t      pstr->bufs_len + 1);\n      if (BE (new_array == NULL, 0))\n\treturn REG_ESPACE;\n      mctx->state_log = new_array;\n    }\n\n  /* Then reconstruct the buffers.  */\n  if (pstr->icase)\n    {\n#ifdef RE_ENABLE_I18N\n      if (pstr->mb_cur_max > 1)\n\t{\n\t  ret = build_wcs_upper_buffer (pstr);\n\t  if (BE (ret != REG_NOERROR, 0))\n\t    return ret;\n\t}\n      else\n#endif /* RE_ENABLE_I18N  */\n\tbuild_upper_buffer (pstr);\n    }\n  else\n    {\n#ifdef RE_ENABLE_I18N\n      if (pstr->mb_cur_max > 1)\n\tbuild_wcs_buffer (pstr);\n      else\n#endif /* RE_ENABLE_I18N  */\n\t{\n\t  if (pstr->trans != NULL)\n\t    re_string_translate_buffer (pstr);\n\t}\n    }\n  return REG_NOERROR;\n}",
      "lines": 59,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "__attribute_warn_unused_result__",
        "__attribute_warn_unused_result__"
      ]
    },
    "match_ctx_init": {
      "start_point": [
        4099,
        0
      ],
      "end_point": [
        4121,
        1
      ],
      "content": "static reg_errcode_t\n__attribute_warn_unused_result__\nmatch_ctx_init (re_match_context_t *mctx, int eflags, int n)\n{\n  mctx->eflags = eflags;\n  mctx->match_last = -1;\n  if (n > 0)\n    {\n      mctx->bkref_ents = re_malloc (struct re_backref_cache_entry, n);\n      mctx->sub_tops = re_malloc (re_sub_match_top_t *, n);\n      if (BE (mctx->bkref_ents == NULL || mctx->sub_tops == NULL, 0))\n\treturn REG_ESPACE;\n    }\n  /* Already zero-ed by the caller.\n     else\n       mctx->bkref_ents = NULL;\n     mctx->nbkref_ents = 0;\n     mctx->nsub_tops = 0;  */\n  mctx->abkref_ents = n;\n  mctx->max_mb_elem_len = 1;\n  mctx->asub_tops = n;\n  return REG_NOERROR;\n}",
      "lines": 23,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "__attribute_warn_unused_result__",
        "__attribute_warn_unused_result__"
      ]
    },
    "match_ctx_clean": {
      "start_point": [
        4127,
        0
      ],
      "end_point": [
        4152,
        1
      ],
      "content": "static void\nmatch_ctx_clean (re_match_context_t *mctx)\n{\n  int st_idx;\n  for (st_idx = 0; st_idx < mctx->nsub_tops; ++st_idx)\n    {\n      int sl_idx;\n      re_sub_match_top_t *top = mctx->sub_tops[st_idx];\n      for (sl_idx = 0; sl_idx < top->nlasts; ++sl_idx)\n\t{\n\t  re_sub_match_last_t *last = top->lasts[sl_idx];\n\t  re_free (last->path.array);\n\t  re_free (last);\n\t}\n      re_free (top->lasts);\n      if (top->path)\n\t{\n\t  re_free (top->path->array);\n\t  re_free (top->path);\n\t}\n      re_free (top);\n    }\n\n  mctx->nsub_tops = 0;\n  mctx->nbkref_ents = 0;\n}",
      "lines": 26,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "match_ctx_free": {
      "start_point": [
        4156,
        0
      ],
      "end_point": [
        4163,
        1
      ],
      "content": "static void\nmatch_ctx_free (re_match_context_t *mctx)\n{\n  /* First, free all the memory associated with MCTX->SUB_TOPS.  */\n  match_ctx_clean (mctx);\n  re_free (mctx->sub_tops);\n  re_free (mctx->bkref_ents);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "match_ctx_add_entry": {
      "start_point": [
        4170,
        0
      ],
      "end_point": [
        4214,
        1
      ],
      "content": "static reg_errcode_t\n__attribute_warn_unused_result__\nmatch_ctx_add_entry (re_match_context_t *mctx, int node, int str_idx, int from,\n\t\t     int to)\n{\n  if (mctx->nbkref_ents >= mctx->abkref_ents)\n    {\n      struct re_backref_cache_entry* new_entry;\n      new_entry = re_realloc (mctx->bkref_ents, struct re_backref_cache_entry,\n\t\t\t      mctx->abkref_ents * 2);\n      if (BE (new_entry == NULL, 0))\n\t{\n\t  re_free (mctx->bkref_ents);\n\t  return REG_ESPACE;\n\t}\n      mctx->bkref_ents = new_entry;\n      memset (mctx->bkref_ents + mctx->nbkref_ents, '\\0',\n\t      sizeof (struct re_backref_cache_entry) * mctx->abkref_ents);\n      mctx->abkref_ents *= 2;\n    }\n  if (mctx->nbkref_ents > 0\n      && mctx->bkref_ents[mctx->nbkref_ents - 1].str_idx == str_idx)\n    mctx->bkref_ents[mctx->nbkref_ents - 1].more = 1;\n\n  mctx->bkref_ents[mctx->nbkref_ents].node = node;\n  mctx->bkref_ents[mctx->nbkref_ents].str_idx = str_idx;\n  mctx->bkref_ents[mctx->nbkref_ents].subexp_from = from;\n  mctx->bkref_ents[mctx->nbkref_ents].subexp_to = to;\n\n  /* This is a cache that saves negative results of check_dst_limits_calc_pos.\n     If bit N is clear, means that this entry won't epsilon-transition to\n     an OP_OPEN_SUBEXP or OP_CLOSE_SUBEXP for the N+1-th subexpression.  If\n     it is set, check_dst_limits_calc_pos_1 will recurse and try to find one\n     such node.\n\n     A backreference does not epsilon-transition unless it is empty, so set\n     to all zeros if FROM != TO.  */\n  mctx->bkref_ents[mctx->nbkref_ents].eps_reachable_subexps_map\n    = (from == to ? ~0 : 0);\n\n  mctx->bkref_ents[mctx->nbkref_ents++].more = 0;\n  if (mctx->max_mb_elem_len < to - from)\n    mctx->max_mb_elem_len = to - from;\n  return REG_NOERROR;\n}",
      "lines": 45,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "__attribute_warn_unused_result__",
        "__attribute_warn_unused_result__"
      ]
    },
    "search_cur_bkref_entry": {
      "start_point": [
        4219,
        0
      ],
      "end_point": [
        4236,
        1
      ],
      "content": "static int\nsearch_cur_bkref_entry (const re_match_context_t *mctx, int str_idx)\n{\n  int left, right, mid, last;\n  last = right = mctx->nbkref_ents;\n  for (left = 0; left < right;)\n    {\n      mid = (left + right) / 2;\n      if (mctx->bkref_ents[mid].str_idx < str_idx)\n\tleft = mid + 1;\n      else\n\tright = mid;\n    }\n  if (left < last && mctx->bkref_ents[left].str_idx == str_idx)\n    return left;\n  else\n    return -1;\n}",
      "lines": 18,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "match_ctx_add_subtop": {
      "start_point": [
        4241,
        0
      ],
      "end_point": [
        4266,
        1
      ],
      "content": "static reg_errcode_t\n__attribute_warn_unused_result__\nmatch_ctx_add_subtop (re_match_context_t *mctx, int node, int str_idx)\n{\n#ifdef DEBUG\n  assert (mctx->sub_tops != NULL);\n  assert (mctx->asub_tops > 0);\n#endif\n  if (BE (mctx->nsub_tops == mctx->asub_tops, 0))\n    {\n      int new_asub_tops = mctx->asub_tops * 2;\n      re_sub_match_top_t **new_array = re_realloc (mctx->sub_tops,\n\t\t\t\t\t\t   re_sub_match_top_t *,\n\t\t\t\t\t\t   new_asub_tops);\n      if (BE (new_array == NULL, 0))\n\treturn REG_ESPACE;\n      mctx->sub_tops = new_array;\n      mctx->asub_tops = new_asub_tops;\n    }\n  mctx->sub_tops[mctx->nsub_tops] = calloc (1, sizeof (re_sub_match_top_t));\n  if (BE (mctx->sub_tops[mctx->nsub_tops] == NULL, 0))\n    return REG_ESPACE;\n  mctx->sub_tops[mctx->nsub_tops]->node = node;\n  mctx->sub_tops[mctx->nsub_tops++]->str_idx = str_idx;\n  return REG_NOERROR;\n}",
      "lines": 26,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "__attribute_warn_unused_result__",
        "__attribute_warn_unused_result__"
      ]
    },
    "match_ctx_add_sublast": {
      "start_point": [
        4271,
        0
      ],
      "end_point": [
        4295,
        1
      ],
      "content": "static re_sub_match_last_t *\nmatch_ctx_add_sublast (re_sub_match_top_t *subtop, int node, int str_idx)\n{\n  re_sub_match_last_t *new_entry;\n  if (BE (subtop->nlasts == subtop->alasts, 0))\n    {\n      int new_alasts = 2 * subtop->alasts + 1;\n      re_sub_match_last_t **new_array = re_realloc (subtop->lasts,\n\t\t\t\t\t\t    re_sub_match_last_t *,\n\t\t\t\t\t\t    new_alasts);\n      if (BE (new_array == NULL, 0))\n\treturn NULL;\n      subtop->lasts = new_array;\n      subtop->alasts = new_alasts;\n    }\n  new_entry = calloc (1, sizeof (re_sub_match_last_t));\n  if (BE (new_entry != NULL, 1))\n    {\n      subtop->lasts[subtop->nlasts] = new_entry;\n      new_entry->node = node;\n      new_entry->str_idx = str_idx;\n      ++subtop->nlasts;\n    }\n  return new_entry;\n}",
      "lines": 25,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "re_sub_match_last_t",
        "*\nmatch_ctx_add_sublast (re_sub_match_top_t *subtop, int node, int str_idx)",
        "*"
      ]
    },
    "sift_ctx_init": {
      "start_point": [
        4297,
        0
      ],
      "end_point": [
        4306,
        1
      ],
      "content": "static void\nsift_ctx_init (re_sift_context_t *sctx, re_dfastate_t **sifted_sts,\n\t       re_dfastate_t **limited_sts, int last_node, int last_str_idx)\n{\n  sctx->sifted_states = sifted_sts;\n  sctx->limited_states = limited_sts;\n  sctx->last_node = last_node;\n  sctx->last_str_idx = last_str_idx;\n  re_node_set_init_empty (&sctx->limits);\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "gawk/gawk-4.2.1/support/regex_internal.c": {
    "MAX": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "static int\nMAX(size_t a, size_t b)\n{\n\treturn (a > b ? a : b);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "re_string_allocate": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        69,
        1
      ],
      "content": "static reg_errcode_t\n__attribute_warn_unused_result__\nre_string_allocate (re_string_t *pstr, const char *str, int len, int init_len,\n\t\t    RE_TRANSLATE_TYPE trans, int icase, const re_dfa_t *dfa)\n{\n  reg_errcode_t ret;\n  int init_buf_len;\n\n  /* Ensure at least one character fits into the buffers.  */\n  if (init_len < dfa->mb_cur_max)\n    init_len = dfa->mb_cur_max;\n  init_buf_len = (len + 1 < init_len) ? len + 1: init_len;\n  re_string_construct_common (str, len, pstr, trans, icase, dfa);\n\n  ret = re_string_realloc_buffers (pstr, init_buf_len);\n  if (BE (ret != REG_NOERROR, 0))\n    return ret;\n\n  pstr->word_char = dfa->word_char;\n  pstr->word_ops_used = dfa->word_ops_used;\n  pstr->mbs = pstr->mbs_allocated ? pstr->mbs : (unsigned char *) str;\n  pstr->valid_len = (pstr->mbs_allocated || dfa->mb_cur_max > 1) ? 0 : len;\n  pstr->valid_raw_len = pstr->valid_len;\n  return REG_NOERROR;\n}",
      "lines": 25,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "__attribute_warn_unused_result__",
        "__attribute_warn_unused_result__"
      ]
    },
    "re_string_construct": {
      "start_point": [
        73,
        0
      ],
      "end_point": [
        132,
        1
      ],
      "content": "static reg_errcode_t\n__attribute_warn_unused_result__\nre_string_construct (re_string_t *pstr, const char *str, int len,\n\t\t     RE_TRANSLATE_TYPE trans, int icase, const re_dfa_t *dfa)\n{\n  reg_errcode_t ret;\n  memset (pstr, '\\0', sizeof (re_string_t));\n  re_string_construct_common (str, len, pstr, trans, icase, dfa);\n\n  if (len > 0)\n    {\n      ret = re_string_realloc_buffers (pstr, len + 1);\n      if (BE (ret != REG_NOERROR, 0))\n\treturn ret;\n    }\n  pstr->mbs = pstr->mbs_allocated ? pstr->mbs : (unsigned char *) str;\n\n  if (icase)\n    {\n#ifdef RE_ENABLE_I18N\n      if (dfa->mb_cur_max > 1)\n\t{\n\t  while (1)\n\t    {\n\t      ret = build_wcs_upper_buffer (pstr);\n\t      if (BE (ret != REG_NOERROR, 0))\n\t\treturn ret;\n\t      if (pstr->valid_raw_len >= len)\n\t\tbreak;\n\t      if (pstr->bufs_len > pstr->valid_len + dfa->mb_cur_max)\n\t\tbreak;\n\t      ret = re_string_realloc_buffers (pstr, pstr->bufs_len * 2);\n\t      if (BE (ret != REG_NOERROR, 0))\n\t\treturn ret;\n\t    }\n\t}\n      else\n#endif /* RE_ENABLE_I18N  */\n\tbuild_upper_buffer (pstr);\n    }\n  else\n    {\n#ifdef RE_ENABLE_I18N\n      if (dfa->mb_cur_max > 1)\n\tbuild_wcs_buffer (pstr);\n      else\n#endif /* RE_ENABLE_I18N  */\n\t{\n\t  if (trans != NULL)\n\t    re_string_translate_buffer (pstr);\n\t  else\n\t    {\n\t      pstr->valid_len = pstr->bufs_len;\n\t      pstr->valid_raw_len = pstr->bufs_len;\n\t    }\n\t}\n    }\n\n  return REG_NOERROR;\n}",
      "lines": 60,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "__attribute_warn_unused_result__",
        "__attribute_warn_unused_result__"
      ]
    },
    "re_string_realloc_buffers": {
      "start_point": [
        136,
        0
      ],
      "end_point": [
        173,
        1
      ],
      "content": "static reg_errcode_t\n__attribute_warn_unused_result__\nre_string_realloc_buffers (re_string_t *pstr, int new_buf_len)\n{\n#ifdef RE_ENABLE_I18N\n  if (pstr->mb_cur_max > 1)\n    {\n      wint_t *new_wcs;\n\n      /* Avoid overflow in realloc.  */\n      const size_t max_object_size = MAX (sizeof (wint_t), sizeof (int));\n      if (BE (SIZE_MAX / max_object_size < new_buf_len, 0))\n\treturn REG_ESPACE;\n\n      new_wcs = re_realloc (pstr->wcs, wint_t, new_buf_len);\n      if (BE (new_wcs == NULL, 0))\n\treturn REG_ESPACE;\n      pstr->wcs = new_wcs;\n      if (pstr->offsets != NULL)\n\t{\n\t  int *new_offsets = re_realloc (pstr->offsets, int, new_buf_len);\n\t  if (BE (new_offsets == NULL, 0))\n\t    return REG_ESPACE;\n\t  pstr->offsets = new_offsets;\n\t}\n    }\n#endif /* RE_ENABLE_I18N  */\n  if (pstr->mbs_allocated)\n    {\n      unsigned char *new_mbs = re_realloc (pstr->mbs, unsigned char,\n\t\t\t\t\t   new_buf_len);\n      if (BE (new_mbs == NULL, 0))\n\treturn REG_ESPACE;\n      pstr->mbs = new_mbs;\n    }\n  pstr->bufs_len = new_buf_len;\n  return REG_NOERROR;\n}",
      "lines": 38,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "__attribute_warn_unused_result__",
        "__attribute_warn_unused_result__"
      ]
    },
    "re_string_construct_common": {
      "start_point": [
        176,
        0
      ],
      "end_point": [
        192,
        1
      ],
      "content": "static void\nre_string_construct_common (const char *str, int len, re_string_t *pstr,\n\t\t\t    RE_TRANSLATE_TYPE trans, int icase,\n\t\t\t    const re_dfa_t *dfa)\n{\n  pstr->raw_mbs = (const unsigned char *) str;\n  pstr->len = len;\n  pstr->raw_len = len;\n  pstr->trans = trans;\n  pstr->icase = icase ? 1 : 0;\n  pstr->mbs_allocated = (trans != NULL || icase);\n  pstr->mb_cur_max = dfa->mb_cur_max;\n  pstr->is_utf8 = dfa->is_utf8;\n  pstr->map_notascii = dfa->map_notascii;\n  pstr->stop = pstr->len;\n  pstr->raw_stop = pstr->stop;\n}",
      "lines": 17,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "build_wcs_buffer": {
      "start_point": [
        207,
        0
      ],
      "end_point": [
        270,
        1
      ],
      "content": "static void\nbuild_wcs_buffer (re_string_t *pstr)\n{\n#ifdef _LIBC\n  unsigned char buf[MB_LEN_MAX];\n  assert (MB_LEN_MAX >= pstr->mb_cur_max);\n#else\n  unsigned char buf[64];\n#endif\n  mbstate_t prev_st;\n  int byte_idx, end_idx, remain_len;\n  size_t mbclen;\n\n  /* Build the buffers from pstr->valid_len to either pstr->len or\n     pstr->bufs_len.  */\n  end_idx = (pstr->bufs_len > pstr->len) ? pstr->len : pstr->bufs_len;\n  for (byte_idx = pstr->valid_len; byte_idx < end_idx;)\n    {\n      wchar_t wc;\n      const char *p;\n\n      remain_len = end_idx - byte_idx;\n      prev_st = pstr->cur_state;\n      /* Apply the translation if we need.  */\n      if (BE (pstr->trans != NULL, 0))\n\t{\n\t  int i, ch;\n\n\t  for (i = 0; i < pstr->mb_cur_max && i < remain_len; ++i)\n\t    {\n\t      ch = pstr->raw_mbs [pstr->raw_mbs_idx + byte_idx + i];\n\t      buf[i] = pstr->mbs[byte_idx + i] = pstr->trans[ch];\n\t    }\n\t  p = (const char *) buf;\n\t}\n      else\n\tp = (const char *) pstr->raw_mbs + pstr->raw_mbs_idx + byte_idx;\n      mbclen = __mbrtowc (&wc, p, remain_len, &pstr->cur_state);\n      if (BE (mbclen == (size_t) -1 || mbclen == 0\n\t      || (mbclen == (size_t) -2 && pstr->bufs_len >= pstr->len), 0))\n\t{\n\t  /* We treat these cases as a singlebyte character.  */\n\t  mbclen = 1;\n\t  wc = (wchar_t) pstr->raw_mbs[pstr->raw_mbs_idx + byte_idx];\n\t  if (BE (pstr->trans != NULL, 0))\n\t    wc = pstr->trans[wc];\n\t  pstr->cur_state = prev_st;\n\t}\n      else if (BE (mbclen == (size_t) -2, 0))\n\t{\n\t  /* The buffer doesn't have enough space, finish to build.  */\n\t  pstr->cur_state = prev_st;\n\t  break;\n\t}\n\n      /* Write wide character and padding.  */\n      pstr->wcs[byte_idx++] = wc;\n      /* Write paddings.  */\n      for (remain_len = byte_idx + mbclen - 1; byte_idx < remain_len ;)\n\tpstr->wcs[byte_idx++] = WEOF;\n    }\n  pstr->valid_len = byte_idx;\n  pstr->valid_raw_len = byte_idx;\n}",
      "lines": 64,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "build_wcs_upper_buffer": {
      "start_point": [
        275,
        0
      ],
      "end_point": [
        489,
        1
      ],
      "content": "static reg_errcode_t\n__attribute_warn_unused_result__\nbuild_wcs_upper_buffer (re_string_t *pstr)\n{\n  mbstate_t prev_st;\n  int src_idx, byte_idx, end_idx, remain_len;\n  size_t mbclen;\n#ifdef _LIBC\n  char buf[MB_LEN_MAX];\n  assert (MB_LEN_MAX >= pstr->mb_cur_max);\n#else\n  char buf[64];\n#endif\n\n  byte_idx = pstr->valid_len;\n  end_idx = (pstr->bufs_len > pstr->len) ? pstr->len : pstr->bufs_len;\n\n  /* The following optimization assumes that ASCII characters can be\n     mapped to wide characters with a simple cast.  */\n  if (! pstr->map_notascii && pstr->trans == NULL && !pstr->offsets_needed)\n    {\n      while (byte_idx < end_idx)\n\t{\n\t  wchar_t wc;\n\n\t  if (isascii (pstr->raw_mbs[pstr->raw_mbs_idx + byte_idx])\n\t      && mbsinit (&pstr->cur_state))\n\t    {\n\t      /* In case of a singlebyte character.  */\n\t      pstr->mbs[byte_idx]\n\t\t= toupper (pstr->raw_mbs[pstr->raw_mbs_idx + byte_idx]);\n\t      /* The next step uses the assumption that wchar_t is encoded\n\t\t ASCII-safe: all ASCII values can be converted like this.  */\n\t      pstr->wcs[byte_idx] = (wchar_t) pstr->mbs[byte_idx];\n\t      ++byte_idx;\n\t      continue;\n\t    }\n\n\t  remain_len = end_idx - byte_idx;\n\t  prev_st = pstr->cur_state;\n\t  mbclen = __mbrtowc (&wc,\n\t\t\t      ((const char *) pstr->raw_mbs + pstr->raw_mbs_idx\n\t\t\t       + byte_idx), remain_len, &pstr->cur_state);\n\t  if (BE (mbclen + 2 > 2, 1))\n\t    {\n\t      wchar_t wcu = wc;\n\t      if (iswlower (wc))\n\t\t{\n\t\t  size_t mbcdlen;\n\n\t\t  wcu = towupper (wc);\n\t\t  mbcdlen = __wcrtomb (buf, wcu, &prev_st);\n\t\t  if (BE (mbclen == mbcdlen, 1))\n\t\t    memcpy (pstr->mbs + byte_idx, buf, mbclen);\n\t\t  else\n\t\t    {\n\t\t      src_idx = byte_idx;\n\t\t      goto offsets_needed;\n\t\t    }\n\t\t}\n\t      else\n\t\tmemcpy (pstr->mbs + byte_idx,\n\t\t\tpstr->raw_mbs + pstr->raw_mbs_idx + byte_idx, mbclen);\n\t      pstr->wcs[byte_idx++] = wcu;\n\t      /* Write paddings.  */\n\t      for (remain_len = byte_idx + mbclen - 1; byte_idx < remain_len ;)\n\t\tpstr->wcs[byte_idx++] = WEOF;\n\t    }\n\t  else if (mbclen == (size_t) -1 || mbclen == 0\n\t\t   || (mbclen == (size_t) -2 && pstr->bufs_len >= pstr->len))\n\t    {\n\t      /* It is an invalid character, an incomplete character\n\t\t at the end of the string, or '\\0'.  Just use the byte.  */\n\t      int ch = pstr->raw_mbs[pstr->raw_mbs_idx + byte_idx];\n\t      pstr->mbs[byte_idx] = ch;\n\t      /* And also cast it to wide char.  */\n\t      pstr->wcs[byte_idx++] = (wchar_t) ch;\n\t      if (BE (mbclen == (size_t) -1, 0))\n\t\tpstr->cur_state = prev_st;\n\t    }\n\t  else\n\t    {\n\t      /* The buffer doesn't have enough space, finish to build.  */\n\t      pstr->cur_state = prev_st;\n\t      break;\n\t    }\n\t}\n      pstr->valid_len = byte_idx;\n      pstr->valid_raw_len = byte_idx;\n      return REG_NOERROR;\n    }\n  else\n    for (src_idx = pstr->valid_raw_len; byte_idx < end_idx;)\n      {\n\twchar_t wc;\n\tconst char *p;\n      offsets_needed:\n\tremain_len = end_idx - byte_idx;\n\tprev_st = pstr->cur_state;\n\tif (BE (pstr->trans != NULL, 0))\n\t  {\n\t    int i, ch;\n\n\t    for (i = 0; i < pstr->mb_cur_max && i < remain_len; ++i)\n\t      {\n\t\tch = pstr->raw_mbs [pstr->raw_mbs_idx + src_idx + i];\n\t\tbuf[i] = pstr->trans[ch];\n\t      }\n\t    p = (const char *) buf;\n\t  }\n\telse\n\t  p = (const char *) pstr->raw_mbs + pstr->raw_mbs_idx + src_idx;\n\tmbclen = __mbrtowc (&wc, p, remain_len, &pstr->cur_state);\n\tif (BE (mbclen + 2 > 2, 1))\n\t  {\n\t    wchar_t wcu = wc;\n\t    if (iswlower (wc))\n\t      {\n\t\tsize_t mbcdlen;\n\n\t\twcu = towupper (wc);\n\t\tmbcdlen = wcrtomb ((char *) buf, wcu, &prev_st);\n\t\tif (BE (mbclen == mbcdlen, 1))\n\t\t  memcpy (pstr->mbs + byte_idx, buf, mbclen);\n\t\telse if (mbcdlen != (size_t) -1)\n\t\t  {\n\t\t    size_t i;\n\n\t\t    if (byte_idx + mbcdlen > pstr->bufs_len)\n\t\t      {\n\t\t\tpstr->cur_state = prev_st;\n\t\t\tbreak;\n\t\t      }\n\n\t\t    if (pstr->offsets == NULL)\n\t\t      {\n\t\t\tpstr->offsets = re_malloc (int, pstr->bufs_len);\n\n\t\t\tif (pstr->offsets == NULL)\n\t\t\t  return REG_ESPACE;\n\t\t      }\n\t\t    if (!pstr->offsets_needed)\n\t\t      {\n\t\t\tfor (i = 0; i < (size_t) byte_idx; ++i)\n\t\t\t  pstr->offsets[i] = i;\n\t\t\tpstr->offsets_needed = 1;\n\t\t      }\n\n\t\t    memcpy (pstr->mbs + byte_idx, buf, mbcdlen);\n\t\t    pstr->wcs[byte_idx] = wcu;\n\t\t    pstr->offsets[byte_idx] = src_idx;\n\t\t    for (i = 1; i < mbcdlen; ++i)\n\t\t      {\n\t\t\tpstr->offsets[byte_idx + i]\n\t\t\t  = src_idx + (i < mbclen ? i : mbclen - 1);\n\t\t\tpstr->wcs[byte_idx + i] = WEOF;\n\t\t      }\n\t\t    pstr->len += mbcdlen - mbclen;\n\t\t    if (pstr->raw_stop > src_idx)\n\t\t      pstr->stop += mbcdlen - mbclen;\n\t\t    end_idx = (pstr->bufs_len > pstr->len)\n\t\t\t      ? pstr->len : pstr->bufs_len;\n\t\t    byte_idx += mbcdlen;\n\t\t    src_idx += mbclen;\n\t\t    continue;\n\t\t  }\n\t\telse\n\t\t  memcpy (pstr->mbs + byte_idx, p, mbclen);\n\t      }\n\t    else\n\t      memcpy (pstr->mbs + byte_idx, p, mbclen);\n\n\t    if (BE (pstr->offsets_needed != 0, 0))\n\t      {\n\t\tsize_t i;\n\t\tfor (i = 0; i < mbclen; ++i)\n\t\t  pstr->offsets[byte_idx + i] = src_idx + i;\n\t      }\n\t    src_idx += mbclen;\n\n\t    pstr->wcs[byte_idx++] = wcu;\n\t    /* Write paddings.  */\n\t    for (remain_len = byte_idx + mbclen - 1; byte_idx < remain_len ;)\n\t      pstr->wcs[byte_idx++] = WEOF;\n\t  }\n\telse if (mbclen == (size_t) -1 || mbclen == 0\n\t\t || (mbclen == (size_t) -2 && pstr->bufs_len >= pstr->len))\n\t  {\n\t    /* It is an invalid character or '\\0'.  Just use the byte.  */\n\t    int ch = pstr->raw_mbs[pstr->raw_mbs_idx + src_idx];\n\n\t    if (BE (pstr->trans != NULL, 0))\n\t      ch = pstr->trans [ch];\n\t    pstr->mbs[byte_idx] = ch;\n\n\t    if (BE (pstr->offsets_needed != 0, 0))\n\t      pstr->offsets[byte_idx] = src_idx;\n\t    ++src_idx;\n\n\t    /* And also cast it to wide char.  */\n\t    pstr->wcs[byte_idx++] = (wchar_t) ch;\n\t    if (BE (mbclen == (size_t) -1, 0))\n\t      pstr->cur_state = prev_st;\n\t  }\n\telse\n\t  {\n\t    /* The buffer doesn't have enough space, finish to build.  */\n\t    pstr->cur_state = prev_st;\n\t    break;\n\t  }\n      }\n  pstr->valid_len = byte_idx;\n  pstr->valid_raw_len = src_idx;\n  return REG_NOERROR;\n}",
      "lines": 215,
      "depth": 21,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "__attribute_warn_unused_result__",
        "__attribute_warn_unused_result__"
      ]
    },
    "re_string_skip_chars": {
      "start_point": [
        494,
        0
      ],
      "end_point": [
        528,
        1
      ],
      "content": "static int\nre_string_skip_chars (re_string_t *pstr, int new_raw_idx, wint_t *last_wc)\n{\n  mbstate_t prev_st;\n  int rawbuf_idx;\n  size_t mbclen;\n  wint_t wc = WEOF;\n\n  /* Skip the characters which are not necessary to check.  */\n  for (rawbuf_idx = pstr->raw_mbs_idx + pstr->valid_raw_len;\n       rawbuf_idx < new_raw_idx;)\n    {\n      wchar_t wc2;\n      int remain_len = pstr->raw_len - rawbuf_idx;\n      prev_st = pstr->cur_state;\n      mbclen = __mbrtowc (&wc2, (const char *) pstr->raw_mbs + rawbuf_idx,\n\t\t\t  remain_len, &pstr->cur_state);\n      if (BE ((ssize_t) mbclen <= 0, 0))\n\t{\n\t  /* We treat these cases as a single byte character.  */\n\t  if (mbclen == 0 || remain_len == 0)\n\t    wc = L'\\0';\n\t  else\n\t    wc = *(unsigned char *) (pstr->raw_mbs + rawbuf_idx);\n\t  mbclen = 1;\n\t  pstr->cur_state = prev_st;\n\t}\n      else\n\twc = (wint_t) wc2;\n      /* Then proceed the next character.  */\n      rawbuf_idx += mbclen;\n    }\n  *last_wc = (wint_t) wc;\n  return rawbuf_idx;\n}",
      "lines": 35,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "build_upper_buffer": {
      "start_point": [
        534,
        0
      ],
      "end_point": [
        552,
        1
      ],
      "content": "static void\nbuild_upper_buffer (re_string_t *pstr)\n{\n  int char_idx, end_idx;\n  end_idx = (pstr->bufs_len > pstr->len) ? pstr->len : pstr->bufs_len;\n\n  for (char_idx = pstr->valid_len; char_idx < end_idx; ++char_idx)\n    {\n      int ch = pstr->raw_mbs[pstr->raw_mbs_idx + char_idx];\n      if (BE (pstr->trans != NULL, 0))\n\tch = pstr->trans[ch];\n      if (islower (ch))\n\tpstr->mbs[char_idx] = toupper (ch);\n      else\n\tpstr->mbs[char_idx] = ch;\n    }\n  pstr->valid_len = char_idx;\n  pstr->valid_raw_len = char_idx;\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "re_string_translate_buffer": {
      "start_point": [
        556,
        0
      ],
      "end_point": [
        570,
        1
      ],
      "content": "static void\nre_string_translate_buffer (re_string_t *pstr)\n{\n  int buf_idx, end_idx;\n  end_idx = (pstr->bufs_len > pstr->len) ? pstr->len : pstr->bufs_len;\n\n  for (buf_idx = pstr->valid_len; buf_idx < end_idx; ++buf_idx)\n    {\n      int ch = pstr->raw_mbs[pstr->raw_mbs_idx + buf_idx];\n      pstr->mbs[buf_idx] = pstr->trans[ch];\n    }\n\n  pstr->valid_len = buf_idx;\n  pstr->valid_raw_len = buf_idx;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "re_string_reconstruct": {
      "start_point": [
        576,
        0
      ],
      "end_point": [
        834,
        1
      ],
      "content": "static reg_errcode_t\n__attribute_warn_unused_result__\nre_string_reconstruct (re_string_t *pstr, int idx, int eflags)\n{\n  int offset = idx - pstr->raw_mbs_idx;\n  if (BE (offset < 0, 0))\n    {\n      /* Reset buffer.  */\n#ifdef RE_ENABLE_I18N\n      if (pstr->mb_cur_max > 1)\n\tmemset (&pstr->cur_state, '\\0', sizeof (mbstate_t));\n#endif /* RE_ENABLE_I18N */\n      pstr->len = pstr->raw_len;\n      pstr->stop = pstr->raw_stop;\n      pstr->valid_len = 0;\n      pstr->raw_mbs_idx = 0;\n      pstr->valid_raw_len = 0;\n      pstr->offsets_needed = 0;\n      pstr->tip_context = ((eflags & REG_NOTBOL) ? CONTEXT_BEGBUF\n\t\t\t   : CONTEXT_NEWLINE | CONTEXT_BEGBUF);\n      if (!pstr->mbs_allocated)\n\tpstr->mbs = (unsigned char *) pstr->raw_mbs;\n      offset = idx;\n    }\n\n  if (BE (offset != 0, 1))\n    {\n      /* Should the already checked characters be kept?  */\n      if (BE (offset < pstr->valid_raw_len, 1))\n\t{\n\t  /* Yes, move them to the front of the buffer.  */\n#ifdef RE_ENABLE_I18N\n\t  if (BE (pstr->offsets_needed, 0))\n\t    {\n\t      int low = 0, high = pstr->valid_len, mid;\n\t      do\n\t\t{\n\t\t  mid = (high + low) / 2;\n\t\t  if (pstr->offsets[mid] > offset)\n\t\t    high = mid;\n\t\t  else if (pstr->offsets[mid] < offset)\n\t\t    low = mid + 1;\n\t\t  else\n\t\t    break;\n\t\t}\n\t      while (low < high);\n\t      if (pstr->offsets[mid] < offset)\n\t\t++mid;\n\t      pstr->tip_context = re_string_context_at (pstr, mid - 1,\n\t\t\t\t\t\t\teflags);\n\t      /* This can be quite complicated, so handle specially\n\t\t only the common and easy case where the character with\n\t\t different length representation of lower and upper\n\t\t case is present at or after offset.  */\n\t      if (pstr->valid_len > offset\n\t\t  && mid == offset && pstr->offsets[mid] == offset)\n\t\t{\n\t\t  memmove (pstr->wcs, pstr->wcs + offset,\n\t\t\t   (pstr->valid_len - offset) * sizeof (wint_t));\n\t\t  memmove (pstr->mbs, pstr->mbs + offset, pstr->valid_len - offset);\n\t\t  pstr->valid_len -= offset;\n\t\t  pstr->valid_raw_len -= offset;\n\t\t  for (low = 0; low < pstr->valid_len; low++)\n\t\t    pstr->offsets[low] = pstr->offsets[low + offset] - offset;\n\t\t}\n\t      else\n\t\t{\n\t\t  /* Otherwise, just find out how long the partial multibyte\n\t\t     character at offset is and fill it with WEOF/255.  */\n\t\t  pstr->len = pstr->raw_len - idx + offset;\n\t\t  pstr->stop = pstr->raw_stop - idx + offset;\n\t\t  pstr->offsets_needed = 0;\n\t\t  while (mid > 0 && pstr->offsets[mid - 1] == offset)\n\t\t    --mid;\n\t\t  while (mid < pstr->valid_len)\n\t\t    if (pstr->wcs[mid] != WEOF)\n\t\t      break;\n\t\t    else\n\t\t      ++mid;\n\t\t  if (mid == pstr->valid_len)\n\t\t    pstr->valid_len = 0;\n\t\t  else\n\t\t    {\n\t\t      pstr->valid_len = pstr->offsets[mid] - offset;\n\t\t      if (pstr->valid_len)\n\t\t\t{\n\t\t\t  for (low = 0; low < pstr->valid_len; ++low)\n\t\t\t    pstr->wcs[low] = WEOF;\n\t\t\t  memset (pstr->mbs, 255, pstr->valid_len);\n\t\t\t}\n\t\t    }\n\t\t  pstr->valid_raw_len = pstr->valid_len;\n\t\t}\n\t    }\n\t  else\n#endif\n\t    {\n\t      pstr->tip_context = re_string_context_at (pstr, offset - 1,\n\t\t\t\t\t\t\teflags);\n#ifdef RE_ENABLE_I18N\n\t      if (pstr->mb_cur_max > 1)\n\t\tmemmove (pstr->wcs, pstr->wcs + offset,\n\t\t\t (pstr->valid_len - offset) * sizeof (wint_t));\n#endif /* RE_ENABLE_I18N */\n\t      if (BE (pstr->mbs_allocated, 0))\n\t\tmemmove (pstr->mbs, pstr->mbs + offset,\n\t\t\t pstr->valid_len - offset);\n\t      pstr->valid_len -= offset;\n\t      pstr->valid_raw_len -= offset;\n#if defined DEBUG && DEBUG\n\t      assert (pstr->valid_len > 0);\n#endif\n\t    }\n\t}\n      else\n\t{\n#ifdef RE_ENABLE_I18N\n\t  /* No, skip all characters until IDX.  */\n\t  int prev_valid_len = pstr->valid_len;\n\n\t  if (BE (pstr->offsets_needed, 0))\n\t    {\n\t      pstr->len = pstr->raw_len - idx + offset;\n\t      pstr->stop = pstr->raw_stop - idx + offset;\n\t      pstr->offsets_needed = 0;\n\t    }\n#endif\n\t  pstr->valid_len = 0;\n#ifdef RE_ENABLE_I18N\n\t  if (pstr->mb_cur_max > 1)\n\t    {\n\t      int wcs_idx;\n\t      wint_t wc = WEOF;\n\n\t      if (pstr->is_utf8)\n\t\t{\n\t\t  const unsigned char *raw, *p, *end;\n\n\t\t  /* Special case UTF-8.  Multi-byte chars start with any\n\t\t     byte other than 0x80 - 0xbf.  */\n\t\t  raw = pstr->raw_mbs + pstr->raw_mbs_idx;\n\t\t  end = raw + (offset - pstr->mb_cur_max);\n\t\t  if (end < pstr->raw_mbs)\n\t\t    end = pstr->raw_mbs;\n\t\t  p = raw + offset - 1;\n#ifdef _LIBC\n\t\t  /* We know the wchar_t encoding is UCS4, so for the simple\n\t\t     case, ASCII characters, skip the conversion step.  */\n\t\t  if (isascii (*p) && BE (pstr->trans == NULL, 1))\n\t\t    {\n\t\t      memset (&pstr->cur_state, '\\0', sizeof (mbstate_t));\n\t\t      /* pstr->valid_len = 0; */\n\t\t      wc = (wchar_t) *p;\n\t\t    }\n\t\t  else\n#endif\n\t\t    for (; p >= end; --p)\n\t\t      if ((*p & 0xc0) != 0x80)\n\t\t\t{\n\t\t\t  mbstate_t cur_state;\n\t\t\t  wchar_t wc2;\n\t\t\t  int mlen = raw + pstr->len - p;\n\t\t\t  unsigned char buf[6];\n\t\t\t  size_t mbclen;\n\n\t\t\t  const unsigned char *pp = p;\n\t\t\t  if (BE (pstr->trans != NULL, 0))\n\t\t\t    {\n\t\t\t      int i = mlen < 6 ? mlen : 6;\n\t\t\t      while (--i >= 0)\n\t\t\t\tbuf[i] = pstr->trans[p[i]];\n\t\t\t      pp = buf;\n\t\t\t    }\n\t\t\t  /* XXX Don't use mbrtowc, we know which conversion\n\t\t\t     to use (UTF-8 -> UCS4).  */\n\t\t\t  memset (&cur_state, 0, sizeof (cur_state));\n\t\t\t  mbclen = __mbrtowc (&wc2, (const char *) pp, mlen,\n\t\t\t\t\t      &cur_state);\n\t\t\t  if (raw + offset - p <= mbclen\n\t\t\t      && mbclen < (size_t) -2)\n\t\t\t    {\n\t\t\t      memset (&pstr->cur_state, '\\0',\n\t\t\t\t      sizeof (mbstate_t));\n\t\t\t      pstr->valid_len = mbclen - (raw + offset - p);\n\t\t\t      wc = wc2;\n\t\t\t    }\n\t\t\t  break;\n\t\t\t}\n\t\t}\n\n\t      if (wc == WEOF)\n\t\tpstr->valid_len = re_string_skip_chars (pstr, idx, &wc) - idx;\n\t      if (wc == WEOF)\n\t\tpstr->tip_context\n\t\t  = re_string_context_at (pstr, prev_valid_len - 1, eflags);\n\t      else\n\t\tpstr->tip_context = ((BE (pstr->word_ops_used != 0, 0)\n\t\t\t\t      && IS_WIDE_WORD_CHAR (wc))\n\t\t\t\t     ? CONTEXT_WORD\n\t\t\t\t     : ((IS_WIDE_NEWLINE (wc)\n\t\t\t\t\t && pstr->newline_anchor)\n\t\t\t\t\t? CONTEXT_NEWLINE : 0));\n\t      if (BE (pstr->valid_len, 0))\n\t\t{\n\t\t  for (wcs_idx = 0; wcs_idx < pstr->valid_len; ++wcs_idx)\n\t\t    pstr->wcs[wcs_idx] = WEOF;\n\t\t  if (pstr->mbs_allocated)\n\t\t    memset (pstr->mbs, 255, pstr->valid_len);\n\t\t}\n\t      pstr->valid_raw_len = pstr->valid_len;\n\t    }\n\t  else\n#endif /* RE_ENABLE_I18N */\n\t    {\n\t      int c = pstr->raw_mbs[pstr->raw_mbs_idx + offset - 1];\n\t      pstr->valid_raw_len = 0;\n\t      if (pstr->trans)\n\t\tc = pstr->trans[c];\n\t      pstr->tip_context = (bitset_contain (pstr->word_char, c)\n\t\t\t\t   ? CONTEXT_WORD\n\t\t\t\t   : ((IS_NEWLINE (c) && pstr->newline_anchor)\n\t\t\t\t      ? CONTEXT_NEWLINE : 0));\n\t    }\n\t}\n      if (!BE (pstr->mbs_allocated, 0))\n\tpstr->mbs += offset;\n    }\n  pstr->raw_mbs_idx = idx;\n  pstr->len -= offset;\n  pstr->stop -= offset;\n\n  /* Then build the buffers.  */\n#ifdef RE_ENABLE_I18N\n  if (pstr->mb_cur_max > 1)\n    {\n      if (pstr->icase)\n\t{\n\t  reg_errcode_t ret = build_wcs_upper_buffer (pstr);\n\t  if (BE (ret != REG_NOERROR, 0))\n\t    return ret;\n\t}\n      else\n\tbuild_wcs_buffer (pstr);\n    }\n  else\n#endif /* RE_ENABLE_I18N */\n    if (BE (pstr->mbs_allocated, 0))\n      {\n\tif (pstr->icase)\n\t  build_upper_buffer (pstr);\n\telse if (pstr->trans != NULL)\n\t  re_string_translate_buffer (pstr);\n      }\n    else\n      pstr->valid_len = pstr->len;\n\n  pstr->cur_idx = 0;\n  return REG_NOERROR;\n}",
      "lines": 259,
      "depth": 23,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "__attribute_warn_unused_result__",
        "__attribute_warn_unused_result__"
      ]
    },
    "__attribute": [
      {
        "start_point": [
          836,
          0
        ],
        "end_point": [
          870,
          1
        ],
        "content": "static unsigned char\n__attribute ((pure))\nre_string_peek_byte_case (const re_string_t *pstr, int idx)\n{\n  int ch, off;\n\n  /* Handle the common (easiest) cases first.  */\n  if (BE (!pstr->mbs_allocated, 1))\n    return re_string_peek_byte (pstr, idx);\n\n#ifdef RE_ENABLE_I18N\n  if (pstr->mb_cur_max > 1\n      && ! re_string_is_single_byte_char (pstr, pstr->cur_idx + idx))\n    return re_string_peek_byte (pstr, idx);\n#endif\n\n  off = pstr->cur_idx + idx;\n#ifdef RE_ENABLE_I18N\n  if (pstr->offsets_needed)\n    off = pstr->offsets[off];\n#endif\n\n  ch = pstr->raw_mbs[pstr->raw_mbs_idx + off];\n\n#ifdef RE_ENABLE_I18N\n  /* Ensure that e.g. for tr_TR.UTF-8 BACKSLASH DOTLESS SMALL LETTER I\n     this function returns CAPITAL LETTER I instead of first byte of\n     DOTLESS SMALL LETTER I.  The latter would confuse the parser,\n     since peek_byte_case doesn't advance cur_idx in any way.  */\n  if (pstr->offsets_needed && !isascii (ch))\n    return re_string_peek_byte (pstr, idx);\n#endif\n\n  return ch;\n}",
        "lines": 35,
        "depth": 12,
        "decorators": [
          "static",
          "static",
          "unsigned char",
          "unsigned",
          "char",
          "__attribute ((pure))"
        ]
      },
      {
        "start_point": [
          1365,
          0
        ],
        "end_point": [
          1376,
          1
        ],
        "content": "static int\n__attribute ((pure))\nre_node_set_compare (const re_node_set *set1, const re_node_set *set2)\n{\n  int i;\n  if (set1 == NULL || set2 == NULL || set1->nelem != set2->nelem)\n    return 0;\n  for (i = set1->nelem ; --i >= 0 ; )\n    if (set1->elems[i] != set2->elems[i])\n      return 0;\n  return 1;\n}",
        "lines": 12,
        "depth": 9,
        "decorators": [
          "static",
          "static",
          "int",
          "__attribute ((pure))"
        ]
      },
      {
        "start_point": [
          1380,
          0
        ],
        "end_point": [
          1400,
          1
        ],
        "content": "static int\n__attribute ((pure))\nre_node_set_contains (const re_node_set *set, int elem)\n{\n  unsigned int idx, right, mid;\n  if (set->nelem <= 0)\n    return 0;\n\n  /* Binary search the element.  */\n  idx = 0;\n  right = set->nelem - 1;\n  while (idx < right)\n    {\n      mid = (idx + right) / 2;\n      if (set->elems[mid] < elem)\n\tidx = mid + 1;\n      else\n\tright = mid;\n    }\n  return set->elems[idx] == elem ? idx + 1 : 0;\n}",
        "lines": 21,
        "depth": 10,
        "decorators": [
          "static",
          "static",
          "int",
          "__attribute ((pure))"
        ]
      }
    ],
    "re_string_fetch_byte_case": {
      "start_point": [
        872,
        0
      ],
      "end_point": [
        906,
        1
      ],
      "content": "static unsigned char\nre_string_fetch_byte_case (re_string_t *pstr)\n{\n  if (BE (!pstr->mbs_allocated, 1))\n    return re_string_fetch_byte (pstr);\n\n#ifdef RE_ENABLE_I18N\n  if (pstr->offsets_needed)\n    {\n      int off, ch;\n\n      /* For tr_TR.UTF-8 [[:islower:]] there is\n\t [[: CAPITAL LETTER I WITH DOT lower:]] in mbs.  Skip\n\t in that case the whole multi-byte character and return\n\t the original letter.  On the other side, with\n\t [[: DOTLESS SMALL LETTER I return [[:I, as doing\n\t anything else would complicate things too much.  */\n\n      if (!re_string_first_byte (pstr, pstr->cur_idx))\n\treturn re_string_fetch_byte (pstr);\n\n      off = pstr->offsets[pstr->cur_idx];\n      ch = pstr->raw_mbs[pstr->raw_mbs_idx + off];\n\n      if (! isascii (ch))\n\treturn re_string_fetch_byte (pstr);\n\n      re_string_skip_bytes (pstr,\n\t\t\t    re_string_char_size_at (pstr, pstr->cur_idx));\n      return ch;\n    }\n#endif\n\n  return pstr->raw_mbs[pstr->raw_mbs_idx + pstr->cur_idx++];\n}",
      "lines": 35,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "unsigned char",
        "unsigned",
        "char"
      ]
    },
    "re_string_destruct": {
      "start_point": [
        908,
        0
      ],
      "end_point": [
        917,
        1
      ],
      "content": "static void\nre_string_destruct (re_string_t *pstr)\n{\n#ifdef RE_ENABLE_I18N\n  re_free (pstr->wcs);\n  re_free (pstr->offsets);\n#endif /* RE_ENABLE_I18N  */\n  if (pstr->mbs_allocated)\n    re_free (pstr->mbs);\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "re_string_context_at": {
      "start_point": [
        921,
        0
      ],
      "end_point": [
        961,
        1
      ],
      "content": "static unsigned int\nre_string_context_at (const re_string_t *input, int idx, int eflags)\n{\n  int c;\n  if (BE (idx < 0, 0))\n    /* In this case, we use the value stored in input->tip_context,\n       since we can't know the character in input->mbs[-1] here.  */\n    return input->tip_context;\n  if (BE (idx == input->len, 0))\n    return ((eflags & REG_NOTEOL) ? CONTEXT_ENDBUF\n\t    : CONTEXT_NEWLINE | CONTEXT_ENDBUF);\n#ifdef RE_ENABLE_I18N\n  if (input->mb_cur_max > 1)\n    {\n      wint_t wc;\n      int wc_idx = idx;\n      while(input->wcs[wc_idx] == WEOF)\n\t{\n#if defined DEBUG && DEBUG\n\t  /* It must not happen.  */\n\t  assert (wc_idx >= 0);\n#endif\n\t  --wc_idx;\n\t  if (wc_idx < 0)\n\t    return input->tip_context;\n\t}\n      wc = input->wcs[wc_idx];\n      if (BE (input->word_ops_used != 0, 0) && IS_WIDE_WORD_CHAR (wc))\n\treturn CONTEXT_WORD;\n      return (IS_WIDE_NEWLINE (wc) && input->newline_anchor\n\t      ? CONTEXT_NEWLINE : 0);\n    }\n  else\n#endif\n    {\n      c = re_string_byte_at (input, idx);\n      if (bitset_contain (input->word_char, c))\n\treturn CONTEXT_WORD;\n      return IS_NEWLINE (c) && input->newline_anchor ? CONTEXT_NEWLINE : 0;\n    }\n}",
      "lines": 41,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "unsigned int",
        "unsigned",
        "int"
      ]
    },
    "re_node_set_alloc": {
      "start_point": [
        965,
        0
      ],
      "end_point": [
        985,
        1
      ],
      "content": "static reg_errcode_t\n__attribute_warn_unused_result__\nre_node_set_alloc (re_node_set *set, int size)\n{\n  /*\n   * ADR: valgrind says size can be 0, which then doesn't\n   * free the block of size 0.  Harumph. This seems\n   * to work ok, though.\n   */\n  if (size == 0)\n    {\n       memset(set, 0, sizeof(*set));\n       return REG_NOERROR;\n    }\n  set->alloc = size;\n  set->nelem = 0;\n  set->elems = re_malloc (int, size);\n  if (BE (set->elems == NULL, 0))\n    return REG_ESPACE;\n  return REG_NOERROR;\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "__attribute_warn_unused_result__",
        "__attribute_warn_unused_result__"
      ]
    },
    "re_node_set_init_1": {
      "start_point": [
        987,
        0
      ],
      "end_point": [
        1001,
        1
      ],
      "content": "static reg_errcode_t\n__attribute_warn_unused_result__\nre_node_set_init_1 (re_node_set *set, int elem)\n{\n  set->alloc = 1;\n  set->nelem = 1;\n  set->elems = re_malloc (int, 1);\n  if (BE (set->elems == NULL, 0))\n    {\n      set->alloc = set->nelem = 0;\n      return REG_ESPACE;\n    }\n  set->elems[0] = elem;\n  return REG_NOERROR;\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "__attribute_warn_unused_result__",
        "__attribute_warn_unused_result__"
      ]
    },
    "re_node_set_init_2": {
      "start_point": [
        1003,
        0
      ],
      "end_point": [
        1031,
        1
      ],
      "content": "static reg_errcode_t\n__attribute_warn_unused_result__\nre_node_set_init_2 (re_node_set *set, int elem1, int elem2)\n{\n  set->alloc = 2;\n  set->elems = re_malloc (int, 2);\n  if (BE (set->elems == NULL, 0))\n    return REG_ESPACE;\n  if (elem1 == elem2)\n    {\n      set->nelem = 1;\n      set->elems[0] = elem1;\n    }\n  else\n    {\n      set->nelem = 2;\n      if (elem1 < elem2)\n\t{\n\t  set->elems[0] = elem1;\n\t  set->elems[1] = elem2;\n\t}\n      else\n\t{\n\t  set->elems[0] = elem2;\n\t  set->elems[1] = elem1;\n\t}\n    }\n  return REG_NOERROR;\n}",
      "lines": 29,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "__attribute_warn_unused_result__",
        "__attribute_warn_unused_result__"
      ]
    },
    "re_node_set_init_copy": {
      "start_point": [
        1033,
        0
      ],
      "end_point": [
        1052,
        1
      ],
      "content": "static reg_errcode_t\n__attribute_warn_unused_result__\nre_node_set_init_copy (re_node_set *dest, const re_node_set *src)\n{\n  dest->nelem = src->nelem;\n  if (src->nelem > 0)\n    {\n      dest->alloc = dest->nelem;\n      dest->elems = re_malloc (int, dest->alloc);\n      if (BE (dest->elems == NULL, 0))\n\t{\n\t  dest->alloc = dest->nelem = 0;\n\t  return REG_ESPACE;\n\t}\n      memcpy (dest->elems, src->elems, src->nelem * sizeof (int));\n    }\n  else\n    re_node_set_init_empty (dest);\n  return REG_NOERROR;\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "__attribute_warn_unused_result__",
        "__attribute_warn_unused_result__"
      ]
    },
    "re_node_set_add_intersect": {
      "start_point": [
        1058,
        0
      ],
      "end_point": [
        1144,
        1
      ],
      "content": "static reg_errcode_t\n__attribute_warn_unused_result__\nre_node_set_add_intersect (re_node_set *dest, const re_node_set *src1,\n\t\t\t   const re_node_set *src2)\n{\n  int i1, i2, is, id, delta, sbase;\n  if (src1->nelem == 0 || src2->nelem == 0)\n    return REG_NOERROR;\n\n  /* We need dest->nelem + 2 * elems_in_intersection; this is a\n     conservative estimate.  */\n  if (src1->nelem + src2->nelem + dest->nelem > dest->alloc)\n    {\n      int new_alloc = src1->nelem + src2->nelem + dest->alloc;\n      int *new_elems = re_realloc (dest->elems, int, new_alloc);\n      if (BE (new_elems == NULL, 0))\n\treturn REG_ESPACE;\n      dest->elems = new_elems;\n      dest->alloc = new_alloc;\n    }\n\n  /* Find the items in the intersection of SRC1 and SRC2, and copy\n     into the top of DEST those that are not already in DEST itself.  */\n  sbase = dest->nelem + src1->nelem + src2->nelem;\n  i1 = src1->nelem - 1;\n  i2 = src2->nelem - 1;\n  id = dest->nelem - 1;\n  for (;;)\n    {\n      if (src1->elems[i1] == src2->elems[i2])\n\t{\n\t  /* Try to find the item in DEST.  Maybe we could binary search?  */\n\t  while (id >= 0 && dest->elems[id] > src1->elems[i1])\n\t    --id;\n\n\t  if (id < 0 || dest->elems[id] != src1->elems[i1])\n\t    dest->elems[--sbase] = src1->elems[i1];\n\n\t  if (--i1 < 0 || --i2 < 0)\n\t    break;\n\t}\n\n      /* Lower the highest of the two items.  */\n      else if (src1->elems[i1] < src2->elems[i2])\n\t{\n\t  if (--i2 < 0)\n\t    break;\n\t}\n      else\n\t{\n\t  if (--i1 < 0)\n\t    break;\n\t}\n    }\n\n  id = dest->nelem - 1;\n  is = dest->nelem + src1->nelem + src2->nelem - 1;\n  delta = is - sbase + 1;\n\n  /* Now copy.  When DELTA becomes zero, the remaining\n     DEST elements are already in place; this is more or\n     less the same loop that is in re_node_set_merge.  */\n  dest->nelem += delta;\n  if (delta > 0 && id >= 0)\n    for (;;)\n      {\n\tif (dest->elems[is] > dest->elems[id])\n\t  {\n\t    /* Copy from the top.  */\n\t    dest->elems[id + delta--] = dest->elems[is--];\n\t    if (delta == 0)\n\t      break;\n\t  }\n\telse\n\t  {\n\t    /* Slide from the bottom.  */\n\t    dest->elems[id + delta] = dest->elems[id];\n\t    if (--id < 0)\n\t      break;\n\t  }\n      }\n\n  /* Copy remaining SRC elements.  */\n  memcpy (dest->elems, dest->elems + sbase, delta * sizeof (int));\n\n  return REG_NOERROR;\n}",
      "lines": 87,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "__attribute_warn_unused_result__",
        "__attribute_warn_unused_result__"
      ]
    },
    "re_node_set_init_union": {
      "start_point": [
        1149,
        0
      ],
      "end_point": [
        1197,
        1
      ],
      "content": "static reg_errcode_t\n__attribute_warn_unused_result__\nre_node_set_init_union (re_node_set *dest, const re_node_set *src1,\n\t\t\tconst re_node_set *src2)\n{\n  int i1, i2, id;\n  if (src1 != NULL && src1->nelem > 0 && src2 != NULL && src2->nelem > 0)\n    {\n      dest->alloc = src1->nelem + src2->nelem;\n      dest->elems = re_malloc (int, dest->alloc);\n      if (BE (dest->elems == NULL, 0))\n\treturn REG_ESPACE;\n    }\n  else\n    {\n      if (src1 != NULL && src1->nelem > 0)\n\treturn re_node_set_init_copy (dest, src1);\n      else if (src2 != NULL && src2->nelem > 0)\n\treturn re_node_set_init_copy (dest, src2);\n      else\n\tre_node_set_init_empty (dest);\n      return REG_NOERROR;\n    }\n  for (i1 = i2 = id = 0 ; i1 < src1->nelem && i2 < src2->nelem ;)\n    {\n      if (src1->elems[i1] > src2->elems[i2])\n\t{\n\t  dest->elems[id++] = src2->elems[i2++];\n\t  continue;\n\t}\n      if (src1->elems[i1] == src2->elems[i2])\n\t++i2;\n      dest->elems[id++] = src1->elems[i1++];\n    }\n  if (i1 < src1->nelem)\n    {\n      memcpy (dest->elems + id, src1->elems + i1,\n\t     (src1->nelem - i1) * sizeof (int));\n      id += src1->nelem - i1;\n    }\n  else if (i2 < src2->nelem)\n    {\n      memcpy (dest->elems + id, src2->elems + i2,\n\t     (src2->nelem - i2) * sizeof (int));\n      id += src2->nelem - i2;\n    }\n  dest->nelem = id;\n  return REG_NOERROR;\n}",
      "lines": 49,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "__attribute_warn_unused_result__",
        "__attribute_warn_unused_result__"
      ]
    },
    "re_node_set_merge": {
      "start_point": [
        1202,
        0
      ],
      "end_point": [
        1279,
        1
      ],
      "content": "static reg_errcode_t\n__attribute_warn_unused_result__\nre_node_set_merge (re_node_set *dest, const re_node_set *src)\n{\n  int is, id, sbase, delta;\n  if (src == NULL || src->nelem == 0)\n    return REG_NOERROR;\n  if (dest->alloc < 2 * src->nelem + dest->nelem)\n    {\n      int new_alloc = 2 * (src->nelem + dest->alloc);\n      int *new_buffer = re_realloc (dest->elems, int, new_alloc);\n      if (BE (new_buffer == NULL, 0))\n\treturn REG_ESPACE;\n      dest->elems = new_buffer;\n      dest->alloc = new_alloc;\n    }\n\n  if (BE (dest->nelem == 0, 0))\n    {\n      dest->nelem = src->nelem;\n      memcpy (dest->elems, src->elems, src->nelem * sizeof (int));\n      return REG_NOERROR;\n    }\n\n  /* Copy into the top of DEST the items of SRC that are not\n     found in DEST.  Maybe we could binary search in DEST?  */\n  for (sbase = dest->nelem + 2 * src->nelem,\n       is = src->nelem - 1, id = dest->nelem - 1; is >= 0 && id >= 0; )\n    {\n      if (dest->elems[id] == src->elems[is])\n\tis--, id--;\n      else if (dest->elems[id] < src->elems[is])\n\tdest->elems[--sbase] = src->elems[is--];\n      else /* if (dest->elems[id] > src->elems[is]) */\n\t--id;\n    }\n\n  if (is >= 0)\n    {\n      /* If DEST is exhausted, the remaining items of SRC must be unique.  */\n      sbase -= is + 1;\n      memcpy (dest->elems + sbase, src->elems, (is + 1) * sizeof (int));\n    }\n\n  id = dest->nelem - 1;\n  is = dest->nelem + 2 * src->nelem - 1;\n  delta = is - sbase + 1;\n  if (delta == 0)\n    return REG_NOERROR;\n\n  /* Now copy.  When DELTA becomes zero, the remaining\n     DEST elements are already in place.  */\n  dest->nelem += delta;\n  for (;;)\n    {\n      if (dest->elems[is] > dest->elems[id])\n\t{\n\t  /* Copy from the top.  */\n\t  dest->elems[id + delta--] = dest->elems[is--];\n\t  if (delta == 0)\n\t    break;\n\t}\n      else\n\t{\n\t  /* Slide from the bottom.  */\n\t  dest->elems[id + delta] = dest->elems[id];\n\t  if (--id < 0)\n\t    {\n\t      /* Copy remaining SRC elements.  */\n\t      memcpy (dest->elems, dest->elems + sbase,\n\t\t      delta * sizeof (int));\n\t      break;\n\t    }\n\t}\n    }\n\n  return REG_NOERROR;\n}",
      "lines": 78,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "__attribute_warn_unused_result__",
        "__attribute_warn_unused_result__"
      ]
    },
    "re_node_set_insert": {
      "start_point": [
        1285,
        0
      ],
      "end_point": [
        1336,
        1
      ],
      "content": "static int\n__attribute_warn_unused_result__\nre_node_set_insert (re_node_set *set, int elem)\n{\n  int idx;\n  /* In case the set is empty.  */\n  if (set->alloc == 0)\n    {\n      if (BE (re_node_set_init_1 (set, elem) == REG_NOERROR, 1))\n\treturn 1;\n      else\n\treturn -1;\n    }\n\n  if (BE (set->nelem, 0) == 0)\n    {\n      /* We already guaranteed above that set->alloc != 0.  */\n      set->elems[0] = elem;\n      ++set->nelem;\n      return 1;\n    }\n\n  /* Realloc if we need.  */\n  if (set->alloc == set->nelem)\n    {\n      int *new_elems;\n      set->alloc = set->alloc * 2;\n      new_elems = re_realloc (set->elems, int, set->alloc);\n      if (BE (new_elems == NULL, 0))\n\treturn -1;\n      set->elems = new_elems;\n    }\n\n  /* Move the elements which follows the new element.  Test the\n     first element separately to skip a check in the inner loop.  */\n  if (elem < set->elems[0])\n    {\n      idx = 0;\n      for (idx = set->nelem; idx > 0; idx--)\n\tset->elems[idx] = set->elems[idx - 1];\n    }\n  else\n    {\n      for (idx = set->nelem; set->elems[idx - 1] > elem; idx--)\n\tset->elems[idx] = set->elems[idx - 1];\n    }\n\n  /* Insert the new element.  */\n  set->elems[idx] = elem;\n  ++set->nelem;\n  return 1;\n}",
      "lines": 52,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int",
        "__attribute_warn_unused_result__",
        "__attribute_warn_unused_result__"
      ]
    },
    "re_node_set_insert_last": {
      "start_point": [
        1342,
        0
      ],
      "end_point": [
        1360,
        1
      ],
      "content": "static int\n__attribute_warn_unused_result__\nre_node_set_insert_last (re_node_set *set, int elem)\n{\n  /* Realloc if we need.  */\n  if (set->alloc == set->nelem)\n    {\n      int *new_elems;\n      set->alloc = (set->alloc + 1) * 2;\n      new_elems = re_realloc (set->elems, int, set->alloc);\n      if (BE (new_elems == NULL, 0))\n\treturn -1;\n      set->elems = new_elems;\n    }\n\n  /* Insert the new element.  */\n  set->elems[set->nelem++] = elem;\n  return 1;\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int",
        "__attribute_warn_unused_result__",
        "__attribute_warn_unused_result__"
      ]
    },
    "re_node_set_remove_at": {
      "start_point": [
        1402,
        0
      ],
      "end_point": [
        1410,
        1
      ],
      "content": "static void\nre_node_set_remove_at (re_node_set *set, int idx)\n{\n  if (idx < 0 || idx >= set->nelem)\n    return;\n  --set->nelem;\n  for (; idx < set->nelem; idx++)\n    set->elems[idx] = set->elems[idx + 1];\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "re_dfa_add_node": {
      "start_point": [
        1416,
        0
      ],
      "end_point": [
        1471,
        1
      ],
      "content": "static int\nre_dfa_add_node (re_dfa_t *dfa, re_token_t token)\n{\n  if (BE (dfa->nodes_len >= dfa->nodes_alloc, 0))\n    {\n      size_t new_nodes_alloc = dfa->nodes_alloc * 2;\n      int *new_nexts, *new_indices;\n      re_node_set *new_edests, *new_eclosures;\n      re_token_t *new_nodes;\n\n      /* Avoid overflows in realloc.  */\n      const size_t max_object_size = MAX (sizeof (re_token_t),\n\t\t\t\t\t  MAX (sizeof (re_node_set),\n\t\t\t\t\t       sizeof (int)));\n      if (BE (SIZE_MAX / max_object_size < new_nodes_alloc, 0))\n\treturn -1;\n\n      new_nodes = re_realloc (dfa->nodes, re_token_t, new_nodes_alloc);\n      if (BE (new_nodes == NULL, 0))\n\treturn -1;\n      dfa->nodes = new_nodes;\n      new_nexts = re_realloc (dfa->nexts, int, new_nodes_alloc);\n      new_indices = re_realloc (dfa->org_indices, int, new_nodes_alloc);\n      new_edests = re_realloc (dfa->edests, re_node_set, new_nodes_alloc);\n      new_eclosures = re_realloc (dfa->eclosures, re_node_set, new_nodes_alloc);\n      if (BE (new_nexts == NULL || new_indices == NULL\n\t      || new_edests == NULL || new_eclosures == NULL, 0))\n        {\n\t   /* if any are not NULL, free them, avoid leaks */\n\t   if (new_nexts != NULL)\n              re_free(new_nexts);\n\t   if (new_indices != NULL)\n              re_free(new_indices);\n\t   if (new_edests != NULL)\n              re_free(new_edests);\n\t   if (new_eclosures != NULL)\n              re_free(new_eclosures);\n\t   return -1;\n\t}\n      dfa->nexts = new_nexts;\n      dfa->org_indices = new_indices;\n      dfa->edests = new_edests;\n      dfa->eclosures = new_eclosures;\n      dfa->nodes_alloc = new_nodes_alloc;\n    }\n  dfa->nodes[dfa->nodes_len] = token;\n  dfa->nodes[dfa->nodes_len].constraint = 0;\n#ifdef RE_ENABLE_I18N\n  dfa->nodes[dfa->nodes_len].accept_mb =\n    (token.type == OP_PERIOD && dfa->mb_cur_max > 1) || token.type == COMPLEX_BRACKET;\n#endif\n  dfa->nexts[dfa->nodes_len] = -1;\n  re_node_set_init_empty (dfa->edests + dfa->nodes_len);\n  re_node_set_init_empty (dfa->eclosures + dfa->nodes_len);\n  return dfa->nodes_len++;\n}",
      "lines": 56,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "calc_state_hash": {
      "start_point": [
        1473,
        0
      ],
      "end_point": [
        1481,
        1
      ],
      "content": "static inline unsigned int\ncalc_state_hash (const re_node_set *nodes, unsigned int context)\n{\n  unsigned int hash = nodes->nelem + context;\n  int i;\n  for (i = 0 ; i < nodes->nelem ; i++)\n    hash += nodes->elems[i];\n  return hash;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "unsigned int",
        "unsigned",
        "int"
      ]
    },
    "re_acquire_state": {
      "start_point": [
        1492,
        0
      ],
      "end_point": [
        1524,
        1
      ],
      "content": "static re_dfastate_t *\n__attribute_warn_unused_result__\nre_acquire_state (reg_errcode_t *err, const re_dfa_t *dfa,\n\t\t  const re_node_set *nodes)\n{\n  unsigned int hash;\n  re_dfastate_t *new_state;\n  struct re_state_table_entry *spot;\n  int i;\n  if (BE (nodes->nelem == 0, 0))\n    {\n      *err = REG_NOERROR;\n      return NULL;\n    }\n  hash = calc_state_hash (nodes, 0);\n  spot = dfa->state_table + (hash & dfa->state_hash_mask);\n\n  for (i = 0 ; i < spot->num ; i++)\n    {\n      re_dfastate_t *state = spot->array[i];\n      if (hash != state->hash)\n\tcontinue;\n      if (re_node_set_compare (&state->nodes, nodes))\n\treturn state;\n    }\n\n  /* There are no appropriate state in the dfa, create the new one.  */\n  new_state = create_ci_newstate (dfa, nodes, hash);\n  if (BE (new_state == NULL, 0))\n    *err = REG_ESPACE;\n\n  return new_state;\n}",
      "lines": 33,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "re_dfastate_t",
        "*\n__attribute_warn_unused_result__\nre_acquire_state (reg_errcode_t *err, const re_dfa_t *dfa,\n\t\t  const re_node_set *nodes)",
        "*",
        "__attribute_warn_unused_result__",
        "__attribute_warn_unused_result__"
      ]
    },
    "re_acquire_state_context": {
      "start_point": [
        1536,
        0
      ],
      "end_point": [
        1567,
        1
      ],
      "content": "static re_dfastate_t *\n__attribute_warn_unused_result__\nre_acquire_state_context (reg_errcode_t *err, const re_dfa_t *dfa,\n\t\t\t  const re_node_set *nodes, unsigned int context)\n{\n  unsigned int hash;\n  re_dfastate_t *new_state;\n  struct re_state_table_entry *spot;\n  int i;\n  if (nodes->nelem == 0)\n    {\n      *err = REG_NOERROR;\n      return NULL;\n    }\n  hash = calc_state_hash (nodes, context);\n  spot = dfa->state_table + (hash & dfa->state_hash_mask);\n\n  for (i = 0 ; i < spot->num ; i++)\n    {\n      re_dfastate_t *state = spot->array[i];\n      if (state->hash == hash\n\t  && state->context == context\n\t  && re_node_set_compare (state->entrance_nodes, nodes))\n\treturn state;\n    }\n  /* There are no appropriate state in `dfa', create the new one.  */\n  new_state = create_cd_newstate (dfa, nodes, context, hash);\n  if (BE (new_state == NULL, 0))\n    *err = REG_ESPACE;\n\n  return new_state;\n}",
      "lines": 32,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "re_dfastate_t",
        "*\n__attribute_warn_unused_result__\nre_acquire_state_context (reg_errcode_t *err, const re_dfa_t *dfa,\n\t\t\t  const re_node_set *nodes, unsigned int context)",
        "*",
        "__attribute_warn_unused_result__",
        "__attribute_warn_unused_result__"
      ]
    },
    "register_state": {
      "start_point": [
        1573,
        0
      ],
      "end_point": [
        1607,
        1
      ],
      "content": "static reg_errcode_t\n__attribute_warn_unused_result__\nregister_state (const re_dfa_t *dfa, re_dfastate_t *newstate,\n\t\tunsigned int hash)\n{\n  struct re_state_table_entry *spot;\n  reg_errcode_t err;\n  int i;\n\n  newstate->hash = hash;\n  err = re_node_set_alloc (&newstate->non_eps_nodes, newstate->nodes.nelem);\n  if (BE (err != REG_NOERROR, 0))\n    return REG_ESPACE;\n  for (i = 0; i < newstate->nodes.nelem; i++)\n    {\n      int elem = newstate->nodes.elems[i];\n      if (!IS_EPSILON_NODE (dfa->nodes[elem].type))\n\tif (re_node_set_insert_last (&newstate->non_eps_nodes, elem) < 0)\n\t  return REG_ESPACE;\n    }\n\n  spot = dfa->state_table + (hash & dfa->state_hash_mask);\n  if (BE (spot->alloc <= spot->num, 0))\n    {\n      int new_alloc = 2 * spot->num + 2;\n      re_dfastate_t **new_array = re_realloc (spot->array, re_dfastate_t *,\n\t\t\t\t\t      new_alloc);\n      if (BE (new_array == NULL, 0))\n\treturn REG_ESPACE;\n      spot->array = new_array;\n      spot->alloc = new_alloc;\n    }\n  spot->array[spot->num++] = newstate;\n  return REG_NOERROR;\n}",
      "lines": 35,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "__attribute_warn_unused_result__",
        "__attribute_warn_unused_result__"
      ]
    },
    "free_state": {
      "start_point": [
        1609,
        0
      ],
      "end_point": [
        1623,
        1
      ],
      "content": "static void\nfree_state (re_dfastate_t *state)\n{\n  re_node_set_free (&state->non_eps_nodes);\n  re_node_set_free (&state->inveclosure);\n  if (state->entrance_nodes != &state->nodes)\n    {\n      re_node_set_free (state->entrance_nodes);\n      re_free (state->entrance_nodes);\n    }\n  re_node_set_free (&state->nodes);\n  re_free (state->word_trtable);\n  re_free (state->trtable);\n  re_free (state);\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "create_ci_newstate": {
      "start_point": [
        1628,
        0
      ],
      "end_point": [
        1673,
        1
      ],
      "content": "static re_dfastate_t *\n__attribute_warn_unused_result__\ncreate_ci_newstate (const re_dfa_t *dfa, const re_node_set *nodes,\n\t\t    unsigned int hash)\n{\n  int i;\n  reg_errcode_t err;\n  re_dfastate_t *newstate;\n\n  newstate = (re_dfastate_t *) calloc (sizeof (re_dfastate_t), 1);\n  if (BE (newstate == NULL, 0))\n    return NULL;\n  err = re_node_set_init_copy (&newstate->nodes, nodes);\n  if (BE (err != REG_NOERROR, 0))\n    {\n      re_free (newstate);\n      return NULL;\n    }\n\n  newstate->entrance_nodes = &newstate->nodes;\n  for (i = 0 ; i < nodes->nelem ; i++)\n    {\n      re_token_t *node = dfa->nodes + nodes->elems[i];\n      re_token_type_t type = node->type;\n      if (type == CHARACTER && !node->constraint)\n\tcontinue;\n#ifdef RE_ENABLE_I18N\n      newstate->accept_mb |= node->accept_mb;\n#endif /* RE_ENABLE_I18N */\n\n      /* If the state has the halt node, the state is a halt state.  */\n      if (type == END_OF_RE)\n\tnewstate->halt = 1;\n      else if (type == OP_BACK_REF)\n\tnewstate->has_backref = 1;\n      else if (type == ANCHOR || node->constraint)\n\tnewstate->has_constraint = 1;\n    }\n  err = register_state (dfa, newstate, hash);\n  if (BE (err != REG_NOERROR, 0))\n    {\n      free_state (newstate);\n      newstate = NULL;\n    }\n  return newstate;\n}",
      "lines": 46,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "re_dfastate_t",
        "*\n__attribute_warn_unused_result__\ncreate_ci_newstate (const re_dfa_t *dfa, const re_node_set *nodes,\n\t\t    unsigned int hash)",
        "*",
        "__attribute_warn_unused_result__",
        "__attribute_warn_unused_result__"
      ]
    },
    "create_cd_newstate": {
      "start_point": [
        1678,
        0
      ],
      "end_point": [
        1749,
        1
      ],
      "content": "static re_dfastate_t *\n__attribute_warn_unused_result__\ncreate_cd_newstate (const re_dfa_t *dfa, const re_node_set *nodes,\n\t\t    unsigned int context, unsigned int hash)\n{\n  int i, nctx_nodes = 0;\n  reg_errcode_t err;\n  re_dfastate_t *newstate;\n\n  newstate = (re_dfastate_t *) calloc (sizeof (re_dfastate_t), 1);\n  if (BE (newstate == NULL, 0))\n    return NULL;\n  err = re_node_set_init_copy (&newstate->nodes, nodes);\n  if (BE (err != REG_NOERROR, 0))\n    {\n      re_free (newstate);\n      return NULL;\n    }\n\n  newstate->context = context;\n  newstate->entrance_nodes = &newstate->nodes;\n\n  for (i = 0 ; i < nodes->nelem ; i++)\n    {\n      re_token_t *node = dfa->nodes + nodes->elems[i];\n      re_token_type_t type = node->type;\n      unsigned int constraint = node->constraint;\n\n      if (type == CHARACTER && !constraint)\n\tcontinue;\n#ifdef RE_ENABLE_I18N\n      newstate->accept_mb |= node->accept_mb;\n#endif /* RE_ENABLE_I18N */\n\n      /* If the state has the halt node, the state is a halt state.  */\n      if (type == END_OF_RE)\n\tnewstate->halt = 1;\n      else if (type == OP_BACK_REF)\n\tnewstate->has_backref = 1;\n\n      if (constraint)\n\t{\n\t  if (newstate->entrance_nodes == &newstate->nodes)\n\t    {\n\t      newstate->entrance_nodes = re_malloc (re_node_set, 1);\n\t      if (BE (newstate->entrance_nodes == NULL, 0))\n\t\t{\n\t\t  free_state (newstate);\n\t\t  return NULL;\n\t\t}\n\t      if (re_node_set_init_copy (newstate->entrance_nodes, nodes)\n\t\t  != REG_NOERROR)\n\t\treturn NULL;\n\t      nctx_nodes = 0;\n\t      newstate->has_constraint = 1;\n\t    }\n\n\t  if (NOT_SATISFY_PREV_CONSTRAINT (constraint,context))\n\t    {\n\t      re_node_set_remove_at (&newstate->nodes, i - nctx_nodes);\n\t      ++nctx_nodes;\n\t    }\n\t}\n    }\n  err = register_state (dfa, newstate, hash);\n  if (BE (err != REG_NOERROR, 0))\n    {\n      free_state (newstate);\n      newstate = NULL;\n    }\n  return  newstate;\n}",
      "lines": 72,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "re_dfastate_t",
        "*\n__attribute_warn_unused_result__\ncreate_cd_newstate (const re_dfa_t *dfa, const re_node_set *nodes,\n\t\t    unsigned int context, unsigned int hash)",
        "*",
        "__attribute_warn_unused_result__",
        "__attribute_warn_unused_result__"
      ]
    }
  },
  "gawk/gawk-4.2.1/support/regex_internal.h": {
    "is_blank": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "static int\nis_blank (int c)\n{\n   return (c == ' ' || c == '\\t');\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "test_malloc": {
      "start_point": [
        456,
        0
      ],
      "end_point": [
        465,
        1
      ],
      "content": "static void *\ntest_malloc(size_t count, const char *file, size_t line)\n{\n\tif (count == 0) {\n\t\tfprintf(stderr, \"%s:%lu: allocation of zero bytes\\n\",\n\t\t\t\tfile, (unsigned long) line);\n\t\texit(1);\n\t}\n\treturn malloc(count);\n}",
      "lines": 10,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void",
        "*\ntest_malloc(size_t count, const char *file, size_t line)",
        "*"
      ]
    },
    "test_realloc": {
      "start_point": [
        467,
        0
      ],
      "end_point": [
        476,
        1
      ],
      "content": "static void *\ntest_realloc(void *p, size_t count, const char *file, size_t line)\n{\n\tif (count == 0) {\n\t\tfprintf(stderr, \"%s:%lu: reallocation of zero bytes\\n\",\n\t\t\t\tfile, (unsigned long) line);\n\t\texit(1);\n\t}\n\treturn realloc(p, count);\n}",
      "lines": 10,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void",
        "*\ntest_realloc(void *p, size_t count, const char *file, size_t line)",
        "*"
      ]
    },
    "bitset_not": {
      "start_point": [
        735,
        0
      ],
      "end_point": [
        741,
        1
      ],
      "content": "static void __attribute__ ((unused))\nbitset_not (bitset_t set)\n{\n  int bitset_i;\n  for (bitset_i = 0; bitset_i < BITSET_WORDS; ++bitset_i)\n    set[bitset_i] = ~set[bitset_i];\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void",
        "__attribute__ ((unused))",
        "__attribute__",
        "(",
        "(unused)",
        "(",
        "unused",
        ")",
        ")"
      ]
    },
    "bitset_merge": {
      "start_point": [
        743,
        0
      ],
      "end_point": [
        749,
        1
      ],
      "content": "static void __attribute__ ((unused))\nbitset_merge (bitset_t dest, const bitset_t src)\n{\n  int bitset_i;\n  for (bitset_i = 0; bitset_i < BITSET_WORDS; ++bitset_i)\n    dest[bitset_i] |= src[bitset_i];\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void",
        "__attribute__ ((unused))",
        "__attribute__",
        "(",
        "(unused)",
        "(",
        "unused",
        ")",
        ")"
      ]
    },
    "bitset_mask": {
      "start_point": [
        751,
        0
      ],
      "end_point": [
        757,
        1
      ],
      "content": "static void __attribute__ ((unused))\nbitset_mask (bitset_t dest, const bitset_t src)\n{\n  int bitset_i;\n  for (bitset_i = 0; bitset_i < BITSET_WORDS; ++bitset_i)\n    dest[bitset_i] &= src[bitset_i];\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void",
        "__attribute__ ((unused))",
        "__attribute__",
        "(",
        "(unused)",
        "(",
        "unused",
        ")",
        ")"
      ]
    },
    "re_string_char_size_at": {
      "start_point": [
        761,
        0
      ],
      "end_point": [
        772,
        1
      ],
      "content": "static int\n__attribute__ ((pure, unused))\nre_string_char_size_at (const re_string_t *pstr, int idx)\n{\n  int byte_idx;\n  if (pstr->mb_cur_max == 1)\n    return 1;\n  for (byte_idx = 1; idx + byte_idx < pstr->valid_len; ++byte_idx)\n    if (pstr->wcs[idx + byte_idx] != WEOF)\n      break;\n  return byte_idx;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int",
        "__attribute__ ((pure, unused))",
        "__attribute__",
        "(",
        "(pure, unused)",
        "(",
        "pure",
        ",",
        "unused",
        ")",
        ")"
      ]
    },
    "re_string_wchar_at": {
      "start_point": [
        774,
        0
      ],
      "end_point": [
        781,
        1
      ],
      "content": "static wint_t\n__attribute__ ((pure, unused))\nre_string_wchar_at (const re_string_t *pstr, int idx)\n{\n  if (pstr->mb_cur_max == 1)\n    return (wint_t) pstr->mbs[idx];\n  return (wint_t) pstr->wcs[idx];\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "wint_t",
        "__attribute__ ((pure, unused))",
        "__attribute__",
        "(",
        "(pure, unused)",
        "(",
        "pure",
        ",",
        "unused",
        ")",
        ")"
      ]
    },
    "re_string_elem_size_at": {
      "start_point": [
        788,
        0
      ],
      "end_point": [
        811,
        1
      ],
      "content": "static int\n__attribute__ ((pure, unused))\nre_string_elem_size_at (const re_string_t *pstr, int idx)\n{\n#  ifdef _LIBC\n  const unsigned char *p, *extra;\n  const int32_t *table, *indirect;\n  uint_fast32_t nrules = _NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_NRULES);\n\n  if (nrules != 0)\n    {\n      table = (const int32_t *) _NL_CURRENT (LC_COLLATE, _NL_COLLATE_TABLEMB);\n      extra = (const unsigned char *)\n\t_NL_CURRENT (LC_COLLATE, _NL_COLLATE_EXTRAMB);\n      indirect = (const int32_t *) _NL_CURRENT (LC_COLLATE,\n\t\t\t\t\t\t_NL_COLLATE_INDIRECTMB);\n      p = pstr->mbs + idx;\n      findidx (table, indirect, extra, &p, pstr->len - idx);\n      return p - pstr->mbs - idx;\n    }\n  else\n#  endif /* _LIBC */\n    return 1;\n}",
      "lines": 24,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int",
        "__attribute__ ((pure, unused))",
        "__attribute__",
        "(",
        "(pure, unused)",
        "(",
        "pure",
        ",",
        "unused",
        ")",
        ")"
      ]
    }
  },
  "gawk/gawk-4.2.1/support/verify.h": {},
  "gawk/gawk-4.2.1/support/xalloc.h": {
    "xnmalloc": {
      "start_point": [
        128,
        0
      ],
      "end_point": [
        134,
        1
      ],
      "content": "static_inline void *\nxnmalloc (size_t n, size_t s)\n{\n  if (xalloc_oversized (n, s))\n    xalloc_die ();\n  return xmalloc (n * s);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static_inline",
        "void",
        "void",
        "*\nxnmalloc (size_t n, size_t s)",
        "*"
      ]
    },
    "xmalloc": {
      "start_point": [
        140,
        0
      ],
      "end_point": [
        149,
        1
      ],
      "content": "void *\nxmalloc(size_t bytes)\n{\n  void *p;\n  if (bytes == 0)\n    bytes = 1;\t/* avoid dfa.c mishegos */\n  if ((p = malloc(bytes)) == NULL)\n    xalloc_die ();\n  return p;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "void",
        "*\nxmalloc(size_t bytes)",
        "*"
      ]
    },
    "xcalloc": {
      "start_point": [
        155,
        0
      ],
      "end_point": [
        165,
        1
      ],
      "content": "void *\nxcalloc(size_t nmemb, size_t size)\n{\n  void *p;\n\n  if (nmemb == 0 || size == 0)\n    nmemb = size = 1; \t/* avoid dfa.c mishegos */\n  if ((p = calloc(nmemb, size)) == NULL)\n    xalloc_die ();\n  return p;\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "void",
        "*\nxcalloc(size_t nmemb, size_t size)",
        "*"
      ]
    },
    "xrealloc": [
      {
        "start_point": [
          169,
          0
        ],
        "end_point": [
          177,
          1
        ],
        "content": "void *\nxrealloc(void *p, size_t size)\n{\n   void *new_p = realloc(p, size);\n   if (new_p ==  0)\n     xalloc_die ();\n\n   return new_p;\n}",
        "lines": 9,
        "depth": 7,
        "decorators": [
          "void",
          "*\nxrealloc(void *p, size_t size)",
          "*"
        ]
      },
      {
        "start_point": [
          343,
          29
        ],
        "end_point": [
          347,
          1
        ],
        "content": "T *\nxrealloc (T *p, size_t s)\n{\n  return (T *) xrealloc ((void *) p, s);\n}",
        "lines": 5,
        "depth": 10,
        "decorators": [
          "T",
          "*\nxrealloc (T *p, size_t s)",
          "*"
        ]
      }
    ],
    "xalloc_die": {
      "start_point": [
        181,
        0
      ],
      "end_point": [
        185,
        1
      ],
      "content": "void\nxalloc_die (void)\n{\n\tr_fatal(_(\"xalloc: malloc failed: %s\"), strerror(errno));\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "xmemdup": [
      {
        "start_point": [
          191,
          0
        ],
        "end_point": [
          195,
          1
        ],
        "content": "void *\nxmemdup (void const *p, size_t s)\n{\n  return memcpy (xmalloc (s), p, s);\n}",
        "lines": 5,
        "depth": 8,
        "decorators": [
          "void",
          "*\nxmemdup (void const *p, size_t s)",
          "*"
        ]
      },
      {
        "start_point": [
          367,
          29
        ],
        "end_point": [
          371,
          1
        ],
        "content": "T *\nxmemdup (T const *p, size_t s)\n{\n  return (T *) xmemdup ((void const *) p, s);\n}",
        "lines": 5,
        "depth": 10,
        "decorators": [
          "T",
          "*\nxmemdup (T const *p, size_t s)",
          "*"
        ]
      }
    ],
    "xstrdup": {
      "start_point": [
        198,
        0
      ],
      "end_point": [
        211,
        1
      ],
      "content": "char *xstrdup(const char *s)\n{\n\tchar *p;\n\tint l;\n\n\tif (s == NULL)\n\t\tr_fatal(_(\"xstrdup: null parameter\"));\n\n\tl = strlen(s);\n\tp = xmemdup(s, l + 1);\n\tp[l] = '\\0';\n\n\treturn p;\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "char",
        "*xstrdup(const char *s)",
        "*"
      ]
    },
    "xnrealloc": [
      {
        "start_point": [
          217,
          0
        ],
        "end_point": [
          223,
          1
        ],
        "content": "static_inline void *\nxnrealloc (void *p, size_t n, size_t s)\n{\n  if (xalloc_oversized (n, s))\n    xalloc_die ();\n  return xrealloc (p, n * s);\n}",
        "lines": 7,
        "depth": 7,
        "decorators": [
          "static_inline",
          "void",
          "void",
          "*\nxnrealloc (void *p, size_t n, size_t s)",
          "*"
        ]
      },
      {
        "start_point": [
          349,
          29
        ],
        "end_point": [
          353,
          1
        ],
        "content": "T *\nxnrealloc (T *p, size_t n, size_t s)\n{\n  return (T *) xnrealloc ((void *) p, n, s);\n}",
        "lines": 5,
        "depth": 10,
        "decorators": [
          "T",
          "*\nxnrealloc (T *p, size_t n, size_t s)",
          "*"
        ]
      }
    ],
    "x2nrealloc": [
      {
        "start_point": [
          280,
          0
        ],
        "end_point": [
          312,
          1
        ],
        "content": "static_inline void *\nx2nrealloc (void *p, size_t *pn, size_t s)\n{\n  size_t n = *pn;\n\n  if (! p)\n    {\n      if (! n)\n        {\n          /* The approximate size to use for initial small allocation\n             requests, when the invoking code specifies an old size of\n             zero.  64 bytes is the largest \"small\" request for the\n             GNU C library malloc.  */\n          enum { DEFAULT_MXFAST = 64 * sizeof (size_t) / 4 };\n\n          n = DEFAULT_MXFAST / s;\n          n += !n;\n        }\n    }\n  else\n    {\n      /* Set N = ceil (1.5 * N) so that progress is made if N == 1.\n         Check for overflow, so that N * S stays in size_t range.\n         The check is slightly conservative, but an exact check isn't\n         worth the trouble.  */\n      if ((size_t) -1 / 3 * 2 / s <= n)\n        xalloc_die ();\n      n += n / 2 + 1;\n    }\n\n  *pn = n;\n  return xrealloc (p, n * s);\n}",
        "lines": 33,
        "depth": 14,
        "decorators": [
          "static_inline",
          "void",
          "void",
          "*\nx2nrealloc (void *p, size_t *pn, size_t s)",
          "*"
        ]
      },
      {
        "start_point": [
          361,
          29
        ],
        "end_point": [
          365,
          1
        ],
        "content": "T *\nx2nrealloc (T *p, size_t *pn, size_t s)\n{\n  return (T *) x2nrealloc ((void *) p, pn, s);\n}",
        "lines": 5,
        "depth": 10,
        "decorators": [
          "T",
          "*\nx2nrealloc (T *p, size_t *pn, size_t s)",
          "*"
        ]
      }
    ],
    "xcharalloc": {
      "start_point": [
        318,
        0
      ],
      "end_point": [
        322,
        1
      ],
      "content": "static_inline char *\nxcharalloc (size_t n)\n{\n  return XNMALLOC (n, char);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static_inline",
        "char",
        "char",
        "*\nxcharalloc (size_t n)",
        "*"
      ]
    },
    "xzalloc": {
      "start_point": [
        328,
        0
      ],
      "end_point": [
        332,
        1
      ],
      "content": "inline void *\nxzalloc (size_t s)\n{\n  return xcalloc(1, s);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "inline",
        "inline",
        "void",
        "*\nxzalloc (size_t s)",
        "*"
      ]
    },
    "x2realloc": {
      "start_point": [
        355,
        29
      ],
      "end_point": [
        359,
        1
      ],
      "content": "T *\nx2realloc (T *p, size_t *pn)\n{\n  return (T *) x2realloc ((void *) p, pn);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "T",
        "*\nx2realloc (T *p, size_t *pn)",
        "*"
      ]
    }
  },
  "gawk/gawk-4.2.1/vms/redirect.h": {},
  "gawk/gawk-4.2.1/vms/unixlib.h": {},
  "gawk/gawk-4.2.1/vms/varargs.h": {},
  "gawk/gawk-4.2.1/vms/vms.h": {},
  "gawk/gawk-4.2.1/vms/vms_args.c": {
    "vms_arg_fixup": {
      "start_point": [
        101,
        0
      ],
      "end_point": [
        313,
        1
      ],
      "content": "void\nvms_arg_fixup( int *pargc, char ***pargv )\n{\n    const char *f_in, *f_out, *f_err,\n\t*out_mode, *rms_rfm, *rms_shr, *rms_mrs;\n    char **argv = *pargv;\n    int i, argc = *pargc;\n    int err_to_out_redirect = 0, out_to_err_redirect = 0;\n    char * shell;\n    int using_shell;\n\n    /* make sure AWK_LIBRARY has a value */\n    if (!getenv(\"AWK_LIBRARY\"))\n\tvms_define(\"AWK_LIBRARY\", \"SYS$LIBRARY:\");\n\n    /* Check if running under a shell instead of DCL */\n    using_shell = 1;\n    shell = getenv(\"SHELL\");\n    if (shell != NULL) {\n\tif (strcmp(shell, \"DCL\") == 0) {\n\t    using_shell = 0;\n\t}\n    } else {\n\tusing_shell = 0;\n    }\n    if (using_shell) {\n\treturn;\n    }\n#ifdef CHECK_DECSHELL\t    /* don't define this if linking with DECC$SHR */\n    if (shell$is_shell())\n\treturn;\t\t    /* don't do anything if we're running DEC/Shell */\n#endif\n#ifndef NO_DCL_CMD\n    for (i = 1; i < argc ; i++)     /* check for dash or other non-VMS args */\n\tif (strchr(\"->\\\\|\", *argv[i]))\tbreak;\t    /* found => (i < argc) */\n    if (i >= argc && (v_argc = vms_gawk()) > 0) {   /* vms_gawk => dcl_parse */\n\t/* if we successfully parsed the command, replace original argv[] */\n\targc = v_argc,\targv = v_argv;\n\tv_argz = v_argc = 0,  v_argv = NULL;\n    }\n#endif\n    v_add_arg(v_argc = 0, argv[0]);\t/* store arg #0 (image name) */\n\n    f_in = f_out = f_err = NULL;\t/* stdio setup (no filenames yet) */\n    out_mode = \"w\";\t\t\t/* default access for stdout */\n    rms_rfm = \"rfm=stmlf\";\t\t/* stream_LF format */\n    rms_shr = \"shr=nil\";\t\t/* no sharing (for '>' output file) */\n    rms_mrs = \"mrs=0\";\t\t\t/* no maximum record size */\n\n    for (i = 1; i < argc; i++) {\n\tchar *p, *fn;\n\tint  is_arg;\n\n\tis_arg = 0;\t\t/* current arg does not begin with dash */\n\tp = argv[i];\t\t/* current arg */\n\tswitch (*p) {\n\t  case '<':\t\t/* stdin */\n\t      /*[should try to determine whether this is really a directory\n\t\t spec using <>; for now, force user to quote them with '\\<']*/\n\t\tif ( f_in ) {\n\t\t    fatal(\"multiple specification of '<' for stdin\");\n\t\t} else if (*++p == '<') {   /* '<<' is not supported */\n\t\t    fatal(\"'<<' not available for stdin\");\n\t\t} else {\n\t\t    p = skipblanks(p);\n\t\t    fn = (*p ? p : argv[++i]);\t/* use next arg if necessary */\n\t\t    if (i >= argc || *fn == '-')\n\t\t\tfatal(\"invalid i/o redirection, null filespec after '<'\");\n\t\t    else\n\t\t\tf_in = fn;\t    /* save filename for stdin */\n\t\t}\n\t\tbreak;\n\t  case '>':   {\t\t/* stdout or stderr */\n\t      /*[vms-specific kludge '>$' added to force stdout to be created\n\t\t as record-oriented text file instead of in stream-lf format]*/\n\t\tint is_out = 1;\t\t    /* assume stdout */\n\t\tif (*++p == '>')\t/* '>>' => append */\n\t\t    out_mode = \"a\",  p++;\n\t\telse if (*p == '&')\t/* '>&' => stderr */\n\t\t    is_out = 0,  p++;\n\t\telse if (*p == '$')\t/* '>$' => kludge for record format */\n\t\t    rms_rfm = \"rfm=var\",  rms_shr = \"shr=get,upi\",\n\t\t    rms_mrs = \"mrs=32767\",  p++;\n\t\telse if (*p == '+')\t/* '>+' => kludge for binary output */\n\t\t    out_mode = \"wb\",  rms_rfm = \"rfm=var\",\n\t\t    rms_mrs = \"mrs=32767\",  p++;\n\t\telse\t\t\t/* '>'\t=> create */\n\t\t    {}\t    /* use default values initialized prior to loop */\n\t\tp = skipblanks(p);\n\t\tfn = (*p ? p : argv[++i]);\t/* use next arg if necessary */\n\t\tif (i >= argc || *fn == '-') {\n\t\t    fatal(\"invalid i/o redirection, null filespec after '>'\");\n\t\t} else if (is_out) {\n\t\t    if (out_to_err_redirect)\n\t\t\tfatal(\"conflicting specifications for stdout\");\n\t\t    else if (f_out)\n\t\t\tfatal(\"multiple specification of '>' for stdout\");\n\t\t    else\n\t\t\tf_out = fn;\t    /* save filename for stdout */\n\t\t} else {\n\t\t    if (err_to_out_redirect)\n\t\t\tfatal(\"conflicting specifications for stderr\");\n\t\t    else if (f_err)\n\t\t\tfatal(\"multiple specification of '>&' for stderr\");\n\t\t    else\n\t\t\tf_err = fn;\t    /* save filename for stderr */\n\t\t}\n\t    }\tbreak;\n\t  case '2':\t\t/* check for ``2>&1'' special case'' */\n\t\tif (strcmp(p, \"2>&1\") != 0)\n\t\t    goto ordinary_arg;\n\t\telse if (f_err || out_to_err_redirect)\n\t\t    fatal(\"conflicting specifications for stderr\");\n\t\telse {\n\t\t    err_to_out_redirect = 1;\n\t\t    f_err = \"SYS$OUTPUT:\";\n\t\t}  break;\n\t  case '1':\t\t/* check for ``1>&2'' special case'' */\n\t\tif (strcmp(p, \"1>&2\") != 0)\n\t\t    goto ordinary_arg;\n\t\telse if (f_out || err_to_out_redirect)\n\t\t    fatal(\"conflicting specifications for stdout\");\n\t\telse {\n\t\t    out_to_err_redirect = 1;\n\t\t /* f_out = \"SYS$ERROR:\"; */\n\t\t}  break;\n\t  case '|':\t\t/* pipe */\n\t      /* command pipelines are not supported */\n\t\tfatal(\"command pipes not available ('|' encountered)\");\n\t\tbreak;\n\t  case '&':\t\t/* background */\n\t      /*[we could probably spawn or fork ourself--maybe someday]*/\n\t\tif (*(p+1) == '\\0' && i == argc - 1) {\n\t\t    fatal(\"background tasks not available ('&' encountered)\");\n\t\t    break;\n\t\t} else {\t/* fall through */\n\t\t    ;\t/*NOBREAK*/\n\t\t}\n\t  case '-':\t\t/* argument */\n\t\tis_arg = 1;\t\t/*(=> skip wildcard check)*/\n\t  default:\t\t/* other (filespec assumed) */\nordinary_arg:\n\t      /* process escape sequences or expand wildcards */\n\t\tv_add_arg(++v_argc, p);\t\t/* include this arg */\n\t\tp = strchr(p, '\\\\');\t\t/* look for backslash */\n\t\tif (p != NULL) {    /* does it have escape sequence(s)? */\n#if 0\t/* disable escape parsing; it's now done elsewhere within gawk */\n\t\t    register int c;\n\t\t    char *q = v_argv[v_argc] + (p - argv[i]);\n\t\t    do {\n\t\t\tc = *p++;\n\t\t\tif (c == '\\\\')\n\t\t\t    c = parse_escape(&p);\n\t\t\t*q++ = (c >= 0 ? (char)c : '\\\\');\n\t\t    } while (*p != '\\0');\n\t\t    *q = '\\0';\n#endif\t/*0*/\n\t\t} else if (!is_arg && strchr(v_argv[v_argc], '=') == NULL) {\n\t\t    vms_expand_wildcards(v_argv[v_argc]);\n\t\t}\n\t\tbreak;\n\t} /* end switch */\n    } /* loop */\n\n    /*\n     * Now process any/all I/O options encountered above.\n     */\n\n    /* must do stderr first, or vaxcrtl init might not see it */\n    /*[ catch 22:  we'll also redirect errors encountered doing <in or >out ]*/\n    if (f_err) {\t/* define logical name but don't open file */\n\tint len = strlen(f_err);\n\tif (len >= (sizeof \"SYS$OUTPUT\" - sizeof \"\")\n\t && strncasecmp(f_err, \"SYS$OUTPUT:\", len) == 0)\n\t    err_to_out_redirect = 1;\n\telse\n\t    (void) vms_define(\"SYS$ERROR\", f_err);\n    }\n    /* do stdin before stdout, so if we bomb we won't make empty output file */\n    if (f_in) {\t\t/* [re]open file and define logical name */\n\tif (freopen(f_in, \"r\", stdin,\n\t\t    \"ctx=rec\", \"shr=get,put,del,upd\",\n\t\t    \"mrs=32767\", \"mbc=32\", \"mbf=2\"))\n\t    (void) vms_define(\"SYS$INPUT\", f_in);\n\telse\n\t    fatal(\"<%s (%s)\", f_in, strerror(errno));\n    }\n    if (f_out) {\n\tif (freopen(f_out, out_mode, stdout,\n\t\t    rms_rfm, rms_shr, rms_mrs,\n\t\t    \"rat=cr\", \"mbc=32\", \"mbf=2\"))\n\t    (void) vms_define(\"SYS$OUTPUT\", f_out);\n\telse\n\t    fatal(\">%s%s (%s)\", (*out_mode == 'a' ? \">\" : \"\"),\n\t\t  f_out, strerror(errno));\n    }\n    if (err_to_out_redirect) {\t/* special case for ``2>&1'' construct */\n\t(void) dup2(1, 2);\t/* make file 2 (stderr) share file 1 (stdout) */\n\t(void) vms_define(\"SYS$ERROR\", \"SYS$OUTPUT:\");\n    } else if (out_to_err_redirect) {\t/* ``1>&2'' */\n\t(void) dup2(2, 1);\t/* make file 1 (stdout) share file 2 (stderr) */\n\t(void) vms_define(\"SYS$OUTPUT\", \"SYS$ERROR:\");\n    }\n\n#ifndef NO_DCL_CMD\n    /* if we replaced argv[] with our own, we can release it now */\n    if (argv != *pargv)\n\tfree((void *)argv),  argv = NULL;\n#endif\n    *pargc = ++v_argc;\t\t/* increment to account for argv[0] */\n    *pargv = v_argv;\n    return;\n}",
      "lines": 213,
      "depth": 19,
      "decorators": [
        "void"
      ]
    },
    "vms_expand_wildcards": {
      "start_point": [
        318,
        0
      ],
      "end_point": [
        359,
        1
      ],
      "content": "static void\nvms_expand_wildcards( const char *prospective_filespec )\n{\n    char *p, spec_buf[255+1], res_buf[255+1];\n    struct dsc$descriptor_s spec, result;\n    void *context;\n    register int len = strlen(prospective_filespec);\n\n    if (len >= sizeof spec_buf)\n\treturn;\t\t/* can't be valid--or at least we can't handle it */\n    strcpy(spec_buf, prospective_filespec);\t/* copy the arg */\n    p = strchr(spec_buf, '?');\n    if (p != NULL)\t/* change '?' single-char wildcard to '%' */\n\tdo  *p++ = '%',  p = strchr(p, '?');\n\t    while (p != NULL);\n    else if (strchr(spec_buf, '*') == strchr(spec_buf, '%')  /* => both NULL */\n\t  && strstr(spec_buf, \"...\") == NULL)\n\treturn;\t\t/* no wildcards present; don't attempt file lookup */\n    spec.dsc$w_length = len;\n    spec.dsc$a_pointer = spec_buf;\n    spec.dsc$b_dtype = DSC$K_DTYPE_T;\n    spec.dsc$b_class = DSC$K_CLASS_S;\n    result.dsc$w_length = sizeof res_buf - 1;\n    result.dsc$a_pointer = res_buf;\n    result.dsc$b_dtype = DSC$K_DTYPE_T;\n    result.dsc$b_class = DSC$K_CLASS_S;\n\n    /* The filespec is already in v_argv[v_argc]; if we fail to match anything,\n       we'll just leave it there (unlike most shells, where it would evaporate).\n     */\n    len = -1;\t\t\t/* overload 'len' with flag value */\n    context = NULL;\t\t/* init */\n    while (vmswork(LIB$FIND_FILE(&spec, &result, &context))) {\n\tfor (len = sizeof(res_buf)-1; len > 0 && res_buf[len-1] == ' '; len--) ;\n\tres_buf[len] = '\\0';\t/* terminate after discarding trailing blanks */\n\tv_add_arg(v_argc++, strdup(res_buf));\t\t/* store result */\n    }\n    (void)LIB$FIND_FILE_END(&context);\n    if (len >= 0)\t\t/* (still -1 => never entered loop) */\n\t--v_argc;\t\t/* undo final post-increment */\n    return;\n}",
      "lines": 42,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "v_add_arg": {
      "start_point": [
        362,
        0
      ],
      "end_point": [
        388,
        1
      ],
      "content": "void\nv_add_arg( int idx, const char *val )\n{\n#ifdef DEBUG_VMS\n    fprintf(stderr, \"v_add_arg: v_argv[%d] \", idx);\n#endif\n    if (idx + 1 >= v_argz) {\t/* 'v_argz' is the current size of v_argv[] */\n\tint old_size = v_argz;\n\n\tv_argz = idx + 10;\t/* increment by arbitrary amount */\n\tif (old_size == 0)\n\t    v_argv = (char **)malloc((unsigned)(v_argz * sizeof(char **)));\n\telse\n\t    v_argv = (char **)realloc((char *)v_argv,\n\t\t\t\t     (unsigned)(v_argz * sizeof(char **)));\n\tif (v_argv == NULL) {\t/* error */\n\t    fatal(\"%s: %s: can't allocate memory (%s)\", \"vms_args\",\n\t\t  \"v_argv\", strerror(errno));\n\t} else {\n\t    while (old_size < v_argz)  v_argv[old_size++] = NULL;\n\t}\n    }\n    v_argv[idx] = (char *)val;\n#ifdef DEBUG_VMS\n    fprintf(stderr, \"= \\\"%s\\\"\\n\", val);\n#endif\n}",
      "lines": 27,
      "depth": 18,
      "decorators": [
        "void"
      ]
    },
    "skipblanks": {
      "start_point": [
        391,
        0
      ],
      "end_point": [
        398,
        1
      ],
      "content": "static char *\nskipblanks( const char *ptr )\n{\n    if (ptr)\n\twhile (*ptr == ' ' || *ptr == '\\t')\n\t    ptr++;\n    return (char *)ptr;\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nskipblanks( const char *ptr )",
        "*"
      ]
    },
    "vms_define": {
      "start_point": [
        401,
        0
      ],
      "end_point": [
        423,
        1
      ],
      "content": "static U_Long\nvms_define( const char *log_name, const char *trans_val )\n{\n    struct dsc$descriptor_s log_dsc;\n    static Descrip(lnmtable,\"LNM$PROCESS_TABLE\");\n    static U_Long attr = LNM$M_CONFINE;\n    static Itm itemlist[] = { {0,LNM$_STRING,0,0}, {0,0} };\n    static unsigned char acmode = PSL$C_USER;\n    unsigned len = strlen(log_name);\n\n    /* avoid \"define SYS$OUTPUT sys$output:\" for redundant \">sys$output:\" */\n    if (strncasecmp(log_name, trans_val, len) == 0\n     && (trans_val[len] == '\\0' || trans_val[len] == ':'))\n\treturn 0;\n\n    log_dsc.dsc$a_pointer = (char *)log_name;\n    log_dsc.dsc$w_length = len;\n    log_dsc.dsc$b_dtype = DSC$K_DTYPE_T;\n    log_dsc.dsc$b_class = DSC$K_CLASS_S;\n    itemlist[0].buffer = (char *)trans_val;\n    itemlist[0].len = strlen(trans_val);\n    return SYS$CRELNM(&attr, &lnmtable, &log_dsc, &acmode, itemlist);\n}",
      "lines": 23,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "U_Long"
      ]
    },
    "t_strstr": {
      "start_point": [
        427,
        0
      ],
      "end_point": [
        441,
        1
      ],
      "content": "static char *t_strstr ( const char *str, const char *sub )\n{\n    register const char *s0, *s1, *s2;\n\n    /* special case: empty substring */\n    if (!*sub)\treturn (char *)str;\n\n    /* brute force method */\n    for (s0 = s1 = str; *s1; s1 = ++s0) {\n\ts2 = sub;\n\twhile (*s1++ == *s2++)\n\t    if (!*s2)  return (char *)s0;\t/* full match */\n    }\n    return (char *)0;\t/* not found */\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "char",
        "*t_strstr ( const char *str, const char *sub )",
        "*"
      ]
    }
  },
  "gawk/gawk-4.2.1/vms/vms_cli.c": {
    "Cli_Present": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "U_Long\nCli_Present( const char *item )\n{\n    struct dsc$descriptor_s item_dsc;\n    (void)LIB$ESTABLISH(LIB$SIG_TO_RET);\n\n    item_dsc.dsc$w_length = strlen(item_dsc.dsc$a_pointer = (char *)item);\n    item_dsc.dsc$b_dtype = DSC$K_DTYPE_T;\n    item_dsc.dsc$b_class = DSC$K_CLASS_S;\n    return CLI$PRESENT(&item_dsc);\n}",
      "lines": 11,
      "depth": 11,
      "decorators": [
        "U_Long"
      ]
    },
    "Cli_Get_Value": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        75,
        1
      ],
      "content": "U_Long\nCli_Get_Value( const char *item, char *result, int size )\n{\n    struct dsc$descriptor_s item_dsc, res_dsc;\n    U_Long sts;\n    short len = 0;\n    (void)LIB$ESTABLISH(LIB$SIG_TO_RET);\n\n    item_dsc.dsc$w_length = strlen(item_dsc.dsc$a_pointer = (char *)item);\n    item_dsc.dsc$b_dtype = DSC$K_DTYPE_T;\n    item_dsc.dsc$b_class = DSC$K_CLASS_S;\n    res_dsc.dsc$w_length = size;\n    res_dsc.dsc$a_pointer = result;\n    res_dsc.dsc$b_dtype = DSC$K_DTYPE_T;\n    res_dsc.dsc$b_class = DSC$K_CLASS_S;\n    sts = CLI$GET_VALUE(&item_dsc, &res_dsc, &len);\n    result[len] = '\\0';\n    return sts;\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "U_Long"
      ]
    },
    "Cli_Parse_Command": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        119,
        1
      ],
      "content": "U_Long\nCli_Parse_Command( const void *cmd_tables, const char *cmd_verb )\n{\n    struct { short len, code; void *adr; } fscn[2];\n    struct { char rqtype, rqindx, rqflags, rqstat; unsigned :32;\n\t     struct dsc$descriptor_s rdesc;\n             unsigned :32; unsigned :32; unsigned :32; } cmd;\n    U_Long sts;\n    int    ltmp;\n    char   longbuf[8200];\n    (void)LIB$ESTABLISH(LIB$SIG_TO_RET);\n\n    memset(&cmd, 0, sizeof cmd);\n    cmd.rqtype = CLI$K_GETCMD;\t\t/* command line minus the verb */\n    sts = SYS$CLI(&cmd, (void *)0, (void *)0);\t/* get actual command line */\n\n    if (vmswork(sts)) {\t\t/* ok => cli available & verb wasn't \"RUN\" */\n\t/* invoked via symbol => have command line (which might be empty) */\n\t/*    [might also be invoked via mcr or dcl; that's ok]\t\t  */\n\tif (cmd.rqstat == CLI$K_VERB_MCR) {\n\t    /* need to strip image name from MCR invocation   */\n\t    memset(fscn, 0, sizeof fscn);\n\t    fscn[0].code = FSCN$_FILESPEC;\t/* full file specification */\n\t    (void)SYS$FILESCAN(&cmd.rdesc, fscn, (long *)0);\n\t    cmd.rdesc.dsc$w_length -= fscn[0].len;\t/* shrink size */\n\t    cmd.rdesc.dsc$a_pointer += fscn[0].len;\t/* advance ptr */\n\t}\n\t/* prepend verb and then parse the command line */\n\tstrcat(strcpy(longbuf, cmd_verb), \" \"),  ltmp = strlen(longbuf);\n\tif (cmd.rdesc.dsc$w_length + ltmp > sizeof longbuf)\n\t    cmd.rdesc.dsc$w_length = sizeof longbuf - ltmp;\n\tstrncpy(&longbuf[ltmp],\n                cmd.rdesc.dsc$a_pointer, cmd.rdesc.dsc$w_length);\n\tcmd.rdesc.dsc$w_length += ltmp,\tcmd.rdesc.dsc$a_pointer = longbuf;\n\tsts = CLI$DCL_PARSE(&cmd.rdesc, cmd_tables);\n    }\n\n    return sts;\n}",
      "lines": 39,
      "depth": 14,
      "decorators": [
        "U_Long"
      ]
    }
  },
  "gawk/gawk-4.2.1/vms/vms_crtl_init.c": {
    "sys_trnlnm": {
      "start_point": [
        125,
        0
      ],
      "end_point": [
        160,
        1
      ],
      "content": "static int sys_trnlnm\n   (const char * logname,\n    char * value,\n    int value_len)\n{\n    const $DESCRIPTOR(table_dsc, \"LNM$FILE_DEV\");\n    const unsigned long attr = LNM$M_CASE_BLIND;\n    struct dsc$descriptor_s name_dsc;\n    int status;\n    unsigned short result;\n    struct itmlst_3 itlst[2];\n\n    itlst[0].buflen = value_len;\n    itlst[0].itmcode = LNM$_STRING;\n    itlst[0].bufadr = value;\n    itlst[0].retlen = &result;\n\n    itlst[1].buflen = 0;\n    itlst[1].itmcode = 0;\n\n    name_dsc.dsc$w_length = strlen(logname);\n    name_dsc.dsc$a_pointer = (char *)logname;\n    name_dsc.dsc$b_dtype = DSC$K_DTYPE_T;\n    name_dsc.dsc$b_class = DSC$K_CLASS_S;\n\n    status = SYS$TRNLNM(&attr, &table_dsc, &name_dsc, 0, itlst);\n\n    if ($VMS_STATUS_SUCCESS(status)) {\n\n\t /* Null terminate and return the string */\n\t/*--------------------------------------*/\n\tvalue[result] = '\\0';\n    }\n\n    return status;\n}",
      "lines": 36,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "sys_crelnm": {
      "start_point": [
        163,
        0
      ],
      "end_point": [
        194,
        1
      ],
      "content": "static int sys_crelnm\n   (const char * logname,\n    const char * value)\n{\n    int ret_val;\n    const char * proc_table = \"LNM$PROCESS_TABLE\";\n    struct dsc$descriptor_s proc_table_dsc;\n    struct dsc$descriptor_s logname_dsc;\n    struct itmlst_3 item_list[2];\n\n    proc_table_dsc.dsc$a_pointer = (char *) proc_table;\n    proc_table_dsc.dsc$w_length = strlen(proc_table);\n    proc_table_dsc.dsc$b_dtype = DSC$K_DTYPE_T;\n    proc_table_dsc.dsc$b_class = DSC$K_CLASS_S;\n\n    logname_dsc.dsc$a_pointer = (char *) logname;\n    logname_dsc.dsc$w_length = strlen(logname);\n    logname_dsc.dsc$b_dtype = DSC$K_DTYPE_T;\n    logname_dsc.dsc$b_class = DSC$K_CLASS_S;\n\n    item_list[0].buflen = strlen(value);\n    item_list[0].itmcode = LNM$_STRING;\n    item_list[0].bufadr = (char *)value;\n    item_list[0].retlen = NULL;\n\n    item_list[1].buflen = 0;\n    item_list[1].itmcode = 0;\n\n    ret_val = SYS$CRELNM(NULL, &proc_table_dsc, &logname_dsc, NULL, item_list);\n\n    return ret_val;\n}",
      "lines": 32,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "set_feature_default": [
      {
        "start_point": [
          203,
          0
        ],
        "end_point": [
          206,
          1
        ],
        "content": "static void set_feature_default(const char *name, const char *value)\n{\n    sys_crelnm(name, value);\n}",
        "lines": 4,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          208,
          0
        ],
        "end_point": [
          216,
          1
        ],
        "content": "static void set_feature_default(const char *name, int value)\n{\n     int index;\n\n     index = decc$feature_get_index(name);\n\n     if (index > 0)\n\tdecc$feature_set_value (index, 0, value);\n}",
        "lines": 9,
        "depth": 7,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      }
    ],
    "set_coe": {
      "start_point": [
        219,
        0
      ],
      "end_point": [
        430,
        1
      ],
      "content": "static void set_coe ( void )\n{\n\n    char gnv_posix_root[4096];\n    char unix_shell_name[255];\n    int use_unix_settings = 0;\n    int status;\n    int gnv_posix_root_found = 0;\n\n    /* If this is compiled for use with a UNIX shell, then the logical\n     * name GNV$UNIX_SHELL will be set to that shell name.\n     *\n     * Else, if the GNV$UNIX_SHELL logical name is set, then this application\n     * is running under some UNIX like shell, so it should modify it's\n     * behavior to be UNIX like.\n     *\n     * If the above logical name is not set, then the application should\n     * expect that it is running under DCL, and should expect VMS filenames\n     * on input, and may need to output filenames in VMS format.\n     *\n     * This can be overriden at compile time with GNV_UNIX_TOOL being\n     * defined.\n     *\n     * So this means that there will be multiple object modules from this\n     * source module.  One for each shell, one for programs that can function\n     * in both DCL and UNIX environments, and one for programs that require\n     * a UNIX environment.\n     */\n\n#ifdef GNV_UNIX_SHELL\n    use_unix_settings = 1;\n\n    status = sys_crelnm(\"GNV$UNIX_SHELL\", GNV_UNIX_SHELL);\n    if (!$VMS_STATUS_SUCCESS(status)) {\n\t/* We have a big problem */\n\tLIB$SIGNAL(status);\n    }\n#else\n\n#ifdef GNV_UNIX_TOOL\n    use_unix_settings = 1;\n#else\n    status = sys_trnlnm(\"GNV$UNIX_SHELL\",\n\t\t\tunix_shell_name, sizeof\n\t\t\tunix_shell_name -1);\n    if (!$VMS_STATUS_SUCCESS(status)) {\n\tunix_shell_name[0] = 0;\n\tuse_unix_settings = 0;\n    }\n#endif /* GNV_UNIX_TOOL */\n\n#endif /* GNV_UNIX_SHELL */\n\n    /* New style interface that works only on very recent\n       (Apr 2001 and beyond) CRTLs */\n\n    /*\n     * Only setting defaults allows logical names to\n     * override these settings.\n     */\n\n    /* Always set */\n\n    /* ACCESS should check ACLs or it is lying. */\n    set_feature_default(\"DECC$ACL_ACCESS_CHECK\"\t\t, ENABLE);\n\n    /* We always want the new parse style */\n    set_feature_default (\"DECC$ARGV_PARSE_STYLE\"\t, ENABLE);\n\n    /* Unless we are in POSIX compliant mode, we want the old POSIX root\n     * enabled.\n     */\n    set_feature_default(\"DECC$DISABLE_POSIX_ROOT\", DISABLE);\n\n    /* EFS charset, means UTF-8 support */\n    /* VTF-7 support is controlled by a feature setting called UTF8 */\n    set_feature_default (\"DECC$EFS_CHARSET\" \t\t, ENABLE);\n    set_feature_default (\"DECC$EFS_CASE_PRESERVE\"\t, ENABLE);\n\n\n    /* Support timestamps when available */\n    set_feature_default (\"DECC$EFS_FILE_TIMESTAMPS\"\t, ENABLE);\n\n    /* Cache environment varibles - performance improvements */\n    set_feature_default (\"DECC$ENABLE_GETENV_CACHE\"\t, ENABLE);\n\n    /* Start out with new file attribute inheritance */\n#ifdef __VAX\n    set_feature_default (\"DECC$EXEC_FILEATTR_INHERITANCE\", \"2\");\n#else\n    set_feature_default (\"DECC$EXEC_FILEATTR_INHERITANCE\", 2);\n#endif\n\n    /* Don't display trailing dot after files without type */\n    set_feature_default (\"DECC$READDIR_DROPDOTNOTYPE\"\t, ENABLE);\n\n    /* For standard output channels buffer output until terminator */\n    /* Gets rid of output logs with single character lines in them. */\n    set_feature_default (\"DECC$STDIO_CTX_EOL\"\t\t, ENABLE);\n\n    /* Fix mv aa.bb aa\t\t\t\t\t\t*/\n    set_feature_default (\"DECC$RENAME_NO_INHERIT\"  \t, ENABLE);\n\n    if (use_unix_settings) {\n\n\t/* POSIX requires that open files be able to be removed */\n\tset_feature_default (\"DECC$ALLOW_REMOVE_OPEN_FILES\", ENABLE);\n\n\tset_feature_default (\"DECC$FILENAME_UNIX_ONLY\"\t, ENABLE);\n\t\t/* FILENAME_UNIX_ONLY Implicitly sets\n\t\t  decc$disable_to_vms_logname_translation */\n\n\tset_feature_default (\"DECC$FILE_PERMISSION_UNIX\", ENABLE);\n\n\t/* For now this only with UNIX mode, applications can override\n\t * with out using a LIB$INITIALIZE setting.\n\t * This should be an application specific setting only enabled\n\t * if the application requires it.\n\t * Left here for now for backwards compatibility\n         */\n\tset_feature_default (\"DECC$FILE_SHARING\"\t, ENABLE);\n\n        set_feature_default (\"DECC$FILE_OWNER_UNIX\"  \t, ENABLE);\n        set_feature_default (\"DECC$POSIX_SEEK_STREAM_FILE\", ENABLE);\n\n    } else {\n\t set_feature_default(\"DECC$FILENAME_UNIX_REPORT\", ENABLE);\n    }\n\n    /* When reporting UNIX filenames, glob the same way */\n    set_feature_default (\"DECC$GLOB_UNIX_STYLE\"\t, ENABLE);\n\n    /* The VMS version numbers on Unix filenames is incompatible with most */\n    /* ported packages. */\n    set_feature_default(\"DECC$FILENAME_UNIX_NO_VERSION\", ENABLE);\n\n    /* The VMS version numbers on Unix filenames is incompatible with most */\n    /* ported packages. */\n    set_feature_default(\"DECC$UNIX_PATH_BEFORE_LOGNAME\", ENABLE);\n\n    /* Set strtol to proper behavior */\n    set_feature_default(\"DECC$STRTOL_ERANGE\", ENABLE);\n\n    /*  Pipe feature settings are longer needed with virtual memory pipe\n\tcode.  Programs that use  pipe need to be converted to use the\n\tvirtual memory pipe code, which effectively removes the hangs and\n\tleft over temporary files.\n\n        Comment left here to prevent regressions, as the larger pipe size\n        actually hurts memory usage with the new algorithm.\n     */\n    /* do_not_set_default (\"DECC$PIPE_BUFFER_SIZE\"\t, 8192); */\n\n\n    /* Rather than remove this completely, a comment is left here to warn\n     * someone from putting this bug back in.\n     *\n     * POSIX style UIDs require that the system administrator have set the\n     * system up to use POSIX style UIDs and GIDs.  And if they have done\n     * so, then they should set the DECC$POSIX_STYLE_UID as a system wide\n     * logical name.\n     *\n     * Setting them in a program will break all routines that expect GID/UID\n     * stuff to work on systems set up by default with out mappings.\n     *\n     * Most utilities do not reference GID/UID values, so it took a while for\n     * this bug to surface.\n     */\n     /*  do_not_set_default (\"DECC$POSIX_STYLE_UID\"\t, TRUE); */\n\n\n\n    /* GNV depends on SYS$POSIX_ROOT to be properly set.  Since SYS$POSIX_ROOT\n     * globally affects all C applications, SYS$POSIX_ROOT can not be set\n     * anywhere that can be seen by other applications.\n     *\n     * So GNV$GNU is used instead, and SYS$POSIX_ROOT will be set in\n     * in the process table in user mode to that value.\n     *\n     * Restriction: The system manager should not point GNV$GNU at\n     * SYS$POSIX_ROOT, or anything that resolves to SYS$POSIX_ROOT.\n     *\n     */\n\n    status = sys_trnlnm(\"GNV$GNU\",\n\t\t\tgnv_posix_root,\n\t\t\tsizeof gnv_posix_root - 1);\n    if ($VMS_STATUS_SUCCESS(status)) {\n\tstatus = sys_crelnm(\"SYS$POSIX_ROOT\", \"GNV$GNU:\");\n\tgnv_posix_root_found = 1;\n    }\n\n    /* GNV depends on BIN being set to GNV$GNU:[bin].  Since BIN\n     * is not prefixed, and it affects everything globally, it needs to\n     * be set here if it is not defined already.\n     * If it is set already, assume that it is correct, rather than\n     * trying to second guess the user.\n     * If GNV$GNU is not defined, then define bin to be SYS$POSIX_ROOT.\n     */\n\n    status = sys_trnlnm(\"BIN\",\n\t\t\tgnv_posix_root,\n\t\t\tsizeof gnv_posix_root - 1);\n    if (!$VMS_STATUS_SUCCESS(status)) {\n\tif (gnv_posix_root_found) {\n\t    status = sys_crelnm(\"BIN\", \"GNV$GNU:[BIN]\");\n\t} else {\n\t    status = sys_crelnm(\"BIN\", \"SYS$POSIX_ROOT:[BIN]\");\n\t}\n    }\n\n}",
      "lines": 212,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "gawk/gawk-4.2.1/vms/vms_fwrite.c": {
    "find_c": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        33,
        1
      ],
      "content": "static int find_c( const char *s, int n, char c ) {\n    register const char *t = (const char *)memchr(s, c, n);\n    return (t == 0 ? n : t - s);\t/* 0..n-1, or n if not found */\n}",
      "lines": 4,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "tty_fwrite": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        194,
        1
      ],
      "content": "size_t\ntty_fwrite( const void *buf, size_t size, size_t number, FILE *file )\n{\n    static long evfn = -1;\n    short chan;\n    int file_num, result;\n\n    if (!size || !number)\n\treturn 0;\n    else if (!file || !*file)\n\treturn 0 * (errno = EBADF);\t/* kludge alert! */\n    else if (file == prev_file)\n\tfile_num = prev_file_num;\n    else\t/* note: VAXCRTL's fileno() is a function, not just a macro */\n\tprev_file_num = file_num = fileno(file),  prev_file = file;\n\n    chan = file_num < _NFILE ? channel[file_num] : -1;\n    if (chan == 0) {\t/* if not initialized, need to assign a channel */\n\tif (isatty(file_num) > 0\t/* isatty: 1=yes, 0=no, -1=problem */\n\t    && ! do_debug) {\n\t    struct dsc$descriptor_s  device;\n\t    char devnam[255+1];\n\n\t    fgetname(file, devnam);\t\t\t/* get 'file's name */\n            /* create descriptor */\n\t    device.dsc$w_length = strlen(device.dsc$a_pointer = devnam);\n            device.dsc$b_dtype = DSC$K_DTYPE_T;\n            device.dsc$b_class = DSC$K_CLASS_S;\n\t    if (vmswork(SYS$ASSIGN(&device, &chan, 0,\n                                  (struct dsc$descriptor_s *)0))) {\n\t\t/* get an event flag; use #0 if problem */\n\t\tif (evfn == -1 && vmsfail(LIB$GET_EF(&evfn)))  evfn = 0;\n\t    } else  chan = 0;\t    /* $ASSIGN failed */\n\t}\n\t/* store channel for later use; -1 => don't repeat failed init attempt */\n\tchannel[file_num] = (chan > 0 ? chan : -1);\n    }\n\n    /* chan > 0 iff 'file' is a terminal and we're not running as dgawk */\n    if (chan > 0) {\n\tstruct _iosbw { U_Short status, count; U_Long rt_kludge; } iosb;\n\tregister U_Long sts = 1;\n\tregister char  *pt = (char *)buf;\n\tregister int\toffset, pos, count = size * number;\n\tU_Long cc_fmt, io_func = IO$_WRITEVBLK;\n\tint    extra = 0;\n\n\tresult = 0;\n\tif (is_stderr(file_num))\t/* if it's SYS$ERROR (stderr)... */\n\t    io_func |= IO$M_CANCTRLO;\t/* cancel ^O (resume tty output) */\n\twhile (count > 0) {\n\t    /* special handling for line-feeds to make them be 'newlines' */\n\t    offset = 0;\n\t    if (*pt == '\\n') {\t    /* got at least one leading line-feed */\n\t\tcc_fmt = PREFIX_CR,  extra++;\t/* precede 1st LF with a CR */\n\t\tdo  offset++;\n\t\t    while (offset < count && *(pt + offset) == '\\n');\n\t    } else\n\t\tcc_fmt = 0;\n\t    /* look for another line-feed; if found, break line there */\n\t    pos = offset + find_c(pt + offset, count - offset, '\\n');\n\t    if (pos >= BUFSIZ)\tpos = BUFSIZ - 1;   /* throttle quota usage */\n\t    else if (pos < count)  pos++,  cc_fmt |= POSTFIX_CR,  extra++;\n\t    /* wait for previous write, if any, to complete */\n\t    if (pt > (char *)buf) {\n\t\tsts = SYS$SYNCH(evfn, &iosb);\n\t\tif (vmswork(sts))  sts = iosb.status,  result += iosb.count;\n\t\tif (vmsfail(sts))  break;\n\t    }\n\t    /* queue an asynchronous write */\n\t    sts = SYS$QIO(evfn, chan, io_func, &iosb, (void (*)(U_Long))0, 0L,\n\t\t\t  pt, pos, 0, cc_fmt, 0, 0);\n\t    if (vmsfail(sts))  break;\t/*(should never happen)*/\n\t    pt += pos,\tcount -= pos;\n\t}\n\t/* wait for last write to complete */\n\tif (pt > (char *)buf && vmswork(sts)) {\n\t    sts = SYS$SYNCH(evfn, &iosb);\n\t    if (vmswork(sts))  sts = iosb.status,  result += iosb.count;\n\t}\n\tif (vmsfail(sts))  errno = EVMSERR,  vaxc$errno = sts;\n\telse if (iosb.rt_kludge == 0)  result = number + extra;\n\tresult -= extra;    /* subtract the additional carriage-returns */\n    } else {\t\t\t\t/* use stdio */\n\t/* Note: we assume that we're writing text, not binary data.\n\t   For stream format files, 'size' and 'number' are effectively\n\t   interchangable, and fwrite works fine.  However, for record\n\t   format files, 'size' governs the maximum record length, so\n\t\tfwrite(string, size(char), strlen(string), file)\n\t   will produce a sequence of 1-byte records, which is hardly\n\t   what we want in this (assumed) situation.  Line-feeds ('\\n')\n\t   are converted into newlines (ie, record separators) by the\n\t   run-time library, but strings that don't end with a newline\n\t   still become separate records.  The simplest work around\n\t   is just to use fputs() instead of fwrite(); unfortunately,\n\t   we have to provide special treatment for NULs ('\\0's).\n\t   At present, only stdout might be in record format (via\n\t   >$'filename' redirection on the command line).\n\t*/\n\tif (size > 1) {\t\t/* not used by GAWK */\n\t    result = fwrite((void *)buf, size, number, file);\n\t} else if (*((char *)buf + number - 1) == '\\n' || !is_stdout(file_num)) {\n\t    result = fwrite((void *)buf, number, size, file);\n\t    result = result * number / size;\t/*(same as 'result = number')*/\n\t} else {\n#ifdef NO_ALLOCA\n# define alloca(n) ((n) <= abuf_siz ? abuf : \\\n\t\t    ((abuf_siz > 0 ? (free(abuf),0) : 0), \\\n\t\t     (abuf = malloc(abuf_siz = (n)+20))))\n\t    static void *abuf = 0;\n\t    static size_t abuf_siz = 0;\n#endif /*NO_ALLOCA*/\n\t    register char *pt = (char *)buf;\n\t    register int   pos,  count = number;\n\n\t    if (pt[count] != '\\0') {\t/*(out of bounds, but relatively safe)*/\n\t\tpt = (char *)alloca(count + 1);\n\t\tmemcpy(pt, buf, count),  pt[count] = '\\0';\n\t\t/* if exiting this block undoes the alloca(), we're hosed :-( */\n\t    }\n\t    result = 0;\n\t    while (count > 0) {\n\t\tpos = find_c(pt, count, '\\0');\n\t\tif (fputs(pt, file) < 0)  break;\n\t\tif (pos < count) {\n\t\t    if (fputc('\\0', file) < 0)\tbreak;\n\t\t    pos++;\t\t/* 0..n-1 -> 1..n */\n\t\t}\n\t\tresult += pos,\tpt += pos,  count -= pos;\n\t    }\n\t}\n    }\n    return result;\n}",
      "lines": 134,
      "depth": 18,
      "decorators": [
        "size_t"
      ]
    },
    "tty_fclose": {
      "start_point": [
        201,
        0
      ],
      "end_point": [
        215,
        1
      ],
      "content": "int\ntty_fclose( FILE *file )\n{\n    if (file && *file) {  /* note: VAXCRTL stdio has extra level of indirection */\n\tint   file_num = fileno(file);\n\tshort chan = file_num < _NFILE ? channel[file_num] : -1;\n\n\tif (chan > 0)\n\t    (void)SYS$DASSGN(chan); /* deassign the channel (ie, close) */\n\tif (file_num < _NFILE)\n\t    channel[file_num] = 0;  /* clear stale info */\n    }\n    prev_file = 0;\t\t    /* force tty_fwrite() to reset */\n    return fclose(file);\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "gawk/gawk-4.2.1/vms/vms_gawk.c": {
    "vms_gawk": {
      "start_point": [
        73,
        0
      ],
      "end_point": [
        207,
        1
      ],
      "content": "int\nvms_gawk()\n{\n    U_Long sts;\n    union arg_w_prefix buf;\n    char misc_args[10], *misc_argp;\n    int  argc, W_cnt;\n    int native_dcl = 1,\t/* assume true until we know otherwise */\n\tshort_circ;\t/* some options make P1, /commands, /input superfluous */\n\n    /* check \"GAWK_P1\"--it's required; its presence will tip us off */\n    sts = Cli_Present(\"GAWK_P1\");\n    if (CondVal(sts) == CondVal(CLI$_SYNTAX)) {\n\tnative_dcl = 0;\t\t/* not invoked via a native command verb */\n\t/* syntax error indicates that we weren't invoked as a native DCL\n\t   command, so we'll now attempt to generate a command from the\n\t   foreign command string and parse that.\n\t*/\n\tsts = Cli_Parse_Command(gawk_cmd, \"GAWK\");\t/* (*not* CmdName) */\n\tif (vmswork(sts))\n\t    sts = Cli_Present(\"GAWK_P1\");\n    }\n    short_circ = Present(\"USAGE\") || Present(\"VERSION\") || Present(\"COPYRIGHT\");\n    if (vmswork(sts))\t\t/* command parsed successfully */\n\tv_add_arg(argc = 0, CmdName);\t/* save \"GAWK\" as argv[0] */\n    else if (CondVal(sts) == CondVal(CLI$_INSFPRM))\n\t/* vms_usage() will handle /usage, /version, and /copyright */\n\treturn short_circ ? vms_usage(0)\n\t\t: native_dcl ? vms_usage(USAGE_FILE_RQRD) : 0; /* insufficient parameters */\n    else if (CondVal(sts) == CondVal(CLI$_CONFLICT))\n\treturn vms_usage(USAGE_BAD_COMBO);  /* conflicting qualifiers (/input+/command) */\n#if 0\t/* 3.1.2: removed since this can't distinguish RUN vs fork+exec */\n    else if (CondVal(sts) == CondVal(CLI$_RUNUSED))\n\treturn vms_usage(USAGE_RUN_CMD);    /* RUN GAWK won't work (no command line) */\n#endif\n    else\n\treturn 0;\t/* forced to rely on original parsing */\n\n    if (short_circ)\t\t/* give usage message & quit or have main() */\n\treturn vms_usage(0);\t/* give --version or --copyleft mesg & quit */\n    else if (! (Present(\"PROGRAM\") || Present(\"PROGFILE\")) )\n\treturn native_dcl ? vms_usage(USAGE_PROG_RQRD) : 0; /* missing required option */\n\n    misc_argp = misc_args;\n    *misc_argp++ = '-';\t\t/* now points at &misc_args[1] */\n    if (Present(\"OPTIMIZE\"))\n\t*misc_argp++ = 'O';\n    W_cnt = 0,\tbuf.arg.buf[0] = '\\0';\n    strncpy(buf.arg.prefix, \"-W\", 2);\n    if (Present(\"LINT\")) {\n\tif (!Present(\"LINT.FATAL\") && !Present(\"LINT.INVALID\"))\n\t    chk_option(\"LINT.WARN\", \"lint\");\n\tchk_option(\"LINT.FATAL\", \"lint=fatal\");\n\tchk_option(\"LINT.INVALID\", \"lint=invalid\");\n\tchk_option(\"LINT.OLD\", \"lint-old\");\t/* distinct option */\n    }\n    chk_option(\"POSIX\", \"posix\");\n    if (CondVal(Cli_Present(\"TRADITIONAL\")) != CondVal(CLI$_NEGATED))\n\tchk_option(\"STRICT\", \"traditional\");  /* /strict is synonym for /traditional */\n    if (CondVal(Cli_Present(\"STRICT\")) != CondVal(CLI$_NEGATED))\n\tchk_option(\"TRADITIONAL\", \"traditional\");\n    chk_option(\"RE_INTERVAL\", \"re-interval\");  /* only used with /traditional */\n    chk_option(\"SANDBOX\", \"sandbox\");\n    /* potentially a problem due to leading \"NO\" */\n    chk_option(\"NON_DECIMAL_DATA\", \"non-decimal-data\");\n    /* note: locale and translation stuff is not supported by vms gawk */\n    chk_option(\"CHARACTERS_AS_BYTES\", \"characters-as-bytes\");\n    chk_option(\"USE_LC_NUMERIC\", \"use-lc-numeric\");\n    chk_option(\"GEN_POT\", \"gen-pot\");\n# if 0\n    /* /copyright and /version don't reach here anymore (short_circ above) */\n    chk_option(\"COPYRIGHT\", \"copyright\");\t/* --copyleft */\n    chk_option(\"VERSION\", \"version\");\n# endif\n    if (W_cnt > 0)\t\t\t/* got something */\n\tv_add_arg(++argc, strdup(buf.value));\n\n#ifdef DEBUG /* most debugging functionality moved to separate DGAWK program */\n    if (Present(\"DEBUG\"))\n\t    *misc_argp++ = 'Y';\t\t/* --parsedebug */\n#endif\n    *misc_argp = '\\0';\t\t/* terminate misc_args[] */\n    if (misc_argp > &misc_args[1])\t/* got something */\n\tv_add_arg(++argc, misc_args);\t/* store it/them */\n\n    if (Present(\"PROFILE\")) {\t    /* /profile[=file] */\n\tstrncpy(buf.arg.prefix, \"-p\", 2);\n\tif (Get_Value(\"PROFILE\", buf.arg.buf, sizeof buf.arg.buf))\n\t    v_add_arg(++argc, strdup(buf.value));\n    }\n    if (Present(\"DUMP_VARIABLES\")) { /* /dump_variables[=file] */\n\tstrncpy(buf.arg.prefix, \"-d\", 2);\n\tif (Get_Value(\"DUMP_VARIABLES\", buf.arg.buf, sizeof buf.arg.buf))\n\t    v_add_arg(++argc, strdup(buf.value));\n    }\n    if (Present(\"FIELD_SEP\")) {     /* field separator */\n\tstrncpy(buf.arg.prefix, \"-F\", 2);\n\tif (Get_Value(\"FIELD_SEP\", buf.arg.buf, sizeof buf.arg.buf))\n\t    v_add_arg(++argc, strdup(buf.value));\n    }\n    if (Present(\"VARIABLES\")) {     /* variables to init prior to BEGIN */\n\tstrncpy(buf.arg.prefix, \"-v\", 2);\n\twhile (Get_Value(\"VARIABLES\", buf.arg.buf, sizeof buf.arg.buf))\n\t    v_add_arg(++argc, strdup(buf.value));\n    }\n    /* the relative order of -e and -f args matters; unfortunately,\n       we're losing that here... */\n    if (Present(\"MOREPROG\")) {\t    /* /extra_input=text -> -e text */\n\tstrncpy(buf.arg.prefix, \"-e\", 2);\n\tif (Get_Value(\"MOREPROG\", buf.arg.buf, sizeof buf.arg.buf))\n\t    v_add_arg(++argc, strdup(buf.value));\n    }\n    if (Present(\"PROGFILE\")) {\t    /* program files, /input=file -> -f file */\n\tstrncpy(buf.arg.prefix, \"-f\", 2);\n\twhile (Get_Value(\"PROGFILE\", buf.arg.buf, sizeof buf.arg.buf))\n\t    v_add_arg(++argc, strdup(buf.value));\n\tv_add_arg(++argc, \"--\");\n    } else if (Present(\"PROGRAM\")) {\t/* program text, /commands -> 'text' */\n\tv_add_arg(++argc, \"--\");\n\tif (Get_Value(\"PROGRAM\", buf.value, sizeof buf.value))\n\t    v_add_arg(++argc, strdup(buf.value));\n    }\n\n    /* we know that \"GAWK_P1\" is present [data files and/or 'var=value'] */\n    while (Get_Value(\"GAWK_P1\", buf.value, sizeof buf.value))\n\tv_add_arg(++argc, strdup(buf.value));\n\n    if (Present(\"OUTPUT\")) {\t/* let other parser treat this as 'stdout' */\n\tstrncpy(buf.arg.prefix, \">$\", 2);\n\tif (Get_Value(\"OUTPUT\", buf.arg.buf, sizeof buf.arg.buf))\n\t    v_add_arg(++argc, strdup(buf.value));\n    }\n\n    return ++argc;\t\t/*(increment to account for arg[0])*/\n}",
      "lines": 135,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "vms_usage": {
      "start_point": [
        210,
        0
      ],
      "end_point": [
        289,
        1
      ],
      "content": "static int\t/* note: usually doesn't return */\nvms_usage( int complaint )\n{\n    static const char\n\t*usage_txt = \"\\n\\\nusage: %s /COMMANDS=\\\"awk program text\\\"  data_file[,data_file,...] \\n\\\n   or  %s /INPUT=awk_file  data_file[,\\\"Var=value\\\",data_file,...] \\n\\\n   or  %s /INPUT=(awk_file1,awk_file2,...)  data_file[,...] \\n\\\n   or  %s /INPUT=awk_file /EXTRA_COMMANDS=\\\"program text\\\" data_file \\n\\\n\",\n    *options_txt = \"\\n\\\noptions: /FIELD_SEPARATOR=\\\"FS_value\\\" \\n\\\n   and   /VARIABLES=(\\\"Var1=value1\\\",\\\"Var2=value2\\\",...) \\n\\\n   and   /OPTIMIZE  /PROFILE[=file]  /DUMP_VARIABLES[=file] \\n\\\n   and   /POSIX  /[NO]TRADITIONAL  /[NO]STRICT  /RE_INTERVAL \\n\\\n   and   /SANDBOX  /NON_DECIMAL_DATA \\n\\\n   and   /LINT[=WARN]  or  /LINT=OLD  or  /LINT=FATAL \\n\\\n   and   /VERSION  /COPYRIGHT  /USAGE \\n\\\n   and   /OUTPUT=out_file \\n\\\n\",  /* omitted: /LINT=INVALID /CHARACTERS_AS_BYTES /USE_LC_NUMERIC /GEN_POT */\n\t*no_prog = \"missing required element: /COMMANDS or /INPUT\",\n\t*no_file = \"missing required element: data_file \\n\\\n       (use \\\"SYS$INPUT:\\\" to read data lines from the terminal)\",\n\t*bad_combo = \"invalid combination of qualifiers \\n\\\n       (/INPUT=awk_file and /COMMANDS=\\\"awk program\\\" are mutually exclusive)\",\n\t*run_used = \"\\\"RUN\\\" was used; required command components missing\";\n    int status, argc;\n\n    /* presence of /usage, /version, or /copyright for feedback+quit\n       supersedes absence of required program or data file */\n    if (Present(\"USAGE\")) {\n\tcomplaint = 0;\t\t\t/* clean exit */\n    } else if (Present(\"VERSION\") || Present(\"COPYRIGHT\")) {\n\t/* construct a truncated Unix-style command line to control main() */\n\tv_add_arg(argc=0, CmdName);\t/* save \"GAWK\" as argv[0] */\n#if 0\n\tv_add_arg(++argc, Present(\"VERSION\") ? \"-V\" : \"-C\");\n#else\n\tv_add_arg(++argc, \"-W\");\n\tv_add_arg(++argc, Present(\"VERSION\") ? \"version\" : \"copyright\");\n#endif\n\t/* kludge to suppress 'usage' message from main() */\n\tv_add_arg(++argc, \"--\");\t\t/* no more arguments */\n\tv_add_arg(++argc, \"{}\");\t\t/* dummy program text */\n\tv_add_arg(++argc, \"NL:\");\t\t/* dummy input file */\n\treturn ++argc;\t\t\t/* count argv[0] too */\n    }\n\n    fflush(stdout);\n    switch (complaint) {\n      case USAGE_PROG_RQRD:\n\tfprintf(stderr, \"\\n%%%s-W-%s, %s \\n\", CmdName, \"PROG_RQRD\", no_prog);\n\tstatus = CLI$_VALREQ | STS$M_INHIB_MSG;\n\tbreak;\n      case USAGE_FILE_RQRD:\n\tfprintf(stderr, \"\\n%%%s-W-%s, %s \\n\", CmdName, \"FILE_RQRD\", no_file);\n\tstatus = CLI$_INSFPRM | STS$M_INHIB_MSG;\n\tbreak;\n      case USAGE_BAD_COMBO:\n\tfprintf(stderr, \"\\n%%%s-W-%s, %s \\n\", CmdName, \"BAD_COMBO\", bad_combo);\n\tstatus = CLI$_CONFLICT | STS$M_INHIB_MSG;\n\tbreak;\n      case USAGE_RUN_CMD:\n\tfprintf(stderr, \"\\n%%%s-W-%s, %s \\n\", CmdName, \"RUN_CMD\", run_used);\n\tstatus = CLI$_NOOPTPRS | STS$M_INHIB_MSG;\n\tbreak;\n      default:\n\tstatus = 1;\n\tbreak;\n    }\n    fprintf(stderr, usage_txt, CmdName, CmdName, CmdName, CmdName);\n    fprintf(stderr, options_txt);\n    fflush(stderr);\n\n    errno = EVMSERR;\n    vaxc$errno = status;\n    _exit(status);\n    /* NOTREACHED */\n    return 0;\n}",
      "lines": 80,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int",
        "/* note: usually doesn't return */"
      ]
    }
  },
  "gawk/gawk-4.2.1/vms/vms_misc.c": {
    "vms_strerror": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "char *\nvms_strerror( int errnum )\n{\n    return ( errnum != EVMSERR ? strerror(errnum)\n\t\t\t       : strerror(EVMSERR, vaxc$errno) );\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "char",
        "*\nvms_strerror( int errnum )",
        "*"
      ]
    },
    "vms_strdup": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        63,
        1
      ],
      "content": "char *\nvms_strdup( const char *str )\n{\n    char *result;\n    int len = strlen(str);\n\n    emalloc(result, char *, len+1, \"strdup\");\n    return strcpy(result, str);\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "char",
        "*\nvms_strdup( const char *str )",
        "*"
      ]
    },
    "unlink": {
      "start_point": [
        71,
        0
      ],
      "end_point": [
        80,
        1
      ],
      "content": "int\nunlink( const char *file_spec ) {\n    char tmp[255+1];\t\t\t/*(should use alloca(len+2+1)) */\n    extern int delete(const char *);\n\n    strcpy(tmp, file_spec);\t\t/* copy file name */\n    if (strchr(tmp, ';') == NULL)\n\tstrcat(tmp, \";0\");\t\t/* append version number */\n    return delete(tmp);\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "vms_open": {
      "start_point": [
        95,
        0
      ],
      "end_point": [
        147,
        1
      ],
      "content": "int\nvms_open( const char *name, int mode, ... )\n{\n    int result;\n\n    if (strncmp(name, \"/dev/\", 5) == 0) {\n\t/* (this used to be handled in vms_devopen(), but that is only\n\t   called when opening files for output; we want it for input too) */\n\tif (strcmp(name + 5, \"null\") == 0)\t/* /dev/null -> NL: */\n\t    name = \"NL:\";\n\telse if (strcmp(name + 5, \"tty\") == 0)\t/* /dev/tty -> TT: */\n\t    name = \"TT:\";\n    }\n\n    if (mode == (O_WRONLY|O_CREAT|O_TRUNC)) {\n\t/* explicitly force stream_lf record format to override DECC$SHR's\n\t   defaulting of RFM to earlier file version's when one is present */\n\t/* 3.1.7 fix: letting record attibutes default resulted in DECC$SHR's\n\t   creat() failing with \"invalid record attributes\" when trying to\n\t   make a new version of an existing file which had rfm=vfc,rat=prn\n\t   format, so add explicit \"rat=cr\" to go with rfm=stmlf to force\n\t   the usual \"carriage return carriage control\" setting */\n\tresult = creat(name, 0, \"rfm=stmlf\", \"rat=cr\", \"shr=nil\", \"mbc=32\");\n    } else {\n\tstruct stat stb;\n        int stat_result;\n\tconst char *mbc, *shr = \"shr=get\", *ctx = \"ctx=stm\";\n\n\tstat_result = stat((char *)name, &stb);\n\tif ( stat_result < 0) {\t/* assume DECnet */\n\t    mbc = \"mbc=8\";\n\t} else {    /* ordinary file; allow full sharing iff record format */\n\t    mbc = \"mbc=32\";\n\t    if ((stb.st_fab_rfm & 0x0F) < FAB$C_STM) shr = \"shr=get,put,upd\";\n\t}\n\tresult = open(name, mode, 0, shr, mbc, \"mbf=2\");\n\tif ((stat_result >= 0) && (result < 0) && (errno == ENOENT)) {\n\t    /* ENOENT not possible because stat succeeded */\n\t    errno = EMFILE;\n\t    if (S_ISDIR(stb.st_mode)) {\n\t\terrno = EISDIR; /* Bug seen in VMS 8.3 */\n\t    }\n        }\n    }\n\n    /* This is only approximate; the ACP -> RMS -> VAXCRTL interface\n       discards too much potentially useful status information...  */\n    if (result < 0 && errno == EVMSERR\n\t\t   && (vaxc$errno == RMS$_ACC || vaxc$errno == RMS$_CRE))\n\terrno = EMFILE;\t/* redirect() should close 1 file & try again */\n\n    return result;\n}",
      "lines": 53,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "vms_devopen": {
      "start_point": [
        153,
        0
      ],
      "end_point": [
        170,
        1
      ],
      "content": "int\nvms_devopen( const char *name, int mode )\n{\n    FILE *file = NULL;\n\n    if (strncasecmp(name, \"SYS$\", 4) == 0) {\n\tname += 4;\t\t/* skip \"SYS$\" */\n\tif (strncasecmp(name, \"INPUT\", 5) == 0 && (mode & O_WRONLY) == 0)\n\t    file = stdin,  name += 5;\n\telse if (strncasecmp(name, \"OUTPUT\", 6) == 0 && (mode & O_WRONLY) != 0)\n\t    file = stdout,  name += 6;\n\telse if (strncasecmp(name, \"ERROR\", 5) == 0 && (mode & O_WRONLY) != 0)\n\t    file = stderr,  name += 5;\n\tif (*name == ':')  name++;\t/* treat trailing colon as optional */\n    }\n    /* note: VAXCRTL stdio has extra level of indirection (*file) */\n    return (file && *file && *name == '\\0') ? fileno(file) : -1;\n}",
      "lines": 18,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "vms_gettimeofday": {
      "start_point": [
        183,
        0
      ],
      "end_point": [
        207,
        1
      ],
      "content": "int\nvms_gettimeofday(struct timeval *tv, void *timezone__not_used)\n{\n    /*\n\tEmulate unix's gettimeofday call; timezone argument is ignored.\n    */\n    static const struct dsc$descriptor_s epoch_dsc =\n       { sizeof UNIX_EPOCH - sizeof \"\",\n         DSC$K_DTYPE_T, DSC$K_CLASS_S, UNIX_EPOCH };\n    static long epoch[2] = {0L,0L};\t/* needs one time initialization */\n    const long  thunk = VMS_UNITS_PER_SECOND;\n    long        now[2], quad[2];\n\n    if (!epoch[0])  SYS$BINTIM(&epoch_dsc, epoch);\t/* 1 Jan 0:0:0 1970 */\n    /* get current time, as VMS quadword time */\n    SYS$GETTIM(now);\n    /* convert the quadword time so that it's relative to Unix epoch */\n    LIB$SUBX(now, epoch, quad); /* quad = now - epoch; */\n    /* convert 1e-7 units into seconds and fraction of seconds */\n    LIB$EDIV(&thunk, quad, &tv->tv_sec, &tv->tv_usec);\n    /* convert fraction of seconds into microseconds */\n    tv->tv_usec /= (VMS_UNITS_PER_SECOND / 1000000);\n\n    return 0;           /* success */\n}",
      "lines": 25,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "tzset": {
      "start_point": [
        219,
        0
      ],
      "end_point": [
        222,
        1
      ],
      "content": "void tzset(void)\n{\n    return;\n}",
      "lines": 4,
      "depth": 5,
      "decorators": [
        "void"
      ]
    },
    "getpgrp": {
      "start_point": [
        230,
        0
      ],
      "end_point": [
        233,
        1
      ],
      "content": "int getpgrp(void)\n{\n    return 0;\n}",
      "lines": 4,
      "depth": 5,
      "decorators": [
        "int"
      ]
    },
    "vms_bcopy": {
      "start_point": [
        237,
        0
      ],
      "end_point": [
        240,
        1
      ],
      "content": "void vms_bcopy( const char *src, char *dst, int len )\n{\n    (void) memcpy(dst, src, len);\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "vms_arg_fixup": {
      "start_point": [
        246,
        0
      ],
      "end_point": [
        246,
        57
      ],
      "content": "void vms_arg_fixup( int *argc, char ***argv ) { return; }",
      "lines": 1,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "popen": {
      "start_point": [
        250,
        0
      ],
      "end_point": [
        253,
        1
      ],
      "content": "FILE *popen( const char *command, const char *mode ) {\n    fatal(\" Cannot open pipe `%s' (not implemented)\", command);\n    return NULL;\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "FILE",
        "*popen( const char *command, const char *mode )",
        "*"
      ]
    },
    "pclose": {
      "start_point": [
        254,
        0
      ],
      "end_point": [
        257,
        1
      ],
      "content": "int pclose( FILE *current ) {\n    fatal(\" Cannot close pipe #%d (not implemented)\", fileno(current));\n    return -1;\n}",
      "lines": 4,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "fork": {
      "start_point": [
        258,
        0
      ],
      "end_point": [
        261,
        1
      ],
      "content": "int fork( void ) {\n    fatal(\" Cannot fork process (not implemented)\");\n    return -1;\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "gawk/gawk-4.2.1/vms/vms_popen.c": {
    "popen": [
      {
        "start_point": [
          26,
          0
        ],
        "end_point": [
          32,
          1
        ],
        "content": "FILE *\npopen( const char *command, const char *mode )\n{\n    fatal(\" Cannot open pipe `%s' (not implemented)\", command);\n    /* NOT REACHED */\n    return 0;\n}",
        "lines": 7,
        "depth": 7,
        "decorators": [
          "FILE",
          "*\npopen( const char *command, const char *mode )",
          "*"
        ]
      },
      {
        "start_point": [
          94,
          0
        ],
        "end_point": [
          128,
          1
        ],
        "content": "FILE *\npopen( const char *command, const char *mode )\n{\n    FILE *current;\n    char *name;\n    int   cur;\n    pipemode curmode;\n\n    if (strcmp(mode, \"r\") == 0)\n\tcurmode = reading;\n    else if (strcmp(mode, \"w\") == 0)\n\tcurmode = writing;\n    else\n\treturn NULL;\n\n    /* make a name for the temporary file */\n    if ((name = mktemp(strdup(\"sys$scratch:gawk-pipe_XXXXXX.tmp\"))) == 0)\n\treturn NULL;\n\n    if (curmode == reading) {\n\t/* an input pipe reads a temporary file created by the command */\n\tvms_execute(command, (char *)0, name);\t/* 'command >tempfile' */\n    }\n    if ((current = fopen(name, mode, \"mbc=24\", \"mbf=2\")) == NULL) {\n\tfree(name);\n\treturn NULL;\n    }\n    cur = fileno(current);\n    if (cur >= pipes_lim)  expand_pipes(cur);\n /* assert( cur >= 0 && cur < pipes_lim ); */\n    pipes[cur].name = name;\n    pipes[cur].pmode = curmode;\n    pipes[cur].command = strdup(command);\n    return current;\n}",
        "lines": 35,
        "depth": 13,
        "decorators": [
          "FILE",
          "*\npopen( const char *command, const char *mode )",
          "*"
        ]
      }
    ],
    "pclose": [
      {
        "start_point": [
          34,
          0
        ],
        "end_point": [
          40,
          1
        ],
        "content": "int\npclose( FILE *current )\n{\n    fatal(\" Internal error ('pclose' not implemented)\");\n    /* NOT REACHED */\n    return -1;\n}",
        "lines": 7,
        "depth": 7,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          130,
          0
        ],
        "end_point": [
          150,
          1
        ],
        "content": "int\npclose( FILE *current )\n{\n    int rval, cur = fileno(current);\n\n /* assert( cur >= 0 && cur < pipes_lim ); */\n    if ((cur < 0) || (pipes[cur].pmode == unopened))\n\treturn -1;\t/* should never happen, but does with two-way */\n\n    rval = fclose(current);\t/* close temp file; if reading, we're done */\n    if (pipes[cur].pmode == writing) {\n\t/* an output pipe feeds the temporary file to the other program */\n\trval = vms_execute(pipes[cur].command, pipes[cur].name, (char *)0);\n    }\n    /* clean up */\n    unlink(pipes[cur].name);\t/* get rid of the temporary file */\n    pipes[cur].pmode = unopened;\n    free(pipes[cur].name),  pipes[cur].name = 0;\n    free(pipes[cur].command),  pipes[cur].command = 0;\n    return rval;\n}",
        "lines": 21,
        "depth": 12,
        "decorators": [
          "int"
        ]
      }
    ],
    "fork": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "int\nfork( void )\n{\n    fatal(\" Internal error ('fork' not implemented)\");\n    /* NOT REACHED */\n    return -1;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "vms_execute": {
      "start_point": [
        158,
        0
      ],
      "end_point": [
        193,
        1
      ],
      "content": "int\nvms_execute( const char *command, const char *input, const char *output )\n{\n    struct dsc$descriptor_s cmd, in, out, *in_p, *out_p;\n    U_Long sts, cmpltn_sts;\n\n    cmd.dsc$w_length = strlen(cmd.dsc$a_pointer = (char *)command);\n    cmd.dsc$b_dtype = DSC$K_DTYPE_T;\n    cmd.dsc$b_class = DSC$K_CLASS_S;\n    if (input) {\n\tin.dsc$w_length = strlen(in.dsc$a_pointer = (char *)input);\n\tin_p = &in;\n\tin.dsc$b_dtype = DSC$K_DTYPE_T;\n\tin.dsc$b_class = DSC$K_CLASS_S;\n    } else\n\tin_p = 0;\n    if (output) {\n\tout.dsc$w_length = strlen(out.dsc$a_pointer = (char *)output);\n\tout_p = &out;\n\tout.dsc$b_dtype = DSC$K_DTYPE_T;\n\tout.dsc$b_class = DSC$K_CLASS_S;\n    } else\n\tout_p = 0;\n\n    push_logicals();\t/* guard against user-mode definitions of sys$Xput */\n    sts = LIB$SPAWN(&cmd, in_p, out_p, (U_Long *)0,\n\t\t    (struct dsc$descriptor_s *)0, (U_Long *)0, &cmpltn_sts);\n    pop_logicals();\t/* restore environment */\n\n    if (vmswork(sts) && vmsfail(cmpltn_sts))  sts = cmpltn_sts;\n    if (vmsfail(sts)) {\n\terrno = EVMSERR,  vaxc$errno = sts;\n\treturn -1;\n    } else\n\treturn 0;\n}",
      "lines": 36,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "push_logicals": {
      "start_point": [
        243,
        0
      ],
      "end_point": [
        255,
        1
      ],
      "content": "static void\npush_logicals( void )\t\t/* deassign sys$input and/or sys$output */\n{\n    static int init_done = 0;\n\n    if (!init_done) {\t/* do logical name lookups one-time only */\n\tinput_definition = save_translation(&sys_input);\n\toutput_definition = save_translation(&sys_output);\n\tinit_done = 1;\n    }\n    if (input_definition) DelTrans(&sys_input);\t\t/* kill sys$input */\n    if (output_definition) DelTrans(&sys_output);\t/* and sys$output */\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "pop_logicals": {
      "start_point": [
        257,
        0
      ],
      "end_point": [
        262,
        1
      ],
      "content": "static void\npop_logicals( void )\t\t/* redefine sys$input and/or sys$output */\n{\n    if (input_definition) restore_translation(&sys_input, input_definition);\n    if (output_definition) restore_translation(&sys_output, output_definition);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "save_translation": {
      "start_point": [
        264,
        0
      ],
      "end_point": [
        325,
        1
      ],
      "content": "static Itm *\nsave_translation( const struct dsc$descriptor_s *logname )\n{\n    Itm trans[4], *itmlst;\n    long trans_attr, max_trans_indx;\t/* 0-based translation index count */\n    unsigned char trans_acmode;\t\t/* translation's access mode */\n    unsigned itmlst_size;\n    register int i, j;\n\n    itmlst = 0;\n    /* Want translation index count for non-confined, user-mode definition;\n\tunfortunately, $trnlnm does not provide that much control.  Try to\n\tfetch several values of interest, then decide based on the result.\n     */\n    SetItmS(trans[0], LNM$_MAX_INDEX, &max_trans_indx),\t max_trans_indx = -1;\n    SetItmS(trans[1], LNM$_ACMODE, &trans_acmode),\t trans_acmode = 0;\n    SetItmS(trans[2], LNM$_ATTRIBUTES, &trans_attr),\t trans_attr = 0;\n    EndItm0(trans[3]);\n    if (vmswork(GetTrans(logname, trans)) && max_trans_indx >= 0\n      && trans_acmode == PSL$C_USER && !(trans_attr & LNM$M_CONFINE)) {\n\t/* Now know that definition of interest exists;\n\t    allocate and initialize an item list and associated buffers;\n\t    use three entries for each translation.\n\t */\n\titmlst_size = (3 * (max_trans_indx + 1) + 1) * sizeof(Itm);\n\temalloc(itmlst, Itm *, itmlst_size, \"save_translation\");\n\tfor (i = 0; i <= max_trans_indx; i++) {\n\t    struct def { U_Long indx, attr; U_Short len;\n\t\t\t char str[LNM$C_NAMLENGTH], eos; } *wrk;\n\t    emalloc(wrk, struct def *, sizeof (struct def), \"save_translation\");\n\t    wrk->indx = (U_Long)i;  /* this one's an input value for $trnlnm */\n\t    SetItmS(itmlst[3*i+0], LNM$_INDEX, &wrk->indx);\n\t    SetItmS(itmlst[3*i+1], LNM$_ATTRIBUTES, &wrk->attr),  wrk->attr = 0;\n\t    SetItmA(itmlst[3*i+2], LNM$_STRING, &wrk->str, &wrk->len),  wrk->len = 0;\n\t}\n\tEndItm0(itmlst[3*i]);   /* assert( i == max_trans_indx+1 ); */\n\t/* Time to perform full logical name translation,\n\t    then update item list for subsequent restoration.\n\t    If there are any holes [don't know whether that's possible]\n\t    collapse them out of the list; don't want them at restore time.\n\t */\n\tif (vmswork(GetTrans(logname, itmlst))) {\n\t    for (i = 0, j = -1; i <= max_trans_indx; i++) {\n\t\tU_Long *attr_p;\n\t\tattr_p = itmlst[3*i+1].buffer;\t/* copy (void *) to true type */\n\t\tif (*attr_p & LNM$M_EXISTS) {\n\t\t    *attr_p &= ~LNM$M_EXISTS;\t/* must clear this bit */\n\t\t    if (++j < i)  itmlst[3*j+0] = itmlst[3*i+0],\n\t\t\t\t  itmlst[3*j+1] = itmlst[3*i+1],\n\t\t\t\t  itmlst[3*j+2] = itmlst[3*i+2];\n\t\t    if (itmlst[3*j+2].retlen) { /* fixup buffer length */\n\t\t\titmlst[3*j+2].len = *itmlst[3*j+2].retlen;\n\t\t\titmlst[3*j+2].retlen = (U_Short *)0;\n\t\t    }\n\t\t}\n\t    }\n\t    if (++j < i)  EndItm0(itmlst[3*j]);\n\t} else\t    /* should never happen; tolerate potential memory leak */\n\t    free(itmlst),  itmlst = 0;  /*('wrk' buffer(s) will become lost)*/\n    }\n    return itmlst;\n}",
      "lines": 62,
      "depth": 20,
      "decorators": [
        "static",
        "static",
        "Itm",
        "*\nsave_translation( const struct dsc$descriptor_s *logname )",
        "*"
      ]
    },
    "restore_translation": {
      "start_point": [
        327,
        0
      ],
      "end_point": [
        354,
        1
      ],
      "content": "static void\nrestore_translation( const struct dsc$descriptor_s *logname,\n                     const Itm *itemlist )\n{\n    struct dsc$descriptor_s trans_val;\n    U_Long *attr_p;\n# define LOG_PROCESS_TABLE 2\t\t/* <obsolete> */\n# define LOG_USERMODE PSL$C_USER\n\n /* assert( itemlist[1].code == LNM$_ATTRIBUTES ); */\n    attr_p = itemlist[1].buffer;\t/* copy (void *) to (U_Long *) */\n    if (*attr_p & LNM$M_CRELOG) {\t/* check original creation method */\n\t/* $crelog values can have only one translation;\n\t    so it'll be the first string entry in the itemlist.\n\t */\n     /* assert( itemlist[2].code == LNM$_STRING ); */\n\ttrans_val.dsc$a_pointer = itemlist[2].buffer;\n\ttrans_val.dsc$w_length = itemlist[2].len;\n\ttrans_val.dsc$b_dtype = DSC$K_DTYPE_T;\n\ttrans_val.dsc$b_class = DSC$K_CLASS_S;\n\t(void) SYS$CRELOG(LOG_PROCESS_TABLE, logname, &trans_val, LOG_USERMODE);\n    } else {\n\t/* $crelnm definition; itemlist could specify multiple translations,\n\t    but has already been setup properly for use as-is.\n\t */\n\t(void) SetTrans(logname, itemlist);\n    }\n}",
      "lines": 28,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  }
}