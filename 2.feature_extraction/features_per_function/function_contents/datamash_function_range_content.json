{
  "datamash/datamash-1.3/lib/alloca.in.h": {},
  "datamash/datamash-1.3/lib/anytostr.c": {
    "__attribute_warn_unused_result__": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "char * __attribute_warn_unused_result__\nanytostr (inttype i, char *buf)\n{\n  char *p = buf + INT_STRLEN_BOUND (inttype);\n  *p = 0;\n\n  if (i < 0)\n    {\n      do\n        *--p = '0' - i % 10;\n      while ((i /= 10) != 0);\n\n      *--p = '-';\n    }\n  else\n    {\n      do\n        *--p = '0' + i % 10;\n      while ((i /= 10) != 0);\n    }\n\n  return p;\n}",
      "lines": 23,
      "depth": 10,
      "decorators": [
        "char",
        "* __attribute_warn_unused_result__\nanytostr (inttype i, char *buf)",
        "*"
      ]
    }
  },
  "datamash/datamash-1.3/lib/arg-nonnull.h": {},
  "datamash/datamash-1.3/lib/assure.h": {},
  "datamash/datamash-1.3/lib/base64.c": {
    "to_uchar": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "static unsigned char\nto_uchar (char ch)\n{\n  return ch;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "unsigned char",
        "unsigned",
        "char"
      ]
    },
    "base64_encode_fast": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        80,
        1
      ],
      "content": "static void\nbase64_encode_fast (const char *restrict in, size_t inlen, char *restrict out)\n{\n  while (inlen)\n    {\n      *out++ = b64c[to_uchar (in[0]) >> 2];\n      *out++ = b64c[((to_uchar (in[0]) << 4) + (to_uchar (in[1]) >> 4)) & 0x3f];\n      *out++ = b64c[((to_uchar (in[1]) << 2) + (to_uchar (in[2]) >> 6)) & 0x3f];\n      *out++ = b64c[to_uchar (in[2]) & 0x3f];\n\n      inlen -= 3;\n      in += 3;\n    }\n}",
      "lines": 14,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "base64_encode": {
      "start_point": [
        86,
        0
      ],
      "end_point": [
        132,
        1
      ],
      "content": "void\nbase64_encode (const char *restrict in, size_t inlen,\n               char *restrict out, size_t outlen)\n{\n  /* Note this outlen constraint can be enforced at compile time.\n     I.E. that the output buffer is exactly large enough to hold\n     the encoded inlen bytes.  The inlen constraints (of corresponding\n     to outlen, and being a multiple of 3) can change at runtime\n     at the end of input.  However the common case when reading\n     large inputs is to have both constraints satisfied, so we depend\n     on both in base_encode_fast().  */\n  if (outlen % 4 == 0 && inlen == outlen / 4 * 3)\n    {\n      base64_encode_fast (in, inlen, out);\n      return;\n    }\n\n  while (inlen && outlen)\n    {\n      *out++ = b64c[to_uchar (in[0]) >> 2];\n      if (!--outlen)\n        break;\n      *out++ = b64c[((to_uchar (in[0]) << 4)\n                       + (--inlen ? to_uchar (in[1]) >> 4 : 0))\n                      & 0x3f];\n      if (!--outlen)\n        break;\n      *out++ =\n        (inlen\n         ? b64c[((to_uchar (in[1]) << 2)\n                   + (--inlen ? to_uchar (in[2]) >> 6 : 0))\n                  & 0x3f]\n         : '=');\n      if (!--outlen)\n        break;\n      *out++ = inlen ? b64c[to_uchar (in[2]) & 0x3f] : '=';\n      if (!--outlen)\n        break;\n      if (inlen)\n        inlen--;\n      if (inlen)\n        in += 3;\n    }\n\n  if (outlen)\n    *out = '\\0';\n}",
      "lines": 47,
      "depth": 19,
      "decorators": [
        "void"
      ]
    },
    "base64_encode_alloc": {
      "start_point": [
        143,
        0
      ],
      "end_point": [
        173,
        1
      ],
      "content": "size_t\nbase64_encode_alloc (const char *in, size_t inlen, char **out)\n{\n  size_t outlen = 1 + BASE64_LENGTH (inlen);\n\n  /* Check for overflow in outlen computation.\n   *\n   * If there is no overflow, outlen >= inlen.\n   *\n   * If the operation (inlen + 2) overflows then it yields at most +1, so\n   * outlen is 0.\n   *\n   * If the multiplication overflows, we lose at least half of the\n   * correct value, so the result is < ((inlen + 2) / 3) * 2, which is\n   * less than (inlen + 2) * 0.66667, which is less than inlen as soon as\n   * (inlen > 4).\n   */\n  if (inlen > outlen)\n    {\n      *out = NULL;\n      return 0;\n    }\n\n  *out = malloc (outlen);\n  if (!*out)\n    return outlen;\n\n  base64_encode (in, inlen, *out, outlen);\n\n  return outlen - 1;\n}",
      "lines": 31,
      "depth": 8,
      "decorators": [
        "size_t"
      ]
    },
    "isbase64": {
      "start_point": [
        327,
        0
      ],
      "end_point": [
        331,
        1
      ],
      "content": "bool\nisbase64 (char ch)\n{\n  return uchar_in_range (to_uchar (ch)) && 0 <= b64[to_uchar (ch)];\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    },
    "base64_decode_ctx_init": {
      "start_point": [
        334,
        0
      ],
      "end_point": [
        338,
        1
      ],
      "content": "void\nbase64_decode_ctx_init (struct base64_decode_context *ctx)\n{\n  ctx->i = 0;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "get_4": {
      "start_point": [
        347,
        0
      ],
      "end_point": [
        385,
        1
      ],
      "content": "static char *\nget_4 (struct base64_decode_context *ctx,\n       char const *restrict *in, char const *restrict in_end,\n       size_t *n_non_newline)\n{\n  if (ctx->i == 4)\n    ctx->i = 0;\n\n  if (ctx->i == 0)\n    {\n      char const *t = *in;\n      if (4 <= in_end - *in && memchr (t, '\\n', 4) == NULL)\n        {\n          /* This is the common case: no newline.  */\n          *in += 4;\n          *n_non_newline = 4;\n          return (char *) t;\n        }\n    }\n\n  {\n    /* Copy non-newline bytes into BUF.  */\n    char const *p = *in;\n    while (p < in_end)\n      {\n        char c = *p++;\n        if (c != '\\n')\n          {\n            ctx->buf[ctx->i++] = c;\n            if (ctx->i == 4)\n              break;\n          }\n      }\n\n    *in = p;\n    *n_non_newline = ctx->i;\n    return ctx->buf;\n  }\n}",
      "lines": 39,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nget_4 (struct base64_decode_context *ctx,\n       char const *restrict *in, char const *restrict in_end,\n       size_t *n_non_newline)",
        "*"
      ]
    },
    "decode_4": {
      "start_point": [
        401,
        0
      ],
      "end_point": [
        466,
        1
      ],
      "content": "static bool\ndecode_4 (char const *restrict in, size_t inlen,\n          char *restrict *outp, size_t *outleft)\n{\n  char *out = *outp;\n  if (inlen < 2)\n    return false;\n\n  if (!isbase64 (in[0]) || !isbase64 (in[1]))\n    return false;\n\n  if (*outleft)\n    {\n      *out++ = ((b64[to_uchar (in[0])] << 2)\n                | (b64[to_uchar (in[1])] >> 4));\n      --*outleft;\n    }\n\n  if (inlen == 2)\n    return_false;\n\n  if (in[2] == '=')\n    {\n      if (inlen != 4)\n        return_false;\n\n      if (in[3] != '=')\n        return_false;\n    }\n  else\n    {\n      if (!isbase64 (in[2]))\n        return_false;\n\n      if (*outleft)\n        {\n          *out++ = (((b64[to_uchar (in[1])] << 4) & 0xf0)\n                    | (b64[to_uchar (in[2])] >> 2));\n          --*outleft;\n        }\n\n      if (inlen == 3)\n        return_false;\n\n      if (in[3] == '=')\n        {\n          if (inlen != 4)\n            return_false;\n        }\n      else\n        {\n          if (!isbase64 (in[3]))\n            return_false;\n\n          if (*outleft)\n            {\n              *out++ = (((b64[to_uchar (in[2])] << 6) & 0xc0)\n                        | b64[to_uchar (in[3])]);\n              --*outleft;\n            }\n        }\n    }\n\n  *outp = out;\n  return true;\n}",
      "lines": 66,
      "depth": 21,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "base64_decode_ctx": {
      "start_point": [
        486,
        0
      ],
      "end_point": [
        564,
        1
      ],
      "content": "bool\nbase64_decode_ctx (struct base64_decode_context *ctx,\n                   const char *restrict in, size_t inlen,\n                   char *restrict out, size_t *outlen)\n{\n  size_t outleft = *outlen;\n  bool ignore_newlines = ctx != NULL;\n  bool flush_ctx = false;\n  unsigned int ctx_i = 0;\n\n  if (ignore_newlines)\n    {\n      ctx_i = ctx->i;\n      flush_ctx = inlen == 0;\n    }\n\n\n  while (true)\n    {\n      size_t outleft_save = outleft;\n      if (ctx_i == 0 && !flush_ctx)\n        {\n          while (true)\n            {\n              /* Save a copy of outleft, in case we need to re-parse this\n                 block of four bytes.  */\n              outleft_save = outleft;\n              if (!decode_4 (in, inlen, &out, &outleft))\n                break;\n\n              in += 4;\n              inlen -= 4;\n            }\n        }\n\n      if (inlen == 0 && !flush_ctx)\n        break;\n\n      /* Handle the common case of 72-byte wrapped lines.\n         This also handles any other multiple-of-4-byte wrapping.  */\n      if (inlen && *in == '\\n' && ignore_newlines)\n        {\n          ++in;\n          --inlen;\n          continue;\n        }\n\n      /* Restore OUT and OUTLEFT.  */\n      out -= outleft_save - outleft;\n      outleft = outleft_save;\n\n      {\n        char const *in_end = in + inlen;\n        char const *non_nl;\n\n        if (ignore_newlines)\n          non_nl = get_4 (ctx, &in, in_end, &inlen);\n        else\n          non_nl = in;  /* Might have nl in this case. */\n\n        /* If the input is empty or consists solely of newlines (0 non-newlines),\n           then we're done.  Likewise if there are fewer than 4 bytes when not\n           flushing context and not treating newlines as garbage.  */\n        if (inlen == 0 || (inlen < 4 && !flush_ctx && ignore_newlines))\n          {\n            inlen = 0;\n            break;\n          }\n        if (!decode_4 (non_nl, inlen, &out, &outleft))\n          break;\n\n        inlen = in_end - in;\n      }\n    }\n\n  *outlen -= outleft;\n\n  return inlen == 0;\n}",
      "lines": 79,
      "depth": 15,
      "decorators": [
        "bool"
      ]
    },
    "base64_decode_alloc_ctx": {
      "start_point": [
        577,
        0
      ],
      "end_point": [
        604,
        1
      ],
      "content": "bool\nbase64_decode_alloc_ctx (struct base64_decode_context *ctx,\n                         const char *in, size_t inlen, char **out,\n                         size_t *outlen)\n{\n  /* This may allocate a few bytes too many, depending on input,\n     but it's not worth the extra CPU time to compute the exact size.\n     The exact size is 3 * (inlen + (ctx ? ctx->i : 0)) / 4, minus 1 if the\n     input ends with \"=\" and minus another 1 if the input ends with \"==\".\n     Dividing before multiplying avoids the possibility of overflow.  */\n  size_t needlen = 3 * (inlen / 4) + 3;\n\n  *out = malloc (needlen);\n  if (!*out)\n    return true;\n\n  if (!base64_decode_ctx (ctx, in, inlen, *out, &needlen))\n    {\n      free (*out);\n      *out = NULL;\n      return false;\n    }\n\n  if (outlen)\n    *outlen = needlen;\n\n  return true;\n}",
      "lines": 28,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    }
  },
  "datamash/datamash-1.3/lib/base64.h": {},
  "datamash/datamash-1.3/lib/basename-lgpl.c": {
    "last_component": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "char *\nlast_component (char const *name)\n{\n  char const *base = name + FILE_SYSTEM_PREFIX_LEN (name);\n  char const *p;\n  bool saw_slash = false;\n\n  while (ISSLASH (*base))\n    base++;\n\n  for (p = base; *p; p++)\n    {\n      if (ISSLASH (*p))\n        saw_slash = true;\n      else if (saw_slash)\n        {\n          base = p;\n          saw_slash = false;\n        }\n    }\n\n  return (char *) base;\n}",
      "lines": 23,
      "depth": 10,
      "decorators": [
        "char",
        "*\nlast_component (char const *name)",
        "*"
      ]
    },
    "base_len": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "size_t\nbase_len (char const *name)\n{\n  size_t len;\n  size_t prefix_len = FILE_SYSTEM_PREFIX_LEN (name);\n\n  for (len = strlen (name);  1 < len && ISSLASH (name[len - 1]);  len--)\n    continue;\n\n  if (DOUBLE_SLASH_IS_DISTINCT_ROOT && len == 1\n      && ISSLASH (name[0]) && ISSLASH (name[1]) && ! name[2])\n    return 2;\n\n  if (FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE && prefix_len\n      && len == prefix_len && ISSLASH (name[prefix_len]))\n    return prefix_len + 1;\n\n  return len;\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "size_t"
      ]
    }
  },
  "datamash/datamash-1.3/lib/basename.c": {
    "base_name": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "char *\nbase_name (char const *name)\n{\n  char const *base = last_component (name);\n  size_t length;\n\n  /* If there is no last component, then name is a file system root or the\n     empty string.  */\n  if (! *base)\n    return xstrndup (name, base_len (name));\n\n  /* Collapse a sequence of trailing slashes into one.  */\n  length = base_len (base);\n  if (ISSLASH (base[length]))\n    length++;\n\n  /* On systems with drive letters, \"a/b:c\" must return \"./b:c\" rather\n     than \"b:c\" to avoid confusion with a drive letter.  On systems\n     with pure POSIX semantics, this is not an issue.  */\n  if (FILE_SYSTEM_PREFIX_LEN (base))\n    {\n      char *p = xmalloc (length + 3);\n      p[0] = '.';\n      p[1] = '/';\n      memcpy (p + 2, base, length);\n      p[length + 2] = '\\0';\n      return p;\n    }\n\n  /* Finally, copy the basename.  */\n  return xstrndup (base, length);\n}",
      "lines": 32,
      "depth": 10,
      "decorators": [
        "char",
        "*\nbase_name (char const *name)",
        "*"
      ]
    }
  },
  "datamash/datamash-1.3/lib/bitrotate.c": {},
  "datamash/datamash-1.3/lib/bitrotate.h": {
    "uint64_t": [
      {
        "start_point": [
          37,
          0
        ],
        "end_point": [
          41,
          1
        ],
        "content": "BITROTATE_INLINE uint64_t\nrotl64 (uint64_t x, int n)\n{\n  return ((x << n) | (x >> (64 - n))) & UINT64_MAX;\n}",
        "lines": 5,
        "depth": 11,
        "decorators": [
          "BITROTATE_INLINE"
        ]
      },
      {
        "start_point": [
          46,
          0
        ],
        "end_point": [
          50,
          1
        ],
        "content": "BITROTATE_INLINE uint64_t\nrotr64 (uint64_t x, int n)\n{\n  return ((x >> n) | (x << (64 - n))) & UINT64_MAX;\n}",
        "lines": 5,
        "depth": 11,
        "decorators": [
          "BITROTATE_INLINE"
        ]
      }
    ],
    "uint32_t": [
      {
        "start_point": [
          56,
          0
        ],
        "end_point": [
          60,
          1
        ],
        "content": "BITROTATE_INLINE uint32_t\nrotl32 (uint32_t x, int n)\n{\n  return ((x << n) | (x >> (32 - n))) & UINT32_MAX;\n}",
        "lines": 5,
        "depth": 11,
        "decorators": [
          "BITROTATE_INLINE"
        ]
      },
      {
        "start_point": [
          65,
          0
        ],
        "end_point": [
          69,
          1
        ],
        "content": "BITROTATE_INLINE uint32_t\nrotr32 (uint32_t x, int n)\n{\n  return ((x >> n) | (x << (32 - n))) & UINT32_MAX;\n}",
        "lines": 5,
        "depth": 11,
        "decorators": [
          "BITROTATE_INLINE"
        ]
      }
    ],
    "rotl_sz": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "BITROTATE_INLINE size_t\nrotl_sz (size_t x, int n)\n{\n  return ((x << n) | (x >> ((CHAR_BIT * sizeof x) - n))) & SIZE_MAX;\n}",
      "lines": 5,
      "depth": 14,
      "decorators": [
        "BITROTATE_INLINE",
        "size_t",
        "size_t"
      ]
    },
    "rotr_sz": {
      "start_point": [
        83,
        0
      ],
      "end_point": [
        87,
        1
      ],
      "content": "BITROTATE_INLINE size_t\nrotr_sz (size_t x, int n)\n{\n  return ((x >> n) | (x << ((CHAR_BIT * sizeof x) - n))) & SIZE_MAX;\n}",
      "lines": 5,
      "depth": 14,
      "decorators": [
        "BITROTATE_INLINE",
        "size_t",
        "size_t"
      ]
    },
    "uint16_t": [
      {
        "start_point": [
          94,
          0
        ],
        "end_point": [
          98,
          1
        ],
        "content": "BITROTATE_INLINE uint16_t\nrotl16 (uint16_t x, int n)\n{\n  return ((x << n) | (x >> (16 - n))) & UINT16_MAX;\n}",
        "lines": 5,
        "depth": 11,
        "decorators": [
          "BITROTATE_INLINE"
        ]
      },
      {
        "start_point": [
          105,
          0
        ],
        "end_point": [
          109,
          1
        ],
        "content": "BITROTATE_INLINE uint16_t\nrotr16 (uint16_t x, int n)\n{\n  return ((x >> n) | (x << (16 - n))) & UINT16_MAX;\n}",
        "lines": 5,
        "depth": 11,
        "decorators": [
          "BITROTATE_INLINE"
        ]
      }
    ],
    "uint8_t": [
      {
        "start_point": [
          116,
          0
        ],
        "end_point": [
          120,
          1
        ],
        "content": "BITROTATE_INLINE uint8_t\nrotl8 (uint8_t x, int n)\n{\n  return ((x << n) | (x >> (8 - n))) & UINT8_MAX;\n}",
        "lines": 5,
        "depth": 11,
        "decorators": [
          "BITROTATE_INLINE"
        ]
      },
      {
        "start_point": [
          127,
          0
        ],
        "end_point": [
          131,
          1
        ],
        "content": "BITROTATE_INLINE uint8_t\nrotr8 (uint8_t x, int n)\n{\n  return ((x >> n) | (x << (8 - n))) & UINT8_MAX;\n}",
        "lines": 5,
        "depth": 11,
        "decorators": [
          "BITROTATE_INLINE"
        ]
      }
    ]
  },
  "datamash/datamash-1.3/lib/c++defs.h": {},
  "datamash/datamash-1.3/lib/c-ctype.c": {},
  "datamash/datamash-1.3/lib/c-ctype.h": {
    "c_isalnum": {
      "start_point": [
        167,
        0
      ],
      "end_point": [
        179,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_isalnum (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_DIGIT:\n    _C_CTYPE_LOWER:\n    _C_CTYPE_UPPER:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_isalpha": {
      "start_point": [
        181,
        0
      ],
      "end_point": [
        192,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_isalpha (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_LOWER:\n    _C_CTYPE_UPPER:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_isascii": {
      "start_point": [
        196,
        0
      ],
      "end_point": [
        211,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_isascii (int c)\n{\n  switch (c)\n    {\n    case ' ':\n    _C_CTYPE_CNTRL:\n    _C_CTYPE_DIGIT:\n    _C_CTYPE_LOWER:\n    _C_CTYPE_PUNCT:\n    _C_CTYPE_UPPER:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 16,
      "depth": 12,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_isblank": {
      "start_point": [
        213,
        0
      ],
      "end_point": [
        217,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_isblank (int c)\n{\n  return c == ' ' || c == '\\t';\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_iscntrl": {
      "start_point": [
        219,
        0
      ],
      "end_point": [
        229,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_iscntrl (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_CNTRL:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_isdigit": {
      "start_point": [
        231,
        0
      ],
      "end_point": [
        241,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_isdigit (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_DIGIT:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_isgraph": {
      "start_point": [
        243,
        0
      ],
      "end_point": [
        256,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_isgraph (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_DIGIT:\n    _C_CTYPE_LOWER:\n    _C_CTYPE_PUNCT:\n    _C_CTYPE_UPPER:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_islower": {
      "start_point": [
        258,
        0
      ],
      "end_point": [
        268,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_islower (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_LOWER:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_isprint": {
      "start_point": [
        270,
        0
      ],
      "end_point": [
        284,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_isprint (int c)\n{\n  switch (c)\n    {\n    case ' ':\n    _C_CTYPE_DIGIT:\n    _C_CTYPE_LOWER:\n    _C_CTYPE_PUNCT:\n    _C_CTYPE_UPPER:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_ispunct": {
      "start_point": [
        286,
        0
      ],
      "end_point": [
        296,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_ispunct (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_PUNCT:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_isspace": {
      "start_point": [
        298,
        0
      ],
      "end_point": [
        308,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_isspace (int c)\n{\n  switch (c)\n    {\n    case ' ': case '\\t': case '\\n': case '\\v': case '\\f': case '\\r':\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_isupper": {
      "start_point": [
        310,
        0
      ],
      "end_point": [
        320,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_isupper (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_UPPER:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_isxdigit": {
      "start_point": [
        322,
        0
      ],
      "end_point": [
        333,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_isxdigit (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_DIGIT:\n    _C_CTYPE_A_THRU_F:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_tolower": {
      "start_point": [
        335,
        0
      ],
      "end_point": [
        345,
        1
      ],
      "content": "C_CTYPE_INLINE int\nc_tolower (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_UPPER:\n      return c - 'A' + 'a';\n    default:\n      return c;\n    }\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "C_CTYPE_INLINE",
        "int",
        "int"
      ]
    },
    "c_toupper": {
      "start_point": [
        347,
        0
      ],
      "end_point": [
        357,
        1
      ],
      "content": "C_CTYPE_INLINE int\nc_toupper (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_LOWER:\n      return c - 'a' + 'A';\n    default:\n      return c;\n    }\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "C_CTYPE_INLINE",
        "int",
        "int"
      ]
    }
  },
  "datamash/datamash-1.3/lib/c-strcase.h": {},
  "datamash/datamash-1.3/lib/c-strcasecmp.c": {
    "c_strcasecmp": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "int\nc_strcasecmp (const char *s1, const char *s2)\n{\n  register const unsigned char *p1 = (const unsigned char *) s1;\n  register const unsigned char *p2 = (const unsigned char *) s2;\n  unsigned char c1, c2;\n\n  if (p1 == p2)\n    return 0;\n\n  do\n    {\n      c1 = c_tolower (*p1);\n      c2 = c_tolower (*p2);\n\n      if (c1 == '\\0')\n        break;\n\n      ++p1;\n      ++p2;\n    }\n  while (c1 == c2);\n\n  if (UCHAR_MAX <= INT_MAX)\n    return c1 - c2;\n  else\n    /* On machines where 'char' and 'int' are types of the same size, the\n       difference of two 'unsigned char' values - including the sign bit -\n       doesn't fit in an 'int'.  */\n    return (c1 > c2 ? 1 : c1 < c2 ? -1 : 0);\n}",
      "lines": 31,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "datamash/datamash-1.3/lib/c-strcaseeq.h": {
    "strcaseeq9": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "static inline int\nstrcaseeq9 (const char *s1, const char *s2)\n{\n  return c_strcasecmp (s1 + 9, s2 + 9) == 0;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq8": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "static inline int\nstrcaseeq8 (const char *s1, const char *s2, char s28)\n{\n  if (CASEEQ (s1[8], s28))\n    {\n      if (s28 == 0)\n        return 1;\n      else\n        return strcaseeq9 (s1, s2);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq7": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "static inline int\nstrcaseeq7 (const char *s1, const char *s2, char s27, char s28)\n{\n  if (CASEEQ (s1[7], s27))\n    {\n      if (s27 == 0)\n        return 1;\n      else\n        return strcaseeq8 (s1, s2, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq6": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "static inline int\nstrcaseeq6 (const char *s1, const char *s2, char s26, char s27, char s28)\n{\n  if (CASEEQ (s1[6], s26))\n    {\n      if (s26 == 0)\n        return 1;\n      else\n        return strcaseeq7 (s1, s2, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq5": {
      "start_point": [
        88,
        0
      ],
      "end_point": [
        100,
        1
      ],
      "content": "static inline int\nstrcaseeq5 (const char *s1, const char *s2, char s25, char s26, char s27, char s28)\n{\n  if (CASEEQ (s1[5], s25))\n    {\n      if (s25 == 0)\n        return 1;\n      else\n        return strcaseeq6 (s1, s2, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq4": {
      "start_point": [
        102,
        0
      ],
      "end_point": [
        114,
        1
      ],
      "content": "static inline int\nstrcaseeq4 (const char *s1, const char *s2, char s24, char s25, char s26, char s27, char s28)\n{\n  if (CASEEQ (s1[4], s24))\n    {\n      if (s24 == 0)\n        return 1;\n      else\n        return strcaseeq5 (s1, s2, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq3": {
      "start_point": [
        116,
        0
      ],
      "end_point": [
        128,
        1
      ],
      "content": "static inline int\nstrcaseeq3 (const char *s1, const char *s2, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (CASEEQ (s1[3], s23))\n    {\n      if (s23 == 0)\n        return 1;\n      else\n        return strcaseeq4 (s1, s2, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq2": {
      "start_point": [
        130,
        0
      ],
      "end_point": [
        142,
        1
      ],
      "content": "static inline int\nstrcaseeq2 (const char *s1, const char *s2, char s22, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (CASEEQ (s1[2], s22))\n    {\n      if (s22 == 0)\n        return 1;\n      else\n        return strcaseeq3 (s1, s2, s23, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq1": {
      "start_point": [
        144,
        0
      ],
      "end_point": [
        156,
        1
      ],
      "content": "static inline int\nstrcaseeq1 (const char *s1, const char *s2, char s21, char s22, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (CASEEQ (s1[1], s21))\n    {\n      if (s21 == 0)\n        return 1;\n      else\n        return strcaseeq2 (s1, s2, s22, s23, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq0": {
      "start_point": [
        158,
        0
      ],
      "end_point": [
        170,
        1
      ],
      "content": "static inline int\nstrcaseeq0 (const char *s1, const char *s2, char s20, char s21, char s22, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (CASEEQ (s1[0], s20))\n    {\n      if (s20 == 0)\n        return 1;\n      else\n        return strcaseeq1 (s1, s2, s21, s22, s23, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    }
  },
  "datamash/datamash-1.3/lib/c-strncasecmp.c": {
    "c_strncasecmp": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "int\nc_strncasecmp (const char *s1, const char *s2, size_t n)\n{\n  register const unsigned char *p1 = (const unsigned char *) s1;\n  register const unsigned char *p2 = (const unsigned char *) s2;\n  unsigned char c1, c2;\n\n  if (p1 == p2 || n == 0)\n    return 0;\n\n  do\n    {\n      c1 = c_tolower (*p1);\n      c2 = c_tolower (*p2);\n\n      if (--n == 0 || c1 == '\\0')\n        break;\n\n      ++p1;\n      ++p2;\n    }\n  while (c1 == c2);\n\n  if (UCHAR_MAX <= INT_MAX)\n    return c1 - c2;\n  else\n    /* On machines where 'char' and 'int' are types of the same size, the\n       difference of two 'unsigned char' values - including the sign bit -\n       doesn't fit in an 'int'.  */\n    return (c1 > c2 ? 1 : c1 < c2 ? -1 : 0);\n}",
      "lines": 31,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "datamash/datamash-1.3/lib/calloc.c": {
    "rpl_calloc": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "void *\nrpl_calloc (size_t n, size_t s)\n{\n  void *result;\n\n#if NEED_CALLOC_GNU\n  if (n == 0 || s == 0)\n    {\n      n = 1;\n      s = 1;\n    }\n  else\n    {\n      /* Defend against buggy calloc implementations that mishandle\n         size_t overflow.  */\n      size_t bytes = n * s;\n      if (bytes / s != n)\n        {\n          errno = ENOMEM;\n          return NULL;\n        }\n    }\n#endif\n\n  result = calloc (n, s);\n\n#if !HAVE_CALLOC_POSIX\n  if (result == NULL)\n    errno = ENOMEM;\n#endif\n\n  return result;\n}",
      "lines": 33,
      "depth": 10,
      "decorators": [
        "void",
        "*\nrpl_calloc (size_t n, size_t s)",
        "*"
      ]
    }
  },
  "datamash/datamash-1.3/lib/ceil.c": {
    "FUNC": {
      "start_point": [
        73,
        0
      ],
      "end_point": [
        116,
        1
      ],
      "content": "DOUBLE\nFUNC (DOUBLE x)\n{\n  /* The use of 'volatile' guarantees that excess precision bits are dropped\n     at each addition step and before the following comparison at the caller's\n     site.  It is necessary on x86 systems where double-floats are not IEEE\n     compliant by default, to avoid that the results become platform and compiler\n     option dependent.  'volatile' is a portable alternative to gcc's\n     -ffloat-store option.  */\n  volatile DOUBLE y = x;\n  volatile DOUBLE z = y;\n\n  if (z > L_(0.0))\n    {\n      /* Avoid rounding errors for values near 2^k, where k >= MANT_DIG-1.  */\n      if (z < TWO_MANT_DIG)\n        {\n          /* Round to the next integer (nearest or up or down, doesn't matter).  */\n          z += TWO_MANT_DIG;\n          z -= TWO_MANT_DIG;\n          /* Enforce rounding up.  */\n          if (z < y)\n            z += L_(1.0);\n        }\n    }\n  else if (z < L_(0.0))\n    {\n      /* For -1 < x < 0, return -0.0 regardless of the current rounding\n         mode.  */\n      if (z > L_(-1.0))\n        z = MINUS_ZERO;\n      /* Avoid rounding errors for values near -2^k, where k >= MANT_DIG-1.  */\n      else if (z > - TWO_MANT_DIG)\n        {\n          /* Round to the next integer (nearest or up or down, doesn't matter).  */\n          z -= TWO_MANT_DIG;\n          z += TWO_MANT_DIG;\n          /* Enforce rounding up.  */\n          if (z < y)\n            z += L_(1.0);\n        }\n    }\n  return z;\n}",
      "lines": 44,
      "depth": 14,
      "decorators": [
        "DOUBLE"
      ]
    }
  },
  "datamash/datamash-1.3/lib/ceill.c": {
    "ceill": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        29,
        1
      ],
      "content": "long double\nceill (long double x)\n{\n  return ceil (x);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "long double",
        "long",
        "double"
      ]
    }
  },
  "datamash/datamash-1.3/lib/close-stream.c": {
    "close_stream": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "int\nclose_stream (FILE *stream)\n{\n  const bool some_pending = (__fpending (stream) != 0);\n  const bool prev_fail = (ferror (stream) != 0);\n  const bool fclose_fail = (fclose (stream) != 0);\n\n  /* Return an error indication if there was a previous failure or if\n     fclose failed, with one exception: ignore an fclose failure if\n     there was no previous error, no data remains to be flushed, and\n     fclose failed with EBADF.  That can happen when a program like cp\n     is invoked like this 'cp a b >&-' (i.e., with standard output\n     closed) and doesn't generate any output (hence no previous error\n     and nothing to be flushed).  */\n\n  if (prev_fail || (fclose_fail && (some_pending || errno != EBADF)))\n    {\n      if (! fclose_fail)\n        errno = 0;\n      return EOF;\n    }\n\n  return 0;\n}",
      "lines": 24,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "datamash/datamash-1.3/lib/close-stream.h": {},
  "datamash/datamash-1.3/lib/closeout.c": {
    "close_stdout_set_file_name": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "void\nclose_stdout_set_file_name (const char *file)\n{\n  file_name = file;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "close_stdout_set_ignore_EPIPE": {
      "start_point": [
        86,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "void\nclose_stdout_set_ignore_EPIPE (bool ignore)\n{\n  ignore_EPIPE = ignore;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "void"
      ]
    },
    "close_stdout": {
      "start_point": [
        115,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "void\nclose_stdout (void)\n{\n  if (close_stream (stdout) != 0\n      && !(ignore_EPIPE && errno == EPIPE))\n    {\n      char const *write_error = _(\"write error\");\n      if (file_name)\n        error (0, errno, \"%s: %s\", quotearg_colon (file_name),\n               write_error);\n      else\n        error (0, errno, \"%s\", write_error);\n\n      _exit (exit_failure);\n    }\n\n  /* Close stderr only if not sanitizing, as sanitizers may report to\n     stderr after this function returns.  */\n  if (!SANITIZE_ADDRESS && close_stream (stderr) != 0)\n    _exit (exit_failure);\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "datamash/datamash-1.3/lib/closeout.h": {},
  "datamash/datamash-1.3/lib/ctype.in.h": {},
  "datamash/datamash-1.3/lib/dirname-lgpl.c": {
    "dir_len": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "size_t\ndir_len (char const *file)\n{\n  size_t prefix_length = FILE_SYSTEM_PREFIX_LEN (file);\n  size_t length;\n\n  /* Advance prefix_length beyond important leading slashes.  */\n  prefix_length += (prefix_length != 0\n                    ? (FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE\n                       && ISSLASH (file[prefix_length]))\n                    : (ISSLASH (file[0])\n                       ? ((DOUBLE_SLASH_IS_DISTINCT_ROOT\n                           && ISSLASH (file[1]) && ! ISSLASH (file[2])\n                           ? 2 : 1))\n                       : 0));\n\n  /* Strip the basename and any redundant slashes before it.  */\n  for (length = last_component (file) - file;\n       prefix_length < length; length--)\n    if (! ISSLASH (file[length - 1]))\n      break;\n  return length;\n}",
      "lines": 23,
      "depth": 17,
      "decorators": [
        "size_t"
      ]
    },
    "mdir_name": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "char *\nmdir_name (char const *file)\n{\n  size_t length = dir_len (file);\n  bool append_dot = (length == 0\n                     || (FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE\n                         && length == FILE_SYSTEM_PREFIX_LEN (file)\n                         && file[2] != '\\0' && ! ISSLASH (file[2])));\n  char *dir = malloc (length + append_dot + 1);\n  if (!dir)\n    return NULL;\n  memcpy (dir, file, length);\n  if (append_dot)\n    dir[length++] = '.';\n  dir[length] = '\\0';\n  return dir;\n}",
      "lines": 17,
      "depth": 14,
      "decorators": [
        "char",
        "*\nmdir_name (char const *file)",
        "*"
      ]
    }
  },
  "datamash/datamash-1.3/lib/dirname.c": {
    "dir_name": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "char *\ndir_name (char const *file)\n{\n  char *result = mdir_name (file);\n  if (!result)\n    xalloc_die ();\n  return result;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "char",
        "*\ndir_name (char const *file)",
        "*"
      ]
    }
  },
  "datamash/datamash-1.3/lib/dirname.h": {},
  "datamash/datamash-1.3/lib/dosname.h": {},
  "datamash/datamash-1.3/lib/errno.in.h": {},
  "datamash/datamash-1.3/lib/error.c": {
    "is_open": {
      "start_point": [
        130,
        0
      ],
      "end_point": [
        145,
        1
      ],
      "content": "static int\nis_open (int fd)\n{\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n  /* On native Windows: The initial state of unassigned standard file\n     descriptors is that they are open but point to an INVALID_HANDLE_VALUE.\n     There is no fcntl, and the gnulib replacement fcntl does not support\n     F_GETFL.  */\n  return (HANDLE) _get_osfhandle (fd) != INVALID_HANDLE_VALUE;\n# else\n#  ifndef F_GETFL\n#   error Please port fcntl to your platform\n#  endif\n  return 0 <= fcntl (fd, F_GETFL);\n# endif\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "flush_stdout": {
      "start_point": [
        148,
        0
      ],
      "end_point": [
        171,
        1
      ],
      "content": "static void\nflush_stdout (void)\n{\n#if !_LIBC\n  int stdout_fd;\n\n# if GNULIB_FREOPEN_SAFER\n  /* Use of gnulib's freopen-safer module normally ensures that\n       fileno (stdout) == 1\n     whenever stdout is open.  */\n  stdout_fd = STDOUT_FILENO;\n# else\n  /* POSIX states that fileno (stdout) after fclose is unspecified.  But in\n     practice it is not a problem, because stdout is statically allocated and\n     the fd of a FILE stream is stored as a field in its allocated memory.  */\n  stdout_fd = fileno (stdout);\n# endif\n  /* POSIX states that fflush (stdout) after fclose is unspecified; it\n     is safe in glibc, but not on all other platforms.  fflush (NULL)\n     is always defined, but too draconian.  */\n  if (0 <= stdout_fd && is_open (stdout_fd))\n#endif\n    fflush (stdout);\n}",
      "lines": 24,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "print_errno_message": {
      "start_point": [
        173,
        0
      ],
      "end_point": [
        202,
        1
      ],
      "content": "static void\nprint_errno_message (int errnum)\n{\n  char const *s;\n\n#if _LIBC || GNULIB_STRERROR_R_POSIX || defined HAVE_STRERROR_R\n  char errbuf[1024];\n# if _LIBC || (!GNULIB_STRERROR_R_POSIX && STRERROR_R_CHAR_P)\n  s = __strerror_r (errnum, errbuf, sizeof errbuf);\n# else\n  if (__strerror_r (errnum, errbuf, sizeof errbuf) == 0)\n    s = errbuf;\n  else\n    s = 0;\n# endif\n#else\n  s = strerror (errnum);\n#endif\n\n#if !_LIBC\n  if (! s)\n    s = _(\"Unknown system error\");\n#endif\n\n#if _LIBC\n  __fxprintf (NULL, \": %s\", s);\n#else\n  fprintf (stderr, \": %s\", s);\n#endif\n}",
      "lines": 30,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "error_tail": {
      "start_point": [
        205,
        42
      ],
      "end_point": [
        286,
        1
      ],
      "content": "char *message, va_list args)\n{\n#if _LIBC\n  if (_IO_fwide (stderr, 0) > 0)\n    {\n      size_t len = strlen (message) + 1;\n      wchar_t *wmessage = NULL;\n      mbstate_t st;\n      size_t res;\n      const char *tmp;\n      bool use_malloc = false;\n\n      while (1)\n        {\n          if (__libc_use_alloca (len * sizeof (wchar_t)))\n            wmessage = (wchar_t *) alloca (len * sizeof (wchar_t));\n          else\n            {\n              if (!use_malloc)\n                wmessage = NULL;\n\n              wchar_t *p = (wchar_t *) realloc (wmessage,\n                                                len * sizeof (wchar_t));\n              if (p == NULL)\n                {\n                  free (wmessage);\n                  fputws_unlocked (L\"out of memory\\n\", stderr);\n                  return;\n                }\n              wmessage = p;\n              use_malloc = true;\n            }\n\n          memset (&st, '\\0', sizeof (st));\n          tmp = message;\n\n          res = mbsrtowcs (wmessage, &tmp, len, &st);\n          if (res != len)\n            break;\n\n          if (__builtin_expect (len >= SIZE_MAX / sizeof (wchar_t) / 2, 0))\n            {\n              /* This really should not happen if everything is fine.  */\n              res = (size_t) -1;\n              break;\n            }\n\n          len *= 2;\n        }\n\n      if (res == (size_t) -1)\n        {\n          /* The string cannot be converted.  */\n          if (use_malloc)\n            {\n              free (wmessage);\n              use_malloc = false;\n            }\n          wmessage = (wchar_t *) L\"???\";\n        }\n\n      __vfwprintf (stderr, wmessage, args);\n\n      if (use_malloc)\n        free (wmessage);\n    }\n  else\n#endif\n    vfprintf (stderr, message, args);\n\n  ++error_message_count;\n  if (errnum)\n    print_errno_message (errnum);\n#if _LIBC\n  __fxprintf (NULL, \"\\n\");\n#else\n  putc ('\\n', stderr);\n#endif\n  fflush (stderr);\n  if (status)\n    exit (status);\n}",
      "lines": 82,
      "depth": 18,
      "decorators": null
    },
    "error": {
      "start_point": [
        293,
        0
      ],
      "end_point": [
        331,
        1
      ],
      "content": "void\nerror (int status, int errnum, const char *message, ...)\n{\n  va_list args;\n\n#if defined _LIBC && defined __libc_ptf_call\n  /* We do not want this call to be cut short by a thread\n     cancellation.  Therefore disable cancellation for now.  */\n  int state = PTHREAD_CANCEL_ENABLE;\n  __libc_ptf_call (pthread_setcancelstate, (PTHREAD_CANCEL_DISABLE, &state),\n                   0);\n#endif\n\n  flush_stdout ();\n#ifdef _LIBC\n  _IO_flockfile (stderr);\n#endif\n  if (error_print_progname)\n    (*error_print_progname) ();\n  else\n    {\n#if _LIBC\n      __fxprintf (NULL, \"%s: \", program_name);\n#else\n      fprintf (stderr, \"%s: \", program_name);\n#endif\n    }\n\n  va_start (args, message);\n  error_tail (status, errnum, message, args);\n  va_end (args);\n\n#ifdef _LIBC\n  _IO_funlockfile (stderr);\n# ifdef __libc_ptf_call\n  __libc_ptf_call (pthread_setcancelstate, (state, NULL), 0);\n# endif\n#endif\n}",
      "lines": 39,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "error_at_line": {
      "start_point": [
        337,
        0
      ],
      "end_point": [
        402,
        1
      ],
      "content": "void\nerror_at_line (int status, int errnum, const char *file_name,\n               unsigned int line_number, const char *message, ...)\n{\n  va_list args;\n\n  if (error_one_per_line)\n    {\n      static const char *old_file_name;\n      static unsigned int old_line_number;\n\n      if (old_line_number == line_number\n          && (file_name == old_file_name\n              || (old_file_name != NULL\n                  && file_name != NULL\n                  && strcmp (old_file_name, file_name) == 0)))\n\n        /* Simply return and print nothing.  */\n        return;\n\n      old_file_name = file_name;\n      old_line_number = line_number;\n    }\n\n#if defined _LIBC && defined __libc_ptf_call\n  /* We do not want this call to be cut short by a thread\n     cancellation.  Therefore disable cancellation for now.  */\n  int state = PTHREAD_CANCEL_ENABLE;\n  __libc_ptf_call (pthread_setcancelstate, (PTHREAD_CANCEL_DISABLE, &state),\n                   0);\n#endif\n\n  flush_stdout ();\n#ifdef _LIBC\n  _IO_flockfile (stderr);\n#endif\n  if (error_print_progname)\n    (*error_print_progname) ();\n  else\n    {\n#if _LIBC\n      __fxprintf (NULL, \"%s:\", program_name);\n#else\n      fprintf (stderr, \"%s:\", program_name);\n#endif\n    }\n\n#if _LIBC\n  __fxprintf (NULL, file_name != NULL ? \"%s:%u: \" : \" \",\n              file_name, line_number);\n#else\n  fprintf (stderr, file_name != NULL ? \"%s:%u: \" : \" \",\n           file_name, line_number);\n#endif\n\n  va_start (args, message);\n  error_tail (status, errnum, message, args);\n  va_end (args);\n\n#ifdef _LIBC\n  _IO_funlockfile (stderr);\n# ifdef __libc_ptf_call\n  __libc_ptf_call (pthread_setcancelstate, (state, NULL), 0);\n# endif\n#endif\n}",
      "lines": 66,
      "depth": 15,
      "decorators": [
        "void"
      ]
    }
  },
  "datamash/datamash-1.3/lib/error.h": {},
  "datamash/datamash-1.3/lib/exitfail.c": {},
  "datamash/datamash-1.3/lib/exitfail.h": {},
  "datamash/datamash-1.3/lib/expl-table.c": {},
  "datamash/datamash-1.3/lib/expl.c": {
    "expl": [
      {
        "start_point": [
          23,
          0
        ],
        "end_point": [
          27,
          1
        ],
        "content": "long double\nexpl (long double x)\n{\n  return exp (x);\n}",
        "lines": 5,
        "depth": 6,
        "decorators": [
          "long double",
          "long",
          "double"
        ]
      },
      {
        "start_point": [
          57,
          0
        ],
        "end_point": [
          147,
          1
        ],
        "content": "long double\nexpl (long double x)\n{\n  if (isnanl (x))\n    return x;\n\n  if (x >= (long double) LDBL_MAX_EXP * LOG2_PLUS_EPSILON)\n    /* x > LDBL_MAX_EXP * log(2)\n       hence exp(x) > 2^LDBL_MAX_EXP, overflows to Infinity.  */\n    return HUGE_VALL;\n\n  if (x <= (long double) (LDBL_MIN_EXP - 1 - LDBL_MANT_DIG) * LOG2_PLUS_EPSILON)\n    /* x < (LDBL_MIN_EXP - 1 - LDBL_MANT_DIG) * log(2)\n       hence exp(x) < 2^(LDBL_MIN_EXP-1-LDBL_MANT_DIG),\n       underflows to zero.  */\n    return 0.0L;\n\n  /* Decompose x into\n       x = n * log(2) + m * log(2)/256 + y\n     where\n       n is an integer,\n       m is an integer, -128 <= m <= 128,\n       y is a number, |y| <= log(2)/512 + epsilon = 0.00135...\n     Then\n       exp(x) = 2^n * exp(m * log(2)/256) * exp(y)\n     The first factor is an ldexpl() call.\n     The second factor is a table lookup.\n     The third factor is computed\n     - either as sinh(y) + cosh(y)\n       where sinh(y) is computed through the power series:\n         sinh(y) = y + y^3/3! + y^5/5! + ...\n       and cosh(y) is computed as hypot(1, sinh(y)),\n     - or as exp(2*z) = (1 + tanh(z)) / (1 - tanh(z))\n       where z = y/2\n       and tanh(z) is computed through its power series:\n         tanh(z) = z\n                   - 1/3 * z^3\n                   + 2/15 * z^5\n                   - 17/315 * z^7\n                   + 62/2835 * z^9\n                   - 1382/155925 * z^11\n                   + 21844/6081075 * z^13\n                   - 929569/638512875 * z^15\n                   + ...\n       Since |z| <= log(2)/1024 < 0.0007, the relative contribution of the\n       z^13 term is < 0.0007^12 < 2^-120 <= 2^-LDBL_MANT_DIG, therefore we\n       can truncate the series after the z^11 term.\n\n     Given the usual bounds LDBL_MAX_EXP <= 16384, LDBL_MIN_EXP >= -16381,\n     LDBL_MANT_DIG <= 120, we can estimate x:  -11440 <= x <= 11357.\n     This means, when dividing x by log(2), where we want x mod log(2)\n     to be precise to LDBL_MANT_DIG bits, we have to use an approximation\n     to log(2) that has 14+LDBL_MANT_DIG bits.  */\n\n  {\n    long double nm = roundl (x * LOG2_BY_256_INVERSE); /* = 256 * n + m */\n    /* n has at most 15 bits, nm therefore has at most 23 bits, therefore\n       n * LOG2_HI_PART is computed exactly, and n * LOG2_LO_PART is computed\n       with an absolute error < 2^15 * 2e-10 * 2^-LDBL_MANT_DIG.  */\n    long double y_tmp = x - nm * LOG2_BY_256_HI_PART;\n    long double y = y_tmp - nm * LOG2_BY_256_LO_PART;\n    long double z = 0.5L * y;\n\n/* Coefficients of the power series for tanh(z).  */\n#define TANH_COEFF_1   1.0L\n#define TANH_COEFF_3  -0.333333333333333333333333333333333333334L\n#define TANH_COEFF_5   0.133333333333333333333333333333333333334L\n#define TANH_COEFF_7  -0.053968253968253968253968253968253968254L\n#define TANH_COEFF_9   0.0218694885361552028218694885361552028218L\n#define TANH_COEFF_11 -0.00886323552990219656886323552990219656886L\n#define TANH_COEFF_13  0.00359212803657248101692546136990581435026L\n#define TANH_COEFF_15 -0.00145583438705131826824948518070211191904L\n\n    long double z2 = z * z;\n    long double tanh_z =\n      (((((TANH_COEFF_11\n           * z2 + TANH_COEFF_9)\n          * z2 + TANH_COEFF_7)\n         * z2 + TANH_COEFF_5)\n        * z2 + TANH_COEFF_3)\n       * z2 + TANH_COEFF_1)\n      * z;\n\n    long double exp_y = (1.0L + tanh_z) / (1.0L - tanh_z);\n\n    int n = (int) roundl (nm * (1.0L / 256.0L));\n    int m = (int) nm - 256 * n;\n\n    return ldexpl (gl_expl_table[128 + m] * exp_y, n);\n  }\n}",
        "lines": 91,
        "depth": 22,
        "decorators": [
          "long double",
          "long",
          "double"
        ]
      }
    ]
  },
  "datamash/datamash-1.3/lib/fabsl.c": {
    "fabsl": [
      {
        "start_point": [
          26,
          0
        ],
        "end_point": [
          30,
          1
        ],
        "content": "long double\nfabsl (long double x)\n{\n  return fabs (x);\n}",
        "lines": 5,
        "depth": 6,
        "decorators": [
          "long double",
          "long",
          "double"
        ]
      },
      {
        "start_point": [
          34,
          0
        ],
        "end_point": [
          38,
          1
        ],
        "content": "long double\nfabsl (long double x)\n{\n  return (signbit (x) ? - x : x);\n}",
        "lines": 5,
        "depth": 8,
        "decorators": [
          "long double",
          "long",
          "double"
        ]
      }
    ]
  },
  "datamash/datamash-1.3/lib/float+.h": {},
  "datamash/datamash-1.3/lib/float.c": {},
  "datamash/datamash-1.3/lib/float.in.h": {},
  "datamash/datamash-1.3/lib/floor.c": {
    "FUNC": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        104,
        1
      ],
      "content": "DOUBLE\nFUNC (DOUBLE x)\n{\n  /* The use of 'volatile' guarantees that excess precision bits are dropped\n     at each addition step and before the following comparison at the caller's\n     site.  It is necessary on x86 systems where double-floats are not IEEE\n     compliant by default, to avoid that the results become platform and compiler\n     option dependent.  'volatile' is a portable alternative to gcc's\n     -ffloat-store option.  */\n  volatile DOUBLE y = x;\n  volatile DOUBLE z = y;\n\n  if (z > L_(0.0))\n    {\n      /* For 0 < x < 1, return +0.0 even if the current rounding mode is\n         FE_DOWNWARD.  */\n      if (z < L_(1.0))\n        z = L_(0.0);\n      /* Avoid rounding errors for values near 2^k, where k >= MANT_DIG-1.  */\n      else if (z < TWO_MANT_DIG)\n        {\n          /* Round to the next integer (nearest or up or down, doesn't matter).  */\n          z += TWO_MANT_DIG;\n          z -= TWO_MANT_DIG;\n          /* Enforce rounding down.  */\n          if (z > y)\n            z -= L_(1.0);\n        }\n    }\n  else if (z < L_(0.0))\n    {\n      /* Avoid rounding errors for values near -2^k, where k >= MANT_DIG-1.  */\n      if (z > - TWO_MANT_DIG)\n        {\n          /* Round to the next integer (nearest or up or down, doesn't matter).  */\n          z -= TWO_MANT_DIG;\n          z += TWO_MANT_DIG;\n          /* Enforce rounding down.  */\n          if (z > y)\n            z -= L_(1.0);\n        }\n    }\n  return z;\n}",
      "lines": 44,
      "depth": 13,
      "decorators": [
        "DOUBLE"
      ]
    }
  },
  "datamash/datamash-1.3/lib/floorl.c": {
    "floorl": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        29,
        1
      ],
      "content": "long double\nfloorl (long double x)\n{\n  return floor (x);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "long double",
        "long",
        "double"
      ]
    }
  },
  "datamash/datamash-1.3/lib/fpending.c": {
    "__fpending": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "size_t\n__fpending (FILE *fp)\n{\n  /* Most systems provide FILE as a struct and the necessary bitmask in\n     <stdio.h>, because they need it for implementing getc() and putc() as\n     fast macros.  */\n#if defined _IO_ftrylockfile || __GNU_LIBRARY__ == 1 /* GNU libc, BeOS, Haiku, Linux libc5 */\n  return fp->_IO_write_ptr - fp->_IO_write_base;\n#elif defined __sferror || defined __DragonFly__ || defined __ANDROID__\n  /* FreeBSD, NetBSD, OpenBSD, DragonFly, Mac OS X, Cygwin, Minix 3, Android */\n  return fp->_p - fp->_bf._base;\n#elif defined __EMX__                /* emx+gcc */\n  return fp->_ptr - fp->_buffer;\n#elif defined __minix                /* Minix */\n  return fp_->_ptr - fp_->_buf;\n#elif defined _IOERR                 /* AIX, HP-UX, IRIX, OSF/1, Solaris, OpenServer, mingw, MSVC, NonStop Kernel, OpenVMS */\n  return (fp_->_ptr ? fp_->_ptr - fp_->_base : 0);\n#elif defined __UCLIBC__             /* uClibc */\n  return (fp->__modeflags & __FLAG_WRITING ? fp->__bufpos - fp->__bufstart : 0);\n#elif defined __QNX__                /* QNX */\n  return (fp->_Mode & 0x2000 /*_MWRITE*/ ? fp->_Next - fp->_Buf : 0);\n#elif defined __MINT__               /* Atari FreeMiNT */\n  return fp->__bufp - fp->__buffer;\n#elif defined EPLAN9                 /* Plan9 */\n  return fp->wp - fp->buf;\n#else\n# error \"Please port gnulib fpending.c to your platform!\"\n  return 1;\n#endif\n}",
      "lines": 30,
      "depth": 15,
      "decorators": [
        "size_t"
      ]
    }
  },
  "datamash/datamash-1.3/lib/fpending.h": {},
  "datamash/datamash-1.3/lib/fpucw.h": {},
  "datamash/datamash-1.3/lib/frexp.c": {
    "FUNC": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        167,
        1
      ],
      "content": "DOUBLE\nFUNC (DOUBLE x, int *expptr)\n{\n  int sign;\n  int exponent;\n  DECL_ROUNDING\n\n  /* Test for NaN, infinity, and zero.  */\n  if (ISNAN (x) || x + x == x)\n    {\n      *expptr = 0;\n      return x;\n    }\n\n  sign = 0;\n  if (x < 0)\n    {\n      x = - x;\n      sign = -1;\n    }\n\n  BEGIN_ROUNDING ();\n\n  {\n    /* Since the exponent is an 'int', it fits in 64 bits.  Therefore the\n       loops are executed no more than 64 times.  */\n    DOUBLE pow2[64]; /* pow2[i] = 2^2^i */\n    DOUBLE powh[64]; /* powh[i] = 2^-2^i */\n    int i;\n\n    exponent = 0;\n    if (x >= L_(1.0))\n      {\n        /* A positive exponent.  */\n        DOUBLE pow2_i; /* = pow2[i] */\n        DOUBLE powh_i; /* = powh[i] */\n\n        /* Invariants: pow2_i = 2^2^i, powh_i = 2^-2^i,\n           x * 2^exponent = argument, x >= 1.0.  */\n        for (i = 0, pow2_i = L_(2.0), powh_i = L_(0.5);\n             ;\n             i++, pow2_i = pow2_i * pow2_i, powh_i = powh_i * powh_i)\n          {\n            if (x >= pow2_i)\n              {\n                exponent += (1 << i);\n                x *= powh_i;\n              }\n            else\n              break;\n\n            pow2[i] = pow2_i;\n            powh[i] = powh_i;\n          }\n        /* Avoid making x too small, as it could become a denormalized\n           number and thus lose precision.  */\n        while (i > 0 && x < pow2[i - 1])\n          {\n            i--;\n            powh_i = powh[i];\n          }\n        exponent += (1 << i);\n        x *= powh_i;\n        /* Here 2^-2^i <= x < 1.0.  */\n      }\n    else\n      {\n        /* A negative or zero exponent.  */\n        DOUBLE pow2_i; /* = pow2[i] */\n        DOUBLE powh_i; /* = powh[i] */\n\n        /* Invariants: pow2_i = 2^2^i, powh_i = 2^-2^i,\n           x * 2^exponent = argument, x < 1.0.  */\n        for (i = 0, pow2_i = L_(2.0), powh_i = L_(0.5);\n             ;\n             i++, pow2_i = pow2_i * pow2_i, powh_i = powh_i * powh_i)\n          {\n            if (x < powh_i)\n              {\n                exponent -= (1 << i);\n                x *= pow2_i;\n              }\n            else\n              break;\n\n            pow2[i] = pow2_i;\n            powh[i] = powh_i;\n          }\n        /* Here 2^-2^i <= x < 1.0.  */\n      }\n\n    /* Invariants: x * 2^exponent = argument, and 2^-2^i <= x < 1.0.  */\n    while (i > 0)\n      {\n        i--;\n        if (x < powh[i])\n          {\n            exponent -= (1 << i);\n            x *= pow2[i];\n          }\n      }\n    /* Here 0.5 <= x < 1.0.  */\n  }\n\n  if (sign < 0)\n    x = - x;\n\n  END_ROUNDING ();\n\n  *expptr = exponent;\n  return x;\n}",
      "lines": 112,
      "depth": 14,
      "decorators": [
        "DOUBLE"
      ]
    }
  },
  "datamash/datamash-1.3/lib/frexpl.c": {
    "frexpl": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        27,
        1
      ],
      "content": "long double\nfrexpl (long double x, int *expptr)\n{\n  return frexp (x, expptr);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "long double",
        "long",
        "double"
      ]
    }
  },
  "datamash/datamash-1.3/lib/getopt-cdefs.in.h": {},
  "datamash/datamash-1.3/lib/getopt-core.h": {},
  "datamash/datamash-1.3/lib/getopt-ext.h": {
    "struct": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "__BEGIN_DECLS\n\n/* Describe the long-named options requested by the application.\n   The LONG_OPTIONS argument to getopt_long or getopt_long_only is a vector\n   of 'struct option' terminated by an element containing a name which is\n   zero.\n\n   The field 'has_arg' is:\n   no_argument\t\t(or 0) if the option does not take an argument,\n   required_argument\t(or 1) if the option requires an argument,\n   optional_argument \t(or 2) if the option takes an optional argument.\n\n   If the field 'flag' is not NULL, it points to a variable that is set\n   to the value given in the field 'val' when the option is found, but\n   left unchanged if the option is not found.\n\n   To have a long-named option do something other than set an 'int' to\n   a compiled-in constant, such as set a value from 'optarg', set the\n   option's 'flag' field to zero and its 'val' field to a nonzero\n   value (the equivalent single-letter option character, if there is\n   one).  For long options that have a zero 'flag' field, 'getopt'\n   returns the contents of the 'val' field.  */\n\nstruct option\n{\n  const char *name;\n  /* has_arg can't be an enum because some compilers complain about\n     type mismatches in all the code that assumes it is an int.  */\n  int has_arg;\n  int *flag;\n  int val;\n}",
      "lines": 32,
      "depth": 5,
      "decorators": null
    }
  },
  "datamash/datamash-1.3/lib/getopt-pfx-core.h": {},
  "datamash/datamash-1.3/lib/getopt-pfx-ext.h": {},
  "datamash/datamash-1.3/lib/getopt.c": {
    "exchange": {
      "start_point": [
        129,
        0
      ],
      "end_point": [
        182,
        1
      ],
      "content": "static void\nexchange (char **argv, struct _getopt_data *d)\n{\n  int bottom = d->__first_nonopt;\n  int middle = d->__last_nonopt;\n  int top = d->optind;\n  char *tem;\n\n  /* Exchange the shorter segment with the far end of the longer segment.\n     That puts the shorter segment into the right place.\n     It leaves the longer segment in the right place overall,\n     but it consists of two parts that need to be swapped next.  */\n\n  while (top > middle && middle > bottom)\n    {\n      if (top - middle > middle - bottom)\n\t{\n\t  /* Bottom segment is the short one.  */\n\t  int len = middle - bottom;\n\t  int i;\n\n\t  /* Swap it with the top part of the top segment.  */\n\t  for (i = 0; i < len; i++)\n\t    {\n\t      tem = argv[bottom + i];\n\t      argv[bottom + i] = argv[top - (middle - bottom) + i];\n\t      argv[top - (middle - bottom) + i] = tem;\n\t    }\n\t  /* Exclude the moved bottom segment from further swapping.  */\n\t  top -= len;\n\t}\n      else\n\t{\n\t  /* Top segment is the short one.  */\n\t  int len = top - middle;\n\t  int i;\n\n\t  /* Swap it with the bottom part of the bottom segment.  */\n\t  for (i = 0; i < len; i++)\n\t    {\n\t      tem = argv[bottom + i];\n\t      argv[bottom + i] = argv[middle + i];\n\t      argv[middle + i] = tem;\n\t    }\n\t  /* Exclude the moved top segment from further swapping.  */\n\t  bottom += len;\n\t}\n    }\n\n  /* Update records for the slots the non-options now occupy.  */\n\n  d->__first_nonopt += (d->optind - d->__last_nonopt);\n  d->__last_nonopt = d->optind;\n}",
      "lines": 54,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "process_long_option": {
      "start_point": [
        192,
        0
      ],
      "end_point": [
        375,
        1
      ],
      "content": "static int\nprocess_long_option (int argc, char **argv, const char *optstring,\n\t\t     const struct option *longopts, int *longind,\n\t\t     int long_only, struct _getopt_data *d,\n\t\t     int print_errors, const char *prefix)\n{\n  char *nameend;\n  size_t namelen;\n  const struct option *p;\n  const struct option *pfound = NULL;\n  int n_options;\n  int option_index;\n\n  for (nameend = d->__nextchar; *nameend && *nameend != '='; nameend++)\n    /* Do nothing.  */ ;\n  namelen = nameend - d->__nextchar;\n\n  /* First look for an exact match, counting the options as a side\n     effect.  */\n  for (p = longopts, n_options = 0; p->name; p++, n_options++)\n    if (!strncmp (p->name, d->__nextchar, namelen)\n\t&& namelen == strlen (p->name))\n      {\n\t/* Exact match found.  */\n\tpfound = p;\n\toption_index = n_options;\n\tbreak;\n      }\n\n  if (pfound == NULL)\n    {\n      /* Didn't find an exact match, so look for abbreviations.  */\n      unsigned char *ambig_set = NULL;\n      int ambig_malloced = 0;\n      int ambig_fallback = 0;\n      int indfound = -1;\n\n      for (p = longopts, option_index = 0; p->name; p++, option_index++)\n\tif (!strncmp (p->name, d->__nextchar, namelen))\n\t  {\n\t    if (pfound == NULL)\n\t      {\n\t\t/* First nonexact match found.  */\n\t\tpfound = p;\n\t\tindfound = option_index;\n\t      }\n\t    else if (long_only\n\t\t     || pfound->has_arg != p->has_arg\n\t\t     || pfound->flag != p->flag\n\t\t     || pfound->val != p->val)\n\t      {\n\t\t/* Second or later nonexact match found.  */\n\t\tif (!ambig_fallback)\n\t\t  {\n\t\t    if (!print_errors)\n\t\t      /* Don't waste effort tracking the ambig set if\n\t\t\t we're not going to print it anyway.  */\n\t\t      ambig_fallback = 1;\n\t\t    else if (!ambig_set)\n\t\t      {\n\t\t\tif (__libc_use_alloca (n_options))\n\t\t\t  ambig_set = alloca (n_options);\n\t\t\telse if ((ambig_set = malloc (n_options)) == NULL)\n\t\t\t  /* Fall back to simpler error message.  */\n\t\t\t  ambig_fallback = 1;\n\t\t\telse\n\t\t\t  ambig_malloced = 1;\n\n\t\t\tif (ambig_set)\n\t\t\t  {\n\t\t\t    memset (ambig_set, 0, n_options);\n\t\t\t    ambig_set[indfound] = 1;\n\t\t\t  }\n\t\t      }\n\t\t    if (ambig_set)\n\t\t      ambig_set[option_index] = 1;\n\t\t  }\n\t      }\n\t  }\n\n      if (ambig_set || ambig_fallback)\n\t{\n\t  if (print_errors)\n\t    {\n\t      if (ambig_fallback)\n\t\tfprintf (stderr, _(\"%s: option '%s%s' is ambiguous\\n\"),\n\t\t\t argv[0], prefix, d->__nextchar);\n\t      else\n\t\t{\n\t\t  flockfile (stderr);\n\t\t  fprintf (stderr,\n\t\t\t   _(\"%s: option '%s%s' is ambiguous; possibilities:\"),\n\t\t\t   argv[0], prefix, d->__nextchar);\n\n\t\t  for (option_index = 0; option_index < n_options; option_index++)\n\t\t    if (ambig_set[option_index])\n\t\t      fprintf (stderr, \" '%s%s'\",\n\t\t\t       prefix, longopts[option_index].name);\n\n\t\t  /* This must use 'fprintf' even though it's only\n\t\t     printing a single character, so that it goes through\n\t\t     __fxprintf_nocancel when compiled as part of glibc.  */\n\t\t  fprintf (stderr, \"\\n\");\n\t\t  funlockfile (stderr);\n\t\t}\n\t    }\n\t  if (ambig_malloced)\n\t    free (ambig_set);\n\t  d->__nextchar += strlen (d->__nextchar);\n\t  d->optind++;\n\t  d->optopt = 0;\n\t  return '?';\n\t}\n\n      option_index = indfound;\n    }\n\n  if (pfound == NULL)\n    {\n      /* Can't find it as a long option.  If this is not getopt_long_only,\n\t or the option starts with '--' or is not a valid short option,\n\t then it's an error.  */\n      if (!long_only || argv[d->optind][1] == '-'\n\t  || strchr (optstring, *d->__nextchar) == NULL)\n\t{\n\t  if (print_errors)\n\t    fprintf (stderr, _(\"%s: unrecognized option '%s%s'\\n\"),\n\t\t     argv[0], prefix, d->__nextchar);\n\n\t  d->__nextchar = NULL;\n\t  d->optind++;\n\t  d->optopt = 0;\n\t  return '?';\n\t}\n\n      /* Otherwise interpret it as a short option.  */\n      return -1;\n    }\n\n  /* We have found a matching long option.  Consume it.  */\n  d->optind++;\n  d->__nextchar = NULL;\n  if (*nameend)\n    {\n      /* Don't test has_arg with >, because some C compilers don't\n\t allow it to be used on enums.  */\n      if (pfound->has_arg)\n\td->optarg = nameend + 1;\n      else\n\t{\n\t  if (print_errors)\n\t    fprintf (stderr,\n\t\t     _(\"%s: option '%s%s' doesn't allow an argument\\n\"),\n\t\t     argv[0], prefix, pfound->name);\n\n\t  d->optopt = pfound->val;\n\t  return '?';\n\t}\n    }\n  else if (pfound->has_arg == 1)\n    {\n      if (d->optind < argc)\n\td->optarg = argv[d->optind++];\n      else\n\t{\n\t  if (print_errors)\n\t    fprintf (stderr,\n\t\t     _(\"%s: option '%s%s' requires an argument\\n\"),\n\t\t     argv[0], prefix, pfound->name);\n\n\t  d->optopt = pfound->val;\n\t  return optstring[0] == ':' ? ':' : '?';\n\t}\n    }\n\n  if (longind != NULL)\n    *longind = option_index;\n  if (pfound->flag)\n    {\n      *(pfound->flag) = pfound->val;\n      return 0;\n    }\n  return pfound->val;\n}",
      "lines": 184,
      "depth": 24,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "_getopt_initialize": {
      "start_point": [
        379,
        0
      ],
      "end_point": [
        411,
        1
      ],
      "content": "static const char *\n_getopt_initialize (int argc _GL_UNUSED,\n\t\t    char **argv _GL_UNUSED, const char *optstring,\n\t\t    struct _getopt_data *d, int posixly_correct)\n{\n  /* Start processing options with ARGV-element 1 (since ARGV-element 0\n     is the program name); the sequence of previously skipped\n     non-option ARGV-elements is empty.  */\n  if (d->optind == 0)\n    d->optind = 1;\n\n  d->__first_nonopt = d->__last_nonopt = d->optind;\n  d->__nextchar = NULL;\n\n  /* Determine how to handle the ordering of options and nonoptions.  */\n  if (optstring[0] == '-')\n    {\n      d->__ordering = RETURN_IN_ORDER;\n      ++optstring;\n    }\n  else if (optstring[0] == '+')\n    {\n      d->__ordering = REQUIRE_ORDER;\n      ++optstring;\n    }\n  else if (posixly_correct || !!getenv (\"POSIXLY_CORRECT\"))\n    d->__ordering = REQUIRE_ORDER;\n  else\n    d->__ordering = PERMUTE;\n\n  d->__initialized = 1;\n  return optstring;\n}",
      "lines": 33,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\n_getopt_initialize (int argc _GL_UNUSED,\n\t\t    char **argv _GL_UNUSED, const char *optstring,\n\t\t    struct _getopt_data *d, int posixly_correct)",
        "*"
      ]
    },
    "_getopt_internal_r": {
      "start_point": [
        469,
        0
      ],
      "end_point": [
        699,
        1
      ],
      "content": "int\n_getopt_internal_r (int argc, char **argv, const char *optstring,\n\t\t    const struct option *longopts, int *longind,\n\t\t    int long_only, struct _getopt_data *d, int posixly_correct)\n{\n  int print_errors = d->opterr;\n\n  if (argc < 1)\n    return -1;\n\n  d->optarg = NULL;\n\n  if (d->optind == 0 || !d->__initialized)\n    optstring = _getopt_initialize (argc, argv, optstring, d, posixly_correct);\n  else if (optstring[0] == '-' || optstring[0] == '+')\n    optstring++;\n\n  if (optstring[0] == ':')\n    print_errors = 0;\n\n  /* Test whether ARGV[optind] points to a non-option argument.  */\n#define NONOPTION_P (argv[d->optind][0] != '-' || argv[d->optind][1] == '\\0')\n\n  if (d->__nextchar == NULL || *d->__nextchar == '\\0')\n    {\n      /* Advance to the next ARGV-element.  */\n\n      /* Give FIRST_NONOPT & LAST_NONOPT rational values if OPTIND has been\n\t moved back by the user (who may also have changed the arguments).  */\n      if (d->__last_nonopt > d->optind)\n\td->__last_nonopt = d->optind;\n      if (d->__first_nonopt > d->optind)\n\td->__first_nonopt = d->optind;\n\n      if (d->__ordering == PERMUTE)\n\t{\n\t  /* If we have just processed some options following some non-options,\n\t     exchange them so that the options come first.  */\n\n\t  if (d->__first_nonopt != d->__last_nonopt\n\t      && d->__last_nonopt != d->optind)\n\t    exchange (argv, d);\n\t  else if (d->__last_nonopt != d->optind)\n\t    d->__first_nonopt = d->optind;\n\n\t  /* Skip any additional non-options\n\t     and extend the range of non-options previously skipped.  */\n\n\t  while (d->optind < argc && NONOPTION_P)\n\t    d->optind++;\n\t  d->__last_nonopt = d->optind;\n\t}\n\n      /* The special ARGV-element '--' means premature end of options.\n\t Skip it like a null option,\n\t then exchange with previous non-options as if it were an option,\n\t then skip everything else like a non-option.  */\n\n      if (d->optind != argc && !strcmp (argv[d->optind], \"--\"))\n\t{\n\t  d->optind++;\n\n\t  if (d->__first_nonopt != d->__last_nonopt\n\t      && d->__last_nonopt != d->optind)\n\t    exchange (argv, d);\n\t  else if (d->__first_nonopt == d->__last_nonopt)\n\t    d->__first_nonopt = d->optind;\n\t  d->__last_nonopt = argc;\n\n\t  d->optind = argc;\n\t}\n\n      /* If we have done all the ARGV-elements, stop the scan\n\t and back over any non-options that we skipped and permuted.  */\n\n      if (d->optind == argc)\n\t{\n\t  /* Set the next-arg-index to point at the non-options\n\t     that we previously skipped, so the caller will digest them.  */\n\t  if (d->__first_nonopt != d->__last_nonopt)\n\t    d->optind = d->__first_nonopt;\n\t  return -1;\n\t}\n\n      /* If we have come to a non-option and did not permute it,\n\t either stop the scan or describe it to the caller and pass it by.  */\n\n      if (NONOPTION_P)\n\t{\n\t  if (d->__ordering == REQUIRE_ORDER)\n\t    return -1;\n\t  d->optarg = argv[d->optind++];\n\t  return 1;\n\t}\n\n      /* We have found another option-ARGV-element.\n\t Check whether it might be a long option.  */\n      if (longopts)\n\t{\n\t  if (argv[d->optind][1] == '-')\n\t    {\n\t      /* \"--foo\" is always a long option.  The special option\n\t\t \"--\" was handled above.  */\n\t      d->__nextchar = argv[d->optind] + 2;\n\t      return process_long_option (argc, argv, optstring, longopts,\n\t\t\t\t\t  longind, long_only, d,\n\t\t\t\t\t  print_errors, \"--\");\n\t    }\n\n\t  /* If long_only and the ARGV-element has the form \"-f\",\n\t     where f is a valid short option, don't consider it an\n\t     abbreviated form of a long option that starts with f.\n\t     Otherwise there would be no way to give the -f short\n\t     option.\n\n\t     On the other hand, if there's a long option \"fubar\" and\n\t     the ARGV-element is \"-fu\", do consider that an\n\t     abbreviation of the long option, just like \"--fu\", and\n\t     not \"-f\" with arg \"u\".\n\n\t     This distinction seems to be the most useful approach.  */\n\t  if (long_only && (argv[d->optind][2]\n\t\t\t    || !strchr (optstring, argv[d->optind][1])))\n\t    {\n\t      int code;\n\t      d->__nextchar = argv[d->optind] + 1;\n\t      code = process_long_option (argc, argv, optstring, longopts,\n\t\t\t\t\t  longind, long_only, d,\n\t\t\t\t\t  print_errors, \"-\");\n\t      if (code != -1)\n\t\treturn code;\n\t    }\n\t}\n\n      /* It is not a long option.  Skip the initial punctuation.  */\n      d->__nextchar = argv[d->optind] + 1;\n    }\n\n  /* Look at and handle the next short option-character.  */\n\n  {\n    char c = *d->__nextchar++;\n    const char *temp = strchr (optstring, c);\n\n    /* Increment 'optind' when we start to process its last character.  */\n    if (*d->__nextchar == '\\0')\n      ++d->optind;\n\n    if (temp == NULL || c == ':' || c == ';')\n      {\n\tif (print_errors)\n\t  fprintf (stderr, _(\"%s: invalid option -- '%c'\\n\"), argv[0], c);\n\td->optopt = c;\n\treturn '?';\n      }\n\n    /* Convenience. Treat POSIX -W foo same as long option --foo */\n    if (temp[0] == 'W' && temp[1] == ';' && longopts != NULL)\n      {\n\t/* This is an option that requires an argument.  */\n\tif (*d->__nextchar != '\\0')\n\t  d->optarg = d->__nextchar;\n\telse if (d->optind == argc)\n\t  {\n\t    if (print_errors)\n\t      fprintf (stderr,\n\t\t       _(\"%s: option requires an argument -- '%c'\\n\"),\n\t\t       argv[0], c);\n\n\t    d->optopt = c;\n\t    if (optstring[0] == ':')\n\t      c = ':';\n\t    else\n\t      c = '?';\n\t    return c;\n\t  }\n\telse\n\t  d->optarg = argv[d->optind];\n\n\td->__nextchar = d->optarg;\n\td->optarg = NULL;\n\treturn process_long_option (argc, argv, optstring, longopts, longind,\n\t\t\t\t    0 /* long_only */, d, print_errors, \"-W \");\n      }\n    if (temp[1] == ':')\n      {\n\tif (temp[2] == ':')\n\t  {\n\t    /* This is an option that accepts an argument optionally.  */\n\t    if (*d->__nextchar != '\\0')\n\t      {\n\t\td->optarg = d->__nextchar;\n\t\td->optind++;\n\t      }\n\t    else\n\t      d->optarg = NULL;\n\t    d->__nextchar = NULL;\n\t  }\n\telse\n\t  {\n\t    /* This is an option that requires an argument.  */\n\t    if (*d->__nextchar != '\\0')\n\t      {\n\t\td->optarg = d->__nextchar;\n\t\t/* If we end this ARGV-element by taking the rest as an arg,\n\t\t   we must advance to the next element now.  */\n\t\td->optind++;\n\t      }\n\t    else if (d->optind == argc)\n\t      {\n\t\tif (print_errors)\n\t\t  fprintf (stderr,\n\t\t\t   _(\"%s: option requires an argument -- '%c'\\n\"),\n\t\t\t   argv[0], c);\n\n\t\td->optopt = c;\n\t\tif (optstring[0] == ':')\n\t\t  c = ':';\n\t\telse\n\t\t  c = '?';\n\t      }\n\t    else\n\t      /* We already incremented 'optind' once;\n\t\t increment it again when taking next ARGV-elt as argument.  */\n\t      d->optarg = argv[d->optind++];\n\t    d->__nextchar = NULL;\n\t  }\n      }\n    return c;\n  }\n}",
      "lines": 231,
      "depth": 18,
      "decorators": [
        "int"
      ]
    },
    "_getopt_internal": {
      "start_point": [
        701,
        0
      ],
      "end_point": [
        720,
        1
      ],
      "content": "int\n_getopt_internal (int argc, char **argv, const char *optstring,\n\t\t  const struct option *longopts, int *longind, int long_only,\n\t\t  int posixly_correct)\n{\n  int result;\n\n  getopt_data.optind = optind;\n  getopt_data.opterr = opterr;\n\n  result = _getopt_internal_r (argc, argv, optstring, longopts,\n\t\t\t       longind, long_only, &getopt_data,\n\t\t\t       posixly_correct);\n\n  optind = getopt_data.optind;\n  optarg = getopt_data.optarg;\n  optopt = getopt_data.optopt;\n\n  return result;\n}",
      "lines": 20,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "main": {
      "start_point": [
        747,
        0
      ],
      "end_point": [
        808,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  int c;\n  int digit_optind = 0;\n\n  while (1)\n    {\n      int this_option_optind = optind ? optind : 1;\n\n      c = getopt (argc, argv, \"abc:d:0123456789\");\n      if (c == -1)\n\tbreak;\n\n      switch (c)\n\t{\n\tcase '0':\n\tcase '1':\n\tcase '2':\n\tcase '3':\n\tcase '4':\n\tcase '5':\n\tcase '6':\n\tcase '7':\n\tcase '8':\n\tcase '9':\n\t  if (digit_optind != 0 && digit_optind != this_option_optind)\n\t    printf (\"digits occur in two different argv-elements.\\n\");\n\t  digit_optind = this_option_optind;\n\t  printf (\"option %c\\n\", c);\n\t  break;\n\n\tcase 'a':\n\t  printf (\"option a\\n\");\n\t  break;\n\n\tcase 'b':\n\t  printf (\"option b\\n\");\n\t  break;\n\n\tcase 'c':\n\t  printf (\"option c with value '%s'\\n\", optarg);\n\t  break;\n\n\tcase '?':\n\t  break;\n\n\tdefault:\n\t  printf (\"?? getopt returned character code 0%o ??\\n\", c);\n\t}\n    }\n\n  if (optind < argc)\n    {\n      printf (\"non-option ARGV-elements: \");\n      while (optind < argc)\n\tprintf (\"%s \", argv[optind++]);\n      printf (\"\\n\");\n    }\n\n  exit (0);\n}",
      "lines": 62,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "datamash/datamash-1.3/lib/getopt.in.h": {},
  "datamash/datamash-1.3/lib/getopt1.c": {
    "getopt_long": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        32,
        1
      ],
      "content": "int\ngetopt_long (int argc, char *__getopt_argv_const *argv, const char *options,\n\t     const struct option *long_options, int *opt_index)\n{\n  return _getopt_internal (argc, (char **) argv, options, long_options,\n\t\t\t   opt_index, 0, 0);\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "_getopt_long_r": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        41,
        1
      ],
      "content": "int\n_getopt_long_r (int argc, char **argv, const char *options,\n\t\tconst struct option *long_options, int *opt_index,\n\t\tstruct _getopt_data *d)\n{\n  return _getopt_internal_r (argc, argv, options, long_options, opt_index,\n\t\t\t     0, d, 0);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "getopt_long_only": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "int\ngetopt_long_only (int argc, char *__getopt_argv_const *argv,\n\t\t  const char *options,\n\t\t  const struct option *long_options, int *opt_index)\n{\n  return _getopt_internal (argc, (char **) argv, options, long_options,\n\t\t\t   opt_index, 1, 0);\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "_getopt_long_only_r": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "int\n_getopt_long_only_r (int argc, char **argv, const char *options,\n\t\t     const struct option *long_options, int *opt_index,\n\t\t     struct _getopt_data *d)\n{\n  return _getopt_internal_r (argc, argv, options, long_options, opt_index,\n\t\t\t     1, d, 0);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "main": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        156,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  int c;\n  int digit_optind = 0;\n\n  while (1)\n    {\n      int this_option_optind = optind ? optind : 1;\n      int option_index = 0;\n      static const struct option long_options[] =\n      {\n\t{\"add\", 1, 0, 0},\n\t{\"append\", 0, 0, 0},\n\t{\"delete\", 1, 0, 0},\n\t{\"verbose\", 0, 0, 0},\n\t{\"create\", 0, 0, 0},\n\t{\"file\", 1, 0, 0},\n\t{0, 0, 0, 0}\n      };\n\n      c = getopt_long (argc, argv, \"abc:d:0123456789\",\n\t\t       long_options, &option_index);\n      if (c == -1)\n\tbreak;\n\n      switch (c)\n\t{\n\tcase 0:\n\t  printf (\"option %s\", long_options[option_index].name);\n\t  if (optarg)\n\t    printf (\" with arg %s\", optarg);\n\t  printf (\"\\n\");\n\t  break;\n\n\tcase '0':\n\tcase '1':\n\tcase '2':\n\tcase '3':\n\tcase '4':\n\tcase '5':\n\tcase '6':\n\tcase '7':\n\tcase '8':\n\tcase '9':\n\t  if (digit_optind != 0 && digit_optind != this_option_optind)\n\t    printf (\"digits occur in two different argv-elements.\\n\");\n\t  digit_optind = this_option_optind;\n\t  printf (\"option %c\\n\", c);\n\t  break;\n\n\tcase 'a':\n\t  printf (\"option a\\n\");\n\t  break;\n\n\tcase 'b':\n\t  printf (\"option b\\n\");\n\t  break;\n\n\tcase 'c':\n\t  printf (\"option c with value '%s'\\n\", optarg);\n\t  break;\n\n\tcase 'd':\n\t  printf (\"option d with value '%s'\\n\", optarg);\n\t  break;\n\n\tcase '?':\n\t  break;\n\n\tdefault:\n\t  printf (\"?? getopt returned character code 0%o ??\\n\", c);\n\t}\n    }\n\n  if (optind < argc)\n    {\n      printf (\"non-option ARGV-elements: \");\n      while (optind < argc)\n\tprintf (\"%s \", argv[optind++]);\n      printf (\"\\n\");\n    }\n\n  exit (0);\n}",
      "lines": 85,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "datamash/datamash-1.3/lib/getopt_int.h": {},
  "datamash/datamash-1.3/lib/getprogname.c": {
    "getprogname": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        181,
        1
      ],
      "content": "char const *\ngetprogname (void)\n{\n# if HAVE_DECL_PROGRAM_INVOCATION_SHORT_NAME                /* glibc, BeOS */\n  /* https://www.gnu.org/software/libc/manual/html_node/Error-Messages.html */\n  return program_invocation_short_name;\n# elif HAVE_DECL_PROGRAM_INVOCATION_NAME                    /* glibc, BeOS */\n  /* https://www.gnu.org/software/libc/manual/html_node/Error-Messages.html */\n  return last_component (program_invocation_name);\n# elif HAVE_GETEXECNAME                                     /* Solaris */\n  /* https://docs.oracle.com/cd/E19253-01/816-5168/6mbb3hrb1/index.html */\n  const char *p = getexecname ();\n  if (!p)\n    p = \"?\";\n  return last_component (p);\n# elif HAVE_DECL___ARGV                                     /* mingw, MSVC */\n  /* https://msdn.microsoft.com/en-us/library/dn727674.aspx */\n  const char *p = __argv && __argv[0] ? __argv[0] : \"?\";\n  return last_component (p);\n# elif HAVE_VAR___PROGNAME                                  /* OpenBSD, QNX */\n  /* https://man.openbsd.org/style.9 */\n  /* http://www.qnx.de/developers/docs/6.5.0/index.jsp?topic=%2Fcom.qnx.doc.neutrino_lib_ref%2Fp%2F__progname.html */\n  /* Be careful to declare this only when we absolutely need it\n     (OpenBSD 5.1), rather than when it's available.  Otherwise,\n     its mere declaration makes program_invocation_short_name\n     malfunction (have zero length) with Fedora 25's glibc.  */\n  extern char *__progname;\n  const char *p = __progname;\n  return p && p[0] ? p : \"?\";\n# elif _AIX                                                 /* AIX */\n  /* Idea by Bastien ROUCARI\u00c3\u0088S,\n     https://lists.gnu.org/r/bug-gnulib/2010-12/msg00095.html\n     Reference: https://www.ibm.com/support/knowledgecenter/en/ssw_aix_61/com.ibm.aix.basetrf1/getprocs.htm\n  */\n  static char *p;\n  static int first = 1;\n  if (first)\n    {\n      first = 0;\n      pid_t pid = getpid ();\n      struct procentry64 procs;\n      p = (0 < getprocs64 (&procs, sizeof procs, NULL, 0, &pid, 1)\n           ? strdup (procs.pi_comm)\n           : NULL);\n      if (!p)\n        p = \"?\";\n    }\n  return p;\n# elif defined __hpux\n  static char *p;\n  static int first = 1;\n  if (first)\n    {\n      first = 0;\n      pid_t pid = getpid ();\n      struct pst_status status;\n      p = (0 < pstat_getproc (&status, sizeof status, 0, pid)\n           ? strdup (status.pst_ucomm)\n           : NULL);\n      if (!p)\n        p = \"?\";\n    }\n  return p;\n# elif __MVS__                                              /* z/OS */\n  /* https://www.ibm.com/support/knowledgecenter/SSLTBW_2.1.0/com.ibm.zos.v2r1.bpxbd00/rtwgetp.htm */\n  static char *p = \"?\";\n  static int first = 1;\n  if (first)\n    {\n      pid_t pid = getpid ();\n      int token;\n      W_PSPROC buf;\n      first = 0;\n      memset (&buf, 0, sizeof(buf));\n      buf.ps_cmdptr    = (char *) malloc (buf.ps_cmdlen    = PS_CMDBLEN_LONG);\n      buf.ps_conttyptr = (char *) malloc (buf.ps_conttylen = PS_CONTTYBLEN);\n      buf.ps_pathptr   = (char *) malloc (buf.ps_pathlen   = PS_PATHBLEN);\n      if (buf.ps_cmdptr && buf.ps_conttyptr && buf.ps_pathptr)\n        {\n          for (token = 0; token >= 0;\n               token = w_getpsent (token, &buf, sizeof(buf)))\n            {\n              if (token > 0 && buf.ps_pid == pid)\n                {\n                  char *s = strdup (last_component (buf.ps_pathptr));\n                  if (s)\n                    p = s;\n                  break;\n                }\n            }\n        }\n      free (buf.ps_cmdptr);\n      free (buf.ps_conttyptr);\n      free (buf.ps_pathptr);\n    }\n  return p;\n# elif defined __sgi                                        /* IRIX */\n  char filename[50];\n  int fd;\n\n  sprintf (filename, \"/proc/pinfo/%d\", (int) getpid ());\n  fd = open (filename, O_RDONLY);\n  if (0 <= fd)\n    {\n      prpsinfo_t buf;\n      int ioctl_ok = 0 <= ioctl (fd, PIOCPSINFO, &buf);\n      close (fd);\n      if (ioctl_ok)\n        {\n          char *name = buf.pr_fname;\n          size_t namesize = sizeof buf.pr_fname;\n          char *namenul = memchr (name, '\\0', namesize);\n          size_t namelen = namenul ? namenul - name : namesize;\n          char *namecopy = malloc (namelen + 1);\n          if (namecopy)\n            {\n              namecopy[namelen] = 0;\n              return memcpy (namecopy, name, namelen);\n            }\n        }\n    }\n  return NULL;\n# else\n#  error \"getprogname module not ported to this OS\"\n# endif\n}",
      "lines": 126,
      "depth": 26,
      "decorators": [
        "char",
        "const",
        "const",
        "*\ngetprogname (void)",
        "*"
      ]
    }
  },
  "datamash/datamash-1.3/lib/getprogname.h": {},
  "datamash/datamash-1.3/lib/gettext.h": {
    "pgettext_aux": {
      "start_point": [
        147,
        0
      ],
      "end_point": [
        157,
        1
      ],
      "content": "static const char *\npgettext_aux (const char *domain,\n              const char *msg_ctxt_id, const char *msgid,\n              int category)\n{\n  const char *translation = dcgettext (domain, msg_ctxt_id, category);\n  if (translation == msg_ctxt_id)\n    return msgid;\n  else\n    return translation;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\npgettext_aux (const char *domain,\n              const char *msg_ctxt_id, const char *msgid,\n              int category)",
        "*"
      ]
    },
    "npgettext_aux": {
      "start_point": [
        166,
        0
      ],
      "end_point": [
        178,
        1
      ],
      "content": "static const char *\nnpgettext_aux (const char *domain,\n               const char *msg_ctxt_id, const char *msgid,\n               const char *msgid_plural, unsigned long int n,\n               int category)\n{\n  const char *translation =\n    dcngettext (domain, msg_ctxt_id, msgid_plural, n, category);\n  if (translation == msg_ctxt_id || translation == msgid_plural)\n    return (n == 1 ? msgid : msgid_plural);\n  else\n    return translation;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nnpgettext_aux (const char *domain,\n               const char *msg_ctxt_id, const char *msgid,\n               const char *msgid_plural, unsigned long int n,\n               int category)",
        "*"
      ]
    },
    "dcpgettext_expr": {
      "start_point": [
        210,
        0
      ],
      "end_point": [
        243,
        1
      ],
      "content": "static const char *\ndcpgettext_expr (const char *domain,\n                 const char *msgctxt, const char *msgid,\n                 int category)\n{\n  size_t msgctxt_len = strlen (msgctxt) + 1;\n  size_t msgid_len = strlen (msgid) + 1;\n  const char *translation;\n#if _LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n  char msg_ctxt_id[msgctxt_len + msgid_len];\n#else\n  char buf[1024];\n  char *msg_ctxt_id =\n    (msgctxt_len + msgid_len <= sizeof (buf)\n     ? buf\n     : (char *) malloc (msgctxt_len + msgid_len));\n  if (msg_ctxt_id != NULL)\n#endif\n    {\n      int found_translation;\n      memcpy (msg_ctxt_id, msgctxt, msgctxt_len - 1);\n      msg_ctxt_id[msgctxt_len - 1] = '\\004';\n      memcpy (msg_ctxt_id + msgctxt_len, msgid, msgid_len);\n      translation = dcgettext (domain, msg_ctxt_id, category);\n      found_translation = (translation != msg_ctxt_id);\n#if !_LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n      if (msg_ctxt_id != buf)\n        free (msg_ctxt_id);\n#endif\n      if (found_translation)\n        return translation;\n    }\n  return msgid;\n}",
      "lines": 34,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\ndcpgettext_expr (const char *domain,\n                 const char *msgctxt, const char *msgid,\n                 int category)",
        "*"
      ]
    },
    "dcnpgettext_expr": {
      "start_point": [
        257,
        0
      ],
      "end_point": [
        291,
        1
      ],
      "content": "static const char *\ndcnpgettext_expr (const char *domain,\n                  const char *msgctxt, const char *msgid,\n                  const char *msgid_plural, unsigned long int n,\n                  int category)\n{\n  size_t msgctxt_len = strlen (msgctxt) + 1;\n  size_t msgid_len = strlen (msgid) + 1;\n  const char *translation;\n#if _LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n  char msg_ctxt_id[msgctxt_len + msgid_len];\n#else\n  char buf[1024];\n  char *msg_ctxt_id =\n    (msgctxt_len + msgid_len <= sizeof (buf)\n     ? buf\n     : (char *) malloc (msgctxt_len + msgid_len));\n  if (msg_ctxt_id != NULL)\n#endif\n    {\n      int found_translation;\n      memcpy (msg_ctxt_id, msgctxt, msgctxt_len - 1);\n      msg_ctxt_id[msgctxt_len - 1] = '\\004';\n      memcpy (msg_ctxt_id + msgctxt_len, msgid, msgid_len);\n      translation = dcngettext (domain, msg_ctxt_id, msgid_plural, n, category);\n      found_translation = !(translation == msg_ctxt_id || translation == msgid_plural);\n#if !_LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n      if (msg_ctxt_id != buf)\n        free (msg_ctxt_id);\n#endif\n      if (found_translation)\n        return translation;\n    }\n  return (n == 1 ? msgid : msgid_plural);\n}",
      "lines": 35,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\ndcnpgettext_expr (const char *domain,\n                  const char *msgctxt, const char *msgid,\n                  const char *msgid_plural, unsigned long int n,\n                  int category)",
        "*"
      ]
    }
  },
  "datamash/datamash-1.3/lib/gl_openssl.h": {
    "GL_CRYPTO_FN": [
      {
        "start_point": [
          76,
          0
        ],
        "end_point": [
          78,
          48
        ],
        "content": "GL_OPENSSL_INLINE void\nGL_CRYPTO_FN (_init_ctx) (struct _gl_ctx *ctx)\n{ (void) OPENSSL_FN (_Init) ((_gl_CTX *) ctx); }",
        "lines": 3,
        "depth": 10,
        "decorators": [
          "GL_OPENSSL_INLINE",
          "void",
          "void"
        ]
      },
      {
        "start_point": [
          82,
          0
        ],
        "end_point": [
          84,
          53
        ],
        "content": "GL_OPENSSL_INLINE void\nGL_CRYPTO_FN (_process_bytes) (const void *buf, size_t len, struct _gl_ctx *ctx)\n{ OPENSSL_FN (_Update) ((_gl_CTX *) ctx, buf, len); }",
        "lines": 3,
        "depth": 9,
        "decorators": [
          "GL_OPENSSL_INLINE",
          "void",
          "void"
        ]
      },
      {
        "start_point": [
          86,
          0
        ],
        "end_point": [
          88,
          50
        ],
        "content": "GL_OPENSSL_INLINE void\nGL_CRYPTO_FN (_process_block) (const void *buf, size_t len, struct _gl_ctx *ctx)\n{ GL_CRYPTO_FN (_process_bytes) (buf, len, ctx); }",
        "lines": 3,
        "depth": 7,
        "decorators": [
          "GL_OPENSSL_INLINE",
          "void",
          "void"
        ]
      },
      {
        "start_point": [
          91,
          0
        ],
        "end_point": [
          93,
          77
        ],
        "content": "GL_OPENSSL_INLINE void *\nGL_CRYPTO_FN (_finish_ctx) (struct _gl_ctx *ctx, void *res)\n{ OPENSSL_FN (_Final) ((unsigned char *) res, (_gl_CTX *) ctx); return res; }",
        "lines": 3,
        "depth": 9,
        "decorators": [
          "GL_OPENSSL_INLINE",
          "void",
          "void",
          "*\nGL_CRYPTO_FN (_finish_ctx) (struct _gl_ctx *ctx, void *res)",
          "*"
        ]
      },
      {
        "start_point": [
          95,
          0
        ],
        "end_point": [
          97,
          83
        ],
        "content": "GL_OPENSSL_INLINE void *\nGL_CRYPTO_FN (_buffer) (const char *buf, size_t len, void *res)\n{ return OPENSSL_FN () ((const unsigned char *) buf, len, (unsigned char *) res); }",
        "lines": 3,
        "depth": 9,
        "decorators": [
          "GL_OPENSSL_INLINE",
          "void",
          "void",
          "*\nGL_CRYPTO_FN (_buffer) (const char *buf, size_t len, void *res)",
          "*"
        ]
      },
      {
        "start_point": [
          99,
          0
        ],
        "end_point": [
          106,
          1
        ],
        "content": "GL_OPENSSL_INLINE void *\nGL_CRYPTO_FN (_read_ctx) (const struct _gl_ctx *ctx, void *res)\n{\n  /* Assume any unprocessed bytes in ctx are not to be ignored.  */\n  _gl_CTX tmp_ctx = *(_gl_CTX *) ctx;\n  OPENSSL_FN (_Final) ((unsigned char *) res, &tmp_ctx);\n  return res;\n}",
        "lines": 8,
        "depth": 9,
        "decorators": [
          "GL_OPENSSL_INLINE",
          "void",
          "void",
          "*\nGL_CRYPTO_FN (_read_ctx) (const struct _gl_ctx *ctx, void *res)",
          "*"
        ]
      }
    ]
  },
  "datamash/datamash-1.3/lib/hard-locale.c": {
    "hard_locale": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "bool\nhard_locale (int category)\n{\n  bool hard = true;\n  char const *p = setlocale (category, NULL);\n\n  if (p)\n    {\n      if (2 <= GLIBC_VERSION)\n        {\n          if (strcmp (p, \"C\") == 0 || strcmp (p, \"POSIX\") == 0)\n            hard = false;\n        }\n      else\n        {\n          char *locale = strdup (p);\n          if (locale)\n            {\n              /* Temporarily set the locale to the \"C\" and \"POSIX\" locales\n                 to find their names, so that we can determine whether one\n                 or the other is the caller's locale.  */\n              if (((p = setlocale (category, \"C\"))\n                   && strcmp (p, locale) == 0)\n                  || ((p = setlocale (category, \"POSIX\"))\n                      && strcmp (p, locale) == 0))\n                hard = false;\n\n              /* Restore the caller's locale.  */\n              setlocale (category, locale);\n              free (locale);\n            }\n        }\n    }\n\n  return hard;\n}",
      "lines": 36,
      "depth": 19,
      "decorators": [
        "bool"
      ]
    }
  },
  "datamash/datamash-1.3/lib/hard-locale.h": {},
  "datamash/datamash-1.3/lib/hash-pjw-bare.c": {
    "hash_pjw_bare": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        41,
        1
      ],
      "content": "size_t\nhash_pjw_bare (const void *x, size_t n)\n{\n  const unsigned char *s = x;\n  size_t h = 0;\n  unsigned i;\n\n  for (i = 0; i < n; i++)\n    h = s[i] + ((h << 9) | (h >> (SIZE_BITS - 9)));\n\n  return h;\n}",
      "lines": 12,
      "depth": 13,
      "decorators": [
        "size_t"
      ]
    }
  },
  "datamash/datamash-1.3/lib/hash-pjw-bare.h": {},
  "datamash/datamash-1.3/lib/hash-pjw.c": {
    "hash_pjw": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        39,
        1
      ],
      "content": "size_t\nhash_pjw (const void *x, size_t tablesize)\n{\n  const char *s;\n  size_t h = 0;\n\n  for (s = x; *s; s++)\n    h = *s + ((h << 9) | (h >> (SIZE_BITS - 9)));\n\n  return h % tablesize;\n}",
      "lines": 11,
      "depth": 13,
      "decorators": [
        "size_t"
      ]
    }
  },
  "datamash/datamash-1.3/lib/hash-pjw.h": {},
  "datamash/datamash-1.3/lib/hash.c": {
    "hash_get_n_buckets": {
      "start_point": [
        148,
        0
      ],
      "end_point": [
        152,
        1
      ],
      "content": "size_t\nhash_get_n_buckets (const Hash_table *table)\n{\n  return table->n_buckets;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "size_t"
      ]
    },
    "hash_get_n_buckets_used": {
      "start_point": [
        156,
        0
      ],
      "end_point": [
        160,
        1
      ],
      "content": "size_t\nhash_get_n_buckets_used (const Hash_table *table)\n{\n  return table->n_buckets_used;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "size_t"
      ]
    },
    "hash_get_n_entries": {
      "start_point": [
        164,
        0
      ],
      "end_point": [
        168,
        1
      ],
      "content": "size_t\nhash_get_n_entries (const Hash_table *table)\n{\n  return table->n_entries;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "size_t"
      ]
    },
    "hash_get_max_bucket_length": {
      "start_point": [
        172,
        0
      ],
      "end_point": [
        194,
        1
      ],
      "content": "size_t\nhash_get_max_bucket_length (const Hash_table *table)\n{\n  struct hash_entry const *bucket;\n  size_t max_bucket_length = 0;\n\n  for (bucket = table->bucket; bucket < table->bucket_limit; bucket++)\n    {\n      if (bucket->data)\n        {\n          struct hash_entry const *cursor = bucket;\n          size_t bucket_length = 1;\n\n          while (cursor = cursor->next, cursor)\n            bucket_length++;\n\n          if (bucket_length > max_bucket_length)\n            max_bucket_length = bucket_length;\n        }\n    }\n\n  return max_bucket_length;\n}",
      "lines": 23,
      "depth": 12,
      "decorators": [
        "size_t"
      ]
    },
    "hash_table_ok": {
      "start_point": [
        199,
        0
      ],
      "end_point": [
        226,
        1
      ],
      "content": "bool\nhash_table_ok (const Hash_table *table)\n{\n  struct hash_entry const *bucket;\n  size_t n_buckets_used = 0;\n  size_t n_entries = 0;\n\n  for (bucket = table->bucket; bucket < table->bucket_limit; bucket++)\n    {\n      if (bucket->data)\n        {\n          struct hash_entry const *cursor = bucket;\n\n          /* Count bucket head.  */\n          n_buckets_used++;\n          n_entries++;\n\n          /* Count bucket overflow.  */\n          while (cursor = cursor->next, cursor)\n            n_entries++;\n        }\n    }\n\n  if (n_buckets_used == table->n_buckets_used && n_entries == table->n_entries)\n    return true;\n\n  return false;\n}",
      "lines": 28,
      "depth": 12,
      "decorators": [
        "bool"
      ]
    },
    "hash_print_statistics": {
      "start_point": [
        228,
        0
      ],
      "end_point": [
        243,
        1
      ],
      "content": "void\nhash_print_statistics (const Hash_table *table, FILE *stream)\n{\n  size_t n_entries = hash_get_n_entries (table);\n  size_t n_buckets = hash_get_n_buckets (table);\n  size_t n_buckets_used = hash_get_n_buckets_used (table);\n  size_t max_bucket_length = hash_get_max_bucket_length (table);\n\n  fprintf (stream, \"# entries:         %lu\\n\", (unsigned long int) n_entries);\n  fprintf (stream, \"# buckets:         %lu\\n\", (unsigned long int) n_buckets);\n  fprintf (stream, \"# buckets used:    %lu (%.2f%%)\\n\",\n           (unsigned long int) n_buckets_used,\n           (100.0 * n_buckets_used) / n_buckets);\n  fprintf (stream, \"max bucket length: %lu\\n\",\n           (unsigned long int) max_bucket_length);\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "safe_hasher": {
      "start_point": [
        247,
        0
      ],
      "end_point": [
        254,
        1
      ],
      "content": "static struct hash_entry *\nsafe_hasher (const Hash_table *table, const void *key)\n{\n  size_t n = table->hasher (key, table->n_buckets);\n  if (! (n < table->n_buckets))\n    abort ();\n  return table->bucket + n;\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "struct hash_entry",
        "struct",
        "hash_entry",
        "*\nsafe_hasher (const Hash_table *table, const void *key)",
        "*"
      ]
    },
    "hash_lookup": {
      "start_point": [
        259,
        0
      ],
      "end_point": [
        273,
        1
      ],
      "content": "void *\nhash_lookup (const Hash_table *table, const void *entry)\n{\n  struct hash_entry const *bucket = safe_hasher (table, entry);\n  struct hash_entry const *cursor;\n\n  if (bucket->data == NULL)\n    return NULL;\n\n  for (cursor = bucket; cursor; cursor = cursor->next)\n    if (entry == cursor->data || table->comparator (entry, cursor->data))\n      return cursor->data;\n\n  return NULL;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "void",
        "*\nhash_lookup (const Hash_table *table, const void *entry)",
        "*"
      ]
    },
    "hash_get_first": {
      "start_point": [
        286,
        0
      ],
      "end_point": [
        299,
        1
      ],
      "content": "void *\nhash_get_first (const Hash_table *table)\n{\n  struct hash_entry const *bucket;\n\n  if (table->n_entries == 0)\n    return NULL;\n\n  for (bucket = table->bucket; ; bucket++)\n    if (! (bucket < table->bucket_limit))\n      abort ();\n    else if (bucket->data)\n      return bucket->data;\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "void",
        "*\nhash_get_first (const Hash_table *table)",
        "*"
      ]
    },
    "hash_get_next": {
      "start_point": [
        305,
        0
      ],
      "end_point": [
        328,
        1
      ],
      "content": "void *\nhash_get_next (const Hash_table *table, const void *entry)\n{\n  struct hash_entry const *bucket = safe_hasher (table, entry);\n  struct hash_entry const *cursor;\n\n  /* Find next entry in the same bucket.  */\n  cursor = bucket;\n  do\n    {\n      if (cursor->data == entry && cursor->next)\n        return cursor->next->data;\n      cursor = cursor->next;\n    }\n  while (cursor != NULL);\n\n  /* Find first entry in any subsequent bucket.  */\n  while (++bucket < table->bucket_limit)\n    if (bucket->data)\n      return bucket->data;\n\n  /* None found.  */\n  return NULL;\n}",
      "lines": 24,
      "depth": 10,
      "decorators": [
        "void",
        "*\nhash_get_next (const Hash_table *table, const void *entry)",
        "*"
      ]
    },
    "hash_get_entries": {
      "start_point": [
        334,
        0
      ],
      "end_point": [
        356,
        1
      ],
      "content": "size_t\nhash_get_entries (const Hash_table *table, void **buffer,\n                  size_t buffer_size)\n{\n  size_t counter = 0;\n  struct hash_entry const *bucket;\n  struct hash_entry const *cursor;\n\n  for (bucket = table->bucket; bucket < table->bucket_limit; bucket++)\n    {\n      if (bucket->data)\n        {\n          for (cursor = bucket; cursor; cursor = cursor->next)\n            {\n              if (counter >= buffer_size)\n                return counter;\n              buffer[counter++] = cursor->data;\n            }\n        }\n    }\n\n  return counter;\n}",
      "lines": 23,
      "depth": 13,
      "decorators": [
        "size_t"
      ]
    },
    "hash_do_for_each": {
      "start_point": [
        366,
        0
      ],
      "end_point": [
        388,
        1
      ],
      "content": "size_t\nhash_do_for_each (const Hash_table *table, Hash_processor processor,\n                  void *processor_data)\n{\n  size_t counter = 0;\n  struct hash_entry const *bucket;\n  struct hash_entry const *cursor;\n\n  for (bucket = table->bucket; bucket < table->bucket_limit; bucket++)\n    {\n      if (bucket->data)\n        {\n          for (cursor = bucket; cursor; cursor = cursor->next)\n            {\n              if (! processor (cursor->data, processor_data))\n                return counter;\n              counter++;\n            }\n        }\n    }\n\n  return counter;\n}",
      "lines": 23,
      "depth": 15,
      "decorators": [
        "size_t"
      ]
    },
    "hash_string": [
      {
        "start_point": [
          403,
          0
        ],
        "end_point": [
          417,
          1
        ],
        "content": "size_t\nhash_string (const char *string, size_t n_buckets)\n{\n# define HASH_ONE_CHAR(Value, Byte) \\\n  ((Byte) + rotl_sz (Value, 7))\n\n  size_t value = 0;\n  unsigned char ch;\n\n  for (; (ch = *string); string++)\n    value = HASH_ONE_CHAR (value, ch);\n  return value % n_buckets;\n\n# undef HASH_ONE_CHAR\n}",
        "lines": 15,
        "depth": 8,
        "decorators": [
          "size_t"
        ]
      },
      {
        "start_point": [
          426,
          0
        ],
        "end_point": [
          435,
          1
        ],
        "content": "size_t\nhash_string (const char *string, size_t n_buckets)\n{\n  size_t value = 0;\n  unsigned char ch;\n\n  for (; (ch = *string); string++)\n    value = (value * 31 + ch) % n_buckets;\n  return value;\n}",
        "lines": 10,
        "depth": 10,
        "decorators": [
          "size_t"
        ]
      }
    ],
    "_GL_ATTRIBUTE_CONST": [
      {
        "start_point": [
          442,
          0
        ],
        "end_point": [
          456,
          1
        ],
        "content": "static bool _GL_ATTRIBUTE_CONST\nis_prime (size_t candidate)\n{\n  size_t divisor = 3;\n  size_t square = divisor * divisor;\n\n  while (square < candidate && (candidate % divisor))\n    {\n      divisor++;\n      square += 4 * divisor;\n      divisor++;\n    }\n\n  return (candidate % divisor ? true : false);\n}",
        "lines": 15,
        "depth": 8,
        "decorators": [
          "static",
          "static",
          "bool"
        ]
      },
      {
        "start_point": [
          461,
          0
        ],
        "end_point": [
          475,
          1
        ],
        "content": "static size_t _GL_ATTRIBUTE_CONST\nnext_prime (size_t candidate)\n{\n  /* Skip small primes.  */\n  if (candidate < 10)\n    candidate = 10;\n\n  /* Make it definitely odd.  */\n  candidate |= 1;\n\n  while (SIZE_MAX != candidate && !is_prime (candidate))\n    candidate += 2;\n\n  return candidate;\n}",
        "lines": 15,
        "depth": 9,
        "decorators": [
          "static",
          "static",
          "size_t"
        ]
      }
    ],
    "hash_reset_tuning": {
      "start_point": [
        477,
        0
      ],
      "end_point": [
        481,
        1
      ],
      "content": "void\nhash_reset_tuning (Hash_tuning *tuning)\n{\n  *tuning = default_tuning;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "raw_hasher": {
      "start_point": [
        484,
        0
      ],
      "end_point": [
        494,
        1
      ],
      "content": "static size_t\nraw_hasher (const void *data, size_t n)\n{\n  /* When hashing unique pointers, it is often the case that they were\n     generated by malloc and thus have the property that the low-order\n     bits are 0.  As this tends to give poorer performance with small\n     tables, we rotate the pointer value before performing division,\n     in an attempt to improve hash quality.  */\n  size_t val = rotr_sz ((size_t) data, 3);\n  return val % n;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "raw_comparator": {
      "start_point": [
        497,
        0
      ],
      "end_point": [
        501,
        1
      ],
      "content": "static bool\nraw_comparator (const void *a, const void *b)\n{\n  return a == b;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "check_tuning": {
      "start_point": [
        510,
        0
      ],
      "end_point": [
        536,
        1
      ],
      "content": "static bool\ncheck_tuning (Hash_table *table)\n{\n  const Hash_tuning *tuning = table->tuning;\n  float epsilon;\n  if (tuning == &default_tuning)\n    return true;\n\n  /* Be a bit stricter than mathematics would require, so that\n     rounding errors in size calculations do not cause allocations to\n     fail to grow or shrink as they should.  The smallest allocation\n     is 11 (due to next_prime's algorithm), so an epsilon of 0.1\n     should be good enough.  */\n  epsilon = 0.1f;\n\n  if (epsilon < tuning->growth_threshold\n      && tuning->growth_threshold < 1 - epsilon\n      && 1 + epsilon < tuning->growth_factor\n      && 0 <= tuning->shrink_threshold\n      && tuning->shrink_threshold + epsilon < tuning->shrink_factor\n      && tuning->shrink_factor <= 1\n      && tuning->shrink_threshold + epsilon < tuning->growth_threshold)\n    return true;\n\n  table->tuning = &default_tuning;\n  return false;\n}",
      "lines": 27,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "compute_bucket_size": {
      "start_point": [
        542,
        0
      ],
      "end_point": [
        556,
        1
      ],
      "content": "static size_t _GL_ATTRIBUTE_PURE\ncompute_bucket_size (size_t candidate, const Hash_tuning *tuning)\n{\n  if (!tuning->is_n_buckets)\n    {\n      float new_candidate = candidate / tuning->growth_threshold;\n      if (SIZE_MAX <= new_candidate)\n        return 0;\n      candidate = new_candidate;\n    }\n  candidate = next_prime (candidate);\n  if (xalloc_oversized (candidate, sizeof (struct hash_entry *)))\n    return 0;\n  return candidate;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "size_t",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "hash_initialize": {
      "start_point": [
        592,
        0
      ],
      "end_point": [
        645,
        1
      ],
      "content": "Hash_table *\nhash_initialize (size_t candidate, const Hash_tuning *tuning,\n                 Hash_hasher hasher, Hash_comparator comparator,\n                 Hash_data_freer data_freer)\n{\n  Hash_table *table;\n\n  if (hasher == NULL)\n    hasher = raw_hasher;\n  if (comparator == NULL)\n    comparator = raw_comparator;\n\n  table = malloc (sizeof *table);\n  if (table == NULL)\n    return NULL;\n\n  if (!tuning)\n    tuning = &default_tuning;\n  table->tuning = tuning;\n  if (!check_tuning (table))\n    {\n      /* Fail if the tuning options are invalid.  This is the only occasion\n         when the user gets some feedback about it.  Once the table is created,\n         if the user provides invalid tuning options, we silently revert to\n         using the defaults, and ignore further request to change the tuning\n         options.  */\n      goto fail;\n    }\n\n  table->n_buckets = compute_bucket_size (candidate, tuning);\n  if (!table->n_buckets)\n    goto fail;\n\n  table->bucket = calloc (table->n_buckets, sizeof *table->bucket);\n  if (table->bucket == NULL)\n    goto fail;\n  table->bucket_limit = table->bucket + table->n_buckets;\n  table->n_buckets_used = 0;\n  table->n_entries = 0;\n\n  table->hasher = hasher;\n  table->comparator = comparator;\n  table->data_freer = data_freer;\n\n  table->free_entry_list = NULL;\n#if USE_OBSTACK\n  obstack_init (&table->entry_stack);\n#endif\n  return table;\n\n fail:\n  free (table);\n  return NULL;\n}",
      "lines": 54,
      "depth": 10,
      "decorators": [
        "Hash_table",
        "*\nhash_initialize (size_t candidate, const Hash_tuning *tuning,\n                 Hash_hasher hasher, Hash_comparator comparator,\n                 Hash_data_freer data_freer)",
        "*"
      ]
    },
    "hash_clear": {
      "start_point": [
        651,
        0
      ],
      "end_point": [
        687,
        1
      ],
      "content": "void\nhash_clear (Hash_table *table)\n{\n  struct hash_entry *bucket;\n\n  for (bucket = table->bucket; bucket < table->bucket_limit; bucket++)\n    {\n      if (bucket->data)\n        {\n          struct hash_entry *cursor;\n          struct hash_entry *next;\n\n          /* Free the bucket overflow.  */\n          for (cursor = bucket->next; cursor; cursor = next)\n            {\n              if (table->data_freer)\n                table->data_freer (cursor->data);\n              cursor->data = NULL;\n\n              next = cursor->next;\n              /* Relinking is done one entry at a time, as it is to be expected\n                 that overflows are either rare or short.  */\n              cursor->next = table->free_entry_list;\n              table->free_entry_list = cursor;\n            }\n\n          /* Free the bucket head.  */\n          if (table->data_freer)\n            table->data_freer (bucket->data);\n          bucket->data = NULL;\n          bucket->next = NULL;\n        }\n    }\n\n  table->n_buckets_used = 0;\n  table->n_entries = 0;\n}",
      "lines": 37,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "hash_free": {
      "start_point": [
        694,
        0
      ],
      "end_point": [
        742,
        1
      ],
      "content": "void\nhash_free (Hash_table *table)\n{\n  struct hash_entry *bucket;\n  struct hash_entry *cursor;\n  struct hash_entry *next;\n\n  /* Call the user data_freer function.  */\n  if (table->data_freer && table->n_entries)\n    {\n      for (bucket = table->bucket; bucket < table->bucket_limit; bucket++)\n        {\n          if (bucket->data)\n            {\n              for (cursor = bucket; cursor; cursor = cursor->next)\n                table->data_freer (cursor->data);\n            }\n        }\n    }\n\n#if USE_OBSTACK\n\n  obstack_free (&table->entry_stack, NULL);\n\n#else\n\n  /* Free all bucket overflowed entries.  */\n  for (bucket = table->bucket; bucket < table->bucket_limit; bucket++)\n    {\n      for (cursor = bucket->next; cursor; cursor = next)\n        {\n          next = cursor->next;\n          free (cursor);\n        }\n    }\n\n  /* Also reclaim the internal list of previously freed entries.  */\n  for (cursor = table->free_entry_list; cursor; cursor = next)\n    {\n      next = cursor->next;\n      free (cursor);\n    }\n\n#endif\n\n  /* Free the remainder of the hash table structure.  */\n  free (table->bucket);\n  free (table);\n}",
      "lines": 49,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "allocate_entry": {
      "start_point": [
        749,
        0
      ],
      "end_point": [
        769,
        1
      ],
      "content": "static struct hash_entry *\nallocate_entry (Hash_table *table)\n{\n  struct hash_entry *new;\n\n  if (table->free_entry_list)\n    {\n      new = table->free_entry_list;\n      table->free_entry_list = new->next;\n    }\n  else\n    {\n#if USE_OBSTACK\n      new = obstack_alloc (&table->entry_stack, sizeof *new);\n#else\n      new = malloc (sizeof *new);\n#endif\n    }\n\n  return new;\n}",
      "lines": 21,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "struct hash_entry",
        "struct",
        "hash_entry",
        "*\nallocate_entry (Hash_table *table)",
        "*"
      ]
    },
    "free_entry": {
      "start_point": [
        774,
        0
      ],
      "end_point": [
        780,
        1
      ],
      "content": "static void\nfree_entry (Hash_table *table, struct hash_entry *entry)\n{\n  entry->data = NULL;\n  entry->next = table->free_entry_list;\n  table->free_entry_list = entry;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "hash_find_entry": {
      "start_point": [
        788,
        0
      ],
      "end_point": [
        850,
        1
      ],
      "content": "static void *\nhash_find_entry (Hash_table *table, const void *entry,\n                 struct hash_entry **bucket_head, bool delete)\n{\n  struct hash_entry *bucket = safe_hasher (table, entry);\n  struct hash_entry *cursor;\n\n  *bucket_head = bucket;\n\n  /* Test for empty bucket.  */\n  if (bucket->data == NULL)\n    return NULL;\n\n  /* See if the entry is the first in the bucket.  */\n  if (entry == bucket->data || table->comparator (entry, bucket->data))\n    {\n      void *data = bucket->data;\n\n      if (delete)\n        {\n          if (bucket->next)\n            {\n              struct hash_entry *next = bucket->next;\n\n              /* Bump the first overflow entry into the bucket head, then save\n                 the previous first overflow entry for later recycling.  */\n              *bucket = *next;\n              free_entry (table, next);\n            }\n          else\n            {\n              bucket->data = NULL;\n            }\n        }\n\n      return data;\n    }\n\n  /* Scan the bucket overflow.  */\n  for (cursor = bucket; cursor->next; cursor = cursor->next)\n    {\n      if (entry == cursor->next->data\n          || table->comparator (entry, cursor->next->data))\n        {\n          void *data = cursor->next->data;\n\n          if (delete)\n            {\n              struct hash_entry *next = cursor->next;\n\n              /* Unlink the entry to delete, then save the freed entry for later\n                 recycling.  */\n              cursor->next = next->next;\n              free_entry (table, next);\n            }\n\n          return data;\n        }\n    }\n\n  /* No entry found.  */\n  return NULL;\n}",
      "lines": 63,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nhash_find_entry (Hash_table *table, const void *entry,\n                 struct hash_entry **bucket_head, bool delete)",
        "*"
      ]
    },
    "transfer_entries": {
      "start_point": [
        858,
        0
      ],
      "end_point": [
        931,
        1
      ],
      "content": "static bool\ntransfer_entries (Hash_table *dst, Hash_table *src, bool safe)\n{\n  struct hash_entry *bucket;\n  struct hash_entry *cursor;\n  struct hash_entry *next;\n  for (bucket = src->bucket; bucket < src->bucket_limit; bucket++)\n    if (bucket->data)\n      {\n        void *data;\n        struct hash_entry *new_bucket;\n\n        /* Within each bucket, transfer overflow entries first and\n           then the bucket head, to minimize memory pressure.  After\n           all, the only time we might allocate is when moving the\n           bucket head, but moving overflow entries first may create\n           free entries that can be recycled by the time we finally\n           get to the bucket head.  */\n        for (cursor = bucket->next; cursor; cursor = next)\n          {\n            data = cursor->data;\n            new_bucket = safe_hasher (dst, data);\n\n            next = cursor->next;\n\n            if (new_bucket->data)\n              {\n                /* Merely relink an existing entry, when moving from a\n                   bucket overflow into a bucket overflow.  */\n                cursor->next = new_bucket->next;\n                new_bucket->next = cursor;\n              }\n            else\n              {\n                /* Free an existing entry, when moving from a bucket\n                   overflow into a bucket header.  */\n                new_bucket->data = data;\n                dst->n_buckets_used++;\n                free_entry (dst, cursor);\n              }\n          }\n        /* Now move the bucket head.  Be sure that if we fail due to\n           allocation failure that the src table is in a consistent\n           state.  */\n        data = bucket->data;\n        bucket->next = NULL;\n        if (safe)\n          continue;\n        new_bucket = safe_hasher (dst, data);\n\n        if (new_bucket->data)\n          {\n            /* Allocate or recycle an entry, when moving from a bucket\n               header into a bucket overflow.  */\n            struct hash_entry *new_entry = allocate_entry (dst);\n\n            if (new_entry == NULL)\n              return false;\n\n            new_entry->data = data;\n            new_entry->next = new_bucket->next;\n            new_bucket->next = new_entry;\n          }\n        else\n          {\n            /* Move from one bucket header to another.  */\n            new_bucket->data = data;\n            dst->n_buckets_used++;\n          }\n        bucket->data = NULL;\n        src->n_buckets_used--;\n      }\n  return true;\n}",
      "lines": 74,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "hash_rehash": {
      "start_point": [
        941,
        0
      ],
      "end_point": [
        1018,
        1
      ],
      "content": "bool\nhash_rehash (Hash_table *table, size_t candidate)\n{\n  Hash_table storage;\n  Hash_table *new_table;\n  size_t new_size = compute_bucket_size (candidate, table->tuning);\n\n  if (!new_size)\n    return false;\n  if (new_size == table->n_buckets)\n    return true;\n  new_table = &storage;\n  new_table->bucket = calloc (new_size, sizeof *new_table->bucket);\n  if (new_table->bucket == NULL)\n    return false;\n  new_table->n_buckets = new_size;\n  new_table->bucket_limit = new_table->bucket + new_size;\n  new_table->n_buckets_used = 0;\n  new_table->n_entries = 0;\n  new_table->tuning = table->tuning;\n  new_table->hasher = table->hasher;\n  new_table->comparator = table->comparator;\n  new_table->data_freer = table->data_freer;\n\n  /* In order for the transfer to successfully complete, we need\n     additional overflow entries when distinct buckets in the old\n     table collide into a common bucket in the new table.  The worst\n     case possible is a hasher that gives a good spread with the old\n     size, but returns a constant with the new size; if we were to\n     guarantee table->n_buckets_used-1 free entries in advance, then\n     the transfer would be guaranteed to not allocate memory.\n     However, for large tables, a guarantee of no further allocation\n     introduces a lot of extra memory pressure, all for an unlikely\n     corner case (most rehashes reduce, rather than increase, the\n     number of overflow entries needed).  So, we instead ensure that\n     the transfer process can be reversed if we hit a memory\n     allocation failure mid-transfer.  */\n\n  /* Merely reuse the extra old space into the new table.  */\n#if USE_OBSTACK\n  new_table->entry_stack = table->entry_stack;\n#endif\n  new_table->free_entry_list = table->free_entry_list;\n\n  if (transfer_entries (new_table, table, false))\n    {\n      /* Entries transferred successfully; tie up the loose ends.  */\n      free (table->bucket);\n      table->bucket = new_table->bucket;\n      table->bucket_limit = new_table->bucket_limit;\n      table->n_buckets = new_table->n_buckets;\n      table->n_buckets_used = new_table->n_buckets_used;\n      table->free_entry_list = new_table->free_entry_list;\n      /* table->n_entries and table->entry_stack already hold their value.  */\n      return true;\n    }\n\n  /* We've allocated new_table->bucket (and possibly some entries),\n     exhausted the free list, and moved some but not all entries into\n     new_table.  We must undo the partial move before returning\n     failure.  The only way to get into this situation is if new_table\n     uses fewer buckets than the old table, so we will reclaim some\n     free entries as overflows in the new table are put back into\n     distinct buckets in the old table.\n\n     There are some pathological cases where a single pass through the\n     table requires more intermediate overflow entries than using two\n     passes.  Two passes give worse cache performance and takes\n     longer, but at this point, we're already out of memory, so slow\n     and safe is better than failure.  */\n  table->free_entry_list = new_table->free_entry_list;\n  if (! (transfer_entries (table, new_table, true)\n         && transfer_entries (table, new_table, false)))\n    abort ();\n  /* table->n_entries already holds its value.  */\n  free (new_table->bucket);\n  return false;\n}",
      "lines": 78,
      "depth": 10,
      "decorators": [
        "bool"
      ]
    },
    "hash_insert_if_absent": {
      "start_point": [
        1036,
        0
      ],
      "end_point": [
        1116,
        1
      ],
      "content": "int\nhash_insert_if_absent (Hash_table *table, void const *entry,\n                       void const **matched_ent)\n{\n  void *data;\n  struct hash_entry *bucket;\n\n  /* The caller cannot insert a NULL entry, since hash_lookup returns NULL\n     to indicate \"not found\", and hash_find_entry uses \"bucket->data == NULL\"\n     to indicate an empty bucket.  */\n  if (! entry)\n    abort ();\n\n  /* If there's a matching entry already in the table, return that.  */\n  if ((data = hash_find_entry (table, entry, &bucket, false)) != NULL)\n    {\n      if (matched_ent)\n        *matched_ent = data;\n      return 0;\n    }\n\n  /* If the growth threshold of the buckets in use has been reached, increase\n     the table size and rehash.  There's no point in checking the number of\n     entries:  if the hashing function is ill-conditioned, rehashing is not\n     likely to improve it.  */\n\n  if (table->n_buckets_used\n      > table->tuning->growth_threshold * table->n_buckets)\n    {\n      /* Check more fully, before starting real work.  If tuning arguments\n         became invalid, the second check will rely on proper defaults.  */\n      check_tuning (table);\n      if (table->n_buckets_used\n          > table->tuning->growth_threshold * table->n_buckets)\n        {\n          const Hash_tuning *tuning = table->tuning;\n          float candidate =\n            (tuning->is_n_buckets\n             ? (table->n_buckets * tuning->growth_factor)\n             : (table->n_buckets * tuning->growth_factor\n                * tuning->growth_threshold));\n\n          if (SIZE_MAX <= candidate)\n            return -1;\n\n          /* If the rehash fails, arrange to return NULL.  */\n          if (!hash_rehash (table, candidate))\n            return -1;\n\n          /* Update the bucket we are interested in.  */\n          if (hash_find_entry (table, entry, &bucket, false) != NULL)\n            abort ();\n        }\n    }\n\n  /* ENTRY is not matched, it should be inserted.  */\n\n  if (bucket->data)\n    {\n      struct hash_entry *new_entry = allocate_entry (table);\n\n      if (new_entry == NULL)\n        return -1;\n\n      /* Add ENTRY in the overflow of the bucket.  */\n\n      new_entry->data = (void *) entry;\n      new_entry->next = bucket->next;\n      bucket->next = new_entry;\n      table->n_entries++;\n      return 1;\n    }\n\n  /* Add ENTRY right in the bucket head.  */\n\n  bucket->data = (void *) entry;\n  table->n_entries++;\n  table->n_buckets_used++;\n\n  return 1;\n}",
      "lines": 81,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "hash_insert": {
      "start_point": [
        1124,
        0
      ],
      "end_point": [
        1132,
        1
      ],
      "content": "void *\nhash_insert (Hash_table *table, void const *entry)\n{\n  void const *matched_ent;\n  int err = hash_insert_if_absent (table, entry, &matched_ent);\n  return (err == -1\n          ? NULL\n          : (void *) (err == 0 ? matched_ent : entry));\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "void",
        "*\nhash_insert (Hash_table *table, void const *entry)",
        "*"
      ]
    },
    "hash_delete": {
      "start_point": [
        1138,
        0
      ],
      "end_point": [
        1196,
        1
      ],
      "content": "void *\nhash_delete (Hash_table *table, const void *entry)\n{\n  void *data;\n  struct hash_entry *bucket;\n\n  data = hash_find_entry (table, entry, &bucket, true);\n  if (!data)\n    return NULL;\n\n  table->n_entries--;\n  if (!bucket->data)\n    {\n      table->n_buckets_used--;\n\n      /* If the shrink threshold of the buckets in use has been reached,\n         rehash into a smaller table.  */\n\n      if (table->n_buckets_used\n          < table->tuning->shrink_threshold * table->n_buckets)\n        {\n          /* Check more fully, before starting real work.  If tuning arguments\n             became invalid, the second check will rely on proper defaults.  */\n          check_tuning (table);\n          if (table->n_buckets_used\n              < table->tuning->shrink_threshold * table->n_buckets)\n            {\n              const Hash_tuning *tuning = table->tuning;\n              size_t candidate =\n                (tuning->is_n_buckets\n                 ? table->n_buckets * tuning->shrink_factor\n                 : (table->n_buckets * tuning->shrink_factor\n                    * tuning->growth_threshold));\n\n              if (!hash_rehash (table, candidate))\n                {\n                  /* Failure to allocate memory in an attempt to\n                     shrink the table is not fatal.  But since memory\n                     is low, we can at least be kind and free any\n                     spare entries, rather than keeping them tied up\n                     in the free entry list.  */\n#if ! USE_OBSTACK\n                  struct hash_entry *cursor = table->free_entry_list;\n                  struct hash_entry *next;\n                  while (cursor)\n                    {\n                      next = cursor->next;\n                      free (cursor);\n                      cursor = next;\n                    }\n                  table->free_entry_list = NULL;\n#endif\n                }\n            }\n        }\n    }\n\n  return data;\n}",
      "lines": 59,
      "depth": 17,
      "decorators": [
        "void",
        "*\nhash_delete (Hash_table *table, const void *entry)",
        "*"
      ]
    },
    "hash_print": {
      "start_point": [
        1202,
        0
      ],
      "end_point": [
        1222,
        1
      ],
      "content": "void\nhash_print (const Hash_table *table)\n{\n  struct hash_entry *bucket = (struct hash_entry *) table->bucket;\n\n  for ( ; bucket < table->bucket_limit; bucket++)\n    {\n      struct hash_entry *cursor;\n\n      if (bucket)\n        printf (\"%lu:\\n\", (unsigned long int) (bucket - table->bucket));\n\n      for (cursor = bucket; cursor; cursor = cursor->next)\n        {\n          char const *s = cursor->data;\n          /* FIXME */\n          if (s)\n            printf (\"  %s\\n\", s);\n        }\n    }\n}",
      "lines": 21,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "datamash/datamash-1.3/lib/hash.h": {},
  "datamash/datamash-1.3/lib/iconv.c": {
    "utf16be_mbtowc": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        81,
        1
      ],
      "content": "static int\nutf16be_mbtowc (ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  if (n >= 2)\n    {\n      ucs4_t wc = (s[0] << 8) + s[1];\n      if (wc >= 0xd800 && wc < 0xdc00)\n        {\n          if (n >= 4)\n            {\n              ucs4_t wc2 = (s[2] << 8) + s[3];\n              if (!(wc2 >= 0xdc00 && wc2 < 0xe000))\n                return RET_ILSEQ;\n              *pwc = 0x10000 + ((wc - 0xd800) << 10) + (wc2 - 0xdc00);\n              return 4;\n            }\n        }\n      else if (wc >= 0xdc00 && wc < 0xe000)\n        {\n          return RET_ILSEQ;\n        }\n      else\n        {\n          *pwc = wc;\n          return 2;\n        }\n    }\n  return RET_TOOFEW;\n}",
      "lines": 29,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "utf16be_wctomb": {
      "start_point": [
        83,
        0
      ],
      "end_point": [
        116,
        1
      ],
      "content": "static int\nutf16be_wctomb (unsigned char *r, ucs4_t wc, size_t n)\n{\n  if (!(wc >= 0xd800 && wc < 0xe000))\n    {\n      if (wc < 0x10000)\n        {\n          if (n >= 2)\n            {\n              r[0] = (unsigned char) (wc >> 8);\n              r[1] = (unsigned char) wc;\n              return 2;\n            }\n          else\n            return RET_TOOSMALL;\n        }\n      else if (wc < 0x110000)\n        {\n          if (n >= 4)\n            {\n              ucs4_t wc1 = 0xd800 + ((wc - 0x10000) >> 10);\n              ucs4_t wc2 = 0xdc00 + ((wc - 0x10000) & 0x3ff);\n              r[0] = (unsigned char) (wc1 >> 8);\n              r[1] = (unsigned char) wc1;\n              r[2] = (unsigned char) (wc2 >> 8);\n              r[3] = (unsigned char) wc2;\n              return 4;\n            }\n          else\n            return RET_TOOSMALL;\n        }\n    }\n  return RET_ILUNI;\n}",
      "lines": 34,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "utf16le_mbtowc": {
      "start_point": [
        124,
        0
      ],
      "end_point": [
        152,
        1
      ],
      "content": "static int\nutf16le_mbtowc (ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  if (n >= 2)\n    {\n      ucs4_t wc = s[0] + (s[1] << 8);\n      if (wc >= 0xd800 && wc < 0xdc00)\n        {\n          if (n >= 4)\n            {\n              ucs4_t wc2 = s[2] + (s[3] << 8);\n              if (!(wc2 >= 0xdc00 && wc2 < 0xe000))\n                return RET_ILSEQ;\n              *pwc = 0x10000 + ((wc - 0xd800) << 10) + (wc2 - 0xdc00);\n              return 4;\n            }\n        }\n      else if (wc >= 0xdc00 && wc < 0xe000)\n        {\n          return RET_ILSEQ;\n        }\n      else\n        {\n          *pwc = wc;\n          return 2;\n        }\n    }\n  return RET_TOOFEW;\n}",
      "lines": 29,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "utf16le_wctomb": {
      "start_point": [
        154,
        0
      ],
      "end_point": [
        187,
        1
      ],
      "content": "static int\nutf16le_wctomb (unsigned char *r, ucs4_t wc, size_t n)\n{\n  if (!(wc >= 0xd800 && wc < 0xe000))\n    {\n      if (wc < 0x10000)\n        {\n          if (n >= 2)\n            {\n              r[0] = (unsigned char) wc;\n              r[1] = (unsigned char) (wc >> 8);\n              return 2;\n            }\n          else\n            return RET_TOOSMALL;\n        }\n      else if (wc < 0x110000)\n        {\n          if (n >= 4)\n            {\n              ucs4_t wc1 = 0xd800 + ((wc - 0x10000) >> 10);\n              ucs4_t wc2 = 0xdc00 + ((wc - 0x10000) & 0x3ff);\n              r[0] = (unsigned char) wc1;\n              r[1] = (unsigned char) (wc1 >> 8);\n              r[2] = (unsigned char) wc2;\n              r[3] = (unsigned char) (wc2 >> 8);\n              return 4;\n            }\n          else\n            return RET_TOOSMALL;\n        }\n    }\n  return RET_ILUNI;\n}",
      "lines": 34,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "utf32be_mbtowc": {
      "start_point": [
        195,
        0
      ],
      "end_point": [
        210,
        1
      ],
      "content": "static int\nutf32be_mbtowc (ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  if (n >= 4)\n    {\n      ucs4_t wc = (s[0] << 24) + (s[1] << 16) + (s[2] << 8) + s[3];\n      if (wc < 0x110000 && !(wc >= 0xd800 && wc < 0xe000))\n        {\n          *pwc = wc;\n          return 4;\n        }\n      else\n        return RET_ILSEQ;\n    }\n  return RET_TOOFEW;\n}",
      "lines": 16,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "utf32be_wctomb": {
      "start_point": [
        212,
        0
      ],
      "end_point": [
        229,
        1
      ],
      "content": "static int\nutf32be_wctomb (unsigned char *r, ucs4_t wc, size_t n)\n{\n  if (wc < 0x110000 && !(wc >= 0xd800 && wc < 0xe000))\n    {\n      if (n >= 4)\n        {\n          r[0] = 0;\n          r[1] = (unsigned char) (wc >> 16);\n          r[2] = (unsigned char) (wc >> 8);\n          r[3] = (unsigned char) wc;\n          return 4;\n        }\n      else\n        return RET_TOOSMALL;\n    }\n  return RET_ILUNI;\n}",
      "lines": 18,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "utf32le_mbtowc": {
      "start_point": [
        237,
        0
      ],
      "end_point": [
        252,
        1
      ],
      "content": "static int\nutf32le_mbtowc (ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  if (n >= 4)\n    {\n      ucs4_t wc = s[0] + (s[1] << 8) + (s[2] << 16) + (s[3] << 24);\n      if (wc < 0x110000 && !(wc >= 0xd800 && wc < 0xe000))\n        {\n          *pwc = wc;\n          return 4;\n        }\n      else\n        return RET_ILSEQ;\n    }\n  return RET_TOOFEW;\n}",
      "lines": 16,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "utf32le_wctomb": {
      "start_point": [
        254,
        0
      ],
      "end_point": [
        271,
        1
      ],
      "content": "static int\nutf32le_wctomb (unsigned char *r, ucs4_t wc, size_t n)\n{\n  if (wc < 0x110000 && !(wc >= 0xd800 && wc < 0xe000))\n    {\n      if (n >= 4)\n        {\n          r[0] = (unsigned char) wc;\n          r[1] = (unsigned char) (wc >> 8);\n          r[2] = (unsigned char) (wc >> 16);\n          r[3] = 0;\n          return 4;\n        }\n      else\n        return RET_TOOSMALL;\n    }\n  return RET_ILUNI;\n}",
      "lines": 18,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "datamash/datamash-1.3/lib/iconv.in.h": {},
  "datamash/datamash-1.3/lib/iconv_close.c": {},
  "datamash/datamash-1.3/lib/iconv_open-aix.h": {
    "mapping_hash": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        81,
        1
      ],
      "content": "static unsigned int\nmapping_hash (register const char *str, register unsigned int len)\n{\n  static const unsigned char asso_values[] =\n    {\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n      45, 45, 45, 45, 45, 45, 45,  0,  4, 25,\n       0, 11, 24,  9, 17,  3, 14, 21, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n       3, 45,  1, 45, 45, 45, 45,  0, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n      45, 45, 45, 45, 45, 45, 45, 45\n    };\n  return len + asso_values[(unsigned char)str[3]+2] + asso_values[(unsigned char)str[len - 1]];\n}",
      "lines": 34,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "unsigned int",
        "unsigned",
        "int"
      ]
    },
    "mapping_lookup": {
      "start_point": [
        235,
        0
      ],
      "end_point": [
        255,
        1
      ],
      "content": "const struct mapping *\nmapping_lookup (register const char *str, register unsigned int len)\n{\n  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)\n    {\n      register int key = mapping_hash (str, len);\n\n      if (key <= MAX_HASH_VALUE && key >= 0)\n        {\n          register int o = mappings[key].standard_name;\n          if (o >= 0)\n            {\n              register const char *s = o + stringpool;\n\n              if (*str == *s && !strcmp (str + 1, s + 1))\n                return &mappings[key];\n            }\n        }\n    }\n  return 0;\n}",
      "lines": 21,
      "depth": 16,
      "decorators": [
        "const",
        "const",
        "struct mapping",
        "struct",
        "mapping",
        "*\nmapping_lookup (register const char *str, register unsigned int len)",
        "*"
      ]
    }
  },
  "datamash/datamash-1.3/lib/iconv_open-hpux.h": {
    "mapping_hash": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        81,
        1
      ],
      "content": "static unsigned int\nmapping_hash (register const char *str, register unsigned int len)\n{\n  static const unsigned char asso_values[] =\n    {\n      50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n      50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n      50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n      50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n      50, 50, 50, 50, 50, 50, 50, 50,  1,  2,\n      24, 43,  5, 10,  0, 13, 32,  3, 19, 18,\n      50, 50, 50, 50, 50, 50, 50, 50, 50,  5,\n      50, 50, 50, 50, 14,  5,  0, 50, 50,  0,\n      27, 50, 12, 14, 50, 50,  0,  5,  2, 50,\n      50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n      50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n      50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n      50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n      50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n      50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n      50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n      50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n      50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n      50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n      50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n      50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n      50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n      50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n      50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n      50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n      50, 50, 50, 50, 50, 50, 50, 50, 50, 50\n    };\n  return len + asso_values[(unsigned char)str[3]+4] + asso_values[(unsigned char)str[len - 1]];\n}",
      "lines": 34,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "unsigned int",
        "unsigned",
        "int"
      ]
    },
    "mapping_lookup": {
      "start_point": [
        278,
        0
      ],
      "end_point": [
        298,
        1
      ],
      "content": "const struct mapping *\nmapping_lookup (register const char *str, register unsigned int len)\n{\n  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)\n    {\n      register int key = mapping_hash (str, len);\n\n      if (key <= MAX_HASH_VALUE && key >= 0)\n        {\n          register int o = mappings[key].standard_name;\n          if (o >= 0)\n            {\n              register const char *s = o + stringpool;\n\n              if (*str == *s && !strcmp (str + 1, s + 1))\n                return &mappings[key];\n            }\n        }\n    }\n  return 0;\n}",
      "lines": 21,
      "depth": 16,
      "decorators": [
        "const",
        "const",
        "struct mapping",
        "struct",
        "mapping",
        "*\nmapping_lookup (register const char *str, register unsigned int len)",
        "*"
      ]
    }
  },
  "datamash/datamash-1.3/lib/iconv_open-irix.h": {
    "mapping_hash": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        81,
        1
      ],
      "content": "static unsigned int\nmapping_hash (register const char *str, register unsigned int len)\n{\n  static const unsigned char asso_values[] =\n    {\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n      24, 24, 24, 24, 24, 24, 24, 24,  8,  2,\n       5, 12, 11,  0, 10,  9,  8,  7, 24, 24,\n      24, 24, 24, 24, 24, 24, 24,  0, 24,  0,\n      24,  5, 24,  0, 24,  7, 24, 24, 24, 24,\n       7, 24,  1,  0,  8, 24, 24,  0, 24, 24,\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n      24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n      24, 24, 24, 24, 24, 24\n    };\n  return len + asso_values[(unsigned char)str[len - 1]] + asso_values[(unsigned char)str[0]];\n}",
      "lines": 34,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "unsigned int",
        "unsigned",
        "int"
      ]
    },
    "mapping_lookup": {
      "start_point": [
        178,
        0
      ],
      "end_point": [
        198,
        1
      ],
      "content": "const struct mapping *\nmapping_lookup (register const char *str, register unsigned int len)\n{\n  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)\n    {\n      register int key = mapping_hash (str, len);\n\n      if (key <= MAX_HASH_VALUE && key >= 0)\n        {\n          register int o = mappings[key].standard_name;\n          if (o >= 0)\n            {\n              register const char *s = o + stringpool;\n\n              if (*str == *s && !strcmp (str + 1, s + 1))\n                return &mappings[key];\n            }\n        }\n    }\n  return 0;\n}",
      "lines": 21,
      "depth": 16,
      "decorators": [
        "const",
        "const",
        "struct mapping",
        "struct",
        "mapping",
        "*\nmapping_lookup (register const char *str, register unsigned int len)",
        "*"
      ]
    }
  },
  "datamash/datamash-1.3/lib/iconv_open-osf.h": {
    "mapping_hash": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        81,
        1
      ],
      "content": "static unsigned int\nmapping_hash (register const char *str, register unsigned int len)\n{\n  static const unsigned char asso_values[] =\n    {\n      48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n      48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n      48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n      48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n      48, 48, 48, 48, 48, 48, 48, 48,  2, 29,\n      24, 34, 31,  0, 15, 14, 10, 13,  2, 48,\n      48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n      48, 48, 48,  7, 48, 48, 48, 48, 48, 48,\n      11, 48,  2,  7, 48, 48, 48,  1, 48, 48,\n      48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n      48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n      48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n      48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n      48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n      48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n      48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n      48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n      48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n      48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n      48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n      48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n      48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n      48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n      48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n      48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n      48, 48, 48, 48, 48, 48, 48, 48, 48\n    };\n  return len + asso_values[(unsigned char)str[3]+3] + asso_values[(unsigned char)str[len - 1]];\n}",
      "lines": 34,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "unsigned int",
        "unsigned",
        "int"
      ]
    },
    "mapping_lookup": {
      "start_point": [
        257,
        0
      ],
      "end_point": [
        277,
        1
      ],
      "content": "const struct mapping *\nmapping_lookup (register const char *str, register unsigned int len)\n{\n  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)\n    {\n      register int key = mapping_hash (str, len);\n\n      if (key <= MAX_HASH_VALUE && key >= 0)\n        {\n          register int o = mappings[key].standard_name;\n          if (o >= 0)\n            {\n              register const char *s = o + stringpool;\n\n              if (*str == *s && !strcmp (str + 1, s + 1))\n                return &mappings[key];\n            }\n        }\n    }\n  return 0;\n}",
      "lines": 21,
      "depth": 16,
      "decorators": [
        "const",
        "const",
        "struct mapping",
        "struct",
        "mapping",
        "*\nmapping_lookup (register const char *str, register unsigned int len)",
        "*"
      ]
    }
  },
  "datamash/datamash-1.3/lib/iconv_open-solaris.h": {
    "mapping_hash": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        95,
        1
      ],
      "content": "static unsigned int\nmapping_hash (register const char *str, register unsigned int len)\n{\n  static const unsigned char asso_values[] =\n    {\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20,  0,\n       9,  8,  7,  6,  5,  4,  3,  2, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      20, 20, 20, 20, 20, 20\n    };\n  register int hval = len;\n\n  switch (hval)\n    {\n      default:\n        hval += asso_values[(unsigned char)str[9]];\n      /*FALLTHROUGH*/\n      case 9:\n      case 8:\n      case 7:\n      case 6:\n      case 5:\n        break;\n    }\n  return hval;\n}",
      "lines": 48,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "unsigned int",
        "unsigned",
        "int"
      ]
    },
    "mapping_lookup": {
      "start_point": [
        169,
        0
      ],
      "end_point": [
        189,
        1
      ],
      "content": "const struct mapping *\nmapping_lookup (register const char *str, register unsigned int len)\n{\n  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)\n    {\n      register int key = mapping_hash (str, len);\n\n      if (key <= MAX_HASH_VALUE && key >= 0)\n        {\n          register int o = mappings[key].standard_name;\n          if (o >= 0)\n            {\n              register const char *s = o + stringpool;\n\n              if (*str == *s && !strcmp (str + 1, s + 1))\n                return &mappings[key];\n            }\n        }\n    }\n  return 0;\n}",
      "lines": 21,
      "depth": 16,
      "decorators": [
        "const",
        "const",
        "struct mapping",
        "struct",
        "mapping",
        "*\nmapping_lookup (register const char *str, register unsigned int len)",
        "*"
      ]
    }
  },
  "datamash/datamash-1.3/lib/iconv_open.c": {},
  "datamash/datamash-1.3/lib/ignore-value.h": {},
  "datamash/datamash-1.3/lib/imaxtostr.c": {},
  "datamash/datamash-1.3/lib/intprops.h": {},
  "datamash/datamash-1.3/lib/inttostr.c": {},
  "datamash/datamash-1.3/lib/inttostr.h": {},
  "datamash/datamash-1.3/lib/inttypes.in.h": {},
  "datamash/datamash-1.3/lib/isblank.c": {
    "isblank": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        32,
        1
      ],
      "content": "int\nisblank (int c)\n{\n  /* On all known platforms, in all predefined locales, isblank(c) is likely\n     equivalent with  (c == ' ' || c == '\\t').  Look at the glibc definition\n     (in glibc/localedata/locales/i18n): The \"blank\" characters are '\\t', ' ',\n     U+1680, U+180E, U+2000..U+2006, U+2008..U+200A, U+205F, U+3000, and none\n     except the first two is present in a common 8-bit encoding.  Therefore\n     the substitute for other platforms is not more complicated than this.  */\n  return (c == ' ' || c == '\\t');\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "datamash/datamash-1.3/lib/isfinite.c": {
    "gl_isfinitef": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "int gl_isfinitef (float x)\n{\n  return !isnanf (x) && x - x == zerof;\n}",
      "lines": 4,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "gl_isfinited": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "int gl_isfinited (double x)\n{\n  return !isnand (x) && x - x == zerod;\n}",
      "lines": 4,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "gl_isfinitel": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "int gl_isfinitel (long double x)\n{\n  return !isnanl (x) && x - x == zerol;\n}",
      "lines": 4,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "datamash/datamash-1.3/lib/isinf.c": {
    "gl_isinff": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        26,
        1
      ],
      "content": "int\ngl_isinff (float x)\n{\n  return x < -FLT_MAX || x > FLT_MAX;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "gl_isinfd": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        32,
        1
      ],
      "content": "int\ngl_isinfd (double x)\n{\n  return x < -DBL_MAX || x > DBL_MAX;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "gl_isinfl": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "int\ngl_isinfl (long double x)\n{\n  return x < -LDBL_MAX || x > LDBL_MAX;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "datamash/datamash-1.3/lib/isnan.c": {
    "FUNC": {
      "start_point": [
        92,
        0
      ],
      "end_point": [
        188,
        1
      ],
      "content": "int\nFUNC (DOUBLE x)\n{\n#if defined KNOWN_EXPBIT0_LOCATION && IEEE_FLOATING_POINT\n# if defined USE_LONG_DOUBLE && ((defined __ia64 && LDBL_MANT_DIG == 64) || (defined __x86_64__ || defined __amd64__) || (defined __i386 || defined __i386__ || defined _I386 || defined _M_IX86 || defined _X86_)) && !HAVE_SAME_LONG_DOUBLE_AS_DOUBLE\n  /* Special CPU dependent code is needed to treat bit patterns outside the\n     IEEE 754 specification (such as Pseudo-NaNs, Pseudo-Infinities,\n     Pseudo-Zeroes, Unnormalized Numbers, and Pseudo-Denormals) as NaNs.\n     These bit patterns are:\n       - exponent = 0x0001..0x7FFF, mantissa bit 63 = 0,\n       - exponent = 0x0000, mantissa bit 63 = 1.\n     The NaN bit pattern is:\n       - exponent = 0x7FFF, mantissa >= 0x8000000000000001.  */\n  memory_double m;\n  unsigned int exponent;\n\n  m.value = x;\n  exponent = (m.word[EXPBIT0_WORD] >> EXPBIT0_BIT) & EXP_MASK;\n#  ifdef WORDS_BIGENDIAN\n  /* Big endian: EXPBIT0_WORD = 0, EXPBIT0_BIT = 16.  */\n  if (exponent == 0)\n    return 1 & (m.word[0] >> 15);\n  else if (exponent == EXP_MASK)\n    return (((m.word[0] ^ 0x8000U) << 16) | m.word[1] | (m.word[2] >> 16)) != 0;\n  else\n    return 1 & ~(m.word[0] >> 15);\n#  else\n  /* Little endian: EXPBIT0_WORD = 2, EXPBIT0_BIT = 0.  */\n  if (exponent == 0)\n    return (m.word[1] >> 31);\n  else if (exponent == EXP_MASK)\n    return ((m.word[1] ^ 0x80000000U) | m.word[0]) != 0;\n  else\n    return (m.word[1] >> 31) ^ 1;\n#  endif\n# else\n  /* Be careful to not do any floating-point operation on x, such as x == x,\n     because x may be a signaling NaN.  */\n#  if defined __SUNPRO_C || defined __ICC || defined _MSC_VER \\\n      || defined __DECC || defined __TINYC__ \\\n      || (defined __sgi && !defined __GNUC__)\n  /* The Sun C 5.0, Intel ICC 10.0, Microsoft Visual C/C++ 9.0, Compaq (ex-DEC)\n     6.4, and TinyCC compilers don't recognize the initializers as constant\n     expressions.  The Compaq compiler also fails when constant-folding\n     0.0 / 0.0 even when constant-folding is not required.  The Microsoft\n     Visual C/C++ compiler also fails when constant-folding 1.0 / 0.0 even\n     when constant-folding is not required. The SGI MIPSpro C compiler\n     complains about \"floating-point operation result is out of range\".  */\n  static DOUBLE zero = L_(0.0);\n  memory_double nan;\n  DOUBLE plus_inf = L_(1.0) / zero;\n  DOUBLE minus_inf = -L_(1.0) / zero;\n  nan.value = zero / zero;\n#  else\n  static memory_double nan = { L_(0.0) / L_(0.0) };\n  static DOUBLE plus_inf = L_(1.0) / L_(0.0);\n  static DOUBLE minus_inf = -L_(1.0) / L_(0.0);\n#  endif\n  {\n    memory_double m;\n\n    /* A NaN can be recognized through its exponent.  But exclude +Infinity and\n       -Infinity, which have the same exponent.  */\n    m.value = x;\n    if (((m.word[EXPBIT0_WORD] ^ nan.word[EXPBIT0_WORD])\n         & (EXP_MASK << EXPBIT0_BIT))\n        == 0)\n      return (memcmp (&m.value, &plus_inf, SIZE) != 0\n              && memcmp (&m.value, &minus_inf, SIZE) != 0);\n    else\n      return 0;\n  }\n# endif\n#else\n  /* The configuration did not find sufficient information, or does\n     not use IEEE floating point.  Give up about the signaling NaNs;\n     handle only the quiet NaNs.  */\n  if (x == x)\n    {\n# if defined USE_LONG_DOUBLE && ((defined __ia64 && LDBL_MANT_DIG == 64) || (defined __x86_64__ || defined __amd64__) || (defined __i386 || defined __i386__ || defined _I386 || defined _M_IX86 || defined _X86_)) && !HAVE_SAME_LONG_DOUBLE_AS_DOUBLE\n      /* Detect any special bit patterns that pass ==; see comment above.  */\n      memory_double m1;\n      memory_double m2;\n\n      memset (&m1.value, 0, SIZE);\n      memset (&m2.value, 0, SIZE);\n      m1.value = x;\n      m2.value = x + (x ? 0.0L : -0.0L);\n      if (memcmp (&m1.value, &m2.value, SIZE) != 0)\n        return 1;\n# endif\n      return 0;\n    }\n  else\n    return 1;\n#endif\n}",
      "lines": 97,
      "depth": 19,
      "decorators": [
        "int"
      ]
    }
  },
  "datamash/datamash-1.3/lib/isnand-nolibm.h": {},
  "datamash/datamash-1.3/lib/isnand.c": {},
  "datamash/datamash-1.3/lib/isnanf-nolibm.h": {},
  "datamash/datamash-1.3/lib/isnanf.c": {},
  "datamash/datamash-1.3/lib/isnanl-nolibm.h": {},
  "datamash/datamash-1.3/lib/isnanl.c": {},
  "datamash/datamash-1.3/lib/iswblank.c": {
    "iswblank": {
      "start_point": [
        21,
        0
      ],
      "end_point": [
        25,
        1
      ],
      "content": "int\niswblank (wint_t wc)\n{\n  return wc == ' ' || wc == '\\t';\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "datamash/datamash-1.3/lib/itold.c": {
    "_Qp_itoq": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        27,
        1
      ],
      "content": "void\n_Qp_itoq (long double *result, int a)\n{\n  /* Convert from 'int' to 'double', then from 'double' to 'long double'.  */\n  *result = (double) a;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "datamash/datamash-1.3/lib/ldexpl.c": {
    "ldexpl": [
      {
        "start_point": [
          27,
          0
        ],
        "end_point": [
          31,
          1
        ],
        "content": "long double\nldexpl (long double x, int exp)\n{\n  return ldexp (x, exp);\n}",
        "lines": 5,
        "depth": 6,
        "decorators": [
          "long double",
          "long",
          "double"
        ]
      },
      {
        "start_point": [
          38,
          0
        ],
        "end_point": [
          75,
          1
        ],
        "content": "long double\nldexpl (long double x, int exp)\n{\n  long double factor;\n  int bit;\n  DECL_LONG_DOUBLE_ROUNDING\n\n  BEGIN_LONG_DOUBLE_ROUNDING ();\n\n  /* Check for zero, nan and infinity. */\n  if (!(isnanl (x) || x + x == x))\n    {\n      if (exp < 0)\n        {\n          exp = -exp;\n          factor = 0.5L;\n        }\n      else\n        factor = 2.0L;\n\n      if (exp > 0)\n        for (bit = 1;;)\n          {\n            /* Invariant: Here bit = 2^i, factor = 2^-2^i or = 2^2^i,\n               and bit <= exp.  */\n            if (exp & bit)\n              x *= factor;\n            bit <<= 1;\n            if (bit > exp)\n              break;\n            factor = factor * factor;\n          }\n    }\n\n  END_LONG_DOUBLE_ROUNDING ();\n\n  return x;\n}",
        "lines": 38,
        "depth": 11,
        "decorators": [
          "long double",
          "long",
          "double"
        ]
      }
    ],
    "main": {
      "start_point": [
        80,
        0
      ],
      "end_point": [
        87,
        1
      ],
      "content": "int\nmain (void)\n{\n  long double x;\n  int y;\n  for (y = 0; y < 29; y++)\n    printf (\"%5d %.16Lg %.16Lg\\n\", y, ldexpl (0.8L, y), ldexpl (0.8L, -y) * ldexpl (0.8L, y));\n}",
      "lines": 8,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "datamash/datamash-1.3/lib/limits.in.h": {},
  "datamash/datamash-1.3/lib/linebuffer.c": {
    "initbuffer": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        39,
        1
      ],
      "content": "void\ninitbuffer (struct linebuffer *linebuffer)\n{\n  memset (linebuffer, 0, sizeof *linebuffer);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "readlinebuffer": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "struct linebuffer *\nreadlinebuffer (struct linebuffer *linebuffer, FILE *stream)\n{\n  return readlinebuffer_delim (linebuffer, stream, '\\n');\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "struct linebuffer",
        "struct",
        "linebuffer",
        "*\nreadlinebuffer (struct linebuffer *linebuffer, FILE *stream)",
        "*"
      ]
    },
    "readlinebuffer_delim": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "struct linebuffer *\nreadlinebuffer_delim (struct linebuffer *linebuffer, FILE *stream,\n                      char delimiter)\n{\n  int c;\n  char *buffer = linebuffer->buffer;\n  char *p = linebuffer->buffer;\n  char *end = buffer + linebuffer->size; /* Sentinel. */\n\n  if (feof (stream))\n    return NULL;\n\n  do\n    {\n      c = getc (stream);\n      if (c == EOF)\n        {\n          if (p == buffer || ferror (stream))\n            return NULL;\n          if (p[-1] == delimiter)\n            break;\n          c = delimiter;\n        }\n      if (p == end)\n        {\n          size_t oldsize = linebuffer->size;\n          buffer = x2realloc (buffer, &linebuffer->size);\n          p = buffer + oldsize;\n          linebuffer->buffer = buffer;\n          end = buffer + linebuffer->size;\n        }\n      *p++ = c;\n    }\n  while (c != delimiter);\n\n  linebuffer->length = p - buffer;\n  return linebuffer;\n}",
      "lines": 38,
      "depth": 13,
      "decorators": [
        "struct linebuffer",
        "struct",
        "linebuffer",
        "*\nreadlinebuffer_delim (struct linebuffer *linebuffer, FILE *stream,\n                      char delimiter)",
        "*"
      ]
    },
    "freebuffer": {
      "start_point": [
        98,
        0
      ],
      "end_point": [
        102,
        1
      ],
      "content": "void\nfreebuffer (struct linebuffer *linebuffer)\n{\n  free (linebuffer->buffer);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "datamash/datamash-1.3/lib/linebuffer.h": {},
  "datamash/datamash-1.3/lib/localcharset.c": {
    "get_charset_aliases": {
      "start_point": [
        123,
        0
      ],
      "end_point": [
        384,
        1
      ],
      "content": "static const char *\nget_charset_aliases (void)\n{\n  const char *cp;\n\n  cp = charset_aliases;\n  if (cp == NULL)\n    {\n#if !(defined DARWIN7 || defined VMS || defined WINDOWS_NATIVE || defined __CYGWIN__ || defined OS2)\n      char *malloc_dir = NULL;\n      const char *dir;\n      const char *base = \"charset.alias\";\n      char *file_name;\n\n      /* Make it possible to override the charset.alias location.  This is\n         necessary for running the testsuite before \"make install\".  */\n      dir = getenv (\"CHARSETALIASDIR\");\n      if (dir == NULL || dir[0] == '\\0')\n        dir = relocate2 (LIBDIR, &malloc_dir);\n\n      /* Concatenate dir and base into freshly allocated file_name.  */\n      {\n        size_t dir_len = strlen (dir);\n        size_t base_len = strlen (base);\n        int add_slash = (dir_len > 0 && !ISSLASH (dir[dir_len - 1]));\n        file_name = (char *) malloc (dir_len + add_slash + base_len + 1);\n        if (file_name != NULL)\n          {\n            memcpy (file_name, dir, dir_len);\n            if (add_slash)\n              file_name[dir_len] = DIRECTORY_SEPARATOR;\n            memcpy (file_name + dir_len + add_slash, base, base_len + 1);\n          }\n      }\n\n      free (malloc_dir);\n\n      if (file_name == NULL)\n        /* Out of memory.  Treat the file as empty.  */\n        cp = \"\";\n      else\n        {\n          int fd;\n\n          /* Open the file.  Reject symbolic links on platforms that support\n             O_NOFOLLOW.  This is a security feature.  Without it, an attacker\n             could retrieve parts of the contents (namely, the tail of the\n             first line that starts with \"* \") of an arbitrary file by placing\n             a symbolic link to that file under the name \"charset.alias\" in\n             some writable directory and defining the environment variable\n             CHARSETALIASDIR to point to that directory.  */\n          fd = open (file_name,\n                     O_RDONLY | (HAVE_WORKING_O_NOFOLLOW ? O_NOFOLLOW : 0));\n          if (fd < 0)\n            /* File not found.  Treat it as empty.  */\n            cp = \"\";\n          else\n            {\n              FILE *fp;\n\n              fp = fdopen (fd, \"r\");\n              if (fp == NULL)\n                {\n                  /* Out of memory.  Treat the file as empty.  */\n                  close (fd);\n                  cp = \"\";\n                }\n              else\n                {\n                  /* Parse the file's contents.  */\n                  char *res_ptr = NULL;\n                  size_t res_size = 0;\n\n                  for (;;)\n                    {\n                      int c;\n                      char buf1[50+1];\n                      char buf2[50+1];\n                      size_t l1, l2;\n                      char *old_res_ptr;\n\n                      c = getc (fp);\n                      if (c == EOF)\n                        break;\n                      if (c == '\\n' || c == ' ' || c == '\\t')\n                        continue;\n                      if (c == '#')\n                        {\n                          /* Skip comment, to end of line.  */\n                          do\n                            c = getc (fp);\n                          while (!(c == EOF || c == '\\n'));\n                          if (c == EOF)\n                            break;\n                          continue;\n                        }\n                      ungetc (c, fp);\n                      if (fscanf (fp, \"%50s %50s\", buf1, buf2) < 2)\n                        break;\n                      l1 = strlen (buf1);\n                      l2 = strlen (buf2);\n                      old_res_ptr = res_ptr;\n                      if (res_size == 0)\n                        {\n                          res_size = l1 + 1 + l2 + 1;\n                          res_ptr = (char *) malloc (res_size + 1);\n                        }\n                      else\n                        {\n                          res_size += l1 + 1 + l2 + 1;\n                          res_ptr = (char *) realloc (res_ptr, res_size + 1);\n                        }\n                      if (res_ptr == NULL)\n                        {\n                          /* Out of memory. */\n                          res_size = 0;\n                          free (old_res_ptr);\n                          break;\n                        }\n                      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);\n                      strcpy (res_ptr + res_size - (l2 + 1), buf2);\n                    }\n                  fclose (fp);\n                  if (res_size == 0)\n                    cp = \"\";\n                  else\n                    {\n                      *(res_ptr + res_size) = '\\0';\n                      cp = res_ptr;\n                    }\n                }\n            }\n\n          free (file_name);\n        }\n\n#else\n\n# if defined DARWIN7\n      /* To avoid the trouble of installing a file that is shared by many\n         GNU packages -- many packaging systems have problems with this --,\n         simply inline the aliases here.  */\n      cp = \"ISO8859-1\" \"\\0\" \"ISO-8859-1\" \"\\0\"\n           \"ISO8859-2\" \"\\0\" \"ISO-8859-2\" \"\\0\"\n           \"ISO8859-4\" \"\\0\" \"ISO-8859-4\" \"\\0\"\n           \"ISO8859-5\" \"\\0\" \"ISO-8859-5\" \"\\0\"\n           \"ISO8859-7\" \"\\0\" \"ISO-8859-7\" \"\\0\"\n           \"ISO8859-9\" \"\\0\" \"ISO-8859-9\" \"\\0\"\n           \"ISO8859-13\" \"\\0\" \"ISO-8859-13\" \"\\0\"\n           \"ISO8859-15\" \"\\0\" \"ISO-8859-15\" \"\\0\"\n           \"KOI8-R\" \"\\0\" \"KOI8-R\" \"\\0\"\n           \"KOI8-U\" \"\\0\" \"KOI8-U\" \"\\0\"\n           \"CP866\" \"\\0\" \"CP866\" \"\\0\"\n           \"CP949\" \"\\0\" \"CP949\" \"\\0\"\n           \"CP1131\" \"\\0\" \"CP1131\" \"\\0\"\n           \"CP1251\" \"\\0\" \"CP1251\" \"\\0\"\n           \"eucCN\" \"\\0\" \"GB2312\" \"\\0\"\n           \"GB2312\" \"\\0\" \"GB2312\" \"\\0\"\n           \"eucJP\" \"\\0\" \"EUC-JP\" \"\\0\"\n           \"eucKR\" \"\\0\" \"EUC-KR\" \"\\0\"\n           \"Big5\" \"\\0\" \"BIG5\" \"\\0\"\n           \"Big5HKSCS\" \"\\0\" \"BIG5-HKSCS\" \"\\0\"\n           \"GBK\" \"\\0\" \"GBK\" \"\\0\"\n           \"GB18030\" \"\\0\" \"GB18030\" \"\\0\"\n           \"SJIS\" \"\\0\" \"SHIFT_JIS\" \"\\0\"\n           \"ARMSCII-8\" \"\\0\" \"ARMSCII-8\" \"\\0\"\n           \"PT154\" \"\\0\" \"PT154\" \"\\0\"\n         /*\"ISCII-DEV\" \"\\0\" \"?\" \"\\0\"*/\n           \"*\" \"\\0\" \"UTF-8\" \"\\0\";\n# endif\n\n# if defined VMS\n      /* To avoid the troubles of an extra file charset.alias_vms in the\n         sources of many GNU packages, simply inline the aliases here.  */\n      /* The list of encodings is taken from the OpenVMS 7.3-1 documentation\n         \"Compaq C Run-Time Library Reference Manual for OpenVMS systems\"\n         section 10.7 \"Handling Different Character Sets\".  */\n      cp = \"ISO8859-1\" \"\\0\" \"ISO-8859-1\" \"\\0\"\n           \"ISO8859-2\" \"\\0\" \"ISO-8859-2\" \"\\0\"\n           \"ISO8859-5\" \"\\0\" \"ISO-8859-5\" \"\\0\"\n           \"ISO8859-7\" \"\\0\" \"ISO-8859-7\" \"\\0\"\n           \"ISO8859-8\" \"\\0\" \"ISO-8859-8\" \"\\0\"\n           \"ISO8859-9\" \"\\0\" \"ISO-8859-9\" \"\\0\"\n           /* Japanese */\n           \"eucJP\" \"\\0\" \"EUC-JP\" \"\\0\"\n           \"SJIS\" \"\\0\" \"SHIFT_JIS\" \"\\0\"\n           \"DECKANJI\" \"\\0\" \"DEC-KANJI\" \"\\0\"\n           \"SDECKANJI\" \"\\0\" \"EUC-JP\" \"\\0\"\n           /* Chinese */\n           \"eucTW\" \"\\0\" \"EUC-TW\" \"\\0\"\n           \"DECHANYU\" \"\\0\" \"DEC-HANYU\" \"\\0\"\n           \"DECHANZI\" \"\\0\" \"GB2312\" \"\\0\"\n           /* Korean */\n           \"DECKOREAN\" \"\\0\" \"EUC-KR\" \"\\0\";\n# endif\n\n# if defined WINDOWS_NATIVE || defined __CYGWIN__\n      /* To avoid the troubles of installing a separate file in the same\n         directory as the DLL and of retrieving the DLL's directory at\n         runtime, simply inline the aliases here.  */\n\n      cp = \"CP936\" \"\\0\" \"GBK\" \"\\0\"\n           \"CP1361\" \"\\0\" \"JOHAB\" \"\\0\"\n           \"CP20127\" \"\\0\" \"ASCII\" \"\\0\"\n           \"CP20866\" \"\\0\" \"KOI8-R\" \"\\0\"\n           \"CP20936\" \"\\0\" \"GB2312\" \"\\0\"\n           \"CP21866\" \"\\0\" \"KOI8-RU\" \"\\0\"\n           \"CP28591\" \"\\0\" \"ISO-8859-1\" \"\\0\"\n           \"CP28592\" \"\\0\" \"ISO-8859-2\" \"\\0\"\n           \"CP28593\" \"\\0\" \"ISO-8859-3\" \"\\0\"\n           \"CP28594\" \"\\0\" \"ISO-8859-4\" \"\\0\"\n           \"CP28595\" \"\\0\" \"ISO-8859-5\" \"\\0\"\n           \"CP28596\" \"\\0\" \"ISO-8859-6\" \"\\0\"\n           \"CP28597\" \"\\0\" \"ISO-8859-7\" \"\\0\"\n           \"CP28598\" \"\\0\" \"ISO-8859-8\" \"\\0\"\n           \"CP28599\" \"\\0\" \"ISO-8859-9\" \"\\0\"\n           \"CP28605\" \"\\0\" \"ISO-8859-15\" \"\\0\"\n           \"CP38598\" \"\\0\" \"ISO-8859-8\" \"\\0\"\n           \"CP51932\" \"\\0\" \"EUC-JP\" \"\\0\"\n           \"CP51936\" \"\\0\" \"GB2312\" \"\\0\"\n           \"CP51949\" \"\\0\" \"EUC-KR\" \"\\0\"\n           \"CP51950\" \"\\0\" \"EUC-TW\" \"\\0\"\n           \"CP54936\" \"\\0\" \"GB18030\" \"\\0\"\n           \"CP65001\" \"\\0\" \"UTF-8\" \"\\0\";\n# endif\n# if defined OS2\n      /* To avoid the troubles of installing a separate file in the same\n         directory as the DLL and of retrieving the DLL's directory at\n         runtime, simply inline the aliases here.  */\n\n      /* The list of encodings is taken from \"List of OS/2 Codepages\"\n         by Alex Taylor:\n         <http://altsan.org/os2/toolkits/uls/index.html#codepages>.\n         See also \"IBM Globalization - Code page identifiers\":\n         <https://www-01.ibm.com/software/globalization/cp/cp_cpgid.html>.  */\n      cp = \"CP813\" \"\\0\" \"ISO-8859-7\" \"\\0\"\n           \"CP878\" \"\\0\" \"KOI8-R\" \"\\0\"\n           \"CP819\" \"\\0\" \"ISO-8859-1\" \"\\0\"\n           \"CP912\" \"\\0\" \"ISO-8859-2\" \"\\0\"\n           \"CP913\" \"\\0\" \"ISO-8859-3\" \"\\0\"\n           \"CP914\" \"\\0\" \"ISO-8859-4\" \"\\0\"\n           \"CP915\" \"\\0\" \"ISO-8859-5\" \"\\0\"\n           \"CP916\" \"\\0\" \"ISO-8859-8\" \"\\0\"\n           \"CP920\" \"\\0\" \"ISO-8859-9\" \"\\0\"\n           \"CP921\" \"\\0\" \"ISO-8859-13\" \"\\0\"\n           \"CP923\" \"\\0\" \"ISO-8859-15\" \"\\0\"\n           \"CP954\" \"\\0\" \"EUC-JP\" \"\\0\"\n           \"CP964\" \"\\0\" \"EUC-TW\" \"\\0\"\n           \"CP970\" \"\\0\" \"EUC-KR\" \"\\0\"\n           \"CP1089\" \"\\0\" \"ISO-8859-6\" \"\\0\"\n           \"CP1208\" \"\\0\" \"UTF-8\" \"\\0\"\n           \"CP1381\" \"\\0\" \"GB2312\" \"\\0\"\n           \"CP1386\" \"\\0\" \"GBK\" \"\\0\"\n           \"CP3372\" \"\\0\" \"EUC-JP\" \"\\0\";\n# endif\n#endif\n\n      charset_aliases = cp;\n    }\n\n  return cp;\n}",
      "lines": 262,
      "depth": 23,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nget_charset_aliases (void)",
        "*"
      ]
    },
    "locale_charset": {
      "start_point": [
        395,
        0
      ],
      "end_point": [
        616,
        1
      ],
      "content": "const char *\nlocale_charset (void)\n{\n  const char *codeset;\n  const char *aliases;\n\n#if !(defined WINDOWS_NATIVE || defined OS2)\n\n# if HAVE_LANGINFO_CODESET\n\n  /* Most systems support nl_langinfo (CODESET) nowadays.  */\n  codeset = nl_langinfo (CODESET);\n\n#  ifdef __CYGWIN__\n  /* Cygwin < 1.7 does not have locales.  nl_langinfo (CODESET) always\n     returns \"US-ASCII\".  Return the suffix of the locale name from the\n     environment variables (if present) or the codepage as a number.  */\n  if (codeset != NULL && strcmp (codeset, \"US-ASCII\") == 0)\n    {\n      const char *locale;\n      static char buf[2 + 10 + 1];\n\n      locale = getenv (\"LC_ALL\");\n      if (locale == NULL || locale[0] == '\\0')\n        {\n          locale = getenv (\"LC_CTYPE\");\n          if (locale == NULL || locale[0] == '\\0')\n            locale = getenv (\"LANG\");\n        }\n      if (locale != NULL && locale[0] != '\\0')\n        {\n          /* If the locale name contains an encoding after the dot, return\n             it.  */\n          const char *dot = strchr (locale, '.');\n\n          if (dot != NULL)\n            {\n              const char *modifier;\n\n              dot++;\n              /* Look for the possible @... trailer and remove it, if any.  */\n              modifier = strchr (dot, '@');\n              if (modifier == NULL)\n                return dot;\n              if (modifier - dot < sizeof (buf))\n                {\n                  memcpy (buf, dot, modifier - dot);\n                  buf [modifier - dot] = '\\0';\n                  return buf;\n                }\n            }\n        }\n\n      /* The Windows API has a function returning the locale's codepage as a\n         number: GetACP().  This encoding is used by Cygwin, unless the user\n         has set the environment variable CYGWIN=codepage:oem (which very few\n         people do).\n         Output directed to console windows needs to be converted (to\n         GetOEMCP() if the console is using a raster font, or to\n         GetConsoleOutputCP() if it is using a TrueType font).  Cygwin does\n         this conversion transparently (see winsup/cygwin/fhandler_console.cc),\n         converting to GetConsoleOutputCP().  This leads to correct results,\n         except when SetConsoleOutputCP has been called and a raster font is\n         in use.  */\n      sprintf (buf, \"CP%u\", GetACP ());\n      codeset = buf;\n    }\n#  endif\n\n# else\n\n  /* On old systems which lack it, use setlocale or getenv.  */\n  const char *locale = NULL;\n\n  /* But most old systems don't have a complete set of locales.  Some\n     (like SunOS 4 or DJGPP) have only the C locale.  Therefore we don't\n     use setlocale here; it would return \"C\" when it doesn't support the\n     locale name the user has set.  */\n#  if 0\n  locale = setlocale (LC_CTYPE, NULL);\n#  endif\n  if (locale == NULL || locale[0] == '\\0')\n    {\n      locale = getenv (\"LC_ALL\");\n      if (locale == NULL || locale[0] == '\\0')\n        {\n          locale = getenv (\"LC_CTYPE\");\n          if (locale == NULL || locale[0] == '\\0')\n            locale = getenv (\"LANG\");\n        }\n    }\n\n  /* On some old systems, one used to set locale = \"iso8859_1\". On others,\n     you set it to \"language_COUNTRY.charset\". In any case, we resolve it\n     through the charset.alias file.  */\n  codeset = locale;\n\n# endif\n\n#elif defined WINDOWS_NATIVE\n\n  static char buf[2 + 10 + 1];\n\n  /* The Windows API has a function returning the locale's codepage as\n     a number, but the value doesn't change according to what the\n     'setlocale' call specified.  So we use it as a last resort, in\n     case the string returned by 'setlocale' doesn't specify the\n     codepage.  */\n  char *current_locale = setlocale (LC_ALL, NULL);\n  char *pdot;\n\n  /* If they set different locales for different categories,\n     'setlocale' will return a semi-colon separated list of locale\n     values.  To make sure we use the correct one, we choose LC_CTYPE.  */\n  if (strchr (current_locale, ';'))\n    current_locale = setlocale (LC_CTYPE, NULL);\n\n  pdot = strrchr (current_locale, '.');\n  if (pdot && 2 + strlen (pdot + 1) + 1 <= sizeof (buf))\n    sprintf (buf, \"CP%s\", pdot + 1);\n  else\n    {\n      /* The Windows API has a function returning the locale's codepage as a\n        number: GetACP().\n        When the output goes to a console window, it needs to be provided in\n        GetOEMCP() encoding if the console is using a raster font, or in\n        GetConsoleOutputCP() encoding if it is using a TrueType font.\n        But in GUI programs and for output sent to files and pipes, GetACP()\n        encoding is the best bet.  */\n      sprintf (buf, \"CP%u\", GetACP ());\n    }\n  codeset = buf;\n\n#elif defined OS2\n\n  const char *locale;\n  static char buf[2 + 10 + 1];\n  ULONG cp[3];\n  ULONG cplen;\n\n  codeset = NULL;\n\n  /* Allow user to override the codeset, as set in the operating system,\n     with standard language environment variables.  */\n  locale = getenv (\"LC_ALL\");\n  if (locale == NULL || locale[0] == '\\0')\n    {\n      locale = getenv (\"LC_CTYPE\");\n      if (locale == NULL || locale[0] == '\\0')\n        locale = getenv (\"LANG\");\n    }\n  if (locale != NULL && locale[0] != '\\0')\n    {\n      /* If the locale name contains an encoding after the dot, return it.  */\n      const char *dot = strchr (locale, '.');\n\n      if (dot != NULL)\n        {\n          const char *modifier;\n\n          dot++;\n          /* Look for the possible @... trailer and remove it, if any.  */\n          modifier = strchr (dot, '@');\n          if (modifier == NULL)\n            return dot;\n          if (modifier - dot < sizeof (buf))\n            {\n              memcpy (buf, dot, modifier - dot);\n              buf [modifier - dot] = '\\0';\n              return buf;\n            }\n        }\n\n      /* For the POSIX locale, don't use the system's codepage.  */\n      if (strcmp (locale, \"C\") == 0 || strcmp (locale, \"POSIX\") == 0)\n        codeset = \"\";\n    }\n\n  if (codeset == NULL)\n    {\n      /* OS/2 has a function returning the locale's codepage as a number.  */\n      if (DosQueryCp (sizeof (cp), cp, &cplen))\n        codeset = \"\";\n      else\n        {\n          sprintf (buf, \"CP%u\", cp[0]);\n          codeset = buf;\n        }\n    }\n\n#endif\n\n  if (codeset == NULL)\n    /* The canonical name cannot be determined.  */\n    codeset = \"\";\n\n  /* Resolve alias. */\n  for (aliases = get_charset_aliases ();\n       *aliases != '\\0';\n       aliases += strlen (aliases) + 1, aliases += strlen (aliases) + 1)\n    if (strcmp (codeset, aliases) == 0\n        || (aliases[0] == '*' && aliases[1] == '\\0'))\n      {\n        codeset = aliases + strlen (aliases) + 1;\n        break;\n      }\n\n  /* Don't return an empty string.  GNU libc and GNU libiconv interpret\n     the empty string as denoting \"the locale's character encoding\",\n     thus GNU libiconv would call this function a second time.  */\n  if (codeset[0] == '\\0')\n    codeset = \"ASCII\";\n\n#ifdef DARWIN7\n  /* Mac OS X sets MB_CUR_MAX to 1 when LC_ALL=C, and \"UTF-8\"\n     (the default codeset) does not work when MB_CUR_MAX is 1.  */\n  if (strcmp (codeset, \"UTF-8\") == 0 && MB_CUR_MAX_L (uselocale (NULL)) <= 1)\n    codeset = \"ASCII\";\n#endif\n\n  return codeset;\n}",
      "lines": 222,
      "depth": 18,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nlocale_charset (void)",
        "*"
      ]
    }
  },
  "datamash/datamash-1.3/lib/localcharset.h": {},
  "datamash/datamash-1.3/lib/locale.in.h": {},
  "datamash/datamash-1.3/lib/localeconv.c": {
    "localeconv": [
      {
        "start_point": [
          26,
          0
        ],
        "end_point": [
          60,
          1
        ],
        "content": "struct lconv *\nlocaleconv (void)\n{\n  static struct lconv result;\n# undef lconv\n# undef localeconv\n  struct lconv *sys_result = localeconv ();\n\n  result.decimal_point = sys_result->decimal_point;\n  result.thousands_sep = sys_result->thousands_sep;\n  result.grouping = sys_result->grouping;\n  result.mon_decimal_point = sys_result->mon_decimal_point;\n  result.mon_thousands_sep = sys_result->mon_thousands_sep;\n  result.mon_grouping = sys_result->mon_grouping;\n  result.positive_sign = sys_result->positive_sign;\n  result.negative_sign = sys_result->negative_sign;\n  result.currency_symbol = sys_result->currency_symbol;\n  result.frac_digits = sys_result->frac_digits;\n  result.p_cs_precedes = sys_result->p_cs_precedes;\n  result.p_sign_posn = sys_result->p_sign_posn;\n  result.p_sep_by_space = sys_result->p_sep_by_space;\n  result.n_cs_precedes = sys_result->n_cs_precedes;\n  result.n_sign_posn = sys_result->n_sign_posn;\n  result.n_sep_by_space = sys_result->n_sep_by_space;\n  result.int_curr_symbol = sys_result->int_curr_symbol;\n  result.int_frac_digits = sys_result->int_frac_digits;\n  result.int_p_cs_precedes = sys_result->p_cs_precedes;\n  result.int_p_sign_posn = sys_result->p_sign_posn;\n  result.int_p_sep_by_space = sys_result->p_sep_by_space;\n  result.int_n_cs_precedes = sys_result->n_cs_precedes;\n  result.int_n_sign_posn = sys_result->n_sign_posn;\n  result.int_n_sep_by_space = sys_result->n_sep_by_space;\n\n  return &result;\n}",
        "lines": 35,
        "depth": 7,
        "decorators": [
          "struct lconv",
          "struct",
          "lconv",
          "*\nlocaleconv (void)",
          "*"
        ]
      },
      {
        "start_point": [
          68,
          0
        ],
        "end_point": [
          100,
          1
        ],
        "content": "struct lconv *\nlocaleconv (void)\n{\n  static /*const*/ struct lconv result =\n    {\n      /* decimal_point */ \".\",\n      /* thousands_sep */ \"\",\n      /* grouping */ \"\",\n      /* mon_decimal_point */ \"\",\n      /* mon_thousands_sep */ \"\",\n      /* mon_grouping */ \"\",\n      /* positive_sign */ \"\",\n      /* negative_sign */ \"\",\n      /* currency_symbol */ \"\",\n      /* frac_digits */ CHAR_MAX,\n      /* p_cs_precedes */ CHAR_MAX,\n      /* p_sign_posn */ CHAR_MAX,\n      /* p_sep_by_space */ CHAR_MAX,\n      /* n_cs_precedes */ CHAR_MAX,\n      /* n_sign_posn */ CHAR_MAX,\n      /* n_sep_by_space */ CHAR_MAX,\n      /* int_curr_symbol */ \"\",\n      /* int_frac_digits */ CHAR_MAX,\n      /* int_p_cs_precedes */ CHAR_MAX,\n      /* int_p_sign_posn */ CHAR_MAX,\n      /* int_p_sep_by_space */ CHAR_MAX,\n      /* int_n_cs_precedes */ CHAR_MAX,\n      /* int_n_sign_posn */ CHAR_MAX,\n      /* int_n_sep_by_space */ CHAR_MAX\n    };\n\n  return &result;\n}",
        "lines": 33,
        "depth": 7,
        "decorators": [
          "struct lconv",
          "struct",
          "lconv",
          "*\nlocaleconv (void)",
          "*"
        ]
      }
    ]
  },
  "datamash/datamash-1.3/lib/malloc.c": {
    "rpl_malloc": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "void *\nrpl_malloc (size_t n)\n{\n  void *result;\n\n#if NEED_MALLOC_GNU\n  if (n == 0)\n    n = 1;\n#endif\n\n  result = malloc (n);\n\n#if !HAVE_MALLOC_POSIX\n  if (result == NULL)\n    errno = ENOMEM;\n#endif\n\n  return result;\n}",
      "lines": 19,
      "depth": 7,
      "decorators": [
        "void",
        "*\nrpl_malloc (size_t n)",
        "*"
      ]
    }
  },
  "datamash/datamash-1.3/lib/malloca.c": {
    "mmalloca": {
      "start_point": [
        82,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "void *\nmmalloca (size_t n)\n{\n#if HAVE_ALLOCA\n  /* Allocate one more word, that serves as an indicator for malloc()ed\n     memory, so that freea() of an alloca() result is fast.  */\n  size_t nplus = n + HEADER_SIZE;\n\n  if (nplus >= n)\n    {\n      void *p = malloc (nplus);\n\n      if (p != NULL)\n        {\n          size_t slot;\n          union header *h = p;\n\n          p = h + 1;\n\n          /* Put a magic number into the indicator word.  */\n          h->magic.word = MAGIC_NUMBER;\n\n          /* Enter p into the hash table.  */\n          slot = (uintptr_t) p % HASH_TABLE_SIZE;\n          h->next = mmalloca_results[slot];\n          mmalloca_results[slot] = p;\n\n          return p;\n        }\n    }\n  /* Out of memory.  */\n  return NULL;\n#else\n# if !MALLOC_0_IS_NONNULL\n  if (n == 0)\n    n = 1;\n# endif\n  return malloc (n);\n#endif\n}",
      "lines": 40,
      "depth": 13,
      "decorators": [
        "void",
        "*\nmmalloca (size_t n)",
        "*"
      ]
    },
    "NO_SANITIZE_MEMORY": {
      "start_point": [
        124,
        0
      ],
      "end_point": [
        157,
        1
      ],
      "content": "void NO_SANITIZE_MEMORY\nfreea (void *p)\n{\n  /* mmalloca() may have returned NULL.  */\n  if (p != NULL)\n    {\n      /* Attempt to quickly distinguish the mmalloca() result - which has\n         a magic indicator word - and the alloca() result - which has an\n         uninitialized indicator word.  It is for this test that sa_increment\n         additional bytes are allocated in the alloca() case.  */\n      if (((int *) p)[-1] == MAGIC_NUMBER)\n        {\n          /* Looks like a mmalloca() result.  To see whether it really is one,\n             perform a lookup in the hash table.  */\n          size_t slot = (uintptr_t) p % HASH_TABLE_SIZE;\n          void **chain = &mmalloca_results[slot];\n          for (; *chain != NULL;)\n            {\n              union header *h = p;\n              if (*chain == p)\n                {\n                  /* Found it.  Remove it from the hash table and free it.  */\n                  union header *p_begin = h - 1;\n                  *chain = p_begin->next;\n                  free (p_begin);\n                  return;\n                }\n              h = *chain;\n              chain = &h[-1].next;\n            }\n        }\n      /* At this point, we know it was not a mmalloca() result.  */\n    }\n}",
      "lines": 34,
      "depth": 14,
      "decorators": [
        "void"
      ]
    }
  },
  "datamash/datamash-1.3/lib/malloca.h": {},
  "datamash/datamash-1.3/lib/math.c": {},
  "datamash/datamash-1.3/lib/math.in.h": {
    "float": {
      "start_point": [
        140,
        0
      ],
      "end_point": [
        145,
        1
      ],
      "content": "_GL_MATH_INLINE float\n_NaN ()\n{\n  static float zero = 0.0f;\n  return zero / zero;\n}",
      "lines": 6,
      "depth": 5,
      "decorators": [
        "_GL_MATH_INLINE"
      ]
    }
  },
  "datamash/datamash-1.3/lib/mbchar.c": {},
  "datamash/datamash-1.3/lib/mbchar.h": {
    "mb_width_aux": {
      "start_point": [
        245,
        0
      ],
      "end_point": [
        252,
        1
      ],
      "content": "MBCHAR_INLINE int\nmb_width_aux (wint_t wc)\n{\n  int w = wcwidth (wc);\n  /* For unprintable characters, arbitrarily return 0 for control characters\n     and MB_UNPRINTABLE_WIDTH otherwise.  */\n  return (w >= 0 ? w : iswcntrl (wc) ? 0 : MB_UNPRINTABLE_WIDTH);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "MBCHAR_INLINE",
        "int",
        "int"
      ]
    },
    "mb_copy": {
      "start_point": [
        266,
        0
      ],
      "end_point": [
        279,
        1
      ],
      "content": "MBCHAR_INLINE void\nmb_copy (mbchar_t *new_mbc, const mbchar_t *old_mbc)\n{\n  if (old_mbc->ptr == &old_mbc->buf[0])\n    {\n      memcpy (&new_mbc->buf[0], &old_mbc->buf[0], old_mbc->bytes);\n      new_mbc->ptr = &new_mbc->buf[0];\n    }\n  else\n    new_mbc->ptr = old_mbc->ptr;\n  new_mbc->bytes = old_mbc->bytes;\n  if ((new_mbc->wc_valid = old_mbc->wc_valid))\n    new_mbc->wc = old_mbc->wc;\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "MBCHAR_INLINE",
        "void",
        "void"
      ]
    },
    "is_basic": [
      {
        "start_point": [
          314,
          0
        ],
        "end_point": [
          319,
          1
        ],
        "content": "MBCHAR_INLINE bool\nis_basic (char c)\n{\n  return (is_basic_table [(unsigned char) c >> 5] >> ((unsigned char) c & 31))\n         & 1;\n}",
        "lines": 6,
        "depth": 12,
        "decorators": [
          "MBCHAR_INLINE",
          "bool",
          "bool"
        ]
      },
      {
        "start_point": [
          323,
          0
        ],
        "end_point": [
          353,
          1
        ],
        "content": "MBCHAR_INLINE bool\nis_basic (char c)\n{\n  switch (c)\n    {\n    case '\\t': case '\\v': case '\\f':\n    case ' ': case '!': case '\"': case '#': case '%':\n    case '&': case '\\'': case '(': case ')': case '*':\n    case '+': case ',': case '-': case '.': case '/':\n    case '0': case '1': case '2': case '3': case '4':\n    case '5': case '6': case '7': case '8': case '9':\n    case ':': case ';': case '<': case '=': case '>':\n    case '?':\n    case 'A': case 'B': case 'C': case 'D': case 'E':\n    case 'F': case 'G': case 'H': case 'I': case 'J':\n    case 'K': case 'L': case 'M': case 'N': case 'O':\n    case 'P': case 'Q': case 'R': case 'S': case 'T':\n    case 'U': case 'V': case 'W': case 'X': case 'Y':\n    case 'Z':\n    case '[': case '\\\\': case ']': case '^': case '_':\n    case 'a': case 'b': case 'c': case 'd': case 'e':\n    case 'f': case 'g': case 'h': case 'i': case 'j':\n    case 'k': case 'l': case 'm': case 'n': case 'o':\n    case 'p': case 'q': case 'r': case 's': case 't':\n    case 'u': case 'v': case 'w': case 'x': case 'y':\n    case 'z': case '{': case '|': case '}': case '~':\n      return 1;\n    default:\n      return 0;\n    }\n}",
        "lines": 31,
        "depth": 7,
        "decorators": [
          "MBCHAR_INLINE",
          "bool",
          "bool"
        ]
      }
    ]
  },
  "datamash/datamash-1.3/lib/mbiter.c": {},
  "datamash/datamash-1.3/lib/mbiter.h": {
    "mbiter_multi_next": {
      "start_point": [
        122,
        0
      ],
      "end_point": [
        180,
        1
      ],
      "content": "MBITER_INLINE void\nmbiter_multi_next (struct mbiter_multi *iter)\n{\n  if (iter->next_done)\n    return;\n  if (iter->in_shift)\n    goto with_shift;\n  /* Handle most ASCII characters quickly, without calling mbrtowc().  */\n  if (is_basic (*iter->cur.ptr))\n    {\n      /* These characters are part of the basic character set.  ISO C 99\n         guarantees that their wide character code is identical to their\n         char code.  */\n      iter->cur.bytes = 1;\n      iter->cur.wc = *iter->cur.ptr;\n      iter->cur.wc_valid = true;\n    }\n  else\n    {\n      assert (mbsinit (&iter->state));\n      iter->in_shift = true;\n    with_shift:\n      iter->cur.bytes = mbrtowc (&iter->cur.wc, iter->cur.ptr,\n                                 iter->limit - iter->cur.ptr, &iter->state);\n      if (iter->cur.bytes == (size_t) -1)\n        {\n          /* An invalid multibyte sequence was encountered.  */\n          iter->cur.bytes = 1;\n          iter->cur.wc_valid = false;\n          /* Whether to set iter->in_shift = false and reset iter->state\n             or not is not very important; the string is bogus anyway.  */\n        }\n      else if (iter->cur.bytes == (size_t) -2)\n        {\n          /* An incomplete multibyte character at the end.  */\n          iter->cur.bytes = iter->limit - iter->cur.ptr;\n          iter->cur.wc_valid = false;\n          /* Whether to set iter->in_shift = false and reset iter->state\n             or not is not important; the string end is reached anyway.  */\n        }\n      else\n        {\n          if (iter->cur.bytes == 0)\n            {\n              /* A null wide character was encountered.  */\n              iter->cur.bytes = 1;\n              assert (*iter->cur.ptr == '\\0');\n              assert (iter->cur.wc == 0);\n            }\n          iter->cur.wc_valid = true;\n\n          /* When in the initial state, we can go back treating ASCII\n             characters more quickly.  */\n          if (mbsinit (&iter->state))\n            iter->in_shift = false;\n        }\n    }\n  iter->next_done = true;\n}",
      "lines": 59,
      "depth": 17,
      "decorators": [
        "MBITER_INLINE",
        "void",
        "void"
      ]
    },
    "mbiter_multi_reloc": {
      "start_point": [
        182,
        0
      ],
      "end_point": [
        187,
        1
      ],
      "content": "MBITER_INLINE void\nmbiter_multi_reloc (struct mbiter_multi *iter, ptrdiff_t ptrdiff)\n{\n  iter->cur.ptr += ptrdiff;\n  iter->limit += ptrdiff;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "MBITER_INLINE",
        "void",
        "void"
      ]
    },
    "mbiter_multi_copy": {
      "start_point": [
        189,
        0
      ],
      "end_point": [
        199,
        1
      ],
      "content": "MBITER_INLINE void\nmbiter_multi_copy (struct mbiter_multi *new_iter, const struct mbiter_multi *old_iter)\n{\n  new_iter->limit = old_iter->limit;\n  if ((new_iter->in_shift = old_iter->in_shift))\n    memcpy (&new_iter->state, &old_iter->state, sizeof (mbstate_t));\n  else\n    memset (&new_iter->state, 0, sizeof (mbstate_t));\n  new_iter->next_done = old_iter->next_done;\n  mb_copy (&new_iter->cur, &old_iter->cur);\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "MBITER_INLINE",
        "void",
        "void"
      ]
    }
  },
  "datamash/datamash-1.3/lib/mbrtowc.c": {
    "mbrtowc": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        332,
        1
      ],
      "content": "size_t\nmbrtowc (wchar_t *pwc, const char *s, size_t n, mbstate_t *ps)\n{\n  char *pstate = (char *)ps;\n\n  if (s == NULL)\n    {\n      pwc = NULL;\n      s = \"\";\n      n = 1;\n    }\n\n  if (n == 0)\n    return (size_t)(-2);\n\n  /* Here n > 0.  */\n\n  if (pstate == NULL)\n    pstate = internal_state;\n\n  {\n    size_t nstate = pstate[0];\n    char buf[4];\n    const char *p;\n    size_t m;\n\n    switch (nstate)\n      {\n      case 0:\n        p = s;\n        m = n;\n        break;\n      case 3:\n        buf[2] = pstate[3];\n        FALLTHROUGH;\n      case 2:\n        buf[1] = pstate[2];\n        FALLTHROUGH;\n      case 1:\n        buf[0] = pstate[1];\n        p = buf;\n        m = nstate;\n        buf[m++] = s[0];\n        if (n >= 2 && m < 4)\n          {\n            buf[m++] = s[1];\n            if (n >= 3 && m < 4)\n              buf[m++] = s[2];\n          }\n        break;\n      default:\n        errno = EINVAL;\n        return (size_t)(-1);\n      }\n\n    /* Here m > 0.  */\n\n# if __GLIBC__ || defined __UCLIBC__\n    /* Work around bug <https://sourceware.org/bugzilla/show_bug.cgi?id=9674> */\n    mbtowc (NULL, NULL, 0);\n# endif\n    {\n      int res = mbtowc (pwc, p, m);\n\n      if (res >= 0)\n        {\n          if (pwc != NULL && ((*pwc == 0) != (res == 0)))\n            abort ();\n          if (nstate >= (res > 0 ? res : 1))\n            abort ();\n          res -= nstate;\n          pstate[0] = 0;\n          return res;\n        }\n\n      /* mbtowc does not distinguish between invalid and incomplete multibyte\n         sequences.  But mbrtowc needs to make this distinction.\n         There are two possible approaches:\n           - Use iconv() and its return value.\n           - Use built-in knowledge about the possible encodings.\n         Given the low quality of implementation of iconv() on the systems that\n         lack mbrtowc(), we use the second approach.\n         The possible encodings are:\n           - 8-bit encodings,\n           - EUC-JP, EUC-KR, GB2312, EUC-TW, BIG5, GB18030, SJIS,\n           - UTF-8.\n         Use specialized code for each.  */\n      if (m >= 4 || m >= MB_CUR_MAX)\n        goto invalid;\n      /* Here MB_CUR_MAX > 1 and 0 < m < 4.  */\n      {\n        const char *encoding = locale_charset ();\n\n        if (STREQ_OPT (encoding, \"UTF-8\", 'U', 'T', 'F', '-', '8', 0, 0, 0, 0))\n          {\n            /* Cf. unistr/u8-mblen.c.  */\n            unsigned char c = (unsigned char) p[0];\n\n            if (c >= 0xc2)\n              {\n                if (c < 0xe0)\n                  {\n                    if (m == 1)\n                      goto incomplete;\n                  }\n                else if (c < 0xf0)\n                  {\n                    if (m == 1)\n                      goto incomplete;\n                    if (m == 2)\n                      {\n                        unsigned char c2 = (unsigned char) p[1];\n\n                        if ((c2 ^ 0x80) < 0x40\n                            && (c >= 0xe1 || c2 >= 0xa0)\n                            && (c != 0xed || c2 < 0xa0))\n                          goto incomplete;\n                      }\n                  }\n                else if (c <= 0xf4)\n                  {\n                    if (m == 1)\n                      goto incomplete;\n                    else /* m == 2 || m == 3 */\n                      {\n                        unsigned char c2 = (unsigned char) p[1];\n\n                        if ((c2 ^ 0x80) < 0x40\n                            && (c >= 0xf1 || c2 >= 0x90)\n                            && (c < 0xf4 || (c == 0xf4 && c2 < 0x90)))\n                          {\n                            if (m == 2)\n                              goto incomplete;\n                            else /* m == 3 */\n                              {\n                                unsigned char c3 = (unsigned char) p[2];\n\n                                if ((c3 ^ 0x80) < 0x40)\n                                  goto incomplete;\n                              }\n                          }\n                      }\n                  }\n              }\n            goto invalid;\n          }\n\n        /* As a reference for this code, you can use the GNU libiconv\n           implementation.  Look for uses of the RET_TOOFEW macro.  */\n\n        if (STREQ_OPT (encoding,\n                       \"EUC-JP\", 'E', 'U', 'C', '-', 'J', 'P', 0, 0, 0))\n          {\n            if (m == 1)\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if ((c >= 0xa1 && c < 0xff) || c == 0x8e || c == 0x8f)\n                  goto incomplete;\n              }\n            if (m == 2)\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if (c == 0x8f)\n                  {\n                    unsigned char c2 = (unsigned char) p[1];\n\n                    if (c2 >= 0xa1 && c2 < 0xff)\n                      goto incomplete;\n                  }\n              }\n            goto invalid;\n          }\n        if (STREQ_OPT (encoding,\n                       \"EUC-KR\", 'E', 'U', 'C', '-', 'K', 'R', 0, 0, 0)\n            || STREQ_OPT (encoding,\n                          \"GB2312\", 'G', 'B', '2', '3', '1', '2', 0, 0, 0)\n            || STREQ_OPT (encoding,\n                          \"BIG5\", 'B', 'I', 'G', '5', 0, 0, 0, 0, 0))\n          {\n            if (m == 1)\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if (c >= 0xa1 && c < 0xff)\n                  goto incomplete;\n              }\n            goto invalid;\n          }\n        if (STREQ_OPT (encoding,\n                       \"EUC-TW\", 'E', 'U', 'C', '-', 'T', 'W', 0, 0, 0))\n          {\n            if (m == 1)\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if ((c >= 0xa1 && c < 0xff) || c == 0x8e)\n                  goto incomplete;\n              }\n            else /* m == 2 || m == 3 */\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if (c == 0x8e)\n                  goto incomplete;\n              }\n            goto invalid;\n          }\n        if (STREQ_OPT (encoding,\n                       \"GB18030\", 'G', 'B', '1', '8', '0', '3', '0', 0, 0))\n          {\n            if (m == 1)\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if ((c >= 0x90 && c <= 0xe3) || (c >= 0xf8 && c <= 0xfe))\n                  goto incomplete;\n              }\n            else /* m == 2 || m == 3 */\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if (c >= 0x90 && c <= 0xe3)\n                  {\n                    unsigned char c2 = (unsigned char) p[1];\n\n                    if (c2 >= 0x30 && c2 <= 0x39)\n                      {\n                        if (m == 2)\n                          goto incomplete;\n                        else /* m == 3 */\n                          {\n                            unsigned char c3 = (unsigned char) p[2];\n\n                            if (c3 >= 0x81 && c3 <= 0xfe)\n                              goto incomplete;\n                          }\n                      }\n                  }\n              }\n            goto invalid;\n          }\n        if (STREQ_OPT (encoding, \"SJIS\", 'S', 'J', 'I', 'S', 0, 0, 0, 0, 0))\n          {\n            if (m == 1)\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if ((c >= 0x81 && c <= 0x9f) || (c >= 0xe0 && c <= 0xea)\n                    || (c >= 0xf0 && c <= 0xf9))\n                  goto incomplete;\n              }\n            goto invalid;\n          }\n\n        /* An unknown multibyte encoding.  */\n        goto incomplete;\n      }\n\n     incomplete:\n      {\n        size_t k = nstate;\n        /* Here 0 <= k < m < 4.  */\n        pstate[++k] = s[0];\n        if (k < m)\n          {\n            pstate[++k] = s[1];\n            if (k < m)\n              pstate[++k] = s[2];\n          }\n        if (k != m)\n          abort ();\n      }\n      pstate[0] = m;\n      return (size_t)(-2);\n\n     invalid:\n      errno = EILSEQ;\n      /* The conversion state is undefined, says POSIX.  */\n      return (size_t)(-1);\n    }\n  }\n}",
      "lines": 284,
      "depth": 25,
      "decorators": [
        "size_t"
      ]
    },
    "rpl_mbrtowc": {
      "start_point": [
        339,
        0
      ],
      "end_point": [
        411,
        1
      ],
      "content": "size_t\nrpl_mbrtowc (wchar_t *pwc, const char *s, size_t n, mbstate_t *ps)\n{\n  size_t ret;\n  wchar_t wc;\n\n# if MBRTOWC_NULL_ARG2_BUG || MBRTOWC_RETVAL_BUG || MBRTOWC_EMPTY_INPUT_BUG\n  if (s == NULL)\n    {\n      pwc = NULL;\n      s = \"\";\n      n = 1;\n    }\n# endif\n\n# if MBRTOWC_EMPTY_INPUT_BUG\n  if (n == 0)\n    return (size_t) -2;\n# endif\n\n  if (! pwc)\n    pwc = &wc;\n\n# if MBRTOWC_RETVAL_BUG\n  {\n    static mbstate_t internal_state;\n\n    /* Override mbrtowc's internal state.  We cannot call mbsinit() on the\n       hidden internal state, but we can call it on our variable.  */\n    if (ps == NULL)\n      ps = &internal_state;\n\n    if (!mbsinit (ps))\n      {\n        /* Parse the rest of the multibyte character byte for byte.  */\n        size_t count = 0;\n        for (; n > 0; s++, n--)\n          {\n            ret = mbrtowc (&wc, s, 1, ps);\n\n            if (ret == (size_t)(-1))\n              return (size_t)(-1);\n            count++;\n            if (ret != (size_t)(-2))\n              {\n                /* The multibyte character has been completed.  */\n                *pwc = wc;\n                return (wc == 0 ? 0 : count);\n              }\n          }\n        return (size_t)(-2);\n      }\n  }\n# endif\n\n  ret = mbrtowc (pwc, s, n, ps);\n\n# if MBRTOWC_NUL_RETVAL_BUG\n  if (ret < (size_t) -2 && !*pwc)\n    return 0;\n# endif\n\n# if C_LOCALE_MAYBE_EILSEQ\n  if ((size_t) -2 <= ret && n != 0 && ! hard_locale (LC_CTYPE))\n    {\n      unsigned char uc = *s;\n      *pwc = uc;\n      return 1;\n    }\n# endif\n\n  return ret;\n}",
      "lines": 73,
      "depth": 15,
      "decorators": [
        "size_t"
      ]
    }
  },
  "datamash/datamash-1.3/lib/mbsinit.c": {
    "mbsinit": [
      {
        "start_point": [
          43,
          0
        ],
        "end_point": [
          49,
          1
        ],
        "content": "int\nmbsinit (const mbstate_t *ps)\n{\n  const char *pstate = (const char *)ps;\n\n  return pstate == NULL || pstate[0] == 0;\n}",
        "lines": 7,
        "depth": 8,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          53,
          0
        ],
        "end_point": [
          70,
          1
        ],
        "content": "int\nmbsinit (const mbstate_t *ps)\n{\n# if (defined _WIN32 || defined __WIN32__) && !defined __CYGWIN__\n  /* Native Windows.  */\n#  ifdef __MINGW32__\n  /* On mingw, 'mbstate_t' is defined as 'int'.  */\n  return ps == NULL || *ps == 0;\n#  else\n  /* MSVC defines 'mbstate_t' as an 8-byte struct; the first 4-bytes matter.  */\n  return ps == NULL || *(const unsigned int *)ps == 0;\n#  endif\n# else\n  /* Minix, HP-UX 11.00, Solaris 2.6, Interix, ...  */\n  /* Maybe this definition works, maybe not...  */\n  return ps == NULL || *(const char *)ps == 0;\n# endif\n}",
        "lines": 18,
        "depth": 13,
        "decorators": [
          "int"
        ]
      }
    ]
  },
  "datamash/datamash-1.3/lib/mbslen.c": {
    "mbslen": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "size_t\nmbslen (const char *string)\n{\n  if (MB_CUR_MAX > 1)\n    {\n      size_t count;\n      mbui_iterator_t iter;\n\n      count = 0;\n      for (mbui_init (iter, string); mbui_avail (iter); mbui_advance (iter))\n        count++;\n\n      return count;\n    }\n  else\n    return strlen (string);\n}",
      "lines": 17,
      "depth": 8,
      "decorators": [
        "size_t"
      ]
    }
  },
  "datamash/datamash-1.3/lib/mbsrtowcs-impl.h": {
    "mbsrtowcs": {
      "start_point": [
        17,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "size_t\nmbsrtowcs (wchar_t *dest, const char **srcp, size_t len, mbstate_t *ps)\n{\n  if (ps == NULL)\n    ps = &_gl_mbsrtowcs_state;\n  {\n    const char *src = *srcp;\n\n    if (dest != NULL)\n      {\n        wchar_t *destptr = dest;\n\n        for (; len > 0; destptr++, len--)\n          {\n            size_t src_avail;\n            size_t ret;\n\n            /* An optimized variant of\n               src_avail = strnlen1 (src, MB_LEN_MAX);  */\n            if (src[0] == '\\0')\n              src_avail = 1;\n            else if (src[1] == '\\0')\n              src_avail = 2;\n            else if (src[2] == '\\0')\n              src_avail = 3;\n            else if (MB_LEN_MAX <= 4 || src[3] == '\\0')\n              src_avail = 4;\n            else\n              src_avail = 4 + strnlen1 (src + 4, MB_LEN_MAX - 4);\n\n            /* Parse the next multibyte character.  */\n            ret = mbrtowc (destptr, src, src_avail, ps);\n\n            if (ret == (size_t)(-2))\n              /* Encountered a multibyte character that extends past a '\\0' byte\n                 or that is longer than MB_LEN_MAX bytes.  Cannot happen.  */\n              abort ();\n\n            if (ret == (size_t)(-1))\n              goto bad_input;\n            if (ret == 0)\n              {\n                src = NULL;\n                /* Here mbsinit (ps).  */\n                break;\n              }\n            src += ret;\n          }\n\n        *srcp = src;\n        return destptr - dest;\n      }\n    else\n      {\n        /* Ignore dest and len, don't store *srcp at the end, and\n           don't clobber *ps.  */\n        mbstate_t state = *ps;\n        size_t totalcount = 0;\n\n        for (;; totalcount++)\n          {\n            size_t src_avail;\n            size_t ret;\n\n            /* An optimized variant of\n               src_avail = strnlen1 (src, MB_LEN_MAX);  */\n            if (src[0] == '\\0')\n              src_avail = 1;\n            else if (src[1] == '\\0')\n              src_avail = 2;\n            else if (src[2] == '\\0')\n              src_avail = 3;\n            else if (MB_LEN_MAX <= 4 || src[3] == '\\0')\n              src_avail = 4;\n            else\n              src_avail = 4 + strnlen1 (src + 4, MB_LEN_MAX - 4);\n\n            /* Parse the next multibyte character.  */\n            ret = mbrtowc (NULL, src, src_avail, &state);\n\n            if (ret == (size_t)(-2))\n              /* Encountered a multibyte character that extends past a '\\0' byte\n                 or that is longer than MB_LEN_MAX bytes.  Cannot happen.  */\n              abort ();\n\n            if (ret == (size_t)(-1))\n              goto bad_input2;\n            if (ret == 0)\n              {\n                /* Here mbsinit (&state).  */\n                break;\n              }\n            src += ret;\n          }\n\n        return totalcount;\n      }\n\n   bad_input:\n    *srcp = src;\n   bad_input2:\n    errno = EILSEQ;\n    return (size_t)(-1);\n  }\n}",
      "lines": 105,
      "depth": 18,
      "decorators": [
        "size_t"
      ]
    }
  },
  "datamash/datamash-1.3/lib/mbsrtowcs-state.c": {},
  "datamash/datamash-1.3/lib/mbsrtowcs.c": {},
  "datamash/datamash-1.3/lib/mbsstr.c": {
    "knuth_morris_pratt_multibyte": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        179,
        1
      ],
      "content": "static bool\nknuth_morris_pratt_multibyte (const char *haystack, const char *needle,\n                              const char **resultp)\n{\n  size_t m = mbslen (needle);\n  mbchar_t *needle_mbchars;\n  size_t *table;\n\n  /* Allocate room for needle_mbchars and the table.  */\n  void *memory = nmalloca (m, sizeof (mbchar_t) + sizeof (size_t));\n  void *table_memory;\n  if (memory == NULL)\n    return false;\n  needle_mbchars = memory;\n  table_memory = needle_mbchars + m;\n  table = table_memory;\n\n  /* Fill needle_mbchars.  */\n  {\n    mbui_iterator_t iter;\n    size_t j;\n\n    j = 0;\n    for (mbui_init (iter, needle); mbui_avail (iter); mbui_advance (iter), j++)\n      mb_copy (&needle_mbchars[j], &mbui_cur (iter));\n  }\n\n  /* Fill the table.\n     For 0 < i < m:\n       0 < table[i] <= i is defined such that\n       forall 0 < x < table[i]: needle[x..i-1] != needle[0..i-1-x],\n       and table[i] is as large as possible with this property.\n     This implies:\n     1) For 0 < i < m:\n          If table[i] < i,\n          needle[table[i]..i-1] = needle[0..i-1-table[i]].\n     2) For 0 < i < m:\n          rhaystack[0..i-1] == needle[0..i-1]\n          and exists h, i <= h < m: rhaystack[h] != needle[h]\n          implies\n          forall 0 <= x < table[i]: rhaystack[x..x+m-1] != needle[0..m-1].\n     table[0] remains uninitialized.  */\n  {\n    size_t i, j;\n\n    /* i = 1: Nothing to verify for x = 0.  */\n    table[1] = 1;\n    j = 0;\n\n    for (i = 2; i < m; i++)\n      {\n        /* Here: j = i-1 - table[i-1].\n           The inequality needle[x..i-1] != needle[0..i-1-x] is known to hold\n           for x < table[i-1], by induction.\n           Furthermore, if j>0: needle[i-1-j..i-2] = needle[0..j-1].  */\n        mbchar_t *b = &needle_mbchars[i - 1];\n\n        for (;;)\n          {\n            /* Invariants: The inequality needle[x..i-1] != needle[0..i-1-x]\n               is known to hold for x < i-1-j.\n               Furthermore, if j>0: needle[i-1-j..i-2] = needle[0..j-1].  */\n            if (mb_equal (*b, needle_mbchars[j]))\n              {\n                /* Set table[i] := i-1-j.  */\n                table[i] = i - ++j;\n                break;\n              }\n            /* The inequality needle[x..i-1] != needle[0..i-1-x] also holds\n               for x = i-1-j, because\n                 needle[i-1] != needle[j] = needle[i-1-x].  */\n            if (j == 0)\n              {\n                /* The inequality holds for all possible x.  */\n                table[i] = i;\n                break;\n              }\n            /* The inequality needle[x..i-1] != needle[0..i-1-x] also holds\n               for i-1-j < x < i-1-j+table[j], because for these x:\n                 needle[x..i-2]\n                 = needle[x-(i-1-j)..j-1]\n                 != needle[0..j-1-(x-(i-1-j))]  (by definition of table[j])\n                    = needle[0..i-2-x],\n               hence needle[x..i-1] != needle[0..i-1-x].\n               Furthermore\n                 needle[i-1-j+table[j]..i-2]\n                 = needle[table[j]..j-1]\n                 = needle[0..j-1-table[j]]  (by definition of table[j]).  */\n            j = j - table[j];\n          }\n        /* Here: j = i - table[i].  */\n      }\n  }\n\n  /* Search, using the table to accelerate the processing.  */\n  {\n    size_t j;\n    mbui_iterator_t rhaystack;\n    mbui_iterator_t phaystack;\n\n    *resultp = NULL;\n    j = 0;\n    mbui_init (rhaystack, haystack);\n    mbui_init (phaystack, haystack);\n    /* Invariant: phaystack = rhaystack + j.  */\n    while (mbui_avail (phaystack))\n      if (mb_equal (needle_mbchars[j], mbui_cur (phaystack)))\n        {\n          j++;\n          mbui_advance (phaystack);\n          if (j == m)\n            {\n              /* The entire needle has been found.  */\n              *resultp = mbui_cur_ptr (rhaystack);\n              break;\n            }\n        }\n      else if (j > 0)\n        {\n          /* Found a match of needle[0..j-1], mismatch at needle[j].  */\n          size_t count = table[j];\n          j -= count;\n          for (; count > 0; count--)\n            {\n              if (!mbui_avail (rhaystack))\n                abort ();\n              mbui_advance (rhaystack);\n            }\n        }\n      else\n        {\n          /* Found a mismatch at needle[0] already.  */\n          if (!mbui_avail (rhaystack))\n            abort ();\n          mbui_advance (rhaystack);\n          mbui_advance (phaystack);\n        }\n  }\n\n  freea (memory);\n  return true;\n}",
      "lines": 142,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "mbsstr": {
      "start_point": [
        183,
        0
      ],
      "end_point": [
        383,
        1
      ],
      "content": "char *\nmbsstr (const char *haystack, const char *needle)\n{\n  /* Be careful not to look at the entire extent of haystack or needle\n     until needed.  This is useful because of these two cases:\n       - haystack may be very long, and a match of needle found early,\n       - needle may be very long, and not even a short initial segment of\n         needle may be found in haystack.  */\n  if (MB_CUR_MAX > 1)\n    {\n      mbui_iterator_t iter_needle;\n\n      mbui_init (iter_needle, needle);\n      if (mbui_avail (iter_needle))\n        {\n          /* Minimizing the worst-case complexity:\n             Let n = mbslen(haystack), m = mbslen(needle).\n             The na\u00c3\u00afve algorithm is O(n*m) worst-case.\n             The Knuth-Morris-Pratt algorithm is O(n) worst-case but it needs a\n             memory allocation.\n             To achieve linear complexity and yet amortize the cost of the\n             memory allocation, we activate the Knuth-Morris-Pratt algorithm\n             only once the na\u00c3\u00afve algorithm has already run for some time; more\n             precisely, when\n               - the outer loop count is >= 10,\n               - the average number of comparisons per outer loop is >= 5,\n               - the total number of comparisons is >= m.\n             But we try it only once.  If the memory allocation attempt failed,\n             we don't retry it.  */\n          bool try_kmp = true;\n          size_t outer_loop_count = 0;\n          size_t comparison_count = 0;\n          size_t last_ccount = 0;                  /* last comparison count */\n          mbui_iterator_t iter_needle_last_ccount; /* = needle + last_ccount */\n\n          mbui_iterator_t iter_haystack;\n\n          mbui_init (iter_needle_last_ccount, needle);\n          mbui_init (iter_haystack, haystack);\n          for (;; mbui_advance (iter_haystack))\n            {\n              if (!mbui_avail (iter_haystack))\n                /* No match.  */\n                return NULL;\n\n              /* See whether it's advisable to use an asymptotically faster\n                 algorithm.  */\n              if (try_kmp\n                  && outer_loop_count >= 10\n                  && comparison_count >= 5 * outer_loop_count)\n                {\n                  /* See if needle + comparison_count now reaches the end of\n                     needle.  */\n                  size_t count = comparison_count - last_ccount;\n                  for (;\n                       count > 0 && mbui_avail (iter_needle_last_ccount);\n                       count--)\n                    mbui_advance (iter_needle_last_ccount);\n                  last_ccount = comparison_count;\n                  if (!mbui_avail (iter_needle_last_ccount))\n                    {\n                      /* Try the Knuth-Morris-Pratt algorithm.  */\n                      const char *result;\n                      bool success =\n                        knuth_morris_pratt_multibyte (haystack, needle,\n                                                      &result);\n                      if (success)\n                        return (char *) result;\n                      try_kmp = false;\n                    }\n                }\n\n              outer_loop_count++;\n              comparison_count++;\n              if (mb_equal (mbui_cur (iter_haystack), mbui_cur (iter_needle)))\n                /* The first character matches.  */\n                {\n                  mbui_iterator_t rhaystack;\n                  mbui_iterator_t rneedle;\n\n                  memcpy (&rhaystack, &iter_haystack, sizeof (mbui_iterator_t));\n                  mbui_advance (rhaystack);\n\n                  mbui_init (rneedle, needle);\n                  if (!mbui_avail (rneedle))\n                    abort ();\n                  mbui_advance (rneedle);\n\n                  for (;; mbui_advance (rhaystack), mbui_advance (rneedle))\n                    {\n                      if (!mbui_avail (rneedle))\n                        /* Found a match.  */\n                        return (char *) mbui_cur_ptr (iter_haystack);\n                      if (!mbui_avail (rhaystack))\n                        /* No match.  */\n                        return NULL;\n                      comparison_count++;\n                      if (!mb_equal (mbui_cur (rhaystack), mbui_cur (rneedle)))\n                        /* Nothing in this round.  */\n                        break;\n                    }\n                }\n            }\n        }\n      else\n        return (char *) haystack;\n    }\n  else\n    {\n      if (*needle != '\\0')\n        {\n          /* Minimizing the worst-case complexity:\n             Let n = strlen(haystack), m = strlen(needle).\n             The na\u00c3\u00afve algorithm is O(n*m) worst-case.\n             The Knuth-Morris-Pratt algorithm is O(n) worst-case but it needs a\n             memory allocation.\n             To achieve linear complexity and yet amortize the cost of the\n             memory allocation, we activate the Knuth-Morris-Pratt algorithm\n             only once the na\u00c3\u00afve algorithm has already run for some time; more\n             precisely, when\n               - the outer loop count is >= 10,\n               - the average number of comparisons per outer loop is >= 5,\n               - the total number of comparisons is >= m.\n             But we try it only once.  If the memory allocation attempt failed,\n             we don't retry it.  */\n          bool try_kmp = true;\n          size_t outer_loop_count = 0;\n          size_t comparison_count = 0;\n          size_t last_ccount = 0;                  /* last comparison count */\n          const char *needle_last_ccount = needle; /* = needle + last_ccount */\n\n          /* Speed up the following searches of needle by caching its first\n             character.  */\n          char b = *needle++;\n\n          for (;; haystack++)\n            {\n              if (*haystack == '\\0')\n                /* No match.  */\n                return NULL;\n\n              /* See whether it's advisable to use an asymptotically faster\n                 algorithm.  */\n              if (try_kmp\n                  && outer_loop_count >= 10\n                  && comparison_count >= 5 * outer_loop_count)\n                {\n                  /* See if needle + comparison_count now reaches the end of\n                     needle.  */\n                  if (needle_last_ccount != NULL)\n                    {\n                      needle_last_ccount +=\n                        strnlen (needle_last_ccount,\n                                 comparison_count - last_ccount);\n                      if (*needle_last_ccount == '\\0')\n                        needle_last_ccount = NULL;\n                      last_ccount = comparison_count;\n                    }\n                  if (needle_last_ccount == NULL)\n                    {\n                      /* Try the Knuth-Morris-Pratt algorithm.  */\n                      const unsigned char *result;\n                      bool success =\n                        knuth_morris_pratt ((const unsigned char *) haystack,\n                                            (const unsigned char *) (needle - 1),\n                                            strlen (needle - 1),\n                                            &result);\n                      if (success)\n                        return (char *) result;\n                      try_kmp = false;\n                    }\n                }\n\n              outer_loop_count++;\n              comparison_count++;\n              if (*haystack == b)\n                /* The first character matches.  */\n                {\n                  const char *rhaystack = haystack + 1;\n                  const char *rneedle = needle;\n\n                  for (;; rhaystack++, rneedle++)\n                    {\n                      if (*rneedle == '\\0')\n                        /* Found a match.  */\n                        return (char *) haystack;\n                      if (*rhaystack == '\\0')\n                        /* No match.  */\n                        return NULL;\n                      comparison_count++;\n                      if (*rhaystack != *rneedle)\n                        /* Nothing in this round.  */\n                        break;\n                    }\n                }\n            }\n        }\n      else\n        return (char *) haystack;\n    }\n}",
      "lines": 201,
      "depth": 20,
      "decorators": [
        "char",
        "*\nmbsstr (const char *haystack, const char *needle)",
        "*"
      ]
    }
  },
  "datamash/datamash-1.3/lib/mbuiter.c": {},
  "datamash/datamash-1.3/lib/mbuiter.h": {
    "mbuiter_multi_next": {
      "start_point": [
        130,
        0
      ],
      "end_point": [
        189,
        1
      ],
      "content": "MBUITER_INLINE void\nmbuiter_multi_next (struct mbuiter_multi *iter)\n{\n  if (iter->next_done)\n    return;\n  if (iter->in_shift)\n    goto with_shift;\n  /* Handle most ASCII characters quickly, without calling mbrtowc().  */\n  if (is_basic (*iter->cur.ptr))\n    {\n      /* These characters are part of the basic character set.  ISO C 99\n         guarantees that their wide character code is identical to their\n         char code.  */\n      iter->cur.bytes = 1;\n      iter->cur.wc = *iter->cur.ptr;\n      iter->cur.wc_valid = true;\n    }\n  else\n    {\n      assert (mbsinit (&iter->state));\n      iter->in_shift = true;\n    with_shift:\n      iter->cur.bytes = mbrtowc (&iter->cur.wc, iter->cur.ptr,\n                                 strnlen1 (iter->cur.ptr, MB_CUR_MAX),\n                                 &iter->state);\n      if (iter->cur.bytes == (size_t) -1)\n        {\n          /* An invalid multibyte sequence was encountered.  */\n          iter->cur.bytes = 1;\n          iter->cur.wc_valid = false;\n          /* Whether to set iter->in_shift = false and reset iter->state\n             or not is not very important; the string is bogus anyway.  */\n        }\n      else if (iter->cur.bytes == (size_t) -2)\n        {\n          /* An incomplete multibyte character at the end.  */\n          iter->cur.bytes = strlen (iter->cur.ptr);\n          iter->cur.wc_valid = false;\n          /* Whether to set iter->in_shift = false and reset iter->state\n             or not is not important; the string end is reached anyway.  */\n        }\n      else\n        {\n          if (iter->cur.bytes == 0)\n            {\n              /* A null wide character was encountered.  */\n              iter->cur.bytes = 1;\n              assert (*iter->cur.ptr == '\\0');\n              assert (iter->cur.wc == 0);\n            }\n          iter->cur.wc_valid = true;\n\n          /* When in the initial state, we can go back treating ASCII\n             characters more quickly.  */\n          if (mbsinit (&iter->state))\n            iter->in_shift = false;\n        }\n    }\n  iter->next_done = true;\n}",
      "lines": 60,
      "depth": 17,
      "decorators": [
        "MBUITER_INLINE",
        "void",
        "void"
      ]
    },
    "mbuiter_multi_reloc": {
      "start_point": [
        191,
        0
      ],
      "end_point": [
        195,
        1
      ],
      "content": "MBUITER_INLINE void\nmbuiter_multi_reloc (struct mbuiter_multi *iter, ptrdiff_t ptrdiff)\n{\n  iter->cur.ptr += ptrdiff;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "MBUITER_INLINE",
        "void",
        "void"
      ]
    },
    "mbuiter_multi_copy": {
      "start_point": [
        197,
        0
      ],
      "end_point": [
        206,
        1
      ],
      "content": "MBUITER_INLINE void\nmbuiter_multi_copy (struct mbuiter_multi *new_iter, const struct mbuiter_multi *old_iter)\n{\n  if ((new_iter->in_shift = old_iter->in_shift))\n    memcpy (&new_iter->state, &old_iter->state, sizeof (mbstate_t));\n  else\n    memset (&new_iter->state, 0, sizeof (mbstate_t));\n  new_iter->next_done = old_iter->next_done;\n  mb_copy (&new_iter->cur, &old_iter->cur);\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "MBUITER_INLINE",
        "void",
        "void"
      ]
    }
  },
  "datamash/datamash-1.3/lib/md5.c": {
    "md5_init_ctx": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        84,
        1
      ],
      "content": "void\nmd5_init_ctx (struct md5_ctx *ctx)\n{\n  ctx->A = 0x67452301;\n  ctx->B = 0xefcdab89;\n  ctx->C = 0x98badcfe;\n  ctx->D = 0x10325476;\n\n  ctx->total[0] = ctx->total[1] = 0;\n  ctx->buflen = 0;\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "set_uint32": {
      "start_point": [
        89,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "static void\nset_uint32 (char *cp, uint32_t v)\n{\n  memcpy (cp, &v, sizeof v);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "md5_read_ctx": {
      "start_point": [
        97,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "void *\nmd5_read_ctx (const struct md5_ctx *ctx, void *resbuf)\n{\n  char *r = resbuf;\n  set_uint32 (r + 0 * sizeof ctx->A, SWAP (ctx->A));\n  set_uint32 (r + 1 * sizeof ctx->B, SWAP (ctx->B));\n  set_uint32 (r + 2 * sizeof ctx->C, SWAP (ctx->C));\n  set_uint32 (r + 3 * sizeof ctx->D, SWAP (ctx->D));\n\n  return resbuf;\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "void",
        "*\nmd5_read_ctx (const struct md5_ctx *ctx, void *resbuf)",
        "*"
      ]
    },
    "md5_finish_ctx": {
      "start_point": [
        111,
        0
      ],
      "end_point": [
        133,
        1
      ],
      "content": "void *\nmd5_finish_ctx (struct md5_ctx *ctx, void *resbuf)\n{\n  /* Take yet unprocessed bytes into account.  */\n  uint32_t bytes = ctx->buflen;\n  size_t size = (bytes < 56) ? 64 / 4 : 64 * 2 / 4;\n\n  /* Now count remaining bytes.  */\n  ctx->total[0] += bytes;\n  if (ctx->total[0] < bytes)\n    ++ctx->total[1];\n\n  /* Put the 64-bit file length in *bits* at the end of the buffer.  */\n  ctx->buffer[size - 2] = SWAP (ctx->total[0] << 3);\n  ctx->buffer[size - 1] = SWAP ((ctx->total[1] << 3) | (ctx->total[0] >> 29));\n\n  memcpy (&((char *) ctx->buffer)[bytes], fillbuf, (size - 2) * 4 - bytes);\n\n  /* Process last bytes.  */\n  md5_process_block (ctx->buffer, size * 4, ctx);\n\n  return md5_read_ctx (ctx, resbuf);\n}",
      "lines": 23,
      "depth": 12,
      "decorators": [
        "void",
        "*\nmd5_finish_ctx (struct md5_ctx *ctx, void *resbuf)",
        "*"
      ]
    },
    "md5_stream": {
      "start_point": [
        139,
        0
      ],
      "end_point": [
        207,
        1
      ],
      "content": "int\nmd5_stream (FILE *stream, void *resblock)\n{\n  struct md5_ctx ctx;\n  size_t sum;\n\n  char *buffer = malloc (BLOCKSIZE + 72);\n  if (!buffer)\n    return 1;\n\n  /* Initialize the computation context.  */\n  md5_init_ctx (&ctx);\n\n  /* Iterate over full file contents.  */\n  while (1)\n    {\n      /* We read the file in blocks of BLOCKSIZE bytes.  One call of the\n         computation function processes the whole buffer so that with the\n         next round of the loop another block can be read.  */\n      size_t n;\n      sum = 0;\n\n      /* Read block.  Take care for partial reads.  */\n      while (1)\n        {\n          n = fread (buffer + sum, 1, BLOCKSIZE - sum, stream);\n\n          sum += n;\n\n          if (sum == BLOCKSIZE)\n            break;\n\n          if (n == 0)\n            {\n              /* Check for the error flag IFF N == 0, so that we don't\n                 exit the loop after a partial read due to e.g., EAGAIN\n                 or EWOULDBLOCK.  */\n              if (ferror (stream))\n                {\n                  free (buffer);\n                  return 1;\n                }\n              goto process_partial_block;\n            }\n\n          /* We've read at least one byte, so ignore errors.  But always\n             check for EOF, since feof may be true even though N > 0.\n             Otherwise, we could end up calling fread after EOF.  */\n          if (feof (stream))\n            goto process_partial_block;\n        }\n\n      /* Process buffer with BLOCKSIZE bytes.  Note that\n         BLOCKSIZE % 64 == 0\n       */\n      md5_process_block (buffer, BLOCKSIZE, &ctx);\n    }\n\nprocess_partial_block:\n\n  /* Process any remaining bytes.  */\n  if (sum > 0)\n    md5_process_bytes (buffer, sum, &ctx);\n\n  /* Construct result in desired memory.  */\n  md5_finish_ctx (&ctx, resblock);\n  free (buffer);\n  return 0;\n}",
      "lines": 69,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "md5_buffer": {
      "start_point": [
        214,
        0
      ],
      "end_point": [
        227,
        1
      ],
      "content": "void *\nmd5_buffer (const char *buffer, size_t len, void *resblock)\n{\n  struct md5_ctx ctx;\n\n  /* Initialize the computation context.  */\n  md5_init_ctx (&ctx);\n\n  /* Process whole buffer but last len % 64 bytes.  */\n  md5_process_bytes (buffer, len, &ctx);\n\n  /* Put result in desired memory area.  */\n  return md5_finish_ctx (&ctx, resblock);\n}",
      "lines": 14,
      "depth": 7,
      "decorators": [
        "void",
        "*\nmd5_buffer (const char *buffer, size_t len, void *resblock)",
        "*"
      ]
    },
    "md5_process_bytes": {
      "start_point": [
        230,
        0
      ],
      "end_point": [
        297,
        1
      ],
      "content": "void\nmd5_process_bytes (const void *buffer, size_t len, struct md5_ctx *ctx)\n{\n  /* When we already have some bits in our internal buffer concatenate\n     both inputs first.  */\n  if (ctx->buflen != 0)\n    {\n      size_t left_over = ctx->buflen;\n      size_t add = 128 - left_over > len ? len : 128 - left_over;\n\n      memcpy (&((char *) ctx->buffer)[left_over], buffer, add);\n      ctx->buflen += add;\n\n      if (ctx->buflen > 64)\n        {\n          md5_process_block (ctx->buffer, ctx->buflen & ~63, ctx);\n\n          ctx->buflen &= 63;\n          /* The regions in the following copy operation cannot overlap,\n             because ctx->buflen < 64 \u00e2\u0089\u00a4 (left_over + add) & ~63.  */\n          memcpy (ctx->buffer,\n                  &((char *) ctx->buffer)[(left_over + add) & ~63],\n                  ctx->buflen);\n        }\n\n      buffer = (const char *) buffer + add;\n      len -= add;\n    }\n\n  /* Process available complete blocks.  */\n  if (len >= 64)\n    {\n#if !(_STRING_ARCH_unaligned || _STRING_INLINE_unaligned)\n# define UNALIGNED_P(p) ((uintptr_t) (p) % alignof (uint32_t) != 0)\n      if (UNALIGNED_P (buffer))\n        while (len > 64)\n          {\n            md5_process_block (memcpy (ctx->buffer, buffer, 64), 64, ctx);\n            buffer = (const char *) buffer + 64;\n            len -= 64;\n          }\n      else\n#endif\n        {\n          md5_process_block (buffer, len & ~63, ctx);\n          buffer = (const char *) buffer + (len & ~63);\n          len &= 63;\n        }\n    }\n\n  /* Move remaining bytes in internal buffer.  */\n  if (len > 0)\n    {\n      size_t left_over = ctx->buflen;\n\n      memcpy (&((char *) ctx->buffer)[left_over], buffer, len);\n      left_over += len;\n      if (left_over >= 64)\n        {\n          md5_process_block (ctx->buffer, 64, ctx);\n          left_over -= 64;\n          /* The regions in the following copy operation cannot overlap,\n             because left_over \u00e2\u0089\u00a4 64.  */\n          memcpy (ctx->buffer, &ctx->buffer[16], left_over);\n        }\n      ctx->buflen = left_over;\n    }\n}",
      "lines": 68,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "md5_process_block": {
      "start_point": [
        312,
        0
      ],
      "end_point": [
        469,
        1
      ],
      "content": "void\nmd5_process_block (const void *buffer, size_t len, struct md5_ctx *ctx)\n{\n  uint32_t correct_words[16];\n  const uint32_t *words = buffer;\n  size_t nwords = len / sizeof (uint32_t);\n  const uint32_t *endp = words + nwords;\n  uint32_t A = ctx->A;\n  uint32_t B = ctx->B;\n  uint32_t C = ctx->C;\n  uint32_t D = ctx->D;\n  uint32_t lolen = len;\n\n  /* First increment the byte count.  RFC 1321 specifies the possible\n     length of the file up to 2^64 bits.  Here we only compute the\n     number of bytes.  Do a double word increment.  */\n  ctx->total[0] += lolen;\n  ctx->total[1] += (len >> 31 >> 1) + (ctx->total[0] < lolen);\n\n  /* Process all bytes in the buffer with 64 bytes in each round of\n     the loop.  */\n  while (words < endp)\n    {\n      uint32_t *cwp = correct_words;\n      uint32_t A_save = A;\n      uint32_t B_save = B;\n      uint32_t C_save = C;\n      uint32_t D_save = D;\n\n      /* First round: using the given function, the context and a constant\n         the next context is computed.  Because the algorithms processing\n         unit is a 32-bit word and it is determined to work on words in\n         little endian byte order we perhaps have to change the byte order\n         before the computation.  To reduce the work for the next steps\n         we store the swapped words in the array CORRECT_WORDS.  */\n\n#define OP(a, b, c, d, s, T)                                            \\\n      do                                                                \\\n        {                                                               \\\n          a += FF (b, c, d) + (*cwp++ = SWAP (*words)) + T;             \\\n          ++words;                                                      \\\n          CYCLIC (a, s);                                                \\\n          a += b;                                                       \\\n        }                                                               \\\n      while (0)\n\n      /* It is unfortunate that C does not provide an operator for\n         cyclic rotation.  Hope the C compiler is smart enough.  */\n#define CYCLIC(w, s) (w = (w << s) | (w >> (32 - s)))\n\n      /* Before we start, one word to the strange constants.\n         They are defined in RFC 1321 as\n\n         T[i] = (int) (4294967296.0 * fabs (sin (i))), i=1..64\n\n         Here is an equivalent invocation using Perl:\n\n         perl -e 'foreach(1..64){printf \"0x%08x\\n\", int (4294967296 * abs (sin $_))}'\n       */\n\n      /* Round 1.  */\n      OP (A, B, C, D, 7, 0xd76aa478);\n      OP (D, A, B, C, 12, 0xe8c7b756);\n      OP (C, D, A, B, 17, 0x242070db);\n      OP (B, C, D, A, 22, 0xc1bdceee);\n      OP (A, B, C, D, 7, 0xf57c0faf);\n      OP (D, A, B, C, 12, 0x4787c62a);\n      OP (C, D, A, B, 17, 0xa8304613);\n      OP (B, C, D, A, 22, 0xfd469501);\n      OP (A, B, C, D, 7, 0x698098d8);\n      OP (D, A, B, C, 12, 0x8b44f7af);\n      OP (C, D, A, B, 17, 0xffff5bb1);\n      OP (B, C, D, A, 22, 0x895cd7be);\n      OP (A, B, C, D, 7, 0x6b901122);\n      OP (D, A, B, C, 12, 0xfd987193);\n      OP (C, D, A, B, 17, 0xa679438e);\n      OP (B, C, D, A, 22, 0x49b40821);\n\n      /* For the second to fourth round we have the possibly swapped words\n         in CORRECT_WORDS.  Redefine the macro to take an additional first\n         argument specifying the function to use.  */\n#undef OP\n#define OP(f, a, b, c, d, k, s, T)                                      \\\n      do                                                                \\\n        {                                                               \\\n          a += f (b, c, d) + correct_words[k] + T;                      \\\n          CYCLIC (a, s);                                                \\\n          a += b;                                                       \\\n        }                                                               \\\n      while (0)\n\n      /* Round 2.  */\n      OP (FG, A, B, C, D, 1, 5, 0xf61e2562);\n      OP (FG, D, A, B, C, 6, 9, 0xc040b340);\n      OP (FG, C, D, A, B, 11, 14, 0x265e5a51);\n      OP (FG, B, C, D, A, 0, 20, 0xe9b6c7aa);\n      OP (FG, A, B, C, D, 5, 5, 0xd62f105d);\n      OP (FG, D, A, B, C, 10, 9, 0x02441453);\n      OP (FG, C, D, A, B, 15, 14, 0xd8a1e681);\n      OP (FG, B, C, D, A, 4, 20, 0xe7d3fbc8);\n      OP (FG, A, B, C, D, 9, 5, 0x21e1cde6);\n      OP (FG, D, A, B, C, 14, 9, 0xc33707d6);\n      OP (FG, C, D, A, B, 3, 14, 0xf4d50d87);\n      OP (FG, B, C, D, A, 8, 20, 0x455a14ed);\n      OP (FG, A, B, C, D, 13, 5, 0xa9e3e905);\n      OP (FG, D, A, B, C, 2, 9, 0xfcefa3f8);\n      OP (FG, C, D, A, B, 7, 14, 0x676f02d9);\n      OP (FG, B, C, D, A, 12, 20, 0x8d2a4c8a);\n\n      /* Round 3.  */\n      OP (FH, A, B, C, D, 5, 4, 0xfffa3942);\n      OP (FH, D, A, B, C, 8, 11, 0x8771f681);\n      OP (FH, C, D, A, B, 11, 16, 0x6d9d6122);\n      OP (FH, B, C, D, A, 14, 23, 0xfde5380c);\n      OP (FH, A, B, C, D, 1, 4, 0xa4beea44);\n      OP (FH, D, A, B, C, 4, 11, 0x4bdecfa9);\n      OP (FH, C, D, A, B, 7, 16, 0xf6bb4b60);\n      OP (FH, B, C, D, A, 10, 23, 0xbebfbc70);\n      OP (FH, A, B, C, D, 13, 4, 0x289b7ec6);\n      OP (FH, D, A, B, C, 0, 11, 0xeaa127fa);\n      OP (FH, C, D, A, B, 3, 16, 0xd4ef3085);\n      OP (FH, B, C, D, A, 6, 23, 0x04881d05);\n      OP (FH, A, B, C, D, 9, 4, 0xd9d4d039);\n      OP (FH, D, A, B, C, 12, 11, 0xe6db99e5);\n      OP (FH, C, D, A, B, 15, 16, 0x1fa27cf8);\n      OP (FH, B, C, D, A, 2, 23, 0xc4ac5665);\n\n      /* Round 4.  */\n      OP (FI, A, B, C, D, 0, 6, 0xf4292244);\n      OP (FI, D, A, B, C, 7, 10, 0x432aff97);\n      OP (FI, C, D, A, B, 14, 15, 0xab9423a7);\n      OP (FI, B, C, D, A, 5, 21, 0xfc93a039);\n      OP (FI, A, B, C, D, 12, 6, 0x655b59c3);\n      OP (FI, D, A, B, C, 3, 10, 0x8f0ccc92);\n      OP (FI, C, D, A, B, 10, 15, 0xffeff47d);\n      OP (FI, B, C, D, A, 1, 21, 0x85845dd1);\n      OP (FI, A, B, C, D, 8, 6, 0x6fa87e4f);\n      OP (FI, D, A, B, C, 15, 10, 0xfe2ce6e0);\n      OP (FI, C, D, A, B, 6, 15, 0xa3014314);\n      OP (FI, B, C, D, A, 13, 21, 0x4e0811a1);\n      OP (FI, A, B, C, D, 4, 6, 0xf7537e82);\n      OP (FI, D, A, B, C, 11, 10, 0xbd3af235);\n      OP (FI, C, D, A, B, 2, 15, 0x2ad7d2bb);\n      OP (FI, B, C, D, A, 9, 21, 0xeb86d391);\n\n      /* Add the starting values of the context.  */\n      A += A_save;\n      B += B_save;\n      C += C_save;\n      D += D_save;\n    }\n\n  /* Put checksum in context given as argument.  */\n  ctx->A = A;\n  ctx->B = B;\n  ctx->C = C;\n  ctx->D = D;\n}",
      "lines": 158,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "datamash/datamash-1.3/lib/md5.h": {},
  "datamash/datamash-1.3/lib/memchr.c": {
    "__memchr": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        168,
        1
      ],
      "content": "void *\n__memchr (void const *s, int c_in, size_t n)\n{\n  /* On 32-bit hardware, choosing longword to be a 32-bit unsigned\n     long instead of a 64-bit uintmax_t tends to give better\n     performance.  On 64-bit hardware, unsigned long is generally 64\n     bits already.  Change this typedef to experiment with\n     performance.  */\n  typedef unsigned long int longword;\n\n  const unsigned char *char_ptr;\n  const longword *longword_ptr;\n  longword repeated_one;\n  longword repeated_c;\n  unsigned reg_char c;\n\n  c = (unsigned char) c_in;\n\n  /* Handle the first few bytes by reading one byte at a time.\n     Do this until CHAR_PTR is aligned on a longword boundary.  */\n  for (char_ptr = (const unsigned char *) s;\n       n > 0 && (size_t) char_ptr % sizeof (longword) != 0;\n       --n, ++char_ptr)\n    if (*char_ptr == c)\n      return (void *) char_ptr;\n\n  longword_ptr = (const longword *) char_ptr;\n\n  /* All these elucidatory comments refer to 4-byte longwords,\n     but the theory applies equally well to any size longwords.  */\n\n  /* Compute auxiliary longword values:\n     repeated_one is a value which has a 1 in every byte.\n     repeated_c has c in every byte.  */\n  repeated_one = 0x01010101;\n  repeated_c = c | (c << 8);\n  repeated_c |= repeated_c << 16;\n  if (0xffffffffU < (longword) -1)\n    {\n      repeated_one |= repeated_one << 31 << 1;\n      repeated_c |= repeated_c << 31 << 1;\n      if (8 < sizeof (longword))\n        {\n          size_t i;\n\n          for (i = 64; i < sizeof (longword) * 8; i *= 2)\n            {\n              repeated_one |= repeated_one << i;\n              repeated_c |= repeated_c << i;\n            }\n        }\n    }\n\n  /* Instead of the traditional loop which tests each byte, we will test a\n     longword at a time.  The tricky part is testing if *any of the four*\n     bytes in the longword in question are equal to c.  We first use an xor\n     with repeated_c.  This reduces the task to testing whether *any of the\n     four* bytes in longword1 is zero.\n\n     We compute tmp =\n       ((longword1 - repeated_one) & ~longword1) & (repeated_one << 7).\n     That is, we perform the following operations:\n       1. Subtract repeated_one.\n       2. & ~longword1.\n       3. & a mask consisting of 0x80 in every byte.\n     Consider what happens in each byte:\n       - If a byte of longword1 is zero, step 1 and 2 transform it into 0xff,\n         and step 3 transforms it into 0x80.  A carry can also be propagated\n         to more significant bytes.\n       - If a byte of longword1 is nonzero, let its lowest 1 bit be at\n         position k (0 <= k <= 7); so the lowest k bits are 0.  After step 1,\n         the byte ends in a single bit of value 0 and k bits of value 1.\n         After step 2, the result is just k bits of value 1: 2^k - 1.  After\n         step 3, the result is 0.  And no carry is produced.\n     So, if longword1 has only non-zero bytes, tmp is zero.\n     Whereas if longword1 has a zero byte, call j the position of the least\n     significant zero byte.  Then the result has a zero at positions 0, ...,\n     j-1 and a 0x80 at position j.  We cannot predict the result at the more\n     significant bytes (positions j+1..3), but it does not matter since we\n     already have a non-zero bit at position 8*j+7.\n\n     So, the test whether any byte in longword1 is zero is equivalent to\n     testing whether tmp is nonzero.  */\n\n  while (n >= sizeof (longword))\n    {\n      longword longword1 = *longword_ptr ^ repeated_c;\n\n      if ((((longword1 - repeated_one) & ~longword1)\n           & (repeated_one << 7)) != 0)\n        break;\n      longword_ptr++;\n      n -= sizeof (longword);\n    }\n\n  char_ptr = (const unsigned char *) longword_ptr;\n\n  /* At this point, we know that either n < sizeof (longword), or one of the\n     sizeof (longword) bytes starting at char_ptr is == c.  On little-endian\n     machines, we could determine the first such byte without any further\n     memory accesses, just by looking at the tmp result from the last loop\n     iteration.  But this does not work on big-endian machines.  Choose code\n     that works in both cases.  */\n\n  for (; n > 0; --n, ++char_ptr)\n    {\n      if (*char_ptr == c)\n        return (void *) char_ptr;\n    }\n\n  return NULL;\n}",
      "lines": 112,
      "depth": 14,
      "decorators": [
        "void",
        "*\n__memchr (void const *s, int c_in, size_t n)",
        "*"
      ]
    }
  },
  "datamash/datamash-1.3/lib/minmax.h": {},
  "datamash/datamash-1.3/lib/modf.c": {
    "modf": {
      "start_point": [
        21,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "double\nmodf (double x, double *iptr)\n{\n  if (isfinite (x))\n    {\n      double integer_part = trunc (x);\n      *iptr = integer_part;\n      return x - integer_part;\n    }\n  else\n    {\n      if (isinf (x))\n        {\n          *iptr = x;\n          return 1.0 / x;\n        }\n      else /* isnand (x) */\n        {\n          *iptr = x;\n          return x;\n        }\n    }\n}",
      "lines": 23,
      "depth": 10,
      "decorators": [
        "double"
      ]
    }
  },
  "datamash/datamash-1.3/lib/modfl.c": {
    "modfl": [
      {
        "start_point": [
          23,
          0
        ],
        "end_point": [
          30,
          1
        ],
        "content": "long double\nmodfl (long double x, long double *iptr)\n{\n  double integer_part;\n  double fractional_part = modf (x, &integer_part);\n  *iptr = integer_part;\n  return fractional_part;\n}",
        "lines": 8,
        "depth": 8,
        "decorators": [
          "long double",
          "long",
          "double"
        ]
      },
      {
        "start_point": [
          34,
          0
        ],
        "end_point": [
          56,
          1
        ],
        "content": "long double\nmodfl (long double x, long double *iptr)\n{\n  if (isfinite (x))\n    {\n      long double integer_part = truncl (x);\n      *iptr = integer_part;\n      return x - integer_part;\n    }\n  else\n    {\n      if (isinf (x))\n        {\n          *iptr = x;\n          return 1.0L / x;\n        }\n      else /* isnanl (x) */\n        {\n          *iptr = x;\n          return x;\n        }\n    }\n}",
        "lines": 23,
        "depth": 10,
        "decorators": [
          "long double",
          "long",
          "double"
        ]
      }
    ]
  },
  "datamash/datamash-1.3/lib/msvc-inval.c": {
    "gl_msvc_invalid_parameter_handler": [
      {
        "start_point": [
          30,
          0
        ],
        "end_point": [
          37,
          1
        ],
        "content": "static void __cdecl\ngl_msvc_invalid_parameter_handler (const wchar_t *expression,\n                                   const wchar_t *function,\n                                   const wchar_t *file,\n                                   unsigned int line,\n                                   uintptr_t dummy)\n{\n}",
        "lines": 8,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void",
          "__cdecl",
          "__cdecl"
        ]
      },
      {
        "start_point": [
          47,
          0
        ],
        "end_point": [
          55,
          1
        ],
        "content": "static void __cdecl\ngl_msvc_invalid_parameter_handler (const wchar_t *expression,\n                                   const wchar_t *function,\n                                   const wchar_t *file,\n                                   unsigned int line,\n                                   uintptr_t dummy)\n{\n  RaiseException (STATUS_GNULIB_INVALID_PARAMETER, 0, 0, NULL);\n}",
        "lines": 9,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void",
          "__cdecl",
          "__cdecl"
        ]
      },
      {
        "start_point": [
          96,
          0
        ],
        "end_point": [
          110,
          1
        ],
        "content": "static void __cdecl\ngl_msvc_invalid_parameter_handler (const wchar_t *expression,\n                                   const wchar_t *function,\n                                   const wchar_t *file,\n                                   unsigned int line,\n                                   uintptr_t dummy)\n{\n  struct gl_msvc_inval_per_thread *current = gl_msvc_inval_current ();\n  if (current->restart_valid)\n    longjmp (current->restart, 1);\n  else\n    /* An invalid parameter notification from outside the gnulib code.\n       Give the caller a chance to intervene.  */\n    RaiseException (STATUS_GNULIB_INVALID_PARAMETER, 0, 0, NULL);\n}",
        "lines": 15,
        "depth": 8,
        "decorators": [
          "static",
          "static",
          "void",
          "__cdecl",
          "__cdecl"
        ]
      }
    ],
    "gl_msvc_inval_current": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "struct gl_msvc_inval_per_thread *\ngl_msvc_inval_current (void)\n{\n  if (!tls_initialized)\n    {\n      tls_index = TlsAlloc ();\n      tls_initialized = 1;\n    }\n  if (tls_index == TLS_OUT_OF_INDEXES)\n    /* TlsAlloc had failed.  */\n    return &not_per_thread;\n  else\n    {\n      struct gl_msvc_inval_per_thread *pointer =\n        (struct gl_msvc_inval_per_thread *) TlsGetValue (tls_index);\n      if (pointer == NULL)\n        {\n          /* First call.  Allocate a new 'struct gl_msvc_inval_per_thread'.  */\n          pointer =\n            (struct gl_msvc_inval_per_thread *)\n            malloc (sizeof (struct gl_msvc_inval_per_thread));\n          if (pointer == NULL)\n            /* Could not allocate memory.  Use the global storage.  */\n            pointer = &not_per_thread;\n          TlsSetValue (tls_index, pointer);\n        }\n      return pointer;\n    }\n}",
      "lines": 29,
      "depth": 15,
      "decorators": [
        "struct gl_msvc_inval_per_thread",
        "struct",
        "gl_msvc_inval_per_thread",
        "*\ngl_msvc_inval_current (void)",
        "*"
      ]
    },
    "gl_msvc_inval_ensure_handler": {
      "start_point": [
        118,
        0
      ],
      "end_point": [
        126,
        1
      ],
      "content": "void\ngl_msvc_inval_ensure_handler (void)\n{\n  if (gl_msvc_inval_initialized == 0)\n    {\n      _set_invalid_parameter_handler (gl_msvc_invalid_parameter_handler);\n      gl_msvc_inval_initialized = 1;\n    }\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "datamash/datamash-1.3/lib/msvc-inval.h": {},
  "datamash/datamash-1.3/lib/msvc-nothrow.c": {
    "_gl_nothrow_get_osfhandle": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        41,
        5
      ],
      "content": "intptr_t\n_gl_nothrow_get_osfhandle (int fd)\n{\n  intptr_t result;\n\n  TRY_MSVC_INVAL\n    {\n      result = _get_osfhandle (fd);\n    }",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "intptr_t"
      ]
    }
  },
  "datamash/datamash-1.3/lib/msvc-nothrow.h": {},
  "datamash/datamash-1.3/lib/offtostr.c": {},
  "datamash/datamash-1.3/lib/progname.c": {
    "set_program_name": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        91,
        1
      ],
      "content": "void\nset_program_name (const char *argv0)\n{\n  /* libtool creates a temporary executable whose name is sometimes prefixed\n     with \"lt-\" (depends on the platform).  It also makes argv[0] absolute.\n     But the name of the temporary executable is a detail that should not be\n     visible to the end user and to the test suite.\n     Remove this \"<dirname>/.libs/\" or \"<dirname>/.libs/lt-\" prefix here.  */\n  const char *slash;\n  const char *base;\n\n  /* Sanity check.  POSIX requires the invoking process to pass a non-NULL\n     argv[0].  */\n  if (argv0 == NULL)\n    {\n      /* It's a bug in the invoking program.  Help diagnosing it.  */\n      fputs (\"A NULL argv[0] was passed through an exec system call.\\n\",\n             stderr);\n      abort ();\n    }\n\n  slash = strrchr (argv0, '/');\n  base = (slash != NULL ? slash + 1 : argv0);\n  if (base - argv0 >= 7 && strncmp (base - 7, \"/.libs/\", 7) == 0)\n    {\n      argv0 = base;\n      if (strncmp (base, \"lt-\", 3) == 0)\n        {\n          argv0 = base + 3;\n          /* On glibc systems, remove the \"lt-\" prefix from the variable\n             program_invocation_short_name.  */\n#if HAVE_DECL_PROGRAM_INVOCATION_SHORT_NAME\n          program_invocation_short_name = (char *) argv0;\n#endif\n        }\n    }\n\n  /* But don't strip off a leading <dirname>/ in general, because when the user\n     runs\n         /some/hidden/place/bin/cp foo foo\n     he should get the error message\n         /some/hidden/place/bin/cp: `foo' and `foo' are the same file\n     not\n         cp: `foo' and `foo' are the same file\n   */\n\n  program_name = argv0;\n\n  /* On glibc systems, the error() function comes from libc and uses the\n     variable program_invocation_name, not program_name.  So set this variable\n     as well.  */\n#if HAVE_DECL_PROGRAM_INVOCATION_NAME\n  program_invocation_name = (char *) argv0;\n#endif\n}",
      "lines": 55,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "datamash/datamash-1.3/lib/progname.h": {},
  "datamash/datamash-1.3/lib/propername.c": {
    "mbsstr_trimmed_wordbounded": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        152,
        1
      ],
      "content": "static bool\nmbsstr_trimmed_wordbounded (const char *string, const char *sub)\n{\n  char *tsub = trim (sub);\n  bool found = false;\n\n  for (; *string != '\\0';)\n    {\n      const char *tsub_in_string = mbsstr (string, tsub);\n      if (tsub_in_string == NULL)\n        break;\n      else\n        {\n          if (MB_CUR_MAX > 1)\n            {\n              mbui_iterator_t string_iter;\n              bool word_boundary_before;\n              bool word_boundary_after;\n\n              mbui_init (string_iter, string);\n              word_boundary_before = true;\n              if (mbui_cur_ptr (string_iter) < tsub_in_string)\n                {\n                  mbchar_t last_char_before_tsub;\n                  do\n                    {\n                      if (!mbui_avail (string_iter))\n                        abort ();\n                      last_char_before_tsub = mbui_cur (string_iter);\n                      mbui_advance (string_iter);\n                    }\n                  while (mbui_cur_ptr (string_iter) < tsub_in_string);\n                  if (mb_isalnum (last_char_before_tsub))\n                    word_boundary_before = false;\n                }\n\n              mbui_init (string_iter, tsub_in_string);\n              {\n                mbui_iterator_t tsub_iter;\n\n                for (mbui_init (tsub_iter, tsub);\n                     mbui_avail (tsub_iter);\n                     mbui_advance (tsub_iter))\n                  {\n                    if (!mbui_avail (string_iter))\n                      abort ();\n                    mbui_advance (string_iter);\n                  }\n              }\n              word_boundary_after = true;\n              if (mbui_avail (string_iter))\n                {\n                  mbchar_t first_char_after_tsub = mbui_cur (string_iter);\n                  if (mb_isalnum (first_char_after_tsub))\n                    word_boundary_after = false;\n                }\n\n              if (word_boundary_before && word_boundary_after)\n                {\n                  found = true;\n                  break;\n                }\n\n              mbui_init (string_iter, tsub_in_string);\n              if (!mbui_avail (string_iter))\n                break;\n              string = tsub_in_string + mb_len (mbui_cur (string_iter));\n            }\n          else\n            {\n              bool word_boundary_before;\n              const char *p;\n              bool word_boundary_after;\n\n              word_boundary_before = true;\n              if (string < tsub_in_string)\n                if (isalnum ((unsigned char) tsub_in_string[-1]))\n                  word_boundary_before = false;\n\n              p = tsub_in_string + strlen (tsub);\n              word_boundary_after = true;\n              if (*p != '\\0')\n                if (isalnum ((unsigned char) *p))\n                  word_boundary_after = false;\n\n              if (word_boundary_before && word_boundary_after)\n                {\n                  found = true;\n                  break;\n                }\n\n              if (*tsub_in_string == '\\0')\n                break;\n              string = tsub_in_string + 1;\n            }\n        }\n    }\n  free (tsub);\n  return found;\n}",
      "lines": 100,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "proper_name": {
      "start_point": [
        156,
        0
      ],
      "end_point": [
        179,
        1
      ],
      "content": "const char *\nproper_name (const char *name)\n{\n  /* See whether there is a translation.   */\n  const char *translation = gettext (name);\n\n  if (translation != name)\n    {\n      /* See whether the translation contains the original name.  */\n      if (mbsstr_trimmed_wordbounded (translation, name))\n        return translation;\n      else\n        {\n          /* Return \"TRANSLATION (NAME)\".  */\n          char *result =\n            XNMALLOC (strlen (translation) + 2 + strlen (name) + 1 + 1, char);\n\n          sprintf (result, \"%s (%s)\", translation, name);\n          return result;\n        }\n    }\n  else\n    return name;\n}",
      "lines": 24,
      "depth": 17,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nproper_name (const char *name)",
        "*"
      ]
    },
    "proper_name_utf8": {
      "start_point": [
        186,
        0
      ],
      "end_point": [
        293,
        1
      ],
      "content": "const char *\nproper_name_utf8 (const char *name_ascii, const char *name_utf8)\n{\n  /* See whether there is a translation.   */\n  const char *translation = gettext (name_ascii);\n\n  /* Try to convert NAME_UTF8 to the locale encoding.  */\n  const char *locale_code = locale_charset ();\n  char *alloc_name_converted = NULL;\n  char *alloc_name_converted_translit = NULL;\n  const char *name_converted = NULL;\n  const char *name_converted_translit = NULL;\n  const char *name;\n\n  if (c_strcasecmp (locale_code, \"UTF-8\") != 0)\n    {\n#if HAVE_ICONV\n      name_converted = alloc_name_converted =\n        xstr_iconv (name_utf8, \"UTF-8\", locale_code);\n\n# if (((__GLIBC__ == 2 && __GLIBC_MINOR__ >= 2) || __GLIBC__ > 2) \\\n      && !defined __UCLIBC__) \\\n     || _LIBICONV_VERSION >= 0x0105\n      {\n        char *converted_translit;\n\n        size_t len = strlen (locale_code);\n        char *locale_code_translit = XNMALLOC (len + 10 + 1, char);\n        memcpy (locale_code_translit, locale_code, len);\n        memcpy (locale_code_translit + len, \"//TRANSLIT\", 10 + 1);\n\n        converted_translit =\n          xstr_iconv (name_utf8, \"UTF-8\", locale_code_translit);\n\n        free (locale_code_translit);\n\n        if (converted_translit != NULL)\n          {\n#  if !_LIBICONV_VERSION\n            /* Don't use the transliteration if it added question marks.\n               glibc's transliteration falls back to question marks; libiconv's\n               transliteration does not.\n               mbschr is equivalent to strchr in this case.  */\n            if (strchr (converted_translit, '?') != NULL)\n              free (converted_translit);\n            else\n#  endif\n              name_converted_translit = alloc_name_converted_translit =\n                converted_translit;\n          }\n      }\n# endif\n#endif\n    }\n  else\n    {\n      name_converted = name_utf8;\n      name_converted_translit = name_utf8;\n    }\n\n  /* The name in locale encoding.  */\n  name = (name_converted != NULL ? name_converted :\n          name_converted_translit != NULL ? name_converted_translit :\n          name_ascii);\n\n  /* See whether we have a translation.  Some translators have not understood\n     that they should use the UTF-8 form of the name, if possible.  So if the\n     translator provided a no-op translation, we ignore it.  */\n  if (strcmp (translation, name_ascii) != 0)\n    {\n      /* See whether the translation contains the original name.  */\n      if (mbsstr_trimmed_wordbounded (translation, name_ascii)\n          || (name_converted != NULL\n              && mbsstr_trimmed_wordbounded (translation, name_converted))\n          || (name_converted_translit != NULL\n              && mbsstr_trimmed_wordbounded (translation, name_converted_translit)))\n        {\n          if (alloc_name_converted != NULL)\n            free (alloc_name_converted);\n          if (alloc_name_converted_translit != NULL)\n            free (alloc_name_converted_translit);\n          return translation;\n        }\n      else\n        {\n          /* Return \"TRANSLATION (NAME)\".  */\n          char *result =\n            XNMALLOC (strlen (translation) + 2 + strlen (name) + 1 + 1, char);\n\n          sprintf (result, \"%s (%s)\", translation, name);\n\n          if (alloc_name_converted != NULL)\n            free (alloc_name_converted);\n          if (alloc_name_converted_translit != NULL)\n            free (alloc_name_converted_translit);\n          return result;\n        }\n    }\n  else\n    {\n      if (alloc_name_converted != NULL && alloc_name_converted != name)\n        free (alloc_name_converted);\n      if (alloc_name_converted_translit != NULL\n          && alloc_name_converted_translit != name)\n        free (alloc_name_converted_translit);\n      return name;\n    }\n}",
      "lines": 108,
      "depth": 17,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nproper_name_utf8 (const char *name_ascii, const char *name_utf8)",
        "*"
      ]
    },
    "main": [
      {
        "start_point": [
          297,
          0
        ],
        "end_point": [
          304,
          1
        ],
        "content": "int\nmain (int argc, char *argv[])\n{\n  setlocale (LC_ALL, \"\");\n  if (mbsstr_trimmed_wordbounded (argv[1], argv[2]))\n    printf(\"found\\n\");\n  return 0;\n}",
        "lines": 8,
        "depth": 8,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          310,
          0
        ],
        "end_point": [
          316,
          1
        ],
        "content": "int\nmain (int argc, char *argv[])\n{\n  setlocale (LC_ALL, \"\");\n  printf (\"%s\\n\", proper_name_utf8 (\"Franc,ois Pinard\", \"Fran\\303\\247ois Pinard\"));\n  return 0;\n}",
        "lines": 7,
        "depth": 9,
        "decorators": [
          "int"
        ]
      }
    ]
  },
  "datamash/datamash-1.3/lib/propername.h": {},
  "datamash/datamash-1.3/lib/quote.h": {},
  "datamash/datamash-1.3/lib/quotearg.c": {
    "clone_quoting_options": {
      "start_point": [
        120,
        0
      ],
      "end_point": [
        128,
        1
      ],
      "content": "struct quoting_options *\nclone_quoting_options (struct quoting_options *o)\n{\n  int e = errno;\n  struct quoting_options *p = xmemdup (o ? o : &default_quoting_options,\n                                       sizeof *o);\n  errno = e;\n  return p;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "struct quoting_options",
        "struct",
        "quoting_options",
        "*\nclone_quoting_options (struct quoting_options *o)",
        "*"
      ]
    },
    "get_quoting_style": {
      "start_point": [
        131,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "enum quoting_style\nget_quoting_style (struct quoting_options const *o)\n{\n  return (o ? o : &default_quoting_options)->style;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "enum quoting_style",
        "enum",
        "quoting_style"
      ]
    },
    "set_quoting_style": {
      "start_point": [
        139,
        0
      ],
      "end_point": [
        143,
        1
      ],
      "content": "void\nset_quoting_style (struct quoting_options *o, enum quoting_style s)\n{\n  (o ? o : &default_quoting_options)->style = s;\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "set_char_quoting": {
      "start_point": [
        150,
        0
      ],
      "end_point": [
        160,
        1
      ],
      "content": "int\nset_char_quoting (struct quoting_options *o, char c, int i)\n{\n  unsigned char uc = c;\n  unsigned int *p =\n    (o ? o : &default_quoting_options)->quote_these_too + uc / INT_BITS;\n  int shift = uc % INT_BITS;\n  int r = (*p >> shift) & 1;\n  *p ^= ((i & 1) ^ r) << shift;\n  return r;\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "set_quoting_flags": {
      "start_point": [
        166,
        0
      ],
      "end_point": [
        175,
        1
      ],
      "content": "int\nset_quoting_flags (struct quoting_options *o, int i)\n{\n  int r;\n  if (!o)\n    o = &default_quoting_options;\n  r = o->flags;\n  o->flags = i;\n  return r;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "set_custom_quoting": {
      "start_point": [
        177,
        0
      ],
      "end_point": [
        188,
        1
      ],
      "content": "void\nset_custom_quoting (struct quoting_options *o,\n                    char const *left_quote, char const *right_quote)\n{\n  if (!o)\n    o = &default_quoting_options;\n  o->style = custom_quoting_style;\n  if (!left_quote || !right_quote)\n    abort ();\n  o->left_quote = left_quote;\n  o->right_quote = right_quote;\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "quoting_options_from_style": {
      "start_point": [
        191,
        0
      ],
      "end_point": [
        199,
        1
      ],
      "content": "static struct quoting_options /* NOT PURE!! */\nquoting_options_from_style (enum quoting_style style)\n{\n  struct quoting_options o = { literal_quoting_style, 0, { 0 }, NULL, NULL };\n  if (style == custom_quoting_style)\n    abort ();\n  o.style = style;\n  return o;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "struct quoting_options",
        "struct",
        "quoting_options",
        "/* NOT PURE!! */"
      ]
    },
    "gettext_quote": {
      "start_point": [
        205,
        0
      ],
      "end_point": [
        239,
        1
      ],
      "content": "static char const *\ngettext_quote (char const *msgid, enum quoting_style s)\n{\n  char const *translation = _(msgid);\n  char const *locale_code;\n\n  if (translation != msgid)\n    return translation;\n\n  /* For UTF-8 and GB-18030, use single quotes U+2018 and U+2019.\n     Here is a list of other locales that include U+2018 and U+2019:\n\n        ISO-8859-7   0xA1                 KOI8-T       0x91\n        CP869        0x8B                 CP874        0x91\n        CP932        0x81 0x65            CP936        0xA1 0xAE\n        CP949        0xA1 0xAE            CP950        0xA1 0xA5\n        CP1250       0x91                 CP1251       0x91\n        CP1252       0x91                 CP1253       0x91\n        CP1254       0x91                 CP1255       0x91\n        CP1256       0x91                 CP1257       0x91\n        EUC-JP       0xA1 0xC6            EUC-KR       0xA1 0xAE\n        EUC-TW       0xA1 0xE4            BIG5         0xA1 0xA5\n        BIG5-HKSCS   0xA1 0xA5            EUC-CN       0xA1 0xAE\n        GBK          0xA1 0xAE            Georgian-PS  0x91\n        PT154        0x91\n\n     None of these is still in wide use; using iconv is overkill.  */\n  locale_code = locale_charset ();\n  if (STRCASEEQ (locale_code, \"UTF-8\", 'U','T','F','-','8',0,0,0,0))\n    return msgid[0] == '`' ? \"\\xe2\\x80\\x98\": \"\\xe2\\x80\\x99\";\n  if (STRCASEEQ (locale_code, \"GB18030\", 'G','B','1','8','0','3','0',0,0))\n    return msgid[0] == '`' ? \"\\xa1\\ae\": \"\\xa1\\xaf\";\n\n  return (s == clocale_quoting_style ? \"\\\"\" : \"'\");\n}",
      "lines": 35,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "char",
        "const",
        "const",
        "*\ngettext_quote (char const *msgid, enum quoting_style s)",
        "*"
      ]
    },
    "quotearg_buffer_restyled": {
      "start_point": [
        254,
        0
      ],
      "end_point": [
        771,
        1
      ],
      "content": "static size_t\nquotearg_buffer_restyled (char *buffer, size_t buffersize,\n                          char const *arg, size_t argsize,\n                          enum quoting_style quoting_style, int flags,\n                          unsigned int const *quote_these_too,\n                          char const *left_quote,\n                          char const *right_quote)\n{\n  size_t i;\n  size_t len = 0;\n  size_t orig_buffersize = 0;\n  char const *quote_string = 0;\n  size_t quote_string_len = 0;\n  bool backslash_escapes = false;\n  bool unibyte_locale = MB_CUR_MAX == 1;\n  bool elide_outer_quotes = (flags & QA_ELIDE_OUTER_QUOTES) != 0;\n  bool pending_shell_escape_end = false;\n  bool encountered_single_quote = false;\n  bool all_c_and_shell_quote_compat = true;\n\n#define STORE(c) \\\n    do \\\n      { \\\n        if (len < buffersize) \\\n          buffer[len] = (c); \\\n        len++; \\\n      } \\\n    while (0)\n\n#define START_ESC() \\\n    do \\\n      { \\\n        if (elide_outer_quotes) \\\n          goto force_outer_quoting_style; \\\n        escaping = true; \\\n        if (quoting_style == shell_always_quoting_style \\\n            && ! pending_shell_escape_end) \\\n          { \\\n            STORE ('\\''); \\\n            STORE ('$'); \\\n            STORE ('\\''); \\\n            pending_shell_escape_end = true; \\\n          } \\\n        STORE ('\\\\'); \\\n      } \\\n    while (0)\n\n#define END_ESC() \\\n    do \\\n      { \\\n        if (pending_shell_escape_end && ! escaping) \\\n          { \\\n            STORE ('\\''); \\\n            STORE ('\\''); \\\n            pending_shell_escape_end = false; \\\n          } \\\n      } \\\n    while (0)\n\n process_input:\n\n  switch (quoting_style)\n    {\n    case c_maybe_quoting_style:\n      quoting_style = c_quoting_style;\n      elide_outer_quotes = true;\n      FALLTHROUGH;\n    case c_quoting_style:\n      if (!elide_outer_quotes)\n        STORE ('\"');\n      backslash_escapes = true;\n      quote_string = \"\\\"\";\n      quote_string_len = 1;\n      break;\n\n    case escape_quoting_style:\n      backslash_escapes = true;\n      elide_outer_quotes = false;\n      break;\n\n    case locale_quoting_style:\n    case clocale_quoting_style:\n    case custom_quoting_style:\n      {\n        if (quoting_style != custom_quoting_style)\n          {\n            /* TRANSLATORS:\n               Get translations for open and closing quotation marks.\n               The message catalog should translate \"`\" to a left\n               quotation mark suitable for the locale, and similarly for\n               \"'\".  For example, a French Unicode local should translate\n               these to U+00AB (LEFT-POINTING DOUBLE ANGLE\n               QUOTATION MARK), and U+00BB (RIGHT-POINTING DOUBLE ANGLE\n               QUOTATION MARK), respectively.\n\n               If the catalog has no translation, we will try to\n               use Unicode U+2018 (LEFT SINGLE QUOTATION MARK) and\n               Unicode U+2019 (RIGHT SINGLE QUOTATION MARK).  If the\n               current locale is not Unicode, locale_quoting_style\n               will quote 'like this', and clocale_quoting_style will\n               quote \"like this\".  You should always include translations\n               for \"`\" and \"'\" even if U+2018 and U+2019 are appropriate\n               for your locale.\n\n               If you don't know what to put here, please see\n               <https://en.wikipedia.org/wiki/Quotation_marks_in_other_languages>\n               and use glyphs suitable for your language.  */\n            left_quote = gettext_quote (N_(\"`\"), quoting_style);\n            right_quote = gettext_quote (N_(\"'\"), quoting_style);\n          }\n        if (!elide_outer_quotes)\n          for (quote_string = left_quote; *quote_string; quote_string++)\n            STORE (*quote_string);\n        backslash_escapes = true;\n        quote_string = right_quote;\n        quote_string_len = strlen (quote_string);\n      }\n      break;\n\n    case shell_escape_quoting_style:\n      backslash_escapes = true;\n      FALLTHROUGH;\n    case shell_quoting_style:\n      elide_outer_quotes = true;\n      FALLTHROUGH;\n    case shell_escape_always_quoting_style:\n      if (!elide_outer_quotes)\n        backslash_escapes = true;\n      FALLTHROUGH;\n    case shell_always_quoting_style:\n      quoting_style = shell_always_quoting_style;\n      if (!elide_outer_quotes)\n        STORE ('\\'');\n      quote_string = \"'\";\n      quote_string_len = 1;\n      break;\n\n    case literal_quoting_style:\n      elide_outer_quotes = false;\n      break;\n\n    default:\n      abort ();\n    }\n\n  for (i = 0;  ! (argsize == SIZE_MAX ? arg[i] == '\\0' : i == argsize);  i++)\n    {\n      unsigned char c;\n      unsigned char esc;\n      bool is_right_quote = false;\n      bool escaping = false;\n      bool c_and_shell_quote_compat = false;\n\n      if (backslash_escapes\n          && quoting_style != shell_always_quoting_style\n          && quote_string_len\n          && (i + quote_string_len\n              <= (argsize == SIZE_MAX && 1 < quote_string_len\n                  /* Use strlen only if we must: when argsize is SIZE_MAX,\n                     and when the quote string is more than 1 byte long.\n                     If we do call strlen, save the result.  */\n                  ? (argsize = strlen (arg)) : argsize))\n          && memcmp (arg + i, quote_string, quote_string_len) == 0)\n        {\n          if (elide_outer_quotes)\n            goto force_outer_quoting_style;\n          is_right_quote = true;\n        }\n\n      c = arg[i];\n      switch (c)\n        {\n        case '\\0':\n          if (backslash_escapes)\n            {\n              START_ESC ();\n              /* If quote_string were to begin with digits, we'd need to\n                 test for the end of the arg as well.  However, it's\n                 hard to imagine any locale that would use digits in\n                 quotes, and set_custom_quoting is documented not to\n                 accept them.  Use only a single \\0 with shell-escape\n                 as currently digits are not printed within $'...'  */\n              if (quoting_style != shell_always_quoting_style\n                  && i + 1 < argsize && '0' <= arg[i + 1] && arg[i + 1] <= '9')\n                {\n                  STORE ('0');\n                  STORE ('0');\n                }\n              c = '0';\n              /* We don't have to worry that this last '0' will be\n                 backslash-escaped because, again, quote_string should\n                 not start with it and because quote_these_too is\n                 documented as not accepting it.  */\n            }\n          else if (flags & QA_ELIDE_NULL_BYTES)\n            continue;\n          break;\n\n        case '?':\n          switch (quoting_style)\n            {\n            case shell_always_quoting_style:\n              if (elide_outer_quotes)\n                goto force_outer_quoting_style;\n              break;\n\n            case c_quoting_style:\n              if ((flags & QA_SPLIT_TRIGRAPHS)\n                  && i + 2 < argsize && arg[i + 1] == '?')\n                switch (arg[i + 2])\n                  {\n                  case '!': case '\\'':\n                  case '(': case ')': case '-': case '/':\n                  case '<': case '=': case '>':\n                    /* Escape the second '?' in what would otherwise be\n                       a trigraph.  */\n                    if (elide_outer_quotes)\n                      goto force_outer_quoting_style;\n                    c = arg[i + 2];\n                    i += 2;\n                    STORE ('?');\n                    STORE ('\"');\n                    STORE ('\"');\n                    STORE ('?');\n                    break;\n\n                  default:\n                    break;\n                  }\n              break;\n\n            default:\n              break;\n            }\n          break;\n\n        case '\\a': esc = 'a'; goto c_escape;\n        case '\\b': esc = 'b'; goto c_escape;\n        case '\\f': esc = 'f'; goto c_escape;\n        case '\\n': esc = 'n'; goto c_and_shell_escape;\n        case '\\r': esc = 'r'; goto c_and_shell_escape;\n        case '\\t': esc = 't'; goto c_and_shell_escape;\n        case '\\v': esc = 'v'; goto c_escape;\n        case '\\\\': esc = c;\n          /* Never need to escape '\\' in shell case.  */\n          if (quoting_style == shell_always_quoting_style)\n            {\n              if (elide_outer_quotes)\n                goto force_outer_quoting_style;\n              goto store_c;\n            }\n\n          /* No need to escape the escape if we are trying to elide\n             outer quotes and nothing else is problematic.  */\n          if (backslash_escapes && elide_outer_quotes && quote_string_len)\n            goto store_c;\n\n        c_and_shell_escape:\n          if (quoting_style == shell_always_quoting_style\n              && elide_outer_quotes)\n            goto force_outer_quoting_style;\n          /* fall through */\n        c_escape:\n          if (backslash_escapes)\n            {\n              c = esc;\n              goto store_escape;\n            }\n          break;\n\n        case '{': case '}': /* sometimes special if isolated */\n          if (! (argsize == SIZE_MAX ? arg[1] == '\\0' : argsize == 1))\n            break;\n          FALLTHROUGH;\n        case '#': case '~':\n          if (i != 0)\n            break;\n          FALLTHROUGH;\n        case ' ':\n          c_and_shell_quote_compat = true;\n          FALLTHROUGH;\n        case '!': /* special in bash */\n        case '\"': case '$': case '&':\n        case '(': case ')': case '*': case ';':\n        case '<':\n        case '=': /* sometimes special in 0th or (with \"set -k\") later args */\n        case '>': case '[':\n        case '^': /* special in old /bin/sh, e.g. SunOS 4.1.4 */\n        case '`': case '|':\n          /* A shell special character.  In theory, '$' and '`' could\n             be the first bytes of multibyte characters, which means\n             we should check them with mbrtowc, but in practice this\n             doesn't happen so it's not worth worrying about.  */\n          if (quoting_style == shell_always_quoting_style\n              && elide_outer_quotes)\n            goto force_outer_quoting_style;\n          break;\n\n        case '\\'':\n          encountered_single_quote = true;\n          c_and_shell_quote_compat = true;\n          if (quoting_style == shell_always_quoting_style)\n            {\n              if (elide_outer_quotes)\n                goto force_outer_quoting_style;\n\n              if (buffersize && ! orig_buffersize)\n                {\n                  /* Just scan string to see if supports a more concise\n                     representation, rather than writing a longer string\n                     but returning the length of the more concise form.  */\n                  orig_buffersize = buffersize;\n                  buffersize = 0;\n                }\n\n              STORE ('\\'');\n              STORE ('\\\\');\n              STORE ('\\'');\n              pending_shell_escape_end = false;\n            }\n          break;\n\n        case '%': case '+': case ',': case '-': case '.': case '/':\n        case '0': case '1': case '2': case '3': case '4': case '5':\n        case '6': case '7': case '8': case '9': case ':':\n        case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n        case 'G': case 'H': case 'I': case 'J': case 'K': case 'L':\n        case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':\n        case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n        case 'Y': case 'Z': case ']': case '_': case 'a': case 'b':\n        case 'c': case 'd': case 'e': case 'f': case 'g': case 'h':\n        case 'i': case 'j': case 'k': case 'l': case 'm': case 'n':\n        case 'o': case 'p': case 'q': case 'r': case 's': case 't':\n        case 'u': case 'v': case 'w': case 'x': case 'y': case 'z':\n          /* These characters don't cause problems, no matter what the\n             quoting style is.  They cannot start multibyte sequences.\n             A digit or a special letter would cause trouble if it\n             appeared at the beginning of quote_string because we'd then\n             escape by prepending a backslash.  However, it's hard to\n             imagine any locale that would use digits or letters as\n             quotes, and set_custom_quoting is documented not to accept\n             them.  Also, a digit or a special letter would cause\n             trouble if it appeared in quote_these_too, but that's also\n             documented as not accepting them.  */\n          c_and_shell_quote_compat = true;\n          break;\n\n        default:\n          /* If we have a multibyte sequence, copy it until we reach\n             its end, find an error, or come back to the initial shift\n             state.  For C-like styles, if the sequence has\n             unprintable characters, escape the whole sequence, since\n             we can't easily escape single characters within it.  */\n          {\n            /* Length of multibyte sequence found so far.  */\n            size_t m;\n\n            bool printable;\n\n            if (unibyte_locale)\n              {\n                m = 1;\n                printable = isprint (c) != 0;\n              }\n            else\n              {\n                mbstate_t mbstate;\n                memset (&mbstate, 0, sizeof mbstate);\n\n                m = 0;\n                printable = true;\n                if (argsize == SIZE_MAX)\n                  argsize = strlen (arg);\n\n                do\n                  {\n                    wchar_t w;\n                    size_t bytes = mbrtowc (&w, &arg[i + m],\n                                            argsize - (i + m), &mbstate);\n                    if (bytes == 0)\n                      break;\n                    else if (bytes == (size_t) -1)\n                      {\n                        printable = false;\n                        break;\n                      }\n                    else if (bytes == (size_t) -2)\n                      {\n                        printable = false;\n                        while (i + m < argsize && arg[i + m])\n                          m++;\n                        break;\n                      }\n                    else\n                      {\n                        /* Work around a bug with older shells that \"see\" a '\\'\n                           that is really the 2nd byte of a multibyte character.\n                           In practice the problem is limited to ASCII\n                           chars >= '@' that are shell special chars.  */\n                        if ('[' == 0x5b && elide_outer_quotes\n                            && quoting_style == shell_always_quoting_style)\n                          {\n                            size_t j;\n                            for (j = 1; j < bytes; j++)\n                              switch (arg[i + m + j])\n                                {\n                                case '[': case '\\\\': case '^':\n                                case '`': case '|':\n                                  goto force_outer_quoting_style;\n\n                                default:\n                                  break;\n                                }\n                          }\n\n                        if (! iswprint (w))\n                          printable = false;\n                        m += bytes;\n                      }\n                  }\n                while (! mbsinit (&mbstate));\n              }\n\n            c_and_shell_quote_compat = printable;\n\n            if (1 < m || (backslash_escapes && ! printable))\n              {\n                /* Output a multibyte sequence, or an escaped\n                   unprintable unibyte character.  */\n                size_t ilim = i + m;\n\n                for (;;)\n                  {\n                    if (backslash_escapes && ! printable)\n                      {\n                        START_ESC ();\n                        STORE ('0' + (c >> 6));\n                        STORE ('0' + ((c >> 3) & 7));\n                        c = '0' + (c & 7);\n                      }\n                    else if (is_right_quote)\n                      {\n                        STORE ('\\\\');\n                        is_right_quote = false;\n                      }\n                    if (ilim <= i + 1)\n                      break;\n                    END_ESC ();\n                    STORE (c);\n                    c = arg[++i];\n                  }\n\n                goto store_c;\n              }\n          }\n        }\n\n      if (! (((backslash_escapes && quoting_style != shell_always_quoting_style)\n              || elide_outer_quotes)\n             && quote_these_too\n             && quote_these_too[c / INT_BITS] >> (c % INT_BITS) & 1)\n          && !is_right_quote)\n        goto store_c;\n\n    store_escape:\n      START_ESC ();\n\n    store_c:\n      END_ESC ();\n      STORE (c);\n\n      if (! c_and_shell_quote_compat)\n        all_c_and_shell_quote_compat = false;\n    }\n\n  if (len == 0 && quoting_style == shell_always_quoting_style\n      && elide_outer_quotes)\n    goto force_outer_quoting_style;\n\n  /* Single shell quotes (') are commonly enough used as an apostrophe,\n     that we attempt to minimize the quoting in this case.  Note it\u00ca\u00bcs\n     better to use the apostrophe modifier \"\\u02BC\" if possible, as that\n     renders better and works with the word match regex \\W+ etc.  */\n  if (quoting_style == shell_always_quoting_style && ! elide_outer_quotes\n      && encountered_single_quote)\n    {\n      if (all_c_and_shell_quote_compat)\n        return quotearg_buffer_restyled (buffer, orig_buffersize, arg, argsize,\n                                         c_quoting_style,\n                                         flags, quote_these_too,\n                                         left_quote, right_quote);\n      else if (! buffersize && orig_buffersize)\n        {\n          /* Disable read-only scan, and reprocess to write quoted string.  */\n          buffersize = orig_buffersize;\n          len = 0;\n          goto process_input;\n        }\n    }\n\n  if (quote_string && !elide_outer_quotes)\n    for (; *quote_string; quote_string++)\n      STORE (*quote_string);\n\n  if (len < buffersize)\n    buffer[len] = '\\0';\n  return len;\n\n force_outer_quoting_style:\n  /* Don't reuse quote_these_too, since the addition of outer quotes\n     sufficiently quotes the specified characters.  */\n  if (quoting_style == shell_always_quoting_style && backslash_escapes)\n    quoting_style = shell_escape_always_quoting_style;\n  return quotearg_buffer_restyled (buffer, buffersize, arg, argsize,\n                                   quoting_style,\n                                   flags & ~QA_ELIDE_OUTER_QUOTES, NULL,\n                                   left_quote, right_quote);\n}",
      "lines": 518,
      "depth": 25,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "quotearg_buffer": {
      "start_point": [
        782,
        0
      ],
      "end_point": [
        794,
        1
      ],
      "content": "size_t\nquotearg_buffer (char *buffer, size_t buffersize,\n                 char const *arg, size_t argsize,\n                 struct quoting_options const *o)\n{\n  struct quoting_options const *p = o ? o : &default_quoting_options;\n  int e = errno;\n  size_t r = quotearg_buffer_restyled (buffer, buffersize, arg, argsize,\n                                       p->style, p->flags, p->quote_these_too,\n                                       p->left_quote, p->right_quote);\n  errno = e;\n  return r;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "size_t"
      ]
    },
    "quotearg_alloc": {
      "start_point": [
        797,
        0
      ],
      "end_point": [
        802,
        1
      ],
      "content": "char *\nquotearg_alloc (char const *arg, size_t argsize,\n                struct quoting_options const *o)\n{\n  return quotearg_alloc_mem (arg, argsize, NULL, o);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_alloc (char const *arg, size_t argsize,\n                struct quoting_options const *o)",
        "*"
      ]
    },
    "quotearg_alloc_mem": {
      "start_point": [
        810,
        0
      ],
      "end_point": [
        830,
        1
      ],
      "content": "char *\nquotearg_alloc_mem (char const *arg, size_t argsize, size_t *size,\n                    struct quoting_options const *o)\n{\n  struct quoting_options const *p = o ? o : &default_quoting_options;\n  int e = errno;\n  /* Elide embedded null bytes if we can't return a size.  */\n  int flags = p->flags | (size ? 0 : QA_ELIDE_NULL_BYTES);\n  size_t bufsize = quotearg_buffer_restyled (0, 0, arg, argsize, p->style,\n                                             flags, p->quote_these_too,\n                                             p->left_quote,\n                                             p->right_quote) + 1;\n  char *buf = xcharalloc (bufsize);\n  quotearg_buffer_restyled (buf, bufsize, arg, argsize, p->style, flags,\n                            p->quote_these_too,\n                            p->left_quote, p->right_quote);\n  errno = e;\n  if (size)\n    *size = bufsize - 1;\n  return buf;\n}",
      "lines": 21,
      "depth": 9,
      "decorators": [
        "char",
        "*\nquotearg_alloc_mem (char const *arg, size_t argsize, size_t *size,\n                    struct quoting_options const *o)",
        "*"
      ]
    },
    "quotearg_free": {
      "start_point": [
        846,
        0
      ],
      "end_point": [
        865,
        1
      ],
      "content": "void\nquotearg_free (void)\n{\n  struct slotvec *sv = slotvec;\n  int i;\n  for (i = 1; i < nslots; i++)\n    free (sv[i].val);\n  if (sv[0].val != slot0)\n    {\n      free (sv[0].val);\n      slotvec0.size = sizeof slot0;\n      slotvec0.val = slot0;\n    }\n  if (sv != &slotvec0)\n    {\n      free (sv);\n      slotvec = &slotvec0;\n    }\n  nslots = 1;\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "quotearg_n_options": {
      "start_point": [
        875,
        0
      ],
      "end_point": [
        927,
        1
      ],
      "content": "static char *\nquotearg_n_options (int n, char const *arg, size_t argsize,\n                    struct quoting_options const *options)\n{\n  int e = errno;\n\n  struct slotvec *sv = slotvec;\n\n  if (n < 0)\n    abort ();\n\n  if (nslots <= n)\n    {\n      bool preallocated = (sv == &slotvec0);\n      int nmax = MIN (INT_MAX, MIN (PTRDIFF_MAX, SIZE_MAX) / sizeof *sv) - 1;\n\n      if (nmax < n)\n        xalloc_die ();\n\n      slotvec = sv = xrealloc (preallocated ? NULL : sv, (n + 1) * sizeof *sv);\n      if (preallocated)\n        *sv = slotvec0;\n      memset (sv + nslots, 0, (n + 1 - nslots) * sizeof *sv);\n      nslots = n + 1;\n    }\n\n  {\n    size_t size = sv[n].size;\n    char *val = sv[n].val;\n    /* Elide embedded null bytes since we don't return a size.  */\n    int flags = options->flags | QA_ELIDE_NULL_BYTES;\n    size_t qsize = quotearg_buffer_restyled (val, size, arg, argsize,\n                                             options->style, flags,\n                                             options->quote_these_too,\n                                             options->left_quote,\n                                             options->right_quote);\n\n    if (size <= qsize)\n      {\n        sv[n].size = size = qsize + 1;\n        if (val != slot0)\n          free (val);\n        sv[n].val = val = xcharalloc (size);\n        quotearg_buffer_restyled (val, size, arg, argsize, options->style,\n                                  flags, options->quote_these_too,\n                                  options->left_quote,\n                                  options->right_quote);\n      }\n\n    errno = e;\n    return val;\n  }\n}",
      "lines": 53,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nquotearg_n_options (int n, char const *arg, size_t argsize,\n                    struct quoting_options const *options)",
        "*"
      ]
    },
    "quotearg_n": {
      "start_point": [
        929,
        0
      ],
      "end_point": [
        933,
        1
      ],
      "content": "char *\nquotearg_n (int n, char const *arg)\n{\n  return quotearg_n_options (n, arg, SIZE_MAX, &default_quoting_options);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_n (int n, char const *arg)",
        "*"
      ]
    },
    "quotearg_n_mem": {
      "start_point": [
        935,
        0
      ],
      "end_point": [
        939,
        1
      ],
      "content": "char *\nquotearg_n_mem (int n, char const *arg, size_t argsize)\n{\n  return quotearg_n_options (n, arg, argsize, &default_quoting_options);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_n_mem (int n, char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quotearg": {
      "start_point": [
        941,
        0
      ],
      "end_point": [
        945,
        1
      ],
      "content": "char *\nquotearg (char const *arg)\n{\n  return quotearg_n (0, arg);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg (char const *arg)",
        "*"
      ]
    },
    "quotearg_mem": {
      "start_point": [
        947,
        0
      ],
      "end_point": [
        951,
        1
      ],
      "content": "char *\nquotearg_mem (char const *arg, size_t argsize)\n{\n  return quotearg_n_mem (0, arg, argsize);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_mem (char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quotearg_n_style": {
      "start_point": [
        953,
        0
      ],
      "end_point": [
        958,
        1
      ],
      "content": "char *\nquotearg_n_style (int n, enum quoting_style s, char const *arg)\n{\n  struct quoting_options const o = quoting_options_from_style (s);\n  return quotearg_n_options (n, arg, SIZE_MAX, &o);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_n_style (int n, enum quoting_style s, char const *arg)",
        "*"
      ]
    },
    "quotearg_n_style_mem": {
      "start_point": [
        960,
        0
      ],
      "end_point": [
        966,
        1
      ],
      "content": "char *\nquotearg_n_style_mem (int n, enum quoting_style s,\n                      char const *arg, size_t argsize)\n{\n  struct quoting_options const o = quoting_options_from_style (s);\n  return quotearg_n_options (n, arg, argsize, &o);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_n_style_mem (int n, enum quoting_style s,\n                      char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quotearg_style": {
      "start_point": [
        968,
        0
      ],
      "end_point": [
        972,
        1
      ],
      "content": "char *\nquotearg_style (enum quoting_style s, char const *arg)\n{\n  return quotearg_n_style (0, s, arg);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_style (enum quoting_style s, char const *arg)",
        "*"
      ]
    },
    "quotearg_style_mem": {
      "start_point": [
        974,
        0
      ],
      "end_point": [
        978,
        1
      ],
      "content": "char *\nquotearg_style_mem (enum quoting_style s, char const *arg, size_t argsize)\n{\n  return quotearg_n_style_mem (0, s, arg, argsize);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_style_mem (enum quoting_style s, char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quotearg_char_mem": {
      "start_point": [
        980,
        0
      ],
      "end_point": [
        987,
        1
      ],
      "content": "char *\nquotearg_char_mem (char const *arg, size_t argsize, char ch)\n{\n  struct quoting_options options;\n  options = default_quoting_options;\n  set_char_quoting (&options, ch, 1);\n  return quotearg_n_options (0, arg, argsize, &options);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_char_mem (char const *arg, size_t argsize, char ch)",
        "*"
      ]
    },
    "quotearg_char": {
      "start_point": [
        989,
        0
      ],
      "end_point": [
        993,
        1
      ],
      "content": "char *\nquotearg_char (char const *arg, char ch)\n{\n  return quotearg_char_mem (arg, SIZE_MAX, ch);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_char (char const *arg, char ch)",
        "*"
      ]
    },
    "quotearg_colon": {
      "start_point": [
        995,
        0
      ],
      "end_point": [
        999,
        1
      ],
      "content": "char *\nquotearg_colon (char const *arg)\n{\n  return quotearg_char (arg, ':');\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_colon (char const *arg)",
        "*"
      ]
    },
    "quotearg_colon_mem": {
      "start_point": [
        1001,
        0
      ],
      "end_point": [
        1005,
        1
      ],
      "content": "char *\nquotearg_colon_mem (char const *arg, size_t argsize)\n{\n  return quotearg_char_mem (arg, argsize, ':');\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_colon_mem (char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quotearg_n_style_colon": {
      "start_point": [
        1007,
        0
      ],
      "end_point": [
        1014,
        1
      ],
      "content": "char *\nquotearg_n_style_colon (int n, enum quoting_style s, char const *arg)\n{\n  struct quoting_options options;\n  options = quoting_options_from_style (s);\n  set_char_quoting (&options, ':', 1);\n  return quotearg_n_options (n, arg, SIZE_MAX, &options);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_n_style_colon (int n, enum quoting_style s, char const *arg)",
        "*"
      ]
    },
    "quotearg_n_custom": {
      "start_point": [
        1016,
        0
      ],
      "end_point": [
        1022,
        1
      ],
      "content": "char *\nquotearg_n_custom (int n, char const *left_quote,\n                   char const *right_quote, char const *arg)\n{\n  return quotearg_n_custom_mem (n, left_quote, right_quote, arg,\n                                SIZE_MAX);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_n_custom (int n, char const *left_quote,\n                   char const *right_quote, char const *arg)",
        "*"
      ]
    },
    "quotearg_n_custom_mem": {
      "start_point": [
        1024,
        0
      ],
      "end_point": [
        1032,
        1
      ],
      "content": "char *\nquotearg_n_custom_mem (int n, char const *left_quote,\n                       char const *right_quote,\n                       char const *arg, size_t argsize)\n{\n  struct quoting_options o = default_quoting_options;\n  set_custom_quoting (&o, left_quote, right_quote);\n  return quotearg_n_options (n, arg, argsize, &o);\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_n_custom_mem (int n, char const *left_quote,\n                       char const *right_quote,\n                       char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quotearg_custom": {
      "start_point": [
        1034,
        0
      ],
      "end_point": [
        1039,
        1
      ],
      "content": "char *\nquotearg_custom (char const *left_quote, char const *right_quote,\n                 char const *arg)\n{\n  return quotearg_n_custom (0, left_quote, right_quote, arg);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_custom (char const *left_quote, char const *right_quote,\n                 char const *arg)",
        "*"
      ]
    },
    "quotearg_custom_mem": {
      "start_point": [
        1041,
        0
      ],
      "end_point": [
        1047,
        1
      ],
      "content": "char *\nquotearg_custom_mem (char const *left_quote, char const *right_quote,\n                     char const *arg, size_t argsize)\n{\n  return quotearg_n_custom_mem (0, left_quote, right_quote, arg,\n                                argsize);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_custom_mem (char const *left_quote, char const *right_quote,\n                     char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quote_n_mem": {
      "start_point": [
        1059,
        0
      ],
      "end_point": [
        1063,
        1
      ],
      "content": "char const *\nquote_n_mem (int n, char const *arg, size_t argsize)\n{\n  return quotearg_n_options (n, arg, argsize, &quote_quoting_options);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "const",
        "const",
        "*\nquote_n_mem (int n, char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quote_mem": {
      "start_point": [
        1065,
        0
      ],
      "end_point": [
        1069,
        1
      ],
      "content": "char const *\nquote_mem (char const *arg, size_t argsize)\n{\n  return quote_n_mem (0, arg, argsize);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "const",
        "const",
        "*\nquote_mem (char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quote_n": {
      "start_point": [
        1071,
        0
      ],
      "end_point": [
        1075,
        1
      ],
      "content": "char const *\nquote_n (int n, char const *arg)\n{\n  return quote_n_mem (n, arg, SIZE_MAX);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "const",
        "const",
        "*\nquote_n (int n, char const *arg)",
        "*"
      ]
    },
    "quote": {
      "start_point": [
        1077,
        0
      ],
      "end_point": [
        1081,
        1
      ],
      "content": "char const *\nquote (char const *arg)\n{\n  return quote_n (0, arg);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "const",
        "const",
        "*\nquote (char const *arg)",
        "*"
      ]
    }
  },
  "datamash/datamash-1.3/lib/quotearg.h": {},
  "datamash/datamash-1.3/lib/random.c": {
    "random": {
      "start_point": [
        154,
        0
      ],
      "end_point": [
        162,
        1
      ],
      "content": "long\nrandom (void)\n{\n  int32_t val;\n\n  if (random_r (&generator, &val) < 0)\n    abort (); /* should not happen */\n  return val;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "long",
        "long"
      ]
    },
    "srandom": {
      "start_point": [
        164,
        0
      ],
      "end_point": [
        168,
        1
      ],
      "content": "void\nsrandom (unsigned int seed)\n{\n  (void) srandom_r (seed, &generator); /* may fail! */\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "initstate": {
      "start_point": [
        170,
        0
      ],
      "end_point": [
        177,
        1
      ],
      "content": "char *\ninitstate (unsigned int seed, char *buf, size_t buf_size)\n{\n  char *old_state = (char *) ((int32_t *) generator.state - 1);\n  if (initstate_r (seed, buf, buf_size, &generator) < 0)\n    return NULL; /* failed */\n  return old_state;\n}",
      "lines": 8,
      "depth": 11,
      "decorators": [
        "char",
        "*\ninitstate (unsigned int seed, char *buf, size_t buf_size)",
        "*"
      ]
    },
    "setstate": {
      "start_point": [
        179,
        0
      ],
      "end_point": [
        186,
        1
      ],
      "content": "char *\nsetstate (char *arg_state)\n{\n  char *old_state = (char *) ((int32_t *) generator.state - 1);\n  if (setstate_r (arg_state, &generator) < 0)\n    return NULL; /* failed */\n  return old_state;\n}",
      "lines": 8,
      "depth": 11,
      "decorators": [
        "char",
        "*\nsetstate (char *arg_state)",
        "*"
      ]
    }
  },
  "datamash/datamash-1.3/lib/random_r.c": {
    "__srandom_r": {
      "start_point": [
        176,
        0
      ],
      "end_point": [
        230,
        1
      ],
      "content": "int\n__srandom_r (unsigned int seed, struct random_data *buf)\n{\n  int type;\n  int32_t *state;\n  long int i;\n  long int word;\n  int32_t *dst;\n  int kc;\n\n  if (buf == NULL)\n    goto fail;\n  type = buf->rand_type;\n  if ((unsigned int) type >= MAX_TYPES)\n    goto fail;\n\n  state = buf->state;\n  /* We must make sure the seed is not 0.  Take arbitrarily 1 in this case.  */\n  if (seed == 0)\n    seed = 1;\n  state[0] = seed;\n  if (type == TYPE_0)\n    goto done;\n\n  dst = state;\n  word = seed;\n  kc = buf->rand_deg;\n  for (i = 1; i < kc; ++i)\n    {\n      /* This does:\n           state[i] = (16807 * state[i - 1]) % 2147483647;\n         but avoids overflowing 31 bits.  */\n      long int hi = word / 127773;\n      long int lo = word % 127773;\n      word = 16807 * lo - 2836 * hi;\n      if (word < 0)\n        word += 2147483647;\n      *++dst = word;\n    }\n\n  buf->fptr = &state[buf->rand_sep];\n  buf->rptr = &state[0];\n  kc *= 10;\n  while (--kc >= 0)\n    {\n      int32_t discard;\n      (void) __random_r (buf, &discard);\n    }\n\n done:\n  return 0;\n\n fail:\n  return -1;\n}",
      "lines": 55,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "__initstate_r": {
      "start_point": [
        245,
        0
      ],
      "end_point": [
        305,
        1
      ],
      "content": "int\n__initstate_r (unsigned int seed, char *arg_state, size_t n,\n               struct random_data *buf)\n{\n  int32_t *old_state;\n  int32_t *state;\n  int type;\n  int degree;\n  int separation;\n\n  if (buf == NULL)\n    goto fail;\n\n  old_state = buf->state;\n  if (old_state != NULL)\n    {\n      int old_type = buf->rand_type;\n      if (old_type == TYPE_0)\n        old_state[-1] = TYPE_0;\n      else\n        old_state[-1] = (MAX_TYPES * (buf->rptr - old_state)) + old_type;\n    }\n\n  if (n >= BREAK_3)\n    type = n < BREAK_4 ? TYPE_3 : TYPE_4;\n  else if (n < BREAK_1)\n    {\n      if (n < BREAK_0)\n        {\n          __set_errno (EINVAL);\n          goto fail;\n        }\n      type = TYPE_0;\n    }\n  else\n    type = n < BREAK_2 ? TYPE_1 : TYPE_2;\n\n  degree = random_poly_info.degrees[type];\n  separation = random_poly_info.seps[type];\n\n  buf->rand_type = type;\n  buf->rand_sep = separation;\n  buf->rand_deg = degree;\n  state = &((int32_t *) arg_state)[1];  /* First location.  */\n  /* Must set END_PTR before srandom.  */\n  buf->end_ptr = &state[degree];\n\n  buf->state = state;\n\n  __srandom_r (seed, buf);\n\n  state[-1] = TYPE_0;\n  if (type != TYPE_0)\n    state[-1] = (buf->rptr - state) * MAX_TYPES + type;\n\n  return 0;\n\n fail:\n  __set_errno (EINVAL);\n  return -1;\n}",
      "lines": 61,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "__setstate_r": {
      "start_point": [
        317,
        0
      ],
      "end_point": [
        360,
        1
      ],
      "content": "int\n__setstate_r (char *arg_state, struct random_data *buf)\n{\n  int32_t *new_state = 1 + (int32_t *) arg_state;\n  int type;\n  int old_type;\n  int32_t *old_state;\n  int degree;\n  int separation;\n\n  if (arg_state == NULL || buf == NULL)\n    goto fail;\n\n  old_type = buf->rand_type;\n  old_state = buf->state;\n  if (old_type == TYPE_0)\n    old_state[-1] = TYPE_0;\n  else\n    old_state[-1] = (MAX_TYPES * (buf->rptr - old_state)) + old_type;\n\n  type = new_state[-1] % MAX_TYPES;\n  if (type < TYPE_0 || type > TYPE_4)\n    goto fail;\n\n  buf->rand_deg = degree = random_poly_info.degrees[type];\n  buf->rand_sep = separation = random_poly_info.seps[type];\n  buf->rand_type = type;\n\n  if (type != TYPE_0)\n    {\n      int rear = new_state[-1] / MAX_TYPES;\n      buf->rptr = &new_state[rear];\n      buf->fptr = &new_state[(rear + separation) % degree];\n    }\n  buf->state = new_state;\n  /* Set end_ptr too.  */\n  buf->end_ptr = &new_state[degree];\n\n  return 0;\n\n fail:\n  __set_errno (EINVAL);\n  return -1;\n}",
      "lines": 44,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "__random_r": {
      "start_point": [
        375,
        0
      ],
      "end_point": [
        422,
        1
      ],
      "content": "int\n__random_r (struct random_data *buf, int32_t *result)\n{\n  int32_t *state;\n\n  if (buf == NULL || result == NULL)\n    goto fail;\n\n  state = buf->state;\n\n  if (buf->rand_type == TYPE_0)\n    {\n      int32_t val = state[0];\n      val = ((state[0] * 1103515245) + 12345) & 0x7fffffff;\n      state[0] = val;\n      *result = val;\n    }\n  else\n    {\n      int32_t *fptr = buf->fptr;\n      int32_t *rptr = buf->rptr;\n      int32_t *end_ptr = buf->end_ptr;\n      int32_t val;\n\n      val = *fptr += *rptr;\n      /* Chucking least random bit.  */\n      *result = (val >> 1) & 0x7fffffff;\n      ++fptr;\n      if (fptr >= end_ptr)\n        {\n          fptr = state;\n          ++rptr;\n        }\n      else\n        {\n          ++rptr;\n          if (rptr >= end_ptr)\n            rptr = state;\n        }\n      buf->fptr = fptr;\n      buf->rptr = rptr;\n    }\n  return 0;\n\n fail:\n  __set_errno (EINVAL);\n  return -1;\n}",
      "lines": 48,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "datamash/datamash-1.3/lib/realloc.c": {
    "rpl_realloc": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "void *\nrpl_realloc (void *p, size_t n)\n{\n  void *result;\n\n#if NEED_REALLOC_GNU\n  if (n == 0)\n    {\n      n = 1;\n\n      /* In theory realloc might fail, so don't rely on it to free.  */\n      free (p);\n      p = NULL;\n    }\n#endif\n\n  if (p == NULL)\n    {\n#if GNULIB_REALLOC_GNU && !NEED_REALLOC_GNU && !SYSTEM_MALLOC_GLIBC_COMPATIBLE\n      if (n == 0)\n        n = 1;\n#endif\n      result = malloc (n);\n    }\n  else\n    result = realloc (p, n);\n\n#if !HAVE_REALLOC_POSIX\n  if (result == NULL)\n    errno = ENOMEM;\n#endif\n\n  return result;\n}",
      "lines": 34,
      "depth": 9,
      "decorators": [
        "void",
        "*\nrpl_realloc (void *p, size_t n)",
        "*"
      ]
    }
  },
  "datamash/datamash-1.3/lib/round.c": {
    "FLOOR_BASED_ROUND": {
      "start_point": [
        87,
        0
      ],
      "end_point": [
        104,
        1
      ],
      "content": "DOUBLE\nFLOOR_BASED_ROUND (DOUBLE x)\n{\n  if (x >= L_(0.0))\n    {\n      DOUBLE y = FLOOR (x);\n      if (x - y >= L_(0.5))\n        y += L_(1.0);\n      return y;\n    }\n  else\n    {\n      DOUBLE y = CEIL (x);\n      if (y - x >= L_(0.5))\n        y -= L_(1.0);\n      return y;\n    }\n}",
      "lines": 18,
      "depth": 10,
      "decorators": [
        "DOUBLE"
      ]
    },
    "FLOOR_FREE_ROUND": {
      "start_point": [
        110,
        0
      ],
      "end_point": [
        172,
        1
      ],
      "content": "DOUBLE\nFLOOR_FREE_ROUND (DOUBLE x)\n{\n  /* 2^(MANT_DIG-1).  */\n  static const DOUBLE TWO_MANT_DIG =\n    /* Assume MANT_DIG <= 5 * 31.\n       Use the identity\n       n = floor(n/5) + floor((n+1)/5) + ... + floor((n+4)/5).  */\n    (DOUBLE) (1U << ((MANT_DIG - 1) / 5))\n    * (DOUBLE) (1U << ((MANT_DIG - 1 + 1) / 5))\n    * (DOUBLE) (1U << ((MANT_DIG - 1 + 2) / 5))\n    * (DOUBLE) (1U << ((MANT_DIG - 1 + 3) / 5))\n    * (DOUBLE) (1U << ((MANT_DIG - 1 + 4) / 5));\n\n  /* The use of 'volatile' guarantees that excess precision bits are dropped at\n     each addition step and before the following comparison at the caller's\n     site.  It is necessary on x86 systems where double-floats are not IEEE\n     compliant by default, to avoid that the results become platform and\n     compiler option dependent.  'volatile' is a portable alternative to gcc's\n     -ffloat-store option.  */\n  volatile DOUBLE y = x;\n  volatile DOUBLE z = y;\n\n  if (z > L_(0.0))\n    {\n      /* Avoid rounding error for x = 0.5 - 2^(-MANT_DIG-1).  */\n      if (z < L_(0.5))\n        z = L_(0.0);\n      /* Avoid rounding errors for values near 2^k, where k >= MANT_DIG-1.  */\n      else if (z < TWO_MANT_DIG)\n        {\n          /* Add 0.5 to the absolute value.  */\n          y = z += L_(0.5);\n          /* Round to the next integer (nearest or up or down, doesn't\n             matter).  */\n          z += TWO_MANT_DIG;\n          z -= TWO_MANT_DIG;\n          /* Enforce rounding down.  */\n          if (z > y)\n            z -= L_(1.0);\n        }\n    }\n  else if (z < L_(0.0))\n    {\n      /* Avoid rounding error for x = -(0.5 - 2^(-MANT_DIG-1)).  */\n      if (z > - L_(0.5))\n        z = MINUS_ZERO;\n      /* Avoid rounding errors for values near -2^k, where k >= MANT_DIG-1.  */\n      else if (z > -TWO_MANT_DIG)\n        {\n          /* Add 0.5 to the absolute value.  */\n          y = z -= L_(0.5);\n          /* Round to the next integer (nearest or up or down, doesn't\n             matter).  */\n          z -= TWO_MANT_DIG;\n          z += TWO_MANT_DIG;\n          /* Enforce rounding up.  */\n          if (z < y)\n            z += L_(1.0);\n        }\n    }\n  return z;\n}",
      "lines": 63,
      "depth": 17,
      "decorators": [
        "DOUBLE"
      ]
    }
  },
  "datamash/datamash-1.3/lib/roundl.c": {
    "roundl": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        27,
        1
      ],
      "content": "long double\nroundl (long double x)\n{\n  return round (x);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "long double",
        "long",
        "double"
      ]
    }
  },
  "datamash/datamash-1.3/lib/sha1.c": {
    "sha1_init_ctx": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "void\nsha1_init_ctx (struct sha1_ctx *ctx)\n{\n  ctx->A = 0x67452301;\n  ctx->B = 0xefcdab89;\n  ctx->C = 0x98badcfe;\n  ctx->D = 0x10325476;\n  ctx->E = 0xc3d2e1f0;\n\n  ctx->total[0] = ctx->total[1] = 0;\n  ctx->buflen = 0;\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "set_uint32": {
      "start_point": [
        76,
        0
      ],
      "end_point": [
        80,
        1
      ],
      "content": "static void\nset_uint32 (char *cp, uint32_t v)\n{\n  memcpy (cp, &v, sizeof v);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "sha1_read_ctx": {
      "start_point": [
        84,
        0
      ],
      "end_point": [
        95,
        1
      ],
      "content": "void *\nsha1_read_ctx (const struct sha1_ctx *ctx, void *resbuf)\n{\n  char *r = resbuf;\n  set_uint32 (r + 0 * sizeof ctx->A, SWAP (ctx->A));\n  set_uint32 (r + 1 * sizeof ctx->B, SWAP (ctx->B));\n  set_uint32 (r + 2 * sizeof ctx->C, SWAP (ctx->C));\n  set_uint32 (r + 3 * sizeof ctx->D, SWAP (ctx->D));\n  set_uint32 (r + 4 * sizeof ctx->E, SWAP (ctx->E));\n\n  return resbuf;\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "void",
        "*\nsha1_read_ctx (const struct sha1_ctx *ctx, void *resbuf)",
        "*"
      ]
    },
    "sha1_finish_ctx": {
      "start_point": [
        99,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "void *\nsha1_finish_ctx (struct sha1_ctx *ctx, void *resbuf)\n{\n  /* Take yet unprocessed bytes into account.  */\n  uint32_t bytes = ctx->buflen;\n  size_t size = (bytes < 56) ? 64 / 4 : 64 * 2 / 4;\n\n  /* Now count remaining bytes.  */\n  ctx->total[0] += bytes;\n  if (ctx->total[0] < bytes)\n    ++ctx->total[1];\n\n  /* Put the 64-bit file length in *bits* at the end of the buffer.  */\n  ctx->buffer[size - 2] = SWAP ((ctx->total[1] << 3) | (ctx->total[0] >> 29));\n  ctx->buffer[size - 1] = SWAP (ctx->total[0] << 3);\n\n  memcpy (&((char *) ctx->buffer)[bytes], fillbuf, (size - 2) * 4 - bytes);\n\n  /* Process last bytes.  */\n  sha1_process_block (ctx->buffer, size * 4, ctx);\n\n  return sha1_read_ctx (ctx, resbuf);\n}",
      "lines": 23,
      "depth": 12,
      "decorators": [
        "void",
        "*\nsha1_finish_ctx (struct sha1_ctx *ctx, void *resbuf)",
        "*"
      ]
    },
    "sha1_stream": {
      "start_point": [
        127,
        0
      ],
      "end_point": [
        195,
        1
      ],
      "content": "int\nsha1_stream (FILE *stream, void *resblock)\n{\n  struct sha1_ctx ctx;\n  size_t sum;\n\n  char *buffer = malloc (BLOCKSIZE + 72);\n  if (!buffer)\n    return 1;\n\n  /* Initialize the computation context.  */\n  sha1_init_ctx (&ctx);\n\n  /* Iterate over full file contents.  */\n  while (1)\n    {\n      /* We read the file in blocks of BLOCKSIZE bytes.  One call of the\n         computation function processes the whole buffer so that with the\n         next round of the loop another block can be read.  */\n      size_t n;\n      sum = 0;\n\n      /* Read block.  Take care for partial reads.  */\n      while (1)\n        {\n          n = fread (buffer + sum, 1, BLOCKSIZE - sum, stream);\n\n          sum += n;\n\n          if (sum == BLOCKSIZE)\n            break;\n\n          if (n == 0)\n            {\n              /* Check for the error flag IFF N == 0, so that we don't\n                 exit the loop after a partial read due to e.g., EAGAIN\n                 or EWOULDBLOCK.  */\n              if (ferror (stream))\n                {\n                  free (buffer);\n                  return 1;\n                }\n              goto process_partial_block;\n            }\n\n          /* We've read at least one byte, so ignore errors.  But always\n             check for EOF, since feof may be true even though N > 0.\n             Otherwise, we could end up calling fread after EOF.  */\n          if (feof (stream))\n            goto process_partial_block;\n        }\n\n      /* Process buffer with BLOCKSIZE bytes.  Note that\n                        BLOCKSIZE % 64 == 0\n       */\n      sha1_process_block (buffer, BLOCKSIZE, &ctx);\n    }\n\n process_partial_block:;\n\n  /* Process any remaining bytes.  */\n  if (sum > 0)\n    sha1_process_bytes (buffer, sum, &ctx);\n\n  /* Construct result in desired memory.  */\n  sha1_finish_ctx (&ctx, resblock);\n  free (buffer);\n  return 0;\n}",
      "lines": 69,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "sha1_buffer": {
      "start_point": [
        202,
        0
      ],
      "end_point": [
        215,
        1
      ],
      "content": "void *\nsha1_buffer (const char *buffer, size_t len, void *resblock)\n{\n  struct sha1_ctx ctx;\n\n  /* Initialize the computation context.  */\n  sha1_init_ctx (&ctx);\n\n  /* Process whole buffer but last len % 64 bytes.  */\n  sha1_process_bytes (buffer, len, &ctx);\n\n  /* Put result in desired memory area.  */\n  return sha1_finish_ctx (&ctx, resblock);\n}",
      "lines": 14,
      "depth": 7,
      "decorators": [
        "void",
        "*\nsha1_buffer (const char *buffer, size_t len, void *resblock)",
        "*"
      ]
    },
    "sha1_process_bytes": {
      "start_point": [
        217,
        0
      ],
      "end_point": [
        284,
        1
      ],
      "content": "void\nsha1_process_bytes (const void *buffer, size_t len, struct sha1_ctx *ctx)\n{\n  /* When we already have some bits in our internal buffer concatenate\n     both inputs first.  */\n  if (ctx->buflen != 0)\n    {\n      size_t left_over = ctx->buflen;\n      size_t add = 128 - left_over > len ? len : 128 - left_over;\n\n      memcpy (&((char *) ctx->buffer)[left_over], buffer, add);\n      ctx->buflen += add;\n\n      if (ctx->buflen > 64)\n        {\n          sha1_process_block (ctx->buffer, ctx->buflen & ~63, ctx);\n\n          ctx->buflen &= 63;\n          /* The regions in the following copy operation cannot overlap,\n             because ctx->buflen < 64 \u00e2\u0089\u00a4 (left_over + add) & ~63.  */\n          memcpy (ctx->buffer,\n                  &((char *) ctx->buffer)[(left_over + add) & ~63],\n                  ctx->buflen);\n        }\n\n      buffer = (const char *) buffer + add;\n      len -= add;\n    }\n\n  /* Process available complete blocks.  */\n  if (len >= 64)\n    {\n#if !(_STRING_ARCH_unaligned || _STRING_INLINE_unaligned)\n# define UNALIGNED_P(p) ((uintptr_t) (p) % alignof (uint32_t) != 0)\n      if (UNALIGNED_P (buffer))\n        while (len > 64)\n          {\n            sha1_process_block (memcpy (ctx->buffer, buffer, 64), 64, ctx);\n            buffer = (const char *) buffer + 64;\n            len -= 64;\n          }\n      else\n#endif\n        {\n          sha1_process_block (buffer, len & ~63, ctx);\n          buffer = (const char *) buffer + (len & ~63);\n          len &= 63;\n        }\n    }\n\n  /* Move remaining bytes in internal buffer.  */\n  if (len > 0)\n    {\n      size_t left_over = ctx->buflen;\n\n      memcpy (&((char *) ctx->buffer)[left_over], buffer, len);\n      left_over += len;\n      if (left_over >= 64)\n        {\n          sha1_process_block (ctx->buffer, 64, ctx);\n          left_over -= 64;\n          /* The regions in the following copy operation cannot overlap,\n             because left_over \u00e2\u0089\u00a4 64.  */\n          memcpy (ctx->buffer, &ctx->buffer[16], left_over);\n        }\n      ctx->buflen = left_over;\n    }\n}",
      "lines": 68,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "sha1_process_block": {
      "start_point": [
        304,
        0
      ],
      "end_point": [
        434,
        1
      ],
      "content": "void\nsha1_process_block (const void *buffer, size_t len, struct sha1_ctx *ctx)\n{\n  const uint32_t *words = buffer;\n  size_t nwords = len / sizeof (uint32_t);\n  const uint32_t *endp = words + nwords;\n  uint32_t x[16];\n  uint32_t a = ctx->A;\n  uint32_t b = ctx->B;\n  uint32_t c = ctx->C;\n  uint32_t d = ctx->D;\n  uint32_t e = ctx->E;\n  uint32_t lolen = len;\n\n  /* First increment the byte count.  RFC 1321 specifies the possible\n     length of the file up to 2^64 bits.  Here we only compute the\n     number of bytes.  Do a double word increment.  */\n  ctx->total[0] += lolen;\n  ctx->total[1] += (len >> 31 >> 1) + (ctx->total[0] < lolen);\n\n#define rol(x, n) (((x) << (n)) | ((uint32_t) (x) >> (32 - (n))))\n\n#define M(I) ( tm =   x[I&0x0f] ^ x[(I-14)&0x0f] \\\n                    ^ x[(I-8)&0x0f] ^ x[(I-3)&0x0f] \\\n               , (x[I&0x0f] = rol(tm, 1)) )\n\n#define R(A,B,C,D,E,F,K,M)  do { E += rol( A, 5 )     \\\n                                      + F( B, C, D )  \\\n                                      + K             \\\n                                      + M;            \\\n                                 B = rol( B, 30 );    \\\n                               } while(0)\n\n  while (words < endp)\n    {\n      uint32_t tm;\n      int t;\n      for (t = 0; t < 16; t++)\n        {\n          x[t] = SWAP (*words);\n          words++;\n        }\n\n      R( a, b, c, d, e, F1, K1, x[ 0] );\n      R( e, a, b, c, d, F1, K1, x[ 1] );\n      R( d, e, a, b, c, F1, K1, x[ 2] );\n      R( c, d, e, a, b, F1, K1, x[ 3] );\n      R( b, c, d, e, a, F1, K1, x[ 4] );\n      R( a, b, c, d, e, F1, K1, x[ 5] );\n      R( e, a, b, c, d, F1, K1, x[ 6] );\n      R( d, e, a, b, c, F1, K1, x[ 7] );\n      R( c, d, e, a, b, F1, K1, x[ 8] );\n      R( b, c, d, e, a, F1, K1, x[ 9] );\n      R( a, b, c, d, e, F1, K1, x[10] );\n      R( e, a, b, c, d, F1, K1, x[11] );\n      R( d, e, a, b, c, F1, K1, x[12] );\n      R( c, d, e, a, b, F1, K1, x[13] );\n      R( b, c, d, e, a, F1, K1, x[14] );\n      R( a, b, c, d, e, F1, K1, x[15] );\n      R( e, a, b, c, d, F1, K1, M(16) );\n      R( d, e, a, b, c, F1, K1, M(17) );\n      R( c, d, e, a, b, F1, K1, M(18) );\n      R( b, c, d, e, a, F1, K1, M(19) );\n      R( a, b, c, d, e, F2, K2, M(20) );\n      R( e, a, b, c, d, F2, K2, M(21) );\n      R( d, e, a, b, c, F2, K2, M(22) );\n      R( c, d, e, a, b, F2, K2, M(23) );\n      R( b, c, d, e, a, F2, K2, M(24) );\n      R( a, b, c, d, e, F2, K2, M(25) );\n      R( e, a, b, c, d, F2, K2, M(26) );\n      R( d, e, a, b, c, F2, K2, M(27) );\n      R( c, d, e, a, b, F2, K2, M(28) );\n      R( b, c, d, e, a, F2, K2, M(29) );\n      R( a, b, c, d, e, F2, K2, M(30) );\n      R( e, a, b, c, d, F2, K2, M(31) );\n      R( d, e, a, b, c, F2, K2, M(32) );\n      R( c, d, e, a, b, F2, K2, M(33) );\n      R( b, c, d, e, a, F2, K2, M(34) );\n      R( a, b, c, d, e, F2, K2, M(35) );\n      R( e, a, b, c, d, F2, K2, M(36) );\n      R( d, e, a, b, c, F2, K2, M(37) );\n      R( c, d, e, a, b, F2, K2, M(38) );\n      R( b, c, d, e, a, F2, K2, M(39) );\n      R( a, b, c, d, e, F3, K3, M(40) );\n      R( e, a, b, c, d, F3, K3, M(41) );\n      R( d, e, a, b, c, F3, K3, M(42) );\n      R( c, d, e, a, b, F3, K3, M(43) );\n      R( b, c, d, e, a, F3, K3, M(44) );\n      R( a, b, c, d, e, F3, K3, M(45) );\n      R( e, a, b, c, d, F3, K3, M(46) );\n      R( d, e, a, b, c, F3, K3, M(47) );\n      R( c, d, e, a, b, F3, K3, M(48) );\n      R( b, c, d, e, a, F3, K3, M(49) );\n      R( a, b, c, d, e, F3, K3, M(50) );\n      R( e, a, b, c, d, F3, K3, M(51) );\n      R( d, e, a, b, c, F3, K3, M(52) );\n      R( c, d, e, a, b, F3, K3, M(53) );\n      R( b, c, d, e, a, F3, K3, M(54) );\n      R( a, b, c, d, e, F3, K3, M(55) );\n      R( e, a, b, c, d, F3, K3, M(56) );\n      R( d, e, a, b, c, F3, K3, M(57) );\n      R( c, d, e, a, b, F3, K3, M(58) );\n      R( b, c, d, e, a, F3, K3, M(59) );\n      R( a, b, c, d, e, F4, K4, M(60) );\n      R( e, a, b, c, d, F4, K4, M(61) );\n      R( d, e, a, b, c, F4, K4, M(62) );\n      R( c, d, e, a, b, F4, K4, M(63) );\n      R( b, c, d, e, a, F4, K4, M(64) );\n      R( a, b, c, d, e, F4, K4, M(65) );\n      R( e, a, b, c, d, F4, K4, M(66) );\n      R( d, e, a, b, c, F4, K4, M(67) );\n      R( c, d, e, a, b, F4, K4, M(68) );\n      R( b, c, d, e, a, F4, K4, M(69) );\n      R( a, b, c, d, e, F4, K4, M(70) );\n      R( e, a, b, c, d, F4, K4, M(71) );\n      R( d, e, a, b, c, F4, K4, M(72) );\n      R( c, d, e, a, b, F4, K4, M(73) );\n      R( b, c, d, e, a, F4, K4, M(74) );\n      R( a, b, c, d, e, F4, K4, M(75) );\n      R( e, a, b, c, d, F4, K4, M(76) );\n      R( d, e, a, b, c, F4, K4, M(77) );\n      R( c, d, e, a, b, F4, K4, M(78) );\n      R( b, c, d, e, a, F4, K4, M(79) );\n\n      a = ctx->A += a;\n      b = ctx->B += b;\n      c = ctx->C += c;\n      d = ctx->D += d;\n      e = ctx->E += e;\n    }\n}",
      "lines": 131,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "datamash/datamash-1.3/lib/sha1.h": {},
  "datamash/datamash-1.3/lib/sha256.c": {
    "sha256_init_ctx": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        75,
        1
      ],
      "content": "void\nsha256_init_ctx (struct sha256_ctx *ctx)\n{\n  ctx->state[0] = 0x6a09e667UL;\n  ctx->state[1] = 0xbb67ae85UL;\n  ctx->state[2] = 0x3c6ef372UL;\n  ctx->state[3] = 0xa54ff53aUL;\n  ctx->state[4] = 0x510e527fUL;\n  ctx->state[5] = 0x9b05688cUL;\n  ctx->state[6] = 0x1f83d9abUL;\n  ctx->state[7] = 0x5be0cd19UL;\n\n  ctx->total[0] = ctx->total[1] = 0;\n  ctx->buflen = 0;\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "sha224_init_ctx": {
      "start_point": [
        77,
        0
      ],
      "end_point": [
        91,
        1
      ],
      "content": "void\nsha224_init_ctx (struct sha256_ctx *ctx)\n{\n  ctx->state[0] = 0xc1059ed8UL;\n  ctx->state[1] = 0x367cd507UL;\n  ctx->state[2] = 0x3070dd17UL;\n  ctx->state[3] = 0xf70e5939UL;\n  ctx->state[4] = 0xffc00b31UL;\n  ctx->state[5] = 0x68581511UL;\n  ctx->state[6] = 0x64f98fa7UL;\n  ctx->state[7] = 0xbefa4fa4UL;\n\n  ctx->total[0] = ctx->total[1] = 0;\n  ctx->buflen = 0;\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "set_uint32": {
      "start_point": [
        96,
        0
      ],
      "end_point": [
        100,
        1
      ],
      "content": "static void\nset_uint32 (char *cp, uint32_t v)\n{\n  memcpy (cp, &v, sizeof v);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "sha256_read_ctx": {
      "start_point": [
        104,
        0
      ],
      "end_point": [
        114,
        1
      ],
      "content": "void *\nsha256_read_ctx (const struct sha256_ctx *ctx, void *resbuf)\n{\n  int i;\n  char *r = resbuf;\n\n  for (i = 0; i < 8; i++)\n    set_uint32 (r + i * sizeof ctx->state[0], SWAP (ctx->state[i]));\n\n  return resbuf;\n}",
      "lines": 11,
      "depth": 12,
      "decorators": [
        "void",
        "*\nsha256_read_ctx (const struct sha256_ctx *ctx, void *resbuf)",
        "*"
      ]
    },
    "sha224_read_ctx": {
      "start_point": [
        116,
        0
      ],
      "end_point": [
        126,
        1
      ],
      "content": "void *\nsha224_read_ctx (const struct sha256_ctx *ctx, void *resbuf)\n{\n  int i;\n  char *r = resbuf;\n\n  for (i = 0; i < 7; i++)\n    set_uint32 (r + i * sizeof ctx->state[0], SWAP (ctx->state[i]));\n\n  return resbuf;\n}",
      "lines": 11,
      "depth": 12,
      "decorators": [
        "void",
        "*\nsha224_read_ctx (const struct sha256_ctx *ctx, void *resbuf)",
        "*"
      ]
    },
    "sha256_conclude_ctx": {
      "start_point": [
        130,
        0
      ],
      "end_point": [
        154,
        1
      ],
      "content": "static void\nsha256_conclude_ctx (struct sha256_ctx *ctx)\n{\n  /* Take yet unprocessed bytes into account.  */\n  size_t bytes = ctx->buflen;\n  size_t size = (bytes < 56) ? 64 / 4 : 64 * 2 / 4;\n\n  /* Now count remaining bytes.  */\n  ctx->total[0] += bytes;\n  if (ctx->total[0] < bytes)\n    ++ctx->total[1];\n\n  /* Put the 64-bit file length in *bits* at the end of the buffer.\n     Use set_uint32 rather than a simple assignment, to avoid risk of\n     unaligned access.  */\n  set_uint32 ((char *) &ctx->buffer[size - 2],\n              SWAP ((ctx->total[1] << 3) | (ctx->total[0] >> 29)));\n  set_uint32 ((char *) &ctx->buffer[size - 1],\n              SWAP (ctx->total[0] << 3));\n\n  memcpy (&((char *) ctx->buffer)[bytes], fillbuf, (size - 2) * 4 - bytes);\n\n  /* Process last bytes.  */\n  sha256_process_block (ctx->buffer, size * 4, ctx);\n}",
      "lines": 25,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "sha256_finish_ctx": {
      "start_point": [
        156,
        0
      ],
      "end_point": [
        161,
        1
      ],
      "content": "void *\nsha256_finish_ctx (struct sha256_ctx *ctx, void *resbuf)\n{\n  sha256_conclude_ctx (ctx);\n  return sha256_read_ctx (ctx, resbuf);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void",
        "*\nsha256_finish_ctx (struct sha256_ctx *ctx, void *resbuf)",
        "*"
      ]
    },
    "sha224_finish_ctx": {
      "start_point": [
        163,
        0
      ],
      "end_point": [
        168,
        1
      ],
      "content": "void *\nsha224_finish_ctx (struct sha256_ctx *ctx, void *resbuf)\n{\n  sha256_conclude_ctx (ctx);\n  return sha224_read_ctx (ctx, resbuf);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void",
        "*\nsha224_finish_ctx (struct sha256_ctx *ctx, void *resbuf)",
        "*"
      ]
    },
    "sha256_stream": {
      "start_point": [
        174,
        0
      ],
      "end_point": [
        242,
        1
      ],
      "content": "int\nsha256_stream (FILE *stream, void *resblock)\n{\n  struct sha256_ctx ctx;\n  size_t sum;\n\n  char *buffer = malloc (BLOCKSIZE + 72);\n  if (!buffer)\n    return 1;\n\n  /* Initialize the computation context.  */\n  sha256_init_ctx (&ctx);\n\n  /* Iterate over full file contents.  */\n  while (1)\n    {\n      /* We read the file in blocks of BLOCKSIZE bytes.  One call of the\n         computation function processes the whole buffer so that with the\n         next round of the loop another block can be read.  */\n      size_t n;\n      sum = 0;\n\n      /* Read block.  Take care for partial reads.  */\n      while (1)\n        {\n          n = fread (buffer + sum, 1, BLOCKSIZE - sum, stream);\n\n          sum += n;\n\n          if (sum == BLOCKSIZE)\n            break;\n\n          if (n == 0)\n            {\n              /* Check for the error flag IFF N == 0, so that we don't\n                 exit the loop after a partial read due to e.g., EAGAIN\n                 or EWOULDBLOCK.  */\n              if (ferror (stream))\n                {\n                  free (buffer);\n                  return 1;\n                }\n              goto process_partial_block;\n            }\n\n          /* We've read at least one byte, so ignore errors.  But always\n             check for EOF, since feof may be true even though N > 0.\n             Otherwise, we could end up calling fread after EOF.  */\n          if (feof (stream))\n            goto process_partial_block;\n        }\n\n      /* Process buffer with BLOCKSIZE bytes.  Note that\n                        BLOCKSIZE % 64 == 0\n       */\n      sha256_process_block (buffer, BLOCKSIZE, &ctx);\n    }\n\n process_partial_block:;\n\n  /* Process any remaining bytes.  */\n  if (sum > 0)\n    sha256_process_bytes (buffer, sum, &ctx);\n\n  /* Construct result in desired memory.  */\n  sha256_finish_ctx (&ctx, resblock);\n  free (buffer);\n  return 0;\n}",
      "lines": 69,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "sha224_stream": {
      "start_point": [
        245,
        0
      ],
      "end_point": [
        313,
        1
      ],
      "content": "int\nsha224_stream (FILE *stream, void *resblock)\n{\n  struct sha256_ctx ctx;\n  size_t sum;\n\n  char *buffer = malloc (BLOCKSIZE + 72);\n  if (!buffer)\n    return 1;\n\n  /* Initialize the computation context.  */\n  sha224_init_ctx (&ctx);\n\n  /* Iterate over full file contents.  */\n  while (1)\n    {\n      /* We read the file in blocks of BLOCKSIZE bytes.  One call of the\n         computation function processes the whole buffer so that with the\n         next round of the loop another block can be read.  */\n      size_t n;\n      sum = 0;\n\n      /* Read block.  Take care for partial reads.  */\n      while (1)\n        {\n          n = fread (buffer + sum, 1, BLOCKSIZE - sum, stream);\n\n          sum += n;\n\n          if (sum == BLOCKSIZE)\n            break;\n\n          if (n == 0)\n            {\n              /* Check for the error flag IFF N == 0, so that we don't\n                 exit the loop after a partial read due to e.g., EAGAIN\n                 or EWOULDBLOCK.  */\n              if (ferror (stream))\n                {\n                  free (buffer);\n                  return 1;\n                }\n              goto process_partial_block;\n            }\n\n          /* We've read at least one byte, so ignore errors.  But always\n             check for EOF, since feof may be true even though N > 0.\n             Otherwise, we could end up calling fread after EOF.  */\n          if (feof (stream))\n            goto process_partial_block;\n        }\n\n      /* Process buffer with BLOCKSIZE bytes.  Note that\n                        BLOCKSIZE % 64 == 0\n       */\n      sha256_process_block (buffer, BLOCKSIZE, &ctx);\n    }\n\n process_partial_block:;\n\n  /* Process any remaining bytes.  */\n  if (sum > 0)\n    sha256_process_bytes (buffer, sum, &ctx);\n\n  /* Construct result in desired memory.  */\n  sha224_finish_ctx (&ctx, resblock);\n  free (buffer);\n  return 0;\n}",
      "lines": 69,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "sha256_buffer": {
      "start_point": [
        320,
        0
      ],
      "end_point": [
        333,
        1
      ],
      "content": "void *\nsha256_buffer (const char *buffer, size_t len, void *resblock)\n{\n  struct sha256_ctx ctx;\n\n  /* Initialize the computation context.  */\n  sha256_init_ctx (&ctx);\n\n  /* Process whole buffer but last len % 64 bytes.  */\n  sha256_process_bytes (buffer, len, &ctx);\n\n  /* Put result in desired memory area.  */\n  return sha256_finish_ctx (&ctx, resblock);\n}",
      "lines": 14,
      "depth": 7,
      "decorators": [
        "void",
        "*\nsha256_buffer (const char *buffer, size_t len, void *resblock)",
        "*"
      ]
    },
    "sha224_buffer": {
      "start_point": [
        335,
        0
      ],
      "end_point": [
        348,
        1
      ],
      "content": "void *\nsha224_buffer (const char *buffer, size_t len, void *resblock)\n{\n  struct sha256_ctx ctx;\n\n  /* Initialize the computation context.  */\n  sha224_init_ctx (&ctx);\n\n  /* Process whole buffer but last len % 64 bytes.  */\n  sha256_process_bytes (buffer, len, &ctx);\n\n  /* Put result in desired memory area.  */\n  return sha224_finish_ctx (&ctx, resblock);\n}",
      "lines": 14,
      "depth": 7,
      "decorators": [
        "void",
        "*\nsha224_buffer (const char *buffer, size_t len, void *resblock)",
        "*"
      ]
    },
    "sha256_process_bytes": {
      "start_point": [
        350,
        0
      ],
      "end_point": [
        417,
        1
      ],
      "content": "void\nsha256_process_bytes (const void *buffer, size_t len, struct sha256_ctx *ctx)\n{\n  /* When we already have some bits in our internal buffer concatenate\n     both inputs first.  */\n  if (ctx->buflen != 0)\n    {\n      size_t left_over = ctx->buflen;\n      size_t add = 128 - left_over > len ? len : 128 - left_over;\n\n      memcpy (&((char *) ctx->buffer)[left_over], buffer, add);\n      ctx->buflen += add;\n\n      if (ctx->buflen > 64)\n        {\n          sha256_process_block (ctx->buffer, ctx->buflen & ~63, ctx);\n\n          ctx->buflen &= 63;\n          /* The regions in the following copy operation cannot overlap,\n             because ctx->buflen < 64 \u00e2\u0089\u00a4 (left_over + add) & ~63.  */\n          memcpy (ctx->buffer,\n                  &((char *) ctx->buffer)[(left_over + add) & ~63],\n                  ctx->buflen);\n        }\n\n      buffer = (const char *) buffer + add;\n      len -= add;\n    }\n\n  /* Process available complete blocks.  */\n  if (len >= 64)\n    {\n#if !(_STRING_ARCH_unaligned || _STRING_INLINE_unaligned)\n# define UNALIGNED_P(p) ((uintptr_t) (p) % alignof (uint32_t) != 0)\n      if (UNALIGNED_P (buffer))\n        while (len > 64)\n          {\n            sha256_process_block (memcpy (ctx->buffer, buffer, 64), 64, ctx);\n            buffer = (const char *) buffer + 64;\n            len -= 64;\n          }\n      else\n#endif\n        {\n          sha256_process_block (buffer, len & ~63, ctx);\n          buffer = (const char *) buffer + (len & ~63);\n          len &= 63;\n        }\n    }\n\n  /* Move remaining bytes in internal buffer.  */\n  if (len > 0)\n    {\n      size_t left_over = ctx->buflen;\n\n      memcpy (&((char *) ctx->buffer)[left_over], buffer, len);\n      left_over += len;\n      if (left_over >= 64)\n        {\n          sha256_process_block (ctx->buffer, 64, ctx);\n          left_over -= 64;\n          /* The regions in the following copy operation cannot overlap,\n             because left_over \u00e2\u0089\u00a4 64.  */\n          memcpy (ctx->buffer, &ctx->buffer[16], left_over);\n        }\n      ctx->buflen = left_over;\n    }\n}",
      "lines": 68,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "sha256_process_block": {
      "start_point": [
        450,
        0
      ],
      "end_point": [
        577,
        1
      ],
      "content": "void\nsha256_process_block (const void *buffer, size_t len, struct sha256_ctx *ctx)\n{\n  const uint32_t *words = buffer;\n  size_t nwords = len / sizeof (uint32_t);\n  const uint32_t *endp = words + nwords;\n  uint32_t x[16];\n  uint32_t a = ctx->state[0];\n  uint32_t b = ctx->state[1];\n  uint32_t c = ctx->state[2];\n  uint32_t d = ctx->state[3];\n  uint32_t e = ctx->state[4];\n  uint32_t f = ctx->state[5];\n  uint32_t g = ctx->state[6];\n  uint32_t h = ctx->state[7];\n  uint32_t lolen = len;\n\n  /* First increment the byte count.  FIPS PUB 180-2 specifies the possible\n     length of the file up to 2^64 bits.  Here we only compute the\n     number of bytes.  Do a double word increment.  */\n  ctx->total[0] += lolen;\n  ctx->total[1] += (len >> 31 >> 1) + (ctx->total[0] < lolen);\n\n#define rol(x, n) (((x) << (n)) | ((x) >> (32 - (n))))\n#define S0(x) (rol(x,25)^rol(x,14)^(x>>3))\n#define S1(x) (rol(x,15)^rol(x,13)^(x>>10))\n#define SS0(x) (rol(x,30)^rol(x,19)^rol(x,10))\n#define SS1(x) (rol(x,26)^rol(x,21)^rol(x,7))\n\n#define M(I) ( tm =   S1(x[(I-2)&0x0f]) + x[(I-7)&0x0f] \\\n                    + S0(x[(I-15)&0x0f]) + x[I&0x0f]    \\\n               , x[I&0x0f] = tm )\n\n#define R(A,B,C,D,E,F,G,H,K,M)  do { t0 = SS0(A) + F2(A,B,C); \\\n                                     t1 = H + SS1(E)  \\\n                                      + F1(E,F,G)     \\\n                                      + K             \\\n                                      + M;            \\\n                                     D += t1;  H = t0 + t1; \\\n                               } while(0)\n\n  while (words < endp)\n    {\n      uint32_t tm;\n      uint32_t t0, t1;\n      int t;\n      /* FIXME: see sha1.c for a better implementation.  */\n      for (t = 0; t < 16; t++)\n        {\n          x[t] = SWAP (*words);\n          words++;\n        }\n\n      R( a, b, c, d, e, f, g, h, K( 0), x[ 0] );\n      R( h, a, b, c, d, e, f, g, K( 1), x[ 1] );\n      R( g, h, a, b, c, d, e, f, K( 2), x[ 2] );\n      R( f, g, h, a, b, c, d, e, K( 3), x[ 3] );\n      R( e, f, g, h, a, b, c, d, K( 4), x[ 4] );\n      R( d, e, f, g, h, a, b, c, K( 5), x[ 5] );\n      R( c, d, e, f, g, h, a, b, K( 6), x[ 6] );\n      R( b, c, d, e, f, g, h, a, K( 7), x[ 7] );\n      R( a, b, c, d, e, f, g, h, K( 8), x[ 8] );\n      R( h, a, b, c, d, e, f, g, K( 9), x[ 9] );\n      R( g, h, a, b, c, d, e, f, K(10), x[10] );\n      R( f, g, h, a, b, c, d, e, K(11), x[11] );\n      R( e, f, g, h, a, b, c, d, K(12), x[12] );\n      R( d, e, f, g, h, a, b, c, K(13), x[13] );\n      R( c, d, e, f, g, h, a, b, K(14), x[14] );\n      R( b, c, d, e, f, g, h, a, K(15), x[15] );\n      R( a, b, c, d, e, f, g, h, K(16), M(16) );\n      R( h, a, b, c, d, e, f, g, K(17), M(17) );\n      R( g, h, a, b, c, d, e, f, K(18), M(18) );\n      R( f, g, h, a, b, c, d, e, K(19), M(19) );\n      R( e, f, g, h, a, b, c, d, K(20), M(20) );\n      R( d, e, f, g, h, a, b, c, K(21), M(21) );\n      R( c, d, e, f, g, h, a, b, K(22), M(22) );\n      R( b, c, d, e, f, g, h, a, K(23), M(23) );\n      R( a, b, c, d, e, f, g, h, K(24), M(24) );\n      R( h, a, b, c, d, e, f, g, K(25), M(25) );\n      R( g, h, a, b, c, d, e, f, K(26), M(26) );\n      R( f, g, h, a, b, c, d, e, K(27), M(27) );\n      R( e, f, g, h, a, b, c, d, K(28), M(28) );\n      R( d, e, f, g, h, a, b, c, K(29), M(29) );\n      R( c, d, e, f, g, h, a, b, K(30), M(30) );\n      R( b, c, d, e, f, g, h, a, K(31), M(31) );\n      R( a, b, c, d, e, f, g, h, K(32), M(32) );\n      R( h, a, b, c, d, e, f, g, K(33), M(33) );\n      R( g, h, a, b, c, d, e, f, K(34), M(34) );\n      R( f, g, h, a, b, c, d, e, K(35), M(35) );\n      R( e, f, g, h, a, b, c, d, K(36), M(36) );\n      R( d, e, f, g, h, a, b, c, K(37), M(37) );\n      R( c, d, e, f, g, h, a, b, K(38), M(38) );\n      R( b, c, d, e, f, g, h, a, K(39), M(39) );\n      R( a, b, c, d, e, f, g, h, K(40), M(40) );\n      R( h, a, b, c, d, e, f, g, K(41), M(41) );\n      R( g, h, a, b, c, d, e, f, K(42), M(42) );\n      R( f, g, h, a, b, c, d, e, K(43), M(43) );\n      R( e, f, g, h, a, b, c, d, K(44), M(44) );\n      R( d, e, f, g, h, a, b, c, K(45), M(45) );\n      R( c, d, e, f, g, h, a, b, K(46), M(46) );\n      R( b, c, d, e, f, g, h, a, K(47), M(47) );\n      R( a, b, c, d, e, f, g, h, K(48), M(48) );\n      R( h, a, b, c, d, e, f, g, K(49), M(49) );\n      R( g, h, a, b, c, d, e, f, K(50), M(50) );\n      R( f, g, h, a, b, c, d, e, K(51), M(51) );\n      R( e, f, g, h, a, b, c, d, K(52), M(52) );\n      R( d, e, f, g, h, a, b, c, K(53), M(53) );\n      R( c, d, e, f, g, h, a, b, K(54), M(54) );\n      R( b, c, d, e, f, g, h, a, K(55), M(55) );\n      R( a, b, c, d, e, f, g, h, K(56), M(56) );\n      R( h, a, b, c, d, e, f, g, K(57), M(57) );\n      R( g, h, a, b, c, d, e, f, K(58), M(58) );\n      R( f, g, h, a, b, c, d, e, K(59), M(59) );\n      R( e, f, g, h, a, b, c, d, K(60), M(60) );\n      R( d, e, f, g, h, a, b, c, K(61), M(61) );\n      R( c, d, e, f, g, h, a, b, K(62), M(62) );\n      R( b, c, d, e, f, g, h, a, K(63), M(63) );\n\n      a = ctx->state[0] += a;\n      b = ctx->state[1] += b;\n      c = ctx->state[2] += c;\n      d = ctx->state[3] += d;\n      e = ctx->state[4] += e;\n      f = ctx->state[5] += f;\n      g = ctx->state[6] += g;\n      h = ctx->state[7] += h;\n    }\n}",
      "lines": 128,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "datamash/datamash-1.3/lib/sha256.h": {},
  "datamash/datamash-1.3/lib/sha512.c": {
    "sha512_init_ctx": {
      "start_point": [
        68,
        0
      ],
      "end_point": [
        82,
        1
      ],
      "content": "void\nsha512_init_ctx (struct sha512_ctx *ctx)\n{\n  ctx->state[0] = u64hilo (0x6a09e667, 0xf3bcc908);\n  ctx->state[1] = u64hilo (0xbb67ae85, 0x84caa73b);\n  ctx->state[2] = u64hilo (0x3c6ef372, 0xfe94f82b);\n  ctx->state[3] = u64hilo (0xa54ff53a, 0x5f1d36f1);\n  ctx->state[4] = u64hilo (0x510e527f, 0xade682d1);\n  ctx->state[5] = u64hilo (0x9b05688c, 0x2b3e6c1f);\n  ctx->state[6] = u64hilo (0x1f83d9ab, 0xfb41bd6b);\n  ctx->state[7] = u64hilo (0x5be0cd19, 0x137e2179);\n\n  ctx->total[0] = ctx->total[1] = u64lo (0);\n  ctx->buflen = 0;\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "sha384_init_ctx": {
      "start_point": [
        84,
        0
      ],
      "end_point": [
        98,
        1
      ],
      "content": "void\nsha384_init_ctx (struct sha512_ctx *ctx)\n{\n  ctx->state[0] = u64hilo (0xcbbb9d5d, 0xc1059ed8);\n  ctx->state[1] = u64hilo (0x629a292a, 0x367cd507);\n  ctx->state[2] = u64hilo (0x9159015a, 0x3070dd17);\n  ctx->state[3] = u64hilo (0x152fecd8, 0xf70e5939);\n  ctx->state[4] = u64hilo (0x67332667, 0xffc00b31);\n  ctx->state[5] = u64hilo (0x8eb44a87, 0x68581511);\n  ctx->state[6] = u64hilo (0xdb0c2e0d, 0x64f98fa7);\n  ctx->state[7] = u64hilo (0x47b5481d, 0xbefa4fa4);\n\n  ctx->total[0] = ctx->total[1] = u64lo (0);\n  ctx->buflen = 0;\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "set_uint64": {
      "start_point": [
        103,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "static void\nset_uint64 (char *cp, u64 v)\n{\n  memcpy (cp, &v, sizeof v);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "sha512_read_ctx": {
      "start_point": [
        111,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "void *\nsha512_read_ctx (const struct sha512_ctx *ctx, void *resbuf)\n{\n  int i;\n  char *r = resbuf;\n\n  for (i = 0; i < 8; i++)\n    set_uint64 (r + i * sizeof ctx->state[0], SWAP (ctx->state[i]));\n\n  return resbuf;\n}",
      "lines": 11,
      "depth": 12,
      "decorators": [
        "void",
        "*\nsha512_read_ctx (const struct sha512_ctx *ctx, void *resbuf)",
        "*"
      ]
    },
    "sha384_read_ctx": {
      "start_point": [
        123,
        0
      ],
      "end_point": [
        133,
        1
      ],
      "content": "void *\nsha384_read_ctx (const struct sha512_ctx *ctx, void *resbuf)\n{\n  int i;\n  char *r = resbuf;\n\n  for (i = 0; i < 6; i++)\n    set_uint64 (r + i * sizeof ctx->state[0], SWAP (ctx->state[i]));\n\n  return resbuf;\n}",
      "lines": 11,
      "depth": 12,
      "decorators": [
        "void",
        "*\nsha384_read_ctx (const struct sha512_ctx *ctx, void *resbuf)",
        "*"
      ]
    },
    "sha512_conclude_ctx": {
      "start_point": [
        137,
        0
      ],
      "end_point": [
        162,
        1
      ],
      "content": "static void\nsha512_conclude_ctx (struct sha512_ctx *ctx)\n{\n  /* Take yet unprocessed bytes into account.  */\n  size_t bytes = ctx->buflen;\n  size_t size = (bytes < 112) ? 128 / 8 : 128 * 2 / 8;\n\n  /* Now count remaining bytes.  */\n  ctx->total[0] = u64plus (ctx->total[0], u64lo (bytes));\n  if (u64lt (ctx->total[0], u64lo (bytes)))\n    ctx->total[1] = u64plus (ctx->total[1], u64lo (1));\n\n  /* Put the 128-bit file length in *bits* at the end of the buffer.\n     Use set_uint64 rather than a simple assignment, to avoid risk of\n     unaligned access.  */\n  set_uint64 ((char *) &ctx->buffer[size - 2],\n              SWAP (u64or (u64shl (ctx->total[1], 3),\n                           u64shr (ctx->total[0], 61))));\n  set_uint64 ((char *) &ctx->buffer[size - 1],\n              SWAP (u64shl (ctx->total[0], 3)));\n\n  memcpy (&((char *) ctx->buffer)[bytes], fillbuf, (size - 2) * 8 - bytes);\n\n  /* Process last bytes.  */\n  sha512_process_block (ctx->buffer, size * 8, ctx);\n}",
      "lines": 26,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "sha512_finish_ctx": {
      "start_point": [
        164,
        0
      ],
      "end_point": [
        169,
        1
      ],
      "content": "void *\nsha512_finish_ctx (struct sha512_ctx *ctx, void *resbuf)\n{\n  sha512_conclude_ctx (ctx);\n  return sha512_read_ctx (ctx, resbuf);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void",
        "*\nsha512_finish_ctx (struct sha512_ctx *ctx, void *resbuf)",
        "*"
      ]
    },
    "sha384_finish_ctx": {
      "start_point": [
        171,
        0
      ],
      "end_point": [
        176,
        1
      ],
      "content": "void *\nsha384_finish_ctx (struct sha512_ctx *ctx, void *resbuf)\n{\n  sha512_conclude_ctx (ctx);\n  return sha384_read_ctx (ctx, resbuf);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void",
        "*\nsha384_finish_ctx (struct sha512_ctx *ctx, void *resbuf)",
        "*"
      ]
    },
    "sha512_stream": {
      "start_point": [
        182,
        0
      ],
      "end_point": [
        250,
        1
      ],
      "content": "int\nsha512_stream (FILE *stream, void *resblock)\n{\n  struct sha512_ctx ctx;\n  size_t sum;\n\n  char *buffer = malloc (BLOCKSIZE + 72);\n  if (!buffer)\n    return 1;\n\n  /* Initialize the computation context.  */\n  sha512_init_ctx (&ctx);\n\n  /* Iterate over full file contents.  */\n  while (1)\n    {\n      /* We read the file in blocks of BLOCKSIZE bytes.  One call of the\n         computation function processes the whole buffer so that with the\n         next round of the loop another block can be read.  */\n      size_t n;\n      sum = 0;\n\n      /* Read block.  Take care for partial reads.  */\n      while (1)\n        {\n          n = fread (buffer + sum, 1, BLOCKSIZE - sum, stream);\n\n          sum += n;\n\n          if (sum == BLOCKSIZE)\n            break;\n\n          if (n == 0)\n            {\n              /* Check for the error flag IFF N == 0, so that we don't\n                 exit the loop after a partial read due to e.g., EAGAIN\n                 or EWOULDBLOCK.  */\n              if (ferror (stream))\n                {\n                  free (buffer);\n                  return 1;\n                }\n              goto process_partial_block;\n            }\n\n          /* We've read at least one byte, so ignore errors.  But always\n             check for EOF, since feof may be true even though N > 0.\n             Otherwise, we could end up calling fread after EOF.  */\n          if (feof (stream))\n            goto process_partial_block;\n        }\n\n      /* Process buffer with BLOCKSIZE bytes.  Note that\n                        BLOCKSIZE % 128 == 0\n       */\n      sha512_process_block (buffer, BLOCKSIZE, &ctx);\n    }\n\n process_partial_block:;\n\n  /* Process any remaining bytes.  */\n  if (sum > 0)\n    sha512_process_bytes (buffer, sum, &ctx);\n\n  /* Construct result in desired memory.  */\n  sha512_finish_ctx (&ctx, resblock);\n  free (buffer);\n  return 0;\n}",
      "lines": 69,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "sha384_stream": {
      "start_point": [
        253,
        0
      ],
      "end_point": [
        321,
        1
      ],
      "content": "int\nsha384_stream (FILE *stream, void *resblock)\n{\n  struct sha512_ctx ctx;\n  size_t sum;\n\n  char *buffer = malloc (BLOCKSIZE + 72);\n  if (!buffer)\n    return 1;\n\n  /* Initialize the computation context.  */\n  sha384_init_ctx (&ctx);\n\n  /* Iterate over full file contents.  */\n  while (1)\n    {\n      /* We read the file in blocks of BLOCKSIZE bytes.  One call of the\n         computation function processes the whole buffer so that with the\n         next round of the loop another block can be read.  */\n      size_t n;\n      sum = 0;\n\n      /* Read block.  Take care for partial reads.  */\n      while (1)\n        {\n          n = fread (buffer + sum, 1, BLOCKSIZE - sum, stream);\n\n          sum += n;\n\n          if (sum == BLOCKSIZE)\n            break;\n\n          if (n == 0)\n            {\n              /* Check for the error flag IFF N == 0, so that we don't\n                 exit the loop after a partial read due to e.g., EAGAIN\n                 or EWOULDBLOCK.  */\n              if (ferror (stream))\n                {\n                  free (buffer);\n                  return 1;\n                }\n              goto process_partial_block;\n            }\n\n          /* We've read at least one byte, so ignore errors.  But always\n             check for EOF, since feof may be true even though N > 0.\n             Otherwise, we could end up calling fread after EOF.  */\n          if (feof (stream))\n            goto process_partial_block;\n        }\n\n      /* Process buffer with BLOCKSIZE bytes.  Note that\n                        BLOCKSIZE % 128 == 0\n       */\n      sha512_process_block (buffer, BLOCKSIZE, &ctx);\n    }\n\n process_partial_block:;\n\n  /* Process any remaining bytes.  */\n  if (sum > 0)\n    sha512_process_bytes (buffer, sum, &ctx);\n\n  /* Construct result in desired memory.  */\n  sha384_finish_ctx (&ctx, resblock);\n  free (buffer);\n  return 0;\n}",
      "lines": 69,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "sha512_buffer": {
      "start_point": [
        328,
        0
      ],
      "end_point": [
        341,
        1
      ],
      "content": "void *\nsha512_buffer (const char *buffer, size_t len, void *resblock)\n{\n  struct sha512_ctx ctx;\n\n  /* Initialize the computation context.  */\n  sha512_init_ctx (&ctx);\n\n  /* Process whole buffer but last len % 128 bytes.  */\n  sha512_process_bytes (buffer, len, &ctx);\n\n  /* Put result in desired memory area.  */\n  return sha512_finish_ctx (&ctx, resblock);\n}",
      "lines": 14,
      "depth": 7,
      "decorators": [
        "void",
        "*\nsha512_buffer (const char *buffer, size_t len, void *resblock)",
        "*"
      ]
    },
    "sha384_buffer": {
      "start_point": [
        343,
        0
      ],
      "end_point": [
        356,
        1
      ],
      "content": "void *\nsha384_buffer (const char *buffer, size_t len, void *resblock)\n{\n  struct sha512_ctx ctx;\n\n  /* Initialize the computation context.  */\n  sha384_init_ctx (&ctx);\n\n  /* Process whole buffer but last len % 128 bytes.  */\n  sha512_process_bytes (buffer, len, &ctx);\n\n  /* Put result in desired memory area.  */\n  return sha384_finish_ctx (&ctx, resblock);\n}",
      "lines": 14,
      "depth": 7,
      "decorators": [
        "void",
        "*\nsha384_buffer (const char *buffer, size_t len, void *resblock)",
        "*"
      ]
    },
    "sha512_process_bytes": {
      "start_point": [
        358,
        0
      ],
      "end_point": [
        425,
        1
      ],
      "content": "void\nsha512_process_bytes (const void *buffer, size_t len, struct sha512_ctx *ctx)\n{\n  /* When we already have some bits in our internal buffer concatenate\n     both inputs first.  */\n  if (ctx->buflen != 0)\n    {\n      size_t left_over = ctx->buflen;\n      size_t add = 256 - left_over > len ? len : 256 - left_over;\n\n      memcpy (&((char *) ctx->buffer)[left_over], buffer, add);\n      ctx->buflen += add;\n\n      if (ctx->buflen > 128)\n        {\n          sha512_process_block (ctx->buffer, ctx->buflen & ~127, ctx);\n\n          ctx->buflen &= 127;\n          /* The regions in the following copy operation cannot overlap,\n             because ctx->buflen < 128 \u00e2\u0089\u00a4 (left_over + add) & ~127.  */\n          memcpy (ctx->buffer,\n                  &((char *) ctx->buffer)[(left_over + add) & ~127],\n                  ctx->buflen);\n        }\n\n      buffer = (const char *) buffer + add;\n      len -= add;\n    }\n\n  /* Process available complete blocks.  */\n  if (len >= 128)\n    {\n#if !(_STRING_ARCH_unaligned || _STRING_INLINE_unaligned)\n# define UNALIGNED_P(p) ((uintptr_t) (p) % alignof (u64) != 0)\n      if (UNALIGNED_P (buffer))\n        while (len > 128)\n          {\n            sha512_process_block (memcpy (ctx->buffer, buffer, 128), 128, ctx);\n            buffer = (const char *) buffer + 128;\n            len -= 128;\n          }\n      else\n#endif\n        {\n          sha512_process_block (buffer, len & ~127, ctx);\n          buffer = (const char *) buffer + (len & ~127);\n          len &= 127;\n        }\n    }\n\n  /* Move remaining bytes in internal buffer.  */\n  if (len > 0)\n    {\n      size_t left_over = ctx->buflen;\n\n      memcpy (&((char *) ctx->buffer)[left_over], buffer, len);\n      left_over += len;\n      if (left_over >= 128)\n        {\n          sha512_process_block (ctx->buffer, 128, ctx);\n          left_over -= 128;\n          /* The regions in the following copy operation cannot overlap,\n             because left_over \u00e2\u0089\u00a4 128.  */\n          memcpy (ctx->buffer, &ctx->buffer[16], left_over);\n        }\n      ctx->buflen = left_over;\n    }\n}",
      "lines": 68,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "sha512_process_block": {
      "start_point": [
        482,
        0
      ],
      "end_point": [
        629,
        1
      ],
      "content": "void\nsha512_process_block (const void *buffer, size_t len, struct sha512_ctx *ctx)\n{\n  u64 const *words = buffer;\n  u64 const *endp = words + len / sizeof (u64);\n  u64 x[16];\n  u64 a = ctx->state[0];\n  u64 b = ctx->state[1];\n  u64 c = ctx->state[2];\n  u64 d = ctx->state[3];\n  u64 e = ctx->state[4];\n  u64 f = ctx->state[5];\n  u64 g = ctx->state[6];\n  u64 h = ctx->state[7];\n  u64 lolen = u64size (len);\n\n  /* First increment the byte count.  FIPS PUB 180-2 specifies the possible\n     length of the file up to 2^128 bits.  Here we only compute the\n     number of bytes.  Do a double word increment.  */\n  ctx->total[0] = u64plus (ctx->total[0], lolen);\n  ctx->total[1] = u64plus (ctx->total[1],\n                           u64plus (u64size (len >> 31 >> 31 >> 2),\n                                    u64lo (u64lt (ctx->total[0], lolen))));\n\n#define S0(x) u64xor (u64rol(x, 63), u64xor (u64rol (x, 56), u64shr (x, 7)))\n#define S1(x) u64xor (u64rol (x, 45), u64xor (u64rol (x, 3), u64shr (x, 6)))\n#define SS0(x) u64xor (u64rol (x, 36), u64xor (u64rol (x, 30), u64rol (x, 25)))\n#define SS1(x) u64xor (u64rol(x, 50), u64xor (u64rol (x, 46), u64rol (x, 23)))\n\n#define M(I) (x[(I) & 15]                                                 \\\n              = u64plus (x[(I) & 15],                                     \\\n                         u64plus (S1 (x[((I) - 2) & 15]),                 \\\n                                  u64plus (x[((I) - 7) & 15],             \\\n                                           S0 (x[((I) - 15) & 15])))))\n\n#define R(A, B, C, D, E, F, G, H, K, M)                                   \\\n  do                                                                      \\\n    {                                                                     \\\n      u64 t0 = u64plus (SS0 (A), F2 (A, B, C));                           \\\n      u64 t1 =                                                            \\\n        u64plus (H, u64plus (SS1 (E),                                     \\\n                             u64plus (F1 (E, F, G), u64plus (K, M))));    \\\n      D = u64plus (D, t1);                                                \\\n      H = u64plus (t0, t1);                                               \\\n    }                                                                     \\\n  while (0)\n\n  while (words < endp)\n    {\n      int t;\n      /* FIXME: see sha1.c for a better implementation.  */\n      for (t = 0; t < 16; t++)\n        {\n          x[t] = SWAP (*words);\n          words++;\n        }\n\n      R( a, b, c, d, e, f, g, h, K( 0), x[ 0] );\n      R( h, a, b, c, d, e, f, g, K( 1), x[ 1] );\n      R( g, h, a, b, c, d, e, f, K( 2), x[ 2] );\n      R( f, g, h, a, b, c, d, e, K( 3), x[ 3] );\n      R( e, f, g, h, a, b, c, d, K( 4), x[ 4] );\n      R( d, e, f, g, h, a, b, c, K( 5), x[ 5] );\n      R( c, d, e, f, g, h, a, b, K( 6), x[ 6] );\n      R( b, c, d, e, f, g, h, a, K( 7), x[ 7] );\n      R( a, b, c, d, e, f, g, h, K( 8), x[ 8] );\n      R( h, a, b, c, d, e, f, g, K( 9), x[ 9] );\n      R( g, h, a, b, c, d, e, f, K(10), x[10] );\n      R( f, g, h, a, b, c, d, e, K(11), x[11] );\n      R( e, f, g, h, a, b, c, d, K(12), x[12] );\n      R( d, e, f, g, h, a, b, c, K(13), x[13] );\n      R( c, d, e, f, g, h, a, b, K(14), x[14] );\n      R( b, c, d, e, f, g, h, a, K(15), x[15] );\n      R( a, b, c, d, e, f, g, h, K(16), M(16) );\n      R( h, a, b, c, d, e, f, g, K(17), M(17) );\n      R( g, h, a, b, c, d, e, f, K(18), M(18) );\n      R( f, g, h, a, b, c, d, e, K(19), M(19) );\n      R( e, f, g, h, a, b, c, d, K(20), M(20) );\n      R( d, e, f, g, h, a, b, c, K(21), M(21) );\n      R( c, d, e, f, g, h, a, b, K(22), M(22) );\n      R( b, c, d, e, f, g, h, a, K(23), M(23) );\n      R( a, b, c, d, e, f, g, h, K(24), M(24) );\n      R( h, a, b, c, d, e, f, g, K(25), M(25) );\n      R( g, h, a, b, c, d, e, f, K(26), M(26) );\n      R( f, g, h, a, b, c, d, e, K(27), M(27) );\n      R( e, f, g, h, a, b, c, d, K(28), M(28) );\n      R( d, e, f, g, h, a, b, c, K(29), M(29) );\n      R( c, d, e, f, g, h, a, b, K(30), M(30) );\n      R( b, c, d, e, f, g, h, a, K(31), M(31) );\n      R( a, b, c, d, e, f, g, h, K(32), M(32) );\n      R( h, a, b, c, d, e, f, g, K(33), M(33) );\n      R( g, h, a, b, c, d, e, f, K(34), M(34) );\n      R( f, g, h, a, b, c, d, e, K(35), M(35) );\n      R( e, f, g, h, a, b, c, d, K(36), M(36) );\n      R( d, e, f, g, h, a, b, c, K(37), M(37) );\n      R( c, d, e, f, g, h, a, b, K(38), M(38) );\n      R( b, c, d, e, f, g, h, a, K(39), M(39) );\n      R( a, b, c, d, e, f, g, h, K(40), M(40) );\n      R( h, a, b, c, d, e, f, g, K(41), M(41) );\n      R( g, h, a, b, c, d, e, f, K(42), M(42) );\n      R( f, g, h, a, b, c, d, e, K(43), M(43) );\n      R( e, f, g, h, a, b, c, d, K(44), M(44) );\n      R( d, e, f, g, h, a, b, c, K(45), M(45) );\n      R( c, d, e, f, g, h, a, b, K(46), M(46) );\n      R( b, c, d, e, f, g, h, a, K(47), M(47) );\n      R( a, b, c, d, e, f, g, h, K(48), M(48) );\n      R( h, a, b, c, d, e, f, g, K(49), M(49) );\n      R( g, h, a, b, c, d, e, f, K(50), M(50) );\n      R( f, g, h, a, b, c, d, e, K(51), M(51) );\n      R( e, f, g, h, a, b, c, d, K(52), M(52) );\n      R( d, e, f, g, h, a, b, c, K(53), M(53) );\n      R( c, d, e, f, g, h, a, b, K(54), M(54) );\n      R( b, c, d, e, f, g, h, a, K(55), M(55) );\n      R( a, b, c, d, e, f, g, h, K(56), M(56) );\n      R( h, a, b, c, d, e, f, g, K(57), M(57) );\n      R( g, h, a, b, c, d, e, f, K(58), M(58) );\n      R( f, g, h, a, b, c, d, e, K(59), M(59) );\n      R( e, f, g, h, a, b, c, d, K(60), M(60) );\n      R( d, e, f, g, h, a, b, c, K(61), M(61) );\n      R( c, d, e, f, g, h, a, b, K(62), M(62) );\n      R( b, c, d, e, f, g, h, a, K(63), M(63) );\n      R( a, b, c, d, e, f, g, h, K(64), M(64) );\n      R( h, a, b, c, d, e, f, g, K(65), M(65) );\n      R( g, h, a, b, c, d, e, f, K(66), M(66) );\n      R( f, g, h, a, b, c, d, e, K(67), M(67) );\n      R( e, f, g, h, a, b, c, d, K(68), M(68) );\n      R( d, e, f, g, h, a, b, c, K(69), M(69) );\n      R( c, d, e, f, g, h, a, b, K(70), M(70) );\n      R( b, c, d, e, f, g, h, a, K(71), M(71) );\n      R( a, b, c, d, e, f, g, h, K(72), M(72) );\n      R( h, a, b, c, d, e, f, g, K(73), M(73) );\n      R( g, h, a, b, c, d, e, f, K(74), M(74) );\n      R( f, g, h, a, b, c, d, e, K(75), M(75) );\n      R( e, f, g, h, a, b, c, d, K(76), M(76) );\n      R( d, e, f, g, h, a, b, c, K(77), M(77) );\n      R( c, d, e, f, g, h, a, b, K(78), M(78) );\n      R( b, c, d, e, f, g, h, a, K(79), M(79) );\n\n      a = ctx->state[0] = u64plus (ctx->state[0], a);\n      b = ctx->state[1] = u64plus (ctx->state[1], b);\n      c = ctx->state[2] = u64plus (ctx->state[2], c);\n      d = ctx->state[3] = u64plus (ctx->state[3], d);\n      e = ctx->state[4] = u64plus (ctx->state[4], e);\n      f = ctx->state[5] = u64plus (ctx->state[5], f);\n      g = ctx->state[6] = u64plus (ctx->state[6], g);\n      h = ctx->state[7] = u64plus (ctx->state[7], h);\n    }\n}",
      "lines": 148,
      "depth": 15,
      "decorators": [
        "void"
      ]
    }
  },
  "datamash/datamash-1.3/lib/sha512.h": {},
  "datamash/datamash-1.3/lib/signbitd.c": {
    "gl_signbitd": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        63,
        1
      ],
      "content": "int\ngl_signbitd (double arg)\n{\n#if defined DBL_SIGNBIT_WORD && defined DBL_SIGNBIT_BIT\n  /* The use of a union to extract the bits of the representation of a\n     'long double' is safe in practice, despite of the \"aliasing rules\" of\n     C99, because the GCC docs say\n       \"Even with '-fstrict-aliasing', type-punning is allowed, provided the\n        memory is accessed through the union type.\"\n     and similarly for other compilers.  */\n# define NWORDS \\\n    ((sizeof (double) + sizeof (unsigned int) - 1) / sizeof (unsigned int))\n  union { double value; unsigned int word[NWORDS]; } m;\n  m.value = arg;\n  return (m.word[DBL_SIGNBIT_WORD] >> DBL_SIGNBIT_BIT) & 1;\n#elif HAVE_COPYSIGN_IN_LIBC\n  return copysign (1.0, arg) < 0;\n#else\n  /* This does not do the right thing for NaN, but this is irrelevant for\n     most use cases.  */\n  if (isnand (arg))\n    return 0;\n  if (arg < 0.0)\n    return 1;\n  else if (arg == 0.0)\n    {\n      /* Distinguish 0.0 and -0.0.  */\n      static double plus_zero = 0.0;\n      double arg_mem = arg;\n      return (memcmp (&plus_zero, &arg_mem, SIZEOF_DBL) != 0);\n    }\n  else\n    return 0;\n#endif\n}",
      "lines": 35,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "datamash/datamash-1.3/lib/signbitf.c": {
    "gl_signbitf": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        63,
        1
      ],
      "content": "int\ngl_signbitf (float arg)\n{\n#if defined FLT_SIGNBIT_WORD && defined FLT_SIGNBIT_BIT\n  /* The use of a union to extract the bits of the representation of a\n     'long double' is safe in practice, despite of the \"aliasing rules\" of\n     C99, because the GCC docs say\n       \"Even with '-fstrict-aliasing', type-punning is allowed, provided the\n        memory is accessed through the union type.\"\n     and similarly for other compilers.  */\n# define NWORDS \\\n    ((sizeof (float) + sizeof (unsigned int) - 1) / sizeof (unsigned int))\n  union { float value; unsigned int word[NWORDS]; } m;\n  m.value = arg;\n  return (m.word[FLT_SIGNBIT_WORD] >> FLT_SIGNBIT_BIT) & 1;\n#elif HAVE_COPYSIGNF_IN_LIBC\n  return copysignf (1.0f, arg) < 0;\n#else\n  /* This does not do the right thing for NaN, but this is irrelevant for\n     most use cases.  */\n  if (isnanf (arg))\n    return 0;\n  if (arg < 0.0f)\n    return 1;\n  else if (arg == 0.0f)\n    {\n      /* Distinguish 0.0f and -0.0f.  */\n      static float plus_zero = 0.0f;\n      float arg_mem = arg;\n      return (memcmp (&plus_zero, &arg_mem, SIZEOF_FLT) != 0);\n    }\n  else\n    return 0;\n#endif\n}",
      "lines": 35,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "datamash/datamash-1.3/lib/signbitl.c": {
    "gl_signbitl": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        63,
        1
      ],
      "content": "int\ngl_signbitl (long double arg)\n{\n#if defined LDBL_SIGNBIT_WORD && defined LDBL_SIGNBIT_BIT\n  /* The use of a union to extract the bits of the representation of a\n     'long double' is safe in practice, despite of the \"aliasing rules\" of\n     C99, because the GCC docs say\n       \"Even with '-fstrict-aliasing', type-punning is allowed, provided the\n        memory is accessed through the union type.\"\n     and similarly for other compilers.  */\n# define NWORDS \\\n    ((sizeof (long double) + sizeof (unsigned int) - 1) / sizeof (unsigned int))\n  union { long double value; unsigned int word[NWORDS]; } m;\n  m.value = arg;\n  return (m.word[LDBL_SIGNBIT_WORD] >> LDBL_SIGNBIT_BIT) & 1;\n#elif HAVE_COPYSIGNL_IN_LIBC\n  return copysignl (1.0L, arg) < 0;\n#else\n  /* This does not do the right thing for NaN, but this is irrelevant for\n     most use cases.  */\n  if (isnanl (arg))\n    return 0;\n  if (arg < 0.0L)\n    return 1;\n  else if (arg == 0.0L)\n    {\n      /* Distinguish 0.0L and -0.0L.  */\n      static long double plus_zero = 0.0L;\n      long double arg_mem = arg;\n      return (memcmp (&plus_zero, &arg_mem, SIZEOF_LDBL) != 0);\n    }\n  else\n    return 0;\n#endif\n}",
      "lines": 35,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "datamash/datamash-1.3/lib/size_max.h": {},
  "datamash/datamash-1.3/lib/sqrtl.c": {
    "sqrtl": [
      {
        "start_point": [
          27,
          0
        ],
        "end_point": [
          31,
          1
        ],
        "content": "long double\nsqrtl (long double x)\n{\n  return sqrt (x);\n}",
        "lines": 5,
        "depth": 6,
        "decorators": [
          "long double",
          "long",
          "double"
        ]
      },
      {
        "start_point": [
          38,
          0
        ],
        "end_point": [
          68,
          1
        ],
        "content": "long double\nsqrtl (long double x)\n{\n  long double delta, y;\n  int exponent;\n\n  /* Check for NaN */\n  if (isnanl (x))\n    return x;\n\n  /* Check for negative numbers */\n  if (x < 0.0L)\n    return (long double) sqrt (-1);\n\n  /* Check for zero and infinites */\n  if (x + x == x)\n    return x;\n\n  frexpl (x, &exponent);\n  y = ldexpl (x, -exponent / 2);\n\n  do\n    {\n      delta = y;\n      y = (y + x / y) * 0.5L;\n      delta -= y;\n    }\n  while (delta != 0.0L);\n\n  return y;\n}",
        "lines": 31,
        "depth": 11,
        "decorators": [
          "long double",
          "long",
          "double"
        ]
      }
    ]
  },
  "datamash/datamash-1.3/lib/stdalign.in.h": {},
  "datamash/datamash-1.3/lib/stdarg.in.h": {},
  "datamash/datamash-1.3/lib/stdbool.in.h": {},
  "datamash/datamash-1.3/lib/stddef.in.h": {},
  "datamash/datamash-1.3/lib/stdint.in.h": {},
  "datamash/datamash-1.3/lib/stdio-impl.h": {},
  "datamash/datamash-1.3/lib/stdio.in.h": {},
  "datamash/datamash-1.3/lib/stdlib.in.h": {},
  "datamash/datamash-1.3/lib/stdnoreturn.in.h": {},
  "datamash/datamash-1.3/lib/stpcpy.c": {
    "__stpcpy": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "char *\n__stpcpy (char *dest, const char *src)\n{\n  register char *d = dest;\n  register const char *s = src;\n\n  do\n    *d++ = *s;\n  while (*s++ != '\\0');\n\n  return d - 1;\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "char",
        "*\n__stpcpy (char *dest, const char *src)",
        "*"
      ]
    }
  },
  "datamash/datamash-1.3/lib/str-kmp.h": {
    "knuth_morris_pratt": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        150,
        1
      ],
      "content": "static bool\nknuth_morris_pratt (const UNIT *haystack,\n                    const UNIT *needle, size_t needle_len,\n                    const UNIT **resultp)\n{\n  size_t m = needle_len;\n\n  /* Allocate the table.  */\n  size_t *table = (size_t *) nmalloca (m, sizeof (size_t));\n  if (table == NULL)\n    return false;\n  /* Fill the table.\n     For 0 < i < m:\n       0 < table[i] <= i is defined such that\n       forall 0 < x < table[i]: needle[x..i-1] != needle[0..i-1-x],\n       and table[i] is as large as possible with this property.\n     This implies:\n     1) For 0 < i < m:\n          If table[i] < i,\n          needle[table[i]..i-1] = needle[0..i-1-table[i]].\n     2) For 0 < i < m:\n          rhaystack[0..i-1] == needle[0..i-1]\n          and exists h, i <= h < m: rhaystack[h] != needle[h]\n          implies\n          forall 0 <= x < table[i]: rhaystack[x..x+m-1] != needle[0..m-1].\n     table[0] remains uninitialized.  */\n  {\n    size_t i, j;\n\n    /* i = 1: Nothing to verify for x = 0.  */\n    table[1] = 1;\n    j = 0;\n\n    for (i = 2; i < m; i++)\n      {\n        /* Here: j = i-1 - table[i-1].\n           The inequality needle[x..i-1] != needle[0..i-1-x] is known to hold\n           for x < table[i-1], by induction.\n           Furthermore, if j>0: needle[i-1-j..i-2] = needle[0..j-1].  */\n        UNIT b = CANON_ELEMENT (needle[i - 1]);\n\n        for (;;)\n          {\n            /* Invariants: The inequality needle[x..i-1] != needle[0..i-1-x]\n               is known to hold for x < i-1-j.\n               Furthermore, if j>0: needle[i-1-j..i-2] = needle[0..j-1].  */\n            if (b == CANON_ELEMENT (needle[j]))\n              {\n                /* Set table[i] := i-1-j.  */\n                table[i] = i - ++j;\n                break;\n              }\n            /* The inequality needle[x..i-1] != needle[0..i-1-x] also holds\n               for x = i-1-j, because\n                 needle[i-1] != needle[j] = needle[i-1-x].  */\n            if (j == 0)\n              {\n                /* The inequality holds for all possible x.  */\n                table[i] = i;\n                break;\n              }\n            /* The inequality needle[x..i-1] != needle[0..i-1-x] also holds\n               for i-1-j < x < i-1-j+table[j], because for these x:\n                 needle[x..i-2]\n                 = needle[x-(i-1-j)..j-1]\n                 != needle[0..j-1-(x-(i-1-j))]  (by definition of table[j])\n                    = needle[0..i-2-x],\n               hence needle[x..i-1] != needle[0..i-1-x].\n               Furthermore\n                 needle[i-1-j+table[j]..i-2]\n                 = needle[table[j]..j-1]\n                 = needle[0..j-1-table[j]]  (by definition of table[j]).  */\n            j = j - table[j];\n          }\n        /* Here: j = i - table[i].  */\n      }\n  }\n\n  /* Search, using the table to accelerate the processing.  */\n  {\n    size_t j;\n    const UNIT *rhaystack;\n    const UNIT *phaystack;\n\n    *resultp = NULL;\n    j = 0;\n    rhaystack = haystack;\n    phaystack = haystack;\n    /* Invariant: phaystack = rhaystack + j.  */\n    while (*phaystack != 0)\n      if (CANON_ELEMENT (needle[j]) == CANON_ELEMENT (*phaystack))\n        {\n          j++;\n          phaystack++;\n          if (j == m)\n            {\n              /* The entire needle has been found.  */\n              *resultp = rhaystack;\n              break;\n            }\n        }\n      else if (j > 0)\n        {\n          /* Found a match of needle[0..j-1], mismatch at needle[j].  */\n          rhaystack += table[j];\n          j -= table[j];\n        }\n      else\n        {\n          /* Found a mismatch at needle[0] already.  */\n          rhaystack++;\n          phaystack++;\n        }\n  }\n\n  freea (table);\n  return true;\n}",
      "lines": 118,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    }
  },
  "datamash/datamash-1.3/lib/streq.h": {
    "streq9": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "static inline int\nstreq9 (const char *s1, const char *s2)\n{\n  return strcmp (s1 + 9, s2 + 9) == 0;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq8": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "static inline int\nstreq8 (const char *s1, const char *s2, char s28)\n{\n  if (s1[8] == s28)\n    {\n      if (s28 == 0)\n        return 1;\n      else\n        return streq9 (s1, s2);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq7": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        65,
        1
      ],
      "content": "static inline int\nstreq7 (const char *s1, const char *s2, char s27, char s28)\n{\n  if (s1[7] == s27)\n    {\n      if (s27 == 0)\n        return 1;\n      else\n        return streq8 (s1, s2, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq6": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "static inline int\nstreq6 (const char *s1, const char *s2, char s26, char s27, char s28)\n{\n  if (s1[6] == s26)\n    {\n      if (s26 == 0)\n        return 1;\n      else\n        return streq7 (s1, s2, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq5": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "static inline int\nstreq5 (const char *s1, const char *s2, char s25, char s26, char s27, char s28)\n{\n  if (s1[5] == s25)\n    {\n      if (s25 == 0)\n        return 1;\n      else\n        return streq6 (s1, s2, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq4": {
      "start_point": [
        95,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "static inline int\nstreq4 (const char *s1, const char *s2, char s24, char s25, char s26, char s27, char s28)\n{\n  if (s1[4] == s24)\n    {\n      if (s24 == 0)\n        return 1;\n      else\n        return streq5 (s1, s2, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq3": {
      "start_point": [
        109,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "static inline int\nstreq3 (const char *s1, const char *s2, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (s1[3] == s23)\n    {\n      if (s23 == 0)\n        return 1;\n      else\n        return streq4 (s1, s2, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq2": {
      "start_point": [
        123,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "static inline int\nstreq2 (const char *s1, const char *s2, char s22, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (s1[2] == s22)\n    {\n      if (s22 == 0)\n        return 1;\n      else\n        return streq3 (s1, s2, s23, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq1": {
      "start_point": [
        137,
        0
      ],
      "end_point": [
        149,
        1
      ],
      "content": "static inline int\nstreq1 (const char *s1, const char *s2, char s21, char s22, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (s1[1] == s21)\n    {\n      if (s21 == 0)\n        return 1;\n      else\n        return streq2 (s1, s2, s22, s23, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq0": {
      "start_point": [
        151,
        0
      ],
      "end_point": [
        163,
        1
      ],
      "content": "static inline int\nstreq0 (const char *s1, const char *s2, char s20, char s21, char s22, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (s1[0] == s20)\n    {\n      if (s20 == 0)\n        return 1;\n      else\n        return streq1 (s1, s2, s21, s22, s23, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    }
  },
  "datamash/datamash-1.3/lib/strerror-override.c": {
    "strerror_override": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        301,
        1
      ],
      "content": "const char *\nstrerror_override (int errnum)\n{\n  /* These error messages are taken from glibc/sysdeps/gnu/errlist.c.  */\n  switch (errnum)\n    {\n#if REPLACE_STRERROR_0\n    case 0:\n      return \"Success\";\n#endif\n\n#if GNULIB_defined_ESOCK /* native Windows platforms with older <errno.h> */\n    case EINPROGRESS:\n      return \"Operation now in progress\";\n    case EALREADY:\n      return \"Operation already in progress\";\n    case ENOTSOCK:\n      return \"Socket operation on non-socket\";\n    case EDESTADDRREQ:\n      return \"Destination address required\";\n    case EMSGSIZE:\n      return \"Message too long\";\n    case EPROTOTYPE:\n      return \"Protocol wrong type for socket\";\n    case ENOPROTOOPT:\n      return \"Protocol not available\";\n    case EPROTONOSUPPORT:\n      return \"Protocol not supported\";\n    case EOPNOTSUPP:\n      return \"Operation not supported\";\n    case EAFNOSUPPORT:\n      return \"Address family not supported by protocol\";\n    case EADDRINUSE:\n      return \"Address already in use\";\n    case EADDRNOTAVAIL:\n      return \"Cannot assign requested address\";\n    case ENETDOWN:\n      return \"Network is down\";\n    case ENETUNREACH:\n      return \"Network is unreachable\";\n    case ECONNRESET:\n      return \"Connection reset by peer\";\n    case ENOBUFS:\n      return \"No buffer space available\";\n    case EISCONN:\n      return \"Transport endpoint is already connected\";\n    case ENOTCONN:\n      return \"Transport endpoint is not connected\";\n    case ETIMEDOUT:\n      return \"Connection timed out\";\n    case ECONNREFUSED:\n      return \"Connection refused\";\n    case ELOOP:\n      return \"Too many levels of symbolic links\";\n    case EHOSTUNREACH:\n      return \"No route to host\";\n    case EWOULDBLOCK:\n      return \"Operation would block\";\n#endif\n#if GNULIB_defined_ESTREAMS /* native Windows platforms with older <errno.h> */\n    case ETXTBSY:\n      return \"Text file busy\";\n    case ENODATA:\n      return \"No data available\";\n    case ENOSR:\n      return \"Out of streams resources\";\n    case ENOSTR:\n      return \"Device not a stream\";\n    case ETIME:\n      return \"Timer expired\";\n    case EOTHER:\n      return \"Other error\";\n#endif\n#if GNULIB_defined_EWINSOCK /* native Windows platforms */\n    case ESOCKTNOSUPPORT:\n      return \"Socket type not supported\";\n    case EPFNOSUPPORT:\n      return \"Protocol family not supported\";\n    case ESHUTDOWN:\n      return \"Cannot send after transport endpoint shutdown\";\n    case ETOOMANYREFS:\n      return \"Too many references: cannot splice\";\n    case EHOSTDOWN:\n      return \"Host is down\";\n    case EPROCLIM:\n      return \"Too many processes\";\n    case EUSERS:\n      return \"Too many users\";\n    case EDQUOT:\n      return \"Disk quota exceeded\";\n    case ESTALE:\n      return \"Stale NFS file handle\";\n    case EREMOTE:\n      return \"Object is remote\";\n# if HAVE_WINSOCK2_H\n      /* WSA_INVALID_HANDLE maps to EBADF */\n      /* WSA_NOT_ENOUGH_MEMORY maps to ENOMEM */\n      /* WSA_INVALID_PARAMETER maps to EINVAL */\n    case WSA_OPERATION_ABORTED:\n      return \"Overlapped operation aborted\";\n    case WSA_IO_INCOMPLETE:\n      return \"Overlapped I/O event object not in signaled state\";\n    case WSA_IO_PENDING:\n      return \"Overlapped operations will complete later\";\n      /* WSAEINTR maps to EINTR */\n      /* WSAEBADF maps to EBADF */\n      /* WSAEACCES maps to EACCES */\n      /* WSAEFAULT maps to EFAULT */\n      /* WSAEINVAL maps to EINVAL */\n      /* WSAEMFILE maps to EMFILE */\n      /* WSAEWOULDBLOCK maps to EWOULDBLOCK */\n      /* WSAEINPROGRESS maps to EINPROGRESS */\n      /* WSAEALREADY maps to EALREADY */\n      /* WSAENOTSOCK maps to ENOTSOCK */\n      /* WSAEDESTADDRREQ maps to EDESTADDRREQ */\n      /* WSAEMSGSIZE maps to EMSGSIZE */\n      /* WSAEPROTOTYPE maps to EPROTOTYPE */\n      /* WSAENOPROTOOPT maps to ENOPROTOOPT */\n      /* WSAEPROTONOSUPPORT maps to EPROTONOSUPPORT */\n      /* WSAESOCKTNOSUPPORT is ESOCKTNOSUPPORT */\n      /* WSAEOPNOTSUPP maps to EOPNOTSUPP */\n      /* WSAEPFNOSUPPORT is EPFNOSUPPORT */\n      /* WSAEAFNOSUPPORT maps to EAFNOSUPPORT */\n      /* WSAEADDRINUSE maps to EADDRINUSE */\n      /* WSAEADDRNOTAVAIL maps to EADDRNOTAVAIL */\n      /* WSAENETDOWN maps to ENETDOWN */\n      /* WSAENETUNREACH maps to ENETUNREACH */\n      /* WSAENETRESET maps to ENETRESET */\n      /* WSAECONNABORTED maps to ECONNABORTED */\n      /* WSAECONNRESET maps to ECONNRESET */\n      /* WSAENOBUFS maps to ENOBUFS */\n      /* WSAEISCONN maps to EISCONN */\n      /* WSAENOTCONN maps to ENOTCONN */\n      /* WSAESHUTDOWN is ESHUTDOWN */\n      /* WSAETOOMANYREFS is ETOOMANYREFS */\n      /* WSAETIMEDOUT maps to ETIMEDOUT */\n      /* WSAECONNREFUSED maps to ECONNREFUSED */\n      /* WSAELOOP maps to ELOOP */\n      /* WSAENAMETOOLONG maps to ENAMETOOLONG */\n      /* WSAEHOSTDOWN is EHOSTDOWN */\n      /* WSAEHOSTUNREACH maps to EHOSTUNREACH */\n      /* WSAENOTEMPTY maps to ENOTEMPTY */\n      /* WSAEPROCLIM is EPROCLIM */\n      /* WSAEUSERS is EUSERS */\n      /* WSAEDQUOT is EDQUOT */\n      /* WSAESTALE is ESTALE */\n      /* WSAEREMOTE is EREMOTE */\n    case WSASYSNOTREADY:\n      return \"Network subsystem is unavailable\";\n    case WSAVERNOTSUPPORTED:\n      return \"Winsock.dll version out of range\";\n    case WSANOTINITIALISED:\n      return \"Successful WSAStartup not yet performed\";\n    case WSAEDISCON:\n      return \"Graceful shutdown in progress\";\n    case WSAENOMORE: case WSA_E_NO_MORE:\n      return \"No more results\";\n    case WSAECANCELLED: case WSA_E_CANCELLED:\n      return \"Call was canceled\";\n    case WSAEINVALIDPROCTABLE:\n      return \"Procedure call table is invalid\";\n    case WSAEINVALIDPROVIDER:\n      return \"Service provider is invalid\";\n    case WSAEPROVIDERFAILEDINIT:\n      return \"Service provider failed to initialize\";\n    case WSASYSCALLFAILURE:\n      return \"System call failure\";\n    case WSASERVICE_NOT_FOUND:\n      return \"Service not found\";\n    case WSATYPE_NOT_FOUND:\n      return \"Class type not found\";\n    case WSAEREFUSED:\n      return \"Database query was refused\";\n    case WSAHOST_NOT_FOUND:\n      return \"Host not found\";\n    case WSATRY_AGAIN:\n      return \"Nonauthoritative host not found\";\n    case WSANO_RECOVERY:\n      return \"Nonrecoverable error\";\n    case WSANO_DATA:\n      return \"Valid name, no data record of requested type\";\n      /* WSA_QOS_* omitted */\n# endif\n#endif\n\n#if GNULIB_defined_ENOMSG\n    case ENOMSG:\n      return \"No message of desired type\";\n#endif\n\n#if GNULIB_defined_EIDRM\n    case EIDRM:\n      return \"Identifier removed\";\n#endif\n\n#if GNULIB_defined_ENOLINK\n    case ENOLINK:\n      return \"Link has been severed\";\n#endif\n\n#if GNULIB_defined_EPROTO\n    case EPROTO:\n      return \"Protocol error\";\n#endif\n\n#if GNULIB_defined_EMULTIHOP\n    case EMULTIHOP:\n      return \"Multihop attempted\";\n#endif\n\n#if GNULIB_defined_EBADMSG\n    case EBADMSG:\n      return \"Bad message\";\n#endif\n\n#if GNULIB_defined_EOVERFLOW\n    case EOVERFLOW:\n      return \"Value too large for defined data type\";\n#endif\n\n#if GNULIB_defined_ENOTSUP\n    case ENOTSUP:\n      return \"Not supported\";\n#endif\n\n#if GNULIB_defined_ENETRESET\n    case ENETRESET:\n      return \"Network dropped connection on reset\";\n#endif\n\n#if GNULIB_defined_ECONNABORTED\n    case ECONNABORTED:\n      return \"Software caused connection abort\";\n#endif\n\n#if GNULIB_defined_ESTALE\n    case ESTALE:\n      return \"Stale NFS file handle\";\n#endif\n\n#if GNULIB_defined_EDQUOT\n    case EDQUOT:\n      return \"Disk quota exceeded\";\n#endif\n\n#if GNULIB_defined_ECANCELED\n    case ECANCELED:\n      return \"Operation canceled\";\n#endif\n\n#if GNULIB_defined_EOWNERDEAD\n    case EOWNERDEAD:\n      return \"Owner died\";\n#endif\n\n#if GNULIB_defined_ENOTRECOVERABLE\n    case ENOTRECOVERABLE:\n      return \"State not recoverable\";\n#endif\n\n#if GNULIB_defined_EILSEQ\n    case EILSEQ:\n      return \"Invalid or incomplete multibyte or wide character\";\n#endif\n\n    default:\n      return NULL;\n    }\n}",
      "lines": 269,
      "depth": 10,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nstrerror_override (int errnum)",
        "*"
      ]
    }
  },
  "datamash/datamash-1.3/lib/strerror-override.h": {},
  "datamash/datamash-1.3/lib/strerror.c": {},
  "datamash/datamash-1.3/lib/striconv.c": {
    "mem_cd_iconv": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        203,
        1
      ],
      "content": "int\nmem_cd_iconv (const char *src, size_t srclen, iconv_t cd,\n              char **resultp, size_t *lengthp)\n{\n# define tmpbufsize 4096\n  size_t length;\n  char *result;\n\n  /* Avoid glibc-2.1 bug and Solaris 2.7-2.9 bug.  */\n# if defined _LIBICONV_VERSION \\\n     || !(((__GLIBC__ == 2 && __GLIBC_MINOR__ <= 1) && !defined __UCLIBC__) \\\n          || defined __sun)\n  /* Set to the initial state.  */\n  iconv (cd, NULL, NULL, NULL, NULL);\n# endif\n\n  /* Determine the length we need.  */\n  {\n    size_t count = 0;\n    /* The alignment is needed when converting e.g. to glibc's WCHAR_T or\n       libiconv's UCS-4-INTERNAL encoding.  */\n    union { unsigned int align; char buf[tmpbufsize]; } tmp;\n# define tmpbuf tmp.buf\n    const char *inptr = src;\n    size_t insize = srclen;\n\n    while (insize > 0)\n      {\n        char *outptr = tmpbuf;\n        size_t outsize = tmpbufsize;\n        size_t res = iconv (cd,\n                            (ICONV_CONST char **) &inptr, &insize,\n                            &outptr, &outsize);\n\n        if (res == (size_t)(-1))\n          {\n            if (errno == E2BIG)\n              ;\n            else if (errno == EINVAL)\n              break;\n            else\n              return -1;\n          }\n# if !defined _LIBICONV_VERSION && !(defined __GLIBC__ && !defined __UCLIBC__)\n        /* Irix iconv() inserts a NUL byte if it cannot convert.\n           NetBSD iconv() inserts a question mark if it cannot convert.\n           Only GNU libiconv and GNU libc are known to prefer to fail rather\n           than doing a lossy conversion.  */\n        else if (res > 0)\n          {\n            errno = EILSEQ;\n            return -1;\n          }\n# endif\n        count += outptr - tmpbuf;\n      }\n    /* Avoid glibc-2.1 bug and Solaris 2.7 bug.  */\n# if defined _LIBICONV_VERSION \\\n     || !(((__GLIBC__ == 2 && __GLIBC_MINOR__ <= 1) && !defined __UCLIBC__) \\\n          || defined __sun)\n    {\n      char *outptr = tmpbuf;\n      size_t outsize = tmpbufsize;\n      size_t res = iconv (cd, NULL, NULL, &outptr, &outsize);\n\n      if (res == (size_t)(-1))\n        return -1;\n      count += outptr - tmpbuf;\n    }\n# endif\n    length = count;\n# undef tmpbuf\n  }\n\n  if (length == 0)\n    {\n      *lengthp = 0;\n      return 0;\n    }\n  if (*resultp != NULL && *lengthp >= length)\n    result = *resultp;\n  else\n    {\n      result = (char *) malloc (length);\n      if (result == NULL)\n        {\n          errno = ENOMEM;\n          return -1;\n        }\n    }\n\n  /* Avoid glibc-2.1 bug and Solaris 2.7-2.9 bug.  */\n# if defined _LIBICONV_VERSION \\\n     || !(((__GLIBC__ == 2 && __GLIBC_MINOR__ <= 1) && !defined __UCLIBC__) \\\n          || defined __sun)\n  /* Return to the initial state.  */\n  iconv (cd, NULL, NULL, NULL, NULL);\n# endif\n\n  /* Do the conversion for real.  */\n  {\n    const char *inptr = src;\n    size_t insize = srclen;\n    char *outptr = result;\n    size_t outsize = length;\n\n    while (insize > 0)\n      {\n        size_t res = iconv (cd,\n                            (ICONV_CONST char **) &inptr, &insize,\n                            &outptr, &outsize);\n\n        if (res == (size_t)(-1))\n          {\n            if (errno == EINVAL)\n              break;\n            else\n              goto fail;\n          }\n# if !defined _LIBICONV_VERSION && !(defined __GLIBC__ && !defined __UCLIBC__)\n        /* Irix iconv() inserts a NUL byte if it cannot convert.\n           NetBSD iconv() inserts a question mark if it cannot convert.\n           Only GNU libiconv and GNU libc are known to prefer to fail rather\n           than doing a lossy conversion.  */\n        else if (res > 0)\n          {\n            errno = EILSEQ;\n            goto fail;\n          }\n# endif\n      }\n    /* Avoid glibc-2.1 bug and Solaris 2.7 bug.  */\n# if defined _LIBICONV_VERSION \\\n     || !(((__GLIBC__ == 2 && __GLIBC_MINOR__ <= 1) && !defined __UCLIBC__) \\\n          || defined __sun)\n    {\n      size_t res = iconv (cd, NULL, NULL, &outptr, &outsize);\n\n      if (res == (size_t)(-1))\n        goto fail;\n    }\n# endif\n    if (outsize != 0)\n      abort ();\n  }\n\n  *resultp = result;\n  *lengthp = length;\n\n  return 0;\n\n fail:\n  {\n    if (result != *resultp)\n      {\n        int saved_errno = errno;\n        free (result);\n        errno = saved_errno;\n      }\n    return -1;\n  }\n# undef tmpbufsize\n}",
      "lines": 163,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "str_cd_iconv": {
      "start_point": [
        205,
        0
      ],
      "end_point": [
        395,
        1
      ],
      "content": "char *\nstr_cd_iconv (const char *src, iconv_t cd)\n{\n  /* For most encodings, a trailing NUL byte in the input will be converted\n     to a trailing NUL byte in the output.  But not for UTF-7.  So that this\n     function is usable for UTF-7, we have to exclude the NUL byte from the\n     conversion and add it by hand afterwards.  */\n# if !defined _LIBICONV_VERSION && !(defined __GLIBC__ && !defined __UCLIBC__)\n  /* Irix iconv() inserts a NUL byte if it cannot convert.\n     NetBSD iconv() inserts a question mark if it cannot convert.\n     Only GNU libiconv and GNU libc are known to prefer to fail rather\n     than doing a lossy conversion.  For other iconv() implementations,\n     we have to look at the number of irreversible conversions returned;\n     but this information is lost when iconv() returns for an E2BIG reason.\n     Therefore we cannot use the second, faster algorithm.  */\n\n  char *result = NULL;\n  size_t length = 0;\n  int retval = mem_cd_iconv (src, strlen (src), cd, &result, &length);\n  char *final_result;\n\n  if (retval < 0)\n    {\n      if (result != NULL)\n        abort ();\n      return NULL;\n    }\n\n  /* Add the terminating NUL byte.  */\n  final_result =\n    (result != NULL ? realloc (result, length + 1) : malloc (length + 1));\n  if (final_result == NULL)\n    {\n      free (result);\n      errno = ENOMEM;\n      return NULL;\n    }\n  final_result[length] = '\\0';\n\n  return final_result;\n\n# else\n  /* This algorithm is likely faster than the one above.  But it may produce\n     iconv() returns for an E2BIG reason, when the output size guess is too\n     small.  Therefore it can only be used when we don't need the number of\n     irreversible conversions performed.  */\n  char *result;\n  size_t result_size;\n  size_t length;\n  const char *inptr = src;\n  size_t inbytes_remaining = strlen (src);\n\n  /* Make a guess for the worst-case output size, in order to avoid a\n     realloc.  It's OK if the guess is wrong as long as it is not zero and\n     doesn't lead to an integer overflow.  */\n  result_size = inbytes_remaining;\n  {\n    size_t approx_sqrt_SIZE_MAX = SIZE_MAX >> (sizeof (size_t) * CHAR_BIT / 2);\n    if (result_size <= approx_sqrt_SIZE_MAX / MB_LEN_MAX)\n      result_size *= MB_LEN_MAX;\n  }\n  result_size += 1; /* for the terminating NUL */\n\n  result = (char *) malloc (result_size);\n  if (result == NULL)\n    {\n      errno = ENOMEM;\n      return NULL;\n    }\n\n  /* Avoid glibc-2.1 bug and Solaris 2.7-2.9 bug.  */\n# if defined _LIBICONV_VERSION \\\n     || !(((__GLIBC__ == 2 && __GLIBC_MINOR__ <= 1) && !defined __UCLIBC__) \\\n          || defined __sun)\n  /* Set to the initial state.  */\n  iconv (cd, NULL, NULL, NULL, NULL);\n# endif\n\n  /* Do the conversion.  */\n  {\n    char *outptr = result;\n    size_t outbytes_remaining = result_size - 1;\n\n    for (;;)\n      {\n        /* Here inptr + inbytes_remaining = src + strlen (src),\n                outptr + outbytes_remaining = result + result_size - 1.  */\n        size_t res = iconv (cd,\n                            (ICONV_CONST char **) &inptr, &inbytes_remaining,\n                            &outptr, &outbytes_remaining);\n\n        if (res == (size_t)(-1))\n          {\n            if (errno == EINVAL)\n              break;\n            else if (errno == E2BIG)\n              {\n                size_t used = outptr - result;\n                size_t newsize = result_size * 2;\n                char *newresult;\n\n                if (!(newsize > result_size))\n                  {\n                    errno = ENOMEM;\n                    goto failed;\n                  }\n                newresult = (char *) realloc (result, newsize);\n                if (newresult == NULL)\n                  {\n                    errno = ENOMEM;\n                    goto failed;\n                  }\n                result = newresult;\n                result_size = newsize;\n                outptr = result + used;\n                outbytes_remaining = result_size - 1 - used;\n              }\n            else\n              goto failed;\n          }\n        else\n          break;\n      }\n    /* Avoid glibc-2.1 bug and Solaris 2.7 bug.  */\n# if defined _LIBICONV_VERSION \\\n     || !(((__GLIBC__ == 2 && __GLIBC_MINOR__ <= 1) && !defined __UCLIBC__) \\\n          || defined __sun)\n    for (;;)\n      {\n        /* Here outptr + outbytes_remaining = result + result_size - 1.  */\n        size_t res = iconv (cd, NULL, NULL, &outptr, &outbytes_remaining);\n\n        if (res == (size_t)(-1))\n          {\n            if (errno == E2BIG)\n              {\n                size_t used = outptr - result;\n                size_t newsize = result_size * 2;\n                char *newresult;\n\n                if (!(newsize > result_size))\n                  {\n                    errno = ENOMEM;\n                    goto failed;\n                  }\n                newresult = (char *) realloc (result, newsize);\n                if (newresult == NULL)\n                  {\n                    errno = ENOMEM;\n                    goto failed;\n                  }\n                result = newresult;\n                result_size = newsize;\n                outptr = result + used;\n                outbytes_remaining = result_size - 1 - used;\n              }\n            else\n              goto failed;\n          }\n        else\n          break;\n      }\n# endif\n\n    /* Add the terminating NUL byte.  */\n    *outptr++ = '\\0';\n\n    length = outptr - result;\n  }\n\n  /* Give away unused memory.  */\n  if (length < result_size)\n    {\n      char *smaller_result = (char *) realloc (result, length);\n\n      if (smaller_result != NULL)\n        result = smaller_result;\n    }\n\n  return result;\n\n failed:\n  {\n    int saved_errno = errno;\n    free (result);\n    errno = saved_errno;\n    return NULL;\n  }\n\n# endif\n}",
      "lines": 191,
      "depth": 18,
      "decorators": [
        "char",
        "*\nstr_cd_iconv (const char *src, iconv_t cd)",
        "*"
      ]
    },
    "str_iconv": {
      "start_point": [
        399,
        0
      ],
      "end_point": [
        462,
        1
      ],
      "content": "char *\nstr_iconv (const char *src, const char *from_codeset, const char *to_codeset)\n{\n  if (*src == '\\0' || c_strcasecmp (from_codeset, to_codeset) == 0)\n    {\n      char *result = strdup (src);\n\n      if (result == NULL)\n        errno = ENOMEM;\n      return result;\n    }\n  else\n    {\n#if HAVE_ICONV\n      iconv_t cd;\n      char *result;\n\n      /* Avoid glibc-2.1 bug with EUC-KR.  */\n# if ((__GLIBC__ == 2 && __GLIBC_MINOR__ <= 1) && !defined __UCLIBC__) \\\n     && !defined _LIBICONV_VERSION\n      if (c_strcasecmp (from_codeset, \"EUC-KR\") == 0\n          || c_strcasecmp (to_codeset, \"EUC-KR\") == 0)\n        {\n          errno = EINVAL;\n          return NULL;\n        }\n# endif\n      cd = iconv_open (to_codeset, from_codeset);\n      if (cd == (iconv_t) -1)\n        return NULL;\n\n      result = str_cd_iconv (src, cd);\n\n      if (result == NULL)\n        {\n          /* Close cd, but preserve the errno from str_cd_iconv.  */\n          int saved_errno = errno;\n          iconv_close (cd);\n          errno = saved_errno;\n        }\n      else\n        {\n          if (iconv_close (cd) < 0)\n            {\n              /* Return NULL, but free the allocated memory, and while doing\n                 that, preserve the errno from iconv_close.  */\n              int saved_errno = errno;\n              free (result);\n              errno = saved_errno;\n              return NULL;\n            }\n        }\n      return result;\n#else\n      /* This is a different error code than if iconv_open existed but didn't\n         support from_codeset and to_codeset, so that the caller can emit\n         an error message such as\n           \"iconv() is not supported. Installing GNU libiconv and\n            then reinstalling this package would fix this.\"  */\n      errno = ENOSYS;\n      return NULL;\n#endif\n    }\n}",
      "lines": 64,
      "depth": 14,
      "decorators": [
        "char",
        "*\nstr_iconv (const char *src, const char *from_codeset, const char *to_codeset)",
        "*"
      ]
    }
  },
  "datamash/datamash-1.3/lib/striconv.h": {},
  "datamash/datamash-1.3/lib/string.in.h": {},
  "datamash/datamash-1.3/lib/stripslash.c": {
    "strip_trailing_slashes": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "bool\nstrip_trailing_slashes (char *file)\n{\n  char *base = last_component (file);\n  char *base_lim;\n  bool had_slash;\n\n  /* last_component returns \"\" for file system roots, but we need to turn\n     \"///\" into \"/\".  */\n  if (! *base)\n    base = file;\n  base_lim = base + base_len (base);\n  had_slash = (*base_lim != '\\0');\n  *base_lim = '\\0';\n  return had_slash;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "bool"
      ]
    }
  },
  "datamash/datamash-1.3/lib/strndup.c": {
    "strndup": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        35,
        1
      ],
      "content": "char *\nstrndup (char const *s, size_t n)\n{\n  size_t len = strnlen (s, n);\n  char *new = malloc (len + 1);\n\n  if (new == NULL)\n    return NULL;\n\n  new[len] = '\\0';\n  return memcpy (new, s, len);\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "char",
        "*\nstrndup (char const *s, size_t n)",
        "*"
      ]
    }
  },
  "datamash/datamash-1.3/lib/strnlen.c": {
    "strnlen": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        29,
        1
      ],
      "content": "size_t\nstrnlen (const char *string, size_t maxlen)\n{\n  const char *end = memchr (string, '\\0', maxlen);\n  return end ? (size_t) (end - string) : maxlen;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "size_t"
      ]
    }
  },
  "datamash/datamash-1.3/lib/strnlen1.c": {
    "strnlen1": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        34,
        1
      ],
      "content": "size_t\nstrnlen1 (const char *string, size_t maxlen)\n{\n  const char *end = (const char *) memchr (string, '\\0', maxlen);\n  if (end != NULL)\n    return end - string + 1;\n  else\n    return maxlen;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "size_t"
      ]
    }
  },
  "datamash/datamash-1.3/lib/strnlen1.h": {},
  "datamash/datamash-1.3/lib/strsep.c": {
    "strsep": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "char *\nstrsep (char **stringp, const char *delim)\n{\n  char *start = *stringp;\n  char *ptr;\n\n  if (start == NULL)\n    return NULL;\n\n  /* Optimize the case of no delimiters.  */\n  if (delim[0] == '\\0')\n    {\n      *stringp = NULL;\n      return start;\n    }\n\n  /* Optimize the case of one delimiter.  */\n  if (delim[1] == '\\0')\n    ptr = strchr (start, delim[0]);\n  else\n    /* The general case.  */\n    ptr = strpbrk (start, delim);\n  if (ptr == NULL)\n    {\n      *stringp = NULL;\n      return start;\n    }\n\n  *ptr = '\\0';\n  *stringp = ptr + 1;\n\n  return start;\n}",
      "lines": 33,
      "depth": 9,
      "decorators": [
        "char",
        "*\nstrsep (char **stringp, const char *delim)",
        "*"
      ]
    }
  },
  "datamash/datamash-1.3/lib/strtoimax.c": {
    "Strtoimax": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        81,
        1
      ],
      "content": "Int\nStrtoimax (char const *ptr, char **endptr, int base)\n{\n#if Have_long_long\n  verify (sizeof (Int) == sizeof (Unsigned long int)\n          || sizeof (Int) == sizeof (Unsigned long long int));\n\n  if (sizeof (Int) != sizeof (Unsigned long int))\n    return Strtoll (ptr, endptr, base);\n#else\n  verify (sizeof (Int) == sizeof (Unsigned long int));\n#endif\n\n  return Strtol (ptr, endptr, base);\n}",
      "lines": 15,
      "depth": 12,
      "decorators": [
        "Int"
      ]
    }
  },
  "datamash/datamash-1.3/lib/strtol.c": {
    "INTERNAL": {
      "start_point": [
        225,
        0
      ],
      "end_point": [
        408,
        1
      ],
      "content": "INT\nINTERNAL (strtol) (const STRING_TYPE *nptr, STRING_TYPE **endptr,\n                   int base, int group LOCALE_PARAM_PROTO)\n{\n  int negative;\n  register unsigned LONG int cutoff;\n  register unsigned int cutlim;\n  register unsigned LONG int i;\n  register const STRING_TYPE *s;\n  register UCHAR_TYPE c;\n  const STRING_TYPE *save, *end;\n  int overflow;\n\n#ifdef USE_NUMBER_GROUPING\n# ifdef USE_IN_EXTENDED_LOCALE_MODEL\n  struct locale_data *current = loc->__locales[LC_NUMERIC];\n# endif\n  /* The thousands character of the current locale.  */\n  wchar_t thousands = L'\\0';\n  /* The numeric grouping specification of the current locale,\n     in the format described in <locale.h>.  */\n  const char *grouping;\n\n  if (group)\n    {\n      grouping = _NL_CURRENT (LC_NUMERIC, GROUPING);\n      if (*grouping <= 0 || *grouping == CHAR_MAX)\n        grouping = NULL;\n      else\n        {\n          /* Figure out the thousands separator character.  */\n# if defined _LIBC || defined _HAVE_BTOWC\n          thousands = __btowc (*_NL_CURRENT (LC_NUMERIC, THOUSANDS_SEP));\n          if (thousands == WEOF)\n            thousands = L'\\0';\n# endif\n          if (thousands == L'\\0')\n            grouping = NULL;\n        }\n    }\n  else\n    grouping = NULL;\n#endif\n\n  if (base < 0 || base == 1 || base > 36)\n    {\n      __set_errno (EINVAL);\n      return 0;\n    }\n\n  save = s = nptr;\n\n  /* Skip white space.  */\n  while (ISSPACE (*s))\n    ++s;\n  if (*s == L_('\\0'))\n    goto noconv;\n\n  /* Check for a sign.  */\n  if (*s == L_('-'))\n    {\n      negative = 1;\n      ++s;\n    }\n  else if (*s == L_('+'))\n    {\n      negative = 0;\n      ++s;\n    }\n  else\n    negative = 0;\n\n  /* Recognize number prefix and if BASE is zero, figure it out ourselves.  */\n  if (*s == L_('0'))\n    {\n      if ((base == 0 || base == 16) && TOUPPER (s[1]) == L_('X'))\n        {\n          s += 2;\n          base = 16;\n        }\n      else if (base == 0)\n        base = 8;\n    }\n  else if (base == 0)\n    base = 10;\n\n  /* Save the pointer so we can check later if anything happened.  */\n  save = s;\n\n#ifdef USE_NUMBER_GROUPING\n  if (group)\n    {\n      /* Find the end of the digit string and check its grouping.  */\n      end = s;\n      for (c = *end; c != L_('\\0'); c = *++end)\n        if ((wchar_t) c != thousands\n            && ((wchar_t) c < L_('0') || (wchar_t) c > L_('9'))\n            && (!ISALPHA (c) || (int) (TOUPPER (c) - L_('A') + 10) >= base))\n          break;\n      if (*s == thousands)\n        end = s;\n      else\n        end = correctly_grouped_prefix (s, end, thousands, grouping);\n    }\n  else\n#endif\n    end = NULL;\n\n  cutoff = STRTOL_ULONG_MAX / (unsigned LONG int) base;\n  cutlim = STRTOL_ULONG_MAX % (unsigned LONG int) base;\n\n  overflow = 0;\n  i = 0;\n  for (c = *s; c != L_('\\0'); c = *++s)\n    {\n      if (s == end)\n        break;\n      if (c >= L_('0') && c <= L_('9'))\n        c -= L_('0');\n      else if (ISALPHA (c))\n        c = TOUPPER (c) - L_('A') + 10;\n      else\n        break;\n      if ((int) c >= base)\n        break;\n      /* Check for overflow.  */\n      if (i > cutoff || (i == cutoff && c > cutlim))\n        overflow = 1;\n      else\n        {\n          i *= (unsigned LONG int) base;\n          i += c;\n        }\n    }\n\n  /* Check if anything actually happened.  */\n  if (s == save)\n    goto noconv;\n\n  /* Store in ENDPTR the address of one character\n     past the last character we converted.  */\n  if (endptr != NULL)\n    *endptr = (STRING_TYPE *) s;\n\n#if !UNSIGNED\n  /* Check for a value that is within the range of\n     'unsigned LONG int', but outside the range of 'LONG int'.  */\n  if (overflow == 0\n      && i > (negative\n              ? -((unsigned LONG int) (STRTOL_LONG_MIN + 1)) + 1\n              : (unsigned LONG int) STRTOL_LONG_MAX))\n    overflow = 1;\n#endif\n\n  if (overflow)\n    {\n      __set_errno (ERANGE);\n#if UNSIGNED\n      return STRTOL_ULONG_MAX;\n#else\n      return negative ? STRTOL_LONG_MIN : STRTOL_LONG_MAX;\n#endif\n    }\n\n  /* Return the result of the appropriate sign.  */\n  return negative ? -i : i;\n\nnoconv:\n  /* We must handle a special case here: the base is 0 or 16 and the\n     first two characters are '0' and 'x', but the rest are no\n     hexadecimal digits.  This is no error case.  We return 0 and\n     ENDPTR points to the 'x'.  */\n  if (endptr != NULL)\n    {\n      if (save - nptr >= 2 && TOUPPER (save[-1]) == L_('X')\n          && save[-2] == L_('0'))\n        *endptr = (STRING_TYPE *) &save[-1];\n      else\n        /*  There was no number to convert.  */\n        *endptr = (STRING_TYPE *) nptr;\n    }\n\n  return 0L;\n}",
      "lines": 184,
      "depth": 20,
      "decorators": [
        "INT"
      ]
    },
    "strtol": {
      "start_point": [
        415,
        0
      ],
      "end_point": [
        421,
        1
      ],
      "content": "weak_function\n#endif\nstrtol (const STRING_TYPE *nptr, STRING_TYPE **endptr,\n        int base LOCALE_PARAM_PROTO)\n{\n  return INTERNAL (strtol) (nptr, endptr, base, 0 LOCALE_PARAM);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "weak_function",
        "#endif",
        "#endif"
      ]
    }
  },
  "datamash/datamash-1.3/lib/strtoul.c": {},
  "datamash/datamash-1.3/lib/strtoull.c": {},
  "datamash/datamash-1.3/lib/strtoumax.c": {},
  "datamash/datamash-1.3/lib/sys_types.in.h": {},
  "datamash/datamash-1.3/lib/trim.c": {
    "trim2": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        128,
        1
      ],
      "content": "char *\ntrim2 (const char *s, int how)\n{\n  char *d;\n\n  d = strdup (s);\n\n  if (!d)\n    xalloc_die ();\n\n  if (MB_CUR_MAX > 1)\n    {\n      mbi_iterator_t i;\n\n      /* Trim leading whitespaces. */\n      if (how != TRIM_TRAILING)\n        {\n          mbi_init (i, d, strlen (d));\n\n          for (; mbi_avail (i) && mb_isspace (mbi_cur (i)); mbi_advance (i))\n            ;\n\n          memmove (d, mbi_cur_ptr (i), strlen (mbi_cur_ptr (i)) + 1);\n        }\n\n      /* Trim trailing whitespaces. */\n      if (how != TRIM_LEADING)\n        {\n          unsigned int state = 0;\n          char *r IF_LINT (= NULL); /* used only while state = 2 */\n\n          mbi_init (i, d, strlen (d));\n\n          for (; mbi_avail (i); mbi_advance (i))\n            {\n              if (state == 0 && mb_isspace (mbi_cur (i)))\n                continue;\n\n              if (state == 0 && !mb_isspace (mbi_cur (i)))\n                {\n                  state = 1;\n                  continue;\n                }\n\n              if (state == 1 && !mb_isspace (mbi_cur (i)))\n                continue;\n\n              if (state == 1 && mb_isspace (mbi_cur (i)))\n                {\n                  state = 2;\n                  r = (char *) mbi_cur_ptr (i);\n                }\n              else if (state == 2 && mb_isspace (mbi_cur (i)))\n                {\n                  /* empty */\n                }\n              else\n                {\n                  state = 1;\n                }\n            }\n\n          if (state == 2)\n            *r = '\\0';\n        }\n    }\n  else\n    {\n      char *p;\n\n      /* Trim leading whitespaces. */\n      if (how != TRIM_TRAILING)\n        {\n          for (p = d; *p && isspace ((unsigned char) *p); p++)\n            ;\n\n          memmove (d, p, strlen (p) + 1);\n        }\n\n      /* Trim trailing whitespaces. */\n      if (how != TRIM_LEADING)\n        {\n          for (p = d + strlen (d) - 1;\n               p >= d && isspace ((unsigned char) *p); p--)\n            *p = '\\0';\n        }\n    }\n\n  return d;\n}",
      "lines": 90,
      "depth": 17,
      "decorators": [
        "char",
        "*\ntrim2 (const char *s, int how)",
        "*"
      ]
    }
  },
  "datamash/datamash-1.3/lib/trim.h": {},
  "datamash/datamash-1.3/lib/trunc.c": {
    "FUNC": {
      "start_point": [
        73,
        0
      ],
      "end_point": [
        120,
        1
      ],
      "content": "DOUBLE\nFUNC (DOUBLE x)\n{\n  /* The use of 'volatile' guarantees that excess precision bits are dropped\n     at each addition step and before the following comparison at the caller's\n     site.  It is necessary on x86 systems where double-floats are not IEEE\n     compliant by default, to avoid that the results become platform and compiler\n     option dependent.  'volatile' is a portable alternative to gcc's\n     -ffloat-store option.  */\n  volatile DOUBLE y = x;\n  volatile DOUBLE z = y;\n\n  if (z > L_(0.0))\n    {\n      /* For 0 < x < 1, return +0.0 even if the current rounding mode is\n         FE_DOWNWARD.  */\n      if (z < L_(1.0))\n        z = L_(0.0);\n      /* Avoid rounding errors for values near 2^k, where k >= MANT_DIG-1.  */\n      else if (z < TWO_MANT_DIG)\n        {\n          /* Round to the next integer (nearest or up or down, doesn't matter).  */\n          z += TWO_MANT_DIG;\n          z -= TWO_MANT_DIG;\n          /* Enforce rounding down.  */\n          if (z > y)\n            z -= L_(1.0);\n        }\n    }\n  else if (z < L_(0.0))\n    {\n      /* For -1 < x < 0, return -0.0 regardless of the current rounding\n         mode.  */\n      if (z > L_(-1.0))\n        z = MINUS_ZERO;\n      /* Avoid rounding errors for values near -2^k, where k >= MANT_DIG-1.  */\n      else if (z > - TWO_MANT_DIG)\n        {\n          /* Round to the next integer (nearest or up or down, doesn't matter).  */\n          z -= TWO_MANT_DIG;\n          z += TWO_MANT_DIG;\n          /* Enforce rounding up.  */\n          if (z < y)\n            z += L_(1.0);\n        }\n    }\n  return z;\n}",
      "lines": 48,
      "depth": 14,
      "decorators": [
        "DOUBLE"
      ]
    }
  },
  "datamash/datamash-1.3/lib/truncl.c": {
    "truncl": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        29,
        1
      ],
      "content": "long double\ntruncl (long double x)\n{\n  return trunc (x);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "long double",
        "long",
        "double"
      ]
    }
  },
  "datamash/datamash-1.3/lib/u64.c": {},
  "datamash/datamash-1.3/lib/u64.h": {
    "u64hilo": {
      "start_point": [
        64,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "_GL_U64_INLINE u64\nu64hilo (uint32_t hi, uint32_t lo)\n{\n  u64 r;\n  r.hi = hi;\n  r.lo = lo;\n  return r;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "_GL_U64_INLINE",
        "u64",
        "u64"
      ]
    },
    "u64lo": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        81,
        1
      ],
      "content": "_GL_U64_INLINE u64\nu64lo (uint32_t lo)\n{\n  u64 r;\n  r.hi = 0;\n  r.lo = lo;\n  return r;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "_GL_U64_INLINE",
        "u64",
        "u64"
      ]
    },
    "u64size": {
      "start_point": [
        84,
        0
      ],
      "end_point": [
        91,
        1
      ],
      "content": "_GL_U64_INLINE u64\nu64size (size_t size)\n{\n  u64 r;\n  r.hi = size >> 31 >> 1;\n  r.lo = size;\n  return r;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "_GL_U64_INLINE",
        "u64",
        "u64"
      ]
    },
    "u64lt": {
      "start_point": [
        94,
        0
      ],
      "end_point": [
        98,
        1
      ],
      "content": "_GL_U64_INLINE int\nu64lt (u64 x, u64 y)\n{\n  return x.hi < y.hi || (x.hi == y.hi && x.lo < y.lo);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "_GL_U64_INLINE",
        "int",
        "int"
      ]
    },
    "u64and": {
      "start_point": [
        101,
        0
      ],
      "end_point": [
        108,
        1
      ],
      "content": "_GL_U64_INLINE u64\nu64and (u64 x, u64 y)\n{\n  u64 r;\n  r.hi = x.hi & y.hi;\n  r.lo = x.lo & y.lo;\n  return r;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "_GL_U64_INLINE",
        "u64",
        "u64"
      ]
    },
    "u64or": {
      "start_point": [
        111,
        0
      ],
      "end_point": [
        118,
        1
      ],
      "content": "_GL_U64_INLINE u64\nu64or (u64 x, u64 y)\n{\n  u64 r;\n  r.hi = x.hi | y.hi;\n  r.lo = x.lo | y.lo;\n  return r;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "_GL_U64_INLINE",
        "u64",
        "u64"
      ]
    },
    "u64xor": {
      "start_point": [
        121,
        0
      ],
      "end_point": [
        128,
        1
      ],
      "content": "_GL_U64_INLINE u64\nu64xor (u64 x, u64 y)\n{\n  u64 r;\n  r.hi = x.hi ^ y.hi;\n  r.lo = x.lo ^ y.lo;\n  return r;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "_GL_U64_INLINE",
        "u64",
        "u64"
      ]
    },
    "u64plus": {
      "start_point": [
        131,
        0
      ],
      "end_point": [
        138,
        1
      ],
      "content": "_GL_U64_INLINE u64\nu64plus (u64 x, u64 y)\n{\n  u64 r;\n  r.lo = x.lo + y.lo;\n  r.hi = x.hi + y.hi + (r.lo < x.lo);\n  return r;\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "_GL_U64_INLINE",
        "u64",
        "u64"
      ]
    },
    "u64shl": {
      "start_point": [
        141,
        0
      ],
      "end_point": [
        156,
        1
      ],
      "content": "_GL_U64_INLINE u64\nu64shl (u64 x, int n)\n{\n  u64 r;\n  if (n < 32)\n    {\n      r.hi = (x.hi << n) | (x.lo >> (32 - n));\n      r.lo = x.lo << n;\n    }\n  else\n    {\n      r.hi = x.lo << (n - 32);\n      r.lo = 0;\n    }\n  return r;\n}",
      "lines": 16,
      "depth": 12,
      "decorators": [
        "_GL_U64_INLINE",
        "u64",
        "u64"
      ]
    },
    "u64shr": {
      "start_point": [
        159,
        0
      ],
      "end_point": [
        174,
        1
      ],
      "content": "_GL_U64_INLINE u64\nu64shr (u64 x, int n)\n{\n  u64 r;\n  if (n < 32)\n    {\n      r.hi = x.hi >> n;\n      r.lo = (x.hi << (32 - n)) | (x.lo >> n);\n    }\n  else\n    {\n      r.hi = 0;\n      r.lo = x.hi >> (n - 32);\n    }\n  return r;\n}",
      "lines": 16,
      "depth": 12,
      "decorators": [
        "_GL_U64_INLINE",
        "u64",
        "u64"
      ]
    }
  },
  "datamash/datamash-1.3/lib/uinttostr.c": {},
  "datamash/datamash-1.3/lib/umaxtostr.c": {},
  "datamash/datamash-1.3/lib/unistd.c": {},
  "datamash/datamash-1.3/lib/unistd.in.h": {
    "rpl_environ": {
      "start_point": [
        426,
        0
      ],
      "end_point": [
        430,
        1
      ],
      "content": "_GL_UNISTD_INLINE char ***\nrpl_environ (void)\n{\n  return &environ;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "_GL_UNISTD_INLINE",
        "char",
        "char",
        "***\nrpl_environ (void)",
        "*",
        "**\nrpl_environ (void)",
        "*",
        "*\nrpl_environ (void)",
        "*"
      ]
    },
    "getpagesize": {
      "start_point": [
        905,
        0
      ],
      "end_point": [
        909,
        1
      ],
      "content": "_GL_UNISTD_INLINE int\ngetpagesize ()\n{\n  return _gl_getpagesize ();\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "_GL_UNISTD_INLINE",
        "int",
        "int"
      ]
    }
  },
  "datamash/datamash-1.3/lib/unistr.in.h": {
    "u8_mbtouc_unsafe": {
      "start_point": [
        149,
        0
      ],
      "end_point": [
        161,
        1
      ],
      "content": "static inline int\nu8_mbtouc_unsafe (ucs4_t *puc, const uint8_t *s, size_t n)\n{\n  uint8_t c = *s;\n\n  if (c < 0x80)\n    {\n      *puc = c;\n      return 1;\n    }\n  else\n    return u8_mbtouc_unsafe_aux (puc, s, n);\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "u16_mbtouc_unsafe": {
      "start_point": [
        172,
        0
      ],
      "end_point": [
        184,
        1
      ],
      "content": "static inline int\nu16_mbtouc_unsafe (ucs4_t *puc, const uint16_t *s, size_t n)\n{\n  uint16_t c = *s;\n\n  if (c < 0xd800 || c >= 0xe000)\n    {\n      *puc = c;\n      return 1;\n    }\n  else\n    return u16_mbtouc_unsafe_aux (puc, s, n);\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "u32_mbtouc_unsafe": {
      "start_point": [
        193,
        0
      ],
      "end_point": [
        205,
        1
      ],
      "content": "static inline int\nu32_mbtouc_unsafe (ucs4_t *puc,\n                   const uint32_t *s, size_t n _GL_UNUSED_PARAMETER)\n{\n  uint32_t c = *s;\n\n  if (c < 0xd800 || (c >= 0xe000 && c < 0x110000))\n    *puc = c;\n  else\n    /* invalid multibyte character */\n    *puc = 0xfffd;\n  return 1;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "u8_mbtouc": {
      "start_point": [
        216,
        0
      ],
      "end_point": [
        228,
        1
      ],
      "content": "static inline int\nu8_mbtouc (ucs4_t *puc, const uint8_t *s, size_t n)\n{\n  uint8_t c = *s;\n\n  if (c < 0x80)\n    {\n      *puc = c;\n      return 1;\n    }\n  else\n    return u8_mbtouc_aux (puc, s, n);\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "u16_mbtouc": {
      "start_point": [
        239,
        0
      ],
      "end_point": [
        251,
        1
      ],
      "content": "static inline int\nu16_mbtouc (ucs4_t *puc, const uint16_t *s, size_t n)\n{\n  uint16_t c = *s;\n\n  if (c < 0xd800 || c >= 0xe000)\n    {\n      *puc = c;\n      return 1;\n    }\n  else\n    return u16_mbtouc_aux (puc, s, n);\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "u32_mbtouc": {
      "start_point": [
        260,
        0
      ],
      "end_point": [
        271,
        1
      ],
      "content": "static inline int\nu32_mbtouc (ucs4_t *puc, const uint32_t *s, size_t n _GL_UNUSED_PARAMETER)\n{\n  uint32_t c = *s;\n\n  if (c < 0xd800 || (c >= 0xe000 && c < 0x110000))\n    *puc = c;\n  else\n    /* invalid multibyte character */\n    *puc = 0xfffd;\n  return 1;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "u8_uctomb": {
      "start_point": [
        312,
        0
      ],
      "end_point": [
        322,
        1
      ],
      "content": "static inline int\nu8_uctomb (uint8_t *s, ucs4_t uc, int n)\n{\n  if (uc < 0x80 && n > 0)\n    {\n      s[0] = uc;\n      return 1;\n    }\n  else\n    return u8_uctomb_aux (s, uc, n);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "u16_uctomb": {
      "start_point": [
        334,
        0
      ],
      "end_point": [
        344,
        1
      ],
      "content": "static inline int\nu16_uctomb (uint16_t *s, ucs4_t uc, int n)\n{\n  if (uc < 0xd800 && n > 0)\n    {\n      s[0] = uc;\n      return 1;\n    }\n  else\n    return u16_uctomb_aux (s, uc, n);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "u32_uctomb": {
      "start_point": [
        353,
        0
      ],
      "end_point": [
        368,
        1
      ],
      "content": "static inline int\nu32_uctomb (uint32_t *s, ucs4_t uc, int n)\n{\n  if (uc < 0xd800 || (uc >= 0xe000 && uc < 0x110000))\n    {\n      if (n > 0)\n        {\n          *s = uc;\n          return 1;\n        }\n      else\n        return -2;\n    }\n  else\n    return -1;\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    }
  },
  "datamash/datamash-1.3/lib/unitypes.in.h": {},
  "datamash/datamash-1.3/lib/uniwidth.in.h": {},
  "datamash/datamash-1.3/lib/unlocked-io.h": {},
  "datamash/datamash-1.3/lib/unused-parameter.h": {},
  "datamash/datamash-1.3/lib/verify.h": {},
  "datamash/datamash-1.3/lib/version-etc.c": {
    "version_etc_arn": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        172,
        1
      ],
      "content": "void\nversion_etc_arn (FILE *stream,\n                 const char *command_name, const char *package,\n                 const char *version,\n                 const char * const * authors, size_t n_authors)\n{\n  if (command_name)\n    fprintf (stream, \"%s (%s) %s\\n\", command_name, package, version);\n  else\n    fprintf (stream, \"%s %s\\n\", package, version);\n\n#ifdef PACKAGE_PACKAGER\n# ifdef PACKAGE_PACKAGER_VERSION\n  fprintf (stream, _(\"Packaged by %s (%s)\\n\"), PACKAGE_PACKAGER,\n           PACKAGE_PACKAGER_VERSION);\n# else\n  fprintf (stream, _(\"Packaged by %s\\n\"), PACKAGE_PACKAGER);\n# endif\n#endif\n\n  /* TRANSLATORS: Translate \"(C)\" to the copyright symbol\n     (C-in-a-circle), if this symbol is available in the user's\n     locale.  Otherwise, do not translate \"(C)\"; leave it as-is.  */\n  fprintf (stream, version_etc_copyright, _(\"(C)\"), COPYRIGHT_YEAR);\n\n  fputs (_(\"\\\n\\n\\\nLicense GPLv3+: GNU GPL version 3 or later <https://gnu.org/licenses/gpl.html>.\\n\\\nThis is free software: you are free to change and redistribute it.\\n\\\nThere is NO WARRANTY, to the extent permitted by law.\\n\\\n\\n\\\n\"),\n         stream);\n\n  switch (n_authors)\n    {\n    case 0:\n      /* The caller must provide at least one author name.  */\n      abort ();\n    case 1:\n      /* TRANSLATORS: %s denotes an author name.  */\n      fprintf (stream, _(\"Written by %s.\\n\"), authors[0]);\n      break;\n    case 2:\n      /* TRANSLATORS: Each %s denotes an author name.  */\n      fprintf (stream, _(\"Written by %s and %s.\\n\"), authors[0], authors[1]);\n      break;\n    case 3:\n      /* TRANSLATORS: Each %s denotes an author name.  */\n      fprintf (stream, _(\"Written by %s, %s, and %s.\\n\"),\n               authors[0], authors[1], authors[2]);\n      break;\n    case 4:\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"Written by %s, %s, %s,\\nand %s.\\n\"),\n               authors[0], authors[1], authors[2], authors[3]);\n      break;\n    case 5:\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"Written by %s, %s, %s,\\n%s, and %s.\\n\"),\n               authors[0], authors[1], authors[2], authors[3], authors[4]);\n      break;\n    case 6:\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"Written by %s, %s, %s,\\n%s, %s, and %s.\\n\"),\n               authors[0], authors[1], authors[2], authors[3], authors[4],\n               authors[5]);\n      break;\n    case 7:\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"Written by %s, %s, %s,\\n%s, %s, %s, and %s.\\n\"),\n               authors[0], authors[1], authors[2], authors[3], authors[4],\n               authors[5], authors[6]);\n      break;\n    case 8:\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"\\\nWritten by %s, %s, %s,\\n%s, %s, %s, %s,\\nand %s.\\n\"),\n                authors[0], authors[1], authors[2], authors[3], authors[4],\n                authors[5], authors[6], authors[7]);\n      break;\n    case 9:\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"\\\nWritten by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, and %s.\\n\"),\n               authors[0], authors[1], authors[2], authors[3], authors[4],\n               authors[5], authors[6], authors[7], authors[8]);\n      break;\n    default:\n      /* 10 or more authors.  Use an abbreviation, since the human reader\n         will probably not want to read the entire list anyway.  */\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"\\\nWritten by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, %s, and others.\\n\"),\n                authors[0], authors[1], authors[2], authors[3], authors[4],\n                authors[5], authors[6], authors[7], authors[8]);\n      break;\n    }\n}",
      "lines": 113,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "version_etc_ar": {
      "start_point": [
        178,
        0
      ],
      "end_point": [
        188,
        1
      ],
      "content": "void\nversion_etc_ar (FILE *stream,\n                const char *command_name, const char *package,\n                const char *version, const char * const * authors)\n{\n  size_t n_authors;\n\n  for (n_authors = 0; authors[n_authors]; n_authors++)\n    ;\n  version_etc_arn (stream, command_name, package, version, authors, n_authors);\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "version_etc_va": {
      "start_point": [
        194,
        0
      ],
      "end_point": [
        209,
        1
      ],
      "content": "void\nversion_etc_va (FILE *stream,\n                const char *command_name, const char *package,\n                const char *version, va_list authors)\n{\n  size_t n_authors;\n  const char *authtab[10];\n\n  for (n_authors = 0;\n       n_authors < 10\n         && (authtab[n_authors] = va_arg (authors, const char *)) != NULL;\n       n_authors++)\n    ;\n  version_etc_arn (stream, command_name, package, version,\n                   authtab, n_authors);\n}",
      "lines": 16,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "version_etc": {
      "start_point": [
        225,
        0
      ],
      "end_point": [
        235,
        1
      ],
      "content": "void\nversion_etc (FILE *stream,\n             const char *command_name, const char *package,\n             const char *version, /* const char *author1, ...*/ ...)\n{\n  va_list authors;\n\n  va_start (authors, version);\n  version_etc_va (stream, command_name, package, version, authors);\n  va_end (authors);\n}",
      "lines": 11,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "emit_bug_reporting_address": {
      "start_point": [
        237,
        0
      ],
      "end_point": [
        257,
        1
      ],
      "content": "void\nemit_bug_reporting_address (void)\n{\n  /* TRANSLATORS: The placeholder indicates the bug-reporting address\n     for this package.  Please add _another line_ saying\n     \"Report translation bugs to <...>\\n\" with the address for translation\n     bugs (typically your translation team's web or email address).  */\n  printf (_(\"\\nReport bugs to: %s\\n\"), PACKAGE_BUGREPORT);\n#ifdef PACKAGE_PACKAGER_BUG_REPORTS\n  printf (_(\"Report %s bugs to: %s\\n\"), PACKAGE_PACKAGER,\n          PACKAGE_PACKAGER_BUG_REPORTS);\n#endif\n#ifdef PACKAGE_URL\n  printf (_(\"%s home page: <%s>\\n\"), PACKAGE_NAME, PACKAGE_URL);\n#else\n  printf (_(\"%s home page: <https://www.gnu.org/software/%s/>\\n\"),\n          PACKAGE_NAME, PACKAGE);\n#endif\n  fputs (_(\"General help using GNU software: <https://www.gnu.org/gethelp/>\\n\"),\n         stdout);\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "datamash/datamash-1.3/lib/version-etc.h": {},
  "datamash/datamash-1.3/lib/warn-on-use.h": {},
  "datamash/datamash-1.3/lib/wchar.in.h": {},
  "datamash/datamash-1.3/lib/wctype-h.c": {},
  "datamash/datamash-1.3/lib/wctype.in.h": {
    "rpl_towlower": {
      "start_point": [
        371,
        0
      ],
      "end_point": [
        375,
        1
      ],
      "content": "_GL_WCTYPE_INLINE wint_t\nrpl_towlower (wint_t wc)\n{\n  return (wint_t) (wchar_t) towlower (wc);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "_GL_WCTYPE_INLINE",
        "wint_t",
        "wint_t"
      ]
    },
    "rpl_towupper": {
      "start_point": [
        380,
        0
      ],
      "end_point": [
        384,
        1
      ],
      "content": "_GL_WCTYPE_INLINE wint_t\nrpl_towupper (wint_t wc)\n{\n  return (wint_t) (wchar_t) towupper (wc);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "_GL_WCTYPE_INLINE",
        "wint_t",
        "wint_t"
      ]
    }
  },
  "datamash/datamash-1.3/lib/wcwidth.c": {},
  "datamash/datamash-1.3/lib/xalloc-die.c": {
    "xalloc_die": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "void\nxalloc_die (void)\n{\n  error (exit_failure, 0, \"%s\", _(\"memory exhausted\"));\n\n  /* _Noreturn cannot be given to error, since it may return if\n     its first argument is 0.  To help compilers understand the\n     xalloc_die does not return, call abort.  Also, the abort is a\n     safety feature if exit_failure is 0 (which shouldn't happen).  */\n  abort ();\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "datamash/datamash-1.3/lib/xalloc-oversized.h": {},
  "datamash/datamash-1.3/lib/xalloc.h": {
    "xnmalloc": {
      "start_point": [
        103,
        0
      ],
      "end_point": [
        109,
        1
      ],
      "content": "XALLOC_INLINE void *\nxnmalloc (size_t n, size_t s)\n{\n  if (xalloc_oversized (n, s))\n    xalloc_die ();\n  return xmalloc (n * s);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "XALLOC_INLINE",
        "void",
        "void",
        "*\nxnmalloc (size_t n, size_t s)",
        "*"
      ]
    },
    "xnrealloc": [
      {
        "start_point": [
          116,
          0
        ],
        "end_point": [
          122,
          1
        ],
        "content": "XALLOC_INLINE void *\nxnrealloc (void *p, size_t n, size_t s)\n{\n  if (xalloc_oversized (n, s))\n    xalloc_die ();\n  return xrealloc (p, n * s);\n}",
        "lines": 7,
        "depth": 7,
        "decorators": [
          "XALLOC_INLINE",
          "void",
          "void",
          "*\nxnrealloc (void *p, size_t n, size_t s)",
          "*"
        ]
      },
      {
        "start_point": [
          239,
          29
        ],
        "end_point": [
          243,
          1
        ],
        "content": "T *\nxnrealloc (T *p, size_t n, size_t s)\n{\n  return (T *) xnrealloc ((void *) p, n, s);\n}",
        "lines": 5,
        "depth": 10,
        "decorators": [
          "T",
          "*\nxnrealloc (T *p, size_t n, size_t s)",
          "*"
        ]
      }
    ],
    "x2nrealloc": [
      {
        "start_point": [
          178,
          0
        ],
        "end_point": [
          213,
          1
        ],
        "content": "XALLOC_INLINE void *\nx2nrealloc (void *p, size_t *pn, size_t s)\n{\n  size_t n = *pn;\n\n  if (! p)\n    {\n      if (! n)\n        {\n          /* The approximate size to use for initial small allocation\n             requests, when the invoking code specifies an old size of\n             zero.  This is the largest \"small\" request for the GNU C\n             library malloc.  */\n          enum { DEFAULT_MXFAST = 64 * sizeof (size_t) / 4 };\n\n          n = DEFAULT_MXFAST / s;\n          n += !n;\n        }\n      if (xalloc_oversized (n, s))\n        xalloc_die ();\n    }\n  else\n    {\n      /* Set N = floor (1.5 * N) + 1 so that progress is made even if N == 0.\n         Check for overflow, so that N * S stays in both ptrdiff_t and\n         size_t range.  The check may be slightly conservative, but an\n         exact check isn't worth the trouble.  */\n      if ((PTRDIFF_MAX < SIZE_MAX ? PTRDIFF_MAX : SIZE_MAX) / 3 * 2 / s\n          <= n)\n        xalloc_die ();\n      n += n / 2 + 1;\n    }\n\n  *pn = n;\n  return xrealloc (p, n * s);\n}",
        "lines": 36,
        "depth": 14,
        "decorators": [
          "XALLOC_INLINE",
          "void",
          "void",
          "*\nx2nrealloc (void *p, size_t *pn, size_t s)",
          "*"
        ]
      },
      {
        "start_point": [
          251,
          29
        ],
        "end_point": [
          255,
          1
        ],
        "content": "T *\nx2nrealloc (T *p, size_t *pn, size_t s)\n{\n  return (T *) x2nrealloc ((void *) p, pn, s);\n}",
        "lines": 5,
        "depth": 10,
        "decorators": [
          "T",
          "*\nx2nrealloc (T *p, size_t *pn, size_t s)",
          "*"
        ]
      }
    ],
    "xcharalloc": {
      "start_point": [
        220,
        0
      ],
      "end_point": [
        224,
        1
      ],
      "content": "XALLOC_INLINE char *\nxcharalloc (size_t n)\n{\n  return XNMALLOC (n, char);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "XALLOC_INLINE",
        "char",
        "char",
        "*\nxcharalloc (size_t n)",
        "*"
      ]
    },
    "xrealloc": {
      "start_point": [
        233,
        29
      ],
      "end_point": [
        237,
        1
      ],
      "content": "T *\nxrealloc (T *p, size_t s)\n{\n  return (T *) xrealloc ((void *) p, s);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "T",
        "*\nxrealloc (T *p, size_t s)",
        "*"
      ]
    },
    "x2realloc": {
      "start_point": [
        245,
        29
      ],
      "end_point": [
        249,
        1
      ],
      "content": "T *\nx2realloc (T *p, size_t *pn)\n{\n  return (T *) x2realloc ((void *) p, pn);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "T",
        "*\nx2realloc (T *p, size_t *pn)",
        "*"
      ]
    },
    "xmemdup": {
      "start_point": [
        257,
        29
      ],
      "end_point": [
        261,
        1
      ],
      "content": "T *\nxmemdup (T const *p, size_t s)\n{\n  return (T *) xmemdup ((void const *) p, s);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "T",
        "*\nxmemdup (T const *p, size_t s)",
        "*"
      ]
    }
  },
  "datamash/datamash-1.3/lib/xmalloc.c": {
    "xmalloc": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "void *\nxmalloc (size_t n)\n{\n  void *p = malloc (n);\n  if (!p && n != 0)\n    xalloc_die ();\n  return p;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void",
        "*\nxmalloc (size_t n)",
        "*"
      ]
    },
    "xrealloc": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "void *\nxrealloc (void *p, size_t n)\n{\n  if (!n && p)\n    {\n      /* The GNU and C99 realloc behaviors disagree here.  Act like\n         GNU, even if the underlying realloc is C99.  */\n      free (p);\n      return NULL;\n    }\n\n  p = realloc (p, n);\n  if (!p && n)\n    xalloc_die ();\n  return p;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "void",
        "*\nxrealloc (void *p, size_t n)",
        "*"
      ]
    },
    "x2realloc": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "void *\nx2realloc (void *p, size_t *pn)\n{\n  return x2nrealloc (p, pn, 1);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void",
        "*\nx2realloc (void *p, size_t *pn)",
        "*"
      ]
    },
    "xzalloc": {
      "start_point": [
        82,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "void *\nxzalloc (size_t s)\n{\n  return memset (xmalloc (s), 0, s);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void",
        "*\nxzalloc (size_t s)",
        "*"
      ]
    },
    "xcalloc": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "void *\nxcalloc (size_t n, size_t s)\n{\n  void *p;\n  /* Test for overflow, since objects with size greater than\n     PTRDIFF_MAX cause pointer subtraction to go awry.  Omit size-zero\n     tests if HAVE_GNU_CALLOC, since GNU calloc never returns NULL if\n     successful.  */\n  if (xalloc_oversized (n, s)\n      || (! (p = calloc (n, s)) && (HAVE_GNU_CALLOC || n != 0)))\n    xalloc_die ();\n  return p;\n}",
      "lines": 13,
      "depth": 13,
      "decorators": [
        "void",
        "*\nxcalloc (size_t n, size_t s)",
        "*"
      ]
    },
    "xmemdup": {
      "start_point": [
        109,
        0
      ],
      "end_point": [
        113,
        1
      ],
      "content": "void *\nxmemdup (void const *p, size_t s)\n{\n  return memcpy (xmalloc (s), p, s);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void",
        "*\nxmemdup (void const *p, size_t s)",
        "*"
      ]
    },
    "xstrdup": {
      "start_point": [
        117,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "char *\nxstrdup (char const *string)\n{\n  return xmemdup (string, strlen (string) + 1);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "char",
        "*\nxstrdup (char const *string)",
        "*"
      ]
    }
  },
  "datamash/datamash-1.3/lib/xstriconv.c": {
    "xmem_cd_iconv": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        39,
        1
      ],
      "content": "int\nxmem_cd_iconv (const char *src, size_t srclen, iconv_t cd,\n               char **resultp, size_t *lengthp)\n{\n  int retval = mem_cd_iconv (src, srclen, cd, resultp, lengthp);\n\n  if (retval < 0 && errno == ENOMEM)\n    xalloc_die ();\n  return retval;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "xstr_cd_iconv": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "char *\nxstr_cd_iconv (const char *src, iconv_t cd)\n{\n  char *result = str_cd_iconv (src, cd);\n\n  if (result == NULL && errno == ENOMEM)\n    xalloc_die ();\n  return result;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "char",
        "*\nxstr_cd_iconv (const char *src, iconv_t cd)",
        "*"
      ]
    },
    "xstr_iconv": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "char *\nxstr_iconv (const char *src, const char *from_codeset, const char *to_codeset)\n{\n  char *result = str_iconv (src, from_codeset, to_codeset);\n\n  if (result == NULL && errno == ENOMEM)\n    xalloc_die ();\n  return result;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "char",
        "*\nxstr_iconv (const char *src, const char *from_codeset, const char *to_codeset)",
        "*"
      ]
    }
  },
  "datamash/datamash-1.3/lib/xstriconv.h": {},
  "datamash/datamash-1.3/lib/xstrndup.c": {
    "xstrndup": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        35,
        1
      ],
      "content": "char *\nxstrndup (const char *string, size_t n)\n{\n  char *s = strndup (string, n);\n  if (! s)\n    xalloc_die ();\n  return s;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "char",
        "*\nxstrndup (const char *string, size_t n)",
        "*"
      ]
    }
  },
  "datamash/datamash-1.3/lib/xstrndup.h": {},
  "datamash/datamash-1.3/lib/xstrtol-error.c": {
    "xstrtol_error": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "static void\nxstrtol_error (enum strtol_error err,\n               int opt_idx, char c, struct option const *long_options,\n               char const *arg,\n               int exit_status)\n{\n  char const *hyphens = \"--\";\n  char const *msgid;\n  char const *option;\n  char option_buffer[2];\n\n  switch (err)\n    {\n    default:\n      abort ();\n\n    case LONGINT_INVALID:\n      msgid = N_(\"invalid %s%s argument '%s'\");\n      break;\n\n    case LONGINT_INVALID_SUFFIX_CHAR:\n    case LONGINT_INVALID_SUFFIX_CHAR_WITH_OVERFLOW:\n      msgid = N_(\"invalid suffix in %s%s argument '%s'\");\n      break;\n\n    case LONGINT_OVERFLOW:\n      msgid = N_(\"%s%s argument '%s' too large\");\n      break;\n    }\n\n  if (opt_idx < 0)\n    {\n      hyphens -= opt_idx;\n      option_buffer[0] = c;\n      option_buffer[1] = '\\0';\n      option = option_buffer;\n    }\n  else\n    option = long_options[opt_idx].name;\n\n  error (exit_status, 0, gettext (msgid), hyphens, option, arg);\n}",
      "lines": 42,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "xstrtol_fatal": {
      "start_point": [
        90,
        0
      ],
      "end_point": [
        97,
        1
      ],
      "content": "void\nxstrtol_fatal (enum strtol_error err,\n               int opt_idx, char c, struct option const *long_options,\n               char const *arg)\n{\n  xstrtol_error (err, opt_idx, c, long_options, arg, exit_failure);\n  abort ();\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "void"
      ]
    }
  },
  "datamash/datamash-1.3/lib/xstrtol.c": {
    "bkm_scale": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        73,
        1
      ],
      "content": "static strtol_error\nbkm_scale (__strtol_t *x, int scale_factor)\n{\n  if (TYPE_SIGNED (__strtol_t) && *x < STRTOL_T_MINIMUM / scale_factor)\n    {\n      *x = STRTOL_T_MINIMUM;\n      return LONGINT_OVERFLOW;\n    }\n  if (STRTOL_T_MAXIMUM / scale_factor < *x)\n    {\n      *x = STRTOL_T_MAXIMUM;\n      return LONGINT_OVERFLOW;\n    }\n  *x *= scale_factor;\n  return LONGINT_OK;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "strtol_error"
      ]
    },
    "bkm_scale_by_power": {
      "start_point": [
        75,
        0
      ],
      "end_point": [
        82,
        1
      ],
      "content": "static strtol_error\nbkm_scale_by_power (__strtol_t *x, int base, int power)\n{\n  strtol_error err = LONGINT_OK;\n  while (power--)\n    err |= bkm_scale (x, base);\n  return err;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "strtol_error"
      ]
    },
    "__xstrtol": {
      "start_point": [
        86,
        0
      ],
      "end_point": [
        248,
        1
      ],
      "content": "strtol_error\n__xstrtol (const char *s, char **ptr, int strtol_base,\n           __strtol_t *val, const char *valid_suffixes)\n{\n  char *t_ptr;\n  char **p;\n  __strtol_t tmp;\n  strtol_error err = LONGINT_OK;\n\n  assure (0 <= strtol_base && strtol_base <= 36);\n\n  p = (ptr ? ptr : &t_ptr);\n\n  errno = 0;\n\n  if (! TYPE_SIGNED (__strtol_t))\n    {\n      const char *q = s;\n      unsigned char ch = *q;\n      while (isspace (ch))\n        ch = *++q;\n      if (ch == '-')\n        return LONGINT_INVALID;\n    }\n\n  tmp = __strtol (s, p, strtol_base);\n\n  if (*p == s)\n    {\n      /* If there is no number but there is a valid suffix, assume the\n         number is 1.  The string is invalid otherwise.  */\n      if (valid_suffixes && **p && strchr (valid_suffixes, **p))\n        tmp = 1;\n      else\n        return LONGINT_INVALID;\n    }\n  else if (errno != 0)\n    {\n      if (errno != ERANGE)\n        return LONGINT_INVALID;\n      err = LONGINT_OVERFLOW;\n    }\n\n  /* Let valid_suffixes == NULL mean \"allow any suffix\".  */\n  /* FIXME: update all callers except the ones that allow suffixes\n     after the number, changing last parameter NULL to \"\".  */\n  if (!valid_suffixes)\n    {\n      *val = tmp;\n      return err;\n    }\n\n  if (**p != '\\0')\n    {\n      int base = 1024;\n      int suffixes = 1;\n      strtol_error overflow;\n\n      if (!strchr (valid_suffixes, **p))\n        {\n          *val = tmp;\n          return err | LONGINT_INVALID_SUFFIX_CHAR;\n        }\n\n      switch (**p)\n        {\n        case 'E': case 'G': case 'g': case 'k': case 'K': case 'M': case 'm':\n        case 'P': case 'T': case 't': case 'Y': case 'Z':\n\n          /* The \"valid suffix\" '0' is a special flag meaning that\n             an optional second suffix is allowed, which can change\n             the base.  A suffix \"B\" (e.g. \"100MB\") stands for a power\n             of 1000, whereas a suffix \"iB\" (e.g. \"100MiB\") stands for\n             a power of 1024.  If no suffix (e.g. \"100M\"), assume\n             power-of-1024.  */\n\n          if (strchr (valid_suffixes, '0'))\n            switch (p[0][1])\n              {\n              case 'i':\n                if (p[0][2] == 'B')\n                  suffixes += 2;\n                break;\n\n              case 'B':\n              case 'D': /* 'D' is obsolescent */\n                base = 1000;\n                suffixes++;\n                break;\n              }\n        }\n\n      switch (**p)\n        {\n        case 'b':\n          overflow = bkm_scale (&tmp, 512);\n          break;\n\n        case 'B':\n          /* This obsolescent first suffix is distinct from the 'B'\n             second suffix above.  E.g., 'tar -L 1000B' means change\n             the tape after writing 1000 KiB of data.  */\n          overflow = bkm_scale (&tmp, 1024);\n          break;\n\n        case 'c':\n          overflow = LONGINT_OK;\n          break;\n\n        case 'E': /* exa or exbi */\n          overflow = bkm_scale_by_power (&tmp, base, 6);\n          break;\n\n        case 'G': /* giga or gibi */\n        case 'g': /* 'g' is undocumented; for compatibility only */\n          overflow = bkm_scale_by_power (&tmp, base, 3);\n          break;\n\n        case 'k': /* kilo */\n        case 'K': /* kibi */\n          overflow = bkm_scale_by_power (&tmp, base, 1);\n          break;\n\n        case 'M': /* mega or mebi */\n        case 'm': /* 'm' is undocumented; for compatibility only */\n          overflow = bkm_scale_by_power (&tmp, base, 2);\n          break;\n\n        case 'P': /* peta or pebi */\n          overflow = bkm_scale_by_power (&tmp, base, 5);\n          break;\n\n        case 'T': /* tera or tebi */\n        case 't': /* 't' is undocumented; for compatibility only */\n          overflow = bkm_scale_by_power (&tmp, base, 4);\n          break;\n\n        case 'w':\n          overflow = bkm_scale (&tmp, 2);\n          break;\n\n        case 'Y': /* yotta or 2**80 */\n          overflow = bkm_scale_by_power (&tmp, base, 8);\n          break;\n\n        case 'Z': /* zetta or 2**70 */\n          overflow = bkm_scale_by_power (&tmp, base, 7);\n          break;\n\n        default:\n          *val = tmp;\n          return err | LONGINT_INVALID_SUFFIX_CHAR;\n        }\n\n      err |= overflow;\n      *p += suffixes;\n      if (**p)\n        err |= LONGINT_INVALID_SUFFIX_CHAR;\n    }\n\n  *val = tmp;\n  return err;\n}",
      "lines": 163,
      "depth": 17,
      "decorators": [
        "strtol_error"
      ]
    }
  },
  "datamash/datamash-1.3/lib/xstrtol.h": {},
  "datamash/datamash-1.3/lib/xstrtoul.c": {},
  "datamash/datamash-1.3/lib/xstrtoumax.c": {},
  "datamash/datamash-1.3/lib/_Noreturn.h": {},
  "datamash/datamash-1.3/lib/unistr/u8-mbtoucr.c": {
    "u8_mbtoucr": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        141,
        1
      ],
      "content": "int\nu8_mbtoucr (ucs4_t *puc, const uint8_t *s, size_t n)\n{\n  uint8_t c = *s;\n\n  if (c < 0x80)\n    {\n      *puc = c;\n      return 1;\n    }\n  else if (c >= 0xc2)\n    {\n      if (c < 0xe0)\n        {\n          if (n >= 2)\n            {\n              if ((s[1] ^ 0x80) < 0x40)\n                {\n                  *puc = ((unsigned int) (c & 0x1f) << 6)\n                         | (unsigned int) (s[1] ^ 0x80);\n                  return 2;\n                }\n              /* invalid multibyte character */\n            }\n          else\n            {\n              /* incomplete multibyte character */\n              *puc = 0xfffd;\n              return -2;\n            }\n        }\n      else if (c < 0xf0)\n        {\n          if (n >= 2)\n            {\n              if ((s[1] ^ 0x80) < 0x40\n                  && (c >= 0xe1 || s[1] >= 0xa0)\n                  && (c != 0xed || s[1] < 0xa0))\n                {\n                  if (n >= 3)\n                    {\n                      if ((s[2] ^ 0x80) < 0x40)\n                        {\n                          *puc = ((unsigned int) (c & 0x0f) << 12)\n                                 | ((unsigned int) (s[1] ^ 0x80) << 6)\n                                 | (unsigned int) (s[2] ^ 0x80);\n                          return 3;\n                        }\n                      /* invalid multibyte character */\n                    }\n                  else\n                    {\n                      /* incomplete multibyte character */\n                      *puc = 0xfffd;\n                      return -2;\n                    }\n                }\n              /* invalid multibyte character */\n            }\n          else\n            {\n              /* incomplete multibyte character */\n              *puc = 0xfffd;\n              return -2;\n            }\n        }\n      else if (c < 0xf8)\n        {\n          if (n >= 2)\n            {\n              if ((s[1] ^ 0x80) < 0x40\n                  && (c >= 0xf1 || s[1] >= 0x90)\n                  && (c < 0xf4 || (c == 0xf4 && s[1] < 0x90)))\n                {\n                  if (n >= 3)\n                    {\n                      if ((s[2] ^ 0x80) < 0x40)\n                        {\n                          if (n >= 4)\n                            {\n                              if ((s[3] ^ 0x80) < 0x40)\n                                {\n                                  *puc = ((unsigned int) (c & 0x07) << 18)\n                                         | ((unsigned int) (s[1] ^ 0x80) << 12)\n                                         | ((unsigned int) (s[2] ^ 0x80) << 6)\n                                         | (unsigned int) (s[3] ^ 0x80);\n                                  return 4;\n                                }\n                              /* invalid multibyte character */\n                            }\n                          else\n                            {\n                              /* incomplete multibyte character */\n                              *puc = 0xfffd;\n                              return -2;\n                            }\n                        }\n                      /* invalid multibyte character */\n                    }\n                  else\n                    {\n                      /* incomplete multibyte character */\n                      *puc = 0xfffd;\n                      return -2;\n                    }\n                }\n              /* invalid multibyte character */\n            }\n          else\n            {\n              /* incomplete multibyte character */\n              *puc = 0xfffd;\n              return -2;\n            }\n        }\n    }\n  /* invalid multibyte character */\n  *puc = 0xfffd;\n  return -1;\n}",
      "lines": 120,
      "depth": 33,
      "decorators": [
        "int"
      ]
    }
  },
  "datamash/datamash-1.3/lib/unistr/u8-uctomb-aux.c": {
    "u8_uctomb_aux": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        65,
        1
      ],
      "content": "int\nu8_uctomb_aux (uint8_t *s, ucs4_t uc, int n)\n{\n  int count;\n\n  if (uc < 0x80)\n    /* The case n >= 1 is already handled by the caller.  */\n    return -2;\n  else if (uc < 0x800)\n    count = 2;\n  else if (uc < 0x10000)\n    {\n      if (uc < 0xd800 || uc >= 0xe000)\n        count = 3;\n      else\n        return -1;\n    }\n  else if (uc < 0x110000)\n    count = 4;\n  else\n    return -1;\n\n  if (n < count)\n    return -2;\n\n  switch (count) /* note: code falls through cases! */\n    {\n    case 4: s[3] = 0x80 | (uc & 0x3f); uc = uc >> 6; uc |= 0x10000;\n      FALLTHROUGH;\n    case 3: s[2] = 0x80 | (uc & 0x3f); uc = uc >> 6; uc |= 0x800;\n      FALLTHROUGH;\n    case 2: s[1] = 0x80 | (uc & 0x3f); uc = uc >> 6; uc |= 0xc0;\n  /*case 1:*/ s[0] = uc;\n    }\n  return count;\n}",
      "lines": 36,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "datamash/datamash-1.3/lib/unistr/u8-uctomb.c": {
    "u8_uctomb": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "int\nu8_uctomb (uint8_t *s, ucs4_t uc, int n)\n{\n  if (uc < 0x80)\n    {\n      if (n > 0)\n        {\n          s[0] = uc;\n          return 1;\n        }\n      /* else return -2, below.  */\n    }\n  else\n    {\n      int count;\n\n      if (uc < 0x800)\n        count = 2;\n      else if (uc < 0x10000)\n        {\n          if (uc < 0xd800 || uc >= 0xe000)\n            count = 3;\n          else\n            return -1;\n        }\n      else if (uc < 0x110000)\n        count = 4;\n      else\n        return -1;\n\n      if (n >= count)\n        {\n          switch (count) /* note: code falls through cases! */\n            {\n            case 4: s[3] = 0x80 | (uc & 0x3f); uc = uc >> 6; uc |= 0x10000;\n            case 3: s[2] = 0x80 | (uc & 0x3f); uc = uc >> 6; uc |= 0x800;\n            case 2: s[1] = 0x80 | (uc & 0x3f); uc = uc >> 6; uc |= 0xc0;\n          /*case 1:*/ s[0] = uc;\n            }\n          return count;\n        }\n    }\n  return -2;\n}",
      "lines": 44,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "datamash/datamash-1.3/lib/uniwidth/cjk.h": {
    "is_cjk_encoding": {
      "start_point": [
        19,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "static int\nis_cjk_encoding (const char *encoding)\n{\n  if (0\n      /* Legacy Japanese encodings */\n      || STREQ_OPT (encoding, \"EUC-JP\", 'E', 'U', 'C', '-', 'J', 'P', 0, 0, 0)\n      /* Legacy Chinese encodings */\n      || STREQ_OPT (encoding, \"GB2312\", 'G', 'B', '2', '3', '1', '2', 0, 0, 0)\n      || STREQ_OPT (encoding, \"GBK\", 'G', 'B', 'K', 0, 0, 0, 0, 0, 0)\n      || STREQ_OPT (encoding, \"EUC-TW\", 'E', 'U', 'C', '-', 'T', 'W', 0, 0, 0)\n      || STREQ_OPT (encoding, \"BIG5\", 'B', 'I', 'G', '5', 0, 0, 0, 0, 0)\n      /* Legacy Korean encodings */\n      || STREQ_OPT (encoding, \"EUC-KR\", 'E', 'U', 'C', '-', 'K', 'R', 0, 0, 0)\n      || STREQ_OPT (encoding, \"CP949\", 'C', 'P', '9', '4', '9', 0, 0, 0, 0)\n      || STREQ_OPT (encoding, \"JOHAB\", 'J', 'O', 'H', 'A', 'B', 0, 0, 0, 0))\n    return 1;\n  return 0;\n}",
      "lines": 18,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "datamash/datamash-1.3/lib/uniwidth/width.c": {
    "uc_width": {
      "start_point": [
        413,
        0
      ],
      "end_point": [
        467,
        1
      ],
      "content": "int\nuc_width (ucs4_t uc, const char *encoding)\n{\n  /* Test for non-spacing or control character.  */\n  if ((uc >> 9) < 248)\n    {\n      int ind = nonspacing_table_ind[uc >> 9];\n      if (ind >= 0)\n        if ((nonspacing_table_data[64*ind + ((uc >> 3) & 63)] >> (uc & 7)) & 1)\n          {\n            if (uc > 0 && uc < 0xa0)\n              return -1;\n            else\n              return 0;\n          }\n    }\n  else if ((uc >> 9) == (0xe0000 >> 9))\n    {\n      if (uc >= 0xe0100)\n        {\n          if (uc <= 0xe01ef)\n            return 0;\n        }\n      else\n        {\n          if (uc >= 0xe0020 ? uc <= 0xe007f : uc == 0xe0001)\n            return 0;\n        }\n    }\n  /* Test for double-width character.\n   * Generated from \"grep '^[^;]\\{4,5\\};[WF]' EastAsianWidth.txt\"\n   * and            \"grep '^[^;]\\{4,5\\};[^WF]' EastAsianWidth.txt\"\n   */\n  if (uc >= 0x1100\n      && ((uc < 0x1160) /* Hangul Jamo */\n          || (uc >= 0x2329 && uc < 0x232b) /* Angle Brackets */\n          || (uc >= 0x2e80 && uc < 0xa4d0  /* CJK ... Yi */\n              && !(uc == 0x303f) && !(uc >= 0x4dc0 && uc < 0x4e00))\n          || (uc >= 0xac00 && uc < 0xd7a4) /* Hangul Syllables */\n          || (uc >= 0xf900 && uc < 0xfb00) /* CJK Compatibility Ideographs */\n          || (uc >= 0xfe10 && uc < 0xfe20) /* Presentation Forms for Vertical */\n          || (uc >= 0xfe30 && uc < 0xfe70) /* CJK Compatibility Forms */\n          || (uc >= 0xff00 && uc < 0xff61) /* Fullwidth Forms */\n          || (uc >= 0xffe0 && uc < 0xffe7) /* Fullwidth Signs */\n          || (uc >= 0x20000 && uc <= 0x2ffff) /* Supplementary Ideographic Plane */\n          || (uc >= 0x30000 && uc <= 0x3ffff) /* Tertiary Ideographic Plane */\n     )   )\n    return 2;\n  /* In ancient CJK encodings, Cyrillic and most other characters are\n     double-width as well.  */\n  if (uc >= 0x00A1 && uc < 0xFF61 && uc != 0x20A9\n      && is_cjk_encoding (encoding))\n    return 2;\n  return 1;\n}",
      "lines": 55,
      "depth": 22,
      "decorators": [
        "int"
      ]
    }
  },
  "datamash/datamash-1.3/src/column-headers.c": {
    "free_column_headers": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "void free_column_headers ()\n{\n  for (size_t i = 0; i < num_input_column_headers; ++i)\n    {\n      free (input_column_headers[i]);\n      input_column_headers[i] = NULL;\n    }\n  free (input_column_headers);\n  input_column_headers = NULL;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "get_num_column_headers": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "size_t _GL_ATTRIBUTE_PURE\nget_num_column_headers ()\n{\n  return num_input_column_headers;\n}",
      "lines": 5,
      "depth": 4,
      "decorators": [
        "size_t",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "get_input_field_name": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "const char* _GL_ATTRIBUTE_PURE\nget_input_field_name (size_t field_num)\n{\n  assert (field_num > 0                              /* LCOV_EXCL_LINE */\n          && field_num <= num_input_column_headers); /* LCOV_EXCL_LINE */\n  return input_column_headers[field_num-1];\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "const",
        "const",
        "char",
        "* _GL_ATTRIBUTE_PURE\nget_input_field_name (size_t field_num)",
        "*",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "get_input_field_number": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "size_t _GL_ATTRIBUTE_PURE\nget_input_field_number (const char* field_name)\n{\n  assert (field_name != NULL); /* LCOV_EXCL_LINE */\n  assert (*field_name != 0);   /* LCOV_EXCL_LINE */\n  for (size_t i = 0 ; i < num_input_column_headers ; ++i)\n    {\n      if (STREQ (field_name,input_column_headers[i]))\n        return i+1;\n    }\n  return 0;\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "size_t",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "build_input_line_headers": {
      "start_point": [
        79,
        0
      ],
      "end_point": [
        109,
        1
      ],
      "content": "void\nbuild_input_line_headers (const struct line_record_t *lr, bool store_names)\n{\n  char *str;\n  size_t len = 0;\n  const size_t num_fields = line_record_num_fields (lr);\n  const size_t field_name_buf_size = 7+INT_BUFSIZE_BOUND (size_t)+1;\n\n  num_input_column_headers = num_fields;\n  input_column_headers = XNMALLOC (num_fields, char*);\n\n  for (size_t i = 1; i <= num_fields; ++i)\n    {\n      if (!store_names)\n        {\n          str = xmalloc ( field_name_buf_size );\n          ignore_value (snprintf (str, field_name_buf_size,\n                                  \"field-%\"PRIuMAX,(uintmax_t)i));\n        }\n      else\n        {\n          const char* tmp = NULL;\n          line_record_get_field (lr, i, &tmp, &len);\n          str = xmalloc ( len+1 );\n          memcpy (str, tmp, len);\n          str[len] = 0;\n        }\n\n      input_column_headers[i-1] = str;\n    }\n}",
      "lines": 31,
      "depth": 14,
      "decorators": [
        "void"
      ]
    }
  },
  "datamash/datamash-1.3/src/column-headers.h": {},
  "datamash/datamash-1.3/src/crosstab.c": {
    "str_comparator": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        46,
        1
      ],
      "content": "static bool _GL_ATTRIBUTE_PURE\nstr_comparator (const void* a, const void* b)\n{\n  assert (a!=NULL && b!=NULL);                   /* LCOV_EXCL_LINE */\n  if (a==b)\n    return true;\n  return (STREQ ((const char*)a, (const char*)b));\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "bool",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "hash_crosstab_data_cell": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        63,
        1
      ],
      "content": "static size_t _GL_ATTRIBUTE_PURE\nhash_crosstab_data_cell (void const *x, size_t tablesize)\n{\n  struct crosstab_datacell *dc = (struct crosstab_datacell*)x;\n\n  const char *s;\n  size_t h = 0;\n#define SIZE_BITS (sizeof (size_t) * CHAR_BIT)\n\n  for (s = dc->row_name; *s; s++)\n    h = *s + ((h << 9) | (h >> (SIZE_BITS - 9)));\n  for (s = dc->col_name; *s; s++)\n    h = *s + ((h << 9) | (h >> (SIZE_BITS - 9)));\n\n  return h % tablesize;\n}",
      "lines": 16,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "size_t",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "crosstab_datacell_comparator": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        75,
        1
      ],
      "content": "static bool _GL_ATTRIBUTE_PURE\ncrosstab_datacell_comparator (const void* a, const void* b)\n{\n  assert (a!=NULL && b!=NULL);                   /* LCOV_EXCL_LINE */\n  if (a==b)\n    return true;\n  const struct crosstab_datacell *da = (struct crosstab_datacell*)a;\n  const struct crosstab_datacell *db = (struct crosstab_datacell*)b;\n  return (STREQ (da->row_name, db->row_name)\n          && STREQ (da->col_name, db->col_name));\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "bool",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "new_datacell": {
      "start_point": [
        78,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "struct crosstab_datacell*\nnew_datacell (const char* row, const char* col, const char* data)\n{\n  struct crosstab_datacell *dc = xmalloc (sizeof (struct crosstab_datacell));\n  dc->row_name = row;\n  dc->col_name = col;\n  dc->data = data;\n  return dc;\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "struct crosstab_datacell",
        "struct",
        "crosstab_datacell",
        "*\nnew_datacell (const char* row, const char* col, const char* data)",
        "*"
      ]
    },
    "crosstab_datacell_free": {
      "start_point": [
        88,
        0
      ],
      "end_point": [
        96,
        1
      ],
      "content": "static void\ncrosstab_datacell_free (void *a)\n{\n  struct crosstab_datacell *dc = (struct crosstab_datacell*)a;\n  dc->row_name = NULL;\n  dc->col_name = NULL;\n  dc->data = NULL;\n  free (dc);\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "crosstab_init": {
      "start_point": [
        99,
        0
      ],
      "end_point": [
        110,
        1
      ],
      "content": "struct crosstab*\ncrosstab_init ()\n{\n  struct crosstab *ct = XMALLOC (struct crosstab);\n\n  ct->rows    = hash_initialize (1000,NULL,hash_pjw,str_comparator,free);\n  ct->columns = hash_initialize (1000,NULL,hash_pjw,str_comparator,free);\n  ct->data    = hash_initialize (1000,NULL,hash_crosstab_data_cell,\n                                crosstab_datacell_comparator,\n                                crosstab_datacell_free);\n  return ct;\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "struct crosstab",
        "struct",
        "crosstab",
        "*\ncrosstab_init ()",
        "*"
      ]
    },
    "crosstab_free": {
      "start_point": [
        112,
        0
      ],
      "end_point": [
        123,
        1
      ],
      "content": "void\ncrosstab_free (struct crosstab* ct)\n{\n  assert (ct!=NULL);                             /* LCOV_EXCL_LINE */\n  hash_free (ct->rows);\n  ct->rows = NULL;\n  hash_free (ct->columns);\n  ct->columns = NULL;\n  hash_free (ct->data);\n  ct->data = NULL;\n  free (ct);\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "crosstab_add_result": {
      "start_point": [
        126,
        0
      ],
      "end_point": [
        140,
        1
      ],
      "content": "void\ncrosstab_add_result (struct crosstab* ct,\n                      const char* row, const char* col, const char* data)\n{\n  const char* r = hash_lookup (ct->rows, row);\n  if (r==NULL)\n    r = hash_insert (ct->rows, xstrdup (row));\n\n  const char* c = hash_lookup (ct->columns, col);\n  if (c==NULL)\n    c = hash_insert (ct->columns, xstrdup (col));\n\n  struct crosstab_datacell *ctdc = new_datacell (r,c,xstrdup (data));\n  ignore_value (hash_insert (ct->data, ctdc));\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "crosstab_print": {
      "start_point": [
        144,
        0
      ],
      "end_point": [
        186,
        1
      ],
      "content": "void\ncrosstab_print (const struct crosstab* ct)\n{\n  const size_t n_rows = hash_get_n_entries (ct->rows);\n  char** rows_list = XNMALLOC (n_rows,char*);\n  hash_get_entries (ct->rows, (void**)rows_list, n_rows);\n  qsort (rows_list, n_rows, sizeof (char*), cmpstringp);\n\n  const size_t n_cols = hash_get_n_entries (ct->columns);\n  char** cols_list = XNMALLOC (n_cols,char*);\n  hash_get_entries (ct->columns, (void**)cols_list, n_cols);\n  qsort (cols_list, n_cols, sizeof (char*), cmpstringp);\n\n  /* Print columns */\n  for (size_t c = 0; c < n_cols; ++c)\n    {\n      print_field_separator ();\n      fputs (cols_list[c], stdout);\n    }\n  print_line_separator ();\n\n  /* Print rows */\n  for (size_t r = 0; r < n_rows; ++r)\n    {\n      fputs (rows_list[r], stdout);\n\n      for (size_t c = 0; c < n_cols; ++c)\n        {\n          struct crosstab_datacell curr;\n          curr.row_name = rows_list[r];\n          curr.col_name = cols_list[c];\n\n          const struct crosstab_datacell *dc = hash_lookup (ct->data, &curr);\n          print_field_separator ();\n          fputs ((dc==NULL)?missing_field_filler:dc->data, stdout);\n        }\n\n      print_line_separator ();\n    }\n\n  IF_LINT (free (rows_list));\n  IF_LINT (free (cols_list));\n}",
      "lines": 43,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "datamash/datamash-1.3/src/crosstab.h": {},
  "datamash/datamash-1.3/src/datamash.c": {
    "group_columns_find_named_columns": {
      "start_point": [
        146,
        0
      ],
      "end_point": [
        163,
        1
      ],
      "content": "void\ngroup_columns_find_named_columns ()\n{\n  for (size_t i = 0; i < dm->num_grps; ++i)\n    {\n      struct group_column_t *p = &dm->grps[i];\n\n      if (!p->by_name)\n        continue;\n\n      p->num = get_input_field_number (p->name);\n      if (p->num == 0)\n        die (EXIT_FAILURE, 0,\n                _(\"column name %s not found in input file\"),\n                quote (p->name));\n      p->by_name = false;\n    }\n}",
      "lines": 18,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "usage": {
      "start_point": [
        165,
        0
      ],
      "end_point": [
        302,
        1
      ],
      "content": "void\nusage (int status)\n{\n  if (status != EXIT_SUCCESS)\n    emit_try_help ();\n  else\n    {\n      printf (_(\"Usage: %s [OPTION] op [fld] [op fld ...]\\n\"),\n          program_name);\n      fputs (\"\\n\", stdout);\n      fputs (_(\"Performs numeric/string operations on input from stdin.\"),\n          stdout);\n      fputs (\"\\n\\n\", stdout);\n      fputs (_(\"\\\n'op' is the operation to perform.  If a primary operation is used,\\n\\\nit must be listed first, optionally followed by other operations.\\n\"), stdout);\n      fputs (_(\"\\\n'fld' is the input field to use.  'fld' can be a number (1=first field),\\n\\\nor a field name when using the -H or --header-in options.\\n\"), stdout);\n      fputs (_(\"\\\nMultiple fields can be listed with a comma (e.g. 1,6,8).  A range of\\n\\\nfields can be listed with a dash (e.g. 2-8).  Use colons for operations\\n\\\nwhich require a pair of fields (e.g. 'pcov 2:6').\\n\"), stdout);\n      fputs (\"\\n\\n\", stdout);\n      fputs (_(\"Primary operations:\\n\"),stdout);\n      fputs (\"  groupby, crosstab, transpose, reverse, check\\n\",stdout);\n\n      fputs (_(\"Line-Filtering operations:\\n\"),stdout);\n      fputs (\"  rmdup\\n\",stdout);\n\n      fputs (_(\"Per-Line operations:\\n\"),stdout);\n      fputs (\"  base64, debase64, md5, sha1, sha256, sha512,\\n\", stdout);\n      fputs (\"  bin, strbin, round, floor, ceil, trunc, frac\\n\", stdout);\n\n      fputs (_(\"Numeric Grouping operations:\\n\"),stdout);\n      fputs (\"  sum, min, max, absmin, absmax, range\\n\",stdout);\n\n      fputs (_(\"Textual/Numeric Grouping operations:\\n\"),stdout);\n      fputs (\"  count, first, last, rand, unique, collapse, countunique\\n\",\n             stdout);\n\n      fputs (_(\"Statistical Grouping operations:\\n\"),stdout);\n      fputs (\"\\\n  mean, trimmean, median, q1, q3, iqr, perc, mode, antimode, \\n\\\n  pstdev, sstdev, pvar, svar, mad, madraw,\\n\\\n  pskew, sskew, pkurt, skurt, dpo, jarque,\\n\\\n  scov, pcov, spearson, ppearson\\n\\\n\\n\", stdout);\n      fputs (\"\\n\", stdout);\n\n      fputs (_(\"Grouping Options:\\n\"),stdout);\n      fputs (_(\"\\\n  -f, --full                print entire input line before op results\\n\\\n                              (default: print only the grouped keys)\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -g, --group=X[,Y,Z]       group via fields X,[Y,Z];\\n\\\n                              equivalent to primary operation 'groupby'\\n\\\n\"), stdout);\n      fputs (_(\"\\\n      --header-in           first input line is column headers\\n\\\n\"), stdout);\n      fputs (_(\"\\\n      --header-out          print column headers as first line\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -H, --headers             same as '--header-in --header-out'\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -i, --ignore-case         ignore upper/lower case when comparing text;\\n\\\n                              this affects grouping, and string operations\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -s, --sort                sort the input before grouping; this removes the\\n\\\n                              need to manually pipe the input through 'sort'\\n\\\n\"), stdout);\n\n      fputs (_(\"File Operation Options:\\n\"),stdout);\n      fputs (_(\"\\\n      --no-strict           allow lines with varying number of fields\\n\\\n\"), stdout);\n      fputs (_(\"\\\n      --filler=X            fill missing values with X (default %s)\\n\\\n\"), stdout);\n\n      fputs (\"\\n\", stdout);\n      fputs (_(\"General Options:\\n\"),stdout);\n      fputs (_(\"\\\n  -t, --field-separator=X   use X instead of TAB as field delimiter\\n\\\n\"), stdout);\n      fputs (_(\"\\\n      --format=FORMAT       print numeric values with printf style\\n\\\n                            floating-point FORMAT.\\n\\\n\"), stdout);\n      fputs (_(\"\\\n      --output-delimiter=X  use X instead as output field delimiter\\n\\\n                            (default: use same delimiter as -t/-W)\\n\\\n\"), stdout);\n      fputs (_(\"\\\n      --narm                skip NA/NaN values\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -R, --round=N             round numeric output to N decimal places\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -W, --whitespace          use whitespace (one or more spaces and/or tabs)\\n\\\n                              for field delimiters\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -z, --zero-terminated     end lines with 0 byte, not newline\\n\\\n\"), stdout);\n\n      fputs (HELP_OPTION_DESCRIPTION, stdout);\n      fputs (VERSION_OPTION_DESCRIPTION, stdout);\n\n      fputs (\"\\n\\n\", stdout);\n\n      fputs (_(\"Examples:\"), stdout);\n      fputs (\"\\n\\n\", stdout);\n      fputs (_(\"Print the sum and the mean of values from column 1:\"), stdout);\n      printf (\"\\n\\\n  $ seq 10 | %s sum 1 mean 1\\n\\\n  55  5.5\\n\\\n\\n\", program_name);\n      fputs (_(\"Transpose input:\"), stdout);\n      printf (\"\\n\\\n  $ seq 10 | paste - - | %s transpose\\n\\\n  1    3    5    7    9\\n\\\n  2    4    6    8    10\\n\\\n\\n\", program_name);\n\n      fputs (_(\"For detailed usage information and examples, see\\n\"),stdout);\n      printf (\"  man %s\\n\", PACKAGE_NAME);\n      fputs (_(\"The manual and more examples are available at\\n\"), stdout);\n      fputs (\"  \" PACKAGE_URL \"\\n\\n\", stdout);\n    }\n  exit (status);\n}",
      "lines": 138,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "error_not_enough_fields": {
      "start_point": [
        304,
        0
      ],
      "end_point": [
        311,
        1
      ],
      "content": "static inline noreturn void\nerror_not_enough_fields (const size_t needed, const size_t found)\n{\n  error (0, 0, _(\"invalid input: field %\"PRIuMAX\" requested, \" \\\n        \"line %\"PRIuMAX\" has only %\"PRIuMAX\" fields\"),\n        (uintmax_t)needed, (uintmax_t)line_number, (uintmax_t)found);\n  exit (EXIT_FAILURE);\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "noreturn",
        "void",
        "void"
      ]
    },
    "safe_line_record_get_field": {
      "start_point": [
        314,
        0
      ],
      "end_point": [
        320,
        1
      ],
      "content": "static inline void\nsafe_line_record_get_field (const struct line_record_t *lr, const size_t n,\n                            const char ** /* out */ pptr, size_t* /*out*/ plen)\n{\n  if (!line_record_get_field (lr, n, pptr, plen))\n    error_not_enough_fields (n, line_record_num_fields (lr));\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    },
    "safe_line_record_get_fieldz": {
      "start_point": [
        322,
        0
      ],
      "end_point": [
        332,
        1
      ],
      "content": "static inline void\nsafe_line_record_get_fieldz (const struct line_record_t *lr, const size_t n,\n                             char * /* out */ buf, size_t len)\n{\n  const char *p;\n  size_t l;\n  safe_line_record_get_field (lr, n, &p, &l);\n  l = MIN (len-1,l);\n  memcpy (buf, p, l);\n  buf[l] = 0;\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    },
    "different": {
      "start_point": [
        337,
        0
      ],
      "end_point": [
        354,
        1
      ],
      "content": "static bool\ndifferent (const struct line_record_t* l1, const struct line_record_t* l2)\n{\n  for (size_t i = 0; i < dm->num_grps; ++i)\n    {\n      const size_t col_num = dm->grps[i].num;\n      const char *str1=NULL,*str2=NULL;\n      size_t len1=0,len2=0;\n      safe_line_record_get_field (l1, col_num, &str1, &len1);\n      safe_line_record_get_field (l2, col_num, &str2, &len2);\n      if (len1 != len2)\n        return true;\n      if ((case_sensitive && !STREQ_LEN (str1,str2,len1))\n          || (!case_sensitive && (strncasecmp (str1,str2,len1)!=0)))\n        return true;\n    }\n  return false;\n}",
      "lines": 18,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "process_line": {
      "start_point": [
        358,
        0
      ],
      "end_point": [
        384,
        1
      ],
      "content": "static bool\nprocess_line (const struct line_record_t *line)\n{\n  const char *str = NULL;\n  size_t len = 0;\n  enum FIELD_OP_COLLECT_RESULT flocr;\n  bool keep_line = false;\n\n  for (size_t i=0; i<dm->num_ops; ++i)\n    {\n      struct fieldop *op = &dm->ops[i];\n      safe_line_record_get_field (line, op->field, &str, &len);\n      flocr = field_op_collect (op, str, len);\n      if (!field_op_ok (flocr))\n        {\n          char *tmp = xmalloc (len+1);\n          memcpy (tmp,str,len);\n          tmp[len] = 0 ;\n          die (EXIT_FAILURE, 0,\n              _(\"%s in line %\"PRIuMAX\" field %\"PRIuMAX\": '%s'\"),\n              field_op_collect_result_name (flocr),\n              (uintmax_t)line_number, (uintmax_t)op->field, tmp);\n        }\n      keep_line = keep_line || (flocr==FLOCR_OK_KEEP_LINE);\n    }\n  return keep_line;\n}",
      "lines": 27,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "print_input_line": {
      "start_point": [
        390,
        0
      ],
      "end_point": [
        414,
        1
      ],
      "content": "static void\nprint_input_line (const struct line_record_t* lb)\n{\n  const char *str = NULL;\n  size_t len = 0 ;\n  if (print_full_line)\n    {\n      for (size_t i = 1; i <= line_record_num_fields (lb); ++i)\n        {\n          safe_line_record_get_field (lb, i, &str, &len);\n          ignore_value (fwrite (str, sizeof (char), len, stdout));\n          print_field_separator ();\n        }\n    }\n  else\n    {\n      for (size_t i = 0; i < dm->num_grps; ++i)\n        {\n          const size_t col_num = dm->grps[i].num;\n          safe_line_record_get_field (lb, col_num, &str, &len);\n          ignore_value (fwrite (str,sizeof (char),len,stdout));\n          print_field_separator ();\n        }\n    }\n}",
      "lines": 25,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "print_column_headers": {
      "start_point": [
        427,
        0
      ],
      "end_point": [
        483,
        1
      ],
      "content": "static void\nprint_column_headers ()\n{\n  if (print_full_line)\n    {\n      /* Print the headers of all the input fields */\n      for (size_t n=1; n<=get_num_column_headers (); ++n)\n        {\n          fputs (get_input_field_name (n), stdout);\n          print_field_separator ();\n        }\n    }\n  else\n    {\n      /* print only the headers of the group-by fields, e.g\n        'GroupBy (field-3)'  (without input headers), or\n        'GroupBy (NAME)'     (with input headers)           */\n      for (size_t i = 0; i < dm->num_grps; ++i)\n        {\n          const size_t col_num = dm->grps[i].num;\n          if (col_num > get_num_column_headers ())\n            error_not_enough_fields (col_num, get_num_column_headers ());\n          printf (\"GroupBy\" \"(%s)\",get_input_field_name (col_num));\n          print_field_separator ();\n        }\n    }\n\n  /* add headers of the operations, e.g.\n        'sum (field-3)'  (without input headers), or\n        'sum (NAME)'     (with input headers)           */\n  for (size_t i=0; i<dm->num_ops; ++i)\n    {\n      struct fieldop *op = &dm->ops[i];\n      if (op->slave)\n        continue;\n\n      if (op->field > get_num_column_headers ())\n        error_not_enough_fields (op->field, get_num_column_headers ());\n\n      printf (\"%s\", get_field_operation_name (op->op));\n\n      if (op->op == OP_PERCENTILE) {\n        printf (\":%\"PRIuMAX, (uintmax_t)op->params.percentile);\n      }\n      if (op->op == OP_TRIMMED_MEAN) {\n        printf (\":%Lg\", op->params.trimmed_mean);\n      }\n\n      printf (\"(%s)\", get_input_field_name (op->field));\n\n      if (i != dm->num_ops-1)\n        print_field_separator ();\n    }\n\n  /* print end-of-line */\n  print_line_separator ();\n}",
      "lines": 57,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "field_op_find_named_columns": {
      "start_point": [
        485,
        0
      ],
      "end_point": [
        500,
        1
      ],
      "content": "void\nfield_op_find_named_columns ()\n{\n  for (size_t i=0; i<dm->num_ops; ++i)\n    {\n      struct fieldop *p = &dm->ops[i];\n      if (!p->field_by_name)\n        continue;\n      p->field = get_input_field_number (p->field_name);\n      if (p->field == 0)\n        die (EXIT_FAILURE, 0,\n                _(\"column name %s not found in input file\"),\n                quote (p->field_name));\n      p->field_by_name = false;\n    }\n}",
      "lines": 16,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "process_input_header": {
      "start_point": [
        505,
        0
      ],
      "end_point": [
        521,
        1
      ],
      "content": "static void\nprocess_input_header (FILE *stream)\n{\n  struct line_record_t lr;\n\n  line_record_init (&lr);\n  if (line_record_fread (&lr, stream, eolchar))\n    {\n      build_input_line_headers (&lr, true);\n      line_number++;\n      /* If using named-columns, find the column numbers after reading the\n         header line. */\n      field_op_find_named_columns ();\n      group_columns_find_named_columns ();\n    }\n  line_record_free (&lr);\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "summarize_field_ops": {
      "start_point": [
        523,
        0
      ],
      "end_point": [
        542,
        1
      ],
      "content": "void\nsummarize_field_ops ()\n{\n  for (size_t i=0;i<dm->num_ops;++i)\n    {\n      struct fieldop *p = &dm->ops[i];\n      if (p->slave)\n        continue;\n\n      field_op_summarize (p);\n      fputs (p->out_buf, stdout);\n\n      /* print field separator */\n      if (i != dm->num_ops-1)\n        print_field_separator ();\n    }\n\n  /* print end-of-line */\n  print_line_separator ();\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "reset_field_ops": {
      "start_point": [
        544,
        0
      ],
      "end_point": [
        549,
        1
      ],
      "content": "void\nreset_field_ops ()\n{\n  for (size_t i=0;i<dm->num_ops;++i)\n    field_op_reset (&dm->ops[i]);\n}",
      "lines": 6,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "process_group": {
      "start_point": [
        553,
        0
      ],
      "end_point": [
        587,
        1
      ],
      "content": "static void\nprocess_group (const struct line_record_t* line)\n{\n  /* TODO: dynamically re-alloc if needed */\n  char col_name[512];\n  char row_name[512];\n\n  if (lines_in_group>0)\n    {\n      if (crosstab_mode)\n        {\n          /* cross-tabulation mode - save results in a matrix, print later */\n          const size_t row_field = dm->grps[0].num;\n          safe_line_record_get_fieldz (line, row_field,\n                                       row_name, sizeof row_name);\n\n          const size_t col_field = dm->grps[1].num;\n          safe_line_record_get_fieldz (line, col_field,\n                                       col_name, sizeof col_name);\n\n          field_op_summarize (&dm->ops[0]);\n          const char* data = dm->ops[0].out_buf;\n\n          crosstab_add_result (crosstab, row_name, col_name, data);\n        }\n      else\n        {\n          /* group-by/per-line mode - print results once available */\n          print_input_line (line);\n          summarize_field_ops ();\n        }\n    }\n  lines_in_group = 0;\n  reset_field_ops ();\n}",
      "lines": 35,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "process_file": {
      "start_point": [
        595,
        0
      ],
      "end_point": [
        668,
        1
      ],
      "content": "static void\nprocess_file ()\n{\n  struct line_record_t lb1, lb2;\n  struct line_record_t *thisline, *group_first_line;\n\n  thisline = &lb1;\n  group_first_line = &lb2;\n\n  line_record_init (thisline);\n  line_record_init (group_first_line);\n\n  /* If there is an input header line, and it wasn't read already\n     in 'open_input' - read it now */\n  if (input_header && line_number==0)\n    process_input_header (input_stream);\n\n  /* If there is an input header line, and the user requested an output\n     header line, and the input line was read successfully, print headers */\n  if (input_header && output_header && line_number==1)\n    print_column_headers ();\n\n\n  while (true)\n    {\n      bool new_group = false;\n\n      if (!line_record_fread (thisline, input_stream, eolchar))\n        break;\n      line_number++;\n\n      /* If there's no input header line, and the user requested an output\n         header line, then generate output header line based on the number\n         of fields in the first (data, non-header) input line */\n      if (line_number==1 && output_header && !input_header)\n        {\n          build_input_line_headers (thisline, false);\n          print_column_headers ();\n        }\n\n\n      /* If no keys are given, the entire input is considered one group */\n      if (dm->num_grps || line_mode)\n        {\n          new_group = (group_first_line->lbuf.length == 0 || line_mode\n                       || different (thisline, group_first_line));\n\n          if (new_group)\n            {\n              process_group (group_first_line);\n              group_first_line->lbuf.length = 0;\n            }\n        }\n      else\n        {\n          /* The entire line is a \"group\", if it's the first line, keep it */\n          new_group = (group_first_line->lbuf.length==0);\n        }\n\n      lines_in_group++;\n      bool keep_line = process_line (thisline);\n\n      if (new_group || keep_line)\n        {\n          SWAP_LINES (group_first_line, thisline);\n        }\n    }\n\n  /* summarize last group */\n  process_group (group_first_line);\n\n  line_record_free (&lb1);\n  line_record_free (&lb2);\n}",
      "lines": 74,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "transpose_file": {
      "start_point": [
        673,
        0
      ],
      "end_point": [
        739,
        1
      ],
      "content": "static void\ntranspose_file ()\n{\n  size_t num_lines = 0;\n  size_t alloc_lines = 0;\n  struct line_record_t *lines = NULL;\n\n  size_t max_num_fields = 0 ;\n  size_t prev_num_fields = 0 ;\n\n  /* Read all input lines - but instead of reusing line_record_t,\n     keep all lines in memory. */\n  while (true)\n    {\n      if (num_lines+1 > alloc_lines)\n        {\n          alloc_lines += 1000;\n          lines = xnrealloc ( lines, alloc_lines,\n                              sizeof (struct line_record_t));\n        }\n\n      struct line_record_t *thisline = &lines[num_lines];\n      num_lines++;\n      line_record_init (thisline);\n\n      if (!line_record_fread ( thisline, input_stream, eolchar))\n        break;\n      line_number++;\n\n      const size_t num_fields = line_record_num_fields (thisline);\n\n      if (strict && line_number>1 && num_fields != prev_num_fields)\n          die (EXIT_FAILURE, 0, _(\"transpose input error: line %\"PRIuMAX\" \" \\\n                    \"has %\"PRIuMAX\" fields (previous lines had %\"PRIuMAX\");\\n\" \\\n                    \"see --help to disable strict mode\"),\n                    (uintmax_t)line_number, (uintmax_t)num_fields,\n                    (uintmax_t)prev_num_fields);\n\n      prev_num_fields = num_fields;\n      max_num_fields = MAX (max_num_fields,num_fields);\n\n    }\n\n  /* Output all fields */\n  for (size_t i = 1 ; i <= max_num_fields ; ++i)\n    {\n      for (size_t j = 0; j < line_number; ++j)\n        {\n          if (j>0)\n            print_field_separator ();\n\n          const struct line_record_t *line = &lines[j];\n          const char* str;\n          size_t len;\n          if (line_record_get_field (line, i, &str, &len))\n            fwrite (str, len, sizeof (char), stdout);\n          else\n            fputs (missing_field_filler, stdout);\n        }\n      print_line_separator ();\n    }\n\n  /* Free pointers */\n  for (size_t i = 0; i < num_lines; ++i)\n    line_record_free (&lines[i]);\n  free (lines);\n}",
      "lines": 67,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "reverse_fields_in_file": {
      "start_point": [
        744,
        0
      ],
      "end_point": [
        809,
        1
      ],
      "content": "static void\nreverse_fields_in_file ()\n{\n  struct line_record_t lr;\n  struct line_record_t *thisline;\n  size_t prev_num_fields = 0;\n  thisline = &lr;\n  line_record_init (thisline);\n\n  while (true)\n    {\n      if (!line_record_fread (thisline, input_stream, eolchar))\n        break;\n      line_number++;\n\n      const size_t num_fields = line_record_num_fields (thisline);\n\n      if (strict && line_number>1 && num_fields != prev_num_fields)\n          die (EXIT_FAILURE, 0, _(\"reverse-field input error: line \" \\\n                       \"%\"PRIuMAX\" has %\"PRIuMAX\" fields (previous lines had \" \\\n                       \"%\"PRIuMAX\");\\n\" \\\n                       \"see --help to disable strict mode\"),\n                        (uintmax_t)line_number, (uintmax_t)num_fields,\n                        (uintmax_t)prev_num_fields);\n\n      prev_num_fields = num_fields;\n\n      /* Special handling for header line */\n      if (line_number == 1)\n        {\n          /* If there is an header line (first line), and the user did not\n             request printing the header, skip it */\n          if (input_header && !output_header)\n            continue;\n\n          /* There is no input header line (first line already contains data),\n             and the user requested to generate output header line.\n             Print dummy header lines. */\n          if (!input_header && output_header)\n            {\n              build_input_line_headers (thisline, false);\n              for (size_t i = num_fields; i > 0; --i)\n                {\n                  if (i < num_fields)\n                    print_field_separator ();\n                  fputs (get_input_field_name (i), stdout);\n                }\n              print_line_separator ();\n            }\n        }\n\n      /* Print the line, reversing field order */\n      for (size_t i = num_fields; i > 0; --i)\n        {\n          if (i < num_fields)\n            print_field_separator ();\n\n          const char* str = NULL;\n          size_t len = 0 ;\n          ignore_value (line_record_get_field (thisline, i, &str, &len));\n          fwrite (str, len, sizeof (char), stdout);\n        }\n      print_line_separator ();\n    }\n  line_record_free (&lr);\n}",
      "lines": 66,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "noop_file": {
      "start_point": [
        814,
        0
      ],
      "end_point": [
        837,
        1
      ],
      "content": "static void\nnoop_file ()\n{\n  struct line_record_t lr;\n  struct line_record_t *thisline;\n\n  thisline = &lr;\n  line_record_init (thisline);\n  while (true)\n    {\n      if (!line_record_fread (thisline, input_stream, eolchar))\n        break;\n      line_number++;\n\n      if (print_full_line)\n        {\n          ignore_value (fwrite (line_record_buffer (thisline),\n                                line_record_length (thisline), sizeof (char),\n                                stdout));\n          print_line_separator ();\n        }\n    }\n  line_record_free (&lr);\n}",
      "lines": 24,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "tabular_check_file": {
      "start_point": [
        843,
        0
      ],
      "end_point": [
        929,
        1
      ],
      "content": "static void\ntabular_check_file ()\n{\n  size_t prev_num_fields=0;\n  struct line_record_t lb1, lb2;\n  struct line_record_t *thisline, *prevline;\n\n  const uintmax_t n_lines = dm->mode_params.check_params.n_lines;\n  const uintmax_t n_fields = dm->mode_params.check_params.n_fields;\n\n  thisline = &lb1;\n  prevline = &lb2;\n\n  line_record_init (thisline);\n  line_record_init (prevline);\n\n  while (true)\n    {\n      if (!line_record_fread (thisline, input_stream, eolchar))\n        break;\n      line_number++;\n\n      const size_t num_fields = line_record_num_fields (thisline);\n\n      /* Check if the number of fields is different than expected/requested\n         on the command line (e.g. with 'datamash check 6 fields') */\n      if (n_fields && n_fields != num_fields)\n        {\n          fprintf (stderr, _(\"line %\"PRIuMAX\" (%\"PRIuMAX\" fields):\\n  \"),\n                       (uintmax_t)(line_number), (uintmax_t)num_fields);\n          ignore_value (fwrite (line_record_buffer (thisline),\n                                line_record_length (thisline), sizeof (char),\n                                stderr));\n          fputc ('\\n', stderr);\n          die (EXIT_FAILURE, 0, _(\"check failed: line \" \\\n                       \"%\"PRIuMAX\" has %\"PRIuMAX\" fields (expecting \"\\\n                       \"%\"PRIuMAX\")\"),\n                       (uintmax_t)line_number, (uintmax_t)num_fields,\n                       (uintmax_t)n_fields);\n        }\n\n      /* Check if the number of fields changed from one line to the next\n         (only if no expected number of fields specified on the command line).*/\n      else if (line_number>1 && num_fields != prev_num_fields)\n        {\n          fprintf (stderr, _(\"line %\"PRIuMAX\" (%\"PRIuMAX\" fields):\\n  \"),\n                       (uintmax_t)(line_number-1), (uintmax_t)prev_num_fields);\n          ignore_value (fwrite (line_record_buffer (prevline),\n                                line_record_length (prevline), sizeof (char),\n                                stderr));\n          fputc ('\\n', stderr);\n          fprintf (stderr, _(\"line %\"PRIuMAX\" (%\"PRIuMAX\" fields):\\n  \"),\n                       (uintmax_t)(line_number), (uintmax_t)num_fields);\n          ignore_value (fwrite (line_record_buffer (thisline),\n                                line_record_length (thisline), sizeof (char),\n                                stderr));\n          fputc ('\\n', stderr);\n          die (EXIT_FAILURE, 0, _(\"check failed: line \" \\\n                       \"%\"PRIuMAX\" has %\"PRIuMAX\" fields (previous line had \"\\\n                       \"%\"PRIuMAX\")\"),\n                       (uintmax_t)line_number, (uintmax_t)num_fields,\n                       (uintmax_t)prev_num_fields);\n        }\n      prev_num_fields = num_fields;\n\n      SWAP_LINES (prevline, thisline);\n    }\n\n  /* Check if we read too many/few lines */\n  if (n_lines && n_lines != line_number)\n    {\n      die (EXIT_FAILURE, 0, _(\"check failed: input had %\"PRIuMAX\" lines \" \\\n                              \"(expecting %\"PRIuMAX\")\"),\n           (uintmax_t)line_number, (uintmax_t)n_lines);\n    }\n\n  /* Print summary */\n  printf (ngettext (\"%\"PRIuMAX\" line\", \"%\"PRIuMAX\" lines\",\n          select_plural (line_number)), (uintmax_t)line_number);\n  fputs (\", \", stdout);\n  printf (ngettext (\"%\"PRIuMAX\" field\", \"%\"PRIuMAX\" fields\",\n          select_plural (prev_num_fields)), (uintmax_t)prev_num_fields);\n  print_line_separator ();\n\n  line_record_free (&lb1);\n  line_record_free (&lb2);\n}",
      "lines": 87,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "remove_dups_in_file": {
      "start_point": [
        934,
        0
      ],
      "end_point": [
        1041,
        1
      ],
      "content": "static void\nremove_dups_in_file ()\n{\n  const char* str = NULL;\n  size_t len = 0;\n  struct line_record_t lr;\n  struct line_record_t *thisline;\n  Hash_table *ht;\n  const size_t init_table_size = rmdup_initial_size;\n\n  char* keys_buffer = NULL;\n  size_t keys_buffer_alloc = 0;\n  size_t next_key_pos = 0;\n\n  char** buffer_list = NULL;\n  size_t buffer_list_alloc = 0;\n  size_t buffer_list_size = 0;\n\n  thisline = &lr;\n  line_record_init (thisline);\n  ht = hash_initialize (init_table_size, NULL,\n                        hash_pjw, hash_compare_strings, NULL);\n\n  /* Allocate keys buffer */\n  keys_buffer_alloc = rmdup_initial_size ;\n  keys_buffer = xmalloc ( keys_buffer_alloc );\n\n  /* List of allocated key-buffers */\n  buffer_list = x2nrealloc (NULL, &buffer_list_alloc, sizeof (char*));\n  buffer_list[0] = keys_buffer;\n  buffer_list_size = 1 ;\n\n  if (input_header)\n    {\n      if (line_record_fread (thisline, input_stream, eolchar))\n        {\n          line_number++;\n\n          /* If using named-columns, find the column numbers after reading the\n             header line. */\n          if (dm->header_required)\n            {\n              build_input_line_headers (&lr, true);\n              group_columns_find_named_columns ();\n            }\n\n          if (output_header)\n            {\n              ignore_value (fwrite (line_record_buffer (thisline),\n                                    line_record_length (thisline),\n                                    sizeof (char), stdout));\n              print_line_separator ();\n            }\n        }\n    }\n\n  assert (dm->num_grps==1); /* LCOV_EXCL_LINE */\n  const size_t key_col = dm->grps[0].num;\n\n  /* TODO: handle (output_header && !input_header) by generating dummy headers\n           after the first line is read, and the number of fields is known. */\n\n  while (true)\n    {\n      if (!line_record_fread (thisline, input_stream, eolchar))\n        break;\n      line_number++;\n\n       if (!line_record_get_field (thisline, key_col, &str, &len))\n         error_not_enough_fields (key_col, line_record_num_fields (thisline));\n\n       /* Add key to the key buffer */\n       if (next_key_pos + len + 1 > keys_buffer_alloc)\n         {\n           keys_buffer = xmalloc ( keys_buffer_alloc ) ;\n           next_key_pos = 0;\n\n           /* Add new key-buffer to the list */\n           if (buffer_list_size == buffer_list_alloc)\n              buffer_list = x2nrealloc (buffer_list,\n                                        &buffer_list_alloc, sizeof (char*));\n           buffer_list[buffer_list_size++] = keys_buffer;\n         }\n       char *next_key = keys_buffer+next_key_pos;\n       memcpy (next_key, str, len);\n       next_key[len] = 0;\n\n       /* Add key to buffer (if not found) */\n       const int i = hash_insert_if_absent (ht, next_key, NULL);\n       if ( i == -1 )\n         die (EXIT_FAILURE, errno, _(\"hash memory allocation error\"));\n\n       if ( i == 1 )\n         {\n           /* This string was not found in the hash - new key */\n           next_key_pos += len+1;\n           ignore_value (fwrite (line_record_buffer (thisline),\n                                 line_record_length (thisline), sizeof (char),\n                                 stdout));\n           print_line_separator ();\n         }\n    }\n  line_record_free (&lr);\n  hash_free (ht);\n  for (size_t i = 0 ; i < buffer_list_size; ++i)\n    free (buffer_list[i]);\n  free (buffer_list);\n}",
      "lines": 108,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "open_input": {
      "start_point": [
        1044,
        0
      ],
      "end_point": [
        1100,
        1
      ],
      "content": "static void\nopen_input ()\n{\n  if (pipe_through_sort && dm->num_grps>0)\n    {\n      char tmp[INT_BUFSIZE_BOUND (size_t)*2+5];\n      char cmd[1024];\n      memset (cmd,0,sizeof (cmd));\n\n      if (input_header)\n        {\n          /* Set no-buffering, to ensure only the first line is consumed */\n          setbuf (stdin,NULL);\n          /* Read the header line from STDIN, and pass the rest of it to\n             the 'sort' child-process */\n          process_input_header (stdin);\n        }\n      strcat (cmd,\"LC_ALL=C sort \");\n      if (!case_sensitive)\n        strcat (cmd,\"-f \");\n#ifdef HAVE_STABLE_SORT\n      /* stable sort (-s) is needed to support first/last operations\n         (prevent sort from re-ordering lines which are not part of the group.\n         '-s' is not standard POSIX, but very commonly supported, including\n         on GNU coreutils, Busybox, FreeBSD, MacOSX */\n      strcat (cmd,\"-s \");\n#endif\n      if (in_tab != TAB_WHITESPACE)\n        {\n          /* If the delimiter is a single-quote character, use\n             double-quote to prevent shell quoting problems. */\n          const char qc = (in_tab=='\\'')?'\"':'\\'';\n          snprintf (tmp,sizeof (tmp),\"-t %c%c%c \",qc,in_tab,qc);\n          strcat (cmd,tmp);\n        }\n      for (size_t i = 0; i < dm->num_grps; ++i)\n        {\n          const size_t col_num = dm->grps[i].num;\n          snprintf (tmp,sizeof (tmp),\"-k%\"PRIuMAX\",%\"PRIuMAX\" \",\n                    (uintmax_t)col_num,(uintmax_t)col_num);\n          if (strlen (tmp)+strlen (cmd)+1 >= sizeof (cmd))\n            die (EXIT_FAILURE, 0,\n                   _(\"sort command too-long (please report this bug)\"));\n          strcat (cmd,tmp);\n        }\n\n      input_stream = popen (cmd,\"r\");\n      if (input_stream == NULL)\n        die (EXIT_FAILURE, 0, _(\"failed to run 'sort': popen failed\"));\n    }\n  else\n    {\n      /* without grouping, there's no need to sort */\n      input_stream = stdin;\n      pipe_through_sort = false;\n    }\n}",
      "lines": 57,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "close_input": {
      "start_point": [
        1102,
        0
      ],
      "end_point": [
        1117,
        1
      ],
      "content": "static void\nclose_input ()\n{\n  int i;\n\n  if (ferror (input_stream))\n    die (EXIT_FAILURE, errno, _(\"read error\"));\n\n  if (pipe_through_sort)\n    i = pclose (input_stream);\n  else\n    i = fclose (input_stream);\n\n  if (i != 0)\n    die (EXIT_FAILURE, errno, _(\"read error (on close)\"));\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        1119,
        0
      ],
      "end_point": [
        1314,
        1
      ],
      "content": "int main (int argc, char* argv[])\n{\n  int optc;\n  enum processing_mode premode = MODE_INVALID;\n  const char* premode_group_spec = NULL;\n\n  DECL_LONG_DOUBLE_ROUNDING\n  BEGIN_LONG_DOUBLE_ROUNDING ();\n\n  set_program_name (argv[0]);\n\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  init_blank_table ();\n  init_random ();\n\n  atexit (close_stdout);\n\n  while ((optc = getopt_long (argc, argv, short_options, long_options, NULL))\n         != -1)\n    {\n      switch (optc)\n        {\n        case 'F':\n          missing_field_filler = optarg;\n          break;\n\n        case 'f':\n          print_full_line = true;\n          break;\n\n        case 'g':\n          premode = MODE_GROUPBY;\n          premode_group_spec = optarg;\n          break;\n\n        case 'i':\n          case_sensitive = false;\n          break;\n\n        case 'z':\n          eolchar = 0;\n          break;\n\n        case INPUT_HEADER_OPTION:\n          input_header = true;\n          break;\n\n        case OUTPUT_HEADER_OPTION:\n          output_header = true;\n          break;\n\n        case 'H':\n          input_header = output_header = true;\n          break;\n\n\tcase 'R':\n\t  set_numeric_output_precision (optarg);\n\t  break;\n\n        case 's':\n          pipe_through_sort = true;\n          break;\n\n        case NO_STRICT_OPTION:\n          strict = false;\n          break;\n\n        case CUSTOM_FORMAT_OPTION:\n          set_numeric_printf_format (optarg);\n          break;\n\n        case REMOVE_NA_VALUES_OPTION:\n          remove_na_values = true;\n          break;\n\n        case 't':\n          if (optarg[0] == '\\0' || optarg[1] != '\\0')\n            die (EXIT_FAILURE, 0,\n                   _(\"the delimiter must be a single character\"));\n          in_tab = out_tab = optarg[0];\n          break;\n\n\tcase OUTPUT_DELIMITER_OPTION:\n          if (optarg[0] == '\\0' || optarg[1] != '\\0')\n            die (EXIT_FAILURE, 0,\n                   _(\"the delimiter must be a single character\"));\n\t  explicit_output_delimiter = (char)optarg[0];\n\t  break;\n\n        case 'W':\n          in_tab = TAB_WHITESPACE;\n          out_tab = '\\t';\n          break;\n\n        case UNDOC_PRINT_INF_OPTION:\n        case UNDOC_PRINT_NAN_OPTION:\n          field_op_print_empty_value ( (optc==UNDOC_PRINT_INF_OPTION)\n                                       ?OP_MAX:OP_MEAN );\n          exit (EXIT_SUCCESS);\n          break;\n\n        case UNDOC_PRINT_PROGNAME_OPTION:\n          printf (\"%s\", program_name);\n          exit (EXIT_SUCCESS);\n          break;\n\n        case UNDOC_RMDUP_TEST:\n          rmdup_initial_size = 1024;\n          break;\n\n        case_GETOPT_HELP_CHAR;\n\n        case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n\n        default:\n          usage (EXIT_FAILURE);\n        }\n    }\n\n  if (argc <= optind)\n    {\n      error (0, 0, _(\"missing operation specifiers\"));\n      usage (EXIT_FAILURE);\n    }\n\n  /* If --output-delimiter=X was used, override any previous output delimiter */\n  if (explicit_output_delimiter != -1)\n    out_tab = explicit_output_delimiter ;\n\n  /* The rest of the parameters are the operations */\n  if (premode == MODE_INVALID)\n    dm = datamash_ops_parse (argc - optind, (const char**)argv+optind);\n  else\n    dm = datamash_ops_parse_premode (premode, premode_group_spec,\n                            argc - optind, (const char**)argv+optind);\n\n  /* If using named-columns, but no input header - abort */\n  if (dm->header_required && !input_header)\n    die (EXIT_FAILURE, 0,\n           _(\"-H or --header-in must be used with named columns\"));\n\n  open_input ();\n  switch (dm->mode)                              /* LCOV_EXCL_BR_LINE */\n    {\n    case MODE_PER_LINE:\n      line_mode = true;\n      /* fall through */\n    case MODE_GROUPBY:\n      process_file ();\n      break;\n\n    case MODE_NOOP:\n      noop_file ();\n      break;\n\n    case MODE_TRANSPOSE:\n      transpose_file ();\n      break;\n\n    case MODE_REVERSE:\n      reverse_fields_in_file ();\n      break;\n\n    case MODE_REMOVE_DUPS:\n      remove_dups_in_file ();\n      break;\n\n    case MODE_CROSSTAB:\n      assert ( dm->num_grps== 2 ); /* LCOV_EXCL_LINE */\n      assert ( dm->num_ops == 1 ); /* LCOV_EXCL_LINE */\n      crosstab_mode = true;\n      crosstab = crosstab_init ();\n      process_file ();\n      crosstab_print (crosstab);\n      crosstab_free (crosstab);\n      break;\n\n    case MODE_TABULAR_CHECK:\n      tabular_check_file ();\n      break;\n\n    case MODE_INVALID:                           /* LCOV_EXCL_LINE */\n    default:                                     /* LCOV_EXCL_LINE */\n      internal_error (\"op mode\");                /* LCOV_EXCL_LINE */\n    }\n  free_column_headers ();\n  close_input ();\n  datamash_ops_free (dm);\n\n  END_LONG_DOUBLE_ROUNDING ();\n\n  return EXIT_SUCCESS;\n}",
      "lines": 196,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "datamash/datamash-1.3/src/die.h": {},
  "datamash/datamash-1.3/src/double-format.c": {
    "validate_double_format": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        82,
        1
      ],
      "content": "char*\nvalidate_double_format (char const *fmt)\n{\n  size_t i;\n  size_t len;\n  char *out;\n\n  len = strlen (fmt);\n\n  /* extra space for NUL and 'L' printf-modifier */\n  out = xmalloc (len+2);\n\n  for (i = 0; ! (fmt[i] == '%' && fmt[i + 1] != '%'); i += (fmt[i] == '%') + 1)\n    if (!fmt[i])\n      die (EXIT_FAILURE, 0,\n\t   _(\"format %s has no %% directive\"), quote (fmt));\n\n  i++;\n  i += strspn (fmt + i, \"-+#0 '\");\n  i += strspn (fmt + i, \"0123456789\");\n  if (fmt[i] == '.')\n    {\n      i++;\n      i += strspn (fmt + i, \"0123456789\");\n    }\n\n  if (!fmt[i])\n    die (EXIT_FAILURE, 0,\n         _(\"format %s missing valid type after '%%'\"), quote (fmt));\n\n  if (! strchr (\"efgaEFGA\", fmt[i]))\n    die (EXIT_FAILURE, 0,\n         _(\"format %s has unknown/invalid type %%%c directive\"),\n\t quote (fmt), fmt[i]);\n\n  /* Copy characters until the type character, add 'L', then the type,\n     then the rest of the format string. */\n  memcpy (out, fmt, i);\n  out[i] = 'L';\n  out[i+1] = fmt[i];\n  memcpy (out+i+2, fmt+i+1, len-i);\n  out[len+1] = '\\0';\n\n  for (i++; fmt[i] ; i += (fmt[i] == '%') + 1)\n    if (fmt[i] == '%' && fmt[i + 1] != '%')\n      die (EXIT_FAILURE, 0, _(\"format %s has too many %% directives\"),\n           quote (fmt));\n\n  return out;\n}",
      "lines": 50,
      "depth": 11,
      "decorators": [
        "char",
        "*\nvalidate_double_format (char const *fmt)",
        "*"
      ]
    }
  },
  "datamash/datamash-1.3/src/double-format.h": {},
  "datamash/datamash-1.3/src/field-ops.c": {
    "field_op_add_value": {
      "start_point": [
        165,
        0
      ],
      "end_point": [
        176,
        1
      ],
      "content": "static void\nfield_op_add_value (struct fieldop *op, long double val)\n{\n  if (op->num_values >= op->alloc_values)\n    {\n      op->alloc_values += VALUES_BATCH_INCREMENT;\n      op->values = xnrealloc (op->values, op->alloc_values,\n                              sizeof (long double));\n    }\n  op->values[op->num_values] = val;\n  op->num_values++;\n}",
      "lines": 12,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "field_op_reserve_out_buf": {
      "start_point": [
        178,
        0
      ],
      "end_point": [
        186,
        1
      ],
      "content": "static void\nfield_op_reserve_out_buf (struct fieldop *op, const size_t minsize)\n{\n  if (op->out_buf_alloc < minsize)\n    {\n      op->out_buf = xrealloc (op->out_buf, minsize);\n      op->out_buf_alloc = minsize;\n    }\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "field_op_to_hex": {
      "start_point": [
        189,
        0
      ],
      "end_point": [
        210,
        1
      ],
      "content": "static void\nfield_op_to_hex ( struct fieldop* op, const char *buffer, const size_t inlen )\n{\n  static const char hex_digits[] =\n  {\n    '0', '1', '2', '3', '4', '5', '6', '7',\n    '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'\n  };\n  size_t len = inlen*2+1;\n  const char* inp = buffer;\n  field_op_reserve_out_buf (op, len);\n  char* ptr = op->out_buf;\n  for (size_t i = 0 ; i < inlen; ++i)\n   {\n     *ptr = hex_digits[ ((*inp)>>4) & 0xf ] ;\n     ++ptr;\n     *ptr = hex_digits[  (*inp)     & 0xf ] ;\n     ++ptr;\n     ++inp;\n   }\n  *ptr = 0 ;\n}",
      "lines": 22,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "field_op_add_string": {
      "start_point": [
        213,
        0
      ],
      "end_point": [
        226,
        1
      ],
      "content": "void\nfield_op_add_string (struct fieldop *op, const char* str, size_t slen)\n{\n  if (op->str_buf_used + slen+1 >= op->str_buf_alloc)\n    {\n      op->str_buf_alloc += MAX (VALUES_BATCH_INCREMENT,slen+1);\n      op->str_buf = xrealloc (op->str_buf, op->str_buf_alloc);\n    }\n\n  /* Copy the string to the buffer */\n  memcpy (op->str_buf + op->str_buf_used, str, slen);\n  *(op->str_buf + op->str_buf_used + slen ) = 0;\n  op->str_buf_used += slen + 1 ;\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "field_op_replace_string": {
      "start_point": [
        230,
        0
      ],
      "end_point": [
        243,
        1
      ],
      "content": "void\nfield_op_replace_string (struct fieldop *op, const char* str, size_t slen)\n{\n  if (slen+1 >= op->str_buf_alloc)\n    {\n      op->str_buf_alloc += MAX (VALUES_BATCH_INCREMENT,slen+1);\n      op->str_buf = xrealloc (op->str_buf, op->str_buf_alloc);\n    }\n\n  /* Copy the string to the buffer */\n  memcpy (op->str_buf, str, slen);\n  *(op->str_buf + slen ) = 0;\n  op->str_buf_used = slen + 1 ;\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "field_op_get_string_ptrs": {
      "start_point": [
        254,
        0
      ],
      "end_point": [
        279,
        1
      ],
      "content": "static const char **\nfield_op_get_string_ptrs ( struct fieldop *op, bool sort,\n                           bool sort_case_sensitive )\n{\n  const char **ptrs = xnmalloc (op->count+1, sizeof (char*));\n  char *p = op->str_buf;\n  const char* pend = op->str_buf + op->str_buf_used;\n  size_t idx=0;\n  while (p < pend)\n    {\n      ptrs[idx++] = p;\n      while ( p<pend && *p != '\\0' )\n        ++p;\n      ++p;\n    }\n  ptrs[idx] = 0;\n\n  if (sort)\n    {\n      /* Sort the string pointers */\n      qsort ( ptrs, op->count, sizeof (char*), sort_case_sensitive\n                                            ?cmpstringp\n                                            :cmpstringp_nocase);\n    }\n  return ptrs;\n}",
      "lines": 26,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "**\nfield_op_get_string_ptrs ( struct fieldop *op, bool sort,\n                           bool sort_case_sensitive )",
        "*",
        "*\nfield_op_get_string_ptrs ( struct fieldop *op, bool sort,\n                           bool sort_case_sensitive )",
        "*"
      ]
    },
    "field_op_sort_values": {
      "start_point": [
        282,
        0
      ],
      "end_point": [
        286,
        1
      ],
      "content": "static void\nfield_op_sort_values (struct fieldop *op)\n{\n  qsortfl (op->values, op->num_values);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "field_op_init": {
      "start_point": [
        288,
        0
      ],
      "end_point": [
        314,
        1
      ],
      "content": "void\nfield_op_init (struct fieldop* /*out*/ op,\n               enum field_operation oper,\n               bool by_name, size_t num, const char* name)\n{\n  assert (op != NULL); /* LCOV_EXCL_LINE */\n  memset (op, 0, sizeof *op);\n\n  op->op = oper;\n  op->acc_type = operations[oper].acc_type;\n  op->res_type = operations[oper].res_type;\n  op->numeric = (op->acc_type == NUMERIC_SCALAR\n                 || op->acc_type == NUMERIC_VECTOR);\n  op->auto_first = operations[oper].auto_first;\n  op->slave = false;\n  op->slave_op = NULL;\n\n  op->field = num;\n  op->field_by_name = by_name;\n  op->field_name = (by_name)?xstrdup (name):NULL;\n  op->first = true;\n  if (op->res_type == STRING_RESULT)\n    {\n      op->out_buf_alloc = 1024;\n      op->out_buf = xmalloc (op->out_buf_alloc);\n    }\n}",
      "lines": 27,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "verify_slave_num_values": {
      "start_point": [
        318,
        0
      ],
      "end_point": [
        329,
        1
      ],
      "content": "static void\nverify_slave_num_values (const struct fieldop *op)\n{\n  assert (op && !op->slave && op->slave_op);     /* LCOV_EXCL_LINE */\n\n  if (op->num_values != op->slave_op->num_values)\n    die (EXIT_FAILURE, 0, _(\"input error for operation %s: \\\nfields %\"PRIuMAX\",%\"PRIuMAX\" have different number of items\"),\n                            quote (get_field_operation_name (op->op)),\n                            (uintmax_t)op->slave_op->field,\n                            (uintmax_t)op->field);\n}",
      "lines": 12,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "field_op_collect": {
      "start_point": [
        332,
        0
      ],
      "end_point": [
        568,
        1
      ],
      "content": "enum FIELD_OP_COLLECT_RESULT\nfield_op_collect (struct fieldop *op,\n                  const char* str, size_t slen)\n{\n  char *endptr=NULL;\n  long double num_value = 0;\n#ifdef HAVE_BROKEN_STRTOLD\n  char tmpbuf[512];\n#endif\n  enum FIELD_OP_COLLECT_RESULT rc = FLOCR_OK;\n\n  assert (str != NULL); /* LCOV_EXCL_LINE */\n\n  if (remove_na_values && is_na (str,slen))\n    return FLOCR_OK_SKIPPED;\n\n  if (op->numeric)\n    {\n      errno = 0;\n#ifdef HAVE_BROKEN_STRTOLD\n      /* On Cygwin, strtold doesn't stop at a tab character,\n         and returns invalid value.\n         Make a copy of the input buffer and NULL-terminate it */\n      if (slen >= sizeof (tmpbuf))\n        die (EXIT_FAILURE, 0,\n                \"internal error: input field too long (%zu)\", slen);\n      memcpy (tmpbuf,str,slen);\n      tmpbuf[slen]=0;\n      num_value = strtold (tmpbuf, &endptr);\n      if (errno==ERANGE || endptr==tmpbuf || endptr!=(tmpbuf+slen))\n        return FLOCR_INVALID_NUMBER;\n#else\n      if (slen == 0)\n        return FLOCR_INVALID_NUMBER;\n      num_value = strtold (str, &endptr);\n      if (errno==ERANGE || endptr==str || endptr!=(str+slen))\n        return FLOCR_INVALID_NUMBER;\n#endif\n    }\n\n  op->count++;\n\n  if (op->first && op->auto_first && op->numeric)\n      op->value = num_value;\n\n  switch (op->op)                                /* LCOV_EXCL_BR_LINE */\n    {\n    case OP_SUM:\n    case OP_MEAN:\n      op->value += num_value;\n      break;\n\n    case OP_COUNT:\n      op->value++;\n      break;\n\n    case OP_MIN:\n      if (num_value < op->value)\n        {\n          op->value = num_value;\n          rc = FLOCR_OK_KEEP_LINE;\n        }\n      break;\n\n    case OP_MAX:\n      if (num_value > op->value)\n        {\n          op->value = num_value;\n          rc = FLOCR_OK_KEEP_LINE;\n        }\n      break;\n\n    case OP_ABSMIN:\n      if (fabsl (num_value) < fabsl (op->value))\n        {\n          op->value = num_value;\n          rc = FLOCR_OK_KEEP_LINE;\n        }\n      break;\n\n    case OP_ABSMAX:\n      if (fabsl (num_value) > fabsl (op->value))\n        {\n          op->value = num_value;\n          rc = FLOCR_OK_KEEP_LINE;\n        }\n      break;\n\n    case OP_RANGE:\n      /* Upon the first value, we store it twice\n         (once for min, once for max).\n         For subsequence values, we update the min/max entries directly. */\n      if (op->first)\n        {\n          field_op_add_value (op, num_value);\n          field_op_add_value (op, num_value);\n        }\n      else\n        {\n          if (num_value < op->values[0])\n            op->values[0] = num_value;\n          if (num_value > op->values[1])\n            op->values[1] = num_value;\n        }\n      break;\n\n    case OP_FIRST:\n      if (op->first)\n        {\n          field_op_replace_string (op, str, slen);\n          rc = FLOCR_OK_KEEP_LINE;\n        }\n      break;\n\n    case OP_LAST:\n      /* Replace the 'current' string with the latest one */\n      field_op_replace_string (op, str, slen);\n      rc = FLOCR_OK_KEEP_LINE;\n      break;\n\n    case OP_DEBASE64:\n      /* Base64 decoding is a special case: we decode during collection,\n         and report any errors back to the caller. */\n      {\n        /* safe to assume decoded base64 is never larger than encoded base64 */\n        size_t decoded_size = slen;\n        field_op_reserve_out_buf (op, decoded_size);\n        if (!base64_decode ( str, slen, op->out_buf, &decoded_size ))\n          return FLOCR_INVALID_BASE64;\n        op->out_buf[decoded_size]=0;\n      }\n      break;\n\n    case OP_BASE64:\n    case OP_MD5:\n    case OP_SHA1:\n    case OP_SHA256:\n    case OP_SHA512:\n      /* Replace the 'current' string with the latest one */\n      field_op_replace_string (op, str, slen);\n      break;\n\n    case OP_RAND:\n      {\n        /* Reservoir sampling,\n           With a simpler case were \"k=1\" */\n        unsigned long i = random ()%op->count;\n        if (op->first || i==0)\n          {\n            field_op_replace_string (op, str, slen);\n            rc = FLOCR_OK_KEEP_LINE;\n          }\n      }\n      break;\n\n    case OP_MEDIAN:\n    case OP_QUARTILE_1:\n    case OP_QUARTILE_3:\n    case OP_IQR:\n    case OP_PERCENTILE:\n    case OP_PSTDEV:\n    case OP_SSTDEV:\n    case OP_PVARIANCE:\n    case OP_SVARIANCE:\n    case OP_MAD:\n    case OP_MADRAW:\n    case OP_S_SKEWNESS:\n    case OP_P_SKEWNESS:\n    case OP_S_EXCESS_KURTOSIS:\n    case OP_P_EXCESS_KURTOSIS:\n    case OP_JARQUE_BERA:\n    case OP_DP_OMNIBUS:\n    case OP_MODE:\n    case OP_ANTIMODE:\n    case OP_P_COVARIANCE:\n    case OP_S_COVARIANCE:\n    case OP_P_PEARSON_COR:\n    case OP_S_PEARSON_COR:\n    case OP_TRIMMED_MEAN:\n      field_op_add_value (op, num_value);\n      break;\n\n    case OP_UNIQUE:\n    case OP_COLLAPSE:\n    case OP_COUNT_UNIQUE:\n      field_op_add_string (op, str, slen);\n      break;\n\n    case OP_BIN_BUCKETS:\n      {\n        const long double val = num_value / op->params.bin_bucket_size;\n        modfl (val, & op->value);\n        /* signbit will take care of negative-zero as well. */\n        if (signbit (op->value))\n          --op->value;\n        op->value *= op->params.bin_bucket_size;\n      }\n      break;\n\n    case OP_STRBIN:\n      op->value = hash_pjw_bare (str,slen) % (op->params.strbin_bucket_size);\n      break;\n\n    case OP_FLOOR:\n      op->value = pos_zero (floorl (num_value));\n      break;\n\n    case OP_CEIL:\n      op->value = pos_zero (ceill (num_value));\n      break;\n\n    case OP_ROUND:\n      op->value = pos_zero (roundl (num_value));\n      break;\n\n    case OP_TRUNCATE:\n      modfl (num_value, &op->value);\n      op->value = pos_zero (op->value);\n      break;\n\n    case OP_FRACTION:\n      {\n        long double dummy;\n        op->value = pos_zero (modfl (num_value, &dummy));\n      };\n      break;\n\n    case OP_INVALID:                 /* LCOV_EXCL_LINE */\n    default:                         /* LCOV_EXCL_LINE */\n      /* Should never happen */\n      internal_error (\"bad op\");     /* LCOV_EXCL_LINE */\n    }\n\n  op->first = false;\n\n  return rc;\n}",
      "lines": 237,
      "depth": 14,
      "decorators": [
        "enum FIELD_OP_COLLECT_RESULT",
        "enum",
        "FIELD_OP_COLLECT_RESULT"
      ]
    },
    "unique_value": {
      "start_point": [
        572,
        0
      ],
      "end_point": [
        605,
        1
      ],
      "content": "static void\nunique_value ( struct fieldop *op, bool case_sensitive )\n{\n  const char *last_str;\n  char *pos;\n\n  const char **ptrs = field_op_get_string_ptrs (op, true, case_sensitive);\n\n  /* Uniquify them */\n  field_op_reserve_out_buf (op, op->str_buf_used);\n  pos = op->out_buf ;\n\n  /* Copy the first string */\n  last_str = ptrs[0];\n  strcpy (pos, ptrs[0]);\n  pos += strlen (ptrs[0]);\n\n  /* Copy the following strings, if they are different from the previous one */\n  for (size_t i = 1; i < op->count; ++i)\n    {\n      const char *newstr = ptrs[i];\n\n      if ((case_sensitive && (!STREQ (newstr, last_str)))\n          || (!case_sensitive && (strcasecmp (newstr, last_str)!=0)))\n        {\n          *pos++ = collapse_separator ;\n          strcpy (pos, newstr);\n          pos += strlen (newstr);\n        }\n      last_str = newstr;\n    }\n\n  free (ptrs);\n}",
      "lines": 34,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "count_unique_values": {
      "start_point": [
        608,
        0
      ],
      "end_point": [
        636,
        1
      ],
      "content": "size_t\ncount_unique_values ( struct fieldop *op, bool case_sensitive )\n{\n  const char *last_str, **cur_str;\n  size_t count = 1 ;\n\n  const char **ptrs = field_op_get_string_ptrs (op, true, case_sensitive);\n\n  /* Copy the first string */\n  cur_str = ptrs;\n  last_str = *cur_str;\n  ++cur_str;\n\n  /* Copy the following strings, if they are different from the previous one */\n  while ( *cur_str != 0 )\n    {\n      if ((case_sensitive && (!STREQ (*cur_str, last_str)))\n          || (!case_sensitive && (strcasecmp (*cur_str, last_str)!=0)))\n        {\n          ++count;\n        }\n      last_str = *cur_str;\n      ++cur_str;\n    }\n\n  free (ptrs);\n\n  return count;\n}",
      "lines": 29,
      "depth": 15,
      "decorators": [
        "size_t"
      ]
    },
    "collapse_value": {
      "start_point": [
        640,
        0
      ],
      "end_point": [
        652,
        1
      ],
      "content": "void\ncollapse_value ( struct fieldop *op )\n{\n  /* Copy the string buffer as-is */\n  field_op_reserve_out_buf (op, op->str_buf_used);\n  char *buf = op->out_buf;\n  memcpy (buf, op->str_buf, op->str_buf_used);\n\n  /* convert every NUL to comma, except for the last one */\n  for (size_t i=0; i < op->str_buf_used-1 ; i++)\n      if (buf[i] == 0)\n        buf[i] = collapse_separator ;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "field_op_summarize_empty": {
      "start_point": [
        658,
        0
      ],
      "end_point": [
        748,
        1
      ],
      "content": "static void\nfield_op_summarize_empty (struct fieldop *op)\n{\n  long double numeric_result = 0 ;\n\n  switch (op->op)                                /* LCOV_EXCL_BR_LINE */\n    {\n    case OP_MEAN:\n    case OP_S_SKEWNESS:\n    case OP_P_SKEWNESS:\n    case OP_S_EXCESS_KURTOSIS:\n    case OP_P_EXCESS_KURTOSIS:\n    case OP_JARQUE_BERA:\n    case OP_DP_OMNIBUS:\n    case OP_MEDIAN:\n    case OP_QUARTILE_1:\n    case OP_QUARTILE_3:\n    case OP_IQR:\n    case OP_PERCENTILE:\n    case OP_MAD:\n    case OP_MADRAW:\n    case OP_PSTDEV:\n    case OP_SSTDEV:\n    case OP_PVARIANCE:\n    case OP_SVARIANCE:\n    case OP_MODE:\n    case OP_ANTIMODE:\n    case OP_P_COVARIANCE:\n    case OP_S_COVARIANCE:\n    case OP_P_PEARSON_COR:\n    case OP_S_PEARSON_COR:\n    case OP_BIN_BUCKETS:\n    case OP_STRBIN:\n    case OP_FLOOR:\n    case OP_CEIL:\n    case OP_ROUND:\n    case OP_TRUNCATE:\n    case OP_FRACTION:\n    case OP_RANGE:\n    case OP_TRIMMED_MEAN:\n      numeric_result = nanl (\"\");\n      break;\n\n    case OP_SUM:\n    case OP_COUNT:\n    case OP_COUNT_UNIQUE:\n      numeric_result = 0;\n      break;\n\n    case OP_MIN:\n    case OP_ABSMIN:\n      numeric_result = -HUGE_VALL;\n      break;\n\n    case OP_MAX:\n    case OP_ABSMAX:\n      numeric_result = HUGE_VALL;\n      break;\n\n    case OP_FIRST:\n    case OP_LAST:\n    case OP_RAND:\n      field_op_reserve_out_buf (op, 4);\n      strcpy (op->out_buf, \"N/A\");\n      break;\n\n    case OP_UNIQUE:\n    case OP_COLLAPSE:\n    case OP_BASE64:\n    case OP_DEBASE64:\n    case OP_MD5:\n    case OP_SHA1:\n    case OP_SHA256:\n    case OP_SHA512:\n      field_op_reserve_out_buf (op, 1);\n      strcpy (op->out_buf, \"\");\n      break;\n\n    case OP_INVALID:                 /* LCOV_EXCL_LINE */\n    default:                         /* LCOV_EXCL_LINE */\n      /* Should never happen */\n      internal_error (\"bad op\");     /* LCOV_EXCL_LINE */\n    }\n\n  if (op->res_type==NUMERIC_RESULT)\n    {\n      field_op_reserve_out_buf (op, numeric_output_bufsize);\n      snprintf (op->out_buf, op->out_buf_alloc,\n                numeric_output_format, numeric_result);\n    }\n}",
      "lines": 91,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "field_op_summarize": {
      "start_point": [
        752,
        0
      ],
      "end_point": [
        976,
        1
      ],
      "content": "void\nfield_op_summarize (struct fieldop *op)\n{\n  long double numeric_result = 0 ;\n  char tmpbuf[64]; /* 64 bytes - enough to hold sha512 */\n\n  /* In case of no values, each operation returns a specific result.\n     'no values' can happen with '--narm' and input of all N/As. */\n  if (op->count==0)\n    {\n      field_op_summarize_empty (op);\n      return ;\n    }\n\n  switch (op->op)                                /* LCOV_EXCL_BR_LINE */\n    {\n    case OP_MEAN:\n      numeric_result = op->value / op->count;\n      break;\n\n    case OP_SUM:\n    case OP_COUNT:\n    case OP_MIN:\n    case OP_MAX:\n    case OP_ABSMIN:\n    case OP_ABSMAX:\n    case OP_BIN_BUCKETS:\n    case OP_STRBIN:\n    case OP_FLOOR:\n    case OP_CEIL:\n    case OP_ROUND:\n    case OP_TRUNCATE:\n    case OP_FRACTION:\n      /* no summarization for these operations, just print the value */\n      numeric_result = op->value;\n      break;\n\n    case OP_FIRST:\n    case OP_LAST:\n    case OP_RAND:\n      /* Only one string is returned in the buffer, return it */\n      field_op_reserve_out_buf (op, op->str_buf_used);\n      memcpy (op->out_buf, op->str_buf, op->str_buf_used);\n      break;\n\n    case OP_RANGE:\n      numeric_result = op->values[1] - op->values[0];\n      break;\n\n    case OP_MEDIAN:\n      field_op_sort_values (op);\n      numeric_result = median_value ( op->values, op->num_values );\n      break;\n\n    case OP_QUARTILE_1:\n      field_op_sort_values (op);\n      numeric_result = quartile1_value ( op->values, op->num_values );\n      break;\n\n    case OP_QUARTILE_3:\n      field_op_sort_values (op);\n      numeric_result = quartile3_value ( op->values, op->num_values );\n      break;\n\n    case OP_IQR:\n      field_op_sort_values (op);\n      numeric_result = quartile3_value ( op->values, op->num_values )\n                       - quartile1_value ( op->values, op->num_values );\n      break;\n\n    case OP_PERCENTILE:\n      field_op_sort_values (op);\n      numeric_result = percentile_value ( op->values, op->num_values,\n                                          op->params.percentile / 100.0 );\n      break;\n\n    case OP_TRIMMED_MEAN:\n      field_op_sort_values (op);\n      numeric_result = trimmed_mean_value ( op->values, op->num_values,\n\t\t\t\t\t    op->params.trimmed_mean);\n      break;\n\n    case OP_PSTDEV:\n      numeric_result = stdev_value ( op->values, op->num_values, DF_POPULATION);\n      break;\n\n    case OP_SSTDEV:\n      numeric_result = stdev_value ( op->values, op->num_values, DF_SAMPLE);\n      break;\n\n    case OP_PVARIANCE:\n      numeric_result = variance_value ( op->values, op->num_values,\n                                        DF_POPULATION);\n      break;\n\n    case OP_SVARIANCE:\n      numeric_result = variance_value ( op->values, op->num_values,\n                                        DF_SAMPLE);\n      break;\n\n    case OP_MAD:\n      field_op_sort_values (op);\n      numeric_result = mad_value ( op->values, op->num_values, 1.4826 );\n      break;\n\n    case OP_MADRAW:\n      field_op_sort_values (op);\n      numeric_result = mad_value ( op->values, op->num_values, 1.0 );\n      break;\n\n    case OP_S_SKEWNESS:\n      numeric_result = skewness_value ( op->values, op->num_values,\n                                        DF_SAMPLE );\n      break;\n\n    case OP_P_SKEWNESS:\n      numeric_result = skewness_value ( op->values, op->num_values,\n                                        DF_POPULATION );\n      break;\n\n    case OP_S_EXCESS_KURTOSIS:\n      numeric_result = excess_kurtosis_value ( op->values, op->num_values,\n                                               DF_SAMPLE );\n      break;\n\n    case OP_P_EXCESS_KURTOSIS:\n      numeric_result = excess_kurtosis_value ( op->values, op->num_values,\n                                               DF_POPULATION );\n      break;\n\n    case OP_JARQUE_BERA:\n      numeric_result = jarque_bera_pvalue ( op->values, op->num_values );\n      break;\n\n    case OP_DP_OMNIBUS:\n      numeric_result = dagostino_pearson_omnibus_pvalue ( op->values,\n                                                          op->num_values );\n      break;\n\n    case OP_P_COVARIANCE:\n    case OP_S_COVARIANCE:\n      assert (!op->slave);                       /* LCOV_EXCL_LINE */\n      assert (op->slave_op);                     /* LCOV_EXCL_LINE */\n      verify_slave_num_values (op);\n      numeric_result = covariance_value (op->values, op->slave_op->values,\n                                         op->num_values,\n                                         (op->op==OP_P_COVARIANCE)?\n                                                DF_POPULATION:DF_SAMPLE );\n      break;\n\n    case OP_P_PEARSON_COR:\n    case OP_S_PEARSON_COR:\n      assert (!op->slave);                       /* LCOV_EXCL_LINE */\n      assert (op->slave_op);                     /* LCOV_EXCL_LINE */\n      verify_slave_num_values (op);\n      numeric_result = pearson_corr_value (op->values, op->slave_op->values,\n                                           op->num_values,\n                                           (op->op==OP_P_PEARSON_COR)?\n                                                DF_POPULATION:DF_SAMPLE);\n      break;\n\n    case OP_MODE:\n    case OP_ANTIMODE:\n      field_op_sort_values (op);\n      numeric_result = mode_value ( op->values, op->num_values,\n                                    (op->op==OP_MODE)?MODE:ANTIMODE);\n      break;\n\n    case OP_UNIQUE:\n      unique_value (op, case_sensitive);\n      break;\n\n    case OP_COLLAPSE:\n      collapse_value (op);\n      break;\n\n    case OP_COUNT_UNIQUE:\n      numeric_result = count_unique_values (op,case_sensitive);\n      break;\n\n    case OP_BASE64:\n      field_op_reserve_out_buf (op, BASE64_LENGTH (op->str_buf_used-1)+1 ) ;\n      base64_encode ( op->str_buf, op->str_buf_used-1,\n      op->out_buf, BASE64_LENGTH (op->str_buf_used-1)+1 );\n      break;\n\n    case OP_DEBASE64:\n      /* Decoding base64 is a special case: decoding (and error checking) was\n         done in field_op_collect.  op->out_buf already contains the decoded\n         value. */\n      break;\n\n    case OP_MD5:\n      md5_buffer (op->str_buf, op->str_buf_used-1, tmpbuf);\n      field_op_to_hex (op, tmpbuf, 16);\n      break;\n\n    case OP_SHA1:\n      sha1_buffer (op->str_buf, op->str_buf_used-1, tmpbuf);\n      field_op_to_hex (op, tmpbuf, 20);\n      break;\n\n    case OP_SHA256:\n      sha256_buffer (op->str_buf, op->str_buf_used-1, tmpbuf);\n      field_op_to_hex (op, tmpbuf, 32);\n      break;\n\n    case OP_SHA512:\n      sha512_buffer (op->str_buf, op->str_buf_used-1, tmpbuf);\n      field_op_to_hex (op, tmpbuf, 64);\n      break;\n\n    case OP_INVALID:                 /* LCOV_EXCL_LINE */\n    default:                         /* LCOV_EXCL_LINE */\n      /* Should never happen */\n      internal_error (\"bad op\");     /* LCOV_EXCL_LINE */\n    }\n\n  if (op->res_type==NUMERIC_RESULT)\n    {\n      field_op_reserve_out_buf (op, numeric_output_bufsize);\n      snprintf (op->out_buf, op->out_buf_alloc,\n                numeric_output_format, numeric_result);\n    }\n}",
      "lines": 225,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "field_op_reset": {
      "start_point": [
        979,
        0
      ],
      "end_point": [
        989,
        1
      ],
      "content": "void\nfield_op_reset (struct fieldop *op)\n{\n  op->first = true;\n  op->count = 0 ;\n  op->value = 0;\n  op->num_values = 0 ;\n  op->str_buf_used = 0;\n  op->out_buf_used = 0;\n  /* note: op->str_buf and op->str_alloc are not free'd, and reused */\n}",
      "lines": 11,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "field_op_free": {
      "start_point": [
        991,
        0
      ],
      "end_point": [
        1010,
        1
      ],
      "content": "void\nfield_op_free (struct fieldop* op)\n{\n  free (op->values);\n  op->num_values = 0 ;\n  op->alloc_values = 0;\n\n  free (op->str_buf);\n  op->str_buf = NULL;\n  op->str_buf_alloc = 0;\n  op->str_buf_used = 0;\n\n  free (op->out_buf);\n  op->out_buf = NULL;\n  op->out_buf_alloc = 0;\n  op->out_buf_used = 0;\n\n  free (op->field_name);\n  op->field_name = NULL;\n}",
      "lines": 20,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "mix": {
      "start_point": [
        1015,
        0
      ],
      "end_point": [
        1028,
        1
      ],
      "content": "static unsigned long\nmix (unsigned long a, unsigned long b, unsigned long c)\n{\n    a=a-b;  a=a-c;  a=a^(c >> 13);\n    b=b-c;  b=b-a;  b=b^(a << 8);\n    c=c-a;  c=c-b;  c=c^(b >> 13);\n    a=a-b;  a=a-c;  a=a^(c >> 12);\n    b=b-c;  b=b-a;  b=b^(a << 16);\n    c=c-a;  c=c-b;  c=c^(b >> 5);\n    a=a-b;  a=a-c;  a=a^(c >> 3);\n    b=b-c;  b=b-a;  b=b^(a << 10);\n    c=c-a;  c=c-b;  c=c^(b >> 15);\n    return c;\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "unsigned long",
        "unsigned",
        "long"
      ]
    },
    "init_random": {
      "start_point": [
        1030,
        0
      ],
      "end_point": [
        1035,
        1
      ],
      "content": "void\ninit_random (void)\n{\n  unsigned long seed = mix (clock (), time (NULL), getpid ());\n  srandom (seed);\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "field_op_collect_result_name": {
      "start_point": [
        1037,
        0
      ],
      "end_point": [
        1053,
        1
      ],
      "content": "const char*\nfield_op_collect_result_name (const enum FIELD_OP_COLLECT_RESULT flocr)\n{\n  switch (flocr)                                 /* LCOV_EXCL_BR_LINE */\n   {\n   case FLOCR_INVALID_NUMBER:\n     return _(\"invalid numeric value\");\n   case FLOCR_INVALID_BASE64:\n     return _(\"invalid base64 value\");\n   case FLOCR_OK:                                /* LCOV_EXCL_LINE */\n   case FLOCR_OK_KEEP_LINE:                      /* LCOV_EXCL_LINE */\n   case FLOCR_OK_SKIPPED:                        /* LCOV_EXCL_LINE */\n   default:\n     internal_error (\"op_collect_result_name\");  /* LCOV_EXCL_LINE */\n     return \"\";                                  /* LCOV_EXCL_LINE */\n   }\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nfield_op_collect_result_name (const enum FIELD_OP_COLLECT_RESULT flocr)",
        "*"
      ]
    },
    "field_op_print_empty_value": {
      "start_point": [
        1055,
        0
      ],
      "end_point": [
        1064,
        1
      ],
      "content": "void\nfield_op_print_empty_value (enum field_operation mode)\n{\n  struct fieldop op;\n  memset (&op, 0, sizeof op);\n  op.op = mode;\n  op.res_type = NUMERIC_RESULT;\n  field_op_summarize_empty (&op);\n  fputs (op.out_buf, stdout);\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "datamash/datamash-1.3/src/field-ops.h": {},
  "datamash/datamash-1.3/src/op-defs.c": {
    "get_field_operation": {
      "start_point": [
        116,
        0
      ],
      "end_point": [
        130,
        1
      ],
      "content": "enum field_operation\nget_field_operation (const char* s, enum processing_mode* /*out*/ mode)\n{\n  const struct field_operation_definition* fod = field_operations;\n  while (fod->name) {\n    if (strcasecmp (fod->name, s)==0)\n      {\n        if (mode)\n          *mode = fod->mode;\n        return fod->op;\n      }\n    ++fod;\n  }\n  return OP_INVALID;\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "enum field_operation",
        "enum",
        "field_operation"
      ]
    },
    "get_field_operation_name": {
      "start_point": [
        132,
        0
      ],
      "end_point": [
        144,
        1
      ],
      "content": "const char* _GL_ATTRIBUTE_PURE\nget_field_operation_name (enum field_operation op)\n{\n  const struct field_operation_definition* fod = field_operations;\n  while (fod->name)                              /* LCOV_EXCL_BR_LINE */\n    {\n      if (fod->op == op)\n        return fod->name;\n      ++fod;\n    }\n  internal_error (\"invalid op value\");            /* LCOV_EXCL_LINE */\n  return NULL;                                    /* LCOV_EXCL_LINE */\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "const",
        "const",
        "char",
        "* _GL_ATTRIBUTE_PURE\nget_field_operation_name (enum field_operation op)",
        "*",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "get_processing_mode": {
      "start_point": [
        146,
        0
      ],
      "end_point": [
        157,
        1
      ],
      "content": "enum processing_mode _GL_ATTRIBUTE_PURE\nget_processing_mode (const char* s)\n{\n  const struct processing_mode_definition* pmd = processing_modes;\n  while (pmd->name)\n    {\n      if (strcasecmp (pmd->name, s)==0)\n        return pmd->mode;\n      ++pmd;\n    }\n  return MODE_INVALID;\n}",
      "lines": 12,
      "depth": 11,
      "decorators": [
        "enum processing_mode",
        "enum",
        "processing_mode",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "get_processing_mode_name": {
      "start_point": [
        159,
        0
      ],
      "end_point": [
        171,
        1
      ],
      "content": "const char* _GL_ATTRIBUTE_PURE\nget_processing_mode_name (enum processing_mode m)\n{\n  const struct processing_mode_definition* pmd = processing_modes;\n  while (pmd->name)                               /* LCOV_EXCL_BR_LINE */\n    {\n      if (pmd->mode == m)\n        return pmd->name;\n      ++pmd;\n    }\n  internal_error (\"invalid mode value\");          /* LCOV_EXCL_LINE */\n  return NULL;                                    /* LCOV_EXCL_LINE */\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "const",
        "const",
        "char",
        "* _GL_ATTRIBUTE_PURE\nget_processing_mode_name (enum processing_mode m)",
        "*",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    }
  },
  "datamash/datamash-1.3/src/op-defs.h": {},
  "datamash/datamash-1.3/src/op-parser.c": {
    "_alloc_ops": {
      "start_point": [
        68,
        0
      ],
      "end_point": [
        81,
        1
      ],
      "content": "static void\n_alloc_ops ()\n{\n  dm = XZALLOC (struct datamash_ops);\n  dm->mode = MODE_INVALID;\n\n  _fields = NULL;\n  _fields_alloc = 0;\n  _fields_used = 0;\n\n  _params = NULL;\n  _params_alloc = 0;\n  _params_used = 0;\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "reset_parsed_operation": {
      "start_point": [
        83,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "static void\nreset_parsed_operation ()\n{\n  fop = OP_INVALID;\n\n  for (size_t i=0; i<_fields_used; ++i)\n    free (_fields[i].name);\n\n  _fields_used = 0;\n  _params_used = 0;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "alloc_next_field": {
      "start_point": [
        95,
        0
      ],
      "end_point": [
        104,
        1
      ],
      "content": "static struct parser_field_t*\nalloc_next_field ()\n{\n  if (_fields_used == _fields_alloc)\n    _fields = x2nrealloc (_fields, &_fields_alloc,\n                          sizeof (struct parser_field_t));\n  struct parser_field_t *p = &_fields[_fields_used++];\n  memset (p, 0, sizeof (*p));\n  return p;\n}",
      "lines": 10,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "struct parser_field_t",
        "struct",
        "parser_field_t",
        "*\nalloc_next_field ()",
        "*"
      ]
    },
    "add_group_col": {
      "start_point": [
        115,
        0
      ],
      "end_point": [
        130,
        1
      ],
      "content": "static void\nadd_group_col (bool by_name, size_t num, const char* name)\n{\n  if (dm->num_grps == dm->alloc_grps)\n    dm->grps = x2nrealloc (dm->grps, &dm->alloc_grps, sizeof *dm->grps);\n  struct group_column_t *p = &dm->grps[dm->num_grps++];\n\n  p->num = num;\n  p->name = NULL;\n  p->by_name = by_name;\n  if (by_name)\n    {\n      p->name = xstrdup (name);\n      dm->header_required = true;\n    }\n}",
      "lines": 16,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "add_op": {
      "start_point": [
        132,
        0
      ],
      "end_point": [
        152,
        1
      ],
      "content": "static struct fieldop *\nadd_op (enum field_operation op, const struct parser_field_t *f)\n{\n  if (dm->num_ops == dm->alloc_ops)\n    dm->ops = x2nrealloc (dm->ops, &dm->alloc_ops, sizeof *dm->ops);\n  struct fieldop *p = &dm->ops[dm->num_ops++];\n\n  if (f->by_name)\n    dm->header_required = true;\n\n  #ifdef _STANDALONE_\n  memset (p, 0, sizeof (struct fieldop));\n  p->op = op;\n  p->field = f->num;\n  p->field_by_name = f->by_name;\n  p->field_name = f->name;\n  #else\n  field_op_init (p, op, f->by_name, f->num, f->name);\n  #endif\n  return p;\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "struct fieldop",
        "struct",
        "fieldop",
        "*\nadd_op (enum field_operation op, const struct parser_field_t *f)",
        "*"
      ]
    },
    "set_op_params": {
      "start_point": [
        154,
        0
      ],
      "end_point": [
        216,
        1
      ],
      "content": "static void\nset_op_params (struct fieldop *op)\n{\n  if (op->op==OP_BIN_BUCKETS)\n    {\n      op->params.bin_bucket_size = 100; /* default bucket size */\n      if (_params_used==1)\n        op->params.bin_bucket_size = _params[0].f;\n      /* TODO: in the future, accept offset as well? */\n      if (_params_used>1)\n        die (EXIT_FAILURE, 0, _(\"too many parameters for operation %s\"),\n                                    quote (get_field_operation_name (op->op)));\n      return;\n    }\n\n  if (op->op==OP_STRBIN)\n    {\n      op->params.strbin_bucket_size = 10; /* default bucket size for strbin */\n      if (_params_used==1)\n        op->params.strbin_bucket_size = _params[0].u;\n      if (op->params.strbin_bucket_size==0)\n        die (EXIT_FAILURE, 0, _(\"strbin bucket size must not be zero\"));\n      /* TODO: in the future, accept offset as well? */\n      if (_params_used>1)\n        die (EXIT_FAILURE, 0, _(\"too many parameters for operation %s\"),\n                                    quote (get_field_operation_name (op->op)));\n      return;\n    }\n\n  if (op->op==OP_PERCENTILE)\n    {\n      op->params.percentile = 95; /* default percentile */\n      if (_params_used==1)\n        op->params.percentile = _params[0].u;\n      if (op->params.percentile==0 || op->params.percentile>100)\n        die (EXIT_FAILURE, 0, _(\"invalid percentile value %\" PRIuMAX),\n             (uintmax_t)op->params.percentile);\n      if (_params_used>1)\n        die (EXIT_FAILURE, 0, _(\"too many parameters for operation %s\"),\n                                    quote (get_field_operation_name (op->op)));\n      return;\n    }\n\n  if (op->op==OP_TRIMMED_MEAN)\n    {\n      op->params.trimmed_mean = 0; /* default trimmed mean = no trim */\n      if (_params_used==1)\n        op->params.trimmed_mean = _params[0].f;\n      if (op->params.trimmed_mean<0 || op->params.trimmed_mean>0.5)\n        die (EXIT_FAILURE, 0, _(\"invalid trim mean value %Lg \" \\\n\t\t\t\t\"(expected 0 <= X <= 0.5)\"),\n             op->params.trimmed_mean);\n      if (_params_used>1)\n        die (EXIT_FAILURE, 0, _(\"too many parameters for operation %s\"),\n                                    quote (get_field_operation_name (op->op)));\n      return;\n    }\n\n  /* All other operations do not take parameters */\n  if (_params_used>0)\n    die (EXIT_FAILURE, 0, _(\"too many parameters for operation %s\"),\n        quote (get_field_operation_name (op->op)));\n}",
      "lines": 63,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "parse_simple_operation_column": {
      "start_point": [
        218,
        0
      ],
      "end_point": [
        273,
        1
      ],
      "content": "static void\nparse_simple_operation_column (struct parser_field_t /*OUTPUT*/ *p,\n                               bool in_range, bool in_pair)\n{\n  assert (p);                                    /* LCOV_EXCL_LINE */\n  enum TOKEN tok = scanner_get_token ();\n  switch (tok)                                   /* LCOV_EXCL_BR */\n    {\n    case TOK_IDENTIFIER:\n      p->by_name = true;\n      p->name = xstrdup (scanner_identifier);\n      break;\n\n    case TOK_WHITESPACE:                        /* LCOV_EXCL_LINE */\n      internal_error (\"whitespace\");            /* LCOV_EXCL_LINE */\n\n    case TOK_COMMA:\n      die (EXIT_FAILURE, 0, _(\"missing field for operation %s\"),\n           quote (get_field_operation_name (fop)));\n\n    case TOK_END:\n      /* informative error message depends on the context: */\n      if (in_range)\n        die (EXIT_FAILURE, 0, _(\"invalid field range for operation %s\"),\n             quote (get_field_operation_name (fop)));\n      if (in_pair)\n        die (EXIT_FAILURE, 0, _(\"invalid field pair for operation %s\"),\n             quote (get_field_operation_name (fop)));\n      die (EXIT_FAILURE, 0, _(\"missing field for operation %s\"),\n           quote (get_field_operation_name (fop)));\n\n    case TOK_DASH:\n      die (EXIT_FAILURE, 0, _(\"invalid field range for operation %s\"),\n           quote (get_field_operation_name (fop)));\n\n    case TOK_COLONS:\n      die (EXIT_FAILURE, 0, _(\"invalid field pair for operation %s\"),\n           quote (get_field_operation_name (fop)));\n\n    case TOK_INTEGER:\n      /* Zero values will fall-through to the error message below */\n      if (scan_val_int>0)\n        {\n          p->by_name = false;\n          p->num = scan_val_int;\n          break;\n        }\n      /* fallthrough */\n\n    case TOK_FLOAT:\n    default:\n      die (EXIT_FAILURE, 0, _(\"invalid field '%s' for operation %s\"),\n          scanner_identifier,\n          quote (get_field_operation_name (fop)));\n    }\n}",
      "lines": 56,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "parse_operation_column": {
      "start_point": [
        275,
        0
      ],
      "end_point": [
        309,
        1
      ],
      "content": "static void\nparse_operation_column ()\n{\n  struct parser_field_t *p = alloc_next_field ();\n  parse_simple_operation_column (p, false, false);\n\n  if (scanner_peek_token () == TOK_COLONS)\n    {\n      scanner_get_token ();\n\n      /* mark the previous field as pair, this will be the other field */\n      p->pair = true;\n\n      struct parser_field_t *q = alloc_next_field ();\n      parse_simple_operation_column (q, false, true);\n    }\n\n  if (scanner_peek_token () == TOK_DASH)\n    {\n      scanner_get_token ();\n\n      /* mark the previous field as range, this will be the 'to' field */\n      p->range = true;\n\n      struct parser_field_t *q = alloc_next_field ();\n      parse_simple_operation_column (q, true, false);\n\n      if (p->by_name || q->by_name)\n        die (EXIT_FAILURE, 0, _(\"field range for %s must be numeric\"),\n                                quote (get_field_operation_name (fop)));\n      if (p->num >= q->num)\n        die (EXIT_FAILURE, 0, _(\"invalid field range for operation %s\"),\n                                quote (get_field_operation_name (fop)));\n    }\n}",
      "lines": 35,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "parse_operation_column_list": {
      "start_point": [
        311,
        0
      ],
      "end_point": [
        323,
        1
      ],
      "content": "static void\nparse_operation_column_list ()\n{\n  parse_operation_column ();\n\n  enum TOKEN tok = scanner_peek_token ();\n  while (tok == TOK_COMMA)\n    {\n      scanner_get_token ();\n      parse_operation_column ();\n      tok = scanner_peek_token ();\n    }\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "parse_operation_params": {
      "start_point": [
        325,
        0
      ],
      "end_point": [
        383,
        1
      ],
      "content": "static void\nparse_operation_params ()\n{\n  /* currently, the only place we want to detect a whitespace, spearating\n     between operation's parameters and field numbers.\n     e.g.:\n      'foo:10: 4' should not be treated as 'foo:10:4' (with two parameters).\n      instead, it should produce an error (missing second parameter),\n      and the '4' should be treated as the field number.\n  */\n  scanner_keep_whitespace = true;\n\n  enum TOKEN tok = scanner_peek_token ();\n  while (tok == TOK_COLONS)\n    {\n      scanner_get_token ();\n      tok = scanner_get_token ();\n\n      if (_params_used == _params_alloc)\n        _params = x2nrealloc (_params, &_params_alloc,\n                                        sizeof (struct parser_param_t));\n      struct parser_param_t *p = &_params[_params_used++];\n\n      switch (tok)\n        {\n        case TOK_INTEGER:\n          p->type = PARAM_INT;\n          p->u    = scan_val_int;\n          p->f    = scan_val_int;\n          break;\n\n        case TOK_FLOAT:\n          p->type = PARAM_FLOAT;\n          p->f    = scan_val_float;\n          break;\n\n        case TOK_WHITESPACE:\n        case TOK_END:\n          die (EXIT_FAILURE, 0, _(\"missing parameter for operation %s\"),\n                                  quote (get_field_operation_name (fop)));\n\n        case TOK_COMMA:\n        case TOK_DASH:\n        case TOK_IDENTIFIER:\n        case TOK_COLONS:\n        default:\n          die (EXIT_FAILURE, 0, _(\"invalid parameter %s for operation %s\"),\n                                  scanner_identifier,\n                                  quote (get_field_operation_name (fop)));\n\n        }\n\n      tok = scanner_peek_token ();\n    }\n  if (tok == TOK_WHITESPACE)\n    scanner_get_token ();\n\n  scanner_keep_whitespace = false;\n}",
      "lines": 59,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "compatible_operation_modes": {
      "start_point": [
        385,
        0
      ],
      "end_point": [
        391,
        1
      ],
      "content": "static inline bool\ncompatible_operation_modes (enum processing_mode current,\n                             enum processing_mode added)\n{\n  return ((current==MODE_CROSSTAB)&&(added==MODE_GROUPBY))||\n         (current==added);\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "bool"
      ]
    },
    "create_field_ops": {
      "start_point": [
        393,
        0
      ],
      "end_point": [
        432,
        1
      ],
      "content": "static void\ncreate_field_ops ()\n{\n  for (size_t i=0; i<_fields_used; ++i)\n    {\n      const struct parser_field_t *f = &_fields[i];\n      struct fieldop *op = add_op (fop, f);\n      set_op_params (op);\n\n      if (OP_NEED_PAIR_PARAMS (fop) && !f->pair)\n        die (EXIT_FAILURE, 0, _(\"operation %s requires field pairs\"),\n                                quote (get_field_operation_name (fop)));\n      if (!OP_NEED_PAIR_PARAMS (fop) && f->pair)\n        die (EXIT_FAILURE, 0, _(\"operation %s cannot use pair of fields\"),\n                                quote (get_field_operation_name (fop)));\n\n      if (f->range)\n        {\n          uintmax_t to   = _fields[++i].num;\n          struct parser_field_t t = *f;\n          while (t.num<to)\n            {\n              ++t.num;\n              op = add_op (fop, &t);\n              set_op_params (op);\n            }\n        }\n\n      if (f->pair)\n        {\n          op->slave = true;\n\n          const struct parser_field_t *other_f = &_fields[++i];\n          op = add_op (fop, other_f);\n          set_op_params (op);\n          op->master = true;\n          op->slave_idx = dm->num_ops-2; /* index of the prev op = slave op */\n        }\n    }\n}",
      "lines": 40,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "parse_operation": {
      "start_point": [
        434,
        0
      ],
      "end_point": [
        465,
        1
      ],
      "content": "static void\nparse_operation (enum processing_mode pm)\n{\n  reset_parsed_operation ();\n\n  scanner_get_token ();\n  enum processing_mode pm2;\n  fop = get_field_operation (scanner_identifier, &pm2);\n  if (fop==OP_INVALID)\n    {\n      pm2 = get_processing_mode (scanner_identifier);\n      if (pm2 != MODE_INVALID)\n        die (EXIT_FAILURE,0, _(\"conflicting operation %s\"),\n                               quote (scanner_identifier));\n\n      die (EXIT_FAILURE,0, _(\"invalid operation %s\"),\n                             quote (scanner_identifier));\n    }\n\n  if (!compatible_operation_modes (pm,pm2))\n    die (EXIT_FAILURE, 0, _(\"conflicting operation found: \"\\\n           \"expecting %s operations, but found %s operation %s\"),\n           get_processing_mode_name (pm),\n           get_processing_mode_name (pm2),\n           quote (scanner_identifier));\n\n  parse_operation_params ();\n\n  parse_operation_column_list ();\n\n  create_field_ops ();\n}",
      "lines": 32,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "parse_operations": {
      "start_point": [
        467,
        0
      ],
      "end_point": [
        487,
        1
      ],
      "content": "static void\nparse_operations (enum processing_mode pm)\n{\n  enum TOKEN tok = scanner_peek_token ();\n  while (tok != TOK_END)\n    {\n      parse_operation (pm);\n      tok = scanner_peek_token ();\n    }\n\n  /* After adding all operations, see of there are master/slave ops\n   * that need resolving - caching their pointer instead of index */\n  for (size_t i=0; i<dm->num_ops; ++i)\n     {\n      if (!dm->ops[i].master)\n        continue;\n      const size_t si = dm->ops[i].slave_idx;\n      assert (si<=dm->num_ops);                  /* LCOV_EXCL_LINE */\n      dm->ops[i].slave_op = &dm->ops[si];\n    }\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "parse_mode_column": {
      "start_point": [
        489,
        0
      ],
      "end_point": [
        524,
        1
      ],
      "content": "static void\nparse_mode_column (enum processing_mode pm)\n{\n  enum TOKEN tok = scanner_get_token ();\n  switch (tok)                                   /* LCOV_EXCL_BR */\n    {\n    case TOK_IDENTIFIER:\n      ADD_NAMED_GROUP (scanner_identifier);\n      break;\n\n    case TOK_WHITESPACE:                        /* LCOV_EXCL_LINE */\n      internal_error (\"whitespace\");            /* LCOV_EXCL_LINE */\n\n    case TOK_COMMA:\n    case TOK_END:\n      die (EXIT_FAILURE, 0, _(\"missing field for operation %s\"),\n           quote (get_processing_mode_name (pm)));\n\n    case TOK_INTEGER:\n      if (scan_val_int>0)\n        {\n          ADD_NUMERIC_GROUP (scan_val_int);\n          break;\n        }\n      /* fallthrough */\n\n    case TOK_DASH:\n    case TOK_COLONS:\n    case TOK_FLOAT:\n    default:\n      die (EXIT_FAILURE, 0, _(\"invalid field '%s' for operation %s\"),\n          scanner_identifier,\n          quote (get_processing_mode_name (pm)));\n\n    }\n}",
      "lines": 36,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "parse_mode_column_list": {
      "start_point": [
        526,
        0
      ],
      "end_point": [
        546,
        1
      ],
      "content": "static void\nparse_mode_column_list (enum processing_mode pm)\n{\n  parse_mode_column (pm);\n\n  enum TOKEN tok = scanner_peek_token ();\n  while (tok == TOK_COMMA)\n    {\n      scanner_get_token ();\n      parse_mode_column (pm);\n      tok = scanner_peek_token ();\n    }\n  /* detect and warn about incorrect usage,\n     field specification for groups can't handle dashes or colons (for now) */\n  if (tok == TOK_DASH)\n    die (EXIT_FAILURE, 0, _(\"invalid field range for operation %s\"),\n                            quote (get_processing_mode_name (pm)));\n  if (tok == TOK_COLONS)\n    die (EXIT_FAILURE, 0, _(\"invalid field pair for operation %s\"),\n                            quote (get_processing_mode_name (pm)));\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "parse_check_line_or_field": {
      "start_point": [
        548,
        0
      ],
      "end_point": [
        559,
        1
      ],
      "content": "static bool\nparse_check_line_or_field (const char* s)\n{\n  if (STREQ (s,\"lines\") || STREQ (s,\"line\") \\\n      || STREQ (s,\"rows\") || STREQ (s,\"row\"))\n    return true;\n  if (STREQ (s,\"fields\") || STREQ (s,\"field\") \\\n      || STREQ (s,\"columns\") || STREQ (s,\"column\") || STREQ (s,\"col\"))\n    return false;\n\n  die (EXIT_FAILURE, 0, _(\"invalid option %s for operation check\"), quote (s));\n}",
      "lines": 12,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "parse_mode_check": {
      "start_point": [
        561,
        0
      ],
      "end_point": [
        615,
        1
      ],
      "content": "static void\nparse_mode_check ()\n{\n  bool set_lines = true; // false = set columns\n  uintmax_t value = 0;\n\n  uintmax_t n_lines = 0;\n  uintmax_t n_fields = 0;\n\n  enum TOKEN tok = scanner_peek_token ();\n  while (tok != TOK_END)\n    {\n      tok = scanner_get_token ();\n      if (tok == TOK_INTEGER)\n        {\n          value = scan_val_int;\n\n          ignore_value (scanner_get_token ());\n          set_lines = parse_check_line_or_field (scanner_identifier);\n        }\n      else\n        {\n          set_lines = parse_check_line_or_field (scanner_identifier);\n          tok = scanner_get_token ();\n          if (tok != TOK_INTEGER)\n            die (EXIT_FAILURE, 0, _(\"number expected after option in \" \\\n                                    \"operation 'check'\"));\n          value = scan_val_int;\n        }\n\n      if (value == 0)\n        die (EXIT_FAILURE, 0, _(\"invalid value zero for lines/fields in \"  \\\n                                \"operation 'check'\"));\n\n      if (set_lines)\n        {\n          if (n_lines>0)\n            die (EXIT_FAILURE, 0, _(\"number of lines/rows already set in \" \\\n                                    \"operation 'check'\"));\n          n_lines = value;\n        }\n      else\n        {\n          if (n_fields>0)\n            die (EXIT_FAILURE, 0, _(\"number of fields/columns already set in \" \\\n                                    \"operation 'check'\"));\n          n_fields = value;\n        }\n\n      tok = scanner_peek_token ();\n    }\n\n  dm->mode_params.check_params.n_lines = n_lines;\n  dm->mode_params.check_params.n_fields = n_fields;\n}",
      "lines": 55,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "parse_mode": {
      "start_point": [
        617,
        0
      ],
      "end_point": [
        679,
        1
      ],
      "content": "static void\nparse_mode ()\n{\n  scanner_get_token ();\n  enum processing_mode pm = get_processing_mode (scanner_identifier);\n  dm->mode = pm;\n\n  switch (pm)                                    /* LCOV_EXCL_BR_LINE */\n  {\n  case MODE_TRANSPOSE:\n  case MODE_NOOP:\n  case MODE_REVERSE:\n    break;\n\n  case MODE_TABULAR_CHECK:\n    parse_mode_check ();\n    break;\n\n  case MODE_REMOVE_DUPS:\n    parse_mode_column_list (pm);\n    break;\n\n  case MODE_CROSSTAB:\n    parse_mode_column_list (pm);\n    if (dm->num_grps!=2)\n      die (EXIT_FAILURE,0, _(\"crosstab requires exactly 2 fields, \" \\\n                               \"found %\"PRIuMAX), (uintmax_t)dm->num_grps);\n\n    /* if the user didn't specify an operation, print counts */\n    parse_operations (pm);\n    if (dm->num_ops==0)\n      {\n        const uintmax_t grp_col = dm->grps[0].num;\n        struct parser_field_t dummy = {grp_col,false,NULL,false,false};\n        add_op (OP_COUNT, &dummy);\n      }\n    else if (dm->num_ops>1)\n      {\n        die (EXIT_FAILURE,0, _(\"crosstab supports one operation, \" \\\n                                 \"found %\"PRIuMAX), (uintmax_t)dm->num_ops);\n      }\n    break;\n\n  case MODE_GROUPBY:\n    parse_mode_column_list (pm);\n    parse_operations (pm);\n    if (dm->num_ops==0)\n      die (EXIT_FAILURE,0, _(\"missing operation\"));\n    break;\n\n  case MODE_PER_LINE:                           /* LCOV_EXCL_LINE */\n    internal_error (\"line mode used directly\"); /* LCOV_EXCL_LINE */\n    break;\n\n  case MODE_INVALID:                 /* LCOV_EXCL_LINE */\n  default:                           /* LCOV_EXCL_LINE */\n    internal_error (\"wrong opmode\"); /* LCOV_EXCL_LINE */\n    break;\n  }\n\n  if (scanner_peek_token ()!=TOK_END)\n    die (EXIT_FAILURE,0,_(\"extra operand %s\"), quote (scanner_identifier));\n}",
      "lines": 63,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "parse_mode_or_op": {
      "start_point": [
        681,
        0
      ],
      "end_point": [
        704,
        1
      ],
      "content": "static void\nparse_mode_or_op ()\n{\n  enum TOKEN tok = scanner_peek_token ();\n  assert ( tok != TOK_END );                      /* LCOV_EXCL_LINE */\n\n  enum processing_mode pm = get_processing_mode (scanner_identifier);\n  if (pm != MODE_INVALID)\n    {\n      parse_mode ();\n      return ;\n    }\n\n  enum field_operation fop = get_field_operation (scanner_identifier, &pm);\n  if (fop!=OP_INVALID)\n    {\n      dm->mode = pm;\n      parse_operations (pm);\n      return ;\n    }\n\n  die (EXIT_FAILURE,0, _(\"invalid operation %s\"),\n\t\t  quote (scanner_identifier));\n}",
      "lines": 24,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "datamash_ops_parse": {
      "start_point": [
        706,
        0
      ],
      "end_point": [
        714,
        1
      ],
      "content": "struct datamash_ops*\ndatamash_ops_parse ( int argc, const char* argv[] )\n{\n  _alloc_ops ();\n  scanner_set_input_from_argv (argc, argv);\n  parse_mode_or_op ();\n  scanner_free ();\n  return dm;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "struct datamash_ops",
        "struct",
        "datamash_ops",
        "*\ndatamash_ops_parse ( int argc, const char* argv[] )",
        "*"
      ]
    },
    "datamash_ops_parse_premode": {
      "start_point": [
        716,
        0
      ],
      "end_point": [
        732,
        1
      ],
      "content": "struct datamash_ops*\ndatamash_ops_parse_premode ( enum processing_mode pm,\n                             const char* grouping,\n                             int argc, const char* argv[] )\n{\n  _alloc_ops ();\n  assert (argc > 0);                             /* LCOV_EXCL_LINE */\n  assert (pm == MODE_GROUPBY);                   /* LCOV_EXCL_LINE */\n  dm->mode = pm;\n  scanner_set_input_from_argv (1, &grouping);\n  parse_mode_column_list (pm);\n  scanner_free ();\n  scanner_set_input_from_argv (argc, argv);\n  parse_operations (pm);\n  scanner_free ();\n  return dm;\n}",
      "lines": 17,
      "depth": 8,
      "decorators": [
        "struct datamash_ops",
        "struct",
        "datamash_ops",
        "*\ndatamash_ops_parse_premode ( enum processing_mode pm,\n                             const char* grouping,\n                             int argc, const char* argv[] )",
        "*"
      ]
    },
    "datamash_ops_free": {
      "start_point": [
        734,
        0
      ],
      "end_point": [
        761,
        1
      ],
      "content": "void\ndatamash_ops_free ( struct datamash_ops* p )\n{\n  assert (p != NULL);                            /* LCOV_EXCL_LINE */\n  for (size_t i=0; i<p->num_grps; ++i)\n    free (p->grps[i].name);\n  free (p->grps);\n  p->grps = NULL;\n\n  #ifndef _STANDALONE_\n  for (size_t i=0; i<p->num_ops; ++i)\n    field_op_free (&p->ops[i]);\n  #endif\n\n  free (p->ops);\n  p->ops = NULL;\n\n  free (_fields);\n  _fields = NULL;\n  _fields_alloc = 0;\n  _fields_used = 0;\n\n  free (_params);\n  _params_alloc = 0;\n  _params_used = 0;\n\n  free (p);\n}",
      "lines": 28,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "datamash_ops_debug_print": {
      "start_point": [
        776,
        0
      ],
      "end_point": [
        809,
        1
      ],
      "content": "void\ndatamash_ops_debug_print ( const struct datamash_ops* p )\n{\n  assert (p != NULL );\n  printf (\"datamash_ops =\\n processing_mode = %s\\n header_required = %d\\n\",\n          get_processing_mode_name (p->mode), (int)p->header_required);\n\n  if (p->num_grps==0)\n      puts (\"   no grouping specified\");\n  for (size_t i=0; i<p->num_grps; ++i)\n    {\n      const struct group_column_t *tmp = &p->grps[i];\n      if (tmp->by_name)\n        printf (\"  group-by named column '%s'\\n\",tmp->name);\n      else\n        printf (\"  group-by numeric column %zu\\n\",tmp->num);\n    }\n\n  for (size_t i=0; i<p->num_ops; ++i)\n    {\n      struct fieldop *o = &p->ops[i];\n      if (o->field_by_name)\n        printf (\"  operation '%s' on named column '%s'\",\n                        get_field_operation_name (o->op), o->field_name);\n      else\n        printf (\"  operation '%s' on numeric column %zu\",\n                        get_field_operation_name (o->op), o->field);\n      if (o->master)\n        printf (\" (master)\");\n      if (o->slave)\n        printf (\" (slave)\");\n      printf ( \"\\n\");\n    }\n}",
      "lines": 34,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "TESTMAIN": {
      "start_point": [
        812,
        0
      ],
      "end_point": [
        821,
        1
      ],
      "content": "int TESTMAIN (int argc, const char* argv[])\n{\n  if (argc<2)\n    die (EXIT_FAILURE, 0, _(\"missing script (among arguments)\"));\n\n  struct datamash_ops *o = datamash_ops_parse (argc-1, argv+1);\n  datamash_ops_debug_print ( o );\n  datamash_ops_free (o);\n  return 0;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "datamash/datamash-1.3/src/op-parser.h": {},
  "datamash/datamash-1.3/src/op-scanner.c": {
    "set_identifier": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "static inline void\nset_identifier (const char* data, size_t n)\n{\n  if (n>=scanner_identifier_len)\n    {\n      scanner_identifier = xrealloc (scanner_identifier,n+1);\n      scanner_identifier_len = n+1;\n    }\n  memcpy (scanner_identifier, data, n);\n  scanner_identifier[n]=0;\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    },
    "scanner_set_input_from_argv": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "void\nscanner_set_input_from_argv (int argc, const char* argv[])\n{\n  assert (scanner_input == NULL);                /* LCOV_EXCL_LINE */\n\n  size_t len = 1; /* +1 for NUL */\n  for (int i=0;i<argc;++i)\n    len += strlen (argv[i])+1; /* +1 for space */\n\n  char *p = scan_pos = scanner_input = XCALLOC (len, char);\n  for (int i=0; i<argc; ++i)\n  {\n      if (i>0)\n        p = stpcpy (p, \" \");\n      p = stpcpy (p, argv[i]);\n  }\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "scanner_free": {
      "start_point": [
        80,
        0
      ],
      "end_point": [
        91,
        1
      ],
      "content": "void\nscanner_free ()\n{\n  free (scanner_identifier);\n  scanner_identifier = NULL;\n  scanner_identifier_len = 0;\n\n  free (scanner_input);\n  scanner_input = NULL;\n  scan_pos = NULL;\n  have_peek = false;\n}",
      "lines": 12,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "scanner_peek_token": {
      "start_point": [
        93,
        0
      ],
      "end_point": [
        102,
        1
      ],
      "content": "enum TOKEN\nscanner_peek_token ()\n{\n  if (have_peek)\n    return scan_peek;\n\n  scan_peek = scanner_get_token ();\n  have_peek = true;\n  return scan_peek;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "enum TOKEN",
        "enum",
        "TOKEN"
      ]
    },
    "scanner_get_token": {
      "start_point": [
        104,
        0
      ],
      "end_point": [
        190,
        1
      ],
      "content": "enum TOKEN\nscanner_get_token ()\n{\n  char *pend;\n\n  if (have_peek)\n    {\n      have_peek = false;\n      return scan_peek;\n    }\n\n  assert (scan_pos != NULL);                      /* LCOV_EXCL_LINE */\n\n  if (*scan_pos == '\\0')\n    return TOK_END;\n\n  /* White space */\n  if (c_isspace (*scan_pos))\n    {\n      while ( c_isspace (*scan_pos) )\n        ++scan_pos;\n      if (scanner_keep_whitespace)\n        {\n          if (*scan_pos == '\\0')\n            return TOK_END;\n          return TOK_WHITESPACE;\n        }\n    }\n\n  /* special characters */\n  if (*scan_pos == ',')\n    {\n      ++scan_pos;\n      set_identifier (\",\", 1);\n      return TOK_COMMA;\n    }\n  if (*scan_pos == '-')\n    {\n      ++scan_pos;\n      set_identifier (\"-\", 1);\n      return TOK_DASH;\n    }\n  if (*scan_pos == ':')\n    {\n      ++scan_pos;\n      set_identifier (\":\", 1);\n      return TOK_COLONS;\n    }\n\n  /* Integer or floating-point value */\n  if (c_isdigit (*scan_pos))\n    {\n      enum TOKEN rc = TOK_INTEGER;\n      errno = 0;\n      scan_val_int = strtol (scan_pos, &pend, 10);\n\n      if (*pend == '.')\n        {\n          /* a floating-point value */\n          scan_val_float = strtold (scan_pos, &pend);\n          rc = TOK_FLOAT;\n        }\n      if ((c_isalpha (*pend) || *pend=='_') || (errno == ERANGE))\n        die (EXIT_FAILURE, 0, _(\"invalid numeric value '%s'\"),\n                                scan_pos);\n\n      set_identifier (scan_pos, pend-scan_pos);\n      scan_pos = pend;\n      return rc;\n    }\n\n  /* a valid identifier ( [a-z_][a-z0-9_]+ ) */\n  if (c_isalpha (*scan_pos) || *scan_pos == '_')\n    {\n      size_t l=1;\n      char *v=scan_pos+1;\n      while ( c_isalpha (*v) || c_isdigit (*v) || *v=='_' )\n        ++l, ++v;\n\n      set_identifier (scan_pos, l);\n      scan_pos += l;\n      return TOK_IDENTIFIER;\n    }\n\n  die (EXIT_FAILURE, 0, _(\"invalid operand %s\"), quote (scan_pos));\n  return TOK_END;\n}",
      "lines": 87,
      "depth": 13,
      "decorators": [
        "enum TOKEN",
        "enum",
        "TOKEN"
      ]
    },
    "TESTMAIN": {
      "start_point": [
        207,
        0
      ],
      "end_point": [
        249,
        1
      ],
      "content": "int TESTMAIN (int argc, const char* argv[])\n{\n  if (argc<2)\n    die (EXIT_FAILURE, 0, _(\"missing script (among arguments)\"));\n\n  scanner_set_input_from_argv (argc-1, argv+1);\n\n  enum TOKEN tok;\n  while ( (tok = scanner_get_token ()) != TOK_END )\n  {\n    switch (tok)\n    {\n    case TOK_IDENTIFIER:\n      printf (\"TOK_IDENTIFIER: '%s'\\n\", scanner_identifier);\n      break;\n\n    case TOK_INTEGER:\n      printf (\"TOK_INTEGER: %lu ('%s')\\n\", scan_val_int, scanner_identifier);\n      break;\n\n    case TOK_FLOAT:\n      printf (\"TOK_FLOAT: %Lf ('%s')\\n\", scan_val_float, scanner_identifier);\n      break;\n\n    case TOK_COMMA:\n      printf (\"TOK_COMMA\\n\");\n      break;\n\n    case TOK_DASH:\n      printf (\"TOK_DASH\\n\");\n      break;\n\n    case TOK_COLONS:\n      printf (\"TOK_COLONS\\n\");\n      break;\n\n    default:\n      die (EXIT_FAILURE, 0 ,_(\"unknown token %d\\n\"),tok);\n    }\n  }\n\n  return 0;\n}",
      "lines": 43,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "datamash/datamash-1.3/src/op-scanner.h": {},
  "datamash/datamash-1.3/src/system.h": {
    "x2nrealloc": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "static inline void*\nx2nrealloc (void *p, size_t *pn, size_t s)\n{\n  size_t n = (*pn==0)?1000:( (*pn)*2 );\n  if (!p) { n = 1000 ; }\n  *pn = n;\n  return realloc (p, n*s);\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void",
        "*\nx2nrealloc (void *p, size_t *pn, size_t s)",
        "*"
      ]
    },
    "emit_try_help": {
      "start_point": [
        136,
        0
      ],
      "end_point": [
        140,
        1
      ],
      "content": "static inline void\nemit_try_help (void)\n{\n  fprintf (stderr, _(\"Try '%s --help' for more information.\\n\"), program_name);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    },
    "to_uchar": {
      "start_point": [
        149,
        0
      ],
      "end_point": [
        149,
        61
      ],
      "content": "static inline unsigned char to_uchar (char ch) { return ch; }",
      "lines": 1,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "unsigned char",
        "unsigned",
        "char"
      ]
    },
    "select_plural": {
      "start_point": [
        177,
        0
      ],
      "end_point": [
        184,
        1
      ],
      "content": "static inline unsigned long int\nselect_plural (uintmax_t n)\n{\n  /* Reduce by a power of ten, but keep it away from zero.  The\n     gettext manual says 1000000 should be safe.  */\n  enum { PLURAL_REDUCER = 1000000 };\n  return (n <= ULONG_MAX ? n : n % PLURAL_REDUCER + PLURAL_REDUCER);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "unsigned long int",
        "unsigned",
        "long",
        "int"
      ]
    }
  },
  "datamash/datamash-1.3/src/text-lines.c": {
    "line_record_init": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "void\nline_record_init (struct line_record_t* lr)\n{\n  initbuffer (&lr->lbuf);\n  lr->alloc_fields = 10 ;\n  lr->num_fields = 0;\n  lr->fields = XNMALLOC (lr->alloc_fields, struct field_record_t);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "line_record_debug_print_fields": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "static void\nline_record_debug_print_fields (const struct line_record_t *lr)\n{\n  fputs (\"line_record_t = {\\n\",stderr);\n  fprintf (stderr, \"  linebuffer.length = %zu\\n\", lr->lbuf.length);\n  fputs (\"  linebuffer.buffer = '\",stderr);\n    fwrite (lr->lbuf.buffer,lr->lbuf.length,sizeof (char),stderr);\n  fputs (\"'\\n\",stderr);\n\n  fprintf (stderr, \"  num_fields = %zu\\n\", lr->num_fields);\n  fprintf (stderr, \"  alloc_fields = %zu\\n\", lr->alloc_fields);\n\n  for (size_t i=0; i<lr->num_fields; ++i)\n    {\n      fprintf (stderr, \"  field[%zu] = '\", i);\n      fwrite (lr->fields[i].buf,lr->fields[i].len,sizeof (char),stderr);\n      fprintf (stderr, \"' (len = %zu)\\n\", lr->fields[i].len);\n    }\n  fputs (\"}\\n\", stderr);\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "linebuffer_nullify": {
      "start_point": [
        73,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "static void\nlinebuffer_nullify (struct linebuffer *line)\n{\n  assert (line->length > 0); /* LCOV_EXCL_LINE */\n  line->buffer[line->length-1] = 0; /* make it NUL terminated */\n  --line->length;\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "line_record_reserve_fields": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "static inline void\nline_record_reserve_fields (struct line_record_t* lr, const size_t n)\n{\n  if (lr->alloc_fields <= n)\n    {\n      lr->alloc_fields = MAX (n,lr->alloc_fields)*2;\n      lr->fields = xnrealloc (lr->fields, lr->alloc_fields,\n                              sizeof (struct field_record_t));\n    }\n}",
      "lines": 10,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    },
    "line_record_parse_fields": {
      "start_point": [
        92,
        0
      ],
      "end_point": [
        156,
        1
      ],
      "content": "static void\nline_record_parse_fields (struct line_record_t *lr, int field_delim)\n{\n  size_t num_fields = 0;\n  size_t pos = 0;\n  const size_t buflen = line_record_length (lr);\n  const char* fptr = line_record_buffer (lr);\n\n  /* Move 'fptr' to point to the beginning of 'field' */\n  if (field_delim != TAB_WHITESPACE)\n    {\n      while (buflen && pos<=buflen)\n        {\n          /* scan buffer until next delimiter */\n          const char* field_beg = fptr;\n          while ( (pos<buflen) && (*fptr != field_delim))\n            {\n              ++fptr;\n              ++pos;\n            }\n\n          /* Add new field */\n          line_record_reserve_fields (lr, num_fields);\n          lr->fields[num_fields].buf = field_beg;\n          lr->fields[num_fields].len = fptr - field_beg;\n          ++num_fields;\n\n          /* Skip the delimiter */\n          ++pos;\n          ++fptr;\n        }\n      lr->num_fields = num_fields;\n    }\n  else\n    {\n      /* delimiter is white-space transition\n         (multiple whitespaces are one delimiter) */\n      while (pos<buflen)\n        {\n          /* Skip leading whitespace */\n          while ( (pos<buflen) && blanks[to_uchar (*fptr)])\n            {\n              ++fptr;\n              ++pos;\n            }\n\n          /* Scan buffer until next whitespace */\n          const char* field_beg = fptr;\n          size_t flen = 0;\n          while ( (pos<buflen) && !blanks[to_uchar (*fptr)])\n            {\n              ++fptr;\n              ++pos;\n              ++flen;\n            }\n\n          /* Add new field */\n          line_record_reserve_fields (lr, num_fields);\n          lr->fields[num_fields].buf = field_beg;\n          lr->fields[num_fields].len = flen;\n          ++num_fields;\n        }\n      lr->num_fields = num_fields;\n    }\n}",
      "lines": 65,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "line_record_fread": {
      "start_point": [
        159,
        0
      ],
      "end_point": [
        170,
        1
      ],
      "content": "bool\nline_record_fread (struct /* in/out */ line_record_t* lr,\n                  FILE *stream, char delimiter)\n{\n  if (readlinebuffer_delim (&lr->lbuf, stream, delimiter) == 0)\n    return false;\n\n  linebuffer_nullify (&lr->lbuf);\n\n  line_record_parse_fields (lr, in_tab);\n  return true;\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "bool"
      ]
    },
    "line_record_free": {
      "start_point": [
        172,
        0
      ],
      "end_point": [
        181,
        1
      ],
      "content": "void\nline_record_free (struct line_record_t* lr)\n{\n  freebuffer (&lr->lbuf);\n  lr->lbuf.buffer = NULL;\n  free (lr->fields);\n  lr->fields = NULL;\n  lr->alloc_fields = 0;\n  lr->num_fields = 0;\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "datamash/datamash-1.3/src/text-lines.h": {
    "line_record_length": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        46,
        1
      ],
      "content": "static inline size_t\nline_record_length (const struct line_record_t *lr)\n{\n  return lr->lbuf.length;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "size_t"
      ]
    },
    "line_record_buffer": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "static inline const char*\nline_record_buffer (const struct line_record_t *lr)\n{\n  return lr->lbuf.buffer;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "const",
        "const",
        "char",
        "*\nline_record_buffer (const struct line_record_t *lr)",
        "*"
      ]
    },
    "line_record_num_fields": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "static inline size_t\nline_record_num_fields (const struct line_record_t *lr)\n{\n  return lr->num_fields;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "size_t"
      ]
    },
    "line_record_field_unsafe": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "static inline const struct field_record_t*\nline_record_field_unsafe (const struct line_record_t *lr, const size_t n)\n{\n  return &lr->fields[n-1];\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "const",
        "const",
        "struct field_record_t",
        "struct",
        "field_record_t",
        "*\nline_record_field_unsafe (const struct line_record_t *lr, const size_t n)",
        "*"
      ]
    },
    "line_record_get_field": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "static inline bool\nline_record_get_field (const struct line_record_t *lr, const size_t n,\n                       const char ** /* out */ pptr, size_t* /*out*/ plen)\n{\n  assert (n!=0); /* LCOV_EXCL_LINE */\n  if (line_record_num_fields (lr) < n)\n    return false;\n\n  *pptr = lr->fields[n-1].buf;\n  *plen = lr->fields[n-1].len;\n  return true;\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "bool"
      ]
    }
  },
  "datamash/datamash-1.3/src/text-options.c": {
    "init_blank_table": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "void\ninit_blank_table (void)\n{\n  size_t i;\n\n  for (i = 0; i < UCHAR_LIM; ++i)\n    {\n      blanks[i] = !! isblank (i);\n    }\n}",
      "lines": 10,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "finalize_numeric_output_buffer": {
      "start_point": [
        89,
        0
      ],
      "end_point": [
        96,
        1
      ],
      "content": "static void\nfinalize_numeric_output_buffer ()\n{\n  char c;\n  long double d = LDBL_MAX;\n  int n = snprintf (&c, 1, numeric_output_format, d);\n  numeric_output_bufsize = n + 100 ;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "set_numeric_output_precision": {
      "start_point": [
        98,
        0
      ],
      "end_point": [
        118,
        1
      ],
      "content": "void\nset_numeric_output_precision (const char* digits)\n{\n  long int l;\n  char *p;\n  char tmp[100];\n\n  if (digits == NULL || digits[0] == '\\0')\n    die (EXIT_FAILURE, 0, _(\"missing rounding digits value\"));\n\n  errno = 0;\n  l = strtol (digits, &p, 10);\n  if (errno != 0 || *p != '\\0' || l <=0 || l> 50)\n    die (EXIT_FAILURE, 0, _(\"invalid rounding digits value %s\"),\n\t quote (digits));\n\n  snprintf (tmp, sizeof (tmp), \"%%.%dLf\", (int)l);\n  numeric_output_format = xstrdup (tmp);\n\n  finalize_numeric_output_buffer ();\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "set_numeric_printf_format": {
      "start_point": [
        120,
        0
      ],
      "end_point": [
        125,
        1
      ],
      "content": "void\nset_numeric_printf_format (const char* format)\n{\n  numeric_output_format = validate_double_format (format);\n  finalize_numeric_output_buffer ();\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "datamash/datamash-1.3/src/text-options.h": {
    "print_field_separator": {
      "start_point": [
        71,
        0
      ],
      "end_point": [
        75,
        1
      ],
      "content": "static inline void\nprint_field_separator ()\n{\n  putchar (out_tab);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    },
    "print_line_separator": {
      "start_point": [
        77,
        0
      ],
      "end_point": [
        81,
        1
      ],
      "content": "static inline void\nprint_line_separator ()\n{\n  putchar (eolchar);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    }
  },
  "datamash/datamash-1.3/src/utils.c": {
    "_GL_ATTRIBUTE_PURE": [
      {
        "start_point": [
          36,
          0
        ],
        "end_point": [
          43,
          1
        ],
        "content": "bool _GL_ATTRIBUTE_PURE\nis_na (const char* value, const size_t len)\n{\n  assert (value != NULL); /* LCOV_EXCL_LINE */\n  return (len==2 && (strncasecmp (value,\"NA\",2)==0))\n          || (len==3 && (strncasecmp (value,\"N/A\",3)==0))\n          || (len==3 && (strncasecmp (value,\"NAN\",3)==0));\n}",
        "lines": 8,
        "depth": 13,
        "decorators": [
          "bool"
        ]
      },
      {
        "start_point": [
          92,
          0
        ],
        "end_point": [
          104,
          1
        ],
        "content": "long double _GL_ATTRIBUTE_PURE\nmad_value (const long double * const values, size_t n, double scale)\n{\n  const long double median = median_value (values,n);\n  long double *mads = xnmalloc (n,sizeof (long double));\n  long double mad = 0 ;\n  for (size_t i=0; i<n; ++i)\n    mads[i] = fabsl (median - values[i]);\n  qsortfl (mads,n);\n  mad = median_value (mads,n);\n  free (mads);\n  return mad * scale;\n}",
        "lines": 13,
        "depth": 10,
        "decorators": [
          "long double",
          "long",
          "double"
        ]
      },
      {
        "start_point": [
          375,
          0
        ],
        "end_point": [
          405,
          1
        ],
        "content": "long double _GL_ATTRIBUTE_PURE\nmode_value ( const long double * const values, size_t n, enum MODETYPE type)\n{\n  /* not ideal implementation but simple enough */\n  /* Assumes 'values' are already sorted, find the longest sequence */\n  long double last_value = values[0];\n  size_t seq_size=1;\n  size_t best_seq_size= (type==MODE)?1:SIZE_MAX;\n  size_t best_value = values[0];\n\n  for (size_t i=1; i<n; i++)\n    {\n      bool eq = (cmp_long_double (&values[i],&last_value)==0);\n\n      if (eq)\n        seq_size++;\n\n      if ( ((type==MODE) && (seq_size > best_seq_size))\n           || ((type==ANTIMODE) && (seq_size < best_seq_size)))\n        {\n          best_seq_size = seq_size;\n          best_value = last_value;\n        }\n\n      if (!eq)\n          seq_size = 1;\n\n      last_value = values[i];\n    }\n  return best_value;\n}",
        "lines": 31,
        "depth": 13,
        "decorators": [
          "long double",
          "long",
          "double"
        ]
      },
      {
        "start_point": [
          430,
          0
        ],
        "end_point": [
          437,
          1
        ],
        "content": "int _GL_ATTRIBUTE_PURE\ncmpstringp (const void *p1, const void *p2)\n{\n  /* The actual arguments to this function are \"pointers to\n   * pointers to char\", but strcmp (3) arguments are \"pointers\n   * to char\", hence the following cast plus dereference */\n  return strcmp (* (char * const *) p1, * (char * const *) p2);\n}",
        "lines": 8,
        "depth": 11,
        "decorators": [
          "int"
        ]
      }
    ],
    "cmp_long_double": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "int _GL_ATTRIBUTE_PURE\ncmp_long_double (const void *p1, const void *p2)\n{\n  const long double *a = (const long double *)p1;\n  const long double *b = (const long double *)p2;\n  return ( *a > *b ) - (*a < *b);\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "int",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "median_value": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "long double _GL_ATTRIBUTE_PURE\nmedian_value (const long double * const values, size_t n)\n{\n#if 0\n  return percentile_value (values, n, 2.0/4.0);\n#else\n  /* Equivalent to the above, but slightly faster */\n  return (n&0x01)\n    ?values[n/2]\n    :( (values[n/2-1] + values[n/2]) / 2.0 );\n#endif\n}",
      "lines": 12,
      "depth": 14,
      "decorators": [
        "long double",
        "long",
        "double",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "percentile_value": {
      "start_point": [
        73,
        0
      ],
      "end_point": [
        87,
        1
      ],
      "content": "long double _GL_ATTRIBUTE_PURE\npercentile_value (const long double * const values,\n                  const size_t n, const double percentile)\n{\n  const double h = ( (n-1) * percentile ) ;\n  const size_t fh = floor (h);\n\n  /* Error in the calling parameters, should not happen */\n  assert (n>0 && percentile>=0.0 && percentile<=100.0); /* LCOV_EXCL_LINE */\n\n  if (n==1)\n    return values[0];\n\n  return values[fh] + (h-fh) * ( values[fh+1] - values[fh] ) ;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "long double",
        "long",
        "double",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "arithmetic_mean_value": {
      "start_point": [
        106,
        0
      ],
      "end_point": [
        115,
        1
      ],
      "content": "long double _GL_ATTRIBUTE_PURE\narithmetic_mean_value (const long double * const values, const size_t n)\n{\n  long double sum=0;\n  long double mean;\n  for (size_t i = 0; i < n; i++)\n    sum += values[i];\n  mean = sum / n ;\n  return mean;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "long double",
        "long",
        "double",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "variance_value": {
      "start_point": [
        117,
        0
      ],
      "end_point": [
        137,
        1
      ],
      "content": "long double _GL_ATTRIBUTE_PURE\nvariance_value (const long double * const values, size_t n, int df)\n{\n  long double sum=0;\n  long double mean;\n  long double variance;\n\n  assert (df>=0); /* LCOV_EXCL_LINE */\n  if ( (size_t)df == n )\n    return nanl (\"\");\n\n  mean = arithmetic_mean_value (values, n);\n\n  sum = 0 ;\n  for (size_t i = 0; i < n; i++)\n    sum += (values[i] - mean) * (values[i] - mean);\n\n  variance = sum / ( n - df );\n\n  return variance;\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "long double",
        "long",
        "double",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "covariance_value": {
      "start_point": [
        139,
        0
      ],
      "end_point": [
        161,
        1
      ],
      "content": "long double _GL_ATTRIBUTE_PURE\ncovariance_value ( const long double * const valuesA,\n                   const long double * const valuesB, size_t n, int df )\n{\n  long double sum=0;\n  long double meanA, meanB;\n  long double covariance;\n\n  assert (df>=0); /* LCOV_EXCL_LINE */\n  if ( (size_t)df == n )\n    return nanl (\"\");\n\n  meanA = arithmetic_mean_value (valuesA, n);\n  meanB = arithmetic_mean_value (valuesB, n);\n\n  sum = 0 ;\n  for (size_t i = 0; i < n; i++)\n    sum += (valuesA[i] - meanA) * (valuesB[i] - meanB);\n\n  covariance = sum / ( n - df );\n\n  return covariance;\n}",
      "lines": 23,
      "depth": 10,
      "decorators": [
        "long double",
        "long",
        "double",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "pearson_corr_value": {
      "start_point": [
        163,
        0
      ],
      "end_point": [
        194,
        1
      ],
      "content": "long double\npearson_corr_value ( const long double * const valuesA,\n                     const long double * const valuesB, size_t n, int df)\n{\n  long double meanA, meanB, sumA=0, sumB=0, sumCo=0;\n  long double sdA, sdB;\n  long double covariance;\n  long double cor;\n\n  assert (df>=0); /* LCOV_EXCL_LINE */\n  if ( (size_t)df == n )\n    return nanl (\"\");\n\n  meanA = arithmetic_mean_value (valuesA, n);\n  meanB = arithmetic_mean_value (valuesB, n);\n\n  for (size_t i = 0; i < n; i++)\n    {\n      const long double a = (valuesA[i] - meanA);\n      const long double b = (valuesB[i] - meanB);\n      sumA += a*a;\n      sumB += b*b;\n      sumCo += a*b;\n    }\n\n  covariance = sumCo/(n-df);\n  sdA = sqrtl (sumA/(n-df));\n  sdB = sqrtl (sumB/(n-df));\n\n  cor = covariance / ( sdA * sdB );\n  return cor;\n}",
      "lines": 32,
      "depth": 10,
      "decorators": [
        "long double",
        "long",
        "double"
      ]
    },
    "stdev_value": {
      "start_point": [
        197,
        0
      ],
      "end_point": [
        201,
        1
      ],
      "content": "long double\nstdev_value (const long double * const values, size_t n, int df)\n{\n  return sqrtl ( variance_value ( values, n, df ) );\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "long double",
        "long",
        "double"
      ]
    },
    "skewness_value": {
      "start_point": [
        207,
        0
      ],
      "end_point": [
        239,
        1
      ],
      "content": "long double\nskewness_value (const long double * const values, size_t n, int df)\n{\n  long double moment2=0;\n  long double moment3=0;\n  long double mean;\n  long double skewness;\n\n  if (n<=1)\n    return nanl (\"\");\n\n  mean = arithmetic_mean_value (values, n);\n\n  for (size_t i = 0; i < n; i++)\n    {\n      const long double t = (values[i] - mean);\n      moment2 += t*t;\n      moment3 += t*t*t;\n    }\n  moment2 /= n;\n  moment3 /= n;\n\n  /* can't use 'powl (moment2,3.0/2.0)' - not all systems have powl */\n  skewness = moment3 / sqrtl (moment2*moment2*moment2);\n  if ( df == DF_SAMPLE )\n    {\n      if (n<=2)\n        return nanl (\"\");\n      skewness = ( sqrtl (n*(n-1)) / (n-2) ) * skewness;\n    }\n\n  return skewness;\n}",
      "lines": 33,
      "depth": 15,
      "decorators": [
        "long double",
        "long",
        "double"
      ]
    },
    "SES_value": {
      "start_point": [
        242,
        0
      ],
      "end_point": [
        249,
        1
      ],
      "content": "long double\nSES_value (size_t n)\n{\n  if (n<=2)\n    return nanl (\"\");\n  return sqrtl ( (long double)(6.0*n*(n-1))\n                  / ((long double)(n-2)*(n+1)*(n+3)) );\n}",
      "lines": 8,
      "depth": 13,
      "decorators": [
        "long double",
        "long",
        "double"
      ]
    },
    "skewnessZ_value": {
      "start_point": [
        252,
        0
      ],
      "end_point": [
        260,
        1
      ],
      "content": "long double\nskewnessZ_value (const long double * const values, size_t n)\n{\n  const long double skew = skewness_value (values,n,DF_SAMPLE);\n  const long double SES = SES_value (n);\n  if (isnan (skew) || isnan (SES) )\n    return nanl (\"\");\n  return skew/SES;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "long double",
        "long",
        "double"
      ]
    },
    "excess_kurtosis_value": {
      "start_point": [
        267,
        0
      ],
      "end_point": [
        301,
        1
      ],
      "content": "long double _GL_ATTRIBUTE_PURE\nexcess_kurtosis_value (const long double * const values, size_t n, int df)\n{\n  long double moment2=0;\n  long double moment4=0;\n  long double mean;\n  long double excess_kurtosis;\n\n  if (n<=1)\n    return nanl (\"\");\n\n  mean = arithmetic_mean_value (values, n);\n\n  for (size_t i = 0; i < n; i++)\n    {\n      const long double t = (values[i] - mean);\n      moment2 += t*t;\n      moment4 += t*t*t*t;\n    }\n  moment2 /= n;\n  moment4 /= n;\n\n  excess_kurtosis = moment4 / (moment2*moment2) - 3;\n\n  if ( df == DF_SAMPLE )\n    {\n      if (n<=3)\n        return nanl (\"\");\n      excess_kurtosis = ( ((long double)n-1)\n                          / (((long double)n-2)*((long double)n-3)) ) *\n                          ( (n+1)*excess_kurtosis + 6 ) ;\n    }\n\n  return excess_kurtosis;\n}",
      "lines": 35,
      "depth": 17,
      "decorators": [
        "long double",
        "long",
        "double",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "SEK_value": {
      "start_point": [
        304,
        0
      ],
      "end_point": [
        314,
        1
      ],
      "content": "long double\nSEK_value (size_t n)\n{\n  const long double ses = SES_value (n);\n\n  if (n<=3)\n    return nanl (\"\");\n\n   return 2 * ses * sqrtl ( (long double)(n*n-1)\n                            / ((long double)((n-3)*(n+5)))  );\n}",
      "lines": 11,
      "depth": 14,
      "decorators": [
        "long double",
        "long",
        "double"
      ]
    },
    "kurtosisZ_value": {
      "start_point": [
        317,
        0
      ],
      "end_point": [
        325,
        1
      ],
      "content": "long double\nkurtosisZ_value (const long double * const values, size_t n)\n{\n  const long double kurt = excess_kurtosis_value (values,n,DF_SAMPLE);\n  const long double SEK = SEK_value (n);\n  if (isnan (kurt) || isnan (SEK) )\n    return nanl (\"\");\n  return kurt/SEK;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "long double",
        "long",
        "double"
      ]
    },
    "pchisq_df2": {
      "start_point": [
        332,
        0
      ],
      "end_point": [
        336,
        1
      ],
      "content": "long double\npchisq_df2 (long double x)\n{\n  return 1.0 - expl (-x/2);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "long double",
        "long",
        "double"
      ]
    },
    "jarque_bera_pvalue": {
      "start_point": [
        344,
        0
      ],
      "end_point": [
        354,
        1
      ],
      "content": "long double\njarque_bera_pvalue (const long double * const values, size_t n )\n{\n  const long double k = excess_kurtosis_value (values,n,DF_POPULATION);\n  const long double s = skewness_value (values,n,DF_POPULATION);\n  const long double jb = (long double)(n*(s*s + k*k/4))/6.0 ;\n  const long double pval = 1.0 - pchisq_df2 (jb);\n  if (n<=1 || isnan (k) || isnan (s))\n    return nanl (\"\");\n  return pval;\n}",
      "lines": 11,
      "depth": 13,
      "decorators": [
        "long double",
        "long",
        "double"
      ]
    },
    "dagostino_pearson_omnibus_pvalue": {
      "start_point": [
        361,
        0
      ],
      "end_point": [
        372,
        1
      ],
      "content": "long double\ndagostino_pearson_omnibus_pvalue (const long double * const values, size_t n)\n{\n  const long double z_skew = skewnessZ_value (values, n);\n  const long double z_kurt = kurtosisZ_value (values, n);\n  const long double DP = z_skew*z_skew + z_kurt*z_kurt;\n  const long double pval = 1.0 - pchisq_df2 (DP);\n\n  if (isnan (z_skew) || isnan (z_kurt))\n    return nanl (\"\");\n  return pval;\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "long double",
        "long",
        "double"
      ]
    },
    "trimmed_mean_value": {
      "start_point": [
        407,
        0
      ],
      "end_point": [
        427,
        1
      ],
      "content": "long double  _GL_ATTRIBUTE_PURE\ntrimmed_mean_value ( const long double * const values, size_t n,\n\t\t     const long double trimmed_mean_percent)\n{\n  assert (trimmed_mean_percent >= 0); /* LCOV_EXCL_LINE */\n  assert (trimmed_mean_percent <= 0.5); /* LCOV_EXCL_LINE */\n\n  /* For R compatability:\n     mean (x,trim=0.5) in R is equivalent to median (x).  */\n  if (trimmed_mean_percent >= 0.5)\n    return median_value (values, n);\n\n  /* number of element to skip from each end */\n  size_t c = pos_zero (floorl (trimmed_mean_percent * n));\n\n  long double v = 0;\n  for (size_t i=c; i< (n-c); i++)\n    v += values[i];\n\n  return v / (long double)(n-c*2);\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "long double",
        "long",
        "double",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "cmpstringp_nocase": {
      "start_point": [
        439,
        0
      ],
      "end_point": [
        446,
        1
      ],
      "content": "int _GL_ATTRIBUTE_PURE\ncmpstringp_nocase (const void *p1, const void *p2)\n{\n  /* The actual arguments to this function are \"pointers to\n   * pointers to char\", but strcmp (3) arguments are \"pointers\n   * to char\", hence the following cast plus dereference */\n  return strcasecmp (* (char * const *) p1, * (char * const *) p2);\n}",
      "lines": 8,
      "depth": 11,
      "decorators": [
        "int",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "qsortfl": {
      "start_point": [
        449,
        0
      ],
      "end_point": [
        452,
        1
      ],
      "content": "void qsortfl (long double *values, size_t n)\n{\n  qsort (values, n, sizeof (long double), cmp_long_double);\n}",
      "lines": 4,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "hash_compare_strings": {
      "start_point": [
        454,
        0
      ],
      "end_point": [
        459,
        1
      ],
      "content": "bool _GL_ATTRIBUTE_PURE\nhash_compare_strings (void const *x, void const *y)\n{\n  assert (x != y); /* LCOV_EXCL_LINE */\n  return STREQ (x, y) ? true : false;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "bool",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    }
  },
  "datamash/datamash-1.3/src/utils.h": {
    "quartile1_value": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "static inline long double\nquartile1_value (const long double * const values, size_t n)\n{\n  return percentile_value (values, n, 1.0/4.0);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "long double",
        "long",
        "double"
      ]
    },
    "quartile3_value": {
      "start_point": [
        63,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "static inline long double\nquartile3_value (const long double * const values, size_t n)\n{\n  return percentile_value (values, n, 3.0/4.0);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "long double",
        "long",
        "double"
      ]
    },
    "is_zero": {
      "start_point": [
        209,
        0
      ],
      "end_point": [
        213,
        1
      ],
      "content": "static inline bool\nis_zero (const long double a)\n{\n  return !((a>0)-(a<0));\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "bool"
      ]
    },
    "is_signed_zero": {
      "start_point": [
        216,
        0
      ],
      "end_point": [
        220,
        1
      ],
      "content": "static inline bool\nis_signed_zero (const long double a)\n{\n  return signbit (a) && is_zero (a);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "bool"
      ]
    },
    "pos_zero": {
      "start_point": [
        224,
        0
      ],
      "end_point": [
        228,
        1
      ],
      "content": "static inline long double\npos_zero (const long double a)\n{\n  return is_signed_zero (a) ? 0 : a;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "long double",
        "long",
        "double"
      ]
    }
  }
}